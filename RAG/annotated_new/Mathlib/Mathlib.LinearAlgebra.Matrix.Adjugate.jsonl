{"name":"Matrix.cramerMap_is_linear","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\ni : n\n⊢ IsLinearMap α fun b => A.cramerMap b i","decl":"theorem cramerMap_is_linear (i : n) : IsLinearMap α fun b => cramerMap A b i :=\n  { map_add := det_updateCol_add _ _\n    map_smul := det_updateCol_smul _ _ }\n\n"}
{"name":"Matrix.cramer_is_linear","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ IsLinearMap α A.cramerMap","decl":"theorem cramer_is_linear : IsLinearMap α (cramerMap A) := by\n  constructor <;> intros <;> ext i\n  · apply (cramerMap_is_linear A i).1\n  · apply (cramerMap_is_linear A i).2\n\n"}
{"name":"Matrix.cramer_apply","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nb : n → α\ni : n\n⊢ Eq (A.cramer b i) (A.updateCol i b).det","decl":"theorem cramer_apply (i : n) : cramer A b i = (A.updateCol i b).det :=\n  rfl\n\n"}
{"name":"Matrix.cramer_transpose_apply","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nb : n → α\ni : n\n⊢ Eq (A.transpose.cramer b i) (A.updateRow i b).det","decl":"theorem cramer_transpose_apply (i : n) : cramer Aᵀ b i = (A.updateRow i b).det := by\n  rw [cramer_apply, updateCol_transpose, det_transpose]\n\n"}
{"name":"Matrix.cramer_transpose_row_self","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\ni : n\n⊢ Eq (A.transpose.cramer (A i)) (Pi.single i A.det)","decl":"theorem cramer_transpose_row_self (i : n) : Aᵀ.cramer (A i) = Pi.single i A.det := by\n  ext j\n  rw [cramer_apply, Pi.single_apply]\n  split_ifs with h\n  · -- i = j: this entry should be `A.det`\n    subst h\n    simp only [updateCol_transpose, det_transpose, updateRow_eq_self]\n  · -- i ≠ j: this entry should be 0\n    rw [updateCol_transpose, det_transpose]\n    apply det_zero_of_row_eq h\n    rw [updateRow_self, updateRow_ne (Ne.symm h)]\n\n"}
{"name":"Matrix.cramer_row_self","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nb : n → α\ni : n\nh : ∀ (j : n), Eq (b j) (A j i)\n⊢ Eq (A.cramer b) (Pi.single i A.det)","decl":"theorem cramer_row_self (i : n) (h : ∀ j, b j = A j i) : A.cramer b = Pi.single i A.det := by\n  rw [← transpose_transpose A, det_transpose]\n  convert cramer_transpose_row_self Aᵀ i\n  exact funext h\n\n"}
{"name":"Matrix.cramer_one","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\n⊢ Eq (Matrix.cramer 1) 1","decl":"@[simp]\ntheorem cramer_one : cramer (1 : Matrix n n α) = 1 := by\n  ext i j\n  convert congr_fun (cramer_row_self (1 : Matrix n n α) (Pi.single i 1) i _) j\n  · simp\n  · intro j\n    rw [Matrix.one_eq_pi_single, Pi.single_comm]\n\n"}
{"name":"Matrix.cramer_smul","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nr : α\nA : Matrix n n α\n⊢ Eq (HSMul.hSMul r A).cramer (HSMul.hSMul (HPow.hPow r (HSub.hSub (Fintype.card n) 1)) A.cramer)","decl":"theorem cramer_smul (r : α) (A : Matrix n n α) :\n    cramer (r • A) = r ^ (Fintype.card n - 1) • cramer A :=\n  LinearMap.ext fun _ => funext fun _ => det_updateCol_smul_left _ _ _ _\n\n"}
{"name":"Matrix.cramer_subsingleton_apply","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : CommRing α\ninst✝ : Subsingleton n\nA : Matrix n n α\nb : n → α\ni : n\n⊢ Eq (A.cramer b i) (b i)","decl":"@[simp]\ntheorem cramer_subsingleton_apply [Subsingleton n] (A : Matrix n n α) (b : n → α) (i : n) :\n    cramer A b i = b i := by rw [cramer_apply, det_eq_elem_of_subsingleton _ i, updateCol_self]\n\n"}
{"name":"Matrix.cramer_zero","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : CommRing α\ninst✝ : Nontrivial n\n⊢ Eq (Matrix.cramer 0) 0","decl":"theorem cramer_zero [Nontrivial n] : cramer (0 : Matrix n n α) = 0 := by\n  ext i j\n  obtain ⟨j', hj'⟩ : ∃ j', j' ≠ j := exists_ne j\n  apply det_eq_zero_of_column_eq_zero j'\n  intro j''\n  simp [updateCol_ne hj']\n\n"}
{"name":"Matrix.sum_cramer","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nβ : Type u_1\ns : Finset β\nf : β → n → α\n⊢ Eq (s.sum fun x => A.cramer (f x)) (A.cramer (s.sum fun x => f x))","decl":"/-- Use linearity of `cramer` to take it out of a summation. -/\ntheorem sum_cramer {β} (s : Finset β) (f : β → n → α) :\n    (∑ x ∈ s, cramer A (f x)) = cramer A (∑ x ∈ s, f x) :=\n  (map_sum (cramer A) ..).symm\n\n"}
{"name":"Matrix.sum_cramer_apply","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nβ : Type u_1\ns : Finset β\nf : n → β → α\ni : n\n⊢ Eq (s.sum fun x => A.cramer (fun j => f j x) i) (A.cramer (fun j => s.sum fun x => f j x) i)","decl":"/-- Use linearity of `cramer` and vector evaluation to take `cramer A _ i` out of a summation. -/\ntheorem sum_cramer_apply {β} (s : Finset β) (f : n → β → α) (i : n) :\n    (∑ x ∈ s, cramer A (fun j => f j x) i) = cramer A (fun j : n => ∑ x ∈ s, f j x) i :=\n  calc\n    (∑ x ∈ s, cramer A (fun j => f j x) i) = (∑ x ∈ s, cramer A fun j => f j x) i :=\n      (Finset.sum_apply i s _).symm\n    _ = cramer A (fun j : n => ∑ x ∈ s, f j x) i := by\n      rw [sum_cramer, cramer_apply, cramer_apply]\n      simp only [updateCol]\n      congr with j\n      congr\n      apply Finset.sum_apply\n\n"}
{"name":"Matrix.cramer_submatrix_equiv","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"m : Type u\nn : Type v\nα : Type w\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\ninst✝ : CommRing α\nA : Matrix m m α\ne : Equiv n m\nb : n → α\n⊢ Eq ((A.submatrix ⇑e ⇑e).cramer b) (Function.comp (A.cramer (Function.comp b ⇑e.symm)) ⇑e)","decl":"theorem cramer_submatrix_equiv (A : Matrix m m α) (e : n ≃ m) (b : n → α) :\n    cramer (A.submatrix e e) b = cramer A (b ∘ e.symm) ∘ e := by\n  ext i\n  simp_rw [Function.comp_apply, cramer_apply, updateCol_submatrix_equiv,\n    det_submatrix_equiv_self e, Function.comp_def]\n\n"}
{"name":"Matrix.cramer_reindex","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"m : Type u\nn : Type v\nα : Type w\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\ninst✝ : CommRing α\ne : Equiv m n\nA : Matrix m m α\nb : n → α\n⊢ Eq (((Matrix.reindex e e) A).cramer b) (Function.comp (A.cramer (Function.comp b ⇑e)) ⇑e.symm)","decl":"theorem cramer_reindex (e : m ≃ n) (A : Matrix m m α) (b : n → α) :\n    cramer (reindex e e A) b = cramer A (b ∘ e) ∘ e.symm :=\n  cramer_submatrix_equiv _ _ _\n\n"}
{"name":"Matrix.adjugate_def","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq A.adjugate (Matrix.of fun i => A.transpose.cramer (Pi.single i 1))","decl":"theorem adjugate_def (A : Matrix n n α) : adjugate A = of fun i => cramer Aᵀ (Pi.single i 1) :=\n  rfl\n\n"}
{"name":"Matrix.adjugate_apply","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\ni j : n\n⊢ Eq (A.adjugate i j) (A.updateRow j (Pi.single i 1)).det","decl":"theorem adjugate_apply (A : Matrix n n α) (i j : n) :\n    adjugate A i j = (A.updateRow j (Pi.single i 1)).det := by\n  rw [adjugate_def, of_apply, cramer_apply, updateCol_transpose, det_transpose]\n\n"}
{"name":"Matrix.adjugate_transpose","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq A.adjugate.transpose A.transpose.adjugate","decl":"theorem adjugate_transpose (A : Matrix n n α) : (adjugate A)ᵀ = adjugate Aᵀ := by\n  ext i j\n  rw [transpose_apply, adjugate_apply, adjugate_apply, updateRow_transpose, det_transpose]\n  rw [det_apply', det_apply']\n  apply Finset.sum_congr rfl\n  intro σ _\n  congr 1\n  by_cases h : i = σ j\n  · -- Everything except `(i , j)` (= `(σ j , j)`) is given by A, and the rest is a single `1`.\n    congr\n    ext j'\n    subst h\n    have : σ j' = σ j ↔ j' = j := σ.injective.eq_iff\n    rw [updateRow_apply, updateCol_apply]\n    simp_rw [this]\n    rw [← dite_eq_ite, ← dite_eq_ite]\n    congr 1 with rfl\n    rw [Pi.single_eq_same, Pi.single_eq_same]\n  · -- Otherwise, we need to show that there is a `0` somewhere in the product.\n    have : (∏ j' : n, updateCol A j (Pi.single i 1) (σ j') j') = 0 := by\n      apply prod_eq_zero (mem_univ j)\n      rw [updateCol_self, Pi.single_eq_of_ne' h]\n    rw [this]\n    apply prod_eq_zero (mem_univ (σ⁻¹ i))\n    erw [apply_symm_apply σ i, updateRow_self]\n    apply Pi.single_eq_of_ne\n    intro h'\n    exact h ((symm_apply_eq σ).mp h')\n\n"}
{"name":"Matrix.adjugate_submatrix_equiv_self","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"m : Type u\nn : Type v\nα : Type w\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\ninst✝ : CommRing α\ne : Equiv n m\nA : Matrix m m α\n⊢ Eq (A.submatrix ⇑e ⇑e).adjugate (A.adjugate.submatrix ⇑e ⇑e)","decl":"@[simp]\ntheorem adjugate_submatrix_equiv_self (e : n ≃ m) (A : Matrix m m α) :\n    adjugate (A.submatrix e e) = (adjugate A).submatrix e e := by\n  ext i j\n  rw [adjugate_apply, submatrix_apply, adjugate_apply, ← det_submatrix_equiv_self e,\n    updateRow_submatrix_equiv]\n  -- Porting note: added\n  suffices (fun j => Pi.single i 1 (e.symm j)) = Pi.single (e i) 1 by\n    erw [this]\n  exact Function.update_comp_equiv _ e.symm _ _\n\n"}
{"name":"Matrix.adjugate_reindex","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"m : Type u\nn : Type v\nα : Type w\ninst✝⁴ : DecidableEq n\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : Fintype m\ninst✝ : CommRing α\ne : Equiv m n\nA : Matrix m m α\n⊢ Eq ((Matrix.reindex e e) A).adjugate ((Matrix.reindex e e) A.adjugate)","decl":"theorem adjugate_reindex (e : m ≃ n) (A : Matrix m m α) :\n    adjugate (reindex e e A) = reindex e e (adjugate A) :=\n  adjugate_submatrix_equiv_self _ _\n\n"}
{"name":"Matrix.cramer_eq_adjugate_mulVec","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nb : n → α\n⊢ Eq (A.cramer b) (A.adjugate.mulVec b)","decl":"/-- Since the map `b ↦ cramer A b` is linear in `b`, it must be multiplication by some matrix. This\nmatrix is `A.adjugate`. -/\ntheorem cramer_eq_adjugate_mulVec (A : Matrix n n α) (b : n → α) :\n    cramer A b = A.adjugate *ᵥ b := by\n  nth_rw 2 [← A.transpose_transpose]\n  rw [← adjugate_transpose, adjugate_def]\n  have : b = ∑ i, b i • (Pi.single i 1 : n → α) := by\n    refine (pi_eq_sum_univ b).trans ?_\n    congr with j\n    -- Porting note: needed to help `Pi.smul_apply`\n    simp [Pi.single_apply, eq_comm, Pi.smul_apply (b j)]\n  conv_lhs =>\n    rw [this]\n  ext k\n  simp [mulVec, dotProduct, mul_comm]\n\n"}
{"name":"Matrix.mul_adjugate_apply","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\ni j k : n\n⊢ Eq (HMul.hMul (A i k) (A.adjugate k j)) (A.transpose.cramer (Pi.single k (A i k)) j)","decl":"theorem mul_adjugate_apply (A : Matrix n n α) (i j k) :\n    A i k * adjugate A k j = cramer Aᵀ (Pi.single k (A i k)) j := by\n  rw [← smul_eq_mul, adjugate, of_apply, ← Pi.smul_apply, ← LinearMap.map_smul, ← Pi.single_smul',\n    smul_eq_mul, mul_one]\n\n"}
{"name":"Matrix.mul_adjugate","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq (HMul.hMul A A.adjugate) (HSMul.hSMul A.det 1)","decl":"theorem mul_adjugate (A : Matrix n n α) : A * adjugate A = A.det • (1 : Matrix n n α) := by\n  ext i j\n  rw [mul_apply, Pi.smul_apply, Pi.smul_apply, one_apply, smul_eq_mul, mul_boole]\n  simp [mul_adjugate_apply, sum_cramer_apply, cramer_transpose_row_self, Pi.single_apply, eq_comm]\n\n"}
{"name":"Matrix.adjugate_mul","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq (HMul.hMul A.adjugate A) (HSMul.hSMul A.det 1)","decl":"theorem adjugate_mul (A : Matrix n n α) : adjugate A * A = A.det • (1 : Matrix n n α) :=\n  calc\n    adjugate A * A = (Aᵀ * adjugate Aᵀ)ᵀ := by\n      rw [← adjugate_transpose, ← transpose_mul, transpose_transpose]\n    _ = _ := by rw [mul_adjugate Aᵀ, det_transpose, transpose_smul, transpose_one]\n\n"}
{"name":"Matrix.adjugate_smul","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nr : α\nA : Matrix n n α\n⊢ Eq (HSMul.hSMul r A).adjugate (HSMul.hSMul (HPow.hPow r (HSub.hSub (Fintype.card n) 1)) A.adjugate)","decl":"theorem adjugate_smul (r : α) (A : Matrix n n α) :\n    adjugate (r • A) = r ^ (Fintype.card n - 1) • adjugate A := by\n  rw [adjugate, adjugate, transpose_smul, cramer_smul]\n  rfl\n\n"}
{"name":"Matrix.mulVec_cramer","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nb : n → α\n⊢ Eq (A.mulVec (A.cramer b)) (HSMul.hSMul A.det b)","decl":"/-- A stronger form of **Cramer's rule** that allows us to solve some instances of `A * x = b` even\nif the determinant is not a unit. A sufficient (but still not necessary) condition is that `A.det`\ndivides `b`. -/\n@[simp]\ntheorem mulVec_cramer (A : Matrix n n α) (b : n → α) : A *ᵥ cramer A b = A.det • b := by\n  rw [cramer_eq_adjugate_mulVec, mulVec_mulVec, mul_adjugate, smul_mulVec_assoc, one_mulVec]\n\n"}
{"name":"Matrix.adjugate_subsingleton","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : CommRing α\ninst✝ : Subsingleton n\nA : Matrix n n α\n⊢ Eq A.adjugate 1","decl":"theorem adjugate_subsingleton [Subsingleton n] (A : Matrix n n α) : adjugate A = 1 := by\n  ext i j\n  simp [Subsingleton.elim i j, adjugate_apply, det_eq_elem_of_subsingleton _ i, one_apply]\n\n"}
{"name":"Matrix.adjugate_eq_one_of_card_eq_one","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nh : Eq (Fintype.card n) 1\n⊢ Eq A.adjugate 1","decl":"theorem adjugate_eq_one_of_card_eq_one {A : Matrix n n α} (h : Fintype.card n = 1) :\n    adjugate A = 1 :=\n  haveI : Subsingleton n := Fintype.card_le_one_iff_subsingleton.mp h.le\n  adjugate_subsingleton _\n\n"}
{"name":"Matrix.adjugate_zero","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : CommRing α\ninst✝ : Nontrivial n\n⊢ Eq (Matrix.adjugate 0) 0","decl":"@[simp]\ntheorem adjugate_zero [Nontrivial n] : adjugate (0 : Matrix n n α) = 0 := by\n  ext i j\n  obtain ⟨j', hj'⟩ : ∃ j', j' ≠ j := exists_ne j\n  apply det_eq_zero_of_column_eq_zero j'\n  intro j''\n  simp [updateCol_ne hj']\n\n"}
{"name":"Matrix.adjugate_one","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\n⊢ Eq (Matrix.adjugate 1) 1","decl":"@[simp]\ntheorem adjugate_one : adjugate (1 : Matrix n n α) = 1 := by\n  ext\n  simp [adjugate_def, Matrix.one_apply, Pi.single_apply, eq_comm]\n\n"}
{"name":"Matrix.adjugate_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nv : n → α\n⊢ Eq (Matrix.diagonal v).adjugate (Matrix.diagonal fun i => (Finset.univ.erase i).prod fun j => v j)","decl":"@[simp]\ntheorem adjugate_diagonal (v : n → α) :\n    adjugate (diagonal v) = diagonal fun i => ∏ j ∈ Finset.univ.erase i, v j := by\n  ext i j\n  simp only [adjugate_def, cramer_apply, diagonal_transpose, of_apply]\n  obtain rfl | hij := eq_or_ne i j\n  · rw [diagonal_apply_eq, diagonal_updateCol_single, det_diagonal,\n      prod_update_of_mem (Finset.mem_univ _), sdiff_singleton_eq_erase, one_mul]\n  · rw [diagonal_apply_ne _ hij]\n    refine det_eq_zero_of_row_eq_zero j fun k => ?_\n    obtain rfl | hjk := eq_or_ne k j\n    · rw [updateCol_self, Pi.single_eq_of_ne' hij]\n    · rw [updateCol_ne hjk, diagonal_apply_ne' _ hjk]\n\n"}
{"name":"RingHom.map_adjugate","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nR : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nM : Matrix n n R\n⊢ Eq (f.mapMatrix M.adjugate) (f.mapMatrix M).adjugate","decl":"theorem _root_.RingHom.map_adjugate {R S : Type*} [CommRing R] [CommRing S] (f : R →+* S)\n    (M : Matrix n n R) : f.mapMatrix M.adjugate = Matrix.adjugate (f.mapMatrix M) := by\n  ext i k\n  have : Pi.single i (1 : S) = f ∘ Pi.single i 1 := by\n    rw [← f.map_one]\n    exact Pi.single_op (fun _ => f) (fun _ => f.map_zero) i (1 : R)\n  rw [adjugate_apply, RingHom.mapMatrix_apply, map_apply, RingHom.mapMatrix_apply, this, ←\n    map_updateRow, ← RingHom.mapMatrix_apply, ← RingHom.map_det, ← adjugate_apply]\n\n"}
{"name":"AlgHom.map_adjugate","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\ninst✝⁶ : DecidableEq n\ninst✝⁵ : Fintype n\nR : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nM : Matrix n n A\n⊢ Eq (f.mapMatrix M.adjugate) (f.mapMatrix M).adjugate","decl":"theorem _root_.AlgHom.map_adjugate {R A B : Type*} [CommSemiring R] [CommRing A] [CommRing B]\n    [Algebra R A] [Algebra R B] (f : A →ₐ[R] B) (M : Matrix n n A) :\n    f.mapMatrix M.adjugate = Matrix.adjugate (f.mapMatrix M) :=\n  f.toRingHom.map_adjugate _\n\n"}
{"name":"Matrix.det_adjugate","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq A.adjugate.det (HPow.hPow A.det (HSub.hSub (Fintype.card n) 1))","decl":"theorem det_adjugate (A : Matrix n n α) : (adjugate A).det = A.det ^ (Fintype.card n - 1) := by\n  -- get rid of the `- 1`\n  rcases (Fintype.card n).eq_zero_or_pos with h_card | h_card\n  · haveI : IsEmpty n := Fintype.card_eq_zero_iff.mp h_card\n    rw [h_card, Nat.zero_sub, pow_zero, adjugate_subsingleton, det_one]\n  replace h_card := tsub_add_cancel_of_le h_card.nat_succ_le\n  -- express `A` as an evaluation of a polynomial in n^2 variables, and solve in the polynomial ring\n  -- where `A'.det` is non-zero.\n  let A' := mvPolynomialX n n ℤ\n  suffices A'.adjugate.det = A'.det ^ (Fintype.card n - 1) by\n    rw [← mvPolynomialX_mapMatrix_aeval ℤ A, ← AlgHom.map_adjugate, ← AlgHom.map_det, ←\n      AlgHom.map_det, ← map_pow, this]\n  apply mul_left_cancel₀ (show A'.det ≠ 0 from det_mvPolynomialX_ne_zero n ℤ)\n  calc\n    A'.det * A'.adjugate.det = (A' * adjugate A').det := (det_mul _ _).symm\n    _ = A'.det ^ Fintype.card n := by rw [mul_adjugate, det_smul, det_one, mul_one]\n    _ = A'.det * A'.det ^ (Fintype.card n - 1) := by rw [← pow_succ', h_card]\n\n"}
{"name":"Matrix.adjugate_fin_zero","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"α : Type w\ninst✝ : CommRing α\nA : Matrix (Fin 0) (Fin 0) α\n⊢ Eq A.adjugate 0","decl":"@[simp]\ntheorem adjugate_fin_zero (A : Matrix (Fin 0) (Fin 0) α) : adjugate A = 0 :=\n  Subsingleton.elim _ _\n\n"}
{"name":"Matrix.adjugate_fin_one","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"α : Type w\ninst✝ : CommRing α\nA : Matrix (Fin 1) (Fin 1) α\n⊢ Eq A.adjugate 1","decl":"@[simp]\ntheorem adjugate_fin_one (A : Matrix (Fin 1) (Fin 1) α) : adjugate A = 1 :=\n  adjugate_subsingleton A\n\n"}
{"name":"Matrix.adjugate_fin_succ_eq_det_submatrix","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"α : Type w\ninst✝ : CommRing α\nn : Nat\nA : Matrix (Fin n.succ) (Fin n.succ) α\ni j : Fin n.succ\n⊢ Eq (A.adjugate i j) (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd ↑j ↑i)) (A.submatrix j.succAbove i.succAbove).det)","decl":"theorem adjugate_fin_succ_eq_det_submatrix {n : ℕ} (A : Matrix (Fin n.succ) (Fin n.succ) α) (i j) :\n    adjugate A i j = (-1) ^ (j + i : ℕ) * det (A.submatrix j.succAbove i.succAbove) := by\n  simp_rw [adjugate_apply, det_succ_row _ j, updateRow_self, submatrix_updateRow_succAbove]\n  rw [Fintype.sum_eq_single i fun h hjk => ?_, Pi.single_eq_same, mul_one]\n  rw [Pi.single_eq_of_ne hjk, mul_zero, zero_mul]\n\n"}
{"name":"Matrix.adjugate_fin_two","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"α : Type w\ninst✝ : CommRing α\nA : Matrix (Fin 2) (Fin 2) α\n⊢ Eq A.adjugate (Matrix.of (Matrix.vecCons (Matrix.vecCons (A 1 1) (Matrix.vecCons (Neg.neg (A 0 1)) Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons (Neg.neg (A 1 0)) (Matrix.vecCons (A 0 0) Matrix.vecEmpty)) Matrix.vecEmpty)))","decl":"theorem adjugate_fin_two (A : Matrix (Fin 2) (Fin 2) α) :\n    adjugate A = !![A 1 1, -A 0 1; -A 1 0, A 0 0] := by\n  ext i j\n  rw [adjugate_fin_succ_eq_det_submatrix]\n  fin_cases i <;> fin_cases j <;> simp\n\n"}
{"name":"Matrix.adjugate_fin_two_of","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"α : Type w\ninst✝ : CommRing α\na b c d : α\n⊢ Eq (Matrix.of (Matrix.vecCons (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons c (Matrix.vecCons d Matrix.vecEmpty)) Matrix.vecEmpty))).adjugate (Matrix.of (Matrix.vecCons (Matrix.vecCons d (Matrix.vecCons (Neg.neg b) Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons (Neg.neg c) (Matrix.vecCons a Matrix.vecEmpty)) Matrix.vecEmpty)))","decl":"@[simp]\ntheorem adjugate_fin_two_of (a b c d : α) : adjugate !![a, b; c, d] = !![d, -b; -c, a] :=\n  adjugate_fin_two _\n\n"}
{"name":"Matrix.adjugate_fin_three","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"α : Type w\ninst✝ : CommRing α\nA : Matrix (Fin 3) (Fin 3) α\n⊢ Eq A.adjugate (Matrix.of (Matrix.vecCons (Matrix.vecCons (HSub.hSub (HMul.hMul (A 1 1) (A 2 2)) (HMul.hMul (A 1 2) (A 2 1))) (Matrix.vecCons (HAdd.hAdd (Neg.neg (HMul.hMul (A 0 1) (A 2 2))) (HMul.hMul (A 0 2) (A 2 1))) (Matrix.vecCons (HSub.hSub (HMul.hMul (A 0 1) (A 1 2)) (HMul.hMul (A 0 2) (A 1 1))) Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons (HAdd.hAdd (Neg.neg (HMul.hMul (A 1 0) (A 2 2))) (HMul.hMul (A 1 2) (A 2 0))) (Matrix.vecCons (HSub.hSub (HMul.hMul (A 0 0) (A 2 2)) (HMul.hMul (A 0 2) (A 2 0))) (Matrix.vecCons (HAdd.hAdd (Neg.neg (HMul.hMul (A 0 0) (A 1 2))) (HMul.hMul (A 0 2) (A 1 0))) Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons (HSub.hSub (HMul.hMul (A 1 0) (A 2 1)) (HMul.hMul (A 1 1) (A 2 0))) (Matrix.vecCons (HAdd.hAdd (Neg.neg (HMul.hMul (A 0 0) (A 2 1))) (HMul.hMul (A 0 1) (A 2 0))) (Matrix.vecCons (HSub.hSub (HMul.hMul (A 0 0) (A 1 1)) (HMul.hMul (A 0 1) (A 1 0))) Matrix.vecEmpty))) Matrix.vecEmpty))))","decl":"theorem adjugate_fin_three (A : Matrix (Fin 3) (Fin 3) α) :\n    adjugate A =\n    !![A 1 1 * A 2 2 - A 1 2 * A 2 1,\n      -(A 0 1 * A 2 2) + A 0 2 * A 2 1,\n      A 0 1 * A 1 2 - A 0 2 * A 1 1;\n      -(A 1 0 * A 2 2) + A 1 2 * A 2 0,\n      A 0 0 * A 2 2 - A 0 2 * A 2 0,\n      -(A 0 0 * A 1 2) + A 0 2 * A 1 0;\n      A 1 0 * A 2 1 - A 1 1 * A 2 0,\n      -(A 0 0 * A 2 1) + A 0 1 * A 2 0,\n      A 0 0 * A 1 1 - A 0 1 * A 1 0] := by\n  ext i j\n  rw [adjugate_fin_succ_eq_det_submatrix, det_fin_two]\n  fin_cases i <;> fin_cases j <;> simp [updateRow, Fin.succAbove, Fin.lt_def] <;> ring\n\n"}
{"name":"Matrix.adjugate_fin_three_of","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"α : Type w\ninst✝ : CommRing α\na b c d e f g h i : α\n⊢ Eq (Matrix.of (Matrix.vecCons (Matrix.vecCons a (Matrix.vecCons b (Matrix.vecCons c Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons d (Matrix.vecCons e (Matrix.vecCons f Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons g (Matrix.vecCons h (Matrix.vecCons i Matrix.vecEmpty))) Matrix.vecEmpty)))).adjugate (Matrix.of (Matrix.vecCons (Matrix.vecCons (HSub.hSub (HMul.hMul e i) (HMul.hMul f h)) (Matrix.vecCons (HAdd.hAdd (Neg.neg (HMul.hMul b i)) (HMul.hMul c h)) (Matrix.vecCons (HSub.hSub (HMul.hMul b f) (HMul.hMul c e)) Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons (HAdd.hAdd (Neg.neg (HMul.hMul d i)) (HMul.hMul f g)) (Matrix.vecCons (HSub.hSub (HMul.hMul a i) (HMul.hMul c g)) (Matrix.vecCons (HAdd.hAdd (Neg.neg (HMul.hMul a f)) (HMul.hMul c d)) Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons (HSub.hSub (HMul.hMul d h) (HMul.hMul e g)) (Matrix.vecCons (HAdd.hAdd (Neg.neg (HMul.hMul a h)) (HMul.hMul b g)) (Matrix.vecCons (HSub.hSub (HMul.hMul a e) (HMul.hMul b d)) Matrix.vecEmpty))) Matrix.vecEmpty))))","decl":"@[simp]\ntheorem adjugate_fin_three_of (a b c d e f g h i : α) :\n    adjugate !![a, b, c; d, e, f; g, h, i] =\n      !![  e * i  - f * h, -(b * i) + c * h,   b * f  - c * e;\n         -(d * i) + f * g,   a * i  - c * g, -(a * f) + c * d;\n           d * h  - e * g, -(a * h) + b * g,   a * e  - b * d] :=\n  adjugate_fin_three _\n\n"}
{"name":"Matrix.det_eq_sum_mul_adjugate_row","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\ni : n\n⊢ Eq A.det (Finset.univ.sum fun j => HMul.hMul (A i j) (A.adjugate j i))","decl":"theorem det_eq_sum_mul_adjugate_row (A : Matrix n n α) (i : n) :\n    det A = ∑ j : n, A i j * adjugate A j i := by\n  haveI : Nonempty n := ⟨i⟩\n  obtain ⟨n', hn'⟩ := Nat.exists_eq_succ_of_ne_zero (Fintype.card_ne_zero : Fintype.card n ≠ 0)\n  obtain ⟨e⟩ := Fintype.truncEquivFinOfCardEq hn'\n  let A' := reindex e e A\n  suffices det A' = ∑ j : Fin n'.succ, A' (e i) j * adjugate A' j (e i) by\n    simp_rw [A', det_reindex_self, adjugate_reindex, reindex_apply, submatrix_apply, ← e.sum_comp,\n      Equiv.symm_apply_apply] at this\n    exact this\n  rw [det_succ_row A' (e i)]\n  simp_rw [mul_assoc, mul_left_comm _ (A' _ _), ← adjugate_fin_succ_eq_det_submatrix]\n\n"}
{"name":"Matrix.det_eq_sum_mul_adjugate_col","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nj : n\n⊢ Eq A.det (Finset.univ.sum fun i => HMul.hMul (A i j) (A.adjugate j i))","decl":"theorem det_eq_sum_mul_adjugate_col (A : Matrix n n α) (j : n) :\n    det A = ∑ i : n, A i j * adjugate A j i := by\n  simpa only [det_transpose, ← adjugate_transpose] using det_eq_sum_mul_adjugate_row Aᵀ j\n\n"}
{"name":"Matrix.adjugate_conjTranspose","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : CommRing α\ninst✝ : StarRing α\nA : Matrix n n α\n⊢ Eq A.adjugate.conjTranspose A.conjTranspose.adjugate","decl":"theorem adjugate_conjTranspose [StarRing α] (A : Matrix n n α) : A.adjugateᴴ = adjugate Aᴴ := by\n  dsimp only [conjTranspose]\n  have : Aᵀ.adjugate.map star = adjugate (Aᵀ.map star) := (starRingEnd α).map_adjugate Aᵀ\n  rw [A.adjugate_transpose, this]\n\n"}
{"name":"Matrix.isRegular_of_isLeftRegular_det","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nhA : IsLeftRegular A.det\n⊢ IsRegular A","decl":"theorem isRegular_of_isLeftRegular_det {A : Matrix n n α} (hA : IsLeftRegular A.det) :\n    IsRegular A := by\n  constructor\n  · intro B C h\n    refine hA.matrix ?_\n    simp only at h ⊢\n    rw [← Matrix.one_mul B, ← Matrix.one_mul C, ← Matrix.smul_mul, ← Matrix.smul_mul, ←\n      adjugate_mul, Matrix.mul_assoc, Matrix.mul_assoc, h]\n  · intro B C (h : B * A = C * A)\n    refine hA.matrix ?_\n    simp only\n    rw [← Matrix.mul_one B, ← Matrix.mul_one C, ← Matrix.mul_smul, ← Matrix.mul_smul, ←\n      mul_adjugate, ← Matrix.mul_assoc, ← Matrix.mul_assoc, h]\n\n"}
{"name":"Matrix.adjugate_mul_distrib_aux","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA B : Matrix n n α\nhA : IsLeftRegular A.det\nhB : IsLeftRegular B.det\n⊢ Eq (HMul.hMul A B).adjugate (HMul.hMul B.adjugate A.adjugate)","decl":"theorem adjugate_mul_distrib_aux (A B : Matrix n n α) (hA : IsLeftRegular A.det)\n    (hB : IsLeftRegular B.det) : adjugate (A * B) = adjugate B * adjugate A := by\n  have hAB : IsLeftRegular (A * B).det := by\n    rw [det_mul]\n    exact hA.mul hB\n  refine (isRegular_of_isLeftRegular_det hAB).left ?_\n  simp only\n  rw [mul_adjugate, Matrix.mul_assoc, ← Matrix.mul_assoc B, mul_adjugate,\n    smul_mul, Matrix.one_mul, mul_smul, mul_adjugate, smul_smul, mul_comm, ← det_mul]\n\n"}
{"name":"Matrix.adjugate_mul_distrib","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA B : Matrix n n α\n⊢ Eq (HMul.hMul A B).adjugate (HMul.hMul B.adjugate A.adjugate)","decl":"/-- Proof follows from \"The trace Cayley-Hamilton theorem\" by Darij Grinberg, Section 5.3\n-/\ntheorem adjugate_mul_distrib (A B : Matrix n n α) : adjugate (A * B) = adjugate B * adjugate A := by\n  let g : Matrix n n α → Matrix n n α[X] := fun M =>\n    M.map Polynomial.C + (Polynomial.X : α[X]) • (1 : Matrix n n α[X])\n  let f' : Matrix n n α[X] →+* Matrix n n α := (Polynomial.evalRingHom 0).mapMatrix\n  have f'_inv : ∀ M, f' (g M) = M := by\n    intro\n    ext\n    simp [f', g]\n  have f'_adj : ∀ M : Matrix n n α, f' (adjugate (g M)) = adjugate M := by\n    intro\n    rw [RingHom.map_adjugate, f'_inv]\n  have f'_g_mul : ∀ M N : Matrix n n α, f' (g M * g N) = M * N := by\n    intros M N\n    rw [RingHom.map_mul, f'_inv, f'_inv]\n  have hu : ∀ M : Matrix n n α, IsRegular (g M).det := by\n    intro M\n    refine Polynomial.Monic.isRegular ?_\n    simp only [g, Polynomial.Monic.def, ← Polynomial.leadingCoeff_det_X_one_add_C M, add_comm]\n  rw [← f'_adj, ← f'_adj, ← f'_adj, ← f'.map_mul, ←\n    adjugate_mul_distrib_aux _ _ (hu A).left (hu B).left, RingHom.map_adjugate,\n    RingHom.map_adjugate, f'_inv, f'_g_mul]\n\n"}
{"name":"Matrix.adjugate_pow","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nk : Nat\n⊢ Eq (HPow.hPow A k).adjugate (HPow.hPow A.adjugate k)","decl":"@[simp]\ntheorem adjugate_pow (A : Matrix n n α) (k : ℕ) : adjugate (A ^ k) = adjugate A ^ k := by\n  induction' k with k IH\n  · simp\n  · rw [pow_succ', adjugate_mul_distrib, IH, pow_succ]\n\n"}
{"name":"Matrix.det_smul_adjugate_adjugate","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\n⊢ Eq (HSMul.hSMul A.det A.adjugate.adjugate) (HSMul.hSMul (HPow.hPow A.det (HSub.hSub (Fintype.card n) 1)) A)","decl":"theorem det_smul_adjugate_adjugate (A : Matrix n n α) :\n    det A • adjugate (adjugate A) = det A ^ (Fintype.card n - 1) • A := by\n  have : A * (A.adjugate * A.adjugate.adjugate) =\n      A * (A.det ^ (Fintype.card n - 1) • (1 : Matrix n n α)) := by\n    rw [← adjugate_mul_distrib, adjugate_mul, adjugate_smul, adjugate_one]\n  rwa [← Matrix.mul_assoc, mul_adjugate, Matrix.mul_smul, Matrix.mul_one, Matrix.smul_mul,\n    Matrix.one_mul] at this\n\n"}
{"name":"Matrix.adjugate_adjugate","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : CommRing α\nA : Matrix n n α\nh : Ne (Fintype.card n) 1\n⊢ Eq A.adjugate.adjugate (HSMul.hSMul (HPow.hPow A.det (HSub.hSub (Fintype.card n) 2)) A)","decl":"/-- Note that this is not true for `Fintype.card n = 1` since `1 - 2 = 0` and not `-1`. -/\ntheorem adjugate_adjugate (A : Matrix n n α) (h : Fintype.card n ≠ 1) :\n    adjugate (adjugate A) = det A ^ (Fintype.card n - 2) • A := by\n  -- get rid of the `- 2`\n  cases' h_card : Fintype.card n with n'\n  · subsingleton [Fintype.card_eq_zero_iff.mp h_card]\n  cases n'\n  · exact (h h_card).elim\n  rw [← h_card]\n  -- express `A` as an evaluation of a polynomial in n^2 variables, and solve in the polynomial ring\n  -- where `A'.det` is non-zero.\n  let A' := mvPolynomialX n n ℤ\n  suffices adjugate (adjugate A') = det A' ^ (Fintype.card n - 2) • A' by\n    rw [← mvPolynomialX_mapMatrix_aeval ℤ A, ← AlgHom.map_adjugate, ← AlgHom.map_adjugate, this,\n      ← AlgHom.map_det, ← map_pow (MvPolynomial.aeval fun p : n × n ↦ A p.1 p.2),\n      AlgHom.mapMatrix_apply, AlgHom.mapMatrix_apply, Matrix.map_smul' _ _ _ (_root_.map_mul _)]\n  have h_card' : Fintype.card n - 2 + 1 = Fintype.card n - 1 := by simp [h_card]\n  have is_reg : IsSMulRegular (MvPolynomial (n × n) ℤ) (det A') := fun x y =>\n    mul_left_cancel₀ (det_mvPolynomialX_ne_zero n ℤ)\n  apply is_reg.matrix\n  simp only\n  rw [smul_smul, ← pow_succ', h_card', det_smul_adjugate_adjugate]\n\n"}
{"name":"Matrix.adjugate_adjugate'","module":"Mathlib.LinearAlgebra.Matrix.Adjugate","initialProofState":"n : Type v\nα : Type w\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : CommRing α\nA : Matrix n n α\ninst✝ : Nontrivial n\n⊢ Eq A.adjugate.adjugate (HSMul.hSMul (HPow.hPow A.det (HSub.hSub (Fintype.card n) 2)) A)","decl":"/-- A weaker version of `Matrix.adjugate_adjugate` that uses `Nontrivial`. -/\ntheorem adjugate_adjugate' (A : Matrix n n α) [Nontrivial n] :\n    adjugate (adjugate A) = det A ^ (Fintype.card n - 2) • A :=\n  adjugate_adjugate _ <| Fintype.one_lt_card.ne'\n\n"}
