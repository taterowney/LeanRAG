{"name":"CategoryTheory.eqToHom_refl","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\np : Eq X X\n‚ä¢ Eq (CategoryTheory.eqToHom p) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem eqToHom_refl (X : C) (p : X = X) : eqToHom p = ùüô X :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_trans_assoc","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z‚úù : C\np : Eq X Y\nq : Eq Y Z‚úù\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom q) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem eqToHom_trans {X Y Z : C} (p : X = Y) (q : Y = Z) :\n    eqToHom p ‚â´ eqToHom q = eqToHom (p.trans q) := by\n  cases p\n  cases q\n  simp\n\n"}
{"name":"CategoryTheory.eqToHom_trans","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\np : Eq X Y\nq : Eq Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom p) (CategoryTheory.eqToHom q)) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem eqToHom_trans {X Y Z : C} (p : X = Y) (q : Y = Z) :\n    eqToHom p ‚â´ eqToHom q = eqToHom (p.trans q) := by\n  cases p\n  cases q\n  simp\n\n"}
{"name":"CategoryTheory.conj_eqToHom_iff_heq","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\nh : Eq W Y\nh' : Eq X Z\n‚ä¢ Iff (Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.eqToHom ‚ãØ)))) (HEq f g)","decl":"/-- Two morphisms are conjugate via eqToHom if and only if they are heterogeneously equal.\nNote this used to be in the Functor namespace, where it doesn't belong. -/\ntheorem conj_eqToHom_iff_heq {W X Y Z : C} (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) (h : W = Y) (h' : X = Z) :\n    f = eqToHom h ‚â´ g ‚â´ eqToHom h'.symm ‚Üî HEq f g := by\n  cases h\n  cases h'\n  simp\n\n"}
{"name":"CategoryTheory.conj_eqToHom_iff_heq'","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\nh : Eq W Y\nh' : Eq Z X\n‚ä¢ Iff (Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.eqToHom h')))) (HEq f g)","decl":"theorem conj_eqToHom_iff_heq' {C} [Category C] {W X Y Z : C}\n    (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) (h : W = Y) (h' : Z = X) :\n    f = eqToHom h ‚â´ g ‚â´ eqToHom h' ‚Üî HEq f g := conj_eqToHom_iff_heq _ _ _ h'.symm\n\n"}
{"name":"CategoryTheory.comp_eqToHom_iff","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Y' : C\np : Eq Y Y'\nf : Quiver.Hom X Y\ng : Quiver.Hom X Y'\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom p)) g) (Eq f (CategoryTheory.CategoryStruct.comp g (CategoryTheory.eqToHom ‚ãØ)))","decl":"theorem comp_eqToHom_iff {X Y Y' : C} (p : Y = Y') (f : X ‚ü∂ Y) (g : X ‚ü∂ Y') :\n    f ‚â´ eqToHom p = g ‚Üî f = g ‚â´ eqToHom p.symm :=\n  { mp := fun h => h ‚ñ∏ by simp\n    mpr := fun h => by simp [eq_whisker h (eqToHom p)] }\n\n"}
{"name":"CategoryTheory.eqToHom_comp_iff","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX X' Y : C\np : Eq X X'\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom p) g) f) (Eq g (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) f))","decl":"theorem eqToHom_comp_iff {X X' Y : C} (p : X = X') (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y) :\n    eqToHom p ‚â´ g = f ‚Üî g = eqToHom p.symm ‚â´ f :=\n  { mp := fun h => h ‚ñ∏ by simp\n    mpr := fun h => h ‚ñ∏ by simp [whisker_eq _ h] }\n\n"}
{"name":"CategoryTheory.eqToHom_comp_heq","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW X Y : C\nf : Quiver.Hom Y X\nh : Eq W Y\n‚ä¢ HEq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) f) f","decl":"theorem eqToHom_comp_heq {C} [Category C] {W X Y : C}\n    (f : Y ‚ü∂ X) (h : W = Y) : HEq (eqToHom h ‚â´ f) f := by\n  rw [‚Üê conj_eqToHom_iff_heq _ _ h rfl, eqToHom_refl, Category.comp_id]\n\n"}
{"name":"CategoryTheory.eqToHom_comp_heq_iff","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z Z' : C\nf : Quiver.Hom Y X\ng : Quiver.Hom Z Z'\nh : Eq W Y\n‚ä¢ Iff (HEq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) f) g) (HEq f g)","decl":"@[simp] theorem eqToHom_comp_heq_iff {C} [Category C] {W X Y Z Z' : C}\n    (f : Y ‚ü∂ X) (g : Z ‚ü∂ Z') (h : W = Y) :\n    HEq (eqToHom h ‚â´ f) g ‚Üî HEq f g :=\n  ‚ü®(eqToHom_comp_heq ..).symm.trans, (eqToHom_comp_heq ..).trans‚ü©\n\n"}
{"name":"CategoryTheory.heq_eqToHom_comp_iff","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z Z' : C\nf : Quiver.Hom Y X\ng : Quiver.Hom Z Z'\nh : Eq W Y\n‚ä¢ Iff (HEq g (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h) f)) (HEq g f)","decl":"@[simp] theorem heq_eqToHom_comp_iff {C} [Category C] {W X Y Z Z' : C}\n    (f : Y ‚ü∂ X) (g : Z ‚ü∂ Z') (h : W = Y) :\n    HEq g (eqToHom h ‚â´ f) ‚Üî HEq g f :=\n  ‚ü®(¬∑.trans (eqToHom_comp_heq ..)), (¬∑.trans (eqToHom_comp_heq ..).symm)‚ü©\n\n"}
{"name":"CategoryTheory.comp_eqToHom_heq","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : C\nf : Quiver.Hom X Y\nh : Eq Y Z\n‚ä¢ HEq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h)) f","decl":"theorem comp_eqToHom_heq {C} [Category C] {X Y Z : C}\n    (f : X ‚ü∂ Y) (h : Y = Z) : HEq (f ‚â´ eqToHom h) f := by\n  rw [‚Üê conj_eqToHom_iff_heq' _ _ rfl h, eqToHom_refl, Category.id_comp]\n\n"}
{"name":"CategoryTheory.comp_eqToHom_heq_iff","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z Z' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z Z'\nh : Eq Y W\n‚ä¢ Iff (HEq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h)) g) (HEq f g)","decl":"@[simp] theorem comp_eqToHom_heq_iff {C} [Category C] {W X Y Z Z' : C}\n    (f : X ‚ü∂ Y) (g : Z ‚ü∂ Z') (h : Y = W) :\n    HEq (f ‚â´ eqToHom h) g ‚Üî HEq f g :=\n  ‚ü®(comp_eqToHom_heq ..).symm.trans, (comp_eqToHom_heq ..).trans‚ü©\n\n"}
{"name":"CategoryTheory.heq_comp_eqToHom_iff","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z Z' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z Z'\nh : Eq Y W\n‚ä¢ Iff (HEq g (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h))) (HEq g f)","decl":"@[simp] theorem heq_comp_eqToHom_iff {C} [Category C] {W X Y Z Z' : C}\n    (f : X ‚ü∂ Y) (g : Z ‚ü∂ Z') (h : Y = W) :\n    HEq g (f ‚â´ eqToHom h) ‚Üî HEq g f :=\n  ‚ü®(¬∑.trans (comp_eqToHom_heq ..)), (¬∑.trans (comp_eqToHom_heq ..).symm)‚ü©\n\n"}
{"name":"CategoryTheory.heq_comp","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y Z X' Y' Z' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nf' : Quiver.Hom X' Y'\ng' : Quiver.Hom Y' Z'\neq1 : Eq X X'\neq2 : Eq Y Y'\neq3 : Eq Z Z'\nH1 : HEq f f'\nH2 : HEq g g'\n‚ä¢ HEq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g')","decl":"theorem heq_comp {C} [Category C] {X Y Z X' Y' Z' : C}\n    {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} {f' : X' ‚ü∂ Y'} {g' : Y' ‚ü∂ Z'}\n    (eq1 : X = X') (eq2 : Y = Y') (eq3 : Z = Z')\n    (H1 : HEq f f') (H2 : HEq g g') :\n    HEq (f ‚â´ g) (f' ‚â´ g') := by\n  cases eq1; cases eq2; cases eq3; cases H1; cases H2; rfl\n\n"}
{"name":"CategoryTheory.eqToHom_naturality","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒ≤ : Sort u_1\nf g : Œ≤ ‚Üí C\nz : (b : Œ≤) ‚Üí Quiver.Hom (f b) (g b)\nj j' : Œ≤\nw : Eq j j'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (z j) (CategoryTheory.eqToHom ‚ãØ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (z j'))","decl":"/-- We can push `eqToHom` to the left through families of morphisms. -/\n-- The simpNF linter incorrectly claims that this will never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n@[reassoc (attr := simp, nolint simpNF)]\ntheorem eqToHom_naturality {f g : Œ≤ ‚Üí C} (z : ‚àÄ b, f b ‚ü∂ g b) {j j' : Œ≤} (w : j = j') :\n    z j ‚â´ eqToHom (by simp [w]) = eqToHom (by simp [w]) ‚â´ z j' := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.eqToHom_naturality_assoc","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒ≤ : Sort u_1\nf g : Œ≤ ‚Üí C\nz : (b : Œ≤) ‚Üí Quiver.Hom (f b) (g b)\nj j' : Œ≤\nw : Eq j j'\nZ : C\nh : Quiver.Hom (g j') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (z j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (z j') h))","decl":"/-- We can push `eqToHom` to the left through families of morphisms. -/\n-- The simpNF linter incorrectly claims that this will never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n@[reassoc (attr := simp, nolint simpNF)]\ntheorem eqToHom_naturality {f g : Œ≤ ‚Üí C} (z : ‚àÄ b, f b ‚ü∂ g b) {j j' : Œ≤} (w : j = j') :\n    z j ‚â´ eqToHom (by simp [w]) = eqToHom (by simp [w]) ‚â´ z j' := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.eqToHom_iso_hom_naturality","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒ≤ : Sort u_1\nf g : Œ≤ ‚Üí C\nz : (b : Œ≤) ‚Üí CategoryTheory.Iso (f b) (g b)\nj j' : Œ≤\nw : Eq j j'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (z j).hom (CategoryTheory.eqToHom ‚ãØ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (z j').hom)","decl":"/-- A variant on `eqToHom_naturality` that helps Lean identify the families `f` and `g`. -/\n-- The simpNF linter incorrectly claims that this will never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n@[reassoc (attr := simp, nolint simpNF)]\ntheorem eqToHom_iso_hom_naturality {f g : Œ≤ ‚Üí C} (z : ‚àÄ b, f b ‚âÖ g b) {j j' : Œ≤} (w : j = j') :\n    (z j).hom ‚â´ eqToHom (by simp [w]) = eqToHom (by simp [w]) ‚â´ (z j').hom := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.eqToHom_iso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒ≤ : Sort u_1\nf g : Œ≤ ‚Üí C\nz : (b : Œ≤) ‚Üí CategoryTheory.Iso (f b) (g b)\nj j' : Œ≤\nw : Eq j j'\nZ : C\nh : Quiver.Hom (g j') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (z j).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (z j').hom h))","decl":"/-- A variant on `eqToHom_naturality` that helps Lean identify the families `f` and `g`. -/\n-- The simpNF linter incorrectly claims that this will never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n@[reassoc (attr := simp, nolint simpNF)]\ntheorem eqToHom_iso_hom_naturality {f g : Œ≤ ‚Üí C} (z : ‚àÄ b, f b ‚âÖ g b) {j j' : Œ≤} (w : j = j') :\n    (z j).hom ‚â´ eqToHom (by simp [w]) = eqToHom (by simp [w]) ‚â´ (z j').hom := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.eqToHom_iso_inv_naturality","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒ≤ : Sort u_1\nf g : Œ≤ ‚Üí C\nz : (b : Œ≤) ‚Üí CategoryTheory.Iso (f b) (g b)\nj j' : Œ≤\nw : Eq j j'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (z j).inv (CategoryTheory.eqToHom ‚ãØ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (z j').inv)","decl":"/-- A variant on `eqToHom_naturality` that helps Lean identify the families `f` and `g`. -/\n-- The simpNF linter incorrectly claims that this will never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n@[reassoc (attr := simp, nolint simpNF)]\ntheorem eqToHom_iso_inv_naturality {f g : Œ≤ ‚Üí C} (z : ‚àÄ b, f b ‚âÖ g b) {j j' : Œ≤} (w : j = j') :\n    (z j).inv ‚â´ eqToHom (by simp [w]) = eqToHom (by simp [w]) ‚â´ (z j').inv := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.eqToHom_iso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒ≤ : Sort u_1\nf g : Œ≤ ‚Üí C\nz : (b : Œ≤) ‚Üí CategoryTheory.Iso (f b) (g b)\nj j' : Œ≤\nw : Eq j j'\nZ : C\nh : Quiver.Hom (f j') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (z j).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (z j').inv h))","decl":"/-- A variant on `eqToHom_naturality` that helps Lean identify the families `f` and `g`. -/\n-- The simpNF linter incorrectly claims that this will never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n@[reassoc (attr := simp, nolint simpNF)]\ntheorem eqToHom_iso_inv_naturality {f g : Œ≤ ‚Üí C} (z : ‚àÄ b, f b ‚âÖ g b) {j j' : Œ≤} (w : j = j') :\n    (z j).inv ‚â´ eqToHom (by simp [w]) = eqToHom (by simp [w]) ‚â´ (z j').inv := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.congrArg_cast_hom_left","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\np : Eq X Y\nq : Quiver.Hom Y Z\n‚ä¢ Eq (cast ‚ãØ q) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom p) q)","decl":"/-- Reducible form of congrArg_mpr_hom_left -/\n@[simp]\ntheorem congrArg_cast_hom_left {X Y Z : C} (p : X = Y) (q : Y ‚ü∂ Z) :\n    cast (congrArg (fun W : C => W ‚ü∂ Z) p.symm) q = eqToHom p ‚â´ q := by\n  cases p\n  simp\n\n"}
{"name":"CategoryTheory.congrArg_mpr_hom_left","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\np : Eq X Y\nq : Quiver.Hom Y Z\n‚ä¢ Eq (‚ãØ.mpr q) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom p) q)","decl":"/-- If we (perhaps unintentionally) perform equational rewriting on\nthe source object of a morphism,\nwe can replace the resulting `_.mpr f` term by a composition with an `eqToHom`.\n\nIt may be advisable to introduce any necessary `eqToHom` morphisms manually,\nrather than relying on this lemma firing.\n-/\ntheorem congrArg_mpr_hom_left {X Y Z : C} (p : X = Y) (q : Y ‚ü∂ Z) :\n    (congrArg (fun W : C => W ‚ü∂ Z) p).mpr q = eqToHom p ‚â´ q := by\n  cases p\n  simp\n\n"}
{"name":"CategoryTheory.congrArg_cast_hom_right","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\np : Quiver.Hom X Y\nq : Eq Z Y\n‚ä¢ Eq (cast ‚ãØ p) (CategoryTheory.CategoryStruct.comp p (CategoryTheory.eqToHom ‚ãØ))","decl":"/-- Reducible form of `congrArg_mpr_hom_right` -/\n@[simp]\ntheorem congrArg_cast_hom_right {X Y Z : C} (p : X ‚ü∂ Y) (q : Z = Y) :\n    cast (congrArg (fun W : C => X ‚ü∂ W) q.symm) p = p ‚â´ eqToHom q.symm := by\n  cases q\n  simp\n\n"}
{"name":"CategoryTheory.congrArg_mpr_hom_right","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\np : Quiver.Hom X Y\nq : Eq Z Y\n‚ä¢ Eq (‚ãØ.mpr p) (CategoryTheory.CategoryStruct.comp p (CategoryTheory.eqToHom ‚ãØ))","decl":"/-- If we (perhaps unintentionally) perform equational rewriting on\nthe target object of a morphism,\nwe can replace the resulting `_.mpr f` term by a composition with an `eqToHom`.\n\nIt may be advisable to introduce any necessary `eqToHom` morphisms manually,\nrather than relying on this lemma firing.\n-/\ntheorem congrArg_mpr_hom_right {X Y Z : C} (p : X ‚ü∂ Y) (q : Z = Y) :\n    (congrArg (fun W : C => X ‚ü∂ W) q).mpr p = p ‚â´ eqToHom q.symm := by\n  cases q\n  simp\n\n"}
{"name":"CategoryTheory.eqToIso.hom","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\np : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToIso p).hom (CategoryTheory.eqToHom p)","decl":"@[simp]\ntheorem eqToIso.hom {X Y : C} (p : X = Y) : (eqToIso p).hom = eqToHom p :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToIso.inv","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\np : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToIso p).inv (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToIso.inv {X Y : C} (p : X = Y) : (eqToIso p).inv = eqToHom p.symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToIso_refl","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\np : Eq X X\n‚ä¢ Eq (CategoryTheory.eqToIso p) (CategoryTheory.Iso.refl X)","decl":"@[simp]\ntheorem eqToIso_refl {X : C} (p : X = X) : eqToIso p = Iso.refl X :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToIso_trans","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\np : Eq X Y\nq : Eq Y Z\n‚ä¢ Eq ((CategoryTheory.eqToIso p).trans (CategoryTheory.eqToIso q)) (CategoryTheory.eqToIso ‚ãØ)","decl":"@[simp]\ntheorem eqToIso_trans {X Y Z : C} (p : X = Y) (q : Y = Z) :\n    eqToIso p ‚â™‚â´ eqToIso q = eqToIso (p.trans q) := by ext; simp\n\n"}
{"name":"CategoryTheory.eqToHom_op","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToHom h).op (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_op {X Y : C} (h : X = Y) : (eqToHom h).op = eqToHom (congr_arg op h.symm) := by\n  cases h\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_unop","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToHom h).unop (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_unop {X Y : C·µí·µñ} (h : X = Y) :\n    (eqToHom h).unop = eqToHom (congr_arg unop h.symm) := by\n  cases h\n  rfl\n\n"}
{"name":"CategoryTheory.instIsIsoEqToHom","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nh : Eq X Y\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.eqToHom h)","decl":"instance {X Y : C} (h : X = Y) : IsIso (eqToHom h) :=\n  (eqToIso h).isIso_hom\n\n"}
{"name":"CategoryTheory.inv_eqToHom","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.inv (CategoryTheory.eqToHom h)) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem inv_eqToHom {X Y : C} (h : X = Y) : inv (eqToHom h) = eqToHom h.symm := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.ext","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh_obj : ‚àÄ (X : C), Eq (F.obj X) (G.obj X)\nh_map : autoParam (‚àÄ (X Y : C) (f : Quiver.Hom X Y), Eq (F.map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (G.map f) (CategoryTheory.eqToHom ‚ãØ)))) _auto‚úù\n‚ä¢ Eq F G","decl":"/-- Proving equality between functors. This isn't an extensionality lemma,\n  because usually you don't really want to do this. -/\ntheorem ext {F G : C ‚•§ D} (h_obj : ‚àÄ X, F.obj X = G.obj X)\n    (h_map : ‚àÄ X Y f,\n      F.map f = eqToHom (h_obj X) ‚â´ G.map f ‚â´ eqToHom (h_obj Y).symm := by aesop_cat) :\n    F = G := by\n  match F, G with\n  | mk F_pre _ _ , mk G_pre _ _ =>\n    match F_pre, G_pre with  -- Porting note: did not unfold the Prefunctor unlike Lean3\n    | Prefunctor.mk F_obj _ , Prefunctor.mk G_obj _ =>\n    obtain rfl : F_obj = G_obj := by\n      ext X\n      apply h_obj\n    congr\n    funext X Y f\n    simpa using h_map X Y f\n\n"}
{"name":"CategoryTheory.Functor.ext_of_iso","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\nhobj : ‚àÄ (X : C), Eq (F.obj X) (G.obj X)\nhapp : ‚àÄ (X : C), Eq (e.hom.app X) (CategoryTheory.eqToHom ‚ãØ)\n‚ä¢ Eq F G","decl":"lemma ext_of_iso {F G : C ‚•§ D} (e : F ‚âÖ G) (hobj : ‚àÄ X, F.obj X = G.obj X)\n    (happ : ‚àÄ X, e.hom.app X = eqToHom (hobj X)) : F = G :=\n  Functor.ext hobj (fun X Y f => by\n    rw [‚Üê cancel_mono (e.hom.app Y), e.hom.naturality f, happ, happ, Category.assoc,\n    Category.assoc, eqToHom_trans, eqToHom_refl, Category.comp_id])\n\n"}
{"name":"CategoryTheory.Functor.hext","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh_obj : ‚àÄ (X : C), Eq (F.obj X) (G.obj X)\nh_map : ‚àÄ (X Y : C) (f : Quiver.Hom X Y), HEq (F.map f) (G.map f)\n‚ä¢ Eq F G","decl":"/-- Proving equality between functors using heterogeneous equality. -/\ntheorem hext {F G : C ‚•§ D} (h_obj : ‚àÄ X, F.obj X = G.obj X)\n    (h_map : ‚àÄ (X Y) (f : X ‚ü∂ Y), HEq (F.map f) (G.map f)) : F = G :=\n  Functor.ext h_obj fun _ _ f => (conj_eqToHom_iff_heq _ _ (h_obj _) (h_obj _)).2 <| h_map _ _ f\n\n-- Using equalities between functors.\n"}
{"name":"CategoryTheory.Functor.congr_obj","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : Eq F G\nX : C\n‚ä¢ Eq (F.obj X) (G.obj X)","decl":"theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by rw [h]\n\n"}
{"name":"CategoryTheory.Functor.congr_hom","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : Eq F G\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (G.map f) (CategoryTheory.eqToHom ‚ãØ)))","decl":"@[reassoc]\ntheorem congr_hom {F G : C ‚•§ D} (h : F = G) {X Y} (f : X ‚ü∂ Y) :\n    F.map f = eqToHom (congr_obj h X) ‚â´ G.map f ‚â´ eqToHom (congr_obj h Y).symm := by\n  subst h; simp\n\n"}
{"name":"CategoryTheory.Functor.congr_hom_assoc","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh‚úù : Eq F G\nX Y : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (G.map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) h)))","decl":"@[reassoc]\ntheorem congr_hom {F G : C ‚•§ D} (h : F = G) {X Y} (f : X ‚ü∂ Y) :\n    F.map f = eqToHom (congr_obj h X) ‚â´ G.map f ‚â´ eqToHom (congr_obj h Y).symm := by\n  subst h; simp\n\n"}
{"name":"CategoryTheory.Functor.congr_inv_of_congr_hom","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nX Y : C\ne : CategoryTheory.Iso X Y\nhX : Eq (F.obj X) (G.obj X)\nhY : Eq (F.obj Y) (G.obj Y)\nh‚ÇÇ : Eq (F.map e.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (G.map e.hom) (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq (F.map e.inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (G.map e.inv) (CategoryTheory.eqToHom ‚ãØ)))","decl":"theorem congr_inv_of_congr_hom (F G : C ‚•§ D) {X Y : C} (e : X ‚âÖ Y) (hX : F.obj X = G.obj X)\n    (hY : F.obj Y = G.obj Y)\n    (h‚ÇÇ : F.map e.hom = eqToHom (by rw [hX]) ‚â´ G.map e.hom ‚â´ eqToHom (by rw [hY])) :\n    F.map e.inv = eqToHom (by rw [hY]) ‚â´ G.map e.inv ‚â´ eqToHom (by rw [hX]) := by\n  simp only [‚Üê IsIso.Iso.inv_hom e, Functor.map_inv, h‚ÇÇ, IsIso.inv_comp, inv_eqToHom,\n    Category.assoc]\n\n"}
{"name":"CategoryTheory.Functor.map_comp_heq","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nhx : Eq (F.obj X) (G.obj X)\nhy : Eq (F.obj Y) (G.obj Y)\nhz : Eq (F.obj Z) (G.obj Z)\nhf : HEq (F.map f) (G.map f)\nhg : HEq (F.map g) (G.map g)\n‚ä¢ HEq (F.map (CategoryTheory.CategoryStruct.comp f g)) (G.map (CategoryTheory.CategoryStruct.comp f g))","decl":"theorem map_comp_heq (hx : F.obj X = G.obj X) (hy : F.obj Y = G.obj Y) (hz : F.obj Z = G.obj Z)\n    (hf : HEq (F.map f) (G.map f)) (hg : HEq (F.map g) (G.map g)) :\n    HEq (F.map (f ‚â´ g)) (G.map (f ‚â´ g)) := by\n  rw [F.map_comp, G.map_comp]\n  congr\n\n"}
{"name":"CategoryTheory.Functor.map_comp_heq'","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nhobj : ‚àÄ (X : C), Eq (F.obj X) (G.obj X)\nhmap : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), HEq (F.map f) (G.map f)\n‚ä¢ HEq (F.map (CategoryTheory.CategoryStruct.comp f g)) (G.map (CategoryTheory.CategoryStruct.comp f g))","decl":"theorem map_comp_heq' (hobj : ‚àÄ X : C, F.obj X = G.obj X)\n    (hmap : ‚àÄ {X Y} (f : X ‚ü∂ Y), HEq (F.map f) (G.map f)) :\n    HEq (F.map (f ‚â´ g)) (G.map (f ‚â´ g)) := by\n  rw [Functor.hext hobj fun _ _ => hmap]\n\n"}
{"name":"CategoryTheory.Functor.precomp_map_heq","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nH : CategoryTheory.Functor E C\nhmap : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), HEq (F.map f) (G.map f)\nX Y : E\nf : Quiver.Hom X Y\n‚ä¢ HEq ((H.comp F).map f) ((H.comp G).map f)","decl":"theorem precomp_map_heq (H : E ‚•§ C) (hmap : ‚àÄ {X Y} (f : X ‚ü∂ Y), HEq (F.map f) (G.map f)) {X Y : E}\n    (f : X ‚ü∂ Y) : HEq ((H ‚ãô F).map f) ((H ‚ãô G).map f) :=\n  hmap _\n\n"}
{"name":"CategoryTheory.Functor.postcomp_map_heq","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\nH : CategoryTheory.Functor D E\nhx : Eq (F.obj X) (G.obj X)\nhy : Eq (F.obj Y) (G.obj Y)\nhmap : HEq (F.map f) (G.map f)\n‚ä¢ HEq ((F.comp H).map f) ((G.comp H).map f)","decl":"theorem postcomp_map_heq (H : D ‚•§ E) (hx : F.obj X = G.obj X) (hy : F.obj Y = G.obj Y)\n    (hmap : HEq (F.map f) (G.map f)) : HEq ((F ‚ãô H).map f) ((G ‚ãô H).map f) := by\n  dsimp\n  congr\n\n"}
{"name":"CategoryTheory.Functor.postcomp_map_heq'","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\nH : CategoryTheory.Functor D E\nhobj : ‚àÄ (X : C), Eq (F.obj X) (G.obj X)\nhmap : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), HEq (F.map f) (G.map f)\n‚ä¢ HEq ((F.comp H).map f) ((G.comp H).map f)","decl":"theorem postcomp_map_heq' (H : D ‚•§ E) (hobj : ‚àÄ X : C, F.obj X = G.obj X)\n    (hmap : ‚àÄ {X Y} (f : X ‚ü∂ Y), HEq (F.map f) (G.map f)) :\n    HEq ((F ‚ãô H).map f) ((G ‚ãô H).map f) := by rw [Functor.hext hobj fun _ _ => hmap]\n\n"}
{"name":"CategoryTheory.Functor.hcongr_hom","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : Eq F G\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ HEq (F.map f) (G.map f)","decl":"theorem hcongr_hom {F G : C ‚•§ D} (h : F = G) {X Y} (f : X ‚ü∂ Y) : HEq (F.map f) (G.map f) := by\n  rw [h]\n\n"}
{"name":"CategoryTheory.eqToHom_map","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\np : Eq X Y\n‚ä¢ Eq (F.map (CategoryTheory.eqToHom p)) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- This is not always a good idea as a `@[simp]` lemma,\nas we lose the ability to use results that interact with `F`,\ne.g. the naturality of a natural transformation.\n\nIn some files it may be appropriate to use `attribute [local simp] eqToHom_map`, however.\n-/\ntheorem eqToHom_map (F : C ‚•§ D) {X Y : C} (p : X = Y) :\n    F.map (eqToHom p) = eqToHom (congr_arg F.obj p) := by cases p; simp\n\n"}
{"name":"CategoryTheory.eqToHom_map_comp","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y Z : C\np : Eq X Y\nq : Eq Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.eqToHom p)) (F.map (CategoryTheory.eqToHom q))) (F.map (CategoryTheory.eqToHom ‚ãØ))","decl":"@[reassoc (attr := simp)]\ntheorem eqToHom_map_comp (F : C ‚•§ D) {X Y Z : C} (p : X = Y) (q : Y = Z) :\n    F.map (eqToHom p) ‚â´ F.map (eqToHom q) = F.map (eqToHom <| p.trans q) := by aesop_cat\n\n"}
{"name":"CategoryTheory.eqToHom_map_comp_assoc","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y Z‚úù : C\np : Eq X Y\nq : Eq Y Z‚úù\nZ : D\nh : Quiver.Hom (F.obj Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.eqToHom p)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.eqToHom q)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.eqToHom ‚ãØ)) h)","decl":"@[reassoc (attr := simp)]\ntheorem eqToHom_map_comp (F : C ‚•§ D) {X Y Z : C} (p : X = Y) (q : Y = Z) :\n    F.map (eqToHom p) ‚â´ F.map (eqToHom q) = F.map (eqToHom <| p.trans q) := by aesop_cat\n\n"}
{"name":"CategoryTheory.eqToIso_map","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\np : Eq X Y\n‚ä¢ Eq (F.mapIso (CategoryTheory.eqToIso p)) (CategoryTheory.eqToIso ‚ãØ)","decl":"/-- See the note on `eqToHom_map` regarding using this as a `simp` lemma.\n-/\ntheorem eqToIso_map (F : C ‚•§ D) {X Y : C} (p : X = Y) :\n    F.mapIso (eqToIso p) = eqToIso (congr_arg F.obj p) := by ext; cases p; simp\n\n"}
{"name":"CategoryTheory.eqToIso_map_trans","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y Z : C\np : Eq X Y\nq : Eq Y Z\n‚ä¢ Eq ((F.mapIso (CategoryTheory.eqToIso p)).trans (F.mapIso (CategoryTheory.eqToIso q))) (F.mapIso (CategoryTheory.eqToIso ‚ãØ))","decl":"@[simp]\ntheorem eqToIso_map_trans (F : C ‚•§ D) {X Y Z : C} (p : X = Y) (q : Y = Z) :\n    F.mapIso (eqToIso p) ‚â™‚â´ F.mapIso (eqToIso q) = F.mapIso (eqToIso <| p.trans q) := by aesop_cat\n\n"}
{"name":"CategoryTheory.eqToHom_app","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : Eq F G\nX : C\n‚ä¢ Eq ((CategoryTheory.eqToHom h).app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_app {F G : C ‚•§ D} (h : F = G) (X : C) :\n    (eqToHom h : F ‚ü∂ G).app X = eqToHom (Functor.congr_obj h X) := by subst h; rfl\n\n"}
{"name":"CategoryTheory.NatTrans.congr","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nX Y : C\nh : Eq X Y\n‚ä¢ Eq (Œ±.app X) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.eqToHom h)) (CategoryTheory.CategoryStruct.comp (Œ±.app Y) (G.map (CategoryTheory.eqToHom ‚ãØ))))","decl":"theorem NatTrans.congr {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) {X Y : C} (h : X = Y) :\n    Œ±.app X = F.map (eqToHom h) ‚â´ Œ±.app Y ‚â´ G.map (eqToHom h.symm) := by\n  rw [Œ±.naturality_assoc]\n  simp [eqToHom_map]\n\n"}
{"name":"CategoryTheory.eq_conj_eqToHom","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom ‚ãØ)))","decl":"theorem eq_conj_eqToHom {X Y : C} (f : X ‚ü∂ Y) : f = eqToHom rfl ‚â´ f ‚â´ eqToHom rfl := by\n  simp only [Category.id_comp, eqToHom_refl, Category.comp_id]\n\n"}
{"name":"CategoryTheory.dcongr_arg","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒπ : Type u_2\nF G : Œπ ‚Üí C\nŒ± : (i : Œπ) ‚Üí Quiver.Hom (F i) (G i)\ni j : Œπ\nh : Eq i j\n‚ä¢ Eq (Œ± i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (Œ± j) (CategoryTheory.eqToHom ‚ãØ)))","decl":"theorem dcongr_arg {Œπ : Type*} {F G : Œπ ‚Üí C} (Œ± : ‚àÄ i, F i ‚ü∂ G i) {i j : Œπ} (h : i = j) :\n    Œ± i = eqToHom (congr_arg F h) ‚â´ Œ± j ‚â´ eqToHom (congr_arg G h.symm) := by\n  subst h\n  simp\n\n"}
{"name":"CategoryTheory.Equivalence.induced_inverse_map","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u_2\ne : Equiv T D\nX Y : D\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Equivalence.induced e).inverse.map f) (letFun (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom ‚ãØ))) fun this => this)","decl":"/-- If `T ‚âÉ D` is a bijection and `D` is a category, then\n`InducedCategory D e` is equivalent to `D`. -/\n@[simps]\ndef Equivalence.induced {T : Type*} (e : T ‚âÉ D) :\n    InducedCategory D e ‚âå D where\n  functor := inducedFunctor e\n  inverse :=\n    { obj := e.symm\n      map {X Y} f := show e (e.symm X) ‚ü∂ e (e.symm Y) from\n        eqToHom (e.apply_symm_apply X) ‚â´ f ‚â´\n          eqToHom (e.apply_symm_apply Y).symm\n      map_comp {X Y Z} f g := by\n        dsimp\n        erw [Category.assoc, Category.assoc, Category.assoc]\n        rw [eqToHom_trans_assoc, eqToHom_refl, Category.id_comp] }\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp)) (fun {X Y} f ‚Ü¶ by\n    dsimp\n    erw [eqToHom_trans_assoc _ (by simp), eqToHom_refl, Category.id_comp]\n    rfl )\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n  functor_unitIso_comp X := eqToHom_trans (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Equivalence.induced_unitIso","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u_2\ne : Equiv T D\n‚ä¢ Eq (CategoryTheory.Equivalence.induced e).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ‚ãØ) ‚ãØ)","decl":"/-- If `T ‚âÉ D` is a bijection and `D` is a category, then\n`InducedCategory D e` is equivalent to `D`. -/\n@[simps]\ndef Equivalence.induced {T : Type*} (e : T ‚âÉ D) :\n    InducedCategory D e ‚âå D where\n  functor := inducedFunctor e\n  inverse :=\n    { obj := e.symm\n      map {X Y} f := show e (e.symm X) ‚ü∂ e (e.symm Y) from\n        eqToHom (e.apply_symm_apply X) ‚â´ f ‚â´\n          eqToHom (e.apply_symm_apply Y).symm\n      map_comp {X Y Z} f g := by\n        dsimp\n        erw [Category.assoc, Category.assoc, Category.assoc]\n        rw [eqToHom_trans_assoc, eqToHom_refl, Category.id_comp] }\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp)) (fun {X Y} f ‚Ü¶ by\n    dsimp\n    erw [eqToHom_trans_assoc _ (by simp), eqToHom_refl, Category.id_comp]\n    rfl )\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n  functor_unitIso_comp X := eqToHom_trans (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Equivalence.induced_counitIso","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u_2\ne : Equiv T D\n‚ä¢ Eq (CategoryTheory.Equivalence.induced e).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ‚ãØ) ‚ãØ)","decl":"/-- If `T ‚âÉ D` is a bijection and `D` is a category, then\n`InducedCategory D e` is equivalent to `D`. -/\n@[simps]\ndef Equivalence.induced {T : Type*} (e : T ‚âÉ D) :\n    InducedCategory D e ‚âå D where\n  functor := inducedFunctor e\n  inverse :=\n    { obj := e.symm\n      map {X Y} f := show e (e.symm X) ‚ü∂ e (e.symm Y) from\n        eqToHom (e.apply_symm_apply X) ‚â´ f ‚â´\n          eqToHom (e.apply_symm_apply Y).symm\n      map_comp {X Y Z} f g := by\n        dsimp\n        erw [Category.assoc, Category.assoc, Category.assoc]\n        rw [eqToHom_trans_assoc, eqToHom_refl, Category.id_comp] }\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp)) (fun {X Y} f ‚Ü¶ by\n    dsimp\n    erw [eqToHom_trans_assoc _ (by simp), eqToHom_refl, Category.id_comp]\n    rfl )\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n  functor_unitIso_comp X := eqToHom_trans (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Equivalence.induced_inverse_obj","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u_2\ne : Equiv T D\na : D\n‚ä¢ Eq ((CategoryTheory.Equivalence.induced e).inverse.obj a) (e.symm a)","decl":"/-- If `T ‚âÉ D` is a bijection and `D` is a category, then\n`InducedCategory D e` is equivalent to `D`. -/\n@[simps]\ndef Equivalence.induced {T : Type*} (e : T ‚âÉ D) :\n    InducedCategory D e ‚âå D where\n  functor := inducedFunctor e\n  inverse :=\n    { obj := e.symm\n      map {X Y} f := show e (e.symm X) ‚ü∂ e (e.symm Y) from\n        eqToHom (e.apply_symm_apply X) ‚â´ f ‚â´\n          eqToHom (e.apply_symm_apply Y).symm\n      map_comp {X Y Z} f g := by\n        dsimp\n        erw [Category.assoc, Category.assoc, Category.assoc]\n        rw [eqToHom_trans_assoc, eqToHom_refl, Category.id_comp] }\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp)) (fun {X Y} f ‚Ü¶ by\n    dsimp\n    erw [eqToHom_trans_assoc _ (by simp), eqToHom_refl, Category.id_comp]\n    rfl )\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n  functor_unitIso_comp X := eqToHom_trans (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Equivalence.induced_functor","module":"Mathlib.CategoryTheory.EqToHom","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : Type u_2\ne : Equiv T D\n‚ä¢ Eq (CategoryTheory.Equivalence.induced e).functor (CategoryTheory.inducedFunctor ‚áëe)","decl":"/-- If `T ‚âÉ D` is a bijection and `D` is a category, then\n`InducedCategory D e` is equivalent to `D`. -/\n@[simps]\ndef Equivalence.induced {T : Type*} (e : T ‚âÉ D) :\n    InducedCategory D e ‚âå D where\n  functor := inducedFunctor e\n  inverse :=\n    { obj := e.symm\n      map {X Y} f := show e (e.symm X) ‚ü∂ e (e.symm Y) from\n        eqToHom (e.apply_symm_apply X) ‚â´ f ‚â´\n          eqToHom (e.apply_symm_apply Y).symm\n      map_comp {X Y Z} f g := by\n        dsimp\n        erw [Category.assoc, Category.assoc, Category.assoc]\n        rw [eqToHom_trans_assoc, eqToHom_refl, Category.id_comp] }\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp)) (fun {X Y} f ‚Ü¶ by\n    dsimp\n    erw [eqToHom_trans_assoc _ (by simp), eqToHom_refl, Category.id_comp]\n    rfl )\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ eqToIso (by simp))\n  functor_unitIso_comp X := eqToHom_trans (by simp) (by simp)\n\n"}
