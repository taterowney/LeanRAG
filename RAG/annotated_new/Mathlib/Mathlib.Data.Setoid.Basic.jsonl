{"name":"Quotient.eq_rel","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : Setoid α\nx y : α\n⊢ Iff (Eq (Quotient.mk' x) (Quotient.mk' y)) (r.Rel x y)","decl":"set_option linter.deprecated false in\n/-- A version of `Quotient.eq'` compatible with `Setoid.Rel`, to make rewriting possible. -/\n@[deprecated Quotient.eq' (since := \"2024-10-09\")]\ntheorem Quotient.eq_rel {r : Setoid α} {x y} :\n    (Quotient.mk' x : Quotient r) = Quotient.mk' y ↔ r.Rel x y :=\n  Quotient.eq\n\n"}
{"name":"Setoid.ext_iff","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Sort u_3\ns t : Setoid α\n⊢ Iff (Eq s t) (∀ (a b : α), Iff (s a b) (t a b))","decl":"attribute [ext] ext\n\n"}
{"name":"Setoid.ext'","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr s : Setoid α\nH : ∀ (a b : α), Iff (r.Rel a b) (s.Rel a b)\n⊢ Eq r s","decl":"set_option linter.deprecated false in\n@[deprecated Setoid.ext (since := \"2024-10-09\")]\ntheorem ext' {r s : Setoid α} (H : ∀ a b, r.Rel a b ↔ s.Rel a b) : r = s :=\n  ext H\n\n"}
{"name":"Setoid.ext'_iff","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr s : Setoid α\n⊢ Iff (Eq r s) (∀ (a b : α), Iff (r.Rel a b) (s.Rel a b))","decl":"set_option linter.deprecated false in\n@[deprecated Setoid.ext_iff (since := \"2024-10-09\")]\ntheorem ext'_iff {r s : Setoid α} : r = s ↔ ∀ a b, r.Rel a b ↔ s.Rel a b :=\n  ⟨fun h _ _ => h ▸ Iff.rfl, ext'⟩\n\n"}
{"name":"Setoid.eq_iff_rel_eq","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr₁ r₂ : Setoid α\n⊢ Iff (Eq r₁ r₂) (Eq ⇑r₁ ⇑r₂)","decl":"/-- Two equivalence relations are equal iff their underlying binary operations are equal. -/\ntheorem eq_iff_rel_eq {r₁ r₂ : Setoid α} : r₁ = r₂ ↔ ⇑r₁ = ⇑r₂ :=\n  ⟨fun h => h ▸ rfl, fun h => Setoid.ext fun _ _ => h ▸ Iff.rfl⟩\n\n"}
{"name":"Setoid.le_def","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr s : Setoid α\n⊢ Iff (LE.le r s) (∀ {x y : α}, r x y → s x y)","decl":"theorem le_def {r s : Setoid α} : r ≤ s ↔ ∀ {x y}, r x y → s x y :=\n  Iff.rfl\n\n"}
{"name":"Setoid.refl'","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : Setoid α\nx : α\n⊢ r x x","decl":"@[refl]\ntheorem refl' (r : Setoid α) (x) : r x x := r.iseqv.refl x\n\n"}
{"name":"Setoid.symm'","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : Setoid α\nx y : α\na✝ : r x y\n⊢ r y x","decl":"@[symm]\ntheorem symm' (r : Setoid α) : ∀ {x y}, r x y → r y x := r.iseqv.symm\n\n"}
{"name":"Setoid.trans'","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : Setoid α\nx y z : α\na✝¹ : r x y\na✝ : r y z\n⊢ r x z","decl":"@[trans]\ntheorem trans' (r : Setoid α) : ∀ {x y z}, r x y → r y z → r x z := r.iseqv.trans\n\n"}
{"name":"Setoid.comm'","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\ns : Setoid α\nx y : α\n⊢ Iff (s x y) (s y x)","decl":"theorem comm' (s : Setoid α) {x y} : s x y ↔ s y x :=\n  ⟨s.symm', s.symm'⟩\n\n"}
{"name":"Setoid.ker_mk_eq","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : Setoid α\n⊢ Eq (Setoid.ker Quotient.mk'') r","decl":"/-- The kernel of the quotient map induced by an equivalence relation r equals r. -/\n@[simp]\ntheorem ker_mk_eq (r : Setoid α) : ker (@Quotient.mk'' _ r) = r :=\n  ext fun _ _ => Quotient.eq\n\n"}
{"name":"Setoid.ker_apply_mk_out","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Eq (f (Quotient.mk (Setoid.ker f) a).out) (f a)","decl":"theorem ker_apply_mk_out {f : α → β} (a : α) : f (⟦a⟧ : Quotient (Setoid.ker f)).out = f a :=\n  @Quotient.mk_out _ (Setoid.ker f) a\n\n"}
{"name":"Setoid.ker_apply_mk_out'","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Eq (f (Quotient.mk (Setoid.ker f) a).out') (f a)","decl":"set_option linter.deprecated false in\n@[deprecated ker_apply_mk_out (since := \"2024-10-19\")]\ntheorem ker_apply_mk_out' {f : α → β} (a : α) :\n    f (Quotient.mk _ a : Quotient <| Setoid.ker f).out' = f a :=\n  @Quotient.mk_out' _ (Setoid.ker f) a\n\n"}
{"name":"Setoid.ker_def","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx y : α\n⊢ Iff ((Setoid.ker f) x y) (Eq (f x) (f y))","decl":"theorem ker_def {f : α → β} {x y : α} : ker f x y ↔ f x = f y :=\n  Iff.rfl\n\n"}
{"name":"Setoid.prod_apply","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Setoid α\ns : Setoid β\nx₁ x₂ : α\ny₁ y₂ : β\n⊢ Iff ((r.prod s) { fst := x₁, snd := y₁ } { fst := x₂, snd := y₂ }) (And (r x₁ x₂) (s y₁ y₂))","decl":"lemma prod_apply {r : Setoid α} {s : Setoid β} {x₁ x₂ : α} {y₁ y₂ : β} :\n    @Setoid.r _ (r.prod s) (x₁, y₁) (x₂, y₂) ↔ (@Setoid.r _ r x₁ x₂ ∧ @Setoid.r _ s y₁ y₂) :=\n  Iff.rfl\n\n"}
{"name":"Setoid.piSetoid_apply","module":"Mathlib.Data.Setoid.Basic","initialProofState":"ι : Sort u_3\nα : ι → Sort u_4\nr : (i : ι) → Setoid (α i)\nx y : (i : ι) → α i\n⊢ Iff (piSetoid x y) (∀ (i : ι), (r i) (x i) (y i))","decl":"lemma piSetoid_apply {ι : Sort*} {α : ι → Sort*} {r : ∀ i, Setoid (α i)} {x y : ∀ i, α i} :\n    @Setoid.r _ (@piSetoid _ _ r) x y ↔ ∀ i, @Setoid.r _ (r i) (x i) (y i) :=\n  Iff.rfl\n\n"}
{"name":"Setoid.prodQuotientEquiv_apply","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Setoid α\ns : Setoid β\nx✝ : Prod (Quotient r) (Quotient s)\n⊢ Eq ((r.prodQuotientEquiv s) x✝) (Setoid.prodQuotientEquiv.match_1 r s (fun x => Quotient (r.prod s)) x✝ fun x y => Quotient.map₂ Prod.mk ⋯ x y)","decl":"/-- A bijection between the product of two quotients and the quotient by the product of the\nequivalence relations. -/\n@[simps]\ndef prodQuotientEquiv (r : Setoid α) (s : Setoid β) :\n    Quotient r × Quotient s ≃ Quotient (r.prod s) where\n  toFun | (x, y) => Quotient.map₂ Prod.mk (fun _ _ hx _ _ hy ↦ ⟨hx, hy⟩) x y\n  invFun q := Quotient.liftOn' q (fun xy ↦ (Quotient.mk'' xy.1, Quotient.mk'' xy.2))\n    fun x y hxy ↦ Prod.ext (by simpa using hxy.1) (by simpa using hxy.2)\n  left_inv q := by\n    rcases q with ⟨qa, qb⟩\n    exact Quotient.inductionOn₂' qa qb fun _ _ ↦ rfl\n  right_inv q := by\n    simp only\n    refine Quotient.inductionOn' q fun _ ↦ rfl\n\n"}
{"name":"Setoid.prodQuotientEquiv_symm_apply","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Setoid α\ns : Setoid β\nq : Quotient (r.prod s)\n⊢ Eq ((r.prodQuotientEquiv s).symm q) (q.liftOn' (fun xy => { fst := Quotient.mk'' xy.1, snd := Quotient.mk'' xy.2 }) ⋯)","decl":"/-- A bijection between the product of two quotients and the quotient by the product of the\nequivalence relations. -/\n@[simps]\ndef prodQuotientEquiv (r : Setoid α) (s : Setoid β) :\n    Quotient r × Quotient s ≃ Quotient (r.prod s) where\n  toFun | (x, y) => Quotient.map₂ Prod.mk (fun _ _ hx _ _ hy ↦ ⟨hx, hy⟩) x y\n  invFun q := Quotient.liftOn' q (fun xy ↦ (Quotient.mk'' xy.1, Quotient.mk'' xy.2))\n    fun x y hxy ↦ Prod.ext (by simpa using hxy.1) (by simpa using hxy.2)\n  left_inv q := by\n    rcases q with ⟨qa, qb⟩\n    exact Quotient.inductionOn₂' qa qb fun _ _ ↦ rfl\n  right_inv q := by\n    simp only\n    refine Quotient.inductionOn' q fun _ ↦ rfl\n\n"}
{"name":"Setoid.piQuotientEquiv_symm_apply","module":"Mathlib.Data.Setoid.Basic","initialProofState":"ι : Sort u_3\nα : ι → Sort u_4\nr : (i : ι) → Setoid (α i)\nq : Quotient piSetoid\ni : ι\n⊢ Eq ((Setoid.piQuotientEquiv r).symm q i) (q.liftOn' (fun x i => Quotient.mk'' (x i)) ⋯ i)","decl":"/-- A bijection between an indexed product of quotients and the quotient by the product of the\nequivalence relations. -/\n@[simps]\nnoncomputable def piQuotientEquiv {ι : Sort*} {α : ι → Sort*} (r : ∀ i, Setoid (α i)) :\n    (∀ i, Quotient (r i)) ≃ Quotient (@piSetoid _ _ r) where\n  toFun x := Quotient.mk'' fun i ↦ (x i).out\n  invFun q := Quotient.liftOn' q (fun x i ↦ Quotient.mk'' (x i)) fun x y hxy ↦ by\n    ext i\n    simpa using hxy i\n  left_inv q := by\n    ext i\n    simp\n  right_inv q := by\n    refine Quotient.inductionOn' q fun _ ↦ ?_\n    simp only [Quotient.liftOn'_mk'', Quotient.eq'']\n    intro i\n    change Setoid.r _ _\n    rw [← Quotient.eq'']\n    simp\n\n"}
{"name":"Setoid.piQuotientEquiv_apply","module":"Mathlib.Data.Setoid.Basic","initialProofState":"ι : Sort u_3\nα : ι → Sort u_4\nr : (i : ι) → Setoid (α i)\nx : (i : ι) → Quotient (r i)\n⊢ Eq ((Setoid.piQuotientEquiv r) x) (Quotient.mk'' fun i => (x i).out)","decl":"/-- A bijection between an indexed product of quotients and the quotient by the product of the\nequivalence relations. -/\n@[simps]\nnoncomputable def piQuotientEquiv {ι : Sort*} {α : ι → Sort*} (r : ∀ i, Setoid (α i)) :\n    (∀ i, Quotient (r i)) ≃ Quotient (@piSetoid _ _ r) where\n  toFun x := Quotient.mk'' fun i ↦ (x i).out\n  invFun q := Quotient.liftOn' q (fun x i ↦ Quotient.mk'' (x i)) fun x y hxy ↦ by\n    ext i\n    simpa using hxy i\n  left_inv q := by\n    ext i\n    simp\n  right_inv q := by\n    refine Quotient.inductionOn' q fun _ ↦ ?_\n    simp only [Quotient.liftOn'_mk'', Quotient.eq'']\n    intro i\n    change Setoid.r _ _\n    rw [← Quotient.eq'']\n    simp\n\n"}
{"name":"Setoid.inf_def","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr s : Setoid α\n⊢ Eq (⇑(Min.min r s)) (Min.min ⇑r ⇑s)","decl":"/-- The infimum of 2 equivalence relations r and s is the same relation as the infimum\n    of the underlying binary operations. -/\ntheorem inf_def {r s : Setoid α} : ⇑(r ⊓ s) = ⇑r ⊓ ⇑s :=\n  rfl\n\n"}
{"name":"Setoid.inf_iff_and","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr s : Setoid α\nx y : α\n⊢ Iff ((Min.min r s) x y) (And (r x y) (s x y))","decl":"theorem inf_iff_and {r s : Setoid α} {x y} : (r ⊓ s) x y ↔ r x y ∧ s x y :=\n  Iff.rfl\n\n"}
{"name":"Setoid.sInf_def","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\ns : Set (Setoid α)\n⊢ Eq (⇑(InfSet.sInf s)) (InfSet.sInf (Set.image (@Setoid.r α) s))","decl":"/-- The underlying binary operation of the infimum of a set of equivalence relations\n    is the infimum of the set's image under the map to the underlying binary operation. -/\ntheorem sInf_def {s : Set (Setoid α)} : ⇑(sInf s) = sInf ((⇑) '' s) := by\n  ext\n  simp only [sInf_image, iInf_apply, iInf_Prop_eq]\n  rfl\n\n"}
{"name":"Setoid.top_def","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq (⇑Top.top) Top.top","decl":"@[simp]\ntheorem top_def : ⇑(⊤ : Setoid α) = ⊤ :=\n  rfl\n\n"}
{"name":"Setoid.bot_def","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\n⊢ Eq ⇑Bot.bot fun x1 x2 => Eq x1 x2","decl":"@[simp]\ntheorem bot_def : ⇑(⊥ : Setoid α) = (· = ·) :=\n  rfl\n\n"}
{"name":"Setoid.eq_top_iff","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\ns : Setoid α\n⊢ Iff (Eq s Top.top) (∀ (x y : α), s x y)","decl":"theorem eq_top_iff {s : Setoid α} : s = (⊤ : Setoid α) ↔ ∀ x y : α, s x y := by\n  rw [_root_.eq_top_iff, Setoid.le_def, Setoid.top_def]\n  simp only [Pi.top_apply, Prop.top_eq_true, forall_true_left]\n\n"}
{"name":"Setoid.sInf_equiv","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nS : Set (Setoid α)\nx y : α\n⊢ Iff (HasEquiv.Equiv x y) (∀ (s : Setoid α), Membership.mem S s → s x y)","decl":"lemma sInf_equiv {S : Set (Setoid α)} {x y : α} :\n    letI := sInf S\n    x ≈ y ↔ ∀ s ∈ S, s x y := Iff.rfl\n\n"}
{"name":"Setoid.sInf_iff","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nS : Set (Setoid α)\nx y : α\n⊢ Iff ((InfSet.sInf S) x y) (∀ (s : Setoid α), Membership.mem S s → s x y)","decl":"lemma sInf_iff {S : Set (Setoid α)} {x y : α} :\n    sInf S x y ↔ ∀ s ∈ S, s x y := Iff.rfl\n\n"}
{"name":"Setoid.quotient_mk_sInf_eq","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nS : Set (Setoid α)\nx y : α\n⊢ Iff (Eq (Quotient.mk (InfSet.sInf S) x) (Quotient.mk (InfSet.sInf S) y)) (∀ (s : Setoid α), Membership.mem S s → s x y)","decl":"lemma quotient_mk_sInf_eq {S : Set (Setoid α)} {x y : α} :\n    Quotient.mk (sInf S) x = Quotient.mk (sInf S) y ↔ ∀ s ∈ S, s x y := by\n  simp [sInf_iff]\n\n"}
{"name":"Setoid.eqvGen_eq","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq (Relation.EqvGen.setoid r) (InfSet.sInf (setOf fun s => ∀ ⦃x y : α⦄, r x y → s x y))","decl":"/-- The inductively defined equivalence closure of a binary relation r is the infimum\n    of the set of all equivalence relations containing r. -/\ntheorem eqvGen_eq (r : α → α → Prop) :\n    EqvGen.setoid r = sInf { s : Setoid α | ∀ ⦃x y⦄, r x y → s x y } :=\n  le_antisymm\n    (fun _ _ H =>\n      EqvGen.rec (fun _ _ h _ hs => hs h) (refl' _) (fun _ _ _ => symm' _)\n        (fun _ _ _ _ _ => trans' _) H)\n    (sInf_le fun _ _ h => EqvGen.rel _ _ h)\n\n"}
{"name":"Setoid.sup_eq_eqvGen","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr s : Setoid α\n⊢ Eq (Max.max r s) (Relation.EqvGen.setoid fun x y => Or (r x y) (s x y))","decl":"/-- The supremum of two equivalence relations r and s is the equivalence closure of the binary\n    relation `x is related to y by r or s`. -/\ntheorem sup_eq_eqvGen (r s : Setoid α) :\n    r ⊔ s = EqvGen.setoid fun x y => r x y ∨ s x y := by\n  rw [eqvGen_eq]\n  apply congr_arg sInf\n  simp only [le_def, or_imp, ← forall_and]\n\n"}
{"name":"Setoid.sup_def","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr s : Setoid α\n⊢ Eq (Max.max r s) (Relation.EqvGen.setoid (Max.max ⇑r ⇑s))","decl":"/-- The supremum of 2 equivalence relations r and s is the equivalence closure of the\n    supremum of the underlying binary operations. -/\ntheorem sup_def {r s : Setoid α} : r ⊔ s = EqvGen.setoid (⇑r ⊔ ⇑s) := by\n  rw [sup_eq_eqvGen]; rfl\n\n"}
{"name":"Setoid.sSup_eq_eqvGen","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nS : Set (Setoid α)\n⊢ Eq (SupSet.sSup S) (Relation.EqvGen.setoid fun x y => Exists fun r => And (Membership.mem S r) (r x y))","decl":"/-- The supremum of a set S of equivalence relations is the equivalence closure of the binary\n    relation `there exists r ∈ S relating x and y`. -/\ntheorem sSup_eq_eqvGen (S : Set (Setoid α)) :\n    sSup S = EqvGen.setoid fun x y => ∃ r : Setoid α, r ∈ S ∧ r x y := by\n  rw [eqvGen_eq]\n  apply congr_arg sInf\n  simp only [upperBounds, le_def, and_imp, exists_imp]\n  ext\n  exact ⟨fun H x y r hr => H hr, fun H r hr x y => H r hr⟩\n\n"}
{"name":"Setoid.sSup_def","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\ns : Set (Setoid α)\n⊢ Eq (SupSet.sSup s) (Relation.EqvGen.setoid (SupSet.sSup (Set.image (@Setoid.r α) s)))","decl":"/-- The supremum of a set of equivalence relations is the equivalence closure of the\n    supremum of the set's image under the map to the underlying binary operation. -/\ntheorem sSup_def {s : Set (Setoid α)} : sSup s = EqvGen.setoid (sSup ((⇑) '' s)) := by\n  rw [sSup_eq_eqvGen, sSup_image]\n  congr with (x y)\n  simp only [iSup_apply, iSup_Prop_eq, exists_prop]\n\n"}
{"name":"Setoid.eqvGen_of_setoid","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : Setoid α\n⊢ Eq (Relation.EqvGen.setoid ⇑r) r","decl":"/-- The equivalence closure of an equivalence relation r is r. -/\n@[simp]\ntheorem eqvGen_of_setoid (r : Setoid α) : EqvGen.setoid r.r = r :=\n  le_antisymm (by rw [eqvGen_eq]; exact sInf_le fun _ _ => id) EqvGen.rel\n\n"}
{"name":"Setoid.eqvGen_idem","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Eq (Relation.EqvGen.setoid ⇑(Relation.EqvGen.setoid r)) (Relation.EqvGen.setoid r)","decl":"/-- Equivalence closure is idempotent. -/\ntheorem eqvGen_idem (r : α → α → Prop) : EqvGen.setoid (EqvGen.setoid r) = EqvGen.setoid r :=\n  eqvGen_of_setoid _\n\n"}
{"name":"Setoid.eqvGen_le","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Setoid α\nh : ∀ (x y : α), r x y → s x y\n⊢ LE.le (Relation.EqvGen.setoid r) s","decl":"/-- The equivalence closure of a binary relation r is contained in any equivalence\n    relation containing r. -/\ntheorem eqvGen_le {r : α → α → Prop} {s : Setoid α} (h : ∀ x y, r x y → s x y) :\n    EqvGen.setoid r ≤ s := by rw [eqvGen_eq]; exact sInf_le h\n\n"}
{"name":"Setoid.eqvGen_mono","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr s : α → α → Prop\nh : ∀ (x y : α), r x y → s x y\n⊢ LE.le (Relation.EqvGen.setoid r) (Relation.EqvGen.setoid s)","decl":"/-- Equivalence closure of binary relations is monotone. -/\ntheorem eqvGen_mono {r s : α → α → Prop} (h : ∀ x y, r x y → s x y) :\n    EqvGen.setoid r ≤ EqvGen.setoid s :=\n  eqvGen_le fun _ _ hr => EqvGen.rel _ _ <| h _ _ hr\n\n"}
{"name":"Setoid.injective_iff_ker_bot","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Iff (Function.Injective f) (Eq (Setoid.ker f) Bot.bot)","decl":"/-- A function from α to β is injective iff its kernel is the bottom element of the complete lattice\n    of equivalence relations on α. -/\ntheorem injective_iff_ker_bot (f : α → β) : Injective f ↔ ker f = ⊥ :=\n  (@eq_bot_iff (Setoid α) _ _ (ker f)).symm\n\n"}
{"name":"Setoid.ker_iff_mem_preimage","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx y : α\n⊢ Iff ((Setoid.ker f) x y) (Membership.mem (Set.preimage f (Singleton.singleton (f y))) x)","decl":"/-- The elements related to x ∈ α by the kernel of f are those in the preimage of f(x) under f. -/\ntheorem ker_iff_mem_preimage {f : α → β} {x y} : ker f x y ↔ x ∈ f ⁻¹' {f y} :=\n  Iff.rfl\n\n"}
{"name":"Setoid.lift_unique","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Setoid α\nf : α → β\nH : LE.le r (Setoid.ker f)\ng : Quotient r → β\nHg : Eq f (Function.comp g Quotient.mk'')\n⊢ Eq (Quotient.lift f H) g","decl":"/-- The uniqueness part of the universal property for quotients of an arbitrary type. -/\ntheorem lift_unique {r : Setoid α} {f : α → β} (H : r ≤ ker f) (g : Quotient r → β)\n    (Hg : f = g ∘ Quotient.mk'') : Quotient.lift f H = g := by\n  ext ⟨x⟩\n  rw [← Quotient.mk, Quotient.lift_mk f H, Hg, Function.comp_apply, Quotient.mk''_eq_mk]\n\n"}
{"name":"Setoid.ker_lift_injective","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Function.Injective (Quotient.lift f ⋯)","decl":"/-- Given a map f from α to β, the natural map from the quotient of α by the kernel of f is\n    injective. -/\ntheorem ker_lift_injective (f : α → β) : Injective (@Quotient.lift _ _ (ker f) f fun _ _ h => h) :=\n  fun x y => Quotient.inductionOn₂' x y fun _ _ h => Quotient.sound' h\n\n"}
{"name":"Setoid.ker_eq_lift_of_injective","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Setoid α\nf : α → β\nH : ∀ (x y : α), r x y → Eq (f x) (f y)\nh : Function.Injective (Quotient.lift f H)\n⊢ Eq (Setoid.ker f) r","decl":"/-- Given a map f from α to β, the kernel of f is the unique equivalence relation on α whose\n    induced map from the quotient of α to β is injective. -/\ntheorem ker_eq_lift_of_injective {r : Setoid α} (f : α → β) (H : ∀ x y, r x y → f x = f y)\n    (h : Injective (Quotient.lift f H)) : ker f = r :=\n  le_antisymm\n    (fun x y hk =>\n      Quotient.exact <| h <| show Quotient.lift f H ⟦x⟧ = Quotient.lift f H ⟦y⟧ from hk)\n    H\n\n"}
{"name":"Setoid.quotientKerEquivOfRightInverse_apply","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nhf : Function.RightInverse g f\na : Quotient (Setoid.ker f)\n⊢ Eq ((Setoid.quotientKerEquivOfRightInverse f g hf) a) (a.liftOn' f ⋯)","decl":"/-- If `f` has a computable right-inverse, then the quotient by its kernel is equivalent to its\ndomain. -/\n@[simps]\ndef quotientKerEquivOfRightInverse (g : β → α) (hf : Function.RightInverse g f) :\n    Quotient (ker f) ≃ β where\n  toFun a := (Quotient.liftOn' a f) fun _ _ => id\n  invFun b := Quotient.mk'' (g b)\n  left_inv a := Quotient.inductionOn' a fun a => Quotient.sound' <| hf (f a)\n  right_inv := hf\n\n"}
{"name":"Setoid.quotientKerEquivOfRightInverse_symm_apply","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nhf : Function.RightInverse g f\nb : β\n⊢ Eq ((Setoid.quotientKerEquivOfRightInverse f g hf).symm b) (Quotient.mk'' (g b))","decl":"/-- If `f` has a computable right-inverse, then the quotient by its kernel is equivalent to its\ndomain. -/\n@[simps]\ndef quotientKerEquivOfRightInverse (g : β → α) (hf : Function.RightInverse g f) :\n    Quotient (ker f) ≃ β where\n  toFun a := (Quotient.liftOn' a f) fun _ _ => id\n  invFun b := Quotient.mk'' (g b)\n  left_inv a := Quotient.inductionOn' a fun a => Quotient.sound' <| hf (f a)\n  right_inv := hf\n\n"}
{"name":"Setoid.mapOfSurjective_eq_map","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : Setoid α\nf : α → β\nh : LE.le (Setoid.ker f) r\nhf : Function.Surjective f\n⊢ Eq (r.map f) (r.mapOfSurjective f h hf)","decl":"/-- A special case of the equivalence closure of an equivalence relation r equalling r. -/\ntheorem mapOfSurjective_eq_map (h : ker f ≤ r) (hf : Surjective f) :\n    map r f = mapOfSurjective r f h hf := by\n  rw [← eqvGen_of_setoid (mapOfSurjective r f h hf)]; rfl\n\n"}
{"name":"Setoid.comap_rel","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nr : Setoid β\nx y : α\n⊢ Iff ((Setoid.comap f r) x y) (r (f x) (f y))","decl":"theorem comap_rel (f : α → β) (r : Setoid β) (x y : α) : comap f r x y ↔ r (f x) (f y) :=\n  Iff.rfl\n\n"}
{"name":"Setoid.comap_eq","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nr : Setoid β\n⊢ Eq (Setoid.comap f r) (Setoid.ker (Function.comp Quotient.mk'' f))","decl":"/-- Given a map `f : N → M` and an equivalence relation `r` on `β`, the equivalence relation\n    induced on `α` by `f` equals the kernel of `r`'s quotient map composed with `f`. -/\ntheorem comap_eq {f : α → β} {r : Setoid β} : comap f r = ker (@Quotient.mk'' _ r ∘ f) :=\n  ext fun x y => show _ ↔ ⟦_⟧ = ⟦_⟧ by rw [Quotient.eq]; rfl\n\n"}
{"name":"Quotient.subsingleton_iff","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\ns : Setoid α\n⊢ Iff (Subsingleton (Quotient s)) (Eq s Top.top)","decl":"@[simp]\ntheorem Quotient.subsingleton_iff {s : Setoid α} : Subsingleton (Quotient s) ↔ s = ⊤ := by\n  simp only [_root_.subsingleton_iff, eq_top_iff, Setoid.le_def, Setoid.top_def, Pi.top_apply,\n    forall_const]\n  refine Quotient.mk'_surjective.forall.trans (forall_congr' fun a => ?_)\n  refine Quotient.mk'_surjective.forall.trans (forall_congr' fun b => ?_)\n  simp_rw [Prop.top_eq_true, true_implies, Quotient.eq']\n\n"}
{"name":"Quot.subsingleton_iff","module":"Mathlib.Data.Setoid.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (Subsingleton (Quot r)) (Eq (Relation.EqvGen r) Top.top)","decl":"theorem Quot.subsingleton_iff (r : α → α → Prop) :\n    Subsingleton (Quot r) ↔ Relation.EqvGen r = ⊤ := by\n  simp only [_root_.subsingleton_iff, _root_.eq_top_iff, Pi.le_def, Pi.top_apply, forall_const]\n  refine Quot.mk_surjective.forall.trans (forall_congr' fun a => ?_)\n  refine Quot.mk_surjective.forall.trans (forall_congr' fun b => ?_)\n  rw [Quot.eq]\n  simp only [forall_const, le_Prop_eq, Pi.top_apply, Prop.top_eq_true, true_implies]\n"}
