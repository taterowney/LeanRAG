{"name":"NumberField.Units.regulator_ne_zero","module":"Mathlib.NumberTheory.NumberField.Units.Regulator","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Ne (NumberField.Units.regulator K) 0","decl":"open scoped Classical in\ntheorem regulator_ne_zero : regulator K ‚â† 0 := ZLattice.covolume_ne_zero (unitLattice K) volume\n\n"}
{"name":"NumberField.Units.regulator_pos","module":"Mathlib.NumberTheory.NumberField.Units.Regulator","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ LT.lt 0 (NumberField.Units.regulator K)","decl":"open scoped Classical in\ntheorem regulator_pos : 0 < regulator K := ZLattice.covolume_pos (unitLattice K) volume\n\n"}
{"name":"NumberField.Units.regulator_eq_det'","module":"Mathlib.NumberTheory.NumberField.Units.Regulator","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\ne : Equiv (Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.w‚ÇÄ) (Fin (NumberField.Units.rank K))\n‚ä¢ Eq (NumberField.Units.regulator K) (abs (Matrix.of fun i => (NumberField.Units.logEmbedding K) (Additive.ofMul (NumberField.Units.fundSystem K (e i)))).det)","decl":"open scoped Classical in\ntheorem regulator_eq_det' (e : {w : InfinitePlace K // w ‚â† w‚ÇÄ} ‚âÉ Fin (rank K)) :\n    regulator K = |(Matrix.of fun i ‚Ü¶\n      logEmbedding K (Additive.ofMul (fundSystem K (e i)))).det| := by\n  simp_rw [regulator, ZLattice.covolume_eq_det _\n    (((basisModTorsion K).map (logEmbeddingEquiv K)).reindex e.symm), Basis.coe_reindex,\n    Function.comp_def, Basis.map_apply, ‚Üê fundSystem_mk, Equiv.symm_symm, logEmbeddingEquiv_apply]\n\n"}
{"name":"NumberField.Units.abs_det_eq_abs_det","module":"Mathlib.NumberTheory.NumberField.Units.Regulator","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nu : Fin (NumberField.Units.rank K) ‚Üí Units (NumberField.RingOfIntegers K)\nw‚ÇÅ w‚ÇÇ : NumberField.InfinitePlace K\ne‚ÇÅ : Equiv (Subtype fun w => Ne w w‚ÇÅ) (Fin (NumberField.Units.rank K))\ne‚ÇÇ : Equiv (Subtype fun w => Ne w w‚ÇÇ) (Fin (NumberField.Units.rank K))\n‚ä¢ Eq (abs (Matrix.of fun i w => HMul.hMul (‚Üë(‚Üëw).mult) (Real.log (‚Üëw ((algebraMap (NumberField.RingOfIntegers K) K) ‚Üë(u (e‚ÇÅ i)))))).det) (abs (Matrix.of fun i w => HMul.hMul (‚Üë(‚Üëw).mult) (Real.log (‚Üëw ((algebraMap (NumberField.RingOfIntegers K) K) ‚Üë(u (e‚ÇÇ i)))))).det)","decl":"open scoped Classical in\n/-- Let `u : Fin (rank K) ‚Üí (ùìû K)À£` be a family of units and let `w‚ÇÅ` and `w‚ÇÇ` be two infinite\nplaces. Then, the two square matrices with entries `(mult w * log w (u i))_i, {w ‚â† w_i}`, `i = 1,2`,\nhave the same determinant in absolute value. -/\ntheorem abs_det_eq_abs_det (u : Fin (rank K) ‚Üí (ùìû K)À£)\n    {w‚ÇÅ w‚ÇÇ : InfinitePlace K} (e‚ÇÅ : {w // w ‚â† w‚ÇÅ} ‚âÉ Fin (rank K))\n    (e‚ÇÇ : {w // w ‚â† w‚ÇÇ} ‚âÉ Fin (rank K)) :\n    |(Matrix.of fun i w : {w // w ‚â† w‚ÇÅ} ‚Ü¶ (mult w.val : ‚Ñù) * (w.val (u (e‚ÇÅ i) : K)).log).det| =\n    |(Matrix.of fun i w : {w // w ‚â† w‚ÇÇ} ‚Ü¶ (mult w.val : ‚Ñù) * (w.val (u (e‚ÇÇ i) : K)).log).det| := by\n  -- We construct an equiv `Fin (rank K + 1) ‚âÉ InfinitePlace K` from `e‚ÇÇ.symm`\n  let f : Fin (rank K + 1) ‚âÉ InfinitePlace K :=\n    (finSuccEquiv _).trans ((Equiv.optionSubtype _).symm e‚ÇÅ.symm).val\n  -- And `g` corresponds to the restriction of `f‚Åª¬π` to `{w // w ‚â† w‚ÇÇ}`\n  let g : {w // w ‚â† w‚ÇÇ} ‚âÉ Fin (rank K) :=\n    (Equiv.subtypeEquiv f.symm (fun _ ‚Ü¶ by simp [f])).trans\n      (finSuccAboveEquiv (f.symm w‚ÇÇ)).symm\n  have h_col := congr_arg abs <| Matrix.det_permute (g.trans e‚ÇÇ.symm)\n    (Matrix.of fun i w : {w // w ‚â† w‚ÇÇ} ‚Ü¶ (mult w.val : ‚Ñù) * (w.val (u (e‚ÇÇ i) : K)).log)\n  rw [abs_mul, ‚Üê Int.cast_abs, Equiv.Perm.sign_abs, Int.cast_one, one_mul] at h_col\n  rw [‚Üê h_col]\n  have h := congr_arg abs <| Matrix.submatrix_succAbove_det_eq_negOnePow_submatrix_succAbove_det'\n    (Matrix.of fun i w ‚Ü¶ (mult (f w) : ‚Ñù) * ((f w) (u i)).log) ?_ 0 (f.symm w‚ÇÇ)\n  ¬∑ rw [‚Üê Matrix.det_reindex_self e‚ÇÅ, ‚Üê Matrix.det_reindex_self g]\n    ¬∑ rw [Units.smul_def, abs_zsmul, Int.abs_negOnePow, one_smul] at h\n      convert h\n      ¬∑ ext; simp only [ne_eq, Matrix.reindex_apply, Matrix.submatrix_apply, Matrix.of_apply,\n          Equiv.apply_symm_apply, Equiv.trans_apply, Fin.succAbove_zero, id_eq, finSuccEquiv_succ,\n          Equiv.optionSubtype_symm_apply_apply_coe, f]\n      ¬∑ ext; simp only [ne_eq, Equiv.coe_trans, Matrix.reindex_apply, Matrix.submatrix_apply,\n          Function.comp_apply, Equiv.apply_symm_apply, id_eq, Matrix.of_apply]; rfl\n  ¬∑ intro _\n    simp_rw [Matrix.of_apply, ‚Üê Real.log_pow]\n    rw [‚Üê Real.log_prod, Equiv.prod_comp f (fun w ‚Ü¶ (w (u _) ^ (mult w))), prod_eq_abs_norm,\n      Units.norm, Rat.cast_one, Real.log_one]\n    exact fun _ _ ‚Ü¶ pow_ne_zero _ <| (map_ne_zero _).mpr (coe_ne_zero _)\n\n"}
{"name":"NumberField.Units.regulator_eq_det","module":"Mathlib.NumberTheory.NumberField.Units.Regulator","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nw' : NumberField.InfinitePlace K\ne : Equiv (Subtype fun w => Ne w w') (Fin (NumberField.Units.rank K))\n‚ä¢ Eq (NumberField.Units.regulator K) (abs (Matrix.of fun i w => HMul.hMul (‚Üë(‚Üëw).mult) (Real.log (‚Üëw ((algebraMap (NumberField.RingOfIntegers K) K) ‚Üë(NumberField.Units.fundSystem K (e i)))))).det)","decl":"open scoped Classical in\n/-- For any infinite place `w'`, the regulator is equal to the absolute value of the determinant\nof the matrix `(mult w * log w (fundSystem K i)))_i, {w ‚â† w'}`. -/\ntheorem regulator_eq_det (w' : InfinitePlace K) (e : {w // w ‚â† w'} ‚âÉ Fin (rank K)) :\n    regulator K =\n      |(Matrix.of fun i w : {w // w ‚â† w'} ‚Ü¶ (mult w.val : ‚Ñù) *\n        Real.log (w.val (fundSystem K (e i) : K))).det| := by\n  let e' : {w : InfinitePlace K // w ‚â† w‚ÇÄ} ‚âÉ Fin (rank K) := Fintype.equivOfCardEq (by\n    rw [Fintype.card_subtype_compl, Fintype.card_ofSubsingleton, Fintype.card_fin, rank])\n  simp_rw [regulator_eq_det' K e', logEmbedding, AddMonoidHom.coe_mk, ZeroHom.coe_mk]\n  exact abs_det_eq_abs_det K (fun i ‚Ü¶ fundSystem K i) e' e\n\n"}
