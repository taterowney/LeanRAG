{"name":"Nat.Subtype.coe_bot","module":"Mathlib.Data.Nat.Order.Lemmas","initialProofState":"s : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem s x\nh : Nonempty ↑s\n⊢ Eq (↑Bot.bot) (Nat.find ⋯)","decl":"theorem Subtype.coe_bot {s : Set ℕ} [DecidablePred (· ∈ s)] [h : Nonempty s] :\n    ((⊥ : s) : ℕ) = Nat.find (nonempty_subtype.1 h) :=\n  rfl\n\n"}
{"name":"Nat.set_eq_univ","module":"Mathlib.Data.Nat.Order.Lemmas","initialProofState":"S : Set Nat\n⊢ Iff (Eq S Set.univ) (And (Membership.mem S 0) (∀ (k : Nat), Membership.mem S k → Membership.mem S (HAdd.hAdd k 1)))","decl":"theorem set_eq_univ {S : Set ℕ} : S = Set.univ ↔ 0 ∈ S ∧ ∀ k : ℕ, k ∈ S → k + 1 ∈ S :=\n  ⟨by rintro rfl; simp, fun ⟨h0, hs⟩ => Set.eq_univ_of_forall (set_induction h0 hs)⟩\n\n"}
{"name":"Nat.exists_not_and_succ_of_not_zero_of_exists","module":"Mathlib.Data.Nat.Order.Lemmas","initialProofState":"p : Nat → Prop\nH' : Not (p 0)\nH : Exists fun n => p n\n⊢ Exists fun n => And (Not (p n)) (p (HAdd.hAdd n 1))","decl":"lemma exists_not_and_succ_of_not_zero_of_exists {p : ℕ → Prop} (H' : ¬ p 0) (H : ∃ n, p n) :\n    ∃ n, ¬ p n ∧ p (n + 1) := by\n  classical\n  let k := Nat.find H\n  have hk : p k := Nat.find_spec H\n  suffices 0 < k from\n    ⟨k - 1, Nat.find_min H <| Nat.pred_lt this.ne', by rwa [Nat.sub_add_cancel this]⟩\n  by_contra! contra\n  rw [le_zero_eq] at contra\n  exact H' (contra ▸ hk)\n\n"}
