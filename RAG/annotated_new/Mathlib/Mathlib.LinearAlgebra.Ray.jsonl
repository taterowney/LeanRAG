{"name":"SameRay.zero_left","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ny : M\n⊢ SameRay R 0 y","decl":"@[simp]\ntheorem zero_left (y : M) : SameRay R 0 y :=\n  Or.inl rfl\n\n"}
{"name":"SameRay.zero_right","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ SameRay R x 0","decl":"@[simp]\ntheorem zero_right (x : M) : SameRay R x 0 :=\n  Or.inr <| Or.inl rfl\n\n"}
{"name":"SameRay.of_subsingleton","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Subsingleton M\nx y : M\n⊢ SameRay R x y","decl":"@[nontriviality]\ntheorem of_subsingleton [Subsingleton M] (x y : M) : SameRay R x y := by\n  rw [Subsingleton.elim x 0]\n  exact zero_left _\n\n"}
{"name":"SameRay.of_subsingleton'","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Subsingleton R\nx y : M\n⊢ SameRay R x y","decl":"@[nontriviality]\ntheorem of_subsingleton' [Subsingleton R] (x y : M) : SameRay R x y :=\n  haveI := Module.subsingleton R M\n  of_subsingleton x y\n\n"}
{"name":"SameRay.refl","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ SameRay R x x","decl":"/-- `SameRay` is reflexive. -/\n@[refl]\ntheorem refl (x : M) : SameRay R x x := by\n  nontriviality R\n  exact Or.inr (Or.inr <| ⟨1, 1, zero_lt_one, zero_lt_one, rfl⟩)\n\n"}
{"name":"SameRay.rfl","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ SameRay R x x","decl":"protected theorem rfl : SameRay R x x :=\n  refl _\n\n"}
{"name":"SameRay.symm","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : M\nh : SameRay R x y\n⊢ SameRay R y x","decl":"/-- `SameRay` is symmetric. -/\n@[symm]\ntheorem symm (h : SameRay R x y) : SameRay R y x :=\n  (or_left_comm.1 h).imp_right <| Or.imp_right fun ⟨r₁, r₂, h₁, h₂, h⟩ => ⟨r₂, r₁, h₂, h₁, h.symm⟩\n\n"}
{"name":"SameRay.exists_pos","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : M\nh : SameRay R x y\nhx : Ne x 0\nhy : Ne y 0\n⊢ Exists fun r₁ => Exists fun r₂ => And (LT.lt 0 r₁) (And (LT.lt 0 r₂) (Eq (HSMul.hSMul r₁ x) (HSMul.hSMul r₂ y)))","decl":"/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\nsuch that `r₁ • x = r₂ • y`. -/\ntheorem exists_pos (h : SameRay R x y) (hx : x ≠ 0) (hy : y ≠ 0) :\n    ∃ r₁ r₂ : R, 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y :=\n  (h.resolve_left hx).resolve_left hy\n\n"}
{"name":"SameRay.sameRay_comm","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y : M\n⊢ Iff (SameRay R x y) (SameRay R y x)","decl":"theorem sameRay_comm : SameRay R x y ↔ SameRay R y x :=\n  ⟨SameRay.symm, SameRay.symm⟩\n\n"}
{"name":"SameRay.trans","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy : Eq y 0 → Or (Eq x 0) (Eq z 0)\n⊢ SameRay R x z","decl":"/-- `SameRay` is transitive unless the vector in the middle is zero and both other vectors are\nnonzero. -/\ntheorem trans (hxy : SameRay R x y) (hyz : SameRay R y z) (hy : y = 0 → x = 0 ∨ z = 0) :\n    SameRay R x z := by\n  rcases eq_or_ne x 0 with (rfl | hx); · exact zero_left z\n  rcases eq_or_ne z 0 with (rfl | hz); · exact zero_right x\n  rcases eq_or_ne y 0 with (rfl | hy)\n  · exact (hy rfl).elim (fun h => (hx h).elim) fun h => (hz h).elim\n  rcases hxy.exists_pos hx hy with ⟨r₁, r₂, hr₁, hr₂, h₁⟩\n  rcases hyz.exists_pos hy hz with ⟨r₃, r₄, hr₃, hr₄, h₂⟩\n  refine Or.inr (Or.inr <| ⟨r₃ * r₁, r₂ * r₄, mul_pos hr₃ hr₁, mul_pos hr₂ hr₄, ?_⟩)\n  rw [mul_smul, mul_smul, h₁, ← h₂, smul_comm]\n\n"}
{"name":"SameRay.sameRay_nonneg_smul_right","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁷ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nS : Type u_5\ninst✝⁴ : OrderedCommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : SMulPosMono S R\ninst✝ : IsScalarTower S R M\na : S\nv : M\nh : LE.le 0 a\n⊢ SameRay R v (HSMul.hSMul a v)","decl":"/-- A vector is in the same ray as a nonnegative multiple of itself. -/\nlemma sameRay_nonneg_smul_right (v : M) (h : 0 ≤ a) : SameRay R v (a • v) := by\n  obtain h | h := (algebraMap_nonneg R h).eq_or_gt\n  · rw [← algebraMap_smul R a v, h, zero_smul]\n    exact zero_right _\n  · refine Or.inr <| Or.inr ⟨algebraMap S R a, 1, h, by nontriviality R; exact zero_lt_one, ?_⟩\n    module\n\n"}
{"name":"SameRay.sameRay_nonneg_smul_left","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁷ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nS : Type u_5\ninst✝⁴ : OrderedCommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : SMulPosMono S R\ninst✝ : IsScalarTower S R M\na : S\nv : M\nha : LE.le 0 a\n⊢ SameRay R (HSMul.hSMul a v) v","decl":"/-- A nonnegative multiple of a vector is in the same ray as that vector. -/\nlemma sameRay_nonneg_smul_left (v : M) (ha : 0 ≤ a) : SameRay R (a • v) v :=\n  (sameRay_nonneg_smul_right v ha).symm\n\n"}
{"name":"SameRay.sameRay_pos_smul_right","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁷ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nS : Type u_5\ninst✝⁴ : OrderedCommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : SMulPosMono S R\ninst✝ : IsScalarTower S R M\na : S\nv : M\nha : LT.lt 0 a\n⊢ SameRay R v (HSMul.hSMul a v)","decl":"/-- A vector is in the same ray as a positive multiple of itself. -/\nlemma sameRay_pos_smul_right (v : M) (ha : 0 < a) : SameRay R v (a • v) :=\n  sameRay_nonneg_smul_right v ha.le\n\n"}
{"name":"SameRay.sameRay_pos_smul_left","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁷ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nS : Type u_5\ninst✝⁴ : OrderedCommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : SMulPosMono S R\ninst✝ : IsScalarTower S R M\na : S\nv : M\nha : LT.lt 0 a\n⊢ SameRay R (HSMul.hSMul a v) v","decl":"/-- A positive multiple of a vector is in the same ray as that vector. -/\nlemma sameRay_pos_smul_left (v : M) (ha : 0 < a) : SameRay R (a • v) v :=\n  sameRay_nonneg_smul_left v ha.le\n\n"}
{"name":"SameRay.nonneg_smul_right","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁷ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nx y : M\nS : Type u_5\ninst✝⁴ : OrderedCommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : SMulPosMono S R\ninst✝ : IsScalarTower S R M\na : S\nh : SameRay R x y\nha : LE.le 0 a\n⊢ SameRay R x (HSMul.hSMul a y)","decl":"/-- A vector is in the same ray as a nonnegative multiple of one it is in the same ray as. -/\nlemma nonneg_smul_right (h : SameRay R x y) (ha : 0 ≤ a) : SameRay R x (a • y) :=\n  h.trans (sameRay_nonneg_smul_right y ha) fun hy => Or.inr <| by rw [hy, smul_zero]\n\n"}
{"name":"SameRay.nonneg_smul_left","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁷ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nx y : M\nS : Type u_5\ninst✝⁴ : OrderedCommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : SMulPosMono S R\ninst✝ : IsScalarTower S R M\na : S\nh : SameRay R x y\nha : LE.le 0 a\n⊢ SameRay R (HSMul.hSMul a x) y","decl":"/-- A nonnegative multiple of a vector is in the same ray as one it is in the same ray as. -/\nlemma nonneg_smul_left (h : SameRay R x y) (ha : 0 ≤ a) : SameRay R (a • x) y :=\n  (h.symm.nonneg_smul_right ha).symm\n\n"}
{"name":"SameRay.pos_smul_right","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁷ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nx y : M\nS : Type u_5\ninst✝⁴ : OrderedCommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : SMulPosMono S R\ninst✝ : IsScalarTower S R M\na : S\nh : SameRay R x y\nha : LT.lt 0 a\n⊢ SameRay R x (HSMul.hSMul a y)","decl":"/-- A vector is in the same ray as a positive multiple of one it is in the same ray as. -/\ntheorem pos_smul_right (h : SameRay R x y) (ha : 0 < a) : SameRay R x (a • y) :=\n  h.nonneg_smul_right ha.le\n\n"}
{"name":"SameRay.pos_smul_left","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁷ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nx y : M\nS : Type u_5\ninst✝⁴ : OrderedCommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : SMulPosMono S R\ninst✝ : IsScalarTower S R M\na : S\nh : SameRay R x y\nhr : LT.lt 0 a\n⊢ SameRay R (HSMul.hSMul a x) y","decl":"/-- A positive multiple of a vector is in the same ray as one it is in the same ray as. -/\ntheorem pos_smul_left (h : SameRay R x y) (hr : 0 < a) : SameRay R (a • x) y :=\n  h.nonneg_smul_left hr.le\n\n"}
{"name":"SameRay.map","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁴ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nx y : M\nf : LinearMap (RingHom.id R) M N\nh : SameRay R x y\n⊢ SameRay R (f x) (f y)","decl":"/-- If two vectors are on the same ray then they remain so after applying a linear map. -/\ntheorem map (f : M →ₗ[R] N) (h : SameRay R x y) : SameRay R (f x) (f y) :=\n  (h.imp fun hx => by rw [hx, map_zero]) <|\n    Or.imp (fun hy => by rw [hy, map_zero]) fun ⟨r₁, r₂, hr₁, hr₂, h⟩ =>\n      ⟨r₁, r₂, hr₁, hr₂, by rw [← f.map_smul, ← f.map_smul, h]⟩\n\n"}
{"name":"Function.Injective.sameRay_map_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁶ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nx y : M\nF : Type u_6\ninst✝¹ : FunLike F M N\ninst✝ : LinearMapClass F R M N\nf : F\nhf : Function.Injective ⇑f\n⊢ Iff (SameRay R (f x) (f y)) (SameRay R x y)","decl":"/-- The images of two vectors under an injective linear map are on the same ray if and only if the\noriginal vectors are on the same ray. -/\ntheorem _root_.Function.Injective.sameRay_map_iff\n    {F : Type*} [FunLike F M N] [LinearMapClass F R M N]\n    {f : F} (hf : Function.Injective f) :\n    SameRay R (f x) (f y) ↔ SameRay R x y := by\n  simp only [SameRay, map_zero, ← hf.eq_iff, map_smul]\n\n"}
{"name":"SameRay.sameRay_map_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁴ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nx y : M\ne : LinearEquiv (RingHom.id R) M N\n⊢ Iff (SameRay R (e x) (e y)) (SameRay R x y)","decl":"/-- The images of two vectors under a linear equivalence are on the same ray if and only if the\noriginal vectors are on the same ray. -/\n@[simp]\ntheorem sameRay_map_iff (e : M ≃ₗ[R] N) : SameRay R (e x) (e y) ↔ SameRay R x y :=\n  Function.Injective.sameRay_map_iff (EquivLike.injective e)\n\n"}
{"name":"SameRay.smul","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁵ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nx y : M\nS : Type u_6\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass R S M\nh : SameRay R x y\ns : S\n⊢ SameRay R (HSMul.hSMul s x) (HSMul.hSMul s y)","decl":"/-- If two vectors are on the same ray then both scaled by the same action are also on the same\nray. -/\ntheorem smul {S : Type*} [Monoid S] [DistribMulAction S M] [SMulCommClass R S M]\n    (h : SameRay R x y) (s : S) : SameRay R (s • x) (s • y) :=\n  h.map (s • (LinearMap.id : M →ₗ[R] M))\n\n"}
{"name":"SameRay.add_left","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y z : M\nhx : SameRay R x z\nhy : SameRay R y z\n⊢ SameRay R (HAdd.hAdd x y) z","decl":"/-- If `x` and `y` are on the same ray as `z`, then so is `x + y`. -/\ntheorem add_left (hx : SameRay R x z) (hy : SameRay R y z) : SameRay R (x + y) z := by\n  rcases eq_or_ne x 0 with (rfl | hx₀); · rwa [zero_add]\n  rcases eq_or_ne y 0 with (rfl | hy₀); · rwa [add_zero]\n  rcases eq_or_ne z 0 with (rfl | hz₀); · apply zero_right\n  rcases hx.exists_pos hx₀ hz₀ with ⟨rx, rz₁, hrx, hrz₁, Hx⟩\n  rcases hy.exists_pos hy₀ hz₀ with ⟨ry, rz₂, hry, hrz₂, Hy⟩\n  refine Or.inr (Or.inr ⟨rx * ry, ry * rz₁ + rx * rz₂, mul_pos hrx hry, ?_, ?_⟩)\n  · positivity\n  · convert congr(ry • $Hx + rx • $Hy) using 1 <;> module\n\n"}
{"name":"SameRay.add_right","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx y z : M\nhy : SameRay R x y\nhz : SameRay R x z\n⊢ SameRay R x (HAdd.hAdd y z)","decl":"/-- If `y` and `z` are on the same ray as `x`, then so is `y + z`. -/\ntheorem add_right (hy : SameRay R x y) (hz : SameRay R x z) : SameRay R x (y + z) :=\n  (hy.symm.add_left hz.symm).symm\n\n"}
{"name":"instNonemptyRayVectorOfNontrivial","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_5\nM : Type u_6\ninst✝¹ : Zero M\ninst✝ : Nontrivial M\n⊢ Nonempty (RayVector R M)","decl":"instance {R M : Type*} [Zero M] [Nontrivial M] : Nonempty (RayVector R M) :=\n  let ⟨x, hx⟩ := exists_ne (0 : M)\n  ⟨⟨x, hx⟩⟩\n"}
{"name":"equiv_iff_sameRay","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv₁ v₂ : RayVector R M\n⊢ Iff (HasEquiv.Equiv v₁ v₂) (SameRay R ↑v₁ ↑v₂)","decl":"/-- Equivalence of nonzero vectors, in terms of `SameRay`. -/\ntheorem equiv_iff_sameRay {v₁ v₂ : RayVector R M} : v₁ ≈ v₂ ↔ SameRay R (v₁ : M) v₂ :=\n  Iff.rfl\n\n"}
{"name":"Module.Ray.ind","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nC : Module.Ray R M → Prop\nh : ∀ (v : M) (hv : Ne v 0), C (rayOfNeZero R v hv)\nx : Module.Ray R M\n⊢ C x","decl":"/-- An induction principle for `Module.Ray`, used as `induction x using Module.Ray.ind`. -/\ntheorem Module.Ray.ind {C : Module.Ray R M → Prop} (h : ∀ (v) (hv : v ≠ 0), C (rayOfNeZero R v hv))\n    (x : Module.Ray R M) : C x :=\n  Quotient.ind (Subtype.rec <| h) x\n\n"}
{"name":"instNonemptyRayOfNontrivial","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial M\n⊢ Nonempty (Module.Ray R M)","decl":"instance [Nontrivial M] : Nonempty (Module.Ray R M) :=\n  Nonempty.map Quotient.mk' inferInstance\n\n"}
{"name":"ray_eq_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv₁ v₂ : M\nhv₁ : Ne v₁ 0\nhv₂ : Ne v₂ 0\n⊢ Iff (Eq (rayOfNeZero R v₁ hv₁) (rayOfNeZero R v₂ hv₂)) (SameRay R v₁ v₂)","decl":"/-- The rays given by two nonzero vectors are equal if and only if those vectors\nsatisfy `SameRay`. -/\ntheorem ray_eq_iff {v₁ v₂ : M} (hv₁ : v₁ ≠ 0) (hv₂ : v₂ ≠ 0) :\n    rayOfNeZero R _ hv₁ = rayOfNeZero R _ hv₂ ↔ SameRay R v₁ v₂ :=\n  Quotient.eq'\n\n"}
{"name":"ray_pos_smul","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : M\nh : Ne v 0\nr : R\nhr : LT.lt 0 r\nhrv : Ne (HSMul.hSMul r v) 0\n⊢ Eq (rayOfNeZero R (HSMul.hSMul r v) hrv) (rayOfNeZero R v h)","decl":"/-- The ray given by a positive multiple of a nonzero vector. -/\n@[simp]\ntheorem ray_pos_smul {v : M} (h : v ≠ 0) {r : R} (hr : 0 < r) (hrv : r • v ≠ 0) :\n    rayOfNeZero R (r • v) hrv = rayOfNeZero R v h :=\n  (ray_eq_iff _ _).2 <| SameRay.sameRay_pos_smul_left v hr\n\n"}
{"name":"Module.Ray.map_apply","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁴ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\nv : M\nhv : Ne v 0\n⊢ Eq ((Module.Ray.map e) (rayOfNeZero R v hv)) (rayOfNeZero R (e v) ⋯)","decl":"@[simp]\ntheorem Module.Ray.map_apply (e : M ≃ₗ[R] N) (v : M) (hv : v ≠ 0) :\n    Module.Ray.map e (rayOfNeZero _ v hv) = rayOfNeZero _ (e v) (e.map_ne_zero_iff.2 hv) :=\n  rfl\n\n"}
{"name":"Module.Ray.map_refl","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Module.Ray.map (LinearEquiv.refl R M)) (Equiv.refl (Module.Ray R M))","decl":"@[simp]\ntheorem Module.Ray.map_refl : (Module.Ray.map <| LinearEquiv.refl R M) = Equiv.refl _ :=\n  Equiv.ext <| Module.Ray.ind R fun _ _ => rfl\n\n"}
{"name":"Module.Ray.map_symm","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁴ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\n⊢ Eq (Module.Ray.map e).symm (Module.Ray.map e.symm)","decl":"@[simp]\ntheorem Module.Ray.map_symm (e : M ≃ₗ[R] N) : (Module.Ray.map e).symm = Module.Ray.map e.symm :=\n  rfl\n\n"}
{"name":"Module.Ray.linearEquiv_smul_eq_map","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : LinearEquiv (RingHom.id R) M M\nv : Module.Ray R M\n⊢ Eq (HSMul.hSMul e v) ((Module.Ray.map e) v)","decl":"/-- The action via `LinearEquiv.apply_distribMulAction` corresponds to `Module.Ray.map`. -/\n@[simp]\ntheorem Module.Ray.linearEquiv_smul_eq_map (e : M ≃ₗ[R] M) (v : Module.Ray R M) :\n    e • v = Module.Ray.map e v :=\n  rfl\n\n"}
{"name":"smul_rayOfNeZero","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁵ : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nG : Type u_5\ninst✝² : Group G\ninst✝¹ : DistribMulAction G M\ninst✝ : SMulCommClass R G M\ng : G\nv : M\nhv : Ne v 0\n⊢ Eq (HSMul.hSMul g (rayOfNeZero R v hv)) (rayOfNeZero R (HSMul.hSMul g v) ⋯)","decl":"@[simp]\ntheorem smul_rayOfNeZero (g : G) (v : M) (hv) :\n    g • rayOfNeZero R v hv = rayOfNeZero R (g • v) ((smul_ne_zero_iff_ne _).2 hv) :=\n  rfl\n\n"}
{"name":"Module.Ray.units_smul_of_pos","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nu : Units R\nhu : LT.lt 0 ↑u\nv : Module.Ray R M\n⊢ Eq (HSMul.hSMul u v) v","decl":"/-- Scaling by a positive unit is a no-op. -/\ntheorem units_smul_of_pos (u : Rˣ) (hu : 0 < (u.1 : R)) (v : Module.Ray R M) : u • v = v := by\n  induction v using Module.Ray.ind\n  rw [smul_rayOfNeZero, ray_eq_iff]\n  exact SameRay.sameRay_pos_smul_left _ hu\n\n"}
{"name":"Module.Ray.someRayVector_ray","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : Module.Ray R M\n⊢ Eq (Quotient.mk (RayVector.Setoid R M) x.someRayVector) x","decl":"/-- The ray of `someRayVector`. -/\n@[simp]\ntheorem someRayVector_ray (x : Module.Ray R M) : (⟦x.someRayVector⟧ : Module.Ray R M) = x :=\n  Quotient.out_eq _\n\n"}
{"name":"Module.Ray.someVector_ne_zero","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : Module.Ray R M\n⊢ Ne x.someVector 0","decl":"/-- `someVector` is nonzero. -/\n@[simp]\ntheorem someVector_ne_zero (x : Module.Ray R M) : x.someVector ≠ 0 :=\n  x.someRayVector.property\n\n"}
{"name":"Module.Ray.someVector_ray","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommSemiring R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : Module.Ray R M\n⊢ Eq (rayOfNeZero R x.someVector ⋯) x","decl":"/-- The ray of `someVector`. -/\n@[simp]\ntheorem someVector_ray (x : Module.Ray R M) : rayOfNeZero R _ x.someVector_ne_zero = x :=\n  (congr_arg _ (Subtype.coe_eta _ _) :).trans x.out_eq\n\n"}
{"name":"sameRay_neg_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\n⊢ Iff (SameRay R (Neg.neg x) (Neg.neg y)) (SameRay R x y)","decl":"/-- `SameRay.neg` as an `iff`. -/\n@[simp]\ntheorem sameRay_neg_iff : SameRay R (-x) (-y) ↔ SameRay R x y := by\n  simp only [SameRay, neg_eq_zero, smul_neg, neg_inj]\n\n"}
{"name":"SameRay.of_neg","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\na✝ : SameRay R (Neg.neg x) (Neg.neg y)\n⊢ SameRay R x y","decl":"alias ⟨SameRay.of_neg, SameRay.neg⟩ := sameRay_neg_iff\n\n"}
{"name":"SameRay.neg","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\na✝ : SameRay R x y\n⊢ SameRay R (Neg.neg x) (Neg.neg y)","decl":"alias ⟨SameRay.of_neg, SameRay.neg⟩ := sameRay_neg_iff\n\n"}
{"name":"sameRay_neg_swap","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\n⊢ Iff (SameRay R (Neg.neg x) y) (SameRay R x (Neg.neg y))","decl":"theorem sameRay_neg_swap : SameRay R (-x) y ↔ SameRay R x (-y) := by rw [← sameRay_neg_iff, neg_neg]\n\n"}
{"name":"eq_zero_of_sameRay_neg_smul_right","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : StrictOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nx : M\ninst✝ : NoZeroSMulDivisors R M\nr : R\nhr : LT.lt r 0\nh : SameRay R x (HSMul.hSMul r x)\n⊢ Eq x 0","decl":"theorem eq_zero_of_sameRay_neg_smul_right [NoZeroSMulDivisors R M] {r : R} (hr : r < 0)\n    (h : SameRay R x (r • x)) : x = 0 := by\n  rcases h with (rfl | h₀ | ⟨r₁, r₂, hr₁, hr₂, h⟩)\n  · rfl\n  · simpa [hr.ne] using h₀\n  · rw [← sub_eq_zero, smul_smul, ← sub_smul, smul_eq_zero] at h\n    refine h.resolve_left (ne_of_gt <| sub_pos.2 ?_)\n    exact (mul_neg_of_pos_of_neg hr₂ hr).trans hr₁\n\n"}
{"name":"eq_zero_of_sameRay_self_neg","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : StrictOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nx : M\ninst✝ : NoZeroSMulDivisors R M\nh : SameRay R x (Neg.neg x)\n⊢ Eq x 0","decl":"/-- If a vector is in the same ray as its negation, that vector is zero. -/\ntheorem eq_zero_of_sameRay_self_neg [NoZeroSMulDivisors R M] (h : SameRay R x (-x)) : x = 0 := by\n  nontriviality M; haveI : Nontrivial R := Module.nontrivial R M\n  refine eq_zero_of_sameRay_neg_smul_right (neg_lt_zero.2 (zero_lt_one' R)) ?_\n  rwa [neg_one_smul]\n\n"}
{"name":"RayVector.coe_neg","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"M : Type u_2\ninst✝ : AddCommGroup M\nR : Type u_4\nv : RayVector R M\n⊢ Eq (↑(Neg.neg v)) (Neg.neg ↑v)","decl":"/-- Negating a nonzero vector commutes with coercion to the underlying module. -/\n@[simp, norm_cast]\ntheorem coe_neg {R : Type*} (v : RayVector R M) : ↑(-v) = -(v : M) :=\n  rfl\n\n"}
{"name":"RayVector.equiv_neg_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nv₁ v₂ : RayVector R M\n⊢ Iff (HasEquiv.Equiv (Neg.neg v₁) (Neg.neg v₂)) (HasEquiv.Equiv v₁ v₂)","decl":"/-- If two nonzero vectors are equivalent, so are their negations. -/\n@[simp]\ntheorem equiv_neg_iff {v₁ v₂ : RayVector R M} : -v₁ ≈ -v₂ ↔ v₁ ≈ v₂ :=\n  sameRay_neg_iff\n\n"}
{"name":"neg_rayOfNeZero","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nv : M\nh : Ne v 0\n⊢ Eq (Neg.neg (rayOfNeZero R v h)) (rayOfNeZero R (Neg.neg v) ⋯)","decl":"/-- The ray given by the negation of a nonzero vector. -/\n@[simp]\ntheorem neg_rayOfNeZero (v : M) (h : v ≠ 0) :\n    -rayOfNeZero R _ h = rayOfNeZero R (-v) (neg_ne_zero.2 h) :=\n  rfl\n\n"}
{"name":"Module.Ray.ne_neg_self","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : StrictOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : Module.Ray R M\n⊢ Ne x (Neg.neg x)","decl":"/-- A ray does not equal its own negation. -/\ntheorem ne_neg_self [NoZeroSMulDivisors R M] (x : Module.Ray R M) : x ≠ -x := by\n  induction' x using Module.Ray.ind with x hx\n  rw [neg_rayOfNeZero, Ne, ray_eq_iff]\n  exact mt eq_zero_of_sameRay_self_neg hx\n\n"}
{"name":"Module.Ray.neg_units_smul","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nu : Units R\nv : Module.Ray R M\n⊢ Eq (HSMul.hSMul (Neg.neg u) v) (Neg.neg (HSMul.hSMul u v))","decl":"theorem neg_units_smul (u : Rˣ) (v : Module.Ray R M) : -u • v = -(u • v) := by\n  induction v using Module.Ray.ind\n  simp only [smul_rayOfNeZero, Units.smul_def, Units.val_neg, neg_smul, neg_rayOfNeZero]\n\n-- Porting note: `(u.1 : R)` was `(u : R)`, CoeHead from R to Rˣ does not seem to work.\n"}
{"name":"Module.Ray.units_smul_of_neg","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : StrictOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nu : Units R\nhu : LT.lt (↑u) 0\nv : Module.Ray R M\n⊢ Eq (HSMul.hSMul u v) (Neg.neg v)","decl":"/-- Scaling by a negative unit is negation. -/\ntheorem units_smul_of_neg (u : Rˣ) (hu : u.1 < 0) (v : Module.Ray R M) : u • v = -v := by\n  rw [← neg_inj, neg_neg, ← neg_units_smul, units_smul_of_pos]\n  rwa [Units.val_neg, Right.neg_pos_iff]\n\n"}
{"name":"Module.Ray.map_neg","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝⁴ : StrictOrderedCommRing R\nM : Type u_2\nN : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M N\nv : Module.Ray R M\n⊢ Eq ((Module.Ray.map f) (Neg.neg v)) (Neg.neg ((Module.Ray.map f) v))","decl":"@[simp]\nprotected theorem map_neg (f : M ≃ₗ[R] N) (v : Module.Ray R M) : map f (-v) = -map f v := by\n  induction' v using Module.Ray.ind with g hg\n  simp\n\n"}
{"name":"sameRay_of_mem_orbit","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nv₁ v₂ : M\nh : Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem (Units.posSubgroup R) x) v₂) v₁\n⊢ SameRay R v₁ v₂","decl":"/-- `SameRay` follows from membership of `MulAction.orbit` for the `Units.posSubgroup`. -/\ntheorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :\n    SameRay R v₁ v₂ := by\n  rcases h with ⟨⟨r, hr : 0 < r.1⟩, rfl : r • v₂ = v₁⟩\n  exact SameRay.sameRay_pos_smul_left _ hr\n\n"}
{"name":"units_inv_smul","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedCommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nu : Units R\nv : Module.Ray R M\n⊢ Eq (HSMul.hSMul (Inv.inv u) v) (HSMul.hSMul u v)","decl":"/-- Scaling by an inverse unit is the same as scaling by itself. -/\n@[simp]\ntheorem units_inv_smul (u : Rˣ) (v : Module.Ray R M) : u⁻¹ • v = u • v :=\n  have := mul_self_pos.2 u.ne_zero\n  calc\n    u⁻¹ • v = (u * u) • u⁻¹ • v := Eq.symm <| (u⁻¹ • v).units_smul_of_pos _ (by exact this)\n    _ = u • v := by rw [mul_smul, smul_inv_smul]\n\n"}
{"name":"sameRay_smul_right_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\nr : R\n⊢ Iff (SameRay R v (HSMul.hSMul r v)) (Or (LE.le 0 r) (Eq v 0))","decl":"@[simp]\ntheorem sameRay_smul_right_iff {v : M} {r : R} : SameRay R v (r • v) ↔ 0 ≤ r ∨ v = 0 :=\n  ⟨fun hrv => or_iff_not_imp_left.2 fun hr => eq_zero_of_sameRay_neg_smul_right (not_le.1 hr) hrv,\n    or_imp.2 ⟨SameRay.sameRay_nonneg_smul_right v, fun h => h.symm ▸ SameRay.zero_left _⟩⟩\n\n"}
{"name":"sameRay_smul_right_iff_of_ne","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\nhv : Ne v 0\nr : R\nhr : Ne r 0\n⊢ Iff (SameRay R v (HSMul.hSMul r v)) (LT.lt 0 r)","decl":"/-- A nonzero vector is in the same ray as a multiple of itself if and only if that multiple\nis positive. -/\ntheorem sameRay_smul_right_iff_of_ne {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) :\n    SameRay R v (r • v) ↔ 0 < r := by\n  simp only [sameRay_smul_right_iff, hv, or_false, hr.symm.le_iff_lt]\n\n"}
{"name":"sameRay_smul_left_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\nr : R\n⊢ Iff (SameRay R (HSMul.hSMul r v) v) (Or (LE.le 0 r) (Eq v 0))","decl":"@[simp]\ntheorem sameRay_smul_left_iff {v : M} {r : R} : SameRay R (r • v) v ↔ 0 ≤ r ∨ v = 0 :=\n  SameRay.sameRay_comm.trans sameRay_smul_right_iff\n\n"}
{"name":"sameRay_smul_left_iff_of_ne","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\nhv : Ne v 0\nr : R\nhr : Ne r 0\n⊢ Iff (SameRay R (HSMul.hSMul r v) v) (LT.lt 0 r)","decl":"/-- A multiple of a nonzero vector is in the same ray as that vector if and only if that multiple\nis positive. -/\ntheorem sameRay_smul_left_iff_of_ne {v : M} (hv : v ≠ 0) {r : R} (hr : r ≠ 0) :\n    SameRay R (r • v) v ↔ 0 < r :=\n  SameRay.sameRay_comm.trans (sameRay_smul_right_iff_of_ne hv hr)\n\n"}
{"name":"sameRay_neg_smul_right_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\nr : R\n⊢ Iff (SameRay R (Neg.neg v) (HSMul.hSMul r v)) (Or (LE.le r 0) (Eq v 0))","decl":"@[simp]\ntheorem sameRay_neg_smul_right_iff {v : M} {r : R} : SameRay R (-v) (r • v) ↔ r ≤ 0 ∨ v = 0 := by\n  rw [← sameRay_neg_iff, neg_neg, ← neg_smul, sameRay_smul_right_iff, neg_nonneg]\n\n"}
{"name":"sameRay_neg_smul_right_iff_of_ne","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\nr : R\nhv : Ne v 0\nhr : Ne r 0\n⊢ Iff (SameRay R (Neg.neg v) (HSMul.hSMul r v)) (LT.lt r 0)","decl":"theorem sameRay_neg_smul_right_iff_of_ne {v : M} {r : R} (hv : v ≠ 0) (hr : r ≠ 0) :\n    SameRay R (-v) (r • v) ↔ r < 0 := by\n  simp only [sameRay_neg_smul_right_iff, hv, or_false, hr.le_iff_lt]\n\n"}
{"name":"sameRay_neg_smul_left_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\nr : R\n⊢ Iff (SameRay R (HSMul.hSMul r v) (Neg.neg v)) (Or (LE.le r 0) (Eq v 0))","decl":"@[simp]\ntheorem sameRay_neg_smul_left_iff {v : M} {r : R} : SameRay R (r • v) (-v) ↔ r ≤ 0 ∨ v = 0 :=\n  SameRay.sameRay_comm.trans sameRay_neg_smul_right_iff\n\n"}
{"name":"sameRay_neg_smul_left_iff_of_ne","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\nr : R\nhv : Ne v 0\nhr : Ne r 0\n⊢ Iff (SameRay R (HSMul.hSMul r v) (Neg.neg v)) (LT.lt r 0)","decl":"theorem sameRay_neg_smul_left_iff_of_ne {v : M} {r : R} (hv : v ≠ 0) (hr : r ≠ 0) :\n    SameRay R (r • v) (-v) ↔ r < 0 :=\n  SameRay.sameRay_comm.trans <| sameRay_neg_smul_right_iff_of_ne hv hr\n\n-- Porting note: `(u.1 : R)` was `(u : R)`, CoeHead from R to Rˣ does not seem to work.\n"}
{"name":"units_smul_eq_self_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nu : Units R\nv : Module.Ray R M\n⊢ Iff (Eq (HSMul.hSMul u v) v) (LT.lt 0 ↑u)","decl":"@[simp]\ntheorem units_smul_eq_self_iff {u : Rˣ} {v : Module.Ray R M} : u • v = v ↔ 0 < u.1 := by\n  induction' v using Module.Ray.ind with v hv\n  simp only [smul_rayOfNeZero, ray_eq_iff, Units.smul_def, sameRay_smul_left_iff_of_ne hv u.ne_zero]\n\n"}
{"name":"units_smul_eq_neg_iff","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nu : Units R\nv : Module.Ray R M\n⊢ Iff (Eq (HSMul.hSMul u v) (Neg.neg v)) (LT.lt (↑u) 0)","decl":"@[simp]\ntheorem units_smul_eq_neg_iff {u : Rˣ} {v : Module.Ray R M} : u • v = -v ↔ u.1 < 0 := by\n  rw [← neg_inj, neg_neg, ← Module.Ray.neg_units_smul, units_smul_eq_self_iff, Units.val_neg,\n    neg_pos]\n\n"}
{"name":"sameRay_or_sameRay_neg_iff_not_linearIndependent","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx y : M\n⊢ Iff (Or (SameRay R x y) (SameRay R x (Neg.neg y))) (Not (LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))))","decl":"/-- Two vectors are in the same ray, or the first is in the same ray as the negation of the\nsecond, if and only if they are not linearly independent. -/\ntheorem sameRay_or_sameRay_neg_iff_not_linearIndependent {x y : M} :\n    SameRay R x y ∨ SameRay R x (-y) ↔ ¬LinearIndependent R ![x, y] := by\n  by_cases hx : x = 0; · simpa [hx] using fun h : LinearIndependent R ![0, y] => h.ne_zero 0 rfl\n  by_cases hy : y = 0; · simpa [hy] using fun h : LinearIndependent R ![x, 0] => h.ne_zero 1 rfl\n  simp_rw [Fintype.not_linearIndependent_iff]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rcases h with ((hx0 | hy0 | ⟨r₁, r₂, hr₁, _, h⟩) | (hx0 | hy0 | ⟨r₁, r₂, hr₁, _, h⟩))\n    · exact False.elim (hx hx0)\n    · exact False.elim (hy hy0)\n    · refine ⟨![r₁, -r₂], ?_⟩\n      rw [Fin.sum_univ_two, Fin.exists_fin_two]\n      simp [h, hr₁.ne.symm]\n    · exact False.elim (hx hx0)\n    · exact False.elim (hy (neg_eq_zero.1 hy0))\n    · refine ⟨![r₁, r₂], ?_⟩\n      rw [Fin.sum_univ_two, Fin.exists_fin_two]\n      simp [h, hr₁.ne.symm]\n  · rcases h with ⟨m, hm, hmne⟩\n    rw [Fin.sum_univ_two, add_eq_zero_iff_eq_neg, Matrix.cons_val_zero,\n      Matrix.cons_val_one, Matrix.head_cons] at hm\n    rcases lt_trichotomy (m 0) 0 with (hm0 | hm0 | hm0) <;>\n      rcases lt_trichotomy (m 1) 0 with (hm1 | hm1 | hm1)\n    · refine\n        Or.inr (Or.inr (Or.inr ⟨-m 0, -m 1, Left.neg_pos_iff.2 hm0, Left.neg_pos_iff.2 hm1, ?_⟩))\n      linear_combination (norm := module) -hm\n    · exfalso\n      simp [hm1, hx, hm0.ne] at hm\n    · refine Or.inl (Or.inr (Or.inr ⟨-m 0, m 1, Left.neg_pos_iff.2 hm0, hm1, ?_⟩))\n      linear_combination (norm := module) -hm\n    · exfalso\n      simp [hm0, hy, hm1.ne] at hm\n    · rw [Fin.exists_fin_two] at hmne\n      exact False.elim (not_and_or.2 hmne ⟨hm0, hm1⟩)\n    · exfalso\n      simp [hm0, hy, hm1.ne.symm] at hm\n    · refine Or.inl (Or.inr (Or.inr ⟨m 0, -m 1, hm0, Left.neg_pos_iff.2 hm1, ?_⟩))\n      rwa [neg_smul]\n    · exfalso\n      simp [hm1, hx, hm0.ne.symm] at hm\n    · refine Or.inr (Or.inr (Or.inr ⟨m 0, m 1, hm0, hm1, ?_⟩))\n      rwa [smul_neg]\n\n"}
{"name":"sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝³ : LinearOrderedCommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx y : M\n⊢ Iff (Or (SameRay R x y) (And (Ne x 0) (And (Ne y 0) (SameRay R x (Neg.neg y))))) (Not (LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))))","decl":"/-- Two vectors are in the same ray, or they are nonzero and the first is in the same ray as the\nnegation of the second, if and only if they are not linearly independent. -/\ntheorem sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent {x y : M} :\n    SameRay R x y ∨ x ≠ 0 ∧ y ≠ 0 ∧ SameRay R x (-y) ↔ ¬LinearIndependent R ![x, y] := by\n  rw [← sameRay_or_sameRay_neg_iff_not_linearIndependent]\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0 <;> simp [hx, hy]\n\n"}
{"name":"SameRay.exists_pos_left","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nh : SameRay R x y\nhx : Ne x 0\nhy : Ne y 0\n⊢ Exists fun r => And (LT.lt 0 r) (Eq (HSMul.hSMul r x) y)","decl":"theorem exists_pos_left (h : SameRay R x y) (hx : x ≠ 0) (hy : y ≠ 0) :\n    ∃ r : R, 0 < r ∧ r • x = y :=\n  let ⟨r₁, r₂, hr₁, hr₂, h⟩ := h.exists_pos hx hy\n  ⟨r₂⁻¹ * r₁, mul_pos (inv_pos.2 hr₂) hr₁, by rw [mul_smul, h, inv_smul_smul₀ hr₂.ne']⟩\n\n"}
{"name":"SameRay.exists_pos_right","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nh : SameRay R x y\nhx : Ne x 0\nhy : Ne y 0\n⊢ Exists fun r => And (LT.lt 0 r) (Eq x (HSMul.hSMul r y))","decl":"theorem exists_pos_right (h : SameRay R x y) (hx : x ≠ 0) (hy : y ≠ 0) :\n    ∃ r : R, 0 < r ∧ x = r • y :=\n  (h.symm.exists_pos_left hy hx).imp fun _ => And.imp_right Eq.symm\n\n"}
{"name":"SameRay.exists_nonneg_left","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nh : SameRay R x y\nhx : Ne x 0\n⊢ Exists fun r => And (LE.le 0 r) (Eq (HSMul.hSMul r x) y)","decl":"/-- If a vector `v₂` is on the same ray as a nonzero vector `v₁`, then it is equal to `c • v₁` for\nsome nonnegative `c`. -/\ntheorem exists_nonneg_left (h : SameRay R x y) (hx : x ≠ 0) : ∃ r : R, 0 ≤ r ∧ r • x = y := by\n  obtain rfl | hy := eq_or_ne y 0\n  · exact ⟨0, le_rfl, zero_smul _ _⟩\n  · exact (h.exists_pos_left hx hy).imp fun _ => And.imp_left le_of_lt\n\n"}
{"name":"SameRay.exists_nonneg_right","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nh : SameRay R x y\nhy : Ne y 0\n⊢ Exists fun r => And (LE.le 0 r) (Eq x (HSMul.hSMul r y))","decl":"/-- If a vector `v₁` is on the same ray as a nonzero vector `v₂`, then it is equal to `c • v₂` for\nsome nonnegative `c`. -/\ntheorem exists_nonneg_right (h : SameRay R x y) (hy : y ≠ 0) : ∃ r : R, 0 ≤ r ∧ x = r • y :=\n  (h.symm.exists_nonneg_left hy).imp fun _ => And.imp_right Eq.symm\n\n"}
{"name":"SameRay.exists_eq_smul_add","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nv₁ v₂ : M\nh : SameRay R v₁ v₂\n⊢ Exists fun a => Exists fun b => And (LE.le 0 a) (And (LE.le 0 b) (And (Eq (HAdd.hAdd a b) 1) (And (Eq v₁ (HSMul.hSMul a (HAdd.hAdd v₁ v₂))) (Eq v₂ (HSMul.hSMul b (HAdd.hAdd v₁ v₂))))))","decl":"/-- If vectors `v₁` and `v₂` are on the same ray, then for some nonnegative `a b`, `a + b = 1`, we\nhave `v₁ = a • (v₁ + v₂)` and `v₂ = b • (v₁ + v₂)`. -/\ntheorem exists_eq_smul_add (h : SameRay R v₁ v₂) :\n    ∃ a b : R, 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = a • (v₁ + v₂) ∧ v₂ = b • (v₁ + v₂) := by\n  rcases h with (rfl | rfl | ⟨r₁, r₂, h₁, h₂, H⟩)\n  · use 0, 1\n    simp\n  · use 1, 0\n    simp\n  · have h₁₂ : 0 < r₁ + r₂ := add_pos h₁ h₂\n    refine\n      ⟨r₂ / (r₁ + r₂), r₁ / (r₁ + r₂), div_nonneg h₂.le h₁₂.le, div_nonneg h₁.le h₁₂.le, ?_, ?_, ?_⟩\n    · rw [← add_div, add_comm, div_self h₁₂.ne']\n    · rw [div_eq_inv_mul, mul_smul, smul_add, ← H, ← add_smul, add_comm r₂, inv_smul_smul₀ h₁₂.ne']\n    · rw [div_eq_inv_mul, mul_smul, smul_add, H, ← add_smul, add_comm r₂, inv_smul_smul₀ h₁₂.ne']\n\n"}
{"name":"SameRay.exists_eq_smul","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nv₁ v₂ : M\nh : SameRay R v₁ v₂\n⊢ Exists fun u => Exists fun a => Exists fun b => And (LE.le 0 a) (And (LE.le 0 b) (And (Eq (HAdd.hAdd a b) 1) (And (Eq v₁ (HSMul.hSMul a u)) (Eq v₂ (HSMul.hSMul b u)))))","decl":"/-- If vectors `v₁` and `v₂` are on the same ray, then they are nonnegative multiples of the same\nvector. Actually, this vector can be assumed to be `v₁ + v₂`, see `SameRay.exists_eq_smul_add`. -/\ntheorem exists_eq_smul (h : SameRay R v₁ v₂) :\n    ∃ (u : M) (a b : R), 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = a • u ∧ v₂ = b • u :=\n  ⟨v₁ + v₂, h.exists_eq_smul_add⟩\n\n"}
{"name":"exists_pos_left_iff_sameRay","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nhx : Ne x 0\nhy : Ne y 0\n⊢ Iff (Exists fun r => And (LT.lt 0 r) (Eq (HSMul.hSMul r x) y)) (SameRay R x y)","decl":"theorem exists_pos_left_iff_sameRay (hx : x ≠ 0) (hy : y ≠ 0) :\n    (∃ r : R, 0 < r ∧ r • x = y) ↔ SameRay R x y := by\n  refine ⟨fun h => ?_, fun h => h.exists_pos_left hx hy⟩\n  rcases h with ⟨r, hr, rfl⟩\n  exact SameRay.sameRay_pos_smul_right x hr\n\n"}
{"name":"exists_pos_left_iff_sameRay_and_ne_zero","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nhx : Ne x 0\n⊢ Iff (Exists fun r => And (LT.lt 0 r) (Eq (HSMul.hSMul r x) y)) (And (SameRay R x y) (Ne y 0))","decl":"theorem exists_pos_left_iff_sameRay_and_ne_zero (hx : x ≠ 0) :\n    (∃ r : R, 0 < r ∧ r • x = y) ↔ SameRay R x y ∧ y ≠ 0 := by\n  constructor\n  · rintro ⟨r, hr, rfl⟩\n    simp [hx, hr.le, hr.ne']\n  · rintro ⟨hxy, hy⟩\n    exact (exists_pos_left_iff_sameRay hx hy).2 hxy\n\n"}
{"name":"exists_nonneg_left_iff_sameRay","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nhx : Ne x 0\n⊢ Iff (Exists fun r => And (LE.le 0 r) (Eq (HSMul.hSMul r x) y)) (SameRay R x y)","decl":"theorem exists_nonneg_left_iff_sameRay (hx : x ≠ 0) :\n    (∃ r : R, 0 ≤ r ∧ r • x = y) ↔ SameRay R x y := by\n  refine ⟨fun h => ?_, fun h => h.exists_nonneg_left hx⟩\n  rcases h with ⟨r, hr, rfl⟩\n  exact SameRay.sameRay_nonneg_smul_right x hr\n\n"}
{"name":"exists_pos_right_iff_sameRay","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nhx : Ne x 0\nhy : Ne y 0\n⊢ Iff (Exists fun r => And (LT.lt 0 r) (Eq x (HSMul.hSMul r y))) (SameRay R x y)","decl":"theorem exists_pos_right_iff_sameRay (hx : x ≠ 0) (hy : y ≠ 0) :\n    (∃ r : R, 0 < r ∧ x = r • y) ↔ SameRay R x y := by\n  rw [SameRay.sameRay_comm]\n  simp_rw [eq_comm (a := x)]\n  exact exists_pos_left_iff_sameRay hy hx\n\n"}
{"name":"exists_pos_right_iff_sameRay_and_ne_zero","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nhy : Ne y 0\n⊢ Iff (Exists fun r => And (LT.lt 0 r) (Eq x (HSMul.hSMul r y))) (And (SameRay R x y) (Ne x 0))","decl":"theorem exists_pos_right_iff_sameRay_and_ne_zero (hy : y ≠ 0) :\n    (∃ r : R, 0 < r ∧ x = r • y) ↔ SameRay R x y ∧ x ≠ 0 := by\n  rw [SameRay.sameRay_comm]\n  simp_rw [eq_comm (a := x)]\n  exact exists_pos_left_iff_sameRay_and_ne_zero hy\n\n"}
{"name":"exists_nonneg_right_iff_sameRay","module":"Mathlib.LinearAlgebra.Ray","initialProofState":"R : Type u_1\ninst✝² : LinearOrderedField R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nhy : Ne y 0\n⊢ Iff (Exists fun r => And (LE.le 0 r) (Eq x (HSMul.hSMul r y))) (SameRay R x y)","decl":"theorem exists_nonneg_right_iff_sameRay (hy : y ≠ 0) :\n    (∃ r : R, 0 ≤ r ∧ x = r • y) ↔ SameRay R x y := by\n  rw [SameRay.sameRay_comm]\n  simp_rw [eq_comm (a := x)]\n  exact exists_nonneg_left_iff_sameRay (R := R) hy\n\n"}
