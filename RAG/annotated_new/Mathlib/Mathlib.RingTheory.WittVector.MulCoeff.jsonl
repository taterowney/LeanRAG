{"name":"WittVector.wittPolyProd_vars","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ HasSubset.Subset (WittVector.wittPolyProd p n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittPolyProd_vars (n : ‚Ñï) : (wittPolyProd p n).vars ‚äÜ univ √óÀ¢ range (n + 1) := by\n  rw [wittPolyProd]\n  apply Subset.trans (vars_mul _ _)\n  refine union_subset ?_ ?_ <;>\n  ¬∑ refine Subset.trans (vars_rename _ _) ?_\n    simp [wittPolynomial_vars, image_subset_iff]\n\n"}
{"name":"WittVector.wittPolyProdRemainder_vars","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ HasSubset.Subset (WittVector.wittPolyProdRemainder p n).vars (SProd.sprod Finset.univ (Finset.range n))","decl":"theorem wittPolyProdRemainder_vars (n : ‚Ñï) :\n    (wittPolyProdRemainder p n).vars ‚äÜ univ √óÀ¢ range n := by\n  rw [wittPolyProdRemainder]\n  refine Subset.trans (vars_sum_subset _ _) ?_\n  rw [biUnion_subset]\n  intro x hx\n  apply Subset.trans (vars_mul _ _)\n  refine union_subset ?_ ?_\n  ¬∑ apply Subset.trans (vars_pow _ _)\n    have : (p : ùïÑ) = C (p : ‚Ñ§) := by simp only [Int.cast_natCast, eq_intCast]\n    rw [this, vars_C]\n    apply empty_subset\n  ¬∑ apply Subset.trans (vars_pow _ _)\n    apply Subset.trans (wittMul_vars _ _)\n    apply product_subset_product (Subset.refl _)\n    simp only [mem_range, range_subset] at hx ‚ä¢\n    exact hx\n\n"}
{"name":"WittVector.remainder_vars","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ HasSubset.Subset (WittVector.remainder p n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem remainder_vars (n : ‚Ñï) : (remainder p n).vars ‚äÜ univ √óÀ¢ range (n + 1) := by\n  rw [remainder]\n  apply Subset.trans (vars_mul _ _)\n  refine union_subset ?_ ?_ <;>\n  ¬∑ refine Subset.trans (vars_sum_subset _ _) ?_\n    rw [biUnion_subset]\n    intro x hx\n    rw [rename_monomial, vars_monomial, Finsupp.mapDomain_single]\n    ¬∑ apply Subset.trans Finsupp.support_single_subset\n      simpa using mem_range.mp hx\n    ¬∑ apply pow_ne_zero\n      exact mod_cast hp.out.ne_zero\n\n"}
{"name":"WittVector.mul_polyOfInterest_aux1","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HPow.hPow (‚Üëp) i) (HPow.hPow (WittVector.wittMul p i) (HPow.hPow p (HSub.hSub n i)))) (WittVector.wittPolyProd p n)","decl":"theorem mul_polyOfInterest_aux1 (n : ‚Ñï) :\n    ‚àë i ‚àà range (n + 1), (p : ùïÑ) ^ i * wittMul p i ^ p ^ (n - i) = wittPolyProd p n := by\n  simp only [wittPolyProd]\n  convert wittStructureInt_prop p (X (0 : Fin 2) * X 1) n using 1\n  ¬∑ simp only [wittPolynomial, wittMul]\n    rw [map_sum]\n    congr 1 with i\n    congr 1\n    have hsupp : (Finsupp.single i (p ^ (n - i))).support = {i} := by\n      rw [Finsupp.support_eq_singleton]\n      simp only [and_true, Finsupp.single_eq_same, eq_self_iff_true, Ne]\n      exact pow_ne_zero _ hp.out.ne_zero\n    simp only [bind‚ÇÅ_monomial, hsupp, Int.cast_natCast, prod_singleton, eq_intCast,\n      Finsupp.single_eq_same, C_pow, mul_eq_mul_left_iff, eq_self_iff_true, Int.cast_pow]\n  ¬∑ simp only [map_mul, bind‚ÇÅ_X_right]\n\n"}
{"name":"WittVector.mul_polyOfInterest_aux2","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (HAdd.hAdd (HMul.hMul (HPow.hPow (‚Üëp) n) (WittVector.wittMul p n)) (WittVector.wittPolyProdRemainder p n)) (WittVector.wittPolyProd p n)","decl":"theorem mul_polyOfInterest_aux2 (n : ‚Ñï) :\n    (p : ùïÑ) ^ n * wittMul p n + wittPolyProdRemainder p n = wittPolyProd p n := by\n  convert mul_polyOfInterest_aux1 p n\n  rw [sum_range_succ, add_comm, Nat.sub_self, pow_zero, pow_one]\n  rfl\n\n-- We redeclare `p` here to locally discard the unneeded `p.Prime` hypothesis.\n"}
{"name":"WittVector.mul_polyOfInterest_aux3","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p n : Nat\n‚ä¢ Eq (WittVector.wittPolyProd p (HAdd.hAdd n 1)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Neg.neg (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (MvPolynomial.X { fst := 0, snd := HAdd.hAdd n 1 }))) (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (MvPolynomial.X { fst := 1, snd := HAdd.hAdd n 1 }))) (HMul.hMul (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (MvPolynomial.X { fst := 0, snd := HAdd.hAdd n 1 })) ((MvPolynomial.rename (Prod.mk 1)) (wittPolynomial p Int (HAdd.hAdd n 1))))) (HMul.hMul (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (MvPolynomial.X { fst := 1, snd := HAdd.hAdd n 1 })) ((MvPolynomial.rename (Prod.mk 0)) (wittPolynomial p Int (HAdd.hAdd n 1))))) (WittVector.remainder p n))","decl":"theorem mul_polyOfInterest_aux3 (p n : ‚Ñï) : wittPolyProd p (n + 1) =\n    -((p : ùïÑ) ^ (n + 1) * X (0, n + 1)) * ((p : ùïÑ) ^ (n + 1) * X (1, n + 1)) +\n    (p : ùïÑ) ^ (n + 1) * X (0, n + 1) * rename (Prod.mk (1 : Fin 2)) (wittPolynomial p ‚Ñ§ (n + 1)) +\n    (p : ùïÑ) ^ (n + 1) * X (1, n + 1) * rename (Prod.mk (0 : Fin 2)) (wittPolynomial p ‚Ñ§ (n + 1)) +\n    remainder p n := by\n  -- a useful auxiliary fact\n  have mvpz : (p : ùïÑ) ^ (n + 1) = MvPolynomial.C ((p : ‚Ñ§) ^ (n + 1)) := by norm_cast\n  -- Porting note: the original proof applies `sum_range_succ` through a non-`conv` rewrite,\n  -- but this does not work in Lean 4; the whole proof also times out very badly. The proof has been\n  -- nearly totally rewritten here and now finishes quite fast.\n  rw [wittPolyProd, wittPolynomial, map_sum, map_sum]\n  conv_lhs =>\n    arg 1\n    rw [sum_range_succ, ‚Üê C_mul_X_pow_eq_monomial, tsub_self, pow_zero, pow_one, map_mul,\n      rename_C, rename_X, ‚Üê mvpz]\n  conv_lhs =>\n    arg 2\n    rw [sum_range_succ, ‚Üê C_mul_X_pow_eq_monomial, tsub_self, pow_zero, pow_one, map_mul,\n      rename_C, rename_X, ‚Üê mvpz]\n  conv_rhs =>\n    enter [1, 1, 2, 2]\n    rw [sum_range_succ, ‚Üê C_mul_X_pow_eq_monomial, tsub_self, pow_zero, pow_one, map_mul,\n      rename_C, rename_X, ‚Üê mvpz]\n  conv_rhs =>\n    enter [1, 2, 2]\n    rw [sum_range_succ, ‚Üê C_mul_X_pow_eq_monomial, tsub_self, pow_zero, pow_one, map_mul,\n      rename_C, rename_X, ‚Üê mvpz]\n  simp only [add_mul, mul_add]\n  rw [add_comm _ (remainder p n)]\n  simp only [add_assoc]\n  apply congrArg (Add.add _)\n  ring\n\n"}
{"name":"WittVector.mul_polyOfInterest_aux4","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (WittVector.wittMul p (HAdd.hAdd n 1))) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Neg.neg (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (MvPolynomial.X { fst := 0, snd := HAdd.hAdd n 1 }))) (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (MvPolynomial.X { fst := 1, snd := HAdd.hAdd n 1 }))) (HMul.hMul (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (MvPolynomial.X { fst := 0, snd := HAdd.hAdd n 1 })) ((MvPolynomial.rename (Prod.mk 1)) (wittPolynomial p Int (HAdd.hAdd n 1))))) (HMul.hMul (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (MvPolynomial.X { fst := 1, snd := HAdd.hAdd n 1 })) ((MvPolynomial.rename (Prod.mk 0)) (wittPolynomial p Int (HAdd.hAdd n 1))))) (HSub.hSub (WittVector.remainder p n) (WittVector.wittPolyProdRemainder p (HAdd.hAdd n 1))))","decl":"theorem mul_polyOfInterest_aux4 (n : ‚Ñï) :\n    (p : ùïÑ) ^ (n + 1) * wittMul p (n + 1) =\n    -((p : ùïÑ) ^ (n + 1) * X (0, n + 1)) * ((p : ùïÑ) ^ (n + 1) * X (1, n + 1)) +\n    (p : ùïÑ) ^ (n + 1) * X (0, n + 1) * rename (Prod.mk (1 : Fin 2)) (wittPolynomial p ‚Ñ§ (n + 1)) +\n    (p : ùïÑ) ^ (n + 1) * X (1, n + 1) * rename (Prod.mk (0 : Fin 2)) (wittPolynomial p ‚Ñ§ (n + 1)) +\n    (remainder p n - wittPolyProdRemainder p (n + 1)) := by\n  rw [‚Üê add_sub_assoc, eq_sub_iff_add_eq, mul_polyOfInterest_aux2]\n  exact mul_polyOfInterest_aux3 _ _\n\n"}
{"name":"WittVector.mul_polyOfInterest_aux5","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (WittVector.polyOfInterest p n)) (HSub.hSub (WittVector.remainder p n) (WittVector.wittPolyProdRemainder p (HAdd.hAdd n 1)))","decl":"theorem mul_polyOfInterest_aux5 (n : ‚Ñï) :\n    (p : ùïÑ) ^ (n + 1) * polyOfInterest p n = remainder p n - wittPolyProdRemainder p (n + 1) := by\n  simp only [polyOfInterest, mul_sub, mul_add, sub_eq_iff_eq_add']\n  rw [mul_polyOfInterest_aux4 p n]\n  ring\n\n"}
{"name":"WittVector.mul_polyOfInterest_vars","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ HasSubset.Subset (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (WittVector.polyOfInterest p n)).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem mul_polyOfInterest_vars (n : ‚Ñï) :\n    ((p : ùïÑ) ^ (n + 1) * polyOfInterest p n).vars ‚äÜ univ √óÀ¢ range (n + 1) := by\n  rw [mul_polyOfInterest_aux5]\n  apply Subset.trans (vars_sub_subset _)\n  refine union_subset ?_ ?_\n  ¬∑ apply remainder_vars\n  ¬∑ apply wittPolyProdRemainder_vars\n\n"}
{"name":"WittVector.polyOfInterest_vars_eq","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (WittVector.polyOfInterest p n).vars (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (HSub.hSub (HSub.hSub (HAdd.hAdd (WittVector.wittMul p (HAdd.hAdd n 1)) (HMul.hMul (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (MvPolynomial.X { fst := 0, snd := HAdd.hAdd n 1 })) (MvPolynomial.X { fst := 1, snd := HAdd.hAdd n 1 }))) (HMul.hMul (MvPolynomial.X { fst := 0, snd := HAdd.hAdd n 1 }) ((MvPolynomial.rename (Prod.mk 1)) (wittPolynomial p Int (HAdd.hAdd n 1))))) (HMul.hMul (MvPolynomial.X { fst := 1, snd := HAdd.hAdd n 1 }) ((MvPolynomial.rename (Prod.mk 0)) (wittPolynomial p Int (HAdd.hAdd n 1)))))).vars","decl":"theorem polyOfInterest_vars_eq (n : ‚Ñï) : (polyOfInterest p n).vars =\n    ((p : ùïÑ) ^ (n + 1) * (wittMul p (n + 1) + (p : ùïÑ) ^ (n + 1) * X (0, n + 1) * X (1, n + 1) -\n      X (0, n + 1) * rename (Prod.mk (1 : Fin 2)) (wittPolynomial p ‚Ñ§ (n + 1)) -\n      X (1, n + 1) * rename (Prod.mk (0 : Fin 2)) (wittPolynomial p ‚Ñ§ (n + 1)))).vars := by\n  have : (p : ùïÑ) ^ (n + 1) = C ((p : ‚Ñ§) ^ (n + 1)) := by norm_cast\n  rw [polyOfInterest, this, vars_C_mul]\n  apply pow_ne_zero\n  exact mod_cast hp.out.ne_zero\n\n"}
{"name":"WittVector.polyOfInterest_vars","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ HasSubset.Subset (WittVector.polyOfInterest p n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem polyOfInterest_vars (n : ‚Ñï) : (polyOfInterest p n).vars ‚äÜ univ √óÀ¢ range (n + 1) := by\n  rw [polyOfInterest_vars_eq]; apply mul_polyOfInterest_vars\n\n"}
{"name":"WittVector.peval_polyOfInterest","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù : CommRing k\nn : Nat\nx y : WittVector p k\n‚ä¢ Eq (WittVector.peval (WittVector.polyOfInterest p n) (Matrix.vecCons (fun i => x.coeff i) (Matrix.vecCons (fun i => y.coeff i) Matrix.vecEmpty))) (HSub.hSub (HSub.hSub (HAdd.hAdd ((HMul.hMul x y).coeff (HAdd.hAdd n 1)) (HMul.hMul (HMul.hMul (HPow.hPow (‚Üëp) (HAdd.hAdd n 1)) (x.coeff (HAdd.hAdd n 1))) (y.coeff (HAdd.hAdd n 1)))) (HMul.hMul (y.coeff (HAdd.hAdd n 1)) ((Finset.range (HAdd.hAdd (HAdd.hAdd n 1) 1)).sum fun i => HMul.hMul (HPow.hPow (‚Üëp) i) (HPow.hPow (x.coeff i) (HPow.hPow p (HSub.hSub (HAdd.hAdd n 1) i)))))) (HMul.hMul (x.coeff (HAdd.hAdd n 1)) ((Finset.range (HAdd.hAdd (HAdd.hAdd n 1) 1)).sum fun i => HMul.hMul (HPow.hPow (‚Üëp) i) (HPow.hPow (y.coeff i) (HPow.hPow p (HSub.hSub (HAdd.hAdd n 1) i))))))","decl":"theorem peval_polyOfInterest (n : ‚Ñï) (x y : ùïé k) :\n    peval (polyOfInterest p n) ![fun i => x.coeff i, fun i => y.coeff i] =\n    (x * y).coeff (n + 1) + p ^ (n + 1) * x.coeff (n + 1) * y.coeff (n + 1) -\n      y.coeff (n + 1) * ‚àë i ‚àà range (n + 1 + 1), p ^ i * x.coeff i ^ p ^ (n + 1 - i) -\n      x.coeff (n + 1) * ‚àë i ‚àà range (n + 1 + 1), p ^ i * y.coeff i ^ p ^ (n + 1 - i) := by\n  simp only [polyOfInterest, peval, map_natCast, Matrix.head_cons, map_pow,\n    Function.uncurry_apply_pair, aeval_X, Matrix.cons_val_one, map_mul, Matrix.cons_val_zero,\n    map_sub]\n  rw [sub_sub, add_comm (_ * _), ‚Üê sub_sub]\n  simp [wittPolynomial_eq_sum_C_mul_X_pow, aeval, eval‚ÇÇ_rename, mul_coeff, peval, map_natCast,\n    map_add, map_pow, map_mul]\n\n"}
{"name":"WittVector.peval_polyOfInterest'","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬π : CommRing k\ninst‚úù : CharP k p\nn : Nat\nx y : WittVector p k\n‚ä¢ Eq (WittVector.peval (WittVector.polyOfInterest p n) (Matrix.vecCons (fun i => x.coeff i) (Matrix.vecCons (fun i => y.coeff i) Matrix.vecEmpty))) (HSub.hSub (HSub.hSub ((HMul.hMul x y).coeff (HAdd.hAdd n 1)) (HMul.hMul (y.coeff (HAdd.hAdd n 1)) (HPow.hPow (x.coeff 0) (HPow.hPow p (HAdd.hAdd n 1))))) (HMul.hMul (x.coeff (HAdd.hAdd n 1)) (HPow.hPow (y.coeff 0) (HPow.hPow p (HAdd.hAdd n 1)))))","decl":"/-- The characteristic `p` version of `peval_polyOfInterest` -/\ntheorem peval_polyOfInterest' (n : ‚Ñï) (x y : ùïé k) :\n    peval (polyOfInterest p n) ![fun i => x.coeff i, fun i => y.coeff i] =\n      (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) -\n        x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) := by\n  rw [peval_polyOfInterest]\n  have : (p : k) = 0 := CharP.cast_eq_zero k p\n  simp only [this, Nat.cast_pow, ne_eq, add_eq_zero, and_false, zero_pow, zero_mul, add_zero,\n    not_false_eq_true, reduceCtorEq]\n  have sum_zero_pow_mul_pow_p (y : ùïé k) : ‚àë x ‚àà range (n + 1 + 1),\n      (0 : k) ^ x * y.coeff x ^ p ^ (n + 1 - x) = y.coeff 0 ^ p ^ (n + 1) := by\n    rw [Finset.sum_eq_single_of_mem 0] <;> simp +contextual\n  congr <;> apply sum_zero_pow_mul_pow_p\n\n"}
{"name":"WittVector.nth_mul_coeff'","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬π : CommRing k\ninst‚úù : CharP k p\nn : Nat\n‚ä¢ Exists fun f => ‚àÄ (x y : WittVector p k), Eq (f (WittVector.truncateFun (HAdd.hAdd n 1) x) (WittVector.truncateFun (HAdd.hAdd n 1) y)) (HSub.hSub (HSub.hSub ((HMul.hMul x y).coeff (HAdd.hAdd n 1)) (HMul.hMul (y.coeff (HAdd.hAdd n 1)) (HPow.hPow (x.coeff 0) (HPow.hPow p (HAdd.hAdd n 1))))) (HMul.hMul (x.coeff (HAdd.hAdd n 1)) (HPow.hPow (y.coeff 0) (HPow.hPow p (HAdd.hAdd n 1)))))","decl":"theorem nth_mul_coeff' (n : ‚Ñï) :\n    ‚àÉ f : TruncatedWittVector p (n + 1) k ‚Üí TruncatedWittVector p (n + 1) k ‚Üí k,\n    ‚àÄ x y : ùïé k, f (truncateFun (n + 1) x) (truncateFun (n + 1) y) =\n      (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) -\n        x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) := by\n  simp only [‚Üê peval_polyOfInterest']\n  obtain ‚ü®f‚ÇÄ, hf‚ÇÄ‚ü© := exists_restrict_to_vars k (polyOfInterest_vars p n)\n  have : ‚àÄ (a : Multiset (Fin 2)) (b : Multiset ‚Ñï), a √óÀ¢ b = a.product b := fun a b => rfl\n  let f : TruncatedWittVector p (n + 1) k ‚Üí TruncatedWittVector p (n + 1) k ‚Üí k := by\n    intro x y\n    apply f‚ÇÄ\n    rintro ‚ü®a, ha‚ü©\n    apply Function.uncurry ![x, y]\n    simp_rw [product_val, this, range_val, Multiset.range_succ] at ha\n    let S : Set (Fin 2 √ó ‚Ñï) := (fun a => a.2 = n ‚à® a.2 < n)\n    have ha' : a ‚àà S := by\n      convert ha\n      dsimp [S]\n      congr!\n      simp\n    refine ‚ü®a.fst, ‚ü®a.snd, ?_‚ü©‚ü©\n    cases' ha' with ha ha <;> omega\n  use f\n  intro x y\n  dsimp [f, peval]\n  rw [‚Üê hf‚ÇÄ]\n  congr\n  ext a\n  cases' a with a ha\n  cases' a with i m\n  fin_cases i <;> rfl -- surely this case split is not necessary\n\n"}
{"name":"WittVector.nth_mul_coeff","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬π : CommRing k\ninst‚úù : CharP k p\nn : Nat\n‚ä¢ Exists fun f => ‚àÄ (x y : WittVector p k), Eq ((HMul.hMul x y).coeff (HAdd.hAdd n 1)) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (x.coeff (HAdd.hAdd n 1)) (HPow.hPow (y.coeff 0) (HPow.hPow p (HAdd.hAdd n 1)))) (HMul.hMul (y.coeff (HAdd.hAdd n 1)) (HPow.hPow (x.coeff 0) (HPow.hPow p (HAdd.hAdd n 1))))) (f (WittVector.truncateFun (HAdd.hAdd n 1) x) (WittVector.truncateFun (HAdd.hAdd n 1) y)))","decl":"theorem nth_mul_coeff (n : ‚Ñï) :\n    ‚àÉ f : TruncatedWittVector p (n + 1) k ‚Üí TruncatedWittVector p (n + 1) k ‚Üí k,\n    ‚àÄ x y : ùïé k, (x * y).coeff (n + 1) =\n      x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) + y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) +\n      f (truncateFun (n + 1) x) (truncateFun (n + 1) y) := by\n  obtain ‚ü®f, hf‚ü© := nth_mul_coeff' p k n\n  use f\n  intro x y\n  rw [hf x y]\n  ring\n\n"}
{"name":"WittVector.nthRemainder_spec","module":"Mathlib.RingTheory.WittVector.MulCoeff","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst‚úù¬π : CommRing k\ninst‚úù : CharP k p\nn : Nat\nx y : WittVector p k\n‚ä¢ Eq ((HMul.hMul x y).coeff (HAdd.hAdd n 1)) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (x.coeff (HAdd.hAdd n 1)) (HPow.hPow (y.coeff 0) (HPow.hPow p (HAdd.hAdd n 1)))) (HMul.hMul (y.coeff (HAdd.hAdd n 1)) (HPow.hPow (x.coeff 0) (HPow.hPow p (HAdd.hAdd n 1))))) (WittVector.nthRemainder p n (WittVector.truncateFun (HAdd.hAdd n 1) x) (WittVector.truncateFun (HAdd.hAdd n 1) y)))","decl":"theorem nthRemainder_spec (n : ‚Ñï) (x y : ùïé k) : (x * y).coeff (n + 1) =\n    x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) + y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) +\n    nthRemainder p n (truncateFun (n + 1) x) (truncateFun (n + 1) y) :=\n  Classical.choose_spec (nth_mul_coeff p k n) _ _\n\n"}
