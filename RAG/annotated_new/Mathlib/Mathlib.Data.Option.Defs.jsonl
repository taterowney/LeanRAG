{"name":"Option.elim'_none","module":"Mathlib.Data.Option.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\nf : α → β\n⊢ Eq (Option.elim' b f Option.none) b","decl":"@[simp]\ntheorem elim'_none (b : β) (f : α → β) : Option.elim' b f none = b := rfl\n"}
{"name":"Option.elim'_some","module":"Mathlib.Data.Option.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nb : β\nf : α → β\n⊢ Eq (Option.elim' b f (Option.some a)) (f a)","decl":"@[simp]\ntheorem elim'_some {a : α} (b : β) (f : α → β) : Option.elim' b f (some a) = f a := rfl\n\n-- Porting note: this lemma was introduced because it is necessary\n-- in `CategoryTheory.Category.PartialFun`\n"}
{"name":"Option.elim'_eq_elim","module":"Mathlib.Data.Option.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nb : β\nf : α → β\na : Option α\n⊢ Eq (Option.elim' b f a) (a.elim b f)","decl":"lemma elim'_eq_elim {α β : Type*} (b : β) (f : α → β) (a : Option α) :\n    Option.elim' b f a = Option.elim a b f := by\n  cases a <;> rfl\n\n\n"}
{"name":"Option.mem_some_iff","module":"Mathlib.Data.Option.Defs","initialProofState":"α : Type u_3\na b : α\n⊢ Iff (Membership.mem (Option.some b) a) (Eq b a)","decl":"theorem mem_some_iff {α : Type*} {a b : α} : a ∈ some b ↔ b = a := by simp\n\n"}
{"name":"Option.iget_some","module":"Mathlib.Data.Option.Defs","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\na : α\n⊢ Eq (Option.some a).iget a","decl":"theorem iget_some [Inhabited α] {a : α} : (some a).iget = a :=\n  rfl\n\n"}
{"name":"Option.liftOrGet_isCommutative","module":"Mathlib.Data.Option.Defs","initialProofState":"α : Type u_1\nf : α → α → α\ninst✝ : Std.Commutative f\n⊢ Std.Commutative (Option.liftOrGet f)","decl":"instance liftOrGet_isCommutative (f : α → α → α) [Std.Commutative f] :\n    Std.Commutative (liftOrGet f) :=\n  ⟨fun a b ↦ by cases a <;> cases b <;> simp [liftOrGet, Std.Commutative.comm]⟩\n\n"}
{"name":"Option.liftOrGet_isAssociative","module":"Mathlib.Data.Option.Defs","initialProofState":"α : Type u_1\nf : α → α → α\ninst✝ : Std.Associative f\n⊢ Std.Associative (Option.liftOrGet f)","decl":"instance liftOrGet_isAssociative (f : α → α → α) [Std.Associative f] :\n    Std.Associative (liftOrGet f) :=\n  ⟨fun a b c ↦ by cases a <;> cases b <;> cases c <;> simp [liftOrGet, Std.Associative.assoc]⟩\n\n"}
{"name":"Option.liftOrGet_isIdempotent","module":"Mathlib.Data.Option.Defs","initialProofState":"α : Type u_1\nf : α → α → α\ninst✝ : Std.IdempotentOp f\n⊢ Std.IdempotentOp (Option.liftOrGet f)","decl":"instance liftOrGet_isIdempotent (f : α → α → α) [Std.IdempotentOp f] :\n    Std.IdempotentOp (liftOrGet f) :=\n  ⟨fun a ↦ by cases a <;> simp [liftOrGet, Std.IdempotentOp.idempotent]⟩\n\n"}
{"name":"Option.liftOrGet_isId","module":"Mathlib.Data.Option.Defs","initialProofState":"α : Type u_1\nf : α → α → α\n⊢ Std.LawfulIdentity (Option.liftOrGet f) Option.none","decl":"instance liftOrGet_isId (f : α → α → α) : Std.LawfulIdentity (liftOrGet f) none where\n  left_id a := by cases a <;> simp [liftOrGet]\n  right_id a := by cases a <;> simp [liftOrGet]\n\n"}
