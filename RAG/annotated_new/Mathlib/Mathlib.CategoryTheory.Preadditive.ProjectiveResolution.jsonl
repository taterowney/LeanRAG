{"name":"CategoryTheory.ProjectiveResolution.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ninst✝ : SizeOf C\ncomplex : ChainComplex C Nat\nprojective : autoParam (∀ (n : Nat), CategoryTheory.Projective (complex.X n)) _auto✝\nhasHomology : ∀ (i : Nat), HomologicalComplex.HasHomology complex i\nπ : Quiver.Hom complex ((ChainComplex.single₀ C).obj Z)\nquasiIso : autoParam (QuasiIso π) _auto✝\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.ProjectiveResolution.mk complex projective π quasiIso)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf complex)) (SizeOf.sizeOf π)) (SizeOf.sizeOf quasiIso))","decl":"/--\nA `ProjectiveResolution Z` consists of a bundled `ℕ`-indexed chain complex of projective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure ProjectiveResolution (Z : C) where\n  /-- the chain complex involved in the resolution -/\n  complex : ChainComplex C ℕ\n  /-- the chain complex must be degreewise projective -/\n  projective : ∀ n, Projective (complex.X n) := by infer_instance\n  /-- the chain complex must have homology -/\n  [hasHomology : ∀ i, complex.HasHomology i]\n  /-- the morphism to the single chain complex with `Z` in degree `0` -/\n  π : complex ⟶ (ChainComplex.single₀ C).obj Z\n  /-- the morphism to the single chain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso π := by infer_instance\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.hasHomology","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.ProjectiveResolution Z\ni : Nat\n⊢ HomologicalComplex.HasHomology self.complex i","decl":"/--\nA `ProjectiveResolution Z` consists of a bundled `ℕ`-indexed chain complex of projective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure ProjectiveResolution (Z : C) where\n  /-- the chain complex involved in the resolution -/\n  complex : ChainComplex C ℕ\n  /-- the chain complex must be degreewise projective -/\n  projective : ∀ n, Projective (complex.X n) := by infer_instance\n  /-- the chain complex must have homology -/\n  [hasHomology : ∀ i, complex.HasHomology i]\n  /-- the morphism to the single chain complex with `Z` in degree `0` -/\n  π : complex ⟶ (ChainComplex.single₀ C).obj Z\n  /-- the morphism to the single chain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso π := by infer_instance\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.mk.inj","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ncomplex✝ : ChainComplex C Nat\nprojective✝ : autoParam (∀ (n : Nat), CategoryTheory.Projective (complex✝.X n)) _auto✝\nhasHomology✝ : ∀ (i : Nat), HomologicalComplex.HasHomology complex✝ i\nπ✝ : Quiver.Hom complex✝ ((ChainComplex.single₀ C).obj Z)\nquasiIso✝ : autoParam (QuasiIso π✝) _auto✝\ncomplex : ChainComplex C Nat\nprojective : autoParam (∀ (n : Nat), CategoryTheory.Projective (complex.X n)) _auto✝\nhasHomology : ∀ (i : Nat), HomologicalComplex.HasHomology complex i\nπ : Quiver.Hom complex ((ChainComplex.single₀ C).obj Z)\nquasiIso : autoParam (QuasiIso π) _auto✝\nx✝ : Eq (CategoryTheory.ProjectiveResolution.mk complex✝ projective✝ π✝ quasiIso✝) (CategoryTheory.ProjectiveResolution.mk complex projective π quasiIso)\n⊢ And (Eq complex✝ complex) (HEq π✝ π)","decl":"/--\nA `ProjectiveResolution Z` consists of a bundled `ℕ`-indexed chain complex of projective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure ProjectiveResolution (Z : C) where\n  /-- the chain complex involved in the resolution -/\n  complex : ChainComplex C ℕ\n  /-- the chain complex must be degreewise projective -/\n  projective : ∀ n, Projective (complex.X n) := by infer_instance\n  /-- the chain complex must have homology -/\n  [hasHomology : ∀ i, complex.HasHomology i]\n  /-- the morphism to the single chain complex with `Z` in degree `0` -/\n  π : complex ⟶ (ChainComplex.single₀ C).obj Z\n  /-- the morphism to the single chain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso π := by infer_instance\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.projective","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.ProjectiveResolution Z\nn : Nat\n⊢ CategoryTheory.Projective (self.complex.X n)","decl":"/--\nA `ProjectiveResolution Z` consists of a bundled `ℕ`-indexed chain complex of projective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure ProjectiveResolution (Z : C) where\n  /-- the chain complex involved in the resolution -/\n  complex : ChainComplex C ℕ\n  /-- the chain complex must be degreewise projective -/\n  projective : ∀ n, Projective (complex.X n) := by infer_instance\n  /-- the chain complex must have homology -/\n  [hasHomology : ∀ i, complex.HasHomology i]\n  /-- the morphism to the single chain complex with `Z` in degree `0` -/\n  π : complex ⟶ (ChainComplex.single₀ C).obj Z\n  /-- the morphism to the single chain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso π := by infer_instance\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.mk.injEq","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ncomplex✝ : ChainComplex C Nat\nprojective✝ : autoParam (∀ (n : Nat), CategoryTheory.Projective (complex✝.X n)) _auto✝\nhasHomology✝ : ∀ (i : Nat), HomologicalComplex.HasHomology complex✝ i\nπ✝ : Quiver.Hom complex✝ ((ChainComplex.single₀ C).obj Z)\nquasiIso✝ : autoParam (QuasiIso π✝) _auto✝\ncomplex : ChainComplex C Nat\nprojective : autoParam (∀ (n : Nat), CategoryTheory.Projective (complex.X n)) _auto✝\nhasHomology : ∀ (i : Nat), HomologicalComplex.HasHomology complex i\nπ : Quiver.Hom complex ((ChainComplex.single₀ C).obj Z)\nquasiIso : autoParam (QuasiIso π) _auto✝\n⊢ Eq (Eq (CategoryTheory.ProjectiveResolution.mk complex✝ projective✝ π✝ quasiIso✝) (CategoryTheory.ProjectiveResolution.mk complex projective π quasiIso)) (And (Eq complex✝ complex) (HEq π✝ π))","decl":"/--\nA `ProjectiveResolution Z` consists of a bundled `ℕ`-indexed chain complex of projective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure ProjectiveResolution (Z : C) where\n  /-- the chain complex involved in the resolution -/\n  complex : ChainComplex C ℕ\n  /-- the chain complex must be degreewise projective -/\n  projective : ∀ n, Projective (complex.X n) := by infer_instance\n  /-- the chain complex must have homology -/\n  [hasHomology : ∀ i, complex.HasHomology i]\n  /-- the morphism to the single chain complex with `Z` in degree `0` -/\n  π : complex ⟶ (ChainComplex.single₀ C).obj Z\n  /-- the morphism to the single chain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso π := by infer_instance\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.quasiIso","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.ProjectiveResolution Z\n⊢ QuasiIso self.π","decl":"/--\nA `ProjectiveResolution Z` consists of a bundled `ℕ`-indexed chain complex of projective objects,\nalong with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.\n-/\nstructure ProjectiveResolution (Z : C) where\n  /-- the chain complex involved in the resolution -/\n  complex : ChainComplex C ℕ\n  /-- the chain complex must be degreewise projective -/\n  projective : ∀ n, Projective (complex.X n) := by infer_instance\n  /-- the chain complex must have homology -/\n  [hasHomology : ∀ i, complex.HasHomology i]\n  /-- the morphism to the single chain complex with `Z` in degree `0` -/\n  π : complex ⟶ (ChainComplex.single₀ C).obj Z\n  /-- the morphism to the single chain complex with `Z` in degree `0` is a quasi-isomorphism -/\n  quasiIso : QuasiIso π := by infer_instance\n\n"}
{"name":"CategoryTheory.HasProjectiveResolution.out","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nself : CategoryTheory.HasProjectiveResolution Z\n⊢ Nonempty (CategoryTheory.ProjectiveResolution Z)","decl":"/-- An object admits a projective resolution.\n-/\nclass HasProjectiveResolution (Z : C) : Prop where\n  out : Nonempty (ProjectiveResolution Z)\n\n"}
{"name":"CategoryTheory.HasProjectiveResolutions.out","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.HasProjectiveResolutions C\nZ : C\n⊢ CategoryTheory.HasProjectiveResolution Z","decl":"/-- You will rarely use this typeclass directly: it is implied by the combination\n`[EnoughProjectives C]` and `[Abelian C]`.\nBy itself it's enough to set up the basic theory of derived functors.\n-/\nclass HasProjectiveResolutions : Prop where\n  out : ∀ Z : C, HasProjectiveResolution Z\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.complex_exactAt_succ","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nP : CategoryTheory.ProjectiveResolution Z\nn : Nat\n⊢ HomologicalComplex.ExactAt P.complex (HAdd.hAdd n 1)","decl":"lemma complex_exactAt_succ (n : ℕ) :\n    P.complex.ExactAt (n + 1) := by\n  rw [← quasiIsoAt_iff_exactAt' P.π (n + 1) (exactAt_succ_single_obj _ _)]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.exact_succ","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nP : CategoryTheory.ProjectiveResolution Z\nn : Nat\n⊢ (CategoryTheory.ShortComplex.mk (P.complex.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) (P.complex.d (HAdd.hAdd n 1) n) ⋯).Exact","decl":"lemma exact_succ (n : ℕ) :\n    (ShortComplex.mk _ _ (P.complex.d_comp_d (n + 2) (n + 1) n)).Exact :=\n  ((HomologicalComplex.exactAt_iff' _ (n + 2) (n + 1) n) (by simp only [prev]; rfl)\n    (by simp)).1 (P.complex_exactAt_succ n)\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.π_f_succ","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nP : CategoryTheory.ProjectiveResolution Z\nn : Nat\n⊢ Eq (P.π.f (HAdd.hAdd n 1)) 0","decl":"@[simp]\ntheorem π_f_succ (n : ℕ) : P.π.f (n + 1) = 0 :=\n  (isZero_single_obj_X _ _ _ _ (by simp)).eq_of_tgt _ _\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.complex_d_comp_π_f_zero","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nP : CategoryTheory.ProjectiveResolution Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.complex.d 1 0) (P.π.f 0)) 0","decl":"@[reassoc (attr := simp)]\ntheorem complex_d_comp_π_f_zero :\n    P.complex.d 1 0 ≫ P.π.f 0 = 0 := by\n  rw [← P.π.comm 1 0, single_obj_d, comp_zero]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.complex_d_comp_π_f_zero_assoc","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ✝ : C\nP : CategoryTheory.ProjectiveResolution Z✝\nZ : C\nh : Quiver.Hom (((ChainComplex.single₀ C).obj Z✝).X 0) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.complex.d 1 0) (CategoryTheory.CategoryStruct.comp (P.π.f 0) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem complex_d_comp_π_f_zero :\n    P.complex.d 1 0 ≫ P.π.f 0 = 0 := by\n  rw [← P.π.comm 1 0, single_obj_d, comp_zero]\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.complex_d_succ_comp","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nP : CategoryTheory.ProjectiveResolution Z\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.complex.d n (HAdd.hAdd n 1)) (P.complex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))) 0","decl":"theorem complex_d_succ_comp (n : ℕ) :\n    P.complex.d n (n + 1) ≫ P.complex.d (n + 1) (n + 2) = 0 := by\n  simp\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.instEpiFNatπ","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\nP : CategoryTheory.ProjectiveResolution Z\nn : Nat\n⊢ CategoryTheory.Epi (P.π.f n)","decl":"instance (n : ℕ) : Epi (P.π.f n) := by\n  cases n\n  · exact epi_of_isColimit_cofork P.isColimitCokernelCofork\n  · rw [π_f_succ]; infer_instance\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.self_complex","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ninst✝ : CategoryTheory.Projective Z\n⊢ Eq (CategoryTheory.ProjectiveResolution.self Z).complex ((ChainComplex.single₀ C).obj Z)","decl":"/-- A projective object admits a trivial projective resolution: itself in degree 0. -/\n@[simps]\nnoncomputable def self [Projective Z] : ProjectiveResolution Z where\n  complex := (ChainComplex.single₀ C).obj Z\n  π := 𝟙 ((ChainComplex.single₀ C).obj Z)\n  projective n := by\n    cases n\n    · simpa\n    · apply IsZero.projective\n      apply HomologicalComplex.isZero_single_obj_X\n      simp\n\n"}
{"name":"CategoryTheory.ProjectiveResolution.self_π","module":"Mathlib.CategoryTheory.Preadditive.ProjectiveResolution","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nZ : C\ninst✝ : CategoryTheory.Projective Z\n⊢ Eq (CategoryTheory.ProjectiveResolution.self Z).π (CategoryTheory.CategoryStruct.id ((ChainComplex.single₀ C).obj Z))","decl":"/-- A projective object admits a trivial projective resolution: itself in degree 0. -/\n@[simps]\nnoncomputable def self [Projective Z] : ProjectiveResolution Z where\n  complex := (ChainComplex.single₀ C).obj Z\n  π := 𝟙 ((ChainComplex.single₀ C).obj Z)\n  projective n := by\n    cases n\n    · simpa\n    · apply IsZero.projective\n      apply HomologicalComplex.isZero_single_obj_X\n      simp\n\n"}
