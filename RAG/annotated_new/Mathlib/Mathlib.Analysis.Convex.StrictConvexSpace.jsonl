{"name":"StrictConvexSpace.strictConvex_closedBall","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NormedLinearOrderedField 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nself : StrictConvexSpace 𝕜 E\nr : Real\na✝ : LT.lt 0 r\n⊢ StrictConvex 𝕜 (Metric.closedBall 0 r)","decl":"/-- A *strictly convex space* is a normed space where the closed balls are strictly convex. We only\nrequire balls of positive radius with center at the origin to be strictly convex in the definition,\nthen prove that any closed ball is strictly convex in `strictConvex_closedBall` below.\n\nSee also `StrictConvexSpace.of_strictConvex_unitClosedBall`. -/\nclass StrictConvexSpace (𝕜 E : Type*) [NormedLinearOrderedField 𝕜] [NormedAddCommGroup E]\n  [NormedSpace 𝕜 E] : Prop where\n  strictConvex_closedBall : ∀ r : ℝ, 0 < r → StrictConvex 𝕜 (closedBall (0 : E) r)\n\n"}
{"name":"strictConvex_closedBall","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : NormedLinearOrderedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : StrictConvexSpace 𝕜 E\nx : E\nr : Real\n⊢ StrictConvex 𝕜 (Metric.closedBall x r)","decl":"/-- A closed ball in a strictly convex space is strictly convex. -/\ntheorem strictConvex_closedBall [StrictConvexSpace 𝕜 E] (x : E) (r : ℝ) :\n    StrictConvex 𝕜 (closedBall x r) := by\n  rcases le_or_lt r 0 with hr | hr\n  · exact (subsingleton_closedBall x hr).strictConvex\n  rw [← vadd_closedBall_zero]\n  exact (StrictConvexSpace.strictConvex_closedBall r hr).vadd _\n\n"}
{"name":"StrictConvexSpace.of_strictConvex_unitClosedBall","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : NormedLinearOrderedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace Real E\ninst✝ : LinearMap.CompatibleSMul E E 𝕜 Real\nh : StrictConvex 𝕜 (Metric.closedBall 0 1)\n⊢ StrictConvexSpace 𝕜 E","decl":"/-- A real normed vector space is strictly convex provided that the unit ball is strictly convex. -/\ntheorem StrictConvexSpace.of_strictConvex_unitClosedBall [LinearMap.CompatibleSMul E E 𝕜 ℝ]\n    (h : StrictConvex 𝕜 (closedBall (0 : E) 1)) : StrictConvexSpace 𝕜 E :=\n  ⟨fun r hr => by simpa only [smul_unitClosedBall_of_nonneg hr.le] using h.smul r⟩\n\n"}
{"name":"StrictConvexSpace.of_strictConvex_closed_unit_ball","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : NormedLinearOrderedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace Real E\ninst✝ : LinearMap.CompatibleSMul E E 𝕜 Real\nh : StrictConvex 𝕜 (Metric.closedBall 0 1)\n⊢ StrictConvexSpace 𝕜 E","decl":"@[deprecated (since := \"2024-12-01\")]\nalias StrictConvexSpace.of_strictConvex_closed_unit_ball :=\n  StrictConvexSpace.of_strictConvex_unitClosedBall\n\n"}
{"name":"StrictConvexSpace.of_norm_combo_lt_one","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nh : ∀ (x y : E), Eq (Norm.norm x) 1 → Eq (Norm.norm y) 1 → Ne x y → Exists fun a => Exists fun b => And (Eq (HAdd.hAdd a b) 1) (LT.lt (Norm.norm (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))) 1)\n⊢ StrictConvexSpace Real E","decl":"/-- Strict convexity is equivalent to `‖a • x + b • y‖ < 1` for all `x` and `y` of norm at most `1`\nand all strictly positive `a` and `b` such that `a + b = 1`. This lemma shows that it suffices to\ncheck this for points of norm one and some `a`, `b` such that `a + b = 1`. -/\ntheorem StrictConvexSpace.of_norm_combo_lt_one\n    (h : ∀ x y : E, ‖x‖ = 1 → ‖y‖ = 1 → x ≠ y → ∃ a b : ℝ, a + b = 1 ∧ ‖a • x + b • y‖ < 1) :\n    StrictConvexSpace ℝ E := by\n  refine\n    StrictConvexSpace.of_strictConvex_unitClosedBall ℝ\n      ((convex_closedBall _ _).strictConvex' fun x hx y hy hne => ?_)\n  rw [interior_closedBall (0 : E) one_ne_zero, closedBall_diff_ball,\n    mem_sphere_zero_iff_norm] at hx hy\n  rcases h x y hx hy hne with ⟨a, b, hab, hlt⟩\n  use b\n  rwa [AffineMap.lineMap_apply_module, interior_closedBall (0 : E) one_ne_zero, mem_ball_zero_iff,\n    sub_eq_iff_eq_add.2 hab.symm]\n\n"}
{"name":"StrictConvexSpace.of_norm_combo_ne_one","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nh : ∀ (x y : E), Eq (Norm.norm x) 1 → Eq (Norm.norm y) 1 → Ne x y → Exists fun a => Exists fun b => And (LE.le 0 a) (And (LE.le 0 b) (And (Eq (HAdd.hAdd a b) 1) (Ne (Norm.norm (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))) 1)))\n⊢ StrictConvexSpace Real E","decl":"theorem StrictConvexSpace.of_norm_combo_ne_one\n    (h :\n      ∀ x y : E,\n        ‖x‖ = 1 → ‖y‖ = 1 → x ≠ y → ∃ a b : ℝ, 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ ‖a • x + b • y‖ ≠ 1) :\n    StrictConvexSpace ℝ E := by\n  refine StrictConvexSpace.of_strictConvex_unitClosedBall ℝ\n    ((convex_closedBall _ _).strictConvex ?_)\n  simp only [interior_closedBall _ one_ne_zero, closedBall_diff_ball, Set.Pairwise,\n    frontier_closedBall _ one_ne_zero, mem_sphere_zero_iff_norm]\n  intro x hx y hy hne\n  rcases h x y hx hy hne with ⟨a, b, ha, hb, hab, hne'⟩\n  exact ⟨_, ⟨a, b, ha, hb, hab, rfl⟩, mt mem_sphere_zero_iff_norm.1 hne'⟩\n\n"}
{"name":"StrictConvexSpace.of_norm_add_ne_two","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nh : ∀ ⦃x y : E⦄, Eq (Norm.norm x) 1 → Eq (Norm.norm y) 1 → Ne x y → Ne (Norm.norm (HAdd.hAdd x y)) 2\n⊢ StrictConvexSpace Real E","decl":"theorem StrictConvexSpace.of_norm_add_ne_two\n    (h : ∀ ⦃x y : E⦄, ‖x‖ = 1 → ‖y‖ = 1 → x ≠ y → ‖x + y‖ ≠ 2) : StrictConvexSpace ℝ E := by\n  refine\n    StrictConvexSpace.of_norm_combo_ne_one fun x y hx hy hne =>\n      ⟨1 / 2, 1 / 2, one_half_pos.le, one_half_pos.le, add_halves _, ?_⟩\n  rw [← smul_add, norm_smul, Real.norm_of_nonneg one_half_pos.le, one_div, ← div_eq_inv_mul, Ne,\n    div_eq_one_iff_eq (two_ne_zero' ℝ)]\n  exact h hx hy hne\n\n"}
{"name":"StrictConvexSpace.of_pairwise_sphere_norm_ne_two","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nh : (Metric.sphere 0 1).Pairwise fun x y => Ne (Norm.norm (HAdd.hAdd x y)) 2\n⊢ StrictConvexSpace Real E","decl":"theorem StrictConvexSpace.of_pairwise_sphere_norm_ne_two\n    (h : (sphere (0 : E) 1).Pairwise fun x y => ‖x + y‖ ≠ 2) : StrictConvexSpace ℝ E :=\n  StrictConvexSpace.of_norm_add_ne_two fun _ _ hx hy =>\n    h (mem_sphere_zero_iff_norm.2 hx) (mem_sphere_zero_iff_norm.2 hy)\n\n"}
{"name":"StrictConvexSpace.of_norm_add","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nh : ∀ (x y : E), Eq (Norm.norm x) 1 → Eq (Norm.norm y) 1 → Eq (Norm.norm (HAdd.hAdd x y)) 2 → SameRay Real x y\n⊢ StrictConvexSpace Real E","decl":"/-- If `‖x + y‖ = ‖x‖ + ‖y‖` implies that `x y : E` are in the same ray, then `E` is a strictly\nconvex space. See also a more -/\ntheorem StrictConvexSpace.of_norm_add\n    (h : ∀ x y : E, ‖x‖ = 1 → ‖y‖ = 1 → ‖x + y‖ = 2 → SameRay ℝ x y) : StrictConvexSpace ℝ E := by\n  refine StrictConvexSpace.of_pairwise_sphere_norm_ne_two fun x hx y hy => mt fun h₂ => ?_\n  rw [mem_sphere_zero_iff_norm] at hx hy\n  exact (sameRay_iff_of_norm_eq (hx.trans hy.symm)).1 (h x y hx hy h₂)\n\n"}
{"name":"combo_mem_ball_of_ne","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y z : E\na b r : Real\nhx : Membership.mem (Metric.closedBall z r) x\nhy : Membership.mem (Metric.closedBall z r) y\nhne : Ne x y\nha : LT.lt 0 a\nhb : LT.lt 0 b\nhab : Eq (HAdd.hAdd a b) 1\n⊢ Membership.mem (Metric.ball z r) (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))","decl":"/-- If `x ≠ y` belong to the same closed ball, then a convex combination of `x` and `y` with\npositive coefficients belongs to the corresponding open ball. -/\ntheorem combo_mem_ball_of_ne (hx : x ∈ closedBall z r) (hy : y ∈ closedBall z r) (hne : x ≠ y)\n    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) : a • x + b • y ∈ ball z r := by\n  rcases eq_or_ne r 0 with (rfl | hr)\n  · rw [closedBall_zero, mem_singleton_iff] at hx hy\n    exact (hne (hx.trans hy.symm)).elim\n  · simp only [← interior_closedBall _ hr] at hx hy ⊢\n    exact strictConvex_closedBall ℝ z r hx hy hne ha hb hab\n\n"}
{"name":"openSegment_subset_ball_of_ne","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y z : E\nr : Real\nhx : Membership.mem (Metric.closedBall z r) x\nhy : Membership.mem (Metric.closedBall z r) y\nhne : Ne x y\n⊢ HasSubset.Subset (openSegment Real x y) (Metric.ball z r)","decl":"/-- If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is\nincluded in the corresponding open ball. -/\ntheorem openSegment_subset_ball_of_ne (hx : x ∈ closedBall z r) (hy : y ∈ closedBall z r)\n    (hne : x ≠ y) : openSegment ℝ x y ⊆ ball z r :=\n  (openSegment_subset_iff _).2 fun _ _ => combo_mem_ball_of_ne hx hy hne\n\n"}
{"name":"norm_combo_lt_of_ne","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\na b r : Real\nhx : LE.le (Norm.norm x) r\nhy : LE.le (Norm.norm y) r\nhne : Ne x y\nha : LT.lt 0 a\nhb : LT.lt 0 b\nhab : Eq (HAdd.hAdd a b) 1\n⊢ LT.lt (Norm.norm (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))) r","decl":"/-- If `x` and `y` are two distinct vectors of norm at most `r`, then a convex combination of `x`\nand `y` with positive coefficients has norm strictly less than `r`. -/\ntheorem norm_combo_lt_of_ne (hx : ‖x‖ ≤ r) (hy : ‖y‖ ≤ r) (hne : x ≠ y) (ha : 0 < a) (hb : 0 < b)\n    (hab : a + b = 1) : ‖a • x + b • y‖ < r := by\n  simp only [← mem_ball_zero_iff, ← mem_closedBall_zero_iff] at hx hy ⊢\n  exact combo_mem_ball_of_ne hx hy hne ha hb hab\n\n"}
{"name":"norm_add_lt_of_not_sameRay","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\nh : Not (SameRay Real x y)\n⊢ LT.lt (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y))","decl":"/-- In a strictly convex space, if `x` and `y` are not in the same ray, then `‖x + y‖ < ‖x‖ + ‖y‖`.\n-/\ntheorem norm_add_lt_of_not_sameRay (h : ¬SameRay ℝ x y) : ‖x + y‖ < ‖x‖ + ‖y‖ := by\n  simp only [sameRay_iff_inv_norm_smul_eq, not_or, ← Ne.eq_def] at h\n  rcases h with ⟨hx, hy, hne⟩\n  rw [← norm_pos_iff] at hx hy\n  have hxy : 0 < ‖x‖ + ‖y‖ := add_pos hx hy\n  have :=\n    combo_mem_ball_of_ne (inv_norm_smul_mem_unitClosedBall x)\n      (inv_norm_smul_mem_unitClosedBall y) hne (div_pos hx hxy) (div_pos hy hxy)\n      (by rw [← add_div, div_self hxy.ne'])\n  rwa [mem_ball_zero_iff, div_eq_inv_mul, div_eq_inv_mul, mul_smul, mul_smul, smul_inv_smul₀ hx.ne',\n    smul_inv_smul₀ hy.ne', ← smul_add, norm_smul, Real.norm_of_nonneg (inv_pos.2 hxy).le, ←\n    div_eq_inv_mul, div_lt_one hxy] at this\n\n"}
{"name":"lt_norm_sub_of_not_sameRay","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\nh : Not (SameRay Real x y)\n⊢ LT.lt (HSub.hSub (Norm.norm x) (Norm.norm y)) (Norm.norm (HSub.hSub x y))","decl":"theorem lt_norm_sub_of_not_sameRay (h : ¬SameRay ℝ x y) : ‖x‖ - ‖y‖ < ‖x - y‖ := by\n  nth_rw 1 [← sub_add_cancel x y] at h ⊢\n  exact sub_lt_iff_lt_add.2 (norm_add_lt_of_not_sameRay fun H' => h <| H'.add_left SameRay.rfl)\n\n"}
{"name":"abs_lt_norm_sub_of_not_sameRay","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\nh : Not (SameRay Real x y)\n⊢ LT.lt (abs (HSub.hSub (Norm.norm x) (Norm.norm y))) (Norm.norm (HSub.hSub x y))","decl":"theorem abs_lt_norm_sub_of_not_sameRay (h : ¬SameRay ℝ x y) : |‖x‖ - ‖y‖| < ‖x - y‖ := by\n  refine abs_sub_lt_iff.2 ⟨lt_norm_sub_of_not_sameRay h, ?_⟩\n  rw [norm_sub_rev]\n  exact lt_norm_sub_of_not_sameRay (mt SameRay.symm h)\n\n"}
{"name":"sameRay_iff_norm_add","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\n⊢ Iff (SameRay Real x y) (Eq (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y)))","decl":"/-- In a strictly convex space, two vectors `x`, `y` are in the same ray if and only if the triangle\ninequality for `x` and `y` becomes an equality. -/\ntheorem sameRay_iff_norm_add : SameRay ℝ x y ↔ ‖x + y‖ = ‖x‖ + ‖y‖ :=\n  ⟨SameRay.norm_add, fun h => Classical.not_not.1 fun h' => (norm_add_lt_of_not_sameRay h').ne h⟩\n\n"}
{"name":"eq_of_norm_eq_of_norm_add_eq","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\nh₁ : Eq (Norm.norm x) (Norm.norm y)\nh₂ : Eq (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y))\n⊢ Eq x y","decl":"/-- If `x` and `y` are two vectors in a strictly convex space have the same norm and the norm of\ntheir sum is equal to the sum of their norms, then they are equal. -/\ntheorem eq_of_norm_eq_of_norm_add_eq (h₁ : ‖x‖ = ‖y‖) (h₂ : ‖x + y‖ = ‖x‖ + ‖y‖) : x = y :=\n  (sameRay_iff_norm_add.mpr h₂).eq_of_norm_eq h₁\n\n"}
{"name":"not_sameRay_iff_norm_add_lt","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\n⊢ Iff (Not (SameRay Real x y)) (LT.lt (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y)))","decl":"/-- In a strictly convex space, two vectors `x`, `y` are not in the same ray if and only if the\ntriangle inequality for `x` and `y` is strict. -/\ntheorem not_sameRay_iff_norm_add_lt : ¬SameRay ℝ x y ↔ ‖x + y‖ < ‖x‖ + ‖y‖ :=\n  sameRay_iff_norm_add.not.trans (norm_add_le _ _).lt_iff_ne.symm\n\n"}
{"name":"sameRay_iff_norm_sub","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\n⊢ Iff (SameRay Real x y) (Eq (Norm.norm (HSub.hSub x y)) (abs (HSub.hSub (Norm.norm x) (Norm.norm y))))","decl":"theorem sameRay_iff_norm_sub : SameRay ℝ x y ↔ ‖x - y‖ = |‖x‖ - ‖y‖| :=\n  ⟨SameRay.norm_sub, fun h =>\n    Classical.not_not.1 fun h' => (abs_lt_norm_sub_of_not_sameRay h').ne' h⟩\n\n"}
{"name":"not_sameRay_iff_abs_lt_norm_sub","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\n⊢ Iff (Not (SameRay Real x y)) (LT.lt (abs (HSub.hSub (Norm.norm x) (Norm.norm y))) (Norm.norm (HSub.hSub x y)))","decl":"theorem not_sameRay_iff_abs_lt_norm_sub : ¬SameRay ℝ x y ↔ |‖x‖ - ‖y‖| < ‖x - y‖ :=\n  sameRay_iff_norm_sub.not.trans <| ne_comm.trans (abs_norm_sub_norm_le _ _).lt_iff_ne.symm\n\n"}
{"name":"norm_midpoint_lt_iff","module":"Mathlib.Analysis.Convex.StrictConvexSpace","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : StrictConvexSpace Real E\nx y : E\nh : Eq (Norm.norm x) (Norm.norm y)\n⊢ Iff (LT.lt (Norm.norm (HSMul.hSMul (1 / 2) (HAdd.hAdd x y))) (Norm.norm x)) (Ne x y)","decl":"theorem norm_midpoint_lt_iff (h : ‖x‖ = ‖y‖) : ‖(1 / 2 : ℝ) • (x + y)‖ < ‖x‖ ↔ x ≠ y := by\n  rw [norm_smul, Real.norm_of_nonneg (one_div_nonneg.2 zero_le_two), ← inv_eq_one_div, ←\n    div_eq_inv_mul, div_lt_iff₀ (zero_lt_two' ℝ), mul_two, ← not_sameRay_iff_of_norm_eq h,\n    not_sameRay_iff_norm_add_lt, h]\n"}
