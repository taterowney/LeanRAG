{"name":"SubMulAction.algebraMap_mem","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Membership.mem 1 ((algebraMap R A) r)","decl":"theorem algebraMap_mem (r : R) : algebraMap R A r ∈ (1 : SubMulAction R A) :=\n  ⟨r, (algebraMap_eq_smul_one r).symm⟩\n\n"}
{"name":"SubMulAction.mem_one'","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\n⊢ Iff (Membership.mem 1 x) (Exists fun y => Eq ((algebraMap R A) y) x)","decl":"theorem mem_one' {x : A} : x ∈ (1 : SubMulAction R A) ↔ ∃ y, algebraMap R A y = x :=\n  exists_congr fun r => by rw [algebraMap_eq_smul_one]\n\n"}
{"name":"Submodule.one_eq_span","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : Semiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Module R A\n⊢ Eq 1 (Submodule.span R (Singleton.singleton 1))","decl":"theorem one_eq_span : (1 : Submodule R A) = R ∙ 1 :=\n  (LinearMap.span_singleton_eq_range _ _ _).symm\n\n"}
{"name":"Submodule.le_one_toAddSubmonoid","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : Semiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Module R A\n⊢ LE.le 1 (Submodule.toAddSubmonoid 1)","decl":"theorem le_one_toAddSubmonoid : 1 ≤ (1 : Submodule R A).toAddSubmonoid := by\n  rintro x ⟨n, rfl⟩\n  exact ⟨n, show (n : R) • (1 : A) = n by rw [Nat.cast_smul_eq_nsmul, nsmul_one]⟩\n\n"}
{"name":"Submodule.toSubMulAction_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : Semiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Module R A\n⊢ Eq (Submodule.toSubMulAction 1) 1","decl":"@[simp]\ntheorem toSubMulAction_one : (1 : Submodule R A).toSubMulAction = 1 :=\n  SetLike.ext fun _ ↦ by rw [one_eq_span, SubMulAction.mem_one]; exact mem_span_singleton\n\n"}
{"name":"Submodule.one_eq_span_one_set","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : Semiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Module R A\n⊢ Eq 1 (Submodule.span R 1)","decl":"theorem one_eq_span_one_set : (1 : Submodule R A) = span R 1 :=\n  one_eq_span\n\n"}
{"name":"Submodule.one_le","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : Semiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Module R A\nP : Submodule R A\n⊢ Iff (LE.le 1 P) (Membership.mem P 1)","decl":"@[simp]\ntheorem one_le {P : Submodule R A} : (1 : Submodule R A) ≤ P ↔ (1 : A) ∈ P := by\n  simp [one_eq_span]\n\n"}
{"name":"Submodule.smul_toAddSubmonoid","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI : Submodule R A\nN : Submodule R M\n⊢ Eq (HSMul.hSMul I N).toAddSubmonoid (HSMul.hSMul I.toAddSubmonoid N.toAddSubmonoid)","decl":"theorem smul_toAddSubmonoid : (I • N).toAddSubmonoid = I.toAddSubmonoid • N.toAddSubmonoid := rfl\n\n"}
{"name":"Submodule.smul_mem_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI : Submodule R A\nN : Submodule R M\nr : A\nn : M\nhr : Membership.mem I r\nhn : Membership.mem N n\n⊢ Membership.mem (HSMul.hSMul I N) (HSMul.hSMul r n)","decl":"theorem smul_mem_smul {r} {n} (hr : r ∈ I) (hn : n ∈ N) : r • n ∈ I • N :=\n  AddSubmonoid.smul_mem_smul hr hn\n\n"}
{"name":"Submodule.smul_le","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI : Submodule R A\nN P : Submodule R M\n⊢ Iff (LE.le (HSMul.hSMul I N) P) (∀ (r : A), Membership.mem I r → ∀ (n : M), Membership.mem N n → Membership.mem P (HSMul.hSMul r n))","decl":"theorem smul_le : I • N ≤ P ↔ ∀ r ∈ I, ∀ n ∈ N, r • n ∈ P :=\n  AddSubmonoid.smul_le\n\n"}
{"name":"Submodule.coe_set_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI : Submodule R A\nN : Submodule R M\n⊢ Eq (HSMul.hSMul (↑I) N) (HSMul.hSMul I N)","decl":"@[simp, norm_cast]\nlemma coe_set_smul : (I : Set A) • N = I • N :=\n  set_smul_eq_of_le _ _ _\n    (fun _ _ hr hx ↦ smul_mem_smul hr hx)\n    (smul_le.mpr fun _ hr _ hx ↦ mem_set_smul_of_mem_mem hr hx)\n\n"}
{"name":"Submodule.smul_induction_on","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI : Submodule R A\nN : Submodule R M\np : M → Prop\nx : M\nH : Membership.mem (HSMul.hSMul I N) x\nsmul : ∀ (r : A), Membership.mem I r → ∀ (n : M), Membership.mem N n → p (HSMul.hSMul r n)\nadd : ∀ (x y : M), p x → p y → p (HAdd.hAdd x y)\n⊢ p x","decl":"@[elab_as_elim]\ntheorem smul_induction_on {p : M → Prop} {x} (H : x ∈ I • N) (smul : ∀ r ∈ I, ∀ n ∈ N, p (r • n))\n    (add : ∀ x y, p x → p y → p (x + y)) : p x :=\n  AddSubmonoid.smul_induction_on H smul add\n\n"}
{"name":"Submodule.smul_induction_on'","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI : Submodule R A\nN : Submodule R M\nx : M\nhx : Membership.mem (HSMul.hSMul I N) x\np : (x : M) → Membership.mem (HSMul.hSMul I N) x → Prop\nsmul : ∀ (r : A) (hr : Membership.mem I r) (n : M) (hn : Membership.mem N n), p (HSMul.hSMul r n) ⋯\nadd : ∀ (x : M) (hx : Membership.mem (HSMul.hSMul I N) x) (y : M) (hy : Membership.mem (HSMul.hSMul I N) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\n⊢ p x hx","decl":"/-- Dependent version of `Submodule.smul_induction_on`. -/\n@[elab_as_elim]\ntheorem smul_induction_on' {x : M} (hx : x ∈ I • N) {p : ∀ x, x ∈ I • N → Prop}\n    (smul : ∀ (r : A) (hr : r ∈ I) (n : M) (hn : n ∈ N), p (r • n) (smul_mem_smul hr hn))\n    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem ‹_› ‹_›)) : p x hx := by\n  refine Exists.elim ?_ fun (h : x ∈ I • N) (H : p x h) ↦ H\n  exact smul_induction_on hx (fun a ha x hx ↦ ⟨_, smul _ ha _ hx⟩)\n    fun x y ⟨_, hx⟩ ⟨_, hy⟩ ↦ ⟨_, add _ _ _ _ hx hy⟩\n\n"}
{"name":"Submodule.smul_mono","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI J : Submodule R A\nN P : Submodule R M\nhij : LE.le I J\nhnp : LE.le N P\n⊢ LE.le (HSMul.hSMul I N) (HSMul.hSMul J P)","decl":"theorem smul_mono (hij : I ≤ J) (hnp : N ≤ P) : I • N ≤ J • P :=\n  AddSubmonoid.smul_le_smul hij hnp\n\n"}
{"name":"Submodule.smul_mono_left","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI J : Submodule R A\nN : Submodule R M\nh : LE.le I J\n⊢ LE.le (HSMul.hSMul I N) (HSMul.hSMul J N)","decl":"theorem smul_mono_left (h : I ≤ J) : I • N ≤ J • N :=\n  smul_mono h le_rfl\n\n"}
{"name":"Submodule.instCovariantClassHSMulLe_1","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\n⊢ CovariantClass (Submodule R A) (Submodule R M) HSMul.hSMul LE.le","decl":"instance : CovariantClass (Submodule R A) (Submodule R M) HSMul.hSMul LE.le :=\n  ⟨fun _ _ => smul_mono le_rfl⟩\n\n"}
{"name":"Submodule.smul_bot","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI : Submodule R A\n⊢ Eq (HSMul.hSMul I Bot.bot) Bot.bot","decl":"@[simp]\ntheorem smul_bot : I • (⊥ : Submodule R M) = ⊥ :=\n  toAddSubmonoid_injective <| AddSubmonoid.addSubmonoid_smul_bot _\n\n"}
{"name":"Submodule.bot_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nN : Submodule R M\n⊢ Eq (HSMul.hSMul Bot.bot N) Bot.bot","decl":"@[simp]\ntheorem bot_smul : (⊥ : Submodule R A) • N = ⊥ :=\n  le_bot_iff.mp <| smul_le.mpr <| by rintro _ rfl _ _; rw [zero_smul]; exact zero_mem _\n\n"}
{"name":"Submodule.smul_sup","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI : Submodule R A\nN P : Submodule R M\n⊢ Eq (HSMul.hSMul I (Max.max N P)) (Max.max (HSMul.hSMul I N) (HSMul.hSMul I P))","decl":"theorem smul_sup : I • (N ⊔ P) = I • N ⊔ I • P :=\n  toAddSubmonoid_injective <| by\n    simp only [smul_toAddSubmonoid, sup_toAddSubmonoid, AddSubmonoid.addSubmonoid_smul_sup]\n\n"}
{"name":"Submodule.sup_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI J : Submodule R A\nN : Submodule R M\n⊢ Eq (HSMul.hSMul (Max.max I J) N) (Max.max (HSMul.hSMul I N) (HSMul.hSMul J N))","decl":"theorem sup_smul : (I ⊔ J) • N = I • N ⊔ J • N :=\n  le_antisymm (smul_le.mpr fun mn hmn p hp ↦ by\n    obtain ⟨m, hm, n, hn, rfl⟩ := mem_sup.mp hmn\n    rw [add_smul]; exact add_mem_sup (smul_mem_smul hm hp) <| smul_mem_smul hn hp)\n    (sup_le (smul_mono_left le_sup_left) <| smul_mono_left le_sup_right)\n\n"}
{"name":"Submodule.smul_assoc","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝¹³ : Semiring R\nA : Type v\ninst✝¹² : Semiring A\ninst✝¹¹ : Module R A\nM : Type u_1\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : Module A M\ninst✝⁷ : IsScalarTower R A M\nB : Type u_2\ninst✝⁶ : Semiring B\ninst✝⁵ : Module R B\ninst✝⁴ : Module A B\ninst✝³ : Module B M\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R B M\ninst✝ : IsScalarTower A B M\nI : Submodule R A\nJ : Submodule R B\nN : Submodule R M\n⊢ Eq (HSMul.hSMul (HSMul.hSMul I J) N) (HSMul.hSMul I (HSMul.hSMul J N))","decl":"protected theorem smul_assoc {B} [Semiring B] [Module R B] [Module A B] [Module B M]\n    [IsScalarTower R A B] [IsScalarTower R B M] [IsScalarTower A B M]\n    (I : Submodule R A) (J : Submodule R B) (N : Submodule R M) :\n    (I • J) • N = I • J • N :=\n  le_antisymm\n    (smul_le.2 fun _ hrsij t htn ↦ smul_induction_on hrsij\n      (fun r hr s hs ↦ smul_assoc r s t ▸ smul_mem_smul hr (smul_mem_smul hs htn))\n      fun x y ↦ (add_smul x y t).symm ▸ add_mem)\n    (smul_le.2 fun r hr _ hsn ↦ smul_induction_on hsn\n      (fun j hj n hn ↦ (smul_assoc r j n).symm ▸ smul_mem_smul (smul_mem_smul hr hj) hn)\n      fun m₁ m₂ ↦ (smul_add r m₁ m₂) ▸ add_mem)\n\n"}
{"name":"Submodule.smul_iSup","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nι : Sort u_2\nI : Submodule R A\nt : ι → Submodule R M\n⊢ Eq (HSMul.hSMul I (iSup fun i => t i)) (iSup fun i => HSMul.hSMul I (t i))","decl":"theorem smul_iSup {ι : Sort*} {I : Submodule R A} {t : ι → Submodule R M} :\n    I • (⨆ i, t i)= ⨆ i, I • t i :=\n  toAddSubmonoid_injective <| by\n    simp only [smul_toAddSubmonoid, iSup_toAddSubmonoid, AddSubmonoid.smul_iSup]\n\n"}
{"name":"Submodule.iSup_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nι : Sort u_2\nt : ι → Submodule R A\nN : Submodule R M\n⊢ Eq (HSMul.hSMul (iSup fun i => t i) N) (iSup fun i => HSMul.hSMul (t i) N)","decl":"theorem iSup_smul {ι : Sort*} {t : ι → Submodule R A} {N : Submodule R M} :\n    (⨆ i, t i) • N = ⨆ i, t i • N :=\n  le_antisymm (smul_le.mpr fun t ht s hs ↦ iSup_induction _ (C := (· • s ∈ _)) ht\n    (fun i t ht ↦ mem_iSup_of_mem i <| smul_mem_smul ht hs)\n    (by simp_rw [zero_smul]; apply zero_mem) fun x y ↦ by simp_rw [add_smul]; apply add_mem)\n    (iSup_le fun i ↦ Submodule.smul_mono_left <| le_iSup _ i)\n\n"}
{"name":"Submodule.one_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nN : Submodule R M\n⊢ Eq (HSMul.hSMul 1 N) N","decl":"protected theorem one_smul : (1 : Submodule R A) • N = N := by\n  refine le_antisymm (smul_le.mpr fun r hr m hm ↦ ?_) fun m hm ↦ ?_\n  · obtain ⟨r, rfl⟩ := hr\n    rw [LinearMap.toSpanSingleton_apply, smul_one_smul]; exact N.smul_mem r hm\n  · rw [← one_smul A m]; exact smul_mem_smul (one_le.mp le_rfl) hm\n\n"}
{"name":"Submodule.smul_subset_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Module R A\nM : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nI : Submodule R A\nN : Submodule R M\n⊢ HasSubset.Subset (HSMul.hSMul ↑I ↑N) ↑(HSMul.hSMul I N)","decl":"theorem smul_subset_smul : (↑I : Set A) • (↑N : Set M) ⊆ (↑(I • N) : Set M) :=\n  AddSubmonoid.smul_subset_smul\n\n"}
{"name":"Submodule.mul_mem_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N : Submodule R A\nm n : A\nhm : Membership.mem M m\nhn : Membership.mem N n\n⊢ Membership.mem (HMul.hMul M N) (HMul.hMul m n)","decl":"theorem mul_mem_mul (hm : m ∈ M) (hn : n ∈ N) : m * n ∈ M * N :=\n  smul_mem_smul hm hn\n\n"}
{"name":"Submodule.mul_le","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N P : Submodule R A\n⊢ Iff (LE.le (HMul.hMul M N) P) (∀ (m : A), Membership.mem M m → ∀ (n : A), Membership.mem N n → Membership.mem P (HMul.hMul m n))","decl":"theorem mul_le : M * N ≤ P ↔ ∀ m ∈ M, ∀ n ∈ N, m * n ∈ P :=\n  smul_le\n\n"}
{"name":"Submodule.mul_toAddSubmonoid","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N : Submodule R A\n⊢ Eq (HMul.hMul M N).toAddSubmonoid (HMul.hMul M.toAddSubmonoid N.toAddSubmonoid)","decl":"theorem mul_toAddSubmonoid (M N : Submodule R A) :\n    (M * N).toAddSubmonoid = M.toAddSubmonoid * N.toAddSubmonoid := rfl\n\n"}
{"name":"Submodule.mul_induction_on","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N : Submodule R A\nC : A → Prop\nr : A\nhr : Membership.mem (HMul.hMul M N) r\nhm : ∀ (m : A), Membership.mem M m → ∀ (n : A), Membership.mem N n → C (HMul.hMul m n)\nha : ∀ (x y : A), C x → C y → C (HAdd.hAdd x y)\n⊢ C r","decl":"@[elab_as_elim]\nprotected theorem mul_induction_on {C : A → Prop} {r : A} (hr : r ∈ M * N)\n    (hm : ∀ m ∈ M, ∀ n ∈ N, C (m * n)) (ha : ∀ x y, C x → C y → C (x + y)) : C r :=\n  smul_induction_on hr hm ha\n\n"}
{"name":"Submodule.mul_induction_on'","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N : Submodule R A\nC : (r : A) → Membership.mem (HMul.hMul M N) r → Prop\nmem_mul_mem : ∀ (m : A) (hm : Membership.mem M m) (n : A) (hn : Membership.mem N n), C (HMul.hMul m n) ⋯\nadd : ∀ (x : A) (hx : Membership.mem (HMul.hMul M N) x) (y : A) (hy : Membership.mem (HMul.hMul M N) y), C x hx → C y hy → C (HAdd.hAdd x y) ⋯\nr : A\nhr : Membership.mem (HMul.hMul M N) r\n⊢ C r hr","decl":"/-- A dependent version of `mul_induction_on`. -/\n@[elab_as_elim]\nprotected theorem mul_induction_on' {C : ∀ r, r ∈ M * N → Prop}\n    (mem_mul_mem : ∀ m (hm : m ∈ M) n (hn : n ∈ N), C (m * n) (mul_mem_mul hm hn))\n    (add : ∀ x hx y hy, C x hx → C y hy → C (x + y) (add_mem hx hy)) {r : A} (hr : r ∈ M * N) :\n    C r hr :=\n  smul_induction_on' hr mem_mul_mem add\n\n"}
{"name":"Submodule.mul_bot","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\n⊢ Eq (HMul.hMul M Bot.bot) Bot.bot","decl":"@[simp]\ntheorem mul_bot : M * ⊥ = ⊥ :=\n  smul_bot _\n\n"}
{"name":"Submodule.bot_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\n⊢ Eq (HMul.hMul Bot.bot M) Bot.bot","decl":"@[simp]\ntheorem bot_mul : ⊥ * M = ⊥ :=\n  bot_smul _\n\n"}
{"name":"Submodule.one_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\n⊢ Eq (HMul.hMul 1 M) M","decl":"protected theorem one_mul : (1 : Submodule R A) * M = M :=\n  Submodule.one_smul _\n\n"}
{"name":"Submodule.mul_le_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N P Q : Submodule R A\nhmp : LE.le M P\nhnq : LE.le N Q\n⊢ LE.le (HMul.hMul M N) (HMul.hMul P Q)","decl":"@[mono]\ntheorem mul_le_mul (hmp : M ≤ P) (hnq : N ≤ Q) : M * N ≤ P * Q :=\n  smul_mono hmp hnq\n\n"}
{"name":"Submodule.mul_le_mul_left","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N P : Submodule R A\nh : LE.le M N\n⊢ LE.le (HMul.hMul M P) (HMul.hMul N P)","decl":"theorem mul_le_mul_left (h : M ≤ N) : M * P ≤ N * P :=\n  smul_mono_left h\n\n"}
{"name":"Submodule.mul_le_mul_right","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N P : Submodule R A\nh : LE.le N P\n⊢ LE.le (HMul.hMul M N) (HMul.hMul M P)","decl":"theorem mul_le_mul_right (h : N ≤ P) : M * N ≤ M * P :=\n  smul_mono_right _ h\n\n"}
{"name":"Submodule.mul_comm_of_commute","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N : Submodule R A\nh : ∀ (m : A), Membership.mem M m → ∀ (n : A), Membership.mem N n → Commute m n\n⊢ Eq (HMul.hMul M N) (HMul.hMul N M)","decl":"theorem mul_comm_of_commute (h : ∀ m ∈ M, ∀ n ∈ N, Commute m n) : M * N = N * M :=\n  toAddSubmonoid_injective <| AddSubmonoid.mul_comm_of_commute h\n\n"}
{"name":"Submodule.mul_sup","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N P : Submodule R A\n⊢ Eq (HMul.hMul M (Max.max N P)) (Max.max (HMul.hMul M N) (HMul.hMul M P))","decl":"theorem mul_sup : M * (N ⊔ P) = M * N ⊔ M * P :=\n  smul_sup _ _ _\n\n"}
{"name":"Submodule.sup_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N P : Submodule R A\n⊢ Eq (HMul.hMul (Max.max M N) P) (Max.max (HMul.hMul M P) (HMul.hMul N P))","decl":"theorem sup_mul : (M ⊔ N) * P = M * P ⊔ N * P :=\n  sup_smul _ _ _\n\n"}
{"name":"Submodule.mul_subset_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM N : Submodule R A\n⊢ HasSubset.Subset (HMul.hMul ↑M ↑N) ↑(HMul.hMul M N)","decl":"theorem mul_subset_mul : (↑M : Set A) * (↑N : Set A) ⊆ (↑(M * N) : Set A) :=\n  smul_subset_smul _ _\n\n"}
{"name":"Submodule.restrictScalars_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Semiring C\ninst✝⁵ : SMul A B\ninst✝⁴ : Module A C\ninst✝³ : Module B C\ninst✝² : IsScalarTower A C C\ninst✝¹ : IsScalarTower B C C\ninst✝ : IsScalarTower A B C\nI J : Submodule B C\n⊢ Eq (Submodule.restrictScalars A (HMul.hMul I J)) (HMul.hMul (Submodule.restrictScalars A I) (Submodule.restrictScalars A J))","decl":"lemma restrictScalars_mul {A B C} [Semiring A] [Semiring B] [Semiring C]\n    [SMul A B] [Module A C] [Module B C] [IsScalarTower A C C] [IsScalarTower B C C]\n    [IsScalarTower A B C] {I J : Submodule B C} :\n    (I * J).restrictScalars A = I.restrictScalars A * J.restrictScalars A :=\n  rfl\n\n"}
{"name":"Submodule.iSup_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nι : Sort uι\ns : ι → Submodule R A\nt : Submodule R A\n⊢ Eq (HMul.hMul (iSup fun i => s i) t) (iSup fun i => HMul.hMul (s i) t)","decl":"theorem iSup_mul (s : ι → Submodule R A) (t : Submodule R A) : (⨆ i, s i) * t = ⨆ i, s i * t :=\n  iSup_smul\n\n"}
{"name":"Submodule.mul_iSup","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nι : Sort uι\nt : Submodule R A\ns : ι → Submodule R A\n⊢ Eq (HMul.hMul t (iSup fun i => s i)) (iSup fun i => HMul.hMul t (s i))","decl":"theorem mul_iSup (t : Submodule R A) (s : ι → Submodule R A) : (t * ⨆ i, s i) = ⨆ i, t * s i :=\n  smul_iSup\n\n"}
{"name":"Submodule.pow_eq_npowRec","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\nn : Nat\n⊢ Eq (HPow.hPow M n) (npowRec n M)","decl":"theorem pow_eq_npowRec {n : ℕ} : M ^ n = npowRec n M := rfl\n\n"}
{"name":"Submodule.pow_zero","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\n⊢ Eq (HPow.hPow M 0) 1","decl":"protected theorem pow_zero : M ^ 0 = 1 := rfl\n\n"}
{"name":"Submodule.pow_succ","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\nn : Nat\n⊢ Eq (HPow.hPow M (HAdd.hAdd n 1)) (HMul.hMul (HPow.hPow M n) M)","decl":"protected theorem pow_succ {n : ℕ} : M ^ (n + 1) = M ^ n * M := rfl\n\n"}
{"name":"Submodule.pow_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\n⊢ Eq (HPow.hPow M 1) M","decl":"protected theorem pow_one : M ^ 1 = M := by\n  rw [Submodule.pow_succ, Submodule.pow_zero, Submodule.one_mul]\n\n"}
{"name":"Submodule.pow_toAddSubmonoid","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\nn : Nat\nh : Ne n 0\n⊢ Eq (HPow.hPow M n).toAddSubmonoid (HPow.hPow M.toAddSubmonoid n)","decl":"theorem pow_toAddSubmonoid {n : ℕ} (h : n ≠ 0) : (M ^ n).toAddSubmonoid = M.toAddSubmonoid ^ n := by\n  induction n with\n  | zero => exact (h rfl).elim\n  | succ n ih =>\n    rw [Submodule.pow_succ, pow_succ, mul_toAddSubmonoid]\n    cases n with\n    | zero => rw [Submodule.pow_zero, pow_zero, one_mul, ← mul_toAddSubmonoid, Submodule.one_mul]\n    | succ n => rw [ih n.succ_ne_zero]\n\n"}
{"name":"Submodule.le_pow_toAddSubmonoid","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\nn : Nat\n⊢ LE.le (HPow.hPow M.toAddSubmonoid n) (HPow.hPow M n).toAddSubmonoid","decl":"theorem le_pow_toAddSubmonoid {n : ℕ} : M.toAddSubmonoid ^ n ≤ (M ^ n).toAddSubmonoid := by\n  obtain rfl | hn := Decidable.eq_or_ne n 0\n  · rw [Submodule.pow_zero, pow_zero]\n    exact le_one_toAddSubmonoid\n  · exact (pow_toAddSubmonoid M hn).ge\n\n"}
{"name":"Submodule.pow_subset_pow","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\nn : Nat\n⊢ HasSubset.Subset (HPow.hPow (↑M) n) ↑(HPow.hPow M n)","decl":"theorem pow_subset_pow {n : ℕ} : (↑M : Set A) ^ n ⊆ ↑(M ^ n : Submodule R A) :=\n  trans AddSubmonoid.pow_subset_pow (le_pow_toAddSubmonoid M)\n\n"}
{"name":"Submodule.pow_mem_pow","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝³ : Semiring R\nA : Type v\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nM : Submodule R A\nx : A\nhx : Membership.mem M x\nn : Nat\n⊢ Membership.mem (HPow.hPow M n) (HPow.hPow x n)","decl":"theorem pow_mem_pow {x : A} (hx : x ∈ M) (n : ℕ) : x ^ n ∈ M ^ n :=\n  pow_subset_pow _ <| Set.pow_mem_pow hx\n\n"}
{"name":"Submodule.restrictScalars_pow","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Semiring C\ninst✝⁵ : SMul A B\ninst✝⁴ : Module A C\ninst✝³ : Module B C\ninst✝² : IsScalarTower A C C\ninst✝¹ : IsScalarTower B C C\ninst✝ : IsScalarTower A B C\nI : Submodule B C\nn : Nat\nhn : Ne n 0\n⊢ Eq (Submodule.restrictScalars A (HPow.hPow I n)) (HPow.hPow (Submodule.restrictScalars A I) n)","decl":"lemma restrictScalars_pow {A B C : Type*} [Semiring A] [Semiring B]\n    [Semiring C] [SMul A B] [Module A C] [Module B C]\n    [IsScalarTower A C C] [IsScalarTower B C C] [IsScalarTower A B C]\n    {I : Submodule B C} :\n    ∀ {n : ℕ}, (hn : n ≠ 0) → (I ^ n).restrictScalars A = I.restrictScalars A ^ n\n  | 1, _ => by simp [Submodule.pow_one]\n  | n + 2, _ => by\n    simp [Submodule.pow_succ (n := n + 1), restrictScalars_mul, restrictScalars_pow n.succ_ne_zero]\n\n"}
{"name":"Submodule.one_eq_range","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq 1 (LinearMap.range (Algebra.linearMap R A))","decl":"theorem one_eq_range : (1 : Submodule R A) = LinearMap.range (Algebra.linearMap R A) := by\n  rw [one_eq_span, LinearMap.span_singleton_eq_range,\n    LinearMap.toSpanSingleton_eq_algebra_linearMap]\n\n"}
{"name":"Submodule.algebraMap_mem","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Membership.mem 1 ((algebraMap R A) r)","decl":"theorem algebraMap_mem (r : R) : algebraMap R A r ∈ (1 : Submodule R A) := by\n  rw [one_eq_range]; exact LinearMap.mem_range_self _ _\n\n"}
{"name":"Submodule.mem_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\n⊢ Iff (Membership.mem 1 x) (Exists fun y => Eq ((algebraMap R A) y) x)","decl":"@[simp]\ntheorem mem_one {x : A} : x ∈ (1 : Submodule R A) ↔ ∃ y, algebraMap R A y = x := by\n  rw [one_eq_range]; rfl\n\n"}
{"name":"Submodule.map_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nA' : Type u_1\ninst✝¹ : Semiring A'\ninst✝ : Algebra R A'\nf : AlgHom R A A'\n⊢ Eq (Submodule.map f.toLinearMap 1) 1","decl":"protected theorem map_one {A'} [Semiring A'] [Algebra R A'] (f : A →ₐ[R] A') :\n    map f.toLinearMap (1 : Submodule R A) = 1 := by\n  ext\n  simp\n\n"}
{"name":"Submodule.map_op_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Submodule.map (↑(MulOpposite.opLinearEquiv R)) 1) 1","decl":"@[simp]\ntheorem map_op_one :\n    map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) (1 : Submodule R A) = 1 := by\n  ext x\n  induction x\n  simp\n\n"}
{"name":"Submodule.comap_op_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Submodule.comap (↑(MulOpposite.opLinearEquiv R)) 1) 1","decl":"@[simp]\ntheorem comap_op_one :\n    comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) (1 : Submodule R Aᵐᵒᵖ) = 1 := by\n  ext\n  simp\n\n"}
{"name":"Submodule.map_unop_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Submodule.map (↑(MulOpposite.opLinearEquiv R).symm) 1) 1","decl":"@[simp]\ntheorem map_unop_one :\n    map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) (1 : Submodule R Aᵐᵒᵖ) = 1 := by\n  rw [← comap_equiv_eq_map_symm, comap_op_one]\n\n"}
{"name":"Submodule.comap_unop_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Submodule.comap (↑(MulOpposite.opLinearEquiv R).symm) 1) 1","decl":"@[simp]\ntheorem comap_unop_one :\n    comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) (1 : Submodule R A) = 1 := by\n  rw [← map_equiv_eq_comap_symm, map_op_one]\n\n"}
{"name":"Submodule.mul_eq_map₂","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM N : Submodule R A\n⊢ Eq (HMul.hMul M N) (Submodule.map₂ (LinearMap.mul R A) M N)","decl":"theorem mul_eq_map₂ : M * N = map₂ (LinearMap.mul R A) M N :=\n  le_antisymm (mul_le.mpr fun _m hm _n ↦ apply_mem_map₂ _ hm)\n    (map₂_le.mpr fun _m hm _n ↦ mul_mem_mul hm)\n\n"}
{"name":"Submodule.span_mul_span","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nS T : Set A\n⊢ Eq (HMul.hMul (Submodule.span R S) (Submodule.span R T)) (Submodule.span R (HMul.hMul S T))","decl":"theorem span_mul_span : span R S * span R T = span R (S * T) := by\n  rw [mul_eq_map₂]; apply map₂_span_span\n\n"}
{"name":"Submodule.mul_def","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM N : Submodule R A\n⊢ Eq (HMul.hMul M N) (Submodule.span R (HMul.hMul ↑M ↑N))","decl":"lemma mul_def : M * N = span R (M * N : Set A) := by simp [← span_mul_span]\n\n"}
{"name":"Submodule.mul_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM : Submodule R A\n⊢ Eq (HMul.hMul M 1) M","decl":"protected theorem mul_one : M * 1 = M := by\n  conv_lhs => rw [one_eq_span, ← span_eq M]\n  rw [span_mul_span]\n  simp\n\n"}
{"name":"Submodule.map_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nM N : Submodule R A\nA' : Type u_1\ninst✝¹ : Semiring A'\ninst✝ : Algebra R A'\nf : AlgHom R A A'\n⊢ Eq (Submodule.map f.toLinearMap (HMul.hMul M N)) (HMul.hMul (Submodule.map f.toLinearMap M) (Submodule.map f.toLinearMap N))","decl":"protected theorem map_mul {A'} [Semiring A'] [Algebra R A'] (f : A →ₐ[R] A') :\n    map f.toLinearMap (M * N) = map f.toLinearMap M * map f.toLinearMap N :=\n  calc\n    map f.toLinearMap (M * N) = ⨆ i : M, (N.map (LinearMap.mul R A i)).map f.toLinearMap := by\n      rw [mul_eq_map₂]; apply map_iSup\n    _ = map f.toLinearMap M * map f.toLinearMap N := by\n      rw [mul_eq_map₂]\n      apply congr_arg sSup\n      ext S\n      constructor <;> rintro ⟨y, hy⟩\n      · use ⟨f y, mem_map.mpr ⟨y.1, y.2, rfl⟩⟩  -- Porting note: added `⟨⟩`\n        refine Eq.trans ?_ hy\n        ext\n        simp\n      · obtain ⟨y', hy', fy_eq⟩ := mem_map.mp y.2\n        use ⟨y', hy'⟩  -- Porting note: added `⟨⟩`\n        refine Eq.trans ?_ hy\n        rw [f.toLinearMap_apply] at fy_eq\n        ext\n        simp [fy_eq]\n\n"}
{"name":"Submodule.map_op_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM N : Submodule R A\n⊢ Eq (Submodule.map (↑(MulOpposite.opLinearEquiv R)) (HMul.hMul M N)) (HMul.hMul (Submodule.map (↑(MulOpposite.opLinearEquiv R)) N) (Submodule.map (↑(MulOpposite.opLinearEquiv R)) M))","decl":"theorem map_op_mul :\n    map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) (M * N) =\n      map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) N *\n        map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) M := by\n  apply le_antisymm\n  · simp_rw [map_le_iff_le_comap]\n    refine mul_le.2 fun m hm n hn => ?_\n    rw [mem_comap, map_equiv_eq_comap_symm, map_equiv_eq_comap_symm]\n    show op n * op m ∈ _\n    exact mul_mem_mul hn hm\n  · refine mul_le.2 (MulOpposite.rec' fun m hm => MulOpposite.rec' fun n hn => ?_)\n    rw [Submodule.mem_map_equiv] at hm hn ⊢\n    exact mul_mem_mul hn hm\n\n"}
{"name":"Submodule.comap_unop_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM N : Submodule R A\n⊢ Eq (Submodule.comap (↑(MulOpposite.opLinearEquiv R).symm) (HMul.hMul M N)) (HMul.hMul (Submodule.comap (↑(MulOpposite.opLinearEquiv R).symm) N) (Submodule.comap (↑(MulOpposite.opLinearEquiv R).symm) M))","decl":"theorem comap_unop_mul :\n    comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) (M * N) =\n      comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) N *\n        comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) M := by\n  simp_rw [← map_equiv_eq_comap_symm, map_op_mul]\n\n"}
{"name":"Submodule.map_unop_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM N : Submodule R (MulOpposite A)\n⊢ Eq (Submodule.map (↑(MulOpposite.opLinearEquiv R).symm) (HMul.hMul M N)) (HMul.hMul (Submodule.map (↑(MulOpposite.opLinearEquiv R).symm) N) (Submodule.map (↑(MulOpposite.opLinearEquiv R).symm) M))","decl":"theorem map_unop_mul (M N : Submodule R Aᵐᵒᵖ) :\n    map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) (M * N) =\n      map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) N *\n        map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) M :=\n  have : Function.Injective (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) :=\n    LinearEquiv.injective _\n  map_injective_of_injective this <| by\n    rw [← map_comp, map_op_mul, ← map_comp, ← map_comp, LinearEquiv.comp_coe,\n      LinearEquiv.symm_trans_self, LinearEquiv.refl_toLinearMap, map_id, map_id, map_id]\n\n"}
{"name":"Submodule.comap_op_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM N : Submodule R (MulOpposite A)\n⊢ Eq (Submodule.comap (↑(MulOpposite.opLinearEquiv R)) (HMul.hMul M N)) (HMul.hMul (Submodule.comap (↑(MulOpposite.opLinearEquiv R)) N) (Submodule.comap (↑(MulOpposite.opLinearEquiv R)) M))","decl":"theorem comap_op_mul (M N : Submodule R Aᵐᵒᵖ) :\n    comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) (M * N) =\n      comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) N *\n        comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) M := by\n  simp_rw [comap_equiv_eq_map_symm, map_unop_mul]\n\n"}
{"name":"Submodule.instIsScalarTower","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : CommSemiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\nα : Type u_1\ninst✝³ : Monoid α\ninst✝² : DistribMulAction α A\ninst✝¹ : SMulCommClass α R A\ninst✝ : IsScalarTower α A A\n⊢ IsScalarTower α (Submodule R A) (Submodule R A)","decl":"instance [IsScalarTower α A A] : IsScalarTower α (Submodule R A) (Submodule R A) where\n  smul_assoc a S T := by\n    rw [← S.span_eq, ← T.span_eq, smul_span, smul_eq_mul, smul_eq_mul, span_mul_span, span_mul_span,\n      smul_span, smul_mul_assoc]\n\n"}
{"name":"Submodule.instSMulCommClass","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : CommSemiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\nα : Type u_1\ninst✝³ : Monoid α\ninst✝² : DistribMulAction α A\ninst✝¹ : SMulCommClass α R A\ninst✝ : SMulCommClass α A A\n⊢ SMulCommClass α (Submodule R A) (Submodule R A)","decl":"instance [SMulCommClass α A A] : SMulCommClass α (Submodule R A) (Submodule R A) where\n  smul_comm a S T := by\n    rw [← S.span_eq, ← T.span_eq, smul_span, smul_eq_mul, smul_eq_mul, span_mul_span, span_mul_span,\n      smul_span, mul_smul_comm]\n\n"}
{"name":"Submodule.instSMulCommClass_1","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁶ : CommSemiring R\nA : Type v\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\nα : Type u_1\ninst✝³ : Monoid α\ninst✝² : DistribMulAction α A\ninst✝¹ : SMulCommClass α R A\ninst✝ : SMulCommClass A α A\n⊢ SMulCommClass (Submodule R A) α (Submodule R A)","decl":"instance [SMulCommClass A α A] : SMulCommClass (Submodule R A) α (Submodule R A) :=\n  have := SMulCommClass.symm A α A; .symm ..\n\n"}
{"name":"Submodule.mem_span_mul_finite_of_mem_span_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid A\ninst✝¹ : Mul A\ninst✝ : Module R A\nS S' : Set A\nx : A\nhx : Membership.mem (Submodule.span R (HMul.hMul S S')) x\n⊢ Exists fun T => Exists fun T' => And (HasSubset.Subset (↑T) S) (And (HasSubset.Subset (↑T') S') (Membership.mem (Submodule.span R (HMul.hMul ↑T ↑T')) x))","decl":"theorem mem_span_mul_finite_of_mem_span_mul {R A} [Semiring R] [AddCommMonoid A] [Mul A]\n    [Module R A] {S : Set A} {S' : Set A} {x : A} (hx : x ∈ span R (S * S')) :\n    ∃ T T' : Finset A, ↑T ⊆ S ∧ ↑T' ⊆ S' ∧ x ∈ span R (T * T' : Set A) := by\n  classical\n  obtain ⟨U, h, hU⟩ := mem_span_finite_of_mem_span hx\n  obtain ⟨T, T', hS, hS', h⟩ := Finset.subset_mul h\n  use T, T', hS, hS'\n  have h' : (U : Set A) ⊆ T * T' := by assumption_mod_cast\n  have h'' := span_mono h' hU\n  assumption\n\n"}
{"name":"Submodule.mul_eq_span_mul_set","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns t : Submodule R A\n⊢ Eq (HMul.hMul s t) (Submodule.span R (HMul.hMul ↑s ↑t))","decl":"theorem mul_eq_span_mul_set (s t : Submodule R A) : s * t = span R ((s : Set A) * (t : Set A)) := by\n  rw [mul_eq_map₂]; exact map₂_eq_span_image2 _ s t\n\n"}
{"name":"Submodule.mem_span_mul_finite_of_mem_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nP Q : Submodule R A\nx : A\nhx : Membership.mem (HMul.hMul P Q) x\n⊢ Exists fun T => Exists fun T' => And (HasSubset.Subset ↑T ↑P) (And (HasSubset.Subset ↑T' ↑Q) (Membership.mem (Submodule.span R (HMul.hMul ↑T ↑T')) x))","decl":"theorem mem_span_mul_finite_of_mem_mul {P Q : Submodule R A} {x : A} (hx : x ∈ P * Q) :\n    ∃ T T' : Finset A, (T : Set A) ⊆ P ∧ (T' : Set A) ⊆ Q ∧ x ∈ span R (T * T' : Set A) :=\n  Submodule.mem_span_mul_finite_of_mem_span_mul\n    (by rwa [← Submodule.span_eq P, ← Submodule.span_eq Q, Submodule.span_mul_span] at hx)\n\n"}
{"name":"Submodule.mem_span_singleton_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nP : Submodule R A\nx y : A\n⊢ Iff (Membership.mem (HMul.hMul (Submodule.span R (Singleton.singleton y)) P) x) (Exists fun z => And (Membership.mem P z) (Eq (HMul.hMul y z) x))","decl":"theorem mem_span_singleton_mul {x y : A} : x ∈ span R {y} * P ↔ ∃ z ∈ P, y * z = x := by\n  simp_rw [mul_eq_map₂, (· * ·), map₂_span_singleton_eq_map]\n  rfl\n\n"}
{"name":"Submodule.mem_mul_span_singleton","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nP : Submodule R A\nx y : A\n⊢ Iff (Membership.mem (HMul.hMul P (Submodule.span R (Singleton.singleton y))) x) (Exists fun z => And (Membership.mem P z) (Eq (HMul.hMul z y) x))","decl":"theorem mem_mul_span_singleton {x y : A} : x ∈ P * span R {y} ↔ ∃ z ∈ P, z * y = x := by\n  simp_rw [mul_eq_map₂, (· * ·), map₂_span_singleton_eq_map_flip]\n  rfl\n\n"}
{"name":"Submodule.span_singleton_mul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\np : Submodule R A\n⊢ Eq (HMul.hMul (Submodule.span R (Singleton.singleton x)) p) (HSMul.hSMul x p)","decl":"lemma span_singleton_mul {x : A} {p : Submodule R A} :\n    Submodule.span R {x} * p = x • p := ext fun _ ↦ mem_span_singleton_mul\n\n"}
{"name":"Submodule.mem_smul_iff_inv_mul_mem","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Type u_1\ninst✝¹ : Field S\ninst✝ : Algebra R S\nx : S\np : Submodule R S\ny : S\nhx : Ne x 0\n⊢ Iff (Membership.mem (HSMul.hSMul x p) y) (Membership.mem p (HMul.hMul (Inv.inv x) y))","decl":"lemma mem_smul_iff_inv_mul_mem {S} [Field S] [Algebra R S] {x : S} {p : Submodule R S} {y : S}\n    (hx : x ≠ 0) : y ∈ x • p ↔ x⁻¹ * y ∈ p := by\n  constructor\n  · rintro ⟨a, ha : a ∈ p, rfl⟩; simpa [inv_mul_cancel_left₀ hx]\n  · exact fun h ↦ ⟨_, h, by simp [mul_inv_cancel_left₀ hx]⟩\n\n"}
{"name":"Submodule.mul_mem_smul_iff","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Type u_1\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\np : Submodule R S\ny : S\nhx : Membership.mem (nonZeroDivisors S) x\n⊢ Iff (Membership.mem (HSMul.hSMul x p) (HMul.hMul x y)) (Membership.mem p y)","decl":"lemma mul_mem_smul_iff {S} [CommRing S] [Algebra R S] {x : S} {p : Submodule R S} {y : S}\n    (hx : x ∈ nonZeroDivisors S) :\n    x * y ∈ x • p ↔ y ∈ p :=\n  show Exists _ ↔ _ by simp [mul_cancel_left_mem_nonZeroDivisors hx]\n\n"}
{"name":"Submodule.mul_smul_mul_eq_smul_mul_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM N : Submodule R A\nx y : R\n⊢ Eq (HSMul.hSMul (HMul.hMul x y) (HMul.hMul M N)) (HMul.hMul (HSMul.hSMul x M) (HSMul.hSMul y N))","decl":"variable (M N) in\ntheorem mul_smul_mul_eq_smul_mul_smul (x y : R) : (x * y) • (M * N) = (x • M) * (y • N) := by\n  ext\n  refine ⟨?_, fun hx ↦ Submodule.mul_induction_on hx ?_ fun _ _ hx hy ↦ Submodule.add_mem _ hx hy⟩\n  · rintro ⟨_, hx, rfl⟩\n    rw [DistribMulAction.toLinearMap_apply]\n    refine Submodule.mul_induction_on hx (fun m hm n hn ↦ ?_) (fun _ _ hn hm ↦ ?_)\n    · rw [mul_smul_mul_comm]\n      exact mul_mem_mul (smul_mem_pointwise_smul m x M hm) (smul_mem_pointwise_smul n y N hn)\n    · rw [smul_add]\n      exact Submodule.add_mem _ hn hm\n  · rintro _ ⟨m, hm, rfl⟩ _ ⟨n, hn, rfl⟩\n    simp_rw [DistribMulAction.toLinearMap_apply, smul_mul_smul_comm]\n    exact smul_mem_pointwise_smul _ _ _ (mul_mem_mul hm hn)\n\n"}
{"name":"Submodule.span_pow","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : Set A\nn : Nat\n⊢ Eq (HPow.hPow (Submodule.span R s) n) (Submodule.span R (HPow.hPow s n))","decl":"theorem span_pow (s : Set A) : ∀ n : ℕ, span R s ^ n = span R (s ^ n)\n  | 0 => by rw [pow_zero, pow_zero, one_eq_span_one_set]\n  | n + 1 => by rw [pow_succ, pow_succ, span_pow s n, span_mul_span]\n\n"}
{"name":"Submodule.pow_eq_span_pow_set","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM : Submodule R A\nn : Nat\n⊢ Eq (HPow.hPow M n) (Submodule.span R (HPow.hPow (↑M) n))","decl":"theorem pow_eq_span_pow_set (n : ℕ) : M ^ n = span R ((M : Set A) ^ n) := by\n  rw [← span_pow, span_eq]\n\n"}
{"name":"Submodule.pow_induction_on_left'","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM : Submodule R A\nC : (n : Nat) → (x : A) → Membership.mem (HPow.hPow M n) x → Prop\nalgebraMap : ∀ (r : R), C 0 ((_root_.algebraMap R A) r) ⋯\nadd : ∀ (x y : A) (i : Nat) (hx : Membership.mem (HPow.hPow M i) x) (hy : Membership.mem (HPow.hPow M i) y), C i x hx → C i y hy → C i (HAdd.hAdd x y) ⋯\nmem_mul : ∀ (m : A) (hm : Membership.mem M m) (i : Nat) (x : A) (hx : Membership.mem (HPow.hPow M i) x), C i x hx → C i.succ (HMul.hMul m x) ⋯\nn : Nat\nx : A\nhx : Membership.mem (HPow.hPow M n) x\n⊢ C n x hx","decl":"/-- Dependent version of `Submodule.pow_induction_on_left`. -/\n@[elab_as_elim]\nprotected theorem pow_induction_on_left' {C : ∀ (n : ℕ) (x), x ∈ M ^ n → Prop}\n    (algebraMap : ∀ r : R, C 0 (algebraMap _ _ r) (algebraMap_mem r))\n    (add : ∀ x y i hx hy, C i x hx → C i y hy → C i (x + y) (add_mem ‹_› ‹_›))\n    (mem_mul : ∀ m (hm : m ∈ M), ∀ (i x hx), C i x hx → C i.succ (m * x)\n      ((pow_succ' M i).symm ▸ (mul_mem_mul hm hx)))\n    -- Porting note: swapped argument order to match order of `C`\n    {n : ℕ} {x : A}\n    (hx : x ∈ M ^ n) : C n x hx := by\n  induction n generalizing x with\n  | zero =>\n    rw [pow_zero] at hx\n    obtain ⟨r, rfl⟩ := mem_one.mp hx\n    exact algebraMap r\n  | succ n n_ih =>\n    revert hx\n    simp_rw [pow_succ']\n    exact fun hx ↦ Submodule.mul_induction_on' (fun m hm x ih => mem_mul _ hm _ _ _ (n_ih ih))\n      (fun x hx y hy Cx Cy => add _ _ _ _ _ Cx Cy) hx\n\n"}
{"name":"Submodule.pow_induction_on_right'","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM : Submodule R A\nC : (n : Nat) → (x : A) → Membership.mem (HPow.hPow M n) x → Prop\nalgebraMap : ∀ (r : R), C 0 ((_root_.algebraMap R A) r) ⋯\nadd : ∀ (x y : A) (i : Nat) (hx : Membership.mem (HPow.hPow M i) x) (hy : Membership.mem (HPow.hPow M i) y), C i x hx → C i y hy → C i (HAdd.hAdd x y) ⋯\nmul_mem : ∀ (i : Nat) (x : A) (hx : Membership.mem (HPow.hPow M i) x), C i x hx → ∀ (m : A) (hm : Membership.mem M m), C i.succ (HMul.hMul x m) ⋯\nn : Nat\nx : A\nhx : Membership.mem (HPow.hPow M n) x\n⊢ C n x hx","decl":"/-- Dependent version of `Submodule.pow_induction_on_right`. -/\n@[elab_as_elim]\nprotected theorem pow_induction_on_right' {C : ∀ (n : ℕ) (x), x ∈ M ^ n → Prop}\n    (algebraMap : ∀ r : R, C 0 (algebraMap _ _ r) (algebraMap_mem r))\n    (add : ∀ x y i hx hy, C i x hx → C i y hy → C i (x + y) (add_mem ‹_› ‹_›))\n    (mul_mem :\n      ∀ i x hx, C i x hx →\n        ∀ m (hm : m ∈ M), C i.succ (x * m) (mul_mem_mul hx hm))\n    -- Porting note: swapped argument order to match order of `C`\n    {n : ℕ} {x : A} (hx : x ∈ M ^ n) : C n x hx := by\n  induction n generalizing x with\n  | zero =>\n    rw [pow_zero] at hx\n    obtain ⟨r, rfl⟩ := mem_one.mp hx\n    exact algebraMap r\n  | succ n n_ih =>\n    revert hx\n    simp_rw [pow_succ]\n    exact fun hx ↦ Submodule.mul_induction_on' (fun m hm x ih => mul_mem _ _ hm (n_ih _) _ ih)\n      (fun x hx y hy Cx Cy => add _ _ _ _ _ Cx Cy) hx\n\n"}
{"name":"Submodule.pow_induction_on_left","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM : Submodule R A\nC : A → Prop\nhr : ∀ (r : R), C ((algebraMap R A) r)\nhadd : ∀ (x y : A), C x → C y → C (HAdd.hAdd x y)\nhmul : ∀ (m : A), Membership.mem M m → ∀ (x : A), C x → C (HMul.hMul m x)\nx : A\nn : Nat\nhx : Membership.mem (HPow.hPow M n) x\n⊢ C x","decl":"/-- To show a property on elements of `M ^ n` holds, it suffices to show that it holds for scalars,\nis closed under addition, and holds for `m * x` where `m ∈ M` and it holds for `x` -/\n@[elab_as_elim]\nprotected theorem pow_induction_on_left {C : A → Prop} (hr : ∀ r : R, C (algebraMap _ _ r))\n    (hadd : ∀ x y, C x → C y → C (x + y)) (hmul : ∀ m ∈ M, ∀ (x), C x → C (m * x)) {x : A} {n : ℕ}\n    (hx : x ∈ M ^ n) : C x :=\n  -- Porting note: `M` is explicit yet can't be passed positionally!\n  Submodule.pow_induction_on_left' (M := M) (C := fun _ a _ => C a) hr\n    (fun x y _i _hx _hy => hadd x y)\n    (fun _m hm _i _x _hx => hmul _ hm _) hx\n\n"}
{"name":"Submodule.pow_induction_on_right","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM : Submodule R A\nC : A → Prop\nhr : ∀ (r : R), C ((algebraMap R A) r)\nhadd : ∀ (x y : A), C x → C y → C (HAdd.hAdd x y)\nhmul : ∀ (x : A), C x → ∀ (m : A), Membership.mem M m → C (HMul.hMul x m)\nx : A\nn : Nat\nhx : Membership.mem (HPow.hPow M n) x\n⊢ C x","decl":"/-- To show a property on elements of `M ^ n` holds, it suffices to show that it holds for scalars,\nis closed under addition, and holds for `x * m` where `m ∈ M` and it holds for `x` -/\n@[elab_as_elim]\nprotected theorem pow_induction_on_right {C : A → Prop} (hr : ∀ r : R, C (algebraMap _ _ r))\n    (hadd : ∀ x y, C x → C y → C (x + y)) (hmul : ∀ x, C x → ∀ m ∈ M, C (x * m)) {x : A} {n : ℕ}\n    (hx : x ∈ M ^ n) : C x :=\n  Submodule.pow_induction_on_right' (M := M) (C := fun _ a _ => C a) hr\n    (fun x y _i _hx _hy => hadd x y)\n    (fun _i _x _hx => hmul _) hx\n\n"}
{"name":"Submodule.mapHom_apply","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nA' : Type u_1\ninst✝¹ : Semiring A'\ninst✝ : Algebra R A'\nf : AlgHom R A A'\np : Submodule R A\n⊢ Eq ((Submodule.mapHom f) p) (Submodule.map f.toLinearMap p)","decl":"/-- `Submonoid.map` as a `RingHom`, when applied to an `AlgHom`. -/\n@[simps]\ndef mapHom {A'} [Semiring A'] [Algebra R A'] (f : A →ₐ[R] A') :\n    Submodule R A →+* Submodule R A' where\n  toFun := map f.toLinearMap\n  map_zero' := Submodule.map_bot _\n  map_add' := (Submodule.map_sup · · _)\n  map_one' := Submodule.map_one _\n  map_mul' := (Submodule.map_mul · · _)\n\n"}
{"name":"Submodule.mapHom_id","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Submodule.mapHom (AlgHom.id R A)) (RingHom.id (Submodule R A))","decl":"theorem mapHom_id : mapHom (.id R A) = .id _ := RingHom.ext map_id\n\n"}
{"name":"Submodule.equivOpposite_symm_apply","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np : MulOpposite (Submodule R A)\n⊢ Eq (Submodule.equivOpposite.symm p) (Submodule.comap (↑(MulOpposite.opLinearEquiv R).symm) (MulOpposite.unop p))","decl":"/-- The ring of submodules of the opposite algebra is isomorphic to the opposite ring of\nsubmodules. -/\n@[simps apply symm_apply]\ndef equivOpposite : Submodule R Aᵐᵒᵖ ≃+* (Submodule R A)ᵐᵒᵖ where\n  toFun p := op <| p.comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ)\n  invFun p := p.unop.comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A)\n  left_inv _ := SetLike.coe_injective <| rfl\n  right_inv _ := unop_injective <| SetLike.coe_injective rfl\n  map_add' p q := by simp [comap_equiv_eq_map_symm, ← op_add]\n  map_mul' _ _ := congr_arg op <| comap_op_mul _ _\n\n"}
{"name":"Submodule.equivOpposite_apply","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np : Submodule R (MulOpposite A)\n⊢ Eq (Submodule.equivOpposite p) (MulOpposite.op (Submodule.comap (↑(MulOpposite.opLinearEquiv R)) p))","decl":"/-- The ring of submodules of the opposite algebra is isomorphic to the opposite ring of\nsubmodules. -/\n@[simps apply symm_apply]\ndef equivOpposite : Submodule R Aᵐᵒᵖ ≃+* (Submodule R A)ᵐᵒᵖ where\n  toFun p := op <| p.comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ)\n  invFun p := p.unop.comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A)\n  left_inv _ := SetLike.coe_injective <| rfl\n  right_inv _ := unop_injective <| SetLike.coe_injective rfl\n  map_add' p q := by simp [comap_equiv_eq_map_symm, ← op_add]\n  map_mul' _ _ := congr_arg op <| comap_op_mul _ _\n\n"}
{"name":"Submodule.map_pow","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nM : Submodule R A\nA' : Type u_1\ninst✝¹ : Semiring A'\ninst✝ : Algebra R A'\nf : AlgHom R A A'\nn : Nat\n⊢ Eq (Submodule.map f.toLinearMap (HPow.hPow M n)) (HPow.hPow (Submodule.map f.toLinearMap M) n)","decl":"protected theorem map_pow {A'} [Semiring A'] [Algebra R A'] (f : A →ₐ[R] A') (n : ℕ) :\n    map f.toLinearMap (M ^ n) = map f.toLinearMap M ^ n :=\n  map_pow (mapHom f) M n\n\n"}
{"name":"Submodule.comap_unop_pow","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM : Submodule R A\nn : Nat\n⊢ Eq (Submodule.comap (↑(MulOpposite.opLinearEquiv R).symm) (HPow.hPow M n)) (HPow.hPow (Submodule.comap (↑(MulOpposite.opLinearEquiv R).symm) M) n)","decl":"theorem comap_unop_pow (n : ℕ) :\n    comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) (M ^ n) =\n      comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) M ^ n :=\n  (equivOpposite : Submodule R Aᵐᵒᵖ ≃+* _).symm.map_pow (op M) n\n\n"}
{"name":"Submodule.comap_op_pow","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nn : Nat\nM : Submodule R (MulOpposite A)\n⊢ Eq (Submodule.comap (↑(MulOpposite.opLinearEquiv R)) (HPow.hPow M n)) (HPow.hPow (Submodule.comap (↑(MulOpposite.opLinearEquiv R)) M) n)","decl":"theorem comap_op_pow (n : ℕ) (M : Submodule R Aᵐᵒᵖ) :\n    comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) (M ^ n) =\n      comap (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) M ^ n :=\n  op_injective <| (equivOpposite : Submodule R Aᵐᵒᵖ ≃+* _).map_pow M n\n\n"}
{"name":"Submodule.map_op_pow","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nM : Submodule R A\nn : Nat\n⊢ Eq (Submodule.map (↑(MulOpposite.opLinearEquiv R)) (HPow.hPow M n)) (HPow.hPow (Submodule.map (↑(MulOpposite.opLinearEquiv R)) M) n)","decl":"theorem map_op_pow (n : ℕ) :\n    map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) (M ^ n) =\n      map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) M ^ n := by\n  rw [map_equiv_eq_comap_symm, map_equiv_eq_comap_symm, comap_unop_pow]\n\n"}
{"name":"Submodule.map_unop_pow","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nn : Nat\nM : Submodule R (MulOpposite A)\n⊢ Eq (Submodule.map (↑(MulOpposite.opLinearEquiv R).symm) (HPow.hPow M n)) (HPow.hPow (Submodule.map (↑(MulOpposite.opLinearEquiv R).symm) M) n)","decl":"theorem map_unop_pow (n : ℕ) (M : Submodule R Aᵐᵒᵖ) :\n    map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) (M ^ n) =\n      map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ).symm : Aᵐᵒᵖ →ₗ[R] A) M ^ n := by\n  rw [← comap_equiv_eq_map_symm, ← comap_equiv_eq_map_symm, comap_op_pow]\n\n"}
{"name":"Submodule.span.ringHom_apply","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ns : SetSemiring A\n⊢ Eq (Submodule.span.ringHom s) (Submodule.span R (SetSemiring.down s))","decl":"/-- `span` is a semiring homomorphism (recall multiplication is pointwise multiplication of subsets\non either side). -/\n@[simps]\ndef span.ringHom : SetSemiring A →+* Submodule R A where\n  toFun s := Submodule.span R (SetSemiring.down s)\n  map_zero' := span_empty\n  map_one' := one_eq_span.symm\n  map_add' := span_union\n  map_mul' s t := by simp_rw [SetSemiring.down_mul, span_mul_span]\n\n"}
{"name":"Submodule.mul_mem_mul_rev","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nM N : Submodule R A\nm n : A\nhm : Membership.mem M m\nhn : Membership.mem N n\n⊢ Membership.mem (HMul.hMul M N) (HMul.hMul n m)","decl":"theorem mul_mem_mul_rev (hm : m ∈ M) (hn : n ∈ N) : n * m ∈ M * N :=\n  mul_comm m n ▸ mul_mem_mul hm hn\n\n"}
{"name":"Submodule.mul_comm","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nM N : Submodule R A\n⊢ Eq (HMul.hMul M N) (HMul.hMul N M)","decl":"protected theorem mul_comm : M * N = N * M :=\n  le_antisymm (mul_le.2 fun _r hrm _s hsn => mul_mem_mul_rev hsn hrm)\n    (mul_le.2 fun _r hrn _s hsm => mul_mem_mul_rev hsm hrn)\n\n"}
{"name":"Submodule.prod_span","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nι : Type u_1\ns : Finset ι\nM : ι → Set A\n⊢ Eq (s.prod fun i => Submodule.span R (M i)) (Submodule.span R (s.prod fun i => M i))","decl":"theorem prod_span {ι : Type*} (s : Finset ι) (M : ι → Set A) :\n    (∏ i ∈ s, Submodule.span R (M i)) = Submodule.span R (∏ i ∈ s, M i) := by\n  letI := Classical.decEq ι\n  refine Finset.induction_on s ?_ ?_\n  · simp [one_eq_span, Set.singleton_one]\n  · intro _ _ H ih\n    rw [Finset.prod_insert H, Finset.prod_insert H, ih, span_mul_span]\n\n"}
{"name":"Submodule.prod_span_singleton","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nι : Type u_1\ns : Finset ι\nx : ι → A\n⊢ Eq (s.prod fun i => Submodule.span R (Singleton.singleton (x i))) (Submodule.span R (Singleton.singleton (s.prod fun i => x i)))","decl":"theorem prod_span_singleton {ι : Type*} (s : Finset ι) (x : ι → A) :\n    (∏ i ∈ s, span R ({x i} : Set A)) = span R {∏ i ∈ s, x i} := by\n  rw [prod_span, Set.finset_prod_singleton]\n\n"}
{"name":"Submodule.setSemiring_smul_def","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\ns : SetSemiring A\nP : Submodule R A\n⊢ Eq (HSMul.hSMul s P) (HMul.hMul (Submodule.span R (SetSemiring.down s)) P)","decl":"theorem setSemiring_smul_def (s : SetSemiring A) (P : Submodule R A) :\n    s • P = span R (SetSemiring.down (α := A) s) * P :=\n  rfl\n\n"}
{"name":"Submodule.smul_le_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\ns t : SetSemiring A\nM N : Submodule R A\nh₁ : HasSubset.Subset (SetSemiring.down s) (SetSemiring.down t)\nh₂ : LE.le M N\n⊢ LE.le (HSMul.hSMul s M) (HSMul.hSMul t N)","decl":"theorem smul_le_smul {s t : SetSemiring A} {M N : Submodule R A}\n    (h₁ : SetSemiring.down (α := A) s ⊆ SetSemiring.down (α := A) t)\n    (h₂ : M ≤ N) : s • M ≤ t • N :=\n  mul_le_mul (span_mono h₁) h₂\n\n"}
{"name":"Submodule.singleton_smul","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\na : A\nM : Submodule R A\n⊢ Eq (HSMul.hSMul (Set.up (Singleton.singleton a)) M) (Submodule.map (LinearMap.mulLeft R a) M)","decl":"theorem singleton_smul (a : A) (M : Submodule R A) :\n    Set.up ({a} : Set A) • M = M.map (LinearMap.mulLeft R a) := by\n  conv_lhs => rw [← span_eq M]\n  rw [setSemiring_smul_def, SetSemiring.down_up, span_mul_span, singleton_mul]\n  exact (map (LinearMap.mulLeft R a) M).span_eq\n\n"}
{"name":"Submodule.mem_div_iff_forall_mul_mem","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nx : A\nI J : Submodule R A\n⊢ Iff (Membership.mem (HDiv.hDiv I J) x) (∀ (y : A), Membership.mem J y → Membership.mem I (HMul.hMul x y))","decl":"theorem mem_div_iff_forall_mul_mem {x : A} {I J : Submodule R A} : x ∈ I / J ↔ ∀ y ∈ J, x * y ∈ I :=\n  Iff.refl _\n\n"}
{"name":"Submodule.mem_div_iff_smul_subset","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nx : A\nI J : Submodule R A\n⊢ Iff (Membership.mem (HDiv.hDiv I J) x) (HasSubset.Subset (HSMul.hSMul x ↑J) ↑I)","decl":"theorem mem_div_iff_smul_subset {x : A} {I J : Submodule R A} : x ∈ I / J ↔ x • (J : Set A) ⊆ I :=\n  ⟨fun h y ⟨y', hy', xy'_eq_y⟩ => by\n    rw [← xy'_eq_y]\n    apply h\n    assumption, fun h _ hy => h (Set.smul_mem_smul_set hy)⟩\n\n"}
{"name":"Submodule.le_div_iff","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nI J K : Submodule R A\n⊢ Iff (LE.le I (HDiv.hDiv J K)) (∀ (x : A), Membership.mem I x → ∀ (z : A), Membership.mem K z → Membership.mem J (HMul.hMul x z))","decl":"theorem le_div_iff {I J K : Submodule R A} : I ≤ J / K ↔ ∀ x ∈ I, ∀ z ∈ K, x * z ∈ J :=\n  Iff.refl _\n\n"}
{"name":"Submodule.le_div_iff_mul_le","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nI J K : Submodule R A\n⊢ Iff (LE.le I (HDiv.hDiv J K)) (LE.le (HMul.hMul I K) J)","decl":"theorem le_div_iff_mul_le {I J K : Submodule R A} : I ≤ J / K ↔ I * K ≤ J := by\n  rw [le_div_iff, mul_le]\n\n"}
{"name":"Submodule.one_le_one_div","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nI : Submodule R A\n⊢ Iff (LE.le 1 (HDiv.hDiv 1 I)) (LE.le I 1)","decl":"theorem one_le_one_div {I : Submodule R A} : 1 ≤ 1 / I ↔ I ≤ 1 := by\n  constructor; all_goals intro hI\n  · rwa [le_div_iff_mul_le, one_mul] at hI\n  · rwa [le_div_iff_mul_le, one_mul]\n\n"}
{"name":"Submodule.one_mem_div","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nI J : Submodule R A\n⊢ Iff (Membership.mem (HDiv.hDiv I J) 1) (LE.le J I)","decl":"@[simp]\ntheorem one_mem_div {I J : Submodule R A} : 1 ∈ I / J ↔ J ≤ I := by\n  rw [← one_le, le_div_iff_mul_le, one_mul]\n\n"}
{"name":"Submodule.le_self_mul_one_div","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nI : Submodule R A\nhI : LE.le I 1\n⊢ LE.le I (HMul.hMul I (HDiv.hDiv 1 I))","decl":"theorem le_self_mul_one_div {I : Submodule R A} (hI : I ≤ 1) : I ≤ I * (1 / I) := by\n  refine (mul_one I).symm.trans_le ?_  -- Porting note: drop `rw {occs := _}` in favor of `refine`\n  apply mul_le_mul_right (one_le_one_div.mpr hI)\n\n"}
{"name":"Submodule.mul_one_div_le_one","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nI : Submodule R A\n⊢ LE.le (HMul.hMul I (HDiv.hDiv 1 I)) 1","decl":"theorem mul_one_div_le_one {I : Submodule R A} : I * (1 / I) ≤ 1 := by\n  rw [Submodule.mul_le]\n  intro m hm n hn\n  rw [Submodule.mem_div_iff_forall_mul_mem] at hn\n  rw [mul_comm]\n  exact hn m hm\n\n"}
{"name":"Submodule.map_div","module":"Mathlib.Algebra.Algebra.Operations","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : CommSemiring A\ninst✝² : Algebra R A\nB : Type u_1\ninst✝¹ : CommSemiring B\ninst✝ : Algebra R B\nI J : Submodule R A\nh : AlgEquiv R A B\n⊢ Eq (Submodule.map h.toLinearMap (HDiv.hDiv I J)) (HDiv.hDiv (Submodule.map h.toLinearMap I) (Submodule.map h.toLinearMap J))","decl":"@[simp]\nprotected theorem map_div {B : Type*} [CommSemiring B] [Algebra R B] (I J : Submodule R A)\n    (h : A ≃ₐ[R] B) : (I / J).map h.toLinearMap = I.map h.toLinearMap / J.map h.toLinearMap := by\n  ext x\n  simp only [mem_map, mem_div_iff_forall_mul_mem]\n  constructor\n  · rintro ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩\n    exact ⟨x * y, hx _ hy, map_mul h x y⟩\n  · rintro hx\n    refine ⟨h.symm x, fun z hz => ?_, h.apply_symm_apply x⟩\n    obtain ⟨xz, xz_mem, hxz⟩ := hx (h z) ⟨z, hz, rfl⟩\n    convert xz_mem\n    apply h.injective\n    rw [map_mul, h.apply_symm_apply]\n    simp only [AlgEquiv.toLinearMap_apply] at hxz\n    rw [hxz]\n\n"}
