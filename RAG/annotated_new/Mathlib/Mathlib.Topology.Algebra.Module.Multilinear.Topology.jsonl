{"name":"ContinuousMultilinearMap.range_toUniformOnFun","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : TopologicalSpace F\nâŠ¢ Eq (Set.range ContinuousMultilinearMap.toUniformOnFun) (setOf fun f => And (Continuous ((UniformOnFun.toFun (setOf fun s => Bornology.IsVonNBounded ğ•œ s)) f)) (And (âˆ€ (m : (i : Î¹) â†’ E i) (i : Î¹) (x y : E i), Eq ((UniformOnFun.toFun (setOf fun s => Bornology.IsVonNBounded ğ•œ s)) f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd ((UniformOnFun.toFun (setOf fun s => Bornology.IsVonNBounded ğ•œ s)) f (Function.update m i x)) ((UniformOnFun.toFun (setOf fun s => Bornology.IsVonNBounded ğ•œ s)) f (Function.update m i y)))) (âˆ€ (m : (i : Î¹) â†’ E i) (i : Î¹) (c : ğ•œ) (x : E i), Eq ((UniformOnFun.toFun (setOf fun s => Bornology.IsVonNBounded ğ•œ s)) f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c ((UniformOnFun.toFun (setOf fun s => Bornology.IsVonNBounded ğ•œ s)) f (Function.update m i x))))))","decl":"open UniformOnFun in\nlemma range_toUniformOnFun [DecidableEq Î¹] [TopologicalSpace F] :\n    range toUniformOnFun =\n      {f : (Î  i, E i) â†’áµ¤[{s | IsVonNBounded ğ•œ s}] F |\n        Continuous (toFun _ f) âˆ§\n        (âˆ€ (m : Î  i, E i) i x y,\n          toFun _ f (update m i (x + y)) = toFun _ f (update m i x) + toFun _ f (update m i y)) âˆ§\n        (âˆ€ (m : Î  i, E i) i (c : ğ•œ) x,\n          toFun _ f (update m i (c â€¢ x)) = c â€¢ toFun _ f (update m i x))} := by\n  ext f\n  constructor\n  Â· rintro âŸ¨f, rflâŸ©\n    exact âŸ¨f.cont, f.map_update_add, f.map_update_smulâŸ©\n  Â· rintro âŸ¨hcont, hadd, hsmulâŸ©\n    exact âŸ¨âŸ¨âŸ¨f, by intro; convert hadd, by intro; convert hsmulâŸ©, hcontâŸ©, rflâŸ©\n\n"}
{"name":"ContinuousMultilinearMap.toUniformOnFun_toFun","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ´ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ³ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ² : AddCommGroup F\ninstâœÂ¹ : Module ğ•œ F\ninstâœ : TopologicalSpace F\nf : ContinuousMultilinearMap ğ•œ E F\nâŠ¢ Eq ((UniformOnFun.toFun (setOf fun s => Bornology.IsVonNBounded ğ•œ s)) f.toUniformOnFun) â‡‘f","decl":"@[simp]\nlemma toUniformOnFun_toFun [TopologicalSpace F] (f : ContinuousMultilinearMap ğ•œ E F) :\n    UniformOnFun.toFun _ f.toUniformOnFun = f :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.isUniformInducing_toUniformOnFun","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nâŠ¢ IsUniformInducing ContinuousMultilinearMap.toUniformOnFun","decl":"lemma isUniformInducing_toUniformOnFun :\n    IsUniformInducing (toUniformOnFun :\n      ContinuousMultilinearMap ğ•œ E F â†’ ((Î  i, E i) â†’áµ¤[{s | IsVonNBounded ğ•œ s}] F)) := âŸ¨rflâŸ©\n\n"}
{"name":"ContinuousMultilinearMap.isUniformEmbedding_toUniformOnFun","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nâŠ¢ IsUniformEmbedding ContinuousMultilinearMap.toUniformOnFun","decl":"lemma isUniformEmbedding_toUniformOnFun :\n    IsUniformEmbedding (toUniformOnFun : ContinuousMultilinearMap ğ•œ E F â†’ _) :=\n  âŸ¨isUniformInducing_toUniformOnFun, DFunLike.coe_injectiveâŸ©\n\n"}
{"name":"ContinuousMultilinearMap.uniformEmbedding_toUniformOnFun","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nâŠ¢ IsUniformEmbedding ContinuousMultilinearMap.toUniformOnFun","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_toUniformOnFun := isUniformEmbedding_toUniformOnFun\n\n"}
{"name":"ContinuousMultilinearMap.isEmbedding_toUniformOnFun","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nâŠ¢ Topology.IsEmbedding ContinuousMultilinearMap.toUniformOnFun","decl":"lemma isEmbedding_toUniformOnFun :\n    IsEmbedding (toUniformOnFun : ContinuousMultilinearMap ğ•œ E F â†’\n      ((Î  i, E i) â†’áµ¤[{s | IsVonNBounded ğ•œ s}] F)) :=\n  isUniformEmbedding_toUniformOnFun.isEmbedding\n\n"}
{"name":"ContinuousMultilinearMap.embedding_toUniformOnFun","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nâŠ¢ Topology.IsEmbedding ContinuousMultilinearMap.toUniformOnFun","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_toUniformOnFun := isEmbedding_toUniformOnFun\n\n"}
{"name":"ContinuousMultilinearMap.uniformContinuous_coe_fun","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œ F\ninstâœÂ² : UniformSpace F\ninstâœÂ¹ : UniformAddGroup F\ninstâœ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nâŠ¢ UniformContinuous DFunLike.coe","decl":"theorem uniformContinuous_coe_fun [âˆ€ i, ContinuousSMul ğ•œ (E i)] :\n    UniformContinuous (DFunLike.coe : ContinuousMultilinearMap ğ•œ E F â†’ (Î  i, E i) â†’ F) :=\n  (UniformOnFun.uniformContinuous_toFun isVonNBounded_covers).comp\n    isUniformEmbedding_toUniformOnFun.uniformContinuous\n\n"}
{"name":"ContinuousMultilinearMap.uniformContinuous_eval_const","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œ F\ninstâœÂ² : UniformSpace F\ninstâœÂ¹ : UniformAddGroup F\ninstâœ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nx : (i : Î¹) â†’ E i\nâŠ¢ UniformContinuous fun f => f x","decl":"theorem uniformContinuous_eval_const [âˆ€ i, ContinuousSMul ğ•œ (E i)] (x : Î  i, E i) :\n    UniformContinuous fun f : ContinuousMultilinearMap ğ•œ E F â†¦ f x :=\n  uniformContinuous_pi.1 uniformContinuous_coe_fun x\n\n"}
{"name":"ContinuousMultilinearMap.instUniformAddGroup","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : UniformSpace F\ninstâœ : UniformAddGroup F\nâŠ¢ UniformAddGroup (ContinuousMultilinearMap ğ•œ E F)","decl":"instance instUniformAddGroup : UniformAddGroup (ContinuousMultilinearMap ğ•œ E F) :=\n  let Ï† : ContinuousMultilinearMap ğ•œ E F â†’+ (Î  i, E i) â†’áµ¤[{s | IsVonNBounded ğ•œ s}] F :=\n    { toFun := toUniformOnFun, map_add' := fun _ _ â†¦ rfl, map_zero' := rfl }\n  isUniformEmbedding_toUniformOnFun.uniformAddGroup Ï†\n\n"}
{"name":"ContinuousMultilinearMap.instUniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹Â¹ : NormedField ğ•œ\ninstâœÂ¹â° : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ¹ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ¸ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : UniformSpace F\ninstâœâ´ : UniformAddGroup F\nM : Type u_5\ninstâœÂ³ : Monoid M\ninstâœÂ² : DistribMulAction M F\ninstâœÂ¹ : SMulCommClass ğ•œ M F\ninstâœ : ContinuousConstSMul M F\nâŠ¢ UniformContinuousConstSMul M (ContinuousMultilinearMap ğ•œ E F)","decl":"instance instUniformContinuousConstSMul {M : Type*}\n    [Monoid M] [DistribMulAction M F] [SMulCommClass ğ•œ M F] [ContinuousConstSMul M F] :\n    UniformContinuousConstSMul M (ContinuousMultilinearMap ğ•œ E F) :=\n  haveI := uniformContinuousConstSMul_of_continuousConstSMul M F\n  isUniformEmbedding_toUniformOnFun.uniformContinuousConstSMul fun _ _ â†¦ rfl\n\n"}
{"name":"ContinuousMultilinearMap.isUniformInducing_postcomp","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹Â¹ : NormedField ğ•œ\ninstâœÂ¹â° : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ¹ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ¸ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : UniformSpace F\ninstâœâ´ : UniformAddGroup F\nG : Type u_5\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : UniformSpace G\ninstâœÂ¹ : UniformAddGroup G\ninstâœ : Module ğ•œ G\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhg : IsUniformInducing â‡‘g\nâŠ¢ IsUniformInducing g.compContinuousMultilinearMap","decl":"theorem isUniformInducing_postcomp\n    {G : Type*} [AddCommGroup G] [UniformSpace G] [UniformAddGroup G] [Module ğ•œ G]\n    (g : F â†’L[ğ•œ] G) (hg : IsUniformInducing g) :\n    IsUniformInducing (g.compContinuousMultilinearMap :\n      ContinuousMultilinearMap ğ•œ E F â†’ ContinuousMultilinearMap ğ•œ E G) := by\n  rw [â† isUniformInducing_toUniformOnFun.of_comp_iff]\n  exact (UniformOnFun.postcomp_isUniformInducing hg).comp isUniformInducing_toUniformOnFun\n\n"}
{"name":"ContinuousMultilinearMap.completeSpace","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹â° : NormedField ğ•œ\ninstâœâ¹ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ¸ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ· : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module ğ•œ F\ninstâœâ´ : UniformSpace F\ninstâœÂ³ : UniformAddGroup F\ninstâœÂ² : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\ninstâœÂ¹ : ContinuousConstSMul ğ•œ F\ninstâœ : CompleteSpace F\nh : Topology.RestrictGenTopology (setOf fun s => Bornology.IsVonNBounded ğ•œ s)\nâŠ¢ CompleteSpace (ContinuousMultilinearMap ğ•œ E F)","decl":"open UniformOnFun in\ntheorem completeSpace (h : RestrictGenTopology {s : Set (Î  i, E i) | IsVonNBounded ğ•œ s}) :\n    CompleteSpace (ContinuousMultilinearMap ğ•œ E F) := by\n  classical\n  wlog hF : T2Space F generalizing F\n  Â· rw [(isUniformInducing_postcomp (SeparationQuotient.mkCLM _ _)\n      SeparationQuotient.isUniformInducing_mk).completeSpace_congr]\n    Â· exact this inferInstance\n    Â· intro f\n      use (SeparationQuotient.outCLM _ _).compContinuousMultilinearMap f\n      simp [DFunLike.ext_iff]\n  have H : âˆ€ {m : Î  i, E i},\n      Continuous fun f : (Î  i, E i) â†’áµ¤[{s | IsVonNBounded ğ•œ s}] F â†¦ toFun _ f m :=\n    (uniformContinuous_eval (isVonNBounded_covers) _).continuous\n  rw [completeSpace_iff_isComplete_range isUniformInducing_toUniformOnFun, range_toUniformOnFun]\n  simp only [setOf_and, setOf_forall]\n  apply_rules [IsClosed.isComplete, IsClosed.inter]\n  Â· exact UniformOnFun.isClosed_setOf_continuous h\n  Â· exact isClosed_iInter fun m â†¦ isClosed_iInter fun i â†¦\n      isClosed_iInter fun x â†¦ isClosed_iInter fun y â†¦ isClosed_eq H (H.add H)\n  Â· exact isClosed_iInter fun m â†¦ isClosed_iInter fun i â†¦\n      isClosed_iInter fun c â†¦ isClosed_iInter fun x â†¦ isClosed_eq H (H.const_smul _)\n\n"}
{"name":"ContinuousMultilinearMap.instCompleteSpace","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹Â² : NormedField ğ•œ\ninstâœÂ¹Â¹ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ¹â° : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ¹ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ F\ninstâœâ¶ : UniformSpace F\ninstâœâµ : UniformAddGroup F\ninstâœâ´ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\ninstâœÂ³ : ContinuousConstSMul ğ•œ F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : âˆ€ (i : Î¹), TopologicalAddGroup (E i)\ninstâœ : SequentialSpace ((i : Î¹) â†’ E i)\nâŠ¢ CompleteSpace (ContinuousMultilinearMap ğ•œ E F)","decl":"instance instCompleteSpace [âˆ€ i, TopologicalAddGroup (E i)] [SequentialSpace (Î  i, E i)] :\n    CompleteSpace (ContinuousMultilinearMap ğ•œ E F) :=\n  completeSpace <| .of_seq fun _u x hux â†¦ (hux.isVonNBounded_range ğ•œ).insert x\n\n"}
{"name":"ContinuousMultilinearMap.isUniformEmbedding_restrictScalars","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹â´ : NormedField ğ•œ\ninstâœÂ¹Â³ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ¹Â² : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ¹â° : AddCommGroup F\ninstâœâ¹ : Module ğ•œ F\ninstâœâ¸ : UniformSpace F\ninstâœâ· : UniformAddGroup F\nğ•œ' : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ'\ninstâœâµ : NormedAlgebra ğ•œ' ğ•œ\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ' (E i)\ninstâœÂ³ : âˆ€ (i : Î¹), IsScalarTower ğ•œ' ğ•œ (E i)\ninstâœÂ² : Module ğ•œ' F\ninstâœÂ¹ : IsScalarTower ğ•œ' ğ•œ F\ninstâœ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nâŠ¢ IsUniformEmbedding (ContinuousMultilinearMap.restrictScalars ğ•œ')","decl":"theorem isUniformEmbedding_restrictScalars :\n    IsUniformEmbedding\n      (restrictScalars ğ•œ' : ContinuousMultilinearMap ğ•œ E F â†’ ContinuousMultilinearMap ğ•œ' E F) := by\n  letI : NontriviallyNormedField ğ•œ :=\n    âŸ¨let âŸ¨x, hxâŸ© := @NontriviallyNormedField.non_trivial ğ•œ' _; âŸ¨algebraMap ğ•œ' ğ•œ x, by simpaâŸ©âŸ©\n  rw [â† isUniformEmbedding_toUniformOnFun.of_comp_iff]\n  convert isUniformEmbedding_toUniformOnFun using 4 with s\n  exact âŸ¨fun h â†¦ h.extend_scalars _, fun h â†¦ h.restrict_scalars _âŸ©\n\n"}
{"name":"ContinuousMultilinearMap.uniformEmbedding_restrictScalars","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹â´ : NormedField ğ•œ\ninstâœÂ¹Â³ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ¹Â² : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ¹â° : AddCommGroup F\ninstâœâ¹ : Module ğ•œ F\ninstâœâ¸ : UniformSpace F\ninstâœâ· : UniformAddGroup F\nğ•œ' : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ'\ninstâœâµ : NormedAlgebra ğ•œ' ğ•œ\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ' (E i)\ninstâœÂ³ : âˆ€ (i : Î¹), IsScalarTower ğ•œ' ğ•œ (E i)\ninstâœÂ² : Module ğ•œ' F\ninstâœÂ¹ : IsScalarTower ğ•œ' ğ•œ F\ninstâœ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nâŠ¢ IsUniformEmbedding (ContinuousMultilinearMap.restrictScalars ğ•œ')","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_restrictScalars := isUniformEmbedding_restrictScalars\n\n"}
{"name":"ContinuousMultilinearMap.uniformContinuous_restrictScalars","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹â´ : NormedField ğ•œ\ninstâœÂ¹Â³ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ¹Â² : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ¹â° : AddCommGroup F\ninstâœâ¹ : Module ğ•œ F\ninstâœâ¸ : UniformSpace F\ninstâœâ· : UniformAddGroup F\nğ•œ' : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ'\ninstâœâµ : NormedAlgebra ğ•œ' ğ•œ\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ' (E i)\ninstâœÂ³ : âˆ€ (i : Î¹), IsScalarTower ğ•œ' ğ•œ (E i)\ninstâœÂ² : Module ğ•œ' F\ninstâœÂ¹ : IsScalarTower ğ•œ' ğ•œ F\ninstâœ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nâŠ¢ UniformContinuous (ContinuousMultilinearMap.restrictScalars ğ•œ')","decl":"theorem uniformContinuous_restrictScalars :\n    UniformContinuous\n      (restrictScalars ğ•œ' : ContinuousMultilinearMap ğ•œ E F â†’ ContinuousMultilinearMap ğ•œ' E F) :=\n  (isUniformEmbedding_restrictScalars ğ•œ').uniformContinuous\n\n"}
{"name":"ContinuousMultilinearMap.instTopologicalAddGroup","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nâŠ¢ TopologicalAddGroup (ContinuousMultilinearMap ğ•œ E F)","decl":"instance instTopologicalAddGroup : TopologicalAddGroup (ContinuousMultilinearMap ğ•œ E F) :=\n  letI := TopologicalAddGroup.toUniformSpace F\n  haveI := comm_topologicalAddGroup_is_uniform (G := F)\n  inferInstance\n\n"}
{"name":"ContinuousMultilinearMap.instContinuousConstSMul","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹Â¹ : NormedField ğ•œ\ninstâœÂ¹â° : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ¹ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ¸ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : TopologicalAddGroup F\nM : Type u_5\ninstâœÂ³ : Monoid M\ninstâœÂ² : DistribMulAction M F\ninstâœÂ¹ : SMulCommClass ğ•œ M F\ninstâœ : ContinuousConstSMul M F\nâŠ¢ ContinuousConstSMul M (ContinuousMultilinearMap ğ•œ E F)","decl":"instance instContinuousConstSMul\n    {M : Type*} [Monoid M] [DistribMulAction M F] [SMulCommClass ğ•œ M F] [ContinuousConstSMul M F] :\n    ContinuousConstSMul M (ContinuousMultilinearMap ğ•œ E F) := by\n  letI := TopologicalAddGroup.toUniformSpace F\n  haveI := comm_topologicalAddGroup_is_uniform (G := F)\n  infer_instance\n\n"}
{"name":"ContinuousMultilinearMap.instContinuousSMul","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œ F\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : ContinuousSMul ğ•œ F\nâŠ¢ ContinuousSMul ğ•œ (ContinuousMultilinearMap ğ•œ E F)","decl":"instance instContinuousSMul [ContinuousSMul ğ•œ F] :\n    ContinuousSMul ğ•œ (ContinuousMultilinearMap ğ•œ E F) :=\n  letI := TopologicalAddGroup.toUniformSpace F\n  haveI := comm_topologicalAddGroup_is_uniform (G := F)\n  let Ï† : ContinuousMultilinearMap ğ•œ E F â†’â‚—[ğ•œ] (Î  i, E i) â†’ F :=\n    { toFun := (â†‘), map_add' := fun _ _ â†¦ rfl, map_smul' := fun _ _ â†¦ rfl }\n  UniformOnFun.continuousSMul_induced_of_image_bounded _ _ _ _ Ï†\n    isEmbedding_toUniformOnFun.isInducing fun _ _ hu â†¦ hu.image_multilinear _\n\n"}
{"name":"ContinuousMultilinearMap.hasBasis_nhds_zero_of_basis","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹âœ : Type u_2\nE : Î¹âœ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹âœ) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹âœ) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹âœ) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nÎ¹ : Type u_5\np : Î¹ â†’ Prop\nb : Î¹ â†’ Set F\nh : (nhds 0).HasBasis p b\nâŠ¢ (nhds 0).HasBasis (fun Si => And (Bornology.IsVonNBounded ğ•œ Si.1) (p Si.2)) fun Si => setOf fun f => Set.MapsTo (â‡‘f) Si.1 (b Si.2)","decl":"theorem hasBasis_nhds_zero_of_basis {Î¹ : Type*} {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set F}\n    (h : (ğ“ (0 : F)).HasBasis p b) :\n    (ğ“ (0 : ContinuousMultilinearMap ğ•œ E F)).HasBasis\n      (fun Si : Set (Î  i, E i) Ã— Î¹ => IsVonNBounded ğ•œ Si.1 âˆ§ p Si.2)\n      fun Si => { f | MapsTo f Si.1 (b Si.2) } := by\n  letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n  haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  rw [nhds_induced]\n  refine (UniformOnFun.hasBasis_nhds_zero_of_basis _ ?_ ?_ h).comap DFunLike.coe\n  Â· exact âŸ¨âˆ…, isVonNBounded_empty _ _âŸ©\n  Â· exact directedOn_of_sup_mem fun _ _ => Bornology.IsVonNBounded.union\n\n"}
{"name":"ContinuousMultilinearMap.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâµ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalAddGroup F\nâŠ¢ (nhds 0).HasBasis (fun SV => And (Bornology.IsVonNBounded ğ•œ SV.1) (Membership.mem (nhds 0) SV.2)) fun SV => setOf fun f => Set.MapsTo (â‡‘f) SV.1 SV.2","decl":"theorem hasBasis_nhds_zero :\n    (ğ“ (0 : ContinuousMultilinearMap ğ•œ E F)).HasBasis\n      (fun SV : Set (Î  i, E i) Ã— Set F => IsVonNBounded ğ•œ SV.1 âˆ§ SV.2 âˆˆ ğ“ 0) fun SV =>\n      { f | MapsTo f SV.1 SV.2 } :=\n  hasBasis_nhds_zero_of_basis (Filter.basis_sets _)\n\n"}
{"name":"ContinuousMultilinearMap.instContinuousEvalConstForall","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œ F\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nâŠ¢ ContinuousEvalConst (ContinuousMultilinearMap ğ•œ E F) ((i : Î¹) â†’ E i) F","decl":"instance : ContinuousEvalConst (ContinuousMultilinearMap ğ•œ E F) (Î  i, E i) F where\n  continuous_eval_const x :=\n    let _ := TopologicalAddGroup.toUniformSpace F\n    have _ := comm_topologicalAddGroup_is_uniform (G := F)\n    (uniformContinuous_eval_const x).continuous\n\n"}
{"name":"ContinuousMultilinearMap.continuous_eval_const","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"F : Type u_1\nÎ± : outParam (Type u_2)\nX : outParam (Type u_3)\ninstâœÂ² : FunLike F Î± X\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : TopologicalSpace X\nself : ContinuousEvalConst F Î± X\nx : Î±\nâŠ¢ Continuous fun f => f x","decl":"@[deprecated (since := \"2024-10-05\")] protected alias continuous_eval_const := continuous_eval_const\n"}
{"name":"ContinuousMultilinearMap.continuous_coe_fun","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"F : Type u_1\nÎ± : Type u_2\nX : Type u_3\ninstâœÂ³ : FunLike F Î± X\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : ContinuousEvalConst F Î± X\nâŠ¢ Continuous DFunLike.coe","decl":"@[deprecated (since := \"2024-10-05\")] protected alias continuous_coe_fun := continuous_coeFun\n\n"}
{"name":"ContinuousMultilinearMap.instT2Space","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¹ : NormedField ğ•œ\ninstâœâ¸ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ¶ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâµ : AddCommGroup F\ninstâœâ´ : Module ğ•œ F\ninstâœÂ³ : TopologicalSpace F\ninstâœÂ² : TopologicalAddGroup F\ninstâœÂ¹ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\ninstâœ : T2Space F\nâŠ¢ T2Space (ContinuousMultilinearMap ğ•œ E F)","decl":"instance instT2Space [T2Space F] : T2Space (ContinuousMultilinearMap ğ•œ E F) :=\n  .of_injective_continuous DFunLike.coe_injective continuous_coeFun\n\n"}
{"name":"ContinuousMultilinearMap.instT3Space","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¹ : NormedField ğ•œ\ninstâœâ¸ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ¶ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâµ : AddCommGroup F\ninstâœâ´ : Module ğ•œ F\ninstâœÂ³ : TopologicalSpace F\ninstâœÂ² : TopologicalAddGroup F\ninstâœÂ¹ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\ninstâœ : T2Space F\nâŠ¢ T3Space (ContinuousMultilinearMap ğ•œ E F)","decl":"instance instT3Space [T2Space F] : T3Space (ContinuousMultilinearMap ğ•œ E F) :=\n  inferInstance\n\n"}
{"name":"ContinuousMultilinearMap.isEmbedding_restrictScalars","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹â´ : NormedField ğ•œ\ninstâœÂ¹Â³ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ¹Â² : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ¹â° : AddCommGroup F\ninstâœâ¹ : Module ğ•œ F\ninstâœâ¸ : TopologicalSpace F\ninstâœâ· : TopologicalAddGroup F\ninstâœâ¶ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nğ•œ' : Type u_5\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : (i : Î¹) â†’ Module ğ•œ' (E i)\ninstâœÂ² : âˆ€ (i : Î¹), IsScalarTower ğ•œ' ğ•œ (E i)\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : IsScalarTower ğ•œ' ğ•œ F\nâŠ¢ Topology.IsEmbedding (ContinuousMultilinearMap.restrictScalars ğ•œ')","decl":"theorem isEmbedding_restrictScalars :\n    IsEmbedding\n      (restrictScalars ğ•œ' : ContinuousMultilinearMap ğ•œ E F â†’ ContinuousMultilinearMap ğ•œ' E F) :=\n  letI : UniformSpace F := TopologicalAddGroup.toUniformSpace F\n  haveI : UniformAddGroup F := comm_topologicalAddGroup_is_uniform\n  (isUniformEmbedding_restrictScalars _).isEmbedding\n\n"}
{"name":"ContinuousMultilinearMap.embedding_restrictScalars","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹â´ : NormedField ğ•œ\ninstâœÂ¹Â³ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ¹Â² : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ¹â° : AddCommGroup F\ninstâœâ¹ : Module ğ•œ F\ninstâœâ¸ : TopologicalSpace F\ninstâœâ· : TopologicalAddGroup F\ninstâœâ¶ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nğ•œ' : Type u_5\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : (i : Î¹) â†’ Module ğ•œ' (E i)\ninstâœÂ² : âˆ€ (i : Î¹), IsScalarTower ğ•œ' ğ•œ (E i)\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : IsScalarTower ğ•œ' ğ•œ F\nâŠ¢ Topology.IsEmbedding (ContinuousMultilinearMap.restrictScalars ğ•œ')","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_restrictScalars := isEmbedding_restrictScalars\n\n"}
{"name":"ContinuousMultilinearMap.continuous_restrictScalars","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹â´ : NormedField ğ•œ\ninstâœÂ¹Â³ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ¹Â² : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ¹â° : AddCommGroup F\ninstâœâ¹ : Module ğ•œ F\ninstâœâ¸ : TopologicalSpace F\ninstâœâ· : TopologicalAddGroup F\ninstâœâ¶ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nğ•œ' : Type u_5\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : (i : Î¹) â†’ Module ğ•œ' (E i)\ninstâœÂ² : âˆ€ (i : Î¹), IsScalarTower ğ•œ' ğ•œ (E i)\ninstâœÂ¹ : Module ğ•œ' F\ninstâœ : IsScalarTower ğ•œ' ğ•œ F\nâŠ¢ Continuous (ContinuousMultilinearMap.restrictScalars ğ•œ')","decl":"@[continuity, fun_prop]\ntheorem continuous_restrictScalars :\n    Continuous\n      (restrictScalars ğ•œ' : ContinuousMultilinearMap ğ•œ E F â†’ ContinuousMultilinearMap ğ•œ' E F) :=\n   isEmbedding_restrictScalars.continuous\n\n"}
{"name":"ContinuousMultilinearMap.restrictScalarsLinear_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœÂ¹â´ : NormedField ğ•œ\ninstâœÂ¹Â³ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ¹Â² : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœÂ¹Â¹ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœÂ¹â° : AddCommGroup F\ninstâœâ¹ : Module ğ•œ F\ninstâœâ¸ : TopologicalSpace F\ninstâœâ· : TopologicalAddGroup F\nğ•œ' : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ'\ninstâœâµ : NormedAlgebra ğ•œ' ğ•œ\ninstâœâ´ : (i : Î¹) â†’ Module ğ•œ' (E i)\ninstâœÂ³ : âˆ€ (i : Î¹), IsScalarTower ğ•œ' ğ•œ (E i)\ninstâœÂ² : Module ğ•œ' F\ninstâœÂ¹ : IsScalarTower ğ•œ' ğ•œ F\ninstâœ : ContinuousConstSMul ğ•œ' F\nâŠ¢ Eq (â‡‘(ContinuousMultilinearMap.restrictScalarsLinear ğ•œ')) (ContinuousMultilinearMap.restrictScalars ğ•œ')","decl":"variable (ğ•œ') in\n/-- `ContinuousMultilinearMap.restrictScalars` as a `ContinuousLinearMap`. -/\n@[simps (config := .asFn) apply]\ndef restrictScalarsLinear [ContinuousConstSMul ğ•œ' F] :\n    ContinuousMultilinearMap ğ•œ E F â†’L[ğ•œ'] ContinuousMultilinearMap ğ•œ' E F where\n  toFun := restrictScalars ğ•œ'\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"ContinuousMultilinearMap.apply_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¹ : NormedField ğ•œ\ninstâœâ¸ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ¶ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâµ : AddCommGroup F\ninstâœâ´ : Module ğ•œ F\ninstâœÂ³ : TopologicalSpace F\ninstâœÂ² : TopologicalAddGroup F\ninstâœÂ¹ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\ninstâœ : ContinuousConstSMul ğ•œ F\nm : (i : Î¹) â†’ E i\nc : ContinuousMultilinearMap ğ•œ E F\nâŠ¢ Eq ((ContinuousMultilinearMap.apply ğ•œ E F m) c) (c m)","decl":"@[simp]\nlemma apply_apply [ContinuousConstSMul ğ•œ F] {m : Î  i, E i} {c : ContinuousMultilinearMap ğ•œ E F} :\n    apply ğ•œ E F m c = c m := rfl\n\n"}
{"name":"ContinuousMultilinearMap.hasSum_eval","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¸ : NormedField ğ•œ\ninstâœâ· : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâ´ : AddCommGroup F\ninstâœÂ³ : Module ğ•œ F\ninstâœÂ² : TopologicalSpace F\ninstâœÂ¹ : TopologicalAddGroup F\ninstâœ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\nÎ± : Type u_5\np : Î± â†’ ContinuousMultilinearMap ğ•œ E F\nq : ContinuousMultilinearMap ğ•œ E F\nh : HasSum p q\nm : (i : Î¹) â†’ E i\nâŠ¢ HasSum (fun a => (p a) m) (q m)","decl":"theorem hasSum_eval {Î± : Type*} {p : Î± â†’ ContinuousMultilinearMap ğ•œ E F}\n    {q : ContinuousMultilinearMap ğ•œ E F} (h : HasSum p q) (m : Î  i, E i) :\n    HasSum (fun a => p a m) (q m) :=\n  h.map (applyAddHom m) (continuous_eval_const m)\n\n"}
{"name":"ContinuousMultilinearMap.tsum_eval","module":"Mathlib.Topology.Algebra.Module.Multilinear.Topology","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Î¹ â†’ Type u_3\nF : Type u_4\ninstâœâ¹ : NormedField ğ•œ\ninstâœâ¸ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœâ· : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâ¶ : (i : Î¹) â†’ Module ğ•œ (E i)\ninstâœâµ : AddCommGroup F\ninstâœâ´ : Module ğ•œ F\ninstâœÂ³ : TopologicalSpace F\ninstâœÂ² : TopologicalAddGroup F\ninstâœÂ¹ : âˆ€ (i : Î¹), ContinuousSMul ğ•œ (E i)\ninstâœ : T2Space F\nÎ± : Type u_5\np : Î± â†’ ContinuousMultilinearMap ğ•œ E F\nhp : Summable p\nm : (i : Î¹) â†’ E i\nâŠ¢ Eq ((tsum fun a => p a) m) (tsum fun a => (p a) m)","decl":"theorem tsum_eval [T2Space F] {Î± : Type*} {p : Î± â†’ ContinuousMultilinearMap ğ•œ E F} (hp : Summable p)\n    (m : Î  i, E i) : (âˆ‘' a, p a) m = âˆ‘' a, p a m :=\n  (hasSum_eval hp.hasSum m).tsum_eq.symm\n\n"}
