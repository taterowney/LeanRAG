{"name":"DFinsupp.le_def","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LE (α i)\nf g : DFinsupp fun i => α i\n⊢ Iff (LE.le f g) (∀ (i : ι), LE.le (f i) (g i))","decl":"lemma le_def : f ≤ g ↔ ∀ i, f i ≤ g i := Iff.rfl\n\n"}
{"name":"DFinsupp.coe_le_coe","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LE (α i)\nf g : DFinsupp fun i => α i\n⊢ Iff (LE.le ⇑f ⇑g) (LE.le f g)","decl":"@[simp, norm_cast] lemma coe_le_coe : ⇑f ≤ g ↔ f ≤ g := Iff.rfl\n\n"}
{"name":"DFinsupp.coe_orderEmbeddingToFun","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LE (α i)\n⊢ Eq (⇑DFinsupp.orderEmbeddingToFun) DFunLike.coe","decl":"@[simp, norm_cast]\nlemma coe_orderEmbeddingToFun : ⇑(orderEmbeddingToFun (α := α)) = DFunLike.coe := rfl\n\n-- Porting note: we added implicit arguments here in https://github.com/leanprover-community/mathlib4/pull/3414.\n"}
{"name":"DFinsupp.orderEmbeddingToFun_apply","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → LE (α i)\nf : DFinsupp fun i => α i\ni : ι\n⊢ Eq (DFinsupp.orderEmbeddingToFun f i) (f i)","decl":"theorem orderEmbeddingToFun_apply {f : Π₀ i, α i} {i : ι} :\n    (@orderEmbeddingToFun ι α _ _ f) i = f i :=\n  rfl\n\n"}
{"name":"DFinsupp.lt_def","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → Preorder (α i)\nf g : DFinsupp fun i => α i\n⊢ Iff (LT.lt f g) (And (LE.le f g) (Exists fun i => LT.lt (f i) (g i)))","decl":"lemma lt_def : f < g ↔ f ≤ g ∧ ∃ i, f i < g i := Pi.lt_def\n"}
{"name":"DFinsupp.coe_lt_coe","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → Preorder (α i)\nf g : DFinsupp fun i => α i\n⊢ Iff (LT.lt ⇑f ⇑g) (LT.lt f g)","decl":"@[simp, norm_cast] lemma coe_lt_coe : ⇑f < g ↔ f < g := Iff.rfl\n\n"}
{"name":"DFinsupp.coe_mono","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → Preorder (α i)\n⊢ Monotone DFunLike.coe","decl":"lemma coe_mono : Monotone ((⇑) : (Π₀ i, α i) → ∀ i, α i) := fun _ _ ↦ id\n\n"}
{"name":"DFinsupp.coe_strictMono","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → Preorder (α i)\n⊢ Monotone DFunLike.coe","decl":"lemma coe_strictMono : Monotone ((⇑) : (Π₀ i, α i) → ∀ i, α i) := fun _ _ ↦ id\n\n"}
{"name":"DFinsupp.coe_inf","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → SemilatticeInf (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (⇑(Min.min f g)) (Min.min ⇑f ⇑g)","decl":"@[simp, norm_cast]\nlemma coe_inf [∀ i, SemilatticeInf (α i)] (f g : Π₀ i, α i) : f ⊓ g = ⇑f ⊓ g := rfl\n\n"}
{"name":"DFinsupp.inf_apply","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → SemilatticeInf (α i)\nf g : DFinsupp fun i => α i\ni : ι\n⊢ Eq ((Min.min f g) i) (Min.min (f i) (g i))","decl":"theorem inf_apply [∀ i, SemilatticeInf (α i)] (f g : Π₀ i, α i) (i : ι) : (f ⊓ g) i = f i ⊓ g i :=\n  zipWith_apply _ _ _ _ _\n\n"}
{"name":"DFinsupp.coe_sup","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → SemilatticeSup (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (⇑(Max.max f g)) (Max.max ⇑f ⇑g)","decl":"@[simp, norm_cast]\nlemma coe_sup [∀ i, SemilatticeSup (α i)] (f g : Π₀ i, α i) : f ⊔ g = ⇑f ⊔ g := rfl\n\n"}
{"name":"DFinsupp.sup_apply","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → Zero (α i)\ninst✝ : (i : ι) → SemilatticeSup (α i)\nf g : DFinsupp fun i => α i\ni : ι\n⊢ Eq ((Max.max f g) i) (Max.max (f i) (g i))","decl":"theorem sup_apply [∀ i, SemilatticeSup (α i)] (f g : Π₀ i, α i) (i : ι) : (f ⊔ g) i = f i ⊔ g i :=\n  zipWith_apply _ _ _ _ _\n\n"}
{"name":"DFinsupp.support_inf_union_support_sup","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : (i : ι) → Zero (α i)\ninst✝² : (i : ι) → Lattice (α i)\nf g : DFinsupp fun i => α i\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\n⊢ Eq (Union.union (Min.min f g).support (Max.max f g).support) (Union.union f.support g.support)","decl":"theorem support_inf_union_support_sup : (f ⊓ g).support ∪ (f ⊔ g).support = f.support ∪ g.support :=\n  coe_injective <| compl_injective <| by ext; simp [inf_eq_and_sup_eq_iff]\n\n"}
{"name":"DFinsupp.support_sup_union_support_inf","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : (i : ι) → Zero (α i)\ninst✝² : (i : ι) → Lattice (α i)\nf g : DFinsupp fun i => α i\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\n⊢ Eq (Union.union (Max.max f g).support (Min.min f g).support) (Union.union f.support g.support)","decl":"theorem support_sup_union_support_inf : (f ⊔ g).support ∪ (f ⊓ g).support = f.support ∪ g.support :=\n  (union_comm _ _).trans <| support_inf_union_support_sup _ _\n\n"}
{"name":"DFinsupp.instAddLeftReflectLE","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → OrderedAddCommMonoid (α i)\ninst✝ : ∀ (i : ι), AddLeftReflectLE (α i)\n⊢ AddLeftReflectLE (DFinsupp fun i => α i)","decl":"instance [∀ i, OrderedAddCommMonoid (α i)] [∀ i, AddLeftReflectLE (α i)] :\n    AddLeftReflectLE (Π₀ i, α i) :=\n  ⟨fun _ _ _ H i ↦ le_of_add_le_add_left (H i)⟩\n\n"}
{"name":"DFinsupp.instPosSMulMono","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : ι → Type u_4\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\ninst✝³ : (i : ι) → AddCommMonoid (β i)\ninst✝² : (i : ι) → Preorder (β i)\ninst✝¹ : (i : ι) → Module α (β i)\ninst✝ : ∀ (i : ι), PosSMulMono α (β i)\n⊢ PosSMulMono α (DFinsupp fun i => β i)","decl":"instance instPosSMulMono [∀ i, PosSMulMono α (β i)] : PosSMulMono α (Π₀ i, β i) :=\n  PosSMulMono.lift _ coe_le_coe coe_smul\n\n"}
{"name":"DFinsupp.instSMulPosMono","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : ι → Type u_4\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\ninst✝³ : (i : ι) → AddCommMonoid (β i)\ninst✝² : (i : ι) → Preorder (β i)\ninst✝¹ : (i : ι) → Module α (β i)\ninst✝ : ∀ (i : ι), SMulPosMono α (β i)\n⊢ SMulPosMono α (DFinsupp fun i => β i)","decl":"instance instSMulPosMono [∀ i, SMulPosMono α (β i)] : SMulPosMono α (Π₀ i, β i) :=\n  SMulPosMono.lift _ coe_le_coe coe_smul coe_zero\n\n"}
{"name":"DFinsupp.instPosSMulReflectLE","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : ι → Type u_4\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\ninst✝³ : (i : ι) → AddCommMonoid (β i)\ninst✝² : (i : ι) → Preorder (β i)\ninst✝¹ : (i : ι) → Module α (β i)\ninst✝ : ∀ (i : ι), PosSMulReflectLE α (β i)\n⊢ PosSMulReflectLE α (DFinsupp fun i => β i)","decl":"instance instPosSMulReflectLE [∀ i, PosSMulReflectLE α (β i)] : PosSMulReflectLE α (Π₀ i, β i) :=\n  PosSMulReflectLE.lift _ coe_le_coe coe_smul\n\n"}
{"name":"DFinsupp.instSMulPosReflectLE","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : ι → Type u_4\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\ninst✝³ : (i : ι) → AddCommMonoid (β i)\ninst✝² : (i : ι) → Preorder (β i)\ninst✝¹ : (i : ι) → Module α (β i)\ninst✝ : ∀ (i : ι), SMulPosReflectLE α (β i)\n⊢ SMulPosReflectLE α (DFinsupp fun i => β i)","decl":"instance instSMulPosReflectLE [∀ i, SMulPosReflectLE α (β i)] : SMulPosReflectLE α (Π₀ i, β i) :=\n  SMulPosReflectLE.lift _ coe_le_coe coe_smul coe_zero\n\n"}
{"name":"DFinsupp.instPosSMulStrictMono","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : ι → Type u_4\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\ninst✝³ : (i : ι) → AddCommMonoid (β i)\ninst✝² : (i : ι) → PartialOrder (β i)\ninst✝¹ : (i : ι) → Module α (β i)\ninst✝ : ∀ (i : ι), PosSMulStrictMono α (β i)\n⊢ PosSMulStrictMono α (DFinsupp fun i => β i)","decl":"instance instPosSMulStrictMono [∀ i, PosSMulStrictMono α (β i)] : PosSMulStrictMono α (Π₀ i, β i) :=\n  PosSMulStrictMono.lift _ coe_le_coe coe_smul\n\n"}
{"name":"DFinsupp.instSMulPosStrictMono","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : ι → Type u_4\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\ninst✝³ : (i : ι) → AddCommMonoid (β i)\ninst✝² : (i : ι) → PartialOrder (β i)\ninst✝¹ : (i : ι) → Module α (β i)\ninst✝ : ∀ (i : ι), SMulPosStrictMono α (β i)\n⊢ SMulPosStrictMono α (DFinsupp fun i => β i)","decl":"instance instSMulPosStrictMono [∀ i, SMulPosStrictMono α (β i)] : SMulPosStrictMono α (Π₀ i, β i) :=\n  SMulPosStrictMono.lift _ coe_le_coe coe_smul coe_zero\n\n-- Note: There is no interesting instance for `PosSMulReflectLT α (Π₀ i, β i)` that's not already\n-- implied by the other instances\n\n"}
{"name":"DFinsupp.instSMulPosReflectLT","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : ι → Type u_4\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\ninst✝³ : (i : ι) → AddCommMonoid (β i)\ninst✝² : (i : ι) → PartialOrder (β i)\ninst✝¹ : (i : ι) → Module α (β i)\ninst✝ : ∀ (i : ι), SMulPosReflectLT α (β i)\n⊢ SMulPosReflectLT α (DFinsupp fun i => β i)","decl":"instance instSMulPosReflectLT [∀ i, SMulPosReflectLT α (β i)] : SMulPosReflectLT α (Π₀ i, β i) :=\n  SMulPosReflectLT.lift _ coe_le_coe coe_smul coe_zero\n\n"}
{"name":"DFinsupp.bot_eq_zero","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → AddCommMonoid (α i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\n⊢ Eq Bot.bot 0","decl":"protected theorem bot_eq_zero : (⊥ : Π₀ i, α i) = 0 :=\n  rfl\n\n"}
{"name":"DFinsupp.add_eq_zero_iff","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → AddCommMonoid (α i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\nf g : DFinsupp fun i => α i\n⊢ Iff (Eq (HAdd.hAdd f g) 0) (And (Eq f 0) (Eq g 0))","decl":"@[simp]\ntheorem add_eq_zero_iff (f g : Π₀ i, α i) : f + g = 0 ↔ f = 0 ∧ g = 0 := by\n  simp [DFunLike.ext_iff, forall_and]\n\n"}
{"name":"DFinsupp.le_iff'","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : (i : ι) → AddCommMonoid (α i)\ninst✝³ : (i : ι) → PartialOrder (α i)\ninst✝² : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\nf g : DFinsupp fun i => α i\ns : Finset ι\nhf : HasSubset.Subset f.support s\n⊢ Iff (LE.le f g) (∀ (i : ι), Membership.mem s i → LE.le (f i) (g i))","decl":"theorem le_iff' (hf : f.support ⊆ s) : f ≤ g ↔ ∀ i ∈ s, f i ≤ g i :=\n  ⟨fun h s _ ↦ h s, fun h s ↦\n    if H : s ∈ f.support then h s (hf H) else (not_mem_support_iff.1 H).symm ▸ zero_le (g s)⟩\n\n"}
{"name":"DFinsupp.le_iff","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : (i : ι) → AddCommMonoid (α i)\ninst✝³ : (i : ι) → PartialOrder (α i)\ninst✝² : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\nf g : DFinsupp fun i => α i\n⊢ Iff (LE.le f g) (∀ (i : ι), Membership.mem f.support i → LE.le (f i) (g i))","decl":"theorem le_iff : f ≤ g ↔ ∀ i ∈ f.support, f i ≤ g i :=\n  le_iff' <| Subset.refl _\n\n"}
{"name":"DFinsupp.support_monotone","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : (i : ι) → AddCommMonoid (α i)\ninst✝³ : (i : ι) → PartialOrder (α i)\ninst✝² : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\n⊢ Monotone DFinsupp.support","decl":"lemma support_monotone : Monotone (support (ι := ι) (β := α)) :=\n  fun f g h a ha ↦ by rw [mem_support_iff, ← pos_iff_ne_zero] at ha ⊢; exact ha.trans_le (h _)\n\n"}
{"name":"DFinsupp.support_mono","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : (i : ι) → AddCommMonoid (α i)\ninst✝³ : (i : ι) → PartialOrder (α i)\ninst✝² : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\nf g : DFinsupp fun i => α i\nhfg : LE.le f g\n⊢ HasSubset.Subset f.support g.support","decl":"lemma support_mono (hfg : f ≤ g) : f.support ⊆ g.support := support_monotone hfg\n\n"}
{"name":"DFinsupp.single_le_iff","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝ : DecidableEq ι\nf : DFinsupp fun i => α i\ni : ι\na : α i\n⊢ Iff (LE.le (DFinsupp.single i a) f) (LE.le a (f i))","decl":"@[simp]\ntheorem single_le_iff {f : Π₀ i, α i} {i : ι} {a : α i} :\n    single i a ≤ f ↔ a ≤ f i := by\n  classical exact (le_iff' support_single_subset).trans <| by simp\n\n"}
{"name":"DFinsupp.tsub_apply","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : (i : ι) → AddCommMonoid (α i)\ninst✝³ : (i : ι) → PartialOrder (α i)\ninst✝² : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝¹ : (i : ι) → Sub (α i)\ninst✝ : ∀ (i : ι), OrderedSub (α i)\nf g : DFinsupp fun i => α i\ni : ι\n⊢ Eq ((HSub.hSub f g) i) (HSub.hSub (f i) (g i))","decl":"theorem tsub_apply (f g : Π₀ i, α i) (i : ι) : (f - g) i = f i - g i :=\n  zipWith_apply _ _ _ _ _\n\n"}
{"name":"DFinsupp.coe_tsub","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : (i : ι) → AddCommMonoid (α i)\ninst✝³ : (i : ι) → PartialOrder (α i)\ninst✝² : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝¹ : (i : ι) → Sub (α i)\ninst✝ : ∀ (i : ι), OrderedSub (α i)\nf g : DFinsupp fun i => α i\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[simp, norm_cast]\ntheorem coe_tsub (f g : Π₀ i, α i) : ⇑(f - g) = f - g := by\n  ext i\n  exact tsub_apply f g i\n\n"}
{"name":"DFinsupp.instOrderedSub","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁴ : (i : ι) → AddCommMonoid (α i)\ninst✝³ : (i : ι) → PartialOrder (α i)\ninst✝² : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝¹ : (i : ι) → Sub (α i)\ninst✝ : ∀ (i : ι), OrderedSub (α i)\n⊢ OrderedSub (DFinsupp fun i => α i)","decl":"instance : OrderedSub (Π₀ i, α i) :=\n  ⟨fun _ _ _ ↦ forall_congr' fun _ ↦ tsub_le_iff_right⟩\n\n"}
{"name":"DFinsupp.instCanonicallyOrderedAddOfCovariantClassHAddLe","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (α i)\ninst✝² : (i : ι) → PartialOrder (α i)\ninst✝¹ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝ : ∀ (i : ι), CovariantClass (α i) (α i) (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\n⊢ CanonicallyOrderedAdd (DFinsupp fun i => α i)","decl":"instance [∀ i, CovariantClass (α i) (α i) (· + ·) (· ≤ ·)] : CanonicallyOrderedAdd (Π₀ i, α i) where\n  exists_add_of_le := by\n    intro f g h\n    exists g - f\n    ext i\n    exact (add_tsub_cancel_of_le <| h i).symm\n  le_self_add := fun _ _ _ ↦ le_self_add\n\n"}
{"name":"DFinsupp.single_tsub","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁵ : (i : ι) → AddCommMonoid (α i)\ninst✝⁴ : (i : ι) → PartialOrder (α i)\ninst✝³ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝² : (i : ι) → Sub (α i)\ninst✝¹ : ∀ (i : ι), OrderedSub (α i)\ni : ι\na b : α i\ninst✝ : DecidableEq ι\n⊢ Eq (DFinsupp.single i (HSub.hSub a b)) (HSub.hSub (DFinsupp.single i a) (DFinsupp.single i b))","decl":"@[simp]\ntheorem single_tsub : single i (a - b) = single i a - single i b := by\n  ext j\n  obtain rfl | h := eq_or_ne i j\n  · rw [tsub_apply, single_eq_same, single_eq_same, single_eq_same]\n  · rw [tsub_apply, single_eq_of_ne h, single_eq_of_ne h, single_eq_of_ne h, tsub_self]\n\n"}
{"name":"DFinsupp.support_tsub","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁶ : (i : ι) → AddCommMonoid (α i)\ninst✝⁵ : (i : ι) → PartialOrder (α i)\ninst✝⁴ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝³ : (i : ι) → Sub (α i)\ninst✝² : ∀ (i : ι), OrderedSub (α i)\nf g : DFinsupp fun i => α i\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\n⊢ HasSubset.Subset (HSub.hSub f g).support f.support","decl":"theorem support_tsub : (f - g).support ⊆ f.support := by\n  simp +contextual only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,\n    Ne, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]\n\n"}
{"name":"DFinsupp.subset_support_tsub","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝⁶ : (i : ι) → AddCommMonoid (α i)\ninst✝⁵ : (i : ι) → PartialOrder (α i)\ninst✝⁴ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝³ : (i : ι) → Sub (α i)\ninst✝² : ∀ (i : ι), OrderedSub (α i)\nf g : DFinsupp fun i => α i\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\n⊢ HasSubset.Subset (SDiff.sdiff f.support g.support) (HSub.hSub f g).support","decl":"theorem subset_support_tsub : f.support \\ g.support ⊆ (f - g).support := by\n  simp +contextual [subset_iff]\n\n"}
{"name":"DFinsupp.support_inf","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (α i)\ninst✝² : (i : ι) → LinearOrder (α i)\ninst✝¹ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝ : DecidableEq ι\nf g : DFinsupp fun i => α i\n⊢ Eq (Min.min f g).support (Inter.inter f.support g.support)","decl":"@[simp]\ntheorem support_inf : (f ⊓ g).support = f.support ∩ g.support := by\n  ext\n  simp only [inf_apply, mem_support_iff, Ne, Finset.mem_inter]\n  simp only [← nonpos_iff_eq_zero, min_le_iff, not_or]\n\n"}
{"name":"DFinsupp.support_sup","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (α i)\ninst✝² : (i : ι) → LinearOrder (α i)\ninst✝¹ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝ : DecidableEq ι\nf g : DFinsupp fun i => α i\n⊢ Eq (Max.max f g).support (Union.union f.support g.support)","decl":"@[simp]\ntheorem support_sup : (f ⊔ g).support = f.support ∪ g.support := by\n  ext\n  simp only [Finset.mem_union, mem_support_iff, sup_apply, Ne, ← bot_eq_zero]\n  rw [_root_.sup_eq_bot_iff, not_and_or]\n\n"}
{"name":"DFinsupp.disjoint_iff","module":"Mathlib.Data.DFinsupp.Order","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (α i)\ninst✝² : (i : ι) → LinearOrder (α i)\ninst✝¹ : ∀ (i : ι), CanonicallyOrderedAdd (α i)\ninst✝ : DecidableEq ι\nf g : DFinsupp fun i => α i\n⊢ Iff (Disjoint f g) (Disjoint f.support g.support)","decl":"nonrec theorem disjoint_iff : Disjoint f g ↔ Disjoint f.support g.support := by\n  rw [disjoint_iff, disjoint_iff, DFinsupp.bot_eq_zero, ← DFinsupp.support_eq_empty,\n    DFinsupp.support_inf]\n  rfl\n\n"}
