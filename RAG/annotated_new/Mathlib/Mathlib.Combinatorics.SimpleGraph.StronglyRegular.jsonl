{"name":"SimpleGraph.IsSRGWith.of_adj","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nn k ℓ μ : Nat\nself : G.IsSRGWith n k ℓ μ\nv w : V\na✝ : G.Adj v w\n⊢ Eq (Fintype.card ↑(G.commonNeighbors v w)) ℓ","decl":"/-- A graph is strongly regular with parameters `n k ℓ μ` if\n * its vertex set has cardinality `n`\n * it is regular with degree `k`\n * every pair of adjacent vertices has `ℓ` common neighbors\n * every pair of nonadjacent vertices has `μ` common neighbors\n-/\nstructure IsSRGWith (n k ℓ μ : ℕ) : Prop where\n  card : Fintype.card V = n\n  regular : G.IsRegularOfDegree k\n  of_adj : ∀ v w : V, G.Adj v w → Fintype.card (G.commonNeighbors v w) = ℓ\n  of_not_adj : Pairwise fun v w => ¬G.Adj v w → Fintype.card (G.commonNeighbors v w) = μ\n\n"}
{"name":"SimpleGraph.IsSRGWith.card","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nn k ℓ μ : Nat\nself : G.IsSRGWith n k ℓ μ\n⊢ Eq (Fintype.card V) n","decl":"/-- A graph is strongly regular with parameters `n k ℓ μ` if\n * its vertex set has cardinality `n`\n * it is regular with degree `k`\n * every pair of adjacent vertices has `ℓ` common neighbors\n * every pair of nonadjacent vertices has `μ` common neighbors\n-/\nstructure IsSRGWith (n k ℓ μ : ℕ) : Prop where\n  card : Fintype.card V = n\n  regular : G.IsRegularOfDegree k\n  of_adj : ∀ v w : V, G.Adj v w → Fintype.card (G.commonNeighbors v w) = ℓ\n  of_not_adj : Pairwise fun v w => ¬G.Adj v w → Fintype.card (G.commonNeighbors v w) = μ\n\n"}
{"name":"SimpleGraph.IsSRGWith.regular","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nn k ℓ μ : Nat\nself : G.IsSRGWith n k ℓ μ\n⊢ G.IsRegularOfDegree k","decl":"/-- A graph is strongly regular with parameters `n k ℓ μ` if\n * its vertex set has cardinality `n`\n * it is regular with degree `k`\n * every pair of adjacent vertices has `ℓ` common neighbors\n * every pair of nonadjacent vertices has `μ` common neighbors\n-/\nstructure IsSRGWith (n k ℓ μ : ℕ) : Prop where\n  card : Fintype.card V = n\n  regular : G.IsRegularOfDegree k\n  of_adj : ∀ v w : V, G.Adj v w → Fintype.card (G.commonNeighbors v w) = ℓ\n  of_not_adj : Pairwise fun v w => ¬G.Adj v w → Fintype.card (G.commonNeighbors v w) = μ\n\n"}
{"name":"SimpleGraph.IsSRGWith.of_not_adj","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nn k ℓ μ : Nat\nself : G.IsSRGWith n k ℓ μ\n⊢ Pairwise fun v w => Not (G.Adj v w) → Eq (Fintype.card ↑(G.commonNeighbors v w)) μ","decl":"/-- A graph is strongly regular with parameters `n k ℓ μ` if\n * its vertex set has cardinality `n`\n * it is regular with degree `k`\n * every pair of adjacent vertices has `ℓ` common neighbors\n * every pair of nonadjacent vertices has `μ` common neighbors\n-/\nstructure IsSRGWith (n k ℓ μ : ℕ) : Prop where\n  card : Fintype.card V = n\n  regular : G.IsRegularOfDegree k\n  of_adj : ∀ v w : V, G.Adj v w → Fintype.card (G.commonNeighbors v w) = ℓ\n  of_not_adj : Pairwise fun v w => ¬G.Adj v w → Fintype.card (G.commonNeighbors v w) = μ\n\n"}
{"name":"SimpleGraph.bot_strongly_regular","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝ : Fintype V\nℓ : Nat\n⊢ Bot.bot.IsSRGWith (Fintype.card V) 0 ℓ 0","decl":"/-- Empty graphs are strongly regular. Note that `ℓ` can take any value\nfor empty graphs, since there are no pairs of adjacent vertices. -/\ntheorem bot_strongly_regular : (⊥ : SimpleGraph V).IsSRGWith (Fintype.card V) 0 ℓ 0 where\n  card := rfl\n  regular := bot_degree\n  of_adj := fun _ _ h => h.elim\n  of_not_adj := fun v w _h => by\n    simp only [card_eq_zero, Fintype.card_ofFinset, forall_true_left, not_false_iff, bot_adj]\n    ext\n    simp [mem_commonNeighbors]\n\n"}
{"name":"SimpleGraph.IsSRGWith.top","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝¹ : Fintype V\nμ : Nat\ninst✝ : DecidableEq V\n⊢ Top.top.IsSRGWith (Fintype.card V) (HSub.hSub (Fintype.card V) 1) (HSub.hSub (Fintype.card V) 2) μ","decl":"/-- Complete graphs are strongly regular. Note that `μ` can take any value\nfor complete graphs, since there are no distinct pairs of non-adjacent vertices. -/\ntheorem IsSRGWith.top :\n    (⊤ : SimpleGraph V).IsSRGWith (Fintype.card V) (Fintype.card V - 1) (Fintype.card V - 2) μ where\n  card := rfl\n  regular := IsRegularOfDegree.top\n  of_adj := fun v w h => by\n    rw [card_commonNeighbors_top]\n    exact h\n  of_not_adj := fun v w h h' => False.elim (h' ((top_adj v w).2 h))\n\n"}
{"name":"SimpleGraph.IsSRGWith.card_neighborFinset_union_eq","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nn k ℓ μ : Nat\ninst✝ : DecidableEq V\nv w : V\nh : G.IsSRGWith n k ℓ μ\n⊢ Eq (Union.union (G.neighborFinset v) (G.neighborFinset w)).card (HSub.hSub (HMul.hMul 2 k) (Fintype.card ↑(G.commonNeighbors v w)))","decl":"theorem IsSRGWith.card_neighborFinset_union_eq {v w : V} (h : G.IsSRGWith n k ℓ μ) :\n    #(G.neighborFinset v ∪ G.neighborFinset w) =\n      2 * k - Fintype.card (G.commonNeighbors v w) := by\n  apply Nat.add_right_cancel (m := Fintype.card (G.commonNeighbors v w))\n  rw [Nat.sub_add_cancel, ← Set.toFinset_card]\n  · simp [commonNeighbors, ← neighborFinset_def, Finset.card_union_add_card_inter,\n      h.regular.degree_eq, two_mul]\n  · apply le_trans (card_commonNeighbors_le_degree_left _ _ _)\n    simp [h.regular.degree_eq, two_mul]\n\n"}
{"name":"SimpleGraph.IsSRGWith.card_neighborFinset_union_of_not_adj","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nn k ℓ μ : Nat\ninst✝ : DecidableEq V\nv w : V\nh : G.IsSRGWith n k ℓ μ\nhne : Ne v w\nha : Not (G.Adj v w)\n⊢ Eq (Union.union (G.neighborFinset v) (G.neighborFinset w)).card (HSub.hSub (HMul.hMul 2 k) μ)","decl":"/-- Assuming `G` is strongly regular, `2*(k + 1) - m` in `G` is the number of vertices that are\nadjacent to either `v` or `w` when `¬G.Adj v w`. So it's the cardinality of\n`G.neighborSet v ∪ G.neighborSet w`. -/\ntheorem IsSRGWith.card_neighborFinset_union_of_not_adj {v w : V} (h : G.IsSRGWith n k ℓ μ)\n    (hne : v ≠ w) (ha : ¬G.Adj v w) :\n    #(G.neighborFinset v ∪ G.neighborFinset w) = 2 * k - μ := by\n  rw [← h.of_not_adj hne ha]\n  apply h.card_neighborFinset_union_eq\n\n"}
{"name":"SimpleGraph.IsSRGWith.card_neighborFinset_union_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nn k ℓ μ : Nat\ninst✝ : DecidableEq V\nv w : V\nh : G.IsSRGWith n k ℓ μ\nha : G.Adj v w\n⊢ Eq (Union.union (G.neighborFinset v) (G.neighborFinset w)).card (HSub.hSub (HMul.hMul 2 k) ℓ)","decl":"theorem IsSRGWith.card_neighborFinset_union_of_adj {v w : V} (h : G.IsSRGWith n k ℓ μ)\n    (ha : G.Adj v w) : #(G.neighborFinset v ∪ G.neighborFinset w) = 2 * k - ℓ := by\n  rw [← h.of_adj v w ha]\n  apply h.card_neighborFinset_union_eq\n\n"}
{"name":"SimpleGraph.compl_neighborFinset_sdiff_inter_eq","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\nv w : V\n⊢ Eq (Inter.inter (SDiff.sdiff (HasCompl.compl (G.neighborFinset v)) (Singleton.singleton v)) (SDiff.sdiff (HasCompl.compl (G.neighborFinset w)) (Singleton.singleton w))) (SDiff.sdiff (Inter.inter (HasCompl.compl (G.neighborFinset v)) (HasCompl.compl (G.neighborFinset w))) (Union.union (Singleton.singleton w) (Singleton.singleton v)))","decl":"theorem compl_neighborFinset_sdiff_inter_eq {v w : V} :\n    (G.neighborFinset v)ᶜ \\ {v} ∩ ((G.neighborFinset w)ᶜ \\ {w}) =\n      ((G.neighborFinset v)ᶜ ∩ (G.neighborFinset w)ᶜ) \\ ({w} ∪ {v}) := by\n  ext\n  rw [← not_iff_not]\n  simp [imp_iff_not_or, or_assoc, or_comm, or_left_comm]\n\n"}
{"name":"SimpleGraph.sdiff_compl_neighborFinset_inter_eq","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : DecidableEq V\nv w : V\nh : G.Adj v w\n⊢ Eq (SDiff.sdiff (Inter.inter (HasCompl.compl (G.neighborFinset v)) (HasCompl.compl (G.neighborFinset w))) (Union.union (Singleton.singleton w) (Singleton.singleton v))) (Inter.inter (HasCompl.compl (G.neighborFinset v)) (HasCompl.compl (G.neighborFinset w)))","decl":"theorem sdiff_compl_neighborFinset_inter_eq {v w : V} (h : G.Adj v w) :\n    ((G.neighborFinset v)ᶜ ∩ (G.neighborFinset w)ᶜ) \\ ({w} ∪ {v}) =\n      (G.neighborFinset v)ᶜ ∩ (G.neighborFinset w)ᶜ := by\n  ext\n  simp only [and_imp, mem_union, mem_sdiff, mem_compl, and_iff_left_iff_imp, mem_neighborFinset,\n    mem_inter, mem_singleton]\n  rintro hnv hnw (rfl | rfl)\n  · exact hnv h\n  · apply hnw\n    rwa [adj_comm]\n\n"}
{"name":"SimpleGraph.IsSRGWith.compl_is_regular","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nn k ℓ μ : Nat\ninst✝ : DecidableEq V\nh : G.IsSRGWith n k ℓ μ\n⊢ (HasCompl.compl G).IsRegularOfDegree (HSub.hSub (HSub.hSub n k) 1)","decl":"theorem IsSRGWith.compl_is_regular (h : G.IsSRGWith n k ℓ μ) :\n    Gᶜ.IsRegularOfDegree (n - k - 1) := by\n  rw [← h.card, Nat.sub_sub, add_comm, ← Nat.sub_sub]\n  exact h.regular.compl\n\n"}
{"name":"SimpleGraph.IsSRGWith.card_commonNeighbors_eq_of_adj_compl","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nn k ℓ μ : Nat\ninst✝ : DecidableEq V\nh : G.IsSRGWith n k ℓ μ\nv w : V\nha : (HasCompl.compl G).Adj v w\n⊢ Eq (Fintype.card ↑((HasCompl.compl G).commonNeighbors v w)) (HSub.hSub (HSub.hSub n (HSub.hSub (HMul.hMul 2 k) μ)) 2)","decl":"theorem IsSRGWith.card_commonNeighbors_eq_of_adj_compl (h : G.IsSRGWith n k ℓ μ) {v w : V}\n    (ha : Gᶜ.Adj v w) : Fintype.card (Gᶜ.commonNeighbors v w) = n - (2 * k - μ) - 2 := by\n  simp only [← Set.toFinset_card, commonNeighbors, Set.toFinset_inter, neighborSet_compl,\n    Set.toFinset_diff, Set.toFinset_singleton, Set.toFinset_compl, ← neighborFinset_def]\n  simp_rw [compl_neighborFinset_sdiff_inter_eq]\n  have hne : v ≠ w := ne_of_adj _ ha\n  rw [compl_adj] at ha\n  rw [card_sdiff, ← insert_eq, card_insert_of_not_mem, card_singleton, ← Finset.compl_union]\n  · rw [card_compl, h.card_neighborFinset_union_of_not_adj hne ha.2, ← h.card]\n  · simp only [hne.symm, not_false_iff, mem_singleton]\n  · intro u\n    simp only [mem_union, mem_compl, mem_neighborFinset, mem_inter, mem_singleton]\n    rintro (rfl | rfl) <;> simpa [adj_comm] using ha.2\n\n"}
{"name":"SimpleGraph.IsSRGWith.card_commonNeighbors_eq_of_not_adj_compl","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nn k ℓ μ : Nat\ninst✝ : DecidableEq V\nh : G.IsSRGWith n k ℓ μ\nv w : V\nhn : Ne v w\nhna : Not ((HasCompl.compl G).Adj v w)\n⊢ Eq (Fintype.card ↑((HasCompl.compl G).commonNeighbors v w)) (HSub.hSub n (HSub.hSub (HMul.hMul 2 k) ℓ))","decl":"theorem IsSRGWith.card_commonNeighbors_eq_of_not_adj_compl (h : G.IsSRGWith n k ℓ μ) {v w : V}\n    (hn : v ≠ w) (hna : ¬Gᶜ.Adj v w) :\n    Fintype.card (Gᶜ.commonNeighbors v w) = n - (2 * k - ℓ) := by\n  simp only [← Set.toFinset_card, commonNeighbors, Set.toFinset_inter, neighborSet_compl,\n    Set.toFinset_diff, Set.toFinset_singleton, Set.toFinset_compl, ← neighborFinset_def]\n  simp only [not_and, Classical.not_not, compl_adj] at hna\n  have h2' := hna hn\n  simp_rw [compl_neighborFinset_sdiff_inter_eq, sdiff_compl_neighborFinset_inter_eq h2']\n  rwa [← Finset.compl_union, card_compl, h.card_neighborFinset_union_of_adj, ← h.card]\n\n"}
{"name":"SimpleGraph.IsSRGWith.compl","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝² : Fintype V\nG : SimpleGraph V\ninst✝¹ : DecidableRel G.Adj\nn k ℓ μ : Nat\ninst✝ : DecidableEq V\nh : G.IsSRGWith n k ℓ μ\n⊢ (HasCompl.compl G).IsSRGWith n (HSub.hSub (HSub.hSub n k) 1) (HSub.hSub (HSub.hSub n (HSub.hSub (HMul.hMul 2 k) μ)) 2) (HSub.hSub n (HSub.hSub (HMul.hMul 2 k) ℓ))","decl":"/-- The complement of a strongly regular graph is strongly regular. -/\ntheorem IsSRGWith.compl (h : G.IsSRGWith n k ℓ μ) :\n    Gᶜ.IsSRGWith n (n - k - 1) (n - (2 * k - μ) - 2) (n - (2 * k - ℓ)) where\n  card := h.card\n  regular := h.compl_is_regular\n  of_adj := fun _v _w ha => h.card_commonNeighbors_eq_of_adj_compl ha\n  of_not_adj := fun _v _w hn hna => h.card_commonNeighbors_eq_of_not_adj_compl hn hna\n\n"}
{"name":"SimpleGraph.IsSRGWith.param_eq","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"n k ℓ μ : Nat\nV : Type u\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nh : G.IsSRGWith n k ℓ μ\nhn : LT.lt 0 n\n⊢ Eq (HMul.hMul k (HSub.hSub (HSub.hSub k ℓ) 1)) (HMul.hMul (HSub.hSub (HSub.hSub n k) 1) μ)","decl":"/-- The parameters of a strongly regular graph with at least one vertex satisfy\n`k * (k - ℓ - 1) = (n - k - 1) * μ`. -/\ntheorem IsSRGWith.param_eq\n    {V : Type u} [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj]\n    (h : G.IsSRGWith n k ℓ μ) (hn : 0 < n) :\n    k * (k - ℓ - 1) = (n - k - 1) * μ := by\n  letI := Classical.decEq V\n  rw [← h.card, Fintype.card_pos_iff] at hn\n  obtain ⟨v⟩ := hn\n  convert card_mul_eq_card_mul G.Adj (s := G.neighborFinset v) (t := Gᶜ.neighborFinset v) _ _\n  · simp [h.regular v]\n  · simp [h.compl.regular v]\n  · intro w hw\n    rw [mem_neighborFinset] at hw\n    simp_rw [bipartiteAbove, ← mem_neighborFinset, filter_mem_eq_inter]\n    have s : {v} ⊆ G.neighborFinset w \\ G.neighborFinset v := by\n      rw [singleton_subset_iff, mem_sdiff, mem_neighborFinset]\n      exact ⟨hw.symm, G.not_mem_neighborFinset_self v⟩\n    rw [inter_comm, neighborFinset_compl, ← inter_sdiff_assoc, ← sdiff_eq_inter_compl, card_sdiff s,\n      card_singleton, ← sdiff_inter_self_left, card_sdiff (by apply inter_subset_left)]\n    congr\n    · simp [h.regular w]\n    · simp_rw [inter_comm, neighborFinset_def, ← Set.toFinset_inter, ← h.of_adj v w hw,\n        ← Set.toFinset_card]\n      congr!\n  · intro w hw\n    simp_rw [neighborFinset_compl, mem_sdiff, mem_compl, mem_singleton, mem_neighborFinset,\n      ← Ne.eq_def] at hw\n    simp_rw [bipartiteBelow, adj_comm, ← mem_neighborFinset, filter_mem_eq_inter,\n      neighborFinset_def, ← Set.toFinset_inter, ← h.of_not_adj hw.2.symm hw.1,\n      ← Set.toFinset_card]\n    congr!\n\n"}
{"name":"SimpleGraph.IsSRGWith.matrix_eq","module":"Mathlib.Combinatorics.SimpleGraph.StronglyRegular","initialProofState":"V : Type u\ninst✝³ : Fintype V\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\nn k ℓ μ : Nat\ninst✝¹ : DecidableEq V\nα : Type u_1\ninst✝ : Semiring α\nh : G.IsSRGWith n k ℓ μ\n⊢ Eq (HPow.hPow (SimpleGraph.adjMatrix α G) 2) (HAdd.hAdd (HAdd.hAdd (HSMul.hSMul k 1) (HSMul.hSMul ℓ (SimpleGraph.adjMatrix α G))) (HSMul.hSMul μ (SimpleGraph.adjMatrix α (HasCompl.compl G))))","decl":"/-- Let `A` and `C` be the adjacency matrices of a strongly regular graph with parameters `n k ℓ μ`\nand its complement respectively and `I` be the identity matrix,\nthen `A ^ 2 = k • I + ℓ • A + μ • C`. `C` is equivalent to the expression `J - I - A`\nmore often found in the literature, where `J` is the all-ones matrix. -/\ntheorem IsSRGWith.matrix_eq {α : Type*} [Semiring α] (h : G.IsSRGWith n k ℓ μ) :\n    G.adjMatrix α ^ 2 = k • (1 : Matrix V V α) + ℓ • G.adjMatrix α + μ • Gᶜ.adjMatrix α := by\n  ext v w\n  simp only [adjMatrix_pow_apply_eq_card_walk, Set.coe_setOf, Matrix.add_apply, Matrix.smul_apply,\n    adjMatrix_apply, compl_adj]\n  rw [Fintype.card_congr (G.walkLengthTwoEquivCommonNeighbors v w)]\n  obtain rfl | hn := eq_or_ne v w\n  · rw [← Set.toFinset_card]\n    simp [commonNeighbors, ← neighborFinset_def, h.regular v]\n  · simp only [Matrix.one_apply_ne' hn.symm, ne_eq, hn]\n    by_cases ha : G.Adj v w <;>\n      simp only [ha, ite_true, ite_false, add_zero, zero_add, nsmul_eq_mul, smul_zero, mul_one,\n        not_true_eq_false, not_false_eq_true, and_false, and_self]\n    · rw [h.of_adj v w ha]\n    · rw [h.of_not_adj hn ha]\n\n"}
