{"name":"Complex.UnitDisc.coe_injective","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ Function.Injective Subtype.val","decl":"theorem coe_injective : Injective ((â†‘) : ğ”» â†’ â„‚) :=\n  Subtype.coe_injective\n\n"}
{"name":"Complex.UnitDisc.abs_lt_one","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ LT.lt (Complex.abs â†‘z) 1","decl":"theorem abs_lt_one (z : ğ”») : abs (z : â„‚) < 1 :=\n  mem_ball_zero_iff.1 z.2\n\n"}
{"name":"Complex.UnitDisc.abs_ne_one","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Ne (Complex.abs â†‘z) 1","decl":"theorem abs_ne_one (z : ğ”») : abs (z : â„‚) â‰  1 :=\n  z.abs_lt_one.ne\n\n"}
{"name":"Complex.UnitDisc.normSq_lt_one","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ LT.lt (Complex.normSq â†‘z) 1","decl":"theorem normSq_lt_one (z : ğ”») : normSq z < 1 := by\n  convert (Real.sqrt_lt' one_pos).1 z.abs_lt_one\n  exact (one_pow 2).symm\n\n"}
{"name":"Complex.UnitDisc.coe_ne_one","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Ne (â†‘z) 1","decl":"theorem coe_ne_one (z : ğ”») : (z : â„‚) â‰  1 :=\n  ne_of_apply_ne abs <| (map_one abs).symm â–¸ z.abs_ne_one\n\n"}
{"name":"Complex.UnitDisc.coe_ne_neg_one","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Ne (â†‘z) (-1)","decl":"theorem coe_ne_neg_one (z : ğ”») : (z : â„‚) â‰  -1 :=\n  ne_of_apply_ne abs <| by\n    rw [abs.map_neg, map_one]\n    exact z.abs_ne_one\n\n"}
{"name":"Complex.UnitDisc.one_add_coe_ne_zero","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Ne (HAdd.hAdd 1 â†‘z) 0","decl":"theorem one_add_coe_ne_zero (z : ğ”») : (1 + z : â„‚) â‰  0 :=\n  mt neg_eq_iff_add_eq_zero.2 z.coe_ne_neg_one.symm\n\n"}
{"name":"Complex.UnitDisc.coe_mul","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z w : Complex.UnitDisc\nâŠ¢ Eq (â†‘(HMul.hMul z w)) (HMul.hMul â†‘z â†‘w)","decl":"@[simp, norm_cast]\ntheorem coe_mul (z w : ğ”») : â†‘(z * w) = (z * w : â„‚) :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.coe_mk","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex\nhz : LT.lt (Complex.abs z) 1\nâŠ¢ Eq (â†‘(Complex.UnitDisc.mk z hz)) z","decl":"@[simp]\ntheorem coe_mk (z : â„‚) (hz : abs z < 1) : (mk z hz : â„‚) = z :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.mk_coe","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nhz : optParam (LT.lt (Complex.abs â†‘z) 1) â‹¯\nâŠ¢ Eq (Complex.UnitDisc.mk (â†‘z) hz) z","decl":"@[simp]\ntheorem mk_coe (z : ğ”») (hz : abs (z : â„‚) < 1 := z.abs_lt_one) : mk z hz = z :=\n  Subtype.eta _ _\n\n"}
{"name":"Complex.UnitDisc.mk_neg","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex\nhz : LT.lt (Complex.abs (Neg.neg z)) 1\nâŠ¢ Eq (Complex.UnitDisc.mk (Neg.neg z) hz) (Neg.neg (Complex.UnitDisc.mk z â‹¯))","decl":"@[simp]\ntheorem mk_neg (z : â„‚) (hz : abs (-z) < 1) : mk (-z) hz = -mk z (abs.map_neg z â–¸ hz) :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.coe_zero","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ Eq (â†‘0) 0","decl":"@[simp]\ntheorem coe_zero : ((0 : ğ”») : â„‚) = 0 :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.coe_eq_zero","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Iff (Eq (â†‘z) 0) (Eq z 0)","decl":"@[simp]\ntheorem coe_eq_zero {z : ğ”»} : (z : â„‚) = 0 â†” z = 0 :=\n  coe_injective.eq_iff' coe_zero\n\n"}
{"name":"Complex.UnitDisc.isScalarTower_circle_circle","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ IsScalarTower Circle Circle Complex.UnitDisc","decl":"instance isScalarTower_circle_circle : IsScalarTower Circle Circle ğ”» :=\n  isScalarTower_sphere_sphere_ball\n\n"}
{"name":"Complex.UnitDisc.isScalarTower_circle","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ IsScalarTower Circle Complex.UnitDisc Complex.UnitDisc","decl":"instance isScalarTower_circle : IsScalarTower Circle ğ”» ğ”» :=\n  isScalarTower_sphere_ball_ball\n\n"}
{"name":"Complex.UnitDisc.instSMulCommClass_circle","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ SMulCommClass Circle Complex.UnitDisc Complex.UnitDisc","decl":"instance instSMulCommClass_circle : SMulCommClass Circle ğ”» ğ”» :=\n  instSMulCommClass_sphere_ball_ball\n\n"}
{"name":"Complex.UnitDisc.instSMulCommClass_circle'","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ SMulCommClass Complex.UnitDisc Circle Complex.UnitDisc","decl":"instance instSMulCommClass_circle' : SMulCommClass ğ”» Circle ğ”» :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Complex.UnitDisc.coe_smul_circle","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Circle\nw : Complex.UnitDisc\nâŠ¢ Eq (â†‘(HSMul.hSMul z w)) (HMul.hMul â†‘z â†‘w)","decl":"@[simp, norm_cast]\ntheorem coe_smul_circle (z : Circle) (w : ğ”») : â†‘(z â€¢ w) = (z * w : â„‚) :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.isScalarTower_closedBall_closedBall","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ IsScalarTower (â†‘(Metric.closedBall 0 1)) (â†‘(Metric.closedBall 0 1)) Complex.UnitDisc","decl":"instance isScalarTower_closedBall_closedBall :\n    IsScalarTower (closedBall (0 : â„‚) 1) (closedBall (0 : â„‚) 1) ğ”» :=\n  isScalarTower_closedBall_closedBall_ball\n\n"}
{"name":"Complex.UnitDisc.isScalarTower_closedBall","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ IsScalarTower (â†‘(Metric.closedBall 0 1)) Complex.UnitDisc Complex.UnitDisc","decl":"instance isScalarTower_closedBall : IsScalarTower (closedBall (0 : â„‚) 1) ğ”» ğ”» :=\n  isScalarTower_closedBall_ball_ball\n\n"}
{"name":"Complex.UnitDisc.instSMulCommClass_closedBall","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ SMulCommClass (â†‘(Metric.closedBall 0 1)) Complex.UnitDisc Complex.UnitDisc","decl":"instance instSMulCommClass_closedBall : SMulCommClass (closedBall (0 : â„‚) 1) ğ”» ğ”» :=\n  âŸ¨fun _ _ _ => Subtype.ext <| mul_left_comm _ _ _âŸ©\n\n"}
{"name":"Complex.UnitDisc.instSMulCommClass_closedBall'","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ SMulCommClass Complex.UnitDisc (â†‘(Metric.closedBall 0 1)) Complex.UnitDisc","decl":"instance instSMulCommClass_closedBall' : SMulCommClass ğ”» (closedBall (0 : â„‚) 1) ğ”» :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Complex.UnitDisc.instSMulCommClass_circle_closedBall","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ SMulCommClass Circle (â†‘(Metric.closedBall 0 1)) Complex.UnitDisc","decl":"instance instSMulCommClass_circle_closedBall : SMulCommClass Circle (closedBall (0 : â„‚) 1) ğ”» :=\n  instSMulCommClass_sphere_closedBall_ball\n\n"}
{"name":"Complex.UnitDisc.instSMulCommClass_closedBall_circle","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ SMulCommClass (â†‘(Metric.closedBall 0 1)) Circle Complex.UnitDisc","decl":"instance instSMulCommClass_closedBall_circle : SMulCommClass (closedBall (0 : â„‚) 1) Circle ğ”» :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"Complex.UnitDisc.coe_smul_closedBall","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : â†‘(Metric.closedBall 0 1)\nw : Complex.UnitDisc\nâŠ¢ Eq (â†‘(HSMul.hSMul z w)) (HMul.hMul â†‘z â†‘w)","decl":"@[simp, norm_cast]\ntheorem coe_smul_closedBall (z : closedBall (0 : â„‚) 1) (w : ğ”») : â†‘(z â€¢ w) = (z * w : â„‚) :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.re_coe","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Eq (â†‘z).re z.re","decl":"@[simp, norm_cast]\ntheorem re_coe (z : ğ”») : (z : â„‚).re = z.re :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.im_coe","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Eq (â†‘z).im z.im","decl":"@[simp, norm_cast]\ntheorem im_coe (z : ğ”») : (z : â„‚).im = z.im :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.re_neg","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Eq (Neg.neg z).re (Neg.neg z.re)","decl":"@[simp]\ntheorem re_neg (z : ğ”») : (-z).re = -z.re :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.im_neg","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Eq (Neg.neg z).im (Neg.neg z.im)","decl":"@[simp]\ntheorem im_neg (z : ğ”») : (-z).im = -z.im :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.coe_conj","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Eq (â†‘z.conj) ((starRingEnd Complex) â†‘z)","decl":"@[simp]\ntheorem coe_conj (z : ğ”») : (z.conj : â„‚) = conj' â†‘z :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.conj_zero","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"âŠ¢ Eq (Complex.UnitDisc.conj 0) 0","decl":"@[simp]\ntheorem conj_zero : conj 0 = 0 :=\n  coe_injective (map_zero conj')\n\n"}
{"name":"Complex.UnitDisc.conj_conj","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Eq z.conj.conj z","decl":"@[simp]\ntheorem conj_conj (z : ğ”») : conj (conj z) = z :=\n  coe_injective <| Complex.conj_conj (z : â„‚)\n\n"}
{"name":"Complex.UnitDisc.conj_neg","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Eq (Neg.neg z).conj (Neg.neg z.conj)","decl":"@[simp]\ntheorem conj_neg (z : ğ”») : (-z).conj = -z.conj :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.re_conj","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Eq z.conj.re z.re","decl":"@[simp]\ntheorem re_conj (z : ğ”») : z.conj.re = z.re :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.im_conj","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z : Complex.UnitDisc\nâŠ¢ Eq z.conj.im (Neg.neg z.im)","decl":"@[simp]\ntheorem im_conj (z : ğ”») : z.conj.im = -z.im :=\n  rfl\n\n"}
{"name":"Complex.UnitDisc.conj_mul","module":"Mathlib.Analysis.Complex.UnitDisc.Basic","initialProofState":"z w : Complex.UnitDisc\nâŠ¢ Eq (HMul.hMul z w).conj (HMul.hMul z.conj w.conj)","decl":"@[simp]\ntheorem conj_mul (z w : ğ”») : (z * w).conj = z.conj * w.conj :=\n  Subtype.ext <| map_mul _ _ _\n\n"}
