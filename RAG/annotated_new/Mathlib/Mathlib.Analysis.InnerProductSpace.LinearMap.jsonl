{"name":"inner_map_polarization","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"V : Type u_4\ninst‚úù¬π : SeminormedAddCommGroup V\ninst‚úù : InnerProductSpace Complex V\nT : LinearMap (RingHom.id Complex) V V\nx y : V\n‚ä¢ Eq (Inner.inner (T y) x) (HDiv.hDiv (HSub.hSub (HAdd.hAdd (HSub.hSub (Inner.inner (T (HAdd.hAdd x y)) (HAdd.hAdd x y)) (Inner.inner (T (HSub.hSub x y)) (HSub.hSub x y))) (HMul.hMul Complex.I (Inner.inner (T (HAdd.hAdd x (HSMul.hSMul Complex.I y))) (HAdd.hAdd x (HSMul.hSMul Complex.I y))))) (HMul.hMul Complex.I (Inner.inner (T (HSub.hSub x (HSMul.hSMul Complex.I y))) (HSub.hSub x (HSMul.hSMul Complex.I y))))) 4)","decl":"/-- A complex polarization identity, with a linear map. -/\ntheorem inner_map_polarization (T : V ‚Üí‚Çó[‚ÑÇ] V) (x y : V) :\n    ‚ü™T y, x‚ü´_‚ÑÇ =\n      (‚ü™T (x + y), x + y‚ü´_‚ÑÇ - ‚ü™T (x - y), x - y‚ü´_‚ÑÇ +\n            Complex.I * ‚ü™T (x + Complex.I ‚Ä¢ y), x + Complex.I ‚Ä¢ y‚ü´_‚ÑÇ -\n          Complex.I * ‚ü™T (x - Complex.I ‚Ä¢ y), x - Complex.I ‚Ä¢ y‚ü´_‚ÑÇ) /\n        4 := by\n  simp only [map_add, map_sub, inner_add_left, inner_add_right, LinearMap.map_smul, inner_smul_left,\n    inner_smul_right, Complex.conj_I, ‚Üê pow_two, Complex.I_sq, inner_sub_left, inner_sub_right,\n    mul_add, ‚Üê mul_assoc, mul_neg, neg_neg, sub_neg_eq_add, one_mul, neg_one_mul, mul_sub, sub_sub]\n  ring\n\n"}
{"name":"inner_map_polarization'","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"V : Type u_4\ninst‚úù¬π : SeminormedAddCommGroup V\ninst‚úù : InnerProductSpace Complex V\nT : LinearMap (RingHom.id Complex) V V\nx y : V\n‚ä¢ Eq (Inner.inner (T x) y) (HDiv.hDiv (HAdd.hAdd (HSub.hSub (HSub.hSub (Inner.inner (T (HAdd.hAdd x y)) (HAdd.hAdd x y)) (Inner.inner (T (HSub.hSub x y)) (HSub.hSub x y))) (HMul.hMul Complex.I (Inner.inner (T (HAdd.hAdd x (HSMul.hSMul Complex.I y))) (HAdd.hAdd x (HSMul.hSMul Complex.I y))))) (HMul.hMul Complex.I (Inner.inner (T (HSub.hSub x (HSMul.hSMul Complex.I y))) (HSub.hSub x (HSMul.hSMul Complex.I y))))) 4)","decl":"theorem inner_map_polarization' (T : V ‚Üí‚Çó[‚ÑÇ] V) (x y : V) :\n    ‚ü™T x, y‚ü´_‚ÑÇ =\n      (‚ü™T (x + y), x + y‚ü´_‚ÑÇ - ‚ü™T (x - y), x - y‚ü´_‚ÑÇ -\n            Complex.I * ‚ü™T (x + Complex.I ‚Ä¢ y), x + Complex.I ‚Ä¢ y‚ü´_‚ÑÇ +\n          Complex.I * ‚ü™T (x - Complex.I ‚Ä¢ y), x - Complex.I ‚Ä¢ y‚ü´_‚ÑÇ) /\n        4 := by\n  simp only [map_add, map_sub, inner_add_left, inner_add_right, LinearMap.map_smul, inner_smul_left,\n    inner_smul_right, Complex.conj_I, ‚Üê pow_two, Complex.I_sq, inner_sub_left, inner_sub_right,\n    mul_add, ‚Üê mul_assoc, mul_neg, neg_neg, sub_neg_eq_add, one_mul, neg_one_mul, mul_sub, sub_sub]\n  ring\n\n"}
{"name":"inner_map_self_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"V : Type u_4\ninst‚úù¬π : NormedAddCommGroup V\ninst‚úù : InnerProductSpace Complex V\nT : LinearMap (RingHom.id Complex) V V\n‚ä¢ Iff (‚àÄ (x : V), Eq (Inner.inner (T x) x) 0) (Eq T 0)","decl":"/-- A linear map `T` is zero, if and only if the identity `‚ü™T x, x‚ü´_‚ÑÇ = 0` holds for all `x`.\n-/\ntheorem inner_map_self_eq_zero (T : V ‚Üí‚Çó[‚ÑÇ] V) : (‚àÄ x : V, ‚ü™T x, x‚ü´_‚ÑÇ = 0) ‚Üî T = 0 := by\n  constructor\n  ¬∑ intro hT\n    ext x\n    rw [LinearMap.zero_apply, ‚Üê @inner_self_eq_zero ‚ÑÇ V, inner_map_polarization]\n    simp only [hT]\n    norm_num\n  ¬∑ rintro rfl x\n    simp only [LinearMap.zero_apply, inner_zero_left]\n\n"}
{"name":"ext_inner_map","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"V : Type u_4\ninst‚úù¬π : NormedAddCommGroup V\ninst‚úù : InnerProductSpace Complex V\nS T : LinearMap (RingHom.id Complex) V V\n‚ä¢ Iff (‚àÄ (x : V), Eq (Inner.inner (S x) x) (Inner.inner (T x) x)) (Eq S T)","decl":"/--\nTwo linear maps `S` and `T` are equal, if and only if the identity `‚ü™S x, x‚ü´_‚ÑÇ = ‚ü™T x, x‚ü´_‚ÑÇ` holds\nfor all `x`.\n-/\ntheorem ext_inner_map (S T : V ‚Üí‚Çó[‚ÑÇ] V) : (‚àÄ x : V, ‚ü™S x, x‚ü´_‚ÑÇ = ‚ü™T x, x‚ü´_‚ÑÇ) ‚Üî S = T := by\n  rw [‚Üê sub_eq_zero, ‚Üê inner_map_self_eq_zero]\n  refine forall_congr' fun x => ?_\n  rw [LinearMap.sub_apply, inner_sub_left, sub_eq_zero]\n\n"}
{"name":"LinearIsometry.inner_map_map","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nE' : Type u_7\ninst‚úù¬π : SeminormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : LinearIsometry (RingHom.id ùïú) E E'\nx y : E\n‚ä¢ Eq (Inner.inner (f x) (f y)) (Inner.inner x y)","decl":"/-- A linear isometry preserves the inner product. -/\n@[simp]\ntheorem LinearIsometry.inner_map_map (f : E ‚Üí‚Çó·µ¢[ùïú] E') (x y : E) : ‚ü™f x, f y‚ü´ = ‚ü™x, y‚ü´ := by\n  simp [inner_eq_sum_norm_sq_div_four, ‚Üê f.norm_map]\n\n"}
{"name":"LinearIsometryEquiv.inner_map_map","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nE' : Type u_7\ninst‚úù¬π : SeminormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : LinearIsometryEquiv (RingHom.id ùïú) E E'\nx y : E\n‚ä¢ Eq (Inner.inner (f x) (f y)) (Inner.inner x y)","decl":"/-- A linear isometric equivalence preserves the inner product. -/\n@[simp]\ntheorem LinearIsometryEquiv.inner_map_map (f : E ‚âÉ‚Çó·µ¢[ùïú] E') (x y : E) : ‚ü™f x, f y‚ü´ = ‚ü™x, y‚ü´ :=\n  f.toLinearIsometry.inner_map_map x y\n\n"}
{"name":"LinearIsometryEquiv.inner_map_eq_flip","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nE' : Type u_7\ninst‚úù¬π : SeminormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : LinearIsometryEquiv (RingHom.id ùïú) E E'\nx : E\ny : E'\n‚ä¢ Eq (Inner.inner (f x) y) (Inner.inner x (f.symm y))","decl":"/-- The adjoint of a linear isometric equivalence is its inverse. -/\ntheorem LinearIsometryEquiv.inner_map_eq_flip (f : E ‚âÉ‚Çó·µ¢[ùïú] E') (x : E) (y : E') :\n    ‚ü™f x, y‚ü´_ùïú = ‚ü™x, f.symm y‚ü´_ùïú := by\n  conv_lhs => rw [‚Üê f.apply_symm_apply y, f.inner_map_map]\n\n"}
{"name":"LinearMap.coe_isometryOfInner","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nE' : Type u_7\ninst‚úù¬π : SeminormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : LinearMap (RingHom.id ùïú) E E'\nh : ‚àÄ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y)\n‚ä¢ Eq ‚áë(f.isometryOfInner h) ‚áëf","decl":"@[simp]\ntheorem LinearMap.coe_isometryOfInner (f : E ‚Üí‚Çó[ùïú] E') (h) : ‚áë(f.isometryOfInner h) = f :=\n  rfl\n\n"}
{"name":"LinearMap.isometryOfInner_toLinearMap","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nE' : Type u_7\ninst‚úù¬π : SeminormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : LinearMap (RingHom.id ùïú) E E'\nh : ‚àÄ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y)\n‚ä¢ Eq (f.isometryOfInner h).toLinearMap f","decl":"@[simp]\ntheorem LinearMap.isometryOfInner_toLinearMap (f : E ‚Üí‚Çó[ùïú] E') (h) :\n    (f.isometryOfInner h).toLinearMap = f :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_isometryOfInner","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nE' : Type u_7\ninst‚úù¬π : SeminormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : LinearEquiv (RingHom.id ùïú) E E'\nh : ‚àÄ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y)\n‚ä¢ Eq ‚áë(f.isometryOfInner h) ‚áëf","decl":"@[simp]\ntheorem LinearEquiv.coe_isometryOfInner (f : E ‚âÉ‚Çó[ùïú] E') (h) : ‚áë(f.isometryOfInner h) = f :=\n  rfl\n\n"}
{"name":"LinearEquiv.isometryOfInner_toLinearEquiv","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nE' : Type u_7\ninst‚úù¬π : SeminormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : LinearEquiv (RingHom.id ùïú) E E'\nh : ‚àÄ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y)\n‚ä¢ Eq (f.isometryOfInner h).toLinearEquiv f","decl":"@[simp]\ntheorem LinearEquiv.isometryOfInner_toLinearEquiv (f : E ‚âÉ‚Çó[ùïú] E') (h) :\n    (f.isometryOfInner h).toLinearEquiv = f :=\n  rfl\n\n"}
{"name":"LinearMap.norm_map_iff_inner_map_map","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å∂ : RCLike ùïú\ninst‚úù‚Åµ : SeminormedAddCommGroup E\ninst‚úù‚Å¥ : InnerProductSpace ùïú E\nE' : Type u_7\ninst‚úù¬≥ : SeminormedAddCommGroup E'\ninst‚úù¬≤ : InnerProductSpace ùïú E'\nF : Type u_9\ninst‚úù¬π : FunLike F E E'\ninst‚úù : LinearMapClass F ùïú E E'\nf : F\n‚ä¢ Iff (‚àÄ (x : E), Eq (Norm.norm (f x)) (Norm.norm x)) (‚àÄ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y))","decl":"/-- A linear map is an isometry if and it preserves the inner product. -/\ntheorem LinearMap.norm_map_iff_inner_map_map {F : Type*} [FunLike F E E'] [LinearMapClass F ùïú E E']\n    (f : F) : (‚àÄ x, ‚Äñf x‚Äñ = ‚Äñx‚Äñ) ‚Üî (‚àÄ x y, ‚ü™f x, f y‚ü´_ùïú = ‚ü™x, y‚ü´_ùïú) :=\n  ‚ü®({ toLinearMap := LinearMapClass.linearMap f, norm_map' := ¬∑ : E ‚Üí‚Çó·µ¢[ùïú] E' }.inner_map_map),\n    (LinearMapClass.linearMap f |>.isometryOfInner ¬∑ |>.norm_map)‚ü©\n\n"}
{"name":"inner‚Çõ‚Çó_apply_coe","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv : E\n‚ä¢ Eq ‚áë((inner‚Çõ‚Çó ùïú) v) fun w => Inner.inner v w","decl":"@[simp]\ntheorem inner‚Çõ‚Çó_apply_coe (v : E) : ‚áë(inner‚Çõ‚Çó ùïú v) = fun w => ‚ü™v, w‚ü´ :=\n  rfl\n\n"}
{"name":"inner‚Çõ‚Çó_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv w : E\n‚ä¢ Eq (((inner‚Çõ‚Çó ùïú) v) w) (Inner.inner v w)","decl":"@[simp]\ntheorem inner‚Çõ‚Çó_apply (v w : E) : inner‚Çõ‚Çó ùïú v w = ‚ü™v, w‚ü´ :=\n  rfl\n\n"}
{"name":"flip_inner‚Çó","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"F : Type u_3\ninst‚úù¬π : SeminormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\n‚ä¢ Eq (inner‚Çó F).flip (inner‚Çó F)","decl":"@[simp] lemma flip_inner‚Çó : (inner‚Çó F).flip = inner‚Çó F := by\n  ext v w\n  exact real_inner_comm v w\n\n"}
{"name":"inner‚Çó_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"F : Type u_3\ninst‚úù¬π : SeminormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nv w : F\n‚ä¢ Eq (((inner‚Çó F) v) w) (Inner.inner v w)","decl":"@[simp] lemma inner‚Çó_apply (v w : F) : inner‚Çó F v w = ‚ü™v, w‚ü´_‚Ñù := rfl\n\n"}
{"name":"innerSL_apply_coe","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv : E\n‚ä¢ Eq ‚áë((innerSL ùïú) v) fun w => Inner.inner v w","decl":"@[simp]\ntheorem innerSL_apply_coe (v : E) : ‚áë(innerSL ùïú v) = fun w => ‚ü™v, w‚ü´ :=\n  rfl\n\n"}
{"name":"innerSL_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nv w : E\n‚ä¢ Eq (((innerSL ùïú) v) w) (Inner.inner v w)","decl":"@[simp]\ntheorem innerSL_apply (v w : E) : innerSL ùïú v w = ‚ü™v, w‚ü´ :=\n  rfl\n\n"}
{"name":"innerSLFlip_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nx y : E\n‚ä¢ Eq (((innerSLFlip ùïú) x) y) (Inner.inner y x)","decl":"@[simp]\ntheorem innerSLFlip_apply (x y : E) : innerSLFlip ùïú x y = ‚ü™y, x‚ü´ :=\n  rfl\n\n"}
{"name":"innerSL_real_flip","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"F : Type u_3\ninst‚úù¬π : SeminormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\n‚ä¢ Eq (innerSL Real).flip (innerSL Real)","decl":"variable (F) in\n@[simp] lemma innerSL_real_flip : (innerSL ‚Ñù (E := F)).flip = innerSL ‚Ñù := by\n  ext v w\n  exact real_inner_comm _ _\n\n"}
{"name":"ContinuousLinearMap.toSesqForm_apply_coe","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nE' : Type u_4\ninst‚úù¬π : SeminormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : ContinuousLinearMap (RingHom.id ùïú) E E'\nx : E'\n‚ä¢ Eq ((ContinuousLinearMap.toSesqForm f) x) (((innerSL ùïú) x).comp f)","decl":"@[simp]\ntheorem toSesqForm_apply_coe (f : E ‚ÜíL[ùïú] E') (x : E') : toSesqForm f x = (innerSL ùïú x).comp f :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.toSesqForm_apply_norm_le","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : RCLike ùïú\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : InnerProductSpace ùïú E\nE' : Type u_4\ninst‚úù¬π : SeminormedAddCommGroup E'\ninst‚úù : InnerProductSpace ùïú E'\nf : ContinuousLinearMap (RingHom.id ùïú) E E'\nv : E'\n‚ä¢ LE.le (Norm.norm ((ContinuousLinearMap.toSesqForm f) v)) (HMul.hMul (Norm.norm f) (Norm.norm v))","decl":"theorem toSesqForm_apply_norm_le {f : E ‚ÜíL[ùïú] E'} {v : E'} : ‚ÄñtoSesqForm f v‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñv‚Äñ := by\n  refine opNorm_le_bound _ (by positivity) fun x ‚Ü¶ ?_\n  have h‚ÇÅ : ‚Äñf x‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñx‚Äñ := le_opNorm _ _\n  have h‚ÇÇ := @norm_inner_le_norm ùïú E' _ _ _ v (f x)\n  calc\n    ‚Äñ‚ü™v, f x‚ü´‚Äñ ‚â§ ‚Äñv‚Äñ * ‚Äñf x‚Äñ := h‚ÇÇ\n    _ ‚â§ ‚Äñv‚Äñ * (‚Äñf‚Äñ * ‚Äñx‚Äñ) := mul_le_mul_of_nonneg_left h‚ÇÅ (norm_nonneg v)\n    _ = ‚Äñf‚Äñ * ‚Äñv‚Äñ * ‚Äñx‚Äñ := by ring\n\n"}
{"name":"innerSL_apply_norm","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nx : E\n‚ä¢ Eq (Norm.norm ((innerSL ùïú) x)) (Norm.norm x)","decl":"/-- `innerSL` is an isometry. Note that the associated `LinearIsometry` is defined in\n`InnerProductSpace.Dual` as `toDualMap`. -/\n@[simp]\ntheorem innerSL_apply_norm (x : E) : ‚ÄñinnerSL ùïú x‚Äñ = ‚Äñx‚Äñ := by\n  refine\n    le_antisymm ((innerSL ùïú x).opNorm_le_bound (norm_nonneg _) fun y => norm_inner_le_norm _ _) ?_\n  rcases (norm_nonneg x).eq_or_gt with (h | h)\n  ¬∑ simp [h]\n  ¬∑ refine (mul_le_mul_right h).mp ?_\n    calc\n      ‚Äñx‚Äñ * ‚Äñx‚Äñ = ‚Äñ(‚ü™x, x‚ü´ : ùïú)‚Äñ := by\n        rw [‚Üê sq, inner_self_eq_norm_sq_to_K, norm_pow, norm_ofReal, abs_norm]\n      _ ‚â§ ‚ÄñinnerSL ùïú x‚Äñ * ‚Äñx‚Äñ := (innerSL ùïú x).le_opNorm _\n\n"}
{"name":"norm_innerSL_le","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\n‚ä¢ LE.le (Norm.norm (innerSL ùïú)) 1","decl":"lemma norm_innerSL_le : ‚ÄñinnerSL ùïú (E := E)‚Äñ ‚â§ 1 :=\n  ContinuousLinearMap.opNorm_le_bound _ zero_le_one (by simp)\n\n"}
{"name":"inner_map_complex","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"G : Type u_4\ninst‚úù¬π : SeminormedAddCommGroup G\ninst‚úù : InnerProductSpace Real G\nf : LinearIsometryEquiv (RingHom.id Real) G Complex\nx y : G\n‚ä¢ Eq (Inner.inner x y) (HMul.hMul ((starRingEnd Complex) (f x)) (f y)).re","decl":"/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem inner_map_complex [SeminormedAddCommGroup G] [InnerProductSpace ‚Ñù G] (f : G ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ)\n    (x y : G) : ‚ü™x, y‚ü´_‚Ñù = (conj (f x) * f y).re := by rw [‚Üê Complex.inner, f.inner_map_map]\n\n"}
{"name":"ContinuousLinearMap.reApplyInnerSelf_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nT : ContinuousLinearMap (RingHom.id ùïú) E E\nx : E\n‚ä¢ Eq (T.reApplyInnerSelf x) (RCLike.re (Inner.inner (T x) x))","decl":"theorem ContinuousLinearMap.reApplyInnerSelf_apply (T : E ‚ÜíL[ùïú] E) (x : E) :\n    T.reApplyInnerSelf x = re ‚ü™T x, x‚ü´ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.reApplyInnerSelf_continuous","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nT : ContinuousLinearMap (RingHom.id ùïú) E E\n‚ä¢ Continuous T.reApplyInnerSelf","decl":"theorem ContinuousLinearMap.reApplyInnerSelf_continuous (T : E ‚ÜíL[ùïú] E) :\n    Continuous T.reApplyInnerSelf :=\n  reCLM.continuous.comp <| T.continuous.inner continuous_id\n\n"}
{"name":"ContinuousLinearMap.reApplyInnerSelf_smul","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\nT : ContinuousLinearMap (RingHom.id ùïú) E E\nx : E\nc : ùïú\n‚ä¢ Eq (T.reApplyInnerSelf (HSMul.hSMul c x)) (HMul.hMul (HPow.hPow (Norm.norm c) 2) (T.reApplyInnerSelf x))","decl":"theorem ContinuousLinearMap.reApplyInnerSelf_smul (T : E ‚ÜíL[ùïú] E) (x : E) {c : ùïú} :\n    T.reApplyInnerSelf (c ‚Ä¢ x) = ‚Äñc‚Äñ ^ 2 * T.reApplyInnerSelf x := by\n  simp only [ContinuousLinearMap.map_smul, ContinuousLinearMap.reApplyInnerSelf_apply,\n    inner_smul_left, inner_smul_right, ‚Üê mul_assoc, mul_conj, ‚Üê ofReal_pow, ‚Üê smul_re,\n    Algebra.smul_def (‚Äñc‚Äñ ^ 2) ‚ü™T x, x‚ü´, algebraMap_eq_ofReal]\n\n"}
