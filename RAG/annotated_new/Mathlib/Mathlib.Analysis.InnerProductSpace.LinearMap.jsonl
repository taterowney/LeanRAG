{"name":"inner_map_polarization","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"V : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup V\ninstâœ : InnerProductSpace Complex V\nT : LinearMap (RingHom.id Complex) V V\nx y : V\nâŠ¢ Eq (Inner.inner (T y) x) (HDiv.hDiv (HSub.hSub (HAdd.hAdd (HSub.hSub (Inner.inner (T (HAdd.hAdd x y)) (HAdd.hAdd x y)) (Inner.inner (T (HSub.hSub x y)) (HSub.hSub x y))) (HMul.hMul Complex.I (Inner.inner (T (HAdd.hAdd x (HSMul.hSMul Complex.I y))) (HAdd.hAdd x (HSMul.hSMul Complex.I y))))) (HMul.hMul Complex.I (Inner.inner (T (HSub.hSub x (HSMul.hSMul Complex.I y))) (HSub.hSub x (HSMul.hSMul Complex.I y))))) 4)","decl":"/-- A complex polarization identity, with a linear map. -/\ntheorem inner_map_polarization (T : V â†’â‚—[â„‚] V) (x y : V) :\n    âŸªT y, xâŸ«_â„‚ =\n      (âŸªT (x + y), x + yâŸ«_â„‚ - âŸªT (x - y), x - yâŸ«_â„‚ +\n            Complex.I * âŸªT (x + Complex.I â€¢ y), x + Complex.I â€¢ yâŸ«_â„‚ -\n          Complex.I * âŸªT (x - Complex.I â€¢ y), x - Complex.I â€¢ yâŸ«_â„‚) /\n        4 := by\n  simp only [map_add, map_sub, inner_add_left, inner_add_right, LinearMap.map_smul, inner_smul_left,\n    inner_smul_right, Complex.conj_I, â† pow_two, Complex.I_sq, inner_sub_left, inner_sub_right,\n    mul_add, â† mul_assoc, mul_neg, neg_neg, sub_neg_eq_add, one_mul, neg_one_mul, mul_sub, sub_sub]\n  ring\n\n"}
{"name":"inner_map_polarization'","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"V : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup V\ninstâœ : InnerProductSpace Complex V\nT : LinearMap (RingHom.id Complex) V V\nx y : V\nâŠ¢ Eq (Inner.inner (T x) y) (HDiv.hDiv (HAdd.hAdd (HSub.hSub (HSub.hSub (Inner.inner (T (HAdd.hAdd x y)) (HAdd.hAdd x y)) (Inner.inner (T (HSub.hSub x y)) (HSub.hSub x y))) (HMul.hMul Complex.I (Inner.inner (T (HAdd.hAdd x (HSMul.hSMul Complex.I y))) (HAdd.hAdd x (HSMul.hSMul Complex.I y))))) (HMul.hMul Complex.I (Inner.inner (T (HSub.hSub x (HSMul.hSMul Complex.I y))) (HSub.hSub x (HSMul.hSMul Complex.I y))))) 4)","decl":"theorem inner_map_polarization' (T : V â†’â‚—[â„‚] V) (x y : V) :\n    âŸªT x, yâŸ«_â„‚ =\n      (âŸªT (x + y), x + yâŸ«_â„‚ - âŸªT (x - y), x - yâŸ«_â„‚ -\n            Complex.I * âŸªT (x + Complex.I â€¢ y), x + Complex.I â€¢ yâŸ«_â„‚ +\n          Complex.I * âŸªT (x - Complex.I â€¢ y), x - Complex.I â€¢ yâŸ«_â„‚) /\n        4 := by\n  simp only [map_add, map_sub, inner_add_left, inner_add_right, LinearMap.map_smul, inner_smul_left,\n    inner_smul_right, Complex.conj_I, â† pow_two, Complex.I_sq, inner_sub_left, inner_sub_right,\n    mul_add, â† mul_assoc, mul_neg, neg_neg, sub_neg_eq_add, one_mul, neg_one_mul, mul_sub, sub_sub]\n  ring\n\n"}
{"name":"inner_map_self_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"V : Type u_4\ninstâœÂ¹ : NormedAddCommGroup V\ninstâœ : InnerProductSpace Complex V\nT : LinearMap (RingHom.id Complex) V V\nâŠ¢ Iff (âˆ€ (x : V), Eq (Inner.inner (T x) x) 0) (Eq T 0)","decl":"/-- A linear map `T` is zero, if and only if the identity `âŸªT x, xâŸ«_â„‚ = 0` holds for all `x`.\n-/\ntheorem inner_map_self_eq_zero (T : V â†’â‚—[â„‚] V) : (âˆ€ x : V, âŸªT x, xâŸ«_â„‚ = 0) â†” T = 0 := by\n  constructor\n  Â· intro hT\n    ext x\n    rw [LinearMap.zero_apply, â† @inner_self_eq_zero â„‚ V, inner_map_polarization]\n    simp only [hT]\n    norm_num\n  Â· rintro rfl x\n    simp only [LinearMap.zero_apply, inner_zero_left]\n\n"}
{"name":"ext_inner_map","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"V : Type u_4\ninstâœÂ¹ : NormedAddCommGroup V\ninstâœ : InnerProductSpace Complex V\nS T : LinearMap (RingHom.id Complex) V V\nâŠ¢ Iff (âˆ€ (x : V), Eq (Inner.inner (S x) x) (Inner.inner (T x) x)) (Eq S T)","decl":"/--\nTwo linear maps `S` and `T` are equal, if and only if the identity `âŸªS x, xâŸ«_â„‚ = âŸªT x, xâŸ«_â„‚` holds\nfor all `x`.\n-/\ntheorem ext_inner_map (S T : V â†’â‚—[â„‚] V) : (âˆ€ x : V, âŸªS x, xâŸ«_â„‚ = âŸªT x, xâŸ«_â„‚) â†” S = T := by\n  rw [â† sub_eq_zero, â† inner_map_self_eq_zero]\n  refine forall_congr' fun x => ?_\n  rw [LinearMap.sub_apply, inner_sub_left, sub_eq_zero]\n\n"}
{"name":"LinearIsometry.inner_map_map","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearIsometry (RingHom.id ğ•œ) E E'\nx y : E\nâŠ¢ Eq (Inner.inner (f x) (f y)) (Inner.inner x y)","decl":"/-- A linear isometry preserves the inner product. -/\n@[simp]\ntheorem LinearIsometry.inner_map_map (f : E â†’â‚—áµ¢[ğ•œ] E') (x y : E) : âŸªf x, f yâŸ« = âŸªx, yâŸ« := by\n  simp [inner_eq_sum_norm_sq_div_four, â† f.norm_map]\n\n"}
{"name":"LinearIsometryEquiv.inner_map_map","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E E'\nx y : E\nâŠ¢ Eq (Inner.inner (f x) (f y)) (Inner.inner x y)","decl":"/-- A linear isometric equivalence preserves the inner product. -/\n@[simp]\ntheorem LinearIsometryEquiv.inner_map_map (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (x y : E) : âŸªf x, f yâŸ« = âŸªx, yâŸ« :=\n  f.toLinearIsometry.inner_map_map x y\n\n"}
{"name":"LinearIsometryEquiv.inner_map_eq_flip","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E E'\nx : E\ny : E'\nâŠ¢ Eq (Inner.inner (f x) y) (Inner.inner x (f.symm y))","decl":"/-- The adjoint of a linear isometric equivalence is its inverse. -/\ntheorem LinearIsometryEquiv.inner_map_eq_flip (f : E â‰ƒâ‚—áµ¢[ğ•œ] E') (x : E) (y : E') :\n    âŸªf x, yâŸ«_ğ•œ = âŸªx, f.symm yâŸ«_ğ•œ := by\n  conv_lhs => rw [â† f.apply_symm_apply y, f.inner_map_map]\n\n"}
{"name":"LinearMap.coe_isometryOfInner","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearMap (RingHom.id ğ•œ) E E'\nh : âˆ€ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y)\nâŠ¢ Eq â‡‘(f.isometryOfInner h) â‡‘f","decl":"@[simp]\ntheorem LinearMap.coe_isometryOfInner (f : E â†’â‚—[ğ•œ] E') (h) : â‡‘(f.isometryOfInner h) = f :=\n  rfl\n\n"}
{"name":"LinearMap.isometryOfInner_toLinearMap","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearMap (RingHom.id ğ•œ) E E'\nh : âˆ€ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y)\nâŠ¢ Eq (f.isometryOfInner h).toLinearMap f","decl":"@[simp]\ntheorem LinearMap.isometryOfInner_toLinearMap (f : E â†’â‚—[ğ•œ] E') (h) :\n    (f.isometryOfInner h).toLinearMap = f :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_isometryOfInner","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearEquiv (RingHom.id ğ•œ) E E'\nh : âˆ€ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y)\nâŠ¢ Eq â‡‘(f.isometryOfInner h) â‡‘f","decl":"@[simp]\ntheorem LinearEquiv.coe_isometryOfInner (f : E â‰ƒâ‚—[ğ•œ] E') (h) : â‡‘(f.isometryOfInner h) = f :=\n  rfl\n\n"}
{"name":"LinearEquiv.isometryOfInner_toLinearEquiv","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nE' : Type u_7\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : LinearEquiv (RingHom.id ğ•œ) E E'\nh : âˆ€ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y)\nâŠ¢ Eq (f.isometryOfInner h).toLinearEquiv f","decl":"@[simp]\ntheorem LinearEquiv.isometryOfInner_toLinearEquiv (f : E â‰ƒâ‚—[ğ•œ] E') (h) :\n    (f.isometryOfInner h).toLinearEquiv = f :=\n  rfl\n\n"}
{"name":"LinearMap.norm_map_iff_inner_map_map","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : InnerProductSpace ğ•œ E\nE' : Type u_7\ninstâœÂ³ : SeminormedAddCommGroup E'\ninstâœÂ² : InnerProductSpace ğ•œ E'\nF : Type u_9\ninstâœÂ¹ : FunLike F E E'\ninstâœ : LinearMapClass F ğ•œ E E'\nf : F\nâŠ¢ Iff (âˆ€ (x : E), Eq (Norm.norm (f x)) (Norm.norm x)) (âˆ€ (x y : E), Eq (Inner.inner (f x) (f y)) (Inner.inner x y))","decl":"/-- A linear map is an isometry if and it preserves the inner product. -/\ntheorem LinearMap.norm_map_iff_inner_map_map {F : Type*} [FunLike F E E'] [LinearMapClass F ğ•œ E E']\n    (f : F) : (âˆ€ x, â€–f xâ€– = â€–xâ€–) â†” (âˆ€ x y, âŸªf x, f yâŸ«_ğ•œ = âŸªx, yâŸ«_ğ•œ) :=\n  âŸ¨({ toLinearMap := LinearMapClass.linearMap f, norm_map' := Â· : E â†’â‚—áµ¢[ğ•œ] E' }.inner_map_map),\n    (LinearMapClass.linearMap f |>.isometryOfInner Â· |>.norm_map)âŸ©\n\n"}
{"name":"innerâ‚›â‚—_apply_coe","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv : E\nâŠ¢ Eq â‡‘((innerâ‚›â‚— ğ•œ) v) fun w => Inner.inner v w","decl":"@[simp]\ntheorem innerâ‚›â‚—_apply_coe (v : E) : â‡‘(innerâ‚›â‚— ğ•œ v) = fun w => âŸªv, wâŸ« :=\n  rfl\n\n"}
{"name":"innerâ‚›â‚—_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv w : E\nâŠ¢ Eq (((innerâ‚›â‚— ğ•œ) v) w) (Inner.inner v w)","decl":"@[simp]\ntheorem innerâ‚›â‚—_apply (v w : E) : innerâ‚›â‚— ğ•œ v w = âŸªv, wâŸ« :=\n  rfl\n\n"}
{"name":"flip_innerâ‚—","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nâŠ¢ Eq (innerâ‚— F).flip (innerâ‚— F)","decl":"@[simp] lemma flip_innerâ‚— : (innerâ‚— F).flip = innerâ‚— F := by\n  ext v w\n  exact real_inner_comm v w\n\n"}
{"name":"innerâ‚—_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nv w : F\nâŠ¢ Eq (((innerâ‚— F) v) w) (Inner.inner v w)","decl":"@[simp] lemma innerâ‚—_apply (v w : F) : innerâ‚— F v w = âŸªv, wâŸ«_â„ := rfl\n\n"}
{"name":"innerSL_apply_coe","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv : E\nâŠ¢ Eq â‡‘((innerSL ğ•œ) v) fun w => Inner.inner v w","decl":"@[simp]\ntheorem innerSL_apply_coe (v : E) : â‡‘(innerSL ğ•œ v) = fun w => âŸªv, wâŸ« :=\n  rfl\n\n"}
{"name":"innerSL_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv w : E\nâŠ¢ Eq (((innerSL ğ•œ) v) w) (Inner.inner v w)","decl":"@[simp]\ntheorem innerSL_apply (v w : E) : innerSL ğ•œ v w = âŸªv, wâŸ« :=\n  rfl\n\n"}
{"name":"innerSLFlip_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (((innerSLFlip ğ•œ) x) y) (Inner.inner y x)","decl":"@[simp]\ntheorem innerSLFlip_apply (x y : E) : innerSLFlip ğ•œ x y = âŸªy, xâŸ« :=\n  rfl\n\n"}
{"name":"innerSL_real_flip","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nâŠ¢ Eq (innerSL Real).flip (innerSL Real)","decl":"variable (F) in\n@[simp] lemma innerSL_real_flip : (innerSL â„ (E := F)).flip = innerSL â„ := by\n  ext v w\n  exact real_inner_comm _ _\n\n"}
{"name":"ContinuousLinearMap.toSesqForm_apply_coe","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nE' : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : ContinuousLinearMap (RingHom.id ğ•œ) E E'\nx : E'\nâŠ¢ Eq ((ContinuousLinearMap.toSesqForm f) x) (((innerSL ğ•œ) x).comp f)","decl":"@[simp]\ntheorem toSesqForm_apply_coe (f : E â†’L[ğ•œ] E') (x : E') : toSesqForm f x = (innerSL ğ•œ x).comp f :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.toSesqForm_apply_norm_le","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\nE' : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup E'\ninstâœ : InnerProductSpace ğ•œ E'\nf : ContinuousLinearMap (RingHom.id ğ•œ) E E'\nv : E'\nâŠ¢ LE.le (Norm.norm ((ContinuousLinearMap.toSesqForm f) v)) (HMul.hMul (Norm.norm f) (Norm.norm v))","decl":"theorem toSesqForm_apply_norm_le {f : E â†’L[ğ•œ] E'} {v : E'} : â€–toSesqForm f vâ€– â‰¤ â€–fâ€– * â€–vâ€– := by\n  refine opNorm_le_bound _ (by positivity) fun x â†¦ ?_\n  have hâ‚ : â€–f xâ€– â‰¤ â€–fâ€– * â€–xâ€– := le_opNorm _ _\n  have hâ‚‚ := @norm_inner_le_norm ğ•œ E' _ _ _ v (f x)\n  calc\n    â€–âŸªv, f xâŸ«â€– â‰¤ â€–vâ€– * â€–f xâ€– := hâ‚‚\n    _ â‰¤ â€–vâ€– * (â€–fâ€– * â€–xâ€–) := mul_le_mul_of_nonneg_left hâ‚ (norm_nonneg v)\n    _ = â€–fâ€– * â€–vâ€– * â€–xâ€– := by ring\n\n"}
{"name":"innerSL_apply_norm","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (Norm.norm ((innerSL ğ•œ) x)) (Norm.norm x)","decl":"/-- `innerSL` is an isometry. Note that the associated `LinearIsometry` is defined in\n`InnerProductSpace.Dual` as `toDualMap`. -/\n@[simp]\ntheorem innerSL_apply_norm (x : E) : â€–innerSL ğ•œ xâ€– = â€–xâ€– := by\n  refine\n    le_antisymm ((innerSL ğ•œ x).opNorm_le_bound (norm_nonneg _) fun y => norm_inner_le_norm _ _) ?_\n  rcases (norm_nonneg x).eq_or_gt with (h | h)\n  Â· simp [h]\n  Â· refine (mul_le_mul_right h).mp ?_\n    calc\n      â€–xâ€– * â€–xâ€– = â€–(âŸªx, xâŸ« : ğ•œ)â€– := by\n        rw [â† sq, inner_self_eq_norm_sq_to_K, norm_pow, norm_ofReal, abs_norm]\n      _ â‰¤ â€–innerSL ğ•œ xâ€– * â€–xâ€– := (innerSL ğ•œ x).le_opNorm _\n\n"}
{"name":"norm_innerSL_le","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ LE.le (Norm.norm (innerSL ğ•œ)) 1","decl":"lemma norm_innerSL_le : â€–innerSL ğ•œ (E := E)â€– â‰¤ 1 :=\n  ContinuousLinearMap.opNorm_le_bound _ zero_le_one (by simp)\n\n"}
{"name":"inner_map_complex","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"G : Type u_4\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : InnerProductSpace Real G\nf : LinearIsometryEquiv (RingHom.id Real) G Complex\nx y : G\nâŠ¢ Eq (Inner.inner x y) (HMul.hMul ((starRingEnd Complex) (f x)) (f y)).re","decl":"/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem inner_map_complex [SeminormedAddCommGroup G] [InnerProductSpace â„ G] (f : G â‰ƒâ‚—áµ¢[â„] â„‚)\n    (x y : G) : âŸªx, yâŸ«_â„ = (conj (f x) * f y).re := by rw [â† Complex.inner, f.inner_map_map]\n\n"}
{"name":"ContinuousLinearMap.reApplyInnerSelf_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nx : E\nâŠ¢ Eq (T.reApplyInnerSelf x) (RCLike.re (Inner.inner (T x) x))","decl":"theorem ContinuousLinearMap.reApplyInnerSelf_apply (T : E â†’L[ğ•œ] E) (x : E) :\n    T.reApplyInnerSelf x = re âŸªT x, xâŸ« :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.reApplyInnerSelf_continuous","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Continuous T.reApplyInnerSelf","decl":"theorem ContinuousLinearMap.reApplyInnerSelf_continuous (T : E â†’L[ğ•œ] E) :\n    Continuous T.reApplyInnerSelf :=\n  reCLM.continuous.comp <| T.continuous.inner continuous_id\n\n"}
{"name":"ContinuousLinearMap.reApplyInnerSelf_smul","module":"Mathlib.Analysis.InnerProductSpace.LinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nx : E\nc : ğ•œ\nâŠ¢ Eq (T.reApplyInnerSelf (HSMul.hSMul c x)) (HMul.hMul (HPow.hPow (Norm.norm c) 2) (T.reApplyInnerSelf x))","decl":"theorem ContinuousLinearMap.reApplyInnerSelf_smul (T : E â†’L[ğ•œ] E) (x : E) {c : ğ•œ} :\n    T.reApplyInnerSelf (c â€¢ x) = â€–câ€– ^ 2 * T.reApplyInnerSelf x := by\n  simp only [ContinuousLinearMap.map_smul, ContinuousLinearMap.reApplyInnerSelf_apply,\n    inner_smul_left, inner_smul_right, â† mul_assoc, mul_conj, â† ofReal_pow, â† smul_re,\n    Algebra.smul_def (â€–câ€– ^ 2) âŸªT x, xâŸ«, algebraMap_eq_ofReal]\n\n"}
