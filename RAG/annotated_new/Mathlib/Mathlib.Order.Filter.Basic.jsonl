{"name":"Filter.filter_eq_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nâŠ¢ Iff (Eq f g) (Eq f.sets g.sets)","decl":"theorem filter_eq_iff : f = g â†” f.sets = g.sets :=\n  âŸ¨congr_arg _, filter_eqâŸ©\n\n"}
{"name":"Filter.sets_subset_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nâŠ¢ Iff (HasSubset.Subset f.sets g.sets) (LE.le g f)","decl":"@[simp] theorem sets_subset_sets : f.sets âŠ† g.sets â†” g â‰¤ f := .rfl\n"}
{"name":"Filter.sets_ssubset_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nâŠ¢ Iff (HasSSubset.SSubset f.sets g.sets) (LT.lt g f)","decl":"@[simp] theorem sets_ssubset_sets : f.sets âŠ‚ g.sets â†” g < f := .rfl\n\n"}
{"name":"Filter.coext","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nh : âˆ€ (s : Set Î±), Iff (Membership.mem f (HasCompl.compl s)) (Membership.mem g (HasCompl.compl s))\nâŠ¢ Eq f g","decl":"/-- An extensionality lemma that is useful for filters with good lemmas about `sá¶œ âˆˆ f` (e.g.,\n`Filter.comap`, `Filter.coprod`, `Filter.Coprod`, `Filter.cofinite`). -/\nprotected theorem coext (h : âˆ€ s, sá¶œ âˆˆ f â†” sá¶œ âˆˆ g) : f = g :=\n  Filter.ext <| compl_surjective.forall.2 h\n\n"}
{"name":"Filter.inter_mem_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns t : Set Î±\nâŠ¢ Iff (Membership.mem f (Inter.inter s t)) (And (Membership.mem f s) (Membership.mem f t))","decl":"@[simp]\ntheorem inter_mem_iff {s t : Set Î±} : s âˆ© t âˆˆ f â†” s âˆˆ f âˆ§ t âˆˆ f :=\n  âŸ¨fun h => âŸ¨mem_of_superset h inter_subset_left, mem_of_superset h inter_subset_rightâŸ©,\n    and_imp.2 inter_memâŸ©\n\n"}
{"name":"Filter.diff_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns t : Set Î±\nhs : Membership.mem f s\nht : Membership.mem f (HasCompl.compl t)\nâŠ¢ Membership.mem f (SDiff.sdiff s t)","decl":"theorem diff_mem {s t : Set Î±} (hs : s âˆˆ f) (ht : tá¶œ âˆˆ f) : s \\ t âˆˆ f :=\n  inter_mem hs ht\n\n"}
{"name":"Filter.congr_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns t : Set Î±\nh : Membership.mem f (setOf fun x => Iff (Membership.mem s x) (Membership.mem t x))\nâŠ¢ Iff (Membership.mem f s) (Membership.mem f t)","decl":"theorem congr_sets (h : { x | x âˆˆ s â†” x âˆˆ t } âˆˆ f) : s âˆˆ f â†” t âˆˆ f :=\n  âŸ¨fun hs => mp_mem hs (mem_of_superset h fun _ => Iff.mp), fun hs =>\n    mp_mem hs (mem_of_superset h fun _ => Iff.mpr)âŸ©\n\n"}
{"name":"Filter.copy_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nS : Set (Set Î±)\nhmem : âˆ€ (s : Set Î±), Iff (Membership.mem S s) (Membership.mem f s)\nâŠ¢ Eq (f.copy S hmem) f","decl":"lemma copy_eq {S} (hmem : âˆ€ s, s âˆˆ S â†” s âˆˆ f) : f.copy S hmem = f := Filter.ext hmem\n\n"}
{"name":"Filter.biInter_mem'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nÎ² : Type v\ns : Î² â†’ Set Î±\nis : Set Î²\nhf : is.Subsingleton\nâŠ¢ Iff (Membership.mem f (Set.iInter fun i => Set.iInter fun h => s i)) (âˆ€ (i : Î²), Membership.mem is i â†’ Membership.mem f (s i))","decl":"/-- Weaker version of `Filter.biInter_mem` that assumes `Subsingleton Î²` rather than `Finite Î²`. -/\ntheorem biInter_mem' {Î² : Type v} {s : Î² â†’ Set Î±} {is : Set Î²} (hf : is.Subsingleton) :\n    (â‹‚ i âˆˆ is, s i) âˆˆ f â†” âˆ€ i âˆˆ is, s i âˆˆ f := by\n  apply Subsingleton.induction_on hf <;> simp\n\n"}
{"name":"Filter.iInter_mem'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nÎ² : Sort v\ns : Î² â†’ Set Î±\ninstâœ : Subsingleton Î²\nâŠ¢ Iff (Membership.mem f (Set.iInter fun i => s i)) (âˆ€ (i : Î²), Membership.mem f (s i))","decl":"/-- Weaker version of `Filter.iInter_mem` that assumes `Subsingleton Î²` rather than `Finite Î²`. -/\ntheorem iInter_mem' {Î² : Sort v} {s : Î² â†’ Set Î±} [Subsingleton Î²] :\n    (â‹‚ i, s i) âˆˆ f â†” âˆ€ i, s i âˆˆ f := by\n  rw [â† sInter_range, sInter_eq_biInter, biInter_mem' (subsingleton_range s), forall_mem_range]\n\n"}
{"name":"Filter.exists_mem_subset_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Exists fun t => And (Membership.mem f t) (HasSubset.Subset t s)) (Membership.mem f s)","decl":"theorem exists_mem_subset_iff : (âˆƒ t âˆˆ f, t âŠ† s) â†” s âˆˆ f :=\n  âŸ¨fun âŸ¨_, ht, tsâŸ© => mem_of_superset ht ts, fun hs => âŸ¨s, hs, Subset.rflâŸ©âŸ©\n\n"}
{"name":"Filter.monotone_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Monotone fun s => Membership.mem f s","decl":"theorem monotone_mem {f : Filter Î±} : Monotone fun s => s âˆˆ f := fun _ _ hst h =>\n  mem_of_superset h hst\n\n"}
{"name":"Filter.exists_mem_and_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nP Q : Set Î± â†’ Prop\nhP : Antitone P\nhQ : Antitone Q\nâŠ¢ Iff (And (Exists fun u => And (Membership.mem f u) (P u)) (Exists fun u => And (Membership.mem f u) (Q u))) (Exists fun u => And (Membership.mem f u) (And (P u) (Q u)))","decl":"theorem exists_mem_and_iff {P : Set Î± â†’ Prop} {Q : Set Î± â†’ Prop} (hP : Antitone P)\n    (hQ : Antitone Q) : ((âˆƒ u âˆˆ f, P u) âˆ§ âˆƒ u âˆˆ f, Q u) â†” âˆƒ u âˆˆ f, P u âˆ§ Q u := by\n  constructor\n  Â· rintro âŸ¨âŸ¨u, huf, hPuâŸ©, v, hvf, hQvâŸ©\n    exact\n      âŸ¨u âˆ© v, inter_mem huf hvf, hP inter_subset_left hPu, hQ inter_subset_right hQvâŸ©\n  Â· rintro âŸ¨u, huf, hPu, hQuâŸ©\n    exact âŸ¨âŸ¨u, huf, hPuâŸ©, u, huf, hQuâŸ©\n\n"}
{"name":"Filter.forall_in_swap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nÎ² : Type u_1\np : Set Î± â†’ Î² â†’ Prop\nâŠ¢ Iff (âˆ€ (a : Set Î±), Membership.mem f a â†’ âˆ€ (b : Î²), p a b) (âˆ€ (b : Î²) (a : Set Î±), Membership.mem f a â†’ p a b)","decl":"theorem forall_in_swap {Î² : Type*} {p : Set Î± â†’ Î² â†’ Prop} :\n    (âˆ€ a âˆˆ f, âˆ€ (b), p a b) â†” âˆ€ (b), âˆ€ a âˆˆ f, p a b :=\n  Set.forall_in_swap\n\n"}
{"name":"Filter.mem_principal_self","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nâŠ¢ Membership.mem (Filter.principal s) s","decl":"theorem mem_principal_self (s : Set Î±) : s âˆˆ ğ“Ÿ s := Subset.rfl\n\n"}
{"name":"Filter.not_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nâŠ¢ Iff (Not (LE.le f g)) (Exists fun s => And (Membership.mem g s) (Not (Membership.mem f s)))","decl":"protected theorem not_le : Â¬f â‰¤ g â†” âˆƒ s âˆˆ g, s âˆ‰ f := by simp_rw [le_def, not_forall, exists_prop]\n\n"}
{"name":"Filter.mem_generate_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nU : Set Î±\nh : Membership.mem s U\nâŠ¢ Membership.mem (Filter.generate s) U","decl":"lemma mem_generate_of_mem {s : Set <| Set Î±} {U : Set Î±} (h : U âˆˆ s) :\n    U âˆˆ generate s := GenerateSets.basic h\n\n"}
{"name":"Filter.le_generate_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nf : Filter Î±\nâŠ¢ Iff (LE.le f (Filter.generate s)) (HasSubset.Subset s f.sets)","decl":"theorem le_generate_iff {s : Set (Set Î±)} {f : Filter Î±} : f â‰¤ generate s â†” s âŠ† f.sets :=\n  Iff.intro (fun h _ hu => h <| GenerateSets.basic <| hu) fun h _ hu =>\n    hu.recOn (fun h' => h h') univ_mem (fun _ hxy hx => mem_of_superset hx hxy) fun _ _ hx hy =>\n      inter_mem hx hy\n\n"}
{"name":"Filter.generate_singleton","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nâŠ¢ Eq (Filter.generate (Singleton.singleton s)) (Filter.principal s)","decl":"@[simp] lemma generate_singleton (s : Set Î±) : generate {s} = ğ“Ÿ s :=\n  le_antisymm (fun _t ht â†¦ mem_of_superset (mem_generate_of_mem <| mem_singleton _) ht) <|\n    le_generate_iff.2 <| singleton_subset_iff.2 Subset.rfl\n\n"}
{"name":"Filter.mkOfClosure_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nhs : Eq (Filter.generate s).sets s\nâŠ¢ Eq (Filter.mkOfClosure s hs) (Filter.generate s)","decl":"theorem mkOfClosure_sets {s : Set (Set Î±)} {hs : (generate s).sets = s} :\n    Filter.mkOfClosure s hs = generate s :=\n  Filter.ext fun u =>\n    show u âˆˆ (Filter.mkOfClosure s hs).sets â†” u âˆˆ (generate s).sets from hs.symm â–¸ Iff.rfl\n\n"}
{"name":"Filter.mem_inf_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Min.min f g) s) (Exists fun tâ‚ => And (Membership.mem f tâ‚) (Exists fun tâ‚‚ => And (Membership.mem g tâ‚‚) (Eq s (Inter.inter tâ‚ tâ‚‚))))","decl":"theorem mem_inf_iff {f g : Filter Î±} {s : Set Î±} : s âˆˆ f âŠ“ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, s = tâ‚ âˆ© tâ‚‚ :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_inf_of_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\ns : Set Î±\nh : Membership.mem f s\nâŠ¢ Membership.mem (Min.min f g) s","decl":"theorem mem_inf_of_left {f g : Filter Î±} {s : Set Î±} (h : s âˆˆ f) : s âˆˆ f âŠ“ g :=\n  âŸ¨s, h, univ, univ_mem, (inter_univ s).symmâŸ©\n\n"}
{"name":"Filter.mem_inf_of_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\ns : Set Î±\nh : Membership.mem g s\nâŠ¢ Membership.mem (Min.min f g) s","decl":"theorem mem_inf_of_right {f g : Filter Î±} {s : Set Î±} (h : s âˆˆ g) : s âˆˆ f âŠ“ g :=\n  âŸ¨univ, univ_mem, s, h, (univ_inter s).symmâŸ©\n\n"}
{"name":"Filter.inter_mem_inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\ns t : Set Î±\nhs : Membership.mem f s\nht : Membership.mem g t\nâŠ¢ Membership.mem (Min.min f g) (Inter.inter s t)","decl":"theorem inter_mem_inf {Î± : Type u} {f g : Filter Î±} {s t : Set Î±} (hs : s âˆˆ f) (ht : t âˆˆ g) :\n    s âˆ© t âˆˆ f âŠ“ g :=\n  âŸ¨s, hs, t, ht, rflâŸ©\n\n"}
{"name":"Filter.mem_inf_of_inter","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\ns t u : Set Î±\nhs : Membership.mem f s\nht : Membership.mem g t\nh : HasSubset.Subset (Inter.inter s t) u\nâŠ¢ Membership.mem (Min.min f g) u","decl":"theorem mem_inf_of_inter {f g : Filter Î±} {s t u : Set Î±} (hs : s âˆˆ f) (ht : t âˆˆ g)\n    (h : s âˆ© t âŠ† u) : u âˆˆ f âŠ“ g :=\n  mem_of_superset (inter_mem_inf hs ht) h\n\n"}
{"name":"Filter.mem_inf_iff_superset","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Min.min f g) s) (Exists fun tâ‚ => And (Membership.mem f tâ‚) (Exists fun tâ‚‚ => And (Membership.mem g tâ‚‚) (HasSubset.Subset (Inter.inter tâ‚ tâ‚‚) s)))","decl":"theorem mem_inf_iff_superset {f g : Filter Î±} {s : Set Î±} :\n    s âˆˆ f âŠ“ g â†” âˆƒ tâ‚ âˆˆ f, âˆƒ tâ‚‚ âˆˆ g, tâ‚ âˆ© tâ‚‚ âŠ† s :=\n  âŸ¨fun âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, EqâŸ© => âŸ¨tâ‚, hâ‚, tâ‚‚, hâ‚‚, Eq â–¸ Subset.rflâŸ©, fun âŸ¨_, hâ‚, _, hâ‚‚, subâŸ© =>\n    mem_inf_of_inter hâ‚ hâ‚‚ subâŸ©\n\n"}
{"name":"Filter.NeBot.ne","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nhf : f.NeBot\nâŠ¢ Ne f Bot.bot","decl":"theorem NeBot.ne {f : Filter Î±} (hf : NeBot f) : f â‰  âŠ¥ := hf.ne'\n\n"}
{"name":"Filter.not_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Iff (Not f.NeBot) (Eq f Bot.bot)","decl":"@[simp] theorem not_neBot {f : Filter Î±} : Â¬f.NeBot â†” f = âŠ¥ := neBot_iff.not_left\n\n"}
{"name":"Filter.NeBot.mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nhf : f.NeBot\nhg : LE.le f g\nâŠ¢ g.NeBot","decl":"theorem NeBot.mono {f g : Filter Î±} (hf : NeBot f) (hg : f â‰¤ g) : NeBot g :=\n  âŸ¨ne_bot_of_le_ne_bot hf.1 hgâŸ©\n\n"}
{"name":"Filter.neBot_of_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nhf : f.NeBot\nhg : LE.le f g\nâŠ¢ g.NeBot","decl":"theorem neBot_of_le {f g : Filter Î±} [hf : NeBot f] (hg : f â‰¤ g) : NeBot g :=\n  hf.mono hg\n\n"}
{"name":"Filter.sup_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nâŠ¢ Iff (Max.max f g).NeBot (Or f.NeBot g.NeBot)","decl":"@[simp] theorem sup_neBot {f g : Filter Î±} : NeBot (f âŠ” g) â†” NeBot f âˆ¨ NeBot g := by\n  simp only [neBot_iff, not_and_or, Ne, sup_eq_bot_iff]\n\n"}
{"name":"Filter.not_disjoint_self_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Iff (Not (Disjoint f f)) f.NeBot","decl":"theorem not_disjoint_self_iff : Â¬Disjoint f f â†” f.NeBot := by rw [disjoint_self, neBot_iff]\n\n"}
{"name":"Filter.bot_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nâŠ¢ Eq Bot.bot.sets Set.univ","decl":"theorem bot_sets_eq : (âŠ¥ : Filter Î±).sets = univ := rfl\n\n"}
{"name":"Filter.eq_or_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Or (Eq f Bot.bot) f.NeBot","decl":"/-- Either `f = âŠ¥` or `Filter.NeBot f`. This is a version of `eq_or_ne` that uses `Filter.NeBot`\nas the second alternative, to be used as an instance. -/\ntheorem eq_or_neBot (f : Filter Î±) : f = âŠ¥ âˆ¨ NeBot f := (eq_or_ne f âŠ¥).imp_right NeBot.mk\n\n"}
{"name":"Filter.sup_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nâŠ¢ Eq (Max.max f g).sets (Inter.inter f.sets g.sets)","decl":"theorem sup_sets_eq {f g : Filter Î±} : (f âŠ” g).sets = f.sets âˆ© g.sets :=\n  (giGenerate Î±).gc.u_inf\n\n"}
{"name":"Filter.sSup_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set (Filter Î±)\nâŠ¢ Eq (SupSet.sSup s).sets (Set.iInter fun f => Set.iInter fun h => f.sets)","decl":"theorem sSup_sets_eq {s : Set (Filter Î±)} : (sSup s).sets = â‹‚ f âˆˆ s, (f : Filter Î±).sets :=\n  (giGenerate Î±).gc.u_sInf\n\n"}
{"name":"Filter.iSup_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\nâŠ¢ Eq (iSup f).sets (Set.iInter fun i => (f i).sets)","decl":"theorem iSup_sets_eq {f : Î¹ â†’ Filter Î±} : (iSup f).sets = â‹‚ i, (f i).sets :=\n  (giGenerate Î±).gc.u_iInf\n\n"}
{"name":"Filter.generate_empty","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nâŠ¢ Eq (Filter.generate EmptyCollection.emptyCollection) Top.top","decl":"theorem generate_empty : Filter.generate âˆ… = (âŠ¤ : Filter Î±) :=\n  (giGenerate Î±).gc.l_bot\n\n"}
{"name":"Filter.generate_univ","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nâŠ¢ Eq (Filter.generate Set.univ) Bot.bot","decl":"theorem generate_univ : Filter.generate univ = (âŠ¥ : Filter Î±) :=\n  bot_unique fun _ _ => GenerateSets.basic (mem_univ _)\n\n"}
{"name":"Filter.generate_union","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set (Set Î±)\nâŠ¢ Eq (Filter.generate (Union.union s t)) (Min.min (Filter.generate s) (Filter.generate t))","decl":"theorem generate_union {s t : Set (Set Î±)} :\n    Filter.generate (s âˆª t) = Filter.generate s âŠ“ Filter.generate t :=\n  (giGenerate Î±).gc.l_sup\n\n"}
{"name":"Filter.generate_iUnion","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\ns : Î¹ â†’ Set (Set Î±)\nâŠ¢ Eq (Filter.generate (Set.iUnion fun i => s i)) (iInf fun i => Filter.generate (s i))","decl":"theorem generate_iUnion {s : Î¹ â†’ Set (Set Î±)} :\n    Filter.generate (â‹ƒ i, s i) = â¨… i, Filter.generate (s i) :=\n  (giGenerate Î±).gc.l_iSup\n\n"}
{"name":"Filter.mem_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Max.max f g) s) (And (Membership.mem f s) (Membership.mem g s))","decl":"@[simp]\ntheorem mem_sup {f g : Filter Î±} {s : Set Î±} : s âˆˆ f âŠ” g â†” s âˆˆ f âˆ§ s âˆˆ g :=\n  Iff.rfl\n\n"}
{"name":"Filter.union_mem_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\ns t : Set Î±\nhs : Membership.mem f s\nht : Membership.mem g t\nâŠ¢ Membership.mem (Max.max f g) (Union.union s t)","decl":"theorem union_mem_sup {f g : Filter Î±} {s t : Set Î±} (hs : s âˆˆ f) (ht : t âˆˆ g) : s âˆª t âˆˆ f âŠ” g :=\n  âŸ¨mem_of_superset hs subset_union_left, mem_of_superset ht subset_union_rightâŸ©\n\n"}
{"name":"Filter.mem_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nx : Set Î±\nf : Î¹ â†’ Filter Î±\nâŠ¢ Iff (Membership.mem (iSup f) x) (âˆ€ (i : Î¹), Membership.mem (f i) x)","decl":"@[simp]\ntheorem mem_iSup {x : Set Î±} {f : Î¹ â†’ Filter Î±} : x âˆˆ iSup f â†” âˆ€ i, x âˆˆ f i := by\n  simp only [â† Filter.mem_sets, iSup_sets_eq, mem_iInter]\n\n"}
{"name":"Filter.iSup_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\nâŠ¢ Iff (iSup fun i => f i).NeBot (Exists fun i => (f i).NeBot)","decl":"@[simp]\ntheorem iSup_neBot {f : Î¹ â†’ Filter Î±} : (â¨† i, f i).NeBot â†” âˆƒ i, (f i).NeBot := by\n  simp [neBot_iff]\n\n"}
{"name":"Filter.iInf_eq_generate","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\ns : Î¹ â†’ Filter Î±\nâŠ¢ Eq (iInf s) (Filter.generate (Set.iUnion fun i => (s i).sets))","decl":"theorem iInf_eq_generate (s : Î¹ â†’ Filter Î±) : iInf s = generate (â‹ƒ i, (s i).sets) :=\n  eq_of_forall_le_iff fun _ â†¦ by simp [le_generate_iff]\n\n"}
{"name":"Filter.mem_iInf_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\ni : Î¹\ns : Set Î±\nhs : Membership.mem (f i) s\nâŠ¢ Membership.mem (iInf fun i => f i) s","decl":"theorem mem_iInf_of_mem {f : Î¹ â†’ Filter Î±} (i : Î¹) {s} (hs : s âˆˆ f i) : s âˆˆ â¨… i, f i :=\n  iInf_le f i hs\n\n"}
{"name":"Filter.le_principal_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nf : Filter Î±\nâŠ¢ Iff (LE.le f (Filter.principal s)) (Membership.mem f s)","decl":"@[simp]\ntheorem le_principal_iff {s : Set Î±} {f : Filter Î±} : f â‰¤ ğ“Ÿ s â†” s âˆˆ f :=\n  âŸ¨fun h => h Subset.rfl, fun hs _ ht => mem_of_superset hs htâŸ©\n\n"}
{"name":"Filter.Iic_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nâŠ¢ Eq (Set.Iic (Filter.principal s)) (setOf fun l => Membership.mem l s)","decl":"theorem Iic_principal (s : Set Î±) : Iic (ğ“Ÿ s) = { l | s âˆˆ l } :=\n  Set.ext fun _ => le_principal_iff\n\n"}
{"name":"Filter.principal_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nâŠ¢ Iff (LE.le (Filter.principal s) (Filter.principal t)) (HasSubset.Subset s t)","decl":"theorem principal_mono {s t : Set Î±} : ğ“Ÿ s â‰¤ ğ“Ÿ t â†” s âŠ† t := by\n  simp only [le_principal_iff, mem_principal]\n\n"}
{"name":"GCongr.filter_principal_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\naâœ : HasSubset.Subset s t\nâŠ¢ LE.le (Filter.principal s) (Filter.principal t)","decl":"@[gcongr] alias âŸ¨_, _root_.GCongr.filter_principal_monoâŸ© := principal_mono\n\n"}
{"name":"Filter.monotone_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nâŠ¢ Monotone Filter.principal","decl":"@[mono]\ntheorem monotone_principal : Monotone (ğ“Ÿ : Set Î± â†’ Filter Î±) := fun _ _ => principal_mono.2\n\n"}
{"name":"Filter.principal_eq_iff_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nâŠ¢ Iff (Eq (Filter.principal s) (Filter.principal t)) (Eq s t)","decl":"@[simp] theorem principal_eq_iff_eq {s t : Set Î±} : ğ“Ÿ s = ğ“Ÿ t â†” s = t := by\n  simp only [le_antisymm_iff, le_principal_iff, mem_principal]; rfl\n\n"}
{"name":"Filter.join_principal_eq_sSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set (Filter Î±)\nâŠ¢ Eq (Filter.principal s).join (SupSet.sSup s)","decl":"@[simp] theorem join_principal_eq_sSup {s : Set (Filter Î±)} : join (ğ“Ÿ s) = sSup s := rfl\n\n"}
{"name":"Filter.principal_univ","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nâŠ¢ Eq (Filter.principal Set.univ) Top.top","decl":"@[simp] theorem principal_univ : ğ“Ÿ (univ : Set Î±) = âŠ¤ :=\n  top_unique <| by simp only [le_principal_iff, mem_top, eq_self_iff_true]\n\n"}
{"name":"Filter.principal_empty","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nâŠ¢ Eq (Filter.principal EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem principal_empty : ğ“Ÿ (âˆ… : Set Î±) = âŠ¥ :=\n  bot_unique fun _ _ => empty_subset _\n\n"}
{"name":"Filter.generate_eq_biInf","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nS : Set (Set Î±)\nâŠ¢ Eq (Filter.generate S) (iInf fun s => iInf fun h => Filter.principal s)","decl":"theorem generate_eq_biInf (S : Set (Set Î±)) : generate S = â¨… s âˆˆ S, ğ“Ÿ s :=\n  eq_of_forall_le_iff fun f => by simp [le_generate_iff, le_principal_iff, subset_def]\n\n"}
{"name":"Filter.empty_mem_iff_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Iff (Membership.mem f EmptyCollection.emptyCollection) (Eq f Bot.bot)","decl":"theorem empty_mem_iff_bot {f : Filter Î±} : âˆ… âˆˆ f â†” f = âŠ¥ :=\n  âŸ¨fun h => bot_unique fun s _ => mem_of_superset h (empty_subset s), fun h => h.symm â–¸ mem_botâŸ©\n\n"}
{"name":"Filter.nonempty_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nhf : f.NeBot\ns : Set Î±\nhs : Membership.mem f s\nâŠ¢ s.Nonempty","decl":"theorem nonempty_of_mem {f : Filter Î±} [hf : NeBot f] {s : Set Î±} (hs : s âˆˆ f) : s.Nonempty :=\n  s.eq_empty_or_nonempty.elim (fun h => absurd hs (h.symm â–¸ mt empty_mem_iff_bot.mp hf.1)) id\n\n"}
{"name":"Filter.NeBot.nonempty_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nhf : f.NeBot\ns : Set Î±\nhs : Membership.mem f s\nâŠ¢ s.Nonempty","decl":"theorem NeBot.nonempty_of_mem {f : Filter Î±} (hf : NeBot f) {s : Set Î±} (hs : s âˆˆ f) : s.Nonempty :=\n  @Filter.nonempty_of_mem Î± f hf s hs\n\n"}
{"name":"Filter.empty_not_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\nâŠ¢ Not (Membership.mem f EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem empty_not_mem (f : Filter Î±) [NeBot f] : Â¬âˆ… âˆˆ f := fun h => (nonempty_of_mem h).ne_empty rfl\n\n"}
{"name":"Filter.nonempty_of_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\nâŠ¢ Nonempty Î±","decl":"theorem nonempty_of_neBot (f : Filter Î±) [NeBot f] : Nonempty Î± :=\n  nonempty_of_exists <| nonempty_of_mem (univ_mem : univ âˆˆ f)\n\n"}
{"name":"Filter.compl_not_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set Î±\ninstâœ : f.NeBot\nh : Membership.mem f s\nâŠ¢ Not (Membership.mem f (HasCompl.compl s))","decl":"theorem compl_not_mem {f : Filter Î±} {s : Set Î±} [NeBot f] (h : s âˆˆ f) : sá¶œ âˆ‰ f := fun hsc =>\n  (nonempty_of_mem (inter_mem h hsc)).ne_empty <| inter_compl_self s\n\n"}
{"name":"Filter.filter_eq_bot_of_isEmpty","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ninstâœ : IsEmpty Î±\nf : Filter Î±\nâŠ¢ Eq f Bot.bot","decl":"theorem filter_eq_bot_of_isEmpty [IsEmpty Î±] (f : Filter Î±) : f = âŠ¥ :=\n  empty_mem_iff_bot.mp <| univ_mem' isEmptyElim\n\n"}
{"name":"Filter.disjoint_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nâŠ¢ Iff (Disjoint f g) (Exists fun s => And (Membership.mem f s) (Exists fun t => And (Membership.mem g t) (Disjoint s t)))","decl":"protected lemma disjoint_iff {f g : Filter Î±} : Disjoint f g â†” âˆƒ s âˆˆ f, âˆƒ t âˆˆ g, Disjoint s t := by\n  simp only [disjoint_iff, â† empty_mem_iff_bot, mem_inf_iff, inf_eq_inter, bot_eq_empty,\n    @eq_comm _ âˆ…]\n\n"}
{"name":"Filter.disjoint_of_disjoint_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\ns t : Set Î±\nh : Disjoint s t\nhs : Membership.mem f s\nht : Membership.mem g t\nâŠ¢ Disjoint f g","decl":"theorem disjoint_of_disjoint_of_mem {f g : Filter Î±} {s t : Set Î±} (h : Disjoint s t) (hs : s âˆˆ f)\n    (ht : t âˆˆ g) : Disjoint f g :=\n  Filter.disjoint_iff.mpr âŸ¨s, hs, t, ht, hâŸ©\n\n"}
{"name":"Filter.NeBot.not_disjoint","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns t : Set Î±\nhf : f.NeBot\nhs : Membership.mem f s\nht : Membership.mem f t\nâŠ¢ Not (Disjoint s t)","decl":"theorem NeBot.not_disjoint (hf : f.NeBot) (hs : s âˆˆ f) (ht : t âˆˆ f) : Â¬Disjoint s t := fun h =>\n  not_disjoint_self_iff.2 hf <| Filter.disjoint_iff.2 âŸ¨s, hs, t, ht, hâŸ©\n\n"}
{"name":"Filter.inf_eq_bot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\nâŠ¢ Iff (Eq (Min.min f g) Bot.bot) (Exists fun U => And (Membership.mem f U) (Exists fun V => And (Membership.mem g V) (Eq (Inter.inter U V) EmptyCollection.emptyCollection)))","decl":"theorem inf_eq_bot_iff {f g : Filter Î±} : f âŠ“ g = âŠ¥ â†” âˆƒ U âˆˆ f, âˆƒ V âˆˆ g, U âˆ© V = âˆ… := by\n  simp only [â† disjoint_iff, Filter.disjoint_iff, Set.disjoint_iff_inter_eq_empty]\n\n"}
{"name":"Filter.NeBot.nonempty","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nhf : f.NeBot\nâŠ¢ Nonempty Î±","decl":"theorem NeBot.nonempty (f : Filter Î±) [hf : f.NeBot] : Nonempty Î± :=\n  not_isEmpty_iff.mp fun _ â†¦ hf.ne (Subsingleton.elim _ _)\n\n"}
{"name":"Filter.eq_top_of_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ninstâœÂ¹ : Subsingleton Î±\nl : Filter Î±\ninstâœ : l.NeBot\nâŠ¢ Eq l Top.top","decl":"/-- There are only two filters on a `Subsingleton`: `âŠ¥` and `âŠ¤`. If the type is empty, then they are\nequal. -/\ntheorem eq_top_of_neBot [Subsingleton Î±] (l : Filter Î±) [NeBot l] : l = âŠ¤ := by\n  refine top_unique fun s hs => ?_\n  obtain rfl : s = univ := Subsingleton.eq_univ_of_nonempty (nonempty_of_mem hs)\n  exact univ_mem\n\n"}
{"name":"Filter.forall_mem_nonempty_iff_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Iff (âˆ€ (s : Set Î±), Membership.mem f s â†’ s.Nonempty) f.NeBot","decl":"theorem forall_mem_nonempty_iff_neBot {f : Filter Î±} :\n    (âˆ€ s : Set Î±, s âˆˆ f â†’ s.Nonempty) â†” NeBot f :=\n  âŸ¨fun h => âŸ¨fun hf => not_nonempty_empty (h âˆ… <| hf.symm â–¸ mem_bot)âŸ©, @nonempty_of_mem _ _âŸ©\n\n"}
{"name":"Filter.instNontrivialFilter","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ninstâœ : Nonempty Î±\nâŠ¢ Nontrivial (Filter Î±)","decl":"instance instNontrivialFilter [Nonempty Î±] : Nontrivial (Filter Î±) :=\n  âŸ¨âŸ¨âŠ¤, âŠ¥, NeBot.ne <| forall_mem_nonempty_iff_neBot.1\n    fun s hs => by rwa [mem_top.1 hs, â† nonempty_iff_univ_nonempty]âŸ©âŸ©\n\n"}
{"name":"Filter.nontrivial_iff_nonempty","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nâŠ¢ Iff (Nontrivial (Filter Î±)) (Nonempty Î±)","decl":"theorem nontrivial_iff_nonempty : Nontrivial (Filter Î±) â†” Nonempty Î± :=\n  âŸ¨fun _ =>\n    by_contra fun h' =>\n      haveI := not_nonempty_iff.1 h'\n      not_subsingleton (Filter Î±) inferInstance,\n    @Filter.instNontrivialFilter Î±âŸ©\n\n"}
{"name":"Filter.eq_sInf_of_mem_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nS : Set (Filter Î±)\nl : Filter Î±\nh : âˆ€ {s : Set Î±}, Iff (Membership.mem l s) (Exists fun f => And (Membership.mem S f) (Membership.mem f s))\nâŠ¢ Eq l (InfSet.sInf S)","decl":"theorem eq_sInf_of_mem_iff_exists_mem {S : Set (Filter Î±)} {l : Filter Î±}\n    (h : âˆ€ {s}, s âˆˆ l â†” âˆƒ f âˆˆ S, s âˆˆ f) : l = sInf S :=\n  le_antisymm (le_sInf fun f hf _ hs => h.2 âŸ¨f, hf, hsâŸ©)\n    fun _ hs => let âŸ¨_, hf, hsâŸ© := h.1 hs; (sInf_le hf) hs\n\n"}
{"name":"Filter.eq_iInf_of_mem_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\nl : Filter Î±\nh : âˆ€ {s : Set Î±}, Iff (Membership.mem l s) (Exists fun i => Membership.mem (f i) s)\nâŠ¢ Eq l (iInf f)","decl":"theorem eq_iInf_of_mem_iff_exists_mem {f : Î¹ â†’ Filter Î±} {l : Filter Î±}\n    (h : âˆ€ {s}, s âˆˆ l â†” âˆƒ i, s âˆˆ f i) : l = iInf f :=\n  eq_sInf_of_mem_iff_exists_mem <| h.trans (exists_range_iff (p := (_ âˆˆ Â·))).symm\n\n"}
{"name":"Filter.eq_biInf_of_mem_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\np : Î¹ â†’ Prop\nl : Filter Î±\nh : âˆ€ {s : Set Î±}, Iff (Membership.mem l s) (Exists fun i => And (p i) (Membership.mem (f i) s))\nâŠ¢ Eq l (iInf fun i => iInf fun x => f i)","decl":"theorem eq_biInf_of_mem_iff_exists_mem {f : Î¹ â†’ Filter Î±} {p : Î¹ â†’ Prop} {l : Filter Î±}\n    (h : âˆ€ {s}, s âˆˆ l â†” âˆƒ i, p i âˆ§ s âˆˆ f i) : l = â¨… (i) (_ : p i), f i := by\n  rw [iInf_subtype']\n  exact eq_iInf_of_mem_iff_exists_mem fun {_} => by simp only [Subtype.exists, h, exists_prop]\n\n"}
{"name":"Filter.iInf_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\nh : Directed (fun x1 x2 => GE.ge x1 x2) f\nne : Nonempty Î¹\nâŠ¢ Eq (iInf f).sets (Set.iUnion fun i => (f i).sets)","decl":"theorem iInf_sets_eq {f : Î¹ â†’ Filter Î±} (h : Directed (Â· â‰¥ Â·) f) [ne : Nonempty Î¹] :\n    (iInf f).sets = â‹ƒ i, (f i).sets :=\n  let âŸ¨iâŸ© := ne\n  let u :=\n    { sets := â‹ƒ i, (f i).sets\n      univ_sets := mem_iUnion.2 âŸ¨i, univ_memâŸ©\n      sets_of_superset := by\n        simp only [mem_iUnion, exists_imp]\n        exact fun i hx hxy => âŸ¨i, mem_of_superset hx hxyâŸ©\n      inter_sets := by\n        simp only [mem_iUnion, exists_imp]\n        intro x y a hx b hy\n        rcases h a b with âŸ¨c, ha, hbâŸ©\n        exact âŸ¨c, inter_mem (ha hx) (hb hy)âŸ© }\n  have : u = iInf f := eq_iInf_of_mem_iff_exists_mem mem_iUnion\n  -- Porting note: it was just `congr_arg filter.sets this.symm`\n  (congr_arg Filter.sets this.symm).trans <| by simp only [u]\n\n"}
{"name":"Filter.mem_iInf_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\nh : Directed (fun x1 x2 => GE.ge x1 x2) f\ninstâœ : Nonempty Î¹\ns : Set Î±\nâŠ¢ Iff (Membership.mem (iInf f) s) (Exists fun i => Membership.mem (f i) s)","decl":"theorem mem_iInf_of_directed {f : Î¹ â†’ Filter Î±} (h : Directed (Â· â‰¥ Â·) f) [Nonempty Î¹] (s) :\n    s âˆˆ iInf f â†” âˆƒ i, s âˆˆ f i := by\n  simp only [â† Filter.mem_sets, iInf_sets_eq h, mem_iUnion]\n\n"}
{"name":"Filter.mem_biInf_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î² â†’ Filter Î±\ns : Set Î²\nh : DirectedOn (Order.Preimage f fun x1 x2 => GE.ge x1 x2) s\nne : s.Nonempty\nt : Set Î±\nâŠ¢ Iff (Membership.mem (iInf fun i => iInf fun h => f i) t) (Exists fun i => And (Membership.mem s i) (Membership.mem (f i) t))","decl":"theorem mem_biInf_of_directed {f : Î² â†’ Filter Î±} {s : Set Î²} (h : DirectedOn (f â»Â¹'o (Â· â‰¥ Â·)) s)\n    (ne : s.Nonempty) {t : Set Î±} : (t âˆˆ â¨… i âˆˆ s, f i) â†” âˆƒ i âˆˆ s, t âˆˆ f i := by\n  haveI := ne.to_subtype\n  simp_rw [iInf_subtype', mem_iInf_of_directed h.directed_val, Subtype.exists, exists_prop]\n\n"}
{"name":"Filter.biInf_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î² â†’ Filter Î±\ns : Set Î²\nh : DirectedOn (Order.Preimage f fun x1 x2 => GE.ge x1 x2) s\nne : s.Nonempty\nâŠ¢ Eq (iInf fun i => iInf fun h => f i).sets (Set.iUnion fun i => Set.iUnion fun h => (f i).sets)","decl":"theorem biInf_sets_eq {f : Î² â†’ Filter Î±} {s : Set Î²} (h : DirectedOn (f â»Â¹'o (Â· â‰¥ Â·)) s)\n    (ne : s.Nonempty) : (â¨… i âˆˆ s, f i).sets = â‹ƒ i âˆˆ s, (f i).sets :=\n  ext fun t => by simp [mem_biInf_of_directed h ne]\n\n"}
{"name":"Filter.sup_join","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nfâ‚ fâ‚‚ : Filter (Filter Î±)\nâŠ¢ Eq (Max.max fâ‚.join fâ‚‚.join) (Max.max fâ‚ fâ‚‚).join","decl":"@[simp]\ntheorem sup_join {fâ‚ fâ‚‚ : Filter (Filter Î±)} : join fâ‚ âŠ” join fâ‚‚ = join (fâ‚ âŠ” fâ‚‚) :=\n  Filter.ext fun x => by simp only [mem_sup, mem_join]\n\n"}
{"name":"Filter.iSup_join","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort w\nf : Î¹ â†’ Filter (Filter Î±)\nâŠ¢ Eq (iSup fun x => (f x).join) (iSup fun x => f x).join","decl":"@[simp]\ntheorem iSup_join {Î¹ : Sort w} {f : Î¹ â†’ Filter (Filter Î±)} : â¨† x, join (f x) = join (â¨† x, f x) :=\n  Filter.ext fun x => by simp only [mem_iSup, mem_join]\n\n"}
{"name":"Filter.iInf_neBot_of_directed'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\ninstâœ : Nonempty Î¹\nhd : Directed (fun x1 x2 => GE.ge x1 x2) f\naâœ : âˆ€ (i : Î¹), (f i).NeBot\nâŠ¢ (iInf f).NeBot","decl":"/-- If `f : Î¹ â†’ Filter Î±` is directed, `Î¹` is not empty, and `âˆ€ i, f i â‰  âŠ¥`, then `iInf f â‰  âŠ¥`.\nSee also `iInf_neBot_of_directed` for a version assuming `Nonempty Î±` instead of `Nonempty Î¹`. -/\ntheorem iInf_neBot_of_directed' {f : Î¹ â†’ Filter Î±} [Nonempty Î¹] (hd : Directed (Â· â‰¥ Â·) f) :\n    (âˆ€ i, NeBot (f i)) â†’ NeBot (iInf f) :=\n  not_imp_not.1 <| by simpa only [not_forall, not_neBot, â† empty_mem_iff_bot,\n    mem_iInf_of_directed hd] using id\n\n"}
{"name":"Filter.iInf_neBot_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\nhn : Nonempty Î±\nhd : Directed (fun x1 x2 => GE.ge x1 x2) f\nhb : âˆ€ (i : Î¹), (f i).NeBot\nâŠ¢ (iInf f).NeBot","decl":"/-- If `f : Î¹ â†’ Filter Î±` is directed, `Î±` is not empty, and `âˆ€ i, f i â‰  âŠ¥`, then `iInf f â‰  âŠ¥`.\nSee also `iInf_neBot_of_directed'` for a version assuming `Nonempty Î¹` instead of `Nonempty Î±`. -/\ntheorem iInf_neBot_of_directed {f : Î¹ â†’ Filter Î±} [hn : Nonempty Î±] (hd : Directed (Â· â‰¥ Â·) f)\n    (hb : âˆ€ i, NeBot (f i)) : NeBot (iInf f) := by\n  cases isEmpty_or_nonempty Î¹\n  Â· constructor\n    simp [iInf_of_empty f, top_ne_bot]\n  Â· exact iInf_neBot_of_directed' hd hb\n\n"}
{"name":"Filter.sInf_neBot_of_directed'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set (Filter Î±)\nhne : s.Nonempty\nhd : DirectedOn (fun x1 x2 => GE.ge x1 x2) s\nhbot : Not (Membership.mem s Bot.bot)\nâŠ¢ (InfSet.sInf s).NeBot","decl":"theorem sInf_neBot_of_directed' {s : Set (Filter Î±)} (hne : s.Nonempty) (hd : DirectedOn (Â· â‰¥ Â·) s)\n    (hbot : âŠ¥ âˆ‰ s) : NeBot (sInf s) :=\n  (sInf_eq_iInf' s).symm â–¸\n    @iInf_neBot_of_directed' _ _ _ hne.to_subtype hd.directed_val fun âŸ¨_, hfâŸ© =>\n      âŸ¨ne_of_mem_of_not_mem hf hbotâŸ©\n\n"}
{"name":"Filter.sInf_neBot_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ninstâœ : Nonempty Î±\ns : Set (Filter Î±)\nhd : DirectedOn (fun x1 x2 => GE.ge x1 x2) s\nhbot : Not (Membership.mem s Bot.bot)\nâŠ¢ (InfSet.sInf s).NeBot","decl":"theorem sInf_neBot_of_directed [Nonempty Î±] {s : Set (Filter Î±)} (hd : DirectedOn (Â· â‰¥ Â·) s)\n    (hbot : âŠ¥ âˆ‰ s) : NeBot (sInf s) :=\n  (sInf_eq_iInf' s).symm â–¸\n    iInf_neBot_of_directed hd.directed_val fun âŸ¨_, hfâŸ© => âŸ¨ne_of_mem_of_not_mem hf hbotâŸ©\n\n"}
{"name":"Filter.iInf_neBot_iff_of_directed'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\ninstâœ : Nonempty Î¹\nhd : Directed (fun x1 x2 => GE.ge x1 x2) f\nâŠ¢ Iff (iInf f).NeBot (âˆ€ (i : Î¹), (f i).NeBot)","decl":"theorem iInf_neBot_iff_of_directed' {f : Î¹ â†’ Filter Î±} [Nonempty Î¹] (hd : Directed (Â· â‰¥ Â·) f) :\n    NeBot (iInf f) â†” âˆ€ i, NeBot (f i) :=\n  âŸ¨fun H i => H.mono (iInf_le _ i), iInf_neBot_of_directed' hdâŸ©\n\n"}
{"name":"Filter.iInf_neBot_iff_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\ninstâœ : Nonempty Î±\nhd : Directed (fun x1 x2 => GE.ge x1 x2) f\nâŠ¢ Iff (iInf f).NeBot (âˆ€ (i : Î¹), (f i).NeBot)","decl":"theorem iInf_neBot_iff_of_directed {f : Î¹ â†’ Filter Î±} [Nonempty Î±] (hd : Directed (Â· â‰¥ Â·) f) :\n    NeBot (iInf f) â†” âˆ€ i, NeBot (f i) :=\n  âŸ¨fun H i => H.mono (iInf_le _ i), iInf_neBot_of_directed hdâŸ©\n\n"}
{"name":"Filter.inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nâŠ¢ Eq (Min.min (Filter.principal s) (Filter.principal t)) (Filter.principal (Inter.inter s t))","decl":"@[simp]\ntheorem inf_principal {s t : Set Î±} : ğ“Ÿ s âŠ“ ğ“Ÿ t = ğ“Ÿ (s âˆ© t) :=\n  le_antisymm\n    (by simp only [le_principal_iff, mem_inf_iff]; exact âŸ¨s, Subset.rfl, t, Subset.rfl, rflâŸ©)\n    (by simp [le_inf_iff, inter_subset_left, inter_subset_right])\n\n"}
{"name":"Filter.sup_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nâŠ¢ Eq (Max.max (Filter.principal s) (Filter.principal t)) (Filter.principal (Union.union s t))","decl":"@[simp]\ntheorem sup_principal {s t : Set Î±} : ğ“Ÿ s âŠ” ğ“Ÿ t = ğ“Ÿ (s âˆª t) :=\n  Filter.ext fun u => by simp only [union_subset_iff, mem_sup, mem_principal]\n\n"}
{"name":"Filter.iSup_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort w\ns : Î¹ â†’ Set Î±\nâŠ¢ Eq (iSup fun x => Filter.principal (s x)) (Filter.principal (Set.iUnion fun i => s i))","decl":"@[simp]\ntheorem iSup_principal {Î¹ : Sort w} {s : Î¹ â†’ Set Î±} : â¨† x, ğ“Ÿ (s x) = ğ“Ÿ (â‹ƒ i, s i) :=\n  Filter.ext fun x => by simp only [mem_iSup, mem_principal, iUnion_subset_iff]\n\n"}
{"name":"Filter.principal_eq_bot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nâŠ¢ Iff (Eq (Filter.principal s) Bot.bot) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem principal_eq_bot_iff {s : Set Î±} : ğ“Ÿ s = âŠ¥ â†” s = âˆ… :=\n  empty_mem_iff_bot.symm.trans <| mem_principal.trans subset_empty_iff\n\n"}
{"name":"Filter.principal_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nâŠ¢ Iff (Filter.principal s).NeBot s.Nonempty","decl":"@[simp]\ntheorem principal_neBot_iff {s : Set Î±} : NeBot (ğ“Ÿ s) â†” s.Nonempty :=\n  neBot_iff.trans <| (not_congr principal_eq_bot_iff).trans nonempty_iff_ne_empty.symm\n\n"}
{"name":"Set.Nonempty.principal_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\naâœ : s.Nonempty\nâŠ¢ (Filter.principal s).NeBot","decl":"alias âŸ¨_, _root_.Set.Nonempty.principal_neBotâŸ© := principal_neBot_iff\n\n"}
{"name":"Filter.isCompl_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nâŠ¢ IsCompl (Filter.principal s) (Filter.principal (HasCompl.compl s))","decl":"theorem isCompl_principal (s : Set Î±) : IsCompl (ğ“Ÿ s) (ğ“Ÿ sá¶œ) :=\n  IsCompl.of_eq (by rw [inf_principal, inter_compl_self, principal_empty]) <| by\n    rw [sup_principal, union_compl_self, principal_univ]\n\n"}
{"name":"Filter.mem_inf_principal'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns t : Set Î±\nâŠ¢ Iff (Membership.mem (Min.min f (Filter.principal t)) s) (Membership.mem f (Union.union (HasCompl.compl t) s))","decl":"theorem mem_inf_principal' {f : Filter Î±} {s t : Set Î±} : s âˆˆ f âŠ“ ğ“Ÿ t â†” tá¶œ âˆª s âˆˆ f := by\n  simp only [â† le_principal_iff, (isCompl_principal s).le_left_iff, disjoint_assoc, inf_principal,\n    â† (isCompl_principal (t âˆ© sá¶œ)).le_right_iff, compl_inter, compl_compl]\n\n"}
{"name":"Filter.mem_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns t : Set Î±\nâŠ¢ Iff (Membership.mem (Min.min f (Filter.principal t)) s) (Membership.mem f (setOf fun x => Membership.mem t x â†’ Membership.mem s x))","decl":"lemma mem_inf_principal {f : Filter Î±} {s t : Set Î±} : s âˆˆ f âŠ“ ğ“Ÿ t â†” { x | x âˆˆ t â†’ x âˆˆ s } âˆˆ f := by\n  simp only [mem_inf_principal', imp_iff_not_or, setOf_or, compl_def, setOf_mem_eq]\n\n"}
{"name":"Filter.iSup_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\ns : Set Î±\nâŠ¢ Eq (iSup fun i => Min.min (f i) (Filter.principal s)) (Min.min (iSup fun i => f i) (Filter.principal s))","decl":"lemma iSup_inf_principal (f : Î¹ â†’ Filter Î±) (s : Set Î±) : â¨† i, f i âŠ“ ğ“Ÿ s = (â¨† i, f i) âŠ“ ğ“Ÿ s := by\n  ext\n  simp only [mem_iSup, mem_inf_principal]\n\n"}
{"name":"Filter.inf_principal_eq_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Eq (Min.min f (Filter.principal s)) Bot.bot) (Membership.mem f (HasCompl.compl s))","decl":"theorem inf_principal_eq_bot {f : Filter Î±} {s : Set Î±} : f âŠ“ ğ“Ÿ s = âŠ¥ â†” sá¶œ âˆˆ f := by\n  rw [â† empty_mem_iff_bot, mem_inf_principal]\n  simp only [mem_empty_iff_false, imp_false, compl_def]\n\n"}
{"name":"Filter.mem_of_eq_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set Î±\nh : Eq (Min.min f (Filter.principal (HasCompl.compl s))) Bot.bot\nâŠ¢ Membership.mem f s","decl":"theorem mem_of_eq_bot {f : Filter Î±} {s : Set Î±} (h : f âŠ“ ğ“Ÿ sá¶œ = âŠ¥) : s âˆˆ f := by\n  rwa [inf_principal_eq_bot, compl_compl] at h\n\n"}
{"name":"Filter.diff_mem_inf_principal_compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set Î±\nhs : Membership.mem f s\nt : Set Î±\nâŠ¢ Membership.mem (Min.min f (Filter.principal (HasCompl.compl t))) (SDiff.sdiff s t)","decl":"theorem diff_mem_inf_principal_compl {f : Filter Î±} {s : Set Î±} (hs : s âˆˆ f) (t : Set Î±) :\n    s \\ t âˆˆ f âŠ“ ğ“Ÿ tá¶œ :=\n  inter_mem_inf hs <| mem_principal_self tá¶œ\n\n"}
{"name":"Filter.principal_le_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nf : Filter Î±\nâŠ¢ Iff (LE.le (Filter.principal s) f) (âˆ€ (V : Set Î±), Membership.mem f V â†’ HasSubset.Subset s V)","decl":"theorem principal_le_iff {s : Set Î±} {f : Filter Î±} : ğ“Ÿ s â‰¤ f â†” âˆ€ V âˆˆ f, s âŠ† V := by\n  simp_rw [le_def, mem_principal]\n\n"}
{"name":"Filter.join_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nfâ‚ fâ‚‚ : Filter (Filter Î±)\nh : LE.le fâ‚ fâ‚‚\nâŠ¢ LE.le fâ‚.join fâ‚‚.join","decl":"@[mono, gcongr]\ntheorem join_mono {fâ‚ fâ‚‚ : Filter (Filter Î±)} (h : fâ‚ â‰¤ fâ‚‚) : join fâ‚ â‰¤ join fâ‚‚ := fun _ hs => h hs\n\n"}
{"name":"Filter.eventually_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nP : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => P x) f) (Membership.mem f (setOf fun x => P x))","decl":"theorem eventually_iff {f : Filter Î±} {P : Î± â†’ Prop} : (âˆ€á¶  x in f, P x) â†” { x | P x } âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventually_mem_set","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nl : Filter Î±\nâŠ¢ Iff (Filter.Eventually (fun x => Membership.mem s x) l) (Membership.mem l s)","decl":"@[simp]\ntheorem eventually_mem_set {s : Set Î±} {l : Filter Î±} : (âˆ€á¶  x in l, x âˆˆ s) â†” s âˆˆ l :=\n  Iff.rfl\n\n"}
{"name":"Filter.ext'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nfâ‚ fâ‚‚ : Filter Î±\nh : âˆ€ (p : Î± â†’ Prop), Iff (Filter.Eventually (fun x => p x) fâ‚) (Filter.Eventually (fun x => p x) fâ‚‚)\nâŠ¢ Eq fâ‚ fâ‚‚","decl":"protected theorem ext' {fâ‚ fâ‚‚ : Filter Î±}\n    (h : âˆ€ p : Î± â†’ Prop, (âˆ€á¶  x in fâ‚, p x) â†” âˆ€á¶  x in fâ‚‚, p x) : fâ‚ = fâ‚‚ :=\n  Filter.ext h\n\n"}
{"name":"Filter.Eventually.filter_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nfâ‚ fâ‚‚ : Filter Î±\nh : LE.le fâ‚ fâ‚‚\np : Î± â†’ Prop\nhp : Filter.Eventually (fun x => p x) fâ‚‚\nâŠ¢ Filter.Eventually (fun x => p x) fâ‚","decl":"theorem Eventually.filter_mono {fâ‚ fâ‚‚ : Filter Î±} (h : fâ‚ â‰¤ fâ‚‚) {p : Î± â†’ Prop}\n    (hp : âˆ€á¶  x in fâ‚‚, p x) : âˆ€á¶  x in fâ‚, p x :=\n  h hp\n\n"}
{"name":"Filter.eventually_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nP : Î± â†’ Prop\nU : Set Î±\nhU : Membership.mem f U\nh : âˆ€ (x : Î±), Membership.mem U x â†’ P x\nâŠ¢ Filter.Eventually (fun x => P x) f","decl":"theorem eventually_of_mem {f : Filter Î±} {P : Î± â†’ Prop} {U : Set Î±} (hU : U âˆˆ f)\n    (h : âˆ€ x âˆˆ U, P x) : âˆ€á¶  x in f, P x :=\n  mem_of_superset hU h\n\n"}
{"name":"Filter.Eventually.and","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np q : Î± â†’ Prop\nf : Filter Î±\naâœÂ¹ : Filter.Eventually p f\naâœ : Filter.Eventually q f\nâŠ¢ Filter.Eventually (fun x => And (p x) (q x)) f","decl":"protected theorem Eventually.and {p q : Î± â†’ Prop} {f : Filter Î±} :\n    f.Eventually p â†’ f.Eventually q â†’ âˆ€á¶  x in f, p x âˆ§ q x :=\n  inter_mem\n\n"}
{"name":"Filter.eventually_true","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Filter.Eventually (fun x => True) f","decl":"@[simp] theorem eventually_true (f : Filter Î±) : âˆ€á¶  _ in f, True := univ_mem\n\n"}
{"name":"Filter.Eventually.of_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf : Filter Î±\nhp : âˆ€ (x : Î±), p x\nâŠ¢ Filter.Eventually (fun x => p x) f","decl":"theorem Eventually.of_forall {p : Î± â†’ Prop} {f : Filter Î±} (hp : âˆ€ x, p x) : âˆ€á¶  x in f, p x :=\n  univ_mem' hp\n\n"}
{"name":"Filter.eventually_of_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf : Filter Î±\nhp : âˆ€ (x : Î±), p x\nâŠ¢ Filter.Eventually (fun x => p x) f","decl":"@[deprecated (since := \"2024-08-02\")] alias eventually_of_forall := Eventually.of_forall\n\n"}
{"name":"Filter.eventually_false_iff_eq_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Iff (Filter.Eventually (fun x => False) f) (Eq f Bot.bot)","decl":"@[simp]\ntheorem eventually_false_iff_eq_bot {f : Filter Î±} : (âˆ€á¶  _ in f, False) â†” f = âŠ¥ :=\n  empty_mem_iff_bot\n\n"}
{"name":"Filter.eventually_const","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nt : f.NeBot\np : Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p) f) p","decl":"@[simp]\ntheorem eventually_const {f : Filter Î±} [t : NeBot f] {p : Prop} : (âˆ€á¶  _ in f, p) â†” p := by\n  by_cases h : p <;> simp [h, t.ne]\n\n"}
{"name":"Filter.eventually_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf : Filter Î±\nâŠ¢ Iff (Filter.Eventually (fun x => p x) f) (Exists fun v => And (Membership.mem f v) (âˆ€ (y : Î±), Membership.mem v y â†’ p y))","decl":"theorem eventually_iff_exists_mem {p : Î± â†’ Prop} {f : Filter Î±} :\n    (âˆ€á¶  x in f, p x) â†” âˆƒ v âˆˆ f, âˆ€ y âˆˆ v, p y :=\n  exists_mem_subset_iff.symm\n\n"}
{"name":"Filter.Eventually.exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf : Filter Î±\nhp : Filter.Eventually (fun x => p x) f\nâŠ¢ Exists fun v => And (Membership.mem f v) (âˆ€ (y : Î±), Membership.mem v y â†’ p y)","decl":"theorem Eventually.exists_mem {p : Î± â†’ Prop} {f : Filter Î±} (hp : âˆ€á¶  x in f, p x) :\n    âˆƒ v âˆˆ f, âˆ€ y âˆˆ v, p y :=\n  eventually_iff_exists_mem.1 hp\n\n"}
{"name":"Filter.Eventually.mp","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np q : Î± â†’ Prop\nf : Filter Î±\nhp : Filter.Eventually (fun x => p x) f\nhq : Filter.Eventually (fun x => p x â†’ q x) f\nâŠ¢ Filter.Eventually (fun x => q x) f","decl":"theorem Eventually.mp {p q : Î± â†’ Prop} {f : Filter Î±} (hp : âˆ€á¶  x in f, p x)\n    (hq : âˆ€á¶  x in f, p x â†’ q x) : âˆ€á¶  x in f, q x :=\n  mp_mem hp hq\n\n"}
{"name":"Filter.Eventually.mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np q : Î± â†’ Prop\nf : Filter Î±\nhp : Filter.Eventually (fun x => p x) f\nhq : âˆ€ (x : Î±), p x â†’ q x\nâŠ¢ Filter.Eventually (fun x => q x) f","decl":"theorem Eventually.mono {p q : Î± â†’ Prop} {f : Filter Î±} (hp : âˆ€á¶  x in f, p x)\n    (hq : âˆ€ x, p x â†’ q x) : âˆ€á¶  x in f, q x :=\n  hp.mp (Eventually.of_forall hq)\n\n"}
{"name":"Filter.forall_eventually_of_eventually_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\np : Î± â†’ Î² â†’ Prop\nh : Filter.Eventually (fun x => âˆ€ (y : Î²), p x y) f\ny : Î²\nâŠ¢ Filter.Eventually (fun x => p x y) f","decl":"theorem forall_eventually_of_eventually_forall {f : Filter Î±} {p : Î± â†’ Î² â†’ Prop}\n    (h : âˆ€á¶  x in f, âˆ€ y, p x y) : âˆ€ y, âˆ€á¶  x in f, p x y :=\n  fun y => h.mono fun _ h => h y\n\n"}
{"name":"Filter.eventually_and","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np q : Î± â†’ Prop\nf : Filter Î±\nâŠ¢ Iff (Filter.Eventually (fun x => And (p x) (q x)) f) (And (Filter.Eventually (fun x => p x) f) (Filter.Eventually (fun x => q x) f))","decl":"@[simp]\ntheorem eventually_and {p q : Î± â†’ Prop} {f : Filter Î±} :\n    (âˆ€á¶  x in f, p x âˆ§ q x) â†” (âˆ€á¶  x in f, p x) âˆ§ âˆ€á¶  x in f, q x :=\n  inter_mem_iff\n\n"}
{"name":"Filter.Eventually.congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np q : Î± â†’ Prop\nh' : Filter.Eventually (fun x => p x) f\nh : Filter.Eventually (fun x => Iff (p x) (q x)) f\nâŠ¢ Filter.Eventually (fun x => q x) f","decl":"theorem Eventually.congr {f : Filter Î±} {p q : Î± â†’ Prop} (h' : âˆ€á¶  x in f, p x)\n    (h : âˆ€á¶  x in f, p x â†” q x) : âˆ€á¶  x in f, q x :=\n  h'.mp (h.mono fun _ hx => hx.mp)\n\n"}
{"name":"Filter.eventually_congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np q : Î± â†’ Prop\nh : Filter.Eventually (fun x => Iff (p x) (q x)) f\nâŠ¢ Iff (Filter.Eventually (fun x => p x) f) (Filter.Eventually (fun x => q x) f)","decl":"theorem eventually_congr {f : Filter Î±} {p q : Î± â†’ Prop} (h : âˆ€á¶  x in f, p x â†” q x) :\n    (âˆ€á¶  x in f, p x) â†” âˆ€á¶  x in f, q x :=\n  âŸ¨fun hp => hp.congr h, fun hq => hq.congr <| by simpa only [Iff.comm] using hâŸ©\n\n"}
{"name":"Filter.eventually_or_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np : Prop\nq : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => Or p (q x)) f) (Or p (Filter.Eventually (fun x => q x) f))","decl":"@[simp]\ntheorem eventually_or_distrib_left {f : Filter Î±} {p : Prop} {q : Î± â†’ Prop} :\n    (âˆ€á¶  x in f, p âˆ¨ q x) â†” p âˆ¨ âˆ€á¶  x in f, q x :=\n  by_cases (fun h : p => by simp [h]) fun h => by simp [h]\n\n"}
{"name":"Filter.eventually_or_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np : Î± â†’ Prop\nq : Prop\nâŠ¢ Iff (Filter.Eventually (fun x => Or (p x) q) f) (Or (Filter.Eventually (fun x => p x) f) q)","decl":"@[simp]\ntheorem eventually_or_distrib_right {f : Filter Î±} {p : Î± â†’ Prop} {q : Prop} :\n    (âˆ€á¶  x in f, p x âˆ¨ q) â†” (âˆ€á¶  x in f, p x) âˆ¨ q := by\n  simp only [@or_comm _ q, eventually_or_distrib_left]\n\n"}
{"name":"Filter.eventually_imp_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np : Prop\nq : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p â†’ q x) f) (p â†’ Filter.Eventually (fun x => q x) f)","decl":"theorem eventually_imp_distrib_left {f : Filter Î±} {p : Prop} {q : Î± â†’ Prop} :\n    (âˆ€á¶  x in f, p â†’ q x) â†” p â†’ âˆ€á¶  x in f, q x := by\n  simp only [imp_iff_not_or, eventually_or_distrib_left]\n\n"}
{"name":"Filter.eventually_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nâŠ¢ Filter.Eventually (fun x => p x) Bot.bot","decl":"@[simp]\ntheorem eventually_bot {p : Î± â†’ Prop} : âˆ€á¶  x in âŠ¥, p x :=\n  âŸ¨âŸ©\n\n"}
{"name":"Filter.eventually_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) Top.top) (âˆ€ (x : Î±), p x)","decl":"@[simp]\ntheorem eventually_top {p : Î± â†’ Prop} : (âˆ€á¶  x in âŠ¤, p x) â†” âˆ€ x, p x :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventually_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf g : Filter Î±\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (Max.max f g)) (And (Filter.Eventually (fun x => p x) f) (Filter.Eventually (fun x => p x) g))","decl":"@[simp]\ntheorem eventually_sup {p : Î± â†’ Prop} {f g : Filter Î±} :\n    (âˆ€á¶  x in f âŠ” g, p x) â†” (âˆ€á¶  x in f, p x) âˆ§ âˆ€á¶  x in g, p x :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventually_sSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nfs : Set (Filter Î±)\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (SupSet.sSup fs)) (âˆ€ (f : Filter Î±), Membership.mem fs f â†’ Filter.Eventually (fun x => p x) f)","decl":"@[simp]\ntheorem eventually_sSup {p : Î± â†’ Prop} {fs : Set (Filter Î±)} :\n    (âˆ€á¶  x in sSup fs, p x) â†” âˆ€ f âˆˆ fs, âˆ€á¶  x in f, p x :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventually_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ¹ : Sort x\np : Î± â†’ Prop\nfs : Î¹ â†’ Filter Î±\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (iSup fun b => fs b)) (âˆ€ (b : Î¹), Filter.Eventually (fun x => p x) (fs b))","decl":"@[simp]\ntheorem eventually_iSup {p : Î± â†’ Prop} {fs : Î¹ â†’ Filter Î±} :\n    (âˆ€á¶  x in â¨† b, fs b, p x) â†” âˆ€ b, âˆ€á¶  x in fs b, p x :=\n  mem_iSup\n\n"}
{"name":"Filter.eventually_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\na : Set Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (Filter.principal a)) (âˆ€ (x : Î±), Membership.mem a x â†’ p x)","decl":"@[simp]\ntheorem eventually_principal {a : Set Î±} {p : Î± â†’ Prop} : (âˆ€á¶  x in ğ“Ÿ a, p x) â†” âˆ€ x âˆˆ a, p x :=\n  Iff.rfl\n\n"}
{"name":"Filter.Eventually.forall_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_2\nf : Filter Î±\ns : Set Î±\nP : Î± â†’ Prop\nhP : Filter.Eventually (fun x => P x) f\nhf : LE.le (Filter.principal s) f\nx : Î±\naâœ : Membership.mem s x\nâŠ¢ P x","decl":"theorem Eventually.forall_mem {Î± : Type*} {f : Filter Î±} {s : Set Î±} {P : Î± â†’ Prop}\n    (hP : âˆ€á¶  x in f, P x) (hf : ğ“Ÿ s â‰¤ f) : âˆ€ x âˆˆ s, P x :=\n  Filter.eventually_principal.mp (hP.filter_mono hf)\n\n"}
{"name":"Filter.eventually_inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Filter Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (Min.min f g)) (Exists fun s => And (Membership.mem f s) (Exists fun t => And (Membership.mem g t) (âˆ€ (x : Î±), Membership.mem (Inter.inter s t) x â†’ p x)))","decl":"theorem eventually_inf {f g : Filter Î±} {p : Î± â†’ Prop} :\n    (âˆ€á¶  x in f âŠ“ g, p x) â†” âˆƒ s âˆˆ f, âˆƒ t âˆˆ g, âˆ€ x âˆˆ s âˆ© t, p x :=\n  mem_inf_iff_superset\n\n"}
{"name":"Filter.eventually_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np : Î± â†’ Prop\ns : Set Î±\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (Min.min f (Filter.principal s))) (Filter.Eventually (fun x => Membership.mem s x â†’ p x) f)","decl":"theorem eventually_inf_principal {f : Filter Î±} {p : Î± â†’ Prop} {s : Set Î±} :\n    (âˆ€á¶  x in f âŠ“ ğ“Ÿ s, p x) â†” âˆ€á¶  x in f, x âˆˆ s â†’ p x :=\n  mem_inf_principal\n\n"}
{"name":"Filter.eventually_iff_all_subsets","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) f) (âˆ€ (s : Set Î±), Filter.Eventually (fun x => Membership.mem s x â†’ p x) f)","decl":"theorem eventually_iff_all_subsets {f : Filter Î±} {p : Î± â†’ Prop} :\n    (âˆ€á¶  x in f, p x) â†” âˆ€ (s : Set Î±), âˆ€á¶  x in f, x âˆˆ s â†’ p x where\n  mp h _ := by filter_upwards [h] with _ pa _ using pa\n  mpr h := by filter_upwards [h univ] with _ pa using pa (by simp)\n\n"}
{"name":"Filter.Eventually.frequently","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\np : Î± â†’ Prop\nh : Filter.Eventually (fun x => p x) f\nâŠ¢ Filter.Frequently (fun x => p x) f","decl":"theorem Eventually.frequently {f : Filter Î±} [NeBot f] {p : Î± â†’ Prop} (h : âˆ€á¶  x in f, p x) :\n    âˆƒá¶  x in f, p x :=\n  compl_not_mem h\n\n"}
{"name":"Filter.Frequently.of_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\np : Î± â†’ Prop\nh : âˆ€ (x : Î±), p x\nâŠ¢ Filter.Frequently (fun x => p x) f","decl":"theorem Frequently.of_forall {f : Filter Î±} [NeBot f] {p : Î± â†’ Prop} (h : âˆ€ x, p x) :\n    âˆƒá¶  x in f, p x :=\n  Eventually.frequently (Eventually.of_forall h)\n\n"}
{"name":"Filter.frequently_of_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\np : Î± â†’ Prop\nh : âˆ€ (x : Î±), p x\nâŠ¢ Filter.Frequently (fun x => p x) f","decl":"@[deprecated (since := \"2024-08-02\")] alias frequently_of_forall := Frequently.of_forall\n\n"}
{"name":"Filter.Frequently.mp","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np q : Î± â†’ Prop\nf : Filter Î±\nh : Filter.Frequently (fun x => p x) f\nhpq : Filter.Eventually (fun x => p x â†’ q x) f\nâŠ¢ Filter.Frequently (fun x => q x) f","decl":"theorem Frequently.mp {p q : Î± â†’ Prop} {f : Filter Î±} (h : âˆƒá¶  x in f, p x)\n    (hpq : âˆ€á¶  x in f, p x â†’ q x) : âˆƒá¶  x in f, q x :=\n  mt (fun hq => hq.mp <| hpq.mono fun _ => mt) h\n\n"}
{"name":"Filter.frequently_congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np q : Î± â†’ Prop\nf : Filter Î±\nh : Filter.Eventually (fun x => Iff (p x) (q x)) f\nâŠ¢ Iff (Filter.Frequently (fun x => p x) f) (Filter.Frequently (fun x => q x) f)","decl":"lemma frequently_congr {p q : Î± â†’ Prop} {f : Filter Î±} (h : âˆ€á¶  x in f, p x â†” q x) :\n    (âˆƒá¶  x in f, p x) â†” âˆƒá¶  x in f, q x :=\n  âŸ¨fun h' â†¦ h'.mp (h.mono fun _ â†¦ Iff.mp), fun h' â†¦ h'.mp (h.mono fun _ â†¦ Iff.mpr)âŸ©\n\n"}
{"name":"Filter.Frequently.filter_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf g : Filter Î±\nh : Filter.Frequently (fun x => p x) f\nhle : LE.le f g\nâŠ¢ Filter.Frequently (fun x => p x) g","decl":"theorem Frequently.filter_mono {p : Î± â†’ Prop} {f g : Filter Î±} (h : âˆƒá¶  x in f, p x) (hle : f â‰¤ g) :\n    âˆƒá¶  x in g, p x :=\n  mt (fun h' => h'.filter_mono hle) h\n\n"}
{"name":"Filter.Frequently.mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np q : Î± â†’ Prop\nf : Filter Î±\nh : Filter.Frequently (fun x => p x) f\nhpq : âˆ€ (x : Î±), p x â†’ q x\nâŠ¢ Filter.Frequently (fun x => q x) f","decl":"theorem Frequently.mono {p q : Î± â†’ Prop} {f : Filter Î±} (h : âˆƒá¶  x in f, p x)\n    (hpq : âˆ€ x, p x â†’ q x) : âˆƒá¶  x in f, q x :=\n  h.mp (Eventually.of_forall hpq)\n\n"}
{"name":"Filter.Frequently.and_eventually","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np q : Î± â†’ Prop\nf : Filter Î±\nhp : Filter.Frequently (fun x => p x) f\nhq : Filter.Eventually (fun x => q x) f\nâŠ¢ Filter.Frequently (fun x => And (p x) (q x)) f","decl":"theorem Frequently.and_eventually {p q : Î± â†’ Prop} {f : Filter Î±} (hp : âˆƒá¶  x in f, p x)\n    (hq : âˆ€á¶  x in f, q x) : âˆƒá¶  x in f, p x âˆ§ q x := by\n  refine mt (fun h => hq.mp <| h.mono ?_) hp\n  exact fun x hpq hq hp => hpq âŸ¨hp, hqâŸ©\n\n"}
{"name":"Filter.Eventually.and_frequently","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np q : Î± â†’ Prop\nf : Filter Î±\nhp : Filter.Eventually (fun x => p x) f\nhq : Filter.Frequently (fun x => q x) f\nâŠ¢ Filter.Frequently (fun x => And (p x) (q x)) f","decl":"theorem Eventually.and_frequently {p q : Î± â†’ Prop} {f : Filter Î±} (hp : âˆ€á¶  x in f, p x)\n    (hq : âˆƒá¶  x in f, q x) : âˆƒá¶  x in f, p x âˆ§ q x := by\n  simpa only [and_comm] using hq.and_eventually hp\n\n"}
{"name":"Filter.Frequently.exists","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf : Filter Î±\nhp : Filter.Frequently (fun x => p x) f\nâŠ¢ Exists fun x => p x","decl":"theorem Frequently.exists {p : Î± â†’ Prop} {f : Filter Î±} (hp : âˆƒá¶  x in f, p x) : âˆƒ x, p x := by\n  by_contra H\n  replace H : âˆ€á¶  x in f, Â¬p x := Eventually.of_forall (not_exists.1 H)\n  exact hp H\n\n"}
{"name":"Filter.Eventually.exists","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf : Filter Î±\ninstâœ : f.NeBot\nhp : Filter.Eventually (fun x => p x) f\nâŠ¢ Exists fun x => p x","decl":"theorem Eventually.exists {p : Î± â†’ Prop} {f : Filter Î±} [NeBot f] (hp : âˆ€á¶  x in f, p x) :\n    âˆƒ x, p x :=\n  hp.frequently.exists\n\n"}
{"name":"Filter.frequently_iff_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nl : Filter Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => p x) l) (Min.min l (Filter.principal (setOf fun x => p x))).NeBot","decl":"lemma frequently_iff_neBot {l : Filter Î±} {p : Î± â†’ Prop} :\n    (âˆƒá¶  x in l, p x) â†” NeBot (l âŠ“ ğ“Ÿ {x | p x}) := by\n  rw [neBot_iff, Ne, inf_principal_eq_bot]; rfl\n\n"}
{"name":"Filter.frequently_mem_iff_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nl : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Filter.Frequently (fun x => Membership.mem s x) l) (Min.min l (Filter.principal s)).NeBot","decl":"lemma frequently_mem_iff_neBot {l : Filter Î±} {s : Set Î±} : (âˆƒá¶  x in l, x âˆˆ s) â†” NeBot (l âŠ“ ğ“Ÿ s) :=\n  frequently_iff_neBot\n\n"}
{"name":"Filter.frequently_iff_forall_eventually_exists_and","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf : Filter Î±\nâŠ¢ Iff (Filter.Frequently (fun x => p x) f) (âˆ€ {q : Î± â†’ Prop}, Filter.Eventually (fun x => q x) f â†’ Exists fun x => And (p x) (q x))","decl":"theorem frequently_iff_forall_eventually_exists_and {p : Î± â†’ Prop} {f : Filter Î±} :\n    (âˆƒá¶  x in f, p x) â†” âˆ€ {q : Î± â†’ Prop}, (âˆ€á¶  x in f, q x) â†’ âˆƒ x, p x âˆ§ q x :=\n  âŸ¨fun hp _ hq => (hp.and_eventually hq).exists, fun H hp => by\n    simpa only [and_not_self_iff, exists_false] using H hpâŸ©\n\n"}
{"name":"Filter.frequently_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nP : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => P x) f) (âˆ€ {U : Set Î±}, Membership.mem f U â†’ Exists fun x => And (Membership.mem U x) (P x))","decl":"theorem frequently_iff {f : Filter Î±} {P : Î± â†’ Prop} :\n    (âˆƒá¶  x in f, P x) â†” âˆ€ {U}, U âˆˆ f â†’ âˆƒ x âˆˆ U, P x := by\n  simp only [frequently_iff_forall_eventually_exists_and, @and_comm (P _)]\n  rfl\n\n"}
{"name":"Filter.not_eventually","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf : Filter Î±\nâŠ¢ Iff (Not (Filter.Eventually (fun x => p x) f)) (Filter.Frequently (fun x => Not (p x)) f)","decl":"@[simp]\ntheorem not_eventually {p : Î± â†’ Prop} {f : Filter Î±} : (Â¬âˆ€á¶  x in f, p x) â†” âˆƒá¶  x in f, Â¬p x := by\n  simp [Filter.Frequently]\n\n"}
{"name":"Filter.not_frequently","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf : Filter Î±\nâŠ¢ Iff (Not (Filter.Frequently (fun x => p x) f)) (Filter.Eventually (fun x => Not (p x)) f)","decl":"@[simp]\ntheorem not_frequently {p : Î± â†’ Prop} {f : Filter Î±} : (Â¬âˆƒá¶  x in f, p x) â†” âˆ€á¶  x in f, Â¬p x := by\n  simp only [Filter.Frequently, not_not]\n\n"}
{"name":"Filter.frequently_true_iff_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Iff (Filter.Frequently (fun x => True) f) f.NeBot","decl":"@[simp]\ntheorem frequently_true_iff_neBot (f : Filter Î±) : (âˆƒá¶  _ in f, True) â†” NeBot f := by\n  simp [frequently_iff_neBot]\n\n"}
{"name":"Filter.frequently_false","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Not (Filter.Frequently (fun x => False) f)","decl":"@[simp]\ntheorem frequently_false (f : Filter Î±) : Â¬âˆƒá¶  _ in f, False := by simp\n\n"}
{"name":"Filter.frequently_const","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\np : Prop\nâŠ¢ Iff (Filter.Frequently (fun x => p) f) p","decl":"@[simp]\ntheorem frequently_const {f : Filter Î±} [NeBot f] {p : Prop} : (âˆƒá¶  _ in f, p) â†” p := by\n  by_cases p <;> simp [*]\n\n"}
{"name":"Filter.frequently_or_distrib","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np q : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => Or (p x) (q x)) f) (Or (Filter.Frequently (fun x => p x) f) (Filter.Frequently (fun x => q x) f))","decl":"@[simp]\ntheorem frequently_or_distrib {f : Filter Î±} {p q : Î± â†’ Prop} :\n    (âˆƒá¶  x in f, p x âˆ¨ q x) â†” (âˆƒá¶  x in f, p x) âˆ¨ âˆƒá¶  x in f, q x := by\n  simp only [Filter.Frequently, â† not_and_or, not_or, eventually_and]\n\n"}
{"name":"Filter.frequently_or_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\np : Prop\nq : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => Or p (q x)) f) (Or p (Filter.Frequently (fun x => q x) f))","decl":"theorem frequently_or_distrib_left {f : Filter Î±} [NeBot f] {p : Prop} {q : Î± â†’ Prop} :\n    (âˆƒá¶  x in f, p âˆ¨ q x) â†” p âˆ¨ âˆƒá¶  x in f, q x := by simp\n\n"}
{"name":"Filter.frequently_or_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\np : Î± â†’ Prop\nq : Prop\nâŠ¢ Iff (Filter.Frequently (fun x => Or (p x) q) f) (Or (Filter.Frequently (fun x => p x) f) q)","decl":"theorem frequently_or_distrib_right {f : Filter Î±} [NeBot f] {p : Î± â†’ Prop} {q : Prop} :\n    (âˆƒá¶  x in f, p x âˆ¨ q) â†” (âˆƒá¶  x in f, p x) âˆ¨ q := by simp\n\n"}
{"name":"Filter.frequently_imp_distrib","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np q : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => p x â†’ q x) f) (Filter.Eventually (fun x => p x) f â†’ Filter.Frequently (fun x => q x) f)","decl":"theorem frequently_imp_distrib {f : Filter Î±} {p q : Î± â†’ Prop} :\n    (âˆƒá¶  x in f, p x â†’ q x) â†” (âˆ€á¶  x in f, p x) â†’ âˆƒá¶  x in f, q x := by\n  simp [imp_iff_not_or]\n\n"}
{"name":"Filter.frequently_imp_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\np : Prop\nq : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => p â†’ q x) f) (p â†’ Filter.Frequently (fun x => q x) f)","decl":"theorem frequently_imp_distrib_left {f : Filter Î±} [NeBot f] {p : Prop} {q : Î± â†’ Prop} :\n    (âˆƒá¶  x in f, p â†’ q x) â†” p â†’ âˆƒá¶  x in f, q x := by simp [frequently_imp_distrib]\n\n"}
{"name":"Filter.frequently_imp_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ninstâœ : f.NeBot\np : Î± â†’ Prop\nq : Prop\nâŠ¢ Iff (Filter.Frequently (fun x => p x â†’ q) f) (Filter.Eventually (fun x => p x) f â†’ q)","decl":"theorem frequently_imp_distrib_right {f : Filter Î±} [NeBot f] {p : Î± â†’ Prop} {q : Prop} :\n    (âˆƒá¶  x in f, p x â†’ q) â†” (âˆ€á¶  x in f, p x) â†’ q := by\n  simp only [frequently_imp_distrib, frequently_const]\n\n"}
{"name":"Filter.eventually_imp_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np : Î± â†’ Prop\nq : Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x â†’ q) f) (Filter.Frequently (fun x => p x) f â†’ q)","decl":"theorem eventually_imp_distrib_right {f : Filter Î±} {p : Î± â†’ Prop} {q : Prop} :\n    (âˆ€á¶  x in f, p x â†’ q) â†” (âˆƒá¶  x in f, p x) â†’ q := by\n  simp only [imp_iff_not_or, eventually_or_distrib_right, not_frequently]\n\n"}
{"name":"Filter.frequently_and_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np : Prop\nq : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => And p (q x)) f) (And p (Filter.Frequently (fun x => q x) f))","decl":"@[simp]\ntheorem frequently_and_distrib_left {f : Filter Î±} {p : Prop} {q : Î± â†’ Prop} :\n    (âˆƒá¶  x in f, p âˆ§ q x) â†” p âˆ§ âˆƒá¶  x in f, q x := by\n  simp only [Filter.Frequently, not_and, eventually_imp_distrib_left, Classical.not_imp]\n\n"}
{"name":"Filter.frequently_and_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\np : Î± â†’ Prop\nq : Prop\nâŠ¢ Iff (Filter.Frequently (fun x => And (p x) q) f) (And (Filter.Frequently (fun x => p x) f) q)","decl":"@[simp]\ntheorem frequently_and_distrib_right {f : Filter Î±} {p : Î± â†’ Prop} {q : Prop} :\n    (âˆƒá¶  x in f, p x âˆ§ q) â†” (âˆƒá¶  x in f, p x) âˆ§ q := by\n  simp only [@and_comm _ q, frequently_and_distrib_left]\n\n"}
{"name":"Filter.frequently_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nâŠ¢ Not (Filter.Frequently (fun x => p x) Bot.bot)","decl":"@[simp]\ntheorem frequently_bot {p : Î± â†’ Prop} : Â¬âˆƒá¶  x in âŠ¥, p x := by simp\n\n"}
{"name":"Filter.frequently_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => p x) Top.top) (Exists fun x => p x)","decl":"@[simp]\ntheorem frequently_top {p : Î± â†’ Prop} : (âˆƒá¶  x in âŠ¤, p x) â†” âˆƒ x, p x := by simp [Filter.Frequently]\n\n"}
{"name":"Filter.frequently_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\na : Set Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => p x) (Filter.principal a)) (Exists fun x => And (Membership.mem a x) (p x))","decl":"@[simp]\ntheorem frequently_principal {a : Set Î±} {p : Î± â†’ Prop} : (âˆƒá¶  x in ğ“Ÿ a, p x) â†” âˆƒ x âˆˆ a, p x := by\n  simp [Filter.Frequently, not_forall]\n\n"}
{"name":"Filter.frequently_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun x => p x) (Min.min f (Filter.principal s))) (Filter.Frequently (fun x => And (Membership.mem s x) (p x)) f)","decl":"theorem frequently_inf_principal {f : Filter Î±} {s : Set Î±} {p : Î± â†’ Prop} :\n    (âˆƒá¶  x in f âŠ“ ğ“Ÿ s, p x) â†” âˆƒá¶  x in f, x âˆˆ s âˆ§ p x := by\n  simp only [Filter.Frequently, eventually_inf_principal, not_and]\n\n"}
{"name":"Filter.Frequently.inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set Î±\np : Î± â†’ Prop\naâœ : Filter.Frequently (fun x => And (Membership.mem s x) (p x)) f\nâŠ¢ Filter.Frequently (fun x => p x) (Min.min f (Filter.principal s))","decl":"alias âŸ¨Frequently.of_inf_principal, Frequently.inf_principalâŸ© := frequently_inf_principal\n\n"}
{"name":"Filter.Frequently.of_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set Î±\np : Î± â†’ Prop\naâœ : Filter.Frequently (fun x => p x) (Min.min f (Filter.principal s))\nâŠ¢ Filter.Frequently (fun x => And (Membership.mem s x) (p x)) f","decl":"alias âŸ¨Frequently.of_inf_principal, Frequently.inf_principalâŸ© := frequently_inf_principal\n\n"}
{"name":"Filter.frequently_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nf g : Filter Î±\nâŠ¢ Iff (Filter.Frequently (fun x => p x) (Max.max f g)) (Or (Filter.Frequently (fun x => p x) f) (Filter.Frequently (fun x => p x) g))","decl":"theorem frequently_sup {p : Î± â†’ Prop} {f g : Filter Î±} :\n    (âˆƒá¶  x in f âŠ” g, p x) â†” (âˆƒá¶  x in f, p x) âˆ¨ âˆƒá¶  x in g, p x := by\n  simp only [Filter.Frequently, eventually_sup, not_and_or]\n\n"}
{"name":"Filter.frequently_sSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\np : Î± â†’ Prop\nfs : Set (Filter Î±)\nâŠ¢ Iff (Filter.Frequently (fun x => p x) (SupSet.sSup fs)) (Exists fun f => And (Membership.mem fs f) (Filter.Frequently (fun x => p x) f))","decl":"@[simp]\ntheorem frequently_sSup {p : Î± â†’ Prop} {fs : Set (Filter Î±)} :\n    (âˆƒá¶  x in sSup fs, p x) â†” âˆƒ f âˆˆ fs, âˆƒá¶  x in f, p x := by\n  simp only [Filter.Frequently, not_forall, eventually_sSup, exists_prop]\n\n"}
{"name":"Filter.frequently_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\np : Î± â†’ Prop\nfs : Î² â†’ Filter Î±\nâŠ¢ Iff (Filter.Frequently (fun x => p x) (iSup fun b => fs b)) (Exists fun b => Filter.Frequently (fun x => p x) (fs b))","decl":"@[simp]\ntheorem frequently_iSup {p : Î± â†’ Prop} {fs : Î² â†’ Filter Î±} :\n    (âˆƒá¶  x in â¨† b, fs b, p x) â†” âˆƒ b, âˆƒá¶  x in fs b, p x := by\n  simp only [Filter.Frequently, eventually_iSup, not_forall]\n\n"}
{"name":"Filter.Eventually.choice","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nr : Î± â†’ Î² â†’ Prop\nl : Filter Î±\ninstâœ : l.NeBot\nh : Filter.Eventually (fun x => Exists fun y => r x y) l\nâŠ¢ Exists fun f => Filter.Eventually (fun x => r x (f x)) l","decl":"theorem Eventually.choice {r : Î± â†’ Î² â†’ Prop} {l : Filter Î±} [l.NeBot] (h : âˆ€á¶  x in l, âˆƒ y, r x y) :\n    âˆƒ f : Î± â†’ Î², âˆ€á¶  x in l, r x (f x) := by\n  haveI : Nonempty Î² := let âŸ¨_, hxâŸ© := h.exists; hx.nonempty\n  choose! f hf using fun x (hx : âˆƒ y, r x y) => hx\n  exact âŸ¨f, h.mono hfâŸ©\n\n"}
{"name":"Filter.skolem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\ninstâœ : âˆ€ (i : Î¹), Nonempty (Î± i)\nP : (i : Î¹) â†’ Î± i â†’ Prop\nF : Filter Î¹\nâŠ¢ Iff (Filter.Eventually (fun i => Exists fun b => P i b) F) (Exists fun b => Filter.Eventually (fun i => P i (b i)) F)","decl":"lemma skolem {Î¹ : Type*} {Î± : Î¹ â†’ Type*} [âˆ€ i, Nonempty (Î± i)]\n    {P : âˆ€ i : Î¹, Î± i â†’ Prop} {F : Filter Î¹} :\n    (âˆ€á¶  i in F, âˆƒ b, P i b) â†” âˆƒ b : (Î  i, Î± i), âˆ€á¶  i in F, P i (b i) := by\n  classical\n  refine âŸ¨fun H â†¦ ?_, fun âŸ¨b, hbâŸ© â†¦ hb.mp (.of_forall fun x a â†¦ âŸ¨_, aâŸ©)âŸ©\n  refine âŸ¨fun i â†¦ if h : âˆƒ b, P i b then h.choose else Nonempty.some inferInstance, ?_âŸ©\n  filter_upwards [H] with i hi\n  exact dif_pos hi â–¸ hi.choose_spec\n\n"}
{"name":"Filter.EventuallyEq.eventually","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g : Î± â†’ Î²\nh : l.EventuallyEq f g\nâŠ¢ Filter.Eventually (fun x => Eq (f x) (g x)) l","decl":"theorem EventuallyEq.eventually (h : f =á¶ [l] g) : âˆ€á¶  x in l, f x = g x := h\n\n"}
{"name":"Filter.eventuallyEq_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Î± â†’ Î²\nâŠ¢ Iff (Top.top.EventuallyEq f g) (Eq f g)","decl":"@[simp] lemma eventuallyEq_top : f =á¶ [âŠ¤] g â†” f = g := by simp [EventuallyEq, funext_iff]\n\n"}
{"name":"Filter.EventuallyEq.rw","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g : Î± â†’ Î²\nh : l.EventuallyEq f g\np : Î± â†’ Î² â†’ Prop\nhf : Filter.Eventually (fun x => p x (f x)) l\nâŠ¢ Filter.Eventually (fun x => p x (g x)) l","decl":"theorem EventuallyEq.rw {l : Filter Î±} {f g : Î± â†’ Î²} (h : f =á¶ [l] g) (p : Î± â†’ Î² â†’ Prop)\n    (hf : âˆ€á¶  x in l, p x (f x)) : âˆ€á¶  x in l, p x (g x) :=\n  hf.congr <| h.mono fun _ hx => hx â–¸ Iff.rfl\n\n"}
{"name":"Filter.eventuallyEq_set","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyEq s t) (Filter.Eventually (fun x => Iff (Membership.mem s x) (Membership.mem t x)) l)","decl":"theorem eventuallyEq_set {s t : Set Î±} {l : Filter Î±} : s =á¶ [l] t â†” âˆ€á¶  x in l, x âˆˆ s â†” x âˆˆ t :=\n  eventually_congr <| Eventually.of_forall fun _ â†¦ eq_iff_iff\n\n"}
{"name":"Filter.Eventually.set_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\naâœ : Filter.Eventually (fun x => Iff (Membership.mem s x) (Membership.mem t x)) l\nâŠ¢ l.EventuallyEq s t","decl":"alias âŸ¨EventuallyEq.mem_iff, Eventually.set_eqâŸ© := eventuallyEq_set\n\n"}
{"name":"Filter.EventuallyEq.mem_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\naâœ : l.EventuallyEq s t\nâŠ¢ Filter.Eventually (fun x => Iff (Membership.mem s x) (Membership.mem t x)) l","decl":"alias âŸ¨EventuallyEq.mem_iff, Eventually.set_eqâŸ© := eventuallyEq_set\n\n"}
{"name":"Filter.eventuallyEq_univ","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyEq s Set.univ) (Membership.mem l s)","decl":"@[simp]\ntheorem eventuallyEq_univ {s : Set Î±} {l : Filter Î±} : s =á¶ [l] univ â†” s âˆˆ l := by\n  simp [eventuallyEq_set]\n\n"}
{"name":"Filter.EventuallyEq.exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g : Î± â†’ Î²\nh : l.EventuallyEq f g\nâŠ¢ Exists fun s => And (Membership.mem l s) (Set.EqOn f g s)","decl":"theorem EventuallyEq.exists_mem {l : Filter Î±} {f g : Î± â†’ Î²} (h : f =á¶ [l] g) :\n    âˆƒ s âˆˆ l, EqOn f g s :=\n  Eventually.exists_mem h\n\n"}
{"name":"Filter.eventuallyEq_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g : Î± â†’ Î²\ns : Set Î±\nhs : Membership.mem l s\nh : Set.EqOn f g s\nâŠ¢ l.EventuallyEq f g","decl":"theorem eventuallyEq_of_mem {l : Filter Î±} {f g : Î± â†’ Î²} {s : Set Î±} (hs : s âˆˆ l) (h : EqOn f g s) :\n    f =á¶ [l] g :=\n  eventually_of_mem hs h\n\n"}
{"name":"Filter.eventuallyEq_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g : Î± â†’ Î²\nâŠ¢ Iff (l.EventuallyEq f g) (Exists fun s => And (Membership.mem l s) (Set.EqOn f g s))","decl":"theorem eventuallyEq_iff_exists_mem {l : Filter Î±} {f g : Î± â†’ Î²} :\n    f =á¶ [l] g â†” âˆƒ s âˆˆ l, EqOn f g s :=\n  eventually_iff_exists_mem\n\n"}
{"name":"Filter.EventuallyEq.filter_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl l' : Filter Î±\nf g : Î± â†’ Î²\nhâ‚ : l.EventuallyEq f g\nhâ‚‚ : LE.le l' l\nâŠ¢ l'.EventuallyEq f g","decl":"theorem EventuallyEq.filter_mono {l l' : Filter Î±} {f g : Î± â†’ Î²} (hâ‚ : f =á¶ [l] g) (hâ‚‚ : l' â‰¤ l) :\n    f =á¶ [l'] g :=\n  hâ‚‚ hâ‚\n\n"}
{"name":"Filter.EventuallyEq.refl","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf : Î± â†’ Î²\nâŠ¢ l.EventuallyEq f f","decl":"@[refl, simp]\ntheorem EventuallyEq.refl (l : Filter Î±) (f : Î± â†’ Î²) : f =á¶ [l] f :=\n  Eventually.of_forall fun _ => rfl\n\n"}
{"name":"Filter.EventuallyEq.rfl","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf : Î± â†’ Î²\nâŠ¢ l.EventuallyEq f f","decl":"protected theorem EventuallyEq.rfl {l : Filter Î±} {f : Î± â†’ Î²} : f =á¶ [l] f :=\n  EventuallyEq.refl l f\n\n"}
{"name":"Filter.EventuallyEq.of_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g : Î± â†’ Î²\nh : Eq f g\nâŠ¢ l.EventuallyEq f g","decl":"theorem EventuallyEq.of_eq {l : Filter Î±} {f g : Î± â†’ Î²} (h : f = g) : f =á¶ [l] g := h â–¸ .rfl\n"}
{"name":"Eq.eventuallyEq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g : Î± â†’ Î²\nh : Eq f g\nâŠ¢ l.EventuallyEq f g","decl":"alias _root_.Eq.eventuallyEq := EventuallyEq.of_eq\n\n"}
{"name":"Filter.EventuallyEq.symm","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Î± â†’ Î²\nl : Filter Î±\nH : l.EventuallyEq f g\nâŠ¢ l.EventuallyEq g f","decl":"@[symm]\ntheorem EventuallyEq.symm {f g : Î± â†’ Î²} {l : Filter Î±} (H : f =á¶ [l] g) : g =á¶ [l] f :=\n  H.mono fun _ => Eq.symm\n\n"}
{"name":"Filter.eventuallyEq_comm","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Î± â†’ Î²\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyEq f g) (l.EventuallyEq g f)","decl":"lemma eventuallyEq_comm {f g : Î± â†’ Î²} {l : Filter Î±} : f =á¶ [l] g â†” g =á¶ [l] f := âŸ¨.symm, .symmâŸ©\n\n"}
{"name":"Filter.EventuallyEq.trans","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g h : Î± â†’ Î²\nHâ‚ : l.EventuallyEq f g\nHâ‚‚ : l.EventuallyEq g h\nâŠ¢ l.EventuallyEq f h","decl":"@[trans]\ntheorem EventuallyEq.trans {l : Filter Î±} {f g h : Î± â†’ Î²} (Hâ‚ : f =á¶ [l] g) (Hâ‚‚ : g =á¶ [l] h) :\n    f =á¶ [l] h :=\n  Hâ‚‚.rw (fun x y => f x = y) Hâ‚\n\n"}
{"name":"Filter.EventuallyEq.congr_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g h : Î± â†’ Î²\nH : l.EventuallyEq f g\nâŠ¢ Iff (l.EventuallyEq f h) (l.EventuallyEq g h)","decl":"theorem EventuallyEq.congr_left {l : Filter Î±} {f g h : Î± â†’ Î²} (H : f =á¶ [l] g) :\n    f =á¶ [l] h â†” g =á¶ [l] h :=\n  âŸ¨H.symm.trans, H.transâŸ©\n\n"}
{"name":"Filter.EventuallyEq.congr_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g h : Î± â†’ Î²\nH : l.EventuallyEq g h\nâŠ¢ Iff (l.EventuallyEq f g) (l.EventuallyEq f h)","decl":"theorem EventuallyEq.congr_right {l : Filter Î±} {f g h : Î± â†’ Î²} (H : g =á¶ [l] h) :\n    f =á¶ [l] g â†” f =á¶ [l] h :=\n  âŸ¨(Â·.trans H), (Â·.trans H.symm)âŸ©\n\n"}
{"name":"Filter.EventuallyEq.prod_mk","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nl : Filter Î±\nf f' : Î± â†’ Î²\nhf : l.EventuallyEq f f'\ng g' : Î± â†’ Î³\nhg : l.EventuallyEq g g'\nâŠ¢ l.EventuallyEq (fun x => { fst := f x, snd := g x }) fun x => { fst := f' x, snd := g' x }","decl":"theorem EventuallyEq.prod_mk {l} {f f' : Î± â†’ Î²} (hf : f =á¶ [l] f') {g g' : Î± â†’ Î³} (hg : g =á¶ [l] g') :\n    (fun x => (f x, g x)) =á¶ [l] fun x => (f' x, g' x) :=\n  hf.mp <|\n    hg.mono <| by\n      intros\n      simp only [*]\n\n-- See `EventuallyEq.comp_tendsto` further below for a similar statement w.r.t.\n-- composition on the right.\n"}
{"name":"Filter.EventuallyEq.fun_comp","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nf g : Î± â†’ Î²\nl : Filter Î±\nH : l.EventuallyEq f g\nh : Î² â†’ Î³\nâŠ¢ l.EventuallyEq (Function.comp h f) (Function.comp h g)","decl":"theorem EventuallyEq.fun_comp {f g : Î± â†’ Î²} {l : Filter Î±} (H : f =á¶ [l] g) (h : Î² â†’ Î³) :\n    h âˆ˜ f =á¶ [l] h âˆ˜ g :=\n  H.mono fun _ hx => congr_arg h hx\n\n"}
{"name":"Filter.EventuallyEq.compâ‚‚","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_2\nf f' : Î± â†’ Î²\ng g' : Î± â†’ Î³\nl : Filter Î±\nHf : l.EventuallyEq f f'\nh : Î² â†’ Î³ â†’ Î´\nHg : l.EventuallyEq g g'\nâŠ¢ l.EventuallyEq (fun x => h (f x) (g x)) fun x => h (f' x) (g' x)","decl":"theorem EventuallyEq.compâ‚‚ {Î´} {f f' : Î± â†’ Î²} {g g' : Î± â†’ Î³} {l} (Hf : f =á¶ [l] f') (h : Î² â†’ Î³ â†’ Î´)\n    (Hg : g =á¶ [l] g') : (fun x => h (f x) (g x)) =á¶ [l] fun x => h (f' x) (g' x) :=\n  (Hf.prod_mk Hg).fun_comp (uncurry h)\n\n"}
{"name":"Filter.EventuallyEq.add","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Add Î²\nf f' g g' : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nh' : l.EventuallyEq f' g'\nâŠ¢ l.EventuallyEq (fun x => HAdd.hAdd (f x) (f' x)) fun x => HAdd.hAdd (g x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.mul [Mul Î²] {f f' g g' : Î± â†’ Î²} {l : Filter Î±} (h : f =á¶ [l] g)\n    (h' : f' =á¶ [l] g') : (fun x => f x * f' x) =á¶ [l] fun x => g x * g' x :=\n  h.compâ‚‚ (Â· * Â·) h'\n\n"}
{"name":"Filter.EventuallyEq.mul","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Mul Î²\nf f' g g' : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nh' : l.EventuallyEq f' g'\nâŠ¢ l.EventuallyEq (fun x => HMul.hMul (f x) (f' x)) fun x => HMul.hMul (g x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.mul [Mul Î²] {f f' g g' : Î± â†’ Î²} {l : Filter Î±} (h : f =á¶ [l] g)\n    (h' : f' =á¶ [l] g') : (fun x => f x * f' x) =á¶ [l] fun x => g x * g' x :=\n  h.compâ‚‚ (Â· * Â·) h'\n\n"}
{"name":"Filter.EventuallyEq.pow_const","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type u_2\ninstâœ : Pow Î² Î³\nf g : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nc : Î³\nâŠ¢ l.EventuallyEq (fun x => HPow.hPow (f x) c) fun x => HPow.hPow (g x) c","decl":"@[to_additive const_smul]\ntheorem EventuallyEq.pow_const {Î³} [Pow Î² Î³] {f g : Î± â†’ Î²} {l : Filter Î±} (h : f =á¶ [l] g) (c : Î³) :\n    (fun x => f x ^ c) =á¶ [l] fun x => g x ^ c :=\n  h.fun_comp (Â· ^ c)\n\n"}
{"name":"Filter.EventuallyEq.const_smul","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type u_2\ninstâœ : SMul Î³ Î²\nf g : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nc : Î³\nâŠ¢ l.EventuallyEq (fun x => HSMul.hSMul c (f x)) fun x => HSMul.hSMul c (g x)","decl":"@[to_additive const_smul]\ntheorem EventuallyEq.pow_const {Î³} [Pow Î² Î³] {f g : Î± â†’ Î²} {l : Filter Î±} (h : f =á¶ [l] g) (c : Î³) :\n    (fun x => f x ^ c) =á¶ [l] fun x => g x ^ c :=\n  h.fun_comp (Â· ^ c)\n\n"}
{"name":"Filter.EventuallyEq.neg","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Neg Î²\nf g : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nâŠ¢ l.EventuallyEq (fun x => Neg.neg (f x)) fun x => Neg.neg (g x)","decl":"@[to_additive]\ntheorem EventuallyEq.inv [Inv Î²] {f g : Î± â†’ Î²} {l : Filter Î±} (h : f =á¶ [l] g) :\n    (fun x => (f x)â»Â¹) =á¶ [l] fun x => (g x)â»Â¹ :=\n  h.fun_comp Inv.inv\n\n"}
{"name":"Filter.EventuallyEq.inv","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Inv Î²\nf g : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nâŠ¢ l.EventuallyEq (fun x => Inv.inv (f x)) fun x => Inv.inv (g x)","decl":"@[to_additive]\ntheorem EventuallyEq.inv [Inv Î²] {f g : Î± â†’ Î²} {l : Filter Î±} (h : f =á¶ [l] g) :\n    (fun x => (f x)â»Â¹) =á¶ [l] fun x => (g x)â»Â¹ :=\n  h.fun_comp Inv.inv\n\n"}
{"name":"Filter.EventuallyEq.div","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Div Î²\nf f' g g' : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nh' : l.EventuallyEq f' g'\nâŠ¢ l.EventuallyEq (fun x => HDiv.hDiv (f x) (f' x)) fun x => HDiv.hDiv (g x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.div [Div Î²] {f f' g g' : Î± â†’ Î²} {l : Filter Î±} (h : f =á¶ [l] g)\n    (h' : f' =á¶ [l] g') : (fun x => f x / f' x) =á¶ [l] fun x => g x / g' x :=\n  h.compâ‚‚ (Â· / Â·) h'\n\n"}
{"name":"Filter.EventuallyEq.sub","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Sub Î²\nf f' g g' : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nh' : l.EventuallyEq f' g'\nâŠ¢ l.EventuallyEq (fun x => HSub.hSub (f x) (f' x)) fun x => HSub.hSub (g x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.div [Div Î²] {f f' g g' : Î± â†’ Î²} {l : Filter Î±} (h : f =á¶ [l] g)\n    (h' : f' =á¶ [l] g') : (fun x => f x / f' x) =á¶ [l] fun x => g x / g' x :=\n  h.compâ‚‚ (Â· / Â·) h'\n\n"}
{"name":"Filter.EventuallyEq.const_vadd","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type u_2\ninstâœ : VAdd Î³ Î²\nf g : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nc : Î³\nâŠ¢ l.EventuallyEq (fun x => HVAdd.hVAdd c (f x)) fun x => HVAdd.hVAdd c (g x)","decl":"attribute [to_additive] EventuallyEq.const_smul\n\n"}
{"name":"Filter.EventuallyEq.vadd","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœ : VAdd ğ•œ Î²\nl : Filter Î±\nf f' : Î± â†’ ğ•œ\ng g' : Î± â†’ Î²\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\nâŠ¢ l.EventuallyEq (fun x => HVAdd.hVAdd (f x) (g x)) fun x => HVAdd.hVAdd (f' x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.smul {ğ•œ} [SMul ğ•œ Î²] {l : Filter Î±} {f f' : Î± â†’ ğ•œ} {g g' : Î± â†’ Î²}\n    (hf : f =á¶ [l] f') (hg : g =á¶ [l] g') : (fun x => f x â€¢ g x) =á¶ [l] fun x => f' x â€¢ g' x :=\n  hf.compâ‚‚ (Â· â€¢ Â·) hg\n\n"}
{"name":"Filter.EventuallyEq.smul","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœ : SMul ğ•œ Î²\nl : Filter Î±\nf f' : Î± â†’ ğ•œ\ng g' : Î± â†’ Î²\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\nâŠ¢ l.EventuallyEq (fun x => HSMul.hSMul (f x) (g x)) fun x => HSMul.hSMul (f' x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.smul {ğ•œ} [SMul ğ•œ Î²] {l : Filter Î±} {f f' : Î± â†’ ğ•œ} {g g' : Î± â†’ Î²}\n    (hf : f =á¶ [l] f') (hg : g =á¶ [l] g') : (fun x => f x â€¢ g x) =á¶ [l] fun x => f' x â€¢ g' x :=\n  hf.compâ‚‚ (Â· â€¢ Â·) hg\n\n"}
{"name":"Filter.EventuallyEq.sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Max Î²\nl : Filter Î±\nf f' g g' : Î± â†’ Î²\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\nâŠ¢ l.EventuallyEq (fun x => Max.max (f x) (g x)) fun x => Max.max (f' x) (g' x)","decl":"theorem EventuallyEq.sup [Max Î²] {l : Filter Î±} {f f' g g' : Î± â†’ Î²} (hf : f =á¶ [l] f')\n    (hg : g =á¶ [l] g') : (fun x => f x âŠ” g x) =á¶ [l] fun x => f' x âŠ” g' x :=\n  hf.compâ‚‚ (Â· âŠ” Â·) hg\n\n"}
{"name":"Filter.EventuallyEq.inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Min Î²\nl : Filter Î±\nf f' g g' : Î± â†’ Î²\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\nâŠ¢ l.EventuallyEq (fun x => Min.min (f x) (g x)) fun x => Min.min (f' x) (g' x)","decl":"theorem EventuallyEq.inf [Min Î²] {l : Filter Î±} {f f' g g' : Î± â†’ Î²} (hf : f =á¶ [l] f')\n    (hg : g =á¶ [l] g') : (fun x => f x âŠ“ g x) =á¶ [l] fun x => f' x âŠ“ g' x :=\n  hf.compâ‚‚ (Â· âŠ“ Â·) hg\n\n"}
{"name":"Filter.EventuallyEq.preimage","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nl : Filter Î±\nf g : Î± â†’ Î²\nh : l.EventuallyEq f g\ns : Set Î²\nâŠ¢ l.EventuallyEq (Set.preimage f s) (Set.preimage g s)","decl":"theorem EventuallyEq.preimage {l : Filter Î±} {f g : Î± â†’ Î²} (h : f =á¶ [l] g) (s : Set Î²) :\n    f â»Â¹' s =á¶ [l] g â»Â¹' s :=\n  h.fun_comp s\n\n"}
{"name":"Filter.EventuallyEq.inter","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t s' t' : Set Î±\nl : Filter Î±\nh : l.EventuallyEq s t\nh' : l.EventuallyEq s' t'\nâŠ¢ l.EventuallyEq (Inter.inter s s') (Inter.inter t t')","decl":"theorem EventuallyEq.inter {s t s' t' : Set Î±} {l : Filter Î±} (h : s =á¶ [l] t) (h' : s' =á¶ [l] t') :\n    (s âˆ© s' : Set Î±) =á¶ [l] (t âˆ© t' : Set Î±) :=\n  h.compâ‚‚ (Â· âˆ§ Â·) h'\n\n"}
{"name":"Filter.EventuallyEq.union","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t s' t' : Set Î±\nl : Filter Î±\nh : l.EventuallyEq s t\nh' : l.EventuallyEq s' t'\nâŠ¢ l.EventuallyEq (Union.union s s') (Union.union t t')","decl":"theorem EventuallyEq.union {s t s' t' : Set Î±} {l : Filter Î±} (h : s =á¶ [l] t) (h' : s' =á¶ [l] t') :\n    (s âˆª s' : Set Î±) =á¶ [l] (t âˆª t' : Set Î±) :=\n  h.compâ‚‚ (Â· âˆ¨ Â·) h'\n\n"}
{"name":"Filter.EventuallyEq.compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\nh : l.EventuallyEq s t\nâŠ¢ l.EventuallyEq (HasCompl.compl s) (HasCompl.compl t)","decl":"theorem EventuallyEq.compl {s t : Set Î±} {l : Filter Î±} (h : s =á¶ [l] t) :\n    (sá¶œ : Set Î±) =á¶ [l] (tá¶œ : Set Î±) :=\n  h.fun_comp Not\n\n"}
{"name":"Filter.EventuallyEq.diff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t s' t' : Set Î±\nl : Filter Î±\nh : l.EventuallyEq s t\nh' : l.EventuallyEq s' t'\nâŠ¢ l.EventuallyEq (SDiff.sdiff s s') (SDiff.sdiff t t')","decl":"theorem EventuallyEq.diff {s t s' t' : Set Î±} {l : Filter Î±} (h : s =á¶ [l] t) (h' : s' =á¶ [l] t') :\n    (s \\ s' : Set Î±) =á¶ [l] (t \\ t' : Set Î±) :=\n  h.inter h'.compl\n\n"}
{"name":"Filter.EventuallyEq.symmDiff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t s' t' : Set Î±\nl : Filter Î±\nh : l.EventuallyEq s t\nh' : l.EventuallyEq s' t'\nâŠ¢ l.EventuallyEq (symmDiff s s') (symmDiff t t')","decl":"protected theorem EventuallyEq.symmDiff {s t s' t' : Set Î±} {l : Filter Î±}\n    (h : s =á¶ [l] t) (h' : s' =á¶ [l] t') : (s âˆ† s' : Set Î±) =á¶ [l] (t âˆ† t' : Set Î±) :=\n  (h.diff h').union (h'.diff h)\n\n"}
{"name":"Filter.eventuallyEq_empty","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyEq s EmptyCollection.emptyCollection) (Filter.Eventually (fun x => Not (Membership.mem s x)) l)","decl":"theorem eventuallyEq_empty {s : Set Î±} {l : Filter Î±} : s =á¶ [l] (âˆ… : Set Î±) â†” âˆ€á¶  x in l, x âˆ‰ s :=\n  eventuallyEq_set.trans <| by simp\n\n"}
{"name":"Filter.inter_eventuallyEq_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyEq (Inter.inter s t) s) (Filter.Eventually (fun x => Membership.mem s x â†’ Membership.mem t x) l)","decl":"theorem inter_eventuallyEq_left {s t : Set Î±} {l : Filter Î±} :\n    (s âˆ© t : Set Î±) =á¶ [l] s â†” âˆ€á¶  x in l, x âˆˆ s â†’ x âˆˆ t := by\n  simp only [eventuallyEq_set, mem_inter_iff, and_iff_left_iff_imp]\n\n"}
{"name":"Filter.inter_eventuallyEq_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyEq (Inter.inter s t) t) (Filter.Eventually (fun x => Membership.mem t x â†’ Membership.mem s x) l)","decl":"theorem inter_eventuallyEq_right {s t : Set Î±} {l : Filter Î±} :\n    (s âˆ© t : Set Î±) =á¶ [l] t â†” âˆ€á¶  x in l, x âˆˆ t â†’ x âˆˆ s := by\n  rw [inter_comm, inter_eventuallyEq_left]\n\n"}
{"name":"Filter.eventuallyEq_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ns : Set Î±\nf g : Î± â†’ Î²\nâŠ¢ Iff ((Filter.principal s).EventuallyEq f g) (Set.EqOn f g s)","decl":"@[simp]\ntheorem eventuallyEq_principal {s : Set Î±} {f g : Î± â†’ Î²} : f =á¶ [ğ“Ÿ s] g â†” EqOn f g s :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventuallyEq_inf_principal_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nF : Filter Î±\ns : Set Î±\nf g : Î± â†’ Î²\nâŠ¢ Iff ((Min.min F (Filter.principal s)).EventuallyEq f g) (Filter.Eventually (fun x => Membership.mem s x â†’ Eq (f x) (g x)) F)","decl":"theorem eventuallyEq_inf_principal_iff {F : Filter Î±} {s : Set Î±} {f g : Î± â†’ Î²} :\n    f =á¶ [F âŠ“ ğ“Ÿ s] g â†” âˆ€á¶  x in F, x âˆˆ s â†’ f x = g x :=\n  eventually_inf_principal\n\n"}
{"name":"Filter.EventuallyEq.sub_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : AddGroup Î²\nf g : Î± â†’ Î²\nl : Filter Î±\nh : l.EventuallyEq f g\nâŠ¢ l.EventuallyEq (HSub.hSub f g) 0","decl":"theorem EventuallyEq.sub_eq [AddGroup Î²] {f g : Î± â†’ Î²} {l : Filter Î±} (h : f =á¶ [l] g) :\n    f - g =á¶ [l] 0 := by simpa using ((EventuallyEq.refl l f).sub h).symm\n\n"}
{"name":"Filter.eventuallyEq_iff_sub","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : AddGroup Î²\nf g : Î± â†’ Î²\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyEq f g) (l.EventuallyEq (HSub.hSub f g) 0)","decl":"theorem eventuallyEq_iff_sub [AddGroup Î²] {f g : Î± â†’ Î²} {l : Filter Î±} :\n    f =á¶ [l] g â†” f - g =á¶ [l] 0 :=\n  âŸ¨fun h => h.sub_eq, fun h => by simpa using h.add (EventuallyEq.refl l g)âŸ©\n\n"}
{"name":"Filter.eventuallyEq_iff_all_subsets","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Î± â†’ Î²\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyEq f g) (âˆ€ (s : Set Î±), Filter.Eventually (fun x => Membership.mem s x â†’ Eq (f x) (g x)) l)","decl":"theorem eventuallyEq_iff_all_subsets {f g : Î± â†’ Î²} {l : Filter Î±} :\n    f =á¶ [l] g â†” âˆ€ s : Set Î±, âˆ€á¶  x in l, x âˆˆ s â†’ f x = g x :=\n  eventually_iff_all_subsets\n\n"}
{"name":"Filter.EventuallyLE.congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : LE Î²\nl : Filter Î±\nf f' g g' : Î± â†’ Î²\nH : l.EventuallyLE f g\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\nâŠ¢ l.EventuallyLE f' g'","decl":"theorem EventuallyLE.congr {f f' g g' : Î± â†’ Î²} (H : f â‰¤á¶ [l] g) (hf : f =á¶ [l] f') (hg : g =á¶ [l] g') :\n    f' â‰¤á¶ [l] g' :=\n  H.mp <| hg.mp <| hf.mono fun x hf hg H => by rwa [hf, hg] at H\n\n"}
{"name":"Filter.eventuallyLE_congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : LE Î²\nl : Filter Î±\nf f' g g' : Î± â†’ Î²\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\nâŠ¢ Iff (l.EventuallyLE f g) (l.EventuallyLE f' g')","decl":"theorem eventuallyLE_congr {f f' g g' : Î± â†’ Î²} (hf : f =á¶ [l] f') (hg : g =á¶ [l] g') :\n    f â‰¤á¶ [l] g â†” f' â‰¤á¶ [l] g' :=\n  âŸ¨fun H => H.congr hf hg, fun H => H.congr hf.symm hg.symmâŸ©\n\n"}
{"name":"Filter.eventuallyLE_iff_all_subsets","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : LE Î²\nf g : Î± â†’ Î²\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyLE f g) (âˆ€ (s : Set Î±), Filter.Eventually (fun x => Membership.mem s x â†’ LE.le (f x) (g x)) l)","decl":"theorem eventuallyLE_iff_all_subsets {f g : Î± â†’ Î²} {l : Filter Î±} :\n    f â‰¤á¶ [l] g â†” âˆ€ s : Set Î±, âˆ€á¶  x in l, x âˆˆ s â†’ f x â‰¤ g x :=\n  eventually_iff_all_subsets\n\n"}
{"name":"Filter.EventuallyEq.le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Preorder Î²\nl : Filter Î±\nf g : Î± â†’ Î²\nh : l.EventuallyEq f g\nâŠ¢ l.EventuallyLE f g","decl":"theorem EventuallyEq.le (h : f =á¶ [l] g) : f â‰¤á¶ [l] g :=\n  h.mono fun _ => le_of_eq\n\n"}
{"name":"Filter.EventuallyLE.refl","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Preorder Î²\nl : Filter Î±\nf : Î± â†’ Î²\nâŠ¢ l.EventuallyLE f f","decl":"@[refl]\ntheorem EventuallyLE.refl (l : Filter Î±) (f : Î± â†’ Î²) : f â‰¤á¶ [l] f :=\n  EventuallyEq.rfl.le\n\n"}
{"name":"Filter.EventuallyLE.rfl","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Preorder Î²\nl : Filter Î±\nf : Î± â†’ Î²\nâŠ¢ l.EventuallyLE f f","decl":"theorem EventuallyLE.rfl : f â‰¤á¶ [l] f :=\n  EventuallyLE.refl l f\n\n"}
{"name":"Filter.EventuallyLE.trans","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Preorder Î²\nl : Filter Î±\nf g h : Î± â†’ Î²\nHâ‚ : l.EventuallyLE f g\nHâ‚‚ : l.EventuallyLE g h\nâŠ¢ l.EventuallyLE f h","decl":"@[trans]\ntheorem EventuallyLE.trans (Hâ‚ : f â‰¤á¶ [l] g) (Hâ‚‚ : g â‰¤á¶ [l] h) : f â‰¤á¶ [l] h :=\n  Hâ‚‚.mp <| Hâ‚.mono fun _ => le_trans\n\n"}
{"name":"Filter.EventuallyEq.trans_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Preorder Î²\nl : Filter Î±\nf g h : Î± â†’ Î²\nHâ‚ : l.EventuallyEq f g\nHâ‚‚ : l.EventuallyLE g h\nâŠ¢ l.EventuallyLE f h","decl":"@[trans]\ntheorem EventuallyEq.trans_le (Hâ‚ : f =á¶ [l] g) (Hâ‚‚ : g â‰¤á¶ [l] h) : f â‰¤á¶ [l] h :=\n  Hâ‚.le.trans Hâ‚‚\n\n"}
{"name":"Filter.EventuallyLE.trans_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Preorder Î²\nl : Filter Î±\nf g h : Î± â†’ Î²\nHâ‚ : l.EventuallyLE f g\nHâ‚‚ : l.EventuallyEq g h\nâŠ¢ l.EventuallyLE f h","decl":"@[trans]\ntheorem EventuallyLE.trans_eq (Hâ‚ : f â‰¤á¶ [l] g) (Hâ‚‚ : g =á¶ [l] h) : f â‰¤á¶ [l] h :=\n  Hâ‚.trans Hâ‚‚.le\n\n"}
{"name":"Filter.EventuallyLE.antisymm","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : PartialOrder Î²\nl : Filter Î±\nf g : Î± â†’ Î²\nhâ‚ : l.EventuallyLE f g\nhâ‚‚ : l.EventuallyLE g f\nâŠ¢ l.EventuallyEq f g","decl":"theorem EventuallyLE.antisymm [PartialOrder Î²] {l : Filter Î±} {f g : Î± â†’ Î²} (hâ‚ : f â‰¤á¶ [l] g)\n    (hâ‚‚ : g â‰¤á¶ [l] f) : f =á¶ [l] g :=\n  hâ‚‚.mp <| hâ‚.mono fun _ => le_antisymm\n\n"}
{"name":"Filter.eventuallyLE_antisymm_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : PartialOrder Î²\nl : Filter Î±\nf g : Î± â†’ Î²\nâŠ¢ Iff (l.EventuallyEq f g) (And (l.EventuallyLE f g) (l.EventuallyLE g f))","decl":"theorem eventuallyLE_antisymm_iff [PartialOrder Î²] {l : Filter Î±} {f g : Î± â†’ Î²} :\n    f =á¶ [l] g â†” f â‰¤á¶ [l] g âˆ§ g â‰¤á¶ [l] f := by\n  simp only [EventuallyEq, EventuallyLE, le_antisymm_iff, eventually_and]\n\n"}
{"name":"Filter.EventuallyLE.le_iff_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : PartialOrder Î²\nl : Filter Î±\nf g : Î± â†’ Î²\nh : l.EventuallyLE f g\nâŠ¢ Iff (l.EventuallyLE g f) (l.EventuallyEq g f)","decl":"theorem EventuallyLE.le_iff_eq [PartialOrder Î²] {l : Filter Î±} {f g : Î± â†’ Î²} (h : f â‰¤á¶ [l] g) :\n    g â‰¤á¶ [l] f â†” g =á¶ [l] f :=\n  âŸ¨fun h' => h'.antisymm h, EventuallyEq.leâŸ©\n\n"}
{"name":"Filter.Eventually.ne_of_lt","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : Preorder Î²\nl : Filter Î±\nf g : Î± â†’ Î²\nh : Filter.Eventually (fun x => LT.lt (f x) (g x)) l\nâŠ¢ Filter.Eventually (fun x => Ne (f x) (g x)) l","decl":"theorem Eventually.ne_of_lt [Preorder Î²] {l : Filter Î±} {f g : Î± â†’ Î²} (h : âˆ€á¶  x in l, f x < g x) :\n    âˆ€á¶  x in l, f x â‰  g x :=\n  h.mono fun _ hx => hx.ne\n\n"}
{"name":"Filter.Eventually.ne_top_of_lt","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PartialOrder Î²\ninstâœ : OrderTop Î²\nl : Filter Î±\nf g : Î± â†’ Î²\nh : Filter.Eventually (fun x => LT.lt (f x) (g x)) l\nâŠ¢ Filter.Eventually (fun x => Ne (f x) Top.top) l","decl":"theorem Eventually.ne_top_of_lt [PartialOrder Î²] [OrderTop Î²] {l : Filter Î±} {f g : Î± â†’ Î²}\n    (h : âˆ€á¶  x in l, f x < g x) : âˆ€á¶  x in l, f x â‰  âŠ¤ :=\n  h.mono fun _ hx => hx.ne_top\n\n"}
{"name":"Filter.Eventually.lt_top_of_ne","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PartialOrder Î²\ninstâœ : OrderTop Î²\nl : Filter Î±\nf : Î± â†’ Î²\nh : Filter.Eventually (fun x => Ne (f x) Top.top) l\nâŠ¢ Filter.Eventually (fun x => LT.lt (f x) Top.top) l","decl":"theorem Eventually.lt_top_of_ne [PartialOrder Î²] [OrderTop Î²] {l : Filter Î±} {f : Î± â†’ Î²}\n    (h : âˆ€á¶  x in l, f x â‰  âŠ¤) : âˆ€á¶  x in l, f x < âŠ¤ :=\n  h.mono fun _ hx => hx.lt_top\n\n"}
{"name":"Filter.Eventually.lt_top_iff_ne_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PartialOrder Î²\ninstâœ : OrderTop Î²\nl : Filter Î±\nf : Î± â†’ Î²\nâŠ¢ Iff (Filter.Eventually (fun x => LT.lt (f x) Top.top) l) (Filter.Eventually (fun x => Ne (f x) Top.top) l)","decl":"theorem Eventually.lt_top_iff_ne_top [PartialOrder Î²] [OrderTop Î²] {l : Filter Î±} {f : Î± â†’ Î²} :\n    (âˆ€á¶  x in l, f x < âŠ¤) â†” âˆ€á¶  x in l, f x â‰  âŠ¤ :=\n  âŸ¨Eventually.ne_of_lt, Eventually.lt_top_of_neâŸ©\n\n"}
{"name":"Filter.EventuallyLE.inter","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t s' t' : Set Î±\nl : Filter Î±\nh : l.EventuallyLE s t\nh' : l.EventuallyLE s' t'\nâŠ¢ l.EventuallyLE (Inter.inter s s') (Inter.inter t t')","decl":"@[mono]\ntheorem EventuallyLE.inter {s t s' t' : Set Î±} {l : Filter Î±} (h : s â‰¤á¶ [l] t) (h' : s' â‰¤á¶ [l] t') :\n    (s âˆ© s' : Set Î±) â‰¤á¶ [l] (t âˆ© t' : Set Î±) :=\n  h'.mp <| h.mono fun _ => And.imp\n\n"}
{"name":"Filter.EventuallyLE.union","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t s' t' : Set Î±\nl : Filter Î±\nh : l.EventuallyLE s t\nh' : l.EventuallyLE s' t'\nâŠ¢ l.EventuallyLE (Union.union s s') (Union.union t t')","decl":"@[mono]\ntheorem EventuallyLE.union {s t s' t' : Set Î±} {l : Filter Î±} (h : s â‰¤á¶ [l] t) (h' : s' â‰¤á¶ [l] t') :\n    (s âˆª s' : Set Î±) â‰¤á¶ [l] (t âˆª t' : Set Î±) :=\n  h'.mp <| h.mono fun _ => Or.imp\n\n"}
{"name":"Filter.EventuallyLE.compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\nh : l.EventuallyLE s t\nâŠ¢ l.EventuallyLE (HasCompl.compl t) (HasCompl.compl s)","decl":"@[mono]\ntheorem EventuallyLE.compl {s t : Set Î±} {l : Filter Î±} (h : s â‰¤á¶ [l] t) :\n    (tá¶œ : Set Î±) â‰¤á¶ [l] (sá¶œ : Set Î±) :=\n  h.mono fun _ => mt\n\n"}
{"name":"Filter.EventuallyLE.diff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t s' t' : Set Î±\nl : Filter Î±\nh : l.EventuallyLE s t\nh' : l.EventuallyLE t' s'\nâŠ¢ l.EventuallyLE (SDiff.sdiff s s') (SDiff.sdiff t t')","decl":"@[mono]\ntheorem EventuallyLE.diff {s t s' t' : Set Î±} {l : Filter Î±} (h : s â‰¤á¶ [l] t) (h' : t' â‰¤á¶ [l] s') :\n    (s \\ s' : Set Î±) â‰¤á¶ [l] (t \\ t' : Set Î±) :=\n  h.inter h'.compl\n\n"}
{"name":"Filter.set_eventuallyLE_iff_mem_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyLE s t) (Membership.mem (Min.min l (Filter.principal s)) t)","decl":"theorem set_eventuallyLE_iff_mem_inf_principal {s t : Set Î±} {l : Filter Î±} :\n    s â‰¤á¶ [l] t â†” t âˆˆ l âŠ“ ğ“Ÿ s :=\n  eventually_inf_principal.symm\n\n"}
{"name":"Filter.set_eventuallyLE_iff_inf_principal_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyLE s t) (LE.le (Min.min l (Filter.principal s)) (Min.min l (Filter.principal t)))","decl":"theorem set_eventuallyLE_iff_inf_principal_le {s t : Set Î±} {l : Filter Î±} :\n    s â‰¤á¶ [l] t â†” l âŠ“ ğ“Ÿ s â‰¤ l âŠ“ ğ“Ÿ t :=\n  set_eventuallyLE_iff_mem_inf_principal.trans <| by\n    simp only [le_inf_iff, inf_le_left, true_and, le_principal_iff]\n\n"}
{"name":"Filter.set_eventuallyEq_iff_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns t : Set Î±\nl : Filter Î±\nâŠ¢ Iff (l.EventuallyEq s t) (Eq (Min.min l (Filter.principal s)) (Min.min l (Filter.principal t)))","decl":"theorem set_eventuallyEq_iff_inf_principal {s t : Set Î±} {l : Filter Î±} :\n    s =á¶ [l] t â†” l âŠ“ ğ“Ÿ s = l âŠ“ ğ“Ÿ t := by\n  simp only [eventuallyLE_antisymm_iff, le_antisymm_iff, set_eventuallyLE_iff_inf_principal_le]\n\n"}
{"name":"Filter.EventuallyLE.sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : SemilatticeSup Î²\nl : Filter Î±\nfâ‚ fâ‚‚ gâ‚ gâ‚‚ : Î± â†’ Î²\nhf : l.EventuallyLE fâ‚ fâ‚‚\nhg : l.EventuallyLE gâ‚ gâ‚‚\nâŠ¢ l.EventuallyLE (Max.max fâ‚ gâ‚) (Max.max fâ‚‚ gâ‚‚)","decl":"theorem EventuallyLE.sup [SemilatticeSup Î²] {l : Filter Î±} {fâ‚ fâ‚‚ gâ‚ gâ‚‚ : Î± â†’ Î²} (hf : fâ‚ â‰¤á¶ [l] fâ‚‚)\n    (hg : gâ‚ â‰¤á¶ [l] gâ‚‚) : fâ‚ âŠ” gâ‚ â‰¤á¶ [l] fâ‚‚ âŠ” gâ‚‚ := by\n  filter_upwards [hf, hg] with x hfx hgx using sup_le_sup hfx hgx\n\n"}
{"name":"Filter.EventuallyLE.sup_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : SemilatticeSup Î²\nl : Filter Î±\nf g h : Î± â†’ Î²\nhf : l.EventuallyLE f h\nhg : l.EventuallyLE g h\nâŠ¢ l.EventuallyLE (Max.max f g) h","decl":"theorem EventuallyLE.sup_le [SemilatticeSup Î²] {l : Filter Î±} {f g h : Î± â†’ Î²} (hf : f â‰¤á¶ [l] h)\n    (hg : g â‰¤á¶ [l] h) : f âŠ” g â‰¤á¶ [l] h := by\n  filter_upwards [hf, hg] with x hfx hgx using _root_.sup_le hfx hgx\n\n"}
{"name":"Filter.EventuallyLE.le_sup_of_le_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : SemilatticeSup Î²\nl : Filter Î±\nf g h : Î± â†’ Î²\nhf : l.EventuallyLE h f\nâŠ¢ l.EventuallyLE h (Max.max f g)","decl":"theorem EventuallyLE.le_sup_of_le_left [SemilatticeSup Î²] {l : Filter Î±} {f g h : Î± â†’ Î²}\n    (hf : h â‰¤á¶ [l] f) : h â‰¤á¶ [l] f âŠ” g :=\n  hf.mono fun _ => _root_.le_sup_of_le_left\n\n"}
{"name":"Filter.EventuallyLE.le_sup_of_le_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : SemilatticeSup Î²\nl : Filter Î±\nf g h : Î± â†’ Î²\nhg : l.EventuallyLE h g\nâŠ¢ l.EventuallyLE h (Max.max f g)","decl":"theorem EventuallyLE.le_sup_of_le_right [SemilatticeSup Î²] {l : Filter Î±} {f g h : Î± â†’ Î²}\n    (hg : h â‰¤á¶ [l] g) : h â‰¤á¶ [l] f âŠ” g :=\n  hg.mono fun _ => _root_.le_sup_of_le_right\n\n"}
{"name":"Filter.join_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter (Filter Î±)\nl : Filter Î±\nh : Filter.Eventually (fun m => LE.le m l) f\nâŠ¢ LE.le f.join l","decl":"theorem join_le {f : Filter (Filter Î±)} {l : Filter Î±} (h : âˆ€á¶  m in f, m â‰¤ l) : join f â‰¤ l :=\n  fun _ hs => h.mono fun _ hm => hm hs\n\n"}
{"name":"Filter.map_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ns : Set Î±\nf : Î± â†’ Î²\nâŠ¢ Eq (Filter.map f (Filter.principal s)) (Filter.principal (Set.image f s))","decl":"@[simp]\ntheorem map_principal {s : Set Î±} {f : Î± â†’ Î²} : map f (ğ“Ÿ s) = ğ“Ÿ (Set.image f s) :=\n  Filter.ext fun _ => image_subset_iff.symm\n\n"}
{"name":"Filter.eventually_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nP : Î² â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun b => P b) (Filter.map m f)) (Filter.Eventually (fun a => P (m a)) f)","decl":"@[simp]\ntheorem eventually_map {P : Î² â†’ Prop} : (âˆ€á¶  b in map m f, P b) â†” âˆ€á¶  a in f, P (m a) :=\n  Iff.rfl\n\n"}
{"name":"Filter.frequently_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nP : Î² â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun b => P b) (Filter.map m f)) (Filter.Frequently (fun a => P (m a)) f)","decl":"@[simp]\ntheorem frequently_map {P : Î² â†’ Prop} : (âˆƒá¶  b in map m f, P b) â†” âˆƒá¶  a in f, P (m a) :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nt : Set Î²\nâŠ¢ Iff (Membership.mem (Filter.map m f) t) (Membership.mem f (Set.preimage m t))","decl":"@[simp]\ntheorem mem_map : t âˆˆ map m f â†” m â»Â¹' t âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_map'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nt : Set Î²\nâŠ¢ Iff (Membership.mem (Filter.map m f) t) (Membership.mem f (setOf fun x => Membership.mem t (m x)))","decl":"theorem mem_map' : t âˆˆ map m f â†” { x | m x âˆˆ t } âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.image_mem_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\ns : Set Î±\nhs : Membership.mem f s\nâŠ¢ Membership.mem (Filter.map m f) (Set.image m s)","decl":"theorem image_mem_map (hs : s âˆˆ f) : m '' s âˆˆ map m f :=\n  f.sets_of_superset hs <| subset_preimage_image m s\n\n-- The simpNF linter says that the LHS can be simplified via `Filter.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"Filter.image_mem_map_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\ns : Set Î±\nhf : Function.Injective m\nâŠ¢ Iff (Membership.mem (Filter.map m f) (Set.image m s)) (Membership.mem f s)","decl":"@[simp 1100, nolint simpNF]\ntheorem image_mem_map_iff (hf : Injective m) : m '' s âˆˆ map m f â†” s âˆˆ f :=\n  âŸ¨fun h => by rwa [â† preimage_image_eq s hf], image_mem_mapâŸ©\n\n"}
{"name":"Filter.range_mem_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nâŠ¢ Membership.mem (Filter.map m f) (Set.range m)","decl":"theorem range_mem_map : range m âˆˆ map m f := by\n  rw [â† image_univ]\n  exact image_mem_map univ_mem\n\n"}
{"name":"Filter.mem_map_iff_exists_image","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nt : Set Î²\nâŠ¢ Iff (Membership.mem (Filter.map m f) t) (Exists fun s => And (Membership.mem f s) (HasSubset.Subset (Set.image m s) t))","decl":"theorem mem_map_iff_exists_image : t âˆˆ map m f â†” âˆƒ s âˆˆ f, m '' s âŠ† t :=\n  âŸ¨fun ht => âŸ¨m â»Â¹' t, ht, image_preimage_subset _ _âŸ©, fun âŸ¨_, hs, htâŸ© =>\n    mem_of_superset (image_mem_map hs) htâŸ©\n\n"}
{"name":"Filter.map_id","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Eq (Filter.map id f) f","decl":"@[simp]\ntheorem map_id : Filter.map id f = f :=\n  filter_eq <| rfl\n\n"}
{"name":"Filter.map_id'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Eq (Filter.map (fun x => x) f) f","decl":"@[simp]\ntheorem map_id' : Filter.map (fun x => x) f = f :=\n  map_id\n\n"}
{"name":"Filter.map_compose","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nm : Î± â†’ Î²\nm' : Î² â†’ Î³\nâŠ¢ Eq (Function.comp (Filter.map m') (Filter.map m)) (Filter.map (Function.comp m' m))","decl":"@[simp]\ntheorem map_compose : Filter.map m' âˆ˜ Filter.map m = Filter.map (m' âˆ˜ m) :=\n  funext fun _ => filter_eq <| rfl\n\n"}
{"name":"Filter.map_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nf : Filter Î±\nm : Î± â†’ Î²\nm' : Î² â†’ Î³\nâŠ¢ Eq (Filter.map m' (Filter.map m f)) (Filter.map (Function.comp m' m) f)","decl":"@[simp]\ntheorem map_map : Filter.map m' (Filter.map m f) = Filter.map (m' âˆ˜ m) f :=\n  congr_fun Filter.map_compose f\n\n"}
{"name":"Filter.map_congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nmâ‚ mâ‚‚ : Î± â†’ Î²\nf : Filter Î±\nh : f.EventuallyEq mâ‚ mâ‚‚\nâŠ¢ Eq (Filter.map mâ‚ f) (Filter.map mâ‚‚ f)","decl":"/-- If functions `mâ‚` and `mâ‚‚` are eventually equal at a filter `f`, then\nthey map this filter to the same filter. -/\ntheorem map_congr {mâ‚ mâ‚‚ : Î± â†’ Î²} {f : Filter Î±} (h : mâ‚ =á¶ [f] mâ‚‚) : map mâ‚ f = map mâ‚‚ f :=\n  Filter.ext' fun _ => eventually_congr (h.mono fun _ hx => hx â–¸ Iff.rfl)\n\n"}
{"name":"Filter.mem_comap'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nl : Filter Î²\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.comap f l) s) (Membership.mem l (setOf fun y => âˆ€ â¦ƒx : Î±â¦„, Eq (f x) y â†’ Membership.mem s x))","decl":"theorem mem_comap' : s âˆˆ comap f l â†” { y | âˆ€ â¦ƒxâ¦„, f x = y â†’ x âˆˆ s } âˆˆ l :=\n  âŸ¨fun âŸ¨t, ht, htsâŸ© => mem_of_superset ht fun y hy x hx => hts <| mem_preimage.2 <| by rwa [hx],\n    fun h => âŸ¨_, h, fun _ hx => hx rflâŸ©âŸ©\n\n-- TODO: it would be nice to use `kernImage` much more to take advantage of common name and API,\n-- and then this would become `mem_comap'`\n"}
{"name":"Filter.mem_comap''","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nl : Filter Î²\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.comap f l) s) (Membership.mem l (Set.kernImage f s))","decl":"theorem mem_comap'' : s âˆˆ comap f l â†” kernImage f s âˆˆ l :=\n  mem_comap'\n\n"}
{"name":"Filter.mem_comap_prod_mk","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nx : Î±\ns : Set Î²\nF : Filter (Prod Î± Î²)\nâŠ¢ Iff (Membership.mem (Filter.comap (Prod.mk x) F) s) (Membership.mem F (setOf fun p => Eq p.1 x â†’ Membership.mem s p.2))","decl":"/-- RHS form is used, e.g., in the definition of `UniformSpace`. -/\nlemma mem_comap_prod_mk {x : Î±} {s : Set Î²} {F : Filter (Î± Ã— Î²)} :\n    s âˆˆ comap (Prod.mk x) F â†” {p : Î± Ã— Î² | p.fst = x â†’ p.snd âˆˆ s} âˆˆ F := by\n  simp_rw [mem_comap', Prod.ext_iff, and_imp, @forall_swap Î² (_ = _), forall_eq, eq_comm]\n\n"}
{"name":"Filter.eventually_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nl : Filter Î²\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun a => p a) (Filter.comap f l)) (Filter.Eventually (fun b => âˆ€ (a : Î±), Eq (f a) b â†’ p a) l)","decl":"@[simp]\ntheorem eventually_comap : (âˆ€á¶  a in comap f l, p a) â†” âˆ€á¶  b in l, âˆ€ a, f a = b â†’ p a :=\n  mem_comap'\n\n"}
{"name":"Filter.frequently_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nl : Filter Î²\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun a => p a) (Filter.comap f l)) (Filter.Frequently (fun b => Exists fun a => And (Eq (f a) b) (p a)) l)","decl":"@[simp]\ntheorem frequently_comap : (âˆƒá¶  a in comap f l, p a) â†” âˆƒá¶  b in l, âˆƒ a, f a = b âˆ§ p a := by\n  simp only [Filter.Frequently, eventually_comap, not_exists, _root_.not_and]\n\n"}
{"name":"Filter.mem_comap_iff_compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nl : Filter Î²\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.comap f l) s) (Membership.mem l (HasCompl.compl (Set.image f (HasCompl.compl s))))","decl":"theorem mem_comap_iff_compl : s âˆˆ comap f l â†” (f '' sá¶œ)á¶œ âˆˆ l := by\n  simp only [mem_comap'', kernImage_eq_compl]\n\n"}
{"name":"Filter.compl_mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nl : Filter Î²\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.comap f l) (HasCompl.compl s)) (Membership.mem l (HasCompl.compl (Set.image f s)))","decl":"theorem compl_mem_comap : sá¶œ âˆˆ comap f l â†” (f '' s)á¶œ âˆˆ l := by rw [mem_comap_iff_compl, compl_compl]\n\n"}
{"name":"Filter.mem_kernMap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nf : Filter Î±\ns : Set Î²\nâŠ¢ Iff (Membership.mem (Filter.kernMap m f) s) (Exists fun t => And (Membership.mem f t) (Eq (Set.kernImage m t) s))","decl":"theorem mem_kernMap {s : Set Î²} : s âˆˆ kernMap m f â†” âˆƒ t âˆˆ f, kernImage m t = s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_kernMap_iff_compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nf : Filter Î±\ns : Set Î²\nâŠ¢ Iff (Membership.mem (Filter.kernMap m f) s) (Exists fun t => And (Membership.mem f (HasCompl.compl t)) (Eq (Set.image m t) (HasCompl.compl s)))","decl":"theorem mem_kernMap_iff_compl {s : Set Î²} : s âˆˆ kernMap m f â†” âˆƒ t, tá¶œ âˆˆ f âˆ§ m '' t = sá¶œ := by\n  rw [mem_kernMap, compl_surjective.exists]\n  refine exists_congr (fun x â†¦ and_congr_right fun _ â†¦ ?_)\n  rw [kernImage_compl, compl_eq_comm, eq_comm]\n\n"}
{"name":"Filter.compl_mem_kernMap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nf : Filter Î±\ns : Set Î²\nâŠ¢ Iff (Membership.mem (Filter.kernMap m f) (HasCompl.compl s)) (Exists fun t => And (Membership.mem f (HasCompl.compl t)) (Eq (Set.image m t) s))","decl":"theorem compl_mem_kernMap {s : Set Î²} : sá¶œ âˆˆ kernMap m f â†” âˆƒ t, tá¶œ âˆˆ f âˆ§ m '' t = s := by\n  simp_rw [mem_kernMap_iff_compl, compl_compl]\n\n"}
{"name":"Filter.instLawfulFunctor","module":"Mathlib.Order.Filter.Basic","initialProofState":"âŠ¢ LawfulFunctor Filter","decl":"instance : LawfulFunctor (Filter : Type u â†’ Type u) where\n  id_map _ := map_id\n  comp_map _ _ _ := map_map.symm\n  map_const := rfl\n\n"}
{"name":"Filter.pure_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\na : Î±\nâŠ¢ Eq (Pure.pure a).sets (setOf fun s => Membership.mem s a)","decl":"theorem pure_sets (a : Î±) : (pure a : Filter Î±).sets = { s | a âˆˆ s } :=\n  rfl\n\n"}
{"name":"Filter.eventually_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\na : Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => p x) (Pure.pure a)) (p a)","decl":"@[simp]\ntheorem eventually_pure {a : Î±} {p : Î± â†’ Prop} : (âˆ€á¶  x in pure a, p x) â†” p a :=\n  Iff.rfl\n\n"}
{"name":"Filter.principal_singleton","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\na : Î±\nâŠ¢ Eq (Filter.principal (Singleton.singleton a)) (Pure.pure a)","decl":"@[simp]\ntheorem principal_singleton (a : Î±) : ğ“Ÿ {a} = pure a :=\n  Filter.ext fun s => by simp only [mem_pure, mem_principal, singleton_subset_iff]\n\n"}
{"name":"Filter.map_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\na : Î±\nâŠ¢ Eq (Filter.map f (Pure.pure a)) (Pure.pure (f a))","decl":"@[simp]\ntheorem map_pure (f : Î± â†’ Î²) (a : Î±) : map f (pure a) = pure (f a) :=\n  rfl\n\n"}
{"name":"Filter.pure_le_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\na : Î±\nâŠ¢ Iff (LE.le (Pure.pure a) (Filter.principal s)) (Membership.mem s a)","decl":"theorem pure_le_principal {s : Set Î±} (a : Î±) : pure a â‰¤ ğ“Ÿ s â†” a âˆˆ s := by\n  simp\n\n"}
{"name":"Filter.join_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Eq (Pure.pure f).join f","decl":"@[simp] theorem join_pure (f : Filter Î±) : join (pure f) = f := rfl\n\n"}
{"name":"Filter.pure_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\na : Î±\nm : Î± â†’ Filter Î²\nâŠ¢ Eq ((Pure.pure a).bind m) (m a)","decl":"@[simp]\ntheorem pure_bind (a : Î±) (m : Î± â†’ Filter Î²) : bind (pure a) m = m a := by\n  simp only [Bind.bind, bind, map_pure, join_pure]\n\n"}
{"name":"Filter.map_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î³ : Type w\nÎ± : Type u_2\nÎ² : Type u_3\nm : Î² â†’ Î³\nf : Filter Î±\ng : Î± â†’ Filter Î²\nâŠ¢ Eq (Filter.map m (f.bind g)) (f.bind (Function.comp (Filter.map m) g))","decl":"theorem map_bind {Î± Î²} (m : Î² â†’ Î³) (f : Filter Î±) (g : Î± â†’ Filter Î²) :\n    map m (bind f g) = bind f (map m âˆ˜ g) :=\n  rfl\n\n"}
{"name":"Filter.bind_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î³ : Type w\nÎ± : Type u_2\nÎ² : Type u_3\nm : Î± â†’ Î²\nf : Filter Î±\ng : Î² â†’ Filter Î³\nâŠ¢ Eq ((Filter.map m f).bind g) (f.bind (Function.comp g m))","decl":"theorem bind_map {Î± Î²} (m : Î± â†’ Î²) (f : Filter Î±) (g : Î² â†’ Filter Î³) :\n    (bind (map m f) g) = bind f (g âˆ˜ m) :=\n  rfl\n\n"}
{"name":"Filter.lawfulMonad","module":"Mathlib.Order.Filter.Basic","initialProofState":"âŠ¢ LawfulMonad Filter","decl":"protected theorem lawfulMonad : LawfulMonad Filter where\n  map_const := rfl\n  id_map _ := rfl\n  seqLeft_eq _ _ := rfl\n  seqRight_eq _ _ := rfl\n  pure_seq _ _ := rfl\n  bind_pure_comp _ _ := rfl\n  bind_map _ _ := rfl\n  pure_bind _ _ := rfl\n  bind_assoc _ _ _ := rfl\n\n"}
{"name":"Filter.map_def","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± Î² : Type u_2\nm : Î± â†’ Î²\nf : Filter Î±\nâŠ¢ Eq (Functor.map m f) (Filter.map m f)","decl":"@[simp]\ntheorem map_def {Î± Î²} (m : Î± â†’ Î²) (f : Filter Î±) : m <$> f = map m f :=\n  rfl\n\n"}
{"name":"Filter.bind_def","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± Î² : Type u_2\nf : Filter Î±\nm : Î± â†’ Filter Î²\nâŠ¢ Eq (Bind.bind f m) (f.bind m)","decl":"@[simp]\ntheorem bind_def {Î± Î²} (f : Filter Î±) (m : Î± â†’ Filter Î²) : f >>= m = bind f m :=\n  rfl\n\n"}
{"name":"Filter.mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ng : Filter Î²\nm : Î± â†’ Î²\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.comap m g) s) (Exists fun t => And (Membership.mem g t) (HasSubset.Subset (Set.preimage m t) s))","decl":"@[simp] theorem mem_comap : s âˆˆ comap m g â†” âˆƒ t âˆˆ g, m â»Â¹' t âŠ† s := Iff.rfl\n\n"}
{"name":"Filter.preimage_mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ng : Filter Î²\nm : Î± â†’ Î²\nt : Set Î²\nht : Membership.mem g t\nâŠ¢ Membership.mem (Filter.comap m g) (Set.preimage m t)","decl":"theorem preimage_mem_comap (ht : t âˆˆ g) : m â»Â¹' t âˆˆ comap m g :=\n  âŸ¨t, ht, Subset.rflâŸ©\n\n"}
{"name":"Filter.Eventually.comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ng : Filter Î²\np : Î² â†’ Prop\nhf : Filter.Eventually (fun b => p b) g\nf : Î± â†’ Î²\nâŠ¢ Filter.Eventually (fun a => p (f a)) (Filter.comap f g)","decl":"theorem Eventually.comap {p : Î² â†’ Prop} (hf : âˆ€á¶  b in g, p b) (f : Î± â†’ Î²) :\n    âˆ€á¶  a in comap f g, p (f a) :=\n  preimage_mem_comap hf\n\n"}
{"name":"Filter.comap_id","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Eq (Filter.comap id f) f","decl":"theorem comap_id : comap id f = f :=\n  le_antisymm (fun _ => preimage_mem_comap) fun _ âŸ¨_, ht, hstâŸ© => mem_of_superset ht hst\n\n"}
{"name":"Filter.comap_id'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nâŠ¢ Eq (Filter.comap (fun x => x) f) f","decl":"theorem comap_id' : comap (fun x => x) f = f := comap_id\n\n"}
{"name":"Filter.comap_const_of_not_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ng : Filter Î²\nt : Set Î²\nx : Î²\nht : Membership.mem g t\nhx : Not (Membership.mem t x)\nâŠ¢ Eq (Filter.comap (fun x_1 => x) g) Bot.bot","decl":"theorem comap_const_of_not_mem {x : Î²} (ht : t âˆˆ g) (hx : x âˆ‰ t) : comap (fun _ : Î± => x) g = âŠ¥ :=\n  empty_mem_iff_bot.1 <| mem_comap'.2 <| mem_of_superset ht fun _ hx' _ h => hx <| h.symm â–¸ hx'\n\n"}
{"name":"Filter.comap_const_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ng : Filter Î²\nx : Î²\nh : âˆ€ (t : Set Î²), Membership.mem g t â†’ Membership.mem t x\nâŠ¢ Eq (Filter.comap (fun x_1 => x) g) Top.top","decl":"theorem comap_const_of_mem {x : Î²} (h : âˆ€ t âˆˆ g, x âˆˆ t) : comap (fun _ : Î± => x) g = âŠ¤ :=\n  top_unique fun _ hs => univ_mem' fun _ => h _ (mem_comap'.1 hs) rfl\n\n"}
{"name":"Filter.map_const","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\ninstâœ : f.NeBot\nc : Î²\nâŠ¢ Eq (Filter.map (fun x => c) f) (Pure.pure c)","decl":"theorem map_const [NeBot f] {c : Î²} : (f.map fun _ => c) = pure c := by\n  ext s\n  by_cases h : c âˆˆ s <;> simp [h]\n\n"}
{"name":"Filter.comap_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nf : Filter Î±\nm : Î³ â†’ Î²\nn : Î² â†’ Î±\nâŠ¢ Eq (Filter.comap m (Filter.comap n f)) (Filter.comap (Function.comp n m) f)","decl":"theorem comap_comap {m : Î³ â†’ Î²} {n : Î² â†’ Î±} : comap m (comap n f) = comap (n âˆ˜ m) f :=\n  Filter.coext fun s => by simp only [compl_mem_comap, image_image, (Â· âˆ˜ Â·)]\n\n"}
{"name":"Filter.map_comm","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÏ† : Î± â†’ Î²\nÎ¸ : Î± â†’ Î³\nÏˆ : Î² â†’ Î´\nÏ : Î³ â†’ Î´\nH : Eq (Function.comp Ïˆ Ï†) (Function.comp Ï Î¸)\nF : Filter Î±\nâŠ¢ Eq (Filter.map Ïˆ (Filter.map Ï† F)) (Filter.map Ï (Filter.map Î¸ F))","decl":"theorem map_comm (H : Ïˆ âˆ˜ Ï† = Ï âˆ˜ Î¸) (F : Filter Î±) :\n    map Ïˆ (map Ï† F) = map Ï (map Î¸ F) := by\n  rw [Filter.map_map, H, â† Filter.map_map]\n\n"}
{"name":"Filter.comap_comm","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nÏ† : Î± â†’ Î²\nÎ¸ : Î± â†’ Î³\nÏˆ : Î² â†’ Î´\nÏ : Î³ â†’ Î´\nH : Eq (Function.comp Ïˆ Ï†) (Function.comp Ï Î¸)\nG : Filter Î´\nâŠ¢ Eq (Filter.comap Ï† (Filter.comap Ïˆ G)) (Filter.comap Î¸ (Filter.comap Ï G))","decl":"theorem comap_comm (H : Ïˆ âˆ˜ Ï† = Ï âˆ˜ Î¸) (G : Filter Î´) :\n    comap Ï† (comap Ïˆ G) = comap Î¸ (comap Ï G) := by\n  rw [Filter.comap_comap, H, â† Filter.comap_comap]\n\n"}
{"name":"Function.Semiconj.filter_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nga : Î± â†’ Î±\ngb : Î² â†’ Î²\nh : Function.Semiconj f ga gb\nâŠ¢ Function.Semiconj (Filter.map f) (Filter.map ga) (Filter.map gb)","decl":"theorem _root_.Function.Semiconj.filter_map {f : Î± â†’ Î²} {ga : Î± â†’ Î±} {gb : Î² â†’ Î²}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (map f) (map ga) (map gb) :=\n  map_comm h.comp_eq\n\n"}
{"name":"Function.Commute.filter_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Î± â†’ Î±\nh : Function.Commute f g\nâŠ¢ Function.Commute (Filter.map f) (Filter.map g)","decl":"theorem _root_.Function.Commute.filter_map {f g : Î± â†’ Î±} (h : Function.Commute f g) :\n    Function.Commute (map f) (map g) :=\n  h.semiconj.filter_map\n\n"}
{"name":"Function.Semiconj.filter_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nga : Î± â†’ Î±\ngb : Î² â†’ Î²\nh : Function.Semiconj f ga gb\nâŠ¢ Function.Semiconj (Filter.comap f) (Filter.comap gb) (Filter.comap ga)","decl":"theorem _root_.Function.Semiconj.filter_comap {f : Î± â†’ Î²} {ga : Î± â†’ Î±} {gb : Î² â†’ Î²}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (comap f) (comap gb) (comap ga) :=\n  comap_comm h.comp_eq.symm\n\n"}
{"name":"Function.Commute.filter_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf g : Î± â†’ Î±\nh : Function.Commute f g\nâŠ¢ Function.Commute (Filter.comap f) (Filter.comap g)","decl":"theorem _root_.Function.Commute.filter_comap {f g : Î± â†’ Î±} (h : Function.Commute f g) :\n    Function.Commute (comap f) (comap g) :=\n  h.semiconj.filter_comap\n\n"}
{"name":"Function.LeftInverse.filter_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nhfg : Function.LeftInverse g f\nâŠ¢ Function.LeftInverse (Filter.map g) (Filter.map f)","decl":"theorem _root_.Function.LeftInverse.filter_map {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hfg : LeftInverse g f) :\n    LeftInverse (map g) (map f) := fun F â†¦ by\n  rw [map_map, hfg.comp_eq_id, map_id]\n\n"}
{"name":"Function.LeftInverse.filter_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nhfg : Function.LeftInverse g f\nâŠ¢ Function.RightInverse (Filter.comap g) (Filter.comap f)","decl":"theorem _root_.Function.LeftInverse.filter_comap {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hfg : LeftInverse g f) :\n    RightInverse (comap g) (comap f) := fun F â†¦ by\n  rw [comap_comap, hfg.comp_eq_id, comap_id]\n\n"}
{"name":"Function.RightInverse.filter_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nhfg : Function.RightInverse g f\nâŠ¢ Function.RightInverse (Filter.map g) (Filter.map f)","decl":"nonrec theorem _root_.Function.RightInverse.filter_map {f : Î± â†’ Î²} {g : Î² â†’ Î±}\n    (hfg : RightInverse g f) : RightInverse (map g) (map f) :=\n  hfg.filter_map\n\n"}
{"name":"Function.RightInverse.filter_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nhfg : Function.RightInverse g f\nâŠ¢ Function.LeftInverse (Filter.comap g) (Filter.comap f)","decl":"nonrec theorem _root_.Function.RightInverse.filter_comap {f : Î± â†’ Î²} {g : Î² â†’ Î±}\n    (hfg : RightInverse g f) : LeftInverse (comap g) (comap f) :=\n  hfg.filter_comap\n\n"}
{"name":"Set.LeftInvOn.filter_map_Iic","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ns : Set Î±\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nhfg : Set.LeftInvOn g f s\nâŠ¢ Set.LeftInvOn (Filter.map g) (Filter.map f) (Set.Iic (Filter.principal s))","decl":"theorem _root_.Set.LeftInvOn.filter_map_Iic {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hfg : LeftInvOn g f s) :\n    LeftInvOn (map g) (map f) (Iic <| ğ“Ÿ s) := fun F (hF : F â‰¤ ğ“Ÿ s) â†¦ by\n  have : (g âˆ˜ f) =á¶ [ğ“Ÿ s] id := by simpa only [eventuallyEq_principal] using hfg\n  rw [map_map, map_congr (this.filter_mono hF), map_id]\n\n"}
{"name":"Set.RightInvOn.filter_map_Iic","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nt : Set Î²\nf : Î± â†’ Î²\ng : Î² â†’ Î±\nhfg : Set.RightInvOn g f t\nâŠ¢ Set.RightInvOn (Filter.map g) (Filter.map f) (Set.Iic (Filter.principal t))","decl":"nonrec theorem _root_.Set.RightInvOn.filter_map_Iic {f : Î± â†’ Î²} {g : Î² â†’ Î±}\n    (hfg : RightInvOn g f t) : RightInvOn (map g) (map f) (Iic <| ğ“Ÿ t) :=\n  hfg.filter_map_Iic\n\n"}
{"name":"Filter.comap_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nt : Set Î²\nâŠ¢ Eq (Filter.comap m (Filter.principal t)) (Filter.principal (Set.preimage m t))","decl":"@[simp]\ntheorem comap_principal {t : Set Î²} : comap m (ğ“Ÿ t) = ğ“Ÿ (m â»Â¹' t) :=\n  Filter.ext fun _ => âŸ¨fun âŸ¨_u, hu, bâŸ© => (preimage_mono hu).trans b,\n    fun h => âŸ¨t, Subset.rfl, hâŸ©âŸ©\n\n"}
{"name":"Filter.principal_subtype","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_2\ns : Set Î±\nt : Set â†‘s\nâŠ¢ Eq (Filter.principal t) (Filter.comap Subtype.val (Filter.principal (Set.image Subtype.val t)))","decl":"theorem principal_subtype {Î± : Type*} (s : Set Î±) (t : Set s) :\n    ğ“Ÿ t = comap (â†‘) (ğ“Ÿ (((â†‘) : s â†’ Î±) '' t)) := by\n  rw [comap_principal, preimage_image_eq _ Subtype.coe_injective]\n\n"}
{"name":"Filter.comap_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nb : Î²\nâŠ¢ Eq (Filter.comap m (Pure.pure b)) (Filter.principal (Set.preimage m (Singleton.singleton b)))","decl":"@[simp]\ntheorem comap_pure {b : Î²} : comap m (pure b) = ğ“Ÿ (m â»Â¹' {b}) := by\n  rw [â† principal_singleton, comap_principal]\n\n"}
{"name":"Filter.map_le_iff_le_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\ng : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (LE.le (Filter.map m f) g) (LE.le f (Filter.comap m g))","decl":"theorem map_le_iff_le_comap : map m f â‰¤ g â†” f â‰¤ comap m g :=\n  âŸ¨fun h _ âŸ¨_, ht, htsâŸ© => mem_of_superset (h ht) hts, fun h _ ht => h âŸ¨_, ht, Subset.rflâŸ©âŸ©\n\n"}
{"name":"Filter.gc_map_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nâŠ¢ GaloisConnection (Filter.map m) (Filter.comap m)","decl":"theorem gc_map_comap (m : Î± â†’ Î²) : GaloisConnection (map m) (comap m) :=\n  fun _ _ => map_le_iff_le_comap\n\n"}
{"name":"Filter.comap_le_iff_le_kernMap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\ng : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (LE.le (Filter.comap m g) f) (LE.le g (Filter.kernMap m f))","decl":"theorem comap_le_iff_le_kernMap : comap m g â‰¤ f â†” g â‰¤ kernMap m f := by\n  simp [Filter.le_def, mem_comap'', mem_kernMap, -mem_comap]\n\n"}
{"name":"Filter.gc_comap_kernMap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nâŠ¢ GaloisConnection (Filter.comap m) (Filter.kernMap m)","decl":"theorem gc_comap_kernMap (m : Î± â†’ Î²) : GaloisConnection (comap m) (kernMap m) :=\n  fun _ _ â†¦ comap_le_iff_le_kernMap\n\n"}
{"name":"Filter.kernMap_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\ns : Set Î±\nâŠ¢ Eq (Filter.kernMap m (Filter.principal s)) (Filter.principal (Set.kernImage m s))","decl":"theorem kernMap_principal {s : Set Î±} : kernMap m (ğ“Ÿ s) = ğ“Ÿ (kernImage m s) := by\n  refine eq_of_forall_le_iff (fun g â†¦ ?_)\n  rw [â† comap_le_iff_le_kernMap, le_principal_iff, le_principal_iff, mem_comap'']\n\n"}
{"name":"Filter.map_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nâŠ¢ Monotone (Filter.map m)","decl":"@[mono]\ntheorem map_mono : Monotone (map m) :=\n  (gc_map_comap m).monotone_l\n\n"}
{"name":"Filter.comap_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nâŠ¢ Monotone (Filter.comap m)","decl":"@[mono]\ntheorem comap_mono : Monotone (comap m) :=\n  (gc_map_comap m).monotone_u\n\n"}
{"name":"GCongr.Filter.map_le_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nF G : Filter Î±\nh : LE.le F G\nâŠ¢ LE.le (Filter.map m F) (Filter.map m G)","decl":"/-- Temporary lemma that we can tag with `gcongr` -/\n@[gcongr] theorem _root_.GCongr.Filter.map_le_map {F G : Filter Î±} (h : F â‰¤ G) :\n    map m F â‰¤ map m G := map_mono h\n\n"}
{"name":"GCongr.Filter.comap_le_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nF G : Filter Î²\nh : LE.le F G\nâŠ¢ LE.le (Filter.comap m F) (Filter.comap m G)","decl":"/-- Temporary lemma that we can tag with `gcongr` -/\n@[gcongr]\ntheorem _root_.GCongr.Filter.comap_le_comap {F G : Filter Î²} (h : F â‰¤ G) :\n    comap m F â‰¤ comap m G := comap_mono h\n\n"}
{"name":"Filter.map_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.map m Bot.bot) Bot.bot","decl":"@[simp] theorem map_bot : map m âŠ¥ = âŠ¥ := (gc_map_comap m).l_bot\n\n"}
{"name":"Filter.map_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nfâ‚ fâ‚‚ : Filter Î±\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.map m (Max.max fâ‚ fâ‚‚)) (Max.max (Filter.map m fâ‚) (Filter.map m fâ‚‚))","decl":"@[simp] theorem map_sup : map m (fâ‚ âŠ” fâ‚‚) = map m fâ‚ âŠ” map m fâ‚‚ := (gc_map_comap m).l_sup\n\n"}
{"name":"Filter.map_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Sort x\nm : Î± â†’ Î²\nf : Î¹ â†’ Filter Î±\nâŠ¢ Eq (Filter.map m (iSup fun i => f i)) (iSup fun i => Filter.map m (f i))","decl":"@[simp]\ntheorem map_iSup {f : Î¹ â†’ Filter Î±} : map m (â¨† i, f i) = â¨† i, map m (f i) :=\n  (gc_map_comap m).l_iSup\n\n"}
{"name":"Filter.map_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nâŠ¢ Eq (Filter.map f Top.top) (Filter.principal (Set.range f))","decl":"@[simp]\ntheorem map_top (f : Î± â†’ Î²) : map f âŠ¤ = ğ“Ÿ (range f) := by\n  rw [â† principal_univ, map_principal, image_univ]\n\n"}
{"name":"Filter.comap_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap m Top.top) Top.top","decl":"@[simp] theorem comap_top : comap m âŠ¤ = âŠ¤ := (gc_map_comap m).u_top\n\n"}
{"name":"Filter.comap_inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ngâ‚ gâ‚‚ : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap m (Min.min gâ‚ gâ‚‚)) (Min.min (Filter.comap m gâ‚) (Filter.comap m gâ‚‚))","decl":"@[simp] theorem comap_inf : comap m (gâ‚ âŠ“ gâ‚‚) = comap m gâ‚ âŠ“ comap m gâ‚‚ := (gc_map_comap m).u_inf\n\n"}
{"name":"Filter.comap_iInf","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Sort x\nm : Î± â†’ Î²\nf : Î¹ â†’ Filter Î²\nâŠ¢ Eq (Filter.comap m (iInf fun i => f i)) (iInf fun i => Filter.comap m (f i))","decl":"@[simp]\ntheorem comap_iInf {f : Î¹ â†’ Filter Î²} : comap m (â¨… i, f i) = â¨… i, comap m (f i) :=\n  (gc_map_comap m).u_iInf\n\n"}
{"name":"Filter.le_comap_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nl : Filter Î±\nâŠ¢ LE.le l (Filter.comap f Top.top)","decl":"theorem le_comap_top (f : Î± â†’ Î²) (l : Filter Î±) : l â‰¤ comap f âŠ¤ := by\n  rw [comap_top]\n  exact le_top\n\n"}
{"name":"Filter.map_comap_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ng : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ LE.le (Filter.map m (Filter.comap m g)) g","decl":"theorem map_comap_le : map m (comap m g) â‰¤ g :=\n  (gc_map_comap m).l_u_le _\n\n"}
{"name":"Filter.le_comap_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nâŠ¢ LE.le f (Filter.comap m (Filter.map m f))","decl":"theorem le_comap_map : f â‰¤ comap m (map m f) :=\n  (gc_map_comap m).le_u_l _\n\n"}
{"name":"Filter.comap_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap m Bot.bot) Bot.bot","decl":"@[simp]\ntheorem comap_bot : comap m âŠ¥ = âŠ¥ :=\n  bot_unique fun s _ => âŸ¨âˆ…, mem_bot, by simp only [empty_subset, preimage_empty]âŸ©\n\n"}
{"name":"Filter.neBot_of_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ng : Filter Î²\nm : Î± â†’ Î²\nh : (Filter.comap m g).NeBot\nâŠ¢ g.NeBot","decl":"theorem neBot_of_comap (h : (comap m g).NeBot) : g.NeBot := by\n  rw [neBot_iff] at *\n  contrapose! h\n  rw [h]\n  exact comap_bot\n\n"}
{"name":"Filter.comap_inf_principal_range","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ng : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap m (Min.min g (Filter.principal (Set.range m)))) (Filter.comap m g)","decl":"theorem comap_inf_principal_range : comap m (g âŠ“ ğ“Ÿ (range m)) = comap m g := by\n  simp\n\n"}
{"name":"Filter.disjoint_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ngâ‚ gâ‚‚ : Filter Î²\nm : Î± â†’ Î²\nh : Disjoint gâ‚ gâ‚‚\nâŠ¢ Disjoint (Filter.comap m gâ‚) (Filter.comap m gâ‚‚)","decl":"theorem disjoint_comap (h : Disjoint gâ‚ gâ‚‚) : Disjoint (comap m gâ‚) (comap m gâ‚‚) := by\n  simp only [disjoint_iff, â† comap_inf, h.eq_bot, comap_bot]\n\n"}
{"name":"Filter.comap_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Sort u_2\nf : Î¹ â†’ Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap m (iSup f)) (iSup fun i => Filter.comap m (f i))","decl":"theorem comap_iSup {Î¹} {f : Î¹ â†’ Filter Î²} {m : Î± â†’ Î²} : comap m (iSup f) = â¨† i, comap m (f i) :=\n  (gc_comap_kernMap m).l_iSup\n\n"}
{"name":"Filter.comap_sSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ns : Set (Filter Î²)\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap m (SupSet.sSup s)) (iSup fun f => iSup fun h => Filter.comap m f)","decl":"theorem comap_sSup {s : Set (Filter Î²)} {m : Î± â†’ Î²} : comap m (sSup s) = â¨† f âˆˆ s, comap m f := by\n  simp only [sSup_eq_iSup, comap_iSup, eq_self_iff_true]\n\n"}
{"name":"Filter.comap_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ngâ‚ gâ‚‚ : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap m (Max.max gâ‚ gâ‚‚)) (Max.max (Filter.comap m gâ‚) (Filter.comap m gâ‚‚))","decl":"theorem comap_sup : comap m (gâ‚ âŠ” gâ‚‚) = comap m gâ‚ âŠ” comap m gâ‚‚ := by\n  rw [sup_eq_iSup, comap_iSup, iSup_bool_eq, Bool.cond_true, Bool.cond_false]\n\n"}
{"name":"Filter.map_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.map m (Filter.comap m f)) (Min.min f (Filter.principal (Set.range m)))","decl":"theorem map_comap (f : Filter Î²) (m : Î± â†’ Î²) : (f.comap m).map m = f âŠ“ ğ“Ÿ (range m) := by\n  refine le_antisymm (le_inf map_comap_le <| le_principal_iff.2 range_mem_map) ?_\n  rintro t' âŸ¨t, ht, subâŸ©\n  refine mem_inf_principal.2 (mem_of_superset ht ?_)\n  rintro _ hxt âŸ¨x, rflâŸ©\n  exact sub hxt\n\n"}
{"name":"Filter.map_comap_setCoe_val","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î² : Type v\nf : Filter Î²\ns : Set Î²\nâŠ¢ Eq (Filter.map Subtype.val (Filter.comap Subtype.val f)) (Min.min f (Filter.principal s))","decl":"theorem map_comap_setCoe_val (f : Filter Î²) (s : Set Î²) :\n    (f.comap ((â†‘) : s â†’ Î²)).map (â†‘) = f âŠ“ ğ“Ÿ s := by\n  rw [map_comap, Subtype.range_val]\n\n"}
{"name":"Filter.map_comap_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nhf : Membership.mem f (Set.range m)\nâŠ¢ Eq (Filter.map m (Filter.comap m f)) f","decl":"theorem map_comap_of_mem {f : Filter Î²} {m : Î± â†’ Î²} (hf : range m âˆˆ f) : (f.comap m).map m = f := by\n  rw [map_comap, inf_eq_left.2 (le_principal_iff.2 hf)]\n\n"}
{"name":"Filter.canLift","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nc : Î² â†’ Î±\np : Î± â†’ Prop\ninstâœ : CanLift Î± Î² c p\nâŠ¢ CanLift (Filter Î±) (Filter Î²) (Filter.map c) fun f => Filter.Eventually (fun x => p x) f","decl":"instance canLift (c) (p) [CanLift Î± Î² c p] :\n    CanLift (Filter Î±) (Filter Î²) (map c) fun f => âˆ€á¶  x : Î± in f, p x where\n  prf f hf := âŸ¨comap c f, map_comap_of_mem <| hf.mono CanLift.prfâŸ©\n\n"}
{"name":"Filter.comap_le_comap_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Filter Î²\nm : Î± â†’ Î²\nhf : Membership.mem f (Set.range m)\nâŠ¢ Iff (LE.le (Filter.comap m f) (Filter.comap m g)) (LE.le f g)","decl":"theorem comap_le_comap_iff {f g : Filter Î²} {m : Î± â†’ Î²} (hf : range m âˆˆ f) :\n    comap m f â‰¤ comap m g â†” f â‰¤ g :=\n  âŸ¨fun h => map_comap_of_mem hf â–¸ (map_mono h).trans map_comap_le, fun h => comap_mono hâŸ©\n\n"}
{"name":"Filter.map_comap_of_surjective","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nhf : Function.Surjective f\nl : Filter Î²\nâŠ¢ Eq (Filter.map f (Filter.comap f l)) l","decl":"theorem map_comap_of_surjective {f : Î± â†’ Î²} (hf : Surjective f) (l : Filter Î²) :\n    map f (comap f l) = l :=\n  map_comap_of_mem <| by simp only [hf.range_eq, univ_mem]\n\n"}
{"name":"Filter.comap_injective","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nhf : Function.Surjective f\nâŠ¢ Function.Injective (Filter.comap f)","decl":"theorem comap_injective {f : Î± â†’ Î²} (hf : Surjective f) : Injective (comap f) :=\n  LeftInverse.injective <| map_comap_of_surjective hf\n\n"}
{"name":"Function.Surjective.filter_map_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nhf : Function.Surjective f\nâŠ¢ Eq (Filter.map f Top.top) Top.top","decl":"theorem _root_.Function.Surjective.filter_map_top {f : Î± â†’ Î²} (hf : Surjective f) : map f âŠ¤ = âŠ¤ :=\n  (congr_arg _ comap_top).symm.trans <| map_comap_of_surjective hf âŠ¤\n\n"}
{"name":"Filter.subtype_coe_map_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nf : Filter Î±\nâŠ¢ Eq (Filter.map Subtype.val (Filter.comap Subtype.val f)) (Min.min f (Filter.principal s))","decl":"theorem subtype_coe_map_comap (s : Set Î±) (f : Filter Î±) :\n    map ((â†‘) : s â†’ Î±) (comap ((â†‘) : s â†’ Î±) f) = f âŠ“ ğ“Ÿ s := by rw [map_comap, Subtype.range_coe]\n\n"}
{"name":"Filter.image_mem_of_mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nc : Î² â†’ Î±\nh : Membership.mem f (Set.range c)\nW : Set Î²\nW_in : Membership.mem (Filter.comap c f) W\nâŠ¢ Membership.mem f (Set.image c W)","decl":"theorem image_mem_of_mem_comap {f : Filter Î±} {c : Î² â†’ Î±} (h : range c âˆˆ f) {W : Set Î²}\n    (W_in : W âˆˆ comap c f) : c '' W âˆˆ f := by\n  rw [â† map_comap_of_mem h]\n  exact image_mem_map W_in\n\n"}
{"name":"Filter.image_coe_mem_of_mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\nU : Set Î±\nh : Membership.mem f U\nW : Set â†‘U\nW_in : Membership.mem (Filter.comap Subtype.val f) W\nâŠ¢ Membership.mem f (Set.image Subtype.val W)","decl":"theorem image_coe_mem_of_mem_comap {f : Filter Î±} {U : Set Î±} (h : U âˆˆ f) {W : Set U}\n    (W_in : W âˆˆ comap ((â†‘) : U â†’ Î±) f) : (â†‘) '' W âˆˆ f :=\n  image_mem_of_mem_comap (by simp [h]) W_in\n\n"}
{"name":"Filter.comap_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nh : Function.Injective m\nâŠ¢ Eq (Filter.comap m (Filter.map m f)) f","decl":"theorem comap_map {f : Filter Î±} {m : Î± â†’ Î²} (h : Injective m) : comap m (map m f) = f :=\n  le_antisymm\n    (fun s hs =>\n      mem_of_superset (preimage_mem_comap <| image_mem_map hs) <| by\n        simp only [preimage_image_eq s h, Subset.rfl])\n    le_comap_map\n\n"}
{"name":"Filter.mem_comap_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\ninj : Function.Injective m\nlarge : Membership.mem f (Set.range m)\nS : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.comap m f) S) (Membership.mem f (Set.image m S))","decl":"theorem mem_comap_iff {f : Filter Î²} {m : Î± â†’ Î²} (inj : Injective m) (large : Set.range m âˆˆ f)\n    {S : Set Î±} : S âˆˆ comap m f â†” m '' S âˆˆ f := by\n  rw [â† image_mem_map_iff inj, map_comap_of_mem large]\n\n"}
{"name":"Filter.map_le_map_iff_of_injOn","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nlâ‚ lâ‚‚ : Filter Î±\nf : Î± â†’ Î²\ns : Set Î±\nhâ‚ : Membership.mem lâ‚ s\nhâ‚‚ : Membership.mem lâ‚‚ s\nhinj : Set.InjOn f s\nâŠ¢ Iff (LE.le (Filter.map f lâ‚) (Filter.map f lâ‚‚)) (LE.le lâ‚ lâ‚‚)","decl":"theorem map_le_map_iff_of_injOn {lâ‚ lâ‚‚ : Filter Î±} {f : Î± â†’ Î²} {s : Set Î±} (hâ‚ : s âˆˆ lâ‚)\n    (hâ‚‚ : s âˆˆ lâ‚‚) (hinj : InjOn f s) : map f lâ‚ â‰¤ map f lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ :=\n  âŸ¨fun h _t ht =>\n    mp_mem hâ‚ <|\n      mem_of_superset (h <| image_mem_map (inter_mem hâ‚‚ ht)) fun _y âŸ¨_x, âŸ¨hxs, hxtâŸ©, hxyâŸ© hys =>\n        hinj hxs hys hxy â–¸ hxt,\n    fun h => map_mono hâŸ©\n\n"}
{"name":"Filter.map_le_map_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Filter Î±\nm : Î± â†’ Î²\nhm : Function.Injective m\nâŠ¢ Iff (LE.le (Filter.map m f) (Filter.map m g)) (LE.le f g)","decl":"theorem map_le_map_iff {f g : Filter Î±} {m : Î± â†’ Î²} (hm : Injective m) :\n    map m f â‰¤ map m g â†” f â‰¤ g := by rw [map_le_iff_le_comap, comap_map hm]\n\n"}
{"name":"Filter.map_eq_map_iff_of_injOn","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Filter Î±\nm : Î± â†’ Î²\ns : Set Î±\nhsf : Membership.mem f s\nhsg : Membership.mem g s\nhm : Set.InjOn m s\nâŠ¢ Iff (Eq (Filter.map m f) (Filter.map m g)) (Eq f g)","decl":"theorem map_eq_map_iff_of_injOn {f g : Filter Î±} {m : Î± â†’ Î²} {s : Set Î±} (hsf : s âˆˆ f) (hsg : s âˆˆ g)\n    (hm : InjOn m s) : map m f = map m g â†” f = g := by\n  simp only [le_antisymm_iff, map_le_map_iff_of_injOn hsf hsg hm,\n    map_le_map_iff_of_injOn hsg hsf hm]\n\n"}
{"name":"Filter.map_inj","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Filter Î±\nm : Î± â†’ Î²\nhm : Function.Injective m\nâŠ¢ Iff (Eq (Filter.map m f) (Filter.map m g)) (Eq f g)","decl":"theorem map_inj {f g : Filter Î±} {m : Î± â†’ Î²} (hm : Injective m) : map m f = map m g â†” f = g :=\n  map_eq_map_iff_of_injOn univ_mem univ_mem hm.injOn\n\n"}
{"name":"Filter.map_injective","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nhm : Function.Injective m\nâŠ¢ Function.Injective (Filter.map m)","decl":"theorem map_injective {m : Î± â†’ Î²} (hm : Injective m) : Injective (map m) := fun _ _ =>\n  (map_inj hm).1\n\n"}
{"name":"Filter.comap_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (Filter.comap m f).NeBot (âˆ€ (t : Set Î²), Membership.mem f t â†’ Exists fun a => Membership.mem t (m a))","decl":"theorem comap_neBot_iff {f : Filter Î²} {m : Î± â†’ Î²} : NeBot (comap m f) â†” âˆ€ t âˆˆ f, âˆƒ a, m a âˆˆ t := by\n  simp only [â† forall_mem_nonempty_iff_neBot, mem_comap, forall_exists_index, and_imp]\n  exact âŸ¨fun h t t_in => h (m â»Â¹' t) t t_in Subset.rfl, fun h s t ht hst => (h t ht).imp hstâŸ©\n\n"}
{"name":"Filter.comap_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nhm : âˆ€ (t : Set Î²), Membership.mem f t â†’ Exists fun a => Membership.mem t (m a)\nâŠ¢ (Filter.comap m f).NeBot","decl":"theorem comap_neBot {f : Filter Î²} {m : Î± â†’ Î²} (hm : âˆ€ t âˆˆ f, âˆƒ a, m a âˆˆ t) : NeBot (comap m f) :=\n  comap_neBot_iff.mpr hm\n\n"}
{"name":"Filter.comap_neBot_iff_frequently","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (Filter.comap m f).NeBot (Filter.Frequently (fun y => Membership.mem (Set.range m) y) f)","decl":"theorem comap_neBot_iff_frequently {f : Filter Î²} {m : Î± â†’ Î²} :\n    NeBot (comap m f) â†” âˆƒá¶  y in f, y âˆˆ range m := by\n  simp only [comap_neBot_iff, frequently_iff, mem_range, @and_comm (_ âˆˆ _), exists_exists_eq_and]\n\n"}
{"name":"Filter.comap_neBot_iff_compl_range","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (Filter.comap m f).NeBot (Not (Membership.mem f (HasCompl.compl (Set.range m))))","decl":"theorem comap_neBot_iff_compl_range {f : Filter Î²} {m : Î± â†’ Î²} :\n    NeBot (comap m f) â†” (range m)á¶œ âˆ‰ f :=\n  comap_neBot_iff_frequently\n\n"}
{"name":"Filter.comap_eq_bot_iff_compl_range","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (Eq (Filter.comap m f) Bot.bot) (Membership.mem f (HasCompl.compl (Set.range m)))","decl":"theorem comap_eq_bot_iff_compl_range {f : Filter Î²} {m : Î± â†’ Î²} : comap m f = âŠ¥ â†” (range m)á¶œ âˆˆ f :=\n  not_iff_not.mp <| neBot_iff.symm.trans comap_neBot_iff_compl_range\n\n"}
{"name":"Filter.comap_surjective_eq_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nhm : Function.Surjective m\nâŠ¢ Iff (Eq (Filter.comap m f) Bot.bot) (Eq f Bot.bot)","decl":"theorem comap_surjective_eq_bot {f : Filter Î²} {m : Î± â†’ Î²} (hm : Surjective m) :\n    comap m f = âŠ¥ â†” f = âŠ¥ := by\n  rw [comap_eq_bot_iff_compl_range, hm.range_eq, compl_univ, empty_mem_iff_bot]\n\n"}
{"name":"Filter.disjoint_comap_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ngâ‚ gâ‚‚ : Filter Î²\nm : Î± â†’ Î²\nh : Function.Surjective m\nâŠ¢ Iff (Disjoint (Filter.comap m gâ‚) (Filter.comap m gâ‚‚)) (Disjoint gâ‚ gâ‚‚)","decl":"theorem disjoint_comap_iff (h : Surjective m) :\n    Disjoint (comap m gâ‚) (comap m gâ‚‚) â†” Disjoint gâ‚ gâ‚‚ := by\n  rw [disjoint_iff, disjoint_iff, â† comap_inf, comap_surjective_eq_bot h]\n\n"}
{"name":"Filter.NeBot.comap_of_range_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nxâœ : f.NeBot\nhm : Membership.mem f (Set.range m)\nâŠ¢ (Filter.comap m f).NeBot","decl":"theorem NeBot.comap_of_range_mem {f : Filter Î²} {m : Î± â†’ Î²} (_ : NeBot f) (hm : range m âˆˆ f) :\n    NeBot (comap m f) :=\n  comap_neBot_iff_frequently.2 <| Eventually.frequently hm\n\n"}
{"name":"Filter.comap_fst_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nâŠ¢ Iff (Filter.comap Prod.fst f).NeBot (And f.NeBot (Nonempty Î²))","decl":"@[simp]\ntheorem comap_fst_neBot_iff {f : Filter Î±} :\n    (f.comap (Prod.fst : Î± Ã— Î² â†’ Î±)).NeBot â†” f.NeBot âˆ§ Nonempty Î² := by\n  cases isEmpty_or_nonempty Î²\n  Â· rw [filter_eq_bot_of_isEmpty (f.comap _), â† not_iff_not]; simp [*]\n  Â· simp [comap_neBot_iff_frequently, *]\n\n"}
{"name":"Filter.comap_fst_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : Nonempty Î²\nf : Filter Î±\ninstâœ : f.NeBot\nâŠ¢ (Filter.comap Prod.fst f).NeBot","decl":"@[instance]\ntheorem comap_fst_neBot [Nonempty Î²] {f : Filter Î±} [NeBot f] :\n    (f.comap (Prod.fst : Î± Ã— Î² â†’ Î±)).NeBot :=\n  comap_fst_neBot_iff.2 âŸ¨â€¹_â€º, â€¹_â€ºâŸ©\n\n"}
{"name":"Filter.comap_snd_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nâŠ¢ Iff (Filter.comap Prod.snd f).NeBot (And (Nonempty Î±) f.NeBot)","decl":"@[simp]\ntheorem comap_snd_neBot_iff {f : Filter Î²} :\n    (f.comap (Prod.snd : Î± Ã— Î² â†’ Î²)).NeBot â†” Nonempty Î± âˆ§ f.NeBot := by\n  cases' isEmpty_or_nonempty Î± with hÎ± hÎ±\n  Â· rw [filter_eq_bot_of_isEmpty (f.comap _), â† not_iff_not]; simp\n  Â· simp [comap_neBot_iff_frequently, hÎ±]\n\n"}
{"name":"Filter.comap_snd_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : Nonempty Î±\nf : Filter Î²\ninstâœ : f.NeBot\nâŠ¢ (Filter.comap Prod.snd f).NeBot","decl":"@[instance]\ntheorem comap_snd_neBot [Nonempty Î±] {f : Filter Î²} [NeBot f] :\n    (f.comap (Prod.snd : Î± Ã— Î² â†’ Î²)).NeBot :=\n  comap_snd_neBot_iff.2 âŸ¨â€¹_â€º, â€¹_â€ºâŸ©\n\n"}
{"name":"Filter.comap_eval_neBot_iff'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\ni : Î¹\nf : Filter (Î± i)\nâŠ¢ Iff (Filter.comap (Function.eval i) f).NeBot (And (âˆ€ (j : Î¹), Nonempty (Î± j)) f.NeBot)","decl":"theorem comap_eval_neBot_iff' {Î¹ : Type*} {Î± : Î¹ â†’ Type*} {i : Î¹} {f : Filter (Î± i)} :\n    (comap (eval i) f).NeBot â†” (âˆ€ j, Nonempty (Î± j)) âˆ§ NeBot f := by\n  cases' isEmpty_or_nonempty (âˆ€ j, Î± j) with H H\n  Â· rw [filter_eq_bot_of_isEmpty (f.comap _), â† not_iff_not]\n    simp [â† Classical.nonempty_pi]\n  Â· have : âˆ€ j, Nonempty (Î± j) := Classical.nonempty_pi.1 H\n    simp [comap_neBot_iff_frequently, *]\n\n"}
{"name":"Filter.comap_eval_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\ninstâœ : âˆ€ (j : Î¹), Nonempty (Î± j)\ni : Î¹\nf : Filter (Î± i)\nâŠ¢ Iff (Filter.comap (Function.eval i) f).NeBot f.NeBot","decl":"@[simp]\ntheorem comap_eval_neBot_iff {Î¹ : Type*} {Î± : Î¹ â†’ Type*} [âˆ€ j, Nonempty (Î± j)] {i : Î¹}\n    {f : Filter (Î± i)} : (comap (eval i) f).NeBot â†” NeBot f := by simp [comap_eval_neBot_iff', *]\n\n"}
{"name":"Filter.comap_eval_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\ninstâœÂ¹ : âˆ€ (j : Î¹), Nonempty (Î± j)\ni : Î¹\nf : Filter (Î± i)\ninstâœ : f.NeBot\nâŠ¢ (Filter.comap (Function.eval i) f).NeBot","decl":"@[instance]\ntheorem comap_eval_neBot {Î¹ : Type*} {Î± : Î¹ â†’ Type*} [âˆ€ j, Nonempty (Î± j)] (i : Î¹)\n    (f : Filter (Î± i)) [NeBot f] : (comap (eval i) f).NeBot :=\n  comap_eval_neBot_iff.2 â€¹_â€º\n\n"}
{"name":"Filter.comap_coe_neBot_of_le_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î³ : Type w\ns : Set Î³\nl : Filter Î³\nh : l.NeBot\nh' : LE.le l (Filter.principal s)\nâŠ¢ (Filter.comap Subtype.val l).NeBot","decl":"theorem comap_coe_neBot_of_le_principal {s : Set Î³} {l : Filter Î³} [h : NeBot l] (h' : l â‰¤ ğ“Ÿ s) :\n    NeBot (comap ((â†‘) : s â†’ Î³) l) :=\n  h.comap_of_range_mem <| (@Subtype.range_coe Î³ s).symm â–¸ h' (mem_principal_self s)\n\n"}
{"name":"Filter.NeBot.comap_of_surj","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nhf : f.NeBot\nhm : Function.Surjective m\nâŠ¢ (Filter.comap m f).NeBot","decl":"theorem NeBot.comap_of_surj {f : Filter Î²} {m : Î± â†’ Î²} (hf : NeBot f) (hm : Surjective m) :\n    NeBot (comap m f) :=\n  hf.comap_of_range_mem <| univ_mem' hm\n\n"}
{"name":"Filter.NeBot.comap_of_image_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nhf : f.NeBot\ns : Set Î±\nhs : Membership.mem f (Set.image m s)\nâŠ¢ (Filter.comap m f).NeBot","decl":"theorem NeBot.comap_of_image_mem {f : Filter Î²} {m : Î± â†’ Î²} (hf : NeBot f) {s : Set Î±}\n    (hs : m '' s âˆˆ f) : NeBot (comap m f) :=\n  hf.comap_of_range_mem <| mem_of_superset hs (image_subset_range _ _)\n\n"}
{"name":"Filter.map_eq_bot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nâŠ¢ Iff (Eq (Filter.map m f) Bot.bot) (Eq f Bot.bot)","decl":"@[simp]\ntheorem map_eq_bot_iff : map m f = âŠ¥ â†” f = âŠ¥ :=\n  âŸ¨by\n    rw [â† empty_mem_iff_bot, â† empty_mem_iff_bot]\n    exact id, fun h => by simp only [h, map_bot]âŸ©\n\n"}
{"name":"Filter.map_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nF : Filter Î±\nâŠ¢ Iff (Filter.map f F).NeBot F.NeBot","decl":"theorem map_neBot_iff (f : Î± â†’ Î²) {F : Filter Î±} : NeBot (map f F) â†” NeBot F := by\n  simp only [neBot_iff, Ne, map_eq_bot_iff]\n\n"}
{"name":"Filter.NeBot.map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nhf : f.NeBot\nm : Î± â†’ Î²\nâŠ¢ (Filter.map m f).NeBot","decl":"theorem NeBot.map (hf : NeBot f) (m : Î± â†’ Î²) : NeBot (map m f) :=\n  (map_neBot_iff m).2 hf\n\n"}
{"name":"Filter.NeBot.of_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\naâœ : (Filter.map m f).NeBot\nâŠ¢ f.NeBot","decl":"theorem NeBot.of_map : NeBot (f.map m) â†’ NeBot f :=\n  (map_neBot_iff m).1\n\n"}
{"name":"Filter.map_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nhf : f.NeBot\nâŠ¢ (Filter.map m f).NeBot","decl":"instance map_neBot [hf : NeBot f] : NeBot (f.map m) :=\n  hf.map m\n\n"}
{"name":"Filter.sInter_comap_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nF : Filter Î²\nâŠ¢ Eq (Filter.comap f F).sets.sInter (Set.iInter fun U => Set.iInter fun h => Set.preimage f U)","decl":"theorem sInter_comap_sets (f : Î± â†’ Î²) (F : Filter Î²) : â‹‚â‚€ (comap f F).sets = â‹‚ U âˆˆ F, f â»Â¹' U := by\n  ext x\n  suffices (âˆ€ (A : Set Î±) (B : Set Î²), B âˆˆ F â†’ f â»Â¹' B âŠ† A â†’ x âˆˆ A) â†”\n      âˆ€ B : Set Î², B âˆˆ F â†’ f x âˆˆ B by\n    simp only [mem_sInter, mem_iInter, Filter.mem_sets, mem_comap, this, and_imp, exists_prop,\n      mem_preimage, exists_imp]\n  constructor\n  Â· intro h U U_in\n    simpa only [Subset.rfl, forall_prop_of_true, mem_preimage] using h (f â»Â¹' U) U U_in\n  Â· intro h V U U_in f_U_V\n    exact f_U_V (h U U_in)\n\n"}
{"name":"Filter.map_iInf_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\nm : Î± â†’ Î²\nâŠ¢ LE.le (Filter.map m (iInf f)) (iInf fun i => Filter.map m (f i))","decl":"theorem map_iInf_le {f : Î¹ â†’ Filter Î±} {m : Î± â†’ Î²} : map m (iInf f) â‰¤ â¨… i, map m (f i) :=\n  le_iInf fun _ => map_mono <| iInf_le _ _\n\n"}
{"name":"Filter.map_iInf_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\nm : Î± â†’ Î²\nhf : Directed (fun x1 x2 => GE.ge x1 x2) f\ninstâœ : Nonempty Î¹\nâŠ¢ Eq (Filter.map m (iInf f)) (iInf fun i => Filter.map m (f i))","decl":"theorem map_iInf_eq {f : Î¹ â†’ Filter Î±} {m : Î± â†’ Î²} (hf : Directed (Â· â‰¥ Â·) f) [Nonempty Î¹] :\n    map m (iInf f) = â¨… i, map m (f i) :=\n  map_iInf_le.antisymm fun s (hs : m â»Â¹' s âˆˆ iInf f) =>\n    let âŸ¨i, hiâŸ© := (mem_iInf_of_directed hf _).1 hs\n    have : â¨… i, map m (f i) â‰¤ ğ“Ÿ s :=\n      iInf_le_of_le i <| by simpa only [le_principal_iff, mem_map]\n    Filter.le_principal_iff.1 this\n\n"}
{"name":"Filter.map_biInf_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ¹ : Type w\nf : Î¹ â†’ Filter Î±\nm : Î± â†’ Î²\np : Î¹ â†’ Prop\nh : DirectedOn (Order.Preimage f fun x1 x2 => GE.ge x1 x2) (setOf fun x => p x)\nne : Exists fun i => p i\nâŠ¢ Eq (Filter.map m (iInf fun i => iInf fun x => f i)) (iInf fun i => iInf fun x => Filter.map m (f i))","decl":"theorem map_biInf_eq {Î¹ : Type w} {f : Î¹ â†’ Filter Î±} {m : Î± â†’ Î²} {p : Î¹ â†’ Prop}\n    (h : DirectedOn (f â»Â¹'o (Â· â‰¥ Â·)) { x | p x }) (ne : âˆƒ i, p i) :\n    map m (â¨… (i) (_ : p i), f i) = â¨… (i) (_ : p i), map m (f i) := by\n  haveI := nonempty_subtype.2 ne\n  simp only [iInf_subtype']\n  exact map_iInf_eq h.directed_val\n\n"}
{"name":"Filter.map_inf_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Filter Î±\nm : Î± â†’ Î²\nâŠ¢ LE.le (Filter.map m (Min.min f g)) (Min.min (Filter.map m f) (Filter.map m g))","decl":"theorem map_inf_le {f g : Filter Î±} {m : Î± â†’ Î²} : map m (f âŠ“ g) â‰¤ map m f âŠ“ map m g :=\n  (@map_mono _ _ m).map_inf_le f g\n\n"}
{"name":"Filter.map_inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Filter Î±\nm : Î± â†’ Î²\nh : Function.Injective m\nâŠ¢ Eq (Filter.map m (Min.min f g)) (Min.min (Filter.map m f) (Filter.map m g))","decl":"theorem map_inf {f g : Filter Î±} {m : Î± â†’ Î²} (h : Injective m) :\n    map m (f âŠ“ g) = map m f âŠ“ map m g := by\n  refine map_inf_le.antisymm ?_\n  rintro t âŸ¨sâ‚, hsâ‚, sâ‚‚, hsâ‚‚, ht : m â»Â¹' t = sâ‚ âˆ© sâ‚‚âŸ©\n  refine mem_inf_of_inter (image_mem_map hsâ‚) (image_mem_map hsâ‚‚) ?_\n  rw [â† image_inter h, image_subset_iff, ht]\n\n"}
{"name":"Filter.map_inf'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Filter Î±\nm : Î± â†’ Î²\nt : Set Î±\nhtf : Membership.mem f t\nhtg : Membership.mem g t\nh : Set.InjOn m t\nâŠ¢ Eq (Filter.map m (Min.min f g)) (Min.min (Filter.map m f) (Filter.map m g))","decl":"theorem map_inf' {f g : Filter Î±} {m : Î± â†’ Î²} {t : Set Î±} (htf : t âˆˆ f) (htg : t âˆˆ g)\n    (h : InjOn m t) : map m (f âŠ“ g) = map m f âŠ“ map m g := by\n  lift f to Filter t using htf; lift g to Filter t using htg\n  replace h : Injective (m âˆ˜ ((â†‘) : t â†’ Î±)) := h.injective\n  simp only [map_map, â† map_inf Subtype.coe_injective, map_inf h]\n\n"}
{"name":"Filter.disjoint_of_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nF G : Filter Î±\nf : Î± â†’ Î²\nh : Disjoint (Filter.map f F) (Filter.map f G)\nâŠ¢ Disjoint F G","decl":"lemma disjoint_of_map {Î± Î² : Type*} {F G : Filter Î±} {f : Î± â†’ Î²}\n    (h : Disjoint (map f F) (map f G)) : Disjoint F G :=\n  disjoint_iff.mpr <| map_eq_bot_iff.mp <| le_bot_iff.mp <| trans map_inf_le (disjoint_iff.mp h)\n\n"}
{"name":"Filter.disjoint_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nm : Î± â†’ Î²\nhm : Function.Injective m\nfâ‚ fâ‚‚ : Filter Î±\nâŠ¢ Iff (Disjoint (Filter.map m fâ‚) (Filter.map m fâ‚‚)) (Disjoint fâ‚ fâ‚‚)","decl":"theorem disjoint_map {m : Î± â†’ Î²} (hm : Injective m) {fâ‚ fâ‚‚ : Filter Î±} :\n    Disjoint (map m fâ‚) (map m fâ‚‚) â†” Disjoint fâ‚ fâ‚‚ := by\n  simp only [disjoint_iff, â† map_inf hm, map_eq_bot_iff]\n\n"}
{"name":"Filter.map_equiv_symm","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ne : Equiv Î± Î²\nf : Filter Î²\nâŠ¢ Eq (Filter.map (â‡‘e.symm) f) (Filter.comap (â‡‘e) f)","decl":"theorem map_equiv_symm (e : Î± â‰ƒ Î²) (f : Filter Î²) : map e.symm f = comap e f :=\n  map_injective e.injective <| by\n    rw [map_map, e.self_comp_symm, map_id, map_comap_of_surjective e.surjective]\n\n"}
{"name":"Filter.map_eq_comap_of_inverse","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\nn : Î² â†’ Î±\nhâ‚ : Eq (Function.comp m n) id\nhâ‚‚ : Eq (Function.comp n m) id\nâŠ¢ Eq (Filter.map m f) (Filter.comap n f)","decl":"theorem map_eq_comap_of_inverse {f : Filter Î±} {m : Î± â†’ Î²} {n : Î² â†’ Î±} (hâ‚ : m âˆ˜ n = id)\n    (hâ‚‚ : n âˆ˜ m = id) : map m f = comap n f :=\n  map_equiv_symm âŸ¨n, m, congr_fun hâ‚, congr_fun hâ‚‚âŸ© f\n\n"}
{"name":"Filter.comap_equiv_symm","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ne : Equiv Î± Î²\nf : Filter Î±\nâŠ¢ Eq (Filter.comap (â‡‘e.symm) f) (Filter.map (â‡‘e) f)","decl":"theorem comap_equiv_symm (e : Î± â‰ƒ Î²) (f : Filter Î±) : comap e.symm f = map e f :=\n  (map_eq_comap_of_inverse e.self_comp_symm e.symm_comp_self).symm\n\n"}
{"name":"Filter.map_swap_eq_comap_swap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter (Prod Î± Î²)\nâŠ¢ Eq (Functor.map Prod.swap f) (Filter.comap Prod.swap f)","decl":"theorem map_swap_eq_comap_swap {f : Filter (Î± Ã— Î²)} : Prod.swap <$> f = comap Prod.swap f :=\n  map_eq_comap_of_inverse Prod.swap_swap_eq Prod.swap_swap_eq\n\n"}
{"name":"Filter.map_swap4_eq_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nÎ´ : Type u_1\nf : Filter (Prod (Prod Î± Î²) (Prod Î³ Î´))\nâŠ¢ Eq (Filter.map (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) f) (Filter.comap (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) f)","decl":"/-- A useful lemma when dealing with uniformities. -/\ntheorem map_swap4_eq_comap {f : Filter ((Î± Ã— Î²) Ã— Î³ Ã— Î´)} :\n    map (fun p : (Î± Ã— Î²) Ã— Î³ Ã— Î´ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) f =\n      comap (fun p : (Î± Ã— Î³) Ã— Î² Ã— Î´ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) f :=\n  map_eq_comap_of_inverse (funext fun âŸ¨âŸ¨_, _âŸ©, âŸ¨_, _âŸ©âŸ© => rfl) (funext fun âŸ¨âŸ¨_, _âŸ©, âŸ¨_, _âŸ©âŸ© => rfl)\n\n"}
{"name":"Filter.le_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\ng : Filter Î²\nh : âˆ€ (s : Set Î±), Membership.mem f s â†’ Membership.mem g (Set.image m s)\nâŠ¢ LE.le g (Filter.map m f)","decl":"theorem le_map {f : Filter Î±} {m : Î± â†’ Î²} {g : Filter Î²} (h : âˆ€ s âˆˆ f, m '' s âˆˆ g) : g â‰¤ f.map m :=\n  fun _ hs => mem_of_superset (h _ hs) <| image_preimage_subset _ _\n\n"}
{"name":"Filter.le_map_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Î²\ng : Filter Î²\nâŠ¢ Iff (LE.le g (Filter.map m f)) (âˆ€ (s : Set Î±), Membership.mem f s â†’ Membership.mem g (Set.image m s))","decl":"theorem le_map_iff {f : Filter Î±} {m : Î± â†’ Î²} {g : Filter Î²} : g â‰¤ f.map m â†” âˆ€ s âˆˆ f, m '' s âˆˆ g :=\n  âŸ¨fun h _ hs => h (image_mem_map hs), le_mapâŸ©\n\n"}
{"name":"Filter.push_pull","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nF : Filter Î±\nG : Filter Î²\nâŠ¢ Eq (Filter.map f (Min.min F (Filter.comap f G))) (Min.min (Filter.map f F) G)","decl":"protected theorem push_pull (f : Î± â†’ Î²) (F : Filter Î±) (G : Filter Î²) :\n    map f (F âŠ“ comap f G) = map f F âŠ“ G := by\n  apply le_antisymm\n  Â· calc\n      map f (F âŠ“ comap f G) â‰¤ map f F âŠ“ (map f <| comap f G) := map_inf_le\n      _ â‰¤ map f F âŠ“ G := inf_le_inf_left (map f F) map_comap_le\n\n  Â· rintro U âŸ¨V, V_in, W, âŸ¨Z, Z_in, hZâŸ©, hâŸ©\n    apply mem_inf_of_inter (image_mem_map V_in) Z_in\n    calc\n      f '' V âˆ© Z = f '' (V âˆ© f â»Â¹' Z) := by rw [image_inter_preimage]\n      _ âŠ† f '' (V âˆ© W) := image_subset _ (inter_subset_inter_right _ â€¹_â€º)\n      _ = f '' (f â»Â¹' U) := by rw [h]\n      _ âŠ† U := image_preimage_subset f U\n\n"}
{"name":"Filter.push_pull'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nF : Filter Î±\nG : Filter Î²\nâŠ¢ Eq (Filter.map f (Min.min (Filter.comap f G) F)) (Min.min G (Filter.map f F))","decl":"protected theorem push_pull' (f : Î± â†’ Î²) (F : Filter Î±) (G : Filter Î²) :\n    map f (comap f G âŠ“ F) = G âŠ“ map f F := by simp only [Filter.push_pull, inf_comm]\n\n"}
{"name":"Filter.disjoint_comap_iff_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nF : Filter Î±\nG : Filter Î²\nâŠ¢ Iff (Disjoint F (Filter.comap f G)) (Disjoint (Filter.map f F) G)","decl":"theorem disjoint_comap_iff_map {f : Î± â†’ Î²} {F : Filter Î±} {G : Filter Î²} :\n    Disjoint F (comap f G) â†” Disjoint (map f F) G := by\n  simp only [disjoint_iff, â† Filter.push_pull, map_eq_bot_iff]\n\n"}
{"name":"Filter.disjoint_comap_iff_map'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nF : Filter Î±\nG : Filter Î²\nâŠ¢ Iff (Disjoint (Filter.comap f G) F) (Disjoint G (Filter.map f F))","decl":"theorem disjoint_comap_iff_map' {f : Î± â†’ Î²} {F : Filter Î±} {G : Filter Î²} :\n    Disjoint (comap f G) F â†” Disjoint G (map f F) := by\n  simp only [disjoint_iff, â† Filter.push_pull', map_eq_bot_iff]\n\n"}
{"name":"Filter.neBot_inf_comap_iff_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nF : Filter Î±\nG : Filter Î²\nâŠ¢ Iff (Min.min F (Filter.comap f G)).NeBot (Min.min (Filter.map f F) G).NeBot","decl":"theorem neBot_inf_comap_iff_map {f : Î± â†’ Î²} {F : Filter Î±} {G : Filter Î²} :\n    NeBot (F âŠ“ comap f G) â†” NeBot (map f F âŠ“ G) := by\n  rw [â† map_neBot_iff, Filter.push_pull]\n\n"}
{"name":"Filter.neBot_inf_comap_iff_map'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Î± â†’ Î²\nF : Filter Î±\nG : Filter Î²\nâŠ¢ Iff (Min.min (Filter.comap f G) F).NeBot (Min.min G (Filter.map f F)).NeBot","decl":"theorem neBot_inf_comap_iff_map' {f : Î± â†’ Î²} {F : Filter Î±} {G : Filter Î²} :\n    NeBot (comap f G âŠ“ F) â†” NeBot (G âŠ“ map f F) := by\n  rw [â† map_neBot_iff, Filter.push_pull']\n\n"}
{"name":"Filter.comap_inf_principal_neBot_of_image_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î²\nm : Î± â†’ Î²\nhf : f.NeBot\ns : Set Î±\nhs : Membership.mem f (Set.image m s)\nâŠ¢ (Min.min (Filter.comap m f) (Filter.principal s)).NeBot","decl":"theorem comap_inf_principal_neBot_of_image_mem {f : Filter Î²} {m : Î± â†’ Î²} (hf : NeBot f) {s : Set Î±}\n    (hs : m '' s âˆˆ f) : NeBot (comap m f âŠ“ ğ“Ÿ s) := by\n  rw [neBot_inf_comap_iff_map', map_principal, â† frequently_mem_iff_neBot]\n  exact Eventually.frequently hs\n\n"}
{"name":"Filter.principal_eq_map_coe_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\ns : Set Î±\nâŠ¢ Eq (Filter.principal s) (Filter.map Subtype.val Top.top)","decl":"theorem principal_eq_map_coe_top (s : Set Î±) : ğ“Ÿ s = map ((â†‘) : s â†’ Î±) âŠ¤ := by simp\n\n"}
{"name":"Filter.inf_principal_eq_bot_iff_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nF : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Eq (Min.min F (Filter.principal s)) Bot.bot) (Eq (Filter.comap Subtype.val F) Bot.bot)","decl":"theorem inf_principal_eq_bot_iff_comap {F : Filter Î±} {s : Set Î±} :\n    F âŠ“ ğ“Ÿ s = âŠ¥ â†” comap ((â†‘) : s â†’ Î±) F = âŠ¥ := by\n  rw [principal_eq_map_coe_top s, â† Filter.push_pull', inf_top_eq, map_eq_bot_iff]\n\n"}
{"name":"Filter.singleton_mem_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\na : Î±\nâŠ¢ Membership.mem (Pure.pure a) (Singleton.singleton a)","decl":"theorem singleton_mem_pure {a : Î±} : {a} âˆˆ (pure a : Filter Î±) :=\n  mem_singleton a\n\n"}
{"name":"Filter.pure_injective","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nâŠ¢ Function.Injective Pure.pure","decl":"theorem pure_injective : Injective (pure : Î± â†’ Filter Î±) := fun a _ hab =>\n  (Filter.ext_iff.1 hab { x | a = x }).1 rfl\n\n"}
{"name":"Filter.pure_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\na : Î±\nâŠ¢ (Pure.pure a).NeBot","decl":"instance pure_neBot {Î± : Type u} {a : Î±} : NeBot (pure a) :=\n  âŸ¨mt empty_mem_iff_bot.2 <| not_mem_empty aâŸ©\n\n"}
{"name":"Filter.le_pure_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nf : Filter Î±\na : Î±\nâŠ¢ Iff (LE.le f (Pure.pure a)) (Membership.mem f (Singleton.singleton a))","decl":"@[simp]\ntheorem le_pure_iff {f : Filter Î±} {a : Î±} : f â‰¤ pure a â†” {a} âˆˆ f := by\n  rw [â† principal_singleton, le_principal_iff]\n\n"}
{"name":"Filter.mem_seq_def","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter (Î± â†’ Î²)\ng : Filter Î±\ns : Set Î²\nâŠ¢ Iff (Membership.mem (f.seq g) s) (Exists fun u => And (Membership.mem f u) (Exists fun t => And (Membership.mem g t) (âˆ€ (x : Î± â†’ Î²), Membership.mem u x â†’ âˆ€ (y : Î±), Membership.mem t y â†’ Membership.mem s (x y))))","decl":"theorem mem_seq_def {f : Filter (Î± â†’ Î²)} {g : Filter Î±} {s : Set Î²} :\n    s âˆˆ f.seq g â†” âˆƒ u âˆˆ f, âˆƒ t âˆˆ g, âˆ€ x âˆˆ u, âˆ€ y âˆˆ t, (x : Î± â†’ Î²) y âˆˆ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_seq_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter (Î± â†’ Î²)\ng : Filter Î±\ns : Set Î²\nâŠ¢ Iff (Membership.mem (f.seq g) s) (Exists fun u => And (Membership.mem f u) (Exists fun t => And (Membership.mem g t) (HasSubset.Subset (u.seq t) s)))","decl":"theorem mem_seq_iff {f : Filter (Î± â†’ Î²)} {g : Filter Î±} {s : Set Î²} :\n    s âˆˆ f.seq g â†” âˆƒ u âˆˆ f, âˆƒ t âˆˆ g, Set.seq u t âŠ† s := by\n  simp only [mem_seq_def, seq_subset, exists_prop]\n\n"}
{"name":"Filter.mem_map_seq_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nf : Filter Î±\ng : Filter Î²\nm : Î± â†’ Î² â†’ Î³\ns : Set Î³\nâŠ¢ Iff (Membership.mem ((Filter.map m f).seq g) s) (Exists fun t => Exists fun u => And (Membership.mem g t) (And (Membership.mem f u) (âˆ€ (x : Î±), Membership.mem u x â†’ âˆ€ (y : Î²), Membership.mem t y â†’ Membership.mem s (m x y))))","decl":"theorem mem_map_seq_iff {f : Filter Î±} {g : Filter Î²} {m : Î± â†’ Î² â†’ Î³} {s : Set Î³} :\n    s âˆˆ (f.map m).seq g â†” âˆƒ t u, t âˆˆ g âˆ§ u âˆˆ f âˆ§ âˆ€ x âˆˆ u, âˆ€ y âˆˆ t, m x y âˆˆ s :=\n  Iff.intro (fun âŸ¨t, ht, s, hs, htsâŸ© => âŸ¨s, m â»Â¹' t, hs, ht, fun _ => hts _âŸ©)\n    fun âŸ¨t, s, ht, hs, htsâŸ© =>\n    âŸ¨m '' s, image_mem_map hs, t, ht, fun _ âŸ¨_, has, EqâŸ© => Eq â–¸ hts _ hasâŸ©\n\n"}
{"name":"Filter.seq_mem_seq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter (Î± â†’ Î²)\ng : Filter Î±\ns : Set (Î± â†’ Î²)\nt : Set Î±\nhs : Membership.mem f s\nht : Membership.mem g t\nâŠ¢ Membership.mem (f.seq g) (s.seq t)","decl":"theorem seq_mem_seq {f : Filter (Î± â†’ Î²)} {g : Filter Î±} {s : Set (Î± â†’ Î²)} {t : Set Î±} (hs : s âˆˆ f)\n    (ht : t âˆˆ g) : s.seq t âˆˆ f.seq g :=\n  âŸ¨s, hs, t, ht, fun f hf a ha => âŸ¨f, hf, a, ha, rflâŸ©âŸ©\n\n"}
{"name":"Filter.le_seq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter (Î± â†’ Î²)\ng : Filter Î±\nh : Filter Î²\nhh : âˆ€ (t : Set (Î± â†’ Î²)), Membership.mem f t â†’ âˆ€ (u : Set Î±), Membership.mem g u â†’ Membership.mem h (t.seq u)\nâŠ¢ LE.le h (f.seq g)","decl":"theorem le_seq {f : Filter (Î± â†’ Î²)} {g : Filter Î±} {h : Filter Î²}\n    (hh : âˆ€ t âˆˆ f, âˆ€ u âˆˆ g, Set.seq t u âˆˆ h) : h â‰¤ seq f g := fun _ âŸ¨_, ht, _, hu, hsâŸ© =>\n  mem_of_superset (hh _ ht _ hu) fun _ âŸ¨_, hm, _, ha, eqâŸ© => eq â–¸ hs _ hm _ ha\n\n"}
{"name":"Filter.seq_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nfâ‚ fâ‚‚ : Filter (Î± â†’ Î²)\ngâ‚ gâ‚‚ : Filter Î±\nhf : LE.le fâ‚ fâ‚‚\nhg : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (fâ‚.seq gâ‚) (fâ‚‚.seq gâ‚‚)","decl":"@[mono]\ntheorem seq_mono {fâ‚ fâ‚‚ : Filter (Î± â†’ Î²)} {gâ‚ gâ‚‚ : Filter Î±} (hf : fâ‚ â‰¤ fâ‚‚) (hg : gâ‚ â‰¤ gâ‚‚) :\n    fâ‚.seq gâ‚ â‰¤ fâ‚‚.seq gâ‚‚ :=\n  le_seq fun _ hs _ ht => seq_mem_seq (hf hs) (hg ht)\n\n"}
{"name":"Filter.pure_seq_eq_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ng : Î± â†’ Î²\nf : Filter Î±\nâŠ¢ Eq ((Pure.pure g).seq f) (Filter.map g f)","decl":"@[simp]\ntheorem pure_seq_eq_map (g : Î± â†’ Î²) (f : Filter Î±) : seq (pure g) f = f.map g := by\n  refine le_antisymm (le_map fun s hs => ?_) (le_seq fun s hs t ht => ?_)\n  Â· rw [â† singleton_seq]\n    apply seq_mem_seq _ hs\n    exact singleton_mem_pure\n  Â· refine sets_of_superset (map g f) (image_mem_map ht) ?_\n    rintro b âŸ¨a, ha, rflâŸ©\n    exact âŸ¨g, hs, a, ha, rflâŸ©\n\n"}
{"name":"Filter.seq_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter (Î± â†’ Î²)\na : Î±\nâŠ¢ Eq (f.seq (Pure.pure a)) (Filter.map (fun g => g a) f)","decl":"@[simp]\ntheorem seq_pure (f : Filter (Î± â†’ Î²)) (a : Î±) : seq f (pure a) = map (fun g : Î± â†’ Î² => g a) f := by\n  refine le_antisymm (le_map fun s hs => ?_) (le_seq fun s hs t ht => ?_)\n  Â· rw [â† seq_singleton]\n    exact seq_mem_seq hs singleton_mem_pure\n  Â· refine sets_of_superset (map (fun g : Î± â†’ Î² => g a) f) (image_mem_map hs) ?_\n    rintro b âŸ¨g, hg, rflâŸ©\n    exact âŸ¨g, hg, a, ht, rflâŸ©\n\n"}
{"name":"Filter.seq_assoc","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nx : Filter Î±\ng : Filter (Î± â†’ Î²)\nh : Filter (Î² â†’ Î³)\nâŠ¢ Eq (h.seq (g.seq x)) (((Filter.map (fun x1 x2 => Function.comp x1 x2) h).seq g).seq x)","decl":"@[simp]\ntheorem seq_assoc (x : Filter Î±) (g : Filter (Î± â†’ Î²)) (h : Filter (Î² â†’ Î³)) :\n    seq h (seq g x) = seq (seq (map (Â· âˆ˜ Â·) h) g) x := by\n  refine le_antisymm (le_seq fun s hs t ht => ?_) (le_seq fun s hs t ht => ?_)\n  Â· rcases mem_seq_iff.1 hs with âŸ¨u, hu, v, hv, hsâŸ©\n    rcases mem_map_iff_exists_image.1 hu with âŸ¨w, hw, huâŸ©\n    refine mem_of_superset ?_ (Set.seq_mono ((Set.seq_mono hu Subset.rfl).trans hs) Subset.rfl)\n    rw [â† Set.seq_seq]\n    exact seq_mem_seq hw (seq_mem_seq hv ht)\n  Â· rcases mem_seq_iff.1 ht with âŸ¨u, hu, v, hv, htâŸ©\n    refine mem_of_superset ?_ (Set.seq_mono Subset.rfl ht)\n    rw [Set.seq_seq]\n    exact seq_mem_seq (seq_mem_seq (image_mem_map hs) hu) hv\n\n"}
{"name":"Filter.prod_map_seq_comm","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Eq ((Filter.map Prod.mk f).seq g) ((Filter.map (fun b a => { fst := a, snd := b }) g).seq f)","decl":"theorem prod_map_seq_comm (f : Filter Î±) (g : Filter Î²) :\n    (map Prod.mk f).seq g = seq (map (fun b a => (a, b)) g) f := by\n  refine le_antisymm (le_seq fun s hs t ht => ?_) (le_seq fun s hs t ht => ?_)\n  Â· rcases mem_map_iff_exists_image.1 hs with âŸ¨u, hu, hsâŸ©\n    refine mem_of_superset ?_ (Set.seq_mono hs Subset.rfl)\n    rw [â† Set.prod_image_seq_comm]\n    exact seq_mem_seq (image_mem_map ht) hu\n  Â· rcases mem_map_iff_exists_image.1 hs with âŸ¨u, hu, hsâŸ©\n    refine mem_of_superset ?_ (Set.seq_mono hs Subset.rfl)\n    rw [Set.prod_image_seq_comm]\n    exact seq_mem_seq (image_mem_map ht) hu\n\n"}
{"name":"Filter.seq_eq_filter_seq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± Î² : Type u\nf : Filter (Î± â†’ Î²)\ng : Filter Î±\nâŠ¢ Eq (Seq.seq f fun x => g) (f.seq g)","decl":"theorem seq_eq_filter_seq {Î± Î² : Type u} (f : Filter (Î± â†’ Î²)) (g : Filter Î±) :\n    f <*> g = seq f g :=\n  rfl\n\n"}
{"name":"Filter.instLawfulApplicative","module":"Mathlib.Order.Filter.Basic","initialProofState":"âŠ¢ LawfulApplicative Filter","decl":"instance : LawfulApplicative (Filter : Type u â†’ Type u) where\n  map_pure := map_pure\n  seqLeft_eq _ _ := rfl\n  seqRight_eq _ _ := rfl\n  seq_pure := seq_pure\n  pure_seq := pure_seq_eq_map\n  seq_assoc := seq_assoc\n\n"}
{"name":"Filter.instCommApplicative","module":"Mathlib.Order.Filter.Basic","initialProofState":"âŠ¢ CommApplicative Filter","decl":"instance : CommApplicative (Filter : Type u â†’ Type u) :=\n  âŸ¨fun f g => prod_map_seq_comm f gâŸ©\n\n"}
{"name":"Filter.eventually_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\nm : Î± â†’ Filter Î²\np : Î² â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun y => p y) (f.bind m)) (Filter.Eventually (fun x => Filter.Eventually (fun y => p y) (m x)) f)","decl":"@[simp]\ntheorem eventually_bind {f : Filter Î±} {m : Î± â†’ Filter Î²} {p : Î² â†’ Prop} :\n    (âˆ€á¶  y in bind f m, p y) â†” âˆ€á¶  x in f, âˆ€á¶  y in m x, p y :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventuallyEq_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nf : Filter Î±\nm : Î± â†’ Filter Î²\ngâ‚ gâ‚‚ : Î² â†’ Î³\nâŠ¢ Iff ((f.bind m).EventuallyEq gâ‚ gâ‚‚) (Filter.Eventually (fun x => (m x).EventuallyEq gâ‚ gâ‚‚) f)","decl":"@[simp]\ntheorem eventuallyEq_bind {f : Filter Î±} {m : Î± â†’ Filter Î²} {gâ‚ gâ‚‚ : Î² â†’ Î³} :\n    gâ‚ =á¶ [bind f m] gâ‚‚ â†” âˆ€á¶  x in f, gâ‚ =á¶ [m x] gâ‚‚ :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventuallyLE_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœ : LE Î³\nf : Filter Î±\nm : Î± â†’ Filter Î²\ngâ‚ gâ‚‚ : Î² â†’ Î³\nâŠ¢ Iff ((f.bind m).EventuallyLE gâ‚ gâ‚‚) (Filter.Eventually (fun x => (m x).EventuallyLE gâ‚ gâ‚‚) f)","decl":"@[simp]\ntheorem eventuallyLE_bind [LE Î³] {f : Filter Î±} {m : Î± â†’ Filter Î²} {gâ‚ gâ‚‚ : Î² â†’ Î³} :\n    gâ‚ â‰¤á¶ [bind f m] gâ‚‚ â†” âˆ€á¶  x in f, gâ‚ â‰¤á¶ [m x] gâ‚‚ :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_bind'","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ns : Set Î²\nf : Filter Î±\nm : Î± â†’ Filter Î²\nâŠ¢ Iff (Membership.mem (f.bind m) s) (Membership.mem f (setOf fun a => Membership.mem (m a) s))","decl":"theorem mem_bind' {s : Set Î²} {f : Filter Î±} {m : Î± â†’ Filter Î²} :\n    s âˆˆ bind f m â†” { a | s âˆˆ m a } âˆˆ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ns : Set Î²\nf : Filter Î±\nm : Î± â†’ Filter Î²\nâŠ¢ Iff (Membership.mem (f.bind m) s) (Exists fun t => And (Membership.mem f t) (âˆ€ (x : Î±), Membership.mem t x â†’ Membership.mem (m x) s))","decl":"@[simp]\ntheorem mem_bind {s : Set Î²} {f : Filter Î±} {m : Î± â†’ Filter Î²} :\n    s âˆˆ bind f m â†” âˆƒ t âˆˆ f, âˆ€ x âˆˆ t, s âˆˆ m x :=\n  calc\n    s âˆˆ bind f m â†” { a | s âˆˆ m a } âˆˆ f := Iff.rfl\n    _ â†” âˆƒ t âˆˆ f, t âŠ† { a | s âˆˆ m a } := exists_mem_subset_iff.symm\n    _ â†” âˆƒ t âˆˆ f, âˆ€ x âˆˆ t, s âˆˆ m x := Iff.rfl\n\n"}
{"name":"Filter.bind_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\ng : Î± â†’ Filter Î²\nl : Filter Î²\nh : Filter.Eventually (fun x => LE.le (g x) l) f\nâŠ¢ LE.le (f.bind g) l","decl":"theorem bind_le {f : Filter Î±} {g : Î± â†’ Filter Î²} {l : Filter Î²} (h : âˆ€á¶  x in f, g x â‰¤ l) :\n    f.bind g â‰¤ l :=\n  join_le <| eventually_map.2 h\n\n"}
{"name":"Filter.bind_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nfâ‚ fâ‚‚ : Filter Î±\ngâ‚ gâ‚‚ : Î± â†’ Filter Î²\nhf : LE.le fâ‚ fâ‚‚\nhg : fâ‚.EventuallyLE gâ‚ gâ‚‚\nâŠ¢ LE.le (fâ‚.bind gâ‚) (fâ‚‚.bind gâ‚‚)","decl":"@[mono]\ntheorem bind_mono {fâ‚ fâ‚‚ : Filter Î±} {gâ‚ gâ‚‚ : Î± â†’ Filter Î²} (hf : fâ‚ â‰¤ fâ‚‚) (hg : gâ‚ â‰¤á¶ [fâ‚] gâ‚‚) :\n    bind fâ‚ gâ‚ â‰¤ bind fâ‚‚ gâ‚‚ := by\n  refine le_trans (fun s hs => ?_) (join_mono <| map_mono hf)\n  simp only [mem_join, mem_bind', mem_map] at hs âŠ¢\n  filter_upwards [hg, hs] with _ hx hs using hx hs\n\n"}
{"name":"Filter.bind_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf : Filter Î±\ng : Î± â†’ Filter Î²\ns : Set Î²\nâŠ¢ Eq (f.bind fun x => Min.min (g x) (Filter.principal s)) (Min.min (f.bind g) (Filter.principal s))","decl":"theorem bind_inf_principal {f : Filter Î±} {g : Î± â†’ Filter Î²} {s : Set Î²} :\n    (f.bind fun x => g x âŠ“ ğ“Ÿ s) = f.bind g âŠ“ ğ“Ÿ s :=\n  Filter.ext fun s => by simp only [mem_bind, mem_inf_principal]\n\n"}
{"name":"Filter.sup_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nf g : Filter Î±\nh : Î± â†’ Filter Î²\nâŠ¢ Eq ((Max.max f g).bind h) (Max.max (f.bind h) (g.bind h))","decl":"theorem sup_bind {f g : Filter Î±} {h : Î± â†’ Filter Î²} : bind (f âŠ” g) h = bind f h âŠ” bind g h := rfl\n\n"}
{"name":"Filter.principal_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ns : Set Î±\nf : Î± â†’ Filter Î²\nâŠ¢ Eq ((Filter.principal s).bind f) (iSup fun x => iSup fun h => f x)","decl":"theorem principal_bind {s : Set Î±} {f : Î± â†’ Filter Î²} : bind (ğ“Ÿ s) f = â¨† x âˆˆ s, f x :=\n  show join (map f (ğ“Ÿ s)) = â¨† x âˆˆ s, f x by\n    simp only [sSup_image, join_principal_eq_sSup, map_principal, eq_self_iff_true]\n\n"}
{"name":"Set.EqOn.eventuallyEq","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nf g : Î± â†’ Î²\nh : Set.EqOn f g s\nâŠ¢ (Filter.principal s).EventuallyEq f g","decl":"theorem Set.EqOn.eventuallyEq {Î± Î²} {s : Set Î±} {f g : Î± â†’ Î²} (h : EqOn f g s) : f =á¶ [ğ“Ÿ s] g :=\n  h\n\n"}
{"name":"Set.EqOn.eventuallyEq_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nl : Filter Î±\nf g : Î± â†’ Î²\nh : Set.EqOn f g s\nhl : Membership.mem l s\nâŠ¢ l.EventuallyEq f g","decl":"theorem Set.EqOn.eventuallyEq_of_mem {Î± Î²} {s : Set Î±} {l : Filter Î±} {f g : Î± â†’ Î²} (h : EqOn f g s)\n    (hl : s âˆˆ l) : f =á¶ [l] g :=\n  h.eventuallyEq.filter_mono <| Filter.le_principal_iff.2 hl\n\n"}
{"name":"HasSubset.Subset.eventuallyLE","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_1\nl : Filter Î±\ns t : Set Î±\nh : HasSubset.Subset s t\nâŠ¢ l.EventuallyLE s t","decl":"theorem HasSubset.Subset.eventuallyLE {Î±} {l : Filter Î±} {s t : Set Î±} (h : s âŠ† t) : s â‰¤á¶ [l] t :=\n  Filter.Eventually.of_forall h\n\n"}
{"name":"Filter.map_surjOn_Iic_iff_le_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nF : Filter Î±\nG : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (Set.SurjOn (Filter.map m) (Set.Iic F) (Set.Iic G)) (LE.le G (Filter.map m F))","decl":"theorem Filter.map_surjOn_Iic_iff_le_map {m : Î± â†’ Î²} :\n    SurjOn (map m) (Iic F) (Iic G) â†” G â‰¤ map m F := by\n  refine âŸ¨fun hm â†¦ ?_, fun hm â†¦ ?_âŸ©\n  Â· rcases hm right_mem_Iic with âŸ¨H, (hHF : H â‰¤ F), rflâŸ©\n    exact map_mono hHF\n  Â· have : RightInvOn (F âŠ“ comap m Â·) (map m) (Iic G) :=\n      fun H (hHG : H â‰¤ G) â†¦ by simpa [Filter.push_pull] using hHG.trans hm\n    exact this.surjOn fun H _ â†¦ mem_Iic.mpr inf_le_left\n\n"}
{"name":"Filter.map_surjOn_Iic_iff_surjOn","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nt : Set Î²\nm : Î± â†’ Î²\nâŠ¢ Iff (Set.SurjOn (Filter.map m) (Set.Iic (Filter.principal s)) (Set.Iic (Filter.principal t))) (Set.SurjOn m s t)","decl":"theorem Filter.map_surjOn_Iic_iff_surjOn {s : Set Î±} {t : Set Î²} {m : Î± â†’ Î²} :\n    SurjOn (map m) (Iic <| ğ“Ÿ s) (Iic <| ğ“Ÿ t) â†” SurjOn m s t := by\n  rw [map_surjOn_Iic_iff_le_map, map_principal, principal_mono, SurjOn]\n\n"}
{"name":"Set.SurjOn.filter_map_Iic","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nt : Set Î²\nm : Î± â†’ Î²\naâœ : Set.SurjOn m s t\nâŠ¢ Set.SurjOn (Filter.map m) (Set.Iic (Filter.principal s)) (Set.Iic (Filter.principal t))","decl":"alias âŸ¨_, Set.SurjOn.filter_map_IicâŸ© := Filter.map_surjOn_Iic_iff_surjOn\n\n"}
{"name":"Filter.filter_injOn_Iic_iff_injOn","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nm : Î± â†’ Î²\nâŠ¢ Iff (Set.InjOn (Filter.map m) (Set.Iic (Filter.principal s))) (Set.InjOn m s)","decl":"theorem Filter.filter_injOn_Iic_iff_injOn {s : Set Î±} {m : Î± â†’ Î²} :\n    InjOn (map m) (Iic <| ğ“Ÿ s) â†” InjOn m s := by\n  refine âŸ¨fun hm x hx y hy hxy â†¦ ?_, fun hm F hF G hG â†¦ ?_âŸ©\n  Â· rwa [â† pure_injective.eq_iff, â† map_pure, â† map_pure, hm.eq_iff, pure_injective.eq_iff]\n      at hxy <;> rwa [mem_Iic, pure_le_principal]\n  Â· simp [map_eq_map_iff_of_injOn (le_principal_iff.mp hF) (le_principal_iff.mp hG) hm]\n\n"}
{"name":"Set.InjOn.filter_map_Iic","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\nm : Î± â†’ Î²\naâœ : Set.InjOn m s\nâŠ¢ Set.InjOn (Filter.map m) (Set.Iic (Filter.principal s))","decl":"alias âŸ¨_, Set.InjOn.filter_map_IicâŸ© := Filter.filter_injOn_Iic_iff_injOn\n\n"}
{"name":"Filter.compl_mem_comk","module":"Mathlib.Order.Filter.Basic","initialProofState":"Î± : Type u_1\np : Set Î± â†’ Prop\nhe : p EmptyCollection.emptyCollection\nhmono : âˆ€ (t : Set Î±), p t â†’ âˆ€ (s : Set Î±), HasSubset.Subset s t â†’ p s\nhunion : âˆ€ (s : Set Î±), p s â†’ âˆ€ (t : Set Î±), p t â†’ p (Union.union s t)\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.comk p he hmono hunion) (HasCompl.compl s)) (p s)","decl":"lemma compl_mem_comk {p : Set Î± â†’ Prop} {he hmono hunion s} :\n    sá¶œ âˆˆ comk p he hmono hunion â†” p s := by\n  simp\n\n"}
