{"name":"Filter.filter_eq_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\n⊢ Iff (Eq f g) (Eq f.sets g.sets)","decl":"theorem filter_eq_iff : f = g ↔ f.sets = g.sets :=\n  ⟨congr_arg _, filter_eq⟩\n\n"}
{"name":"Filter.sets_subset_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\n⊢ Iff (HasSubset.Subset f.sets g.sets) (LE.le g f)","decl":"@[simp] theorem sets_subset_sets : f.sets ⊆ g.sets ↔ g ≤ f := .rfl\n"}
{"name":"Filter.sets_ssubset_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\n⊢ Iff (HasSSubset.SSubset f.sets g.sets) (LT.lt g f)","decl":"@[simp] theorem sets_ssubset_sets : f.sets ⊂ g.sets ↔ g < f := .rfl\n\n"}
{"name":"Filter.coext","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\nh : ∀ (s : Set α), Iff (Membership.mem f (HasCompl.compl s)) (Membership.mem g (HasCompl.compl s))\n⊢ Eq f g","decl":"/-- An extensionality lemma that is useful for filters with good lemmas about `sᶜ ∈ f` (e.g.,\n`Filter.comap`, `Filter.coprod`, `Filter.Coprod`, `Filter.cofinite`). -/\nprotected theorem coext (h : ∀ s, sᶜ ∈ f ↔ sᶜ ∈ g) : f = g :=\n  Filter.ext <| compl_surjective.forall.2 h\n\n"}
{"name":"Filter.inter_mem_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns t : Set α\n⊢ Iff (Membership.mem f (Inter.inter s t)) (And (Membership.mem f s) (Membership.mem f t))","decl":"@[simp]\ntheorem inter_mem_iff {s t : Set α} : s ∩ t ∈ f ↔ s ∈ f ∧ t ∈ f :=\n  ⟨fun h => ⟨mem_of_superset h inter_subset_left, mem_of_superset h inter_subset_right⟩,\n    and_imp.2 inter_mem⟩\n\n"}
{"name":"Filter.diff_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns t : Set α\nhs : Membership.mem f s\nht : Membership.mem f (HasCompl.compl t)\n⊢ Membership.mem f (SDiff.sdiff s t)","decl":"theorem diff_mem {s t : Set α} (hs : s ∈ f) (ht : tᶜ ∈ f) : s \\ t ∈ f :=\n  inter_mem hs ht\n\n"}
{"name":"Filter.congr_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns t : Set α\nh : Membership.mem f (setOf fun x => Iff (Membership.mem s x) (Membership.mem t x))\n⊢ Iff (Membership.mem f s) (Membership.mem f t)","decl":"theorem congr_sets (h : { x | x ∈ s ↔ x ∈ t } ∈ f) : s ∈ f ↔ t ∈ f :=\n  ⟨fun hs => mp_mem hs (mem_of_superset h fun _ => Iff.mp), fun hs =>\n    mp_mem hs (mem_of_superset h fun _ => Iff.mpr)⟩\n\n"}
{"name":"Filter.copy_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nS : Set (Set α)\nhmem : ∀ (s : Set α), Iff (Membership.mem S s) (Membership.mem f s)\n⊢ Eq (f.copy S hmem) f","decl":"lemma copy_eq {S} (hmem : ∀ s, s ∈ S ↔ s ∈ f) : f.copy S hmem = f := Filter.ext hmem\n\n"}
{"name":"Filter.biInter_mem'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nβ : Type v\ns : β → Set α\nis : Set β\nhf : is.Subsingleton\n⊢ Iff (Membership.mem f (Set.iInter fun i => Set.iInter fun h => s i)) (∀ (i : β), Membership.mem is i → Membership.mem f (s i))","decl":"/-- Weaker version of `Filter.biInter_mem` that assumes `Subsingleton β` rather than `Finite β`. -/\ntheorem biInter_mem' {β : Type v} {s : β → Set α} {is : Set β} (hf : is.Subsingleton) :\n    (⋂ i ∈ is, s i) ∈ f ↔ ∀ i ∈ is, s i ∈ f := by\n  apply Subsingleton.induction_on hf <;> simp\n\n"}
{"name":"Filter.iInter_mem'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nβ : Sort v\ns : β → Set α\ninst✝ : Subsingleton β\n⊢ Iff (Membership.mem f (Set.iInter fun i => s i)) (∀ (i : β), Membership.mem f (s i))","decl":"/-- Weaker version of `Filter.iInter_mem` that assumes `Subsingleton β` rather than `Finite β`. -/\ntheorem iInter_mem' {β : Sort v} {s : β → Set α} [Subsingleton β] :\n    (⋂ i, s i) ∈ f ↔ ∀ i, s i ∈ f := by\n  rw [← sInter_range, sInter_eq_biInter, biInter_mem' (subsingleton_range s), forall_mem_range]\n\n"}
{"name":"Filter.exists_mem_subset_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns : Set α\n⊢ Iff (Exists fun t => And (Membership.mem f t) (HasSubset.Subset t s)) (Membership.mem f s)","decl":"theorem exists_mem_subset_iff : (∃ t ∈ f, t ⊆ s) ↔ s ∈ f :=\n  ⟨fun ⟨_, ht, ts⟩ => mem_of_superset ht ts, fun hs => ⟨s, hs, Subset.rfl⟩⟩\n\n"}
{"name":"Filter.monotone_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Monotone fun s => Membership.mem f s","decl":"theorem monotone_mem {f : Filter α} : Monotone fun s => s ∈ f := fun _ _ hst h =>\n  mem_of_superset h hst\n\n"}
{"name":"Filter.exists_mem_and_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nP Q : Set α → Prop\nhP : Antitone P\nhQ : Antitone Q\n⊢ Iff (And (Exists fun u => And (Membership.mem f u) (P u)) (Exists fun u => And (Membership.mem f u) (Q u))) (Exists fun u => And (Membership.mem f u) (And (P u) (Q u)))","decl":"theorem exists_mem_and_iff {P : Set α → Prop} {Q : Set α → Prop} (hP : Antitone P)\n    (hQ : Antitone Q) : ((∃ u ∈ f, P u) ∧ ∃ u ∈ f, Q u) ↔ ∃ u ∈ f, P u ∧ Q u := by\n  constructor\n  · rintro ⟨⟨u, huf, hPu⟩, v, hvf, hQv⟩\n    exact\n      ⟨u ∩ v, inter_mem huf hvf, hP inter_subset_left hPu, hQ inter_subset_right hQv⟩\n  · rintro ⟨u, huf, hPu, hQu⟩\n    exact ⟨⟨u, huf, hPu⟩, u, huf, hQu⟩\n\n"}
{"name":"Filter.forall_in_swap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nβ : Type u_1\np : Set α → β → Prop\n⊢ Iff (∀ (a : Set α), Membership.mem f a → ∀ (b : β), p a b) (∀ (b : β) (a : Set α), Membership.mem f a → p a b)","decl":"theorem forall_in_swap {β : Type*} {p : Set α → β → Prop} :\n    (∀ a ∈ f, ∀ (b), p a b) ↔ ∀ (b), ∀ a ∈ f, p a b :=\n  Set.forall_in_swap\n\n"}
{"name":"Filter.mem_principal_self","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Membership.mem (Filter.principal s) s","decl":"theorem mem_principal_self (s : Set α) : s ∈ 𝓟 s := Subset.rfl\n\n"}
{"name":"Filter.not_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\n⊢ Iff (Not (LE.le f g)) (Exists fun s => And (Membership.mem g s) (Not (Membership.mem f s)))","decl":"protected theorem not_le : ¬f ≤ g ↔ ∃ s ∈ g, s ∉ f := by simp_rw [le_def, not_forall, exists_prop]\n\n"}
{"name":"Filter.mem_generate_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set (Set α)\nU : Set α\nh : Membership.mem s U\n⊢ Membership.mem (Filter.generate s) U","decl":"lemma mem_generate_of_mem {s : Set <| Set α} {U : Set α} (h : U ∈ s) :\n    U ∈ generate s := GenerateSets.basic h\n\n"}
{"name":"Filter.le_generate_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set (Set α)\nf : Filter α\n⊢ Iff (LE.le f (Filter.generate s)) (HasSubset.Subset s f.sets)","decl":"theorem le_generate_iff {s : Set (Set α)} {f : Filter α} : f ≤ generate s ↔ s ⊆ f.sets :=\n  Iff.intro (fun h _ hu => h <| GenerateSets.basic <| hu) fun h _ hu =>\n    hu.recOn (fun h' => h h') univ_mem (fun _ hxy hx => mem_of_superset hx hxy) fun _ _ hx hy =>\n      inter_mem hx hy\n\n"}
{"name":"Filter.generate_singleton","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Filter.generate (Singleton.singleton s)) (Filter.principal s)","decl":"@[simp] lemma generate_singleton (s : Set α) : generate {s} = 𝓟 s :=\n  le_antisymm (fun _t ht ↦ mem_of_superset (mem_generate_of_mem <| mem_singleton _) ht) <|\n    le_generate_iff.2 <| singleton_subset_iff.2 Subset.rfl\n\n"}
{"name":"Filter.mkOfClosure_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set (Set α)\nhs : Eq (Filter.generate s).sets s\n⊢ Eq (Filter.mkOfClosure s hs) (Filter.generate s)","decl":"theorem mkOfClosure_sets {s : Set (Set α)} {hs : (generate s).sets = s} :\n    Filter.mkOfClosure s hs = generate s :=\n  Filter.ext fun u =>\n    show u ∈ (Filter.mkOfClosure s hs).sets ↔ u ∈ (generate s).sets from hs.symm ▸ Iff.rfl\n\n"}
{"name":"Filter.mem_inf_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\ns : Set α\n⊢ Iff (Membership.mem (Min.min f g) s) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (Eq s (Inter.inter t₁ t₂))))","decl":"theorem mem_inf_iff {f g : Filter α} {s : Set α} : s ∈ f ⊓ g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, s = t₁ ∩ t₂ :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_inf_of_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\ns : Set α\nh : Membership.mem f s\n⊢ Membership.mem (Min.min f g) s","decl":"theorem mem_inf_of_left {f g : Filter α} {s : Set α} (h : s ∈ f) : s ∈ f ⊓ g :=\n  ⟨s, h, univ, univ_mem, (inter_univ s).symm⟩\n\n"}
{"name":"Filter.mem_inf_of_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\ns : Set α\nh : Membership.mem g s\n⊢ Membership.mem (Min.min f g) s","decl":"theorem mem_inf_of_right {f g : Filter α} {s : Set α} (h : s ∈ g) : s ∈ f ⊓ g :=\n  ⟨univ, univ_mem, s, h, (univ_inter s).symm⟩\n\n"}
{"name":"Filter.inter_mem_inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\ns t : Set α\nhs : Membership.mem f s\nht : Membership.mem g t\n⊢ Membership.mem (Min.min f g) (Inter.inter s t)","decl":"theorem inter_mem_inf {α : Type u} {f g : Filter α} {s t : Set α} (hs : s ∈ f) (ht : t ∈ g) :\n    s ∩ t ∈ f ⊓ g :=\n  ⟨s, hs, t, ht, rfl⟩\n\n"}
{"name":"Filter.mem_inf_of_inter","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\ns t u : Set α\nhs : Membership.mem f s\nht : Membership.mem g t\nh : HasSubset.Subset (Inter.inter s t) u\n⊢ Membership.mem (Min.min f g) u","decl":"theorem mem_inf_of_inter {f g : Filter α} {s t u : Set α} (hs : s ∈ f) (ht : t ∈ g)\n    (h : s ∩ t ⊆ u) : u ∈ f ⊓ g :=\n  mem_of_superset (inter_mem_inf hs ht) h\n\n"}
{"name":"Filter.mem_inf_iff_superset","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\ns : Set α\n⊢ Iff (Membership.mem (Min.min f g) s) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (Inter.inter t₁ t₂) s)))","decl":"theorem mem_inf_iff_superset {f g : Filter α} {s : Set α} :\n    s ∈ f ⊓ g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ ∩ t₂ ⊆ s :=\n  ⟨fun ⟨t₁, h₁, t₂, h₂, Eq⟩ => ⟨t₁, h₁, t₂, h₂, Eq ▸ Subset.rfl⟩, fun ⟨_, h₁, _, h₂, sub⟩ =>\n    mem_inf_of_inter h₁ h₂ sub⟩\n\n"}
{"name":"Filter.NeBot.ne","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nhf : f.NeBot\n⊢ Ne f Bot.bot","decl":"theorem NeBot.ne {f : Filter α} (hf : NeBot f) : f ≠ ⊥ := hf.ne'\n\n"}
{"name":"Filter.not_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Iff (Not f.NeBot) (Eq f Bot.bot)","decl":"@[simp] theorem not_neBot {f : Filter α} : ¬f.NeBot ↔ f = ⊥ := neBot_iff.not_left\n\n"}
{"name":"Filter.NeBot.mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\nhf : f.NeBot\nhg : LE.le f g\n⊢ g.NeBot","decl":"theorem NeBot.mono {f g : Filter α} (hf : NeBot f) (hg : f ≤ g) : NeBot g :=\n  ⟨ne_bot_of_le_ne_bot hf.1 hg⟩\n\n"}
{"name":"Filter.neBot_of_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\nhf : f.NeBot\nhg : LE.le f g\n⊢ g.NeBot","decl":"theorem neBot_of_le {f g : Filter α} [hf : NeBot f] (hg : f ≤ g) : NeBot g :=\n  hf.mono hg\n\n"}
{"name":"Filter.sup_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\n⊢ Iff (Max.max f g).NeBot (Or f.NeBot g.NeBot)","decl":"@[simp] theorem sup_neBot {f g : Filter α} : NeBot (f ⊔ g) ↔ NeBot f ∨ NeBot g := by\n  simp only [neBot_iff, not_and_or, Ne, sup_eq_bot_iff]\n\n"}
{"name":"Filter.not_disjoint_self_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Iff (Not (Disjoint f f)) f.NeBot","decl":"theorem not_disjoint_self_iff : ¬Disjoint f f ↔ f.NeBot := by rw [disjoint_self, neBot_iff]\n\n"}
{"name":"Filter.bot_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\n⊢ Eq Bot.bot.sets Set.univ","decl":"theorem bot_sets_eq : (⊥ : Filter α).sets = univ := rfl\n\n"}
{"name":"Filter.eq_or_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Or (Eq f Bot.bot) f.NeBot","decl":"/-- Either `f = ⊥` or `Filter.NeBot f`. This is a version of `eq_or_ne` that uses `Filter.NeBot`\nas the second alternative, to be used as an instance. -/\ntheorem eq_or_neBot (f : Filter α) : f = ⊥ ∨ NeBot f := (eq_or_ne f ⊥).imp_right NeBot.mk\n\n"}
{"name":"Filter.sup_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\n⊢ Eq (Max.max f g).sets (Inter.inter f.sets g.sets)","decl":"theorem sup_sets_eq {f g : Filter α} : (f ⊔ g).sets = f.sets ∩ g.sets :=\n  (giGenerate α).gc.u_inf\n\n"}
{"name":"Filter.sSup_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set (Filter α)\n⊢ Eq (SupSet.sSup s).sets (Set.iInter fun f => Set.iInter fun h => f.sets)","decl":"theorem sSup_sets_eq {s : Set (Filter α)} : (sSup s).sets = ⋂ f ∈ s, (f : Filter α).sets :=\n  (giGenerate α).gc.u_sInf\n\n"}
{"name":"Filter.iSup_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\n⊢ Eq (iSup f).sets (Set.iInter fun i => (f i).sets)","decl":"theorem iSup_sets_eq {f : ι → Filter α} : (iSup f).sets = ⋂ i, (f i).sets :=\n  (giGenerate α).gc.u_iInf\n\n"}
{"name":"Filter.generate_empty","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\n⊢ Eq (Filter.generate EmptyCollection.emptyCollection) Top.top","decl":"theorem generate_empty : Filter.generate ∅ = (⊤ : Filter α) :=\n  (giGenerate α).gc.l_bot\n\n"}
{"name":"Filter.generate_univ","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\n⊢ Eq (Filter.generate Set.univ) Bot.bot","decl":"theorem generate_univ : Filter.generate univ = (⊥ : Filter α) :=\n  bot_unique fun _ _ => GenerateSets.basic (mem_univ _)\n\n"}
{"name":"Filter.generate_union","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set (Set α)\n⊢ Eq (Filter.generate (Union.union s t)) (Min.min (Filter.generate s) (Filter.generate t))","decl":"theorem generate_union {s t : Set (Set α)} :\n    Filter.generate (s ∪ t) = Filter.generate s ⊓ Filter.generate t :=\n  (giGenerate α).gc.l_sup\n\n"}
{"name":"Filter.generate_iUnion","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\ns : ι → Set (Set α)\n⊢ Eq (Filter.generate (Set.iUnion fun i => s i)) (iInf fun i => Filter.generate (s i))","decl":"theorem generate_iUnion {s : ι → Set (Set α)} :\n    Filter.generate (⋃ i, s i) = ⨅ i, Filter.generate (s i) :=\n  (giGenerate α).gc.l_iSup\n\n"}
{"name":"Filter.mem_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\ns : Set α\n⊢ Iff (Membership.mem (Max.max f g) s) (And (Membership.mem f s) (Membership.mem g s))","decl":"@[simp]\ntheorem mem_sup {f g : Filter α} {s : Set α} : s ∈ f ⊔ g ↔ s ∈ f ∧ s ∈ g :=\n  Iff.rfl\n\n"}
{"name":"Filter.union_mem_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\ns t : Set α\nhs : Membership.mem f s\nht : Membership.mem g t\n⊢ Membership.mem (Max.max f g) (Union.union s t)","decl":"theorem union_mem_sup {f g : Filter α} {s t : Set α} (hs : s ∈ f) (ht : t ∈ g) : s ∪ t ∈ f ⊔ g :=\n  ⟨mem_of_superset hs subset_union_left, mem_of_superset ht subset_union_right⟩\n\n"}
{"name":"Filter.mem_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nx : Set α\nf : ι → Filter α\n⊢ Iff (Membership.mem (iSup f) x) (∀ (i : ι), Membership.mem (f i) x)","decl":"@[simp]\ntheorem mem_iSup {x : Set α} {f : ι → Filter α} : x ∈ iSup f ↔ ∀ i, x ∈ f i := by\n  simp only [← Filter.mem_sets, iSup_sets_eq, mem_iInter]\n\n"}
{"name":"Filter.iSup_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\n⊢ Iff (iSup fun i => f i).NeBot (Exists fun i => (f i).NeBot)","decl":"@[simp]\ntheorem iSup_neBot {f : ι → Filter α} : (⨆ i, f i).NeBot ↔ ∃ i, (f i).NeBot := by\n  simp [neBot_iff]\n\n"}
{"name":"Filter.iInf_eq_generate","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\ns : ι → Filter α\n⊢ Eq (iInf s) (Filter.generate (Set.iUnion fun i => (s i).sets))","decl":"theorem iInf_eq_generate (s : ι → Filter α) : iInf s = generate (⋃ i, (s i).sets) :=\n  eq_of_forall_le_iff fun _ ↦ by simp [le_generate_iff]\n\n"}
{"name":"Filter.mem_iInf_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\ni : ι\ns : Set α\nhs : Membership.mem (f i) s\n⊢ Membership.mem (iInf fun i => f i) s","decl":"theorem mem_iInf_of_mem {f : ι → Filter α} (i : ι) {s} (hs : s ∈ f i) : s ∈ ⨅ i, f i :=\n  iInf_le f i hs\n\n"}
{"name":"Filter.le_principal_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\nf : Filter α\n⊢ Iff (LE.le f (Filter.principal s)) (Membership.mem f s)","decl":"@[simp]\ntheorem le_principal_iff {s : Set α} {f : Filter α} : f ≤ 𝓟 s ↔ s ∈ f :=\n  ⟨fun h => h Subset.rfl, fun hs _ ht => mem_of_superset hs ht⟩\n\n"}
{"name":"Filter.Iic_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Set.Iic (Filter.principal s)) (setOf fun l => Membership.mem l s)","decl":"theorem Iic_principal (s : Set α) : Iic (𝓟 s) = { l | s ∈ l } :=\n  Set.ext fun _ => le_principal_iff\n\n"}
{"name":"Filter.principal_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (LE.le (Filter.principal s) (Filter.principal t)) (HasSubset.Subset s t)","decl":"theorem principal_mono {s t : Set α} : 𝓟 s ≤ 𝓟 t ↔ s ⊆ t := by\n  simp only [le_principal_iff, mem_principal]\n\n"}
{"name":"GCongr.filter_principal_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\na✝ : HasSubset.Subset s t\n⊢ LE.le (Filter.principal s) (Filter.principal t)","decl":"@[gcongr] alias ⟨_, _root_.GCongr.filter_principal_mono⟩ := principal_mono\n\n"}
{"name":"Filter.monotone_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\n⊢ Monotone Filter.principal","decl":"@[mono]\ntheorem monotone_principal : Monotone (𝓟 : Set α → Filter α) := fun _ _ => principal_mono.2\n\n"}
{"name":"Filter.principal_eq_iff_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Eq (Filter.principal s) (Filter.principal t)) (Eq s t)","decl":"@[simp] theorem principal_eq_iff_eq {s t : Set α} : 𝓟 s = 𝓟 t ↔ s = t := by\n  simp only [le_antisymm_iff, le_principal_iff, mem_principal]; rfl\n\n"}
{"name":"Filter.join_principal_eq_sSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set (Filter α)\n⊢ Eq (Filter.principal s).join (SupSet.sSup s)","decl":"@[simp] theorem join_principal_eq_sSup {s : Set (Filter α)} : join (𝓟 s) = sSup s := rfl\n\n"}
{"name":"Filter.principal_univ","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\n⊢ Eq (Filter.principal Set.univ) Top.top","decl":"@[simp] theorem principal_univ : 𝓟 (univ : Set α) = ⊤ :=\n  top_unique <| by simp only [le_principal_iff, mem_top, eq_self_iff_true]\n\n"}
{"name":"Filter.principal_empty","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\n⊢ Eq (Filter.principal EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem principal_empty : 𝓟 (∅ : Set α) = ⊥ :=\n  bot_unique fun _ _ => empty_subset _\n\n"}
{"name":"Filter.generate_eq_biInf","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nS : Set (Set α)\n⊢ Eq (Filter.generate S) (iInf fun s => iInf fun h => Filter.principal s)","decl":"theorem generate_eq_biInf (S : Set (Set α)) : generate S = ⨅ s ∈ S, 𝓟 s :=\n  eq_of_forall_le_iff fun f => by simp [le_generate_iff, le_principal_iff, subset_def]\n\n"}
{"name":"Filter.empty_mem_iff_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Iff (Membership.mem f EmptyCollection.emptyCollection) (Eq f Bot.bot)","decl":"theorem empty_mem_iff_bot {f : Filter α} : ∅ ∈ f ↔ f = ⊥ :=\n  ⟨fun h => bot_unique fun s _ => mem_of_superset h (empty_subset s), fun h => h.symm ▸ mem_bot⟩\n\n"}
{"name":"Filter.nonempty_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nhf : f.NeBot\ns : Set α\nhs : Membership.mem f s\n⊢ s.Nonempty","decl":"theorem nonempty_of_mem {f : Filter α} [hf : NeBot f] {s : Set α} (hs : s ∈ f) : s.Nonempty :=\n  s.eq_empty_or_nonempty.elim (fun h => absurd hs (h.symm ▸ mt empty_mem_iff_bot.mp hf.1)) id\n\n"}
{"name":"Filter.NeBot.nonempty_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nhf : f.NeBot\ns : Set α\nhs : Membership.mem f s\n⊢ s.Nonempty","decl":"theorem NeBot.nonempty_of_mem {f : Filter α} (hf : NeBot f) {s : Set α} (hs : s ∈ f) : s.Nonempty :=\n  @Filter.nonempty_of_mem α f hf s hs\n\n"}
{"name":"Filter.empty_not_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\n⊢ Not (Membership.mem f EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem empty_not_mem (f : Filter α) [NeBot f] : ¬∅ ∈ f := fun h => (nonempty_of_mem h).ne_empty rfl\n\n"}
{"name":"Filter.nonempty_of_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\n⊢ Nonempty α","decl":"theorem nonempty_of_neBot (f : Filter α) [NeBot f] : Nonempty α :=\n  nonempty_of_exists <| nonempty_of_mem (univ_mem : univ ∈ f)\n\n"}
{"name":"Filter.compl_not_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns : Set α\ninst✝ : f.NeBot\nh : Membership.mem f s\n⊢ Not (Membership.mem f (HasCompl.compl s))","decl":"theorem compl_not_mem {f : Filter α} {s : Set α} [NeBot f] (h : s ∈ f) : sᶜ ∉ f := fun hsc =>\n  (nonempty_of_mem (inter_mem h hsc)).ne_empty <| inter_compl_self s\n\n"}
{"name":"Filter.filter_eq_bot_of_isEmpty","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ninst✝ : IsEmpty α\nf : Filter α\n⊢ Eq f Bot.bot","decl":"theorem filter_eq_bot_of_isEmpty [IsEmpty α] (f : Filter α) : f = ⊥ :=\n  empty_mem_iff_bot.mp <| univ_mem' isEmptyElim\n\n"}
{"name":"Filter.disjoint_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\n⊢ Iff (Disjoint f g) (Exists fun s => And (Membership.mem f s) (Exists fun t => And (Membership.mem g t) (Disjoint s t)))","decl":"protected lemma disjoint_iff {f g : Filter α} : Disjoint f g ↔ ∃ s ∈ f, ∃ t ∈ g, Disjoint s t := by\n  simp only [disjoint_iff, ← empty_mem_iff_bot, mem_inf_iff, inf_eq_inter, bot_eq_empty,\n    @eq_comm _ ∅]\n\n"}
{"name":"Filter.disjoint_of_disjoint_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\ns t : Set α\nh : Disjoint s t\nhs : Membership.mem f s\nht : Membership.mem g t\n⊢ Disjoint f g","decl":"theorem disjoint_of_disjoint_of_mem {f g : Filter α} {s t : Set α} (h : Disjoint s t) (hs : s ∈ f)\n    (ht : t ∈ g) : Disjoint f g :=\n  Filter.disjoint_iff.mpr ⟨s, hs, t, ht, h⟩\n\n"}
{"name":"Filter.NeBot.not_disjoint","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns t : Set α\nhf : f.NeBot\nhs : Membership.mem f s\nht : Membership.mem f t\n⊢ Not (Disjoint s t)","decl":"theorem NeBot.not_disjoint (hf : f.NeBot) (hs : s ∈ f) (ht : t ∈ f) : ¬Disjoint s t := fun h =>\n  not_disjoint_self_iff.2 hf <| Filter.disjoint_iff.2 ⟨s, hs, t, ht, h⟩\n\n"}
{"name":"Filter.inf_eq_bot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\n⊢ Iff (Eq (Min.min f g) Bot.bot) (Exists fun U => And (Membership.mem f U) (Exists fun V => And (Membership.mem g V) (Eq (Inter.inter U V) EmptyCollection.emptyCollection)))","decl":"theorem inf_eq_bot_iff {f g : Filter α} : f ⊓ g = ⊥ ↔ ∃ U ∈ f, ∃ V ∈ g, U ∩ V = ∅ := by\n  simp only [← disjoint_iff, Filter.disjoint_iff, Set.disjoint_iff_inter_eq_empty]\n\n"}
{"name":"Filter.NeBot.nonempty","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nhf : f.NeBot\n⊢ Nonempty α","decl":"theorem NeBot.nonempty (f : Filter α) [hf : f.NeBot] : Nonempty α :=\n  not_isEmpty_iff.mp fun _ ↦ hf.ne (Subsingleton.elim _ _)\n\n"}
{"name":"Filter.eq_top_of_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ninst✝¹ : Subsingleton α\nl : Filter α\ninst✝ : l.NeBot\n⊢ Eq l Top.top","decl":"/-- There are only two filters on a `Subsingleton`: `⊥` and `⊤`. If the type is empty, then they are\nequal. -/\ntheorem eq_top_of_neBot [Subsingleton α] (l : Filter α) [NeBot l] : l = ⊤ := by\n  refine top_unique fun s hs => ?_\n  obtain rfl : s = univ := Subsingleton.eq_univ_of_nonempty (nonempty_of_mem hs)\n  exact univ_mem\n\n"}
{"name":"Filter.forall_mem_nonempty_iff_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Iff (∀ (s : Set α), Membership.mem f s → s.Nonempty) f.NeBot","decl":"theorem forall_mem_nonempty_iff_neBot {f : Filter α} :\n    (∀ s : Set α, s ∈ f → s.Nonempty) ↔ NeBot f :=\n  ⟨fun h => ⟨fun hf => not_nonempty_empty (h ∅ <| hf.symm ▸ mem_bot)⟩, @nonempty_of_mem _ _⟩\n\n"}
{"name":"Filter.instNontrivialFilter","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Nontrivial (Filter α)","decl":"instance instNontrivialFilter [Nonempty α] : Nontrivial (Filter α) :=\n  ⟨⟨⊤, ⊥, NeBot.ne <| forall_mem_nonempty_iff_neBot.1\n    fun s hs => by rwa [mem_top.1 hs, ← nonempty_iff_univ_nonempty]⟩⟩\n\n"}
{"name":"Filter.nontrivial_iff_nonempty","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\n⊢ Iff (Nontrivial (Filter α)) (Nonempty α)","decl":"theorem nontrivial_iff_nonempty : Nontrivial (Filter α) ↔ Nonempty α :=\n  ⟨fun _ =>\n    by_contra fun h' =>\n      haveI := not_nonempty_iff.1 h'\n      not_subsingleton (Filter α) inferInstance,\n    @Filter.instNontrivialFilter α⟩\n\n"}
{"name":"Filter.eq_sInf_of_mem_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nS : Set (Filter α)\nl : Filter α\nh : ∀ {s : Set α}, Iff (Membership.mem l s) (Exists fun f => And (Membership.mem S f) (Membership.mem f s))\n⊢ Eq l (InfSet.sInf S)","decl":"theorem eq_sInf_of_mem_iff_exists_mem {S : Set (Filter α)} {l : Filter α}\n    (h : ∀ {s}, s ∈ l ↔ ∃ f ∈ S, s ∈ f) : l = sInf S :=\n  le_antisymm (le_sInf fun f hf _ hs => h.2 ⟨f, hf, hs⟩)\n    fun _ hs => let ⟨_, hf, hs⟩ := h.1 hs; (sInf_le hf) hs\n\n"}
{"name":"Filter.eq_iInf_of_mem_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\nl : Filter α\nh : ∀ {s : Set α}, Iff (Membership.mem l s) (Exists fun i => Membership.mem (f i) s)\n⊢ Eq l (iInf f)","decl":"theorem eq_iInf_of_mem_iff_exists_mem {f : ι → Filter α} {l : Filter α}\n    (h : ∀ {s}, s ∈ l ↔ ∃ i, s ∈ f i) : l = iInf f :=\n  eq_sInf_of_mem_iff_exists_mem <| h.trans (exists_range_iff (p := (_ ∈ ·))).symm\n\n"}
{"name":"Filter.eq_biInf_of_mem_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\np : ι → Prop\nl : Filter α\nh : ∀ {s : Set α}, Iff (Membership.mem l s) (Exists fun i => And (p i) (Membership.mem (f i) s))\n⊢ Eq l (iInf fun i => iInf fun x => f i)","decl":"theorem eq_biInf_of_mem_iff_exists_mem {f : ι → Filter α} {p : ι → Prop} {l : Filter α}\n    (h : ∀ {s}, s ∈ l ↔ ∃ i, p i ∧ s ∈ f i) : l = ⨅ (i) (_ : p i), f i := by\n  rw [iInf_subtype']\n  exact eq_iInf_of_mem_iff_exists_mem fun {_} => by simp only [Subtype.exists, h, exists_prop]\n\n"}
{"name":"Filter.iInf_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\nh : Directed (fun x1 x2 => GE.ge x1 x2) f\nne : Nonempty ι\n⊢ Eq (iInf f).sets (Set.iUnion fun i => (f i).sets)","decl":"theorem iInf_sets_eq {f : ι → Filter α} (h : Directed (· ≥ ·) f) [ne : Nonempty ι] :\n    (iInf f).sets = ⋃ i, (f i).sets :=\n  let ⟨i⟩ := ne\n  let u :=\n    { sets := ⋃ i, (f i).sets\n      univ_sets := mem_iUnion.2 ⟨i, univ_mem⟩\n      sets_of_superset := by\n        simp only [mem_iUnion, exists_imp]\n        exact fun i hx hxy => ⟨i, mem_of_superset hx hxy⟩\n      inter_sets := by\n        simp only [mem_iUnion, exists_imp]\n        intro x y a hx b hy\n        rcases h a b with ⟨c, ha, hb⟩\n        exact ⟨c, inter_mem (ha hx) (hb hy)⟩ }\n  have : u = iInf f := eq_iInf_of_mem_iff_exists_mem mem_iUnion\n  -- Porting note: it was just `congr_arg filter.sets this.symm`\n  (congr_arg Filter.sets this.symm).trans <| by simp only [u]\n\n"}
{"name":"Filter.mem_iInf_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\nh : Directed (fun x1 x2 => GE.ge x1 x2) f\ninst✝ : Nonempty ι\ns : Set α\n⊢ Iff (Membership.mem (iInf f) s) (Exists fun i => Membership.mem (f i) s)","decl":"theorem mem_iInf_of_directed {f : ι → Filter α} (h : Directed (· ≥ ·) f) [Nonempty ι] (s) :\n    s ∈ iInf f ↔ ∃ i, s ∈ f i := by\n  simp only [← Filter.mem_sets, iInf_sets_eq h, mem_iUnion]\n\n"}
{"name":"Filter.mem_biInf_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → Filter α\ns : Set β\nh : DirectedOn (Order.Preimage f fun x1 x2 => GE.ge x1 x2) s\nne : s.Nonempty\nt : Set α\n⊢ Iff (Membership.mem (iInf fun i => iInf fun h => f i) t) (Exists fun i => And (Membership.mem s i) (Membership.mem (f i) t))","decl":"theorem mem_biInf_of_directed {f : β → Filter α} {s : Set β} (h : DirectedOn (f ⁻¹'o (· ≥ ·)) s)\n    (ne : s.Nonempty) {t : Set α} : (t ∈ ⨅ i ∈ s, f i) ↔ ∃ i ∈ s, t ∈ f i := by\n  haveI := ne.to_subtype\n  simp_rw [iInf_subtype', mem_iInf_of_directed h.directed_val, Subtype.exists, exists_prop]\n\n"}
{"name":"Filter.biInf_sets_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : β → Filter α\ns : Set β\nh : DirectedOn (Order.Preimage f fun x1 x2 => GE.ge x1 x2) s\nne : s.Nonempty\n⊢ Eq (iInf fun i => iInf fun h => f i).sets (Set.iUnion fun i => Set.iUnion fun h => (f i).sets)","decl":"theorem biInf_sets_eq {f : β → Filter α} {s : Set β} (h : DirectedOn (f ⁻¹'o (· ≥ ·)) s)\n    (ne : s.Nonempty) : (⨅ i ∈ s, f i).sets = ⋃ i ∈ s, (f i).sets :=\n  ext fun t => by simp [mem_biInf_of_directed h ne]\n\n"}
{"name":"Filter.sup_join","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf₁ f₂ : Filter (Filter α)\n⊢ Eq (Max.max f₁.join f₂.join) (Max.max f₁ f₂).join","decl":"@[simp]\ntheorem sup_join {f₁ f₂ : Filter (Filter α)} : join f₁ ⊔ join f₂ = join (f₁ ⊔ f₂) :=\n  Filter.ext fun x => by simp only [mem_sup, mem_join]\n\n"}
{"name":"Filter.iSup_join","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort w\nf : ι → Filter (Filter α)\n⊢ Eq (iSup fun x => (f x).join) (iSup fun x => f x).join","decl":"@[simp]\ntheorem iSup_join {ι : Sort w} {f : ι → Filter (Filter α)} : ⨆ x, join (f x) = join (⨆ x, f x) :=\n  Filter.ext fun x => by simp only [mem_iSup, mem_join]\n\n"}
{"name":"Filter.iInf_neBot_of_directed'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\ninst✝ : Nonempty ι\nhd : Directed (fun x1 x2 => GE.ge x1 x2) f\na✝ : ∀ (i : ι), (f i).NeBot\n⊢ (iInf f).NeBot","decl":"/-- If `f : ι → Filter α` is directed, `ι` is not empty, and `∀ i, f i ≠ ⊥`, then `iInf f ≠ ⊥`.\nSee also `iInf_neBot_of_directed` for a version assuming `Nonempty α` instead of `Nonempty ι`. -/\ntheorem iInf_neBot_of_directed' {f : ι → Filter α} [Nonempty ι] (hd : Directed (· ≥ ·) f) :\n    (∀ i, NeBot (f i)) → NeBot (iInf f) :=\n  not_imp_not.1 <| by simpa only [not_forall, not_neBot, ← empty_mem_iff_bot,\n    mem_iInf_of_directed hd] using id\n\n"}
{"name":"Filter.iInf_neBot_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\nhn : Nonempty α\nhd : Directed (fun x1 x2 => GE.ge x1 x2) f\nhb : ∀ (i : ι), (f i).NeBot\n⊢ (iInf f).NeBot","decl":"/-- If `f : ι → Filter α` is directed, `α` is not empty, and `∀ i, f i ≠ ⊥`, then `iInf f ≠ ⊥`.\nSee also `iInf_neBot_of_directed'` for a version assuming `Nonempty ι` instead of `Nonempty α`. -/\ntheorem iInf_neBot_of_directed {f : ι → Filter α} [hn : Nonempty α] (hd : Directed (· ≥ ·) f)\n    (hb : ∀ i, NeBot (f i)) : NeBot (iInf f) := by\n  cases isEmpty_or_nonempty ι\n  · constructor\n    simp [iInf_of_empty f, top_ne_bot]\n  · exact iInf_neBot_of_directed' hd hb\n\n"}
{"name":"Filter.sInf_neBot_of_directed'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set (Filter α)\nhne : s.Nonempty\nhd : DirectedOn (fun x1 x2 => GE.ge x1 x2) s\nhbot : Not (Membership.mem s Bot.bot)\n⊢ (InfSet.sInf s).NeBot","decl":"theorem sInf_neBot_of_directed' {s : Set (Filter α)} (hne : s.Nonempty) (hd : DirectedOn (· ≥ ·) s)\n    (hbot : ⊥ ∉ s) : NeBot (sInf s) :=\n  (sInf_eq_iInf' s).symm ▸\n    @iInf_neBot_of_directed' _ _ _ hne.to_subtype hd.directed_val fun ⟨_, hf⟩ =>\n      ⟨ne_of_mem_of_not_mem hf hbot⟩\n\n"}
{"name":"Filter.sInf_neBot_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ninst✝ : Nonempty α\ns : Set (Filter α)\nhd : DirectedOn (fun x1 x2 => GE.ge x1 x2) s\nhbot : Not (Membership.mem s Bot.bot)\n⊢ (InfSet.sInf s).NeBot","decl":"theorem sInf_neBot_of_directed [Nonempty α] {s : Set (Filter α)} (hd : DirectedOn (· ≥ ·) s)\n    (hbot : ⊥ ∉ s) : NeBot (sInf s) :=\n  (sInf_eq_iInf' s).symm ▸\n    iInf_neBot_of_directed hd.directed_val fun ⟨_, hf⟩ => ⟨ne_of_mem_of_not_mem hf hbot⟩\n\n"}
{"name":"Filter.iInf_neBot_iff_of_directed'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\ninst✝ : Nonempty ι\nhd : Directed (fun x1 x2 => GE.ge x1 x2) f\n⊢ Iff (iInf f).NeBot (∀ (i : ι), (f i).NeBot)","decl":"theorem iInf_neBot_iff_of_directed' {f : ι → Filter α} [Nonempty ι] (hd : Directed (· ≥ ·) f) :\n    NeBot (iInf f) ↔ ∀ i, NeBot (f i) :=\n  ⟨fun H i => H.mono (iInf_le _ i), iInf_neBot_of_directed' hd⟩\n\n"}
{"name":"Filter.iInf_neBot_iff_of_directed","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\ninst✝ : Nonempty α\nhd : Directed (fun x1 x2 => GE.ge x1 x2) f\n⊢ Iff (iInf f).NeBot (∀ (i : ι), (f i).NeBot)","decl":"theorem iInf_neBot_iff_of_directed {f : ι → Filter α} [Nonempty α] (hd : Directed (· ≥ ·) f) :\n    NeBot (iInf f) ↔ ∀ i, NeBot (f i) :=\n  ⟨fun H i => H.mono (iInf_le _ i), iInf_neBot_of_directed hd⟩\n\n"}
{"name":"Filter.inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Min.min (Filter.principal s) (Filter.principal t)) (Filter.principal (Inter.inter s t))","decl":"@[simp]\ntheorem inf_principal {s t : Set α} : 𝓟 s ⊓ 𝓟 t = 𝓟 (s ∩ t) :=\n  le_antisymm\n    (by simp only [le_principal_iff, mem_inf_iff]; exact ⟨s, Subset.rfl, t, Subset.rfl, rfl⟩)\n    (by simp [le_inf_iff, inter_subset_left, inter_subset_right])\n\n"}
{"name":"Filter.sup_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Max.max (Filter.principal s) (Filter.principal t)) (Filter.principal (Union.union s t))","decl":"@[simp]\ntheorem sup_principal {s t : Set α} : 𝓟 s ⊔ 𝓟 t = 𝓟 (s ∪ t) :=\n  Filter.ext fun u => by simp only [union_subset_iff, mem_sup, mem_principal]\n\n"}
{"name":"Filter.iSup_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort w\ns : ι → Set α\n⊢ Eq (iSup fun x => Filter.principal (s x)) (Filter.principal (Set.iUnion fun i => s i))","decl":"@[simp]\ntheorem iSup_principal {ι : Sort w} {s : ι → Set α} : ⨆ x, 𝓟 (s x) = 𝓟 (⋃ i, s i) :=\n  Filter.ext fun x => by simp only [mem_iSup, mem_principal, iUnion_subset_iff]\n\n"}
{"name":"Filter.principal_eq_bot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Eq (Filter.principal s) Bot.bot) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem principal_eq_bot_iff {s : Set α} : 𝓟 s = ⊥ ↔ s = ∅ :=\n  empty_mem_iff_bot.symm.trans <| mem_principal.trans subset_empty_iff\n\n"}
{"name":"Filter.principal_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Filter.principal s).NeBot s.Nonempty","decl":"@[simp]\ntheorem principal_neBot_iff {s : Set α} : NeBot (𝓟 s) ↔ s.Nonempty :=\n  neBot_iff.trans <| (not_congr principal_eq_bot_iff).trans nonempty_iff_ne_empty.symm\n\n"}
{"name":"Set.Nonempty.principal_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Nonempty\n⊢ (Filter.principal s).NeBot","decl":"alias ⟨_, _root_.Set.Nonempty.principal_neBot⟩ := principal_neBot_iff\n\n"}
{"name":"Filter.isCompl_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ IsCompl (Filter.principal s) (Filter.principal (HasCompl.compl s))","decl":"theorem isCompl_principal (s : Set α) : IsCompl (𝓟 s) (𝓟 sᶜ) :=\n  IsCompl.of_eq (by rw [inf_principal, inter_compl_self, principal_empty]) <| by\n    rw [sup_principal, union_compl_self, principal_univ]\n\n"}
{"name":"Filter.mem_inf_principal'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns t : Set α\n⊢ Iff (Membership.mem (Min.min f (Filter.principal t)) s) (Membership.mem f (Union.union (HasCompl.compl t) s))","decl":"theorem mem_inf_principal' {f : Filter α} {s t : Set α} : s ∈ f ⊓ 𝓟 t ↔ tᶜ ∪ s ∈ f := by\n  simp only [← le_principal_iff, (isCompl_principal s).le_left_iff, disjoint_assoc, inf_principal,\n    ← (isCompl_principal (t ∩ sᶜ)).le_right_iff, compl_inter, compl_compl]\n\n"}
{"name":"Filter.mem_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns t : Set α\n⊢ Iff (Membership.mem (Min.min f (Filter.principal t)) s) (Membership.mem f (setOf fun x => Membership.mem t x → Membership.mem s x))","decl":"lemma mem_inf_principal {f : Filter α} {s t : Set α} : s ∈ f ⊓ 𝓟 t ↔ { x | x ∈ t → x ∈ s } ∈ f := by\n  simp only [mem_inf_principal', imp_iff_not_or, setOf_or, compl_def, setOf_mem_eq]\n\n"}
{"name":"Filter.iSup_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\ns : Set α\n⊢ Eq (iSup fun i => Min.min (f i) (Filter.principal s)) (Min.min (iSup fun i => f i) (Filter.principal s))","decl":"lemma iSup_inf_principal (f : ι → Filter α) (s : Set α) : ⨆ i, f i ⊓ 𝓟 s = (⨆ i, f i) ⊓ 𝓟 s := by\n  ext\n  simp only [mem_iSup, mem_inf_principal]\n\n"}
{"name":"Filter.inf_principal_eq_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns : Set α\n⊢ Iff (Eq (Min.min f (Filter.principal s)) Bot.bot) (Membership.mem f (HasCompl.compl s))","decl":"theorem inf_principal_eq_bot {f : Filter α} {s : Set α} : f ⊓ 𝓟 s = ⊥ ↔ sᶜ ∈ f := by\n  rw [← empty_mem_iff_bot, mem_inf_principal]\n  simp only [mem_empty_iff_false, imp_false, compl_def]\n\n"}
{"name":"Filter.mem_of_eq_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns : Set α\nh : Eq (Min.min f (Filter.principal (HasCompl.compl s))) Bot.bot\n⊢ Membership.mem f s","decl":"theorem mem_of_eq_bot {f : Filter α} {s : Set α} (h : f ⊓ 𝓟 sᶜ = ⊥) : s ∈ f := by\n  rwa [inf_principal_eq_bot, compl_compl] at h\n\n"}
{"name":"Filter.diff_mem_inf_principal_compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns : Set α\nhs : Membership.mem f s\nt : Set α\n⊢ Membership.mem (Min.min f (Filter.principal (HasCompl.compl t))) (SDiff.sdiff s t)","decl":"theorem diff_mem_inf_principal_compl {f : Filter α} {s : Set α} (hs : s ∈ f) (t : Set α) :\n    s \\ t ∈ f ⊓ 𝓟 tᶜ :=\n  inter_mem_inf hs <| mem_principal_self tᶜ\n\n"}
{"name":"Filter.principal_le_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\nf : Filter α\n⊢ Iff (LE.le (Filter.principal s) f) (∀ (V : Set α), Membership.mem f V → HasSubset.Subset s V)","decl":"theorem principal_le_iff {s : Set α} {f : Filter α} : 𝓟 s ≤ f ↔ ∀ V ∈ f, s ⊆ V := by\n  simp_rw [le_def, mem_principal]\n\n"}
{"name":"Filter.join_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf₁ f₂ : Filter (Filter α)\nh : LE.le f₁ f₂\n⊢ LE.le f₁.join f₂.join","decl":"@[mono, gcongr]\ntheorem join_mono {f₁ f₂ : Filter (Filter α)} (h : f₁ ≤ f₂) : join f₁ ≤ join f₂ := fun _ hs => h hs\n\n"}
{"name":"Filter.eventually_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nP : α → Prop\n⊢ Iff (Filter.Eventually (fun x => P x) f) (Membership.mem f (setOf fun x => P x))","decl":"theorem eventually_iff {f : Filter α} {P : α → Prop} : (∀ᶠ x in f, P x) ↔ { x | P x } ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventually_mem_set","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\nl : Filter α\n⊢ Iff (Filter.Eventually (fun x => Membership.mem s x) l) (Membership.mem l s)","decl":"@[simp]\ntheorem eventually_mem_set {s : Set α} {l : Filter α} : (∀ᶠ x in l, x ∈ s) ↔ s ∈ l :=\n  Iff.rfl\n\n"}
{"name":"Filter.ext'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf₁ f₂ : Filter α\nh : ∀ (p : α → Prop), Iff (Filter.Eventually (fun x => p x) f₁) (Filter.Eventually (fun x => p x) f₂)\n⊢ Eq f₁ f₂","decl":"protected theorem ext' {f₁ f₂ : Filter α}\n    (h : ∀ p : α → Prop, (∀ᶠ x in f₁, p x) ↔ ∀ᶠ x in f₂, p x) : f₁ = f₂ :=\n  Filter.ext h\n\n"}
{"name":"Filter.Eventually.filter_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf₁ f₂ : Filter α\nh : LE.le f₁ f₂\np : α → Prop\nhp : Filter.Eventually (fun x => p x) f₂\n⊢ Filter.Eventually (fun x => p x) f₁","decl":"theorem Eventually.filter_mono {f₁ f₂ : Filter α} (h : f₁ ≤ f₂) {p : α → Prop}\n    (hp : ∀ᶠ x in f₂, p x) : ∀ᶠ x in f₁, p x :=\n  h hp\n\n"}
{"name":"Filter.eventually_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nP : α → Prop\nU : Set α\nhU : Membership.mem f U\nh : ∀ (x : α), Membership.mem U x → P x\n⊢ Filter.Eventually (fun x => P x) f","decl":"theorem eventually_of_mem {f : Filter α} {P : α → Prop} {U : Set α} (hU : U ∈ f)\n    (h : ∀ x ∈ U, P x) : ∀ᶠ x in f, P x :=\n  mem_of_superset hU h\n\n"}
{"name":"Filter.Eventually.and","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np q : α → Prop\nf : Filter α\na✝¹ : Filter.Eventually p f\na✝ : Filter.Eventually q f\n⊢ Filter.Eventually (fun x => And (p x) (q x)) f","decl":"protected theorem Eventually.and {p q : α → Prop} {f : Filter α} :\n    f.Eventually p → f.Eventually q → ∀ᶠ x in f, p x ∧ q x :=\n  inter_mem\n\n"}
{"name":"Filter.eventually_true","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Filter.Eventually (fun x => True) f","decl":"@[simp] theorem eventually_true (f : Filter α) : ∀ᶠ _ in f, True := univ_mem\n\n"}
{"name":"Filter.Eventually.of_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Filter α\nhp : ∀ (x : α), p x\n⊢ Filter.Eventually (fun x => p x) f","decl":"theorem Eventually.of_forall {p : α → Prop} {f : Filter α} (hp : ∀ x, p x) : ∀ᶠ x in f, p x :=\n  univ_mem' hp\n\n"}
{"name":"Filter.eventually_of_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Filter α\nhp : ∀ (x : α), p x\n⊢ Filter.Eventually (fun x => p x) f","decl":"@[deprecated (since := \"2024-08-02\")] alias eventually_of_forall := Eventually.of_forall\n\n"}
{"name":"Filter.eventually_false_iff_eq_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Iff (Filter.Eventually (fun x => False) f) (Eq f Bot.bot)","decl":"@[simp]\ntheorem eventually_false_iff_eq_bot {f : Filter α} : (∀ᶠ _ in f, False) ↔ f = ⊥ :=\n  empty_mem_iff_bot\n\n"}
{"name":"Filter.eventually_const","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nt : f.NeBot\np : Prop\n⊢ Iff (Filter.Eventually (fun x => p) f) p","decl":"@[simp]\ntheorem eventually_const {f : Filter α} [t : NeBot f] {p : Prop} : (∀ᶠ _ in f, p) ↔ p := by\n  by_cases h : p <;> simp [h, t.ne]\n\n"}
{"name":"Filter.eventually_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Filter α\n⊢ Iff (Filter.Eventually (fun x => p x) f) (Exists fun v => And (Membership.mem f v) (∀ (y : α), Membership.mem v y → p y))","decl":"theorem eventually_iff_exists_mem {p : α → Prop} {f : Filter α} :\n    (∀ᶠ x in f, p x) ↔ ∃ v ∈ f, ∀ y ∈ v, p y :=\n  exists_mem_subset_iff.symm\n\n"}
{"name":"Filter.Eventually.exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Filter α\nhp : Filter.Eventually (fun x => p x) f\n⊢ Exists fun v => And (Membership.mem f v) (∀ (y : α), Membership.mem v y → p y)","decl":"theorem Eventually.exists_mem {p : α → Prop} {f : Filter α} (hp : ∀ᶠ x in f, p x) :\n    ∃ v ∈ f, ∀ y ∈ v, p y :=\n  eventually_iff_exists_mem.1 hp\n\n"}
{"name":"Filter.Eventually.mp","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np q : α → Prop\nf : Filter α\nhp : Filter.Eventually (fun x => p x) f\nhq : Filter.Eventually (fun x => p x → q x) f\n⊢ Filter.Eventually (fun x => q x) f","decl":"theorem Eventually.mp {p q : α → Prop} {f : Filter α} (hp : ∀ᶠ x in f, p x)\n    (hq : ∀ᶠ x in f, p x → q x) : ∀ᶠ x in f, q x :=\n  mp_mem hp hq\n\n"}
{"name":"Filter.Eventually.mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np q : α → Prop\nf : Filter α\nhp : Filter.Eventually (fun x => p x) f\nhq : ∀ (x : α), p x → q x\n⊢ Filter.Eventually (fun x => q x) f","decl":"theorem Eventually.mono {p q : α → Prop} {f : Filter α} (hp : ∀ᶠ x in f, p x)\n    (hq : ∀ x, p x → q x) : ∀ᶠ x in f, q x :=\n  hp.mp (Eventually.of_forall hq)\n\n"}
{"name":"Filter.forall_eventually_of_eventually_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\np : α → β → Prop\nh : Filter.Eventually (fun x => ∀ (y : β), p x y) f\ny : β\n⊢ Filter.Eventually (fun x => p x y) f","decl":"theorem forall_eventually_of_eventually_forall {f : Filter α} {p : α → β → Prop}\n    (h : ∀ᶠ x in f, ∀ y, p x y) : ∀ y, ∀ᶠ x in f, p x y :=\n  fun y => h.mono fun _ h => h y\n\n"}
{"name":"Filter.eventually_and","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np q : α → Prop\nf : Filter α\n⊢ Iff (Filter.Eventually (fun x => And (p x) (q x)) f) (And (Filter.Eventually (fun x => p x) f) (Filter.Eventually (fun x => q x) f))","decl":"@[simp]\ntheorem eventually_and {p q : α → Prop} {f : Filter α} :\n    (∀ᶠ x in f, p x ∧ q x) ↔ (∀ᶠ x in f, p x) ∧ ∀ᶠ x in f, q x :=\n  inter_mem_iff\n\n"}
{"name":"Filter.Eventually.congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np q : α → Prop\nh' : Filter.Eventually (fun x => p x) f\nh : Filter.Eventually (fun x => Iff (p x) (q x)) f\n⊢ Filter.Eventually (fun x => q x) f","decl":"theorem Eventually.congr {f : Filter α} {p q : α → Prop} (h' : ∀ᶠ x in f, p x)\n    (h : ∀ᶠ x in f, p x ↔ q x) : ∀ᶠ x in f, q x :=\n  h'.mp (h.mono fun _ hx => hx.mp)\n\n"}
{"name":"Filter.eventually_congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np q : α → Prop\nh : Filter.Eventually (fun x => Iff (p x) (q x)) f\n⊢ Iff (Filter.Eventually (fun x => p x) f) (Filter.Eventually (fun x => q x) f)","decl":"theorem eventually_congr {f : Filter α} {p q : α → Prop} (h : ∀ᶠ x in f, p x ↔ q x) :\n    (∀ᶠ x in f, p x) ↔ ∀ᶠ x in f, q x :=\n  ⟨fun hp => hp.congr h, fun hq => hq.congr <| by simpa only [Iff.comm] using h⟩\n\n"}
{"name":"Filter.eventually_or_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np : Prop\nq : α → Prop\n⊢ Iff (Filter.Eventually (fun x => Or p (q x)) f) (Or p (Filter.Eventually (fun x => q x) f))","decl":"@[simp]\ntheorem eventually_or_distrib_left {f : Filter α} {p : Prop} {q : α → Prop} :\n    (∀ᶠ x in f, p ∨ q x) ↔ p ∨ ∀ᶠ x in f, q x :=\n  by_cases (fun h : p => by simp [h]) fun h => by simp [h]\n\n"}
{"name":"Filter.eventually_or_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np : α → Prop\nq : Prop\n⊢ Iff (Filter.Eventually (fun x => Or (p x) q) f) (Or (Filter.Eventually (fun x => p x) f) q)","decl":"@[simp]\ntheorem eventually_or_distrib_right {f : Filter α} {p : α → Prop} {q : Prop} :\n    (∀ᶠ x in f, p x ∨ q) ↔ (∀ᶠ x in f, p x) ∨ q := by\n  simp only [@or_comm _ q, eventually_or_distrib_left]\n\n"}
{"name":"Filter.eventually_imp_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np : Prop\nq : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p → q x) f) (p → Filter.Eventually (fun x => q x) f)","decl":"theorem eventually_imp_distrib_left {f : Filter α} {p : Prop} {q : α → Prop} :\n    (∀ᶠ x in f, p → q x) ↔ p → ∀ᶠ x in f, q x := by\n  simp only [imp_iff_not_or, eventually_or_distrib_left]\n\n"}
{"name":"Filter.eventually_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Filter.Eventually (fun x => p x) Bot.bot","decl":"@[simp]\ntheorem eventually_bot {p : α → Prop} : ∀ᶠ x in ⊥, p x :=\n  ⟨⟩\n\n"}
{"name":"Filter.eventually_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) Top.top) (∀ (x : α), p x)","decl":"@[simp]\ntheorem eventually_top {p : α → Prop} : (∀ᶠ x in ⊤, p x) ↔ ∀ x, p x :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventually_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf g : Filter α\n⊢ Iff (Filter.Eventually (fun x => p x) (Max.max f g)) (And (Filter.Eventually (fun x => p x) f) (Filter.Eventually (fun x => p x) g))","decl":"@[simp]\ntheorem eventually_sup {p : α → Prop} {f g : Filter α} :\n    (∀ᶠ x in f ⊔ g, p x) ↔ (∀ᶠ x in f, p x) ∧ ∀ᶠ x in g, p x :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventually_sSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nfs : Set (Filter α)\n⊢ Iff (Filter.Eventually (fun x => p x) (SupSet.sSup fs)) (∀ (f : Filter α), Membership.mem fs f → Filter.Eventually (fun x => p x) f)","decl":"@[simp]\ntheorem eventually_sSup {p : α → Prop} {fs : Set (Filter α)} :\n    (∀ᶠ x in sSup fs, p x) ↔ ∀ f ∈ fs, ∀ᶠ x in f, p x :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventually_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nι : Sort x\np : α → Prop\nfs : ι → Filter α\n⊢ Iff (Filter.Eventually (fun x => p x) (iSup fun b => fs b)) (∀ (b : ι), Filter.Eventually (fun x => p x) (fs b))","decl":"@[simp]\ntheorem eventually_iSup {p : α → Prop} {fs : ι → Filter α} :\n    (∀ᶠ x in ⨆ b, fs b, p x) ↔ ∀ b, ∀ᶠ x in fs b, p x :=\n  mem_iSup\n\n"}
{"name":"Filter.eventually_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\na : Set α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (Filter.principal a)) (∀ (x : α), Membership.mem a x → p x)","decl":"@[simp]\ntheorem eventually_principal {a : Set α} {p : α → Prop} : (∀ᶠ x in 𝓟 a, p x) ↔ ∀ x ∈ a, p x :=\n  Iff.rfl\n\n"}
{"name":"Filter.Eventually.forall_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_2\nf : Filter α\ns : Set α\nP : α → Prop\nhP : Filter.Eventually (fun x => P x) f\nhf : LE.le (Filter.principal s) f\nx : α\na✝ : Membership.mem s x\n⊢ P x","decl":"theorem Eventually.forall_mem {α : Type*} {f : Filter α} {s : Set α} {P : α → Prop}\n    (hP : ∀ᶠ x in f, P x) (hf : 𝓟 s ≤ f) : ∀ x ∈ s, P x :=\n  Filter.eventually_principal.mp (hP.filter_mono hf)\n\n"}
{"name":"Filter.eventually_inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : Filter α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (Min.min f g)) (Exists fun s => And (Membership.mem f s) (Exists fun t => And (Membership.mem g t) (∀ (x : α), Membership.mem (Inter.inter s t) x → p x)))","decl":"theorem eventually_inf {f g : Filter α} {p : α → Prop} :\n    (∀ᶠ x in f ⊓ g, p x) ↔ ∃ s ∈ f, ∃ t ∈ g, ∀ x ∈ s ∩ t, p x :=\n  mem_inf_iff_superset\n\n"}
{"name":"Filter.eventually_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np : α → Prop\ns : Set α\n⊢ Iff (Filter.Eventually (fun x => p x) (Min.min f (Filter.principal s))) (Filter.Eventually (fun x => Membership.mem s x → p x) f)","decl":"theorem eventually_inf_principal {f : Filter α} {p : α → Prop} {s : Set α} :\n    (∀ᶠ x in f ⊓ 𝓟 s, p x) ↔ ∀ᶠ x in f, x ∈ s → p x :=\n  mem_inf_principal\n\n"}
{"name":"Filter.eventually_iff_all_subsets","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) f) (∀ (s : Set α), Filter.Eventually (fun x => Membership.mem s x → p x) f)","decl":"theorem eventually_iff_all_subsets {f : Filter α} {p : α → Prop} :\n    (∀ᶠ x in f, p x) ↔ ∀ (s : Set α), ∀ᶠ x in f, x ∈ s → p x where\n  mp h _ := by filter_upwards [h] with _ pa _ using pa\n  mpr h := by filter_upwards [h univ] with _ pa using pa (by simp)\n\n"}
{"name":"Filter.Eventually.frequently","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\np : α → Prop\nh : Filter.Eventually (fun x => p x) f\n⊢ Filter.Frequently (fun x => p x) f","decl":"theorem Eventually.frequently {f : Filter α} [NeBot f] {p : α → Prop} (h : ∀ᶠ x in f, p x) :\n    ∃ᶠ x in f, p x :=\n  compl_not_mem h\n\n"}
{"name":"Filter.Frequently.of_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\np : α → Prop\nh : ∀ (x : α), p x\n⊢ Filter.Frequently (fun x => p x) f","decl":"theorem Frequently.of_forall {f : Filter α} [NeBot f] {p : α → Prop} (h : ∀ x, p x) :\n    ∃ᶠ x in f, p x :=\n  Eventually.frequently (Eventually.of_forall h)\n\n"}
{"name":"Filter.frequently_of_forall","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\np : α → Prop\nh : ∀ (x : α), p x\n⊢ Filter.Frequently (fun x => p x) f","decl":"@[deprecated (since := \"2024-08-02\")] alias frequently_of_forall := Frequently.of_forall\n\n"}
{"name":"Filter.Frequently.mp","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np q : α → Prop\nf : Filter α\nh : Filter.Frequently (fun x => p x) f\nhpq : Filter.Eventually (fun x => p x → q x) f\n⊢ Filter.Frequently (fun x => q x) f","decl":"theorem Frequently.mp {p q : α → Prop} {f : Filter α} (h : ∃ᶠ x in f, p x)\n    (hpq : ∀ᶠ x in f, p x → q x) : ∃ᶠ x in f, q x :=\n  mt (fun hq => hq.mp <| hpq.mono fun _ => mt) h\n\n"}
{"name":"Filter.frequently_congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np q : α → Prop\nf : Filter α\nh : Filter.Eventually (fun x => Iff (p x) (q x)) f\n⊢ Iff (Filter.Frequently (fun x => p x) f) (Filter.Frequently (fun x => q x) f)","decl":"lemma frequently_congr {p q : α → Prop} {f : Filter α} (h : ∀ᶠ x in f, p x ↔ q x) :\n    (∃ᶠ x in f, p x) ↔ ∃ᶠ x in f, q x :=\n  ⟨fun h' ↦ h'.mp (h.mono fun _ ↦ Iff.mp), fun h' ↦ h'.mp (h.mono fun _ ↦ Iff.mpr)⟩\n\n"}
{"name":"Filter.Frequently.filter_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf g : Filter α\nh : Filter.Frequently (fun x => p x) f\nhle : LE.le f g\n⊢ Filter.Frequently (fun x => p x) g","decl":"theorem Frequently.filter_mono {p : α → Prop} {f g : Filter α} (h : ∃ᶠ x in f, p x) (hle : f ≤ g) :\n    ∃ᶠ x in g, p x :=\n  mt (fun h' => h'.filter_mono hle) h\n\n"}
{"name":"Filter.Frequently.mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np q : α → Prop\nf : Filter α\nh : Filter.Frequently (fun x => p x) f\nhpq : ∀ (x : α), p x → q x\n⊢ Filter.Frequently (fun x => q x) f","decl":"theorem Frequently.mono {p q : α → Prop} {f : Filter α} (h : ∃ᶠ x in f, p x)\n    (hpq : ∀ x, p x → q x) : ∃ᶠ x in f, q x :=\n  h.mp (Eventually.of_forall hpq)\n\n"}
{"name":"Filter.Frequently.and_eventually","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np q : α → Prop\nf : Filter α\nhp : Filter.Frequently (fun x => p x) f\nhq : Filter.Eventually (fun x => q x) f\n⊢ Filter.Frequently (fun x => And (p x) (q x)) f","decl":"theorem Frequently.and_eventually {p q : α → Prop} {f : Filter α} (hp : ∃ᶠ x in f, p x)\n    (hq : ∀ᶠ x in f, q x) : ∃ᶠ x in f, p x ∧ q x := by\n  refine mt (fun h => hq.mp <| h.mono ?_) hp\n  exact fun x hpq hq hp => hpq ⟨hp, hq⟩\n\n"}
{"name":"Filter.Eventually.and_frequently","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np q : α → Prop\nf : Filter α\nhp : Filter.Eventually (fun x => p x) f\nhq : Filter.Frequently (fun x => q x) f\n⊢ Filter.Frequently (fun x => And (p x) (q x)) f","decl":"theorem Eventually.and_frequently {p q : α → Prop} {f : Filter α} (hp : ∀ᶠ x in f, p x)\n    (hq : ∃ᶠ x in f, q x) : ∃ᶠ x in f, p x ∧ q x := by\n  simpa only [and_comm] using hq.and_eventually hp\n\n"}
{"name":"Filter.Frequently.exists","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Filter α\nhp : Filter.Frequently (fun x => p x) f\n⊢ Exists fun x => p x","decl":"theorem Frequently.exists {p : α → Prop} {f : Filter α} (hp : ∃ᶠ x in f, p x) : ∃ x, p x := by\n  by_contra H\n  replace H : ∀ᶠ x in f, ¬p x := Eventually.of_forall (not_exists.1 H)\n  exact hp H\n\n"}
{"name":"Filter.Eventually.exists","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Filter α\ninst✝ : f.NeBot\nhp : Filter.Eventually (fun x => p x) f\n⊢ Exists fun x => p x","decl":"theorem Eventually.exists {p : α → Prop} {f : Filter α} [NeBot f] (hp : ∀ᶠ x in f, p x) :\n    ∃ x, p x :=\n  hp.frequently.exists\n\n"}
{"name":"Filter.frequently_iff_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nl : Filter α\np : α → Prop\n⊢ Iff (Filter.Frequently (fun x => p x) l) (Min.min l (Filter.principal (setOf fun x => p x))).NeBot","decl":"lemma frequently_iff_neBot {l : Filter α} {p : α → Prop} :\n    (∃ᶠ x in l, p x) ↔ NeBot (l ⊓ 𝓟 {x | p x}) := by\n  rw [neBot_iff, Ne, inf_principal_eq_bot]; rfl\n\n"}
{"name":"Filter.frequently_mem_iff_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nl : Filter α\ns : Set α\n⊢ Iff (Filter.Frequently (fun x => Membership.mem s x) l) (Min.min l (Filter.principal s)).NeBot","decl":"lemma frequently_mem_iff_neBot {l : Filter α} {s : Set α} : (∃ᶠ x in l, x ∈ s) ↔ NeBot (l ⊓ 𝓟 s) :=\n  frequently_iff_neBot\n\n"}
{"name":"Filter.frequently_iff_forall_eventually_exists_and","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Filter α\n⊢ Iff (Filter.Frequently (fun x => p x) f) (∀ {q : α → Prop}, Filter.Eventually (fun x => q x) f → Exists fun x => And (p x) (q x))","decl":"theorem frequently_iff_forall_eventually_exists_and {p : α → Prop} {f : Filter α} :\n    (∃ᶠ x in f, p x) ↔ ∀ {q : α → Prop}, (∀ᶠ x in f, q x) → ∃ x, p x ∧ q x :=\n  ⟨fun hp _ hq => (hp.and_eventually hq).exists, fun H hp => by\n    simpa only [and_not_self_iff, exists_false] using H hp⟩\n\n"}
{"name":"Filter.frequently_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nP : α → Prop\n⊢ Iff (Filter.Frequently (fun x => P x) f) (∀ {U : Set α}, Membership.mem f U → Exists fun x => And (Membership.mem U x) (P x))","decl":"theorem frequently_iff {f : Filter α} {P : α → Prop} :\n    (∃ᶠ x in f, P x) ↔ ∀ {U}, U ∈ f → ∃ x ∈ U, P x := by\n  simp only [frequently_iff_forall_eventually_exists_and, @and_comm (P _)]\n  rfl\n\n"}
{"name":"Filter.not_eventually","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Filter α\n⊢ Iff (Not (Filter.Eventually (fun x => p x) f)) (Filter.Frequently (fun x => Not (p x)) f)","decl":"@[simp]\ntheorem not_eventually {p : α → Prop} {f : Filter α} : (¬∀ᶠ x in f, p x) ↔ ∃ᶠ x in f, ¬p x := by\n  simp [Filter.Frequently]\n\n"}
{"name":"Filter.not_frequently","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Filter α\n⊢ Iff (Not (Filter.Frequently (fun x => p x) f)) (Filter.Eventually (fun x => Not (p x)) f)","decl":"@[simp]\ntheorem not_frequently {p : α → Prop} {f : Filter α} : (¬∃ᶠ x in f, p x) ↔ ∀ᶠ x in f, ¬p x := by\n  simp only [Filter.Frequently, not_not]\n\n"}
{"name":"Filter.frequently_true_iff_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Iff (Filter.Frequently (fun x => True) f) f.NeBot","decl":"@[simp]\ntheorem frequently_true_iff_neBot (f : Filter α) : (∃ᶠ _ in f, True) ↔ NeBot f := by\n  simp [frequently_iff_neBot]\n\n"}
{"name":"Filter.frequently_false","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Not (Filter.Frequently (fun x => False) f)","decl":"@[simp]\ntheorem frequently_false (f : Filter α) : ¬∃ᶠ _ in f, False := by simp\n\n"}
{"name":"Filter.frequently_const","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\np : Prop\n⊢ Iff (Filter.Frequently (fun x => p) f) p","decl":"@[simp]\ntheorem frequently_const {f : Filter α} [NeBot f] {p : Prop} : (∃ᶠ _ in f, p) ↔ p := by\n  by_cases p <;> simp [*]\n\n"}
{"name":"Filter.frequently_or_distrib","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np q : α → Prop\n⊢ Iff (Filter.Frequently (fun x => Or (p x) (q x)) f) (Or (Filter.Frequently (fun x => p x) f) (Filter.Frequently (fun x => q x) f))","decl":"@[simp]\ntheorem frequently_or_distrib {f : Filter α} {p q : α → Prop} :\n    (∃ᶠ x in f, p x ∨ q x) ↔ (∃ᶠ x in f, p x) ∨ ∃ᶠ x in f, q x := by\n  simp only [Filter.Frequently, ← not_and_or, not_or, eventually_and]\n\n"}
{"name":"Filter.frequently_or_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\np : Prop\nq : α → Prop\n⊢ Iff (Filter.Frequently (fun x => Or p (q x)) f) (Or p (Filter.Frequently (fun x => q x) f))","decl":"theorem frequently_or_distrib_left {f : Filter α} [NeBot f] {p : Prop} {q : α → Prop} :\n    (∃ᶠ x in f, p ∨ q x) ↔ p ∨ ∃ᶠ x in f, q x := by simp\n\n"}
{"name":"Filter.frequently_or_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\np : α → Prop\nq : Prop\n⊢ Iff (Filter.Frequently (fun x => Or (p x) q) f) (Or (Filter.Frequently (fun x => p x) f) q)","decl":"theorem frequently_or_distrib_right {f : Filter α} [NeBot f] {p : α → Prop} {q : Prop} :\n    (∃ᶠ x in f, p x ∨ q) ↔ (∃ᶠ x in f, p x) ∨ q := by simp\n\n"}
{"name":"Filter.frequently_imp_distrib","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np q : α → Prop\n⊢ Iff (Filter.Frequently (fun x => p x → q x) f) (Filter.Eventually (fun x => p x) f → Filter.Frequently (fun x => q x) f)","decl":"theorem frequently_imp_distrib {f : Filter α} {p q : α → Prop} :\n    (∃ᶠ x in f, p x → q x) ↔ (∀ᶠ x in f, p x) → ∃ᶠ x in f, q x := by\n  simp [imp_iff_not_or]\n\n"}
{"name":"Filter.frequently_imp_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\np : Prop\nq : α → Prop\n⊢ Iff (Filter.Frequently (fun x => p → q x) f) (p → Filter.Frequently (fun x => q x) f)","decl":"theorem frequently_imp_distrib_left {f : Filter α} [NeBot f] {p : Prop} {q : α → Prop} :\n    (∃ᶠ x in f, p → q x) ↔ p → ∃ᶠ x in f, q x := by simp [frequently_imp_distrib]\n\n"}
{"name":"Filter.frequently_imp_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ninst✝ : f.NeBot\np : α → Prop\nq : Prop\n⊢ Iff (Filter.Frequently (fun x => p x → q) f) (Filter.Eventually (fun x => p x) f → q)","decl":"theorem frequently_imp_distrib_right {f : Filter α} [NeBot f] {p : α → Prop} {q : Prop} :\n    (∃ᶠ x in f, p x → q) ↔ (∀ᶠ x in f, p x) → q := by\n  simp only [frequently_imp_distrib, frequently_const]\n\n"}
{"name":"Filter.eventually_imp_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np : α → Prop\nq : Prop\n⊢ Iff (Filter.Eventually (fun x => p x → q) f) (Filter.Frequently (fun x => p x) f → q)","decl":"theorem eventually_imp_distrib_right {f : Filter α} {p : α → Prop} {q : Prop} :\n    (∀ᶠ x in f, p x → q) ↔ (∃ᶠ x in f, p x) → q := by\n  simp only [imp_iff_not_or, eventually_or_distrib_right, not_frequently]\n\n"}
{"name":"Filter.frequently_and_distrib_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np : Prop\nq : α → Prop\n⊢ Iff (Filter.Frequently (fun x => And p (q x)) f) (And p (Filter.Frequently (fun x => q x) f))","decl":"@[simp]\ntheorem frequently_and_distrib_left {f : Filter α} {p : Prop} {q : α → Prop} :\n    (∃ᶠ x in f, p ∧ q x) ↔ p ∧ ∃ᶠ x in f, q x := by\n  simp only [Filter.Frequently, not_and, eventually_imp_distrib_left, Classical.not_imp]\n\n"}
{"name":"Filter.frequently_and_distrib_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\np : α → Prop\nq : Prop\n⊢ Iff (Filter.Frequently (fun x => And (p x) q) f) (And (Filter.Frequently (fun x => p x) f) q)","decl":"@[simp]\ntheorem frequently_and_distrib_right {f : Filter α} {p : α → Prop} {q : Prop} :\n    (∃ᶠ x in f, p x ∧ q) ↔ (∃ᶠ x in f, p x) ∧ q := by\n  simp only [@and_comm _ q, frequently_and_distrib_left]\n\n"}
{"name":"Filter.frequently_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Not (Filter.Frequently (fun x => p x) Bot.bot)","decl":"@[simp]\ntheorem frequently_bot {p : α → Prop} : ¬∃ᶠ x in ⊥, p x := by simp\n\n"}
{"name":"Filter.frequently_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\n⊢ Iff (Filter.Frequently (fun x => p x) Top.top) (Exists fun x => p x)","decl":"@[simp]\ntheorem frequently_top {p : α → Prop} : (∃ᶠ x in ⊤, p x) ↔ ∃ x, p x := by simp [Filter.Frequently]\n\n"}
{"name":"Filter.frequently_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\na : Set α\np : α → Prop\n⊢ Iff (Filter.Frequently (fun x => p x) (Filter.principal a)) (Exists fun x => And (Membership.mem a x) (p x))","decl":"@[simp]\ntheorem frequently_principal {a : Set α} {p : α → Prop} : (∃ᶠ x in 𝓟 a, p x) ↔ ∃ x ∈ a, p x := by\n  simp [Filter.Frequently, not_forall]\n\n"}
{"name":"Filter.frequently_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns : Set α\np : α → Prop\n⊢ Iff (Filter.Frequently (fun x => p x) (Min.min f (Filter.principal s))) (Filter.Frequently (fun x => And (Membership.mem s x) (p x)) f)","decl":"theorem frequently_inf_principal {f : Filter α} {s : Set α} {p : α → Prop} :\n    (∃ᶠ x in f ⊓ 𝓟 s, p x) ↔ ∃ᶠ x in f, x ∈ s ∧ p x := by\n  simp only [Filter.Frequently, eventually_inf_principal, not_and]\n\n"}
{"name":"Filter.Frequently.inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns : Set α\np : α → Prop\na✝ : Filter.Frequently (fun x => And (Membership.mem s x) (p x)) f\n⊢ Filter.Frequently (fun x => p x) (Min.min f (Filter.principal s))","decl":"alias ⟨Frequently.of_inf_principal, Frequently.inf_principal⟩ := frequently_inf_principal\n\n"}
{"name":"Filter.Frequently.of_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\ns : Set α\np : α → Prop\na✝ : Filter.Frequently (fun x => p x) (Min.min f (Filter.principal s))\n⊢ Filter.Frequently (fun x => And (Membership.mem s x) (p x)) f","decl":"alias ⟨Frequently.of_inf_principal, Frequently.inf_principal⟩ := frequently_inf_principal\n\n"}
{"name":"Filter.frequently_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nf g : Filter α\n⊢ Iff (Filter.Frequently (fun x => p x) (Max.max f g)) (Or (Filter.Frequently (fun x => p x) f) (Filter.Frequently (fun x => p x) g))","decl":"theorem frequently_sup {p : α → Prop} {f g : Filter α} :\n    (∃ᶠ x in f ⊔ g, p x) ↔ (∃ᶠ x in f, p x) ∨ ∃ᶠ x in g, p x := by\n  simp only [Filter.Frequently, eventually_sup, not_and_or]\n\n"}
{"name":"Filter.frequently_sSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\np : α → Prop\nfs : Set (Filter α)\n⊢ Iff (Filter.Frequently (fun x => p x) (SupSet.sSup fs)) (Exists fun f => And (Membership.mem fs f) (Filter.Frequently (fun x => p x) f))","decl":"@[simp]\ntheorem frequently_sSup {p : α → Prop} {fs : Set (Filter α)} :\n    (∃ᶠ x in sSup fs, p x) ↔ ∃ f ∈ fs, ∃ᶠ x in f, p x := by\n  simp only [Filter.Frequently, not_forall, eventually_sSup, exists_prop]\n\n"}
{"name":"Filter.frequently_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\np : α → Prop\nfs : β → Filter α\n⊢ Iff (Filter.Frequently (fun x => p x) (iSup fun b => fs b)) (Exists fun b => Filter.Frequently (fun x => p x) (fs b))","decl":"@[simp]\ntheorem frequently_iSup {p : α → Prop} {fs : β → Filter α} :\n    (∃ᶠ x in ⨆ b, fs b, p x) ↔ ∃ b, ∃ᶠ x in fs b, p x := by\n  simp only [Filter.Frequently, eventually_iSup, not_forall]\n\n"}
{"name":"Filter.Eventually.choice","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nr : α → β → Prop\nl : Filter α\ninst✝ : l.NeBot\nh : Filter.Eventually (fun x => Exists fun y => r x y) l\n⊢ Exists fun f => Filter.Eventually (fun x => r x (f x)) l","decl":"theorem Eventually.choice {r : α → β → Prop} {l : Filter α} [l.NeBot] (h : ∀ᶠ x in l, ∃ y, r x y) :\n    ∃ f : α → β, ∀ᶠ x in l, r x (f x) := by\n  haveI : Nonempty β := let ⟨_, hx⟩ := h.exists; hx.nonempty\n  choose! f hf using fun x (hx : ∃ y, r x y) => hx\n  exact ⟨f, h.mono hf⟩\n\n"}
{"name":"Filter.skolem","module":"Mathlib.Order.Filter.Basic","initialProofState":"ι : Type u_2\nα : ι → Type u_3\ninst✝ : ∀ (i : ι), Nonempty (α i)\nP : (i : ι) → α i → Prop\nF : Filter ι\n⊢ Iff (Filter.Eventually (fun i => Exists fun b => P i b) F) (Exists fun b => Filter.Eventually (fun i => P i (b i)) F)","decl":"lemma skolem {ι : Type*} {α : ι → Type*} [∀ i, Nonempty (α i)]\n    {P : ∀ i : ι, α i → Prop} {F : Filter ι} :\n    (∀ᶠ i in F, ∃ b, P i b) ↔ ∃ b : (Π i, α i), ∀ᶠ i in F, P i (b i) := by\n  classical\n  refine ⟨fun H ↦ ?_, fun ⟨b, hb⟩ ↦ hb.mp (.of_forall fun x a ↦ ⟨_, a⟩)⟩\n  refine ⟨fun i ↦ if h : ∃ b, P i b then h.choose else Nonempty.some inferInstance, ?_⟩\n  filter_upwards [H] with i hi\n  exact dif_pos hi ▸ hi.choose_spec\n\n"}
{"name":"Filter.EventuallyEq.eventually","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g : α → β\nh : l.EventuallyEq f g\n⊢ Filter.Eventually (fun x => Eq (f x) (g x)) l","decl":"theorem EventuallyEq.eventually (h : f =ᶠ[l] g) : ∀ᶠ x in l, f x = g x := h\n\n"}
{"name":"Filter.eventuallyEq_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : α → β\n⊢ Iff (Top.top.EventuallyEq f g) (Eq f g)","decl":"@[simp] lemma eventuallyEq_top : f =ᶠ[⊤] g ↔ f = g := by simp [EventuallyEq, funext_iff]\n\n"}
{"name":"Filter.EventuallyEq.rw","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g : α → β\nh : l.EventuallyEq f g\np : α → β → Prop\nhf : Filter.Eventually (fun x => p x (f x)) l\n⊢ Filter.Eventually (fun x => p x (g x)) l","decl":"theorem EventuallyEq.rw {l : Filter α} {f g : α → β} (h : f =ᶠ[l] g) (p : α → β → Prop)\n    (hf : ∀ᶠ x in l, p x (f x)) : ∀ᶠ x in l, p x (g x) :=\n  hf.congr <| h.mono fun _ hx => hx ▸ Iff.rfl\n\n"}
{"name":"Filter.eventuallyEq_set","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\n⊢ Iff (l.EventuallyEq s t) (Filter.Eventually (fun x => Iff (Membership.mem s x) (Membership.mem t x)) l)","decl":"theorem eventuallyEq_set {s t : Set α} {l : Filter α} : s =ᶠ[l] t ↔ ∀ᶠ x in l, x ∈ s ↔ x ∈ t :=\n  eventually_congr <| Eventually.of_forall fun _ ↦ eq_iff_iff\n\n"}
{"name":"Filter.Eventually.set_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\na✝ : Filter.Eventually (fun x => Iff (Membership.mem s x) (Membership.mem t x)) l\n⊢ l.EventuallyEq s t","decl":"alias ⟨EventuallyEq.mem_iff, Eventually.set_eq⟩ := eventuallyEq_set\n\n"}
{"name":"Filter.EventuallyEq.mem_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\na✝ : l.EventuallyEq s t\n⊢ Filter.Eventually (fun x => Iff (Membership.mem s x) (Membership.mem t x)) l","decl":"alias ⟨EventuallyEq.mem_iff, Eventually.set_eq⟩ := eventuallyEq_set\n\n"}
{"name":"Filter.eventuallyEq_univ","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\nl : Filter α\n⊢ Iff (l.EventuallyEq s Set.univ) (Membership.mem l s)","decl":"@[simp]\ntheorem eventuallyEq_univ {s : Set α} {l : Filter α} : s =ᶠ[l] univ ↔ s ∈ l := by\n  simp [eventuallyEq_set]\n\n"}
{"name":"Filter.EventuallyEq.exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g : α → β\nh : l.EventuallyEq f g\n⊢ Exists fun s => And (Membership.mem l s) (Set.EqOn f g s)","decl":"theorem EventuallyEq.exists_mem {l : Filter α} {f g : α → β} (h : f =ᶠ[l] g) :\n    ∃ s ∈ l, EqOn f g s :=\n  Eventually.exists_mem h\n\n"}
{"name":"Filter.eventuallyEq_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g : α → β\ns : Set α\nhs : Membership.mem l s\nh : Set.EqOn f g s\n⊢ l.EventuallyEq f g","decl":"theorem eventuallyEq_of_mem {l : Filter α} {f g : α → β} {s : Set α} (hs : s ∈ l) (h : EqOn f g s) :\n    f =ᶠ[l] g :=\n  eventually_of_mem hs h\n\n"}
{"name":"Filter.eventuallyEq_iff_exists_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g : α → β\n⊢ Iff (l.EventuallyEq f g) (Exists fun s => And (Membership.mem l s) (Set.EqOn f g s))","decl":"theorem eventuallyEq_iff_exists_mem {l : Filter α} {f g : α → β} :\n    f =ᶠ[l] g ↔ ∃ s ∈ l, EqOn f g s :=\n  eventually_iff_exists_mem\n\n"}
{"name":"Filter.EventuallyEq.filter_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl l' : Filter α\nf g : α → β\nh₁ : l.EventuallyEq f g\nh₂ : LE.le l' l\n⊢ l'.EventuallyEq f g","decl":"theorem EventuallyEq.filter_mono {l l' : Filter α} {f g : α → β} (h₁ : f =ᶠ[l] g) (h₂ : l' ≤ l) :\n    f =ᶠ[l'] g :=\n  h₂ h₁\n\n"}
{"name":"Filter.EventuallyEq.refl","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf : α → β\n⊢ l.EventuallyEq f f","decl":"@[refl, simp]\ntheorem EventuallyEq.refl (l : Filter α) (f : α → β) : f =ᶠ[l] f :=\n  Eventually.of_forall fun _ => rfl\n\n"}
{"name":"Filter.EventuallyEq.rfl","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf : α → β\n⊢ l.EventuallyEq f f","decl":"protected theorem EventuallyEq.rfl {l : Filter α} {f : α → β} : f =ᶠ[l] f :=\n  EventuallyEq.refl l f\n\n"}
{"name":"Filter.EventuallyEq.of_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g : α → β\nh : Eq f g\n⊢ l.EventuallyEq f g","decl":"theorem EventuallyEq.of_eq {l : Filter α} {f g : α → β} (h : f = g) : f =ᶠ[l] g := h ▸ .rfl\n"}
{"name":"Eq.eventuallyEq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g : α → β\nh : Eq f g\n⊢ l.EventuallyEq f g","decl":"alias _root_.Eq.eventuallyEq := EventuallyEq.of_eq\n\n"}
{"name":"Filter.EventuallyEq.symm","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : α → β\nl : Filter α\nH : l.EventuallyEq f g\n⊢ l.EventuallyEq g f","decl":"@[symm]\ntheorem EventuallyEq.symm {f g : α → β} {l : Filter α} (H : f =ᶠ[l] g) : g =ᶠ[l] f :=\n  H.mono fun _ => Eq.symm\n\n"}
{"name":"Filter.eventuallyEq_comm","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : α → β\nl : Filter α\n⊢ Iff (l.EventuallyEq f g) (l.EventuallyEq g f)","decl":"lemma eventuallyEq_comm {f g : α → β} {l : Filter α} : f =ᶠ[l] g ↔ g =ᶠ[l] f := ⟨.symm, .symm⟩\n\n"}
{"name":"Filter.EventuallyEq.trans","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g h : α → β\nH₁ : l.EventuallyEq f g\nH₂ : l.EventuallyEq g h\n⊢ l.EventuallyEq f h","decl":"@[trans]\ntheorem EventuallyEq.trans {l : Filter α} {f g h : α → β} (H₁ : f =ᶠ[l] g) (H₂ : g =ᶠ[l] h) :\n    f =ᶠ[l] h :=\n  H₂.rw (fun x y => f x = y) H₁\n\n"}
{"name":"Filter.EventuallyEq.congr_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g h : α → β\nH : l.EventuallyEq f g\n⊢ Iff (l.EventuallyEq f h) (l.EventuallyEq g h)","decl":"theorem EventuallyEq.congr_left {l : Filter α} {f g h : α → β} (H : f =ᶠ[l] g) :\n    f =ᶠ[l] h ↔ g =ᶠ[l] h :=\n  ⟨H.symm.trans, H.trans⟩\n\n"}
{"name":"Filter.EventuallyEq.congr_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g h : α → β\nH : l.EventuallyEq g h\n⊢ Iff (l.EventuallyEq f g) (l.EventuallyEq f h)","decl":"theorem EventuallyEq.congr_right {l : Filter α} {f g h : α → β} (H : g =ᶠ[l] h) :\n    f =ᶠ[l] g ↔ f =ᶠ[l] h :=\n  ⟨(·.trans H), (·.trans H.symm)⟩\n\n"}
{"name":"Filter.EventuallyEq.prod_mk","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nl : Filter α\nf f' : α → β\nhf : l.EventuallyEq f f'\ng g' : α → γ\nhg : l.EventuallyEq g g'\n⊢ l.EventuallyEq (fun x => { fst := f x, snd := g x }) fun x => { fst := f' x, snd := g' x }","decl":"theorem EventuallyEq.prod_mk {l} {f f' : α → β} (hf : f =ᶠ[l] f') {g g' : α → γ} (hg : g =ᶠ[l] g') :\n    (fun x => (f x, g x)) =ᶠ[l] fun x => (f' x, g' x) :=\n  hf.mp <|\n    hg.mono <| by\n      intros\n      simp only [*]\n\n-- See `EventuallyEq.comp_tendsto` further below for a similar statement w.r.t.\n-- composition on the right.\n"}
{"name":"Filter.EventuallyEq.fun_comp","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf g : α → β\nl : Filter α\nH : l.EventuallyEq f g\nh : β → γ\n⊢ l.EventuallyEq (Function.comp h f) (Function.comp h g)","decl":"theorem EventuallyEq.fun_comp {f g : α → β} {l : Filter α} (H : f =ᶠ[l] g) (h : β → γ) :\n    h ∘ f =ᶠ[l] h ∘ g :=\n  H.mono fun _ hx => congr_arg h hx\n\n"}
{"name":"Filter.EventuallyEq.comp₂","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_2\nf f' : α → β\ng g' : α → γ\nl : Filter α\nHf : l.EventuallyEq f f'\nh : β → γ → δ\nHg : l.EventuallyEq g g'\n⊢ l.EventuallyEq (fun x => h (f x) (g x)) fun x => h (f' x) (g' x)","decl":"theorem EventuallyEq.comp₂ {δ} {f f' : α → β} {g g' : α → γ} {l} (Hf : f =ᶠ[l] f') (h : β → γ → δ)\n    (Hg : g =ᶠ[l] g') : (fun x => h (f x) (g x)) =ᶠ[l] fun x => h (f' x) (g' x) :=\n  (Hf.prod_mk Hg).fun_comp (uncurry h)\n\n"}
{"name":"Filter.EventuallyEq.add","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Add β\nf f' g g' : α → β\nl : Filter α\nh : l.EventuallyEq f g\nh' : l.EventuallyEq f' g'\n⊢ l.EventuallyEq (fun x => HAdd.hAdd (f x) (f' x)) fun x => HAdd.hAdd (g x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.mul [Mul β] {f f' g g' : α → β} {l : Filter α} (h : f =ᶠ[l] g)\n    (h' : f' =ᶠ[l] g') : (fun x => f x * f' x) =ᶠ[l] fun x => g x * g' x :=\n  h.comp₂ (· * ·) h'\n\n"}
{"name":"Filter.EventuallyEq.mul","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Mul β\nf f' g g' : α → β\nl : Filter α\nh : l.EventuallyEq f g\nh' : l.EventuallyEq f' g'\n⊢ l.EventuallyEq (fun x => HMul.hMul (f x) (f' x)) fun x => HMul.hMul (g x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.mul [Mul β] {f f' g g' : α → β} {l : Filter α} (h : f =ᶠ[l] g)\n    (h' : f' =ᶠ[l] g') : (fun x => f x * f' x) =ᶠ[l] fun x => g x * g' x :=\n  h.comp₂ (· * ·) h'\n\n"}
{"name":"Filter.EventuallyEq.pow_const","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_2\ninst✝ : Pow β γ\nf g : α → β\nl : Filter α\nh : l.EventuallyEq f g\nc : γ\n⊢ l.EventuallyEq (fun x => HPow.hPow (f x) c) fun x => HPow.hPow (g x) c","decl":"@[to_additive const_smul]\ntheorem EventuallyEq.pow_const {γ} [Pow β γ] {f g : α → β} {l : Filter α} (h : f =ᶠ[l] g) (c : γ) :\n    (fun x => f x ^ c) =ᶠ[l] fun x => g x ^ c :=\n  h.fun_comp (· ^ c)\n\n"}
{"name":"Filter.EventuallyEq.const_smul","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_2\ninst✝ : SMul γ β\nf g : α → β\nl : Filter α\nh : l.EventuallyEq f g\nc : γ\n⊢ l.EventuallyEq (fun x => HSMul.hSMul c (f x)) fun x => HSMul.hSMul c (g x)","decl":"@[to_additive const_smul]\ntheorem EventuallyEq.pow_const {γ} [Pow β γ] {f g : α → β} {l : Filter α} (h : f =ᶠ[l] g) (c : γ) :\n    (fun x => f x ^ c) =ᶠ[l] fun x => g x ^ c :=\n  h.fun_comp (· ^ c)\n\n"}
{"name":"Filter.EventuallyEq.neg","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Neg β\nf g : α → β\nl : Filter α\nh : l.EventuallyEq f g\n⊢ l.EventuallyEq (fun x => Neg.neg (f x)) fun x => Neg.neg (g x)","decl":"@[to_additive]\ntheorem EventuallyEq.inv [Inv β] {f g : α → β} {l : Filter α} (h : f =ᶠ[l] g) :\n    (fun x => (f x)⁻¹) =ᶠ[l] fun x => (g x)⁻¹ :=\n  h.fun_comp Inv.inv\n\n"}
{"name":"Filter.EventuallyEq.inv","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Inv β\nf g : α → β\nl : Filter α\nh : l.EventuallyEq f g\n⊢ l.EventuallyEq (fun x => Inv.inv (f x)) fun x => Inv.inv (g x)","decl":"@[to_additive]\ntheorem EventuallyEq.inv [Inv β] {f g : α → β} {l : Filter α} (h : f =ᶠ[l] g) :\n    (fun x => (f x)⁻¹) =ᶠ[l] fun x => (g x)⁻¹ :=\n  h.fun_comp Inv.inv\n\n"}
{"name":"Filter.EventuallyEq.div","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Div β\nf f' g g' : α → β\nl : Filter α\nh : l.EventuallyEq f g\nh' : l.EventuallyEq f' g'\n⊢ l.EventuallyEq (fun x => HDiv.hDiv (f x) (f' x)) fun x => HDiv.hDiv (g x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.div [Div β] {f f' g g' : α → β} {l : Filter α} (h : f =ᶠ[l] g)\n    (h' : f' =ᶠ[l] g') : (fun x => f x / f' x) =ᶠ[l] fun x => g x / g' x :=\n  h.comp₂ (· / ·) h'\n\n"}
{"name":"Filter.EventuallyEq.sub","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Sub β\nf f' g g' : α → β\nl : Filter α\nh : l.EventuallyEq f g\nh' : l.EventuallyEq f' g'\n⊢ l.EventuallyEq (fun x => HSub.hSub (f x) (f' x)) fun x => HSub.hSub (g x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.div [Div β] {f f' g g' : α → β} {l : Filter α} (h : f =ᶠ[l] g)\n    (h' : f' =ᶠ[l] g') : (fun x => f x / f' x) =ᶠ[l] fun x => g x / g' x :=\n  h.comp₂ (· / ·) h'\n\n"}
{"name":"Filter.EventuallyEq.const_vadd","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_2\ninst✝ : VAdd γ β\nf g : α → β\nl : Filter α\nh : l.EventuallyEq f g\nc : γ\n⊢ l.EventuallyEq (fun x => HVAdd.hVAdd c (f x)) fun x => HVAdd.hVAdd c (g x)","decl":"attribute [to_additive] EventuallyEq.const_smul\n\n"}
{"name":"Filter.EventuallyEq.vadd","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝ : VAdd 𝕜 β\nl : Filter α\nf f' : α → 𝕜\ng g' : α → β\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\n⊢ l.EventuallyEq (fun x => HVAdd.hVAdd (f x) (g x)) fun x => HVAdd.hVAdd (f' x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.smul {𝕜} [SMul 𝕜 β] {l : Filter α} {f f' : α → 𝕜} {g g' : α → β}\n    (hf : f =ᶠ[l] f') (hg : g =ᶠ[l] g') : (fun x => f x • g x) =ᶠ[l] fun x => f' x • g' x :=\n  hf.comp₂ (· • ·) hg\n\n"}
{"name":"Filter.EventuallyEq.smul","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝ : SMul 𝕜 β\nl : Filter α\nf f' : α → 𝕜\ng g' : α → β\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\n⊢ l.EventuallyEq (fun x => HSMul.hSMul (f x) (g x)) fun x => HSMul.hSMul (f' x) (g' x)","decl":"@[to_additive]\ntheorem EventuallyEq.smul {𝕜} [SMul 𝕜 β] {l : Filter α} {f f' : α → 𝕜} {g g' : α → β}\n    (hf : f =ᶠ[l] f') (hg : g =ᶠ[l] g') : (fun x => f x • g x) =ᶠ[l] fun x => f' x • g' x :=\n  hf.comp₂ (· • ·) hg\n\n"}
{"name":"Filter.EventuallyEq.sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Max β\nl : Filter α\nf f' g g' : α → β\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\n⊢ l.EventuallyEq (fun x => Max.max (f x) (g x)) fun x => Max.max (f' x) (g' x)","decl":"theorem EventuallyEq.sup [Max β] {l : Filter α} {f f' g g' : α → β} (hf : f =ᶠ[l] f')\n    (hg : g =ᶠ[l] g') : (fun x => f x ⊔ g x) =ᶠ[l] fun x => f' x ⊔ g' x :=\n  hf.comp₂ (· ⊔ ·) hg\n\n"}
{"name":"Filter.EventuallyEq.inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Min β\nl : Filter α\nf f' g g' : α → β\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\n⊢ l.EventuallyEq (fun x => Min.min (f x) (g x)) fun x => Min.min (f' x) (g' x)","decl":"theorem EventuallyEq.inf [Min β] {l : Filter α} {f f' g g' : α → β} (hf : f =ᶠ[l] f')\n    (hg : g =ᶠ[l] g') : (fun x => f x ⊓ g x) =ᶠ[l] fun x => f' x ⊓ g' x :=\n  hf.comp₂ (· ⊓ ·) hg\n\n"}
{"name":"Filter.EventuallyEq.preimage","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl : Filter α\nf g : α → β\nh : l.EventuallyEq f g\ns : Set β\n⊢ l.EventuallyEq (Set.preimage f s) (Set.preimage g s)","decl":"theorem EventuallyEq.preimage {l : Filter α} {f g : α → β} (h : f =ᶠ[l] g) (s : Set β) :\n    f ⁻¹' s =ᶠ[l] g ⁻¹' s :=\n  h.fun_comp s\n\n"}
{"name":"Filter.EventuallyEq.inter","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t s' t' : Set α\nl : Filter α\nh : l.EventuallyEq s t\nh' : l.EventuallyEq s' t'\n⊢ l.EventuallyEq (Inter.inter s s') (Inter.inter t t')","decl":"theorem EventuallyEq.inter {s t s' t' : Set α} {l : Filter α} (h : s =ᶠ[l] t) (h' : s' =ᶠ[l] t') :\n    (s ∩ s' : Set α) =ᶠ[l] (t ∩ t' : Set α) :=\n  h.comp₂ (· ∧ ·) h'\n\n"}
{"name":"Filter.EventuallyEq.union","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t s' t' : Set α\nl : Filter α\nh : l.EventuallyEq s t\nh' : l.EventuallyEq s' t'\n⊢ l.EventuallyEq (Union.union s s') (Union.union t t')","decl":"theorem EventuallyEq.union {s t s' t' : Set α} {l : Filter α} (h : s =ᶠ[l] t) (h' : s' =ᶠ[l] t') :\n    (s ∪ s' : Set α) =ᶠ[l] (t ∪ t' : Set α) :=\n  h.comp₂ (· ∨ ·) h'\n\n"}
{"name":"Filter.EventuallyEq.compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\nh : l.EventuallyEq s t\n⊢ l.EventuallyEq (HasCompl.compl s) (HasCompl.compl t)","decl":"theorem EventuallyEq.compl {s t : Set α} {l : Filter α} (h : s =ᶠ[l] t) :\n    (sᶜ : Set α) =ᶠ[l] (tᶜ : Set α) :=\n  h.fun_comp Not\n\n"}
{"name":"Filter.EventuallyEq.diff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t s' t' : Set α\nl : Filter α\nh : l.EventuallyEq s t\nh' : l.EventuallyEq s' t'\n⊢ l.EventuallyEq (SDiff.sdiff s s') (SDiff.sdiff t t')","decl":"theorem EventuallyEq.diff {s t s' t' : Set α} {l : Filter α} (h : s =ᶠ[l] t) (h' : s' =ᶠ[l] t') :\n    (s \\ s' : Set α) =ᶠ[l] (t \\ t' : Set α) :=\n  h.inter h'.compl\n\n"}
{"name":"Filter.EventuallyEq.symmDiff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t s' t' : Set α\nl : Filter α\nh : l.EventuallyEq s t\nh' : l.EventuallyEq s' t'\n⊢ l.EventuallyEq (symmDiff s s') (symmDiff t t')","decl":"protected theorem EventuallyEq.symmDiff {s t s' t' : Set α} {l : Filter α}\n    (h : s =ᶠ[l] t) (h' : s' =ᶠ[l] t') : (s ∆ s' : Set α) =ᶠ[l] (t ∆ t' : Set α) :=\n  (h.diff h').union (h'.diff h)\n\n"}
{"name":"Filter.eventuallyEq_empty","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\nl : Filter α\n⊢ Iff (l.EventuallyEq s EmptyCollection.emptyCollection) (Filter.Eventually (fun x => Not (Membership.mem s x)) l)","decl":"theorem eventuallyEq_empty {s : Set α} {l : Filter α} : s =ᶠ[l] (∅ : Set α) ↔ ∀ᶠ x in l, x ∉ s :=\n  eventuallyEq_set.trans <| by simp\n\n"}
{"name":"Filter.inter_eventuallyEq_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\n⊢ Iff (l.EventuallyEq (Inter.inter s t) s) (Filter.Eventually (fun x => Membership.mem s x → Membership.mem t x) l)","decl":"theorem inter_eventuallyEq_left {s t : Set α} {l : Filter α} :\n    (s ∩ t : Set α) =ᶠ[l] s ↔ ∀ᶠ x in l, x ∈ s → x ∈ t := by\n  simp only [eventuallyEq_set, mem_inter_iff, and_iff_left_iff_imp]\n\n"}
{"name":"Filter.inter_eventuallyEq_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\n⊢ Iff (l.EventuallyEq (Inter.inter s t) t) (Filter.Eventually (fun x => Membership.mem t x → Membership.mem s x) l)","decl":"theorem inter_eventuallyEq_right {s t : Set α} {l : Filter α} :\n    (s ∩ t : Set α) =ᶠ[l] t ↔ ∀ᶠ x in l, x ∈ t → x ∈ s := by\n  rw [inter_comm, inter_eventuallyEq_left]\n\n"}
{"name":"Filter.eventuallyEq_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf g : α → β\n⊢ Iff ((Filter.principal s).EventuallyEq f g) (Set.EqOn f g s)","decl":"@[simp]\ntheorem eventuallyEq_principal {s : Set α} {f g : α → β} : f =ᶠ[𝓟 s] g ↔ EqOn f g s :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventuallyEq_inf_principal_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nF : Filter α\ns : Set α\nf g : α → β\n⊢ Iff ((Min.min F (Filter.principal s)).EventuallyEq f g) (Filter.Eventually (fun x => Membership.mem s x → Eq (f x) (g x)) F)","decl":"theorem eventuallyEq_inf_principal_iff {F : Filter α} {s : Set α} {f g : α → β} :\n    f =ᶠ[F ⊓ 𝓟 s] g ↔ ∀ᶠ x in F, x ∈ s → f x = g x :=\n  eventually_inf_principal\n\n"}
{"name":"Filter.EventuallyEq.sub_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddGroup β\nf g : α → β\nl : Filter α\nh : l.EventuallyEq f g\n⊢ l.EventuallyEq (HSub.hSub f g) 0","decl":"theorem EventuallyEq.sub_eq [AddGroup β] {f g : α → β} {l : Filter α} (h : f =ᶠ[l] g) :\n    f - g =ᶠ[l] 0 := by simpa using ((EventuallyEq.refl l f).sub h).symm\n\n"}
{"name":"Filter.eventuallyEq_iff_sub","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddGroup β\nf g : α → β\nl : Filter α\n⊢ Iff (l.EventuallyEq f g) (l.EventuallyEq (HSub.hSub f g) 0)","decl":"theorem eventuallyEq_iff_sub [AddGroup β] {f g : α → β} {l : Filter α} :\n    f =ᶠ[l] g ↔ f - g =ᶠ[l] 0 :=\n  ⟨fun h => h.sub_eq, fun h => by simpa using h.add (EventuallyEq.refl l g)⟩\n\n"}
{"name":"Filter.eventuallyEq_iff_all_subsets","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : α → β\nl : Filter α\n⊢ Iff (l.EventuallyEq f g) (∀ (s : Set α), Filter.Eventually (fun x => Membership.mem s x → Eq (f x) (g x)) l)","decl":"theorem eventuallyEq_iff_all_subsets {f g : α → β} {l : Filter α} :\n    f =ᶠ[l] g ↔ ∀ s : Set α, ∀ᶠ x in l, x ∈ s → f x = g x :=\n  eventually_iff_all_subsets\n\n"}
{"name":"Filter.EventuallyLE.congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LE β\nl : Filter α\nf f' g g' : α → β\nH : l.EventuallyLE f g\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\n⊢ l.EventuallyLE f' g'","decl":"theorem EventuallyLE.congr {f f' g g' : α → β} (H : f ≤ᶠ[l] g) (hf : f =ᶠ[l] f') (hg : g =ᶠ[l] g') :\n    f' ≤ᶠ[l] g' :=\n  H.mp <| hg.mp <| hf.mono fun x hf hg H => by rwa [hf, hg] at H\n\n"}
{"name":"Filter.eventuallyLE_congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LE β\nl : Filter α\nf f' g g' : α → β\nhf : l.EventuallyEq f f'\nhg : l.EventuallyEq g g'\n⊢ Iff (l.EventuallyLE f g) (l.EventuallyLE f' g')","decl":"theorem eventuallyLE_congr {f f' g g' : α → β} (hf : f =ᶠ[l] f') (hg : g =ᶠ[l] g') :\n    f ≤ᶠ[l] g ↔ f' ≤ᶠ[l] g' :=\n  ⟨fun H => H.congr hf hg, fun H => H.congr hf.symm hg.symm⟩\n\n"}
{"name":"Filter.eventuallyLE_iff_all_subsets","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LE β\nf g : α → β\nl : Filter α\n⊢ Iff (l.EventuallyLE f g) (∀ (s : Set α), Filter.Eventually (fun x => Membership.mem s x → LE.le (f x) (g x)) l)","decl":"theorem eventuallyLE_iff_all_subsets {f g : α → β} {l : Filter α} :\n    f ≤ᶠ[l] g ↔ ∀ s : Set α, ∀ᶠ x in l, x ∈ s → f x ≤ g x :=\n  eventually_iff_all_subsets\n\n"}
{"name":"Filter.EventuallyEq.le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\nf g : α → β\nh : l.EventuallyEq f g\n⊢ l.EventuallyLE f g","decl":"theorem EventuallyEq.le (h : f =ᶠ[l] g) : f ≤ᶠ[l] g :=\n  h.mono fun _ => le_of_eq\n\n"}
{"name":"Filter.EventuallyLE.refl","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\nf : α → β\n⊢ l.EventuallyLE f f","decl":"@[refl]\ntheorem EventuallyLE.refl (l : Filter α) (f : α → β) : f ≤ᶠ[l] f :=\n  EventuallyEq.rfl.le\n\n"}
{"name":"Filter.EventuallyLE.rfl","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\nf : α → β\n⊢ l.EventuallyLE f f","decl":"theorem EventuallyLE.rfl : f ≤ᶠ[l] f :=\n  EventuallyLE.refl l f\n\n"}
{"name":"Filter.EventuallyLE.trans","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\nf g h : α → β\nH₁ : l.EventuallyLE f g\nH₂ : l.EventuallyLE g h\n⊢ l.EventuallyLE f h","decl":"@[trans]\ntheorem EventuallyLE.trans (H₁ : f ≤ᶠ[l] g) (H₂ : g ≤ᶠ[l] h) : f ≤ᶠ[l] h :=\n  H₂.mp <| H₁.mono fun _ => le_trans\n\n"}
{"name":"Filter.EventuallyEq.trans_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\nf g h : α → β\nH₁ : l.EventuallyEq f g\nH₂ : l.EventuallyLE g h\n⊢ l.EventuallyLE f h","decl":"@[trans]\ntheorem EventuallyEq.trans_le (H₁ : f =ᶠ[l] g) (H₂ : g ≤ᶠ[l] h) : f ≤ᶠ[l] h :=\n  H₁.le.trans H₂\n\n"}
{"name":"Filter.EventuallyLE.trans_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\nf g h : α → β\nH₁ : l.EventuallyLE f g\nH₂ : l.EventuallyEq g h\n⊢ l.EventuallyLE f h","decl":"@[trans]\ntheorem EventuallyLE.trans_eq (H₁ : f ≤ᶠ[l] g) (H₂ : g =ᶠ[l] h) : f ≤ᶠ[l] h :=\n  H₁.trans H₂.le\n\n"}
{"name":"Filter.EventuallyLE.antisymm","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PartialOrder β\nl : Filter α\nf g : α → β\nh₁ : l.EventuallyLE f g\nh₂ : l.EventuallyLE g f\n⊢ l.EventuallyEq f g","decl":"theorem EventuallyLE.antisymm [PartialOrder β] {l : Filter α} {f g : α → β} (h₁ : f ≤ᶠ[l] g)\n    (h₂ : g ≤ᶠ[l] f) : f =ᶠ[l] g :=\n  h₂.mp <| h₁.mono fun _ => le_antisymm\n\n"}
{"name":"Filter.eventuallyLE_antisymm_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PartialOrder β\nl : Filter α\nf g : α → β\n⊢ Iff (l.EventuallyEq f g) (And (l.EventuallyLE f g) (l.EventuallyLE g f))","decl":"theorem eventuallyLE_antisymm_iff [PartialOrder β] {l : Filter α} {f g : α → β} :\n    f =ᶠ[l] g ↔ f ≤ᶠ[l] g ∧ g ≤ᶠ[l] f := by\n  simp only [EventuallyEq, EventuallyLE, le_antisymm_iff, eventually_and]\n\n"}
{"name":"Filter.EventuallyLE.le_iff_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PartialOrder β\nl : Filter α\nf g : α → β\nh : l.EventuallyLE f g\n⊢ Iff (l.EventuallyLE g f) (l.EventuallyEq g f)","decl":"theorem EventuallyLE.le_iff_eq [PartialOrder β] {l : Filter α} {f g : α → β} (h : f ≤ᶠ[l] g) :\n    g ≤ᶠ[l] f ↔ g =ᶠ[l] f :=\n  ⟨fun h' => h'.antisymm h, EventuallyEq.le⟩\n\n"}
{"name":"Filter.Eventually.ne_of_lt","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\nf g : α → β\nh : Filter.Eventually (fun x => LT.lt (f x) (g x)) l\n⊢ Filter.Eventually (fun x => Ne (f x) (g x)) l","decl":"theorem Eventually.ne_of_lt [Preorder β] {l : Filter α} {f g : α → β} (h : ∀ᶠ x in l, f x < g x) :\n    ∀ᶠ x in l, f x ≠ g x :=\n  h.mono fun _ hx => hx.ne\n\n"}
{"name":"Filter.Eventually.ne_top_of_lt","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder β\ninst✝ : OrderTop β\nl : Filter α\nf g : α → β\nh : Filter.Eventually (fun x => LT.lt (f x) (g x)) l\n⊢ Filter.Eventually (fun x => Ne (f x) Top.top) l","decl":"theorem Eventually.ne_top_of_lt [PartialOrder β] [OrderTop β] {l : Filter α} {f g : α → β}\n    (h : ∀ᶠ x in l, f x < g x) : ∀ᶠ x in l, f x ≠ ⊤ :=\n  h.mono fun _ hx => hx.ne_top\n\n"}
{"name":"Filter.Eventually.lt_top_of_ne","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder β\ninst✝ : OrderTop β\nl : Filter α\nf : α → β\nh : Filter.Eventually (fun x => Ne (f x) Top.top) l\n⊢ Filter.Eventually (fun x => LT.lt (f x) Top.top) l","decl":"theorem Eventually.lt_top_of_ne [PartialOrder β] [OrderTop β] {l : Filter α} {f : α → β}\n    (h : ∀ᶠ x in l, f x ≠ ⊤) : ∀ᶠ x in l, f x < ⊤ :=\n  h.mono fun _ hx => hx.lt_top\n\n"}
{"name":"Filter.Eventually.lt_top_iff_ne_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PartialOrder β\ninst✝ : OrderTop β\nl : Filter α\nf : α → β\n⊢ Iff (Filter.Eventually (fun x => LT.lt (f x) Top.top) l) (Filter.Eventually (fun x => Ne (f x) Top.top) l)","decl":"theorem Eventually.lt_top_iff_ne_top [PartialOrder β] [OrderTop β] {l : Filter α} {f : α → β} :\n    (∀ᶠ x in l, f x < ⊤) ↔ ∀ᶠ x in l, f x ≠ ⊤ :=\n  ⟨Eventually.ne_of_lt, Eventually.lt_top_of_ne⟩\n\n"}
{"name":"Filter.EventuallyLE.inter","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t s' t' : Set α\nl : Filter α\nh : l.EventuallyLE s t\nh' : l.EventuallyLE s' t'\n⊢ l.EventuallyLE (Inter.inter s s') (Inter.inter t t')","decl":"@[mono]\ntheorem EventuallyLE.inter {s t s' t' : Set α} {l : Filter α} (h : s ≤ᶠ[l] t) (h' : s' ≤ᶠ[l] t') :\n    (s ∩ s' : Set α) ≤ᶠ[l] (t ∩ t' : Set α) :=\n  h'.mp <| h.mono fun _ => And.imp\n\n"}
{"name":"Filter.EventuallyLE.union","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t s' t' : Set α\nl : Filter α\nh : l.EventuallyLE s t\nh' : l.EventuallyLE s' t'\n⊢ l.EventuallyLE (Union.union s s') (Union.union t t')","decl":"@[mono]\ntheorem EventuallyLE.union {s t s' t' : Set α} {l : Filter α} (h : s ≤ᶠ[l] t) (h' : s' ≤ᶠ[l] t') :\n    (s ∪ s' : Set α) ≤ᶠ[l] (t ∪ t' : Set α) :=\n  h'.mp <| h.mono fun _ => Or.imp\n\n"}
{"name":"Filter.EventuallyLE.compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\nh : l.EventuallyLE s t\n⊢ l.EventuallyLE (HasCompl.compl t) (HasCompl.compl s)","decl":"@[mono]\ntheorem EventuallyLE.compl {s t : Set α} {l : Filter α} (h : s ≤ᶠ[l] t) :\n    (tᶜ : Set α) ≤ᶠ[l] (sᶜ : Set α) :=\n  h.mono fun _ => mt\n\n"}
{"name":"Filter.EventuallyLE.diff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t s' t' : Set α\nl : Filter α\nh : l.EventuallyLE s t\nh' : l.EventuallyLE t' s'\n⊢ l.EventuallyLE (SDiff.sdiff s s') (SDiff.sdiff t t')","decl":"@[mono]\ntheorem EventuallyLE.diff {s t s' t' : Set α} {l : Filter α} (h : s ≤ᶠ[l] t) (h' : t' ≤ᶠ[l] s') :\n    (s \\ s' : Set α) ≤ᶠ[l] (t \\ t' : Set α) :=\n  h.inter h'.compl\n\n"}
{"name":"Filter.set_eventuallyLE_iff_mem_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\n⊢ Iff (l.EventuallyLE s t) (Membership.mem (Min.min l (Filter.principal s)) t)","decl":"theorem set_eventuallyLE_iff_mem_inf_principal {s t : Set α} {l : Filter α} :\n    s ≤ᶠ[l] t ↔ t ∈ l ⊓ 𝓟 s :=\n  eventually_inf_principal.symm\n\n"}
{"name":"Filter.set_eventuallyLE_iff_inf_principal_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\n⊢ Iff (l.EventuallyLE s t) (LE.le (Min.min l (Filter.principal s)) (Min.min l (Filter.principal t)))","decl":"theorem set_eventuallyLE_iff_inf_principal_le {s t : Set α} {l : Filter α} :\n    s ≤ᶠ[l] t ↔ l ⊓ 𝓟 s ≤ l ⊓ 𝓟 t :=\n  set_eventuallyLE_iff_mem_inf_principal.trans <| by\n    simp only [le_inf_iff, inf_le_left, true_and, le_principal_iff]\n\n"}
{"name":"Filter.set_eventuallyEq_iff_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns t : Set α\nl : Filter α\n⊢ Iff (l.EventuallyEq s t) (Eq (Min.min l (Filter.principal s)) (Min.min l (Filter.principal t)))","decl":"theorem set_eventuallyEq_iff_inf_principal {s t : Set α} {l : Filter α} :\n    s =ᶠ[l] t ↔ l ⊓ 𝓟 s = l ⊓ 𝓟 t := by\n  simp only [eventuallyLE_antisymm_iff, le_antisymm_iff, set_eventuallyLE_iff_inf_principal_le]\n\n"}
{"name":"Filter.EventuallyLE.sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeSup β\nl : Filter α\nf₁ f₂ g₁ g₂ : α → β\nhf : l.EventuallyLE f₁ f₂\nhg : l.EventuallyLE g₁ g₂\n⊢ l.EventuallyLE (Max.max f₁ g₁) (Max.max f₂ g₂)","decl":"theorem EventuallyLE.sup [SemilatticeSup β] {l : Filter α} {f₁ f₂ g₁ g₂ : α → β} (hf : f₁ ≤ᶠ[l] f₂)\n    (hg : g₁ ≤ᶠ[l] g₂) : f₁ ⊔ g₁ ≤ᶠ[l] f₂ ⊔ g₂ := by\n  filter_upwards [hf, hg] with x hfx hgx using sup_le_sup hfx hgx\n\n"}
{"name":"Filter.EventuallyLE.sup_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeSup β\nl : Filter α\nf g h : α → β\nhf : l.EventuallyLE f h\nhg : l.EventuallyLE g h\n⊢ l.EventuallyLE (Max.max f g) h","decl":"theorem EventuallyLE.sup_le [SemilatticeSup β] {l : Filter α} {f g h : α → β} (hf : f ≤ᶠ[l] h)\n    (hg : g ≤ᶠ[l] h) : f ⊔ g ≤ᶠ[l] h := by\n  filter_upwards [hf, hg] with x hfx hgx using _root_.sup_le hfx hgx\n\n"}
{"name":"Filter.EventuallyLE.le_sup_of_le_left","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeSup β\nl : Filter α\nf g h : α → β\nhf : l.EventuallyLE h f\n⊢ l.EventuallyLE h (Max.max f g)","decl":"theorem EventuallyLE.le_sup_of_le_left [SemilatticeSup β] {l : Filter α} {f g h : α → β}\n    (hf : h ≤ᶠ[l] f) : h ≤ᶠ[l] f ⊔ g :=\n  hf.mono fun _ => _root_.le_sup_of_le_left\n\n"}
{"name":"Filter.EventuallyLE.le_sup_of_le_right","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeSup β\nl : Filter α\nf g h : α → β\nhg : l.EventuallyLE h g\n⊢ l.EventuallyLE h (Max.max f g)","decl":"theorem EventuallyLE.le_sup_of_le_right [SemilatticeSup β] {l : Filter α} {f g h : α → β}\n    (hg : h ≤ᶠ[l] g) : h ≤ᶠ[l] f ⊔ g :=\n  hg.mono fun _ => _root_.le_sup_of_le_right\n\n"}
{"name":"Filter.join_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter (Filter α)\nl : Filter α\nh : Filter.Eventually (fun m => LE.le m l) f\n⊢ LE.le f.join l","decl":"theorem join_le {f : Filter (Filter α)} {l : Filter α} (h : ∀ᶠ m in f, m ≤ l) : join f ≤ l :=\n  fun _ hs => h.mono fun _ hm => hm hs\n\n"}
{"name":"Filter.map_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → β\n⊢ Eq (Filter.map f (Filter.principal s)) (Filter.principal (Set.image f s))","decl":"@[simp]\ntheorem map_principal {s : Set α} {f : α → β} : map f (𝓟 s) = 𝓟 (Set.image f s) :=\n  Filter.ext fun _ => image_subset_iff.symm\n\n"}
{"name":"Filter.eventually_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\nP : β → Prop\n⊢ Iff (Filter.Eventually (fun b => P b) (Filter.map m f)) (Filter.Eventually (fun a => P (m a)) f)","decl":"@[simp]\ntheorem eventually_map {P : β → Prop} : (∀ᶠ b in map m f, P b) ↔ ∀ᶠ a in f, P (m a) :=\n  Iff.rfl\n\n"}
{"name":"Filter.frequently_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\nP : β → Prop\n⊢ Iff (Filter.Frequently (fun b => P b) (Filter.map m f)) (Filter.Frequently (fun a => P (m a)) f)","decl":"@[simp]\ntheorem frequently_map {P : β → Prop} : (∃ᶠ b in map m f, P b) ↔ ∃ᶠ a in f, P (m a) :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\nt : Set β\n⊢ Iff (Membership.mem (Filter.map m f) t) (Membership.mem f (Set.preimage m t))","decl":"@[simp]\ntheorem mem_map : t ∈ map m f ↔ m ⁻¹' t ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_map'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\nt : Set β\n⊢ Iff (Membership.mem (Filter.map m f) t) (Membership.mem f (setOf fun x => Membership.mem t (m x)))","decl":"theorem mem_map' : t ∈ map m f ↔ { x | m x ∈ t } ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.image_mem_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\ns : Set α\nhs : Membership.mem f s\n⊢ Membership.mem (Filter.map m f) (Set.image m s)","decl":"theorem image_mem_map (hs : s ∈ f) : m '' s ∈ map m f :=\n  f.sets_of_superset hs <| subset_preimage_image m s\n\n-- The simpNF linter says that the LHS can be simplified via `Filter.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"Filter.image_mem_map_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\ns : Set α\nhf : Function.Injective m\n⊢ Iff (Membership.mem (Filter.map m f) (Set.image m s)) (Membership.mem f s)","decl":"@[simp 1100, nolint simpNF]\ntheorem image_mem_map_iff (hf : Injective m) : m '' s ∈ map m f ↔ s ∈ f :=\n  ⟨fun h => by rwa [← preimage_image_eq s hf], image_mem_map⟩\n\n"}
{"name":"Filter.range_mem_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\n⊢ Membership.mem (Filter.map m f) (Set.range m)","decl":"theorem range_mem_map : range m ∈ map m f := by\n  rw [← image_univ]\n  exact image_mem_map univ_mem\n\n"}
{"name":"Filter.mem_map_iff_exists_image","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\nt : Set β\n⊢ Iff (Membership.mem (Filter.map m f) t) (Exists fun s => And (Membership.mem f s) (HasSubset.Subset (Set.image m s) t))","decl":"theorem mem_map_iff_exists_image : t ∈ map m f ↔ ∃ s ∈ f, m '' s ⊆ t :=\n  ⟨fun ht => ⟨m ⁻¹' t, ht, image_preimage_subset _ _⟩, fun ⟨_, hs, ht⟩ =>\n    mem_of_superset (image_mem_map hs) ht⟩\n\n"}
{"name":"Filter.map_id","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Eq (Filter.map id f) f","decl":"@[simp]\ntheorem map_id : Filter.map id f = f :=\n  filter_eq <| rfl\n\n"}
{"name":"Filter.map_id'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Eq (Filter.map (fun x => x) f) f","decl":"@[simp]\ntheorem map_id' : Filter.map (fun x => x) f = f :=\n  map_id\n\n"}
{"name":"Filter.map_compose","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nm : α → β\nm' : β → γ\n⊢ Eq (Function.comp (Filter.map m') (Filter.map m)) (Filter.map (Function.comp m' m))","decl":"@[simp]\ntheorem map_compose : Filter.map m' ∘ Filter.map m = Filter.map (m' ∘ m) :=\n  funext fun _ => filter_eq <| rfl\n\n"}
{"name":"Filter.map_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Filter α\nm : α → β\nm' : β → γ\n⊢ Eq (Filter.map m' (Filter.map m f)) (Filter.map (Function.comp m' m) f)","decl":"@[simp]\ntheorem map_map : Filter.map m' (Filter.map m f) = Filter.map (m' ∘ m) f :=\n  congr_fun Filter.map_compose f\n\n"}
{"name":"Filter.map_congr","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm₁ m₂ : α → β\nf : Filter α\nh : f.EventuallyEq m₁ m₂\n⊢ Eq (Filter.map m₁ f) (Filter.map m₂ f)","decl":"/-- If functions `m₁` and `m₂` are eventually equal at a filter `f`, then\nthey map this filter to the same filter. -/\ntheorem map_congr {m₁ m₂ : α → β} {f : Filter α} (h : m₁ =ᶠ[f] m₂) : map m₁ f = map m₂ f :=\n  Filter.ext' fun _ => eventually_congr (h.mono fun _ hx => hx ▸ Iff.rfl)\n\n"}
{"name":"Filter.mem_comap'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : Filter β\ns : Set α\n⊢ Iff (Membership.mem (Filter.comap f l) s) (Membership.mem l (setOf fun y => ∀ ⦃x : α⦄, Eq (f x) y → Membership.mem s x))","decl":"theorem mem_comap' : s ∈ comap f l ↔ { y | ∀ ⦃x⦄, f x = y → x ∈ s } ∈ l :=\n  ⟨fun ⟨t, ht, hts⟩ => mem_of_superset ht fun y hy x hx => hts <| mem_preimage.2 <| by rwa [hx],\n    fun h => ⟨_, h, fun _ hx => hx rfl⟩⟩\n\n-- TODO: it would be nice to use `kernImage` much more to take advantage of common name and API,\n-- and then this would become `mem_comap'`\n"}
{"name":"Filter.mem_comap''","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : Filter β\ns : Set α\n⊢ Iff (Membership.mem (Filter.comap f l) s) (Membership.mem l (Set.kernImage f s))","decl":"theorem mem_comap'' : s ∈ comap f l ↔ kernImage f s ∈ l :=\n  mem_comap'\n\n"}
{"name":"Filter.mem_comap_prod_mk","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nx : α\ns : Set β\nF : Filter (Prod α β)\n⊢ Iff (Membership.mem (Filter.comap (Prod.mk x) F) s) (Membership.mem F (setOf fun p => Eq p.1 x → Membership.mem s p.2))","decl":"/-- RHS form is used, e.g., in the definition of `UniformSpace`. -/\nlemma mem_comap_prod_mk {x : α} {s : Set β} {F : Filter (α × β)} :\n    s ∈ comap (Prod.mk x) F ↔ {p : α × β | p.fst = x → p.snd ∈ s} ∈ F := by\n  simp_rw [mem_comap', Prod.ext_iff, and_imp, @forall_swap β (_ = _), forall_eq, eq_comm]\n\n"}
{"name":"Filter.eventually_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : Filter β\np : α → Prop\n⊢ Iff (Filter.Eventually (fun a => p a) (Filter.comap f l)) (Filter.Eventually (fun b => ∀ (a : α), Eq (f a) b → p a) l)","decl":"@[simp]\ntheorem eventually_comap : (∀ᶠ a in comap f l, p a) ↔ ∀ᶠ b in l, ∀ a, f a = b → p a :=\n  mem_comap'\n\n"}
{"name":"Filter.frequently_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : Filter β\np : α → Prop\n⊢ Iff (Filter.Frequently (fun a => p a) (Filter.comap f l)) (Filter.Frequently (fun b => Exists fun a => And (Eq (f a) b) (p a)) l)","decl":"@[simp]\ntheorem frequently_comap : (∃ᶠ a in comap f l, p a) ↔ ∃ᶠ b in l, ∃ a, f a = b ∧ p a := by\n  simp only [Filter.Frequently, eventually_comap, not_exists, _root_.not_and]\n\n"}
{"name":"Filter.mem_comap_iff_compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : Filter β\ns : Set α\n⊢ Iff (Membership.mem (Filter.comap f l) s) (Membership.mem l (HasCompl.compl (Set.image f (HasCompl.compl s))))","decl":"theorem mem_comap_iff_compl : s ∈ comap f l ↔ (f '' sᶜ)ᶜ ∈ l := by\n  simp only [mem_comap'', kernImage_eq_compl]\n\n"}
{"name":"Filter.compl_mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : Filter β\ns : Set α\n⊢ Iff (Membership.mem (Filter.comap f l) (HasCompl.compl s)) (Membership.mem l (HasCompl.compl (Set.image f s)))","decl":"theorem compl_mem_comap : sᶜ ∈ comap f l ↔ (f '' s)ᶜ ∈ l := by rw [mem_comap_iff_compl, compl_compl]\n\n"}
{"name":"Filter.mem_kernMap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nf : Filter α\ns : Set β\n⊢ Iff (Membership.mem (Filter.kernMap m f) s) (Exists fun t => And (Membership.mem f t) (Eq (Set.kernImage m t) s))","decl":"theorem mem_kernMap {s : Set β} : s ∈ kernMap m f ↔ ∃ t ∈ f, kernImage m t = s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_kernMap_iff_compl","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nf : Filter α\ns : Set β\n⊢ Iff (Membership.mem (Filter.kernMap m f) s) (Exists fun t => And (Membership.mem f (HasCompl.compl t)) (Eq (Set.image m t) (HasCompl.compl s)))","decl":"theorem mem_kernMap_iff_compl {s : Set β} : s ∈ kernMap m f ↔ ∃ t, tᶜ ∈ f ∧ m '' t = sᶜ := by\n  rw [mem_kernMap, compl_surjective.exists]\n  refine exists_congr (fun x ↦ and_congr_right fun _ ↦ ?_)\n  rw [kernImage_compl, compl_eq_comm, eq_comm]\n\n"}
{"name":"Filter.compl_mem_kernMap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nf : Filter α\ns : Set β\n⊢ Iff (Membership.mem (Filter.kernMap m f) (HasCompl.compl s)) (Exists fun t => And (Membership.mem f (HasCompl.compl t)) (Eq (Set.image m t) s))","decl":"theorem compl_mem_kernMap {s : Set β} : sᶜ ∈ kernMap m f ↔ ∃ t, tᶜ ∈ f ∧ m '' t = s := by\n  simp_rw [mem_kernMap_iff_compl, compl_compl]\n\n"}
{"name":"Filter.instLawfulFunctor","module":"Mathlib.Order.Filter.Basic","initialProofState":"⊢ LawfulFunctor Filter","decl":"instance : LawfulFunctor (Filter : Type u → Type u) where\n  id_map _ := map_id\n  comp_map _ _ _ := map_map.symm\n  map_const := rfl\n\n"}
{"name":"Filter.pure_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (Pure.pure a).sets (setOf fun s => Membership.mem s a)","decl":"theorem pure_sets (a : α) : (pure a : Filter α).sets = { s | a ∈ s } :=\n  rfl\n\n"}
{"name":"Filter.eventually_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\na : α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (Pure.pure a)) (p a)","decl":"@[simp]\ntheorem eventually_pure {a : α} {p : α → Prop} : (∀ᶠ x in pure a, p x) ↔ p a :=\n  Iff.rfl\n\n"}
{"name":"Filter.principal_singleton","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (Filter.principal (Singleton.singleton a)) (Pure.pure a)","decl":"@[simp]\ntheorem principal_singleton (a : α) : 𝓟 {a} = pure a :=\n  Filter.ext fun s => by simp only [mem_pure, mem_principal, singleton_subset_iff]\n\n"}
{"name":"Filter.map_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\n⊢ Eq (Filter.map f (Pure.pure a)) (Pure.pure (f a))","decl":"@[simp]\ntheorem map_pure (f : α → β) (a : α) : map f (pure a) = pure (f a) :=\n  rfl\n\n"}
{"name":"Filter.pure_le_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\na : α\n⊢ Iff (LE.le (Pure.pure a) (Filter.principal s)) (Membership.mem s a)","decl":"theorem pure_le_principal {s : Set α} (a : α) : pure a ≤ 𝓟 s ↔ a ∈ s := by\n  simp\n\n"}
{"name":"Filter.join_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Eq (Pure.pure f).join f","decl":"@[simp] theorem join_pure (f : Filter α) : join (pure f) = f := rfl\n\n"}
{"name":"Filter.pure_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\na : α\nm : α → Filter β\n⊢ Eq ((Pure.pure a).bind m) (m a)","decl":"@[simp]\ntheorem pure_bind (a : α) (m : α → Filter β) : bind (pure a) m = m a := by\n  simp only [Bind.bind, bind, map_pure, join_pure]\n\n"}
{"name":"Filter.map_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"γ : Type w\nα : Type u_2\nβ : Type u_3\nm : β → γ\nf : Filter α\ng : α → Filter β\n⊢ Eq (Filter.map m (f.bind g)) (f.bind (Function.comp (Filter.map m) g))","decl":"theorem map_bind {α β} (m : β → γ) (f : Filter α) (g : α → Filter β) :\n    map m (bind f g) = bind f (map m ∘ g) :=\n  rfl\n\n"}
{"name":"Filter.bind_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"γ : Type w\nα : Type u_2\nβ : Type u_3\nm : α → β\nf : Filter α\ng : β → Filter γ\n⊢ Eq ((Filter.map m f).bind g) (f.bind (Function.comp g m))","decl":"theorem bind_map {α β} (m : α → β) (f : Filter α) (g : β → Filter γ) :\n    (bind (map m f) g) = bind f (g ∘ m) :=\n  rfl\n\n"}
{"name":"Filter.lawfulMonad","module":"Mathlib.Order.Filter.Basic","initialProofState":"⊢ LawfulMonad Filter","decl":"protected theorem lawfulMonad : LawfulMonad Filter where\n  map_const := rfl\n  id_map _ := rfl\n  seqLeft_eq _ _ := rfl\n  seqRight_eq _ _ := rfl\n  pure_seq _ _ := rfl\n  bind_pure_comp _ _ := rfl\n  bind_map _ _ := rfl\n  pure_bind _ _ := rfl\n  bind_assoc _ _ _ := rfl\n\n"}
{"name":"Filter.map_def","module":"Mathlib.Order.Filter.Basic","initialProofState":"α β : Type u_2\nm : α → β\nf : Filter α\n⊢ Eq (Functor.map m f) (Filter.map m f)","decl":"@[simp]\ntheorem map_def {α β} (m : α → β) (f : Filter α) : m <$> f = map m f :=\n  rfl\n\n"}
{"name":"Filter.bind_def","module":"Mathlib.Order.Filter.Basic","initialProofState":"α β : Type u_2\nf : Filter α\nm : α → Filter β\n⊢ Eq (Bind.bind f m) (f.bind m)","decl":"@[simp]\ntheorem bind_def {α β} (f : Filter α) (m : α → Filter β) : f >>= m = bind f m :=\n  rfl\n\n"}
{"name":"Filter.mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng : Filter β\nm : α → β\ns : Set α\n⊢ Iff (Membership.mem (Filter.comap m g) s) (Exists fun t => And (Membership.mem g t) (HasSubset.Subset (Set.preimage m t) s))","decl":"@[simp] theorem mem_comap : s ∈ comap m g ↔ ∃ t ∈ g, m ⁻¹' t ⊆ s := Iff.rfl\n\n"}
{"name":"Filter.preimage_mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng : Filter β\nm : α → β\nt : Set β\nht : Membership.mem g t\n⊢ Membership.mem (Filter.comap m g) (Set.preimage m t)","decl":"theorem preimage_mem_comap (ht : t ∈ g) : m ⁻¹' t ∈ comap m g :=\n  ⟨t, ht, Subset.rfl⟩\n\n"}
{"name":"Filter.Eventually.comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng : Filter β\np : β → Prop\nhf : Filter.Eventually (fun b => p b) g\nf : α → β\n⊢ Filter.Eventually (fun a => p (f a)) (Filter.comap f g)","decl":"theorem Eventually.comap {p : β → Prop} (hf : ∀ᶠ b in g, p b) (f : α → β) :\n    ∀ᶠ a in comap f g, p (f a) :=\n  preimage_mem_comap hf\n\n"}
{"name":"Filter.comap_id","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Eq (Filter.comap id f) f","decl":"theorem comap_id : comap id f = f :=\n  le_antisymm (fun _ => preimage_mem_comap) fun _ ⟨_, ht, hst⟩ => mem_of_superset ht hst\n\n"}
{"name":"Filter.comap_id'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\n⊢ Eq (Filter.comap (fun x => x) f) f","decl":"theorem comap_id' : comap (fun x => x) f = f := comap_id\n\n"}
{"name":"Filter.comap_const_of_not_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng : Filter β\nt : Set β\nx : β\nht : Membership.mem g t\nhx : Not (Membership.mem t x)\n⊢ Eq (Filter.comap (fun x_1 => x) g) Bot.bot","decl":"theorem comap_const_of_not_mem {x : β} (ht : t ∈ g) (hx : x ∉ t) : comap (fun _ : α => x) g = ⊥ :=\n  empty_mem_iff_bot.1 <| mem_comap'.2 <| mem_of_superset ht fun _ hx' _ h => hx <| h.symm ▸ hx'\n\n"}
{"name":"Filter.comap_const_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng : Filter β\nx : β\nh : ∀ (t : Set β), Membership.mem g t → Membership.mem t x\n⊢ Eq (Filter.comap (fun x_1 => x) g) Top.top","decl":"theorem comap_const_of_mem {x : β} (h : ∀ t ∈ g, x ∈ t) : comap (fun _ : α => x) g = ⊤ :=\n  top_unique fun _ hs => univ_mem' fun _ => h _ (mem_comap'.1 hs) rfl\n\n"}
{"name":"Filter.map_const","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\ninst✝ : f.NeBot\nc : β\n⊢ Eq (Filter.map (fun x => c) f) (Pure.pure c)","decl":"theorem map_const [NeBot f] {c : β} : (f.map fun _ => c) = pure c := by\n  ext s\n  by_cases h : c ∈ s <;> simp [h]\n\n"}
{"name":"Filter.comap_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Filter α\nm : γ → β\nn : β → α\n⊢ Eq (Filter.comap m (Filter.comap n f)) (Filter.comap (Function.comp n m) f)","decl":"theorem comap_comap {m : γ → β} {n : β → α} : comap m (comap n f) = comap (n ∘ m) f :=\n  Filter.coext fun s => by simp only [compl_mem_comap, image_image, (· ∘ ·)]\n\n"}
{"name":"Filter.map_comm","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_1\nφ : α → β\nθ : α → γ\nψ : β → δ\nρ : γ → δ\nH : Eq (Function.comp ψ φ) (Function.comp ρ θ)\nF : Filter α\n⊢ Eq (Filter.map ψ (Filter.map φ F)) (Filter.map ρ (Filter.map θ F))","decl":"theorem map_comm (H : ψ ∘ φ = ρ ∘ θ) (F : Filter α) :\n    map ψ (map φ F) = map ρ (map θ F) := by\n  rw [Filter.map_map, H, ← Filter.map_map]\n\n"}
{"name":"Filter.comap_comm","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_1\nφ : α → β\nθ : α → γ\nψ : β → δ\nρ : γ → δ\nH : Eq (Function.comp ψ φ) (Function.comp ρ θ)\nG : Filter δ\n⊢ Eq (Filter.comap φ (Filter.comap ψ G)) (Filter.comap θ (Filter.comap ρ G))","decl":"theorem comap_comm (H : ψ ∘ φ = ρ ∘ θ) (G : Filter δ) :\n    comap φ (comap ψ G) = comap θ (comap ρ G) := by\n  rw [Filter.comap_comap, H, ← Filter.comap_comap]\n\n"}
{"name":"Function.Semiconj.filter_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nga : α → α\ngb : β → β\nh : Function.Semiconj f ga gb\n⊢ Function.Semiconj (Filter.map f) (Filter.map ga) (Filter.map gb)","decl":"theorem _root_.Function.Semiconj.filter_map {f : α → β} {ga : α → α} {gb : β → β}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (map f) (map ga) (map gb) :=\n  map_comm h.comp_eq\n\n"}
{"name":"Function.Commute.filter_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\n⊢ Function.Commute (Filter.map f) (Filter.map g)","decl":"theorem _root_.Function.Commute.filter_map {f g : α → α} (h : Function.Commute f g) :\n    Function.Commute (map f) (map g) :=\n  h.semiconj.filter_map\n\n"}
{"name":"Function.Semiconj.filter_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nga : α → α\ngb : β → β\nh : Function.Semiconj f ga gb\n⊢ Function.Semiconj (Filter.comap f) (Filter.comap gb) (Filter.comap ga)","decl":"theorem _root_.Function.Semiconj.filter_comap {f : α → β} {ga : α → α} {gb : β → β}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (comap f) (comap gb) (comap ga) :=\n  comap_comm h.comp_eq.symm\n\n"}
{"name":"Function.Commute.filter_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\n⊢ Function.Commute (Filter.comap f) (Filter.comap g)","decl":"theorem _root_.Function.Commute.filter_comap {f g : α → α} (h : Function.Commute f g) :\n    Function.Commute (comap f) (comap g) :=\n  h.semiconj.filter_comap\n\n"}
{"name":"Function.LeftInverse.filter_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\nhfg : Function.LeftInverse g f\n⊢ Function.LeftInverse (Filter.map g) (Filter.map f)","decl":"theorem _root_.Function.LeftInverse.filter_map {f : α → β} {g : β → α} (hfg : LeftInverse g f) :\n    LeftInverse (map g) (map f) := fun F ↦ by\n  rw [map_map, hfg.comp_eq_id, map_id]\n\n"}
{"name":"Function.LeftInverse.filter_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\nhfg : Function.LeftInverse g f\n⊢ Function.RightInverse (Filter.comap g) (Filter.comap f)","decl":"theorem _root_.Function.LeftInverse.filter_comap {f : α → β} {g : β → α} (hfg : LeftInverse g f) :\n    RightInverse (comap g) (comap f) := fun F ↦ by\n  rw [comap_comap, hfg.comp_eq_id, comap_id]\n\n"}
{"name":"Function.RightInverse.filter_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\nhfg : Function.RightInverse g f\n⊢ Function.RightInverse (Filter.map g) (Filter.map f)","decl":"nonrec theorem _root_.Function.RightInverse.filter_map {f : α → β} {g : β → α}\n    (hfg : RightInverse g f) : RightInverse (map g) (map f) :=\n  hfg.filter_map\n\n"}
{"name":"Function.RightInverse.filter_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\nhfg : Function.RightInverse g f\n⊢ Function.LeftInverse (Filter.comap g) (Filter.comap f)","decl":"nonrec theorem _root_.Function.RightInverse.filter_comap {f : α → β} {g : β → α}\n    (hfg : RightInverse g f) : LeftInverse (comap g) (comap f) :=\n  hfg.filter_comap\n\n"}
{"name":"Set.LeftInvOn.filter_map_Iic","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → β\ng : β → α\nhfg : Set.LeftInvOn g f s\n⊢ Set.LeftInvOn (Filter.map g) (Filter.map f) (Set.Iic (Filter.principal s))","decl":"theorem _root_.Set.LeftInvOn.filter_map_Iic {f : α → β} {g : β → α} (hfg : LeftInvOn g f s) :\n    LeftInvOn (map g) (map f) (Iic <| 𝓟 s) := fun F (hF : F ≤ 𝓟 s) ↦ by\n  have : (g ∘ f) =ᶠ[𝓟 s] id := by simpa only [eventuallyEq_principal] using hfg\n  rw [map_map, map_congr (this.filter_mono hF), map_id]\n\n"}
{"name":"Set.RightInvOn.filter_map_Iic","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nt : Set β\nf : α → β\ng : β → α\nhfg : Set.RightInvOn g f t\n⊢ Set.RightInvOn (Filter.map g) (Filter.map f) (Set.Iic (Filter.principal t))","decl":"nonrec theorem _root_.Set.RightInvOn.filter_map_Iic {f : α → β} {g : β → α}\n    (hfg : RightInvOn g f t) : RightInvOn (map g) (map f) (Iic <| 𝓟 t) :=\n  hfg.filter_map_Iic\n\n"}
{"name":"Filter.comap_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nt : Set β\n⊢ Eq (Filter.comap m (Filter.principal t)) (Filter.principal (Set.preimage m t))","decl":"@[simp]\ntheorem comap_principal {t : Set β} : comap m (𝓟 t) = 𝓟 (m ⁻¹' t) :=\n  Filter.ext fun _ => ⟨fun ⟨_u, hu, b⟩ => (preimage_mono hu).trans b,\n    fun h => ⟨t, Subset.rfl, h⟩⟩\n\n"}
{"name":"Filter.principal_subtype","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_2\ns : Set α\nt : Set ↑s\n⊢ Eq (Filter.principal t) (Filter.comap Subtype.val (Filter.principal (Set.image Subtype.val t)))","decl":"theorem principal_subtype {α : Type*} (s : Set α) (t : Set s) :\n    𝓟 t = comap (↑) (𝓟 (((↑) : s → α) '' t)) := by\n  rw [comap_principal, preimage_image_eq _ Subtype.coe_injective]\n\n"}
{"name":"Filter.comap_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nb : β\n⊢ Eq (Filter.comap m (Pure.pure b)) (Filter.principal (Set.preimage m (Singleton.singleton b)))","decl":"@[simp]\ntheorem comap_pure {b : β} : comap m (pure b) = 𝓟 (m ⁻¹' {b}) := by\n  rw [← principal_singleton, comap_principal]\n\n"}
{"name":"Filter.map_le_iff_le_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\ng : Filter β\nm : α → β\n⊢ Iff (LE.le (Filter.map m f) g) (LE.le f (Filter.comap m g))","decl":"theorem map_le_iff_le_comap : map m f ≤ g ↔ f ≤ comap m g :=\n  ⟨fun h _ ⟨_, ht, hts⟩ => mem_of_superset (h ht) hts, fun h _ ht => h ⟨_, ht, Subset.rfl⟩⟩\n\n"}
{"name":"Filter.gc_map_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\n⊢ GaloisConnection (Filter.map m) (Filter.comap m)","decl":"theorem gc_map_comap (m : α → β) : GaloisConnection (map m) (comap m) :=\n  fun _ _ => map_le_iff_le_comap\n\n"}
{"name":"Filter.comap_le_iff_le_kernMap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\ng : Filter β\nm : α → β\n⊢ Iff (LE.le (Filter.comap m g) f) (LE.le g (Filter.kernMap m f))","decl":"theorem comap_le_iff_le_kernMap : comap m g ≤ f ↔ g ≤ kernMap m f := by\n  simp [Filter.le_def, mem_comap'', mem_kernMap, -mem_comap]\n\n"}
{"name":"Filter.gc_comap_kernMap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\n⊢ GaloisConnection (Filter.comap m) (Filter.kernMap m)","decl":"theorem gc_comap_kernMap (m : α → β) : GaloisConnection (comap m) (kernMap m) :=\n  fun _ _ ↦ comap_le_iff_le_kernMap\n\n"}
{"name":"Filter.kernMap_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\ns : Set α\n⊢ Eq (Filter.kernMap m (Filter.principal s)) (Filter.principal (Set.kernImage m s))","decl":"theorem kernMap_principal {s : Set α} : kernMap m (𝓟 s) = 𝓟 (kernImage m s) := by\n  refine eq_of_forall_le_iff (fun g ↦ ?_)\n  rw [← comap_le_iff_le_kernMap, le_principal_iff, le_principal_iff, mem_comap'']\n\n"}
{"name":"Filter.map_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\n⊢ Monotone (Filter.map m)","decl":"@[mono]\ntheorem map_mono : Monotone (map m) :=\n  (gc_map_comap m).monotone_l\n\n"}
{"name":"Filter.comap_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\n⊢ Monotone (Filter.comap m)","decl":"@[mono]\ntheorem comap_mono : Monotone (comap m) :=\n  (gc_map_comap m).monotone_u\n\n"}
{"name":"GCongr.Filter.map_le_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nF G : Filter α\nh : LE.le F G\n⊢ LE.le (Filter.map m F) (Filter.map m G)","decl":"/-- Temporary lemma that we can tag with `gcongr` -/\n@[gcongr] theorem _root_.GCongr.Filter.map_le_map {F G : Filter α} (h : F ≤ G) :\n    map m F ≤ map m G := map_mono h\n\n"}
{"name":"GCongr.Filter.comap_le_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nF G : Filter β\nh : LE.le F G\n⊢ LE.le (Filter.comap m F) (Filter.comap m G)","decl":"/-- Temporary lemma that we can tag with `gcongr` -/\n@[gcongr]\ntheorem _root_.GCongr.Filter.comap_le_comap {F G : Filter β} (h : F ≤ G) :\n    comap m F ≤ comap m G := comap_mono h\n\n"}
{"name":"Filter.map_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\n⊢ Eq (Filter.map m Bot.bot) Bot.bot","decl":"@[simp] theorem map_bot : map m ⊥ = ⊥ := (gc_map_comap m).l_bot\n\n"}
{"name":"Filter.map_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf₁ f₂ : Filter α\nm : α → β\n⊢ Eq (Filter.map m (Max.max f₁ f₂)) (Max.max (Filter.map m f₁) (Filter.map m f₂))","decl":"@[simp] theorem map_sup : map m (f₁ ⊔ f₂) = map m f₁ ⊔ map m f₂ := (gc_map_comap m).l_sup\n\n"}
{"name":"Filter.map_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Sort x\nm : α → β\nf : ι → Filter α\n⊢ Eq (Filter.map m (iSup fun i => f i)) (iSup fun i => Filter.map m (f i))","decl":"@[simp]\ntheorem map_iSup {f : ι → Filter α} : map m (⨆ i, f i) = ⨆ i, map m (f i) :=\n  (gc_map_comap m).l_iSup\n\n"}
{"name":"Filter.map_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Eq (Filter.map f Top.top) (Filter.principal (Set.range f))","decl":"@[simp]\ntheorem map_top (f : α → β) : map f ⊤ = 𝓟 (range f) := by\n  rw [← principal_univ, map_principal, image_univ]\n\n"}
{"name":"Filter.comap_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\n⊢ Eq (Filter.comap m Top.top) Top.top","decl":"@[simp] theorem comap_top : comap m ⊤ = ⊤ := (gc_map_comap m).u_top\n\n"}
{"name":"Filter.comap_inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng₁ g₂ : Filter β\nm : α → β\n⊢ Eq (Filter.comap m (Min.min g₁ g₂)) (Min.min (Filter.comap m g₁) (Filter.comap m g₂))","decl":"@[simp] theorem comap_inf : comap m (g₁ ⊓ g₂) = comap m g₁ ⊓ comap m g₂ := (gc_map_comap m).u_inf\n\n"}
{"name":"Filter.comap_iInf","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Sort x\nm : α → β\nf : ι → Filter β\n⊢ Eq (Filter.comap m (iInf fun i => f i)) (iInf fun i => Filter.comap m (f i))","decl":"@[simp]\ntheorem comap_iInf {f : ι → Filter β} : comap m (⨅ i, f i) = ⨅ i, comap m (f i) :=\n  (gc_map_comap m).u_iInf\n\n"}
{"name":"Filter.le_comap_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nl : Filter α\n⊢ LE.le l (Filter.comap f Top.top)","decl":"theorem le_comap_top (f : α → β) (l : Filter α) : l ≤ comap f ⊤ := by\n  rw [comap_top]\n  exact le_top\n\n"}
{"name":"Filter.map_comap_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng : Filter β\nm : α → β\n⊢ LE.le (Filter.map m (Filter.comap m g)) g","decl":"theorem map_comap_le : map m (comap m g) ≤ g :=\n  (gc_map_comap m).l_u_le _\n\n"}
{"name":"Filter.le_comap_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\n⊢ LE.le f (Filter.comap m (Filter.map m f))","decl":"theorem le_comap_map : f ≤ comap m (map m f) :=\n  (gc_map_comap m).le_u_l _\n\n"}
{"name":"Filter.comap_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\n⊢ Eq (Filter.comap m Bot.bot) Bot.bot","decl":"@[simp]\ntheorem comap_bot : comap m ⊥ = ⊥ :=\n  bot_unique fun s _ => ⟨∅, mem_bot, by simp only [empty_subset, preimage_empty]⟩\n\n"}
{"name":"Filter.neBot_of_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng : Filter β\nm : α → β\nh : (Filter.comap m g).NeBot\n⊢ g.NeBot","decl":"theorem neBot_of_comap (h : (comap m g).NeBot) : g.NeBot := by\n  rw [neBot_iff] at *\n  contrapose! h\n  rw [h]\n  exact comap_bot\n\n"}
{"name":"Filter.comap_inf_principal_range","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng : Filter β\nm : α → β\n⊢ Eq (Filter.comap m (Min.min g (Filter.principal (Set.range m)))) (Filter.comap m g)","decl":"theorem comap_inf_principal_range : comap m (g ⊓ 𝓟 (range m)) = comap m g := by\n  simp\n\n"}
{"name":"Filter.disjoint_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng₁ g₂ : Filter β\nm : α → β\nh : Disjoint g₁ g₂\n⊢ Disjoint (Filter.comap m g₁) (Filter.comap m g₂)","decl":"theorem disjoint_comap (h : Disjoint g₁ g₂) : Disjoint (comap m g₁) (comap m g₂) := by\n  simp only [disjoint_iff, ← comap_inf, h.eq_bot, comap_bot]\n\n"}
{"name":"Filter.comap_iSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Sort u_2\nf : ι → Filter β\nm : α → β\n⊢ Eq (Filter.comap m (iSup f)) (iSup fun i => Filter.comap m (f i))","decl":"theorem comap_iSup {ι} {f : ι → Filter β} {m : α → β} : comap m (iSup f) = ⨆ i, comap m (f i) :=\n  (gc_comap_kernMap m).l_iSup\n\n"}
{"name":"Filter.comap_sSup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set (Filter β)\nm : α → β\n⊢ Eq (Filter.comap m (SupSet.sSup s)) (iSup fun f => iSup fun h => Filter.comap m f)","decl":"theorem comap_sSup {s : Set (Filter β)} {m : α → β} : comap m (sSup s) = ⨆ f ∈ s, comap m f := by\n  simp only [sSup_eq_iSup, comap_iSup, eq_self_iff_true]\n\n"}
{"name":"Filter.comap_sup","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng₁ g₂ : Filter β\nm : α → β\n⊢ Eq (Filter.comap m (Max.max g₁ g₂)) (Max.max (Filter.comap m g₁) (Filter.comap m g₂))","decl":"theorem comap_sup : comap m (g₁ ⊔ g₂) = comap m g₁ ⊔ comap m g₂ := by\n  rw [sup_eq_iSup, comap_iSup, iSup_bool_eq, Bool.cond_true, Bool.cond_false]\n\n"}
{"name":"Filter.map_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\n⊢ Eq (Filter.map m (Filter.comap m f)) (Min.min f (Filter.principal (Set.range m)))","decl":"theorem map_comap (f : Filter β) (m : α → β) : (f.comap m).map m = f ⊓ 𝓟 (range m) := by\n  refine le_antisymm (le_inf map_comap_le <| le_principal_iff.2 range_mem_map) ?_\n  rintro t' ⟨t, ht, sub⟩\n  refine mem_inf_principal.2 (mem_of_superset ht ?_)\n  rintro _ hxt ⟨x, rfl⟩\n  exact sub hxt\n\n"}
{"name":"Filter.map_comap_setCoe_val","module":"Mathlib.Order.Filter.Basic","initialProofState":"β : Type v\nf : Filter β\ns : Set β\n⊢ Eq (Filter.map Subtype.val (Filter.comap Subtype.val f)) (Min.min f (Filter.principal s))","decl":"theorem map_comap_setCoe_val (f : Filter β) (s : Set β) :\n    (f.comap ((↑) : s → β)).map (↑) = f ⊓ 𝓟 s := by\n  rw [map_comap, Subtype.range_val]\n\n"}
{"name":"Filter.map_comap_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\nhf : Membership.mem f (Set.range m)\n⊢ Eq (Filter.map m (Filter.comap m f)) f","decl":"theorem map_comap_of_mem {f : Filter β} {m : α → β} (hf : range m ∈ f) : (f.comap m).map m = f := by\n  rw [map_comap, inf_eq_left.2 (le_principal_iff.2 hf)]\n\n"}
{"name":"Filter.canLift","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nc : β → α\np : α → Prop\ninst✝ : CanLift α β c p\n⊢ CanLift (Filter α) (Filter β) (Filter.map c) fun f => Filter.Eventually (fun x => p x) f","decl":"instance canLift (c) (p) [CanLift α β c p] :\n    CanLift (Filter α) (Filter β) (map c) fun f => ∀ᶠ x : α in f, p x where\n  prf f hf := ⟨comap c f, map_comap_of_mem <| hf.mono CanLift.prf⟩\n\n"}
{"name":"Filter.comap_le_comap_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : Filter β\nm : α → β\nhf : Membership.mem f (Set.range m)\n⊢ Iff (LE.le (Filter.comap m f) (Filter.comap m g)) (LE.le f g)","decl":"theorem comap_le_comap_iff {f g : Filter β} {m : α → β} (hf : range m ∈ f) :\n    comap m f ≤ comap m g ↔ f ≤ g :=\n  ⟨fun h => map_comap_of_mem hf ▸ (map_mono h).trans map_comap_le, fun h => comap_mono h⟩\n\n"}
{"name":"Filter.map_comap_of_surjective","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhf : Function.Surjective f\nl : Filter β\n⊢ Eq (Filter.map f (Filter.comap f l)) l","decl":"theorem map_comap_of_surjective {f : α → β} (hf : Surjective f) (l : Filter β) :\n    map f (comap f l) = l :=\n  map_comap_of_mem <| by simp only [hf.range_eq, univ_mem]\n\n"}
{"name":"Filter.comap_injective","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhf : Function.Surjective f\n⊢ Function.Injective (Filter.comap f)","decl":"theorem comap_injective {f : α → β} (hf : Surjective f) : Injective (comap f) :=\n  LeftInverse.injective <| map_comap_of_surjective hf\n\n"}
{"name":"Function.Surjective.filter_map_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhf : Function.Surjective f\n⊢ Eq (Filter.map f Top.top) Top.top","decl":"theorem _root_.Function.Surjective.filter_map_top {f : α → β} (hf : Surjective f) : map f ⊤ = ⊤ :=\n  (congr_arg _ comap_top).symm.trans <| map_comap_of_surjective hf ⊤\n\n"}
{"name":"Filter.subtype_coe_map_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\nf : Filter α\n⊢ Eq (Filter.map Subtype.val (Filter.comap Subtype.val f)) (Min.min f (Filter.principal s))","decl":"theorem subtype_coe_map_comap (s : Set α) (f : Filter α) :\n    map ((↑) : s → α) (comap ((↑) : s → α) f) = f ⊓ 𝓟 s := by rw [map_comap, Subtype.range_coe]\n\n"}
{"name":"Filter.image_mem_of_mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nc : β → α\nh : Membership.mem f (Set.range c)\nW : Set β\nW_in : Membership.mem (Filter.comap c f) W\n⊢ Membership.mem f (Set.image c W)","decl":"theorem image_mem_of_mem_comap {f : Filter α} {c : β → α} (h : range c ∈ f) {W : Set β}\n    (W_in : W ∈ comap c f) : c '' W ∈ f := by\n  rw [← map_comap_of_mem h]\n  exact image_mem_map W_in\n\n"}
{"name":"Filter.image_coe_mem_of_mem_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\nU : Set α\nh : Membership.mem f U\nW : Set ↑U\nW_in : Membership.mem (Filter.comap Subtype.val f) W\n⊢ Membership.mem f (Set.image Subtype.val W)","decl":"theorem image_coe_mem_of_mem_comap {f : Filter α} {U : Set α} (h : U ∈ f) {W : Set U}\n    (W_in : W ∈ comap ((↑) : U → α) f) : (↑) '' W ∈ f :=\n  image_mem_of_mem_comap (by simp [h]) W_in\n\n"}
{"name":"Filter.comap_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\nh : Function.Injective m\n⊢ Eq (Filter.comap m (Filter.map m f)) f","decl":"theorem comap_map {f : Filter α} {m : α → β} (h : Injective m) : comap m (map m f) = f :=\n  le_antisymm\n    (fun s hs =>\n      mem_of_superset (preimage_mem_comap <| image_mem_map hs) <| by\n        simp only [preimage_image_eq s h, Subset.rfl])\n    le_comap_map\n\n"}
{"name":"Filter.mem_comap_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\ninj : Function.Injective m\nlarge : Membership.mem f (Set.range m)\nS : Set α\n⊢ Iff (Membership.mem (Filter.comap m f) S) (Membership.mem f (Set.image m S))","decl":"theorem mem_comap_iff {f : Filter β} {m : α → β} (inj : Injective m) (large : Set.range m ∈ f)\n    {S : Set α} : S ∈ comap m f ↔ m '' S ∈ f := by\n  rw [← image_mem_map_iff inj, map_comap_of_mem large]\n\n"}
{"name":"Filter.map_le_map_iff_of_injOn","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nl₁ l₂ : Filter α\nf : α → β\ns : Set α\nh₁ : Membership.mem l₁ s\nh₂ : Membership.mem l₂ s\nhinj : Set.InjOn f s\n⊢ Iff (LE.le (Filter.map f l₁) (Filter.map f l₂)) (LE.le l₁ l₂)","decl":"theorem map_le_map_iff_of_injOn {l₁ l₂ : Filter α} {f : α → β} {s : Set α} (h₁ : s ∈ l₁)\n    (h₂ : s ∈ l₂) (hinj : InjOn f s) : map f l₁ ≤ map f l₂ ↔ l₁ ≤ l₂ :=\n  ⟨fun h _t ht =>\n    mp_mem h₁ <|\n      mem_of_superset (h <| image_mem_map (inter_mem h₂ ht)) fun _y ⟨_x, ⟨hxs, hxt⟩, hxy⟩ hys =>\n        hinj hxs hys hxy ▸ hxt,\n    fun h => map_mono h⟩\n\n"}
{"name":"Filter.map_le_map_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : Filter α\nm : α → β\nhm : Function.Injective m\n⊢ Iff (LE.le (Filter.map m f) (Filter.map m g)) (LE.le f g)","decl":"theorem map_le_map_iff {f g : Filter α} {m : α → β} (hm : Injective m) :\n    map m f ≤ map m g ↔ f ≤ g := by rw [map_le_iff_le_comap, comap_map hm]\n\n"}
{"name":"Filter.map_eq_map_iff_of_injOn","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : Filter α\nm : α → β\ns : Set α\nhsf : Membership.mem f s\nhsg : Membership.mem g s\nhm : Set.InjOn m s\n⊢ Iff (Eq (Filter.map m f) (Filter.map m g)) (Eq f g)","decl":"theorem map_eq_map_iff_of_injOn {f g : Filter α} {m : α → β} {s : Set α} (hsf : s ∈ f) (hsg : s ∈ g)\n    (hm : InjOn m s) : map m f = map m g ↔ f = g := by\n  simp only [le_antisymm_iff, map_le_map_iff_of_injOn hsf hsg hm,\n    map_le_map_iff_of_injOn hsg hsf hm]\n\n"}
{"name":"Filter.map_inj","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : Filter α\nm : α → β\nhm : Function.Injective m\n⊢ Iff (Eq (Filter.map m f) (Filter.map m g)) (Eq f g)","decl":"theorem map_inj {f g : Filter α} {m : α → β} (hm : Injective m) : map m f = map m g ↔ f = g :=\n  map_eq_map_iff_of_injOn univ_mem univ_mem hm.injOn\n\n"}
{"name":"Filter.map_injective","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nhm : Function.Injective m\n⊢ Function.Injective (Filter.map m)","decl":"theorem map_injective {m : α → β} (hm : Injective m) : Injective (map m) := fun _ _ =>\n  (map_inj hm).1\n\n"}
{"name":"Filter.comap_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\n⊢ Iff (Filter.comap m f).NeBot (∀ (t : Set β), Membership.mem f t → Exists fun a => Membership.mem t (m a))","decl":"theorem comap_neBot_iff {f : Filter β} {m : α → β} : NeBot (comap m f) ↔ ∀ t ∈ f, ∃ a, m a ∈ t := by\n  simp only [← forall_mem_nonempty_iff_neBot, mem_comap, forall_exists_index, and_imp]\n  exact ⟨fun h t t_in => h (m ⁻¹' t) t t_in Subset.rfl, fun h s t ht hst => (h t ht).imp hst⟩\n\n"}
{"name":"Filter.comap_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\nhm : ∀ (t : Set β), Membership.mem f t → Exists fun a => Membership.mem t (m a)\n⊢ (Filter.comap m f).NeBot","decl":"theorem comap_neBot {f : Filter β} {m : α → β} (hm : ∀ t ∈ f, ∃ a, m a ∈ t) : NeBot (comap m f) :=\n  comap_neBot_iff.mpr hm\n\n"}
{"name":"Filter.comap_neBot_iff_frequently","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\n⊢ Iff (Filter.comap m f).NeBot (Filter.Frequently (fun y => Membership.mem (Set.range m) y) f)","decl":"theorem comap_neBot_iff_frequently {f : Filter β} {m : α → β} :\n    NeBot (comap m f) ↔ ∃ᶠ y in f, y ∈ range m := by\n  simp only [comap_neBot_iff, frequently_iff, mem_range, @and_comm (_ ∈ _), exists_exists_eq_and]\n\n"}
{"name":"Filter.comap_neBot_iff_compl_range","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\n⊢ Iff (Filter.comap m f).NeBot (Not (Membership.mem f (HasCompl.compl (Set.range m))))","decl":"theorem comap_neBot_iff_compl_range {f : Filter β} {m : α → β} :\n    NeBot (comap m f) ↔ (range m)ᶜ ∉ f :=\n  comap_neBot_iff_frequently\n\n"}
{"name":"Filter.comap_eq_bot_iff_compl_range","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\n⊢ Iff (Eq (Filter.comap m f) Bot.bot) (Membership.mem f (HasCompl.compl (Set.range m)))","decl":"theorem comap_eq_bot_iff_compl_range {f : Filter β} {m : α → β} : comap m f = ⊥ ↔ (range m)ᶜ ∈ f :=\n  not_iff_not.mp <| neBot_iff.symm.trans comap_neBot_iff_compl_range\n\n"}
{"name":"Filter.comap_surjective_eq_bot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\nhm : Function.Surjective m\n⊢ Iff (Eq (Filter.comap m f) Bot.bot) (Eq f Bot.bot)","decl":"theorem comap_surjective_eq_bot {f : Filter β} {m : α → β} (hm : Surjective m) :\n    comap m f = ⊥ ↔ f = ⊥ := by\n  rw [comap_eq_bot_iff_compl_range, hm.range_eq, compl_univ, empty_mem_iff_bot]\n\n"}
{"name":"Filter.disjoint_comap_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng₁ g₂ : Filter β\nm : α → β\nh : Function.Surjective m\n⊢ Iff (Disjoint (Filter.comap m g₁) (Filter.comap m g₂)) (Disjoint g₁ g₂)","decl":"theorem disjoint_comap_iff (h : Surjective m) :\n    Disjoint (comap m g₁) (comap m g₂) ↔ Disjoint g₁ g₂ := by\n  rw [disjoint_iff, disjoint_iff, ← comap_inf, comap_surjective_eq_bot h]\n\n"}
{"name":"Filter.NeBot.comap_of_range_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\nx✝ : f.NeBot\nhm : Membership.mem f (Set.range m)\n⊢ (Filter.comap m f).NeBot","decl":"theorem NeBot.comap_of_range_mem {f : Filter β} {m : α → β} (_ : NeBot f) (hm : range m ∈ f) :\n    NeBot (comap m f) :=\n  comap_neBot_iff_frequently.2 <| Eventually.frequently hm\n\n"}
{"name":"Filter.comap_fst_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\n⊢ Iff (Filter.comap Prod.fst f).NeBot (And f.NeBot (Nonempty β))","decl":"@[simp]\ntheorem comap_fst_neBot_iff {f : Filter α} :\n    (f.comap (Prod.fst : α × β → α)).NeBot ↔ f.NeBot ∧ Nonempty β := by\n  cases isEmpty_or_nonempty β\n  · rw [filter_eq_bot_of_isEmpty (f.comap _), ← not_iff_not]; simp [*]\n  · simp [comap_neBot_iff_frequently, *]\n\n"}
{"name":"Filter.comap_fst_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Nonempty β\nf : Filter α\ninst✝ : f.NeBot\n⊢ (Filter.comap Prod.fst f).NeBot","decl":"@[instance]\ntheorem comap_fst_neBot [Nonempty β] {f : Filter α} [NeBot f] :\n    (f.comap (Prod.fst : α × β → α)).NeBot :=\n  comap_fst_neBot_iff.2 ⟨‹_›, ‹_›⟩\n\n"}
{"name":"Filter.comap_snd_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\n⊢ Iff (Filter.comap Prod.snd f).NeBot (And (Nonempty α) f.NeBot)","decl":"@[simp]\ntheorem comap_snd_neBot_iff {f : Filter β} :\n    (f.comap (Prod.snd : α × β → β)).NeBot ↔ Nonempty α ∧ f.NeBot := by\n  cases' isEmpty_or_nonempty α with hα hα\n  · rw [filter_eq_bot_of_isEmpty (f.comap _), ← not_iff_not]; simp\n  · simp [comap_neBot_iff_frequently, hα]\n\n"}
{"name":"Filter.comap_snd_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Nonempty α\nf : Filter β\ninst✝ : f.NeBot\n⊢ (Filter.comap Prod.snd f).NeBot","decl":"@[instance]\ntheorem comap_snd_neBot [Nonempty α] {f : Filter β} [NeBot f] :\n    (f.comap (Prod.snd : α × β → β)).NeBot :=\n  comap_snd_neBot_iff.2 ⟨‹_›, ‹_›⟩\n\n"}
{"name":"Filter.comap_eval_neBot_iff'","module":"Mathlib.Order.Filter.Basic","initialProofState":"ι : Type u_2\nα : ι → Type u_3\ni : ι\nf : Filter (α i)\n⊢ Iff (Filter.comap (Function.eval i) f).NeBot (And (∀ (j : ι), Nonempty (α j)) f.NeBot)","decl":"theorem comap_eval_neBot_iff' {ι : Type*} {α : ι → Type*} {i : ι} {f : Filter (α i)} :\n    (comap (eval i) f).NeBot ↔ (∀ j, Nonempty (α j)) ∧ NeBot f := by\n  cases' isEmpty_or_nonempty (∀ j, α j) with H H\n  · rw [filter_eq_bot_of_isEmpty (f.comap _), ← not_iff_not]\n    simp [← Classical.nonempty_pi]\n  · have : ∀ j, Nonempty (α j) := Classical.nonempty_pi.1 H\n    simp [comap_neBot_iff_frequently, *]\n\n"}
{"name":"Filter.comap_eval_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"ι : Type u_2\nα : ι → Type u_3\ninst✝ : ∀ (j : ι), Nonempty (α j)\ni : ι\nf : Filter (α i)\n⊢ Iff (Filter.comap (Function.eval i) f).NeBot f.NeBot","decl":"@[simp]\ntheorem comap_eval_neBot_iff {ι : Type*} {α : ι → Type*} [∀ j, Nonempty (α j)] {i : ι}\n    {f : Filter (α i)} : (comap (eval i) f).NeBot ↔ NeBot f := by simp [comap_eval_neBot_iff', *]\n\n"}
{"name":"Filter.comap_eval_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"ι : Type u_2\nα : ι → Type u_3\ninst✝¹ : ∀ (j : ι), Nonempty (α j)\ni : ι\nf : Filter (α i)\ninst✝ : f.NeBot\n⊢ (Filter.comap (Function.eval i) f).NeBot","decl":"@[instance]\ntheorem comap_eval_neBot {ι : Type*} {α : ι → Type*} [∀ j, Nonempty (α j)] (i : ι)\n    (f : Filter (α i)) [NeBot f] : (comap (eval i) f).NeBot :=\n  comap_eval_neBot_iff.2 ‹_›\n\n"}
{"name":"Filter.comap_coe_neBot_of_le_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"γ : Type w\ns : Set γ\nl : Filter γ\nh : l.NeBot\nh' : LE.le l (Filter.principal s)\n⊢ (Filter.comap Subtype.val l).NeBot","decl":"theorem comap_coe_neBot_of_le_principal {s : Set γ} {l : Filter γ} [h : NeBot l] (h' : l ≤ 𝓟 s) :\n    NeBot (comap ((↑) : s → γ) l) :=\n  h.comap_of_range_mem <| (@Subtype.range_coe γ s).symm ▸ h' (mem_principal_self s)\n\n"}
{"name":"Filter.NeBot.comap_of_surj","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\nhf : f.NeBot\nhm : Function.Surjective m\n⊢ (Filter.comap m f).NeBot","decl":"theorem NeBot.comap_of_surj {f : Filter β} {m : α → β} (hf : NeBot f) (hm : Surjective m) :\n    NeBot (comap m f) :=\n  hf.comap_of_range_mem <| univ_mem' hm\n\n"}
{"name":"Filter.NeBot.comap_of_image_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\nhf : f.NeBot\ns : Set α\nhs : Membership.mem f (Set.image m s)\n⊢ (Filter.comap m f).NeBot","decl":"theorem NeBot.comap_of_image_mem {f : Filter β} {m : α → β} (hf : NeBot f) {s : Set α}\n    (hs : m '' s ∈ f) : NeBot (comap m f) :=\n  hf.comap_of_range_mem <| mem_of_superset hs (image_subset_range _ _)\n\n"}
{"name":"Filter.map_eq_bot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\n⊢ Iff (Eq (Filter.map m f) Bot.bot) (Eq f Bot.bot)","decl":"@[simp]\ntheorem map_eq_bot_iff : map m f = ⊥ ↔ f = ⊥ :=\n  ⟨by\n    rw [← empty_mem_iff_bot, ← empty_mem_iff_bot]\n    exact id, fun h => by simp only [h, map_bot]⟩\n\n"}
{"name":"Filter.map_neBot_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nF : Filter α\n⊢ Iff (Filter.map f F).NeBot F.NeBot","decl":"theorem map_neBot_iff (f : α → β) {F : Filter α} : NeBot (map f F) ↔ NeBot F := by\n  simp only [neBot_iff, Ne, map_eq_bot_iff]\n\n"}
{"name":"Filter.NeBot.map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nhf : f.NeBot\nm : α → β\n⊢ (Filter.map m f).NeBot","decl":"theorem NeBot.map (hf : NeBot f) (m : α → β) : NeBot (map m f) :=\n  (map_neBot_iff m).2 hf\n\n"}
{"name":"Filter.NeBot.of_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\na✝ : (Filter.map m f).NeBot\n⊢ f.NeBot","decl":"theorem NeBot.of_map : NeBot (f.map m) → NeBot f :=\n  (map_neBot_iff m).1\n\n"}
{"name":"Filter.map_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\nhf : f.NeBot\n⊢ (Filter.map m f).NeBot","decl":"instance map_neBot [hf : NeBot f] : NeBot (f.map m) :=\n  hf.map m\n\n"}
{"name":"Filter.sInter_comap_sets","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nF : Filter β\n⊢ Eq (Filter.comap f F).sets.sInter (Set.iInter fun U => Set.iInter fun h => Set.preimage f U)","decl":"theorem sInter_comap_sets (f : α → β) (F : Filter β) : ⋂₀ (comap f F).sets = ⋂ U ∈ F, f ⁻¹' U := by\n  ext x\n  suffices (∀ (A : Set α) (B : Set β), B ∈ F → f ⁻¹' B ⊆ A → x ∈ A) ↔\n      ∀ B : Set β, B ∈ F → f x ∈ B by\n    simp only [mem_sInter, mem_iInter, Filter.mem_sets, mem_comap, this, and_imp, exists_prop,\n      mem_preimage, exists_imp]\n  constructor\n  · intro h U U_in\n    simpa only [Subset.rfl, forall_prop_of_true, mem_preimage] using h (f ⁻¹' U) U U_in\n  · intro h V U U_in f_U_V\n    exact f_U_V (h U U_in)\n\n"}
{"name":"Filter.map_iInf_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Sort x\nf : ι → Filter α\nm : α → β\n⊢ LE.le (Filter.map m (iInf f)) (iInf fun i => Filter.map m (f i))","decl":"theorem map_iInf_le {f : ι → Filter α} {m : α → β} : map m (iInf f) ≤ ⨅ i, map m (f i) :=\n  le_iInf fun _ => map_mono <| iInf_le _ _\n\n"}
{"name":"Filter.map_iInf_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Sort x\nf : ι → Filter α\nm : α → β\nhf : Directed (fun x1 x2 => GE.ge x1 x2) f\ninst✝ : Nonempty ι\n⊢ Eq (Filter.map m (iInf f)) (iInf fun i => Filter.map m (f i))","decl":"theorem map_iInf_eq {f : ι → Filter α} {m : α → β} (hf : Directed (· ≥ ·) f) [Nonempty ι] :\n    map m (iInf f) = ⨅ i, map m (f i) :=\n  map_iInf_le.antisymm fun s (hs : m ⁻¹' s ∈ iInf f) =>\n    let ⟨i, hi⟩ := (mem_iInf_of_directed hf _).1 hs\n    have : ⨅ i, map m (f i) ≤ 𝓟 s :=\n      iInf_le_of_le i <| by simpa only [le_principal_iff, mem_map]\n    Filter.le_principal_iff.1 this\n\n"}
{"name":"Filter.map_biInf_eq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nι : Type w\nf : ι → Filter α\nm : α → β\np : ι → Prop\nh : DirectedOn (Order.Preimage f fun x1 x2 => GE.ge x1 x2) (setOf fun x => p x)\nne : Exists fun i => p i\n⊢ Eq (Filter.map m (iInf fun i => iInf fun x => f i)) (iInf fun i => iInf fun x => Filter.map m (f i))","decl":"theorem map_biInf_eq {ι : Type w} {f : ι → Filter α} {m : α → β} {p : ι → Prop}\n    (h : DirectedOn (f ⁻¹'o (· ≥ ·)) { x | p x }) (ne : ∃ i, p i) :\n    map m (⨅ (i) (_ : p i), f i) = ⨅ (i) (_ : p i), map m (f i) := by\n  haveI := nonempty_subtype.2 ne\n  simp only [iInf_subtype']\n  exact map_iInf_eq h.directed_val\n\n"}
{"name":"Filter.map_inf_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : Filter α\nm : α → β\n⊢ LE.le (Filter.map m (Min.min f g)) (Min.min (Filter.map m f) (Filter.map m g))","decl":"theorem map_inf_le {f g : Filter α} {m : α → β} : map m (f ⊓ g) ≤ map m f ⊓ map m g :=\n  (@map_mono _ _ m).map_inf_le f g\n\n"}
{"name":"Filter.map_inf","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : Filter α\nm : α → β\nh : Function.Injective m\n⊢ Eq (Filter.map m (Min.min f g)) (Min.min (Filter.map m f) (Filter.map m g))","decl":"theorem map_inf {f g : Filter α} {m : α → β} (h : Injective m) :\n    map m (f ⊓ g) = map m f ⊓ map m g := by\n  refine map_inf_le.antisymm ?_\n  rintro t ⟨s₁, hs₁, s₂, hs₂, ht : m ⁻¹' t = s₁ ∩ s₂⟩\n  refine mem_inf_of_inter (image_mem_map hs₁) (image_mem_map hs₂) ?_\n  rw [← image_inter h, image_subset_iff, ht]\n\n"}
{"name":"Filter.map_inf'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : Filter α\nm : α → β\nt : Set α\nhtf : Membership.mem f t\nhtg : Membership.mem g t\nh : Set.InjOn m t\n⊢ Eq (Filter.map m (Min.min f g)) (Min.min (Filter.map m f) (Filter.map m g))","decl":"theorem map_inf' {f g : Filter α} {m : α → β} {t : Set α} (htf : t ∈ f) (htg : t ∈ g)\n    (h : InjOn m t) : map m (f ⊓ g) = map m f ⊓ map m g := by\n  lift f to Filter t using htf; lift g to Filter t using htg\n  replace h : Injective (m ∘ ((↑) : t → α)) := h.injective\n  simp only [map_map, ← map_inf Subtype.coe_injective, map_inf h]\n\n"}
{"name":"Filter.disjoint_of_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nF G : Filter α\nf : α → β\nh : Disjoint (Filter.map f F) (Filter.map f G)\n⊢ Disjoint F G","decl":"lemma disjoint_of_map {α β : Type*} {F G : Filter α} {f : α → β}\n    (h : Disjoint (map f F) (map f G)) : Disjoint F G :=\n  disjoint_iff.mpr <| map_eq_bot_iff.mp <| le_bot_iff.mp <| trans map_inf_le (disjoint_iff.mp h)\n\n"}
{"name":"Filter.disjoint_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nm : α → β\nhm : Function.Injective m\nf₁ f₂ : Filter α\n⊢ Iff (Disjoint (Filter.map m f₁) (Filter.map m f₂)) (Disjoint f₁ f₂)","decl":"theorem disjoint_map {m : α → β} (hm : Injective m) {f₁ f₂ : Filter α} :\n    Disjoint (map m f₁) (map m f₂) ↔ Disjoint f₁ f₂ := by\n  simp only [disjoint_iff, ← map_inf hm, map_eq_bot_iff]\n\n"}
{"name":"Filter.map_equiv_symm","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\nf : Filter β\n⊢ Eq (Filter.map (⇑e.symm) f) (Filter.comap (⇑e) f)","decl":"theorem map_equiv_symm (e : α ≃ β) (f : Filter β) : map e.symm f = comap e f :=\n  map_injective e.injective <| by\n    rw [map_map, e.self_comp_symm, map_id, map_comap_of_surjective e.surjective]\n\n"}
{"name":"Filter.map_eq_comap_of_inverse","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\nn : β → α\nh₁ : Eq (Function.comp m n) id\nh₂ : Eq (Function.comp n m) id\n⊢ Eq (Filter.map m f) (Filter.comap n f)","decl":"theorem map_eq_comap_of_inverse {f : Filter α} {m : α → β} {n : β → α} (h₁ : m ∘ n = id)\n    (h₂ : n ∘ m = id) : map m f = comap n f :=\n  map_equiv_symm ⟨n, m, congr_fun h₁, congr_fun h₂⟩ f\n\n"}
{"name":"Filter.comap_equiv_symm","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\nf : Filter α\n⊢ Eq (Filter.comap (⇑e.symm) f) (Filter.map (⇑e) f)","decl":"theorem comap_equiv_symm (e : α ≃ β) (f : Filter α) : comap e.symm f = map e f :=\n  (map_eq_comap_of_inverse e.self_comp_symm e.symm_comp_self).symm\n\n"}
{"name":"Filter.map_swap_eq_comap_swap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter (Prod α β)\n⊢ Eq (Functor.map Prod.swap f) (Filter.comap Prod.swap f)","decl":"theorem map_swap_eq_comap_swap {f : Filter (α × β)} : Prod.swap <$> f = comap Prod.swap f :=\n  map_eq_comap_of_inverse Prod.swap_swap_eq Prod.swap_swap_eq\n\n"}
{"name":"Filter.map_swap4_eq_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_1\nf : Filter (Prod (Prod α β) (Prod γ δ))\n⊢ Eq (Filter.map (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) f) (Filter.comap (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) f)","decl":"/-- A useful lemma when dealing with uniformities. -/\ntheorem map_swap4_eq_comap {f : Filter ((α × β) × γ × δ)} :\n    map (fun p : (α × β) × γ × δ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) f =\n      comap (fun p : (α × γ) × β × δ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) f :=\n  map_eq_comap_of_inverse (funext fun ⟨⟨_, _⟩, ⟨_, _⟩⟩ => rfl) (funext fun ⟨⟨_, _⟩, ⟨_, _⟩⟩ => rfl)\n\n"}
{"name":"Filter.le_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\ng : Filter β\nh : ∀ (s : Set α), Membership.mem f s → Membership.mem g (Set.image m s)\n⊢ LE.le g (Filter.map m f)","decl":"theorem le_map {f : Filter α} {m : α → β} {g : Filter β} (h : ∀ s ∈ f, m '' s ∈ g) : g ≤ f.map m :=\n  fun _ hs => mem_of_superset (h _ hs) <| image_preimage_subset _ _\n\n"}
{"name":"Filter.le_map_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → β\ng : Filter β\n⊢ Iff (LE.le g (Filter.map m f)) (∀ (s : Set α), Membership.mem f s → Membership.mem g (Set.image m s))","decl":"theorem le_map_iff {f : Filter α} {m : α → β} {g : Filter β} : g ≤ f.map m ↔ ∀ s ∈ f, m '' s ∈ g :=\n  ⟨fun h _ hs => h (image_mem_map hs), le_map⟩\n\n"}
{"name":"Filter.push_pull","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nF : Filter α\nG : Filter β\n⊢ Eq (Filter.map f (Min.min F (Filter.comap f G))) (Min.min (Filter.map f F) G)","decl":"protected theorem push_pull (f : α → β) (F : Filter α) (G : Filter β) :\n    map f (F ⊓ comap f G) = map f F ⊓ G := by\n  apply le_antisymm\n  · calc\n      map f (F ⊓ comap f G) ≤ map f F ⊓ (map f <| comap f G) := map_inf_le\n      _ ≤ map f F ⊓ G := inf_le_inf_left (map f F) map_comap_le\n\n  · rintro U ⟨V, V_in, W, ⟨Z, Z_in, hZ⟩, h⟩\n    apply mem_inf_of_inter (image_mem_map V_in) Z_in\n    calc\n      f '' V ∩ Z = f '' (V ∩ f ⁻¹' Z) := by rw [image_inter_preimage]\n      _ ⊆ f '' (V ∩ W) := image_subset _ (inter_subset_inter_right _ ‹_›)\n      _ = f '' (f ⁻¹' U) := by rw [h]\n      _ ⊆ U := image_preimage_subset f U\n\n"}
{"name":"Filter.push_pull'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nF : Filter α\nG : Filter β\n⊢ Eq (Filter.map f (Min.min (Filter.comap f G) F)) (Min.min G (Filter.map f F))","decl":"protected theorem push_pull' (f : α → β) (F : Filter α) (G : Filter β) :\n    map f (comap f G ⊓ F) = G ⊓ map f F := by simp only [Filter.push_pull, inf_comm]\n\n"}
{"name":"Filter.disjoint_comap_iff_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nF : Filter α\nG : Filter β\n⊢ Iff (Disjoint F (Filter.comap f G)) (Disjoint (Filter.map f F) G)","decl":"theorem disjoint_comap_iff_map {f : α → β} {F : Filter α} {G : Filter β} :\n    Disjoint F (comap f G) ↔ Disjoint (map f F) G := by\n  simp only [disjoint_iff, ← Filter.push_pull, map_eq_bot_iff]\n\n"}
{"name":"Filter.disjoint_comap_iff_map'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nF : Filter α\nG : Filter β\n⊢ Iff (Disjoint (Filter.comap f G) F) (Disjoint G (Filter.map f F))","decl":"theorem disjoint_comap_iff_map' {f : α → β} {F : Filter α} {G : Filter β} :\n    Disjoint (comap f G) F ↔ Disjoint G (map f F) := by\n  simp only [disjoint_iff, ← Filter.push_pull', map_eq_bot_iff]\n\n"}
{"name":"Filter.neBot_inf_comap_iff_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nF : Filter α\nG : Filter β\n⊢ Iff (Min.min F (Filter.comap f G)).NeBot (Min.min (Filter.map f F) G).NeBot","decl":"theorem neBot_inf_comap_iff_map {f : α → β} {F : Filter α} {G : Filter β} :\n    NeBot (F ⊓ comap f G) ↔ NeBot (map f F ⊓ G) := by\n  rw [← map_neBot_iff, Filter.push_pull]\n\n"}
{"name":"Filter.neBot_inf_comap_iff_map'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nF : Filter α\nG : Filter β\n⊢ Iff (Min.min (Filter.comap f G) F).NeBot (Min.min G (Filter.map f F)).NeBot","decl":"theorem neBot_inf_comap_iff_map' {f : α → β} {F : Filter α} {G : Filter β} :\n    NeBot (comap f G ⊓ F) ↔ NeBot (G ⊓ map f F) := by\n  rw [← map_neBot_iff, Filter.push_pull']\n\n"}
{"name":"Filter.comap_inf_principal_neBot_of_image_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter β\nm : α → β\nhf : f.NeBot\ns : Set α\nhs : Membership.mem f (Set.image m s)\n⊢ (Min.min (Filter.comap m f) (Filter.principal s)).NeBot","decl":"theorem comap_inf_principal_neBot_of_image_mem {f : Filter β} {m : α → β} (hf : NeBot f) {s : Set α}\n    (hs : m '' s ∈ f) : NeBot (comap m f ⊓ 𝓟 s) := by\n  rw [neBot_inf_comap_iff_map', map_principal, ← frequently_mem_iff_neBot]\n  exact Eventually.frequently hs\n\n"}
{"name":"Filter.principal_eq_map_coe_top","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Eq (Filter.principal s) (Filter.map Subtype.val Top.top)","decl":"theorem principal_eq_map_coe_top (s : Set α) : 𝓟 s = map ((↑) : s → α) ⊤ := by simp\n\n"}
{"name":"Filter.inf_principal_eq_bot_iff_comap","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nF : Filter α\ns : Set α\n⊢ Iff (Eq (Min.min F (Filter.principal s)) Bot.bot) (Eq (Filter.comap Subtype.val F) Bot.bot)","decl":"theorem inf_principal_eq_bot_iff_comap {F : Filter α} {s : Set α} :\n    F ⊓ 𝓟 s = ⊥ ↔ comap ((↑) : s → α) F = ⊥ := by\n  rw [principal_eq_map_coe_top s, ← Filter.push_pull', inf_top_eq, map_eq_bot_iff]\n\n"}
{"name":"Filter.singleton_mem_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\na : α\n⊢ Membership.mem (Pure.pure a) (Singleton.singleton a)","decl":"theorem singleton_mem_pure {a : α} : {a} ∈ (pure a : Filter α) :=\n  mem_singleton a\n\n"}
{"name":"Filter.pure_injective","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\n⊢ Function.Injective Pure.pure","decl":"theorem pure_injective : Injective (pure : α → Filter α) := fun a _ hab =>\n  (Filter.ext_iff.1 hab { x | a = x }).1 rfl\n\n"}
{"name":"Filter.pure_neBot","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\na : α\n⊢ (Pure.pure a).NeBot","decl":"instance pure_neBot {α : Type u} {a : α} : NeBot (pure a) :=\n  ⟨mt empty_mem_iff_bot.2 <| not_mem_empty a⟩\n\n"}
{"name":"Filter.le_pure_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nf : Filter α\na : α\n⊢ Iff (LE.le f (Pure.pure a)) (Membership.mem f (Singleton.singleton a))","decl":"@[simp]\ntheorem le_pure_iff {f : Filter α} {a : α} : f ≤ pure a ↔ {a} ∈ f := by\n  rw [← principal_singleton, le_principal_iff]\n\n"}
{"name":"Filter.mem_seq_def","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter (α → β)\ng : Filter α\ns : Set β\n⊢ Iff (Membership.mem (f.seq g) s) (Exists fun u => And (Membership.mem f u) (Exists fun t => And (Membership.mem g t) (∀ (x : α → β), Membership.mem u x → ∀ (y : α), Membership.mem t y → Membership.mem s (x y))))","decl":"theorem mem_seq_def {f : Filter (α → β)} {g : Filter α} {s : Set β} :\n    s ∈ f.seq g ↔ ∃ u ∈ f, ∃ t ∈ g, ∀ x ∈ u, ∀ y ∈ t, (x : α → β) y ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_seq_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter (α → β)\ng : Filter α\ns : Set β\n⊢ Iff (Membership.mem (f.seq g) s) (Exists fun u => And (Membership.mem f u) (Exists fun t => And (Membership.mem g t) (HasSubset.Subset (u.seq t) s)))","decl":"theorem mem_seq_iff {f : Filter (α → β)} {g : Filter α} {s : Set β} :\n    s ∈ f.seq g ↔ ∃ u ∈ f, ∃ t ∈ g, Set.seq u t ⊆ s := by\n  simp only [mem_seq_def, seq_subset, exists_prop]\n\n"}
{"name":"Filter.mem_map_seq_iff","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Filter α\ng : Filter β\nm : α → β → γ\ns : Set γ\n⊢ Iff (Membership.mem ((Filter.map m f).seq g) s) (Exists fun t => Exists fun u => And (Membership.mem g t) (And (Membership.mem f u) (∀ (x : α), Membership.mem u x → ∀ (y : β), Membership.mem t y → Membership.mem s (m x y))))","decl":"theorem mem_map_seq_iff {f : Filter α} {g : Filter β} {m : α → β → γ} {s : Set γ} :\n    s ∈ (f.map m).seq g ↔ ∃ t u, t ∈ g ∧ u ∈ f ∧ ∀ x ∈ u, ∀ y ∈ t, m x y ∈ s :=\n  Iff.intro (fun ⟨t, ht, s, hs, hts⟩ => ⟨s, m ⁻¹' t, hs, ht, fun _ => hts _⟩)\n    fun ⟨t, s, ht, hs, hts⟩ =>\n    ⟨m '' s, image_mem_map hs, t, ht, fun _ ⟨_, has, Eq⟩ => Eq ▸ hts _ has⟩\n\n"}
{"name":"Filter.seq_mem_seq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter (α → β)\ng : Filter α\ns : Set (α → β)\nt : Set α\nhs : Membership.mem f s\nht : Membership.mem g t\n⊢ Membership.mem (f.seq g) (s.seq t)","decl":"theorem seq_mem_seq {f : Filter (α → β)} {g : Filter α} {s : Set (α → β)} {t : Set α} (hs : s ∈ f)\n    (ht : t ∈ g) : s.seq t ∈ f.seq g :=\n  ⟨s, hs, t, ht, fun f hf a ha => ⟨f, hf, a, ha, rfl⟩⟩\n\n"}
{"name":"Filter.le_seq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter (α → β)\ng : Filter α\nh : Filter β\nhh : ∀ (t : Set (α → β)), Membership.mem f t → ∀ (u : Set α), Membership.mem g u → Membership.mem h (t.seq u)\n⊢ LE.le h (f.seq g)","decl":"theorem le_seq {f : Filter (α → β)} {g : Filter α} {h : Filter β}\n    (hh : ∀ t ∈ f, ∀ u ∈ g, Set.seq t u ∈ h) : h ≤ seq f g := fun _ ⟨_, ht, _, hu, hs⟩ =>\n  mem_of_superset (hh _ ht _ hu) fun _ ⟨_, hm, _, ha, eq⟩ => eq ▸ hs _ hm _ ha\n\n"}
{"name":"Filter.seq_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf₁ f₂ : Filter (α → β)\ng₁ g₂ : Filter α\nhf : LE.le f₁ f₂\nhg : LE.le g₁ g₂\n⊢ LE.le (f₁.seq g₁) (f₂.seq g₂)","decl":"@[mono]\ntheorem seq_mono {f₁ f₂ : Filter (α → β)} {g₁ g₂ : Filter α} (hf : f₁ ≤ f₂) (hg : g₁ ≤ g₂) :\n    f₁.seq g₁ ≤ f₂.seq g₂ :=\n  le_seq fun _ hs _ ht => seq_mem_seq (hf hs) (hg ht)\n\n"}
{"name":"Filter.pure_seq_eq_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ng : α → β\nf : Filter α\n⊢ Eq ((Pure.pure g).seq f) (Filter.map g f)","decl":"@[simp]\ntheorem pure_seq_eq_map (g : α → β) (f : Filter α) : seq (pure g) f = f.map g := by\n  refine le_antisymm (le_map fun s hs => ?_) (le_seq fun s hs t ht => ?_)\n  · rw [← singleton_seq]\n    apply seq_mem_seq _ hs\n    exact singleton_mem_pure\n  · refine sets_of_superset (map g f) (image_mem_map ht) ?_\n    rintro b ⟨a, ha, rfl⟩\n    exact ⟨g, hs, a, ha, rfl⟩\n\n"}
{"name":"Filter.seq_pure","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter (α → β)\na : α\n⊢ Eq (f.seq (Pure.pure a)) (Filter.map (fun g => g a) f)","decl":"@[simp]\ntheorem seq_pure (f : Filter (α → β)) (a : α) : seq f (pure a) = map (fun g : α → β => g a) f := by\n  refine le_antisymm (le_map fun s hs => ?_) (le_seq fun s hs t ht => ?_)\n  · rw [← seq_singleton]\n    exact seq_mem_seq hs singleton_mem_pure\n  · refine sets_of_superset (map (fun g : α → β => g a) f) (image_mem_map hs) ?_\n    rintro b ⟨g, hg, rfl⟩\n    exact ⟨g, hg, a, ht, rfl⟩\n\n"}
{"name":"Filter.seq_assoc","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nx : Filter α\ng : Filter (α → β)\nh : Filter (β → γ)\n⊢ Eq (h.seq (g.seq x)) (((Filter.map (fun x1 x2 => Function.comp x1 x2) h).seq g).seq x)","decl":"@[simp]\ntheorem seq_assoc (x : Filter α) (g : Filter (α → β)) (h : Filter (β → γ)) :\n    seq h (seq g x) = seq (seq (map (· ∘ ·) h) g) x := by\n  refine le_antisymm (le_seq fun s hs t ht => ?_) (le_seq fun s hs t ht => ?_)\n  · rcases mem_seq_iff.1 hs with ⟨u, hu, v, hv, hs⟩\n    rcases mem_map_iff_exists_image.1 hu with ⟨w, hw, hu⟩\n    refine mem_of_superset ?_ (Set.seq_mono ((Set.seq_mono hu Subset.rfl).trans hs) Subset.rfl)\n    rw [← Set.seq_seq]\n    exact seq_mem_seq hw (seq_mem_seq hv ht)\n  · rcases mem_seq_iff.1 ht with ⟨u, hu, v, hv, ht⟩\n    refine mem_of_superset ?_ (Set.seq_mono Subset.rfl ht)\n    rw [Set.seq_seq]\n    exact seq_mem_seq (seq_mem_seq (image_mem_map hs) hu) hv\n\n"}
{"name":"Filter.prod_map_seq_comm","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\ng : Filter β\n⊢ Eq ((Filter.map Prod.mk f).seq g) ((Filter.map (fun b a => { fst := a, snd := b }) g).seq f)","decl":"theorem prod_map_seq_comm (f : Filter α) (g : Filter β) :\n    (map Prod.mk f).seq g = seq (map (fun b a => (a, b)) g) f := by\n  refine le_antisymm (le_seq fun s hs t ht => ?_) (le_seq fun s hs t ht => ?_)\n  · rcases mem_map_iff_exists_image.1 hs with ⟨u, hu, hs⟩\n    refine mem_of_superset ?_ (Set.seq_mono hs Subset.rfl)\n    rw [← Set.prod_image_seq_comm]\n    exact seq_mem_seq (image_mem_map ht) hu\n  · rcases mem_map_iff_exists_image.1 hs with ⟨u, hu, hs⟩\n    refine mem_of_superset ?_ (Set.seq_mono hs Subset.rfl)\n    rw [Set.prod_image_seq_comm]\n    exact seq_mem_seq (image_mem_map ht) hu\n\n"}
{"name":"Filter.seq_eq_filter_seq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α β : Type u\nf : Filter (α → β)\ng : Filter α\n⊢ Eq (Seq.seq f fun x => g) (f.seq g)","decl":"theorem seq_eq_filter_seq {α β : Type u} (f : Filter (α → β)) (g : Filter α) :\n    f <*> g = seq f g :=\n  rfl\n\n"}
{"name":"Filter.instLawfulApplicative","module":"Mathlib.Order.Filter.Basic","initialProofState":"⊢ LawfulApplicative Filter","decl":"instance : LawfulApplicative (Filter : Type u → Type u) where\n  map_pure := map_pure\n  seqLeft_eq _ _ := rfl\n  seqRight_eq _ _ := rfl\n  seq_pure := seq_pure\n  pure_seq := pure_seq_eq_map\n  seq_assoc := seq_assoc\n\n"}
{"name":"Filter.instCommApplicative","module":"Mathlib.Order.Filter.Basic","initialProofState":"⊢ CommApplicative Filter","decl":"instance : CommApplicative (Filter : Type u → Type u) :=\n  ⟨fun f g => prod_map_seq_comm f g⟩\n\n"}
{"name":"Filter.eventually_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\nm : α → Filter β\np : β → Prop\n⊢ Iff (Filter.Eventually (fun y => p y) (f.bind m)) (Filter.Eventually (fun x => Filter.Eventually (fun y => p y) (m x)) f)","decl":"@[simp]\ntheorem eventually_bind {f : Filter α} {m : α → Filter β} {p : β → Prop} :\n    (∀ᶠ y in bind f m, p y) ↔ ∀ᶠ x in f, ∀ᶠ y in m x, p y :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventuallyEq_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : Filter α\nm : α → Filter β\ng₁ g₂ : β → γ\n⊢ Iff ((f.bind m).EventuallyEq g₁ g₂) (Filter.Eventually (fun x => (m x).EventuallyEq g₁ g₂) f)","decl":"@[simp]\ntheorem eventuallyEq_bind {f : Filter α} {m : α → Filter β} {g₁ g₂ : β → γ} :\n    g₁ =ᶠ[bind f m] g₂ ↔ ∀ᶠ x in f, g₁ =ᶠ[m x] g₂ :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventuallyLE_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝ : LE γ\nf : Filter α\nm : α → Filter β\ng₁ g₂ : β → γ\n⊢ Iff ((f.bind m).EventuallyLE g₁ g₂) (Filter.Eventually (fun x => (m x).EventuallyLE g₁ g₂) f)","decl":"@[simp]\ntheorem eventuallyLE_bind [LE γ] {f : Filter α} {m : α → Filter β} {g₁ g₂ : β → γ} :\n    g₁ ≤ᶠ[bind f m] g₂ ↔ ∀ᶠ x in f, g₁ ≤ᶠ[m x] g₂ :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_bind'","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set β\nf : Filter α\nm : α → Filter β\n⊢ Iff (Membership.mem (f.bind m) s) (Membership.mem f (setOf fun a => Membership.mem (m a) s))","decl":"theorem mem_bind' {s : Set β} {f : Filter α} {m : α → Filter β} :\n    s ∈ bind f m ↔ { a | s ∈ m a } ∈ f :=\n  Iff.rfl\n\n"}
{"name":"Filter.mem_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set β\nf : Filter α\nm : α → Filter β\n⊢ Iff (Membership.mem (f.bind m) s) (Exists fun t => And (Membership.mem f t) (∀ (x : α), Membership.mem t x → Membership.mem (m x) s))","decl":"@[simp]\ntheorem mem_bind {s : Set β} {f : Filter α} {m : α → Filter β} :\n    s ∈ bind f m ↔ ∃ t ∈ f, ∀ x ∈ t, s ∈ m x :=\n  calc\n    s ∈ bind f m ↔ { a | s ∈ m a } ∈ f := Iff.rfl\n    _ ↔ ∃ t ∈ f, t ⊆ { a | s ∈ m a } := exists_mem_subset_iff.symm\n    _ ↔ ∃ t ∈ f, ∀ x ∈ t, s ∈ m x := Iff.rfl\n\n"}
{"name":"Filter.bind_le","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\ng : α → Filter β\nl : Filter β\nh : Filter.Eventually (fun x => LE.le (g x) l) f\n⊢ LE.le (f.bind g) l","decl":"theorem bind_le {f : Filter α} {g : α → Filter β} {l : Filter β} (h : ∀ᶠ x in f, g x ≤ l) :\n    f.bind g ≤ l :=\n  join_le <| eventually_map.2 h\n\n"}
{"name":"Filter.bind_mono","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf₁ f₂ : Filter α\ng₁ g₂ : α → Filter β\nhf : LE.le f₁ f₂\nhg : f₁.EventuallyLE g₁ g₂\n⊢ LE.le (f₁.bind g₁) (f₂.bind g₂)","decl":"@[mono]\ntheorem bind_mono {f₁ f₂ : Filter α} {g₁ g₂ : α → Filter β} (hf : f₁ ≤ f₂) (hg : g₁ ≤ᶠ[f₁] g₂) :\n    bind f₁ g₁ ≤ bind f₂ g₂ := by\n  refine le_trans (fun s hs => ?_) (join_mono <| map_mono hf)\n  simp only [mem_join, mem_bind', mem_map] at hs ⊢\n  filter_upwards [hg, hs] with _ hx hs using hx hs\n\n"}
{"name":"Filter.bind_inf_principal","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf : Filter α\ng : α → Filter β\ns : Set β\n⊢ Eq (f.bind fun x => Min.min (g x) (Filter.principal s)) (Min.min (f.bind g) (Filter.principal s))","decl":"theorem bind_inf_principal {f : Filter α} {g : α → Filter β} {s : Set β} :\n    (f.bind fun x => g x ⊓ 𝓟 s) = f.bind g ⊓ 𝓟 s :=\n  Filter.ext fun s => by simp only [mem_bind, mem_inf_principal]\n\n"}
{"name":"Filter.sup_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\nf g : Filter α\nh : α → Filter β\n⊢ Eq ((Max.max f g).bind h) (Max.max (f.bind h) (g.bind h))","decl":"theorem sup_bind {f g : Filter α} {h : α → Filter β} : bind (f ⊔ g) h = bind f h ⊔ bind g h := rfl\n\n"}
{"name":"Filter.principal_bind","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → Filter β\n⊢ Eq ((Filter.principal s).bind f) (iSup fun x => iSup fun h => f x)","decl":"theorem principal_bind {s : Set α} {f : α → Filter β} : bind (𝓟 s) f = ⨆ x ∈ s, f x :=\n  show join (map f (𝓟 s)) = ⨆ x ∈ s, f x by\n    simp only [sSup_image, join_principal_eq_sSup, map_principal, eq_self_iff_true]\n\n"}
{"name":"Set.EqOn.eventuallyEq","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf g : α → β\nh : Set.EqOn f g s\n⊢ (Filter.principal s).EventuallyEq f g","decl":"theorem Set.EqOn.eventuallyEq {α β} {s : Set α} {f g : α → β} (h : EqOn f g s) : f =ᶠ[𝓟 s] g :=\n  h\n\n"}
{"name":"Set.EqOn.eventuallyEq_of_mem","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nl : Filter α\nf g : α → β\nh : Set.EqOn f g s\nhl : Membership.mem l s\n⊢ l.EventuallyEq f g","decl":"theorem Set.EqOn.eventuallyEq_of_mem {α β} {s : Set α} {l : Filter α} {f g : α → β} (h : EqOn f g s)\n    (hl : s ∈ l) : f =ᶠ[l] g :=\n  h.eventuallyEq.filter_mono <| Filter.le_principal_iff.2 hl\n\n"}
{"name":"HasSubset.Subset.eventuallyLE","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_1\nl : Filter α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ l.EventuallyLE s t","decl":"theorem HasSubset.Subset.eventuallyLE {α} {l : Filter α} {s t : Set α} (h : s ⊆ t) : s ≤ᶠ[l] t :=\n  Filter.Eventually.of_forall h\n\n"}
{"name":"Filter.map_surjOn_Iic_iff_le_map","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Filter α\nG : Filter β\nm : α → β\n⊢ Iff (Set.SurjOn (Filter.map m) (Set.Iic F) (Set.Iic G)) (LE.le G (Filter.map m F))","decl":"theorem Filter.map_surjOn_Iic_iff_le_map {m : α → β} :\n    SurjOn (map m) (Iic F) (Iic G) ↔ G ≤ map m F := by\n  refine ⟨fun hm ↦ ?_, fun hm ↦ ?_⟩\n  · rcases hm right_mem_Iic with ⟨H, (hHF : H ≤ F), rfl⟩\n    exact map_mono hHF\n  · have : RightInvOn (F ⊓ comap m ·) (map m) (Iic G) :=\n      fun H (hHG : H ≤ G) ↦ by simpa [Filter.push_pull] using hHG.trans hm\n    exact this.surjOn fun H _ ↦ mem_Iic.mpr inf_le_left\n\n"}
{"name":"Filter.map_surjOn_Iic_iff_surjOn","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nm : α → β\n⊢ Iff (Set.SurjOn (Filter.map m) (Set.Iic (Filter.principal s)) (Set.Iic (Filter.principal t))) (Set.SurjOn m s t)","decl":"theorem Filter.map_surjOn_Iic_iff_surjOn {s : Set α} {t : Set β} {m : α → β} :\n    SurjOn (map m) (Iic <| 𝓟 s) (Iic <| 𝓟 t) ↔ SurjOn m s t := by\n  rw [map_surjOn_Iic_iff_le_map, map_principal, principal_mono, SurjOn]\n\n"}
{"name":"Set.SurjOn.filter_map_Iic","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nm : α → β\na✝ : Set.SurjOn m s t\n⊢ Set.SurjOn (Filter.map m) (Set.Iic (Filter.principal s)) (Set.Iic (Filter.principal t))","decl":"alias ⟨_, Set.SurjOn.filter_map_Iic⟩ := Filter.map_surjOn_Iic_iff_surjOn\n\n"}
{"name":"Filter.filter_injOn_Iic_iff_injOn","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nm : α → β\n⊢ Iff (Set.InjOn (Filter.map m) (Set.Iic (Filter.principal s))) (Set.InjOn m s)","decl":"theorem Filter.filter_injOn_Iic_iff_injOn {s : Set α} {m : α → β} :\n    InjOn (map m) (Iic <| 𝓟 s) ↔ InjOn m s := by\n  refine ⟨fun hm x hx y hy hxy ↦ ?_, fun hm F hF G hG ↦ ?_⟩\n  · rwa [← pure_injective.eq_iff, ← map_pure, ← map_pure, hm.eq_iff, pure_injective.eq_iff]\n      at hxy <;> rwa [mem_Iic, pure_le_principal]\n  · simp [map_eq_map_iff_of_injOn (le_principal_iff.mp hF) (le_principal_iff.mp hG) hm]\n\n"}
{"name":"Set.InjOn.filter_map_Iic","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nm : α → β\na✝ : Set.InjOn m s\n⊢ Set.InjOn (Filter.map m) (Set.Iic (Filter.principal s))","decl":"alias ⟨_, Set.InjOn.filter_map_Iic⟩ := Filter.filter_injOn_Iic_iff_injOn\n\n"}
{"name":"Filter.compl_mem_comk","module":"Mathlib.Order.Filter.Basic","initialProofState":"α : Type u_1\np : Set α → Prop\nhe : p EmptyCollection.emptyCollection\nhmono : ∀ (t : Set α), p t → ∀ (s : Set α), HasSubset.Subset s t → p s\nhunion : ∀ (s : Set α), p s → ∀ (t : Set α), p t → p (Union.union s t)\ns : Set α\n⊢ Iff (Membership.mem (Filter.comk p he hmono hunion) (HasCompl.compl s)) (p s)","decl":"lemma compl_mem_comk {p : Set α → Prop} {he hmono hunion s} :\n    sᶜ ∈ comk p he hmono hunion ↔ p s := by\n  simp\n\n"}
