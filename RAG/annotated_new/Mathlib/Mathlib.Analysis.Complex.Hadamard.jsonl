{"name":"Complex.HadamardThreeLines.sSupNormIm_nonneg","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nx : Real\n⊢ LE.le 0 (Complex.HadamardThreeLines.sSupNormIm f x)","decl":"/-- `sSup` of `norm` is nonneg applied to the image of `f` on the vertical line `re z = x` -/\nlemma sSupNormIm_nonneg (x : ℝ) : 0 ≤ sSupNormIm f x := by\n  apply Real.sSup_nonneg\n  rintro y ⟨z1, _, hz2⟩\n  simp only [← hz2, comp, norm_nonneg]\n\n"}
{"name":"Complex.HadamardThreeLines.sSupNormIm_eps_pos","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nε : Real\nhε : GT.gt ε 0\nx : Real\n⊢ LT.lt 0 (HAdd.hAdd ε (Complex.HadamardThreeLines.sSupNormIm f x))","decl":"/-- `sSup` of `norm` translated by `ε > 0` is positive applied to the image of `f` on the\nvertical line `re z = x` -/\nlemma sSupNormIm_eps_pos {ε : ℝ} (hε : ε > 0) (x : ℝ) : 0 < ε + sSupNormIm f x := by\n   linarith [sSupNormIm_nonneg f x]\n\n"}
{"name":"Complex.HadamardThreeLines.abs_invInterpStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nz : Complex\nε : Real\nhε : GT.gt ε 0\n⊢ Eq (Complex.abs (Complex.HadamardThreeLines.invInterpStrip f z ε)) (HMul.hMul (HPow.hPow (HAdd.hAdd ε (Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub z.re 1)) (HPow.hPow (HAdd.hAdd ε (Complex.HadamardThreeLines.sSupNormIm f 1)) (Neg.neg z.re)))","decl":"/-- Useful rewrite for the absolute value of `invInterpStrip`-/\nlemma abs_invInterpStrip {ε : ℝ} (hε : ε > 0) :\n    abs (invInterpStrip f z ε) =\n    (ε + sSupNormIm f 0) ^ (z.re - 1) * (ε + sSupNormIm f 1) ^ (-z.re) := by\n  simp only [invInterpStrip, map_mul]\n  repeat rw [← ofReal_add]\n  repeat rw [abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hε _) _]\n  simp only [sub_re, one_re, neg_re]\n\n"}
{"name":"Complex.HadamardThreeLines.diffContOnCl_invInterpStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nε : Real\nhε : GT.gt ε 0\n⊢ DiffContOnCl Complex (fun z => Complex.HadamardThreeLines.invInterpStrip f z ε) (Complex.HadamardThreeLines.verticalStrip 0 1)","decl":"/-- The function `invInterpStrip` is `diffContOnCl`. -/\nlemma diffContOnCl_invInterpStrip {ε : ℝ} (hε : ε > 0) :\n    DiffContOnCl ℂ (fun z ↦ invInterpStrip f z ε) (verticalStrip 0 1) := by\n  apply Differentiable.diffContOnCl\n  apply Differentiable.mul\n  · apply Differentiable.const_cpow (Differentiable.sub_const (differentiable_id') 1) _\n    left\n    rw [← ofReal_add, ofReal_ne_zero]\n    simp only [ne_eq, ne_of_gt (sSupNormIm_eps_pos f hε 0), not_false_eq_true]\n  · apply Differentiable.const_cpow (Differentiable.neg differentiable_id')\n    apply Or.inl\n    rw [← ofReal_add, ofReal_ne_zero]\n    exact (ne_of_gt (sSupNormIm_eps_pos f hε 1))\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_sSupNormIm","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nz : Complex\nhD : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\n⊢ LE.le (Norm.norm (f z)) (Complex.HadamardThreeLines.sSupNormIm f z.re)","decl":"/-- If `f` is bounded on the unit vertical strip, then `f` is bounded by `sSupNormIm` there. -/\nlemma norm_le_sSupNormIm (f : ℂ → E) (z : ℂ) (hD : z ∈ verticalClosedStrip 0 1)\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1)) :\n    ‖f z‖ ≤ sSupNormIm f (z.re) := by\n  refine le_csSup ?_ ?_\n  · apply BddAbove.mono (image_subset (norm ∘ f) _) hB\n    exact preimage_mono (singleton_subset_iff.mpr hD)\n  · apply mem_image_of_mem (norm ∘ f)\n    simp only [mem_preimage, mem_singleton]\n\n"}
{"name":"Complex.HadamardThreeLines.norm_lt_sSupNormIm_eps","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nε : Real\nhε : GT.gt ε 0\nz : Complex\nhD : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\n⊢ LT.lt (Norm.norm (f z)) (HAdd.hAdd ε (Complex.HadamardThreeLines.sSupNormIm f z.re))","decl":"/-- Alternative version of `norm_le_sSupNormIm` with a strict inequality and a positive `ε`. -/\nlemma norm_lt_sSupNormIm_eps (f : ℂ → E) (ε : ℝ) (hε : ε > 0) (z : ℂ)\n    (hD : z ∈ verticalClosedStrip 0 1) (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1)) :\n    ‖f z‖ < ε + sSupNormIm f (z.re) :=\n  lt_add_of_pos_of_le hε (norm_le_sSupNormIm f z hD hB)\n\n"}
{"name":"Complex.HadamardThreeLines.F_BddAbove","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nε : Real\nhε : GT.gt ε 0\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\n⊢ BddAbove (Set.image (Function.comp Norm.norm (Complex.HadamardThreeLines.F f ε)) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))","decl":"/-- When the function `f` is bounded above on a vertical strip, then so is `F`. -/\nlemma F_BddAbove (f : ℂ → E) (ε : ℝ) (hε : ε > 0)\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1)) :\n    BddAbove ((norm ∘ (F f ε)) '' verticalClosedStrip 0 1) := by\n -- Rewriting goal\n  simp only [F, image_congr, comp_apply, map_mul, invInterpStrip]\n  rw [bddAbove_def] at *\n  rcases hB with ⟨B, hB⟩\n  -- Using bound\n  use ((max 1 ((ε + sSupNormIm f 0) ^ (-(1 : ℝ)))) * max 1 ((ε + sSupNormIm f 1) ^ (-(1 : ℝ)))) * B\n  simp only [mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n  intros z hset\n  specialize hB (‖f z‖) (by simpa [image_congr, mem_image, comp_apply] using ⟨z, hset, rfl⟩)\n  -- Proof that the bound is correct\n  simp only [norm_smul, norm_mul, ← ofReal_add]\n  gcongr\n    -- Bounding individual terms\n  · by_cases hM0_one : 1 ≤ ε + sSupNormIm f 0\n    -- `1 ≤ sSupNormIm f 0`\n    · apply le_trans _ (le_max_left _ _)\n      simp only [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hε 0), sub_re,\n        one_re, Real.rpow_le_one_of_one_le_of_nonpos hM0_one (sub_nonpos.mpr hset.2)]\n    -- `0 < sSupNormIm f 0 < 1`\n    · rw [not_le] at hM0_one; apply le_trans _ (le_max_right _ _)\n      simp only [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hε 0), sub_re,\n        one_re]\n      apply Real.rpow_le_rpow_of_exponent_ge (sSupNormIm_eps_pos f hε 0) (le_of_lt hM0_one) _\n      simp only [neg_le_sub_iff_le_add, le_add_iff_nonneg_left, hset.1]\n  · by_cases hM1_one : 1 ≤ ε + sSupNormIm f 1\n    -- `1 ≤ sSupNormIm f 1`\n    · apply le_trans _ (le_max_left _ _)\n      simp only [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hε 1), sub_re,\n        one_re, neg_re, Real.rpow_le_one_of_one_le_of_nonpos\n        hM1_one (Right.neg_nonpos_iff.mpr hset.1)]\n    -- `0 < sSupNormIm f 1 < 1`\n    · rw [not_le] at hM1_one; apply le_trans _ (le_max_right _ _)\n      simp only [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hε 1), sub_re,\n        one_re, neg_re, Real.rpow_le_rpow_of_exponent_ge (sSupNormIm_eps_pos f hε 1)\n        (le_of_lt hM1_one) (neg_le_neg_iff.mpr hset.2)]\n\n"}
{"name":"Complex.HadamardThreeLines.F_edge_le_one","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nε : Real\nhε : GT.gt ε 0\nz : Complex\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhz : Membership.mem (Set.preimage Complex.re (Insert.insert 0 (Singleton.singleton 1))) z\n⊢ LE.le (Norm.norm (Complex.HadamardThreeLines.F f ε z)) 1","decl":"/-- Proof that `F` is bounded by one one the edges. -/\nlemma F_edge_le_one (f : ℂ → E) (ε : ℝ) (hε : ε > 0) (z : ℂ)\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1)) (hz : z ∈ re ⁻¹' {0, 1}) :\n    ‖F f ε z‖ ≤ 1 := by\n  simp only [F, norm_smul, norm_eq_abs, map_mul, abs_cpow_eq_rpow_re_of_pos,\n    abs_invInterpStrip f z hε, sSupNormIm_eps_pos f hε 1,\n    sub_re, one_re, neg_re]\n  rcases hz with hz0 | hz1\n  -- `z.re = 0`\n  · simp only [hz0, zero_sub, Real.rpow_neg_one, neg_zero, Real.rpow_zero, mul_one,\n      inv_mul_le_iff₀ (sSupNormIm_eps_pos f hε 0)]\n    rw [← hz0]\n    apply le_of_lt (norm_lt_sSupNormIm_eps f ε hε _ _ hB)\n    simp only [verticalClosedStrip, mem_preimage, zero_le_one, left_mem_Icc, hz0]\n  -- `z.re = 1`\n  · rw [mem_singleton_iff] at hz1\n    simp only [hz1, one_mul, Real.rpow_zero, sub_self, Real.rpow_neg_one,\n      inv_mul_le_iff₀ (sSupNormIm_eps_pos f hε 1), mul_one]\n    rw [← hz1]\n    apply le_of_lt (norm_lt_sSupNormIm_eps f ε hε _ _ hB)\n    simp only [verticalClosedStrip, mem_preimage, zero_le_one, hz1, right_mem_Icc]\n\n"}
{"name":"Complex.HadamardThreeLines.norm_mul_invInterpStrip_le_one_of_mem_verticalClosedStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nε : Real\nhε : LT.lt 0 ε\nz : Complex\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\n⊢ LE.le (Norm.norm (Complex.HadamardThreeLines.F f ε z)) 1","decl":"theorem norm_mul_invInterpStrip_le_one_of_mem_verticalClosedStrip (f : ℂ → E) (ε : ℝ) (hε : 0 < ε)\n    (z : ℂ) (hd : DiffContOnCl ℂ f (verticalStrip 0 1))\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1)) (hz : z ∈ verticalClosedStrip 0 1) :\n    ‖F f ε z‖ ≤ 1 := by\n  apply PhragmenLindelof.vertical_strip\n    (DiffContOnCl.smul (diffContOnCl_invInterpStrip f hε) hd) _\n    (fun x hx ↦ F_edge_le_one f ε hε x hB (Or.inl hx))\n    (fun x hx ↦ F_edge_le_one f ε hε x hB (Or.inr hx)) hz.1 hz.2\n  use 0\n  rw [sub_zero, div_one]\n  refine ⟨ Real.pi_pos, ?_⟩\n  obtain ⟨BF, hBF⟩ := F_BddAbove f ε hε hB\n  simp only [comp_apply, mem_upperBounds, mem_image, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff₂] at hBF\n  use BF\n  rw [Asymptotics.isBigO_iff]\n  use 1\n  rw [eventually_inf_principal]\n  apply Eventually.of_forall\n  intro x hx\n  norm_num\n  exact (hBF x ((preimage_mono Ioo_subset_Icc_self) hx)).trans\n    ((le_of_lt (lt_add_one BF)).trans (Real.add_one_le_exp BF))\n\n"}
{"name":"Complex.HadamardThreeLines.interpStrip_eq_of_pos","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nz : Complex\nh0 : LT.lt 0 (Complex.HadamardThreeLines.sSupNormIm f 0)\nh1 : LT.lt 0 (Complex.HadamardThreeLines.sSupNormIm f 1)\n⊢ Eq (Complex.HadamardThreeLines.interpStrip f z) (HMul.hMul (HPow.hPow (↑(Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub 1 z)) (HPow.hPow (↑(Complex.HadamardThreeLines.sSupNormIm f 1)) z))","decl":"/-- Rewrite for `InterpStrip` when `0 < sSupNormIm f 0` and `0 < sSupNormIm f 1`. -/\nlemma interpStrip_eq_of_pos (z : ℂ) (h0 : 0 < sSupNormIm f 0) (h1 : 0 < sSupNormIm f 1) :\n    interpStrip f z = sSupNormIm f 0 ^ (1 - z) * sSupNormIm f 1 ^ z := by\n  simp only [ne_of_gt h0, ne_of_gt h1, interpStrip, if_false, or_false]\n\n"}
{"name":"Complex.HadamardThreeLines.interpStrip_eq_of_zero","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nz : Complex\nh : Or (Eq (Complex.HadamardThreeLines.sSupNormIm f 0) 0) (Eq (Complex.HadamardThreeLines.sSupNormIm f 1) 0)\n⊢ Eq (Complex.HadamardThreeLines.interpStrip f z) 0","decl":"/-- Rewrite for `InterpStrip` when `0 = sSupNormIm f 0` or `0 = sSupNormIm f 1`. -/\nlemma interpStrip_eq_of_zero (z : ℂ) (h : sSupNormIm f 0 = 0 ∨ sSupNormIm f 1 = 0) :\n    interpStrip f z = 0 :=\n  if_pos h\n\n"}
{"name":"Complex.HadamardThreeLines.interpStrip_eq_of_mem_verticalStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalStrip 0 1) z\n⊢ Eq (Complex.HadamardThreeLines.interpStrip f z) (HMul.hMul (HPow.hPow (↑(Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub 1 z)) (HPow.hPow (↑(Complex.HadamardThreeLines.sSupNormIm f 1)) z))","decl":"/-- Rewrite for `InterpStrip` on the open vertical strip. -/\nlemma interpStrip_eq_of_mem_verticalStrip (z : ℂ) (hz : z ∈ verticalStrip 0 1) :\n    interpStrip f z = sSupNormIm f 0 ^ (1 - z) * sSupNormIm f 1 ^ z := by\n  by_cases h : sSupNormIm f 0 = 0 ∨ sSupNormIm f 1 = 0\n  · rw [interpStrip_eq_of_zero _ z h]\n    rcases h with h0 | h1\n    · simp only [h0, ofReal_zero, zero_eq_mul, cpow_eq_zero_iff, ne_eq, true_and, ofReal_eq_zero]\n      left\n      rw [sub_eq_zero, eq_comm]\n      simp only [ne_eq, Complex.ext_iff, one_re, ne_of_lt hz.2, or_iff_left, false_and,\n        not_false_eq_true]\n    · simp only [h1, ofReal_zero, zero_eq_mul, cpow_eq_zero_iff, ofReal_eq_zero, ne_eq, true_and]\n      right\n      rw [eq_comm]\n      simp only [ne_eq, Complex.ext_iff, zero_re, ne_of_lt hz.1, or_iff_left, false_and,\n        not_false_eq_true]\n  · push_neg at h\n    replace h : (0 < sSupNormIm f 0) ∧ (0 < sSupNormIm f 1) :=\n      ⟨(lt_of_le_of_ne (sSupNormIm_nonneg f 0) (ne_comm.mp h.1)),\n        (lt_of_le_of_ne (sSupNormIm_nonneg f 1) (ne_comm.mp h.2))⟩\n    exact interpStrip_eq_of_pos f z h.1 h.2\n\n"}
{"name":"Complex.HadamardThreeLines.diffContOnCl_interpStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\n⊢ DiffContOnCl Complex (Complex.HadamardThreeLines.interpStrip f) (Complex.HadamardThreeLines.verticalStrip 0 1)","decl":"lemma diffContOnCl_interpStrip :\n    DiffContOnCl ℂ (interpStrip f) (verticalStrip 0 1) := by\n  by_cases h : sSupNormIm f 0 = 0 ∨ sSupNormIm f 1 = 0\n  -- Case everywhere 0\n  · eta_expand; simp_rw [interpStrip_eq_of_zero f _ h]; exact diffContOnCl_const\n  -- Case nowhere 0\n  · push_neg at h\n    rcases h with ⟨h0, h1⟩\n    rw [ne_comm] at h0 h1\n    apply Differentiable.diffContOnCl\n    intro z\n    eta_expand\n    simp_rw [interpStrip_eq_of_pos f _ (lt_of_le_of_ne (sSupNormIm_nonneg f 0) h0)\n      (lt_of_le_of_ne (sSupNormIm_nonneg f 1) h1)]\n    refine DifferentiableAt.mul ?_ ?_\n    · apply DifferentiableAt.const_cpow (DifferentiableAt.const_sub (differentiableAt_id') 1) _\n      left; simp only [Ne, ofReal_eq_zero]; rwa [eq_comm]\n    · refine DifferentiableAt.const_cpow ?_ ?_\n      · apply differentiableAt_id'\n      · left; simp only [Ne, ofReal_eq_zero]; rwa [eq_comm]\n\n"}
{"name":"Complex.HadamardThreeLines.scale_id_mem_verticalClosedStrip_of_mem_verticalClosedStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"l u : Real\nhul : LT.lt l u\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\n⊢ Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip l u) (HAdd.hAdd (↑l) (HMul.hMul z (HSub.hSub ↑u ↑l)))","decl":"/-- The transformation on ℂ that is used for `scale` maps the closed strip ``re ⁻¹' [l, u]``\n  to the closed strip ``re ⁻¹' [0, 1]``. -/\nlemma scale_id_mem_verticalClosedStrip_of_mem_verticalClosedStrip {l u : ℝ} (hul : l < u) {z : ℂ}\n    (hz : z ∈ verticalClosedStrip 0 1) : l + z * (u - l) ∈ verticalClosedStrip l u := by\n  simp only [verticalClosedStrip, mem_preimage, add_re, ofReal_re, mul_re, sub_re, sub_im,\n    ofReal_im, sub_self, mul_zero, sub_zero, mem_Icc, le_add_iff_nonneg_right]\n  simp only [verticalClosedStrip, mem_preimage, mem_Icc] at hz\n  obtain ⟨hz₁, hz₂⟩ := hz\n  simp only [sub_pos, hul, mul_nonneg_iff_of_pos_right, hz₁, true_and]\n  rw [add_comm, ← sub_le_sub_iff_right l, add_sub_assoc, sub_self, add_zero]\n  nth_rewrite 2 [← one_mul (u - l)]\n  have := sub_nonneg.2 hul.le\n  gcongr\n\n"}
{"name":"Complex.HadamardThreeLines.scale_bddAbove","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nl u : Real\nhul : LT.lt l u\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip l u))\n⊢ BddAbove (Set.image (Function.comp Norm.norm (Complex.HadamardThreeLines.scale f l u)) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))","decl":"/-- The norm of the function `scale f l u` is bounded above on the closed strip `re⁻¹' [0, 1]`. -/\nlemma scale_bddAbove {f : ℂ → E} {l u : ℝ} (hul : l < u)\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip l u)) :\n    BddAbove ((norm ∘ scale f l u) '' verticalClosedStrip 0 1) := by\n  obtain ⟨R, hR⟩ := bddAbove_def.mp hB\n  rw [bddAbove_def]\n  use R\n  intro r hr\n  obtain ⟨w, hw₁, hw₂, _⟩ := hr\n  simp only [comp_apply, scale, smul_eq_mul]\n  have : ‖f (↑l + w * (↑u - ↑l))‖ ∈ norm ∘ f '' verticalClosedStrip l u := by\n    simp only [comp_apply, mem_image]\n    use ↑l + w * (↑u - ↑l)\n    simp only [and_true]\n    exact scale_id_mem_verticalClosedStrip_of_mem_verticalClosedStrip hul hw₁\n  exact hR ‖f (↑l + w * (↑u - ↑l))‖ this\n\n"}
{"name":"Complex.HadamardThreeLines.scale_bound_left","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nl u a : Real\nha : ∀ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton l)) z → LE.le (Norm.norm (f z)) a\nz : Complex\na✝ : Membership.mem (Set.preimage Complex.re (Singleton.singleton 0)) z\n⊢ LE.le (Norm.norm (Complex.HadamardThreeLines.scale f l u z)) a","decl":"/-- A bound to the norm of `f` on the line `z.re = l` induces a bound to the norm of\n  `scale f l u z` on the line `z.re = 0`. -/\nlemma scale_bound_left {f : ℂ → E} {l u a : ℝ} (ha : ∀ z ∈ re ⁻¹' {l}, ‖f z‖ ≤ a) :\n    ∀ z ∈ re ⁻¹' {0}, ‖scale f l u z‖ ≤ a := by\n  simp only [mem_preimage, mem_singleton_iff, scale, smul_eq_mul]\n  intro z hz\n  exact ha (↑l + z * (↑u - ↑l)) (by simp [hz])\n\n"}
{"name":"Complex.HadamardThreeLines.scale_bound_right","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nl u b : Real\nhb : ∀ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton u)) z → LE.le (Norm.norm (f z)) b\nz : Complex\na✝ : Membership.mem (Set.preimage Complex.re (Singleton.singleton 1)) z\n⊢ LE.le (Norm.norm (Complex.HadamardThreeLines.scale f l u z)) b","decl":"/-- A bound to the norm of `f` on the line `z.re = u` induces a bound to the norm of `scale f l u z`\n  on the line `z.re = 1`. -/\nlemma scale_bound_right {f : ℂ → E} {l u b : ℝ} (hb : ∀ z ∈ re ⁻¹' {u}, ‖f z‖ ≤ b) :\n    ∀ z ∈ re ⁻¹' {1}, ‖scale f l u z‖ ≤ b := by\n  simp only [scale, mem_preimage, mem_singleton_iff, smul_eq_mul]\n  intro z hz\n  exact hb (↑l + z * (↑u - ↑l)) (by simp [hz])\n\n"}
{"name":"Complex.HadamardThreeLines.sSupNormIm_scale_left","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nl u : Real\nhul : LT.lt l u\n⊢ Eq (Complex.HadamardThreeLines.sSupNormIm (Complex.HadamardThreeLines.scale f l u) 0) (Complex.HadamardThreeLines.sSupNormIm f l)","decl":"/-- The supremum of the norm of `scale f l u` on the line `z.re = 0` is the same as the supremum\n  of `f` on the line `z.re = l`. -/\nlemma sSupNormIm_scale_left (f : ℂ → E) {l u : ℝ} (hul : l < u) :\n    sSupNormIm (scale f l u) 0 = sSupNormIm f l := by\n  simp_rw [sSupNormIm, image_comp]\n  have : scale f l u '' (re ⁻¹' {0}) = f '' (re ⁻¹' {l}) := by\n    ext e\n    simp only [scale, smul_eq_mul, mem_image, mem_preimage, mem_singleton_iff]\n    constructor\n    · intro h\n      obtain ⟨z, hz₁, hz₂⟩ := h\n      use ↑l + z * (↑u - ↑l)\n      simp [hz₁, hz₂]\n    · intro h\n      obtain ⟨z, hz₁, hz₂⟩ := h\n      use ((z - l) / (u - l))\n      constructor\n      · norm_cast\n        rw [Complex.div_re, Complex.normSq_ofReal, Complex.ofReal_re]\n        simp[hz₁]\n      · rw [div_mul_comm, div_self (by norm_cast; linarith)]\n        simp [hz₂]\n  rw [this]\n\n"}
{"name":"Complex.HadamardThreeLines.sSupNormIm_scale_right","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nl u : Real\nhul : LT.lt l u\n⊢ Eq (Complex.HadamardThreeLines.sSupNormIm (Complex.HadamardThreeLines.scale f l u) 1) (Complex.HadamardThreeLines.sSupNormIm f u)","decl":"/-- The supremum of the norm of `scale f l u` on the line `z.re = 1` is the same as\n  the supremum of `f` on the line `z.re = u`. -/\nlemma sSupNormIm_scale_right (f : ℂ → E) {l u : ℝ} (hul : l < u) :\n    sSupNormIm (scale f l u) 1 = sSupNormIm f u := by\n  simp_rw [sSupNormIm, image_comp]\n  have : scale f l u '' (re ⁻¹' {1}) = f '' (re ⁻¹' {u}) := by\n    ext e\n    simp only [scale, smul_eq_mul, mem_image, mem_preimage, mem_singleton_iff]\n    constructor\n    · intro h\n      obtain ⟨z, hz₁, hz₂⟩ := h\n      use ↑l + z * (↑u - ↑l)\n      simp only [add_re, ofReal_re, mul_re, hz₁, sub_re, one_mul, sub_im, ofReal_im, sub_self,\n        mul_zero, sub_zero, add_sub_cancel, hz₂, and_self]\n    · intro h\n      obtain ⟨z, hz₁, hz₂⟩ := h\n      use ((z - l) / (u - l))\n      constructor\n      · norm_cast\n        rw [Complex.div_re, Complex.normSq_ofReal, Complex.ofReal_re]\n        simp only [sub_re, hz₁, ofReal_re, sub_im, ofReal_im, sub_zero, ofReal_sub, sub_self,\n          mul_zero, zero_div, add_zero]\n        rw [div_mul_eq_div_div_swap, mul_div_assoc,\n          div_self (by norm_cast; linarith),\n          mul_one, div_self (by norm_cast; linarith)]\n      · rw [div_mul_comm, div_self (by norm_cast; linarith)]\n        simp only [one_mul, add_sub_cancel, hz₂]\n  rw [this]\n\n"}
{"name":"Complex.HadamardThreeLines.interpStrip_scale","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nl u : Real\nhul : LT.lt l u\nz : Complex\n⊢ Eq (Complex.HadamardThreeLines.interpStrip (Complex.HadamardThreeLines.scale f l u) (HDiv.hDiv (HSub.hSub z ↑l) (HSub.hSub ↑u ↑l))) (Complex.HadamardThreeLines.interpStrip' f l u z)","decl":"/-- A technical lemma relating the bounds given by the three lines lemma on a general strip\nto the bounds for its scaled version on the strip ``re ⁻¹' [0, 1]`. -/\nlemma interpStrip_scale (f : ℂ → E) {l u : ℝ} (hul: l < u) (z : ℂ)  : interpStrip (scale f l u)\n    ((z - ↑l) / (↑u - ↑l)) = interpStrip' f l u z := by\n  simp only [interpStrip, interpStrip']\n  simp_rw [sSupNormIm_scale_left f hul, sSupNormIm_scale_right f hul]\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interpStrip_of_mem_verticalClosedStrip_eps","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\nf : Complex → E\ninst✝ : NormedSpace Complex E\nε : Real\nhε : GT.gt ε 0\nz : Complex\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\n⊢ LE.le (Norm.norm (f z)) (Norm.norm (HMul.hMul (HPow.hPow (HAdd.hAdd ↑ε ↑(Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub 1 z)) (HPow.hPow (HAdd.hAdd ↑ε ↑(Complex.HadamardThreeLines.sSupNormIm f 1)) z)))","decl":"lemma norm_le_interpStrip_of_mem_verticalClosedStrip_eps (ε : ℝ) (hε : ε > 0) (z : ℂ)\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1))\n    (hd : DiffContOnCl ℂ f (verticalStrip 0 1)) (hz : z ∈ verticalClosedStrip 0 1) :\n    ‖f z‖ ≤  ‖((ε + sSupNormIm f 0) ^ (1-z) * (ε + sSupNormIm f 1) ^ z : ℂ)‖ := by\n  simp only [F, abs_invInterpStrip _ _ hε, norm_smul, norm_mul, norm_eq_abs,\n    ← ofReal_add, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hε _) _, sub_re, one_re]\n  rw [← mul_inv_le_iff₀', ← one_mul (((ε + sSupNormIm f 1) ^ z.re)), ← mul_inv_le_iff₀,\n    ← Real.rpow_neg_one, ← Real.rpow_neg_one]\n  · simp only [← Real.rpow_mul (le_of_lt (sSupNormIm_eps_pos f hε _)),\n    mul_neg, mul_one, neg_sub, mul_assoc]\n    simpa [F, abs_invInterpStrip _ _ hε, norm_smul, mul_comm] using\n      norm_mul_invInterpStrip_le_one_of_mem_verticalClosedStrip f ε hε z hd hB hz\n  · simp only [Real.rpow_pos_of_pos (sSupNormIm_eps_pos f hε _) z.re]\n  · simp only [Real.rpow_pos_of_pos (sSupNormIm_eps_pos f hε _) (1-z.re)]\n\n"}
{"name":"Complex.HadamardThreeLines.eventuallyle","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\nf : Complex → E\ninst✝ : NormedSpace Complex E\nz : Complex\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhz : Membership.mem (Complex.HadamardThreeLines.verticalStrip 0 1) z\n⊢ (nhdsWithin 0 (Set.Ioi 0)).EventuallyLE (fun x => Norm.norm (f z)) fun ε => Norm.norm (HMul.hMul (HPow.hPow (HAdd.hAdd ↑ε ↑(Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub 1 z)) (HPow.hPow (HAdd.hAdd ↑ε ↑(Complex.HadamardThreeLines.sSupNormIm f 1)) z))","decl":"lemma eventuallyle (z : ℂ) (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1))\n    (hd : DiffContOnCl ℂ f (verticalStrip 0 1)) (hz : z ∈ verticalStrip 0 1) :\n    (fun _ : ℝ ↦ ‖f z‖) ≤ᶠ[𝓝[>] 0]\n    (fun ε ↦ ‖((ε + sSupNormIm f 0) ^ (1 - z) * (ε + sSupNormIm f 1) ^ z : ℂ)‖) := by\n  filter_upwards [self_mem_nhdsWithin] with ε (hε : 0 < ε) using\n    norm_le_interpStrip_of_mem_verticalClosedStrip_eps f ε hε z hB hd\n      (mem_of_mem_of_subset hz (preimage_mono Ioo_subset_Icc_self))\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interpStrip_of_mem_verticalStrip_zero","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\nf : Complex → E\ninst✝ : NormedSpace Complex E\nz : Complex\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhz : Membership.mem (Complex.HadamardThreeLines.verticalStrip 0 1) z\n⊢ LE.le (Norm.norm (f z)) (Norm.norm (Complex.HadamardThreeLines.interpStrip f z))","decl":"lemma norm_le_interpStrip_of_mem_verticalStrip_zero (z : ℂ)\n    (hd : DiffContOnCl ℂ f (verticalStrip 0 1))\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1)) (hz : z ∈ verticalStrip 0 1) :\n    ‖f z‖ ≤ ‖interpStrip f z‖ := by\n  apply tendsto_le_of_eventuallyLE _ _ (eventuallyle f z hB hd hz)\n  · apply tendsto_inf_left\n    simp only [tendsto_const_nhds_iff]\n  -- Proof that we can let epsilon tend to zero.\n  · rw [interpStrip_eq_of_mem_verticalStrip _ _ hz]\n    convert ContinuousWithinAt.tendsto _ using 2\n    · simp only [ofReal_zero, zero_add]\n    · simp_rw [← ofReal_add, norm_eq_abs]\n      have : ∀ x ∈ Ioi 0, (x + sSupNormIm f 0) ^ (1 - z.re) * (x + sSupNormIm f 1) ^ z.re\n          = abs (↑(x + sSupNormIm f 0) ^ (1 - z) * ↑(x + sSupNormIm f 1) ^ z) := by\n              intro x hx\n              simp only [map_mul]\n              repeat rw [abs_cpow_eq_rpow_re_of_nonneg (le_of_lt (sSupNormIm_eps_pos f hx _)) _]\n              · simp only [sub_re, one_re]\n              · simpa using (ne_comm.mpr (ne_of_lt hz.1))\n              · simpa [sub_eq_zero] using (ne_comm.mpr (ne_of_lt hz.2))\n      apply tendsto_nhdsWithin_congr this _\n      simp only [zero_add]\n      rw [map_mul, abs_cpow_eq_rpow_re_of_nonneg (sSupNormIm_nonneg _ _) _,\n        abs_cpow_eq_rpow_re_of_nonneg (sSupNormIm_nonneg _ _) _]\n      · apply Tendsto.mul\n        · apply Tendsto.rpow_const\n          · nth_rw 2 [← zero_add (sSupNormIm f 0)]\n            exact Tendsto.add_const (sSupNormIm f 0) (tendsto_nhdsWithin_of_tendsto_nhds\n              (Continuous.tendsto continuous_id' _))\n          · right; simp only [sub_nonneg, le_of_lt hz.2]\n        · apply Tendsto.rpow_const\n          · nth_rw 2 [← zero_add (sSupNormIm f 1)]\n            exact Tendsto.add_const (sSupNormIm f 1) (tendsto_nhdsWithin_of_tendsto_nhds\n              (Continuous.tendsto continuous_id' _))\n          · right; simp only [sub_nonneg, le_of_lt hz.1]\n      · simpa using (ne_comm.mpr (ne_of_lt hz.1))\n      · simpa [sub_eq_zero] using (ne_comm.mpr (ne_of_lt hz.2))\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interpStrip_of_mem_verticalClosedStrip₀₁","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\n⊢ LE.le (Norm.norm (f z)) (Norm.norm (Complex.HadamardThreeLines.interpStrip f z))","decl":"/--\n**Hadamard three-line theorem** on `re ⁻¹' [0, 1]`: If `f` is a bounded function, continuous on the\nclosed strip `re ⁻¹' [0, 1]` and differentiable on open strip `re ⁻¹' (0, 1)`, then for\n`M(x) := sup ((norm ∘ f) '' (re ⁻¹' {x}))` we have that for all `z` in the closed strip\n`re ⁻¹' [0, 1]` the inequality `‖f(z)‖ ≤ M(0) ^ (1 - z.re) * M(1) ^ z.re` holds. -/\nlemma norm_le_interpStrip_of_mem_verticalClosedStrip₀₁ (f : ℂ → E) {z : ℂ}\n    (hz : z ∈ verticalClosedStrip 0 1) (hd : DiffContOnCl ℂ f (verticalStrip 0 1))\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1)) :\n    ‖f z‖ ≤ ‖interpStrip f z‖ := by\n  apply le_on_closure (fun w hw ↦ norm_le_interpStrip_of_mem_verticalStrip_zero f w hd hB hw)\n    (Continuous.comp_continuousOn' continuous_norm hd.2)\n    (Continuous.comp_continuousOn' continuous_norm (diffContOnCl_interpStrip f).2)\n  rwa [verticalClosedStrip, ← closure_Ioo zero_ne_one, ← closure_preimage_re] at hz\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interp_of_mem_verticalClosedStrip₀₁'","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nz : Complex\na b : Real\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nha : ∀ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton 0)) z → LE.le (Norm.norm (f z)) a\nhb : ∀ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton 1)) z → LE.le (Norm.norm (f z)) b\n⊢ LE.le (Norm.norm (f z)) (HMul.hMul (HPow.hPow a (HSub.hSub 1 z.re)) (HPow.hPow b z.re))","decl":"/-- **Hadamard three-line theorem** on `re ⁻¹' [0, 1]` (Variant in simpler terms): Let `f` be a\nbounded function, continuous on the closed strip `re ⁻¹' [0, 1]` and differentiable on open strip\n`re ⁻¹' (0, 1)`. If, for all `z.re = 0`, `‖f z‖ ≤ a` for some `a ∈ ℝ` and, similarly, for all\n`z.re = 1`, `‖f z‖ ≤ b` for some `b ∈ ℝ` then for all `z` in the closed strip\n`re ⁻¹' [0, 1]` the inequality `‖f(z)‖ ≤ a ^ (1 - z.re) * b ^ z.re` holds. -/\nlemma norm_le_interp_of_mem_verticalClosedStrip₀₁' (f : ℂ → E) {z : ℂ} {a b : ℝ}\n    (hz : z ∈ verticalClosedStrip 0 1) (hd : DiffContOnCl ℂ f (verticalStrip 0 1))\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip 0 1))\n    (ha : ∀ z ∈ re ⁻¹' {0}, ‖f z‖ ≤ a) (hb : ∀ z ∈ re ⁻¹' {1}, ‖f z‖ ≤ b) :\n    ‖f z‖ ≤ a ^ (1 - z.re) * b ^ z.re := by\n  have : ‖interpStrip f z‖ ≤ sSupNormIm f 0 ^ (1 - z.re) * sSupNormIm f 1 ^ z.re := by\n    by_cases h : sSupNormIm f 0 = 0 ∨ sSupNormIm f 1 = 0\n    · rw [interpStrip_eq_of_zero f z h, norm_zero, mul_nonneg_iff]\n      left\n      exact ⟨Real.rpow_nonneg (sSupNormIm_nonneg f _) _,\n        Real.rpow_nonneg (sSupNormIm_nonneg f _) _ ⟩\n    · push_neg at h\n      rcases h with ⟨h0, h1⟩\n      rw [ne_comm] at h0 h1\n      simp_rw [interpStrip_eq_of_pos f _ (lt_of_le_of_ne (sSupNormIm_nonneg f 0) h0)\n        (lt_of_le_of_ne (sSupNormIm_nonneg f 1) h1)]\n      simp only [norm_eq_abs, map_mul]\n      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h0).mp (sSupNormIm_nonneg f _)) _]\n      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h1).mp (sSupNormIm_nonneg f _)) _]\n      simp only [sub_re, one_re, le_refl]\n  apply (norm_le_interpStrip_of_mem_verticalClosedStrip₀₁ f hz hd hB).trans (this.trans _)\n  apply mul_le_mul_of_nonneg _ _ (Real.rpow_nonneg (sSupNormIm_nonneg f _) _)\n  · apply (Real.rpow_nonneg _ _)\n    specialize hb 1\n    simp only [mem_preimage, one_re, mem_singleton_iff, forall_true_left] at hb\n    exact (norm_nonneg _).trans hb\n  · apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ (sub_nonneg.mpr hz.2)\n    · rw [sSupNormIm]\n      apply csSup_le _\n      · simpa [comp_apply, mem_image, forall_exists_index,\n          and_imp, forall_apply_eq_imp_iff₂] using ha\n      · use ‖(f 0)‖, 0\n        simp only [mem_preimage, zero_re, mem_singleton_iff, comp_apply,\n          and_self]\n  · apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ hz.1\n    · rw [sSupNormIm]\n      apply csSup_le _\n      · simpa [comp_apply, mem_image, forall_exists_index,\n          and_imp, forall_apply_eq_imp_iff₂] using hb\n      · use ‖(f 1)‖, 1\n        simp only [mem_preimage, one_re, mem_singleton_iff, comp_apply,\n          and_self]\n\n"}
{"name":"Complex.HadamardThreeLines.scale_id_mem_verticalStrip_of_mem_verticalStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"l u : Real\nhul : LT.lt l u\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalStrip 0 1) z\n⊢ Membership.mem (Complex.HadamardThreeLines.verticalStrip l u) (HAdd.hAdd (↑l) (HMul.hMul z (HSub.hSub ↑u ↑l)))","decl":"/-- The transformation on ℂ that is used for `scale` maps the strip ``re ⁻¹' (l, u)``\n  to the strip ``re ⁻¹' (0, 1)``. -/\nlemma scale_id_mem_verticalStrip_of_mem_verticalStrip {l u : ℝ} (hul : l < u) {z : ℂ}\n    (hz : z ∈ verticalStrip 0 1) : l + z * (u - l) ∈ verticalStrip l u := by\n  simp only [verticalStrip, mem_preimage, mem_Ioo] at hz\n  simp only [verticalStrip, mem_preimage, add_re, ofReal_re, mul_re, sub_re, sub_im, ofReal_im,\n    sub_self, mul_zero, sub_zero, mem_Ioo, lt_add_iff_pos_right]\n  obtain ⟨hz₁, hz₂⟩ := hz\n  simp only [hz₁, mul_pos_iff_of_pos_left, sub_pos, hul, true_and]\n  rw [add_comm, ← sub_lt_sub_iff_right l, add_sub_assoc, sub_self, add_zero]\n  nth_rewrite 2 [← one_mul (u - l)]\n  gcongr\n  simp only [sub_pos]\n  exact hul\n\n"}
{"name":"Complex.HadamardThreeLines.mem_verticalClosedStrip_of_scale_id_mem_verticalClosedStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"z : Complex\nl u : Real\nhul : LT.lt l u\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip l u) z\n⊢ Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) (HSub.hSub (HDiv.hDiv z (HSub.hSub ↑u ↑l)) (HDiv.hDiv (↑l) (HSub.hSub ↑u ↑l)))","decl":"/-- If z is on the closed strip `re ⁻¹' [l, u]`, then `(z - l) / (u - l)` is on the closed strip\n  `re ⁻¹' [0, 1]`. -/\nlemma mem_verticalClosedStrip_of_scale_id_mem_verticalClosedStrip {z : ℂ} {l u : ℝ} (hul : l < u)\n    (hz : z ∈ verticalClosedStrip l u) : z / (u - l) - l / (u - l) ∈ verticalClosedStrip 0 1 := by\n  simp only [verticalClosedStrip, Complex.div_re, mem_preimage, sub_re, mem_Icc,\n    sub_nonneg, tsub_le_iff_right, ofReal_re, ofReal_im, sub_im, sub_self, mul_zero, zero_div,\n    add_zero]\n  simp only [verticalClosedStrip] at hz\n  norm_cast\n  simp_rw [Complex.normSq_ofReal, mul_div_assoc, div_mul_eq_div_div_swap,\n    div_self (by linarith : u - l ≠ 0), ← div_eq_mul_one_div]\n  constructor\n  · gcongr\n    · apply le_of_lt; simp [hul]\n    · exact hz.1\n  · rw [← sub_le_sub_iff_right (l / (u - l)), add_sub_assoc, sub_self, add_zero, div_sub_div_same,\n      div_le_one (by simp[hul]), sub_le_sub_iff_right l]\n    exact hz.2\n\n"}
{"name":"Complex.HadamardThreeLines.scale_diffContOnCl","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nl u : Real\nhul : LT.lt l u\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip l u)\n⊢ DiffContOnCl Complex (Complex.HadamardThreeLines.scale f l u) (Complex.HadamardThreeLines.verticalStrip 0 1)","decl":"/-- The function `scale f l u` is `diffContOnCl`. -/\nlemma scale_diffContOnCl {f : ℂ → E} {l u : ℝ} (hul : l < u)\n    (hd : DiffContOnCl ℂ f (verticalStrip l u)) :\n    DiffContOnCl ℂ (scale f l u) (verticalStrip 0 1) := by\n  unfold scale\n  apply DiffContOnCl.comp (s := verticalStrip l u) hd\n  · apply DiffContOnCl.const_add\n    apply DiffContOnCl.smul_const\n    exact Differentiable.diffContOnCl differentiable_id'\n  · rw [MapsTo]\n    intro z hz\n    exact scale_id_mem_verticalStrip_of_mem_verticalStrip hul hz\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interpStrip_of_mem_verticalClosedStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nl u : Real\nhul : LT.lt l u\nf : Complex → E\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip l u) z\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip l u)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip l u))\n⊢ LE.le (Norm.norm (f z)) (Norm.norm (Complex.HadamardThreeLines.interpStrip' f l u z))","decl":"/--\n**Hadamard three-line theorem**: If `f` is a bounded function, continuous on the\nclosed strip `re ⁻¹' [l, u]` and differentiable on open strip `re ⁻¹' (l, u)`, then for\n`M(x) := sup ((norm ∘ f) '' (re ⁻¹' {x}))` we have that for all `z` in the closed strip\n`re ⁻¹' [a,b]` the inequality\n`‖f(z)‖ ≤ M(0) ^ (1 - ((z.re - l) / (u - l))) * M(1) ^ ((z.re - l) / (u - l))`\nholds. -/\nlemma norm_le_interpStrip_of_mem_verticalClosedStrip {l u : ℝ} (hul: l < u)\n    {f : ℂ → E} {z : ℂ}\n    (hz : z ∈ verticalClosedStrip l u) (hd : DiffContOnCl ℂ f (verticalStrip l u))\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip l u)) :\n    ‖f z‖ ≤ ‖interpStrip' f l u z‖ := by\n  have hgoal := norm_le_interpStrip_of_mem_verticalClosedStrip₀₁ (scale f l u)\n    (mem_verticalClosedStrip_of_scale_id_mem_verticalClosedStrip hul hz)\n    (scale_diffContOnCl hul hd) (scale_bddAbove hul hB)\n  simp only [scale, smul_eq_mul, norm_eq_abs] at hgoal\n  rw [fun_arg_eq hul, div_sub_div_same, interpStrip_scale f hul z] at hgoal\n  exact hgoal\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interp_of_mem_verticalClosedStrip'","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nz : Complex\na b l u : Real\nhul : LT.lt l u\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip l u) z\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip l u)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip l u))\nha : ∀ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton l)) z → LE.le (Norm.norm (f z)) a\nhb : ∀ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton u)) z → LE.le (Norm.norm (f z)) b\n⊢ LE.le (Norm.norm (f z)) (HMul.hMul (HPow.hPow a (HSub.hSub 1 (HDiv.hDiv (HSub.hSub z.re l) (HSub.hSub u l)))) (HPow.hPow b (HDiv.hDiv (HSub.hSub z.re l) (HSub.hSub u l))))","decl":"/-- **Hadamard three-line theorem** (Variant in simpler terms): Let `f` be a\nbounded function, continuous on the closed strip `re ⁻¹' [l, u]` and differentiable on open strip\n`re ⁻¹' (l, u)`. If, for all `z.re = l`, `‖f z‖ ≤ a` for some `a ∈ ℝ` and, similarly, for all\n`z.re = u`, `‖f z‖ ≤ b` for some `b ∈ ℝ` then for all `z` in the closed strip\n`re ⁻¹' [l, u]` the inequality\n`‖f(z)‖ ≤ a ^ (1 - (z.re - l) / (u - l)) * b ^ ((z.re - l) / (u - l))`\nholds. -/\nlemma norm_le_interp_of_mem_verticalClosedStrip' {f : ℂ → E} {z : ℂ} {a b l u : ℝ}\n    (hul : l < u) (hz : z ∈ verticalClosedStrip l u) (hd : DiffContOnCl ℂ f (verticalStrip l u))\n    (hB : BddAbove ((norm ∘ f) '' verticalClosedStrip l u))\n    (ha : ∀ z ∈ re ⁻¹' {l}, ‖f z‖ ≤ a) (hb : ∀ z ∈ re ⁻¹' {u}, ‖f z‖ ≤ b) :\n    ‖f z‖ ≤ a ^ (1 - (z.re - l) / (u - l)) * b ^ ((z.re - l) / (u - l)) := by\n  have hgoal := norm_le_interp_of_mem_verticalClosedStrip₀₁' (scale f l u)\n    (mem_verticalClosedStrip_of_scale_id_mem_verticalClosedStrip hul hz) (scale_diffContOnCl hul hd)\n    (scale_bddAbove hul hB) (scale_bound_left ha) (scale_bound_right hb)\n  simp only [scale, smul_eq_mul, sub_re] at hgoal\n  rw [fun_arg_eq hul, bound_exp_eq hul] at hgoal\n  exact hgoal\n\n"}
