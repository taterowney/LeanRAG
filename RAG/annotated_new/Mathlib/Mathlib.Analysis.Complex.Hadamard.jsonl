{"name":"Complex.HadamardThreeLines.sSupNormIm_nonneg","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nx : Real\n‚ä¢ LE.le 0 (Complex.HadamardThreeLines.sSupNormIm f x)","decl":"/-- `sSup` of `norm` is nonneg applied to the image of `f` on the vertical line `re z = x` -/\nlemma sSupNormIm_nonneg (x : ‚Ñù) : 0 ‚â§ sSupNormIm f x := by\n  apply Real.sSup_nonneg\n  rintro y ‚ü®z1, _, hz2‚ü©\n  simp only [‚Üê hz2, comp, norm_nonneg]\n\n"}
{"name":"Complex.HadamardThreeLines.sSupNormIm_eps_pos","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nŒµ : Real\nhŒµ : GT.gt Œµ 0\nx : Real\n‚ä¢ LT.lt 0 (HAdd.hAdd Œµ (Complex.HadamardThreeLines.sSupNormIm f x))","decl":"/-- `sSup` of `norm` translated by `Œµ > 0` is positive applied to the image of `f` on the\nvertical line `re z = x` -/\nlemma sSupNormIm_eps_pos {Œµ : ‚Ñù} (hŒµ : Œµ > 0) (x : ‚Ñù) : 0 < Œµ + sSupNormIm f x := by\n   linarith [sSupNormIm_nonneg f x]\n\n"}
{"name":"Complex.HadamardThreeLines.abs_invInterpStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nz : Complex\nŒµ : Real\nhŒµ : GT.gt Œµ 0\n‚ä¢ Eq (Complex.abs (Complex.HadamardThreeLines.invInterpStrip f z Œµ)) (HMul.hMul (HPow.hPow (HAdd.hAdd Œµ (Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub z.re 1)) (HPow.hPow (HAdd.hAdd Œµ (Complex.HadamardThreeLines.sSupNormIm f 1)) (Neg.neg z.re)))","decl":"/-- Useful rewrite for the absolute value of `invInterpStrip`-/\nlemma abs_invInterpStrip {Œµ : ‚Ñù} (hŒµ : Œµ > 0) :\n    abs (invInterpStrip f z Œµ) =\n    (Œµ + sSupNormIm f 0) ^ (z.re - 1) * (Œµ + sSupNormIm f 1) ^ (-z.re) := by\n  simp only [invInterpStrip, map_mul]\n  repeat rw [‚Üê ofReal_add]\n  repeat rw [abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hŒµ _) _]\n  simp only [sub_re, one_re, neg_re]\n\n"}
{"name":"Complex.HadamardThreeLines.diffContOnCl_invInterpStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nŒµ : Real\nhŒµ : GT.gt Œµ 0\n‚ä¢ DiffContOnCl Complex (fun z => Complex.HadamardThreeLines.invInterpStrip f z Œµ) (Complex.HadamardThreeLines.verticalStrip 0 1)","decl":"/-- The function `invInterpStrip` is `diffContOnCl`. -/\nlemma diffContOnCl_invInterpStrip {Œµ : ‚Ñù} (hŒµ : Œµ > 0) :\n    DiffContOnCl ‚ÑÇ (fun z ‚Ü¶ invInterpStrip f z Œµ) (verticalStrip 0 1) := by\n  apply Differentiable.diffContOnCl\n  apply Differentiable.mul\n  ¬∑ apply Differentiable.const_cpow (Differentiable.sub_const (differentiable_id') 1) _\n    left\n    rw [‚Üê ofReal_add, ofReal_ne_zero]\n    simp only [ne_eq, ne_of_gt (sSupNormIm_eps_pos f hŒµ 0), not_false_eq_true]\n  ¬∑ apply Differentiable.const_cpow (Differentiable.neg differentiable_id')\n    apply Or.inl\n    rw [‚Üê ofReal_add, ofReal_ne_zero]\n    exact (ne_of_gt (sSupNormIm_eps_pos f hŒµ 1))\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_sSupNormIm","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nz : Complex\nhD : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\n‚ä¢ LE.le (Norm.norm (f z)) (Complex.HadamardThreeLines.sSupNormIm f z.re)","decl":"/-- If `f` is bounded on the unit vertical strip, then `f` is bounded by `sSupNormIm` there. -/\nlemma norm_le_sSupNormIm (f : ‚ÑÇ ‚Üí E) (z : ‚ÑÇ) (hD : z ‚àà verticalClosedStrip 0 1)\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1)) :\n    ‚Äñf z‚Äñ ‚â§ sSupNormIm f (z.re) := by\n  refine le_csSup ?_ ?_\n  ¬∑ apply BddAbove.mono (image_subset (norm ‚àò f) _) hB\n    exact preimage_mono (singleton_subset_iff.mpr hD)\n  ¬∑ apply mem_image_of_mem (norm ‚àò f)\n    simp only [mem_preimage, mem_singleton]\n\n"}
{"name":"Complex.HadamardThreeLines.norm_lt_sSupNormIm_eps","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nŒµ : Real\nhŒµ : GT.gt Œµ 0\nz : Complex\nhD : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\n‚ä¢ LT.lt (Norm.norm (f z)) (HAdd.hAdd Œµ (Complex.HadamardThreeLines.sSupNormIm f z.re))","decl":"/-- Alternative version of `norm_le_sSupNormIm` with a strict inequality and a positive `Œµ`. -/\nlemma norm_lt_sSupNormIm_eps (f : ‚ÑÇ ‚Üí E) (Œµ : ‚Ñù) (hŒµ : Œµ > 0) (z : ‚ÑÇ)\n    (hD : z ‚àà verticalClosedStrip 0 1) (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1)) :\n    ‚Äñf z‚Äñ < Œµ + sSupNormIm f (z.re) :=\n  lt_add_of_pos_of_le hŒµ (norm_le_sSupNormIm f z hD hB)\n\n"}
{"name":"Complex.HadamardThreeLines.F_BddAbove","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nŒµ : Real\nhŒµ : GT.gt Œµ 0\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\n‚ä¢ BddAbove (Set.image (Function.comp Norm.norm (Complex.HadamardThreeLines.F f Œµ)) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))","decl":"/-- When the function `f` is bounded above on a vertical strip, then so is `F`. -/\nlemma F_BddAbove (f : ‚ÑÇ ‚Üí E) (Œµ : ‚Ñù) (hŒµ : Œµ > 0)\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1)) :\n    BddAbove ((norm ‚àò (F f Œµ)) '' verticalClosedStrip 0 1) := by\n -- Rewriting goal\n  simp only [F, image_congr, comp_apply, map_mul, invInterpStrip]\n  rw [bddAbove_def] at *\n  rcases hB with ‚ü®B, hB‚ü©\n  -- Using bound\n  use ((max 1 ((Œµ + sSupNormIm f 0) ^ (-(1 : ‚Ñù)))) * max 1 ((Œµ + sSupNormIm f 1) ^ (-(1 : ‚Ñù)))) * B\n  simp only [mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff‚ÇÇ]\n  intros z hset\n  specialize hB (‚Äñf z‚Äñ) (by simpa [image_congr, mem_image, comp_apply] using ‚ü®z, hset, rfl‚ü©)\n  -- Proof that the bound is correct\n  simp only [norm_smul, norm_mul, ‚Üê ofReal_add]\n  gcongr\n    -- Bounding individual terms\n  ¬∑ by_cases hM0_one : 1 ‚â§ Œµ + sSupNormIm f 0\n    -- `1 ‚â§ sSupNormIm f 0`\n    ¬∑ apply le_trans _ (le_max_left _ _)\n      simp only [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hŒµ 0), sub_re,\n        one_re, Real.rpow_le_one_of_one_le_of_nonpos hM0_one (sub_nonpos.mpr hset.2)]\n    -- `0 < sSupNormIm f 0 < 1`\n    ¬∑ rw [not_le] at hM0_one; apply le_trans _ (le_max_right _ _)\n      simp only [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hŒµ 0), sub_re,\n        one_re]\n      apply Real.rpow_le_rpow_of_exponent_ge (sSupNormIm_eps_pos f hŒµ 0) (le_of_lt hM0_one) _\n      simp only [neg_le_sub_iff_le_add, le_add_iff_nonneg_left, hset.1]\n  ¬∑ by_cases hM1_one : 1 ‚â§ Œµ + sSupNormIm f 1\n    -- `1 ‚â§ sSupNormIm f 1`\n    ¬∑ apply le_trans _ (le_max_left _ _)\n      simp only [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hŒµ 1), sub_re,\n        one_re, neg_re, Real.rpow_le_one_of_one_le_of_nonpos\n        hM1_one (Right.neg_nonpos_iff.mpr hset.1)]\n    -- `0 < sSupNormIm f 1 < 1`\n    ¬∑ rw [not_le] at hM1_one; apply le_trans _ (le_max_right _ _)\n      simp only [norm_eq_abs, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hŒµ 1), sub_re,\n        one_re, neg_re, Real.rpow_le_rpow_of_exponent_ge (sSupNormIm_eps_pos f hŒµ 1)\n        (le_of_lt hM1_one) (neg_le_neg_iff.mpr hset.2)]\n\n"}
{"name":"Complex.HadamardThreeLines.F_edge_le_one","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nŒµ : Real\nhŒµ : GT.gt Œµ 0\nz : Complex\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhz : Membership.mem (Set.preimage Complex.re (Insert.insert 0 (Singleton.singleton 1))) z\n‚ä¢ LE.le (Norm.norm (Complex.HadamardThreeLines.F f Œµ z)) 1","decl":"/-- Proof that `F` is bounded by one one the edges. -/\nlemma F_edge_le_one (f : ‚ÑÇ ‚Üí E) (Œµ : ‚Ñù) (hŒµ : Œµ > 0) (z : ‚ÑÇ)\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1)) (hz : z ‚àà re ‚Åª¬π' {0, 1}) :\n    ‚ÄñF f Œµ z‚Äñ ‚â§ 1 := by\n  simp only [F, norm_smul, norm_eq_abs, map_mul, abs_cpow_eq_rpow_re_of_pos,\n    abs_invInterpStrip f z hŒµ, sSupNormIm_eps_pos f hŒµ 1,\n    sub_re, one_re, neg_re]\n  rcases hz with hz0 | hz1\n  -- `z.re = 0`\n  ¬∑ simp only [hz0, zero_sub, Real.rpow_neg_one, neg_zero, Real.rpow_zero, mul_one,\n      inv_mul_le_iff‚ÇÄ (sSupNormIm_eps_pos f hŒµ 0)]\n    rw [‚Üê hz0]\n    apply le_of_lt (norm_lt_sSupNormIm_eps f Œµ hŒµ _ _ hB)\n    simp only [verticalClosedStrip, mem_preimage, zero_le_one, left_mem_Icc, hz0]\n  -- `z.re = 1`\n  ¬∑ rw [mem_singleton_iff] at hz1\n    simp only [hz1, one_mul, Real.rpow_zero, sub_self, Real.rpow_neg_one,\n      inv_mul_le_iff‚ÇÄ (sSupNormIm_eps_pos f hŒµ 1), mul_one]\n    rw [‚Üê hz1]\n    apply le_of_lt (norm_lt_sSupNormIm_eps f Œµ hŒµ _ _ hB)\n    simp only [verticalClosedStrip, mem_preimage, zero_le_one, hz1, right_mem_Icc]\n\n"}
{"name":"Complex.HadamardThreeLines.norm_mul_invInterpStrip_le_one_of_mem_verticalClosedStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\nz : Complex\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\n‚ä¢ LE.le (Norm.norm (Complex.HadamardThreeLines.F f Œµ z)) 1","decl":"theorem norm_mul_invInterpStrip_le_one_of_mem_verticalClosedStrip (f : ‚ÑÇ ‚Üí E) (Œµ : ‚Ñù) (hŒµ : 0 < Œµ)\n    (z : ‚ÑÇ) (hd : DiffContOnCl ‚ÑÇ f (verticalStrip 0 1))\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1)) (hz : z ‚àà verticalClosedStrip 0 1) :\n    ‚ÄñF f Œµ z‚Äñ ‚â§ 1 := by\n  apply PhragmenLindelof.vertical_strip\n    (DiffContOnCl.smul (diffContOnCl_invInterpStrip f hŒµ) hd) _\n    (fun x hx ‚Ü¶ F_edge_le_one f Œµ hŒµ x hB (Or.inl hx))\n    (fun x hx ‚Ü¶ F_edge_le_one f Œµ hŒµ x hB (Or.inr hx)) hz.1 hz.2\n  use 0\n  rw [sub_zero, div_one]\n  refine ‚ü® Real.pi_pos, ?_‚ü©\n  obtain ‚ü®BF, hBF‚ü© := F_BddAbove f Œµ hŒµ hB\n  simp only [comp_apply, mem_upperBounds, mem_image, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff‚ÇÇ] at hBF\n  use BF\n  rw [Asymptotics.isBigO_iff]\n  use 1\n  rw [eventually_inf_principal]\n  apply Eventually.of_forall\n  intro x hx\n  norm_num\n  exact (hBF x ((preimage_mono Ioo_subset_Icc_self) hx)).trans\n    ((le_of_lt (lt_add_one BF)).trans (Real.add_one_le_exp BF))\n\n"}
{"name":"Complex.HadamardThreeLines.interpStrip_eq_of_pos","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nz : Complex\nh0 : LT.lt 0 (Complex.HadamardThreeLines.sSupNormIm f 0)\nh1 : LT.lt 0 (Complex.HadamardThreeLines.sSupNormIm f 1)\n‚ä¢ Eq (Complex.HadamardThreeLines.interpStrip f z) (HMul.hMul (HPow.hPow (‚Üë(Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub 1 z)) (HPow.hPow (‚Üë(Complex.HadamardThreeLines.sSupNormIm f 1)) z))","decl":"/-- Rewrite for `InterpStrip` when `0 < sSupNormIm f 0` and `0 < sSupNormIm f 1`. -/\nlemma interpStrip_eq_of_pos (z : ‚ÑÇ) (h0 : 0 < sSupNormIm f 0) (h1 : 0 < sSupNormIm f 1) :\n    interpStrip f z = sSupNormIm f 0 ^ (1 - z) * sSupNormIm f 1 ^ z := by\n  simp only [ne_of_gt h0, ne_of_gt h1, interpStrip, if_false, or_false]\n\n"}
{"name":"Complex.HadamardThreeLines.interpStrip_eq_of_zero","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nz : Complex\nh : Or (Eq (Complex.HadamardThreeLines.sSupNormIm f 0) 0) (Eq (Complex.HadamardThreeLines.sSupNormIm f 1) 0)\n‚ä¢ Eq (Complex.HadamardThreeLines.interpStrip f z) 0","decl":"/-- Rewrite for `InterpStrip` when `0 = sSupNormIm f 0` or `0 = sSupNormIm f 1`. -/\nlemma interpStrip_eq_of_zero (z : ‚ÑÇ) (h : sSupNormIm f 0 = 0 ‚à® sSupNormIm f 1 = 0) :\n    interpStrip f z = 0 :=\n  if_pos h\n\n"}
{"name":"Complex.HadamardThreeLines.interpStrip_eq_of_mem_verticalStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalStrip 0 1) z\n‚ä¢ Eq (Complex.HadamardThreeLines.interpStrip f z) (HMul.hMul (HPow.hPow (‚Üë(Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub 1 z)) (HPow.hPow (‚Üë(Complex.HadamardThreeLines.sSupNormIm f 1)) z))","decl":"/-- Rewrite for `InterpStrip` on the open vertical strip. -/\nlemma interpStrip_eq_of_mem_verticalStrip (z : ‚ÑÇ) (hz : z ‚àà verticalStrip 0 1) :\n    interpStrip f z = sSupNormIm f 0 ^ (1 - z) * sSupNormIm f 1 ^ z := by\n  by_cases h : sSupNormIm f 0 = 0 ‚à® sSupNormIm f 1 = 0\n  ¬∑ rw [interpStrip_eq_of_zero _ z h]\n    rcases h with h0 | h1\n    ¬∑ simp only [h0, ofReal_zero, zero_eq_mul, cpow_eq_zero_iff, ne_eq, true_and, ofReal_eq_zero]\n      left\n      rw [sub_eq_zero, eq_comm]\n      simp only [ne_eq, Complex.ext_iff, one_re, ne_of_lt hz.2, or_iff_left, false_and,\n        not_false_eq_true]\n    ¬∑ simp only [h1, ofReal_zero, zero_eq_mul, cpow_eq_zero_iff, ofReal_eq_zero, ne_eq, true_and]\n      right\n      rw [eq_comm]\n      simp only [ne_eq, Complex.ext_iff, zero_re, ne_of_lt hz.1, or_iff_left, false_and,\n        not_false_eq_true]\n  ¬∑ push_neg at h\n    replace h : (0 < sSupNormIm f 0) ‚àß (0 < sSupNormIm f 1) :=\n      ‚ü®(lt_of_le_of_ne (sSupNormIm_nonneg f 0) (ne_comm.mp h.1)),\n        (lt_of_le_of_ne (sSupNormIm_nonneg f 1) (ne_comm.mp h.2))‚ü©\n    exact interpStrip_eq_of_pos f z h.1 h.2\n\n"}
{"name":"Complex.HadamardThreeLines.diffContOnCl_interpStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\n‚ä¢ DiffContOnCl Complex (Complex.HadamardThreeLines.interpStrip f) (Complex.HadamardThreeLines.verticalStrip 0 1)","decl":"lemma diffContOnCl_interpStrip :\n    DiffContOnCl ‚ÑÇ (interpStrip f) (verticalStrip 0 1) := by\n  by_cases h : sSupNormIm f 0 = 0 ‚à® sSupNormIm f 1 = 0\n  -- Case everywhere 0\n  ¬∑ eta_expand; simp_rw [interpStrip_eq_of_zero f _ h]; exact diffContOnCl_const\n  -- Case nowhere 0\n  ¬∑ push_neg at h\n    rcases h with ‚ü®h0, h1‚ü©\n    rw [ne_comm] at h0 h1\n    apply Differentiable.diffContOnCl\n    intro z\n    eta_expand\n    simp_rw [interpStrip_eq_of_pos f _ (lt_of_le_of_ne (sSupNormIm_nonneg f 0) h0)\n      (lt_of_le_of_ne (sSupNormIm_nonneg f 1) h1)]\n    refine DifferentiableAt.mul ?_ ?_\n    ¬∑ apply DifferentiableAt.const_cpow (DifferentiableAt.const_sub (differentiableAt_id') 1) _\n      left; simp only [Ne, ofReal_eq_zero]; rwa [eq_comm]\n    ¬∑ refine DifferentiableAt.const_cpow ?_ ?_\n      ¬∑ apply differentiableAt_id'\n      ¬∑ left; simp only [Ne, ofReal_eq_zero]; rwa [eq_comm]\n\n"}
{"name":"Complex.HadamardThreeLines.scale_id_mem_verticalClosedStrip_of_mem_verticalClosedStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"l u : Real\nhul : LT.lt l u\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\n‚ä¢ Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip l u) (HAdd.hAdd (‚Üël) (HMul.hMul z (HSub.hSub ‚Üëu ‚Üël)))","decl":"/-- The transformation on ‚ÑÇ that is used for `scale` maps the closed strip ``re ‚Åª¬π' [l, u]``\n  to the closed strip ``re ‚Åª¬π' [0, 1]``. -/\nlemma scale_id_mem_verticalClosedStrip_of_mem_verticalClosedStrip {l u : ‚Ñù} (hul : l < u) {z : ‚ÑÇ}\n    (hz : z ‚àà verticalClosedStrip 0 1) : l + z * (u - l) ‚àà verticalClosedStrip l u := by\n  simp only [verticalClosedStrip, mem_preimage, add_re, ofReal_re, mul_re, sub_re, sub_im,\n    ofReal_im, sub_self, mul_zero, sub_zero, mem_Icc, le_add_iff_nonneg_right]\n  simp only [verticalClosedStrip, mem_preimage, mem_Icc] at hz\n  obtain ‚ü®hz‚ÇÅ, hz‚ÇÇ‚ü© := hz\n  simp only [sub_pos, hul, mul_nonneg_iff_of_pos_right, hz‚ÇÅ, true_and]\n  rw [add_comm, ‚Üê sub_le_sub_iff_right l, add_sub_assoc, sub_self, add_zero]\n  nth_rewrite 2 [‚Üê one_mul (u - l)]\n  have := sub_nonneg.2 hul.le\n  gcongr\n\n"}
{"name":"Complex.HadamardThreeLines.scale_bddAbove","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nl u : Real\nhul : LT.lt l u\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip l u))\n‚ä¢ BddAbove (Set.image (Function.comp Norm.norm (Complex.HadamardThreeLines.scale f l u)) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))","decl":"/-- The norm of the function `scale f l u` is bounded above on the closed strip `re‚Åª¬π' [0, 1]`. -/\nlemma scale_bddAbove {f : ‚ÑÇ ‚Üí E} {l u : ‚Ñù} (hul : l < u)\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip l u)) :\n    BddAbove ((norm ‚àò scale f l u) '' verticalClosedStrip 0 1) := by\n  obtain ‚ü®R, hR‚ü© := bddAbove_def.mp hB\n  rw [bddAbove_def]\n  use R\n  intro r hr\n  obtain ‚ü®w, hw‚ÇÅ, hw‚ÇÇ, _‚ü© := hr\n  simp only [comp_apply, scale, smul_eq_mul]\n  have : ‚Äñf (‚Üël + w * (‚Üëu - ‚Üël))‚Äñ ‚àà norm ‚àò f '' verticalClosedStrip l u := by\n    simp only [comp_apply, mem_image]\n    use ‚Üël + w * (‚Üëu - ‚Üël)\n    simp only [and_true]\n    exact scale_id_mem_verticalClosedStrip_of_mem_verticalClosedStrip hul hw‚ÇÅ\n  exact hR ‚Äñf (‚Üël + w * (‚Üëu - ‚Üël))‚Äñ this\n\n"}
{"name":"Complex.HadamardThreeLines.scale_bound_left","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nl u a : Real\nha : ‚àÄ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton l)) z ‚Üí LE.le (Norm.norm (f z)) a\nz : Complex\na‚úù : Membership.mem (Set.preimage Complex.re (Singleton.singleton 0)) z\n‚ä¢ LE.le (Norm.norm (Complex.HadamardThreeLines.scale f l u z)) a","decl":"/-- A bound to the norm of `f` on the line `z.re = l` induces a bound to the norm of\n  `scale f l u z` on the line `z.re = 0`. -/\nlemma scale_bound_left {f : ‚ÑÇ ‚Üí E} {l u a : ‚Ñù} (ha : ‚àÄ z ‚àà re ‚Åª¬π' {l}, ‚Äñf z‚Äñ ‚â§ a) :\n    ‚àÄ z ‚àà re ‚Åª¬π' {0}, ‚Äñscale f l u z‚Äñ ‚â§ a := by\n  simp only [mem_preimage, mem_singleton_iff, scale, smul_eq_mul]\n  intro z hz\n  exact ha (‚Üël + z * (‚Üëu - ‚Üël)) (by simp [hz])\n\n"}
{"name":"Complex.HadamardThreeLines.scale_bound_right","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nl u b : Real\nhb : ‚àÄ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton u)) z ‚Üí LE.le (Norm.norm (f z)) b\nz : Complex\na‚úù : Membership.mem (Set.preimage Complex.re (Singleton.singleton 1)) z\n‚ä¢ LE.le (Norm.norm (Complex.HadamardThreeLines.scale f l u z)) b","decl":"/-- A bound to the norm of `f` on the line `z.re = u` induces a bound to the norm of `scale f l u z`\n  on the line `z.re = 1`. -/\nlemma scale_bound_right {f : ‚ÑÇ ‚Üí E} {l u b : ‚Ñù} (hb : ‚àÄ z ‚àà re ‚Åª¬π' {u}, ‚Äñf z‚Äñ ‚â§ b) :\n    ‚àÄ z ‚àà re ‚Åª¬π' {1}, ‚Äñscale f l u z‚Äñ ‚â§ b := by\n  simp only [scale, mem_preimage, mem_singleton_iff, smul_eq_mul]\n  intro z hz\n  exact hb (‚Üël + z * (‚Üëu - ‚Üël)) (by simp [hz])\n\n"}
{"name":"Complex.HadamardThreeLines.sSupNormIm_scale_left","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nl u : Real\nhul : LT.lt l u\n‚ä¢ Eq (Complex.HadamardThreeLines.sSupNormIm (Complex.HadamardThreeLines.scale f l u) 0) (Complex.HadamardThreeLines.sSupNormIm f l)","decl":"/-- The supremum of the norm of `scale f l u` on the line `z.re = 0` is the same as the supremum\n  of `f` on the line `z.re = l`. -/\nlemma sSupNormIm_scale_left (f : ‚ÑÇ ‚Üí E) {l u : ‚Ñù} (hul : l < u) :\n    sSupNormIm (scale f l u) 0 = sSupNormIm f l := by\n  simp_rw [sSupNormIm, image_comp]\n  have : scale f l u '' (re ‚Åª¬π' {0}) = f '' (re ‚Åª¬π' {l}) := by\n    ext e\n    simp only [scale, smul_eq_mul, mem_image, mem_preimage, mem_singleton_iff]\n    constructor\n    ¬∑ intro h\n      obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := h\n      use ‚Üël + z * (‚Üëu - ‚Üël)\n      simp [hz‚ÇÅ, hz‚ÇÇ]\n    ¬∑ intro h\n      obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := h\n      use ((z - l) / (u - l))\n      constructor\n      ¬∑ norm_cast\n        rw [Complex.div_re, Complex.normSq_ofReal, Complex.ofReal_re]\n        simp[hz‚ÇÅ]\n      ¬∑ rw [div_mul_comm, div_self (by norm_cast; linarith)]\n        simp [hz‚ÇÇ]\n  rw [this]\n\n"}
{"name":"Complex.HadamardThreeLines.sSupNormIm_scale_right","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nl u : Real\nhul : LT.lt l u\n‚ä¢ Eq (Complex.HadamardThreeLines.sSupNormIm (Complex.HadamardThreeLines.scale f l u) 1) (Complex.HadamardThreeLines.sSupNormIm f u)","decl":"/-- The supremum of the norm of `scale f l u` on the line `z.re = 1` is the same as\n  the supremum of `f` on the line `z.re = u`. -/\nlemma sSupNormIm_scale_right (f : ‚ÑÇ ‚Üí E) {l u : ‚Ñù} (hul : l < u) :\n    sSupNormIm (scale f l u) 1 = sSupNormIm f u := by\n  simp_rw [sSupNormIm, image_comp]\n  have : scale f l u '' (re ‚Åª¬π' {1}) = f '' (re ‚Åª¬π' {u}) := by\n    ext e\n    simp only [scale, smul_eq_mul, mem_image, mem_preimage, mem_singleton_iff]\n    constructor\n    ¬∑ intro h\n      obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := h\n      use ‚Üël + z * (‚Üëu - ‚Üël)\n      simp only [add_re, ofReal_re, mul_re, hz‚ÇÅ, sub_re, one_mul, sub_im, ofReal_im, sub_self,\n        mul_zero, sub_zero, add_sub_cancel, hz‚ÇÇ, and_self]\n    ¬∑ intro h\n      obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := h\n      use ((z - l) / (u - l))\n      constructor\n      ¬∑ norm_cast\n        rw [Complex.div_re, Complex.normSq_ofReal, Complex.ofReal_re]\n        simp only [sub_re, hz‚ÇÅ, ofReal_re, sub_im, ofReal_im, sub_zero, ofReal_sub, sub_self,\n          mul_zero, zero_div, add_zero]\n        rw [div_mul_eq_div_div_swap, mul_div_assoc,\n          div_self (by norm_cast; linarith),\n          mul_one, div_self (by norm_cast; linarith)]\n      ¬∑ rw [div_mul_comm, div_self (by norm_cast; linarith)]\n        simp only [one_mul, add_sub_cancel, hz‚ÇÇ]\n  rw [this]\n\n"}
{"name":"Complex.HadamardThreeLines.interpStrip_scale","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : Complex ‚Üí E\nl u : Real\nhul : LT.lt l u\nz : Complex\n‚ä¢ Eq (Complex.HadamardThreeLines.interpStrip (Complex.HadamardThreeLines.scale f l u) (HDiv.hDiv (HSub.hSub z ‚Üël) (HSub.hSub ‚Üëu ‚Üël))) (Complex.HadamardThreeLines.interpStrip' f l u z)","decl":"/-- A technical lemma relating the bounds given by the three lines lemma on a general strip\nto the bounds for its scaled version on the strip ``re ‚Åª¬π' [0, 1]`. -/\nlemma interpStrip_scale (f : ‚ÑÇ ‚Üí E) {l u : ‚Ñù} (hul: l < u) (z : ‚ÑÇ)  : interpStrip (scale f l u)\n    ((z - ‚Üël) / (‚Üëu - ‚Üël)) = interpStrip' f l u z := by\n  simp only [interpStrip, interpStrip']\n  simp_rw [sSupNormIm_scale_left f hul, sSupNormIm_scale_right f hul]\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interpStrip_of_mem_verticalClosedStrip_eps","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\nf : Complex ‚Üí E\ninst‚úù : NormedSpace Complex E\nŒµ : Real\nhŒµ : GT.gt Œµ 0\nz : Complex\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\n‚ä¢ LE.le (Norm.norm (f z)) (Norm.norm (HMul.hMul (HPow.hPow (HAdd.hAdd ‚ÜëŒµ ‚Üë(Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub 1 z)) (HPow.hPow (HAdd.hAdd ‚ÜëŒµ ‚Üë(Complex.HadamardThreeLines.sSupNormIm f 1)) z)))","decl":"lemma norm_le_interpStrip_of_mem_verticalClosedStrip_eps (Œµ : ‚Ñù) (hŒµ : Œµ > 0) (z : ‚ÑÇ)\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1))\n    (hd : DiffContOnCl ‚ÑÇ f (verticalStrip 0 1)) (hz : z ‚àà verticalClosedStrip 0 1) :\n    ‚Äñf z‚Äñ ‚â§  ‚Äñ((Œµ + sSupNormIm f 0) ^ (1-z) * (Œµ + sSupNormIm f 1) ^ z : ‚ÑÇ)‚Äñ := by\n  simp only [F, abs_invInterpStrip _ _ hŒµ, norm_smul, norm_mul, norm_eq_abs,\n    ‚Üê ofReal_add, abs_cpow_eq_rpow_re_of_pos (sSupNormIm_eps_pos f hŒµ _) _, sub_re, one_re]\n  rw [‚Üê mul_inv_le_iff‚ÇÄ', ‚Üê one_mul (((Œµ + sSupNormIm f 1) ^ z.re)), ‚Üê mul_inv_le_iff‚ÇÄ,\n    ‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_neg_one]\n  ¬∑ simp only [‚Üê Real.rpow_mul (le_of_lt (sSupNormIm_eps_pos f hŒµ _)),\n    mul_neg, mul_one, neg_sub, mul_assoc]\n    simpa [F, abs_invInterpStrip _ _ hŒµ, norm_smul, mul_comm] using\n      norm_mul_invInterpStrip_le_one_of_mem_verticalClosedStrip f Œµ hŒµ z hd hB hz\n  ¬∑ simp only [Real.rpow_pos_of_pos (sSupNormIm_eps_pos f hŒµ _) z.re]\n  ¬∑ simp only [Real.rpow_pos_of_pos (sSupNormIm_eps_pos f hŒµ _) (1-z.re)]\n\n"}
{"name":"Complex.HadamardThreeLines.eventuallyle","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\nf : Complex ‚Üí E\ninst‚úù : NormedSpace Complex E\nz : Complex\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhz : Membership.mem (Complex.HadamardThreeLines.verticalStrip 0 1) z\n‚ä¢ (nhdsWithin 0 (Set.Ioi 0)).EventuallyLE (fun x => Norm.norm (f z)) fun Œµ => Norm.norm (HMul.hMul (HPow.hPow (HAdd.hAdd ‚ÜëŒµ ‚Üë(Complex.HadamardThreeLines.sSupNormIm f 0)) (HSub.hSub 1 z)) (HPow.hPow (HAdd.hAdd ‚ÜëŒµ ‚Üë(Complex.HadamardThreeLines.sSupNormIm f 1)) z))","decl":"lemma eventuallyle (z : ‚ÑÇ) (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1))\n    (hd : DiffContOnCl ‚ÑÇ f (verticalStrip 0 1)) (hz : z ‚àà verticalStrip 0 1) :\n    (fun _ : ‚Ñù ‚Ü¶ ‚Äñf z‚Äñ) ‚â§·∂†[ùìù[>] 0]\n    (fun Œµ ‚Ü¶ ‚Äñ((Œµ + sSupNormIm f 0) ^ (1 - z) * (Œµ + sSupNormIm f 1) ^ z : ‚ÑÇ)‚Äñ) := by\n  filter_upwards [self_mem_nhdsWithin] with Œµ (hŒµ : 0 < Œµ) using\n    norm_le_interpStrip_of_mem_verticalClosedStrip_eps f Œµ hŒµ z hB hd\n      (mem_of_mem_of_subset hz (preimage_mono Ioo_subset_Icc_self))\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interpStrip_of_mem_verticalStrip_zero","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\nf : Complex ‚Üí E\ninst‚úù : NormedSpace Complex E\nz : Complex\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nhz : Membership.mem (Complex.HadamardThreeLines.verticalStrip 0 1) z\n‚ä¢ LE.le (Norm.norm (f z)) (Norm.norm (Complex.HadamardThreeLines.interpStrip f z))","decl":"lemma norm_le_interpStrip_of_mem_verticalStrip_zero (z : ‚ÑÇ)\n    (hd : DiffContOnCl ‚ÑÇ f (verticalStrip 0 1))\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1)) (hz : z ‚àà verticalStrip 0 1) :\n    ‚Äñf z‚Äñ ‚â§ ‚ÄñinterpStrip f z‚Äñ := by\n  apply tendsto_le_of_eventuallyLE _ _ (eventuallyle f z hB hd hz)\n  ¬∑ apply tendsto_inf_left\n    simp only [tendsto_const_nhds_iff]\n  -- Proof that we can let epsilon tend to zero.\n  ¬∑ rw [interpStrip_eq_of_mem_verticalStrip _ _ hz]\n    convert ContinuousWithinAt.tendsto _ using 2\n    ¬∑ simp only [ofReal_zero, zero_add]\n    ¬∑ simp_rw [‚Üê ofReal_add, norm_eq_abs]\n      have : ‚àÄ x ‚àà Ioi 0, (x + sSupNormIm f 0) ^ (1 - z.re) * (x + sSupNormIm f 1) ^ z.re\n          = abs (‚Üë(x + sSupNormIm f 0) ^ (1 - z) * ‚Üë(x + sSupNormIm f 1) ^ z) := by\n              intro x hx\n              simp only [map_mul]\n              repeat rw [abs_cpow_eq_rpow_re_of_nonneg (le_of_lt (sSupNormIm_eps_pos f hx _)) _]\n              ¬∑ simp only [sub_re, one_re]\n              ¬∑ simpa using (ne_comm.mpr (ne_of_lt hz.1))\n              ¬∑ simpa [sub_eq_zero] using (ne_comm.mpr (ne_of_lt hz.2))\n      apply tendsto_nhdsWithin_congr this _\n      simp only [zero_add]\n      rw [map_mul, abs_cpow_eq_rpow_re_of_nonneg (sSupNormIm_nonneg _ _) _,\n        abs_cpow_eq_rpow_re_of_nonneg (sSupNormIm_nonneg _ _) _]\n      ¬∑ apply Tendsto.mul\n        ¬∑ apply Tendsto.rpow_const\n          ¬∑ nth_rw 2 [‚Üê zero_add (sSupNormIm f 0)]\n            exact Tendsto.add_const (sSupNormIm f 0) (tendsto_nhdsWithin_of_tendsto_nhds\n              (Continuous.tendsto continuous_id' _))\n          ¬∑ right; simp only [sub_nonneg, le_of_lt hz.2]\n        ¬∑ apply Tendsto.rpow_const\n          ¬∑ nth_rw 2 [‚Üê zero_add (sSupNormIm f 1)]\n            exact Tendsto.add_const (sSupNormIm f 1) (tendsto_nhdsWithin_of_tendsto_nhds\n              (Continuous.tendsto continuous_id' _))\n          ¬∑ right; simp only [sub_nonneg, le_of_lt hz.1]\n      ¬∑ simpa using (ne_comm.mpr (ne_of_lt hz.1))\n      ¬∑ simpa [sub_eq_zero] using (ne_comm.mpr (ne_of_lt hz.2))\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interpStrip_of_mem_verticalClosedStrip‚ÇÄ‚ÇÅ","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\n‚ä¢ LE.le (Norm.norm (f z)) (Norm.norm (Complex.HadamardThreeLines.interpStrip f z))","decl":"/--\n**Hadamard three-line theorem** on `re ‚Åª¬π' [0, 1]`: If `f` is a bounded function, continuous on the\nclosed strip `re ‚Åª¬π' [0, 1]` and differentiable on open strip `re ‚Åª¬π' (0, 1)`, then for\n`M(x) := sup ((norm ‚àò f) '' (re ‚Åª¬π' {x}))` we have that for all `z` in the closed strip\n`re ‚Åª¬π' [0, 1]` the inequality `‚Äñf(z)‚Äñ ‚â§ M(0) ^ (1 - z.re) * M(1) ^ z.re` holds. -/\nlemma norm_le_interpStrip_of_mem_verticalClosedStrip‚ÇÄ‚ÇÅ (f : ‚ÑÇ ‚Üí E) {z : ‚ÑÇ}\n    (hz : z ‚àà verticalClosedStrip 0 1) (hd : DiffContOnCl ‚ÑÇ f (verticalStrip 0 1))\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1)) :\n    ‚Äñf z‚Äñ ‚â§ ‚ÄñinterpStrip f z‚Äñ := by\n  apply le_on_closure (fun w hw ‚Ü¶ norm_le_interpStrip_of_mem_verticalStrip_zero f w hd hB hw)\n    (Continuous.comp_continuousOn' continuous_norm hd.2)\n    (Continuous.comp_continuousOn' continuous_norm (diffContOnCl_interpStrip f).2)\n  rwa [verticalClosedStrip, ‚Üê closure_Ioo zero_ne_one, ‚Üê closure_preimage_re] at hz\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interp_of_mem_verticalClosedStrip‚ÇÄ‚ÇÅ'","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nz : Complex\na b : Real\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) z\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip 0 1)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip 0 1))\nha : ‚àÄ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton 0)) z ‚Üí LE.le (Norm.norm (f z)) a\nhb : ‚àÄ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton 1)) z ‚Üí LE.le (Norm.norm (f z)) b\n‚ä¢ LE.le (Norm.norm (f z)) (HMul.hMul (HPow.hPow a (HSub.hSub 1 z.re)) (HPow.hPow b z.re))","decl":"/-- **Hadamard three-line theorem** on `re ‚Åª¬π' [0, 1]` (Variant in simpler terms): Let `f` be a\nbounded function, continuous on the closed strip `re ‚Åª¬π' [0, 1]` and differentiable on open strip\n`re ‚Åª¬π' (0, 1)`. If, for all `z.re = 0`, `‚Äñf z‚Äñ ‚â§ a` for some `a ‚àà ‚Ñù` and, similarly, for all\n`z.re = 1`, `‚Äñf z‚Äñ ‚â§ b` for some `b ‚àà ‚Ñù` then for all `z` in the closed strip\n`re ‚Åª¬π' [0, 1]` the inequality `‚Äñf(z)‚Äñ ‚â§ a ^ (1 - z.re) * b ^ z.re` holds. -/\nlemma norm_le_interp_of_mem_verticalClosedStrip‚ÇÄ‚ÇÅ' (f : ‚ÑÇ ‚Üí E) {z : ‚ÑÇ} {a b : ‚Ñù}\n    (hz : z ‚àà verticalClosedStrip 0 1) (hd : DiffContOnCl ‚ÑÇ f (verticalStrip 0 1))\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip 0 1))\n    (ha : ‚àÄ z ‚àà re ‚Åª¬π' {0}, ‚Äñf z‚Äñ ‚â§ a) (hb : ‚àÄ z ‚àà re ‚Åª¬π' {1}, ‚Äñf z‚Äñ ‚â§ b) :\n    ‚Äñf z‚Äñ ‚â§ a ^ (1 - z.re) * b ^ z.re := by\n  have : ‚ÄñinterpStrip f z‚Äñ ‚â§ sSupNormIm f 0 ^ (1 - z.re) * sSupNormIm f 1 ^ z.re := by\n    by_cases h : sSupNormIm f 0 = 0 ‚à® sSupNormIm f 1 = 0\n    ¬∑ rw [interpStrip_eq_of_zero f z h, norm_zero, mul_nonneg_iff]\n      left\n      exact ‚ü®Real.rpow_nonneg (sSupNormIm_nonneg f _) _,\n        Real.rpow_nonneg (sSupNormIm_nonneg f _) _ ‚ü©\n    ¬∑ push_neg at h\n      rcases h with ‚ü®h0, h1‚ü©\n      rw [ne_comm] at h0 h1\n      simp_rw [interpStrip_eq_of_pos f _ (lt_of_le_of_ne (sSupNormIm_nonneg f 0) h0)\n        (lt_of_le_of_ne (sSupNormIm_nonneg f 1) h1)]\n      simp only [norm_eq_abs, map_mul]\n      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h0).mp (sSupNormIm_nonneg f _)) _]\n      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h1).mp (sSupNormIm_nonneg f _)) _]\n      simp only [sub_re, one_re, le_refl]\n  apply (norm_le_interpStrip_of_mem_verticalClosedStrip‚ÇÄ‚ÇÅ f hz hd hB).trans (this.trans _)\n  apply mul_le_mul_of_nonneg _ _ (Real.rpow_nonneg (sSupNormIm_nonneg f _) _)\n  ¬∑ apply (Real.rpow_nonneg _ _)\n    specialize hb 1\n    simp only [mem_preimage, one_re, mem_singleton_iff, forall_true_left] at hb\n    exact (norm_nonneg _).trans hb\n  ¬∑ apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ (sub_nonneg.mpr hz.2)\n    ¬∑ rw [sSupNormIm]\n      apply csSup_le _\n      ¬∑ simpa [comp_apply, mem_image, forall_exists_index,\n          and_imp, forall_apply_eq_imp_iff‚ÇÇ] using ha\n      ¬∑ use ‚Äñ(f 0)‚Äñ, 0\n        simp only [mem_preimage, zero_re, mem_singleton_iff, comp_apply,\n          and_self]\n  ¬∑ apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ hz.1\n    ¬∑ rw [sSupNormIm]\n      apply csSup_le _\n      ¬∑ simpa [comp_apply, mem_image, forall_exists_index,\n          and_imp, forall_apply_eq_imp_iff‚ÇÇ] using hb\n      ¬∑ use ‚Äñ(f 1)‚Äñ, 1\n        simp only [mem_preimage, one_re, mem_singleton_iff, comp_apply,\n          and_self]\n\n"}
{"name":"Complex.HadamardThreeLines.scale_id_mem_verticalStrip_of_mem_verticalStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"l u : Real\nhul : LT.lt l u\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalStrip 0 1) z\n‚ä¢ Membership.mem (Complex.HadamardThreeLines.verticalStrip l u) (HAdd.hAdd (‚Üël) (HMul.hMul z (HSub.hSub ‚Üëu ‚Üël)))","decl":"/-- The transformation on ‚ÑÇ that is used for `scale` maps the strip ``re ‚Åª¬π' (l, u)``\n  to the strip ``re ‚Åª¬π' (0, 1)``. -/\nlemma scale_id_mem_verticalStrip_of_mem_verticalStrip {l u : ‚Ñù} (hul : l < u) {z : ‚ÑÇ}\n    (hz : z ‚àà verticalStrip 0 1) : l + z * (u - l) ‚àà verticalStrip l u := by\n  simp only [verticalStrip, mem_preimage, mem_Ioo] at hz\n  simp only [verticalStrip, mem_preimage, add_re, ofReal_re, mul_re, sub_re, sub_im, ofReal_im,\n    sub_self, mul_zero, sub_zero, mem_Ioo, lt_add_iff_pos_right]\n  obtain ‚ü®hz‚ÇÅ, hz‚ÇÇ‚ü© := hz\n  simp only [hz‚ÇÅ, mul_pos_iff_of_pos_left, sub_pos, hul, true_and]\n  rw [add_comm, ‚Üê sub_lt_sub_iff_right l, add_sub_assoc, sub_self, add_zero]\n  nth_rewrite 2 [‚Üê one_mul (u - l)]\n  gcongr\n  simp only [sub_pos]\n  exact hul\n\n"}
{"name":"Complex.HadamardThreeLines.mem_verticalClosedStrip_of_scale_id_mem_verticalClosedStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"z : Complex\nl u : Real\nhul : LT.lt l u\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip l u) z\n‚ä¢ Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip 0 1) (HSub.hSub (HDiv.hDiv z (HSub.hSub ‚Üëu ‚Üël)) (HDiv.hDiv (‚Üël) (HSub.hSub ‚Üëu ‚Üël)))","decl":"/-- If z is on the closed strip `re ‚Åª¬π' [l, u]`, then `(z - l) / (u - l)` is on the closed strip\n  `re ‚Åª¬π' [0, 1]`. -/\nlemma mem_verticalClosedStrip_of_scale_id_mem_verticalClosedStrip {z : ‚ÑÇ} {l u : ‚Ñù} (hul : l < u)\n    (hz : z ‚àà verticalClosedStrip l u) : z / (u - l) - l / (u - l) ‚àà verticalClosedStrip 0 1 := by\n  simp only [verticalClosedStrip, Complex.div_re, mem_preimage, sub_re, mem_Icc,\n    sub_nonneg, tsub_le_iff_right, ofReal_re, ofReal_im, sub_im, sub_self, mul_zero, zero_div,\n    add_zero]\n  simp only [verticalClosedStrip] at hz\n  norm_cast\n  simp_rw [Complex.normSq_ofReal, mul_div_assoc, div_mul_eq_div_div_swap,\n    div_self (by linarith : u - l ‚â† 0), ‚Üê div_eq_mul_one_div]\n  constructor\n  ¬∑ gcongr\n    ¬∑ apply le_of_lt; simp [hul]\n    ¬∑ exact hz.1\n  ¬∑ rw [‚Üê sub_le_sub_iff_right (l / (u - l)), add_sub_assoc, sub_self, add_zero, div_sub_div_same,\n      div_le_one (by simp[hul]), sub_le_sub_iff_right l]\n    exact hz.2\n\n"}
{"name":"Complex.HadamardThreeLines.scale_diffContOnCl","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nl u : Real\nhul : LT.lt l u\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip l u)\n‚ä¢ DiffContOnCl Complex (Complex.HadamardThreeLines.scale f l u) (Complex.HadamardThreeLines.verticalStrip 0 1)","decl":"/-- The function `scale f l u` is `diffContOnCl`. -/\nlemma scale_diffContOnCl {f : ‚ÑÇ ‚Üí E} {l u : ‚Ñù} (hul : l < u)\n    (hd : DiffContOnCl ‚ÑÇ f (verticalStrip l u)) :\n    DiffContOnCl ‚ÑÇ (scale f l u) (verticalStrip 0 1) := by\n  unfold scale\n  apply DiffContOnCl.comp (s := verticalStrip l u) hd\n  ¬∑ apply DiffContOnCl.const_add\n    apply DiffContOnCl.smul_const\n    exact Differentiable.diffContOnCl differentiable_id'\n  ¬∑ rw [MapsTo]\n    intro z hz\n    exact scale_id_mem_verticalStrip_of_mem_verticalStrip hul hz\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interpStrip_of_mem_verticalClosedStrip","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nl u : Real\nhul : LT.lt l u\nf : Complex ‚Üí E\nz : Complex\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip l u) z\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip l u)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip l u))\n‚ä¢ LE.le (Norm.norm (f z)) (Norm.norm (Complex.HadamardThreeLines.interpStrip' f l u z))","decl":"/--\n**Hadamard three-line theorem**: If `f` is a bounded function, continuous on the\nclosed strip `re ‚Åª¬π' [l, u]` and differentiable on open strip `re ‚Åª¬π' (l, u)`, then for\n`M(x) := sup ((norm ‚àò f) '' (re ‚Åª¬π' {x}))` we have that for all `z` in the closed strip\n`re ‚Åª¬π' [a,b]` the inequality\n`‚Äñf(z)‚Äñ ‚â§ M(0) ^ (1 - ((z.re - l) / (u - l))) * M(1) ^ ((z.re - l) / (u - l))`\nholds. -/\nlemma norm_le_interpStrip_of_mem_verticalClosedStrip {l u : ‚Ñù} (hul: l < u)\n    {f : ‚ÑÇ ‚Üí E} {z : ‚ÑÇ}\n    (hz : z ‚àà verticalClosedStrip l u) (hd : DiffContOnCl ‚ÑÇ f (verticalStrip l u))\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip l u)) :\n    ‚Äñf z‚Äñ ‚â§ ‚ÄñinterpStrip' f l u z‚Äñ := by\n  have hgoal := norm_le_interpStrip_of_mem_verticalClosedStrip‚ÇÄ‚ÇÅ (scale f l u)\n    (mem_verticalClosedStrip_of_scale_id_mem_verticalClosedStrip hul hz)\n    (scale_diffContOnCl hul hd) (scale_bddAbove hul hB)\n  simp only [scale, smul_eq_mul, norm_eq_abs] at hgoal\n  rw [fun_arg_eq hul, div_sub_div_same, interpStrip_scale f hul z] at hgoal\n  exact hgoal\n\n"}
{"name":"Complex.HadamardThreeLines.norm_le_interp_of_mem_verticalClosedStrip'","module":"Mathlib.Analysis.Complex.Hadamard","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Complex ‚Üí E\nz : Complex\na b l u : Real\nhul : LT.lt l u\nhz : Membership.mem (Complex.HadamardThreeLines.verticalClosedStrip l u) z\nhd : DiffContOnCl Complex f (Complex.HadamardThreeLines.verticalStrip l u)\nhB : BddAbove (Set.image (Function.comp Norm.norm f) (Complex.HadamardThreeLines.verticalClosedStrip l u))\nha : ‚àÄ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton l)) z ‚Üí LE.le (Norm.norm (f z)) a\nhb : ‚àÄ (z : Complex), Membership.mem (Set.preimage Complex.re (Singleton.singleton u)) z ‚Üí LE.le (Norm.norm (f z)) b\n‚ä¢ LE.le (Norm.norm (f z)) (HMul.hMul (HPow.hPow a (HSub.hSub 1 (HDiv.hDiv (HSub.hSub z.re l) (HSub.hSub u l)))) (HPow.hPow b (HDiv.hDiv (HSub.hSub z.re l) (HSub.hSub u l))))","decl":"/-- **Hadamard three-line theorem** (Variant in simpler terms): Let `f` be a\nbounded function, continuous on the closed strip `re ‚Åª¬π' [l, u]` and differentiable on open strip\n`re ‚Åª¬π' (l, u)`. If, for all `z.re = l`, `‚Äñf z‚Äñ ‚â§ a` for some `a ‚àà ‚Ñù` and, similarly, for all\n`z.re = u`, `‚Äñf z‚Äñ ‚â§ b` for some `b ‚àà ‚Ñù` then for all `z` in the closed strip\n`re ‚Åª¬π' [l, u]` the inequality\n`‚Äñf(z)‚Äñ ‚â§ a ^ (1 - (z.re - l) / (u - l)) * b ^ ((z.re - l) / (u - l))`\nholds. -/\nlemma norm_le_interp_of_mem_verticalClosedStrip' {f : ‚ÑÇ ‚Üí E} {z : ‚ÑÇ} {a b l u : ‚Ñù}\n    (hul : l < u) (hz : z ‚àà verticalClosedStrip l u) (hd : DiffContOnCl ‚ÑÇ f (verticalStrip l u))\n    (hB : BddAbove ((norm ‚àò f) '' verticalClosedStrip l u))\n    (ha : ‚àÄ z ‚àà re ‚Åª¬π' {l}, ‚Äñf z‚Äñ ‚â§ a) (hb : ‚àÄ z ‚àà re ‚Åª¬π' {u}, ‚Äñf z‚Äñ ‚â§ b) :\n    ‚Äñf z‚Äñ ‚â§ a ^ (1 - (z.re - l) / (u - l)) * b ^ ((z.re - l) / (u - l)) := by\n  have hgoal := norm_le_interp_of_mem_verticalClosedStrip‚ÇÄ‚ÇÅ' (scale f l u)\n    (mem_verticalClosedStrip_of_scale_id_mem_verticalClosedStrip hul hz) (scale_diffContOnCl hul hd)\n    (scale_bddAbove hul hB) (scale_bound_left ha) (scale_bound_right hb)\n  simp only [scale, smul_eq_mul, sub_re] at hgoal\n  rw [fun_arg_eq hul, bound_exp_eq hul] at hgoal\n  exact hgoal\n\n"}
