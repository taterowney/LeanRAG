{"name":"MeasureTheory.SimpleFunc.nnnorm_approxOn_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : OpensMeasurableSpace E\nf : Œ≤ ‚Üí E\nhf : Measurable f\ns : Set E\ny‚ÇÄ : E\nh‚ÇÄ : Membership.mem s y‚ÇÄ\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nx : Œ≤\nn : Nat\n‚ä¢ LE.le (NNNorm.nnnorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f hf s y‚ÇÄ h‚ÇÄ n) x) (f x))) (NNNorm.nnnorm (HSub.hSub (f x) y‚ÇÄ))","decl":"theorem nnnorm_approxOn_le [OpensMeasurableSpace E] {f : Œ≤ ‚Üí E} (hf : Measurable f) {s : Set E}\n    {y‚ÇÄ : E} (h‚ÇÄ : y‚ÇÄ ‚àà s) [SeparableSpace s] (x : Œ≤) (n : ‚Ñï) :\n    ‚ÄñapproxOn f hf s y‚ÇÄ h‚ÇÄ n x - f x‚Äñ‚Çä ‚â§ ‚Äñf x - y‚ÇÄ‚Äñ‚Çä := by\n  have := edist_approxOn_le hf h‚ÇÄ x n\n  rw [edist_comm y‚ÇÄ] at this\n  simp only [edist_nndist, nndist_eq_nnnorm] at this\n  exact mod_cast this\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_approxOn_y‚ÇÄ_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : OpensMeasurableSpace E\nf : Œ≤ ‚Üí E\nhf : Measurable f\ns : Set E\ny‚ÇÄ : E\nh‚ÇÄ : Membership.mem s y‚ÇÄ\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nx : Œ≤\nn : Nat\n‚ä¢ LE.le (Norm.norm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f hf s y‚ÇÄ h‚ÇÄ n) x) y‚ÇÄ)) (HAdd.hAdd (Norm.norm (HSub.hSub (f x) y‚ÇÄ)) (Norm.norm (HSub.hSub (f x) y‚ÇÄ)))","decl":"theorem norm_approxOn_y‚ÇÄ_le [OpensMeasurableSpace E] {f : Œ≤ ‚Üí E} (hf : Measurable f) {s : Set E}\n    {y‚ÇÄ : E} (h‚ÇÄ : y‚ÇÄ ‚àà s) [SeparableSpace s] (x : Œ≤) (n : ‚Ñï) :\n    ‚ÄñapproxOn f hf s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ‚Äñ ‚â§ ‚Äñf x - y‚ÇÄ‚Äñ + ‚Äñf x - y‚ÇÄ‚Äñ := by\n  simpa [enorm, edist_eq_enorm_sub, ‚Üê ENNReal.coe_add, norm_sub_rev]\n    using edist_approxOn_y0_le hf h‚ÇÄ x n\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_approxOn_zero_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : OpensMeasurableSpace E\nf : Œ≤ ‚Üí E\nhf : Measurable f\ns : Set E\nh‚ÇÄ : Membership.mem s 0\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nx : Œ≤\nn : Nat\n‚ä¢ LE.le (Norm.norm ((MeasureTheory.SimpleFunc.approxOn f hf s 0 h‚ÇÄ n) x)) (HAdd.hAdd (Norm.norm (f x)) (Norm.norm (f x)))","decl":"theorem norm_approxOn_zero_le [OpensMeasurableSpace E] {f : Œ≤ ‚Üí E} (hf : Measurable f) {s : Set E}\n    (h‚ÇÄ : (0 : E) ‚àà s) [SeparableSpace s] (x : Œ≤) (n : ‚Ñï) :\n    ‚ÄñapproxOn f hf s 0 h‚ÇÄ n x‚Äñ ‚â§ ‚Äñf x‚Äñ + ‚Äñf x‚Äñ := by\n  simpa [enorm, edist_eq_enorm_sub, ‚Üê ENNReal.coe_add, norm_sub_rev]\n    using edist_approxOn_y0_le hf h‚ÇÄ x n\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_Lp_eLpNorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\np : ENNReal\ninst‚úù¬π : OpensMeasurableSpace E\nf : Œ≤ ‚Üí E\nhf : Measurable f\ns : Set E\ny‚ÇÄ : E\nh‚ÇÄ : Membership.mem s y‚ÇÄ\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nhp_ne_top : Ne p Top.top\nŒº : MeasureTheory.Measure Œ≤\nhŒº : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae Œº)\nhi : LT.lt (MeasureTheory.eLpNorm (fun x => HSub.hSub (f x) y‚ÇÄ) p Œº) Top.top\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (‚áë(MeasureTheory.SimpleFunc.approxOn f hf s y‚ÇÄ h‚ÇÄ n)) f) p Œº) Filter.atTop (nhds 0)","decl":"theorem tendsto_approxOn_Lp_eLpNorm [OpensMeasurableSpace E] {f : Œ≤ ‚Üí E} (hf : Measurable f)\n    {s : Set E} {y‚ÇÄ : E} (h‚ÇÄ : y‚ÇÄ ‚àà s) [SeparableSpace s] (hp_ne_top : p ‚â† ‚àû) {Œº : Measure Œ≤}\n    (hŒº : ‚àÄ·µê x ‚àÇŒº, f x ‚àà closure s) (hi : eLpNorm (fun x => f x - y‚ÇÄ) p Œº < ‚àû) :\n    Tendsto (fun n => eLpNorm (‚áë(approxOn f hf s y‚ÇÄ h‚ÇÄ n) - f) p Œº) atTop (ùìù 0) := by\n  by_cases hp_zero : p = 0\n  ¬∑ simpa only [hp_zero, eLpNorm_exponent_zero] using tendsto_const_nhds\n  have hp : 0 < p.toReal := toReal_pos hp_zero hp_ne_top\n  suffices Tendsto (fun n => ‚à´‚Åª x, ‚ÄñapproxOn f hf s y‚ÇÄ h‚ÇÄ n x - f x‚Äñ‚Çë ^ p.toReal ‚àÇŒº) atTop (ùìù 0) by\n    simp only [eLpNorm_eq_lintegral_rpow_enorm hp_zero hp_ne_top]\n    convert continuous_rpow_const.continuousAt.tendsto.comp this\n    simp [zero_rpow_of_pos (_root_.inv_pos.mpr hp)]\n  -- We simply check the conditions of the Dominated Convergence Theorem:\n  -- (1) The function \"`p`-th power of distance between `f` and the approximation\" is measurable\n  have hF_meas n : Measurable fun x => ‚ÄñapproxOn f hf s y‚ÇÄ h‚ÇÄ n x - f x‚Äñ‚Çë ^ p.toReal := by\n    simpa only [‚Üê edist_eq_enorm_sub] using\n      (approxOn f hf s y‚ÇÄ h‚ÇÄ n).measurable_bind (fun y x => edist y (f x) ^ p.toReal) fun y =>\n        (measurable_edist_right.comp hf).pow_const p.toReal\n  -- (2) The functions \"`p`-th power of distance between `f` and the approximation\" are uniformly\n  -- bounded, at any given point, by `fun x => ‚Äñf x - y‚ÇÄ‚Äñ ^ p.toReal`\n  have h_bound n :\n    (fun x ‚Ü¶ ‚ÄñapproxOn f hf s y‚ÇÄ h‚ÇÄ n x - f x‚Äñ‚Çë ^ p.toReal) ‚â§·µê[Œº] (‚Äñf ¬∑ - y‚ÇÄ‚Äñ‚Çë ^ p.toReal) :=\n    .of_forall fun x => rpow_le_rpow (coe_mono (nnnorm_approxOn_le hf h‚ÇÄ x n)) toReal_nonneg\n  -- (3) The bounding function `fun x => ‚Äñf x - y‚ÇÄ‚Äñ ^ p.toReal` has finite integral\n  have h_fin : (‚à´‚Åª a : Œ≤, ‚Äñf a - y‚ÇÄ‚Äñ‚Çë ^ p.toReal ‚àÇŒº) ‚â† ‚ä§ :=\n    (lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top hp_zero hp_ne_top hi).ne\n  -- (4) The functions \"`p`-th power of distance between `f` and the approximation\" tend pointwise\n  -- to zero\n  have h_lim :\n    ‚àÄ·µê a : Œ≤ ‚àÇŒº, Tendsto (‚ÄñapproxOn f hf s y‚ÇÄ h‚ÇÄ ¬∑ a - f a‚Äñ‚Çë ^ p.toReal) atTop (ùìù 0) := by\n    filter_upwards [hŒº] with a ha\n    have : Tendsto (fun n => (approxOn f hf s y‚ÇÄ h‚ÇÄ n) a - f a) atTop (ùìù (f a - f a)) :=\n      (tendsto_approxOn hf h‚ÇÄ ha).sub tendsto_const_nhds\n    convert continuous_rpow_const.continuousAt.tendsto.comp (tendsto_coe.mpr this.nnnorm)\n    simp [zero_rpow_of_pos hp]\n  -- Then we apply the Dominated Convergence Theorem\n  simpa using tendsto_lintegral_of_dominated_convergence _ hF_meas h_bound h_fin h_lim\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem‚Ñíp_approxOn","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\np : ENNReal\ninst‚úù¬π : BorelSpace E\nf : Œ≤ ‚Üí E\nŒº : MeasureTheory.Measure Œ≤\nfmeas : Measurable f\nhf : MeasureTheory.Mem‚Ñíp f p Œº\ns : Set E\ny‚ÇÄ : E\nh‚ÇÄ : Membership.mem s y‚ÇÄ\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nhi‚ÇÄ : MeasureTheory.Mem‚Ñíp (fun x => y‚ÇÄ) p Œº\nn : Nat\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚áë(MeasureTheory.SimpleFunc.approxOn f fmeas s y‚ÇÄ h‚ÇÄ n)) p Œº","decl":"theorem mem‚Ñíp_approxOn [BorelSpace E] {f : Œ≤ ‚Üí E} {Œº : Measure Œ≤} (fmeas : Measurable f)\n    (hf : Mem‚Ñíp f p Œº) {s : Set E} {y‚ÇÄ : E} (h‚ÇÄ : y‚ÇÄ ‚àà s) [SeparableSpace s]\n    (hi‚ÇÄ : Mem‚Ñíp (fun _ => y‚ÇÄ) p Œº) (n : ‚Ñï) : Mem‚Ñíp (approxOn f fmeas s y‚ÇÄ h‚ÇÄ n) p Œº := by\n  refine ‚ü®(approxOn f fmeas s y‚ÇÄ h‚ÇÄ n).aestronglyMeasurable, ?_‚ü©\n  suffices eLpNorm (fun x => approxOn f fmeas s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ) p Œº < ‚ä§ by\n    have : Mem‚Ñíp (fun x => approxOn f fmeas s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ) p Œº :=\n      ‚ü®(approxOn f fmeas s y‚ÇÄ h‚ÇÄ n - const Œ≤ y‚ÇÄ).aestronglyMeasurable, this‚ü©\n    convert eLpNorm_add_lt_top this hi‚ÇÄ\n    ext x\n    simp\n  have hf' : Mem‚Ñíp (fun x => ‚Äñf x - y‚ÇÄ‚Äñ) p Œº := by\n    have h_meas : Measurable fun x => ‚Äñf x - y‚ÇÄ‚Äñ := by\n      simp only [‚Üê dist_eq_norm]\n      exact (continuous_id.dist continuous_const).measurable.comp fmeas\n    refine ‚ü®h_meas.aemeasurable.aestronglyMeasurable, ?_‚ü©\n    rw [eLpNorm_norm]\n    convert eLpNorm_add_lt_top hf hi‚ÇÄ.neg with x\n    simp [sub_eq_add_neg]\n  have : ‚àÄ·µê x ‚àÇŒº, ‚ÄñapproxOn f fmeas s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ‚Äñ ‚â§ ‚Äñ‚Äñf x - y‚ÇÄ‚Äñ + ‚Äñf x - y‚ÇÄ‚Äñ‚Äñ := by\n    filter_upwards with x\n    convert norm_approxOn_y‚ÇÄ_le fmeas h‚ÇÄ x n using 1\n    rw [Real.norm_eq_abs, abs_of_nonneg]\n    positivity\n  calc\n    eLpNorm (fun x => approxOn f fmeas s y‚ÇÄ h‚ÇÄ n x - y‚ÇÄ) p Œº ‚â§\n        eLpNorm (fun x => ‚Äñf x - y‚ÇÄ‚Äñ + ‚Äñf x - y‚ÇÄ‚Äñ) p Œº :=\n      eLpNorm_mono_ae this\n    _ < ‚ä§ := eLpNorm_add_lt_top hf' hf'\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_range_Lp_eLpNorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\np : ENNReal\ninst‚úù¬π : BorelSpace E\nf : Œ≤ ‚Üí E\nhp_ne_top : Ne p Top.top\nŒº : MeasureTheory.Measure Œ≤\nfmeas : Measurable f\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üë(Union.union (Set.range f) (Singleton.singleton 0))\nhf : LT.lt (MeasureTheory.eLpNorm f p Œº) Top.top\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (‚áë(MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ‚ãØ n)) f) p Œº) Filter.atTop (nhds 0)","decl":"theorem tendsto_approxOn_range_Lp_eLpNorm [BorelSpace E] {f : Œ≤ ‚Üí E} (hp_ne_top : p ‚â† ‚àû)\n    {Œº : Measure Œ≤} (fmeas : Measurable f) [SeparableSpace (range f ‚à™ {0} : Set E)]\n    (hf : eLpNorm f p Œº < ‚àû) :\n    Tendsto (fun n => eLpNorm (‚áë(approxOn f fmeas (range f ‚à™ {0}) 0 (by simp) n) - f) p Œº)\n      atTop (ùìù 0) := by\n  refine tendsto_approxOn_Lp_eLpNorm fmeas _ hp_ne_top ?_ ?_\n  ¬∑ filter_upwards with x using subset_closure (by simp)\n  ¬∑ simpa using hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem‚Ñíp_approxOn_range","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\np : ENNReal\ninst‚úù¬π : BorelSpace E\nf : Œ≤ ‚Üí E\nŒº : MeasureTheory.Measure Œ≤\nfmeas : Measurable f\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üë(Union.union (Set.range f) (Singleton.singleton 0))\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nn : Nat\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚áë(MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ‚ãØ n)) p Œº","decl":"theorem mem‚Ñíp_approxOn_range [BorelSpace E] {f : Œ≤ ‚Üí E} {Œº : Measure Œ≤} (fmeas : Measurable f)\n    [SeparableSpace (range f ‚à™ {0} : Set E)] (hf : Mem‚Ñíp f p Œº) (n : ‚Ñï) :\n    Mem‚Ñíp (approxOn f fmeas (range f ‚à™ {0}) 0 (by simp) n) p Œº :=\n  mem‚Ñíp_approxOn fmeas hf (y‚ÇÄ := 0) (by simp) Mem‚Ñíp.zero n\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_range_Lp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\np : ENNReal\ninst‚úù¬π : BorelSpace E\nf : Œ≤ ‚Üí E\nhp : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\nŒº : MeasureTheory.Measure Œ≤\nfmeas : Measurable f\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üë(Union.union (Set.range f) (Singleton.singleton 0))\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.Mem‚Ñíp.toLp ‚áë(MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ‚ãØ n) ‚ãØ) Filter.atTop (nhds (MeasureTheory.Mem‚Ñíp.toLp f hf))","decl":"theorem tendsto_approxOn_range_Lp [BorelSpace E] {f : Œ≤ ‚Üí E} [hp : Fact (1 ‚â§ p)] (hp_ne_top : p ‚â† ‚àû)\n    {Œº : Measure Œ≤} (fmeas : Measurable f) [SeparableSpace (range f ‚à™ {0} : Set E)]\n    (hf : Mem‚Ñíp f p Œº) :\n    Tendsto\n      (fun n =>\n        (mem‚Ñíp_approxOn_range fmeas hf n).toLp (approxOn f fmeas (range f ‚à™ {0}) 0 (by simp) n))\n      atTop (ùìù (hf.toLp f)) := by\n  simpa only [Lp.tendsto_Lp_iff_tendsto_‚Ñíp''] using\n    tendsto_approxOn_range_Lp_eLpNorm hp_ne_top fmeas hf.2\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.exists_simpleFunc_eLpNorm_sub_lt","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\ninst‚úù¬π : MeasurableSpace Œ≤\np : ENNReal\nE : Type u_7\ninst‚úù : NormedAddCommGroup E\nf : Œ≤ ‚Üí E\nŒº : MeasureTheory.Measure Œ≤\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhp_ne_top : Ne p Top.top\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ Exists fun g => And (LT.lt (MeasureTheory.eLpNorm (HSub.hSub f ‚áëg) p Œº) Œµ) (MeasureTheory.Mem‚Ñíp (‚áëg) p Œº)","decl":"/-- Any function in `‚Ñíp` can be approximated by a simple function if `p < ‚àû`. -/\ntheorem _root_.MeasureTheory.Mem‚Ñíp.exists_simpleFunc_eLpNorm_sub_lt {E : Type*}\n    [NormedAddCommGroup E] {f : Œ≤ ‚Üí E} {Œº : Measure Œ≤} (hf : Mem‚Ñíp f p Œº) (hp_ne_top : p ‚â† ‚àû)\n    {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) : ‚àÉ g : Œ≤ ‚Üí‚Çõ E, eLpNorm (f - ‚áëg) p Œº < Œµ ‚àß Mem‚Ñíp g p Œº := by\n  borelize E\n  let f' := hf.1.mk f\n  rsuffices ‚ü®g, hg, g_mem‚ü© : ‚àÉ g : Œ≤ ‚Üí‚Çõ E, eLpNorm (f' - ‚áëg) p Œº < Œµ ‚àß Mem‚Ñíp g p Œº\n  ¬∑ refine ‚ü®g, ?_, g_mem‚ü©\n    suffices eLpNorm (f - ‚áëg) p Œº = eLpNorm (f' - ‚áëg) p Œº by rwa [this]\n    apply eLpNorm_congr_ae\n    filter_upwards [hf.1.ae_eq_mk] with x hx\n    simpa only [Pi.sub_apply, sub_left_inj] using hx\n  have hf' : Mem‚Ñíp f' p Œº := hf.ae_eq hf.1.ae_eq_mk\n  have f'meas : Measurable f' := hf.1.measurable_mk\n  have : SeparableSpace (range f' ‚à™ {0} : Set E) :=\n    StronglyMeasurable.separableSpace_range_union_singleton hf.1.stronglyMeasurable_mk\n  rcases ((tendsto_approxOn_range_Lp_eLpNorm hp_ne_top f'meas hf'.2).eventually <|\n    gt_mem_nhds hŒµ.bot_lt).exists with ‚ü®n, hn‚ü©\n  rw [‚Üê eLpNorm_neg, neg_sub] at hn\n  exact ‚ü®_, hn, mem‚Ñíp_approxOn_range f'meas hf' _‚ü©\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_L1_enorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : OpensMeasurableSpace E\nf : Œ≤ ‚Üí E\nhf : Measurable f\ns : Set E\ny‚ÇÄ : E\nh‚ÇÄ : Membership.mem s y‚ÇÄ\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nŒº : MeasureTheory.Measure Œ≤\nhŒº : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae Œº)\nhi : MeasureTheory.HasFiniteIntegral (fun x => HSub.hSub (f x) y‚ÇÄ) Œº\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Œº fun x => ENorm.enorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f hf s y‚ÇÄ h‚ÇÄ n) x) (f x))) Filter.atTop (nhds 0)","decl":"theorem tendsto_approxOn_L1_enorm [OpensMeasurableSpace E] {f : Œ≤ ‚Üí E} (hf : Measurable f)\n    {s : Set E} {y‚ÇÄ : E} (h‚ÇÄ : y‚ÇÄ ‚àà s) [SeparableSpace s] {Œº : Measure Œ≤}\n    (hŒº : ‚àÄ·µê x ‚àÇŒº, f x ‚àà closure s) (hi : HasFiniteIntegral (fun x => f x - y‚ÇÄ) Œº) :\n    Tendsto (fun n => ‚à´‚Åª x, ‚ÄñapproxOn f hf s y‚ÇÄ h‚ÇÄ n x - f x‚Äñ‚Çë ‚àÇŒº) atTop (ùìù 0) := by\n  simpa [eLpNorm_one_eq_lintegral_enorm] using\n    tendsto_approxOn_Lp_eLpNorm hf h‚ÇÄ one_ne_top hŒº\n      (by simpa [eLpNorm_one_eq_lintegral_enorm] using hi)\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_L1_nnnorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : OpensMeasurableSpace E\nf : Œ≤ ‚Üí E\nhf : Measurable f\ns : Set E\ny‚ÇÄ : E\nh‚ÇÄ : Membership.mem s y‚ÇÄ\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nŒº : MeasureTheory.Measure Œ≤\nhŒº : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae Œº)\nhi : MeasureTheory.HasFiniteIntegral (fun x => HSub.hSub (f x) y‚ÇÄ) Œº\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Œº fun x => ENorm.enorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f hf s y‚ÇÄ h‚ÇÄ n) x) (f x))) Filter.atTop (nhds 0)","decl":"@[deprecated (since := \"2025-01-21\")] alias tendsto_approxOn_L1_nnnorm := tendsto_approxOn_L1_enorm\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_approxOn","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : BorelSpace E\nf : Œ≤ ‚Üí E\nŒº : MeasureTheory.Measure Œ≤\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f Œº\ns : Set E\ny‚ÇÄ : E\nh‚ÇÄ : Membership.mem s y‚ÇÄ\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nhi‚ÇÄ : MeasureTheory.Integrable (fun x => y‚ÇÄ) Œº\nn : Nat\n‚ä¢ MeasureTheory.Integrable (‚áë(MeasureTheory.SimpleFunc.approxOn f fmeas s y‚ÇÄ h‚ÇÄ n)) Œº","decl":"theorem integrable_approxOn [BorelSpace E] {f : Œ≤ ‚Üí E} {Œº : Measure Œ≤} (fmeas : Measurable f)\n    (hf : Integrable f Œº) {s : Set E} {y‚ÇÄ : E} (h‚ÇÄ : y‚ÇÄ ‚àà s) [SeparableSpace s]\n    (hi‚ÇÄ : Integrable (fun _ => y‚ÇÄ) Œº) (n : ‚Ñï) : Integrable (approxOn f fmeas s y‚ÇÄ h‚ÇÄ n) Œº := by\n  rw [‚Üê mem‚Ñíp_one_iff_integrable] at hf hi‚ÇÄ ‚ä¢\n  exact mem‚Ñíp_approxOn fmeas hf h‚ÇÄ hi‚ÇÄ n\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_range_L1_enorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : OpensMeasurableSpace E\nf : Œ≤ ‚Üí E\nŒº : MeasureTheory.Measure Œ≤\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üë(Union.union (Set.range f) (Singleton.singleton 0))\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Œº fun x => ENorm.enorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ‚ãØ n) x) (f x))) Filter.atTop (nhds 0)","decl":"theorem tendsto_approxOn_range_L1_enorm [OpensMeasurableSpace E] {f : Œ≤ ‚Üí E} {Œº : Measure Œ≤}\n    [SeparableSpace (range f ‚à™ {0} : Set E)] (fmeas : Measurable f) (hf : Integrable f Œº) :\n    Tendsto (fun n => ‚à´‚Åª x, ‚ÄñapproxOn f fmeas (range f ‚à™ {0}) 0 (by simp) n x - f x‚Äñ‚Çë ‚àÇŒº) atTop\n      (ùìù 0) := by\n  apply tendsto_approxOn_L1_enorm fmeas\n  ¬∑ filter_upwards with x using subset_closure (by simp)\n  ¬∑ simpa using hf.2\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_range_L1_nnnorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : OpensMeasurableSpace E\nf : Œ≤ ‚Üí E\nŒº : MeasureTheory.Measure Œ≤\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üë(Union.union (Set.range f) (Singleton.singleton 0))\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.lintegral Œº fun x => ENorm.enorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ‚ãØ n) x) (f x))) Filter.atTop (nhds 0)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias tendsto_approxOn_range_L1_nnnorm := tendsto_approxOn_range_L1_enorm\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_approxOn_range","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ≤ : Type u_2\nE : Type u_4\ninst‚úù‚Å¥ : MeasurableSpace Œ≤\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : BorelSpace E\nf : Œ≤ ‚Üí E\nŒº : MeasureTheory.Measure Œ≤\nfmeas : Measurable f\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üë(Union.union (Set.range f) (Singleton.singleton 0))\nhf : MeasureTheory.Integrable f Œº\nn : Nat\n‚ä¢ MeasureTheory.Integrable (‚áë(MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ‚ãØ n)) Œº","decl":"theorem integrable_approxOn_range [BorelSpace E] {f : Œ≤ ‚Üí E} {Œº : Measure Œ≤} (fmeas : Measurable f)\n    [SeparableSpace (range f ‚à™ {0} : Set E)] (hf : Integrable f Œº) (n : ‚Ñï) :\n    Integrable (approxOn f fmeas (range f ‚à™ {0}) 0 (by simp) n) Œº :=\n  integrable_approxOn fmeas hf _ (integrable_zero _ _ _) n\n\n"}
{"name":"MeasureTheory.SimpleFunc.exists_forall_norm_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nF : Type u_5\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup F\nf : MeasureTheory.SimpleFunc Œ± F\n‚ä¢ Exists fun C => ‚àÄ (x : Œ±), LE.le (Norm.norm (f x)) C","decl":"theorem exists_forall_norm_le (f : Œ± ‚Üí‚Çõ F) : ‚àÉ C, ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C :=\n  exists_forall_le (f.map fun x => ‚Äñx‚Äñ)\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem‚Ñíp_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nf : MeasureTheory.SimpleFunc Œ± E\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚áëf) 0 Œº","decl":"theorem mem‚Ñíp_zero (f : Œ± ‚Üí‚Çõ E) (Œº : Measure Œ±) : Mem‚Ñíp f 0 Œº :=\n  mem‚Ñíp_zero_iff_aestronglyMeasurable.mpr f.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem‚Ñíp_top","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nf : MeasureTheory.SimpleFunc Œ± E\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚áëf) Top.top Œº","decl":"theorem mem‚Ñíp_top (f : Œ± ‚Üí‚Çõ E) (Œº : Measure Œ±) : Mem‚Ñíp f ‚àû Œº :=\n  let ‚ü®C, hfC‚ü© := f.exists_forall_norm_le\n  mem‚Ñíp_top_of_bound f.aestronglyMeasurable C <| Eventually.of_forall hfC\n\n"}
{"name":"MeasureTheory.SimpleFunc.eLpNorm'_eq","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nF : Type u_5\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup F\np : Real\nf : MeasureTheory.SimpleFunc Œ± F\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Eq (MeasureTheory.eLpNorm' (‚áëf) p Œº) (HPow.hPow (f.range.sum fun y => HMul.hMul (HPow.hPow (ENorm.enorm y) p) (Œº (Set.preimage (‚áëf) (Singleton.singleton y)))) (HDiv.hDiv 1 p))","decl":"protected theorem eLpNorm'_eq {p : ‚Ñù} (f : Œ± ‚Üí‚Çõ F) (Œº : Measure Œ±) :\n    eLpNorm' f p Œº = (‚àë y ‚àà f.range, ‚Äñy‚Äñ‚Çë ^ p * Œº (f ‚Åª¬π' {y})) ^ (1 / p) := by\n  have h_map : (‚Äñf ¬∑‚Äñ‚Çë ^ p) = f.map (‚Äñ¬∑‚Äñ‚Çë ^ p) := by simp; rfl\n  rw [eLpNorm'_eq_lintegral_enorm, h_map, lintegral_eq_lintegral, map_lintegral]\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_preimage_lt_top_of_mem‚Ñíp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\ny : E\nhy_ne : Ne y 0\n‚ä¢ LT.lt (Œº (Set.preimage (‚áëf) (Singleton.singleton y))) Top.top","decl":"theorem measure_preimage_lt_top_of_mem‚Ñíp (hp_pos : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) (f : Œ± ‚Üí‚Çõ E)\n    (hf : Mem‚Ñíp f p Œº) (y : E) (hy_ne : y ‚â† 0) : Œº (f ‚Åª¬π' {y}) < ‚àû := by\n  have hp_pos_real : 0 < p.toReal := ENNReal.toReal_pos hp_pos hp_ne_top\n  have hf_eLpNorm := Mem‚Ñíp.eLpNorm_lt_top hf\n  rw [eLpNorm_eq_eLpNorm' hp_pos hp_ne_top, f.eLpNorm'_eq, one_div,\n    ‚Üê @ENNReal.lt_rpow_inv_iff _ _ p.toReal‚Åª¬π (by simp [hp_pos_real]),\n    @ENNReal.top_rpow_of_pos p.toReal‚Åª¬π‚Åª¬π (by simp [hp_pos_real]),\n    ENNReal.sum_lt_top] at hf_eLpNorm\n  by_cases hyf : y ‚àà f.range\n  swap\n  ¬∑ suffices h_empty : f ‚Åª¬π' {y} = ‚àÖ by\n      rw [h_empty, measure_empty]; exact ENNReal.coe_lt_top\n    ext1 x\n    rw [Set.mem_preimage, Set.mem_singleton_iff, mem_empty_iff_false, iff_false]\n    refine fun hxy => hyf ?_\n    rw [mem_range, Set.mem_range]\n    exact ‚ü®x, hxy‚ü©\n  specialize hf_eLpNorm y hyf\n  rw [ENNReal.mul_lt_top_iff] at hf_eLpNorm\n  cases hf_eLpNorm with\n  | inl hf_eLpNorm => exact hf_eLpNorm.2\n  | inr hf_eLpNorm =>\n    cases hf_eLpNorm with\n    | inl hf_eLpNorm =>\n      refine absurd ?_ hy_ne\n      simpa [hp_pos_real] using hf_eLpNorm\n    | inr hf_eLpNorm => simp [hf_eLpNorm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem‚Ñíp_of_finite_measure_preimage","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf : MeasureTheory.SimpleFunc Œ± E\nhf : ‚àÄ (y : E), Ne y 0 ‚Üí LT.lt (Œº (Set.preimage (‚áëf) (Singleton.singleton y))) Top.top\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚áëf) p Œº","decl":"theorem mem‚Ñíp_of_finite_measure_preimage (p : ‚Ñù‚â•0‚àû) {f : Œ± ‚Üí‚Çõ E}\n    (hf : ‚àÄ y, y ‚â† 0 ‚Üí Œº (f ‚Åª¬π' {y}) < ‚àû) : Mem‚Ñíp f p Œº := by\n  by_cases hp0 : p = 0\n  ¬∑ rw [hp0, mem‚Ñíp_zero_iff_aestronglyMeasurable]; exact f.aestronglyMeasurable\n  by_cases hp_top : p = ‚àû\n  ¬∑ rw [hp_top]; exact mem‚Ñíp_top f Œº\n  refine ‚ü®f.aestronglyMeasurable, ?_‚ü©\n  rw [eLpNorm_eq_eLpNorm' hp0 hp_top, f.eLpNorm'_eq]\n  refine ENNReal.rpow_lt_top_of_nonneg (by simp) (ENNReal.sum_lt_top.mpr fun y _ => ?_).ne\n  by_cases hy0 : y = 0\n  ¬∑ simp [hy0, ENNReal.toReal_pos hp0 hp_top]\n  ¬∑ refine ENNReal.mul_lt_top ?_ (hf y hy0)\n    exact ENNReal.rpow_lt_top_of_nonneg ENNReal.toReal_nonneg ENNReal.coe_ne_top\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem‚Ñíp_iff","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf : MeasureTheory.SimpleFunc Œ± E\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\n‚ä¢ Iff (MeasureTheory.Mem‚Ñíp (‚áëf) p Œº) (‚àÄ (y : E), Ne y 0 ‚Üí LT.lt (Œº (Set.preimage (‚áëf) (Singleton.singleton y))) Top.top)","decl":"theorem mem‚Ñíp_iff {f : Œ± ‚Üí‚Çõ E} (hp_pos : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) :\n    Mem‚Ñíp f p Œº ‚Üî ‚àÄ y, y ‚â† 0 ‚Üí Œº (f ‚Åª¬π' {y}) < ‚àû :=\n  ‚ü®fun h => measure_preimage_lt_top_of_mem‚Ñíp hp_pos hp_ne_top f h, fun h =>\n    mem‚Ñíp_of_finite_measure_preimage p h‚ü©\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_iff","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\n‚ä¢ Iff (MeasureTheory.Integrable (‚áëf) Œº) (‚àÄ (y : E), Ne y 0 ‚Üí LT.lt (Œº (Set.preimage (‚áëf) (Singleton.singleton y))) Top.top)","decl":"theorem integrable_iff {f : Œ± ‚Üí‚Çõ E} : Integrable f Œº ‚Üî ‚àÄ y, y ‚â† 0 ‚Üí Œº (f ‚Åª¬π' {y}) < ‚àû :=\n  mem‚Ñíp_one_iff_integrable.symm.trans <| mem‚Ñíp_iff one_ne_zero ENNReal.coe_ne_top\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem‚Ñíp_iff_integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf : MeasureTheory.SimpleFunc Œ± E\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\n‚ä¢ Iff (MeasureTheory.Mem‚Ñíp (‚áëf) p Œº) (MeasureTheory.Integrable (‚áëf) Œº)","decl":"theorem mem‚Ñíp_iff_integrable {f : Œ± ‚Üí‚Çõ E} (hp_pos : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) :\n    Mem‚Ñíp f p Œº ‚Üî Integrable f Œº :=\n  (mem‚Ñíp_iff hp_pos hp_ne_top).trans integrable_iff.symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem‚Ñíp_iff_finMeasSupp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf : MeasureTheory.SimpleFunc Œ± E\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\n‚ä¢ Iff (MeasureTheory.Mem‚Ñíp (‚áëf) p Œº) (f.FinMeasSupp Œº)","decl":"theorem mem‚Ñíp_iff_finMeasSupp {f : Œ± ‚Üí‚Çõ E} (hp_pos : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) :\n    Mem‚Ñíp f p Œº ‚Üî f.FinMeasSupp Œº :=\n  (mem‚Ñíp_iff hp_pos hp_ne_top).trans finMeasSupp_iff.symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_iff_finMeasSupp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\n‚ä¢ Iff (MeasureTheory.Integrable (‚áëf) Œº) (f.FinMeasSupp Œº)","decl":"theorem integrable_iff_finMeasSupp {f : Œ± ‚Üí‚Çõ E} : Integrable f Œº ‚Üî f.FinMeasSupp Œº :=\n  integrable_iff.trans finMeasSupp_iff.symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nh : f.FinMeasSupp Œº\n‚ä¢ MeasureTheory.Integrable (‚áëf) Œº","decl":"theorem FinMeasSupp.integrable {f : Œ± ‚Üí‚Çõ E} (h : f.FinMeasSupp Œº) : Integrable f Œº :=\n  integrable_iff_finMeasSupp.2 h\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_pair","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\nF : Type u_5\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedAddCommGroup F\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\ng : MeasureTheory.SimpleFunc Œ± F\na‚úù¬π : MeasureTheory.Integrable (‚áëf) Œº\na‚úù : MeasureTheory.Integrable (‚áëg) Œº\n‚ä¢ MeasureTheory.Integrable (‚áë(f.pair g)) Œº","decl":"theorem integrable_pair {f : Œ± ‚Üí‚Çõ E} {g : Œ± ‚Üí‚Çõ F} :\n    Integrable f Œº ‚Üí Integrable g Œº ‚Üí Integrable (pair f g) Œº := by\n  simpa only [integrable_iff_finMeasSupp] using FinMeasSupp.pair\n\n"}
{"name":"MeasureTheory.SimpleFunc.mem‚Ñíp_of_isFiniteMeasure","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\nf : MeasureTheory.SimpleFunc Œ± E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚áëf) p Œº","decl":"theorem mem‚Ñíp_of_isFiniteMeasure (f : Œ± ‚Üí‚Çõ E) (p : ‚Ñù‚â•0‚àû) (Œº : Measure Œ±) [IsFiniteMeasure Œº] :\n    Mem‚Ñíp f p Œº :=\n  let ‚ü®C, hfC‚ü© := f.exists_forall_norm_le\n  Mem‚Ñíp.of_bound f.aestronglyMeasurable C <| Eventually.of_forall hfC\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_of_isFiniteMeasure","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : MeasureTheory.SimpleFunc Œ± E\n‚ä¢ MeasureTheory.Integrable (‚áëf) Œº","decl":"@[fun_prop]\ntheorem integrable_of_isFiniteMeasure [IsFiniteMeasure Œº] (f : Œ± ‚Üí‚Çõ E) : Integrable f Œº :=\n  mem‚Ñíp_one_iff_integrable.mp (f.mem‚Ñíp_of_isFiniteMeasure 1 Œº)\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_preimage_lt_top_of_integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\nx : E\nhx : Ne x 0\n‚ä¢ LT.lt (Œº (Set.preimage (‚áëf) (Singleton.singleton x))) Top.top","decl":"theorem measure_preimage_lt_top_of_integrable (f : Œ± ‚Üí‚Çõ E) (hf : Integrable f Œº) {x : E}\n    (hx : x ‚â† 0) : Œº (f ‚Åª¬π' {x}) < ‚àû :=\n  integrable_iff.mp hf x hx\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_support_lt_top_of_mem‚Ñíp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n‚ä¢ LT.lt (Œº (Function.support ‚áëf)) Top.top","decl":"theorem measure_support_lt_top_of_mem‚Ñíp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) (hp_ne_zero : p ‚â† 0)\n    (hp_ne_top : p ‚â† ‚àû) : Œº (support f) < ‚àû :=\n  f.measure_support_lt_top ((mem‚Ñíp_iff hp_ne_zero hp_ne_top).mp hf)\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_support_lt_top_of_integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ LT.lt (Œº (Function.support ‚áëf)) Top.top","decl":"theorem measure_support_lt_top_of_integrable (f : Œ± ‚Üí‚Çõ E) (hf : Integrable f Œº) :\n    Œº (support f) < ‚àû :=\n  f.measure_support_lt_top (integrable_iff.mp hf)\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_lt_top_of_mem‚Ñíp_indicator","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\nc : E\nhc : Ne c 0\ns : Set Œ±\nhs : MeasurableSet s\nhcs : MeasureTheory.Mem‚Ñíp (‚áë(MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const Œ± c) (MeasureTheory.SimpleFunc.const Œ± 0))) p Œº\n‚ä¢ LT.lt (Œº s) Top.top","decl":"theorem measure_lt_top_of_mem‚Ñíp_indicator (hp_pos : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) {c : E} (hc : c ‚â† 0)\n    {s : Set Œ±} (hs : MeasurableSet s) (hcs : Mem‚Ñíp ((const Œ± c).piecewise s hs (const Œ± 0)) p Œº) :\n    Œº s < ‚ä§ := by\n  have : Function.support (const Œ± c) = Set.univ := Function.support_const hc\n  simpa only [mem‚Ñíp_iff_finMeasSupp hp_pos hp_ne_top, finMeasSupp_iff_support,\n    support_indicator, Set.inter_univ, this] using hcs\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.eq'","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\na‚úù : Eq ‚Üë‚Üëf ‚Üë‚Üëg\n‚ä¢ Eq f g","decl":"protected theorem eq' {f g : Lp.simpleFunc E p Œº} : (f : Œ± ‚Üí‚Çò[Œº] E) = (g : Œ± ‚Üí‚Çò[Œº] E) ‚Üí f = g :=\n  Subtype.eq ‚àò Subtype.eq\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coe_smul","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\nùïú : Type u_6\ninst‚úù‚Å¥ : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : Module ùïú E\ninst‚úù : BoundedSMul ùïú E\nc : ùïú\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ Eq (‚Üë(HSMul.hSMul c f)) (HSMul.hSMul c ‚Üëf)","decl":"@[simp, norm_cast]\ntheorem coe_smul (c : ùïú) (f : Lp.simpleFunc E p Œº) :\n    ((c ‚Ä¢ f : Lp.simpleFunc E p Œº) : Lp E p Œº) = c ‚Ä¢ (f : Lp E p Œº) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.boundedSMul","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\nùïú : Type u_6\ninst‚úù‚Åµ : MeasurableSpace Œ±\ninst‚úù‚Å¥ : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : Module ùïú E\ninst‚úù¬π : BoundedSMul ùïú E\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ BoundedSMul ùïú (Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x)","decl":"/-- If `E` is a normed space, `Lp.simpleFunc E p Œº` is a normed space. Not declared as an\ninstance as it is (as of writing) used only in the construction of the Bochner integral. -/\nprotected theorem boundedSMul [Fact (1 ‚â§ p)] : BoundedSMul ùïú (Lp.simpleFunc E p Œº) :=\n  BoundedSMul.of_norm_smul_le fun r f => (norm_smul_le r (f : Lp E p Œº) :)\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_eq_toLp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\n‚ä¢ Eq (‚Üë(MeasureTheory.Lp.simpleFunc.toLp f hf)) (MeasureTheory.Mem‚Ñíp.toLp (‚áëf) hf)","decl":"theorem toLp_eq_toLp (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_eq_mk","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\n‚ä¢ Eq (‚Üë‚Üë(MeasureTheory.Lp.simpleFunc.toLp f hf)) (MeasureTheory.AEEqFun.mk ‚áëf ‚ãØ)","decl":"theorem toLp_eq_mk (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) :\n    (toLp f hf : Œ± ‚Üí‚Çò[Œº] E) = AEEqFun.mk f f.aestronglyMeasurable :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Eq (MeasureTheory.Lp.simpleFunc.toLp 0 ‚ãØ) 0","decl":"theorem toLp_zero : toLp (0 : Œ± ‚Üí‚Çõ E) Mem‚Ñíp.zero = (0 : Lp.simpleFunc E p Œº) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_add","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\nhg : MeasureTheory.Mem‚Ñíp (‚áëg) p Œº\n‚ä¢ Eq (MeasureTheory.Lp.simpleFunc.toLp (HAdd.hAdd f g) ‚ãØ) (HAdd.hAdd (MeasureTheory.Lp.simpleFunc.toLp f hf) (MeasureTheory.Lp.simpleFunc.toLp g hg))","decl":"theorem toLp_add (f g : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) :\n    toLp (f + g) (hf.add hg) = toLp f hf + toLp g hg :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_neg","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\n‚ä¢ Eq (MeasureTheory.Lp.simpleFunc.toLp (Neg.neg f) ‚ãØ) (Neg.neg (MeasureTheory.Lp.simpleFunc.toLp f hf))","decl":"theorem toLp_neg (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : toLp (-f) hf.neg = -toLp f hf :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_sub","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\nhg : MeasureTheory.Mem‚Ñíp (‚áëg) p Œº\n‚ä¢ Eq (MeasureTheory.Lp.simpleFunc.toLp (HSub.hSub f g) ‚ãØ) (HSub.hSub (MeasureTheory.Lp.simpleFunc.toLp f hf) (MeasureTheory.Lp.simpleFunc.toLp g hg))","decl":"theorem toLp_sub (f g : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) :\n    toLp (f - g) (hf.sub hg) = toLp f hf - toLp g hg := by\n  simp only [sub_eq_add_neg, ‚Üê toLp_neg, ‚Üê toLp_add]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_smul","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\nùïú : Type u_6\ninst‚úù‚Å¥ : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : Module ùïú E\ninst‚úù : BoundedSMul ùïú E\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\nc : ùïú\n‚ä¢ Eq (MeasureTheory.Lp.simpleFunc.toLp (HSMul.hSMul c f) ‚ãØ) (HSMul.hSMul c (MeasureTheory.Lp.simpleFunc.toLp f hf))","decl":"theorem toLp_smul (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) (c : ùïú) :\n    toLp (c ‚Ä¢ f) (hf.const_smul c) = c ‚Ä¢ toLp f hf :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.norm_toLp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\n‚ä¢ Eq (Norm.norm (MeasureTheory.Lp.simpleFunc.toLp f hf)) (MeasureTheory.eLpNorm (‚áëf) p Œº).toReal","decl":"nonrec theorem norm_toLp [Fact (1 ‚â§ p)] (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) :\n    ‚ÄñtoLp f hf‚Äñ = ENNReal.toReal (eLpNorm f p Œº) :=\n  norm_toLp f hf\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.measurable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasurableSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ Measurable ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)","decl":"/-- `(toSimpleFunc f)` is measurable. -/\n@[measurability]\nprotected theorem measurable [MeasurableSpace E] (f : Lp.simpleFunc E p Œº) :\n    Measurable (toSimpleFunc f) :=\n  (toSimpleFunc f).measurable\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ MeasureTheory.StronglyMeasurable ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)","decl":"protected theorem stronglyMeasurable (f : Lp.simpleFunc E p Œº) :\n    StronglyMeasurable (toSimpleFunc f) :=\n  (toSimpleFunc f).stronglyMeasurable\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.aemeasurable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasurableSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ AEMeasurable (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) Œº","decl":"@[measurability]\nprotected theorem aemeasurable [MeasurableSpace E] (f : Lp.simpleFunc E p Œº) :\n    AEMeasurable (toSimpleFunc f) Œº :=\n  (simpleFunc.measurable f).aemeasurable\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ MeasureTheory.AEStronglyMeasurable (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) Œº","decl":"protected theorem aestronglyMeasurable (f : Lp.simpleFunc E p Œº) :\n    AEStronglyMeasurable (toSimpleFunc f) Œº :=\n  (simpleFunc.stronglyMeasurable f).aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toSimpleFunc_eq_toFun","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ‚Üë‚Üë‚Üëf","decl":"theorem toSimpleFunc_eq_toFun (f : Lp.simpleFunc E p Œº) : toSimpleFunc f =·µê[Œº] f :=\n  show ‚áë(toSimpleFunc f) =·µê[Œº] ‚áë(f : Œ± ‚Üí‚Çò[Œº] E) by\n    convert (AEEqFun.coeFn_mk (toSimpleFunc f)\n          (toSimpleFunc f).aestronglyMeasurable).symm using 2\n    exact (Classical.choose_spec f.2).symm\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.mem‚Ñíp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ MeasureTheory.Mem‚Ñíp (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) p Œº","decl":"/-- `toSimpleFunc f` satisfies the predicate `Mem‚Ñíp`. -/\nprotected theorem mem‚Ñíp (f : Lp.simpleFunc E p Œº) : Mem‚Ñíp (toSimpleFunc f) p Œº :=\n  Mem‚Ñíp.ae_eq (toSimpleFunc_eq_toFun f).symm <| mem_Lp_iff_mem‚Ñíp.mp (f : Lp E p Œº).2\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ Eq (MeasureTheory.Lp.simpleFunc.toLp (MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ‚ãØ) f","decl":"theorem toLp_toSimpleFunc (f : Lp.simpleFunc E p Œº) :\n    toLp (toSimpleFunc f) (simpleFunc.mem‚Ñíp f) = f :=\n  simpleFunc.eq' (Classical.choose_spec f.2)\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toSimpleFunc_toLp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhfi : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc (MeasureTheory.Lp.simpleFunc.toLp f hfi)) ‚áëf","decl":"theorem toSimpleFunc_toLp (f : Œ± ‚Üí‚Çõ E) (hfi : Mem‚Ñíp f p Œº) : toSimpleFunc (toLp f hfi) =·µê[Œº] f := by\n  rw [‚Üê AEEqFun.mk_eq_mk]; exact Classical.choose_spec (toLp f hfi).2\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.zero_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc 0)) 0","decl":"theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 := by\n  filter_upwards [toSimpleFunc_eq_toFun (0 : Lp.simpleFunc E p Œº),\n    Lp.coeFn_zero E 1 Œº] with _ h‚ÇÅ _\n  rwa [h‚ÇÅ]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.add_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc (HAdd.hAdd f g))) (HAdd.hAdd ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc g))","decl":"theorem add_toSimpleFunc (f g : Lp.simpleFunc E p Œº) :\n    toSimpleFunc (f + g) =·µê[Œº] toSimpleFunc f + toSimpleFunc g := by\n  filter_upwards [toSimpleFunc_eq_toFun (f + g), toSimpleFunc_eq_toFun f,\n    toSimpleFunc_eq_toFun g, Lp.coeFn_add (f : Lp E p Œº) g] with _\n  simp only [AddSubgroup.coe_add, Pi.add_apply]\n  iterate 4 intro h; rw [h]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.neg_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc (Neg.neg f))) (Neg.neg ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f))","decl":"theorem neg_toSimpleFunc (f : Lp.simpleFunc E p Œº) : toSimpleFunc (-f) =·µê[Œº] -toSimpleFunc f := by\n  filter_upwards [toSimpleFunc_eq_toFun (-f), toSimpleFunc_eq_toFun f,\n    Lp.coeFn_neg (f : Lp E p Œº)] with _\n  simp only [Pi.neg_apply, AddSubgroup.coe_neg]\n  repeat intro h; rw [h]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.sub_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc (HSub.hSub f g))) (HSub.hSub ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc g))","decl":"theorem sub_toSimpleFunc (f g : Lp.simpleFunc E p Œº) :\n    toSimpleFunc (f - g) =·µê[Œº] toSimpleFunc f - toSimpleFunc g := by\n  filter_upwards [toSimpleFunc_eq_toFun (f - g), toSimpleFunc_eq_toFun f,\n    toSimpleFunc_eq_toFun g, Lp.coeFn_sub (f : Lp E p Œº) g] with _\n  simp only [AddSubgroup.coe_sub, Pi.sub_apply]\n  repeat' intro h; rw [h]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.smul_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\nùïú : Type u_6\ninst‚úù‚Å¥ : MeasurableSpace Œ±\ninst‚úù¬≥ : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : Module ùïú E\ninst‚úù : BoundedSMul ùïú E\nk : ùïú\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc (HSMul.hSMul k f))) (HSMul.hSMul k ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f))","decl":"theorem smul_toSimpleFunc (k : ùïú) (f : Lp.simpleFunc E p Œº) :\n    toSimpleFunc (k ‚Ä¢ f) =·µê[Œº] k ‚Ä¢ ‚áë(toSimpleFunc f) := by\n  filter_upwards [toSimpleFunc_eq_toFun (k ‚Ä¢ f), toSimpleFunc_eq_toFun f,\n    Lp.coeFn_smul k (f : Lp E p Œº)] with _\n  simp only [Pi.smul_apply, coe_smul]\n  repeat intro h; rw [h]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.norm_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ Eq (Norm.norm f) (MeasureTheory.eLpNorm (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) p Œº).toReal","decl":"theorem norm_toSimpleFunc [Fact (1 ‚â§ p)] (f : Lp.simpleFunc E p Œº) :\n    ‚Äñf‚Äñ = ENNReal.toReal (eLpNorm (toSimpleFunc f) p Œº) := by\n  simpa [toLp_toSimpleFunc] using norm_toLp (toSimpleFunc f) (simpleFunc.mem‚Ñíp f)\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coe_indicatorConst","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\n‚ä¢ Eq (‚Üë(MeasureTheory.Lp.simpleFunc.indicatorConst p hs hŒºs c)) (MeasureTheory.indicatorConstLp p hs hŒºs c)","decl":"@[simp]\ntheorem coe_indicatorConst {s : Set Œ±} (hs : MeasurableSet s) (hŒºs : Œº s ‚â† ‚àû) (c : E) :\n    (‚Üë(indicatorConst p hs hŒºs c) : Lp E p Œº) = indicatorConstLp p hs hŒºs c :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toSimpleFunc_indicatorConst","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nhs : MeasurableSet s\nhŒºs : Ne (Œº s) Top.top\nc : E\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc (MeasureTheory.Lp.simpleFunc.indicatorConst p hs hŒºs c)) ‚áë(MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const Œ± c) (MeasureTheory.SimpleFunc.const Œ± 0))","decl":"theorem toSimpleFunc_indicatorConst {s : Set Œ±} (hs : MeasurableSet s) (hŒºs : Œº s ‚â† ‚àû) (c : E) :\n    toSimpleFunc (indicatorConst p hs hŒºs c) =·µê[Œº]\n      (SimpleFunc.const _ c).piecewise s hs (SimpleFunc.const _ 0) :=\n  Lp.simpleFunc.toSimpleFunc_toLp _ _\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.induction","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\nP : (Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x) ‚Üí Prop\nh_ind : ‚àÄ (c : E) {s : Set Œ±} (hs : MeasurableSet s) (hŒºs : LT.lt (Œº s) Top.top), P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs ‚ãØ c)\nh_add : ‚àÄ ‚¶Éf g : MeasureTheory.SimpleFunc Œ± E‚¶Ñ (hf : MeasureTheory.Mem‚Ñíp (‚áëf) p Œº) (hg : MeasureTheory.Mem‚Ñíp (‚áëg) p Œº), Disjoint (Function.support ‚áëf) (Function.support ‚áëg) ‚Üí P (MeasureTheory.Lp.simpleFunc.toLp f hf) ‚Üí P (MeasureTheory.Lp.simpleFunc.toLp g hg) ‚Üí P (HAdd.hAdd (MeasureTheory.Lp.simpleFunc.toLp f hf) (MeasureTheory.Lp.simpleFunc.toLp g hg))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p Œº) x\n‚ä¢ P f","decl":"/-- To prove something for an arbitrary `Lp` simple function, with `0 < p < ‚àû`, it suffices to show\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\nsets and is closed under addition (of functions with disjoint support). -/\n@[elab_as_elim]\nprotected theorem induction (hp_pos : p ‚â† 0) (hp_ne_top : p ‚â† ‚àû) {P : Lp.simpleFunc E p Œº ‚Üí Prop}\n    (h_ind :\n      ‚àÄ (c : E) {s : Set Œ±} (hs : MeasurableSet s) (hŒºs : Œº s < ‚àû),\n        P (Lp.simpleFunc.indicatorConst p hs hŒºs.ne c))\n    (h_add :\n      ‚àÄ ‚¶Éf g : Œ± ‚Üí‚Çõ E‚¶Ñ,\n        ‚àÄ hf : Mem‚Ñíp f p Œº,\n          ‚àÄ hg : Mem‚Ñíp g p Œº,\n            Disjoint (support f) (support g) ‚Üí\n              P (Lp.simpleFunc.toLp f hf) ‚Üí\n                P (Lp.simpleFunc.toLp g hg) ‚Üí P (Lp.simpleFunc.toLp f hf + Lp.simpleFunc.toLp g hg))\n    (f : Lp.simpleFunc E p Œº) : P f := by\n  suffices ‚àÄ f : Œ± ‚Üí‚Çõ E, ‚àÄ hf : Mem‚Ñíp f p Œº, P (toLp f hf) by\n    rw [‚Üê toLp_toSimpleFunc f]\n    apply this\n  clear f\n  apply SimpleFunc.induction\n  ¬∑ intro c s hs hf\n    by_cases hc : c = 0\n    ¬∑ convert h_ind 0 MeasurableSet.empty (by simp) using 1\n      ext1\n      simp [hc]\n    exact h_ind c hs (SimpleFunc.measure_lt_top_of_mem‚Ñíp_indicator hp_pos hp_ne_top hc hs hf)\n  ¬∑ intro f g hfg hf hg hfg'\n    obtain ‚ü®hf', hg'‚ü© : Mem‚Ñíp f p Œº ‚àß Mem‚Ñíp g p Œº :=\n      (mem‚Ñíp_add_of_disjoint hfg f.stronglyMeasurable g.stronglyMeasurable).mp hfg'\n    exact h_add hf' hg' hfg (hf hf') (hg hg')\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.uniformContinuous","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ UniformContinuous Subtype.val","decl":"protected theorem uniformContinuous : UniformContinuous ((‚Üë) : Lp.simpleFunc E p Œº ‚Üí Lp E p Œº) :=\n  uniformContinuous_comap\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.isUniformEmbedding","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ IsUniformEmbedding Subtype.val","decl":"lemma isUniformEmbedding : IsUniformEmbedding ((‚Üë) : Lp.simpleFunc E p Œº ‚Üí Lp E p Œº) :=\n  isUniformEmbedding_comap Subtype.val_injective\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.uniformEmbedding","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ IsUniformEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-01\")] alias uniformEmbedding := isUniformEmbedding\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.isUniformInducing","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ IsUniformInducing Subtype.val","decl":"theorem isUniformInducing : IsUniformInducing ((‚Üë) : Lp.simpleFunc E p Œº ‚Üí Lp E p Œº) :=\n  simpleFunc.isUniformEmbedding.isUniformInducing\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.uniformInducing","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ IsUniformInducing Subtype.val","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing := isUniformInducing\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.isDenseEmbedding","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n‚ä¢ IsDenseEmbedding Subtype.val","decl":"lemma isDenseEmbedding (hp_ne_top : p ‚â† ‚àû) :\n    IsDenseEmbedding ((‚Üë) : Lp.simpleFunc E p Œº ‚Üí Lp E p Œº) := by\n  borelize E\n  apply simpleFunc.isUniformEmbedding.isDenseEmbedding\n  intro f\n  rw [mem_closure_iff_seq_limit]\n  have hfi' : Mem‚Ñíp f p Œº := Lp.mem‚Ñíp f\n  haveI : SeparableSpace (range f ‚à™ {0} : Set E) :=\n    (Lp.stronglyMeasurable f).separableSpace_range_union_singleton\n  refine\n    ‚ü®fun n =>\n      toLp\n        (SimpleFunc.approxOn f (Lp.stronglyMeasurable f).measurable (range f ‚à™ {0}) 0 _ n)\n        (SimpleFunc.mem‚Ñíp_approxOn_range (Lp.stronglyMeasurable f).measurable hfi' n),\n      fun n => mem_range_self _, ?_‚ü©\n  convert SimpleFunc.tendsto_approxOn_range_Lp hp_ne_top (Lp.stronglyMeasurable f).measurable hfi'\n  rw [toLp_coeFn f (Lp.mem‚Ñíp f)]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.denseEmbedding","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n‚ä¢ IsDenseEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-09-30\")]\nalias denseEmbedding := isDenseEmbedding\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.isDenseInducing","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n‚ä¢ IsDenseInducing Subtype.val","decl":"protected theorem isDenseInducing (hp_ne_top : p ‚â† ‚àû) :\n    IsDenseInducing ((‚Üë) : Lp.simpleFunc E p Œº ‚Üí Lp E p Œº) :=\n  (simpleFunc.isDenseEmbedding hp_ne_top).isDenseInducing\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.denseRange","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n‚ä¢ DenseRange Subtype.val","decl":"protected theorem denseRange (hp_ne_top : p ‚â† ‚àû) :\n    DenseRange ((‚Üë) : Lp.simpleFunc E p Œº ‚Üí Lp E p Œº) :=\n  (simpleFunc.isDenseInducing hp_ne_top).dense\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.dense","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n‚ä¢ Dense ‚Üë(MeasureTheory.Lp.simpleFunc E p Œº)","decl":"protected theorem dense (hp_ne_top : p ‚â† ‚àû) : Dense (Lp.simpleFunc E p Œº : Set (Lp E p Œº)) := by\n  simpa only [denseRange_subtype_val] using simpleFunc.denseRange (E := E) (Œº := Œº) hp_ne_top\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coeFn_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nG : Type u_7\ninst‚úù : NormedLatticeAddCommGroup G\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G p Œº) x\n‚ä¢ Iff ((MeasureTheory.ae Œº).EventuallyLE ‚Üë‚Üë‚Üëf ‚Üë‚Üë‚Üëg) (LE.le f g)","decl":"theorem coeFn_le (f g : Lp.simpleFunc G p Œº) : (f : Œ± ‚Üí G) ‚â§·µê[Œº] g ‚Üî f ‚â§ g := by\n  rw [‚Üê Subtype.coe_le_coe, ‚Üê Lp.coeFn_le]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.instAddLeftMono","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nG : Type u_7\ninst‚úù : NormedLatticeAddCommGroup G\n‚ä¢ AddLeftMono (Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G p Œº) x)","decl":"instance instAddLeftMono : AddLeftMono (Lp.simpleFunc G p Œº) := by\n  refine ‚ü®fun f g‚ÇÅ g‚ÇÇ hg‚ÇÅ‚ÇÇ => ?_‚ü©\n  exact add_le_add_left hg‚ÇÅ‚ÇÇ f\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coeFn_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nG : Type u_7\ninst‚úù : NormedLatticeAddCommGroup G\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (‚Üë‚Üë‚Üë0) 0","decl":"theorem coeFn_zero : (0 : Lp.simpleFunc G p Œº) =·µê[Œº] (0 : Œ± ‚Üí G) :=\n  Lp.coeFn_zero _ _ _\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coeFn_nonneg","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nG : Type u_7\ninst‚úù : NormedLatticeAddCommGroup G\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G p Œº) x\n‚ä¢ Iff ((MeasureTheory.ae Œº).EventuallyLE 0 ‚Üë‚Üë‚Üëf) (LE.le 0 f)","decl":"theorem coeFn_nonneg (f : Lp.simpleFunc G p Œº) : (0 : Œ± ‚Üí G) ‚â§·µê[Œº] f ‚Üî 0 ‚â§ f := by\n  rw [‚Üê Subtype.coe_le_coe, Lp.coeFn_nonneg, AddSubmonoid.coe_zero]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.exists_simpleFunc_nonneg_ae_eq","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nG : Type u_7\ninst‚úù : NormedLatticeAddCommGroup G\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G p Œº) x\nhf : LE.le 0 f\n‚ä¢ Exists fun f' => And (LE.le 0 f') ((MeasureTheory.ae Œº).EventuallyEq ‚Üë‚Üë‚Üëf ‚áëf')","decl":"theorem exists_simpleFunc_nonneg_ae_eq {f : Lp.simpleFunc G p Œº} (hf : 0 ‚â§ f) :\n    ‚àÉ f' : Œ± ‚Üí‚Çõ G, 0 ‚â§ f' ‚àß f =·µê[Œº] f' := by\n  rcases f with ‚ü®‚ü®f, hp‚ü©, g, (rfl : _ = f)‚ü©\n  change 0 ‚â§·µê[Œº] g at hf\n  refine ‚ü®g ‚äî 0, le_sup_right, (AEEqFun.coeFn_mk _ _).trans ?_‚ü©\n  exact hf.mono fun x hx ‚Ü¶ (sup_of_le_left hx).symm\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.denseRange_coeSimpleFuncNonnegToLpNonneg","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nG : Type u_7\ninst‚úù : NormedLatticeAddCommGroup G\nhp : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n‚ä¢ DenseRange (MeasureTheory.Lp.simpleFunc.coeSimpleFuncNonnegToLpNonneg p Œº G)","decl":"theorem denseRange_coeSimpleFuncNonnegToLpNonneg [hp : Fact (1 ‚â§ p)] (hp_ne_top : p ‚â† ‚àû) :\n    DenseRange (coeSimpleFuncNonnegToLpNonneg p Œº G) := fun g ‚Ü¶ by\n  borelize G\n  rw [mem_closure_iff_seq_limit]\n  have hg_mem‚Ñíp : Mem‚Ñíp (g : Œ± ‚Üí G) p Œº := Lp.mem‚Ñíp (g : Lp G p Œº)\n  have zero_mem : (0 : G) ‚àà (range (g : Œ± ‚Üí G) ‚à™ {0} : Set G) ‚à© { y | 0 ‚â§ y } := by\n    simp only [union_singleton, mem_inter_iff, mem_insert_iff, eq_self_iff_true, true_or,\n      mem_setOf_eq, le_refl, and_self_iff]\n  have : SeparableSpace ((range (g : Œ± ‚Üí G) ‚à™ {0}) ‚à© { y | 0 ‚â§ y } : Set G) := by\n    apply IsSeparable.separableSpace\n    apply IsSeparable.mono _ Set.inter_subset_left\n    exact\n      (Lp.stronglyMeasurable (g : Lp G p Œº)).isSeparable_range.union\n        (finite_singleton _).isSeparable\n  have g_meas : Measurable (g : Œ± ‚Üí G) := (Lp.stronglyMeasurable (g : Lp G p Œº)).measurable\n  let x n := SimpleFunc.approxOn (g : Œ± ‚Üí G) g_meas\n    ((range (g : Œ± ‚Üí G) ‚à™ {0}) ‚à© { y | 0 ‚â§ y }) 0 zero_mem n\n  have hx_nonneg : ‚àÄ n, 0 ‚â§ x n := by\n    intro n a\n    change x n a ‚àà { y : G | 0 ‚â§ y }\n    have A : (range (g : Œ± ‚Üí G) ‚à™ {0} : Set G) ‚à© { y | 0 ‚â§ y } ‚äÜ { y | 0 ‚â§ y } :=\n      inter_subset_right\n    apply A\n    exact SimpleFunc.approxOn_mem g_meas _ n a\n  have hx_mem‚Ñíp : ‚àÄ n, Mem‚Ñíp (x n) p Œº :=\n    SimpleFunc.mem‚Ñíp_approxOn _ hg_mem‚Ñíp _ ‚ü®aestronglyMeasurable_const, by simp‚ü©\n  have h_toLp := fun n => Mem‚Ñíp.coeFn_toLp (hx_mem‚Ñíp n)\n  have hx_nonneg_Lp : ‚àÄ n, 0 ‚â§ toLp (x n) (hx_mem‚Ñíp n) := by\n    intro n\n    rw [‚Üê Lp.simpleFunc.coeFn_le, Lp.simpleFunc.toLp_eq_toLp]\n    filter_upwards [Lp.simpleFunc.coeFn_zero p Œº G, h_toLp n] with a ha0 ha_toLp\n    rw [ha0, ha_toLp]\n    exact hx_nonneg n a\n  have hx_tendsto :\n      Tendsto (fun n : ‚Ñï => eLpNorm ((x n : Œ± ‚Üí G) - (g : Œ± ‚Üí G)) p Œº) atTop (ùìù 0) := by\n    apply SimpleFunc.tendsto_approxOn_Lp_eLpNorm g_meas zero_mem hp_ne_top\n    ¬∑ have hg_nonneg : (0 : Œ± ‚Üí G) ‚â§·µê[Œº] g := (Lp.coeFn_nonneg _).mpr g.2\n      refine hg_nonneg.mono fun a ha => subset_closure ?_\n      simpa using ha\n    ¬∑ simp_rw [sub_zero]; exact hg_mem‚Ñíp.eLpNorm_lt_top\n  refine\n    ‚ü®fun n =>\n      (coeSimpleFuncNonnegToLpNonneg p Œº G) ‚ü®toLp (x n) (hx_mem‚Ñíp n), hx_nonneg_Lp n‚ü©,\n      fun n => mem_range_self _, ?_‚ü©\n  suffices Tendsto (fun n : ‚Ñï => (toLp (x n) (hx_mem‚Ñíp n) : Lp G p Œº)) atTop (ùìù (g : Lp G p Œº)) by\n    rw [tendsto_iff_dist_tendsto_zero] at this ‚ä¢\n    simp_rw [Subtype.dist_eq]\n    exact this\n  rw [Lp.tendsto_Lp_iff_tendsto_‚Ñíp']\n  refine Filter.Tendsto.congr (fun n => eLpNorm_congr_ae (EventuallyEq.sub ?_ ?_)) hx_tendsto\n  ¬∑ symm\n    rw [Lp.simpleFunc.toLp_eq_toLp]\n    exact h_toLp n\n  ¬∑ rfl\n\n"}
{"name":"MeasureTheory.Lp.induction","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\n_i : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\nP : (Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x) ‚Üí Prop\nh_ind : ‚àÄ (c : E) {s : Set Œ±} (hs : MeasurableSet s) (hŒºs : LT.lt (Œº s) Top.top), P ‚Üë(MeasureTheory.Lp.simpleFunc.indicatorConst p hs ‚ãØ c)\nh_add : ‚àÄ ‚¶Éf g : Œ± ‚Üí E‚¶Ñ (hf : MeasureTheory.Mem‚Ñíp f p Œº) (hg : MeasureTheory.Mem‚Ñíp g p Œº), Disjoint (Function.support f) (Function.support g) ‚Üí P (MeasureTheory.Mem‚Ñíp.toLp f hf) ‚Üí P (MeasureTheory.Mem‚Ñíp.toLp g hg) ‚Üí P (HAdd.hAdd (MeasureTheory.Mem‚Ñíp.toLp f hf) (MeasureTheory.Mem‚Ñíp.toLp g hg))\nh_closed : IsClosed (setOf fun f => P f)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Œº) x\n‚ä¢ P f","decl":"/-- To prove something for an arbitrary `Lp` function in a second countable Borel normed group, it\nsuffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in `Lp` for which the property holds is closed.\n-/\n@[elab_as_elim]\ntheorem Lp.induction [_i : Fact (1 ‚â§ p)] (hp_ne_top : p ‚â† ‚àû) (P : Lp E p Œº ‚Üí Prop)\n    (h_ind : ‚àÄ (c : E) {s : Set Œ±} (hs : MeasurableSet s) (hŒºs : Œº s < ‚àû),\n      P (Lp.simpleFunc.indicatorConst p hs hŒºs.ne c))\n    (h_add : ‚àÄ ‚¶Éf g‚¶Ñ, ‚àÄ hf : Mem‚Ñíp f p Œº, ‚àÄ hg : Mem‚Ñíp g p Œº, Disjoint (support f) (support g) ‚Üí\n      P (hf.toLp f) ‚Üí P (hg.toLp g) ‚Üí P (hf.toLp f + hg.toLp g))\n    (h_closed : IsClosed { f : Lp E p Œº | P f }) : ‚àÄ f : Lp E p Œº, P f := by\n  refine fun f => (Lp.simpleFunc.denseRange hp_ne_top).induction_on f h_closed ?_\n  refine Lp.simpleFunc.induction (Œ± := Œ±) (E := E) (lt_of_lt_of_le zero_lt_one _i.elim).ne'\n    hp_ne_top ?_ ?_\n  ¬∑ exact fun c s => h_ind c\n  ¬∑ exact fun f g hf hg => h_add hf hg\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.induction","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\n_i : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\nP : (Œ± ‚Üí E) ‚Üí Prop\nh_ind : ‚àÄ (c : E) ‚¶És : Set Œ±‚¶Ñ, MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí P (s.indicator fun x => c)\nh_add : ‚àÄ ‚¶Éf g : Œ± ‚Üí E‚¶Ñ, Disjoint (Function.support f) (Function.support g) ‚Üí MeasureTheory.Mem‚Ñíp f p Œº ‚Üí MeasureTheory.Mem‚Ñíp g p Œº ‚Üí P f ‚Üí P g ‚Üí P (HAdd.hAdd f g)\nh_closed : IsClosed (setOf fun f => P ‚Üë‚Üëf)\nh_ae : ‚àÄ ‚¶Éf g : Œ± ‚Üí E‚¶Ñ, (MeasureTheory.ae Œº).EventuallyEq f g ‚Üí MeasureTheory.Mem‚Ñíp f p Œº ‚Üí P f ‚Üí P g\nf : Œ± ‚Üí E\na‚úù : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ P f","decl":"/-- To prove something for an arbitrary `Mem‚Ñíp` function in a second countable\nBorel normed group, it suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `L·µñ` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`).\n-/\n@[elab_as_elim]\ntheorem Mem‚Ñíp.induction [_i : Fact (1 ‚â§ p)] (hp_ne_top : p ‚â† ‚àû) (P : (Œ± ‚Üí E) ‚Üí Prop)\n    (h_ind : ‚àÄ (c : E) ‚¶És‚¶Ñ, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí P (s.indicator fun _ => c))\n    (h_add : ‚àÄ ‚¶Éf g : Œ± ‚Üí E‚¶Ñ, Disjoint (support f) (support g) ‚Üí Mem‚Ñíp f p Œº ‚Üí Mem‚Ñíp g p Œº ‚Üí\n      P f ‚Üí P g ‚Üí P (f + g))\n    (h_closed : IsClosed { f : Lp E p Œº | P f })\n    (h_ae : ‚àÄ ‚¶Éf g‚¶Ñ, f =·µê[Œº] g ‚Üí Mem‚Ñíp f p Œº ‚Üí P f ‚Üí P g) :\n    ‚àÄ ‚¶Éf : Œ± ‚Üí E‚¶Ñ, Mem‚Ñíp f p Œº ‚Üí P f := by\n  have : ‚àÄ f : SimpleFunc Œ± E, Mem‚Ñíp f p Œº ‚Üí P f := by\n    apply SimpleFunc.induction\n    ¬∑ intro c s hs h\n      by_cases hc : c = 0\n      ¬∑ subst hc; convert h_ind 0 MeasurableSet.empty (by simp) using 1; ext; simp [const]\n      have hp_pos : p ‚â† 0 := (lt_of_lt_of_le zero_lt_one _i.elim).ne'\n      exact h_ind c hs (SimpleFunc.measure_lt_top_of_mem‚Ñíp_indicator hp_pos hp_ne_top hc hs h)\n    ¬∑ intro f g hfg hf hg int_fg\n      rw [SimpleFunc.coe_add,\n        mem‚Ñíp_add_of_disjoint hfg f.stronglyMeasurable g.stronglyMeasurable] at int_fg\n      exact h_add hfg int_fg.1 int_fg.2 (hf int_fg.1) (hg int_fg.2)\n  have : ‚àÄ f : Lp.simpleFunc E p Œº, P f := by\n    intro f\n    exact\n      h_ae (Lp.simpleFunc.toSimpleFunc_eq_toFun f) (Lp.simpleFunc.mem‚Ñíp f)\n        (this (Lp.simpleFunc.toSimpleFunc f) (Lp.simpleFunc.mem‚Ñíp f))\n  have : ‚àÄ f : Lp E p Œº, P f := fun f =>\n    (Lp.simpleFunc.denseRange hp_ne_top).induction_on f h_closed this\n  exact fun f hf => h_ae hf.coeFn_toLp (Lp.mem‚Ñíp _) (this (hf.toLp f))\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.induction_dense","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nhp_ne_top : Ne p Top.top\nP : (Œ± ‚Üí E) ‚Üí Prop\nh0P : ‚àÄ (c : E) ‚¶És : Set Œ±‚¶Ñ, MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí ‚àÄ {Œµ : ENNReal}, Ne Œµ 0 ‚Üí Exists fun g => And (LE.le (MeasureTheory.eLpNorm (HSub.hSub g (s.indicator fun x => c)) p Œº) Œµ) (P g)\nh1P : ‚àÄ (f g : Œ± ‚Üí E), P f ‚Üí P g ‚Üí P (HAdd.hAdd f g)\nh2P : ‚àÄ (f : Œ± ‚Üí E), P f ‚Üí MeasureTheory.AEStronglyMeasurable f Œº\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ Exists fun g => And (LE.le (MeasureTheory.eLpNorm (HSub.hSub f g) p Œº) Œµ) (P g)","decl":"/-- If a set of ae strongly measurable functions is stable under addition and approximates\ncharacteristic functions in `‚Ñíp`, then it is dense in `‚Ñíp`. -/\ntheorem Mem‚Ñíp.induction_dense (hp_ne_top : p ‚â† ‚àû) (P : (Œ± ‚Üí E) ‚Üí Prop)\n    (h0P :\n      ‚àÄ (c : E) ‚¶És : Set Œ±‚¶Ñ,\n        MeasurableSet s ‚Üí\n          Œº s < ‚àû ‚Üí\n            ‚àÄ {Œµ : ‚Ñù‚â•0‚àû}, Œµ ‚â† 0 ‚Üí ‚àÉ g : Œ± ‚Üí E, eLpNorm (g - s.indicator fun _ => c) p Œº ‚â§ Œµ ‚àß P g)\n    (h1P : ‚àÄ f g, P f ‚Üí P g ‚Üí P (f + g)) (h2P : ‚àÄ f, P f ‚Üí AEStronglyMeasurable f Œº) {f : Œ± ‚Üí E}\n    (hf : Mem‚Ñíp f p Œº) {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) : ‚àÉ g : Œ± ‚Üí E, eLpNorm (f - g) p Œº ‚â§ Œµ ‚àß P g := by\n  rcases eq_or_ne p 0 with (rfl | hp_pos)\n  ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])\n        hŒµ with ‚ü®g, _, Pg‚ü©\n    exact ‚ü®g, by simp only [eLpNorm_exponent_zero, zero_le'], Pg‚ü©\n  suffices H : ‚àÄ (f' : Œ± ‚Üí‚Çõ E) (Œ¥ : ‚Ñù‚â•0‚àû) (hŒ¥ : Œ¥ ‚â† 0), Mem‚Ñíp f' p Œº ‚Üí\n      ‚àÉ g, eLpNorm (‚áëf' - g) p Œº ‚â§ Œ¥ ‚àß P g by\n    obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p hŒµ\n    rcases hf.exists_simpleFunc_eLpNorm_sub_lt hp_ne_top Œ∑pos.ne' with ‚ü®f', hf', f'_mem‚ü©\n    rcases H f' Œ∑ Œ∑pos.ne' f'_mem with ‚ü®g, hg, Pg‚ü©\n    refine ‚ü®g, ?_, Pg‚ü©\n    convert (hŒ∑ _ _ (hf.aestronglyMeasurable.sub f'.aestronglyMeasurable)\n          (f'.aestronglyMeasurable.sub (h2P g Pg)) hf'.le hg).le using 2\n    simp only [sub_add_sub_cancel]\n  apply SimpleFunc.induction\n  ¬∑ intro c s hs Œµ Œµpos Hs\n    rcases eq_or_ne c 0 with (rfl | hc)\n    ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])\n          Œµpos with ‚ü®g, hg, Pg‚ü©\n      rw [‚Üê eLpNorm_neg, neg_sub] at hg\n      refine ‚ü®g, ?_, Pg‚ü©\n      convert hg\n      ext x\n      simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_zero,\n        piecewise_eq_indicator, indicator_zero', Pi.zero_apply, indicator_zero]\n    ¬∑ have : Œº s < ‚àû := SimpleFunc.measure_lt_top_of_mem‚Ñíp_indicator hp_pos hp_ne_top hc hs Hs\n      rcases h0P c hs this Œµpos with ‚ü®g, hg, Pg‚ü©\n      rw [‚Üê eLpNorm_neg, neg_sub] at hg\n      exact ‚ü®g, hg, Pg‚ü©\n  ¬∑ intro f f' hff' hf hf' Œ¥ Œ¥pos int_ff'\n    obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p Œ¥pos\n    rw [SimpleFunc.coe_add,\n      mem‚Ñíp_add_of_disjoint hff' f.stronglyMeasurable f'.stronglyMeasurable] at int_ff'\n    rcases hf Œ∑ Œ∑pos.ne' int_ff'.1 with ‚ü®g, hg, Pg‚ü©\n    rcases hf' Œ∑ Œ∑pos.ne' int_ff'.2 with ‚ü®g', hg', Pg'‚ü©\n    refine ‚ü®g + g', ?_, h1P g g' Pg Pg'‚ü©\n    convert (hŒ∑ _ _ (f.aestronglyMeasurable.sub (h2P g Pg))\n          (f'.aestronglyMeasurable.sub (h2P g' Pg')) hg hg').le using 2\n    rw [SimpleFunc.coe_add]\n    abel\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.toLp_one_eq_toL1","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (‚Üë(MeasureTheory.Lp.simpleFunc.toLp f ‚ãØ)) (MeasureTheory.Integrable.toL1 (‚áëf) hf)","decl":"theorem L1.SimpleFunc.toLp_one_eq_toL1 (f : Œ± ‚Üí‚Çõ E) (hf : Integrable f Œº) :\n    (Lp.simpleFunc.toLp f (mem‚Ñíp_one_iff_integrable.2 hf) : Œ± ‚Üí‚ÇÅ[Œº] E) = hf.toL1 f :=\n  rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ MeasureTheory.Integrable (‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) Œº","decl":"@[fun_prop]\nprotected theorem L1.SimpleFunc.integrable (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    Integrable (Lp.simpleFunc.toSimpleFunc f) Œº := by\n  rw [‚Üê mem‚Ñíp_one_iff_integrable]; exact Lp.simpleFunc.mem‚Ñíp f\n\n"}
{"name":"MeasureTheory.Integrable.induction","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"Œ± : Type u_1\nE : Type u_4\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nP : (Œ± ‚Üí E) ‚Üí Prop\nh_ind : ‚àÄ (c : E) ‚¶És : Set Œ±‚¶Ñ, MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí P (s.indicator fun x => c)\nh_add : ‚àÄ ‚¶Éf g : Œ± ‚Üí E‚¶Ñ, Disjoint (Function.support f) (Function.support g) ‚Üí MeasureTheory.Integrable f Œº ‚Üí MeasureTheory.Integrable g Œº ‚Üí P f ‚Üí P g ‚Üí P (HAdd.hAdd f g)\nh_closed : IsClosed (setOf fun f => P ‚Üë‚Üëf)\nh_ae : ‚àÄ ‚¶Éf g : Œ± ‚Üí E‚¶Ñ, (MeasureTheory.ae Œº).EventuallyEq f g ‚Üí MeasureTheory.Integrable f Œº ‚Üí P f ‚Üí P g\nf : Œ± ‚Üí E\na‚úù : MeasureTheory.Integrable f Œº\n‚ä¢ P f","decl":"/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `L¬π` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`).\n-/\n@[elab_as_elim]\ntheorem Integrable.induction (P : (Œ± ‚Üí E) ‚Üí Prop)\n    (h_ind : ‚àÄ (c : E) ‚¶És‚¶Ñ, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí P (s.indicator fun _ => c))\n    (h_add :\n      ‚àÄ ‚¶Éf g : Œ± ‚Üí E‚¶Ñ,\n        Disjoint (support f) (support g) ‚Üí Integrable f Œº ‚Üí Integrable g Œº ‚Üí P f ‚Üí P g ‚Üí P (f + g))\n    (h_closed : IsClosed { f : Œ± ‚Üí‚ÇÅ[Œº] E | P f })\n    (h_ae : ‚àÄ ‚¶Éf g‚¶Ñ, f =·µê[Œº] g ‚Üí Integrable f Œº ‚Üí P f ‚Üí P g) :\n    ‚àÄ ‚¶Éf : Œ± ‚Üí E‚¶Ñ, Integrable f Œº ‚Üí P f := by\n  simp only [‚Üê mem‚Ñíp_one_iff_integrable] at *\n  exact Mem‚Ñíp.induction one_ne_top (P := P) h_ind h_add h_closed h_ae\n\n"}
