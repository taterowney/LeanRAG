{"name":"MeasureTheory.SimpleFunc.nnnorm_approxOn_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : OpensMeasurableSpace E\nf : β → E\nhf : Measurable f\ns : Set E\ny₀ : E\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nx : β\nn : Nat\n⊢ LE.le (NNNorm.nnnorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n) x) (f x))) (NNNorm.nnnorm (HSub.hSub (f x) y₀))","decl":"theorem nnnorm_approxOn_le [OpensMeasurableSpace E] {f : β → E} (hf : Measurable f) {s : Set E}\n    {y₀ : E} (h₀ : y₀ ∈ s) [SeparableSpace s] (x : β) (n : ℕ) :\n    ‖approxOn f hf s y₀ h₀ n x - f x‖₊ ≤ ‖f x - y₀‖₊ := by\n  have := edist_approxOn_le hf h₀ x n\n  rw [edist_comm y₀] at this\n  simp only [edist_nndist, nndist_eq_nnnorm] at this\n  exact mod_cast this\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_approxOn_y₀_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : OpensMeasurableSpace E\nf : β → E\nhf : Measurable f\ns : Set E\ny₀ : E\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nx : β\nn : Nat\n⊢ LE.le (Norm.norm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n) x) y₀)) (HAdd.hAdd (Norm.norm (HSub.hSub (f x) y₀)) (Norm.norm (HSub.hSub (f x) y₀)))","decl":"theorem norm_approxOn_y₀_le [OpensMeasurableSpace E] {f : β → E} (hf : Measurable f) {s : Set E}\n    {y₀ : E} (h₀ : y₀ ∈ s) [SeparableSpace s] (x : β) (n : ℕ) :\n    ‖approxOn f hf s y₀ h₀ n x - y₀‖ ≤ ‖f x - y₀‖ + ‖f x - y₀‖ := by\n  simpa [enorm, edist_eq_enorm_sub, ← ENNReal.coe_add, norm_sub_rev]\n    using edist_approxOn_y0_le hf h₀ x n\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_approxOn_zero_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : OpensMeasurableSpace E\nf : β → E\nhf : Measurable f\ns : Set E\nh₀ : Membership.mem s 0\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nx : β\nn : Nat\n⊢ LE.le (Norm.norm ((MeasureTheory.SimpleFunc.approxOn f hf s 0 h₀ n) x)) (HAdd.hAdd (Norm.norm (f x)) (Norm.norm (f x)))","decl":"theorem norm_approxOn_zero_le [OpensMeasurableSpace E] {f : β → E} (hf : Measurable f) {s : Set E}\n    (h₀ : (0 : E) ∈ s) [SeparableSpace s] (x : β) (n : ℕ) :\n    ‖approxOn f hf s 0 h₀ n x‖ ≤ ‖f x‖ + ‖f x‖ := by\n  simpa [enorm, edist_eq_enorm_sub, ← ENNReal.coe_add, norm_sub_rev]\n    using edist_approxOn_y0_le hf h₀ x n\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_Lp_eLpNorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\np : ENNReal\ninst✝¹ : OpensMeasurableSpace E\nf : β → E\nhf : Measurable f\ns : Set E\ny₀ : E\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nhp_ne_top : Ne p Top.top\nμ : MeasureTheory.Measure β\nhμ : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae μ)\nhi : LT.lt (MeasureTheory.eLpNorm (fun x => HSub.hSub (f x) y₀) p μ) Top.top\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (⇑(MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n)) f) p μ) Filter.atTop (nhds 0)","decl":"theorem tendsto_approxOn_Lp_eLpNorm [OpensMeasurableSpace E] {f : β → E} (hf : Measurable f)\n    {s : Set E} {y₀ : E} (h₀ : y₀ ∈ s) [SeparableSpace s] (hp_ne_top : p ≠ ∞) {μ : Measure β}\n    (hμ : ∀ᵐ x ∂μ, f x ∈ closure s) (hi : eLpNorm (fun x => f x - y₀) p μ < ∞) :\n    Tendsto (fun n => eLpNorm (⇑(approxOn f hf s y₀ h₀ n) - f) p μ) atTop (𝓝 0) := by\n  by_cases hp_zero : p = 0\n  · simpa only [hp_zero, eLpNorm_exponent_zero] using tendsto_const_nhds\n  have hp : 0 < p.toReal := toReal_pos hp_zero hp_ne_top\n  suffices Tendsto (fun n => ∫⁻ x, ‖approxOn f hf s y₀ h₀ n x - f x‖ₑ ^ p.toReal ∂μ) atTop (𝓝 0) by\n    simp only [eLpNorm_eq_lintegral_rpow_enorm hp_zero hp_ne_top]\n    convert continuous_rpow_const.continuousAt.tendsto.comp this\n    simp [zero_rpow_of_pos (_root_.inv_pos.mpr hp)]\n  -- We simply check the conditions of the Dominated Convergence Theorem:\n  -- (1) The function \"`p`-th power of distance between `f` and the approximation\" is measurable\n  have hF_meas n : Measurable fun x => ‖approxOn f hf s y₀ h₀ n x - f x‖ₑ ^ p.toReal := by\n    simpa only [← edist_eq_enorm_sub] using\n      (approxOn f hf s y₀ h₀ n).measurable_bind (fun y x => edist y (f x) ^ p.toReal) fun y =>\n        (measurable_edist_right.comp hf).pow_const p.toReal\n  -- (2) The functions \"`p`-th power of distance between `f` and the approximation\" are uniformly\n  -- bounded, at any given point, by `fun x => ‖f x - y₀‖ ^ p.toReal`\n  have h_bound n :\n    (fun x ↦ ‖approxOn f hf s y₀ h₀ n x - f x‖ₑ ^ p.toReal) ≤ᵐ[μ] (‖f · - y₀‖ₑ ^ p.toReal) :=\n    .of_forall fun x => rpow_le_rpow (coe_mono (nnnorm_approxOn_le hf h₀ x n)) toReal_nonneg\n  -- (3) The bounding function `fun x => ‖f x - y₀‖ ^ p.toReal` has finite integral\n  have h_fin : (∫⁻ a : β, ‖f a - y₀‖ₑ ^ p.toReal ∂μ) ≠ ⊤ :=\n    (lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top hp_zero hp_ne_top hi).ne\n  -- (4) The functions \"`p`-th power of distance between `f` and the approximation\" tend pointwise\n  -- to zero\n  have h_lim :\n    ∀ᵐ a : β ∂μ, Tendsto (‖approxOn f hf s y₀ h₀ · a - f a‖ₑ ^ p.toReal) atTop (𝓝 0) := by\n    filter_upwards [hμ] with a ha\n    have : Tendsto (fun n => (approxOn f hf s y₀ h₀ n) a - f a) atTop (𝓝 (f a - f a)) :=\n      (tendsto_approxOn hf h₀ ha).sub tendsto_const_nhds\n    convert continuous_rpow_const.continuousAt.tendsto.comp (tendsto_coe.mpr this.nnnorm)\n    simp [zero_rpow_of_pos hp]\n  -- Then we apply the Dominated Convergence Theorem\n  simpa using tendsto_lintegral_of_dominated_convergence _ hF_meas h_bound h_fin h_lim\n\n"}
{"name":"MeasureTheory.SimpleFunc.memℒp_approxOn","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\np : ENNReal\ninst✝¹ : BorelSpace E\nf : β → E\nμ : MeasureTheory.Measure β\nfmeas : Measurable f\nhf : MeasureTheory.Memℒp f p μ\ns : Set E\ny₀ : E\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nhi₀ : MeasureTheory.Memℒp (fun x => y₀) p μ\nn : Nat\n⊢ MeasureTheory.Memℒp (⇑(MeasureTheory.SimpleFunc.approxOn f fmeas s y₀ h₀ n)) p μ","decl":"theorem memℒp_approxOn [BorelSpace E] {f : β → E} {μ : Measure β} (fmeas : Measurable f)\n    (hf : Memℒp f p μ) {s : Set E} {y₀ : E} (h₀ : y₀ ∈ s) [SeparableSpace s]\n    (hi₀ : Memℒp (fun _ => y₀) p μ) (n : ℕ) : Memℒp (approxOn f fmeas s y₀ h₀ n) p μ := by\n  refine ⟨(approxOn f fmeas s y₀ h₀ n).aestronglyMeasurable, ?_⟩\n  suffices eLpNorm (fun x => approxOn f fmeas s y₀ h₀ n x - y₀) p μ < ⊤ by\n    have : Memℒp (fun x => approxOn f fmeas s y₀ h₀ n x - y₀) p μ :=\n      ⟨(approxOn f fmeas s y₀ h₀ n - const β y₀).aestronglyMeasurable, this⟩\n    convert eLpNorm_add_lt_top this hi₀\n    ext x\n    simp\n  have hf' : Memℒp (fun x => ‖f x - y₀‖) p μ := by\n    have h_meas : Measurable fun x => ‖f x - y₀‖ := by\n      simp only [← dist_eq_norm]\n      exact (continuous_id.dist continuous_const).measurable.comp fmeas\n    refine ⟨h_meas.aemeasurable.aestronglyMeasurable, ?_⟩\n    rw [eLpNorm_norm]\n    convert eLpNorm_add_lt_top hf hi₀.neg with x\n    simp [sub_eq_add_neg]\n  have : ∀ᵐ x ∂μ, ‖approxOn f fmeas s y₀ h₀ n x - y₀‖ ≤ ‖‖f x - y₀‖ + ‖f x - y₀‖‖ := by\n    filter_upwards with x\n    convert norm_approxOn_y₀_le fmeas h₀ x n using 1\n    rw [Real.norm_eq_abs, abs_of_nonneg]\n    positivity\n  calc\n    eLpNorm (fun x => approxOn f fmeas s y₀ h₀ n x - y₀) p μ ≤\n        eLpNorm (fun x => ‖f x - y₀‖ + ‖f x - y₀‖) p μ :=\n      eLpNorm_mono_ae this\n    _ < ⊤ := eLpNorm_add_lt_top hf' hf'\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_range_Lp_eLpNorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\np : ENNReal\ninst✝¹ : BorelSpace E\nf : β → E\nhp_ne_top : Ne p Top.top\nμ : MeasureTheory.Measure β\nfmeas : Measurable f\ninst✝ : TopologicalSpace.SeparableSpace ↑(Union.union (Set.range f) (Singleton.singleton 0))\nhf : LT.lt (MeasureTheory.eLpNorm f p μ) Top.top\n⊢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (⇑(MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ⋯ n)) f) p μ) Filter.atTop (nhds 0)","decl":"theorem tendsto_approxOn_range_Lp_eLpNorm [BorelSpace E] {f : β → E} (hp_ne_top : p ≠ ∞)\n    {μ : Measure β} (fmeas : Measurable f) [SeparableSpace (range f ∪ {0} : Set E)]\n    (hf : eLpNorm f p μ < ∞) :\n    Tendsto (fun n => eLpNorm (⇑(approxOn f fmeas (range f ∪ {0}) 0 (by simp) n) - f) p μ)\n      atTop (𝓝 0) := by\n  refine tendsto_approxOn_Lp_eLpNorm fmeas _ hp_ne_top ?_ ?_\n  · filter_upwards with x using subset_closure (by simp)\n  · simpa using hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.memℒp_approxOn_range","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\np : ENNReal\ninst✝¹ : BorelSpace E\nf : β → E\nμ : MeasureTheory.Measure β\nfmeas : Measurable f\ninst✝ : TopologicalSpace.SeparableSpace ↑(Union.union (Set.range f) (Singleton.singleton 0))\nhf : MeasureTheory.Memℒp f p μ\nn : Nat\n⊢ MeasureTheory.Memℒp (⇑(MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ⋯ n)) p μ","decl":"theorem memℒp_approxOn_range [BorelSpace E] {f : β → E} {μ : Measure β} (fmeas : Measurable f)\n    [SeparableSpace (range f ∪ {0} : Set E)] (hf : Memℒp f p μ) (n : ℕ) :\n    Memℒp (approxOn f fmeas (range f ∪ {0}) 0 (by simp) n) p μ :=\n  memℒp_approxOn fmeas hf (y₀ := 0) (by simp) Memℒp.zero n\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_range_Lp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\np : ENNReal\ninst✝¹ : BorelSpace E\nf : β → E\nhp : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\nμ : MeasureTheory.Measure β\nfmeas : Measurable f\ninst✝ : TopologicalSpace.SeparableSpace ↑(Union.union (Set.range f) (Singleton.singleton 0))\nhf : MeasureTheory.Memℒp f p μ\n⊢ Filter.Tendsto (fun n => MeasureTheory.Memℒp.toLp ⇑(MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ⋯ n) ⋯) Filter.atTop (nhds (MeasureTheory.Memℒp.toLp f hf))","decl":"theorem tendsto_approxOn_range_Lp [BorelSpace E] {f : β → E} [hp : Fact (1 ≤ p)] (hp_ne_top : p ≠ ∞)\n    {μ : Measure β} (fmeas : Measurable f) [SeparableSpace (range f ∪ {0} : Set E)]\n    (hf : Memℒp f p μ) :\n    Tendsto\n      (fun n =>\n        (memℒp_approxOn_range fmeas hf n).toLp (approxOn f fmeas (range f ∪ {0}) 0 (by simp) n))\n      atTop (𝓝 (hf.toLp f)) := by\n  simpa only [Lp.tendsto_Lp_iff_tendsto_ℒp''] using\n    tendsto_approxOn_range_Lp_eLpNorm hp_ne_top fmeas hf.2\n\n"}
{"name":"MeasureTheory.Memℒp.exists_simpleFunc_eLpNorm_sub_lt","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\ninst✝¹ : MeasurableSpace β\np : ENNReal\nE : Type u_7\ninst✝ : NormedAddCommGroup E\nf : β → E\nμ : MeasureTheory.Measure β\nhf : MeasureTheory.Memℒp f p μ\nhp_ne_top : Ne p Top.top\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun g => And (LT.lt (MeasureTheory.eLpNorm (HSub.hSub f ⇑g) p μ) ε) (MeasureTheory.Memℒp (⇑g) p μ)","decl":"/-- Any function in `ℒp` can be approximated by a simple function if `p < ∞`. -/\ntheorem _root_.MeasureTheory.Memℒp.exists_simpleFunc_eLpNorm_sub_lt {E : Type*}\n    [NormedAddCommGroup E] {f : β → E} {μ : Measure β} (hf : Memℒp f p μ) (hp_ne_top : p ≠ ∞)\n    {ε : ℝ≥0∞} (hε : ε ≠ 0) : ∃ g : β →ₛ E, eLpNorm (f - ⇑g) p μ < ε ∧ Memℒp g p μ := by\n  borelize E\n  let f' := hf.1.mk f\n  rsuffices ⟨g, hg, g_mem⟩ : ∃ g : β →ₛ E, eLpNorm (f' - ⇑g) p μ < ε ∧ Memℒp g p μ\n  · refine ⟨g, ?_, g_mem⟩\n    suffices eLpNorm (f - ⇑g) p μ = eLpNorm (f' - ⇑g) p μ by rwa [this]\n    apply eLpNorm_congr_ae\n    filter_upwards [hf.1.ae_eq_mk] with x hx\n    simpa only [Pi.sub_apply, sub_left_inj] using hx\n  have hf' : Memℒp f' p μ := hf.ae_eq hf.1.ae_eq_mk\n  have f'meas : Measurable f' := hf.1.measurable_mk\n  have : SeparableSpace (range f' ∪ {0} : Set E) :=\n    StronglyMeasurable.separableSpace_range_union_singleton hf.1.stronglyMeasurable_mk\n  rcases ((tendsto_approxOn_range_Lp_eLpNorm hp_ne_top f'meas hf'.2).eventually <|\n    gt_mem_nhds hε.bot_lt).exists with ⟨n, hn⟩\n  rw [← eLpNorm_neg, neg_sub] at hn\n  exact ⟨_, hn, memℒp_approxOn_range f'meas hf' _⟩\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_L1_enorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : OpensMeasurableSpace E\nf : β → E\nhf : Measurable f\ns : Set E\ny₀ : E\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nμ : MeasureTheory.Measure β\nhμ : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae μ)\nhi : MeasureTheory.HasFiniteIntegral (fun x => HSub.hSub (f x) y₀) μ\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral μ fun x => ENorm.enorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n) x) (f x))) Filter.atTop (nhds 0)","decl":"theorem tendsto_approxOn_L1_enorm [OpensMeasurableSpace E] {f : β → E} (hf : Measurable f)\n    {s : Set E} {y₀ : E} (h₀ : y₀ ∈ s) [SeparableSpace s] {μ : Measure β}\n    (hμ : ∀ᵐ x ∂μ, f x ∈ closure s) (hi : HasFiniteIntegral (fun x => f x - y₀) μ) :\n    Tendsto (fun n => ∫⁻ x, ‖approxOn f hf s y₀ h₀ n x - f x‖ₑ ∂μ) atTop (𝓝 0) := by\n  simpa [eLpNorm_one_eq_lintegral_enorm] using\n    tendsto_approxOn_Lp_eLpNorm hf h₀ one_ne_top hμ\n      (by simpa [eLpNorm_one_eq_lintegral_enorm] using hi)\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_L1_nnnorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : OpensMeasurableSpace E\nf : β → E\nhf : Measurable f\ns : Set E\ny₀ : E\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nμ : MeasureTheory.Measure β\nhμ : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae μ)\nhi : MeasureTheory.HasFiniteIntegral (fun x => HSub.hSub (f x) y₀) μ\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral μ fun x => ENorm.enorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f hf s y₀ h₀ n) x) (f x))) Filter.atTop (nhds 0)","decl":"@[deprecated (since := \"2025-01-21\")] alias tendsto_approxOn_L1_nnnorm := tendsto_approxOn_L1_enorm\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_approxOn","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : BorelSpace E\nf : β → E\nμ : MeasureTheory.Measure β\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f μ\ns : Set E\ny₀ : E\nh₀ : Membership.mem s y₀\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nhi₀ : MeasureTheory.Integrable (fun x => y₀) μ\nn : Nat\n⊢ MeasureTheory.Integrable (⇑(MeasureTheory.SimpleFunc.approxOn f fmeas s y₀ h₀ n)) μ","decl":"theorem integrable_approxOn [BorelSpace E] {f : β → E} {μ : Measure β} (fmeas : Measurable f)\n    (hf : Integrable f μ) {s : Set E} {y₀ : E} (h₀ : y₀ ∈ s) [SeparableSpace s]\n    (hi₀ : Integrable (fun _ => y₀) μ) (n : ℕ) : Integrable (approxOn f fmeas s y₀ h₀ n) μ := by\n  rw [← memℒp_one_iff_integrable] at hf hi₀ ⊢\n  exact memℒp_approxOn fmeas hf h₀ hi₀ n\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_range_L1_enorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : OpensMeasurableSpace E\nf : β → E\nμ : MeasureTheory.Measure β\ninst✝ : TopologicalSpace.SeparableSpace ↑(Union.union (Set.range f) (Singleton.singleton 0))\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f μ\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral μ fun x => ENorm.enorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ⋯ n) x) (f x))) Filter.atTop (nhds 0)","decl":"theorem tendsto_approxOn_range_L1_enorm [OpensMeasurableSpace E] {f : β → E} {μ : Measure β}\n    [SeparableSpace (range f ∪ {0} : Set E)] (fmeas : Measurable f) (hf : Integrable f μ) :\n    Tendsto (fun n => ∫⁻ x, ‖approxOn f fmeas (range f ∪ {0}) 0 (by simp) n x - f x‖ₑ ∂μ) atTop\n      (𝓝 0) := by\n  apply tendsto_approxOn_L1_enorm fmeas\n  · filter_upwards with x using subset_closure (by simp)\n  · simpa using hf.2\n\n"}
{"name":"MeasureTheory.SimpleFunc.tendsto_approxOn_range_L1_nnnorm","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : OpensMeasurableSpace E\nf : β → E\nμ : MeasureTheory.Measure β\ninst✝ : TopologicalSpace.SeparableSpace ↑(Union.union (Set.range f) (Singleton.singleton 0))\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f μ\n⊢ Filter.Tendsto (fun n => MeasureTheory.lintegral μ fun x => ENorm.enorm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ⋯ n) x) (f x))) Filter.atTop (nhds 0)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias tendsto_approxOn_range_L1_nnnorm := tendsto_approxOn_range_L1_enorm\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_approxOn_range","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"β : Type u_2\nE : Type u_4\ninst✝⁴ : MeasurableSpace β\ninst✝³ : MeasurableSpace E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : BorelSpace E\nf : β → E\nμ : MeasureTheory.Measure β\nfmeas : Measurable f\ninst✝ : TopologicalSpace.SeparableSpace ↑(Union.union (Set.range f) (Singleton.singleton 0))\nhf : MeasureTheory.Integrable f μ\nn : Nat\n⊢ MeasureTheory.Integrable (⇑(MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ⋯ n)) μ","decl":"theorem integrable_approxOn_range [BorelSpace E] {f : β → E} {μ : Measure β} (fmeas : Measurable f)\n    [SeparableSpace (range f ∪ {0} : Set E)] (hf : Integrable f μ) (n : ℕ) :\n    Integrable (approxOn f fmeas (range f ∪ {0}) 0 (by simp) n) μ :=\n  integrable_approxOn fmeas hf _ (integrable_zero _ _ _) n\n\n"}
{"name":"MeasureTheory.SimpleFunc.exists_forall_norm_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nF : Type u_5\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\nf : MeasureTheory.SimpleFunc α F\n⊢ Exists fun C => ∀ (x : α), LE.le (Norm.norm (f x)) C","decl":"theorem exists_forall_norm_le (f : α →ₛ F) : ∃ C, ∀ x, ‖f x‖ ≤ C :=\n  exists_forall_le (f.map fun x => ‖x‖)\n\n"}
{"name":"MeasureTheory.SimpleFunc.memℒp_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nf : MeasureTheory.SimpleFunc α E\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.Memℒp (⇑f) 0 μ","decl":"theorem memℒp_zero (f : α →ₛ E) (μ : Measure α) : Memℒp f 0 μ :=\n  memℒp_zero_iff_aestronglyMeasurable.mpr f.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.SimpleFunc.memℒp_top","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nf : MeasureTheory.SimpleFunc α E\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.Memℒp (⇑f) Top.top μ","decl":"theorem memℒp_top (f : α →ₛ E) (μ : Measure α) : Memℒp f ∞ μ :=\n  let ⟨C, hfC⟩ := f.exists_forall_norm_le\n  memℒp_top_of_bound f.aestronglyMeasurable C <| Eventually.of_forall hfC\n\n"}
{"name":"MeasureTheory.SimpleFunc.eLpNorm'_eq","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nF : Type u_5\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\np : Real\nf : MeasureTheory.SimpleFunc α F\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm' (⇑f) p μ) (HPow.hPow (f.range.sum fun y => HMul.hMul (HPow.hPow (ENorm.enorm y) p) (μ (Set.preimage (⇑f) (Singleton.singleton y)))) (HDiv.hDiv 1 p))","decl":"protected theorem eLpNorm'_eq {p : ℝ} (f : α →ₛ F) (μ : Measure α) :\n    eLpNorm' f p μ = (∑ y ∈ f.range, ‖y‖ₑ ^ p * μ (f ⁻¹' {y})) ^ (1 / p) := by\n  have h_map : (‖f ·‖ₑ ^ p) = f.map (‖·‖ₑ ^ p) := by simp; rfl\n  rw [eLpNorm'_eq_lintegral_enorm, h_map, lintegral_eq_lintegral, map_lintegral]\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_preimage_lt_top_of_memℒp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Memℒp (⇑f) p μ\ny : E\nhy_ne : Ne y 0\n⊢ LT.lt (μ (Set.preimage (⇑f) (Singleton.singleton y))) Top.top","decl":"theorem measure_preimage_lt_top_of_memℒp (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ∞) (f : α →ₛ E)\n    (hf : Memℒp f p μ) (y : E) (hy_ne : y ≠ 0) : μ (f ⁻¹' {y}) < ∞ := by\n  have hp_pos_real : 0 < p.toReal := ENNReal.toReal_pos hp_pos hp_ne_top\n  have hf_eLpNorm := Memℒp.eLpNorm_lt_top hf\n  rw [eLpNorm_eq_eLpNorm' hp_pos hp_ne_top, f.eLpNorm'_eq, one_div,\n    ← @ENNReal.lt_rpow_inv_iff _ _ p.toReal⁻¹ (by simp [hp_pos_real]),\n    @ENNReal.top_rpow_of_pos p.toReal⁻¹⁻¹ (by simp [hp_pos_real]),\n    ENNReal.sum_lt_top] at hf_eLpNorm\n  by_cases hyf : y ∈ f.range\n  swap\n  · suffices h_empty : f ⁻¹' {y} = ∅ by\n      rw [h_empty, measure_empty]; exact ENNReal.coe_lt_top\n    ext1 x\n    rw [Set.mem_preimage, Set.mem_singleton_iff, mem_empty_iff_false, iff_false]\n    refine fun hxy => hyf ?_\n    rw [mem_range, Set.mem_range]\n    exact ⟨x, hxy⟩\n  specialize hf_eLpNorm y hyf\n  rw [ENNReal.mul_lt_top_iff] at hf_eLpNorm\n  cases hf_eLpNorm with\n  | inl hf_eLpNorm => exact hf_eLpNorm.2\n  | inr hf_eLpNorm =>\n    cases hf_eLpNorm with\n    | inl hf_eLpNorm =>\n      refine absurd ?_ hy_ne\n      simpa [hp_pos_real] using hf_eLpNorm\n    | inr hf_eLpNorm => simp [hf_eLpNorm]\n\n"}
{"name":"MeasureTheory.SimpleFunc.memℒp_of_finite_measure_preimage","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\nf : MeasureTheory.SimpleFunc α E\nhf : ∀ (y : E), Ne y 0 → LT.lt (μ (Set.preimage (⇑f) (Singleton.singleton y))) Top.top\n⊢ MeasureTheory.Memℒp (⇑f) p μ","decl":"theorem memℒp_of_finite_measure_preimage (p : ℝ≥0∞) {f : α →ₛ E}\n    (hf : ∀ y, y ≠ 0 → μ (f ⁻¹' {y}) < ∞) : Memℒp f p μ := by\n  by_cases hp0 : p = 0\n  · rw [hp0, memℒp_zero_iff_aestronglyMeasurable]; exact f.aestronglyMeasurable\n  by_cases hp_top : p = ∞\n  · rw [hp_top]; exact memℒp_top f μ\n  refine ⟨f.aestronglyMeasurable, ?_⟩\n  rw [eLpNorm_eq_eLpNorm' hp0 hp_top, f.eLpNorm'_eq]\n  refine ENNReal.rpow_lt_top_of_nonneg (by simp) (ENNReal.sum_lt_top.mpr fun y _ => ?_).ne\n  by_cases hy0 : y = 0\n  · simp [hy0, ENNReal.toReal_pos hp0 hp_top]\n  · refine ENNReal.mul_lt_top ?_ (hf y hy0)\n    exact ENNReal.rpow_lt_top_of_nonneg ENNReal.toReal_nonneg ENNReal.coe_ne_top\n\n"}
{"name":"MeasureTheory.SimpleFunc.memℒp_iff","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\nf : MeasureTheory.SimpleFunc α E\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ Iff (MeasureTheory.Memℒp (⇑f) p μ) (∀ (y : E), Ne y 0 → LT.lt (μ (Set.preimage (⇑f) (Singleton.singleton y))) Top.top)","decl":"theorem memℒp_iff {f : α →ₛ E} (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ∞) :\n    Memℒp f p μ ↔ ∀ y, y ≠ 0 → μ (f ⁻¹' {y}) < ∞ :=\n  ⟨fun h => measure_preimage_lt_top_of_memℒp hp_pos hp_ne_top f h, fun h =>\n    memℒp_of_finite_measure_preimage p h⟩\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_iff","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\n⊢ Iff (MeasureTheory.Integrable (⇑f) μ) (∀ (y : E), Ne y 0 → LT.lt (μ (Set.preimage (⇑f) (Singleton.singleton y))) Top.top)","decl":"theorem integrable_iff {f : α →ₛ E} : Integrable f μ ↔ ∀ y, y ≠ 0 → μ (f ⁻¹' {y}) < ∞ :=\n  memℒp_one_iff_integrable.symm.trans <| memℒp_iff one_ne_zero ENNReal.coe_ne_top\n\n"}
{"name":"MeasureTheory.SimpleFunc.memℒp_iff_integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\nf : MeasureTheory.SimpleFunc α E\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ Iff (MeasureTheory.Memℒp (⇑f) p μ) (MeasureTheory.Integrable (⇑f) μ)","decl":"theorem memℒp_iff_integrable {f : α →ₛ E} (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ∞) :\n    Memℒp f p μ ↔ Integrable f μ :=\n  (memℒp_iff hp_pos hp_ne_top).trans integrable_iff.symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.memℒp_iff_finMeasSupp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\nf : MeasureTheory.SimpleFunc α E\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ Iff (MeasureTheory.Memℒp (⇑f) p μ) (f.FinMeasSupp μ)","decl":"theorem memℒp_iff_finMeasSupp {f : α →ₛ E} (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ∞) :\n    Memℒp f p μ ↔ f.FinMeasSupp μ :=\n  (memℒp_iff hp_pos hp_ne_top).trans finMeasSupp_iff.symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_iff_finMeasSupp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\n⊢ Iff (MeasureTheory.Integrable (⇑f) μ) (f.FinMeasSupp μ)","decl":"theorem integrable_iff_finMeasSupp {f : α →ₛ E} : Integrable f μ ↔ f.FinMeasSupp μ :=\n  integrable_iff.trans finMeasSupp_iff.symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.FinMeasSupp.integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\nh : f.FinMeasSupp μ\n⊢ MeasureTheory.Integrable (⇑f) μ","decl":"theorem FinMeasSupp.integrable {f : α →ₛ E} (h : f.FinMeasSupp μ) : Integrable f μ :=\n  integrable_iff_finMeasSupp.2 h\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_pair","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\nF : Type u_5\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\ng : MeasureTheory.SimpleFunc α F\na✝¹ : MeasureTheory.Integrable (⇑f) μ\na✝ : MeasureTheory.Integrable (⇑g) μ\n⊢ MeasureTheory.Integrable (⇑(f.pair g)) μ","decl":"theorem integrable_pair {f : α →ₛ E} {g : α →ₛ F} :\n    Integrable f μ → Integrable g μ → Integrable (pair f g) μ := by\n  simpa only [integrable_iff_finMeasSupp] using FinMeasSupp.pair\n\n"}
{"name":"MeasureTheory.SimpleFunc.memℒp_of_isFiniteMeasure","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\nf : MeasureTheory.SimpleFunc α E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.Memℒp (⇑f) p μ","decl":"theorem memℒp_of_isFiniteMeasure (f : α →ₛ E) (p : ℝ≥0∞) (μ : Measure α) [IsFiniteMeasure μ] :\n    Memℒp f p μ :=\n  let ⟨C, hfC⟩ := f.exists_forall_norm_le\n  Memℒp.of_bound f.aestronglyMeasurable C <| Eventually.of_forall hfC\n\n"}
{"name":"MeasureTheory.SimpleFunc.integrable_of_isFiniteMeasure","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : MeasureTheory.SimpleFunc α E\n⊢ MeasureTheory.Integrable (⇑f) μ","decl":"@[fun_prop]\ntheorem integrable_of_isFiniteMeasure [IsFiniteMeasure μ] (f : α →ₛ E) : Integrable f μ :=\n  memℒp_one_iff_integrable.mp (f.memℒp_of_isFiniteMeasure 1 μ)\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_preimage_lt_top_of_integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Integrable (⇑f) μ\nx : E\nhx : Ne x 0\n⊢ LT.lt (μ (Set.preimage (⇑f) (Singleton.singleton x))) Top.top","decl":"theorem measure_preimage_lt_top_of_integrable (f : α →ₛ E) (hf : Integrable f μ) {x : E}\n    (hx : x ≠ 0) : μ (f ⁻¹' {x}) < ∞ :=\n  integrable_iff.mp hf x hx\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_support_lt_top_of_memℒp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Memℒp (⇑f) p μ\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ LT.lt (μ (Function.support ⇑f)) Top.top","decl":"theorem measure_support_lt_top_of_memℒp (f : α →ₛ E) (hf : Memℒp f p μ) (hp_ne_zero : p ≠ 0)\n    (hp_ne_top : p ≠ ∞) : μ (support f) < ∞ :=\n  f.measure_support_lt_top ((memℒp_iff hp_ne_zero hp_ne_top).mp hf)\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_support_lt_top_of_integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Integrable (⇑f) μ\n⊢ LT.lt (μ (Function.support ⇑f)) Top.top","decl":"theorem measure_support_lt_top_of_integrable (f : α →ₛ E) (hf : Integrable f μ) :\n    μ (support f) < ∞ :=\n  f.measure_support_lt_top (integrable_iff.mp hf)\n\n"}
{"name":"MeasureTheory.SimpleFunc.measure_lt_top_of_memℒp_indicator","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\nc : E\nhc : Ne c 0\ns : Set α\nhs : MeasurableSet s\nhcs : MeasureTheory.Memℒp (⇑(MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const α c) (MeasureTheory.SimpleFunc.const α 0))) p μ\n⊢ LT.lt (μ s) Top.top","decl":"theorem measure_lt_top_of_memℒp_indicator (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ∞) {c : E} (hc : c ≠ 0)\n    {s : Set α} (hs : MeasurableSet s) (hcs : Memℒp ((const α c).piecewise s hs (const α 0)) p μ) :\n    μ s < ⊤ := by\n  have : Function.support (const α c) = Set.univ := Function.support_const hc\n  simpa only [memℒp_iff_finMeasSupp hp_pos hp_ne_top, finMeasSupp_iff_support,\n    support_indicator, Set.inter_univ, this] using hcs\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.eq'","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\na✝ : Eq ↑↑f ↑↑g\n⊢ Eq f g","decl":"protected theorem eq' {f g : Lp.simpleFunc E p μ} : (f : α →ₘ[μ] E) = (g : α →ₘ[μ] E) → f = g :=\n  Subtype.eq ∘ Subtype.eq\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coe_smul","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\n𝕜 : Type u_6\ninst✝⁴ : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nc : 𝕜\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ Eq (↑(HSMul.hSMul c f)) (HSMul.hSMul c ↑f)","decl":"@[simp, norm_cast]\ntheorem coe_smul (c : 𝕜) (f : Lp.simpleFunc E p μ) :\n    ((c • f : Lp.simpleFunc E p μ) : Lp E p μ) = c • (f : Lp E p μ) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.boundedSMul","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\n𝕜 : Type u_6\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝³ : NormedRing 𝕜\ninst✝² : Module 𝕜 E\ninst✝¹ : BoundedSMul 𝕜 E\ninst✝ : Fact (LE.le 1 p)\n⊢ BoundedSMul 𝕜 (Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x)","decl":"/-- If `E` is a normed space, `Lp.simpleFunc E p μ` is a normed space. Not declared as an\ninstance as it is (as of writing) used only in the construction of the Bochner integral. -/\nprotected theorem boundedSMul [Fact (1 ≤ p)] : BoundedSMul 𝕜 (Lp.simpleFunc E p μ) :=\n  BoundedSMul.of_norm_smul_le fun r f => (norm_smul_le r (f : Lp E p μ) :)\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_eq_toLp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Memℒp (⇑f) p μ\n⊢ Eq (↑(MeasureTheory.Lp.simpleFunc.toLp f hf)) (MeasureTheory.Memℒp.toLp (⇑f) hf)","decl":"theorem toLp_eq_toLp (f : α →ₛ E) (hf : Memℒp f p μ) : (toLp f hf : Lp E p μ) = hf.toLp f :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_eq_mk","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Memℒp (⇑f) p μ\n⊢ Eq (↑↑(MeasureTheory.Lp.simpleFunc.toLp f hf)) (MeasureTheory.AEEqFun.mk ⇑f ⋯)","decl":"theorem toLp_eq_mk (f : α →ₛ E) (hf : Memℒp f p μ) :\n    (toLp f hf : α →ₘ[μ] E) = AEEqFun.mk f f.aestronglyMeasurable :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Lp.simpleFunc.toLp 0 ⋯) 0","decl":"theorem toLp_zero : toLp (0 : α →ₛ E) Memℒp.zero = (0 : Lp.simpleFunc E p μ) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_add","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf g : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Memℒp (⇑f) p μ\nhg : MeasureTheory.Memℒp (⇑g) p μ\n⊢ Eq (MeasureTheory.Lp.simpleFunc.toLp (HAdd.hAdd f g) ⋯) (HAdd.hAdd (MeasureTheory.Lp.simpleFunc.toLp f hf) (MeasureTheory.Lp.simpleFunc.toLp g hg))","decl":"theorem toLp_add (f g : α →ₛ E) (hf : Memℒp f p μ) (hg : Memℒp g p μ) :\n    toLp (f + g) (hf.add hg) = toLp f hf + toLp g hg :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_neg","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Memℒp (⇑f) p μ\n⊢ Eq (MeasureTheory.Lp.simpleFunc.toLp (Neg.neg f) ⋯) (Neg.neg (MeasureTheory.Lp.simpleFunc.toLp f hf))","decl":"theorem toLp_neg (f : α →ₛ E) (hf : Memℒp f p μ) : toLp (-f) hf.neg = -toLp f hf :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_sub","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf g : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Memℒp (⇑f) p μ\nhg : MeasureTheory.Memℒp (⇑g) p μ\n⊢ Eq (MeasureTheory.Lp.simpleFunc.toLp (HSub.hSub f g) ⋯) (HSub.hSub (MeasureTheory.Lp.simpleFunc.toLp f hf) (MeasureTheory.Lp.simpleFunc.toLp g hg))","decl":"theorem toLp_sub (f g : α →ₛ E) (hf : Memℒp f p μ) (hg : Memℒp g p μ) :\n    toLp (f - g) (hf.sub hg) = toLp f hf - toLp g hg := by\n  simp only [sub_eq_add_neg, ← toLp_neg, ← toLp_add]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_smul","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\n𝕜 : Type u_6\ninst✝⁴ : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Memℒp (⇑f) p μ\nc : 𝕜\n⊢ Eq (MeasureTheory.Lp.simpleFunc.toLp (HSMul.hSMul c f) ⋯) (HSMul.hSMul c (MeasureTheory.Lp.simpleFunc.toLp f hf))","decl":"theorem toLp_smul (f : α →ₛ E) (hf : Memℒp f p μ) (c : 𝕜) :\n    toLp (c • f) (hf.const_smul c) = c • toLp f hf :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.norm_toLp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Memℒp (⇑f) p μ\n⊢ Eq (Norm.norm (MeasureTheory.Lp.simpleFunc.toLp f hf)) (MeasureTheory.eLpNorm (⇑f) p μ).toReal","decl":"nonrec theorem norm_toLp [Fact (1 ≤ p)] (f : α →ₛ E) (hf : Memℒp f p μ) :\n    ‖toLp f hf‖ = ENNReal.toReal (eLpNorm f p μ) :=\n  norm_toLp f hf\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.measurable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ Measurable ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)","decl":"/-- `(toSimpleFunc f)` is measurable. -/\n@[measurability]\nprotected theorem measurable [MeasurableSpace E] (f : Lp.simpleFunc E p μ) :\n    Measurable (toSimpleFunc f) :=\n  (toSimpleFunc f).measurable\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ MeasureTheory.StronglyMeasurable ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)","decl":"protected theorem stronglyMeasurable (f : Lp.simpleFunc E p μ) :\n    StronglyMeasurable (toSimpleFunc f) :=\n  (toSimpleFunc f).stronglyMeasurable\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.aemeasurable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : MeasurableSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ AEMeasurable (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) μ","decl":"@[measurability]\nprotected theorem aemeasurable [MeasurableSpace E] (f : Lp.simpleFunc E p μ) :\n    AEMeasurable (toSimpleFunc f) μ :=\n  (simpleFunc.measurable f).aemeasurable\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ MeasureTheory.AEStronglyMeasurable (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) μ","decl":"protected theorem aestronglyMeasurable (f : Lp.simpleFunc E p μ) :\n    AEStronglyMeasurable (toSimpleFunc f) μ :=\n  (simpleFunc.stronglyMeasurable f).aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toSimpleFunc_eq_toFun","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ↑↑↑f","decl":"theorem toSimpleFunc_eq_toFun (f : Lp.simpleFunc E p μ) : toSimpleFunc f =ᵐ[μ] f :=\n  show ⇑(toSimpleFunc f) =ᵐ[μ] ⇑(f : α →ₘ[μ] E) by\n    convert (AEEqFun.coeFn_mk (toSimpleFunc f)\n          (toSimpleFunc f).aestronglyMeasurable).symm using 2\n    exact (Classical.choose_spec f.2).symm\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.memℒp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ MeasureTheory.Memℒp (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) p μ","decl":"/-- `toSimpleFunc f` satisfies the predicate `Memℒp`. -/\nprotected theorem memℒp (f : Lp.simpleFunc E p μ) : Memℒp (toSimpleFunc f) p μ :=\n  Memℒp.ae_eq (toSimpleFunc_eq_toFun f).symm <| mem_Lp_iff_memℒp.mp (f : Lp E p μ).2\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toLp_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ Eq (MeasureTheory.Lp.simpleFunc.toLp (MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ⋯) f","decl":"theorem toLp_toSimpleFunc (f : Lp.simpleFunc E p μ) :\n    toLp (toSimpleFunc f) (simpleFunc.memℒp f) = f :=\n  simpleFunc.eq' (Classical.choose_spec f.2)\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toSimpleFunc_toLp","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\nhfi : MeasureTheory.Memℒp (⇑f) p μ\n⊢ (MeasureTheory.ae μ).EventuallyEq ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc (MeasureTheory.Lp.simpleFunc.toLp f hfi)) ⇑f","decl":"theorem toSimpleFunc_toLp (f : α →ₛ E) (hfi : Memℒp f p μ) : toSimpleFunc (toLp f hfi) =ᵐ[μ] f := by\n  rw [← AEEqFun.mk_eq_mk]; exact Classical.choose_spec (toLp f hfi).2\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.zero_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ (MeasureTheory.ae μ).EventuallyEq (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc 0)) 0","decl":"theorem zero_toSimpleFunc : toSimpleFunc (0 : Lp.simpleFunc E p μ) =ᵐ[μ] 0 := by\n  filter_upwards [toSimpleFunc_eq_toFun (0 : Lp.simpleFunc E p μ),\n    Lp.coeFn_zero E 1 μ] with _ h₁ _\n  rwa [h₁]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.add_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc (HAdd.hAdd f g))) (HAdd.hAdd ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc g))","decl":"theorem add_toSimpleFunc (f g : Lp.simpleFunc E p μ) :\n    toSimpleFunc (f + g) =ᵐ[μ] toSimpleFunc f + toSimpleFunc g := by\n  filter_upwards [toSimpleFunc_eq_toFun (f + g), toSimpleFunc_eq_toFun f,\n    toSimpleFunc_eq_toFun g, Lp.coeFn_add (f : Lp E p μ) g] with _\n  simp only [AddSubgroup.coe_add, Pi.add_apply]\n  iterate 4 intro h; rw [h]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.neg_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc (Neg.neg f))) (Neg.neg ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f))","decl":"theorem neg_toSimpleFunc (f : Lp.simpleFunc E p μ) : toSimpleFunc (-f) =ᵐ[μ] -toSimpleFunc f := by\n  filter_upwards [toSimpleFunc_eq_toFun (-f), toSimpleFunc_eq_toFun f,\n    Lp.coeFn_neg (f : Lp E p μ)] with _\n  simp only [Pi.neg_apply, AddSubgroup.coe_neg]\n  repeat intro h; rw [h]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.sub_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc (HSub.hSub f g))) (HSub.hSub ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc g))","decl":"theorem sub_toSimpleFunc (f g : Lp.simpleFunc E p μ) :\n    toSimpleFunc (f - g) =ᵐ[μ] toSimpleFunc f - toSimpleFunc g := by\n  filter_upwards [toSimpleFunc_eq_toFun (f - g), toSimpleFunc_eq_toFun f,\n    toSimpleFunc_eq_toFun g, Lp.coeFn_sub (f : Lp E p μ) g] with _\n  simp only [AddSubgroup.coe_sub, Pi.sub_apply]\n  repeat' intro h; rw [h]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.smul_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\n𝕜 : Type u_6\ninst✝⁴ : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nk : 𝕜\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ (MeasureTheory.ae μ).EventuallyEq (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc (HSMul.hSMul k f))) (HSMul.hSMul k ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f))","decl":"theorem smul_toSimpleFunc (k : 𝕜) (f : Lp.simpleFunc E p μ) :\n    toSimpleFunc (k • f) =ᵐ[μ] k • ⇑(toSimpleFunc f) := by\n  filter_upwards [toSimpleFunc_eq_toFun (k • f), toSimpleFunc_eq_toFun f,\n    Lp.coeFn_smul k (f : Lp E p μ)] with _\n  simp only [Pi.smul_apply, coe_smul]\n  repeat intro h; rw [h]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.norm_toSimpleFunc","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ Eq (Norm.norm f) (MeasureTheory.eLpNorm (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) p μ).toReal","decl":"theorem norm_toSimpleFunc [Fact (1 ≤ p)] (f : Lp.simpleFunc E p μ) :\n    ‖f‖ = ENNReal.toReal (eLpNorm (toSimpleFunc f) p μ) := by\n  simpa [toLp_toSimpleFunc] using norm_toLp (toSimpleFunc f) (simpleFunc.memℒp f)\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coe_indicatorConst","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\n⊢ Eq (↑(MeasureTheory.Lp.simpleFunc.indicatorConst p hs hμs c)) (MeasureTheory.indicatorConstLp p hs hμs c)","decl":"@[simp]\ntheorem coe_indicatorConst {s : Set α} (hs : MeasurableSet s) (hμs : μ s ≠ ∞) (c : E) :\n    (↑(indicatorConst p hs hμs c) : Lp E p μ) = indicatorConstLp p hs hμs c :=\n  rfl\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.toSimpleFunc_indicatorConst","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\n⊢ (MeasureTheory.ae μ).EventuallyEq ⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc (MeasureTheory.Lp.simpleFunc.indicatorConst p hs hμs c)) ⇑(MeasureTheory.SimpleFunc.piecewise s hs (MeasureTheory.SimpleFunc.const α c) (MeasureTheory.SimpleFunc.const α 0))","decl":"theorem toSimpleFunc_indicatorConst {s : Set α} (hs : MeasurableSet s) (hμs : μ s ≠ ∞) (c : E) :\n    toSimpleFunc (indicatorConst p hs hμs c) =ᵐ[μ]\n      (SimpleFunc.const _ c).piecewise s hs (SimpleFunc.const _ 0) :=\n  Lp.simpleFunc.toSimpleFunc_toLp _ _\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.induction","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nhp_pos : Ne p 0\nhp_ne_top : Ne p Top.top\nP : (Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x) → Prop\nh_ind : ∀ (c : E) {s : Set α} (hs : MeasurableSet s) (hμs : LT.lt (μ s) Top.top), P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs ⋯ c)\nh_add : ∀ ⦃f g : MeasureTheory.SimpleFunc α E⦄ (hf : MeasureTheory.Memℒp (⇑f) p μ) (hg : MeasureTheory.Memℒp (⇑g) p μ), Disjoint (Function.support ⇑f) (Function.support ⇑g) → P (MeasureTheory.Lp.simpleFunc.toLp f hf) → P (MeasureTheory.Lp.simpleFunc.toLp g hg) → P (HAdd.hAdd (MeasureTheory.Lp.simpleFunc.toLp f hf) (MeasureTheory.Lp.simpleFunc.toLp g hg))\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E p μ) x\n⊢ P f","decl":"/-- To prove something for an arbitrary `Lp` simple function, with `0 < p < ∞`, it suffices to show\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\nsets and is closed under addition (of functions with disjoint support). -/\n@[elab_as_elim]\nprotected theorem induction (hp_pos : p ≠ 0) (hp_ne_top : p ≠ ∞) {P : Lp.simpleFunc E p μ → Prop}\n    (h_ind :\n      ∀ (c : E) {s : Set α} (hs : MeasurableSet s) (hμs : μ s < ∞),\n        P (Lp.simpleFunc.indicatorConst p hs hμs.ne c))\n    (h_add :\n      ∀ ⦃f g : α →ₛ E⦄,\n        ∀ hf : Memℒp f p μ,\n          ∀ hg : Memℒp g p μ,\n            Disjoint (support f) (support g) →\n              P (Lp.simpleFunc.toLp f hf) →\n                P (Lp.simpleFunc.toLp g hg) → P (Lp.simpleFunc.toLp f hf + Lp.simpleFunc.toLp g hg))\n    (f : Lp.simpleFunc E p μ) : P f := by\n  suffices ∀ f : α →ₛ E, ∀ hf : Memℒp f p μ, P (toLp f hf) by\n    rw [← toLp_toSimpleFunc f]\n    apply this\n  clear f\n  apply SimpleFunc.induction\n  · intro c s hs hf\n    by_cases hc : c = 0\n    · convert h_ind 0 MeasurableSet.empty (by simp) using 1\n      ext1\n      simp [hc]\n    exact h_ind c hs (SimpleFunc.measure_lt_top_of_memℒp_indicator hp_pos hp_ne_top hc hs hf)\n  · intro f g hfg hf hg hfg'\n    obtain ⟨hf', hg'⟩ : Memℒp f p μ ∧ Memℒp g p μ :=\n      (memℒp_add_of_disjoint hfg f.stronglyMeasurable g.stronglyMeasurable).mp hfg'\n    exact h_add hf' hg' hfg (hf hf') (hg hg')\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.uniformContinuous","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\n⊢ UniformContinuous Subtype.val","decl":"protected theorem uniformContinuous : UniformContinuous ((↑) : Lp.simpleFunc E p μ → Lp E p μ) :=\n  uniformContinuous_comap\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.isUniformEmbedding","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\n⊢ IsUniformEmbedding Subtype.val","decl":"lemma isUniformEmbedding : IsUniformEmbedding ((↑) : Lp.simpleFunc E p μ → Lp E p μ) :=\n  isUniformEmbedding_comap Subtype.val_injective\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.uniformEmbedding","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\n⊢ IsUniformEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-01\")] alias uniformEmbedding := isUniformEmbedding\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.isUniformInducing","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\n⊢ IsUniformInducing Subtype.val","decl":"theorem isUniformInducing : IsUniformInducing ((↑) : Lp.simpleFunc E p μ → Lp E p μ) :=\n  simpleFunc.isUniformEmbedding.isUniformInducing\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.uniformInducing","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\n⊢ IsUniformInducing Subtype.val","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing := isUniformInducing\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.isDenseEmbedding","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n⊢ IsDenseEmbedding Subtype.val","decl":"lemma isDenseEmbedding (hp_ne_top : p ≠ ∞) :\n    IsDenseEmbedding ((↑) : Lp.simpleFunc E p μ → Lp E p μ) := by\n  borelize E\n  apply simpleFunc.isUniformEmbedding.isDenseEmbedding\n  intro f\n  rw [mem_closure_iff_seq_limit]\n  have hfi' : Memℒp f p μ := Lp.memℒp f\n  haveI : SeparableSpace (range f ∪ {0} : Set E) :=\n    (Lp.stronglyMeasurable f).separableSpace_range_union_singleton\n  refine\n    ⟨fun n =>\n      toLp\n        (SimpleFunc.approxOn f (Lp.stronglyMeasurable f).measurable (range f ∪ {0}) 0 _ n)\n        (SimpleFunc.memℒp_approxOn_range (Lp.stronglyMeasurable f).measurable hfi' n),\n      fun n => mem_range_self _, ?_⟩\n  convert SimpleFunc.tendsto_approxOn_range_Lp hp_ne_top (Lp.stronglyMeasurable f).measurable hfi'\n  rw [toLp_coeFn f (Lp.memℒp f)]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.denseEmbedding","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n⊢ IsDenseEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-09-30\")]\nalias denseEmbedding := isDenseEmbedding\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.isDenseInducing","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n⊢ IsDenseInducing Subtype.val","decl":"protected theorem isDenseInducing (hp_ne_top : p ≠ ∞) :\n    IsDenseInducing ((↑) : Lp.simpleFunc E p μ → Lp E p μ) :=\n  (simpleFunc.isDenseEmbedding hp_ne_top).isDenseInducing\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.denseRange","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n⊢ DenseRange Subtype.val","decl":"protected theorem denseRange (hp_ne_top : p ≠ ∞) :\n    DenseRange ((↑) : Lp.simpleFunc E p μ → Lp E p μ) :=\n  (simpleFunc.isDenseInducing hp_ne_top).dense\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.dense","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n⊢ Dense ↑(MeasureTheory.Lp.simpleFunc E p μ)","decl":"protected theorem dense (hp_ne_top : p ≠ ∞) : Dense (Lp.simpleFunc E p μ : Set (Lp E p μ)) := by\n  simpa only [denseRange_subtype_val] using simpleFunc.denseRange (E := E) (μ := μ) hp_ne_top\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coeFn_le","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nG : Type u_7\ninst✝ : NormedLatticeAddCommGroup G\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G p μ) x\n⊢ Iff ((MeasureTheory.ae μ).EventuallyLE ↑↑↑f ↑↑↑g) (LE.le f g)","decl":"theorem coeFn_le (f g : Lp.simpleFunc G p μ) : (f : α → G) ≤ᵐ[μ] g ↔ f ≤ g := by\n  rw [← Subtype.coe_le_coe, ← Lp.coeFn_le]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.instAddLeftMono","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nG : Type u_7\ninst✝ : NormedLatticeAddCommGroup G\n⊢ AddLeftMono (Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G p μ) x)","decl":"instance instAddLeftMono : AddLeftMono (Lp.simpleFunc G p μ) := by\n  refine ⟨fun f g₁ g₂ hg₁₂ => ?_⟩\n  exact add_le_add_left hg₁₂ f\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coeFn_zero","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nG : Type u_7\ninst✝ : NormedLatticeAddCommGroup G\n⊢ (MeasureTheory.ae μ).EventuallyEq (↑↑↑0) 0","decl":"theorem coeFn_zero : (0 : Lp.simpleFunc G p μ) =ᵐ[μ] (0 : α → G) :=\n  Lp.coeFn_zero _ _ _\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.coeFn_nonneg","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nG : Type u_7\ninst✝ : NormedLatticeAddCommGroup G\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G p μ) x\n⊢ Iff ((MeasureTheory.ae μ).EventuallyLE 0 ↑↑↑f) (LE.le 0 f)","decl":"theorem coeFn_nonneg (f : Lp.simpleFunc G p μ) : (0 : α → G) ≤ᵐ[μ] f ↔ 0 ≤ f := by\n  rw [← Subtype.coe_le_coe, Lp.coeFn_nonneg, AddSubmonoid.coe_zero]\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.exists_simpleFunc_nonneg_ae_eq","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nG : Type u_7\ninst✝ : NormedLatticeAddCommGroup G\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc G p μ) x\nhf : LE.le 0 f\n⊢ Exists fun f' => And (LE.le 0 f') ((MeasureTheory.ae μ).EventuallyEq ↑↑↑f ⇑f')","decl":"theorem exists_simpleFunc_nonneg_ae_eq {f : Lp.simpleFunc G p μ} (hf : 0 ≤ f) :\n    ∃ f' : α →ₛ G, 0 ≤ f' ∧ f =ᵐ[μ] f' := by\n  rcases f with ⟨⟨f, hp⟩, g, (rfl : _ = f)⟩\n  change 0 ≤ᵐ[μ] g at hf\n  refine ⟨g ⊔ 0, le_sup_right, (AEEqFun.coeFn_mk _ _).trans ?_⟩\n  exact hf.mono fun x hx ↦ (sup_of_le_left hx).symm\n\n"}
{"name":"MeasureTheory.Lp.simpleFunc.denseRange_coeSimpleFuncNonnegToLpNonneg","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nG : Type u_7\ninst✝ : NormedLatticeAddCommGroup G\nhp : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\n⊢ DenseRange (MeasureTheory.Lp.simpleFunc.coeSimpleFuncNonnegToLpNonneg p μ G)","decl":"theorem denseRange_coeSimpleFuncNonnegToLpNonneg [hp : Fact (1 ≤ p)] (hp_ne_top : p ≠ ∞) :\n    DenseRange (coeSimpleFuncNonnegToLpNonneg p μ G) := fun g ↦ by\n  borelize G\n  rw [mem_closure_iff_seq_limit]\n  have hg_memℒp : Memℒp (g : α → G) p μ := Lp.memℒp (g : Lp G p μ)\n  have zero_mem : (0 : G) ∈ (range (g : α → G) ∪ {0} : Set G) ∩ { y | 0 ≤ y } := by\n    simp only [union_singleton, mem_inter_iff, mem_insert_iff, eq_self_iff_true, true_or,\n      mem_setOf_eq, le_refl, and_self_iff]\n  have : SeparableSpace ((range (g : α → G) ∪ {0}) ∩ { y | 0 ≤ y } : Set G) := by\n    apply IsSeparable.separableSpace\n    apply IsSeparable.mono _ Set.inter_subset_left\n    exact\n      (Lp.stronglyMeasurable (g : Lp G p μ)).isSeparable_range.union\n        (finite_singleton _).isSeparable\n  have g_meas : Measurable (g : α → G) := (Lp.stronglyMeasurable (g : Lp G p μ)).measurable\n  let x n := SimpleFunc.approxOn (g : α → G) g_meas\n    ((range (g : α → G) ∪ {0}) ∩ { y | 0 ≤ y }) 0 zero_mem n\n  have hx_nonneg : ∀ n, 0 ≤ x n := by\n    intro n a\n    change x n a ∈ { y : G | 0 ≤ y }\n    have A : (range (g : α → G) ∪ {0} : Set G) ∩ { y | 0 ≤ y } ⊆ { y | 0 ≤ y } :=\n      inter_subset_right\n    apply A\n    exact SimpleFunc.approxOn_mem g_meas _ n a\n  have hx_memℒp : ∀ n, Memℒp (x n) p μ :=\n    SimpleFunc.memℒp_approxOn _ hg_memℒp _ ⟨aestronglyMeasurable_const, by simp⟩\n  have h_toLp := fun n => Memℒp.coeFn_toLp (hx_memℒp n)\n  have hx_nonneg_Lp : ∀ n, 0 ≤ toLp (x n) (hx_memℒp n) := by\n    intro n\n    rw [← Lp.simpleFunc.coeFn_le, Lp.simpleFunc.toLp_eq_toLp]\n    filter_upwards [Lp.simpleFunc.coeFn_zero p μ G, h_toLp n] with a ha0 ha_toLp\n    rw [ha0, ha_toLp]\n    exact hx_nonneg n a\n  have hx_tendsto :\n      Tendsto (fun n : ℕ => eLpNorm ((x n : α → G) - (g : α → G)) p μ) atTop (𝓝 0) := by\n    apply SimpleFunc.tendsto_approxOn_Lp_eLpNorm g_meas zero_mem hp_ne_top\n    · have hg_nonneg : (0 : α → G) ≤ᵐ[μ] g := (Lp.coeFn_nonneg _).mpr g.2\n      refine hg_nonneg.mono fun a ha => subset_closure ?_\n      simpa using ha\n    · simp_rw [sub_zero]; exact hg_memℒp.eLpNorm_lt_top\n  refine\n    ⟨fun n =>\n      (coeSimpleFuncNonnegToLpNonneg p μ G) ⟨toLp (x n) (hx_memℒp n), hx_nonneg_Lp n⟩,\n      fun n => mem_range_self _, ?_⟩\n  suffices Tendsto (fun n : ℕ => (toLp (x n) (hx_memℒp n) : Lp G p μ)) atTop (𝓝 (g : Lp G p μ)) by\n    rw [tendsto_iff_dist_tendsto_zero] at this ⊢\n    simp_rw [Subtype.dist_eq]\n    exact this\n  rw [Lp.tendsto_Lp_iff_tendsto_ℒp']\n  refine Filter.Tendsto.congr (fun n => eLpNorm_congr_ae (EventuallyEq.sub ?_ ?_)) hx_tendsto\n  · symm\n    rw [Lp.simpleFunc.toLp_eq_toLp]\n    exact h_toLp n\n  · rfl\n\n"}
{"name":"MeasureTheory.Lp.induction","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\n_i : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\nP : (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x) → Prop\nh_ind : ∀ (c : E) {s : Set α} (hs : MeasurableSet s) (hμs : LT.lt (μ s) Top.top), P ↑(MeasureTheory.Lp.simpleFunc.indicatorConst p hs ⋯ c)\nh_add : ∀ ⦃f g : α → E⦄ (hf : MeasureTheory.Memℒp f p μ) (hg : MeasureTheory.Memℒp g p μ), Disjoint (Function.support f) (Function.support g) → P (MeasureTheory.Memℒp.toLp f hf) → P (MeasureTheory.Memℒp.toLp g hg) → P (HAdd.hAdd (MeasureTheory.Memℒp.toLp f hf) (MeasureTheory.Memℒp.toLp g hg))\nh_closed : IsClosed (setOf fun f => P f)\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ P f","decl":"/-- To prove something for an arbitrary `Lp` function in a second countable Borel normed group, it\nsuffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in `Lp` for which the property holds is closed.\n-/\n@[elab_as_elim]\ntheorem Lp.induction [_i : Fact (1 ≤ p)] (hp_ne_top : p ≠ ∞) (P : Lp E p μ → Prop)\n    (h_ind : ∀ (c : E) {s : Set α} (hs : MeasurableSet s) (hμs : μ s < ∞),\n      P (Lp.simpleFunc.indicatorConst p hs hμs.ne c))\n    (h_add : ∀ ⦃f g⦄, ∀ hf : Memℒp f p μ, ∀ hg : Memℒp g p μ, Disjoint (support f) (support g) →\n      P (hf.toLp f) → P (hg.toLp g) → P (hf.toLp f + hg.toLp g))\n    (h_closed : IsClosed { f : Lp E p μ | P f }) : ∀ f : Lp E p μ, P f := by\n  refine fun f => (Lp.simpleFunc.denseRange hp_ne_top).induction_on f h_closed ?_\n  refine Lp.simpleFunc.induction (α := α) (E := E) (lt_of_lt_of_le zero_lt_one _i.elim).ne'\n    hp_ne_top ?_ ?_\n  · exact fun c s => h_ind c\n  · exact fun f g hf hg => h_add hf hg\n\n"}
{"name":"MeasureTheory.Memℒp.induction","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\n_i : Fact (LE.le 1 p)\nhp_ne_top : Ne p Top.top\nP : (α → E) → Prop\nh_ind : ∀ (c : E) ⦃s : Set α⦄, MeasurableSet s → LT.lt (μ s) Top.top → P (s.indicator fun x => c)\nh_add : ∀ ⦃f g : α → E⦄, Disjoint (Function.support f) (Function.support g) → MeasureTheory.Memℒp f p μ → MeasureTheory.Memℒp g p μ → P f → P g → P (HAdd.hAdd f g)\nh_closed : IsClosed (setOf fun f => P ↑↑f)\nh_ae : ∀ ⦃f g : α → E⦄, (MeasureTheory.ae μ).EventuallyEq f g → MeasureTheory.Memℒp f p μ → P f → P g\nf : α → E\na✝ : MeasureTheory.Memℒp f p μ\n⊢ P f","decl":"/-- To prove something for an arbitrary `Memℒp` function in a second countable\nBorel normed group, it suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `Lᵖ` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`).\n-/\n@[elab_as_elim]\ntheorem Memℒp.induction [_i : Fact (1 ≤ p)] (hp_ne_top : p ≠ ∞) (P : (α → E) → Prop)\n    (h_ind : ∀ (c : E) ⦃s⦄, MeasurableSet s → μ s < ∞ → P (s.indicator fun _ => c))\n    (h_add : ∀ ⦃f g : α → E⦄, Disjoint (support f) (support g) → Memℒp f p μ → Memℒp g p μ →\n      P f → P g → P (f + g))\n    (h_closed : IsClosed { f : Lp E p μ | P f })\n    (h_ae : ∀ ⦃f g⦄, f =ᵐ[μ] g → Memℒp f p μ → P f → P g) :\n    ∀ ⦃f : α → E⦄, Memℒp f p μ → P f := by\n  have : ∀ f : SimpleFunc α E, Memℒp f p μ → P f := by\n    apply SimpleFunc.induction\n    · intro c s hs h\n      by_cases hc : c = 0\n      · subst hc; convert h_ind 0 MeasurableSet.empty (by simp) using 1; ext; simp [const]\n      have hp_pos : p ≠ 0 := (lt_of_lt_of_le zero_lt_one _i.elim).ne'\n      exact h_ind c hs (SimpleFunc.measure_lt_top_of_memℒp_indicator hp_pos hp_ne_top hc hs h)\n    · intro f g hfg hf hg int_fg\n      rw [SimpleFunc.coe_add,\n        memℒp_add_of_disjoint hfg f.stronglyMeasurable g.stronglyMeasurable] at int_fg\n      exact h_add hfg int_fg.1 int_fg.2 (hf int_fg.1) (hg int_fg.2)\n  have : ∀ f : Lp.simpleFunc E p μ, P f := by\n    intro f\n    exact\n      h_ae (Lp.simpleFunc.toSimpleFunc_eq_toFun f) (Lp.simpleFunc.memℒp f)\n        (this (Lp.simpleFunc.toSimpleFunc f) (Lp.simpleFunc.memℒp f))\n  have : ∀ f : Lp E p μ, P f := fun f =>\n    (Lp.simpleFunc.denseRange hp_ne_top).induction_on f h_closed this\n  exact fun f hf => h_ae hf.coeFn_toLp (Lp.memℒp _) (this (hf.toLp f))\n\n"}
{"name":"MeasureTheory.Memℒp.induction_dense","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure α\nhp_ne_top : Ne p Top.top\nP : (α → E) → Prop\nh0P : ∀ (c : E) ⦃s : Set α⦄, MeasurableSet s → LT.lt (μ s) Top.top → ∀ {ε : ENNReal}, Ne ε 0 → Exists fun g => And (LE.le (MeasureTheory.eLpNorm (HSub.hSub g (s.indicator fun x => c)) p μ) ε) (P g)\nh1P : ∀ (f g : α → E), P f → P g → P (HAdd.hAdd f g)\nh2P : ∀ (f : α → E), P f → MeasureTheory.AEStronglyMeasurable f μ\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun g => And (LE.le (MeasureTheory.eLpNorm (HSub.hSub f g) p μ) ε) (P g)","decl":"/-- If a set of ae strongly measurable functions is stable under addition and approximates\ncharacteristic functions in `ℒp`, then it is dense in `ℒp`. -/\ntheorem Memℒp.induction_dense (hp_ne_top : p ≠ ∞) (P : (α → E) → Prop)\n    (h0P :\n      ∀ (c : E) ⦃s : Set α⦄,\n        MeasurableSet s →\n          μ s < ∞ →\n            ∀ {ε : ℝ≥0∞}, ε ≠ 0 → ∃ g : α → E, eLpNorm (g - s.indicator fun _ => c) p μ ≤ ε ∧ P g)\n    (h1P : ∀ f g, P f → P g → P (f + g)) (h2P : ∀ f, P f → AEStronglyMeasurable f μ) {f : α → E}\n    (hf : Memℒp f p μ) {ε : ℝ≥0∞} (hε : ε ≠ 0) : ∃ g : α → E, eLpNorm (f - g) p μ ≤ ε ∧ P g := by\n  rcases eq_or_ne p 0 with (rfl | hp_pos)\n  · rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])\n        hε with ⟨g, _, Pg⟩\n    exact ⟨g, by simp only [eLpNorm_exponent_zero, zero_le'], Pg⟩\n  suffices H : ∀ (f' : α →ₛ E) (δ : ℝ≥0∞) (hδ : δ ≠ 0), Memℒp f' p μ →\n      ∃ g, eLpNorm (⇑f' - g) p μ ≤ δ ∧ P g by\n    obtain ⟨η, ηpos, hη⟩ := exists_Lp_half E μ p hε\n    rcases hf.exists_simpleFunc_eLpNorm_sub_lt hp_ne_top ηpos.ne' with ⟨f', hf', f'_mem⟩\n    rcases H f' η ηpos.ne' f'_mem with ⟨g, hg, Pg⟩\n    refine ⟨g, ?_, Pg⟩\n    convert (hη _ _ (hf.aestronglyMeasurable.sub f'.aestronglyMeasurable)\n          (f'.aestronglyMeasurable.sub (h2P g Pg)) hf'.le hg).le using 2\n    simp only [sub_add_sub_cancel]\n  apply SimpleFunc.induction\n  · intro c s hs ε εpos Hs\n    rcases eq_or_ne c 0 with (rfl | hc)\n    · rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])\n          εpos with ⟨g, hg, Pg⟩\n      rw [← eLpNorm_neg, neg_sub] at hg\n      refine ⟨g, ?_, Pg⟩\n      convert hg\n      ext x\n      simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_zero,\n        piecewise_eq_indicator, indicator_zero', Pi.zero_apply, indicator_zero]\n    · have : μ s < ∞ := SimpleFunc.measure_lt_top_of_memℒp_indicator hp_pos hp_ne_top hc hs Hs\n      rcases h0P c hs this εpos with ⟨g, hg, Pg⟩\n      rw [← eLpNorm_neg, neg_sub] at hg\n      exact ⟨g, hg, Pg⟩\n  · intro f f' hff' hf hf' δ δpos int_ff'\n    obtain ⟨η, ηpos, hη⟩ := exists_Lp_half E μ p δpos\n    rw [SimpleFunc.coe_add,\n      memℒp_add_of_disjoint hff' f.stronglyMeasurable f'.stronglyMeasurable] at int_ff'\n    rcases hf η ηpos.ne' int_ff'.1 with ⟨g, hg, Pg⟩\n    rcases hf' η ηpos.ne' int_ff'.2 with ⟨g', hg', Pg'⟩\n    refine ⟨g + g', ?_, h1P g g' Pg Pg'⟩\n    convert (hη _ _ (f.aestronglyMeasurable.sub (h2P g Pg))\n          (f'.aestronglyMeasurable.sub (h2P g' Pg')) hg hg').le using 2\n    rw [SimpleFunc.coe_add]\n    abel\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.toLp_one_eq_toL1","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : MeasureTheory.SimpleFunc α E\nhf : MeasureTheory.Integrable (⇑f) μ\n⊢ Eq (↑(MeasureTheory.Lp.simpleFunc.toLp f ⋯)) (MeasureTheory.Integrable.toL1 (⇑f) hf)","decl":"theorem L1.SimpleFunc.toLp_one_eq_toL1 (f : α →ₛ E) (hf : Integrable f μ) :\n    (Lp.simpleFunc.toLp f (memℒp_one_iff_integrable.2 hf) : α →₁[μ] E) = hf.toL1 f :=\n  rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integrable","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 μ) x\n⊢ MeasureTheory.Integrable (⇑(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)) μ","decl":"@[fun_prop]\nprotected theorem L1.SimpleFunc.integrable (f : α →₁ₛ[μ] E) :\n    Integrable (Lp.simpleFunc.toSimpleFunc f) μ := by\n  rw [← memℒp_one_iff_integrable]; exact Lp.simpleFunc.memℒp f\n\n"}
{"name":"MeasureTheory.Integrable.induction","module":"Mathlib.MeasureTheory.Function.SimpleFuncDenseLp","initialProofState":"α : Type u_1\nE : Type u_4\ninst✝¹ : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nP : (α → E) → Prop\nh_ind : ∀ (c : E) ⦃s : Set α⦄, MeasurableSet s → LT.lt (μ s) Top.top → P (s.indicator fun x => c)\nh_add : ∀ ⦃f g : α → E⦄, Disjoint (Function.support f) (Function.support g) → MeasureTheory.Integrable f μ → MeasureTheory.Integrable g μ → P f → P g → P (HAdd.hAdd f g)\nh_closed : IsClosed (setOf fun f => P ↑↑f)\nh_ae : ∀ ⦃f g : α → E⦄, (MeasureTheory.ae μ).EventuallyEq f g → MeasureTheory.Integrable f μ → P f → P g\nf : α → E\na✝ : MeasureTheory.Integrable f μ\n⊢ P f","decl":"/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `L¹` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`).\n-/\n@[elab_as_elim]\ntheorem Integrable.induction (P : (α → E) → Prop)\n    (h_ind : ∀ (c : E) ⦃s⦄, MeasurableSet s → μ s < ∞ → P (s.indicator fun _ => c))\n    (h_add :\n      ∀ ⦃f g : α → E⦄,\n        Disjoint (support f) (support g) → Integrable f μ → Integrable g μ → P f → P g → P (f + g))\n    (h_closed : IsClosed { f : α →₁[μ] E | P f })\n    (h_ae : ∀ ⦃f g⦄, f =ᵐ[μ] g → Integrable f μ → P f → P g) :\n    ∀ ⦃f : α → E⦄, Integrable f μ → P f := by\n  simp only [← memℒp_one_iff_integrable] at *\n  exact Memℒp.induction one_ne_top (P := P) h_ind h_add h_closed h_ae\n\n"}
