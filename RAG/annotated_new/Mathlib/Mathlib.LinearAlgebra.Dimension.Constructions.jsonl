{"name":"LinearIndependent.sum_elim_of_quotient","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nM' : Submodule R M\nι₁ : Type u_2\nι₂ : Type u_3\nf : ι₁ → Subtype fun x => Membership.mem M' x\nhf : LinearIndependent R f\ng : ι₂ → M\nhg : LinearIndependent R (Function.comp Submodule.Quotient.mk g)\n⊢ LinearIndependent R (Sum.elim (fun x => ↑(f x)) g)","decl":"theorem LinearIndependent.sum_elim_of_quotient\n    {M' : Submodule R M} {ι₁ ι₂} {f : ι₁ → M'} (hf : LinearIndependent R f) (g : ι₂ → M)\n    (hg : LinearIndependent R (Submodule.Quotient.mk (p := M') ∘ g)) :\n    LinearIndependent R (Sum.elim (f · : ι₁ → M) g) := by\n  refine .sum_type (hf.map' M'.subtype M'.ker_subtype) (.of_comp M'.mkQ hg) ?_\n  refine disjoint_def.mpr fun x h₁ h₂ ↦ ?_\n  have : x ∈ M' := span_le.mpr (Set.range_subset_iff.mpr fun i ↦ (f i).prop) h₁\n  obtain ⟨c, rfl⟩ := Finsupp.mem_span_range_iff_exists_finsupp.mp h₂\n  simp_rw [← Quotient.mk_eq_zero, ← mkQ_apply, map_finsupp_sum, map_smul, mkQ_apply] at this\n  rw [linearIndependent_iff.mp hg _ this, Finsupp.sum_zero_index]\n\n"}
{"name":"LinearIndependent.union_of_quotient","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nM' : Submodule R M\ns : Set M\nhs : HasSubset.Subset s ↑M'\nhs' : LinearIndependent R Subtype.val\nt : Set M\nht : LinearIndependent R (Function.comp Submodule.Quotient.mk Subtype.val)\n⊢ LinearIndependent R Subtype.val","decl":"theorem LinearIndependent.union_of_quotient {M' : Submodule R M}\n    {s : Set M} (hs : s ⊆ M') (hs' : LinearIndependent (ι := s) R Subtype.val) {t : Set M}\n    (ht : LinearIndependent (ι := t) R (Submodule.Quotient.mk (p := M') ∘ Subtype.val)) :\n    LinearIndependent (ι := (s ∪ t :)) R Subtype.val := by\n  refine (LinearIndependent.sum_elim_of_quotient (f := Set.embeddingOfSubset s M' hs)\n    (of_comp M'.subtype (by simpa using hs')) Subtype.val ht).to_subtype_range' ?_\n  simp only [embeddingOfSubset_apply_coe, Sum.elim_range, Subtype.range_val]\n\n"}
{"name":"rank_quotient_add_rank_le","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nM' : Submodule R M\n⊢ LE.le (HAdd.hAdd (Module.rank R (HasQuotient.Quotient M M')) (Module.rank R (Subtype fun x => Membership.mem M' x))) (Module.rank R M)","decl":"theorem rank_quotient_add_rank_le [Nontrivial R] (M' : Submodule R M) :\n    Module.rank R (M ⧸ M') + Module.rank R M' ≤ Module.rank R M := by\n  conv_lhs => simp only [Module.rank_def]\n  have := nonempty_linearIndependent_set R (M ⧸ M')\n  have := nonempty_linearIndependent_set R M'\n  rw [Cardinal.ciSup_add_ciSup _ (bddAbove_range _) _ (bddAbove_range _)]\n  refine ciSup_le fun ⟨s, hs⟩ ↦ ciSup_le fun ⟨t, ht⟩ ↦ ?_\n  choose f hf using Submodule.Quotient.mk_surjective M'\n  simpa [add_comm] using (LinearIndependent.sum_elim_of_quotient ht (fun (i : s) ↦ f i)\n    (by simpa [Function.comp_def, hf] using hs)).cardinal_le_rank\n\n"}
{"name":"rank_quotient_le","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ LE.le (Module.rank R (HasQuotient.Quotient M p)) (Module.rank R M)","decl":"theorem rank_quotient_le (p : Submodule R M) : Module.rank R (M ⧸ p) ≤ Module.rank R M :=\n  (mkQ p).rank_le_of_surjective Quot.mk_surjective\n\n"}
{"name":"Submodule.finrank_quotient_le","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\ns : Submodule R M\n⊢ LE.le (Module.finrank R (HasQuotient.Quotient M s)) (Module.finrank R M)","decl":"/-- The dimension of a quotient is bounded by the dimension of the ambient space. -/\ntheorem Submodule.finrank_quotient_le [StrongRankCondition R] [Module.Finite R M]\n    (s : Submodule R M) : finrank R (M ⧸ s) ≤ finrank R M :=\n  toNat_le_toNat ((Submodule.mkQ s).rank_le_of_surjective Quot.mk_surjective)\n    (rank_lt_aleph0 _ _)\n\n"}
{"name":"rank_ulift","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Module.rank R (ULift.{w, v} M)) (Cardinal.lift.{w, v} (Module.rank R M))","decl":"@[simp]\ntheorem rank_ulift : Module.rank R (ULift.{w} M) = Cardinal.lift.{w} (Module.rank R M) :=\n  Cardinal.lift_injective.{v} <| Eq.symm <| (lift_lift _).trans ULift.moduleEquiv.symm.lift_rank_eq\n\n"}
{"name":"finrank_ulift","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Module.finrank R (ULift.{u_2, v} M)) (Module.finrank R M)","decl":"@[simp]\ntheorem finrank_ulift : finrank R (ULift M) = finrank R M := by\n  simp_rw [finrank, rank_ulift, toNat_lift]\n\n"}
{"name":"rank_add_rank_le_rank_prod","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M\ninst✝¹ : Module R M₁\ninst✝ : Nontrivial R\n⊢ LE.le (HAdd.hAdd (Module.rank R M) (Module.rank R M₁)) (Module.rank R (Prod M M₁))","decl":"theorem rank_add_rank_le_rank_prod [Nontrivial R] :\n    Module.rank R M + Module.rank R M₁ ≤ Module.rank R (M × M₁) := by\n  conv_lhs => simp only [Module.rank_def]\n  have := nonempty_linearIndependent_set R M\n  have := nonempty_linearIndependent_set R M₁\n  rw [Cardinal.ciSup_add_ciSup _ (bddAbove_range _) _ (bddAbove_range _)]\n  exact ciSup_le fun ⟨s, hs⟩ ↦ ciSup_le fun ⟨t, ht⟩ ↦\n    (linearIndependent_inl_union_inr' hs ht).cardinal_le_rank\n\n"}
{"name":"lift_rank_add_lift_rank_le_rank_prod","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\ninst✝ : Nontrivial R\n⊢ LE.le (HAdd.hAdd (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R M'))) (Module.rank R (Prod M M'))","decl":"theorem lift_rank_add_lift_rank_le_rank_prod [Nontrivial R] :\n    lift.{v'} (Module.rank R M) + lift.{v} (Module.rank R M') ≤ Module.rank R (M × M') := by\n  rw [← rank_ulift, ← rank_ulift]\n  exact (rank_add_rank_le_rank_prod R _).trans_eq\n    (ULift.moduleEquiv.prod ULift.moduleEquiv).rank_eq\n\n"}
{"name":"rank_prod","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : Module R M\ninst✝³ : Module R M'\ninst✝² : StrongRankCondition R\ninst✝¹ : Module.Free R M\ninst✝ : Module.Free R M'\n⊢ Eq (Module.rank R (Prod M M')) (HAdd.hAdd (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R M')))","decl":"/-- If `M` and `M'` are free, then the rank of `M × M'` is\n`(Module.rank R M).lift + (Module.rank R M').lift`. -/\n@[simp]\ntheorem rank_prod : Module.rank R (M × M') =\n    Cardinal.lift.{v'} (Module.rank R M) + Cardinal.lift.{v, v'} (Module.rank R M') := by\n  simpa [rank_eq_card_chooseBasisIndex R M, rank_eq_card_chooseBasisIndex R M', lift_umax]\n    using ((chooseBasis R M).prod (chooseBasis R M')).mk_eq_rank.symm\n\n"}
{"name":"rank_prod'","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : Module R M\ninst✝³ : Module R M₁\ninst✝² : StrongRankCondition R\ninst✝¹ : Module.Free R M\ninst✝ : Module.Free R M₁\n⊢ Eq (Module.rank R (Prod M M₁)) (HAdd.hAdd (Module.rank R M) (Module.rank R M₁))","decl":"/-- If `M` and `M'` are free (and lie in the same universe), the rank of `M × M'` is\n  `(Module.rank R M) + (Module.rank R M')`. -/\ntheorem rank_prod' : Module.rank R (M × M₁) = Module.rank R M + Module.rank R M₁ := by simp\n\n"}
{"name":"Module.finrank_prod","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid M'\ninst✝⁶ : Module R M\ninst✝⁵ : Module R M'\ninst✝⁴ : StrongRankCondition R\ninst✝³ : Module.Free R M\ninst✝² : Module.Free R M'\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Finite R M'\n⊢ Eq (Module.finrank R (Prod M M')) (HAdd.hAdd (Module.finrank R M) (Module.finrank R M'))","decl":"/-- The finrank of `M × M'` is `(finrank R M) + (finrank R M')`. -/\n@[simp]\ntheorem Module.finrank_prod [Module.Finite R M] [Module.Finite R M'] :\n    finrank R (M × M') = finrank R M + finrank R M' := by\n  simp [finrank, rank_lt_aleph0 R M, rank_lt_aleph0 R M']\n\n"}
{"name":"rank_finsupp","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Free R M\nι : Type w\n⊢ Eq (Module.rank R (Finsupp ι M)) (HMul.hMul (Cardinal.lift.{v, w} (Cardinal.mk ι)) (Cardinal.lift.{w, v} (Module.rank R M)))","decl":"@[simp]\ntheorem rank_finsupp (ι : Type w) :\n    Module.rank R (ι →₀ M) = Cardinal.lift.{v} #ι * Cardinal.lift.{w} (Module.rank R M) := by\n  obtain ⟨⟨_, bs⟩⟩ := Module.Free.exists_basis (R := R) (M := M)\n  rw [← bs.mk_eq_rank'', ← (Finsupp.basis fun _ : ι => bs).mk_eq_rank'', Cardinal.mk_sigma,\n    Cardinal.sum_const]\n\n"}
{"name":"rank_finsupp'","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Free R M\nι : Type v\n⊢ Eq (Module.rank R (Finsupp ι M)) (HMul.hMul (Cardinal.mk ι) (Module.rank R M))","decl":"theorem rank_finsupp' (ι : Type v) : Module.rank R (ι →₀ M) = #ι * Module.rank R M := by\n  simp [rank_finsupp]\n\n"}
{"name":"rank_finsupp_self","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : StrongRankCondition R\nι : Type w\n⊢ Eq (Module.rank R (Finsupp ι R)) (Cardinal.lift.{u, w} (Cardinal.mk ι))","decl":"/-- The rank of `(ι →₀ R)` is `(#ι).lift`. -/\ntheorem rank_finsupp_self (ι : Type w) : Module.rank R (ι →₀ R) = Cardinal.lift.{u} #ι := by\n  simp\n\n"}
{"name":"rank_finsupp_self'","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : StrongRankCondition R\nι : Type u\n⊢ Eq (Module.rank R (Finsupp ι R)) (Cardinal.mk ι)","decl":"/-- If `R` and `ι` lie in the same universe, the rank of `(ι →₀ R)` is `# ι`. -/\ntheorem rank_finsupp_self' {ι : Type u} : Module.rank R (ι →₀ R) = #ι := by simp\n\n"}
{"name":"rank_directSum","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\ninst✝³ : StrongRankCondition R\nι : Type v\nM : ι → Type w\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : ∀ (i : ι), Module.Free R (M i)\n⊢ Eq (Module.rank R (DirectSum ι fun i => M i)) (Cardinal.sum fun i => Module.rank R (M i))","decl":"/-- The rank of the direct sum is the sum of the ranks. -/\n@[simp]\ntheorem rank_directSum {ι : Type v} (M : ι → Type w) [∀ i : ι, AddCommMonoid (M i)]\n    [∀ i : ι, Module R (M i)] [∀ i : ι, Module.Free R (M i)] :\n    Module.rank R (⨁ i, M i) = Cardinal.sum fun i => Module.rank R (M i) := by\n  let B i := chooseBasis R (M i)\n  let b : Basis _ R (⨁ i, M i) := DFinsupp.basis fun i => B i\n  simp [← b.mk_eq_rank'', fun i => (B i).mk_eq_rank'']\n\n"}
{"name":"rank_matrix_module","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : StrongRankCondition R\ninst✝² : Module.Free R M\nm : Type w\nn : Type w'\ninst✝¹ : Finite m\ninst✝ : Finite n\n⊢ Eq (Module.rank R (Matrix m n M)) (HMul.hMul (HMul.hMul (Cardinal.lift.{max v w', w} (Cardinal.mk m)) (Cardinal.lift.{max v w, w'} (Cardinal.mk n))) (Cardinal.lift.{max w w', v} (Module.rank R M)))","decl":"/-- If `m` and `n` are finite, the rank of `m × n` matrices over a module `M` is\n`(#m).lift * (#n).lift * rank R M`. -/\n@[simp]\ntheorem rank_matrix_module (m : Type w) (n : Type w') [Finite m] [Finite n] :\n    Module.rank R (Matrix m n M) =\n      lift.{max v w'} #m * lift.{max v w} #n * lift.{max w w'} (Module.rank R M) := by\n  cases nonempty_fintype m\n  cases nonempty_fintype n\n  obtain ⟨I, b⟩ := Module.Free.exists_basis (R := R) (M := M)\n  rw [← (b.matrix m n).mk_eq_rank'']\n  simp only [mk_prod, lift_mul, lift_lift, ← mul_assoc, b.mk_eq_rank'']\n\n\n"}
{"name":"rank_matrix_module'","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : StrongRankCondition R\ninst✝² : Module.Free R M\nm n : Type w\ninst✝¹ : Finite m\ninst✝ : Finite n\n⊢ Eq (Module.rank R (Matrix m n M)) (HMul.hMul (Cardinal.lift.{v, w} (HMul.hMul (Cardinal.mk m) (Cardinal.mk n))) (Cardinal.lift.{w, v} (Module.rank R M)))","decl":"/-- If `m` and `n` are finite and lie in the same universe, the rank of `m × n` matrices over a\nmodule `M` is `(#m * #n).lift * rank R M`. -/\n@[simp high]\ntheorem rank_matrix_module' (m n : Type w) [Finite m] [Finite n] :\n    Module.rank R (Matrix m n M) =\n      lift.{max v} (#m * #n) * lift.{w} (Module.rank R M) := by\n  rw [rank_matrix_module, lift_mul, lift_umax.{w, v}]\n\n"}
{"name":"rank_matrix","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : StrongRankCondition R\nm : Type v\nn : Type w\ninst✝¹ : Finite m\ninst✝ : Finite n\n⊢ Eq (Module.rank R (Matrix m n R)) (HMul.hMul (Cardinal.lift.{max v w u, v} (Cardinal.mk m)) (Cardinal.lift.{max v w u, w} (Cardinal.mk n)))","decl":"/-- If `m` and `n` are finite, the rank of `m × n` matrices is `(#m).lift * (#n).lift`. -/\ntheorem rank_matrix (m : Type v) (n : Type w) [Finite m] [Finite n] :\n    Module.rank R (Matrix m n R) =\n      Cardinal.lift.{max v w u, v} #m * Cardinal.lift.{max v w u, w} #n := by\n  rw [rank_matrix_module, rank_self, lift_one, mul_one, ← lift_lift.{v, max u w}, lift_id,\n    ← lift_lift.{w, max u v}, lift_id]\n\n"}
{"name":"rank_matrix'","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : StrongRankCondition R\nm n : Type v\ninst✝¹ : Finite m\ninst✝ : Finite n\n⊢ Eq (Module.rank R (Matrix m n R)) (Cardinal.lift.{u, v} (HMul.hMul (Cardinal.mk m) (Cardinal.mk n)))","decl":"/-- If `m` and `n` are finite and lie in the same universe, the rank of `m × n` matrices is\n  `(#n * #m).lift`. -/\ntheorem rank_matrix' (m n : Type v) [Finite m] [Finite n] :\n    Module.rank R (Matrix m n R) = Cardinal.lift.{u} (#m * #n) := by\n  rw [rank_matrix, lift_mul, lift_umax.{v, u}]\n\n"}
{"name":"rank_matrix''","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : StrongRankCondition R\nm n : Type u\ninst✝¹ : Finite m\ninst✝ : Finite n\n⊢ Eq (Module.rank R (Matrix m n R)) (HMul.hMul (Cardinal.mk m) (Cardinal.mk n))","decl":"/-- If `m` and `n` are finite and lie in the same universe as `R`, the rank of `m × n` matrices\n  is `# m * # n`. -/\ntheorem rank_matrix'' (m n : Type u) [Finite m] [Finite n] :\n    Module.rank R (Matrix m n R) = #m * #n := by simp\n\n"}
{"name":"Module.finrank_finsupp","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : Module.Free R M\nι : Type v\ninst✝ : Fintype ι\n⊢ Eq (Module.finrank R (Finsupp ι M)) (HMul.hMul (Fintype.card ι) (Module.finrank R M))","decl":"@[simp]\ntheorem finrank_finsupp {ι : Type v} [Fintype ι] : finrank R (ι →₀ M) = card ι * finrank R M := by\n  rw [finrank, finrank, rank_finsupp, ← mk_toNat_eq_card, toNat_mul, toNat_lift, toNat_lift]\n\n"}
{"name":"Module.finrank_finsupp_self","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝² : Semiring R\ninst✝¹ : StrongRankCondition R\nι : Type v\ninst✝ : Fintype ι\n⊢ Eq (Module.finrank R (Finsupp ι R)) (Fintype.card ι)","decl":"/-- The finrank of `(ι →₀ R)` is `Fintype.card ι`. -/\n@[simp]\ntheorem finrank_finsupp_self {ι : Type v} [Fintype ι] : finrank R (ι →₀ R) = card ι := by\n  rw [finrank, rank_finsupp_self, ← mk_toNat_eq_card, toNat_lift]\n\n"}
{"name":"Module.finrank_directSum","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\ninst✝⁵ : StrongRankCondition R\nι : Type v\ninst✝⁴ : Fintype ι\nM : ι → Type w\ninst✝³ : (i : ι) → AddCommMonoid (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : ∀ (i : ι), Module.Free R (M i)\ninst✝ : ∀ (i : ι), Module.Finite R (M i)\n⊢ Eq (Module.finrank R (DirectSum ι fun i => M i)) (Finset.univ.sum fun i => Module.finrank R (M i))","decl":"/-- The finrank of the direct sum is the sum of the finranks. -/\n@[simp]\ntheorem finrank_directSum {ι : Type v} [Fintype ι] (M : ι → Type w) [∀ i : ι, AddCommMonoid (M i)]\n    [∀ i : ι, Module R (M i)] [∀ i : ι, Module.Free R (M i)] [∀ i : ι, Module.Finite R (M i)] :\n    finrank R (⨁ i, M i) = ∑ i, finrank R (M i) := by\n  letI := nontrivial_of_invariantBasisNumber R\n  simp only [finrank, fun i => rank_eq_card_chooseBasisIndex R (M i), rank_directSum, ← mk_sigma,\n    mk_toNat_eq_card, card_sigma]\n\n"}
{"name":"Module.finrank_matrix","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : StrongRankCondition R\ninst✝² : Module.Free R M\nm : Type u_2\nn : Type u_3\ninst✝¹ : Fintype m\ninst✝ : Fintype n\n⊢ Eq (Module.finrank R (Matrix m n M)) (HMul.hMul (HMul.hMul (Fintype.card m) (Fintype.card n)) (Module.finrank R M))","decl":"/-- If `m` and `n` are `Fintype`, the finrank of `m × n` matrices over a module `M` is\n  `(Fintype.card m) * (Fintype.card n) * finrank R M`. -/\ntheorem finrank_matrix (m n : Type*) [Fintype m] [Fintype n] :\n    finrank R (Matrix m n M) = card m * card n * finrank R M := by simp [finrank]\n\n"}
{"name":"rank_pi","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nη : Type u₁'\nφ : η → Type u_1\ninst✝⁵ : Semiring R\ninst✝⁴ : StrongRankCondition R\ninst✝³ : (i : η) → AddCommMonoid (φ i)\ninst✝² : (i : η) → Module R (φ i)\ninst✝¹ : ∀ (i : η), Module.Free R (φ i)\ninst✝ : Finite η\n⊢ Eq (Module.rank R ((i : η) → φ i)) (Cardinal.sum fun i => Module.rank R (φ i))","decl":"/-- The rank of a finite product of free modules is the sum of the ranks. -/\n-- this result is not true without the freeness assumption\n@[simp]\ntheorem rank_pi [Finite η] : Module.rank R (∀ i, φ i) =\n    Cardinal.sum fun i => Module.rank R (φ i) := by\n  cases nonempty_fintype η\n  let B i := chooseBasis R (φ i)\n  let b : Basis _ R (∀ i, φ i) := Pi.basis fun i => B i\n  simp [← b.mk_eq_rank'', fun i => (B i).mk_eq_rank'']\n\n"}
{"name":"Module.finrank_pi","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝² : Semiring R\ninst✝¹ : StrongRankCondition R\nι : Type v\ninst✝ : Fintype ι\n⊢ Eq (Module.finrank R (ι → R)) (Fintype.card ι)","decl":"/-- The finrank of `(ι → R)` is `Fintype.card ι`. -/\ntheorem Module.finrank_pi {ι : Type v} [Fintype ι] :\n    finrank R (ι → R) = Fintype.card ι := by\n  simp [finrank]\n\n--TODO: this should follow from `LinearEquiv.finrank_eq`, that is over a field.\n"}
{"name":"Module.finrank_pi_fintype","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝⁶ : Semiring R\ninst✝⁵ : StrongRankCondition R\nι : Type v\ninst✝⁴ : Fintype ι\nM : ι → Type w\ninst✝³ : (i : ι) → AddCommMonoid (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : ∀ (i : ι), Module.Free R (M i)\ninst✝ : ∀ (i : ι), Module.Finite R (M i)\n⊢ Eq (Module.finrank R ((i : ι) → M i)) (Finset.univ.sum fun i => Module.finrank R (M i))","decl":"/-- The finrank of a finite product is the sum of the finranks. -/\ntheorem Module.finrank_pi_fintype\n    {ι : Type v} [Fintype ι] {M : ι → Type w} [∀ i : ι, AddCommMonoid (M i)]\n    [∀ i : ι, Module R (M i)] [∀ i : ι, Module.Free R (M i)] [∀ i : ι, Module.Finite R (M i)] :\n    finrank R (∀ i, M i) = ∑ i, finrank R (M i) := by\n  letI := nontrivial_of_invariantBasisNumber R\n  simp only [finrank, fun i => rank_eq_card_chooseBasisIndex R (M i), rank_pi, ← mk_sigma,\n    mk_toNat_eq_card, Fintype.card_sigma]\n\n"}
{"name":"rank_fun","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝⁵ : Semiring R\ninst✝⁴ : StrongRankCondition R\nM η : Type u\ninst✝³ : Fintype η\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\n⊢ Eq (Module.rank R (η → M)) (HMul.hMul (↑(Fintype.card η)) (Module.rank R M))","decl":"theorem rank_fun {M η : Type u} [Fintype η] [AddCommMonoid M] [Module R M] [Module.Free R M] :\n    Module.rank R (η → M) = Fintype.card η * Module.rank R M := by\n  rw [rank_pi, Cardinal.sum_const', Cardinal.mk_fintype]\n\n"}
{"name":"rank_fun_eq_lift_mul","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\nη : Type u₁'\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : Module.Free R M\ninst✝ : Fintype η\n⊢ Eq (Module.rank R (η → M)) (HMul.hMul (↑(Fintype.card η)) (Cardinal.lift.{u₁', v} (Module.rank R M)))","decl":"theorem rank_fun_eq_lift_mul : Module.rank R (η → M) =\n    (Fintype.card η : Cardinal.{max u₁' v}) * Cardinal.lift.{u₁'} (Module.rank R M) := by\n  rw [rank_pi, Cardinal.sum_const, Cardinal.mk_fintype, Cardinal.lift_natCast]\n\n"}
{"name":"rank_fun'","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nη : Type u₁'\ninst✝² : Semiring R\ninst✝¹ : StrongRankCondition R\ninst✝ : Fintype η\n⊢ Eq (Module.rank R (η → R)) ↑(Fintype.card η)","decl":"theorem rank_fun' : Module.rank R (η → R) = Fintype.card η := by\n  rw [rank_fun_eq_lift_mul, rank_self, Cardinal.lift_one, mul_one]\n\n"}
{"name":"rank_fin_fun","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : StrongRankCondition R\nn : Nat\n⊢ Eq (Module.rank R (Fin n → R)) ↑n","decl":"theorem rank_fin_fun (n : ℕ) : Module.rank R (Fin n → R) = n := by simp [rank_fun']\n\n"}
{"name":"Module.finrank_fintype_fun_eq_card","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nη : Type u₁'\ninst✝² : Semiring R\ninst✝¹ : StrongRankCondition R\ninst✝ : Fintype η\n⊢ Eq (Module.finrank R (η → R)) (Fintype.card η)","decl":"/-- The vector space of functions on a `Fintype ι` has finrank equal to the cardinality of `ι`. -/\n@[simp]\ntheorem Module.finrank_fintype_fun_eq_card : finrank R (η → R) = Fintype.card η :=\n  finrank_eq_of_rank_eq rank_fun'\n\n"}
{"name":"Module.finrank_fin_fun","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : StrongRankCondition R\nn : Nat\n⊢ Eq (Module.finrank R (Fin n → R)) n","decl":"/-- The vector space of functions on `Fin n` has finrank equal to `n`. -/\ntheorem Module.finrank_fin_fun {n : ℕ} : finrank R (Fin n → R) = n := by simp\n\n"}
{"name":"rank_tensorProduct","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nS : Type u'\nM : Type v\nM' : Type v'\ninst✝¹² : Semiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : AddCommMonoid M'\ninst✝⁸ : Module R M\ninst✝⁷ : StrongRankCondition R\ninst✝⁶ : StrongRankCondition S\ninst✝⁵ : Module S M\ninst✝⁴ : Module S M'\ninst✝³ : Module.Free S M'\ninst✝² : Algebra S R\ninst✝¹ : IsScalarTower S R M\ninst✝ : Module.Free R M\n⊢ Eq (Module.rank R (TensorProduct S M M')) (HMul.hMul (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank S M')))","decl":"/-- The `S`-rank of `M ⊗[R] M'` is `(Module.rank S M).lift * (Module.rank R M').lift`. -/\n@[simp]\ntheorem rank_tensorProduct :\n    Module.rank R (M ⊗[S] M') =\n      Cardinal.lift.{v'} (Module.rank R M) * Cardinal.lift.{v} (Module.rank S M') := by\n  obtain ⟨⟨_, bM⟩⟩ := Module.Free.exists_basis (R := R) (M := M)\n  obtain ⟨⟨_, bN⟩⟩ := Module.Free.exists_basis (R := S) (M := M')\n  rw [← bM.mk_eq_rank'', ← bN.mk_eq_rank'', ← (bM.tensorProduct bN).mk_eq_rank'', Cardinal.mk_prod]\n\n"}
{"name":"rank_tensorProduct'","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nS : Type u'\nM M₁ : Type v\ninst✝¹² : Semiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M\ninst✝⁷ : StrongRankCondition R\ninst✝⁶ : StrongRankCondition S\ninst✝⁵ : Module S M\ninst✝⁴ : Module S M₁\ninst✝³ : Module.Free S M₁\ninst✝² : Algebra S R\ninst✝¹ : IsScalarTower S R M\ninst✝ : Module.Free R M\n⊢ Eq (Module.rank R (TensorProduct S M M₁)) (HMul.hMul (Module.rank R M) (Module.rank S M₁))","decl":"/-- If `M` and `M'` lie in the same universe, the `S`-rank of `M ⊗[R] M'` is\n  `(Module.rank S M) * (Module.rank R M')`. -/\ntheorem rank_tensorProduct' :\n    Module.rank R (M ⊗[S] M₁) = Module.rank R M * Module.rank S M₁ := by simp\n\n"}
{"name":"Module.rank_baseChange","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nS : Type u'\nM' : Type v'\ninst✝⁷ : Semiring R\ninst✝⁶ : CommSemiring S\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : StrongRankCondition R\ninst✝³ : StrongRankCondition S\ninst✝² : Module S M'\ninst✝¹ : Module.Free S M'\ninst✝ : Algebra S R\n⊢ Eq (Module.rank R (TensorProduct S R M')) (Cardinal.lift.{u, v'} (Module.rank S M'))","decl":"theorem Module.rank_baseChange :\n    Module.rank R (R ⊗[S] M') = Cardinal.lift.{u} (Module.rank S M') := by simp\n\n"}
{"name":"Module.finrank_tensorProduct","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nS : Type u'\nM : Type v\nM' : Type v'\ninst✝¹² : Semiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : AddCommMonoid M'\ninst✝⁸ : Module R M\ninst✝⁷ : StrongRankCondition R\ninst✝⁶ : StrongRankCondition S\ninst✝⁵ : Module S M\ninst✝⁴ : Module S M'\ninst✝³ : Module.Free S M'\ninst✝² : Algebra S R\ninst✝¹ : IsScalarTower S R M\ninst✝ : Module.Free R M\n⊢ Eq (Module.finrank R (TensorProduct S M M')) (HMul.hMul (Module.finrank R M) (Module.finrank S M'))","decl":"/-- The `S`-finrank of `M ⊗[R] M'` is `(finrank S M) * (finrank R M')`. -/\n@[simp]\ntheorem Module.finrank_tensorProduct :\n    finrank R (M ⊗[S] M') = finrank R M * finrank S M' := by simp [finrank]\n\n"}
{"name":"Module.finrank_baseChange","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nS : Type u'\nM' : Type v'\ninst✝⁷ : Semiring R\ninst✝⁶ : CommSemiring S\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : StrongRankCondition R\ninst✝³ : StrongRankCondition S\ninst✝² : Module S M'\ninst✝¹ : Module.Free S M'\ninst✝ : Algebra S R\n⊢ Eq (Module.finrank R (TensorProduct S R M')) (Module.finrank S M')","decl":"theorem Module.finrank_baseChange : finrank R (R ⊗[S] M') = finrank S M' := by simp\n\n"}
{"name":"Submodule.lt_of_le_of_finrank_lt_finrank","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Submodule R M\nle : LE.le s t\nlt : LT.lt (Module.finrank R (Subtype fun x => Membership.mem s x)) (Module.finrank R (Subtype fun x => Membership.mem t x))\n⊢ LT.lt s t","decl":"theorem lt_of_le_of_finrank_lt_finrank {s t : Submodule R M} (le : s ≤ t)\n    (lt : finrank R s < finrank R t) : s < t :=\n  lt_of_le_of_ne le fun h => ne_of_lt lt (by rw [h])\n\n"}
{"name":"Submodule.lt_top_of_finrank_lt_finrank","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Submodule R M\nlt : LT.lt (Module.finrank R (Subtype fun x => Membership.mem s x)) (Module.finrank R M)\n⊢ LT.lt s Top.top","decl":"theorem lt_top_of_finrank_lt_finrank {s : Submodule R M} (lt : finrank R s < finrank R M) :\n    s < ⊤ := by\n  rw [← finrank_top R M] at lt\n  exact lt_of_le_of_finrank_lt_finrank le_top lt\n\n"}
{"name":"Submodule.finrank_le","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\ns : Submodule R M\n⊢ LE.le (Module.finrank R (Subtype fun x => Membership.mem s x)) (Module.finrank R M)","decl":"/-- The dimension of a submodule is bounded by the dimension of the ambient space. -/\ntheorem Submodule.finrank_le [Module.Finite R M] (s : Submodule R M) :\n    finrank R s ≤ finrank R M :=\n  toNat_le_toNat (Submodule.rank_le s) (rank_lt_aleph0 _ _)\n\n"}
{"name":"Submodule.finrank_map_le","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\np : Submodule R M\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem p x)\n⊢ LE.le (Module.finrank R (Subtype fun x => Membership.mem (Submodule.map f p) x)) (Module.finrank R (Subtype fun x => Membership.mem p x))","decl":"/-- Pushforwards of finite submodules have a smaller finrank. -/\ntheorem Submodule.finrank_map_le\n    [Module R M'] (f : M →ₗ[R] M') (p : Submodule R M) [Module.Finite R p] :\n    finrank R (p.map f) ≤ finrank R p :=\n  finrank_le_finrank_of_rank_le_rank (lift_rank_map_le _ _) (rank_lt_aleph0 _ _)\n\n"}
{"name":"Submodule.finrank_mono","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ns t : Submodule R M\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem t x)\nhst : LE.le s t\n⊢ LE.le (Module.finrank R (Subtype fun x => Membership.mem s x)) (Module.finrank R (Subtype fun x => Membership.mem t x))","decl":"theorem Submodule.finrank_mono {s t : Submodule R M} [Module.Finite R t] (hst : s ≤ t) :\n    finrank R s ≤ finrank R t :=\n  Cardinal.toNat_le_toNat (Submodule.rank_mono hst) (rank_lt_aleph0 R ↥t)\n\n"}
{"name":"Submodule.finrank_le_finrank_of_le","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ns t : Submodule R M\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem t x)\nhst : LE.le s t\n⊢ LE.le (Module.finrank R (Subtype fun x => Membership.mem s x)) (Module.finrank R (Subtype fun x => Membership.mem t x))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias Submodule.finrank_le_finrank_of_le := Submodule.finrank_mono\n\n"}
{"name":"rank_span_le","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\ns : Set M\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Submodule.span R s) x)) (Cardinal.mk ↑s)","decl":"theorem rank_span_le (s : Set M) : Module.rank R (span R s) ≤ #s := by\n  rw [Finsupp.span_eq_range_linearCombination, ← lift_strictMono.le_iff_le]\n  refine (lift_rank_range_le _).trans ?_\n  rw [rank_finsupp_self]\n  simp only [lift_lift, le_refl]\n\n"}
{"name":"rank_span_finset_le","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\ns : Finset M\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Submodule.span R ↑s) x)) ↑s.card","decl":"theorem rank_span_finset_le (s : Finset M) : Module.rank R (span R (s : Set M)) ≤ s.card := by\n  simpa using rank_span_le s.toSet\n\n"}
{"name":"rank_span_of_finset","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\ns : Finset M\n⊢ LT.lt (Module.rank R (Subtype fun x => Membership.mem (Submodule.span R ↑s) x)) Cardinal.aleph0","decl":"theorem rank_span_of_finset (s : Finset M) : Module.rank R (span R (s : Set M)) < ℵ₀ :=\n  (rank_span_finset_le s).trans_lt (Cardinal.nat_lt_aleph0 _)\n\n"}
{"name":"finrank_span_le_card","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ns : Set M\ninst✝ : Fintype ↑s\n⊢ LE.le (Module.finrank R (Subtype fun x => Membership.mem (Submodule.span R s) x)) s.toFinset.card","decl":"theorem finrank_span_le_card (s : Set M) [Fintype s] : finrank R (span R s) ≤ s.toFinset.card :=\n  finrank_le_of_rank_le (by simpa using rank_span_le (R := R) s)\n\n"}
{"name":"finrank_span_finset_le_card","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\ns : Finset M\n⊢ LE.le (Set.finrank R ↑s) s.card","decl":"theorem finrank_span_finset_le_card (s : Finset M) : (s : Set M).finrank R ≤ s.card :=\n  calc\n    (s : Set M).finrank R ≤ (s : Set M).toFinset.card := finrank_span_le_card (M := M) s\n    _ = s.card := by simp\n\n"}
{"name":"finrank_range_le_card","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type u_2\ninst✝ : Fintype ι\nb : ι → M\n⊢ LE.le (Set.finrank R (Set.range b)) (Fintype.card ι)","decl":"theorem finrank_range_le_card {ι : Type*} [Fintype ι] (b : ι → M) :\n    (Set.range b).finrank R ≤ Fintype.card ι := by\n  classical\n  refine (finrank_span_le_card _).trans ?_\n  rw [Set.toFinset_range]\n  exact Finset.card_image_le\n\n"}
{"name":"finrank_span_eq_card","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\ninst✝¹ : Nontrivial R\nι : Type u_2\ninst✝ : Fintype ι\nb : ι → M\nhb : LinearIndependent R b\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem (Submodule.span R (Set.range b)) x)) (Fintype.card ι)","decl":"theorem finrank_span_eq_card [Nontrivial R] {ι : Type*} [Fintype ι] {b : ι → M}\n    (hb : LinearIndependent R b) :\n    finrank R (span R (Set.range b)) = Fintype.card ι :=\n  finrank_eq_of_rank_eq\n    (by\n      have : Module.rank R (span R (Set.range b)) = #(Set.range b) := rank_span hb\n      rwa [← lift_inj, mk_range_eq_of_injective hb.injective, Cardinal.mk_fintype, lift_natCast,\n        lift_eq_nat_iff] at this)\n\n"}
{"name":"finrank_span_set_eq_card","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ns : Set M\ninst✝ : Fintype ↑s\nhs : LinearIndependent R Subtype.val\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem (Submodule.span R s) x)) s.toFinset.card","decl":"theorem finrank_span_set_eq_card {s : Set M} [Fintype s] (hs : LinearIndependent R ((↑) : s → M)) :\n    finrank R (span R s) = s.toFinset.card :=\n  finrank_eq_of_rank_eq\n    (by\n      have : Module.rank R (span R s) = #s := rank_span_set hs\n      rwa [Cardinal.mk_fintype, ← Set.toFinset_card] at this)\n\n"}
{"name":"finrank_span_finset_eq_card","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\ns : Finset M\nhs : LinearIndependent R Subtype.val\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem (Submodule.span R ↑s) x)) s.card","decl":"theorem finrank_span_finset_eq_card {s : Finset M} (hs : LinearIndependent R ((↑) : s → M)) :\n    finrank R (span R (s : Set M)) = s.card := by\n  convert finrank_span_set_eq_card (s := (s : Set M)) hs\n  ext\n  simp\n\n"}
{"name":"span_lt_of_subset_of_card_lt_finrank","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ns : Set M\ninst✝ : Fintype ↑s\nt : Submodule R M\nsubset : HasSubset.Subset s ↑t\ncard_lt : LT.lt s.toFinset.card (Module.finrank R (Subtype fun x => Membership.mem t x))\n⊢ LT.lt (Submodule.span R s) t","decl":"theorem span_lt_of_subset_of_card_lt_finrank {s : Set M} [Fintype s] {t : Submodule R M}\n    (subset : s ⊆ t) (card_lt : s.toFinset.card < finrank R t) : span R s < t :=\n  lt_of_le_of_finrank_lt_finrank (span_le.mpr subset)\n    (lt_of_le_of_lt (finrank_span_le_card _) card_lt)\n\n"}
{"name":"span_lt_top_of_card_lt_finrank","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ns : Set M\ninst✝ : Fintype ↑s\ncard_lt : LT.lt s.toFinset.card (Module.finrank R M)\n⊢ LT.lt (Submodule.span R s) Top.top","decl":"theorem span_lt_top_of_card_lt_finrank {s : Set M} [Fintype s]\n    (card_lt : s.toFinset.card < finrank R M) : span R s < ⊤ :=\n  lt_top_of_finrank_lt_finrank (lt_of_le_of_lt (finrank_span_le_card _) card_lt)\n\n"}
{"name":"finrank_le_of_span_eq_top","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type u_2\ninst✝ : Fintype ι\nv : ι → M\nhv : Eq (Submodule.span R (Set.range v)) Top.top\n⊢ LE.le (Module.finrank R M) (Fintype.card ι)","decl":"lemma finrank_le_of_span_eq_top {ι : Type*} [Fintype ι] {v : ι → M}\n    (hv : Submodule.span R (Set.range v) = ⊤) : finrank R M ≤ Fintype.card ι := by\n  classical\n  rw [← finrank_top, ← hv]\n  exact (finrank_span_le_card _).trans (by convert Fintype.card_range_le v; rw [Set.toFinset_card])\n\n"}
{"name":"Subalgebra.rank_toSubmodule","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"F : Type u_2\nE : Type u_3\ninst✝² : CommSemiring F\ninst✝¹ : Semiring E\ninst✝ : Algebra F E\nS : Subalgebra F E\n⊢ Eq (Module.rank F (Subtype fun x => Membership.mem (Subalgebra.toSubmodule S) x)) (Module.rank F (Subtype fun x => Membership.mem S x))","decl":"@[simp]\ntheorem Subalgebra.rank_toSubmodule (S : Subalgebra F E) :\n    Module.rank F (Subalgebra.toSubmodule S) = Module.rank F S :=\n  rfl\n\n"}
{"name":"Subalgebra.finrank_toSubmodule","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"F : Type u_2\nE : Type u_3\ninst✝² : CommSemiring F\ninst✝¹ : Semiring E\ninst✝ : Algebra F E\nS : Subalgebra F E\n⊢ Eq (Module.finrank F (Subtype fun x => Membership.mem (Subalgebra.toSubmodule S) x)) (Module.finrank F (Subtype fun x => Membership.mem S x))","decl":"@[simp]\ntheorem Subalgebra.finrank_toSubmodule (S : Subalgebra F E) :\n    finrank F (Subalgebra.toSubmodule S) = finrank F S :=\n  rfl\n\n"}
{"name":"subalgebra_top_rank_eq_submodule_top_rank","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"F : Type u_2\nE : Type u_3\ninst✝² : CommSemiring F\ninst✝¹ : Semiring E\ninst✝ : Algebra F E\n⊢ Eq (Module.rank F (Subtype fun x => Membership.mem Top.top x)) (Module.rank F (Subtype fun x => Membership.mem Top.top x))","decl":"theorem subalgebra_top_rank_eq_submodule_top_rank :\n    Module.rank F (⊤ : Subalgebra F E) = Module.rank F (⊤ : Submodule F E) := by\n  rw [← Algebra.top_toSubmodule]\n  rfl\n\n"}
{"name":"subalgebra_top_finrank_eq_submodule_top_finrank","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"F : Type u_2\nE : Type u_3\ninst✝² : CommSemiring F\ninst✝¹ : Semiring E\ninst✝ : Algebra F E\n⊢ Eq (Module.finrank F (Subtype fun x => Membership.mem Top.top x)) (Module.finrank F (Subtype fun x => Membership.mem Top.top x))","decl":"theorem subalgebra_top_finrank_eq_submodule_top_finrank :\n    finrank F (⊤ : Subalgebra F E) = finrank F (⊤ : Submodule F E) := by\n  rw [← Algebra.top_toSubmodule]\n  rfl\n\n"}
{"name":"Subalgebra.rank_top","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"F : Type u_2\nE : Type u_3\ninst✝² : CommSemiring F\ninst✝¹ : Semiring E\ninst✝ : Algebra F E\n⊢ Eq (Module.rank F (Subtype fun x => Membership.mem Top.top x)) (Module.rank F E)","decl":"theorem Subalgebra.rank_top : Module.rank F (⊤ : Subalgebra F E) = Module.rank F E := by\n  rw [subalgebra_top_rank_eq_submodule_top_rank]\n  exact _root_.rank_top F E\n\n"}
{"name":"Subalgebra.rank_bot","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"F : Type u_2\nE : Type u_3\ninst✝⁵ : CommRing F\ninst✝⁴ : Ring E\ninst✝³ : Algebra F E\ninst✝² : StrongRankCondition F\ninst✝¹ : NoZeroSMulDivisors F E\ninst✝ : Nontrivial E\n⊢ Eq (Module.rank F (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[simp]\ntheorem Subalgebra.rank_bot : Module.rank F (⊥ : Subalgebra F E) = 1 :=\n  (Subalgebra.toSubmoduleEquiv (⊥ : Subalgebra F E)).symm.rank_eq.trans <| by\n    rw [Algebra.toSubmodule_bot, one_eq_span, rank_span_set, mk_singleton _]\n    letI := Module.nontrivial F E\n    exact linearIndependent_singleton one_ne_zero\n\n"}
{"name":"Subalgebra.finrank_bot","module":"Mathlib.LinearAlgebra.Dimension.Constructions","initialProofState":"F : Type u_2\nE : Type u_3\ninst✝⁵ : CommRing F\ninst✝⁴ : Ring E\ninst✝³ : Algebra F E\ninst✝² : StrongRankCondition F\ninst✝¹ : NoZeroSMulDivisors F E\ninst✝ : Nontrivial E\n⊢ Eq (Module.finrank F (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[simp]\ntheorem Subalgebra.finrank_bot : finrank F (⊥ : Subalgebra F E) = 1 :=\n  finrank_eq_of_rank_eq (by simp)\n\n"}
