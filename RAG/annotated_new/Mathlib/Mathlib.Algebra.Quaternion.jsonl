{"name":"QuaternionAlgebra.mk.inj","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\na b c re✝ imI✝ imJ✝ imK✝ re imI imJ imK : R\nx✝ : Eq { re := re✝, imI := imI✝, imJ := imJ✝, imK := imK✝ } { re := re, imI := imI, imJ := imJ, imK := imK }\n⊢ And (Eq re✝ re) (And (Eq imI✝ imI) (And (Eq imJ✝ imJ) (Eq imK✝ imK)))","decl":"/-- Quaternion algebra over a type with fixed coefficients where $i^2 = a + bi$ and $j^2 = c$,\ndenoted as `ℍ[R,a,b]`.\nImplemented as a structure with four fields: `re`, `imI`, `imJ`, and `imK`. -/\n@[ext]\nstructure QuaternionAlgebra (R : Type*) (a b c : R) where\n  /-- Real part of a quaternion. -/\n  re : R\n  /-- First imaginary part (i) of a quaternion. -/\n  imI : R\n  /-- Second imaginary part (j) of a quaternion. -/\n  imJ : R\n  /-- Third imaginary part (k) of a quaternion. -/\n  imK : R\n\n"}
{"name":"QuaternionAlgebra.ext_iff","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\na b c : R\nx y : QuaternionAlgebra R a b c\n⊢ Iff (Eq x y) (And (Eq x.re y.re) (And (Eq x.imI y.imI) (And (Eq x.imJ y.imJ) (Eq x.imK y.imK))))","decl":"/-- Quaternion algebra over a type with fixed coefficients where $i^2 = a + bi$ and $j^2 = c$,\ndenoted as `ℍ[R,a,b]`.\nImplemented as a structure with four fields: `re`, `imI`, `imJ`, and `imK`. -/\n@[ext]\nstructure QuaternionAlgebra (R : Type*) (a b c : R) where\n  /-- Real part of a quaternion. -/\n  re : R\n  /-- First imaginary part (i) of a quaternion. -/\n  imI : R\n  /-- Second imaginary part (j) of a quaternion. -/\n  imJ : R\n  /-- Third imaginary part (k) of a quaternion. -/\n  imK : R\n\n"}
{"name":"QuaternionAlgebra.mk.injEq","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\na b c re✝ imI✝ imJ✝ imK✝ re imI imJ imK : R\n⊢ Eq (Eq { re := re✝, imI := imI✝, imJ := imJ✝, imK := imK✝ } { re := re, imI := imI, imJ := imJ, imK := imK }) (And (Eq re✝ re) (And (Eq imI✝ imI) (And (Eq imJ✝ imJ) (Eq imK✝ imK))))","decl":"/-- Quaternion algebra over a type with fixed coefficients where $i^2 = a + bi$ and $j^2 = c$,\ndenoted as `ℍ[R,a,b]`.\nImplemented as a structure with four fields: `re`, `imI`, `imJ`, and `imK`. -/\n@[ext]\nstructure QuaternionAlgebra (R : Type*) (a b c : R) where\n  /-- Real part of a quaternion. -/\n  re : R\n  /-- First imaginary part (i) of a quaternion. -/\n  imI : R\n  /-- Second imaginary part (j) of a quaternion. -/\n  imJ : R\n  /-- Third imaginary part (k) of a quaternion. -/\n  imK : R\n\n"}
{"name":"QuaternionAlgebra.ext","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\na b c : R\nx y : QuaternionAlgebra R a b c\nre : Eq x.re y.re\nimI : Eq x.imI y.imI\nimJ : Eq x.imJ y.imJ\nimK : Eq x.imK y.imK\n⊢ Eq x y","decl":"/-- Quaternion algebra over a type with fixed coefficients where $i^2 = a + bi$ and $j^2 = c$,\ndenoted as `ℍ[R,a,b]`.\nImplemented as a structure with four fields: `re`, `imI`, `imJ`, and `imK`. -/\n@[ext]\nstructure QuaternionAlgebra (R : Type*) (a b c : R) where\n  /-- Real part of a quaternion. -/\n  re : R\n  /-- First imaginary part (i) of a quaternion. -/\n  imI : R\n  /-- Second imaginary part (j) of a quaternion. -/\n  imJ : R\n  /-- Third imaginary part (k) of a quaternion. -/\n  imK : R\n\n"}
{"name":"QuaternionAlgebra.mk.sizeOf_spec","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\na b c : R\ninst✝ : SizeOf R\nre imI imJ imK : R\n⊢ Eq (SizeOf.sizeOf { re := re, imI := imI, imJ := imJ, imK := imK }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf re)) (SizeOf.sizeOf imI)) (SizeOf.sizeOf imJ)) (SizeOf.sizeOf imK))","decl":"/-- Quaternion algebra over a type with fixed coefficients where $i^2 = a + bi$ and $j^2 = c$,\ndenoted as `ℍ[R,a,b]`.\nImplemented as a structure with four fields: `re`, `imI`, `imJ`, and `imK`. -/\n@[ext]\nstructure QuaternionAlgebra (R : Type*) (a b c : R) where\n  /-- Real part of a quaternion. -/\n  re : R\n  /-- First imaginary part (i) of a quaternion. -/\n  imI : R\n  /-- Second imaginary part (j) of a quaternion. -/\n  imJ : R\n  /-- Third imaginary part (k) of a quaternion. -/\n  imK : R\n\n"}
{"name":"QuaternionAlgebra.equivProd_symm_apply_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\na : Prod R (Prod R (Prod R R))\n⊢ Eq ((QuaternionAlgebra.equivProd c₁ c₂ c₃).symm a).re a.1","decl":"/-- The equivalence between a quaternion algebra over `R` and `R × R × R × R`. -/\n@[simps]\ndef equivProd {R : Type*} (c₁ c₂ c₃: R) : ℍ[R,c₁,c₂,c₃] ≃ R × R × R × R where\n  toFun a := ⟨a.1, a.2, a.3, a.4⟩\n  invFun a := ⟨a.1, a.2.1, a.2.2.1, a.2.2.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"QuaternionAlgebra.equivProd_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq ((QuaternionAlgebra.equivProd c₁ c₂ c₃) a) { fst := a.re, snd := { fst := a.imI, snd := { fst := a.imJ, snd := a.imK } } }","decl":"/-- The equivalence between a quaternion algebra over `R` and `R × R × R × R`. -/\n@[simps]\ndef equivProd {R : Type*} (c₁ c₂ c₃: R) : ℍ[R,c₁,c₂,c₃] ≃ R × R × R × R where\n  toFun a := ⟨a.1, a.2, a.3, a.4⟩\n  invFun a := ⟨a.1, a.2.1, a.2.2.1, a.2.2.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"QuaternionAlgebra.equivProd_symm_apply_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\na : Prod R (Prod R (Prod R R))\n⊢ Eq ((QuaternionAlgebra.equivProd c₁ c₂ c₃).symm a).imK a.2.2.2","decl":"/-- The equivalence between a quaternion algebra over `R` and `R × R × R × R`. -/\n@[simps]\ndef equivProd {R : Type*} (c₁ c₂ c₃: R) : ℍ[R,c₁,c₂,c₃] ≃ R × R × R × R where\n  toFun a := ⟨a.1, a.2, a.3, a.4⟩\n  invFun a := ⟨a.1, a.2.1, a.2.2.1, a.2.2.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"QuaternionAlgebra.equivProd_symm_apply_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\na : Prod R (Prod R (Prod R R))\n⊢ Eq ((QuaternionAlgebra.equivProd c₁ c₂ c₃).symm a).imI a.2.1","decl":"/-- The equivalence between a quaternion algebra over `R` and `R × R × R × R`. -/\n@[simps]\ndef equivProd {R : Type*} (c₁ c₂ c₃: R) : ℍ[R,c₁,c₂,c₃] ≃ R × R × R × R where\n  toFun a := ⟨a.1, a.2, a.3, a.4⟩\n  invFun a := ⟨a.1, a.2.1, a.2.2.1, a.2.2.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"QuaternionAlgebra.equivProd_symm_apply_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\na : Prod R (Prod R (Prod R R))\n⊢ Eq ((QuaternionAlgebra.equivProd c₁ c₂ c₃).symm a).imJ a.2.2.1","decl":"/-- The equivalence between a quaternion algebra over `R` and `R × R × R × R`. -/\n@[simps]\ndef equivProd {R : Type*} (c₁ c₂ c₃: R) : ℍ[R,c₁,c₂,c₃] ≃ R × R × R × R where\n  toFun a := ⟨a.1, a.2, a.3, a.4⟩\n  invFun a := ⟨a.1, a.2.1, a.2.2.1, a.2.2.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"QuaternionAlgebra.equivTuple_symm_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\na : Fin 4 → R\n⊢ Eq ((QuaternionAlgebra.equivTuple c₁ c₂ c₃).symm a) { re := a 0, imI := a 1, imJ := a 2, imK := a 3 }","decl":"/-- The equivalence between a quaternion algebra over `R` and `Fin 4 → R`. -/\n@[simps symm_apply]\ndef equivTuple {R : Type*} (c₁ c₂ c₃: R) : ℍ[R,c₁,c₂,c₃] ≃ (Fin 4 → R) where\n  toFun a := ![a.1, a.2, a.3, a.4]\n  invFun a := ⟨a 0, a 1, a 2, a 3⟩\n  left_inv _ := rfl\n  right_inv f := by ext ⟨_, _ | _ | _ | _ | _ | ⟨⟩⟩ <;> rfl\n\n"}
{"name":"QuaternionAlgebra.equivTuple_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\nx : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq ((QuaternionAlgebra.equivTuple c₁ c₂ c₃) x) (Matrix.vecCons x.re (Matrix.vecCons x.imI (Matrix.vecCons x.imJ (Matrix.vecCons x.imK Matrix.vecEmpty))))","decl":"@[simp]\ntheorem equivTuple_apply {R : Type*} (c₁ c₂ c₃: R) (x : ℍ[R,c₁,c₂,c₃]) :\n    equivTuple c₁ c₂ c₃ x = ![x.re, x.imI, x.imJ, x.imK] :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.mk.eta","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq { re := a.re, imI := a.imI, imJ := a.imJ, imK := a.imK } a","decl":"@[simp]\ntheorem mk.eta {R : Type*} {c₁ c₂ c₃} (a : ℍ[R,c₁,c₂,c₃]) : mk a.1 a.2 a.3 a.4 = a := rfl\n\n"}
{"name":"QuaternionAlgebra.instSubsingleton","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Subsingleton R\n⊢ Subsingleton (QuaternionAlgebra R c₁ c₂ c₃)","decl":"instance [Subsingleton R] : Subsingleton ℍ[R, c₁, c₂, c₃] := (equivTuple c₁ c₂ c₃).subsingleton\n"}
{"name":"QuaternionAlgebra.instNontrivial","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Nontrivial R\n⊢ Nontrivial (QuaternionAlgebra R c₁ c₂ c₃)","decl":"instance [Nontrivial R] : Nontrivial ℍ[R, c₁, c₂, c₃] := (equivTuple c₁ c₂ c₃).surjective.nontrivial\n\n"}
{"name":"QuaternionAlgebra.im_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Zero R\n⊢ Eq a.im.re 0","decl":"@[simp]\ntheorem im_re : a.im.re = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.im_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Zero R\n⊢ Eq a.im.imI a.imI","decl":"@[simp]\ntheorem im_imI : a.im.imI = a.imI :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.im_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Zero R\n⊢ Eq a.im.imJ a.imJ","decl":"@[simp]\ntheorem im_imJ : a.im.imJ = a.imJ :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.im_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Zero R\n⊢ Eq a.im.imK a.imK","decl":"@[simp]\ntheorem im_imK : a.im.imK = a.imK :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.im_idem","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Zero R\n⊢ Eq a.im.im a.im","decl":"@[simp]\ntheorem im_idem : a.im.im = a.im :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.coe_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x : R\ninst✝ : Zero R\n⊢ Eq (↑x).re x","decl":"@[simp, norm_cast]\ntheorem coe_re : (x : ℍ[R,c₁,c₂,c₃]).re = x := rfl\n\n"}
{"name":"QuaternionAlgebra.coe_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x : R\ninst✝ : Zero R\n⊢ Eq (↑x).imI 0","decl":"@[simp, norm_cast]\ntheorem coe_imI : (x : ℍ[R,c₁,c₂,c₃]).imI = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.coe_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x : R\ninst✝ : Zero R\n⊢ Eq (↑x).imJ 0","decl":"@[simp, norm_cast]\ntheorem coe_imJ : (x : ℍ[R,c₁,c₂,c₃]).imJ = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.coe_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x : R\ninst✝ : Zero R\n⊢ Eq (↑x).imK 0","decl":"@[simp, norm_cast]\ntheorem coe_imK : (x : ℍ[R,c₁,c₂,c₃]).imK = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.coe_injective","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Zero R\n⊢ Function.Injective QuaternionAlgebra.coe","decl":"theorem coe_injective : Function.Injective (coe : R → ℍ[R,c₁,c₂,c₃]) := fun _ _ h => congr_arg re h\n\n"}
{"name":"QuaternionAlgebra.coe_inj","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Zero R\nx y : R\n⊢ Iff (Eq ↑x ↑y) (Eq x y)","decl":"@[simp]\ntheorem coe_inj {x y : R} : (x : ℍ[R,c₁,c₂,c₃]) = y ↔ x = y :=\n  coe_injective.eq_iff\n\n-- Porting note: removed `simps`, added simp lemmas manually.\n-- Should adjust `simps` to name properly, i.e. as `zero_re` rather than `instZero_zero_re`.\n"}
{"name":"QuaternionAlgebra.zero_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Zero R\n⊢ Eq (QuaternionAlgebra.re 0) 0","decl":"@[simp] theorem zero_re : (0 : ℍ[R,c₁,c₂,c₃]).re = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.zero_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Zero R\n⊢ Eq (QuaternionAlgebra.imI 0) 0","decl":"@[simp] theorem zero_imI : (0 : ℍ[R,c₁,c₂,c₃]).imI = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.zero_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Zero R\n⊢ Eq (QuaternionAlgebra.imJ 0) 0","decl":"@[simp] theorem zero_imJ : (0 : ℍ[R,c₁,c₂,c₃]).imJ = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.zero_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Zero R\n⊢ Eq (QuaternionAlgebra.imK 0) 0","decl":"@[simp] theorem zero_imK : (0 : ℍ[R,c₁,c₂,c₃]).imK = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.zero_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Zero R\n⊢ Eq (QuaternionAlgebra.im 0) 0","decl":"@[simp] theorem zero_im : (0 : ℍ[R,c₁,c₂,c₃]).im = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.coe_zero","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Zero R\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : R) : ℍ[R,c₁,c₂,c₃]) = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.one_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq (QuaternionAlgebra.re 1) 1","decl":"@[simp] theorem one_re : (1 : ℍ[R,c₁,c₂,c₃]).re = 1 := rfl\n\n"}
{"name":"QuaternionAlgebra.one_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq (QuaternionAlgebra.imI 1) 0","decl":"@[simp] theorem one_imI : (1 : ℍ[R,c₁,c₂,c₃]).imI = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.one_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq (QuaternionAlgebra.imJ 1) 0","decl":"@[simp] theorem one_imJ : (1 : ℍ[R,c₁,c₂,c₃]).imJ = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.one_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq (QuaternionAlgebra.imK 1) 0","decl":"@[simp] theorem one_imK : (1 : ℍ[R,c₁,c₂,c₃]).imK = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.one_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq (QuaternionAlgebra.im 1) 0","decl":"@[simp] theorem one_im : (1 : ℍ[R,c₁,c₂,c₃]).im = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.coe_one","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ((1 : R) : ℍ[R,c₁,c₂,c₃]) = 1 := rfl\n\n"}
{"name":"QuaternionAlgebra.add_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Add R\n⊢ Eq (HAdd.hAdd a b).re (HAdd.hAdd a.re b.re)","decl":"@[simp] theorem add_re : (a + b).re = a.re + b.re := rfl\n\n"}
{"name":"QuaternionAlgebra.add_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Add R\n⊢ Eq (HAdd.hAdd a b).imI (HAdd.hAdd a.imI b.imI)","decl":"@[simp] theorem add_imI : (a + b).imI = a.imI + b.imI := rfl\n\n"}
{"name":"QuaternionAlgebra.add_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Add R\n⊢ Eq (HAdd.hAdd a b).imJ (HAdd.hAdd a.imJ b.imJ)","decl":"@[simp] theorem add_imJ : (a + b).imJ = a.imJ + b.imJ := rfl\n\n"}
{"name":"QuaternionAlgebra.add_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Add R\n⊢ Eq (HAdd.hAdd a b).imK (HAdd.hAdd a.imK b.imK)","decl":"@[simp] theorem add_imK : (a + b).imK = a.imK + b.imK := rfl\n\n"}
{"name":"QuaternionAlgebra.mk_add_mk","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Add R\na₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : R\n⊢ Eq (HAdd.hAdd { re := a₁, imI := a₂, imJ := a₃, imK := a₄ } { re := b₁, imI := b₂, imJ := b₃, imK := b₄ }) { re := HAdd.hAdd a₁ b₁, imI := HAdd.hAdd a₂ b₂, imJ := HAdd.hAdd a₃ b₃, imK := HAdd.hAdd a₄ b₄ }","decl":"@[simp]\ntheorem mk_add_mk (a₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : R) :\n    (mk a₁ a₂ a₃ a₄ : ℍ[R,c₁,c₂,c₃]) + mk b₁ b₂ b₃ b₄ =\n    mk (a₁ + b₁) (a₂ + b₂) (a₃ + b₃) (a₄ + b₄) :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.add_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddZeroClass R\n⊢ Eq (HAdd.hAdd a b).im (HAdd.hAdd a.im b.im)","decl":"@[simp] theorem add_im : (a + b).im = a.im + b.im :=\n  QuaternionAlgebra.ext (zero_add _).symm rfl rfl rfl\n\n"}
{"name":"QuaternionAlgebra.coe_add","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x y : R\ninst✝ : AddZeroClass R\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_add : ((x + y : R) : ℍ[R,c₁,c₂,c₃]) = x + y := by ext <;> simp\n\n"}
{"name":"QuaternionAlgebra.neg_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Neg R\n⊢ Eq (Neg.neg a).re (Neg.neg a.re)","decl":"@[simp] theorem neg_re : (-a).re = -a.re := rfl\n\n"}
{"name":"QuaternionAlgebra.neg_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Neg R\n⊢ Eq (Neg.neg a).imI (Neg.neg a.imI)","decl":"@[simp] theorem neg_imI : (-a).imI = -a.imI := rfl\n\n"}
{"name":"QuaternionAlgebra.neg_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Neg R\n⊢ Eq (Neg.neg a).imJ (Neg.neg a.imJ)","decl":"@[simp] theorem neg_imJ : (-a).imJ = -a.imJ := rfl\n\n"}
{"name":"QuaternionAlgebra.neg_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Neg R\n⊢ Eq (Neg.neg a).imK (Neg.neg a.imK)","decl":"@[simp] theorem neg_imK : (-a).imK = -a.imK := rfl\n\n"}
{"name":"QuaternionAlgebra.neg_mk","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Neg R\na₁ a₂ a₃ a₄ : R\n⊢ Eq (Neg.neg { re := a₁, imI := a₂, imJ := a₃, imK := a₄ }) { re := Neg.neg a₁, imI := Neg.neg a₂, imJ := Neg.neg a₃, imK := Neg.neg a₄ }","decl":"@[simp]\ntheorem neg_mk (a₁ a₂ a₃ a₄ : R) : -(mk a₁ a₂ a₃ a₄ : ℍ[R,c₁,c₂,c₃]) = ⟨-a₁, -a₂, -a₃, -a₄⟩ :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.neg_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddGroup R\n⊢ Eq (Neg.neg a).im (Neg.neg a.im)","decl":"@[simp] theorem neg_im : (-a).im = -a.im :=\n  QuaternionAlgebra.ext neg_zero.symm rfl rfl rfl\n\n"}
{"name":"QuaternionAlgebra.coe_neg","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x : R\ninst✝ : AddGroup R\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[simp, norm_cast]\ntheorem coe_neg : ((-x : R) : ℍ[R,c₁,c₂,c₃]) = -x := by ext <;> simp\n\n"}
{"name":"QuaternionAlgebra.sub_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddGroup R\n⊢ Eq (HSub.hSub a b).re (HSub.hSub a.re b.re)","decl":"@[simp] theorem sub_re : (a - b).re = a.re - b.re := rfl\n\n"}
{"name":"QuaternionAlgebra.sub_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddGroup R\n⊢ Eq (HSub.hSub a b).imI (HSub.hSub a.imI b.imI)","decl":"@[simp] theorem sub_imI : (a - b).imI = a.imI - b.imI := rfl\n\n"}
{"name":"QuaternionAlgebra.sub_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddGroup R\n⊢ Eq (HSub.hSub a b).imJ (HSub.hSub a.imJ b.imJ)","decl":"@[simp] theorem sub_imJ : (a - b).imJ = a.imJ - b.imJ := rfl\n\n"}
{"name":"QuaternionAlgebra.sub_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddGroup R\n⊢ Eq (HSub.hSub a b).imK (HSub.hSub a.imK b.imK)","decl":"@[simp] theorem sub_imK : (a - b).imK = a.imK - b.imK := rfl\n\n"}
{"name":"QuaternionAlgebra.sub_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddGroup R\n⊢ Eq (HSub.hSub a b).im (HSub.hSub a.im b.im)","decl":"@[simp] theorem sub_im : (a - b).im = a.im - b.im :=\n  QuaternionAlgebra.ext (sub_zero _).symm rfl rfl rfl\n\n"}
{"name":"QuaternionAlgebra.mk_sub_mk","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddGroup R\na₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : R\n⊢ Eq (HSub.hSub { re := a₁, imI := a₂, imJ := a₃, imK := a₄ } { re := b₁, imI := b₂, imJ := b₃, imK := b₄ }) { re := HSub.hSub a₁ b₁, imI := HSub.hSub a₂ b₂, imJ := HSub.hSub a₃ b₃, imK := HSub.hSub a₄ b₄ }","decl":"@[simp]\ntheorem mk_sub_mk (a₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : R) :\n    (mk a₁ a₂ a₃ a₄ : ℍ[R,c₁,c₂,c₃]) - mk b₁ b₂ b₃ b₄ =\n    mk (a₁ - b₁) (a₂ - b₂) (a₃ - b₃) (a₄ - b₄) :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.coe_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x : R\ninst✝ : AddGroup R\n⊢ Eq (↑x).im 0","decl":"@[simp, norm_cast]\ntheorem coe_im : (x : ℍ[R,c₁,c₂,c₃]).im = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.re_add_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddGroup R\n⊢ Eq (HAdd.hAdd (↑a.re) a.im) a","decl":"@[simp]\ntheorem re_add_im : ↑a.re + a.im = a :=\n  QuaternionAlgebra.ext (add_zero _) (zero_add _) (zero_add _) (zero_add _)\n\n"}
{"name":"QuaternionAlgebra.sub_self_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddGroup R\n⊢ Eq (HSub.hSub a a.im) ↑a.re","decl":"@[simp]\ntheorem sub_self_im : a - a.im = a.re :=\n  QuaternionAlgebra.ext (sub_zero _) (sub_self _) (sub_self _) (sub_self _)\n\n"}
{"name":"QuaternionAlgebra.sub_self_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : AddGroup R\n⊢ Eq (HSub.hSub a ↑a.re) a.im","decl":"@[simp]\ntheorem sub_self_re : a - a.re = a.im :=\n  QuaternionAlgebra.ext (sub_self _) (sub_zero _) (sub_zero _) (sub_zero _)\n\n"}
{"name":"QuaternionAlgebra.mul_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Ring R\n⊢ Eq (HMul.hMul a b).re (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul a.re b.re) (HMul.hMul (HMul.hMul c₁ a.imI) b.imI)) (HMul.hMul (HMul.hMul c₃ a.imJ) b.imJ)) (HMul.hMul (HMul.hMul (HMul.hMul c₂ c₃) a.imJ) b.imK)) (HMul.hMul (HMul.hMul (HMul.hMul c₁ c₃) a.imK) b.imK))","decl":"@[simp]\ntheorem mul_re : (a * b).re = a.1 * b.1 + c₁ * a.2 * b.2 + c₃ * a.3 * b.3 +\n    c₂ * c₃ * a.3 * b.4 - c₁ * c₃ * a.4 * b.4 := rfl\n\n"}
{"name":"QuaternionAlgebra.mul_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Ring R\n⊢ Eq (HMul.hMul a b).imI (HAdd.hAdd (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HMul.hMul a.re b.imI) (HMul.hMul a.imI b.re)) (HMul.hMul (HMul.hMul c₂ a.imI) b.imI)) (HMul.hMul (HMul.hMul c₃ a.imJ) b.imK)) (HMul.hMul (HMul.hMul c₃ a.imK) b.imJ))","decl":"@[simp]\ntheorem mul_imI : (a * b).imI = a.1 * b.2 + a.2 * b.1 +\n    c₂ * a.2 * b.2 - c₃ * a.3 * b.4 + c₃ * a.4 * b.3 := rfl\n\n"}
{"name":"QuaternionAlgebra.mul_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Ring R\n⊢ Eq (HMul.hMul a b).imJ (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul a.re b.imJ) (HMul.hMul (HMul.hMul c₁ a.imI) b.imK)) (HMul.hMul a.imJ b.re)) (HMul.hMul (HMul.hMul c₂ a.imJ) b.imI)) (HMul.hMul (HMul.hMul c₁ a.imK) b.imI))","decl":"@[simp]\ntheorem mul_imJ : (a * b).imJ = a.1 * b.3 + c₁ * a.2 * b.4 + a.3 * b.1 +\n    c₂ * a.3 * b.2 - c₁ * a.4 * b.2 := rfl\n\n"}
{"name":"QuaternionAlgebra.mul_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na b : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : Ring R\n⊢ Eq (HMul.hMul a b).imK (HAdd.hAdd (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HMul.hMul a.re b.imK) (HMul.hMul a.imI b.imJ)) (HMul.hMul (HMul.hMul c₂ a.imI) b.imK)) (HMul.hMul a.imJ b.imI)) (HMul.hMul a.imK b.re))","decl":"@[simp]\ntheorem mul_imK : (a * b).imK = a.1 * b.4 + a.2 * b.3 +\n    c₂ * a.2 * b.4 - a.3 * b.2 + a.4 * b.1 := rfl\n\n"}
{"name":"QuaternionAlgebra.mk_mul_mk","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : Ring R\na₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : R\n⊢ Eq (HMul.hMul { re := a₁, imI := a₂, imJ := a₃, imK := a₄ } { re := b₁, imI := b₂, imJ := b₃, imK := b₄ }) { re := HSub.hSub (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₁ b₁) (HMul.hMul (HMul.hMul c₁ a₂) b₂)) (HMul.hMul (HMul.hMul c₃ a₃) b₃)) (HMul.hMul (HMul.hMul (HMul.hMul c₂ c₃) a₃) b₄)) (HMul.hMul (HMul.hMul (HMul.hMul c₁ c₃) a₄) b₄), imI := HAdd.hAdd (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₁ b₂) (HMul.hMul a₂ b₁)) (HMul.hMul (HMul.hMul c₂ a₂) b₂)) (HMul.hMul (HMul.hMul c₃ a₃) b₄)) (HMul.hMul (HMul.hMul c₃ a₄) b₃), imJ := HSub.hSub (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₁ b₃) (HMul.hMul (HMul.hMul c₁ a₂) b₄)) (HMul.hMul a₃ b₁)) (HMul.hMul (HMul.hMul c₂ a₃) b₂)) (HMul.hMul (HMul.hMul c₁ a₄) b₂), imK := HAdd.hAdd (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₁ b₄) (HMul.hMul a₂ b₃)) (HMul.hMul (HMul.hMul c₂ a₂) b₄)) (HMul.hMul a₃ b₂)) (HMul.hMul a₄ b₁) }","decl":"@[simp]\ntheorem mk_mul_mk (a₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : R) :\n    (mk a₁ a₂ a₃ a₄ : ℍ[R,c₁,c₂,c₃]) * mk b₁ b₂ b₃ b₄ =\n    mk\n      (a₁ * b₁ + c₁ * a₂ * b₂ + c₃ * a₃ * b₃ + c₂ * c₃ * a₃ * b₄ - c₁ * c₃ * a₄ * b₄)\n      (a₁ * b₂ + a₂ * b₁ + c₂ * a₂ * b₂ - c₃ * a₃ * b₄ + c₃ * a₄ * b₃)\n      (a₁ * b₃ + c₁ * a₂ * b₄ + a₃ * b₁ + c₂ * a₃ * b₂ - c₁ * a₄ * b₂)\n      (a₁ * b₄ + a₂ * b₃ + c₂ * a₂ * b₄ - a₃ * b₂ + a₄ * b₁) :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.instIsScalarTower","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nT : Type u_2\nR : Type u_3\nc₁ c₂ c₃ : R\ninst✝³ : SMul S R\ninst✝² : SMul T R\ninst✝¹ : SMul S T\ninst✝ : IsScalarTower S T R\n⊢ IsScalarTower S T (QuaternionAlgebra R c₁ c₂ c₃)","decl":"instance [SMul S T] [IsScalarTower S T R] : IsScalarTower S T ℍ[R,c₁,c₂,c₃] where\n  smul_assoc s t x := by ext <;> exact smul_assoc _ _ _\n\n"}
{"name":"QuaternionAlgebra.instSMulCommClass","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nT : Type u_2\nR : Type u_3\nc₁ c₂ c₃ : R\ninst✝² : SMul S R\ninst✝¹ : SMul T R\ninst✝ : SMulCommClass S T R\n⊢ SMulCommClass S T (QuaternionAlgebra R c₁ c₂ c₃)","decl":"instance [SMulCommClass S T R] : SMulCommClass S T ℍ[R,c₁,c₂,c₃] where\n  smul_comm s t x := by ext <;> exact smul_comm _ _ _\n\n"}
{"name":"QuaternionAlgebra.smul_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : SMul S R\ns : S\n⊢ Eq (HSMul.hSMul s a).re (HSMul.hSMul s a.re)","decl":"@[simp] theorem smul_re : (s • a).re = s • a.re := rfl\n\n"}
{"name":"QuaternionAlgebra.smul_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : SMul S R\ns : S\n⊢ Eq (HSMul.hSMul s a).imI (HSMul.hSMul s a.imI)","decl":"@[simp] theorem smul_imI : (s • a).imI = s • a.imI := rfl\n\n"}
{"name":"QuaternionAlgebra.smul_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : SMul S R\ns : S\n⊢ Eq (HSMul.hSMul s a).imJ (HSMul.hSMul s a.imJ)","decl":"@[simp] theorem smul_imJ : (s • a).imJ = s • a.imJ := rfl\n\n"}
{"name":"QuaternionAlgebra.smul_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : SMul S R\ns : S\n⊢ Eq (HSMul.hSMul s a).imK (HSMul.hSMul s a.imK)","decl":"@[simp] theorem smul_imK : (s • a).imK = s • a.imK := rfl\n\n"}
{"name":"QuaternionAlgebra.smul_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : SMulZeroClass S R\ns : S\n⊢ Eq (HSMul.hSMul s a).im (HSMul.hSMul s a.im)","decl":"@[simp] theorem smul_im {S} [CommRing R] [SMulZeroClass S R] (s : S) : (s • a).im = s • a.im :=\n  QuaternionAlgebra.ext (smul_zero s).symm rfl rfl rfl\n\n"}
{"name":"QuaternionAlgebra.smul_mk","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : SMul S R\ns : S\nre im_i im_j im_k : R\n⊢ Eq (HSMul.hSMul s { re := re, imI := im_i, imJ := im_j, imK := im_k }) { re := HSMul.hSMul s re, imI := HSMul.hSMul s im_i, imJ := HSMul.hSMul s im_j, imK := HSMul.hSMul s im_k }","decl":"@[simp]\ntheorem smul_mk (re im_i im_j im_k : R) :\n    s • (⟨re, im_i, im_j, im_k⟩ : ℍ[R,c₁,c₂,c₃]) = ⟨s • re, s • im_i, s • im_j, s • im_k⟩ :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.coe_smul","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : Zero R\ninst✝ : SMulZeroClass S R\ns : S\nr : R\n⊢ Eq (↑(HSMul.hSMul s r)) (HSMul.hSMul s ↑r)","decl":"@[simp, norm_cast]\ntheorem coe_smul [Zero R] [SMulZeroClass S R] (s : S) (r : R) :\n    (↑(s • r) : ℍ[R,c₁,c₂,c₃]) = s • (r : ℍ[R,c₁,c₂,c₃]) :=\n  QuaternionAlgebra.ext rfl (smul_zero _).symm (smul_zero _).symm (smul_zero _).symm\n\n"}
{"name":"QuaternionAlgebra.natCast_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nn : Nat\n⊢ Eq (↑n).re ↑n","decl":"@[simp, norm_cast]\ntheorem natCast_re (n : ℕ) : (n : ℍ[R,c₁,c₂,c₃]).re = n :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.natCast_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nn : Nat\n⊢ Eq (↑n).imI 0","decl":"@[simp, norm_cast]\ntheorem natCast_imI (n : ℕ) : (n : ℍ[R,c₁,c₂,c₃]).imI = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.natCast_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nn : Nat\n⊢ Eq (↑n).imJ 0","decl":"@[simp, norm_cast]\ntheorem natCast_imJ (n : ℕ) : (n : ℍ[R,c₁,c₂,c₃]).imJ = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.natCast_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nn : Nat\n⊢ Eq (↑n).imK 0","decl":"@[simp, norm_cast]\ntheorem natCast_imK (n : ℕ) : (n : ℍ[R,c₁,c₂,c₃]).imK = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.natCast_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nn : Nat\n⊢ Eq (↑n).im 0","decl":"@[simp, norm_cast]\ntheorem natCast_im (n : ℕ) : (n : ℍ[R,c₁,c₂,c₃]).im = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.coe_natCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[norm_cast]\ntheorem coe_natCast (n : ℕ) : ↑(n : R) = (n : ℍ[R,c₁,c₂,c₃]) :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.intCast_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nz : Int\n⊢ Eq (↑z).re ↑z","decl":"@[simp, norm_cast]\ntheorem intCast_re (z : ℤ) : (z : ℍ[R,c₁,c₂,c₃]).re = z :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.ofNat_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : AddCommGroupWithOne R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).re (OfNat.ofNat n)","decl":"@[simp]\ntheorem ofNat_re (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : ℍ[R,c₁,c₂,c₃]).re = ofNat(n) := rfl\n\n"}
{"name":"QuaternionAlgebra.ofNat_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : AddCommGroupWithOne R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).imI 0","decl":"@[simp]\ntheorem ofNat_imI (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : ℍ[R,c₁,c₂,c₃]).imI = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.ofNat_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : AddCommGroupWithOne R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).imJ 0","decl":"@[simp]\ntheorem ofNat_imJ (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : ℍ[R,c₁,c₂,c₃]).imJ = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.ofNat_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : AddCommGroupWithOne R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).imK 0","decl":"@[simp]\ntheorem ofNat_imK (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : ℍ[R,c₁,c₂,c₃]).imK = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.ofNat_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : AddCommGroupWithOne R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).im 0","decl":"@[simp]\ntheorem ofNat_im (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : ℍ[R,c₁,c₂,c₃]).im = 0 := rfl\n\n"}
{"name":"QuaternionAlgebra.intCast_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nz : Int\n⊢ Eq (↑z).imI 0","decl":"@[simp, norm_cast]\ntheorem intCast_imI (z : ℤ) : (z : ℍ[R,c₁,c₂,c₃]).imI = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.intCast_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nz : Int\n⊢ Eq (↑z).imJ 0","decl":"@[simp, norm_cast]\ntheorem intCast_imJ (z : ℤ) : (z : ℍ[R,c₁,c₂,c₃]).imJ = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.intCast_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nz : Int\n⊢ Eq (↑z).imK 0","decl":"@[simp, norm_cast]\ntheorem intCast_imK (z : ℤ) : (z : ℍ[R,c₁,c₂,c₃]).imK = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.intCast_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nz : Int\n⊢ Eq (↑z).im 0","decl":"@[simp, norm_cast]\ntheorem intCast_im (z : ℤ) : (z : ℍ[R,c₁,c₂,c₃]).im = 0 :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.coe_intCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : AddCommGroupWithOne R\nz : Int\n⊢ Eq ↑↑z ↑z","decl":"@[norm_cast]\ntheorem coe_intCast (z : ℤ) : ↑(z : R) = (z : ℍ[R,c₁,c₂,c₃]) :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.coe_mul","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x y : R\ninst✝ : CommRing R\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[norm_cast, simp]\ntheorem coe_mul : ((x * y : R) : ℍ[R,c₁,c₂,c₃]) = x * y := by ext <;> simp\n\n"}
{"name":"QuaternionAlgebra.coe_ofNat","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : CommRing R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[norm_cast, simp]\nlemma coe_ofNat {n : ℕ} [n.AtLeastTwo]:\n    ((ofNat(n) : R) : ℍ[R,c₁,c₂,c₃]) = (ofNat(n) : ℍ[R,c₁,c₂,c₃]) := by\n  rfl\n\n-- TODO: add weaker `MulAction`, `DistribMulAction`, and `Module` instances (and repeat them\n-- for `ℍ[R]`)\n"}
{"name":"QuaternionAlgebra.algebraMap_eq","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\nr : R\n⊢ Eq ((algebraMap R (QuaternionAlgebra R c₁ c₂ c₃)) r) { re := r, imI := 0, imJ := 0, imK := 0 }","decl":"theorem algebraMap_eq (r : R) : algebraMap R ℍ[R,c₁,c₂,c₃] r = ⟨r, 0, 0, 0⟩ :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.algebraMap_injective","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\n⊢ Function.Injective ⇑(algebraMap R (QuaternionAlgebra R c₁ c₂ c₃))","decl":"theorem algebraMap_injective : (algebraMap R ℍ[R,c₁,c₂,c₃] : _ → _).Injective :=\n  fun _ _ ↦ by simp [algebraMap_eq]\n\n"}
{"name":"QuaternionAlgebra.instNoZeroSMulDivisorsOfNoZeroDivisors","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : CommRing R\ninst✝ : NoZeroDivisors R\n⊢ NoZeroSMulDivisors R (QuaternionAlgebra R c₁ c₂ c₃)","decl":"instance [NoZeroDivisors R] : NoZeroSMulDivisors R ℍ[R,c₁,c₂,c₃] := ⟨by\n  rintro t ⟨a, b, c, d⟩ h\n  rw [or_iff_not_imp_left]\n  intro ht\n  simpa [QuaternionAlgebra.ext_iff, ht] using h⟩\n\n"}
{"name":"QuaternionAlgebra.reₗ_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\nself : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq ((QuaternionAlgebra.reₗ c₁ c₂ c₃) self) self.re","decl":"/-- `QuaternionAlgebra.re` as a `LinearMap`-/\n@[simps]\ndef reₗ : ℍ[R,c₁,c₂,c₃] →ₗ[R] R where\n  toFun := re\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"QuaternionAlgebra.imIₗ_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\nself : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq ((QuaternionAlgebra.imIₗ c₁ c₂ c₃) self) self.imI","decl":"/-- `QuaternionAlgebra.imI` as a `LinearMap`-/\n@[simps]\ndef imIₗ : ℍ[R,c₁,c₂,c₃] →ₗ[R] R where\n  toFun := imI\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"QuaternionAlgebra.imJₗ_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\nself : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq ((QuaternionAlgebra.imJₗ c₁ c₂ c₃) self) self.imJ","decl":"/-- `QuaternionAlgebra.imJ` as a `LinearMap`-/\n@[simps]\ndef imJₗ : ℍ[R,c₁,c₂,c₃] →ₗ[R] R where\n  toFun := imJ\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"QuaternionAlgebra.imKₗ_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\nself : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq ((QuaternionAlgebra.imKₗ c₁ c₂ c₃) self) self.imK","decl":"/-- `QuaternionAlgebra.imK` as a `LinearMap`-/\n@[simps]\ndef imKₗ : ℍ[R,c₁,c₂,c₃] →ₗ[R] R where\n  toFun := imK\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"QuaternionAlgebra.coe_linearEquivTuple","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\n⊢ Eq ⇑(QuaternionAlgebra.linearEquivTuple c₁ c₂ c₃) ⇑(QuaternionAlgebra.equivTuple c₁ c₂ c₃)","decl":"@[simp]\ntheorem coe_linearEquivTuple :\n    ⇑(linearEquivTuple c₁ c₂ c₃) = equivTuple c₁ c₂ c₃ := rfl\n\n"}
{"name":"QuaternionAlgebra.coe_linearEquivTuple_symm","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\n⊢ Eq ⇑(QuaternionAlgebra.linearEquivTuple c₁ c₂ c₃).symm ⇑(QuaternionAlgebra.equivTuple c₁ c₂ c₃).symm","decl":"@[simp]\ntheorem coe_linearEquivTuple_symm :\n    ⇑(linearEquivTuple c₁ c₂ c₃).symm = (equivTuple c₁ c₂ c₃).symm := rfl\n\n"}
{"name":"QuaternionAlgebra.coe_basisOneIJK_repr","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\nq : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq (⇑((QuaternionAlgebra.basisOneIJK c₁ c₂ c₃).repr q)) (Matrix.vecCons q.re (Matrix.vecCons q.imI (Matrix.vecCons q.imJ (Matrix.vecCons q.imK Matrix.vecEmpty))))","decl":"@[simp]\ntheorem coe_basisOneIJK_repr (q : ℍ[R,c₁,c₂,c₃]) :\n    ((basisOneIJK c₁ c₂ c₃).repr q) = ![q.re, q.imI, q.imJ, q.imK] :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.instFinite","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\n⊢ Module.Finite R (QuaternionAlgebra R c₁ c₂ c₃)","decl":"instance : Module.Finite R ℍ[R,c₁,c₂,c₃] := .of_basis (basisOneIJK c₁ c₂ c₃)\n\n"}
{"name":"QuaternionAlgebra.instFree","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\n⊢ Module.Free R (QuaternionAlgebra R c₁ c₂ c₃)","decl":"instance : Module.Free R ℍ[R,c₁,c₂,c₃] := .of_basis (basisOneIJK c₁ c₂ c₃)\n\n"}
{"name":"QuaternionAlgebra.rank_eq_four","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\n⊢ Eq (Module.rank R (QuaternionAlgebra R c₁ c₂ c₃)) 4","decl":"theorem rank_eq_four [StrongRankCondition R] : Module.rank R ℍ[R,c₁,c₂,c₃] = 4 := by\n  rw [rank_eq_card_basis (basisOneIJK c₁ c₂ c₃), Fintype.card_fin]\n  norm_num\n\n"}
{"name":"QuaternionAlgebra.finrank_eq_four","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\n⊢ Eq (Module.finrank R (QuaternionAlgebra R c₁ c₂ c₃)) 4","decl":"theorem finrank_eq_four [StrongRankCondition R] : Module.finrank R ℍ[R,c₁,c₂,c₃] = 4 := by\n  rw [Module.finrank, rank_eq_four, Cardinal.toNat_ofNat]\n\n"}
{"name":"QuaternionAlgebra.swapEquiv_apply_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₃ : R\ninst✝ : CommRing R\nt : QuaternionAlgebra R c₁ 0 c₃\n⊢ Eq ((QuaternionAlgebra.swapEquiv c₁ c₃) t).imI t.imJ","decl":"/-- There is a natural equivalence when swapping the first and third coefficients of a\n  quaternion algebra if `c₂` is 0. -/\n@[simps]\ndef swapEquiv : ℍ[R,c₁,0,c₃] ≃ₐ[R] ℍ[R,c₃,0,c₁] where\n  toFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  invFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' _ _ := by ext <;> simp <;> ring\n  map_add' _ _ := by ext <;> simp [add_comm]\n  commutes' _ := by simp [algebraMap_eq]\n\n"}
{"name":"QuaternionAlgebra.swapEquiv_apply_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₃ : R\ninst✝ : CommRing R\nt : QuaternionAlgebra R c₁ 0 c₃\n⊢ Eq ((QuaternionAlgebra.swapEquiv c₁ c₃) t).re t.re","decl":"/-- There is a natural equivalence when swapping the first and third coefficients of a\n  quaternion algebra if `c₂` is 0. -/\n@[simps]\ndef swapEquiv : ℍ[R,c₁,0,c₃] ≃ₐ[R] ℍ[R,c₃,0,c₁] where\n  toFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  invFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' _ _ := by ext <;> simp <;> ring\n  map_add' _ _ := by ext <;> simp [add_comm]\n  commutes' _ := by simp [algebraMap_eq]\n\n"}
{"name":"QuaternionAlgebra.swapEquiv_apply_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₃ : R\ninst✝ : CommRing R\nt : QuaternionAlgebra R c₁ 0 c₃\n⊢ Eq ((QuaternionAlgebra.swapEquiv c₁ c₃) t).imJ t.imI","decl":"/-- There is a natural equivalence when swapping the first and third coefficients of a\n  quaternion algebra if `c₂` is 0. -/\n@[simps]\ndef swapEquiv : ℍ[R,c₁,0,c₃] ≃ₐ[R] ℍ[R,c₃,0,c₁] where\n  toFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  invFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' _ _ := by ext <;> simp <;> ring\n  map_add' _ _ := by ext <;> simp [add_comm]\n  commutes' _ := by simp [algebraMap_eq]\n\n"}
{"name":"QuaternionAlgebra.swapEquiv_symm_apply_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₃ : R\ninst✝ : CommRing R\nt : QuaternionAlgebra R c₃ 0 c₁\n⊢ Eq ((QuaternionAlgebra.swapEquiv c₁ c₃).symm t).imI t.imJ","decl":"/-- There is a natural equivalence when swapping the first and third coefficients of a\n  quaternion algebra if `c₂` is 0. -/\n@[simps]\ndef swapEquiv : ℍ[R,c₁,0,c₃] ≃ₐ[R] ℍ[R,c₃,0,c₁] where\n  toFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  invFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' _ _ := by ext <;> simp <;> ring\n  map_add' _ _ := by ext <;> simp [add_comm]\n  commutes' _ := by simp [algebraMap_eq]\n\n"}
{"name":"QuaternionAlgebra.swapEquiv_apply_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₃ : R\ninst✝ : CommRing R\nt : QuaternionAlgebra R c₁ 0 c₃\n⊢ Eq ((QuaternionAlgebra.swapEquiv c₁ c₃) t).imK (Neg.neg t.imK)","decl":"/-- There is a natural equivalence when swapping the first and third coefficients of a\n  quaternion algebra if `c₂` is 0. -/\n@[simps]\ndef swapEquiv : ℍ[R,c₁,0,c₃] ≃ₐ[R] ℍ[R,c₃,0,c₁] where\n  toFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  invFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' _ _ := by ext <;> simp <;> ring\n  map_add' _ _ := by ext <;> simp [add_comm]\n  commutes' _ := by simp [algebraMap_eq]\n\n"}
{"name":"QuaternionAlgebra.swapEquiv_symm_apply_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₃ : R\ninst✝ : CommRing R\nt : QuaternionAlgebra R c₃ 0 c₁\n⊢ Eq ((QuaternionAlgebra.swapEquiv c₁ c₃).symm t).imJ t.imI","decl":"/-- There is a natural equivalence when swapping the first and third coefficients of a\n  quaternion algebra if `c₂` is 0. -/\n@[simps]\ndef swapEquiv : ℍ[R,c₁,0,c₃] ≃ₐ[R] ℍ[R,c₃,0,c₁] where\n  toFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  invFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' _ _ := by ext <;> simp <;> ring\n  map_add' _ _ := by ext <;> simp [add_comm]\n  commutes' _ := by simp [algebraMap_eq]\n\n"}
{"name":"QuaternionAlgebra.swapEquiv_symm_apply_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₃ : R\ninst✝ : CommRing R\nt : QuaternionAlgebra R c₃ 0 c₁\n⊢ Eq ((QuaternionAlgebra.swapEquiv c₁ c₃).symm t).re t.re","decl":"/-- There is a natural equivalence when swapping the first and third coefficients of a\n  quaternion algebra if `c₂` is 0. -/\n@[simps]\ndef swapEquiv : ℍ[R,c₁,0,c₃] ≃ₐ[R] ℍ[R,c₃,0,c₁] where\n  toFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  invFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' _ _ := by ext <;> simp <;> ring\n  map_add' _ _ := by ext <;> simp [add_comm]\n  commutes' _ := by simp [algebraMap_eq]\n\n"}
{"name":"QuaternionAlgebra.swapEquiv_symm_apply_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₃ : R\ninst✝ : CommRing R\nt : QuaternionAlgebra R c₃ 0 c₁\n⊢ Eq ((QuaternionAlgebra.swapEquiv c₁ c₃).symm t).imK (Neg.neg t.imK)","decl":"/-- There is a natural equivalence when swapping the first and third coefficients of a\n  quaternion algebra if `c₂` is 0. -/\n@[simps]\ndef swapEquiv : ℍ[R,c₁,0,c₃] ≃ₐ[R] ℍ[R,c₃,0,c₁] where\n  toFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  invFun t := ⟨t.1, t.3, t.2, -t.4⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' _ _ := by ext <;> simp <;> ring\n  map_add' _ _ := by ext <;> simp [add_comm]\n  commutes' _ := by simp [algebraMap_eq]\n\n"}
{"name":"QuaternionAlgebra.coe_sub","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x y : R\ninst✝ : CommRing R\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"@[norm_cast, simp]\ntheorem coe_sub : ((x - y : R) : ℍ[R,c₁,c₂,c₃]) = x - y :=\n  (algebraMap R ℍ[R,c₁,c₂,c₃]).map_sub x y\n\n"}
{"name":"QuaternionAlgebra.coe_pow","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x : R\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[norm_cast, simp]\ntheorem coe_pow (n : ℕ) : (↑(x ^ n) : ℍ[R,c₁,c₂,c₃]) = (x : ℍ[R,c₁,c₂,c₃]) ^ n :=\n  (algebraMap R ℍ[R,c₁,c₂,c₃]).map_pow x n\n\n"}
{"name":"QuaternionAlgebra.coe_commutes","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ r : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (HMul.hMul (↑r) a) (HMul.hMul a ↑r)","decl":"theorem coe_commutes : ↑r * a = a * r :=\n  Algebra.commutes r a\n\n"}
{"name":"QuaternionAlgebra.coe_commute","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ r : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Commute (↑r) a","decl":"theorem coe_commute : Commute (↑r) a :=\n  coe_commutes r a\n\n"}
{"name":"QuaternionAlgebra.coe_mul_eq_smul","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ r : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (HMul.hMul (↑r) a) (HSMul.hSMul r a)","decl":"theorem coe_mul_eq_smul : ↑r * a = r • a :=\n  (Algebra.smul_def r a).symm\n\n"}
{"name":"QuaternionAlgebra.mul_coe_eq_smul","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ r : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (HMul.hMul a ↑r) (HSMul.hSMul r a)","decl":"theorem mul_coe_eq_smul : a * r = r • a := by rw [← coe_commutes, coe_mul_eq_smul]\n\n"}
{"name":"QuaternionAlgebra.coe_algebraMap","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\n⊢ Eq (⇑(algebraMap R (QuaternionAlgebra R c₁ c₂ c₃))) QuaternionAlgebra.coe","decl":"@[norm_cast, simp]\ntheorem coe_algebraMap : ⇑(algebraMap R ℍ[R,c₁,c₂,c₃]) = coe :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.smul_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x y : R\ninst✝ : CommRing R\n⊢ Eq (HSMul.hSMul x ↑y) ↑(HMul.hMul x y)","decl":"theorem smul_coe : x • (y : ℍ[R,c₁,c₂,c₃]) = ↑(x * y) := by rw [coe_mul, coe_mul_eq_smul]\n\n"}
{"name":"QuaternionAlgebra.re_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (Star.star a).re (HAdd.hAdd a.re (HMul.hMul c₂ a.imI))","decl":"@[simp] theorem re_star : (star a).re = a.re + c₂ * a.imI := rfl\n\n"}
{"name":"QuaternionAlgebra.imI_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (Star.star a).imI (Neg.neg a.imI)","decl":"@[simp]\ntheorem imI_star : (star a).imI = -a.imI :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.imJ_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (Star.star a).imJ (Neg.neg a.imJ)","decl":"@[simp]\ntheorem imJ_star : (star a).imJ = -a.imJ :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.imK_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (Star.star a).imK (Neg.neg a.imK)","decl":"@[simp]\ntheorem imK_star : (star a).imK = -a.imK :=\n  rfl\n\n"}
{"name":"QuaternionAlgebra.im_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (Star.star a).im (Neg.neg a.im)","decl":"@[simp]\ntheorem im_star : (star a).im = -a.im :=\n  QuaternionAlgebra.ext neg_zero.symm rfl rfl rfl\n\n"}
{"name":"QuaternionAlgebra.star_mk","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\na₁ a₂ a₃ a₄ : R\n⊢ Eq (Star.star { re := a₁, imI := a₂, imJ := a₃, imK := a₄ }) { re := HAdd.hAdd a₁ (HMul.hMul c₂ a₂), imI := Neg.neg a₂, imJ := Neg.neg a₃, imK := Neg.neg a₄ }","decl":"@[simp]\ntheorem star_mk (a₁ a₂ a₃ a₄ : R) : star (mk a₁ a₂ a₃ a₄ : ℍ[R,c₁,c₂,c₃]) =\n    ⟨a₁ + c₂ * a₂, -a₂, -a₃, -a₄⟩ := rfl\n\n"}
{"name":"QuaternionAlgebra.self_add_star'","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (HAdd.hAdd a (Star.star a)) ↑(HAdd.hAdd (HMul.hMul 2 a.re) (HMul.hMul c₂ a.imI))","decl":"theorem self_add_star' : a + star a = ↑(2 * a.re + c₂ * a.imI) := by ext <;> simp [two_mul]; ring\n\n"}
{"name":"QuaternionAlgebra.self_add_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (HAdd.hAdd a (Star.star a)) (HAdd.hAdd (HMul.hMul 2 ↑a.re) (HMul.hMul ↑c₂ ↑a.imI))","decl":"theorem self_add_star : a + star a = 2 * a.re + c₂ * a.imI := by simp [self_add_star']\n\n"}
{"name":"QuaternionAlgebra.star_add_self'","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (HAdd.hAdd (Star.star a) a) ↑(HAdd.hAdd (HMul.hMul 2 a.re) (HMul.hMul c₂ a.imI))","decl":"theorem star_add_self' : star a + a = ↑(2 * a.re + c₂ * a.imI) := by rw [add_comm, self_add_star']\n\n"}
{"name":"QuaternionAlgebra.star_add_self","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (HAdd.hAdd (Star.star a) a) (HAdd.hAdd (HMul.hMul 2 ↑a.re) (HMul.hMul ↑c₂ ↑a.imI))","decl":"theorem star_add_self : star a + a = 2 * a.re + c₂ * a.imI := by rw [add_comm, self_add_star]\n\n"}
{"name":"QuaternionAlgebra.star_eq_two_re_sub","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (Star.star a) (HSub.hSub (↑(HAdd.hAdd (HMul.hMul 2 a.re) (HMul.hMul c₂ a.imI))) a)","decl":"theorem star_eq_two_re_sub : star a = ↑(2 * a.re + c₂ * a.imI) - a :=\n  eq_sub_iff_add_eq.2 a.star_add_self'\n\n"}
{"name":"QuaternionAlgebra.comm","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\nr : R\nx : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq (HMul.hMul (↑r) x) (HMul.hMul x ↑r)","decl":"lemma comm (r : R) (x : ℍ[R, c₁, c₂, c₃]) : r * x = x * r := by\n  ext <;> simp [mul_comm]\n\n"}
{"name":"QuaternionAlgebra.instIsStarNormal","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ IsStarNormal a","decl":"instance : IsStarNormal a :=\n  ⟨by\n    rw [commute_iff_eq, a.star_eq_two_re_sub];\n    ext <;> simp <;> ring⟩\n\n"}
{"name":"QuaternionAlgebra.star_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ x : R\ninst✝ : CommRing R\n⊢ Eq (Star.star ↑x) ↑x","decl":"@[simp, norm_cast]\ntheorem star_coe : star (x : ℍ[R,c₁,c₂,c₃]) = x := by ext <;> simp\n\n"}
{"name":"QuaternionAlgebra.star_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (Star.star a.im) (HAdd.hAdd (Neg.neg a.im) (HMul.hMul ↑c₂ ↑a.imI))","decl":"@[simp] theorem star_im : star a.im = -a.im + c₂ * a.imI := by ext <;> simp\n\n"}
{"name":"QuaternionAlgebra.star_smul","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\nc₁ c₂ c₃ : R\ninst✝³ : CommRing R\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S R\ninst✝ : SMulCommClass S R R\ns : S\na : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Eq (Star.star (HSMul.hSMul s a)) (HSMul.hSMul s (Star.star a))","decl":"@[simp]\ntheorem star_smul [Monoid S] [DistribMulAction S R] [SMulCommClass S R R]\n    (s : S) (a : ℍ[R,c₁,c₂,c₃]) :\n    star (s • a) = s • star a :=\n  QuaternionAlgebra.ext\n    (by simp [mul_smul_comm]) (smul_neg _ _).symm (smul_neg _ _).symm (smul_neg _ _).symm\n\n"}
{"name":"QuaternionAlgebra.star_smul'","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\nc₁ c₃ : R\ninst✝² : CommRing R\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S R\ns : S\na : QuaternionAlgebra R c₁ 0 c₃\n⊢ Eq (Star.star (HSMul.hSMul s a)) (HSMul.hSMul s (Star.star a))","decl":"/-- A version of `star_smul` for the special case when `c₂ = 0`, without `SMulCommClass S R R`. -/\ntheorem star_smul' [Monoid S] [DistribMulAction S R] (s : S) (a : ℍ[R,c₁,0,c₃]) :\n    star (s • a) = s • star a :=\n  QuaternionAlgebra.ext (by simp) (smul_neg _ _).symm (smul_neg _ _).symm (smul_neg _ _).symm\n\n"}
{"name":"QuaternionAlgebra.eq_re_of_eq_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\na : QuaternionAlgebra R c₁ c₂ c₃\nx : R\nh : Eq a ↑x\n⊢ Eq a ↑a.re","decl":"theorem eq_re_of_eq_coe {a : ℍ[R,c₁,c₂,c₃]} {x : R} (h : a = x) : a = a.re := by rw [h, coe_re]\n\n"}
{"name":"QuaternionAlgebra.eq_re_iff_mem_range_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\na : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Iff (Eq a ↑a.re) (Membership.mem (Set.range QuaternionAlgebra.coe) a)","decl":"theorem eq_re_iff_mem_range_coe {a : ℍ[R,c₁,c₂,c₃]} :\n    a = a.re ↔ a ∈ Set.range (coe : R → ℍ[R,c₁,c₂,c₃]) :=\n  ⟨fun h => ⟨a.re, h.symm⟩, fun ⟨_, h⟩ => eq_re_of_eq_coe h.symm⟩\n\n"}
{"name":"QuaternionAlgebra.star_eq_self","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₃ : R\ninst✝² : CommRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\nc₁ c₂ : R\na : QuaternionAlgebra R c₁ c₂ c₃\n⊢ Iff (Eq (Star.star a) a) (Eq a ↑a.re)","decl":"@[simp]\ntheorem star_eq_self {c₁ c₂ : R} {a : ℍ[R,c₁,c₂,c₃]} : star a = a ↔ a = a.re := by\n  simp_all [QuaternionAlgebra.ext_iff, neg_eq_iff_add_eq_zero, add_self_eq_zero]\n\n"}
{"name":"QuaternionAlgebra.star_eq_neg","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₃ : R\ninst✝² : CommRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\nc₁ : R\na : QuaternionAlgebra R c₁ 0 c₃\n⊢ Iff (Eq (Star.star a) (Neg.neg a)) (Eq a.re 0)","decl":"theorem star_eq_neg {c₁ : R} {a : ℍ[R,c₁,0,c₃]} : star a = -a ↔ a.re = 0 := by\n  simp [QuaternionAlgebra.ext_iff, eq_neg_iff_add_eq_zero]\n\n"}
{"name":"QuaternionAlgebra.star_mul_eq_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (HMul.hMul (Star.star a) a) ↑(HMul.hMul (Star.star a) a).re","decl":"theorem star_mul_eq_coe : star a * a = (star a * a).re := by ext <;> simp <;> ring\n\n"}
{"name":"QuaternionAlgebra.mul_star_eq_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\na : QuaternionAlgebra R c₁ c₂ c₃\ninst✝ : CommRing R\n⊢ Eq (HMul.hMul a (Star.star a)) ↑(HMul.hMul a (Star.star a)).re","decl":"theorem mul_star_eq_coe : a * star a = (a * star a).re := by\n  rw [← star_comm_self']\n  exact a.star_mul_eq_coe\n\n"}
{"name":"QuaternionAlgebra.coe_starAe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\nc₁ c₂ c₃ : R\ninst✝ : CommRing R\n⊢ Eq (⇑QuaternionAlgebra.starAe) (Function.comp MulOpposite.op Star.star)","decl":"@[simp]\ntheorem coe_starAe : ⇑(starAe : ℍ[R,c₁,c₂,c₃] ≃ₐ[R] _) = op ∘ star :=\n  rfl\n\n"}
{"name":"Quaternion.equivProd_symm_apply_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : Neg R\na : Prod R (Prod R (Prod R R))\n⊢ Eq ((Quaternion.equivProd R).symm a).imJ a.2.2.1","decl":"/-- The equivalence between the quaternions over `R` and `R × R × R × R`. -/\n@[simps!]\ndef Quaternion.equivProd (R : Type*) [Zero R] [One R] [Neg R] : ℍ[R] ≃ R × R × R × R :=\n  QuaternionAlgebra.equivProd _ _ _\n\n"}
{"name":"Quaternion.equivProd_symm_apply_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : Neg R\na : Prod R (Prod R (Prod R R))\n⊢ Eq ((Quaternion.equivProd R).symm a).re a.1","decl":"/-- The equivalence between the quaternions over `R` and `R × R × R × R`. -/\n@[simps!]\ndef Quaternion.equivProd (R : Type*) [Zero R] [One R] [Neg R] : ℍ[R] ≃ R × R × R × R :=\n  QuaternionAlgebra.equivProd _ _ _\n\n"}
{"name":"Quaternion.equivProd_symm_apply_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : Neg R\na : Prod R (Prod R (Prod R R))\n⊢ Eq ((Quaternion.equivProd R).symm a).imK a.2.2.2","decl":"/-- The equivalence between the quaternions over `R` and `R × R × R × R`. -/\n@[simps!]\ndef Quaternion.equivProd (R : Type*) [Zero R] [One R] [Neg R] : ℍ[R] ≃ R × R × R × R :=\n  QuaternionAlgebra.equivProd _ _ _\n\n"}
{"name":"Quaternion.equivProd_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : Neg R\na : QuaternionAlgebra R (-1) 0 (-1)\n⊢ Eq ((Quaternion.equivProd R) a) { fst := a.re, snd := { fst := a.imI, snd := { fst := a.imJ, snd := a.imK } } }","decl":"/-- The equivalence between the quaternions over `R` and `R × R × R × R`. -/\n@[simps!]\ndef Quaternion.equivProd (R : Type*) [Zero R] [One R] [Neg R] : ℍ[R] ≃ R × R × R × R :=\n  QuaternionAlgebra.equivProd _ _ _\n\n"}
{"name":"Quaternion.equivProd_symm_apply_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : Neg R\na : Prod R (Prod R (Prod R R))\n⊢ Eq ((Quaternion.equivProd R).symm a).imI a.2.1","decl":"/-- The equivalence between the quaternions over `R` and `R × R × R × R`. -/\n@[simps!]\ndef Quaternion.equivProd (R : Type*) [Zero R] [One R] [Neg R] : ℍ[R] ≃ R × R × R × R :=\n  QuaternionAlgebra.equivProd _ _ _\n\n"}
{"name":"Quaternion.equivTuple_symm_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : Neg R\na : Fin 4 → R\n⊢ Eq ((Quaternion.equivTuple R).symm a) { re := a 0, imI := a 1, imJ := a 2, imK := a 3 }","decl":"/-- The equivalence between the quaternions over `R` and `Fin 4 → R`. -/\n@[simps! symm_apply]\ndef Quaternion.equivTuple (R : Type*) [Zero R] [One R] [Neg R] : ℍ[R] ≃ (Fin 4 → R) :=\n  QuaternionAlgebra.equivTuple _ _ _\n\n"}
{"name":"Quaternion.equivTuple_apply","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : Neg R\nx : Quaternion R\n⊢ Eq ((Quaternion.equivTuple R) x) (Matrix.vecCons x.re (Matrix.vecCons x.imI (Matrix.vecCons x.imJ (Matrix.vecCons x.imK Matrix.vecEmpty))))","decl":"@[simp]\ntheorem Quaternion.equivTuple_apply (R : Type*) [Zero R] [One R] [Neg R] (x : ℍ[R]) :\n    Quaternion.equivTuple R x = ![x.re, x.imI, x.imJ, x.imK] :=\n  rfl\n\n"}
{"name":"instSubsingletonQuaternion","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝³ : Zero R\ninst✝² : One R\ninst✝¹ : Neg R\ninst✝ : Subsingleton R\n⊢ Subsingleton (Quaternion R)","decl":"instance {R : Type*} [Zero R] [One R] [Neg R] [Subsingleton R] : Subsingleton ℍ[R] :=\n  inferInstanceAs (Subsingleton <| ℍ[R, -1, 0, -1])\n"}
{"name":"instNontrivialQuaternion","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝³ : Zero R\ninst✝² : One R\ninst✝¹ : Neg R\ninst✝ : Nontrivial R\n⊢ Nontrivial (Quaternion R)","decl":"instance {R : Type*} [Zero R] [One R] [Neg R] [Nontrivial R] : Nontrivial ℍ[R] :=\n  inferInstanceAs (Nontrivial <| ℍ[R, -1, 0, -1])\n\n"}
{"name":"Quaternion.instIsScalarTower","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nT : Type u_2\nR : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : SMul S T\ninst✝² : SMul S R\ninst✝¹ : SMul T R\ninst✝ : IsScalarTower S T R\n⊢ IsScalarTower S T (Quaternion R)","decl":"instance [SMul S T] [SMul S R] [SMul T R] [IsScalarTower S T R] : IsScalarTower S T ℍ[R] :=\n  inferInstanceAs <| IsScalarTower S T ℍ[R,-1,0,-1]\n\n"}
{"name":"Quaternion.instSMulCommClass","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nT : Type u_2\nR : Type u_3\ninst✝³ : CommRing R\ninst✝² : SMul S R\ninst✝¹ : SMul T R\ninst✝ : SMulCommClass S T R\n⊢ SMulCommClass S T (Quaternion R)","decl":"instance [SMul S R] [SMul T R] [SMulCommClass S T R] : SMulCommClass S T ℍ[R] :=\n  inferInstanceAs <| SMulCommClass S T ℍ[R,-1,0,-1]\n\n"}
{"name":"Quaternion.instIsStarNormal","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ IsStarNormal a","decl":"instance : IsStarNormal a := inferInstanceAs <| IsStarNormal (R := ℍ[R,-1,0,-1]) a\n\n"}
{"name":"Quaternion.ext","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\na✝³ : Eq a.re b.re\na✝² : Eq a.imI b.imI\na✝¹ : Eq a.imJ b.imJ\na✝ : Eq a.imK b.imK\n⊢ Eq a b","decl":"@[ext]\ntheorem ext : a.re = b.re → a.imI = b.imI → a.imJ = b.imJ → a.imK = b.imK → a = b :=\n  QuaternionAlgebra.ext\n\n"}
{"name":"Quaternion.ext_iff","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Iff (Eq a b) (And (Eq a.re b.re) (And (Eq a.imI b.imI) (And (Eq a.imJ b.imJ) (Eq a.imK b.imK))))","decl":"@[ext]\ntheorem ext : a.re = b.re → a.imI = b.imI → a.imJ = b.imJ → a.imK = b.imK → a = b :=\n  QuaternionAlgebra.ext\n\n"}
{"name":"Quaternion.im_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq a.im.re 0","decl":"@[simp] theorem im_re : a.im.re = 0 := rfl\n\n"}
{"name":"Quaternion.im_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq a.im.imI a.imI","decl":"@[simp] theorem im_imI : a.im.imI = a.imI := rfl\n\n"}
{"name":"Quaternion.im_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq a.im.imJ a.imJ","decl":"@[simp] theorem im_imJ : a.im.imJ = a.imJ := rfl\n\n"}
{"name":"Quaternion.im_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq a.im.imK a.imK","decl":"@[simp] theorem im_imK : a.im.imK = a.imK := rfl\n\n"}
{"name":"Quaternion.im_idem","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq a.im.im a.im","decl":"@[simp] theorem im_idem : a.im.im = a.im := rfl\n\n"}
{"name":"Quaternion.re_add_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HAdd.hAdd (↑a.re) a.im) a","decl":"@[simp] nonrec theorem re_add_im : ↑a.re + a.im = a := a.re_add_im\n\n"}
{"name":"Quaternion.sub_self_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HSub.hSub a a.im) ↑a.re","decl":"@[simp] nonrec theorem sub_self_im : a - a.im = a.re := a.sub_self_im\n\n"}
{"name":"Quaternion.sub_self_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HSub.hSub a ↑a.re) a.im","decl":"@[simp] nonrec theorem sub_self_re : a - ↑a.re = a.im := a.sub_self_re\n\n"}
{"name":"Quaternion.coe_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx : R\n⊢ Eq (↑x).re x","decl":"@[simp, norm_cast]\ntheorem coe_re : (x : ℍ[R]).re = x := rfl\n\n"}
{"name":"Quaternion.coe_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx : R\n⊢ Eq (↑x).imI 0","decl":"@[simp, norm_cast]\ntheorem coe_imI : (x : ℍ[R]).imI = 0 := rfl\n\n"}
{"name":"Quaternion.coe_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx : R\n⊢ Eq (↑x).imJ 0","decl":"@[simp, norm_cast]\ntheorem coe_imJ : (x : ℍ[R]).imJ = 0 := rfl\n\n"}
{"name":"Quaternion.coe_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx : R\n⊢ Eq (↑x).imK 0","decl":"@[simp, norm_cast]\ntheorem coe_imK : (x : ℍ[R]).imK = 0 := rfl\n\n"}
{"name":"Quaternion.coe_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx : R\n⊢ Eq (↑x).im 0","decl":"@[simp, norm_cast]\ntheorem coe_im : (x : ℍ[R]).im = 0 := rfl\n\n"}
{"name":"Quaternion.zero_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (QuaternionAlgebra.re 0) 0","decl":"@[simp] theorem zero_re : (0 : ℍ[R]).re = 0 := rfl\n\n"}
{"name":"Quaternion.zero_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (QuaternionAlgebra.imI 0) 0","decl":"@[simp] theorem zero_imI : (0 : ℍ[R]).imI = 0 := rfl\n\n"}
{"name":"Quaternion.zero_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (QuaternionAlgebra.imJ 0) 0","decl":"@[simp] theorem zero_imJ : (0 : ℍ[R]).imJ = 0 := rfl\n\n"}
{"name":"Quaternion.zero_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (QuaternionAlgebra.imK 0) 0","decl":"@[simp] theorem zero_imK : (0 : ℍ[R]).imK = 0 := rfl\n\n"}
{"name":"Quaternion.zero_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (Quaternion.im 0) 0","decl":"@[simp] theorem zero_im : (0 : ℍ[R]).im = 0 := rfl\n\n"}
{"name":"Quaternion.coe_zero","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : R) : ℍ[R]) = 0 := rfl\n\n"}
{"name":"Quaternion.one_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (QuaternionAlgebra.re 1) 1","decl":"@[simp] theorem one_re : (1 : ℍ[R]).re = 1 := rfl\n\n"}
{"name":"Quaternion.one_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (QuaternionAlgebra.imI 1) 0","decl":"@[simp] theorem one_imI : (1 : ℍ[R]).imI = 0 := rfl\n\n"}
{"name":"Quaternion.one_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (QuaternionAlgebra.imJ 1) 0","decl":"@[simp] theorem one_imJ : (1 : ℍ[R]).imJ = 0 := rfl\n\n"}
{"name":"Quaternion.one_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (QuaternionAlgebra.imK 1) 0","decl":"@[simp] theorem one_imK : (1 : ℍ[R]).imK = 0 := rfl\n\n"}
{"name":"Quaternion.one_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (Quaternion.im 1) 0","decl":"@[simp] theorem one_im : (1 : ℍ[R]).im = 0 := rfl\n\n"}
{"name":"Quaternion.coe_one","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ((1 : R) : ℍ[R]) = 1 := rfl\n\n"}
{"name":"Quaternion.add_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HAdd.hAdd a b).re (HAdd.hAdd a.re b.re)","decl":"@[simp] theorem add_re : (a + b).re = a.re + b.re := rfl\n\n"}
{"name":"Quaternion.add_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HAdd.hAdd a b).imI (HAdd.hAdd a.imI b.imI)","decl":"@[simp] theorem add_imI : (a + b).imI = a.imI + b.imI := rfl\n\n"}
{"name":"Quaternion.add_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HAdd.hAdd a b).imJ (HAdd.hAdd a.imJ b.imJ)","decl":"@[simp] theorem add_imJ : (a + b).imJ = a.imJ + b.imJ := rfl\n\n"}
{"name":"Quaternion.add_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HAdd.hAdd a b).imK (HAdd.hAdd a.imK b.imK)","decl":"@[simp] theorem add_imK : (a + b).imK = a.imK + b.imK := rfl\n\n"}
{"name":"Quaternion.add_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HAdd.hAdd a b).im (HAdd.hAdd a.im b.im)","decl":"@[simp] nonrec theorem add_im : (a + b).im = a.im + b.im := a.add_im b\n\n"}
{"name":"Quaternion.coe_add","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx y : R\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_add : ((x + y : R) : ℍ[R]) = x + y :=\n  QuaternionAlgebra.coe_add x y\n\n"}
{"name":"Quaternion.neg_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Neg.neg a).re (Neg.neg a.re)","decl":"@[simp] theorem neg_re : (-a).re = -a.re := rfl\n\n"}
{"name":"Quaternion.neg_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Neg.neg a).imI (Neg.neg a.imI)","decl":"@[simp] theorem neg_imI : (-a).imI = -a.imI := rfl\n\n"}
{"name":"Quaternion.neg_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Neg.neg a).imJ (Neg.neg a.imJ)","decl":"@[simp] theorem neg_imJ : (-a).imJ = -a.imJ := rfl\n\n"}
{"name":"Quaternion.neg_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Neg.neg a).imK (Neg.neg a.imK)","decl":"@[simp] theorem neg_imK : (-a).imK = -a.imK := rfl\n\n"}
{"name":"Quaternion.neg_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Neg.neg a).im (Neg.neg a.im)","decl":"@[simp] nonrec theorem neg_im : (-a).im = -a.im := a.neg_im\n\n"}
{"name":"Quaternion.coe_neg","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx : R\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[simp, norm_cast]\ntheorem coe_neg : ((-x : R) : ℍ[R]) = -x :=\n  QuaternionAlgebra.coe_neg x\n\n"}
{"name":"Quaternion.sub_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HSub.hSub a b).re (HSub.hSub a.re b.re)","decl":"@[simp] theorem sub_re : (a - b).re = a.re - b.re := rfl\n\n"}
{"name":"Quaternion.sub_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HSub.hSub a b).imI (HSub.hSub a.imI b.imI)","decl":"@[simp] theorem sub_imI : (a - b).imI = a.imI - b.imI := rfl\n\n"}
{"name":"Quaternion.sub_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HSub.hSub a b).imJ (HSub.hSub a.imJ b.imJ)","decl":"@[simp] theorem sub_imJ : (a - b).imJ = a.imJ - b.imJ := rfl\n\n"}
{"name":"Quaternion.sub_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HSub.hSub a b).imK (HSub.hSub a.imK b.imK)","decl":"@[simp] theorem sub_imK : (a - b).imK = a.imK - b.imK := rfl\n\n"}
{"name":"Quaternion.sub_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HSub.hSub a b).im (HSub.hSub a.im b.im)","decl":"@[simp] nonrec theorem sub_im : (a - b).im = a.im - b.im := a.sub_im b\n\n"}
{"name":"Quaternion.coe_sub","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx y : R\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_sub : ((x - y : R) : ℍ[R]) = x - y :=\n  QuaternionAlgebra.coe_sub x y\n\n"}
{"name":"Quaternion.mul_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HMul.hMul a b).re (HSub.hSub (HSub.hSub (HSub.hSub (HMul.hMul a.re b.re) (HMul.hMul a.imI b.imI)) (HMul.hMul a.imJ b.imJ)) (HMul.hMul a.imK b.imK))","decl":"@[simp]\ntheorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=\n  (QuaternionAlgebra.mul_re a b).trans <| by simp [one_mul, neg_mul, sub_eq_add_neg, neg_neg]\n\n"}
{"name":"Quaternion.mul_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HMul.hMul a b).imI (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HMul.hMul a.re b.imI) (HMul.hMul a.imI b.re)) (HMul.hMul a.imJ b.imK)) (HMul.hMul a.imK b.imJ))","decl":"@[simp]\ntheorem mul_imI : (a * b).imI = a.re * b.imI + a.imI * b.re + a.imJ * b.imK - a.imK * b.imJ :=\n  (QuaternionAlgebra.mul_imI a b).trans <| by ring\n\n"}
{"name":"Quaternion.mul_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HMul.hMul a b).imJ (HAdd.hAdd (HAdd.hAdd (HSub.hSub (HMul.hMul a.re b.imJ) (HMul.hMul a.imI b.imK)) (HMul.hMul a.imJ b.re)) (HMul.hMul a.imK b.imI))","decl":"@[simp]\ntheorem mul_imJ : (a * b).imJ = a.re * b.imJ - a.imI * b.imK + a.imJ * b.re + a.imK * b.imI :=\n  (QuaternionAlgebra.mul_imJ a b).trans <| by ring\n\n"}
{"name":"Quaternion.mul_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (HMul.hMul a b).imK (HAdd.hAdd (HSub.hSub (HAdd.hAdd (HMul.hMul a.re b.imK) (HMul.hMul a.imI b.imJ)) (HMul.hMul a.imJ b.imI)) (HMul.hMul a.imK b.re))","decl":"@[simp]\ntheorem mul_imK : (a * b).imK = a.re * b.imK + a.imI * b.imJ - a.imJ * b.imI + a.imK * b.re :=\n  (QuaternionAlgebra.mul_imK a b).trans <| by ring\n\n"}
{"name":"Quaternion.coe_mul","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx y : R\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_mul : ((x * y : R) : ℍ[R]) = x * y := QuaternionAlgebra.coe_mul x y\n\n"}
{"name":"Quaternion.coe_pow","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx : R\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[norm_cast, simp]\ntheorem coe_pow (n : ℕ) : (↑(x ^ n) : ℍ[R]) = (x : ℍ[R]) ^ n :=\n  QuaternionAlgebra.coe_pow x n\n\n"}
{"name":"Quaternion.natCast_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (↑n).re ↑n","decl":"@[simp, norm_cast]\ntheorem natCast_re (n : ℕ) : (n : ℍ[R]).re = n := rfl\n\n"}
{"name":"Quaternion.natCast_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (↑n).imI 0","decl":"@[simp, norm_cast]\ntheorem natCast_imI (n : ℕ) : (n : ℍ[R]).imI = 0 := rfl\n\n"}
{"name":"Quaternion.natCast_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (↑n).imJ 0","decl":"@[simp, norm_cast]\ntheorem natCast_imJ (n : ℕ) : (n : ℍ[R]).imJ = 0 := rfl\n\n"}
{"name":"Quaternion.natCast_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (↑n).imK 0","decl":"@[simp, norm_cast]\ntheorem natCast_imK (n : ℕ) : (n : ℍ[R]).imK = 0 := rfl\n\n"}
{"name":"Quaternion.natCast_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (↑n).im 0","decl":"@[simp, norm_cast]\ntheorem natCast_im (n : ℕ) : (n : ℍ[R]).im = 0 := rfl\n\n"}
{"name":"Quaternion.coe_natCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[norm_cast]\ntheorem coe_natCast (n : ℕ) : ↑(n : R) = (n : ℍ[R]) := rfl\n\n"}
{"name":"Quaternion.intCast_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nz : Int\n⊢ Eq (↑z).re ↑z","decl":"@[simp, norm_cast]\ntheorem intCast_re (z : ℤ) : (z : ℍ[R]).re = z := rfl\n\n"}
{"name":"Quaternion.intCast_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nz : Int\n⊢ Eq (↑z).imI 0","decl":"@[simp, norm_cast]\ntheorem intCast_imI (z : ℤ) : (z : ℍ[R]).imI = 0 := rfl\n\n"}
{"name":"Quaternion.intCast_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nz : Int\n⊢ Eq (↑z).imJ 0","decl":"@[simp, norm_cast]\ntheorem intCast_imJ (z : ℤ) : (z : ℍ[R]).imJ = 0 := rfl\n\n"}
{"name":"Quaternion.intCast_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nz : Int\n⊢ Eq (↑z).imK 0","decl":"@[simp, norm_cast]\ntheorem intCast_imK (z : ℤ) : (z : ℍ[R]).imK = 0 := rfl\n\n"}
{"name":"Quaternion.intCast_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nz : Int\n⊢ Eq (↑z).im 0","decl":"@[simp, norm_cast]\ntheorem intCast_im (z : ℤ) : (z : ℍ[R]).im = 0 := rfl\n\n"}
{"name":"Quaternion.coe_intCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nz : Int\n⊢ Eq ↑↑z ↑z","decl":"@[norm_cast]\ntheorem coe_intCast (z : ℤ) : ↑(z : R) = (z : ℍ[R]) := rfl\n\n"}
{"name":"Quaternion.coe_injective","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Function.Injective Quaternion.coe","decl":"theorem coe_injective : Function.Injective (coe : R → ℍ[R]) :=\n  QuaternionAlgebra.coe_injective\n\n"}
{"name":"Quaternion.coe_inj","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx y : R\n⊢ Iff (Eq ↑x ↑y) (Eq x y)","decl":"@[simp]\ntheorem coe_inj {x y : R} : (x : ℍ[R]) = y ↔ x = y :=\n  coe_injective.eq_iff\n\n"}
{"name":"Quaternion.smul_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\ninst✝¹ : CommRing R\na : Quaternion R\ninst✝ : SMul S R\ns : S\n⊢ Eq (HSMul.hSMul s a).re (HSMul.hSMul s a.re)","decl":"@[simp]\ntheorem smul_re [SMul S R] (s : S) : (s • a).re = s • a.re :=\n  rfl\n\n"}
{"name":"Quaternion.smul_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\ninst✝¹ : CommRing R\na : Quaternion R\ninst✝ : SMul S R\ns : S\n⊢ Eq (HSMul.hSMul s a).imI (HSMul.hSMul s a.imI)","decl":"@[simp] theorem smul_imI [SMul S R] (s : S) : (s • a).imI = s • a.imI := rfl\n\n"}
{"name":"Quaternion.smul_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\ninst✝¹ : CommRing R\na : Quaternion R\ninst✝ : SMul S R\ns : S\n⊢ Eq (HSMul.hSMul s a).imJ (HSMul.hSMul s a.imJ)","decl":"@[simp] theorem smul_imJ [SMul S R] (s : S) : (s • a).imJ = s • a.imJ := rfl\n\n"}
{"name":"Quaternion.smul_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\ninst✝¹ : CommRing R\na : Quaternion R\ninst✝ : SMul S R\ns : S\n⊢ Eq (HSMul.hSMul s a).imK (HSMul.hSMul s a.imK)","decl":"@[simp] theorem smul_imK [SMul S R] (s : S) : (s • a).imK = s • a.imK := rfl\n\n"}
{"name":"Quaternion.smul_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\ninst✝¹ : CommRing R\na : Quaternion R\ninst✝ : SMulZeroClass S R\ns : S\n⊢ Eq (HSMul.hSMul s a).im (HSMul.hSMul s a.im)","decl":"@[simp]\nnonrec theorem smul_im [SMulZeroClass S R] (s : S) : (s • a).im = s • a.im :=\n  a.smul_im s\n\n"}
{"name":"Quaternion.coe_smul","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\ninst✝¹ : CommRing R\ninst✝ : SMulZeroClass S R\ns : S\nr : R\n⊢ Eq (↑(HSMul.hSMul s r)) (HSMul.hSMul s ↑r)","decl":"@[simp, norm_cast]\ntheorem coe_smul [SMulZeroClass S R] (s : S) (r : R) : (↑(s • r) : ℍ[R]) = s • (r : ℍ[R]) :=\n  QuaternionAlgebra.coe_smul _ _\n\n"}
{"name":"Quaternion.coe_commutes","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nr : R\na : Quaternion R\n⊢ Eq (HMul.hMul (↑r) a) (HMul.hMul a ↑r)","decl":"theorem coe_commutes : ↑r * a = a * r :=\n  QuaternionAlgebra.coe_commutes r a\n\n"}
{"name":"Quaternion.coe_commute","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nr : R\na : Quaternion R\n⊢ Commute (↑r) a","decl":"theorem coe_commute : Commute (↑r) a :=\n  QuaternionAlgebra.coe_commute r a\n\n"}
{"name":"Quaternion.coe_mul_eq_smul","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nr : R\na : Quaternion R\n⊢ Eq (HMul.hMul (↑r) a) (HSMul.hSMul r a)","decl":"theorem coe_mul_eq_smul : ↑r * a = r • a :=\n  QuaternionAlgebra.coe_mul_eq_smul r a\n\n"}
{"name":"Quaternion.mul_coe_eq_smul","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nr : R\na : Quaternion R\n⊢ Eq (HMul.hMul a ↑r) (HSMul.hSMul r a)","decl":"theorem mul_coe_eq_smul : a * r = r • a :=\n  QuaternionAlgebra.mul_coe_eq_smul r a\n\n"}
{"name":"Quaternion.algebraMap_def","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (⇑(algebraMap R (Quaternion R))) Quaternion.coe","decl":"@[simp]\ntheorem algebraMap_def : ⇑(algebraMap R ℍ[R]) = coe :=\n  rfl\n\n"}
{"name":"Quaternion.algebraMap_injective","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Function.Injective ⇑(algebraMap R (Quaternion R))","decl":"theorem algebraMap_injective : (algebraMap R ℍ[R] : _ → _).Injective :=\n  QuaternionAlgebra.algebraMap_injective\n\n"}
{"name":"Quaternion.smul_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx y : R\n⊢ Eq (HSMul.hSMul x ↑y) ↑(HMul.hMul x y)","decl":"theorem smul_coe : x • (y : ℍ[R]) = ↑(x * y) :=\n  QuaternionAlgebra.smul_coe x y\n\n"}
{"name":"Quaternion.instFinite","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Module.Finite R (Quaternion R)","decl":"instance : Module.Finite R ℍ[R] := inferInstanceAs <| Module.Finite R ℍ[R,-1,0,-1]\n"}
{"name":"Quaternion.instFree","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Module.Free R (Quaternion R)","decl":"instance : Module.Free R ℍ[R] := inferInstanceAs <| Module.Free R ℍ[R,-1,0,-1]\n\n"}
{"name":"Quaternion.rank_eq_four","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\n⊢ Eq (Module.rank R (Quaternion R)) 4","decl":"theorem rank_eq_four [StrongRankCondition R] : Module.rank R ℍ[R] = 4 :=\n  QuaternionAlgebra.rank_eq_four _ _ _\n\n"}
{"name":"Quaternion.finrank_eq_four","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\n⊢ Eq (Module.finrank R (Quaternion R)) 4","decl":"theorem finrank_eq_four [StrongRankCondition R] : Module.finrank R ℍ[R] = 4 :=\n  QuaternionAlgebra.finrank_eq_four _ _ _\n\n"}
{"name":"Quaternion.star_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Star.star a).re a.re","decl":"@[simp] theorem star_re : (star a).re = a.re := by\n  rw [QuaternionAlgebra.re_star, zero_mul, add_zero]\n\n"}
{"name":"Quaternion.star_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Star.star a).imI (Neg.neg a.imI)","decl":"@[simp] theorem star_imI : (star a).imI = -a.imI := rfl\n\n"}
{"name":"Quaternion.star_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Star.star a).imJ (Neg.neg a.imJ)","decl":"@[simp] theorem star_imJ : (star a).imJ = -a.imJ := rfl\n\n"}
{"name":"Quaternion.star_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Star.star a).imK (Neg.neg a.imK)","decl":"@[simp] theorem star_imK : (star a).imK = -a.imK := rfl\n\n"}
{"name":"Quaternion.star_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Star.star a).im (Neg.neg a.im)","decl":"@[simp] theorem star_im : (star a).im = -a.im := a.im_star\n\n"}
{"name":"Quaternion.self_add_star'","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HAdd.hAdd a (Star.star a)) ↑(HMul.hMul 2 a.re)","decl":"nonrec theorem self_add_star' : a + star a = ↑(2 * a.re) := by\n  simp [a.self_add_star', Quaternion.coe]\n\n"}
{"name":"Quaternion.self_add_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HAdd.hAdd a (Star.star a)) (HMul.hMul 2 ↑a.re)","decl":"nonrec theorem self_add_star : a + star a = 2 * a.re := by\n  simp [a.self_add_star, Quaternion.coe]\n\n"}
{"name":"Quaternion.star_add_self'","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HAdd.hAdd (Star.star a) a) ↑(HMul.hMul 2 a.re)","decl":"nonrec theorem star_add_self' : star a + a = ↑(2 * a.re) := by\n  simp [a.star_add_self', Quaternion.coe]\n\n"}
{"name":"Quaternion.star_add_self","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HAdd.hAdd (Star.star a) a) (HMul.hMul 2 ↑a.re)","decl":"nonrec theorem star_add_self : star a + a = 2 * a.re := by\n  simp [a.star_add_self, Quaternion.coe]\n\n"}
{"name":"Quaternion.star_eq_two_re_sub","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Star.star a) (HSub.hSub (↑(HMul.hMul 2 a.re)) a)","decl":"nonrec theorem star_eq_two_re_sub : star a = ↑(2 * a.re) - a := by\n  simp [a.star_eq_two_re_sub, Quaternion.coe]\n\n"}
{"name":"Quaternion.star_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx : R\n⊢ Eq (Star.star ↑x) ↑x","decl":"@[simp, norm_cast]\ntheorem star_coe : star (x : ℍ[R]) = x :=\n  QuaternionAlgebra.star_coe x\n\n"}
{"name":"Quaternion.im_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Star.star a.im) (Neg.neg a.im)","decl":"@[simp]\ntheorem im_star : star a.im = -a.im := by ext <;> simp\n\n"}
{"name":"Quaternion.star_smul","module":"Mathlib.Algebra.Quaternion","initialProofState":"S : Type u_1\nR : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S R\ns : S\na : Quaternion R\n⊢ Eq (Star.star (HSMul.hSMul s a)) (HSMul.hSMul s (Star.star a))","decl":"@[simp]\ntheorem star_smul [Monoid S] [DistribMulAction S R] (s : S) (a : ℍ[R]) :\n    star (s • a) = s • star a := QuaternionAlgebra.star_smul' s a\n\n"}
{"name":"Quaternion.eq_re_of_eq_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\nx : R\nh : Eq a ↑x\n⊢ Eq a ↑a.re","decl":"theorem eq_re_of_eq_coe {a : ℍ[R]} {x : R} (h : a = x) : a = a.re :=\n  QuaternionAlgebra.eq_re_of_eq_coe h\n\n"}
{"name":"Quaternion.eq_re_iff_mem_range_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Iff (Eq a ↑a.re) (Membership.mem (Set.range Quaternion.coe) a)","decl":"theorem eq_re_iff_mem_range_coe {a : ℍ[R]} : a = a.re ↔ a ∈ Set.range (coe : R → ℍ[R]) :=\n  QuaternionAlgebra.eq_re_iff_mem_range_coe\n\n"}
{"name":"Quaternion.star_eq_self","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝² : CommRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\na : Quaternion R\n⊢ Iff (Eq (Star.star a) a) (Eq a ↑a.re)","decl":"@[simp]\ntheorem star_eq_self {a : ℍ[R]} : star a = a ↔ a = a.re :=\n  QuaternionAlgebra.star_eq_self\n\n"}
{"name":"Quaternion.star_eq_neg","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝² : CommRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\na : Quaternion R\n⊢ Iff (Eq (Star.star a) (Neg.neg a)) (Eq a.re 0)","decl":"@[simp]\ntheorem star_eq_neg {a : ℍ[R]} : star a = -a ↔ a.re = 0 :=\n  QuaternionAlgebra.star_eq_neg\n\n"}
{"name":"Quaternion.star_mul_eq_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HMul.hMul (Star.star a) a) ↑(HMul.hMul (Star.star a) a).re","decl":"nonrec theorem star_mul_eq_coe : star a * a = (star a * a).re :=\n  a.star_mul_eq_coe\n\n"}
{"name":"Quaternion.mul_star_eq_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HMul.hMul a (Star.star a)) ↑(HMul.hMul a (Star.star a)).re","decl":"nonrec theorem mul_star_eq_coe : a * star a = (a * star a).re :=\n  a.mul_star_eq_coe\n\n"}
{"name":"Quaternion.coe_starAe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Eq (⇑Quaternion.starAe) (Function.comp MulOpposite.op Star.star)","decl":"@[simp]\ntheorem coe_starAe : ⇑(starAe : ℍ[R] ≃ₐ[R] ℍ[R]ᵐᵒᵖ) = op ∘ star :=\n  rfl\n\n"}
{"name":"Quaternion.normSq_def","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Quaternion.normSq a) (HMul.hMul a (Star.star a)).re","decl":"theorem normSq_def : normSq a = (a * star a).re := rfl\n\n"}
{"name":"Quaternion.normSq_def'","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Quaternion.normSq a) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow a.re 2) (HPow.hPow a.imI 2)) (HPow.hPow a.imJ 2)) (HPow.hPow a.imK 2))","decl":"theorem normSq_def' : normSq a = a.1 ^ 2 + a.2 ^ 2 + a.3 ^ 2 + a.4 ^ 2 := by\n  simp only [normSq_def, sq, mul_neg, sub_neg_eq_add, mul_re, star_re, star_imI, star_imJ,\n    star_imK]\n\n"}
{"name":"Quaternion.normSq_coe","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nx : R\n⊢ Eq (Quaternion.normSq ↑x) (HPow.hPow x 2)","decl":"theorem normSq_coe : normSq (x : ℍ[R]) = x ^ 2 := by\n  rw [normSq_def, star_coe, ← coe_mul, coe_re, sq]\n\n"}
{"name":"Quaternion.normSq_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Quaternion.normSq (Star.star a)) (Quaternion.normSq a)","decl":"@[simp]\ntheorem normSq_star : normSq (star a) = normSq a := by simp [normSq_def']\n\n"}
{"name":"Quaternion.normSq_natCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nn : Nat\n⊢ Eq (Quaternion.normSq ↑n) (HPow.hPow (↑n) 2)","decl":"@[norm_cast]\ntheorem normSq_natCast (n : ℕ) : normSq (n : ℍ[R]) = (n : R) ^ 2 := by\n  rw [← coe_natCast, normSq_coe]\n\n"}
{"name":"Quaternion.normSq_intCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nz : Int\n⊢ Eq (Quaternion.normSq ↑z) (HPow.hPow (↑z) 2)","decl":"@[norm_cast]\ntheorem normSq_intCast (z : ℤ) : normSq (z : ℍ[R]) = (z : R) ^ 2 := by\n  rw [← coe_intCast, normSq_coe]\n\n"}
{"name":"Quaternion.normSq_neg","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (Quaternion.normSq (Neg.neg a)) (Quaternion.normSq a)","decl":"@[simp]\ntheorem normSq_neg : normSq (-a) = normSq a := by simp only [normSq_def, star_neg, neg_mul_neg]\n\n"}
{"name":"Quaternion.self_mul_star","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HMul.hMul a (Star.star a)) ↑(Quaternion.normSq a)","decl":"theorem self_mul_star : a * star a = normSq a := by rw [mul_star_eq_coe, normSq_def]\n\n"}
{"name":"Quaternion.star_mul_self","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HMul.hMul (Star.star a) a) ↑(Quaternion.normSq a)","decl":"theorem star_mul_self : star a * a = normSq a := by rw [star_comm_self, self_mul_star]\n\n"}
{"name":"Quaternion.im_sq","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na : Quaternion R\n⊢ Eq (HPow.hPow a.im 2) (Neg.neg ↑(Quaternion.normSq a.im))","decl":"theorem im_sq : a.im ^ 2 = -normSq a.im := by\n  simp_rw [sq, ← star_mul_self, im_star, neg_mul, neg_neg]\n\n"}
{"name":"Quaternion.coe_normSq_add","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (↑(Quaternion.normSq (HAdd.hAdd a b))) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (↑(Quaternion.normSq a)) (HMul.hMul a (Star.star b))) (HMul.hMul b (Star.star a))) ↑(Quaternion.normSq b))","decl":"theorem coe_normSq_add : normSq (a + b) = normSq a + a * star b + b * star a + normSq b := by\n  simp only [star_add, ← self_mul_star, mul_add, add_mul, add_assoc, add_left_comm]\n\n"}
{"name":"Quaternion.normSq_smul","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nr : R\nq : Quaternion R\n⊢ Eq (Quaternion.normSq (HSMul.hSMul r q)) (HMul.hMul (HPow.hPow r 2) (Quaternion.normSq q))","decl":"theorem normSq_smul (r : R) (q : ℍ[R]) : normSq (r • q) = r ^ 2 * normSq q := by\n  simp only [normSq_def', smul_re, smul_imI, smul_imJ, smul_imK, mul_pow, mul_add, smul_eq_mul]\n\n"}
{"name":"Quaternion.normSq_add","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na b : Quaternion R\n⊢ Eq (Quaternion.normSq (HAdd.hAdd a b)) (HAdd.hAdd (HAdd.hAdd (Quaternion.normSq a) (Quaternion.normSq b)) (HMul.hMul 2 (HMul.hMul a (Star.star b)).re))","decl":"theorem normSq_add (a b : ℍ[R]) : normSq (a + b) = normSq a + normSq b + 2 * (a * star b).re :=\n  calc\n    normSq (a + b) = normSq a + (a * star b).re + ((b * star a).re + normSq b) := by\n      simp_rw [normSq_def, star_add, add_mul, mul_add, add_re]\n    _ = normSq a + normSq b + ((a * star b).re + (b * star a).re) := by abel\n    _ = normSq a + normSq b + 2 * (a * star b).re := by\n      rw [← add_re, ← star_mul_star a b, self_add_star', coe_re]\n\n"}
{"name":"Quaternion.normSq_eq_zero","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\na : Quaternion R\n⊢ Iff (Eq (Quaternion.normSq a) 0) (Eq a 0)","decl":"@[simp]\ntheorem normSq_eq_zero : normSq a = 0 ↔ a = 0 := by\n  refine ⟨fun h => ?_, fun h => h.symm ▸ normSq.map_zero⟩\n  rw [normSq_def', add_eq_zero_iff_of_nonneg, add_eq_zero_iff_of_nonneg, add_eq_zero_iff_of_nonneg]\n    at h\n  · exact ext a 0 (pow_eq_zero h.1.1.1) (pow_eq_zero h.1.1.2) (pow_eq_zero h.1.2) (pow_eq_zero h.2)\n  all_goals apply_rules [sq_nonneg, add_nonneg]\n\n"}
{"name":"Quaternion.normSq_ne_zero","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\na : Quaternion R\n⊢ Iff (Ne (Quaternion.normSq a) 0) (Ne a 0)","decl":"theorem normSq_ne_zero : normSq a ≠ 0 ↔ a ≠ 0 := normSq_eq_zero.not\n\n"}
{"name":"Quaternion.normSq_nonneg","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\na : Quaternion R\n⊢ LE.le 0 (Quaternion.normSq a)","decl":"@[simp]\ntheorem normSq_nonneg : 0 ≤ normSq a := by\n  rw [normSq_def']\n  apply_rules [sq_nonneg, add_nonneg]\n\n"}
{"name":"Quaternion.normSq_le_zero","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\na : Quaternion R\n⊢ Iff (LE.le (Quaternion.normSq a) 0) (Eq a 0)","decl":"@[simp]\ntheorem normSq_le_zero : normSq a ≤ 0 ↔ a = 0 :=\n  normSq_nonneg.le_iff_eq.trans normSq_eq_zero\n\n"}
{"name":"Quaternion.instNontrivial","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\n⊢ Nontrivial (Quaternion R)","decl":"instance instNontrivial : Nontrivial ℍ[R] where\n  exists_pair_ne := ⟨0, 1, mt (congr_arg QuaternionAlgebra.re) zero_ne_one⟩\n\n"}
{"name":"Quaternion.instNoZeroDivisors","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\n⊢ NoZeroDivisors (Quaternion R)","decl":"instance : NoZeroDivisors ℍ[R] where\n  eq_zero_or_eq_zero_of_mul_eq_zero {a b} hab :=\n    have : normSq a * normSq b = 0 := by rwa [← map_mul, normSq_eq_zero]\n    (eq_zero_or_eq_zero_of_mul_eq_zero this).imp normSq_eq_zero.1 normSq_eq_zero.1\n\n"}
{"name":"Quaternion.instIsDomain","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\n⊢ IsDomain (Quaternion R)","decl":"instance : IsDomain ℍ[R] := NoZeroDivisors.to_isDomain _\n\n"}
{"name":"Quaternion.sq_eq_normSq","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\na : Quaternion R\n⊢ Iff (Eq (HPow.hPow a 2) ↑(Quaternion.normSq a)) (Eq a ↑a.re)","decl":"theorem sq_eq_normSq : a ^ 2 = normSq a ↔ a = a.re := by\n  rw [← star_eq_self, ← star_mul_self, sq, mul_eq_mul_right_iff, eq_comm]\n  exact or_iff_left_of_imp fun ha ↦ ha.symm ▸ star_zero _\n\n"}
{"name":"Quaternion.sq_eq_neg_normSq","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\na : Quaternion R\n⊢ Iff (Eq (HPow.hPow a 2) (Neg.neg ↑(Quaternion.normSq a))) (Eq a.re 0)","decl":"theorem sq_eq_neg_normSq : a ^ 2 = -normSq a ↔ a.re = 0 := by\n  simp_rw [← star_eq_neg]\n  obtain rfl | hq0 := eq_or_ne a 0\n  · simp\n  · rw [← star_mul_self, ← mul_neg, ← neg_sq, sq, mul_left_inj' (neg_ne_zero.mpr hq0), eq_comm]\n\n"}
{"name":"Quaternion.instInv_inv","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\na : Quaternion R\n⊢ Eq (Inv.inv a) (HSMul.hSMul (Inv.inv (Quaternion.normSq a)) (Star.star a))","decl":"@[simps (config := .lemmasOnly)]\ninstance instInv : Inv ℍ[R] :=\n  ⟨fun a => (normSq a)⁻¹ • star a⟩\n\n"}
{"name":"Quaternion.coe_inv","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nx : R\n⊢ Eq (↑(Inv.inv x)) (Inv.inv ↑x)","decl":"@[norm_cast, simp]\ntheorem coe_inv (x : R) : ((x⁻¹ : R) : ℍ[R]) = (↑x)⁻¹ :=\n  map_inv₀ (algebraMap R ℍ[R]) _\n\n"}
{"name":"Quaternion.coe_div","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nx y : R\n⊢ Eq (↑(HDiv.hDiv x y)) (HDiv.hDiv ↑x ↑y)","decl":"@[norm_cast, simp]\ntheorem coe_div (x y : R) : ((x / y : R) : ℍ[R]) = x / y :=\n  map_div₀ (algebraMap R ℍ[R]) x y\n\n"}
{"name":"Quaternion.coe_zpow","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nx : R\nz : Int\n⊢ Eq (↑(HPow.hPow x z)) (HPow.hPow (↑x) z)","decl":"@[norm_cast, simp]\ntheorem coe_zpow (x : R) (z : ℤ) : ((x ^ z : R) : ℍ[R]) = (x : ℍ[R]) ^ z :=\n  map_zpow₀ (algebraMap R ℍ[R]) x z\n\n"}
{"name":"Quaternion.re_nnratCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : NNRat\n⊢ Eq (↑q).re ↑q","decl":"@[simp, norm_cast] lemma re_nnratCast (q : ℚ≥0) : (q : ℍ[R]).re = q := rfl\n"}
{"name":"Quaternion.im_nnratCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : NNRat\n⊢ Eq (↑q).im 0","decl":"@[simp, norm_cast] lemma im_nnratCast (q : ℚ≥0) : (q : ℍ[R]).im = 0 := rfl\n"}
{"name":"Quaternion.imI_nnratCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : NNRat\n⊢ Eq (↑q).imI 0","decl":"@[simp, norm_cast] lemma imI_nnratCast (q : ℚ≥0) : (q : ℍ[R]).imI = 0 := rfl\n"}
{"name":"Quaternion.imJ_nnratCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : NNRat\n⊢ Eq (↑q).imJ 0","decl":"@[simp, norm_cast] lemma imJ_nnratCast (q : ℚ≥0) : (q : ℍ[R]).imJ = 0 := rfl\n"}
{"name":"Quaternion.imK_nnratCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : NNRat\n⊢ Eq (↑q).imK 0","decl":"@[simp, norm_cast] lemma imK_nnratCast (q : ℚ≥0) : (q : ℍ[R]).imK = 0 := rfl\n"}
{"name":"Quaternion.ratCast_re","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : Rat\n⊢ Eq (↑q).re ↑q","decl":"@[simp, norm_cast] lemma ratCast_re (q : ℚ) : (q : ℍ[R]).re = q := rfl\n"}
{"name":"Quaternion.ratCast_im","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : Rat\n⊢ Eq (↑q).im 0","decl":"@[simp, norm_cast] lemma ratCast_im (q : ℚ) : (q : ℍ[R]).im = 0 := rfl\n"}
{"name":"Quaternion.ratCast_imI","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : Rat\n⊢ Eq (↑q).imI 0","decl":"@[simp, norm_cast] lemma ratCast_imI (q : ℚ) : (q : ℍ[R]).imI = 0 := rfl\n"}
{"name":"Quaternion.ratCast_imJ","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : Rat\n⊢ Eq (↑q).imJ 0","decl":"@[simp, norm_cast] lemma ratCast_imJ (q : ℚ) : (q : ℍ[R]).imJ = 0 := rfl\n"}
{"name":"Quaternion.ratCast_imK","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : Rat\n⊢ Eq (↑q).imK 0","decl":"@[simp, norm_cast] lemma ratCast_imK (q : ℚ) : (q : ℍ[R]).imK = 0 := rfl\n\n"}
{"name":"Quaternion.coe_nnratCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : NNRat\n⊢ Eq ↑↑q ↑q","decl":"@[norm_cast] lemma coe_nnratCast (q : ℚ≥0) : ↑(q : R) = (q : ℍ[R]) := rfl\n\n"}
{"name":"Quaternion.coe_ratCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : Rat\n⊢ Eq ↑↑q ↑q","decl":"@[norm_cast] lemma coe_ratCast (q : ℚ) : ↑(q : R) = (q : ℍ[R]) := rfl\n\n"}
{"name":"Quaternion.normSq_inv","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\na : Quaternion R\n⊢ Eq (Quaternion.normSq (Inv.inv a)) (Inv.inv (Quaternion.normSq a))","decl":"theorem normSq_inv : normSq a⁻¹ = (normSq a)⁻¹ :=\n  map_inv₀ normSq _\n\n"}
{"name":"Quaternion.normSq_div","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\na b : Quaternion R\n⊢ Eq (Quaternion.normSq (HDiv.hDiv a b)) (HDiv.hDiv (Quaternion.normSq a) (Quaternion.normSq b))","decl":"theorem normSq_div : normSq (a / b) = normSq a / normSq b :=\n  map_div₀ normSq a b\n\n"}
{"name":"Quaternion.normSq_zpow","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\na : Quaternion R\nz : Int\n⊢ Eq (Quaternion.normSq (HPow.hPow a z)) (HPow.hPow (Quaternion.normSq a) z)","decl":"theorem normSq_zpow (z : ℤ) : normSq (a ^ z) = normSq a ^ z :=\n  map_zpow₀ normSq a z\n\n"}
{"name":"Quaternion.normSq_ratCast","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedField R\nq : Rat\n⊢ Eq (↑(Quaternion.normSq ↑q)) (HPow.hPow (↑q) 2)","decl":"@[norm_cast]\ntheorem normSq_ratCast (q : ℚ) : normSq (q : ℍ[R]) = (q : ℍ[R]) ^ 2 := by\n  rw [← coe_ratCast, normSq_coe, coe_pow]\n\n"}
{"name":"Cardinal.mk_quaternionAlgebra","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\n⊢ Eq (Cardinal.mk (QuaternionAlgebra R c₁ c₂ c₃)) (HPow.hPow (Cardinal.mk R) 4)","decl":"/-- The cardinality of a quaternion algebra, as a type. -/\ntheorem mk_quaternionAlgebra : #(ℍ[R,c₁,c₂,c₃]) = #R ^ 4 := by\n  rw [mk_congr (QuaternionAlgebra.equivProd c₁ c₂ c₃)]\n  simp only [mk_prod, lift_id]\n  ring\n\n"}
{"name":"Cardinal.mk_quaternionAlgebra_of_infinite","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\ninst✝ : Infinite R\n⊢ Eq (Cardinal.mk (QuaternionAlgebra R c₁ c₂ c₃)) (Cardinal.mk R)","decl":"@[simp]\ntheorem mk_quaternionAlgebra_of_infinite [Infinite R] : #(ℍ[R,c₁,c₂,c₃]) = #R := by\n  rw [mk_quaternionAlgebra, pow_four]\n\n"}
{"name":"Cardinal.mk_univ_quaternionAlgebra","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\n⊢ Eq (Cardinal.mk ↑Set.univ) (HPow.hPow (Cardinal.mk R) 4)","decl":"/-- The cardinality of a quaternion algebra, as a set. -/\ntheorem mk_univ_quaternionAlgebra : #(Set.univ : Set ℍ[R,c₁,c₂,c₃]) = #R ^ 4 := by\n  rw [mk_univ, mk_quaternionAlgebra]\n\n"}
{"name":"Cardinal.mk_univ_quaternionAlgebra_of_infinite","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\nc₁ c₂ c₃ : R\ninst✝ : Infinite R\n⊢ Eq (Cardinal.mk ↑Set.univ) (Cardinal.mk R)","decl":"theorem mk_univ_quaternionAlgebra_of_infinite [Infinite R] :\n    #(Set.univ : Set ℍ[R,c₁,c₂,c₃]) = #R := by rw [mk_univ_quaternionAlgebra, pow_four]\n\n"}
{"name":"Cardinal.mk_quaternion","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : Neg R\n⊢ Eq (Cardinal.mk (Quaternion R)) (HPow.hPow (Cardinal.mk R) 4)","decl":"/-- The cardinality of the quaternions, as a type. -/\n@[simp]\ntheorem mk_quaternion : #(ℍ[R]) = #R ^ 4 :=\n  mk_quaternionAlgebra _ _ _\n\n"}
{"name":"Cardinal.mk_quaternion_of_infinite","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝³ : Zero R\ninst✝² : One R\ninst✝¹ : Neg R\ninst✝ : Infinite R\n⊢ Eq (Cardinal.mk (Quaternion R)) (Cardinal.mk R)","decl":"theorem mk_quaternion_of_infinite [Infinite R] : #(ℍ[R]) = #R :=\n  mk_quaternionAlgebra_of_infinite _ _ _\n\n"}
{"name":"Cardinal.mk_univ_quaternion","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝² : Zero R\ninst✝¹ : One R\ninst✝ : Neg R\n⊢ Eq (Cardinal.mk ↑Set.univ) (HPow.hPow (Cardinal.mk R) 4)","decl":"/-- The cardinality of the quaternions, as a set. -/\ntheorem mk_univ_quaternion : #(Set.univ : Set ℍ[R]) = #R ^ 4 :=\n  mk_univ_quaternionAlgebra _ _ _\n\n"}
{"name":"Cardinal.mk_univ_quaternion_of_infinite","module":"Mathlib.Algebra.Quaternion","initialProofState":"R : Type u_1\ninst✝³ : Zero R\ninst✝² : One R\ninst✝¹ : Neg R\ninst✝ : Infinite R\n⊢ Eq (Cardinal.mk ↑Set.univ) (Cardinal.mk R)","decl":"theorem mk_univ_quaternion_of_infinite [Infinite R] : #(Set.univ : Set ℍ[R]) = #R :=\n  mk_univ_quaternionAlgebra_of_infinite _ _ _\n\n"}
