{"name":"Nat.noZeroSMulDivisors","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : CharZero R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\n⊢ NoZeroSMulDivisors Nat M","decl":"theorem Nat.noZeroSMulDivisors\n    (R) (M) [Semiring R] [CharZero R] [AddCommMonoid M] [Module R M] [NoZeroSMulDivisors R M] :\n    NoZeroSMulDivisors ℕ M where\n  eq_zero_or_eq_zero_of_smul_eq_zero {c x} := by rw [← Nat.cast_smul_eq_nsmul R, smul_eq_zero]; simp\n\n"}
{"name":"two_nsmul_eq_zero","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : CharZero R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\n⊢ Iff (Eq (HSMul.hSMul 2 v) 0) (Eq v 0)","decl":"theorem two_nsmul_eq_zero\n    (R) (M) [Semiring R] [CharZero R] [AddCommMonoid M] [Module R M] [NoZeroSMulDivisors R M]\n    {v : M} : 2 • v = 0 ↔ v = 0 := by\n  haveI := Nat.noZeroSMulDivisors R M\n  simp [smul_eq_zero]\n\n"}
{"name":"CharZero.of_module","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nM : Type u_3\ninst✝² : AddCommMonoidWithOne M\ninst✝¹ : CharZero M\ninst✝ : Module R M\n⊢ CharZero R","decl":"/-- If `M` is an `R`-module with one and `M` has characteristic zero, then `R` has characteristic\nzero as well. Usually `M` is an `R`-algebra. -/\ntheorem CharZero.of_module (M) [AddCommMonoidWithOne M] [CharZero M] [Module R M] : CharZero R := by\n  refine ⟨fun m n h => @Nat.cast_injective M _ _ _ _ ?_⟩\n  rw [← nsmul_one, ← nsmul_one, ← Nat.cast_smul_eq_nsmul R, ← Nat.cast_smul_eq_nsmul R, h]\n\n"}
{"name":"smul_right_injective","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nc : R\nhc : Ne c 0\n⊢ Function.Injective fun x => HSMul.hSMul c x","decl":"theorem smul_right_injective [NoZeroSMulDivisors R M] {c : R} (hc : c ≠ 0) :\n    Function.Injective (c • · : M → M) :=\n  (injective_iff_map_eq_zero (smulAddHom R M c)).2 fun _ ha => (smul_eq_zero.mp ha).resolve_left hc\n\n"}
{"name":"smul_right_inj","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nc : R\nhc : Ne c 0\nx y : M\n⊢ Iff (Eq (HSMul.hSMul c x) (HSMul.hSMul c y)) (Eq x y)","decl":"theorem smul_right_inj [NoZeroSMulDivisors R M] {c : R} (hc : c ≠ 0) {x y : M} :\n    c • x = c • y ↔ x = y :=\n  (smul_right_injective M hc).eq_iff\n\n"}
{"name":"self_eq_neg","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : CharZero R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\n⊢ Iff (Eq v (Neg.neg v)) (Eq v 0)","decl":"theorem self_eq_neg\n    (R) (M) [Semiring R] [CharZero R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    {v : M} : v = -v ↔ v = 0 := by\n  rw [← two_nsmul_eq_zero R M, two_smul, add_eq_zero_iff_eq_neg]\n\n"}
{"name":"neg_eq_self","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : CharZero R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\n⊢ Iff (Eq (Neg.neg v) v) (Eq v 0)","decl":"theorem neg_eq_self\n    (R) (M) [Semiring R] [CharZero R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    {v : M} : -v = v ↔ v = 0 := by\n  rw [eq_comm, self_eq_neg R M]\n\n"}
{"name":"self_ne_neg","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : CharZero R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\n⊢ Iff (Ne v (Neg.neg v)) (Ne v 0)","decl":"theorem self_ne_neg\n    (R) (M) [Semiring R] [CharZero R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    {v : M} : v ≠ -v ↔ v ≠ 0 :=\n  (self_eq_neg R M).not\n\n"}
{"name":"neg_ne_self","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : CharZero R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nv : M\n⊢ Iff (Ne (Neg.neg v) v) (Ne v 0)","decl":"theorem neg_ne_self\n    (R) (M) [Semiring R] [CharZero R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    {v : M} : -v ≠ v ↔ v ≠ 0 :=\n  (neg_eq_self R M).not\n\n"}
{"name":"smul_left_injective","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : M\nhx : Ne x 0\n⊢ Function.Injective fun c => HSMul.hSMul c x","decl":"theorem smul_left_injective {x : M} (hx : x ≠ 0) : Function.Injective fun c : R => c • x :=\n  fun c d h =>\n  sub_eq_zero.mp\n    ((smul_eq_zero.mp\n          (calc\n            (c - d) • x = c • x - d • x := sub_smul c d x\n            _ = 0 := sub_eq_zero.mpr h\n            )).resolve_right\n      hx)\n\n"}
{"name":"instNoZeroSMulDivisorsNatOfInt","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"M : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : NoZeroSMulDivisors Int M\n⊢ NoZeroSMulDivisors Nat M","decl":"instance [NoZeroSMulDivisors ℤ M] : NoZeroSMulDivisors ℕ M :=\n  ⟨fun {c x} hcx ↦ by rwa [← Nat.cast_smul_eq_nsmul ℤ, smul_eq_zero, Nat.cast_eq_zero] at hcx⟩\n\n"}
{"name":"NoZeroSMulDivisors.int_of_charZero","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : CharZero R\n⊢ NoZeroSMulDivisors Int M","decl":"theorem NoZeroSMulDivisors.int_of_charZero\n    (R) (M) [Ring R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M] [CharZero R] :\n    NoZeroSMulDivisors ℤ M :=\n  ⟨fun {z x} h ↦ by simpa [← smul_one_smul R z x] using h⟩\n\n"}
{"name":"CharZero.of_noZeroSMulDivisors","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial M\ninst✝ : NoZeroSMulDivisors Int M\n⊢ CharZero R","decl":"/-- Only a ring of characteristic zero can have a non-trivial module without additive or\nscalar torsion. -/\ntheorem CharZero.of_noZeroSMulDivisors [Nontrivial M] [NoZeroSMulDivisors ℤ M] : CharZero R := by\n  refine ⟨fun {n m h} ↦ ?_⟩\n  obtain ⟨x, hx⟩ := exists_ne (0 : M)\n  replace h : (n : ℤ) • x = (m : ℤ) • x := by simp [← Nat.cast_smul_eq_nsmul R, h]\n  simpa using smul_left_injective ℤ hx h\n\n"}
{"name":"instNoZeroSMulDivisorsNatOfInt_1","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"M : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : NoZeroSMulDivisors Int M\n⊢ NoZeroSMulDivisors Nat M","decl":"instance [AddCommGroup M] [NoZeroSMulDivisors ℤ M] : NoZeroSMulDivisors ℕ M :=\n  ⟨fun {c x} hcx ↦ by rwa [← Nat.cast_smul_eq_nsmul ℤ c x, smul_eq_zero, Nat.cast_eq_zero] at hcx⟩\n\n"}
{"name":"GroupWithZero.toNoZeroSMulDivisors","module":"Mathlib.Algebra.NoZeroSMulDivisors.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : GroupWithZero R\ninst✝¹ : AddMonoid M\ninst✝ : DistribMulAction R M\n⊢ NoZeroSMulDivisors R M","decl":"/-- This instance applies to `DivisionSemiring`s, in particular `NNReal` and `NNRat`. -/\ninstance (priority := 100) GroupWithZero.toNoZeroSMulDivisors : NoZeroSMulDivisors R M :=\n  ⟨fun {a _} h ↦ or_iff_not_imp_left.2 fun ha ↦ (smul_eq_zero_iff_eq <| Units.mk0 a ha).1 h⟩\n\n"}
