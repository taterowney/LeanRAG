{"name":"ZMod.dft_apply","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¦ : ZMod N â†’ E\nk : ZMod N\nâŠ¢ Eq (ZMod.dft Î¦ k) (Finset.univ.sum fun j => HSMul.hSMul (ZMod.stdAddChar (Neg.neg (HMul.hMul j k))) (Î¦ j))","decl":"lemma dft_apply (Î¦ : ZMod N â†’ E) (k : ZMod N) :\n    ğ“• Î¦ k = âˆ‘ j : ZMod N, stdAddChar (-(j * k)) â€¢ Î¦ j :=\n  rfl\n\n"}
{"name":"ZMod.dft_def","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¦ : ZMod N â†’ E\nâŠ¢ Eq (ZMod.dft Î¦) fun k => Finset.univ.sum fun j => HSMul.hSMul (ZMod.stdAddChar (Neg.neg (HMul.hMul j k))) (Î¦ j)","decl":"lemma dft_def (Î¦ : ZMod N â†’ E) :\n    ğ“• Î¦ = fun k â†¦ âˆ‘ j : ZMod N, stdAddChar (-(j * k)) â€¢ Î¦ j :=\n  rfl\n\n"}
{"name":"ZMod.invDFT_apply","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¨ : ZMod N â†’ E\nk : ZMod N\nâŠ¢ Eq (ZMod.dft.symm Î¨ k) (HSMul.hSMul (Inv.inv â†‘N) (Finset.univ.sum fun j => HSMul.hSMul (ZMod.stdAddChar (HMul.hMul j k)) (Î¨ j)))","decl":"lemma invDFT_apply (Î¨ : ZMod N â†’ E) (k : ZMod N) :\n    ğ“•â» Î¨ k = (N : â„‚)â»Â¹ â€¢ âˆ‘ j : ZMod N, stdAddChar (j * k) â€¢ Î¨ j := by\n  simp only [dft, LinearEquiv.coe_symm_mk, auxDFT, mul_neg, neg_neg]\n\n"}
{"name":"ZMod.invDFT_def","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¨ : ZMod N â†’ E\nâŠ¢ Eq (ZMod.dft.symm Î¨) fun k => HSMul.hSMul (Inv.inv â†‘N) (Finset.univ.sum fun j => HSMul.hSMul (ZMod.stdAddChar (HMul.hMul j k)) (Î¨ j))","decl":"lemma invDFT_def (Î¨ : ZMod N â†’ E) :\n    ğ“•â» Î¨ = fun k â†¦ (N : â„‚)â»Â¹ â€¢ âˆ‘ j : ZMod N, stdAddChar (j * k) â€¢ Î¨ j :=\n  funext <| invDFT_apply Î¨\n\n"}
{"name":"ZMod.invDFT_apply'","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¨ : ZMod N â†’ E\nk : ZMod N\nâŠ¢ Eq (ZMod.dft.symm Î¨ k) (HSMul.hSMul (Inv.inv â†‘N) (ZMod.dft Î¨ (Neg.neg k)))","decl":"lemma invDFT_apply' (Î¨ : ZMod N â†’ E) (k : ZMod N) : ğ“•â» Î¨ k = (N : â„‚)â»Â¹ â€¢ ğ“• Î¨ (-k) :=\n  rfl\n\n"}
{"name":"ZMod.invDFT_def'","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¨ : ZMod N â†’ E\nâŠ¢ Eq (ZMod.dft.symm Î¨) fun k => HSMul.hSMul (Inv.inv â†‘N) (ZMod.dft Î¨ (Neg.neg k))","decl":"lemma invDFT_def' (Î¨ : ZMod N â†’ E) : ğ“•â» Î¨ = fun k â†¦ (N : â„‚)â»Â¹ â€¢ ğ“• Î¨ (-k) :=\n  rfl\n\n"}
{"name":"ZMod.dft_apply_zero","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¦ : ZMod N â†’ E\nâŠ¢ Eq (ZMod.dft Î¦ 0) (Finset.univ.sum fun j => Î¦ j)","decl":"lemma dft_apply_zero (Î¦ : ZMod N â†’ E) : ğ“• Î¦ 0 = âˆ‘ j, Î¦ j := by\n  simp only [dft_apply, mul_zero, neg_zero, map_zero_eq_one, one_smul]\n\n"}
{"name":"ZMod.dft_eq_fourier","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ³ : NeZero N\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nÎ¦ : ZMod N â†’ E\nk : ZMod N\nâŠ¢ Eq (ZMod.dft Î¦ k) (Fourier.fourierIntegral ZMod.toCircle MeasureTheory.Measure.count Î¦ k)","decl":"/--\nThe discrete Fourier transform agrees with the general one (assuming the target space is a complete\nnormed space).\n-/\nlemma dft_eq_fourier {E : Type*} [NormedAddCommGroup E] [NormedSpace â„‚ E] [CompleteSpace E]\n    (Î¦ : ZMod N â†’ E) (k : ZMod N) :\n    ğ“• Î¦ k = Fourier.fourierIntegral toCircle Measure.count Î¦ k := by\n  simp only [dft_apply, stdAddChar_apply, Fourier.fourierIntegral_def, Circle.smul_def,\n    integral_countable' <| .of_finite .., Measure.count_singleton, ENNReal.one_toReal, one_smul,\n    tsum_fintype]\n\n"}
{"name":"ZMod.dft_const_smul","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœâ´ : NeZero N\nE : Type u_1\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Complex E\nR : Type u_2\ninstâœÂ¹ : DistribSMul R E\ninstâœ : SMulCommClass R Complex E\nr : R\nÎ¦ : ZMod N â†’ E\nâŠ¢ Eq (ZMod.dft (HSMul.hSMul r Î¦)) (HSMul.hSMul r (ZMod.dft Î¦))","decl":"lemma dft_const_smul {R : Type*} [DistribSMul R E] [SMulCommClass R â„‚ E] (r : R) (Î¦ : ZMod N â†’ E) :\n    ğ“• (r â€¢ Î¦) = r â€¢ ğ“• Î¦ := by\n  simp only [Pi.smul_def, dft_def, smul_sum, smul_comm]\n\n"}
{"name":"ZMod.dft_smul_const","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœâ¶ : NeZero N\nE : Type u_1\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module Complex E\nR : Type u_2\ninstâœÂ³ : Ring R\ninstâœÂ² : Module Complex R\ninstâœÂ¹ : Module R E\ninstâœ : IsScalarTower Complex R E\nÎ¦ : ZMod N â†’ R\ne : E\nâŠ¢ Eq (ZMod.dft fun j => HSMul.hSMul (Î¦ j) e) fun k => HSMul.hSMul (ZMod.dft Î¦ k) e","decl":"lemma dft_smul_const {R : Type*} [Ring R] [Module â„‚ R] [Module R E] [IsScalarTower â„‚ R E]\n    (Î¦ : ZMod N â†’ R) (e : E) :\n    ğ“• (fun j â†¦ Î¦ j â€¢ e) = fun k â†¦ ğ“• Î¦ k â€¢ e := by\n  simp only [dft_def, sum_smul, smul_assoc]\n\n"}
{"name":"ZMod.dft_const_mul","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nR : Type u_2\ninstâœÂ¹ : Ring R\ninstâœ : Algebra Complex R\nr : R\nÎ¦ : ZMod N â†’ R\nâŠ¢ Eq (ZMod.dft fun j => HMul.hMul r (Î¦ j)) fun k => HMul.hMul r (ZMod.dft Î¦ k)","decl":"lemma dft_const_mul {R : Type*} [Ring R] [Algebra â„‚ R] (r : R) (Î¦ : ZMod N â†’ R) :\n    ğ“• (fun j â†¦ r * Î¦ j) = fun k â†¦ r * ğ“• Î¦ k :=\n  dft_const_smul r Î¦\n\n"}
{"name":"ZMod.dft_mul_const","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nR : Type u_2\ninstâœÂ¹ : Ring R\ninstâœ : Algebra Complex R\nÎ¦ : ZMod N â†’ R\nr : R\nâŠ¢ Eq (ZMod.dft fun j => HMul.hMul (Î¦ j) r) fun k => HMul.hMul (ZMod.dft Î¦ k) r","decl":"lemma dft_mul_const {R : Type*} [Ring R] [Algebra â„‚ R] (Î¦ : ZMod N â†’ R) (r : R) :\n    ğ“• (fun j â†¦ Î¦ j * r) = fun k â†¦ ğ“• Î¦ k * r :=\n  dft_smul_const Î¦ r\n\n"}
{"name":"ZMod.dft_comp_neg","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¦ : ZMod N â†’ E\nâŠ¢ Eq (ZMod.dft fun j => Î¦ (Neg.neg j)) fun k => ZMod.dft Î¦ (Neg.neg k)","decl":"lemma dft_comp_neg (Î¦ : ZMod N â†’ E) : ğ“• (fun j â†¦ Î¦ (-j)) = fun k â†¦ ğ“• Î¦ (-k) :=\n  auxDFT_neg ..\n\n"}
{"name":"ZMod.dft_dft","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¦ : ZMod N â†’ E\nâŠ¢ Eq (ZMod.dft (ZMod.dft Î¦)) fun j => HSMul.hSMul (â†‘N) (Î¦ (Neg.neg j))","decl":"/-- Fourier inversion formula, discrete case. -/\nlemma dft_dft (Î¦ : ZMod N â†’ E) : ğ“• (ğ“• Î¦) = fun j â†¦ (N : â„‚) â€¢ Î¦ (-j) :=\n  auxDFT_auxDFT ..\n\n"}
{"name":"ZMod.dft_comp_unitMul","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœÂ² : NeZero N\nE : Type u_1\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module Complex E\nÎ¦ : ZMod N â†’ E\nu : Units (ZMod N)\nk : ZMod N\nâŠ¢ Eq (ZMod.dft (fun j => Î¦ (HMul.hMul (â†‘u) j)) k) (ZMod.dft Î¦ (HMul.hMul (â†‘(Inv.inv u)) k))","decl":"lemma dft_comp_unitMul (Î¦ : ZMod N â†’ E) (u : (ZMod N)Ë£) (k : ZMod N) :\n    ğ“• (fun j â†¦ Î¦ (u.val * j)) k = ğ“• Î¦ (uâ»Â¹.val * k) := by\n  refine Fintype.sum_equiv u.mulLeft _ _ fun x â†¦ ?_\n  simp only [mul_comm u.val, u.mulLeft_apply, â† mul_assoc, u.mul_inv_cancel_right]\n\n"}
{"name":"ZMod.dft_even_iff","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœ : NeZero N\nÎ¦ : ZMod N â†’ Complex\nâŠ¢ Iff (Function.Even (ZMod.dft Î¦)) (Function.Even Î¦)","decl":"/-- The discrete Fourier transform of `Î¦` is even if and only if `Î¦` itself is. -/\nlemma dft_even_iff {Î¦ : ZMod N â†’ â„‚} : (ğ“• Î¦).Even â†” Î¦.Even := by\n  have h {f : ZMod N â†’ â„‚} (hf : f.Even) : (ğ“• f).Even := by\n    simp only [Function.Even, â† congr_fun (dft_comp_neg f), funext hf, implies_true]\n  refine âŸ¨fun hÎ¦ x â†¦ ?_, hâŸ©\n  simpa only [neg_neg, smul_right_inj (NeZero.ne (N : â„‚)), dft_dft] using h hÎ¦ (-x)\n\n"}
{"name":"ZMod.dft_odd_iff","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœ : NeZero N\nÎ¦ : ZMod N â†’ Complex\nâŠ¢ Iff (Function.Odd (ZMod.dft Î¦)) (Function.Odd Î¦)","decl":"/-- The discrete Fourier transform of `Î¦` is odd if and only if `Î¦` itself is. -/\nlemma dft_odd_iff {Î¦ : ZMod N â†’ â„‚} : (ğ“• Î¦).Odd â†” Î¦.Odd := by\n  have h {f : ZMod N â†’ â„‚} (hf : f.Odd) : (ğ“• f).Odd := by\n    simp only [Function.Odd, â† congr_fun (dft_comp_neg f), funext hf, â† Pi.neg_apply, map_neg,\n      implies_true]\n  refine âŸ¨fun hÎ¦ x â†¦ ?_, hâŸ©\n  simpa only [neg_neg, dft_dft, â† smul_neg, smul_right_inj (NeZero.ne (N : â„‚))] using h hÎ¦ (-x)\n\n"}
{"name":"DirichletCharacter.fourierTransform_eq_gaussSum_mulShift","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\nk : ZMod N\nâŠ¢ Eq (ZMod.dft (â‡‘Ï‡) k) (gaussSum Ï‡ (ZMod.stdAddChar.mulShift (Neg.neg k)))","decl":"lemma fourierTransform_eq_gaussSum_mulShift (Ï‡ : DirichletCharacter â„‚ N) (k : ZMod N) :\n    ğ“• Ï‡ k = gaussSum Ï‡ (stdAddChar.mulShift (-k)) := by\n  simp only [dft_apply, smul_eq_mul]\n  congr 1 with j\n  rw [mulShift_apply, mul_comm j, neg_mul, stdAddChar_apply, mul_comm (Ï‡ _)]\n\n"}
{"name":"DirichletCharacter.IsPrimitive.fourierTransform_eq_inv_mul_gaussSum","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Ï‡.IsPrimitive\nk : ZMod N\nâŠ¢ Eq (ZMod.dft (â‡‘Ï‡) k) (HMul.hMul ((Inv.inv Ï‡) (Neg.neg k)) (gaussSum Ï‡ ZMod.stdAddChar))","decl":"/-- For a primitive Dirichlet character `Ï‡`, the Fourier transform of `Ï‡` is a constant multiple\nof `Ï‡â»Â¹` (and the constant is essentially the Gauss sum). -/\nlemma IsPrimitive.fourierTransform_eq_inv_mul_gaussSum {Ï‡ : DirichletCharacter â„‚ N}\n    (hÏ‡ : IsPrimitive Ï‡) (k : ZMod N) :\n    ğ“• Ï‡ k = Ï‡â»Â¹ (-k) * gaussSum Ï‡ stdAddChar := by\n  rw [fourierTransform_eq_gaussSum_mulShift, gaussSum_mulShift_of_isPrimitive _ hÏ‡]\n\n"}
