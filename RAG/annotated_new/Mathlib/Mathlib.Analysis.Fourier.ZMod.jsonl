{"name":"ZMod.dft_apply","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΦ : ZMod N → E\nk : ZMod N\n⊢ Eq (ZMod.dft Φ k) (Finset.univ.sum fun j => HSMul.hSMul (ZMod.stdAddChar (Neg.neg (HMul.hMul j k))) (Φ j))","decl":"lemma dft_apply (Φ : ZMod N → E) (k : ZMod N) :\n    𝓕 Φ k = ∑ j : ZMod N, stdAddChar (-(j * k)) • Φ j :=\n  rfl\n\n"}
{"name":"ZMod.dft_def","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΦ : ZMod N → E\n⊢ Eq (ZMod.dft Φ) fun k => Finset.univ.sum fun j => HSMul.hSMul (ZMod.stdAddChar (Neg.neg (HMul.hMul j k))) (Φ j)","decl":"lemma dft_def (Φ : ZMod N → E) :\n    𝓕 Φ = fun k ↦ ∑ j : ZMod N, stdAddChar (-(j * k)) • Φ j :=\n  rfl\n\n"}
{"name":"ZMod.invDFT_apply","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΨ : ZMod N → E\nk : ZMod N\n⊢ Eq (ZMod.dft.symm Ψ k) (HSMul.hSMul (Inv.inv ↑N) (Finset.univ.sum fun j => HSMul.hSMul (ZMod.stdAddChar (HMul.hMul j k)) (Ψ j)))","decl":"lemma invDFT_apply (Ψ : ZMod N → E) (k : ZMod N) :\n    𝓕⁻ Ψ k = (N : ℂ)⁻¹ • ∑ j : ZMod N, stdAddChar (j * k) • Ψ j := by\n  simp only [dft, LinearEquiv.coe_symm_mk, auxDFT, mul_neg, neg_neg]\n\n"}
{"name":"ZMod.invDFT_def","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΨ : ZMod N → E\n⊢ Eq (ZMod.dft.symm Ψ) fun k => HSMul.hSMul (Inv.inv ↑N) (Finset.univ.sum fun j => HSMul.hSMul (ZMod.stdAddChar (HMul.hMul j k)) (Ψ j))","decl":"lemma invDFT_def (Ψ : ZMod N → E) :\n    𝓕⁻ Ψ = fun k ↦ (N : ℂ)⁻¹ • ∑ j : ZMod N, stdAddChar (j * k) • Ψ j :=\n  funext <| invDFT_apply Ψ\n\n"}
{"name":"ZMod.invDFT_apply'","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΨ : ZMod N → E\nk : ZMod N\n⊢ Eq (ZMod.dft.symm Ψ k) (HSMul.hSMul (Inv.inv ↑N) (ZMod.dft Ψ (Neg.neg k)))","decl":"lemma invDFT_apply' (Ψ : ZMod N → E) (k : ZMod N) : 𝓕⁻ Ψ k = (N : ℂ)⁻¹ • 𝓕 Ψ (-k) :=\n  rfl\n\n"}
{"name":"ZMod.invDFT_def'","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΨ : ZMod N → E\n⊢ Eq (ZMod.dft.symm Ψ) fun k => HSMul.hSMul (Inv.inv ↑N) (ZMod.dft Ψ (Neg.neg k))","decl":"lemma invDFT_def' (Ψ : ZMod N → E) : 𝓕⁻ Ψ = fun k ↦ (N : ℂ)⁻¹ • 𝓕 Ψ (-k) :=\n  rfl\n\n"}
{"name":"ZMod.dft_apply_zero","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΦ : ZMod N → E\n⊢ Eq (ZMod.dft Φ 0) (Finset.univ.sum fun j => Φ j)","decl":"lemma dft_apply_zero (Φ : ZMod N → E) : 𝓕 Φ 0 = ∑ j, Φ j := by\n  simp only [dft_apply, mul_zero, neg_zero, map_zero_eq_one, one_smul]\n\n"}
{"name":"ZMod.dft_eq_fourier","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝³ : NeZero N\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nΦ : ZMod N → E\nk : ZMod N\n⊢ Eq (ZMod.dft Φ k) (Fourier.fourierIntegral ZMod.toCircle MeasureTheory.Measure.count Φ k)","decl":"/--\nThe discrete Fourier transform agrees with the general one (assuming the target space is a complete\nnormed space).\n-/\nlemma dft_eq_fourier {E : Type*} [NormedAddCommGroup E] [NormedSpace ℂ E] [CompleteSpace E]\n    (Φ : ZMod N → E) (k : ZMod N) :\n    𝓕 Φ k = Fourier.fourierIntegral toCircle Measure.count Φ k := by\n  simp only [dft_apply, stdAddChar_apply, Fourier.fourierIntegral_def, Circle.smul_def,\n    integral_countable' <| .of_finite .., Measure.count_singleton, ENNReal.one_toReal, one_smul,\n    tsum_fintype]\n\n"}
{"name":"ZMod.dft_const_smul","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝⁴ : NeZero N\nE : Type u_1\ninst✝³ : AddCommGroup E\ninst✝² : Module Complex E\nR : Type u_2\ninst✝¹ : DistribSMul R E\ninst✝ : SMulCommClass R Complex E\nr : R\nΦ : ZMod N → E\n⊢ Eq (ZMod.dft (HSMul.hSMul r Φ)) (HSMul.hSMul r (ZMod.dft Φ))","decl":"lemma dft_const_smul {R : Type*} [DistribSMul R E] [SMulCommClass R ℂ E] (r : R) (Φ : ZMod N → E) :\n    𝓕 (r • Φ) = r • 𝓕 Φ := by\n  simp only [Pi.smul_def, dft_def, smul_sum, smul_comm]\n\n"}
{"name":"ZMod.dft_smul_const","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝⁶ : NeZero N\nE : Type u_1\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\nR : Type u_2\ninst✝³ : Ring R\ninst✝² : Module Complex R\ninst✝¹ : Module R E\ninst✝ : IsScalarTower Complex R E\nΦ : ZMod N → R\ne : E\n⊢ Eq (ZMod.dft fun j => HSMul.hSMul (Φ j) e) fun k => HSMul.hSMul (ZMod.dft Φ k) e","decl":"lemma dft_smul_const {R : Type*} [Ring R] [Module ℂ R] [Module R E] [IsScalarTower ℂ R E]\n    (Φ : ZMod N → R) (e : E) :\n    𝓕 (fun j ↦ Φ j • e) = fun k ↦ 𝓕 Φ k • e := by\n  simp only [dft_def, sum_smul, smul_assoc]\n\n"}
{"name":"ZMod.dft_const_mul","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nR : Type u_2\ninst✝¹ : Ring R\ninst✝ : Algebra Complex R\nr : R\nΦ : ZMod N → R\n⊢ Eq (ZMod.dft fun j => HMul.hMul r (Φ j)) fun k => HMul.hMul r (ZMod.dft Φ k)","decl":"lemma dft_const_mul {R : Type*} [Ring R] [Algebra ℂ R] (r : R) (Φ : ZMod N → R) :\n    𝓕 (fun j ↦ r * Φ j) = fun k ↦ r * 𝓕 Φ k :=\n  dft_const_smul r Φ\n\n"}
{"name":"ZMod.dft_mul_const","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nR : Type u_2\ninst✝¹ : Ring R\ninst✝ : Algebra Complex R\nΦ : ZMod N → R\nr : R\n⊢ Eq (ZMod.dft fun j => HMul.hMul (Φ j) r) fun k => HMul.hMul (ZMod.dft Φ k) r","decl":"lemma dft_mul_const {R : Type*} [Ring R] [Algebra ℂ R] (Φ : ZMod N → R) (r : R) :\n    𝓕 (fun j ↦ Φ j * r) = fun k ↦ 𝓕 Φ k * r :=\n  dft_smul_const Φ r\n\n"}
{"name":"ZMod.dft_comp_neg","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΦ : ZMod N → E\n⊢ Eq (ZMod.dft fun j => Φ (Neg.neg j)) fun k => ZMod.dft Φ (Neg.neg k)","decl":"lemma dft_comp_neg (Φ : ZMod N → E) : 𝓕 (fun j ↦ Φ (-j)) = fun k ↦ 𝓕 Φ (-k) :=\n  auxDFT_neg ..\n\n"}
{"name":"ZMod.dft_dft","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΦ : ZMod N → E\n⊢ Eq (ZMod.dft (ZMod.dft Φ)) fun j => HSMul.hSMul (↑N) (Φ (Neg.neg j))","decl":"/-- Fourier inversion formula, discrete case. -/\nlemma dft_dft (Φ : ZMod N → E) : 𝓕 (𝓕 Φ) = fun j ↦ (N : ℂ) • Φ (-j) :=\n  auxDFT_auxDFT ..\n\n"}
{"name":"ZMod.dft_comp_unitMul","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝² : NeZero N\nE : Type u_1\ninst✝¹ : AddCommGroup E\ninst✝ : Module Complex E\nΦ : ZMod N → E\nu : Units (ZMod N)\nk : ZMod N\n⊢ Eq (ZMod.dft (fun j => Φ (HMul.hMul (↑u) j)) k) (ZMod.dft Φ (HMul.hMul (↑(Inv.inv u)) k))","decl":"lemma dft_comp_unitMul (Φ : ZMod N → E) (u : (ZMod N)ˣ) (k : ZMod N) :\n    𝓕 (fun j ↦ Φ (u.val * j)) k = 𝓕 Φ (u⁻¹.val * k) := by\n  refine Fintype.sum_equiv u.mulLeft _ _ fun x ↦ ?_\n  simp only [mul_comm u.val, u.mulLeft_apply, ← mul_assoc, u.mul_inv_cancel_right]\n\n"}
{"name":"ZMod.dft_even_iff","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝ : NeZero N\nΦ : ZMod N → Complex\n⊢ Iff (Function.Even (ZMod.dft Φ)) (Function.Even Φ)","decl":"/-- The discrete Fourier transform of `Φ` is even if and only if `Φ` itself is. -/\nlemma dft_even_iff {Φ : ZMod N → ℂ} : (𝓕 Φ).Even ↔ Φ.Even := by\n  have h {f : ZMod N → ℂ} (hf : f.Even) : (𝓕 f).Even := by\n    simp only [Function.Even, ← congr_fun (dft_comp_neg f), funext hf, implies_true]\n  refine ⟨fun hΦ x ↦ ?_, h⟩\n  simpa only [neg_neg, smul_right_inj (NeZero.ne (N : ℂ)), dft_dft] using h hΦ (-x)\n\n"}
{"name":"ZMod.dft_odd_iff","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝ : NeZero N\nΦ : ZMod N → Complex\n⊢ Iff (Function.Odd (ZMod.dft Φ)) (Function.Odd Φ)","decl":"/-- The discrete Fourier transform of `Φ` is odd if and only if `Φ` itself is. -/\nlemma dft_odd_iff {Φ : ZMod N → ℂ} : (𝓕 Φ).Odd ↔ Φ.Odd := by\n  have h {f : ZMod N → ℂ} (hf : f.Odd) : (𝓕 f).Odd := by\n    simp only [Function.Odd, ← congr_fun (dft_comp_neg f), funext hf, ← Pi.neg_apply, map_neg,\n      implies_true]\n  refine ⟨fun hΦ x ↦ ?_, h⟩\n  simpa only [neg_neg, dft_dft, ← smul_neg, smul_right_inj (NeZero.ne (N : ℂ))] using h hΦ (-x)\n\n"}
{"name":"DirichletCharacter.fourierTransform_eq_gaussSum_mulShift","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝ : NeZero N\nχ : DirichletCharacter Complex N\nk : ZMod N\n⊢ Eq (ZMod.dft (⇑χ) k) (gaussSum χ (ZMod.stdAddChar.mulShift (Neg.neg k)))","decl":"lemma fourierTransform_eq_gaussSum_mulShift (χ : DirichletCharacter ℂ N) (k : ZMod N) :\n    𝓕 χ k = gaussSum χ (stdAddChar.mulShift (-k)) := by\n  simp only [dft_apply, smul_eq_mul]\n  congr 1 with j\n  rw [mulShift_apply, mul_comm j, neg_mul, stdAddChar_apply, mul_comm (χ _)]\n\n"}
{"name":"DirichletCharacter.IsPrimitive.fourierTransform_eq_inv_mul_gaussSum","module":"Mathlib.Analysis.Fourier.ZMod","initialProofState":"N : Nat\ninst✝ : NeZero N\nχ : DirichletCharacter Complex N\nhχ : χ.IsPrimitive\nk : ZMod N\n⊢ Eq (ZMod.dft (⇑χ) k) (HMul.hMul ((Inv.inv χ) (Neg.neg k)) (gaussSum χ ZMod.stdAddChar))","decl":"/-- For a primitive Dirichlet character `χ`, the Fourier transform of `χ` is a constant multiple\nof `χ⁻¹` (and the constant is essentially the Gauss sum). -/\nlemma IsPrimitive.fourierTransform_eq_inv_mul_gaussSum {χ : DirichletCharacter ℂ N}\n    (hχ : IsPrimitive χ) (k : ZMod N) :\n    𝓕 χ k = χ⁻¹ (-k) * gaussSum χ stdAddChar := by\n  rw [fourierTransform_eq_gaussSum_mulShift, gaussSum_mulShift_of_isPrimitive _ hχ]\n\n"}
