{"name":"AlgebraicGeometry.StructureSheaf.localRingLocalizations","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nP : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\n‚ä¢ IsLocalRing (AlgebraicGeometry.StructureSheaf.Localizations R P)","decl":"instance localRingLocalizations (P : PrimeSpectrum.Top R) : IsLocalRing <| Localizations R P :=\n  inferInstanceAs <| IsLocalRing <| Localization.AtPrime P.asIdeal\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.instAtPrimeLocalizationsValŒ±TopologicalSpaceTopMemOpensAsIdeal","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nx : Subtype fun x => Membership.mem U x\n‚ä¢ IsLocalization.AtPrime (AlgebraicGeometry.StructureSheaf.Localizations R ‚Üëx) (‚Üëx).asIdeal","decl":"instance (U : Opens (PrimeSpectrum.Top R)) (x : U) :\n    IsLocalization.AtPrime (Localizations R x) (x : PrimeSpectrum.Top R).asIdeal :=\n  Localization.isLocalization\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.IsFraction.eq_mk'","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nf : (x : Subtype fun x => Membership.mem U x) ‚Üí AlgebraicGeometry.StructureSheaf.Localizations R ‚Üëx\nhf : AlgebraicGeometry.StructureSheaf.IsFraction f\n‚ä¢ Exists fun r => Exists fun s => ‚àÄ (x : Subtype fun x => Membership.mem U x), Exists fun hs => Eq (f x) (IsLocalization.mk' (Localization.AtPrime (‚Üëx).asIdeal) r ‚ü®s, hs‚ü©)","decl":"theorem IsFraction.eq_mk' {U : Opens (PrimeSpectrum.Top R)} {f : ‚àÄ x : U, Localizations R x}\n    (hf : IsFraction f) :\n    ‚àÉ r s : R,\n      ‚àÄ x : U,\n        ‚àÉ hs : s ‚àâ x.1.asIdeal,\n          f x =\n            IsLocalization.mk' (Localization.AtPrime _) r\n              (‚ü®s, hs‚ü© : (x : PrimeSpectrum.Top R).asIdeal.primeCompl) := by\n  rcases hf with ‚ü®r, s, h‚ü©\n  refine ‚ü®r, s, fun x => ‚ü®(h x).1, (IsLocalization.mk'_eq_iff_eq_mul.mpr ?_).symm‚ü©‚ü©\n  exact (h x).2.symm\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.isLocallyFraction_pred","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nf : (x : Subtype fun x => Membership.mem U x) ‚Üí AlgebraicGeometry.StructureSheaf.Localizations R ‚Üëx\n‚ä¢ Eq ((AlgebraicGeometry.StructureSheaf.isLocallyFraction R).pred f) (‚àÄ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => Exists fun r => Exists fun s => ‚àÄ (y : Subtype fun x => Membership.mem V x), And (Not (Membership.mem (‚Üëy).asIdeal s)) (Eq (HMul.hMul (f ((fun x => ‚ü®‚Üëx, ‚ãØ‚ü©) y)) ((algebraMap R (AlgebraicGeometry.StructureSheaf.Localizations R ‚Üë((fun x => ‚ü®‚Üëx, ‚ãØ‚ü©) y))) s)) ((algebraMap R (AlgebraicGeometry.StructureSheaf.Localizations R ‚Üë((fun x => ‚ü®‚Üëx, ‚ãØ‚ü©) y))) r)))","decl":"@[simp]\ntheorem isLocallyFraction_pred {U : Opens (PrimeSpectrum.Top R)} (f : ‚àÄ x : U, Localizations R x) :\n    (isLocallyFraction R).pred f =\n      ‚àÄ x : U,\n        ‚àÉ (V : _) (_ : x.1 ‚àà V) (i : V ‚ü∂ U),\n          ‚àÉ r s : R,\n            ‚àÄ y : V, ¬¨s ‚àà y.1.asIdeal ‚àß f (i y : U) * algebraMap _ _ s = algebraMap _ _ r :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.structurePresheafInCommRing_obj_carrier","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : Opposite (TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R))\n‚ä¢ Eq (‚Üë((AlgebraicGeometry.structurePresheafInCommRing R).obj U)) ((AlgebraicGeometry.structureSheafInType R).val.obj U)","decl":"/-- The structure presheaf, valued in `CommRingCat`, constructed by dressing up the `Type` valued\nstructure presheaf.\n-/\n@[simps obj_carrier]\ndef structurePresheafInCommRing : Presheaf CommRingCat (PrimeSpectrum.Top R) where\n  obj U := CommRingCat.of ((structureSheafInType R).1.obj U)\n  map {_ _} i := CommRingCat.ofHom\n    { toFun := (structureSheafInType R).1.map i\n      map_zero' := rfl\n      map_add' := fun _ _ => rfl\n      map_one' := rfl\n      map_mul' := fun _ _ => rfl }\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.res_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU V : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\ni : Quiver.Hom V U\ns : ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj { unop := U })\nx : Subtype fun x => Membership.mem V x\n‚ä¢ Eq (‚Üë((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).val.map i.op)) s) x) (‚Üës ((fun x => ‚ü®‚Üëx, ‚ãØ‚ü©) x))","decl":"@[simp]\ntheorem res_apply (U V : Opens (PrimeSpectrum.Top R)) (i : V ‚ü∂ U)\n    (s : (structureSheaf R).1.obj (op U)) (x : V) :\n    ((structureSheaf R).1.map i.op s).1 x = (s.1 (i x) :) :=\n  rfl\n\n/-\n\nNotation in this comment\n\nX = Spec R\nOX = structure sheaf\n\nIn the following we construct an isomorphism between OX_p and R_p given any point p corresponding\nto a prime ideal in R.\n\nWe do this via 8 steps:\n\n1. def const (f g : R) (V) (hv : V ‚â§ D_g) : OX(V) [for api]\n2. def toOpen (U) : R ‚ü∂ OX(U)\n3. [2] def toStalk (p : Spec R) : R ‚ü∂ OX_p\n4. [2] def toBasicOpen (f : R) : R_f ‚ü∂ OX(D_f)\n5. [3] def localizationToStalk (p : Spec R) : R_p ‚ü∂ OX_p\n6. def openToLocalization (U) (p) (hp : p ‚àà U) : OX(U) ‚ü∂ R_p\n7. [6] def stalkToFiberRingHom (p : Spec R) : OX_p ‚ü∂ R_p\n8. [5,7] def stalkIso (p : Spec R) : OX_p ‚âÖ R_p\n\nIn the square brackets we list the dependencies of a construction on the previous steps.\n\n-/\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf g : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g\nx : Subtype fun x => Membership.mem U x\n‚ä¢ Eq (‚Üë(AlgebraicGeometry.StructureSheaf.const R f g U hu) x) (IsLocalization.mk' (Localization.AtPrime (‚Üëx).asIdeal) f ‚ü®g, ‚ãØ‚ü©)","decl":"@[simp]\ntheorem const_apply (f g : R) (U : Opens (PrimeSpectrum.Top R))\n    (hu : ‚àÄ x ‚àà U, g ‚àà (x : PrimeSpectrum.Top R).asIdeal.primeCompl) (x : U) :\n    (const R f g U hu).1 x =\n      IsLocalization.mk' (Localization.AtPrime x.1.asIdeal) f ‚ü®g, hu x x.2‚ü© :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_apply'","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf g : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g\nx : Subtype fun x => Membership.mem U x\nhx : Membership.mem (‚Üëx).asIdeal.primeCompl g\n‚ä¢ Eq (‚Üë(AlgebraicGeometry.StructureSheaf.const R f g U hu) x) (IsLocalization.mk' (AlgebraicGeometry.StructureSheaf.Localizations R ‚Üëx) f ‚ü®g, hx‚ü©)","decl":"theorem const_apply' (f g : R) (U : Opens (PrimeSpectrum.Top R))\n    (hu : ‚àÄ x ‚àà U, g ‚àà (x : PrimeSpectrum.Top R).asIdeal.primeCompl) (x : U)\n    (hx : g ‚àà (x : PrimeSpectrum.Top R).asIdeal.primeCompl) :\n    (const R f g U hu).1 x = IsLocalization.mk' _ f ‚ü®g, hx‚ü© :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.exists_const","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\ns : ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj { unop := U })\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhx : Membership.mem U x\n‚ä¢ Exists fun V => Exists fun x => Exists fun i => Exists fun f => Exists fun g => Exists fun hg => Eq (AlgebraicGeometry.StructureSheaf.const R f g V hg) ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).val.map i.op)) s)","decl":"theorem exists_const (U) (s : (structureSheaf R).1.obj (op U)) (x : PrimeSpectrum.Top R)\n    (hx : x ‚àà U) :\n    ‚àÉ (V : Opens (PrimeSpectrum.Top R)) (_ : x ‚àà V) (i : V ‚ü∂ U) (f g : R) (hg : _),\n      const R f g V hg = (structureSheaf R).1.map i.op s :=\n  let ‚ü®V, hxV, iVU, f, g, hfg‚ü© := s.2 ‚ü®x, hx‚ü©\n  ‚ü®V, hxV, iVU, f, g, fun y hyV => (hfg ‚ü®y, hyV‚ü©).1,\n    Subtype.eq <| funext fun y => IsLocalization.mk'_eq_iff_eq_mul.2 <| Eq.symm <| (hfg y).2‚ü©\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.res_const","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf g : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g\nV : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhv : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem V x ‚Üí Membership.mem x.asIdeal.primeCompl g\ni : Quiver.Hom { unop := U } { unop := V }\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).val.map i)) (AlgebraicGeometry.StructureSheaf.const R f g U hu)) (AlgebraicGeometry.StructureSheaf.const R f g V hv)","decl":"@[simp]\ntheorem res_const (f g : R) (U hu V hv i) :\n    (structureSheaf R).1.map i (const R f g U hu) = const R f g V hv :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.res_const'","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf g : R\nV : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhv : LE.le V (PrimeSpectrum.basicOpen g)\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).val.map (CategoryTheory.homOfLE hv).op)) (AlgebraicGeometry.StructureSheaf.const R f g (PrimeSpectrum.basicOpen g) ‚ãØ)) (AlgebraicGeometry.StructureSheaf.const R f g V hv)","decl":"theorem res_const' (f g : R) (V hv) :\n    (structureSheaf R).1.map (homOfLE hv).op (const R f g (PrimeSpectrum.basicOpen g) fun _ => id) =\n      const R f g V hv :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_zero","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl f\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.const R 0 f U hu) 0","decl":"theorem const_zero (f : R) (U hu) : const R 0 f U hu = 0 :=\n  Subtype.eq <| funext fun x => IsLocalization.mk'_eq_iff_eq_mul.2 <| by\n    rw [RingHom.map_zero]\n    exact (mul_eq_zero_of_left rfl ((algebraMap R (Localizations R x)) _)).symm\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_self","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl f\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.const R f f U hu) 1","decl":"theorem const_self (f : R) (U hu) : const R f f U hu = 1 :=\n  Subtype.eq <| funext fun _ => IsLocalization.mk'_self _ _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_one","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.const R 1 1 U ‚ãØ) 1","decl":"theorem const_one (U) : (const R 1 1 U fun _ _ => Submonoid.one_mem _) = 1 :=\n  const_self R 1 U _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_add","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu‚ÇÅ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÅ\nhu‚ÇÇ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÇ\n‚ä¢ Eq (HAdd.hAdd (AlgebraicGeometry.StructureSheaf.const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ) (AlgebraicGeometry.StructureSheaf.const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ)) (AlgebraicGeometry.StructureSheaf.const R (HAdd.hAdd (HMul.hMul f‚ÇÅ g‚ÇÇ) (HMul.hMul f‚ÇÇ g‚ÇÅ)) (HMul.hMul g‚ÇÅ g‚ÇÇ) U ‚ãØ)","decl":"theorem const_add (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) :\n    const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ + const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ =\n      const R (f‚ÇÅ * g‚ÇÇ + f‚ÇÇ * g‚ÇÅ) (g‚ÇÅ * g‚ÇÇ) U fun x hx =>\n        Submonoid.mul_mem _ (hu‚ÇÅ x hx) (hu‚ÇÇ x hx) :=\n  Subtype.eq <| funext fun x => Eq.symm <| IsLocalization.mk'_add _ _\n    ‚ü®g‚ÇÅ, hu‚ÇÅ x x.2‚ü© ‚ü®g‚ÇÇ, hu‚ÇÇ x x.2‚ü©\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_mul","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu‚ÇÅ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÅ\nhu‚ÇÇ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÇ\n‚ä¢ Eq (HMul.hMul (AlgebraicGeometry.StructureSheaf.const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ) (AlgebraicGeometry.StructureSheaf.const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ)) (AlgebraicGeometry.StructureSheaf.const R (HMul.hMul f‚ÇÅ f‚ÇÇ) (HMul.hMul g‚ÇÅ g‚ÇÇ) U ‚ãØ)","decl":"theorem const_mul (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) :\n    const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ * const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ =\n      const R (f‚ÇÅ * f‚ÇÇ) (g‚ÇÅ * g‚ÇÇ) U fun x hx => Submonoid.mul_mem _ (hu‚ÇÅ x hx) (hu‚ÇÇ x hx) :=\n  Subtype.eq <|\n    funext fun x =>\n      Eq.symm <| IsLocalization.mk'_mul _ f‚ÇÅ f‚ÇÇ ‚ü®g‚ÇÅ, hu‚ÇÅ x x.2‚ü© ‚ü®g‚ÇÇ, hu‚ÇÇ x x.2‚ü©\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_ext","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu‚ÇÅ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÅ\nhu‚ÇÇ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÇ\nh : Eq (HMul.hMul f‚ÇÅ g‚ÇÇ) (HMul.hMul f‚ÇÇ g‚ÇÅ)\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ) (AlgebraicGeometry.StructureSheaf.const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ)","decl":"theorem const_ext {f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R} {U hu‚ÇÅ hu‚ÇÇ} (h : f‚ÇÅ * g‚ÇÇ = f‚ÇÇ * g‚ÇÅ) :\n    const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ = const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ :=\n  Subtype.eq <|\n    funext fun x =>\n      IsLocalization.mk'_eq_of_eq (by rw [mul_comm, Subtype.coe_mk, ‚Üê h, mul_comm, Subtype.coe_mk])\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_congr","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÅ\nhf : Eq f‚ÇÅ f‚ÇÇ\nhg : Eq g‚ÇÅ g‚ÇÇ\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.const R f‚ÇÅ g‚ÇÅ U hu) (AlgebraicGeometry.StructureSheaf.const R f‚ÇÇ g‚ÇÇ U ‚ãØ)","decl":"theorem const_congr {f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R} {U hu} (hf : f‚ÇÅ = f‚ÇÇ) (hg : g‚ÇÅ = g‚ÇÇ) :\n    const R f‚ÇÅ g‚ÇÅ U hu = const R f‚ÇÇ g‚ÇÇ U (hg ‚ñ∏ hu) := by substs hf hg; rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_mul_rev","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf g : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu‚ÇÅ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g\nhu‚ÇÇ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl f\n‚ä¢ Eq (HMul.hMul (AlgebraicGeometry.StructureSheaf.const R f g U hu‚ÇÅ) (AlgebraicGeometry.StructureSheaf.const R g f U hu‚ÇÇ)) 1","decl":"theorem const_mul_rev (f g : R) (U hu‚ÇÅ hu‚ÇÇ) : const R f g U hu‚ÇÅ * const R g f U hu‚ÇÇ = 1 := by\n  rw [const_mul, const_congr R rfl (mul_comm g f), const_self]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_mul_cancel","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf g‚ÇÅ g‚ÇÇ : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu‚ÇÅ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÅ\nhu‚ÇÇ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÇ\n‚ä¢ Eq (HMul.hMul (AlgebraicGeometry.StructureSheaf.const R f g‚ÇÅ U hu‚ÇÅ) (AlgebraicGeometry.StructureSheaf.const R g‚ÇÅ g‚ÇÇ U hu‚ÇÇ)) (AlgebraicGeometry.StructureSheaf.const R f g‚ÇÇ U hu‚ÇÇ)","decl":"theorem const_mul_cancel (f g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) :\n    const R f g‚ÇÅ U hu‚ÇÅ * const R g‚ÇÅ g‚ÇÇ U hu‚ÇÇ = const R f g‚ÇÇ U hu‚ÇÇ := by\n  rw [const_mul, const_ext]; rw [mul_assoc]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.const_mul_cancel'","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf g‚ÇÅ g‚ÇÇ : R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhu‚ÇÅ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÅ\nhu‚ÇÇ : ‚àÄ (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl g‚ÇÇ\n‚ä¢ Eq (HMul.hMul (AlgebraicGeometry.StructureSheaf.const R g‚ÇÅ g‚ÇÇ U hu‚ÇÇ) (AlgebraicGeometry.StructureSheaf.const R f g‚ÇÅ U hu‚ÇÅ)) (AlgebraicGeometry.StructureSheaf.const R f g‚ÇÇ U hu‚ÇÇ)","decl":"theorem const_mul_cancel' (f g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) :\n    const R g‚ÇÅ g‚ÇÇ U hu‚ÇÇ * const R f g‚ÇÅ U hu‚ÇÅ = const R f g‚ÇÇ U hu‚ÇÇ := by\n  rw [mul_comm, const_mul_cancel]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toOpen_res","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU V : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\ni : Quiver.Hom V U\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen R U) ((AlgebraicGeometry.Spec.structureSheaf R).val.map i.op)) (AlgebraicGeometry.StructureSheaf.toOpen R V)","decl":"@[simp]\ntheorem toOpen_res (U V : Opens (PrimeSpectrum.Top R)) (i : V ‚ü∂ U) :\n    toOpen R U ‚â´ (structureSheaf R).1.map i.op = toOpen R V :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toOpen_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nf : R\nx : Subtype fun x => Membership.mem U x\n‚ä¢ Eq (‚Üë((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toOpen R U)) f) x) ((algebraMap R (AlgebraicGeometry.StructureSheaf.Localizations R ‚Üëx)) f)","decl":"@[simp]\ntheorem toOpen_apply (U : Opens (PrimeSpectrum.Top R)) (f : R) (x : U) :\n    (toOpen R U f).1 x = algebraMap _ _ f :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toOpen_eq_const","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nf : R\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toOpen R U)) f) (AlgebraicGeometry.StructureSheaf.const R f 1 U ‚ãØ)","decl":"theorem toOpen_eq_const (U : Opens (PrimeSpectrum.Top R)) (f : R) :\n    toOpen R U f = const R f 1 U fun x _ => (Ideal.ne_top_iff_one _).1 x.2.1 :=\n  Subtype.eq <| funext fun _ => Eq.symm <| IsLocalization.mk'_one _ f\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toOpen_germ","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhx : Membership.mem U x\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen R U) ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.germ U x hx)) (AlgebraicGeometry.StructureSheaf.toStalk R x)","decl":"@[simp]\ntheorem toOpen_germ (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R) (hx : x ‚àà U) :\n    toOpen R U ‚â´ (structureSheaf R).presheaf.germ U x hx = toStalk R x := by\n  rw [‚Üê toOpen_res R ‚ä§ U (homOfLE le_top : U ‚ü∂ ‚ä§), Category.assoc, Presheaf.germ_res]; rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.germ_toOpen","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhx : Membership.mem U x\nf : R\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.germ U x hx)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toOpen R U)) f)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toStalk R x)) f)","decl":"@[simp]\ntheorem germ_toOpen\n    (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R) (hx : x ‚àà U) (f : R) :\n    (structureSheaf R).presheaf.germ U x hx (toOpen R U f) = toStalk R x f := by\n  rw [‚Üê toOpen_germ]; rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toOpen_Œìgerm_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nf : R\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.Œìgerm x)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toOpen R Top.top)) f)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toStalk R x)) f)","decl":"theorem toOpen_Œìgerm_apply (x : PrimeSpectrum.Top R) (f : R) :\n    (structureSheaf R).presheaf.Œìgerm x (toOpen R ‚ä§ f) = toStalk R x f :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.isUnit_to_basicOpen_self","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf : R\n‚ä¢ IsUnit ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toOpen R (PrimeSpectrum.basicOpen f))) f)","decl":"theorem isUnit_to_basicOpen_self (f : R) : IsUnit (toOpen R (PrimeSpectrum.basicOpen f) f) :=\n  isUnit_of_mul_eq_one _ (const R 1 f (PrimeSpectrum.basicOpen f) fun _ => id) <| by\n    rw [toOpen_eq_const, const_mul_rev]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.isUnit_toStalk","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nf : Subtype fun x_1 => Membership.mem x.asIdeal.primeCompl x_1\n‚ä¢ IsUnit ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toStalk R x)) ‚Üëf)","decl":"theorem isUnit_toStalk (x : PrimeSpectrum.Top R) (f : x.asIdeal.primeCompl) :\n    IsUnit (toStalk R x (f : R)) := by\n  rw [‚Üê germ_toOpen R (PrimeSpectrum.basicOpen (f : R)) x f.2 (f : R)]\n  exact RingHom.isUnit_map _ (isUnit_to_basicOpen_self R f)\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.localizationToStalk_of","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nf : R\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.localizationToStalk R x)) ((algebraMap R (Localization x.asIdeal.primeCompl)) f)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toStalk R x)) f)","decl":"@[simp]\ntheorem localizationToStalk_of (x : PrimeSpectrum.Top R) (f : R) :\n    localizationToStalk R x (algebraMap _ (Localization _) f) = toStalk R x f :=\n  IsLocalization.lift_eq (S := Localization x.asIdeal.primeCompl) _ f\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.localizationToStalk_mk'","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nf : R\ns : Subtype fun x_1 => Membership.mem x.asIdeal.primeCompl x_1\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.localizationToStalk R x)) (IsLocalization.mk' (Localization.AtPrime x.asIdeal) f s)) ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.germ (PrimeSpectrum.basicOpen ‚Üës) x ‚ãØ)) (AlgebraicGeometry.StructureSheaf.const R f (‚Üës) (PrimeSpectrum.basicOpen ‚Üës) ‚ãØ))","decl":"@[simp]\ntheorem localizationToStalk_mk' (x : PrimeSpectrum.Top R) (f : R) (s : x.asIdeal.primeCompl) :\n    localizationToStalk R x (IsLocalization.mk' (Localization.AtPrime x.asIdeal) f s) =\n      (structureSheaf R).presheaf.germ (PrimeSpectrum.basicOpen (s : R)) x s.2\n        (const R f s (PrimeSpectrum.basicOpen s) fun _ => id) :=\n  (IsLocalization.lift_mk'_spec (S := Localization.AtPrime x.asIdeal) _ _ _ _).2 <| by\n    rw [‚Üê germ_toOpen R (PrimeSpectrum.basicOpen s) x s.2,\n      ‚Üê germ_toOpen R (PrimeSpectrum.basicOpen s) x s.2, ‚Üê RingHom.map_mul, toOpen_eq_const,\n      toOpen_eq_const, const_mul_cancel']\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.coe_openToLocalization","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhx : Membership.mem U x\n‚ä¢ Eq ‚áë(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.openToLocalization R U x hx)) fun s => ‚Üës ‚ü®x, hx‚ü©","decl":"@[simp]\ntheorem coe_openToLocalization (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R)\n    (hx : x ‚àà U) :\n    (openToLocalization R U x hx :\n        (structureSheaf R).1.obj (op U) ‚Üí Localization.AtPrime x.asIdeal) =\n      fun s => s.1 ‚ü®x, hx‚ü© :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.openToLocalization_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhx : Membership.mem U x\ns : ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj { unop := U })\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.openToLocalization R U x hx)) s) (‚Üës ‚ü®x, hx‚ü©)","decl":"theorem openToLocalization_apply (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R)\n    (hx : x ‚àà U) (s : (structureSheaf R).1.obj (op U)) :\n    openToLocalization R U x hx s = s.1 ‚ü®x, hx‚ü© :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.germ_comp_stalkToFiberRingHom","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhx : Membership.mem U x\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.germ U x hx) (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x)) (AlgebraicGeometry.StructureSheaf.openToLocalization R U x hx)","decl":"@[simp]\ntheorem germ_comp_stalkToFiberRingHom\n    (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R) (hx : x ‚àà U) :\n    (structureSheaf R).presheaf.germ U x hx ‚â´ stalkToFiberRingHom R x =\n      openToLocalization R U x hx :=\n  Limits.colimit.Œπ_desc _ _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_germ","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhx : Membership.mem U x\ns : ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj { unop := U })\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x)) ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.germ U x hx)) s)) (‚Üës ‚ü®x, hx‚ü©)","decl":"@[simp]\ntheorem stalkToFiberRingHom_germ (U : Opens (PrimeSpectrum.Top R))\n    (x : PrimeSpectrum.Top R) (hx : x ‚àà U) (s : (structureSheaf R).1.obj (op U)) :\n    stalkToFiberRingHom R x ((structureSheaf R).presheaf.germ U x hx s) = s.1 ‚ü®x, hx‚ü© :=\n  RingHom.ext_iff.mp (CommRingCat.hom_ext_iff.mp (germ_comp_stalkToFiberRingHom R U x hx)) s\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toStalk_comp_stalkToFiberRingHom","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk R x) (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x)) (CommRingCat.ofHom (algebraMap R (Localization.AtPrime x.asIdeal)))","decl":"@[simp]\ntheorem toStalk_comp_stalkToFiberRingHom (x : PrimeSpectrum.Top R) :\n    toStalk R x ‚â´ stalkToFiberRingHom R x = CommRingCat.ofHom (algebraMap _ _) := by\n  rw [toStalk, Category.assoc, germ_comp_stalkToFiberRingHom]; rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_toStalk","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nf : R\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toStalk R x)) f)) ((algebraMap R ‚Üë(CommRingCat.of (Localization.AtPrime x.asIdeal))) f)","decl":"@[simp]\ntheorem stalkToFiberRingHom_toStalk (x : PrimeSpectrum.Top R) (f : R) :\n    stalkToFiberRingHom R x (toStalk R x f) = algebraMap _ _ f :=\n  RingHom.ext_iff.1 (CommRingCat.hom_ext_iff.mp (toStalk_comp_stalkToFiberRingHom R x)) _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkIso_hom","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.stalkIso R x).hom (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x)","decl":"/-- The ring isomorphism between the stalk of the structure sheaf of `R` at a point `p`\ncorresponding to a prime ideal in `R` and the localization of `R` at `p`. -/\n@[simps]\ndef stalkIso (x : PrimeSpectrum.Top R) :\n    (structureSheaf R).presheaf.stalk x ‚âÖ CommRingCat.of (Localization.AtPrime x.asIdeal) where\n  hom := stalkToFiberRingHom R x\n  inv := localizationToStalk R x\n  hom_inv_id := by\n    apply stalk_hom_ext\n    intro U hxU\n    ext s\n    dsimp only [CommRingCat.hom_comp, RingHom.coe_comp, Function.comp_apply, CommRingCat.hom_id,\n      RingHom.coe_id, id_eq]\n    rw [stalkToFiberRingHom_germ]\n    obtain ‚ü®V, hxV, iVU, f, g, (hg : V ‚â§ PrimeSpectrum.basicOpen _), hs‚ü© :=\n      exists_const _ _ s x hxU\n    rw [‚Üê res_apply R U V iVU s ‚ü®x, hxV‚ü©, ‚Üê hs, const_apply, localizationToStalk_mk']\n    refine (structureSheaf R).presheaf.germ_ext V hxV (homOfLE hg) iVU ?_\n    -- Replace the `HasForget.instFunLike` instance with `CommRingCat.hom`:\n    show (structureSheaf R).presheaf.map (homOfLE hg).op _ =\n      (structureSheaf R).presheaf.map iVU.op s\n    rw [‚Üê hs, res_const']\n  inv_hom_id := CommRingCat.hom_ext <|\n    @IsLocalization.ringHom_ext R _ x.asIdeal.primeCompl (Localization.AtPrime x.asIdeal) _ _\n      (Localization.AtPrime x.asIdeal) _ _\n      (RingHom.comp (stalkToFiberRingHom R x).hom (localizationToStalk R x).hom)\n      (RingHom.id (Localization.AtPrime _)) <| by\n        ext f\n        rw [RingHom.comp_apply, RingHom.comp_apply, localizationToStalk_of,\n          stalkToFiberRingHom_toStalk, RingHom.comp_apply, RingHom.id_apply]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkIso_inv","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.stalkIso R x).inv (AlgebraicGeometry.StructureSheaf.localizationToStalk R x)","decl":"/-- The ring isomorphism between the stalk of the structure sheaf of `R` at a point `p`\ncorresponding to a prime ideal in `R` and the localization of `R` at `p`. -/\n@[simps]\ndef stalkIso (x : PrimeSpectrum.Top R) :\n    (structureSheaf R).presheaf.stalk x ‚âÖ CommRingCat.of (Localization.AtPrime x.asIdeal) where\n  hom := stalkToFiberRingHom R x\n  inv := localizationToStalk R x\n  hom_inv_id := by\n    apply stalk_hom_ext\n    intro U hxU\n    ext s\n    dsimp only [CommRingCat.hom_comp, RingHom.coe_comp, Function.comp_apply, CommRingCat.hom_id,\n      RingHom.coe_id, id_eq]\n    rw [stalkToFiberRingHom_germ]\n    obtain ‚ü®V, hxV, iVU, f, g, (hg : V ‚â§ PrimeSpectrum.basicOpen _), hs‚ü© :=\n      exists_const _ _ s x hxU\n    rw [‚Üê res_apply R U V iVU s ‚ü®x, hxV‚ü©, ‚Üê hs, const_apply, localizationToStalk_mk']\n    refine (structureSheaf R).presheaf.germ_ext V hxV (homOfLE hg) iVU ?_\n    -- Replace the `HasForget.instFunLike` instance with `CommRingCat.hom`:\n    show (structureSheaf R).presheaf.map (homOfLE hg).op _ =\n      (structureSheaf R).presheaf.map iVU.op s\n    rw [‚Üê hs, res_const']\n  inv_hom_id := CommRingCat.hom_ext <|\n    @IsLocalization.ringHom_ext R _ x.asIdeal.primeCompl (Localization.AtPrime x.asIdeal) _ _\n      (Localization.AtPrime x.asIdeal) _ _\n      (RingHom.comp (stalkToFiberRingHom R x).hom (localizationToStalk R x).hom)\n      (RingHom.id (Localization.AtPrime _)) <| by\n        ext f\n        rw [RingHom.comp_apply, RingHom.comp_apply, localizationToStalk_of,\n          stalkToFiberRingHom_toStalk, RingHom.comp_apply, RingHom.id_apply]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.instIsIsoCommRingCatStalkToFiberRingHom","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : PrimeSpectrum R\n‚ä¢ CategoryTheory.IsIso (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x)","decl":"instance (x : PrimeSpectrum R) : IsIso (stalkToFiberRingHom R x) :=\n  (stalkIso R x).isIso_hom\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.instIsLocalHomCarrierStalkCommRingCatPresheafStructureSheafOfAtPrimeAsIdealRingHomHomStalkToFiberRingHom","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : PrimeSpectrum R\n‚ä¢ IsLocalHom (CommRingCat.Hom.hom (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x))","decl":"instance (x : PrimeSpectrum R) : IsLocalHom (stalkToFiberRingHom R x).hom :=\n  isLocalHom_of_isIso _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.instIsIsoCommRingCatLocalizationToStalk","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : PrimeSpectrum R\n‚ä¢ CategoryTheory.IsIso (AlgebraicGeometry.StructureSheaf.localizationToStalk R x)","decl":"instance (x : PrimeSpectrum R) : IsIso (localizationToStalk R x) :=\n  (stalkIso R x).isIso_inv\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.instIsLocalHomCarrierOfAtPrimeAsIdealStalkCommRingCatPresheafStructureSheafRingHomHomLocalizationToStalk","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : PrimeSpectrum R\n‚ä¢ IsLocalHom (CommRingCat.Hom.hom (AlgebraicGeometry.StructureSheaf.localizationToStalk R x))","decl":"instance (x : PrimeSpectrum R) : IsLocalHom (localizationToStalk R x).hom :=\n  isLocalHom_of_isIso _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_localizationToStalk_assoc","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nZ : CommRingCat\nh : Quiver.Hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.localizationToStalk R x) h)) h","decl":"@[simp, reassoc]\ntheorem stalkToFiberRingHom_localizationToStalk (x : PrimeSpectrum.Top R) :\n    stalkToFiberRingHom R x ‚â´ localizationToStalk R x = ùüô _ :=\n  (stalkIso R x).hom_inv_id\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_localizationToStalk","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x) (AlgebraicGeometry.StructureSheaf.localizationToStalk R x)) (CategoryTheory.CategoryStruct.id ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalk x))","decl":"@[simp, reassoc]\ntheorem stalkToFiberRingHom_localizationToStalk (x : PrimeSpectrum.Top R) :\n    stalkToFiberRingHom R x ‚â´ localizationToStalk R x = ùüô _ :=\n  (stalkIso R x).hom_inv_id\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.localizationToStalk_stalkToFiberRingHom","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.localizationToStalk R x) (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x)) (CategoryTheory.CategoryStruct.id (CommRingCat.of (Localization.AtPrime x.asIdeal)))","decl":"@[simp, reassoc]\ntheorem localizationToStalk_stalkToFiberRingHom (x : PrimeSpectrum.Top R) :\n    localizationToStalk R x ‚â´ stalkToFiberRingHom R x = ùüô _ :=\n  (stalkIso R x).inv_hom_id\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.localizationToStalk_stalkToFiberRingHom_assoc","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nZ : CommRingCat\nh : Quiver.Hom (CommRingCat.of (Localization.AtPrime x.asIdeal)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.localizationToStalk R x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x) h)) h","decl":"@[simp, reassoc]\ntheorem localizationToStalk_stalkToFiberRingHom (x : PrimeSpectrum.Top R) :\n    localizationToStalk R x ‚â´ stalkToFiberRingHom R x = ùüô _ :=\n  (stalkIso R x).inv_hom_id\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toBasicOpen_mk'","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\ns f : R\ng : Subtype fun x => Membership.mem (Submonoid.powers s) x\n‚ä¢ Eq ((AlgebraicGeometry.StructureSheaf.toBasicOpen R s) (IsLocalization.mk' (Localization.Away s) f g)) (AlgebraicGeometry.StructureSheaf.const R f (‚Üëg) (PrimeSpectrum.basicOpen s) ‚ãØ)","decl":"@[simp]\ntheorem toBasicOpen_mk' (s f : R) (g : Submonoid.powers s) :\n    toBasicOpen R s (IsLocalization.mk' (Localization.Away s) f g) =\n      const R f g (PrimeSpectrum.basicOpen s) fun _ hx => Submonoid.powers_le.2 hx g.2 :=\n  (IsLocalization.lift_mk'_spec _ _ _ _).2 <| by\n    rw [toOpen_eq_const, toOpen_eq_const, const_mul_cancel']\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.localization_toBasicOpen","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf : R\n‚ä¢ Eq ((AlgebraicGeometry.StructureSheaf.toBasicOpen R f).comp (algebraMap R (Localization.Away f))) (CommRingCat.Hom.hom (AlgebraicGeometry.StructureSheaf.toOpen R (PrimeSpectrum.basicOpen f)))","decl":"@[simp]\ntheorem localization_toBasicOpen (f : R) :\n    RingHom.comp (toBasicOpen R f) (algebraMap R (Localization.Away f)) =\n    (toOpen R (PrimeSpectrum.basicOpen f)).hom :=\n  RingHom.ext fun g => by\n    rw [toBasicOpen, IsLocalization.Away.lift, RingHom.comp_apply, IsLocalization.lift_eq]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toBasicOpen_to_map","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\ns f : R\n‚ä¢ Eq ((AlgebraicGeometry.StructureSheaf.toBasicOpen R s) ((algebraMap R (Localization.Away s)) f)) (AlgebraicGeometry.StructureSheaf.const R f 1 (PrimeSpectrum.basicOpen s) ‚ãØ)","decl":"@[simp]\ntheorem toBasicOpen_to_map (s f : R) :\n    toBasicOpen R s (algebraMap R (Localization.Away s) f) =\n      const R f 1 (PrimeSpectrum.basicOpen s) fun _ _ => Submonoid.one_mem _ :=\n  (IsLocalization.lift_eq _ _).trans <| toOpen_eq_const _ _ _\n\n-- The proof here follows the argument in Hartshorne's Algebraic Geometry, Proposition II.2.2.\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toBasicOpen_injective","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf : R\n‚ä¢ Function.Injective ‚áë(AlgebraicGeometry.StructureSheaf.toBasicOpen R f)","decl":"theorem toBasicOpen_injective (f : R) : Function.Injective (toBasicOpen R f) := by\n  intro s t h_eq\n  obtain ‚ü®a, ‚ü®b, hb‚ü©, rfl‚ü© := IsLocalization.mk'_surjective (Submonoid.powers f) s\n  obtain ‚ü®c, ‚ü®d, hd‚ü©, rfl‚ü© := IsLocalization.mk'_surjective (Submonoid.powers f) t\n  simp only [toBasicOpen_mk'] at h_eq\n  rw [IsLocalization.eq]\n  -- We know that the fractions `a/b` and `c/d` are equal as sections of the structure sheaf on\n  -- `basicOpen f`. We need to show that they agree as elements in the localization of `R` at `f`.\n  -- This amounts showing that `r * (d * a) = r * (b * c)`, for some power `r = f ^ n` of `f`.\n  -- We define `I` as the ideal of *all* elements `r` satisfying the above equation.\n  let I : Ideal R :=\n    { carrier := { r : R | r * (d * a) = r * (b * c) }\n      zero_mem' := by simp only [Set.mem_setOf_eq, zero_mul]\n      add_mem' := fun {r‚ÇÅ r‚ÇÇ} hr‚ÇÅ hr‚ÇÇ => by dsimp at hr‚ÇÅ hr‚ÇÇ ‚ä¢; simp only [add_mul, hr‚ÇÅ, hr‚ÇÇ]\n      smul_mem' := fun {r‚ÇÅ r‚ÇÇ} hr‚ÇÇ => by dsimp at hr‚ÇÇ ‚ä¢; simp only [mul_assoc, hr‚ÇÇ] }\n  -- Our claim now reduces to showing that `f` is contained in the radical of `I`\n  suffices f ‚àà I.radical by\n    cases' this with n hn\n    exact ‚ü®‚ü®f ^ n, n, rfl‚ü©, hn‚ü©\n  rw [‚Üê PrimeSpectrum.vanishingIdeal_zeroLocus_eq_radical, PrimeSpectrum.mem_vanishingIdeal]\n  intro p hfp\n  contrapose hfp\n  rw [PrimeSpectrum.mem_zeroLocus, Set.not_subset]\n  have := congr_fun (congr_arg Subtype.val h_eq) ‚ü®p, hfp‚ü©\n  dsimp at this\n  rw [IsLocalization.eq (S := Localization.AtPrime p.asIdeal)] at this\n  cases' this with r hr\n  exact ‚ü®r.1, hr, r.2‚ü©\n\n/-\nAuxiliary lemma for surjectivity of `toBasicOpen`.\nEvery section can locally be represented on basic opens `basicOpen g` as a fraction `f/g`\n-/\n"}
{"name":"AlgebraicGeometry.StructureSheaf.locally_const_basicOpen","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\ns : ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj { unop := U })\nx : Subtype fun x => Membership.mem U x\n‚ä¢ Exists fun f => Exists fun g => Exists fun i => And (Membership.mem (PrimeSpectrum.basicOpen g) ‚Üëx) (Eq (AlgebraicGeometry.StructureSheaf.const R f g (PrimeSpectrum.basicOpen g) ‚ãØ) ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).val.map i.op)) s))","decl":"theorem locally_const_basicOpen (U : Opens (PrimeSpectrum.Top R))\n    (s : (structureSheaf R).1.obj (op U)) (x : U) :\n    ‚àÉ (f g : R) (i : PrimeSpectrum.basicOpen g ‚ü∂ U), x.1 ‚àà PrimeSpectrum.basicOpen g ‚àß\n      (const R f g (PrimeSpectrum.basicOpen g) fun _ hy => hy) =\n      (structureSheaf R).1.map i.op s := by\n  -- First, any section `s` can be represented as a fraction `f/g` on some open neighborhood of `x`\n  -- and we may pass to a `basicOpen h`, since these form a basis\n  obtain ‚ü®V, hxV : x.1 ‚àà V.1, iVU, f, g, hVDg : V ‚â§ PrimeSpectrum.basicOpen g, s_eq‚ü© :=\n    exists_const R U s x.1 x.2\n  obtain ‚ü®_, ‚ü®h, rfl‚ü©, hxDh, hDhV : PrimeSpectrum.basicOpen h ‚â§ V‚ü© :=\n    PrimeSpectrum.isTopologicalBasis_basic_opens.exists_subset_of_mem_open hxV V.2\n  -- The problem is of course, that `g` and `h` don't need to coincide.\n  -- But, since `basicOpen h ‚â§ basicOpen g`, some power of `h` must be a multiple of `g`\n  cases' (PrimeSpectrum.basicOpen_le_basicOpen_iff h g).mp (Set.Subset.trans hDhV hVDg) with n hn\n  -- Actually, we will need a *nonzero* power of `h`.\n  -- This is because we will need the equality `basicOpen (h ^ n) = basicOpen h`, which only\n  -- holds for a nonzero power `n`. We therefore artificially increase `n` by one.\n  replace hn := Ideal.mul_mem_right h (Ideal.span {g}) hn\n  rw [‚Üê pow_succ, Ideal.mem_span_singleton'] at hn\n  cases' hn with c hc\n  have basic_opens_eq := PrimeSpectrum.basicOpen_pow h (n + 1) (by omega)\n  have i_basic_open := eqToHom basic_opens_eq ‚â´ homOfLE hDhV\n  -- We claim that `(f * c) / h ^ (n+1)` is our desired representation\n  use f * c, h ^ (n + 1), i_basic_open ‚â´ iVU, (basic_opens_eq.symm.le :) hxDh\n  rw [op_comp, Functor.map_comp] --, comp_apply, ‚Üê s_eq, res_const]\n  -- Porting note: `comp_apply` can't be rewritten, so use a change\n  change const R _ _ _ _ = (structureSheaf R).1.map i_basic_open.op\n    ((structureSheaf R).1.map iVU.op s)\n  rw [‚Üê s_eq, res_const]\n  -- Note that the last rewrite here generated an additional goal, which was a parameter\n  -- of `res_const`. We prove this goal first\n  swap\n  ¬∑ intro y hy\n    rw [basic_opens_eq] at hy\n    exact (Set.Subset.trans hDhV hVDg :) hy\n  -- All that is left is a simple calculation\n  apply const_ext\n  rw [mul_assoc f c g, hc]\n\n/-\nAuxiliary lemma for surjectivity of `toBasicOpen`.\nA local representation of a section `s` as fractions `a i / h i` on finitely many basic opens\n`basicOpen (h i)` can be \"normalized\" in such a way that `a i * h j = h i * a j` for all `i, j`\n-/\n"}
{"name":"AlgebraicGeometry.StructureSheaf.normalize_finite_fraction_representation","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\ns : ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj { unop := U })\nŒπ : Type u_1\nt : Finset Œπ\na h : Œπ ‚Üí R\niDh : (i : Œπ) ‚Üí Quiver.Hom (PrimeSpectrum.basicOpen (h i)) U\nh_cover : LE.le U (iSup fun i => iSup fun h_1 => PrimeSpectrum.basicOpen (h i))\nhs : ‚àÄ (i : Œπ), Eq (AlgebraicGeometry.StructureSheaf.const R (a i) (h i) (PrimeSpectrum.basicOpen (h i)) ‚ãØ) ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).val.map (iDh i).op)) s)\n‚ä¢ Exists fun a' => Exists fun h' => Exists fun iDh' => And (LE.le U (iSup fun i => iSup fun h => PrimeSpectrum.basicOpen (h' i))) (And (‚àÄ (i : Œπ), Membership.mem t i ‚Üí ‚àÄ (j : Œπ), Membership.mem t j ‚Üí Eq (HMul.hMul (a' i) (h' j)) (HMul.hMul (h' i) (a' j))) (‚àÄ (i : Œπ), Membership.mem t i ‚Üí Eq ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).val.map (iDh' i).op)) s) (AlgebraicGeometry.StructureSheaf.const R (a' i) (h' i) (PrimeSpectrum.basicOpen (h' i)) ‚ãØ)))","decl":"theorem normalize_finite_fraction_representation (U : Opens (PrimeSpectrum.Top R))\n    (s : (structureSheaf R).1.obj (op U)) {Œπ : Type*} (t : Finset Œπ) (a h : Œπ ‚Üí R)\n    (iDh : ‚àÄ i : Œπ, PrimeSpectrum.basicOpen (h i) ‚ü∂ U)\n    (h_cover : U ‚â§ ‚®Ü i ‚àà t, PrimeSpectrum.basicOpen (h i))\n    (hs :\n      ‚àÄ i : Œπ,\n        (const R (a i) (h i) (PrimeSpectrum.basicOpen (h i)) fun _ hy => hy) =\n          (structureSheaf R).1.map (iDh i).op s) :\n    ‚àÉ (a' h' : Œπ ‚Üí R) (iDh' : ‚àÄ i : Œπ, PrimeSpectrum.basicOpen (h' i) ‚ü∂ U),\n      (U ‚â§ ‚®Ü i ‚àà t, PrimeSpectrum.basicOpen (h' i)) ‚àß\n        (‚àÄ (i) (_ : i ‚àà t) (j) (_ : j ‚àà t), a' i * h' j = h' i * a' j) ‚àß\n          ‚àÄ i ‚àà t,\n            (structureSheaf R).1.map (iDh' i).op s =\n              const R (a' i) (h' i) (PrimeSpectrum.basicOpen (h' i)) fun _ hy => hy := by\n  -- First we show that the fractions `(a i * h j) / (h i * h j)` and `(h i * a j) / (h i * h j)`\n  -- coincide in the localization of `R` at `h i * h j`\n  have fractions_eq :\n    ‚àÄ i j : Œπ,\n      IsLocalization.mk' (Localization.Away (h i * h j))\n        (a i * h j) ‚ü®h i * h j, Submonoid.mem_powers _‚ü© =\n      IsLocalization.mk' _ (h i * a j) ‚ü®h i * h j, Submonoid.mem_powers _‚ü© := by\n    intro i j\n    let D := PrimeSpectrum.basicOpen (h i * h j)\n    let iDi : D ‚ü∂ PrimeSpectrum.basicOpen (h i) := homOfLE (PrimeSpectrum.basicOpen_mul_le_left _ _)\n    let iDj : D ‚ü∂ PrimeSpectrum.basicOpen (h j) :=\n      homOfLE (PrimeSpectrum.basicOpen_mul_le_right _ _)\n    -- Crucially, we need injectivity of `toBasicOpen`\n    apply toBasicOpen_injective R (h i * h j)\n    rw [toBasicOpen_mk', toBasicOpen_mk']\n    simp only []\n    -- Here, both sides of the equation are equal to a restriction of `s`\n    trans\n    on_goal 1 =>\n      convert congr_arg ((structureSheaf R).1.map iDj.op) (hs j).symm using 1\n      convert congr_arg ((structureSheaf R).1.map iDi.op) (hs i) using 1\n    all_goals rw [res_const]; apply const_ext; ring\n    -- The remaining two goals were generated during the rewrite of `res_const`\n    -- These can be solved immediately\n    exacts [PrimeSpectrum.basicOpen_mul_le_left _ _, PrimeSpectrum.basicOpen_mul_le_right _ _]\n  -- From the equality in the localization, we obtain for each `(i,j)` some power `(h i * h j) ^ n`\n  -- which equalizes `a i * h j` and `h i * a j`\n  have exists_power :\n    ‚àÄ i j : Œπ, ‚àÉ n : ‚Ñï, a i * h j * (h i * h j) ^ n = h i * a j * (h i * h j) ^ n := by\n    intro i j\n    obtain ‚ü®‚ü®c, n, rfl‚ü©, hc‚ü© := IsLocalization.eq.mp (fractions_eq i j)\n    use n + 1\n    rw [pow_succ]\n    dsimp at hc\n    convert hc using 1 <;> ring\n  let n := fun p : Œπ √ó Œπ => (exists_power p.1 p.2).choose\n  have n_spec := fun p : Œπ √ó Œπ => (exists_power p.fst p.snd).choose_spec\n  -- We need one power `(h i * h j) ^ N` that works for *all* pairs `(i,j)`\n  -- Since there are only finitely many indices involved, we can pick the supremum.\n  let N := (t √óÀ¢ t).sup n\n  have basic_opens_eq : ‚àÄ i : Œπ, PrimeSpectrum.basicOpen (h i ^ (N + 1)) =\n    PrimeSpectrum.basicOpen (h i) := fun i => PrimeSpectrum.basicOpen_pow _ _ (by omega)\n  -- Expanding the fraction `a i / h i` by the power `(h i) ^ n` gives the desired normalization\n  refine\n    ‚ü®fun i => a i * h i ^ N, fun i => h i ^ (N + 1), fun i => eqToHom (basic_opens_eq i) ‚â´ iDh i,\n      ?_, ?_, ?_‚ü©\n  ¬∑ simpa only [basic_opens_eq] using h_cover\n  ¬∑ intro i hi j hj\n    -- Here we need to show that our new fractions `a i / h i` satisfy the normalization condition\n    -- Of course, the power `N` we used to expand the fractions might be bigger than the power\n    -- `n (i, j)` which was originally chosen. We denote their difference by `k`\n    have n_le_N : n (i, j) ‚â§ N := Finset.le_sup (Finset.mem_product.mpr ‚ü®hi, hj‚ü©)\n    cases' Nat.le.dest n_le_N with k hk\n    simp only [‚Üê hk, pow_add, pow_one]\n    -- To accommodate for the difference `k`, we multiply both sides of the equation `n_spec (i, j)`\n    -- by `(h i * h j) ^ k`\n    convert congr_arg (fun z => z * (h i * h j) ^ k) (n_spec (i, j)) using 1 <;>\n      ¬∑ simp only [n, mul_pow]; ring\n  -- Lastly, we need to show that the new fractions still represent our original `s`\n  intro i _\n  rw [op_comp, Functor.map_comp]\n  -- Porting note: `comp_apply` can't be rewritten, so use a change\n  change (structureSheaf R).1.map (eqToHom (basic_opens_eq _)).op\n    ((structureSheaf R).1.map (iDh i).op s) = _\n  rw [‚Üê hs, res_const]\n  -- additional goal spit out by `res_const`\n  swap\n  ¬∑ exact (basic_opens_eq i).le\n  apply const_ext\n  dsimp\n  rw [pow_succ]\n  ring\n\n-- Porting note: in the following proof there are two places where `‚ãÉ i, ‚ãÉ (hx : i ‚àà _), ... `\n-- though `hx` is not used in `...` part, it is still required to maintain the structure of\n-- the original proof in mathlib3.\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toBasicOpen_surjective","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf : R\n‚ä¢ Function.Surjective ‚áë(AlgebraicGeometry.StructureSheaf.toBasicOpen R f)","decl":"set_option linter.unusedVariables false in\n-- The proof here follows the argument in Hartshorne's Algebraic Geometry, Proposition II.2.2.\ntheorem toBasicOpen_surjective (f : R) : Function.Surjective (toBasicOpen R f) := by\n  intro s\n  -- In this proof, `basicOpen f` will play two distinct roles: Firstly, it is an open set in the\n  -- prime spectrum. Secondly, it is used as an indexing type for various families of objects\n  -- (open sets, ring elements, ...). In order to make the distinction clear, we introduce a type\n  -- alias `Œπ` that is used whenever we want think of it as an indexing type.\n  let Œπ : Type u := PrimeSpectrum.basicOpen f\n  -- First, we pick some cover of basic opens, on which we can represent `s` as a fraction\n  choose a' h' iDh' hxDh' s_eq' using locally_const_basicOpen R (PrimeSpectrum.basicOpen f) s\n  -- Since basic opens are compact, we can pass to a finite subcover\n  obtain ‚ü®t, ht_cover'‚ü© :=\n    (PrimeSpectrum.isCompact_basicOpen f).elim_finite_subcover\n      (fun i : Œπ => PrimeSpectrum.basicOpen (h' i)) (fun i => PrimeSpectrum.isOpen_basicOpen)\n      -- Here, we need to show that our basic opens actually form a cover of `basicOpen f`\n      fun x hx => by rw [Set.mem_iUnion]; exact ‚ü®‚ü®x, hx‚ü©, hxDh' ‚ü®x, hx‚ü©‚ü©\n  simp only [‚Üê Opens.coe_iSup, SetLike.coe_subset_coe] at ht_cover'\n  -- We use the normalization lemma from above to obtain the relation `a i * h j = h i * a j`\n  obtain ‚ü®a, h, iDh, ht_cover, ah_ha, s_eq‚ü© :=\n    normalize_finite_fraction_representation R (PrimeSpectrum.basicOpen f)\n      s t a' h' iDh' ht_cover' s_eq'\n  clear s_eq' iDh' hxDh' ht_cover' a' h'\n  -- Porting note: simp with `[‚Üê SetLike.coe_subset_coe, Opens.coe_iSup]` does not result in\n  -- desired form\n  rw [‚Üê SetLike.coe_subset_coe, Opens.coe_iSup] at ht_cover\n  replace ht_cover : (PrimeSpectrum.basicOpen f : Set <| PrimeSpectrum R) ‚äÜ\n      ‚ãÉ (i : Œπ) (x : i ‚àà t), (PrimeSpectrum.basicOpen (h i) : Set _) := by\n    convert ht_cover using 2\n    exact funext fun j => by rw [Opens.coe_iSup]\n  -- Next we show that some power of `f` is a linear combination of the `h i`\n  obtain ‚ü®n, hn‚ü© : f ‚àà (Ideal.span (h '' ‚Üët)).radical := by\n    rw [‚Üê PrimeSpectrum.vanishingIdeal_zeroLocus_eq_radical, PrimeSpectrum.zeroLocus_span]\n    -- Porting note: simp with `PrimeSpectrum.basicOpen_eq_zeroLocus_compl` does not work\n    replace ht_cover : (PrimeSpectrum.zeroLocus {f})·∂ú ‚äÜ\n        ‚ãÉ (i : Œπ) (x : i ‚àà t), (PrimeSpectrum.zeroLocus {h i})·∂ú := by\n      convert ht_cover\n      ¬∑ rw [PrimeSpectrum.basicOpen_eq_zeroLocus_compl]\n      ¬∑ simp only [Opens.iSup_mk, Opens.carrier_eq_coe, PrimeSpectrum.basicOpen_eq_zeroLocus_compl]\n    rw [Set.compl_subset_comm] at ht_cover\n    -- Why doesn't `simp_rw` do this?\n    simp_rw [Set.compl_iUnion, compl_compl, ‚Üê PrimeSpectrum.zeroLocus_iUnion,\n      ‚Üê Finset.set_biUnion_coe, ‚Üê Set.image_eq_iUnion] at ht_cover\n    apply PrimeSpectrum.vanishingIdeal_anti_mono ht_cover\n    exact PrimeSpectrum.subset_vanishingIdeal_zeroLocus {f} (Set.mem_singleton f)\n  replace hn := Ideal.mul_mem_right f _ hn\n  erw [‚Üê pow_succ, Finsupp.mem_span_image_iff_linearCombination] at hn\n  rcases hn with ‚ü®b, b_supp, hb‚ü©\n  rw [Finsupp.linearCombination_apply_of_mem_supported R b_supp] at hb\n  dsimp at hb\n  -- Finally, we have all the ingredients.\n  -- We claim that our preimage is given by `(‚àë (i : Œπ) ‚àà t, b i * a i) / f ^ (n+1)`\n  use\n    IsLocalization.mk' (Localization.Away f) (‚àë i ‚àà t, b i * a i)\n      (‚ü®f ^ (n + 1), n + 1, rfl‚ü© : Submonoid.powers _)\n  rw [toBasicOpen_mk']\n  -- Since the structure sheaf is a sheaf, we can show the desired equality locally.\n  -- Annoyingly, `Sheaf.eq_of_locally_eq'` requires an open cover indexed by a *type*, so we need to\n  -- coerce our finset `t` to a type first.\n  let tt := ((t : Set (PrimeSpectrum.basicOpen f)) : Type u)\n  apply\n    (structureSheaf R).eq_of_locally_eq' (fun i : tt => PrimeSpectrum.basicOpen (h i))\n      (PrimeSpectrum.basicOpen f) fun i : tt => iDh i\n  ¬∑ -- This feels a little redundant, since already have `ht_cover` as a hypothesis\n    -- Unfortunately, `ht_cover` uses a bounded union over the set `t`, while here we have the\n    -- Union indexed by the type `tt`, so we need some boilerplate to translate one to the other\n    intro x hx\n    erw [TopologicalSpace.Opens.mem_iSup]\n    have := ht_cover hx\n    rw [‚Üê Finset.set_biUnion_coe, Set.mem_iUnion‚ÇÇ] at this\n    rcases this with ‚ü®i, i_mem, x_mem‚ü©\n    exact ‚ü®‚ü®i, i_mem‚ü©, x_mem‚ü©\n  rintro ‚ü®i, hi‚ü©\n  dsimp\n  change (structureSheaf R).1.map (iDh i).op _ = (structureSheaf R).1.map (iDh i).op _\n  rw [s_eq i hi, res_const]\n  -- Again, `res_const` spits out an additional goal\n  swap\n  ¬∑ intro y hy\n    change y ‚àà PrimeSpectrum.basicOpen (f ^ (n + 1))\n    rw [PrimeSpectrum.basicOpen_pow f (n + 1) (by omega)]\n    exact (leOfHom (iDh i) :) hy\n  -- The rest of the proof is just computation\n  apply const_ext\n  rw [‚Üê hb, Finset.sum_mul, Finset.mul_sum]\n  apply Finset.sum_congr rfl\n  intro j hj\n  rw [mul_assoc, ah_ha j hj i hi]\n  ring\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.isIso_toBasicOpen","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nf : R\n‚ä¢ CategoryTheory.IsIso (CommRingCat.ofHom (AlgebraicGeometry.StructureSheaf.toBasicOpen R f))","decl":"instance isIso_toBasicOpen (f : R) :\n    IsIso (CommRingCat.ofHom (toBasicOpen R f)) :=\n  haveI : IsIso ((forget CommRingCat).map (CommRingCat.ofHom (toBasicOpen R f))) :=\n    (isIso_iff_bijective _).mpr ‚ü®toBasicOpen_injective R f, toBasicOpen_surjective R f‚ü©\n  isIso_of_reflects_iso _ (forget CommRingCat)\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkAlgebra_map","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\np : PrimeSpectrum R\nr : R\n‚ä¢ Eq ((algebraMap R ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalk p)) r) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toStalk R p)) r)","decl":"@[simp]\ntheorem stalkAlgebra_map (p : PrimeSpectrum R) (r : R) :\n    algebraMap R ((structureSheaf R).presheaf.stalk p) r = toStalk R p r :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.IsLocalization.to_stalk","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\np : PrimeSpectrum R\n‚ä¢ IsLocalization.AtPrime (‚Üë((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalk p)) p.asIdeal","decl":"/-- Stalk of the structure sheaf at a prime p as localization of R -/\ninstance IsLocalization.to_stalk (p : PrimeSpectrum R) :\n    IsLocalization.AtPrime ((structureSheaf R).presheaf.stalk p) p.asIdeal := by\n  convert (IsLocalization.isLocalization_iff_of_ringEquiv (S := Localization.AtPrime p.asIdeal) _\n          (stalkIso R p).symm.commRingCatIsoToRingEquiv).mp\n      Localization.isLocalization\n  apply Algebra.algebra_ext\n  intro\n  rw [stalkAlgebra_map]\n  congr 2\n  change toStalk R p = _ ‚â´ (stalkIso R p).inv\n  rw [Iso.eq_comp_inv]\n  exact toStalk_comp_stalkToFiberRingHom R p\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.openAlgebra_map","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : Opposite (TopologicalSpace.Opens (PrimeSpectrum R))\nr : R\n‚ä¢ Eq ((algebraMap R ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj U)) r) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toOpen R (Opposite.unop U))) r)","decl":"@[simp]\ntheorem openAlgebra_map (U : (Opens (PrimeSpectrum R))·µí·µñ) (r : R) :\n    algebraMap R ((structureSheaf R).val.obj U) r = toOpen R (unop U) r :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.IsLocalization.to_basicOpen","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nr : R\n‚ä¢ IsLocalization.Away r ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj { unop := PrimeSpectrum.basicOpen r })","decl":"/-- Sections of the structure sheaf of Spec R on a basic open as localization of R -/\ninstance IsLocalization.to_basicOpen (r : R) :\n    IsLocalization.Away r ((structureSheaf R).val.obj (op <| PrimeSpectrum.basicOpen r)) := by\n  convert (IsLocalization.isLocalization_iff_of_ringEquiv (S := Localization.Away r) _\n      (basicOpenIso R r).symm.commRingCatIsoToRingEquiv).mp\n      Localization.isLocalization\n  apply Algebra.algebra_ext\n  intro x\n  congr 1\n  exact (localization_toBasicOpen R r).symm\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.to_basicOpen_epi","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nr : R\n‚ä¢ CategoryTheory.Epi (AlgebraicGeometry.StructureSheaf.toOpen R (PrimeSpectrum.basicOpen r))","decl":"instance to_basicOpen_epi (r : R) : Epi (toOpen R (PrimeSpectrum.basicOpen r)) :=\n  ‚ü®fun _ _ h => CommRingCat.hom_ext (IsLocalization.ringHom_ext (Submonoid.powers r)\n    (CommRingCat.hom_ext_iff.mp h))‚ü©\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.to_global_factors_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nx : CategoryTheory.ToType (CommRingCat.of R)\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toOpen R Top.top)) x) ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).val.map (CategoryTheory.eqToHom ‚ãØ))) (AlgebraicGeometry.StructureSheaf.const R x 1 (PrimeSpectrum.basicOpen 1) ‚ãØ))","decl":"@[elementwise]\ntheorem to_global_factors :\n    toOpen R ‚ä§ =\n      CommRingCat.ofHom (algebraMap R (Localization.Away (1 : R))) ‚â´\n        CommRingCat.ofHom (toBasicOpen R (1 : R)) ‚â´\n        (structureSheaf R).1.map (eqToHom PrimeSpectrum.basicOpen_one.symm).op := by\n  rw [‚Üê Category.assoc]\n  change toOpen R ‚ä§ =\n    (CommRingCat.ofHom <| (toBasicOpen R 1).comp (algebraMap R (Localization.Away 1))) ‚â´\n    (structureSheaf R).1.map (eqToHom _).op\n  rw [localization_toBasicOpen R, CommRingCat.ofHom_hom, toOpen_res]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.to_global_factors","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.toOpen R Top.top) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (algebraMap R (Localization.Away 1))) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (AlgebraicGeometry.StructureSheaf.toBasicOpen R 1)) ((AlgebraicGeometry.Spec.structureSheaf R).val.map (CategoryTheory.eqToHom ‚ãØ).op)))","decl":"@[elementwise]\ntheorem to_global_factors :\n    toOpen R ‚ä§ =\n      CommRingCat.ofHom (algebraMap R (Localization.Away (1 : R))) ‚â´\n        CommRingCat.ofHom (toBasicOpen R (1 : R)) ‚â´\n        (structureSheaf R).1.map (eqToHom PrimeSpectrum.basicOpen_one.symm).op := by\n  rw [‚Üê Category.assoc]\n  change toOpen R ‚ä§ =\n    (CommRingCat.ofHom <| (toBasicOpen R 1).comp (algebraMap R (Localization.Away 1))) ‚â´\n    (structureSheaf R).1.map (eqToHom _).op\n  rw [localization_toBasicOpen R, CommRingCat.ofHom_hom, toOpen_res]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.isIso_to_global","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\n‚ä¢ CategoryTheory.IsIso (AlgebraicGeometry.StructureSheaf.toOpen R Top.top)","decl":"instance isIso_to_global : IsIso (toOpen R ‚ä§) := by\n  let hom := CommRingCat.ofHom (algebraMap R (Localization.Away (1 : R)))\n  haveI : IsIso hom :=\n    (IsLocalization.atOne R (Localization.Away (1 : R))).toRingEquiv.toCommRingCatIso.isIso_hom\n  rw [to_global_factors R]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.globalSectionsIso_inv","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.globalSectionsIso R).inv (CategoryTheory.inv (AlgebraicGeometry.StructureSheaf.toOpen R Top.top))","decl":"/-- The ring isomorphism between the ring `R` and the global sections `Œì(X, ùí™‚Çì)`. -/\n@[simps! inv]\ndef globalSectionsIso : CommRingCat.of R ‚âÖ (structureSheaf R).1.obj (op ‚ä§) :=\n  asIso (toOpen R ‚ä§)\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.globalSectionsIso_hom","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : CommRingCat\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.globalSectionsIso ‚ÜëR).hom (AlgebraicGeometry.StructureSheaf.toOpen (‚ÜëR) Top.top)","decl":"@[simp]\ntheorem globalSectionsIso_hom (R : CommRingCat) : (globalSectionsIso R).hom = toOpen R ‚ä§ :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toStalk_stalkSpecializes_assoc","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nx y : PrimeSpectrum R\nh‚úù : Specializes x y\nZ : CommRingCat\nh : Quiver.Hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk R y) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h‚úù) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk R x) h)","decl":"@[simp, reassoc, elementwise nosimp]\ntheorem toStalk_stalkSpecializes {R : Type*} [CommRing R] {x y : PrimeSpectrum R} (h : x ‚§≥ y) :\n    toStalk R y ‚â´ (structureSheaf R).presheaf.stalkSpecializes h = toStalk R x := by\n  dsimp [toStalk]; simp [-toOpen_germ]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toStalk_stalkSpecializes_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nx‚úù y : PrimeSpectrum R\nh : Specializes x‚úù y\nx : CategoryTheory.ToType (CommRingCat.of R)\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toStalk R y)) x)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toStalk R x‚úù)) x)","decl":"@[simp, reassoc, elementwise nosimp]\ntheorem toStalk_stalkSpecializes {R : Type*} [CommRing R] {x y : PrimeSpectrum R} (h : x ‚§≥ y) :\n    toStalk R y ‚â´ (structureSheaf R).presheaf.stalkSpecializes h = toStalk R x := by\n  dsimp [toStalk]; simp [-toOpen_germ]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toStalk_stalkSpecializes","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nx y : PrimeSpectrum R\nh : Specializes x y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toStalk R y) ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h)) (AlgebraicGeometry.StructureSheaf.toStalk R x)","decl":"@[simp, reassoc, elementwise nosimp]\ntheorem toStalk_stalkSpecializes {R : Type*} [CommRing R] {x y : PrimeSpectrum R} (h : x ‚§≥ y) :\n    toStalk R y ‚â´ (structureSheaf R).presheaf.stalkSpecializes h = toStalk R x := by\n  dsimp [toStalk]; simp [-toOpen_germ]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.localizationToStalk_stalkSpecializes_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nx‚úù y : PrimeSpectrum R\nh : Specializes x‚úù y\nx : CategoryTheory.ToType (CommRingCat.of (Localization.AtPrime y.asIdeal))\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.localizationToStalk R y)) x)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.localizationToStalk R x‚úù)) ((CategoryTheory.ConcreteCategory.hom (CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h))) x))","decl":"@[simp, reassoc, elementwise nosimp]\ntheorem localizationToStalk_stalkSpecializes {R : Type*} [CommRing R] {x y : PrimeSpectrum R}\n    (h : x ‚§≥ y) :\n    StructureSheaf.localizationToStalk R y ‚â´ (structureSheaf R).presheaf.stalkSpecializes h =\n      CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h) ‚â´\n        StructureSheaf.localizationToStalk R x := by\n  ext : 1\n  apply IsLocalization.ringHom_ext (S := Localization.AtPrime y.asIdeal) y.asIdeal.primeCompl\n  rw [CommRingCat.hom_comp, RingHom.comp_assoc, CommRingCat.hom_comp, RingHom.comp_assoc]\n  dsimp [localizationToStalk, PrimeSpectrum.localizationMapOfSpecializes]\n  rw [IsLocalization.lift_comp, IsLocalization.lift_comp, IsLocalization.lift_comp]\n  exact CommRingCat.hom_ext_iff.mp (toStalk_stalkSpecializes h)\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.localizationToStalk_stalkSpecializes_assoc","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nx y : PrimeSpectrum R\nh‚úù : Specializes x y\nZ : CommRingCat\nh : Quiver.Hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.localizationToStalk R y) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h‚úù) h)) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h‚úù)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.localizationToStalk R x) h))","decl":"@[simp, reassoc, elementwise nosimp]\ntheorem localizationToStalk_stalkSpecializes {R : Type*} [CommRing R] {x y : PrimeSpectrum R}\n    (h : x ‚§≥ y) :\n    StructureSheaf.localizationToStalk R y ‚â´ (structureSheaf R).presheaf.stalkSpecializes h =\n      CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h) ‚â´\n        StructureSheaf.localizationToStalk R x := by\n  ext : 1\n  apply IsLocalization.ringHom_ext (S := Localization.AtPrime y.asIdeal) y.asIdeal.primeCompl\n  rw [CommRingCat.hom_comp, RingHom.comp_assoc, CommRingCat.hom_comp, RingHom.comp_assoc]\n  dsimp [localizationToStalk, PrimeSpectrum.localizationMapOfSpecializes]\n  rw [IsLocalization.lift_comp, IsLocalization.lift_comp, IsLocalization.lift_comp]\n  exact CommRingCat.hom_ext_iff.mp (toStalk_stalkSpecializes h)\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.localizationToStalk_stalkSpecializes","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nx y : PrimeSpectrum R\nh : Specializes x y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.localizationToStalk R y) ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h)) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h)) (AlgebraicGeometry.StructureSheaf.localizationToStalk R x))","decl":"@[simp, reassoc, elementwise nosimp]\ntheorem localizationToStalk_stalkSpecializes {R : Type*} [CommRing R] {x y : PrimeSpectrum R}\n    (h : x ‚§≥ y) :\n    StructureSheaf.localizationToStalk R y ‚â´ (structureSheaf R).presheaf.stalkSpecializes h =\n      CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h) ‚â´\n        StructureSheaf.localizationToStalk R x := by\n  ext : 1\n  apply IsLocalization.ringHom_ext (S := Localization.AtPrime y.asIdeal) y.asIdeal.primeCompl\n  rw [CommRingCat.hom_comp, RingHom.comp_assoc, CommRingCat.hom_comp, RingHom.comp_assoc]\n  dsimp [localizationToStalk, PrimeSpectrum.localizationMapOfSpecializes]\n  rw [IsLocalization.lift_comp, IsLocalization.lift_comp, IsLocalization.lift_comp]\n  exact CommRingCat.hom_ext_iff.mp (toStalk_stalkSpecializes h)\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkSpecializes_stalk_to_fiber_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nx‚úù y : PrimeSpectrum R\nh : Specializes x‚úù y\nx : CategoryTheory.ToType ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalk y)\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x‚úù)) ((CategoryTheory.ConcreteCategory.hom ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h)) x)) ((CategoryTheory.ConcreteCategory.hom (CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h))) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R y)) x))","decl":"@[simp, reassoc, elementwise nosimp]\ntheorem stalkSpecializes_stalk_to_fiber {R : Type*} [CommRing R] {x y : PrimeSpectrum R}\n    (h : x ‚§≥ y) :\n    (structureSheaf R).presheaf.stalkSpecializes h ‚â´ StructureSheaf.stalkToFiberRingHom R x =\n      StructureSheaf.stalkToFiberRingHom R y ‚â´\n      (CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h)) := by\n  change _ ‚â´ (StructureSheaf.stalkIso R x).hom = (StructureSheaf.stalkIso R y).hom ‚â´ _\n  rw [‚Üê Iso.eq_comp_inv, Category.assoc, ‚Üê Iso.inv_comp_eq]\n  exact localizationToStalk_stalkSpecializes h\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkSpecializes_stalk_to_fiber_assoc","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nx y : PrimeSpectrum R\nh‚úù : Specializes x y\nZ : CommRingCat\nh : Quiver.Hom (CommRingCat.of (Localization.AtPrime x.asIdeal)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h‚úù) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R y) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h‚úù)) h))","decl":"@[simp, reassoc, elementwise nosimp]\ntheorem stalkSpecializes_stalk_to_fiber {R : Type*} [CommRing R] {x y : PrimeSpectrum R}\n    (h : x ‚§≥ y) :\n    (structureSheaf R).presheaf.stalkSpecializes h ‚â´ StructureSheaf.stalkToFiberRingHom R x =\n      StructureSheaf.stalkToFiberRingHom R y ‚â´\n      (CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h)) := by\n  change _ ‚â´ (StructureSheaf.stalkIso R x).hom = (StructureSheaf.stalkIso R y).hom ‚â´ _\n  rw [‚Üê Iso.eq_comp_inv, Category.assoc, ‚Üê Iso.inv_comp_eq]\n  exact localizationToStalk_stalkSpecializes h\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.stalkSpecializes_stalk_to_fiber","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nx y : PrimeSpectrum R\nh : Specializes x y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h) (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R y) (CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h)))","decl":"@[simp, reassoc, elementwise nosimp]\ntheorem stalkSpecializes_stalk_to_fiber {R : Type*} [CommRing R] {x y : PrimeSpectrum R}\n    (h : x ‚§≥ y) :\n    (structureSheaf R).presheaf.stalkSpecializes h ‚â´ StructureSheaf.stalkToFiberRingHom R x =\n      StructureSheaf.stalkToFiberRingHom R y ‚â´\n      (CommRingCat.ofHom (PrimeSpectrum.localizationMapOfSpecializes h)) := by\n  change _ ‚â´ (StructureSheaf.stalkIso R x).hom = (StructureSheaf.stalkIso R y).hom ‚â´ _\n  rw [‚Üê Iso.eq_comp_inv, Category.assoc, ‚Üê Iso.inv_comp_eq]\n  exact localizationToStalk_stalkSpecializes h\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.comapFunIsLocallyFraction","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\nS : Type u\ninst‚úù : CommRing S\nf : RingHom R S\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nV : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top S)\nhUV : HasSubset.Subset V.carrier (Set.preimage (‚áë(PrimeSpectrum.comap f)) U.carrier)\ns : (x : Subtype fun x => Membership.mem U x) ‚Üí AlgebraicGeometry.StructureSheaf.Localizations R ‚Üëx\nhs : (AlgebraicGeometry.StructureSheaf.isLocallyFraction R).pred s\n‚ä¢ (AlgebraicGeometry.StructureSheaf.isLocallyFraction S).pred (AlgebraicGeometry.StructureSheaf.comapFun f U V hUV s)","decl":"theorem comapFunIsLocallyFraction (f : R ‚Üí+* S) (U : Opens (PrimeSpectrum.Top R))\n    (V : Opens (PrimeSpectrum.Top S)) (hUV : V.1 ‚äÜ PrimeSpectrum.comap f ‚Åª¬π' U.1)\n    (s : ‚àÄ x : U, Localizations R x) (hs : (isLocallyFraction R).toPrelocalPredicate.pred s) :\n    (isLocallyFraction S).toPrelocalPredicate.pred (comapFun f U V hUV s) := by\n  rintro ‚ü®p, hpV‚ü©\n  -- Since `s` is locally fraction, we can find a neighborhood `W` of `PrimeSpectrum.comap f p`\n  -- in `U`, such that `s = a / b` on `W`, for some ring elements `a, b : R`.\n  rcases hs ‚ü®PrimeSpectrum.comap f p, hUV hpV‚ü© with ‚ü®W, m, iWU, a, b, h_frac‚ü©\n  -- We claim that we can write our new section as the fraction `f a / f b` on the neighborhood\n  -- `(comap f) ‚Åª¬π W ‚äì V` of `p`.\n  refine ‚ü®Opens.comap (PrimeSpectrum.comap f) W ‚äì V, ‚ü®m, hpV‚ü©, Opens.infLERight _ _, f a, f b, ?_‚ü©\n  rintro ‚ü®q, ‚ü®hqW, hqV‚ü©‚ü©\n  specialize h_frac ‚ü®PrimeSpectrum.comap f q, hqW‚ü©\n  refine ‚ü®h_frac.1, ?_‚ü©\n  dsimp only [comapFun]\n  erw [‚Üê Localization.localRingHom_to_map (PrimeSpectrum.comap f q).asIdeal, ‚Üê RingHom.map_mul,\n    h_frac.2, Localization.localRingHom_to_map]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.comap_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\nS : Type u\ninst‚úù : CommRing S\nf : RingHom R S\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nV : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top S)\nhUV : HasSubset.Subset V.carrier (Set.preimage (‚áë(PrimeSpectrum.comap f)) U.carrier)\ns : ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj { unop := U })\np : Subtype fun x => Membership.mem V x\n‚ä¢ Eq (‚Üë((AlgebraicGeometry.StructureSheaf.comap f U V hUV) s) p) ((Localization.localRingHom ((PrimeSpectrum.comap f) ‚Üëp).asIdeal (‚Üëp).asIdeal f ‚ãØ) (‚Üës ‚ü®(PrimeSpectrum.comap f) ‚Üëp, ‚ãØ‚ü©))","decl":"@[simp]\ntheorem comap_apply (f : R ‚Üí+* S) (U : Opens (PrimeSpectrum.Top R))\n    (V : Opens (PrimeSpectrum.Top S)) (hUV : V.1 ‚äÜ PrimeSpectrum.comap f ‚Åª¬π' U.1)\n    (s : (structureSheaf R).1.obj (op U)) (p : V) :\n    (comap f U V hUV s).1 p =\n      Localization.localRingHom (PrimeSpectrum.comap f p.1).asIdeal _ f rfl\n        (s.1 ‚ü®PrimeSpectrum.comap f p.1, hUV p.2‚ü© :) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.comap_const","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\nS : Type u\ninst‚úù : CommRing S\nf : RingHom R S\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nV : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top S)\nhUV : HasSubset.Subset V.carrier (Set.preimage (‚áë(PrimeSpectrum.comap f)) U.carrier)\na b : R\nhb : ‚àÄ (x : PrimeSpectrum R), Membership.mem U x ‚Üí Membership.mem x.asIdeal.primeCompl b\n‚ä¢ Eq ((AlgebraicGeometry.StructureSheaf.comap f U V hUV) (AlgebraicGeometry.StructureSheaf.const R a b U hb)) (AlgebraicGeometry.StructureSheaf.const S (f a) (f b) V ‚ãØ)","decl":"theorem comap_const (f : R ‚Üí+* S) (U : Opens (PrimeSpectrum.Top R))\n    (V : Opens (PrimeSpectrum.Top S)) (hUV : V.1 ‚äÜ PrimeSpectrum.comap f ‚Åª¬π' U.1) (a b : R)\n    (hb : ‚àÄ x : PrimeSpectrum R, x ‚àà U ‚Üí b ‚àà x.asIdeal.primeCompl) :\n    comap f U V hUV (const R a b U hb) =\n      const S (f a) (f b) V fun p hpV => hb (PrimeSpectrum.comap f p) (hUV hpV) :=\n  Subtype.eq <|\n    funext fun p => by\n      rw [comap_apply, const_apply, const_apply, Localization.localRingHom_mk']\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.comap_id_eq_map","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU V : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\niVU : Quiver.Hom V U\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.comap (RingHom.id R) U V ‚ãØ) (CommRingCat.Hom.hom ((AlgebraicGeometry.Spec.structureSheaf R).val.map iVU.op))","decl":"/-- For an inclusion `i : V ‚ü∂ U` between open sets of the prime spectrum of `R`, the comap of the\nidentity from OO_X(U) to OO_X(V) equals as the restriction map of the structure sheaf.\n\nThis is a generalization of the fact that, for fixed `U`, the comap of the identity from OO_X(U)\nto OO_X(U) is the identity.\n-/\ntheorem comap_id_eq_map (U V : Opens (PrimeSpectrum.Top R)) (iVU : V ‚ü∂ U) :\n    (comap (RingHom.id R) U V fun _ hpV => leOfHom iVU <| hpV) =\n      ((structureSheaf R).1.map iVU.op).hom :=\n  RingHom.ext fun s => Subtype.eq <| funext fun p => by\n    rw [comap_apply]\n    -- Unfortunately, we cannot use `Localization.localRingHom_id` here, because\n    -- `PrimeSpectrum.comap (RingHom.id R) p` is not *definitionally* equal to `p`. Instead, we use\n    -- that we can write `s` as a fraction `a/b` in a small neighborhood around `p`. Since\n    -- `PrimeSpectrum.comap (RingHom.id R) p` equals `p`, it is also contained in the same\n    -- neighborhood, hence `s` equals `a/b` there too.\n    obtain ‚ü®W, hpW, iWU, h‚ü© := s.2 (iVU p)\n    obtain ‚ü®a, b, h'‚ü© := h.eq_mk'\n    obtain ‚ü®hb‚ÇÅ, s_eq‚ÇÅ‚ü© := h' ‚ü®p, hpW‚ü©\n    obtain ‚ü®hb‚ÇÇ, s_eq‚ÇÇ‚ü© :=\n      h' ‚ü®PrimeSpectrum.comap (RingHom.id _) p.1, hpW‚ü©\n    dsimp only at s_eq‚ÇÅ s_eq‚ÇÇ\n    erw [s_eq‚ÇÇ, Localization.localRingHom_mk', ‚Üê s_eq‚ÇÅ, ‚Üê res_apply _ _ _ iVU]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.comap_id","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU V : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nhUV : Eq U V\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.comap (RingHom.id R) U V ‚ãØ) (CommRingCat.Hom.hom (CategoryTheory.eqToHom ‚ãØ))","decl":"/--\nThe comap of the identity is the identity. In this variant of the lemma, two open subsets `U` and\n`V` are given as arguments, together with a proof that `U = V`. This is useful when `U` and `V`\nare not definitionally equal.\n-/\ntheorem comap_id {U V : Opens (PrimeSpectrum.Top R)} (hUV : U = V) :\n    (comap (RingHom.id R) U V fun p hpV => by rwa [hUV, PrimeSpectrum.comap_id]) =\n      (eqToHom (show (structureSheaf R).1.obj (op U) = _ by rw [hUV])).hom := by\n  rw [comap_id_eq_map U V (eqToHom hUV.symm), eqToHom_op, eqToHom_map]\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.comap_id'","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù : CommRing R\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.comap (RingHom.id R) U U ‚ãØ) (RingHom.id ‚Üë((AlgebraicGeometry.Spec.structureSheaf R).val.obj { unop := U }))","decl":"@[simp]\ntheorem comap_id' (U : Opens (PrimeSpectrum.Top R)) :\n    (comap (RingHom.id R) U U fun p hpU => by rwa [PrimeSpectrum.comap_id]) = RingHom.id _ := by\n  rw [comap_id rfl]; rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.comap_comp","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù¬≤ : CommRing R\nS : Type u\ninst‚úù¬π : CommRing S\nP : Type u\ninst‚úù : CommRing P\nf : RingHom R S\ng : RingHom S P\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nV : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top S)\nW : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top P)\nhUV : ‚àÄ (p : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top S)), Membership.mem V p ‚Üí Membership.mem U ((PrimeSpectrum.comap f) p)\nhVW : ‚àÄ (p : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top P)), Membership.mem W p ‚Üí Membership.mem V ((PrimeSpectrum.comap g) p)\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.comap (g.comp f) U W ‚ãØ) ((AlgebraicGeometry.StructureSheaf.comap g V W hVW).comp (AlgebraicGeometry.StructureSheaf.comap f U V hUV))","decl":"theorem comap_comp (f : R ‚Üí+* S) (g : S ‚Üí+* P) (U : Opens (PrimeSpectrum.Top R))\n    (V : Opens (PrimeSpectrum.Top S)) (W : Opens (PrimeSpectrum.Top P))\n    (hUV : ‚àÄ p ‚àà V, PrimeSpectrum.comap f p ‚àà U) (hVW : ‚àÄ p ‚àà W, PrimeSpectrum.comap g p ‚àà V) :\n    (comap (g.comp f) U W fun p hpW => hUV (PrimeSpectrum.comap g p) (hVW p hpW)) =\n      (comap g V W hVW).comp (comap f U V hUV) :=\n  RingHom.ext fun s =>\n    Subtype.eq <|\n      funext fun p => by\n        rw [comap_apply]\n        rw [Localization.localRingHom_comp _ (PrimeSpectrum.comap g p.1).asIdeal] <;>\n        -- refl works here, because `PrimeSpectrum.comap (g.comp f) p` is defeq to\n        -- `PrimeSpectrum.comap f (PrimeSpectrum.comap g p)`\n        rfl\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toOpen_comp_comap_apply","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\nS : Type u\ninst‚úù : CommRing S\nf : RingHom R S\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nx : CategoryTheory.ToType (CommRingCat.of R)\n‚ä¢ Eq ((AlgebraicGeometry.StructureSheaf.comap f U ((TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) U) ‚ãØ) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toOpen R U)) x)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.StructureSheaf.toOpen S ((TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) U))) (f x))","decl":"@[elementwise, reassoc]\ntheorem toOpen_comp_comap (f : R ‚Üí+* S) (U : Opens (PrimeSpectrum.Top R)) :\n    (toOpen R U ‚â´ CommRingCat.ofHom (comap f U (Opens.comap (PrimeSpectrum.comap f) U)\n        fun _ => id)) =\n      CommRingCat.ofHom f ‚â´ toOpen S _ :=\n  CommRingCat.hom_ext <| RingHom.ext fun _ => Subtype.eq <| funext fun _ =>\n    Localization.localRingHom_to_map _ _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toOpen_comp_comap_assoc","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\nS : Type u\ninst‚úù : CommRing S\nf : RingHom R S\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\nZ : CommRingCat\nh : Quiver.Hom (CommRingCat.of ‚Üë((AlgebraicGeometry.Spec.structureSheaf S).val.obj { unop := (TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) U })) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen R U) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom (AlgebraicGeometry.StructureSheaf.comap f U ((TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) U) ‚ãØ)) h)) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom f) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen S ((TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) U)) h))","decl":"@[elementwise, reassoc]\ntheorem toOpen_comp_comap (f : R ‚Üí+* S) (U : Opens (PrimeSpectrum.Top R)) :\n    (toOpen R U ‚â´ CommRingCat.ofHom (comap f U (Opens.comap (PrimeSpectrum.comap f) U)\n        fun _ => id)) =\n      CommRingCat.ofHom f ‚â´ toOpen S _ :=\n  CommRingCat.hom_ext <| RingHom.ext fun _ => Subtype.eq <| funext fun _ =>\n    Localization.localRingHom_to_map _ _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.toOpen_comp_comap","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\nS : Type u\ninst‚úù : CommRing S\nf : RingHom R S\nU : TopologicalSpace.Opens ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen R U) (CommRingCat.ofHom (AlgebraicGeometry.StructureSheaf.comap f U ((TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) U) ‚ãØ))) (CategoryTheory.CategoryStruct.comp (CommRingCat.ofHom f) (AlgebraicGeometry.StructureSheaf.toOpen S ((TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) U)))","decl":"@[elementwise, reassoc]\ntheorem toOpen_comp_comap (f : R ‚Üí+* S) (U : Opens (PrimeSpectrum.Top R)) :\n    (toOpen R U ‚â´ CommRingCat.ofHom (comap f U (Opens.comap (PrimeSpectrum.comap f) U)\n        fun _ => id)) =\n      CommRingCat.ofHom f ‚â´ toOpen S _ :=\n  CommRingCat.hom_ext <| RingHom.ext fun _ => Subtype.eq <| funext fun _ =>\n    Localization.localRingHom_to_map _ _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.StructureSheaf.comap_basicOpen","module":"Mathlib.AlgebraicGeometry.StructureSheaf","initialProofState":"R : Type u\ninst‚úù¬π : CommRing R\nS : Type u\ninst‚úù : CommRing S\nf : RingHom R S\nx : R\n‚ä¢ Eq (AlgebraicGeometry.StructureSheaf.comap f (PrimeSpectrum.basicOpen x) (PrimeSpectrum.basicOpen (f x)) ‚ãØ) (IsLocalization.map (‚Üë((AlgebraicGeometry.Spec.structureSheaf S).val.obj { unop := PrimeSpectrum.basicOpen (f x) })) f ‚ãØ)","decl":"lemma comap_basicOpen (f : R ‚Üí+* S) (x : R) :\n    comap f (PrimeSpectrum.basicOpen x) (PrimeSpectrum.basicOpen (f x))\n        (PrimeSpectrum.comap_basicOpen f x).le =\n      IsLocalization.map (M := .powers x) (T := .powers (f x)) _ f\n        (Submonoid.powers_le.mpr (Submonoid.mem_powers _)) :=\n  IsLocalization.ringHom_ext (.powers x) <| by\n    simpa [CommRingCat.hom_ext_iff] using toOpen_comp_comap f _\n\n"}
