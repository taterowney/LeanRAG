{"name":"CompleteSublattice.sSupClosed'","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nself : CompleteSublattice α\ns : Set α\na✝ : HasSubset.Subset s self.carrier\n⊢ Membership.mem self.carrier (SupSet.sSup s)","decl":"/-- A complete sublattice is a subset of a complete lattice that is closed under arbitrary suprema\nand infima. -/\nstructure CompleteSublattice extends Sublattice α where\n  sSupClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sSup s ∈ carrier\n  sInfClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sInf s ∈ carrier\n\n"}
{"name":"CompleteSublattice.mk.sizeOf_spec","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\ninst✝ : SizeOf α\ntoSublattice : Sublattice α\nsSupClosed' : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice.carrier → Membership.mem toSublattice.carrier (SupSet.sSup s)\nsInfClosed' : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice.carrier → Membership.mem toSublattice.carrier (InfSet.sInf s)\n⊢ Eq (SizeOf.sizeOf { toSublattice := toSublattice, sSupClosed' := sSupClosed', sInfClosed' := sInfClosed' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSublattice))","decl":"/-- A complete sublattice is a subset of a complete lattice that is closed under arbitrary suprema\nand infima. -/\nstructure CompleteSublattice extends Sublattice α where\n  sSupClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sSup s ∈ carrier\n  sInfClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sInf s ∈ carrier\n\n"}
{"name":"CompleteSublattice.mk.injEq","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ntoSublattice✝ : Sublattice α\nsSupClosed'✝ : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice✝.carrier → Membership.mem toSublattice✝.carrier (SupSet.sSup s)\nsInfClosed'✝ : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice✝.carrier → Membership.mem toSublattice✝.carrier (InfSet.sInf s)\ntoSublattice : Sublattice α\nsSupClosed' : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice.carrier → Membership.mem toSublattice.carrier (SupSet.sSup s)\nsInfClosed' : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice.carrier → Membership.mem toSublattice.carrier (InfSet.sInf s)\n⊢ Eq (Eq { toSublattice := toSublattice✝, sSupClosed' := sSupClosed'✝, sInfClosed' := sInfClosed'✝ } { toSublattice := toSublattice, sSupClosed' := sSupClosed', sInfClosed' := sInfClosed' }) (Eq toSublattice✝ toSublattice)","decl":"/-- A complete sublattice is a subset of a complete lattice that is closed under arbitrary suprema\nand infima. -/\nstructure CompleteSublattice extends Sublattice α where\n  sSupClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sSup s ∈ carrier\n  sInfClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sInf s ∈ carrier\n\n"}
{"name":"CompleteSublattice.mk.inj","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ntoSublattice✝ : Sublattice α\nsSupClosed'✝ : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice✝.carrier → Membership.mem toSublattice✝.carrier (SupSet.sSup s)\nsInfClosed'✝ : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice✝.carrier → Membership.mem toSublattice✝.carrier (InfSet.sInf s)\ntoSublattice : Sublattice α\nsSupClosed' : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice.carrier → Membership.mem toSublattice.carrier (SupSet.sSup s)\nsInfClosed' : ∀ ⦃s : Set α⦄, HasSubset.Subset s toSublattice.carrier → Membership.mem toSublattice.carrier (InfSet.sInf s)\nx✝ : Eq { toSublattice := toSublattice✝, sSupClosed' := sSupClosed'✝, sInfClosed' := sInfClosed'✝ } { toSublattice := toSublattice, sSupClosed' := sSupClosed', sInfClosed' := sInfClosed' }\n⊢ Eq toSublattice✝ toSublattice","decl":"/-- A complete sublattice is a subset of a complete lattice that is closed under arbitrary suprema\nand infima. -/\nstructure CompleteSublattice extends Sublattice α where\n  sSupClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sSup s ∈ carrier\n  sInfClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sInf s ∈ carrier\n\n"}
{"name":"CompleteSublattice.sInfClosed'","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nself : CompleteSublattice α\ns : Set α\na✝ : HasSubset.Subset s self.carrier\n⊢ Membership.mem self.carrier (InfSet.sInf s)","decl":"/-- A complete sublattice is a subset of a complete lattice that is closed under arbitrary suprema\nand infima. -/\nstructure CompleteSublattice extends Sublattice α where\n  sSupClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sSup s ∈ carrier\n  sInfClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sInf s ∈ carrier\n\n"}
{"name":"CompleteSublattice.mk'_carrier","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ncarrier : Set α\nsSupClosed' : ∀ ⦃s : Set α⦄, HasSubset.Subset s carrier → Membership.mem carrier (SupSet.sSup s)\nsInfClosed' : ∀ ⦃s : Set α⦄, HasSubset.Subset s carrier → Membership.mem carrier (InfSet.sInf s)\n⊢ Eq (CompleteSublattice.mk' carrier sSupClosed' sInfClosed').carrier carrier","decl":"/-- To check that a subset is a complete sublattice, one does not need to check that it is closed\nunder binary `Sup` since this follows from the stronger `sSup` condition. Likewise for infima. -/\n@[simps] def mk' (carrier : Set α)\n    (sSupClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sSup s ∈ carrier)\n    (sInfClosed' : ∀ ⦃s : Set α⦄, s ⊆ carrier → sInf s ∈ carrier) :\n  CompleteSublattice α where\n    carrier := carrier\n    sSupClosed' := sSupClosed'\n    sInfClosed' := sInfClosed'\n    supClosed' := fun x hx y hy ↦ by\n      suffices x ⊔ y = sSup {x, y} by exact this ▸ sSupClosed' (fun z hz ↦ by aesop)\n      simp [sSup_singleton]\n    infClosed' := fun x hx y hy ↦ by\n      suffices x ⊓ y = sInf {x, y} by exact this ▸ sInfClosed' (fun z hz ↦ by aesop)\n      simp [sInf_singleton]\n\n"}
{"name":"CompleteSublattice.sSupClosed","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\ns : Set α\nh : HasSubset.Subset s ↑L\n⊢ Membership.mem L (SupSet.sSup s)","decl":"theorem sSupClosed {s : Set α} (h : s ⊆ L) : sSup s ∈ L := L.sSupClosed' h\n\n"}
{"name":"CompleteSublattice.sInfClosed","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\ns : Set α\nh : HasSubset.Subset s ↑L\n⊢ Membership.mem L (InfSet.sInf s)","decl":"theorem sInfClosed {s : Set α} (h : s ⊆ L) : sInf s ∈ L := L.sInfClosed' h\n\n"}
{"name":"CompleteSublattice.coe_bot","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\n⊢ Eq (↑Bot.bot) Bot.bot","decl":"@[simp] theorem coe_bot : (↑(⊥ : L) : α) = ⊥ := rfl\n\n"}
{"name":"CompleteSublattice.coe_top","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\n⊢ Eq (↑Top.top) Top.top","decl":"@[simp] theorem coe_top : (↑(⊤ : L) : α) = ⊤ := rfl\n\n"}
{"name":"CompleteSublattice.coe_sSup","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\nS : Set (Subtype fun x => Membership.mem L x)\n⊢ Eq (↑(SupSet.sSup S)) (SupSet.sSup (setOf fun x => Exists fun s => And (Membership.mem S s) (Eq (↑s) x)))","decl":"@[simp] theorem coe_sSup (S : Set L) : (↑(sSup S) : α) = sSup {(s : α) | s ∈ S} := rfl\n\n"}
{"name":"CompleteSublattice.coe_sSup'","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\nS : Set (Subtype fun x => Membership.mem L x)\n⊢ Eq (↑(SupSet.sSup S)) (iSup fun N => iSup fun h => ↑N)","decl":"theorem coe_sSup' (S : Set L) : (↑(sSup S) : α) = ⨆ N ∈ S, (N : α) := by\n  rw [coe_sSup, ← Set.image, sSup_image]\n\n"}
{"name":"CompleteSublattice.coe_sInf","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\nS : Set (Subtype fun x => Membership.mem L x)\n⊢ Eq (↑(InfSet.sInf S)) (InfSet.sInf (setOf fun x => Exists fun s => And (Membership.mem S s) (Eq (↑s) x)))","decl":"@[simp] theorem coe_sInf (S : Set L) : (↑(sInf S) : α) = sInf {(s : α) | s ∈ S} := rfl\n\n"}
{"name":"CompleteSublattice.coe_sInf'","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\nS : Set (Subtype fun x => Membership.mem L x)\n⊢ Eq (↑(InfSet.sInf S)) (iInf fun N => iInf fun h => ↑N)","decl":"theorem coe_sInf' (S : Set L) : (↑(sInf S) : α) = ⨅ N ∈ S, (N : α) := by\n  rw [coe_sInf, ← Set.image, sInf_image]\n\n-- Redeclaring to get proper keys for these instances\n"}
{"name":"CompleteSublattice.coe_subtype","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\n⊢ Eq (⇑L.subtype) Subtype.val","decl":"@[simp, norm_cast] lemma coe_subtype (L : CompleteSublattice α) : L.subtype = ((↑) : L → α) := rfl\n"}
{"name":"CompleteSublattice.subtype_apply","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : Sublattice α\na : Subtype fun x => Membership.mem L x\n⊢ Eq (L.subtype a) ↑a","decl":"lemma subtype_apply (L : Sublattice α) (a : L) : L.subtype a = a := rfl\n\n"}
{"name":"CompleteSublattice.subtype_injective","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\n⊢ Function.Injective ⇑L.subtype","decl":"lemma subtype_injective (L : CompleteSublattice α) :\n    Injective <| subtype L := Subtype.coe_injective\n\n"}
{"name":"CompleteSublattice.map_carrier","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : CompleteLatticeHom α β\nL : CompleteSublattice α\n⊢ Eq (CompleteSublattice.map f L).carrier (Set.image ⇑f ↑L)","decl":"/-- The push forward of a complete sublattice under a complete lattice hom is a complete\nsublattice. -/\n@[simps] def map (L : CompleteSublattice α) : CompleteSublattice β where\n  carrier := f '' L\n  supClosed' := L.supClosed.image f\n  infClosed' := L.infClosed.image f\n  sSupClosed' := fun s hs ↦ by\n    obtain ⟨t, ht, rfl⟩ := subset_image_iff.mp hs\n    rw [← map_sSup]\n    exact mem_image_of_mem f (sSupClosed ht)\n  sInfClosed' := fun s hs ↦ by\n    obtain ⟨t, ht, rfl⟩ := subset_image_iff.mp hs\n    rw [← map_sInf]\n    exact mem_image_of_mem f (sInfClosed ht)\n\n"}
{"name":"CompleteSublattice.mem_map","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : CompleteLatticeHom α β\nL : CompleteSublattice α\nb : β\n⊢ Iff (Membership.mem (CompleteSublattice.map f L) b) (Exists fun a => And (Membership.mem L a) (Eq (f a) b))","decl":"@[simp] theorem mem_map {b : β} : b ∈ L.map f ↔ ∃ a ∈ L, f a = b := Iff.rfl\n\n"}
{"name":"CompleteSublattice.comap_carrier","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : CompleteLatticeHom α β\nL : CompleteSublattice β\n⊢ Eq (CompleteSublattice.comap f L).carrier (Set.preimage ⇑f ↑L)","decl":"/-- The pull back of a complete sublattice under a complete lattice hom is a complete sublattice. -/\n@[simps] def comap (L : CompleteSublattice β) : CompleteSublattice α where\n  carrier := f ⁻¹' L\n  supClosed' := L.supClosed.preimage f\n  infClosed' := L.infClosed.preimage f\n  sSupClosed' s hs := by\n    simpa only [mem_preimage, map_sSup, SetLike.mem_coe] using sSupClosed <| mapsTo'.mp hs\n  sInfClosed' s hs := by\n    simpa only [mem_preimage, map_sInf, SetLike.mem_coe] using sInfClosed <| mapsTo'.mp hs\n\n"}
{"name":"CompleteSublattice.mem_comap","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : CompleteLatticeHom α β\nL : CompleteSublattice β\na : α\n⊢ Iff (Membership.mem (CompleteSublattice.comap f L) a) (Membership.mem L (f a))","decl":"@[simp] theorem mem_comap {L : CompleteSublattice β} {a : α} : a ∈ L.comap f ↔ f a ∈ L := Iff.rfl\n\n"}
{"name":"CompleteSublattice.disjoint_iff","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\na b : Subtype fun x => Membership.mem L x\n⊢ Iff (Disjoint a b) (Disjoint ↑a ↑b)","decl":"protected lemma disjoint_iff {a b : L} :\n    Disjoint a b ↔ Disjoint (a : α) (b : α) := by\n  rw [disjoint_iff, disjoint_iff, ← Sublattice.coe_inf, ← coe_bot (L := L),\n    Subtype.coe_injective.eq_iff]\n\n"}
{"name":"CompleteSublattice.codisjoint_iff","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\na b : Subtype fun x => Membership.mem L x\n⊢ Iff (Codisjoint a b) (Codisjoint ↑a ↑b)","decl":"protected lemma codisjoint_iff {a b : L} :\n    Codisjoint a b ↔ Codisjoint (a : α) (b : α) := by\n  rw [codisjoint_iff, codisjoint_iff, ← Sublattice.coe_sup, ← coe_top (L := L),\n    Subtype.coe_injective.eq_iff]\n\n"}
{"name":"CompleteSublattice.isCompl_iff","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\na b : Subtype fun x => Membership.mem L x\n⊢ Iff (IsCompl a b) (IsCompl ↑a ↑b)","decl":"protected lemma isCompl_iff {a b : L} :\n    IsCompl a b ↔ IsCompl (a : α) (b : α) := by\n  rw [isCompl_iff, isCompl_iff, CompleteSublattice.disjoint_iff, CompleteSublattice.codisjoint_iff]\n\n"}
{"name":"CompleteSublattice.isComplemented_iff","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\n⊢ Iff (ComplementedLattice (Subtype fun x => Membership.mem L x)) (∀ (a : α), Membership.mem L a → Exists fun b => And (Membership.mem L b) (IsCompl a b))","decl":"lemma isComplemented_iff : ComplementedLattice L ↔ ∀ a ∈ L, ∃ b ∈ L, IsCompl a b := by\n  refine ⟨fun ⟨h⟩ a ha ↦ ?_, fun h ↦ ⟨fun ⟨a, ha⟩ ↦ ?_⟩⟩\n  · obtain ⟨b, hb⟩ := h ⟨a, ha⟩\n    exact ⟨b, b.property, CompleteSublattice.isCompl_iff.mp hb⟩\n  · obtain ⟨b, hb, hb'⟩ := h a ha\n    exact ⟨⟨b, hb⟩, CompleteSublattice.isCompl_iff.mpr hb'⟩\n\n"}
{"name":"CompleteSublattice.coe_copy","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\ns : Set α\nhs : Eq s ↑L\n⊢ Eq (↑(L.copy s hs)) s","decl":"@[simp, norm_cast] lemma coe_copy (s : Set α) (hs) : L.copy s hs = s := rfl\n\n"}
{"name":"CompleteSublattice.copy_eq","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nL : CompleteSublattice α\ns : Set α\nhs : Eq s ↑L\n⊢ Eq (L.copy s hs) L","decl":"lemma copy_eq (s : Set α) (hs) : L.copy s hs = L := SetLike.coe_injective hs\n\n"}
{"name":"CompleteLatticeHom.range_coe","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : CompleteLatticeHom α β\n⊢ Eq (↑f.range) (Set.range ⇑f)","decl":"theorem range_coe : (f.range : Set β) = range f := rfl\n\n"}
{"name":"CompleteLatticeHom.toOrderIsoRangeOfInjective_apply","module":"Mathlib.Order.CompleteSublattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : CompleteLatticeHom α β\nhf : Function.Injective ⇑f\na : α\n⊢ Eq ((f.toOrderIsoRangeOfInjective hf) a) ⟨f a, ⋯⟩","decl":"/-- We can regard a complete lattice homomorphism as an order equivalence to its range. -/\n@[simps! apply] noncomputable def toOrderIsoRangeOfInjective (hf : Injective f) : α ≃o f.range :=\n  (orderEmbeddingOfInjective f hf).orderIso\n\n"}
