{"name":"MulChar.finite","module":"Mathlib.NumberTheory.MulChar.Duality","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝³ : CommMonoid M\ninst✝² : CommRing R\ninst✝¹ : Finite (Units M)\ninst✝ : IsDomain R\n⊢ Finite (MulChar M R)","decl":"instance finite [Finite Mˣ] [IsDomain R] : Finite (MulChar M R) := by\n  have : Finite (Mˣ →* Rˣ) := by\n    have : Fintype Mˣ := .ofFinite _\n    let S := rootsOfUnity (Fintype.card Mˣ) R\n    let F := Mˣ →* S\n    have fF : Finite F := .of_injective _ DFunLike.coe_injective\n    refine .of_surjective (fun f : F ↦ (Subgroup.subtype _).comp f) fun f ↦ ?_\n    have H a : f a ∈ S := by simp only [mem_rootsOfUnity, ← map_pow, pow_card_eq_one, map_one, S]\n    refine ⟨.codRestrict f S H, MonoidHom.ext fun _ ↦ ?_⟩\n    simp only [MonoidHom.coe_comp, Subgroup.coeSubtype, Function.comp_apply,\n      MonoidHom.codRestrict_apply]\n  exact .of_equiv _ MulChar.equivToUnitHom.symm\n\n"}
{"name":"MulChar.exists_apply_ne_one_iff_exists_monoidHom","module":"Mathlib.NumberTheory.MulChar.Duality","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝¹ : CommMonoid M\ninst✝ : CommRing R\na : Units M\n⊢ Iff (Exists fun χ => Ne (χ ↑a) 1) (Exists fun φ => Ne (φ a) 1)","decl":"lemma exists_apply_ne_one_iff_exists_monoidHom (a : Mˣ) :\n    (∃ χ : MulChar M R, χ a ≠ 1) ↔ ∃ φ : Mˣ →* Rˣ, φ a ≠ 1 := by\n  refine ⟨fun ⟨χ, hχ⟩ ↦ ⟨χ.toUnitHom, ?_⟩, fun ⟨φ, hφ⟩ ↦ ⟨ofUnitHom φ, ?_⟩⟩\n  · contrapose! hχ\n    rwa [Units.ext_iff, coe_toUnitHom] at hχ\n  · contrapose! hφ\n    simpa only [ofUnitHom_eq, equivToUnitHom_symm_coe, Units.val_eq_one] using hφ\n\n"}
{"name":"MulChar.exists_apply_ne_one_of_hasEnoughRootsOfUnity","module":"Mathlib.NumberTheory.MulChar.Duality","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝⁴ : CommMonoid M\ninst✝³ : CommRing R\ninst✝² : Finite M\ninst✝¹ : HasEnoughRootsOfUnity R (Monoid.exponent (Units M))\ninst✝ : Nontrivial R\na : M\nha : Ne a 1\n⊢ Exists fun χ => Ne (χ a) 1","decl":"/-- If `M` is a finite commutative monoid and `R` is a ring that has enough roots of unity,\nthen for each `a ≠ 1` in `M`, there exists a multiplicative character `χ : M → R` such that\n`χ a ≠ 1`. -/\ntheorem exists_apply_ne_one_of_hasEnoughRootsOfUnity [Nontrivial R] {a : M} (ha : a ≠ 1) :\n    ∃ χ : MulChar M R, χ a ≠ 1 := by\n  by_cases hu : IsUnit a\n  · refine (exists_apply_ne_one_iff_exists_monoidHom hu.unit).mpr ?_\n    refine CommGroup.exists_apply_ne_one_of_hasEnoughRootsOfUnity Mˣ R ?_\n    contrapose! ha\n    rw [← hu.unit_spec, ha, Units.val_eq_one]\n  · exact ⟨1, by simpa only [map_nonunit _ hu] using zero_ne_one⟩\n\n"}
{"name":"MulChar.mulEquiv_units","module":"Mathlib.NumberTheory.MulChar.Duality","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝³ : CommMonoid M\ninst✝² : CommRing R\ninst✝¹ : Finite M\ninst✝ : HasEnoughRootsOfUnity R (Monoid.exponent (Units M))\n⊢ Nonempty (MulEquiv (MulChar M R) (Units M))","decl":"/-- The group of `R`-valued multiplicative characters on a finite commutative monoid `M` is\n(noncanonically) isomorphic to its unit group `Mˣ` when `R` is a ring that has enough roots\nof unity. -/\nlemma mulEquiv_units : Nonempty (MulChar M R ≃* Mˣ) :=\n  ⟨mulEquivToUnitHom.trans\n    (CommGroup.monoidHom_mulEquiv_of_hasEnoughRootsOfUnity Mˣ R).some⟩\n\n"}
{"name":"MulChar.card_eq_card_units_of_hasEnoughRootsOfUnity","module":"Mathlib.NumberTheory.MulChar.Duality","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝³ : CommMonoid M\ninst✝² : CommRing R\ninst✝¹ : Finite M\ninst✝ : HasEnoughRootsOfUnity R (Monoid.exponent (Units M))\n⊢ Eq (Nat.card (MulChar M R)) (Nat.card (Units M))","decl":"/-- The cardinality of the group of `R`-valued multiplicative characters on a finite commutative\nmonoid `M` is the same as that of its unit group `Mˣ` when `R` is a ring that has enough roots\nof unity. -/\nlemma card_eq_card_units_of_hasEnoughRootsOfUnity : Nat.card (MulChar M R) = Nat.card Mˣ :=\n  Nat.card_congr (mulEquiv_units M R).some.toEquiv\n\n"}
