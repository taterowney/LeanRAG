{"name":"Complex.exp_bound_sq","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"x z : Complex\nhz : LE.le (Norm.norm z) 1\n‚ä¢ LE.le (Norm.norm (HSub.hSub (HSub.hSub (Complex.exp (HAdd.hAdd x z)) (Complex.exp x)) (HSMul.hSMul z (Complex.exp x)))) (HMul.hMul (Norm.norm (Complex.exp x)) (HPow.hPow (Norm.norm z) 2))","decl":"theorem exp_bound_sq (x z : ‚ÑÇ) (hz : ‚Äñz‚Äñ ‚â§ 1) :\n    ‚Äñexp (x + z) - exp x - z ‚Ä¢ exp x‚Äñ ‚â§ ‚Äñexp x‚Äñ * ‚Äñz‚Äñ ^ 2 :=\n  calc\n    ‚Äñexp (x + z) - exp x - z * exp x‚Äñ = ‚Äñexp x * (exp z - 1 - z)‚Äñ := by\n      congr\n      rw [exp_add]\n      ring\n    _ = ‚Äñexp x‚Äñ * ‚Äñexp z - 1 - z‚Äñ := norm_mul _ _\n    _ ‚â§ ‚Äñexp x‚Äñ * ‚Äñz‚Äñ ^ 2 :=\n      mul_le_mul_of_nonneg_left (abs_exp_sub_one_sub_id_le hz) (norm_nonneg _)\n\n"}
{"name":"Complex.locally_lipschitz_exp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"r : Real\nhr_nonneg : LE.le 0 r\nhr_le : LE.le r 1\nx y : Complex\nhyx : LT.lt (Norm.norm (HSub.hSub y x)) r\n‚ä¢ LE.le (Norm.norm (HSub.hSub (Complex.exp y) (Complex.exp x))) (HMul.hMul (HMul.hMul (HAdd.hAdd 1 r) (Norm.norm (Complex.exp x))) (Norm.norm (HSub.hSub y x)))","decl":"theorem locally_lipschitz_exp {r : ‚Ñù} (hr_nonneg : 0 ‚â§ r) (hr_le : r ‚â§ 1) (x y : ‚ÑÇ)\n    (hyx : ‚Äñy - x‚Äñ < r) : ‚Äñexp y - exp x‚Äñ ‚â§ (1 + r) * ‚Äñexp x‚Äñ * ‚Äñy - x‚Äñ := by\n  have hy_eq : y = x + (y - x) := by abel\n  have hyx_sq_le : ‚Äñy - x‚Äñ ^ 2 ‚â§ r * ‚Äñy - x‚Äñ := by\n    rw [pow_two]\n    exact mul_le_mul hyx.le le_rfl (norm_nonneg _) hr_nonneg\n  have h_sq : ‚àÄ z, ‚Äñz‚Äñ ‚â§ 1 ‚Üí ‚Äñexp (x + z) - exp x‚Äñ ‚â§ ‚Äñz‚Äñ * ‚Äñexp x‚Äñ + ‚Äñexp x‚Äñ * ‚Äñz‚Äñ ^ 2 := by\n    intro z hz\n    have : ‚Äñexp (x + z) - exp x - z ‚Ä¢ exp x‚Äñ ‚â§ ‚Äñexp x‚Äñ * ‚Äñz‚Äñ ^ 2 := exp_bound_sq x z hz\n    rw [‚Üê sub_le_iff_le_add', ‚Üê norm_smul z]\n    exact (norm_sub_norm_le _ _).trans this\n  calc\n    ‚Äñexp y - exp x‚Äñ = ‚Äñexp (x + (y - x)) - exp x‚Äñ := by nth_rw 1 [hy_eq]\n    _ ‚â§ ‚Äñy - x‚Äñ * ‚Äñexp x‚Äñ + ‚Äñexp x‚Äñ * ‚Äñy - x‚Äñ ^ 2 := h_sq (y - x) (hyx.le.trans hr_le)\n    _ ‚â§ ‚Äñy - x‚Äñ * ‚Äñexp x‚Äñ + ‚Äñexp x‚Äñ * (r * ‚Äñy - x‚Äñ) :=\n      (add_le_add_left (mul_le_mul le_rfl hyx_sq_le (sq_nonneg _) (norm_nonneg _)) _)\n    _ = (1 + r) * ‚Äñexp x‚Äñ * ‚Äñy - x‚Äñ := by ring\n\n-- Porting note: proof by term mode `locally_lipschitz_exp zero_le_one le_rfl x`\n-- doesn't work because `‚Äñy - x‚Äñ` and `dist y x` don't unify\n"}
{"name":"Complex.continuous_exp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Continuous Complex.exp","decl":"@[continuity]\ntheorem continuous_exp : Continuous exp :=\n  continuous_iff_continuousAt.mpr fun x =>\n    continuousAt_of_locally_lipschitz zero_lt_one (2 * ‚Äñexp x‚Äñ)\n      (fun y ‚Ü¶ by\n        convert locally_lipschitz_exp zero_le_one le_rfl x y using 2\n        congr\n        ring)\n\n"}
{"name":"Complex.continuousOn_exp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"s : Set Complex\n‚ä¢ ContinuousOn Complex.exp s","decl":"theorem continuousOn_exp {s : Set ‚ÑÇ} : ContinuousOn exp s :=\n  continuous_exp.continuousOn\n\n"}
{"name":"Complex.exp_sub_sum_range_isBigO_pow","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"n : Nat\n‚ä¢ Asymptotics.IsBigO (nhds 0) (fun x => HSub.hSub (Complex.exp x) ((Finset.range n).sum fun i => HDiv.hDiv (HPow.hPow x i) ‚Üëi.factorial)) fun x => HPow.hPow x n","decl":"lemma exp_sub_sum_range_isBigO_pow (n : ‚Ñï) :\n    (fun x ‚Ü¶ exp x - ‚àë i ‚àà Finset.range n, x ^ i / i !) =O[ùìù 0] (¬∑ ^ n) := by\n  rcases (zero_le n).eq_or_lt with rfl | hn\n  ¬∑ simpa using continuous_exp.continuousAt.norm.isBoundedUnder_le\n  ¬∑ refine .of_bound (n.succ / (n ! * n)) ?_\n    rw [NormedAddCommGroup.nhds_zero_basis_norm_lt.eventually_iff]\n    refine ‚ü®1, one_pos, fun x hx ‚Ü¶ ?_‚ü©\n    convert exp_bound hx.out.le hn using 1\n    field_simp [mul_comm]\n\n"}
{"name":"Complex.exp_sub_sum_range_succ_isLittleO_pow","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"n : Nat\n‚ä¢ Asymptotics.IsLittleO (nhds 0) (fun x => HSub.hSub (Complex.exp x) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HDiv.hDiv (HPow.hPow x i) ‚Üëi.factorial)) fun x => HPow.hPow x n","decl":"lemma exp_sub_sum_range_succ_isLittleO_pow (n : ‚Ñï) :\n    (fun x ‚Ü¶ exp x - ‚àë i ‚àà Finset.range (n + 1), x ^ i / i !) =o[ùìù 0] (¬∑ ^ n) :=\n  (exp_sub_sum_range_isBigO_pow (n + 1)).trans_isLittleO <| isLittleO_pow_pow n.lt_succ_self\n\n"}
{"name":"Filter.Tendsto.cexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Complex\nz : Complex\nhf : Filter.Tendsto f l (nhds z)\n‚ä¢ Filter.Tendsto (fun x => Complex.exp (f x)) l (nhds (Complex.exp z))","decl":"theorem Filter.Tendsto.cexp {l : Filter Œ±} {f : Œ± ‚Üí ‚ÑÇ} {z : ‚ÑÇ} (hf : Tendsto f l (ùìù z)) :\n    Tendsto (fun x => exp (f x)) l (ùìù (exp z)) :=\n  (continuous_exp.tendsto _).comp hf\n\n"}
{"name":"ContinuousWithinAt.cexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\ns : Set Œ±\nx : Œ±\nh : ContinuousWithinAt f s x\n‚ä¢ ContinuousWithinAt (fun y => Complex.exp (f y)) s x","decl":"nonrec\ntheorem ContinuousWithinAt.cexp (h : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun y => exp (f y)) s x :=\n  h.cexp\n\n"}
{"name":"ContinuousAt.cexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\nx : Œ±\nh : ContinuousAt f x\n‚ä¢ ContinuousAt (fun y => Complex.exp (f y)) x","decl":"@[fun_prop]\nnonrec\ntheorem ContinuousAt.cexp (h : ContinuousAt f x) : ContinuousAt (fun y => exp (f y)) x :=\n  h.cexp\n\n"}
{"name":"ContinuousOn.cexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\ns : Set Œ±\nh : ContinuousOn f s\n‚ä¢ ContinuousOn (fun y => Complex.exp (f y)) s","decl":"@[fun_prop]\ntheorem ContinuousOn.cexp (h : ContinuousOn f s) : ContinuousOn (fun y => exp (f y)) s :=\n  fun x hx => (h x hx).cexp\n\n"}
{"name":"Continuous.cexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\nh : Continuous f\n‚ä¢ Continuous fun y => Complex.exp (f y)","decl":"@[fun_prop]\ntheorem Continuous.cexp (h : Continuous f) : Continuous fun y => exp (f y) :=\n  continuous_iff_continuousAt.2 fun _ => h.continuousAt.cexp\n\n"}
{"name":"UniformlyContinuousOn.cexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"a : Real\n‚ä¢ UniformContinuousOn Complex.exp (setOf fun x => LE.le x.re a)","decl":"/-- The complex exponential function is uniformly continuous on left half planes. -/\nlemma UniformlyContinuousOn.cexp (a : ‚Ñù) : UniformContinuousOn exp {x : ‚ÑÇ | x.re ‚â§ a} := by\n  have : Continuous (cexp - 1) := Continuous.sub (Continuous.cexp continuous_id') continuous_one\n  rw [Metric.uniformContinuousOn_iff, Metric.continuous_iff'] at *\n  intro Œµ hŒµ\n  simp only [gt_iff_lt, Pi.sub_apply, Pi.one_apply, dist_sub_eq_dist_add_right,\n    sub_add_cancel] at this\n  have ha : 0 < Œµ / (2 * Real.exp a) := by positivity\n  have H := this 0 (Œµ / (2 * Real.exp a)) ha\n  rw [Metric.eventually_nhds_iff] at H\n  obtain ‚ü®Œ¥, hŒ¥‚ü© := H\n  refine ‚ü®Œ¥, hŒ¥.1, ?_‚ü©\n  intros x _ y hy hxy\n  have h3 := hŒ¥.2 (y := x - y) (by simpa only [dist_zero_right, norm_eq_abs] using hxy)\n  rw [dist_eq_norm, exp_zero] at *\n  have : cexp x - cexp y = cexp y * (cexp (x - y) - 1) := by\n      rw [mul_sub_one, ‚Üê exp_add]\n      ring_nf\n  rw [this, mul_comm]\n  have hya : ‚Äñcexp y‚Äñ ‚â§ Real.exp a := by\n    simp only [norm_eq_abs, abs_exp, Real.exp_le_exp]\n    exact hy\n  simp only [gt_iff_lt, dist_zero_right, norm_eq_abs, Set.mem_setOf_eq, norm_mul,\n    Complex.abs_exp] at *\n  apply lt_of_le_of_lt (mul_le_mul h3.le hya (Real.exp_nonneg y.re) (le_of_lt ha))\n  have hrr : Œµ / (2 * a.exp) * a.exp = Œµ / 2 := by\n    nth_rw 2 [mul_comm]\n    field_simp [mul_assoc]\n  rw [hrr]\n  exact div_two_lt_of_pos hŒµ\n\n"}
{"name":"Real.continuous_exp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Continuous Real.exp","decl":"@[continuity]\ntheorem continuous_exp : Continuous exp :=\n  Complex.continuous_re.comp Complex.continuous_ofReal.cexp\n\n"}
{"name":"Real.continuousOn_exp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"s : Set Real\n‚ä¢ ContinuousOn Real.exp s","decl":"theorem continuousOn_exp {s : Set ‚Ñù} : ContinuousOn exp s :=\n  continuous_exp.continuousOn\n\n"}
{"name":"Real.exp_sub_sum_range_isBigO_pow","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"n : Nat\n‚ä¢ Asymptotics.IsBigO (nhds 0) (fun x => HSub.hSub (Real.exp x) ((Finset.range n).sum fun i => HDiv.hDiv (HPow.hPow x i) ‚Üëi.factorial)) fun x => HPow.hPow x n","decl":"lemma exp_sub_sum_range_isBigO_pow (n : ‚Ñï) :\n    (fun x ‚Ü¶ exp x - ‚àë i ‚àà Finset.range n, x ^ i / i !) =O[ùìù 0] (¬∑ ^ n) := by\n  have := (Complex.exp_sub_sum_range_isBigO_pow n).comp_tendsto\n    (Complex.continuous_ofReal.tendsto' 0 0 rfl)\n  simp only [Function.comp_def] at this\n  norm_cast at this\n\n"}
{"name":"Real.exp_sub_sum_range_succ_isLittleO_pow","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"n : Nat\n‚ä¢ Asymptotics.IsLittleO (nhds 0) (fun x => HSub.hSub (Real.exp x) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HDiv.hDiv (HPow.hPow x i) ‚Üëi.factorial)) fun x => HPow.hPow x n","decl":"lemma exp_sub_sum_range_succ_isLittleO_pow (n : ‚Ñï) :\n    (fun x ‚Ü¶ exp x - ‚àë i ‚àà Finset.range (n + 1), x ^ i / i !) =o[ùìù 0] (¬∑ ^ n) :=\n  (exp_sub_sum_range_isBigO_pow (n + 1)).trans_isLittleO <| isLittleO_pow_pow n.lt_succ_self\n\n"}
{"name":"Filter.Tendsto.rexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\nz : Real\nhf : Filter.Tendsto f l (nhds z)\n‚ä¢ Filter.Tendsto (fun x => Real.exp (f x)) l (nhds (Real.exp z))","decl":"theorem Filter.Tendsto.rexp {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù} {z : ‚Ñù} (hf : Tendsto f l (ùìù z)) :\n    Tendsto (fun x => exp (f x)) l (ùìù (exp z)) :=\n  (continuous_exp.tendsto _).comp hf\n\n"}
{"name":"ContinuousWithinAt.rexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\ns : Set Œ±\nx : Œ±\nh : ContinuousWithinAt f s x\n‚ä¢ ContinuousWithinAt (fun y => Real.exp (f y)) s x","decl":"nonrec\ntheorem ContinuousWithinAt.rexp (h : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun y ‚Ü¶ exp (f y)) s x :=\n  h.rexp\n"}
{"name":"ContinuousAt.rexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\nx : Œ±\nh : ContinuousAt f x\n‚ä¢ ContinuousAt (fun y => Real.exp (f y)) x","decl":"@[fun_prop]\nnonrec\ntheorem ContinuousAt.rexp (h : ContinuousAt f x) : ContinuousAt (fun y ‚Ü¶ exp (f y)) x :=\n  h.rexp\n"}
{"name":"ContinuousOn.rexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\ns : Set Œ±\nh : ContinuousOn f s\n‚ä¢ ContinuousOn (fun y => Real.exp (f y)) s","decl":"@[fun_prop]\ntheorem ContinuousOn.rexp (h : ContinuousOn f s) :\n    ContinuousOn (fun y ‚Ü¶ exp (f y)) s :=\n  fun x hx ‚Ü¶ (h x hx).rexp\n"}
{"name":"Continuous.rexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\nh : Continuous f\n‚ä¢ Continuous fun y => Real.exp (f y)","decl":"@[fun_prop]\ntheorem Continuous.rexp (h : Continuous f) : Continuous fun y ‚Ü¶ exp (f y) :=\n  continuous_iff_continuousAt.2 fun _ ‚Ü¶ h.continuousAt.rexp\n"}
{"name":"Real.exp_half","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"x : Real\n‚ä¢ Eq (Real.exp (HDiv.hDiv x 2)) (Real.exp x).sqrt","decl":"theorem exp_half (x : ‚Ñù) : exp (x / 2) = ‚àö(exp x) := by\n  rw [eq_comm, sqrt_eq_iff_eq_sq, sq, ‚Üê exp_add, add_halves] <;> exact (exp_pos _).le\n\n"}
{"name":"Real.tendsto_exp_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto Real.exp Filter.atTop Filter.atTop","decl":"/-- The real exponential function tends to `+‚àû` at `+‚àû`. -/\ntheorem tendsto_exp_atTop : Tendsto exp atTop atTop := by\n  have A : Tendsto (fun x : ‚Ñù => x + 1) atTop atTop :=\n    tendsto_atTop_add_const_right atTop 1 tendsto_id\n  have B : ‚àÄ·∂† x in atTop, x + 1 ‚â§ exp x := eventually_atTop.2 ‚ü®0, fun x _ => add_one_le_exp x‚ü©\n  exact tendsto_atTop_mono' atTop B A\n\n"}
{"name":"Real.tendsto_exp_neg_atTop_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto (fun x => Real.exp (Neg.neg x)) Filter.atTop (nhds 0)","decl":"/-- The real exponential function tends to `0` at `-‚àû` or, equivalently, `exp(-x)` tends to `0`\nat `+‚àû` -/\ntheorem tendsto_exp_neg_atTop_nhds_zero : Tendsto (fun x => exp (-x)) atTop (ùìù 0) :=\n  (tendsto_inv_atTop_zero.comp tendsto_exp_atTop).congr fun x => (exp_neg x).symm\n\n"}
{"name":"Real.tendsto_exp_nhds_zero_nhds_one","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto Real.exp (nhds 0) (nhds 1)","decl":"/-- The real exponential function tends to `1` at `0`. -/\ntheorem tendsto_exp_nhds_zero_nhds_one : Tendsto exp (ùìù 0) (ùìù 1) := by\n  convert continuous_exp.tendsto 0\n  simp\n\n"}
{"name":"Real.tendsto_exp_atBot","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto Real.exp Filter.atBot (nhds 0)","decl":"theorem tendsto_exp_atBot : Tendsto exp atBot (ùìù 0) :=\n  (tendsto_exp_neg_atTop_nhds_zero.comp tendsto_neg_atBot_atTop).congr fun x =>\n    congr_arg exp <| neg_neg x\n\n"}
{"name":"Real.tendsto_exp_atBot_nhdsGT","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto Real.exp Filter.atBot (nhdsWithin 0 (Set.Ioi 0))","decl":"theorem tendsto_exp_atBot_nhdsGT : Tendsto exp atBot (ùìù[>] 0) :=\n  tendsto_inf.2 ‚ü®tendsto_exp_atBot, tendsto_principal.2 <| Eventually.of_forall exp_pos‚ü©\n\n"}
{"name":"Real.tendsto_exp_atBot_nhdsWithin","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto Real.exp Filter.atBot (nhdsWithin 0 (Set.Ioi 0))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_exp_atBot_nhdsWithin := tendsto_exp_atBot_nhdsGT\n\n"}
{"name":"Real.isBoundedUnder_ge_exp_comp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l fun x => Real.exp (f x)","decl":"@[simp]\ntheorem isBoundedUnder_ge_exp_comp (l : Filter Œ±) (f : Œ± ‚Üí ‚Ñù) :\n    IsBoundedUnder (¬∑ ‚â• ¬∑) l fun x => exp (f x) :=\n  isBoundedUnder_of ‚ü®0, fun _ => (exp_pos _).le‚ü©\n\n"}
{"name":"Real.isBoundedUnder_le_exp_comp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Real.exp (f x)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l f)","decl":"@[simp]\ntheorem isBoundedUnder_le_exp_comp {f : Œ± ‚Üí ‚Ñù} :\n    (IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun x => exp (f x)) ‚Üî IsBoundedUnder (¬∑ ‚â§ ¬∑) l f :=\n  exp_monotone.isBoundedUnder_le_comp_iff tendsto_exp_atTop\n\n"}
{"name":"Real.tendsto_exp_div_pow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"n : Nat\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (Real.exp x) (HPow.hPow x n)) Filter.atTop Filter.atTop","decl":"/-- The function `exp(x)/x^n` tends to `+‚àû` at `+‚àû`, for any natural number `n` -/\ntheorem tendsto_exp_div_pow_atTop (n : ‚Ñï) : Tendsto (fun x => exp x / x ^ n) atTop atTop := by\n  refine (atTop_basis_Ioi.tendsto_iff (atTop_basis' 1)).2 fun C hC‚ÇÅ => ?_\n  have hC‚ÇÄ : 0 < C := zero_lt_one.trans_le hC‚ÇÅ\n  have : 0 < (exp 1 * C)‚Åª¬π := inv_pos.2 (mul_pos (exp_pos _) hC‚ÇÄ)\n  obtain ‚ü®N, hN‚ü© : ‚àÉ N : ‚Ñï, ‚àÄ k ‚â• N, (‚Üëk : ‚Ñù) ^ n / exp 1 ^ k < (exp 1 * C)‚Åª¬π :=\n    eventually_atTop.1\n      ((tendsto_pow_const_div_const_pow_of_one_lt n (one_lt_exp_iff.2 zero_lt_one)).eventually\n        (gt_mem_nhds this))\n  simp only [‚Üê exp_nat_mul, mul_one, div_lt_iff‚ÇÄ, exp_pos, ‚Üê div_eq_inv_mul] at hN\n  refine ‚ü®N, trivial, fun x hx => ?_‚ü©\n  rw [Set.mem_Ioi] at hx\n  have hx‚ÇÄ : 0 < x := (Nat.cast_nonneg N).trans_lt hx\n  rw [Set.mem_Ici, le_div_iff‚ÇÄ (pow_pos hx‚ÇÄ _), ‚Üê le_div_iff‚ÇÄ' hC‚ÇÄ]\n  calc\n    x ^ n ‚â§ ‚åàx‚åâ‚Çä ^ n := by gcongr; exact Nat.le_ceil _\n    _ ‚â§ exp ‚åàx‚åâ‚Çä / (exp 1 * C) := mod_cast (hN _ (Nat.lt_ceil.2 hx).le).le\n    _ ‚â§ exp (x + 1) / (exp 1 * C) := by gcongr; exact (Nat.ceil_lt_add_one hx‚ÇÄ.le).le\n    _ = exp x / C := by rw [add_comm, exp_add, mul_div_mul_left _ _ (exp_pos _).ne']\n\n"}
{"name":"Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"n : Nat\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul (HPow.hPow x n) (Real.exp (Neg.neg x))) Filter.atTop (nhds 0)","decl":"/-- The function `x^n * exp(-x)` tends to `0` at `+‚àû`, for any natural number `n`. -/\ntheorem tendsto_pow_mul_exp_neg_atTop_nhds_zero (n : ‚Ñï) :\n    Tendsto (fun x => x ^ n * exp (-x)) atTop (ùìù 0) :=\n  (tendsto_inv_atTop_zero.comp (tendsto_exp_div_pow_atTop n)).congr fun x => by\n    rw [comp_apply, inv_eq_one_div, div_div_eq_mul_div, one_mul, div_eq_mul_inv, exp_neg]\n\n"}
{"name":"Real.tendsto_mul_exp_add_div_pow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"b c : Real\nn : Nat\nhb : LT.lt 0 b\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (HAdd.hAdd (HMul.hMul b (Real.exp x)) c) (HPow.hPow x n)) Filter.atTop Filter.atTop","decl":"/-- The function `(b * exp x + c) / (x ^ n)` tends to `+‚àû` at `+‚àû`, for any natural number\n`n` and any real numbers `b` and `c` such that `b` is positive. -/\ntheorem tendsto_mul_exp_add_div_pow_atTop (b c : ‚Ñù) (n : ‚Ñï) (hb : 0 < b) :\n    Tendsto (fun x => (b * exp x + c) / x ^ n) atTop atTop := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  ¬∑ simp only [pow_zero, div_one]\n    exact (tendsto_exp_atTop.const_mul_atTop hb).atTop_add tendsto_const_nhds\n  simp only [add_div, mul_div_assoc]\n  exact\n    ((tendsto_exp_div_pow_atTop n).const_mul_atTop hb).atTop_add\n      (tendsto_const_nhds.div_atTop (tendsto_pow_atTop hn))\n\n"}
{"name":"Real.tendsto_div_pow_mul_exp_add_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"b c : Real\nn : Nat\nhb : Ne 0 b\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (HPow.hPow x n) (HAdd.hAdd (HMul.hMul b (Real.exp x)) c)) Filter.atTop (nhds 0)","decl":"/-- The function `(x ^ n) / (b * exp x + c)` tends to `0` at `+‚àû`, for any natural number\n`n` and any real numbers `b` and `c` such that `b` is nonzero. -/\ntheorem tendsto_div_pow_mul_exp_add_atTop (b c : ‚Ñù) (n : ‚Ñï) (hb : 0 ‚â† b) :\n    Tendsto (fun x => x ^ n / (b * exp x + c)) atTop (ùìù 0) := by\n  have H : ‚àÄ d e, 0 < d ‚Üí Tendsto (fun x : ‚Ñù => x ^ n / (d * exp x + e)) atTop (ùìù 0) := by\n    intro b' c' h\n    convert (tendsto_mul_exp_add_div_pow_atTop b' c' n h).inv_tendsto_atTop using 1\n    ext x\n    simp\n  cases' lt_or_gt_of_ne hb with h h\n  ¬∑ exact H b c h\n  ¬∑ convert (H (-b) (-c) (neg_pos.mpr h)).neg using 1\n    ¬∑ ext x\n      field_simp\n      rw [‚Üê neg_add (b * exp x) c, neg_div_neg_eq]\n    ¬∑ rw [neg_zero]\n\n"}
{"name":"Real.coe_expOrderIso_apply","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"x : Real\n‚ä¢ Eq (‚Üë(Real.expOrderIso x)) (Real.exp x)","decl":"@[simp]\ntheorem coe_expOrderIso_apply (x : ‚Ñù) : (expOrderIso x : ‚Ñù) = exp x :=\n  rfl\n\n"}
{"name":"Real.coe_comp_expOrderIso","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Function.comp Subtype.val ‚áëReal.expOrderIso) Real.exp","decl":"@[simp]\ntheorem coe_comp_expOrderIso : (‚Üë) ‚àò expOrderIso = exp :=\n  rfl\n\n"}
{"name":"Real.range_exp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Set.range Real.exp) (Set.Ioi 0)","decl":"@[simp]\ntheorem range_exp : range exp = Set.Ioi 0 := by\n  rw [‚Üê coe_comp_expOrderIso, range_comp, expOrderIso.range_eq, image_univ, Subtype.range_coe]\n\n"}
{"name":"Real.map_exp_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.map Real.exp Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem map_exp_atTop : map exp atTop = atTop := by\n  rw [‚Üê coe_comp_expOrderIso, ‚Üê Filter.map_map, OrderIso.map_atTop, map_val_Ioi_atTop]\n\n"}
{"name":"Real.comap_exp_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.comap Real.exp Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem comap_exp_atTop : comap exp atTop = atTop := by\n  rw [‚Üê map_exp_atTop, comap_map exp_injective, map_exp_atTop]\n\n"}
{"name":"Real.tendsto_exp_comp_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Filter.Tendsto (fun x => Real.exp (f x)) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"@[simp]\ntheorem tendsto_exp_comp_atTop {f : Œ± ‚Üí ‚Ñù} :\n    Tendsto (fun x => exp (f x)) l atTop ‚Üî Tendsto f l atTop := by\n  simp_rw [‚Üê comp_apply (f := exp), ‚Üê tendsto_comap_iff, comap_exp_atTop]\n\n"}
{"name":"Real.tendsto_comp_exp_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Real ‚Üí Œ±\n‚ä¢ Iff (Filter.Tendsto (fun x => f (Real.exp x)) Filter.atTop l) (Filter.Tendsto f Filter.atTop l)","decl":"theorem tendsto_comp_exp_atTop {f : ‚Ñù ‚Üí Œ±} :\n    Tendsto (fun x => f (exp x)) atTop l ‚Üî Tendsto f atTop l := by\n  simp_rw [‚Üê comp_apply (g := exp), ‚Üê tendsto_map'_iff, map_exp_atTop]\n\n"}
{"name":"Real.map_exp_atBot","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.map Real.exp Filter.atBot) (nhdsWithin 0 (Set.Ioi 0))","decl":"@[simp]\ntheorem map_exp_atBot : map exp atBot = ùìù[>] 0 := by\n  rw [‚Üê coe_comp_expOrderIso, ‚Üê Filter.map_map, expOrderIso.map_atBot, ‚Üê map_coe_Ioi_atBot]\n\n"}
{"name":"Real.comap_exp_nhdsGT_zero","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.comap Real.exp (nhdsWithin 0 (Set.Ioi 0))) Filter.atBot","decl":"@[simp]\ntheorem comap_exp_nhdsGT_zero : comap exp (ùìù[>] 0) = atBot := by\n  rw [‚Üê map_exp_atBot, comap_map exp_injective]\n\n"}
{"name":"Real.comap_exp_nhdsWithin_Ioi_zero","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.comap Real.exp (nhdsWithin 0 (Set.Ioi 0))) Filter.atBot","decl":"@[deprecated (since := \"2024-12-22\")]\nalias comap_exp_nhdsWithin_Ioi_zero := comap_exp_nhdsGT_zero\n\n"}
{"name":"Real.tendsto_comp_exp_atBot","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Real ‚Üí Œ±\n‚ä¢ Iff (Filter.Tendsto (fun x => f (Real.exp x)) Filter.atBot l) (Filter.Tendsto f (nhdsWithin 0 (Set.Ioi 0)) l)","decl":"theorem tendsto_comp_exp_atBot {f : ‚Ñù ‚Üí Œ±} :\n    Tendsto (fun x => f (exp x)) atBot l ‚Üî Tendsto f (ùìù[>] 0) l := by\n  rw [‚Üê map_exp_atBot, tendsto_map'_iff]\n  rfl\n\n"}
{"name":"Real.comap_exp_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.comap Real.exp (nhds 0)) Filter.atBot","decl":"@[simp]\ntheorem comap_exp_nhds_zero : comap exp (ùìù 0) = atBot :=\n  (comap_nhdsWithin_range exp 0).symm.trans <| by simp\n\n"}
{"name":"Real.tendsto_exp_comp_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Filter.Tendsto (fun x => Real.exp (f x)) l (nhds 0)) (Filter.Tendsto f l Filter.atBot)","decl":"@[simp]\ntheorem tendsto_exp_comp_nhds_zero {f : Œ± ‚Üí ‚Ñù} :\n    Tendsto (fun x => exp (f x)) l (ùìù 0) ‚Üî Tendsto f l atBot := by\n  simp_rw [‚Üê comp_apply (f := exp), ‚Üê tendsto_comap_iff, comap_exp_nhds_zero]\n\n"}
{"name":"Real.isOpenEmbedding_exp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Topology.IsOpenEmbedding Real.exp","decl":"theorem isOpenEmbedding_exp : IsOpenEmbedding exp :=\n  isOpen_Ioi.isOpenEmbedding_subtypeVal.comp expOrderIso.toHomeomorph.isOpenEmbedding\n\n"}
{"name":"Real.openEmbedding_exp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Topology.IsOpenEmbedding Real.exp","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_exp := isOpenEmbedding_exp\n\n"}
{"name":"Real.map_exp_nhds","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"x : Real\n‚ä¢ Eq (Filter.map Real.exp (nhds x)) (nhds (Real.exp x))","decl":"@[simp]\ntheorem map_exp_nhds (x : ‚Ñù) : map exp (ùìù x) = ùìù (exp x) :=\n  isOpenEmbedding_exp.map_nhds_eq x\n\n"}
{"name":"Real.comap_exp_nhds_exp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"x : Real\n‚ä¢ Eq (Filter.comap Real.exp (nhds (Real.exp x))) (nhds x)","decl":"@[simp]\ntheorem comap_exp_nhds_exp (x : ‚Ñù) : comap exp (ùìù (exp x)) = ùìù x :=\n  (isOpenEmbedding_exp.nhds_eq_comap x).symm\n\n"}
{"name":"Real.isLittleO_pow_exp_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"n : Nat\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow x n) Real.exp","decl":"theorem isLittleO_pow_exp_atTop {n : ‚Ñï} : (fun x : ‚Ñù => x ^ n) =o[atTop] Real.exp := by\n  simpa [isLittleO_iff_tendsto fun x hx => ((exp_pos x).ne' hx).elim] using\n    tendsto_div_pow_mul_exp_add_atTop 1 0 n zero_ne_one\n\n"}
{"name":"Real.isBigO_exp_comp_exp_comp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Real\n‚ä¢ Iff (Asymptotics.IsBigO l (fun x => Real.exp (f x)) fun x => Real.exp (g x)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (HSub.hSub f g))","decl":"@[simp]\ntheorem isBigO_exp_comp_exp_comp {f g : Œ± ‚Üí ‚Ñù} :\n    ((fun x => exp (f x)) =O[l] fun x => exp (g x)) ‚Üî IsBoundedUnder (¬∑ ‚â§ ¬∑) l (f - g) :=\n  Iff.trans (isBigO_iff_isBoundedUnder_le_div <| Eventually.of_forall fun _ => exp_ne_zero _) <| by\n    simp only [norm_eq_abs, abs_exp, ‚Üê exp_sub, isBoundedUnder_le_exp_comp, Pi.sub_def]\n\n"}
{"name":"Real.isTheta_exp_comp_exp_comp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Real\n‚ä¢ Iff (Asymptotics.IsTheta l (fun x => Real.exp (f x)) fun x => Real.exp (g x)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => abs (HSub.hSub (f x) (g x)))","decl":"@[simp]\ntheorem isTheta_exp_comp_exp_comp {f g : Œ± ‚Üí ‚Ñù} :\n    ((fun x => exp (f x)) =Œò[l] fun x => exp (g x)) ‚Üî\n      IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun x => |f x - g x| := by\n  simp only [isBoundedUnder_le_abs, ‚Üê isBoundedUnder_le_neg, neg_sub, IsTheta,\n    isBigO_exp_comp_exp_comp, Pi.sub_def]\n\n"}
{"name":"Real.isLittleO_exp_comp_exp_comp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Real\n‚ä¢ Iff (Asymptotics.IsLittleO l (fun x => Real.exp (f x)) fun x => Real.exp (g x)) (Filter.Tendsto (fun x => HSub.hSub (g x) (f x)) l Filter.atTop)","decl":"@[simp]\ntheorem isLittleO_exp_comp_exp_comp {f g : Œ± ‚Üí ‚Ñù} :\n    ((fun x => exp (f x)) =o[l] fun x => exp (g x)) ‚Üî Tendsto (fun x => g x - f x) l atTop := by\n  simp only [isLittleO_iff_tendsto, exp_ne_zero, ‚Üê exp_sub, ‚Üê tendsto_neg_atTop_iff, false_imp_iff,\n    imp_true_iff, tendsto_exp_comp_nhds_zero, neg_sub]\n\n"}
{"name":"Real.isLittleO_one_exp_comp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Asymptotics.IsLittleO l (fun x => 1) fun x => Real.exp (f x)) (Filter.Tendsto f l Filter.atTop)","decl":"theorem isLittleO_one_exp_comp {f : Œ± ‚Üí ‚Ñù} :\n    ((fun _ => 1 : Œ± ‚Üí ‚Ñù) =o[l] fun x => exp (f x)) ‚Üî Tendsto f l atTop := by\n  simp only [‚Üê exp_zero, isLittleO_exp_comp_exp_comp, sub_zero]\n\n"}
{"name":"Real.isBigO_one_exp_comp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Asymptotics.IsBigO l (fun x => 1) fun x => Real.exp (f x)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l f)","decl":"/-- `Real.exp (f x)` is bounded away from zero along a filter if and only if this filter is bounded\nfrom below under `f`. -/\n@[simp]\ntheorem isBigO_one_exp_comp {f : Œ± ‚Üí ‚Ñù} :\n    ((fun _ => 1 : Œ± ‚Üí ‚Ñù) =O[l] fun x => exp (f x)) ‚Üî IsBoundedUnder (¬∑ ‚â• ¬∑) l f := by\n  simp only [‚Üê exp_zero, isBigO_exp_comp_exp_comp, Pi.sub_def, zero_sub, isBoundedUnder_le_neg]\n\n"}
{"name":"Real.isBigO_exp_comp_one","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Asymptotics.IsBigO l (fun x => Real.exp (f x)) fun x => 1) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l f)","decl":"/-- `Real.exp (f x)` is bounded away from zero along a filter if and only if this filter is bounded\nfrom below under `f`. -/\ntheorem isBigO_exp_comp_one {f : Œ± ‚Üí ‚Ñù} :\n    (fun x => exp (f x)) =O[l] (fun _ => 1 : Œ± ‚Üí ‚Ñù) ‚Üî IsBoundedUnder (¬∑ ‚â§ ¬∑) l f := by\n  simp only [isBigO_one_iff, norm_eq_abs, abs_exp, isBoundedUnder_le_exp_comp]\n\n"}
{"name":"Real.isTheta_exp_comp_one","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Asymptotics.IsTheta l (fun x => Real.exp (f x)) fun x => 1) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => abs (f x))","decl":"/-- `Real.exp (f x)` is bounded away from zero and infinity along a filter `l` if and only if\n`|f x|` is bounded from above along this filter. -/\n@[simp]\ntheorem isTheta_exp_comp_one {f : Œ± ‚Üí ‚Ñù} :\n    (fun x => exp (f x)) =Œò[l] (fun _ => 1 : Œ± ‚Üí ‚Ñù) ‚Üî IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun x => |f x| := by\n  simp only [‚Üê exp_zero, isTheta_exp_comp_exp_comp, sub_zero]\n\n"}
{"name":"Real.summable_exp_nat_mul_iff","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"a : Real\n‚ä¢ Iff (Summable fun n => Real.exp (HMul.hMul (‚Üën) a)) (LT.lt a 0)","decl":"lemma summable_exp_nat_mul_iff {a : ‚Ñù} :\n    Summable (fun n : ‚Ñï ‚Ü¶ exp (n * a)) ‚Üî a < 0 := by\n  simp only [exp_nat_mul, summable_geometric_iff_norm_lt_one, norm_of_nonneg (exp_nonneg _),\n    exp_lt_one_iff]\n\n"}
{"name":"Real.summable_exp_neg_nat","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Summable fun n => Real.exp (Neg.neg ‚Üën)","decl":"lemma summable_exp_neg_nat : Summable fun n : ‚Ñï ‚Ü¶ exp (-n) := by\n  simpa only [mul_neg_one] using summable_exp_nat_mul_iff.mpr neg_one_lt_zero\n\n"}
{"name":"Real.summable_pow_mul_exp_neg_nat_mul","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"k : Nat\nr : Real\nhr : LT.lt 0 r\n‚ä¢ Summable fun n => HMul.hMul (HPow.hPow (‚Üën) k) (Real.exp (HMul.hMul (Neg.neg r) ‚Üën))","decl":"lemma summable_pow_mul_exp_neg_nat_mul (k : ‚Ñï) {r : ‚Ñù} (hr : 0 < r) :\n    Summable fun n : ‚Ñï ‚Ü¶ n ^ k * exp (-r * n) := by\n  simp_rw [mul_comm (-r), exp_nat_mul]\n  apply summable_pow_mul_geometric_of_norm_lt_one\n  rwa [norm_of_nonneg (exp_nonneg _), exp_lt_one_iff, neg_lt_zero]\n\n"}
{"name":"HasSum.rexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œπ : Type u_1\nf : Œπ ‚Üí Real\na : Real\nh : HasSum f a\n‚ä¢ HasProd (Function.comp Real.exp f) (Real.exp a)","decl":"open Real in\n/-- If `f` has sum `a`, then `exp ‚àò f` has product `exp a`. -/\nlemma HasSum.rexp {Œπ} {f : Œπ ‚Üí ‚Ñù} {a : ‚Ñù} (h : HasSum f a) : HasProd (rexp ‚àò f) (rexp a) :=\n  Tendsto.congr (fun s ‚Ü¶ exp_sum s f) <| Tendsto.rexp h\n\n"}
{"name":"Complex.comap_exp_cobounded","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.comap Complex.exp (Bornology.cobounded Complex)) (Filter.comap Complex.re Filter.atTop)","decl":"@[simp]\ntheorem comap_exp_cobounded : comap exp (cobounded ‚ÑÇ) = comap re atTop :=\n  calc\n    comap exp (cobounded ‚ÑÇ) = comap re (comap Real.exp atTop) := by\n      simp only [‚Üê comap_norm_atTop, Complex.norm_eq_abs, comap_comap, Function.comp_def, abs_exp]\n    _ = comap re atTop := by rw [Real.comap_exp_atTop]\n\n"}
{"name":"Complex.comap_exp_nhds_zero","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.comap Complex.exp (nhds 0)) (Filter.comap Complex.re Filter.atBot)","decl":"@[simp]\ntheorem comap_exp_nhds_zero : comap exp (ùìù 0) = comap re atBot :=\n  calc\n    comap exp (ùìù 0) = comap re (comap Real.exp (ùìù 0)) := by\n      simp only [comap_comap, ‚Üê comap_abs_nhds_zero, Function.comp_def, abs_exp]\n    _ = comap re atBot := by rw [Real.comap_exp_nhds_zero]\n\n"}
{"name":"Complex.comap_exp_nhdsNE","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.comap Complex.exp (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))) (Filter.comap Complex.re Filter.atBot)","decl":"theorem comap_exp_nhdsNE : comap exp (ùìù[‚â†] 0) = comap re atBot := by\n  have : (exp ‚Åª¬π' {0})·∂ú = Set.univ := eq_univ_of_forall exp_ne_zero\n  simp [nhdsWithin, comap_exp_nhds_zero, this]\n\n"}
{"name":"Complex.comap_exp_nhdsWithin_zero","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Eq (Filter.comap Complex.exp (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))) (Filter.comap Complex.re Filter.atBot)","decl":"@[deprecated (since := \"2024-12-22\")]\nalias comap_exp_nhdsWithin_zero := comap_exp_nhdsNE\n\n"}
{"name":"Complex.tendsto_exp_nhds_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Complex\n‚ä¢ Iff (Filter.Tendsto (fun x => Complex.exp (f x)) l (nhds 0)) (Filter.Tendsto (fun x => (f x).re) l Filter.atBot)","decl":"theorem tendsto_exp_nhds_zero_iff {Œ± : Type*} {l : Filter Œ±} {f : Œ± ‚Üí ‚ÑÇ} :\n    Tendsto (fun x => exp (f x)) l (ùìù 0) ‚Üî Tendsto (fun x => re (f x)) l atBot := by\n  simp_rw [‚Üê comp_apply (f := exp), ‚Üê tendsto_comap_iff, comap_exp_nhds_zero, tendsto_comap_iff]\n  rfl\n\n"}
{"name":"Complex.tendsto_exp_comap_re_atTop","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto Complex.exp (Filter.comap Complex.re Filter.atTop) (Bornology.cobounded Complex)","decl":"/-- `Complex.abs (Complex.exp z) ‚Üí ‚àû` as `Complex.re z ‚Üí ‚àû`. -/\ntheorem tendsto_exp_comap_re_atTop : Tendsto exp (comap re atTop) (cobounded ‚ÑÇ) :=\n  comap_exp_cobounded ‚ñ∏ tendsto_comap\n\n"}
{"name":"Complex.tendsto_exp_comap_re_atBot","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto Complex.exp (Filter.comap Complex.re Filter.atBot) (nhds 0)","decl":"/-- `Complex.exp z ‚Üí 0` as `Complex.re z ‚Üí -‚àû`. -/\ntheorem tendsto_exp_comap_re_atBot : Tendsto exp (comap re atBot) (ùìù 0) :=\n  comap_exp_nhds_zero ‚ñ∏ tendsto_comap\n\n"}
{"name":"Complex.tendsto_exp_comap_re_atBot_nhdsNE","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto Complex.exp (Filter.comap Complex.re Filter.atBot) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"theorem tendsto_exp_comap_re_atBot_nhdsNE : Tendsto exp (comap re atBot) (ùìù[‚â†] 0) :=\n  comap_exp_nhdsNE ‚ñ∏ tendsto_comap\n\n"}
{"name":"Complex.tendsto_exp_comap_re_atBot_nhdsWithin","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"‚ä¢ Filter.Tendsto Complex.exp (Filter.comap Complex.re Filter.atBot) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias tendsto_exp_comap_re_atBot_nhdsWithin := tendsto_exp_comap_re_atBot_nhdsNE\n\n"}
{"name":"HasSum.cexp","module":"Mathlib.Analysis.SpecialFunctions.Exp","initialProofState":"Œπ : Type u_1\nf : Œπ ‚Üí Complex\na : Complex\nh : HasSum f a\n‚ä¢ HasProd (Function.comp Complex.exp f) (Complex.exp a)","decl":"open Complex in\n/-- If `f` has sum `a`, then `exp ‚àò f` has product `exp a`. -/\nlemma HasSum.cexp {Œπ : Type*} {f : Œπ ‚Üí ‚ÑÇ} {a : ‚ÑÇ} (h : HasSum f a) : HasProd (cexp ‚àò f) (cexp a) :=\n  Filter.Tendsto.congr (fun s ‚Ü¶ exp_sum s f) <| Filter.Tendsto.cexp h\n"}
