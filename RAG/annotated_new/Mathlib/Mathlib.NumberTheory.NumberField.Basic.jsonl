{"name":"NumberField.to_finiteDimensional","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nself : NumberField K\nâŠ¢ FiniteDimensional Rat K","decl":"/-- A number field is a field which has characteristic zero and is finite\ndimensional over â„š. -/\n@[stacks 09GA]\nclass NumberField (K : Type*) [Field K] : Prop where\n  [to_charZero : CharZero K]\n  [to_finiteDimensional : FiniteDimensional â„š K]\n\n"}
{"name":"NumberField.to_charZero","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nself : NumberField K\nâŠ¢ CharZero K","decl":"/-- A number field is a field which has characteristic zero and is finite\ndimensional over â„š. -/\n@[stacks 09GA]\nclass NumberField (K : Type*) [Field K] : Prop where\n  [to_charZero : CharZero K]\n  [to_finiteDimensional : FiniteDimensional â„š K]\n\n"}
{"name":"Int.not_isField","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"âŠ¢ Not (IsField Int)","decl":"/-- `â„¤` with its usual ring structure is not a field. -/\ntheorem Int.not_isField : Â¬IsField â„¤ := fun h =>\n  Int.not_even_one <|\n    (h.mul_inv_cancel two_ne_zero).imp fun a => by rw [â† two_mul]; exact Eq.symm\n\n"}
{"name":"NumberField.isAlgebraic","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Algebra.IsAlgebraic Rat K","decl":"protected theorem isAlgebraic [NumberField K] : Algebra.IsAlgebraic â„š K :=\n  Algebra.IsAlgebraic.of_finite _ _\n\n"}
{"name":"NumberField.instFiniteDimensional","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : NumberField K\ninstâœÂ¹ : NumberField L\ninstâœ : Algebra K L\nâŠ¢ FiniteDimensional K L","decl":"instance [NumberField K] [NumberField L] [Algebra K L] : FiniteDimensional K L :=\n  Module.Finite.of_restrictScalars_finite â„š K L\n\n"}
{"name":"NumberField.of_module_finite","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : NumberField K\ninstâœÂ¹ : Algebra K L\ninstâœ : Module.Finite K L\nâŠ¢ NumberField L","decl":"/-- A finite extension of a number field is a number field. -/\ntheorem of_module_finite [NumberField K] [Algebra K L] [Module.Finite K L] : NumberField L where\n  to_charZero := charZero_of_injective_algebraMap (algebraMap K L).injective\n  to_finiteDimensional :=\n    letI := charZero_of_injective_algebraMap (algebraMap K L).injective\n    Module.Finite.trans K L\n\n"}
{"name":"NumberField.of_intermediateField","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : NumberField K\ninstâœÂ¹ : NumberField L\ninstâœ : Algebra K L\nE : IntermediateField K L\nâŠ¢ NumberField (Subtype fun x => Membership.mem E x)","decl":"variable {K} {L} in\ninstance of_intermediateField [NumberField K] [NumberField L] [Algebra K L]\n    (E : IntermediateField K L) : NumberField E :=\n  of_module_finite K E\n\n"}
{"name":"NumberField.of_tower","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninstâœâ¸ : Field K\ninstâœâ· : Field L\ninstâœâ¶ : NumberField K\ninstâœâµ : NumberField L\ninstâœâ´ : Algebra K L\nE : Type u_3\ninstâœÂ³ : Field E\ninstâœÂ² : Algebra K E\ninstâœÂ¹ : Algebra E L\ninstâœ : IsScalarTower K E L\nâŠ¢ NumberField E","decl":"theorem of_tower [NumberField K] [NumberField L] [Algebra K L] (E : Type*) [Field E]\n    [Algebra K E] [Algebra E L] [IsScalarTower K E L] : NumberField E :=\n  letI := Module.Finite.left K E L\n  of_module_finite K E\n\n"}
{"name":"NumberField.RingOfIntegers.instIsDomain","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ IsDomain (NumberField.RingOfIntegers K)","decl":"instance : IsDomain (ğ“ K) :=\n  inferInstanceAs (IsDomain (integralClosure _ _))\n"}
{"name":"NumberField.RingOfIntegers.instCharZero","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ CharZero (NumberField.RingOfIntegers K)","decl":"instance [NumberField K] : CharZero (ğ“ K) :=\n  inferInstanceAs (CharZero (integralClosure _ _))\n"}
{"name":"NumberField.RingOfIntegers.instNoZeroSMulDivisors","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ NoZeroSMulDivisors (NumberField.RingOfIntegers K) K","decl":"instance : NoZeroSMulDivisors (ğ“ K) K :=\n  inferInstanceAs (NoZeroSMulDivisors (integralClosure _ _) _)\n"}
{"name":"NumberField.RingOfIntegers.instNontrivial","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Nontrivial (NumberField.RingOfIntegers K)","decl":"instance : Nontrivial (ğ“ K) :=\n  inferInstanceAs (Nontrivial (integralClosure _ _))\n"}
{"name":"NumberField.RingOfIntegers.instIsScalarTower","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ² : Field K\nL : Type u_3\ninstâœÂ¹ : Ring L\ninstâœ : Algebra K L\nâŠ¢ IsScalarTower (NumberField.RingOfIntegers K) K L","decl":"instance {L : Type*} [Ring L] [Algebra K L] : IsScalarTower (ğ“ K) K L :=\n  inferInstanceAs (IsScalarTower (integralClosure _ _) K L)\n\n"}
{"name":"NumberField.RingOfIntegers.coe_eq_algebraMap","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : NumberField.RingOfIntegers K\nâŠ¢ Eq (â†‘x) ((algebraMap (NumberField.RingOfIntegers K) K) x)","decl":"lemma coe_eq_algebraMap (x : ğ“ K) : (x : K) = algebraMap _ _ x := rfl\n\n"}
{"name":"NumberField.RingOfIntegers.ext","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx y : NumberField.RingOfIntegers K\nh : Eq â†‘x â†‘y\nâŠ¢ Eq x y","decl":"@[ext] theorem ext {x y : ğ“ K} (h : (x : K) = (y : K)) : x = y :=\n  Subtype.ext h\n\n"}
{"name":"NumberField.RingOfIntegers.ext_iff","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx y : NumberField.RingOfIntegers K\nâŠ¢ Iff (Eq x y) (Eq â†‘x â†‘y)","decl":"@[ext] theorem ext {x y : ğ“ K} (h : (x : K) = (y : K)) : x = y :=\n  Subtype.ext h\n\n"}
{"name":"NumberField.RingOfIntegers.eq_iff","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx y : NumberField.RingOfIntegers K\nâŠ¢ Iff (Eq â†‘x â†‘y) (Eq x y)","decl":"@[norm_cast]\ntheorem eq_iff {x y : ğ“ K} : (x : K) = (y : K) â†” x = y :=\n  NumberField.RingOfIntegers.ext_iff.symm\n\n"}
{"name":"NumberField.RingOfIntegers.map_mk","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : K\nhx : Membership.mem (integralClosure Int K) x\nâŠ¢ Eq ((algebraMap (NumberField.RingOfIntegers K) K) âŸ¨x, hxâŸ©) x","decl":"@[simp] lemma map_mk (x : K) (hx) : algebraMap (ğ“ K) K âŸ¨x, hxâŸ© = x := rfl\n\n"}
{"name":"NumberField.RingOfIntegers.coe_mk","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : K\nhx : Membership.mem (integralClosure Int K) x\nâŠ¢ Eq (â†‘âŸ¨x, hxâŸ©) x","decl":"lemma coe_mk {x : K} (hx) : ((âŸ¨x, hxâŸ© : ğ“ K) : K) = x := rfl\n\n"}
{"name":"NumberField.RingOfIntegers.mk_eq_mk","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx y : K\nhx : Membership.mem (integralClosure Int K) x\nhy : Membership.mem (integralClosure Int K) y\nâŠ¢ Iff (Eq âŸ¨x, hxâŸ© âŸ¨y, hyâŸ©) (Eq x y)","decl":"lemma mk_eq_mk (x y : K) (hx hy) : (âŸ¨x, hxâŸ© : ğ“ K) = âŸ¨y, hyâŸ© â†” x = y := by simp\n\n"}
{"name":"NumberField.RingOfIntegers.mk_one","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Eq âŸ¨1, â‹¯âŸ© 1","decl":"@[simp] lemma mk_one : (âŸ¨1, one_mem _âŸ© : ğ“ K) = 1 :=\n  rfl\n\n"}
{"name":"NumberField.RingOfIntegers.mk_zero","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Eq âŸ¨0, â‹¯âŸ© 0","decl":"@[simp] lemma mk_zero : (âŸ¨0, zero_mem _âŸ© : ğ“ K) = 0 :=\n  rfl\n-- TODO: these lemmas don't seem to fire?\n"}
{"name":"NumberField.RingOfIntegers.mk_add_mk","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx y : K\nhx : Membership.mem (integralClosure Int K) x\nhy : Membership.mem (integralClosure Int K) y\nâŠ¢ Eq (HAdd.hAdd âŸ¨x, hxâŸ© âŸ¨y, hyâŸ©) âŸ¨HAdd.hAdd x y, â‹¯âŸ©","decl":"@[simp] lemma mk_add_mk (x y : K) (hx hy) : (âŸ¨x, hxâŸ© : ğ“ K) + âŸ¨y, hyâŸ© = âŸ¨x + y, add_mem hx hyâŸ© :=\n  rfl\n\n"}
{"name":"NumberField.RingOfIntegers.mk_mul_mk","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx y : K\nhx : Membership.mem (integralClosure Int K) x\nhy : Membership.mem (integralClosure Int K) y\nâŠ¢ Eq (HMul.hMul âŸ¨x, hxâŸ© âŸ¨y, hyâŸ©) âŸ¨HMul.hMul x y, â‹¯âŸ©","decl":"@[simp] lemma mk_mul_mk (x y : K) (hx hy) : (âŸ¨x, hxâŸ© : ğ“ K) * âŸ¨y, hyâŸ© = âŸ¨x * y, mul_mem hx hyâŸ© :=\n  rfl\n\n"}
{"name":"NumberField.RingOfIntegers.mk_sub_mk","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx y : K\nhx : Membership.mem (integralClosure Int K) x\nhy : Membership.mem (integralClosure Int K) y\nâŠ¢ Eq (HSub.hSub âŸ¨x, hxâŸ© âŸ¨y, hyâŸ©) âŸ¨HSub.hSub x y, â‹¯âŸ©","decl":"@[simp] lemma mk_sub_mk (x y : K) (hx hy) : (âŸ¨x, hxâŸ© : ğ“ K) - âŸ¨y, hyâŸ© = âŸ¨x - y, sub_mem hx hyâŸ© :=\n  rfl\n\n"}
{"name":"NumberField.RingOfIntegers.neg_mk","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : K\nhx : Membership.mem (integralClosure Int K) x\nâŠ¢ Eq (Neg.neg âŸ¨x, hxâŸ©) âŸ¨Neg.neg x, â‹¯âŸ©","decl":"@[simp] lemma neg_mk (x : K) (hx) : (-âŸ¨x, hxâŸ© : ğ“ K) = âŸ¨-x, neg_mem hxâŸ© :=\n  rfl\n\n"}
{"name":"NumberField.RingOfIntegers.inst_isScalarTower","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"k : Type u_3\nK : Type u_4\nL : Type u_5\ninstâœâ¶ : Field k\ninstâœâµ : Field K\ninstâœâ´ : Field L\ninstâœÂ³ : Algebra k K\ninstâœÂ² : Algebra k L\ninstâœÂ¹ : Algebra K L\ninstâœ : IsScalarTower k K L\nâŠ¢ IsScalarTower (NumberField.RingOfIntegers k) (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)","decl":"instance inst_isScalarTower (k K L : Type*) [Field k] [Field K] [Field L]\n    [Algebra k K] [Algebra k L] [Algebra K L] [IsScalarTower k K L] :\n    IsScalarTower (ğ“ k) (ğ“ K) (ğ“ L) :=\n  IsScalarTower.of_algHom (mapAlgHom (IsScalarTower.toAlgHom k K L))\n\n"}
{"name":"NumberField.RingOfIntegers.coe_injective","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Function.Injective â‡‘(algebraMap (NumberField.RingOfIntegers K) K)","decl":"/-- The canonical map from `ğ“ K` to `K` is injective.\n\nThis is a convenient abbreviation for `NoZeroSMulDivisors.algebraMap_injective`.\n-/\nlemma coe_injective : Function.Injective (algebraMap (ğ“ K) K) :=\n  NoZeroSMulDivisors.algebraMap_injective _ _\n\n"}
{"name":"NumberField.RingOfIntegers.coe_eq_zero_iff","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : NumberField.RingOfIntegers K\nâŠ¢ Iff (Eq ((algebraMap (NumberField.RingOfIntegers K) K) x) 0) (Eq x 0)","decl":"/-- The canonical map from `ğ“ K` to `K` is injective.\n\nThis is a convenient abbreviation for `map_eq_zero_iff` applied to\n`NoZeroSMulDivisors.algebraMap_injective`.\n-/\nlemma coe_eq_zero_iff {x : ğ“ K} : algebraMap _ K x = 0 â†” x = 0 :=\n  map_eq_zero_iff _ coe_injective\n\n"}
{"name":"NumberField.RingOfIntegers.coe_ne_zero_iff","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : NumberField.RingOfIntegers K\nâŠ¢ Iff (Ne ((algebraMap (NumberField.RingOfIntegers K) K) x) 0) (Ne x 0)","decl":"/-- The canonical map from `ğ“ K` to `K` is injective.\n\nThis is a convenient abbreviation for `map_ne_zero_iff` applied to\n`NoZeroSMulDivisors.algebraMap_injective`.\n-/\nlemma coe_ne_zero_iff {x : ğ“ K} : algebraMap _ K x â‰  0 â†” x â‰  0 :=\n  map_ne_zero_iff _ coe_injective\n\n"}
{"name":"NumberField.RingOfIntegers.isIntegral_coe","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : NumberField.RingOfIntegers K\nâŠ¢ IsIntegral Int ((algebraMap (NumberField.RingOfIntegers K) K) x)","decl":"theorem isIntegral_coe (x : ğ“ K) : IsIntegral â„¤ (algebraMap _ K x) :=\n  x.2\n\n"}
{"name":"NumberField.RingOfIntegers.isIntegral","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nx : NumberField.RingOfIntegers K\nâŠ¢ IsIntegral Int x","decl":"theorem isIntegral (x : ğ“ K) : IsIntegral â„¤ x := by\n  obtain âŸ¨P, hPm, hPâŸ© := x.isIntegral_coe\n  refine âŸ¨P, hPm, ?_âŸ©\n  rwa [IsScalarTower.algebraMap_eq (S := ğ“ K), â† Polynomial.hom_evalâ‚‚, coe_eq_zero_iff] at hP\n\n"}
{"name":"NumberField.RingOfIntegers.instIsFractionRing","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ IsFractionRing (NumberField.RingOfIntegers K) K","decl":"instance [NumberField K] : IsFractionRing (ğ“ K) K :=\n  integralClosure.isFractionRing_of_finite_extension â„š _\n\n"}
{"name":"NumberField.RingOfIntegers.instIsIntegralClosureInt","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ IsIntegralClosure (NumberField.RingOfIntegers K) Int K","decl":"instance : IsIntegralClosure (ğ“ K) â„¤ K :=\n  integralClosure.isIntegralClosure _ _\n\n"}
{"name":"NumberField.RingOfIntegers.instIsIntegralInt","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœ : Field K\nâŠ¢ Algebra.IsIntegral Int (NumberField.RingOfIntegers K)","decl":"instance : Algebra.IsIntegral â„¤ (ğ“ K) :=\n  IsIntegralClosure.isIntegral_algebra â„¤ K\n\n"}
{"name":"NumberField.RingOfIntegers.instIsIntegrallyClosed","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ IsIntegrallyClosed (NumberField.RingOfIntegers K)","decl":"instance [NumberField K] : IsIntegrallyClosed (ğ“ K) :=\n  integralClosure.isIntegrallyClosedOfFiniteExtension â„š\n\n"}
{"name":"NumberField.RingOfIntegers.instCharZero_1","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : CharZero K\nâŠ¢ CharZero (NumberField.RingOfIntegers K)","decl":"instance [CharZero K] : CharZero (ğ“ K) :=\n  CharZero.of_module _ K\n\n"}
{"name":"NumberField.RingOfIntegers.instIsNoetherianInt","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ IsNoetherian Int (NumberField.RingOfIntegers K)","decl":"instance : IsNoetherian â„¤ (ğ“ K) :=\n  IsIntegralClosure.isNoetherian _ â„š K _\n\n"}
{"name":"NumberField.RingOfIntegers.not_isField","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Not (IsField (NumberField.RingOfIntegers K))","decl":"/-- The ring of integers of a number field is not a field. -/\ntheorem not_isField : Â¬IsField (ğ“ K) := by\n  have h_inj : Function.Injective (algebraMap â„¤ (ğ“ K)) := RingHom.injective_int (algebraMap â„¤ (ğ“ K))\n  intro hf\n  exact Int.not_isField\n    (((IsIntegralClosure.isIntegral_algebra â„¤ K).isField_iff_isField h_inj).mpr hf)\n\n"}
{"name":"NumberField.RingOfIntegers.instIsDedekindDomain","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ IsDedekindDomain (NumberField.RingOfIntegers K)","decl":"instance : IsDedekindDomain (ğ“ K) :=\n  IsIntegralClosure.isDedekindDomain â„¤ â„š K _\n\n"}
{"name":"NumberField.RingOfIntegers.instFreeInt","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Module.Free Int (NumberField.RingOfIntegers K)","decl":"instance : Free â„¤ (ğ“ K) :=\n  IsIntegralClosure.module_free â„¤ â„š K (ğ“ K)\n\n"}
{"name":"NumberField.RingOfIntegers.instIsLocalizationAlgebraMapSubmonoidIntNonZeroDivisors","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ IsLocalization (Algebra.algebraMapSubmonoid (NumberField.RingOfIntegers K) (nonZeroDivisors Int)) K","decl":"instance : IsLocalization (Algebra.algebraMapSubmonoid (ğ“ K) â„¤â°) K :=\n  IsIntegralClosure.isLocalization_of_isSeparable â„¤ â„š K (ğ“ K)\n\n"}
{"name":"NumberField.RingOfIntegers.instIsScalarTower_1","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\nâŠ¢ IsScalarTower (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L) L","decl":"instance : IsScalarTower (ğ“ K) (ğ“ L) L :=\n  IsScalarTower.of_algebraMap_eq' rfl\n\n"}
{"name":"NumberField.RingOfIntegers.instIsIntegralClosure","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\nâŠ¢ IsIntegralClosure (NumberField.RingOfIntegers L) (NumberField.RingOfIntegers K) L","decl":"instance : IsIntegralClosure (ğ“ L) (ğ“ K) L :=\n  IsIntegralClosure.tower_top (R := â„¤)\n\n"}
{"name":"NumberField.RingOfIntegers.extension_algebra_isIntegral","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\nâŠ¢ Algebra.IsIntegral (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)","decl":"/-- Any extension between ring of integers is integral. -/\ninstance extension_algebra_isIntegral : Algebra.IsIntegral (ğ“ K) (ğ“ L) :=\n  IsIntegralClosure.isIntegral_algebra (ğ“ K) L\n\n"}
{"name":"NumberField.RingOfIntegers.extension_isNoetherian","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninstâœâ´ : Field K\ninstâœÂ³ : Field L\ninstâœÂ² : Algebra K L\ninstâœÂ¹ : NumberField K\ninstâœ : NumberField L\nâŠ¢ IsNoetherian (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)","decl":"/-- Any extension between ring of integers of number fields is noetherian. -/\ninstance extension_isNoetherian [NumberField K] [NumberField L] : IsNoetherian (ğ“ K) (ğ“ L) :=\n  IsIntegralClosure.isNoetherian (ğ“ K) K L (ğ“ L)\n\n"}
{"name":"NumberField.RingOfIntegers.ker_algebraMap_eq_bot","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\nâŠ¢ Eq (RingHom.ker (algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L))) Bot.bot","decl":"/-- The kernel of the algebraMap between ring of integers is `âŠ¥`. -/\ntheorem ker_algebraMap_eq_bot : RingHom.ker (algebraMap (ğ“ K) (ğ“ L)) = âŠ¥ :=\n  (RingHom.ker_eq_bot_iff_eq_zero (algebraMap (ğ“ K) (ğ“ L))).mpr <| fun x hx => by\n  have h : (algebraMap K L) x = (algebraMap (ğ“ K) (ğ“ L)) x := rfl\n  simp only [hx, map_zero, map_eq_zero, RingOfIntegers.coe_eq_zero_iff] at h\n  exact h\n\n"}
{"name":"NumberField.RingOfIntegers.algebraMap.injective","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\nâŠ¢ Function.Injective â‡‘(algebraMap (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L))","decl":"/-- The algebraMap between ring of integers is injective. -/\ntheorem algebraMap.injective : Function.Injective (algebraMap (ğ“ K) (ğ“ L)) :=\n  (RingHom.injective_iff_ker_eq_bot (algebraMap (ğ“ K) (ğ“ L))).mpr (ker_algebraMap_eq_bot K L)\n\n"}
{"name":"NumberField.RingOfIntegers.instNoZeroSMulDivisors_1","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\nâŠ¢ NoZeroSMulDivisors (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)","decl":"instance : NoZeroSMulDivisors (ğ“ K) (ğ“ L) :=\n  NoZeroSMulDivisors.of_algebraMap_injective (algebraMap.injective K L)\n\n"}
{"name":"NumberField.RingOfIntegers.instNoZeroSMulDivisors_2","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninstâœÂ² : Field K\ninstâœÂ¹ : Field L\ninstâœ : Algebra K L\nâŠ¢ NoZeroSMulDivisors (NumberField.RingOfIntegers K) L","decl":"instance : NoZeroSMulDivisors (ğ“ K) L :=\n  NoZeroSMulDivisors.trans (ğ“ K) (ğ“ L) L\n\n"}
{"name":"NumberField.integralBasis_apply","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\ni : Module.Free.ChooseBasisIndex Int (NumberField.RingOfIntegers K)\nâŠ¢ Eq ((NumberField.integralBasis K) i) ((algebraMap (NumberField.RingOfIntegers K) K) ((NumberField.RingOfIntegers.basis K) i))","decl":"@[simp]\ntheorem integralBasis_apply (i : Free.ChooseBasisIndex â„¤ (ğ“ K)) :\n    integralBasis K i = algebraMap (ğ“ K) K (RingOfIntegers.basis K i) :=\n  Basis.localizationLocalization_apply â„š (nonZeroDivisors â„¤) K (RingOfIntegers.basis K) i\n\n"}
{"name":"NumberField.integralBasis_repr_apply","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.RingOfIntegers K\ni : Module.Free.ChooseBasisIndex Int (NumberField.RingOfIntegers K)\nâŠ¢ Eq (((NumberField.integralBasis K).repr ((algebraMap (NumberField.RingOfIntegers K) K) x)) i) ((algebraMap Int Rat) (((NumberField.RingOfIntegers.basis K).repr x) i))","decl":"@[simp]\ntheorem integralBasis_repr_apply (x : (ğ“ K)) (i : Free.ChooseBasisIndex â„¤ (ğ“ K)) :\n    (integralBasis K).repr (algebraMap _ _ x) i =\n      (algebraMap â„¤ â„š) ((RingOfIntegers.basis K).repr x i) :=\n  Basis.localizationLocalization_repr_algebraMap â„š (nonZeroDivisors â„¤) K _ x i\n\n"}
{"name":"NumberField.mem_span_integralBasis","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : K\nâŠ¢ Iff (Membership.mem (Submodule.span Int (Set.range â‡‘(NumberField.integralBasis K))) x) (Membership.mem (algebraMap (NumberField.RingOfIntegers K) K).range x)","decl":"theorem mem_span_integralBasis {x : K} :\n    x âˆˆ Submodule.span â„¤ (Set.range (integralBasis K)) â†” x âˆˆ (algebraMap (ğ“ K) K).range := by\n  rw [integralBasis, Basis.localizationLocalization_span, LinearMap.mem_range,\n      IsScalarTower.coe_toAlgHom', RingHom.mem_range]\n\n"}
{"name":"NumberField.RingOfIntegers.rank","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (Module.finrank Int (NumberField.RingOfIntegers K)) (Module.finrank Rat K)","decl":"theorem RingOfIntegers.rank : Module.finrank â„¤ (ğ“ K) = Module.finrank â„š K :=\n  IsIntegralClosure.rank â„¤ â„š K (ğ“ K)\n\n"}
{"name":"Rat.numberField","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"âŠ¢ NumberField Rat","decl":"instance numberField : NumberField â„š where\n  to_charZero := inferInstance\n  to_finiteDimensional := by\n  -- The vector space structure of `â„š` over itself can arise in multiple ways:\n  -- all fields are vector spaces over themselves (used in `Rat.finiteDimensional`)\n  -- all char 0 fields have a canonical embedding of `â„š` (used in `NumberField`).\n  -- Show that these coincide:\n    convert (inferInstance : FiniteDimensional â„š â„š)\n\n"}
{"name":"Rat.coe_ringOfIntegersEquiv","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"z : NumberField.RingOfIntegers Rat\nâŠ¢ Eq (â†‘(Rat.ringOfIntegersEquiv z)) ((algebraMap (NumberField.RingOfIntegers Rat) Rat) z)","decl":"@[simp]\ntheorem coe_ringOfIntegersEquiv (z : ğ“ â„š) :\n    (Rat.ringOfIntegersEquiv z : â„š) = algebraMap (ğ“ â„š) â„š z := by\n  obtain âŸ¨z, rflâŸ© := Rat.ringOfIntegersEquiv.symm.surjective z\n  simp\n\n"}
{"name":"AdjoinRoot.instNumberFieldRat","module":"Mathlib.NumberTheory.NumberField.Basic","initialProofState":"f : Polynomial Rat\nhf : Fact (Irreducible f)\nâŠ¢ NumberField (AdjoinRoot f)","decl":"/-- The quotient of `â„š[X]` by the ideal generated by an irreducible polynomial of `â„š[X]`\nis a number field. -/\ninstance {f : Polynomial â„š} [hf : Fact (Irreducible f)] : NumberField (AdjoinRoot f) where\n  to_charZero := charZero_of_injective_algebraMap (algebraMap â„š _).injective\n  to_finiteDimensional := by convert (AdjoinRoot.powerBasis hf.out.ne_zero).finite\n\n"}
