{"name":"VectorFourier.fourierIntegral_const_smul","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : CommRing ğ•œ\nV : Type u_2\ninstâœâ¶ : AddCommGroup V\ninstâœâµ : Module ğ•œ V\ninstâœâ´ : MeasurableSpace V\nW : Type u_3\ninstâœÂ³ : AddCommGroup W\ninstâœÂ² : Module ğ•œ W\nE : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id ğ•œ) V (LinearMap (RingHom.id ğ•œ) W ğ•œ)\nf : V â†’ E\nr : Complex\nâŠ¢ Eq (VectorFourier.fourierIntegral e Î¼ L (HSMul.hSMul r f)) (HSMul.hSMul r (VectorFourier.fourierIntegral e Î¼ L f))","decl":"theorem fourierIntegral_const_smul (e : AddChar ğ•œ ğ•Š) (Î¼ : Measure V)\n    (L : V â†’â‚—[ğ•œ] W â†’â‚—[ğ•œ] ğ•œ) (f : V â†’ E) (r : â„‚) :\n    fourierIntegral e Î¼ L (r â€¢ f) = r â€¢ fourierIntegral e Î¼ L f := by\n  ext1 w\n  simp only [Pi.smul_apply, fourierIntegral, smul_comm _ r, integral_smul]\n\n"}
{"name":"VectorFourier.norm_fourierIntegral_le_integral_norm","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : CommRing ğ•œ\nV : Type u_2\ninstâœâ¶ : AddCommGroup V\ninstâœâµ : Module ğ•œ V\ninstâœâ´ : MeasurableSpace V\nW : Type u_3\ninstâœÂ³ : AddCommGroup W\ninstâœÂ² : Module ğ•œ W\nE : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id ğ•œ) V (LinearMap (RingHom.id ğ•œ) W ğ•œ)\nf : V â†’ E\nw : W\nâŠ¢ LE.le (Norm.norm (VectorFourier.fourierIntegral e Î¼ L f w)) (MeasureTheory.integral Î¼ fun v => Norm.norm (f v))","decl":"/-- The uniform norm of the Fourier integral of `f` is bounded by the `LÂ¹` norm of `f`. -/\ntheorem norm_fourierIntegral_le_integral_norm (e : AddChar ğ•œ ğ•Š) (Î¼ : Measure V)\n    (L : V â†’â‚—[ğ•œ] W â†’â‚—[ğ•œ] ğ•œ) (f : V â†’ E) (w : W) :\n    â€–fourierIntegral e Î¼ L f wâ€– â‰¤ âˆ« v : V, â€–f vâ€– âˆ‚Î¼ := by\n  refine (norm_integral_le_integral_norm _).trans (le_of_eq ?_)\n  simp_rw [Circle.norm_smul]\n\n"}
{"name":"VectorFourier.fourierIntegral_comp_add_right","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : CommRing ğ•œ\nV : Type u_2\ninstâœâ¸ : AddCommGroup V\ninstâœâ· : Module ğ•œ V\ninstâœâ¶ : MeasurableSpace V\nW : Type u_3\ninstâœâµ : AddCommGroup W\ninstâœâ´ : Module ğ•œ W\nE : Type u_4\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Complex E\ninstâœÂ¹ : MeasurableAdd V\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\ninstâœ : Î¼.IsAddRightInvariant\nL : LinearMap (RingHom.id ğ•œ) V (LinearMap (RingHom.id ğ•œ) W ğ•œ)\nf : V â†’ E\nvâ‚€ : V\nâŠ¢ Eq (VectorFourier.fourierIntegral e Î¼ L (Function.comp f fun v => HAdd.hAdd v vâ‚€)) fun w => HSMul.hSMul (e ((L vâ‚€) w)) (VectorFourier.fourierIntegral e Î¼ L f w)","decl":"/-- The Fourier integral converts right-translation into scalar multiplication by a phase factor. -/\ntheorem fourierIntegral_comp_add_right [MeasurableAdd V] (e : AddChar ğ•œ ğ•Š) (Î¼ : Measure V)\n    [Î¼.IsAddRightInvariant] (L : V â†’â‚—[ğ•œ] W â†’â‚—[ğ•œ] ğ•œ) (f : V â†’ E) (vâ‚€ : V) :\n    fourierIntegral e Î¼ L (f âˆ˜ fun v â†¦ v + vâ‚€) =\n      fun w â†¦ e (L vâ‚€ w) â€¢ fourierIntegral e Î¼ L f w := by\n  ext1 w\n  dsimp only [fourierIntegral, Function.comp_apply, Circle.smul_def]\n  conv in L _ => rw [â† add_sub_cancel_right v vâ‚€]\n  rw [integral_add_right_eq_self fun v : V â†¦ (e (-L (v - vâ‚€) w) : â„‚) â€¢ f v, â† integral_smul]\n  congr 1 with v\n  rw [â† smul_assoc, smul_eq_mul, â† Circle.coe_mul, â† e.map_add_eq_mul, â† LinearMap.neg_apply,\n    â† sub_eq_add_neg, â† LinearMap.sub_apply, LinearMap.map_sub, neg_sub]\n\n"}
{"name":"VectorFourier.fourierIntegral_convergent_iff","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â² : CommRing ğ•œ\nV : Type u_2\ninstâœÂ¹Â¹ : AddCommGroup V\ninstâœÂ¹â° : Module ğ•œ V\ninstâœâ¹ : MeasurableSpace V\nW : Type u_3\ninstâœâ¸ : AddCommGroup W\ninstâœâ· : Module ğ•œ W\nE : Type u_4\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\ninstâœâ´ : TopologicalSpace ğ•œ\ninstâœÂ³ : TopologicalRing ğ•œ\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : TopologicalSpace W\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id ğ•œ) V (LinearMap (RingHom.id ğ•œ) W ğ•œ)\nhe : Continuous â‡‘e\nhL : Continuous fun p => (L p.1) p.2\nf : V â†’ E\nw : W\nâŠ¢ Iff (MeasureTheory.Integrable (fun v => HSMul.hSMul (e (Neg.neg ((L v) w))) (f v)) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"/-- For any `w`, the Fourier integral is convergent iff `f` is integrable. -/\ntheorem fourierIntegral_convergent_iff (he : Continuous e)\n    (hL : Continuous fun p : V Ã— W â†¦ L p.1 p.2) {f : V â†’ E} (w : W) :\n    Integrable (fun v : V â†¦ e (-L v w) â€¢ f v) Î¼ â†” Integrable f Î¼ := by\n  -- first prove one-way implication\n  have aux {g : V â†’ E} (hg : Integrable g Î¼) (x : W) :\n      Integrable (fun v : V â†¦ e (-L v x) â€¢ g v) Î¼ := by\n    have c : Continuous fun v â†¦ e (-L v x) :=\n      he.comp (hL.comp (continuous_prod_mk.mpr âŸ¨continuous_id, continuous_constâŸ©)).neg\n    simp_rw [â† integrable_norm_iff (c.aestronglyMeasurable.smul hg.1), Circle.norm_smul]\n    exact hg.norm\n  -- then use it for both directions\n  refine âŸ¨fun hf â†¦ ?_, fun hf â†¦ aux hf wâŸ©\n  have := aux hf (-w)\n  simp_rw [â† mul_smul (e _) (e _) (f _), â† e.map_add_eq_mul, LinearMap.map_neg, neg_add_cancel,\n    e.map_zero_eq_one, one_smul] at this -- the `(e _)` speeds up elaboration considerably\n  exact this\n\n"}
{"name":"VectorFourier.fourierIntegral_add","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â² : CommRing ğ•œ\nV : Type u_2\ninstâœÂ¹Â¹ : AddCommGroup V\ninstâœÂ¹â° : Module ğ•œ V\ninstâœâ¹ : MeasurableSpace V\nW : Type u_3\ninstâœâ¸ : AddCommGroup W\ninstâœâ· : Module ğ•œ W\nE : Type u_4\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\ninstâœâ´ : TopologicalSpace ğ•œ\ninstâœÂ³ : TopologicalRing ğ•œ\ninstâœÂ² : TopologicalSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : TopologicalSpace W\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id ğ•œ) V (LinearMap (RingHom.id ğ•œ) W ğ•œ)\nhe : Continuous â‡‘e\nhL : Continuous fun p => (L p.1) p.2\nf g : V â†’ E\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Eq (VectorFourier.fourierIntegral e Î¼ L (HAdd.hAdd f g)) (HAdd.hAdd (VectorFourier.fourierIntegral e Î¼ L f) (VectorFourier.fourierIntegral e Î¼ L g))","decl":"theorem fourierIntegral_add (he : Continuous e) (hL : Continuous fun p : V Ã— W â†¦ L p.1 p.2)\n    {f g : V â†’ E} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    fourierIntegral e Î¼ L (f + g) = fourierIntegral e Î¼ L f + fourierIntegral e Î¼ L g := by\n  ext1 w\n  dsimp only [Pi.add_apply, fourierIntegral]\n  simp_rw [smul_add]\n  rw [integral_add]\n  Â· exact (fourierIntegral_convergent_iff he hL w).2 hf\n  Â· exact (fourierIntegral_convergent_iff he hL w).2 hg\n\n"}
{"name":"VectorFourier.fourierIntegral_continuous","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â³ : CommRing ğ•œ\nV : Type u_2\ninstâœÂ¹Â² : AddCommGroup V\ninstâœÂ¹Â¹ : Module ğ•œ V\ninstâœÂ¹â° : MeasurableSpace V\nW : Type u_3\ninstâœâ¹ : AddCommGroup W\ninstâœâ¸ : Module ğ•œ W\nE : Type u_4\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Complex E\ninstâœâµ : TopologicalSpace ğ•œ\ninstâœâ´ : TopologicalRing ğ•œ\ninstâœÂ³ : TopologicalSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : TopologicalSpace W\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id ğ•œ) V (LinearMap (RingHom.id ğ•œ) W ğ•œ)\ninstâœ : FirstCountableTopology W\nhe : Continuous â‡‘e\nhL : Continuous fun p => (L p.1) p.2\nf : V â†’ E\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Continuous (VectorFourier.fourierIntegral e Î¼ L f)","decl":"/-- The Fourier integral of an `L^1` function is a continuous function. -/\ntheorem fourierIntegral_continuous [FirstCountableTopology W] (he : Continuous e)\n    (hL : Continuous fun p : V Ã— W â†¦ L p.1 p.2) {f : V â†’ E} (hf : Integrable f Î¼) :\n    Continuous (fourierIntegral e Î¼ L f) := by\n  apply continuous_of_dominated\n  Â· exact fun w â†¦ ((fourierIntegral_convergent_iff he hL w).2 hf).1\n  Â· exact fun w â†¦ ae_of_all _ fun v â†¦ le_of_eq (Circle.norm_smul _ _)\n  Â· exact hf.norm\n  Â· refine ae_of_all _ fun v â†¦ (he.comp ?_).smul continuous_const\n    exact (hL.comp (continuous_prod_mk.mpr âŸ¨continuous_const, continuous_idâŸ©)).neg\n\n"}
{"name":"VectorFourier.integral_bilin_fourierIntegral_eq_flip","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœÂ²Â³ : CommRing ğ•œ\nV : Type u_2\ninstâœÂ²Â² : AddCommGroup V\ninstâœÂ²Â¹ : Module ğ•œ V\ninstâœÂ²â° : MeasurableSpace V\nW : Type u_3\ninstâœÂ¹â¹ : AddCommGroup W\ninstâœÂ¹â¸ : Module ğ•œ W\nE : Type u_4\nF : Type u_5\nG : Type u_6\ninstâœÂ¹â· : NormedAddCommGroup E\ninstâœÂ¹â¶ : NormedSpace Complex E\ninstâœÂ¹âµ : NormedAddCommGroup F\ninstâœÂ¹â´ : NormedSpace Complex F\ninstâœÂ¹Â³ : NormedAddCommGroup G\ninstâœÂ¹Â² : NormedSpace Complex G\ninstâœÂ¹Â¹ : TopologicalSpace ğ•œ\ninstâœÂ¹â° : TopologicalRing ğ•œ\ninstâœâ¹ : TopologicalSpace V\ninstâœâ¸ : BorelSpace V\ninstâœâ· : TopologicalSpace W\ninstâœâ¶ : MeasurableSpace W\ninstâœâµ : BorelSpace W\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id ğ•œ) V (LinearMap (RingHom.id ğ•œ) W ğ•œ)\nÎ½ : MeasureTheory.Measure W\ninstâœâ´ : MeasureTheory.SigmaFinite Î¼\ninstâœÂ³ : MeasureTheory.SigmaFinite Î½\ninstâœÂ² : SecondCountableTopology V\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nf : V â†’ E\ng : W â†’ F\nM : ContinuousLinearMap (RingHom.id Complex) E (ContinuousLinearMap (RingHom.id Complex) F G)\nhe : Continuous â‡‘e\nhL : Continuous fun p => (L p.1) p.2\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î½\nâŠ¢ Eq (MeasureTheory.integral Î½ fun Î¾ => (M (VectorFourier.fourierIntegral e Î¼ L f Î¾)) (g Î¾)) (MeasureTheory.integral Î¼ fun x => (M (f x)) (VectorFourier.fourierIntegral e Î½ L.flip g x))","decl":"/-- The Fourier transform satisfies `âˆ« ğ“• f * g = âˆ« f * ğ“• g`, i.e., it is self-adjoint.\nVersion where the multiplication is replaced by a general bilinear form `M`. -/\ntheorem integral_bilin_fourierIntegral_eq_flip\n    {f : V â†’ E} {g : W â†’ F} (M : E â†’L[â„‚] F â†’L[â„‚] G) (he : Continuous e)\n    (hL : Continuous fun p : V Ã— W â†¦ L p.1 p.2) (hf : Integrable f Î¼) (hg : Integrable g Î½) :\n    âˆ« Î¾, M (fourierIntegral e Î¼ L f Î¾) (g Î¾) âˆ‚Î½ =\n      âˆ« x, M (f x) (fourierIntegral e Î½ L.flip g x) âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G; swap; Â· simp [integral, hG]\n  calc\n  _ = âˆ« Î¾, M.flip (g Î¾) (âˆ« x, e (-L x Î¾) â€¢ f x âˆ‚Î¼) âˆ‚Î½ := rfl\n  _ = âˆ« Î¾, (âˆ« x, M.flip (g Î¾) (e (-L x Î¾) â€¢ f x) âˆ‚Î¼) âˆ‚Î½ := by\n    congr with Î¾\n    apply (ContinuousLinearMap.integral_comp_comm _ _).symm\n    exact (fourierIntegral_convergent_iff he hL _).2 hf\n  _ = âˆ« x, (âˆ« Î¾, M.flip (g Î¾) (e (-L x Î¾) â€¢ f x) âˆ‚Î½) âˆ‚Î¼ := by\n    rw [integral_integral_swap]\n    have : Integrable (fun (p : W Ã— V) â†¦ â€–Mâ€– * (â€–g p.1â€– * â€–f p.2â€–)) (Î½.prod Î¼) :=\n      (hg.norm.prod_mul hf.norm).const_mul _\n    apply this.mono\n    Â· -- This proof can be golfed but becomes very slow; breaking it up into steps\n      -- speeds up compilation.\n      change AEStronglyMeasurable (fun p : W Ã— V â†¦ (M (e (-(L p.2) p.1) â€¢ f p.2) (g p.1))) _\n      have A : AEStronglyMeasurable (fun (p : W Ã— V) â†¦ e (-L p.2 p.1) â€¢ f p.2) (Î½.prod Î¼) := by\n        refine (Continuous.aestronglyMeasurable ?_).smul hf.1.snd\n        exact he.comp (hL.comp continuous_swap).neg\n      have A' : AEStronglyMeasurable (fun p â†¦ (g p.1, e (-(L p.2) p.1) â€¢ f p.2) : W Ã— V â†’ F Ã— E)\n        (Measure.prod Î½ Î¼) := hg.1.fst.prod_mk A\n      have B : Continuous (fun q â†¦ M q.2 q.1 : F Ã— E â†’ G) := M.flip.continuousâ‚‚\n      apply B.comp_aestronglyMeasurable A' -- `exact` works, but `apply` is 10x faster!\n    Â· filter_upwards with âŸ¨Î¾, xâŸ©\n      rw [Function.uncurry_apply_pair, Submonoid.smul_def, (M.flip (g Î¾)).map_smul,\n        â† Submonoid.smul_def, Circle.norm_smul, ContinuousLinearMap.flip_apply,\n        norm_mul, norm_norm M, norm_mul, norm_norm, norm_norm, mul_comm (â€–g _â€–), â† mul_assoc]\n      exact M.le_opNormâ‚‚ (f x) (g Î¾)\n  _ = âˆ« x, (âˆ« Î¾, M (f x) (e (-L.flip Î¾ x) â€¢ g Î¾) âˆ‚Î½) âˆ‚Î¼ := by\n      simp only [ContinuousLinearMap.flip_apply, ContinuousLinearMap.map_smul_of_tower,\n      ContinuousLinearMap.coe_smul', Pi.smul_apply, LinearMap.flip_apply]\n  _ = âˆ« x, M (f x) (âˆ« Î¾, e (-L.flip Î¾ x) â€¢ g Î¾ âˆ‚Î½) âˆ‚Î¼ := by\n    congr with x\n    apply ContinuousLinearMap.integral_comp_comm\n    apply (fourierIntegral_convergent_iff he _ _).2 hg\n    exact hL.comp continuous_swap\n\n"}
{"name":"VectorFourier.integral_fourierIntegral_smul_eq_flip","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â¸ : CommRing ğ•œ\nV : Type u_2\ninstâœÂ¹â· : AddCommGroup V\ninstâœÂ¹â¶ : Module ğ•œ V\ninstâœÂ¹âµ : MeasurableSpace V\nW : Type u_3\ninstâœÂ¹â´ : AddCommGroup W\ninstâœÂ¹Â³ : Module ğ•œ W\nF : Type u_5\ninstâœÂ¹Â² : NormedAddCommGroup F\ninstâœÂ¹Â¹ : NormedSpace Complex F\ninstâœÂ¹â° : TopologicalSpace ğ•œ\ninstâœâ¹ : TopologicalRing ğ•œ\ninstâœâ¸ : TopologicalSpace V\ninstâœâ· : BorelSpace V\ninstâœâ¶ : TopologicalSpace W\ninstâœâµ : MeasurableSpace W\ninstâœâ´ : BorelSpace W\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id ğ•œ) V (LinearMap (RingHom.id ğ•œ) W ğ•œ)\nÎ½ : MeasureTheory.Measure W\ninstâœÂ³ : MeasureTheory.SigmaFinite Î¼\ninstâœÂ² : MeasureTheory.SigmaFinite Î½\ninstâœÂ¹ : SecondCountableTopology V\ninstâœ : CompleteSpace F\nf : V â†’ Complex\ng : W â†’ F\nhe : Continuous â‡‘e\nhL : Continuous fun p => (L p.1) p.2\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î½\nâŠ¢ Eq (MeasureTheory.integral Î½ fun Î¾ => HSMul.hSMul (VectorFourier.fourierIntegral e Î¼ L f Î¾) (g Î¾)) (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (f x) (VectorFourier.fourierIntegral e Î½ L.flip g x))","decl":"/-- The Fourier transform satisfies `âˆ« ğ“• f * g = âˆ« f * ğ“• g`, i.e., it is self-adjoint. -/\ntheorem integral_fourierIntegral_smul_eq_flip\n    {f : V â†’ â„‚} {g : W â†’ F} (he : Continuous e)\n    (hL : Continuous fun p : V Ã— W â†¦ L p.1 p.2) (hf : Integrable f Î¼) (hg : Integrable g Î½) :\n    âˆ« Î¾, (fourierIntegral e Î¼ L f Î¾) â€¢ (g Î¾) âˆ‚Î½ =\n      âˆ« x, (f x) â€¢ (fourierIntegral e Î½ L.flip g x) âˆ‚Î¼ :=\n  integral_bilin_fourierIntegral_eq_flip (ContinuousLinearMap.lsmul â„‚ â„‚) he hL hf hg\n\n"}
{"name":"VectorFourier.fourierIntegral_continuousLinearMap_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nF : Type u_4\nV : Type u_5\nW : Type u_6\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedAddCommGroup V\ninstâœâ¸ : NormedSpace ğ•œ V\ninstâœâ· : MeasurableSpace V\ninstâœâ¶ : BorelSpace V\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace ğ•œ W\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\nL : ContinuousLinearMap (RingHom.id ğ•œ) V (ContinuousLinearMap (RingHom.id ğ•œ) W ğ•œ)\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : V â†’ ContinuousLinearMap (RingHom.id Real) F E\na : F\nw : W\nhe : Continuous â‡‘e\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq ((VectorFourier.fourierIntegral e Î¼ L.toLinearMapâ‚‚ f w) a) (VectorFourier.fourierIntegral e Î¼ L.toLinearMapâ‚‚ (fun x => (f x) a) w)","decl":"theorem fourierIntegral_continuousLinearMap_apply\n    {f : V â†’ (F â†’L[â„] E)} {a : F} {w : W} (he : Continuous e) (hf : Integrable f Î¼) :\n    fourierIntegral e Î¼ L.toLinearMapâ‚‚ f w a =\n      fourierIntegral e Î¼ L.toLinearMapâ‚‚ (fun x â†¦ f x a) w := by\n  rw [fourierIntegral, ContinuousLinearMap.integral_apply]\n  Â· rfl\n  Â· apply (fourierIntegral_convergent_iff he _ _).2 hf\n    exact L.continuousâ‚‚\n\n"}
{"name":"VectorFourier.fourierIntegral_continuousMultilinearMap_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\nV : Type u_5\nW : Type u_6\ninstâœÂ¹Â¹ : Fintype Î¹\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedAddCommGroup V\ninstâœâ¸ : NormedSpace ğ•œ V\ninstâœâ· : MeasurableSpace V\ninstâœâ¶ : BorelSpace V\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : NormedSpace ğ•œ W\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure V\nL : ContinuousLinearMap (RingHom.id ğ•œ) V (ContinuousLinearMap (RingHom.id ğ•œ) W ğ•œ)\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Complex E\nM : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœ : (i : Î¹) â†’ NormedSpace Real (M i)\nf : V â†’ ContinuousMultilinearMap Real M E\nm : (i : Î¹) â†’ M i\nw : W\nhe : Continuous â‡‘e\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq ((VectorFourier.fourierIntegral e Î¼ L.toLinearMapâ‚‚ f w) m) (VectorFourier.fourierIntegral e Î¼ L.toLinearMapâ‚‚ (fun x => (f x) m) w)","decl":"theorem fourierIntegral_continuousMultilinearMap_apply\n    {f : V â†’ (ContinuousMultilinearMap â„ M E)} {m : (i : Î¹) â†’ M i} {w : W} (he : Continuous e)\n    (hf : Integrable f Î¼) :\n    fourierIntegral e Î¼ L.toLinearMapâ‚‚ f w m =\n      fourierIntegral e Î¼ L.toLinearMapâ‚‚ (fun x â†¦ f x m) w := by\n  rw [fourierIntegral, ContinuousMultilinearMap.integral_apply]\n  Â· rfl\n  Â· apply (fourierIntegral_convergent_iff he _ _).2 hf\n    exact L.continuousâ‚‚\n\n"}
{"name":"Fourier.fourierIntegral_def","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : CommRing ğ•œ\ninstâœÂ² : MeasurableSpace ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure ğ•œ\nf : ğ•œ â†’ E\nw : ğ•œ\nâŠ¢ Eq (Fourier.fourierIntegral e Î¼ f w) (MeasureTheory.integral Î¼ fun v => HSMul.hSMul (e (Neg.neg (HMul.hMul v w))) (f v))","decl":"theorem fourierIntegral_def (e : AddChar ğ•œ ğ•Š) (Î¼ : Measure ğ•œ) (f : ğ•œ â†’ E) (w : ğ•œ) :\n    fourierIntegral e Î¼ f w = âˆ« v : ğ•œ, e (-(v * w)) â€¢ f v âˆ‚Î¼ :=\n  rfl\n\n"}
{"name":"Fourier.fourierIntegral_const_smul","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : CommRing ğ•œ\ninstâœÂ² : MeasurableSpace ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure ğ•œ\nf : ğ•œ â†’ E\nr : Complex\nâŠ¢ Eq (Fourier.fourierIntegral e Î¼ (HSMul.hSMul r f)) (HSMul.hSMul r (Fourier.fourierIntegral e Î¼ f))","decl":"theorem fourierIntegral_const_smul (e : AddChar ğ•œ ğ•Š) (Î¼ : Measure ğ•œ) (f : ğ•œ â†’ E) (r : â„‚) :\n    fourierIntegral e Î¼ (r â€¢ f) = r â€¢ fourierIntegral e Î¼ f :=\n  VectorFourier.fourierIntegral_const_smul _ _ _ _ _\n\n"}
{"name":"Fourier.norm_fourierIntegral_le_integral_norm","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : CommRing ğ•œ\ninstâœÂ² : MeasurableSpace ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure ğ•œ\nf : ğ•œ â†’ E\nw : ğ•œ\nâŠ¢ LE.le (Norm.norm (Fourier.fourierIntegral e Î¼ f w)) (MeasureTheory.integral Î¼ fun x => Norm.norm (f x))","decl":"/-- The uniform norm of the Fourier transform of `f` is bounded by the `LÂ¹` norm of `f`. -/\ntheorem norm_fourierIntegral_le_integral_norm (e : AddChar ğ•œ ğ•Š) (Î¼ : Measure ğ•œ)\n    (f : ğ•œ â†’ E) (w : ğ•œ) : â€–fourierIntegral e Î¼ f wâ€– â‰¤ âˆ« x : ğ•œ, â€–f xâ€– âˆ‚Î¼ :=\n  VectorFourier.norm_fourierIntegral_le_integral_norm _ _ _ _ _\n\n"}
{"name":"Fourier.fourierIntegral_comp_add_right","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : CommRing ğ•œ\ninstâœâ´ : MeasurableSpace ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Complex E\ninstâœÂ¹ : MeasurableAdd ğ•œ\ne : AddChar ğ•œ Circle\nÎ¼ : MeasureTheory.Measure ğ•œ\ninstâœ : Î¼.IsAddRightInvariant\nf : ğ•œ â†’ E\nvâ‚€ : ğ•œ\nâŠ¢ Eq (Fourier.fourierIntegral e Î¼ (Function.comp f fun v => HAdd.hAdd v vâ‚€)) fun w => HSMul.hSMul (e (HMul.hMul vâ‚€ w)) (Fourier.fourierIntegral e Î¼ f w)","decl":"/-- The Fourier transform converts right-translation into scalar multiplication by a phase\nfactor. -/\ntheorem fourierIntegral_comp_add_right [MeasurableAdd ğ•œ] (e : AddChar ğ•œ ğ•Š) (Î¼ : Measure ğ•œ)\n    [Î¼.IsAddRightInvariant] (f : ğ•œ â†’ E) (vâ‚€ : ğ•œ) :\n    fourierIntegral e Î¼ (f âˆ˜ fun v â†¦ v + vâ‚€) = fun w â†¦ e (vâ‚€ * w) â€¢ fourierIntegral e Î¼ f w :=\n  VectorFourier.fourierIntegral_comp_add_right _ _ _ _ _\n\n"}
{"name":"Real.fourierChar_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"x : Real\nâŠ¢ Eq (â†‘(Real.fourierChar x)) (Complex.exp (HMul.hMul (â†‘(HMul.hMul (HMul.hMul 2 Real.pi) x)) Complex.I))","decl":"theorem fourierChar_apply (x : â„) : ğ x = Complex.exp (â†‘(2 * Ï€ * x) * Complex.I) :=\n  rfl\n\n"}
{"name":"Real.continuous_fourierChar","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"âŠ¢ Continuous â‡‘Real.fourierChar","decl":"@[continuity]\ntheorem continuous_fourierChar : Continuous ğ := Circle.exp.continuous.comp (continuous_mul_left _)\n\n"}
{"name":"Real.vector_fourierIntegral_eq_integral_exp_smul","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : AddCommGroup V\ninstâœÂ³ : Module Real V\ninstâœÂ² : MeasurableSpace V\nW : Type u_3\ninstâœÂ¹ : AddCommGroup W\ninstâœ : Module Real W\nL : LinearMap (RingHom.id Real) V (LinearMap (RingHom.id Real) W Real)\nÎ¼ : MeasureTheory.Measure V\nf : V â†’ E\nw : W\nâŠ¢ Eq (VectorFourier.fourierIntegral Real.fourierChar Î¼ L f w) (MeasureTheory.integral Î¼ fun v => HSMul.hSMul (Complex.exp (HMul.hMul (â†‘(HMul.hMul (HMul.hMul (-2) Real.pi) ((L v) w))) Complex.I)) (f v))","decl":"theorem vector_fourierIntegral_eq_integral_exp_smul {V : Type*} [AddCommGroup V] [Module â„ V]\n    [MeasurableSpace V] {W : Type*} [AddCommGroup W] [Module â„ W] (L : V â†’â‚—[â„] W â†’â‚—[â„] â„)\n    (Î¼ : Measure V) (f : V â†’ E) (w : W) :\n    VectorFourier.fourierIntegral fourierChar Î¼ L f w =\n      âˆ« v : V, Complex.exp (â†‘(-2 * Ï€ * L v w) * Complex.I) â€¢ f v âˆ‚Î¼ := by\n  simp_rw [VectorFourier.fourierIntegral, Circle.smul_def, Real.fourierChar_apply, mul_neg,\n    neg_mul]\n\n"}
{"name":"Real.fourierIntegral_convergent_iff'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : NormedSpace Real V\ninstâœÂ³ : NormedAddCommGroup W\ninstâœÂ² : NormedSpace Real W\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nÎ¼ : MeasureTheory.Measure V\nf : V â†’ E\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nw : W\nâŠ¢ Iff (MeasureTheory.Integrable (fun v => HSMul.hSMul (Real.fourierChar (Neg.neg ((L v) w))) (f v)) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"/-- The Fourier integral is well defined iff the function is integrable. Version with a general\ncontinuous bilinear function `L`. For the specialization to the inner product in an inner product\nspace, see `Real.fourierIntegral_convergent_iff`. -/\n@[simp]\ntheorem fourierIntegral_convergent_iff' {V W : Type*} [NormedAddCommGroup V] [NormedSpace â„ V]\n    [NormedAddCommGroup W] [NormedSpace â„ W] [MeasurableSpace V] [BorelSpace V] {Î¼ : Measure V}\n    {f : V â†’ E} (L : V â†’L[â„] W â†’L[â„] â„) (w : W) :\n    Integrable (fun v : V â†¦ ğ (- L v w) â€¢ f v) Î¼ â†” Integrable f Î¼ :=\n  VectorFourier.fourierIntegral_convergent_iff (E := E) (L := L.toLinearMapâ‚‚)\n    continuous_fourierChar L.continuousâ‚‚ _\n\n"}
{"name":"Real.fourierIntegral_continuousLinearMap_apply'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Complex E\nF : Type u_3\nV : Type u_4\nW : Type u_5\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : NormedSpace Real V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : NormedAddCommGroup W\ninstâœÂ² : NormedSpace Real W\nÎ¼ : MeasureTheory.Measure V\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : V â†’ ContinuousLinearMap (RingHom.id Real) F E\na : F\nw : W\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq ((VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f w) a) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ (fun x => (f x) a) w)","decl":"theorem fourierIntegral_continuousLinearMap_apply'\n    {f : V â†’ (F â†’L[â„] E)} {a : F} {w : W} (hf : Integrable f Î¼) :\n    VectorFourier.fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f w a =\n      VectorFourier.fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fun x â†¦ f x a) w :=\n  VectorFourier.fourierIntegral_continuousLinearMap_apply continuous_fourierChar hf\n\n"}
{"name":"Real.fourierIntegral_continuousMultilinearMap_apply'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedSpace Complex E\nÎ¹ : Type u_2\nV : Type u_4\nW : Type u_5\ninstâœâ¸ : Fintype Î¹\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : NormedSpace Real V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : NormedAddCommGroup W\ninstâœÂ² : NormedSpace Real W\nÎ¼ : MeasureTheory.Measure V\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nM : Î¹ â†’ Type u_6\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœ : (i : Î¹) â†’ NormedSpace Real (M i)\nf : V â†’ ContinuousMultilinearMap Real M E\nm : (i : Î¹) â†’ M i\nw : W\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq ((VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ f w) m) (VectorFourier.fourierIntegral Real.fourierChar Î¼ L.toLinearMapâ‚‚ (fun x => (f x) m) w)","decl":"theorem fourierIntegral_continuousMultilinearMap_apply'\n    {f : V â†’ ContinuousMultilinearMap â„ M E} {m : (i : Î¹) â†’ M i} {w : W} (hf : Integrable f Î¼) :\n    VectorFourier.fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ f w m =\n      VectorFourier.fourierIntegral ğ Î¼ L.toLinearMapâ‚‚ (fun x â†¦ f x m) w :=\n  VectorFourier.fourierIntegral_continuousMultilinearMap_apply continuous_fourierChar hf\n\n"}
{"name":"Real.fourierIntegral_convergent_iff","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Complex E\nV : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : MeasurableSpace V\ninstâœ : BorelSpace V\nÎ¼ : MeasureTheory.Measure V\nf : V â†’ E\nw : V\nâŠ¢ Iff (MeasureTheory.Integrable (fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (f v)) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"@[simp] theorem fourierIntegral_convergent_iff {Î¼ : Measure V} {f : V â†’ E} (w : V) :\n    Integrable (fun v : V â†¦ ğ (- âŸªv, wâŸ«) â€¢ f v) Î¼ â†” Integrable f Î¼ :=\n  fourierIntegral_convergent_iff' (innerSL â„) w\n\n"}
{"name":"Real.fourierIntegral_eq","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : FiniteDimensional Real V\nf : V â†’ E\nw : V\nâŠ¢ Eq (Real.fourierIntegral f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (f v))","decl":"lemma fourierIntegral_eq (f : V â†’ E) (w : V) :\n    ğ“• f w = âˆ« v, ğ (-âŸªv, wâŸ«) â€¢ f v := rfl\n\n"}
{"name":"Real.fourierIntegral_eq'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : FiniteDimensional Real V\nf : V â†’ E\nw : V\nâŠ¢ Eq (Real.fourierIntegral f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Complex.exp (HMul.hMul (â†‘(HMul.hMul (HMul.hMul (-2) Real.pi) (Inner.inner v w))) Complex.I)) (f v))","decl":"lemma fourierIntegral_eq' (f : V â†’ E) (w : V) :\n    ğ“• f w = âˆ« v, Complex.exp ((â†‘(-2 * Ï€ * âŸªv, wâŸ«) * Complex.I)) â€¢ f v := by\n  simp_rw [fourierIntegral_eq, Circle.smul_def, Real.fourierChar_apply, mul_neg, neg_mul]\n\n"}
{"name":"Real.fourierIntegralInv_eq","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : FiniteDimensional Real V\nf : V â†’ E\nw : V\nâŠ¢ Eq (Real.fourierIntegralInv f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Inner.inner v w)) (f v))","decl":"lemma fourierIntegralInv_eq (f : V â†’ E) (w : V) :\n    ğ“•â» f w = âˆ« v, ğ âŸªv, wâŸ« â€¢ f v := by\n  simp [fourierIntegralInv, VectorFourier.fourierIntegral]\n\n"}
{"name":"Real.fourierIntegralInv_eq'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : FiniteDimensional Real V\nf : V â†’ E\nw : V\nâŠ¢ Eq (Real.fourierIntegralInv f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Complex.exp (HMul.hMul (â†‘(HMul.hMul (HMul.hMul 2 Real.pi) (Inner.inner v w))) Complex.I)) (f v))","decl":"lemma fourierIntegralInv_eq' (f : V â†’ E) (w : V) :\n    ğ“•â» f w = âˆ« v, Complex.exp ((â†‘(2 * Ï€ * âŸªv, wâŸ«) * Complex.I)) â€¢ f v := by\n  simp_rw [fourierIntegralInv_eq, Circle.smul_def, Real.fourierChar_apply]\n\n"}
{"name":"Real.fourierIntegral_comp_linearIsometry","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace Complex E\nV : Type u_2\ninstâœâ¹ : NormedAddCommGroup V\ninstâœâ¸ : InnerProductSpace Real V\ninstâœâ· : MeasurableSpace V\ninstâœâ¶ : BorelSpace V\nW : Type u_3\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : InnerProductSpace Real W\ninstâœÂ³ : MeasurableSpace W\ninstâœÂ² : BorelSpace W\ninstâœÂ¹ : FiniteDimensional Real W\ninstâœ : FiniteDimensional Real V\nA : LinearIsometryEquiv (RingHom.id Real) W V\nf : V â†’ E\nw : W\nâŠ¢ Eq (Real.fourierIntegral (Function.comp f â‡‘A) w) (Real.fourierIntegral f (A w))","decl":"lemma fourierIntegral_comp_linearIsometry (A : W â‰ƒâ‚—áµ¢[â„] V) (f : V â†’ E) (w : W) :\n    ğ“• (f âˆ˜ A) w = (ğ“• f) (A w) := by\n  simp only [fourierIntegral_eq, â† A.inner_map_map, Function.comp_apply,\n    â† MeasurePreserving.integral_comp A.measurePreserving A.toHomeomorph.measurableEmbedding]\n\n"}
{"name":"Real.fourierIntegralInv_eq_fourierIntegral_neg","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : FiniteDimensional Real V\nf : V â†’ E\nw : V\nâŠ¢ Eq (Real.fourierIntegralInv f w) (Real.fourierIntegral f (Neg.neg w))","decl":"lemma fourierIntegralInv_eq_fourierIntegral_neg (f : V â†’ E) (w : V) :\n    ğ“•â» f w = ğ“• f (-w) := by\n  simp [fourierIntegral_eq, fourierIntegralInv_eq]\n\n"}
{"name":"Real.fourierIntegralInv_eq_fourierIntegral_comp_neg","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : FiniteDimensional Real V\nf : V â†’ E\nâŠ¢ Eq (Real.fourierIntegralInv f) (Real.fourierIntegral fun x => f (Neg.neg x))","decl":"lemma fourierIntegralInv_eq_fourierIntegral_comp_neg (f : V â†’ E) :\n    ğ“•â» f = ğ“• (fun x â†¦ f (-x)) := by\n  ext y\n  rw [fourierIntegralInv_eq_fourierIntegral_neg]\n  change ğ“• f (LinearIsometryEquiv.neg â„ y) = ğ“• (f âˆ˜ LinearIsometryEquiv.neg â„) y\n  exact (fourierIntegral_comp_linearIsometry _ _ _).symm\n\n"}
{"name":"Real.fourierIntegralInv_comm","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nV : Type u_2\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : InnerProductSpace Real V\ninstâœÂ² : MeasurableSpace V\ninstâœÂ¹ : BorelSpace V\ninstâœ : FiniteDimensional Real V\nf : V â†’ E\nâŠ¢ Eq (Real.fourierIntegral (Real.fourierIntegralInv f)) (Real.fourierIntegralInv (Real.fourierIntegral f))","decl":"lemma fourierIntegralInv_comm (f : V â†’ E) :\n    ğ“• (ğ“•â» f) = ğ“•â» (ğ“• f) := by\n  conv_rhs => rw [fourierIntegralInv_eq_fourierIntegral_comp_neg]\n  simp_rw [â† fourierIntegralInv_eq_fourierIntegral_neg]\n\n"}
{"name":"Real.fourierIntegralInv_comp_linearIsometry","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace Complex E\nV : Type u_2\ninstâœâ¹ : NormedAddCommGroup V\ninstâœâ¸ : InnerProductSpace Real V\ninstâœâ· : MeasurableSpace V\ninstâœâ¶ : BorelSpace V\nW : Type u_3\ninstâœâµ : NormedAddCommGroup W\ninstâœâ´ : InnerProductSpace Real W\ninstâœÂ³ : MeasurableSpace W\ninstâœÂ² : BorelSpace W\ninstâœÂ¹ : FiniteDimensional Real W\ninstâœ : FiniteDimensional Real V\nA : LinearIsometryEquiv (RingHom.id Real) W V\nf : V â†’ E\nw : W\nâŠ¢ Eq (Real.fourierIntegralInv (Function.comp f â‡‘A) w) (Real.fourierIntegralInv f (A w))","decl":"lemma fourierIntegralInv_comp_linearIsometry (A : W â‰ƒâ‚—áµ¢[â„] V) (f : V â†’ E) (w : W) :\n    ğ“•â» (f âˆ˜ A) w = (ğ“•â» f) (A w) := by\n  simp [fourierIntegralInv_eq_fourierIntegral_neg, fourierIntegral_comp_linearIsometry]\n\n"}
{"name":"Real.fourierIntegral_real_eq","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\nw : Real\nâŠ¢ Eq (Real.fourierIntegral f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (HMul.hMul v w))) (f v))","decl":"theorem fourierIntegral_real_eq (f : â„ â†’ E) (w : â„) :\n    fourierIntegral f w = âˆ« v : â„, ğ (-(v * w)) â€¢ f v :=\n  rfl\n\n"}
{"name":"Real.fourierIntegral_real_eq_integral_exp_smul","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\nw : Real\nâŠ¢ Eq (Real.fourierIntegral f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Complex.exp (HMul.hMul (â†‘(HMul.hMul (HMul.hMul (HMul.hMul (-2) Real.pi) v) w)) Complex.I)) (f v))","decl":"theorem fourierIntegral_real_eq_integral_exp_smul (f : â„ â†’ E) (w : â„) :\n    ğ“• f w = âˆ« v : â„, Complex.exp (â†‘(-2 * Ï€ * v * w) * Complex.I) â€¢ f v := by\n  simp_rw [fourierIntegral_real_eq, Circle.smul_def, Real.fourierChar_apply, mul_neg, neg_mul,\n    mul_assoc]\n\n"}
{"name":"Real.fourierIntegral_continuousLinearMap_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Complex E\nV : Type u_2\ninstâœâ¶ : NormedAddCommGroup V\ninstâœâµ : InnerProductSpace Real V\ninstâœâ´ : MeasurableSpace V\ninstâœÂ³ : BorelSpace V\ninstâœÂ² : FiniteDimensional Real V\nF : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : V â†’ ContinuousLinearMap (RingHom.id Real) F E\na : F\nv : V\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((Real.fourierIntegral f v) a) (Real.fourierIntegral (fun x => (f x) a) v)","decl":"theorem fourierIntegral_continuousLinearMap_apply\n    {F : Type*} [NormedAddCommGroup F] [NormedSpace â„ F]\n    {f : V â†’ (F â†’L[â„] E)} {a : F} {v : V} (hf : Integrable f) :\n    ğ“• f v a = ğ“• (fun x â†¦ f x a) v :=\n  fourierIntegral_continuousLinearMap_apply' (L := innerSL â„) hf\n\n"}
{"name":"Real.fourierIntegral_continuousMultilinearMap_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Complex E\nV : Type u_2\ninstâœâ· : NormedAddCommGroup V\ninstâœâ¶ : InnerProductSpace Real V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : FiniteDimensional Real V\nÎ¹ : Type u_4\ninstâœÂ² : Fintype Î¹\nM : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœ : (i : Î¹) â†’ NormedSpace Real (M i)\nf : V â†’ ContinuousMultilinearMap Real M E\nm : (i : Î¹) â†’ M i\nv : V\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((Real.fourierIntegral f v) m) (Real.fourierIntegral (fun x => (f x) m) v)","decl":"theorem fourierIntegral_continuousMultilinearMap_apply {Î¹ : Type*} [Fintype Î¹]\n    {M : Î¹ â†’ Type*} [âˆ€ i, NormedAddCommGroup (M i)] [âˆ€ i, NormedSpace â„ (M i)]\n    {f : V â†’ ContinuousMultilinearMap â„ M E} {m : (i : Î¹) â†’ M i} {v : V} (hf : Integrable f) :\n    ğ“• f v m = ğ“• (fun x â†¦ f x m) v :=\n  fourierIntegral_continuousMultilinearMap_apply' (L := innerSL â„) hf\n\n"}
