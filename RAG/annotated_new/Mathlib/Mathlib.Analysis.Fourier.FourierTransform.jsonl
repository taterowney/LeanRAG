{"name":"VectorFourier.fourierIntegral_const_smul","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : CommRing 𝕜\nV : Type u_2\ninst✝⁶ : AddCommGroup V\ninst✝⁵ : Module 𝕜 V\ninst✝⁴ : MeasurableSpace V\nW : Type u_3\ninst✝³ : AddCommGroup W\ninst✝² : Module 𝕜 W\nE : Type u_4\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id 𝕜) V (LinearMap (RingHom.id 𝕜) W 𝕜)\nf : V → E\nr : Complex\n⊢ Eq (VectorFourier.fourierIntegral e μ L (HSMul.hSMul r f)) (HSMul.hSMul r (VectorFourier.fourierIntegral e μ L f))","decl":"theorem fourierIntegral_const_smul (e : AddChar 𝕜 𝕊) (μ : Measure V)\n    (L : V →ₗ[𝕜] W →ₗ[𝕜] 𝕜) (f : V → E) (r : ℂ) :\n    fourierIntegral e μ L (r • f) = r • fourierIntegral e μ L f := by\n  ext1 w\n  simp only [Pi.smul_apply, fourierIntegral, smul_comm _ r, integral_smul]\n\n"}
{"name":"VectorFourier.norm_fourierIntegral_le_integral_norm","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : CommRing 𝕜\nV : Type u_2\ninst✝⁶ : AddCommGroup V\ninst✝⁵ : Module 𝕜 V\ninst✝⁴ : MeasurableSpace V\nW : Type u_3\ninst✝³ : AddCommGroup W\ninst✝² : Module 𝕜 W\nE : Type u_4\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id 𝕜) V (LinearMap (RingHom.id 𝕜) W 𝕜)\nf : V → E\nw : W\n⊢ LE.le (Norm.norm (VectorFourier.fourierIntegral e μ L f w)) (MeasureTheory.integral μ fun v => Norm.norm (f v))","decl":"/-- The uniform norm of the Fourier integral of `f` is bounded by the `L¹` norm of `f`. -/\ntheorem norm_fourierIntegral_le_integral_norm (e : AddChar 𝕜 𝕊) (μ : Measure V)\n    (L : V →ₗ[𝕜] W →ₗ[𝕜] 𝕜) (f : V → E) (w : W) :\n    ‖fourierIntegral e μ L f w‖ ≤ ∫ v : V, ‖f v‖ ∂μ := by\n  refine (norm_integral_le_integral_norm _).trans (le_of_eq ?_)\n  simp_rw [Circle.norm_smul]\n\n"}
{"name":"VectorFourier.fourierIntegral_comp_add_right","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : CommRing 𝕜\nV : Type u_2\ninst✝⁸ : AddCommGroup V\ninst✝⁷ : Module 𝕜 V\ninst✝⁶ : MeasurableSpace V\nW : Type u_3\ninst✝⁵ : AddCommGroup W\ninst✝⁴ : Module 𝕜 W\nE : Type u_4\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\ninst✝¹ : MeasurableAdd V\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\ninst✝ : μ.IsAddRightInvariant\nL : LinearMap (RingHom.id 𝕜) V (LinearMap (RingHom.id 𝕜) W 𝕜)\nf : V → E\nv₀ : V\n⊢ Eq (VectorFourier.fourierIntegral e μ L (Function.comp f fun v => HAdd.hAdd v v₀)) fun w => HSMul.hSMul (e ((L v₀) w)) (VectorFourier.fourierIntegral e μ L f w)","decl":"/-- The Fourier integral converts right-translation into scalar multiplication by a phase factor. -/\ntheorem fourierIntegral_comp_add_right [MeasurableAdd V] (e : AddChar 𝕜 𝕊) (μ : Measure V)\n    [μ.IsAddRightInvariant] (L : V →ₗ[𝕜] W →ₗ[𝕜] 𝕜) (f : V → E) (v₀ : V) :\n    fourierIntegral e μ L (f ∘ fun v ↦ v + v₀) =\n      fun w ↦ e (L v₀ w) • fourierIntegral e μ L f w := by\n  ext1 w\n  dsimp only [fourierIntegral, Function.comp_apply, Circle.smul_def]\n  conv in L _ => rw [← add_sub_cancel_right v v₀]\n  rw [integral_add_right_eq_self fun v : V ↦ (e (-L (v - v₀) w) : ℂ) • f v, ← integral_smul]\n  congr 1 with v\n  rw [← smul_assoc, smul_eq_mul, ← Circle.coe_mul, ← e.map_add_eq_mul, ← LinearMap.neg_apply,\n    ← sub_eq_add_neg, ← LinearMap.sub_apply, LinearMap.map_sub, neg_sub]\n\n"}
{"name":"VectorFourier.fourierIntegral_convergent_iff","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝¹² : CommRing 𝕜\nV : Type u_2\ninst✝¹¹ : AddCommGroup V\ninst✝¹⁰ : Module 𝕜 V\ninst✝⁹ : MeasurableSpace V\nW : Type u_3\ninst✝⁸ : AddCommGroup W\ninst✝⁷ : Module 𝕜 W\nE : Type u_4\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : TopologicalRing 𝕜\ninst✝² : TopologicalSpace V\ninst✝¹ : BorelSpace V\ninst✝ : TopologicalSpace W\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id 𝕜) V (LinearMap (RingHom.id 𝕜) W 𝕜)\nhe : Continuous ⇑e\nhL : Continuous fun p => (L p.1) p.2\nf : V → E\nw : W\n⊢ Iff (MeasureTheory.Integrable (fun v => HSMul.hSMul (e (Neg.neg ((L v) w))) (f v)) μ) (MeasureTheory.Integrable f μ)","decl":"/-- For any `w`, the Fourier integral is convergent iff `f` is integrable. -/\ntheorem fourierIntegral_convergent_iff (he : Continuous e)\n    (hL : Continuous fun p : V × W ↦ L p.1 p.2) {f : V → E} (w : W) :\n    Integrable (fun v : V ↦ e (-L v w) • f v) μ ↔ Integrable f μ := by\n  -- first prove one-way implication\n  have aux {g : V → E} (hg : Integrable g μ) (x : W) :\n      Integrable (fun v : V ↦ e (-L v x) • g v) μ := by\n    have c : Continuous fun v ↦ e (-L v x) :=\n      he.comp (hL.comp (continuous_prod_mk.mpr ⟨continuous_id, continuous_const⟩)).neg\n    simp_rw [← integrable_norm_iff (c.aestronglyMeasurable.smul hg.1), Circle.norm_smul]\n    exact hg.norm\n  -- then use it for both directions\n  refine ⟨fun hf ↦ ?_, fun hf ↦ aux hf w⟩\n  have := aux hf (-w)\n  simp_rw [← mul_smul (e _) (e _) (f _), ← e.map_add_eq_mul, LinearMap.map_neg, neg_add_cancel,\n    e.map_zero_eq_one, one_smul] at this -- the `(e _)` speeds up elaboration considerably\n  exact this\n\n"}
{"name":"VectorFourier.fourierIntegral_add","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝¹² : CommRing 𝕜\nV : Type u_2\ninst✝¹¹ : AddCommGroup V\ninst✝¹⁰ : Module 𝕜 V\ninst✝⁹ : MeasurableSpace V\nW : Type u_3\ninst✝⁸ : AddCommGroup W\ninst✝⁷ : Module 𝕜 W\nE : Type u_4\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : TopologicalRing 𝕜\ninst✝² : TopologicalSpace V\ninst✝¹ : BorelSpace V\ninst✝ : TopologicalSpace W\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id 𝕜) V (LinearMap (RingHom.id 𝕜) W 𝕜)\nhe : Continuous ⇑e\nhL : Continuous fun p => (L p.1) p.2\nf g : V → E\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ Eq (VectorFourier.fourierIntegral e μ L (HAdd.hAdd f g)) (HAdd.hAdd (VectorFourier.fourierIntegral e μ L f) (VectorFourier.fourierIntegral e μ L g))","decl":"theorem fourierIntegral_add (he : Continuous e) (hL : Continuous fun p : V × W ↦ L p.1 p.2)\n    {f g : V → E} (hf : Integrable f μ) (hg : Integrable g μ) :\n    fourierIntegral e μ L (f + g) = fourierIntegral e μ L f + fourierIntegral e μ L g := by\n  ext1 w\n  dsimp only [Pi.add_apply, fourierIntegral]\n  simp_rw [smul_add]\n  rw [integral_add]\n  · exact (fourierIntegral_convergent_iff he hL w).2 hf\n  · exact (fourierIntegral_convergent_iff he hL w).2 hg\n\n"}
{"name":"VectorFourier.fourierIntegral_continuous","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝¹³ : CommRing 𝕜\nV : Type u_2\ninst✝¹² : AddCommGroup V\ninst✝¹¹ : Module 𝕜 V\ninst✝¹⁰ : MeasurableSpace V\nW : Type u_3\ninst✝⁹ : AddCommGroup W\ninst✝⁸ : Module 𝕜 W\nE : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Complex E\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : TopologicalRing 𝕜\ninst✝³ : TopologicalSpace V\ninst✝² : BorelSpace V\ninst✝¹ : TopologicalSpace W\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id 𝕜) V (LinearMap (RingHom.id 𝕜) W 𝕜)\ninst✝ : FirstCountableTopology W\nhe : Continuous ⇑e\nhL : Continuous fun p => (L p.1) p.2\nf : V → E\nhf : MeasureTheory.Integrable f μ\n⊢ Continuous (VectorFourier.fourierIntegral e μ L f)","decl":"/-- The Fourier integral of an `L^1` function is a continuous function. -/\ntheorem fourierIntegral_continuous [FirstCountableTopology W] (he : Continuous e)\n    (hL : Continuous fun p : V × W ↦ L p.1 p.2) {f : V → E} (hf : Integrable f μ) :\n    Continuous (fourierIntegral e μ L f) := by\n  apply continuous_of_dominated\n  · exact fun w ↦ ((fourierIntegral_convergent_iff he hL w).2 hf).1\n  · exact fun w ↦ ae_of_all _ fun v ↦ le_of_eq (Circle.norm_smul _ _)\n  · exact hf.norm\n  · refine ae_of_all _ fun v ↦ (he.comp ?_).smul continuous_const\n    exact (hL.comp (continuous_prod_mk.mpr ⟨continuous_const, continuous_id⟩)).neg\n\n"}
{"name":"VectorFourier.integral_bilin_fourierIntegral_eq_flip","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝²³ : CommRing 𝕜\nV : Type u_2\ninst✝²² : AddCommGroup V\ninst✝²¹ : Module 𝕜 V\ninst✝²⁰ : MeasurableSpace V\nW : Type u_3\ninst✝¹⁹ : AddCommGroup W\ninst✝¹⁸ : Module 𝕜 W\nE : Type u_4\nF : Type u_5\nG : Type u_6\ninst✝¹⁷ : NormedAddCommGroup E\ninst✝¹⁶ : NormedSpace Complex E\ninst✝¹⁵ : NormedAddCommGroup F\ninst✝¹⁴ : NormedSpace Complex F\ninst✝¹³ : NormedAddCommGroup G\ninst✝¹² : NormedSpace Complex G\ninst✝¹¹ : TopologicalSpace 𝕜\ninst✝¹⁰ : TopologicalRing 𝕜\ninst✝⁹ : TopologicalSpace V\ninst✝⁸ : BorelSpace V\ninst✝⁷ : TopologicalSpace W\ninst✝⁶ : MeasurableSpace W\ninst✝⁵ : BorelSpace W\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id 𝕜) V (LinearMap (RingHom.id 𝕜) W 𝕜)\nν : MeasureTheory.Measure W\ninst✝⁴ : MeasureTheory.SigmaFinite μ\ninst✝³ : MeasureTheory.SigmaFinite ν\ninst✝² : SecondCountableTopology V\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nf : V → E\ng : W → F\nM : ContinuousLinearMap (RingHom.id Complex) E (ContinuousLinearMap (RingHom.id Complex) F G)\nhe : Continuous ⇑e\nhL : Continuous fun p => (L p.1) p.2\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g ν\n⊢ Eq (MeasureTheory.integral ν fun ξ => (M (VectorFourier.fourierIntegral e μ L f ξ)) (g ξ)) (MeasureTheory.integral μ fun x => (M (f x)) (VectorFourier.fourierIntegral e ν L.flip g x))","decl":"/-- The Fourier transform satisfies `∫ 𝓕 f * g = ∫ f * 𝓕 g`, i.e., it is self-adjoint.\nVersion where the multiplication is replaced by a general bilinear form `M`. -/\ntheorem integral_bilin_fourierIntegral_eq_flip\n    {f : V → E} {g : W → F} (M : E →L[ℂ] F →L[ℂ] G) (he : Continuous e)\n    (hL : Continuous fun p : V × W ↦ L p.1 p.2) (hf : Integrable f μ) (hg : Integrable g ν) :\n    ∫ ξ, M (fourierIntegral e μ L f ξ) (g ξ) ∂ν =\n      ∫ x, M (f x) (fourierIntegral e ν L.flip g x) ∂μ := by\n  by_cases hG : CompleteSpace G; swap; · simp [integral, hG]\n  calc\n  _ = ∫ ξ, M.flip (g ξ) (∫ x, e (-L x ξ) • f x ∂μ) ∂ν := rfl\n  _ = ∫ ξ, (∫ x, M.flip (g ξ) (e (-L x ξ) • f x) ∂μ) ∂ν := by\n    congr with ξ\n    apply (ContinuousLinearMap.integral_comp_comm _ _).symm\n    exact (fourierIntegral_convergent_iff he hL _).2 hf\n  _ = ∫ x, (∫ ξ, M.flip (g ξ) (e (-L x ξ) • f x) ∂ν) ∂μ := by\n    rw [integral_integral_swap]\n    have : Integrable (fun (p : W × V) ↦ ‖M‖ * (‖g p.1‖ * ‖f p.2‖)) (ν.prod μ) :=\n      (hg.norm.prod_mul hf.norm).const_mul _\n    apply this.mono\n    · -- This proof can be golfed but becomes very slow; breaking it up into steps\n      -- speeds up compilation.\n      change AEStronglyMeasurable (fun p : W × V ↦ (M (e (-(L p.2) p.1) • f p.2) (g p.1))) _\n      have A : AEStronglyMeasurable (fun (p : W × V) ↦ e (-L p.2 p.1) • f p.2) (ν.prod μ) := by\n        refine (Continuous.aestronglyMeasurable ?_).smul hf.1.snd\n        exact he.comp (hL.comp continuous_swap).neg\n      have A' : AEStronglyMeasurable (fun p ↦ (g p.1, e (-(L p.2) p.1) • f p.2) : W × V → F × E)\n        (Measure.prod ν μ) := hg.1.fst.prod_mk A\n      have B : Continuous (fun q ↦ M q.2 q.1 : F × E → G) := M.flip.continuous₂\n      apply B.comp_aestronglyMeasurable A' -- `exact` works, but `apply` is 10x faster!\n    · filter_upwards with ⟨ξ, x⟩\n      rw [Function.uncurry_apply_pair, Submonoid.smul_def, (M.flip (g ξ)).map_smul,\n        ← Submonoid.smul_def, Circle.norm_smul, ContinuousLinearMap.flip_apply,\n        norm_mul, norm_norm M, norm_mul, norm_norm, norm_norm, mul_comm (‖g _‖), ← mul_assoc]\n      exact M.le_opNorm₂ (f x) (g ξ)\n  _ = ∫ x, (∫ ξ, M (f x) (e (-L.flip ξ x) • g ξ) ∂ν) ∂μ := by\n      simp only [ContinuousLinearMap.flip_apply, ContinuousLinearMap.map_smul_of_tower,\n      ContinuousLinearMap.coe_smul', Pi.smul_apply, LinearMap.flip_apply]\n  _ = ∫ x, M (f x) (∫ ξ, e (-L.flip ξ x) • g ξ ∂ν) ∂μ := by\n    congr with x\n    apply ContinuousLinearMap.integral_comp_comm\n    apply (fourierIntegral_convergent_iff he _ _).2 hg\n    exact hL.comp continuous_swap\n\n"}
{"name":"VectorFourier.integral_fourierIntegral_smul_eq_flip","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝¹⁸ : CommRing 𝕜\nV : Type u_2\ninst✝¹⁷ : AddCommGroup V\ninst✝¹⁶ : Module 𝕜 V\ninst✝¹⁵ : MeasurableSpace V\nW : Type u_3\ninst✝¹⁴ : AddCommGroup W\ninst✝¹³ : Module 𝕜 W\nF : Type u_5\ninst✝¹² : NormedAddCommGroup F\ninst✝¹¹ : NormedSpace Complex F\ninst✝¹⁰ : TopologicalSpace 𝕜\ninst✝⁹ : TopologicalRing 𝕜\ninst✝⁸ : TopologicalSpace V\ninst✝⁷ : BorelSpace V\ninst✝⁶ : TopologicalSpace W\ninst✝⁵ : MeasurableSpace W\ninst✝⁴ : BorelSpace W\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\nL : LinearMap (RingHom.id 𝕜) V (LinearMap (RingHom.id 𝕜) W 𝕜)\nν : MeasureTheory.Measure W\ninst✝³ : MeasureTheory.SigmaFinite μ\ninst✝² : MeasureTheory.SigmaFinite ν\ninst✝¹ : SecondCountableTopology V\ninst✝ : CompleteSpace F\nf : V → Complex\ng : W → F\nhe : Continuous ⇑e\nhL : Continuous fun p => (L p.1) p.2\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g ν\n⊢ Eq (MeasureTheory.integral ν fun ξ => HSMul.hSMul (VectorFourier.fourierIntegral e μ L f ξ) (g ξ)) (MeasureTheory.integral μ fun x => HSMul.hSMul (f x) (VectorFourier.fourierIntegral e ν L.flip g x))","decl":"/-- The Fourier transform satisfies `∫ 𝓕 f * g = ∫ f * 𝓕 g`, i.e., it is self-adjoint. -/\ntheorem integral_fourierIntegral_smul_eq_flip\n    {f : V → ℂ} {g : W → F} (he : Continuous e)\n    (hL : Continuous fun p : V × W ↦ L p.1 p.2) (hf : Integrable f μ) (hg : Integrable g ν) :\n    ∫ ξ, (fourierIntegral e μ L f ξ) • (g ξ) ∂ν =\n      ∫ x, (f x) • (fourierIntegral e ν L.flip g x) ∂μ :=\n  integral_bilin_fourierIntegral_eq_flip (ContinuousLinearMap.lsmul ℂ ℂ) he hL hf hg\n\n"}
{"name":"VectorFourier.fourierIntegral_continuousLinearMap_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nF : Type u_4\nV : Type u_5\nW : Type u_6\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedAddCommGroup V\ninst✝⁸ : NormedSpace 𝕜 V\ninst✝⁷ : MeasurableSpace V\ninst✝⁶ : BorelSpace V\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace 𝕜 W\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\nL : ContinuousLinearMap (RingHom.id 𝕜) V (ContinuousLinearMap (RingHom.id 𝕜) W 𝕜)\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : V → ContinuousLinearMap (RingHom.id Real) F E\na : F\nw : W\nhe : Continuous ⇑e\nhf : MeasureTheory.Integrable f μ\n⊢ Eq ((VectorFourier.fourierIntegral e μ L.toLinearMap₂ f w) a) (VectorFourier.fourierIntegral e μ L.toLinearMap₂ (fun x => (f x) a) w)","decl":"theorem fourierIntegral_continuousLinearMap_apply\n    {f : V → (F →L[ℝ] E)} {a : F} {w : W} (he : Continuous e) (hf : Integrable f μ) :\n    fourierIntegral e μ L.toLinearMap₂ f w a =\n      fourierIntegral e μ L.toLinearMap₂ (fun x ↦ f x a) w := by\n  rw [fourierIntegral, ContinuousLinearMap.integral_apply]\n  · rfl\n  · apply (fourierIntegral_convergent_iff he _ _).2 hf\n    exact L.continuous₂\n\n"}
{"name":"VectorFourier.fourierIntegral_continuousMultilinearMap_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\nι : Type u_2\nE : Type u_3\nV : Type u_5\nW : Type u_6\ninst✝¹¹ : Fintype ι\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedAddCommGroup V\ninst✝⁸ : NormedSpace 𝕜 V\ninst✝⁷ : MeasurableSpace V\ninst✝⁶ : BorelSpace V\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedSpace 𝕜 W\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure V\nL : ContinuousLinearMap (RingHom.id 𝕜) V (ContinuousLinearMap (RingHom.id 𝕜) W 𝕜)\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\nM : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (M i)\ninst✝ : (i : ι) → NormedSpace Real (M i)\nf : V → ContinuousMultilinearMap Real M E\nm : (i : ι) → M i\nw : W\nhe : Continuous ⇑e\nhf : MeasureTheory.Integrable f μ\n⊢ Eq ((VectorFourier.fourierIntegral e μ L.toLinearMap₂ f w) m) (VectorFourier.fourierIntegral e μ L.toLinearMap₂ (fun x => (f x) m) w)","decl":"theorem fourierIntegral_continuousMultilinearMap_apply\n    {f : V → (ContinuousMultilinearMap ℝ M E)} {m : (i : ι) → M i} {w : W} (he : Continuous e)\n    (hf : Integrable f μ) :\n    fourierIntegral e μ L.toLinearMap₂ f w m =\n      fourierIntegral e μ L.toLinearMap₂ (fun x ↦ f x m) w := by\n  rw [fourierIntegral, ContinuousMultilinearMap.integral_apply]\n  · rfl\n  · apply (fourierIntegral_convergent_iff he _ _).2 hf\n    exact L.continuous₂\n\n"}
{"name":"Fourier.fourierIntegral_def","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝³ : CommRing 𝕜\ninst✝² : MeasurableSpace 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure 𝕜\nf : 𝕜 → E\nw : 𝕜\n⊢ Eq (Fourier.fourierIntegral e μ f w) (MeasureTheory.integral μ fun v => HSMul.hSMul (e (Neg.neg (HMul.hMul v w))) (f v))","decl":"theorem fourierIntegral_def (e : AddChar 𝕜 𝕊) (μ : Measure 𝕜) (f : 𝕜 → E) (w : 𝕜) :\n    fourierIntegral e μ f w = ∫ v : 𝕜, e (-(v * w)) • f v ∂μ :=\n  rfl\n\n"}
{"name":"Fourier.fourierIntegral_const_smul","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝³ : CommRing 𝕜\ninst✝² : MeasurableSpace 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure 𝕜\nf : 𝕜 → E\nr : Complex\n⊢ Eq (Fourier.fourierIntegral e μ (HSMul.hSMul r f)) (HSMul.hSMul r (Fourier.fourierIntegral e μ f))","decl":"theorem fourierIntegral_const_smul (e : AddChar 𝕜 𝕊) (μ : Measure 𝕜) (f : 𝕜 → E) (r : ℂ) :\n    fourierIntegral e μ (r • f) = r • fourierIntegral e μ f :=\n  VectorFourier.fourierIntegral_const_smul _ _ _ _ _\n\n"}
{"name":"Fourier.norm_fourierIntegral_le_integral_norm","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝³ : CommRing 𝕜\ninst✝² : MeasurableSpace 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure 𝕜\nf : 𝕜 → E\nw : 𝕜\n⊢ LE.le (Norm.norm (Fourier.fourierIntegral e μ f w)) (MeasureTheory.integral μ fun x => Norm.norm (f x))","decl":"/-- The uniform norm of the Fourier transform of `f` is bounded by the `L¹` norm of `f`. -/\ntheorem norm_fourierIntegral_le_integral_norm (e : AddChar 𝕜 𝕊) (μ : Measure 𝕜)\n    (f : 𝕜 → E) (w : 𝕜) : ‖fourierIntegral e μ f w‖ ≤ ∫ x : 𝕜, ‖f x‖ ∂μ :=\n  VectorFourier.norm_fourierIntegral_le_integral_norm _ _ _ _ _\n\n"}
{"name":"Fourier.fourierIntegral_comp_add_right","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : CommRing 𝕜\ninst✝⁴ : MeasurableSpace 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\ninst✝¹ : MeasurableAdd 𝕜\ne : AddChar 𝕜 Circle\nμ : MeasureTheory.Measure 𝕜\ninst✝ : μ.IsAddRightInvariant\nf : 𝕜 → E\nv₀ : 𝕜\n⊢ Eq (Fourier.fourierIntegral e μ (Function.comp f fun v => HAdd.hAdd v v₀)) fun w => HSMul.hSMul (e (HMul.hMul v₀ w)) (Fourier.fourierIntegral e μ f w)","decl":"/-- The Fourier transform converts right-translation into scalar multiplication by a phase\nfactor. -/\ntheorem fourierIntegral_comp_add_right [MeasurableAdd 𝕜] (e : AddChar 𝕜 𝕊) (μ : Measure 𝕜)\n    [μ.IsAddRightInvariant] (f : 𝕜 → E) (v₀ : 𝕜) :\n    fourierIntegral e μ (f ∘ fun v ↦ v + v₀) = fun w ↦ e (v₀ * w) • fourierIntegral e μ f w :=\n  VectorFourier.fourierIntegral_comp_add_right _ _ _ _ _\n\n"}
{"name":"Real.fourierChar_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"x : Real\n⊢ Eq (↑(Real.fourierChar x)) (Complex.exp (HMul.hMul (↑(HMul.hMul (HMul.hMul 2 Real.pi) x)) Complex.I))","decl":"theorem fourierChar_apply (x : ℝ) : 𝐞 x = Complex.exp (↑(2 * π * x) * Complex.I) :=\n  rfl\n\n"}
{"name":"Real.continuous_fourierChar","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"⊢ Continuous ⇑Real.fourierChar","decl":"@[continuity]\ntheorem continuous_fourierChar : Continuous 𝐞 := Circle.exp.continuous.comp (continuous_mul_left _)\n\n"}
{"name":"Real.vector_fourierIntegral_eq_integral_exp_smul","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module Real V\ninst✝² : MeasurableSpace V\nW : Type u_3\ninst✝¹ : AddCommGroup W\ninst✝ : Module Real W\nL : LinearMap (RingHom.id Real) V (LinearMap (RingHom.id Real) W Real)\nμ : MeasureTheory.Measure V\nf : V → E\nw : W\n⊢ Eq (VectorFourier.fourierIntegral Real.fourierChar μ L f w) (MeasureTheory.integral μ fun v => HSMul.hSMul (Complex.exp (HMul.hMul (↑(HMul.hMul (HMul.hMul (-2) Real.pi) ((L v) w))) Complex.I)) (f v))","decl":"theorem vector_fourierIntegral_eq_integral_exp_smul {V : Type*} [AddCommGroup V] [Module ℝ V]\n    [MeasurableSpace V] {W : Type*} [AddCommGroup W] [Module ℝ W] (L : V →ₗ[ℝ] W →ₗ[ℝ] ℝ)\n    (μ : Measure V) (f : V → E) (w : W) :\n    VectorFourier.fourierIntegral fourierChar μ L f w =\n      ∫ v : V, Complex.exp (↑(-2 * π * L v w) * Complex.I) • f v ∂μ := by\n  simp_rw [VectorFourier.fourierIntegral, Circle.smul_def, Real.fourierChar_apply, mul_neg,\n    neg_mul]\n\n"}
{"name":"Real.fourierIntegral_convergent_iff'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Complex E\nV : Type u_2\nW : Type u_3\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : NormedSpace Real V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedSpace Real W\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nμ : MeasureTheory.Measure V\nf : V → E\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nw : W\n⊢ Iff (MeasureTheory.Integrable (fun v => HSMul.hSMul (Real.fourierChar (Neg.neg ((L v) w))) (f v)) μ) (MeasureTheory.Integrable f μ)","decl":"/-- The Fourier integral is well defined iff the function is integrable. Version with a general\ncontinuous bilinear function `L`. For the specialization to the inner product in an inner product\nspace, see `Real.fourierIntegral_convergent_iff`. -/\n@[simp]\ntheorem fourierIntegral_convergent_iff' {V W : Type*} [NormedAddCommGroup V] [NormedSpace ℝ V]\n    [NormedAddCommGroup W] [NormedSpace ℝ W] [MeasurableSpace V] [BorelSpace V] {μ : Measure V}\n    {f : V → E} (L : V →L[ℝ] W →L[ℝ] ℝ) (w : W) :\n    Integrable (fun v : V ↦ 𝐞 (- L v w) • f v) μ ↔ Integrable f μ :=\n  VectorFourier.fourierIntegral_convergent_iff (E := E) (L := L.toLinearMap₂)\n    continuous_fourierChar L.continuous₂ _\n\n"}
{"name":"Real.fourierIntegral_continuousLinearMap_apply'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Complex E\nF : Type u_3\nV : Type u_4\nW : Type u_5\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : NormedSpace Real V\ninst✝⁵ : MeasurableSpace V\ninst✝⁴ : BorelSpace V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedSpace Real W\nμ : MeasureTheory.Measure V\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : V → ContinuousLinearMap (RingHom.id Real) F E\na : F\nw : W\nhf : MeasureTheory.Integrable f μ\n⊢ Eq ((VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f w) a) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ (fun x => (f x) a) w)","decl":"theorem fourierIntegral_continuousLinearMap_apply'\n    {f : V → (F →L[ℝ] E)} {a : F} {w : W} (hf : Integrable f μ) :\n    VectorFourier.fourierIntegral 𝐞 μ L.toLinearMap₂ f w a =\n      VectorFourier.fourierIntegral 𝐞 μ L.toLinearMap₂ (fun x ↦ f x a) w :=\n  VectorFourier.fourierIntegral_continuousLinearMap_apply continuous_fourierChar hf\n\n"}
{"name":"Real.fourierIntegral_continuousMultilinearMap_apply'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedSpace Complex E\nι : Type u_2\nV : Type u_4\nW : Type u_5\ninst✝⁸ : Fintype ι\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : NormedSpace Real V\ninst✝⁵ : MeasurableSpace V\ninst✝⁴ : BorelSpace V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedSpace Real W\nμ : MeasureTheory.Measure V\nL : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) W Real)\nM : ι → Type u_6\ninst✝¹ : (i : ι) → NormedAddCommGroup (M i)\ninst✝ : (i : ι) → NormedSpace Real (M i)\nf : V → ContinuousMultilinearMap Real M E\nm : (i : ι) → M i\nw : W\nhf : MeasureTheory.Integrable f μ\n⊢ Eq ((VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ f w) m) (VectorFourier.fourierIntegral Real.fourierChar μ L.toLinearMap₂ (fun x => (f x) m) w)","decl":"theorem fourierIntegral_continuousMultilinearMap_apply'\n    {f : V → ContinuousMultilinearMap ℝ M E} {m : (i : ι) → M i} {w : W} (hf : Integrable f μ) :\n    VectorFourier.fourierIntegral 𝐞 μ L.toLinearMap₂ f w m =\n      VectorFourier.fourierIntegral 𝐞 μ L.toLinearMap₂ (fun x ↦ f x m) w :=\n  VectorFourier.fourierIntegral_continuousMultilinearMap_apply continuous_fourierChar hf\n\n"}
{"name":"Real.fourierIntegral_convergent_iff","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nV : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MeasurableSpace V\ninst✝ : BorelSpace V\nμ : MeasureTheory.Measure V\nf : V → E\nw : V\n⊢ Iff (MeasureTheory.Integrable (fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (f v)) μ) (MeasureTheory.Integrable f μ)","decl":"@[simp] theorem fourierIntegral_convergent_iff {μ : Measure V} {f : V → E} (w : V) :\n    Integrable (fun v : V ↦ 𝐞 (- ⟪v, w⟫) • f v) μ ↔ Integrable f μ :=\n  fourierIntegral_convergent_iff' (innerSL ℝ) w\n\n"}
{"name":"Real.fourierIntegral_eq","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : FiniteDimensional Real V\nf : V → E\nw : V\n⊢ Eq (Real.fourierIntegral f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (f v))","decl":"lemma fourierIntegral_eq (f : V → E) (w : V) :\n    𝓕 f w = ∫ v, 𝐞 (-⟪v, w⟫) • f v := rfl\n\n"}
{"name":"Real.fourierIntegral_eq'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : FiniteDimensional Real V\nf : V → E\nw : V\n⊢ Eq (Real.fourierIntegral f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Complex.exp (HMul.hMul (↑(HMul.hMul (HMul.hMul (-2) Real.pi) (Inner.inner v w))) Complex.I)) (f v))","decl":"lemma fourierIntegral_eq' (f : V → E) (w : V) :\n    𝓕 f w = ∫ v, Complex.exp ((↑(-2 * π * ⟪v, w⟫) * Complex.I)) • f v := by\n  simp_rw [fourierIntegral_eq, Circle.smul_def, Real.fourierChar_apply, mul_neg, neg_mul]\n\n"}
{"name":"Real.fourierIntegralInv_eq","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : FiniteDimensional Real V\nf : V → E\nw : V\n⊢ Eq (Real.fourierIntegralInv f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Inner.inner v w)) (f v))","decl":"lemma fourierIntegralInv_eq (f : V → E) (w : V) :\n    𝓕⁻ f w = ∫ v, 𝐞 ⟪v, w⟫ • f v := by\n  simp [fourierIntegralInv, VectorFourier.fourierIntegral]\n\n"}
{"name":"Real.fourierIntegralInv_eq'","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : FiniteDimensional Real V\nf : V → E\nw : V\n⊢ Eq (Real.fourierIntegralInv f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Complex.exp (HMul.hMul (↑(HMul.hMul (HMul.hMul 2 Real.pi) (Inner.inner v w))) Complex.I)) (f v))","decl":"lemma fourierIntegralInv_eq' (f : V → E) (w : V) :\n    𝓕⁻ f w = ∫ v, Complex.exp ((↑(2 * π * ⟪v, w⟫) * Complex.I)) • f v := by\n  simp_rw [fourierIntegralInv_eq, Circle.smul_def, Real.fourierChar_apply]\n\n"}
{"name":"Real.fourierIntegral_comp_linearIsometry","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace Complex E\nV : Type u_2\ninst✝⁹ : NormedAddCommGroup V\ninst✝⁸ : InnerProductSpace Real V\ninst✝⁷ : MeasurableSpace V\ninst✝⁶ : BorelSpace V\nW : Type u_3\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : InnerProductSpace Real W\ninst✝³ : MeasurableSpace W\ninst✝² : BorelSpace W\ninst✝¹ : FiniteDimensional Real W\ninst✝ : FiniteDimensional Real V\nA : LinearIsometryEquiv (RingHom.id Real) W V\nf : V → E\nw : W\n⊢ Eq (Real.fourierIntegral (Function.comp f ⇑A) w) (Real.fourierIntegral f (A w))","decl":"lemma fourierIntegral_comp_linearIsometry (A : W ≃ₗᵢ[ℝ] V) (f : V → E) (w : W) :\n    𝓕 (f ∘ A) w = (𝓕 f) (A w) := by\n  simp only [fourierIntegral_eq, ← A.inner_map_map, Function.comp_apply,\n    ← MeasurePreserving.integral_comp A.measurePreserving A.toHomeomorph.measurableEmbedding]\n\n"}
{"name":"Real.fourierIntegralInv_eq_fourierIntegral_neg","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : FiniteDimensional Real V\nf : V → E\nw : V\n⊢ Eq (Real.fourierIntegralInv f w) (Real.fourierIntegral f (Neg.neg w))","decl":"lemma fourierIntegralInv_eq_fourierIntegral_neg (f : V → E) (w : V) :\n    𝓕⁻ f w = 𝓕 f (-w) := by\n  simp [fourierIntegral_eq, fourierIntegralInv_eq]\n\n"}
{"name":"Real.fourierIntegralInv_eq_fourierIntegral_comp_neg","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : FiniteDimensional Real V\nf : V → E\n⊢ Eq (Real.fourierIntegralInv f) (Real.fourierIntegral fun x => f (Neg.neg x))","decl":"lemma fourierIntegralInv_eq_fourierIntegral_comp_neg (f : V → E) :\n    𝓕⁻ f = 𝓕 (fun x ↦ f (-x)) := by\n  ext y\n  rw [fourierIntegralInv_eq_fourierIntegral_neg]\n  change 𝓕 f (LinearIsometryEquiv.neg ℝ y) = 𝓕 (f ∘ LinearIsometryEquiv.neg ℝ) y\n  exact (fourierIntegral_comp_linearIsometry _ _ _).symm\n\n"}
{"name":"Real.fourierIntegralInv_comm","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Complex E\nV : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MeasurableSpace V\ninst✝¹ : BorelSpace V\ninst✝ : FiniteDimensional Real V\nf : V → E\n⊢ Eq (Real.fourierIntegral (Real.fourierIntegralInv f)) (Real.fourierIntegralInv (Real.fourierIntegral f))","decl":"lemma fourierIntegralInv_comm (f : V → E) :\n    𝓕 (𝓕⁻ f) = 𝓕⁻ (𝓕 f) := by\n  conv_rhs => rw [fourierIntegralInv_eq_fourierIntegral_comp_neg]\n  simp_rw [← fourierIntegralInv_eq_fourierIntegral_neg]\n\n"}
{"name":"Real.fourierIntegralInv_comp_linearIsometry","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace Complex E\nV : Type u_2\ninst✝⁹ : NormedAddCommGroup V\ninst✝⁸ : InnerProductSpace Real V\ninst✝⁷ : MeasurableSpace V\ninst✝⁶ : BorelSpace V\nW : Type u_3\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : InnerProductSpace Real W\ninst✝³ : MeasurableSpace W\ninst✝² : BorelSpace W\ninst✝¹ : FiniteDimensional Real W\ninst✝ : FiniteDimensional Real V\nA : LinearIsometryEquiv (RingHom.id Real) W V\nf : V → E\nw : W\n⊢ Eq (Real.fourierIntegralInv (Function.comp f ⇑A) w) (Real.fourierIntegralInv f (A w))","decl":"lemma fourierIntegralInv_comp_linearIsometry (A : W ≃ₗᵢ[ℝ] V) (f : V → E) (w : W) :\n    𝓕⁻ (f ∘ A) w = (𝓕⁻ f) (A w) := by\n  simp [fourierIntegralInv_eq_fourierIntegral_neg, fourierIntegral_comp_linearIsometry]\n\n"}
{"name":"Real.fourierIntegral_real_eq","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Real → E\nw : Real\n⊢ Eq (Real.fourierIntegral f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (HMul.hMul v w))) (f v))","decl":"theorem fourierIntegral_real_eq (f : ℝ → E) (w : ℝ) :\n    fourierIntegral f w = ∫ v : ℝ, 𝐞 (-(v * w)) • f v :=\n  rfl\n\n"}
{"name":"Real.fourierIntegral_real_eq_integral_exp_smul","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Real → E\nw : Real\n⊢ Eq (Real.fourierIntegral f w) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Complex.exp (HMul.hMul (↑(HMul.hMul (HMul.hMul (HMul.hMul (-2) Real.pi) v) w)) Complex.I)) (f v))","decl":"theorem fourierIntegral_real_eq_integral_exp_smul (f : ℝ → E) (w : ℝ) :\n    𝓕 f w = ∫ v : ℝ, Complex.exp (↑(-2 * π * v * w) * Complex.I) • f v := by\n  simp_rw [fourierIntegral_real_eq, Circle.smul_def, Real.fourierChar_apply, mul_neg, neg_mul,\n    mul_assoc]\n\n"}
{"name":"Real.fourierIntegral_continuousLinearMap_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Complex E\nV : Type u_2\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : InnerProductSpace Real V\ninst✝⁴ : MeasurableSpace V\ninst✝³ : BorelSpace V\ninst✝² : FiniteDimensional Real V\nF : Type u_4\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : V → ContinuousLinearMap (RingHom.id Real) F E\na : F\nv : V\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\n⊢ Eq ((Real.fourierIntegral f v) a) (Real.fourierIntegral (fun x => (f x) a) v)","decl":"theorem fourierIntegral_continuousLinearMap_apply\n    {F : Type*} [NormedAddCommGroup F] [NormedSpace ℝ F]\n    {f : V → (F →L[ℝ] E)} {a : F} {v : V} (hf : Integrable f) :\n    𝓕 f v a = 𝓕 (fun x ↦ f x a) v :=\n  fourierIntegral_continuousLinearMap_apply' (L := innerSL ℝ) hf\n\n"}
{"name":"Real.fourierIntegral_continuousMultilinearMap_apply","module":"Mathlib.Analysis.Fourier.FourierTransform","initialProofState":"E : Type u_1\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Complex E\nV : Type u_2\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : InnerProductSpace Real V\ninst✝⁵ : MeasurableSpace V\ninst✝⁴ : BorelSpace V\ninst✝³ : FiniteDimensional Real V\nι : Type u_4\ninst✝² : Fintype ι\nM : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (M i)\ninst✝ : (i : ι) → NormedSpace Real (M i)\nf : V → ContinuousMultilinearMap Real M E\nm : (i : ι) → M i\nv : V\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\n⊢ Eq ((Real.fourierIntegral f v) m) (Real.fourierIntegral (fun x => (f x) m) v)","decl":"theorem fourierIntegral_continuousMultilinearMap_apply {ι : Type*} [Fintype ι]\n    {M : ι → Type*} [∀ i, NormedAddCommGroup (M i)] [∀ i, NormedSpace ℝ (M i)]\n    {f : V → ContinuousMultilinearMap ℝ M E} {m : (i : ι) → M i} {v : V} (hf : Integrable f) :\n    𝓕 f v m = 𝓕 (fun x ↦ f x m) v :=\n  fourierIntegral_continuousMultilinearMap_apply' (L := innerSL ℝ) hf\n\n"}
