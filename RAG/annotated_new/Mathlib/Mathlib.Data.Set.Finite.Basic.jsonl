{"name":"Set.finite_def","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\n⊢ Iff s.Finite (Nonempty (Fintype ↑s))","decl":"theorem finite_def {s : Set α} : s.Finite ↔ Nonempty (Fintype s) :=\n  finite_iff_nonempty_fintype s\n\n"}
{"name":"Set.Finite.nonempty_fintype","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\na✝ : s.Finite\n⊢ Nonempty (Fintype ↑s)","decl":"protected alias ⟨Finite.nonempty_fintype, _⟩ := finite_def\n\n"}
{"name":"Set.Finite.ofFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\np : Set α\ns : Finset α\nH : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem p x)\n⊢ p.Finite","decl":"/-- Construct a `Finite` instance for a `Set` from a `Finset` with the same elements. -/\nprotected theorem Finite.ofFinset {p : Set α} (s : Finset α) (H : ∀ x, x ∈ s ↔ x ∈ p) : p.Finite :=\n  have := Fintype.ofFinset s H; p.toFinite\n\n"}
{"name":"Set.Finite.toFinset_eq_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\ninst✝ : Fintype ↑s\nh : s.Finite\n⊢ Eq h.toFinset s.toFinset","decl":"theorem Finite.toFinset_eq_toFinset {s : Set α} [Fintype s] (h : s.Finite) :\n    h.toFinset = s.toFinset := by\n  -- Porting note: was `rw [Finite.toFinset]; congr`\n  -- in Lean 4, a goal is left after `congr`\n  have : h.fintype = ‹_› := Subsingleton.elim _ _\n  rw [Finite.toFinset, this]\n\n"}
{"name":"Set.toFinite_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq ⋯.toFinset s.toFinset","decl":"@[simp]\ntheorem toFinite_toFinset (s : Set α) [Fintype s] : s.toFinite.toFinset = s.toFinset :=\n  s.toFinite.toFinset_eq_toFinset\n\n"}
{"name":"Set.Finite.exists_finset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nh : s.Finite\n⊢ Exists fun s' => ∀ (a : α), Iff (Membership.mem s' a) (Membership.mem s a)","decl":"theorem Finite.exists_finset {s : Set α} (h : s.Finite) :\n    ∃ s' : Finset α, ∀ a : α, a ∈ s' ↔ a ∈ s := by\n  cases h.nonempty_fintype\n  exact ⟨s.toFinset, fun _ => mem_toFinset⟩\n\n"}
{"name":"Set.Finite.exists_finset_coe","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nh : s.Finite\n⊢ Exists fun s' => Eq (↑s') s","decl":"theorem Finite.exists_finset_coe {s : Set α} (h : s.Finite) : ∃ s' : Finset α, ↑s' = s := by\n  cases h.nonempty_fintype\n  exact ⟨s.toFinset, s.coe_toFinset⟩\n\n"}
{"name":"Set.instCanLiftFinsetToSetFinite","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\n⊢ CanLift (Set α) (Finset α) Finset.toSet Set.Finite","decl":"/-- Finite sets can be lifted to finsets. -/\ninstance : CanLift (Set α) (Finset α) (↑) Set.Finite where prf _ hs := hs.exists_finset_coe\n\n"}
{"name":"Set.Finite.mem_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\na : α\nhs : s.Finite\n⊢ Iff (Membership.mem hs.toFinset a) (Membership.mem s a)","decl":"@[simp]\nprotected theorem mem_toFinset : a ∈ hs.toFinset ↔ a ∈ s :=\n  @mem_toFinset _ _ hs.fintype _\n\n"}
{"name":"Set.Finite.coe_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\n⊢ Eq (↑hs.toFinset) s","decl":"@[simp]\nprotected theorem coe_toFinset : (hs.toFinset : Set α) = s :=\n  @coe_toFinset _ _ hs.fintype\n\n"}
{"name":"Set.Finite.toFinset_nonempty","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\n⊢ Iff hs.toFinset.Nonempty s.Nonempty","decl":"@[simp]\nprotected theorem toFinset_nonempty : hs.toFinset.Nonempty ↔ s.Nonempty := by\n  rw [← Finset.coe_nonempty, Finite.coe_toFinset]\n\n"}
{"name":"Set.Finite.coeSort_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\n⊢ Eq (Subtype fun x => Membership.mem hs.toFinset x) ↑s","decl":"/-- Note that this is an equality of types not holding definitionally. Use wisely. -/\ntheorem coeSort_toFinset : ↥hs.toFinset = ↥s := by\n  rw [← Finset.coe_sort_coe _, hs.coe_toFinset]\n\n"}
{"name":"Set.Finite.subtypeEquivToFinset_symm_apply_coe","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\nb : Subtype fun b => Membership.mem hs.toFinset b\n⊢ Eq ↑(hs.subtypeEquivToFinset.symm b) ↑b","decl":"/-- The identity map, bundled as an equivalence between the subtypes of `s : Set α` and of\n`h.toFinset : Finset α`, where `h` is a proof of finiteness of `s`. -/\n@[simps!] def subtypeEquivToFinset : {x // x ∈ s} ≃ {x // x ∈ hs.toFinset} :=\n  (Equiv.refl α).subtypeEquiv fun _ ↦ hs.mem_toFinset.symm\n\n"}
{"name":"Set.Finite.subtypeEquivToFinset_apply_coe","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\na : Subtype fun a => Membership.mem s a\n⊢ Eq ↑(hs.subtypeEquivToFinset a) ↑a","decl":"/-- The identity map, bundled as an equivalence between the subtypes of `s : Set α` and of\n`h.toFinset : Finset α`, where `h` is a proof of finiteness of `s`. -/\n@[simps!] def subtypeEquivToFinset : {x // x ∈ s} ≃ {x // x ∈ hs.toFinset} :=\n  (Equiv.refl α).subtypeEquiv fun _ ↦ hs.mem_toFinset.symm\n\n"}
{"name":"Set.Finite.toFinset_inj","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Finite\nht : t.Finite\n⊢ Iff (Eq hs.toFinset ht.toFinset) (Eq s t)","decl":"@[simp]\nprotected theorem toFinset_inj : hs.toFinset = ht.toFinset ↔ s = t :=\n  @toFinset_inj _ _ _ hs.fintype ht.fintype\n\n"}
{"name":"Set.Finite.toFinset_subset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\nt : Finset α\n⊢ Iff (HasSubset.Subset hs.toFinset t) (HasSubset.Subset s ↑t)","decl":"@[simp]\ntheorem toFinset_subset {t : Finset α} : hs.toFinset ⊆ t ↔ s ⊆ t := by\n  rw [← Finset.coe_subset, Finite.coe_toFinset]\n\n"}
{"name":"Set.Finite.toFinset_ssubset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\nt : Finset α\n⊢ Iff (HasSSubset.SSubset hs.toFinset t) (HasSSubset.SSubset s ↑t)","decl":"@[simp]\ntheorem toFinset_ssubset {t : Finset α} : hs.toFinset ⊂ t ↔ s ⊂ t := by\n  rw [← Finset.coe_ssubset, Finite.coe_toFinset]\n\n"}
{"name":"Set.Finite.subset_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nt : Set α\nht : t.Finite\ns : Finset α\n⊢ Iff (HasSubset.Subset s ht.toFinset) (HasSubset.Subset (↑s) t)","decl":"@[simp]\ntheorem subset_toFinset {s : Finset α} : s ⊆ ht.toFinset ↔ ↑s ⊆ t := by\n  rw [← Finset.coe_subset, Finite.coe_toFinset]\n\n"}
{"name":"Set.Finite.ssubset_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nt : Set α\nht : t.Finite\ns : Finset α\n⊢ Iff (HasSSubset.SSubset s ht.toFinset) (HasSSubset.SSubset (↑s) t)","decl":"@[simp]\ntheorem ssubset_toFinset {s : Finset α} : s ⊂ ht.toFinset ↔ ↑s ⊂ t := by\n  rw [← Finset.coe_ssubset, Finite.coe_toFinset]\n\n"}
{"name":"Set.Finite.toFinset_subset_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Finite\nht : t.Finite\n⊢ Iff (HasSubset.Subset hs.toFinset ht.toFinset) (HasSubset.Subset s t)","decl":"@[mono]\nprotected theorem toFinset_subset_toFinset : hs.toFinset ⊆ ht.toFinset ↔ s ⊆ t := by\n  simp only [← Finset.coe_subset, Finite.coe_toFinset]\n\n"}
{"name":"Set.Finite.toFinset_ssubset_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Finite\nht : t.Finite\n⊢ Iff (HasSSubset.SSubset hs.toFinset ht.toFinset) (HasSSubset.SSubset s t)","decl":"@[mono]\nprotected theorem toFinset_ssubset_toFinset : hs.toFinset ⊂ ht.toFinset ↔ s ⊂ t := by\n  simp only [← Finset.coe_ssubset, Finite.coe_toFinset]\n\n"}
{"name":"Set.Finite.toFinset_mono","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Finite\nht : t.Finite\na✝ : HasSubset.Subset s t\n⊢ HasSubset.Subset hs.toFinset ht.toFinset","decl":"protected alias ⟨_, toFinset_mono⟩ := Finite.toFinset_subset_toFinset\n\n"}
{"name":"Set.Finite.toFinset_strictMono","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Finite\nht : t.Finite\na✝ : HasSSubset.SSubset s t\n⊢ HasSSubset.SSubset hs.toFinset ht.toFinset","decl":"protected alias ⟨_, toFinset_strictMono⟩ := Finite.toFinset_ssubset_toFinset\n\n-- Porting note: `simp` can simplify LHS but then it simplifies something\n-- in the generated `Fintype {x | p x}` instance and fails to apply `Set.toFinset_setOf`\n"}
{"name":"Set.Finite.toFinset_setOf","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\nh : (setOf fun x => p x).Finite\n⊢ Eq h.toFinset (Finset.filter p Finset.univ)","decl":"@[simp high]\nprotected theorem toFinset_setOf [Fintype α] (p : α → Prop) [DecidablePred p]\n    (h : { x | p x }.Finite) : h.toFinset = Finset.univ.filter p := by\n  ext\n  -- Porting note: `simp` doesn't use the `simp` lemma `Set.toFinset_setOf` without the `_`\n  simp [Set.toFinset_setOf _]\n\n"}
{"name":"Set.Finite.disjoint_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Finite\nht : t.Finite\n⊢ Iff (Disjoint hs.toFinset ht.toFinset) (Disjoint s t)","decl":"@[simp]\nnonrec theorem disjoint_toFinset {hs : s.Finite} {ht : t.Finite} :\n    Disjoint hs.toFinset ht.toFinset ↔ Disjoint s t :=\n  @disjoint_toFinset _ _ _ hs.fintype ht.fintype\n\n"}
{"name":"Set.Finite.toFinset_inter","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝ : DecidableEq α\nhs : s.Finite\nht : t.Finite\nh : (Inter.inter s t).Finite\n⊢ Eq h.toFinset (Inter.inter hs.toFinset ht.toFinset)","decl":"protected theorem toFinset_inter [DecidableEq α] (hs : s.Finite) (ht : t.Finite)\n    (h : (s ∩ t).Finite) : h.toFinset = hs.toFinset ∩ ht.toFinset := by\n  ext\n  simp\n\n"}
{"name":"Set.Finite.toFinset_union","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝ : DecidableEq α\nhs : s.Finite\nht : t.Finite\nh : (Union.union s t).Finite\n⊢ Eq h.toFinset (Union.union hs.toFinset ht.toFinset)","decl":"protected theorem toFinset_union [DecidableEq α] (hs : s.Finite) (ht : t.Finite)\n    (h : (s ∪ t).Finite) : h.toFinset = hs.toFinset ∪ ht.toFinset := by\n  ext\n  simp\n\n"}
{"name":"Set.Finite.toFinset_diff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝ : DecidableEq α\nhs : s.Finite\nht : t.Finite\nh : (SDiff.sdiff s t).Finite\n⊢ Eq h.toFinset (SDiff.sdiff hs.toFinset ht.toFinset)","decl":"protected theorem toFinset_diff [DecidableEq α] (hs : s.Finite) (ht : t.Finite)\n    (h : (s \\ t).Finite) : h.toFinset = hs.toFinset \\ ht.toFinset := by\n  ext\n  simp\n\n"}
{"name":"Set.Finite.toFinset_symmDiff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝ : DecidableEq α\nhs : s.Finite\nht : t.Finite\nh : (symmDiff s t).Finite\n⊢ Eq h.toFinset (symmDiff hs.toFinset ht.toFinset)","decl":"open scoped symmDiff in\nprotected theorem toFinset_symmDiff [DecidableEq α] (hs : s.Finite) (ht : t.Finite)\n    (h : (s ∆ t).Finite) : h.toFinset = hs.toFinset ∆ ht.toFinset := by\n  ext\n  simp [mem_symmDiff, Finset.mem_symmDiff]\n\n"}
{"name":"Set.Finite.toFinset_compl","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nhs : s.Finite\nh : (HasCompl.compl s).Finite\n⊢ Eq h.toFinset (HasCompl.compl hs.toFinset)","decl":"protected theorem toFinset_compl [DecidableEq α] [Fintype α] (hs : s.Finite) (h : sᶜ.Finite) :\n    h.toFinset = hs.toFinsetᶜ := by\n  ext\n  simp\n\n"}
{"name":"Set.Finite.toFinset_univ","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : Fintype α\nh : Set.univ.Finite\n⊢ Eq h.toFinset Finset.univ","decl":"protected theorem toFinset_univ [Fintype α] (h : (Set.univ : Set α).Finite) :\n    h.toFinset = Finset.univ := by\n  simp\n\n"}
{"name":"Set.Finite.toFinset_eq_empty","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nh : s.Finite\n⊢ Iff (Eq h.toFinset EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\nprotected theorem toFinset_eq_empty {h : s.Finite} : h.toFinset = ∅ ↔ s = ∅ :=\n  @toFinset_eq_empty _ _ h.fintype\n\n"}
{"name":"Set.Finite.toFinset_empty","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nh : EmptyCollection.emptyCollection.Finite\n⊢ Eq h.toFinset EmptyCollection.emptyCollection","decl":"protected theorem toFinset_empty (h : (∅ : Set α).Finite) : h.toFinset = ∅ := by\n  simp\n\n"}
{"name":"Set.Finite.toFinset_eq_univ","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\ninst✝ : Fintype α\nh : s.Finite\n⊢ Iff (Eq h.toFinset Finset.univ) (Eq s Set.univ)","decl":"@[simp]\nprotected theorem toFinset_eq_univ [Fintype α] {h : s.Finite} :\n    h.toFinset = Finset.univ ↔ s = univ :=\n  @toFinset_eq_univ _ _ _ h.fintype\n\n"}
{"name":"Set.Finite.toFinset_image","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝ : DecidableEq β\nf : α → β\nhs : s.Finite\nh : (Set.image f s).Finite\n⊢ Eq h.toFinset (Finset.image f hs.toFinset)","decl":"protected theorem toFinset_image [DecidableEq β] (f : α → β) (hs : s.Finite) (h : (f '' s).Finite) :\n    h.toFinset = hs.toFinset.image f := by\n  ext\n  simp\n\n"}
{"name":"Set.Finite.toFinset_range","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : Fintype β\nf : β → α\nh : (Set.range f).Finite\n⊢ Eq h.toFinset (Finset.image f Finset.univ)","decl":"protected theorem toFinset_range [DecidableEq α] [Fintype β] (f : β → α) (h : (range f).Finite) :\n    h.toFinset = Finset.univ.image f := by\n  ext\n  simp\n\n"}
{"name":"Finset.finite_toSet","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Finset α\n⊢ (↑s).Finite","decl":"/-- Gives a `Set.Finite` for the `Finset` coerced to a `Set`.\nThis is a wrapper around `Set.toFinite`. -/\n@[simp]\ntheorem finite_toSet (s : Finset α) : (s : Set α).Finite :=\n  Set.toFinite _\n\n"}
{"name":"Finset.finite_toSet_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Finset α\n⊢ Eq ⋯.toFinset s","decl":"theorem finite_toSet_toFinset (s : Finset α) : s.finite_toSet.toFinset = s := by\n  rw [toFinite_toFinset, toFinset_coe]\n\n"}
{"name":"Multiset.finite_toSet","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Multiset α\n⊢ (setOf fun x => Membership.mem s x).Finite","decl":"@[simp]\ntheorem finite_toSet (s : Multiset α) : { x | x ∈ s }.Finite := by\n  classical simpa only [← Multiset.mem_toFinset] using s.toFinset.finite_toSet\n\n"}
{"name":"Multiset.finite_toSet_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq ⋯.toFinset s.toFinset","decl":"@[simp]\ntheorem finite_toSet_toFinset [DecidableEq α] (s : Multiset α) :\n    s.finite_toSet.toFinset = s.toFinset := by\n  ext x\n  simp\n\n"}
{"name":"List.finite_toSet","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nl : List α\n⊢ (setOf fun x => Membership.mem l x).Finite","decl":"@[simp]\ntheorem List.finite_toSet (l : List α) : { x | x ∈ l }.Finite :=\n  (show Multiset α from ⟦l⟧).finite_toSet\n\n"}
{"name":"Finite.Set.finite_union","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝¹ : Finite ↑s\ninst✝ : Finite ↑t\n⊢ Finite ↑(Union.union s t)","decl":"instance finite_union (s t : Set α) [Finite s] [Finite t] : Finite (s ∪ t : Set α) := by\n  cases nonempty_fintype s\n  cases nonempty_fintype t\n  classical\n  infer_instance\n\n"}
{"name":"Finite.Set.finite_sep","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\np : α → Prop\ninst✝ : Finite ↑s\n⊢ Finite ↑(setOf fun a => And (Membership.mem s a) (p a))","decl":"instance finite_sep (s : Set α) (p : α → Prop) [Finite s] : Finite ({ a ∈ s | p a } : Set α) := by\n  cases nonempty_fintype s\n  classical\n  infer_instance\n\n"}
{"name":"Finite.Set.subset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝ : Finite ↑s\nh : HasSubset.Subset t s\n⊢ Finite ↑t","decl":"protected theorem subset (s : Set α) {t : Set α} [Finite s] (h : t ⊆ s) : Finite t := by\n  rw [← sep_eq_of_subset h]\n  infer_instance\n\n"}
{"name":"Finite.Set.finite_inter_of_right","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝ : Finite ↑t\n⊢ Finite ↑(Inter.inter s t)","decl":"instance finite_inter_of_right (s t : Set α) [Finite t] : Finite (s ∩ t : Set α) :=\n  Finite.Set.subset t inter_subset_right\n\n"}
{"name":"Finite.Set.finite_inter_of_left","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝ : Finite ↑s\n⊢ Finite ↑(Inter.inter s t)","decl":"instance finite_inter_of_left (s t : Set α) [Finite s] : Finite (s ∩ t : Set α) :=\n  Finite.Set.subset s inter_subset_left\n\n"}
{"name":"Finite.Set.finite_diff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝ : Finite ↑s\n⊢ Finite ↑(SDiff.sdiff s t)","decl":"instance finite_diff (s t : Set α) [Finite s] : Finite (s \\ t : Set α) :=\n  Finite.Set.subset s diff_subset\n\n"}
{"name":"Finite.Set.finite_insert","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\na : α\ns : Set α\ninst✝ : Finite ↑s\n⊢ Finite ↑(Insert.insert a s)","decl":"instance finite_insert (a : α) (s : Set α) [Finite s] : Finite (insert a s : Set α) :=\n  Finite.Set.finite_union {a} s\n\n"}
{"name":"Finite.Set.finite_image","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → β\ninst✝ : Finite ↑s\n⊢ Finite ↑(Set.image f s)","decl":"instance finite_image (s : Set α) (f : α → β) [Finite s] : Finite (f '' s) := by\n  cases nonempty_fintype s\n  classical\n  infer_instance\n\n"}
{"name":"Set.Finite.of_subsingleton","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : Subsingleton α\ns : Set α\n⊢ s.Finite","decl":"@[nontriviality]\ntheorem Finite.of_subsingleton [Subsingleton α] (s : Set α) : s.Finite :=\n  s.toFinite\n\n"}
{"name":"Set.finite_univ","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : Finite α\n⊢ Set.univ.Finite","decl":"theorem finite_univ [Finite α] : (@univ α).Finite :=\n  Set.toFinite _\n\n"}
{"name":"Set.finite_univ_iff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\n⊢ Iff Set.univ.Finite (Finite α)","decl":"theorem finite_univ_iff : (@univ α).Finite ↔ Finite α := (Equiv.Set.univ α).finite_iff\n\n"}
{"name":"Finite.of_finite_univ","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\na✝ : Set.univ.Finite\n⊢ Finite α","decl":"alias ⟨_root_.Finite.of_finite_univ, _⟩ := finite_univ_iff\n\n"}
{"name":"Set.Finite.subset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\nt : Set α\nht : HasSubset.Subset t s\n⊢ t.Finite","decl":"theorem Finite.subset {s : Set α} (hs : s.Finite) {t : Set α} (ht : t ⊆ s) : t.Finite := by\n  have := hs.to_subtype\n  exact Finite.Set.subset _ ht\n\n"}
{"name":"Set.Finite.union","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Finite\nht : t.Finite\n⊢ (Union.union s t).Finite","decl":"theorem Finite.union (hs : s.Finite) (ht : t.Finite) : (s ∪ t).Finite := by\n  rw [Set.Finite] at hs ht\n  apply toFinite\n\n"}
{"name":"Set.Finite.finite_of_compl","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\nhsc : (HasCompl.compl s).Finite\n⊢ Finite α","decl":"theorem Finite.finite_of_compl {s : Set α} (hs : s.Finite) (hsc : sᶜ.Finite) : Finite α := by\n  rw [← finite_univ_iff, ← union_compl_self s]\n  exact hs.union hsc\n\n"}
{"name":"Set.Finite.sup","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\na✝¹ : s.Finite\na✝ : t.Finite\n⊢ (Max.max s t).Finite","decl":"theorem Finite.sup {s t : Set α} : s.Finite → t.Finite → (s ⊔ t).Finite :=\n  Finite.union\n\n"}
{"name":"Set.Finite.sep","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\np : α → Prop\n⊢ (setOf fun a => And (Membership.mem s a) (p a)).Finite","decl":"theorem Finite.sep {s : Set α} (hs : s.Finite) (p : α → Prop) : { a ∈ s | p a }.Finite :=\n  hs.subset <| sep_subset _ _\n\n"}
{"name":"Set.Finite.inter_of_left","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\nt : Set α\n⊢ (Inter.inter s t).Finite","decl":"theorem Finite.inter_of_left {s : Set α} (hs : s.Finite) (t : Set α) : (s ∩ t).Finite :=\n  hs.subset inter_subset_left\n\n"}
{"name":"Set.Finite.inter_of_right","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\nt : Set α\n⊢ (Inter.inter t s).Finite","decl":"theorem Finite.inter_of_right {s : Set α} (hs : s.Finite) (t : Set α) : (t ∩ s).Finite :=\n  hs.subset inter_subset_right\n\n"}
{"name":"Set.Finite.inf_of_left","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nh : s.Finite\nt : Set α\n⊢ (Min.min s t).Finite","decl":"theorem Finite.inf_of_left {s : Set α} (h : s.Finite) (t : Set α) : (s ⊓ t).Finite :=\n  h.inter_of_left t\n\n"}
{"name":"Set.Finite.inf_of_right","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nh : s.Finite\nt : Set α\n⊢ (Min.min t s).Finite","decl":"theorem Finite.inf_of_right {s : Set α} (h : s.Finite) (t : Set α) : (t ⊓ s).Finite :=\n  h.inter_of_right t\n\n"}
{"name":"Set.Infinite.mono","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nh : HasSubset.Subset s t\na✝ : s.Infinite\n⊢ t.Infinite","decl":"protected lemma Infinite.mono {s t : Set α} (h : s ⊆ t) : s.Infinite → t.Infinite :=\n  mt fun ht ↦ ht.subset h\n\n"}
{"name":"Set.Finite.diff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Finite\n⊢ (SDiff.sdiff s t).Finite","decl":"theorem Finite.diff (hs : s.Finite) : (s \\ t).Finite := hs.subset diff_subset\n\n"}
{"name":"Set.Finite.of_diff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhd : (SDiff.sdiff s t).Finite\nht : t.Finite\n⊢ s.Finite","decl":"theorem Finite.of_diff {s t : Set α} (hd : (s \\ t).Finite) (ht : t.Finite) : s.Finite :=\n  (hd.union ht).subset <| subset_diff_union _ _\n\n"}
{"name":"Set.Finite.symmDiff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Finite\nht : t.Finite\n⊢ (symmDiff s t).Finite","decl":"lemma Finite.symmDiff (hs : s.Finite) (ht : t.Finite) : (s ∆ t).Finite := hs.diff.union ht.diff\n\n"}
{"name":"Set.Finite.symmDiff_congr","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t u : Set α\nhst : (symmDiff s t).Finite\n⊢ Iff (symmDiff s u).Finite (symmDiff t u).Finite","decl":"lemma Finite.symmDiff_congr (hst : (s ∆ t).Finite) : (s ∆ u).Finite ↔ (t ∆ u).Finite where\n  mp hsu := (hst.union hsu).subset (symmDiff_comm s t ▸ symmDiff_triangle ..)\n  mpr htu := (hst.union htu).subset (symmDiff_triangle ..)\n\n"}
{"name":"Set.finite_empty","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\n⊢ EmptyCollection.emptyCollection.Finite","decl":"@[simp]\ntheorem finite_empty : (∅ : Set α).Finite :=\n  toFinite _\n\n"}
{"name":"Set.Infinite.nonempty","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nh : s.Infinite\n⊢ s.Nonempty","decl":"protected theorem Infinite.nonempty {s : Set α} (h : s.Infinite) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 <| by\n    rintro rfl\n    exact h finite_empty\n\n"}
{"name":"Set.finite_singleton","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\na : α\n⊢ (Singleton.singleton a).Finite","decl":"@[simp]\ntheorem finite_singleton (a : α) : ({a} : Set α).Finite :=\n  toFinite _\n\n"}
{"name":"Set.Finite.insert","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\na : α\ns : Set α\nhs : s.Finite\n⊢ (Insert.insert a s).Finite","decl":"@[simp]\nprotected theorem Finite.insert (a : α) {s : Set α} (hs : s.Finite) : (insert a s).Finite :=\n  (finite_singleton a).union hs\n\n"}
{"name":"Set.Finite.image","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → β\nhs : s.Finite\n⊢ (Set.image f s).Finite","decl":"theorem Finite.image {s : Set α} (f : α → β) (hs : s.Finite) : (f '' s).Finite := by\n  have := hs.to_subtype\n  apply toFinite\n\n"}
{"name":"Set.Finite.of_surjOn","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : Set β\nf : α → β\nhf : Set.SurjOn f s t\nhs : s.Finite\n⊢ t.Finite","decl":"lemma Finite.of_surjOn {s : Set α} {t : Set β} (f : α → β) (hf : SurjOn f s t) (hs : s.Finite) :\n    t.Finite := (hs.image _).subset hf\n\n"}
{"name":"Set.Finite.map","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α β : Type u_1\ns : Set α\nf : α → β\na✝ : s.Finite\n⊢ (Functor.map f s).Finite","decl":"theorem Finite.map {α β} {s : Set α} : ∀ f : α → β, s.Finite → (f <$> s).Finite :=\n  Finite.image\n\n"}
{"name":"Set.Finite.of_finite_image","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → β\nh : (Set.image f s).Finite\nhi : Set.InjOn f s\n⊢ s.Finite","decl":"theorem Finite.of_finite_image {s : Set α} {f : α → β} (h : (f '' s).Finite) (hi : Set.InjOn f s) :\n    s.Finite :=\n  have := h.to_subtype\n  .of_injective _ hi.bijOn_image.bijective.injective\n\n"}
{"name":"Set.finite_of_finite_preimage","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\nh : (Set.preimage f s).Finite\nhs : HasSubset.Subset s (Set.range f)\n⊢ s.Finite","decl":"theorem finite_of_finite_preimage (h : (f ⁻¹' s).Finite) (hs : s ⊆ range f) : s.Finite := by\n  rw [← image_preimage_eq_of_subset hs]\n  exact Finite.image f h\n\n"}
{"name":"Set.Finite.of_preimage","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\nh : (Set.preimage f s).Finite\nhf : Function.Surjective f\n⊢ s.Finite","decl":"theorem Finite.of_preimage (h : (f ⁻¹' s).Finite) (hf : Surjective f) : s.Finite :=\n  hf.image_preimage s ▸ h.image _\n\n"}
{"name":"Set.Finite.preimage","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\nI : Set.InjOn f (Set.preimage f s)\nh : s.Finite\n⊢ (Set.preimage f s).Finite","decl":"theorem Finite.preimage (I : Set.InjOn f (f ⁻¹' s)) (h : s.Finite) : (f ⁻¹' s).Finite :=\n  (h.subset (image_preimage_subset f s)).of_finite_image I\n\n"}
{"name":"Set.Infinite.preimage","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\nhs : s.Infinite\nhf : HasSubset.Subset s (Set.range f)\n⊢ (Set.preimage f s).Infinite","decl":"protected lemma Infinite.preimage (hs : s.Infinite) (hf : s ⊆ range f) : (f ⁻¹' s).Infinite :=\n  fun h ↦ hs <| finite_of_finite_preimage h hf\n\n"}
{"name":"Set.Infinite.preimage'","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\nhs : (Inter.inter s (Set.range f)).Infinite\n⊢ (Set.preimage f s).Infinite","decl":"lemma Infinite.preimage' (hs : (s ∩ range f).Infinite) : (f ⁻¹' s).Infinite :=\n  (hs.preimage inter_subset_right).mono <| preimage_mono inter_subset_left\n\n"}
{"name":"Set.Finite.preimage_embedding","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set β\nf : Function.Embedding α β\nh : s.Finite\n⊢ (Set.preimage (⇑f) s).Finite","decl":"theorem Finite.preimage_embedding {s : Set β} (f : α ↪ β) (h : s.Finite) : (f ⁻¹' s).Finite :=\n  h.preimage fun _ _ _ _ h' => f.injective h'\n\n"}
{"name":"Set.finite_lt_nat","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"n : Nat\n⊢ (setOf fun i => LT.lt i n).Finite","decl":"theorem finite_lt_nat (n : ℕ) : Set.Finite { i | i < n } :=\n  toFinite _\n\n"}
{"name":"Set.finite_le_nat","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"n : Nat\n⊢ (setOf fun i => LE.le i n).Finite","decl":"theorem finite_le_nat (n : ℕ) : Set.Finite { i | i ≤ n } :=\n  toFinite _\n\n"}
{"name":"Set.Finite.surjOn_iff_bijOn_of_mapsTo","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nf : α → α\nhs : s.Finite\nhm : Set.MapsTo f s s\n⊢ Iff (Set.SurjOn f s s) (Set.BijOn f s s)","decl":"theorem Finite.surjOn_iff_bijOn_of_mapsTo (hs : s.Finite) (hm : MapsTo f s s) :\n    SurjOn f s s ↔ BijOn f s s := by\n  refine ⟨fun h ↦ ⟨hm, ?_, h⟩, BijOn.surjOn⟩\n  have : Finite s := finite_coe_iff.mpr hs\n  exact hm.restrict_inj.mp (Finite.injective_iff_surjective.mpr <| hm.restrict_surjective_iff.mpr h)\n\n"}
{"name":"Set.Finite.injOn_iff_bijOn_of_mapsTo","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nf : α → α\nhs : s.Finite\nhm : Set.MapsTo f s s\n⊢ Iff (Set.InjOn f s) (Set.BijOn f s s)","decl":"theorem Finite.injOn_iff_bijOn_of_mapsTo (hs : s.Finite) (hm : MapsTo f s s) :\n    InjOn f s ↔ BijOn f s s := by\n  refine ⟨fun h ↦ ⟨hm, h, ?_⟩, BijOn.injOn⟩\n  have : Finite s := finite_coe_iff.mpr hs\n  exact hm.restrict_surjective_iff.mp (Finite.injective_iff_surjective.mp <| hm.restrict_inj.mpr h)\n\n"}
{"name":"Set.finite_mem_finset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Finset α\n⊢ (setOf fun a => Membership.mem s a).Finite","decl":"theorem finite_mem_finset (s : Finset α) : { a | a ∈ s }.Finite :=\n  toFinite _\n\n"}
{"name":"Set.Subsingleton.finite","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nh : s.Subsingleton\n⊢ s.Finite","decl":"theorem Subsingleton.finite {s : Set α} (h : s.Subsingleton) : s.Finite :=\n  h.induction_on finite_empty finite_singleton\n\n"}
{"name":"Set.Infinite.nontrivial","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Infinite\n⊢ s.Nontrivial","decl":"theorem Infinite.nontrivial {s : Set α} (hs : s.Infinite) : s.Nontrivial :=\n  not_subsingleton_iff.1 <| mt Subsingleton.finite hs\n\n"}
{"name":"Set.finite_preimage_inl_and_inr","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set (Sum α β)\n⊢ Iff (And (Set.preimage Sum.inl s).Finite (Set.preimage Sum.inr s).Finite) s.Finite","decl":"theorem finite_preimage_inl_and_inr {s : Set (α ⊕ β)} :\n    (Sum.inl ⁻¹' s).Finite ∧ (Sum.inr ⁻¹' s).Finite ↔ s.Finite :=\n  ⟨fun h => image_preimage_inl_union_image_preimage_inr s ▸ (h.1.image _).union (h.2.image _),\n    fun h => ⟨h.preimage Sum.inl_injective.injOn, h.preimage Sum.inr_injective.injOn⟩⟩\n\n"}
{"name":"Set.exists_finite_iff_finset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\np : Set α → Prop\n⊢ Iff (Exists fun s => And s.Finite (p s)) (Exists fun s => p ↑s)","decl":"theorem exists_finite_iff_finset {p : Set α → Prop} :\n    (∃ s : Set α, s.Finite ∧ p s) ↔ ∃ s : Finset α, p ↑s :=\n  ⟨fun ⟨_, hs, hps⟩ => ⟨hs.toFinset, hs.coe_toFinset.symm ▸ hps⟩, fun ⟨s, hs⟩ =>\n    ⟨s, s.finite_toSet, hs⟩⟩\n\n"}
{"name":"Set.exists_subset_image_finite_and","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\np : Set β → Prop\n⊢ Iff (Exists fun t => And (HasSubset.Subset t (Set.image f s)) (And t.Finite (p t))) (Exists fun t => And (HasSubset.Subset t s) (And t.Finite (p (Set.image f t))))","decl":"theorem exists_subset_image_finite_and {f : α → β} {s : Set α} {p : Set β → Prop} :\n    (∃ t ⊆ f '' s, t.Finite ∧ p t) ↔ ∃ t ⊆ s, t.Finite ∧ p (f '' t) := by\n  classical\n  simp_rw [@and_comm (_ ⊆ _), and_assoc, exists_finite_iff_finset, @and_comm (p _),\n    Finset.subset_set_image_iff]\n  aesop\n\n"}
{"name":"Set.finite_range_ite","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\np : α → Prop\ninst✝ : DecidablePred p\nf g : α → β\nhf : (Set.range f).Finite\nhg : (Set.range g).Finite\n⊢ (Set.range fun x => ite (p x) (f x) (g x)).Finite","decl":"theorem finite_range_ite {p : α → Prop} [DecidablePred p] {f g : α → β} (hf : (range f).Finite)\n    (hg : (range g).Finite) : (range fun x => if p x then f x else g x).Finite :=\n  (hf.union hg).subset range_ite_subset\n\n"}
{"name":"Set.finite_range_const","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nc : β\n⊢ (Set.range fun x => c).Finite","decl":"theorem finite_range_const {c : β} : (range fun _ : α => c).Finite :=\n  (finite_singleton c).subset range_const_subset\n\n"}
{"name":"Set.finite_union","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Union.union s t).Finite (And s.Finite t.Finite)","decl":"@[simp]\ntheorem finite_union {s t : Set α} : (s ∪ t).Finite ↔ s.Finite ∧ t.Finite :=\n  ⟨fun h => ⟨h.subset subset_union_left, h.subset subset_union_right⟩, fun ⟨hs, ht⟩ =>\n    hs.union ht⟩\n\n"}
{"name":"Set.finite_image_iff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → β\nhi : Set.InjOn f s\n⊢ Iff (Set.image f s).Finite s.Finite","decl":"theorem finite_image_iff {s : Set α} {f : α → β} (hi : InjOn f s) : (f '' s).Finite ↔ s.Finite :=\n  ⟨fun h => h.of_finite_image hi, Finite.image _⟩\n\n"}
{"name":"Set.univ_finite_iff_nonempty_fintype","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\n⊢ Iff Set.univ.Finite (Nonempty (Fintype α))","decl":"theorem univ_finite_iff_nonempty_fintype : (univ : Set α).Finite ↔ Nonempty (Fintype α) :=\n  ⟨fun h => ⟨fintypeOfFiniteUniv h⟩, fun ⟨_i⟩ => finite_univ⟩\n\n-- Porting note: moved `@[simp]` to `Set.toFinset_singleton` because `simp` can now simplify LHS\n"}
{"name":"Set.Finite.toFinset_singleton","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\na : α\nha : optParam (Singleton.singleton a).Finite ⋯\n⊢ Eq (Set.Finite.toFinset ha) (Singleton.singleton a)","decl":"theorem Finite.toFinset_singleton {a : α} (ha : ({a} : Set α).Finite := finite_singleton _) :\n    ha.toFinset = {a} :=\n  Set.toFinite_toFinset _\n\n"}
{"name":"Set.Finite.toFinset_insert","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ns : Set α\na : α\nhs : (Insert.insert a s).Finite\n⊢ Eq hs.toFinset (Insert.insert a ⋯.toFinset)","decl":"@[simp]\ntheorem Finite.toFinset_insert [DecidableEq α] {s : Set α} {a : α} (hs : (insert a s).Finite) :\n    hs.toFinset = insert a (hs.subset <| subset_insert _ _).toFinset :=\n  Finset.ext <| by simp\n\n"}
{"name":"Set.Finite.toFinset_insert'","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\ns : Set α\nhs : s.Finite\n⊢ Eq ⋯.toFinset (Insert.insert a hs.toFinset)","decl":"theorem Finite.toFinset_insert' [DecidableEq α] {a : α} {s : Set α} (hs : s.Finite) :\n    (hs.insert a).toFinset = insert a hs.toFinset :=\n  Finite.toFinset_insert _\n\n"}
{"name":"Set.finite_option","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set (Option α)\n⊢ Iff s.Finite (setOf fun x => Membership.mem s (Option.some x)).Finite","decl":"theorem finite_option {s : Set (Option α)} : s.Finite ↔ { x : α | some x ∈ s }.Finite :=\n  ⟨fun h => h.preimage_embedding Embedding.some, fun h =>\n    ((h.image some).insert none).subset fun x =>\n      x.casesOn (fun _ => Or.inl rfl) fun _ hx => Or.inr <| mem_image_of_mem _ hx⟩\n\n"}
{"name":"Set.Finite.induction_on","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nmotive : (s : Set α) → s.Finite → Prop\ns : Set α\nhs : s.Finite\nempty : motive EmptyCollection.emptyCollection ⋯\ninsert : ∀ {a : α} {s : Set α}, Not (Membership.mem s a) → ∀ (hs : s.Finite), motive s hs → motive (Insert.insert a s) ⋯\n⊢ motive s hs","decl":"/-- Induction principle for finite sets: To prove a property `motive` of a finite set `s`, it's\nenough to prove for the empty set and to prove that `motive t → motive ({a} ∪ t)` for all `t`.\n\nSee also `Set.Finite.induction_on` for the version requiring to check `motive t → motive ({a} ∪ t)`\nonly for `t ⊆ s`. -/\n@[elab_as_elim]\ntheorem Finite.induction_on {motive : ∀ s : Set α, s.Finite → Prop} (s : Set α) (hs : s.Finite)\n    (empty : motive ∅ finite_empty)\n    (insert : ∀ {a s}, a ∉ s →\n      ∀ hs : Set.Finite s, motive s hs → motive (insert a s) (hs.insert a)) :\n    motive s hs := by\n  lift s to Finset α using id hs\n  induction' s using Finset.cons_induction_on with a s ha ih\n  · simpa\n  · simpa using @insert a s ha (Set.toFinite _) (ih _)\n\n"}
{"name":"Set.Finite.induction_on_subset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nmotive : (s : Set α) → s.Finite → Prop\ns : Set α\nhs : s.Finite\nempty : motive EmptyCollection.emptyCollection ⋯\ninsert : ∀ {a : α} {t : Set α}, Membership.mem s a → ∀ (hts : HasSubset.Subset t s), Not (Membership.mem t a) → motive t ⋯ → motive (Insert.insert a t) ⋯\n⊢ motive s hs","decl":"/-- Induction principle for finite sets: To prove a property `C` of a finite set `s`, it's enough\nto prove for the empty set and to prove that `C t → C ({a} ∪ t)` for all `t ⊆ s`.\n\nThis is analogous to `Finset.induction_on'`. See also `Set.Finite.induction_on` for the version\nrequiring `C t → C ({a} ∪ t)` for all `t`. -/\n@[elab_as_elim]\ntheorem Finite.induction_on_subset {motive : ∀ s : Set α, s.Finite → Prop} (s : Set α)\n    (hs : s.Finite) (empty : motive ∅ finite_empty)\n    (insert : ∀ {a t}, a ∈ s → ∀ hts : t ⊆ s, a ∉ t → motive t (hs.subset hts) →\n      motive (insert a t) ((hs.subset hts).insert a)) : motive s hs := by\n  refine Set.Finite.induction_on (motive := fun t _ => ∀ hts : t ⊆ s, motive t (hs.subset hts)) s hs\n    (fun _ => empty) ?_ .rfl\n  intro a s has _ hCs haS\n  rw [insert_subset_iff] at haS\n  exact insert haS.1 haS.2 has (hCs haS.2)\n\n"}
{"name":"Set.Finite.induction_on'","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nmotive : (s : Set α) → s.Finite → Prop\ns : Set α\nhs : s.Finite\nempty : motive EmptyCollection.emptyCollection ⋯\ninsert : ∀ {a : α} {t : Set α}, Membership.mem s a → ∀ (hts : HasSubset.Subset t s), Not (Membership.mem t a) → motive t ⋯ → motive (Insert.insert a t) ⋯\n⊢ motive s hs","decl":"@[deprecated (since := \"2025-01-03\")] alias Finite.induction_on' := Finite.induction_on_subset\n"}
{"name":"Set.Finite.dinduction_on","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nmotive : (s : Set α) → s.Finite → Prop\ns : Set α\nhs : s.Finite\nempty : motive EmptyCollection.emptyCollection ⋯\ninsert : ∀ {a : α} {s : Set α}, Not (Membership.mem s a) → ∀ (hs : s.Finite), motive s hs → motive (Insert.insert a s) ⋯\n⊢ motive s hs","decl":"@[deprecated (since := \"2025-01-03\")] alias Finite.dinduction_on := Finite.induction_on\n\n"}
{"name":"Set.seq_of_forall_finite_exists","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"γ : Type u_1\nP : γ → Set γ → Prop\nh : ∀ (t : Set γ), t.Finite → Exists fun c => P c t\n⊢ Exists fun u => ∀ (n : Nat), P (u n) (Set.image u (Set.Iio n))","decl":"/-- If `P` is some relation between terms of `γ` and sets in `γ`, such that every finite set\n`t : Set γ` has some `c : γ` related to it, then there is a recursively defined sequence `u` in `γ`\nso `u n` is related to the image of `{0, 1, ..., n-1}` under `u`.\n\n(We use this later to show sequentially compact sets are totally bounded.)\n-/\ntheorem seq_of_forall_finite_exists {γ : Type*} {P : γ → Set γ → Prop}\n    (h : ∀ t : Set γ, t.Finite → ∃ c, P c t) : ∃ u : ℕ → γ, ∀ n, P (u n) (u '' Iio n) := by\n  haveI : Nonempty γ := (h ∅ finite_empty).nonempty\n  choose! c hc using h\n  set f : (n : ℕ) → (g : (m : ℕ) → m < n → γ) → γ := fun n g => c (range fun k : Iio n => g k.1 k.2)\n  set u : ℕ → γ := fun n => Nat.strongRecOn' n f\n  refine ⟨u, fun n => ?_⟩\n  convert hc (u '' Iio n) ((finite_lt_nat _).image _)\n  rw [image_eq_range]\n  exact Nat.strongRecOn'_beta\n\n"}
{"name":"Set.empty_card","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\n⊢ Eq (Fintype.card ↑EmptyCollection.emptyCollection) 0","decl":"theorem empty_card : Fintype.card (∅ : Set α) = 0 :=\n  rfl\n\n"}
{"name":"Set.empty_card'","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nh : Fintype ↑EmptyCollection.emptyCollection\n⊢ Eq (Fintype.card ↑EmptyCollection.emptyCollection) 0","decl":"theorem empty_card' {h : Fintype.{u} (∅ : Set α)} : @Fintype.card (∅ : Set α) h = 0 := by\n  simp\n\n"}
{"name":"Set.card_fintypeInsertOfNotMem","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\na : α\ns : Set α\ninst✝ : Fintype ↑s\nh : Not (Membership.mem s a)\n⊢ Eq (Fintype.card ↑(Insert.insert a s)) (HAdd.hAdd (Fintype.card ↑s) 1)","decl":"theorem card_fintypeInsertOfNotMem {a : α} (s : Set α) [Fintype s] (h : a ∉ s) :\n    @Fintype.card _ (fintypeInsertOfNotMem s h) = Fintype.card s + 1 := by\n  simp [fintypeInsertOfNotMem, Fintype.card_ofFinset]\n\n"}
{"name":"Set.card_insert","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\na : α\ns : Set α\ninst✝ : Fintype ↑s\nh : Not (Membership.mem s a)\nd : Fintype ↑(Insert.insert a s)\n⊢ Eq (Fintype.card ↑(Insert.insert a s)) (HAdd.hAdd (Fintype.card ↑s) 1)","decl":"@[simp]\ntheorem card_insert {a : α} (s : Set α) [Fintype s] (h : a ∉ s)\n    {d : Fintype.{u} (insert a s : Set α)} : @Fintype.card _ d = Fintype.card s + 1 := by\n  rw [← card_fintypeInsertOfNotMem s h]; congr!\n\n"}
{"name":"Set.card_image_of_inj_on","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Fintype ↑s\nf : α → β\ninst✝ : Fintype ↑(Set.image f s)\nH : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (f x) (f y) → Eq x y\n⊢ Eq (Fintype.card ↑(Set.image f s)) (Fintype.card ↑s)","decl":"theorem card_image_of_inj_on {s : Set α} [Fintype s] {f : α → β} [Fintype (f '' s)]\n    (H : ∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y) : Fintype.card (f '' s) = Fintype.card s :=\n  haveI := Classical.propDecidable\n  calc\n    Fintype.card (f '' s) = (s.toFinset.image f).card := Fintype.card_of_finset' _ (by simp)\n    _ = s.toFinset.card :=\n      Finset.card_image_of_injOn fun x hx y hy hxy =>\n        H x (mem_toFinset.1 hx) y (mem_toFinset.1 hy) hxy\n    _ = Fintype.card s := (Fintype.card_of_finset' _ fun _ => mem_toFinset).symm\n\n"}
{"name":"Set.card_image_of_injective","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\ninst✝¹ : Fintype ↑s\nf : α → β\ninst✝ : Fintype ↑(Set.image f s)\nH : Function.Injective f\n⊢ Eq (Fintype.card ↑(Set.image f s)) (Fintype.card ↑s)","decl":"theorem card_image_of_injective (s : Set α) [Fintype s] {f : α → β} [Fintype (f '' s)]\n    (H : Function.Injective f) : Fintype.card (f '' s) = Fintype.card s :=\n  card_image_of_inj_on fun _ _ _ _ h => H h\n\n"}
{"name":"Set.card_singleton","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\na : α\n⊢ Eq (Fintype.card ↑(Singleton.singleton a)) 1","decl":"@[simp]\ntheorem card_singleton (a : α) : Fintype.card ({a} : Set α) = 1 :=\n  Fintype.card_ofSubsingleton _\n\n"}
{"name":"Set.card_lt_card","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\nh : HasSSubset.SSubset s t\n⊢ LT.lt (Fintype.card ↑s) (Fintype.card ↑t)","decl":"theorem card_lt_card {s t : Set α} [Fintype s] [Fintype t] (h : s ⊂ t) :\n    Fintype.card s < Fintype.card t :=\n  Fintype.card_lt_of_injective_not_surjective (Set.inclusion h.1) (Set.inclusion_injective h.1)\n    fun hst => (ssubset_iff_subset_ne.1 h).2 (eq_of_inclusion_surjective hst)\n\n"}
{"name":"Set.card_le_card","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\nhsub : HasSubset.Subset s t\n⊢ LE.le (Fintype.card ↑s) (Fintype.card ↑t)","decl":"theorem card_le_card {s t : Set α} [Fintype s] [Fintype t] (hsub : s ⊆ t) :\n    Fintype.card s ≤ Fintype.card t :=\n  Fintype.card_le_of_injective (Set.inclusion hsub) (Set.inclusion_injective hsub)\n\n"}
{"name":"Set.eq_of_subset_of_card_le","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\nhsub : HasSubset.Subset s t\nhcard : LE.le (Fintype.card ↑t) (Fintype.card ↑s)\n⊢ Eq s t","decl":"theorem eq_of_subset_of_card_le {s t : Set α} [Fintype s] [Fintype t] (hsub : s ⊆ t)\n    (hcard : Fintype.card t ≤ Fintype.card s) : s = t :=\n  (eq_or_ssubset_of_subset hsub).elim id fun h => absurd hcard <| not_le_of_lt <| card_lt_card h\n\n"}
{"name":"Set.card_range_of_injective","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Fintype α\nf : α → β\nhf : Function.Injective f\ninst✝ : Fintype ↑(Set.range f)\n⊢ Eq (Fintype.card ↑(Set.range f)) (Fintype.card α)","decl":"theorem card_range_of_injective [Fintype α] {f : α → β} (hf : Injective f) [Fintype (range f)] :\n    Fintype.card (range f) = Fintype.card α :=\n  Eq.symm <| Fintype.card_congr <| Equiv.ofInjective f hf\n\n"}
{"name":"Set.Finite.card_toFinset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\ninst✝ : Fintype ↑s\nh : s.Finite\n⊢ Eq h.toFinset.card (Fintype.card ↑s)","decl":"theorem Finite.card_toFinset {s : Set α} [Fintype s] (h : s.Finite) :\n    h.toFinset.card = Fintype.card s :=\n  Eq.symm <| Fintype.card_of_finset' _ fun _ ↦ h.mem_toFinset\n\n"}
{"name":"Set.card_ne_eq","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝¹ : Fintype α\na : α\ninst✝ : Fintype ↑(setOf fun x => Ne x a)\n⊢ Eq (Fintype.card ↑(setOf fun x => Ne x a)) (HSub.hSub (Fintype.card α) 1)","decl":"theorem card_ne_eq [Fintype α] (a : α) [Fintype { x : α | x ≠ a }] :\n    Fintype.card { x : α | x ≠ a } = Fintype.card α - 1 := by\n  haveI := Classical.decEq α\n  rw [← toFinset_card, toFinset_setOf, Finset.filter_ne',\n    Finset.card_erase_of_mem (Finset.mem_univ _), Finset.card_univ]\n\n"}
{"name":"Set.infinite_univ_iff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\n⊢ Iff Set.univ.Infinite (Infinite α)","decl":"theorem infinite_univ_iff : (@univ α).Infinite ↔ Infinite α := by\n  rw [Set.Infinite, finite_univ_iff, not_finite_iff_infinite]\n\n"}
{"name":"Set.infinite_univ","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nh : Infinite α\n⊢ Set.univ.Infinite","decl":"theorem infinite_univ [h : Infinite α] : (@univ α).Infinite :=\n  infinite_univ_iff.2 h\n\n"}
{"name":"Set.Infinite.exists_not_mem_finite","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Infinite\nht : t.Finite\n⊢ Exists fun a => And (Membership.mem s a) (Not (Membership.mem t a))","decl":"lemma Infinite.exists_not_mem_finite (hs : s.Infinite) (ht : t.Finite) : ∃ a, a ∈ s ∧ a ∉ t := by\n  by_contra! h; exact hs <| ht.subset h\n\n"}
{"name":"Set.Infinite.exists_not_mem_finset","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Infinite\nt : Finset α\n⊢ Exists fun a => And (Membership.mem s a) (Not (Membership.mem t a))","decl":"lemma Infinite.exists_not_mem_finset (hs : s.Infinite) (t : Finset α) : ∃ a ∈ s, a ∉ t :=\n  hs.exists_not_mem_finite t.finite_toSet\n\n"}
{"name":"Set.Finite.exists_not_mem","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\ninst✝ : Infinite α\nhs : s.Finite\n⊢ Exists fun a => Not (Membership.mem s a)","decl":"lemma Finite.exists_not_mem (hs : s.Finite) : ∃ a, a ∉ s := by\n  by_contra! h; exact infinite_univ (hs.subset fun a _ ↦ h _)\n\n"}
{"name":"Finset.exists_not_mem","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\ns : Finset α\n⊢ Exists fun a => Not (Membership.mem s a)","decl":"lemma _root_.Finset.exists_not_mem (s : Finset α) : ∃ a, a ∉ s := s.finite_toSet.exists_not_mem\n\n"}
{"name":"Set.Infinite.exists_subset_card_eq","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns : Set α\nhs : s.Infinite\nn : Nat\n⊢ Exists fun t => And (HasSubset.Subset (↑t) s) (Eq t.card n)","decl":"theorem Infinite.exists_subset_card_eq {s : Set α} (hs : s.Infinite) (n : ℕ) :\n    ∃ t : Finset α, ↑t ⊆ s ∧ t.card = n :=\n  ⟨((Finset.range n).map (hs.natEmbedding _)).map (Embedding.subtype _), by simp⟩\n\n"}
{"name":"Set.infinite_of_finite_compl","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\ns : Set α\nhs : (HasCompl.compl s).Finite\n⊢ s.Infinite","decl":"theorem infinite_of_finite_compl [Infinite α] {s : Set α} (hs : sᶜ.Finite) : s.Infinite := fun h =>\n  Set.infinite_univ (α := α) (by simpa using hs.union h)\n\n"}
{"name":"Set.Finite.infinite_compl","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\ns : Set α\nhs : s.Finite\n⊢ (HasCompl.compl s).Infinite","decl":"theorem Finite.infinite_compl [Infinite α] {s : Set α} (hs : s.Finite) : sᶜ.Infinite := fun h =>\n  Set.infinite_univ (α := α) (by simpa using hs.union h)\n\n"}
{"name":"Set.Infinite.diff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\nhs : s.Infinite\nht : t.Finite\n⊢ (SDiff.sdiff s t).Infinite","decl":"theorem Infinite.diff {s t : Set α} (hs : s.Infinite) (ht : t.Finite) : (s \\ t).Infinite := fun h =>\n  hs <| h.of_diff ht\n\n"}
{"name":"Set.infinite_union","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Union.union s t).Infinite (Or s.Infinite t.Infinite)","decl":"@[simp]\ntheorem infinite_union {s t : Set α} : (s ∪ t).Infinite ↔ s.Infinite ∨ t.Infinite := by\n  simp only [Set.Infinite, finite_union, not_and_or]\n\n"}
{"name":"Set.Infinite.of_image","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nhs : (Set.image f s).Infinite\n⊢ s.Infinite","decl":"theorem Infinite.of_image (f : α → β) {s : Set α} (hs : (f '' s).Infinite) : s.Infinite :=\n  mt (Finite.image f) hs\n\n"}
{"name":"Set.infinite_image_iff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → β\nhi : Set.InjOn f s\n⊢ Iff (Set.image f s).Infinite s.Infinite","decl":"theorem infinite_image_iff {s : Set α} {f : α → β} (hi : InjOn f s) :\n    (f '' s).Infinite ↔ s.Infinite :=\n  not_congr <| finite_image_iff hi\n\n"}
{"name":"Set.infinite_range_iff","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nhi : Function.Injective f\n⊢ Iff (Set.range f).Infinite (Infinite α)","decl":"theorem infinite_range_iff {f : α → β} (hi : Injective f) :\n    (range f).Infinite ↔ Infinite α := by\n  rw [← image_univ, infinite_image_iff hi.injOn, infinite_univ_iff]\n\n"}
{"name":"Set.Infinite.image","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → β\nhi : Set.InjOn f s\na✝ : s.Infinite\n⊢ (Set.image f s).Infinite","decl":"protected alias ⟨_, Infinite.image⟩ := infinite_image_iff\n\n"}
{"name":"Set.infinite_of_injOn_mapsTo","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : Set β\nf : α → β\nhi : Set.InjOn f s\nhm : Set.MapsTo f s t\nhs : s.Infinite\n⊢ t.Infinite","decl":"theorem infinite_of_injOn_mapsTo {s : Set α} {t : Set β} {f : α → β} (hi : InjOn f s)\n    (hm : MapsTo f s t) (hs : s.Infinite) : t.Infinite :=\n  ((infinite_image_iff hi).2 hs).mono (mapsTo'.mp hm)\n\n"}
{"name":"Set.Infinite.exists_ne_map_eq_of_mapsTo","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : Set β\nf : α → β\nhs : s.Infinite\nhf : Set.MapsTo f s t\nht : t.Finite\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (Eq (f x) (f y))))","decl":"theorem Infinite.exists_ne_map_eq_of_mapsTo {s : Set α} {t : Set β} {f : α → β} (hs : s.Infinite)\n    (hf : MapsTo f s t) (ht : t.Finite) : ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ f x = f y := by\n  contrapose! ht\n  exact infinite_of_injOn_mapsTo (fun x hx y hy => not_imp_not.1 (ht x hx y hy)) hf hs\n\n"}
{"name":"Set.infinite_range_of_injective","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Infinite α\nf : α → β\nhi : Function.Injective f\n⊢ (Set.range f).Infinite","decl":"theorem infinite_range_of_injective [Infinite α] {f : α → β} (hi : Injective f) :\n    (range f).Infinite := by\n  rw [← image_univ, infinite_image_iff hi.injOn]\n  exact infinite_univ\n\n"}
{"name":"Set.infinite_of_injective_forall_mem","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Infinite α\ns : Set β\nf : α → β\nhi : Function.Injective f\nhf : ∀ (x : α), Membership.mem s (f x)\n⊢ s.Infinite","decl":"theorem infinite_of_injective_forall_mem [Infinite α] {s : Set β} {f : α → β} (hi : Injective f)\n    (hf : ∀ x : α, f x ∈ s) : s.Infinite := by\n  rw [← range_subset_iff] at hf\n  exact (infinite_range_of_injective hi).mono hf\n\n"}
{"name":"Set.not_injOn_infinite_finite_image","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nh_inf : s.Infinite\nh_fin : (Set.image f s).Finite\n⊢ Not (Set.InjOn f s)","decl":"theorem not_injOn_infinite_finite_image {f : α → β} {s : Set α} (h_inf : s.Infinite)\n    (h_fin : (f '' s).Finite) : ¬InjOn f s := by\n  have : Finite (f '' s) := finite_coe_iff.mpr h_fin\n  have : Infinite s := infinite_coe_iff.mpr h_inf\n  have h := not_injective_infinite_finite\n            ((f '' s).codRestrict (s.restrict f) fun x => ⟨x, x.property, rfl⟩)\n  contrapose! h\n  rwa [injective_codRestrict, ← injOn_iff_injective]\n\n"}
{"name":"Set.infinite_of_forall_exists_gt","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\ns : Set α\nh : ∀ (a : α), Exists fun b => And (Membership.mem s b) (LT.lt a b)\n⊢ s.Infinite","decl":"theorem infinite_of_forall_exists_gt (h : ∀ a, ∃ b ∈ s, a < b) : s.Infinite := by\n  inhabit α\n  set f : ℕ → α := fun n => Nat.recOn n (h default).choose fun _ a => (h a).choose\n  have hf : ∀ n, f n ∈ s := by rintro (_ | _) <;> exact (h _).choose_spec.1\n  exact infinite_of_injective_forall_mem\n    (strictMono_nat_of_lt_succ fun n => (h _).choose_spec.2).injective hf\n\n"}
{"name":"Set.infinite_of_forall_exists_lt","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\ns : Set α\nh : ∀ (a : α), Exists fun b => And (Membership.mem s b) (LT.lt b a)\n⊢ s.Infinite","decl":"theorem infinite_of_forall_exists_lt (h : ∀ a, ∃ b ∈ s, b < a) : s.Infinite :=\n  infinite_of_forall_exists_gt (α := αᵒᵈ) h\n\n"}
{"name":"Set.finite_isTop","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ (setOf fun x => IsTop x).Finite","decl":"theorem finite_isTop (α : Type*) [PartialOrder α] : { x : α | IsTop x }.Finite :=\n  (subsingleton_isTop α).finite\n\n"}
{"name":"Set.finite_isBot","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ (setOf fun x => IsBot x).Finite","decl":"theorem finite_isBot (α : Type*) [PartialOrder α] : { x : α | IsBot x }.Finite :=\n  (subsingleton_isBot α).finite\n\n"}
{"name":"Set.Infinite.exists_lt_map_eq_of_mapsTo","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder α\ns : Set α\nt : Set β\nf : α → β\nhs : s.Infinite\nhf : Set.MapsTo f s t\nht : t.Finite\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (LT.lt x y) (Eq (f x) (f y))))","decl":"theorem Infinite.exists_lt_map_eq_of_mapsTo [LinearOrder α] {s : Set α} {t : Set β} {f : α → β}\n    (hs : s.Infinite) (hf : MapsTo f s t) (ht : t.Finite) : ∃ x ∈ s, ∃ y ∈ s, x < y ∧ f x = f y :=\n  let ⟨x, hx, y, hy, hxy, hf⟩ := hs.exists_ne_map_eq_of_mapsTo hf ht\n  hxy.lt_or_lt.elim (fun hxy => ⟨x, hx, y, hy, hxy, hf⟩) fun hyx => ⟨y, hy, x, hx, hyx, hf.symm⟩\n\n"}
{"name":"Set.Finite.exists_lt_map_eq_of_forall_mem","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Infinite α\nt : Set β\nf : α → β\nhf : ∀ (a : α), Membership.mem t (f a)\nht : t.Finite\n⊢ Exists fun a => Exists fun b => And (LT.lt a b) (Eq (f a) (f b))","decl":"theorem Finite.exists_lt_map_eq_of_forall_mem [LinearOrder α] [Infinite α] {t : Set β} {f : α → β}\n    (hf : ∀ a, f a ∈ t) (ht : t.Finite) : ∃ a b, a < b ∧ f a = f b := by\n  rw [← mapsTo_univ_iff] at hf\n  obtain ⟨a, -, b, -, h⟩ := infinite_univ.exists_lt_map_eq_of_mapsTo hf ht\n  exact ⟨a, b, h⟩\n\n"}
{"name":"Set.finite_range_findGreatest","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nP : α → Nat → Prop\ninst✝ : (x : α) → DecidablePred (P x)\nb : Nat\n⊢ (Set.range fun x => Nat.findGreatest (P x) b).Finite","decl":"theorem finite_range_findGreatest {P : α → ℕ → Prop} [∀ x, DecidablePred (P x)] {b : ℕ} :\n    (range fun x => Nat.findGreatest (P x) b).Finite :=\n  (finite_le_nat b).subset <| range_subset_iff.2 fun _ => Nat.findGreatest_le _\n\n"}
{"name":"Set.Finite.exists_maximal_wrt","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PartialOrder β\nf : α → β\ns : Set α\nh : s.Finite\nhs : s.Nonempty\n⊢ Exists fun a => And (Membership.mem s a) (∀ (a' : α), Membership.mem s a' → LE.le (f a) (f a') → Eq (f a) (f a'))","decl":"theorem Finite.exists_maximal_wrt [PartialOrder β] (f : α → β) (s : Set α) (h : s.Finite)\n    (hs : s.Nonempty) : ∃ a ∈ s, ∀ a' ∈ s, f a ≤ f a' → f a = f a' := by\n  induction s, h using Set.Finite.induction_on with\n  | empty => exact absurd hs not_nonempty_empty\n  | @insert a s his _ ih =>\n    rcases s.eq_empty_or_nonempty with h | h\n    · use a\n      simp [h]\n    rcases ih h with ⟨b, hb, ih⟩\n    by_cases h : f b ≤ f a\n    · refine ⟨a, Set.mem_insert _ _, fun c hc hac => le_antisymm hac ?_⟩\n      rcases Set.mem_insert_iff.1 hc with (rfl | hcs)\n      · rfl\n      · rwa [← ih c hcs (le_trans h hac)]\n    · refine ⟨b, Set.mem_insert_of_mem _ hb, fun c hc hbc => ?_⟩\n      rcases Set.mem_insert_iff.1 hc with (rfl | hcs)\n      · exact (h hbc).elim\n      · exact ih c hcs hbc\n\n"}
{"name":"Set.Finite.exists_maximal_wrt'","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PartialOrder β\nf : α → β\ns : Set α\nh : (Set.image f s).Finite\nhs : s.Nonempty\n⊢ Exists fun a => And (Membership.mem s a) (∀ (a' : α), Membership.mem s a' → LE.le (f a) (f a') → Eq (f a) (f a'))","decl":"/-- A version of `Finite.exists_maximal_wrt` with the (weaker) hypothesis that the image of `s`\n  is finite rather than `s` itself. -/\ntheorem Finite.exists_maximal_wrt' [PartialOrder β] (f : α → β) (s : Set α) (h : (f '' s).Finite)\n    (hs : s.Nonempty) : (∃ a ∈ s, ∀ (a' : α), a' ∈ s → f a ≤ f a' → f a = f a') := by\n  obtain ⟨_, ⟨a, ha, rfl⟩, hmax⟩ := Finite.exists_maximal_wrt id (f '' s) h (hs.image f)\n  exact ⟨a, ha, fun a' ha' hf ↦ hmax _ (mem_image_of_mem f ha') hf⟩\n\n"}
{"name":"Set.Finite.exists_minimal_wrt","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PartialOrder β\nf : α → β\ns : Set α\nh : s.Finite\nhs : s.Nonempty\n⊢ Exists fun a => And (Membership.mem s a) (∀ (a' : α), Membership.mem s a' → LE.le (f a') (f a) → Eq (f a) (f a'))","decl":"theorem Finite.exists_minimal_wrt [PartialOrder β] (f : α → β) (s : Set α) (h : s.Finite)\n    (hs : s.Nonempty) : ∃ a ∈ s, ∀ a' ∈ s, f a' ≤ f a → f a = f a' :=\n  Finite.exists_maximal_wrt (β := βᵒᵈ) f s h hs\n\n"}
{"name":"Set.Finite.exists_minimal_wrt'","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PartialOrder β\nf : α → β\ns : Set α\nh : (Set.image f s).Finite\nhs : s.Nonempty\n⊢ Exists fun a => And (Membership.mem s a) (∀ (a' : α), Membership.mem s a' → LE.le (f a') (f a) → Eq (f a) (f a'))","decl":"/-- A version of `Finite.exists_minimal_wrt` with the (weaker) hypothesis that the image of `s`\n  is finite rather than `s` itself. -/\nlemma Finite.exists_minimal_wrt' [PartialOrder β] (f : α → β) (s : Set α) (h : (f '' s).Finite)\n    (hs : s.Nonempty) : (∃ a ∈ s, ∀ (a' : α), a' ∈ s → f a' ≤ f a → f a = f a') :=\n  Set.Finite.exists_maximal_wrt' (β := βᵒᵈ) f s h hs\n\n"}
{"name":"Finset.exists_card_eq","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : Infinite α\nn : Nat\n⊢ Exists fun s => Eq s.card n","decl":"lemma exists_card_eq [Infinite α] : ∀ n : ℕ, ∃ s : Finset α, s.card = n\n  | 0 => ⟨∅, card_empty⟩\n  | n + 1 => by\n    classical\n    obtain ⟨s, rfl⟩ := exists_card_eq n\n    obtain ⟨a, ha⟩ := s.exists_not_mem\n    exact ⟨insert a s, card_insert_of_not_mem ha⟩\n\n"}
{"name":"Finite.of_forall_not_lt_lt","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\nh : ∀ ⦃x y z : α⦄, LT.lt x y → LT.lt y z → False\n⊢ Finite α","decl":"/-- If a linear order does not contain any triple of elements `x < y < z`, then this type\nis finite. -/\nlemma Finite.of_forall_not_lt_lt (h : ∀ ⦃x y z : α⦄, x < y → y < z → False) : Finite α := by\n  nontriviality α\n  rcases exists_pair_ne α with ⟨x, y, hne⟩\n  refine @Finite.of_fintype α ⟨{x, y}, fun z => ?_⟩\n  simpa [hne] using eq_or_eq_or_eq_of_forall_not_lt_lt h z x y\n\n"}
{"name":"Set.finite_of_forall_not_lt_lt","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u\ninst✝ : LinearOrder α\ns : Set α\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → ∀ (z : α), Membership.mem s z → LT.lt x y → LT.lt y z → False\n⊢ s.Finite","decl":"/-- If a set `s` does not contain any triple of elements `x < y < z`, then `s` is finite. -/\nlemma Set.finite_of_forall_not_lt_lt (h : ∀ x ∈ s, ∀ y ∈ s, ∀ z ∈ s, x < y → y < z → False) :\n    Set.Finite s :=\n  @Set.toFinite _ s <| Finite.of_forall_not_lt_lt <| by simpa only [SetCoe.forall'] using h\n\n"}
{"name":"Directed.exists_mem_subset_of_finset_subset_biUnion","module":"Mathlib.Data.Set.Finite.Basic","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : Nonempty ι\nf : ι → Set α\nh : Directed (fun x1 x2 => HasSubset.Subset x1 x2) f\ns : Finset α\nhs : HasSubset.Subset (↑s) (Set.iUnion fun i => f i)\n⊢ Exists fun i => HasSubset.Subset (↑s) (f i)","decl":"lemma Directed.exists_mem_subset_of_finset_subset_biUnion {α ι : Type*} [Nonempty ι]\n    {f : ι → Set α} (h : Directed (· ⊆ ·) f) {s : Finset α} (hs : (s : Set α) ⊆ ⋃ i, f i) :\n    ∃ i, (s : Set α) ⊆ f i := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons b t hbt iht =>\n    simp only [Finset.coe_cons, Set.insert_subset_iff, Set.mem_iUnion] at hs ⊢\n    rcases hs.imp_right iht with ⟨⟨i, hi⟩, j, hj⟩\n    rcases h i j with ⟨k, hik, hjk⟩\n    exact ⟨k, hik hi, hj.trans hjk⟩\n\n"}
