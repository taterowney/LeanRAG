{"name":"IsPicardLindelof.ht₀","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝ : NormedAddCommGroup E\nv : Real → E → E\ntMin t₀ tMax : Real\nx₀ : E\nL : NNReal\nR C : Real\nself : IsPicardLindelof v tMin t₀ tMax x₀ L R C\n⊢ Membership.mem (Set.Icc tMin tMax) t₀","decl":"/-- `Prop` structure holding the hypotheses of the Picard-Lindelöf theorem.\n\nThe similarly named `PicardLindelof` structure is part of the internal API for convenience, so as\nnot to constantly invoke choice, but is not intended for public use. -/\nstructure IsPicardLindelof {E : Type*} [NormedAddCommGroup E] (v : ℝ → E → E) (tMin t₀ tMax : ℝ)\n    (x₀ : E) (L : ℝ≥0) (R C : ℝ) : Prop where\n  ht₀ : t₀ ∈ Icc tMin tMax\n  hR : 0 ≤ R\n  lipschitz : ∀ t ∈ Icc tMin tMax, LipschitzOnWith L (v t) (closedBall x₀ R)\n  cont : ∀ x ∈ closedBall x₀ R, ContinuousOn (fun t : ℝ => v t x) (Icc tMin tMax)\n  norm_le : ∀ t ∈ Icc tMin tMax, ∀ x ∈ closedBall x₀ R, ‖v t x‖ ≤ C\n  C_mul_le_R : (C : ℝ) * max (tMax - t₀) (t₀ - tMin) ≤ R\n\n"}
{"name":"IsPicardLindelof.C_mul_le_R","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝ : NormedAddCommGroup E\nv : Real → E → E\ntMin t₀ tMax : Real\nx₀ : E\nL : NNReal\nR C : Real\nself : IsPicardLindelof v tMin t₀ tMax x₀ L R C\n⊢ LE.le (HMul.hMul C (Max.max (HSub.hSub tMax t₀) (HSub.hSub t₀ tMin))) R","decl":"/-- `Prop` structure holding the hypotheses of the Picard-Lindelöf theorem.\n\nThe similarly named `PicardLindelof` structure is part of the internal API for convenience, so as\nnot to constantly invoke choice, but is not intended for public use. -/\nstructure IsPicardLindelof {E : Type*} [NormedAddCommGroup E] (v : ℝ → E → E) (tMin t₀ tMax : ℝ)\n    (x₀ : E) (L : ℝ≥0) (R C : ℝ) : Prop where\n  ht₀ : t₀ ∈ Icc tMin tMax\n  hR : 0 ≤ R\n  lipschitz : ∀ t ∈ Icc tMin tMax, LipschitzOnWith L (v t) (closedBall x₀ R)\n  cont : ∀ x ∈ closedBall x₀ R, ContinuousOn (fun t : ℝ => v t x) (Icc tMin tMax)\n  norm_le : ∀ t ∈ Icc tMin tMax, ∀ x ∈ closedBall x₀ R, ‖v t x‖ ≤ C\n  C_mul_le_R : (C : ℝ) * max (tMax - t₀) (t₀ - tMin) ≤ R\n\n"}
{"name":"IsPicardLindelof.lipschitz","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝ : NormedAddCommGroup E\nv : Real → E → E\ntMin t₀ tMax : Real\nx₀ : E\nL : NNReal\nR C : Real\nself : IsPicardLindelof v tMin t₀ tMax x₀ L R C\nt : Real\na✝ : Membership.mem (Set.Icc tMin tMax) t\n⊢ LipschitzOnWith L (v t) (Metric.closedBall x₀ R)","decl":"/-- `Prop` structure holding the hypotheses of the Picard-Lindelöf theorem.\n\nThe similarly named `PicardLindelof` structure is part of the internal API for convenience, so as\nnot to constantly invoke choice, but is not intended for public use. -/\nstructure IsPicardLindelof {E : Type*} [NormedAddCommGroup E] (v : ℝ → E → E) (tMin t₀ tMax : ℝ)\n    (x₀ : E) (L : ℝ≥0) (R C : ℝ) : Prop where\n  ht₀ : t₀ ∈ Icc tMin tMax\n  hR : 0 ≤ R\n  lipschitz : ∀ t ∈ Icc tMin tMax, LipschitzOnWith L (v t) (closedBall x₀ R)\n  cont : ∀ x ∈ closedBall x₀ R, ContinuousOn (fun t : ℝ => v t x) (Icc tMin tMax)\n  norm_le : ∀ t ∈ Icc tMin tMax, ∀ x ∈ closedBall x₀ R, ‖v t x‖ ≤ C\n  C_mul_le_R : (C : ℝ) * max (tMax - t₀) (t₀ - tMin) ≤ R\n\n"}
{"name":"IsPicardLindelof.hR","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝ : NormedAddCommGroup E\nv : Real → E → E\ntMin t₀ tMax : Real\nx₀ : E\nL : NNReal\nR C : Real\nself : IsPicardLindelof v tMin t₀ tMax x₀ L R C\n⊢ LE.le 0 R","decl":"/-- `Prop` structure holding the hypotheses of the Picard-Lindelöf theorem.\n\nThe similarly named `PicardLindelof` structure is part of the internal API for convenience, so as\nnot to constantly invoke choice, but is not intended for public use. -/\nstructure IsPicardLindelof {E : Type*} [NormedAddCommGroup E] (v : ℝ → E → E) (tMin t₀ tMax : ℝ)\n    (x₀ : E) (L : ℝ≥0) (R C : ℝ) : Prop where\n  ht₀ : t₀ ∈ Icc tMin tMax\n  hR : 0 ≤ R\n  lipschitz : ∀ t ∈ Icc tMin tMax, LipschitzOnWith L (v t) (closedBall x₀ R)\n  cont : ∀ x ∈ closedBall x₀ R, ContinuousOn (fun t : ℝ => v t x) (Icc tMin tMax)\n  norm_le : ∀ t ∈ Icc tMin tMax, ∀ x ∈ closedBall x₀ R, ‖v t x‖ ≤ C\n  C_mul_le_R : (C : ℝ) * max (tMax - t₀) (t₀ - tMin) ≤ R\n\n"}
{"name":"IsPicardLindelof.cont","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝ : NormedAddCommGroup E\nv : Real → E → E\ntMin t₀ tMax : Real\nx₀ : E\nL : NNReal\nR C : Real\nself : IsPicardLindelof v tMin t₀ tMax x₀ L R C\nx : E\na✝ : Membership.mem (Metric.closedBall x₀ R) x\n⊢ ContinuousOn (fun t => v t x) (Set.Icc tMin tMax)","decl":"/-- `Prop` structure holding the hypotheses of the Picard-Lindelöf theorem.\n\nThe similarly named `PicardLindelof` structure is part of the internal API for convenience, so as\nnot to constantly invoke choice, but is not intended for public use. -/\nstructure IsPicardLindelof {E : Type*} [NormedAddCommGroup E] (v : ℝ → E → E) (tMin t₀ tMax : ℝ)\n    (x₀ : E) (L : ℝ≥0) (R C : ℝ) : Prop where\n  ht₀ : t₀ ∈ Icc tMin tMax\n  hR : 0 ≤ R\n  lipschitz : ∀ t ∈ Icc tMin tMax, LipschitzOnWith L (v t) (closedBall x₀ R)\n  cont : ∀ x ∈ closedBall x₀ R, ContinuousOn (fun t : ℝ => v t x) (Icc tMin tMax)\n  norm_le : ∀ t ∈ Icc tMin tMax, ∀ x ∈ closedBall x₀ R, ‖v t x‖ ≤ C\n  C_mul_le_R : (C : ℝ) * max (tMax - t₀) (t₀ - tMin) ≤ R\n\n"}
{"name":"IsPicardLindelof.norm_le","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝ : NormedAddCommGroup E\nv : Real → E → E\ntMin t₀ tMax : Real\nx₀ : E\nL : NNReal\nR C : Real\nself : IsPicardLindelof v tMin t₀ tMax x₀ L R C\nt : Real\na✝¹ : Membership.mem (Set.Icc tMin tMax) t\nx : E\na✝ : Membership.mem (Metric.closedBall x₀ R) x\n⊢ LE.le (Norm.norm (v t x)) C","decl":"/-- `Prop` structure holding the hypotheses of the Picard-Lindelöf theorem.\n\nThe similarly named `PicardLindelof` structure is part of the internal API for convenience, so as\nnot to constantly invoke choice, but is not intended for public use. -/\nstructure IsPicardLindelof {E : Type*} [NormedAddCommGroup E] (v : ℝ → E → E) (tMin t₀ tMax : ℝ)\n    (x₀ : E) (L : ℝ≥0) (R C : ℝ) : Prop where\n  ht₀ : t₀ ∈ Icc tMin tMax\n  hR : 0 ≤ R\n  lipschitz : ∀ t ∈ Icc tMin tMax, LipschitzOnWith L (v t) (closedBall x₀ R)\n  cont : ∀ x ∈ closedBall x₀ R, ContinuousOn (fun t : ℝ => v t x) (Icc tMin tMax)\n  norm_le : ∀ t ∈ Icc tMin tMax, ∀ x ∈ closedBall x₀ R, ‖v t x‖ ≤ C\n  C_mul_le_R : (C : ℝ) * max (tMax - t₀) (t₀ - tMin) ≤ R\n\n"}
{"name":"PicardLindelof.isPicardLindelof","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nself : PicardLindelof E\n⊢ IsPicardLindelof self.toFun self.tMin (↑self.t₀) self.tMax self.x₀ self.L ↑self.R ↑self.C","decl":"/-- This structure holds arguments of the Picard-Lipschitz (Cauchy-Lipschitz) theorem. It is part of\nthe internal API for convenience, so as not to constantly invoke choice. Unless you want to use one\nof the auxiliary lemmas, use `IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq` instead\nof using this structure.\n\nThe similarly named `IsPicardLindelof` is a bundled `Prop` holding the long hypotheses of the\nPicard-Lindelöf theorem as named arguments. It is used as part of the public API.\n-/\nstructure PicardLindelof (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  toFun : ℝ → E → E\n  (tMin tMax : ℝ)\n  t₀ : Icc tMin tMax\n  x₀ : E\n  (C R L : ℝ≥0)\n  isPicardLindelof : IsPicardLindelof toFun tMin t₀ tMax x₀ L R C\n\n"}
{"name":"PicardLindelof.mk.inj","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ntoFun✝ : Real → E → E\ntMin✝ tMax✝ : Real\nt₀✝ : ↑(Set.Icc tMin✝ tMax✝)\nx₀✝ : E\nC✝ R✝ L✝ : NNReal\nisPicardLindelof✝ : IsPicardLindelof toFun✝ tMin✝ (↑t₀✝) tMax✝ x₀✝ L✝ ↑R✝ ↑C✝\ntoFun : Real → E → E\ntMin tMax : Real\nt₀ : ↑(Set.Icc tMin tMax)\nx₀ : E\nC R L : NNReal\nisPicardLindelof : IsPicardLindelof toFun tMin (↑t₀) tMax x₀ L ↑R ↑C\nx✝ : Eq { toFun := toFun✝, tMin := tMin✝, tMax := tMax✝, t₀ := t₀✝, x₀ := x₀✝, C := C✝, R := R✝, L := L✝, isPicardLindelof := isPicardLindelof✝ } { toFun := toFun, tMin := tMin, tMax := tMax, t₀ := t₀, x₀ := x₀, C := C, R := R, L := L, isPicardLindelof := isPicardLindelof }\n⊢ And (Eq toFun✝ toFun) (And (Eq tMin✝ tMin) (And (Eq tMax✝ tMax) (And (HEq t₀✝ t₀) (And (Eq x₀✝ x₀) (And (Eq C✝ C) (And (Eq R✝ R) (Eq L✝ L)))))))","decl":"/-- This structure holds arguments of the Picard-Lipschitz (Cauchy-Lipschitz) theorem. It is part of\nthe internal API for convenience, so as not to constantly invoke choice. Unless you want to use one\nof the auxiliary lemmas, use `IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq` instead\nof using this structure.\n\nThe similarly named `IsPicardLindelof` is a bundled `Prop` holding the long hypotheses of the\nPicard-Lindelöf theorem as named arguments. It is used as part of the public API.\n-/\nstructure PicardLindelof (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  toFun : ℝ → E → E\n  (tMin tMax : ℝ)\n  t₀ : Icc tMin tMax\n  x₀ : E\n  (C R L : ℝ≥0)\n  isPicardLindelof : IsPicardLindelof toFun tMin t₀ tMax x₀ L R C\n\n"}
{"name":"PicardLindelof.mk.injEq","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ntoFun✝ : Real → E → E\ntMin✝ tMax✝ : Real\nt₀✝ : ↑(Set.Icc tMin✝ tMax✝)\nx₀✝ : E\nC✝ R✝ L✝ : NNReal\nisPicardLindelof✝ : IsPicardLindelof toFun✝ tMin✝ (↑t₀✝) tMax✝ x₀✝ L✝ ↑R✝ ↑C✝\ntoFun : Real → E → E\ntMin tMax : Real\nt₀ : ↑(Set.Icc tMin tMax)\nx₀ : E\nC R L : NNReal\nisPicardLindelof : IsPicardLindelof toFun tMin (↑t₀) tMax x₀ L ↑R ↑C\n⊢ Eq (Eq { toFun := toFun✝, tMin := tMin✝, tMax := tMax✝, t₀ := t₀✝, x₀ := x₀✝, C := C✝, R := R✝, L := L✝, isPicardLindelof := isPicardLindelof✝ } { toFun := toFun, tMin := tMin, tMax := tMax, t₀ := t₀, x₀ := x₀, C := C, R := R, L := L, isPicardLindelof := isPicardLindelof }) (And (Eq toFun✝ toFun) (And (Eq tMin✝ tMin) (And (Eq tMax✝ tMax) (And (HEq t₀✝ t₀) (And (Eq x₀✝ x₀) (And (Eq C✝ C) (And (Eq R✝ R) (Eq L✝ L))))))))","decl":"/-- This structure holds arguments of the Picard-Lipschitz (Cauchy-Lipschitz) theorem. It is part of\nthe internal API for convenience, so as not to constantly invoke choice. Unless you want to use one\nof the auxiliary lemmas, use `IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq` instead\nof using this structure.\n\nThe similarly named `IsPicardLindelof` is a bundled `Prop` holding the long hypotheses of the\nPicard-Lindelöf theorem as named arguments. It is used as part of the public API.\n-/\nstructure PicardLindelof (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  toFun : ℝ → E → E\n  (tMin tMax : ℝ)\n  t₀ : Icc tMin tMax\n  x₀ : E\n  (C R L : ℝ≥0)\n  isPicardLindelof : IsPicardLindelof toFun tMin t₀ tMax x₀ L R C\n\n"}
{"name":"PicardLindelof.mk.sizeOf_spec","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : SizeOf E\ntoFun : Real → E → E\ntMin tMax : Real\nt₀ : ↑(Set.Icc tMin tMax)\nx₀ : E\nC R L : NNReal\nisPicardLindelof : IsPicardLindelof toFun tMin (↑t₀) tMax x₀ L ↑R ↑C\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, tMin := tMin, tMax := tMax, t₀ := t₀, x₀ := x₀, C := C, R := R, L := L, isPicardLindelof := isPicardLindelof }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf tMin)) (SizeOf.sizeOf tMax)) (SizeOf.sizeOf t₀)) (SizeOf.sizeOf x₀)) (SizeOf.sizeOf C)) (SizeOf.sizeOf R)) (SizeOf.sizeOf L)) (SizeOf.sizeOf isPicardLindelof))","decl":"/-- This structure holds arguments of the Picard-Lipschitz (Cauchy-Lipschitz) theorem. It is part of\nthe internal API for convenience, so as not to constantly invoke choice. Unless you want to use one\nof the auxiliary lemmas, use `IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq` instead\nof using this structure.\n\nThe similarly named `IsPicardLindelof` is a bundled `Prop` holding the long hypotheses of the\nPicard-Lindelöf theorem as named arguments. It is used as part of the public API.\n-/\nstructure PicardLindelof (E : Type*) [NormedAddCommGroup E] [NormedSpace ℝ E] where\n  toFun : ℝ → E → E\n  (tMin tMax : ℝ)\n  t₀ : Icc tMin tMax\n  x₀ : E\n  (C R L : ℝ≥0)\n  isPicardLindelof : IsPicardLindelof toFun tMin t₀ tMax x₀ L R C\n\n"}
{"name":"PicardLindelof.tMin_le_tMax","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\n⊢ LE.le v.tMin v.tMax","decl":"theorem tMin_le_tMax : v.tMin ≤ v.tMax :=\n  v.t₀.2.1.trans v.t₀.2.2\n\n"}
{"name":"PicardLindelof.nonempty_Icc","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\n⊢ (Set.Icc v.tMin v.tMax).Nonempty","decl":"protected theorem nonempty_Icc : (Icc v.tMin v.tMax).Nonempty :=\n  nonempty_Icc.2 v.tMin_le_tMax\n\n"}
{"name":"PicardLindelof.lipschitzOnWith","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nt : Real\nht : Membership.mem (Set.Icc v.tMin v.tMax) t\n⊢ LipschitzOnWith v.L (v.toFun t) (Metric.closedBall v.x₀ ↑v.R)","decl":"protected theorem lipschitzOnWith {t} (ht : t ∈ Icc v.tMin v.tMax) :\n    LipschitzOnWith v.L (v t) (closedBall v.x₀ v.R) :=\n  v.isPicardLindelof.lipschitz t ht\n\n"}
{"name":"PicardLindelof.continuousOn","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\n⊢ ContinuousOn (Function.uncurry v.toFun) (SProd.sprod (Set.Icc v.tMin v.tMax) (Metric.closedBall v.x₀ ↑v.R))","decl":"protected theorem continuousOn :\n    ContinuousOn (uncurry v) (Icc v.tMin v.tMax ×ˢ closedBall v.x₀ v.R) :=\n  have : ContinuousOn (uncurry (flip v)) (closedBall v.x₀ v.R ×ˢ Icc v.tMin v.tMax) :=\n    continuousOn_prod_of_continuousOn_lipschitzOnWith _ v.L v.isPicardLindelof.cont\n      v.isPicardLindelof.lipschitz\n  this.comp continuous_swap.continuousOn (preimage_swap_prod _ _).symm.subset\n\n"}
{"name":"PicardLindelof.norm_le","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nt : Real\nht : Membership.mem (Set.Icc v.tMin v.tMax) t\nx : E\nhx : Membership.mem (Metric.closedBall v.x₀ ↑v.R) x\n⊢ LE.le (Norm.norm (v.toFun t x)) ↑v.C","decl":"theorem norm_le {t : ℝ} (ht : t ∈ Icc v.tMin v.tMax) {x : E} (hx : x ∈ closedBall v.x₀ v.R) :\n    ‖v t x‖ ≤ v.C :=\n  v.isPicardLindelof.norm_le _ ht _ hx\n\n"}
{"name":"PicardLindelof.tDist_nonneg","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\n⊢ LE.le 0 v.tDist","decl":"theorem tDist_nonneg : 0 ≤ v.tDist :=\n  le_max_iff.2 <| Or.inl <| sub_nonneg.2 v.t₀.2.2\n\n"}
{"name":"PicardLindelof.dist_t₀_le","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nt : ↑(Set.Icc v.tMin v.tMax)\n⊢ LE.le (Dist.dist t v.t₀) v.tDist","decl":"theorem dist_t₀_le (t : Icc v.tMin v.tMax) : dist t v.t₀ ≤ v.tDist := by\n  rw [Subtype.dist_eq, Real.dist_eq]\n  rcases le_total t v.t₀ with ht | ht\n  · rw [abs_of_nonpos (sub_nonpos.2 <| Subtype.coe_le_coe.2 ht), neg_sub]\n    exact (sub_le_sub_left t.2.1 _).trans (le_max_right _ _)\n  · rw [abs_of_nonneg (sub_nonneg.2 <| Subtype.coe_le_coe.2 ht)]\n    exact (sub_le_sub_right t.2.2 _).trans (le_max_left _ _)\n\n"}
{"name":"PicardLindelof.proj_coe","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nt : ↑(Set.Icc v.tMin v.tMax)\n⊢ Eq (v.proj ↑t) t","decl":"theorem proj_coe (t : Icc v.tMin v.tMax) : v.proj t = t :=\n  projIcc_val _ _\n\n"}
{"name":"PicardLindelof.proj_of_mem","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nt : Real\nht : Membership.mem (Set.Icc v.tMin v.tMax) t\n⊢ Eq (↑(v.proj t)) t","decl":"theorem proj_of_mem {t : ℝ} (ht : t ∈ Icc v.tMin v.tMax) : ↑(v.proj t) = t := by\n  simp only [proj, projIcc_of_mem v.tMin_le_tMax ht]\n\n"}
{"name":"PicardLindelof.continuous_proj","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\n⊢ Continuous v.proj","decl":"@[continuity, fun_prop]\ntheorem continuous_proj : Continuous v.proj :=\n  continuous_projIcc\n\n"}
{"name":"PicardLindelof.FunSpace.mk.injEq","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\ntoFun✝ : ↑(Set.Icc v.tMin v.tMax) → E\nmap_t₀'✝ : Eq (toFun✝ v.t₀) v.x₀\nlipschitz'✝ : LipschitzWith v.C toFun✝\ntoFun : ↑(Set.Icc v.tMin v.tMax) → E\nmap_t₀' : Eq (toFun v.t₀) v.x₀\nlipschitz' : LipschitzWith v.C toFun\n⊢ Eq (Eq { toFun := toFun✝, map_t₀' := map_t₀'✝, lipschitz' := lipschitz'✝ } { toFun := toFun, map_t₀' := map_t₀', lipschitz' := lipschitz' }) (Eq toFun✝ toFun)","decl":"/-- The space of curves $γ \\colon [t_{\\min}, t_{\\max}] \\to E$ such that $γ(t₀) = x₀$ and $γ$ is\nLipschitz continuous with constant $C$. The map sending $γ$ to\n$\\mathbf Pγ(t)=x₀ + ∫_{t₀}^{t} v(τ, γ(τ))\\,dτ$ is a contracting map on this space, and its fixed\npoint is a solution of the ODE $\\dot x=v(t, x)$. -/\nstructure FunSpace where\n  toFun : Icc v.tMin v.tMax → E\n  map_t₀' : toFun v.t₀ = v.x₀\n  lipschitz' : LipschitzWith v.C toFun\n\n"}
{"name":"PicardLindelof.FunSpace.map_t₀'","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nself : v.FunSpace\n⊢ Eq (self.toFun v.t₀) v.x₀","decl":"/-- The space of curves $γ \\colon [t_{\\min}, t_{\\max}] \\to E$ such that $γ(t₀) = x₀$ and $γ$ is\nLipschitz continuous with constant $C$. The map sending $γ$ to\n$\\mathbf Pγ(t)=x₀ + ∫_{t₀}^{t} v(τ, γ(τ))\\,dτ$ is a contracting map on this space, and its fixed\npoint is a solution of the ODE $\\dot x=v(t, x)$. -/\nstructure FunSpace where\n  toFun : Icc v.tMin v.tMax → E\n  map_t₀' : toFun v.t₀ = v.x₀\n  lipschitz' : LipschitzWith v.C toFun\n\n"}
{"name":"PicardLindelof.FunSpace.mk.inj","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\ntoFun✝ : ↑(Set.Icc v.tMin v.tMax) → E\nmap_t₀'✝ : Eq (toFun✝ v.t₀) v.x₀\nlipschitz'✝ : LipschitzWith v.C toFun✝\ntoFun : ↑(Set.Icc v.tMin v.tMax) → E\nmap_t₀' : Eq (toFun v.t₀) v.x₀\nlipschitz' : LipschitzWith v.C toFun\nx✝ : Eq { toFun := toFun✝, map_t₀' := map_t₀'✝, lipschitz' := lipschitz'✝ } { toFun := toFun, map_t₀' := map_t₀', lipschitz' := lipschitz' }\n⊢ Eq toFun✝ toFun","decl":"/-- The space of curves $γ \\colon [t_{\\min}, t_{\\max}] \\to E$ such that $γ(t₀) = x₀$ and $γ$ is\nLipschitz continuous with constant $C$. The map sending $γ$ to\n$\\mathbf Pγ(t)=x₀ + ∫_{t₀}^{t} v(τ, γ(τ))\\,dτ$ is a contracting map on this space, and its fixed\npoint is a solution of the ODE $\\dot x=v(t, x)$. -/\nstructure FunSpace where\n  toFun : Icc v.tMin v.tMax → E\n  map_t₀' : toFun v.t₀ = v.x₀\n  lipschitz' : LipschitzWith v.C toFun\n\n"}
{"name":"PicardLindelof.FunSpace.mk.sizeOf_spec","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nv : PicardLindelof E\ninst✝ : SizeOf E\ntoFun : ↑(Set.Icc v.tMin v.tMax) → E\nmap_t₀' : Eq (toFun v.t₀) v.x₀\nlipschitz' : LipschitzWith v.C toFun\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_t₀' := map_t₀', lipschitz' := lipschitz' }) (HAdd.hAdd 1 (SizeOf.sizeOf map_t₀'))","decl":"/-- The space of curves $γ \\colon [t_{\\min}, t_{\\max}] \\to E$ such that $γ(t₀) = x₀$ and $γ$ is\nLipschitz continuous with constant $C$. The map sending $γ$ to\n$\\mathbf Pγ(t)=x₀ + ∫_{t₀}^{t} v(τ, γ(τ))\\,dτ$ is a contracting map on this space, and its fixed\npoint is a solution of the ODE $\\dot x=v(t, x)$. -/\nstructure FunSpace where\n  toFun : Icc v.tMin v.tMax → E\n  map_t₀' : toFun v.t₀ = v.x₀\n  lipschitz' : LipschitzWith v.C toFun\n\n"}
{"name":"PicardLindelof.FunSpace.lipschitz'","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nself : v.FunSpace\n⊢ LipschitzWith v.C self.toFun","decl":"/-- The space of curves $γ \\colon [t_{\\min}, t_{\\max}] \\to E$ such that $γ(t₀) = x₀$ and $γ$ is\nLipschitz continuous with constant $C$. The map sending $γ$ to\n$\\mathbf Pγ(t)=x₀ + ∫_{t₀}^{t} v(τ, γ(τ))\\,dτ$ is a contracting map on this space, and its fixed\npoint is a solution of the ODE $\\dot x=v(t, x)$. -/\nstructure FunSpace where\n  toFun : Icc v.tMin v.tMax → E\n  map_t₀' : toFun v.t₀ = v.x₀\n  lipschitz' : LipschitzWith v.C toFun\n\n"}
{"name":"PicardLindelof.FunSpace.lipschitz","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\n⊢ LipschitzWith v.C f.toFun","decl":"protected theorem lipschitz : LipschitzWith v.C f :=\n  f.lipschitz'\n\n"}
{"name":"PicardLindelof.FunSpace.continuous","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\n⊢ Continuous f.toFun","decl":"protected theorem continuous : Continuous f :=\n  f.lipschitz.continuous\n\n"}
{"name":"PicardLindelof.FunSpace.isUniformInducing_toContinuousMap","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\n⊢ IsUniformInducing ⇑PicardLindelof.FunSpace.toContinuousMap","decl":"theorem isUniformInducing_toContinuousMap : IsUniformInducing (@toContinuousMap _ _ _ v) :=\n  ⟨rfl⟩\n\n"}
{"name":"PicardLindelof.FunSpace.uniformInducing_toContinuousMap","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\n⊢ IsUniformInducing ⇑PicardLindelof.FunSpace.toContinuousMap","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_toContinuousMap := isUniformInducing_toContinuousMap\n\n"}
{"name":"PicardLindelof.FunSpace.range_toContinuousMap","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\n⊢ Eq (Set.range ⇑PicardLindelof.FunSpace.toContinuousMap) (setOf fun f => And (Eq (f v.t₀) v.x₀) (LipschitzWith v.C ⇑f))","decl":"theorem range_toContinuousMap :\n    range toContinuousMap =\n      {f : C(Icc v.tMin v.tMax, E) | f v.t₀ = v.x₀ ∧ LipschitzWith v.C f} := by\n  ext f; constructor\n  · rintro ⟨⟨f, hf₀, hf_lip⟩, rfl⟩; exact ⟨hf₀, hf_lip⟩\n  · rcases f with ⟨f, hf⟩; rintro ⟨hf₀, hf_lip⟩; exact ⟨⟨f, hf₀, hf_lip⟩, rfl⟩\n\n"}
{"name":"PicardLindelof.FunSpace.map_t₀","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\n⊢ Eq (f.toFun v.t₀) v.x₀","decl":"theorem map_t₀ : f v.t₀ = v.x₀ :=\n  f.map_t₀'\n\n"}
{"name":"PicardLindelof.FunSpace.mem_closedBall","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\nt : ↑(Set.Icc v.tMin v.tMax)\n⊢ Membership.mem (Metric.closedBall v.x₀ ↑v.R) (f.toFun t)","decl":"protected theorem mem_closedBall (t : Icc v.tMin v.tMax) : f t ∈ closedBall v.x₀ v.R :=\n  calc\n    dist (f t) v.x₀ = dist (f t) (f.toFun v.t₀) := by rw [f.map_t₀']\n    _ ≤ v.C * dist t v.t₀ := f.lipschitz.dist_le_mul _ _\n    _ ≤ v.C * v.tDist := mul_le_mul_of_nonneg_left (v.dist_t₀_le _) v.C.2\n    _ ≤ v.R := v.isPicardLindelof.C_mul_le_R\n\n"}
{"name":"PicardLindelof.FunSpace.vComp_apply_coe","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\nt : ↑(Set.Icc v.tMin v.tMax)\n⊢ Eq (f.vComp ↑t) (v.toFun (↑t) (f.toFun t))","decl":"theorem vComp_apply_coe (t : Icc v.tMin v.tMax) : f.vComp t = v t (f t) := by\n  simp only [vComp, proj_coe]\n\n"}
{"name":"PicardLindelof.FunSpace.continuous_vComp","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\n⊢ Continuous f.vComp","decl":"theorem continuous_vComp : Continuous f.vComp := by\n  have := (continuous_subtype_val.prod_mk f.continuous).comp v.continuous_proj\n  refine ContinuousOn.comp_continuous v.continuousOn this fun x => ?_\n  exact ⟨(v.proj x).2, f.mem_closedBall _⟩\n\n"}
{"name":"PicardLindelof.FunSpace.norm_vComp_le","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\nt : Real\n⊢ LE.le (Norm.norm (f.vComp t)) ↑v.C","decl":"theorem norm_vComp_le (t : ℝ) : ‖f.vComp t‖ ≤ v.C :=\n  v.norm_le (v.proj t).2 <| f.mem_closedBall _\n\n"}
{"name":"PicardLindelof.FunSpace.dist_apply_le_dist","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf₁ f₂ : v.FunSpace\nt : ↑(Set.Icc v.tMin v.tMax)\n⊢ LE.le (Dist.dist (f₁.toFun t) (f₂.toFun t)) (Dist.dist f₁ f₂)","decl":"theorem dist_apply_le_dist (f₁ f₂ : FunSpace v) (t : Icc v.tMin v.tMax) :\n    dist (f₁ t) (f₂ t) ≤ dist f₁ f₂ :=\n  @ContinuousMap.dist_apply_le_dist _ _ _ _ _ (toContinuousMap f₁) (toContinuousMap f₂) _\n\n"}
{"name":"PicardLindelof.FunSpace.dist_le_of_forall","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf₁ f₂ : v.FunSpace\nd : Real\nh : ∀ (t : ↑(Set.Icc v.tMin v.tMax)), LE.le (Dist.dist (f₁.toFun t) (f₂.toFun t)) d\n⊢ LE.le (Dist.dist f₁ f₂) d","decl":"theorem dist_le_of_forall {f₁ f₂ : FunSpace v} {d : ℝ} (h : ∀ t, dist (f₁ t) (f₂ t) ≤ d) :\n    dist f₁ f₂ ≤ d :=\n  (@ContinuousMap.dist_le_iff_of_nonempty _ _ _ _ _ (toContinuousMap f₁) (toContinuousMap f₂) _\n    v.nonempty_Icc.to_subtype).2 h\n\n"}
{"name":"PicardLindelof.FunSpace.instCompleteSpace","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nv : PicardLindelof E\ninst✝ : CompleteSpace E\n⊢ CompleteSpace v.FunSpace","decl":"instance [CompleteSpace E] : CompleteSpace v.FunSpace := by\n  refine (completeSpace_iff_isComplete_range isUniformInducing_toContinuousMap).2\n      (IsClosed.isComplete ?_)\n  rw [range_toContinuousMap, setOf_and]\n  refine (isClosed_eq (continuous_eval_const _) continuous_const).inter ?_\n  have : IsClosed {f : Icc v.tMin v.tMax → E | LipschitzWith v.C f} :=\n    isClosed_setOf_lipschitzWith v.C\n  exact this.preimage continuous_coeFun\n\n"}
{"name":"PicardLindelof.FunSpace.intervalIntegrable_vComp","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\nt₁ t₂ : Real\n⊢ IntervalIntegrable f.vComp MeasureTheory.MeasureSpace.volume t₁ t₂","decl":"theorem intervalIntegrable_vComp (t₁ t₂ : ℝ) : IntervalIntegrable f.vComp volume t₁ t₂ :=\n  f.continuous_vComp.intervalIntegrable _ _\n\n"}
{"name":"PicardLindelof.FunSpace.next_apply","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\nt : ↑(Set.Icc v.tMin v.tMax)\n⊢ Eq (f.next.toFun t) (HAdd.hAdd v.x₀ (intervalIntegral (fun τ => f.vComp τ) (↑v.t₀) (↑t) MeasureTheory.MeasureSpace.volume))","decl":"theorem next_apply (t : Icc v.tMin v.tMax) : f.next t = v.x₀ + ∫ τ : ℝ in v.t₀..t, f.vComp τ :=\n  rfl\n\n"}
{"name":"PicardLindelof.FunSpace.dist_next_apply_le_of_le","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf₁ f₂ : v.FunSpace\nn : Nat\nd : Real\nh : ∀ (t : ↑(Set.Icc v.tMin v.tMax)), LE.le (Dist.dist (f₁.toFun t) (f₂.toFun t)) (HMul.hMul (HDiv.hDiv (HPow.hPow (HMul.hMul (↑v.L) (abs (HSub.hSub ↑t ↑v.t₀))) n) ↑n.factorial) d)\nt : ↑(Set.Icc v.tMin v.tMax)\n⊢ LE.le (Dist.dist (f₁.next.toFun t) (f₂.next.toFun t)) (HMul.hMul (HDiv.hDiv (HPow.hPow (HMul.hMul (↑v.L) (abs (HSub.hSub ↑t ↑v.t₀))) (HAdd.hAdd n 1)) ↑(HAdd.hAdd n 1).factorial) d)","decl":"theorem dist_next_apply_le_of_le {f₁ f₂ : FunSpace v} {n : ℕ} {d : ℝ}\n    (h : ∀ t, dist (f₁ t) (f₂ t) ≤ (v.L * |t.1 - v.t₀|) ^ n / n ! * d) (t : Icc v.tMin v.tMax) :\n    dist (next f₁ t) (next f₂ t) ≤ (v.L * |t.1 - v.t₀|) ^ (n + 1) / (n + 1)! * d := by\n  simp only [dist_eq_norm, next_apply, add_sub_add_left_eq_sub, ←\n    intervalIntegral.integral_sub (intervalIntegrable_vComp _ _ _)\n      (intervalIntegrable_vComp _ _ _),\n    norm_integral_eq_norm_integral_Ioc] at *\n  calc\n    ‖∫ τ in Ι (v.t₀ : ℝ) t, f₁.vComp τ - f₂.vComp τ‖ ≤\n        ∫ τ in Ι (v.t₀ : ℝ) t, v.L * ((v.L * |τ - v.t₀|) ^ n / n ! * d) := by\n      refine norm_integral_le_of_norm_le (Continuous.integrableOn_uIoc (by fun_prop)) ?_\n      refine (ae_restrict_mem measurableSet_Ioc).mono fun τ hτ ↦ ?_\n      refine (v.lipschitzOnWith (v.proj τ).2).norm_sub_le_of_le (f₁.mem_closedBall _)\n          (f₂.mem_closedBall _) ((h _).trans_eq ?_)\n      rw [v.proj_of_mem]\n      exact uIcc_subset_Icc v.t₀.2 t.2 <| Ioc_subset_Icc_self hτ\n    _ = (v.L * |t.1 - v.t₀|) ^ (n + 1) / (n + 1)! * d := by\n      simp_rw [mul_pow, div_eq_mul_inv, mul_assoc, MeasureTheory.integral_mul_left,\n        MeasureTheory.integral_mul_right, integral_pow_abs_sub_uIoc, div_eq_mul_inv,\n        pow_succ' (v.L : ℝ), Nat.factorial_succ, Nat.cast_mul, Nat.cast_succ, mul_inv, mul_assoc]\n\n"}
{"name":"PicardLindelof.FunSpace.dist_iterate_next_apply_le","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf₁ f₂ : v.FunSpace\nn : Nat\nt : ↑(Set.Icc v.tMin v.tMax)\n⊢ LE.le (Dist.dist ((Nat.iterate PicardLindelof.FunSpace.next n f₁).toFun t) ((Nat.iterate PicardLindelof.FunSpace.next n f₂).toFun t)) (HMul.hMul (HDiv.hDiv (HPow.hPow (HMul.hMul (↑v.L) (abs (HSub.hSub ↑t ↑v.t₀))) n) ↑n.factorial) (Dist.dist f₁ f₂))","decl":"theorem dist_iterate_next_apply_le (f₁ f₂ : FunSpace v) (n : ℕ) (t : Icc v.tMin v.tMax) :\n    dist (next^[n] f₁ t) (next^[n] f₂ t) ≤ (v.L * |t.1 - v.t₀|) ^ n / n ! * dist f₁ f₂ := by\n  induction n generalizing t with\n  | zero =>\n    rw [pow_zero, Nat.factorial_zero, Nat.cast_one, div_one, one_mul]\n    exact dist_apply_le_dist f₁ f₂ t\n  | succ n ihn =>\n    rw [iterate_succ_apply', iterate_succ_apply']\n    exact dist_next_apply_le_of_le ihn _\n\n"}
{"name":"PicardLindelof.FunSpace.dist_iterate_next_le","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\nf₁ f₂ : v.FunSpace\nn : Nat\n⊢ LE.le (Dist.dist (Nat.iterate PicardLindelof.FunSpace.next n f₁) (Nat.iterate PicardLindelof.FunSpace.next n f₂)) (HMul.hMul (HDiv.hDiv (HPow.hPow (HMul.hMul (↑v.L) v.tDist) n) ↑n.factorial) (Dist.dist f₁ f₂))","decl":"theorem dist_iterate_next_le (f₁ f₂ : FunSpace v) (n : ℕ) :\n    dist (next^[n] f₁) (next^[n] f₂) ≤ (v.L * v.tDist) ^ n / n ! * dist f₁ f₂ := by\n  refine dist_le_of_forall fun t => (dist_iterate_next_apply_le _ _ _ _).trans ?_\n  have : |(t - v.t₀ : ℝ)| ≤ v.tDist := v.dist_t₀_le t\n  gcongr\n\n"}
{"name":"PicardLindelof.FunSpace.hasDerivWithinAt_next","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nv : PicardLindelof E\nf : v.FunSpace\ninst✝ : CompleteSpace E\nt : ↑(Set.Icc v.tMin v.tMax)\n⊢ HasDerivWithinAt (Function.comp f.next.toFun v.proj) (v.toFun (↑t) (f.toFun t)) (Set.Icc v.tMin v.tMax) ↑t","decl":"theorem hasDerivWithinAt_next (t : Icc v.tMin v.tMax) :\n    HasDerivWithinAt (f.next ∘ v.proj) (v t (f t)) (Icc v.tMin v.tMax) t := by\n  haveI : Fact ((t : ℝ) ∈ Icc v.tMin v.tMax) := ⟨t.2⟩\n  simp only [Function.comp_def, next_apply]\n  refine HasDerivWithinAt.const_add _ ?_\n  have : HasDerivWithinAt (∫ τ in v.t₀..·, f.vComp τ) (f.vComp t) (Icc v.tMin v.tMax) t :=\n    integral_hasDerivWithinAt_right (f.intervalIntegrable_vComp _ _)\n      (f.continuous_vComp.stronglyMeasurableAtFilter _ _)\n      f.continuous_vComp.continuousWithinAt\n  rw [vComp_apply_coe] at this\n  refine this.congr_of_eventuallyEq_of_mem ?_ t.coe_prop\n  filter_upwards [self_mem_nhdsWithin] with _ ht'\n  rw [v.proj_of_mem ht']\n\n"}
{"name":"PicardLindelof.exists_contracting_iterate","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : PicardLindelof E\n⊢ Exists fun N => Exists fun K => ContractingWith K (Nat.iterate PicardLindelof.FunSpace.next N)","decl":"theorem exists_contracting_iterate :\n    ∃ (N : ℕ) (K : _), ContractingWith K (FunSpace.next : v.FunSpace → v.FunSpace)^[N] := by\n  rcases ((FloorSemiring.tendsto_pow_div_factorial_atTop (v.L * v.tDist)).eventually\n    (gt_mem_nhds zero_lt_one)).exists with ⟨N, hN⟩\n  have : (0 : ℝ) ≤ (v.L * v.tDist) ^ N / N ! :=\n    div_nonneg (pow_nonneg (mul_nonneg v.L.2 v.tDist_nonneg) _) (Nat.cast_nonneg _)\n  exact ⟨N, ⟨_, this⟩, hN, LipschitzWith.of_dist_le_mul fun f g =>\n    FunSpace.dist_iterate_next_le f g N⟩\n\n"}
{"name":"PicardLindelof.exists_fixed","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nv : PicardLindelof E\ninst✝ : CompleteSpace E\n⊢ Exists fun f => Eq f.next f","decl":"theorem exists_fixed [CompleteSpace E] : ∃ f : v.FunSpace, f.next = f :=\n  let ⟨_N, _K, hK⟩ := exists_contracting_iterate v\n  ⟨_, hK.isFixedPt_fixedPoint_iterate⟩\n\n"}
{"name":"PicardLindelof.exists_solution","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nv : PicardLindelof E\ninst✝ : CompleteSpace E\n⊢ Exists fun f => And (Eq (f ↑v.t₀) v.x₀) (∀ (t : Real), Membership.mem (Set.Icc v.tMin v.tMax) t → HasDerivWithinAt f (v.toFun t (f t)) (Set.Icc v.tMin v.tMax) t)","decl":"/-- Picard-Lindelöf (Cauchy-Lipschitz) theorem. Use\n`IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq` instead for the public API. -/\ntheorem exists_solution [CompleteSpace E] :\n    ∃ f : ℝ → E, f v.t₀ = v.x₀ ∧ ∀ t ∈ Icc v.tMin v.tMax,\n      HasDerivWithinAt f (v t (f t)) (Icc v.tMin v.tMax) t := by\n  rcases v.exists_fixed with ⟨f, hf⟩\n  refine ⟨f ∘ v.proj, ?_, fun t ht => ?_⟩\n  · simp only [(· ∘ ·), proj_coe, f.map_t₀]\n  · simp only [(· ∘ ·), v.proj_of_mem ht]\n    lift t to Icc v.tMin v.tMax using ht\n    simpa only [hf, v.proj_coe] using f.hasDerivWithinAt_next t\n\n"}
{"name":"IsPicardLindelof.norm_le₀","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_2\ninst✝ : NormedAddCommGroup E\nv : Real → E → E\ntMin t₀ tMax : Real\nx₀ : E\nC R : Real\nL : NNReal\nhpl : IsPicardLindelof v tMin t₀ tMax x₀ L R C\n⊢ LE.le (Norm.norm (v t₀ x₀)) C","decl":"theorem IsPicardLindelof.norm_le₀ {E : Type*} [NormedAddCommGroup E] {v : ℝ → E → E}\n    {tMin t₀ tMax : ℝ} {x₀ : E} {C R : ℝ} {L : ℝ≥0}\n    (hpl : IsPicardLindelof v tMin t₀ tMax x₀ L R C) : ‖v t₀ x₀‖ ≤ C :=\n  hpl.norm_le t₀ hpl.ht₀ x₀ <| mem_closedBall_self hpl.hR\n\n"}
{"name":"IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nv : Real → E → E\ntMin t₀ tMax : Real\nx₀ : E\nC R : Real\nL : NNReal\nhpl : IsPicardLindelof v tMin t₀ tMax x₀ L R C\n⊢ Exists fun f => And (Eq (f t₀) x₀) (∀ (t : Real), Membership.mem (Set.Icc tMin tMax) t → HasDerivWithinAt f (v t (f t)) (Set.Icc tMin tMax) t)","decl":"/-- Picard-Lindelöf (Cauchy-Lipschitz) theorem. -/\ntheorem IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq [CompleteSpace E] {v : ℝ → E → E}\n    {tMin t₀ tMax : ℝ} (x₀ : E) {C R : ℝ} {L : ℝ≥0}\n    (hpl : IsPicardLindelof v tMin t₀ tMax x₀ L R C) :\n    ∃ f : ℝ → E, f t₀ = x₀ ∧\n      ∀ t ∈ Icc tMin tMax, HasDerivWithinAt f (v t (f t)) (Icc tMin tMax) t := by\n  lift C to ℝ≥0 using (norm_nonneg _).trans hpl.norm_le₀\n  lift t₀ to Icc tMin tMax using hpl.ht₀\n  exact PicardLindelof.exists_solution\n    ⟨v, tMin, tMax, t₀, x₀, C, ⟨R, hpl.hR⟩, L, { hpl with ht₀ := t₀.property }⟩\n\n"}
{"name":"exists_isPicardLindelof_const_of_contDiffAt","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nv : E → E\nt₀ : Real\nx₀ : E\nhv : ContDiffAt Real 1 v x₀\n⊢ Exists fun ε => And (GT.gt ε 0) (Exists fun L => Exists fun R => Exists fun C => IsPicardLindelof (fun x => v) (HSub.hSub t₀ ε) t₀ (HAdd.hAdd t₀ ε) x₀ L R C)","decl":"/-- A time-independent, continuously differentiable ODE satisfies the hypotheses of the\n  Picard-Lindelöf theorem. -/\ntheorem exists_isPicardLindelof_const_of_contDiffAt (hv : ContDiffAt ℝ 1 v x₀) :\n    ∃ ε > (0 : ℝ), ∃ L R C, IsPicardLindelof (fun _ => v) (t₀ - ε) t₀ (t₀ + ε) x₀ L R C := by\n  obtain ⟨L, s, hs, hlip⟩ := hv.exists_lipschitzOnWith\n  obtain ⟨R₁, hR₁ : 0 < R₁, hball⟩ := Metric.mem_nhds_iff.mp hs\n  obtain ⟨R₂, hR₂ : 0 < R₂, hbdd⟩ := Metric.continuousAt_iff.mp hv.continuousAt.norm 1 zero_lt_one\n  have hbdd' : ∀ x ∈ Metric.ball x₀ R₂, ‖v x‖ ≤ 1 + ‖v x₀‖ := fun _ hx =>\n    sub_le_iff_le_add.mp <| le_of_lt <| lt_of_abs_lt <| Real.dist_eq _ _ ▸ hbdd hx\n  set ε := min R₁ R₂ / 2 / (1 + ‖v x₀‖) with hε\n  have hε0 : 0 < ε := hε ▸ div_pos (half_pos <| lt_min hR₁ hR₂)\n    (add_pos_of_pos_of_nonneg zero_lt_one (norm_nonneg _))\n  refine ⟨ε, hε0, L, min R₁ R₂ / 2, 1 + ‖v x₀‖, ?_⟩\n  exact\n    { ht₀ := Real.closedBall_eq_Icc ▸ mem_closedBall_self hε0.le\n      hR := by positivity\n      lipschitz := fun _ _ => hlip.mono <|\n        (closedBall_subset_ball <| half_lt_self <| lt_min hR₁ hR₂).trans <|\n        (Metric.ball_subset_ball <| min_le_left _ _).trans hball\n      cont := fun _ _ => continuousOn_const\n      norm_le := fun _ _ x hx => hbdd' x <| mem_of_mem_of_subset hx <|\n        (closedBall_subset_ball <| half_lt_self <| lt_min hR₁ hR₂).trans <|\n        (Metric.ball_subset_ball <| min_le_right _ _).trans (subset_refl _)\n      C_mul_le_R := by\n        rw [add_sub_cancel_left, sub_sub_cancel, max_self, hε, mul_div_left_comm, div_self, mul_one]\n        exact ne_of_gt <| add_pos_of_pos_of_nonneg zero_lt_one <| norm_nonneg _ }\n\n"}
{"name":"exists_forall_hasDerivAt_Ioo_eq_of_contDiffAt","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nv : E → E\nt₀ : Real\nx₀ : E\ninst✝ : CompleteSpace E\nhv : ContDiffAt Real 1 v x₀\n⊢ Exists fun f => And (Eq (f t₀) x₀) (Exists fun ε => And (GT.gt ε 0) (∀ (t : Real), Membership.mem (Set.Ioo (HSub.hSub t₀ ε) (HAdd.hAdd t₀ ε)) t → HasDerivAt f (v (f t)) t))","decl":"/-- A time-independent, continuously differentiable ODE admits a solution in some open interval. -/\ntheorem exists_forall_hasDerivAt_Ioo_eq_of_contDiffAt (hv : ContDiffAt ℝ 1 v x₀) :\n    ∃ f : ℝ → E, f t₀ = x₀ ∧\n      ∃ ε > (0 : ℝ), ∀ t ∈ Ioo (t₀ - ε) (t₀ + ε), HasDerivAt f (v (f t)) t := by\n  obtain ⟨ε, hε, _, _, _, hpl⟩ := exists_isPicardLindelof_const_of_contDiffAt t₀ hv\n  obtain ⟨f, hf1, hf2⟩ := hpl.exists_forall_hasDerivWithinAt_Icc_eq x₀\n  exact ⟨f, hf1, ε, hε, fun t ht =>\n    (hf2 t (Ioo_subset_Icc_self ht)).hasDerivAt (Icc_mem_nhds ht.1 ht.2)⟩\n\n"}
{"name":"exists_forall_hasDerivAt_Ioo_eq_of_contDiff","module":"Mathlib.Analysis.ODE.PicardLindelof","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nv : E → E\nt₀ : Real\nx₀ : E\ninst✝ : CompleteSpace E\nhv : ContDiff Real 1 v\n⊢ Exists fun f => And (Eq (f t₀) x₀) (Exists fun ε => And (GT.gt ε 0) (∀ (t : Real), Membership.mem (Set.Ioo (HSub.hSub t₀ ε) (HAdd.hAdd t₀ ε)) t → HasDerivAt f (v (f t)) t))","decl":"/-- A time-independent, continuously differentiable ODE admits a solution in some open interval. -/\ntheorem exists_forall_hasDerivAt_Ioo_eq_of_contDiff (hv : ContDiff ℝ 1 v) :\n    ∃ f : ℝ → E, f t₀ = x₀ ∧\n      ∃ ε > (0 : ℝ), ∀ t ∈ Ioo (t₀ - ε) (t₀ + ε), HasDerivAt f (v (f t)) t :=\n  let ⟨f, hf1, ε, hε, hf2⟩ :=\n    exists_forall_hasDerivAt_Ioo_eq_of_contDiffAt t₀ hv.contDiffAt\n  ⟨f, hf1, ε, hε, fun _ h => hf2 _ h⟩\n"}
