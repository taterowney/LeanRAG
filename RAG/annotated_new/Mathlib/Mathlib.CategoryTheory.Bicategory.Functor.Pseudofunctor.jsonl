{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_whisker_left","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b c : B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nŒ∑ : Quiver.Hom g h\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (CategoryTheory.CategoryStruct.comp (self.mapComp f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.map‚ÇÇ Œ∑)) (self.mapComp f h).inv))","decl":"/-- A pseudofunctor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the compositions,\nand do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms\n`F.map (ùüô a) ‚âÖ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure Pseudofunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n    [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  mapId (a : B) : map (ùüô a) ‚âÖ ùüô (obj a)\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚âÖ map f ‚â´ map g\n  map‚ÇÇ_whisker_left :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h),\n      map‚ÇÇ (f ‚óÅ Œ∑) = (mapComp f g).hom ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ (mapComp f h).inv := by\n    aesop_cat\n  map‚ÇÇ_whisker_right :\n    ‚àÄ {a b c : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (h : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ h) = (mapComp f h).hom ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map h ‚â´ (mapComp g h).inv := by\n    aesop_cat\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom = (mapComp (f ‚â´ g) h).hom ‚â´ (mapComp f g).hom ‚ñ∑ map h ‚â´\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ (mapComp g h).inv ‚â´\n      (mapComp f (g ‚â´ h)).inv := by\n    aesop_cat\n  map‚ÇÇ_left_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = (mapComp (ùüô a) f).hom ‚â´ (mapId a).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  map‚ÇÇ_right_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = (mapComp f (ùüô b)).hom ‚â´ map f ‚óÅ (mapId b).hom ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\ntoPrelaxFunctor‚úù : CategoryTheory.PrelaxFunctor B C\nmapId‚úù : (a : B) ‚Üí CategoryTheory.Iso (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor‚úù.obj a))\nmapComp‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g))\nmap‚ÇÇ_whisker_left‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g h : Quiver.Hom b c} (Œ∑ : Quiver.Hom g h), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑)) (mapComp‚úù f h).inv))) _auto‚úù\nmap‚ÇÇ_whisker_right‚úù : autoParam (‚àÄ {a b c : B} {f g : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (h : Quiver.Hom b c), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ h)) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑) (toPrelaxFunctor‚úù.map h)) (mapComp‚úù g h).inv))) _auto‚úù\nmap‚ÇÇ_associator‚úù : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp‚úù f g).hom (toPrelaxFunctor‚úù.map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g) (toPrelaxFunctor‚úù.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapComp‚úù g h).inv) (mapComp‚úù f (CategoryTheory.CategoryStruct.comp g h)).inv))))) _auto‚úù\nmap‚ÇÇ_left_unitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.id a) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId‚úù a).hom (toPrelaxFunctor‚úù.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor‚úù.map f)).hom))) _auto‚úù\nmap‚ÇÇ_right_unitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f (CategoryTheory.CategoryStruct.id b)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapId‚úù b).hom) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor‚úù.map f)).hom))) _auto‚úù\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) ‚Üí CategoryTheory.Iso (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a))\nmapComp : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g))\nmap‚ÇÇ_whisker_left : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g h : Quiver.Hom b c} (Œ∑ : Quiver.Hom g h), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (CategoryTheory.CategoryStruct.comp (mapComp f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map‚ÇÇ Œ∑)) (mapComp f h).inv))) _auto‚úù\nmap‚ÇÇ_whisker_right : autoParam (‚àÄ {a b c : B} {f g : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (h : Quiver.Hom b c), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ h)) (CategoryTheory.CategoryStruct.comp (mapComp f h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map‚ÇÇ Œ∑) (toPrelaxFunctor.map h)) (mapComp g h).inv))) _auto‚úù\nmap‚ÇÇ_associator : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (toPrelaxFunctor.map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv))))) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id a) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a).hom (toPrelaxFunctor.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b).hom) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\n‚ä¢ Eq (Eq { toPrelaxFunctor := toPrelaxFunctor‚úù, mapId := mapId‚úù, mapComp := mapComp‚úù, map‚ÇÇ_whisker_left := map‚ÇÇ_whisker_left‚úù, map‚ÇÇ_whisker_right := map‚ÇÇ_whisker_right‚úù, map‚ÇÇ_associator := map‚ÇÇ_associator‚úù, map‚ÇÇ_left_unitor := map‚ÇÇ_left_unitor‚úù, map‚ÇÇ_right_unitor := map‚ÇÇ_right_unitor‚úù } { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, map‚ÇÇ_whisker_left := map‚ÇÇ_whisker_left, map‚ÇÇ_whisker_right := map‚ÇÇ_whisker_right, map‚ÇÇ_associator := map‚ÇÇ_associator, map‚ÇÇ_left_unitor := map‚ÇÇ_left_unitor, map‚ÇÇ_right_unitor := map‚ÇÇ_right_unitor }) (And (Eq toPrelaxFunctor‚úù toPrelaxFunctor) (And (HEq mapId‚úù mapId) (HEq mapComp‚úù mapComp)))","decl":"/-- A pseudofunctor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the compositions,\nand do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms\n`F.map (ùüô a) ‚âÖ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure Pseudofunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n    [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  mapId (a : B) : map (ùüô a) ‚âÖ ùüô (obj a)\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚âÖ map f ‚â´ map g\n  map‚ÇÇ_whisker_left :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h),\n      map‚ÇÇ (f ‚óÅ Œ∑) = (mapComp f g).hom ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ (mapComp f h).inv := by\n    aesop_cat\n  map‚ÇÇ_whisker_right :\n    ‚àÄ {a b c : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (h : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ h) = (mapComp f h).hom ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map h ‚â´ (mapComp g h).inv := by\n    aesop_cat\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom = (mapComp (f ‚â´ g) h).hom ‚â´ (mapComp f g).hom ‚ñ∑ map h ‚â´\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ (mapComp g h).inv ‚â´\n      (mapComp f (g ‚â´ h)).inv := by\n    aesop_cat\n  map‚ÇÇ_left_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = (mapComp (ùüô a) f).hom ‚â´ (mapId a).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  map‚ÇÇ_right_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = (mapComp f (ùüô b)).hom ‚â´ map f ‚óÅ (mapId b).hom ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_associator","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapComp f g).hom (self.map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapComp g h).inv) (self.mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv))))","decl":"/-- A pseudofunctor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the compositions,\nand do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms\n`F.map (ùüô a) ‚âÖ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure Pseudofunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n    [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  mapId (a : B) : map (ùüô a) ‚âÖ ùüô (obj a)\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚âÖ map f ‚â´ map g\n  map‚ÇÇ_whisker_left :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h),\n      map‚ÇÇ (f ‚óÅ Œ∑) = (mapComp f g).hom ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ (mapComp f h).inv := by\n    aesop_cat\n  map‚ÇÇ_whisker_right :\n    ‚àÄ {a b c : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (h : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ h) = (mapComp f h).hom ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map h ‚â´ (mapComp g h).inv := by\n    aesop_cat\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom = (mapComp (f ‚â´ g) h).hom ‚â´ (mapComp f g).hom ‚ñ∑ map h ‚â´\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ (mapComp g h).inv ‚â´\n      (mapComp f (g ‚â´ h)).inv := by\n    aesop_cat\n  map‚ÇÇ_left_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = (mapComp (ùüô a) f).hom ‚â´ (mapId a).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  map‚ÇÇ_right_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = (mapComp f (ùüô b)).hom ‚â´ map f ‚óÅ (mapId b).hom ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_left_unitor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.id a) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapId a).hom (self.map f)) (CategoryTheory.Bicategory.leftUnitor (self.map f)).hom))","decl":"/-- A pseudofunctor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the compositions,\nand do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms\n`F.map (ùüô a) ‚âÖ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure Pseudofunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n    [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  mapId (a : B) : map (ùüô a) ‚âÖ ùüô (obj a)\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚âÖ map f ‚â´ map g\n  map‚ÇÇ_whisker_left :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h),\n      map‚ÇÇ (f ‚óÅ Œ∑) = (mapComp f g).hom ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ (mapComp f h).inv := by\n    aesop_cat\n  map‚ÇÇ_whisker_right :\n    ‚àÄ {a b c : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (h : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ h) = (mapComp f h).hom ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map h ‚â´ (mapComp g h).inv := by\n    aesop_cat\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom = (mapComp (f ‚â´ g) h).hom ‚â´ (mapComp f g).hom ‚ñ∑ map h ‚â´\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ (mapComp g h).inv ‚â´\n      (mapComp f (g ‚â´ h)).inv := by\n    aesop_cat\n  map‚ÇÇ_left_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = (mapComp (ùüô a) f).hom ‚â´ (mapId a).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  map‚ÇÇ_right_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = (mapComp f (ùüô b)).hom ‚â´ map f ‚óÅ (mapId b).hom ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_whisker_right","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b c : B\nf g : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\nh : Quiver.Hom b c\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ h)) (CategoryTheory.CategoryStruct.comp (self.mapComp f h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.map‚ÇÇ Œ∑) (self.map h)) (self.mapComp g h).inv))","decl":"/-- A pseudofunctor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the compositions,\nand do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms\n`F.map (ùüô a) ‚âÖ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure Pseudofunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n    [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  mapId (a : B) : map (ùüô a) ‚âÖ ùüô (obj a)\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚âÖ map f ‚â´ map g\n  map‚ÇÇ_whisker_left :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h),\n      map‚ÇÇ (f ‚óÅ Œ∑) = (mapComp f g).hom ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ (mapComp f h).inv := by\n    aesop_cat\n  map‚ÇÇ_whisker_right :\n    ‚àÄ {a b c : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (h : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ h) = (mapComp f h).hom ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map h ‚â´ (mapComp g h).inv := by\n    aesop_cat\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom = (mapComp (f ‚â´ g) h).hom ‚â´ (mapComp f g).hom ‚ñ∑ map h ‚â´\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ (mapComp g h).inv ‚â´\n      (mapComp f (g ‚â´ h)).inv := by\n    aesop_cat\n  map‚ÇÇ_left_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = (mapComp (ùüô a) f).hom ‚â´ (mapId a).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  map‚ÇÇ_right_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = (mapComp f (ùüô b)).hom ‚â´ map f ‚óÅ (mapId b).hom ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_right_unitor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (self.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.id b)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapId b).hom) (CategoryTheory.Bicategory.rightUnitor (self.map f)).hom))","decl":"/-- A pseudofunctor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the compositions,\nand do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms\n`F.map (ùüô a) ‚âÖ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure Pseudofunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n    [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  mapId (a : B) : map (ùüô a) ‚âÖ ùüô (obj a)\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚âÖ map f ‚â´ map g\n  map‚ÇÇ_whisker_left :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h),\n      map‚ÇÇ (f ‚óÅ Œ∑) = (mapComp f g).hom ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ (mapComp f h).inv := by\n    aesop_cat\n  map‚ÇÇ_whisker_right :\n    ‚àÄ {a b c : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (h : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ h) = (mapComp f h).hom ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map h ‚â´ (mapComp g h).inv := by\n    aesop_cat\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom = (mapComp (f ‚â´ g) h).hom ‚â´ (mapComp f g).hom ‚ñ∑ map h ‚â´\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ (mapComp g h).inv ‚â´\n      (mapComp f (g ‚â´ h)).inv := by\n    aesop_cat\n  map‚ÇÇ_left_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = (mapComp (ùüô a) f).hom ‚â´ (mapId a).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  map‚ÇÇ_right_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = (mapComp f (ùüô b)).hom ‚â´ map f ‚óÅ (mapId b).hom ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\ninst‚úù¬π : SizeOf B\ninst‚úù : SizeOf C\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) ‚Üí CategoryTheory.Iso (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a))\nmapComp : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g))\nmap‚ÇÇ_whisker_left : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g h : Quiver.Hom b c} (Œ∑ : Quiver.Hom g h), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (CategoryTheory.CategoryStruct.comp (mapComp f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map‚ÇÇ Œ∑)) (mapComp f h).inv))) _auto‚úù\nmap‚ÇÇ_whisker_right : autoParam (‚àÄ {a b c : B} {f g : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (h : Quiver.Hom b c), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ h)) (CategoryTheory.CategoryStruct.comp (mapComp f h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map‚ÇÇ Œ∑) (toPrelaxFunctor.map h)) (mapComp g h).inv))) _auto‚úù\nmap‚ÇÇ_associator : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (toPrelaxFunctor.map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv))))) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id a) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a).hom (toPrelaxFunctor.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b).hom) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, map‚ÇÇ_whisker_left := map‚ÇÇ_whisker_left, map‚ÇÇ_whisker_right := map‚ÇÇ_whisker_right, map‚ÇÇ_associator := map‚ÇÇ_associator, map‚ÇÇ_left_unitor := map‚ÇÇ_left_unitor, map‚ÇÇ_right_unitor := map‚ÇÇ_right_unitor }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrelaxFunctor))","decl":"/-- A pseudofunctor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the compositions,\nand do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms\n`F.map (ùüô a) ‚âÖ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure Pseudofunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n    [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  mapId (a : B) : map (ùüô a) ‚âÖ ùüô (obj a)\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚âÖ map f ‚â´ map g\n  map‚ÇÇ_whisker_left :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h),\n      map‚ÇÇ (f ‚óÅ Œ∑) = (mapComp f g).hom ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ (mapComp f h).inv := by\n    aesop_cat\n  map‚ÇÇ_whisker_right :\n    ‚àÄ {a b c : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (h : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ h) = (mapComp f h).hom ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map h ‚â´ (mapComp g h).inv := by\n    aesop_cat\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom = (mapComp (f ‚â´ g) h).hom ‚â´ (mapComp f g).hom ‚ñ∑ map h ‚â´\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ (mapComp g h).inv ‚â´\n      (mapComp f (g ‚â´ h)).inv := by\n    aesop_cat\n  map‚ÇÇ_left_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = (mapComp (ùüô a) f).hom ‚â´ (mapId a).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  map‚ÇÇ_right_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = (mapComp f (ùüô b)).hom ‚â´ map f ‚óÅ (mapId b).hom ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\ntoPrelaxFunctor‚úù : CategoryTheory.PrelaxFunctor B C\nmapId‚úù : (a : B) ‚Üí CategoryTheory.Iso (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor‚úù.obj a))\nmapComp‚úù : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (toPrelaxFunctor‚úù.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g))\nmap‚ÇÇ_whisker_left‚úù : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g h : Quiver.Hom b c} (Œ∑ : Quiver.Hom g h), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑)) (mapComp‚úù f h).inv))) _auto‚úù\nmap‚ÇÇ_whisker_right‚úù : autoParam (‚àÄ {a b c : B} {f g : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (h : Quiver.Hom b c), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ h)) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor‚úù.map‚ÇÇ Œ∑) (toPrelaxFunctor‚úù.map h)) (mapComp‚úù g h).inv))) _auto‚úù\nmap‚ÇÇ_associator‚úù : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp‚úù f g).hom (toPrelaxFunctor‚úù.map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor‚úù.map f) (toPrelaxFunctor‚úù.map g) (toPrelaxFunctor‚úù.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapComp‚úù g h).inv) (mapComp‚úù f (CategoryTheory.CategoryStruct.comp g h)).inv))))) _auto‚úù\nmap‚ÇÇ_left_unitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù (CategoryTheory.CategoryStruct.id a) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId‚úù a).hom (toPrelaxFunctor‚úù.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor‚úù.map f)).hom))) _auto‚úù\nmap‚ÇÇ_right_unitor‚úù : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor‚úù.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp‚úù f (CategoryTheory.CategoryStruct.id b)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor‚úù.map f) (mapId‚úù b).hom) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor‚úù.map f)).hom))) _auto‚úù\ntoPrelaxFunctor : CategoryTheory.PrelaxFunctor B C\nmapId : (a : B) ‚Üí CategoryTheory.Iso (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (toPrelaxFunctor.obj a))\nmapComp : {a b c : B} ‚Üí (f : Quiver.Hom a b) ‚Üí (g : Quiver.Hom b c) ‚Üí CategoryTheory.Iso (toPrelaxFunctor.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrelaxFunctor.map f) (toPrelaxFunctor.map g))\nmap‚ÇÇ_whisker_left : autoParam (‚àÄ {a b c : B} (f : Quiver.Hom a b) {g h : Quiver.Hom b c} (Œ∑ : Quiver.Hom g h), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) (CategoryTheory.CategoryStruct.comp (mapComp f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (toPrelaxFunctor.map‚ÇÇ Œ∑)) (mapComp f h).inv))) _auto‚úù\nmap‚ÇÇ_whisker_right : autoParam (‚àÄ {a b c : B} {f g : Quiver.Hom a b} (Œ∑ : Quiver.Hom f g) (h : Quiver.Hom b c), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ h)) (CategoryTheory.CategoryStruct.comp (mapComp f h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (toPrelaxFunctor.map‚ÇÇ Œ∑) (toPrelaxFunctor.map h)) (mapComp g h).inv))) _auto‚úù\nmap‚ÇÇ_associator : autoParam (‚àÄ {a b c d : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c) (h : Quiver.Hom c d), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (toPrelaxFunctor.map h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (toPrelaxFunctor.map f) (toPrelaxFunctor.map g) (toPrelaxFunctor.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapComp g h).inv) (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv))))) _auto‚úù\nmap‚ÇÇ_left_unitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id a) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId a).hom (toPrelaxFunctor.map f)) (CategoryTheory.Bicategory.leftUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\nmap‚ÇÇ_right_unitor : autoParam (‚àÄ {a b : B} (f : Quiver.Hom a b), Eq (toPrelaxFunctor.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (toPrelaxFunctor.map f) (mapId b).hom) (CategoryTheory.Bicategory.rightUnitor (toPrelaxFunctor.map f)).hom))) _auto‚úù\nx‚úù : Eq { toPrelaxFunctor := toPrelaxFunctor‚úù, mapId := mapId‚úù, mapComp := mapComp‚úù, map‚ÇÇ_whisker_left := map‚ÇÇ_whisker_left‚úù, map‚ÇÇ_whisker_right := map‚ÇÇ_whisker_right‚úù, map‚ÇÇ_associator := map‚ÇÇ_associator‚úù, map‚ÇÇ_left_unitor := map‚ÇÇ_left_unitor‚úù, map‚ÇÇ_right_unitor := map‚ÇÇ_right_unitor‚úù } { toPrelaxFunctor := toPrelaxFunctor, mapId := mapId, mapComp := mapComp, map‚ÇÇ_whisker_left := map‚ÇÇ_whisker_left, map‚ÇÇ_whisker_right := map‚ÇÇ_whisker_right, map‚ÇÇ_associator := map‚ÇÇ_associator, map‚ÇÇ_left_unitor := map‚ÇÇ_left_unitor, map‚ÇÇ_right_unitor := map‚ÇÇ_right_unitor }\n‚ä¢ And (Eq toPrelaxFunctor‚úù toPrelaxFunctor) (And (HEq mapId‚úù mapId) (HEq mapComp‚úù mapComp))","decl":"/-- A pseudofunctor `F` between bicategories `B` and `C` consists of a function between objects\n`F.obj`, a function between 1-morphisms `F.map`, and a function between 2-morphisms `F.map‚ÇÇ`.\n\nUnlike functors between categories, `F.map` do not need to strictly commute with the compositions,\nand do not need to strictly preserve the identity. Instead, there are specified 2-isomorphisms\n`F.map (ùüô a) ‚âÖ ùüô (F.obj a)` and `F.map (f ‚â´ g) ‚âÖ F.map f ‚â´ F.map g`.\n\n`F.map‚ÇÇ` strictly commute with compositions and preserve the identity. They also preserve the\nassociator, the left unitor, and the right unitor modulo some adjustments of domains and codomains\nof 2-morphisms.\n-/\nstructure Pseudofunctor (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] (C : Type u‚ÇÇ)\n    [Bicategory.{w‚ÇÇ, v‚ÇÇ} C] extends PrelaxFunctor B C where\n  mapId (a : B) : map (ùüô a) ‚âÖ ùüô (obj a)\n  mapComp {a b c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) : map (f ‚â´ g) ‚âÖ map f ‚â´ map g\n  map‚ÇÇ_whisker_left :\n    ‚àÄ {a b c : B} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : g ‚ü∂ h),\n      map‚ÇÇ (f ‚óÅ Œ∑) = (mapComp f g).hom ‚â´ map f ‚óÅ map‚ÇÇ Œ∑ ‚â´ (mapComp f h).inv := by\n    aesop_cat\n  map‚ÇÇ_whisker_right :\n    ‚àÄ {a b c : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (h : b ‚ü∂ c),\n      map‚ÇÇ (Œ∑ ‚ñ∑ h) = (mapComp f h).hom ‚â´ map‚ÇÇ Œ∑ ‚ñ∑ map h ‚â´ (mapComp g h).inv := by\n    aesop_cat\n  map‚ÇÇ_associator :\n    ‚àÄ {a b c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n      map‚ÇÇ (Œ±_ f g h).hom = (mapComp (f ‚â´ g) h).hom ‚â´ (mapComp f g).hom ‚ñ∑ map h ‚â´\n      (Œ±_ (map f) (map g) (map h)).hom ‚â´ map f ‚óÅ (mapComp g h).inv ‚â´\n      (mapComp f (g ‚â´ h)).inv := by\n    aesop_cat\n  map‚ÇÇ_left_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (Œª_ f).hom = (mapComp (ùüô a) f).hom ‚â´ (mapId a).hom ‚ñ∑ map f ‚â´ (Œª_ (map f)).hom := by\n    aesop_cat\n  map‚ÇÇ_right_unitor :\n    ‚àÄ {a b : B} (f : a ‚ü∂ b),\n      map‚ÇÇ (œÅ_ f).hom = (mapComp f (ùüô b)).hom ‚â´ map f ‚óÅ (mapId b).hom ‚â´ (œÅ_ (map f)).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_right_unitor_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(self.obj a)\n‚ä¢ Eq ((self.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom).app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp f (CategoryTheory.CategoryStruct.id b)).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.mapId b).hom.app ((self.map f).obj X)) ((CategoryTheory.Bicategory.rightUnitor (self.map f)).hom.app X)))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_whisker_right_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b c : B\nf g : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\nh‚úù : Quiver.Hom b c\nZ : Quiver.Hom (self.obj a) (self.obj c)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp g h‚úù)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ h‚úù)) h) (CategoryTheory.CategoryStruct.comp (self.mapComp f h‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.map‚ÇÇ Œ∑) (self.map h‚úù)) (CategoryTheory.CategoryStruct.comp (self.mapComp g h‚úù).inv h)))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_whisker_right_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b c : B\nf g : Quiver.Hom a b\nŒ∑ : Quiver.Hom f g\nh : Quiver.Hom b c\nX : ‚Üë(self.obj a)\n‚ä¢ Eq ((self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerRight Œ∑ h)).app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp f h).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.map h).map ((self.map‚ÇÇ Œ∑).app X)) ((self.mapComp g h).inv.app X)))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_whisker_left_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b c : B\nf : Quiver.Hom a b\ng h‚úù : Quiver.Hom b c\nŒ∑ : Quiver.Hom g h‚úù\nZ : Quiver.Hom (self.obj a) (self.obj c)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f h‚úù)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)) h) (CategoryTheory.CategoryStruct.comp (self.mapComp f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.map‚ÇÇ Œ∑)) (CategoryTheory.CategoryStruct.comp (self.mapComp f h‚úù).inv h)))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_right_unitor_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) h) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.id b)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapId b).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (self.map f)).hom h)))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_left_unitor_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (self.obj a) (self.obj b)\nh : Quiver.Hom (self.map f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) h) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.id a) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapId a).hom (self.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.map f)).hom h)))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_whisker_left_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b c : B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nŒ∑ : Quiver.Hom g h\nX : ‚Üë(self.obj a)\n‚ä¢ Eq ((self.map‚ÇÇ (CategoryTheory.Bicategory.whiskerLeft f Œ∑)).app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp f g).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.map‚ÇÇ Œ∑).app ((self.map f).obj X)) ((self.mapComp f h).inv.app X)))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_associator_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nself : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (self.obj a) (self.obj d)\nh : Quiver.Hom (self.map (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h‚úù))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).hom) h) (CategoryTheory.CategoryStruct.comp (self.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.mapComp f g).hom (self.map h‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h‚úù)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.map f) (self.mapComp g h‚úù).inv) (CategoryTheory.CategoryStruct.comp (self.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)).inv h)))))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_associator_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(self.obj a)\n‚ä¢ Eq ((self.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom).app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.map h).map ((self.mapComp f g).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.associator (self.map f) (self.map g) (self.map h)).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp g h).inv.app ((self.map f).obj X)) ((self.mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv.app X)))))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.map‚ÇÇ_left_unitor_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nself : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(self.obj a)\n‚ä¢ Eq ((self.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom).app X) (CategoryTheory.CategoryStruct.comp ((self.mapComp (CategoryTheory.CategoryStruct.id a) f).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.map f).map ((self.mapId a).hom.app X)) ((CategoryTheory.Bicategory.leftUnitor (self.map f)).hom.app X)))","decl":"attribute [simp, reassoc, to_app]\n  map‚ÇÇ_whisker_left map‚ÇÇ_whisker_right map‚ÇÇ_associator map‚ÇÇ_left_unitor map‚ÇÇ_right_unitor\n\n"}
{"name":"CategoryTheory.Pseudofunctor.toOplax_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\n‚ä¢ Eq F.toOplax.toPrelaxFunctor F.toPrelaxFunctor","decl":"/-- The oplax functor associated with a pseudofunctor. -/\n@[simps]\ndef toOplax : OplaxFunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => (F.mapId a).hom\n  mapComp := fun f g => (F.mapComp f g).hom\n\n"}
{"name":"CategoryTheory.Pseudofunctor.toOplax_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq (F.toOplax.mapComp f g) (F.mapComp f g).hom","decl":"/-- The oplax functor associated with a pseudofunctor. -/\n@[simps]\ndef toOplax : OplaxFunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => (F.mapId a).hom\n  mapComp := fun f g => (F.mapComp f g).hom\n\n"}
{"name":"CategoryTheory.Pseudofunctor.toOplax_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na : B\n‚ä¢ Eq (F.toOplax.mapId a) (F.mapId a).hom","decl":"/-- The oplax functor associated with a pseudofunctor. -/\n@[simps]\ndef toOplax : OplaxFunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => (F.mapId a).hom\n  mapComp := fun f g => (F.mapComp f g).hom\n\n"}
{"name":"CategoryTheory.Pseudofunctor.toLax_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na : B\n‚ä¢ Eq (F.toLax.mapId a) (F.mapId a).inv","decl":"/-- The Lax functor associated with a pseudofunctor. -/\n@[simps]\ndef toLax : LaxFunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => (F.mapId a).inv\n  mapComp := fun f g => (F.mapComp f g).inv\n  map‚ÇÇ_leftUnitor f := by\n    rw [‚Üê F.map‚ÇÇIso_inv, eq_inv_comp, comp_inv_eq]\n    simp\n  map‚ÇÇ_rightUnitor f := by\n    rw [‚Üê F.map‚ÇÇIso_inv, eq_inv_comp, comp_inv_eq]\n    simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.toLax_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq (F.toLax.mapComp f g) (F.mapComp f g).inv","decl":"/-- The Lax functor associated with a pseudofunctor. -/\n@[simps]\ndef toLax : LaxFunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => (F.mapId a).inv\n  mapComp := fun f g => (F.mapComp f g).inv\n  map‚ÇÇ_leftUnitor f := by\n    rw [‚Üê F.map‚ÇÇIso_inv, eq_inv_comp, comp_inv_eq]\n    simp\n  map‚ÇÇ_rightUnitor f := by\n    rw [‚Üê F.map‚ÇÇIso_inv, eq_inv_comp, comp_inv_eq]\n    simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.toLax_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\n‚ä¢ Eq F.toLax.toPrelaxFunctor F.toPrelaxFunctor","decl":"/-- The Lax functor associated with a pseudofunctor. -/\n@[simps]\ndef toLax : LaxFunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => (F.mapId a).inv\n  mapComp := fun f g => (F.mapComp f g).inv\n  map‚ÇÇ_leftUnitor f := by\n    rw [‚Üê F.map‚ÇÇIso_inv, eq_inv_comp, comp_inv_eq]\n    simp\n  map‚ÇÇ_rightUnitor f := by\n    rw [‚Üê F.map‚ÇÇIso_inv, eq_inv_comp, comp_inv_eq]\n    simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.id_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\na : B\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.id B).mapId a) (CategoryTheory.Iso.refl (CategoryTheory.CategoryStruct.id a))","decl":"/-- The identity pseudofunctor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : Pseudofunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => Iso.refl (ùüô a)\n  mapComp := fun f g => Iso.refl (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.Pseudofunctor.id_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\n‚ä¢ Eq (CategoryTheory.Pseudofunctor.id B).toPrelaxFunctor (CategoryTheory.PrelaxFunctor.id B)","decl":"/-- The identity pseudofunctor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : Pseudofunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => Iso.refl (ùüô a)\n  mapComp := fun f g => Iso.refl (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.Pseudofunctor.id_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Bicategory B\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.id B).mapComp f g) (CategoryTheory.Iso.refl (CategoryTheory.CategoryStruct.comp f g))","decl":"/-- The identity pseudofunctor. -/\n@[simps]\ndef id (B : Type u‚ÇÅ) [Bicategory.{w‚ÇÅ, v‚ÇÅ} B] : Pseudofunctor B B where\n  toPrelaxFunctor := PrelaxFunctor.id B\n  mapId := fun a => Iso.refl (ùüô a)\n  mapComp := fun f g => Iso.refl (f ‚â´ g)\n\n"}
{"name":"CategoryTheory.Pseudofunctor.comp_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Bicategory D\nF : CategoryTheory.Pseudofunctor B C\nG : CategoryTheory.Pseudofunctor C D\n‚ä¢ Eq (F.comp G).toPrelaxFunctor (F.comp G.toPrelaxFunctor)","decl":"/-- Composition of pseudofunctors. -/\n@[simps]\ndef comp (F : Pseudofunctor B C) (G : Pseudofunctor C D) : Pseudofunctor B D where\n  toPrelaxFunctor := F.toPrelaxFunctor.comp G.toPrelaxFunctor\n  mapId := fun a => G.map‚ÇÇIso (F.mapId a) ‚â™‚â´ G.mapId (F.obj a)\n  mapComp := fun f g => (G.map‚ÇÇIso (F.mapComp f g)) ‚â™‚â´ G.mapComp (F.map f) (F.map g)\n  -- Note: whilst these are all provable by `aesop_cat`, the proof is very slow\n  map‚ÇÇ_whisker_left f Œ∑ := by dsimp; simp\n  map‚ÇÇ_whisker_right Œ∑ h := by dsimp; simp\n  map‚ÇÇ_associator f g h := by dsimp; simp\n  map‚ÇÇ_left_unitor f := by dsimp; simp\n  map‚ÇÇ_right_unitor f := by dsimp; simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.comp_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Bicategory D\nF : CategoryTheory.Pseudofunctor B C\nG : CategoryTheory.Pseudofunctor C D\na : B\n‚ä¢ Eq ((F.comp G).mapId a) ((G.map‚ÇÇIso (F.mapId a)).trans (G.mapId (F.obj a)))","decl":"/-- Composition of pseudofunctors. -/\n@[simps]\ndef comp (F : Pseudofunctor B C) (G : Pseudofunctor C D) : Pseudofunctor B D where\n  toPrelaxFunctor := F.toPrelaxFunctor.comp G.toPrelaxFunctor\n  mapId := fun a => G.map‚ÇÇIso (F.mapId a) ‚â™‚â´ G.mapId (F.obj a)\n  mapComp := fun f g => (G.map‚ÇÇIso (F.mapComp f g)) ‚â™‚â´ G.mapComp (F.map f) (F.map g)\n  -- Note: whilst these are all provable by `aesop_cat`, the proof is very slow\n  map‚ÇÇ_whisker_left f Œ∑ := by dsimp; simp\n  map‚ÇÇ_whisker_right Œ∑ h := by dsimp; simp\n  map‚ÇÇ_associator f g h := by dsimp; simp\n  map‚ÇÇ_left_unitor f := by dsimp; simp\n  map‚ÇÇ_right_unitor f := by dsimp; simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.comp_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Bicategory C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Bicategory D\nF : CategoryTheory.Pseudofunctor B C\nG : CategoryTheory.Pseudofunctor C D\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((F.comp G).mapComp f g) ((G.map‚ÇÇIso (F.mapComp f g)).trans (G.mapComp (F.map f) (F.map g)))","decl":"/-- Composition of pseudofunctors. -/\n@[simps]\ndef comp (F : Pseudofunctor B C) (G : Pseudofunctor C D) : Pseudofunctor B D where\n  toPrelaxFunctor := F.toPrelaxFunctor.comp G.toPrelaxFunctor\n  mapId := fun a => G.map‚ÇÇIso (F.mapId a) ‚â™‚â´ G.mapId (F.obj a)\n  mapComp := fun f g => (G.map‚ÇÇIso (F.mapComp f g)) ‚â™‚â´ G.mapComp (F.map f) (F.map g)\n  -- Note: whilst these are all provable by `aesop_cat`, the proof is very slow\n  map‚ÇÇ_whisker_left f Œ∑ := by dsimp; simp\n  map‚ÇÇ_whisker_right Œ∑ h := by dsimp; simp\n  map‚ÇÇ_associator f g h := by dsimp; simp\n  map‚ÇÇ_left_unitor f := by dsimp; simp\n  map‚ÇÇ_right_unitor f := by dsimp; simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_right_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (F.map g) (F.map h‚úù))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h‚úù).hom) h)) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).inv) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g).hom (F.map h‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h‚úù)).hom h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right_hom {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    (F.mapComp f (g ‚â´ h)).hom ‚â´ F.map f ‚óÅ (F.mapComp g h).hom = F.map‚ÇÇ (Œ±_ f g h).inv ‚â´\n    (F.mapComp (f ‚â´ g) h).hom ‚â´ (F.mapComp f g).hom ‚ñ∑ F.map h ‚â´\n    (Œ±_ (F.map f) (F.map g) (F.map h)).hom :=\n  F.toOplax.mapComp_assoc_right _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_right_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(F.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).hom.app X) ((F.mapComp g h).hom.app ((F.map f).obj X))) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).inv).app X) (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.map h).map ((F.mapComp f g).hom.app X)) ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom.app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right_hom {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    (F.mapComp f (g ‚â´ h)).hom ‚â´ F.map f ‚óÅ (F.mapComp g h).hom = F.map‚ÇÇ (Œ±_ f g h).inv ‚â´\n    (F.mapComp (f ‚â´ g) h).hom ‚â´ (F.mapComp f g).hom ‚ñ∑ F.map h ‚â´\n    (Œ±_ (F.map f) (F.map g) (F.map h)).hom :=\n  F.toOplax.mapComp_assoc_right _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_right_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).hom (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h).hom)) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).inv) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g).hom (F.map h)) (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom)))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right_hom {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    (F.mapComp f (g ‚â´ h)).hom ‚â´ F.map f ‚óÅ (F.mapComp g h).hom = F.map‚ÇÇ (Œ±_ f g h).inv ‚â´\n    (F.mapComp (f ‚â´ g) h).hom ‚â´ (F.mapComp f g).hom ‚ñ∑ F.map h ‚â´\n    (Œ±_ (F.map f) (F.map g) (F.map h)).hom :=\n  F.toOplax.mapComp_assoc_right _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_left_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g).hom (F.map h))) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h).hom) (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv)))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left_hom {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    (F.mapComp (f ‚â´ g) h).hom ‚â´ (F.mapComp f g).hom ‚ñ∑ F.map h =\n    F.map‚ÇÇ (Œ±_ f g h).hom ‚â´ (F.mapComp f (g ‚â´ h)).hom ‚â´ F.map f ‚óÅ (F.mapComp g h).hom\n    ‚â´ (Œ±_ (F.map f) (F.map g) (F.map h)).inv :=\n  F.toOplax.mapComp_assoc_left _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_left_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(F.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom.app X) ((F.map h).map ((F.mapComp f g).hom.app X))) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom).app X) (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.mapComp g h).hom.app ((F.map f).obj X)) ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv.app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left_hom {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    (F.mapComp (f ‚â´ g) h).hom ‚â´ (F.mapComp f g).hom ‚ñ∑ F.map h =\n    F.map‚ÇÇ (Œ±_ f g h).hom ‚â´ (F.mapComp f (g ‚â´ h)).hom ‚â´ F.map f ‚óÅ (F.mapComp g h).hom\n    ‚â´ (Œ±_ (F.map f) (F.map g) (F.map h)).inv :=\n  F.toOplax.mapComp_assoc_left _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_left_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (F.map f) (F.map g)) (F.map h‚úù)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g).hom (F.map h‚úù)) h)) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).hom) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h‚úù).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h‚úù)).inv h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left_hom {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    (F.mapComp (f ‚â´ g) h).hom ‚â´ (F.mapComp f g).hom ‚ñ∑ F.map h =\n    F.map‚ÇÇ (Œ±_ f g h).hom ‚â´ (F.mapComp f (g ‚â´ h)).hom ‚â´ F.map f ‚óÅ (F.mapComp g h).hom\n    ‚â´ (Œ±_ (F.map f) (F.map g) (F.map h)).inv :=\n  F.toOplax.mapComp_assoc_left _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_right_inv_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(F.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapComp g h).inv.app ((F.map f).obj X)) ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.map h).map ((F.mapComp f g).inv.app X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).inv.app X) ((F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom).app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right_inv {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.map f ‚óÅ (F.mapComp g h).inv ‚â´ (F.mapComp f (g ‚â´ h)).inv =\n    (Œ±_ (F.map f) (F.map g) (F.map h)).inv ‚â´ (F.mapComp f g).inv ‚ñ∑ F.map h ‚â´\n    (F.mapComp (f ‚â´ g) h).inv ‚â´ F.map‚ÇÇ (Œ±_ f g h).hom :=\n  F.toLax.mapComp_assoc_right _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_right_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h).inv) (F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g).inv (F.map h)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).inv (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).hom))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right_inv {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.map f ‚óÅ (F.mapComp g h).inv ‚â´ (F.mapComp f (g ‚â´ h)).inv =\n    (Œ±_ (F.map f) (F.map g) (F.map h)).inv ‚â´ (F.mapComp f g).inv ‚ñ∑ F.map h ‚â´\n    (F.mapComp (f ‚â´ g) h).inv ‚â´ F.map‚ÇÇ (Œ±_ f g h).hom :=\n  F.toLax.mapComp_assoc_right _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_right_inv_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (F.map (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h‚úù))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h‚úù).inv) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h‚úù)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g).inv (F.map h‚úù)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù).inv (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).hom) h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_right_inv {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    F.map f ‚óÅ (F.mapComp g h).inv ‚â´ (F.mapComp f (g ‚â´ h)).inv =\n    (Œ±_ (F.map f) (F.map g) (F.map h)).inv ‚â´ (F.mapComp f g).inv ‚ñ∑ F.map h ‚â´\n    (F.mapComp (f ‚â´ g) h).inv ‚â´ F.map‚ÇÇ (Œ±_ f g h).hom :=\n  F.toLax.mapComp_assoc_right _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_left_inv_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh‚úù : Quiver.Hom c d\nZ : Quiver.Hom (F.obj a) (F.obj d)\nh : Quiver.Hom (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h‚úù)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g).inv (F.map h‚úù)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h‚úù).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h‚úù)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h‚úù).inv) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h‚úù)).inv (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h‚úù).inv) h))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left_inv {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    (F.mapComp f g).inv ‚ñ∑ F.map h ‚â´ (F.mapComp (f ‚â´ g) h).inv =\n    (Œ±_ (F.map f) (F.map g) (F.map h)).hom ‚â´ F.map f ‚óÅ (F.mapComp g h).inv ‚â´\n    (F.mapComp f (g ‚â´ h)).inv ‚â´ F.map‚ÇÇ (Œ±_ f g h).inv :=\n  F.toLax.mapComp_assoc_left _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_left_inv_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\nX : ‚Üë(F.obj a)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map h).map ((F.mapComp f g).inv.app X)) ((F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.mapComp g h).inv.app ((F.map f).obj X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv.app X) ((F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).inv).app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left_inv {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    (F.mapComp f g).inv ‚ñ∑ F.map h ‚â´ (F.mapComp (f ‚â´ g) h).inv =\n    (Œ±_ (F.map f) (F.map g) (F.map h)).hom ‚â´ F.map f ‚óÅ (F.mapComp g h).inv ‚â´\n    (F.mapComp f (g ‚â´ h)).inv ‚â´ F.map‚ÇÇ (Œ±_ f g h).inv :=\n  F.toLax.mapComp_assoc_left _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_assoc_left_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b c d : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g).inv (F.map h)) (F.mapComp (CategoryTheory.CategoryStruct.comp f g) h).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (F.map h)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapComp g h).inv) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv (F.map‚ÇÇ (CategoryTheory.Bicategory.associator f g h).inv))))","decl":"@[reassoc, to_app]\nlemma mapComp_assoc_left_inv {c d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n    (F.mapComp f g).inv ‚ñ∑ F.map h ‚â´ (F.mapComp (f ‚â´ g) h).inv =\n    (Œ±_ (F.map f) (F.map g) (F.map h)).hom ‚â´ F.map f ‚óÅ (F.mapComp g h).inv ‚â´\n    (F.mapComp f (g ‚â´ h)).inv ‚â´ F.map‚ÇÇ (Œ±_ f g h).inv :=\n  F.toLax.mapComp_assoc_left _ _ _\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_left_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.CategoryStruct.id a)) (F.map f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.id a) f).hom h) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a).inv (F.map f)) h)))","decl":"@[reassoc, to_app]\nlemma mapComp_id_left_hom (f : a ‚ü∂ b) : (F.mapComp (ùüô a) f).hom =\n    F.map‚ÇÇ (Œª_ f).hom ‚â´ (Œª_ (F.map f)).inv ‚â´ (F.mapId a).inv ‚ñ∑ F.map f := by\n  simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_left_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((F.mapComp (CategoryTheory.CategoryStruct.id a) f).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.leftUnitor (F.map f)).inv.app X) ((F.map f).map ((F.mapId a).inv.app X))))","decl":"@[reassoc, to_app]\nlemma mapComp_id_left_hom (f : a ‚ü∂ b) : (F.mapComp (ùüô a) f).hom =\n    F.map‚ÇÇ (Œª_ f).hom ‚â´ (Œª_ (F.map f)).inv ‚â´ (F.mapId a).inv ‚ñ∑ F.map f := by\n  simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_left_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (F.mapComp (CategoryTheory.CategoryStruct.id a) f).hom (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).inv (CategoryTheory.Bicategory.whiskerRight (F.mapId a).inv (F.map f))))","decl":"@[reassoc, to_app]\nlemma mapComp_id_left_hom (f : a ‚ü∂ b) : (F.mapComp (ùüô a) f).hom =\n    F.map‚ÇÇ (Œª_ f).hom ‚â´ (Œª_ (F.map f)).inv ‚â´ (F.mapId a).inv ‚ñ∑ F.map f := by\n  simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_left","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (F.mapComp (CategoryTheory.CategoryStruct.id a) f) ((F.map‚ÇÇIso (CategoryTheory.Bicategory.leftUnitor f)).trans ((CategoryTheory.Bicategory.leftUnitor (F.map f)).symm.trans (CategoryTheory.Bicategory.whiskerRightIso (F.mapId a) (F.map f)).symm))","decl":"lemma mapComp_id_left (f : a ‚ü∂ b) : (F.mapComp (ùüô a) f) = F.map‚ÇÇIso (Œª_ f) ‚â™‚â´\n    (Œª_ (F.map f)).symm ‚â™‚â´ (whiskerRightIso (F.mapId a) (F.map f)).symm :=\n  Iso.ext <| F.mapComp_id_left_hom f\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_left_inv_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((F.mapComp (CategoryTheory.CategoryStruct.id a) f).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.map f).map ((F.mapId a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.leftUnitor (F.map f)).hom.app X) ((F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv).app X)))","decl":"@[reassoc, to_app]\nlemma mapComp_id_left_inv (f : a ‚ü∂ b) : (F.mapComp (ùüô a) f).inv =\n    (F.mapId a).hom ‚ñ∑ F.map f ‚â´ (Œª_ (F.map f)).hom ‚â´ F.map‚ÇÇ (Œª_ f).inv := by\n  simp [mapComp_id_left]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_left_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (F.mapComp (CategoryTheory.CategoryStruct.id a) f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a).hom (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).hom (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv)))","decl":"@[reassoc, to_app]\nlemma mapComp_id_left_inv (f : a ‚ü∂ b) : (F.mapComp (ùüô a) f).inv =\n    (F.mapId a).hom ‚ñ∑ F.map f ‚â´ (Œª_ (F.map f)).hom ‚â´ F.map‚ÇÇ (Œª_ f).inv := by\n  simp [mapComp_id_left]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_left_inv_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id a) f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.id a) f).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a).hom (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) h)))","decl":"@[reassoc, to_app]\nlemma mapComp_id_left_inv (f : a ‚ü∂ b) : (F.mapComp (ùüô a) f).inv =\n    (F.mapId a).hom ‚ñ∑ F.map f ‚â´ (Œª_ (F.map f)).hom ‚â´ F.map‚ÇÇ (Œª_ f).inv := by\n  simp [mapComp_id_left]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerRightIso_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (CategoryTheory.Bicategory.whiskerRightIso (F.mapId a) (F.map f)) ((F.mapComp (CategoryTheory.CategoryStruct.id a) f).symm.trans ((F.map‚ÇÇIso (CategoryTheory.Bicategory.leftUnitor f)).trans (CategoryTheory.Bicategory.leftUnitor (F.map f)).symm))","decl":"lemma whiskerRightIso_mapId (f : a ‚ü∂ b) : whiskerRightIso (F.mapId a) (F.map f) =\n    (F.mapComp (ùüô a) f).symm ‚â™‚â´ F.map‚ÇÇIso (Œª_ f) ‚â™‚â´ (Œª_ (F.map f)).symm := by\n  simp [mapComp_id_left]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerRight_mapId_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id (F.obj a)) (F.map f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a).hom (F.map f)) h) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.id a) f).inv (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).inv h)))","decl":"@[reassoc, to_app]\nlemma whiskerRight_mapId_hom (f : a ‚ü∂ b) : (F.mapId a).hom ‚ñ∑ F.map f =\n    (F.mapComp (ùüô a) f).inv ‚â´ F.map‚ÇÇ (Œª_ f).hom ‚â´ (Œª_ (F.map f)).inv := by\n  simp [whiskerRightIso_mapId]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerRight_mapId_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (CategoryTheory.Bicategory.whiskerRight (F.mapId a).hom (F.map f)) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.id a) f).inv (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom) (CategoryTheory.Bicategory.leftUnitor (F.map f)).inv))","decl":"@[reassoc, to_app]\nlemma whiskerRight_mapId_hom (f : a ‚ü∂ b) : (F.mapId a).hom ‚ñ∑ F.map f =\n    (F.mapComp (ùüô a) f).inv ‚â´ F.map‚ÇÇ (Œª_ f).hom ‚â´ (Œª_ (F.map f)).inv := by\n  simp [whiskerRightIso_mapId]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerRight_mapId_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((F.map f).map ((F.mapId a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp (CategoryTheory.CategoryStruct.id a) f).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).hom).app X) ((CategoryTheory.Bicategory.leftUnitor (F.map f)).inv.app X)))","decl":"@[reassoc, to_app]\nlemma whiskerRight_mapId_hom (f : a ‚ü∂ b) : (F.mapId a).hom ‚ñ∑ F.map f =\n    (F.mapComp (ùüô a) f).inv ‚â´ F.map‚ÇÇ (Œª_ f).hom ‚â´ (Œª_ (F.map f)).inv := by\n  simp [whiskerRightIso_mapId]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerRight_mapId_inv_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.CategoryStruct.id a)) (F.map f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a).inv (F.map f)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) (CategoryTheory.CategoryStruct.comp (F.mapComp (CategoryTheory.CategoryStruct.id a) f).hom h)))","decl":"@[reassoc, to_app]\nlemma whiskerRight_mapId_inv (f : a ‚ü∂ b) : (F.mapId a).inv ‚ñ∑ F.map f =\n    (Œª_ (F.map f)).hom ‚â´ F.map‚ÇÇ (Œª_ f).inv ‚â´ (F.mapComp (ùüô a) f).hom := by\n  simpa using congrArg (¬∑.inv) (F.whiskerRightIso_mapId f)\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerRight_mapId_inv_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((F.map f).map ((F.mapId a).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.leftUnitor (F.map f)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv).app X) ((F.mapComp (CategoryTheory.CategoryStruct.id a) f).hom.app X)))","decl":"@[reassoc, to_app]\nlemma whiskerRight_mapId_inv (f : a ‚ü∂ b) : (F.mapId a).inv ‚ñ∑ F.map f =\n    (Œª_ (F.map f)).hom ‚â´ F.map‚ÇÇ (Œª_ f).inv ‚â´ (F.mapComp (ùüô a) f).hom := by\n  simpa using congrArg (¬∑.inv) (F.whiskerRightIso_mapId f)\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerRight_mapId_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (CategoryTheory.Bicategory.whiskerRight (F.mapId a).inv (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.leftUnitor f).inv) (F.mapComp (CategoryTheory.CategoryStruct.id a) f).hom))","decl":"@[reassoc, to_app]\nlemma whiskerRight_mapId_inv (f : a ‚ü∂ b) : (F.mapId a).inv ‚ñ∑ F.map f =\n    (Œª_ (F.map f)).hom ‚â´ F.map‚ÇÇ (Œª_ f).inv ‚â´ (F.mapComp (ùüô a) f).hom := by\n  simpa using congrArg (¬∑.inv) (F.whiskerRightIso_mapId f)\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_right_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (F.map (CategoryTheory.CategoryStruct.id b))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.id b)).hom h) (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b).inv) h)))","decl":"@[reassoc, to_app]\nlemma mapComp_id_right_hom (f : a ‚ü∂ b) : (F.mapComp f (ùüô b)).hom =\n    F.map‚ÇÇ (œÅ_ f).hom ‚â´ (œÅ_ (F.map f)).inv ‚â´ F.map f ‚óÅ (F.mapId b).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_right_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (F.mapComp f (CategoryTheory.CategoryStruct.id b)).hom (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).inv (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b).inv)))","decl":"@[reassoc, to_app]\nlemma mapComp_id_right_hom (f : a ‚ü∂ b) : (F.mapComp f (ùüô b)).hom =\n    F.map‚ÇÇ (œÅ_ f).hom ‚â´ (œÅ_ (F.map f)).inv ‚â´ F.map f ‚óÅ (F.mapId b).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_right_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((F.mapComp f (CategoryTheory.CategoryStruct.id b)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom).app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.rightUnitor (F.map f)).inv.app X) ((F.mapId b).inv.app ((F.map f).obj X))))","decl":"@[reassoc, to_app]\nlemma mapComp_id_right_hom (f : a ‚ü∂ b) : (F.mapComp f (ùüô b)).hom =\n    F.map‚ÇÇ (œÅ_ f).hom ‚â´ (œÅ_ (F.map f)).inv ‚â´ F.map f ‚óÅ (F.mapId b).inv := by\n  simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_right","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (F.mapComp f (CategoryTheory.CategoryStruct.id b)) ((F.map‚ÇÇIso (CategoryTheory.Bicategory.rightUnitor f)).trans ((CategoryTheory.Bicategory.rightUnitor (F.map f)).symm.trans (CategoryTheory.Bicategory.whiskerLeftIso (F.map f) (F.mapId b)).symm))","decl":"lemma mapComp_id_right (f : a ‚ü∂ b) : (F.mapComp f (ùüô b)) = F.map‚ÇÇIso (œÅ_ f) ‚â™‚â´\n    (œÅ_ (F.map f)).symm ‚â™‚â´ (whiskerLeftIso (F.map f) (F.mapId b)).symm :=\n  Iso.ext <| F.mapComp_id_right_hom f\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_right_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (F.mapComp f (CategoryTheory.CategoryStruct.id b)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv)))","decl":"@[reassoc, to_app]\nlemma mapComp_id_right_inv (f : a ‚ü∂ b) : (F.mapComp f (ùüô b)).inv =\n    F.map f ‚óÅ (F.mapId b).hom ‚â´ (œÅ_ (F.map f)).hom ‚â´ F.map‚ÇÇ (œÅ_ f).inv := by\n  simp [mapComp_id_right]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_right_inv_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((F.mapComp f (CategoryTheory.CategoryStruct.id b)).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.mapId b).hom.app ((F.map f).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.rightUnitor (F.map f)).hom.app X) ((F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv).app X)))","decl":"@[reassoc, to_app]\nlemma mapComp_id_right_inv (f : a ‚ü∂ b) : (F.mapComp f (ùüô b)).inv =\n    F.map f ‚óÅ (F.mapId b).hom ‚â´ (œÅ_ (F.map f)).hom ‚â´ F.map‚ÇÇ (œÅ_ f).inv := by\n  simp [mapComp_id_right]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mapComp_id_right_inv_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (F.map (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id b))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.id b)).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) h)))","decl":"@[reassoc, to_app]\nlemma mapComp_id_right_inv (f : a ‚ü∂ b) : (F.mapComp f (ùüô b)).inv =\n    F.map f ‚óÅ (F.mapId b).hom ‚â´ (œÅ_ (F.map f)).hom ‚â´ F.map‚ÇÇ (œÅ_ f).inv := by\n  simp [mapComp_id_right]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerLeftIso_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (CategoryTheory.Bicategory.whiskerLeftIso (F.map f) (F.mapId b)) ((F.mapComp f (CategoryTheory.CategoryStruct.id b)).symm.trans ((F.map‚ÇÇIso (CategoryTheory.Bicategory.rightUnitor f)).trans (CategoryTheory.Bicategory.rightUnitor (F.map f)).symm))","decl":"lemma whiskerLeftIso_mapId (f : a ‚ü∂ b) : whiskerLeftIso (F.map f) (F.mapId b) =\n    (F.mapComp f (ùüô b)).symm ‚â™‚â´ F.map‚ÇÇIso (œÅ_ f) ‚â™‚â´ (œÅ_ (F.map f)).symm := by\n  simp [mapComp_id_right]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerLeft_mapId_hom_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.id (F.obj b))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b).hom) h) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.id b)).inv (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).inv h)))","decl":"@[reassoc, to_app]\nlemma whiskerLeft_mapId_hom (f : a ‚ü∂ b) : F.map f ‚óÅ (F.mapId b).hom =\n    (F.mapComp f (ùüô b)).inv ‚â´ F.map‚ÇÇ (œÅ_ f).hom ‚â´ (œÅ_ (F.map f)).inv := by\n  simp [whiskerLeftIso_mapId]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerLeft_mapId_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b).hom) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.id b)).inv (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom) (CategoryTheory.Bicategory.rightUnitor (F.map f)).inv))","decl":"@[reassoc, to_app]\nlemma whiskerLeft_mapId_hom (f : a ‚ü∂ b) : F.map f ‚óÅ (F.mapId b).hom =\n    (F.mapComp f (ùüô b)).inv ‚â´ F.map‚ÇÇ (œÅ_ f).hom ‚â´ (œÅ_ (F.map f)).inv := by\n  simp [whiskerLeftIso_mapId]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerLeft_mapId_hom_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((F.mapId b).hom.app ((F.map f).obj X)) (CategoryTheory.CategoryStruct.comp ((F.mapComp f (CategoryTheory.CategoryStruct.id b)).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).hom).app X) ((CategoryTheory.Bicategory.rightUnitor (F.map f)).inv.app X)))","decl":"@[reassoc, to_app]\nlemma whiskerLeft_mapId_hom (f : a ‚ü∂ b) : F.map f ‚óÅ (F.mapId b).hom =\n    (F.mapComp f (ùüô b)).inv ‚â´ F.map‚ÇÇ (œÅ_ f).hom ‚â´ (œÅ_ (F.map f)).inv := by\n  simp [whiskerLeftIso_mapId]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerLeft_mapId_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) (F.mapComp f (CategoryTheory.CategoryStruct.id b)).hom))","decl":"@[reassoc, to_app]\nlemma whiskerLeft_mapId_inv (f : a ‚ü∂ b) : F.map f ‚óÅ (F.mapId b).inv =\n    (œÅ_ (F.map f)).hom ‚â´ F.map‚ÇÇ (œÅ_ f).inv ‚â´ (F.mapComp f (ùüô b)).hom := by\n  simpa using congrArg (¬∑.inv) (F.whiskerLeftIso_mapId f)\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerLeft_mapId_inv_app","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u_1\ninst‚úù : CategoryTheory.Bicategory B\nF : CategoryTheory.Pseudofunctor B CategoryTheory.Cat\na b : B\nf : Quiver.Hom a b\nX : ‚Üë(F.obj a)\n‚ä¢ Eq ((F.mapId b).inv.app ((F.map f).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Bicategory.rightUnitor (F.map f)).hom.app X) (CategoryTheory.CategoryStruct.comp ((F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv).app X) ((F.mapComp f (CategoryTheory.CategoryStruct.id b)).hom.app X)))","decl":"@[reassoc, to_app]\nlemma whiskerLeft_mapId_inv (f : a ‚ü∂ b) : F.map f ‚óÅ (F.mapId b).inv =\n    (œÅ_ (F.map f)).hom ‚â´ F.map‚ÇÇ (œÅ_ f).inv ‚â´ (F.mapComp f (ùüô b)).hom := by\n  simpa using congrArg (¬∑.inv) (F.whiskerLeftIso_mapId f)\n\n"}
{"name":"CategoryTheory.Pseudofunctor.whiskerLeft_mapId_inv_assoc","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\na b : B\nf : Quiver.Hom a b\nZ : Quiver.Hom (F.obj a) (F.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (F.map f) (F.map (CategoryTheory.CategoryStruct.id b))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (F.mapId b).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom (CategoryTheory.CategoryStruct.comp (F.map‚ÇÇ (CategoryTheory.Bicategory.rightUnitor f).inv) (CategoryTheory.CategoryStruct.comp (F.mapComp f (CategoryTheory.CategoryStruct.id b)).hom h)))","decl":"@[reassoc, to_app]\nlemma whiskerLeft_mapId_inv (f : a ‚ü∂ b) : F.map f ‚óÅ (F.mapId b).inv =\n    (œÅ_ (F.map f)).hom ‚â´ F.map‚ÇÇ (œÅ_ f).inv ‚â´ (F.mapComp f (ùüô b)).hom := by\n  simpa using congrArg (¬∑.inv) (F.whiskerLeftIso_mapId f)\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfOplax_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\nF' : F.PseudoCore\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfOplax F F').mapComp f g) (F'.mapCompIso f g)","decl":"/-- Construct a pseudofunctor from an oplax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps]\ndef mkOfOplax (F : OplaxFunctor B C) (F' : F.PseudoCore) : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := F'.mapIdIso\n  mapComp := F'.mapCompIso\n  map‚ÇÇ_whisker_left := fun f g h Œ∑ => by\n    dsimp\n    rw [F'.mapCompIso_hom f g, ‚Üê F.mapComp_naturality_right_assoc, ‚Üê F'.mapCompIso_hom f h,\n      hom_inv_id, comp_id]\n  map‚ÇÇ_whisker_right := fun Œ∑ h => by\n    dsimp\n    rw [F'.mapCompIso_hom _ h, ‚Üê F.mapComp_naturality_left_assoc, ‚Üê F'.mapCompIso_hom _ h,\n      hom_inv_id, comp_id]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    rw [F'.mapCompIso_hom (f ‚â´ g) h, F'.mapCompIso_hom f g, ‚Üê F.map‚ÇÇ_associator_assoc, ‚Üê\n      F'.mapCompIso_hom f (g ‚â´ h), ‚Üê F'.mapCompIso_hom g h, whiskerLeft_hom_inv_assoc,\n      hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfOplax_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\nF' : F.PseudoCore\na : B\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfOplax F F').mapId a) (F'.mapIdIso a)","decl":"/-- Construct a pseudofunctor from an oplax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps]\ndef mkOfOplax (F : OplaxFunctor B C) (F' : F.PseudoCore) : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := F'.mapIdIso\n  mapComp := F'.mapCompIso\n  map‚ÇÇ_whisker_left := fun f g h Œ∑ => by\n    dsimp\n    rw [F'.mapCompIso_hom f g, ‚Üê F.mapComp_naturality_right_assoc, ‚Üê F'.mapCompIso_hom f h,\n      hom_inv_id, comp_id]\n  map‚ÇÇ_whisker_right := fun Œ∑ h => by\n    dsimp\n    rw [F'.mapCompIso_hom _ h, ‚Üê F.mapComp_naturality_left_assoc, ‚Üê F'.mapCompIso_hom _ h,\n      hom_inv_id, comp_id]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    rw [F'.mapCompIso_hom (f ‚â´ g) h, F'.mapCompIso_hom f g, ‚Üê F.map‚ÇÇ_associator_assoc, ‚Üê\n      F'.mapCompIso_hom f (g ‚â´ h), ‚Üê F'.mapCompIso_hom g h, whiskerLeft_hom_inv_assoc,\n      hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfOplax_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\nF' : F.PseudoCore\n‚ä¢ Eq (CategoryTheory.Pseudofunctor.mkOfOplax F F').toPrelaxFunctor F.toPrelaxFunctor","decl":"/-- Construct a pseudofunctor from an oplax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps]\ndef mkOfOplax (F : OplaxFunctor B C) (F' : F.PseudoCore) : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := F'.mapIdIso\n  mapComp := F'.mapCompIso\n  map‚ÇÇ_whisker_left := fun f g h Œ∑ => by\n    dsimp\n    rw [F'.mapCompIso_hom f g, ‚Üê F.mapComp_naturality_right_assoc, ‚Üê F'.mapCompIso_hom f h,\n      hom_inv_id, comp_id]\n  map‚ÇÇ_whisker_right := fun Œ∑ h => by\n    dsimp\n    rw [F'.mapCompIso_hom _ h, ‚Üê F.mapComp_naturality_left_assoc, ‚Üê F'.mapCompIso_hom _ h,\n      hom_inv_id, comp_id]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    rw [F'.mapCompIso_hom (f ‚â´ g) h, F'.mapCompIso_hom f g, ‚Üê F.map‚ÇÇ_associator_assoc, ‚Üê\n      F'.mapCompIso_hom f (g ‚â´ h), ‚Üê F'.mapCompIso_hom g h, whiskerLeft_hom_inv_assoc,\n      hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfOplax'_mapId_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\na : B\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfOplax' F).mapId a).inv (CategoryTheory.inv (F.mapId a))","decl":"/-- Construct a pseudofunctor from an oplax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfOplax' (F : OplaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => asIso (F.mapId a)\n  mapComp := fun f g => asIso (F.mapComp f g)\n  map‚ÇÇ_whisker_left := fun f g h Œ∑ => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_right]\n  map‚ÇÇ_whisker_right := fun Œ∑ h => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_left]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    simp only [‚Üê assoc]\n    rw [IsIso.eq_comp_inv, ‚Üê inv_whiskerLeft, IsIso.eq_comp_inv]\n    simp only [assoc, F.map‚ÇÇ_associator]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfOplax'_mapId_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\na : B\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfOplax' F).mapId a).hom (F.mapId a)","decl":"/-- Construct a pseudofunctor from an oplax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfOplax' (F : OplaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => asIso (F.mapId a)\n  mapComp := fun f g => asIso (F.mapComp f g)\n  map‚ÇÇ_whisker_left := fun f g h Œ∑ => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_right]\n  map‚ÇÇ_whisker_right := fun Œ∑ h => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_left]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    simp only [‚Üê assoc]\n    rw [IsIso.eq_comp_inv, ‚Üê inv_whiskerLeft, IsIso.eq_comp_inv]\n    simp only [assoc, F.map‚ÇÇ_associator]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfOplax'_mapComp_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfOplax' F).mapComp f g).inv (CategoryTheory.inv (F.mapComp f g))","decl":"/-- Construct a pseudofunctor from an oplax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfOplax' (F : OplaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => asIso (F.mapId a)\n  mapComp := fun f g => asIso (F.mapComp f g)\n  map‚ÇÇ_whisker_left := fun f g h Œ∑ => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_right]\n  map‚ÇÇ_whisker_right := fun Œ∑ h => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_left]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    simp only [‚Üê assoc]\n    rw [IsIso.eq_comp_inv, ‚Üê inv_whiskerLeft, IsIso.eq_comp_inv]\n    simp only [assoc, F.map‚ÇÇ_associator]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfOplax'_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\n‚ä¢ Eq (CategoryTheory.Pseudofunctor.mkOfOplax' F).toPrelaxFunctor F.toPrelaxFunctor","decl":"/-- Construct a pseudofunctor from an oplax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfOplax' (F : OplaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => asIso (F.mapId a)\n  mapComp := fun f g => asIso (F.mapComp f g)\n  map‚ÇÇ_whisker_left := fun f g h Œ∑ => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_right]\n  map‚ÇÇ_whisker_right := fun Œ∑ h => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_left]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    simp only [‚Üê assoc]\n    rw [IsIso.eq_comp_inv, ‚Üê inv_whiskerLeft, IsIso.eq_comp_inv]\n    simp only [assoc, F.map‚ÇÇ_associator]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfOplax'_mapComp_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfOplax' F).mapComp f g).hom (F.mapComp f g)","decl":"/-- Construct a pseudofunctor from an oplax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfOplax' (F : OplaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := fun a => asIso (F.mapId a)\n  mapComp := fun f g => asIso (F.mapComp f g)\n  map‚ÇÇ_whisker_left := fun f g h Œ∑ => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_right]\n  map‚ÇÇ_whisker_right := fun Œ∑ h => by\n    dsimp\n    rw [‚Üê assoc, IsIso.eq_comp_inv, F.mapComp_naturality_left]\n  map‚ÇÇ_associator := fun f g h => by\n    dsimp\n    simp only [‚Üê assoc]\n    rw [IsIso.eq_comp_inv, ‚Üê inv_whiskerLeft, IsIso.eq_comp_inv]\n    simp only [assoc, F.map‚ÇÇ_associator]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfLax_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nF' : F.PseudoCore\n‚ä¢ Eq (CategoryTheory.Pseudofunctor.mkOfLax F F').toPrelaxFunctor F.toPrelaxFunctor","decl":"/-- Construct a pseudofunctor from a lax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps]\ndef mkOfLax (F : LaxFunctor B C) (F' : F.PseudoCore) : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := F'.mapIdIso\n  mapComp := F'.mapCompIso\n  map‚ÇÇ_whisker_left f g h Œ∑ := by\n    rw [F'.mapCompIso_inv, ‚Üê LaxFunctor.mapComp_naturality_right, ‚Üê F'.mapCompIso_inv,\n      hom_inv_id_assoc]\n  map‚ÇÇ_whisker_right Œ∑ h := by\n    rw [F'.mapCompIso_inv, ‚Üê LaxFunctor.mapComp_naturality_left, ‚Üê F'.mapCompIso_inv,\n      hom_inv_id_assoc]\n  map‚ÇÇ_associator {a b c d} f g h := by\n    rw [F'.mapCompIso_inv, F'.mapCompIso_inv, ‚Üê inv_comp_eq, ‚Üê IsIso.inv_comp_eq]\n    simp\n  map‚ÇÇ_left_unitor {a b} f := by rw [‚Üê IsIso.inv_eq_inv, ‚Üê F.map‚ÇÇ_inv]; simp\n  map‚ÇÇ_right_unitor {a b} f := by rw [‚Üê IsIso.inv_eq_inv, ‚Üê F.map‚ÇÇ_inv]; simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfLax_mapId","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nF' : F.PseudoCore\na : B\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfLax F F').mapId a) (F'.mapIdIso a)","decl":"/-- Construct a pseudofunctor from a lax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps]\ndef mkOfLax (F : LaxFunctor B C) (F' : F.PseudoCore) : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := F'.mapIdIso\n  mapComp := F'.mapCompIso\n  map‚ÇÇ_whisker_left f g h Œ∑ := by\n    rw [F'.mapCompIso_inv, ‚Üê LaxFunctor.mapComp_naturality_right, ‚Üê F'.mapCompIso_inv,\n      hom_inv_id_assoc]\n  map‚ÇÇ_whisker_right Œ∑ h := by\n    rw [F'.mapCompIso_inv, ‚Üê LaxFunctor.mapComp_naturality_left, ‚Üê F'.mapCompIso_inv,\n      hom_inv_id_assoc]\n  map‚ÇÇ_associator {a b c d} f g h := by\n    rw [F'.mapCompIso_inv, F'.mapCompIso_inv, ‚Üê inv_comp_eq, ‚Üê IsIso.inv_comp_eq]\n    simp\n  map‚ÇÇ_left_unitor {a b} f := by rw [‚Üê IsIso.inv_eq_inv, ‚Üê F.map‚ÇÇ_inv]; simp\n  map‚ÇÇ_right_unitor {a b} f := by rw [‚Üê IsIso.inv_eq_inv, ‚Üê F.map‚ÇÇ_inv]; simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfLax_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\nF' : F.PseudoCore\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfLax F F').mapComp f g) (F'.mapCompIso f g)","decl":"/-- Construct a pseudofunctor from a lax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps]\ndef mkOfLax (F : LaxFunctor B C) (F' : F.PseudoCore) : Pseudofunctor B C where\n  toPrelaxFunctor := F.toPrelaxFunctor\n  mapId := F'.mapIdIso\n  mapComp := F'.mapCompIso\n  map‚ÇÇ_whisker_left f g h Œ∑ := by\n    rw [F'.mapCompIso_inv, ‚Üê LaxFunctor.mapComp_naturality_right, ‚Üê F'.mapCompIso_inv,\n      hom_inv_id_assoc]\n  map‚ÇÇ_whisker_right Œ∑ h := by\n    rw [F'.mapCompIso_inv, ‚Üê LaxFunctor.mapComp_naturality_left, ‚Üê F'.mapCompIso_inv,\n      hom_inv_id_assoc]\n  map‚ÇÇ_associator {a b c d} f g h := by\n    rw [F'.mapCompIso_inv, F'.mapCompIso_inv, ‚Üê inv_comp_eq, ‚Üê IsIso.inv_comp_eq]\n    simp\n  map‚ÇÇ_left_unitor {a b} f := by rw [‚Üê IsIso.inv_eq_inv, ‚Üê F.map‚ÇÇ_inv]; simp\n  map‚ÇÇ_right_unitor {a b} f := by rw [‚Üê IsIso.inv_eq_inv, ‚Üê F.map‚ÇÇ_inv]; simp\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfLax'_toPrelaxFunctor","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\n‚ä¢ Eq (CategoryTheory.Pseudofunctor.mkOfLax' F).toPrelaxFunctor F.toPrelaxFunctor","decl":"/-- Construct a pseudofunctor from a lax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfLax' (F : LaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C :=\n  mkOfLax F\n  { mapIdIso := fun a => (asIso (F.mapId a)).symm\n    mapCompIso := fun f g => (asIso (F.mapComp f g)).symm }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfLax'_mapId_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\na : B\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfLax' F).mapId a).hom (CategoryTheory.inv (F.mapId a))","decl":"/-- Construct a pseudofunctor from a lax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfLax' (F : LaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C :=\n  mkOfLax F\n  { mapIdIso := fun a => (asIso (F.mapId a)).symm\n    mapCompIso := fun f g => (asIso (F.mapComp f g)).symm }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfLax'_mapId_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\na : B\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfLax' F).mapId a).inv (F.mapId a)","decl":"/-- Construct a pseudofunctor from a lax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfLax' (F : LaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C :=\n  mkOfLax F\n  { mapIdIso := fun a => (asIso (F.mapId a)).symm\n    mapCompIso := fun f g => (asIso (F.mapComp f g)).symm }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfLax'_mapComp_inv","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfLax' F).mapComp f g).inv (F.mapComp f g)","decl":"/-- Construct a pseudofunctor from a lax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfLax' (F : LaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C :=\n  mkOfLax F\n  { mapIdIso := fun a => (asIso (F.mapId a)).symm\n    mapCompIso := fun f g => (asIso (F.mapComp f g)).symm }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.mkOfLax'_mapComp_hom","module":"Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Bicategory B\nC : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Bicategory C\nF : CategoryTheory.LaxFunctor B C\ninst‚úù¬π : ‚àÄ (a : B), CategoryTheory.IsIso (F.mapId a)\ninst‚úù : ‚àÄ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), CategoryTheory.IsIso (F.mapComp f g)\na‚úù b‚úù c‚úù : B\nf : Quiver.Hom a‚úù b‚úù\ng : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.Pseudofunctor.mkOfLax' F).mapComp f g).hom (CategoryTheory.inv (F.mapComp f g))","decl":"/-- Construct a pseudofunctor from a lax functor whose `mapId` and `mapComp` are isomorphisms. -/\n@[simps!]\nnoncomputable def mkOfLax' (F : LaxFunctor B C) [‚àÄ a, IsIso (F.mapId a)]\n    [‚àÄ {a b c} (f : a ‚ü∂ b) (g : b ‚ü∂ c), IsIso (F.mapComp f g)] : Pseudofunctor B C :=\n  mkOfLax F\n  { mapIdIso := fun a => (asIso (F.mapId a)).symm\n    mapCompIso := fun f g => (asIso (F.mapComp f g)).symm }\n\n"}
