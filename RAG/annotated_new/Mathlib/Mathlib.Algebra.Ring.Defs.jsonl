{"name":"Distrib.left_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u_1\nself : Distrib R\na b c : R\n⊢ Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))","decl":"/-- A typeclass stating that multiplication is left and right distributive\nover addition. -/\nclass Distrib (R : Type*) extends Mul R, Add R where\n  /-- Multiplication is left distributive over addition -/\n  protected left_distrib : ∀ a b c : R, a * (b + c) = a * b + a * c\n  /-- Multiplication is right distributive over addition -/\n  protected right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c\n\n"}
{"name":"Distrib.right_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u_1\nself : Distrib R\na b c : R\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"/-- A typeclass stating that multiplication is left and right distributive\nover addition. -/\nclass Distrib (R : Type*) extends Mul R, Add R where\n  /-- Multiplication is left distributive over addition -/\n  protected left_distrib : ∀ a b c : R, a * (b + c) = a * b + a * c\n  /-- Multiplication is right distributive over addition -/\n  protected right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c\n\n"}
{"name":"LeftDistribClass.left_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : Add R\nself : LeftDistribClass R\na b c : R\n⊢ Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))","decl":"/-- A typeclass stating that multiplication is left distributive over addition. -/\nclass LeftDistribClass (R : Type*) [Mul R] [Add R] : Prop where\n  /-- Multiplication is left distributive over addition -/\n  protected left_distrib : ∀ a b c : R, a * (b + c) = a * b + a * c\n\n"}
{"name":"RightDistribClass.right_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : Add R\nself : RightDistribClass R\na b c : R\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"/-- A typeclass stating that multiplication is right distributive over addition. -/\nclass RightDistribClass (R : Type*) [Mul R] [Add R] : Prop where\n  /-- Multiplication is right distributive over addition -/\n  protected right_distrib : ∀ a b c : R, (a + b) * c = a * c + b * c\n\n-- see Note [lower instance priority]\n"}
{"name":"Distrib.leftDistribClass","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u_1\ninst✝ : Distrib R\n⊢ LeftDistribClass R","decl":"instance (priority := 100) Distrib.leftDistribClass (R : Type*) [Distrib R] : LeftDistribClass R :=\n  ⟨Distrib.left_distrib⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"Distrib.rightDistribClass","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u_1\ninst✝ : Distrib R\n⊢ RightDistribClass R","decl":"instance (priority := 100) Distrib.rightDistribClass (R : Type*) [Distrib R] :\n    RightDistribClass R :=\n  ⟨Distrib.right_distrib⟩\n\n"}
{"name":"left_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type v\ninst✝² : Mul R\ninst✝¹ : Add R\ninst✝ : LeftDistribClass R\na b c : R\n⊢ Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))","decl":"theorem left_distrib [Mul R] [Add R] [LeftDistribClass R] (a b c : R) :\n    a * (b + c) = a * b + a * c :=\n  LeftDistribClass.left_distrib a b c\n\n"}
{"name":"mul_add","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type v\ninst✝² : Mul R\ninst✝¹ : Add R\ninst✝ : LeftDistribClass R\na b c : R\n⊢ Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))","decl":"alias mul_add := left_distrib\n\n"}
{"name":"right_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type v\ninst✝² : Mul R\ninst✝¹ : Add R\ninst✝ : RightDistribClass R\na b c : R\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"theorem right_distrib [Mul R] [Add R] [RightDistribClass R] (a b c : R) :\n    (a + b) * c = a * c + b * c :=\n  RightDistribClass.right_distrib a b c\n\n"}
{"name":"add_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type v\ninst✝² : Mul R\ninst✝¹ : Add R\ninst✝ : RightDistribClass R\na b c : R\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"alias add_mul := right_distrib\n\n"}
{"name":"distrib_three_right","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type v\ninst✝² : Mul R\ninst✝¹ : Add R\ninst✝ : RightDistribClass R\na b c d : R\n⊢ Eq (HMul.hMul (HAdd.hAdd (HAdd.hAdd a b) c) d) (HAdd.hAdd (HAdd.hAdd (HMul.hMul a d) (HMul.hMul b d)) (HMul.hMul c d))","decl":"theorem distrib_three_right [Mul R] [Add R] [RightDistribClass R] (a b c d : R) :\n    (a + b + c) * d = a * d + b * d + c * d := by simp [right_distrib]\n\n"}
{"name":"NonUnitalNonAssocSemiring.mul_zero","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocSemiring α\na : α\n⊢ Eq (HMul.hMul a 0) 0","decl":"/-- A not-necessarily-unital, not-necessarily-associative semiring. See `CommutatorRing` and the\n  documentation thereof in case you need a `NonUnitalNonAssocSemiring` instance on a Lie ring\n  or a Lie algebra. -/\nclass NonUnitalNonAssocSemiring (α : Type u) extends AddCommMonoid α, Distrib α, MulZeroClass α\n\n"}
{"name":"NonUnitalNonAssocSemiring.zero_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocSemiring α\na : α\n⊢ Eq (HMul.hMul 0 a) 0","decl":"/-- A not-necessarily-unital, not-necessarily-associative semiring. See `CommutatorRing` and the\n  documentation thereof in case you need a `NonUnitalNonAssocSemiring` instance on a Lie ring\n  or a Lie algebra. -/\nclass NonUnitalNonAssocSemiring (α : Type u) extends AddCommMonoid α, Distrib α, MulZeroClass α\n\n"}
{"name":"NonUnitalNonAssocSemiring.right_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocSemiring α\na b c : α\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"/-- A not-necessarily-unital, not-necessarily-associative semiring. See `CommutatorRing` and the\n  documentation thereof in case you need a `NonUnitalNonAssocSemiring` instance on a Lie ring\n  or a Lie algebra. -/\nclass NonUnitalNonAssocSemiring (α : Type u) extends AddCommMonoid α, Distrib α, MulZeroClass α\n\n"}
{"name":"NonUnitalNonAssocSemiring.left_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocSemiring α\na b c : α\n⊢ Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))","decl":"/-- A not-necessarily-unital, not-necessarily-associative semiring. See `CommutatorRing` and the\n  documentation thereof in case you need a `NonUnitalNonAssocSemiring` instance on a Lie ring\n  or a Lie algebra. -/\nclass NonUnitalNonAssocSemiring (α : Type u) extends AddCommMonoid α, Distrib α, MulZeroClass α\n\n"}
{"name":"NonUnitalSemiring.mul_assoc","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalSemiring α\na b c : α\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))","decl":"/-- An associative but not-necessarily unital semiring. -/\nclass NonUnitalSemiring (α : Type u) extends NonUnitalNonAssocSemiring α, SemigroupWithZero α\n\n"}
{"name":"NonAssocSemiring.one_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonAssocSemiring α\na : α\n⊢ Eq (HMul.hMul 1 a) a","decl":"/-- A unital but not-necessarily-associative semiring. -/\nclass NonAssocSemiring (α : Type u) extends NonUnitalNonAssocSemiring α, MulZeroOneClass α,\n    AddCommMonoidWithOne α\n\n"}
{"name":"NonAssocSemiring.natCast_succ","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonAssocSemiring α\nn : Nat\n⊢ Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)","decl":"/-- A unital but not-necessarily-associative semiring. -/\nclass NonAssocSemiring (α : Type u) extends NonUnitalNonAssocSemiring α, MulZeroOneClass α,\n    AddCommMonoidWithOne α\n\n"}
{"name":"NonAssocSemiring.natCast_zero","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonAssocSemiring α\n⊢ Eq (NatCast.natCast 0) 0","decl":"/-- A unital but not-necessarily-associative semiring. -/\nclass NonAssocSemiring (α : Type u) extends NonUnitalNonAssocSemiring α, MulZeroOneClass α,\n    AddCommMonoidWithOne α\n\n"}
{"name":"NonAssocSemiring.mul_one","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonAssocSemiring α\na : α\n⊢ Eq (HMul.hMul a 1) a","decl":"/-- A unital but not-necessarily-associative semiring. -/\nclass NonAssocSemiring (α : Type u) extends NonUnitalNonAssocSemiring α, MulZeroOneClass α,\n    AddCommMonoidWithOne α\n\n"}
{"name":"NonUnitalNonAssocRing.mul_zero","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocRing α\na : α\n⊢ Eq (HMul.hMul a 0) 0","decl":"/-- A not-necessarily-unital, not-necessarily-associative ring. -/\nclass NonUnitalNonAssocRing (α : Type u) extends AddCommGroup α, NonUnitalNonAssocSemiring α\n\n"}
{"name":"NonUnitalNonAssocRing.right_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocRing α\na b c : α\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"/-- A not-necessarily-unital, not-necessarily-associative ring. -/\nclass NonUnitalNonAssocRing (α : Type u) extends AddCommGroup α, NonUnitalNonAssocSemiring α\n\n"}
{"name":"NonUnitalNonAssocRing.zero_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocRing α\na : α\n⊢ Eq (HMul.hMul 0 a) 0","decl":"/-- A not-necessarily-unital, not-necessarily-associative ring. -/\nclass NonUnitalNonAssocRing (α : Type u) extends AddCommGroup α, NonUnitalNonAssocSemiring α\n\n"}
{"name":"NonUnitalNonAssocRing.left_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocRing α\na b c : α\n⊢ Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))","decl":"/-- A not-necessarily-unital, not-necessarily-associative ring. -/\nclass NonUnitalNonAssocRing (α : Type u) extends AddCommGroup α, NonUnitalNonAssocSemiring α\n\n"}
{"name":"NonUnitalRing.mul_assoc","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\nself : NonUnitalRing α\na b c : α\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))","decl":"/-- An associative but not-necessarily unital ring. -/\nclass NonUnitalRing (α : Type*) extends NonUnitalNonAssocRing α, NonUnitalSemiring α\n\n"}
{"name":"NonAssocRing.natCast_zero","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\nself : NonAssocRing α\n⊢ Eq (NatCast.natCast 0) 0","decl":"/-- A unital but not-necessarily-associative ring. -/\nclass NonAssocRing (α : Type*) extends NonUnitalNonAssocRing α, NonAssocSemiring α,\n    AddCommGroupWithOne α\n\n"}
{"name":"NonAssocRing.natCast_succ","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\nself : NonAssocRing α\nn : Nat\n⊢ Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)","decl":"/-- A unital but not-necessarily-associative ring. -/\nclass NonAssocRing (α : Type*) extends NonUnitalNonAssocRing α, NonAssocSemiring α,\n    AddCommGroupWithOne α\n\n"}
{"name":"NonAssocRing.mul_one","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\nself : NonAssocRing α\na : α\n⊢ Eq (HMul.hMul a 1) a","decl":"/-- A unital but not-necessarily-associative ring. -/\nclass NonAssocRing (α : Type*) extends NonUnitalNonAssocRing α, NonAssocSemiring α,\n    AddCommGroupWithOne α\n\n"}
{"name":"NonAssocRing.one_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\nself : NonAssocRing α\na : α\n⊢ Eq (HMul.hMul 1 a) a","decl":"/-- A unital but not-necessarily-associative ring. -/\nclass NonAssocRing (α : Type*) extends NonUnitalNonAssocRing α, NonAssocSemiring α,\n    AddCommGroupWithOne α\n\n"}
{"name":"NonAssocRing.intCast_ofNat","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\nself : NonAssocRing α\nn : Nat\n⊢ Eq (IntCast.intCast ↑n) ↑n","decl":"/-- A unital but not-necessarily-associative ring. -/\nclass NonAssocRing (α : Type*) extends NonUnitalNonAssocRing α, NonAssocSemiring α,\n    AddCommGroupWithOne α\n\n"}
{"name":"NonAssocRing.intCast_negSucc","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\nself : NonAssocRing α\nn : Nat\n⊢ Eq (IntCast.intCast (Int.negSucc n)) (Neg.neg ↑(HAdd.hAdd n 1))","decl":"/-- A unital but not-necessarily-associative ring. -/\nclass NonAssocRing (α : Type*) extends NonUnitalNonAssocRing α, NonAssocSemiring α,\n    AddCommGroupWithOne α\n\n"}
{"name":"Semiring.one_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : Semiring α\na : α\n⊢ Eq (HMul.hMul 1 a) a","decl":"/-- A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is\ncommutative and associative, multiplication is associative and left and right distributive over\naddition, and `0` and `1` are additive and multiplicative identities. -/\nclass Semiring (α : Type u) extends NonUnitalSemiring α, NonAssocSemiring α, MonoidWithZero α\n\n"}
{"name":"Semiring.npow_zero","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : Semiring α\nx : α\n⊢ Eq (Semiring.npow 0 x) 1","decl":"/-- A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is\ncommutative and associative, multiplication is associative and left and right distributive over\naddition, and `0` and `1` are additive and multiplicative identities. -/\nclass Semiring (α : Type u) extends NonUnitalSemiring α, NonAssocSemiring α, MonoidWithZero α\n\n"}
{"name":"Semiring.npow_succ","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : Semiring α\nn : Nat\nx : α\n⊢ Eq (Semiring.npow (HAdd.hAdd n 1) x) (HMul.hMul (Semiring.npow n x) x)","decl":"/-- A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is\ncommutative and associative, multiplication is associative and left and right distributive over\naddition, and `0` and `1` are additive and multiplicative identities. -/\nclass Semiring (α : Type u) extends NonUnitalSemiring α, NonAssocSemiring α, MonoidWithZero α\n\n"}
{"name":"Semiring.mul_one","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : Semiring α\na : α\n⊢ Eq (HMul.hMul a 1) a","decl":"/-- A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is\ncommutative and associative, multiplication is associative and left and right distributive over\naddition, and `0` and `1` are additive and multiplicative identities. -/\nclass Semiring (α : Type u) extends NonUnitalSemiring α, NonAssocSemiring α, MonoidWithZero α\n\n"}
{"name":"Semiring.natCast_succ","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : Semiring α\nn : Nat\n⊢ Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)","decl":"/-- A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is\ncommutative and associative, multiplication is associative and left and right distributive over\naddition, and `0` and `1` are additive and multiplicative identities. -/\nclass Semiring (α : Type u) extends NonUnitalSemiring α, NonAssocSemiring α, MonoidWithZero α\n\n"}
{"name":"Semiring.natCast_zero","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : Semiring α\n⊢ Eq (NatCast.natCast 0) 0","decl":"/-- A `Semiring` is a type with addition, multiplication, a `0` and a `1` where addition is\ncommutative and associative, multiplication is associative and left and right distributive over\naddition, and `0` and `1` are additive and multiplicative identities. -/\nclass Semiring (α : Type u) extends NonUnitalSemiring α, NonAssocSemiring α, MonoidWithZero α\n\n"}
{"name":"Ring.sub_eq_add_neg","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u\nself : Ring R\na b : R\n⊢ Eq (HSub.hSub a b) (HAdd.hAdd a (Neg.neg b))","decl":"/-- A `Ring` is a `Semiring` with negation making it an additive group. -/\nclass Ring (R : Type u) extends Semiring R, AddCommGroup R, AddGroupWithOne R\n\n"}
{"name":"Ring.zsmul_succ'","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u\nself : Ring R\nn : Nat\na : R\n⊢ Eq (Ring.zsmul (↑n.succ) a) (HAdd.hAdd (Ring.zsmul (↑n) a) a)","decl":"/-- A `Ring` is a `Semiring` with negation making it an additive group. -/\nclass Ring (R : Type u) extends Semiring R, AddCommGroup R, AddGroupWithOne R\n\n"}
{"name":"Ring.neg_add_cancel","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u\nself : Ring R\na : R\n⊢ Eq (HAdd.hAdd (Neg.neg a) a) 0","decl":"/-- A `Ring` is a `Semiring` with negation making it an additive group. -/\nclass Ring (R : Type u) extends Semiring R, AddCommGroup R, AddGroupWithOne R\n\n"}
{"name":"Ring.zsmul_zero'","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u\nself : Ring R\na : R\n⊢ Eq (Ring.zsmul 0 a) 0","decl":"/-- A `Ring` is a `Semiring` with negation making it an additive group. -/\nclass Ring (R : Type u) extends Semiring R, AddCommGroup R, AddGroupWithOne R\n\n"}
{"name":"Ring.zsmul_neg'","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u\nself : Ring R\nn : Nat\na : R\n⊢ Eq (Ring.zsmul (Int.negSucc n) a) (Neg.neg (Ring.zsmul (↑n.succ) a))","decl":"/-- A `Ring` is a `Semiring` with negation making it an additive group. -/\nclass Ring (R : Type u) extends Semiring R, AddCommGroup R, AddGroupWithOne R\n\n"}
{"name":"Ring.intCast_ofNat","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u\nself : Ring R\nn : Nat\n⊢ Eq (IntCast.intCast ↑n) ↑n","decl":"/-- A `Ring` is a `Semiring` with negation making it an additive group. -/\nclass Ring (R : Type u) extends Semiring R, AddCommGroup R, AddGroupWithOne R\n\n"}
{"name":"Ring.intCast_negSucc","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u\nself : Ring R\nn : Nat\n⊢ Eq (IntCast.intCast (Int.negSucc n)) (Neg.neg ↑(HAdd.hAdd n 1))","decl":"/-- A `Ring` is a `Semiring` with negation making it an additive group. -/\nclass Ring (R : Type u) extends Semiring R, AddCommGroup R, AddGroupWithOne R\n\n"}
{"name":"add_one_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : MulOneClass α\ninst✝ : RightDistribClass α\na b : α\n⊢ Eq (HMul.hMul (HAdd.hAdd a 1) b) (HAdd.hAdd (HMul.hMul a b) b)","decl":"theorem add_one_mul [RightDistribClass α] (a b : α) : (a + 1) * b = a * b + b := by\n  rw [add_mul, one_mul]\n\n"}
{"name":"mul_add_one","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : MulOneClass α\ninst✝ : LeftDistribClass α\na b : α\n⊢ Eq (HMul.hMul a (HAdd.hAdd b 1)) (HAdd.hAdd (HMul.hMul a b) a)","decl":"theorem mul_add_one [LeftDistribClass α] (a b : α) : a * (b + 1) = a * b + a := by\n  rw [mul_add, mul_one]\n\n"}
{"name":"one_add_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : MulOneClass α\ninst✝ : RightDistribClass α\na b : α\n⊢ Eq (HMul.hMul (HAdd.hAdd 1 a) b) (HAdd.hAdd b (HMul.hMul a b))","decl":"theorem one_add_mul [RightDistribClass α] (a b : α) : (1 + a) * b = b + a * b := by\n  rw [add_mul, one_mul]\n\n"}
{"name":"mul_one_add","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : MulOneClass α\ninst✝ : LeftDistribClass α\na b : α\n⊢ Eq (HMul.hMul a (HAdd.hAdd 1 b)) (HAdd.hAdd a (HMul.hMul a b))","decl":"theorem mul_one_add [LeftDistribClass α] (a b : α) : a * (1 + b) = a + a * b := by\n  rw [mul_add, mul_one]\n\n"}
{"name":"two_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonAssocSemiring α\nn : α\n⊢ Eq (HMul.hMul 2 n) (HAdd.hAdd n n)","decl":"theorem two_mul (n : α) : 2 * n = n + n :=\n  (congrArg₂ _ one_add_one_eq_two.symm rfl).trans <| (right_distrib 1 1 n).trans (by rw [one_mul])\n\n-- Porting note: was [has_add α] [mul_one_class α] [left_distrib_class α]\n"}
{"name":"mul_two","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonAssocSemiring α\nn : α\n⊢ Eq (HMul.hMul n 2) (HAdd.hAdd n n)","decl":"theorem mul_two (n : α) : n * 2 = n + n :=\n  (congrArg₂ _ rfl one_add_one_eq_two.symm).trans <| (left_distrib n 1 1).trans (by rw [mul_one])\n\n"}
{"name":"ite_zero_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : MulZeroClass α\nP : Prop\ninst✝ : Decidable P\na b : α\n⊢ Eq (HMul.hMul (ite P a 0) b) (ite P (HMul.hMul a b) 0)","decl":"lemma ite_zero_mul : ite P a 0 * b = ite P (a * b) 0 := by simp\n\n"}
{"name":"mul_ite_zero","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : MulZeroClass α\nP : Prop\ninst✝ : Decidable P\na b : α\n⊢ Eq (HMul.hMul a (ite P b 0)) (ite P (HMul.hMul a b) 0)","decl":"lemma mul_ite_zero : a * ite P b 0 = ite P (a * b) 0 := by simp\n\n"}
{"name":"ite_zero_mul_ite_zero","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝² : MulZeroClass α\nP Q : Prop\ninst✝¹ : Decidable P\ninst✝ : Decidable Q\na b : α\n⊢ Eq (HMul.hMul (ite P a 0) (ite Q b 0)) (ite (And P Q) (HMul.hMul a b) 0)","decl":"lemma ite_zero_mul_ite_zero : ite P a 0 * ite Q b 0 = ite (P ∧ Q) (a * b) 0 := by\n  simp only [← ite_and, ite_mul, mul_ite, mul_zero, zero_mul, and_comm]\n\n"}
{"name":"mul_boole","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MulZeroOneClass α\nP : Prop\ninst✝ : Decidable P\na : α\n⊢ Eq (HMul.hMul a (ite P 1 0)) (ite P a 0)","decl":"theorem mul_boole {α} [MulZeroOneClass α] (P : Prop) [Decidable P] (a : α) :\n    (a * if P then 1 else 0) = if P then a else 0 := by simp\n\n-- Porting note: no @[simp] because simp proves it\n"}
{"name":"boole_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MulZeroOneClass α\nP : Prop\ninst✝ : Decidable P\na : α\n⊢ Eq (HMul.hMul (ite P 1 0) a) (ite P a 0)","decl":"theorem boole_mul {α} [MulZeroOneClass α] (P : Prop) [Decidable P] (a : α) :\n    (if P then 1 else 0) * a = if P then a else 0 := by simp\n\n"}
{"name":"NonUnitalNonAssocCommSemiring.mul_comm","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocCommSemiring α\na b : α\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A not-necessarily-unital, not-necessarily-associative, but commutative semiring. -/\nclass NonUnitalNonAssocCommSemiring (α : Type u) extends NonUnitalNonAssocSemiring α, CommMagma α\n\n"}
{"name":"NonUnitalCommSemiring.mul_comm","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalCommSemiring α\na b : α\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A non-unital commutative semiring is a `NonUnitalSemiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`AddCommMonoid`), commutative semigroup (`CommSemigroup`), distributive laws (`Distrib`), and\nmultiplication by zero law (`MulZeroClass`). -/\nclass NonUnitalCommSemiring (α : Type u) extends NonUnitalSemiring α, CommSemigroup α\n\n"}
{"name":"CommSemiring.mul_comm","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"R : Type u\nself : CommSemiring R\na b : R\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A commutative semiring is a semiring with commutative multiplication. -/\nclass CommSemiring (R : Type u) extends Semiring R, CommMonoid R\n\n-- see Note [lower instance priority]\n"}
{"name":"add_mul_self_eq","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : CommSemiring α\na b : α\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) (HAdd.hAdd a b)) (HAdd.hAdd (HAdd.hAdd (HMul.hMul a a) (HMul.hMul (HMul.hMul 2 a) b)) (HMul.hMul b b))","decl":"theorem add_mul_self_eq (a b : α) : (a + b) * (a + b) = a * a + 2 * a * b + b * b := by\n  simp only [two_mul, add_mul, mul_add, add_assoc, mul_comm b]\n\n"}
{"name":"add_sq","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : CommSemiring α\na b : α\n⊢ Eq (HPow.hPow (HAdd.hAdd a b) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow a 2) (HMul.hMul (HMul.hMul 2 a) b)) (HPow.hPow b 2))","decl":"lemma add_sq (a b : α) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2 := by\n  simp only [sq, add_mul_self_eq]\n\n"}
{"name":"add_sq'","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : CommSemiring α\na b : α\n⊢ Eq (HPow.hPow (HAdd.hAdd a b) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) (HMul.hMul (HMul.hMul 2 a) b))","decl":"lemma add_sq' (a b : α) : (a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b := by\n  rw [add_sq, add_assoc, add_comm _ (b ^ 2), add_assoc]\n\n"}
{"name":"add_pow_two","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : CommSemiring α\na b : α\n⊢ Eq (HPow.hPow (HAdd.hAdd a b) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow a 2) (HMul.hMul (HMul.hMul 2 a) b)) (HPow.hPow b 2))","decl":"alias add_pow_two := add_sq\n\n"}
{"name":"HasDistribNeg.neg_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\ninst✝ : Mul α\nself : HasDistribNeg α\nx y : α\n⊢ Eq (HMul.hMul (Neg.neg x) y) (Neg.neg (HMul.hMul x y))","decl":"/-- Typeclass for a negation operator that distributes across multiplication.\n\nThis is useful for dealing with submonoids of a ring that contain `-1` without having to duplicate\nlemmas. -/\nclass HasDistribNeg (α : Type*) [Mul α] extends InvolutiveNeg α where\n  /-- Negation is left distributive over multiplication -/\n  neg_mul : ∀ x y : α, -x * y = -(x * y)\n  /-- Negation is right distributive over multiplication -/\n  mul_neg : ∀ x y : α, x * -y = -(x * y)\n\n"}
{"name":"HasDistribNeg.mul_neg","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u_1\ninst✝ : Mul α\nself : HasDistribNeg α\nx y : α\n⊢ Eq (HMul.hMul x (Neg.neg y)) (Neg.neg (HMul.hMul x y))","decl":"/-- Typeclass for a negation operator that distributes across multiplication.\n\nThis is useful for dealing with submonoids of a ring that contain `-1` without having to duplicate\nlemmas. -/\nclass HasDistribNeg (α : Type*) [Mul α] extends InvolutiveNeg α where\n  /-- Negation is left distributive over multiplication -/\n  neg_mul : ∀ x y : α, -x * y = -(x * y)\n  /-- Negation is right distributive over multiplication -/\n  mul_neg : ∀ x y : α, x * -y = -(x * y)\n\n"}
{"name":"neg_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : HasDistribNeg α\na b : α\n⊢ Eq (HMul.hMul (Neg.neg a) b) (Neg.neg (HMul.hMul a b))","decl":"@[simp]\ntheorem neg_mul (a b : α) : -a * b = -(a * b) :=\n  HasDistribNeg.neg_mul _ _\n\n"}
{"name":"mul_neg","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : HasDistribNeg α\na b : α\n⊢ Eq (HMul.hMul a (Neg.neg b)) (Neg.neg (HMul.hMul a b))","decl":"@[simp]\ntheorem mul_neg (a b : α) : a * -b = -(a * b) :=\n  HasDistribNeg.mul_neg _ _\n\n"}
{"name":"neg_mul_neg","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : HasDistribNeg α\na b : α\n⊢ Eq (HMul.hMul (Neg.neg a) (Neg.neg b)) (HMul.hMul a b)","decl":"theorem neg_mul_neg (a b : α) : -a * -b = a * b := by simp\n\n"}
{"name":"neg_mul_eq_neg_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : HasDistribNeg α\na b : α\n⊢ Eq (Neg.neg (HMul.hMul a b)) (HMul.hMul (Neg.neg a) b)","decl":"theorem neg_mul_eq_neg_mul (a b : α) : -(a * b) = -a * b :=\n  (neg_mul _ _).symm\n\n"}
{"name":"neg_mul_eq_mul_neg","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : HasDistribNeg α\na b : α\n⊢ Eq (Neg.neg (HMul.hMul a b)) (HMul.hMul a (Neg.neg b))","decl":"theorem neg_mul_eq_mul_neg (a b : α) : -(a * b) = a * -b :=\n  (mul_neg _ _).symm\n\n"}
{"name":"neg_mul_comm","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : HasDistribNeg α\na b : α\n⊢ Eq (HMul.hMul (Neg.neg a) b) (HMul.hMul a (Neg.neg b))","decl":"theorem neg_mul_comm (a b : α) : -a * b = a * -b := by simp\n\n"}
{"name":"neg_eq_neg_one_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : MulOneClass α\ninst✝ : HasDistribNeg α\na : α\n⊢ Eq (Neg.neg a) (HMul.hMul (-1) a)","decl":"theorem neg_eq_neg_one_mul (a : α) : -a = -1 * a := by simp\n\n"}
{"name":"mul_neg_one","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : MulOneClass α\ninst✝ : HasDistribNeg α\na : α\n⊢ Eq (HMul.hMul a (-1)) (Neg.neg a)","decl":"/-- An element of a ring multiplied by the additive inverse of one is the element's additive\n  inverse. -/\ntheorem mul_neg_one (a : α) : a * -1 = -a := by simp\n\n"}
{"name":"neg_one_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝¹ : MulOneClass α\ninst✝ : HasDistribNeg α\na : α\n⊢ Eq (HMul.hMul (-1) a) (Neg.neg a)","decl":"/-- The additive inverse of one multiplied by an element of a ring is the element's additive\n  inverse. -/\ntheorem neg_one_mul (a : α) : -1 * a = -a := by simp\n\n"}
{"name":"mul_sub_left_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonUnitalNonAssocRing α\na b c : α\n⊢ Eq (HMul.hMul a (HSub.hSub b c)) (HSub.hSub (HMul.hMul a b) (HMul.hMul a c))","decl":"theorem mul_sub_left_distrib (a b c : α) : a * (b - c) = a * b - a * c := by\n  simpa only [sub_eq_add_neg, neg_mul_eq_mul_neg] using mul_add a b (-c)\n\n"}
{"name":"mul_sub","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonUnitalNonAssocRing α\na b c : α\n⊢ Eq (HMul.hMul a (HSub.hSub b c)) (HSub.hSub (HMul.hMul a b) (HMul.hMul a c))","decl":"alias mul_sub := mul_sub_left_distrib\n\n"}
{"name":"mul_sub_right_distrib","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonUnitalNonAssocRing α\na b c : α\n⊢ Eq (HMul.hMul (HSub.hSub a b) c) (HSub.hSub (HMul.hMul a c) (HMul.hMul b c))","decl":"theorem mul_sub_right_distrib (a b c : α) : (a - b) * c = a * c - b * c := by\n  simpa only [sub_eq_add_neg, neg_mul_eq_neg_mul] using add_mul a (-b) c\n\n"}
{"name":"sub_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonUnitalNonAssocRing α\na b c : α\n⊢ Eq (HMul.hMul (HSub.hSub a b) c) (HSub.hSub (HMul.hMul a c) (HMul.hMul b c))","decl":"alias sub_mul := mul_sub_right_distrib\n\n"}
{"name":"sub_one_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonAssocRing α\na b : α\n⊢ Eq (HMul.hMul (HSub.hSub a 1) b) (HSub.hSub (HMul.hMul a b) b)","decl":"theorem sub_one_mul (a b : α) : (a - 1) * b = a * b - b := by rw [sub_mul, one_mul]\n\n"}
{"name":"mul_sub_one","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonAssocRing α\na b : α\n⊢ Eq (HMul.hMul a (HSub.hSub b 1)) (HSub.hSub (HMul.hMul a b) a)","decl":"theorem mul_sub_one (a b : α) : a * (b - 1) = a * b - a := by rw [mul_sub, mul_one]\n\n"}
{"name":"one_sub_mul","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonAssocRing α\na b : α\n⊢ Eq (HMul.hMul (HSub.hSub 1 a) b) (HSub.hSub b (HMul.hMul a b))","decl":"theorem one_sub_mul (a b : α) : (1 - a) * b = b - a * b := by rw [sub_mul, one_mul]\n\n"}
{"name":"mul_one_sub","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : NonAssocRing α\na b : α\n⊢ Eq (HMul.hMul a (HSub.hSub 1 b)) (HSub.hSub a (HMul.hMul a b))","decl":"theorem mul_one_sub (a b : α) : a * (1 - b) = a - a * b := by rw [mul_sub, mul_one]\n\n"}
{"name":"NonUnitalNonAssocCommRing.mul_comm","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalNonAssocCommRing α\na b : α\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A non-unital non-associative commutative ring is a `NonUnitalNonAssocRing` with commutative\nmultiplication. -/\nclass NonUnitalNonAssocCommRing (α : Type u)\n  extends NonUnitalNonAssocRing α, NonUnitalNonAssocCommSemiring α\n\n"}
{"name":"NonUnitalCommRing.mul_comm","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : NonUnitalCommRing α\na b : α\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A non-unital commutative ring is a `NonUnitalRing` with commutative multiplication. -/\nclass NonUnitalCommRing (α : Type u) extends NonUnitalRing α, NonUnitalNonAssocCommRing α\n\n-- see Note [lower instance priority]\n"}
{"name":"CommRing.mul_comm","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\nself : CommRing α\na b : α\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A commutative ring is a ring with commutative multiplication. -/\nclass CommRing (α : Type u) extends Ring α, CommMonoid α\n\n"}
{"name":"IsDomain.toNontrivial","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nself : IsDomain α\n⊢ Nontrivial α","decl":"/-- A domain is a nontrivial semiring such that multiplication by a non zero element\nis cancellative on both sides. In other words, a nontrivial semiring `R` satisfying\n`∀ {a b c : R}, a ≠ 0 → a * b = a * c → b = c` and\n`∀ {a b c : R}, b ≠ 0 → a * b = c * b → a = c`.\n\nThis is implemented as a mixin for `Semiring α`.\nTo obtain an integral domain use `[CommRing α] [IsDomain α]`. -/\n@[stacks 09FE]\nclass IsDomain (α : Type u) [Semiring α] extends IsCancelMulZero α, Nontrivial α : Prop\n"}
{"name":"IsDomain.toIsCancelMulZero","module":"Mathlib.Algebra.Ring.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nself : IsDomain α\n⊢ IsCancelMulZero α","decl":"/-- A domain is a nontrivial semiring such that multiplication by a non zero element\nis cancellative on both sides. In other words, a nontrivial semiring `R` satisfying\n`∀ {a b c : R}, a ≠ 0 → a * b = a * c → b = c` and\n`∀ {a b c : R}, b ≠ 0 → a * b = c * b → a = c`.\n\nThis is implemented as a mixin for `Semiring α`.\nTo obtain an integral domain use `[CommRing α] [IsDomain α]`. -/\n@[stacks 09FE]\nclass IsDomain (α : Type u) [Semiring α] extends IsCancelMulZero α, Nontrivial α : Prop\n"}
