{"name":"GenContFract.exists_gcf_pair_rat_eq_of_nth_contsAux","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Exists fun conts => Eq ((GenContFract.of v).contsAux n) (GenContFract.Pair.map Rat.cast conts)","decl":"nonrec theorem exists_gcf_pair_rat_eq_of_nth_contsAux :\n    ∃ conts : Pair ℚ, (of v).contsAux n = (conts.map (↑) : Pair K) :=\n  Nat.strong_induction_on n\n    (by\n      clear n\n      let g := of v\n      intro n IH\n      rcases n with (_ | _ | n)\n      -- n = 0\n      · suffices ∃ gp : Pair ℚ, Pair.mk (1 : K) 0 = gp.map (↑) by simpa [contsAux]\n        use Pair.mk 1 0\n        simp\n      -- n = 1\n      · suffices ∃ conts : Pair ℚ, Pair.mk g.h 1 = conts.map (↑) by simpa [contsAux]\n        use Pair.mk ⌊v⌋ 1\n        simp [g]\n      -- 2 ≤ n\n      · obtain ⟨pred_conts, pred_conts_eq⟩ := IH (n + 1) <| lt_add_one (n + 1)\n        -- invoke the IH\n        rcases s_ppred_nth_eq : g.s.get? n with gp_n | gp_n\n        -- option.none\n        · use pred_conts\n          have : g.contsAux (n + 2) = g.contsAux (n + 1) :=\n            contsAux_stable_of_terminated (n + 1).le_succ s_ppred_nth_eq\n          simp only [g, this, pred_conts_eq]\n        -- option.some\n        · -- invoke the IH a second time\n          obtain ⟨ppred_conts, ppred_conts_eq⟩ :=\n            IH n <| lt_of_le_of_lt n.le_succ <| lt_add_one <| n + 1\n          obtain ⟨a_eq_one, z, b_eq_z⟩ : gp_n.a = 1 ∧ ∃ z : ℤ, gp_n.b = (z : K) :=\n            of_partNum_eq_one_and_exists_int_partDen_eq s_ppred_nth_eq\n          -- finally, unfold the recurrence to obtain the required rational value.\n          simp only [g, a_eq_one, b_eq_z,\n            contsAux_recurrence s_ppred_nth_eq ppred_conts_eq pred_conts_eq]\n          use nextConts 1 (z : ℚ) ppred_conts pred_conts\n          cases ppred_conts; cases pred_conts\n          simp [nextConts, nextNum, nextDen])\n\n"}
{"name":"GenContFract.exists_gcf_pair_rat_eq_nth_conts","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Exists fun conts => Eq ((GenContFract.of v).conts n) (GenContFract.Pair.map Rat.cast conts)","decl":"theorem exists_gcf_pair_rat_eq_nth_conts :\n    ∃ conts : Pair ℚ, (of v).conts n = (conts.map (↑) : Pair K) := by\n  rw [nth_cont_eq_succ_nth_contAux]; exact exists_gcf_pair_rat_eq_of_nth_contsAux v <| n + 1\n\n"}
{"name":"GenContFract.exists_rat_eq_nth_num","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Exists fun q => Eq ((GenContFract.of v).nums n) ↑q","decl":"theorem exists_rat_eq_nth_num : ∃ q : ℚ, (of v).nums n = (q : K) := by\n  rcases exists_gcf_pair_rat_eq_nth_conts v n with ⟨⟨a, _⟩, nth_cont_eq⟩\n  use a\n  simp [num_eq_conts_a, nth_cont_eq]\n\n"}
{"name":"GenContFract.exists_rat_eq_nth_den","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Exists fun q => Eq ((GenContFract.of v).dens n) ↑q","decl":"theorem exists_rat_eq_nth_den : ∃ q : ℚ, (of v).dens n = (q : K) := by\n  rcases exists_gcf_pair_rat_eq_nth_conts v n with ⟨⟨_, b⟩, nth_cont_eq⟩\n  use b\n  simp [den_eq_conts_b, nth_cont_eq]\n\n"}
{"name":"GenContFract.exists_rat_eq_nth_conv","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Exists fun q => Eq ((GenContFract.of v).convs n) ↑q","decl":"/-- Every finite convergent corresponds to a rational number. -/\ntheorem exists_rat_eq_nth_conv : ∃ q : ℚ, (of v).convs n = (q : K) := by\n  rcases exists_rat_eq_nth_num v n with ⟨Aₙ, nth_num_eq⟩\n  rcases exists_rat_eq_nth_den v n with ⟨Bₙ, nth_den_eq⟩\n  use Aₙ / Bₙ\n  simp [nth_num_eq, nth_den_eq, conv_eq_num_div_den]\n\n"}
{"name":"GenContFract.exists_rat_eq_of_terminates","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nterminates : (GenContFract.of v).Terminates\n⊢ Exists fun q => Eq v ↑q","decl":"/-- Every terminating continued fraction corresponds to a rational number. -/\ntheorem exists_rat_eq_of_terminates (terminates : (of v).Terminates) : ∃ q : ℚ, v = ↑q := by\n  obtain ⟨n, v_eq_conv⟩ : ∃ n, v = (of v).convs n := of_correctness_of_terminates terminates\n  obtain ⟨q, conv_eq_q⟩ : ∃ q : ℚ, (of v).convs n = (↑q : K) := exists_rat_eq_nth_conv v n\n  have : v = (↑q : K) := Eq.trans v_eq_conv conv_eq_q\n  use q, this\n\n"}
{"name":"GenContFract.IntFractPair.coe_of_rat_eq","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nq : Rat\nv_eq_q : Eq v ↑q\n⊢ Eq (GenContFract.IntFractPair.mapFr Rat.cast (GenContFract.IntFractPair.of q)) (GenContFract.IntFractPair.of v)","decl":"theorem coe_of_rat_eq (v_eq_q : v = (↑q : K)) :\n    ((IntFractPair.of q).mapFr (↑) : IntFractPair K) = IntFractPair.of v := by\n  simp [IntFractPair.of, v_eq_q]\n\n"}
{"name":"GenContFract.IntFractPair.coe_stream_nth_rat_eq","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nq : Rat\nv_eq_q : Eq v ↑q\nn : Nat\n⊢ Eq (Option.map (GenContFract.IntFractPair.mapFr Rat.cast) (GenContFract.IntFractPair.stream q n)) (GenContFract.IntFractPair.stream v n)","decl":"theorem coe_stream_nth_rat_eq (v_eq_q : v = (↑q : K)) (n : ℕ) :\n    ((IntFractPair.stream q n).map (mapFr (↑)) : Option <| IntFractPair K) =\n      IntFractPair.stream v n := by\n  induction n with\n  | zero =>\n    -- Porting note: was\n    -- simp [IntFractPair.stream, coe_of_rat_eq v_eq_q]\n    simp only [IntFractPair.stream, Option.map_some', coe_of_rat_eq v_eq_q]\n  | succ n IH =>\n    rw [v_eq_q] at IH\n    cases stream_q_nth_eq : IntFractPair.stream q n with\n    | none => simp [IntFractPair.stream, IH.symm, v_eq_q, stream_q_nth_eq]\n    | some ifp_n =>\n      obtain ⟨b, fr⟩ := ifp_n\n      rcases Decidable.em (fr = 0) with fr_zero | fr_ne_zero\n      · simp [IntFractPair.stream, IH.symm, v_eq_q, stream_q_nth_eq, fr_zero]\n      · replace IH : some (IntFractPair.mk b (fr : K)) = IntFractPair.stream (↑q) n := by\n          rwa [stream_q_nth_eq] at IH\n        have : (fr : K)⁻¹ = ((fr⁻¹ : ℚ) : K) := by norm_cast\n        have coe_of_fr := coe_of_rat_eq this\n        simpa [IntFractPair.stream, IH.symm, v_eq_q, stream_q_nth_eq, fr_ne_zero]\n\n"}
{"name":"GenContFract.IntFractPair.coe_stream'_rat_eq","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nq : Rat\nv_eq_q : Eq v ↑q\n⊢ Eq (Stream'.map (Option.map (GenContFract.IntFractPair.mapFr Rat.cast)) (GenContFract.IntFractPair.stream q)) (GenContFract.IntFractPair.stream v)","decl":"theorem coe_stream'_rat_eq (v_eq_q : v = (↑q : K)) :\n    ((IntFractPair.stream q).map (Option.map (mapFr (↑))) : Stream' <| Option <| IntFractPair K) =\n      IntFractPair.stream v := by\n  funext n; exact IntFractPair.coe_stream_nth_rat_eq v_eq_q n\n\n"}
{"name":"GenContFract.coe_of_h_rat_eq","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nq : Rat\nv_eq_q : Eq v ↑q\n⊢ Eq (↑(GenContFract.of q).h) (GenContFract.of v).h","decl":"theorem coe_of_h_rat_eq (v_eq_q : v = (↑q : K)) : (↑((of q).h : ℚ) : K) = (of v).h := by\n  unfold of IntFractPair.seq1\n  rw [← IntFractPair.coe_of_rat_eq v_eq_q]\n  simp\n\n"}
{"name":"GenContFract.coe_of_s_get?_rat_eq","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nq : Rat\nv_eq_q : Eq v ↑q\nn : Nat\n⊢ Eq (Option.map (GenContFract.Pair.map Rat.cast) ((GenContFract.of q).s.get? n)) ((GenContFract.of v).s.get? n)","decl":"theorem coe_of_s_get?_rat_eq (v_eq_q : v = (↑q : K)) (n : ℕ) :\n    (((of q).s.get? n).map (Pair.map (↑)) : Option <| Pair K) = (of v).s.get? n := by\n  simp only [of, IntFractPair.seq1, Stream'.Seq.map_get?, Stream'.Seq.get?_tail]\n  simp only [Stream'.Seq.get?]\n  rw [← IntFractPair.coe_stream'_rat_eq v_eq_q]\n  rcases succ_nth_stream_eq : IntFractPair.stream q (n + 1) with (_ | ⟨_, _⟩) <;>\n    simp [Stream'.map, Stream'.get, succ_nth_stream_eq]\n\n"}
{"name":"GenContFract.coe_of_s_rat_eq","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nq : Rat\nv_eq_q : Eq v ↑q\n⊢ Eq (Stream'.Seq.map (GenContFract.Pair.map Rat.cast) (GenContFract.of q).s) (GenContFract.of v).s","decl":"theorem coe_of_s_rat_eq (v_eq_q : v = (↑q : K)) :\n    ((of q).s.map (Pair.map ((↑))) : Stream'.Seq <| Pair K) = (of v).s := by\n  ext n; rw [← coe_of_s_get?_rat_eq v_eq_q]; rfl\n\n"}
{"name":"GenContFract.coe_of_rat_eq","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nq : Rat\nv_eq_q : Eq v ↑q\n⊢ Eq { h := ↑(GenContFract.of q).h, s := Stream'.Seq.map (GenContFract.Pair.map Rat.cast) (GenContFract.of q).s } (GenContFract.of v)","decl":"/-- Given `(v : K), (q : ℚ), and v = q`, we have that `of q = of v` -/\ntheorem coe_of_rat_eq (v_eq_q : v = (↑q : K)) :\n    (⟨(of q).h, (of q).s.map (Pair.map (↑))⟩ : GenContFract K) = of v := by\n  rcases gcf_v_eq : of v with ⟨h, s⟩; subst v\n  -- Porting note: made coercion target explicit\n  obtain rfl : ↑⌊(q : K)⌋ = h := by injection gcf_v_eq\n  simp [coe_of_h_rat_eq rfl, coe_of_s_rat_eq rfl, gcf_v_eq]\n\n"}
{"name":"GenContFract.of_terminates_iff_of_rat_terminates","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nq : Rat\nv_eq_q : Eq v ↑q\n⊢ Iff (GenContFract.of v).Terminates (GenContFract.of q).Terminates","decl":"theorem of_terminates_iff_of_rat_terminates {v : K} {q : ℚ} (v_eq_q : v = (q : K)) :\n    (of v).Terminates ↔ (of q).Terminates := by\n  constructor <;> intro h <;> obtain ⟨n, h⟩ := h <;> use n <;>\n    simp only [Stream'.Seq.TerminatedAt, (coe_of_s_get?_rat_eq v_eq_q n).symm] at h ⊢ <;>\n    cases h' : (of q).s.get? n <;>\n    simp only [h'] at h <;> -- Porting note: added\n    trivial\n\n"}
{"name":"GenContFract.IntFractPair.of_inv_fr_num_lt_num_of_pos","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"q : Rat\nq_pos : LT.lt 0 q\n⊢ LT.lt (GenContFract.IntFractPair.of (Inv.inv q)).fr.num q.num","decl":"/-- Shows that for any `q : ℚ` with `0 < q < 1`, the numerator of the fractional part of\n`IntFractPair.of q⁻¹` is smaller than the numerator of `q`.\n-/\ntheorem of_inv_fr_num_lt_num_of_pos (q_pos : 0 < q) : (IntFractPair.of q⁻¹).fr.num < q.num :=\n  Rat.fract_inv_num_lt_num_of_pos q_pos\n\n"}
{"name":"GenContFract.IntFractPair.stream_succ_nth_fr_num_lt_nth_fr_num_rat","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"q : Rat\nn : Nat\nifp_n ifp_succ_n : GenContFract.IntFractPair Rat\nstream_nth_eq : Eq (GenContFract.IntFractPair.stream q n) (Option.some ifp_n)\nstream_succ_nth_eq : Eq (GenContFract.IntFractPair.stream q (HAdd.hAdd n 1)) (Option.some ifp_succ_n)\n⊢ LT.lt ifp_succ_n.fr.num ifp_n.fr.num","decl":"/-- Shows that the sequence of numerators of the fractional parts of the stream is strictly\nantitone. -/\ntheorem stream_succ_nth_fr_num_lt_nth_fr_num_rat {ifp_n ifp_succ_n : IntFractPair ℚ}\n    (stream_nth_eq : IntFractPair.stream q n = some ifp_n)\n    (stream_succ_nth_eq : IntFractPair.stream q (n + 1) = some ifp_succ_n) :\n    ifp_succ_n.fr.num < ifp_n.fr.num := by\n  obtain ⟨ifp_n', stream_nth_eq', ifp_n_fract_ne_zero, IntFractPair.of_eq_ifp_succ_n⟩ :\n    ∃ ifp_n',\n      IntFractPair.stream q n = some ifp_n' ∧\n        ifp_n'.fr ≠ 0 ∧ IntFractPair.of ifp_n'.fr⁻¹ = ifp_succ_n :=\n    succ_nth_stream_eq_some_iff.mp stream_succ_nth_eq\n  have : ifp_n = ifp_n' := by injection Eq.trans stream_nth_eq.symm stream_nth_eq'\n  cases this\n  rw [← IntFractPair.of_eq_ifp_succ_n]\n  obtain ⟨zero_le_ifp_n_fract, _⟩ := nth_stream_fr_nonneg_lt_one stream_nth_eq\n  have : 0 < ifp_n.fr := lt_of_le_of_ne zero_le_ifp_n_fract <| ifp_n_fract_ne_zero.symm\n  exact of_inv_fr_num_lt_num_of_pos this\n\n"}
{"name":"GenContFract.IntFractPair.stream_nth_fr_num_le_fr_num_sub_n_rat","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"q : Rat\nn : Nat\nifp_n : GenContFract.IntFractPair Rat\na✝ : Eq (GenContFract.IntFractPair.stream q n) (Option.some ifp_n)\n⊢ LE.le ifp_n.fr.num (HSub.hSub (GenContFract.IntFractPair.of q).fr.num ↑n)","decl":"theorem stream_nth_fr_num_le_fr_num_sub_n_rat :\n    ∀ {ifp_n : IntFractPair ℚ},\n      IntFractPair.stream q n = some ifp_n → ifp_n.fr.num ≤ (IntFractPair.of q).fr.num - n := by\n  induction n with\n  | zero =>\n    intro ifp_zero stream_zero_eq\n    have : IntFractPair.of q = ifp_zero := by injection stream_zero_eq\n    simp [le_refl, this.symm]\n  | succ n IH =>\n    intro ifp_succ_n stream_succ_nth_eq\n    suffices ifp_succ_n.fr.num + 1 ≤ (IntFractPair.of q).fr.num - n by\n      rw [Int.ofNat_succ, sub_add_eq_sub_sub]\n      solve_by_elim [le_sub_right_of_add_le]\n    rcases succ_nth_stream_eq_some_iff.mp stream_succ_nth_eq with ⟨ifp_n, stream_nth_eq, -⟩\n    have : ifp_succ_n.fr.num < ifp_n.fr.num :=\n      stream_succ_nth_fr_num_lt_nth_fr_num_rat stream_nth_eq stream_succ_nth_eq\n    have : ifp_succ_n.fr.num + 1 ≤ ifp_n.fr.num := Int.add_one_le_of_lt this\n    exact le_trans this (IH stream_nth_eq)\n\n"}
{"name":"GenContFract.IntFractPair.exists_nth_stream_eq_none_of_rat","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"q : Rat\n⊢ Exists fun n => Eq (GenContFract.IntFractPair.stream q n) Option.none","decl":"theorem exists_nth_stream_eq_none_of_rat (q : ℚ) : ∃ n : ℕ, IntFractPair.stream q n = none := by\n  let fract_q_num := (Int.fract q).num; let n := fract_q_num.natAbs + 1\n  rcases stream_nth_eq : IntFractPair.stream q n with ifp | ifp\n  · use n, stream_nth_eq\n  · -- arrive at a contradiction since the numerator decreased num + 1 times but every fractional\n    -- value is nonnegative.\n    have ifp_fr_num_le_q_fr_num_sub_n : ifp.fr.num ≤ fract_q_num - n :=\n      stream_nth_fr_num_le_fr_num_sub_n_rat stream_nth_eq\n    have : fract_q_num - n = -1 := by\n      have : 0 ≤ fract_q_num := Rat.num_nonneg.mpr (Int.fract_nonneg q)\n      -- Porting note: was\n      -- simp [Int.natAbs_of_nonneg this, sub_add_eq_sub_sub_swap, sub_right_comm]\n      simp only [n, Nat.cast_add, Int.natAbs_of_nonneg this, Nat.cast_one,\n        sub_add_eq_sub_sub_swap, sub_right_comm, sub_self, zero_sub]\n    have : 0 ≤ ifp.fr := (nth_stream_fr_nonneg_lt_one stream_nth_eq).left\n    have : 0 ≤ ifp.fr.num := Rat.num_nonneg.mpr this\n    omega\n\n"}
{"name":"GenContFract.terminates_of_rat","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"q : Rat\n⊢ (GenContFract.of q).Terminates","decl":"/-- The continued fraction of a rational number terminates. -/\ntheorem terminates_of_rat (q : ℚ) : (of q).Terminates :=\n  Exists.elim (IntFractPair.exists_nth_stream_eq_none_of_rat q) fun n stream_nth_eq_none =>\n    Exists.intro n\n      (have : IntFractPair.stream q (n + 1) = none := IntFractPair.stream_isSeq q stream_nth_eq_none\n      of_terminatedAt_n_iff_succ_nth_intFractPair_stream_eq_none.mpr this)\n\n"}
{"name":"GenContFract.terminates_iff_rat","module":"Mathlib.Algebra.ContinuedFractions.Computation.TerminatesIffRat","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\n⊢ Iff (GenContFract.of v).Terminates (Exists fun q => Eq v ↑q)","decl":"/-- The continued fraction `GenContFract.of v` terminates if and only if `v ∈ ℚ`. -/\ntheorem terminates_iff_rat (v : K) : (of v).Terminates ↔ ∃ q : ℚ, v = (q : K) :=\n  Iff.intro\n    (fun terminates_v : (of v).Terminates =>\n      show ∃ q : ℚ, v = (q : K) from exists_rat_eq_of_terminates terminates_v)\n    fun exists_q_eq_v : ∃ q : ℚ, v = (↑q : K) =>\n    Exists.elim exists_q_eq_v fun q => fun v_eq_q : v = ↑q =>\n      have : (of q).Terminates := terminates_of_rat q\n      (of_terminates_iff_of_rat_terminates v_eq_q).mpr this\n\n"}
