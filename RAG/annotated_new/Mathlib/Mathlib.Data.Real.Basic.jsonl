{"name":"Real.ofCauchy.inj","module":"Mathlib.Data.Real.Basic","initialProofState":"cauchy✝ cauchy : CauSeq.Completion.Cauchy abs\nx✝ : Eq { cauchy := cauchy✝ } { cauchy := cauchy }\n⊢ Eq cauchy✝ cauchy","decl":"/-- The type `ℝ` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. -/\nstructure Real where ofCauchy ::\n  /-- The underlying Cauchy completion -/\n  cauchy : CauSeq.Completion.Cauchy (abs : ℚ → ℚ)\n\n"}
{"name":"Real.ofCauchy.sizeOf_spec","module":"Mathlib.Data.Real.Basic","initialProofState":"cauchy : CauSeq.Completion.Cauchy abs\n⊢ Eq (SizeOf.sizeOf { cauchy := cauchy }) (HAdd.hAdd 1 (SizeOf.sizeOf cauchy))","decl":"/-- The type `ℝ` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. -/\nstructure Real where ofCauchy ::\n  /-- The underlying Cauchy completion -/\n  cauchy : CauSeq.Completion.Cauchy (abs : ℚ → ℚ)\n\n"}
{"name":"Real.ofCauchy.injEq","module":"Mathlib.Data.Real.Basic","initialProofState":"cauchy✝ cauchy : CauSeq.Completion.Cauchy abs\n⊢ Eq (Eq { cauchy := cauchy✝ } { cauchy := cauchy }) (Eq cauchy✝ cauchy)","decl":"/-- The type `ℝ` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. -/\nstructure Real where ofCauchy ::\n  /-- The underlying Cauchy completion -/\n  cauchy : CauSeq.Completion.Cauchy (abs : ℚ → ℚ)\n\n"}
{"name":"CauSeq.Completion.ofRat_rat","module":"Mathlib.Data.Real.Basic","initialProofState":"abv : Rat → Rat\ninst✝ : IsAbsoluteValue abv\nq : Rat\n⊢ Eq (CauSeq.Completion.ofRat q) ↑q","decl":"@[simp]\ntheorem ofRat_rat {abv : ℚ → ℚ} [IsAbsoluteValue abv] (q : ℚ) :\n    ofRat (q : ℚ) = (q : Cauchy abv) :=\n  rfl\n\n"}
{"name":"Real.ext_cauchy_iff","module":"Mathlib.Data.Real.Basic","initialProofState":"x y : Real\n⊢ Iff (Eq x y) (Eq x.cauchy y.cauchy)","decl":"theorem ext_cauchy_iff : ∀ {x y : Real}, x = y ↔ x.cauchy = y.cauchy\n  | ⟨a⟩, ⟨b⟩ => by rw [ofCauchy.injEq]\n\n"}
{"name":"Real.ext_cauchy","module":"Mathlib.Data.Real.Basic","initialProofState":"x y : Real\na✝ : Eq x.cauchy y.cauchy\n⊢ Eq x y","decl":"theorem ext_cauchy {x y : Real} : x.cauchy = y.cauchy → x = y :=\n  ext_cauchy_iff.2\n\n"}
{"name":"Real.ofCauchy_zero","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ Eq { cauchy := 0 } 0","decl":"theorem ofCauchy_zero : (⟨0⟩ : ℝ) = 0 :=\n  zero_def.symm\n\n"}
{"name":"Real.ofCauchy_one","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ Eq { cauchy := 1 } 1","decl":"theorem ofCauchy_one : (⟨1⟩ : ℝ) = 1 :=\n  one_def.symm\n\n"}
{"name":"Real.ofCauchy_add","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : CauSeq.Completion.Cauchy abs\n⊢ Eq { cauchy := HAdd.hAdd a b } (HAdd.hAdd { cauchy := a } { cauchy := b })","decl":"theorem ofCauchy_add (a b) : (⟨a + b⟩ : ℝ) = ⟨a⟩ + ⟨b⟩ :=\n  (add_def _ _).symm\n\n"}
{"name":"Real.ofCauchy_neg","module":"Mathlib.Data.Real.Basic","initialProofState":"a : CauSeq.Completion.Cauchy abs\n⊢ Eq { cauchy := Neg.neg a } (Neg.neg { cauchy := a })","decl":"theorem ofCauchy_neg (a) : (⟨-a⟩ : ℝ) = -⟨a⟩ :=\n  (neg_def _).symm\n\n"}
{"name":"Real.ofCauchy_sub","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : CauSeq.Completion.Cauchy abs\n⊢ Eq { cauchy := HSub.hSub a b } (HSub.hSub { cauchy := a } { cauchy := b })","decl":"theorem ofCauchy_sub (a b) : (⟨a - b⟩ : ℝ) = ⟨a⟩ - ⟨b⟩ := by\n  rw [sub_eq_add_neg, ofCauchy_add, ofCauchy_neg]\n  rfl\n\n"}
{"name":"Real.ofCauchy_mul","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : CauSeq.Completion.Cauchy abs\n⊢ Eq { cauchy := HMul.hMul a b } (HMul.hMul { cauchy := a } { cauchy := b })","decl":"theorem ofCauchy_mul (a b) : (⟨a * b⟩ : ℝ) = ⟨a⟩ * ⟨b⟩ :=\n  (mul_def _ _).symm\n\n"}
{"name":"Real.ofCauchy_inv","module":"Mathlib.Data.Real.Basic","initialProofState":"f : CauSeq.Completion.Cauchy abs\n⊢ Eq { cauchy := Inv.inv f } (Inv.inv { cauchy := f })","decl":"theorem ofCauchy_inv {f} : (⟨f⁻¹⟩ : ℝ) = ⟨f⟩⁻¹ :=\n  show _ = inv' _ by rw [inv']\n\n"}
{"name":"Real.cauchy_zero","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ Eq (Real.cauchy 0) 0","decl":"theorem cauchy_zero : (0 : ℝ).cauchy = 0 :=\n  show zero.cauchy = 0 by rw [zero_def]\n\n"}
{"name":"Real.cauchy_one","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ Eq (Real.cauchy 1) 1","decl":"theorem cauchy_one : (1 : ℝ).cauchy = 1 :=\n  show one.cauchy = 1 by rw [one_def]\n\n"}
{"name":"Real.cauchy_add","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : Real\n⊢ Eq (HAdd.hAdd a b).cauchy (HAdd.hAdd a.cauchy b.cauchy)","decl":"theorem cauchy_add : ∀ a b, (a + b : ℝ).cauchy = a.cauchy + b.cauchy\n  | ⟨a⟩, ⟨b⟩ => show (add _ _).cauchy = _ by rw [add_def]\n\n"}
{"name":"Real.cauchy_neg","module":"Mathlib.Data.Real.Basic","initialProofState":"a : Real\n⊢ Eq (Neg.neg a).cauchy (Neg.neg a.cauchy)","decl":"theorem cauchy_neg : ∀ a, (-a : ℝ).cauchy = -a.cauchy\n  | ⟨a⟩ => show (neg _).cauchy = _ by rw [neg_def]\n\n"}
{"name":"Real.cauchy_mul","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : Real\n⊢ Eq (HMul.hMul a b).cauchy (HMul.hMul a.cauchy b.cauchy)","decl":"theorem cauchy_mul : ∀ a b, (a * b : ℝ).cauchy = a.cauchy * b.cauchy\n  | ⟨a⟩, ⟨b⟩ => show (mul _ _).cauchy = _ by rw [mul_def]\n\n"}
{"name":"Real.cauchy_sub","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : Real\n⊢ Eq (HSub.hSub a b).cauchy (HSub.hSub a.cauchy b.cauchy)","decl":"theorem cauchy_sub : ∀ a b, (a - b : ℝ).cauchy = a.cauchy - b.cauchy\n  | ⟨a⟩, ⟨b⟩ => by\n    rw [sub_eq_add_neg, ← cauchy_neg, ← cauchy_add]\n    rfl\n\n"}
{"name":"Real.cauchy_inv","module":"Mathlib.Data.Real.Basic","initialProofState":"f : Real\n⊢ Eq (Inv.inv f).cauchy (Inv.inv f.cauchy)","decl":"theorem cauchy_inv : ∀ f, (f⁻¹ : ℝ).cauchy = f.cauchy⁻¹\n  | ⟨f⟩ => show (inv' _).cauchy = _ by rw [inv']\n\n"}
{"name":"Real.ofCauchy_natCast","module":"Mathlib.Data.Real.Basic","initialProofState":"n : Nat\n⊢ Eq { cauchy := ↑n } ↑n","decl":"lemma ofCauchy_natCast (n : ℕ) : (⟨n⟩ : ℝ) = n := rfl\n"}
{"name":"Real.ofCauchy_intCast","module":"Mathlib.Data.Real.Basic","initialProofState":"z : Int\n⊢ Eq { cauchy := ↑z } ↑z","decl":"lemma ofCauchy_intCast (z : ℤ) : (⟨z⟩ : ℝ) = z := rfl\n"}
{"name":"Real.ofCauchy_nnratCast","module":"Mathlib.Data.Real.Basic","initialProofState":"q : NNRat\n⊢ Eq { cauchy := ↑q } ↑q","decl":"lemma ofCauchy_nnratCast (q : ℚ≥0) : (⟨q⟩ : ℝ) = q := rfl\n"}
{"name":"Real.ofCauchy_ratCast","module":"Mathlib.Data.Real.Basic","initialProofState":"q : Rat\n⊢ Eq { cauchy := ↑q } ↑q","decl":"lemma ofCauchy_ratCast (q : ℚ) : (⟨q⟩ : ℝ) = q := rfl\n\n"}
{"name":"Real.cauchy_natCast","module":"Mathlib.Data.Real.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n).cauchy ↑n","decl":"lemma cauchy_natCast (n : ℕ) : (n : ℝ).cauchy = n := rfl\n"}
{"name":"Real.cauchy_intCast","module":"Mathlib.Data.Real.Basic","initialProofState":"z : Int\n⊢ Eq (↑z).cauchy ↑z","decl":"lemma cauchy_intCast (z : ℤ) : (z : ℝ).cauchy = z := rfl\n"}
{"name":"Real.cauchy_nnratCast","module":"Mathlib.Data.Real.Basic","initialProofState":"q : NNRat\n⊢ Eq (↑q).cauchy ↑q","decl":"lemma cauchy_nnratCast (q : ℚ≥0) : (q : ℝ).cauchy = q := rfl\n"}
{"name":"Real.cauchy_ratCast","module":"Mathlib.Data.Real.Basic","initialProofState":"q : Rat\n⊢ Eq (↑q).cauchy ↑q","decl":"lemma cauchy_ratCast (q : ℚ) : (q : ℝ).cauchy = q := rfl\n\n"}
{"name":"Real.ringEquivCauchy_symm_apply_cauchy","module":"Mathlib.Data.Real.Basic","initialProofState":"cauchy : CauSeq.Completion.Cauchy abs\n⊢ Eq (Real.ringEquivCauchy.symm cauchy).cauchy cauchy","decl":"/-- `Real.equivCauchy` as a ring equivalence. -/\n@[simps]\ndef ringEquivCauchy : ℝ ≃+* CauSeq.Completion.Cauchy (abs : ℚ → ℚ) :=\n  { equivCauchy with\n    toFun := cauchy\n    invFun := ofCauchy\n    map_add' := cauchy_add\n    map_mul' := cauchy_mul }\n\n"}
{"name":"Real.ringEquivCauchy_apply","module":"Mathlib.Data.Real.Basic","initialProofState":"self : Real\n⊢ Eq (Real.ringEquivCauchy self) self.cauchy","decl":"/-- `Real.equivCauchy` as a ring equivalence. -/\n@[simps]\ndef ringEquivCauchy : ℝ ≃+* CauSeq.Completion.Cauchy (abs : ℚ → ℚ) :=\n  { equivCauchy with\n    toFun := cauchy\n    invFun := ofCauchy\n    map_add' := cauchy_add\n    map_mul' := cauchy_mul }\n\n"}
{"name":"Real.mk_eq","module":"Mathlib.Data.Real.Basic","initialProofState":"f g : CauSeq Rat abs\n⊢ Iff (Eq (Real.mk f) (Real.mk g)) (HasEquiv.Equiv f g)","decl":"theorem mk_eq {f g : CauSeq ℚ abs} : mk f = mk g ↔ f ≈ g :=\n  ext_cauchy_iff.trans CauSeq.Completion.mk_eq\n\n"}
{"name":"Real.lt_cauchy","module":"Mathlib.Data.Real.Basic","initialProofState":"f g : CauSeq Rat abs\n⊢ Iff (LT.lt { cauchy := Quotient.mk CauSeq.equiv f } { cauchy := Quotient.mk CauSeq.equiv g }) (LT.lt f g)","decl":"theorem lt_cauchy {f g} : (⟨⟦f⟧⟩ : ℝ) < ⟨⟦g⟧⟩ ↔ f < g :=\n  show lt _ _ ↔ _ by rw [lt_def]; rfl\n\n"}
{"name":"Real.mk_lt","module":"Mathlib.Data.Real.Basic","initialProofState":"f g : CauSeq Rat abs\n⊢ Iff (LT.lt (Real.mk f) (Real.mk g)) (LT.lt f g)","decl":"@[simp]\ntheorem mk_lt {f g : CauSeq ℚ abs} : mk f < mk g ↔ f < g :=\n  lt_cauchy\n\n"}
{"name":"Real.mk_zero","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ Eq (Real.mk 0) 0","decl":"theorem mk_zero : mk 0 = 0 := by rw [← ofCauchy_zero]; rfl\n\n"}
{"name":"Real.mk_one","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ Eq (Real.mk 1) 1","decl":"theorem mk_one : mk 1 = 1 := by rw [← ofCauchy_one]; rfl\n\n"}
{"name":"Real.mk_add","module":"Mathlib.Data.Real.Basic","initialProofState":"f g : CauSeq Rat abs\n⊢ Eq (Real.mk (HAdd.hAdd f g)) (HAdd.hAdd (Real.mk f) (Real.mk g))","decl":"theorem mk_add {f g : CauSeq ℚ abs} : mk (f + g) = mk f + mk g := by simp [mk, ← ofCauchy_add]\n\n"}
{"name":"Real.mk_mul","module":"Mathlib.Data.Real.Basic","initialProofState":"f g : CauSeq Rat abs\n⊢ Eq (Real.mk (HMul.hMul f g)) (HMul.hMul (Real.mk f) (Real.mk g))","decl":"theorem mk_mul {f g : CauSeq ℚ abs} : mk (f * g) = mk f * mk g := by simp [mk, ← ofCauchy_mul]\n\n"}
{"name":"Real.mk_neg","module":"Mathlib.Data.Real.Basic","initialProofState":"f : CauSeq Rat abs\n⊢ Eq (Real.mk (Neg.neg f)) (Neg.neg (Real.mk f))","decl":"theorem mk_neg {f : CauSeq ℚ abs} : mk (-f) = -mk f := by simp [mk, ← ofCauchy_neg]\n\n"}
{"name":"Real.mk_pos","module":"Mathlib.Data.Real.Basic","initialProofState":"f : CauSeq Rat abs\n⊢ Iff (LT.lt 0 (Real.mk f)) f.Pos","decl":"@[simp]\ntheorem mk_pos {f : CauSeq ℚ abs} : 0 < mk f ↔ Pos f := by\n  rw [← mk_zero, mk_lt]\n  exact iff_of_eq (congr_arg Pos (sub_zero f))\n\n"}
{"name":"Real.mk_le","module":"Mathlib.Data.Real.Basic","initialProofState":"f g : CauSeq Rat abs\n⊢ Iff (LE.le (Real.mk f) (Real.mk g)) (LE.le f g)","decl":"@[simp]\ntheorem mk_le {f g : CauSeq ℚ abs} : mk f ≤ mk g ↔ f ≤ g := by\n  simp only [le_def', mk_lt, mk_eq]; rfl\n\n"}
{"name":"Real.ind_mk","module":"Mathlib.Data.Real.Basic","initialProofState":"C : Real → Prop\nx : Real\nh : ∀ (y : CauSeq Rat abs), C (Real.mk y)\n⊢ C x","decl":"@[elab_as_elim]\nprotected theorem ind_mk {C : Real → Prop} (x : Real) (h : ∀ y, C (mk y)) : C x := by\n  cases' x with x\n  induction' x using Quot.induction_on with x\n  exact h x\n\n"}
{"name":"Real.add_lt_add_iff_left","module":"Mathlib.Data.Real.Basic","initialProofState":"a b c : Real\n⊢ Iff (LT.lt (HAdd.hAdd c a) (HAdd.hAdd c b)) (LT.lt a b)","decl":"theorem add_lt_add_iff_left {a b : ℝ} (c : ℝ) : c + a < c + b ↔ a < b := by\n  induction a using Real.ind_mk\n  induction b using Real.ind_mk\n  induction c using Real.ind_mk\n  simp only [mk_lt, ← mk_add]\n  show Pos _ ↔ Pos _; rw [add_sub_add_left_eq_sub]\n\n"}
{"name":"Real.ratCast_lt","module":"Mathlib.Data.Real.Basic","initialProofState":"x y : Rat\n⊢ Iff (LT.lt ↑x ↑y) (LT.lt x y)","decl":"theorem ratCast_lt {x y : ℚ} : (x : ℝ) < (y : ℝ) ↔ x < y := by\n  erw [mk_lt]\n  exact const_lt\n\n"}
{"name":"Real.zero_lt_one","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ LT.lt 0 1","decl":"protected theorem zero_lt_one : (0 : ℝ) < 1 := by\n  convert ratCast_lt.2 zero_lt_one <;> simp [← ofCauchy_ratCast, ofCauchy_one, ofCauchy_zero]\n\n"}
{"name":"Real.fact_zero_lt_one","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ Fact (LT.lt 0 1)","decl":"protected theorem fact_zero_lt_one : Fact ((0 : ℝ) < 1) :=\n  ⟨Real.zero_lt_one⟩\n\n"}
{"name":"Real.mul_pos","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : Real\na✝¹ : LT.lt 0 a\na✝ : LT.lt 0 b\n⊢ LT.lt 0 (HMul.hMul a b)","decl":"@[deprecated mul_pos (since := \"2024-08-15\")]\nprotected theorem mul_pos {a b : ℝ} : 0 < a → 0 < b → 0 < a * b := by\n  induction' a using Real.ind_mk with a\n  induction' b using Real.ind_mk with b\n  simpa only [mk_lt, mk_pos, ← mk_mul] using CauSeq.mul_pos\n\n"}
{"name":"Real.nontrivial","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ Nontrivial Real","decl":"instance nontrivial : Nontrivial ℝ :=\n  inferInstance\n\n"}
{"name":"Real.ofCauchy_sup","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : CauSeq Rat abs\n⊢ Eq { cauchy := Quotient.mk CauSeq.equiv (Max.max a b) } (Max.max { cauchy := Quotient.mk CauSeq.equiv a } { cauchy := Quotient.mk CauSeq.equiv b })","decl":"theorem ofCauchy_sup (a b) : (⟨⟦a ⊔ b⟧⟩ : ℝ) = ⟨⟦a⟧⟩ ⊔ ⟨⟦b⟧⟩ :=\n  show _ = sup _ _ by\n    rw [sup_def]\n    rfl\n\n"}
{"name":"Real.mk_sup","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : CauSeq Rat abs\n⊢ Eq (Real.mk (Max.max a b)) (Max.max (Real.mk a) (Real.mk b))","decl":"@[simp]\ntheorem mk_sup (a b) : (mk (a ⊔ b) : ℝ) = mk a ⊔ mk b :=\n  ofCauchy_sup _ _\n\n"}
{"name":"Real.ofCauchy_inf","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : CauSeq Rat abs\n⊢ Eq { cauchy := Quotient.mk CauSeq.equiv (Min.min a b) } (Min.min { cauchy := Quotient.mk CauSeq.equiv a } { cauchy := Quotient.mk CauSeq.equiv b })","decl":"theorem ofCauchy_inf (a b) : (⟨⟦a ⊓ b⟧⟩ : ℝ) = ⟨⟦a⟧⟩ ⊓ ⟨⟦b⟧⟩ :=\n  show _ = inf _ _ by\n    rw [inf_def]\n    rfl\n\n"}
{"name":"Real.mk_inf","module":"Mathlib.Data.Real.Basic","initialProofState":"a b : CauSeq Rat abs\n⊢ Eq (Real.mk (Min.min a b)) (Min.min (Real.mk a) (Real.mk b))","decl":"@[simp]\ntheorem mk_inf (a b) : (mk (a ⊓ b) : ℝ) = mk a ⊓ mk b :=\n  ofCauchy_inf _ _\n\n"}
{"name":"Real.leTotal_R","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ IsTotal Real fun x1 x2 => LE.le x1 x2","decl":"instance leTotal_R : IsTotal ℝ (· ≤ ·) :=\n  ⟨by\n    intros a b\n    induction' a using Real.ind_mk with a\n    induction' b using Real.ind_mk with b\n    simpa using le_total a b⟩\n\n"}
{"name":"Real.instIsDomain","module":"Mathlib.Data.Real.Basic","initialProofState":"⊢ IsDomain Real","decl":"instance : IsDomain ℝ :=\n  { Real.nontrivial, Real.commRing, LinearOrderedRing.isDomain with }\n\n"}
{"name":"Real.ofCauchy_div","module":"Mathlib.Data.Real.Basic","initialProofState":"f g : CauSeq.Completion.Cauchy abs\n⊢ Eq { cauchy := HDiv.hDiv f g } (HDiv.hDiv { cauchy := f } { cauchy := g })","decl":"lemma ofCauchy_div (f g) : (⟨f / g⟩ : ℝ) = (⟨f⟩ : ℝ) / (⟨g⟩ : ℝ) := by\n  simp_rw [div_eq_mul_inv, ofCauchy_mul, ofCauchy_inv]\n\n"}
{"name":"Real.le_mk_of_forall_le","module":"Mathlib.Data.Real.Basic","initialProofState":"x : Real\nf : CauSeq Rat abs\na✝ : Exists fun i => ∀ (j : Nat), GE.ge j i → LE.le x ↑(↑f j)\n⊢ LE.le x (Real.mk f)","decl":"theorem le_mk_of_forall_le {f : CauSeq ℚ abs} : (∃ i, ∀ j ≥ i, x ≤ f j) → x ≤ mk f := by\n  intro h\n  induction' x using Real.ind_mk with x\n  apply le_of_not_lt\n  rw [mk_lt]\n  rintro ⟨K, K0, hK⟩\n  obtain ⟨i, H⟩ := exists_forall_ge_and h (exists_forall_ge_and hK (f.cauchy₃ <| half_pos K0))\n  apply not_lt_of_le (H _ le_rfl).1\n  erw [mk_lt]\n  refine ⟨_, half_pos K0, i, fun j ij => ?_⟩\n  have := add_le_add (H _ ij).2.1 (le_of_lt (abs_lt.1 <| (H _ le_rfl).2.2 _ ij).1)\n  rwa [← sub_eq_add_neg, sub_self_div_two, sub_apply, sub_add_sub_cancel] at this\n\n"}
{"name":"Real.mk_le_of_forall_le","module":"Mathlib.Data.Real.Basic","initialProofState":"f : CauSeq Rat abs\nx : Real\nh : Exists fun i => ∀ (j : Nat), GE.ge j i → LE.le (↑(↑f j)) x\n⊢ LE.le (Real.mk f) x","decl":"theorem mk_le_of_forall_le {f : CauSeq ℚ abs} {x : ℝ} (h : ∃ i, ∀ j ≥ i, (f j : ℝ) ≤ x) :\n    mk f ≤ x := by\n  cases' h with i H\n  rw [← neg_le_neg_iff, ← mk_neg]\n  exact le_mk_of_forall_le ⟨i, fun j ij => by simp [H _ ij]⟩\n\n"}
{"name":"Real.mk_near_of_forall_near","module":"Mathlib.Data.Real.Basic","initialProofState":"f : CauSeq Rat abs\nx ε : Real\nH : Exists fun i => ∀ (j : Nat), GE.ge j i → LE.le (abs (HSub.hSub (↑(↑f j)) x)) ε\n⊢ LE.le (abs (HSub.hSub (Real.mk f) x)) ε","decl":"theorem mk_near_of_forall_near {f : CauSeq ℚ abs} {x : ℝ} {ε : ℝ}\n    (H : ∃ i, ∀ j ≥ i, |(f j : ℝ) - x| ≤ ε) : |mk f - x| ≤ ε :=\n  abs_sub_le_iff.2\n    ⟨sub_le_iff_le_add'.2 <|\n        mk_le_of_forall_le <|\n          H.imp fun _ h j ij => sub_le_iff_le_add'.1 (abs_sub_le_iff.1 <| h j ij).1,\n      sub_le_comm.1 <|\n        le_mk_of_forall_le <| H.imp fun _ h j ij => sub_le_comm.1 (abs_sub_le_iff.1 <| h j ij).2⟩\n\n"}
{"name":"Real.mul_add_one_le_add_one_pow","module":"Mathlib.Data.Real.Basic","initialProofState":"a : Real\nha : LE.le 0 a\nb : Nat\n⊢ LE.le (HAdd.hAdd (HMul.hMul a ↑b) 1) (HPow.hPow (HAdd.hAdd a 1) b)","decl":"lemma mul_add_one_le_add_one_pow {a : ℝ} (ha : 0 ≤ a) (b : ℕ) : a * b + 1 ≤ (a + 1) ^ b := by\n  rcases ha.eq_or_lt with rfl|ha'\n  · simp\n  clear ha\n  induction b generalizing a with\n  | zero => simp\n  | succ b hb =>\n    calc\n      a * ↑(b + 1) + 1 = (0 + 1) ^ b * a + (a * b + 1) := by\n        simp [mul_add, add_assoc, add_left_comm]\n      _ ≤ (a + 1) ^ b * a + (a + 1) ^ b := by\n        gcongr\n        · norm_num\n        · exact hb ha'\n      _ = (a + 1) ^ (b + 1) := by simp [pow_succ, mul_add]\n\n"}
