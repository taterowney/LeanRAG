{"name":"HasDerivAt.lhopital_zero_right_on_Ioo","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhab : LT.lt a b\nhff' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ HasDerivAt f (f' x) x\nhgg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ HasDerivAt g (g' x) x\nhg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ Ne (g' x) 0\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (Set.Ioi a)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"theorem lhopital_zero_right_on_Ioo (hab : a < b) (hff' : âˆ€ x âˆˆ Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€ x âˆˆ Ioo a b, HasDerivAt g (g' x) x) (hg' : âˆ€ x âˆˆ Ioo a b, g' x â‰  0)\n    (hfa : Tendsto f (ğ“[>] a) (ğ“ 0)) (hga : Tendsto g (ğ“[>] a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“[>] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[>] a) l := by\n  have sub : âˆ€ x âˆˆ Ioo a b, Ioo a x âŠ† Ioo a b := fun x hx =>\n    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)\n  have hg : âˆ€ x âˆˆ Ioo a b, g x â‰  0 := by\n    intro x hx h\n    have : Tendsto g (ğ“[<] x) (ğ“ 0) := by\n      rw [â† h, â† nhdsWithin_Ioo_eq_nhdsLT hx.1]\n      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto\n    obtain âŸ¨y, hyx, hyâŸ© : âˆƒ c âˆˆ Ioo a x, g' c = 0 :=\n      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy\n    exact hg' y (sub x hx hyx) hy\n  have : âˆ€ x âˆˆ Ioo a b, âˆƒ c âˆˆ Ioo a x, f x * g' c = g x * f' c := by\n    intro x hx\n    rw [â† sub_zero (f x), â† sub_zero (g x)]\n    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)\n      (fun y hy => hff' y <| sub x hx hy) hga hfa\n      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)\n      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)\n  choose! c hc using this\n  have : âˆ€ x âˆˆ Ioo a b, ((fun x' => f' x' / g' x') âˆ˜ c) x = f x / g x := by\n    intro x hx\n    rcases hc x hx with âŸ¨hâ‚, hâ‚‚âŸ©\n    field_simp [hg x hx, hg' (c x) ((sub x hx) hâ‚)]\n    simp only [hâ‚‚]\n    rw [mul_comm]\n  have cmp : âˆ€ x âˆˆ Ioo a b, a < c x âˆ§ c x < x := fun x hx => (hc x hx).1\n  rw [â† nhdsWithin_Ioo_eq_nhdsGT hab]\n  apply tendsto_nhdsWithin_congr this\n  apply hdiv.comp\n  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds\n      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_) ?_\n  all_goals\n    apply eventually_nhdsWithin_of_forall\n    intro x hx\n    have := cmp x hx\n    try simp\n    linarith [this]\n\n"}
{"name":"HasDerivAt.lhopital_zero_right_on_Ico","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhab : LT.lt a b\nhff' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ HasDerivAt f (f' x) x\nhgg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ HasDerivAt g (g' x) x\nhcf : ContinuousOn f (Set.Ico a b)\nhcg : ContinuousOn g (Set.Ico a b)\nhg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ Ne (g' x) 0\nhfa : Eq (f a) 0\nhga : Eq (g a) 0\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (Set.Ioi a)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"theorem lhopital_zero_right_on_Ico (hab : a < b) (hff' : âˆ€ x âˆˆ Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€ x âˆˆ Ioo a b, HasDerivAt g (g' x) x) (hcf : ContinuousOn f (Ico a b))\n    (hcg : ContinuousOn g (Ico a b)) (hg' : âˆ€ x âˆˆ Ioo a b, g' x â‰  0) (hfa : f a = 0) (hga : g a = 0)\n    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“[>] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[>] a) l := by\n  refine lhopital_zero_right_on_Ioo hab hff' hgg' hg' ?_ ?_ hdiv\n  Â· rw [â† hfa, â† nhdsWithin_Ioo_eq_nhdsGT hab]\n    exact ((hcf a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto\n  Â· rw [â† hga, â† nhdsWithin_Ioo_eq_nhdsGT hab]\n    exact ((hcg a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto\n\n"}
{"name":"HasDerivAt.lhopital_zero_left_on_Ioo","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhab : LT.lt a b\nhff' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ HasDerivAt f (f' x) x\nhgg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ HasDerivAt g (g' x) x\nhg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ Ne (g' x) 0\nhfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds 0)\nhgb : Filter.Tendsto g (nhdsWithin b (Set.Iio b)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin b (Set.Iio b)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin b (Set.Iio b)) l","decl":"theorem lhopital_zero_left_on_Ioo (hab : a < b) (hff' : âˆ€ x âˆˆ Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€ x âˆˆ Ioo a b, HasDerivAt g (g' x) x) (hg' : âˆ€ x âˆˆ Ioo a b, g' x â‰  0)\n    (hfb : Tendsto f (ğ“[<] b) (ğ“ 0)) (hgb : Tendsto g (ğ“[<] b) (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“[<] b) l) :\n  Tendsto (fun x => f x / g x) (ğ“[<] b) l := by\n  -- Here, we essentially compose by `Neg.neg`. The following is mostly technical details.\n  have hdnf : âˆ€ x âˆˆ -Ioo a b, HasDerivAt (f âˆ˜ Neg.neg) (f' (-x) * -1) x := fun x hx =>\n    comp x (hff' (-x) hx) (hasDerivAt_neg x)\n  have hdng : âˆ€ x âˆˆ -Ioo a b, HasDerivAt (g âˆ˜ Neg.neg) (g' (-x) * -1) x := fun x hx =>\n    comp x (hgg' (-x) hx) (hasDerivAt_neg x)\n  rw [neg_Ioo] at hdnf\n  rw [neg_Ioo] at hdng\n  have := lhopital_zero_right_on_Ioo (neg_lt_neg hab) hdnf hdng (by\n    intro x hx h\n    apply hg' _ (by rw [â† neg_Ioo] at hx; exact hx)\n    rwa [mul_comm, â† neg_eq_neg_one_mul, neg_eq_zero] at h)\n    (hfb.comp tendsto_neg_nhdsGT_neg) (hgb.comp tendsto_neg_nhdsGT_neg)\n    (by\n      simp only [neg_div_neg_eq, mul_one, mul_neg]\n      exact (tendsto_congr fun x => rfl).mp (hdiv.comp tendsto_neg_nhdsGT_neg))\n  have := this.comp tendsto_neg_nhdsLT\n  unfold Function.comp at this\n  simpa only [neg_neg]\n\n"}
{"name":"HasDerivAt.lhopital_zero_left_on_Ioc","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhab : LT.lt a b\nhff' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ HasDerivAt f (f' x) x\nhgg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ HasDerivAt g (g' x) x\nhcf : ContinuousOn f (Set.Ioc a b)\nhcg : ContinuousOn g (Set.Ioc a b)\nhg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ Ne (g' x) 0\nhfb : Eq (f b) 0\nhgb : Eq (g b) 0\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin b (Set.Iio b)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin b (Set.Iio b)) l","decl":"theorem lhopital_zero_left_on_Ioc (hab : a < b) (hff' : âˆ€ x âˆˆ Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€ x âˆˆ Ioo a b, HasDerivAt g (g' x) x) (hcf : ContinuousOn f (Ioc a b))\n    (hcg : ContinuousOn g (Ioc a b)) (hg' : âˆ€ x âˆˆ Ioo a b, g' x â‰  0) (hfb : f b = 0) (hgb : g b = 0)\n    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“[<] b) l) :\n    Tendsto (fun x => f x / g x) (ğ“[<] b) l := by\n  refine lhopital_zero_left_on_Ioo hab hff' hgg' hg' ?_ ?_ hdiv\n  Â· rw [â† hfb, â† nhdsWithin_Ioo_eq_nhdsLT hab]\n    exact ((hcf b <| right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto\n  Â· rw [â† hgb, â† nhdsWithin_Ioo_eq_nhdsLT hab]\n    exact ((hcg b <| right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto\n\n"}
{"name":"HasDerivAt.lhopital_zero_atTop_on_Ioi","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhff' : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt f (f' x) x\nhgg' : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt g (g' x) x\nhg' : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ Ne (g' x) 0\nhftop : Filter.Tendsto f Filter.atTop (nhds 0)\nhgtop : Filter.Tendsto g Filter.atTop (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) Filter.atTop l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atTop l","decl":"theorem lhopital_zero_atTop_on_Ioi (hff' : âˆ€ x âˆˆ Ioi a, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€ x âˆˆ Ioi a, HasDerivAt g (g' x) x) (hg' : âˆ€ x âˆˆ Ioi a, g' x â‰  0)\n    (hftop : Tendsto f atTop (ğ“ 0)) (hgtop : Tendsto g atTop (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atTop l) : Tendsto (fun x => f x / g x) atTop l := by\n  obtain âŸ¨a', haa', ha'âŸ© : âˆƒ a', a < a' âˆ§ 0 < a' := âŸ¨1 + max a 0,\n    âŸ¨lt_of_le_of_lt (le_max_left a 0) (lt_one_add _),\n      lt_of_le_of_lt (le_max_right a 0) (lt_one_add _)âŸ©âŸ©\n  have fact1 : âˆ€ x : â„, x âˆˆ Ioo 0 a'â»Â¹ â†’ x â‰  0 := fun _ hx => (ne_of_lt hx.1).symm\n  have fact2 (x) (hx : x âˆˆ Ioo 0 a'â»Â¹) : a < xâ»Â¹ := lt_trans haa' ((lt_inv_commâ‚€ ha' hx.1).mpr hx.2)\n  have hdnf : âˆ€ x âˆˆ Ioo 0 a'â»Â¹, HasDerivAt (f âˆ˜ Inv.inv) (f' xâ»Â¹ * -(x ^ 2)â»Â¹) x := fun x hx =>\n    comp x (hff' xâ»Â¹ <| fact2 x hx) (hasDerivAt_inv <| fact1 x hx)\n  have hdng : âˆ€ x âˆˆ Ioo 0 a'â»Â¹, HasDerivAt (g âˆ˜ Inv.inv) (g' xâ»Â¹ * -(x ^ 2)â»Â¹) x := fun x hx =>\n    comp x (hgg' xâ»Â¹ <| fact2 x hx) (hasDerivAt_inv <| fact1 x hx)\n  have := lhopital_zero_right_on_Ioo (inv_pos.mpr ha') hdnf hdng\n    (by\n      intro x hx\n      refine mul_ne_zero ?_ (neg_ne_zero.mpr <| inv_ne_zero <| pow_ne_zero _ <| fact1 x hx)\n      exact hg' _ (fact2 x hx))\n    (hftop.comp tendsto_inv_nhdsGT_zero) (hgtop.comp tendsto_inv_nhdsGT_zero)\n    (by\n      refine (tendsto_congr' ?_).mp (hdiv.comp tendsto_inv_nhdsGT_zero)\n      rw [eventuallyEq_iff_exists_mem]\n      use Ioi 0, self_mem_nhdsWithin\n      intro x hx\n      unfold Function.comp\n      simp only\n      rw [mul_div_mul_right]\n      exact neg_ne_zero.mpr (inv_ne_zero <| pow_ne_zero _ <| ne_of_gt hx))\n  have := this.comp tendsto_inv_atTop_nhdsGT_zero\n  unfold Function.comp at this\n  simpa only [inv_inv]\n\n"}
{"name":"HasDerivAt.lhopital_zero_atBot_on_Iio","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhff' : âˆ€ (x : Real), Membership.mem (Set.Iio a) x â†’ HasDerivAt f (f' x) x\nhgg' : âˆ€ (x : Real), Membership.mem (Set.Iio a) x â†’ HasDerivAt g (g' x) x\nhg' : âˆ€ (x : Real), Membership.mem (Set.Iio a) x â†’ Ne (g' x) 0\nhfbot : Filter.Tendsto f Filter.atBot (nhds 0)\nhgbot : Filter.Tendsto g Filter.atBot (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) Filter.atBot l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atBot l","decl":"theorem lhopital_zero_atBot_on_Iio (hff' : âˆ€ x âˆˆ Iio a, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€ x âˆˆ Iio a, HasDerivAt g (g' x) x) (hg' : âˆ€ x âˆˆ Iio a, g' x â‰  0)\n    (hfbot : Tendsto f atBot (ğ“ 0)) (hgbot : Tendsto g atBot (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atBot l) : Tendsto (fun x => f x / g x) atBot l := by\n  -- Here, we essentially compose by `Neg.neg`. The following is mostly technical details.\n  have hdnf : âˆ€ x âˆˆ -Iio a, HasDerivAt (f âˆ˜ Neg.neg) (f' (-x) * -1) x := fun x hx =>\n    comp x (hff' (-x) hx) (hasDerivAt_neg x)\n  have hdng : âˆ€ x âˆˆ -Iio a, HasDerivAt (g âˆ˜ Neg.neg) (g' (-x) * -1) x := fun x hx =>\n    comp x (hgg' (-x) hx) (hasDerivAt_neg x)\n  rw [neg_Iio] at hdnf\n  rw [neg_Iio] at hdng\n  have := lhopital_zero_atTop_on_Ioi hdnf hdng\n    (by\n      intro x hx h\n      apply hg' _ (by rw [â† neg_Iio] at hx; exact hx)\n      rwa [mul_comm, â† neg_eq_neg_one_mul, neg_eq_zero] at h)\n    (hfbot.comp tendsto_neg_atTop_atBot) (hgbot.comp tendsto_neg_atTop_atBot)\n    (by\n      simp only [mul_one, mul_neg, neg_div_neg_eq]\n      exact (tendsto_congr fun x => rfl).mp (hdiv.comp tendsto_neg_atTop_atBot))\n  have := this.comp tendsto_neg_atBot_atTop\n  unfold Function.comp at this\n  simpa only [neg_neg]\n\n"}
{"name":"deriv.lhopital_zero_right_on_Ioo","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf g : Real â†’ Real\nhab : LT.lt a b\nhdf : DifferentiableOn Real f (Set.Ioo a b)\nhg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ Ne (deriv g x) 0\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (Set.Ioi a)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"theorem lhopital_zero_right_on_Ioo (hab : a < b) (hdf : DifferentiableOn â„ f (Ioo a b))\n    (hg' : âˆ€ x âˆˆ Ioo a b, deriv g x â‰  0) (hfa : Tendsto f (ğ“[>] a) (ğ“ 0))\n    (hga : Tendsto g (ğ“[>] a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (ğ“[>] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[>] a) l := by\n  have hdf : âˆ€ x âˆˆ Ioo a b, DifferentiableAt â„ f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioo_mem_nhds hx.1 hx.2)\n  have hdg : âˆ€ x âˆˆ Ioo a b, DifferentiableAt â„ g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_right_on_Ioo hab (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfa hga hdiv\n\n"}
{"name":"deriv.lhopital_zero_right_on_Ico","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf g : Real â†’ Real\nhab : LT.lt a b\nhdf : DifferentiableOn Real f (Set.Ioo a b)\nhcf : ContinuousOn f (Set.Ico a b)\nhcg : ContinuousOn g (Set.Ico a b)\nhg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ Ne (deriv g x) 0\nhfa : Eq (f a) 0\nhga : Eq (g a) 0\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (Set.Ioi a)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"theorem lhopital_zero_right_on_Ico (hab : a < b) (hdf : DifferentiableOn â„ f (Ioo a b))\n    (hcf : ContinuousOn f (Ico a b)) (hcg : ContinuousOn g (Ico a b))\n    (hg' : âˆ€ x âˆˆ Ioo a b, (deriv g) x â‰  0) (hfa : f a = 0) (hga : g a = 0)\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (ğ“[>] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[>] a) l := by\n  refine lhopital_zero_right_on_Ioo hab hdf hg' ?_ ?_ hdiv\n  Â· rw [â† hfa, â† nhdsWithin_Ioo_eq_nhdsGT hab]\n    exact ((hcf a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto\n  Â· rw [â† hga, â† nhdsWithin_Ioo_eq_nhdsGT hab]\n    exact ((hcg a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto\n\n"}
{"name":"deriv.lhopital_zero_left_on_Ioo","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf g : Real â†’ Real\nhab : LT.lt a b\nhdf : DifferentiableOn Real f (Set.Ioo a b)\nhg' : âˆ€ (x : Real), Membership.mem (Set.Ioo a b) x â†’ Ne (deriv g x) 0\nhfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds 0)\nhgb : Filter.Tendsto g (nhdsWithin b (Set.Iio b)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin b (Set.Iio b)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin b (Set.Iio b)) l","decl":"theorem lhopital_zero_left_on_Ioo (hab : a < b) (hdf : DifferentiableOn â„ f (Ioo a b))\n    (hg' : âˆ€ x âˆˆ Ioo a b, (deriv g) x â‰  0) (hfb : Tendsto f (ğ“[<] b) (ğ“ 0))\n    (hgb : Tendsto g (ğ“[<] b) (ğ“ 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (ğ“[<] b) l) :\n    Tendsto (fun x => f x / g x) (ğ“[<] b) l := by\n  have hdf : âˆ€ x âˆˆ Ioo a b, DifferentiableAt â„ f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioo_mem_nhds hx.1 hx.2)\n  have hdg : âˆ€ x âˆˆ Ioo a b, DifferentiableAt â„ g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_left_on_Ioo hab (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfb hgb hdiv\n\n"}
{"name":"deriv.lhopital_zero_atTop_on_Ioi","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real â†’ Real\nhdf : DifferentiableOn Real f (Set.Ioi a)\nhg' : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ Ne (deriv g x) 0\nhftop : Filter.Tendsto f Filter.atTop (nhds 0)\nhgtop : Filter.Tendsto g Filter.atTop (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) Filter.atTop l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atTop l","decl":"theorem lhopital_zero_atTop_on_Ioi (hdf : DifferentiableOn â„ f (Ioi a))\n    (hg' : âˆ€ x âˆˆ Ioi a, (deriv g) x â‰  0) (hftop : Tendsto f atTop (ğ“ 0))\n    (hgtop : Tendsto g atTop (ğ“ 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atTop l) :\n    Tendsto (fun x => f x / g x) atTop l := by\n  have hdf : âˆ€ x âˆˆ Ioi a, DifferentiableAt â„ f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioi_mem_nhds hx)\n  have hdg : âˆ€ x âˆˆ Ioi a, DifferentiableAt â„ g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_atTop_on_Ioi (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hftop hgtop hdiv\n\n"}
{"name":"deriv.lhopital_zero_atBot_on_Iio","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real â†’ Real\nhdf : DifferentiableOn Real f (Set.Iio a)\nhg' : âˆ€ (x : Real), Membership.mem (Set.Iio a) x â†’ Ne (deriv g x) 0\nhfbot : Filter.Tendsto f Filter.atBot (nhds 0)\nhgbot : Filter.Tendsto g Filter.atBot (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) Filter.atBot l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atBot l","decl":"theorem lhopital_zero_atBot_on_Iio (hdf : DifferentiableOn â„ f (Iio a))\n    (hg' : âˆ€ x âˆˆ Iio a, (deriv g) x â‰  0) (hfbot : Tendsto f atBot (ğ“ 0))\n    (hgbot : Tendsto g atBot (ğ“ 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atBot l) :\n    Tendsto (fun x => f x / g x) atBot l := by\n  have hdf : âˆ€ x âˆˆ Iio a, DifferentiableAt â„ f x := fun x hx =>\n    (hdf x hx).differentiableAt (Iio_mem_nhds hx)\n  have hdg : âˆ€ x âˆˆ Iio a, DifferentiableAt â„ g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_atBot_on_Iio (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfbot hgbot hdiv\n\n"}
{"name":"HasDerivAt.lhopital_zero_nhds_right","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) (nhdsWithin a (Set.Ioi a))\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) (nhdsWithin a (Set.Ioi a))\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) (nhdsWithin a (Set.Ioi a))\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (Set.Ioi a)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"/-- L'HÃ´pital's rule for approaching a real from the right, `HasDerivAt` version -/\ntheorem lhopital_zero_nhds_right (hff' : âˆ€á¶  x in ğ“[>] a, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€á¶  x in ğ“[>] a, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  x in ğ“[>] a, g' x â‰  0)\n    (hfa : Tendsto f (ğ“[>] a) (ğ“ 0)) (hga : Tendsto g (ğ“[>] a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“[>] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[>] a) l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with âŸ¨sâ‚, hsâ‚, hff'âŸ©\n  rcases hgg' with âŸ¨sâ‚‚, hsâ‚‚, hgg'âŸ©\n  rcases hg' with âŸ¨sâ‚ƒ, hsâ‚ƒ, hg'âŸ©\n  let s := sâ‚ âˆ© sâ‚‚ âˆ© sâ‚ƒ\n  have hs : s âˆˆ ğ“[>] a := inter_mem (inter_mem hsâ‚ hsâ‚‚) hsâ‚ƒ\n  rw [mem_nhdsGT_iff_exists_Ioo_subset] at hs\n  rcases hs with âŸ¨u, hau, huâŸ©\n  refine lhopital_zero_right_on_Ioo hau ?_ ?_ ?_ hfa hga hdiv <;>\n    intro x hx <;> apply_assumption <;>\n    first | exact (hu hx).1.1 | exact (hu hx).1.2 | exact (hu hx).2\n\n"}
{"name":"HasDerivAt.lhopital_zero_nhds_left","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) (nhdsWithin a (Set.Iio a))\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) (nhdsWithin a (Set.Iio a))\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) (nhdsWithin a (Set.Iio a))\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (Set.Iio a)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Iio a)) l","decl":"/-- L'HÃ´pital's rule for approaching a real from the left, `HasDerivAt` version -/\ntheorem lhopital_zero_nhds_left (hff' : âˆ€á¶  x in ğ“[<] a, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€á¶  x in ğ“[<] a, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  x in ğ“[<] a, g' x â‰  0)\n    (hfa : Tendsto f (ğ“[<] a) (ğ“ 0)) (hga : Tendsto g (ğ“[<] a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“[<] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[<] a) l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with âŸ¨sâ‚, hsâ‚, hff'âŸ©\n  rcases hgg' with âŸ¨sâ‚‚, hsâ‚‚, hgg'âŸ©\n  rcases hg' with âŸ¨sâ‚ƒ, hsâ‚ƒ, hg'âŸ©\n  let s := sâ‚ âˆ© sâ‚‚ âˆ© sâ‚ƒ\n  have hs : s âˆˆ ğ“[<] a := inter_mem (inter_mem hsâ‚ hsâ‚‚) hsâ‚ƒ\n  rw [mem_nhdsLT_iff_exists_Ioo_subset] at hs\n  rcases hs with âŸ¨l, hal, hlâŸ©\n  refine lhopital_zero_left_on_Ioo hal ?_ ?_ ?_ hfa hga hdiv <;> intro x hx <;> apply_assumption <;>\n    first | exact (hl hx).1.1| exact (hl hx).1.2| exact (hl hx).2\n\n"}
{"name":"HasDerivAt.lhopital_zero_nhds'","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhfa : Filter.Tendsto f (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l","decl":"/-- L'HÃ´pital's rule for approaching a real, `HasDerivAt` version. This\n  does not require anything about the situation at `a` -/\ntheorem lhopital_zero_nhds' (hff' : âˆ€á¶  x in ğ“[â‰ ] a, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€á¶  x in ğ“[â‰ ] a, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  x in ğ“[â‰ ] a, g' x â‰  0)\n    (hfa : Tendsto f (ğ“[â‰ ] a) (ğ“ 0)) (hga : Tendsto g (ğ“[â‰ ] a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“[â‰ ] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[â‰ ] a) l := by\n  simp only [â† Iio_union_Ioi, nhdsWithin_union, tendsto_sup, eventually_sup] at *\n  exact âŸ¨lhopital_zero_nhds_left hff'.1 hgg'.1 hg'.1 hfa.1 hga.1 hdiv.1,\n    lhopital_zero_nhds_right hff'.2 hgg'.2 hg'.2 hfa.2 hga.2 hdiv.2âŸ©\n\n"}
{"name":"HasDerivAt.lhopital_zero_nhds","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real â†’ Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) (nhds a)\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) (nhds a)\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) (nhds a)\nhfa : Filter.Tendsto f (nhds a) (nhds 0)\nhga : Filter.Tendsto g (nhds a) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhds a) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l","decl":"/-- **L'HÃ´pital's rule** for approaching a real, `HasDerivAt` version -/\ntheorem lhopital_zero_nhds (hff' : âˆ€á¶  x in ğ“ a, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€á¶  x in ğ“ a, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  x in ğ“ a, g' x â‰  0)\n    (hfa : Tendsto f (ğ“ a) (ğ“ 0)) (hga : Tendsto g (ğ“ a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“ a) l) : Tendsto (fun x => f x / g x) (ğ“[â‰ ] a) l := by\n  apply @lhopital_zero_nhds' _ _ _ f' _ g' <;>\n    (first | apply eventually_nhdsWithin_of_eventually_nhds |\n      apply tendsto_nhdsWithin_of_tendsto_nhds) <;> assumption\n\n"}
{"name":"HasDerivAt.lhopital_zero_atTop","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"l : Filter Real\nf f' g g' : Real â†’ Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) Filter.atTop\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) Filter.atTop\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) Filter.atTop\nhftop : Filter.Tendsto f Filter.atTop (nhds 0)\nhgtop : Filter.Tendsto g Filter.atTop (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) Filter.atTop l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atTop l","decl":"/-- L'HÃ´pital's rule for approaching +âˆ, `HasDerivAt` version -/\ntheorem lhopital_zero_atTop (hff' : âˆ€á¶  x in atTop, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€á¶  x in atTop, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  x in atTop, g' x â‰  0)\n    (hftop : Tendsto f atTop (ğ“ 0)) (hgtop : Tendsto g atTop (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atTop l) : Tendsto (fun x => f x / g x) atTop l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with âŸ¨sâ‚, hsâ‚, hff'âŸ©\n  rcases hgg' with âŸ¨sâ‚‚, hsâ‚‚, hgg'âŸ©\n  rcases hg' with âŸ¨sâ‚ƒ, hsâ‚ƒ, hg'âŸ©\n  let s := sâ‚ âˆ© sâ‚‚ âˆ© sâ‚ƒ\n  have hs : s âˆˆ atTop := inter_mem (inter_mem hsâ‚ hsâ‚‚) hsâ‚ƒ\n  rw [mem_atTop_sets] at hs\n  rcases hs with âŸ¨l, hlâŸ©\n  have hl' : Ioi l âŠ† s := fun x hx => hl x (le_of_lt hx)\n  refine lhopital_zero_atTop_on_Ioi ?_ ?_ (fun x hx => hg' x <| (hl' hx).2) hftop hgtop hdiv <;>\n    intro x hx <;> apply_assumption <;> first | exact (hl' hx).1.1| exact (hl' hx).1.2\n\n"}
{"name":"HasDerivAt.lhopital_zero_atBot","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"l : Filter Real\nf f' g g' : Real â†’ Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) Filter.atBot\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) Filter.atBot\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) Filter.atBot\nhfbot : Filter.Tendsto f Filter.atBot (nhds 0)\nhgbot : Filter.Tendsto g Filter.atBot (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) Filter.atBot l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atBot l","decl":"/-- L'HÃ´pital's rule for approaching -âˆ, `HasDerivAt` version -/\ntheorem lhopital_zero_atBot (hff' : âˆ€á¶  x in atBot, HasDerivAt f (f' x) x)\n    (hgg' : âˆ€á¶  x in atBot, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  x in atBot, g' x â‰  0)\n    (hfbot : Tendsto f atBot (ğ“ 0)) (hgbot : Tendsto g atBot (ğ“ 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atBot l) : Tendsto (fun x => f x / g x) atBot l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with âŸ¨sâ‚, hsâ‚, hff'âŸ©\n  rcases hgg' with âŸ¨sâ‚‚, hsâ‚‚, hgg'âŸ©\n  rcases hg' with âŸ¨sâ‚ƒ, hsâ‚ƒ, hg'âŸ©\n  let s := sâ‚ âˆ© sâ‚‚ âˆ© sâ‚ƒ\n  have hs : s âˆˆ atBot := inter_mem (inter_mem hsâ‚ hsâ‚‚) hsâ‚ƒ\n  rw [mem_atBot_sets] at hs\n  rcases hs with âŸ¨l, hlâŸ©\n  have hl' : Iio l âŠ† s := fun x hx => hl x (le_of_lt hx)\n  refine lhopital_zero_atBot_on_Iio ?_ ?_ (fun x hx => hg' x <| (hl' hx).2) hfbot hgbot hdiv <;>\n    intro x hx <;> apply_assumption <;> first | exact (hl' hx).1.1| exact (hl' hx).1.2\n\n"}
{"name":"deriv.lhopital_zero_nhds_right","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real â†’ Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) (nhdsWithin a (Set.Ioi a))\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) (nhdsWithin a (Set.Ioi a))\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (Set.Ioi a)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"/-- **L'HÃ´pital's rule** for approaching a real from the right, `deriv` version -/\ntheorem lhopital_zero_nhds_right (hdf : âˆ€á¶  x in ğ“[>] a, DifferentiableAt â„ f x)\n    (hg' : âˆ€á¶  x in ğ“[>] a, deriv g x â‰  0) (hfa : Tendsto f (ğ“[>] a) (ğ“ 0))\n    (hga : Tendsto g (ğ“[>] a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (ğ“[>] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[>] a) l := by\n  have hdg : âˆ€á¶  x in ğ“[>] a, DifferentiableAt â„ g x :=\n    hg'.mp (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))\n  have hdf' : âˆ€á¶  x in ğ“[>] a, HasDerivAt f (deriv f x) x :=\n    hdf.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  have hdg' : âˆ€á¶  x in ğ“[>] a, HasDerivAt g (deriv g x) x :=\n    hdg.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  exact HasDerivAt.lhopital_zero_nhds_right hdf' hdg' hg' hfa hga hdiv\n\n"}
{"name":"deriv.lhopital_zero_nhds_left","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real â†’ Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) (nhdsWithin a (Set.Iio a))\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) (nhdsWithin a (Set.Iio a))\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (Set.Iio a)) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Iio a)) l","decl":"/-- **L'HÃ´pital's rule** for approaching a real from the left, `deriv` version -/\ntheorem lhopital_zero_nhds_left (hdf : âˆ€á¶  x in ğ“[<] a, DifferentiableAt â„ f x)\n    (hg' : âˆ€á¶  x in ğ“[<] a, deriv g x â‰  0) (hfa : Tendsto f (ğ“[<] a) (ğ“ 0))\n    (hga : Tendsto g (ğ“[<] a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (ğ“[<] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[<] a) l := by\n  have hdg : âˆ€á¶  x in ğ“[<] a, DifferentiableAt â„ g x :=\n    hg'.mp (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))\n  have hdf' : âˆ€á¶  x in ğ“[<] a, HasDerivAt f (deriv f x) x :=\n    hdf.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  have hdg' : âˆ€á¶  x in ğ“[<] a, HasDerivAt g (deriv g x) x :=\n    hdg.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  exact HasDerivAt.lhopital_zero_nhds_left hdf' hdg' hg' hfa hga hdiv\n\n"}
{"name":"deriv.lhopital_zero_nhds'","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real â†’ Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhfa : Filter.Tendsto f (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l","decl":"/-- **L'HÃ´pital's rule** for approaching a real, `deriv` version. This\n  does not require anything about the situation at `a` -/\ntheorem lhopital_zero_nhds' (hdf : âˆ€á¶  x in ğ“[â‰ ] a, DifferentiableAt â„ f x)\n    (hg' : âˆ€á¶  x in ğ“[â‰ ] a, deriv g x â‰  0) (hfa : Tendsto f (ğ“[â‰ ] a) (ğ“ 0))\n    (hga : Tendsto g (ğ“[â‰ ] a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (ğ“[â‰ ] a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[â‰ ] a) l := by\n  simp only [â† Iio_union_Ioi, nhdsWithin_union, tendsto_sup, eventually_sup] at *\n  exact âŸ¨lhopital_zero_nhds_left hdf.1 hg'.1 hfa.1 hga.1 hdiv.1,\n    lhopital_zero_nhds_right hdf.2 hg'.2 hfa.2 hga.2 hdiv.2âŸ©\n\n"}
{"name":"deriv.lhopital_zero_nhds","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real â†’ Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) (nhds a)\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) (nhds a)\nhfa : Filter.Tendsto f (nhds a) (nhds 0)\nhga : Filter.Tendsto g (nhds a) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhds a) l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l","decl":"/-- **L'HÃ´pital's rule** for approaching a real, `deriv` version -/\ntheorem lhopital_zero_nhds (hdf : âˆ€á¶  x in ğ“ a, DifferentiableAt â„ f x)\n    (hg' : âˆ€á¶  x in ğ“ a, deriv g x â‰  0) (hfa : Tendsto f (ğ“ a) (ğ“ 0)) (hga : Tendsto g (ğ“ a) (ğ“ 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (ğ“ a) l) :\n    Tendsto (fun x => f x / g x) (ğ“[â‰ ] a) l := by\n  apply lhopital_zero_nhds' <;>\n    (first | apply eventually_nhdsWithin_of_eventually_nhds |\n      apply tendsto_nhdsWithin_of_tendsto_nhds) <;> assumption\n\n"}
{"name":"deriv.lhopital_zero_atTop","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"l : Filter Real\nf g : Real â†’ Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) Filter.atTop\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) Filter.atTop\nhftop : Filter.Tendsto f Filter.atTop (nhds 0)\nhgtop : Filter.Tendsto g Filter.atTop (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) Filter.atTop l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atTop l","decl":"/-- **L'HÃ´pital's rule** for approaching +âˆ, `deriv` version -/\ntheorem lhopital_zero_atTop (hdf : âˆ€á¶  x : â„ in atTop, DifferentiableAt â„ f x)\n    (hg' : âˆ€á¶  x : â„ in atTop, deriv g x â‰  0) (hftop : Tendsto f atTop (ğ“ 0))\n    (hgtop : Tendsto g atTop (ğ“ 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atTop l) :\n    Tendsto (fun x => f x / g x) atTop l := by\n  have hdg : âˆ€á¶  x in atTop, DifferentiableAt â„ g x := hg'.mp\n    (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))\n  have hdf' : âˆ€á¶  x in atTop, HasDerivAt f (deriv f x) x :=\n    hdf.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  have hdg' : âˆ€á¶  x in atTop, HasDerivAt g (deriv g x) x :=\n    hdg.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  exact HasDerivAt.lhopital_zero_atTop hdf' hdg' hg' hftop hgtop hdiv\n\n"}
{"name":"deriv.lhopital_zero_atBot","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"l : Filter Real\nf g : Real â†’ Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) Filter.atBot\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) Filter.atBot\nhfbot : Filter.Tendsto f Filter.atBot (nhds 0)\nhgbot : Filter.Tendsto g Filter.atBot (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) Filter.atBot l\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atBot l","decl":"/-- **L'HÃ´pital's rule** for approaching -âˆ, `deriv` version -/\ntheorem lhopital_zero_atBot (hdf : âˆ€á¶  x : â„ in atBot, DifferentiableAt â„ f x)\n    (hg' : âˆ€á¶  x : â„ in atBot, deriv g x â‰  0) (hfbot : Tendsto f atBot (ğ“ 0))\n    (hgbot : Tendsto g atBot (ğ“ 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atBot l) :\n    Tendsto (fun x => f x / g x) atBot l := by\n  have hdg : âˆ€á¶  x in atBot, DifferentiableAt â„ g x :=\n    hg'.mp (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))\n  have hdf' : âˆ€á¶  x in atBot, HasDerivAt f (deriv f x) x :=\n    hdf.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  have hdg' : âˆ€á¶  x in atBot, HasDerivAt g (deriv g x) x :=\n    hdg.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  exact HasDerivAt.lhopital_zero_atBot hdf' hdg' hg' hfbot hgbot hdiv\n\n"}
