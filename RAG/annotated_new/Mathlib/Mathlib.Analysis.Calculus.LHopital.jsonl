{"name":"HasDerivAt.lhopital_zero_right_on_Ioo","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf f' g g' : Real → Real\nhab : LT.lt a b\nhff' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → HasDerivAt f (f' x) x\nhgg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → HasDerivAt g (g' x) x\nhg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → Ne (g' x) 0\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (Set.Ioi a)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"theorem lhopital_zero_right_on_Ioo (hab : a < b) (hff' : ∀ x ∈ Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : ∀ x ∈ Ioo a b, HasDerivAt g (g' x) x) (hg' : ∀ x ∈ Ioo a b, g' x ≠ 0)\n    (hfa : Tendsto f (𝓝[>] a) (𝓝 0)) (hga : Tendsto g (𝓝[>] a) (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[>] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[>] a) l := by\n  have sub : ∀ x ∈ Ioo a b, Ioo a x ⊆ Ioo a b := fun x hx =>\n    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)\n  have hg : ∀ x ∈ Ioo a b, g x ≠ 0 := by\n    intro x hx h\n    have : Tendsto g (𝓝[<] x) (𝓝 0) := by\n      rw [← h, ← nhdsWithin_Ioo_eq_nhdsLT hx.1]\n      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto\n    obtain ⟨y, hyx, hy⟩ : ∃ c ∈ Ioo a x, g' c = 0 :=\n      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy\n    exact hg' y (sub x hx hyx) hy\n  have : ∀ x ∈ Ioo a b, ∃ c ∈ Ioo a x, f x * g' c = g x * f' c := by\n    intro x hx\n    rw [← sub_zero (f x), ← sub_zero (g x)]\n    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)\n      (fun y hy => hff' y <| sub x hx hy) hga hfa\n      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)\n      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)\n  choose! c hc using this\n  have : ∀ x ∈ Ioo a b, ((fun x' => f' x' / g' x') ∘ c) x = f x / g x := by\n    intro x hx\n    rcases hc x hx with ⟨h₁, h₂⟩\n    field_simp [hg x hx, hg' (c x) ((sub x hx) h₁)]\n    simp only [h₂]\n    rw [mul_comm]\n  have cmp : ∀ x ∈ Ioo a b, a < c x ∧ c x < x := fun x hx => (hc x hx).1\n  rw [← nhdsWithin_Ioo_eq_nhdsGT hab]\n  apply tendsto_nhdsWithin_congr this\n  apply hdiv.comp\n  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds\n      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_) ?_\n  all_goals\n    apply eventually_nhdsWithin_of_forall\n    intro x hx\n    have := cmp x hx\n    try simp\n    linarith [this]\n\n"}
{"name":"HasDerivAt.lhopital_zero_right_on_Ico","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf f' g g' : Real → Real\nhab : LT.lt a b\nhff' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → HasDerivAt f (f' x) x\nhgg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → HasDerivAt g (g' x) x\nhcf : ContinuousOn f (Set.Ico a b)\nhcg : ContinuousOn g (Set.Ico a b)\nhg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → Ne (g' x) 0\nhfa : Eq (f a) 0\nhga : Eq (g a) 0\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (Set.Ioi a)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"theorem lhopital_zero_right_on_Ico (hab : a < b) (hff' : ∀ x ∈ Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : ∀ x ∈ Ioo a b, HasDerivAt g (g' x) x) (hcf : ContinuousOn f (Ico a b))\n    (hcg : ContinuousOn g (Ico a b)) (hg' : ∀ x ∈ Ioo a b, g' x ≠ 0) (hfa : f a = 0) (hga : g a = 0)\n    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[>] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[>] a) l := by\n  refine lhopital_zero_right_on_Ioo hab hff' hgg' hg' ?_ ?_ hdiv\n  · rw [← hfa, ← nhdsWithin_Ioo_eq_nhdsGT hab]\n    exact ((hcf a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto\n  · rw [← hga, ← nhdsWithin_Ioo_eq_nhdsGT hab]\n    exact ((hcg a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto\n\n"}
{"name":"HasDerivAt.lhopital_zero_left_on_Ioo","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf f' g g' : Real → Real\nhab : LT.lt a b\nhff' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → HasDerivAt f (f' x) x\nhgg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → HasDerivAt g (g' x) x\nhg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → Ne (g' x) 0\nhfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds 0)\nhgb : Filter.Tendsto g (nhdsWithin b (Set.Iio b)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin b (Set.Iio b)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin b (Set.Iio b)) l","decl":"theorem lhopital_zero_left_on_Ioo (hab : a < b) (hff' : ∀ x ∈ Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : ∀ x ∈ Ioo a b, HasDerivAt g (g' x) x) (hg' : ∀ x ∈ Ioo a b, g' x ≠ 0)\n    (hfb : Tendsto f (𝓝[<] b) (𝓝 0)) (hgb : Tendsto g (𝓝[<] b) (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[<] b) l) :\n  Tendsto (fun x => f x / g x) (𝓝[<] b) l := by\n  -- Here, we essentially compose by `Neg.neg`. The following is mostly technical details.\n  have hdnf : ∀ x ∈ -Ioo a b, HasDerivAt (f ∘ Neg.neg) (f' (-x) * -1) x := fun x hx =>\n    comp x (hff' (-x) hx) (hasDerivAt_neg x)\n  have hdng : ∀ x ∈ -Ioo a b, HasDerivAt (g ∘ Neg.neg) (g' (-x) * -1) x := fun x hx =>\n    comp x (hgg' (-x) hx) (hasDerivAt_neg x)\n  rw [neg_Ioo] at hdnf\n  rw [neg_Ioo] at hdng\n  have := lhopital_zero_right_on_Ioo (neg_lt_neg hab) hdnf hdng (by\n    intro x hx h\n    apply hg' _ (by rw [← neg_Ioo] at hx; exact hx)\n    rwa [mul_comm, ← neg_eq_neg_one_mul, neg_eq_zero] at h)\n    (hfb.comp tendsto_neg_nhdsGT_neg) (hgb.comp tendsto_neg_nhdsGT_neg)\n    (by\n      simp only [neg_div_neg_eq, mul_one, mul_neg]\n      exact (tendsto_congr fun x => rfl).mp (hdiv.comp tendsto_neg_nhdsGT_neg))\n  have := this.comp tendsto_neg_nhdsLT\n  unfold Function.comp at this\n  simpa only [neg_neg]\n\n"}
{"name":"HasDerivAt.lhopital_zero_left_on_Ioc","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf f' g g' : Real → Real\nhab : LT.lt a b\nhff' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → HasDerivAt f (f' x) x\nhgg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → HasDerivAt g (g' x) x\nhcf : ContinuousOn f (Set.Ioc a b)\nhcg : ContinuousOn g (Set.Ioc a b)\nhg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → Ne (g' x) 0\nhfb : Eq (f b) 0\nhgb : Eq (g b) 0\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin b (Set.Iio b)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin b (Set.Iio b)) l","decl":"theorem lhopital_zero_left_on_Ioc (hab : a < b) (hff' : ∀ x ∈ Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : ∀ x ∈ Ioo a b, HasDerivAt g (g' x) x) (hcf : ContinuousOn f (Ioc a b))\n    (hcg : ContinuousOn g (Ioc a b)) (hg' : ∀ x ∈ Ioo a b, g' x ≠ 0) (hfb : f b = 0) (hgb : g b = 0)\n    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[<] b) l) :\n    Tendsto (fun x => f x / g x) (𝓝[<] b) l := by\n  refine lhopital_zero_left_on_Ioo hab hff' hgg' hg' ?_ ?_ hdiv\n  · rw [← hfb, ← nhdsWithin_Ioo_eq_nhdsLT hab]\n    exact ((hcf b <| right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto\n  · rw [← hgb, ← nhdsWithin_Ioo_eq_nhdsLT hab]\n    exact ((hcg b <| right_mem_Ioc.mpr hab).mono Ioo_subset_Ioc_self).tendsto\n\n"}
{"name":"HasDerivAt.lhopital_zero_atTop_on_Ioi","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real → Real\nhff' : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt f (f' x) x\nhgg' : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt g (g' x) x\nhg' : ∀ (x : Real), Membership.mem (Set.Ioi a) x → Ne (g' x) 0\nhftop : Filter.Tendsto f Filter.atTop (nhds 0)\nhgtop : Filter.Tendsto g Filter.atTop (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) Filter.atTop l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atTop l","decl":"theorem lhopital_zero_atTop_on_Ioi (hff' : ∀ x ∈ Ioi a, HasDerivAt f (f' x) x)\n    (hgg' : ∀ x ∈ Ioi a, HasDerivAt g (g' x) x) (hg' : ∀ x ∈ Ioi a, g' x ≠ 0)\n    (hftop : Tendsto f atTop (𝓝 0)) (hgtop : Tendsto g atTop (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atTop l) : Tendsto (fun x => f x / g x) atTop l := by\n  obtain ⟨a', haa', ha'⟩ : ∃ a', a < a' ∧ 0 < a' := ⟨1 + max a 0,\n    ⟨lt_of_le_of_lt (le_max_left a 0) (lt_one_add _),\n      lt_of_le_of_lt (le_max_right a 0) (lt_one_add _)⟩⟩\n  have fact1 : ∀ x : ℝ, x ∈ Ioo 0 a'⁻¹ → x ≠ 0 := fun _ hx => (ne_of_lt hx.1).symm\n  have fact2 (x) (hx : x ∈ Ioo 0 a'⁻¹) : a < x⁻¹ := lt_trans haa' ((lt_inv_comm₀ ha' hx.1).mpr hx.2)\n  have hdnf : ∀ x ∈ Ioo 0 a'⁻¹, HasDerivAt (f ∘ Inv.inv) (f' x⁻¹ * -(x ^ 2)⁻¹) x := fun x hx =>\n    comp x (hff' x⁻¹ <| fact2 x hx) (hasDerivAt_inv <| fact1 x hx)\n  have hdng : ∀ x ∈ Ioo 0 a'⁻¹, HasDerivAt (g ∘ Inv.inv) (g' x⁻¹ * -(x ^ 2)⁻¹) x := fun x hx =>\n    comp x (hgg' x⁻¹ <| fact2 x hx) (hasDerivAt_inv <| fact1 x hx)\n  have := lhopital_zero_right_on_Ioo (inv_pos.mpr ha') hdnf hdng\n    (by\n      intro x hx\n      refine mul_ne_zero ?_ (neg_ne_zero.mpr <| inv_ne_zero <| pow_ne_zero _ <| fact1 x hx)\n      exact hg' _ (fact2 x hx))\n    (hftop.comp tendsto_inv_nhdsGT_zero) (hgtop.comp tendsto_inv_nhdsGT_zero)\n    (by\n      refine (tendsto_congr' ?_).mp (hdiv.comp tendsto_inv_nhdsGT_zero)\n      rw [eventuallyEq_iff_exists_mem]\n      use Ioi 0, self_mem_nhdsWithin\n      intro x hx\n      unfold Function.comp\n      simp only\n      rw [mul_div_mul_right]\n      exact neg_ne_zero.mpr (inv_ne_zero <| pow_ne_zero _ <| ne_of_gt hx))\n  have := this.comp tendsto_inv_atTop_nhdsGT_zero\n  unfold Function.comp at this\n  simpa only [inv_inv]\n\n"}
{"name":"HasDerivAt.lhopital_zero_atBot_on_Iio","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real → Real\nhff' : ∀ (x : Real), Membership.mem (Set.Iio a) x → HasDerivAt f (f' x) x\nhgg' : ∀ (x : Real), Membership.mem (Set.Iio a) x → HasDerivAt g (g' x) x\nhg' : ∀ (x : Real), Membership.mem (Set.Iio a) x → Ne (g' x) 0\nhfbot : Filter.Tendsto f Filter.atBot (nhds 0)\nhgbot : Filter.Tendsto g Filter.atBot (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) Filter.atBot l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atBot l","decl":"theorem lhopital_zero_atBot_on_Iio (hff' : ∀ x ∈ Iio a, HasDerivAt f (f' x) x)\n    (hgg' : ∀ x ∈ Iio a, HasDerivAt g (g' x) x) (hg' : ∀ x ∈ Iio a, g' x ≠ 0)\n    (hfbot : Tendsto f atBot (𝓝 0)) (hgbot : Tendsto g atBot (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atBot l) : Tendsto (fun x => f x / g x) atBot l := by\n  -- Here, we essentially compose by `Neg.neg`. The following is mostly technical details.\n  have hdnf : ∀ x ∈ -Iio a, HasDerivAt (f ∘ Neg.neg) (f' (-x) * -1) x := fun x hx =>\n    comp x (hff' (-x) hx) (hasDerivAt_neg x)\n  have hdng : ∀ x ∈ -Iio a, HasDerivAt (g ∘ Neg.neg) (g' (-x) * -1) x := fun x hx =>\n    comp x (hgg' (-x) hx) (hasDerivAt_neg x)\n  rw [neg_Iio] at hdnf\n  rw [neg_Iio] at hdng\n  have := lhopital_zero_atTop_on_Ioi hdnf hdng\n    (by\n      intro x hx h\n      apply hg' _ (by rw [← neg_Iio] at hx; exact hx)\n      rwa [mul_comm, ← neg_eq_neg_one_mul, neg_eq_zero] at h)\n    (hfbot.comp tendsto_neg_atTop_atBot) (hgbot.comp tendsto_neg_atTop_atBot)\n    (by\n      simp only [mul_one, mul_neg, neg_div_neg_eq]\n      exact (tendsto_congr fun x => rfl).mp (hdiv.comp tendsto_neg_atTop_atBot))\n  have := this.comp tendsto_neg_atBot_atTop\n  unfold Function.comp at this\n  simpa only [neg_neg]\n\n"}
{"name":"deriv.lhopital_zero_right_on_Ioo","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf g : Real → Real\nhab : LT.lt a b\nhdf : DifferentiableOn Real f (Set.Ioo a b)\nhg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → Ne (deriv g x) 0\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (Set.Ioi a)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"theorem lhopital_zero_right_on_Ioo (hab : a < b) (hdf : DifferentiableOn ℝ f (Ioo a b))\n    (hg' : ∀ x ∈ Ioo a b, deriv g x ≠ 0) (hfa : Tendsto f (𝓝[>] a) (𝓝 0))\n    (hga : Tendsto g (𝓝[>] a) (𝓝 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (𝓝[>] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[>] a) l := by\n  have hdf : ∀ x ∈ Ioo a b, DifferentiableAt ℝ f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioo_mem_nhds hx.1 hx.2)\n  have hdg : ∀ x ∈ Ioo a b, DifferentiableAt ℝ g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_right_on_Ioo hab (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfa hga hdiv\n\n"}
{"name":"deriv.lhopital_zero_right_on_Ico","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf g : Real → Real\nhab : LT.lt a b\nhdf : DifferentiableOn Real f (Set.Ioo a b)\nhcf : ContinuousOn f (Set.Ico a b)\nhcg : ContinuousOn g (Set.Ico a b)\nhg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → Ne (deriv g x) 0\nhfa : Eq (f a) 0\nhga : Eq (g a) 0\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (Set.Ioi a)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"theorem lhopital_zero_right_on_Ico (hab : a < b) (hdf : DifferentiableOn ℝ f (Ioo a b))\n    (hcf : ContinuousOn f (Ico a b)) (hcg : ContinuousOn g (Ico a b))\n    (hg' : ∀ x ∈ Ioo a b, (deriv g) x ≠ 0) (hfa : f a = 0) (hga : g a = 0)\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (𝓝[>] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[>] a) l := by\n  refine lhopital_zero_right_on_Ioo hab hdf hg' ?_ ?_ hdiv\n  · rw [← hfa, ← nhdsWithin_Ioo_eq_nhdsGT hab]\n    exact ((hcf a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto\n  · rw [← hga, ← nhdsWithin_Ioo_eq_nhdsGT hab]\n    exact ((hcg a <| left_mem_Ico.mpr hab).mono Ioo_subset_Ico_self).tendsto\n\n"}
{"name":"deriv.lhopital_zero_left_on_Ioo","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a b : Real\nl : Filter Real\nf g : Real → Real\nhab : LT.lt a b\nhdf : DifferentiableOn Real f (Set.Ioo a b)\nhg' : ∀ (x : Real), Membership.mem (Set.Ioo a b) x → Ne (deriv g x) 0\nhfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds 0)\nhgb : Filter.Tendsto g (nhdsWithin b (Set.Iio b)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin b (Set.Iio b)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin b (Set.Iio b)) l","decl":"theorem lhopital_zero_left_on_Ioo (hab : a < b) (hdf : DifferentiableOn ℝ f (Ioo a b))\n    (hg' : ∀ x ∈ Ioo a b, (deriv g) x ≠ 0) (hfb : Tendsto f (𝓝[<] b) (𝓝 0))\n    (hgb : Tendsto g (𝓝[<] b) (𝓝 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (𝓝[<] b) l) :\n    Tendsto (fun x => f x / g x) (𝓝[<] b) l := by\n  have hdf : ∀ x ∈ Ioo a b, DifferentiableAt ℝ f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioo_mem_nhds hx.1 hx.2)\n  have hdg : ∀ x ∈ Ioo a b, DifferentiableAt ℝ g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_left_on_Ioo hab (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfb hgb hdiv\n\n"}
{"name":"deriv.lhopital_zero_atTop_on_Ioi","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real → Real\nhdf : DifferentiableOn Real f (Set.Ioi a)\nhg' : ∀ (x : Real), Membership.mem (Set.Ioi a) x → Ne (deriv g x) 0\nhftop : Filter.Tendsto f Filter.atTop (nhds 0)\nhgtop : Filter.Tendsto g Filter.atTop (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) Filter.atTop l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atTop l","decl":"theorem lhopital_zero_atTop_on_Ioi (hdf : DifferentiableOn ℝ f (Ioi a))\n    (hg' : ∀ x ∈ Ioi a, (deriv g) x ≠ 0) (hftop : Tendsto f atTop (𝓝 0))\n    (hgtop : Tendsto g atTop (𝓝 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atTop l) :\n    Tendsto (fun x => f x / g x) atTop l := by\n  have hdf : ∀ x ∈ Ioi a, DifferentiableAt ℝ f x := fun x hx =>\n    (hdf x hx).differentiableAt (Ioi_mem_nhds hx)\n  have hdg : ∀ x ∈ Ioi a, DifferentiableAt ℝ g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_atTop_on_Ioi (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hftop hgtop hdiv\n\n"}
{"name":"deriv.lhopital_zero_atBot_on_Iio","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real → Real\nhdf : DifferentiableOn Real f (Set.Iio a)\nhg' : ∀ (x : Real), Membership.mem (Set.Iio a) x → Ne (deriv g x) 0\nhfbot : Filter.Tendsto f Filter.atBot (nhds 0)\nhgbot : Filter.Tendsto g Filter.atBot (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) Filter.atBot l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atBot l","decl":"theorem lhopital_zero_atBot_on_Iio (hdf : DifferentiableOn ℝ f (Iio a))\n    (hg' : ∀ x ∈ Iio a, (deriv g) x ≠ 0) (hfbot : Tendsto f atBot (𝓝 0))\n    (hgbot : Tendsto g atBot (𝓝 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atBot l) :\n    Tendsto (fun x => f x / g x) atBot l := by\n  have hdf : ∀ x ∈ Iio a, DifferentiableAt ℝ f x := fun x hx =>\n    (hdf x hx).differentiableAt (Iio_mem_nhds hx)\n  have hdg : ∀ x ∈ Iio a, DifferentiableAt ℝ g x := fun x hx =>\n    by_contradiction fun h => hg' x hx (deriv_zero_of_not_differentiableAt h)\n  exact HasDerivAt.lhopital_zero_atBot_on_Iio (fun x hx => (hdf x hx).hasDerivAt)\n    (fun x hx => (hdg x hx).hasDerivAt) hg' hfbot hgbot hdiv\n\n"}
{"name":"HasDerivAt.lhopital_zero_nhds_right","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real → Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) (nhdsWithin a (Set.Ioi a))\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) (nhdsWithin a (Set.Ioi a))\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) (nhdsWithin a (Set.Ioi a))\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (Set.Ioi a)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"/-- L'Hôpital's rule for approaching a real from the right, `HasDerivAt` version -/\ntheorem lhopital_zero_nhds_right (hff' : ∀ᶠ x in 𝓝[>] a, HasDerivAt f (f' x) x)\n    (hgg' : ∀ᶠ x in 𝓝[>] a, HasDerivAt g (g' x) x) (hg' : ∀ᶠ x in 𝓝[>] a, g' x ≠ 0)\n    (hfa : Tendsto f (𝓝[>] a) (𝓝 0)) (hga : Tendsto g (𝓝[>] a) (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[>] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[>] a) l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with ⟨s₁, hs₁, hff'⟩\n  rcases hgg' with ⟨s₂, hs₂, hgg'⟩\n  rcases hg' with ⟨s₃, hs₃, hg'⟩\n  let s := s₁ ∩ s₂ ∩ s₃\n  have hs : s ∈ 𝓝[>] a := inter_mem (inter_mem hs₁ hs₂) hs₃\n  rw [mem_nhdsGT_iff_exists_Ioo_subset] at hs\n  rcases hs with ⟨u, hau, hu⟩\n  refine lhopital_zero_right_on_Ioo hau ?_ ?_ ?_ hfa hga hdiv <;>\n    intro x hx <;> apply_assumption <;>\n    first | exact (hu hx).1.1 | exact (hu hx).1.2 | exact (hu hx).2\n\n"}
{"name":"HasDerivAt.lhopital_zero_nhds_left","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real → Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) (nhdsWithin a (Set.Iio a))\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) (nhdsWithin a (Set.Iio a))\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) (nhdsWithin a (Set.Iio a))\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (Set.Iio a)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Iio a)) l","decl":"/-- L'Hôpital's rule for approaching a real from the left, `HasDerivAt` version -/\ntheorem lhopital_zero_nhds_left (hff' : ∀ᶠ x in 𝓝[<] a, HasDerivAt f (f' x) x)\n    (hgg' : ∀ᶠ x in 𝓝[<] a, HasDerivAt g (g' x) x) (hg' : ∀ᶠ x in 𝓝[<] a, g' x ≠ 0)\n    (hfa : Tendsto f (𝓝[<] a) (𝓝 0)) (hga : Tendsto g (𝓝[<] a) (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[<] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[<] a) l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with ⟨s₁, hs₁, hff'⟩\n  rcases hgg' with ⟨s₂, hs₂, hgg'⟩\n  rcases hg' with ⟨s₃, hs₃, hg'⟩\n  let s := s₁ ∩ s₂ ∩ s₃\n  have hs : s ∈ 𝓝[<] a := inter_mem (inter_mem hs₁ hs₂) hs₃\n  rw [mem_nhdsLT_iff_exists_Ioo_subset] at hs\n  rcases hs with ⟨l, hal, hl⟩\n  refine lhopital_zero_left_on_Ioo hal ?_ ?_ ?_ hfa hga hdiv <;> intro x hx <;> apply_assumption <;>\n    first | exact (hl hx).1.1| exact (hl hx).1.2| exact (hl hx).2\n\n"}
{"name":"HasDerivAt.lhopital_zero_nhds'","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real → Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhfa : Filter.Tendsto f (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l","decl":"/-- L'Hôpital's rule for approaching a real, `HasDerivAt` version. This\n  does not require anything about the situation at `a` -/\ntheorem lhopital_zero_nhds' (hff' : ∀ᶠ x in 𝓝[≠] a, HasDerivAt f (f' x) x)\n    (hgg' : ∀ᶠ x in 𝓝[≠] a, HasDerivAt g (g' x) x) (hg' : ∀ᶠ x in 𝓝[≠] a, g' x ≠ 0)\n    (hfa : Tendsto f (𝓝[≠] a) (𝓝 0)) (hga : Tendsto g (𝓝[≠] a) (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[≠] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[≠] a) l := by\n  simp only [← Iio_union_Ioi, nhdsWithin_union, tendsto_sup, eventually_sup] at *\n  exact ⟨lhopital_zero_nhds_left hff'.1 hgg'.1 hg'.1 hfa.1 hga.1 hdiv.1,\n    lhopital_zero_nhds_right hff'.2 hgg'.2 hg'.2 hfa.2 hga.2 hdiv.2⟩\n\n"}
{"name":"HasDerivAt.lhopital_zero_nhds","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf f' g g' : Real → Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) (nhds a)\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) (nhds a)\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) (nhds a)\nhfa : Filter.Tendsto f (nhds a) (nhds 0)\nhga : Filter.Tendsto g (nhds a) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) (nhds a) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l","decl":"/-- **L'Hôpital's rule** for approaching a real, `HasDerivAt` version -/\ntheorem lhopital_zero_nhds (hff' : ∀ᶠ x in 𝓝 a, HasDerivAt f (f' x) x)\n    (hgg' : ∀ᶠ x in 𝓝 a, HasDerivAt g (g' x) x) (hg' : ∀ᶠ x in 𝓝 a, g' x ≠ 0)\n    (hfa : Tendsto f (𝓝 a) (𝓝 0)) (hga : Tendsto g (𝓝 a) (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝 a) l) : Tendsto (fun x => f x / g x) (𝓝[≠] a) l := by\n  apply @lhopital_zero_nhds' _ _ _ f' _ g' <;>\n    (first | apply eventually_nhdsWithin_of_eventually_nhds |\n      apply tendsto_nhdsWithin_of_tendsto_nhds) <;> assumption\n\n"}
{"name":"HasDerivAt.lhopital_zero_atTop","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"l : Filter Real\nf f' g g' : Real → Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) Filter.atTop\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) Filter.atTop\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) Filter.atTop\nhftop : Filter.Tendsto f Filter.atTop (nhds 0)\nhgtop : Filter.Tendsto g Filter.atTop (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) Filter.atTop l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atTop l","decl":"/-- L'Hôpital's rule for approaching +∞, `HasDerivAt` version -/\ntheorem lhopital_zero_atTop (hff' : ∀ᶠ x in atTop, HasDerivAt f (f' x) x)\n    (hgg' : ∀ᶠ x in atTop, HasDerivAt g (g' x) x) (hg' : ∀ᶠ x in atTop, g' x ≠ 0)\n    (hftop : Tendsto f atTop (𝓝 0)) (hgtop : Tendsto g atTop (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atTop l) : Tendsto (fun x => f x / g x) atTop l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with ⟨s₁, hs₁, hff'⟩\n  rcases hgg' with ⟨s₂, hs₂, hgg'⟩\n  rcases hg' with ⟨s₃, hs₃, hg'⟩\n  let s := s₁ ∩ s₂ ∩ s₃\n  have hs : s ∈ atTop := inter_mem (inter_mem hs₁ hs₂) hs₃\n  rw [mem_atTop_sets] at hs\n  rcases hs with ⟨l, hl⟩\n  have hl' : Ioi l ⊆ s := fun x hx => hl x (le_of_lt hx)\n  refine lhopital_zero_atTop_on_Ioi ?_ ?_ (fun x hx => hg' x <| (hl' hx).2) hftop hgtop hdiv <;>\n    intro x hx <;> apply_assumption <;> first | exact (hl' hx).1.1| exact (hl' hx).1.2\n\n"}
{"name":"HasDerivAt.lhopital_zero_atBot","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"l : Filter Real\nf f' g g' : Real → Real\nhff' : Filter.Eventually (fun x => HasDerivAt f (f' x) x) Filter.atBot\nhgg' : Filter.Eventually (fun x => HasDerivAt g (g' x) x) Filter.atBot\nhg' : Filter.Eventually (fun x => Ne (g' x) 0) Filter.atBot\nhfbot : Filter.Tendsto f Filter.atBot (nhds 0)\nhgbot : Filter.Tendsto g Filter.atBot (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (f' x) (g' x)) Filter.atBot l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atBot l","decl":"/-- L'Hôpital's rule for approaching -∞, `HasDerivAt` version -/\ntheorem lhopital_zero_atBot (hff' : ∀ᶠ x in atBot, HasDerivAt f (f' x) x)\n    (hgg' : ∀ᶠ x in atBot, HasDerivAt g (g' x) x) (hg' : ∀ᶠ x in atBot, g' x ≠ 0)\n    (hfbot : Tendsto f atBot (𝓝 0)) (hgbot : Tendsto g atBot (𝓝 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atBot l) : Tendsto (fun x => f x / g x) atBot l := by\n  rw [eventually_iff_exists_mem] at *\n  rcases hff' with ⟨s₁, hs₁, hff'⟩\n  rcases hgg' with ⟨s₂, hs₂, hgg'⟩\n  rcases hg' with ⟨s₃, hs₃, hg'⟩\n  let s := s₁ ∩ s₂ ∩ s₃\n  have hs : s ∈ atBot := inter_mem (inter_mem hs₁ hs₂) hs₃\n  rw [mem_atBot_sets] at hs\n  rcases hs with ⟨l, hl⟩\n  have hl' : Iio l ⊆ s := fun x hx => hl x (le_of_lt hx)\n  refine lhopital_zero_atBot_on_Iio ?_ ?_ (fun x hx => hg' x <| (hl' hx).2) hfbot hgbot hdiv <;>\n    intro x hx <;> apply_assumption <;> first | exact (hl' hx).1.1| exact (hl' hx).1.2\n\n"}
{"name":"deriv.lhopital_zero_nhds_right","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real → Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) (nhdsWithin a (Set.Ioi a))\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) (nhdsWithin a (Set.Ioi a))\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (Set.Ioi a)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Ioi a)) l","decl":"/-- **L'Hôpital's rule** for approaching a real from the right, `deriv` version -/\ntheorem lhopital_zero_nhds_right (hdf : ∀ᶠ x in 𝓝[>] a, DifferentiableAt ℝ f x)\n    (hg' : ∀ᶠ x in 𝓝[>] a, deriv g x ≠ 0) (hfa : Tendsto f (𝓝[>] a) (𝓝 0))\n    (hga : Tendsto g (𝓝[>] a) (𝓝 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (𝓝[>] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[>] a) l := by\n  have hdg : ∀ᶠ x in 𝓝[>] a, DifferentiableAt ℝ g x :=\n    hg'.mp (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))\n  have hdf' : ∀ᶠ x in 𝓝[>] a, HasDerivAt f (deriv f x) x :=\n    hdf.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  have hdg' : ∀ᶠ x in 𝓝[>] a, HasDerivAt g (deriv g x) x :=\n    hdg.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  exact HasDerivAt.lhopital_zero_nhds_right hdf' hdg' hg' hfa hga hdiv\n\n"}
{"name":"deriv.lhopital_zero_nhds_left","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real → Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) (nhdsWithin a (Set.Iio a))\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) (nhdsWithin a (Set.Iio a))\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (Set.Iio a)) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (Set.Iio a)) l","decl":"/-- **L'Hôpital's rule** for approaching a real from the left, `deriv` version -/\ntheorem lhopital_zero_nhds_left (hdf : ∀ᶠ x in 𝓝[<] a, DifferentiableAt ℝ f x)\n    (hg' : ∀ᶠ x in 𝓝[<] a, deriv g x ≠ 0) (hfa : Tendsto f (𝓝[<] a) (𝓝 0))\n    (hga : Tendsto g (𝓝[<] a) (𝓝 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (𝓝[<] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[<] a) l := by\n  have hdg : ∀ᶠ x in 𝓝[<] a, DifferentiableAt ℝ g x :=\n    hg'.mp (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))\n  have hdf' : ∀ᶠ x in 𝓝[<] a, HasDerivAt f (deriv f x) x :=\n    hdf.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  have hdg' : ∀ᶠ x in 𝓝[<] a, HasDerivAt g (deriv g x) x :=\n    hdg.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  exact HasDerivAt.lhopital_zero_nhds_left hdf' hdg' hg' hfa hga hdiv\n\n"}
{"name":"deriv.lhopital_zero_nhds'","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real → Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) (nhdsWithin a (HasCompl.compl (Singleton.singleton a)))\nhfa : Filter.Tendsto f (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhds 0)\nhga : Filter.Tendsto g (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l","decl":"/-- **L'Hôpital's rule** for approaching a real, `deriv` version. This\n  does not require anything about the situation at `a` -/\ntheorem lhopital_zero_nhds' (hdf : ∀ᶠ x in 𝓝[≠] a, DifferentiableAt ℝ f x)\n    (hg' : ∀ᶠ x in 𝓝[≠] a, deriv g x ≠ 0) (hfa : Tendsto f (𝓝[≠] a) (𝓝 0))\n    (hga : Tendsto g (𝓝[≠] a) (𝓝 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (𝓝[≠] a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[≠] a) l := by\n  simp only [← Iio_union_Ioi, nhdsWithin_union, tendsto_sup, eventually_sup] at *\n  exact ⟨lhopital_zero_nhds_left hdf.1 hg'.1 hfa.1 hga.1 hdiv.1,\n    lhopital_zero_nhds_right hdf.2 hg'.2 hfa.2 hga.2 hdiv.2⟩\n\n"}
{"name":"deriv.lhopital_zero_nhds","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"a : Real\nl : Filter Real\nf g : Real → Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) (nhds a)\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) (nhds a)\nhfa : Filter.Tendsto f (nhds a) (nhds 0)\nhga : Filter.Tendsto g (nhds a) (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) (nhds a) l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) l","decl":"/-- **L'Hôpital's rule** for approaching a real, `deriv` version -/\ntheorem lhopital_zero_nhds (hdf : ∀ᶠ x in 𝓝 a, DifferentiableAt ℝ f x)\n    (hg' : ∀ᶠ x in 𝓝 a, deriv g x ≠ 0) (hfa : Tendsto f (𝓝 a) (𝓝 0)) (hga : Tendsto g (𝓝 a) (𝓝 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (𝓝 a) l) :\n    Tendsto (fun x => f x / g x) (𝓝[≠] a) l := by\n  apply lhopital_zero_nhds' <;>\n    (first | apply eventually_nhdsWithin_of_eventually_nhds |\n      apply tendsto_nhdsWithin_of_tendsto_nhds) <;> assumption\n\n"}
{"name":"deriv.lhopital_zero_atTop","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"l : Filter Real\nf g : Real → Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) Filter.atTop\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) Filter.atTop\nhftop : Filter.Tendsto f Filter.atTop (nhds 0)\nhgtop : Filter.Tendsto g Filter.atTop (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) Filter.atTop l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atTop l","decl":"/-- **L'Hôpital's rule** for approaching +∞, `deriv` version -/\ntheorem lhopital_zero_atTop (hdf : ∀ᶠ x : ℝ in atTop, DifferentiableAt ℝ f x)\n    (hg' : ∀ᶠ x : ℝ in atTop, deriv g x ≠ 0) (hftop : Tendsto f atTop (𝓝 0))\n    (hgtop : Tendsto g atTop (𝓝 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atTop l) :\n    Tendsto (fun x => f x / g x) atTop l := by\n  have hdg : ∀ᶠ x in atTop, DifferentiableAt ℝ g x := hg'.mp\n    (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))\n  have hdf' : ∀ᶠ x in atTop, HasDerivAt f (deriv f x) x :=\n    hdf.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  have hdg' : ∀ᶠ x in atTop, HasDerivAt g (deriv g x) x :=\n    hdg.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  exact HasDerivAt.lhopital_zero_atTop hdf' hdg' hg' hftop hgtop hdiv\n\n"}
{"name":"deriv.lhopital_zero_atBot","module":"Mathlib.Analysis.Calculus.LHopital","initialProofState":"l : Filter Real\nf g : Real → Real\nhdf : Filter.Eventually (fun x => DifferentiableAt Real f x) Filter.atBot\nhg' : Filter.Eventually (fun x => Ne (deriv g x) 0) Filter.atBot\nhfbot : Filter.Tendsto f Filter.atBot (nhds 0)\nhgbot : Filter.Tendsto g Filter.atBot (nhds 0)\nhdiv : Filter.Tendsto (fun x => HDiv.hDiv (deriv f x) (deriv g x)) Filter.atBot l\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) Filter.atBot l","decl":"/-- **L'Hôpital's rule** for approaching -∞, `deriv` version -/\ntheorem lhopital_zero_atBot (hdf : ∀ᶠ x : ℝ in atBot, DifferentiableAt ℝ f x)\n    (hg' : ∀ᶠ x : ℝ in atBot, deriv g x ≠ 0) (hfbot : Tendsto f atBot (𝓝 0))\n    (hgbot : Tendsto g atBot (𝓝 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atBot l) :\n    Tendsto (fun x => f x / g x) atBot l := by\n  have hdg : ∀ᶠ x in atBot, DifferentiableAt ℝ g x :=\n    hg'.mp (Eventually.of_forall fun _ hg' =>\n      by_contradiction fun h => hg' (deriv_zero_of_not_differentiableAt h))\n  have hdf' : ∀ᶠ x in atBot, HasDerivAt f (deriv f x) x :=\n    hdf.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  have hdg' : ∀ᶠ x in atBot, HasDerivAt g (deriv g x) x :=\n    hdg.mp (Eventually.of_forall fun _ => DifferentiableAt.hasDerivAt)\n  exact HasDerivAt.lhopital_zero_atBot hdf' hdg' hg' hfbot hgbot hdiv\n\n"}
