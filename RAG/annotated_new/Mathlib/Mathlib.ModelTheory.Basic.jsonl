{"name":"FirstOrder.Language.mk.sizeOf_spec","module":"Mathlib.ModelTheory.Basic","initialProofState":"Functions : Nat → Type u\nRelations : Nat → Type v\n⊢ Eq (SizeOf.sizeOf { Functions := Functions, Relations := Relations }) 1","decl":"/-- A first-order language consists of a type of functions of every natural-number arity and a\n  type of relations of every natural-number arity. -/\n@[nolint checkUnivs]\nstructure Language where\n  /-- For every arity, a `Type*` of functions of that arity -/\n  Functions : ℕ → Type u\n  /-- For every arity, a `Type*` of relations of that arity -/\n  Relations : ℕ → Type v\n\n"}
{"name":"FirstOrder.Language.mk.inj","module":"Mathlib.ModelTheory.Basic","initialProofState":"Functions✝ : Nat → Type u\nRelations✝ : Nat → Type v\nFunctions : Nat → Type u\nRelations : Nat → Type v\nx✝ : Eq { Functions := Functions✝, Relations := Relations✝ } { Functions := Functions, Relations := Relations }\n⊢ And (Eq Functions✝ Functions) (Eq Relations✝ Relations)","decl":"/-- A first-order language consists of a type of functions of every natural-number arity and a\n  type of relations of every natural-number arity. -/\n@[nolint checkUnivs]\nstructure Language where\n  /-- For every arity, a `Type*` of functions of that arity -/\n  Functions : ℕ → Type u\n  /-- For every arity, a `Type*` of relations of that arity -/\n  Relations : ℕ → Type v\n\n"}
{"name":"FirstOrder.Language.mk.injEq","module":"Mathlib.ModelTheory.Basic","initialProofState":"Functions✝ : Nat → Type u\nRelations✝ : Nat → Type v\nFunctions : Nat → Type u\nRelations : Nat → Type v\n⊢ Eq (Eq { Functions := Functions✝, Relations := Relations✝ } { Functions := Functions, Relations := Relations }) (And (Eq Functions✝ Functions) (Eq Relations✝ Relations))","decl":"/-- A first-order language consists of a type of functions of every natural-number arity and a\n  type of relations of every natural-number arity. -/\n@[nolint checkUnivs]\nstructure Language where\n  /-- For every arity, a `Type*` of functions of that arity -/\n  Functions : ℕ → Type u\n  /-- For every arity, a `Type*` of relations of that arity -/\n  Relations : ℕ → Type v\n\n"}
{"name":"FirstOrder.Language.card_eq_card_functions_add_card_relations","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\n⊢ Eq L.card (HAdd.hAdd (Cardinal.sum fun l => Cardinal.lift.{v, u} (Cardinal.mk (L.Functions l))) (Cardinal.sum fun l => Cardinal.lift.{u, v} (Cardinal.mk (L.Relations l))))","decl":"theorem card_eq_card_functions_add_card_relations :\n    L.card =\n      (Cardinal.sum fun l => Cardinal.lift.{v} #(L.Functions l)) +\n        Cardinal.sum fun l => Cardinal.lift.{u} #(L.Relations l) := by\n  simp only [card, mk_sum, mk_sigma, lift_sum]\n\n"}
{"name":"FirstOrder.Language.isRelational_sum","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ninst✝¹ : L.IsRelational\ninst✝ : L'.IsRelational\n⊢ (L.sum L').IsRelational","decl":"instance isRelational_sum [L.IsRelational] [L'.IsRelational] : IsRelational (L.sum L') :=\n  fun _ => instIsEmptySum\n\n"}
{"name":"FirstOrder.Language.isAlgebraic_sum","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ninst✝¹ : L.IsAlgebraic\ninst✝ : L'.IsAlgebraic\n⊢ (L.sum L').IsAlgebraic","decl":"instance isAlgebraic_sum [L.IsAlgebraic] [L'.IsAlgebraic] : IsAlgebraic (L.sum L') :=\n  fun _ => instIsEmptySum\n\n"}
{"name":"FirstOrder.Language.empty_card","module":"Mathlib.ModelTheory.Basic","initialProofState":"⊢ Eq FirstOrder.Language.empty.card 0","decl":"@[simp]\ntheorem empty_card : Language.empty.card = 0 := by simp only [card, mk_sum, mk_sigma, mk_eq_zero,\n  sum_const, mk_eq_aleph0, lift_id', mul_zero, add_zero]\n\n"}
{"name":"FirstOrder.Language.isEmpty_empty","module":"Mathlib.ModelTheory.Basic","initialProofState":"⊢ IsEmpty FirstOrder.Language.empty.Symbols","decl":"instance isEmpty_empty : IsEmpty Language.empty.Symbols := by\n  simp only [Language.Symbols, isEmpty_sum, isEmpty_sigma]\n  exact ⟨fun _ => inferInstance, fun _ => inferInstance⟩\n\n"}
{"name":"FirstOrder.Language.Countable.countable_functions","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nh : Countable L.Symbols\n⊢ Countable (Sigma fun l => L.Functions l)","decl":"instance Countable.countable_functions [h : Countable L.Symbols] : Countable (Σl, L.Functions l) :=\n  @Function.Injective.countable _ _ h _ Sum.inl_injective\n\n"}
{"name":"FirstOrder.Language.card_functions_sum","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ni : Nat\n⊢ Eq (Cardinal.mk ((L.sum L').Functions i)) (HAdd.hAdd (Cardinal.lift.{u', u} (Cardinal.mk (L.Functions i))) (Cardinal.lift.{u, u'} (Cardinal.mk (L'.Functions i))))","decl":"@[simp]\ntheorem card_functions_sum (i : ℕ) :\n    #((L.sum L').Functions i)\n      = (Cardinal.lift.{u'} #(L.Functions i) + Cardinal.lift.{u} #(L'.Functions i) : Cardinal) := by\n  simp [Language.sum]\n\n"}
{"name":"FirstOrder.Language.card_relations_sum","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ni : Nat\n⊢ Eq (Cardinal.mk ((L.sum L').Relations i)) (HAdd.hAdd (Cardinal.lift.{v', v} (Cardinal.mk (L.Relations i))) (Cardinal.lift.{v, v'} (Cardinal.mk (L'.Relations i))))","decl":"@[simp]\ntheorem card_relations_sum (i : ℕ) :\n    #((L.sum L').Relations i) =\n      Cardinal.lift.{v'} #(L.Relations i) + Cardinal.lift.{v} #(L'.Relations i) := by\n  simp [Language.sum]\n\n"}
{"name":"FirstOrder.Language.card_sum","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\n⊢ Eq (L.sum L').card (HAdd.hAdd (Cardinal.lift.{max u' v', max u v} L.card) (Cardinal.lift.{max u v, max u' v'} L'.card))","decl":"theorem card_sum :\n    (L.sum L').card = Cardinal.lift.{max u' v'} L.card + Cardinal.lift.{max u v} L'.card := by\n  simp only [card, mk_sum, mk_sigma, card_functions_sum, sum_add_distrib', lift_add, lift_sum,\n    lift_lift, card_relations_sum, add_assoc,\n    add_comm (Cardinal.sum fun i => (#(L'.Functions i)).lift)]\n\n"}
{"name":"FirstOrder.Language.Structure.ext","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nx y : L.Structure M\nfunMap : Eq (@FirstOrder.Language.Structure.funMap L M x) (@FirstOrder.Language.Structure.funMap L M y)\nRelMap : Eq (@FirstOrder.Language.Structure.RelMap L M x) (@FirstOrder.Language.Structure.RelMap L M y)\n⊢ Eq x y","decl":"/-- A first-order structure on a type `M` consists of interpretations of all the symbols in a given\n  language. Each function of arity `n` is interpreted as a function sending tuples of length `n`\n  (modeled as `(Fin n → M)`) to `M`, and a relation of arity `n` is a function from tuples of length\n  `n` to `Prop`. -/\n@[ext]\nclass Structure where\n  /-- Interpretation of the function symbols -/\n  funMap : ∀ {n}, L.Functions n → (Fin n → M) → M := by\n    exact fun {n} => isEmptyElim\n  /-- Interpretation of the relation symbols -/\n  RelMap : ∀ {n}, L.Relations n → (Fin n → M) → Prop := by\n    exact fun {n} => isEmptyElim\n\n"}
{"name":"FirstOrder.Language.Structure.ext_iff","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nx y : L.Structure M\n⊢ Iff (Eq x y) (And (Eq (@FirstOrder.Language.Structure.funMap L M x) (@FirstOrder.Language.Structure.funMap L M y)) (Eq (@FirstOrder.Language.Structure.RelMap L M x) (@FirstOrder.Language.Structure.RelMap L M y)))","decl":"/-- A first-order structure on a type `M` consists of interpretations of all the symbols in a given\n  language. Each function of arity `n` is interpreted as a function sending tuples of length `n`\n  (modeled as `(Fin n → M)`) to `M`, and a relation of arity `n` is a function from tuples of length\n  `n` to `Prop`. -/\n@[ext]\nclass Structure where\n  /-- Interpretation of the function symbols -/\n  funMap : ∀ {n}, L.Functions n → (Fin n → M) → M := by\n    exact fun {n} => isEmptyElim\n  /-- Interpretation of the relation symbols -/\n  RelMap : ∀ {n}, L.Relations n → (Fin n → M) → Prop := by\n    exact fun {n} => isEmptyElim\n\n"}
{"name":"FirstOrder.Language.Hom.mk.sizeOf_spec","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoFun : M → N\nmap_fun' : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toFun x))) _auto✝\nmap_rel' : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), FirstOrder.Language.Structure.RelMap r x → FirstOrder.Language.Structure.RelMap r (Function.comp toFun x)) _auto✝\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_fun' := map_fun', map_rel' := map_rel' }) 1","decl":"/-- A homomorphism between first-order structures is a function that commutes with the\n  interpretations of functions and maps tuples in one structure where a given relation is true to\n  tuples in the second structure where that relation is still true. -/\nstructure Hom where\n  /-- The underlying function of a homomorphism of structures -/\n  toFun : M → N\n  /-- The homomorphism commutes with the interpretations of the function symbols -/\n  -- Porting note:\n  -- The autoparam here used to be `obviously`. We would like to replace it with `aesop`\n  -- but that isn't currently sufficient.\n  -- See https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Aesop.20and.20cases\n  -- If that can be improved, we should change this to `by aesop` and remove the proofs below.\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    intros; trivial\n  /-- The homomorphism sends related elements to related elements -/\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r x → RelMap r (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Hom.map_fun'","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nself : L.Hom M N\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (self.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp self.toFun x))","decl":"/-- A homomorphism between first-order structures is a function that commutes with the\n  interpretations of functions and maps tuples in one structure where a given relation is true to\n  tuples in the second structure where that relation is still true. -/\nstructure Hom where\n  /-- The underlying function of a homomorphism of structures -/\n  toFun : M → N\n  /-- The homomorphism commutes with the interpretations of the function symbols -/\n  -- Porting note:\n  -- The autoparam here used to be `obviously`. We would like to replace it with `aesop`\n  -- but that isn't currently sufficient.\n  -- See https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Aesop.20and.20cases\n  -- If that can be improved, we should change this to `by aesop` and remove the proofs below.\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    intros; trivial\n  /-- The homomorphism sends related elements to related elements -/\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r x → RelMap r (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Hom.map_rel'","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nself : L.Hom M N\nn : Nat\nr : L.Relations n\nx : Fin n → M\na✝ : FirstOrder.Language.Structure.RelMap r x\n⊢ FirstOrder.Language.Structure.RelMap r (Function.comp self.toFun x)","decl":"/-- A homomorphism between first-order structures is a function that commutes with the\n  interpretations of functions and maps tuples in one structure where a given relation is true to\n  tuples in the second structure where that relation is still true. -/\nstructure Hom where\n  /-- The underlying function of a homomorphism of structures -/\n  toFun : M → N\n  /-- The homomorphism commutes with the interpretations of the function symbols -/\n  -- Porting note:\n  -- The autoparam here used to be `obviously`. We would like to replace it with `aesop`\n  -- but that isn't currently sufficient.\n  -- See https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Aesop.20and.20cases\n  -- If that can be improved, we should change this to `by aesop` and remove the proofs below.\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    intros; trivial\n  /-- The homomorphism sends related elements to related elements -/\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r x → RelMap r (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Hom.mk.inj","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ntoFun✝ : M → N\nmap_fun'✝ : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toFun✝ (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toFun✝ x))) _auto✝\nmap_rel'✝ : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), FirstOrder.Language.Structure.RelMap r x → FirstOrder.Language.Structure.RelMap r (Function.comp toFun✝ x)) _auto✝\ntoFun : M → N\nmap_fun' : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toFun x))) _auto✝\nmap_rel' : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), FirstOrder.Language.Structure.RelMap r x → FirstOrder.Language.Structure.RelMap r (Function.comp toFun x)) _auto✝\nx✝ : Eq { toFun := toFun✝, map_fun' := map_fun'✝, map_rel' := map_rel'✝ } { toFun := toFun, map_fun' := map_fun', map_rel' := map_rel' }\n⊢ Eq toFun✝ toFun","decl":"/-- A homomorphism between first-order structures is a function that commutes with the\n  interpretations of functions and maps tuples in one structure where a given relation is true to\n  tuples in the second structure where that relation is still true. -/\nstructure Hom where\n  /-- The underlying function of a homomorphism of structures -/\n  toFun : M → N\n  /-- The homomorphism commutes with the interpretations of the function symbols -/\n  -- Porting note:\n  -- The autoparam here used to be `obviously`. We would like to replace it with `aesop`\n  -- but that isn't currently sufficient.\n  -- See https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Aesop.20and.20cases\n  -- If that can be improved, we should change this to `by aesop` and remove the proofs below.\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    intros; trivial\n  /-- The homomorphism sends related elements to related elements -/\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r x → RelMap r (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Hom.mk.injEq","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ntoFun✝ : M → N\nmap_fun'✝ : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toFun✝ (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toFun✝ x))) _auto✝\nmap_rel'✝ : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), FirstOrder.Language.Structure.RelMap r x → FirstOrder.Language.Structure.RelMap r (Function.comp toFun✝ x)) _auto✝\ntoFun : M → N\nmap_fun' : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toFun x))) _auto✝\nmap_rel' : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), FirstOrder.Language.Structure.RelMap r x → FirstOrder.Language.Structure.RelMap r (Function.comp toFun x)) _auto✝\n⊢ Eq (Eq { toFun := toFun✝, map_fun' := map_fun'✝, map_rel' := map_rel'✝ } { toFun := toFun, map_fun' := map_fun', map_rel' := map_rel' }) (Eq toFun✝ toFun)","decl":"/-- A homomorphism between first-order structures is a function that commutes with the\n  interpretations of functions and maps tuples in one structure where a given relation is true to\n  tuples in the second structure where that relation is still true. -/\nstructure Hom where\n  /-- The underlying function of a homomorphism of structures -/\n  toFun : M → N\n  /-- The homomorphism commutes with the interpretations of the function symbols -/\n  -- Porting note:\n  -- The autoparam here used to be `obviously`. We would like to replace it with `aesop`\n  -- but that isn't currently sufficient.\n  -- See https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Aesop.20and.20cases\n  -- If that can be improved, we should change this to `by aesop` and remove the proofs below.\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    intros; trivial\n  /-- The homomorphism sends related elements to related elements -/\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r x → RelMap r (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Embedding.map_rel'","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nself : L.Embedding M N\nn : Nat\nr : L.Relations n\nx : Fin n → M\n⊢ Iff (FirstOrder.Language.Structure.RelMap r (Function.comp self.toFun x)) (FirstOrder.Language.Structure.RelMap r x)","decl":"/-- An embedding of first-order structures is an embedding that commutes with the\n  interpretations of functions and relations. -/\nstructure Embedding extends M ↪ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Embedding.map_fun'","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nself : L.Embedding M N\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (self.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp self.toFun x))","decl":"/-- An embedding of first-order structures is an embedding that commutes with the\n  interpretations of functions and relations. -/\nstructure Embedding extends M ↪ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Embedding.mk.inj","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ntoEmbedding✝ : Function.Embedding M N\nmap_fun'✝ : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEmbedding✝.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEmbedding✝.toFun x))) _auto✝\nmap_rel'✝ : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEmbedding✝.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\ntoEmbedding : Function.Embedding M N\nmap_fun' : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEmbedding.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEmbedding.toFun x))) _auto✝\nmap_rel' : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEmbedding.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\nx✝ : Eq { toEmbedding := toEmbedding✝, map_fun' := map_fun'✝, map_rel' := map_rel'✝ } { toEmbedding := toEmbedding, map_fun' := map_fun', map_rel' := map_rel' }\n⊢ Eq toEmbedding✝ toEmbedding","decl":"/-- An embedding of first-order structures is an embedding that commutes with the\n  interpretations of functions and relations. -/\nstructure Embedding extends M ↪ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Embedding.mk.sizeOf_spec","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoEmbedding : Function.Embedding M N\nmap_fun' : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEmbedding.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEmbedding.toFun x))) _auto✝\nmap_rel' : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEmbedding.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\n⊢ Eq (SizeOf.sizeOf { toEmbedding := toEmbedding, map_fun' := map_fun', map_rel' := map_rel' }) (HAdd.hAdd 1 (SizeOf.sizeOf toEmbedding))","decl":"/-- An embedding of first-order structures is an embedding that commutes with the\n  interpretations of functions and relations. -/\nstructure Embedding extends M ↪ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Embedding.mk.injEq","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ntoEmbedding✝ : Function.Embedding M N\nmap_fun'✝ : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEmbedding✝.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEmbedding✝.toFun x))) _auto✝\nmap_rel'✝ : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEmbedding✝.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\ntoEmbedding : Function.Embedding M N\nmap_fun' : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEmbedding.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEmbedding.toFun x))) _auto✝\nmap_rel' : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEmbedding.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\n⊢ Eq (Eq { toEmbedding := toEmbedding✝, map_fun' := map_fun'✝, map_rel' := map_rel'✝ } { toEmbedding := toEmbedding, map_fun' := map_fun', map_rel' := map_rel' }) (Eq toEmbedding✝ toEmbedding)","decl":"/-- An embedding of first-order structures is an embedding that commutes with the\n  interpretations of functions and relations. -/\nstructure Embedding extends M ↪ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Equiv.map_fun'","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nself : L.Equiv M N\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (self.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp self.toFun x))","decl":"/-- An equivalence of first-order structures is an equivalence that commutes with the\n  interpretations of functions and relations. -/\nstructure Equiv extends M ≃ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Equiv.mk.injEq","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ntoEquiv✝ : Equiv M N\nmap_fun'✝ : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEquiv✝.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEquiv✝.toFun x))) _auto✝\nmap_rel'✝ : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEquiv✝.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\ntoEquiv : Equiv M N\nmap_fun' : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEquiv.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEquiv.toFun x))) _auto✝\nmap_rel' : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEquiv.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\n⊢ Eq (Eq { toEquiv := toEquiv✝, map_fun' := map_fun'✝, map_rel' := map_rel'✝ } { toEquiv := toEquiv, map_fun' := map_fun', map_rel' := map_rel' }) (Eq toEquiv✝ toEquiv)","decl":"/-- An equivalence of first-order structures is an equivalence that commutes with the\n  interpretations of functions and relations. -/\nstructure Equiv extends M ≃ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Equiv.mk.inj","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ntoEquiv✝ : Equiv M N\nmap_fun'✝ : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEquiv✝.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEquiv✝.toFun x))) _auto✝\nmap_rel'✝ : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEquiv✝.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\ntoEquiv : Equiv M N\nmap_fun' : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEquiv.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEquiv.toFun x))) _auto✝\nmap_rel' : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEquiv.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\nx✝ : Eq { toEquiv := toEquiv✝, map_fun' := map_fun'✝, map_rel' := map_rel'✝ } { toEquiv := toEquiv, map_fun' := map_fun', map_rel' := map_rel' }\n⊢ Eq toEquiv✝ toEquiv","decl":"/-- An equivalence of first-order structures is an equivalence that commutes with the\n  interpretations of functions and relations. -/\nstructure Equiv extends M ≃ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Equiv.map_rel'","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nself : L.Equiv M N\nn : Nat\nr : L.Relations n\nx : Fin n → M\n⊢ Iff (FirstOrder.Language.Structure.RelMap r (Function.comp self.toFun x)) (FirstOrder.Language.Structure.RelMap r x)","decl":"/-- An equivalence of first-order structures is an equivalence that commutes with the\n  interpretations of functions and relations. -/\nstructure Equiv extends M ≃ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.Equiv.mk.sizeOf_spec","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoEquiv : Equiv M N\nmap_fun' : autoParam (∀ {n : Nat} (f : L.Functions n) (x : Fin n → M), Eq (toEquiv.toFun (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp toEquiv.toFun x))) _auto✝\nmap_rel' : autoParam (∀ {n : Nat} (r : L.Relations n) (x : Fin n → M), Iff (FirstOrder.Language.Structure.RelMap r (Function.comp toEquiv.toFun x)) (FirstOrder.Language.Structure.RelMap r x)) _auto✝\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, map_fun' := map_fun', map_rel' := map_rel' }) (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv))","decl":"/-- An equivalence of first-order structures is an equivalence that commutes with the\n  interpretations of functions and relations. -/\nstructure Equiv extends M ≃ N where\n  map_fun' : ∀ {n} (f : L.Functions n) (x), toFun (funMap f x) = funMap f (toFun ∘ x) := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n  map_rel' : ∀ {n} (r : L.Relations n) (x), RelMap r (toFun ∘ x) ↔ RelMap r x := by\n    -- Porting note: see porting note on `Hom.map_fun'`\n    intros; trivial\n\n"}
{"name":"FirstOrder.Language.funMap_eq_coe_constants","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nc : L.Constants\nx : Fin 0 → M\n⊢ Eq (FirstOrder.Language.Structure.funMap c x) ↑c","decl":"theorem funMap_eq_coe_constants {c : L.Constants} {x : Fin 0 → M} : funMap c x = c :=\n  congr rfl (funext finZeroElim)\n\n"}
{"name":"FirstOrder.Language.nonempty_of_nonempty_constants","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nh : Nonempty L.Constants\n⊢ Nonempty M","decl":"/-- Given a language with a nonempty type of constants, any structure will be nonempty. This cannot\n  be a global instance, because `L` becomes a metavariable. -/\ntheorem nonempty_of_nonempty_constants [h : Nonempty L.Constants] : Nonempty M :=\n  h.map (↑)\n\n"}
{"name":"FirstOrder.Language.HomClass.map_fun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : outParam FirstOrder.Language\nF : Type u_3\nM : outParam (Type u_4)\nN : outParam (Type u_5)\ninst✝² : FunLike F M N\ninst✝¹ : FirstOrder.Language.Structure L M\ninst✝ : FirstOrder.Language.Structure L N\nself : FirstOrder.Language.HomClass L F M N\nφ : F\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (φ (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp (⇑φ) x))","decl":"/-- `HomClass L F M N` states that `F` is a type of `L`-homomorphisms. You should extend this\n  typeclass when you extend `FirstOrder.Language.Hom`. -/\nclass HomClass (L : outParam Language) (F : Type*) (M N : outParam Type*)\n  [FunLike F M N] [L.Structure M] [L.Structure N] : Prop where\n  map_fun : ∀ (φ : F) {n} (f : L.Functions n) (x), φ (funMap f x) = funMap f (φ ∘ x)\n  map_rel : ∀ (φ : F) {n} (r : L.Relations n) (x), RelMap r x → RelMap r (φ ∘ x)\n\n"}
{"name":"FirstOrder.Language.HomClass.map_rel","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : outParam FirstOrder.Language\nF : Type u_3\nM : outParam (Type u_4)\nN : outParam (Type u_5)\ninst✝² : FunLike F M N\ninst✝¹ : FirstOrder.Language.Structure L M\ninst✝ : FirstOrder.Language.Structure L N\nself : FirstOrder.Language.HomClass L F M N\nφ : F\nn : Nat\nr : L.Relations n\nx : Fin n → M\na✝ : FirstOrder.Language.Structure.RelMap r x\n⊢ FirstOrder.Language.Structure.RelMap r (Function.comp (⇑φ) x)","decl":"/-- `HomClass L F M N` states that `F` is a type of `L`-homomorphisms. You should extend this\n  typeclass when you extend `FirstOrder.Language.Hom`. -/\nclass HomClass (L : outParam Language) (F : Type*) (M N : outParam Type*)\n  [FunLike F M N] [L.Structure M] [L.Structure N] : Prop where\n  map_fun : ∀ (φ : F) {n} (f : L.Functions n) (x), φ (funMap f x) = funMap f (φ ∘ x)\n  map_rel : ∀ (φ : F) {n} (r : L.Relations n) (x), RelMap r x → RelMap r (φ ∘ x)\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.map_fun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : outParam FirstOrder.Language\nF : Type u_3\nM : outParam (Type u_4)\nN : outParam (Type u_5)\ninst✝² : FunLike F M N\ninst✝¹ : FirstOrder.Language.Structure L M\ninst✝ : FirstOrder.Language.Structure L N\nself : FirstOrder.Language.StrongHomClass L F M N\nφ : F\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (φ (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp (⇑φ) x))","decl":"/-- `StrongHomClass L F M N` states that `F` is a type of `L`-homomorphisms which preserve\n  relations in both directions. -/\nclass StrongHomClass (L : outParam Language) (F : Type*) (M N : outParam Type*)\n  [FunLike F M N] [L.Structure M] [L.Structure N] : Prop where\n  map_fun : ∀ (φ : F) {n} (f : L.Functions n) (x), φ (funMap f x) = funMap f (φ ∘ x)\n  map_rel : ∀ (φ : F) {n} (r : L.Relations n) (x), RelMap r (φ ∘ x) ↔ RelMap r x\n\n-- Porting note: using implicit brackets for `Structure` arguments\n"}
{"name":"FirstOrder.Language.StrongHomClass.map_rel","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : outParam FirstOrder.Language\nF : Type u_3\nM : outParam (Type u_4)\nN : outParam (Type u_5)\ninst✝² : FunLike F M N\ninst✝¹ : FirstOrder.Language.Structure L M\ninst✝ : FirstOrder.Language.Structure L N\nself : FirstOrder.Language.StrongHomClass L F M N\nφ : F\nn : Nat\nr : L.Relations n\nx : Fin n → M\n⊢ Iff (FirstOrder.Language.Structure.RelMap r (Function.comp (⇑φ) x)) (FirstOrder.Language.Structure.RelMap r x)","decl":"/-- `StrongHomClass L F M N` states that `F` is a type of `L`-homomorphisms which preserve\n  relations in both directions. -/\nclass StrongHomClass (L : outParam Language) (F : Type*) (M N : outParam Type*)\n  [FunLike F M N] [L.Structure M] [L.Structure N] : Prop where\n  map_fun : ∀ (φ : F) {n} (f : L.Functions n) (x), φ (funMap f x) = funMap f (φ ∘ x)\n  map_rel : ∀ (φ : F) {n} (r : L.Relations n) (x), RelMap r (φ ∘ x) ↔ RelMap r x\n\n-- Porting note: using implicit brackets for `Structure` arguments\n"}
{"name":"FirstOrder.Language.StrongHomClass.homClass","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\nF : Type u_3\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : FunLike F M N\ninst✝ : L.StrongHomClass F M N\n⊢ L.HomClass F M N","decl":"instance (priority := 100) StrongHomClass.homClass {F : Type*} [L.Structure M]\n    [L.Structure N] [FunLike F M N] [StrongHomClass L F M N] : HomClass L F M N where\n  map_fun := StrongHomClass.map_fun\n  map_rel φ _ R x := (StrongHomClass.map_rel φ R x).2\n\n"}
{"name":"FirstOrder.Language.HomClass.strongHomClassOfIsAlgebraic","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\ninst✝⁴ : L.IsAlgebraic\nF : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : FunLike F M N\ninst✝ : L.HomClass F M N\n⊢ L.StrongHomClass F M N","decl":"/-- Not an instance to avoid a loop. -/\ntheorem HomClass.strongHomClassOfIsAlgebraic [L.IsAlgebraic] {F M N} [L.Structure M] [L.Structure N]\n    [FunLike F M N] [HomClass L F M N] : StrongHomClass L F M N where\n  map_fun := HomClass.map_fun\n  map_rel _ _ := isEmptyElim\n\n"}
{"name":"FirstOrder.Language.HomClass.map_constants","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nF : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : FunLike F M N\ninst✝ : L.HomClass F M N\nφ : F\nc : L.Constants\n⊢ Eq (φ ↑c) ↑c","decl":"theorem HomClass.map_constants {F M N} [L.Structure M] [L.Structure N] [FunLike F M N]\n    [HomClass L F M N] (φ : F) (c : L.Constants) : φ c = c :=\n  (HomClass.map_fun φ c default).trans (congr rfl (funext default))\n\n"}
{"name":"FirstOrder.Language.Hom.homClass","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ L.HomClass (L.Hom M N) M N","decl":"instance homClass : HomClass L (M →[L] N) M N where\n  map_fun := map_fun'\n  map_rel := map_rel'\n\n"}
{"name":"FirstOrder.Language.Hom.instStrongHomClassOfIsAlgebraic","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.IsAlgebraic\n⊢ L.StrongHomClass (L.Hom M N) M N","decl":"instance [L.IsAlgebraic] : StrongHomClass L (M →[L] N) M N :=\n  HomClass.strongHomClassOfIsAlgebraic\n\n"}
{"name":"FirstOrder.Language.Hom.toFun_eq_coe","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe {f : M →[L] N} : f.toFun = (f : M → N) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Hom.ext","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.Hom M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : M →[L] N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"FirstOrder.Language.Hom.ext_iff","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.Hom M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : M →[L] N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"FirstOrder.Language.Hom.map_fun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Hom M N\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (φ (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp (⇑φ) x))","decl":"@[simp]\ntheorem map_fun (φ : M →[L] N) {n : ℕ} (f : L.Functions n) (x : Fin n → M) :\n    φ (funMap f x) = funMap f (φ ∘ x) :=\n  HomClass.map_fun φ f x\n\n"}
{"name":"FirstOrder.Language.Hom.map_constants","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Hom M N\nc : L.Constants\n⊢ Eq (φ ↑c) ↑c","decl":"@[simp]\ntheorem map_constants (φ : M →[L] N) (c : L.Constants) : φ c = c :=\n  HomClass.map_constants φ c\n\n"}
{"name":"FirstOrder.Language.Hom.map_rel","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Hom M N\nn : Nat\nr : L.Relations n\nx : Fin n → M\na✝ : FirstOrder.Language.Structure.RelMap r x\n⊢ FirstOrder.Language.Structure.RelMap r (Function.comp (⇑φ) x)","decl":"@[simp]\ntheorem map_rel (φ : M →[L] N) {n : ℕ} (r : L.Relations n) (x : Fin n → M) :\n    RelMap r x → RelMap r (φ ∘ x) :=\n  HomClass.map_rel φ r x\n\n"}
{"name":"FirstOrder.Language.Hom.id_apply","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nx : M\n⊢ Eq ((FirstOrder.Language.Hom.id L M) x) x","decl":"@[simp]\ntheorem id_apply (x : M) : id L M x = x :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Hom.comp_apply","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\ng : L.Hom N P\nf : L.Hom M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[simp]\ntheorem comp_apply (g : N →[L] P) (f : M →[L] N) (x : M) : g.comp f x = g (f x) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Hom.comp_assoc","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\nP : Type u_1\ninst✝¹ : L.Structure P\nQ : Type u_2\ninst✝ : L.Structure Q\nf : L.Hom M N\ng : L.Hom N P\nh : L.Hom P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"/-- Composition of first-order homomorphisms is associative. -/\ntheorem comp_assoc (f : M →[L] N) (g : N →[L] P) (h : P →[L] Q) :\n    (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Hom.comp_id","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Eq (f.comp (FirstOrder.Language.Hom.id L M)) f","decl":"@[simp]\ntheorem comp_id (f : M →[L] N) : f.comp (id L M) = f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Hom.id_comp","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Hom M N\n⊢ Eq ((FirstOrder.Language.Hom.id L N).comp f) f","decl":"@[simp]\ntheorem id_comp (f : M →[L] N) : (id L N).comp f = f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.HomClass.toHom_toFun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nF : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : FunLike F M N\ninst✝ : L.HomClass F M N\na✝ : F\na : M\n⊢ Eq ((FirstOrder.Language.HomClass.toHom a✝) a) (a✝ a)","decl":"/-- Any element of a `HomClass` can be realized as a first_order homomorphism. -/\n@[simps] def HomClass.toHom {F M N} [L.Structure M] [L.Structure N] [FunLike F M N]\n    [HomClass L F M N] : F → M →[L] N := fun φ =>\n  ⟨φ, HomClass.map_fun φ, HomClass.map_rel φ⟩\n\n"}
{"name":"FirstOrder.Language.Embedding.embeddingLike","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ EmbeddingLike (L.Embedding M N) M N","decl":"instance embeddingLike : EmbeddingLike (M ↪[L] N) M N where\n  injective' f := f.toEmbedding.injective\n\n"}
{"name":"FirstOrder.Language.Embedding.strongHomClass","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ L.StrongHomClass (L.Embedding M N) M N","decl":"instance strongHomClass : StrongHomClass L (M ↪[L] N) M N where\n  map_fun := map_fun'\n  map_rel := map_rel'\n\n"}
{"name":"FirstOrder.Language.Embedding.map_fun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Embedding M N\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (φ (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp (⇑φ) x))","decl":"@[simp]\ntheorem map_fun (φ : M ↪[L] N) {n : ℕ} (f : L.Functions n) (x : Fin n → M) :\n    φ (funMap f x) = funMap f (φ ∘ x) :=\n  HomClass.map_fun φ f x\n\n"}
{"name":"FirstOrder.Language.Embedding.map_constants","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Embedding M N\nc : L.Constants\n⊢ Eq (φ ↑c) ↑c","decl":"@[simp]\ntheorem map_constants (φ : M ↪[L] N) (c : L.Constants) : φ c = c :=\n  HomClass.map_constants φ c\n\n"}
{"name":"FirstOrder.Language.Embedding.map_rel","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Embedding M N\nn : Nat\nr : L.Relations n\nx : Fin n → M\n⊢ Iff (FirstOrder.Language.Structure.RelMap r (Function.comp (⇑φ) x)) (FirstOrder.Language.Structure.RelMap r x)","decl":"@[simp]\ntheorem map_rel (φ : M ↪[L] N) {n : ℕ} (r : L.Relations n) (x : Fin n → M) :\n    RelMap r (φ ∘ x) ↔ RelMap r x :=\n  StrongHomClass.map_rel φ r x\n\n"}
{"name":"FirstOrder.Language.Embedding.coe_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\n⊢ Eq ⇑f.toHom ⇑f","decl":"@[simp]\ntheorem coe_toHom {f : M ↪[L] N} : (f.toHom : M → N) = f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.coe_injective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (M ↪[L] N) (M → N) (↑)\n  | f, g, h => by\n    cases f\n    cases g\n    congr\n    ext x\n    exact funext_iff.1 h x\n\n"}
{"name":"FirstOrder.Language.Embedding.ext","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.Embedding M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : M ↪[L] N⦄ (h : ∀ x, f x = g x) : f = g :=\n  coe_injective (funext h)\n\n"}
{"name":"FirstOrder.Language.Embedding.ext_iff","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.Embedding M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : M ↪[L] N⦄ (h : ∀ x, f x = g x) : f = g :=\n  coe_injective (funext h)\n\n"}
{"name":"FirstOrder.Language.Embedding.toHom_injective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Function.Injective fun x => x.toHom","decl":"theorem toHom_injective : @Function.Injective (M ↪[L] N) (M →[L] N) (·.toHom) := by\n  intro f f' h\n  ext\n  exact congr_fun (congr_arg (↑) h) _\n\n"}
{"name":"FirstOrder.Language.Embedding.toHom_inj","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.Embedding M N\n⊢ Iff (Eq f.toHom g.toHom) (Eq f g)","decl":"@[simp]\ntheorem toHom_inj {f g : M ↪[L] N} : f.toHom = g.toHom ↔ f = g :=\n  ⟨fun h ↦ toHom_injective h, fun h ↦ congr_arg (·.toHom) h⟩\n\n"}
{"name":"FirstOrder.Language.Embedding.injective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\n⊢ Function.Injective ⇑f","decl":"theorem injective (f : M ↪[L] N) : Function.Injective f :=\n  f.toEmbedding.injective\n\n"}
{"name":"FirstOrder.Language.Embedding.ofInjective_toFun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.IsAlgebraic\nf : L.Hom M N\nhf : Function.Injective ⇑f\na✝ : M\n⊢ Eq ((FirstOrder.Language.Embedding.ofInjective hf) a✝) (f a✝)","decl":"/-- In an algebraic language, any injective homomorphism is an embedding. -/\n@[simps!]\ndef ofInjective [L.IsAlgebraic] {f : M →[L] N} (hf : Function.Injective f) : M ↪[L] N :=\n  { f with\n    inj' := hf\n    map_rel' := fun {_} r x => StrongHomClass.map_rel f r x }\n\n"}
{"name":"FirstOrder.Language.Embedding.coeFn_ofInjective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.IsAlgebraic\nf : L.Hom M N\nhf : Function.Injective ⇑f\n⊢ Eq ⇑(FirstOrder.Language.Embedding.ofInjective hf) ⇑f","decl":"@[simp]\ntheorem coeFn_ofInjective [L.IsAlgebraic] {f : M →[L] N} (hf : Function.Injective f) :\n    (ofInjective hf : M → N) = f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.ofInjective_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\ninst✝ : L.IsAlgebraic\nf : L.Hom M N\nhf : Function.Injective ⇑f\n⊢ Eq (FirstOrder.Language.Embedding.ofInjective hf).toHom f","decl":"@[simp]\ntheorem ofInjective_toHom [L.IsAlgebraic] {f : M →[L] N} (hf : Function.Injective f) :\n    (ofInjective hf).toHom = f := by\n  ext; simp\n\n"}
{"name":"FirstOrder.Language.Embedding.refl_apply","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nx : M\n⊢ Eq ((FirstOrder.Language.Embedding.refl L M) x) x","decl":"@[simp]\ntheorem refl_apply (x : M) : refl L M x = x :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.comp_apply","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\ng : L.Embedding N P\nf : L.Embedding M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[simp]\ntheorem comp_apply (g : N ↪[L] P) (f : M ↪[L] N) (x : M) : g.comp f x = g (f x) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.comp_assoc","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\nP : Type u_1\ninst✝¹ : L.Structure P\nQ : Type u_2\ninst✝ : L.Structure Q\nf : L.Embedding M N\ng : L.Embedding N P\nh : L.Embedding P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"/-- Composition of first-order embeddings is associative. -/\ntheorem comp_assoc (f : M ↪[L] N) (g : N ↪[L] P) (h : P ↪[L] Q) :\n    (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.comp_injective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nh : L.Embedding N P\n⊢ Function.Injective h.comp","decl":"theorem comp_injective (h : N ↪[L] P) :\n    Function.Injective (h.comp : (M ↪[L] N) →  (M ↪[L] P)) := by\n  intro f g hfg\n  ext x; exact h.injective (DFunLike.congr_fun hfg x)\n\n"}
{"name":"FirstOrder.Language.Embedding.comp_inj","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nh : L.Embedding N P\nf g : L.Embedding M N\n⊢ Iff (Eq (h.comp f) (h.comp g)) (Eq f g)","decl":"@[simp]\ntheorem comp_inj (h : N ↪[L] P) (f g : M ↪[L] N) : h.comp f = h.comp g ↔ f = g :=\n  ⟨fun eq ↦ h.comp_injective eq, congr_arg h.comp⟩\n\n"}
{"name":"FirstOrder.Language.Embedding.toHom_comp_injective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nh : L.Embedding N P\n⊢ Function.Injective h.toHom.comp","decl":"theorem toHom_comp_injective (h : N ↪[L] P) :\n    Function.Injective (h.toHom.comp : (M →[L] N) →  (M →[L] P)) := by\n  intro f g hfg\n  ext x; exact h.injective (DFunLike.congr_fun hfg x)\n\n"}
{"name":"FirstOrder.Language.Embedding.toHom_comp_inj","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nh : L.Embedding N P\nf g : L.Hom M N\n⊢ Iff (Eq (h.toHom.comp f) (h.toHom.comp g)) (Eq f g)","decl":"@[simp]\ntheorem toHom_comp_inj (h : N ↪[L] P) (f g : M →[L] N) : h.toHom.comp f = h.toHom.comp g ↔ f = g :=\n  ⟨fun eq ↦ h.toHom_comp_injective eq, congr_arg h.toHom.comp⟩\n\n"}
{"name":"FirstOrder.Language.Embedding.comp_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nhnp : L.Embedding N P\nhmn : L.Embedding M N\n⊢ Eq (hnp.comp hmn).toHom (hnp.toHom.comp hmn.toHom)","decl":"@[simp]\ntheorem comp_toHom (hnp : N ↪[L] P) (hmn : M ↪[L] N) :\n    (hnp.comp hmn).toHom = hnp.toHom.comp hmn.toHom :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.comp_refl","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\n⊢ Eq (f.comp (FirstOrder.Language.Embedding.refl L M)) f","decl":"@[simp]\ntheorem comp_refl (f : M ↪[L] N) : f.comp (refl L M) = f := DFunLike.coe_injective rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.refl_comp","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Embedding M N\n⊢ Eq ((FirstOrder.Language.Embedding.refl L N).comp f) f","decl":"@[simp]\ntheorem refl_comp (f : M ↪[L] N) : (refl L N).comp f = f := DFunLike.coe_injective rfl\n\n"}
{"name":"FirstOrder.Language.Embedding.refl_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Eq (FirstOrder.Language.Embedding.refl L M).toHom (FirstOrder.Language.Hom.id L M)","decl":"@[simp]\ntheorem refl_toHom : (refl L M).toHom = Hom.id L M :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.toEmbedding_toFun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nF : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁴ : L.Structure M\ninst✝³ : L.Structure N\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : L.StrongHomClass F M N\na✝ : F\na : M\n⊢ Eq ((FirstOrder.Language.StrongHomClass.toEmbedding a✝) a) (a✝ a)","decl":"/-- Any element of an injective `StrongHomClass` can be realized as a first_order embedding. -/\n@[simps] def StrongHomClass.toEmbedding {F M N} [L.Structure M] [L.Structure N] [FunLike F M N]\n    [EmbeddingLike F M N] [StrongHomClass L F M N] : F → M ↪[L] N := fun φ =>\n  ⟨⟨φ, EmbeddingLike.injective φ⟩, StrongHomClass.map_fun φ, StrongHomClass.map_rel φ⟩\n\n"}
{"name":"FirstOrder.Language.Equiv.instStrongHomClass","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ L.StrongHomClass (L.Equiv M N) M N","decl":"instance : StrongHomClass L (M ≃[L] N) M N where\n  map_fun := map_fun'\n  map_rel := map_rel'\n\n"}
{"name":"FirstOrder.Language.Equiv.symm_symm","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq f.symm.symm f","decl":"@[simp]\ntheorem symm_symm (f : M ≃[L] N) :\n    f.symm.symm = f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.apply_symm_apply","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\na : N\n⊢ Eq (f (f.symm a)) a","decl":"@[simp]\ntheorem apply_symm_apply (f : M ≃[L] N) (a : N) : f (f.symm a) = a :=\n  f.toEquiv.apply_symm_apply a\n\n"}
{"name":"FirstOrder.Language.Equiv.symm_apply_apply","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\na : M\n⊢ Eq (f.symm (f a)) a","decl":"@[simp]\ntheorem symm_apply_apply (f : M ≃[L] N) (a : M) : f.symm (f a) = a :=\n  f.toEquiv.symm_apply_apply a\n\n"}
{"name":"FirstOrder.Language.Equiv.map_fun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Equiv M N\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (φ (FirstOrder.Language.Structure.funMap f x)) (FirstOrder.Language.Structure.funMap f (Function.comp (⇑φ) x))","decl":"@[simp]\ntheorem map_fun (φ : M ≃[L] N) {n : ℕ} (f : L.Functions n) (x : Fin n → M) :\n    φ (funMap f x) = funMap f (φ ∘ x) :=\n  HomClass.map_fun φ f x\n\n"}
{"name":"FirstOrder.Language.Equiv.map_constants","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Equiv M N\nc : L.Constants\n⊢ Eq (φ ↑c) ↑c","decl":"@[simp]\ntheorem map_constants (φ : M ≃[L] N) (c : L.Constants) : φ c = c :=\n  HomClass.map_constants φ c\n\n"}
{"name":"FirstOrder.Language.Equiv.map_rel","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nφ : L.Equiv M N\nn : Nat\nr : L.Relations n\nx : Fin n → M\n⊢ Iff (FirstOrder.Language.Structure.RelMap r (Function.comp (⇑φ) x)) (FirstOrder.Language.Structure.RelMap r x)","decl":"@[simp]\ntheorem map_rel (φ : M ≃[L] N) {n : ℕ} (r : L.Relations n) (x : Fin n → M) :\n    RelMap r (φ ∘ x) ↔ RelMap r x :=\n  StrongHomClass.map_rel φ r x\n\n"}
{"name":"FirstOrder.Language.Equiv.toEmbedding_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq f.toEmbedding.toHom f.toHom","decl":"@[simp]\ntheorem toEmbedding_toHom (f : M ≃[L] N) : f.toEmbedding.toHom = f.toHom :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.coe_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq ⇑f.toHom ⇑f","decl":"@[simp]\ntheorem coe_toHom {f : M ≃[L] N} : (f.toHom : M → N) = (f : M → N) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.coe_toEmbedding","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq ⇑f.toEmbedding ⇑f","decl":"@[simp]\ntheorem coe_toEmbedding (f : M ≃[L] N) : (f.toEmbedding : M → N) = (f : M → N) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.injective_toEmbedding","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Function.Injective FirstOrder.Language.Equiv.toEmbedding","decl":"theorem injective_toEmbedding : Function.Injective (toEmbedding : (M ≃[L] N) → M ↪[L] N) := by\n  intro _ _ h; apply DFunLike.coe_injective; exact congr_arg (DFunLike.coe ∘ Embedding.toHom) h\n\n"}
{"name":"FirstOrder.Language.Equiv.coe_injective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (M ≃[L] N) (M → N) (↑) :=\n  DFunLike.coe_injective\n\n"}
{"name":"FirstOrder.Language.Equiv.ext","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.Equiv M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : M ≃[L] N⦄ (h : ∀ x, f x = g x) : f = g :=\n  coe_injective (funext h)\n\n"}
{"name":"FirstOrder.Language.Equiv.ext_iff","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf g : L.Equiv M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : M ≃[L] N⦄ (h : ∀ x, f x = g x) : f = g :=\n  coe_injective (funext h)\n\n"}
{"name":"FirstOrder.Language.Equiv.bijective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Function.Bijective ⇑f","decl":"theorem bijective (f : M ≃[L] N) : Function.Bijective f :=\n  EquivLike.bijective f\n\n"}
{"name":"FirstOrder.Language.Equiv.injective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Function.Injective ⇑f","decl":"theorem injective (f : M ≃[L] N) : Function.Injective f :=\n  EquivLike.injective f\n\n"}
{"name":"FirstOrder.Language.Equiv.surjective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Function.Surjective ⇑f","decl":"theorem surjective (f : M ≃[L] N) : Function.Surjective f :=\n  EquivLike.surjective f\n\n"}
{"name":"FirstOrder.Language.Equiv.refl_apply","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nx : M\n⊢ Eq ((FirstOrder.Language.Equiv.refl L M) x) x","decl":"@[simp]\ntheorem refl_apply (x : M) : refl L M x = x := by simp [refl]; rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.comp_apply","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\ng : L.Equiv N P\nf : L.Equiv M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[simp]\ntheorem comp_apply (g : N ≃[L] P) (f : M ≃[L] N) (x : M) : g.comp f x = g (f x) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.comp_refl","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ng : L.Equiv M N\n⊢ Eq (g.comp (FirstOrder.Language.Equiv.refl L M)) g","decl":"@[simp]\ntheorem comp_refl (g : M ≃[L] N) : g.comp (refl L M) = g :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.refl_comp","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\ng : L.Equiv M N\n⊢ Eq ((FirstOrder.Language.Equiv.refl L N).comp g) g","decl":"@[simp]\ntheorem refl_comp (g : M ≃[L] N) : (refl L N).comp g = g :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.refl_toEmbedding","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Eq (FirstOrder.Language.Equiv.refl L M).toEmbedding (FirstOrder.Language.Embedding.refl L M)","decl":"@[simp]\ntheorem refl_toEmbedding : (refl L M).toEmbedding = Embedding.refl L M :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.refl_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ Eq (FirstOrder.Language.Equiv.refl L M).toHom (FirstOrder.Language.Hom.id L M)","decl":"@[simp]\ntheorem refl_toHom : (refl L M).toHom = Hom.id L M :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.comp_assoc","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\nP : Type u_1\ninst✝¹ : L.Structure P\nQ : Type u_2\ninst✝ : L.Structure Q\nf : L.Equiv M N\ng : L.Equiv N P\nh : L.Equiv P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"/-- Composition of first-order homomorphisms is associative. -/\ntheorem comp_assoc (f : M ≃[L] N) (g : N ≃[L] P) (h : P ≃[L] Q) :\n    (h.comp g).comp f = h.comp (g.comp f) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.injective_comp","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nh : L.Equiv N P\n⊢ Function.Injective h.comp","decl":"theorem injective_comp (h : N ≃[L] P) :\n    Function.Injective (h.comp : (M ≃[L] N) →  (M ≃[L] P)) := by\n  intro f g hfg\n  ext x; exact h.injective (congr_fun (congr_arg DFunLike.coe hfg) x)\n\n"}
{"name":"FirstOrder.Language.Equiv.comp_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nhnp : L.Equiv N P\nhmn : L.Equiv M N\n⊢ Eq (hnp.comp hmn).toHom (hnp.toHom.comp hmn.toHom)","decl":"@[simp]\ntheorem comp_toHom (hnp : N ≃[L] P) (hmn : M ≃[L] N) :\n    (hnp.comp hmn).toHom = hnp.toHom.comp hmn.toHom :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.comp_toEmbedding","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nhnp : L.Equiv N P\nhmn : L.Equiv M N\n⊢ Eq (hnp.comp hmn).toEmbedding (hnp.toEmbedding.comp hmn.toEmbedding)","decl":"@[simp]\ntheorem comp_toEmbedding (hnp : N ≃[L] P) (hmn : M ≃[L] N) :\n    (hnp.comp hmn).toEmbedding = hnp.toEmbedding.comp hmn.toEmbedding :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.self_comp_symm","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq (f.comp f.symm) (FirstOrder.Language.Equiv.refl L N)","decl":"@[simp]\ntheorem self_comp_symm (f : M ≃[L] N) : f.comp f.symm = refl L N := by\n  ext; rw [comp_apply, apply_symm_apply, refl_apply]\n\n"}
{"name":"FirstOrder.Language.Equiv.symm_comp_self","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq (f.symm.comp f) (FirstOrder.Language.Equiv.refl L M)","decl":"@[simp]\ntheorem symm_comp_self (f : M ≃[L] N) : f.symm.comp f = refl L M := by\n  ext; rw [comp_apply, symm_apply_apply, refl_apply]\n\n"}
{"name":"FirstOrder.Language.Equiv.symm_comp_self_toEmbedding","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq (f.symm.toEmbedding.comp f.toEmbedding) (FirstOrder.Language.Embedding.refl L M)","decl":"@[simp]\ntheorem symm_comp_self_toEmbedding (f : M ≃[L] N) :\n    f.symm.toEmbedding.comp f.toEmbedding = Embedding.refl L M := by\n  rw [← comp_toEmbedding, symm_comp_self, refl_toEmbedding]\n\n"}
{"name":"FirstOrder.Language.Equiv.self_comp_symm_toEmbedding","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq (f.toEmbedding.comp f.symm.toEmbedding) (FirstOrder.Language.Embedding.refl L N)","decl":"@[simp]\ntheorem self_comp_symm_toEmbedding (f : M ≃[L] N) :\n    f.toEmbedding.comp f.symm.toEmbedding = Embedding.refl L N := by\n  rw [← comp_toEmbedding, self_comp_symm, refl_toEmbedding]\n\n"}
{"name":"FirstOrder.Language.Equiv.symm_comp_self_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq (f.symm.toHom.comp f.toHom) (FirstOrder.Language.Hom.id L M)","decl":"@[simp]\ntheorem symm_comp_self_toHom (f : M ≃[L] N) :\n    f.symm.toHom.comp f.toHom = Hom.id L M := by\n  rw [← comp_toHom, symm_comp_self, refl_toHom]\n\n"}
{"name":"FirstOrder.Language.Equiv.self_comp_symm_toHom","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝¹ : L.Structure M\ninst✝ : L.Structure N\nf : L.Equiv M N\n⊢ Eq (f.toHom.comp f.symm.toHom) (FirstOrder.Language.Hom.id L N)","decl":"@[simp]\ntheorem self_comp_symm_toHom (f : M ≃[L] N) :\n    f.toHom.comp f.symm.toHom = Hom.id L N := by\n  rw [← comp_toHom, self_comp_symm, refl_toHom]\n\n"}
{"name":"FirstOrder.Language.Equiv.comp_symm","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nf : L.Equiv M N\ng : L.Equiv N P\n⊢ Eq (g.comp f).symm (f.symm.comp g.symm)","decl":"@[simp]\ntheorem comp_symm (f : M ≃[L] N) (g : N ≃[L] P) : (g.comp f).symm = f.symm.comp g.symm :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Equiv.comp_right_injective","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nh : L.Equiv M N\n⊢ Function.Injective fun f => f.comp h","decl":"theorem comp_right_injective (h : M ≃[L] N) :\n    Function.Injective (fun f ↦ f.comp h : (N ≃[L] P) → (M ≃[L] P)) := by\n  intro f g hfg\n  convert (congr_arg (fun r : (M ≃[L] P) ↦ r.comp h.symm) hfg) <;>\n    rw [comp_assoc, self_comp_symm, comp_refl]\n\n"}
{"name":"FirstOrder.Language.Equiv.comp_right_inj","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type w\nN : Type w'\ninst✝² : L.Structure M\ninst✝¹ : L.Structure N\nP : Type u_1\ninst✝ : L.Structure P\nh : L.Equiv M N\nf g : L.Equiv N P\n⊢ Iff (Eq (f.comp h) (g.comp h)) (Eq f g)","decl":"@[simp]\ntheorem comp_right_inj (h : M ≃[L] N) (f g : N ≃[L] P) : f.comp h = g.comp h ↔ f = g :=\n  ⟨fun eq ↦ h.comp_right_injective eq, congr_arg (fun (r : N ≃[L] P) ↦ r.comp h)⟩\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.toEquiv_toFun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nF : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : EquivLike F M N\ninst✝ : L.StrongHomClass F M N\na✝ : F\na : M\n⊢ Eq ((FirstOrder.Language.StrongHomClass.toEquiv a✝) a) (a✝ a)","decl":"/-- Any element of a bijective `StrongHomClass` can be realized as a first_order isomorphism. -/\n@[simps] def StrongHomClass.toEquiv {F M N} [L.Structure M] [L.Structure N] [EquivLike F M N]\n    [StrongHomClass L F M N] : F → M ≃[L] N := fun φ =>\n  ⟨⟨φ, EquivLike.inv φ, EquivLike.left_inv φ, EquivLike.right_inv φ⟩, StrongHomClass.map_fun φ,\n    StrongHomClass.map_rel φ⟩\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.toEquiv_invFun","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nF : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝³ : L.Structure M\ninst✝² : L.Structure N\ninst✝¹ : EquivLike F M N\ninst✝ : L.StrongHomClass F M N\na✝¹ : F\na✝ : N\n⊢ Eq ((FirstOrder.Language.StrongHomClass.toEquiv a✝¹).invFun a✝) (EquivLike.inv a✝¹ a✝)","decl":"/-- Any element of a bijective `StrongHomClass` can be realized as a first_order isomorphism. -/\n@[simps] def StrongHomClass.toEquiv {F M N} [L.Structure M] [L.Structure N] [EquivLike F M N]\n    [StrongHomClass L F M N] : F → M ≃[L] N := fun φ =>\n  ⟨⟨φ, EquivLike.inv φ, EquivLike.left_inv φ, EquivLike.right_inv φ⟩, StrongHomClass.map_fun φ,\n    StrongHomClass.map_rel φ⟩\n\n"}
{"name":"FirstOrder.Language.funMap_sum_inl","module":"Mathlib.ModelTheory.Basic","initialProofState":"L₁ : FirstOrder.Language\nL₂ : FirstOrder.Language\nS : Type u_3\ninst✝¹ : L₁.Structure S\ninst✝ : L₂.Structure S\nn : Nat\nf : L₁.Functions n\n⊢ Eq (FirstOrder.Language.Structure.funMap (Sum.inl f)) (FirstOrder.Language.Structure.funMap f)","decl":"@[simp]\ntheorem funMap_sum_inl {n : ℕ} (f : L₁.Functions n) :\n    @funMap (L₁.sum L₂) S _ n (Sum.inl f) = funMap f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.funMap_sum_inr","module":"Mathlib.ModelTheory.Basic","initialProofState":"L₁ : FirstOrder.Language\nL₂ : FirstOrder.Language\nS : Type u_3\ninst✝¹ : L₁.Structure S\ninst✝ : L₂.Structure S\nn : Nat\nf : L₂.Functions n\n⊢ Eq (FirstOrder.Language.Structure.funMap (Sum.inr f)) (FirstOrder.Language.Structure.funMap f)","decl":"@[simp]\ntheorem funMap_sum_inr {n : ℕ} (f : L₂.Functions n) :\n    @funMap (L₁.sum L₂) S _ n (Sum.inr f) = funMap f :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.relMap_sum_inl","module":"Mathlib.ModelTheory.Basic","initialProofState":"L₁ : FirstOrder.Language\nL₂ : FirstOrder.Language\nS : Type u_3\ninst✝¹ : L₁.Structure S\ninst✝ : L₂.Structure S\nn : Nat\nR : L₁.Relations n\n⊢ Eq (FirstOrder.Language.Structure.RelMap (Sum.inl R)) (FirstOrder.Language.Structure.RelMap R)","decl":"@[simp]\ntheorem relMap_sum_inl {n : ℕ} (R : L₁.Relations n) :\n    @RelMap (L₁.sum L₂) S _ n (Sum.inl R) = RelMap R :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.relMap_sum_inr","module":"Mathlib.ModelTheory.Basic","initialProofState":"L₁ : FirstOrder.Language\nL₂ : FirstOrder.Language\nS : Type u_3\ninst✝¹ : L₁.Structure S\ninst✝ : L₂.Structure S\nn : Nat\nR : L₂.Relations n\n⊢ Eq (FirstOrder.Language.Structure.RelMap (Sum.inr R)) (FirstOrder.Language.Structure.RelMap R)","decl":"@[simp]\ntheorem relMap_sum_inr {n : ℕ} (R : L₂.Relations n) :\n    @RelMap (L₁.sum L₂) S _ n (Sum.inr R) = RelMap R :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.strongHomClassEmpty","module":"Mathlib.ModelTheory.Basic","initialProofState":"M : Type w\nN : Type w'\ninst✝² : FirstOrder.Language.empty.Structure M\ninst✝¹ : FirstOrder.Language.empty.Structure N\nF : Type u_3\ninst✝ : FunLike F M N\n⊢ FirstOrder.Language.empty.StrongHomClass F M N","decl":"instance (priority := 100) strongHomClassEmpty {F} [FunLike F M N] :\n    StrongHomClass Language.empty F M N :=\n  ⟨fun _ _ f => Empty.elim f, fun _ _ r => Empty.elim r⟩\n\n"}
{"name":"FirstOrder.Language.empty.nonempty_embedding_iff","module":"Mathlib.ModelTheory.Basic","initialProofState":"M : Type w\nN : Type w'\ninst✝¹ : FirstOrder.Language.empty.Structure M\ninst✝ : FirstOrder.Language.empty.Structure N\n⊢ Iff (Nonempty (FirstOrder.Language.empty.Embedding M N)) (LE.le (Cardinal.lift.{w', w} (Cardinal.mk M)) (Cardinal.lift.{w, w'} (Cardinal.mk N)))","decl":"@[simp]\ntheorem empty.nonempty_embedding_iff :\n    Nonempty (M ↪[Language.empty] N) ↔ Cardinal.lift.{w'} #M ≤ Cardinal.lift.{w} #N :=\n  _root_.trans ⟨Nonempty.map fun f => f.toEmbedding, Nonempty.map StrongHomClass.toEmbedding⟩\n    Cardinal.lift_mk_le'.symm\n\n"}
{"name":"FirstOrder.Language.empty.nonempty_equiv_iff","module":"Mathlib.ModelTheory.Basic","initialProofState":"M : Type w\nN : Type w'\ninst✝¹ : FirstOrder.Language.empty.Structure M\ninst✝ : FirstOrder.Language.empty.Structure N\n⊢ Iff (Nonempty (FirstOrder.Language.empty.Equiv M N)) (Eq (Cardinal.lift.{w', w} (Cardinal.mk M)) (Cardinal.lift.{w, w'} (Cardinal.mk N)))","decl":"@[simp]\ntheorem empty.nonempty_equiv_iff :\n    Nonempty (M ≃[Language.empty] N) ↔ Cardinal.lift.{w'} #M = Cardinal.lift.{w} #N :=\n  _root_.trans ⟨Nonempty.map fun f => f.toEquiv, Nonempty.map fun f => { toEquiv := f }⟩\n    Cardinal.lift_mk_eq'.symm\n\n"}
{"name":"Function.emptyHom_toFun","module":"Mathlib.ModelTheory.Basic","initialProofState":"M : Type w\nN : Type w'\ninst✝¹ : FirstOrder.Language.empty.Structure M\ninst✝ : FirstOrder.Language.empty.Structure N\nf : M → N\na✝ : M\n⊢ Eq ((Function.emptyHom f) a✝) (f a✝)","decl":"/-- Makes a `Language.empty.Hom` out of any function.\nThis is only needed because there is no instance of `FunLike (M → N) M N`, and thus no instance of\n`Language.empty.HomClass M N`. -/\n@[simps]\ndef _root_.Function.emptyHom (f : M → N) : M →[Language.empty] N where toFun := f\n\n"}
{"name":"Equiv.inducedStructure_funMap","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝ : L.Structure M\ne : Equiv M N\nn✝ : Nat\nf : L.Functions n✝\nx : Fin n✝ → N\n⊢ Eq (FirstOrder.Language.Structure.funMap f x) (e (FirstOrder.Language.Structure.funMap f (Function.comp (⇑e.symm) x)))","decl":"/-- A structure induced by a bijection. -/\n@[simps!]\ndef inducedStructure (e : M ≃ N) : L.Structure N :=\n  ⟨fun f x => e (funMap f (e.symm ∘ x)), fun r x => RelMap r (e.symm ∘ x)⟩\n\n"}
{"name":"Equiv.inducedStructure_RelMap","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝ : L.Structure M\ne : Equiv M N\nn✝ : Nat\nr : L.Relations n✝\nx : Fin n✝ → N\n⊢ Eq (FirstOrder.Language.Structure.RelMap r x) (FirstOrder.Language.Structure.RelMap r (Function.comp (⇑e.symm) x))","decl":"/-- A structure induced by a bijection. -/\n@[simps!]\ndef inducedStructure (e : M ≃ N) : L.Structure N :=\n  ⟨fun f x => e (funMap f (e.symm ∘ x)), fun r x => RelMap r (e.symm ∘ x)⟩\n\n"}
{"name":"Equiv.toEquiv_inducedStructureEquiv","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝ : L.Structure M\ne : Equiv M N\n⊢ Eq e.inducedStructureEquiv.toEquiv e","decl":"@[simp]\ntheorem toEquiv_inducedStructureEquiv (e : M ≃ N) :\n    @Language.Equiv.toEquiv L M N _ (inducedStructure e) (inducedStructureEquiv e) = e :=\n  rfl\n\n"}
{"name":"Equiv.toFun_inducedStructureEquiv","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝ : L.Structure M\ne : Equiv M N\n⊢ Eq ⇑e.inducedStructureEquiv ⇑e","decl":"@[simp]\ntheorem toFun_inducedStructureEquiv (e : M ≃ N) :\n    DFunLike.coe (@inducedStructureEquiv L M N _ e) = e :=\n  rfl\n\n"}
{"name":"Equiv.toFun_inducedStructureEquiv_Symm","module":"Mathlib.ModelTheory.Basic","initialProofState":"L : FirstOrder.Language\nM : Type u_1\nN : Type u_2\ninst✝ : L.Structure M\ne : Equiv M N\n⊢ Eq ⇑e.inducedStructureEquiv.symm ⇑e.symm","decl":"@[simp]\ntheorem toFun_inducedStructureEquiv_Symm (e : M ≃ N) :\n    (by\n    letI : L.Structure N := inducedStructure e\n    exact DFunLike.coe (@inducedStructureEquiv L M N _ e).symm) = (e.symm : N → M) :=\n  rfl\n\n"}
