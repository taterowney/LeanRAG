{"name":"Unitization.lift_range_le","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : NonUnitalSemiring A\ninst✝⁴ : Module R A\ninst✝³ : SMulCommClass R A A\ninst✝² : IsScalarTower R A A\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\nf : NonUnitalAlgHom (MonoidHom.id R) A C\nS : Subalgebra R C\n⊢ Iff (LE.le (Unitization.lift f).range S) (LE.le (NonUnitalAlgHom.range f) S.toNonUnitalSubalgebra)","decl":"theorem lift_range_le {f : A →ₙₐ[R] C} {S : Subalgebra R C} :\n    (lift f).range ≤ S ↔ NonUnitalAlgHom.range f ≤ S.toNonUnitalSubalgebra := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rintro - ⟨x, rfl⟩\n    exact @h (f x) ⟨x, by simp⟩\n  · rintro - ⟨x, rfl⟩\n    induction x with\n    | _ r a => simpa using add_mem (algebraMap_mem S r) (h ⟨a, rfl⟩)\n\n"}
{"name":"Unitization.lift_range","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : NonUnitalSemiring A\ninst✝⁴ : Module R A\ninst✝³ : SMulCommClass R A A\ninst✝² : IsScalarTower R A A\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\nf : NonUnitalAlgHom (MonoidHom.id R) A C\n⊢ Eq (Unitization.lift f).range (Algebra.adjoin R ↑(NonUnitalAlgHom.range f))","decl":"theorem lift_range (f : A →ₙₐ[R] C) :\n    (lift f).range = Algebra.adjoin R (NonUnitalAlgHom.range f : Set C) :=\n  eq_of_forall_ge_iff fun c ↦ by rw [lift_range_le, Algebra.adjoin_le_iff]; rfl\n\n"}
{"name":"NonUnitalSubalgebra.unitization_apply","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : SetLike S A\nhSA : NonUnitalSubsemiringClass S A\nhSRA : SMulMemClass S R A\ns : S\nx : Unitization R (Subtype fun x => Membership.mem s x)\n⊢ Eq ((NonUnitalSubalgebra.unitization s) x) (HAdd.hAdd ((algebraMap R A) x.fst) ↑x.snd)","decl":"@[simp]\ntheorem unitization_apply (x : Unitization R s) :\n    unitization s x = algebraMap R A x.fst + x.snd :=\n  rfl\n\n"}
{"name":"NonUnitalSubalgebra.unitization_range","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : SetLike S A\nhSA : NonUnitalSubsemiringClass S A\nhSRA : SMulMemClass S R A\ns : S\n⊢ Eq (NonUnitalSubalgebra.unitization s).range (Algebra.adjoin R ↑s)","decl":"theorem unitization_range : (unitization s).range = Algebra.adjoin R (s : Set A) := by\n  rw [unitization, Unitization.lift_range]\n  simp only [NonUnitalAlgHom.coe_range, NonUnitalSubalgebraClass.coeSubtype,\n    Subtype.range_coe_subtype, SetLike.mem_coe]\n  rfl\n\n"}
{"name":"AlgHomClass.unitization_injective'","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : SetLike S A\nhSA : NonUnitalSubringClass S A\nhSRA : SMulMemClass S R A\ns : S\nh : ∀ (r : R), Ne r 0 → Not (Membership.mem s ((algebraMap R A) r))\ninst✝¹ : FunLike F (Unitization R (Subtype fun x => Membership.mem s x)) A\ninst✝ : AlgHomClass F R (Unitization R (Subtype fun x => Membership.mem s x)) A\nf : F\nhf : ∀ (x : Subtype fun x => Membership.mem s x), Eq (f ↑x) ↑x\n⊢ Function.Injective ⇑f","decl":"/-- A sufficient condition for injectivity of `NonUnitalSubalgebra.unitization` when the scalars\nare a commutative ring. When the scalars are a field, one should use the more natural\n`NonUnitalStarSubalgebra.unitization_injective` whose hypothesis is easier to verify. -/\ntheorem _root_.AlgHomClass.unitization_injective' {F R S A : Type*} [CommRing R] [Ring A]\n    [Algebra R A] [SetLike S A] [hSA : NonUnitalSubringClass S A] [hSRA : SMulMemClass S R A]\n    (s : S) (h : ∀ r, r ≠ 0 → algebraMap R A r ∉ s)\n    [FunLike F (Unitization R s) A] [AlgHomClass F R (Unitization R s) A]\n    (f : F) (hf : ∀ x : s, f x = x) : Function.Injective f := by\n  refine (injective_iff_map_eq_zero f).mpr fun x hx => ?_\n  induction x with\n  | inl_add_inr r a =>\n    simp_rw [map_add, hf, ← Unitization.algebraMap_eq_inl, AlgHomClass.commutes] at hx\n    rw [add_eq_zero_iff_eq_neg] at hx ⊢\n    by_cases hr : r = 0\n    · ext\n      · simp [hr]\n      · simpa [hr] using hx\n    · exact (h r hr <| hx ▸ (neg_mem a.property)).elim\n\n"}
{"name":"AlgHomClass.unitization_injective","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\ninst✝⁵ : Field R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : SetLike S A\nhSA : NonUnitalSubringClass S A\nhSRA : SMulMemClass S R A\ns : S\nh1 : Not (Membership.mem s 1)\ninst✝¹ : FunLike F (Unitization R (Subtype fun x => Membership.mem s x)) A\ninst✝ : AlgHomClass F R (Unitization R (Subtype fun x => Membership.mem s x)) A\nf : F\nhf : ∀ (x : Subtype fun x => Membership.mem s x), Eq (f ↑x) ↑x\n⊢ Function.Injective ⇑f","decl":"/-- This is a generic version which allows us to prove both\n`NonUnitalSubalgebra.unitization_injective` and `NonUnitalStarSubalgebra.unitization_injective`. -/\ntheorem _root_.AlgHomClass.unitization_injective {F R S A : Type*} [Field R] [Ring A]\n    [Algebra R A] [SetLike S A] [hSA : NonUnitalSubringClass S A] [hSRA : SMulMemClass S R A]\n    (s : S) (h1 : 1 ∉ s) [FunLike F (Unitization R s) A] [AlgHomClass F R (Unitization R s) A]\n    (f : F) (hf : ∀ x : s, f x = x) : Function.Injective f := by\n  refine AlgHomClass.unitization_injective' s (fun r hr hr' ↦ ?_) f hf\n  rw [Algebra.algebraMap_eq_smul_one] at hr'\n  exact h1 <| inv_smul_smul₀ hr (1 : A) ▸ SMulMemClass.smul_mem r⁻¹ hr'\n\n"}
{"name":"NonUnitalSubalgebra.unitization_injective","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝³ : Field R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : SetLike S A\nhSA : NonUnitalSubringClass S A\nhSRA : SMulMemClass S R A\ns : S\nh1 : Not (Membership.mem s 1)\n⊢ Function.Injective ⇑(NonUnitalSubalgebra.unitization s)","decl":"theorem unitization_injective (h1 : (1 : A) ∉ s) : Function.Injective (unitization s) :=\n  AlgHomClass.unitization_injective s h1 (unitization s) fun _ ↦ by simp\n\n"}
{"name":"NonUnitalSubalgebra.unitizationAlgEquiv_apply_coe","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝³ : Field R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : SetLike S A\nhSA : NonUnitalSubringClass S A\nhSRA : SMulMemClass S R A\ns : S\nh1 : Not (Membership.mem s 1)\na : Unitization R (Subtype fun x => Membership.mem s x)\n⊢ Eq (↑((NonUnitalSubalgebra.unitizationAlgEquiv s h1) a)) (HAdd.hAdd ((algebraMap R A) a.fst) ↑a.snd)","decl":"/-- If a `NonUnitalSubalgebra` over a field does not contain `1`, then its unitization is\nisomorphic to its `Algebra.adjoin`. -/\n@[simps! apply_coe]\nnoncomputable def unitizationAlgEquiv (h1 : (1 : A) ∉ s) :\n    Unitization R s ≃ₐ[R] Algebra.adjoin R (s : Set A) :=\n  let algHom : Unitization R s →ₐ[R] Algebra.adjoin R (s : Set A) :=\n    ((unitization s).codRestrict _\n      fun x ↦ (unitization_range s).le <| AlgHom.mem_range_self _ x)\n  AlgEquiv.ofBijective algHom <| by\n    refine ⟨?_, fun x ↦ ?_⟩\n    · have := AlgHomClass.unitization_injective s h1\n        ((Subalgebra.val _).comp algHom) fun _ ↦ by simp [algHom]\n      rw [AlgHom.coe_comp] at this\n      exact this.of_comp\n    · obtain (⟨a, ha⟩ : (x : A) ∈ (unitization s).range) :=\n        (unitization_range s).ge x.property\n      exact ⟨a, Subtype.ext ha⟩\n\n"}
{"name":"NonUnitalSubsemiring.unitization_apply","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : SetLike S R\nhSR : NonUnitalSubsemiringClass S R\ns : S\nx : Unitization Nat (Subtype fun x => Membership.mem s x)\n⊢ Eq ((NonUnitalSubsemiring.unitization s) x) (HAdd.hAdd ↑x.fst ↑x.snd)","decl":"@[simp]\ntheorem unitization_apply (x : Unitization ℕ s) : unitization s x = x.fst + x.snd :=\n  rfl\n\n"}
{"name":"NonUnitalSubsemiring.unitization_range","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : SetLike S R\nhSR : NonUnitalSubsemiringClass S R\ns : S\n⊢ Eq (NonUnitalSubsemiring.unitization s).range (subalgebraOfSubsemiring (Subsemiring.closure ↑s))","decl":"theorem unitization_range :\n    (unitization s).range = subalgebraOfSubsemiring (.closure s) := by\n  have := AddSubmonoidClass.nsmulMemClass (S := S)\n  rw [unitization, NonUnitalSubalgebra.unitization_range (hSRA := this), Algebra.adjoin_nat]\n\n"}
{"name":"NonUnitalSubring.unitization_apply","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nhSR : NonUnitalSubringClass S R\ns : S\nx : Unitization Int (Subtype fun x => Membership.mem s x)\n⊢ Eq ((NonUnitalSubring.unitization s) x) (HAdd.hAdd ↑x.fst ↑x.snd)","decl":"@[simp]\ntheorem unitization_apply (x : Unitization ℤ s) : unitization s x = x.fst + x.snd :=\n  rfl\n\n"}
{"name":"NonUnitalSubring.unitization_range","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : SetLike S R\nhSR : NonUnitalSubringClass S R\ns : S\n⊢ Eq (NonUnitalSubring.unitization s).range (subalgebraOfSubring (Subring.closure ↑s))","decl":"theorem unitization_range :\n    (unitization s).range = subalgebraOfSubring (.closure s) := by\n  have := AddSubgroupClass.zsmulMemClass (S := S)\n  rw [unitization, NonUnitalSubalgebra.unitization_range (hSRA := this), Algebra.adjoin_int]\n\n"}
{"name":"Unitization.starLift_range_le","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : NonUnitalSemiring A\ninst✝⁹ : StarRing R\ninst✝⁸ : StarRing A\ninst✝⁷ : Module R A\ninst✝⁶ : SMulCommClass R A A\ninst✝⁵ : IsScalarTower R A A\ninst✝⁴ : StarModule R A\ninst✝³ : Semiring C\ninst✝² : StarRing C\ninst✝¹ : Algebra R C\ninst✝ : StarModule R C\nf : NonUnitalStarAlgHom R A C\nS : StarSubalgebra R C\n⊢ Iff (LE.le (Unitization.starLift f).range S) (LE.le (NonUnitalStarAlgHom.range f) S.toNonUnitalStarSubalgebra)","decl":"theorem starLift_range_le\n    {f : A →⋆ₙₐ[R] C} {S : StarSubalgebra R C} :\n    (starLift f).range ≤ S ↔ NonUnitalStarAlgHom.range f ≤ S.toNonUnitalStarSubalgebra := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rintro - ⟨x, rfl⟩\n    exact @h (f x) ⟨x, by simp⟩\n  · rintro - ⟨x, rfl⟩\n    induction x with\n    | _ r a => simpa using add_mem (algebraMap_mem S r) (h ⟨a, rfl⟩)\n\n"}
{"name":"Unitization.starLift_range","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nA : Type u_2\nC : Type u_3\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : NonUnitalSemiring A\ninst✝⁹ : StarRing R\ninst✝⁸ : StarRing A\ninst✝⁷ : Module R A\ninst✝⁶ : SMulCommClass R A A\ninst✝⁵ : IsScalarTower R A A\ninst✝⁴ : StarModule R A\ninst✝³ : Semiring C\ninst✝² : StarRing C\ninst✝¹ : Algebra R C\ninst✝ : StarModule R C\nf : NonUnitalStarAlgHom R A C\n⊢ Eq (Unitization.starLift f).range (StarAlgebra.adjoin R ↑(NonUnitalStarAlgHom.range f))","decl":"theorem starLift_range (f : A →⋆ₙₐ[R] C) :\n    (starLift f).range = StarAlgebra.adjoin R (NonUnitalStarAlgHom.range f : Set C) :=\n  eq_of_forall_ge_iff fun c ↦ by\n    rw [starLift_range_le, StarAlgebra.adjoin_le_iff]\n    rfl\n\n"}
{"name":"NonUnitalStarSubalgebra.unitization_apply","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁷ : CommSemiring R\ninst✝⁶ : StarRing R\ninst✝⁵ : Semiring A\ninst✝⁴ : StarRing A\ninst✝³ : Algebra R A\ninst✝² : StarModule R A\ninst✝¹ : SetLike S A\nhSA : NonUnitalSubsemiringClass S A\nhSRA : SMulMemClass S R A\ninst✝ : StarMemClass S A\ns : S\nx : Unitization R (Subtype fun x => Membership.mem s x)\n⊢ Eq ((NonUnitalStarSubalgebra.unitization s) x) (HAdd.hAdd ((algebraMap R A) x.fst) ↑x.snd)","decl":"@[simp]\ntheorem unitization_apply (x : Unitization R s) : unitization s x = algebraMap R A x.fst + x.snd :=\n  rfl\n\n"}
{"name":"NonUnitalStarSubalgebra.unitization_range","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁷ : CommSemiring R\ninst✝⁶ : StarRing R\ninst✝⁵ : Semiring A\ninst✝⁴ : StarRing A\ninst✝³ : Algebra R A\ninst✝² : StarModule R A\ninst✝¹ : SetLike S A\nhSA : NonUnitalSubsemiringClass S A\nhSRA : SMulMemClass S R A\ninst✝ : StarMemClass S A\ns : S\n⊢ Eq (NonUnitalStarSubalgebra.unitization s).range (StarAlgebra.adjoin R ↑s)","decl":"theorem unitization_range : (unitization s).range = StarAlgebra.adjoin R s := by\n  rw [unitization, Unitization.starLift_range]\n  simp only [NonUnitalStarAlgHom.coe_range, NonUnitalStarSubalgebraClass.coeSubtype,\n    Subtype.range_coe_subtype]\n  rfl\n\n"}
{"name":"NonUnitalStarSubalgebra.unitization_injective","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁷ : Field R\ninst✝⁶ : StarRing R\ninst✝⁵ : Ring A\ninst✝⁴ : StarRing A\ninst✝³ : Algebra R A\ninst✝² : StarModule R A\ninst✝¹ : SetLike S A\nhSA : NonUnitalSubringClass S A\nhSRA : SMulMemClass S R A\ninst✝ : StarMemClass S A\ns : S\nh1 : Not (Membership.mem s 1)\n⊢ Function.Injective ⇑(NonUnitalStarSubalgebra.unitization s)","decl":"theorem unitization_injective (h1 : (1 : A) ∉ s) : Function.Injective (unitization s) :=\n  AlgHomClass.unitization_injective s h1 (unitization s) fun _ ↦ by simp\n\n"}
{"name":"NonUnitalStarSubalgebra.unitizationStarAlgEquiv_apply_coe","module":"Mathlib.Algebra.Algebra.Subalgebra.Unitization","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁷ : Field R\ninst✝⁶ : StarRing R\ninst✝⁵ : Ring A\ninst✝⁴ : StarRing A\ninst✝³ : Algebra R A\ninst✝² : StarModule R A\ninst✝¹ : SetLike S A\nhSA : NonUnitalSubringClass S A\nhSRA : SMulMemClass S R A\ninst✝ : StarMemClass S A\ns : S\nh1 : Not (Membership.mem s 1)\na : Unitization R (Subtype fun x => Membership.mem s x)\n⊢ Eq (↑((NonUnitalStarSubalgebra.unitizationStarAlgEquiv s h1) a)) (HAdd.hAdd ((algebraMap R A) a.fst) ↑a.snd)","decl":"/-- If a `NonUnitalStarSubalgebra` over a field does not contain `1`, then its unitization is\nisomorphic to its `StarAlgebra.adjoin`. -/\n@[simps! apply_coe]\nnoncomputable def unitizationStarAlgEquiv (h1 : (1 : A) ∉ s) :\n    Unitization R s ≃⋆ₐ[R] StarAlgebra.adjoin R (s : Set A) :=\n  let starAlgHom : Unitization R s →⋆ₐ[R] StarAlgebra.adjoin R (s : Set A) :=\n    ((unitization s).codRestrict _\n      fun x ↦ (unitization_range s).le <| Set.mem_range_self x)\n  StarAlgEquiv.ofBijective starAlgHom <| by\n    refine ⟨?_, fun x ↦ ?_⟩\n    · have := AlgHomClass.unitization_injective s h1 ((StarSubalgebra.subtype _).comp starAlgHom)\n        fun _ ↦ by simp [starAlgHom]\n      rw [StarAlgHom.coe_comp] at this\n      exact this.of_comp\n    · obtain (⟨a, ha⟩ : (x : A) ∈ (unitization s).range) :=\n        (unitization_range s).ge x.property\n      exact ⟨a, Subtype.ext ha⟩\n\n"}
