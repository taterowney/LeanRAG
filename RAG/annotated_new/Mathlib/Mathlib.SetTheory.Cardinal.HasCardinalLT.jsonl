{"name":"hasCardinalLT_iff_cardinal_mk_lt","module":"Mathlib.SetTheory.Cardinal.HasCardinalLT","initialProofState":"X : Type u\nκ : Cardinal.{u}\n⊢ Iff (HasCardinalLT X κ) (LT.lt (Cardinal.mk X) κ)","decl":"lemma hasCardinalLT_iff_cardinal_mk_lt (X : Type u) (κ : Cardinal.{u}) :\n    HasCardinalLT X κ ↔ Cardinal.mk X < κ := by\n  simp [HasCardinalLT]\n\n"}
{"name":"HasCardinalLT.small","module":"Mathlib.SetTheory.Cardinal.HasCardinalLT","initialProofState":"X : Type u\nκ : Cardinal.{v}\nh : HasCardinalLT X κ\n⊢ Small.{v, u} X","decl":"lemma small : Small.{v} X := by\n  dsimp [HasCardinalLT] at h\n  rw [← Cardinal.lift_lt.{_, v + 1}, Cardinal.lift_lift, Cardinal.lift_lift] at h\n  simpa only [Cardinal.small_iff_lift_mk_lt_univ] using h.trans (Cardinal.lift_lt_univ' κ)\n\n"}
{"name":"HasCardinalLT.of_le","module":"Mathlib.SetTheory.Cardinal.HasCardinalLT","initialProofState":"X : Type u\nκ : Cardinal.{v}\nh : HasCardinalLT X κ\nκ' : Cardinal.{v}\nhκ' : LE.le κ κ'\n⊢ HasCardinalLT X κ'","decl":"lemma of_le {κ' : Cardinal.{v}} (hκ' : κ ≤ κ') :\n    HasCardinalLT X κ' :=\n  lt_of_lt_of_le h (by simpa only [Cardinal.lift_le] using hκ')\n\n"}
{"name":"HasCardinalLT.of_injective","module":"Mathlib.SetTheory.Cardinal.HasCardinalLT","initialProofState":"X : Type u\nκ : Cardinal.{v}\nh : HasCardinalLT X κ\nY : Type u'\nf : Y → X\nhf : Function.Injective f\n⊢ HasCardinalLT Y κ","decl":"lemma of_injective (f : Y → X) (hf : Function.Injective f) :\n    HasCardinalLT Y κ := by\n  dsimp [HasCardinalLT] at h ⊢\n  rw [← Cardinal.lift_lt.{_, u}, Cardinal.lift_lift, Cardinal.lift_lift]\n  rw [← Cardinal.lift_lt.{_, u'}, Cardinal.lift_lift, Cardinal.lift_lift] at h\n  exact lt_of_le_of_lt (Cardinal.mk_le_of_injective\n    (Function.Injective.comp ULift.up_injective\n      (Function.Injective.comp hf ULift.down_injective))) h\n\n"}
{"name":"HasCardinalLT.of_surjective","module":"Mathlib.SetTheory.Cardinal.HasCardinalLT","initialProofState":"X : Type u\nκ : Cardinal.{v}\nh : HasCardinalLT X κ\nY : Type u'\nf : X → Y\nhf : Function.Surjective f\n⊢ HasCardinalLT Y κ","decl":"lemma of_surjective (f : X → Y) (hf : Function.Surjective f) :\n    HasCardinalLT Y κ := by\n  dsimp [HasCardinalLT] at h ⊢\n  rw [← Cardinal.lift_lt.{_, u}, Cardinal.lift_lift, Cardinal.lift_lift]\n  rw [← Cardinal.lift_lt.{_, u'}, Cardinal.lift_lift, Cardinal.lift_lift] at h\n  exact lt_of_le_of_lt (Cardinal.mk_le_of_surjective\n    (Function.Surjective.comp ULift.up_surjective (Function.Surjective.comp hf\n      ULift.down_surjective))) h\n\n"}
{"name":"hasCardinalLT_iff_of_equiv","module":"Mathlib.SetTheory.Cardinal.HasCardinalLT","initialProofState":"X : Type u\nY : Type u'\ne : Equiv X Y\nκ : Cardinal.{v}\n⊢ Iff (HasCardinalLT X κ) (HasCardinalLT Y κ)","decl":"lemma hasCardinalLT_iff_of_equiv {X : Type u} {Y : Type u'} (e : X ≃ Y) (κ : Cardinal.{v}) :\n    HasCardinalLT X κ ↔ HasCardinalLT Y κ :=\n  ⟨fun h ↦ h.of_injective _ e.symm.injective,\n    fun h ↦ h.of_injective _ e.injective⟩\n\n"}
{"name":"hasCardinalLT_aleph0_iff","module":"Mathlib.SetTheory.Cardinal.HasCardinalLT","initialProofState":"X : Type u\n⊢ Iff (HasCardinalLT X Cardinal.aleph0) (Finite X)","decl":"@[simp]\nlemma hasCardinalLT_aleph0_iff (X : Type u) :\n    HasCardinalLT X Cardinal.aleph0.{v} ↔ Finite X := by\n  simpa [HasCardinalLT] using Cardinal.mk_lt_aleph0_iff\n\n"}
{"name":"hasCardinalLT_option_iff","module":"Mathlib.SetTheory.Cardinal.HasCardinalLT","initialProofState":"X : Type u\nκ : Cardinal.{w}\nhκ : LE.le Cardinal.aleph0 κ\n⊢ Iff (HasCardinalLT (Option X) κ) (HasCardinalLT X κ)","decl":"lemma hasCardinalLT_option_iff (X : Type u) (κ : Cardinal.{w})\n    (hκ : Cardinal.aleph0 ≤ κ) :\n    HasCardinalLT (Option X) κ ↔ HasCardinalLT X κ := by\n  constructor\n  · intro h\n    exact h.of_injective _ (Option.some_injective _)\n  · intro h\n    dsimp [HasCardinalLT] at h ⊢\n    simp only [Cardinal.mk_option, Cardinal.lift_add, Cardinal.lift_one]\n    exact Cardinal.add_lt_of_lt (by simpa using hκ) h\n      (lt_of_lt_of_le Cardinal.one_lt_aleph0 (by simpa using hκ))\n"}
