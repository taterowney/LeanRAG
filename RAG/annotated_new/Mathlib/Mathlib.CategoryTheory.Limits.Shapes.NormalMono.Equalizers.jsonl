{"name":"CategoryTheory.NormalMonoCategory.hasEqualizers","module":"Mathlib.CategoryTheory.Limits.Shapes.NormalMono.Equalizers","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasFiniteProducts C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.IsNormalMonoCategory C\n⊢ CategoryTheory.Limits.HasEqualizers C","decl":"/-- A `NormalMonoCategory` category with finite products and kernels has all equalizers. -/\ninstance (priority := 100) hasEqualizers : HasEqualizers C :=\n  hasEqualizers_of_hasLimit_parallelPair _\n\n"}
{"name":"CategoryTheory.NormalMonoCategory.epi_of_zero_cokernel","module":"Mathlib.CategoryTheory.Limits.Shapes.NormalMono.Equalizers","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasFiniteProducts C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.IsNormalMonoCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nl : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ 0 ⋯)\n⊢ CategoryTheory.Epi f","decl":"/-- If a zero morphism is a cokernel of `f`, then `f` is an epimorphism. -/\ntheorem epi_of_zero_cokernel {X Y : C} (f : X ⟶ Y) (Z : C)\n    (l : IsColimit (CokernelCofork.ofπ (0 : Y ⟶ Z) (show f ≫ 0 = 0 by simp))) : Epi f :=\n  ⟨fun u v huv => by\n    obtain ⟨W, w, hw, hl⟩ := normalMonoOfMono (equalizer.ι u v)\n    obtain ⟨m, hm⟩ := equalizer.lift' f huv\n    have hwf : f ≫ w = 0 := by rw [← hm, Category.assoc, hw, comp_zero]\n    obtain ⟨n, hn⟩ := CokernelCofork.IsColimit.desc' l _ hwf\n    rw [Cofork.π_ofπ, zero_comp] at hn\n    have : IsIso (equalizer.ι u v) := by apply isIso_limit_cone_parallelPair_of_eq hn.symm hl\n    apply (cancel_epi (equalizer.ι u v)).1\n    exact equalizer.condition _ _⟩\n\n"}
{"name":"CategoryTheory.NormalMonoCategory.epi_of_zero_cancel","module":"Mathlib.CategoryTheory.Limits.Shapes.NormalMono.Equalizers","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝² : CategoryTheory.Limits.HasKernels C\ninst✝¹ : CategoryTheory.IsNormalMonoCategory C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\nhf : ∀ (Z : C) (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp f g) 0 → Eq g 0\n⊢ CategoryTheory.Epi f","decl":"/-- If `f ≫ g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. -/\ntheorem epi_of_zero_cancel {X Y : C} (f : X ⟶ Y)\n    (hf : ∀ (Z : C) (g : Y ⟶ Z) (_ : f ≫ g = 0), g = 0) : Epi f :=\n  epi_of_zero_cokernel f 0 <| zeroCokernelOfZeroCancel f hf\n\n"}
{"name":"CategoryTheory.NormalEpiCategory.hasCoequalizers","module":"Mathlib.CategoryTheory.Limits.Shapes.NormalMono.Equalizers","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝¹ : CategoryTheory.Limits.HasCokernels C\ninst✝ : CategoryTheory.IsNormalEpiCategory C\n⊢ CategoryTheory.Limits.HasCoequalizers C","decl":"/-- A `NormalEpiCategory` category with finite coproducts and cokernels has all coequalizers. -/\ninstance (priority := 100) hasCoequalizers : HasCoequalizers C :=\n  hasCoequalizers_of_hasColimit_parallelPair _\n\n"}
{"name":"CategoryTheory.NormalEpiCategory.mono_of_zero_kernel","module":"Mathlib.CategoryTheory.Limits.Shapes.NormalMono.Equalizers","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝¹ : CategoryTheory.Limits.HasCokernels C\ninst✝ : CategoryTheory.IsNormalEpiCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nl : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι 0 ⋯)\n⊢ CategoryTheory.Mono f","decl":"/-- If a zero morphism is a kernel of `f`, then `f` is a monomorphism. -/\ntheorem mono_of_zero_kernel {X Y : C} (f : X ⟶ Y) (Z : C)\n    (l : IsLimit (KernelFork.ofι (0 : Z ⟶ X) (show 0 ≫ f = 0 by simp))) : Mono f :=\n  ⟨fun u v huv => by\n    obtain ⟨W, w, hw, hl⟩ := normalEpiOfEpi (coequalizer.π u v)\n    obtain ⟨m, hm⟩ := coequalizer.desc' f huv\n    have reassoced {W : C} (h : coequalizer u v ⟶ W) : w ≫ coequalizer.π u v ≫ h = 0 ≫ h := by\n      rw [← Category.assoc, eq_whisker hw]\n    have hwf : w ≫ f = 0 := by rw [← hm, reassoced, zero_comp]\n    obtain ⟨n, hn⟩ := KernelFork.IsLimit.lift' l _ hwf\n    rw [Fork.ι_ofι, HasZeroMorphisms.comp_zero] at hn\n    have : IsIso (coequalizer.π u v) := by\n      apply isIso_colimit_cocone_parallelPair_of_eq hn.symm hl\n    apply (cancel_mono (coequalizer.π u v)).1\n    exact coequalizer.condition _ _⟩\n\n"}
{"name":"CategoryTheory.NormalEpiCategory.mono_of_cancel_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.NormalMono.Equalizers","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝² : CategoryTheory.Limits.HasCokernels C\ninst✝¹ : CategoryTheory.IsNormalEpiCategory C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\nhf : ∀ (Z : C) (g : Quiver.Hom Z X), Eq (CategoryTheory.CategoryStruct.comp g f) 0 → Eq g 0\n⊢ CategoryTheory.Mono f","decl":"/-- If `g ≫ f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. -/\ntheorem mono_of_cancel_zero {X Y : C} (f : X ⟶ Y)\n    (hf : ∀ (Z : C) (g : Z ⟶ X) (_ : g ≫ f = 0), g = 0) : Mono f :=\n  mono_of_zero_kernel f 0 <| zeroKernelOfCancelZero f hf\n\n"}
