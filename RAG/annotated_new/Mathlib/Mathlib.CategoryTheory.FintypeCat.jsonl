{"name":"FintypeCat.incl_map","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X‚úù Y‚úù : CategoryTheory.InducedCategory (Type u_1) CategoryTheory.Bundled.Œ±\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : ‚ÜëX‚úù\n‚ä¢ Eq (FintypeCat.incl.map f a‚úù) (f a‚úù)","decl":"/-- The fully faithful embedding of `FintypeCat` into the category of types. -/\n@[simps!]\ndef incl : FintypeCat ‚•§ Type* :=\n  inducedFunctor _\n\n"}
{"name":"FintypeCat.incl_obj","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"self : CategoryTheory.Bundled Fintype\n‚ä¢ Eq (FintypeCat.incl.obj self) ‚Üëself","decl":"/-- The fully faithful embedding of `FintypeCat` into the category of types. -/\n@[simps!]\ndef incl : FintypeCat ‚•§ Type* :=\n  inducedFunctor _\n\n"}
{"name":"FintypeCat.instFullIncl","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ FintypeCat.incl.Full","decl":"instance : incl.Full := InducedCategory.full _\n"}
{"name":"FintypeCat.instFaithfulIncl","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ FintypeCat.incl.Faithful","decl":"instance : incl.Faithful := InducedCategory.faithful _\n\n"}
{"name":"FintypeCat.instFullForget","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ (CategoryTheory.forget FintypeCat).Full","decl":"instance : (forget FintypeCat).Full := inferInstanceAs <| FintypeCat.incl.Full\n\n"}
{"name":"FintypeCat.id_apply","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X : FintypeCat\nx : ‚ÜëX\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X x) x","decl":"@[simp]\ntheorem id_apply (X : FintypeCat) (x : X) : (ùüô X : X ‚Üí X) x = x :=\n  rfl\n\n"}
{"name":"FintypeCat.comp_apply","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y Z : FintypeCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : ‚ÜëX\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g x) (g (f x))","decl":"@[simp]\ntheorem comp_apply {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=\n  rfl\n\n"}
{"name":"FintypeCat.hom_inv_id_apply","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat\nf : CategoryTheory.Iso X Y\nx : ‚ÜëX\n‚ä¢ Eq (f.inv (f.hom x)) x","decl":"@[simp]\nlemma hom_inv_id_apply {X Y : FintypeCat} (f : X ‚âÖ Y) (x : X) : f.inv (f.hom x) = x :=\n  congr_fun f.hom_inv_id x\n\n"}
{"name":"FintypeCat.inv_hom_id_apply","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat\nf : CategoryTheory.Iso X Y\ny : ‚ÜëY\n‚ä¢ Eq (f.hom (f.inv y)) y","decl":"@[simp]\nlemma inv_hom_id_apply {X Y : FintypeCat} (f : X ‚âÖ Y) (y : Y) : f.hom (f.inv y) = y :=\n  congr_fun f.inv_hom_id y\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"FintypeCat.hom_ext","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat\nf g : Quiver.Hom X Y\nh : ‚àÄ (x : ‚ÜëX), Eq (f x) (g x)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : FintypeCat} (f g : X ‚ü∂ Y) (h : ‚àÄ x, f x = g x) : f = g := by\n  funext\n  apply h\n\n-- See `equivEquivIso` in the root namespace for the analogue in `Type`.\n"}
{"name":"FintypeCat.hom_ext_iff","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (x : ‚ÜëX), Eq (f x) (g x))","decl":"@[ext]\nlemma hom_ext {X Y : FintypeCat} (f g : X ‚ü∂ Y) (h : ‚àÄ x, f x = g x) : f = g := by\n  funext\n  apply h\n\n-- See `equivEquivIso` in the root namespace for the analogue in `Type`.\n"}
{"name":"FintypeCat.equivEquivIso_symm_apply_symm_apply","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"A B : FintypeCat\ni : CategoryTheory.Iso A B\na‚úù : ‚ÜëB\n‚ä¢ Eq ((FintypeCat.equivEquivIso.symm i).symm a‚úù) (i.inv a‚úù)","decl":"/-- Equivalences between finite types are the same as isomorphisms in `FintypeCat`. -/\n@[simps]\ndef equivEquivIso {A B : FintypeCat} : A ‚âÉ B ‚âÉ (A ‚âÖ B) where\n  toFun e :=\n    { hom := e\n      inv := e.symm }\n  invFun i :=\n    { toFun := i.hom\n      invFun := i.inv\n      left_inv := congr_fun i.hom_inv_id\n      right_inv := congr_fun i.inv_hom_id }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"FintypeCat.equivEquivIso_apply_hom","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"A B : FintypeCat\ne : Equiv ‚ÜëA ‚ÜëB\na : ‚ÜëA\n‚ä¢ Eq ((FintypeCat.equivEquivIso e).hom a) (e a)","decl":"/-- Equivalences between finite types are the same as isomorphisms in `FintypeCat`. -/\n@[simps]\ndef equivEquivIso {A B : FintypeCat} : A ‚âÉ B ‚âÉ (A ‚âÖ B) where\n  toFun e :=\n    { hom := e\n      inv := e.symm }\n  invFun i :=\n    { toFun := i.hom\n      invFun := i.inv\n      left_inv := congr_fun i.hom_inv_id\n      right_inv := congr_fun i.inv_hom_id }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"FintypeCat.equivEquivIso_symm_apply_apply","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"A B : FintypeCat\ni : CategoryTheory.Iso A B\na‚úù : ‚ÜëA\n‚ä¢ Eq ((FintypeCat.equivEquivIso.symm i) a‚úù) (i.hom a‚úù)","decl":"/-- Equivalences between finite types are the same as isomorphisms in `FintypeCat`. -/\n@[simps]\ndef equivEquivIso {A B : FintypeCat} : A ‚âÉ B ‚âÉ (A ‚âÖ B) where\n  toFun e :=\n    { hom := e\n      inv := e.symm }\n  invFun i :=\n    { toFun := i.hom\n      invFun := i.inv\n      left_inv := congr_fun i.hom_inv_id\n      right_inv := congr_fun i.inv_hom_id }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"FintypeCat.equivEquivIso_apply_inv","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"A B : FintypeCat\ne : Equiv ‚ÜëA ‚ÜëB\na : ‚ÜëB\n‚ä¢ Eq ((FintypeCat.equivEquivIso e).inv a) (e.symm a)","decl":"/-- Equivalences between finite types are the same as isomorphisms in `FintypeCat`. -/\n@[simps]\ndef equivEquivIso {A B : FintypeCat} : A ‚âÉ B ‚âÉ (A ‚âÖ B) where\n  toFun e :=\n    { hom := e\n      inv := e.symm }\n  invFun i :=\n    { toFun := i.hom\n      invFun := i.inv\n      left_inv := congr_fun i.hom_inv_id\n      right_inv := congr_fun i.inv_hom_id }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"FintypeCat.instFiniteHom","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat\n‚ä¢ Finite (Quiver.Hom X Y)","decl":"instance (X Y : FintypeCat) : Finite (X ‚ü∂ Y) :=\n  inferInstanceAs <| Finite (X ‚Üí Y)\n\n"}
{"name":"FintypeCat.instFiniteIso","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat\n‚ä¢ Finite (CategoryTheory.Iso X Y)","decl":"instance (X Y : FintypeCat) : Finite (X ‚âÖ Y) :=\n  Finite.of_injective _ (fun _ _ h ‚Ü¶ Iso.ext h)\n\n"}
{"name":"FintypeCat.instFiniteAut","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X : FintypeCat\n‚ä¢ Finite (CategoryTheory.Aut X)","decl":"instance (X : FintypeCat) : Finite (Aut X) :=\n  inferInstanceAs <| Finite (X ‚âÖ X)\n\n"}
{"name":"FintypeCat.Skeleton.ext_iff","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat.Skeleton\n‚ä¢ Iff (Eq X Y) (Eq X.len Y.len)","decl":"@[ext]\ntheorem ext (X Y : Skeleton) : X.len = Y.len ‚Üí X = Y :=\n  ULift.ext _ _\n\n"}
{"name":"FintypeCat.Skeleton.ext","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat.Skeleton\na‚úù : Eq X.len Y.len\n‚ä¢ Eq X Y","decl":"@[ext]\ntheorem ext (X Y : Skeleton) : X.len = Y.len ‚Üí X = Y :=\n  ULift.ext _ _\n\n"}
{"name":"FintypeCat.Skeleton.is_skeletal","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ CategoryTheory.Skeletal FintypeCat.Skeleton","decl":"theorem is_skeletal : Skeletal Skeleton.{u} := fun X Y ‚ü®h‚ü© =>\n  ext _ _ <|\n    Fin.equiv_iff_eq.mp <|\n      Nonempty.intro <|\n        { toFun := fun x => (h.hom ‚ü®x‚ü©).down\n          invFun := fun x => (h.inv ‚ü®x‚ü©).down\n          left_inv := by\n            intro a\n            change ULift.down _ = _\n            rw [ULift.up_down]\n            change ((h.hom ‚â´ h.inv) _).down = _\n            simp\n            rfl\n          right_inv := by\n            intro a\n            change ULift.down _ = _\n            rw [ULift.up_down]\n            change ((h.inv ‚â´ h.hom) _).down = _\n            simp\n            rfl }\n\n"}
{"name":"FintypeCat.Skeleton.instFullIncl","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ FintypeCat.Skeleton.incl.Full","decl":"instance : incl.Full where map_surjective f := ‚ü®f, rfl‚ü©\n\n"}
{"name":"FintypeCat.Skeleton.instFaithfulIncl","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ FintypeCat.Skeleton.incl.Faithful","decl":"instance : incl.Faithful where\n\n"}
{"name":"FintypeCat.Skeleton.instEssSurjIncl","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ FintypeCat.Skeleton.incl.EssSurj","decl":"instance : incl.EssSurj :=\n  Functor.EssSurj.mk fun X =>\n    let F := Fintype.equivFin X\n    ‚ü®mk (Fintype.card X),\n      Nonempty.intro\n        { hom := F.symm ‚àò ULift.down\n          inv := ULift.up ‚àò F }‚ü©\n\n"}
{"name":"FintypeCat.Skeleton.instIsEquivalenceIncl","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ FintypeCat.Skeleton.incl.IsEquivalence","decl":"noncomputable instance : incl.IsEquivalence where\n\n"}
{"name":"FintypeCat.Skeleton.incl_mk_nat_card","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"n : Nat\n‚ä¢ Eq (Fintype.card ‚Üë(FintypeCat.Skeleton.incl.obj (FintypeCat.Skeleton.mk n))) n","decl":"@[simp]\ntheorem incl_mk_nat_card (n : ‚Ñï) : Fintype.card (incl.obj (mk n)) = n := by\n  convert Finset.card_fin n\n  apply Fintype.ofEquiv_card\n\n"}
{"name":"FintypeCat.isSkeleton","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ CategoryTheory.IsSkeletonOf FintypeCat FintypeCat.Skeleton FintypeCat.Skeleton.incl","decl":"/-- `Fintype.Skeleton` is a skeleton of `Fintype`. -/\nlemma isSkeleton : IsSkeletonOf FintypeCat Skeleton Skeleton.incl where\n  skel := Skeleton.is_skeletal\n  eqv := by infer_instance\n\n"}
{"name":"FintypeCat.uSwitchEquiv_naturality","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat\nf : Quiver.Hom X Y\nx : ‚Üë(FintypeCat.uSwitch.obj X)\n‚ä¢ Eq (f (X.uSwitchEquiv x)) (Y.uSwitchEquiv (FintypeCat.uSwitch.map f x))","decl":"lemma uSwitchEquiv_naturality {X Y : FintypeCat.{u}} (f : X ‚ü∂ Y)\n    (x : uSwitch.{u, v}.obj X) :\n    f (X.uSwitchEquiv x) = Y.uSwitchEquiv (uSwitch.map f x) := by\n  simp only [uSwitch, uSwitchEquiv, Equiv.trans_apply]\n  erw [Equiv.ulift_apply, Equiv.ulift_apply]\n  simp only [Equiv.symm_apply_apply]\n\n"}
{"name":"FintypeCat.uSwitchEquiv_symm_naturality","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat\nf : Quiver.Hom X Y\nx : ‚ÜëX\n‚ä¢ Eq (FintypeCat.uSwitch.map f (X.uSwitchEquiv.symm x)) (Y.uSwitchEquiv.symm (f x))","decl":"lemma uSwitchEquiv_symm_naturality {X Y : FintypeCat.{u}} (f : X ‚ü∂ Y) (x : X) :\n    uSwitch.map f (X.uSwitchEquiv.symm x) = Y.uSwitchEquiv.symm (f x) := by\n  rw [‚Üê Equiv.apply_eq_iff_eq_symm_apply, ‚Üê uSwitchEquiv_naturality f,\n    Equiv.apply_symm_apply]\n\n"}
{"name":"FintypeCat.uSwitch_map_uSwitch_map","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"X Y : FintypeCat\nf : Quiver.Hom X Y\n‚ä¢ Eq (FintypeCat.uSwitch.map (FintypeCat.uSwitch.map f)) (CategoryTheory.CategoryStruct.comp (FintypeCat.equivEquivIso ((FintypeCat.uSwitch.obj X).uSwitchEquiv.trans X.uSwitchEquiv)).hom (CategoryTheory.CategoryStruct.comp f (FintypeCat.equivEquivIso ((FintypeCat.uSwitch.obj Y).uSwitchEquiv.trans Y.uSwitchEquiv)).inv))","decl":"lemma uSwitch_map_uSwitch_map {X Y : FintypeCat.{u}} (f : X ‚ü∂ Y) :\n    uSwitch.map (uSwitch.map f) =\n    (equivEquivIso ((uSwitch.obj X).uSwitchEquiv.trans X.uSwitchEquiv)).hom ‚â´\n      f ‚â´ (equivEquivIso ((uSwitch.obj Y).uSwitchEquiv.trans\n      Y.uSwitchEquiv)).inv := by\n  ext x\n  simp only [comp_apply, equivEquivIso_apply_hom, Equiv.trans_apply]\n  rw [uSwitchEquiv_naturality f, ‚Üê uSwitchEquiv_naturality]\n  rfl\n\n"}
{"name":"FintypeCat.instIsEquivalenceUSwitch","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"‚ä¢ FintypeCat.uSwitch.IsEquivalence","decl":"instance : uSwitch.IsEquivalence :=\n  uSwitchEquivalence.isEquivalence_functor\n\n"}
{"name":"FunctorToFintypeCat.naturality","module":"Mathlib.CategoryTheory.FintypeCat","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C FintypeCat\nX Y : C\nœÉ : Quiver.Hom F G\nf : Quiver.Hom X Y\nx : ‚Üë(F.obj X)\n‚ä¢ Eq (œÉ.app Y (F.map f x)) (G.map f (œÉ.app X x))","decl":"lemma naturality (œÉ : F ‚ü∂ G) (f : X ‚ü∂ Y) (x : F.obj X) :\n    œÉ.app Y (F.map f x) = G.map f (œÉ.app X x) :=\n  congr_fun (œÉ.naturality f) x\n\n"}
