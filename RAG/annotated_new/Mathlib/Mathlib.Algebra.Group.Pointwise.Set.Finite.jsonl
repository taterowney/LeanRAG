{"name":"Set.finite_one","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : One α\n⊢ Set.Finite 1","decl":"@[to_additive (attr := simp)]\ntheorem finite_one : (1 : Set α).Finite :=\n  finite_singleton _\n\n"}
{"name":"Set.finite_zero","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : Zero α\n⊢ Set.Finite 0","decl":"@[to_additive (attr := simp)]\ntheorem finite_one : (1 : Set α).Finite :=\n  finite_singleton _\n\n"}
{"name":"Set.Finite.mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : Mul α\ns t : Set α\na✝¹ : s.Finite\na✝ : t.Finite\n⊢ (HMul.hMul s t).Finite","decl":"@[to_additive]\ntheorem Finite.mul : s.Finite → t.Finite → (s * t).Finite :=\n  Finite.image2 _\n\n"}
{"name":"Set.Finite.add","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : Add α\ns t : Set α\na✝¹ : s.Finite\na✝ : t.Finite\n⊢ (HAdd.hAdd s t).Finite","decl":"@[to_additive]\ntheorem Finite.mul : s.Finite → t.Finite → (s * t).Finite :=\n  Finite.image2 _\n\n"}
{"name":"Set.Finite.smul","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set α\nt : Set β\na✝¹ : s.Finite\na✝ : t.Finite\n⊢ (HSMul.hSMul s t).Finite","decl":"@[to_additive]\ntheorem Finite.smul : s.Finite → t.Finite → (s • t).Finite :=\n  Finite.image2 _\n\n"}
{"name":"Set.Finite.vadd","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set α\nt : Set β\na✝¹ : s.Finite\na✝ : t.Finite\n⊢ (HVAdd.hVAdd s t).Finite","decl":"@[to_additive]\ntheorem Finite.smul : s.Finite → t.Finite → (s • t).Finite :=\n  Finite.image2 _\n\n"}
{"name":"Set.Finite.smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set β\na : α\na✝ : s.Finite\n⊢ (HSMul.hSMul a s).Finite","decl":"@[to_additive]\ntheorem Finite.smul_set : s.Finite → (a • s).Finite :=\n  Finite.image _\n\n"}
{"name":"Set.Finite.vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set β\na : α\na✝ : s.Finite\n⊢ (HVAdd.hVAdd a s).Finite","decl":"@[to_additive]\ntheorem Finite.smul_set : s.Finite → (a • s).Finite :=\n  Finite.image _\n\n"}
{"name":"Set.Infinite.of_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : SMul α β\ns : Set β\na : α\na✝ : (HSMul.hSMul a s).Infinite\n⊢ s.Infinite","decl":"@[to_additive]\ntheorem Infinite.of_smul_set : (a • s).Infinite → s.Infinite :=\n  Infinite.of_image _\n\n"}
{"name":"Set.Infinite.of_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VAdd α β\ns : Set β\na : α\na✝ : (HVAdd.hVAdd a s).Infinite\n⊢ s.Infinite","decl":"@[to_additive]\ntheorem Infinite.of_smul_set : (a • s).Infinite → s.Infinite :=\n  Infinite.of_image _\n\n"}
{"name":"Set.Finite.vsub","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : VSub α β\ns t : Set β\nhs : s.Finite\nht : t.Finite\n⊢ (VSub.vsub s t).Finite","decl":"theorem Finite.vsub (hs : s.Finite) (ht : t.Finite) : Set.Finite (s -ᵥ t) :=\n  hs.image2 _ ht\n\n"}
{"name":"Set.finite_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsLeftCancelAdd α\ninst✝ : IsRightCancelAdd α\ns t : Set α\n⊢ Iff (HAdd.hAdd s t).Finite (Or (And s.Finite t.Finite) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"@[to_additive]\nlemma finite_mul : (s * t).Finite ↔ s.Finite ∧ t.Finite ∨ s = ∅ ∨ t = ∅ :=\n  finite_image2 (fun _ _ ↦ (mul_left_injective _).injOn) fun _ _ ↦ (mul_right_injective _).injOn\n\n"}
{"name":"Set.finite_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsLeftCancelMul α\ninst✝ : IsRightCancelMul α\ns t : Set α\n⊢ Iff (HMul.hMul s t).Finite (Or (And s.Finite t.Finite) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"@[to_additive]\nlemma finite_mul : (s * t).Finite ↔ s.Finite ∧ t.Finite ∨ s = ∅ ∨ t = ∅ :=\n  finite_image2 (fun _ _ ↦ (mul_left_injective _).injOn) fun _ _ ↦ (mul_right_injective _).injOn\n\n"}
{"name":"Set.infinite_mul","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : IsLeftCancelMul α\ninst✝ : IsRightCancelMul α\ns t : Set α\n⊢ Iff (HMul.hMul s t).Infinite (Or (And s.Infinite t.Nonempty) (And t.Infinite s.Nonempty))","decl":"@[to_additive]\nlemma infinite_mul : (s * t).Infinite ↔ s.Infinite ∧ t.Nonempty ∨ t.Infinite ∧ s.Nonempty :=\n  infinite_image2 (fun _ _ => (mul_left_injective _).injOn) fun _ _ => (mul_right_injective _).injOn\n\n"}
{"name":"Set.infinite_add","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝² : Add α\ninst✝¹ : IsLeftCancelAdd α\ninst✝ : IsRightCancelAdd α\ns t : Set α\n⊢ Iff (HAdd.hAdd s t).Infinite (Or (And s.Infinite t.Nonempty) (And t.Infinite s.Nonempty))","decl":"@[to_additive]\nlemma infinite_mul : (s * t).Infinite ↔ s.Infinite ∧ t.Nonempty ∨ t.Infinite ∧ s.Nonempty :=\n  infinite_image2 (fun _ _ => (mul_left_injective _).injOn) fun _ _ => (mul_right_injective _).injOn\n\n"}
{"name":"Set.finite_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\n⊢ Iff (Inv.inv s).Finite s.Finite","decl":"@[to_additive (attr := simp)] lemma finite_inv : s⁻¹.Finite ↔ s.Finite := by\n  rw [← image_inv_eq_inv, finite_image_iff inv_injective.injOn]\n\n"}
{"name":"Set.finite_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\n⊢ Iff (Neg.neg s).Finite s.Finite","decl":"@[to_additive (attr := simp)] lemma finite_inv : s⁻¹.Finite ↔ s.Finite := by\n  rw [← image_inv_eq_inv, finite_image_iff inv_injective.injOn]\n\n"}
{"name":"Set.infinite_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\n⊢ Iff (Inv.inv s).Infinite s.Infinite","decl":"@[to_additive (attr := simp)] lemma infinite_inv : s⁻¹.Infinite ↔ s.Infinite := finite_inv.not\n\n"}
{"name":"Set.infinite_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\n⊢ Iff (Neg.neg s).Infinite s.Infinite","decl":"@[to_additive (attr := simp)] lemma infinite_inv : s⁻¹.Infinite ↔ s.Infinite := finite_inv.not\n\n"}
{"name":"Set.Finite.inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\na✝ : s.Finite\n⊢ (Inv.inv s).Finite","decl":"@[to_additive] alias ⟨Finite.of_inv, Finite.inv⟩ := finite_inv\n\n"}
{"name":"Set.Finite.neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\na✝ : s.Finite\n⊢ (Neg.neg s).Finite","decl":"@[to_additive] alias ⟨Finite.of_inv, Finite.inv⟩ := finite_inv\n\n"}
{"name":"Set.Finite.of_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : InvolutiveInv α\ns : Set α\na✝ : (Inv.inv s).Finite\n⊢ s.Finite","decl":"@[to_additive] alias ⟨Finite.of_inv, Finite.inv⟩ := finite_inv\n\n"}
{"name":"Set.Finite.of_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : InvolutiveNeg α\ns : Set α\na✝ : (Neg.neg s).Finite\n⊢ s.Finite","decl":"@[to_additive] alias ⟨Finite.of_inv, Finite.inv⟩ := finite_inv\n\n"}
{"name":"Set.Finite.sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : Sub α\ns t : Set α\na✝¹ : s.Finite\na✝ : t.Finite\n⊢ (HSub.hSub s t).Finite","decl":"@[to_additive] lemma Finite.div : s.Finite → t.Finite → (s / t).Finite := .image2 _\n\n"}
{"name":"Set.Finite.div","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : Div α\ns t : Set α\na✝¹ : s.Finite\na✝ : t.Finite\n⊢ (HDiv.hDiv s t).Finite","decl":"@[to_additive] lemma Finite.div : s.Finite → t.Finite → (s / t).Finite := .image2 _\n\n"}
{"name":"Set.finite_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\n⊢ Iff (HSub.hSub s t).Finite (Or (And s.Finite t.Finite) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"@[to_additive]\nlemma finite_div : (s / t).Finite ↔ s.Finite ∧ t.Finite ∨ s = ∅ ∨ t = ∅ :=\n  finite_image2 (fun _ _ ↦ div_left_injective.injOn) fun _ _ ↦ div_right_injective.injOn\n\n"}
{"name":"Set.finite_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\n⊢ Iff (HDiv.hDiv s t).Finite (Or (And s.Finite t.Finite) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"@[to_additive]\nlemma finite_div : (s / t).Finite ↔ s.Finite ∧ t.Finite ∨ s = ∅ ∨ t = ∅ :=\n  finite_image2 (fun _ _ ↦ div_left_injective.injOn) fun _ _ ↦ div_right_injective.injOn\n\n"}
{"name":"Set.infinite_sub","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : AddGroup α\ns t : Set α\n⊢ Iff (HSub.hSub s t).Infinite (Or (And s.Infinite t.Nonempty) (And t.Infinite s.Nonempty))","decl":"@[to_additive]\nlemma infinite_div : (s / t).Infinite ↔ s.Infinite ∧ t.Nonempty ∨ t.Infinite ∧ s.Nonempty :=\n  infinite_image2 (fun _ _ ↦ div_left_injective.injOn) fun _ _ ↦ div_right_injective.injOn\n\n"}
{"name":"Set.infinite_div","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\ninst✝ : Group α\ns t : Set α\n⊢ Iff (HDiv.hDiv s t).Infinite (Or (And s.Infinite t.Nonempty) (And t.Infinite s.Nonempty))","decl":"@[to_additive]\nlemma infinite_div : (s / t).Infinite ↔ s.Infinite ∧ t.Nonempty ∨ t.Infinite ∧ s.Nonempty :=\n  infinite_image2 (fun _ _ ↦ div_left_injective.injOn) fun _ _ ↦ div_right_injective.injOn\n\n"}
{"name":"Set.finite_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\ns : Set β\n⊢ Iff (HSMul.hSMul a s).Finite s.Finite","decl":"@[to_additive (attr := simp)]\ntheorem finite_smul_set : (a • s).Finite ↔ s.Finite :=\n  finite_image_iff (MulAction.injective _).injOn\n\n"}
{"name":"Set.finite_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\ns : Set β\n⊢ Iff (HVAdd.hVAdd a s).Finite s.Finite","decl":"@[to_additive (attr := simp)]\ntheorem finite_smul_set : (a • s).Finite ↔ s.Finite :=\n  finite_image_iff (MulAction.injective _).injOn\n\n"}
{"name":"Set.infinite_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\ns : Set β\n⊢ Iff (HVAdd.hVAdd a s).Infinite s.Infinite","decl":"@[to_additive (attr := simp)]\ntheorem infinite_smul_set : (a • s).Infinite ↔ s.Infinite :=\n  infinite_image_iff (MulAction.injective _).injOn\n\n"}
{"name":"Set.infinite_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\ns : Set β\n⊢ Iff (HSMul.hSMul a s).Infinite s.Infinite","decl":"@[to_additive (attr := simp)]\ntheorem infinite_smul_set : (a • s).Infinite ↔ s.Infinite :=\n  infinite_image_iff (MulAction.injective _).injOn\n\n"}
{"name":"Set.Finite.of_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\ns : Set β\na✝ : (HSMul.hSMul a s).Finite\n⊢ s.Finite","decl":"@[to_additive] alias ⟨Finite.of_smul_set, _⟩ := finite_smul_set\n"}
{"name":"Set.Finite.of_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\ns : Set β\na✝ : (HVAdd.hVAdd a s).Finite\n⊢ s.Finite","decl":"@[to_additive] alias ⟨Finite.of_smul_set, _⟩ := finite_smul_set\n"}
{"name":"Set.Infinite.vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\na : α\ns : Set β\na✝ : s.Infinite\n⊢ (HVAdd.hVAdd a s).Infinite","decl":"@[to_additive] alias ⟨_, Infinite.smul_set⟩ := infinite_smul_set\n\n"}
{"name":"Set.Infinite.smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : MulAction α β\na : α\ns : Set β\na✝ : s.Infinite\n⊢ (HSMul.hSMul a s).Infinite","decl":"@[to_additive] alias ⟨_, Infinite.smul_set⟩ := infinite_smul_set\n\n"}
{"name":"Group.card_pow_eq_card_pow_card_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"G : Type u_5\ninst✝² : Group G\ninst✝¹ : Fintype G\nS : Set G\ninst✝ : (k : Nat) → DecidablePred fun x => Membership.mem (HPow.hPow S k) x\nk : Nat\na✝ : LE.le (Fintype.card G) k\n⊢ Eq (Fintype.card ↑(HPow.hPow S k)) (Fintype.card ↑(HPow.hPow S (Fintype.card G)))","decl":"@[to_additive]\ntheorem card_pow_eq_card_pow_card_univ [∀ k : ℕ, DecidablePred (· ∈ S ^ k)] :\n    ∀ k, Fintype.card G ≤ k → Fintype.card (↥(S ^ k)) = Fintype.card (↥(S ^ Fintype.card G)) := by\n  have hG : 0 < Fintype.card G := Fintype.card_pos\n  rcases S.eq_empty_or_nonempty with (rfl | ⟨a, ha⟩)\n  · refine fun k hk ↦ Fintype.card_congr ?_\n    rw [empty_pow (hG.trans_le hk).ne', empty_pow (ne_of_gt hG)]\n  have key : ∀ (a) (s t : Set G) [Fintype s] [Fintype t],\n      (∀ b : G, b ∈ s → b * a ∈ t) → Fintype.card s ≤ Fintype.card t := by\n    refine fun a s t _ _ h ↦ Fintype.card_le_of_injective (fun ⟨b, hb⟩ ↦ ⟨b * a, h b hb⟩) ?_\n    rintro ⟨b, hb⟩ ⟨c, hc⟩ hbc\n    exact Subtype.ext (mul_right_cancel (Subtype.ext_iff.mp hbc))\n  have mono : Monotone (fun n ↦ Fintype.card (↥(S ^ n)) : ℕ → ℕ) :=\n    monotone_nat_of_le_succ fun n ↦ key a _ _ fun b hb ↦ Set.mul_mem_mul hb ha\n  refine fun _ ↦ Nat.stabilises_of_monotone mono (fun n ↦ set_fintype_card_le_univ (S ^ n))\n    fun n h ↦ le_antisymm (mono (n + 1).le_succ) (key a⁻¹ (S ^ (n + 2)) (S ^ (n + 1)) ?_)\n  replace h₂ : S ^ n * {a} = S ^ (n + 1) := by\n    have : Fintype (S ^ n * Set.singleton a) := by\n      classical\n      apply fintypeMul\n    refine Set.eq_of_subset_of_card_le ?_ (le_trans (ge_of_eq h) ?_)\n    · exact mul_subset_mul Set.Subset.rfl (Set.singleton_subset_iff.mpr ha)\n    · convert key a (S ^ n) (S ^ n * {a}) fun b hb ↦ Set.mul_mem_mul hb (Set.mem_singleton a)\n  rw [pow_succ', ← h₂, ← mul_assoc, ← pow_succ', h₂, mul_singleton, forall_mem_image]\n  intro x hx\n  rwa [mul_inv_cancel_right]\n\n"}
{"name":"AddGroup.card_nsmul_eq_card_nsmul_card_univ","module":"Mathlib.Algebra.Group.Pointwise.Set.Finite","initialProofState":"G : Type u_5\ninst✝² : AddGroup G\ninst✝¹ : Fintype G\nS : Set G\ninst✝ : (k : Nat) → DecidablePred fun x => Membership.mem (HSMul.hSMul k S) x\nk : Nat\na✝ : LE.le (Fintype.card G) k\n⊢ Eq (Fintype.card ↑(HSMul.hSMul k S)) (Fintype.card ↑(HSMul.hSMul (Fintype.card G) S))","decl":"@[to_additive]\ntheorem card_pow_eq_card_pow_card_univ [∀ k : ℕ, DecidablePred (· ∈ S ^ k)] :\n    ∀ k, Fintype.card G ≤ k → Fintype.card (↥(S ^ k)) = Fintype.card (↥(S ^ Fintype.card G)) := by\n  have hG : 0 < Fintype.card G := Fintype.card_pos\n  rcases S.eq_empty_or_nonempty with (rfl | ⟨a, ha⟩)\n  · refine fun k hk ↦ Fintype.card_congr ?_\n    rw [empty_pow (hG.trans_le hk).ne', empty_pow (ne_of_gt hG)]\n  have key : ∀ (a) (s t : Set G) [Fintype s] [Fintype t],\n      (∀ b : G, b ∈ s → b * a ∈ t) → Fintype.card s ≤ Fintype.card t := by\n    refine fun a s t _ _ h ↦ Fintype.card_le_of_injective (fun ⟨b, hb⟩ ↦ ⟨b * a, h b hb⟩) ?_\n    rintro ⟨b, hb⟩ ⟨c, hc⟩ hbc\n    exact Subtype.ext (mul_right_cancel (Subtype.ext_iff.mp hbc))\n  have mono : Monotone (fun n ↦ Fintype.card (↥(S ^ n)) : ℕ → ℕ) :=\n    monotone_nat_of_le_succ fun n ↦ key a _ _ fun b hb ↦ Set.mul_mem_mul hb ha\n  refine fun _ ↦ Nat.stabilises_of_monotone mono (fun n ↦ set_fintype_card_le_univ (S ^ n))\n    fun n h ↦ le_antisymm (mono (n + 1).le_succ) (key a⁻¹ (S ^ (n + 2)) (S ^ (n + 1)) ?_)\n  replace h₂ : S ^ n * {a} = S ^ (n + 1) := by\n    have : Fintype (S ^ n * Set.singleton a) := by\n      classical\n      apply fintypeMul\n    refine Set.eq_of_subset_of_card_le ?_ (le_trans (ge_of_eq h) ?_)\n    · exact mul_subset_mul Set.Subset.rfl (Set.singleton_subset_iff.mpr ha)\n    · convert key a (S ^ n) (S ^ n * {a}) fun b hb ↦ Set.mul_mem_mul hb (Set.mem_singleton a)\n  rw [pow_succ', ← h₂, ← mul_assoc, ← pow_succ', h₂, mul_singleton, forall_mem_image]\n  intro x hx\n  rwa [mul_inv_cancel_right]\n\n"}
