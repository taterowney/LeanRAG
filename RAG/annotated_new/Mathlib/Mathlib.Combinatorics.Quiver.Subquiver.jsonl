{"name":"Quiver.Total.ext","module":"Mathlib.Combinatorics.Quiver.Subquiver","initialProofState":"V : Type u\ninst✝ : Quiver V\nx y : Quiver.Total V\nleft : Eq x.left y.left\nright : Eq x.right y.right\nhom : HEq x.hom y.hom\n⊢ Eq x y","decl":"/-- `Total V` is the type of _all_ arrows of `V`. -/\n-- Porting note: no hasNonemptyInstance linter yet https://github.com/leanprover-community/mathlib4/issues/5171\n@[ext]\nstructure Total (V : Type u) [Quiver.{v} V] : Sort max (u + 1) v where\n  /-- the source vertex of an arrow -/\n  left : V\n  /-- the target vertex of an arrow -/\n  right : V\n  /-- an arrow -/\n  hom : left ⟶ right\n\n"}
{"name":"Quiver.Total.mk.injEq","module":"Mathlib.Combinatorics.Quiver.Subquiver","initialProofState":"V : Type u\ninst✝ : Quiver V\nleft✝ right✝ : V\nhom✝ : Quiver.Hom left✝ right✝\nleft right : V\nhom : Quiver.Hom left right\n⊢ Eq (Eq { left := left✝, right := right✝, hom := hom✝ } { left := left, right := right, hom := hom }) (And (Eq left✝ left) (And (Eq right✝ right) (HEq hom✝ hom)))","decl":"/-- `Total V` is the type of _all_ arrows of `V`. -/\n-- Porting note: no hasNonemptyInstance linter yet https://github.com/leanprover-community/mathlib4/issues/5171\n@[ext]\nstructure Total (V : Type u) [Quiver.{v} V] : Sort max (u + 1) v where\n  /-- the source vertex of an arrow -/\n  left : V\n  /-- the target vertex of an arrow -/\n  right : V\n  /-- an arrow -/\n  hom : left ⟶ right\n\n"}
{"name":"Quiver.Total.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Quiver.Subquiver","initialProofState":"V : Type u\ninst✝¹ : Quiver V\ninst✝ : SizeOf V\nleft right : V\nhom : Quiver.Hom left right\n⊢ Eq (SizeOf.sizeOf { left := left, right := right, hom := hom }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf left)) (SizeOf.sizeOf right)) (SizeOf.sizeOf hom))","decl":"/-- `Total V` is the type of _all_ arrows of `V`. -/\n-- Porting note: no hasNonemptyInstance linter yet https://github.com/leanprover-community/mathlib4/issues/5171\n@[ext]\nstructure Total (V : Type u) [Quiver.{v} V] : Sort max (u + 1) v where\n  /-- the source vertex of an arrow -/\n  left : V\n  /-- the target vertex of an arrow -/\n  right : V\n  /-- an arrow -/\n  hom : left ⟶ right\n\n"}
{"name":"Quiver.Total.mk.inj","module":"Mathlib.Combinatorics.Quiver.Subquiver","initialProofState":"V : Type u\ninst✝ : Quiver V\nleft✝ right✝ : V\nhom✝ : Quiver.Hom left✝ right✝\nleft right : V\nhom : Quiver.Hom left right\nx✝ : Eq { left := left✝, right := right✝, hom := hom✝ } { left := left, right := right, hom := hom }\n⊢ And (Eq left✝ left) (And (Eq right✝ right) (HEq hom✝ hom))","decl":"/-- `Total V` is the type of _all_ arrows of `V`. -/\n-- Porting note: no hasNonemptyInstance linter yet https://github.com/leanprover-community/mathlib4/issues/5171\n@[ext]\nstructure Total (V : Type u) [Quiver.{v} V] : Sort max (u + 1) v where\n  /-- the source vertex of an arrow -/\n  left : V\n  /-- the target vertex of an arrow -/\n  right : V\n  /-- an arrow -/\n  hom : left ⟶ right\n\n"}
{"name":"Quiver.Total.ext_iff","module":"Mathlib.Combinatorics.Quiver.Subquiver","initialProofState":"V : Type u\ninst✝ : Quiver V\nx y : Quiver.Total V\n⊢ Iff (Eq x y) (And (Eq x.left y.left) (And (Eq x.right y.right) (HEq x.hom y.hom)))","decl":"/-- `Total V` is the type of _all_ arrows of `V`. -/\n-- Porting note: no hasNonemptyInstance linter yet https://github.com/leanprover-community/mathlib4/issues/5171\n@[ext]\nstructure Total (V : Type u) [Quiver.{v} V] : Sort max (u + 1) v where\n  /-- the source vertex of an arrow -/\n  left : V\n  /-- the target vertex of an arrow -/\n  right : V\n  /-- an arrow -/\n  hom : left ⟶ right\n\n"}
