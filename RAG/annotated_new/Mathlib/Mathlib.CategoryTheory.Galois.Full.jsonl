{"name":"CategoryTheory.PreGaloisCategory.exists_lift_of_mono_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Full","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝³ : CategoryTheory.GaloisCategory C\ninst✝² : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\nY : Action FintypeCat (MonCat.of (CategoryTheory.Aut F))\ni : Quiver.Hom Y ((CategoryTheory.PreGaloisCategory.functorToAction F).obj X)\ninst✝¹ : CategoryTheory.Mono i\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected Y\n⊢ Exists fun Z => Exists fun f => Exists fun u => And (CategoryTheory.PreGaloisCategory.IsConnected Z) (And (CategoryTheory.Mono f) (Eq i (CategoryTheory.CategoryStruct.comp u.hom ((CategoryTheory.PreGaloisCategory.functorToAction F).map f))))","decl":"/--\nLet `X` be an object of a Galois category with fiber functor `F` and `Y` a sub-`Aut F`-set\nof `F.obj X`, on which `Aut F` acts transitively (i.e. which is connected in the Galois category\nof finite `Aut F`-sets). Then there exists a connected sub-object `Z` of `X` and an isomorphism\n`Y ≅ F.obj X` as `Aut F`-sets such that the obvious triangle commutes.\n\nFor a version without the connectedness assumption, see `exists_lift_of_mono`.\n-/\nlemma exists_lift_of_mono_of_isConnected (X : C) (Y : Action FintypeCat.{u} (MonCat.of (Aut F)))\n    (i : Y ⟶ (functorToAction F).obj X) [Mono i] [IsConnected Y] : ∃ (Z : C) (f : Z ⟶ X)\n    (u : Y ≅ (functorToAction F).obj Z),\n    IsConnected Z ∧ Mono f ∧ i = u.hom ≫ (functorToAction F).map f := by\n  obtain ⟨y⟩ := nonempty_fiber_of_isConnected (forget₂ _ FintypeCat) Y\n  obtain ⟨Z, f, z, hz, hc, hm⟩ := fiber_in_connected_component F X (i.hom y)\n  have : IsConnected ((functorToAction F).obj Z) := PreservesIsConnected.preserves\n  obtain ⟨u, hu⟩ := connected_component_unique\n    (forget₂ (Action FintypeCat (MonCat.of (Aut F))) FintypeCat) (B := (functorToAction F).obj Z)\n    y z i ((functorToAction F).map f) hz.symm\n  refine ⟨Z, f, u, hc, hm, ?_⟩\n  apply evaluation_injective_of_isConnected\n    (forget₂ (Action FintypeCat (MonCat.of (Aut F))) FintypeCat) Y ((functorToAction F).obj X) y\n  suffices h : i.hom y = F.map f z by simpa [hu]\n  exact hz.symm\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_lift_of_mono","module":"Mathlib.CategoryTheory.Galois.Full","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C FintypeCat\ninst✝² : CategoryTheory.GaloisCategory C\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\nY : Action FintypeCat (MonCat.of (CategoryTheory.Aut F))\ni : Quiver.Hom Y ((CategoryTheory.PreGaloisCategory.functorToAction F).obj X)\ninst✝ : CategoryTheory.Mono i\n⊢ Exists fun Z => Exists fun f => Exists fun u => And (CategoryTheory.Mono f) (Eq (CategoryTheory.CategoryStruct.comp u.hom ((CategoryTheory.PreGaloisCategory.functorToAction F).map f)) i)","decl":"/--\nLet `X` be an object of a Galois category with fiber functor `F` and `Y` a sub-`Aut F`-set\nof `F.obj X`. Then there exists a sub-object `Z` of `X` and an isomorphism\n`Y ≅ F.obj X` as `Aut F`-sets such that the obvious triangle commutes.\n-/\nlemma exists_lift_of_mono (X : C) (Y : Action FintypeCat.{u} (MonCat.of (Aut F)))\n    (i : Y ⟶ (functorToAction F).obj X) [Mono i] : ∃ (Z : C) (f : Z ⟶ X)\n    (u : Y ≅ (functorToAction F).obj Z), Mono f ∧ u.hom ≫ (functorToAction F).map f = i := by\n  obtain ⟨ι, hf, f, t, hc⟩ := has_decomp_connected_components' Y\n  let i' (j : ι) : f j ⟶ (functorToAction F).obj X := Sigma.ι f j ≫ t.hom ≫ i\n  have (j : ι) : Mono (i' j) :=\n    have : Mono (Sigma.ι f j) := MonoCoprod.mono_ι f j\n    have : Mono (t.hom ≫ i) := mono_comp _ _\n    mono_comp _ _\n  choose gZ gf gu _ _ h using fun i ↦ exists_lift_of_mono_of_isConnected F X (f i) (i' i)\n  let is2 : (functorToAction F).obj (∐ gZ) ≅ ∐ fun i => (functorToAction F).obj (gZ i) :=\n    PreservesCoproduct.iso (functorToAction F) gZ\n  let u' : ∐ f ≅ ∐ fun i => (functorToAction F).obj (gZ i) := Sigma.mapIso gu\n  have heq : (functorToAction F).map (Sigma.desc gf) = (t.symm ≪≫ u' ≪≫ is2.symm).inv ≫ i := by\n    simp only [Iso.trans_inv, Iso.symm_inv, Category.assoc]\n    rw [← Iso.inv_comp_eq]\n    refine Sigma.hom_ext _ _ (fun j ↦ ?_)\n    suffices (functorToAction F).map (gf j) = (gu j).inv ≫ i' j by\n      simpa [is2, u']\n    simp only [h, Iso.inv_hom_id_assoc]\n  refine ⟨∐ gZ, Sigma.desc gf, t.symm ≪≫ u' ≪≫ is2.symm, ?_, by simp [heq]⟩\n  · exact mono_of_mono_map (functorToAction F) (heq ▸ mono_comp _ _)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.functorToAction_full","module":"Mathlib.CategoryTheory.Galois.Full","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C FintypeCat\n⊢ (CategoryTheory.PreGaloisCategory.functorToAction F).Full","decl":"/-- The by a fiber functor `F : C ⥤ FintypeCat` induced functor `functorToAction F` to\nfinite `Aut F`-sets is full. -/\ninstance functorToAction_full : Functor.Full (functorToAction F) where\n  map_surjective {X Y} f := by\n    let u : (functorToAction F).obj X ⟶ (functorToAction F).obj X ⨯ (functorToAction F).obj Y :=\n      prod.lift (𝟙 _) f\n    let i : (functorToAction F).obj X ⟶ (functorToAction F).obj (X ⨯ Y) :=\n      u ≫ (PreservesLimitPair.iso (functorToAction F) X Y).inv\n    have : Mono i := by\n      have : Mono (u ≫ prod.fst) := prod.lift_fst (𝟙 _) f ▸ inferInstance\n      have : Mono u := mono_of_mono u prod.fst\n      apply mono_comp u _\n    obtain ⟨Z, g, v, _, hvgi⟩ := exists_lift_of_mono F (Limits.prod X Y)\n      ((functorToAction F).obj X) i\n    let ψ : Z ⟶ X := g ≫ prod.fst\n    have hgvi : (functorToAction F).map g = v.inv ≫ i := by simp [← hvgi]\n    have : IsIso ((functorToAction F).map ψ) := by\n      simp only [map_comp, hgvi, Category.assoc, ψ]\n      have : IsIso (i ≫ (functorToAction F).map prod.fst) := by\n        suffices h : IsIso (𝟙 ((functorToAction F).obj X)) by simpa [i, u]\n        infer_instance\n      apply IsIso.comp_isIso\n    have : IsIso ψ := isIso_of_reflects_iso ψ (functorToAction F)\n    use inv ψ ≫ g ≫ prod.snd\n    rw [← cancel_epi ((functorToAction F).map ψ)]\n    ext (z : F.obj Z)\n    simp [-FintypeCat.comp_apply, -Action.comp_hom, i, u, ψ, hgvi]\n\n"}
