{"name":"CategoryTheory.PreGaloisCategory.exists_lift_of_mono_of_isConnected","module":"Mathlib.CategoryTheory.Galois.Full","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C FintypeCat\ninstâœÂ³ : CategoryTheory.GaloisCategory C\ninstâœÂ² : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\nY : Action FintypeCat (MonCat.of (CategoryTheory.Aut F))\ni : Quiver.Hom Y ((CategoryTheory.PreGaloisCategory.functorToAction F).obj X)\ninstâœÂ¹ : CategoryTheory.Mono i\ninstâœ : CategoryTheory.PreGaloisCategory.IsConnected Y\nâŠ¢ Exists fun Z => Exists fun f => Exists fun u => And (CategoryTheory.PreGaloisCategory.IsConnected Z) (And (CategoryTheory.Mono f) (Eq i (CategoryTheory.CategoryStruct.comp u.hom ((CategoryTheory.PreGaloisCategory.functorToAction F).map f))))","decl":"/--\nLet `X` be an object of a Galois category with fiber functor `F` and `Y` a sub-`Aut F`-set\nof `F.obj X`, on which `Aut F` acts transitively (i.e. which is connected in the Galois category\nof finite `Aut F`-sets). Then there exists a connected sub-object `Z` of `X` and an isomorphism\n`Y â‰… F.obj X` as `Aut F`-sets such that the obvious triangle commutes.\n\nFor a version without the connectedness assumption, see `exists_lift_of_mono`.\n-/\nlemma exists_lift_of_mono_of_isConnected (X : C) (Y : Action FintypeCat.{u} (MonCat.of (Aut F)))\n    (i : Y âŸ¶ (functorToAction F).obj X) [Mono i] [IsConnected Y] : âˆƒ (Z : C) (f : Z âŸ¶ X)\n    (u : Y â‰… (functorToAction F).obj Z),\n    IsConnected Z âˆ§ Mono f âˆ§ i = u.hom â‰« (functorToAction F).map f := by\n  obtain âŸ¨yâŸ© := nonempty_fiber_of_isConnected (forgetâ‚‚ _ FintypeCat) Y\n  obtain âŸ¨Z, f, z, hz, hc, hmâŸ© := fiber_in_connected_component F X (i.hom y)\n  have : IsConnected ((functorToAction F).obj Z) := PreservesIsConnected.preserves\n  obtain âŸ¨u, huâŸ© := connected_component_unique\n    (forgetâ‚‚ (Action FintypeCat (MonCat.of (Aut F))) FintypeCat) (B := (functorToAction F).obj Z)\n    y z i ((functorToAction F).map f) hz.symm\n  refine âŸ¨Z, f, u, hc, hm, ?_âŸ©\n  apply evaluation_injective_of_isConnected\n    (forgetâ‚‚ (Action FintypeCat (MonCat.of (Aut F))) FintypeCat) Y ((functorToAction F).obj X) y\n  suffices h : i.hom y = F.map f z by simpa [hu]\n  exact hz.symm\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_lift_of_mono","module":"Mathlib.CategoryTheory.Galois.Full","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C FintypeCat\ninstâœÂ² : CategoryTheory.GaloisCategory C\ninstâœÂ¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\nY : Action FintypeCat (MonCat.of (CategoryTheory.Aut F))\ni : Quiver.Hom Y ((CategoryTheory.PreGaloisCategory.functorToAction F).obj X)\ninstâœ : CategoryTheory.Mono i\nâŠ¢ Exists fun Z => Exists fun f => Exists fun u => And (CategoryTheory.Mono f) (Eq (CategoryTheory.CategoryStruct.comp u.hom ((CategoryTheory.PreGaloisCategory.functorToAction F).map f)) i)","decl":"/--\nLet `X` be an object of a Galois category with fiber functor `F` and `Y` a sub-`Aut F`-set\nof `F.obj X`. Then there exists a sub-object `Z` of `X` and an isomorphism\n`Y â‰… F.obj X` as `Aut F`-sets such that the obvious triangle commutes.\n-/\nlemma exists_lift_of_mono (X : C) (Y : Action FintypeCat.{u} (MonCat.of (Aut F)))\n    (i : Y âŸ¶ (functorToAction F).obj X) [Mono i] : âˆƒ (Z : C) (f : Z âŸ¶ X)\n    (u : Y â‰… (functorToAction F).obj Z), Mono f âˆ§ u.hom â‰« (functorToAction F).map f = i := by\n  obtain âŸ¨Î¹, hf, f, t, hcâŸ© := has_decomp_connected_components' Y\n  let i' (j : Î¹) : f j âŸ¶ (functorToAction F).obj X := Sigma.Î¹ f j â‰« t.hom â‰« i\n  have (j : Î¹) : Mono (i' j) :=\n    have : Mono (Sigma.Î¹ f j) := MonoCoprod.mono_Î¹ f j\n    have : Mono (t.hom â‰« i) := mono_comp _ _\n    mono_comp _ _\n  choose gZ gf gu _ _ h using fun i â†¦ exists_lift_of_mono_of_isConnected F X (f i) (i' i)\n  let is2 : (functorToAction F).obj (âˆ gZ) â‰… âˆ fun i => (functorToAction F).obj (gZ i) :=\n    PreservesCoproduct.iso (functorToAction F) gZ\n  let u' : âˆ f â‰… âˆ fun i => (functorToAction F).obj (gZ i) := Sigma.mapIso gu\n  have heq : (functorToAction F).map (Sigma.desc gf) = (t.symm â‰ªâ‰« u' â‰ªâ‰« is2.symm).inv â‰« i := by\n    simp only [Iso.trans_inv, Iso.symm_inv, Category.assoc]\n    rw [â† Iso.inv_comp_eq]\n    refine Sigma.hom_ext _ _ (fun j â†¦ ?_)\n    suffices (functorToAction F).map (gf j) = (gu j).inv â‰« i' j by\n      simpa [is2, u']\n    simp only [h, Iso.inv_hom_id_assoc]\n  refine âŸ¨âˆ gZ, Sigma.desc gf, t.symm â‰ªâ‰« u' â‰ªâ‰« is2.symm, ?_, by simp [heq]âŸ©\n  Â· exact mono_of_mono_map (functorToAction F) (heq â–¸ mono_comp _ _)\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.functorToAction_full","module":"Mathlib.CategoryTheory.Galois.Full","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C FintypeCat\nâŠ¢ (CategoryTheory.PreGaloisCategory.functorToAction F).Full","decl":"/-- The by a fiber functor `F : C â¥¤ FintypeCat` induced functor `functorToAction F` to\nfinite `Aut F`-sets is full. -/\ninstance functorToAction_full : Functor.Full (functorToAction F) where\n  map_surjective {X Y} f := by\n    let u : (functorToAction F).obj X âŸ¶ (functorToAction F).obj X â¨¯ (functorToAction F).obj Y :=\n      prod.lift (ğŸ™ _) f\n    let i : (functorToAction F).obj X âŸ¶ (functorToAction F).obj (X â¨¯ Y) :=\n      u â‰« (PreservesLimitPair.iso (functorToAction F) X Y).inv\n    have : Mono i := by\n      have : Mono (u â‰« prod.fst) := prod.lift_fst (ğŸ™ _) f â–¸ inferInstance\n      have : Mono u := mono_of_mono u prod.fst\n      apply mono_comp u _\n    obtain âŸ¨Z, g, v, _, hvgiâŸ© := exists_lift_of_mono F (Limits.prod X Y)\n      ((functorToAction F).obj X) i\n    let Ïˆ : Z âŸ¶ X := g â‰« prod.fst\n    have hgvi : (functorToAction F).map g = v.inv â‰« i := by simp [â† hvgi]\n    have : IsIso ((functorToAction F).map Ïˆ) := by\n      simp only [map_comp, hgvi, Category.assoc, Ïˆ]\n      have : IsIso (i â‰« (functorToAction F).map prod.fst) := by\n        suffices h : IsIso (ğŸ™ ((functorToAction F).obj X)) by simpa [i, u]\n        infer_instance\n      apply IsIso.comp_isIso\n    have : IsIso Ïˆ := isIso_of_reflects_iso Ïˆ (functorToAction F)\n    use inv Ïˆ â‰« g â‰« prod.snd\n    rw [â† cancel_epi ((functorToAction F).map Ïˆ)]\n    ext (z : F.obj Z)\n    simp [-FintypeCat.comp_apply, -Action.comp_hom, i, u, Ïˆ, hgvi]\n\n"}
