{"name":"Fin.instIsCancelAdd","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\n⊢ IsCancelAdd (Fin n)","decl":"/-- Note this is more general than `Fin.addCommGroup` as it applies (vacuously) to `Fin 0` too. -/\ninstance instIsCancelAdd (n : ℕ) : IsCancelAdd (Fin n) where\n  add_left_cancel := Nat.casesOn n finZeroElim fun _i _ _ _ ↦ add_left_cancel\n  add_right_cancel := Nat.casesOn n finZeroElim fun _i _ _ _ ↦ add_right_cancel\n\n"}
{"name":"Fin.coe_sub_one","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\na : Fin (HAdd.hAdd n 1)\n⊢ Eq (↑(HSub.hSub a 1)) (ite (Eq a 0) n (HSub.hSub (↑a) 1))","decl":"lemma coe_sub_one (a : Fin (n + 1)) : ↑(a - 1) = if a = 0 then n else a - 1 := by\n  cases n\n  · simp\n  split_ifs with h\n  · simp [h]\n  rw [sub_eq_add_neg, val_add_eq_ite, coe_neg_one, if_pos, Nat.add_comm, Nat.add_sub_add_left]\n  conv_rhs => rw [Nat.add_comm]\n  rw [Nat.add_le_add_iff_left, Nat.one_le_iff_ne_zero]\n  rwa [Fin.ext_iff] at h\n\n"}
{"name":"Fin.lt_sub_iff","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LT.lt a (HSub.hSub a b)) (LT.lt a b)","decl":"@[simp]\nlemma lt_sub_iff {n : ℕ} {a b : Fin n} : a < a - b ↔ a < b := by\n  cases' n with n\n  · exact a.elim0\n  constructor\n  · contrapose!\n    intro h\n    obtain ⟨l, hl⟩ := Nat.exists_eq_add_of_le (Fin.not_lt.mp h)\n    simpa only [Fin.not_lt, le_iff_val_le_val, sub_def, hl, ← Nat.add_assoc, Nat.add_mod_left,\n      Nat.mod_eq_of_lt, Nat.sub_add_cancel b.is_lt.le] using\n        (le_trans (mod_le _ _) (le_add_left _ _))\n  · intro h\n    rw [lt_iff_val_lt_val, sub_def]\n    simp only\n    obtain ⟨k, hk⟩ := Nat.exists_eq_add_of_lt b.is_lt\n    have : n + 1 - b = k + 1 := by\n      simp_rw [hk, Nat.add_assoc, Nat.add_sub_cancel_left]\n      -- simp_rw because, otherwise, rw tries to rewrite inside `b : Fin (n + 1)`\n    rw [this, Nat.mod_eq_of_lt (hk.ge.trans_lt' ?_), Nat.lt_add_left_iff_pos] <;>\n    omega\n\n"}
{"name":"Fin.sub_le_iff","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LE.le (HSub.hSub a b) a) (LE.le b a)","decl":"@[simp]\nlemma sub_le_iff {n : ℕ} {a b : Fin n} : a - b ≤ a ↔ b ≤ a := by\n  rw [← not_iff_not, Fin.not_le, Fin.not_le, lt_sub_iff]\n\n"}
{"name":"Fin.lt_one_iff","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\nx : Fin (HAdd.hAdd n 2)\n⊢ Iff (LT.lt x 1) (Eq x 0)","decl":"@[simp]\nlemma lt_one_iff {n : ℕ} (x : Fin (n + 2)) : x < 1 ↔ x = 0 := by\n  simp [lt_iff_val_lt_val, Fin.ext_iff]\n\n"}
{"name":"Fin.lt_sub_one_iff","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\nk : Fin (HAdd.hAdd n 2)\n⊢ Iff (LT.lt k (HSub.hSub k 1)) (Eq k 0)","decl":"lemma lt_sub_one_iff {k : Fin (n + 2)} : k < k - 1 ↔ k = 0 := by\n  simp\n\n"}
{"name":"Fin.le_sub_one_iff","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\nk : Fin (HAdd.hAdd n 1)\n⊢ Iff (LE.le k (HSub.hSub k 1)) (Eq k 0)","decl":"@[simp] lemma le_sub_one_iff {k : Fin (n + 1)} : k ≤ k - 1 ↔ k = 0 := by\n  cases n\n  · simp [fin_one_eq_zero k]\n  simp only [le_def]\n  rw [← lt_sub_one_iff, le_iff_lt_or_eq, val_fin_lt, val_inj, lt_sub_one_iff, or_iff_left_iff_imp,\n    eq_comm, sub_eq_iff_eq_add]\n  simp\n\n"}
{"name":"Fin.sub_one_lt_iff","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\nk : Fin (HAdd.hAdd n 1)\n⊢ Iff (LT.lt (HSub.hSub k 1) k) (LT.lt 0 k)","decl":"lemma sub_one_lt_iff {k : Fin (n + 1)} : k - 1 < k ↔ 0 < k :=\n  not_iff_not.1 <| by simp only [lt_def, not_lt, val_fin_le, le_sub_one_iff, le_zero_iff]\n\n"}
{"name":"Fin.neg_last","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Neg.neg (Fin.last n)) 1","decl":"@[simp] lemma neg_last (n : ℕ) : -Fin.last n = 1 := by simp [neg_eq_iff_add_eq_zero]\n\n"}
{"name":"Fin.neg_natCast_eq_one","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Neg.neg ↑n) 1","decl":"lemma neg_natCast_eq_one (n : ℕ) : -(n : Fin (n + 1)) = 1 := by\n  simp only [natCast_eq_last, neg_last]\n\n"}
{"name":"Fin.rev_add","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Eq (HAdd.hAdd a b).rev (HSub.hSub a.rev b)","decl":"lemma rev_add (a b : Fin n) : rev (a + b) = rev a - b := by\n  cases' n\n  · exact a.elim0\n  rw [← last_sub, ← last_sub, sub_add_eq_sub_sub]\n\n"}
{"name":"Fin.rev_sub","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Eq (HSub.hSub a b).rev (HAdd.hAdd a.rev b)","decl":"lemma rev_sub (a b : Fin n) : rev (a - b) = rev a + b := by\n  rw [rev_eq_iff, rev_add, rev_rev]\n\n"}
{"name":"Fin.add_lt_left_iff","module":"Mathlib.Algebra.Group.Fin.Basic","initialProofState":"n : Nat\na b : Fin n\n⊢ Iff (LT.lt (HAdd.hAdd a b) a) (LT.lt b.rev a)","decl":"lemma add_lt_left_iff {n : ℕ} {a b : Fin n} : a + b < a ↔ rev b < a := by\n  rw [← rev_lt_rev, Iff.comm, ← rev_lt_rev, rev_add, lt_sub_iff, rev_rev]\n\n"}
