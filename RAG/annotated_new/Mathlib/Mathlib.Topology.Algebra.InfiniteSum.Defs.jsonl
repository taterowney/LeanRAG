{"name":"tsum_def","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_4\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nβ : Type u_5\nf : β → α\n⊢ Eq (tsum f) (dite (Summable f) (fun h => ite (Function.support f).Finite (finsum f) (Exists.choose h)) fun h => 0)","decl":"open scoped Classical in\n/-- `∏' i, f i` is the product of `f` if it exists and is unconditionally convergent,\nor 1 otherwise. -/\n@[to_additive \"`∑' i, f i` is the sum of `f` if it exists and is unconditionally convergent,\nor 0 otherwise.\"]\nnoncomputable irreducible_def tprod {β} (f : β → α) :=\n  if h : Multipliable f then\n  /- Note that the product might not be uniquely defined if the topology is not separated.\n  When the multiplicative support of `f` is finite, we make the most reasonable choice to use the\n  product over the multiplicative support. Otherwise, we choose arbitrarily an `a` satisfying\n  `HasProd f a`. -/\n    if (mulSupport f).Finite then finprod f\n    else h.choose\n  else 1\n\n-- see Note [operator precedence of big operators]\n"}
{"name":"tprod_def","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_4\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nβ : Type u_5\nf : β → α\n⊢ Eq (tprod f) (dite (Multipliable f) (fun h => ite (Function.mulSupport f).Finite (finprod f) (Exists.choose h)) fun h => 1)","decl":"open scoped Classical in\n/-- `∏' i, f i` is the product of `f` if it exists and is unconditionally convergent,\nor 1 otherwise. -/\n@[to_additive \"`∑' i, f i` is the sum of `f` if it exists and is unconditionally convergent,\nor 0 otherwise.\"]\nnoncomputable irreducible_def tprod {β} (f : β → α) :=\n  if h : Multipliable f then\n  /- Note that the product might not be uniquely defined if the topology is not separated.\n  When the multiplicative support of `f` is finite, we make the most reasonable choice to use the\n  product over the multiplicative support. Otherwise, we choose arbitrarily an `a` satisfying\n  `HasProd f a`. -/\n    if (mulSupport f).Finite then finprod f\n    else h.choose\n  else 1\n\n-- see Note [operator precedence of big operators]\n"}
{"name":"HasProd.multipliable","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\nh : HasProd f a\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem HasProd.multipliable (h : HasProd f a) : Multipliable f :=\n  ⟨a, h⟩\n\n"}
{"name":"HasSum.summable","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\nh : HasSum f a\n⊢ Summable f","decl":"@[to_additive]\ntheorem HasProd.multipliable (h : HasProd f a) : Multipliable f :=\n  ⟨a, h⟩\n\n"}
{"name":"tprod_eq_one_of_not_multipliable","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nh : Not (Multipliable f)\n⊢ Eq (tprod fun b => f b) 1","decl":"@[to_additive]\ntheorem tprod_eq_one_of_not_multipliable (h : ¬Multipliable f) : ∏' b, f b = 1 := by\n  simp [tprod_def, h]\n\n"}
{"name":"tsum_eq_zero_of_not_summable","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nh : Not (Summable f)\n⊢ Eq (tsum fun b => f b) 0","decl":"@[to_additive]\ntheorem tprod_eq_one_of_not_multipliable (h : ¬Multipliable f) : ∏' b, f b = 1 := by\n  simp [tprod_def, h]\n\n"}
{"name":"Function.Injective.hasSum_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → β\nhg : Function.Injective g\nhf : ∀ (x : β), Not (Membership.mem (Set.range g) x) → Eq (f x) 0\n⊢ Iff (HasSum (Function.comp f g) a) (HasSum f a)","decl":"@[to_additive]\ntheorem Function.Injective.hasProd_iff {g : γ → β} (hg : Injective g)\n    (hf : ∀ x, x ∉ Set.range g → f x = 1) : HasProd (f ∘ g) a ↔ HasProd f a := by\n  simp only [HasProd, Tendsto, comp_apply, hg.map_atTop_finset_prod_eq hf]\n\n"}
{"name":"Function.Injective.hasProd_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → β\nhg : Function.Injective g\nhf : ∀ (x : β), Not (Membership.mem (Set.range g) x) → Eq (f x) 1\n⊢ Iff (HasProd (Function.comp f g) a) (HasProd f a)","decl":"@[to_additive]\ntheorem Function.Injective.hasProd_iff {g : γ → β} (hg : Injective g)\n    (hf : ∀ x, x ∉ Set.range g → f x = 1) : HasProd (f ∘ g) a ↔ HasProd f a := by\n  simp only [HasProd, Tendsto, comp_apply, hg.map_atTop_finset_prod_eq hf]\n\n"}
{"name":"hasProd_subtype_iff_of_mulSupport_subset","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ns : Set β\nhf : HasSubset.Subset (Function.mulSupport f) s\n⊢ Iff (HasProd (Function.comp f Subtype.val) a) (HasProd f a)","decl":"@[to_additive]\ntheorem hasProd_subtype_iff_of_mulSupport_subset {s : Set β} (hf : mulSupport f ⊆ s) :\n    HasProd (f ∘ (↑) : s → α) a ↔ HasProd f a :=\n  Subtype.coe_injective.hasProd_iff <| by simpa using mulSupport_subset_iff'.1 hf\n\n"}
{"name":"hasSum_subtype_iff_of_support_subset","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ns : Set β\nhf : HasSubset.Subset (Function.support f) s\n⊢ Iff (HasSum (Function.comp f Subtype.val) a) (HasSum f a)","decl":"@[to_additive]\ntheorem hasProd_subtype_iff_of_mulSupport_subset {s : Set β} (hf : mulSupport f ⊆ s) :\n    HasProd (f ∘ (↑) : s → α) a ↔ HasProd f a :=\n  Subtype.coe_injective.hasProd_iff <| by simpa using mulSupport_subset_iff'.1 hf\n\n"}
{"name":"hasSum_fintype","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : Fintype β\nf : β → α\n⊢ HasSum f (Finset.univ.sum fun b => f b)","decl":"@[to_additive]\ntheorem hasProd_fintype [Fintype β] (f : β → α) : HasProd f (∏ b, f b) :=\n  OrderTop.tendsto_atTop_nhds _\n\n"}
{"name":"hasProd_fintype","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : Fintype β\nf : β → α\n⊢ HasProd f (Finset.univ.prod fun b => f b)","decl":"@[to_additive]\ntheorem hasProd_fintype [Fintype β] (f : β → α) : HasProd f (∏ b, f b) :=\n  OrderTop.tendsto_atTop_nhds _\n\n"}
{"name":"Finset.hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ns : Finset β\nf : β → α\n⊢ HasSum (Function.comp f Subtype.val) (s.sum fun b => f b)","decl":"@[to_additive]\nprotected theorem Finset.hasProd (s : Finset β) (f : β → α) :\n    HasProd (f ∘ (↑) : (↑s : Set β) → α) (∏ b ∈ s, f b) := by\n  rw [← prod_attach]\n  exact hasProd_fintype _\n\n"}
{"name":"Finset.hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ns : Finset β\nf : β → α\n⊢ HasProd (Function.comp f Subtype.val) (s.prod fun b => f b)","decl":"@[to_additive]\nprotected theorem Finset.hasProd (s : Finset β) (f : β → α) :\n    HasProd (f ∘ (↑) : (↑s : Set β) → α) (∏ b ∈ s, f b) := by\n  rw [← prod_attach]\n  exact hasProd_fintype _\n\n"}
{"name":"hasProd_prod_of_ne_finset_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\nhf : ∀ (b : β), Not (Membership.mem s b) → Eq (f b) 1\n⊢ HasProd f (s.prod fun b => f b)","decl":"/-- If a function `f` is `1` outside of a finite set `s`, then it `HasProd` `∏ b ∈ s, f b`. -/\n@[to_additive \"If a function `f` vanishes outside of a finite set `s`, then it `HasSum`\n`∑ b ∈ s, f b`.\"]\ntheorem hasProd_prod_of_ne_finset_one (hf : ∀ b ∉ s, f b = 1) :\n    HasProd f (∏ b ∈ s, f b) :=\n  (hasProd_subtype_iff_of_mulSupport_subset <| mulSupport_subset_iff'.2 hf).1 <| s.hasProd f\n\n"}
{"name":"hasSum_sum_of_ne_finset_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\nhf : ∀ (b : β), Not (Membership.mem s b) → Eq (f b) 0\n⊢ HasSum f (s.sum fun b => f b)","decl":"/-- If a function `f` is `1` outside of a finite set `s`, then it `HasProd` `∏ b ∈ s, f b`. -/\n@[to_additive \"If a function `f` vanishes outside of a finite set `s`, then it `HasSum`\n`∑ b ∈ s, f b`.\"]\ntheorem hasProd_prod_of_ne_finset_one (hf : ∀ b ∉ s, f b = 1) :\n    HasProd f (∏ b ∈ s, f b) :=\n  (hasProd_subtype_iff_of_mulSupport_subset <| mulSupport_subset_iff'.2 hf).1 <| s.hasProd f\n\n"}
{"name":"summable_of_ne_finset_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\nhf : ∀ (b : β), Not (Membership.mem s b) → Eq (f b) 0\n⊢ Summable f","decl":"@[to_additive]\ntheorem multipliable_of_ne_finset_one (hf : ∀ b ∉ s, f b = 1) : Multipliable f :=\n  (hasProd_prod_of_ne_finset_one hf).multipliable\n\n"}
{"name":"multipliable_of_ne_finset_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\nhf : ∀ (b : β), Not (Membership.mem s b) → Eq (f b) 1\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem multipliable_of_ne_finset_one (hf : ∀ b ∉ s, f b = 1) : Multipliable f :=\n  (hasProd_prod_of_ne_finset_one hf).multipliable\n\n"}
{"name":"Summable.hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nha : Summable f\n⊢ HasSum f (tsum fun b => f b)","decl":"@[to_additive]\ntheorem Multipliable.hasProd (ha : Multipliable f) : HasProd f (∏' b, f b) := by\n  simp only [tprod_def, ha, dite_true]\n  by_cases H : (mulSupport f).Finite\n  · simp [H, hasProd_prod_of_ne_finset_one, finprod_eq_prod]\n  · simpa [H] using ha.choose_spec\n\n"}
{"name":"Multipliable.hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nha : Multipliable f\n⊢ HasProd f (tprod fun b => f b)","decl":"@[to_additive]\ntheorem Multipliable.hasProd (ha : Multipliable f) : HasProd f (∏' b, f b) := by\n  simp only [tprod_def, ha, dite_true]\n  by_cases H : (mulSupport f).Finite\n  · simp [H, hasProd_prod_of_ne_finset_one, finprod_eq_prod]\n  · simpa [H] using ha.choose_spec\n\n"}
{"name":"HasProd.unique","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na₁ a₂ : α\ninst✝ : T2Space α\na✝¹ : HasProd f a₁\na✝ : HasProd f a₂\n⊢ Eq a₁ a₂","decl":"@[to_additive]\ntheorem HasProd.unique {a₁ a₂ : α} [T2Space α] : HasProd f a₁ → HasProd f a₂ → a₁ = a₂ := by\n  classical exact tendsto_nhds_unique\n\n"}
{"name":"HasSum.unique","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na₁ a₂ : α\ninst✝ : T2Space α\na✝¹ : HasSum f a₁\na✝ : HasSum f a₂\n⊢ Eq a₁ a₂","decl":"@[to_additive]\ntheorem HasProd.unique {a₁ a₂ : α} [T2Space α] : HasProd f a₁ → HasProd f a₂ → a₁ = a₂ := by\n  classical exact tendsto_nhds_unique\n\n"}
{"name":"HasProd.tprod_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na : α\ninst✝ : T2Space α\nha : HasProd f a\n⊢ Eq (tprod fun b => f b) a","decl":"@[to_additive]\ntheorem HasProd.tprod_eq (ha : HasProd f a) : ∏' b, f b = a :=\n  (Multipliable.hasProd ⟨a, ha⟩).unique ha\n\n"}
{"name":"HasSum.tsum_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na : α\ninst✝ : T2Space α\nha : HasSum f a\n⊢ Eq (tsum fun b => f b) a","decl":"@[to_additive]\ntheorem HasProd.tprod_eq (ha : HasProd f a) : ∏' b, f b = a :=\n  (Multipliable.hasProd ⟨a, ha⟩).unique ha\n\n"}
{"name":"Summable.hasSum_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na : α\ninst✝ : T2Space α\nh : Summable f\n⊢ Iff (HasSum f a) (Eq (tsum fun b => f b) a)","decl":"@[to_additive]\ntheorem Multipliable.hasProd_iff (h : Multipliable f) : HasProd f a ↔ ∏' b, f b = a :=\n  Iff.intro HasProd.tprod_eq fun eq ↦ eq ▸ h.hasProd\n\n"}
{"name":"Multipliable.hasProd_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na : α\ninst✝ : T2Space α\nh : Multipliable f\n⊢ Iff (HasProd f a) (Eq (tprod fun b => f b) a)","decl":"@[to_additive]\ntheorem Multipliable.hasProd_iff (h : Multipliable f) : HasProd f a ↔ ∏' b, f b = a :=\n  Iff.intro HasProd.tprod_eq fun eq ↦ eq ▸ h.hasProd\n\n"}
