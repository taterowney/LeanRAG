{"name":"isReduced_localizationPreserves","module":"Mathlib.RingTheory.LocalProperties.Reduced","initialProofState":"⊢ LocalizationPreserves fun R x => IsReduced R","decl":"/-- `M⁻¹R` is reduced if `R` is reduced. -/\ntheorem isReduced_localizationPreserves : LocalizationPreserves fun R _ => IsReduced R := by\n  introv R _ _\n  constructor\n  rintro x ⟨_ | n, e⟩\n  · simpa using congr_arg (· * x) e\n  obtain ⟨⟨y, m⟩, hx⟩ := IsLocalization.surj M x\n  dsimp only at hx\n  let hx' := congr_arg (· ^ n.succ) hx\n  simp only [mul_pow, e, zero_mul, ← RingHom.map_pow] at hx'\n  rw [← (algebraMap R S).map_zero] at hx'\n  obtain ⟨m', hm'⟩ := (IsLocalization.eq_iff_exists M S).mp hx'\n  apply_fun (· * (m' : R) ^ n) at hm'\n  simp only [mul_assoc, zero_mul, mul_zero] at hm'\n  rw [← mul_left_comm, ← pow_succ', ← mul_pow] at hm'\n  replace hm' := IsNilpotent.eq_zero ⟨_, hm'.symm⟩\n  rw [← (IsLocalization.map_units S m).mul_left_inj, hx, zero_mul,\n    IsLocalization.map_eq_zero_iff M]\n  exact ⟨m', by rw [← hm', mul_comm]⟩\n\n"}
{"name":"instIsReducedLocalization","module":"Mathlib.RingTheory.LocalProperties.Reduced","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nM : Submonoid R\ninst✝ : IsReduced R\n⊢ IsReduced (Localization M)","decl":"instance {R : Type*} [CommRing R] (M : Submonoid R) [IsReduced R] : IsReduced (Localization M) :=\n  isReduced_localizationPreserves M _ inferInstance\n\n"}
{"name":"isReduced_ofLocalizationMaximal","module":"Mathlib.RingTheory.LocalProperties.Reduced","initialProofState":"⊢ OfLocalizationMaximal fun R x => IsReduced R","decl":"/-- `R` is reduced if `Rₘ` is reduced for all maximal ideal `m`. -/\ntheorem isReduced_ofLocalizationMaximal : OfLocalizationMaximal fun R _ => IsReduced R := by\n  introv R h\n  constructor\n  intro x hx\n  apply eq_zero_of_localization\n  intro J hJ\n  specialize h J hJ\n  exact (hx.map <| algebraMap R <| Localization.AtPrime J).eq_zero\n"}
