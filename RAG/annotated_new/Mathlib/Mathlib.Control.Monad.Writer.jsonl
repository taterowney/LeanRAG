{"name":"WriterT.ext_iff","module":"Mathlib.Control.Monad.Writer","initialProofState":"M : Type u → Type v\nα ω : Type u\nx x' : WriterT ω M α\n⊢ Iff (Eq x x') (Eq x.run x'.run)","decl":"@[ext]\nprotected theorem ext {ω : Type u} (x x' : WriterT ω M α) (h : x.run = x'.run) : x = x' := h\n\n"}
{"name":"WriterT.ext","module":"Mathlib.Control.Monad.Writer","initialProofState":"M : Type u → Type v\nα ω : Type u\nx x' : WriterT ω M α\nh : Eq x.run x'.run\n⊢ Eq x x'","decl":"@[ext]\nprotected theorem ext {ω : Type u} (x x' : WriterT ω M α) (h : x.run = x'.run) : x = x' := h\n\n"}
{"name":"WriterT.instLawfulMonad","module":"Mathlib.Control.Monad.Writer","initialProofState":"M : Type u → Type v\nω : Type u\ninst✝² : Monad M\ninst✝¹ : Monoid ω\ninst✝ : LawfulMonad M\n⊢ LawfulMonad (WriterT ω M)","decl":"instance [Monoid ω] [LawfulMonad M] : LawfulMonad (WriterT ω M) := LawfulMonad.mk'\n  (bind_pure_comp := by\n    intros; simp [Bind.bind, Functor.map, Pure.pure, WriterT.mk, bind_pure_comp])\n  (id_map := by intros; simp [Functor.map, WriterT.mk])\n  (pure_bind := by intros; simp [Bind.bind, Pure.pure, WriterT.mk])\n  (bind_assoc := by intros; simp [Bind.bind, mul_assoc, WriterT.mk, ← bind_pure_comp])\n\n"}
