{"name":"LinearMap.reduceModIdeal_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nx : M\n⊢ Eq ((LinearMap.reduceModIdeal I f) (Submodule.Quotient.mk x)) (Submodule.Quotient.mk (f x))","decl":"@[simp]\ntheorem reduceModIdeal_apply (f : M →ₗ[R] N) (x : M) :\n    (f.reduceModIdeal I) (Submodule.Quotient.mk (p := (I • ⊤ : Submodule R M)) x) =\n      Submodule.Quotient.mk (p := (I • ⊤ : Submodule R N)) (f x) :=\n  rfl\n\n"}
{"name":"AdicCompletion.transitionMap_comp_reduceModIdeal","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nm n : Nat\nhmn : LE.le m n\n⊢ Eq ((AdicCompletion.transitionMap I N hmn).comp (↑R (LinearMap.reduceModIdeal (HPow.hPow I n) f))) ((↑R (LinearMap.reduceModIdeal (HPow.hPow I m) f)).comp (AdicCompletion.transitionMap I M hmn))","decl":"theorem transitionMap_comp_reduceModIdeal (f : M →ₗ[R] N) {m n : ℕ}\n    (hmn : m ≤ n) : transitionMap I N hmn ∘ₗ f.reduceModIdeal (I ^ n) =\n      (f.reduceModIdeal (I ^ m) : _ →ₗ[R] _) ∘ₗ transitionMap I M hmn := by\n  ext x\n  simp\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.map_apply_coe","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\na : AdicCompletion.AdicCauchySequence I M\nn : Nat\n⊢ Eq (↑((AdicCompletion.AdicCauchySequence.map I f) a) n) (f (↑a n))","decl":"/-- A linear map induces a linear map on adic cauchy sequences. -/\n@[simps]\ndef map (f : M →ₗ[R] N) : AdicCauchySequence I M →ₗ[R] AdicCauchySequence I N where\n  toFun a := ⟨fun n ↦ f (a n), fun {m n} hmn ↦ by\n    have hm : Submodule.map f (I ^ m • ⊤ : Submodule R M) ≤ (I ^ m • ⊤ : Submodule R N) := by\n      rw [Submodule.map_smul'']\n      exact smul_mono_right _ le_top\n    apply SModEq.mono hm\n    apply SModEq.map (a.property hmn) f⟩\n  map_add' a b := by ext n; simp\n  map_smul' r a := by ext n; simp\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.map_id","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (AdicCompletion.AdicCauchySequence.map I LinearMap.id) LinearMap.id","decl":"variable (M) in\n@[simp]\ntheorem map_id : map I (LinearMap.id (M := M)) = LinearMap.id :=\n  rfl\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.map_comp","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nP : Type u_4\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\n⊢ Eq ((AdicCompletion.AdicCauchySequence.map I g).comp (AdicCompletion.AdicCauchySequence.map I f)) (AdicCompletion.AdicCauchySequence.map I (g.comp f))","decl":"theorem map_comp (f : M →ₗ[R] N) (g : N →ₗ[R] P) :\n    map I g ∘ₗ map I f = map I (g ∘ₗ f) :=\n  rfl\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.map_comp_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nP : Type u_4\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\na : AdicCompletion.AdicCauchySequence I M\n⊢ Eq ((AdicCompletion.AdicCauchySequence.map I g) ((AdicCompletion.AdicCauchySequence.map I f) a)) ((AdicCompletion.AdicCauchySequence.map I (g.comp f)) a)","decl":"theorem map_comp_apply (f : M →ₗ[R] N) (g : N →ₗ[R] P) (a : AdicCauchySequence I M) :\n    map I g (map I f a) = map I (g ∘ₗ f) a :=\n  rfl\n\n"}
{"name":"AdicCompletion.AdicCauchySequence.map_zero","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\n⊢ Eq (AdicCompletion.AdicCauchySequence.map I 0) 0","decl":"@[simp]\ntheorem map_zero : map I (0 : M →ₗ[R] N) = 0 :=\n  rfl\n\n"}
{"name":"AdicCompletion.map_val_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nn : Nat\nx : AdicCompletion I M\n⊢ Eq (↑((AdicCompletion.map I f) x) n) ((LinearMap.reduceModIdeal (HPow.hPow I n) f) (↑x n))","decl":"@[simp]\ntheorem map_val_apply (f : M →ₗ[R] N) {n : ℕ} (x : AdicCompletion I M) :\n    (map I f x).val n = f.reduceModIdeal (I ^ n) (x.val n) :=\n  rfl\n\n"}
{"name":"AdicCompletion.map_ext","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Sort u_6\nf g : AdicCompletion I M → N\nh : ∀ (a : AdicCompletion.AdicCauchySequence I M), Eq (f ((AdicCompletion.mk I M) a)) (g ((AdicCompletion.mk I M) a))\n⊢ Eq f g","decl":"/-- Equality of maps out of an adic completion can be checked on Cauchy sequences. -/\ntheorem map_ext {N} {f g : AdicCompletion I M → N}\n    (h : ∀ (a : AdicCauchySequence I M),\n      f (AdicCompletion.mk I M a) = g (AdicCompletion.mk I M a)) :\n    f = g := by\n  ext x\n  apply induction_on I M x h\n\n"}
{"name":"AdicCompletion.map_ext'","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nT : Type u_5\ninst✝¹ : AddCommGroup T\ninst✝ : Module (AdicCompletion I R) T\nf g : LinearMap (RingHom.id (AdicCompletion I R)) (AdicCompletion I M) T\nh : ∀ (a : AdicCompletion.AdicCauchySequence I M), Eq (f ((AdicCompletion.mk I M) a)) (g ((AdicCompletion.mk I M) a))\n⊢ Eq f g","decl":"/-- Equality of linear maps out of an adic completion can be checked on Cauchy sequences. -/\n@[ext]\ntheorem map_ext' {f g : AdicCompletion I M →ₗ[AdicCompletion I R] T}\n    (h : ∀ (a : AdicCauchySequence I M),\n      f (AdicCompletion.mk I M a) = g (AdicCompletion.mk I M a)) :\n    f = g := by\n  ext x\n  apply induction_on I M x h\n\n"}
{"name":"AdicCompletion.map_ext'_iff","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nT : Type u_5\ninst✝¹ : AddCommGroup T\ninst✝ : Module (AdicCompletion I R) T\nf g : LinearMap (RingHom.id (AdicCompletion I R)) (AdicCompletion I M) T\n⊢ Iff (Eq f g) (∀ (a : AdicCompletion.AdicCauchySequence I M), Eq (f ((AdicCompletion.mk I M) a)) (g ((AdicCompletion.mk I M) a)))","decl":"/-- Equality of linear maps out of an adic completion can be checked on Cauchy sequences. -/\n@[ext]\ntheorem map_ext' {f g : AdicCompletion I M →ₗ[AdicCompletion I R] T}\n    (h : ∀ (a : AdicCauchySequence I M),\n      f (AdicCompletion.mk I M a) = g (AdicCompletion.mk I M a)) :\n    f = g := by\n  ext x\n  apply induction_on I M x h\n\n"}
{"name":"AdicCompletion.map_ext''_iff","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) (AdicCompletion I M) N\n⊢ Iff (Eq f g) (Eq (f.comp (AdicCompletion.mk I M)) (g.comp (AdicCompletion.mk I M)))","decl":"/-- Equality of linear maps out of an adic completion can be checked on Cauchy sequences. -/\n@[ext]\ntheorem map_ext'' {f g : AdicCompletion I M →ₗ[R] N}\n    (h : f.comp (AdicCompletion.mk I M) = g.comp (AdicCompletion.mk I M)) :\n    f = g := by\n  ext x\n  apply induction_on I M x (fun a ↦ LinearMap.ext_iff.mp h a)\n\n"}
{"name":"AdicCompletion.map_ext''","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) (AdicCompletion I M) N\nh : Eq (f.comp (AdicCompletion.mk I M)) (g.comp (AdicCompletion.mk I M))\n⊢ Eq f g","decl":"/-- Equality of linear maps out of an adic completion can be checked on Cauchy sequences. -/\n@[ext]\ntheorem map_ext'' {f g : AdicCompletion I M →ₗ[R] N}\n    (h : f.comp (AdicCompletion.mk I M) = g.comp (AdicCompletion.mk I M)) :\n    f = g := by\n  ext x\n  apply induction_on I M x (fun a ↦ LinearMap.ext_iff.mp h a)\n\n"}
{"name":"AdicCompletion.map_id","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (AdicCompletion.map I LinearMap.id) LinearMap.id","decl":"variable (M) in\n@[simp]\ntheorem map_id :\n    map I (LinearMap.id (M := M)) =\n      LinearMap.id (R := AdicCompletion I R) (M := AdicCompletion I M) := by\n  ext a n\n  simp\n\n"}
{"name":"AdicCompletion.map_comp","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nP : Type u_4\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\n⊢ Eq ((AdicCompletion.map I g).comp (AdicCompletion.map I f)) (AdicCompletion.map I (g.comp f))","decl":"theorem map_comp (f : M →ₗ[R] N) (g : N →ₗ[R] P) :\n    map I g ∘ₗ map I f = map I (g ∘ₗ f) := by\n  ext\n  simp\n\n"}
{"name":"AdicCompletion.map_comp_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_3\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\nP : Type u_4\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nx : AdicCompletion I M\n⊢ Eq ((AdicCompletion.map I g) ((AdicCompletion.map I f) x)) ((AdicCompletion.map I (g.comp f)) x)","decl":"theorem map_comp_apply (f : M →ₗ[R] N) (g : N →ₗ[R] P) (x : AdicCompletion I M) :\n    map I g (map I f x) = map I (g ∘ₗ f) x := by\n  show (map I g ∘ₗ map I f) x = map I (g ∘ₗ f) x\n  rw [map_comp]\n\n"}
{"name":"AdicCompletion.map_mk","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\na : AdicCompletion.AdicCauchySequence I M\n⊢ Eq ((AdicCompletion.map I f) ((AdicCompletion.mk I M) a)) ((AdicCompletion.mk I N) ((AdicCompletion.AdicCauchySequence.map I f) a))","decl":"@[simp]\ntheorem map_mk (f : M →ₗ[R] N) (a : AdicCauchySequence I M) :\n    map I f (AdicCompletion.mk I M a) =\n      AdicCompletion.mk I N (AdicCauchySequence.map I f a) :=\n  rfl\n\n"}
{"name":"AdicCompletion.map_zero","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\n⊢ Eq (AdicCompletion.map I 0) 0","decl":"@[simp]\ntheorem map_zero : map I (0 : M →ₗ[R] N) = 0 := by\n  ext\n  simp\n\n"}
{"name":"AdicCompletion.congr_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M N\nx : AdicCompletion I M\n⊢ Eq ((AdicCompletion.congr I f) x) ((AdicCompletion.map I ↑f) x)","decl":"@[simp]\ntheorem congr_apply (f : M ≃ₗ[R] N) (x : AdicCompletion I M) :\n    congr I f x = map I f x :=\n  rfl\n\n"}
{"name":"AdicCompletion.congr_symm_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M N\nx : AdicCompletion I N\n⊢ Eq ((AdicCompletion.congr I f).symm x) ((AdicCompletion.map I ↑f.symm) x)","decl":"@[simp]\ntheorem congr_symm_apply (f : M ≃ₗ[R] N) (x : AdicCompletion I N) :\n    (congr I f).symm x = map I f.symm x :=\n  rfl\n\n"}
{"name":"AdicCompletion.pi_apply_coe","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommGroup (M i)\ninst✝ : (i : ι) → Module R (M i)\nc : AdicCompletion I ((j : ι) → M j)\ni : ι\nn : Nat\n⊢ Eq (↑((AdicCompletion.pi I M) c i) n) ((LinearMap.reduceModIdeal (HPow.hPow I n) (LinearMap.proj i)) (↑c n))","decl":"/-- The canonical map from the adic completion of the product to the product of the\nadic completions. -/\n@[simps!]\ndef pi : AdicCompletion I (∀ j, M j) →ₗ[AdicCompletion I R] ∀ j, AdicCompletion I (M j) :=\n  LinearMap.pi (fun j ↦ map I (LinearMap.proj j))\n\n"}
{"name":"AdicCompletion.sum_lof","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝² : (i : ι) → AddCommGroup (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\nj : ι\nx : AdicCompletion I (M j)\n⊢ Eq ((AdicCompletion.sum I M) ((DirectSum.lof (AdicCompletion I R) ι (fun i => AdicCompletion I (M i)) j) x)) ((AdicCompletion.map I (DirectSum.lof R ι M j)) x)","decl":"@[simp]\ntheorem sum_lof [DecidableEq ι] (j : ι) (x : AdicCompletion I (M j)) :\n    sum I M ((DirectSum.lof (AdicCompletion I R) ι (fun i ↦ AdicCompletion I (M i)) j) x) =\n      map I (lof R ι M j) x := by\n  simp [sum]\n\n"}
{"name":"AdicCompletion.sum_of","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝² : (i : ι) → AddCommGroup (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : DecidableEq ι\nj : ι\nx : AdicCompletion I (M j)\n⊢ Eq ((AdicCompletion.sum I M) ((DirectSum.of (fun i => AdicCompletion I (M i)) j) x)) ((AdicCompletion.map I (DirectSum.lof R ι M j)) x)","decl":"@[simp]\ntheorem sum_of [DecidableEq ι] (j : ι) (x : AdicCompletion I (M j)) :\n    sum I M ((DirectSum.of (fun i ↦ AdicCompletion I (M i)) j) x) =\n      map I (lof R ι M j) x := by\n  rw [← lof_eq_of R]\n  apply sum_lof\n\n"}
{"name":"AdicCompletion.component_sumInv","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝² : (i : ι) → AddCommGroup (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : Fintype ι\nx : AdicCompletion I (DirectSum ι fun j => M j)\nj : ι\n⊢ Eq ((DirectSum.component (AdicCompletion I R) ι (fun i => AdicCompletion I (M i)) j) ((AdicCompletion.sumInv I M) x)) ((AdicCompletion.map I (DirectSum.component R ι M j)) x)","decl":"@[simp]\ntheorem component_sumInv (x : AdicCompletion I (⨁ j, M j)) (j : ι) :\n    component (AdicCompletion I R) ι _ j (sumInv I M x) =\n      map I (component R ι _ j) x := by\n  apply induction_on I _ x (fun x ↦ ?_)\n  rfl\n\n"}
{"name":"AdicCompletion.sumInv_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝² : (i : ι) → AddCommGroup (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : Fintype ι\nx : AdicCompletion I (DirectSum ι fun j => M j)\nj : ι\n⊢ Eq (((AdicCompletion.sumInv I M) x) j) ((AdicCompletion.map I (DirectSum.component R ι M j)) x)","decl":"@[simp]\ntheorem sumInv_apply (x : AdicCompletion I (⨁ j, M j)) (j : ι) :\n    (sumInv I M x) j = map I (component R ι _ j) x := by\n  apply induction_on I _ x (fun x ↦ ?_)\n  rfl\n\n"}
{"name":"AdicCompletion.sumInv_comp_sum","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝³ : (i : ι) → AddCommGroup (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\n⊢ Eq ((AdicCompletion.sumInv I M).comp (AdicCompletion.sum I M)) LinearMap.id","decl":"theorem sumInv_comp_sum : sumInv I M ∘ₗ sum I M = LinearMap.id := by\n  ext j x : 2\n  apply DirectSum.ext_component (AdicCompletion I R) (fun i ↦ ?_)\n  ext n\n  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, map_mk, component_sumInv,\n    mk_apply_coe, AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply, LinearMap.id_comp]\n  rw [DirectSum.component.of, DirectSum.component.of]\n  split\n  · next h => subst h; simp\n  · simp\n\n"}
{"name":"AdicCompletion.sum_comp_sumInv","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝³ : (i : ι) → AddCommGroup (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\n⊢ Eq ((AdicCompletion.sum I M).comp (AdicCompletion.sumInv I M)) LinearMap.id","decl":"theorem sum_comp_sumInv : sum I M ∘ₗ sumInv I M = LinearMap.id := by\n  ext f n\n  simp only [LinearMap.coe_comp, Function.comp_apply, LinearMap.id_coe, id_eq, mk_apply_coe,\n    Submodule.mkQ_apply]\n  rw [← DirectSum.sum_univ_of (((sumInv I M) ((AdicCompletion.mk I (⨁ (j : ι), M j)) f)))]\n  simp only [sumInv_apply, map_mk, map_sum, sum_of, val_sum_apply, mk_apply_coe,\n    AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply]\n  simp only [← Submodule.mkQ_apply, ← map_sum]\n  erw [DirectSum.sum_univ_of]\n\n"}
{"name":"AdicCompletion.sumEquivOfFintype_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝³ : (i : ι) → AddCommGroup (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nx : DirectSum ι fun j => AdicCompletion I (M j)\n⊢ Eq ((AdicCompletion.sumEquivOfFintype I M) x) ((AdicCompletion.sum I M) x)","decl":"@[simp]\ntheorem sumEquivOfFintype_apply (x : ⨁ j, (AdicCompletion I (M j))) :\n    sumEquivOfFintype I M x = sum I M x :=\n  rfl\n\n"}
{"name":"AdicCompletion.sumEquivOfFintype_symm_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝³ : (i : ι) → AddCommGroup (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nx : AdicCompletion I (DirectSum ι fun j => M j)\n⊢ Eq ((AdicCompletion.sumEquivOfFintype I M).symm x) ((AdicCompletion.sumInv I M) x)","decl":"@[simp]\ntheorem sumEquivOfFintype_symm_apply (x : AdicCompletion I (⨁ j, M j)) :\n    (sumEquivOfFintype I M).symm x = sumInv I M x :=\n  rfl\n\n"}
{"name":"AdicCompletion.piEquivOfFintype_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nI : Ideal R\nι : Type u_6\nM : ι → Type u_7\ninst✝³ : (i : ι) → AddCommGroup (M i)\ninst✝² : (i : ι) → Module R (M i)\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nx : AdicCompletion I ((j : ι) → M j)\n⊢ Eq ((AdicCompletion.piEquivOfFintype I M) x) ((AdicCompletion.pi I M) x)","decl":"@[simp]\ntheorem piEquivOfFintype_apply (x : AdicCompletion I (∀ j, M j)) :\n    piEquivOfFintype I M x = pi I M x := by\n  simp [piEquivOfFintype, sumInv, map_comp_apply]\n\n"}
{"name":"AdicCompletion.piEquivFin_apply","module":"Mathlib.RingTheory.AdicCompletion.Functoriality","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nn : Nat\nx : AdicCompletion I (Fin n → R)\n⊢ Eq ((AdicCompletion.piEquivFin I n) x) ((AdicCompletion.pi I fun x => R) x)","decl":"@[simp]\ntheorem piEquivFin_apply (n : ℕ) (x : AdicCompletion I (Fin n → R)) :\n    piEquivFin I n x = pi I (fun _ : Fin n ↦ R) x := by\n  simp only [piEquivFin, piEquivOfFintype_apply]\n\n"}
