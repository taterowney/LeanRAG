{"name":"Polynomial.quotientSpanXSubCAlgEquiv_mk","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx : R\np : Polynomial R\n⊢ Eq ((Polynomial.quotientSpanXSubCAlgEquiv x) ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (HSub.hSub Polynomial.X (Polynomial.C x))))) p)) (Polynomial.eval x p)","decl":"@[simp]\ntheorem quotientSpanXSubCAlgEquiv_mk (x : R) (p : R[X]) :\n    quotientSpanXSubCAlgEquiv x (Ideal.Quotient.mk _ p) = p.eval x :=\n  rfl\n\n"}
{"name":"Polynomial.quotientSpanXSubCAlgEquiv_symm_apply","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\n⊢ Eq ((Polynomial.quotientSpanXSubCAlgEquiv x).symm y) ((algebraMap R (HasQuotient.Quotient (Polynomial R) (Ideal.span (Singleton.singleton (HSub.hSub Polynomial.X (Polynomial.C x)))))) y)","decl":"@[simp]\ntheorem quotientSpanXSubCAlgEquiv_symm_apply (x : R) (y : R) :\n    (quotientSpanXSubCAlgEquiv x).symm y = algebraMap R _ y :=\n  rfl\n\n"}
{"name":"Polynomial.modByMonic_eq_zero_iff_quotient_eq_zero","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np q : Polynomial R\nhq : q.Monic\n⊢ Iff (Eq (p.modByMonic q) 0) (Eq ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton q))) p) 0)","decl":"lemma modByMonic_eq_zero_iff_quotient_eq_zero (p q : R[X]) (hq : q.Monic) :\n    p %ₘ q = 0 ↔ (p : R[X] ⧸ Ideal.span {q}) = 0 := by\n  rw [modByMonic_eq_zero_iff_dvd hq, Ideal.Quotient.eq_zero_iff_dvd]\n\n"}
{"name":"Ideal.quotient_map_C_eq_zero","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\na : R\na✝ : Membership.mem I a\n⊢ Eq (((Ideal.Quotient.mk (Ideal.map Polynomial.C I)).comp Polynomial.C) a) 0","decl":"theorem quotient_map_C_eq_zero {I : Ideal R} :\n    ∀ a ∈ I, ((Quotient.mk (map (C : R →+* R[X]) I : Ideal R[X])).comp C) a = 0 := by\n  intro a ha\n  rw [RingHom.comp_apply, Quotient.eq_zero_iff_mem]\n  exact mem_map_of_mem _ ha\n\n"}
{"name":"Ideal.eval₂_C_mk_eq_zero","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nf : Polynomial R\na✝ : Membership.mem (Ideal.map Polynomial.C I) f\n⊢ Eq ((Polynomial.eval₂RingHom (Polynomial.C.comp (Ideal.Quotient.mk I)) Polynomial.X) f) 0","decl":"theorem eval₂_C_mk_eq_zero {I : Ideal R} :\n    ∀ f ∈ (map (C : R →+* R[X]) I : Ideal R[X]), eval₂RingHom (C.comp (Quotient.mk I)) X f = 0 := by\n  intro a ha\n  rw [← sum_monomial_eq a]\n  dsimp\n  rw [eval₂_sum]\n  refine Finset.sum_eq_zero fun n _ => ?_\n  dsimp\n  rw [eval₂_monomial (C.comp (Quotient.mk I)) X]\n  refine mul_eq_zero_of_left (Polynomial.ext fun m => ?_) (X ^ n)\n  erw [coeff_C]\n  by_cases h : m = 0\n  · simpa [h] using Quotient.eq_zero_iff_mem.2 ((mem_map_C_iff.1 ha) n)\n  · simp [h]\n\n"}
{"name":"Ideal.polynomialQuotientEquivQuotientPolynomial_symm_mk","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nf : Polynomial R\n⊢ Eq (I.polynomialQuotientEquivQuotientPolynomial.symm ((Ideal.Quotient.mk (Ideal.map Polynomial.C I)) f)) (Polynomial.map (Ideal.Quotient.mk I) f)","decl":"@[simp]\ntheorem polynomialQuotientEquivQuotientPolynomial_symm_mk (I : Ideal R) (f : R[X]) :\n    I.polynomialQuotientEquivQuotientPolynomial.symm (Quotient.mk _ f) = f.map (Quotient.mk I) := by\n  rw [polynomialQuotientEquivQuotientPolynomial, RingEquiv.symm_mk, RingEquiv.coe_mk,\n    Equiv.coe_fn_mk, Quotient.lift_mk, coe_eval₂RingHom, eval₂_eq_eval_map, ← Polynomial.map_map,\n    ← eval₂_eq_eval_map, Polynomial.eval₂_C_X]\n\n"}
{"name":"Ideal.polynomialQuotientEquivQuotientPolynomial_map_mk","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nf : Polynomial R\n⊢ Eq (I.polynomialQuotientEquivQuotientPolynomial (Polynomial.map (Ideal.Quotient.mk I) f)) ((Ideal.Quotient.mk (Ideal.map Polynomial.C I)) f)","decl":"@[simp]\ntheorem polynomialQuotientEquivQuotientPolynomial_map_mk (I : Ideal R) (f : R[X]) :\n    I.polynomialQuotientEquivQuotientPolynomial (f.map <| Quotient.mk I) =\n    Quotient.mk (map C I : Ideal R[X]) f := by\n  apply (polynomialQuotientEquivQuotientPolynomial I).symm.injective\n  rw [RingEquiv.symm_apply_apply, polynomialQuotientEquivQuotientPolynomial_symm_mk]\n\n"}
{"name":"Ideal.isDomain_map_C_quotient","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nP : Ideal R\nx✝ : P.IsPrime\n⊢ IsDomain (HasQuotient.Quotient (Polynomial R) (Ideal.map Polynomial.C P))","decl":"/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem isDomain_map_C_quotient {P : Ideal R} (_ : IsPrime P) :\n    IsDomain (R[X] ⧸ (map (C : R →+* R[X]) P : Ideal R[X])) :=\n  MulEquiv.isDomain (Polynomial (R ⧸ P)) (polynomialQuotientEquivQuotientPolynomial P).symm\n\n"}
{"name":"Ideal.eq_zero_of_polynomial_mem_map_range","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal (Polynomial R)\nx : Subtype fun x => Membership.mem ((Ideal.Quotient.mk I).comp Polynomial.C).range x\nhx : Membership.mem (Ideal.map (Polynomial.mapRingHom ((Ideal.Quotient.mk I).comp Polynomial.C).rangeRestrict) I) (Polynomial.C x)\n⊢ Eq x 0","decl":"/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\n  If we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\n  In particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\n  This theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem eq_zero_of_polynomial_mem_map_range (I : Ideal R[X]) (x : ((Quotient.mk I).comp C).range)\n    (hx : C x ∈ I.map (Polynomial.mapRingHom ((Quotient.mk I).comp C).rangeRestrict)) : x = 0 := by\n  let i := ((Quotient.mk I).comp C).rangeRestrict\n  have hi' : RingHom.ker (Polynomial.mapRingHom i) ≤ I := by\n    refine fun f hf => polynomial_mem_ideal_of_coeff_mem_ideal I f fun n => ?_\n    rw [mem_comap, ← Quotient.eq_zero_iff_mem, ← RingHom.comp_apply]\n    rw [RingHom.mem_ker, coe_mapRingHom] at hf\n    replace hf := congr_arg (fun f : Polynomial _ => f.coeff n) hf\n    simp only [coeff_map, coeff_zero] at hf\n    rwa [Subtype.ext_iff, RingHom.coe_rangeRestrict] at hf\n  obtain ⟨x, hx'⟩ := x\n  obtain ⟨y, rfl⟩ := RingHom.mem_range.1 hx'\n  refine Subtype.eq ?_\n  simp only [RingHom.comp_apply, Quotient.eq_zero_iff_mem, ZeroMemClass.coe_zero]\n  suffices C (i y) ∈ I.map (Polynomial.mapRingHom i) by\n    obtain ⟨f, hf⟩ := mem_image_of_mem_map_of_surjective (Polynomial.mapRingHom i)\n      (Polynomial.map_surjective _ (RingHom.rangeRestrict_surjective ((Quotient.mk I).comp C))) this\n    refine sub_add_cancel (C y) f ▸ I.add_mem (hi' ?_ : C y - f ∈ I) hf.1\n    rw [RingHom.mem_ker, RingHom.map_sub, hf.2, sub_eq_zero, coe_mapRingHom, map_C]\n  exact hx\n\n"}
{"name":"MvPolynomial.quotient_map_C_eq_zero","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\nσ : Type u_2\ninst✝ : CommRing R\nI : Ideal R\ni : R\nhi : Membership.mem I i\n⊢ Eq (((Ideal.Quotient.mk (Ideal.map MvPolynomial.C I)).comp MvPolynomial.C) i) 0","decl":"theorem quotient_map_C_eq_zero {I : Ideal R} {i : R} (hi : i ∈ I) :\n    (Ideal.Quotient.mk (Ideal.map (C : R →+* MvPolynomial σ R) I :\n      Ideal (MvPolynomial σ R))).comp C i = 0 := by\n  simp only [Function.comp_apply, RingHom.coe_comp, Ideal.Quotient.eq_zero_iff_mem]\n  exact Ideal.mem_map_of_mem _ hi\n\n"}
{"name":"MvPolynomial.eval₂_C_mk_eq_zero","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\nσ : Type u_2\ninst✝ : CommRing R\nI : Ideal R\na : MvPolynomial σ R\nha : Membership.mem (Ideal.map MvPolynomial.C I) a\n⊢ Eq ((MvPolynomial.eval₂Hom (MvPolynomial.C.comp (Ideal.Quotient.mk I)) MvPolynomial.X) a) 0","decl":"theorem eval₂_C_mk_eq_zero {I : Ideal R} {a : MvPolynomial σ R}\n    (ha : a ∈ (Ideal.map (C : R →+* MvPolynomial σ R) I : Ideal (MvPolynomial σ R))) :\n    eval₂Hom (C.comp (Ideal.Quotient.mk I)) X a = 0 := by\n  rw [as_sum a]\n  rw [coe_eval₂Hom, eval₂_sum]\n  refine Finset.sum_eq_zero fun n _ => ?_\n  simp only [eval₂_monomial, Function.comp_apply, RingHom.coe_comp]\n  refine mul_eq_zero_of_left ?_ _\n  suffices coeff n a ∈ I by\n    rw [← @Ideal.mk_ker R _ I, RingHom.mem_ker] at this\n    simp only [this, C_0]\n  exact mem_map_C_iff.1 ha n\n\n"}
{"name":"MvPolynomial.quotientEquivQuotientMvPolynomial_rightInverse","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\nσ : Type u_2\ninst✝ : CommRing R\nI : Ideal R\n⊢ Function.RightInverse (MvPolynomial.eval₂ (Ideal.Quotient.lift I ((Ideal.Quotient.mk (Ideal.map MvPolynomial.C I)).comp MvPolynomial.C) ⋯) fun i => (Ideal.Quotient.mk (Ideal.map MvPolynomial.C I)) (MvPolynomial.X i)) ⇑(Ideal.Quotient.lift (Ideal.map MvPolynomial.C I) (MvPolynomial.eval₂Hom (MvPolynomial.C.comp (Ideal.Quotient.mk I)) MvPolynomial.X) ⋯)","decl":"lemma quotientEquivQuotientMvPolynomial_rightInverse (I : Ideal R) :\n    Function.RightInverse\n      (eval₂ (Ideal.Quotient.lift I\n        ((Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial σ R))).comp C)\n          fun _ hi => quotient_map_C_eq_zero hi)\n          fun i => Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial σ R)) (X i))\n      (Ideal.Quotient.lift (Ideal.map C I : Ideal (MvPolynomial σ R))\n        (eval₂Hom (C.comp (Ideal.Quotient.mk I)) X) fun _ ha => eval₂_C_mk_eq_zero ha) := by\n  intro f\n  apply induction_on f\n  · intro r\n    obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective r\n    rw [eval₂_C, Ideal.Quotient.lift_mk, RingHom.comp_apply, Ideal.Quotient.lift_mk, eval₂Hom_C,\n      RingHom.comp_apply]\n  · intros p q hp hq\n    simp only [RingHom.map_add, MvPolynomial.coe_eval₂Hom, coe_eval₂Hom, MvPolynomial.eval₂_add]\n      at hp hq ⊢\n    rw [hp, hq]\n  · intros p i hp\n    simp only [coe_eval₂Hom] at hp\n    simp only [hp, coe_eval₂Hom, Ideal.Quotient.lift_mk, eval₂_mul, RingHom.map_mul, eval₂_X]\n\n"}
{"name":"MvPolynomial.quotientEquivQuotientMvPolynomial_leftInverse","module":"Mathlib.RingTheory.Polynomial.Quotient","initialProofState":"R : Type u_1\nσ : Type u_2\ninst✝ : CommRing R\nI : Ideal R\n⊢ Function.LeftInverse (MvPolynomial.eval₂ (Ideal.Quotient.lift I ((Ideal.Quotient.mk (Ideal.map MvPolynomial.C I)).comp MvPolynomial.C) ⋯) fun i => (Ideal.Quotient.mk (Ideal.map MvPolynomial.C I)) (MvPolynomial.X i)) ⇑(Ideal.Quotient.lift (Ideal.map MvPolynomial.C I) (MvPolynomial.eval₂Hom (MvPolynomial.C.comp (Ideal.Quotient.mk I)) MvPolynomial.X) ⋯)","decl":"lemma quotientEquivQuotientMvPolynomial_leftInverse (I : Ideal R) :\n    Function.LeftInverse\n      (eval₂ (Ideal.Quotient.lift I\n        ((Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial σ R))).comp C)\n          fun _ hi => quotient_map_C_eq_zero hi)\n          fun i => Ideal.Quotient.mk (Ideal.map C I : Ideal (MvPolynomial σ R)) (X i))\n      (Ideal.Quotient.lift (Ideal.map C I : Ideal (MvPolynomial σ R))\n        (eval₂Hom (C.comp (Ideal.Quotient.mk I)) X) fun _ ha => eval₂_C_mk_eq_zero ha) := by\n  intro f\n  obtain ⟨f, rfl⟩ := Ideal.Quotient.mk_surjective f\n  apply induction_on f\n  · intro r\n    rw [Ideal.Quotient.lift_mk, eval₂Hom_C, RingHom.comp_apply, eval₂_C, Ideal.Quotient.lift_mk,\n      RingHom.comp_apply]\n  · intros p q hp hq\n    rw [Ideal.Quotient.lift_mk] at hp hq ⊢\n    simp only [Submodule.Quotient.quot_mk_eq_mk, eval₂_add, RingHom.map_add, coe_eval₂Hom,\n      Ideal.Quotient.lift_mk, Ideal.Quotient.mk_eq_mk] at hp hq ⊢\n    rw [hp, hq]\n  · intros p i hp\n    simp only [Submodule.Quotient.quot_mk_eq_mk, coe_eval₂Hom, Ideal.Quotient.lift_mk,\n      Ideal.Quotient.mk_eq_mk, eval₂_mul, RingHom.map_mul, eval₂_X] at hp ⊢\n    simp only [hp]\n\n-- Porting note: this definition was split to avoid timeouts.\n"}
