{"name":"MeasureTheory.laverage_zero","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.laverage μ fun _x => 0) 0","decl":"@[simp]\ntheorem laverage_zero : ⨍⁻ _x, (0 : ℝ≥0∞) ∂μ = 0 := by rw [laverage, lintegral_zero]\n\n"}
{"name":"MeasureTheory.laverage_zero_measure","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.laverage 0 fun x => f x) 0","decl":"@[simp]\ntheorem laverage_zero_measure (f : α → ℝ≥0∞) : ⨍⁻ x, f x ∂(0 : Measure α) = 0 := by simp [laverage]\n\n"}
{"name":"MeasureTheory.laverage_eq'","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.laverage μ fun x => f x) (MeasureTheory.lintegral (HSMul.hSMul (Inv.inv (μ Set.univ)) μ) fun x => f x)","decl":"theorem laverage_eq' (f : α → ℝ≥0∞) : ⨍⁻ x, f x ∂μ = ∫⁻ x, f x ∂(μ univ)⁻¹ • μ := rfl\n\n"}
{"name":"MeasureTheory.laverage_eq","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.laverage μ fun x => f x) (HDiv.hDiv (MeasureTheory.lintegral μ fun x => f x) (μ Set.univ))","decl":"theorem laverage_eq (f : α → ℝ≥0∞) : ⨍⁻ x, f x ∂μ = (∫⁻ x, f x ∂μ) / μ univ := by\n  rw [laverage_eq', lintegral_smul_measure, ENNReal.div_eq_inv_mul]\n\n"}
{"name":"MeasureTheory.laverage_eq_lintegral","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.laverage μ fun x => f x) (MeasureTheory.lintegral μ fun x => f x)","decl":"theorem laverage_eq_lintegral [IsProbabilityMeasure μ] (f : α → ℝ≥0∞) :\n    ⨍⁻ x, f x ∂μ = ∫⁻ x, f x ∂μ := by rw [laverage, measure_univ, inv_one, one_smul]\n\n"}
{"name":"MeasureTheory.measure_mul_laverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → ENNReal\n⊢ Eq (HMul.hMul (μ Set.univ) (MeasureTheory.laverage μ fun x => f x)) (MeasureTheory.lintegral μ fun x => f x)","decl":"@[simp]\ntheorem measure_mul_laverage [IsFiniteMeasure μ] (f : α → ℝ≥0∞) :\n    μ univ * ⨍⁻ x, f x ∂μ = ∫⁻ x, f x ∂μ := by\n  rcases eq_or_ne μ 0 with hμ | hμ\n  · rw [hμ, lintegral_zero_measure, laverage_zero_measure, mul_zero]\n  · rw [laverage_eq, ENNReal.mul_div_cancel (measure_univ_ne_zero.2 hμ) (measure_ne_top _ _)]\n\n"}
{"name":"MeasureTheory.setLaverage_eq","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\n⊢ Eq (MeasureTheory.laverage (μ.restrict s) fun x => f x) (HDiv.hDiv (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (μ s))","decl":"theorem setLaverage_eq (f : α → ℝ≥0∞) (s : Set α) :\n    ⨍⁻ x in s, f x ∂μ = (∫⁻ x in s, f x ∂μ) / μ s := by rw [laverage_eq, restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.setLaverage_eq'","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\n⊢ Eq (MeasureTheory.laverage (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (HSMul.hSMul (Inv.inv (μ s)) (μ.restrict s)) fun x => f x)","decl":"theorem setLaverage_eq' (f : α → ℝ≥0∞) (s : Set α) :\n    ⨍⁻ x in s, f x ∂μ = ∫⁻ x, f x ∂(μ s)⁻¹ • μ.restrict s := by\n  simp only [laverage_eq', restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.laverage_congr","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (MeasureTheory.laverage μ fun x => f x) (MeasureTheory.laverage μ fun x => g x)","decl":"theorem laverage_congr {f g : α → ℝ≥0∞} (h : f =ᵐ[μ] g) : ⨍⁻ x, f x ∂μ = ⨍⁻ x, g x ∂μ := by\n  simp only [laverage_eq, lintegral_congr_ae h]\n\n"}
{"name":"MeasureTheory.setLaverage_congr","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nf : α → ENNReal\nh : (MeasureTheory.ae μ).EventuallyEq s t\n⊢ Eq (MeasureTheory.laverage (μ.restrict s) fun x => f x) (MeasureTheory.laverage (μ.restrict t) fun x => f x)","decl":"theorem setLaverage_congr (h : s =ᵐ[μ] t) : ⨍⁻ x in s, f x ∂μ = ⨍⁻ x in t, f x ∂μ := by\n  simp only [setLaverage_eq, setLIntegral_congr h, measure_congr h]\n\n"}
{"name":"MeasureTheory.setLaverage_congr_fun","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf g : α → ENNReal\nhs : MeasurableSet s\nh : Filter.Eventually (fun x => Membership.mem s x → Eq (f x) (g x)) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.laverage (μ.restrict s) fun x => f x) (MeasureTheory.laverage (μ.restrict s) fun x => g x)","decl":"theorem setLaverage_congr_fun (hs : MeasurableSet s) (h : ∀ᵐ x ∂μ, x ∈ s → f x = g x) :\n    ⨍⁻ x in s, f x ∂μ = ⨍⁻ x in s, g x ∂μ := by\n  simp only [laverage_eq, setLIntegral_congr_fun hs h]\n\n"}
{"name":"MeasureTheory.laverage_lt_top","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\n⊢ LT.lt (MeasureTheory.laverage μ fun x => f x) Top.top","decl":"theorem laverage_lt_top (hf : ∫⁻ x, f x ∂μ ≠ ∞) : ⨍⁻ x, f x ∂μ < ∞ := by\n  obtain rfl | hμ := eq_or_ne μ 0\n  · simp\n  · rw [laverage_eq]\n    exact div_lt_top hf (measure_univ_ne_zero.2 hμ)\n\n"}
{"name":"MeasureTheory.setLaverage_lt_top","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\na✝ : Ne (MeasureTheory.lintegral (μ.restrict s) fun x => f x) Top.top\n⊢ LT.lt (MeasureTheory.laverage (μ.restrict s) fun x => f x) Top.top","decl":"theorem setLaverage_lt_top : ∫⁻ x in s, f x ∂μ ≠ ∞ → ⨍⁻ x in s, f x ∂μ < ∞ :=\n  laverage_lt_top\n\n"}
{"name":"MeasureTheory.laverage_add_measure","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.laverage (HAdd.hAdd μ ν) fun x => f x) (HAdd.hAdd (HMul.hMul (HDiv.hDiv (μ Set.univ) (HAdd.hAdd (μ Set.univ) (ν Set.univ))) (MeasureTheory.laverage μ fun x => f x)) (HMul.hMul (HDiv.hDiv (ν Set.univ) (HAdd.hAdd (μ Set.univ) (ν Set.univ))) (MeasureTheory.laverage ν fun x => f x)))","decl":"theorem laverage_add_measure :\n    ⨍⁻ x, f x ∂(μ + ν) =\n      μ univ / (μ univ + ν univ) * ⨍⁻ x, f x ∂μ + ν univ / (μ univ + ν univ) * ⨍⁻ x, f x ∂ν := by\n  by_cases hμ : IsFiniteMeasure μ; swap\n  · rw [not_isFiniteMeasure_iff] at hμ\n    simp [laverage_eq, hμ]\n  by_cases hν : IsFiniteMeasure ν; swap\n  · rw [not_isFiniteMeasure_iff] at hν\n    simp [laverage_eq, hν]\n  haveI := hμ; haveI := hν\n  simp only [← ENNReal.mul_div_right_comm, measure_mul_laverage, ← ENNReal.add_div,\n    ← lintegral_add_measure, ← Measure.add_apply, ← laverage_eq]\n\n"}
{"name":"MeasureTheory.measure_mul_setLaverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nh : Ne (μ s) Top.top\n⊢ Eq (HMul.hMul (μ s) (MeasureTheory.laverage (μ.restrict s) fun x => f x)) (MeasureTheory.lintegral (μ.restrict s) fun x => f x)","decl":"theorem measure_mul_setLaverage (f : α → ℝ≥0∞) (h : μ s ≠ ∞) :\n    μ s * ⨍⁻ x in s, f x ∂μ = ∫⁻ x in s, f x ∂μ := by\n  have := Fact.mk h.lt_top\n  rw [← measure_mul_laverage, restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.laverage_union","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nf : α → ENNReal\nhd : MeasureTheory.AEDisjoint μ s t\nht : MeasureTheory.NullMeasurableSet t μ\n⊢ Eq (MeasureTheory.laverage (μ.restrict (Union.union s t)) fun x => f x) (HAdd.hAdd (HMul.hMul (HDiv.hDiv (μ s) (HAdd.hAdd (μ s) (μ t))) (MeasureTheory.laverage (μ.restrict s) fun x => f x)) (HMul.hMul (HDiv.hDiv (μ t) (HAdd.hAdd (μ s) (μ t))) (MeasureTheory.laverage (μ.restrict t) fun x => f x)))","decl":"theorem laverage_union (hd : AEDisjoint μ s t) (ht : NullMeasurableSet t μ) :\n    ⨍⁻ x in s ∪ t, f x ∂μ =\n      μ s / (μ s + μ t) * ⨍⁻ x in s, f x ∂μ + μ t / (μ s + μ t) * ⨍⁻ x in t, f x ∂μ := by\n  rw [restrict_union₀ hd ht, laverage_add_measure, restrict_apply_univ, restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.laverage_union_mem_openSegment","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nf : α → ENNReal\nhd : MeasureTheory.AEDisjoint μ s t\nht : MeasureTheory.NullMeasurableSet t μ\nhs₀ : Ne (μ s) 0\nht₀ : Ne (μ t) 0\nhsμ : Ne (μ s) Top.top\nhtμ : Ne (μ t) Top.top\n⊢ Membership.mem (openSegment ENNReal (MeasureTheory.laverage (μ.restrict s) fun x => f x) (MeasureTheory.laverage (μ.restrict t) fun x => f x)) (MeasureTheory.laverage (μ.restrict (Union.union s t)) fun x => f x)","decl":"theorem laverage_union_mem_openSegment (hd : AEDisjoint μ s t) (ht : NullMeasurableSet t μ)\n    (hs₀ : μ s ≠ 0) (ht₀ : μ t ≠ 0) (hsμ : μ s ≠ ∞) (htμ : μ t ≠ ∞) :\n    ⨍⁻ x in s ∪ t, f x ∂μ ∈ openSegment ℝ≥0∞ (⨍⁻ x in s, f x ∂μ) (⨍⁻ x in t, f x ∂μ) := by\n  refine\n    ⟨μ s / (μ s + μ t), μ t / (μ s + μ t), ENNReal.div_pos hs₀ <| add_ne_top.2 ⟨hsμ, htμ⟩,\n      ENNReal.div_pos ht₀ <| add_ne_top.2 ⟨hsμ, htμ⟩, ?_, (laverage_union hd ht).symm⟩\n  rw [← ENNReal.add_div,\n    ENNReal.div_self (add_eq_zero.not.2 fun h => hs₀ h.1) (add_ne_top.2 ⟨hsμ, htμ⟩)]\n\n"}
{"name":"MeasureTheory.laverage_union_mem_segment","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nf : α → ENNReal\nhd : MeasureTheory.AEDisjoint μ s t\nht : MeasureTheory.NullMeasurableSet t μ\nhsμ : Ne (μ s) Top.top\nhtμ : Ne (μ t) Top.top\n⊢ Membership.mem (segment ENNReal (MeasureTheory.laverage (μ.restrict s) fun x => f x) (MeasureTheory.laverage (μ.restrict t) fun x => f x)) (MeasureTheory.laverage (μ.restrict (Union.union s t)) fun x => f x)","decl":"theorem laverage_union_mem_segment (hd : AEDisjoint μ s t) (ht : NullMeasurableSet t μ)\n    (hsμ : μ s ≠ ∞) (htμ : μ t ≠ ∞) :\n    ⨍⁻ x in s ∪ t, f x ∂μ ∈ [⨍⁻ x in s, f x ∂μ -[ℝ≥0∞] ⨍⁻ x in t, f x ∂μ] := by\n  by_cases hs₀ : μ s = 0\n  · rw [← ae_eq_empty] at hs₀\n    rw [restrict_congr_set (hs₀.union EventuallyEq.rfl), empty_union]\n    exact right_mem_segment _ _ _\n  · refine\n      ⟨μ s / (μ s + μ t), μ t / (μ s + μ t), zero_le _, zero_le _, ?_, (laverage_union hd ht).symm⟩\n    rw [← ENNReal.add_div,\n      ENNReal.div_self (add_eq_zero.not.2 fun h => hs₀ h.1) (add_ne_top.2 ⟨hsμ, htμ⟩)]\n\n"}
{"name":"MeasureTheory.laverage_mem_openSegment_compl_self","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhs : MeasureTheory.NullMeasurableSet s μ\nhs₀ : Ne (μ s) 0\nhsc₀ : Ne (μ (HasCompl.compl s)) 0\n⊢ Membership.mem (openSegment ENNReal (MeasureTheory.laverage (μ.restrict s) fun x => f x) (MeasureTheory.laverage (μ.restrict (HasCompl.compl s)) fun x => f x)) (MeasureTheory.laverage μ fun x => f x)","decl":"theorem laverage_mem_openSegment_compl_self [IsFiniteMeasure μ] (hs : NullMeasurableSet s μ)\n    (hs₀ : μ s ≠ 0) (hsc₀ : μ sᶜ ≠ 0) :\n    ⨍⁻ x, f x ∂μ ∈ openSegment ℝ≥0∞ (⨍⁻ x in s, f x ∂μ) (⨍⁻ x in sᶜ, f x ∂μ) := by\n  simpa only [union_compl_self, restrict_univ] using\n    laverage_union_mem_openSegment aedisjoint_compl_right hs.compl hs₀ hsc₀ (measure_ne_top _ _)\n      (measure_ne_top _ _)\n\n"}
{"name":"MeasureTheory.laverage_const","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : NeZero μ\nc : ENNReal\n⊢ Eq (MeasureTheory.laverage μ fun _x => c) c","decl":"@[simp]\ntheorem laverage_const (μ : Measure α) [IsFiniteMeasure μ] [h : NeZero μ] (c : ℝ≥0∞) :\n    ⨍⁻ _x, c ∂μ = c := by\n  simp only [laverage, lintegral_const, measure_univ, mul_one]\n\n"}
{"name":"MeasureTheory.setLaverage_const","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs₀ : Ne (μ s) 0\nhs : Ne (μ s) Top.top\nc : ENNReal\n⊢ Eq (MeasureTheory.laverage (μ.restrict s) fun _x => c) c","decl":"theorem setLaverage_const (hs₀ : μ s ≠ 0) (hs : μ s ≠ ∞) (c : ℝ≥0∞) : ⨍⁻ _x in s, c ∂μ = c := by\n  simp only [setLaverage_eq, lintegral_const, Measure.restrict_apply, MeasurableSet.univ,\n    univ_inter, div_eq_mul_inv, mul_assoc, ENNReal.mul_inv_cancel hs₀ hs, mul_one]\n\n"}
{"name":"MeasureTheory.laverage_one","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : NeZero μ\n⊢ Eq (MeasureTheory.laverage μ fun _x => 1) 1","decl":"theorem laverage_one [IsFiniteMeasure μ] [NeZero μ] : ⨍⁻ _x, (1 : ℝ≥0∞) ∂μ = 1 :=\n  laverage_const _ _\n\n"}
{"name":"MeasureTheory.setLaverage_one","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs₀ : Ne (μ s) 0\nhs : Ne (μ s) Top.top\n⊢ Eq (MeasureTheory.laverage (μ.restrict s) fun _x => 1) 1","decl":"theorem setLaverage_one (hs₀ : μ s ≠ 0) (hs : μ s ≠ ∞) : ⨍⁻ _x in s, (1 : ℝ≥0∞) ∂μ = 1 :=\n  setLaverage_const hs₀ hs _\n\n-- Porting note: Dropped `simp` because of `simp` seeing through `1 : α → ℝ≥0∞` and applying\n-- `lintegral_const`. This is suboptimal.\n"}
{"name":"MeasureTheory.lintegral_laverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun _x => MeasureTheory.laverage μ fun a => f a) (MeasureTheory.lintegral μ fun x => f x)","decl":"theorem lintegral_laverage (μ : Measure α) [IsFiniteMeasure μ] (f : α → ℝ≥0∞) :\n    ∫⁻ _x, ⨍⁻ a, f a ∂μ ∂μ = ∫⁻ x, f x ∂μ := by\n  obtain rfl | hμ := eq_or_ne μ 0\n  · simp\n  · rw [lintegral_const, laverage_eq,\n      ENNReal.div_mul_cancel (measure_univ_ne_zero.2 hμ) (measure_ne_top _ _)]\n\n"}
{"name":"MeasureTheory.setLintegral_setLaverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → ENNReal\ns : Set α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun _x => MeasureTheory.laverage (μ.restrict s) fun a => f a) (MeasureTheory.lintegral (μ.restrict s) fun x => f x)","decl":"theorem setLintegral_setLaverage (μ : Measure α) [IsFiniteMeasure μ] (f : α → ℝ≥0∞) (s : Set α) :\n    ∫⁻ _x in s, ⨍⁻ a in s, f a ∂μ ∂μ = ∫⁻ x in s, f x ∂μ :=\n  lintegral_laverage _ _\n\n"}
{"name":"MeasureTheory.average_zero","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.average μ fun x => 0) 0","decl":"@[simp]\ntheorem average_zero : ⨍ _, (0 : E) ∂μ = 0 := by rw [average, integral_zero]\n\n"}
{"name":"MeasureTheory.average_zero_measure","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → E\n⊢ Eq (MeasureTheory.average 0 fun x => f x) 0","decl":"@[simp]\ntheorem average_zero_measure (f : α → E) : ⨍ x, f x ∂(0 : Measure α) = 0 := by\n  rw [average, smul_zero, integral_zero_measure]\n\n"}
{"name":"MeasureTheory.average_neg","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\n⊢ Eq (MeasureTheory.average μ fun x => Neg.neg (f x)) (Neg.neg (MeasureTheory.average μ fun x => f x))","decl":"@[simp]\ntheorem average_neg (f : α → E) : ⨍ x, -f x ∂μ = -⨍ x, f x ∂μ :=\n  integral_neg f\n\n"}
{"name":"MeasureTheory.average_eq'","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\n⊢ Eq (MeasureTheory.average μ fun x => f x) (MeasureTheory.integral (HSMul.hSMul (Inv.inv (μ Set.univ)) μ) fun x => f x)","decl":"theorem average_eq' (f : α → E) : ⨍ x, f x ∂μ = ∫ x, f x ∂(μ univ)⁻¹ • μ :=\n  rfl\n\n"}
{"name":"MeasureTheory.average_eq","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\n⊢ Eq (MeasureTheory.average μ fun x => f x) (HSMul.hSMul (Inv.inv (μ Set.univ).toReal) (MeasureTheory.integral μ fun x => f x))","decl":"theorem average_eq (f : α → E) : ⨍ x, f x ∂μ = (μ univ).toReal⁻¹ • ∫ x, f x ∂μ := by\n  rw [average_eq', integral_smul_measure, ENNReal.toReal_inv]\n\n"}
{"name":"MeasureTheory.average_eq_integral","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nf : α → E\n⊢ Eq (MeasureTheory.average μ fun x => f x) (MeasureTheory.integral μ fun x => f x)","decl":"theorem average_eq_integral [IsProbabilityMeasure μ] (f : α → E) : ⨍ x, f x ∂μ = ∫ x, f x ∂μ := by\n  rw [average, measure_univ, inv_one, one_smul]\n\n"}
{"name":"MeasureTheory.measure_smul_average","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → E\n⊢ Eq (HSMul.hSMul (μ Set.univ).toReal (MeasureTheory.average μ fun x => f x)) (MeasureTheory.integral μ fun x => f x)","decl":"@[simp]\ntheorem measure_smul_average [IsFiniteMeasure μ] (f : α → E) :\n    (μ univ).toReal • ⨍ x, f x ∂μ = ∫ x, f x ∂μ := by\n  rcases eq_or_ne μ 0 with hμ | hμ\n  · rw [hμ, integral_zero_measure, average_zero_measure, smul_zero]\n  · rw [average_eq, smul_inv_smul₀]\n    refine (ENNReal.toReal_pos ?_ <| measure_ne_top _ _).ne'\n    rwa [Ne, measure_univ_eq_zero]\n\n"}
{"name":"MeasureTheory.setAverage_eq","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\n⊢ Eq (MeasureTheory.average (μ.restrict s) fun x => f x) (HSMul.hSMul (Inv.inv (μ s).toReal) (MeasureTheory.integral (μ.restrict s) fun x => f x))","decl":"theorem setAverage_eq (f : α → E) (s : Set α) :\n    ⨍ x in s, f x ∂μ = (μ s).toReal⁻¹ • ∫ x in s, f x ∂μ := by rw [average_eq, restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.setAverage_eq'","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\n⊢ Eq (MeasureTheory.average (μ.restrict s) fun x => f x) (MeasureTheory.integral (HSMul.hSMul (Inv.inv (μ s)) (μ.restrict s)) fun x => f x)","decl":"theorem setAverage_eq' (f : α → E) (s : Set α) :\n    ⨍ x in s, f x ∂μ = ∫ x, f x ∂(μ s)⁻¹ • μ.restrict s := by\n  simp only [average_eq', restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.average_congr","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf g : α → E\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (MeasureTheory.average μ fun x => f x) (MeasureTheory.average μ fun x => g x)","decl":"theorem average_congr {f g : α → E} (h : f =ᵐ[μ] g) : ⨍ x, f x ∂μ = ⨍ x, g x ∂μ := by\n  simp only [average_eq, integral_congr_ae h]\n\n"}
{"name":"MeasureTheory.setAverage_congr","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\ns t : Set α\nf : α → E\nh : (MeasureTheory.ae μ).EventuallyEq s t\n⊢ Eq (MeasureTheory.average (μ.restrict s) fun x => f x) (MeasureTheory.average (μ.restrict t) fun x => f x)","decl":"theorem setAverage_congr (h : s =ᵐ[μ] t) : ⨍ x in s, f x ∂μ = ⨍ x in t, f x ∂μ := by\n  simp only [setAverage_eq, setIntegral_congr_set h, measure_congr h]\n\n"}
{"name":"MeasureTheory.setAverage_congr_fun","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\ns : Set α\nf g : α → E\nhs : MeasurableSet s\nh : Filter.Eventually (fun x => Membership.mem s x → Eq (f x) (g x)) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.average (μ.restrict s) fun x => f x) (MeasureTheory.average (μ.restrict s) fun x => g x)","decl":"theorem setAverage_congr_fun (hs : MeasurableSet s) (h : ∀ᵐ x ∂μ, x ∈ s → f x = g x) :\n    ⨍ x in s, f x ∂μ = ⨍ x in s, g x ∂μ := by simp only [average_eq, setIntegral_congr_ae hs h]\n\n"}
{"name":"MeasureTheory.average_add_measure","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure ν\nf : α → E\nhμ : MeasureTheory.Integrable f μ\nhν : MeasureTheory.Integrable f ν\n⊢ Eq (MeasureTheory.average (HAdd.hAdd μ ν) fun x => f x) (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv (μ Set.univ).toReal (HAdd.hAdd (μ Set.univ).toReal (ν Set.univ).toReal)) (MeasureTheory.average μ fun x => f x)) (HSMul.hSMul (HDiv.hDiv (ν Set.univ).toReal (HAdd.hAdd (μ Set.univ).toReal (ν Set.univ).toReal)) (MeasureTheory.average ν fun x => f x)))","decl":"theorem average_add_measure [IsFiniteMeasure μ] {ν : Measure α} [IsFiniteMeasure ν] {f : α → E}\n    (hμ : Integrable f μ) (hν : Integrable f ν) :\n    ⨍ x, f x ∂(μ + ν) =\n      ((μ univ).toReal / ((μ univ).toReal + (ν univ).toReal)) • ⨍ x, f x ∂μ +\n        ((ν univ).toReal / ((μ univ).toReal + (ν univ).toReal)) • ⨍ x, f x ∂ν := by\n  simp only [div_eq_inv_mul, mul_smul, measure_smul_average, ← smul_add,\n    ← integral_add_measure hμ hν, ← ENNReal.toReal_add (measure_ne_top μ _) (measure_ne_top ν _)]\n  rw [average_eq, Measure.add_apply]\n\n"}
{"name":"MeasureTheory.average_pair","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\nm0 : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\ninst✝¹ : CompleteSpace F\nμ : MeasureTheory.Measure α\ninst✝ : CompleteSpace E\nf : α → E\ng : α → F\nhfi : MeasureTheory.Integrable f μ\nhgi : MeasureTheory.Integrable g μ\n⊢ Eq (MeasureTheory.average μ fun x => { fst := f x, snd := g x }) { fst := MeasureTheory.average μ fun x => f x, snd := MeasureTheory.average μ fun x => g x }","decl":"theorem average_pair [CompleteSpace E]\n    {f : α → E} {g : α → F} (hfi : Integrable f μ) (hgi : Integrable g μ) :\n    ⨍ x, (f x, g x) ∂μ = (⨍ x, f x ∂μ, ⨍ x, g x ∂μ) :=\n  integral_pair hfi.to_average hgi.to_average\n\n"}
{"name":"MeasureTheory.measure_smul_setAverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\nh : Ne (μ s) Top.top\n⊢ Eq (HSMul.hSMul (μ s).toReal (MeasureTheory.average (μ.restrict s) fun x => f x)) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem measure_smul_setAverage (f : α → E) {s : Set α} (h : μ s ≠ ∞) :\n    (μ s).toReal • ⨍ x in s, f x ∂μ = ∫ x in s, f x ∂μ := by\n  haveI := Fact.mk h.lt_top\n  rw [← measure_smul_average, restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.average_union","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\ns t : Set α\nhd : MeasureTheory.AEDisjoint μ s t\nht : MeasureTheory.NullMeasurableSet t μ\nhsμ : Ne (μ s) Top.top\nhtμ : Ne (μ t) Top.top\nhfs : MeasureTheory.IntegrableOn f s μ\nhft : MeasureTheory.IntegrableOn f t μ\n⊢ Eq (MeasureTheory.average (μ.restrict (Union.union s t)) fun x => f x) (HAdd.hAdd (HSMul.hSMul (HDiv.hDiv (μ s).toReal (HAdd.hAdd (μ s).toReal (μ t).toReal)) (MeasureTheory.average (μ.restrict s) fun x => f x)) (HSMul.hSMul (HDiv.hDiv (μ t).toReal (HAdd.hAdd (μ s).toReal (μ t).toReal)) (MeasureTheory.average (μ.restrict t) fun x => f x)))","decl":"theorem average_union {f : α → E} {s t : Set α} (hd : AEDisjoint μ s t) (ht : NullMeasurableSet t μ)\n    (hsμ : μ s ≠ ∞) (htμ : μ t ≠ ∞) (hfs : IntegrableOn f s μ) (hft : IntegrableOn f t μ) :\n    ⨍ x in s ∪ t, f x ∂μ =\n      ((μ s).toReal / ((μ s).toReal + (μ t).toReal)) • ⨍ x in s, f x ∂μ +\n        ((μ t).toReal / ((μ s).toReal + (μ t).toReal)) • ⨍ x in t, f x ∂μ := by\n  haveI := Fact.mk hsμ.lt_top; haveI := Fact.mk htμ.lt_top\n  rw [restrict_union₀ hd ht, average_add_measure hfs hft, restrict_apply_univ, restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.average_union_mem_openSegment","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\ns t : Set α\nhd : MeasureTheory.AEDisjoint μ s t\nht : MeasureTheory.NullMeasurableSet t μ\nhs₀ : Ne (μ s) 0\nht₀ : Ne (μ t) 0\nhsμ : Ne (μ s) Top.top\nhtμ : Ne (μ t) Top.top\nhfs : MeasureTheory.IntegrableOn f s μ\nhft : MeasureTheory.IntegrableOn f t μ\n⊢ Membership.mem (openSegment Real (MeasureTheory.average (μ.restrict s) fun x => f x) (MeasureTheory.average (μ.restrict t) fun x => f x)) (MeasureTheory.average (μ.restrict (Union.union s t)) fun x => f x)","decl":"theorem average_union_mem_openSegment {f : α → E} {s t : Set α} (hd : AEDisjoint μ s t)\n    (ht : NullMeasurableSet t μ) (hs₀ : μ s ≠ 0) (ht₀ : μ t ≠ 0) (hsμ : μ s ≠ ∞) (htμ : μ t ≠ ∞)\n    (hfs : IntegrableOn f s μ) (hft : IntegrableOn f t μ) :\n    ⨍ x in s ∪ t, f x ∂μ ∈ openSegment ℝ (⨍ x in s, f x ∂μ) (⨍ x in t, f x ∂μ) := by\n  replace hs₀ : 0 < (μ s).toReal := ENNReal.toReal_pos hs₀ hsμ\n  replace ht₀ : 0 < (μ t).toReal := ENNReal.toReal_pos ht₀ htμ\n  exact mem_openSegment_iff_div.mpr\n    ⟨(μ s).toReal, (μ t).toReal, hs₀, ht₀, (average_union hd ht hsμ htμ hfs hft).symm⟩\n\n"}
{"name":"MeasureTheory.average_union_mem_segment","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\ns t : Set α\nhd : MeasureTheory.AEDisjoint μ s t\nht : MeasureTheory.NullMeasurableSet t μ\nhsμ : Ne (μ s) Top.top\nhtμ : Ne (μ t) Top.top\nhfs : MeasureTheory.IntegrableOn f s μ\nhft : MeasureTheory.IntegrableOn f t μ\n⊢ Membership.mem (segment Real (MeasureTheory.average (μ.restrict s) fun x => f x) (MeasureTheory.average (μ.restrict t) fun x => f x)) (MeasureTheory.average (μ.restrict (Union.union s t)) fun x => f x)","decl":"theorem average_union_mem_segment {f : α → E} {s t : Set α} (hd : AEDisjoint μ s t)\n    (ht : NullMeasurableSet t μ) (hsμ : μ s ≠ ∞) (htμ : μ t ≠ ∞) (hfs : IntegrableOn f s μ)\n    (hft : IntegrableOn f t μ) :\n    ⨍ x in s ∪ t, f x ∂μ ∈ [⨍ x in s, f x ∂μ -[ℝ] ⨍ x in t, f x ∂μ] := by\n  by_cases hse : μ s = 0\n  · rw [← ae_eq_empty] at hse\n    rw [restrict_congr_set (hse.union EventuallyEq.rfl), empty_union]\n    exact right_mem_segment _ _ _\n  · refine\n      mem_segment_iff_div.mpr\n        ⟨(μ s).toReal, (μ t).toReal, ENNReal.toReal_nonneg, ENNReal.toReal_nonneg, ?_,\n          (average_union hd ht hsμ htμ hfs hft).symm⟩\n    calc\n      0 < (μ s).toReal := ENNReal.toReal_pos hse hsμ\n      _ ≤ _ := le_add_of_nonneg_right ENNReal.toReal_nonneg\n\n"}
{"name":"MeasureTheory.average_mem_openSegment_compl_self","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → E\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nhs₀ : Ne (μ s) 0\nhsc₀ : Ne (μ (HasCompl.compl s)) 0\nhfi : MeasureTheory.Integrable f μ\n⊢ Membership.mem (openSegment Real (MeasureTheory.average (μ.restrict s) fun x => f x) (MeasureTheory.average (μ.restrict (HasCompl.compl s)) fun x => f x)) (MeasureTheory.average μ fun x => f x)","decl":"theorem average_mem_openSegment_compl_self [IsFiniteMeasure μ] {f : α → E} {s : Set α}\n    (hs : NullMeasurableSet s μ) (hs₀ : μ s ≠ 0) (hsc₀ : μ sᶜ ≠ 0) (hfi : Integrable f μ) :\n    ⨍ x, f x ∂μ ∈ openSegment ℝ (⨍ x in s, f x ∂μ) (⨍ x in sᶜ, f x ∂μ) := by\n  simpa only [union_compl_self, restrict_univ] using\n    average_union_mem_openSegment aedisjoint_compl_right hs.compl hs₀ hsc₀ (measure_ne_top _ _)\n      (measure_ne_top _ _) hfi.integrableOn hfi.integrableOn\n\n"}
{"name":"MeasureTheory.average_const","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : NeZero μ\nc : E\n⊢ Eq (MeasureTheory.average μ fun _x => c) c","decl":"@[simp]\ntheorem average_const (μ : Measure α) [IsFiniteMeasure μ] [h : NeZero μ] (c : E) :\n    ⨍ _x, c ∂μ = c := by\n  rw [average, integral_const, measure_univ, ENNReal.one_toReal, one_smul]\n\n"}
{"name":"MeasureTheory.setAverage_const","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure α\ninst✝ : CompleteSpace E\ns : Set α\nhs₀ : Ne (μ s) 0\nhs : Ne (μ s) Top.top\nc : E\n⊢ Eq (MeasureTheory.average (μ.restrict s) fun x => c) c","decl":"theorem setAverage_const {s : Set α} (hs₀ : μ s ≠ 0) (hs : μ s ≠ ∞) (c : E) :\n    ⨍ _ in s, c ∂μ = c :=\n  have := NeZero.mk hs₀; have := Fact.mk hs.lt_top; average_const _ _\n\n"}
{"name":"MeasureTheory.integral_average","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → E\n⊢ Eq (MeasureTheory.integral μ fun x => MeasureTheory.average μ fun a => f a) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_average (μ : Measure α) [IsFiniteMeasure μ] (f : α → E) :\n    ∫ _, ⨍ a, f a ∂μ ∂μ = ∫ x, f x ∂μ := by simp\n\n"}
{"name":"MeasureTheory.setIntegral_setAverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → E\ns : Set α\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => MeasureTheory.average (μ.restrict s) fun a => f a) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem setIntegral_setAverage (μ : Measure α) [IsFiniteMeasure μ] (f : α → E) (s : Set α) :\n    ∫ _ in s, ⨍ a in s, f a ∂μ ∂μ = ∫ x in s, f x ∂μ :=\n  integral_average _ _\n\n"}
{"name":"MeasureTheory.integral_sub_average","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → E\n⊢ Eq (MeasureTheory.integral μ fun x => HSub.hSub (f x) (MeasureTheory.average μ fun a => f a)) 0","decl":"theorem integral_sub_average (μ : Measure α) [IsFiniteMeasure μ] (f : α → E) :\n    ∫ x, f x - ⨍ a, f a ∂μ ∂μ = 0 := by\n  by_cases hf : Integrable f μ\n  · rw [integral_sub hf (integrable_const _), integral_average, sub_self]\n  refine integral_undef fun h => hf ?_\n  convert h.add (integrable_const (⨍ a, f a ∂μ))\n  exact (sub_add_cancel _ _).symm\n\n"}
{"name":"MeasureTheory.setAverage_sub_setAverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure α\ns : Set α\ninst✝ : CompleteSpace E\nhs : Ne (μ s) Top.top\nf : α → E\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => HSub.hSub (f x) (MeasureTheory.average (μ.restrict s) fun a => f a)) 0","decl":"theorem setAverage_sub_setAverage (hs : μ s ≠ ∞) (f : α → E) :\n    ∫ x in s, f x - ⨍ a in s, f a ∂μ ∂μ = 0 :=\n  haveI : Fact (μ s < ∞) := ⟨lt_top_iff_ne_top.2 hs⟩\n  integral_sub_average _ _\n\n"}
{"name":"MeasureTheory.integral_average_sub","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nμ : MeasureTheory.Measure α\nf : α → E\ninst✝¹ : CompleteSpace E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => HSub.hSub (MeasureTheory.average μ fun a => f a) (f x)) 0","decl":"theorem integral_average_sub [IsFiniteMeasure μ] (hf : Integrable f μ) :\n    ∫ x, ⨍ a, f a ∂μ - f x ∂μ = 0 := by\n  rw [integral_sub (integrable_const _) hf, integral_average, sub_self]\n\n"}
{"name":"MeasureTheory.setIntegral_setAverage_sub","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → E\ninst✝ : CompleteSpace E\nhs : Ne (μ s) Top.top\nhf : MeasureTheory.IntegrableOn f s μ\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => HSub.hSub (MeasureTheory.average (μ.restrict s) fun a => f a) (f x)) 0","decl":"theorem setIntegral_setAverage_sub (hs : μ s ≠ ∞) (hf : IntegrableOn f s μ) :\n    ∫ x in s, ⨍ a in s, f a ∂μ - f x ∂μ = 0 :=\n  haveI : Fact (μ s < ∞) := ⟨lt_top_iff_ne_top.2 hs⟩\n  integral_average_sub hf\n\n"}
{"name":"MeasureTheory.ofReal_average","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\nhf₀ : (MeasureTheory.ae μ).EventuallyLE 0 f\n⊢ Eq (ENNReal.ofReal (MeasureTheory.average μ fun x => f x)) (HDiv.hDiv (MeasureTheory.lintegral μ fun x => ENNReal.ofReal (f x)) (μ Set.univ))","decl":"theorem ofReal_average {f : α → ℝ} (hf : Integrable f μ) (hf₀ : 0 ≤ᵐ[μ] f) :\n    ENNReal.ofReal (⨍ x, f x ∂μ) = (∫⁻ x, ENNReal.ofReal (f x) ∂μ) / μ univ := by\n  obtain rfl | hμ := eq_or_ne μ 0\n  · simp\n  · rw [average_eq, smul_eq_mul, ← toReal_inv, ofReal_mul toReal_nonneg,\n      ofReal_toReal (inv_ne_top.2 <| measure_univ_ne_zero.2 hμ),\n      ofReal_integral_eq_lintegral_ofReal hf hf₀, ENNReal.div_eq_inv_mul]\n\n"}
{"name":"MeasureTheory.ofReal_setAverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → Real\nhf : MeasureTheory.IntegrableOn f s μ\nhf₀ : (MeasureTheory.ae (μ.restrict s)).EventuallyLE 0 f\n⊢ Eq (ENNReal.ofReal (MeasureTheory.average (μ.restrict s) fun x => f x)) (HDiv.hDiv (MeasureTheory.lintegral (μ.restrict s) fun x => ENNReal.ofReal (f x)) (μ s))","decl":"theorem ofReal_setAverage {f : α → ℝ} (hf : IntegrableOn f s μ) (hf₀ : 0 ≤ᵐ[μ.restrict s] f) :\n    ENNReal.ofReal (⨍ x in s, f x ∂μ) = (∫⁻ x in s, ENNReal.ofReal (f x) ∂μ) / μ s := by\n  simpa using ofReal_average hf hf₀\n\n"}
{"name":"MeasureTheory.toReal_laverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nhf' : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.laverage μ fun x => f x).toReal (MeasureTheory.average μ fun x => (f x).toReal)","decl":"theorem toReal_laverage {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hf' : ∀ᵐ x ∂μ, f x ≠ ∞) :\n    (⨍⁻ x, f x ∂μ).toReal = ⨍ x, (f x).toReal ∂μ := by\n    rw [average_eq, laverage_eq, smul_eq_mul, toReal_div, div_eq_inv_mul, ←\n      integral_toReal hf (hf'.mono fun _ => lt_top_iff_ne_top.2)]\n\n"}
{"name":"MeasureTheory.toReal_setLaverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhf : AEMeasurable f (μ.restrict s)\nhf' : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae (μ.restrict s))\n⊢ Eq (MeasureTheory.laverage (μ.restrict s) fun x => f x).toReal (MeasureTheory.average (μ.restrict s) fun x => (f x).toReal)","decl":"theorem toReal_setLaverage {f : α → ℝ≥0∞} (hf : AEMeasurable f (μ.restrict s))\n    (hf' : ∀ᵐ x ∂μ.restrict s, f x ≠ ∞) :\n    (⨍⁻ x in s, f x ∂μ).toReal = ⨍ x in s, (f x).toReal ∂μ := by\n  simpa [laverage_eq] using toReal_laverage hf hf'\n\n"}
{"name":"MeasureTheory.measure_le_setAverage_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → Real\nhμ : Ne (μ s) 0\nhμ₁ : Ne (μ s) Top.top\nhf : MeasureTheory.IntegrableOn f s μ\n⊢ LT.lt 0 (μ (setOf fun x => And (Membership.mem s x) (LE.le (f x) (MeasureTheory.average (μ.restrict s) fun a => f a))))","decl":"/-- **First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. -/\ntheorem measure_le_setAverage_pos (hμ : μ s ≠ 0) (hμ₁ : μ s ≠ ∞) (hf : IntegrableOn f s μ) :\n    0 < μ ({x ∈ s | f x ≤ ⨍ a in s, f a ∂μ}) := by\n  refine pos_iff_ne_zero.2 fun H => ?_\n  replace H : (μ.restrict s) {x | f x ≤ ⨍ a in s, f a ∂μ} = 0 := by\n    rwa [restrict_apply₀, inter_comm]\n    exact AEStronglyMeasurable.nullMeasurableSet_le hf.1 aestronglyMeasurable_const\n  haveI := Fact.mk hμ₁.lt_top\n  refine (integral_sub_average (μ.restrict s) f).not_gt ?_\n  refine (setIntegral_pos_iff_support_of_nonneg_ae ?_ ?_).2 ?_\n  · refine measure_mono_null (fun x hx ↦ ?_) H\n    simp only [Pi.zero_apply, sub_nonneg, mem_compl_iff, mem_setOf_eq, not_le] at hx\n    exact hx.le\n  · exact hf.sub (integrableOn_const.2 <| Or.inr <| lt_top_iff_ne_top.2 hμ₁)\n  · rwa [pos_iff_ne_zero, inter_comm, ← diff_compl, ← diff_inter_self_eq_diff, measure_diff_null]\n    refine measure_mono_null ?_ (measure_inter_eq_zero_of_restrict H)\n    exact inter_subset_inter_left _ fun a ha => (sub_eq_zero.1 <| of_not_not ha).le\n\n"}
{"name":"MeasureTheory.measure_setAverage_le_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → Real\nhμ : Ne (μ s) 0\nhμ₁ : Ne (μ s) Top.top\nhf : MeasureTheory.IntegrableOn f s μ\n⊢ LT.lt 0 (μ (setOf fun x => And (Membership.mem s x) (LE.le (MeasureTheory.average (μ.restrict s) fun a => f a) (f x))))","decl":"/-- **First moment method**. An integrable function is greater than its mean on a set of positive\nmeasure. -/\ntheorem measure_setAverage_le_pos (hμ : μ s ≠ 0) (hμ₁ : μ s ≠ ∞) (hf : IntegrableOn f s μ) :\n    0 < μ ({x ∈ s | ⨍ a in s, f a ∂μ ≤ f x}) := by\n  simpa [integral_neg, neg_div] using measure_le_setAverage_pos hμ hμ₁ hf.neg\n\n"}
{"name":"MeasureTheory.exists_le_setAverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → Real\nhμ : Ne (μ s) 0\nhμ₁ : Ne (μ s) Top.top\nhf : MeasureTheory.IntegrableOn f s μ\n⊢ Exists fun x => And (Membership.mem s x) (LE.le (f x) (MeasureTheory.average (μ.restrict s) fun a => f a))","decl":"/-- **First moment method**. The minimum of an integrable function is smaller than its mean. -/\ntheorem exists_le_setAverage (hμ : μ s ≠ 0) (hμ₁ : μ s ≠ ∞) (hf : IntegrableOn f s μ) :\n    ∃ x ∈ s, f x ≤ ⨍ a in s, f a ∂μ :=\n  let ⟨x, hx, h⟩ := nonempty_of_measure_ne_zero (measure_le_setAverage_pos hμ hμ₁ hf).ne'\n  ⟨x, hx, h⟩\n\n"}
{"name":"MeasureTheory.exists_setAverage_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → Real\nhμ : Ne (μ s) 0\nhμ₁ : Ne (μ s) Top.top\nhf : MeasureTheory.IntegrableOn f s μ\n⊢ Exists fun x => And (Membership.mem s x) (LE.le (MeasureTheory.average (μ.restrict s) fun a => f a) (f x))","decl":"/-- **First moment method**. The maximum of an integrable function is greater than its mean. -/\ntheorem exists_setAverage_le (hμ : μ s ≠ 0) (hμ₁ : μ s ≠ ∞) (hf : IntegrableOn f s μ) :\n    ∃ x ∈ s, ⨍ a in s, f a ∂μ ≤ f x :=\n  let ⟨x, hx, h⟩ := nonempty_of_measure_ne_zero (measure_setAverage_le_pos hμ hμ₁ hf).ne'\n  ⟨x, hx, h⟩\n\n"}
{"name":"MeasureTheory.measure_le_average_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nhf : MeasureTheory.Integrable f μ\n⊢ LT.lt 0 (μ (setOf fun x => LE.le (f x) (MeasureTheory.average μ fun a => f a)))","decl":"/-- **First moment method**. An integrable function is smaller than its mean on a set of positive\nmeasure. -/\ntheorem measure_le_average_pos (hμ : μ ≠ 0) (hf : Integrable f μ) :\n    0 < μ {x | f x ≤ ⨍ a, f a ∂μ} := by\n  simpa using measure_le_setAverage_pos (Measure.measure_univ_ne_zero.2 hμ) (measure_ne_top _ _)\n    hf.integrableOn\n\n"}
{"name":"MeasureTheory.measure_average_le_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nhf : MeasureTheory.Integrable f μ\n⊢ LT.lt 0 (μ (setOf fun x => LE.le (MeasureTheory.average μ fun a => f a) (f x)))","decl":"/-- **First moment method**. An integrable function is greater than its mean on a set of positive\nmeasure. -/\ntheorem measure_average_le_pos (hμ : μ ≠ 0) (hf : Integrable f μ) :\n    0 < μ {x | ⨍ a, f a ∂μ ≤ f x} := by\n  simpa using measure_setAverage_le_pos (Measure.measure_univ_ne_zero.2 hμ) (measure_ne_top _ _)\n    hf.integrableOn\n\n"}
{"name":"MeasureTheory.exists_le_average","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nhf : MeasureTheory.Integrable f μ\n⊢ Exists fun x => LE.le (f x) (MeasureTheory.average μ fun a => f a)","decl":"/-- **First moment method**. The minimum of an integrable function is smaller than its mean. -/\ntheorem exists_le_average (hμ : μ ≠ 0) (hf : Integrable f μ) : ∃ x, f x ≤ ⨍ a, f a ∂μ :=\n  let ⟨x, hx⟩ := nonempty_of_measure_ne_zero (measure_le_average_pos hμ hf).ne'\n  ⟨x, hx⟩\n\n"}
{"name":"MeasureTheory.exists_average_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nhf : MeasureTheory.Integrable f μ\n⊢ Exists fun x => LE.le (MeasureTheory.average μ fun a => f a) (f x)","decl":"/-- **First moment method**. The maximum of an integrable function is greater than its mean. -/\ntheorem exists_average_le (hμ : μ ≠ 0) (hf : Integrable f μ) : ∃ x, ⨍ a, f a ∂μ ≤ f x :=\n  let ⟨x, hx⟩ := nonempty_of_measure_ne_zero (measure_average_le_pos hμ hf).ne'\n  ⟨x, hx⟩\n\n"}
{"name":"MeasureTheory.exists_not_mem_null_le_average","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nN : Set α\nf : α → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nhf : MeasureTheory.Integrable f μ\nhN : Eq (μ N) 0\n⊢ Exists fun x => And (Not (Membership.mem N x)) (LE.le (f x) (MeasureTheory.average μ fun a => f a))","decl":"/-- **First moment method**. The minimum of an integrable function is smaller than its mean, while\navoiding a null set. -/\ntheorem exists_not_mem_null_le_average (hμ : μ ≠ 0) (hf : Integrable f μ) (hN : μ N = 0) :\n    ∃ x, x ∉ N ∧ f x ≤ ⨍ a, f a ∂μ := by\n  have := measure_le_average_pos hμ hf\n  rw [← measure_diff_null hN] at this\n  obtain ⟨x, hx, hxN⟩ := nonempty_of_measure_ne_zero this.ne'\n  exact ⟨x, hxN, hx⟩\n\n"}
{"name":"MeasureTheory.exists_not_mem_null_average_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nN : Set α\nf : α → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nhf : MeasureTheory.Integrable f μ\nhN : Eq (μ N) 0\n⊢ Exists fun x => And (Not (Membership.mem N x)) (LE.le (MeasureTheory.average μ fun a => f a) (f x))","decl":"/-- **First moment method**. The maximum of an integrable function is greater than its mean, while\navoiding a null set. -/\ntheorem exists_not_mem_null_average_le (hμ : μ ≠ 0) (hf : Integrable f μ) (hN : μ N = 0) :\n    ∃ x, x ∉ N ∧ ⨍ a, f a ∂μ ≤ f x := by\n  simpa [integral_neg, neg_div] using exists_not_mem_null_le_average hμ hf.neg hN\n\n"}
{"name":"MeasureTheory.measure_le_integral_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : MeasureTheory.Integrable f μ\n⊢ LT.lt 0 (μ (setOf fun x => LE.le (f x) (MeasureTheory.integral μ fun a => f a)))","decl":"/-- **First moment method**. An integrable function is smaller than its integral on a set of\npositive measure. -/\ntheorem measure_le_integral_pos (hf : Integrable f μ) : 0 < μ {x | f x ≤ ∫ a, f a ∂μ} := by\n  simpa only [average_eq_integral] using\n    measure_le_average_pos (IsProbabilityMeasure.ne_zero μ) hf\n\n"}
{"name":"MeasureTheory.measure_integral_le_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : MeasureTheory.Integrable f μ\n⊢ LT.lt 0 (μ (setOf fun x => LE.le (MeasureTheory.integral μ fun a => f a) (f x)))","decl":"/-- **First moment method**. An integrable function is greater than its integral on a set of\npositive measure. -/\ntheorem measure_integral_le_pos (hf : Integrable f μ) : 0 < μ {x | ∫ a, f a ∂μ ≤ f x} := by\n  simpa only [average_eq_integral] using\n    measure_average_le_pos (IsProbabilityMeasure.ne_zero μ) hf\n\n"}
{"name":"MeasureTheory.exists_le_integral","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : MeasureTheory.Integrable f μ\n⊢ Exists fun x => LE.le (f x) (MeasureTheory.integral μ fun a => f a)","decl":"/-- **First moment method**. The minimum of an integrable function is smaller than its integral. -/\ntheorem exists_le_integral (hf : Integrable f μ) : ∃ x, f x ≤ ∫ a, f a ∂μ := by\n  simpa only [average_eq_integral] using exists_le_average (IsProbabilityMeasure.ne_zero μ) hf\n\n"}
{"name":"MeasureTheory.exists_integral_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : MeasureTheory.Integrable f μ\n⊢ Exists fun x => LE.le (MeasureTheory.integral μ fun a => f a) (f x)","decl":"/-- **First moment method**. The maximum of an integrable function is greater than its integral. -/\ntheorem exists_integral_le (hf : Integrable f μ) : ∃ x, ∫ a, f a ∂μ ≤ f x := by\n  simpa only [average_eq_integral] using exists_average_le (IsProbabilityMeasure.ne_zero μ) hf\n\n"}
{"name":"MeasureTheory.exists_not_mem_null_le_integral","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nN : Set α\nf : α → Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : MeasureTheory.Integrable f μ\nhN : Eq (μ N) 0\n⊢ Exists fun x => And (Not (Membership.mem N x)) (LE.le (f x) (MeasureTheory.integral μ fun a => f a))","decl":"/-- **First moment method**. The minimum of an integrable function is smaller than its integral,\nwhile avoiding a null set. -/\ntheorem exists_not_mem_null_le_integral (hf : Integrable f μ) (hN : μ N = 0) :\n    ∃ x, x ∉ N ∧ f x ≤ ∫ a, f a ∂μ := by\n  simpa only [average_eq_integral] using\n    exists_not_mem_null_le_average (IsProbabilityMeasure.ne_zero μ) hf hN\n\n"}
{"name":"MeasureTheory.exists_not_mem_null_integral_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nN : Set α\nf : α → Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : MeasureTheory.Integrable f μ\nhN : Eq (μ N) 0\n⊢ Exists fun x => And (Not (Membership.mem N x)) (LE.le (MeasureTheory.integral μ fun a => f a) (f x))","decl":"/-- **First moment method**. The maximum of an integrable function is greater than its integral,\nwhile avoiding a null set. -/\ntheorem exists_not_mem_null_integral_le (hf : Integrable f μ) (hN : μ N = 0) :\n    ∃ x, x ∉ N ∧ ∫ a, f a ∂μ ≤ f x := by\n  simpa only [average_eq_integral] using\n    exists_not_mem_null_average_le (IsProbabilityMeasure.ne_zero μ) hf hN\n\n"}
{"name":"MeasureTheory.measure_le_setLaverage_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhμ : Ne (μ s) 0\nhμ₁ : Ne (μ s) Top.top\nhf : AEMeasurable f (μ.restrict s)\n⊢ LT.lt 0 (μ (setOf fun x => And (Membership.mem s x) (LE.le (f x) (MeasureTheory.laverage (μ.restrict s) fun a => f a))))","decl":"/-- **First moment method**. A measurable function is smaller than its mean on a set of positive\nmeasure. -/\ntheorem measure_le_setLaverage_pos (hμ : μ s ≠ 0) (hμ₁ : μ s ≠ ∞)\n    (hf : AEMeasurable f (μ.restrict s)) : 0 < μ {x ∈ s | f x ≤ ⨍⁻ a in s, f a ∂μ} := by\n  obtain h | h := eq_or_ne (∫⁻ a in s, f a ∂μ) ∞\n  · simpa [mul_top, hμ₁, laverage, h, top_div_of_ne_top hμ₁, pos_iff_ne_zero] using hμ\n  have := measure_le_setAverage_pos hμ hμ₁ (integrable_toReal_of_lintegral_ne_top hf h)\n  rw [← setOf_inter_eq_sep, ← Measure.restrict_apply₀\n    (hf.aestronglyMeasurable.nullMeasurableSet_le aestronglyMeasurable_const)]\n  rw [← setOf_inter_eq_sep, ← Measure.restrict_apply₀\n    (hf.ennreal_toReal.aestronglyMeasurable.nullMeasurableSet_le aestronglyMeasurable_const),\n    ← measure_diff_null (measure_eq_top_of_lintegral_ne_top hf h)] at this\n  refine this.trans_le (measure_mono ?_)\n  rintro x ⟨hfx, hx⟩\n  dsimp at hfx\n  rwa [← toReal_laverage hf, toReal_le_toReal hx (setLaverage_lt_top h).ne] at hfx\n  simp_rw [ae_iff, not_ne_iff]\n  exact measure_eq_top_of_lintegral_ne_top hf h\n\n"}
{"name":"MeasureTheory.measure_setLaverage_le_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhμ : Ne (μ s) 0\nhs : MeasureTheory.NullMeasurableSet s μ\nhint : Ne (MeasureTheory.lintegral (μ.restrict s) fun a => f a) Top.top\n⊢ LT.lt 0 (μ (setOf fun x => And (Membership.mem s x) (LE.le (MeasureTheory.laverage (μ.restrict s) fun a => f a) (f x))))","decl":"/-- **First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. -/\ntheorem measure_setLaverage_le_pos (hμ : μ s ≠ 0) (hs : NullMeasurableSet s μ)\n    (hint : ∫⁻ a in s, f a ∂μ ≠ ∞) : 0 < μ {x ∈ s | ⨍⁻ a in s, f a ∂μ ≤ f x} := by\n  obtain hμ₁ | hμ₁ := eq_or_ne (μ s) ∞\n  · simp [setLaverage_eq, hμ₁]\n  obtain ⟨g, hg, hgf, hfg⟩ := exists_measurable_le_lintegral_eq (μ.restrict s) f\n  have hfg' : ⨍⁻ a in s, f a ∂μ = ⨍⁻ a in s, g a ∂μ := by simp_rw [laverage_eq, hfg]\n  rw [hfg] at hint\n  have :=\n    measure_setAverage_le_pos hμ hμ₁ (integrable_toReal_of_lintegral_ne_top hg.aemeasurable hint)\n  simp_rw [← setOf_inter_eq_sep, ← Measure.restrict_apply₀' hs, hfg']\n  rw [← setOf_inter_eq_sep, ← Measure.restrict_apply₀' hs, ←\n    measure_diff_null (measure_eq_top_of_lintegral_ne_top hg.aemeasurable hint)] at this\n  refine this.trans_le (measure_mono ?_)\n  rintro x ⟨hfx, hx⟩\n  dsimp at hfx\n  rw [← toReal_laverage hg.aemeasurable, toReal_le_toReal (setLaverage_lt_top hint).ne hx] at hfx\n  · exact hfx.trans (hgf _)\n  · simp_rw [ae_iff, not_ne_iff]\n    exact measure_eq_top_of_lintegral_ne_top hg.aemeasurable hint\n\n"}
{"name":"MeasureTheory.exists_le_setLaverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhμ : Ne (μ s) 0\nhμ₁ : Ne (μ s) Top.top\nhf : AEMeasurable f (μ.restrict s)\n⊢ Exists fun x => And (Membership.mem s x) (LE.le (f x) (MeasureTheory.laverage (μ.restrict s) fun a => f a))","decl":"/-- **First moment method**. The minimum of a measurable function is smaller than its mean. -/\ntheorem exists_le_setLaverage (hμ : μ s ≠ 0) (hμ₁ : μ s ≠ ∞) (hf : AEMeasurable f (μ.restrict s)) :\n    ∃ x ∈ s, f x ≤ ⨍⁻ a in s, f a ∂μ :=\n  let ⟨x, hx, h⟩ := nonempty_of_measure_ne_zero (measure_le_setLaverage_pos hμ hμ₁ hf).ne'\n  ⟨x, hx, h⟩\n\n"}
{"name":"MeasureTheory.exists_setLaverage_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhμ : Ne (μ s) 0\nhs : MeasureTheory.NullMeasurableSet s μ\nhint : Ne (MeasureTheory.lintegral (μ.restrict s) fun a => f a) Top.top\n⊢ Exists fun x => And (Membership.mem s x) (LE.le (MeasureTheory.laverage (μ.restrict s) fun a => f a) (f x))","decl":"/-- **First moment method**. The maximum of a measurable function is greater than its mean. -/\ntheorem exists_setLaverage_le (hμ : μ s ≠ 0) (hs : NullMeasurableSet s μ)\n    (hint : ∫⁻ a in s, f a ∂μ ≠ ∞) : ∃ x ∈ s, ⨍⁻ a in s, f a ∂μ ≤ f x :=\n  let ⟨x, hx, h⟩ := nonempty_of_measure_ne_zero (measure_setLaverage_le_pos hμ hs hint).ne'\n  ⟨x, hx, h⟩\n\n"}
{"name":"MeasureTheory.measure_laverage_le_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhμ : Ne μ 0\nhint : Ne (MeasureTheory.lintegral μ fun a => f a) Top.top\n⊢ LT.lt 0 (μ (setOf fun x => LE.le (MeasureTheory.laverage μ fun a => f a) (f x)))","decl":"/-- **First moment method**. A measurable function is greater than its mean on a set of positive\nmeasure. -/\ntheorem measure_laverage_le_pos (hμ : μ ≠ 0) (hint : ∫⁻ a, f a ∂μ ≠ ∞) :\n    0 < μ {x | ⨍⁻ a, f a ∂μ ≤ f x} := by\n  simpa [hint] using\n    @measure_setLaverage_le_pos _ _ _ _ f (measure_univ_ne_zero.2 hμ) nullMeasurableSet_univ\n\n"}
{"name":"MeasureTheory.exists_laverage_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhμ : Ne μ 0\nhint : Ne (MeasureTheory.lintegral μ fun a => f a) Top.top\n⊢ Exists fun x => LE.le (MeasureTheory.laverage μ fun a => f a) (f x)","decl":"/-- **First moment method**. The maximum of a measurable function is greater than its mean. -/\ntheorem exists_laverage_le (hμ : μ ≠ 0) (hint : ∫⁻ a, f a ∂μ ≠ ∞) : ∃ x, ⨍⁻ a, f a ∂μ ≤ f x :=\n  let ⟨x, hx⟩ := nonempty_of_measure_ne_zero (measure_laverage_le_pos hμ hint).ne'\n  ⟨x, hx⟩\n\n"}
{"name":"MeasureTheory.exists_not_mem_null_laverage_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nN : Set α\nf : α → ENNReal\nhμ : Ne μ 0\nhint : Ne (MeasureTheory.lintegral μ fun a => f a) Top.top\nhN : Eq (μ N) 0\n⊢ Exists fun x => And (Not (Membership.mem N x)) (LE.le (MeasureTheory.laverage μ fun a => f a) (f x))","decl":"/-- **First moment method**. The maximum of a measurable function is greater than its mean, while\navoiding a null set. -/\ntheorem exists_not_mem_null_laverage_le (hμ : μ ≠ 0) (hint : ∫⁻ a : α, f a ∂μ ≠ ∞) (hN : μ N = 0) :\n    ∃ x, x ∉ N ∧ ⨍⁻ a, f a ∂μ ≤ f x := by\n  have := measure_laverage_le_pos hμ hint\n  rw [← measure_diff_null hN] at this\n  obtain ⟨x, hx, hxN⟩ := nonempty_of_measure_ne_zero this.ne'\n  exact ⟨x, hxN, hx⟩\n\n"}
{"name":"MeasureTheory.measure_le_laverage_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nhf : AEMeasurable f μ\n⊢ LT.lt 0 (μ (setOf fun x => LE.le (f x) (MeasureTheory.laverage μ fun a => f a)))","decl":"/-- **First moment method**. A measurable function is smaller than its mean on a set of positive\nmeasure. -/\ntheorem measure_le_laverage_pos (hμ : μ ≠ 0) (hf : AEMeasurable f μ) :\n    0 < μ {x | f x ≤ ⨍⁻ a, f a ∂μ} := by\n  simpa using\n    measure_le_setLaverage_pos (measure_univ_ne_zero.2 hμ) (measure_ne_top _ _) hf.restrict\n\n"}
{"name":"MeasureTheory.exists_le_laverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nhf : AEMeasurable f μ\n⊢ Exists fun x => LE.le (f x) (MeasureTheory.laverage μ fun a => f a)","decl":"/-- **First moment method**. The minimum of a measurable function is smaller than its mean. -/\ntheorem exists_le_laverage (hμ : μ ≠ 0) (hf : AEMeasurable f μ) : ∃ x, f x ≤ ⨍⁻ a, f a ∂μ :=\n  let ⟨x, hx⟩ := nonempty_of_measure_ne_zero (measure_le_laverage_pos hμ hf).ne'\n  ⟨x, hx⟩\n\n"}
{"name":"MeasureTheory.exists_not_mem_null_le_laverage","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nN : Set α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμ : Ne μ 0\nhf : AEMeasurable f μ\nhN : Eq (μ N) 0\n⊢ Exists fun x => And (Not (Membership.mem N x)) (LE.le (f x) (MeasureTheory.laverage μ fun a => f a))","decl":"/-- **First moment method**. The minimum of a measurable function is smaller than its mean, while\navoiding a null set. -/\ntheorem exists_not_mem_null_le_laverage (hμ : μ ≠ 0) (hf : AEMeasurable f μ) (hN : μ N = 0) :\n    ∃ x, x ∉ N ∧ f x ≤ ⨍⁻ a, f a ∂μ := by\n  have := measure_le_laverage_pos hμ hf\n  rw [← measure_diff_null hN] at this\n  obtain ⟨x, hx, hxN⟩ := nonempty_of_measure_ne_zero this.ne'\n  exact ⟨x, hxN, hx⟩\n\n"}
{"name":"MeasureTheory.measure_le_lintegral_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : AEMeasurable f μ\n⊢ LT.lt 0 (μ (setOf fun x => LE.le (f x) (MeasureTheory.lintegral μ fun a => f a)))","decl":"/-- **First moment method**. A measurable function is smaller than its integral on a set f\npositive measure. -/\ntheorem measure_le_lintegral_pos (hf : AEMeasurable f μ) : 0 < μ {x | f x ≤ ∫⁻ a, f a ∂μ} := by\n  simpa only [laverage_eq_lintegral] using\n    measure_le_laverage_pos (IsProbabilityMeasure.ne_zero μ) hf\n\n"}
{"name":"MeasureTheory.measure_lintegral_le_pos","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhint : Ne (MeasureTheory.lintegral μ fun a => f a) Top.top\n⊢ LT.lt 0 (μ (setOf fun x => LE.le (MeasureTheory.lintegral μ fun a => f a) (f x)))","decl":"/-- **First moment method**. A measurable function is greater than its integral on a set f\npositive measure. -/\ntheorem measure_lintegral_le_pos (hint : ∫⁻ a, f a ∂μ ≠ ∞) : 0 < μ {x | ∫⁻ a, f a ∂μ ≤ f x} := by\n  simpa only [laverage_eq_lintegral] using\n    measure_laverage_le_pos (IsProbabilityMeasure.ne_zero μ) hint\n\n"}
{"name":"MeasureTheory.exists_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : AEMeasurable f μ\n⊢ Exists fun x => LE.le (f x) (MeasureTheory.lintegral μ fun a => f a)","decl":"/-- **First moment method**. The minimum of a measurable function is smaller than its integral. -/\ntheorem exists_le_lintegral (hf : AEMeasurable f μ) : ∃ x, f x ≤ ∫⁻ a, f a ∂μ := by\n  simpa only [laverage_eq_lintegral] using exists_le_laverage (IsProbabilityMeasure.ne_zero μ) hf\n\n"}
{"name":"MeasureTheory.exists_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhint : Ne (MeasureTheory.lintegral μ fun a => f a) Top.top\n⊢ Exists fun x => LE.le (MeasureTheory.lintegral μ fun a => f a) (f x)","decl":"/-- **First moment method**. The maximum of a measurable function is greater than its integral. -/\ntheorem exists_lintegral_le (hint : ∫⁻ a, f a ∂μ ≠ ∞) : ∃ x, ∫⁻ a, f a ∂μ ≤ f x := by\n  simpa only [laverage_eq_lintegral] using\n    exists_laverage_le (IsProbabilityMeasure.ne_zero μ) hint\n\n"}
{"name":"MeasureTheory.exists_not_mem_null_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nN : Set α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : AEMeasurable f μ\nhN : Eq (μ N) 0\n⊢ Exists fun x => And (Not (Membership.mem N x)) (LE.le (f x) (MeasureTheory.lintegral μ fun a => f a))","decl":"/-- **First moment method**. The minimum of a measurable function is smaller than its integral,\nwhile avoiding a null set. -/\ntheorem exists_not_mem_null_le_lintegral (hf : AEMeasurable f μ) (hN : μ N = 0) :\n    ∃ x, x ∉ N ∧ f x ≤ ∫⁻ a, f a ∂μ := by\n  simpa only [laverage_eq_lintegral] using\n    exists_not_mem_null_le_laverage (IsProbabilityMeasure.ne_zero μ) hf hN\n\n"}
{"name":"MeasureTheory.exists_not_mem_null_lintegral_le","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nN : Set α\nf : α → ENNReal\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhint : Ne (MeasureTheory.lintegral μ fun a => f a) Top.top\nhN : Eq (μ N) 0\n⊢ Exists fun x => And (Not (Membership.mem N x)) (LE.le (MeasureTheory.lintegral μ fun a => f a) (f x))","decl":"/-- **First moment method**. The maximum of a measurable function is greater than its integral,\nwhile avoiding a null set. -/\ntheorem exists_not_mem_null_lintegral_le (hint : ∫⁻ a, f a ∂μ ≠ ∞) (hN : μ N = 0) :\n    ∃ x, x ∉ N ∧ ∫⁻ a, f a ∂μ ≤ f x := by\n  simpa only [laverage_eq_lintegral] using\n    exists_not_mem_null_laverage_le (IsProbabilityMeasure.ne_zero μ) hint hN\n\n"}
{"name":"MeasureTheory.tendsto_integral_smul_of_tendsto_average_norm_sub","module":"Mathlib.MeasureTheory.Integral.Average","initialProofState":"α : Type u_1\nE : Type u_2\nm0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure α\ninst✝ : CompleteSpace E\nι : Type u_4\na : ι → Set α\nl : Filter ι\nf : α → E\nc : E\ng : ι → α → Real\nK : Real\nhf : Filter.Tendsto (fun i => MeasureTheory.average (μ.restrict (a i)) fun y => Norm.norm (HSub.hSub (f y) c)) l (nhds 0)\nf_int : Filter.Eventually (fun i => MeasureTheory.IntegrableOn f (a i) μ) l\nhg : Filter.Tendsto (fun i => MeasureTheory.integral μ fun y => g i y) l (nhds 1)\ng_supp : Filter.Eventually (fun i => HasSubset.Subset (Function.support (g i)) (a i)) l\ng_bound : Filter.Eventually (fun i => ∀ (x : α), LE.le (abs (g i x)) (HDiv.hDiv K (μ (a i)).toReal)) l\n⊢ Filter.Tendsto (fun i => MeasureTheory.integral μ fun y => HSMul.hSMul (g i y) (f y)) l (nhds c)","decl":"/-- If the average of a function `f` along a sequence of sets `aₙ` converges to `c` (more precisely,\nwe require that `⨍ y in a i, ‖f y - c‖ ∂μ` tends to `0`), then the integral of `gₙ • f` also tends\nto `c` if `gₙ` is supported in `aₙ`, has integral converging to one and supremum at most `K / μ aₙ`.\n-/\ntheorem tendsto_integral_smul_of_tendsto_average_norm_sub\n    [CompleteSpace E]\n    {ι : Type*} {a : ι → Set α} {l : Filter ι} {f : α → E} {c : E} {g : ι → α → ℝ} (K : ℝ)\n    (hf : Tendsto (fun i ↦ ⨍ y in a i, ‖f y - c‖ ∂μ) l (𝓝 0))\n    (f_int : ∀ᶠ i in l, IntegrableOn f (a i) μ)\n    (hg : Tendsto (fun i ↦ ∫ y, g i y ∂μ) l (𝓝 1))\n    (g_supp : ∀ᶠ i in l, Function.support (g i) ⊆ a i)\n    (g_bound : ∀ᶠ i in l, ∀ x, |g i x| ≤ K / (μ (a i)).toReal) :\n    Tendsto (fun i ↦ ∫ y, g i y • f y ∂μ) l (𝓝 c) := by\n  have g_int : ∀ᶠ i in l, Integrable (g i) μ := by\n    filter_upwards [(tendsto_order.1 hg).1 _ zero_lt_one] with i hi\n    contrapose hi\n    simp only [integral_undef hi, lt_self_iff_false, not_false_eq_true]\n  have I : ∀ᶠ i in l, ∫ y, g i y • (f y - c) ∂μ + (∫ y, g i y ∂μ) • c = ∫ y, g i y • f y ∂μ := by\n    filter_upwards [f_int, g_int, g_supp, g_bound] with i hif hig hisupp hibound\n    rw [← integral_smul_const, ← integral_add]\n    · simp only [smul_sub, sub_add_cancel]\n    · simp_rw [smul_sub]\n      apply Integrable.sub _ (hig.smul_const _)\n      have A : Function.support (fun y ↦ g i y • f y) ⊆ a i := by\n        apply Subset.trans _ hisupp\n        exact Function.support_smul_subset_left _ _\n      rw [← integrableOn_iff_integrable_of_support_subset A]\n      apply Integrable.smul_of_top_right hif\n      exact memℒp_top_of_bound hig.aestronglyMeasurable.restrict\n        (K / (μ (a i)).toReal) (Eventually.of_forall hibound)\n    · exact hig.smul_const _\n  have L0 : Tendsto (fun i ↦ ∫ y, g i y • (f y - c) ∂μ) l (𝓝 0) := by\n    have := hf.const_mul K\n    simp only [mul_zero] at this\n    refine squeeze_zero_norm' ?_ this\n    filter_upwards [g_supp, g_bound, f_int, (tendsto_order.1 hg).1 _ zero_lt_one]\n      with i hi h'i h''i hi_int\n    have mu_ai : μ (a i) < ∞ := by\n      rw [lt_top_iff_ne_top]\n      intro h\n      simp only [h, ENNReal.top_toReal, _root_.div_zero, abs_nonpos_iff] at h'i\n      have : ∫ (y : α), g i y ∂μ = ∫ (y : α), 0 ∂μ := by congr; ext y; exact h'i y\n      simp [this] at hi_int\n    apply (norm_integral_le_integral_norm _).trans\n    simp_rw [average_eq, smul_eq_mul, ← integral_mul_left, norm_smul, ← mul_assoc, ← div_eq_mul_inv]\n    have : ∀ x, x ∉ a i → ‖g i x‖ * ‖(f x - c)‖ = 0 := by\n      intro x hx\n      have : g i x = 0 := by rw [← Function.nmem_support]; exact fun h ↦ hx (hi h)\n      simp [this]\n    rw [← setIntegral_eq_integral_of_forall_compl_eq_zero this (μ := μ)]\n    refine integral_mono_of_nonneg (Eventually.of_forall (fun x ↦ by positivity)) ?_\n      (Eventually.of_forall (fun x ↦ ?_))\n    · apply (Integrable.sub h''i _).norm.const_mul\n      change IntegrableOn (fun _ ↦ c) (a i) μ\n      simp [integrableOn_const, mu_ai]\n    · dsimp; gcongr; simpa using h'i x\n  have := L0.add (hg.smul_const c)\n  simp only [one_smul, zero_add] at this\n  exact Tendsto.congr' I this\n\n"}
