{"name":"CategoryTheory.Limits.hasPullback_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝² : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝¹ : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\n⊢ CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)","decl":"theorem hasPullback_assoc [HasPullback (g₂ ≫ f₃) f₄] : HasPullback f₁ (g₃ ≫ f₂) :=\n  ⟨⟨⟨_, pullbackAssocIsPullback f₁ f₂ f₃ f₄⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_assoc_symm","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝² : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝¹ : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\n⊢ CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄","decl":"theorem hasPullback_assoc_symm [HasPullback f₁ (g₃ ≫ f₂)] : HasPullback (g₂ ≫ f₃) f₄ :=\n  ⟨⟨⟨_, pullbackAssocSymmIsPullback f₁ f₂ f₃ f₄⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_inv_fst_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) (CategoryTheory.Limits.pullback.fst f₁ f₂))) (CategoryTheory.Limits.pullback.fst f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_inv_fst_fst [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).inv ≫ pullback.fst _ _ ≫ pullback.fst _ _ = pullback.fst _ _ := by\n  trans l₁' ≫ pullback.fst _ _\n  · rw [← Category.assoc]\n    congr 1\n    exact IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.left\n  · exact pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_inv_fst_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\nZ : C\nh : Quiver.Hom X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₁ f₂) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_inv_fst_fst [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).inv ≫ pullback.fst _ _ ≫ pullback.fst _ _ = pullback.fst _ _ := by\n  trans l₁' ≫ pullback.fst _ _\n  · rw [← Category.assoc]\n    congr 1\n    exact IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.left\n  · exact pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\nZ : C\nh : Quiver.Hom X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₁ f₂) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_hom_fst [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).hom ≫ pullback.fst _ _ = pullback.fst _ _ ≫ pullback.fst _ _ := by\n  rw [← Iso.eq_inv_comp, pullbackAssoc_inv_fst_fst]\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_hom_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).hom (CategoryTheory.Limits.pullback.fst f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) (CategoryTheory.Limits.pullback.fst f₁ f₂))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_hom_fst [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).hom ≫ pullback.fst _ _ = pullback.fst _ _ ≫ pullback.fst _ _ := by\n  rw [← Iso.eq_inv_comp, pullbackAssoc_inv_fst_fst]\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_hom_snd_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\nZ : C\nh : Quiver.Hom X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_hom_snd_fst [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] : (pullbackAssoc f₁ f₂ f₃ f₄).hom ≫\n    pullback.snd _ _ ≫ pullback.fst _ _ = pullback.fst _ _ ≫ pullback.snd _ _ := by\n  trans l₂ ≫ pullback.fst _ _\n  · rw [← Category.assoc]\n    congr 1\n    exact IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right\n  · exact pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_hom_snd_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) (CategoryTheory.Limits.pullback.fst f₃ f₄))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) (CategoryTheory.Limits.pullback.snd f₁ f₂))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_hom_snd_fst [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] : (pullbackAssoc f₁ f₂ f₃ f₄).hom ≫\n    pullback.snd _ _ ≫ pullback.fst _ _ = pullback.fst _ _ ≫ pullback.snd _ _ := by\n  trans l₂ ≫ pullback.fst _ _\n  · rw [← Category.assoc]\n    congr 1\n    exact IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right\n  · exact pullback.lift_fst _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_hom_snd_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\nZ : C\nh : Quiver.Hom X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₃ f₄) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_hom_snd_snd [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).hom ≫ pullback.snd _ _ ≫ pullback.snd _ _ = pullback.snd _ _ := by\n  trans l₂ ≫ pullback.snd _ _\n  · rw [← Category.assoc]\n    congr 1\n    exact IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right\n  · exact pullback.lift_snd _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_hom_snd_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) (CategoryTheory.Limits.pullback.snd f₃ f₄))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_hom_snd_snd [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).hom ≫ pullback.snd _ _ ≫ pullback.snd _ _ = pullback.snd _ _ := by\n  trans l₂ ≫ pullback.snd _ _\n  · rw [← Category.assoc]\n    congr 1\n    exact IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right\n  · exact pullback.lift_snd _ _ _\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_inv_fst_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\nZ : C\nh : Quiver.Hom X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_inv_fst_snd [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).inv ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n    pullback.snd _ _ ≫ pullback.fst _ _ := by rw [Iso.inv_comp_eq, pullbackAssoc_hom_snd_fst]\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_inv_fst_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) (CategoryTheory.Limits.pullback.snd f₁ f₂))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) (CategoryTheory.Limits.pullback.fst f₃ f₄))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_inv_fst_snd [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).inv ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n    pullback.snd _ _ ≫ pullback.fst _ _ := by rw [Iso.inv_comp_eq, pullbackAssoc_hom_snd_fst]\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_inv_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).inv (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) (CategoryTheory.Limits.pullback.snd f₃ f₄))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_inv_snd [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).inv ≫ pullback.snd _ _ = pullback.snd _ _ ≫ pullback.snd _ _ := by\n  rw [Iso.inv_comp_eq, pullbackAssoc_hom_snd_snd]\n\n"}
{"name":"CategoryTheory.Limits.pullbackAssoc_inv_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Y₁ Y₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₁\nf₃ : Quiver.Hom X₂ Y₂\nf₄ : Quiver.Hom X₃ Y₂\ninst✝³ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝² : CategoryTheory.Limits.HasPullback f₃ f₄\ninst✝¹ : CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄\ninst✝ : CategoryTheory.Limits.HasPullback f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)\nZ : C\nh : Quiver.Hom X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackAssoc f₁ f₂ f₃ f₄).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ f₂) f₃) f₄) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₁ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f₃ f₄) f₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f₃ f₄) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackAssoc_inv_snd [HasPullback ((pullback.snd _ _ : Z₁ ⟶ X₂) ≫ f₃) f₄]\n    [HasPullback f₁ ((pullback.fst _ _ : Z₂ ⟶ X₂) ≫ f₂)] :\n    (pullbackAssoc f₁ f₂ f₃ f₄).inv ≫ pullback.snd _ _ = pullback.snd _ _ ≫ pullback.snd _ _ := by\n  rw [Iso.inv_comp_eq, pullbackAssoc_hom_snd_snd]\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝² : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝¹ : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\n⊢ CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))","decl":"theorem hasPushout_assoc [HasPushout (g₃ ≫ f₂) g₄] : HasPushout g₁ (g₂ ≫ f₃) :=\n  ⟨⟨⟨_, pushoutAssocIsPushout g₁ g₂ g₃ g₄⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_assoc_symm","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝² : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝¹ : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\n⊢ CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄","decl":"theorem hasPushout_assoc_symm [HasPushout g₁ (g₂ ≫ f₃)] : HasPushout (g₃ ≫ f₂) g₄ :=\n  ⟨⟨⟨_, pushoutAssocSymmIsPushout g₁ g₂ g₃ g₄⟩⟩⟩\n\n-- Porting note: these are not propagating so moved into statements\n-- variable [HasPushout (g₃ ≫ f₂) g₄] [HasPushout g₁ (g₂ ≫ f₃)]\n\n"}
{"name":"CategoryTheory.Limits.inl_inl_pushoutAssoc_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₁ g₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_inl_pushoutAssoc_hom [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inl _ _ ≫ pushout.inl _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).hom = pushout.inl _ _ := by\n  trans f₁ ≫ l₁\n  · congr 1\n    exact\n      (pushoutPushoutLeftIsPushout g₁ g₂ g₃ g₄).comp_coconePointUniqueUpToIso_hom _\n        WalkingCospan.left\n  · exact pushout.inl_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inl_inl_pushoutAssoc_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₁ g₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).hom)) (CategoryTheory.Limits.pushout.inl g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄)))","decl":"@[reassoc (attr := simp)]\ntheorem inl_inl_pushoutAssoc_hom [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inl _ _ ≫ pushout.inl _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).hom = pushout.inl _ _ := by\n  trans f₁ ≫ l₁\n  · congr 1\n    exact\n      (pushoutPushoutLeftIsPushout g₁ g₂ g₃ g₄).comp_coconePointUniqueUpToIso_hom _\n        WalkingCospan.left\n  · exact pushout.inl_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inr_inl_pushoutAssoc_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ g₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₃ g₄) (CategoryTheory.Limits.pushout.inr g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))))","decl":"@[reassoc (attr := simp)]\ntheorem inr_inl_pushoutAssoc_hom [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inr _ _ ≫ pushout.inl _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).hom =\n      pushout.inl _ _ ≫ pushout.inr _ _ := by\n  trans f₂ ≫ l₁\n  · congr 1\n    exact\n      (pushoutPushoutLeftIsPushout g₁ g₂ g₃ g₄).comp_coconePointUniqueUpToIso_hom _\n        WalkingCospan.left\n  · exact pushout.inr_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inr_inl_pushoutAssoc_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ g₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₃ g₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) h))","decl":"@[reassoc (attr := simp)]\ntheorem inr_inl_pushoutAssoc_hom [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inr _ _ ≫ pushout.inl _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).hom =\n      pushout.inl _ _ ≫ pushout.inr _ _ := by\n  trans f₂ ≫ l₁\n  · congr 1\n    exact\n      (pushoutPushoutLeftIsPushout g₁ g₂ g₃ g₄).comp_coconePointUniqueUpToIso_hom _\n        WalkingCospan.left\n  · exact pushout.inr_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inr_inr_pushoutAssoc_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₃ g₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_inr_pushoutAssoc_inv [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inr _ _ ≫ pushout.inr _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).inv = pushout.inr _ _ := by\n  trans f₄ ≫ l₂'\n  · congr 1\n    exact\n      (pushoutPushoutLeftIsPushout g₁ g₂ g₃ g₄).comp_coconePointUniqueUpToIso_inv\n        (pushoutPushoutRightIsPushout g₁ g₂ g₃ g₄) WalkingCospan.right\n  · exact pushout.inr_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inr_inr_pushoutAssoc_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₃ g₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).inv)) (CategoryTheory.Limits.pushout.inr (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄)","decl":"@[reassoc (attr := simp)]\ntheorem inr_inr_pushoutAssoc_inv [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inr _ _ ≫ pushout.inr _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).inv = pushout.inr _ _ := by\n  trans f₄ ≫ l₂'\n  · congr 1\n    exact\n      (pushoutPushoutLeftIsPushout g₁ g₂ g₃ g₄).comp_coconePointUniqueUpToIso_inv\n        (pushoutPushoutRightIsPushout g₁ g₂ g₃ g₄) WalkingCospan.right\n  · exact pushout.inr_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.inl_pushoutAssoc_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₁ g₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) h))","decl":"@[reassoc (attr := simp)]\ntheorem inl_pushoutAssoc_inv [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inl _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).inv = pushout.inl _ _ ≫ pushout.inl _ _ := by\n  rw [Iso.comp_inv_eq, Category.assoc, inl_inl_pushoutAssoc_hom]\n\n"}
{"name":"CategoryTheory.Limits.inl_pushoutAssoc_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₁ g₂) (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄))","decl":"@[reassoc (attr := simp)]\ntheorem inl_pushoutAssoc_inv [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inl _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).inv = pushout.inl _ _ ≫ pushout.inl _ _ := by\n  rw [Iso.comp_inv_eq, Category.assoc, inl_inl_pushoutAssoc_hom]\n\n"}
{"name":"CategoryTheory.Limits.inl_inr_pushoutAssoc_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₃ g₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ g₂) (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄))","decl":"@[reassoc (attr := simp)]\ntheorem inl_inr_pushoutAssoc_inv [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inl _ _ ≫ pushout.inr _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).inv =\n      pushout.inr _ _ ≫ pushout.inl _ _ := by\n  rw [← Category.assoc, Iso.comp_inv_eq, Category.assoc, inr_inl_pushoutAssoc_hom]\n\n"}
{"name":"CategoryTheory.Limits.inl_inr_pushoutAssoc_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl g₃ g₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ g₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) h))","decl":"@[reassoc (attr := simp)]\ntheorem inl_inr_pushoutAssoc_inv [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inl _ _ ≫ pushout.inr _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).inv =\n      pushout.inr _ _ ≫ pushout.inl _ _ := by\n  rw [← Category.assoc, Iso.comp_inv_eq, Category.assoc, inr_inl_pushoutAssoc_hom]\n\n"}
{"name":"CategoryTheory.Limits.inr_pushoutAssoc_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₃ g₄) (CategoryTheory.Limits.pushout.inr g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))))","decl":"@[reassoc (attr := simp)]\ntheorem inr_pushoutAssoc_hom [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inr _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).hom = pushout.inr _ _ ≫ pushout.inr _ _ := by\n  rw [← Iso.eq_comp_inv, Category.assoc, inr_inr_pushoutAssoc_inv]\n\n"}
{"name":"CategoryTheory.Limits.inr_pushoutAssoc_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Assoc","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nX₁ X₂ X₃ Z₁ Z₂ : C\ng₁ : Quiver.Hom Z₁ X₁\ng₂ : Quiver.Hom Z₁ X₂\ng₃ : Quiver.Hom Z₂ X₂\ng₄ : Quiver.Hom Z₂ X₃\ninst✝³ : CategoryTheory.Limits.HasPushout g₁ g₂\ninst✝² : CategoryTheory.Limits.HasPushout g₃ g₄\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄\ninst✝ : CategoryTheory.Limits.HasPushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.CategoryStruct.comp g₃ (CategoryTheory.Limits.pushout.inr g₁ g₂)) g₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutAssoc g₁ g₂ g₃ g₄).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₃ g₄) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr g₁ (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.pushout.inl g₃ g₄))) h))","decl":"@[reassoc (attr := simp)]\ntheorem inr_pushoutAssoc_hom [HasPushout (g₃ ≫ (pushout.inr _ _ : X₂ ⟶ Y₁)) g₄]\n    [HasPushout g₁ (g₂ ≫ (pushout.inl _ _ : X₂ ⟶ Y₂))] :\n    pushout.inr _ _ ≫ (pushoutAssoc g₁ g₂ g₃ g₄).hom = pushout.inr _ _ ≫ pushout.inr _ _ := by\n  rw [← Iso.eq_comp_inv, Category.assoc, inr_inr_pushoutAssoc_inv]\n\n"}
