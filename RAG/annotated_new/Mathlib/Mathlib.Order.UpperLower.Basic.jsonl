{"name":"isUpperSet_empty","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ IsUpperSet EmptyCollection.emptyCollection","decl":"theorem isUpperSet_empty : IsUpperSet (∅ : Set α) := fun _ _ _ => id\n\n"}
{"name":"isLowerSet_empty","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ IsLowerSet EmptyCollection.emptyCollection","decl":"theorem isLowerSet_empty : IsLowerSet (∅ : Set α) := fun _ _ _ => id\n\n"}
{"name":"isUpperSet_univ","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ IsUpperSet Set.univ","decl":"theorem isUpperSet_univ : IsUpperSet (univ : Set α) := fun _ _ _ => id\n\n"}
{"name":"isLowerSet_univ","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ IsLowerSet Set.univ","decl":"theorem isLowerSet_univ : IsLowerSet (univ : Set α) := fun _ _ _ => id\n\n"}
{"name":"IsUpperSet.compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\nhs : IsUpperSet s\n⊢ IsLowerSet (HasCompl.compl s)","decl":"theorem IsUpperSet.compl (hs : IsUpperSet s) : IsLowerSet sᶜ := fun _a _b h hb ha => hb <| hs h ha\n\n"}
{"name":"IsLowerSet.compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\nhs : IsLowerSet s\n⊢ IsUpperSet (HasCompl.compl s)","decl":"theorem IsLowerSet.compl (hs : IsLowerSet s) : IsUpperSet sᶜ := fun _a _b h hb ha => hb <| hs h ha\n\n"}
{"name":"isUpperSet_compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\n⊢ Iff (IsUpperSet (HasCompl.compl s)) (IsLowerSet s)","decl":"@[simp]\ntheorem isUpperSet_compl : IsUpperSet sᶜ ↔ IsLowerSet s :=\n  ⟨fun h => by\n    convert h.compl\n    rw [compl_compl], IsLowerSet.compl⟩\n\n"}
{"name":"isLowerSet_compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\n⊢ Iff (IsLowerSet (HasCompl.compl s)) (IsUpperSet s)","decl":"@[simp]\ntheorem isLowerSet_compl : IsLowerSet sᶜ ↔ IsUpperSet s :=\n  ⟨fun h => by\n    convert h.compl\n    rw [compl_compl], IsUpperSet.compl⟩\n\n"}
{"name":"IsUpperSet.union","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsUpperSet s\nht : IsUpperSet t\n⊢ IsUpperSet (Union.union s t)","decl":"theorem IsUpperSet.union (hs : IsUpperSet s) (ht : IsUpperSet t) : IsUpperSet (s ∪ t) :=\n  fun _ _ h => Or.imp (hs h) (ht h)\n\n"}
{"name":"IsLowerSet.union","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsLowerSet s\nht : IsLowerSet t\n⊢ IsLowerSet (Union.union s t)","decl":"theorem IsLowerSet.union (hs : IsLowerSet s) (ht : IsLowerSet t) : IsLowerSet (s ∪ t) :=\n  fun _ _ h => Or.imp (hs h) (ht h)\n\n"}
{"name":"IsUpperSet.inter","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsUpperSet s\nht : IsUpperSet t\n⊢ IsUpperSet (Inter.inter s t)","decl":"theorem IsUpperSet.inter (hs : IsUpperSet s) (ht : IsUpperSet t) : IsUpperSet (s ∩ t) :=\n  fun _ _ h => And.imp (hs h) (ht h)\n\n"}
{"name":"IsLowerSet.inter","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsLowerSet s\nht : IsLowerSet t\n⊢ IsLowerSet (Inter.inter s t)","decl":"theorem IsLowerSet.inter (hs : IsLowerSet s) (ht : IsLowerSet t) : IsLowerSet (s ∩ t) :=\n  fun _ _ h => And.imp (hs h) (ht h)\n\n"}
{"name":"isUpperSet_sUnion","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (Set α)\nhf : ∀ (s : Set α), Membership.mem S s → IsUpperSet s\n⊢ IsUpperSet S.sUnion","decl":"theorem isUpperSet_sUnion {S : Set (Set α)} (hf : ∀ s ∈ S, IsUpperSet s) : IsUpperSet (⋃₀ S) :=\n  fun _ _ h => Exists.imp fun _ hs => ⟨hs.1, hf _ hs.1 h hs.2⟩\n\n"}
{"name":"isLowerSet_sUnion","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (Set α)\nhf : ∀ (s : Set α), Membership.mem S s → IsLowerSet s\n⊢ IsLowerSet S.sUnion","decl":"theorem isLowerSet_sUnion {S : Set (Set α)} (hf : ∀ s ∈ S, IsLowerSet s) : IsLowerSet (⋃₀ S) :=\n  fun _ _ h => Exists.imp fun _ hs => ⟨hs.1, hf _ hs.1 h hs.2⟩\n\n"}
{"name":"isUpperSet_iUnion","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → Set α\nhf : ∀ (i : ι), IsUpperSet (f i)\n⊢ IsUpperSet (Set.iUnion fun i => f i)","decl":"theorem isUpperSet_iUnion {f : ι → Set α} (hf : ∀ i, IsUpperSet (f i)) : IsUpperSet (⋃ i, f i) :=\n  isUpperSet_sUnion <| forall_mem_range.2 hf\n\n"}
{"name":"isLowerSet_iUnion","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → Set α\nhf : ∀ (i : ι), IsLowerSet (f i)\n⊢ IsLowerSet (Set.iUnion fun i => f i)","decl":"theorem isLowerSet_iUnion {f : ι → Set α} (hf : ∀ i, IsLowerSet (f i)) : IsLowerSet (⋃ i, f i) :=\n  isLowerSet_sUnion <| forall_mem_range.2 hf\n\n"}
{"name":"isUpperSet_iUnion₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → Set α\nhf : ∀ (i : ι) (j : κ i), IsUpperSet (f i j)\n⊢ IsUpperSet (Set.iUnion fun i => Set.iUnion fun j => f i j)","decl":"theorem isUpperSet_iUnion₂ {f : ∀ i, κ i → Set α} (hf : ∀ i j, IsUpperSet (f i j)) :\n    IsUpperSet (⋃ (i) (j), f i j) :=\n  isUpperSet_iUnion fun i => isUpperSet_iUnion <| hf i\n\n"}
{"name":"isLowerSet_iUnion₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → Set α\nhf : ∀ (i : ι) (j : κ i), IsLowerSet (f i j)\n⊢ IsLowerSet (Set.iUnion fun i => Set.iUnion fun j => f i j)","decl":"theorem isLowerSet_iUnion₂ {f : ∀ i, κ i → Set α} (hf : ∀ i j, IsLowerSet (f i j)) :\n    IsLowerSet (⋃ (i) (j), f i j) :=\n  isLowerSet_iUnion fun i => isLowerSet_iUnion <| hf i\n\n"}
{"name":"isUpperSet_sInter","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (Set α)\nhf : ∀ (s : Set α), Membership.mem S s → IsUpperSet s\n⊢ IsUpperSet S.sInter","decl":"theorem isUpperSet_sInter {S : Set (Set α)} (hf : ∀ s ∈ S, IsUpperSet s) : IsUpperSet (⋂₀ S) :=\n  fun _ _ h => forall₂_imp fun s hs => hf s hs h\n\n"}
{"name":"isLowerSet_sInter","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (Set α)\nhf : ∀ (s : Set α), Membership.mem S s → IsLowerSet s\n⊢ IsLowerSet S.sInter","decl":"theorem isLowerSet_sInter {S : Set (Set α)} (hf : ∀ s ∈ S, IsLowerSet s) : IsLowerSet (⋂₀ S) :=\n  fun _ _ h => forall₂_imp fun s hs => hf s hs h\n\n"}
{"name":"isUpperSet_iInter","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → Set α\nhf : ∀ (i : ι), IsUpperSet (f i)\n⊢ IsUpperSet (Set.iInter fun i => f i)","decl":"theorem isUpperSet_iInter {f : ι → Set α} (hf : ∀ i, IsUpperSet (f i)) : IsUpperSet (⋂ i, f i) :=\n  isUpperSet_sInter <| forall_mem_range.2 hf\n\n"}
{"name":"isLowerSet_iInter","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → Set α\nhf : ∀ (i : ι), IsLowerSet (f i)\n⊢ IsLowerSet (Set.iInter fun i => f i)","decl":"theorem isLowerSet_iInter {f : ι → Set α} (hf : ∀ i, IsLowerSet (f i)) : IsLowerSet (⋂ i, f i) :=\n  isLowerSet_sInter <| forall_mem_range.2 hf\n\n"}
{"name":"isUpperSet_iInter₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → Set α\nhf : ∀ (i : ι) (j : κ i), IsUpperSet (f i j)\n⊢ IsUpperSet (Set.iInter fun i => Set.iInter fun j => f i j)","decl":"theorem isUpperSet_iInter₂ {f : ∀ i, κ i → Set α} (hf : ∀ i j, IsUpperSet (f i j)) :\n    IsUpperSet (⋂ (i) (j), f i j) :=\n  isUpperSet_iInter fun i => isUpperSet_iInter <| hf i\n\n"}
{"name":"isLowerSet_iInter₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → Set α\nhf : ∀ (i : ι) (j : κ i), IsLowerSet (f i j)\n⊢ IsLowerSet (Set.iInter fun i => Set.iInter fun j => f i j)","decl":"theorem isLowerSet_iInter₂ {f : ∀ i, κ i → Set α} (hf : ∀ i j, IsLowerSet (f i j)) :\n    IsLowerSet (⋂ (i) (j), f i j) :=\n  isLowerSet_iInter fun i => isLowerSet_iInter <| hf i\n\n"}
{"name":"isLowerSet_preimage_ofDual_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\n⊢ Iff (IsLowerSet (Set.preimage (⇑OrderDual.ofDual) s)) (IsUpperSet s)","decl":"@[simp]\ntheorem isLowerSet_preimage_ofDual_iff : IsLowerSet (ofDual ⁻¹' s) ↔ IsUpperSet s :=\n  Iff.rfl\n\n"}
{"name":"isUpperSet_preimage_ofDual_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\n⊢ Iff (IsUpperSet (Set.preimage (⇑OrderDual.ofDual) s)) (IsLowerSet s)","decl":"@[simp]\ntheorem isUpperSet_preimage_ofDual_iff : IsUpperSet (ofDual ⁻¹' s) ↔ IsLowerSet s :=\n  Iff.rfl\n\n"}
{"name":"isLowerSet_preimage_toDual_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set (OrderDual α)\n⊢ Iff (IsLowerSet (Set.preimage (⇑OrderDual.toDual) s)) (IsUpperSet s)","decl":"@[simp]\ntheorem isLowerSet_preimage_toDual_iff {s : Set αᵒᵈ} : IsLowerSet (toDual ⁻¹' s) ↔ IsUpperSet s :=\n  Iff.rfl\n\n"}
{"name":"isUpperSet_preimage_toDual_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set (OrderDual α)\n⊢ Iff (IsUpperSet (Set.preimage (⇑OrderDual.toDual) s)) (IsLowerSet s)","decl":"@[simp]\ntheorem isUpperSet_preimage_toDual_iff {s : Set αᵒᵈ} : IsUpperSet (toDual ⁻¹' s) ↔ IsLowerSet s :=\n  Iff.rfl\n\n"}
{"name":"IsUpperSet.toDual","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\na✝ : IsUpperSet s\n⊢ IsLowerSet (Set.preimage (⇑OrderDual.ofDual) s)","decl":"alias ⟨_, IsUpperSet.toDual⟩ := isLowerSet_preimage_ofDual_iff\n\n"}
{"name":"IsLowerSet.toDual","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\na✝ : IsLowerSet s\n⊢ IsUpperSet (Set.preimage (⇑OrderDual.ofDual) s)","decl":"alias ⟨_, IsLowerSet.toDual⟩ := isUpperSet_preimage_ofDual_iff\n\n"}
{"name":"IsUpperSet.ofDual","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set (OrderDual α)\na✝ : IsUpperSet s\n⊢ IsLowerSet (Set.preimage (⇑OrderDual.toDual) s)","decl":"alias ⟨_, IsUpperSet.ofDual⟩ := isLowerSet_preimage_toDual_iff\n\n"}
{"name":"IsLowerSet.ofDual","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set (OrderDual α)\na✝ : IsLowerSet s\n⊢ IsUpperSet (Set.preimage (⇑OrderDual.toDual) s)","decl":"alias ⟨_, IsLowerSet.ofDual⟩ := isUpperSet_preimage_toDual_iff\n\n"}
{"name":"IsUpperSet.isLowerSet_preimage_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsUpperSet s\n⊢ Iff (IsLowerSet (Set.preimage Subtype.val t)) (∀ (b : α), Membership.mem s b → ∀ (c : α), Membership.mem t c → LE.le b c → Membership.mem t b)","decl":"lemma IsUpperSet.isLowerSet_preimage_coe (hs : IsUpperSet s) :\n    IsLowerSet ((↑) ⁻¹' t : Set s) ↔ ∀ b ∈ s, ∀ c ∈ t, b ≤ c → b ∈ t := by aesop\n\n"}
{"name":"IsLowerSet.isUpperSet_preimage_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsLowerSet s\n⊢ Iff (IsUpperSet (Set.preimage Subtype.val t)) (∀ (b : α), Membership.mem s b → ∀ (c : α), Membership.mem t c → LE.le c b → Membership.mem t b)","decl":"lemma IsLowerSet.isUpperSet_preimage_coe (hs : IsLowerSet s) :\n    IsUpperSet ((↑) ⁻¹' t : Set s) ↔ ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t := by aesop\n\n"}
{"name":"IsUpperSet.sdiff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsUpperSet s\nht : ∀ (b : α), Membership.mem s b → ∀ (c : α), Membership.mem t c → LE.le b c → Membership.mem t b\n⊢ IsUpperSet (SDiff.sdiff s t)","decl":"lemma IsUpperSet.sdiff (hs : IsUpperSet s) (ht : ∀ b ∈ s, ∀ c ∈ t, b ≤ c → b ∈ t) :\n    IsUpperSet (s \\ t) :=\n  fun _b _c hbc hb ↦ ⟨hs hbc hb.1, fun hc ↦ hb.2 <| ht _ hb.1 _ hc hbc⟩\n\n"}
{"name":"IsLowerSet.sdiff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsLowerSet s\nht : ∀ (b : α), Membership.mem s b → ∀ (c : α), Membership.mem t c → LE.le c b → Membership.mem t b\n⊢ IsLowerSet (SDiff.sdiff s t)","decl":"lemma IsLowerSet.sdiff (hs : IsLowerSet s) (ht : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :\n    IsLowerSet (s \\ t) :=\n  fun _b _c hcb hb ↦ ⟨hs hcb hb.1, fun hc ↦ hb.2 <| ht _ hb.1 _ hc hcb⟩\n\n"}
{"name":"IsUpperSet.sdiff_of_isLowerSet","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsUpperSet s\nht : IsLowerSet t\n⊢ IsUpperSet (SDiff.sdiff s t)","decl":"lemma IsUpperSet.sdiff_of_isLowerSet (hs : IsUpperSet s) (ht : IsLowerSet t) : IsUpperSet (s \\ t) :=\n  hs.sdiff <| by aesop\n\n"}
{"name":"IsLowerSet.sdiff_of_isUpperSet","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nhs : IsLowerSet s\nht : IsUpperSet t\n⊢ IsLowerSet (SDiff.sdiff s t)","decl":"lemma IsLowerSet.sdiff_of_isUpperSet (hs : IsLowerSet s) (ht : IsUpperSet t) : IsLowerSet (s \\ t) :=\n  hs.sdiff <| by aesop\n\n"}
{"name":"IsUpperSet.erase","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\na : α\nhs : IsUpperSet s\nhas : ∀ (b : α), Membership.mem s b → LE.le b a → Eq b a\n⊢ IsUpperSet (SDiff.sdiff s (Singleton.singleton a))","decl":"lemma IsUpperSet.erase (hs : IsUpperSet s) (has : ∀ b ∈ s, b ≤ a → b = a) : IsUpperSet (s \\ {a}) :=\n  hs.sdiff <| by simpa using has\n\n"}
{"name":"IsLowerSet.erase","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\na : α\nhs : IsLowerSet s\nhas : ∀ (b : α), Membership.mem s b → LE.le a b → Eq b a\n⊢ IsLowerSet (SDiff.sdiff s (Singleton.singleton a))","decl":"lemma IsLowerSet.erase (hs : IsLowerSet s) (has : ∀ b ∈ s, a ≤ b → b = a) : IsLowerSet (s \\ {a}) :=\n  hs.sdiff <| by simpa using has\n\n"}
{"name":"isUpperSet_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ IsUpperSet (Set.Ici a)","decl":"theorem isUpperSet_Ici : IsUpperSet (Ici a) := fun _ _ => ge_trans\n\n"}
{"name":"isLowerSet_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ IsLowerSet (Set.Iic a)","decl":"theorem isLowerSet_Iic : IsLowerSet (Iic a) := fun _ _ => le_trans\n\n"}
{"name":"isUpperSet_Ioi","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ IsUpperSet (Set.Ioi a)","decl":"theorem isUpperSet_Ioi : IsUpperSet (Ioi a) := fun _ _ => flip lt_of_lt_of_le\n\n"}
{"name":"isLowerSet_Iio","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ IsLowerSet (Set.Iio a)","decl":"theorem isLowerSet_Iio : IsLowerSet (Iio a) := fun _ _ => lt_of_le_of_lt\n\n"}
{"name":"isUpperSet_iff_Ici_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (IsUpperSet s) (∀ ⦃a : α⦄, Membership.mem s a → HasSubset.Subset (Set.Ici a) s)","decl":"theorem isUpperSet_iff_Ici_subset : IsUpperSet s ↔ ∀ ⦃a⦄, a ∈ s → Ici a ⊆ s := by\n  simp [IsUpperSet, subset_def, @forall_swap (_ ∈ s)]\n\n"}
{"name":"isLowerSet_iff_Iic_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (IsLowerSet s) (∀ ⦃a : α⦄, Membership.mem s a → HasSubset.Subset (Set.Iic a) s)","decl":"theorem isLowerSet_iff_Iic_subset : IsLowerSet s ↔ ∀ ⦃a⦄, a ∈ s → Iic a ⊆ s := by\n  simp [IsLowerSet, subset_def, @forall_swap (_ ∈ s)]\n\n"}
{"name":"IsUpperSet.Ici_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝¹ : IsUpperSet s\na : α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (Set.Ici a) s","decl":"alias ⟨IsUpperSet.Ici_subset, _⟩ := isUpperSet_iff_Ici_subset\n\n"}
{"name":"IsLowerSet.Iic_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝¹ : IsLowerSet s\na : α\na✝ : Membership.mem s a\n⊢ HasSubset.Subset (Set.Iic a) s","decl":"alias ⟨IsLowerSet.Iic_subset, _⟩ := isLowerSet_iff_Iic_subset\n\n"}
{"name":"IsUpperSet.Ioi_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nh : IsUpperSet s\na : α\nha : Membership.mem s a\n⊢ HasSubset.Subset (Set.Ioi a) s","decl":"theorem IsUpperSet.Ioi_subset (h : IsUpperSet s) ⦃a⦄ (ha : a ∈ s) : Ioi a ⊆ s :=\n  Ioi_subset_Ici_self.trans <| h.Ici_subset ha\n\n"}
{"name":"IsLowerSet.Iio_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nh : IsLowerSet s\na : α\nha : Membership.mem s a\n⊢ HasSubset.Subset (Set.Iio a) s","decl":"theorem IsLowerSet.Iio_subset (h : IsLowerSet s) ⦃a⦄ (ha : a ∈ s) : Iio a ⊆ s :=\n  h.toDual.Ioi_subset ha\n\n"}
{"name":"IsUpperSet.ordConnected","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nh : IsUpperSet s\n⊢ s.OrdConnected","decl":"theorem IsUpperSet.ordConnected (h : IsUpperSet s) : s.OrdConnected :=\n  ⟨fun _ ha _ _ => Icc_subset_Ici_self.trans <| h.Ici_subset ha⟩\n\n"}
{"name":"IsLowerSet.ordConnected","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nh : IsLowerSet s\n⊢ s.OrdConnected","decl":"theorem IsLowerSet.ordConnected (h : IsLowerSet s) : s.OrdConnected :=\n  ⟨fun _ _ _ hb => Icc_subset_Iic_self.trans <| h.Iic_subset hb⟩\n\n"}
{"name":"IsUpperSet.preimage","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nhs : IsUpperSet s\nf : β → α\nhf : Monotone f\n⊢ IsUpperSet (Set.preimage f s)","decl":"theorem IsUpperSet.preimage (hs : IsUpperSet s) {f : β → α} (hf : Monotone f) :\n    IsUpperSet (f ⁻¹' s : Set β) := fun _ _ h => hs <| hf h\n\n"}
{"name":"IsLowerSet.preimage","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nhs : IsLowerSet s\nf : β → α\nhf : Monotone f\n⊢ IsLowerSet (Set.preimage f s)","decl":"theorem IsLowerSet.preimage (hs : IsLowerSet s) {f : β → α} (hf : Monotone f) :\n    IsLowerSet (f ⁻¹' s : Set β) := fun _ _ h => hs <| hf h\n\n"}
{"name":"IsUpperSet.image","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nhs : IsUpperSet s\nf : OrderIso α β\n⊢ IsUpperSet (Set.image (⇑f) s)","decl":"theorem IsUpperSet.image (hs : IsUpperSet s) (f : α ≃o β) : IsUpperSet (f '' s : Set β) := by\n  change IsUpperSet ((f : α ≃ β) '' s)\n  rw [Set.image_equiv_eq_preimage_symm]\n  exact hs.preimage f.symm.monotone\n\n"}
{"name":"IsLowerSet.image","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nhs : IsLowerSet s\nf : OrderIso α β\n⊢ IsLowerSet (Set.image (⇑f) s)","decl":"theorem IsLowerSet.image (hs : IsLowerSet s) (f : α ≃o β) : IsLowerSet (f '' s : Set β) := by\n  change IsLowerSet ((f : α ≃ β) '' s)\n  rw [Set.image_equiv_eq_preimage_symm]\n  exact hs.preimage f.symm.monotone\n\n"}
{"name":"OrderEmbedding.image_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderEmbedding α β\nhe : IsUpperSet (Set.range ⇑e)\na : α\n⊢ Eq (Set.image (⇑e) (Set.Ici a)) (Set.Ici (e a))","decl":"theorem OrderEmbedding.image_Ici (e : α ↪o β) (he : IsUpperSet (range e)) (a : α) :\n    e '' Ici a = Ici (e a) := by\n  rw [← e.preimage_Ici, image_preimage_eq_inter_range,\n    inter_eq_left.2 <| he.Ici_subset (mem_range_self _)]\n\n"}
{"name":"OrderEmbedding.image_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderEmbedding α β\nhe : IsLowerSet (Set.range ⇑e)\na : α\n⊢ Eq (Set.image (⇑e) (Set.Iic a)) (Set.Iic (e a))","decl":"theorem OrderEmbedding.image_Iic (e : α ↪o β) (he : IsLowerSet (range e)) (a : α) :\n    e '' Iic a = Iic (e a) :=\n  e.dual.image_Ici he a\n\n"}
{"name":"OrderEmbedding.image_Ioi","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderEmbedding α β\nhe : IsUpperSet (Set.range ⇑e)\na : α\n⊢ Eq (Set.image (⇑e) (Set.Ioi a)) (Set.Ioi (e a))","decl":"theorem OrderEmbedding.image_Ioi (e : α ↪o β) (he : IsUpperSet (range e)) (a : α) :\n    e '' Ioi a = Ioi (e a) := by\n  rw [← e.preimage_Ioi, image_preimage_eq_inter_range,\n    inter_eq_left.2 <| he.Ioi_subset (mem_range_self _)]\n\n"}
{"name":"OrderEmbedding.image_Iio","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderEmbedding α β\nhe : IsLowerSet (Set.range ⇑e)\na : α\n⊢ Eq (Set.image (⇑e) (Set.Iio a)) (Set.Iio (e a))","decl":"theorem OrderEmbedding.image_Iio (e : α ↪o β) (he : IsLowerSet (range e)) (a : α) :\n    e '' Iio a = Iio (e a) :=\n  e.dual.image_Ioi he a\n\n"}
{"name":"Set.monotone_mem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Monotone fun x => Membership.mem s x) (IsUpperSet s)","decl":"@[simp]\ntheorem Set.monotone_mem : Monotone (· ∈ s) ↔ IsUpperSet s :=\n  Iff.rfl\n\n"}
{"name":"Set.antitone_mem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Antitone fun x => Membership.mem s x) (IsLowerSet s)","decl":"@[simp]\ntheorem Set.antitone_mem : Antitone (· ∈ s) ↔ IsLowerSet s :=\n  forall_swap\n\n"}
{"name":"isUpperSet_setOf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : α → Prop\n⊢ Iff (IsUpperSet (setOf fun a => p a)) (Monotone p)","decl":"@[simp]\ntheorem isUpperSet_setOf : IsUpperSet { a | p a } ↔ Monotone p :=\n  Iff.rfl\n\n"}
{"name":"isLowerSet_setOf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : α → Prop\n⊢ Iff (IsLowerSet (setOf fun a => p a)) (Antitone p)","decl":"@[simp]\ntheorem isLowerSet_setOf : IsLowerSet { a | p a } ↔ Antitone p :=\n  forall_swap\n\n"}
{"name":"IsUpperSet.upperBounds_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : IsUpperSet s\na✝ : s.Nonempty\n⊢ HasSubset.Subset (upperBounds s) s","decl":"lemma IsUpperSet.upperBounds_subset (hs : IsUpperSet s) : s.Nonempty → upperBounds s ⊆ s :=\n  fun ⟨_a, ha⟩ _b hb ↦ hs (hb ha) ha\n\n"}
{"name":"IsLowerSet.lowerBounds_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : IsLowerSet s\na✝ : s.Nonempty\n⊢ HasSubset.Subset (lowerBounds s) s","decl":"lemma IsLowerSet.lowerBounds_subset (hs : IsLowerSet s) : s.Nonempty → lowerBounds s ⊆ s :=\n  fun ⟨_a, ha⟩ _b hb ↦ hs (hb ha) ha\n\n"}
{"name":"IsLowerSet.top_mem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : OrderTop α\nhs : IsLowerSet s\n⊢ Iff (Membership.mem s Top.top) (Eq s Set.univ)","decl":"theorem IsLowerSet.top_mem (hs : IsLowerSet s) : ⊤ ∈ s ↔ s = univ :=\n  ⟨fun h => eq_univ_of_forall fun _ => hs le_top h, fun h => h.symm ▸ mem_univ _⟩\n\n"}
{"name":"IsUpperSet.top_mem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : OrderTop α\nhs : IsUpperSet s\n⊢ Iff (Membership.mem s Top.top) s.Nonempty","decl":"theorem IsUpperSet.top_mem (hs : IsUpperSet s) : ⊤ ∈ s ↔ s.Nonempty :=\n  ⟨fun h => ⟨_, h⟩, fun ⟨_a, ha⟩ => hs le_top ha⟩\n\n"}
{"name":"IsUpperSet.not_top_mem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : OrderTop α\nhs : IsUpperSet s\n⊢ Iff (Not (Membership.mem s Top.top)) (Eq s EmptyCollection.emptyCollection)","decl":"theorem IsUpperSet.not_top_mem (hs : IsUpperSet s) : ⊤ ∉ s ↔ s = ∅ :=\n  hs.top_mem.not.trans not_nonempty_iff_eq_empty\n\n"}
{"name":"IsUpperSet.bot_mem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : OrderBot α\nhs : IsUpperSet s\n⊢ Iff (Membership.mem s Bot.bot) (Eq s Set.univ)","decl":"theorem IsUpperSet.bot_mem (hs : IsUpperSet s) : ⊥ ∈ s ↔ s = univ :=\n  ⟨fun h => eq_univ_of_forall fun _ => hs bot_le h, fun h => h.symm ▸ mem_univ _⟩\n\n"}
{"name":"IsLowerSet.bot_mem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : OrderBot α\nhs : IsLowerSet s\n⊢ Iff (Membership.mem s Bot.bot) s.Nonempty","decl":"theorem IsLowerSet.bot_mem (hs : IsLowerSet s) : ⊥ ∈ s ↔ s.Nonempty :=\n  ⟨fun h => ⟨_, h⟩, fun ⟨_a, ha⟩ => hs bot_le ha⟩\n\n"}
{"name":"IsLowerSet.not_bot_mem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : OrderBot α\nhs : IsLowerSet s\n⊢ Iff (Not (Membership.mem s Bot.bot)) (Eq s EmptyCollection.emptyCollection)","decl":"theorem IsLowerSet.not_bot_mem (hs : IsLowerSet s) : ⊥ ∉ s ↔ s = ∅ :=\n  hs.bot_mem.not.trans not_nonempty_iff_eq_empty\n\n"}
{"name":"IsUpperSet.not_bddAbove","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : NoMaxOrder α\nhs : IsUpperSet s\na✝ : s.Nonempty\n⊢ Not (BddAbove s)","decl":"theorem IsUpperSet.not_bddAbove (hs : IsUpperSet s) : s.Nonempty → ¬BddAbove s := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  obtain ⟨c, hc⟩ := exists_gt b\n  exact hc.not_le (hb <| hs ((hb ha).trans hc.le) ha)\n\n"}
{"name":"not_bddAbove_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMaxOrder α\n⊢ Not (BddAbove (Set.Ici a))","decl":"theorem not_bddAbove_Ici : ¬BddAbove (Ici a) :=\n  (isUpperSet_Ici _).not_bddAbove nonempty_Ici\n\n"}
{"name":"not_bddAbove_Ioi","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMaxOrder α\n⊢ Not (BddAbove (Set.Ioi a))","decl":"theorem not_bddAbove_Ioi : ¬BddAbove (Ioi a) :=\n  (isUpperSet_Ioi _).not_bddAbove nonempty_Ioi\n\n"}
{"name":"IsLowerSet.not_bddBelow","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : NoMinOrder α\nhs : IsLowerSet s\na✝ : s.Nonempty\n⊢ Not (BddBelow s)","decl":"theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty → ¬BddBelow s := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  obtain ⟨c, hc⟩ := exists_lt b\n  exact hc.not_le (hb <| hs (hc.le.trans <| hb ha) ha)\n\n"}
{"name":"not_bddBelow_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMinOrder α\n⊢ Not (BddBelow (Set.Iic a))","decl":"theorem not_bddBelow_Iic : ¬BddBelow (Iic a) :=\n  (isLowerSet_Iic _).not_bddBelow nonempty_Iic\n\n"}
{"name":"not_bddBelow_Iio","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMinOrder α\n⊢ Not (BddBelow (Set.Iio a))","decl":"theorem not_bddBelow_Iio : ¬BddBelow (Iio a) :=\n  (isLowerSet_Iio _).not_bddBelow nonempty_Iio\n\n"}
{"name":"isUpperSet_iff_forall_lt","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\n⊢ Iff (IsUpperSet s) (∀ ⦃a b : α⦄, LT.lt a b → Membership.mem s a → Membership.mem s b)","decl":"theorem isUpperSet_iff_forall_lt : IsUpperSet s ↔ ∀ ⦃a b : α⦄, a < b → a ∈ s → b ∈ s :=\n  forall_congr' fun a => by simp [le_iff_eq_or_lt, or_imp, forall_and]\n\n"}
{"name":"isLowerSet_iff_forall_lt","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\n⊢ Iff (IsLowerSet s) (∀ ⦃a b : α⦄, LT.lt b a → Membership.mem s a → Membership.mem s b)","decl":"theorem isLowerSet_iff_forall_lt : IsLowerSet s ↔ ∀ ⦃a b : α⦄, b < a → a ∈ s → b ∈ s :=\n  forall_congr' fun a => by simp [le_iff_eq_or_lt, or_imp, forall_and]\n\n"}
{"name":"isUpperSet_iff_Ioi_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\n⊢ Iff (IsUpperSet s) (∀ ⦃a : α⦄, Membership.mem s a → HasSubset.Subset (Set.Ioi a) s)","decl":"theorem isUpperSet_iff_Ioi_subset : IsUpperSet s ↔ ∀ ⦃a⦄, a ∈ s → Ioi a ⊆ s := by\n  simp [isUpperSet_iff_forall_lt, subset_def, @forall_swap (_ ∈ s)]\n\n"}
{"name":"isLowerSet_iff_Iio_subset","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\n⊢ Iff (IsLowerSet s) (∀ ⦃a : α⦄, Membership.mem s a → HasSubset.Subset (Set.Iio a) s)","decl":"theorem isLowerSet_iff_Iio_subset : IsLowerSet s ↔ ∀ ⦃a⦄, a ∈ s → Iio a ⊆ s := by\n  simp [isLowerSet_iff_forall_lt, subset_def, @forall_swap (_ ∈ s)]\n\n"}
{"name":"Relation.Fibration.isLowerSet_image","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : LE α\ninst✝ : LE β\nhf : Relation.Fibration (fun x1 x2 => LE.le x1 x2) (fun x1 x2 => LE.le x1 x2) f\ns : Set α\nhs : IsLowerSet s\n⊢ IsLowerSet (Set.image f s)","decl":"lemma Fibration.isLowerSet_image [LE α] [LE β] (hf : Fibration (· ≤ ·) (· ≤ ·) f)\n    {s : Set α} (hs : IsLowerSet s) : IsLowerSet (f '' s) := by\n  rintro _ y' e ⟨x, hx, rfl⟩; obtain ⟨y, e', rfl⟩ := hf e; exact ⟨_, hs e' hx, rfl⟩\n\n"}
{"name":"IsLowerSet.image_fibration","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : LE α\ninst✝ : LE β\nhf : Relation.Fibration (fun x1 x2 => LE.le x1 x2) (fun x1 x2 => LE.le x1 x2) f\ns : Set α\nhs : IsLowerSet s\n⊢ IsLowerSet (Set.image f s)","decl":"alias _root_.IsLowerSet.image_fibration := Fibration.isLowerSet_image\n\n"}
{"name":"Relation.fibration_iff_isLowerSet_image_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : LE β\n⊢ Iff (Relation.Fibration (fun x1 x2 => LE.le x1 x2) (fun x1 x2 => LE.le x1 x2) f) (∀ (x : α), IsLowerSet (Set.image f (Set.Iic x)))","decl":"lemma fibration_iff_isLowerSet_image_Iic [Preorder α] [LE β] :\n    Fibration (· ≤ ·) (· ≤ ·) f ↔ ∀ x, IsLowerSet (f '' Iic x) :=\n  ⟨fun h x ↦ (isLowerSet_Iic x).image_fibration h, fun H x _ e ↦ H x e ⟨x, le_rfl, rfl⟩⟩\n\n"}
{"name":"Relation.fibration_iff_isLowerSet_image","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : LE β\n⊢ Iff (Relation.Fibration (fun x1 x2 => LE.le x1 x2) (fun x1 x2 => LE.le x1 x2) f) (∀ (s : Set α), IsLowerSet s → IsLowerSet (Set.image f s))","decl":"lemma fibration_iff_isLowerSet_image [Preorder α] [LE β] :\n    Fibration (· ≤ ·) (· ≤ ·) f ↔ ∀ s, IsLowerSet s → IsLowerSet (f '' s) :=\n  ⟨Fibration.isLowerSet_image,\n    fun H ↦ fibration_iff_isLowerSet_image_Iic.mpr (H _ <| isLowerSet_Iic ·)⟩\n\n"}
{"name":"Relation.fibration_iff_image_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nhf : Monotone f\n⊢ Iff (Relation.Fibration (fun x1 x2 => LE.le x1 x2) (fun x1 x2 => LE.le x1 x2) f) (∀ (x : α), Eq (Set.image f (Set.Iic x)) (Set.Iic (f x)))","decl":"lemma fibration_iff_image_Iic [Preorder α] [Preorder β] (hf : Monotone f) :\n    Fibration (· ≤ ·) (· ≤ ·) f ↔ ∀ x, f '' Iic x = Iic (f x) :=\n  ⟨fun H x ↦ le_antisymm (fun _ ⟨_, hy, e⟩ ↦ e ▸ hf hy)\n    ((H.isLowerSet_image (isLowerSet_Iic x)).Iic_subset ⟨x, le_rfl, rfl⟩),\n    fun H ↦ fibration_iff_isLowerSet_image_Iic.mpr (fun x ↦ (H x).symm ▸ isLowerSet_Iic (f x))⟩\n\n"}
{"name":"Relation.Fibration.isUpperSet_image","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : LE α\ninst✝ : LE β\nhf : Relation.Fibration (fun x1 x2 => GE.ge x1 x2) (fun x1 x2 => GE.ge x1 x2) f\ns : Set α\nhs : IsUpperSet s\n⊢ IsUpperSet (Set.image f s)","decl":"lemma Fibration.isUpperSet_image [LE α] [LE β] (hf : Fibration (· ≥ ·) (· ≥ ·) f)\n    {s : Set α} (hs : IsUpperSet s) : IsUpperSet (f '' s) :=\n  @Fibration.isLowerSet_image αᵒᵈ βᵒᵈ _ _ _ hf s hs\n\n"}
{"name":"IsUpperSet.image_fibration","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : LE α\ninst✝ : LE β\nhf : Relation.Fibration (fun x1 x2 => GE.ge x1 x2) (fun x1 x2 => GE.ge x1 x2) f\ns : Set α\nhs : IsUpperSet s\n⊢ IsUpperSet (Set.image f s)","decl":"alias _root_.IsUpperSet.image_fibration := Fibration.isUpperSet_image\n\n"}
{"name":"Relation.fibration_iff_isUpperSet_image_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : LE β\n⊢ Iff (Relation.Fibration (fun x1 x2 => GE.ge x1 x2) (fun x1 x2 => GE.ge x1 x2) f) (∀ (x : α), IsUpperSet (Set.image f (Set.Ici x)))","decl":"lemma fibration_iff_isUpperSet_image_Ici [Preorder α] [LE β] :\n    Fibration (· ≥ ·) (· ≥ ·) f ↔ ∀ x, IsUpperSet (f '' Ici x) :=\n  @fibration_iff_isLowerSet_image_Iic αᵒᵈ βᵒᵈ _ _ _\n\n"}
{"name":"Relation.fibration_iff_isUpperSet_image","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : LE β\n⊢ Iff (Relation.Fibration (fun x1 x2 => GE.ge x1 x2) (fun x1 x2 => GE.ge x1 x2) f) (∀ (s : Set α), IsUpperSet s → IsUpperSet (Set.image f s))","decl":"lemma fibration_iff_isUpperSet_image [Preorder α] [LE β] :\n    Fibration (· ≥ ·) (· ≥ ·) f ↔ ∀ s, IsUpperSet s → IsUpperSet (f '' s) :=\n  @fibration_iff_isLowerSet_image αᵒᵈ βᵒᵈ _ _ _\n\n"}
{"name":"Relation.fibration_iff_image_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nhf : Monotone f\n⊢ Iff (Relation.Fibration (fun x1 x2 => GE.ge x1 x2) (fun x1 x2 => GE.ge x1 x2) f) (∀ (x : α), Eq (Set.image f (Set.Ici x)) (Set.Ici (f x)))","decl":"lemma fibration_iff_image_Ici [Preorder α] [Preorder β] (hf : Monotone f) :\n    Fibration (· ≥ ·) (· ≥ ·) f ↔ ∀ x, f '' Ici x = Ici (f x) :=\n  fibration_iff_image_Iic hf.dual\n\n"}
{"name":"IsUpperSet.total","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\nhs : IsUpperSet s\nht : IsUpperSet t\n⊢ Or (HasSubset.Subset s t) (HasSubset.Subset t s)","decl":"theorem IsUpperSet.total (hs : IsUpperSet s) (ht : IsUpperSet t) : s ⊆ t ∨ t ⊆ s := by\n  by_contra! h\n  simp_rw [Set.not_subset] at h\n  obtain ⟨⟨a, has, hat⟩, b, hbt, hbs⟩ := h\n  obtain hab | hba := le_total a b\n  · exact hbs (hs hab has)\n  · exact hat (ht hba hbt)\n\n"}
{"name":"IsLowerSet.total","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\nhs : IsLowerSet s\nht : IsLowerSet t\n⊢ Or (HasSubset.Subset s t) (HasSubset.Subset t s)","decl":"theorem IsLowerSet.total (hs : IsLowerSet s) (ht : IsLowerSet t) : s ⊆ t ∨ t ⊆ s :=\n  hs.toDual.total ht.toDual\n\n"}
{"name":"UpperSet.ext","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\na✝ : Eq ↑s ↑t\n⊢ Eq s t","decl":"@[ext]\ntheorem ext {s t : UpperSet α} : (s : Set α) = t → s = t :=\n  SetLike.ext'\n\n"}
{"name":"UpperSet.ext_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\n⊢ Iff (Eq s t) (Eq ↑s ↑t)","decl":"@[ext]\ntheorem ext {s t : UpperSet α} : (s : Set α) = t → s = t :=\n  SetLike.ext'\n\n"}
{"name":"UpperSet.carrier_eq_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : UpperSet α\n⊢ Eq s.carrier ↑s","decl":"@[simp]\ntheorem carrier_eq_coe (s : UpperSet α) : s.carrier = s :=\n  rfl\n\n"}
{"name":"UpperSet.upper","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : UpperSet α\n⊢ IsUpperSet ↑s","decl":"@[simp] protected lemma upper (s : UpperSet α) : IsUpperSet (s : Set α) := s.upper'\n\n"}
{"name":"UpperSet.coe_mk","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\nhs : IsUpperSet s\n⊢ Eq (↑{ carrier := s, upper' := hs }) s","decl":"@[simp, norm_cast] lemma coe_mk (s : Set α) (hs) : mk s hs = s := rfl\n"}
{"name":"UpperSet.mem_mk","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\nhs : IsUpperSet s\na : α\n⊢ Iff (Membership.mem { carrier := s, upper' := hs } a) (Membership.mem s a)","decl":"@[simp] lemma mem_mk {s : Set α} (hs) {a : α} : a ∈ mk s hs ↔ a ∈ s := Iff.rfl\n\n"}
{"name":"LowerSet.ext","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\na✝ : Eq ↑s ↑t\n⊢ Eq s t","decl":"@[ext]\ntheorem ext {s t : LowerSet α} : (s : Set α) = t → s = t :=\n  SetLike.ext'\n\n"}
{"name":"LowerSet.ext_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\n⊢ Iff (Eq s t) (Eq ↑s ↑t)","decl":"@[ext]\ntheorem ext {s t : LowerSet α} : (s : Set α) = t → s = t :=\n  SetLike.ext'\n\n"}
{"name":"LowerSet.carrier_eq_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : LowerSet α\n⊢ Eq s.carrier ↑s","decl":"@[simp]\ntheorem carrier_eq_coe (s : LowerSet α) : s.carrier = s :=\n  rfl\n\n"}
{"name":"LowerSet.lower","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : LowerSet α\n⊢ IsLowerSet ↑s","decl":"@[simp] protected lemma lower (s : LowerSet α) : IsLowerSet (s : Set α) := s.lower'\n\n"}
{"name":"LowerSet.coe_mk","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\nhs : IsLowerSet s\n⊢ Eq (↑{ carrier := s, lower' := hs }) s","decl":"@[simp, norm_cast] lemma coe_mk (s : Set α) (hs) : mk s hs = s := rfl\n"}
{"name":"LowerSet.mem_mk","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\nhs : IsLowerSet s\na : α\n⊢ Iff (Membership.mem { carrier := s, lower' := hs } a) (Membership.mem s a)","decl":"@[simp] lemma mem_mk {s : Set α} (hs) {a : α} : a ∈ mk s hs ↔ a ∈ s := Iff.rfl\n\n"}
{"name":"UpperSet.coe_subset_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\n⊢ Iff (HasSubset.Subset ↑s ↑t) (LE.le t s)","decl":"@[simp 1100, norm_cast]\ntheorem coe_subset_coe : (s : Set α) ⊆ t ↔ t ≤ s :=\n  Iff.rfl\n\n"}
{"name":"UpperSet.coe_ssubset_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\n⊢ Iff (HasSSubset.SSubset ↑s ↑t) (LT.lt t s)","decl":"@[simp 1100, norm_cast] lemma coe_ssubset_coe : (s : Set α) ⊂ t ↔ t < s := Iff.rfl\n\n"}
{"name":"UpperSet.coe_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq (↑Top.top) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_top : ((⊤ : UpperSet α) : Set α) = ∅ :=\n  rfl\n\n"}
{"name":"UpperSet.coe_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq (↑Bot.bot) Set.univ","decl":"@[simp, norm_cast]\ntheorem coe_bot : ((⊥ : UpperSet α) : Set α) = univ :=\n  rfl\n\n"}
{"name":"UpperSet.coe_eq_univ","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : UpperSet α\n⊢ Iff (Eq (↑s) Set.univ) (Eq s Bot.bot)","decl":"@[simp, norm_cast]\ntheorem coe_eq_univ : (s : Set α) = univ ↔ s = ⊥ := by simp [SetLike.ext'_iff]\n\n"}
{"name":"UpperSet.coe_eq_empty","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : UpperSet α\n⊢ Iff (Eq (↑s) EmptyCollection.emptyCollection) (Eq s Top.top)","decl":"@[simp, norm_cast]\ntheorem coe_eq_empty : (s : Set α) = ∅ ↔ s = ⊤ := by simp [SetLike.ext'_iff]\n\n"}
{"name":"UpperSet.coe_nonempty","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : UpperSet α\n⊢ Iff (↑s).Nonempty (Ne s Top.top)","decl":"@[simp, norm_cast] lemma coe_nonempty : (s : Set α).Nonempty ↔ s ≠ ⊤ :=\n  nonempty_iff_ne_empty.trans coe_eq_empty.not\n\n"}
{"name":"UpperSet.coe_sup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\n⊢ Eq (↑(Max.max s t)) (Inter.inter ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_sup (s t : UpperSet α) : (↑(s ⊔ t) : Set α) = (s : Set α) ∩ t :=\n  rfl\n\n"}
{"name":"UpperSet.coe_inf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\n⊢ Eq (↑(Min.min s t)) (Union.union ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_inf (s t : UpperSet α) : (↑(s ⊓ t) : Set α) = (s : Set α) ∪ t :=\n  rfl\n\n"}
{"name":"UpperSet.coe_sSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (UpperSet α)\n⊢ Eq (↑(SupSet.sSup S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sSup (S : Set (UpperSet α)) : (↑(sSup S) : Set α) = ⋂ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"UpperSet.coe_sInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (UpperSet α)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sInf (S : Set (UpperSet α)) : (↑(sInf S) : Set α) = ⋃ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"UpperSet.coe_iSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → UpperSet α\n⊢ Eq (↑(iSup fun i => f i)) (Set.iInter fun i => ↑(f i))","decl":"@[simp, norm_cast]\ntheorem coe_iSup (f : ι → UpperSet α) : (↑(⨆ i, f i) : Set α) = ⋂ i, f i := by simp [iSup]\n\n"}
{"name":"UpperSet.coe_iInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → UpperSet α\n⊢ Eq (↑(iInf fun i => f i)) (Set.iUnion fun i => ↑(f i))","decl":"@[simp, norm_cast]\ntheorem coe_iInf (f : ι → UpperSet α) : (↑(⨅ i, f i) : Set α) = ⋃ i, f i := by simp [iInf]\n\n"}
{"name":"UpperSet.coe_iSup₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → UpperSet α\n⊢ Eq (↑(iSup fun i => iSup fun j => f i j)) (Set.iInter fun i => Set.iInter fun j => ↑(f i j))","decl":"@[norm_cast] -- Porting note: no longer a `simp`\ntheorem coe_iSup₂ (f : ∀ i, κ i → UpperSet α) :\n    (↑(⨆ (i) (j), f i j) : Set α) = ⋂ (i) (j), f i j := by simp_rw [coe_iSup]\n\n"}
{"name":"UpperSet.coe_iInf₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → UpperSet α\n⊢ Eq (↑(iInf fun i => iInf fun j => f i j)) (Set.iUnion fun i => Set.iUnion fun j => ↑(f i j))","decl":"@[norm_cast] -- Porting note: no longer a `simp`\ntheorem coe_iInf₂ (f : ∀ i, κ i → UpperSet α) :\n    (↑(⨅ (i) (j), f i j) : Set α) = ⋃ (i) (j), f i j := by simp_rw [coe_iInf]\n\n"}
{"name":"UpperSet.not_mem_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Not (Membership.mem Top.top a)","decl":"@[simp]\ntheorem not_mem_top : a ∉ (⊤ : UpperSet α) :=\n  id\n\n"}
{"name":"UpperSet.mem_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Membership.mem Bot.bot a","decl":"@[simp]\ntheorem mem_bot : a ∈ (⊥ : UpperSet α) :=\n  trivial\n\n"}
{"name":"UpperSet.mem_sup_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\na : α\n⊢ Iff (Membership.mem (Max.max s t) a) (And (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\ntheorem mem_sup_iff : a ∈ s ⊔ t ↔ a ∈ s ∧ a ∈ t :=\n  Iff.rfl\n\n"}
{"name":"UpperSet.mem_inf_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\na : α\n⊢ Iff (Membership.mem (Min.min s t) a) (Or (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\ntheorem mem_inf_iff : a ∈ s ⊓ t ↔ a ∈ s ∨ a ∈ t :=\n  Iff.rfl\n\n"}
{"name":"UpperSet.mem_sSup_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (UpperSet α)\na : α\n⊢ Iff (Membership.mem (SupSet.sSup S) a) (∀ (s : UpperSet α), Membership.mem S s → Membership.mem s a)","decl":"@[simp]\ntheorem mem_sSup_iff : a ∈ sSup S ↔ ∀ s ∈ S, a ∈ s :=\n  mem_iInter₂\n\n"}
{"name":"UpperSet.mem_sInf_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (UpperSet α)\na : α\n⊢ Iff (Membership.mem (InfSet.sInf S) a) (Exists fun s => And (Membership.mem S s) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_sInf_iff : a ∈ sInf S ↔ ∃ s ∈ S, a ∈ s :=\n  mem_iUnion₂.trans <| by simp only [exists_prop, SetLike.mem_coe]\n\n"}
{"name":"UpperSet.mem_iSup_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\na : α\nf : ι → UpperSet α\n⊢ Iff (Membership.mem (iSup fun i => f i) a) (∀ (i : ι), Membership.mem (f i) a)","decl":"@[simp]\ntheorem mem_iSup_iff {f : ι → UpperSet α} : (a ∈ ⨆ i, f i) ↔ ∀ i, a ∈ f i := by\n  rw [← SetLike.mem_coe, coe_iSup]\n  exact mem_iInter\n\n"}
{"name":"UpperSet.mem_iInf_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\na : α\nf : ι → UpperSet α\n⊢ Iff (Membership.mem (iInf fun i => f i) a) (Exists fun i => Membership.mem (f i) a)","decl":"@[simp]\ntheorem mem_iInf_iff {f : ι → UpperSet α} : (a ∈ ⨅ i, f i) ↔ ∃ i, a ∈ f i := by\n  rw [← SetLike.mem_coe, coe_iInf]\n  exact mem_iUnion\n\n-- Porting note: no longer a @[simp]\n"}
{"name":"UpperSet.mem_iSup₂_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\na : α\nf : (i : ι) → κ i → UpperSet α\n⊢ Iff (Membership.mem (iSup fun i => iSup fun j => f i j) a) (∀ (i : ι) (j : κ i), Membership.mem (f i j) a)","decl":"theorem mem_iSup₂_iff {f : ∀ i, κ i → UpperSet α} : (a ∈ ⨆ (i) (j), f i j) ↔ ∀ i j, a ∈ f i j := by\n  simp_rw [mem_iSup_iff]\n\n-- Porting note: no longer a @[simp]\n"}
{"name":"UpperSet.mem_iInf₂_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\na : α\nf : (i : ι) → κ i → UpperSet α\n⊢ Iff (Membership.mem (iInf fun i => iInf fun j => f i j) a) (Exists fun i => Exists fun j => Membership.mem (f i j) a)","decl":"theorem mem_iInf₂_iff {f : ∀ i, κ i → UpperSet α} : (a ∈ ⨅ (i) (j), f i j) ↔ ∃ i j, a ∈ f i j := by\n  simp_rw [mem_iInf_iff]\n\n"}
{"name":"UpperSet.codisjoint_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\n⊢ Iff (Codisjoint ↑s ↑t) (Disjoint s t)","decl":"@[simp, norm_cast]\ntheorem codisjoint_coe : Codisjoint (s : Set α) t ↔ Disjoint s t := by\n  simp [disjoint_iff, codisjoint_iff, SetLike.ext'_iff]\n\n"}
{"name":"LowerSet.coe_subset_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\n⊢ Iff (HasSubset.Subset ↑s ↑t) (LE.le s t)","decl":"@[norm_cast] lemma coe_subset_coe : (s : Set α) ⊆ t ↔ s ≤ t := Iff.rfl\n\n"}
{"name":"LowerSet.coe_ssubset_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\n⊢ Iff (HasSSubset.SSubset ↑s ↑t) (LT.lt s t)","decl":"@[norm_cast] lemma coe_ssubset_coe : (s : Set α) ⊂ t ↔ s < t := Iff.rfl\n\n"}
{"name":"LowerSet.coe_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp, norm_cast]\ntheorem coe_top : ((⊤ : LowerSet α) : Set α) = univ :=\n  rfl\n\n"}
{"name":"LowerSet.coe_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq (↑Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_bot : ((⊥ : LowerSet α) : Set α) = ∅ :=\n  rfl\n\n"}
{"name":"LowerSet.coe_eq_univ","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : LowerSet α\n⊢ Iff (Eq (↑s) Set.univ) (Eq s Top.top)","decl":"@[simp, norm_cast]\ntheorem coe_eq_univ : (s : Set α) = univ ↔ s = ⊤ := by simp [SetLike.ext'_iff]\n\n"}
{"name":"LowerSet.coe_eq_empty","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : LowerSet α\n⊢ Iff (Eq (↑s) EmptyCollection.emptyCollection) (Eq s Bot.bot)","decl":"@[simp, norm_cast]\ntheorem coe_eq_empty : (s : Set α) = ∅ ↔ s = ⊥ := by simp [SetLike.ext'_iff]\n\n"}
{"name":"LowerSet.coe_nonempty","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : LowerSet α\n⊢ Iff (↑s).Nonempty (Ne s Bot.bot)","decl":"@[simp, norm_cast] lemma coe_nonempty : (s : Set α).Nonempty ↔ s ≠ ⊥ :=\n  nonempty_iff_ne_empty.trans coe_eq_empty.not\n\n"}
{"name":"LowerSet.coe_sup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\n⊢ Eq (↑(Max.max s t)) (Union.union ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_sup (s t : LowerSet α) : (↑(s ⊔ t) : Set α) = (s : Set α) ∪ t :=\n  rfl\n\n"}
{"name":"LowerSet.coe_inf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\n⊢ Eq (↑(Min.min s t)) (Inter.inter ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_inf (s t : LowerSet α) : (↑(s ⊓ t) : Set α) = (s : Set α) ∩ t :=\n  rfl\n\n"}
{"name":"LowerSet.coe_sSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (LowerSet α)\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sSup (S : Set (LowerSet α)) : (↑(sSup S) : Set α) = ⋃ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"LowerSet.coe_sInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (LowerSet α)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sInf (S : Set (LowerSet α)) : (↑(sInf S) : Set α) = ⋂ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"LowerSet.coe_iSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → LowerSet α\n⊢ Eq (↑(iSup fun i => f i)) (Set.iUnion fun i => ↑(f i))","decl":"@[simp, norm_cast]\ntheorem coe_iSup (f : ι → LowerSet α) : (↑(⨆ i, f i) : Set α) = ⋃ i, f i := by\n  simp_rw [iSup, coe_sSup, mem_range, iUnion_exists, iUnion_iUnion_eq']\n\n"}
{"name":"LowerSet.coe_iInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → LowerSet α\n⊢ Eq (↑(iInf fun i => f i)) (Set.iInter fun i => ↑(f i))","decl":"@[simp, norm_cast]\ntheorem coe_iInf (f : ι → LowerSet α) : (↑(⨅ i, f i) : Set α) = ⋂ i, f i := by\n  simp_rw [iInf, coe_sInf, mem_range, iInter_exists, iInter_iInter_eq']\n\n"}
{"name":"LowerSet.coe_iSup₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → LowerSet α\n⊢ Eq (↑(iSup fun i => iSup fun j => f i j)) (Set.iUnion fun i => Set.iUnion fun j => ↑(f i j))","decl":"@[norm_cast] -- Porting note: no longer a `simp`\ntheorem coe_iSup₂ (f : ∀ i, κ i → LowerSet α) :\n    (↑(⨆ (i) (j), f i j) : Set α) = ⋃ (i) (j), f i j := by simp_rw [coe_iSup]\n\n"}
{"name":"LowerSet.coe_iInf₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → LowerSet α\n⊢ Eq (↑(iInf fun i => iInf fun j => f i j)) (Set.iInter fun i => Set.iInter fun j => ↑(f i j))","decl":"@[norm_cast] -- Porting note: no longer a `simp`\ntheorem coe_iInf₂ (f : ∀ i, κ i → LowerSet α) :\n    (↑(⨅ (i) (j), f i j) : Set α) = ⋂ (i) (j), f i j := by simp_rw [coe_iInf]\n\n"}
{"name":"LowerSet.mem_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Membership.mem Top.top a","decl":"@[simp]\ntheorem mem_top : a ∈ (⊤ : LowerSet α) :=\n  trivial\n\n"}
{"name":"LowerSet.not_mem_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\na : α\n⊢ Not (Membership.mem Bot.bot a)","decl":"@[simp]\ntheorem not_mem_bot : a ∉ (⊥ : LowerSet α) :=\n  id\n\n"}
{"name":"LowerSet.mem_sup_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\na : α\n⊢ Iff (Membership.mem (Max.max s t) a) (Or (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\ntheorem mem_sup_iff : a ∈ s ⊔ t ↔ a ∈ s ∨ a ∈ t :=\n  Iff.rfl\n\n"}
{"name":"LowerSet.mem_inf_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\na : α\n⊢ Iff (Membership.mem (Min.min s t) a) (And (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\ntheorem mem_inf_iff : a ∈ s ⊓ t ↔ a ∈ s ∧ a ∈ t :=\n  Iff.rfl\n\n"}
{"name":"LowerSet.mem_sSup_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (LowerSet α)\na : α\n⊢ Iff (Membership.mem (SupSet.sSup S) a) (Exists fun s => And (Membership.mem S s) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_sSup_iff : a ∈ sSup S ↔ ∃ s ∈ S, a ∈ s :=\n  mem_iUnion₂.trans <| by simp only [exists_prop, SetLike.mem_coe]\n\n"}
{"name":"LowerSet.mem_sInf_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (LowerSet α)\na : α\n⊢ Iff (Membership.mem (InfSet.sInf S) a) (∀ (s : LowerSet α), Membership.mem S s → Membership.mem s a)","decl":"@[simp]\ntheorem mem_sInf_iff : a ∈ sInf S ↔ ∀ s ∈ S, a ∈ s :=\n  mem_iInter₂\n\n"}
{"name":"LowerSet.mem_iSup_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\na : α\nf : ι → LowerSet α\n⊢ Iff (Membership.mem (iSup fun i => f i) a) (Exists fun i => Membership.mem (f i) a)","decl":"@[simp]\ntheorem mem_iSup_iff {f : ι → LowerSet α} : (a ∈ ⨆ i, f i) ↔ ∃ i, a ∈ f i := by\n  rw [← SetLike.mem_coe, coe_iSup]\n  exact mem_iUnion\n\n"}
{"name":"LowerSet.mem_iInf_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\na : α\nf : ι → LowerSet α\n⊢ Iff (Membership.mem (iInf fun i => f i) a) (∀ (i : ι), Membership.mem (f i) a)","decl":"@[simp]\ntheorem mem_iInf_iff {f : ι → LowerSet α} : (a ∈ ⨅ i, f i) ↔ ∀ i, a ∈ f i := by\n  rw [← SetLike.mem_coe, coe_iInf]\n  exact mem_iInter\n\n-- Porting note: no longer a @[simp]\n"}
{"name":"LowerSet.mem_iSup₂_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\na : α\nf : (i : ι) → κ i → LowerSet α\n⊢ Iff (Membership.mem (iSup fun i => iSup fun j => f i j) a) (Exists fun i => Exists fun j => Membership.mem (f i j) a)","decl":"theorem mem_iSup₂_iff {f : ∀ i, κ i → LowerSet α} : (a ∈ ⨆ (i) (j), f i j) ↔ ∃ i j, a ∈ f i j := by\n  simp_rw [mem_iSup_iff]\n\n-- Porting note: no longer a @[simp]\n"}
{"name":"LowerSet.mem_iInf₂_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\na : α\nf : (i : ι) → κ i → LowerSet α\n⊢ Iff (Membership.mem (iInf fun i => iInf fun j => f i j) a) (∀ (i : ι) (j : κ i), Membership.mem (f i j) a)","decl":"theorem mem_iInf₂_iff {f : ∀ i, κ i → LowerSet α} : (a ∈ ⨅ (i) (j), f i j) ↔ ∀ i j, a ∈ f i j := by\n  simp_rw [mem_iInf_iff]\n\n"}
{"name":"LowerSet.disjoint_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\n⊢ Iff (Disjoint ↑s ↑t) (Disjoint s t)","decl":"@[simp, norm_cast]\ntheorem disjoint_coe : Disjoint (s : Set α) t ↔ Disjoint s t := by\n  simp [disjoint_iff, SetLike.ext'_iff]\n\n"}
{"name":"UpperSet.coe_compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : UpperSet α\n⊢ Eq (↑s.compl) (HasCompl.compl ↑s)","decl":"@[simp]\ntheorem coe_compl (s : UpperSet α) : (s.compl : Set α) = (↑s)ᶜ :=\n  rfl\n\n"}
{"name":"UpperSet.mem_compl_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : UpperSet α\na : α\n⊢ Iff (Membership.mem s.compl a) (Not (Membership.mem s a))","decl":"@[simp]\ntheorem mem_compl_iff : a ∈ s.compl ↔ a ∉ s :=\n  Iff.rfl\n\n"}
{"name":"UpperSet.compl_compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : UpperSet α\n⊢ Eq s.compl.compl s","decl":"@[simp]\nnonrec theorem compl_compl (s : UpperSet α) : s.compl.compl = s :=\n  UpperSet.ext <| compl_compl _\n\n"}
{"name":"UpperSet.compl_le_compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\n⊢ Iff (LE.le s.compl t.compl) (LE.le s t)","decl":"@[simp]\ntheorem compl_le_compl : s.compl ≤ t.compl ↔ s ≤ t :=\n  compl_subset_compl\n\n"}
{"name":"UpperSet.compl_sup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\n⊢ Eq (Max.max s t).compl (Max.max s.compl t.compl)","decl":"@[simp]\nprotected theorem compl_sup (s t : UpperSet α) : (s ⊔ t).compl = s.compl ⊔ t.compl :=\n  LowerSet.ext compl_inf\n\n"}
{"name":"UpperSet.compl_inf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : UpperSet α\n⊢ Eq (Min.min s t).compl (Min.min s.compl t.compl)","decl":"@[simp]\nprotected theorem compl_inf (s t : UpperSet α) : (s ⊓ t).compl = s.compl ⊓ t.compl :=\n  LowerSet.ext compl_sup\n\n"}
{"name":"UpperSet.compl_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq Top.top.compl Top.top","decl":"@[simp]\nprotected theorem compl_top : (⊤ : UpperSet α).compl = ⊤ :=\n  LowerSet.ext compl_empty\n\n"}
{"name":"UpperSet.compl_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq Bot.bot.compl Bot.bot","decl":"@[simp]\nprotected theorem compl_bot : (⊥ : UpperSet α).compl = ⊥ :=\n  LowerSet.ext compl_univ\n\n"}
{"name":"UpperSet.compl_sSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (UpperSet α)\n⊢ Eq (SupSet.sSup S).compl (iSup fun s => iSup fun h => s.compl)","decl":"@[simp]\nprotected theorem compl_sSup (S : Set (UpperSet α)) : (sSup S).compl = ⨆ s ∈ S, UpperSet.compl s :=\n  LowerSet.ext <| by simp only [coe_compl, coe_sSup, compl_iInter₂, LowerSet.coe_iSup₂]\n\n"}
{"name":"UpperSet.compl_sInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (UpperSet α)\n⊢ Eq (InfSet.sInf S).compl (iInf fun s => iInf fun h => s.compl)","decl":"@[simp]\nprotected theorem compl_sInf (S : Set (UpperSet α)) : (sInf S).compl = ⨅ s ∈ S, UpperSet.compl s :=\n  LowerSet.ext <| by simp only [coe_compl, coe_sInf, compl_iUnion₂, LowerSet.coe_iInf₂]\n\n"}
{"name":"UpperSet.compl_iSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → UpperSet α\n⊢ Eq (iSup fun i => f i).compl (iSup fun i => (f i).compl)","decl":"@[simp]\nprotected theorem compl_iSup (f : ι → UpperSet α) : (⨆ i, f i).compl = ⨆ i, (f i).compl :=\n  LowerSet.ext <| by simp only [coe_compl, coe_iSup, compl_iInter, LowerSet.coe_iSup]\n\n"}
{"name":"UpperSet.compl_iInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → UpperSet α\n⊢ Eq (iInf fun i => f i).compl (iInf fun i => (f i).compl)","decl":"@[simp]\nprotected theorem compl_iInf (f : ι → UpperSet α) : (⨅ i, f i).compl = ⨅ i, (f i).compl :=\n  LowerSet.ext <| by simp only [coe_compl, coe_iInf, compl_iUnion, LowerSet.coe_iInf]\n\n-- Porting note: no longer a @[simp]\n"}
{"name":"UpperSet.compl_iSup₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → UpperSet α\n⊢ Eq (iSup fun i => iSup fun j => f i j).compl (iSup fun i => iSup fun j => (f i j).compl)","decl":"theorem compl_iSup₂ (f : ∀ i, κ i → UpperSet α) :\n    (⨆ (i) (j), f i j).compl = ⨆ (i) (j), (f i j).compl := by simp_rw [UpperSet.compl_iSup]\n\n-- Porting note: no longer a @[simp]\n"}
{"name":"UpperSet.compl_iInf₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → UpperSet α\n⊢ Eq (iInf fun i => iInf fun j => f i j).compl (iInf fun i => iInf fun j => (f i j).compl)","decl":"theorem compl_iInf₂ (f : ∀ i, κ i → UpperSet α) :\n    (⨅ (i) (j), f i j).compl = ⨅ (i) (j), (f i j).compl := by simp_rw [UpperSet.compl_iInf]\n\n"}
{"name":"LowerSet.coe_compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : LowerSet α\n⊢ Eq (↑s.compl) (HasCompl.compl ↑s)","decl":"@[simp]\ntheorem coe_compl (s : LowerSet α) : (s.compl : Set α) = (↑s)ᶜ :=\n  rfl\n\n"}
{"name":"LowerSet.mem_compl_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : LowerSet α\na : α\n⊢ Iff (Membership.mem s.compl a) (Not (Membership.mem s a))","decl":"@[simp]\ntheorem mem_compl_iff : a ∈ s.compl ↔ a ∉ s :=\n  Iff.rfl\n\n"}
{"name":"LowerSet.compl_compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : LowerSet α\n⊢ Eq s.compl.compl s","decl":"@[simp]\nnonrec theorem compl_compl (s : LowerSet α) : s.compl.compl = s :=\n  LowerSet.ext <| compl_compl _\n\n"}
{"name":"LowerSet.compl_le_compl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\n⊢ Iff (LE.le s.compl t.compl) (LE.le s t)","decl":"@[simp]\ntheorem compl_le_compl : s.compl ≤ t.compl ↔ s ≤ t :=\n  compl_subset_compl\n\n"}
{"name":"LowerSet.compl_sup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\n⊢ Eq (Max.max s t).compl (Max.max s.compl t.compl)","decl":"protected theorem compl_sup (s t : LowerSet α) : (s ⊔ t).compl = s.compl ⊔ t.compl :=\n  UpperSet.ext compl_sup\n\n"}
{"name":"LowerSet.compl_inf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : LowerSet α\n⊢ Eq (Min.min s t).compl (Min.min s.compl t.compl)","decl":"protected theorem compl_inf (s t : LowerSet α) : (s ⊓ t).compl = s.compl ⊓ t.compl :=\n  UpperSet.ext compl_inf\n\n"}
{"name":"LowerSet.compl_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq Top.top.compl Top.top","decl":"protected theorem compl_top : (⊤ : LowerSet α).compl = ⊤ :=\n  UpperSet.ext compl_univ\n\n"}
{"name":"LowerSet.compl_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Eq Bot.bot.compl Bot.bot","decl":"protected theorem compl_bot : (⊥ : LowerSet α).compl = ⊥ :=\n  UpperSet.ext compl_empty\n\n"}
{"name":"LowerSet.compl_sSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (LowerSet α)\n⊢ Eq (SupSet.sSup S).compl (iSup fun s => iSup fun h => s.compl)","decl":"protected theorem compl_sSup (S : Set (LowerSet α)) : (sSup S).compl = ⨆ s ∈ S, LowerSet.compl s :=\n  UpperSet.ext <| by simp only [coe_compl, coe_sSup, compl_iUnion₂, UpperSet.coe_iSup₂]\n\n"}
{"name":"LowerSet.compl_sInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\nS : Set (LowerSet α)\n⊢ Eq (InfSet.sInf S).compl (iInf fun s => iInf fun h => s.compl)","decl":"protected theorem compl_sInf (S : Set (LowerSet α)) : (sInf S).compl = ⨅ s ∈ S, LowerSet.compl s :=\n  UpperSet.ext <| by simp only [coe_compl, coe_sInf, compl_iInter₂, UpperSet.coe_iInf₂]\n\n"}
{"name":"LowerSet.compl_iSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → LowerSet α\n⊢ Eq (iSup fun i => f i).compl (iSup fun i => (f i).compl)","decl":"protected theorem compl_iSup (f : ι → LowerSet α) : (⨆ i, f i).compl = ⨆ i, (f i).compl :=\n  UpperSet.ext <| by simp only [coe_compl, coe_iSup, compl_iUnion, UpperSet.coe_iSup]\n\n"}
{"name":"LowerSet.compl_iInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : LE α\nf : ι → LowerSet α\n⊢ Eq (iInf fun i => f i).compl (iInf fun i => (f i).compl)","decl":"protected theorem compl_iInf (f : ι → LowerSet α) : (⨅ i, f i).compl = ⨅ i, (f i).compl :=\n  UpperSet.ext <| by simp only [coe_compl, coe_iInf, compl_iInter, UpperSet.coe_iInf]\n\n"}
{"name":"LowerSet.compl_iSup₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → LowerSet α\n⊢ Eq (iSup fun i => iSup fun j => f i j).compl (iSup fun i => iSup fun j => (f i j).compl)","decl":"@[simp]\ntheorem compl_iSup₂ (f : ∀ i, κ i → LowerSet α) :\n    (⨆ (i) (j), f i j).compl = ⨆ (i) (j), (f i j).compl := by simp_rw [LowerSet.compl_iSup]\n\n"}
{"name":"LowerSet.compl_iInf₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : LE α\nf : (i : ι) → κ i → LowerSet α\n⊢ Eq (iInf fun i => iInf fun j => f i j).compl (iInf fun i => iInf fun j => (f i j).compl)","decl":"@[simp]\ntheorem compl_iInf₂ (f : ∀ i, κ i → LowerSet α) :\n    (⨅ (i) (j), f i j).compl = ⨅ (i) (j), (f i j).compl := by simp_rw [LowerSet.compl_iInf]\n\n"}
{"name":"upperSetIsoLowerSet_symm_apply","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : LowerSet α\n⊢ Eq ((RelIso.symm upperSetIsoLowerSet) s) s.compl","decl":"/-- Upper sets are order-isomorphic to lower sets under complementation. -/\n@[simps]\ndef upperSetIsoLowerSet : UpperSet α ≃o LowerSet α where\n  toFun := UpperSet.compl\n  invFun := LowerSet.compl\n  left_inv := UpperSet.compl_compl\n  right_inv := LowerSet.compl_compl\n  map_rel_iff' := UpperSet.compl_le_compl\n\n"}
{"name":"upperSetIsoLowerSet_apply","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : UpperSet α\n⊢ Eq (upperSetIsoLowerSet s) s.compl","decl":"/-- Upper sets are order-isomorphic to lower sets under complementation. -/\n@[simps]\ndef upperSetIsoLowerSet : UpperSet α ≃o LowerSet α where\n  toFun := UpperSet.compl\n  invFun := LowerSet.compl\n  left_inv := UpperSet.compl_compl\n  right_inv := LowerSet.compl_compl\n  map_rel_iff' := UpperSet.compl_le_compl\n\n"}
{"name":"UpperSet.isTotal_le","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ IsTotal (UpperSet α) fun x1 x2 => LE.le x1 x2","decl":"instance UpperSet.isTotal_le : IsTotal (UpperSet α) (· ≤ ·) := ⟨fun s t => t.upper.total s.upper⟩\n\n"}
{"name":"LowerSet.isTotal_le","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ IsTotal (LowerSet α) fun x1 x2 => LE.le x1 x2","decl":"instance LowerSet.isTotal_le : IsTotal (LowerSet α) (· ≤ ·) := ⟨fun s t => s.lower.total t.lower⟩\n\n"}
{"name":"UpperSet.symm_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\n⊢ Eq (UpperSet.map f).symm (UpperSet.map f.symm)","decl":"@[simp]\ntheorem symm_map (f : α ≃o β) : (map f).symm = map f.symm :=\n  DFunLike.ext _ _ fun s => ext <| by convert Set.preimage_equiv_eq_image_symm s f.toEquiv\n\n"}
{"name":"UpperSet.mem_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\ns : UpperSet α\nb : β\n⊢ Iff (Membership.mem ((UpperSet.map f) s) b) (Membership.mem s (f.symm b))","decl":"@[simp]\ntheorem mem_map : b ∈ map f s ↔ f.symm b ∈ s := by\n  rw [← f.symm_symm, ← symm_map, f.symm_symm]\n  rfl\n\n"}
{"name":"UpperSet.map_refl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (UpperSet.map (OrderIso.refl α)) (OrderIso.refl (UpperSet α))","decl":"@[simp]\ntheorem map_refl : map (OrderIso.refl α) = OrderIso.refl _ := by\n  ext\n  simp\n\n"}
{"name":"UpperSet.map_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ns : UpperSet α\ng : OrderIso β γ\nf : OrderIso α β\n⊢ Eq ((UpperSet.map g) ((UpperSet.map f) s)) ((UpperSet.map (f.trans g)) s)","decl":"@[simp]\ntheorem map_map (g : β ≃o γ) (f : α ≃o β) : map g (map f s) = map (f.trans g) s := by\n  ext\n  simp\n\n"}
{"name":"UpperSet.coe_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\ns : UpperSet α\n⊢ Eq (↑((UpperSet.map f) s)) (Set.image ⇑f ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_map : (map f s : Set β) = f '' s :=\n  rfl\n\n"}
{"name":"LowerSet.symm_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\n⊢ Eq (LowerSet.map f).symm (LowerSet.map f.symm)","decl":"@[simp]\ntheorem symm_map (f : α ≃o β) : (map f).symm = map f.symm :=\n  DFunLike.ext _ _ fun s => ext <| by convert Set.preimage_equiv_eq_image_symm s f.toEquiv\n\n"}
{"name":"LowerSet.mem_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : LowerSet α\nf : OrderIso α β\nb : β\n⊢ Iff (Membership.mem ((LowerSet.map f) s) b) (Membership.mem s (f.symm b))","decl":"@[simp]\ntheorem mem_map {f : α ≃o β} {b : β} : b ∈ map f s ↔ f.symm b ∈ s := by\n  rw [← f.symm_symm, ← symm_map, f.symm_symm]\n  rfl\n\n"}
{"name":"LowerSet.map_refl","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (LowerSet.map (OrderIso.refl α)) (OrderIso.refl (LowerSet α))","decl":"@[simp]\ntheorem map_refl : map (OrderIso.refl α) = OrderIso.refl _ := by\n  ext\n  simp\n\n"}
{"name":"LowerSet.map_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ns : LowerSet α\ng : OrderIso β γ\nf : OrderIso α β\n⊢ Eq ((LowerSet.map g) ((LowerSet.map f) s)) ((LowerSet.map (f.trans g)) s)","decl":"@[simp]\ntheorem map_map (g : β ≃o γ) (f : α ≃o β) : map g (map f s) = map (f.trans g) s := by\n  ext\n  simp\n\n"}
{"name":"LowerSet.coe_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\ns : LowerSet α\n⊢ Eq (↑((LowerSet.map f) s)) (Set.image ⇑f ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_map : (map f s : Set β) = f '' s :=\n  rfl\n\n"}
{"name":"UpperSet.compl_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\ns : UpperSet α\n⊢ Eq ((UpperSet.map f) s).compl ((LowerSet.map f) s.compl)","decl":"@[simp]\ntheorem compl_map (f : α ≃o β) (s : UpperSet α) : (map f s).compl = LowerSet.map f s.compl :=\n  SetLike.coe_injective (Set.image_compl_eq f.bijective).symm\n\n"}
{"name":"LowerSet.compl_map","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\ns : LowerSet α\n⊢ Eq ((LowerSet.map f) s).compl ((UpperSet.map f) s.compl)","decl":"@[simp]\ntheorem compl_map (f : α ≃o β) (s : LowerSet α) : (map f s).compl = UpperSet.map f s.compl :=\n  SetLike.coe_injective (Set.image_compl_eq f.bijective).symm\n\n"}
{"name":"UpperSet.coe_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (↑(UpperSet.Ici a)) (Set.Ici a)","decl":"@[simp]\ntheorem coe_Ici (a : α) : ↑(Ici a) = Set.Ici a :=\n  rfl\n\n"}
{"name":"UpperSet.coe_Ioi","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (↑(UpperSet.Ioi a)) (Set.Ioi a)","decl":"@[simp]\ntheorem coe_Ioi (a : α) : ↑(Ioi a) = Set.Ioi a :=\n  rfl\n\n"}
{"name":"UpperSet.mem_Ici_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (UpperSet.Ici a) b) (LE.le a b)","decl":"@[simp]\ntheorem mem_Ici_iff : b ∈ Ici a ↔ a ≤ b :=\n  Iff.rfl\n\n"}
{"name":"UpperSet.mem_Ioi_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (UpperSet.Ioi a) b) (LT.lt a b)","decl":"@[simp]\ntheorem mem_Ioi_iff : b ∈ Ioi a ↔ a < b :=\n  Iff.rfl\n\n"}
{"name":"UpperSet.map_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\na : α\n⊢ Eq ((UpperSet.map f) (UpperSet.Ici a)) (UpperSet.Ici (f a))","decl":"@[simp]\ntheorem map_Ici (f : α ≃o β) (a : α) : map f (Ici a) = Ici (f a) := by\n  ext\n  simp\n\n"}
{"name":"UpperSet.map_Ioi","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\na : α\n⊢ Eq ((UpperSet.map f) (UpperSet.Ioi a)) (UpperSet.Ioi (f a))","decl":"@[simp]\ntheorem map_Ioi (f : α ≃o β) (a : α) : map f (Ioi a) = Ioi (f a) := by\n  ext\n  simp\n\n"}
{"name":"UpperSet.Ici_le_Ioi","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ LE.le (UpperSet.Ici a) (UpperSet.Ioi a)","decl":"theorem Ici_le_Ioi (a : α) : Ici a ≤ Ioi a :=\n  Ioi_subset_Ici_self\n\n"}
{"name":"UpperSet.Ici_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ Eq (UpperSet.Ici Bot.bot) Bot.bot","decl":"@[simp]\nnonrec theorem Ici_bot [OrderBot α] : Ici (⊥ : α) = ⊥ :=\n  SetLike.coe_injective Ici_bot\n\n"}
{"name":"UpperSet.Ioi_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ Eq (UpperSet.Ioi Top.top) Top.top","decl":"@[simp]\nnonrec theorem Ioi_top [OrderTop α] : Ioi (⊤ : α) = ⊤ :=\n  SetLike.coe_injective Ioi_top\n\n"}
{"name":"UpperSet.Ici_ne_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Ne (UpperSet.Ici a) Top.top","decl":"@[simp] lemma Ici_ne_top : Ici a ≠ ⊤ := SetLike.coe_ne_coe.1 nonempty_Ici.ne_empty\n"}
{"name":"UpperSet.Ici_lt_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ LT.lt (UpperSet.Ici a) Top.top","decl":"@[simp] lemma Ici_lt_top : Ici a < ⊤ := lt_top_iff_ne_top.2 Ici_ne_top\n"}
{"name":"UpperSet.le_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\na : α\n⊢ Iff (LE.le s (UpperSet.Ici a)) (Membership.mem s a)","decl":"@[simp] lemma le_Ici : s ≤ Ici a ↔ a ∈ s := ⟨fun h ↦ h le_rfl, fun ha ↦ s.upper.Ici_subset ha⟩\n\n"}
{"name":"UpperSet.Ici_injective","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Function.Injective UpperSet.Ici","decl":"nonrec lemma Ici_injective : Injective (Ici : α → UpperSet α) := fun _a _b hab ↦\n  Ici_injective <| congr_arg ((↑) : _ → Set α) hab\n\n"}
{"name":"UpperSet.Ici_inj","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Eq (UpperSet.Ici a) (UpperSet.Ici b)) (Eq a b)","decl":"@[simp] lemma Ici_inj : Ici a = Ici b ↔ a = b := Ici_injective.eq_iff\n\n"}
{"name":"UpperSet.Ici_ne_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Ne (UpperSet.Ici a) (UpperSet.Ici b)) (Ne a b)","decl":"lemma Ici_ne_Ici : Ici a ≠ Ici b ↔ a ≠ b := Ici_inj.not\n\n"}
{"name":"UpperSet.Ici_sup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\na b : α\n⊢ Eq (UpperSet.Ici (Max.max a b)) (Max.max (UpperSet.Ici a) (UpperSet.Ici b))","decl":"@[simp]\ntheorem Ici_sup [SemilatticeSup α] (a b : α) : Ici (a ⊔ b) = Ici a ⊔ Ici b :=\n  ext Ici_inter_Ici.symm\n\n"}
{"name":"UpperSet.Ici_sSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nS : Set α\n⊢ Eq (UpperSet.Ici (SupSet.sSup S)) (iSup fun a => iSup fun h => UpperSet.Ici a)","decl":"@[simp]\ntheorem Ici_sSup (S : Set α) : Ici (sSup S) = ⨆ a ∈ S, Ici a :=\n  SetLike.ext fun c => by simp only [mem_Ici_iff, mem_iSup_iff, sSup_le_iff]\n\n"}
{"name":"UpperSet.Ici_iSup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\n⊢ Eq (UpperSet.Ici (iSup fun i => f i)) (iSup fun i => UpperSet.Ici (f i))","decl":"@[simp]\ntheorem Ici_iSup (f : ι → α) : Ici (⨆ i, f i) = ⨆ i, Ici (f i) :=\n  SetLike.ext fun c => by simp only [mem_Ici_iff, mem_iSup_iff, iSup_le_iff]\n\n-- Porting note: no longer a @[simp]\n"}
{"name":"UpperSet.Ici_iSup₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\n⊢ Eq (UpperSet.Ici (iSup fun i => iSup fun j => f i j)) (iSup fun i => iSup fun j => UpperSet.Ici (f i j))","decl":"theorem Ici_iSup₂ (f : ∀ i, κ i → α) : Ici (⨆ (i) (j), f i j) = ⨆ (i) (j), Ici (f i j) := by\n  simp_rw [Ici_iSup]\n\n"}
{"name":"LowerSet.coe_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (↑(LowerSet.Iic a)) (Set.Iic a)","decl":"@[simp]\ntheorem coe_Iic (a : α) : ↑(Iic a) = Set.Iic a :=\n  rfl\n\n"}
{"name":"LowerSet.coe_Iio","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (↑(LowerSet.Iio a)) (Set.Iio a)","decl":"@[simp]\ntheorem coe_Iio (a : α) : ↑(Iio a) = Set.Iio a :=\n  rfl\n\n"}
{"name":"LowerSet.mem_Iic_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (LowerSet.Iic a) b) (LE.le b a)","decl":"@[simp]\ntheorem mem_Iic_iff : b ∈ Iic a ↔ b ≤ a :=\n  Iff.rfl\n\n"}
{"name":"LowerSet.mem_Iio_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (LowerSet.Iio a) b) (LT.lt b a)","decl":"@[simp]\ntheorem mem_Iio_iff : b ∈ Iio a ↔ b < a :=\n  Iff.rfl\n\n"}
{"name":"LowerSet.map_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\na : α\n⊢ Eq ((LowerSet.map f) (LowerSet.Iic a)) (LowerSet.Iic (f a))","decl":"@[simp]\ntheorem map_Iic (f : α ≃o β) (a : α) : map f (Iic a) = Iic (f a) := by\n  ext\n  simp\n\n"}
{"name":"LowerSet.map_Iio","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\na : α\n⊢ Eq ((LowerSet.map f) (LowerSet.Iio a)) (LowerSet.Iio (f a))","decl":"@[simp]\ntheorem map_Iio (f : α ≃o β) (a : α) : map f (Iio a) = Iio (f a) := by\n  ext\n  simp\n\n"}
{"name":"LowerSet.Ioi_le_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ LE.le (Set.Ioi a) (Set.Ici a)","decl":"theorem Ioi_le_Ici (a : α) : Ioi a ≤ Ici a :=\n  Ioi_subset_Ici_self\n\n"}
{"name":"LowerSet.Iic_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ Eq (LowerSet.Iic Top.top) Top.top","decl":"@[simp]\nnonrec theorem Iic_top [OrderTop α] : Iic (⊤ : α) = ⊤ :=\n  SetLike.coe_injective Iic_top\n\n"}
{"name":"LowerSet.Iio_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ Eq (LowerSet.Iio Bot.bot) Bot.bot","decl":"@[simp]\nnonrec theorem Iio_bot [OrderBot α] : Iio (⊥ : α) = ⊥ :=\n  SetLike.coe_injective Iio_bot\n\n"}
{"name":"LowerSet.Iic_ne_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Ne (LowerSet.Iic a) Bot.bot","decl":"@[simp] lemma Iic_ne_bot : Iic a ≠ ⊥ := SetLike.coe_ne_coe.1 nonempty_Iic.ne_empty\n"}
{"name":"LowerSet.bot_lt_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ LT.lt Bot.bot (LowerSet.Iic a)","decl":"@[simp] lemma bot_lt_Iic : ⊥ < Iic a := bot_lt_iff_ne_bot.2 Iic_ne_bot\n"}
{"name":"LowerSet.Iic_le","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\na : α\n⊢ Iff (LE.le (LowerSet.Iic a) s) (Membership.mem s a)","decl":"@[simp] lemma Iic_le : Iic a ≤ s ↔ a ∈ s := ⟨fun h ↦ h le_rfl, fun ha ↦ s.lower.Iic_subset ha⟩\n\n"}
{"name":"LowerSet.Iic_injective","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Function.Injective LowerSet.Iic","decl":"nonrec lemma Iic_injective : Injective (Iic : α → LowerSet α) := fun _a _b hab ↦\n  Iic_injective <| congr_arg ((↑) : _ → Set α) hab\n\n"}
{"name":"LowerSet.Iic_inj","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Eq (LowerSet.Iic a) (LowerSet.Iic b)) (Eq a b)","decl":"@[simp] lemma Iic_inj : Iic a = Iic b ↔ a = b := Iic_injective.eq_iff\n\n"}
{"name":"LowerSet.Iic_ne_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Ne (LowerSet.Iic a) (LowerSet.Iic b)) (Ne a b)","decl":"lemma Iic_ne_Iic : Iic a ≠ Iic b ↔ a ≠ b := Iic_inj.not\n\n"}
{"name":"LowerSet.Iic_inf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : SemilatticeInf α\na b : α\n⊢ Eq (LowerSet.Iic (Min.min a b)) (Min.min (LowerSet.Iic a) (LowerSet.Iic b))","decl":"@[simp]\ntheorem Iic_inf [SemilatticeInf α] (a b : α) : Iic (a ⊓ b) = Iic a ⊓ Iic b :=\n  SetLike.coe_injective Iic_inter_Iic.symm\n\n"}
{"name":"LowerSet.Iic_sInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nS : Set α\n⊢ Eq (LowerSet.Iic (InfSet.sInf S)) (iInf fun a => iInf fun h => LowerSet.Iic a)","decl":"@[simp]\ntheorem Iic_sInf (S : Set α) : Iic (sInf S) = ⨅ a ∈ S, Iic a :=\n  SetLike.ext fun c => by simp only [mem_Iic_iff, mem_iInf₂_iff, le_sInf_iff]\n\n"}
{"name":"LowerSet.Iic_iInf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLattice α\nf : ι → α\n⊢ Eq (LowerSet.Iic (iInf fun i => f i)) (iInf fun i => LowerSet.Iic (f i))","decl":"@[simp]\ntheorem Iic_iInf (f : ι → α) : Iic (⨅ i, f i) = ⨅ i, Iic (f i) :=\n  SetLike.ext fun c => by simp only [mem_Iic_iff, mem_iInf_iff, le_iInf_iff]\n\n-- Porting note: no longer a @[simp]\n"}
{"name":"LowerSet.Iic_iInf₂","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\n⊢ Eq (LowerSet.Iic (iInf fun i => iInf fun j => f i j)) (iInf fun i => iInf fun j => LowerSet.Iic (f i j))","decl":"theorem Iic_iInf₂ (f : ∀ i, κ i → α) : Iic (⨅ (i) (j), f i j) = ⨅ (i) (j), Iic (f i j) := by\n  simp_rw [Iic_iInf]\n\n"}
{"name":"mem_upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nx : α\n⊢ Iff (Membership.mem (upperClosure s) x) (Exists fun a => And (Membership.mem s a) (LE.le a x))","decl":"@[simp]\ntheorem mem_upperClosure : x ∈ upperClosure s ↔ ∃ a ∈ s, a ≤ x :=\n  Iff.rfl\n\n"}
{"name":"mem_lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nx : α\n⊢ Iff (Membership.mem (lowerClosure s) x) (Exists fun a => And (Membership.mem s a) (LE.le x a))","decl":"@[simp]\ntheorem mem_lowerClosure : x ∈ lowerClosure s ↔ ∃ a ∈ s, x ≤ a :=\n  Iff.rfl\n\n-- We do not tag those two as `simp` to respect the abstraction.\n"}
{"name":"coe_upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Eq (↑(upperClosure s)) (Set.iUnion fun a => Set.iUnion fun h => Set.Ici a)","decl":"@[norm_cast]\ntheorem coe_upperClosure (s : Set α) : ↑(upperClosure s) = ⋃ a ∈ s, Ici a := by\n  ext\n  simp\n\n"}
{"name":"coe_lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Eq (↑(lowerClosure s)) (Set.iUnion fun a => Set.iUnion fun h => Set.Iic a)","decl":"@[norm_cast]\ntheorem coe_lowerClosure (s : Set α) : ↑(lowerClosure s) = ⋃ a ∈ s, Iic a := by\n  ext\n  simp\n\n"}
{"name":"subset_upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ HasSubset.Subset s ↑(upperClosure s)","decl":"theorem subset_upperClosure : s ⊆ upperClosure s := fun x hx => ⟨x, hx, le_rfl⟩\n\n"}
{"name":"subset_lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ HasSubset.Subset s ↑(lowerClosure s)","decl":"theorem subset_lowerClosure : s ⊆ lowerClosure s := fun x hx => ⟨x, hx, le_rfl⟩\n\n"}
{"name":"upperClosure_min","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nh : HasSubset.Subset s t\nht : IsUpperSet t\n⊢ HasSubset.Subset (↑(upperClosure s)) t","decl":"theorem upperClosure_min (h : s ⊆ t) (ht : IsUpperSet t) : ↑(upperClosure s) ⊆ t :=\n  fun _a ⟨_b, hb, hba⟩ => ht hba <| h hb\n\n"}
{"name":"lowerClosure_min","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nh : HasSubset.Subset s t\nht : IsLowerSet t\n⊢ HasSubset.Subset (↑(lowerClosure s)) t","decl":"theorem lowerClosure_min (h : s ⊆ t) (ht : IsLowerSet t) : ↑(lowerClosure s) ⊆ t :=\n  fun _a ⟨_b, hb, hab⟩ => ht hab <| h hb\n\n"}
{"name":"IsUpperSet.upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : IsUpperSet s\n⊢ Eq (↑(upperClosure s)) s","decl":"protected theorem IsUpperSet.upperClosure (hs : IsUpperSet s) : ↑(upperClosure s) = s :=\n  (upperClosure_min Subset.rfl hs).antisymm subset_upperClosure\n\n"}
{"name":"IsLowerSet.lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : IsLowerSet s\n⊢ Eq (↑(lowerClosure s)) s","decl":"protected theorem IsLowerSet.lowerClosure (hs : IsLowerSet s) : ↑(lowerClosure s) = s :=\n  (lowerClosure_min Subset.rfl hs).antisymm subset_lowerClosure\n\n"}
{"name":"UpperSet.upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\n⊢ Eq (upperClosure ↑s) s","decl":"@[simp]\nprotected theorem UpperSet.upperClosure (s : UpperSet α) : upperClosure (s : Set α) = s :=\n  SetLike.coe_injective s.2.upperClosure\n\n"}
{"name":"LowerSet.lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\n⊢ Eq (lowerClosure ↑s) s","decl":"@[simp]\nprotected theorem LowerSet.lowerClosure (s : LowerSet α) : lowerClosure (s : Set α) = s :=\n  SetLike.coe_injective s.2.lowerClosure\n\n"}
{"name":"upperClosure_image","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nf : OrderIso α β\n⊢ Eq (upperClosure (Set.image (⇑f) s)) ((UpperSet.map f) (upperClosure s))","decl":"@[simp]\ntheorem upperClosure_image (f : α ≃o β) :\n    upperClosure (f '' s) = UpperSet.map f (upperClosure s) := by\n  rw [← f.symm_symm, ← UpperSet.symm_map, f.symm_symm]\n  ext\n  simp [-UpperSet.symm_map, UpperSet.map, OrderIso.symm, ← f.le_symm_apply]\n\n"}
{"name":"lowerClosure_image","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nf : OrderIso α β\n⊢ Eq (lowerClosure (Set.image (⇑f) s)) ((LowerSet.map f) (lowerClosure s))","decl":"@[simp]\ntheorem lowerClosure_image (f : α ≃o β) :\n    lowerClosure (f '' s) = LowerSet.map f (lowerClosure s) := by\n  rw [← f.symm_symm, ← LowerSet.symm_map, f.symm_symm]\n  ext\n  simp [-LowerSet.symm_map, LowerSet.map, OrderIso.symm, ← f.symm_apply_le]\n\n"}
{"name":"UpperSet.iInf_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Eq (iInf fun a => iInf fun h => UpperSet.Ici a) (upperClosure s)","decl":"@[simp]\ntheorem UpperSet.iInf_Ici (s : Set α) : ⨅ a ∈ s, UpperSet.Ici a = upperClosure s := by\n  ext\n  simp\n\n"}
{"name":"LowerSet.iSup_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Eq (iSup fun a => iSup fun h => LowerSet.Iic a) (lowerClosure s)","decl":"@[simp]\ntheorem LowerSet.iSup_Iic (s : Set α) : ⨆ a ∈ s, LowerSet.Iic a = lowerClosure s := by\n  ext\n  simp\n\n"}
{"name":"lowerClosure_le","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nt : LowerSet α\n⊢ Iff (LE.le (lowerClosure s) t) (HasSubset.Subset s ↑t)","decl":"@[simp] lemma lowerClosure_le {t : LowerSet α} : lowerClosure s ≤ t ↔ s ⊆ t :=\n  ⟨fun h ↦ subset_lowerClosure.trans <| LowerSet.coe_subset_coe.2 h,\n    fun h ↦ lowerClosure_min h t.lower⟩\n\n"}
{"name":"le_upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Set α\ns : UpperSet α\n⊢ Iff (LE.le s (upperClosure t)) (HasSubset.Subset t ↑s)","decl":"@[simp] lemma le_upperClosure {s : UpperSet α} : s ≤ upperClosure t ↔ t ⊆ s :=\n  ⟨fun h ↦ subset_upperClosure.trans <| UpperSet.coe_subset_coe.2 h,\n    fun h ↦ upperClosure_min h s.upper⟩\n\n"}
{"name":"gc_upperClosure_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ GaloisConnection (Function.comp (⇑OrderDual.toDual) upperClosure) (Function.comp SetLike.coe ⇑OrderDual.ofDual)","decl":"theorem gc_upperClosure_coe :\n    GaloisConnection (toDual ∘ upperClosure : Set α → (UpperSet α)ᵒᵈ) ((↑) ∘ ofDual) :=\n  fun _s _t ↦ le_upperClosure\n\n"}
{"name":"gc_lowerClosure_coe","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ GaloisConnection lowerClosure SetLike.coe","decl":"theorem gc_lowerClosure_coe :\n    GaloisConnection (lowerClosure : Set α → LowerSet α) (↑) := fun _s _t ↦ lowerClosure_le\n\n"}
{"name":"upperClosure_anti","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Antitone upperClosure","decl":"theorem upperClosure_anti : Antitone (upperClosure : Set α → UpperSet α) :=\n  gc_upperClosure_coe.monotone_l\n\n"}
{"name":"lowerClosure_mono","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Monotone lowerClosure","decl":"theorem lowerClosure_mono : Monotone (lowerClosure : Set α → LowerSet α) :=\n  gc_lowerClosure_coe.monotone_l\n\n"}
{"name":"upperClosure_empty","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (upperClosure EmptyCollection.emptyCollection) Top.top","decl":"@[simp]\ntheorem upperClosure_empty : upperClosure (∅ : Set α) = ⊤ :=\n  (@gc_upperClosure_coe α).l_bot\n\n"}
{"name":"lowerClosure_empty","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (lowerClosure EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem lowerClosure_empty : lowerClosure (∅ : Set α) = ⊥ :=\n  (@gc_lowerClosure_coe α).l_bot\n\n"}
{"name":"upperClosure_singleton","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (upperClosure (Singleton.singleton a)) (UpperSet.Ici a)","decl":"@[simp]\ntheorem upperClosure_singleton (a : α) : upperClosure ({a} : Set α) = UpperSet.Ici a := by\n  ext\n  simp\n\n"}
{"name":"lowerClosure_singleton","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (lowerClosure (Singleton.singleton a)) (LowerSet.Iic a)","decl":"@[simp]\ntheorem lowerClosure_singleton (a : α) : lowerClosure ({a} : Set α) = LowerSet.Iic a := by\n  ext\n  simp\n\n"}
{"name":"upperClosure_univ","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (upperClosure Set.univ) Bot.bot","decl":"@[simp]\ntheorem upperClosure_univ : upperClosure (univ : Set α) = ⊥ :=\n  bot_unique subset_upperClosure\n\n"}
{"name":"lowerClosure_univ","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (lowerClosure Set.univ) Top.top","decl":"@[simp]\ntheorem lowerClosure_univ : lowerClosure (univ : Set α) = ⊤ :=\n  top_unique subset_lowerClosure\n\n"}
{"name":"upperClosure_eq_top_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Eq (upperClosure s) Top.top) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem upperClosure_eq_top_iff : upperClosure s = ⊤ ↔ s = ∅ :=\n  (@gc_upperClosure_coe α _).l_eq_bot.trans subset_empty_iff\n\n"}
{"name":"lowerClosure_eq_bot_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Eq (lowerClosure s) Bot.bot) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem lowerClosure_eq_bot_iff : lowerClosure s = ⊥ ↔ s = ∅ :=\n  (@gc_lowerClosure_coe α _).l_eq_bot.trans subset_empty_iff\n\n"}
{"name":"upperClosure_union","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\n⊢ Eq (upperClosure (Union.union s t)) (Min.min (upperClosure s) (upperClosure t))","decl":"@[simp]\ntheorem upperClosure_union (s t : Set α) : upperClosure (s ∪ t) = upperClosure s ⊓ upperClosure t :=\n  (@gc_upperClosure_coe α _).l_sup\n\n"}
{"name":"lowerClosure_union","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\n⊢ Eq (lowerClosure (Union.union s t)) (Max.max (lowerClosure s) (lowerClosure t))","decl":"@[simp]\ntheorem lowerClosure_union (s t : Set α) : lowerClosure (s ∪ t) = lowerClosure s ⊔ lowerClosure t :=\n  (@gc_lowerClosure_coe α _).l_sup\n\n"}
{"name":"upperClosure_iUnion","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : Preorder α\nf : ι → Set α\n⊢ Eq (upperClosure (Set.iUnion fun i => f i)) (iInf fun i => upperClosure (f i))","decl":"@[simp]\ntheorem upperClosure_iUnion (f : ι → Set α) : upperClosure (⋃ i, f i) = ⨅ i, upperClosure (f i) :=\n  (@gc_upperClosure_coe α _).l_iSup\n\n"}
{"name":"lowerClosure_iUnion","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : Preorder α\nf : ι → Set α\n⊢ Eq (lowerClosure (Set.iUnion fun i => f i)) (iSup fun i => lowerClosure (f i))","decl":"@[simp]\ntheorem lowerClosure_iUnion (f : ι → Set α) : lowerClosure (⋃ i, f i) = ⨆ i, lowerClosure (f i) :=\n  (@gc_lowerClosure_coe α _).l_iSup\n\n"}
{"name":"upperClosure_sUnion","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nS : Set (Set α)\n⊢ Eq (upperClosure S.sUnion) (iInf fun s => iInf fun h => upperClosure s)","decl":"@[simp]\ntheorem upperClosure_sUnion (S : Set (Set α)) : upperClosure (⋃₀ S) = ⨅ s ∈ S, upperClosure s := by\n  simp_rw [sUnion_eq_biUnion, upperClosure_iUnion]\n\n"}
{"name":"lowerClosure_sUnion","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nS : Set (Set α)\n⊢ Eq (lowerClosure S.sUnion) (iSup fun s => iSup fun h => lowerClosure s)","decl":"@[simp]\ntheorem lowerClosure_sUnion (S : Set (Set α)) : lowerClosure (⋃₀ S) = ⨆ s ∈ S, lowerClosure s := by\n  simp_rw [sUnion_eq_biUnion, lowerClosure_iUnion]\n\n"}
{"name":"Set.OrdConnected.upperClosure_inter_lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nh : s.OrdConnected\n⊢ Eq (Inter.inter ↑(upperClosure s) ↑(lowerClosure s)) s","decl":"theorem Set.OrdConnected.upperClosure_inter_lowerClosure (h : s.OrdConnected) :\n    ↑(upperClosure s) ∩ ↑(lowerClosure s) = s :=\n  (subset_inter subset_upperClosure subset_lowerClosure).antisymm'\n    fun _a ⟨⟨_b, hb, hba⟩, _c, hc, hac⟩ => h.out hb hc ⟨hba, hac⟩\n\n"}
{"name":"ordConnected_iff_upperClosure_inter_lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff s.OrdConnected (Eq (Inter.inter ↑(upperClosure s) ↑(lowerClosure s)) s)","decl":"theorem ordConnected_iff_upperClosure_inter_lowerClosure :\n    s.OrdConnected ↔ ↑(upperClosure s) ∩ ↑(lowerClosure s) = s := by\n  refine ⟨Set.OrdConnected.upperClosure_inter_lowerClosure, fun h => ?_⟩\n  rw [← h]\n  exact (UpperSet.upper _).ordConnected.inter (LowerSet.lower _).ordConnected\n\n"}
{"name":"upperBounds_lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Eq (upperBounds ↑(lowerClosure s)) (upperBounds s)","decl":"@[simp]\ntheorem upperBounds_lowerClosure : upperBounds (lowerClosure s : Set α) = upperBounds s :=\n  (upperBounds_mono_set subset_lowerClosure).antisymm\n    fun _a ha _b ⟨_c, hc, hcb⟩ ↦ hcb.trans <| ha hc\n\n"}
{"name":"lowerBounds_upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Eq (lowerBounds ↑(upperClosure s)) (lowerBounds s)","decl":"@[simp]\ntheorem lowerBounds_upperClosure : lowerBounds (upperClosure s : Set α) = lowerBounds s :=\n  (lowerBounds_mono_set subset_upperClosure).antisymm\n    fun _a ha _b ⟨_c, hc, hcb⟩ ↦ (ha hc).trans hcb\n\n"}
{"name":"bddAbove_lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (BddAbove ↑(lowerClosure s)) (BddAbove s)","decl":"@[simp]\ntheorem bddAbove_lowerClosure : BddAbove (lowerClosure s : Set α) ↔ BddAbove s := by\n  simp_rw [BddAbove, upperBounds_lowerClosure]\n\n"}
{"name":"bddBelow_upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (BddBelow ↑(upperClosure s)) (BddBelow s)","decl":"@[simp]\ntheorem bddBelow_upperClosure : BddBelow (upperClosure s : Set α) ↔ BddBelow s := by\n  simp_rw [BddBelow, lowerBounds_upperClosure]\n\n"}
{"name":"BddAbove.lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝ : BddAbove s\n⊢ BddAbove ↑(lowerClosure s)","decl":"protected alias ⟨BddAbove.of_lowerClosure, BddAbove.lowerClosure⟩ := bddAbove_lowerClosure\n\n"}
{"name":"BddAbove.of_lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝ : BddAbove ↑(lowerClosure s)\n⊢ BddAbove s","decl":"protected alias ⟨BddAbove.of_lowerClosure, BddAbove.lowerClosure⟩ := bddAbove_lowerClosure\n\n"}
{"name":"BddBelow.of_upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝ : BddBelow ↑(upperClosure s)\n⊢ BddBelow s","decl":"protected alias ⟨BddBelow.of_upperClosure, BddBelow.upperClosure⟩ := bddBelow_upperClosure\n\n"}
{"name":"BddBelow.upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝ : BddBelow s\n⊢ BddBelow ↑(upperClosure s)","decl":"protected alias ⟨BddBelow.of_upperClosure, BddBelow.upperClosure⟩ := bddBelow_upperClosure\n\n"}
{"name":"IsLowerSet.disjoint_upperClosure_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nht : IsLowerSet t\n⊢ Iff (Disjoint (↑(upperClosure s)) t) (Disjoint s t)","decl":"@[simp] lemma IsLowerSet.disjoint_upperClosure_left (ht : IsLowerSet t) :\n    Disjoint ↑(upperClosure s) t ↔ Disjoint s t := by\n  refine ⟨Disjoint.mono_left subset_upperClosure, ?_⟩\n  simp only [disjoint_left, SetLike.mem_coe, mem_upperClosure, forall_exists_index, and_imp]\n  exact fun h a b hb hba ha ↦ h hb <| ht hba ha\n\n"}
{"name":"IsLowerSet.disjoint_upperClosure_right","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nhs : IsLowerSet s\n⊢ Iff (Disjoint s ↑(upperClosure t)) (Disjoint s t)","decl":"@[simp] lemma IsLowerSet.disjoint_upperClosure_right (hs : IsLowerSet s) :\n    Disjoint s (upperClosure t) ↔ Disjoint s t := by\n  simpa only [disjoint_comm] using hs.disjoint_upperClosure_left\n\n"}
{"name":"IsUpperSet.disjoint_lowerClosure_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nht : IsUpperSet t\n⊢ Iff (Disjoint (↑(lowerClosure s)) t) (Disjoint s t)","decl":"@[simp] lemma IsUpperSet.disjoint_lowerClosure_left (ht : IsUpperSet t) :\n    Disjoint ↑(lowerClosure s) t ↔ Disjoint s t := ht.toDual.disjoint_upperClosure_left\n\n"}
{"name":"IsUpperSet.disjoint_lowerClosure_right","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nhs : IsUpperSet s\n⊢ Iff (Disjoint s ↑(lowerClosure t)) (Disjoint s t)","decl":"@[simp] lemma IsUpperSet.disjoint_lowerClosure_right (hs : IsUpperSet s) :\n    Disjoint s (lowerClosure t) ↔ Disjoint s t := hs.toDual.disjoint_upperClosure_right\n\n"}
{"name":"upperClosure_eq","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Eq (↑(upperClosure s)) s) (IsUpperSet s)","decl":"@[simp] lemma upperClosure_eq :\n    ↑(upperClosure s) = s ↔ IsUpperSet s :=\n  ⟨(· ▸ UpperSet.upper _), IsUpperSet.upperClosure⟩\n\n"}
{"name":"lowerClosure_eq","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Eq (↑(lowerClosure s)) s) (IsLowerSet s)","decl":"@[simp] lemma lowerClosure_eq :\n    ↑(lowerClosure s) = s ↔ IsLowerSet s :=\n  @upperClosure_eq αᵒᵈ _ _\n\n"}
{"name":"LowerSet.coe_sdiff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\nt : Set α\n⊢ Eq (↑(s.sdiff t)) (SDiff.sdiff ↑s ↑(upperClosure t))","decl":"@[simp, norm_cast]\nlemma coe_sdiff (s : LowerSet α) (t : Set α) : s.sdiff t = (s : Set α) \\ upperClosure t := rfl\n\n"}
{"name":"LowerSet.coe_erase","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\na : α\n⊢ Eq (↑(s.erase a)) (SDiff.sdiff ↑s ↑(UpperSet.Ici a))","decl":"@[simp, norm_cast]\nlemma coe_erase (s : LowerSet α) (a : α) : s.erase a = (s : Set α) \\ UpperSet.Ici a := rfl\n\n"}
{"name":"LowerSet.sdiff_singleton","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\na : α\n⊢ Eq (s.sdiff (Singleton.singleton a)) (s.erase a)","decl":"@[simp] lemma sdiff_singleton (s : LowerSet α) (a : α) : s.sdiff {a} = s.erase a := by\n  simp [sdiff, erase]\n\n"}
{"name":"LowerSet.sdiff_le_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\nt : Set α\n⊢ LE.le (s.sdiff t) s","decl":"lemma sdiff_le_left : s.sdiff t ≤ s := diff_subset\n"}
{"name":"LowerSet.erase_le","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\na : α\n⊢ LE.le (s.erase a) s","decl":"lemma erase_le : s.erase a ≤ s := diff_subset\n\n"}
{"name":"LowerSet.sdiff_eq_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\nt : Set α\n⊢ Iff (Eq (s.sdiff t) s) (Disjoint (↑s) t)","decl":"@[simp] protected lemma sdiff_eq_left : s.sdiff t = s ↔ Disjoint ↑s t := by\n  simp [← SetLike.coe_set_eq]\n\n"}
{"name":"LowerSet.erase_eq","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\na : α\n⊢ Iff (Eq (s.erase a) s) (Not (Membership.mem s a))","decl":"@[simp] lemma erase_eq : s.erase a = s ↔ a ∉ s := by rw [← sdiff_singleton]; simp [-sdiff_singleton]\n\n"}
{"name":"LowerSet.sdiff_lt_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\nt : Set α\n⊢ Iff (LT.lt (s.sdiff t) s) (Not (Disjoint (↑s) t))","decl":"@[simp] lemma sdiff_lt_left : s.sdiff t < s ↔ ¬ Disjoint ↑s t :=\n  sdiff_le_left.lt_iff_ne.trans LowerSet.sdiff_eq_left.not\n\n"}
{"name":"LowerSet.erase_lt","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\na : α\n⊢ Iff (LT.lt (s.erase a) s) (Membership.mem s a)","decl":"@[simp] lemma erase_lt : s.erase a < s ↔ a ∈ s := erase_le.lt_iff_ne.trans erase_eq.not_left\n\n"}
{"name":"LowerSet.sdiff_idem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\nt : Set α\n⊢ Eq ((s.sdiff t).sdiff t) (s.sdiff t)","decl":"@[simp] protected lemma sdiff_idem (s : LowerSet α) (t : Set α) : (s.sdiff t).sdiff t = s.sdiff t :=\n  SetLike.coe_injective sdiff_idem\n\n"}
{"name":"LowerSet.erase_idem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\na : α\n⊢ Eq ((s.erase a).erase a) (s.erase a)","decl":"@[simp] lemma erase_idem (s : LowerSet α) (a : α) : (s.erase a).erase a = s.erase a :=\n  SetLike.coe_injective sdiff_idem\n\n"}
{"name":"LowerSet.sdiff_sup_lowerClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\nt : Set α\nhts : HasSubset.Subset t ↑s\nhst : ∀ (b : α), Membership.mem s b → ∀ (c : α), Membership.mem t c → LE.le c b → Membership.mem t b\n⊢ Eq (Max.max (s.sdiff t) (lowerClosure t)) s","decl":"lemma sdiff_sup_lowerClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :\n    s.sdiff t ⊔ lowerClosure t = s := by\n  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ↦ ?_\n  obtain hat | hat := em (a ∈ t)\n  · exact subset_union_right (subset_lowerClosure hat)\n  · refine subset_union_left ⟨ha, ?_⟩\n    rintro ⟨b, hb, hba⟩\n    exact hat <| hst _ ha _ hb hba\n\n"}
{"name":"LowerSet.lowerClosure_sup_sdiff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\nt : Set α\nhts : HasSubset.Subset t ↑s\nhst : ∀ (b : α), Membership.mem s b → ∀ (c : α), Membership.mem t c → LE.le c b → Membership.mem t b\n⊢ Eq (Max.max (lowerClosure t) (s.sdiff t)) s","decl":"lemma lowerClosure_sup_sdiff (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, c ≤ b → b ∈ t) :\n    lowerClosure t ⊔ s.sdiff t = s := by rw [sup_comm, sdiff_sup_lowerClosure hts hst]\n\n"}
{"name":"LowerSet.erase_sup_Iic","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\na : α\nha : Membership.mem s a\nhas : ∀ (b : α), Membership.mem s b → LE.le a b → Eq b a\n⊢ Eq (Max.max (s.erase a) (LowerSet.Iic a)) s","decl":"lemma erase_sup_Iic (ha : a ∈ s) (has : ∀ b ∈ s, a ≤ b → b = a) : s.erase a ⊔ Iic a = s := by\n  rw [← lowerClosure_singleton, ← sdiff_singleton, sdiff_sup_lowerClosure] <;> simpa\n\n"}
{"name":"LowerSet.Iic_sup_erase","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : LowerSet α\na : α\nha : Membership.mem s a\nhas : ∀ (b : α), Membership.mem s b → LE.le a b → Eq b a\n⊢ Eq (Max.max (LowerSet.Iic a) (s.erase a)) s","decl":"lemma Iic_sup_erase (ha : a ∈ s) (has : ∀ b ∈ s, a ≤ b → b = a) : Iic a ⊔ s.erase a = s := by\n  rw [sup_comm, erase_sup_Iic ha has]\n\n"}
{"name":"UpperSet.coe_sdiff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\nt : Set α\n⊢ Eq (↑(s.sdiff t)) (SDiff.sdiff ↑s ↑(lowerClosure t))","decl":"@[simp, norm_cast]\nlemma coe_sdiff (s : UpperSet α) (t : Set α) : s.sdiff t = (s : Set α) \\ lowerClosure t := rfl\n\n"}
{"name":"UpperSet.coe_erase","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\na : α\n⊢ Eq (↑(s.erase a)) (SDiff.sdiff ↑s ↑(LowerSet.Iic a))","decl":"@[simp, norm_cast]\nlemma coe_erase (s : UpperSet α) (a : α) : s.erase a = (s : Set α) \\ LowerSet.Iic a := rfl\n\n"}
{"name":"UpperSet.sdiff_singleton","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\na : α\n⊢ Eq (s.sdiff (Singleton.singleton a)) (s.erase a)","decl":"@[simp] lemma sdiff_singleton (s : UpperSet α) (a : α) : s.sdiff {a} = s.erase a := by\n  simp [sdiff, erase]\n\n"}
{"name":"UpperSet.le_sdiff_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\nt : Set α\n⊢ LE.le s (s.sdiff t)","decl":"lemma le_sdiff_left : s ≤ s.sdiff t := diff_subset\n"}
{"name":"UpperSet.le_erase","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\na : α\n⊢ LE.le s (s.erase a)","decl":"lemma le_erase : s ≤ s.erase a := diff_subset\n\n"}
{"name":"UpperSet.sdiff_eq_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\nt : Set α\n⊢ Iff (Eq (s.sdiff t) s) (Disjoint (↑s) t)","decl":"@[simp] protected lemma sdiff_eq_left : s.sdiff t = s ↔ Disjoint ↑s t := by\n  simp [← SetLike.coe_set_eq]\n\n"}
{"name":"UpperSet.erase_eq","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\na : α\n⊢ Iff (Eq (s.erase a) s) (Not (Membership.mem s a))","decl":"@[simp] lemma erase_eq : s.erase a = s ↔ a ∉ s := by rw [← sdiff_singleton]; simp [-sdiff_singleton]\n\n"}
{"name":"UpperSet.lt_sdiff_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\nt : Set α\n⊢ Iff (LT.lt s (s.sdiff t)) (Not (Disjoint (↑s) t))","decl":"@[simp] lemma lt_sdiff_left : s < s.sdiff t ↔ ¬ Disjoint ↑s t :=\n  le_sdiff_left.gt_iff_ne.trans UpperSet.sdiff_eq_left.not\n\n"}
{"name":"UpperSet.lt_erase","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\na : α\n⊢ Iff (LT.lt s (s.erase a)) (Membership.mem s a)","decl":"@[simp] lemma lt_erase : s < s.erase a ↔ a ∈ s := le_erase.gt_iff_ne.trans erase_eq.not_left\n\n"}
{"name":"UpperSet.sdiff_idem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\nt : Set α\n⊢ Eq ((s.sdiff t).sdiff t) (s.sdiff t)","decl":"@[simp] protected lemma sdiff_idem (s : UpperSet α) (t : Set α) : (s.sdiff t).sdiff t = s.sdiff t :=\n  SetLike.coe_injective sdiff_idem\n\n"}
{"name":"UpperSet.erase_idem","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\na : α\n⊢ Eq ((s.erase a).erase a) (s.erase a)","decl":"@[simp] lemma erase_idem (s : UpperSet α) (a : α) : (s.erase a).erase a = s.erase a :=\n  SetLike.coe_injective sdiff_idem\n\n"}
{"name":"UpperSet.sdiff_inf_upperClosure","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\nt : Set α\nhts : HasSubset.Subset t ↑s\nhst : ∀ (b : α), Membership.mem s b → ∀ (c : α), Membership.mem t c → LE.le b c → Membership.mem t b\n⊢ Eq (Min.min (s.sdiff t) (upperClosure t)) s","decl":"lemma sdiff_inf_upperClosure (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, b ≤ c → b ∈ t) :\n    s.sdiff t ⊓ upperClosure t = s := by\n  refine ge_antisymm (le_inf le_sdiff_left <| le_upperClosure.2 hts) fun a ha ↦ ?_\n  obtain hat | hat := em (a ∈ t)\n  · exact subset_union_right (subset_upperClosure hat)\n  · refine subset_union_left ⟨ha, ?_⟩\n    rintro ⟨b, hb, hab⟩\n    exact hat <| hst _ ha _ hb hab\n\n"}
{"name":"UpperSet.upperClosure_inf_sdiff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\nt : Set α\nhts : HasSubset.Subset t ↑s\nhst : ∀ (b : α), Membership.mem s b → ∀ (c : α), Membership.mem t c → LE.le b c → Membership.mem t b\n⊢ Eq (Min.min (upperClosure t) (s.sdiff t)) s","decl":"lemma upperClosure_inf_sdiff (hts : t ⊆ s) (hst : ∀ b ∈ s, ∀ c ∈ t, b ≤ c → b ∈ t) :\n    upperClosure t ⊓ s.sdiff t = s := by rw [inf_comm, sdiff_inf_upperClosure hts hst]\n\n"}
{"name":"UpperSet.erase_inf_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\na : α\nha : Membership.mem s a\nhas : ∀ (b : α), Membership.mem s b → LE.le b a → Eq b a\n⊢ Eq (Min.min (s.erase a) (UpperSet.Ici a)) s","decl":"lemma erase_inf_Ici (ha : a ∈ s) (has : ∀ b ∈ s, b ≤ a → b = a) : s.erase a ⊓ Ici a = s := by\n  rw [← upperClosure_singleton, ← sdiff_singleton, sdiff_inf_upperClosure] <;> simpa\n\n"}
{"name":"UpperSet.Ici_inf_erase","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : UpperSet α\na : α\nha : Membership.mem s a\nhas : ∀ (b : α), Membership.mem s b → LE.le b a → Eq b a\n⊢ Eq (Min.min (UpperSet.Ici a) (s.erase a)) s","decl":"lemma Ici_inf_erase (ha : a ∈ s) (has : ∀ b ∈ s, b ≤ a → b = a) : Ici a ⊓ s.erase a = s := by\n  rw [inf_comm, erase_inf_Ici ha has]\n\n"}
{"name":"IsUpperSet.prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nt : Set β\nhs : IsUpperSet s\nht : IsUpperSet t\n⊢ IsUpperSet (SProd.sprod s t)","decl":"theorem IsUpperSet.prod (hs : IsUpperSet s) (ht : IsUpperSet t) : IsUpperSet (s ×ˢ t) :=\n  fun _ _ h ha => ⟨hs h.1 ha.1, ht h.2 ha.2⟩\n\n"}
{"name":"IsLowerSet.prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nt : Set β\nhs : IsLowerSet s\nht : IsLowerSet t\n⊢ IsLowerSet (SProd.sprod s t)","decl":"theorem IsLowerSet.prod (hs : IsLowerSet s) (ht : IsLowerSet t) : IsLowerSet (s ×ˢ t) :=\n  fun _ _ h ha => ⟨hs h.1 ha.1, ht h.2 ha.2⟩\n\n"}
{"name":"UpperSet.coe_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : UpperSet α\nt : UpperSet β\n⊢ Eq (↑(SProd.sprod s t)) (SProd.sprod ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_prod : ((s ×ˢ t : UpperSet (α × β)) : Set (α × β)) = (s : Set α) ×ˢ t :=\n  rfl\n\n"}
{"name":"UpperSet.mem_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\ns : UpperSet α\nt : UpperSet β\n⊢ Iff (Membership.mem (SProd.sprod s t) x) (And (Membership.mem s x.1) (Membership.mem t x.2))","decl":"@[simp]\ntheorem mem_prod {s : UpperSet α} {t : UpperSet β} : x ∈ s ×ˢ t ↔ x.1 ∈ s ∧ x.2 ∈ t :=\n  Iff.rfl\n\n"}
{"name":"UpperSet.Ici_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\n⊢ Eq (UpperSet.Ici x) (SProd.sprod (UpperSet.Ici x.1) (UpperSet.Ici x.2))","decl":"theorem Ici_prod (x : α × β) : Ici x = Ici x.1 ×ˢ Ici x.2 :=\n  rfl\n\n"}
{"name":"UpperSet.Ici_prod_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb : β\n⊢ Eq (SProd.sprod (UpperSet.Ici a) (UpperSet.Ici b)) (UpperSet.Ici { fst := a, snd := b })","decl":"@[simp]\ntheorem Ici_prod_Ici (a : α) (b : β) : Ici a ×ˢ Ici b = Ici (a, b) :=\n  rfl\n\n"}
{"name":"UpperSet.prod_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : UpperSet α\n⊢ Eq (SProd.sprod s Top.top) Top.top","decl":"@[simp]\ntheorem prod_top : s ×ˢ (⊤ : UpperSet β) = ⊤ :=\n  ext prod_empty\n\n"}
{"name":"UpperSet.top_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nt : UpperSet β\n⊢ Eq (SProd.sprod Top.top t) Top.top","decl":"@[simp]\ntheorem top_prod : (⊤ : UpperSet α) ×ˢ t = ⊤ :=\n  ext empty_prod\n\n"}
{"name":"UpperSet.bot_prod_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Eq (SProd.sprod Bot.bot Bot.bot) Bot.bot","decl":"@[simp]\ntheorem bot_prod_bot : (⊥ : UpperSet α) ×ˢ (⊥ : UpperSet β) = ⊥ :=\n  ext univ_prod_univ\n\n"}
{"name":"UpperSet.sup_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : UpperSet α\nt : UpperSet β\n⊢ Eq (SProd.sprod (Max.max s₁ s₂) t) (Max.max (SProd.sprod s₁ t) (SProd.sprod s₂ t))","decl":"@[simp]\ntheorem sup_prod : (s₁ ⊔ s₂) ×ˢ t = s₁ ×ˢ t ⊔ s₂ ×ˢ t :=\n  ext inter_prod\n\n"}
{"name":"UpperSet.prod_sup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : UpperSet α\nt₁ t₂ : UpperSet β\n⊢ Eq (SProd.sprod s (Max.max t₁ t₂)) (Max.max (SProd.sprod s t₁) (SProd.sprod s t₂))","decl":"@[simp]\ntheorem prod_sup : s ×ˢ (t₁ ⊔ t₂) = s ×ˢ t₁ ⊔ s ×ˢ t₂ :=\n  ext prod_inter\n\n"}
{"name":"UpperSet.inf_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : UpperSet α\nt : UpperSet β\n⊢ Eq (SProd.sprod (Min.min s₁ s₂) t) (Min.min (SProd.sprod s₁ t) (SProd.sprod s₂ t))","decl":"@[simp]\ntheorem inf_prod : (s₁ ⊓ s₂) ×ˢ t = s₁ ×ˢ t ⊓ s₂ ×ˢ t :=\n  ext union_prod\n\n"}
{"name":"UpperSet.prod_inf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : UpperSet α\nt₁ t₂ : UpperSet β\n⊢ Eq (SProd.sprod s (Min.min t₁ t₂)) (Min.min (SProd.sprod s t₁) (SProd.sprod s t₂))","decl":"@[simp]\ntheorem prod_inf : s ×ˢ (t₁ ⊓ t₂) = s ×ˢ t₁ ⊓ s ×ˢ t₂ :=\n  ext prod_union\n\n"}
{"name":"UpperSet.prod_sup_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : UpperSet α\nt₁ t₂ : UpperSet β\n⊢ Eq (Max.max (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (SProd.sprod (Max.max s₁ s₂) (Max.max t₁ t₂))","decl":"theorem prod_sup_prod : s₁ ×ˢ t₁ ⊔ s₂ ×ˢ t₂ = (s₁ ⊔ s₂) ×ˢ (t₁ ⊔ t₂) :=\n  ext prod_inter_prod\n\n"}
{"name":"UpperSet.prod_mono","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : UpperSet α\nt₁ t₂ : UpperSet β\na✝¹ : LE.le s₁ s₂\na✝ : LE.le t₁ t₂\n⊢ LE.le (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)","decl":"@[mono]\ntheorem prod_mono : s₁ ≤ s₂ → t₁ ≤ t₂ → s₁ ×ˢ t₁ ≤ s₂ ×ˢ t₂ :=\n  Set.prod_mono\n\n"}
{"name":"UpperSet.prod_mono_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : UpperSet α\nt : UpperSet β\na✝ : LE.le s₁ s₂\n⊢ LE.le (SProd.sprod s₁ t) (SProd.sprod s₂ t)","decl":"theorem prod_mono_left : s₁ ≤ s₂ → s₁ ×ˢ t ≤ s₂ ×ˢ t :=\n  Set.prod_mono_left\n\n"}
{"name":"UpperSet.prod_mono_right","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : UpperSet α\nt₁ t₂ : UpperSet β\na✝ : LE.le t₁ t₂\n⊢ LE.le (SProd.sprod s t₁) (SProd.sprod s t₂)","decl":"theorem prod_mono_right : t₁ ≤ t₂ → s ×ˢ t₁ ≤ s ×ˢ t₂ :=\n  Set.prod_mono_right\n\n"}
{"name":"UpperSet.prod_self_le_prod_self","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns₁ s₂ : UpperSet α\n⊢ Iff (LE.le (SProd.sprod s₁ s₁) (SProd.sprod s₂ s₂)) (LE.le s₁ s₂)","decl":"@[simp]\ntheorem prod_self_le_prod_self : s₁ ×ˢ s₁ ≤ s₂ ×ˢ s₂ ↔ s₁ ≤ s₂ :=\n  prod_self_subset_prod_self\n\n"}
{"name":"UpperSet.prod_self_lt_prod_self","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns₁ s₂ : UpperSet α\n⊢ Iff (LT.lt (SProd.sprod s₁ s₁) (SProd.sprod s₂ s₂)) (LT.lt s₁ s₂)","decl":"@[simp]\ntheorem prod_self_lt_prod_self : s₁ ×ˢ s₁ < s₂ ×ˢ s₂ ↔ s₁ < s₂ :=\n  prod_self_ssubset_prod_self\n\n"}
{"name":"UpperSet.prod_le_prod_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : UpperSet α\nt₁ t₂ : UpperSet β\n⊢ Iff (LE.le (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (Or (And (LE.le s₁ s₂) (LE.le t₁ t₂)) (Or (Eq s₂ Top.top) (Eq t₂ Top.top)))","decl":"theorem prod_le_prod_iff : s₁ ×ˢ t₁ ≤ s₂ ×ˢ t₂ ↔ s₁ ≤ s₂ ∧ t₁ ≤ t₂ ∨ s₂ = ⊤ ∨ t₂ = ⊤ :=\n  prod_subset_prod_iff.trans <| by simp\n\n"}
{"name":"UpperSet.prod_eq_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : UpperSet α\nt : UpperSet β\n⊢ Iff (Eq (SProd.sprod s t) Top.top) (Or (Eq s Top.top) (Eq t Top.top))","decl":"@[simp]\ntheorem prod_eq_top : s ×ˢ t = ⊤ ↔ s = ⊤ ∨ t = ⊤ := by\n  simp_rw [SetLike.ext'_iff]\n  exact prod_eq_empty_iff\n\n"}
{"name":"UpperSet.codisjoint_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : UpperSet α\nt₁ t₂ : UpperSet β\n⊢ Iff (Codisjoint (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (Or (Codisjoint s₁ s₂) (Codisjoint t₁ t₂))","decl":"@[simp]\ntheorem codisjoint_prod :\n    Codisjoint (s₁ ×ˢ t₁) (s₂ ×ˢ t₂) ↔ Codisjoint s₁ s₂ ∨ Codisjoint t₁ t₂ := by\n  simp_rw [codisjoint_iff, prod_sup_prod, prod_eq_top]\n\n"}
{"name":"LowerSet.coe_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : LowerSet α\nt : LowerSet β\n⊢ Eq (↑(SProd.sprod s t)) (SProd.sprod ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_prod : ((s ×ˢ t : LowerSet (α × β)) : Set (α × β)) = (s : Set α) ×ˢ t := rfl\n\n"}
{"name":"LowerSet.mem_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\ns : LowerSet α\nt : LowerSet β\n⊢ Iff (Membership.mem (SProd.sprod s t) x) (And (Membership.mem s x.1) (Membership.mem t x.2))","decl":"@[simp]\ntheorem mem_prod {s : LowerSet α} {t : LowerSet β} : x ∈ s ×ˢ t ↔ x.1 ∈ s ∧ x.2 ∈ t :=\n  Iff.rfl\n\n"}
{"name":"LowerSet.Iic_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : Prod α β\n⊢ Eq (LowerSet.Iic x) (SProd.sprod (LowerSet.Iic x.1) (LowerSet.Iic x.2))","decl":"theorem Iic_prod (x : α × β) : Iic x = Iic x.1 ×ˢ Iic x.2 :=\n  rfl\n\n"}
{"name":"LowerSet.Ici_prod_Ici","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb : β\n⊢ Eq (SProd.sprod (LowerSet.Iic a) (LowerSet.Iic b)) (LowerSet.Iic { fst := a, snd := b })","decl":"@[simp]\ntheorem Ici_prod_Ici (a : α) (b : β) : Iic a ×ˢ Iic b = Iic (a, b) :=\n  rfl\n\n"}
{"name":"LowerSet.prod_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : LowerSet α\n⊢ Eq (SProd.sprod s Bot.bot) Bot.bot","decl":"@[simp]\ntheorem prod_bot : s ×ˢ (⊥ : LowerSet β) = ⊥ :=\n  ext prod_empty\n\n"}
{"name":"LowerSet.bot_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nt : LowerSet β\n⊢ Eq (SProd.sprod Bot.bot t) Bot.bot","decl":"@[simp]\ntheorem bot_prod : (⊥ : LowerSet α) ×ˢ t = ⊥ :=\n  ext empty_prod\n\n"}
{"name":"LowerSet.top_prod_top","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Eq (SProd.sprod Top.top Top.top) Top.top","decl":"@[simp]\ntheorem top_prod_top : (⊤ : LowerSet α) ×ˢ (⊤ : LowerSet β) = ⊤ :=\n  ext univ_prod_univ\n\n"}
{"name":"LowerSet.inf_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : LowerSet α\nt : LowerSet β\n⊢ Eq (SProd.sprod (Min.min s₁ s₂) t) (Min.min (SProd.sprod s₁ t) (SProd.sprod s₂ t))","decl":"@[simp]\ntheorem inf_prod : (s₁ ⊓ s₂) ×ˢ t = s₁ ×ˢ t ⊓ s₂ ×ˢ t :=\n  ext inter_prod\n\n"}
{"name":"LowerSet.prod_inf","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : LowerSet α\nt₁ t₂ : LowerSet β\n⊢ Eq (SProd.sprod s (Min.min t₁ t₂)) (Min.min (SProd.sprod s t₁) (SProd.sprod s t₂))","decl":"@[simp]\ntheorem prod_inf : s ×ˢ (t₁ ⊓ t₂) = s ×ˢ t₁ ⊓ s ×ˢ t₂ :=\n  ext prod_inter\n\n"}
{"name":"LowerSet.sup_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : LowerSet α\nt : LowerSet β\n⊢ Eq (SProd.sprod (Max.max s₁ s₂) t) (Max.max (SProd.sprod s₁ t) (SProd.sprod s₂ t))","decl":"@[simp]\ntheorem sup_prod : (s₁ ⊔ s₂) ×ˢ t = s₁ ×ˢ t ⊔ s₂ ×ˢ t :=\n  ext union_prod\n\n"}
{"name":"LowerSet.prod_sup","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : LowerSet α\nt₁ t₂ : LowerSet β\n⊢ Eq (SProd.sprod s (Max.max t₁ t₂)) (Max.max (SProd.sprod s t₁) (SProd.sprod s t₂))","decl":"@[simp]\ntheorem prod_sup : s ×ˢ (t₁ ⊔ t₂) = s ×ˢ t₁ ⊔ s ×ˢ t₂ :=\n  ext prod_union\n\n"}
{"name":"LowerSet.prod_inf_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : LowerSet α\nt₁ t₂ : LowerSet β\n⊢ Eq (Min.min (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (SProd.sprod (Min.min s₁ s₂) (Min.min t₁ t₂))","decl":"theorem prod_inf_prod : s₁ ×ˢ t₁ ⊓ s₂ ×ˢ t₂ = (s₁ ⊓ s₂) ×ˢ (t₁ ⊓ t₂) :=\n  ext prod_inter_prod\n\n"}
{"name":"LowerSet.prod_mono","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : LowerSet α\nt₁ t₂ : LowerSet β\na✝¹ : LE.le s₁ s₂\na✝ : LE.le t₁ t₂\n⊢ LE.le (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)","decl":"theorem prod_mono : s₁ ≤ s₂ → t₁ ≤ t₂ → s₁ ×ˢ t₁ ≤ s₂ ×ˢ t₂ := Set.prod_mono\n\n"}
{"name":"LowerSet.prod_mono_left","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : LowerSet α\nt : LowerSet β\na✝ : LE.le s₁ s₂\n⊢ LE.le (SProd.sprod s₁ t) (SProd.sprod s₂ t)","decl":"theorem prod_mono_left : s₁ ≤ s₂ → s₁ ×ˢ t ≤ s₂ ×ˢ t := Set.prod_mono_left\n\n"}
{"name":"LowerSet.prod_mono_right","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : LowerSet α\nt₁ t₂ : LowerSet β\na✝ : LE.le t₁ t₂\n⊢ LE.le (SProd.sprod s t₁) (SProd.sprod s t₂)","decl":"theorem prod_mono_right : t₁ ≤ t₂ → s ×ˢ t₁ ≤ s ×ˢ t₂ := Set.prod_mono_right\n\n"}
{"name":"LowerSet.prod_self_le_prod_self","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns₁ s₂ : LowerSet α\n⊢ Iff (LE.le (SProd.sprod s₁ s₁) (SProd.sprod s₂ s₂)) (LE.le s₁ s₂)","decl":"@[simp]\ntheorem prod_self_le_prod_self : s₁ ×ˢ s₁ ≤ s₂ ×ˢ s₂ ↔ s₁ ≤ s₂ :=\n  prod_self_subset_prod_self\n\n"}
{"name":"LowerSet.prod_self_lt_prod_self","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns₁ s₂ : LowerSet α\n⊢ Iff (LT.lt (SProd.sprod s₁ s₁) (SProd.sprod s₂ s₂)) (LT.lt s₁ s₂)","decl":"@[simp]\ntheorem prod_self_lt_prod_self : s₁ ×ˢ s₁ < s₂ ×ˢ s₂ ↔ s₁ < s₂ :=\n  prod_self_ssubset_prod_self\n\n"}
{"name":"LowerSet.prod_le_prod_iff","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : LowerSet α\nt₁ t₂ : LowerSet β\n⊢ Iff (LE.le (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (Or (And (LE.le s₁ s₂) (LE.le t₁ t₂)) (Or (Eq s₁ Bot.bot) (Eq t₁ Bot.bot)))","decl":"theorem prod_le_prod_iff : s₁ ×ˢ t₁ ≤ s₂ ×ˢ t₂ ↔ s₁ ≤ s₂ ∧ t₁ ≤ t₂ ∨ s₁ = ⊥ ∨ t₁ = ⊥ :=\n  prod_subset_prod_iff.trans <| by simp\n\n"}
{"name":"LowerSet.prod_eq_bot","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : LowerSet α\nt : LowerSet β\n⊢ Iff (Eq (SProd.sprod s t) Bot.bot) (Or (Eq s Bot.bot) (Eq t Bot.bot))","decl":"@[simp]\ntheorem prod_eq_bot : s ×ˢ t = ⊥ ↔ s = ⊥ ∨ t = ⊥ := by\n  simp_rw [SetLike.ext'_iff]\n  exact prod_eq_empty_iff\n\n"}
{"name":"LowerSet.disjoint_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns₁ s₂ : LowerSet α\nt₁ t₂ : LowerSet β\n⊢ Iff (Disjoint (SProd.sprod s₁ t₁) (SProd.sprod s₂ t₂)) (Or (Disjoint s₁ s₂) (Disjoint t₁ t₂))","decl":"@[simp]\ntheorem disjoint_prod : Disjoint (s₁ ×ˢ t₁) (s₂ ×ˢ t₂) ↔ Disjoint s₁ s₂ ∨ Disjoint t₁ t₂ := by\n  simp_rw [disjoint_iff, prod_inf_prod, prod_eq_bot]\n\n"}
{"name":"upperClosure_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nt : Set β\n⊢ Eq (upperClosure (SProd.sprod s t)) (SProd.sprod (upperClosure s) (upperClosure t))","decl":"@[simp]\ntheorem upperClosure_prod (s : Set α) (t : Set β) :\n    upperClosure (s ×ˢ t) = upperClosure s ×ˢ upperClosure t := by\n  ext\n  simp [Prod.le_def, @and_and_and_comm _ (_ ∈ t)]\n\n"}
{"name":"lowerClosure_prod","module":"Mathlib.Order.UpperLower.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nt : Set β\n⊢ Eq (lowerClosure (SProd.sprod s t)) (SProd.sprod (lowerClosure s) (lowerClosure t))","decl":"@[simp]\ntheorem lowerClosure_prod (s : Set α) (t : Set β) :\n    lowerClosure (s ×ˢ t) = lowerClosure s ×ˢ lowerClosure t := by\n  ext\n  simp [Prod.le_def, @and_and_and_comm _ (_ ∈ t)]\n\n"}
