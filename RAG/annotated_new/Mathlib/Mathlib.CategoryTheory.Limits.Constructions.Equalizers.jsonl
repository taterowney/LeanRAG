{"name":"CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.pullbackFst_eq_pullback_snd","module":"Mathlib.CategoryTheory.Limits.Constructions.Equalizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\n⊢ Eq (CategoryTheory.Limits.HasEqualizersOfHasPullbacksAndBinaryProducts.pullbackFst F) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingParallelPair.zero)) (F.map CategoryTheory.Limits.WalkingParallelPairHom.left)) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingParallelPair.zero)) (F.map CategoryTheory.Limits.WalkingParallelPairHom.right)))","decl":"theorem pullbackFst_eq_pullback_snd (F : WalkingParallelPair ⥤ C) :\n    pullbackFst F = pullback.snd _ _ := by\n  convert (eq_whisker pullback.condition Limits.prod.fst :\n      (_ : constructEqualizer F ⟶ F.obj WalkingParallelPair.zero) = _) <;> simp\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizers_of_hasPullbacks_and_binary_products","module":"Mathlib.CategoryTheory.Limits.Constructions.Equalizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ CategoryTheory.Limits.HasEqualizers C","decl":"/-- Any category with pullbacks and binary products, has equalizers. -/\ntheorem hasEqualizers_of_hasPullbacks_and_binary_products [HasBinaryProducts C] [HasPullbacks C] :\n    HasEqualizers C :=\n  { has_limit := fun F =>\n      HasLimit.mk\n        { cone := equalizerCone F\n          isLimit := equalizerConeIsLimit F } }\n\n"}
{"name":"CategoryTheory.Limits.preservesEqualizers_of_preservesPullbacks_and_binaryProducts","module":"Mathlib.CategoryTheory.Limits.Constructions.Equalizers","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\nG : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.Limits.HasBinaryProducts C\ninst✝² : CategoryTheory.Limits.HasPullbacks C\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) G\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan G\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair G","decl":"/-- A functor that preserves pullbacks and binary products also presrves equalizers. -/\nlemma preservesEqualizers_of_preservesPullbacks_and_binaryProducts\n    [HasBinaryProducts C] [HasPullbacks C]\n    [PreservesLimitsOfShape (Discrete WalkingPair) G] [PreservesLimitsOfShape WalkingCospan G] :\n    PreservesLimitsOfShape WalkingParallelPair G :=\n  ⟨fun {K} =>\n    preservesLimit_of_preserves_limit_cone (equalizerConeIsLimit K) <|\n      { lift := fun c => by\n          refine pullback.lift ?_ ?_ ?_ ≫ (PreservesPullback.iso _ _ _ ).inv\n          · exact c.π.app WalkingParallelPair.zero\n          · exact c.π.app WalkingParallelPair.zero\n          apply (mapIsLimitOfPreservesOfIsLimit G _ _ (prodIsProd _ _)).hom_ext\n          rintro (_ | _)\n          · simp only [Category.assoc, ← G.map_comp, prod.lift_fst, BinaryFan.π_app_left,\n              BinaryFan.mk_fst]\n          · simp only [BinaryFan.π_app_right, BinaryFan.mk_snd, Category.assoc, ← G.map_comp,\n              prod.lift_snd]\n            exact\n              (c.π.naturality WalkingParallelPairHom.left).symm.trans\n                (c.π.naturality WalkingParallelPairHom.right)\n        fac := fun c j => by\n          rcases j with (_ | _) <;>\n            simp only [Category.comp_id, PreservesPullback.iso_inv_fst, Cone.ofFork_π, G.map_comp,\n              PreservesPullback.iso_inv_fst_assoc, Functor.mapCone_π_app, eqToHom_refl,\n              Category.assoc, Fork.ofι_π_app, pullback.lift_fst, pullback.lift_fst_assoc]\n          exact (c.π.naturality WalkingParallelPairHom.left).symm.trans (Category.id_comp _)\n        uniq := fun s m h => by\n          rw [Iso.eq_comp_inv]\n          have := h WalkingParallelPair.zero\n          dsimp [equalizerCone] at this\n          ext <;>\n            simp only [PreservesPullback.iso_hom_snd, Category.assoc,\n              PreservesPullback.iso_hom_fst, pullback.lift_fst, pullback.lift_snd,\n              Category.comp_id, ← pullbackFst_eq_pullback_snd, ← this] }⟩\n\n-- We hide the \"implementation details\" inside a namespace\n"}
{"name":"CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.pushoutInl_eq_pushout_inr","module":"Mathlib.CategoryTheory.Limits.Constructions.Equalizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasPushouts C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\n⊢ Eq (CategoryTheory.Limits.HasCoequalizersOfHasPushoutsAndBinaryCoproducts.pushoutInl F) (CategoryTheory.Limits.pushout.inr (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingParallelPair.one)) (F.map CategoryTheory.Limits.WalkingParallelPairHom.left)) (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingParallelPair.one)) (F.map CategoryTheory.Limits.WalkingParallelPairHom.right)))","decl":"theorem pushoutInl_eq_pushout_inr (F : WalkingParallelPair ⥤ C) :\n    pushoutInl F = pushout.inr _ _ := by\n  convert (whisker_eq Limits.coprod.inl pushout.condition :\n    (_ : F.obj _ ⟶ constructCoequalizer _) = _) <;> simp\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizers_of_hasPushouts_and_binary_coproducts","module":"Mathlib.CategoryTheory.Limits.Constructions.Equalizers","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasPushouts C\n⊢ CategoryTheory.Limits.HasCoequalizers C","decl":"/-- Any category with pullbacks and binary products, has equalizers. -/\ntheorem hasCoequalizers_of_hasPushouts_and_binary_coproducts [HasBinaryCoproducts C]\n    [HasPushouts C] : HasCoequalizers C :=\n  {\n    has_colimit := fun F =>\n      HasColimit.mk\n        { cocone := coequalizerCocone F\n          isColimit := coequalizerCoconeIsColimit F } }\n\n"}
{"name":"CategoryTheory.Limits.preservesCoequalizers_of_preservesPushouts_and_binaryCoproducts","module":"Mathlib.CategoryTheory.Limits.Constructions.Equalizers","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\nG : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝² : CategoryTheory.Limits.HasPushouts C\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) G\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan G\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair G","decl":"/-- A functor that preserves pushouts and binary coproducts also presrves coequalizers. -/\nlemma preservesCoequalizers_of_preservesPushouts_and_binaryCoproducts [HasBinaryCoproducts C]\n    [HasPushouts C] [PreservesColimitsOfShape (Discrete WalkingPair) G]\n    [PreservesColimitsOfShape WalkingSpan G] : PreservesColimitsOfShape WalkingParallelPair G :=\n  ⟨fun {K} =>\n    preservesColimit_of_preserves_colimit_cocone (coequalizerCoconeIsColimit K) <|\n      { desc := fun c => by\n          refine (PreservesPushout.iso _ _ _).inv ≫ pushout.desc ?_ ?_ ?_\n          · exact c.ι.app WalkingParallelPair.one\n          · exact c.ι.app WalkingParallelPair.one\n          apply (mapIsColimitOfPreservesOfIsColimit G _ _ (coprodIsCoprod _ _)).hom_ext\n          rintro (_ | _)\n          · simp only [BinaryCofan.ι_app_left, BinaryCofan.mk_inl, Category.assoc, ←\n              G.map_comp_assoc, coprod.inl_desc]\n          · simp only [BinaryCofan.ι_app_right, BinaryCofan.mk_inr, Category.assoc, ←\n              G.map_comp_assoc, coprod.inr_desc]\n            exact\n              (c.ι.naturality WalkingParallelPairHom.left).trans\n                (c.ι.naturality WalkingParallelPairHom.right).symm\n        fac := fun c j => by\n          rcases j with (_ | _) <;>\n            simp only [Functor.mapCocone_ι_app, Cocone.ofCofork_ι, Category.id_comp,\n              eqToHom_refl, Category.assoc, Functor.map_comp, Cofork.ofπ_ι_app, pushout.inl_desc,\n              PreservesPushout.inl_iso_inv_assoc]\n          exact (c.ι.naturality WalkingParallelPairHom.left).trans (Category.comp_id _)\n        uniq := fun s m h => by\n          rw [Iso.eq_inv_comp]\n          have := h WalkingParallelPair.one\n          dsimp [coequalizerCocone] at this\n          ext <;>\n            simp only [PreservesPushout.inl_iso_hom_assoc, Category.id_comp, pushout.inl_desc,\n              pushout.inr_desc, PreservesPushout.inr_iso_hom_assoc, ← pushoutInl_eq_pushout_inr, ←\n              this] }⟩\n\n"}
