{"name":"isConformalMap_conj","module":"Mathlib.Analysis.Complex.Conformal","initialProofState":"⊢ IsConformalMap ↑{ toLinearEquiv := Complex.conjLIE.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }","decl":"theorem isConformalMap_conj : IsConformalMap (conjLIE : ℂ →L[ℝ] ℂ) :=\n  conjLIE.toLinearIsometry.isConformalMap\n\n"}
{"name":"isConformalMap_complex_linear","module":"Mathlib.Analysis.Complex.Conformal","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : NormedSpace Complex E\nmap : ContinuousLinearMap (RingHom.id Complex) Complex E\nnonzero : Ne map 0\n⊢ IsConformalMap (ContinuousLinearMap.restrictScalars Real map)","decl":"theorem isConformalMap_complex_linear {map : ℂ →L[ℂ] E} (nonzero : map ≠ 0) :\n    IsConformalMap (map.restrictScalars ℝ) := by\n  have minor₁ : ‖map 1‖ ≠ 0 := by\n    simpa only [ContinuousLinearMap.ext_ring_iff, Ne, norm_eq_zero] using nonzero\n  refine ⟨‖map 1‖, minor₁, ⟨‖map 1‖⁻¹ • ((map : ℂ →ₗ[ℂ] E) : ℂ →ₗ[ℝ] E), ?_⟩, ?_⟩\n  · intro x\n    simp only [LinearMap.smul_apply]\n    have : x = x • (1 : ℂ) := by rw [smul_eq_mul, mul_one]\n    nth_rw 1 [this]\n    rw [LinearMap.coe_restrictScalars]\n    simp only [map.coe_coe, map.map_smul, norm_smul, norm_inv, norm_norm]\n    field_simp only [one_mul]\n  · ext1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp`; explicitly supplied simp lemma\n    simp [smul_inv_smul₀ minor₁]\n\n"}
{"name":"isConformalMap_complex_linear_conj","module":"Mathlib.Analysis.Complex.Conformal","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : NormedSpace Complex E\nmap : ContinuousLinearMap (RingHom.id Complex) Complex E\nnonzero : Ne map 0\n⊢ IsConformalMap ((ContinuousLinearMap.restrictScalars Real map).comp ↑Complex.conjCLE)","decl":"theorem isConformalMap_complex_linear_conj {map : ℂ →L[ℂ] E} (nonzero : map ≠ 0) :\n    IsConformalMap ((map.restrictScalars ℝ).comp (conjCLE : ℂ →L[ℝ] ℂ)) :=\n  (isConformalMap_complex_linear nonzero).comp isConformalMap_conj\n\n"}
{"name":"IsConformalMap.is_complex_or_conj_linear","module":"Mathlib.Analysis.Complex.Conformal","initialProofState":"g : ContinuousLinearMap (RingHom.id Real) Complex Complex\nh : IsConformalMap g\n⊢ Or (Exists fun map => Eq (ContinuousLinearMap.restrictScalars Real map) g) (Exists fun map => Eq (ContinuousLinearMap.restrictScalars Real map) (g.comp ↑Complex.conjCLE))","decl":"theorem IsConformalMap.is_complex_or_conj_linear (h : IsConformalMap g) :\n    (∃ map : ℂ →L[ℂ] ℂ, map.restrictScalars ℝ = g) ∨\n      ∃ map : ℂ →L[ℂ] ℂ, map.restrictScalars ℝ = g ∘L ↑conjCLE := by\n  rcases h with ⟨c, -, li, rfl⟩\n  obtain ⟨li, rfl⟩ : ∃ li' : ℂ ≃ₗᵢ[ℝ] ℂ, li'.toLinearIsometry = li :=\n    ⟨li.toLinearIsometryEquiv rfl, by ext1; rfl⟩\n  rcases linear_isometry_complex li with ⟨a, rfl | rfl⟩\n  -- let rot := c • (a : ℂ) • ContinuousLinearMap.id ℂ ℂ,\n  · refine Or.inl ⟨c • (a : ℂ) • ContinuousLinearMap.id ℂ ℂ, ?_⟩\n    ext1\n    simp\n  · refine Or.inr ⟨c • (a : ℂ) • ContinuousLinearMap.id ℂ ℂ, ?_⟩\n    ext1\n    simp\n\n"}
{"name":"isConformalMap_iff_is_complex_or_conj_linear","module":"Mathlib.Analysis.Complex.Conformal","initialProofState":"g : ContinuousLinearMap (RingHom.id Real) Complex Complex\n⊢ Iff (IsConformalMap g) (And (Or (Exists fun map => Eq (ContinuousLinearMap.restrictScalars Real map) g) (Exists fun map => Eq (ContinuousLinearMap.restrictScalars Real map) (g.comp ↑Complex.conjCLE))) (Ne g 0))","decl":"/-- A real continuous linear map on the complex plane is conformal if and only if the map or its\n    conjugate is complex linear, and the map is nonvanishing. -/\ntheorem isConformalMap_iff_is_complex_or_conj_linear :\n    IsConformalMap g ↔\n      ((∃ map : ℂ →L[ℂ] ℂ, map.restrictScalars ℝ = g) ∨\n          ∃ map : ℂ →L[ℂ] ℂ, map.restrictScalars ℝ = g ∘L ↑conjCLE) ∧\n        g ≠ 0 := by\n  constructor\n  · exact fun h => ⟨h.is_complex_or_conj_linear, h.ne_zero⟩\n  · rintro ⟨⟨map, rfl⟩ | ⟨map, hmap⟩, h₂⟩\n    · refine isConformalMap_complex_linear ?_\n      contrapose! h₂ with w\n      simp only [w, restrictScalars_zero]\n    · have minor₁ : g = map.restrictScalars ℝ ∘L ↑conjCLE := by\n        ext1\n        simp only [hmap, coe_comp', ContinuousLinearEquiv.coe_coe, Function.comp_apply,\n          conjCLE_apply, starRingEnd_self_apply]\n      rw [minor₁] at h₂ ⊢\n      refine isConformalMap_complex_linear_conj ?_\n      contrapose! h₂ with w\n      simp only [w, restrictScalars_zero, zero_comp]\n\n"}
{"name":"DifferentiableAt.conformalAt","module":"Mathlib.Analysis.Complex.Conformal","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nz : Complex\nf : Complex → E\nh : DifferentiableAt Complex f z\nhf' : Ne (deriv f z) 0\n⊢ ConformalAt f z","decl":"/-- A real differentiable function of the complex plane into some complex normed space `E` is\nconformal at a point `z` if it is holomorphic at that point with a nonvanishing differential.\nThis is a version of the Cauchy-Riemann equations. -/\ntheorem DifferentiableAt.conformalAt (h : DifferentiableAt ℂ f z) (hf' : deriv f z ≠ 0) :\n    ConformalAt f z := by\n  rw [conformalAt_iff_isConformalMap_fderiv, (h.hasFDerivAt.restrictScalars ℝ).fderiv]\n  apply isConformalMap_complex_linear\n  simpa only [Ne, ContinuousLinearMap.ext_ring_iff]\n\n"}
{"name":"conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj","module":"Mathlib.Analysis.Complex.Conformal","initialProofState":"f : Complex → Complex\nz : Complex\n⊢ Iff (ConformalAt f z) (And (Or (DifferentiableAt Complex f z) (DifferentiableAt Complex (Function.comp f ⇑(starRingEnd Complex)) ((starRingEnd Complex) z))) (Ne (fderiv Real f z) 0))","decl":"/-- A complex function is conformal if and only if the function is holomorphic or antiholomorphic\nwith a nonvanishing differential. -/\ntheorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj {f : ℂ → ℂ} {z : ℂ} :\n    ConformalAt f z ↔\n      (DifferentiableAt ℂ f z ∨ DifferentiableAt ℂ (f ∘ conj) (conj z)) ∧ fderiv ℝ f z ≠ 0 := by\n  rw [conformalAt_iff_isConformalMap_fderiv]\n  rw [isConformalMap_iff_is_complex_or_conj_linear]\n  apply and_congr_left\n  intro h\n  have h_diff := h.imp_symm fderiv_zero_of_not_differentiableAt\n  apply or_congr\n  · rw [differentiableAt_iff_restrictScalars ℝ h_diff]\n  rw [← conj_conj z] at h_diff\n  rw [differentiableAt_iff_restrictScalars ℝ (h_diff.comp _ conjCLE.differentiableAt)]\n  refine exists_congr fun g => rfl.congr ?_\n  have : fderiv ℝ conj (conj z) = _ := conjCLE.fderiv\n  simp [fderiv_comp _ h_diff conjCLE.differentiableAt, this, conj_conj]\n\n"}
