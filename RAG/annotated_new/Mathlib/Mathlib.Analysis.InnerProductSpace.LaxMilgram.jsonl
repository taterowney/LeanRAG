{"name":"IsCoercive.bounded_below","module":"Mathlib.Analysis.InnerProductSpace.LaxMilgram","initialProofState":"V : Type u\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : CompleteSpace V\nB : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) V Real)\ncoercive : IsCoercive B\n⊢ Exists fun C => And (LT.lt 0 C) (∀ (v : V), LE.le (HMul.hMul C (Norm.norm v)) (Norm.norm ((InnerProductSpace.continuousLinearMapOfBilin B) v)))","decl":"theorem bounded_below (coercive : IsCoercive B) : ∃ C, 0 < C ∧ ∀ v, C * ‖v‖ ≤ ‖B♯ v‖ := by\n  rcases coercive with ⟨C, C_ge_0, coercivity⟩\n  refine ⟨C, C_ge_0, ?_⟩\n  intro v\n  by_cases h : 0 < ‖v‖\n  · refine (mul_le_mul_right h).mp ?_\n    calc\n      C * ‖v‖ * ‖v‖ ≤ B v v := coercivity v\n      _ = ⟪B♯ v, v⟫_ℝ := (continuousLinearMapOfBilin_apply B v v).symm\n      _ ≤ ‖B♯ v‖ * ‖v‖ := real_inner_le_norm (B♯ v) v\n  · have : v = 0 := by simpa using h\n    simp [this]\n\n"}
{"name":"IsCoercive.antilipschitz","module":"Mathlib.Analysis.InnerProductSpace.LaxMilgram","initialProofState":"V : Type u\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : CompleteSpace V\nB : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) V Real)\ncoercive : IsCoercive B\n⊢ Exists fun C => And (LT.lt 0 C) (AntilipschitzWith C ⇑(InnerProductSpace.continuousLinearMapOfBilin B))","decl":"theorem antilipschitz (coercive : IsCoercive B) : ∃ C : ℝ≥0, 0 < C ∧ AntilipschitzWith C B♯ := by\n  rcases coercive.bounded_below with ⟨C, C_pos, below_bound⟩\n  refine ⟨C⁻¹.toNNReal, Real.toNNReal_pos.mpr (inv_pos.mpr C_pos), ?_⟩\n  refine ContinuousLinearMap.antilipschitz_of_bound B♯ ?_\n  simp_rw [Real.coe_toNNReal', max_eq_left_of_lt (inv_pos.mpr C_pos), ←\n    inv_mul_le_iff₀ (inv_pos.mpr C_pos)]\n  simpa using below_bound\n\n"}
{"name":"IsCoercive.ker_eq_bot","module":"Mathlib.Analysis.InnerProductSpace.LaxMilgram","initialProofState":"V : Type u\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : CompleteSpace V\nB : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) V Real)\ncoercive : IsCoercive B\n⊢ Eq (LinearMap.ker (InnerProductSpace.continuousLinearMapOfBilin B)) Bot.bot","decl":"theorem ker_eq_bot (coercive : IsCoercive B) : ker B♯ = ⊥ := by\n  rw [LinearMapClass.ker_eq_bot]\n  rcases coercive.antilipschitz with ⟨_, _, antilipschitz⟩\n  exact antilipschitz.injective\n\n"}
{"name":"IsCoercive.isClosed_range","module":"Mathlib.Analysis.InnerProductSpace.LaxMilgram","initialProofState":"V : Type u\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : CompleteSpace V\nB : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) V Real)\ncoercive : IsCoercive B\n⊢ IsClosed ↑(LinearMap.range (InnerProductSpace.continuousLinearMapOfBilin B))","decl":"theorem isClosed_range (coercive : IsCoercive B) : IsClosed (range B♯ : Set V) := by\n  rcases coercive.antilipschitz with ⟨_, _, antilipschitz⟩\n  exact antilipschitz.isClosed_range B♯.uniformContinuous\n\n\n"}
{"name":"IsCoercive.range_eq_top","module":"Mathlib.Analysis.InnerProductSpace.LaxMilgram","initialProofState":"V : Type u\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : CompleteSpace V\nB : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) V Real)\ncoercive : IsCoercive B\n⊢ Eq (LinearMap.range (InnerProductSpace.continuousLinearMapOfBilin B)) Top.top","decl":"theorem range_eq_top (coercive : IsCoercive B) : range B♯ = ⊤ := by\n  haveI := coercive.isClosed_range.completeSpace_coe\n  rw [← (range B♯).orthogonal_orthogonal]\n  rw [Submodule.eq_top_iff']\n  intro v w mem_w_orthogonal\n  rcases coercive with ⟨C, C_pos, coercivity⟩\n  obtain rfl : w = 0 := by\n    rw [← norm_eq_zero, ← mul_self_eq_zero, ← mul_right_inj' C_pos.ne', mul_zero, ←\n      mul_assoc]\n    apply le_antisymm\n    · calc\n        C * ‖w‖ * ‖w‖ ≤ B w w := coercivity w\n        _ = ⟪B♯ w, w⟫_ℝ := (continuousLinearMapOfBilin_apply B w w).symm\n        _ = 0 := mem_w_orthogonal _ ⟨w, rfl⟩\n    · positivity\n  exact inner_zero_left _\n\n"}
{"name":"IsCoercive.continuousLinearEquivOfBilin_apply","module":"Mathlib.Analysis.InnerProductSpace.LaxMilgram","initialProofState":"V : Type u\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : CompleteSpace V\nB : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) V Real)\ncoercive : IsCoercive B\nv w : V\n⊢ Eq (Inner.inner (coercive.continuousLinearEquivOfBilin v) w) ((B v) w)","decl":"@[simp]\ntheorem continuousLinearEquivOfBilin_apply (coercive : IsCoercive B) (v w : V) :\n    ⟪coercive.continuousLinearEquivOfBilin v, w⟫_ℝ = B v w :=\n  continuousLinearMapOfBilin_apply B v w\n\n"}
{"name":"IsCoercive.unique_continuousLinearEquivOfBilin","module":"Mathlib.Analysis.InnerProductSpace.LaxMilgram","initialProofState":"V : Type u\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : CompleteSpace V\nB : ContinuousLinearMap (RingHom.id Real) V (ContinuousLinearMap (RingHom.id Real) V Real)\ncoercive : IsCoercive B\nv f : V\nis_lax_milgram : ∀ (w : V), Eq (Inner.inner f w) ((B v) w)\n⊢ Eq f (coercive.continuousLinearEquivOfBilin v)","decl":"theorem unique_continuousLinearEquivOfBilin (coercive : IsCoercive B) {v f : V}\n    (is_lax_milgram : ∀ w, ⟪f, w⟫_ℝ = B v w) : f = coercive.continuousLinearEquivOfBilin v :=\n  unique_continuousLinearMapOfBilin B is_lax_milgram\n\n"}
