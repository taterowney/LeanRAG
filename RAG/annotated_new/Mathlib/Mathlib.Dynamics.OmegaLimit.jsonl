{"name":"omegaLimit_def","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\nâŠ¢ Eq (omegaLimit f Ï• s) (Set.iInter fun u => Set.iInter fun h => closure (Set.image2 Ï• u s))","decl":"theorem omegaLimit_def : Ï‰ f Ï• s = â‹‚ u âˆˆ f, closure (image2 Ï• u s) := rfl\n\n"}
{"name":"omegaLimit_subset_of_tendsto","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\nm : Ï„ â†’ Ï„\nfâ‚ fâ‚‚ : Filter Ï„\nhf : Filter.Tendsto m fâ‚ fâ‚‚\nâŠ¢ HasSubset.Subset (omegaLimit fâ‚ (fun t x => Ï• (m t) x) s) (omegaLimit fâ‚‚ Ï• s)","decl":"theorem omegaLimit_subset_of_tendsto {m : Ï„ â†’ Ï„} {fâ‚ fâ‚‚ : Filter Ï„} (hf : Tendsto m fâ‚ fâ‚‚) :\n    Ï‰ fâ‚ (fun t x â†¦ Ï• (m t) x) s âŠ† Ï‰ fâ‚‚ Ï• s := by\n  refine iInterâ‚‚_mono' fun u hu â†¦ âŸ¨m â»Â¹' u, tendsto_def.mp hf _ hu, ?_âŸ©\n  rw [â† image2_image_left]\n  exact closure_mono (image2_subset (image_preimage_subset _ _) Subset.rfl)\n\n"}
{"name":"omegaLimit_mono_left","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\nfâ‚ fâ‚‚ : Filter Ï„\nhf : LE.le fâ‚ fâ‚‚\nâŠ¢ HasSubset.Subset (omegaLimit fâ‚ Ï• s) (omegaLimit fâ‚‚ Ï• s)","decl":"theorem omegaLimit_mono_left {fâ‚ fâ‚‚ : Filter Ï„} (hf : fâ‚ â‰¤ fâ‚‚) : Ï‰ fâ‚ Ï• s âŠ† Ï‰ fâ‚‚ Ï• s :=\n  omegaLimit_subset_of_tendsto Ï• s (tendsto_id'.2 hf)\n\n"}
{"name":"omegaLimit_mono_right","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\nsâ‚ sâ‚‚ : Set Î±\nhs : HasSubset.Subset sâ‚ sâ‚‚\nâŠ¢ HasSubset.Subset (omegaLimit f Ï• sâ‚) (omegaLimit f Ï• sâ‚‚)","decl":"theorem omegaLimit_mono_right {sâ‚ sâ‚‚ : Set Î±} (hs : sâ‚ âŠ† sâ‚‚) : Ï‰ f Ï• sâ‚ âŠ† Ï‰ f Ï• sâ‚‚ :=\n  iInterâ‚‚_mono fun _u _hu â†¦ closure_mono (image2_subset Subset.rfl hs)\n\n"}
{"name":"isClosed_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\nâŠ¢ IsClosed (omegaLimit f Ï• s)","decl":"theorem isClosed_omegaLimit : IsClosed (Ï‰ f Ï• s) :=\n  isClosed_iInter fun _u â†¦ isClosed_iInter fun _hu â†¦ isClosed_closure\n\n"}
{"name":"mapsTo_omegaLimit'","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î²\ns : Set Î±\nÎ±' : Type u_5\nÎ²' : Type u_6\ninstâœ : TopologicalSpace Î²'\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\nÏ•' : Ï„ â†’ Î±' â†’ Î²'\nga : Î± â†’ Î±'\ns' : Set Î±'\nhs : Set.MapsTo ga s s'\ngb : Î² â†’ Î²'\nhg : Filter.Eventually (fun t => Set.EqOn (Function.comp gb (Ï• t)) (Function.comp (Ï•' t) ga) s) f\nhgc : Continuous gb\nâŠ¢ Set.MapsTo gb (omegaLimit f Ï• s) (omegaLimit f Ï•' s')","decl":"theorem mapsTo_omegaLimit' {Î±' Î²' : Type*} [TopologicalSpace Î²'] {f : Filter Ï„} {Ï• : Ï„ â†’ Î± â†’ Î²}\n    {Ï•' : Ï„ â†’ Î±' â†’ Î²'} {ga : Î± â†’ Î±'} {s' : Set Î±'} (hs : MapsTo ga s s') {gb : Î² â†’ Î²'}\n    (hg : âˆ€á¶  t in f, EqOn (gb âˆ˜ Ï• t) (Ï•' t âˆ˜ ga) s) (hgc : Continuous gb) :\n    MapsTo gb (Ï‰ f Ï• s) (Ï‰ f Ï•' s') := by\n  simp only [omegaLimit_def, mem_iInter, MapsTo]\n  intro y hy u hu\n  refine map_mem_closure hgc (hy _ (inter_mem hu hg)) (forall_mem_image2.2 fun t ht x hx â†¦ ?_)\n  calc\n    Ï•' t (ga x) âˆˆ image2 Ï•' u s' := mem_image2_of_mem ht.1 (hs hx)\n    _ = gb (Ï• t x) := ht.2 hx |>.symm\n\n"}
{"name":"mapsTo_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î²\ns : Set Î±\nÎ±' : Type u_5\nÎ²' : Type u_6\ninstâœ : TopologicalSpace Î²'\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\nÏ•' : Ï„ â†’ Î±' â†’ Î²'\nga : Î± â†’ Î±'\ns' : Set Î±'\nhs : Set.MapsTo ga s s'\ngb : Î² â†’ Î²'\nhg : âˆ€ (t : Ï„) (x : Î±), Eq (gb (Ï• t x)) (Ï•' t (ga x))\nhgc : Continuous gb\nâŠ¢ Set.MapsTo gb (omegaLimit f Ï• s) (omegaLimit f Ï•' s')","decl":"theorem mapsTo_omegaLimit {Î±' Î²' : Type*} [TopologicalSpace Î²'] {f : Filter Ï„} {Ï• : Ï„ â†’ Î± â†’ Î²}\n    {Ï•' : Ï„ â†’ Î±' â†’ Î²'} {ga : Î± â†’ Î±'} {s' : Set Î±'} (hs : MapsTo ga s s') {gb : Î² â†’ Î²'}\n    (hg : âˆ€ t x, gb (Ï• t x) = Ï•' t (ga x)) (hgc : Continuous gb) :\n    MapsTo gb (Ï‰ f Ï• s) (Ï‰ f Ï•' s') :=\n  mapsTo_omegaLimit' _ hs (Eventually.of_forall fun t x _hx â†¦ hg t x) hgc\n\n"}
{"name":"omegaLimit_image_eq","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\ns : Set Î±\nÎ±' : Type u_5\nÏ• : Ï„ â†’ Î±' â†’ Î²\nf : Filter Ï„\ng : Î± â†’ Î±'\nâŠ¢ Eq (omegaLimit f Ï• (Set.image g s)) (omegaLimit f (fun t x => Ï• t (g x)) s)","decl":"theorem omegaLimit_image_eq {Î±' : Type*} (Ï• : Ï„ â†’ Î±' â†’ Î²) (f : Filter Ï„) (g : Î± â†’ Î±') :\n    Ï‰ f Ï• (g '' s) = Ï‰ f (fun t x â†¦ Ï• t (g x)) s := by simp only [omegaLimit, image2_image_right]\n\n"}
{"name":"omegaLimit_preimage_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nÎ±' : Type u_5\nÏ• : Ï„ â†’ Î±' â†’ Î²\ns : Set Î±'\nf : Filter Ï„\ng : Î± â†’ Î±'\nâŠ¢ HasSubset.Subset (omegaLimit f (fun t x => Ï• t (g x)) (Set.preimage g s)) (omegaLimit f Ï• s)","decl":"theorem omegaLimit_preimage_subset {Î±' : Type*} (Ï• : Ï„ â†’ Î±' â†’ Î²) (s : Set Î±') (f : Filter Ï„)\n    (g : Î± â†’ Î±') : Ï‰ f (fun t x â†¦ Ï• t (g x)) (g â»Â¹' s) âŠ† Ï‰ f Ï• s :=\n  mapsTo_omegaLimit _ (mapsTo_preimage _ _) (fun _t _x â†¦ rfl) continuous_id\n\n"}
{"name":"mem_omegaLimit_iff_frequently","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\ny : Î²\nâŠ¢ Iff (Membership.mem (omegaLimit f Ï• s) y) (âˆ€ (n : Set Î²), Membership.mem (nhds y) n â†’ Filter.Frequently (fun t => (Inter.inter s (Set.preimage (Ï• t) n)).Nonempty) f)","decl":"/-- An element `y` is in the Ï‰-limit set of `s` w.r.t. `f` if the\n    preimages of an arbitrary neighbourhood of `y` frequently\n    (w.r.t. `f`) intersects of `s`. -/\ntheorem mem_omegaLimit_iff_frequently (y : Î²) :\n    y âˆˆ Ï‰ f Ï• s â†” âˆ€ n âˆˆ ğ“ y, âˆƒá¶  t in f, (s âˆ© Ï• t â»Â¹' n).Nonempty := by\n  simp_rw [frequently_iff, omegaLimit_def, mem_iInter, mem_closure_iff_nhds]\n  constructor\n  Â· intro h _ hn _ hu\n    rcases h _ hu _ hn with âŸ¨_, _, _, ht, _, hx, rflâŸ©\n    exact âŸ¨_, ht, _, hx, by rwa [mem_preimage]âŸ©\n  Â· intro h _ hu _ hn\n    rcases h _ hn hu with âŸ¨_, ht, _, hx, hÏ•txâŸ©\n    exact âŸ¨_, hÏ•tx, _, ht, _, hx, rflâŸ©\n\n"}
{"name":"mem_omegaLimit_iff_frequentlyâ‚‚","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\ny : Î²\nâŠ¢ Iff (Membership.mem (omegaLimit f Ï• s) y) (âˆ€ (n : Set Î²), Membership.mem (nhds y) n â†’ Filter.Frequently (fun t => (Inter.inter (Set.image (Ï• t) s) n).Nonempty) f)","decl":"/-- An element `y` is in the Ï‰-limit set of `s` w.r.t. `f` if the\n    forward images of `s` frequently (w.r.t. `f`) intersect arbitrary\n    neighbourhoods of `y`. -/\ntheorem mem_omegaLimit_iff_frequentlyâ‚‚ (y : Î²) :\n    y âˆˆ Ï‰ f Ï• s â†” âˆ€ n âˆˆ ğ“ y, âˆƒá¶  t in f, (Ï• t '' s âˆ© n).Nonempty := by\n  simp_rw [mem_omegaLimit_iff_frequently, image_inter_nonempty_iff]\n\n"}
{"name":"mem_omegaLimit_singleton_iff_map_cluster_point","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\nx : Î±\ny : Î²\nâŠ¢ Iff (Membership.mem (omegaLimit f Ï• (Singleton.singleton x)) y) (MapClusterPt y f fun t => Ï• t x)","decl":"/-- An element `y` is in the Ï‰-limit of `x` w.r.t. `f` if the forward\n    images of `x` frequently (w.r.t. `f`) falls within an arbitrary\n    neighbourhood of `y`. -/\ntheorem mem_omegaLimit_singleton_iff_map_cluster_point (x : Î±) (y : Î²) :\n    y âˆˆ Ï‰ f Ï• {x} â†” MapClusterPt y f fun t â†¦ Ï• t x := by\n  simp_rw [mem_omegaLimit_iff_frequently, mapClusterPt_iff, singleton_inter_nonempty, mem_preimage]\n\n"}
{"name":"omegaLimit_inter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\nsâ‚ sâ‚‚ : Set Î±\nâŠ¢ HasSubset.Subset (omegaLimit f Ï• (Inter.inter sâ‚ sâ‚‚)) (Inter.inter (omegaLimit f Ï• sâ‚) (omegaLimit f Ï• sâ‚‚))","decl":"theorem omegaLimit_inter : Ï‰ f Ï• (sâ‚ âˆ© sâ‚‚) âŠ† Ï‰ f Ï• sâ‚ âˆ© Ï‰ f Ï• sâ‚‚ :=\n  subset_inter (omegaLimit_mono_right _ _ inter_subset_left)\n    (omegaLimit_mono_right _ _ inter_subset_right)\n\n"}
{"name":"omegaLimit_iInter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ¹ : Type u_4\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\np : Î¹ â†’ Set Î±\nâŠ¢ HasSubset.Subset (omegaLimit f Ï• (Set.iInter fun i => p i)) (Set.iInter fun i => omegaLimit f Ï• (p i))","decl":"theorem omegaLimit_iInter (p : Î¹ â†’ Set Î±) : Ï‰ f Ï• (â‹‚ i, p i) âŠ† â‹‚ i, Ï‰ f Ï• (p i) :=\n  subset_iInter fun _i â†¦ omegaLimit_mono_right _ _ (iInter_subset _ _)\n\n"}
{"name":"omegaLimit_union","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\nsâ‚ sâ‚‚ : Set Î±\nâŠ¢ Eq (omegaLimit f Ï• (Union.union sâ‚ sâ‚‚)) (Union.union (omegaLimit f Ï• sâ‚) (omegaLimit f Ï• sâ‚‚))","decl":"theorem omegaLimit_union : Ï‰ f Ï• (sâ‚ âˆª sâ‚‚) = Ï‰ f Ï• sâ‚ âˆª Ï‰ f Ï• sâ‚‚ := by\n  ext y; constructor\n  Â· simp only [mem_union, mem_omegaLimit_iff_frequently, union_inter_distrib_right, union_nonempty,\n      frequently_or_distrib]\n    contrapose!\n    simp only [not_frequently, not_nonempty_iff_eq_empty, â† subset_empty_iff]\n    rintro âŸ¨âŸ¨nâ‚, hnâ‚, hâ‚âŸ©, âŸ¨nâ‚‚, hnâ‚‚, hâ‚‚âŸ©âŸ©\n    refine âŸ¨nâ‚ âˆ© nâ‚‚, inter_mem hnâ‚ hnâ‚‚, hâ‚.mono fun t â†¦ ?_, hâ‚‚.mono fun t â†¦ ?_âŸ©\n    exacts [Subset.trans <| inter_subset_inter_right _ <| preimage_mono inter_subset_left,\n      Subset.trans <| inter_subset_inter_right _ <| preimage_mono inter_subset_right]\n  Â· rintro (hy | hy)\n    exacts [omegaLimit_mono_right _ _ subset_union_left hy,\n      omegaLimit_mono_right _ _ subset_union_right hy]\n\n"}
{"name":"omegaLimit_iUnion","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nÎ¹ : Type u_4\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\np : Î¹ â†’ Set Î±\nâŠ¢ HasSubset.Subset (Set.iUnion fun i => omegaLimit f Ï• (p i)) (omegaLimit f Ï• (Set.iUnion fun i => p i))","decl":"theorem omegaLimit_iUnion (p : Î¹ â†’ Set Î±) : â‹ƒ i, Ï‰ f Ï• (p i) âŠ† Ï‰ f Ï• (â‹ƒ i, p i) := by\n  rw [iUnion_subset_iff]\n  exact fun i â†¦ omegaLimit_mono_right _ _ (subset_iUnion _ _)\n\n"}
{"name":"omegaLimit_eq_iInter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\nâŠ¢ Eq (omegaLimit f Ï• s) (Set.iInter fun u => closure (Set.image2 Ï• (â†‘u) s))","decl":"theorem omegaLimit_eq_iInter : Ï‰ f Ï• s = â‹‚ u : â†¥f.sets, closure (image2 Ï• u s) :=\n  biInter_eq_iInter _ _\n\n"}
{"name":"omegaLimit_eq_biInter_inter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\nv : Set Ï„\nhv : Membership.mem f v\nâŠ¢ Eq (omegaLimit f Ï• s) (Set.iInter fun u => Set.iInter fun h => closure (Set.image2 Ï• (Inter.inter u v) s))","decl":"theorem omegaLimit_eq_biInter_inter {v : Set Ï„} (hv : v âˆˆ f) :\n    Ï‰ f Ï• s = â‹‚ u âˆˆ f, closure (image2 Ï• (u âˆ© v) s) :=\n  Subset.antisymm (iInterâ‚‚_mono' fun u hu â†¦ âŸ¨u âˆ© v, inter_mem hu hv, Subset.rflâŸ©)\n    (iInterâ‚‚_mono fun _u _hu â†¦ closure_mono <| image2_subset inter_subset_left Subset.rfl)\n\n"}
{"name":"omegaLimit_eq_iInter_inter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\nv : Set Ï„\nhv : Membership.mem f v\nâŠ¢ Eq (omegaLimit f Ï• s) (Set.iInter fun u => closure (Set.image2 Ï• (Inter.inter (â†‘u) v) s))","decl":"theorem omegaLimit_eq_iInter_inter {v : Set Ï„} (hv : v âˆˆ f) :\n    Ï‰ f Ï• s = â‹‚ u : â†¥f.sets, closure (image2 Ï• (u âˆ© v) s) := by\n  rw [omegaLimit_eq_biInter_inter _ _ _ hv]\n  apply biInter_eq_iInter\n\n"}
{"name":"omegaLimit_subset_closure_fw_image","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\nu : Set Ï„\nhu : Membership.mem f u\nâŠ¢ HasSubset.Subset (omegaLimit f Ï• s) (closure (Set.image2 Ï• u s))","decl":"theorem omegaLimit_subset_closure_fw_image {u : Set Ï„} (hu : u âˆˆ f) :\n    Ï‰ f Ï• s âŠ† closure (image2 Ï• u s) := by\n  rw [omegaLimit_eq_iInter]\n  intro _ hx\n  rw [mem_iInter] at hx\n  exact hx âŸ¨u, huâŸ©\n\n-- An instance with better keys\n"}
{"name":"eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset'","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\nc : Set Î²\nhcâ‚ : IsCompact c\nhcâ‚‚ : Exists fun v => And (Membership.mem f v) (HasSubset.Subset (closure (Set.image2 Ï• v s)) c)\nn : Set Î²\nhnâ‚ : IsOpen n\nhnâ‚‚ : HasSubset.Subset (omegaLimit f Ï• s) n\nâŠ¢ Exists fun u => And (Membership.mem f u) (HasSubset.Subset (closure (Set.image2 Ï• u s)) n)","decl":"/-- A set is eventually carried into any open neighbourhood of its Ï‰-limit:\nif `c` is a compact set such that `closure {Ï• t x | t âˆˆ v, x âˆˆ s} âŠ† c` for some `v âˆˆ f`\nand `n` is an open neighbourhood of `Ï‰ f Ï• s`, then for some `u âˆˆ f` we have\n`closure {Ï• t x | t âˆˆ u, x âˆˆ s} âŠ† n`. -/\ntheorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set Î²}\n    (hcâ‚ : IsCompact c) (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) {n : Set Î²} (hnâ‚ : IsOpen n)\n    (hnâ‚‚ : Ï‰ f Ï• s âŠ† n) : âˆƒ u âˆˆ f, closure (image2 Ï• u s) âŠ† n := by\n  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©\n  let k := closure (image2 Ï• v s)\n  have hk : IsCompact (k \\ n) :=\n    (hcâ‚.of_isClosed_subset isClosed_closure hvâ‚‚).diff hnâ‚\n  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ\n  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure\n  have hjâ‚‚ : k \\ n âŠ† â‹ƒ u âˆˆ f, j u := by\n    have : â‹ƒ u âˆˆ f, j u = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _\n    rw [this, diff_subset_comm, diff_iUnion]\n    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚\n    simp_rw [j, diff_compl]\n    rw [â† inter_iInter]\n    exact Subset.trans inter_subset_right hnâ‚‚\n  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©\n  let w := (â‹‚ u âˆˆ g, u) âˆ© v\n  have hwâ‚‚ : w âˆˆ f := by simpa [w, *]\n  have hwâ‚ƒ : k \\ n âŠ† (closure (image2 Ï• w s))á¶œ := by\n    apply Subset.trans hgâ‚ƒ\n    simp only [j, iUnion_subset_iff, compl_subset_compl]\n    intros u hu\n    mono\n    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)\n    all_goals exact Subset.rfl\n  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by\n    simp only [compl_subset_compl]\n    exact closure_mono (image2_subset inter_subset_right Subset.rfl)\n  have hnc : ná¶œ âŠ† k \\ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]\n  have hw : closure (image2 Ï• w s) âŠ† n :=\n    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))\n  exact âŸ¨_, hwâ‚‚, hwâŸ©\n\n"}
{"name":"eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\ninstâœ : T2Space Î²\nc : Set Î²\nhcâ‚ : IsCompact c\nhcâ‚‚ : Filter.Eventually (fun t => Set.MapsTo (Ï• t) s c) f\nn : Set Î²\nhnâ‚ : IsOpen n\nhnâ‚‚ : HasSubset.Subset (omegaLimit f Ï• s) n\nâŠ¢ Exists fun u => And (Membership.mem f u) (HasSubset.Subset (closure (Set.image2 Ï• u s)) n)","decl":"/-- A set is eventually carried into any open neighbourhood of its Ï‰-limit:\nif `c` is a compact set such that `closure {Ï• t x | t âˆˆ v, x âˆˆ s} âŠ† c` for some `v âˆˆ f`\nand `n` is an open neighbourhood of `Ï‰ f Ï• s`, then for some `u âˆˆ f` we have\n`closure {Ï• t x | t âˆˆ u, x âˆˆ s} âŠ† n`. -/\ntheorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset [T2Space Î²]\n    {c : Set Î²} (hcâ‚ : IsCompact c) (hcâ‚‚ : âˆ€á¶  t in f, MapsTo (Ï• t) s c) {n : Set Î²} (hnâ‚ : IsOpen n)\n    (hnâ‚‚ : Ï‰ f Ï• s âŠ† n) : âˆƒ u âˆˆ f, closure (image2 Ï• u s) âŠ† n :=\n  eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' f Ï• _ hcâ‚\n    âŸ¨_, hcâ‚‚, closure_minimal (image2_subset_iff.2 fun _t â†¦ id) hcâ‚.isClosedâŸ© hnâ‚ hnâ‚‚\n\n"}
{"name":"eventually_mapsTo_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\ninstâœ : T2Space Î²\nc : Set Î²\nhcâ‚ : IsCompact c\nhcâ‚‚ : Filter.Eventually (fun t => Set.MapsTo (Ï• t) s c) f\nn : Set Î²\nhnâ‚ : IsOpen n\nhnâ‚‚ : HasSubset.Subset (omegaLimit f Ï• s) n\nâŠ¢ Filter.Eventually (fun t => Set.MapsTo (Ï• t) s n) f","decl":"theorem eventually_mapsTo_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset [T2Space Î²]\n    {c : Set Î²} (hcâ‚ : IsCompact c) (hcâ‚‚ : âˆ€á¶  t in f, MapsTo (Ï• t) s c) {n : Set Î²} (hnâ‚ : IsOpen n)\n    (hnâ‚‚ : Ï‰ f Ï• s âŠ† n) : âˆ€á¶  t in f, MapsTo (Ï• t) s n := by\n  rcases eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset f Ï• s hcâ‚\n      hcâ‚‚ hnâ‚ hnâ‚‚ with\n    âŸ¨u, hu_mem, huâŸ©\n  refine mem_of_superset hu_mem fun t ht x hx â†¦ ?_\n  exact hu (subset_closure <| mem_image2_of_mem ht hx)\n\n"}
{"name":"eventually_closure_subset_of_isOpen_of_omegaLimit_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\ninstâœ : CompactSpace Î²\nv : Set Î²\nhvâ‚ : IsOpen v\nhvâ‚‚ : HasSubset.Subset (omegaLimit f Ï• s) v\nâŠ¢ Exists fun u => And (Membership.mem f u) (HasSubset.Subset (closure (Set.image2 Ï• u s)) v)","decl":"theorem eventually_closure_subset_of_isOpen_of_omegaLimit_subset [CompactSpace Î²] {v : Set Î²}\n    (hvâ‚ : IsOpen v) (hvâ‚‚ : Ï‰ f Ï• s âŠ† v) : âˆƒ u âˆˆ f, closure (image2 Ï• u s) âŠ† v :=\n  eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' _ _ _\n    isCompact_univ âŸ¨univ, univ_mem, subset_univ _âŸ© hvâ‚ hvâ‚‚\n\n"}
{"name":"eventually_mapsTo_of_isOpen_of_omegaLimit_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\ninstâœ : CompactSpace Î²\nv : Set Î²\nhvâ‚ : IsOpen v\nhvâ‚‚ : HasSubset.Subset (omegaLimit f Ï• s) v\nâŠ¢ Filter.Eventually (fun t => Set.MapsTo (Ï• t) s v) f","decl":"theorem eventually_mapsTo_of_isOpen_of_omegaLimit_subset [CompactSpace Î²] {v : Set Î²}\n    (hvâ‚ : IsOpen v) (hvâ‚‚ : Ï‰ f Ï• s âŠ† v) : âˆ€á¶  t in f, MapsTo (Ï• t) s v := by\n  rcases eventually_closure_subset_of_isOpen_of_omegaLimit_subset f Ï• s hvâ‚ hvâ‚‚ with âŸ¨u, hu_mem, huâŸ©\n  refine mem_of_superset hu_mem fun t ht x hx â†¦ ?_\n  exact hu (subset_closure <| mem_image2_of_mem ht hx)\n\n"}
{"name":"nonempty_omegaLimit_of_isCompact_absorbing","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\ninstâœ : f.NeBot\nc : Set Î²\nhcâ‚ : IsCompact c\nhcâ‚‚ : Exists fun v => And (Membership.mem f v) (HasSubset.Subset (closure (Set.image2 Ï• v s)) c)\nhs : s.Nonempty\nâŠ¢ (omegaLimit f Ï• s).Nonempty","decl":"/-- The Ï‰-limit of a nonempty set w.r.t. a nontrivial filter is nonempty. -/\ntheorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set Î²} (hcâ‚ : IsCompact c)\n    (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) (hs : s.Nonempty) : (Ï‰ f Ï• s).Nonempty := by\n  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©\n  rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚]\n  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed\n  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©\n    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©\n    constructor\n    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)\n  Â· intro u\n    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=\n      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs\n    exact hn.mono subset_closure\n  Â· intro\n    apply hcâ‚.of_isClosed_subset isClosed_closure\n    calc\n      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)\n      _ âŠ† c := hvâ‚‚\n  Â· exact fun _ â†¦ isClosed_closure\n\n"}
{"name":"nonempty_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : TopologicalSpace Î²\nf : Filter Ï„\nÏ• : Ï„ â†’ Î± â†’ Î²\ns : Set Î±\ninstâœÂ¹ : CompactSpace Î²\ninstâœ : f.NeBot\nhs : s.Nonempty\nâŠ¢ (omegaLimit f Ï• s).Nonempty","decl":"theorem nonempty_omegaLimit [CompactSpace Î²] [NeBot f] (hs : s.Nonempty) : (Ï‰ f Ï• s).Nonempty :=\n  nonempty_omegaLimit_of_isCompact_absorbing _ _ _ isCompact_univ âŸ¨univ, univ_mem, subset_univ _âŸ© hs\n\n"}
{"name":"Flow.isInvariant_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\ninstâœÂ³ : TopologicalSpace Ï„\ninstâœÂ² : AddMonoid Ï„\ninstâœÂ¹ : ContinuousAdd Ï„\nÎ± : Type u_2\ninstâœ : TopologicalSpace Î±\nf : Filter Ï„\nÏ• : Flow Ï„ Î±\ns : Set Î±\nhf : âˆ€ (t : Ï„), Filter.Tendsto (fun x => HAdd.hAdd t x) f f\nâŠ¢ IsInvariant Ï•.toFun (omegaLimit f Ï•.toFun s)","decl":"theorem isInvariant_omegaLimit (hf : âˆ€ t, Tendsto (t + Â·) f f) : IsInvariant Ï• (Ï‰ f Ï• s) := by\n  refine fun t â†¦ MapsTo.mono_right ?_ (omegaLimit_subset_of_tendsto Ï• s (hf t))\n  exact\n    mapsTo_omegaLimit _ (mapsTo_id _) (fun t' x â†¦ (Ï•.map_add _ _ _).symm)\n      (continuous_const.flow Ï• continuous_id)\n\n"}
{"name":"Flow.omegaLimit_image_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\ninstâœÂ³ : TopologicalSpace Ï„\ninstâœÂ² : AddMonoid Ï„\ninstâœÂ¹ : ContinuousAdd Ï„\nÎ± : Type u_2\ninstâœ : TopologicalSpace Î±\nf : Filter Ï„\nÏ• : Flow Ï„ Î±\ns : Set Î±\nt : Ï„\nht : Filter.Tendsto (fun x => HAdd.hAdd x t) f f\nâŠ¢ HasSubset.Subset (omegaLimit f Ï•.toFun (Set.image (Ï•.toFun t) s)) (omegaLimit f Ï•.toFun s)","decl":"theorem omegaLimit_image_subset (t : Ï„) (ht : Tendsto (Â· + t) f f) :\n    Ï‰ f Ï• (Ï• t '' s) âŠ† Ï‰ f Ï• s := by\n  simp only [omegaLimit_image_eq, â† map_add]\n  exact omegaLimit_subset_of_tendsto Ï• s ht\n\n"}
{"name":"Flow.omegaLimit_image_eq","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\ninstâœÂ³ : TopologicalSpace Ï„\ninstâœÂ² : AddCommGroup Ï„\ninstâœÂ¹ : TopologicalAddGroup Ï„\nÎ± : Type u_2\ninstâœ : TopologicalSpace Î±\nf : Filter Ï„\nÏ• : Flow Ï„ Î±\ns : Set Î±\nhf : âˆ€ (t : Ï„), Filter.Tendsto (fun x => HAdd.hAdd x t) f f\nt : Ï„\nâŠ¢ Eq (omegaLimit f Ï•.toFun (Set.image (Ï•.toFun t) s)) (omegaLimit f Ï•.toFun s)","decl":"/-- the Ï‰-limit of a forward image of `s` is the same as the Ï‰-limit of `s`. -/\n@[simp]\ntheorem omegaLimit_image_eq (hf : âˆ€ t, Tendsto (Â· + t) f f) (t : Ï„) : Ï‰ f Ï• (Ï• t '' s) = Ï‰ f Ï• s :=\n  Subset.antisymm (omegaLimit_image_subset _ _ _ _ (hf t)) <|\n    calc\n      Ï‰ f Ï• s = Ï‰ f Ï• (Ï• (-t) '' (Ï• t '' s)) := by simp [image_image, â† map_add]\n      _ âŠ† Ï‰ f Ï• (Ï• t '' s) := omegaLimit_image_subset _ _ _ _ (hf _)\n\n"}
{"name":"Flow.omegaLimit_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"Ï„ : Type u_1\ninstâœÂ³ : TopologicalSpace Ï„\ninstâœÂ² : AddCommGroup Ï„\ninstâœÂ¹ : TopologicalAddGroup Ï„\nÎ± : Type u_2\ninstâœ : TopologicalSpace Î±\nf : Filter Ï„\nÏ• : Flow Ï„ Î±\ns : Set Î±\nhf : âˆ€ (t : Ï„), Filter.Tendsto (fun x => HAdd.hAdd t x) f f\nâŠ¢ HasSubset.Subset (omegaLimit f Ï•.toFun (omegaLimit f Ï•.toFun s)) (omegaLimit f Ï•.toFun s)","decl":"theorem omegaLimit_omegaLimit (hf : âˆ€ t, Tendsto (t + Â·) f f) : Ï‰ f Ï• (Ï‰ f Ï• s) âŠ† Ï‰ f Ï• s := by\n  simp only [subset_def, mem_omegaLimit_iff_frequentlyâ‚‚, frequently_iff]\n  intro _ h\n  rintro n hn u hu\n  rcases mem_nhds_iff.mp hn with âŸ¨o, hoâ‚, hoâ‚‚, hoâ‚ƒâŸ©\n  rcases h o (IsOpen.mem_nhds hoâ‚‚ hoâ‚ƒ) hu with âŸ¨t, _htâ‚, htâ‚‚âŸ©\n  have lâ‚ : (Ï‰ f Ï• s âˆ© o).Nonempty :=\n    htâ‚‚.mono\n      (inter_subset_inter_left _\n        ((isInvariant_iff_image _ _).mp (isInvariant_omegaLimit _ _ _ hf) _))\n  have lâ‚‚ : (closure (image2 Ï• u s) âˆ© o).Nonempty :=\n    lâ‚.mono fun b hb â†¦ âŸ¨omegaLimit_subset_closure_fw_image _ _ _ hu hb.1, hb.2âŸ©\n  have lâ‚ƒ : (o âˆ© image2 Ï• u s).Nonempty := by\n    rcases lâ‚‚ with âŸ¨b, hbâ‚, hbâ‚‚âŸ©\n    exact mem_closure_iff_nhds.mp hbâ‚ o (IsOpen.mem_nhds hoâ‚‚ hbâ‚‚)\n  rcases lâ‚ƒ with âŸ¨Ï•ra, ho, âŸ¨_, hr, _, ha, hÏ•raâŸ©âŸ©\n  exact âŸ¨_, hr, Ï•ra, âŸ¨_, ha, hÏ•raâŸ©, hoâ‚ hoâŸ©\n\n"}
