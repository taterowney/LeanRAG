{"name":"omegaLimit_def","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\n⊢ Eq (omegaLimit f ϕ s) (Set.iInter fun u => Set.iInter fun h => closure (Set.image2 ϕ u s))","decl":"theorem omegaLimit_def : ω f ϕ s = ⋂ u ∈ f, closure (image2 ϕ u s) := rfl\n\n"}
{"name":"omegaLimit_subset_of_tendsto","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nϕ : τ → α → β\ns : Set α\nm : τ → τ\nf₁ f₂ : Filter τ\nhf : Filter.Tendsto m f₁ f₂\n⊢ HasSubset.Subset (omegaLimit f₁ (fun t x => ϕ (m t) x) s) (omegaLimit f₂ ϕ s)","decl":"theorem omegaLimit_subset_of_tendsto {m : τ → τ} {f₁ f₂ : Filter τ} (hf : Tendsto m f₁ f₂) :\n    ω f₁ (fun t x ↦ ϕ (m t) x) s ⊆ ω f₂ ϕ s := by\n  refine iInter₂_mono' fun u hu ↦ ⟨m ⁻¹' u, tendsto_def.mp hf _ hu, ?_⟩\n  rw [← image2_image_left]\n  exact closure_mono (image2_subset (image_preimage_subset _ _) Subset.rfl)\n\n"}
{"name":"omegaLimit_mono_left","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nϕ : τ → α → β\ns : Set α\nf₁ f₂ : Filter τ\nhf : LE.le f₁ f₂\n⊢ HasSubset.Subset (omegaLimit f₁ ϕ s) (omegaLimit f₂ ϕ s)","decl":"theorem omegaLimit_mono_left {f₁ f₂ : Filter τ} (hf : f₁ ≤ f₂) : ω f₁ ϕ s ⊆ ω f₂ ϕ s :=\n  omegaLimit_subset_of_tendsto ϕ s (tendsto_id'.2 hf)\n\n"}
{"name":"omegaLimit_mono_right","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns₁ s₂ : Set α\nhs : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (omegaLimit f ϕ s₁) (omegaLimit f ϕ s₂)","decl":"theorem omegaLimit_mono_right {s₁ s₂ : Set α} (hs : s₁ ⊆ s₂) : ω f ϕ s₁ ⊆ ω f ϕ s₂ :=\n  iInter₂_mono fun _u _hu ↦ closure_mono (image2_subset Subset.rfl hs)\n\n"}
{"name":"isClosed_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\n⊢ IsClosed (omegaLimit f ϕ s)","decl":"theorem isClosed_omegaLimit : IsClosed (ω f ϕ s) :=\n  isClosed_iInter fun _u ↦ isClosed_iInter fun _hu ↦ isClosed_closure\n\n"}
{"name":"mapsTo_omegaLimit'","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\ns : Set α\nα' : Type u_5\nβ' : Type u_6\ninst✝ : TopologicalSpace β'\nf : Filter τ\nϕ : τ → α → β\nϕ' : τ → α' → β'\nga : α → α'\ns' : Set α'\nhs : Set.MapsTo ga s s'\ngb : β → β'\nhg : Filter.Eventually (fun t => Set.EqOn (Function.comp gb (ϕ t)) (Function.comp (ϕ' t) ga) s) f\nhgc : Continuous gb\n⊢ Set.MapsTo gb (omegaLimit f ϕ s) (omegaLimit f ϕ' s')","decl":"theorem mapsTo_omegaLimit' {α' β' : Type*} [TopologicalSpace β'] {f : Filter τ} {ϕ : τ → α → β}\n    {ϕ' : τ → α' → β'} {ga : α → α'} {s' : Set α'} (hs : MapsTo ga s s') {gb : β → β'}\n    (hg : ∀ᶠ t in f, EqOn (gb ∘ ϕ t) (ϕ' t ∘ ga) s) (hgc : Continuous gb) :\n    MapsTo gb (ω f ϕ s) (ω f ϕ' s') := by\n  simp only [omegaLimit_def, mem_iInter, MapsTo]\n  intro y hy u hu\n  refine map_mem_closure hgc (hy _ (inter_mem hu hg)) (forall_mem_image2.2 fun t ht x hx ↦ ?_)\n  calc\n    ϕ' t (ga x) ∈ image2 ϕ' u s' := mem_image2_of_mem ht.1 (hs hx)\n    _ = gb (ϕ t x) := ht.2 hx |>.symm\n\n"}
{"name":"mapsTo_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\ns : Set α\nα' : Type u_5\nβ' : Type u_6\ninst✝ : TopologicalSpace β'\nf : Filter τ\nϕ : τ → α → β\nϕ' : τ → α' → β'\nga : α → α'\ns' : Set α'\nhs : Set.MapsTo ga s s'\ngb : β → β'\nhg : ∀ (t : τ) (x : α), Eq (gb (ϕ t x)) (ϕ' t (ga x))\nhgc : Continuous gb\n⊢ Set.MapsTo gb (omegaLimit f ϕ s) (omegaLimit f ϕ' s')","decl":"theorem mapsTo_omegaLimit {α' β' : Type*} [TopologicalSpace β'] {f : Filter τ} {ϕ : τ → α → β}\n    {ϕ' : τ → α' → β'} {ga : α → α'} {s' : Set α'} (hs : MapsTo ga s s') {gb : β → β'}\n    (hg : ∀ t x, gb (ϕ t x) = ϕ' t (ga x)) (hgc : Continuous gb) :\n    MapsTo gb (ω f ϕ s) (ω f ϕ' s') :=\n  mapsTo_omegaLimit' _ hs (Eventually.of_forall fun t x _hx ↦ hg t x) hgc\n\n"}
{"name":"omegaLimit_image_eq","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\ns : Set α\nα' : Type u_5\nϕ : τ → α' → β\nf : Filter τ\ng : α → α'\n⊢ Eq (omegaLimit f ϕ (Set.image g s)) (omegaLimit f (fun t x => ϕ t (g x)) s)","decl":"theorem omegaLimit_image_eq {α' : Type*} (ϕ : τ → α' → β) (f : Filter τ) (g : α → α') :\n    ω f ϕ (g '' s) = ω f (fun t x ↦ ϕ t (g x)) s := by simp only [omegaLimit, image2_image_right]\n\n"}
{"name":"omegaLimit_preimage_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nα' : Type u_5\nϕ : τ → α' → β\ns : Set α'\nf : Filter τ\ng : α → α'\n⊢ HasSubset.Subset (omegaLimit f (fun t x => ϕ t (g x)) (Set.preimage g s)) (omegaLimit f ϕ s)","decl":"theorem omegaLimit_preimage_subset {α' : Type*} (ϕ : τ → α' → β) (s : Set α') (f : Filter τ)\n    (g : α → α') : ω f (fun t x ↦ ϕ t (g x)) (g ⁻¹' s) ⊆ ω f ϕ s :=\n  mapsTo_omegaLimit _ (mapsTo_preimage _ _) (fun _t _x ↦ rfl) continuous_id\n\n"}
{"name":"mem_omegaLimit_iff_frequently","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\ny : β\n⊢ Iff (Membership.mem (omegaLimit f ϕ s) y) (∀ (n : Set β), Membership.mem (nhds y) n → Filter.Frequently (fun t => (Inter.inter s (Set.preimage (ϕ t) n)).Nonempty) f)","decl":"/-- An element `y` is in the ω-limit set of `s` w.r.t. `f` if the\n    preimages of an arbitrary neighbourhood of `y` frequently\n    (w.r.t. `f`) intersects of `s`. -/\ntheorem mem_omegaLimit_iff_frequently (y : β) :\n    y ∈ ω f ϕ s ↔ ∀ n ∈ 𝓝 y, ∃ᶠ t in f, (s ∩ ϕ t ⁻¹' n).Nonempty := by\n  simp_rw [frequently_iff, omegaLimit_def, mem_iInter, mem_closure_iff_nhds]\n  constructor\n  · intro h _ hn _ hu\n    rcases h _ hu _ hn with ⟨_, _, _, ht, _, hx, rfl⟩\n    exact ⟨_, ht, _, hx, by rwa [mem_preimage]⟩\n  · intro h _ hu _ hn\n    rcases h _ hn hu with ⟨_, ht, _, hx, hϕtx⟩\n    exact ⟨_, hϕtx, _, ht, _, hx, rfl⟩\n\n"}
{"name":"mem_omegaLimit_iff_frequently₂","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\ny : β\n⊢ Iff (Membership.mem (omegaLimit f ϕ s) y) (∀ (n : Set β), Membership.mem (nhds y) n → Filter.Frequently (fun t => (Inter.inter (Set.image (ϕ t) s) n).Nonempty) f)","decl":"/-- An element `y` is in the ω-limit set of `s` w.r.t. `f` if the\n    forward images of `s` frequently (w.r.t. `f`) intersect arbitrary\n    neighbourhoods of `y`. -/\ntheorem mem_omegaLimit_iff_frequently₂ (y : β) :\n    y ∈ ω f ϕ s ↔ ∀ n ∈ 𝓝 y, ∃ᶠ t in f, (ϕ t '' s ∩ n).Nonempty := by\n  simp_rw [mem_omegaLimit_iff_frequently, image_inter_nonempty_iff]\n\n"}
{"name":"mem_omegaLimit_singleton_iff_map_cluster_point","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\nx : α\ny : β\n⊢ Iff (Membership.mem (omegaLimit f ϕ (Singleton.singleton x)) y) (MapClusterPt y f fun t => ϕ t x)","decl":"/-- An element `y` is in the ω-limit of `x` w.r.t. `f` if the forward\n    images of `x` frequently (w.r.t. `f`) falls within an arbitrary\n    neighbourhood of `y`. -/\ntheorem mem_omegaLimit_singleton_iff_map_cluster_point (x : α) (y : β) :\n    y ∈ ω f ϕ {x} ↔ MapClusterPt y f fun t ↦ ϕ t x := by\n  simp_rw [mem_omegaLimit_iff_frequently, mapClusterPt_iff, singleton_inter_nonempty, mem_preimage]\n\n"}
{"name":"omegaLimit_inter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns₁ s₂ : Set α\n⊢ HasSubset.Subset (omegaLimit f ϕ (Inter.inter s₁ s₂)) (Inter.inter (omegaLimit f ϕ s₁) (omegaLimit f ϕ s₂))","decl":"theorem omegaLimit_inter : ω f ϕ (s₁ ∩ s₂) ⊆ ω f ϕ s₁ ∩ ω f ϕ s₂ :=\n  subset_inter (omegaLimit_mono_right _ _ inter_subset_left)\n    (omegaLimit_mono_right _ _ inter_subset_right)\n\n"}
{"name":"omegaLimit_iInter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\nι : Type u_4\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\np : ι → Set α\n⊢ HasSubset.Subset (omegaLimit f ϕ (Set.iInter fun i => p i)) (Set.iInter fun i => omegaLimit f ϕ (p i))","decl":"theorem omegaLimit_iInter (p : ι → Set α) : ω f ϕ (⋂ i, p i) ⊆ ⋂ i, ω f ϕ (p i) :=\n  subset_iInter fun _i ↦ omegaLimit_mono_right _ _ (iInter_subset _ _)\n\n"}
{"name":"omegaLimit_union","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns₁ s₂ : Set α\n⊢ Eq (omegaLimit f ϕ (Union.union s₁ s₂)) (Union.union (omegaLimit f ϕ s₁) (omegaLimit f ϕ s₂))","decl":"theorem omegaLimit_union : ω f ϕ (s₁ ∪ s₂) = ω f ϕ s₁ ∪ ω f ϕ s₂ := by\n  ext y; constructor\n  · simp only [mem_union, mem_omegaLimit_iff_frequently, union_inter_distrib_right, union_nonempty,\n      frequently_or_distrib]\n    contrapose!\n    simp only [not_frequently, not_nonempty_iff_eq_empty, ← subset_empty_iff]\n    rintro ⟨⟨n₁, hn₁, h₁⟩, ⟨n₂, hn₂, h₂⟩⟩\n    refine ⟨n₁ ∩ n₂, inter_mem hn₁ hn₂, h₁.mono fun t ↦ ?_, h₂.mono fun t ↦ ?_⟩\n    exacts [Subset.trans <| inter_subset_inter_right _ <| preimage_mono inter_subset_left,\n      Subset.trans <| inter_subset_inter_right _ <| preimage_mono inter_subset_right]\n  · rintro (hy | hy)\n    exacts [omegaLimit_mono_right _ _ subset_union_left hy,\n      omegaLimit_mono_right _ _ subset_union_right hy]\n\n"}
{"name":"omegaLimit_iUnion","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\nι : Type u_4\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\np : ι → Set α\n⊢ HasSubset.Subset (Set.iUnion fun i => omegaLimit f ϕ (p i)) (omegaLimit f ϕ (Set.iUnion fun i => p i))","decl":"theorem omegaLimit_iUnion (p : ι → Set α) : ⋃ i, ω f ϕ (p i) ⊆ ω f ϕ (⋃ i, p i) := by\n  rw [iUnion_subset_iff]\n  exact fun i ↦ omegaLimit_mono_right _ _ (subset_iUnion _ _)\n\n"}
{"name":"omegaLimit_eq_iInter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\n⊢ Eq (omegaLimit f ϕ s) (Set.iInter fun u => closure (Set.image2 ϕ (↑u) s))","decl":"theorem omegaLimit_eq_iInter : ω f ϕ s = ⋂ u : ↥f.sets, closure (image2 ϕ u s) :=\n  biInter_eq_iInter _ _\n\n"}
{"name":"omegaLimit_eq_biInter_inter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\nv : Set τ\nhv : Membership.mem f v\n⊢ Eq (omegaLimit f ϕ s) (Set.iInter fun u => Set.iInter fun h => closure (Set.image2 ϕ (Inter.inter u v) s))","decl":"theorem omegaLimit_eq_biInter_inter {v : Set τ} (hv : v ∈ f) :\n    ω f ϕ s = ⋂ u ∈ f, closure (image2 ϕ (u ∩ v) s) :=\n  Subset.antisymm (iInter₂_mono' fun u hu ↦ ⟨u ∩ v, inter_mem hu hv, Subset.rfl⟩)\n    (iInter₂_mono fun _u _hu ↦ closure_mono <| image2_subset inter_subset_left Subset.rfl)\n\n"}
{"name":"omegaLimit_eq_iInter_inter","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\nv : Set τ\nhv : Membership.mem f v\n⊢ Eq (omegaLimit f ϕ s) (Set.iInter fun u => closure (Set.image2 ϕ (Inter.inter (↑u) v) s))","decl":"theorem omegaLimit_eq_iInter_inter {v : Set τ} (hv : v ∈ f) :\n    ω f ϕ s = ⋂ u : ↥f.sets, closure (image2 ϕ (u ∩ v) s) := by\n  rw [omegaLimit_eq_biInter_inter _ _ _ hv]\n  apply biInter_eq_iInter\n\n"}
{"name":"omegaLimit_subset_closure_fw_image","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\nu : Set τ\nhu : Membership.mem f u\n⊢ HasSubset.Subset (omegaLimit f ϕ s) (closure (Set.image2 ϕ u s))","decl":"theorem omegaLimit_subset_closure_fw_image {u : Set τ} (hu : u ∈ f) :\n    ω f ϕ s ⊆ closure (image2 ϕ u s) := by\n  rw [omegaLimit_eq_iInter]\n  intro _ hx\n  rw [mem_iInter] at hx\n  exact hx ⟨u, hu⟩\n\n-- An instance with better keys\n"}
{"name":"eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset'","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\nc : Set β\nhc₁ : IsCompact c\nhc₂ : Exists fun v => And (Membership.mem f v) (HasSubset.Subset (closure (Set.image2 ϕ v s)) c)\nn : Set β\nhn₁ : IsOpen n\nhn₂ : HasSubset.Subset (omegaLimit f ϕ s) n\n⊢ Exists fun u => And (Membership.mem f u) (HasSubset.Subset (closure (Set.image2 ϕ u s)) n)","decl":"/-- A set is eventually carried into any open neighbourhood of its ω-limit:\nif `c` is a compact set such that `closure {ϕ t x | t ∈ v, x ∈ s} ⊆ c` for some `v ∈ f`\nand `n` is an open neighbourhood of `ω f ϕ s`, then for some `u ∈ f` we have\n`closure {ϕ t x | t ∈ u, x ∈ s} ⊆ n`. -/\ntheorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}\n    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)\n    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n := by\n  rcases hc₂ with ⟨v, hv₁, hv₂⟩\n  let k := closure (image2 ϕ v s)\n  have hk : IsCompact (k \\ n) :=\n    (hc₁.of_isClosed_subset isClosed_closure hv₂).diff hn₁\n  let j u := (closure (image2 ϕ (u ∩ v) s))ᶜ\n  have hj₁ : ∀ u ∈ f, IsOpen (j u) := fun _ _ ↦ isOpen_compl_iff.mpr isClosed_closure\n  have hj₂ : k \\ n ⊆ ⋃ u ∈ f, j u := by\n    have : ⋃ u ∈ f, j u = ⋃ u : (↥f.sets), j u := biUnion_eq_iUnion _ _\n    rw [this, diff_subset_comm, diff_iUnion]\n    rw [omegaLimit_eq_iInter_inter _ _ _ hv₁] at hn₂\n    simp_rw [j, diff_compl]\n    rw [← inter_iInter]\n    exact Subset.trans inter_subset_right hn₂\n  rcases hk.elim_finite_subcover_image hj₁ hj₂ with ⟨g, hg₁ : ∀ u ∈ g, u ∈ f, hg₂, hg₃⟩\n  let w := (⋂ u ∈ g, u) ∩ v\n  have hw₂ : w ∈ f := by simpa [w, *]\n  have hw₃ : k \\ n ⊆ (closure (image2 ϕ w s))ᶜ := by\n    apply Subset.trans hg₃\n    simp only [j, iUnion_subset_iff, compl_subset_compl]\n    intros u hu\n    mono\n    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)\n    all_goals exact Subset.rfl\n  have hw₄ : kᶜ ⊆ (closure (image2 ϕ w s))ᶜ := by\n    simp only [compl_subset_compl]\n    exact closure_mono (image2_subset inter_subset_right Subset.rfl)\n  have hnc : nᶜ ⊆ k \\ n ∪ kᶜ := by rw [union_comm, ← inter_subset, diff_eq, inter_comm]\n  have hw : closure (image2 ϕ w s) ⊆ n :=\n    compl_subset_compl.mp (Subset.trans hnc (union_subset hw₃ hw₄))\n  exact ⟨_, hw₂, hw⟩\n\n"}
{"name":"eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\ninst✝ : T2Space β\nc : Set β\nhc₁ : IsCompact c\nhc₂ : Filter.Eventually (fun t => Set.MapsTo (ϕ t) s c) f\nn : Set β\nhn₁ : IsOpen n\nhn₂ : HasSubset.Subset (omegaLimit f ϕ s) n\n⊢ Exists fun u => And (Membership.mem f u) (HasSubset.Subset (closure (Set.image2 ϕ u s)) n)","decl":"/-- A set is eventually carried into any open neighbourhood of its ω-limit:\nif `c` is a compact set such that `closure {ϕ t x | t ∈ v, x ∈ s} ⊆ c` for some `v ∈ f`\nand `n` is an open neighbourhood of `ω f ϕ s`, then for some `u ∈ f` we have\n`closure {ϕ t x | t ∈ u, x ∈ s} ⊆ n`. -/\ntheorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset [T2Space β]\n    {c : Set β} (hc₁ : IsCompact c) (hc₂ : ∀ᶠ t in f, MapsTo (ϕ t) s c) {n : Set β} (hn₁ : IsOpen n)\n    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n :=\n  eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' f ϕ _ hc₁\n    ⟨_, hc₂, closure_minimal (image2_subset_iff.2 fun _t ↦ id) hc₁.isClosed⟩ hn₁ hn₂\n\n"}
{"name":"eventually_mapsTo_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\ninst✝ : T2Space β\nc : Set β\nhc₁ : IsCompact c\nhc₂ : Filter.Eventually (fun t => Set.MapsTo (ϕ t) s c) f\nn : Set β\nhn₁ : IsOpen n\nhn₂ : HasSubset.Subset (omegaLimit f ϕ s) n\n⊢ Filter.Eventually (fun t => Set.MapsTo (ϕ t) s n) f","decl":"theorem eventually_mapsTo_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset [T2Space β]\n    {c : Set β} (hc₁ : IsCompact c) (hc₂ : ∀ᶠ t in f, MapsTo (ϕ t) s c) {n : Set β} (hn₁ : IsOpen n)\n    (hn₂ : ω f ϕ s ⊆ n) : ∀ᶠ t in f, MapsTo (ϕ t) s n := by\n  rcases eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset f ϕ s hc₁\n      hc₂ hn₁ hn₂ with\n    ⟨u, hu_mem, hu⟩\n  refine mem_of_superset hu_mem fun t ht x hx ↦ ?_\n  exact hu (subset_closure <| mem_image2_of_mem ht hx)\n\n"}
{"name":"eventually_closure_subset_of_isOpen_of_omegaLimit_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\ninst✝ : CompactSpace β\nv : Set β\nhv₁ : IsOpen v\nhv₂ : HasSubset.Subset (omegaLimit f ϕ s) v\n⊢ Exists fun u => And (Membership.mem f u) (HasSubset.Subset (closure (Set.image2 ϕ u s)) v)","decl":"theorem eventually_closure_subset_of_isOpen_of_omegaLimit_subset [CompactSpace β] {v : Set β}\n    (hv₁ : IsOpen v) (hv₂ : ω f ϕ s ⊆ v) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ v :=\n  eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' _ _ _\n    isCompact_univ ⟨univ, univ_mem, subset_univ _⟩ hv₁ hv₂\n\n"}
{"name":"eventually_mapsTo_of_isOpen_of_omegaLimit_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\ninst✝ : CompactSpace β\nv : Set β\nhv₁ : IsOpen v\nhv₂ : HasSubset.Subset (omegaLimit f ϕ s) v\n⊢ Filter.Eventually (fun t => Set.MapsTo (ϕ t) s v) f","decl":"theorem eventually_mapsTo_of_isOpen_of_omegaLimit_subset [CompactSpace β] {v : Set β}\n    (hv₁ : IsOpen v) (hv₂ : ω f ϕ s ⊆ v) : ∀ᶠ t in f, MapsTo (ϕ t) s v := by\n  rcases eventually_closure_subset_of_isOpen_of_omegaLimit_subset f ϕ s hv₁ hv₂ with ⟨u, hu_mem, hu⟩\n  refine mem_of_superset hu_mem fun t ht x hx ↦ ?_\n  exact hu (subset_closure <| mem_image2_of_mem ht hx)\n\n"}
{"name":"nonempty_omegaLimit_of_isCompact_absorbing","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\ninst✝ : f.NeBot\nc : Set β\nhc₁ : IsCompact c\nhc₂ : Exists fun v => And (Membership.mem f v) (HasSubset.Subset (closure (Set.image2 ϕ v s)) c)\nhs : s.Nonempty\n⊢ (omegaLimit f ϕ s).Nonempty","decl":"/-- The ω-limit of a nonempty set w.r.t. a nontrivial filter is nonempty. -/\ntheorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set β} (hc₁ : IsCompact c)\n    (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) (hs : s.Nonempty) : (ω f ϕ s).Nonempty := by\n  rcases hc₂ with ⟨v, hv₁, hv₂⟩\n  rw [omegaLimit_eq_iInter_inter _ _ _ hv₁]\n  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed\n  · rintro ⟨u₁, hu₁⟩ ⟨u₂, hu₂⟩\n    use ⟨u₁ ∩ u₂, inter_mem hu₁ hu₂⟩\n    constructor\n    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)\n  · intro u\n    have hn : (image2 ϕ (u ∩ v) s).Nonempty :=\n      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hv₁)) hs\n    exact hn.mono subset_closure\n  · intro\n    apply hc₁.of_isClosed_subset isClosed_closure\n    calc\n      _ ⊆ closure (image2 ϕ v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)\n      _ ⊆ c := hv₂\n  · exact fun _ ↦ isClosed_closure\n\n"}
{"name":"nonempty_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : TopologicalSpace β\nf : Filter τ\nϕ : τ → α → β\ns : Set α\ninst✝¹ : CompactSpace β\ninst✝ : f.NeBot\nhs : s.Nonempty\n⊢ (omegaLimit f ϕ s).Nonempty","decl":"theorem nonempty_omegaLimit [CompactSpace β] [NeBot f] (hs : s.Nonempty) : (ω f ϕ s).Nonempty :=\n  nonempty_omegaLimit_of_isCompact_absorbing _ _ _ isCompact_univ ⟨univ, univ_mem, subset_univ _⟩ hs\n\n"}
{"name":"Flow.isInvariant_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\ninst✝³ : TopologicalSpace τ\ninst✝² : AddMonoid τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nf : Filter τ\nϕ : Flow τ α\ns : Set α\nhf : ∀ (t : τ), Filter.Tendsto (fun x => HAdd.hAdd t x) f f\n⊢ IsInvariant ϕ.toFun (omegaLimit f ϕ.toFun s)","decl":"theorem isInvariant_omegaLimit (hf : ∀ t, Tendsto (t + ·) f f) : IsInvariant ϕ (ω f ϕ s) := by\n  refine fun t ↦ MapsTo.mono_right ?_ (omegaLimit_subset_of_tendsto ϕ s (hf t))\n  exact\n    mapsTo_omegaLimit _ (mapsTo_id _) (fun t' x ↦ (ϕ.map_add _ _ _).symm)\n      (continuous_const.flow ϕ continuous_id)\n\n"}
{"name":"Flow.omegaLimit_image_subset","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\ninst✝³ : TopologicalSpace τ\ninst✝² : AddMonoid τ\ninst✝¹ : ContinuousAdd τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nf : Filter τ\nϕ : Flow τ α\ns : Set α\nt : τ\nht : Filter.Tendsto (fun x => HAdd.hAdd x t) f f\n⊢ HasSubset.Subset (omegaLimit f ϕ.toFun (Set.image (ϕ.toFun t) s)) (omegaLimit f ϕ.toFun s)","decl":"theorem omegaLimit_image_subset (t : τ) (ht : Tendsto (· + t) f f) :\n    ω f ϕ (ϕ t '' s) ⊆ ω f ϕ s := by\n  simp only [omegaLimit_image_eq, ← map_add]\n  exact omegaLimit_subset_of_tendsto ϕ s ht\n\n"}
{"name":"Flow.omegaLimit_image_eq","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\ninst✝³ : TopologicalSpace τ\ninst✝² : AddCommGroup τ\ninst✝¹ : TopologicalAddGroup τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nf : Filter τ\nϕ : Flow τ α\ns : Set α\nhf : ∀ (t : τ), Filter.Tendsto (fun x => HAdd.hAdd x t) f f\nt : τ\n⊢ Eq (omegaLimit f ϕ.toFun (Set.image (ϕ.toFun t) s)) (omegaLimit f ϕ.toFun s)","decl":"/-- the ω-limit of a forward image of `s` is the same as the ω-limit of `s`. -/\n@[simp]\ntheorem omegaLimit_image_eq (hf : ∀ t, Tendsto (· + t) f f) (t : τ) : ω f ϕ (ϕ t '' s) = ω f ϕ s :=\n  Subset.antisymm (omegaLimit_image_subset _ _ _ _ (hf t)) <|\n    calc\n      ω f ϕ s = ω f ϕ (ϕ (-t) '' (ϕ t '' s)) := by simp [image_image, ← map_add]\n      _ ⊆ ω f ϕ (ϕ t '' s) := omegaLimit_image_subset _ _ _ _ (hf _)\n\n"}
{"name":"Flow.omegaLimit_omegaLimit","module":"Mathlib.Dynamics.OmegaLimit","initialProofState":"τ : Type u_1\ninst✝³ : TopologicalSpace τ\ninst✝² : AddCommGroup τ\ninst✝¹ : TopologicalAddGroup τ\nα : Type u_2\ninst✝ : TopologicalSpace α\nf : Filter τ\nϕ : Flow τ α\ns : Set α\nhf : ∀ (t : τ), Filter.Tendsto (fun x => HAdd.hAdd t x) f f\n⊢ HasSubset.Subset (omegaLimit f ϕ.toFun (omegaLimit f ϕ.toFun s)) (omegaLimit f ϕ.toFun s)","decl":"theorem omegaLimit_omegaLimit (hf : ∀ t, Tendsto (t + ·) f f) : ω f ϕ (ω f ϕ s) ⊆ ω f ϕ s := by\n  simp only [subset_def, mem_omegaLimit_iff_frequently₂, frequently_iff]\n  intro _ h\n  rintro n hn u hu\n  rcases mem_nhds_iff.mp hn with ⟨o, ho₁, ho₂, ho₃⟩\n  rcases h o (IsOpen.mem_nhds ho₂ ho₃) hu with ⟨t, _ht₁, ht₂⟩\n  have l₁ : (ω f ϕ s ∩ o).Nonempty :=\n    ht₂.mono\n      (inter_subset_inter_left _\n        ((isInvariant_iff_image _ _).mp (isInvariant_omegaLimit _ _ _ hf) _))\n  have l₂ : (closure (image2 ϕ u s) ∩ o).Nonempty :=\n    l₁.mono fun b hb ↦ ⟨omegaLimit_subset_closure_fw_image _ _ _ hu hb.1, hb.2⟩\n  have l₃ : (o ∩ image2 ϕ u s).Nonempty := by\n    rcases l₂ with ⟨b, hb₁, hb₂⟩\n    exact mem_closure_iff_nhds.mp hb₁ o (IsOpen.mem_nhds ho₂ hb₂)\n  rcases l₃ with ⟨ϕra, ho, ⟨_, hr, _, ha, hϕra⟩⟩\n  exact ⟨_, hr, ϕra, ⟨_, ha, hϕra⟩, ho₁ ho⟩\n\n"}
