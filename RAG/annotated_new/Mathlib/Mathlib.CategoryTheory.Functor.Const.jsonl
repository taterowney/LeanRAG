{"name":"CategoryTheory.Functor.const_obj_obj","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nX : C\nxâœ : J\nâŠ¢ Eq (((CategoryTheory.Functor.const J).obj X).obj xâœ) X","decl":"/-- The functor sending `X : C` to the constant functor `J â¥¤ C` sending everything to `X`.\n-/\n@[simps]\ndef const : C â¥¤ J â¥¤ C where\n  obj X :=\n    { obj := fun _ => X\n      map := fun _ => ðŸ™ X }\n  map f := { app := fun _ => f }\n\n"}
{"name":"CategoryTheory.Functor.const_obj_map","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nX : C\nXâœ Yâœ : J\nxâœ : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (((CategoryTheory.Functor.const J).obj X).map xâœ) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The functor sending `X : C` to the constant functor `J â¥¤ C` sending everything to `X`.\n-/\n@[simps]\ndef const : C â¥¤ J â¥¤ C where\n  obj X :=\n    { obj := fun _ => X\n      map := fun _ => ðŸ™ X }\n  map f := { app := fun _ => f }\n\n"}
{"name":"CategoryTheory.Functor.const_map_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nXâœ Yâœ : C\nf : Quiver.Hom Xâœ Yâœ\nxâœ : J\nâŠ¢ Eq (((CategoryTheory.Functor.const J).map f).app xâœ) f","decl":"/-- The functor sending `X : C` to the constant functor `J â¥¤ C` sending everything to `X`.\n-/\n@[simps]\ndef const : C â¥¤ J â¥¤ C where\n  obj X :=\n    { obj := fun _ => X\n      map := fun _ => ðŸ™ X }\n  map f := { app := fun _ => f }\n\n"}
{"name":"CategoryTheory.Functor.const.opObjOp_inv_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nX : C\nxâœ : Opposite J\nâŠ¢ Eq ((CategoryTheory.Functor.const.opObjOp X).inv.app xâœ) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const J).obj X).op.obj xâœ))","decl":"/-- The constant functor `Jáµ’áµ– â¥¤ Cáµ’áµ–` sending everything to `op X`\nis (naturally isomorphic to) the opposite of the constant functor `J â¥¤ C` sending everything to `X`.\n-/\n@[simps]\ndef opObjOp (X : C) : (const Jáµ’áµ–).obj (op X) â‰… ((const J).obj X).op where\n  hom := { app := fun _ => ðŸ™ _ }\n  inv := { app := fun _ => ðŸ™ _ }\n\n"}
{"name":"CategoryTheory.Functor.const.opObjOp_hom_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nX : C\nxâœ : Opposite J\nâŠ¢ Eq ((CategoryTheory.Functor.const.opObjOp X).hom.app xâœ) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const (Opposite J)).obj { unop := X }).obj xâœ))","decl":"/-- The constant functor `Jáµ’áµ– â¥¤ Cáµ’áµ–` sending everything to `op X`\nis (naturally isomorphic to) the opposite of the constant functor `J â¥¤ C` sending everything to `X`.\n-/\n@[simps]\ndef opObjOp (X : C) : (const Jáµ’áµ–).obj (op X) â‰… ((const J).obj X).op where\n  hom := { app := fun _ => ðŸ™ _ }\n  inv := { app := fun _ => ðŸ™ _ }\n\n"}
{"name":"CategoryTheory.Functor.const.opObjUnop_hom_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nX : Opposite C\nj : Opposite J\nâŠ¢ Eq ((CategoryTheory.Functor.const.opObjUnop X).hom.app j) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const (Opposite J)).obj (Opposite.unop X)).obj j))","decl":"@[simp]\ntheorem opObjUnop_hom_app (X : Cáµ’áµ–) (j : Jáµ’áµ–) : (opObjUnop.{vâ‚, vâ‚‚} X).hom.app j = ðŸ™ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.const.opObjUnop_inv_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nX : Opposite C\nj : Opposite J\nâŠ¢ Eq ((CategoryTheory.Functor.const.opObjUnop X).inv.app j) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const J).obj X).leftOp.obj j))","decl":"@[simp]\ntheorem opObjUnop_inv_app (X : Cáµ’áµ–) (j : Jáµ’áµ–) : (opObjUnop.{vâ‚, vâ‚‚} X).inv.app j = ðŸ™ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.const.unop_functor_op_obj_map","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nX : Opposite C\njâ‚ jâ‚‚ : J\nf : Quiver.Hom jâ‚ jâ‚‚\nâŠ¢ Eq ((Opposite.unop ((CategoryTheory.Functor.const J).op.obj X)).map f) (CategoryTheory.CategoryStruct.id (Opposite.unop X))","decl":"@[simp]\ntheorem unop_functor_op_obj_map (X : Cáµ’áµ–) {jâ‚ jâ‚‚ : J} (f : jâ‚ âŸ¶ jâ‚‚) :\n    (unop ((Functor.op (const J)).obj X)).map f = ðŸ™ (unop X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.constComp_hom_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nD : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} D\nX : C\nF : CategoryTheory.Functor C D\nxâœ : J\nâŠ¢ Eq ((CategoryTheory.Functor.constComp J X F).hom.app xâœ) (CategoryTheory.CategoryStruct.id ((((CategoryTheory.Functor.const J).obj X).comp F).obj xâœ))","decl":"/-- These are actually equal, of course, but not definitionally equal\n  (the equality requires F.map (ðŸ™ _) = ðŸ™ _). A natural isomorphism is\n  more convenient than an equality between functors (compare id_to_iso). -/\n@[simps]\ndef constComp (X : C) (F : C â¥¤ D) : (const J).obj X â‹™ F â‰… (const J).obj (F.obj X) where\n  hom := { app := fun _ => ðŸ™ _ }\n  inv := { app := fun _ => ðŸ™ _ }\n\n"}
{"name":"CategoryTheory.Functor.constComp_inv_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nD : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} D\nX : C\nF : CategoryTheory.Functor C D\nxâœ : J\nâŠ¢ Eq ((CategoryTheory.Functor.constComp J X F).inv.app xâœ) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const J).obj (F.obj X)).obj xâœ))","decl":"/-- These are actually equal, of course, but not definitionally equal\n  (the equality requires F.map (ðŸ™ _) = ðŸ™ _). A natural isomorphism is\n  more convenient than an equality between functors (compare id_to_iso). -/\n@[simps]\ndef constComp (X : C) (F : C â¥¤ D) : (const J).obj X â‹™ F â‰… (const J).obj (F.obj X) where\n  hom := { app := fun _ => ðŸ™ _ }\n  inv := { app := fun _ => ðŸ™ _ }\n\n"}
{"name":"CategoryTheory.Functor.instFaithfulConstOfNonempty","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\ninstâœ : Nonempty J\nâŠ¢ (CategoryTheory.Functor.const J).Faithful","decl":"/-- If `J` is nonempty, then the constant functor over `J` is faithful. -/\ninstance [Nonempty J] : Faithful (const J : C â¥¤ J â¥¤ C) where\n  map_injective e := NatTrans.congr_app e (Classical.arbitrary J)\n\n"}
{"name":"CategoryTheory.Functor.compConstIso_inv_app_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nD : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} D\nF : CategoryTheory.Functor C D\nXâœ : C\nX : J\nâŠ¢ Eq (((CategoryTheory.Functor.compConstIso J F).inv.app Xâœ).app X) (CategoryTheory.CategoryStruct.id (F.obj Xâœ))","decl":"/-- The canonical isomorphism\n`F â‹™ Functor.const J â‰… Functor.const F â‹™ (whiskeringRight J _ _).obj L`. -/\n@[simps!]\ndef compConstIso (F : C â¥¤ D) :\n    F â‹™ Functor.const J â‰… Functor.const J â‹™ (whiskeringRight J C D).obj F :=\n  NatIso.ofComponents\n    (fun X => NatIso.ofComponents (fun _ => Iso.refl _) (by simp))\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.compConstIso_hom_app_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nD : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} D\nF : CategoryTheory.Functor C D\nXâœ : C\nX : J\nâŠ¢ Eq (((CategoryTheory.Functor.compConstIso J F).hom.app Xâœ).app X) (CategoryTheory.CategoryStruct.id (F.obj Xâœ))","decl":"/-- The canonical isomorphism\n`F â‹™ Functor.const J â‰… Functor.const F â‹™ (whiskeringRight J _ _).obj L`. -/\n@[simps!]\ndef compConstIso (F : C â¥¤ D) :\n    F â‹™ Functor.const J â‰… Functor.const J â‹™ (whiskeringRight J C D).obj F :=\n  NatIso.ofComponents\n    (fun X => NatIso.ofComponents (fun _ => Iso.refl _) (by simp))\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.constCompWhiskeringLeftIso_inv_app_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nD : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} D\nF : CategoryTheory.Functor J D\nXâœ : C\nX : J\nâŠ¢ Eq (((CategoryTheory.Functor.constCompWhiskeringLeftIso J F).inv.app Xâœ).app X) (CategoryTheory.CategoryStruct.id Xâœ)","decl":"/-- The canonical isomorphism\n`const D â‹™ (whiskeringLeft J _ _).obj F â‰… const J`.-/\n@[simps!]\ndef constCompWhiskeringLeftIso (F : J â¥¤ D) :\n    const D â‹™ (whiskeringLeft J D C).obj F â‰… const J :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.constCompWhiskeringLeftIso_hom_app_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\nC : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} C\nD : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} D\nF : CategoryTheory.Functor J D\nXâœ : C\nX : J\nâŠ¢ Eq (((CategoryTheory.Functor.constCompWhiskeringLeftIso J F).hom.app Xâœ).app X) (CategoryTheory.CategoryStruct.id Xâœ)","decl":"/-- The canonical isomorphism\n`const D â‹™ (whiskeringLeft J _ _).obj F â‰… const J`.-/\n@[simps!]\ndef constCompWhiskeringLeftIso (F : J â¥¤ D) :\n    const D â‹™ (whiskeringLeft J D C).obj F â‰… const J :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => Iso.refl _\n\n"}
