{"name":"CategoryTheory.Functor.const_obj_obj","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nX : C\nx‚úù : J\n‚ä¢ Eq (((CategoryTheory.Functor.const J).obj X).obj x‚úù) X","decl":"/-- The functor sending `X : C` to the constant functor `J ‚•§ C` sending everything to `X`.\n-/\n@[simps]\ndef const : C ‚•§ J ‚•§ C where\n  obj X :=\n    { obj := fun _ => X\n      map := fun _ => ùüô X }\n  map f := { app := fun _ => f }\n\n"}
{"name":"CategoryTheory.Functor.const_obj_map","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nX : C\nX‚úù Y‚úù : J\nx‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.Functor.const J).obj X).map x‚úù) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The functor sending `X : C` to the constant functor `J ‚•§ C` sending everything to `X`.\n-/\n@[simps]\ndef const : C ‚•§ J ‚•§ C where\n  obj X :=\n    { obj := fun _ => X\n      map := fun _ => ùüô X }\n  map f := { app := fun _ => f }\n\n"}
{"name":"CategoryTheory.Functor.const_map_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : J\n‚ä¢ Eq (((CategoryTheory.Functor.const J).map f).app x‚úù) f","decl":"/-- The functor sending `X : C` to the constant functor `J ‚•§ C` sending everything to `X`.\n-/\n@[simps]\ndef const : C ‚•§ J ‚•§ C where\n  obj X :=\n    { obj := fun _ => X\n      map := fun _ => ùüô X }\n  map f := { app := fun _ => f }\n\n"}
{"name":"CategoryTheory.Functor.const.opObjOp_inv_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nX : C\nx‚úù : Opposite J\n‚ä¢ Eq ((CategoryTheory.Functor.const.opObjOp X).inv.app x‚úù) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const J).obj X).op.obj x‚úù))","decl":"/-- The constant functor `J·µí·µñ ‚•§ C·µí·µñ` sending everything to `op X`\nis (naturally isomorphic to) the opposite of the constant functor `J ‚•§ C` sending everything to `X`.\n-/\n@[simps]\ndef opObjOp (X : C) : (const J·µí·µñ).obj (op X) ‚âÖ ((const J).obj X).op where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Functor.const.opObjOp_hom_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nX : C\nx‚úù : Opposite J\n‚ä¢ Eq ((CategoryTheory.Functor.const.opObjOp X).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const (Opposite J)).obj { unop := X }).obj x‚úù))","decl":"/-- The constant functor `J·µí·µñ ‚•§ C·µí·µñ` sending everything to `op X`\nis (naturally isomorphic to) the opposite of the constant functor `J ‚•§ C` sending everything to `X`.\n-/\n@[simps]\ndef opObjOp (X : C) : (const J·µí·µñ).obj (op X) ‚âÖ ((const J).obj X).op where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Functor.const.opObjUnop_hom_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nX : Opposite C\nj : Opposite J\n‚ä¢ Eq ((CategoryTheory.Functor.const.opObjUnop X).hom.app j) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const (Opposite J)).obj (Opposite.unop X)).obj j))","decl":"@[simp]\ntheorem opObjUnop_hom_app (X : C·µí·µñ) (j : J·µí·µñ) : (opObjUnop.{v‚ÇÅ, v‚ÇÇ} X).hom.app j = ùüô _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.const.opObjUnop_inv_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nX : Opposite C\nj : Opposite J\n‚ä¢ Eq ((CategoryTheory.Functor.const.opObjUnop X).inv.app j) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const J).obj X).leftOp.obj j))","decl":"@[simp]\ntheorem opObjUnop_inv_app (X : C·µí·µñ) (j : J·µí·µñ) : (opObjUnop.{v‚ÇÅ, v‚ÇÇ} X).inv.app j = ùüô _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.const.unop_functor_op_obj_map","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nX : Opposite C\nj‚ÇÅ j‚ÇÇ : J\nf : Quiver.Hom j‚ÇÅ j‚ÇÇ\n‚ä¢ Eq ((Opposite.unop ((CategoryTheory.Functor.const J).op.obj X)).map f) (CategoryTheory.CategoryStruct.id (Opposite.unop X))","decl":"@[simp]\ntheorem unop_functor_op_obj_map (X : C·µí·µñ) {j‚ÇÅ j‚ÇÇ : J} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) :\n    (unop ((Functor.op (const J)).obj X)).map f = ùüô (unop X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.constComp_hom_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} D\nX : C\nF : CategoryTheory.Functor C D\nx‚úù : J\n‚ä¢ Eq ((CategoryTheory.Functor.constComp J X F).hom.app x‚úù) (CategoryTheory.CategoryStruct.id ((((CategoryTheory.Functor.const J).obj X).comp F).obj x‚úù))","decl":"/-- These are actually equal, of course, but not definitionally equal\n  (the equality requires F.map (ùüô _) = ùüô _). A natural isomorphism is\n  more convenient than an equality between functors (compare id_to_iso). -/\n@[simps]\ndef constComp (X : C) (F : C ‚•§ D) : (const J).obj X ‚ãô F ‚âÖ (const J).obj (F.obj X) where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Functor.constComp_inv_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} D\nX : C\nF : CategoryTheory.Functor C D\nx‚úù : J\n‚ä¢ Eq ((CategoryTheory.Functor.constComp J X F).inv.app x‚úù) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.const J).obj (F.obj X)).obj x‚úù))","decl":"/-- These are actually equal, of course, but not definitionally equal\n  (the equality requires F.map (ùüô _) = ùüô _). A natural isomorphism is\n  more convenient than an equality between functors (compare id_to_iso). -/\n@[simps]\ndef constComp (X : C) (F : C ‚•§ D) : (const J).obj X ‚ãô F ‚âÖ (const J).obj (F.obj X) where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Functor.instFaithfulConstOfNonempty","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\ninst‚úù : Nonempty J\n‚ä¢ (CategoryTheory.Functor.const J).Faithful","decl":"/-- If `J` is nonempty, then the constant functor over `J` is faithful. -/\ninstance [Nonempty J] : Faithful (const J : C ‚•§ J ‚•§ C) where\n  map_injective e := NatTrans.congr_app e (Classical.arbitrary J)\n\n"}
{"name":"CategoryTheory.Functor.compConstIso_inv_app_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} D\nF : CategoryTheory.Functor C D\nX‚úù : C\nX : J\n‚ä¢ Eq (((CategoryTheory.Functor.compConstIso J F).inv.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (F.obj X‚úù))","decl":"/-- The canonical isomorphism\n`F ‚ãô Functor.const J ‚âÖ Functor.const F ‚ãô (whiskeringRight J _ _).obj L`. -/\n@[simps!]\ndef compConstIso (F : C ‚•§ D) :\n    F ‚ãô Functor.const J ‚âÖ Functor.const J ‚ãô (whiskeringRight J C D).obj F :=\n  NatIso.ofComponents\n    (fun X => NatIso.ofComponents (fun _ => Iso.refl _) (by simp))\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.compConstIso_hom_app_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} D\nF : CategoryTheory.Functor C D\nX‚úù : C\nX : J\n‚ä¢ Eq (((CategoryTheory.Functor.compConstIso J F).hom.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (F.obj X‚úù))","decl":"/-- The canonical isomorphism\n`F ‚ãô Functor.const J ‚âÖ Functor.const F ‚ãô (whiskeringRight J _ _).obj L`. -/\n@[simps!]\ndef compConstIso (F : C ‚•§ D) :\n    F ‚ãô Functor.const J ‚âÖ Functor.const J ‚ãô (whiskeringRight J C D).obj F :=\n  NatIso.ofComponents\n    (fun X => NatIso.ofComponents (fun _ => Iso.refl _) (by simp))\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Functor.constCompWhiskeringLeftIso_inv_app_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} D\nF : CategoryTheory.Functor J D\nX‚úù : C\nX : J\n‚ä¢ Eq (((CategoryTheory.Functor.constCompWhiskeringLeftIso J F).inv.app X‚úù).app X) (CategoryTheory.CategoryStruct.id X‚úù)","decl":"/-- The canonical isomorphism\n`const D ‚ãô (whiskeringLeft J _ _).obj F ‚âÖ const J`.-/\n@[simps!]\ndef constCompWhiskeringLeftIso (F : J ‚•§ D) :\n    const D ‚ãô (whiskeringLeft J D C).obj F ‚âÖ const J :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.constCompWhiskeringLeftIso_hom_app_app","module":"Mathlib.CategoryTheory.Functor.Const","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nD : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} D\nF : CategoryTheory.Functor J D\nX‚úù : C\nX : J\n‚ä¢ Eq (((CategoryTheory.Functor.constCompWhiskeringLeftIso J F).hom.app X‚úù).app X) (CategoryTheory.CategoryStruct.id X‚úù)","decl":"/-- The canonical isomorphism\n`const D ‚ãô (whiskeringLeft J _ _).obj F ‚âÖ const J`.-/\n@[simps!]\ndef constCompWhiskeringLeftIso (F : J ‚•§ D) :\n    const D ‚ãô (whiskeringLeft J D C).obj F ‚âÖ const J :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => Iso.refl _\n\n"}
