{"name":"List.Palindrome.brecOn","module":"Mathlib.Data.List.Palindrome","initialProofState":"α : Type u_1\nmotive✝ : (a : List α) → a.Palindrome → Prop\na✝ : List α\nx✝ : a✝.Palindrome\nih✝ : ∀ (a : List α) (x : a.Palindrome), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- `Palindrome l` asserts that `l` is a palindrome. This is defined inductively:\n\n* The empty list is a palindrome;\n* A list with one element is a palindrome;\n* Adding the same element to both ends of a palindrome results in a bigger palindrome.\n-/\ninductive Palindrome : List α → Prop\n  | nil : Palindrome []\n  | singleton : ∀ x, Palindrome [x]\n  | cons_concat : ∀ (x) {l}, Palindrome l → Palindrome (x :: (l ++ [x]))\n\n"}
{"name":"List.Palindrome.reverse_eq","module":"Mathlib.Data.List.Palindrome","initialProofState":"α : Type u_1\nl : List α\np : l.Palindrome\n⊢ Eq l.reverse l","decl":"theorem reverse_eq {l : List α} (p : Palindrome l) : reverse l = l := by\n  induction p <;> try (exact rfl)\n  simpa\n\n"}
{"name":"List.Palindrome.of_reverse_eq","module":"Mathlib.Data.List.Palindrome","initialProofState":"α : Type u_1\nl : List α\na✝ : Eq l.reverse l\n⊢ l.Palindrome","decl":"theorem of_reverse_eq {l : List α} : reverse l = l → Palindrome l := by\n  refine bidirectionalRecOn l (fun _ => Palindrome.nil) (fun a _ => Palindrome.singleton a) ?_\n  intro x l y hp hr\n  rw [reverse_cons, reverse_append] at hr\n  rw [head_eq_of_cons_eq hr]\n  have : Palindrome l := hp (append_inj_left' (tail_eq_of_cons_eq hr) rfl)\n  exact Palindrome.cons_concat x this\n\n"}
{"name":"List.Palindrome.iff_reverse_eq","module":"Mathlib.Data.List.Palindrome","initialProofState":"α : Type u_1\nl : List α\n⊢ Iff l.Palindrome (Eq l.reverse l)","decl":"theorem iff_reverse_eq {l : List α} : Palindrome l ↔ reverse l = l :=\n  Iff.intro reverse_eq of_reverse_eq\n\n"}
{"name":"List.Palindrome.append_reverse","module":"Mathlib.Data.List.Palindrome","initialProofState":"α : Type u_1\nl : List α\n⊢ (HAppend.hAppend l l.reverse).Palindrome","decl":"theorem append_reverse (l : List α) : Palindrome (l ++ reverse l) := by\n  apply of_reverse_eq\n  rw [reverse_append, reverse_reverse]\n\n"}
{"name":"List.Palindrome.map","module":"Mathlib.Data.List.Palindrome","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf : α → β\np : l.Palindrome\n⊢ (List.map f l).Palindrome","decl":"protected theorem map (f : α → β) (p : Palindrome l) : Palindrome (map f l) :=\n  of_reverse_eq <| by rw [← map_reverse, p.reverse_eq]\n\n"}
