{"name":"Cardinal.ofENat_top","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ Eq (↑Top.top) Cardinal.aleph0","decl":"@[simp, norm_cast] lemma ofENat_top : ofENat ⊤ = ℵ₀ := rfl\n"}
{"name":"Cardinal.ofENat_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"n : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast] lemma ofENat_nat (n : ℕ) : ofENat n = n := rfl\n"}
{"name":"Cardinal.ofENat_zero","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp, norm_cast] lemma ofENat_zero : ofENat 0 = 0 := rfl\n"}
{"name":"Cardinal.ofENat_one","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast] lemma ofENat_one : ofENat 1 = 1 := rfl\n\n"}
{"name":"Cardinal.ofENat_ofNat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast] lemma ofENat_ofNat (n : ℕ) [n.AtLeastTwo] :\n    ((ofNat(n) : ℕ∞) : Cardinal) = OfNat.ofNat n :=\n  rfl\n\n"}
{"name":"Cardinal.ofENat_strictMono","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ StrictMono Cardinal.ofENat","decl":"lemma ofENat_strictMono : StrictMono ofENat :=\n  WithTop.strictMono_iff.2 ⟨Nat.strictMono_cast, nat_lt_aleph0⟩\n\n"}
{"name":"Cardinal.ofENat_lt_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m n : ENat\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[simp, norm_cast]\nlemma ofENat_lt_ofENat {m n : ℕ∞} : (m : Cardinal) < n ↔ m < n :=\n  ofENat_strictMono.lt_iff_lt\n\n"}
{"name":"Cardinal.ofENat_lt_ofENat_of_lt","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m n : ENat\na✝ : LT.lt m n\n⊢ LT.lt ↑m ↑n","decl":"@[gcongr, mono] alias ⟨_, ofENat_lt_ofENat_of_lt⟩ := ofENat_lt_ofENat\n\n"}
{"name":"Cardinal.ofENat_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Iff (LT.lt (↑m) Cardinal.aleph0) (LT.lt m Top.top)","decl":"@[simp, norm_cast]\nlemma ofENat_lt_aleph0 {m : ℕ∞} : (m : Cardinal) < ℵ₀ ↔ m < ⊤ :=\n  ofENat_lt_ofENat (n := ⊤)\n\n"}
{"name":"Cardinal.ofENat_lt_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\nn : Nat\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m ↑n)","decl":"@[simp] lemma ofENat_lt_nat {m : ℕ∞} {n : ℕ} : ofENat m < n ↔ m < n := by norm_cast\n\n"}
{"name":"Cardinal.ofENat_lt_ofNat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LT.lt (↑m) (OfNat.ofNat n)) (LT.lt m (OfNat.ofNat n))","decl":"@[simp] lemma ofENat_lt_ofNat {m : ℕ∞} {n : ℕ} [n.AtLeastTwo] :\n    ofENat m < ofNat(n) ↔ m < OfNat.ofNat n := ofENat_lt_nat\n\n"}
{"name":"Cardinal.nat_lt_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : Nat\nn : ENat\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt (↑m) n)","decl":"@[simp] lemma nat_lt_ofENat {m : ℕ} {n : ℕ∞} : (m : Cardinal) < n ↔ m < n := by norm_cast\n"}
{"name":"Cardinal.ofENat_pos","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Iff (LT.lt 0 ↑m) (LT.lt 0 m)","decl":"@[simp] lemma ofENat_pos {m : ℕ∞} : 0 < (m : Cardinal) ↔ 0 < m := by norm_cast\n"}
{"name":"Cardinal.one_lt_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Iff (LT.lt 1 ↑m) (LT.lt 1 m)","decl":"@[simp] lemma one_lt_ofENat {m : ℕ∞} : 1 < (m : Cardinal) ↔ 1 < m := by norm_cast\n\n"}
{"name":"Cardinal.ofNat_lt_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : Nat\ninst✝ : m.AtLeastTwo\nn : ENat\n⊢ Iff (LT.lt (OfNat.ofNat m) ↑n) (LT.lt (OfNat.ofNat m) n)","decl":"@[simp, norm_cast] lemma ofNat_lt_ofENat {m : ℕ} [m.AtLeastTwo] {n : ℕ∞} :\n  (ofNat(m) : Cardinal) < n ↔ OfNat.ofNat m < n := nat_lt_ofENat\n\n"}
{"name":"Cardinal.ofENat_mono","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ Monotone Cardinal.ofENat","decl":"lemma ofENat_mono : Monotone ofENat := ofENat_strictMono.monotone\n\n"}
{"name":"Cardinal.ofENat_le_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m n : ENat\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[simp, norm_cast]\nlemma ofENat_le_ofENat {m n : ℕ∞} : (m : Cardinal) ≤ n ↔ m ≤ n := ofENat_strictMono.le_iff_le\n\n"}
{"name":"Cardinal.ofENat_le_ofENat_of_le","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m n : ENat\na✝ : LE.le m n\n⊢ LE.le ↑m ↑n","decl":"@[gcongr, mono] alias ⟨_, ofENat_le_ofENat_of_le⟩ := ofENat_le_ofENat\n\n"}
{"name":"Cardinal.ofENat_le_aleph0","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"n : ENat\n⊢ LE.le (↑n) Cardinal.aleph0","decl":"@[simp] lemma ofENat_le_aleph0 (n : ℕ∞) : ↑n ≤ ℵ₀ := ofENat_le_ofENat.2 le_top\n"}
{"name":"Cardinal.ofENat_le_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\nn : Nat\n⊢ Iff (LE.le ↑m ↑n) (LE.le m ↑n)","decl":"@[simp] lemma ofENat_le_nat {m : ℕ∞} {n : ℕ} : ofENat m ≤ n ↔ m ≤ n := by norm_cast\n"}
{"name":"Cardinal.ofENat_le_one","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Iff (LE.le (↑m) 1) (LE.le m 1)","decl":"@[simp] lemma ofENat_le_one {m : ℕ∞} : ofENat m ≤ 1 ↔ m ≤ 1 := by norm_cast\n\n"}
{"name":"Cardinal.ofENat_le_ofNat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le (↑m) (OfNat.ofNat n)) (LE.le m (OfNat.ofNat n))","decl":"@[simp] lemma ofENat_le_ofNat {m : ℕ∞} {n : ℕ} [n.AtLeastTwo] :\n    ofENat m ≤ ofNat(n) ↔ m ≤ OfNat.ofNat n := ofENat_le_nat\n\n"}
{"name":"Cardinal.nat_le_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : Nat\nn : ENat\n⊢ Iff (LE.le ↑m ↑n) (LE.le (↑m) n)","decl":"@[simp] lemma nat_le_ofENat {m : ℕ} {n : ℕ∞} : (m : Cardinal) ≤ n ↔ m ≤ n := by norm_cast\n"}
{"name":"Cardinal.one_le_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"n : ENat\n⊢ Iff (LE.le 1 ↑n) (LE.le 1 n)","decl":"@[simp] lemma one_le_ofENat {n : ℕ∞} : 1 ≤ (n : Cardinal) ↔ 1 ≤ n := by norm_cast\n\n"}
{"name":"Cardinal.ofNat_le_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : Nat\ninst✝ : m.AtLeastTwo\nn : ENat\n⊢ Iff (LE.le (OfNat.ofNat m) ↑n) (LE.le (OfNat.ofNat m) n)","decl":"@[simp]\nlemma ofNat_le_ofENat {m : ℕ} [m.AtLeastTwo] {n : ℕ∞} :\n    (ofNat(m) : Cardinal) ≤ n ↔ OfNat.ofNat m ≤ n := nat_le_ofENat\n\n"}
{"name":"Cardinal.ofENat_injective","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ Function.Injective Cardinal.ofENat","decl":"lemma ofENat_injective : Injective ofENat := ofENat_strictMono.injective\n\n"}
{"name":"Cardinal.ofENat_inj","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m n : ENat\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[simp, norm_cast]\nlemma ofENat_inj {m n : ℕ∞} : (m : Cardinal) = n ↔ m = n := ofENat_injective.eq_iff\n\n"}
{"name":"Cardinal.ofENat_eq_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\nn : Nat\n⊢ Iff (Eq ↑m ↑n) (Eq m ↑n)","decl":"@[simp] lemma ofENat_eq_nat {m : ℕ∞} {n : ℕ} : (m : Cardinal) = n ↔ m = n := by norm_cast\n"}
{"name":"Cardinal.nat_eq_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : Nat\nn : ENat\n⊢ Iff (Eq ↑m ↑n) (Eq (↑m) n)","decl":"@[simp] lemma nat_eq_ofENat {m : ℕ} {n : ℕ∞} : (m : Cardinal) = n ↔ m = n := by norm_cast\n\n"}
{"name":"Cardinal.ofENat_eq_zero","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Iff (Eq (↑m) 0) (Eq m 0)","decl":"@[simp] lemma ofENat_eq_zero {m : ℕ∞} : (m : Cardinal) = 0 ↔ m = 0 := by norm_cast\n"}
{"name":"Cardinal.zero_eq_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Iff (Eq 0 ↑m) (Eq m 0)","decl":"@[simp] lemma zero_eq_ofENat {m : ℕ∞} : 0 = (m : Cardinal) ↔ m = 0 := by norm_cast; apply eq_comm\n\n"}
{"name":"Cardinal.ofENat_eq_one","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Iff (Eq (↑m) 1) (Eq m 1)","decl":"@[simp] lemma ofENat_eq_one {m : ℕ∞} : (m : Cardinal) = 1 ↔ m = 1 := by norm_cast\n"}
{"name":"Cardinal.one_eq_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Iff (Eq 1 ↑m) (Eq m 1)","decl":"@[simp] lemma one_eq_ofENat {m : ℕ∞} : 1 = (m : Cardinal) ↔ m = 1 := by norm_cast; apply eq_comm\n\n"}
{"name":"Cardinal.ofENat_eq_ofNat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (Eq (↑m) (OfNat.ofNat n)) (Eq m (OfNat.ofNat n))","decl":"@[simp] lemma ofENat_eq_ofNat {m : ℕ∞} {n : ℕ} [n.AtLeastTwo] :\n    (m : Cardinal) = ofNat(n) ↔ m = OfNat.ofNat n := ofENat_eq_nat\n\n"}
{"name":"Cardinal.ofNat_eq_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : Nat\nn : ENat\ninst✝ : m.AtLeastTwo\n⊢ Iff (Eq (OfNat.ofNat m) ↑n) (Eq (OfNat.ofNat m) n)","decl":"@[simp] lemma ofNat_eq_ofENat {m : ℕ} {n : ℕ∞} [m.AtLeastTwo] :\n    ofNat(m) = (n : Cardinal) ↔ OfNat.ofNat m = n := nat_eq_ofENat\n\n"}
{"name":"Cardinal.lift_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Eq (Cardinal.lift.{u, v} ↑m) ↑m","decl":"@[simp, norm_cast] lemma lift_ofENat : ∀ m : ℕ∞, lift.{u, v} m = m\n  | (m : ℕ) => lift_natCast m\n  | ⊤ => lift_aleph0\n\n"}
{"name":"Cardinal.lift_lt_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"x : Cardinal.{v}\nm : ENat\n⊢ Iff (LT.lt (Cardinal.lift.{u, v} x) ↑m) (LT.lt x ↑m)","decl":"@[simp] lemma lift_lt_ofENat {x : Cardinal.{v}} {m : ℕ∞} : lift.{u} x < m ↔ x < m := by\n  rw [← lift_ofENat.{u, v}, lift_lt]\n\n"}
{"name":"Cardinal.lift_le_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"x : Cardinal.{v}\nm : ENat\n⊢ Iff (LE.le (Cardinal.lift.{u, v} x) ↑m) (LE.le x ↑m)","decl":"@[simp] lemma lift_le_ofENat {x : Cardinal.{v}} {m : ℕ∞} : lift.{u} x ≤ m ↔ x ≤ m := by\n  rw [← lift_ofENat.{u, v}, lift_le]\n\n"}
{"name":"Cardinal.lift_eq_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"x : Cardinal.{v}\nm : ENat\n⊢ Iff (Eq (Cardinal.lift.{u, v} x) ↑m) (Eq x ↑m)","decl":"@[simp] lemma lift_eq_ofENat {x : Cardinal.{v}} {m : ℕ∞} : lift.{u} x = m ↔ x = m := by\n  rw [← lift_ofENat.{u, v}, lift_inj]\n\n"}
{"name":"Cardinal.ofENat_lt_lift","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"x : Cardinal.{v}\nm : ENat\n⊢ Iff (LT.lt (↑m) (Cardinal.lift.{u, v} x)) (LT.lt (↑m) x)","decl":"@[simp] lemma ofENat_lt_lift {x : Cardinal.{v}} {m : ℕ∞} : m < lift.{u} x ↔ m < x := by\n  rw [← lift_ofENat.{u, v}, lift_lt]\n\n"}
{"name":"Cardinal.ofENat_le_lift","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"x : Cardinal.{v}\nm : ENat\n⊢ Iff (LE.le (↑m) (Cardinal.lift.{u, v} x)) (LE.le (↑m) x)","decl":"@[simp] lemma ofENat_le_lift {x : Cardinal.{v}} {m : ℕ∞} : m ≤ lift.{u} x ↔ m ≤ x := by\n  rw [← lift_ofENat.{u, v}, lift_le]\n\n"}
{"name":"Cardinal.ofENat_eq_lift","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"x : Cardinal.{v}\nm : ENat\n⊢ Iff (Eq (↑m) (Cardinal.lift.{u, v} x)) (Eq (↑m) x)","decl":"@[simp] lemma ofENat_eq_lift {x : Cardinal.{v}} {m : ℕ∞} : m = lift.{u} x ↔ m = x := by\n  rw [← lift_ofENat.{u, v}, lift_inj]\n\n"}
{"name":"Cardinal.range_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ Eq (Set.range Cardinal.ofENat) (Set.Iic Cardinal.aleph0)","decl":"@[simp]\nlemma range_ofENat : range ofENat = Iic ℵ₀ := by\n  refine (range_subset_iff.2 ofENat_le_aleph0).antisymm fun x (hx : x ≤ ℵ₀) ↦ ?_\n  rcases hx.lt_or_eq with hlt | rfl\n  · lift x to ℕ using hlt\n    exact mem_range_self (x : ℕ∞)\n  · exact mem_range_self (⊤ : ℕ∞)\n\n"}
{"name":"Cardinal.instCanLiftENatOfENatLeAleph0","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ CanLift Cardinal.{u_1} ENat Cardinal.ofENat fun x => LE.le x Cardinal.aleph0","decl":"instance : CanLift Cardinal ℕ∞ (↑) (· ≤ ℵ₀) where\n  prf x := (Set.ext_iff.1 range_ofENat x).2\n\n"}
{"name":"Cardinal.toENatAux_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"n : Nat\n⊢ Eq (↑n).toENatAux ↑n","decl":"lemma toENatAux_nat (n : ℕ) : toENatAux n = n := Nat.cast_injective.extend_apply ..\n"}
{"name":"Cardinal.toENatAux_zero","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ Eq (Cardinal.toENatAux 0) 0","decl":"lemma toENatAux_zero : toENatAux 0 = 0 := toENatAux_nat 0\n\n"}
{"name":"Cardinal.toENatAux_eq_top","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 a\n⊢ Eq a.toENatAux Top.top","decl":"lemma toENatAux_eq_top {a : Cardinal} (ha : ℵ₀ ≤ a) : toENatAux a = ⊤ :=\n  extend_apply' _ _ _ fun ⟨n, hn⟩ ↦ ha.not_lt <| hn ▸ nat_lt_aleph0 n\n\n"}
{"name":"Cardinal.toENatAux_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"n : ENat\n⊢ Eq (↑n).toENatAux n","decl":"lemma toENatAux_ofENat : ∀ n : ℕ∞, toENatAux n = n\n  | (n : ℕ) => toENatAux_nat n\n  | ⊤ => toENatAux_eq_top le_rfl\n\n"}
{"name":"Cardinal.toENatAux_gc","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ GaloisConnection Cardinal.ofENat Cardinal.toENatAux","decl":"lemma toENatAux_gc : GaloisConnection (↑) toENatAux := fun n x ↦ by\n  cases lt_or_le x ℵ₀ with\n  | inl hx => lift x to ℕ using hx; simp\n  | inr hx => simp [toENatAux_eq_top hx, (ofENat_le_aleph0 n).trans hx]\n\n"}
{"name":"Cardinal.toENatAux_le_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"x : Cardinal.{u_1}\nn : Nat\n⊢ Iff (LE.le x.toENatAux ↑n) (LE.le x ↑n)","decl":"theorem toENatAux_le_nat {x : Cardinal} {n : ℕ} : toENatAux x ≤ n ↔ x ≤ n := by\n  cases lt_or_le x ℵ₀ with\n  | inl hx => lift x to ℕ using hx; simp\n  | inr hx => simp [toENatAux_eq_top hx, (nat_lt_aleph0 n).trans_le hx]\n\n"}
{"name":"Cardinal.toENatAux_eq_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"x : Cardinal.{u_1}\nn : Nat\n⊢ Iff (Eq x.toENatAux ↑n) (Eq x ↑n)","decl":"lemma toENatAux_eq_nat {x : Cardinal} {n : ℕ} : toENatAux x = n ↔ x = n := by\n  simp only [le_antisymm_iff, toENatAux_le_nat, ← toENatAux_gc _, ofENat_nat]\n\n"}
{"name":"Cardinal.toENatAux_eq_zero","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"x : Cardinal.{u_1}\n⊢ Iff (Eq x.toENatAux 0) (Eq x 0)","decl":"lemma toENatAux_eq_zero {x : Cardinal} : toENatAux x = 0 ↔ x = 0 := toENatAux_eq_nat\n\n"}
{"name":"Cardinal.enat_gc","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ GaloisConnection Cardinal.ofENat ⇑Cardinal.toENat","decl":"/-- The coercion `Cardinal.ofENat` and the projection `Cardinal.toENat` form a Galois connection.\nSee also `Cardinal.gciENat`. -/\nlemma enat_gc : GaloisConnection (↑) toENat := toENatAux_gc\n\n"}
{"name":"Cardinal.toENat_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"n : ENat\n⊢ Eq (Cardinal.toENat ↑n) n","decl":"@[simp] lemma toENat_ofENat (n : ℕ∞) : toENat n = n := toENatAux_ofENat n\n"}
{"name":"Cardinal.toENat_comp_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ Eq (Function.comp (⇑Cardinal.toENat) Cardinal.ofENat) id","decl":"@[simp] lemma toENat_comp_ofENat : toENat ∘ (↑) = id := funext toENat_ofENat\n\n"}
{"name":"Cardinal.toENat_strictMonoOn","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ StrictMonoOn (⇑Cardinal.toENat) (Set.Iic Cardinal.aleph0)","decl":"lemma toENat_strictMonoOn : StrictMonoOn toENat (Iic ℵ₀) := by\n  simp only [← range_ofENat, StrictMonoOn, forall_mem_range, toENat_ofENat, ofENat_lt_ofENat]\n  exact fun _ _ ↦ id\n\n"}
{"name":"Cardinal.toENat_injOn","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"⊢ Set.InjOn (⇑Cardinal.toENat) (Set.Iic Cardinal.aleph0)","decl":"lemma toENat_injOn : InjOn toENat (Iic ℵ₀) := toENat_strictMonoOn.injOn\n\n"}
{"name":"Cardinal.ofENat_toENat_le","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\n⊢ LE.le (↑(Cardinal.toENat a)) a","decl":"lemma ofENat_toENat_le (a : Cardinal) : ↑(toENat a) ≤ a := enat_gc.l_u_le _\n\n"}
{"name":"Cardinal.ofENat_toENat_eq_self","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (Eq (↑(Cardinal.toENat a)) a) (LE.le a Cardinal.aleph0)","decl":"@[simp]\nlemma ofENat_toENat_eq_self {a : Cardinal} : toENat a = a ↔ a ≤ ℵ₀ := by\n  rw [eq_comm, ← enat_gc.exists_eq_l]\n  simpa only [mem_range, eq_comm] using Set.ext_iff.1 range_ofENat a\n\n"}
{"name":"Cardinal.ofENat_toENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\na✝ : LE.le a Cardinal.aleph0\n⊢ Eq (↑(Cardinal.toENat a)) a","decl":"@[simp] alias ⟨_, ofENat_toENat⟩ := ofENat_toENat_eq_self\n\n"}
{"name":"Cardinal.toENat_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"n : Nat\n⊢ Eq (Cardinal.toENat ↑n) ↑n","decl":"lemma toENat_nat (n : ℕ) : toENat n = n := map_natCast _ n\n\n"}
{"name":"Cardinal.toENat_le_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\nn : Nat\n⊢ Iff (LE.le (Cardinal.toENat a) ↑n) (LE.le a ↑n)","decl":"@[simp] lemma toENat_le_nat {a : Cardinal} {n : ℕ} : toENat a ≤ n ↔ a ≤ n := toENatAux_le_nat\n"}
{"name":"Cardinal.toENat_eq_nat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\nn : Nat\n⊢ Iff (Eq (Cardinal.toENat a) ↑n) (Eq a ↑n)","decl":"@[simp] lemma toENat_eq_nat {a : Cardinal} {n : ℕ} : toENat a = n ↔ a = n := toENatAux_eq_nat\n"}
{"name":"Cardinal.toENat_eq_zero","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (Eq (Cardinal.toENat a) 0) (Eq a 0)","decl":"@[simp] lemma toENat_eq_zero {a : Cardinal} : toENat a = 0 ↔ a = 0 := toENatAux_eq_zero\n"}
{"name":"Cardinal.toENat_le_one","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (LE.le (Cardinal.toENat a) 1) (LE.le a 1)","decl":"@[simp] lemma toENat_le_one {a : Cardinal} : toENat a ≤ 1 ↔ a ≤ 1 := toENat_le_nat\n"}
{"name":"Cardinal.toENat_eq_one","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (Eq (Cardinal.toENat a) 1) (Eq a 1)","decl":"@[simp] lemma toENat_eq_one {a : Cardinal} : toENat a = 1 ↔ a = 1 := toENat_eq_nat\n\n"}
{"name":"Cardinal.toENat_le_ofNat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le (Cardinal.toENat a) (OfNat.ofNat n)) (LE.le a (OfNat.ofNat n))","decl":"@[simp] lemma toENat_le_ofNat {a : Cardinal} {n : ℕ} [n.AtLeastTwo] :\n    toENat a ≤ ofNat(n) ↔ a ≤ OfNat.ofNat n := toENat_le_nat\n\n"}
{"name":"Cardinal.toENat_eq_ofNat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (Eq (Cardinal.toENat a) (OfNat.ofNat n)) (Eq a (OfNat.ofNat n))","decl":"@[simp] lemma toENat_eq_ofNat {a : Cardinal} {n : ℕ} [n.AtLeastTwo] :\n    toENat a = ofNat(n) ↔ a = OfNat.ofNat n := toENat_eq_nat\n\n"}
{"name":"Cardinal.toENat_eq_top","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{u_1}\n⊢ Iff (Eq (Cardinal.toENat a) Top.top) (LE.le Cardinal.aleph0 a)","decl":"@[simp] lemma toENat_eq_top {a : Cardinal} : toENat a = ⊤ ↔ ℵ₀ ≤ a := enat_gc.u_eq_top\n\n"}
{"name":"Cardinal.toENat_lift","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"a : Cardinal.{v}\n⊢ Eq (Cardinal.toENat (Cardinal.lift.{u, v} a)) (Cardinal.toENat a)","decl":"@[simp]\ntheorem toENat_lift {a : Cardinal.{v}} : toENat (lift.{u} a) = toENat a := by\n  cases le_total a ℵ₀ with\n  | inl ha => lift a to ℕ∞ using ha; simp\n  | inr ha => simp [toENat_eq_top.2, ha]\n\n"}
{"name":"Cardinal.toENat_congr","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\n⊢ Eq (Cardinal.toENat (Cardinal.mk α)) (Cardinal.toENat (Cardinal.mk β))","decl":"theorem toENat_congr {α : Type u} {β : Type v} (e : α ≃ β) : toENat #α = toENat #β := by\n  rw [← toENat_lift, lift_mk_eq.{_, _,v}.mpr ⟨e⟩, toENat_lift]\n\n"}
{"name":"Cardinal.toENat_le_iff_of_le_aleph0","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"c c' : Cardinal.{u_1}\nh : LE.le c Cardinal.aleph0\n⊢ Iff (LE.le (Cardinal.toENat c) (Cardinal.toENat c')) (LE.le c c')","decl":"lemma toENat_le_iff_of_le_aleph0 {c c' : Cardinal} (h : c ≤ ℵ₀) :\n    toENat c ≤ toENat c' ↔ c ≤ c' := by\n  lift c to ℕ∞ using h\n  simp_rw [toENat_ofENat, enat_gc _]\n\n"}
{"name":"Cardinal.toENat_le_iff_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"c c' : Cardinal.{u_1}\nhc' : LT.lt c' Cardinal.aleph0\n⊢ Iff (LE.le (Cardinal.toENat c) (Cardinal.toENat c')) (LE.le c c')","decl":"lemma toENat_le_iff_of_lt_aleph0 {c c' : Cardinal} (hc' : c' < ℵ₀) :\n    toENat c ≤ toENat c' ↔ c ≤ c' := by\n  lift c' to ℕ using hc'\n  simp_rw [toENat_nat, ← toENat_le_nat]\n\n"}
{"name":"Cardinal.toENat_eq_iff_of_le_aleph0","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"c c' : Cardinal.{u_1}\nhc : LE.le c Cardinal.aleph0\nhc' : LE.le c' Cardinal.aleph0\n⊢ Iff (Eq (Cardinal.toENat c) (Cardinal.toENat c')) (Eq c c')","decl":"lemma toENat_eq_iff_of_le_aleph0 {c c' : Cardinal} (hc : c ≤ ℵ₀) (hc' : c' ≤ ℵ₀) :\n    toENat c = toENat c' ↔ c = c' :=\n  toENat_strictMonoOn.injOn.eq_iff hc hc'\n\n"}
{"name":"Cardinal.ofENat_add","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m n : ENat\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[simp, norm_cast]\nlemma ofENat_add (m n : ℕ∞) : ofENat (m + n) = m + n := by apply toENat_injOn <;> simp\n\n"}
{"name":"Cardinal.aleph0_add_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Eq (HAdd.hAdd Cardinal.aleph0 ↑m) Cardinal.aleph0","decl":"@[simp] lemma aleph0_add_ofENat (m : ℕ∞) : ℵ₀ + m = ℵ₀ := (ofENat_add ⊤ m).symm\n\n"}
{"name":"Cardinal.ofENat_add_aleph0","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\n⊢ Eq (HAdd.hAdd (↑m) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp] lemma ofENat_add_aleph0 (m : ℕ∞) : m + ℵ₀ = ℵ₀ := by rw [add_comm, aleph0_add_ofENat]\n\n"}
{"name":"Cardinal.ofENat_mul_aleph0","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\nhm : Ne m 0\n⊢ Eq (HMul.hMul (↑m) Cardinal.aleph0) Cardinal.aleph0","decl":"@[simp] lemma ofENat_mul_aleph0 {m : ℕ∞} (hm : m ≠ 0) : ↑m * ℵ₀ = ℵ₀ := by\n  induction m with\n  | top => exact aleph0_mul_aleph0\n  | coe m => rw [ofENat_nat, nat_mul_aleph0 (mod_cast hm)]\n\n"}
{"name":"Cardinal.aleph0_mul_ofENat","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m : ENat\nhm : Ne m 0\n⊢ Eq (HMul.hMul Cardinal.aleph0 ↑m) Cardinal.aleph0","decl":"@[simp] lemma aleph0_mul_ofENat {m : ℕ∞} (hm : m ≠ 0) : ℵ₀ * m = ℵ₀ := by\n  rw [mul_comm, ofENat_mul_aleph0 hm]\n\n"}
{"name":"Cardinal.ofENat_mul","module":"Mathlib.SetTheory.Cardinal.ENat","initialProofState":"m n : ENat\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp] lemma ofENat_mul (m n : ℕ∞) : ofENat (m * n) = m * n :=\n  toENat_injOn (by simp)\n    (aleph0_mul_aleph0 ▸ mul_le_mul' (ofENat_le_aleph0 _) (ofENat_le_aleph0 _)) (by simp)\n\n"}
