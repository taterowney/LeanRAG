{"name":"Prop.bot_eq_false","module":"Mathlib.Order.PropInstances","initialProofState":"⊢ Eq Bot.bot False","decl":"@[simp]\ntheorem Prop.bot_eq_false : (⊥ : Prop) = False :=\n  rfl\n\n"}
{"name":"Prop.top_eq_true","module":"Mathlib.Order.PropInstances","initialProofState":"⊢ Eq Top.top True","decl":"@[simp]\ntheorem Prop.top_eq_true : (⊤ : Prop) = True :=\n  rfl\n\n"}
{"name":"Prop.le_isTotal","module":"Mathlib.Order.PropInstances","initialProofState":"⊢ IsTotal Prop fun x1 x2 => LE.le x1 x2","decl":"instance Prop.le_isTotal : IsTotal Prop (· ≤ ·) :=\n  ⟨fun p q => by by_cases h : q <;> simp [h]⟩\n\n"}
{"name":"sup_Prop_eq","module":"Mathlib.Order.PropInstances","initialProofState":"⊢ Eq (fun x1 x2 => Max.max x1 x2) fun x1 x2 => Or x1 x2","decl":"@[simp]\ntheorem sup_Prop_eq : (· ⊔ ·) = (· ∨ ·) :=\n  rfl\n\n"}
{"name":"inf_Prop_eq","module":"Mathlib.Order.PropInstances","initialProofState":"⊢ Eq (fun x1 x2 => Min.min x1 x2) fun x1 x2 => And x1 x2","decl":"@[simp]\ntheorem inf_Prop_eq : (· ⊓ ·) = (· ∧ ·) :=\n  rfl\n\n"}
{"name":"Pi.disjoint_iff","module":"Mathlib.Order.PropInstances","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝¹ : (i : ι) → PartialOrder (α' i)\ninst✝ : (i : ι) → OrderBot (α' i)\nf g : (i : ι) → α' i\n⊢ Iff (Disjoint f g) (∀ (i : ι), Disjoint (f i) (g i))","decl":"theorem disjoint_iff [∀ i, OrderBot (α' i)] {f g : ∀ i, α' i} :\n    Disjoint f g ↔ ∀ i, Disjoint (f i) (g i) := by\n  classical\n  constructor\n  · intro h i x hf hg\n    exact (update_le_iff.mp <| h (update_le_iff.mpr ⟨hf, fun _ _ => bot_le⟩)\n      (update_le_iff.mpr ⟨hg, fun _ _ => bot_le⟩)).1\n  · intro h x hf hg i\n    apply h i (hf i) (hg i)\n\n"}
{"name":"Pi.codisjoint_iff","module":"Mathlib.Order.PropInstances","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝¹ : (i : ι) → PartialOrder (α' i)\ninst✝ : (i : ι) → OrderTop (α' i)\nf g : (i : ι) → α' i\n⊢ Iff (Codisjoint f g) (∀ (i : ι), Codisjoint (f i) (g i))","decl":"theorem codisjoint_iff [∀ i, OrderTop (α' i)] {f g : ∀ i, α' i} :\n    Codisjoint f g ↔ ∀ i, Codisjoint (f i) (g i) :=\n  @disjoint_iff _ (fun i => (α' i)ᵒᵈ) _ _ _ _\n\n"}
{"name":"Pi.isCompl_iff","module":"Mathlib.Order.PropInstances","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝¹ : (i : ι) → PartialOrder (α' i)\ninst✝ : (i : ι) → BoundedOrder (α' i)\nf g : (i : ι) → α' i\n⊢ Iff (IsCompl f g) (∀ (i : ι), IsCompl (f i) (g i))","decl":"theorem isCompl_iff [∀ i, BoundedOrder (α' i)] {f g : ∀ i, α' i} :\n    IsCompl f g ↔ ∀ i, IsCompl (f i) (g i) := by\n  simp_rw [_root_.isCompl_iff, disjoint_iff, codisjoint_iff, forall_and]\n\n"}
{"name":"Prop.disjoint_iff","module":"Mathlib.Order.PropInstances","initialProofState":"P Q : Prop\n⊢ Iff (Disjoint P Q) (Not (And P Q))","decl":"@[simp]\ntheorem Prop.disjoint_iff {P Q : Prop} : Disjoint P Q ↔ ¬(P ∧ Q) :=\n  disjoint_iff_inf_le\n\n"}
{"name":"Prop.codisjoint_iff","module":"Mathlib.Order.PropInstances","initialProofState":"P Q : Prop\n⊢ Iff (Codisjoint P Q) (Or P Q)","decl":"@[simp]\ntheorem Prop.codisjoint_iff {P Q : Prop} : Codisjoint P Q ↔ P ∨ Q :=\n  codisjoint_iff_le_sup.trans <| forall_const True\n\n"}
{"name":"Prop.isCompl_iff","module":"Mathlib.Order.PropInstances","initialProofState":"P Q : Prop\n⊢ Iff (IsCompl P Q) (Not (Iff P Q))","decl":"@[simp]\ntheorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q ↔ ¬(P ↔ Q) := by\n  rw [_root_.isCompl_iff, Prop.disjoint_iff, Prop.codisjoint_iff, not_iff]\n  by_cases P <;> by_cases Q <;> simp [*]\n\n-- Porting note: Lean 3 would unfold these for us, but we need to do it manually now\n"}
