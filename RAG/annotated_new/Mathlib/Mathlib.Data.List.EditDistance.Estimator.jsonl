{"name":"LevenshteinEstimator'.bound_eq","module":"Mathlib.Data.List.EditDistance.Estimator","initialProofState":"α : Type u_1\nβ δ : Type\ninst✝ : LinearOrderedAddCommMonoid δ\nC : Levenshtein.Cost α β δ\nxs : List α\nys : List β\nself : LevenshteinEstimator' C xs ys\n⊢ Eq self.bound (LevenshteinEstimator'.match_1 ys self.suff (fun pre_rev split => Prod δ Nat) self.pre_rev ⋯ (fun split => { fst := GetElem.getElem (↑self.distances) 0 ⋯, snd := ys.length }) fun x split => { fst := List.minimum_of_length_pos ⋯, snd := self.suff.length })","decl":"/--\nData showing that the Levenshtein distance from `xs` to `ys`\nis bounded below by the minimum Levenshtein distance between some suffix of `xs`\nand a particular suffix of `ys`.\n\nThis bound is (non-strict) monotone as we take longer suffixes of `ys`.\n\nThis is an auxiliary definition for the later `LevenshteinEstimator`:\nthis variant constructs a lower bound for the pair consisting of\nthe Levenshtein distance from `xs` to `ys`,\nalong with the length of `ys`.\n-/\nstructure LevenshteinEstimator' : Type where\n  /-- The prefix of `ys` that is not is not involved in the bound, in reverse order. -/\n  pre_rev : List β\n  /-- The suffix of `ys`, such that the distance from `xs` to `ys` is bounded below\n  by the minimum distance from any suffix of `xs` to this suffix. -/\n  suff : List β\n  /-- Witness that `ys` has been decomposed into a prefix and suffix. -/\n  split : pre_rev.reverse ++ suff = ys\n  /-- The distances from each suffix of `xs` to `suff`. -/\n  distances : {r : List δ // 0 < r.length}\n  /-- Witness that `distances` are correct. -/\n  distances_eq : distances = suffixLevenshtein C xs suff\n  /-- The current bound on the pair (distance from `xs` to `ys`, length of `ys`). -/\n  bound : δ × ℕ\n  /-- Predicate describing the current bound. -/\n  bound_eq : bound = match pre_rev with\n    | [] => (distances.1[0]'(distances.2), ys.length)\n    | _ => (List.minimum_of_length_pos distances.2, suff.length)\n\n"}
{"name":"LevenshteinEstimator'.mk.sizeOf_spec","module":"Mathlib.Data.List.EditDistance.Estimator","initialProofState":"α : Type u_1\nβ δ : Type\ninst✝³ : LinearOrderedAddCommMonoid δ\nC : Levenshtein.Cost α β δ\nxs : List α\nys : List β\ninst✝² : SizeOf α\ninst✝¹ : SizeOf β\ninst✝ : SizeOf δ\npre_rev suff : List β\nsplit : Eq (HAppend.hAppend pre_rev.reverse suff) ys\ndistances : Subtype fun r => LT.lt 0 r.length\ndistances_eq : Eq distances (suffixLevenshtein C xs suff)\nbound : Prod δ Nat\nbound_eq : Eq bound (LevenshteinEstimator'.match_1 ys suff (fun pre_rev split => Prod δ Nat) pre_rev split (fun split => { fst := GetElem.getElem (↑distances) 0 ⋯, snd := ys.length }) fun x split => { fst := List.minimum_of_length_pos ⋯, snd := suff.length })\n⊢ Eq (SizeOf.sizeOf { pre_rev := pre_rev, suff := suff, split := split, distances := distances, distances_eq := distances_eq, bound := bound, bound_eq := bound_eq }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf pre_rev)) (SizeOf.sizeOf suff)) (SizeOf.sizeOf split)) (SizeOf.sizeOf distances)) (SizeOf.sizeOf distances_eq)) (SizeOf.sizeOf bound)) (SizeOf.sizeOf bound_eq))","decl":"/--\nData showing that the Levenshtein distance from `xs` to `ys`\nis bounded below by the minimum Levenshtein distance between some suffix of `xs`\nand a particular suffix of `ys`.\n\nThis bound is (non-strict) monotone as we take longer suffixes of `ys`.\n\nThis is an auxiliary definition for the later `LevenshteinEstimator`:\nthis variant constructs a lower bound for the pair consisting of\nthe Levenshtein distance from `xs` to `ys`,\nalong with the length of `ys`.\n-/\nstructure LevenshteinEstimator' : Type where\n  /-- The prefix of `ys` that is not is not involved in the bound, in reverse order. -/\n  pre_rev : List β\n  /-- The suffix of `ys`, such that the distance from `xs` to `ys` is bounded below\n  by the minimum distance from any suffix of `xs` to this suffix. -/\n  suff : List β\n  /-- Witness that `ys` has been decomposed into a prefix and suffix. -/\n  split : pre_rev.reverse ++ suff = ys\n  /-- The distances from each suffix of `xs` to `suff`. -/\n  distances : {r : List δ // 0 < r.length}\n  /-- Witness that `distances` are correct. -/\n  distances_eq : distances = suffixLevenshtein C xs suff\n  /-- The current bound on the pair (distance from `xs` to `ys`, length of `ys`). -/\n  bound : δ × ℕ\n  /-- Predicate describing the current bound. -/\n  bound_eq : bound = match pre_rev with\n    | [] => (distances.1[0]'(distances.2), ys.length)\n    | _ => (List.minimum_of_length_pos distances.2, suff.length)\n\n"}
{"name":"LevenshteinEstimator'.mk.injEq","module":"Mathlib.Data.List.EditDistance.Estimator","initialProofState":"α : Type u_1\nβ δ : Type\ninst✝ : LinearOrderedAddCommMonoid δ\nC : Levenshtein.Cost α β δ\nxs : List α\nys pre_rev✝ suff✝ : List β\nsplit✝ : Eq (HAppend.hAppend pre_rev✝.reverse suff✝) ys\ndistances✝ : Subtype fun r => LT.lt 0 r.length\ndistances_eq✝ : Eq distances✝ (suffixLevenshtein C xs suff✝)\nbound✝ : Prod δ Nat\nbound_eq✝ : Eq bound✝ (LevenshteinEstimator'.match_1 ys suff✝ (fun pre_rev split => Prod δ Nat) pre_rev✝ split✝ (fun split => { fst := GetElem.getElem (↑distances✝) 0 ⋯, snd := ys.length }) fun x split => { fst := List.minimum_of_length_pos ⋯, snd := suff✝.length })\npre_rev suff : List β\nsplit : Eq (HAppend.hAppend pre_rev.reverse suff) ys\ndistances : Subtype fun r => LT.lt 0 r.length\ndistances_eq : Eq distances (suffixLevenshtein C xs suff)\nbound : Prod δ Nat\nbound_eq : Eq bound (LevenshteinEstimator'.match_1 ys suff (fun pre_rev split => Prod δ Nat) pre_rev split (fun split => { fst := GetElem.getElem (↑distances) 0 ⋯, snd := ys.length }) fun x split => { fst := List.minimum_of_length_pos ⋯, snd := suff.length })\n⊢ Eq (Eq { pre_rev := pre_rev✝, suff := suff✝, split := split✝, distances := distances✝, distances_eq := distances_eq✝, bound := bound✝, bound_eq := bound_eq✝ } { pre_rev := pre_rev, suff := suff, split := split, distances := distances, distances_eq := distances_eq, bound := bound, bound_eq := bound_eq }) (And (Eq pre_rev✝ pre_rev) (And (Eq suff✝ suff) (And (Eq distances✝ distances) (Eq bound✝ bound))))","decl":"/--\nData showing that the Levenshtein distance from `xs` to `ys`\nis bounded below by the minimum Levenshtein distance between some suffix of `xs`\nand a particular suffix of `ys`.\n\nThis bound is (non-strict) monotone as we take longer suffixes of `ys`.\n\nThis is an auxiliary definition for the later `LevenshteinEstimator`:\nthis variant constructs a lower bound for the pair consisting of\nthe Levenshtein distance from `xs` to `ys`,\nalong with the length of `ys`.\n-/\nstructure LevenshteinEstimator' : Type where\n  /-- The prefix of `ys` that is not is not involved in the bound, in reverse order. -/\n  pre_rev : List β\n  /-- The suffix of `ys`, such that the distance from `xs` to `ys` is bounded below\n  by the minimum distance from any suffix of `xs` to this suffix. -/\n  suff : List β\n  /-- Witness that `ys` has been decomposed into a prefix and suffix. -/\n  split : pre_rev.reverse ++ suff = ys\n  /-- The distances from each suffix of `xs` to `suff`. -/\n  distances : {r : List δ // 0 < r.length}\n  /-- Witness that `distances` are correct. -/\n  distances_eq : distances = suffixLevenshtein C xs suff\n  /-- The current bound on the pair (distance from `xs` to `ys`, length of `ys`). -/\n  bound : δ × ℕ\n  /-- Predicate describing the current bound. -/\n  bound_eq : bound = match pre_rev with\n    | [] => (distances.1[0]'(distances.2), ys.length)\n    | _ => (List.minimum_of_length_pos distances.2, suff.length)\n\n"}
{"name":"LevenshteinEstimator'.split","module":"Mathlib.Data.List.EditDistance.Estimator","initialProofState":"α : Type u_1\nβ δ : Type\ninst✝ : LinearOrderedAddCommMonoid δ\nC : Levenshtein.Cost α β δ\nxs : List α\nys : List β\nself : LevenshteinEstimator' C xs ys\n⊢ Eq (HAppend.hAppend self.pre_rev.reverse self.suff) ys","decl":"/--\nData showing that the Levenshtein distance from `xs` to `ys`\nis bounded below by the minimum Levenshtein distance between some suffix of `xs`\nand a particular suffix of `ys`.\n\nThis bound is (non-strict) monotone as we take longer suffixes of `ys`.\n\nThis is an auxiliary definition for the later `LevenshteinEstimator`:\nthis variant constructs a lower bound for the pair consisting of\nthe Levenshtein distance from `xs` to `ys`,\nalong with the length of `ys`.\n-/\nstructure LevenshteinEstimator' : Type where\n  /-- The prefix of `ys` that is not is not involved in the bound, in reverse order. -/\n  pre_rev : List β\n  /-- The suffix of `ys`, such that the distance from `xs` to `ys` is bounded below\n  by the minimum distance from any suffix of `xs` to this suffix. -/\n  suff : List β\n  /-- Witness that `ys` has been decomposed into a prefix and suffix. -/\n  split : pre_rev.reverse ++ suff = ys\n  /-- The distances from each suffix of `xs` to `suff`. -/\n  distances : {r : List δ // 0 < r.length}\n  /-- Witness that `distances` are correct. -/\n  distances_eq : distances = suffixLevenshtein C xs suff\n  /-- The current bound on the pair (distance from `xs` to `ys`, length of `ys`). -/\n  bound : δ × ℕ\n  /-- Predicate describing the current bound. -/\n  bound_eq : bound = match pre_rev with\n    | [] => (distances.1[0]'(distances.2), ys.length)\n    | _ => (List.minimum_of_length_pos distances.2, suff.length)\n\n"}
{"name":"LevenshteinEstimator'.mk.inj","module":"Mathlib.Data.List.EditDistance.Estimator","initialProofState":"α : Type u_1\nβ δ : Type\ninst✝ : LinearOrderedAddCommMonoid δ\nC : Levenshtein.Cost α β δ\nxs : List α\nys pre_rev✝ suff✝ : List β\nsplit✝ : Eq (HAppend.hAppend pre_rev✝.reverse suff✝) ys\ndistances✝ : Subtype fun r => LT.lt 0 r.length\ndistances_eq✝ : Eq distances✝ (suffixLevenshtein C xs suff✝)\nbound✝ : Prod δ Nat\nbound_eq✝ : Eq bound✝ (LevenshteinEstimator'.match_1 ys suff✝ (fun pre_rev split => Prod δ Nat) pre_rev✝ split✝ (fun split => { fst := GetElem.getElem (↑distances✝) 0 ⋯, snd := ys.length }) fun x split => { fst := List.minimum_of_length_pos ⋯, snd := suff✝.length })\npre_rev suff : List β\nsplit : Eq (HAppend.hAppend pre_rev.reverse suff) ys\ndistances : Subtype fun r => LT.lt 0 r.length\ndistances_eq : Eq distances (suffixLevenshtein C xs suff)\nbound : Prod δ Nat\nbound_eq : Eq bound (LevenshteinEstimator'.match_1 ys suff (fun pre_rev split => Prod δ Nat) pre_rev split (fun split => { fst := GetElem.getElem (↑distances) 0 ⋯, snd := ys.length }) fun x split => { fst := List.minimum_of_length_pos ⋯, snd := suff.length })\nx✝ : Eq { pre_rev := pre_rev✝, suff := suff✝, split := split✝, distances := distances✝, distances_eq := distances_eq✝, bound := bound✝, bound_eq := bound_eq✝ } { pre_rev := pre_rev, suff := suff, split := split, distances := distances, distances_eq := distances_eq, bound := bound, bound_eq := bound_eq }\n⊢ And (Eq pre_rev✝ pre_rev) (And (Eq suff✝ suff) (And (Eq distances✝ distances) (Eq bound✝ bound)))","decl":"/--\nData showing that the Levenshtein distance from `xs` to `ys`\nis bounded below by the minimum Levenshtein distance between some suffix of `xs`\nand a particular suffix of `ys`.\n\nThis bound is (non-strict) monotone as we take longer suffixes of `ys`.\n\nThis is an auxiliary definition for the later `LevenshteinEstimator`:\nthis variant constructs a lower bound for the pair consisting of\nthe Levenshtein distance from `xs` to `ys`,\nalong with the length of `ys`.\n-/\nstructure LevenshteinEstimator' : Type where\n  /-- The prefix of `ys` that is not is not involved in the bound, in reverse order. -/\n  pre_rev : List β\n  /-- The suffix of `ys`, such that the distance from `xs` to `ys` is bounded below\n  by the minimum distance from any suffix of `xs` to this suffix. -/\n  suff : List β\n  /-- Witness that `ys` has been decomposed into a prefix and suffix. -/\n  split : pre_rev.reverse ++ suff = ys\n  /-- The distances from each suffix of `xs` to `suff`. -/\n  distances : {r : List δ // 0 < r.length}\n  /-- Witness that `distances` are correct. -/\n  distances_eq : distances = suffixLevenshtein C xs suff\n  /-- The current bound on the pair (distance from `xs` to `ys`, length of `ys`). -/\n  bound : δ × ℕ\n  /-- Predicate describing the current bound. -/\n  bound_eq : bound = match pre_rev with\n    | [] => (distances.1[0]'(distances.2), ys.length)\n    | _ => (List.minimum_of_length_pos distances.2, suff.length)\n\n"}
{"name":"LevenshteinEstimator'.distances_eq","module":"Mathlib.Data.List.EditDistance.Estimator","initialProofState":"α : Type u_1\nβ δ : Type\ninst✝ : LinearOrderedAddCommMonoid δ\nC : Levenshtein.Cost α β δ\nxs : List α\nys : List β\nself : LevenshteinEstimator' C xs ys\n⊢ Eq self.distances (suffixLevenshtein C xs self.suff)","decl":"/--\nData showing that the Levenshtein distance from `xs` to `ys`\nis bounded below by the minimum Levenshtein distance between some suffix of `xs`\nand a particular suffix of `ys`.\n\nThis bound is (non-strict) monotone as we take longer suffixes of `ys`.\n\nThis is an auxiliary definition for the later `LevenshteinEstimator`:\nthis variant constructs a lower bound for the pair consisting of\nthe Levenshtein distance from `xs` to `ys`,\nalong with the length of `ys`.\n-/\nstructure LevenshteinEstimator' : Type where\n  /-- The prefix of `ys` that is not is not involved in the bound, in reverse order. -/\n  pre_rev : List β\n  /-- The suffix of `ys`, such that the distance from `xs` to `ys` is bounded below\n  by the minimum distance from any suffix of `xs` to this suffix. -/\n  suff : List β\n  /-- Witness that `ys` has been decomposed into a prefix and suffix. -/\n  split : pre_rev.reverse ++ suff = ys\n  /-- The distances from each suffix of `xs` to `suff`. -/\n  distances : {r : List δ // 0 < r.length}\n  /-- Witness that `distances` are correct. -/\n  distances_eq : distances = suffixLevenshtein C xs suff\n  /-- The current bound on the pair (distance from `xs` to `ys`, length of `ys`). -/\n  bound : δ × ℕ\n  /-- Predicate describing the current bound. -/\n  bound_eq : bound = match pre_rev with\n    | [] => (distances.1[0]'(distances.2), ys.length)\n    | _ => (List.minimum_of_length_pos distances.2, suff.length)\n\n"}
