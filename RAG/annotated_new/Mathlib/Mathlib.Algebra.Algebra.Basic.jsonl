{"name":"Algebra.algebraMap_pUnit","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nr : R\n⊢ Eq ((algebraMap R PUnit.{u_1 + 1}) r) PUnit.unit","decl":"@[simp]\ntheorem algebraMap_pUnit (r : R) : algebraMap R PUnit r = PUnit.unit :=\n  rfl\n\n"}
{"name":"ULift.algebraMap_eq","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\nA : Type w\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Eq ((algebraMap R (ULift.{u_1, w} A)) r) { down := (algebraMap R A) r }","decl":"theorem _root_.ULift.algebraMap_eq (r : R) :\n    algebraMap R (ULift A) r = ULift.up (algebraMap R A r) :=\n  rfl\n\n"}
{"name":"ULift.down_algebraMap","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\nA : Type w\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Eq ((algebraMap R (ULift.{u_1, w} A)) r).down ((algebraMap R A) r)","decl":"@[simp]\ntheorem _root_.ULift.down_algebraMap (r : R) : (algebraMap R (ULift A) r).down = algebraMap R A r :=\n  rfl\n\n"}
{"name":"Algebra.algebraMap_ofSubsemiring","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nS : Subsemiring R\n⊢ Eq (algebraMap (Subtype fun x => Membership.mem S x) R) S.subtype","decl":"theorem algebraMap_ofSubsemiring (S : Subsemiring R) :\n    (algebraMap S R : S →+* R) = Subsemiring.subtype S :=\n  rfl\n\n"}
{"name":"Algebra.coe_algebraMap_ofSubsemiring","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nS : Subsemiring R\n⊢ Eq (⇑(algebraMap (Subtype fun x => Membership.mem S x) R)) Subtype.val","decl":"theorem coe_algebraMap_ofSubsemiring (S : Subsemiring R) : (algebraMap S R : S → R) = Subtype.val :=\n  rfl\n\n"}
{"name":"Algebra.algebraMap_ofSubsemiring_apply","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nS : Subsemiring R\nx : Subtype fun x => Membership.mem S x\n⊢ Eq ((algebraMap (Subtype fun x => Membership.mem S x) R) x) ↑x","decl":"theorem algebraMap_ofSubsemiring_apply (S : Subsemiring R) (x : S) : algebraMap S R x = x :=\n  rfl\n\n"}
{"name":"Algebra.algebraMap_ofSubring","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nS : Subring R\n⊢ Eq (algebraMap (Subtype fun x => Membership.mem S x) R) S.subtype","decl":"theorem algebraMap_ofSubring {R : Type*} [CommRing R] (S : Subring R) :\n    (algebraMap S R : S →+* R) = Subring.subtype S :=\n  rfl\n\n"}
{"name":"Algebra.coe_algebraMap_ofSubring","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nS : Subring R\n⊢ Eq (⇑(algebraMap (Subtype fun x => Membership.mem S x) R)) Subtype.val","decl":"theorem coe_algebraMap_ofSubring {R : Type*} [CommRing R] (S : Subring R) :\n    (algebraMap S R : S → R) = Subtype.val :=\n  rfl\n\n"}
{"name":"Algebra.algebraMap_ofSubring_apply","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nS : Subring R\nx : Subtype fun x => Membership.mem S x\n⊢ Eq ((algebraMap (Subtype fun x => Membership.mem S x) R) x) ↑x","decl":"theorem algebraMap_ofSubring_apply {R : Type*} [CommRing R] (S : Subring R) (x : S) :\n    algebraMap S R x = x :=\n  rfl\n\n"}
{"name":"Algebra.mem_algebraMapSubmonoid_of_mem","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Type u_1\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submonoid R\nx : Subtype fun x => Membership.mem M x\n⊢ Membership.mem (Algebra.algebraMapSubmonoid S M) ((algebraMap R S) ↑x)","decl":"theorem mem_algebraMapSubmonoid_of_mem {S : Type*} [Semiring S] [Algebra R S] {M : Submonoid R}\n    (x : M) : algebraMap R S x ∈ algebraMapSubmonoid S M :=\n  Set.mem_image_of_mem (algebraMap R S) x.2\n\n"}
{"name":"Algebra.mul_sub_algebraMap_commutes","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\nA : Type w\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : A\nr : R\n⊢ Eq (HMul.hMul x (HSub.hSub x ((algebraMap R A) r))) (HMul.hMul (HSub.hSub x ((algebraMap R A) r)) x)","decl":"theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :\n    x * (x - algebraMap R A r) = (x - algebraMap R A r) * x := by rw [mul_sub, ← commutes, sub_mul]\n\n"}
{"name":"Algebra.mul_sub_algebraMap_pow_commutes","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\nA : Type w\ninst✝² : CommSemiring R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : A\nr : R\nn : Nat\n⊢ Eq (HMul.hMul x (HPow.hPow (HSub.hSub x ((algebraMap R A) r)) n)) (HMul.hMul (HPow.hPow (HSub.hSub x ((algebraMap R A) r)) n) x)","decl":"theorem mul_sub_algebraMap_pow_commutes [Ring A] [Algebra R A] (x : A) (r : R) (n : ℕ) :\n    x * (x - algebraMap R A r) ^ n = (x - algebraMap R A r) ^ n * x := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [pow_succ', ← mul_assoc, mul_sub_algebraMap_commutes, mul_assoc, ih, ← mul_assoc]\n\n"}
{"name":"Module.algebraMap_end_eq_smul_id","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\nS : Type v\nM : Type w\ninst✝⁷ : CommSemiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : SMulCommClass S R M\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S M\na : R\n⊢ Eq ((algebraMap R (Module.End S M)) a) (HSMul.hSMul a LinearMap.id)","decl":"theorem algebraMap_end_eq_smul_id (a : R) : algebraMap R (End S M) a = a • LinearMap.id :=\n  rfl\n\n"}
{"name":"Module.algebraMap_end_apply","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\nS : Type v\nM : Type w\ninst✝⁷ : CommSemiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : SMulCommClass S R M\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S M\na : R\nm : M\n⊢ Eq (((algebraMap R (Module.End S M)) a) m) (HSMul.hSMul a m)","decl":"@[simp]\ntheorem algebraMap_end_apply (a : R) (m : M) : algebraMap R (End S M) a m = a • m :=\n  rfl\n\n"}
{"name":"Module.ker_algebraMap_end","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\na : K\nha : Ne a 0\n⊢ Eq (LinearMap.ker ((algebraMap K (Module.End K V)) a)) Bot.bot","decl":"@[simp]\ntheorem ker_algebraMap_end (K : Type u) (V : Type v) [Field K] [AddCommGroup V] [Module K V] (a : K)\n    (ha : a ≠ 0) : LinearMap.ker ((algebraMap K (End K V)) a) = ⊥ :=\n  LinearMap.ker_smul _ _ ha\n\n"}
{"name":"Module.End_algebraMap_isUnit_inv_apply_eq_iff","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\nS : Type v\nM : Type w\ninst✝⁷ : CommSemiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : SMulCommClass S R M\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S M\nx : R\nh : IsUnit ((algebraMap R (Module.End S M)) x)\nm m' : M\n⊢ Iff (Eq (↑(Inv.inv h.unit) m) m') (Eq m (HSMul.hSMul x m'))","decl":"theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}\n    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :\n    (↑(h.unit⁻¹) : Module.End S M) m = m' ↔ m = x • m' where\n  mp H := H ▸ (End_isUnit_apply_inv_apply_of_isUnit h m).symm\n  mpr H :=\n    H.symm ▸ by\n      apply_fun ⇑h.unit.val using ((Module.End_isUnit_iff _).mp h).injective\n      simpa using End_isUnit_apply_inv_apply_of_isUnit h (x • m')\n\n"}
{"name":"Module.End_algebraMap_isUnit_inv_apply_eq_iff'","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u\nS : Type v\nM : Type w\ninst✝⁷ : CommSemiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : SMulCommClass S R M\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S M\nx : R\nh : IsUnit ((algebraMap R (Module.End S M)) x)\nm m' : M\n⊢ Iff (Eq m' (↑(Inv.inv h.unit) m)) (Eq m (HSMul.hSMul x m'))","decl":"theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}\n    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :\n    m' = (↑h.unit⁻¹ : Module.End S M) m ↔ m = x • m' where\n  mp H := H ▸ (End_isUnit_apply_inv_apply_of_isUnit h m).symm\n  mpr H :=\n    H.symm ▸ by\n      apply_fun (↑h.unit : M → M) using ((Module.End_isUnit_iff _).mp h).injective\n      simpa using End_isUnit_apply_inv_apply_of_isUnit h (x • m') |>.symm\n\n"}
{"name":"LinearMap.map_algebraMap_mul","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : LinearMap (RingHom.id R) A B\na : A\nr : R\n⊢ Eq (f (HMul.hMul ((algebraMap R A) r) a)) (HMul.hMul ((algebraMap R B) r) (f a))","decl":"/-- An alternate statement of `LinearMap.map_smul` for when `algebraMap` is more convenient to\nwork with than `•`. -/\ntheorem map_algebraMap_mul (f : A →ₗ[R] B) (a : A) (r : R) :\n    f (algebraMap R A r * a) = algebraMap R B r * f a := by\n  rw [← Algebra.smul_def, ← Algebra.smul_def, map_smul]\n\n"}
{"name":"LinearMap.map_mul_algebraMap","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : LinearMap (RingHom.id R) A B\na : A\nr : R\n⊢ Eq (f (HMul.hMul a ((algebraMap R A) r))) (HMul.hMul (f a) ((algebraMap R B) r))","decl":"theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :\n    f (a * algebraMap R A r) = f a * algebraMap R B r := by\n  rw [← Algebra.commutes, ← Algebra.commutes, map_algebraMap_mul]\n\n"}
{"name":"nat_algebra_subsingleton","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Subsingleton (Algebra Nat R)","decl":"instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R) :=\n  ⟨fun P Q => by ext; simp⟩\n\n"}
{"name":"algebraMap_int_eq","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ Eq (algebraMap Int R) (Int.castRingHom R)","decl":"/-- A special case of `eq_intCast'` that happens to be true definitionally -/\n@[simp]\ntheorem algebraMap_int_eq : algebraMap ℤ R = Int.castRingHom R :=\n  rfl\n\n"}
{"name":"int_algebra_subsingleton","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ Subsingleton (Algebra Int R)","decl":"instance int_algebra_subsingleton : Subsingleton (Algebra ℤ R) :=\n  ⟨fun P Q => Algebra.algebra_ext P Q <| RingHom.congr_fun <| Subsingleton.elim _ _⟩\n\n"}
{"name":"NoZeroSMulDivisors.of_algebraMap_injective","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroDivisors A\nh : Function.Injective ⇑(algebraMap R A)\n⊢ NoZeroSMulDivisors R A","decl":"/-- If `algebraMap R A` is injective and `A` has no zero divisors,\n`R`-multiples in `A` are zero only if one of the factors is zero.\n\nCannot be an instance because there is no `Injective (algebraMap R A)` typeclass.\n-/\ntheorem of_algebraMap_injective [CommSemiring R] [Semiring A] [Algebra R A] [NoZeroDivisors A]\n    (h : Function.Injective (algebraMap R A)) : NoZeroSMulDivisors R A :=\n  ⟨fun hcx => (mul_eq_zero.mp ((smul_def _ _).symm.trans hcx)).imp_left\n    (map_eq_zero_iff (algebraMap R A) h).mp⟩\n\n"}
{"name":"NoZeroSMulDivisors.algebraMap_injective","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Nontrivial A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroSMulDivisors R A\n⊢ Function.Injective ⇑(algebraMap R A)","decl":"theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]\n    [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A) := by\n  simpa only [algebraMap_eq_smul_one'] using smul_left_injective R one_ne_zero\n\n"}
{"name":"NoZeroSMulDivisors.algebraMap_eq_zero_iff","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Nontrivial A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroSMulDivisors R A\nr : R\n⊢ Iff (Eq ((algebraMap R A) r) 0) (Eq r 0)","decl":"@[simp]\nlemma algebraMap_eq_zero_iff [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]\n    [NoZeroSMulDivisors R A] {r : R} : algebraMap R A r = 0 ↔ r = 0 :=\n  map_eq_zero_iff _ <| algebraMap_injective R A\n\n"}
{"name":"NoZeroSMulDivisors.algebraMap_eq_one_iff","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Nontrivial A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroSMulDivisors R A\nr : R\n⊢ Iff (Eq ((algebraMap R A) r) 1) (Eq r 1)","decl":"@[simp]\nlemma algebraMap_eq_one_iff [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]\n    [NoZeroSMulDivisors R A] {r : R} : algebraMap R A r = 1 ↔ r = 1 :=\n  map_eq_one_iff _ <| algebraMap_injective R A\n\n"}
{"name":"NeZero.of_noZeroSMulDivisors","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nn : Nat\ninst✝⁵ : CommRing R\ninst✝⁴ : NeZero ↑n\ninst✝³ : Ring A\ninst✝² : Nontrivial A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroSMulDivisors R A\n⊢ NeZero ↑n","decl":"theorem _root_.NeZero.of_noZeroSMulDivisors (n : ℕ) [CommRing R] [NeZero (n : R)] [Ring A]\n    [Nontrivial A] [Algebra R A] [NoZeroSMulDivisors R A] : NeZero (n : A) :=\n  NeZero.nat_of_injective <| NoZeroSMulDivisors.algebraMap_injective R A\n\n"}
{"name":"NoZeroSMulDivisors.iff_algebraMap_injective","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : IsDomain A\ninst✝ : Algebra R A\n⊢ Iff (NoZeroSMulDivisors R A) (Function.Injective ⇑(algebraMap R A))","decl":"theorem iff_algebraMap_injective [CommRing R] [Ring A] [IsDomain A] [Algebra R A] :\n    NoZeroSMulDivisors R A ↔ Function.Injective (algebraMap R A) :=\n  ⟨@NoZeroSMulDivisors.algebraMap_injective R A _ _ _ _, NoZeroSMulDivisors.of_algebraMap_injective⟩\n\n-- see note [lower instance priority]\n"}
{"name":"NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_nat","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝² : Semiring R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\n⊢ NoZeroSMulDivisors Nat R","decl":"instance (priority := 100) CharZero.noZeroSMulDivisors_nat [Semiring R] [NoZeroDivisors R]\n    [CharZero R] : NoZeroSMulDivisors ℕ R :=\n  NoZeroSMulDivisors.of_algebraMap_injective <| (algebraMap ℕ R).injective_nat\n\n-- see note [lower instance priority]\n"}
{"name":"NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_int","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\n⊢ NoZeroSMulDivisors Int R","decl":"instance (priority := 100) CharZero.noZeroSMulDivisors_int [Ring R] [NoZeroDivisors R]\n    [CharZero R] : NoZeroSMulDivisors ℤ R :=\n  NoZeroSMulDivisors.of_algebraMap_injective <| (algebraMap ℤ R).injective_int\n\n"}
{"name":"algebra_compatible_smul","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nA : Type u_2\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module A M\ninst✝¹ : Module R M\ninst✝ : IsScalarTower R A M\nr : R\nm : M\n⊢ Eq (HSMul.hSMul r m) (HSMul.hSMul ((algebraMap R A) r) m)","decl":"theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m := by\n  rw [← one_smul A m, ← smul_assoc, Algebra.smul_def, mul_one, one_smul]\n\n"}
{"name":"algebraMap_smul","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nA : Type u_2\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module A M\ninst✝¹ : Module R M\ninst✝ : IsScalarTower R A M\nr : R\nm : M\n⊢ Eq (HSMul.hSMul ((algebraMap R A) r) m) (HSMul.hSMul r m)","decl":"@[simp]\ntheorem algebraMap_smul (r : R) (m : M) : (algebraMap R A) r • m = r • m :=\n  (algebra_compatible_smul A r m).symm\n\n"}
{"name":"NoZeroSMulDivisors.of_algebraMap_injective'","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_4\nA : Type u_5\nM : Type u_6\ninst✝⁷ : CommSemiring R\ninst✝⁶ : Semiring A\ninst✝⁵ : Algebra R A\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module A M\ninst✝¹ : IsScalarTower R A M\ninst✝ : NoZeroSMulDivisors A M\nh : Function.Injective ⇑(algebraMap R A)\n⊢ NoZeroSMulDivisors R M","decl":"/-- If `M` is `A`-torsion free and `algebraMap R A` is injective, `M` is also `R`-torsion free. -/\nlemma NoZeroSMulDivisors.of_algebraMap_injective' {R A M : Type*} [CommSemiring R] [Semiring A]\n    [Algebra R A] [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M]\n    [NoZeroSMulDivisors A M] (h : Function.Injective (algebraMap R A)) :\n    NoZeroSMulDivisors R M where\n  eq_zero_or_eq_zero_of_smul_eq_zero hx := by\n    rw [← algebraMap_smul (A := A)] at hx\n    obtain (hc|hx) := eq_zero_or_eq_zero_of_smul_eq_zero hx\n    · exact Or.inl <| (map_eq_zero_iff _ h).mp hc\n    · exact Or.inr hx\n\n"}
{"name":"NoZeroSMulDivisors.trans","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_4\nA : Type u_5\nM : Type u_6\ninst✝⁹ : CommRing R\ninst✝⁸ : Ring A\ninst✝⁷ : IsDomain A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : NoZeroSMulDivisors R A\ninst✝ : NoZeroSMulDivisors A M\n⊢ NoZeroSMulDivisors R M","decl":"theorem NoZeroSMulDivisors.trans (R A M : Type*) [CommRing R] [Ring A] [IsDomain A] [Algebra R A]\n    [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A]\n    [NoZeroSMulDivisors A M] : NoZeroSMulDivisors R M :=\n  of_algebraMap_injective' (A := A) (NoZeroSMulDivisors.iff_algebraMap_injective.1 inferInstance)\n\n"}
{"name":"IsScalarTower.to_smulCommClass","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nA : Type u_2\ninst✝³ : Semiring A\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module A M\ninst✝ : Module R M\n⊢ SMulCommClass R A M","decl":"instance (priority := 120) IsScalarTower.to_smulCommClass : SMulCommClass R A M :=\n  ⟨fun r a m => by\n    rw [algebra_compatible_smul A r (a • m), smul_smul, Algebra.commutes, mul_smul, ←\n      algebra_compatible_smul]⟩\n\n-- see Note [lower instance priority]\n-- priority manually adjusted in https://github.com/leanprover-community/mathlib4/pull/11980, as it is a very common path\n"}
{"name":"IsScalarTower.to_smulCommClass'","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nA : Type u_2\ninst✝³ : Semiring A\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module A M\ninst✝ : Module R M\n⊢ SMulCommClass A R M","decl":"instance (priority := 110) IsScalarTower.to_smulCommClass' : SMulCommClass A R M :=\n  SMulCommClass.symm _ _ _\n\n-- see Note [lower instance priority]\n"}
{"name":"Algebra.to_smulCommClass","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_4\nA : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ SMulCommClass R A A","decl":"instance (priority := 200) Algebra.to_smulCommClass {R A} [CommSemiring R] [Semiring A]\n    [Algebra R A] : SMulCommClass R A A :=\n  IsScalarTower.to_smulCommClass\n\n"}
{"name":"smul_algebra_smul_comm","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nA : Type u_2\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module A M\ninst✝¹ : Module R M\ninst✝ : IsScalarTower R A M\nr : R\na : A\nm : M\n⊢ Eq (HSMul.hSMul a (HSMul.hSMul r m)) (HSMul.hSMul r (HSMul.hSMul a m))","decl":"theorem smul_algebra_smul_comm (r : R) (a : A) (m : M) : a • r • m = r • a • m :=\n  smul_comm _ _ _\n\n"}
{"name":"LinearMap.ker_restrictScalars","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁰ : Semiring R\ninst✝⁹ : Semiring S\ninst✝⁸ : SMul R S\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module S M\ninst✝⁴ : IsScalarTower R S M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nf : LinearMap (RingHom.id S) M N\n⊢ Eq (LinearMap.ker (↑R f)) (Submodule.restrictScalars R (LinearMap.ker f))","decl":"@[simp]\ntheorem LinearMap.ker_restrictScalars (f : M →ₗ[S] N) :\n    LinearMap.ker (f.restrictScalars R) = f.ker.restrictScalars R :=\n  rfl\n\n"}
{"name":"IsUnit.algebraMap_of_algebraMap","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : LinearMap (RingHom.id R) A B\nhf : Eq (f 1) 1\nr : R\nh : IsUnit ((algebraMap R A) r)\n⊢ IsUnit ((algebraMap R B) r)","decl":"/-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is\na unit when `algebraMap R A r` is. -/\nlemma IsUnit.algebraMap_of_algebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}\n    (h : IsUnit (algebraMap R A r)) : IsUnit (algebraMap R B r) :=\n  let ⟨i⟩ := nonempty_invertible h\n  letI := Invertible.algebraMapOfInvertibleAlgebraMap f hf i\n  isUnit_of_invertible _\n\n"}
{"name":"injective_algebraMap_of_linearMap","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : CommSemiring F\ninst✝¹ : Semiring E\ninst✝ : Algebra F E\nb : LinearMap (RingHom.id F) F E\nhb : Function.Injective ⇑b\n⊢ Function.Injective ⇑(algebraMap F E)","decl":"/-- If `E` is an `F`-algebra, and there exists an injective `F`-linear map from `F` to `E`,\nthen the algebra map from `F` to `E` is also injective. -/\ntheorem injective_algebraMap_of_linearMap (hb : Function.Injective b) :\n    Function.Injective (algebraMap F E) := fun x y e ↦ hb <| by\n  rw [← mul_one x, ← mul_one y, ← smul_eq_mul, ← smul_eq_mul,\n    map_smul, map_smul, Algebra.smul_def, Algebra.smul_def, e]\n\n"}
{"name":"surjective_algebraMap_of_linearMap","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : CommSemiring F\ninst✝¹ : Semiring E\ninst✝ : Algebra F E\nb : LinearMap (RingHom.id F) F E\nhb : Function.Surjective ⇑b\n⊢ Function.Surjective ⇑(algebraMap F E)","decl":"/-- If `E` is an `F`-algebra, and there exists a surjective `F`-linear map from `F` to `E`,\nthen the algebra map from `F` to `E` is also surjective. -/\ntheorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :\n    Function.Surjective (algebraMap F E) := fun x ↦ by\n  obtain ⟨x, rfl⟩ := hb x\n  obtain ⟨y, hy⟩ := hb (b 1 * b 1)\n  refine ⟨x * y, ?_⟩\n  obtain ⟨z, hz⟩ := hb 1\n  apply_fun (x • z • ·) at hy\n  rwa [← map_smul, smul_eq_mul, mul_comm, ← smul_mul_assoc, ← map_smul _ z, smul_eq_mul, mul_one,\n    ← smul_eq_mul, map_smul, hz, one_mul, ← map_smul, smul_eq_mul, mul_one, smul_smul,\n    ← Algebra.algebraMap_eq_smul_one] at hy\n\n"}
{"name":"bijective_algebraMap_of_linearMap","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : CommSemiring F\ninst✝¹ : Semiring E\ninst✝ : Algebra F E\nb : LinearMap (RingHom.id F) F E\nhb : Function.Bijective ⇑b\n⊢ Function.Bijective ⇑(algebraMap F E)","decl":"/-- If `E` is an `F`-algebra, and there exists a bijective `F`-linear map from `F` to `E`,\nthen the algebra map from `F` to `E` is also bijective.\n\nNOTE: The same result can also be obtained if there are two `F`-linear maps from `F` to `E`,\none is injective, the other one is surjective. In this case, use\n`injective_algebraMap_of_linearMap` and `surjective_algebraMap_of_linearMap` separately. -/\ntheorem bijective_algebraMap_of_linearMap (hb : Function.Bijective b) :\n    Function.Bijective (algebraMap F E) :=\n  ⟨injective_algebraMap_of_linearMap b hb.1, surjective_algebraMap_of_linearMap b hb.2⟩\n\n"}
{"name":"bijective_algebraMap_of_linearEquiv","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : CommSemiring F\ninst✝¹ : Semiring E\ninst✝ : Algebra F E\nb : LinearEquiv (RingHom.id F) F E\n⊢ Function.Bijective ⇑(algebraMap F E)","decl":"/-- If `E` is an `F`-algebra, there exists an `F`-linear isomorphism from `F` to `E` (namely,\n`E` is a free `F`-module of rank one), then the algebra map from `F` to `E` is bijective. -/\ntheorem bijective_algebraMap_of_linearEquiv (b : F ≃ₗ[F] E) :\n    Function.Bijective (algebraMap F E) :=\n  bijective_algebraMap_of_linearMap _ b.bijective\n\n"}
{"name":"LinearMap.extendScalarsOfSurjective_apply","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : Semiring S\ninst✝⁸ : Algebra R S\nM : Type u_2\nN : Type u_3\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module S M\ninst✝³ : IsScalarTower R S M\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nh : Function.Surjective ⇑(algebraMap R S)\nl : LinearMap (RingHom.id R) M N\nx : M\n⊢ Eq ((LinearMap.extendScalarsOfSurjective h l) x) (l x)","decl":"@[simp]\nlemma LinearMap.extendScalarsOfSurjective_apply (l : M →ₗ[R] N) (x) :\n    l.extendScalarsOfSurjective h x = l x := rfl\n\n"}
{"name":"LinearEquiv.extendScalarsOfSurjective_apply","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : Semiring S\ninst✝⁸ : Algebra R S\nM : Type u_2\nN : Type u_3\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module S M\ninst✝³ : IsScalarTower R S M\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nh : Function.Surjective ⇑(algebraMap R S)\nf : LinearEquiv (RingHom.id R) M N\nx : M\n⊢ Eq ((LinearEquiv.extendScalarsOfSurjective h f) x) (f x)","decl":"@[simp]\nlemma LinearEquiv.extendScalarsOfSurjective_apply (f : M ≃ₗ[R] N) (x) :\n    f.extendScalarsOfSurjective h x = f x := rfl\n\n"}
{"name":"LinearEquiv.extendScalarsOfSurjective_symm","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : Semiring S\ninst✝⁸ : Algebra R S\nM : Type u_2\nN : Type u_3\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module S M\ninst✝³ : IsScalarTower R S M\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nh : Function.Surjective ⇑(algebraMap R S)\nf : LinearEquiv (RingHom.id R) M N\n⊢ Eq (LinearEquiv.extendScalarsOfSurjective h f).symm (LinearEquiv.extendScalarsOfSurjective h f.symm)","decl":"@[simp]\nlemma LinearEquiv.extendScalarsOfSurjective_symm (f : M ≃ₗ[R] N) :\n    (f.extendScalarsOfSurjective h).symm = f.symm.extendScalarsOfSurjective h := rfl\n\n"}
{"name":"algebraMap.coe_prod","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nι : Type u_3\ns : Finset ι\na : ι → R\n⊢ Eq (↑(s.prod fun i => a i)) (s.prod fun i => ↑(a i))","decl":"@[norm_cast]\ntheorem coe_prod (a : ι → R) : (↑(∏ i ∈ s, a i : R) : A) = ∏ i ∈ s, (↑(a i) : A) :=\n  map_prod (algebraMap R A) a s\n\n"}
{"name":"algebraMap.coe_sum","module":"Mathlib.Algebra.Algebra.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nι : Type u_3\ns : Finset ι\na : ι → R\n⊢ Eq (↑(s.sum fun i => a i)) (s.sum fun i => ↑(a i))","decl":"@[norm_cast]\ntheorem coe_sum (a : ι → R) : ↑(∑ i ∈ s, a i) = ∑ i ∈ s, (↑(a i) : A) :=\n  map_sum (algebraMap R A) a s\n\n"}
