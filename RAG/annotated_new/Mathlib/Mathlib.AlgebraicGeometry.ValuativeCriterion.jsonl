{"name":"AlgebraicGeometry.ValuativeCommSq.commSq","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.ValuativeCommSq f\n‚ä¢ CategoryTheory.CommSq self.i‚ÇÅ (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap self.R self.K))) f self.i‚ÇÇ","decl":"/--\nA valuative commutative square over a morphism `f : X ‚ü∂ Y` is a square\n```\nSpec K ‚ü∂ Y\n  |       |\n  ‚Üì       ‚Üì\nSpec R ‚ü∂ X\n```\nwhere `R` is a valuation ring, and `K` is its ring of fractions.\n\nWe are interested in finding lifts `Spec R ‚ü∂ Y` of this diagram.\n-/\nstructure ValuativeCommSq {X Y : Scheme.{u}} (f : X ‚ü∂ Y) where\n  /-- The valuation ring of a valuative commutative square. -/\n  R : Type u\n  [commRing : CommRing R]\n  [domain : IsDomain R]\n  [valuationRing : ValuationRing R]\n  /-- The field of fractions of a valuative commutative square. -/\n  K : Type u\n  [field : Field K]\n  [algebra : Algebra R K]\n  [isFractionRing : IsFractionRing R K]\n  /-- The top map in a valuative commutative map. -/\n  (i‚ÇÅ : Spec (.of K) ‚ü∂ X)\n  /-- The bottom map in a valuative commutative map. -/\n  (i‚ÇÇ : Spec (.of R) ‚ü∂ Y)\n  (commSq : CommSq i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ)\n\n"}
{"name":"AlgebraicGeometry.ValuativeCommSq.isFractionRing","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.ValuativeCommSq f\n‚ä¢ IsFractionRing self.R self.K","decl":"/--\nA valuative commutative square over a morphism `f : X ‚ü∂ Y` is a square\n```\nSpec K ‚ü∂ Y\n  |       |\n  ‚Üì       ‚Üì\nSpec R ‚ü∂ X\n```\nwhere `R` is a valuation ring, and `K` is its ring of fractions.\n\nWe are interested in finding lifts `Spec R ‚ü∂ Y` of this diagram.\n-/\nstructure ValuativeCommSq {X Y : Scheme.{u}} (f : X ‚ü∂ Y) where\n  /-- The valuation ring of a valuative commutative square. -/\n  R : Type u\n  [commRing : CommRing R]\n  [domain : IsDomain R]\n  [valuationRing : ValuationRing R]\n  /-- The field of fractions of a valuative commutative square. -/\n  K : Type u\n  [field : Field K]\n  [algebra : Algebra R K]\n  [isFractionRing : IsFractionRing R K]\n  /-- The top map in a valuative commutative map. -/\n  (i‚ÇÅ : Spec (.of K) ‚ü∂ X)\n  /-- The bottom map in a valuative commutative map. -/\n  (i‚ÇÇ : Spec (.of R) ‚ü∂ Y)\n  (commSq : CommSq i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ)\n\n"}
{"name":"AlgebraicGeometry.ValuativeCommSq.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nR : Type u\ncommRing : CommRing R\ndomain : IsDomain R\nvaluationRing : ValuationRing R\nK : Type u\nfield : Field K\nalgebra : Algebra R K\nisFractionRing : IsFractionRing R K\ni‚ÇÅ : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of K)) X\ni‚ÇÇ : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of R)) Y\ncommSq : CategoryTheory.CommSq i‚ÇÅ (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ\n‚ä¢ Eq (SizeOf.sizeOf (AlgebraicGeometry.ValuativeCommSq.mk R K i‚ÇÅ i‚ÇÇ commSq)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf R)) (SizeOf.sizeOf commRing)) (SizeOf.sizeOf domain)) (SizeOf.sizeOf valuationRing)) (SizeOf.sizeOf K)) (SizeOf.sizeOf field)) (SizeOf.sizeOf algebra)) (SizeOf.sizeOf isFractionRing)) (SizeOf.sizeOf i‚ÇÅ)) (SizeOf.sizeOf i‚ÇÇ)) (SizeOf.sizeOf commSq))","decl":"/--\nA valuative commutative square over a morphism `f : X ‚ü∂ Y` is a square\n```\nSpec K ‚ü∂ Y\n  |       |\n  ‚Üì       ‚Üì\nSpec R ‚ü∂ X\n```\nwhere `R` is a valuation ring, and `K` is its ring of fractions.\n\nWe are interested in finding lifts `Spec R ‚ü∂ Y` of this diagram.\n-/\nstructure ValuativeCommSq {X Y : Scheme.{u}} (f : X ‚ü∂ Y) where\n  /-- The valuation ring of a valuative commutative square. -/\n  R : Type u\n  [commRing : CommRing R]\n  [domain : IsDomain R]\n  [valuationRing : ValuationRing R]\n  /-- The field of fractions of a valuative commutative square. -/\n  K : Type u\n  [field : Field K]\n  [algebra : Algebra R K]\n  [isFractionRing : IsFractionRing R K]\n  /-- The top map in a valuative commutative map. -/\n  (i‚ÇÅ : Spec (.of K) ‚ü∂ X)\n  /-- The bottom map in a valuative commutative map. -/\n  (i‚ÇÇ : Spec (.of R) ‚ü∂ Y)\n  (commSq : CommSq i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ)\n\n"}
{"name":"AlgebraicGeometry.ValuativeCommSq.mk.injEq","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nR‚úù : Type u\ncommRing‚úù : CommRing R‚úù\ndomain‚úù : IsDomain R‚úù\nvaluationRing‚úù : ValuationRing R‚úù\nK‚úù : Type u\nfield‚úù : Field K‚úù\nalgebra‚úù : Algebra R‚úù K‚úù\nisFractionRing‚úù : IsFractionRing R‚úù K‚úù\ni‚ÇÅ‚úù : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of K‚úù)) X\ni‚ÇÇ‚úù : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of R‚úù)) Y\ncommSq‚úù : CategoryTheory.CommSq i‚ÇÅ‚úù (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R‚úù K‚úù))) f i‚ÇÇ‚úù\nR : Type u\ncommRing : CommRing R\ndomain : IsDomain R\nvaluationRing : ValuationRing R\nK : Type u\nfield : Field K\nalgebra : Algebra R K\nisFractionRing : IsFractionRing R K\ni‚ÇÅ : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of K)) X\ni‚ÇÇ : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of R)) Y\ncommSq : CategoryTheory.CommSq i‚ÇÅ (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ\n‚ä¢ Eq (Eq (AlgebraicGeometry.ValuativeCommSq.mk R‚úù K‚úù i‚ÇÅ‚úù i‚ÇÇ‚úù commSq‚úù) (AlgebraicGeometry.ValuativeCommSq.mk R K i‚ÇÅ i‚ÇÇ commSq)) (And (Eq R‚úù R) (And (HEq commRing‚úù commRing) (And (Eq K‚úù K) (And (HEq field‚úù field) (And (HEq algebra‚úù algebra) (And (HEq i‚ÇÅ‚úù i‚ÇÅ) (HEq i‚ÇÇ‚úù i‚ÇÇ)))))))","decl":"/--\nA valuative commutative square over a morphism `f : X ‚ü∂ Y` is a square\n```\nSpec K ‚ü∂ Y\n  |       |\n  ‚Üì       ‚Üì\nSpec R ‚ü∂ X\n```\nwhere `R` is a valuation ring, and `K` is its ring of fractions.\n\nWe are interested in finding lifts `Spec R ‚ü∂ Y` of this diagram.\n-/\nstructure ValuativeCommSq {X Y : Scheme.{u}} (f : X ‚ü∂ Y) where\n  /-- The valuation ring of a valuative commutative square. -/\n  R : Type u\n  [commRing : CommRing R]\n  [domain : IsDomain R]\n  [valuationRing : ValuationRing R]\n  /-- The field of fractions of a valuative commutative square. -/\n  K : Type u\n  [field : Field K]\n  [algebra : Algebra R K]\n  [isFractionRing : IsFractionRing R K]\n  /-- The top map in a valuative commutative map. -/\n  (i‚ÇÅ : Spec (.of K) ‚ü∂ X)\n  /-- The bottom map in a valuative commutative map. -/\n  (i‚ÇÇ : Spec (.of R) ‚ü∂ Y)\n  (commSq : CommSq i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ)\n\n"}
{"name":"AlgebraicGeometry.ValuativeCommSq.valuationRing","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.ValuativeCommSq f\n‚ä¢ ValuationRing self.R","decl":"/--\nA valuative commutative square over a morphism `f : X ‚ü∂ Y` is a square\n```\nSpec K ‚ü∂ Y\n  |       |\n  ‚Üì       ‚Üì\nSpec R ‚ü∂ X\n```\nwhere `R` is a valuation ring, and `K` is its ring of fractions.\n\nWe are interested in finding lifts `Spec R ‚ü∂ Y` of this diagram.\n-/\nstructure ValuativeCommSq {X Y : Scheme.{u}} (f : X ‚ü∂ Y) where\n  /-- The valuation ring of a valuative commutative square. -/\n  R : Type u\n  [commRing : CommRing R]\n  [domain : IsDomain R]\n  [valuationRing : ValuationRing R]\n  /-- The field of fractions of a valuative commutative square. -/\n  K : Type u\n  [field : Field K]\n  [algebra : Algebra R K]\n  [isFractionRing : IsFractionRing R K]\n  /-- The top map in a valuative commutative map. -/\n  (i‚ÇÅ : Spec (.of K) ‚ü∂ X)\n  /-- The bottom map in a valuative commutative map. -/\n  (i‚ÇÇ : Spec (.of R) ‚ü∂ Y)\n  (commSq : CommSq i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ)\n\n"}
{"name":"AlgebraicGeometry.ValuativeCommSq.mk.inj","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nR‚úù : Type u\ncommRing‚úù : CommRing R‚úù\ndomain‚úù : IsDomain R‚úù\nvaluationRing‚úù : ValuationRing R‚úù\nK‚úù : Type u\nfield‚úù : Field K‚úù\nalgebra‚úù : Algebra R‚úù K‚úù\nisFractionRing‚úù : IsFractionRing R‚úù K‚úù\ni‚ÇÅ‚úù : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of K‚úù)) X\ni‚ÇÇ‚úù : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of R‚úù)) Y\ncommSq‚úù : CategoryTheory.CommSq i‚ÇÅ‚úù (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R‚úù K‚úù))) f i‚ÇÇ‚úù\nR : Type u\ncommRing : CommRing R\ndomain : IsDomain R\nvaluationRing : ValuationRing R\nK : Type u\nfield : Field K\nalgebra : Algebra R K\nisFractionRing : IsFractionRing R K\ni‚ÇÅ : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of K)) X\ni‚ÇÇ : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of R)) Y\ncommSq : CategoryTheory.CommSq i‚ÇÅ (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ\nx‚úù : Eq (AlgebraicGeometry.ValuativeCommSq.mk R‚úù K‚úù i‚ÇÅ‚úù i‚ÇÇ‚úù commSq‚úù) (AlgebraicGeometry.ValuativeCommSq.mk R K i‚ÇÅ i‚ÇÇ commSq)\n‚ä¢ And (Eq R‚úù R) (And (HEq commRing‚úù commRing) (And (Eq K‚úù K) (And (HEq field‚úù field) (And (HEq algebra‚úù algebra) (And (HEq i‚ÇÅ‚úù i‚ÇÅ) (HEq i‚ÇÇ‚úù i‚ÇÇ))))))","decl":"/--\nA valuative commutative square over a morphism `f : X ‚ü∂ Y` is a square\n```\nSpec K ‚ü∂ Y\n  |       |\n  ‚Üì       ‚Üì\nSpec R ‚ü∂ X\n```\nwhere `R` is a valuation ring, and `K` is its ring of fractions.\n\nWe are interested in finding lifts `Spec R ‚ü∂ Y` of this diagram.\n-/\nstructure ValuativeCommSq {X Y : Scheme.{u}} (f : X ‚ü∂ Y) where\n  /-- The valuation ring of a valuative commutative square. -/\n  R : Type u\n  [commRing : CommRing R]\n  [domain : IsDomain R]\n  [valuationRing : ValuationRing R]\n  /-- The field of fractions of a valuative commutative square. -/\n  K : Type u\n  [field : Field K]\n  [algebra : Algebra R K]\n  [isFractionRing : IsFractionRing R K]\n  /-- The top map in a valuative commutative map. -/\n  (i‚ÇÅ : Spec (.of K) ‚ü∂ X)\n  /-- The bottom map in a valuative commutative map. -/\n  (i‚ÇÇ : Spec (.of R) ‚ü∂ Y)\n  (commSq : CommSq i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ)\n\n"}
{"name":"AlgebraicGeometry.ValuativeCommSq.domain","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.ValuativeCommSq f\n‚ä¢ IsDomain self.R","decl":"/--\nA valuative commutative square over a morphism `f : X ‚ü∂ Y` is a square\n```\nSpec K ‚ü∂ Y\n  |       |\n  ‚Üì       ‚Üì\nSpec R ‚ü∂ X\n```\nwhere `R` is a valuation ring, and `K` is its ring of fractions.\n\nWe are interested in finding lifts `Spec R ‚ü∂ Y` of this diagram.\n-/\nstructure ValuativeCommSq {X Y : Scheme.{u}} (f : X ‚ü∂ Y) where\n  /-- The valuation ring of a valuative commutative square. -/\n  R : Type u\n  [commRing : CommRing R]\n  [domain : IsDomain R]\n  [valuationRing : ValuationRing R]\n  /-- The field of fractions of a valuative commutative square. -/\n  K : Type u\n  [field : Field K]\n  [algebra : Algebra R K]\n  [isFractionRing : IsFractionRing R K]\n  /-- The top map in a valuative commutative map. -/\n  (i‚ÇÅ : Spec (.of K) ‚ü∂ X)\n  /-- The bottom map in a valuative commutative map. -/\n  (i‚ÇÇ : Spec (.of R) ‚ü∂ Y)\n  (commSq : CommSq i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ)\n\n"}
{"name":"AlgebraicGeometry.ValuativeCriterion.iff","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.ValuativeCriterion f) (And (AlgebraicGeometry.ValuativeCriterion.Existence f) (AlgebraicGeometry.ValuativeCriterion.Uniqueness f))","decl":"lemma ValuativeCriterion.iff {f : X ‚ü∂ Y} :\n    ValuativeCriterion f ‚Üî Existence f ‚àß Uniqueness f := by\n  show (‚àÄ _, _) ‚Üî (‚àÄ _, _) ‚àß (‚àÄ _, _)\n  simp_rw [‚Üê forall_and, unique_iff_subsingleton_and_nonempty, and_comm, CommSq.HasLift.iff]\n\n"}
{"name":"AlgebraicGeometry.ValuativeCriterion.eq","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"‚ä¢ Eq AlgebraicGeometry.ValuativeCriterion (Min.min AlgebraicGeometry.ValuativeCriterion.Existence AlgebraicGeometry.ValuativeCriterion.Uniqueness)","decl":"lemma ValuativeCriterion.eq :\n    ValuativeCriterion = Existence ‚äì Uniqueness := by\n  ext X Y f\n  exact iff\n\n"}
{"name":"AlgebraicGeometry.ValuativeCriterion.existence","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nh : AlgebraicGeometry.ValuativeCriterion f\n‚ä¢ AlgebraicGeometry.ValuativeCriterion.Existence f","decl":"lemma ValuativeCriterion.existence {f : X ‚ü∂ Y} (h : ValuativeCriterion f) :\n    ValuativeCriterion.Existence f := (iff.mp h).1\n\n"}
{"name":"AlgebraicGeometry.ValuativeCriterion.uniqueness","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nh : AlgebraicGeometry.ValuativeCriterion f\n‚ä¢ AlgebraicGeometry.ValuativeCriterion.Uniqueness f","decl":"lemma ValuativeCriterion.uniqueness {f : X ‚ü∂ Y} (h : ValuativeCriterion f) :\n    ValuativeCriterion.Uniqueness f := (iff.mp h).2\n\n"}
{"name":"AlgebraicGeometry.ValuativeCriterion.Existence.specializingMap","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.ValuativeCriterion.Existence f\n‚ä¢ SpecializingMap ‚áëf.base","decl":"@[stacks 01KE]\nlemma specializingMap (H : ValuativeCriterion.Existence f) :\n    SpecializingMap f.base := by\n  intro x' y h\n  let stalk_y_to_residue_x' : Y.presheaf.stalk y ‚ü∂ X.residueField x' :=\n    Y.presheaf.stalkSpecializes h ‚â´ f.stalkMap x' ‚â´ X.residue x'\n  obtain ‚ü®A, hA, hA_local‚ü© := exists_factor_valuationRing stalk_y_to_residue_x'.hom\n  let stalk_y_to_A : Y.presheaf.stalk y ‚ü∂ .of A :=\n    CommRingCat.ofHom (stalk_y_to_residue_x'.hom.codRestrict _ hA)\n  have w : X.fromSpecResidueField x' ‚â´ f =\n      Spec.map (CommRingCat.ofHom (algebraMap A (X.residueField x'))) ‚â´\n        Spec.map stalk_y_to_A ‚â´ Y.fromSpecStalk y := by\n    rw [Scheme.fromSpecResidueField, Category.assoc, ‚Üê Scheme.Spec_map_stalkMap_fromSpecStalk,\n      ‚Üê Scheme.Spec_map_stalkSpecializes_fromSpecStalk h]\n    simp_rw [‚Üê Spec.map_comp_assoc]\n    rfl\n  obtain ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü© := (H { R := A, K := X.residueField x', commSq := ‚ü®w‚ü© }).exists_lift\n  dsimp only at hl‚ÇÅ hl‚ÇÇ\n  refine ‚ü®l.base (closedPoint A), ?_, ?_‚ü©\n  ¬∑ simp_rw [‚Üê Scheme.fromSpecResidueField_apply x' (closedPoint (X.residueField x')), ‚Üê hl‚ÇÅ]\n    exact (specializes_closedPoint _).map l.base.2\n  ¬∑ rw [‚Üê Scheme.comp_base_apply, hl‚ÇÇ]\n    simp only [Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply]\n    have : (Spec.map stalk_y_to_A).base (closedPoint A) = closedPoint (Y.presheaf.stalk y) :=\n      comap_closedPoint (S := A) (stalk_y_to_residue_x'.hom.codRestrict A.toSubring hA)\n    rw [this, Y.fromSpecStalk_closedPoint]\n\n"}
{"name":"AlgebraicGeometry.ValuativeCriterion.Existence.instIsLocalHomCarrierRingHomHomHomCommRingCat","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"R S : CommRingCat\ne : CategoryTheory.Iso R S\n‚ä¢ IsLocalHom (CommRingCat.Hom.hom e.hom)","decl":"instance {R S : CommRingCat} (e : R ‚âÖ S) : IsLocalHom e.hom.hom :=\n  isLocalHom_of_isIso _\n\n"}
{"name":"AlgebraicGeometry.ValuativeCriterion.Existence.of_specializingMap","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : (AlgebraicGeometry.topologically @SpecializingMap).universally f\n‚ä¢ AlgebraicGeometry.ValuativeCriterion.Existence f","decl":"lemma of_specializingMap (H : (topologically @SpecializingMap).universally f) :\n    ValuativeCriterion.Existence f := by\n  rintro ‚ü®R, K, i‚ÇÅ, i‚ÇÇ, ‚ü®w‚ü©‚ü©\n  haveI : IsDomain (CommRingCat.of R) := ‚Äπ_‚Ä∫\n  haveI : ValuationRing (CommRingCat.of R) := ‚Äπ_‚Ä∫\n  letI : Field (CommRingCat.of K) := ‚Äπ_‚Ä∫\n  replace H := H (pullback.snd i‚ÇÇ f) i‚ÇÇ (pullback.fst i‚ÇÇ f) (.of_hasPullback i‚ÇÇ f)\n  let lft := pullback.lift (Spec.map (CommRingCat.ofHom (algebraMap R K))) i‚ÇÅ w.symm\n  obtain ‚ü®x, h‚ÇÅ, h‚ÇÇ‚ü© := @H (lft.base (closedPoint _)) _ (specializes_closedPoint (R := R) _)\n  let e : CommRingCat.of R ‚âÖ (Spec (.of R)).presheaf.stalk ((pullback.fst i‚ÇÇ f).base x) :=\n    (stalkClosedPointIso (.of R)).symm ‚â™‚â´\n      (Spec (.of R)).presheaf.stalkCongr (.of_eq h‚ÇÇ.symm)\n  let Œ± := e.hom ‚â´ (pullback.fst i‚ÇÇ f).stalkMap x\n  have : IsLocalHom e.hom.hom := isLocalHom_of_isIso e.hom\n  have : IsLocalHom Œ±.hom := inferInstanceAs\n    (IsLocalHom (((pullback.fst i‚ÇÇ f).stalkMap x).hom.comp e.hom.hom))\n  let Œ≤ := (pullback i‚ÇÇ f).presheaf.stalkSpecializes h‚ÇÅ ‚â´ Scheme.stalkClosedPointTo lft\n  have hŒ±Œ≤ : Œ± ‚â´ Œ≤ = CommRingCat.ofHom (algebraMap R K) := by\n    simp only [CommRingCat.coe_of, Iso.trans_hom, Iso.symm_hom, TopCat.Presheaf.stalkCongr_hom,\n      Category.assoc, Œ±, e, Œ≤, stalkClosedPointIso_inv, StructureSheaf.toStalk]\n    show (Scheme.ŒìSpecIso (.of R)).inv ‚â´ (Spec (.of R)).presheaf.germ _ _ _ ‚â´ _ = _\n    simp only [TopCat.Presheaf.germ_stalkSpecializes_assoc, Scheme.stalkMap_germ_assoc,\n      TopologicalSpace.Opens.map_top]\n    erw [Scheme.germ_stalkClosedPointTo lft ‚ä§ trivial,\n      ‚Üê Scheme.comp_app_assoc lft (pullback.fst i‚ÇÇ f)]\n    rw [pullback.lift_fst]\n    simp\n  have hbij := (bijective_rangeRestrict_comp_of_valuationRing (R := R) (K := K) Œ±.hom Œ≤.hom\n    (CommRingCat.hom_ext_iff.mp hŒ±Œ≤))\n  let œÜ : (pullback i‚ÇÇ f).presheaf.stalk x ‚ü∂ CommRingCat.of R := CommRingCat.ofHom <|\n    (RingEquiv.ofBijective _ hbij).symm.toRingHom.comp Œ≤.hom.rangeRestrict\n  have hŒ±œÜ : Œ± ‚â´ œÜ = ùüô _ := by ext x; exact (RingEquiv.ofBijective _ hbij).symm_apply_apply x\n  have hŒ±œÜ' : (pullback.fst i‚ÇÇ f).stalkMap x ‚â´ œÜ = e.inv := by\n    rw [‚Üê cancel_epi e.hom, ‚Üê Category.assoc, hŒ±œÜ, e.hom_inv_id]\n  have hœÜŒ≤ : œÜ ‚â´ CommRingCat.ofHom (algebraMap R K) = Œ≤ :=\n    hŒ±Œ≤ ‚ñ∏ CommRingCat.hom_ext (RingHom.ext fun x ‚Ü¶ congr_arg Subtype.val\n      ((RingEquiv.ofBijective _ hbij).apply_symm_apply (Œ≤.hom.rangeRestrict x)))\n  refine ‚ü®‚ü®‚ü®Spec.map ((pullback.snd i‚ÇÇ f).stalkMap x ‚â´ œÜ) ‚â´ X.fromSpecStalk _, ?_, ?_‚ü©‚ü©‚ü©\n  ¬∑ simp only [‚Üê Spec.map_comp_assoc, Category.assoc, hœÜŒ≤]\n    simp only [Spec.map_comp, Category.assoc, Scheme.Spec_map_stalkMap_fromSpecStalk,\n      Scheme.Spec_map_stalkSpecializes_fromSpecStalk_assoc, Œ≤]\n    -- This next line only fires as `rw`, not `simp`:\n    rw [Scheme.Spec_stalkClosedPointTo_fromSpecStalk_assoc]\n    simp [lft]\n  ¬∑ simp only [Spec.map_comp, Category.assoc, Scheme.Spec_map_stalkMap_fromSpecStalk,\n      ‚Üê pullback.condition]\n    rw [‚Üê Scheme.Spec_map_stalkMap_fromSpecStalk_assoc, ‚Üê Spec.map_comp_assoc, hŒ±œÜ']\n    simp only [Iso.trans_inv, TopCat.Presheaf.stalkCongr_inv, Iso.symm_inv, Spec.map_comp,\n      Category.assoc, Scheme.Spec_map_stalkSpecializes_fromSpecStalk_assoc, e]\n    rw [‚Üê Spec_stalkClosedPointIso, ‚Üê Spec.map_comp_assoc,\n      Iso.inv_hom_id, Spec.map_id, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.ValuativeCriterion.Existence.stableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"‚ä¢ AlgebraicGeometry.ValuativeCriterion.Existence.IsStableUnderBaseChange","decl":"instance stableUnderBaseChange : ValuativeCriterion.Existence.IsStableUnderBaseChange := by\n  constructor\n  intros Y' X X' Y  Y'_to_Y f X'_to_X f' hP hf commSq\n  let commSq' : ValuativeCommSq f :=\n  { R := commSq.R\n    K := commSq.K\n    i‚ÇÅ := commSq.i‚ÇÅ ‚â´ X'_to_X\n    i‚ÇÇ := commSq.i‚ÇÇ ‚â´ Y'_to_Y\n    commSq := ‚ü®by simp only [Category.assoc, hP.w, reassoc_of% commSq.commSq.w]‚ü© }\n  obtain ‚ü®l‚ÇÄ, hl‚ÇÅ, hl‚ÇÇ‚ü© := (hf commSq').exists_lift\n  refine ‚ü®‚ü®‚ü®hP.lift l‚ÇÄ commSq.i‚ÇÇ (by simp_all only [commSq']), ?_, hP.lift_snd _ _ _‚ü©‚ü©‚ü©\n  apply hP.hom_ext\n  ¬∑ simpa\n  ¬∑ simp only [Category.assoc]\n    rw [hP.lift_snd]\n    rw [commSq.commSq.w]\n\n"}
{"name":"AlgebraicGeometry.ValuativeCriterion.Existence.eq","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"‚ä¢ Eq AlgebraicGeometry.ValuativeCriterion.Existence (AlgebraicGeometry.topologically @SpecializingMap).universally","decl":"@[stacks 01KE]\nprotected lemma eq :\n    ValuativeCriterion.Existence = (topologically @SpecializingMap).universally := by\n  ext\n  constructor\n  ¬∑ intro _\n    apply MorphismProperty.universally_mono\n    ¬∑ apply specializingMap\n    ¬∑ rwa [MorphismProperty.IsStableUnderBaseChange.universally_eq]\n  ¬∑ apply of_specializingMap\n\n"}
{"name":"AlgebraicGeometry.UniversallyClosed.eq_valuativeCriterion","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"‚ä¢ Eq (@AlgebraicGeometry.UniversallyClosed) (Min.min AlgebraicGeometry.ValuativeCriterion.Existence @AlgebraicGeometry.QuasiCompact)","decl":"/-- The **valuative criterion** for universally closed morphisms. -/\n@[stacks 01KF]\nlemma UniversallyClosed.eq_valuativeCriterion :\n    @UniversallyClosed = ValuativeCriterion.Existence ‚äì @QuasiCompact := by\n  rw [universallyClosed_eq_universallySpecializing, ValuativeCriterion.Existence.eq]\n\n"}
{"name":"AlgebraicGeometry.UniversallyClosed.of_valuativeCriterion","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.QuasiCompact f\nhf : AlgebraicGeometry.ValuativeCriterion.Existence f\n‚ä¢ AlgebraicGeometry.UniversallyClosed f","decl":"/-- The **valuative criterion** for universally closed morphisms. -/\n@[stacks 01KF]\nlemma UniversallyClosed.of_valuativeCriterion [QuasiCompact f]\n    (hf : ValuativeCriterion.Existence f) : UniversallyClosed f := by\n  rw [eq_valuativeCriterion]\n  exact ‚ü®hf, ‚Äπ_‚Ä∫‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.of_valuativeCriterion","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.QuasiSeparated f\nhf : AlgebraicGeometry.ValuativeCriterion.Uniqueness f\n‚ä¢ AlgebraicGeometry.IsSeparated f","decl":"/-- The **valuative criterion** for separated morphisms. -/\n@[stacks 01L0]\nlemma IsSeparated.of_valuativeCriterion [QuasiSeparated f]\n    (hf : ValuativeCriterion.Uniqueness f) : IsSeparated f where\n  diagonal_isClosedImmersion := by\n    suffices h : ValuativeCriterion.Existence (pullback.diagonal f) by\n      have : QuasiCompact (pullback.diagonal f) :=\n        AlgebraicGeometry.QuasiSeparated.diagonalQuasiCompact\n      apply IsClosedImmersion.of_isPreimmersion\n      apply IsClosedMap.isClosed_range\n      apply (topologically @IsClosedMap).universally_le\n      exact (UniversallyClosed.of_valuativeCriterion (pullback.diagonal f) h).out\n    intro S\n    have hc : CommSq S.i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap S.R S.K)))\n        f (S.i‚ÇÇ ‚â´ pullback.fst f f ‚â´ f) := ‚ü®by simp [‚Üê S.commSq.w_assoc]‚ü©\n    let S' : ValuativeCommSq f := ‚ü®S.R, S.K, S.i‚ÇÅ, S.i‚ÇÇ ‚â´ pullback.fst f f ‚â´ f, hc‚ü©\n    have : Subsingleton S'.commSq.LiftStruct := hf S'\n    let S'l‚ÇÅ : S'.commSq.LiftStruct := ‚ü®S.i‚ÇÇ ‚â´ pullback.fst f f,\n      by simp [S', ‚Üê S.commSq.w_assoc], by simp [S']‚ü©\n    let S'l‚ÇÇ : S'.commSq.LiftStruct := ‚ü®S.i‚ÇÇ ‚â´ pullback.snd f f,\n      by simp [S', ‚Üê S.commSq.w_assoc], by simp [S', pullback.condition]‚ü©\n    have h‚ÇÅ‚ÇÇ : S'l‚ÇÅ = S'l‚ÇÇ := Subsingleton.elim _ _\n    constructor\n    constructor\n    refine ‚ü®S.i‚ÇÇ ‚â´ pullback.fst _ _, ?_, ?_‚ü©\n    ¬∑ simp [‚Üê S.commSq.w_assoc]\n    ¬∑ simp\n      apply IsPullback.hom_ext (IsPullback.of_hasPullback _ _)\n      ¬∑ simp\n      ¬∑ simp only [Category.assoc, pullback.diagonal_snd, Category.comp_id]\n        exact congrArg CommSq.LiftStruct.l h‚ÇÅ‚ÇÇ\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.valuativeCriterion","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsSeparated f\n‚ä¢ AlgebraicGeometry.ValuativeCriterion.Uniqueness f","decl":"@[stacks 01KZ]\nlemma IsSeparated.valuativeCriterion [IsSeparated f] : ValuativeCriterion.Uniqueness f := by\n  intros S\n  constructor\n  rintro ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü© ‚ü®l‚ÇÇ, hl‚ÇÇ, hl‚ÇÇ'‚ü©\n  ext : 1\n  dsimp at *\n  have h := hl‚ÇÅ'.trans hl‚ÇÇ'.symm\n  let Z := pullback (pullback.diagonal f) (pullback.lift l‚ÇÅ l‚ÇÇ h)\n  let g : Z ‚ü∂ Spec (.of S.R) := pullback.snd _ _\n  have : IsClosedImmersion g := MorphismProperty.pullback_snd _ _ inferInstance\n  have hZ : IsAffine Z := by\n    rw [@HasAffineProperty.iff_of_isAffine @IsClosedImmersion] at this\n    exact this.left\n  suffices IsIso g by\n    rw [‚Üê cancel_epi g]\n    conv_lhs => rw [‚Üê pullback.lift_fst l‚ÇÅ l‚ÇÇ h, ‚Üê pullback.condition_assoc]\n    conv_rhs => rw [‚Üê pullback.lift_snd l‚ÇÅ l‚ÇÇ h, ‚Üê pullback.condition_assoc]\n    simp\n  suffices h : Function.Bijective (g.appTop) by\n    refine (HasAffineProperty.iff_of_isAffine (P := MorphismProperty.isomorphisms Scheme)).mpr ?_\n    exact ‚ü®hZ, (ConcreteCategory.isIso_iff_bijective _).mpr h‚ü©\n  constructor\n  ¬∑ let l : Spec (.of S.K) ‚ü∂ Z := by\n      apply pullback.lift S.i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap S.R S.K)))\n      apply IsPullback.hom_ext (IsPullback.of_hasPullback _ _)\n      simpa using hl‚ÇÅ.symm\n      simpa using hl‚ÇÇ.symm\n    have hg : l ‚â´ g = Spec.map (CommRingCat.ofHom (algebraMap S.R S.K)) :=\n      pullback.lift_snd _ _ _\n    have : Function.Injective ((l ‚â´ g).appTop) := by\n      rw [hg]\n      let e := arrowIsoŒìSpecOfIsAffine (CommRingCat.ofHom <| algebraMap S.R S.K)\n      let P : MorphismProperty CommRingCat :=\n        RingHom.toMorphismProperty <| fun f ‚Ü¶ Function.Injective f\n      have : (RingHom.toMorphismProperty <| fun f ‚Ü¶ Function.Injective f).RespectsIso :=\n        RingHom.toMorphismProperty_respectsIso_iff.mp RingHom.injective_respectsIso\n      show P _\n      rw [‚Üê MorphismProperty.arrow_mk_iso_iff (P := P) e]\n      exact NoZeroSMulDivisors.algebraMap_injective S.R S.K\n    rw [Scheme.comp_appTop] at this\n    exact Function.Injective.of_comp this\n  ¬∑ rw [@HasAffineProperty.iff_of_isAffine @IsClosedImmersion] at this\n    exact this.right\n\n"}
{"name":"AlgebraicGeometry.IsSeparated.eq_valuativeCriterion","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"‚ä¢ Eq (@AlgebraicGeometry.IsSeparated) (Min.min AlgebraicGeometry.ValuativeCriterion.Uniqueness @AlgebraicGeometry.QuasiSeparated)","decl":"/-- The **valuative criterion** for separated morphisms. -/\nlemma IsSeparated.eq_valuativeCriterion :\n    @IsSeparated = ValuativeCriterion.Uniqueness ‚äì @QuasiSeparated := by\n  ext X Y f\n  exact ‚ü®fun _ ‚Ü¶ ‚ü®IsSeparated.valuativeCriterion f, inferInstance‚ü©,\n    fun ‚ü®H, _‚ü© ‚Ü¶ .of_valuativeCriterion f H‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsProper.eq_valuativeCriterion","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"‚ä¢ Eq (@AlgebraicGeometry.IsProper) (Min.min (Min.min (Min.min AlgebraicGeometry.ValuativeCriterion @AlgebraicGeometry.QuasiCompact) @AlgebraicGeometry.QuasiSeparated) @AlgebraicGeometry.LocallyOfFiniteType)","decl":"/-- The **valuative criterion** for proper morphisms. -/\n@[stacks 0BX5]\nlemma IsProper.eq_valuativeCriterion :\n    @IsProper = ValuativeCriterion ‚äì @QuasiCompact ‚äì @QuasiSeparated ‚äì @LocallyOfFiniteType := by\n  rw [isProper_eq, IsSeparated.eq_valuativeCriterion, ValuativeCriterion.eq,\n    UniversallyClosed.eq_valuativeCriterion]\n  simp_rw [inf_assoc]\n  ext X Y f\n  show _ ‚àß _ ‚àß _ ‚àß _ ‚àß _ ‚Üî _ ‚àß _ ‚àß _ ‚àß _ ‚àß _\n  tauto\n\n"}
{"name":"AlgebraicGeometry.IsProper.of_valuativeCriterion","module":"Mathlib.AlgebraicGeometry.ValuativeCriterion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù¬≤ : AlgebraicGeometry.QuasiCompact f\ninst‚úù¬π : AlgebraicGeometry.QuasiSeparated f\ninst‚úù : AlgebraicGeometry.LocallyOfFiniteType f\nH : AlgebraicGeometry.ValuativeCriterion f\n‚ä¢ AlgebraicGeometry.IsProper f","decl":"/-- The **valuative criterion** for proper morphisms. -/\n@[stacks 0BX5]\nlemma IsProper.of_valuativeCriterion [QuasiCompact f] [QuasiSeparated f] [LocallyOfFiniteType f]\n    (H : ValuativeCriterion f) : IsProper f := by\n  rw [eq_valuativeCriterion]\n  exact ‚ü®‚ü®‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©, ‚Äπ_‚Ä∫‚ü©, ‚Äπ_‚Ä∫‚ü©\n\n"}
