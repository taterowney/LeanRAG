{"name":"Set.toFinset_iUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Fintype β\ninst✝¹ : DecidableEq α\nf : β → Set α\ninst✝ : (w : β) → Fintype ↑(f w)\n⊢ Eq (Set.iUnion fun x => f x).toFinset (Finset.univ.biUnion fun x => (f x).toFinset)","decl":"lemma toFinset_iUnion [Fintype β] [DecidableEq α] (f : β → Set α)\n    [∀ w, Fintype (f w)] :\n    Set.toFinset (⋃ (x : β), f x) =\n    Finset.biUnion (Finset.univ : Finset β) (fun x => (f x).toFinset) := by\n  ext v\n  simp only [mem_toFinset, mem_iUnion, Finset.mem_biUnion, Finset.mem_univ, true_and]\n\n"}
{"name":"Finite.Set.finite_iUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Sort w\ninst✝¹ : Finite ι\nf : ι → Set α\ninst✝ : ∀ (i : ι), Finite ↑(f i)\n⊢ Finite ↑(Set.iUnion fun i => f i)","decl":"instance finite_iUnion [Finite ι] (f : ι → Set α) [∀ i, Finite (f i)] : Finite (⋃ i, f i) := by\n  rw [iUnion_eq_range_psigma]\n  apply Set.finite_range\n\n"}
{"name":"Finite.Set.finite_sUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ns : Set (Set α)\ninst✝ : Finite ↑s\nH : ∀ (t : ↑s), Finite ↑↑t\n⊢ Finite ↑s.sUnion","decl":"instance finite_sUnion {s : Set (Set α)} [Finite s] [H : ∀ t : s, Finite (t : Set α)] :\n    Finite (⋃₀ s) := by\n  rw [sUnion_eq_iUnion]\n  exact @Finite.Set.finite_iUnion _ _ _ _ H\n\n"}
{"name":"Finite.Set.finite_biUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\ns : Set ι\ninst✝ : Finite ↑s\nt : ι → Set α\nH : ∀ (i : ι), Membership.mem s i → Finite ↑(t i)\n⊢ Finite ↑(Set.iUnion fun x => Set.iUnion fun h => t x)","decl":"theorem finite_biUnion {ι : Type*} (s : Set ι) [Finite s] (t : ι → Set α)\n    (H : ∀ i ∈ s, Finite (t i)) : Finite (⋃ x ∈ s, t x) := by\n  rw [biUnion_eq_iUnion]\n  haveI : ∀ i : s, Finite (t i) := fun i => H i i.property\n  infer_instance\n\n"}
{"name":"Finite.Set.finite_biUnion'","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\ns : Set ι\ninst✝¹ : Finite ↑s\nt : ι → Set α\ninst✝ : ∀ (i : ι), Finite ↑(t i)\n⊢ Finite ↑(Set.iUnion fun x => Set.iUnion fun h => t x)","decl":"instance finite_biUnion' {ι : Type*} (s : Set ι) [Finite s] (t : ι → Set α) [∀ i, Finite (t i)] :\n    Finite (⋃ x ∈ s, t x) :=\n  finite_biUnion s t fun _ _ => inferInstance\n\n"}
{"name":"Finite.Set.finite_biUnion''","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\np : ι → Prop\nh : Finite ↑(setOf fun x => p x)\nt : ι → Set α\ninst✝ : ∀ (i : ι), Finite ↑(t i)\n⊢ Finite ↑(Set.iUnion fun x => Set.iUnion fun x_1 => t x)","decl":"/-- Example: `Finite (⋃ (i < n), f i)` where `f : ℕ → Set α` and `[∀ i, Finite (f i)]`\n(when given instances from `Order.Interval.Finset.Nat`).\n-/\ninstance finite_biUnion'' {ι : Type*} (p : ι → Prop) [h : Finite { x | p x }] (t : ι → Set α)\n    [∀ i, Finite (t i)] : Finite (⋃ (x) (_ : p x), t x) :=\n  @Finite.Set.finite_biUnion' _ _ (setOf p) h t _\n\n"}
{"name":"Finite.Set.finite_iInter","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Sort u_1\ninst✝¹ : Nonempty ι\nt : ι → Set α\ninst✝ : ∀ (i : ι), Finite ↑(t i)\n⊢ Finite ↑(Set.iInter fun i => t i)","decl":"instance finite_iInter {ι : Sort*} [Nonempty ι] (t : ι → Set α) [∀ i, Finite (t i)] :\n    Finite (⋂ i, t i) :=\n  Finite.Set.subset (t <| Classical.arbitrary ι) (iInter_subset _ _)\n\n"}
{"name":"Set.finite_iUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Sort w\ninst✝ : Finite ι\nf : ι → Set α\nH : ∀ (i : ι), (f i).Finite\n⊢ (Set.iUnion fun i => f i).Finite","decl":"theorem finite_iUnion [Finite ι] {f : ι → Set α} (H : ∀ i, (f i).Finite) : (⋃ i, f i).Finite :=\n  haveI := fun i => (H i).to_subtype\n  toFinite _\n\n"}
{"name":"Set.Finite.biUnion'","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\ns : Set ι\nhs : s.Finite\nt : (i : ι) → Membership.mem s i → Set α\nht : ∀ (i : ι) (hi : Membership.mem s i), (t i hi).Finite\n⊢ (Set.iUnion fun i => Set.iUnion fun h => t i h).Finite","decl":"/-- Dependent version of `Finite.biUnion`. -/\ntheorem Finite.biUnion' {ι} {s : Set ι} (hs : s.Finite) {t : ∀ i ∈ s, Set α}\n    (ht : ∀ i (hi : i ∈ s), (t i hi).Finite) : (⋃ i ∈ s, t i ‹_›).Finite := by\n  have := hs.to_subtype\n  rw [biUnion_eq_iUnion]\n  apply finite_iUnion fun i : s => ht i.1 i.2\n\n"}
{"name":"Set.Finite.biUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\ns : Set ι\nhs : s.Finite\nt : ι → Set α\nht : ∀ (i : ι), Membership.mem s i → (t i).Finite\n⊢ (Set.iUnion fun i => Set.iUnion fun h => t i).Finite","decl":"theorem Finite.biUnion {ι} {s : Set ι} (hs : s.Finite) {t : ι → Set α}\n    (ht : ∀ i ∈ s, (t i).Finite) : (⋃ i ∈ s, t i).Finite :=\n  hs.biUnion' ht\n\n"}
{"name":"Set.Finite.sUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ns : Set (Set α)\nhs : s.Finite\nH : ∀ (t : Set α), Membership.mem s t → t.Finite\n⊢ s.sUnion.Finite","decl":"theorem Finite.sUnion {s : Set (Set α)} (hs : s.Finite) (H : ∀ t ∈ s, Set.Finite t) :\n    (⋃₀ s).Finite := by\n  simpa only [sUnion_eq_biUnion] using hs.biUnion H\n\n"}
{"name":"Set.Finite.sInter","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\nt : Set α\nht : Membership.mem s t\nhf : t.Finite\n⊢ s.sInter.Finite","decl":"theorem Finite.sInter {α : Type*} {s : Set (Set α)} {t : Set α} (ht : t ∈ s) (hf : t.Finite) :\n    (⋂₀ s).Finite :=\n  hf.subset (sInter_subset_of_mem ht)\n\n"}
{"name":"Set.Finite.iUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\ns : ι → Set α\nt : Set ι\nht : t.Finite\nhs : ∀ (i : ι), Membership.mem t i → (s i).Finite\nhe : ∀ (i : ι), Not (Membership.mem t i) → Eq (s i) EmptyCollection.emptyCollection\n⊢ (Set.iUnion fun i => s i).Finite","decl":"/-- If sets `s i` are finite for all `i` from a finite set `t` and are empty for `i ∉ t`, then the\nunion `⋃ i, s i` is a finite set. -/\ntheorem Finite.iUnion {ι : Type*} {s : ι → Set α} {t : Set ι} (ht : t.Finite)\n    (hs : ∀ i ∈ t, (s i).Finite) (he : ∀ i, i ∉ t → s i = ∅) : (⋃ i, s i).Finite := by\n  suffices ⋃ i, s i ⊆ ⋃ i ∈ t, s i by exact (ht.biUnion hs).subset this\n  refine iUnion_subset fun i x hx => ?_\n  by_cases hi : i ∈ t\n  · exact mem_biUnion hi hx\n  · rw [he i hi, mem_empty_iff_false] at hx\n    contradiction\n\n"}
{"name":"Set.finite_iUnion_iff","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\ns : ι → Set α\nhs : Pairwise fun i j => Disjoint (s i) (s j)\n⊢ Iff (Set.iUnion fun i => s i).Finite (And (∀ (i : ι), (s i).Finite) (setOf fun i => (s i).Nonempty).Finite)","decl":"/-- An indexed union of pairwise disjoint sets is finite iff all sets are finite, and all but\nfinitely many are empty. -/\nlemma finite_iUnion_iff {ι : Type*} {s : ι → Set α} (hs : Pairwise fun i j ↦ Disjoint (s i) (s j)) :\n    (⋃ i, s i).Finite ↔ (∀ i, (s i).Finite) ∧ {i | (s i).Nonempty}.Finite where\n  mp h := by\n    refine ⟨fun i ↦ h.subset <| subset_iUnion _ _, ?_⟩\n    let u (i : {i | (s i).Nonempty}) : ⋃ i, s i := ⟨i.2.choose, mem_iUnion.2 ⟨i.1, i.2.choose_spec⟩⟩\n    have u_inj : Function.Injective u := by\n      rintro ⟨i, hi⟩ ⟨j, hj⟩ hij\n      ext\n      refine hs.eq <| not_disjoint_iff.2 ⟨u ⟨i, hi⟩, hi.choose_spec, ?_⟩\n      rw [hij]\n      exact hj.choose_spec\n    have : Finite (⋃ i, s i) := h\n    exact .of_injective u u_inj\n  mpr h := h.2.iUnion (fun _ _ ↦ h.1 _) (by simp [not_nonempty_iff_eq_empty])\n\n"}
{"name":"Set.finite_iUnion_of_subsingleton","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Sort u_1\ninst✝ : Subsingleton ι\ns : ι → Set α\n⊢ Iff (Set.iUnion fun i => s i).Finite (∀ (i : ι), (s i).Finite)","decl":"@[simp] lemma finite_iUnion_of_subsingleton {ι : Sort*} [Subsingleton ι] {s : ι → Set α} :\n    (⋃ i, s i).Finite ↔ ∀ i, (s i).Finite := by\n  rw [← iUnion_plift_down, finite_iUnion_iff _root_.Subsingleton.pairwise]\n  simp [PLift.forall, Finite.of_subsingleton]\n\n"}
{"name":"Set.PairwiseDisjoint.finite_biUnion_iff","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : β → Set α\ns : Set β\nhs : s.PairwiseDisjoint f\n⊢ Iff (Set.iUnion fun i => Set.iUnion fun h => f i).Finite (And (∀ (i : β), Membership.mem s i → (f i).Finite) (setOf fun i => And (Membership.mem s i) (f i).Nonempty).Finite)","decl":"/-- An indexed union of pairwise disjoint sets is finite iff all sets are finite, and all but\nfinitely many are empty. -/\nlemma PairwiseDisjoint.finite_biUnion_iff {f : β → Set α} {s : Set β} (hs : s.PairwiseDisjoint f) :\n    (⋃ i ∈ s, f i).Finite ↔ (∀ i ∈ s, (f i).Finite) ∧ {i ∈ s | (f i).Nonempty}.Finite := by\n  rw [finite_iUnion_iff (by aesop (add unfold safe [Pairwise, PairwiseDisjoint, Set.Pairwise]))]\n  simp\n\n"}
{"name":"Set.Finite.preimage'","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set β\nh : s.Finite\nhf : ∀ (b : β), Membership.mem s b → (Set.preimage f (Singleton.singleton b)).Finite\n⊢ (Set.preimage f s).Finite","decl":"theorem Finite.preimage' (h : s.Finite) (hf : ∀ b ∈ s, (f ⁻¹' {b}).Finite) :\n    (f ⁻¹' s).Finite := by\n  rw [← Set.biUnion_preimage_singleton]\n  exact Set.Finite.biUnion h hf\n\n"}
{"name":"Set.union_finset_finite_of_range_finite","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → Finset β\nh : (Set.range f).Finite\n⊢ (Set.iUnion fun a => ↑(f a)).Finite","decl":"/-- A finite union of finsets is finite. -/\ntheorem union_finset_finite_of_range_finite (f : α → Finset β) (h : (range f).Finite) :\n    (⋃ a, (f a : Set β)).Finite := by\n  rw [← biUnion_range]\n  exact h.biUnion fun y _ => y.finite_toSet\n\n"}
{"name":"Set.Finite.of_finite_fibers","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Set α\nhimage : (Set.image f s).Finite\nhfibers : ∀ (x : β), Membership.mem (Set.image f s) x → (Inter.inter s (Set.preimage f (Singleton.singleton x))).Finite\n⊢ s.Finite","decl":"/--\nIf the image of `s` under `f` is finite, and each fiber of `f` has a finite intersection\nwith `s`, then `s` is itself finite.\n\nIt is useful to give `f` explicitly here so this can be used with `apply`.\n-/\nlemma Finite.of_finite_fibers (f : α → β) {s : Set α} (himage : (f '' s).Finite)\n    (hfibers : ∀ x ∈ f '' s, (s ∩ f ⁻¹' {x}).Finite) : s.Finite :=\n  (himage.biUnion hfibers).subset fun x ↦ by aesop\n\n"}
{"name":"Set.finite_subset_iUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\nι : Type u_1\nt : ι → Set α\nh : HasSubset.Subset s (Set.iUnion fun i => t i)\n⊢ Exists fun I => And I.Finite (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => t i))","decl":"theorem finite_subset_iUnion {s : Set α} (hs : s.Finite) {ι} {t : ι → Set α} (h : s ⊆ ⋃ i, t i) :\n    ∃ I : Set ι, I.Finite ∧ s ⊆ ⋃ i ∈ I, t i := by\n  have := hs.to_subtype\n  choose f hf using show ∀ x : s, ∃ i, x.1 ∈ t i by simpa [subset_def] using h\n  refine ⟨range f, finite_range f, fun x hx => ?_⟩\n  rw [biUnion_range, mem_iUnion]\n  exact ⟨⟨x, hx⟩, hf _⟩\n\n"}
{"name":"Set.eq_finite_iUnion_of_finite_subset_iUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\ns : ι → Set α\nt : Set α\ntfin : t.Finite\nh : HasSubset.Subset t (Set.iUnion fun i => s i)\n⊢ Exists fun I => And I.Finite (Exists fun σ => And (∀ (i : ↑(setOf fun i => Membership.mem I i)), (σ i).Finite) (And (∀ (i : ↑(setOf fun i => Membership.mem I i)), HasSubset.Subset (σ i) (s ↑i)) (Eq t (Set.iUnion fun i => σ i))))","decl":"theorem eq_finite_iUnion_of_finite_subset_iUnion {ι} {s : ι → Set α} {t : Set α} (tfin : t.Finite)\n    (h : t ⊆ ⋃ i, s i) :\n    ∃ I : Set ι,\n      I.Finite ∧\n        ∃ σ : { i | i ∈ I } → Set α, (∀ i, (σ i).Finite) ∧ (∀ i, σ i ⊆ s i) ∧ t = ⋃ i, σ i :=\n  let ⟨I, Ifin, hI⟩ := finite_subset_iUnion tfin h\n  ⟨I, Ifin, fun x => s x ∩ t, fun _ => tfin.subset inter_subset_right, fun _ =>\n    inter_subset_left, by\n    ext x\n    rw [mem_iUnion]\n    constructor\n    · intro x_in\n      rcases mem_iUnion.mp (hI x_in) with ⟨i, _, ⟨hi, rfl⟩, H⟩\n      exact ⟨⟨i, hi⟩, ⟨H, x_in⟩⟩\n    · rintro ⟨i, -, H⟩\n      exact H⟩\n\n"}
{"name":"Set.infinite_iUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\ninst✝ : Infinite ι\ns : ι → Set α\nhs : Function.Injective s\n⊢ (Set.iUnion fun i => s i).Infinite","decl":"theorem infinite_iUnion {ι : Type*} [Infinite ι] {s : ι → Set α} (hs : Function.Injective s) :\n    (⋃ i, s i).Infinite :=\n  fun hfin ↦ @not_injective_infinite_finite ι _ _ hfin.finite_subsets.to_subtype\n    (fun i ↦ ⟨s i, subset_iUnion _ _⟩) fun i j h_eq ↦ hs (by simpa using h_eq)\n\n"}
{"name":"Set.Infinite.biUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nι : Type u_1\ns : ι → Set α\na : Set ι\nha : a.Infinite\nhs : Set.InjOn s a\n⊢ (Set.iUnion fun i => Set.iUnion fun h => s i).Infinite","decl":"theorem Infinite.biUnion {ι : Type*} {s : ι → Set α} {a : Set ι} (ha : a.Infinite)\n    (hs : a.InjOn s) : (⋃ i ∈ a, s i).Infinite := by\n  rw [biUnion_eq_iUnion]\n  have _ := ha.to_subtype\n  exact infinite_iUnion fun ⟨i,hi⟩ ⟨j,hj⟩ hij ↦ by simp [hs hi hj hij]\n\n"}
{"name":"Set.Infinite.sUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ns : Set (Set α)\nhs : s.Infinite\n⊢ s.sUnion.Infinite","decl":"theorem Infinite.sUnion {s : Set (Set α)} (hs : s.Infinite) : (⋃₀ s).Infinite := by\n  rw [sUnion_eq_iUnion]\n  have _ := hs.to_subtype\n  exact infinite_iUnion Subtype.coe_injective\n\n"}
{"name":"Set.map_finite_biSup","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\nF : Type u_1\nι : Type u_2\ninst✝³ : CompleteLattice α\ninst✝² : CompleteLattice β\ninst✝¹ : FunLike F α β\ninst✝ : SupBotHomClass F α β\ns : Set ι\nhs : s.Finite\nf : F\ng : ι → α\n⊢ Eq (f (iSup fun x => iSup fun h => g x)) (iSup fun x => iSup fun h => f (g x))","decl":"lemma map_finite_biSup {F ι : Type*} [CompleteLattice α] [CompleteLattice β] [FunLike F α β]\n    [SupBotHomClass F α β] {s : Set ι} (hs : s.Finite) (f : F) (g : ι → α) :\n    f (⨆ x ∈ s, g x) = ⨆ x ∈ s, f (g x) := by\n  have := map_finset_sup f hs.toFinset g\n  simp only [Finset.sup_eq_iSup, hs.mem_toFinset, comp_apply] at this\n  exact this\n\n"}
{"name":"Set.map_finite_biInf","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\nF : Type u_1\nι : Type u_2\ninst✝³ : CompleteLattice α\ninst✝² : CompleteLattice β\ninst✝¹ : FunLike F α β\ninst✝ : InfTopHomClass F α β\ns : Set ι\nhs : s.Finite\nf : F\ng : ι → α\n⊢ Eq (f (iInf fun x => iInf fun h => g x)) (iInf fun x => iInf fun h => f (g x))","decl":"lemma map_finite_biInf {F ι : Type*} [CompleteLattice α] [CompleteLattice β] [FunLike F α β]\n    [InfTopHomClass F α β] {s : Set ι} (hs : s.Finite) (f : F) (g : ι → α) :\n    f (⨅ x ∈ s, g x) = ⨅ x ∈ s, f (g x) := by\n  have := map_finset_inf f hs.toFinset g\n  simp only [Finset.inf_eq_iInf, hs.mem_toFinset, comp_apply] at this\n  exact this\n\n"}
{"name":"Set.map_finite_iSup","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\nF : Type u_1\nι : Type u_2\ninst✝⁴ : CompleteLattice α\ninst✝³ : CompleteLattice β\ninst✝² : FunLike F α β\ninst✝¹ : SupBotHomClass F α β\ninst✝ : Finite ι\nf : F\ng : ι → α\n⊢ Eq (f (iSup fun i => g i)) (iSup fun i => f (g i))","decl":"lemma map_finite_iSup {F ι : Type*} [CompleteLattice α] [CompleteLattice β] [FunLike F α β]\n    [SupBotHomClass F α β] [Finite ι] (f : F) (g : ι → α) :\n    f (⨆ i, g i) = ⨆ i, f (g i) := by\n  rw [← iSup_univ (f := g), ← iSup_univ (f := fun i ↦ f (g i))]\n  exact map_finite_biSup finite_univ f g\n\n"}
{"name":"Set.map_finite_iInf","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\nF : Type u_1\nι : Type u_2\ninst✝⁴ : CompleteLattice α\ninst✝³ : CompleteLattice β\ninst✝² : FunLike F α β\ninst✝¹ : InfTopHomClass F α β\ninst✝ : Finite ι\nf : F\ng : ι → α\n⊢ Eq (f (iInf fun i => g i)) (iInf fun i => f (g i))","decl":"lemma map_finite_iInf {F ι : Type*} [CompleteLattice α] [CompleteLattice β] [FunLike F α β]\n    [InfTopHomClass F α β] [Finite ι] (f : F) (g : ι → α) :\n    f (⨅ i, g i) = ⨅ i, f (g i) := by\n  rw [← iInf_univ (f := g), ← iInf_univ (f := fun i ↦ f (g i))]\n  exact map_finite_biInf finite_univ f g\n\n"}
{"name":"Set.Finite.iSup_biInf_of_monotone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝³ : Preorder ι'\ninst✝² : Nonempty ι'\ninst✝¹ : IsDirected ι' fun x1 x2 => LE.le x1 x2\ninst✝ : Order.Frame α\ns : Set ι\nhs : s.Finite\nf : ι → ι' → α\nhf : ∀ (i : ι), Membership.mem s i → Monotone (f i)\n⊢ Eq (iSup fun j => iInf fun i => iInf fun h => f i j) (iInf fun i => iInf fun h => iSup fun j => f i j)","decl":"theorem Finite.iSup_biInf_of_monotone {ι ι' α : Type*} [Preorder ι'] [Nonempty ι']\n    [IsDirected ι' (· ≤ ·)] [Order.Frame α] {s : Set ι} (hs : s.Finite) {f : ι → ι' → α}\n    (hf : ∀ i ∈ s, Monotone (f i)) : ⨆ j, ⨅ i ∈ s, f i j = ⨅ i ∈ s, ⨆ j, f i j := by\n  induction s, hs using Set.Finite.induction_on with\n  | empty => simp [iSup_const]\n  | insert _ _ ihs =>\n    rw [forall_mem_insert] at hf\n    simp only [iInf_insert, ← ihs hf.2]\n    exact iSup_inf_of_monotone hf.1 fun j₁ j₂ hj => iInf₂_mono fun i hi => hf.2 i hi hj\n\n"}
{"name":"Set.Finite.iSup_biInf_of_antitone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝³ : Preorder ι'\ninst✝² : Nonempty ι'\ninst✝¹ : IsDirected ι' (Function.swap fun x1 x2 => LE.le x1 x2)\ninst✝ : Order.Frame α\ns : Set ι\nhs : s.Finite\nf : ι → ι' → α\nhf : ∀ (i : ι), Membership.mem s i → Antitone (f i)\n⊢ Eq (iSup fun j => iInf fun i => iInf fun h => f i j) (iInf fun i => iInf fun h => iSup fun j => f i j)","decl":"theorem Finite.iSup_biInf_of_antitone {ι ι' α : Type*} [Preorder ι'] [Nonempty ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Order.Frame α] {s : Set ι} (hs : s.Finite) {f : ι → ι' → α}\n    (hf : ∀ i ∈ s, Antitone (f i)) : ⨆ j, ⨅ i ∈ s, f i j = ⨅ i ∈ s, ⨆ j, f i j :=\n  @Finite.iSup_biInf_of_monotone ι ι'ᵒᵈ α _ _ _ _ _ hs _ fun i hi => (hf i hi).dual_left\n\n"}
{"name":"Set.Finite.iInf_biSup_of_monotone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝³ : Preorder ι'\ninst✝² : Nonempty ι'\ninst✝¹ : IsDirected ι' (Function.swap fun x1 x2 => LE.le x1 x2)\ninst✝ : Order.Coframe α\ns : Set ι\nhs : s.Finite\nf : ι → ι' → α\nhf : ∀ (i : ι), Membership.mem s i → Monotone (f i)\n⊢ Eq (iInf fun j => iSup fun i => iSup fun h => f i j) (iSup fun i => iSup fun h => iInf fun j => f i j)","decl":"theorem Finite.iInf_biSup_of_monotone {ι ι' α : Type*} [Preorder ι'] [Nonempty ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Order.Coframe α] {s : Set ι} (hs : s.Finite) {f : ι → ι' → α}\n    (hf : ∀ i ∈ s, Monotone (f i)) : ⨅ j, ⨆ i ∈ s, f i j = ⨆ i ∈ s, ⨅ j, f i j :=\n  hs.iSup_biInf_of_antitone (α := αᵒᵈ) fun i hi => (hf i hi).dual_right\n\n"}
{"name":"Set.Finite.iInf_biSup_of_antitone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝³ : Preorder ι'\ninst✝² : Nonempty ι'\ninst✝¹ : IsDirected ι' fun x1 x2 => LE.le x1 x2\ninst✝ : Order.Coframe α\ns : Set ι\nhs : s.Finite\nf : ι → ι' → α\nhf : ∀ (i : ι), Membership.mem s i → Antitone (f i)\n⊢ Eq (iInf fun j => iSup fun i => iSup fun h => f i j) (iSup fun i => iSup fun h => iInf fun j => f i j)","decl":"theorem Finite.iInf_biSup_of_antitone {ι ι' α : Type*} [Preorder ι'] [Nonempty ι']\n    [IsDirected ι' (· ≤ ·)] [Order.Coframe α] {s : Set ι} (hs : s.Finite) {f : ι → ι' → α}\n    (hf : ∀ i ∈ s, Antitone (f i)) : ⨅ j, ⨆ i ∈ s, f i j = ⨆ i ∈ s, ⨅ j, f i j :=\n  hs.iSup_biInf_of_monotone (α := αᵒᵈ) fun i hi => (hf i hi).dual_right\n\n"}
{"name":"Set.iSup_iInf_of_monotone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝⁴ : Finite ι\ninst✝³ : Preorder ι'\ninst✝² : Nonempty ι'\ninst✝¹ : IsDirected ι' fun x1 x2 => LE.le x1 x2\ninst✝ : Order.Frame α\nf : ι → ι' → α\nhf : ∀ (i : ι), Monotone (f i)\n⊢ Eq (iSup fun j => iInf fun i => f i j) (iInf fun i => iSup fun j => f i j)","decl":"theorem iSup_iInf_of_monotone {ι ι' α : Type*} [Finite ι] [Preorder ι'] [Nonempty ι']\n    [IsDirected ι' (· ≤ ·)] [Order.Frame α] {f : ι → ι' → α} (hf : ∀ i, Monotone (f i)) :\n    ⨆ j, ⨅ i, f i j = ⨅ i, ⨆ j, f i j := by\n  simpa only [iInf_univ] using finite_univ.iSup_biInf_of_monotone fun i _ => hf i\n\n"}
{"name":"Set.iSup_iInf_of_antitone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝⁴ : Finite ι\ninst✝³ : Preorder ι'\ninst✝² : Nonempty ι'\ninst✝¹ : IsDirected ι' (Function.swap fun x1 x2 => LE.le x1 x2)\ninst✝ : Order.Frame α\nf : ι → ι' → α\nhf : ∀ (i : ι), Antitone (f i)\n⊢ Eq (iSup fun j => iInf fun i => f i j) (iInf fun i => iSup fun j => f i j)","decl":"theorem iSup_iInf_of_antitone {ι ι' α : Type*} [Finite ι] [Preorder ι'] [Nonempty ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Order.Frame α] {f : ι → ι' → α} (hf : ∀ i, Antitone (f i)) :\n    ⨆ j, ⨅ i, f i j = ⨅ i, ⨆ j, f i j :=\n  @iSup_iInf_of_monotone ι ι'ᵒᵈ α _ _ _ _ _ _ fun i => (hf i).dual_left\n\n"}
{"name":"Set.iInf_iSup_of_monotone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝⁴ : Finite ι\ninst✝³ : Preorder ι'\ninst✝² : Nonempty ι'\ninst✝¹ : IsDirected ι' (Function.swap fun x1 x2 => LE.le x1 x2)\ninst✝ : Order.Coframe α\nf : ι → ι' → α\nhf : ∀ (i : ι), Monotone (f i)\n⊢ Eq (iInf fun j => iSup fun i => f i j) (iSup fun i => iInf fun j => f i j)","decl":"theorem iInf_iSup_of_monotone {ι ι' α : Type*} [Finite ι] [Preorder ι'] [Nonempty ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Order.Coframe α] {f : ι → ι' → α} (hf : ∀ i, Monotone (f i)) :\n    ⨅ j, ⨆ i, f i j = ⨆ i, ⨅ j, f i j :=\n  iSup_iInf_of_antitone (α := αᵒᵈ) fun i => (hf i).dual_right\n\n"}
{"name":"Set.iInf_iSup_of_antitone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝⁴ : Finite ι\ninst✝³ : Preorder ι'\ninst✝² : Nonempty ι'\ninst✝¹ : IsDirected ι' fun x1 x2 => LE.le x1 x2\ninst✝ : Order.Coframe α\nf : ι → ι' → α\nhf : ∀ (i : ι), Antitone (f i)\n⊢ Eq (iInf fun j => iSup fun i => f i j) (iSup fun i => iInf fun j => f i j)","decl":"theorem iInf_iSup_of_antitone {ι ι' α : Type*} [Finite ι] [Preorder ι'] [Nonempty ι']\n    [IsDirected ι' (· ≤ ·)] [Order.Coframe α] {f : ι → ι' → α} (hf : ∀ i, Antitone (f i)) :\n    ⨅ j, ⨆ i, f i j = ⨆ i, ⨅ j, f i j :=\n  iSup_iInf_of_monotone (α := αᵒᵈ) fun i => (hf i).dual_right\n\n"}
{"name":"Set.iUnion_iInter_of_monotone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝³ : Finite ι\ninst✝² : Preorder ι'\ninst✝¹ : IsDirected ι' fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty ι'\ns : ι → ι' → Set α\nhs : ∀ (i : ι), Monotone (s i)\n⊢ Eq (Set.iUnion fun j => Set.iInter fun i => s i j) (Set.iInter fun i => Set.iUnion fun j => s i j)","decl":"/-- An increasing union distributes over finite intersection. -/\ntheorem iUnion_iInter_of_monotone {ι ι' α : Type*} [Finite ι] [Preorder ι'] [IsDirected ι' (· ≤ ·)]\n    [Nonempty ι'] {s : ι → ι' → Set α} (hs : ∀ i, Monotone (s i)) :\n    ⋃ j : ι', ⋂ i : ι, s i j = ⋂ i : ι, ⋃ j : ι', s i j :=\n  iSup_iInf_of_monotone hs\n\n"}
{"name":"Set.iUnion_iInter_of_antitone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝³ : Finite ι\ninst✝² : Preorder ι'\ninst✝¹ : IsDirected ι' (Function.swap fun x1 x2 => LE.le x1 x2)\ninst✝ : Nonempty ι'\ns : ι → ι' → Set α\nhs : ∀ (i : ι), Antitone (s i)\n⊢ Eq (Set.iUnion fun j => Set.iInter fun i => s i j) (Set.iInter fun i => Set.iUnion fun j => s i j)","decl":"/-- A decreasing union distributes over finite intersection. -/\ntheorem iUnion_iInter_of_antitone {ι ι' α : Type*} [Finite ι] [Preorder ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Nonempty ι'] {s : ι → ι' → Set α} (hs : ∀ i, Antitone (s i)) :\n    ⋃ j : ι', ⋂ i : ι, s i j = ⋂ i : ι, ⋃ j : ι', s i j :=\n  iSup_iInf_of_antitone hs\n\n"}
{"name":"Set.iInter_iUnion_of_monotone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝³ : Finite ι\ninst✝² : Preorder ι'\ninst✝¹ : IsDirected ι' (Function.swap fun x1 x2 => LE.le x1 x2)\ninst✝ : Nonempty ι'\ns : ι → ι' → Set α\nhs : ∀ (i : ι), Monotone (s i)\n⊢ Eq (Set.iInter fun j => Set.iUnion fun i => s i j) (Set.iUnion fun i => Set.iInter fun j => s i j)","decl":"/-- An increasing intersection distributes over finite union. -/\ntheorem iInter_iUnion_of_monotone {ι ι' α : Type*} [Finite ι] [Preorder ι']\n    [IsDirected ι' (swap (· ≤ ·))] [Nonempty ι'] {s : ι → ι' → Set α} (hs : ∀ i, Monotone (s i)) :\n    ⋂ j : ι', ⋃ i : ι, s i j = ⋃ i : ι, ⋂ j : ι', s i j :=\n  iInf_iSup_of_monotone hs\n\n"}
{"name":"Set.iInter_iUnion_of_antitone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : Type u_3\ninst✝³ : Finite ι\ninst✝² : Preorder ι'\ninst✝¹ : IsDirected ι' fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty ι'\ns : ι → ι' → Set α\nhs : ∀ (i : ι), Antitone (s i)\n⊢ Eq (Set.iInter fun j => Set.iUnion fun i => s i j) (Set.iUnion fun i => Set.iInter fun j => s i j)","decl":"/-- A decreasing intersection distributes over finite union. -/\ntheorem iInter_iUnion_of_antitone {ι ι' α : Type*} [Finite ι] [Preorder ι'] [IsDirected ι' (· ≤ ·)]\n    [Nonempty ι'] {s : ι → ι' → Set α} (hs : ∀ i, Antitone (s i)) :\n    ⋂ j : ι', ⋃ i : ι, s i j = ⋃ i : ι, ⋂ j : ι', s i j :=\n  iInf_iSup_of_antitone hs\n\n"}
{"name":"Set.iUnion_pi_of_monotone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\ninst✝¹ : LinearOrder ι'\ninst✝ : Nonempty ι'\nα : ι → Type u_3\nI : Set ι\ns : (i : ι) → ι' → Set (α i)\nhI : I.Finite\nhs : ∀ (i : ι), Membership.mem I i → Monotone (s i)\n⊢ Eq (Set.iUnion fun j => I.pi fun i => s i j) (I.pi fun i => Set.iUnion fun j => s i j)","decl":"theorem iUnion_pi_of_monotone {ι ι' : Type*} [LinearOrder ι'] [Nonempty ι'] {α : ι → Type*}\n    {I : Set ι} {s : ∀ i, ι' → Set (α i)} (hI : I.Finite) (hs : ∀ i ∈ I, Monotone (s i)) :\n    ⋃ j : ι', I.pi (fun i => s i j) = I.pi fun i => ⋃ j, s i j := by\n  simp only [pi_def, biInter_eq_iInter, preimage_iUnion]\n  haveI := hI.fintype.finite\n  refine iUnion_iInter_of_monotone (ι' := ι') (fun (i : I) j₁ j₂ h => ?_)\n  exact preimage_mono <| hs i i.2 h\n\n"}
{"name":"Set.iUnion_univ_pi_of_monotone","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"ι : Type u_1\nι' : Type u_2\ninst✝² : LinearOrder ι'\ninst✝¹ : Nonempty ι'\ninst✝ : Finite ι\nα : ι → Type u_3\ns : (i : ι) → ι' → Set (α i)\nhs : ∀ (i : ι), Monotone (s i)\n⊢ Eq (Set.iUnion fun j => Set.univ.pi fun i => s i j) (Set.univ.pi fun i => Set.iUnion fun j => s i j)","decl":"theorem iUnion_univ_pi_of_monotone {ι ι' : Type*} [LinearOrder ι'] [Nonempty ι'] [Finite ι]\n    {α : ι → Type*} {s : ∀ i, ι' → Set (α i)} (hs : ∀ i, Monotone (s i)) :\n    ⋃ j : ι', pi univ (fun i => s i j) = pi univ fun i => ⋃ j, s i j :=\n  iUnion_pi_of_monotone finite_univ fun i _ => hs i\n\n"}
{"name":"Set.Finite.bddAbove","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty α\ns : Set α\nhs : s.Finite\n⊢ BddAbove s","decl":"/-- A finite set is bounded above. -/\nprotected theorem Finite.bddAbove (hs : s.Finite) : BddAbove s :=\n  Finite.induction_on _ hs bddAbove_empty fun _ _ h => h.insert _\n\n"}
{"name":"Set.Finite.bddAbove_biUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty α\nI : Set β\nS : β → Set α\nH : I.Finite\n⊢ Iff (BddAbove (Set.iUnion fun i => Set.iUnion fun h => S i)) (∀ (i : β), Membership.mem I i → BddAbove (S i))","decl":"/-- A finite union of sets which are all bounded above is still bounded above. -/\ntheorem Finite.bddAbove_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :\n    BddAbove (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddAbove (S i) :=\n  Finite.induction_on _ H (by simp only [biUnion_empty, bddAbove_empty, forall_mem_empty])\n    fun _ _ hs => by simp only [biUnion_insert, forall_mem_insert, bddAbove_union, hs]\n\n"}
{"name":"Set.infinite_of_not_bddAbove","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty α\ns : Set α\na✝ : Not (BddAbove s)\n⊢ s.Infinite","decl":"theorem infinite_of_not_bddAbove : ¬BddAbove s → s.Infinite :=\n  mt Finite.bddAbove\n\n"}
{"name":"Set.Finite.bddBelow","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => GE.ge x1 x2\ninst✝ : Nonempty α\ns : Set α\nhs : s.Finite\n⊢ BddBelow s","decl":"/-- A finite set is bounded below. -/\nprotected theorem Finite.bddBelow (hs : s.Finite) : BddBelow s :=\n  Finite.bddAbove (α := αᵒᵈ) hs\n\n"}
{"name":"Set.Finite.bddBelow_biUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => GE.ge x1 x2\ninst✝ : Nonempty α\nI : Set β\nS : β → Set α\nH : I.Finite\n⊢ Iff (BddBelow (Set.iUnion fun i => Set.iUnion fun h => S i)) (∀ (i : β), Membership.mem I i → BddBelow (S i))","decl":"/-- A finite union of sets which are all bounded below is still bounded below. -/\ntheorem Finite.bddBelow_biUnion {I : Set β} {S : β → Set α} (H : I.Finite) :\n    BddBelow (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddBelow (S i) :=\n  Finite.bddAbove_biUnion (α := αᵒᵈ) H\n\n"}
{"name":"Set.infinite_of_not_bddBelow","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ninst✝² : Preorder α\ninst✝¹ : IsDirected α fun x1 x2 => GE.ge x1 x2\ninst✝ : Nonempty α\ns : Set α\na✝ : Not (BddBelow s)\n⊢ s.Infinite","decl":"theorem infinite_of_not_bddBelow : ¬BddBelow s → s.Infinite := mt Finite.bddBelow\n\n"}
{"name":"Finset.bddAbove","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ninst✝¹ : SemilatticeSup α\ninst✝ : Nonempty α\ns : Finset α\n⊢ BddAbove ↑s","decl":"/-- A finset is bounded above. -/\nprotected theorem bddAbove [SemilatticeSup α] [Nonempty α] (s : Finset α) : BddAbove (↑s : Set α) :=\n  s.finite_toSet.bddAbove\n\n"}
{"name":"Finset.bddBelow","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ninst✝¹ : SemilatticeInf α\ninst✝ : Nonempty α\ns : Finset α\n⊢ BddBelow ↑s","decl":"/-- A finset is bounded below. -/\nprotected theorem bddBelow [SemilatticeInf α] [Nonempty α] (s : Finset α) : BddBelow (↑s : Set α) :=\n  s.finite_toSet.bddBelow\n\n"}
{"name":"Set.finite_diff_iUnion_Ioo","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\ns : Set α\n⊢ (SDiff.sdiff s (Set.iUnion fun x => Set.iUnion fun h => Set.iUnion fun y => Set.iUnion fun h => Set.Ioo x y)).Finite","decl":"lemma Set.finite_diff_iUnion_Ioo (s : Set α) : (s \\ ⋃ (x ∈ s) (y ∈ s), Ioo x y).Finite :=\n  Set.finite_of_forall_not_lt_lt fun _x hx _y hy _z hz hxy hyz => hy.2 <| mem_iUnion₂_of_mem hx.1 <|\n    mem_iUnion₂_of_mem hz.1 ⟨hxy, hyz⟩\n\n"}
{"name":"Set.finite_diff_iUnion_Ioo'","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u\ninst✝ : LinearOrder α\ns : Set α\n⊢ (SDiff.sdiff s (Set.iUnion fun x => Set.Ioo ↑x.1 ↑x.2)).Finite","decl":"lemma Set.finite_diff_iUnion_Ioo' (s : Set α) : (s \\ ⋃ x : s × s, Ioo x.1 x.2).Finite := by\n  simpa only [iUnion, iSup_prod, iSup_subtype] using s.finite_diff_iUnion_Ioo\n\n"}
{"name":"DirectedOn.exists_mem_subset_of_finset_subset_biUnion","module":"Mathlib.Data.Set.Finite.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → Set α\nc : Set ι\nhn : c.Nonempty\nhc : DirectedOn (fun i j => HasSubset.Subset (f i) (f j)) c\ns : Finset α\nhs : HasSubset.Subset (↑s) (Set.iUnion fun i => Set.iUnion fun h => f i)\n⊢ Exists fun i => And (Membership.mem c i) (HasSubset.Subset (↑s) (f i))","decl":"theorem DirectedOn.exists_mem_subset_of_finset_subset_biUnion {α ι : Type*} {f : ι → Set α}\n    {c : Set ι} (hn : c.Nonempty) (hc : DirectedOn (fun i j => f i ⊆ f j) c) {s : Finset α}\n    (hs : (s : Set α) ⊆ ⋃ i ∈ c, f i) : ∃ i ∈ c, (s : Set α) ⊆ f i := by\n  rw [Set.biUnion_eq_iUnion] at hs\n  haveI := hn.coe_sort\n  simpa using (directed_comp.2 hc.directed_val).exists_mem_subset_of_finset_subset_biUnion hs\n\n"}
