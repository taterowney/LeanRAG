{"name":"DirectSum.lie_module_bracket_apply","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"ι : Type v\nL : Type w₁\nM : ι → Type w\ninst✝² : LieRing L\ninst✝¹ : (i : ι) → AddCommGroup (M i)\ninst✝ : (i : ι) → LieRingModule L (M i)\nx : L\nm : DirectSum ι fun i => M i\ni : ι\n⊢ Eq ((Bracket.bracket x m) i) (Bracket.bracket x (m i))","decl":"@[simp]\ntheorem lie_module_bracket_apply (x : L) (m : ⨁ i, M i) (i : ι) : ⁅x, m⁆ i = ⁅x, m i⁆ :=\n  mapRange_apply _ _ m i\n\n"}
{"name":"DirectSum.instLieModule","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"R : Type u\nι : Type v\ninst✝⁵ : CommRing R\nL : Type w₁\nM : ι → Type w\ninst✝⁴ : LieRing L\ninst✝³ : LieAlgebra R L\ninst✝² : (i : ι) → AddCommGroup (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : (i : ι) → LieRingModule L (M i)\n⊢ LieModule R L (DirectSum ι fun i => M i)","decl":"instance : LieModule R L (⨁ i, M i) where\n  smul_lie t x m := by\n    ext\n    simp only [smul_lie, lie_module_bracket_apply, smul_apply]\n  lie_smul t x m := by\n    ext\n    simp only [lie_smul, lie_module_bracket_apply, smul_apply]\n\n"}
{"name":"DirectSum.bracket_apply","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"ι : Type v\nL : ι → Type w\ninst✝ : (i : ι) → LieRing (L i)\nx y : DirectSum ι fun i => L i\ni : ι\n⊢ Eq ((Bracket.bracket x y) i) (Bracket.bracket (x i) (y i))","decl":"@[simp]\ntheorem bracket_apply (x y : ⨁ i, L i) (i : ι) : ⁅x, y⁆ i = ⁅x i, y i⁆ :=\n  zipWith_apply _ _ x y i\n\n"}
{"name":"DirectSum.lie_of_same","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"ι : Type v\nL : ι → Type w\ninst✝¹ : (i : ι) → LieRing (L i)\ninst✝ : DecidableEq ι\ni : ι\nx y : L i\n⊢ Eq (Bracket.bracket ((DirectSum.of L i) x) ((DirectSum.of L i) y)) ((DirectSum.of L i) (Bracket.bracket x y))","decl":"theorem lie_of_same [DecidableEq ι] {i : ι} (x y : L i) :\n    ⁅of L i x, of L i y⁆ = of L i ⁅x, y⁆ :=\n  DFinsupp.zipWith_single_single _ _ _ _\n\n"}
{"name":"DirectSum.lie_of_of_ne","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"ι : Type v\nL : ι → Type w\ninst✝¹ : (i : ι) → LieRing (L i)\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\nx : L i\ny : L j\n⊢ Eq (Bracket.bracket ((DirectSum.of L i) x) ((DirectSum.of L j) y)) 0","decl":"theorem lie_of_of_ne [DecidableEq ι] {i j : ι} (hij : i ≠ j) (x : L i) (y : L j) :\n    ⁅of L i x, of L j y⁆ = 0 := by\n  ext k\n  rw [bracket_apply]\n  obtain rfl | hik := Decidable.eq_or_ne i k\n  · rw [of_eq_of_ne _ _ _ hij.symm, lie_zero, zero_apply]\n  · rw [of_eq_of_ne _ _ _ hik, zero_lie, zero_apply]\n\n"}
{"name":"DirectSum.lie_of","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"ι : Type v\nL : ι → Type w\ninst✝¹ : (i : ι) → LieRing (L i)\ninst✝ : DecidableEq ι\ni j : ι\nx : L i\ny : L j\n⊢ Eq (Bracket.bracket ((DirectSum.of L i) x) ((DirectSum.of L j) y)) (dite (Eq i j) (fun hij => (DirectSum.of L i) (Bracket.bracket x (Eq.recOn ⋯ y))) fun hij => 0)","decl":"@[simp]\ntheorem lie_of [DecidableEq ι] {i j : ι} (x : L i) (y : L j) :\n    ⁅of L i x, of L j y⁆ = if hij : i = j then of L i ⁅x, hij.symm.recOn y⁆ else 0 := by\n  obtain rfl | hij := Decidable.eq_or_ne i j\n  · simp only [lie_of_same L x y, dif_pos]\n  · simp only [lie_of_of_ne L hij x y, hij, dif_neg, dite_false]\n\n"}
{"name":"DirectSum.lieAlgebraOf_apply","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"R : Type u\nι : Type v\ninst✝³ : CommRing R\nL : ι → Type w\ninst✝² : (i : ι) → LieRing (L i)\ninst✝¹ : (i : ι) → LieAlgebra R (L i)\ninst✝ : DecidableEq ι\nj : ι\na : L j\n⊢ Eq ((DirectSum.lieAlgebraOf R ι L j) a) ((DirectSum.of L j) a)","decl":"/-- The inclusion of each component into the direct sum as morphism of Lie algebras. -/\n@[simps]\ndef lieAlgebraOf [DecidableEq ι] (j : ι) : L j →ₗ⁅R⁆ ⨁ i, L i :=\n  { lof R ι L j with\n    toFun := of L j\n    map_lie' := fun {x y} => (lie_of_same L x y).symm }\n\n"}
{"name":"DirectSum.lieAlgebraComponent_apply","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"R : Type u\nι : Type v\ninst✝² : CommRing R\nL : ι → Type w\ninst✝¹ : (i : ι) → LieRing (L i)\ninst✝ : (i : ι) → LieAlgebra R (L i)\nj : ι\na : DirectSum ι fun i => L i\n⊢ Eq ((DirectSum.lieAlgebraComponent R ι L j) a) ((DirectSum.component R ι L j) a)","decl":"/-- The projection map onto one component, as a morphism of Lie algebras. -/\n@[simps]\ndef lieAlgebraComponent (j : ι) : (⨁ i, L i) →ₗ⁅R⁆ L j :=\n  { component R ι L j with\n    toFun := component R ι L j\n    map_lie' := fun {x y} => by simp [component, lapply] }\n\n-- Note(kmill): `ext` cannot generate an iff theorem here since `x` and `y` do not determine `R`.\n"}
{"name":"DirectSum.lieAlgebra_ext","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"R : Type u\nι : Type v\ninst✝² : CommRing R\nL : ι → Type w\ninst✝¹ : (i : ι) → LieRing (L i)\ninst✝ : (i : ι) → LieAlgebra R (L i)\nx y : DirectSum ι fun i => L i\nh : ∀ (i : ι), Eq ((DirectSum.lieAlgebraComponent R ι L i) x) ((DirectSum.lieAlgebraComponent R ι L i) y)\n⊢ Eq x y","decl":"@[ext (iff := false)]\ntheorem lieAlgebra_ext {x y : ⨁ i, L i}\n    (h : ∀ i, lieAlgebraComponent R ι L i x = lieAlgebraComponent R ι L i y) : x = y :=\n  DFinsupp.ext h\n\n"}
{"name":"DirectSum.toLieAlgebra_apply","module":"Mathlib.Algebra.Lie.DirectSum","initialProofState":"R : Type u\nι : Type v\ninst✝⁵ : CommRing R\nL : ι → Type w\ninst✝⁴ : (i : ι) → LieRing (L i)\ninst✝³ : (i : ι) → LieAlgebra R (L i)\ninst✝² : DecidableEq ι\nL' : Type w₁\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : (i : ι) → LieHom R (L i) L'\nhf : Pairwise fun i j => ∀ (x : L i) (y : L j), Eq (Bracket.bracket ((f i) x) ((f j) y)) 0\na : DirectSum ι fun i => L i\n⊢ Eq ((DirectSum.toLieAlgebra L' f hf) a) ((DirectSum.toModule R ι L' fun i => ↑(f i)) a)","decl":"/-- Given a family of Lie algebras `L i`, together with a family of morphisms of Lie algebras\n`f i : L i →ₗ⁅R⁆ L'` into a fixed Lie algebra `L'`, we have a natural linear map:\n`(⨁ i, L i) →ₗ[R] L'`. If in addition `⁅f i x, f j y⁆ = 0` for any `x ∈ L i` and `y ∈ L j` (`i ≠ j`)\nthen this map is a morphism of Lie algebras. -/\n@[simps]\ndef toLieAlgebra [DecidableEq ι] (L' : Type w₁) [LieRing L'] [LieAlgebra R L']\n    (f : ∀ i, L i →ₗ⁅R⁆ L') (hf : Pairwise fun i j => ∀ (x : L i) (y : L j), ⁅f i x, f j y⁆ = 0) :\n    (⨁ i, L i) →ₗ⁅R⁆ L' :=\n  { toModule R ι L' fun i => (f i : L i →ₗ[R] L') with\n    toFun := toModule R ι L' fun i => (f i : L i →ₗ[R] L')\n    map_lie' := fun {x y} => by\n      let f' i := (f i : L i →ₗ[R] L')\n      /- The goal is linear in `y`. We can use this to reduce to the case that `y` has only one\n        non-zero component. -/\n      suffices ∀ (i : ι) (y : L i),\n          toModule R ι L' f' ⁅x, of L i y⁆ =\n            ⁅toModule R ι L' f' x, toModule R ι L' f' (of L i y)⁆ by\n        simp only [← LieAlgebra.ad_apply R]\n        rw [← LinearMap.comp_apply, ← LinearMap.comp_apply]\n        congr; clear y; ext i y; exact this i y\n      -- Similarly, we can reduce to the case that `x` has only one non-zero component.\n      suffices ∀ (i j) (y : L i) (x : L j),\n          toModule R ι L' f' ⁅of L j x, of L i y⁆ =\n            ⁅toModule R ι L' f' (of L j x), toModule R ι L' f' (of L i y)⁆ by\n        intro i y\n        rw [← lie_skew x, ← lie_skew (toModule R ι L' f' x)]\n        simp only [LinearMap.map_neg, neg_inj, ← LieAlgebra.ad_apply R]\n        rw [← LinearMap.comp_apply, ← LinearMap.comp_apply]\n        congr; clear x; ext j x; exact this j i x y\n      intro i j y x\n      simp only [f', coe_toModule_eq_coe_toAddMonoid, toAddMonoid_of]\n      -- And finish with trivial case analysis.\n      obtain rfl | hij := Decidable.eq_or_ne i j\n      · simp_rw [lie_of_same, toAddMonoid_of, LinearMap.toAddMonoidHom_coe, LieHom.coe_toLinearMap,\n          LieHom.map_lie]\n      · simp_rw [lie_of_of_ne _ hij.symm, map_zero,  LinearMap.toAddMonoidHom_coe,\n          LieHom.coe_toLinearMap, hf hij.symm x y] }\n\n"}
