{"name":"AlgebraicGeometry.Scheme.Pullback.t_fst_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t ğ’° f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) h)","decl":"@[simp, reassoc]\ntheorem t_fst_fst (i j : ğ’°.J) : t ğ’° f g i j â‰« pullback.fst _ _ â‰« pullback.fst _ _ =\n    pullback.snd _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_fst_assoc, pullbackAssoc_hom_snd_fst,\n    pullback.lift_fst_assoc, pullbackSymmetry_hom_comp_snd, pullbackAssoc_inv_fst_fst,\n    pullbackSymmetry_hom_comp_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t ğ’° f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j))","decl":"@[simp, reassoc]\ntheorem t_fst_fst (i j : ğ’°.J) : t ğ’° f g i j â‰« pullback.fst _ _ â‰« pullback.fst _ _ =\n    pullback.snd _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_fst_assoc, pullbackAssoc_hom_snd_fst,\n    pullback.lift_fst_assoc, pullbackSymmetry_hom_comp_snd, pullbackAssoc_inv_fst_fst,\n    pullbackSymmetry_hom_comp_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t ğ’° f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g))","decl":"@[simp, reassoc]\ntheorem t_fst_snd (i j : ğ’°.J) :\n    t ğ’° f g i j â‰« pullback.fst _ _ â‰« pullback.snd _ _ = pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_fst_assoc, pullbackAssoc_hom_snd_snd,\n    pullback.lift_snd, Category.comp_id, pullbackAssoc_inv_snd, pullbackSymmetry_hom_comp_snd_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t ğ’° f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) h))","decl":"@[simp, reassoc]\ntheorem t_fst_snd (i j : ğ’°.J) :\n    t ğ’° f g i j â‰« pullback.fst _ _ â‰« pullback.snd _ _ = pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_fst_assoc, pullbackAssoc_hom_snd_snd,\n    pullback.lift_snd, Category.comp_id, pullbackAssoc_inv_snd, pullbackSymmetry_hom_comp_snd_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t ğ’° f g i j) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g))","decl":"@[simp, reassoc]\ntheorem t_snd (i j : ğ’°.J) : t ğ’° f g i j â‰« pullback.snd _ _ =\n    pullback.fst _ _ â‰« pullback.fst _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_snd, pullbackAssoc_hom_fst,\n    pullback.lift_fst_assoc, pullbackSymmetry_hom_comp_fst, pullbackAssoc_inv_fst_snd,\n    pullbackSymmetry_hom_comp_snd_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t ğ’° f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) h))","decl":"@[simp, reassoc]\ntheorem t_snd (i j : ğ’°.J) : t ğ’° f g i j â‰« pullback.snd _ _ =\n    pullback.fst _ _ â‰« pullback.fst _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_snd, pullbackAssoc_hom_fst,\n    pullback.lift_fst_assoc, pullbackSymmetry_hom_comp_fst, pullbackAssoc_inv_fst_snd,\n    pullbackSymmetry_hom_comp_snd_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_id","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nâŠ¢ Eq (AlgebraicGeometry.Scheme.Pullback.t ğ’° f g i i) (CategoryTheory.CategoryStruct.id (AlgebraicGeometry.Scheme.Pullback.v ğ’° f g i i))","decl":"theorem t_id (i : ğ’°.J) : t ğ’° f g i i = ğŸ™ _ := by\n  apply pullback.hom_ext <;> rw [Category.id_comp]\n  Â· apply pullback.hom_ext\n    Â· rw [â† cancel_mono (ğ’°.map i)]; simp only [pullback.condition, Category.assoc, t_fst_fst]\n    Â· simp only [Category.assoc, t_fst_snd]\n  Â· rw [â† cancel_mono (ğ’°.map i)]; simp only [pullback.condition, t_snd, Category.assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) h))","decl":"@[simp, reassoc]\ntheorem t'_fst_fst_fst (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map k)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)))","decl":"@[simp, reassoc]\ntheorem t'_fst_fst_fst (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))","decl":"@[simp, reassoc]\ntheorem t'_fst_fst_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ =\n      pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) h)))","decl":"@[simp, reassoc]\ntheorem t'_fst_fst_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ =\n      pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map k)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map k)))","decl":"@[simp, reassoc]\ntheorem t'_fst_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.fst _ _ â‰« pullback.snd _ _ =\n      pullback.snd _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_snd, pullback.lift_snd, Category.comp_id,\n    pullbackRightPullbackFstIso_hom_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj k) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map k)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map k)) h))","decl":"@[simp, reassoc]\ntheorem t'_fst_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.fst _ _ â‰« pullback.snd _ _ =\n      pullback.snd _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_snd, pullback.lift_snd, Category.comp_id,\n    pullbackRightPullbackFstIso_hom_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)))","decl":"@[simp, reassoc]\ntheorem t'_snd_fst_fst (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.snd _ _ â‰« pullback.fst _ _ â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) h))","decl":"@[simp, reassoc]\ntheorem t'_snd_fst_fst (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.snd _ _ â‰« pullback.fst _ _ â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))","decl":"@[simp, reassoc]\ntheorem t'_snd_fst_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.snd _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ =\n      pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) h)))","decl":"@[simp, reassoc]\ntheorem t'_snd_fst_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.snd _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ =\n      pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) h)))","decl":"@[simp, reassoc]\ntheorem t'_snd_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.snd _ _ â‰« pullback.snd _ _ =\n      pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.fst _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j k) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g j i)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))","decl":"@[simp, reassoc]\ntheorem t'_snd_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« pullback.snd _ _ â‰« pullback.snd _ _ =\n      pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.fst _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_fst_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))","decl":"theorem cocycle_fst_fst_fst (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« t' ğ’° f g j k i â‰« t' ğ’° f g k i j â‰« pullback.fst _ _ â‰« pullback.fst _ _ â‰«\n      pullback.fst _ _ = pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.fst _ _ := by\n  simp only [t'_fst_fst_fst, t'_fst_snd, t'_snd_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_fst_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))","decl":"theorem cocycle_fst_fst_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« t' ğ’° f g j k i â‰« t' ğ’° f g k i j â‰« pullback.fst _ _ â‰« pullback.fst _ _ â‰«\n      pullback.snd _ _ = pullback.fst _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t'_fst_fst_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)))","decl":"theorem cocycle_fst_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« t' ğ’° f g j k i â‰« t' ğ’° f g k i j â‰« pullback.fst _ _ â‰« pullback.snd _ _ =\n      pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [t'_fst_snd, t'_snd_snd, t'_fst_fst_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_snd_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map k)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map k)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))","decl":"theorem cocycle_snd_fst_fst (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« t' ğ’° f g j k i â‰« t' ğ’° f g k i j â‰« pullback.snd _ _ â‰« pullback.fst _ _ â‰«\n      pullback.fst _ _ = pullback.snd _ _ â‰« pullback.fst _ _ â‰« pullback.fst _ _ := by\n  rw [â† cancel_mono (ğ’°.map i)]\n  simp only [pullback.condition_assoc, t'_snd_fst_fst, t'_fst_snd, t'_snd_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_snd_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)))","decl":"theorem cocycle_snd_fst_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« t' ğ’° f g j k i â‰« t' ğ’° f g k i j â‰« pullback.snd _ _ â‰« pullback.fst _ _ â‰«\n      pullback.snd _ _ = pullback.snd _ _ â‰« pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp only [pullback.condition_assoc, t'_snd_fst_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_snd_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map k)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map k)))","decl":"theorem cocycle_snd_snd (i j k : ğ’°.J) :\n    t' ğ’° f g i j k â‰« t' ğ’° f g j k i â‰« t' ğ’° f g k i j â‰« pullback.snd _ _ â‰« pullback.snd _ _ =\n      pullback.snd _ _ â‰« pullback.snd _ _ := by\n  simp only [t'_snd_snd, t'_fst_fst_fst, t'_fst_snd]\n\n-- `by tidy` should solve it, but it times out.\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g j k i) (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i j) (AlgebraicGeometry.Scheme.Pullback.fV ğ’° f g i k)))","decl":"theorem cocycle (i j k : ğ’°.J) : t' ğ’° f g i j k â‰« t' ğ’° f g j k i â‰« t' ğ’° f g k i j = ğŸ™ _ := by\n  apply pullback.hom_ext <;> rw [Category.id_comp]\n  Â· apply pullback.hom_ext\n    Â· apply pullback.hom_ext\n      Â· simp_rw [Category.assoc, cocycle_fst_fst_fst ğ’° f g i j k]\n      Â· simp_rw [Category.assoc, cocycle_fst_fst_snd ğ’° f g i j k]\n    Â· simp_rw [Category.assoc, cocycle_fst_snd ğ’° f g i j k]\n  Â· apply pullback.hom_ext\n    Â· apply pullback.hom_ext\n      Â· simp_rw [Category.assoc, cocycle_snd_fst_fst ğ’° f g i j k]\n      Â· simp_rw [Category.assoc, cocycle_snd_fst_snd ğ’° f g i j k]\n    Â· simp_rw [Category.assoc, cocycle_snd_snd ğ’° f g i j k]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_U","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).U i) (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)","decl":"/-- Given `Uáµ¢ Ã—[Z] Y`, this is the glued fibered product `X Ã—[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U i := pullback (ğ’°.map i â‰« f) g\n  V := fun âŸ¨i, jâŸ© => v ğ’° f g i j\n  -- `pâ»Â¹(Uáµ¢ âˆ© Uâ±¼)` where `p : Uáµ¢ Ã—[Z] Y âŸ¶ Uáµ¢ âŸ¶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t ğ’° f g i j\n  t_id i := t_id ğ’° f g i\n  t' i j k := t' ğ’° f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle ğ’° f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\nâŠ¢ Eq (AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).J ğ’°.J","decl":"/-- Given `Uáµ¢ Ã—[Z] Y`, this is the glued fibered product `X Ã—[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U i := pullback (ğ’°.map i â‰« f) g\n  V := fun âŸ¨i, jâŸ© => v ğ’° f g i j\n  -- `pâ»Â¹(Uáµ¢ âˆ© Uâ±¼)` where `p : Uáµ¢ Ã—[Z] Y âŸ¶ Uáµ¢ âŸ¶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t ğ’° f g i j\n  t_id i := t_id ğ’° f g i\n  t' i j k := t' ğ’° f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle ğ’° f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_t","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).t i j) (AlgebraicGeometry.Scheme.Pullback.t ğ’° f g i j)","decl":"/-- Given `Uáµ¢ Ã—[Z] Y`, this is the glued fibered product `X Ã—[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U i := pullback (ğ’°.map i â‰« f) g\n  V := fun âŸ¨i, jâŸ© => v ğ’° f g i j\n  -- `pâ»Â¹(Uáµ¢ âˆ© Uâ±¼)` where `p : Uáµ¢ Ã—[Z] Y âŸ¶ Uáµ¢ âŸ¶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t ğ’° f g i j\n  t_id i := t_id ğ’° f g i\n  t' i j k := t' ğ’° f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle ğ’° f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_V","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\nxâœ : Prod ğ’°.J ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).V xâœ) (AlgebraicGeometry.Scheme.Pullback.gluing.match_1 ğ’° (fun x => AlgebraicGeometry.Scheme) xâœ fun i j => AlgebraicGeometry.Scheme.Pullback.v ğ’° f g i j)","decl":"/-- Given `Uáµ¢ Ã—[Z] Y`, this is the glued fibered product `X Ã—[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U i := pullback (ğ’°.map i â‰« f) g\n  V := fun âŸ¨i, jâŸ© => v ğ’° f g i j\n  -- `pâ»Â¹(Uáµ¢ âˆ© Uâ±¼)` where `p : Uáµ¢ Ã—[Z] Y âŸ¶ Uáµ¢ âŸ¶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t ğ’° f g i j\n  t_id i := t_id ğ’° f g i\n  t' i j k := t' ğ’° f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle ğ’° f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_t'","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j k : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).t' i j k) (AlgebraicGeometry.Scheme.Pullback.t' ğ’° f g i j k)","decl":"/-- Given `Uáµ¢ Ã—[Z] Y`, this is the glued fibered product `X Ã—[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U i := pullback (ğ’°.map i â‰« f) g\n  V := fun âŸ¨i, jâŸ© => v ğ’° f g i j\n  -- `pâ»Â¹(Uáµ¢ âˆ© Uâ±¼)` where `p : Uáµ¢ Ã—[Z] Y âŸ¶ Uáµ¢ âŸ¶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t ğ’° f g i j\n  t_id i := t_id ğ’° f g i\n  t' i j k := t' ğ’° f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle ğ’° f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_f","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\nxâœÂ¹ xâœ : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).f xâœÂ¹ xâœ) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map xâœÂ¹) f) g) (ğ’°.map xâœÂ¹)) (ğ’°.map xâœ))","decl":"/-- Given `Uáµ¢ Ã—[Z] Y`, this is the glued fibered product `X Ã—[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := ğ’°.J\n  U i := pullback (ğ’°.map i â‰« f) g\n  V := fun âŸ¨i, jâŸ© => v ğ’° f g i j\n  -- `pâ»Â¹(Uáµ¢ âˆ© Uâ±¼)` where `p : Uáµ¢ Ã—[Z] Y âŸ¶ Uáµ¢ âŸ¶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t ğ’° f g i j\n  t_id i := t_id ğ’° f g i\n  t' i j k := t' ğ’° f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle ğ’° f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_Î¹","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\nj : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).Î¹ j) (CategoryTheory.Limits.Multicoequalizer.Ï€ (AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).diagram j)","decl":"@[simp]\nlemma gluing_Î¹ (j : ğ’°.J) :\n    (gluing ğ’° f g).Î¹ j = Multicoequalizer.Ï€ (gluing ğ’° f g).diagram j := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.p_comm","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) f) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.p2 ğ’° f g) g)","decl":"theorem p_comm : p1 ğ’° f g â‰« f = p2 ğ’° f g â‰« g := by\n  apply Multicoequalizer.hom_ext\n  simp [p1, p2, pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\ni j : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap ğ’° f g s i j) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° s.fst).map i) ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° s.fst).map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry s.fst (ğ’°.map i)).hom (CategoryTheory.Limits.pullback.map (ğ’°.map i) s.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g (CategoryTheory.CategoryStruct.id (ğ’°.obj i)) s.snd f â‹¯ â‹¯)))","decl":"@[reassoc]\ntheorem gluedLiftPullbackMap_fst (i j : ğ’°.J) :\n    gluedLiftPullbackMap ğ’° f g s i j â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰«\n        (pullbackSymmetry _ _).hom â‰«\n          pullback.map _ _ _ _ (ğŸ™ _) s.snd f (Category.id_comp _).symm s.condition := by\n  simp [gluedLiftPullbackMap]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\ni j : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap ğ’° f g s i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° s.fst).map i) ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° s.fst).map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry s.fst (ğ’°.map i)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map (ğ’°.map i) s.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g (CategoryTheory.CategoryStruct.id (ğ’°.obj i)) s.snd f â‹¯ â‹¯) h)))","decl":"@[reassoc]\ntheorem gluedLiftPullbackMap_fst (i j : ğ’°.J) :\n    gluedLiftPullbackMap ğ’° f g s i j â‰« pullback.fst _ _ =\n      pullback.fst _ _ â‰«\n        (pullbackSymmetry _ _).hom â‰«\n          pullback.map _ _ _ _ (ğŸ™ _) s.snd f (Category.id_comp _).symm s.condition := by\n  simp [gluedLiftPullbackMap]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\ni j : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap ğ’° f g s i j) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° s.fst).map i) ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° s.fst).map j)) (CategoryTheory.Limits.pullback.snd s.fst (ğ’°.map j)))","decl":"@[reassoc]\ntheorem gluedLiftPullbackMap_snd (i j : ğ’°.J) :\n    gluedLiftPullbackMap ğ’° f g s i j â‰« pullback.snd _ _ = pullback.snd _ _ â‰« pullback.snd _ _ := by\n  simp [gluedLiftPullbackMap]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\ni j : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap ğ’° f g s i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) (ğ’°.map i)) (ğ’°.map j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° s.fst).map i) ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° s.fst).map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd s.fst (ğ’°.map j)) h))","decl":"@[reassoc]\ntheorem gluedLiftPullbackMap_snd (i j : ğ’°.J) :\n    gluedLiftPullbackMap ğ’° f g s i j â‰« pullback.snd _ _ = pullback.snd _ _ â‰« pullback.snd _ _ := by\n  simp [gluedLiftPullbackMap]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLift_p1","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLift ğ’° f g s) (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g)) s.fst","decl":"theorem gluedLift_p1 : gluedLift ğ’° f g s â‰« p1 ğ’° f g = s.fst := by\n  rw [â† cancel_epi (ğ’°.pullbackCover s.fst).fromGlued]\n  apply Multicoequalizer.hom_ext\n  intro b\n  simp_rw [Cover.fromGlued, Multicoequalizer.Ï€_desc_assoc, gluedLift, â† Category.assoc]\n  simp_rw [(ğ’°.pullbackCover s.fst).Î¹_glueMorphisms]\n  simp [p1, pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLift_p2","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLift ğ’° f g s) (AlgebraicGeometry.Scheme.Pullback.p2 ğ’° f g)) s.snd","decl":"theorem gluedLift_p2 : gluedLift ğ’° f g s â‰« p2 ğ’° f g = s.snd := by\n  rw [â† cancel_epi (ğ’°.pullbackCover s.fst).fromGlued]\n  apply Multicoequalizer.hom_ext\n  intro b\n  simp_rw [Cover.fromGlued, Multicoequalizer.Ï€_desc_assoc, gluedLift, â† Category.assoc]\n  simp_rw [(ğ’°.pullbackCover s.fst).Î¹_glueMorphisms]\n  simp [p2, pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackFstÎ¹ToV_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackFstÎ¹ToV ğ’° f g i j) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).Î¹ j))","decl":"@[simp, reassoc]\ntheorem pullbackFstÎ¹ToV_fst (i j : ğ’°.J) :\n    pullbackFstÎ¹ToV ğ’° f g i j â‰« pullback.fst _ _ = pullback.snd _ _ := by\n  simp [pullbackFstÎ¹ToV, p1]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackFstÎ¹ToV_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackFstÎ¹ToV ğ’° f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).Î¹ j)) h)","decl":"@[simp, reassoc]\ntheorem pullbackFstÎ¹ToV_fst (i j : ğ’°.J) :\n    pullbackFstÎ¹ToV ğ’° f g i j â‰« pullback.fst _ _ = pullback.snd _ _ := by\n  simp [pullbackFstÎ¹ToV, p1]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackFstÎ¹ToV_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackFstÎ¹ToV ğ’° f g i j) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).Î¹ j)) (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)))","decl":"@[simp, reassoc]\ntheorem pullbackFstÎ¹ToV_snd (i j : ğ’°.J) :\n    pullbackFstÎ¹ToV ğ’° f g i j â‰« pullback.snd _ _ = pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp [pullbackFstÎ¹ToV, p1]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackFstÎ¹ToV_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni j : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackFstÎ¹ToV ğ’° f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map j) f) g) (ğ’°.map j)) (ğ’°.map i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).Î¹ j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) h))","decl":"@[simp, reassoc]\ntheorem pullbackFstÎ¹ToV_snd (i j : ğ’°.J) :\n    pullbackFstÎ¹ToV ğ’° f g i j â‰« pullback.snd _ _ = pullback.fst _ _ â‰« pullback.snd _ _ := by\n  simp [pullbackFstÎ¹ToV, p1]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.lift_comp_Î¹","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) (AlgebraicGeometry.Scheme.Pullback.p2 ğ’° f g)) â‹¯) ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).Î¹ i)) (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i))","decl":"/-- We show that the map `W Ã—[X] Uáµ¢ âŸ¶ Uáµ¢ Ã—[Z] Y âŸ¶ W` is the first projection, where the\nfirst map is given by the lift of `W Ã—[X] Uáµ¢ âŸ¶ Uáµ¢` and `W Ã—[X] Uáµ¢ âŸ¶ W âŸ¶ Y`.\n\nIt suffices to show that the two map agrees when restricted onto `Uâ±¼ Ã—[Z] Y`. In this case,\nboth maps factor through `V j i` via `pullback_fst_Î¹_to_V` -/\ntheorem lift_comp_Î¹ (i : ğ’°.J) :\n    pullback.lift (pullback.snd _ _) (pullback.fst _ _ â‰« p2 ğ’° f g)\n          (by rw [â† pullback.condition_assoc, Category.assoc, p_comm]) â‰«\n        (gluing ğ’° f g).Î¹ i =\n      (pullback.fst _ _ : pullback (p1 ğ’° f g) (ğ’°.map i) âŸ¶ _) := by\n  apply ((gluing ğ’° f g).openCover.pullbackCover (pullback.fst _ _)).hom_ext\n  intro j\n  dsimp only [Cover.pullbackCover]\n  trans pullbackFstÎ¹ToV ğ’° f g i j â‰« fV ğ’° f g j i â‰« (gluing ğ’° f g).Î¹ _\n  Â· rw [â† show _ = fV ğ’° f g j i â‰« _ from (gluing ğ’° f g).glue_condition j i]\n    simp_rw [â† Category.assoc]\n    congr 1\n    rw [gluing_f, gluing_t]\n    apply pullback.hom_ext <;> simp_rw [Category.assoc]\n    Â· simp_rw [t_fst_fst, pullback.lift_fst, pullbackFstÎ¹ToV_snd, GlueData.openCover_map]\n    Â· simp_rw [t_fst_snd, pullback.lift_snd, pullbackFstÎ¹ToV_fst_assoc, pullback.condition_assoc,\n        GlueData.openCover_map, p2]\n      simp\n  Â· rw [pullback.condition, â† Category.assoc]\n    simp_rw [pullbackFstÎ¹ToV_fst, GlueData.openCover_map]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).hom (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)) (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i))","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_fst (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).hom â‰« pullback.fst _ _ = pullback.snd _ _ := by\n  simp_rw [pullbackP1Iso, pullback.lift_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) h)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_fst (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).hom â‰« pullback.fst _ _ = pullback.snd _ _ := by\n  simp_rw [pullbackP1Iso, pullback.lift_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.p2 ğ’° f g) h))","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_snd (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).hom â‰« pullback.snd _ _ = pullback.fst _ _ â‰« p2 ğ’° f g := by\n  simp_rw [pullbackP1Iso, pullback.lift_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).hom (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) (AlgebraicGeometry.Scheme.Pullback.p2 ğ’° f g))","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_snd (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).hom â‰« pullback.snd _ _ = pullback.fst _ _ â‰« p2 ğ’° f g := by\n  simp_rw [pullbackP1Iso, pullback.lift_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).inv (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i))) ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).Î¹ i)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_inv_fst (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).inv â‰« pullback.fst _ _ = (gluing ğ’° f g).Î¹ i := by\n  simp_rw [pullbackP1Iso, pullback.lift_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).glued Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) h)) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).Î¹ i) h)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_inv_fst (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).inv â‰« pullback.fst _ _ = (gluing ğ’° f g).Î¹ i := by\n  simp_rw [pullbackP1Iso, pullback.lift_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).inv (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i))) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_inv_snd (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).inv â‰« pullback.snd _ _ = pullback.fst _ _ := by\n  simp_rw [pullbackP1Iso, pullback.lift_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (ğ’°.obj i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g) h)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_inv_snd (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).inv â‰« pullback.snd _ _ = pullback.fst _ _ := by\n  simp_rw [pullbackP1Iso, pullback.lift_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_Î¹_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Zâœ : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Zâœ\ng : Quiver.Hom Y Zâœ\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (CategoryTheory.Limits.multicoequalizer (AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).diagram) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.Ï€ (AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).diagram i) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i)) h)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_Î¹ (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).hom â‰« Multicoequalizer.Ï€ (gluing ğ’° f g).diagram i =\n    pullback.fst _ _ := by\n  rw [â† gluing_Î¹, â† pullbackP1Iso_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_Î¹","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\ni : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso ğ’° f g i).hom (CategoryTheory.Limits.Multicoequalizer.Ï€ (AlgebraicGeometry.Scheme.Pullback.gluing ğ’° f g).diagram i)) (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 ğ’° f g) (ğ’°.map i))","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_Î¹ (i : ğ’°.J) :\n    (pullbackP1Iso ğ’° f g i).hom â‰« Multicoequalizer.Ï€ (gluing ğ’° f g).diagram i =\n    pullback.fst _ _ := by\n  rw [â† gluing_Î¹, â† pullbackP1Iso_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.hasPullback_of_cover","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœ : âˆ€ (i : ğ’°.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g\nâŠ¢ CategoryTheory.Limits.HasPullback f g","decl":"include ğ’° in\ntheorem hasPullback_of_cover : HasPullback f g :=\n  âŸ¨âŸ¨âŸ¨_, gluedIsLimit ğ’° f gâŸ©âŸ©âŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.affine_hasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"A B C : CommRingCat\nf : Quiver.Hom (AlgebraicGeometry.Spec A) (AlgebraicGeometry.Spec C)\ng : Quiver.Hom (AlgebraicGeometry.Spec B) (AlgebraicGeometry.Spec C)\nâŠ¢ CategoryTheory.Limits.HasPullback f g","decl":"instance affine_hasPullback {A B C : CommRingCat}\n    (f : Spec A âŸ¶ Spec C)\n    (g : Spec B âŸ¶ Spec C) : HasPullback f g := by\n  rw [â† Scheme.Spec.map_preimage f, â† Scheme.Spec.map_preimage g]\n  exact âŸ¨âŸ¨âŸ¨_, isLimitOfHasPullbackOfPreservesLimit\n    Scheme.Spec (Scheme.Spec.preimage f) (Scheme.Spec.preimage g)âŸ©âŸ©âŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.affine_affine_hasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"B C : CommRingCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom X (AlgebraicGeometry.Spec C)\ng : Quiver.Hom (AlgebraicGeometry.Spec B) (AlgebraicGeometry.Spec C)\nâŠ¢ CategoryTheory.Limits.HasPullback f g","decl":"theorem affine_affine_hasPullback {B C : CommRingCat} {X : Scheme}\n    (f : X âŸ¶ Spec C) (g : Spec B âŸ¶ Spec C) :\n    HasPullback f g :=\n  hasPullback_of_cover X.affineCover f g\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.base_affine_hasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"C : CommRingCat\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X (AlgebraicGeometry.Spec C)\ng : Quiver.Hom Y (AlgebraicGeometry.Spec C)\nâŠ¢ CategoryTheory.Limits.HasPullback f g","decl":"instance base_affine_hasPullback {C : CommRingCat} {X Y : Scheme} (f : X âŸ¶ Spec C)\n    (g : Y âŸ¶ Spec C) : HasPullback f g :=\n  @hasPullback_symmetry _ _ _ _ _ _ _\n    (@hasPullback_of_cover _ _ _ Y.affineCover g f fun _ =>\n      @hasPullback_symmetry _ _ _ _ _ _ _ <| affine_affine_hasPullback _ _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.left_affine_comp_pullback_hasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : Z.affineCover.J\nâŠ¢ CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover Z.affineCover f).map i) f) g","decl":"instance left_affine_comp_pullback_hasPullback {X Y Z : Scheme} (f : X âŸ¶ Z) (g : Y âŸ¶ Z)\n    (i : Z.affineCover.J) : HasPullback ((Z.affineCover.pullbackCover f).map i â‰« f) g := by\n  simp only [Cover.pullbackCover_obj, Cover.pullbackCover_map, pullback.condition]\n  exact hasPullback_assoc_symm f (Z.affineCover.map i) (Z.affineCover.map i) g\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.instHasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nâŠ¢ CategoryTheory.Limits.HasPullback f g","decl":"instance {X Y Z : Scheme} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : HasPullback f g :=\n  hasPullback_of_cover (Z.affineCover.pullbackCover f) f g\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.instHasPullbacks","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"âŠ¢ CategoryTheory.Limits.HasPullbacks AlgebraicGeometry.Scheme","decl":"instance : HasPullbacks Scheme :=\n  hasPullbacks_of_hasLimit_cospan _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.isAffine_of_isAffine_isAffine_isAffine","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœÂ² : AlgebraicGeometry.IsAffine X\ninstâœÂ¹ : AlgebraicGeometry.IsAffine Y\ninstâœ : AlgebraicGeometry.IsAffine Z\nâŠ¢ AlgebraicGeometry.IsAffine (CategoryTheory.Limits.pullback f g)","decl":"instance isAffine_of_isAffine_isAffine_isAffine {X Y Z : Scheme}\n    (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [IsAffine X] [IsAffine Y] [IsAffine Z] :\n    IsAffine (pullback f g) :=\n  isAffine_of_isIso\n    (pullback.map f g (Spec.map (Î“.map f.op)) (Spec.map (Î“.map g.op))\n        X.toSpecÎ“ Y.toSpecÎ“ Z.toSpecÎ“\n        (Scheme.toSpecÎ“_naturality f) (Scheme.toSpecÎ“_naturality g) â‰«\n      (PreservesPullback.iso Scheme.Spec _ _).inv)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nâŠ¢ Eq (AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft ğ’° f g).J ğ’°.J","decl":"/-- Given an open cover `{ Xáµ¢ }` of `X`, then `X Ã—[Z] Y` is covered by `Xáµ¢ Ã—[Z] Y`. -/\n@[simps! J obj map]\ndef openCoverOfLeft (ğ’° : OpenCover X) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((gluing ğ’° f g).openCover.pushforwardIso\n          (limit.isoLimitCone âŸ¨_, gluedIsLimit ğ’° f gâŸ©).inv).copy\n      ğ’°.J (fun i => pullback (ğ’°.map i â‰« f) g)\n      (fun i => pullback.map _ _ _ _ (ğ’°.map i) (ğŸ™ _) (ğŸ™ _) (Category.comp_id _) (by simp))\n      (Equiv.refl ğ’°.J) fun _ => Iso.refl _\n  rintro (i : ğ’°.J)\n  simp_rw [Cover.pushforwardIso_J, Cover.pushforwardIso_map, GlueData.openCover_map,\n    GlueData.openCover_J, gluing_J]\n  exact pullback.hom_ext (by simp [p1]) (by simp [p2])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft ğ’° f g).map i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g f g (ğ’°.map i) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) â‹¯ â‹¯)","decl":"/-- Given an open cover `{ Xáµ¢ }` of `X`, then `X Ã—[Z] Y` is covered by `Xáµ¢ Ã—[Z] Y`. -/\n@[simps! J obj map]\ndef openCoverOfLeft (ğ’° : OpenCover X) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((gluing ğ’° f g).openCover.pushforwardIso\n          (limit.isoLimitCone âŸ¨_, gluedIsLimit ğ’° f gâŸ©).inv).copy\n      ğ’°.J (fun i => pullback (ğ’°.map i â‰« f) g)\n      (fun i => pullback.map _ _ _ _ (ğ’°.map i) (ğŸ™ _) (ğŸ™ _) (Category.comp_id _) (by simp))\n      (Equiv.refl ğ’°.J) fun _ => Iso.refl _\n  rintro (i : ğ’°.J)\n  simp_rw [Cover.pushforwardIso_J, Cover.pushforwardIso_map, GlueData.openCover_map,\n    GlueData.openCover_J, gluing_J]\n  exact pullback.hom_ext (by simp [p1]) (by simp [p2])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft_obj","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft ğ’° f g).obj i) (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f) g)","decl":"/-- Given an open cover `{ Xáµ¢ }` of `X`, then `X Ã—[Z] Y` is covered by `Xáµ¢ Ã—[Z] Y`. -/\n@[simps! J obj map]\ndef openCoverOfLeft (ğ’° : OpenCover X) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((gluing ğ’° f g).openCover.pushforwardIso\n          (limit.isoLimitCone âŸ¨_, gluedIsLimit ğ’° f gâŸ©).inv).copy\n      ğ’°.J (fun i => pullback (ğ’°.map i â‰« f) g)\n      (fun i => pullback.map _ _ _ _ (ğ’°.map i) (ğŸ™ _) (ğŸ™ _) (Category.comp_id _) (by simp))\n      (Equiv.refl ğ’°.J) fun _ => Iso.refl _\n  rintro (i : ğ’°.J)\n  simp_rw [Cover.pushforwardIso_J, Cover.pushforwardIso_map, GlueData.openCover_map,\n    GlueData.openCover_J, gluing_J]\n  exact pullback.hom_ext (by simp [p1]) (by simp [p2])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfRight_obj","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfRight ğ’° f g).obj i) (CategoryTheory.Limits.pullback f (CategoryTheory.CategoryStruct.comp (ğ’°.map i) g))","decl":"/-- Given an open cover `{ Yáµ¢ }` of `Y`, then `X Ã—[Z] Y` is covered by `X Ã—[Z] Yáµ¢`. -/\n@[simps! J obj map]\ndef openCoverOfRight (ğ’° : OpenCover Y) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((openCoverOfLeft ğ’° g f).pushforwardIso (pullbackSymmetry _ _).hom).copy ğ’°.J\n      (fun i => pullback f (ğ’°.map i â‰« g))\n      (fun i => pullback.map _ _ _ _ (ğŸ™ _) (ğ’°.map i) (ğŸ™ _) (by simp) (Category.comp_id _))\n      (Equiv.refl _) fun i => pullbackSymmetry _ _\n  intro i\n  dsimp [Cover.bind]\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfRight_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfRight ğ’° f g).map i) (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp (ğ’°.map i) g) f g (CategoryTheory.CategoryStruct.id X) (ğ’°.map i) (CategoryTheory.CategoryStruct.id Z) â‹¯ â‹¯)","decl":"/-- Given an open cover `{ Yáµ¢ }` of `Y`, then `X Ã—[Z] Y` is covered by `X Ã—[Z] Yáµ¢`. -/\n@[simps! J obj map]\ndef openCoverOfRight (ğ’° : OpenCover Y) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((openCoverOfLeft ğ’° g f).pushforwardIso (pullbackSymmetry _ _).hom).copy ğ’°.J\n      (fun i => pullback f (ğ’°.map i â‰« g))\n      (fun i => pullback.map _ _ _ _ (ğŸ™ _) (ğ’°.map i) (ğŸ™ _) (by simp) (Category.comp_id _))\n      (Equiv.refl _) fun i => pullbackSymmetry _ _\n  intro i\n  dsimp [Cover.bind]\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfRight_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nâŠ¢ Eq (AlgebraicGeometry.Scheme.Pullback.openCoverOfRight ğ’° f g).J ğ’°.J","decl":"/-- Given an open cover `{ Yáµ¢ }` of `Y`, then `X Ã—[Z] Y` is covered by `X Ã—[Z] Yáµ¢`. -/\n@[simps! J obj map]\ndef openCoverOfRight (ğ’° : OpenCover Y) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((openCoverOfLeft ğ’° g f).pushforwardIso (pullbackSymmetry _ _).hom).copy ğ’°.J\n      (fun i => pullback f (ğ’°.map i â‰« g))\n      (fun i => pullback.map _ _ _ _ (ğŸ™ _) (ğ’°.map i) (ğŸ™ _) (by simp) (Category.comp_id _))\n      (Equiv.refl _) fun i => pullbackSymmetry _ _\n  intro i\n  dsimp [Cover.bind]\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight_obj","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’°X : X.OpenCover\nğ’°Y : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nij : Prod ğ’°X.J ğ’°Y.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight ğ’°X ğ’°Y f g).obj ij) (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (ğ’°X.map ij.1) f) (CategoryTheory.CategoryStruct.comp (ğ’°Y.map ij.2) g))","decl":"/-- Given an open cover `{ Xáµ¢ }` of `X` and an open cover `{ Yâ±¼ }` of `Y`, then\n`X Ã—[Z] Y` is covered by `Xáµ¢ Ã—[Z] Yâ±¼`. -/\n@[simps! J obj map]\ndef openCoverOfLeftRight (ğ’°X : X.OpenCover) (ğ’°Y : Y.OpenCover) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) :\n    (pullback f g).OpenCover := by\n  fapply\n    ((openCoverOfLeft ğ’°X f g).bind fun x => openCoverOfRight ğ’°Y (ğ’°X.map x â‰« f) g).copy\n      (ğ’°X.J Ã— ğ’°Y.J) (fun ij => pullback (ğ’°X.map ij.1 â‰« f) (ğ’°Y.map ij.2 â‰« g))\n      (fun ij =>\n        pullback.map _ _ _ _ (ğ’°X.map ij.1) (ğ’°Y.map ij.2) (ğŸ™ _) (Category.comp_id _)\n          (Category.comp_id _))\n      (Equiv.sigmaEquivProd _ _).symm fun _ => Iso.refl _\n  rintro âŸ¨i, jâŸ©\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’°X : X.OpenCover\nğ’°Y : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nâŠ¢ Eq (AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight ğ’°X ğ’°Y f g).J (Prod ğ’°X.J ğ’°Y.J)","decl":"/-- Given an open cover `{ Xáµ¢ }` of `X` and an open cover `{ Yâ±¼ }` of `Y`, then\n`X Ã—[Z] Y` is covered by `Xáµ¢ Ã—[Z] Yâ±¼`. -/\n@[simps! J obj map]\ndef openCoverOfLeftRight (ğ’°X : X.OpenCover) (ğ’°Y : Y.OpenCover) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) :\n    (pullback f g).OpenCover := by\n  fapply\n    ((openCoverOfLeft ğ’°X f g).bind fun x => openCoverOfRight ğ’°Y (ğ’°X.map x â‰« f) g).copy\n      (ğ’°X.J Ã— ğ’°Y.J) (fun ij => pullback (ğ’°X.map ij.1 â‰« f) (ğ’°Y.map ij.2 â‰« g))\n      (fun ij =>\n        pullback.map _ _ _ _ (ğ’°X.map ij.1) (ğ’°Y.map ij.2) (ğŸ™ _) (Category.comp_id _)\n          (Category.comp_id _))\n      (Equiv.sigmaEquivProd _ _).symm fun _ => Iso.refl _\n  rintro âŸ¨i, jâŸ©\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’°X : X.OpenCover\nğ’°Y : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nij : Prod ğ’°X.J ğ’°Y.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight ğ’°X ğ’°Y f g).map ij) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (ğ’°X.map ij.1) f) (CategoryTheory.CategoryStruct.comp (ğ’°Y.map ij.2) g) f g (ğ’°X.map ij.1) (ğ’°Y.map ij.2) (CategoryTheory.CategoryStruct.id Z) â‹¯ â‹¯)","decl":"/-- Given an open cover `{ Xáµ¢ }` of `X` and an open cover `{ Yâ±¼ }` of `Y`, then\n`X Ã—[Z] Y` is covered by `Xáµ¢ Ã—[Z] Yâ±¼`. -/\n@[simps! J obj map]\ndef openCoverOfLeftRight (ğ’°X : X.OpenCover) (ğ’°Y : Y.OpenCover) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) :\n    (pullback f g).OpenCover := by\n  fapply\n    ((openCoverOfLeft ğ’°X f g).bind fun x => openCoverOfRight ğ’°Y (ğ’°X.map x â‰« f) g).copy\n      (ğ’°X.J Ã— ğ’°Y.J) (fun ij => pullback (ğ’°X.map ij.1 â‰« f) (ğ’°Y.map ij.2 â‰« g))\n      (fun ij =>\n        pullback.map _ _ _ _ (ğ’°X.map ij.1) (ğ’°Y.map ij.2) (ğŸ™ _) (Category.comp_id _)\n          (Category.comp_id _))\n      (Equiv.sigmaEquivProd _ _).symm fun _ => Iso.refl _\n  rintro âŸ¨i, jâŸ©\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfBase'_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : Z.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : Sigma fun i => ((fun i => AlgebraicGeometry.Scheme.coverOfIsIso (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (CategoryTheory.Limits.pullback.snd f (ğ’°.map i)) (CategoryTheory.Limits.pullback.snd g (ğ’°.map i))).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone { cone := â‹¯.cone, isLimit := â‹¯.isLimit }).inv (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f (ğ’°.map i)) (ğ’°.map i)) g (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° f).map i) f) g (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback f (ğ’°.map i))) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) â‹¯ â‹¯)))) i).J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfBase' ğ’° f g).map x) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (CategoryTheory.Limits.pullback.snd f (ğ’°.map x.fst)) (CategoryTheory.Limits.pullback.snd g (ğ’°.map x.fst))).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone { cone := â‹¯.cone, isLimit := â‹¯.isLimit }).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f (ğ’°.map x.fst)) (ğ’°.map x.fst)) g (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f (ğ’°.map x.fst)) f) g (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback f (ğ’°.map x.fst))) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) â‹¯ â‹¯) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f (ğ’°.map x.fst)) f) g f g (CategoryTheory.Limits.pullback.fst f (ğ’°.map x.fst)) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) â‹¯ â‹¯))))","decl":"/-- (Implementation). Use `openCoverOfBase` instead. -/\n@[simps! map]\ndef openCoverOfBase' (ğ’° : OpenCover Z) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  apply (openCoverOfLeft (ğ’°.pullbackCover f) f g).bind\n  intro i\n  haveI := ((IsPullback.of_hasPullback (pullback.snd g (ğ’°.map i))\n    (pullback.snd f (ğ’°.map i))).paste_horiz (IsPullback.of_hasPullback _ _)).flip\n  refine\n    @coverOfIsIso _ _ _ _ _\n      (f := (pullbackSymmetry (pullback.snd f (ğ’°.map i)) (pullback.snd g (ğ’°.map i))).hom â‰«\n        (limit.isoLimitCone âŸ¨_, this.isLimitâŸ©).inv â‰«\n        pullback.map _ _ _ _ (ğŸ™ _) (ğŸ™ _) (ğŸ™ _) ?_ ?_) inferInstance\n  Â· simp [â† pullback.condition]\n  Â· simp only [Category.comp_id, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfBase_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : Z.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nâŠ¢ Eq (AlgebraicGeometry.Scheme.Pullback.openCoverOfBase ğ’° f g).J ğ’°.J","decl":"/-- Given an open cover `{ Záµ¢ }` of `Z`, then `X Ã—[Z] Y` is covered by `Xáµ¢ Ã—[Záµ¢] Yáµ¢`, where\n  `Xáµ¢ = X Ã—[Z] Záµ¢` and `Yáµ¢ = Y Ã—[Z] Záµ¢` is the preimage of `Záµ¢` in `X` and `Y`. -/\n@[simps! J obj map]\ndef openCoverOfBase (ğ’° : OpenCover Z) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  apply\n    (openCoverOfBase'.{u, u} ğ’° f g).copy ğ’°.J\n      (fun i =>\n        pullback (pullback.snd _ _ : pullback f (ğ’°.map i) âŸ¶ _)\n          (pullback.snd _ _ : pullback g (ğ’°.map i) âŸ¶ _))\n      (fun i =>\n        pullback.map _ _ _ _ (pullback.fst _ _) (pullback.fst _ _) (ğ’°.map i)\n          pullback.condition.symm pullback.condition.symm)\n      ((Equiv.prodPUnit ğ’°.J).symm.trans (Equiv.sigmaEquivProd ğ’°.J PUnit).symm) fun _ => Iso.refl _\n  intro i\n  rw [Iso.refl_hom, Category.id_comp, openCoverOfBase'_map]\n  ext : 1 <;>\n  Â· simp only [limit.lift_Ï€, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app, Equiv.trans_apply,\n      Equiv.prodPUnit_symm_apply, Category.assoc, limit.lift_Ï€_assoc, cospan_left, Category.comp_id,\n      limit.isoLimitCone_inv_Ï€_assoc, PullbackCone.Ï€_app_left, IsPullback.cone_fst,\n      pullbackSymmetry_hom_comp_snd_assoc, limit.isoLimitCone_inv_Ï€,\n      PullbackCone.Ï€_app_right, IsPullback.cone_snd, pullbackSymmetry_hom_comp_fst_assoc]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfBase_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : Z.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfBase ğ’° f g).map i) (CategoryTheory.Limits.pullback.map (CategoryTheory.Limits.pullback.snd f (ğ’°.map i)) (CategoryTheory.Limits.pullback.snd g (ğ’°.map i)) f g (CategoryTheory.Limits.pullback.fst f (ğ’°.map i)) (CategoryTheory.Limits.pullback.fst g (ğ’°.map i)) (ğ’°.map i) â‹¯ â‹¯)","decl":"/-- Given an open cover `{ Záµ¢ }` of `Z`, then `X Ã—[Z] Y` is covered by `Xáµ¢ Ã—[Záµ¢] Yáµ¢`, where\n  `Xáµ¢ = X Ã—[Z] Záµ¢` and `Yáµ¢ = Y Ã—[Z] Záµ¢` is the preimage of `Záµ¢` in `X` and `Y`. -/\n@[simps! J obj map]\ndef openCoverOfBase (ğ’° : OpenCover Z) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  apply\n    (openCoverOfBase'.{u, u} ğ’° f g).copy ğ’°.J\n      (fun i =>\n        pullback (pullback.snd _ _ : pullback f (ğ’°.map i) âŸ¶ _)\n          (pullback.snd _ _ : pullback g (ğ’°.map i) âŸ¶ _))\n      (fun i =>\n        pullback.map _ _ _ _ (pullback.fst _ _) (pullback.fst _ _) (ğ’°.map i)\n          pullback.condition.symm pullback.condition.symm)\n      ((Equiv.prodPUnit ğ’°.J).symm.trans (Equiv.sigmaEquivProd ğ’°.J PUnit).symm) fun _ => Iso.refl _\n  intro i\n  rw [Iso.refl_hom, Category.id_comp, openCoverOfBase'_map]\n  ext : 1 <;>\n  Â· simp only [limit.lift_Ï€, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app, Equiv.trans_apply,\n      Equiv.prodPUnit_symm_apply, Category.assoc, limit.lift_Ï€_assoc, cospan_left, Category.comp_id,\n      limit.isoLimitCone_inv_Ï€_assoc, PullbackCone.Ï€_app_left, IsPullback.cone_fst,\n      pullbackSymmetry_hom_comp_snd_assoc, limit.isoLimitCone_inv_Ï€,\n      PullbackCone.Ï€_app_right, IsPullback.cone_snd, pullbackSymmetry_hom_comp_fst_assoc]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfBase_obj","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nğ’° : Z.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : ğ’°.J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfBase ğ’° f g).obj i) (CategoryTheory.Limits.pullback (CategoryTheory.Limits.pullback.snd f (ğ’°.map i)) (CategoryTheory.Limits.pullback.snd g (ğ’°.map i)))","decl":"/-- Given an open cover `{ Záµ¢ }` of `Z`, then `X Ã—[Z] Y` is covered by `Xáµ¢ Ã—[Záµ¢] Yáµ¢`, where\n  `Xáµ¢ = X Ã—[Z] Záµ¢` and `Yáµ¢ = Y Ã—[Z] Záµ¢` is the preimage of `Záµ¢` in `X` and `Y`. -/\n@[simps! J obj map]\ndef openCoverOfBase (ğ’° : OpenCover Z) (f : X âŸ¶ Z) (g : Y âŸ¶ Z) : OpenCover (pullback f g) := by\n  apply\n    (openCoverOfBase'.{u, u} ğ’° f g).copy ğ’°.J\n      (fun i =>\n        pullback (pullback.snd _ _ : pullback f (ğ’°.map i) âŸ¶ _)\n          (pullback.snd _ _ : pullback g (ğ’°.map i) âŸ¶ _))\n      (fun i =>\n        pullback.map _ _ _ _ (pullback.fst _ _) (pullback.fst _ _) (ğ’°.map i)\n          pullback.condition.symm pullback.condition.symm)\n      ((Equiv.prodPUnit ğ’°.J).symm.trans (Equiv.sigmaEquivProd ğ’°.J PUnit).symm) fun _ => Iso.refl _\n  intro i\n  rw [Iso.refl_hom, Category.id_comp, openCoverOfBase'_map]\n  ext : 1 <;>\n  Â· simp only [limit.lift_Ï€, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app, Equiv.trans_apply,\n      Equiv.prodPUnit_symm_apply, Category.assoc, limit.lift_Ï€_assoc, cospan_left, Category.comp_id,\n      limit.isoLimitCone_inv_Ï€_assoc, PullbackCone.Ï€_app_left, IsPullback.cone_fst,\n      pullbackSymmetry_hom_comp_snd_assoc, limit.isoLimitCone_inv_Ï€,\n      PullbackCone.Ï€_app_right, IsPullback.cone_snd, pullbackSymmetry_hom_comp_fst_assoc]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.diagonalCover_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\nğ’± : (i : (AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° f).J) â†’ ((AlgebraicGeometry.Scheme.Cover.pullbackCover ğ’° f).obj i).OpenCover\nI : (AlgebraicGeometry.Scheme.Pullback.diagonalCover f ğ’° ğ’±).J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Pullback.diagonalCover f ğ’° ğ’±).map I) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp ((ğ’± I.fst).map I.snd.1) (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f I.fst)) (CategoryTheory.CategoryStruct.comp ((ğ’± I.fst).map I.snd.2) (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f I.fst)) f f (CategoryTheory.CategoryStruct.comp ((ğ’± I.fst).map I.snd.1) (CategoryTheory.Limits.pullback.fst f (ğ’°.map I.fst))) (CategoryTheory.CategoryStruct.comp ((ğ’± I.fst).map I.snd.2) (CategoryTheory.Limits.pullback.fst f (ğ’°.map I.fst))) (ğ’°.map I.fst) â‹¯ â‹¯)","decl":"lemma diagonalCover_map (I) : (diagonalCover f ğ’° ğ’±).map I =\n    pullback.map _ _ _ _\n    ((ğ’± I.fst).map _ â‰« pullback.fst _ _) ((ğ’± I.fst).map _ â‰« pullback.fst _ _) (ğ’°.map _)\n    (by simp)\n    (by simp) := by\n  ext1 <;> simp [diagonalCover, Cover.pullbackHom]\n\n"}
{"name":"AlgebraicGeometry.Scheme.pullback_map_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y S X' Y' S' : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom X' S'\ng' : Quiver.Hom Y' S'\niâ‚ : Quiver.Hom X X'\niâ‚‚ : Quiver.Hom Y Y'\niâ‚ƒ : Quiver.Hom S S'\neâ‚ : Eq (CategoryTheory.CategoryStruct.comp f iâ‚ƒ) (CategoryTheory.CategoryStruct.comp iâ‚ f')\neâ‚‚ : Eq (CategoryTheory.CategoryStruct.comp g iâ‚ƒ) (CategoryTheory.CategoryStruct.comp iâ‚‚ g')\ninstâœÂ² : AlgebraicGeometry.IsOpenImmersion iâ‚\ninstâœÂ¹ : AlgebraicGeometry.IsOpenImmersion iâ‚‚\ninstâœ : CategoryTheory.Mono iâ‚ƒ\nâŠ¢ AlgebraicGeometry.IsOpenImmersion (CategoryTheory.Limits.pullback.map f g f' g' iâ‚ iâ‚‚ iâ‚ƒ eâ‚ eâ‚‚)","decl":"instance Scheme.pullback_map_isOpenImmersion {X Y S X' Y' S' : Scheme}\n    (f : X âŸ¶ S) (g : Y âŸ¶ S) (f' : X' âŸ¶ S') (g' : Y' âŸ¶ S')\n    (iâ‚ : X âŸ¶ X') (iâ‚‚ : Y âŸ¶ Y') (iâ‚ƒ : S âŸ¶ S') (eâ‚ : f â‰« iâ‚ƒ = iâ‚ â‰« f') (eâ‚‚ : g â‰« iâ‚ƒ = iâ‚‚ â‰« g')\n    [IsOpenImmersion iâ‚] [IsOpenImmersion iâ‚‚] [Mono iâ‚ƒ] :\n    IsOpenImmersion (pullback.map f g f' g' iâ‚ iâ‚‚ iâ‚ƒ eâ‚ eâ‚‚) := by\n  rw [pullback_map_eq_pullbackFstFstIso_inv]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_inv_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing S\ninstâœÂ² : CommRing T\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra R T\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).inv (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T))))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom))","decl":"/--\nThe composition of the inverse of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S âŸ¶ Spec R` and `Spec T âŸ¶ Spec R` to `Spec (S âŠ—[R] T)`) with the first projection is\nthe morphism `Spec (S âŠ—[R] T) âŸ¶ Spec S` obtained by applying `Spec.map` to the ring morphism\n`s â†¦ s âŠ—â‚œ[R] 1`.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_inv_fst :\n    (pullbackSpecIso R S T).inv â‰« pullback.fst _ _ = Spec.map (ofHom includeLeftRingHom) :=\n  limit.isoLimitCone_inv_Ï€ _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_inv_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing S\ninstâœÂ² : CommRing T\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra R T\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of S)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T)))) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom)) h)","decl":"/--\nThe composition of the inverse of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S âŸ¶ Spec R` and `Spec T âŸ¶ Spec R` to `Spec (S âŠ—[R] T)`) with the first projection is\nthe morphism `Spec (S âŠ—[R] T) âŸ¶ Spec S` obtained by applying `Spec.map` to the ring morphism\n`s â†¦ s âŠ—â‚œ[R] 1`.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_inv_fst :\n    (pullbackSpecIso R S T).inv â‰« pullback.fst _ _ = Spec.map (ofHom includeLeftRingHom) :=\n  limit.isoLimitCone_inv_Ï€ _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_inv_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing S\ninstâœÂ² : CommRing T\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra R T\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of T)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T)))) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom â†‘Algebra.TensorProduct.includeRight)) h)","decl":"/--\nThe composition of the inverse of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S âŸ¶ Spec R` and `Spec T âŸ¶ Spec R` to `Spec (S âŠ—[R] T)`) with the second projection is\nthe morphism `Spec (S âŠ—[R] T) âŸ¶ Spec T` obtained by applying `Spec.map` to the ring morphism\n`t â†¦ 1 âŠ—â‚œ[R] t`.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_inv_snd :\n    (pullbackSpecIso R S T).inv â‰« pullback.snd _ _ =\n      Spec.map (ofHom (R := T) (S := S âŠ—[R] T) (toRingHom includeRight)) :=\n  limit.isoLimitCone_inv_Ï€ _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_inv_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing S\ninstâœÂ² : CommRing T\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra R T\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).inv (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T))))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom â†‘Algebra.TensorProduct.includeRight))","decl":"/--\nThe composition of the inverse of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S âŸ¶ Spec R` and `Spec T âŸ¶ Spec R` to `Spec (S âŠ—[R] T)`) with the second projection is\nthe morphism `Spec (S âŠ—[R] T) âŸ¶ Spec T` obtained by applying `Spec.map` to the ring morphism\n`t â†¦ 1 âŠ—â‚œ[R] t`.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_inv_snd :\n    (pullbackSpecIso R S T).inv â‰« pullback.snd _ _ =\n      Spec.map (ofHom (R := T) (S := S âŠ—[R] T) (toRingHom includeRight)) :=\n  limit.isoLimitCone_inv_Ï€ _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_hom_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing S\ninstâœÂ² : CommRing T\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra R T\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).hom (AlgebraicGeometry.Spec.map (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom))) (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T))))","decl":"/--\nThe composition of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S âŸ¶ Spec R` and `Spec T âŸ¶ Spec R` to `Spec (S âŠ—[R] T)`) with the morphism\n`Spec (S âŠ—[R] T) âŸ¶ Spec S` obtained by applying `Spec.map` to the ring morphism `s â†¦ s âŠ—â‚œ[R] 1`\nis the first projection.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_hom_fst :\n    (pullbackSpecIso R S T).hom â‰« Spec.map (ofHom includeLeftRingHom) = pullback.fst _ _ := by\n  rw [â† pullbackSpecIso_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_hom_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing S\ninstâœÂ² : CommRing T\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra R T\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of S)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T)))) h)","decl":"/--\nThe composition of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S âŸ¶ Spec R` and `Spec T âŸ¶ Spec R` to `Spec (S âŠ—[R] T)`) with the morphism\n`Spec (S âŠ—[R] T) âŸ¶ Spec S` obtained by applying `Spec.map` to the ring morphism `s â†¦ s âŠ—â‚œ[R] 1`\nis the first projection.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_hom_fst :\n    (pullbackSpecIso R S T).hom â‰« Spec.map (ofHom includeLeftRingHom) = pullback.fst _ _ := by\n  rw [â† pullbackSpecIso_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_hom_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing S\ninstâœÂ² : CommRing T\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra R T\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).hom (AlgebraicGeometry.Spec.map (CommRingCat.ofHom â†‘Algebra.TensorProduct.includeRight))) (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T))))","decl":"/--\nThe composition of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S âŸ¶ Spec R` and `Spec T âŸ¶ Spec R` to `Spec (S âŠ—[R] T)`) with the morphism\n`Spec (S âŠ—[R] T) âŸ¶ Spec T` obtained by applying `Spec.map` to the ring morphism `t â†¦ 1 âŠ—â‚œ[R] t`\nis the second projection.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_hom_snd :\n    (pullbackSpecIso R S T).hom â‰« Spec.map (ofHom (toRingHom includeRight)) = pullback.snd _ _ := by\n  rw [â† pullbackSpecIso_inv_snd, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_hom_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing S\ninstâœÂ² : CommRing T\ninstâœÂ¹ : Algebra R S\ninstâœ : Algebra R T\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of T)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom â†‘Algebra.TensorProduct.includeRight)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T)))) h)","decl":"/--\nThe composition of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S âŸ¶ Spec R` and `Spec T âŸ¶ Spec R` to `Spec (S âŠ—[R] T)`) with the morphism\n`Spec (S âŠ—[R] T) âŸ¶ Spec T` obtained by applying `Spec.map` to the ring morphism `t â†¦ 1 âŠ—â‚œ[R] t`\nis the second projection.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_hom_snd :\n    (pullbackSpecIso R S T).hom â‰« Spec.map (ofHom (toRingHom includeRight)) = pullback.snd _ _ := by\n  rw [â† pullbackSpecIso_inv_snd, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.isPullback_Spec_map_isPushout","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"A B C P : CommRingCat\nf : Quiver.Hom A B\ng : Quiver.Hom A C\ninl : Quiver.Hom B P\ninr : Quiver.Hom C P\nh : CategoryTheory.IsPushout f g inl inr\nâŠ¢ CategoryTheory.IsPullback (AlgebraicGeometry.Spec.map inl) (AlgebraicGeometry.Spec.map inr) (AlgebraicGeometry.Spec.map f) (AlgebraicGeometry.Spec.map g)","decl":"lemma isPullback_Spec_map_isPushout {A B C P : CommRingCat} (f : A âŸ¶ B) (g : A âŸ¶ C)\n    (inl : B âŸ¶ P) (inr : C âŸ¶ P) (h : IsPushout f g inl inr) :\n    IsPullback (Spec.map inl) (Spec.map inr) (Spec.map f) (Spec.map g) :=\n  IsPullback.map Scheme.Spec h.op.flip\n\n"}
{"name":"AlgebraicGeometry.isPullback_Spec_map_pushout","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"A B C : CommRingCat\nf : Quiver.Hom A B\ng : Quiver.Hom A C\nâŠ¢ CategoryTheory.IsPullback (AlgebraicGeometry.Spec.map (CategoryTheory.Limits.pushout.inl f g)) (AlgebraicGeometry.Spec.map (CategoryTheory.Limits.pushout.inr f g)) (AlgebraicGeometry.Spec.map f) (AlgebraicGeometry.Spec.map g)","decl":"lemma isPullback_Spec_map_pushout {A B C : CommRingCat} (f : A âŸ¶ B) (g : A âŸ¶ C) :\n    IsPullback (Spec.map (pushout.inl f g))\n      (Spec.map (pushout.inr f g)) (Spec.map f) (Spec.map g) := by\n  apply isPullback_Spec_map_isPushout\n  exact IsPushout.of_hasPushout f g\n\n"}
{"name":"AlgebraicGeometry.diagonal_Spec_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S : Type u\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nâŠ¢ Eq (CategoryTheory.Limits.pullback.diagonal (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S)))) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Algebra.TensorProduct.lmul' R).toRingHom)) (AlgebraicGeometry.pullbackSpecIso R S S).inv)","decl":"lemma diagonal_Spec_map :\n    pullback.diagonal (Spec.map (CommRingCat.ofHom (algebraMap R S))) =\n      Spec.map (CommRingCat.ofHom (Algebra.TensorProduct.lmul' R : S âŠ—[R] S â†’â‚[R] S).toRingHom) â‰«\n        (pullbackSpecIso R S S).inv := by\n  ext1 <;> simp only [pullback.diagonal_fst, pullback.diagonal_snd, â† Spec.map_comp, â† Spec.map_id,\n    AlgHom.toRingHom_eq_coe, Category.assoc, pullbackSpecIso_inv_fst, pullbackSpecIso_inv_snd]\n  Â· congr 1; ext x; show x = Algebra.TensorProduct.lmul' R (S := S) (x âŠ—â‚œ[R] 1); simp\n  Â· congr 1; ext x; show x = Algebra.TensorProduct.lmul' R (S := S) (1 âŠ—â‚œ[R] x); simp\n\n"}
