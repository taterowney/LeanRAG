{"name":"AlgebraicGeometry.Scheme.Pullback.t_fst_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t 𝒰 f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) h)","decl":"@[simp, reassoc]\ntheorem t_fst_fst (i j : 𝒰.J) : t 𝒰 f g i j ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n    pullback.snd _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_fst_assoc, pullbackAssoc_hom_snd_fst,\n    pullback.lift_fst_assoc, pullbackSymmetry_hom_comp_snd, pullbackAssoc_inv_fst_fst,\n    pullbackSymmetry_hom_comp_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t 𝒰 f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j))","decl":"@[simp, reassoc]\ntheorem t_fst_fst (i j : 𝒰.J) : t 𝒰 f g i j ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n    pullback.snd _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_fst_assoc, pullbackAssoc_hom_snd_fst,\n    pullback.lift_fst_assoc, pullbackSymmetry_hom_comp_snd, pullbackAssoc_inv_fst_fst,\n    pullbackSymmetry_hom_comp_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t 𝒰 f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g))","decl":"@[simp, reassoc]\ntheorem t_fst_snd (i j : 𝒰.J) :\n    t 𝒰 f g i j ≫ pullback.fst _ _ ≫ pullback.snd _ _ = pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_fst_assoc, pullbackAssoc_hom_snd_snd,\n    pullback.lift_snd, Category.comp_id, pullbackAssoc_inv_snd, pullbackSymmetry_hom_comp_snd_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t 𝒰 f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) h))","decl":"@[simp, reassoc]\ntheorem t_fst_snd (i j : 𝒰.J) :\n    t 𝒰 f g i j ≫ pullback.fst _ _ ≫ pullback.snd _ _ = pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_fst_assoc, pullbackAssoc_hom_snd_snd,\n    pullback.lift_snd, Category.comp_id, pullbackAssoc_inv_snd, pullbackSymmetry_hom_comp_snd_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t 𝒰 f g i j) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g))","decl":"@[simp, reassoc]\ntheorem t_snd (i j : 𝒰.J) : t 𝒰 f g i j ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ pullback.fst _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_snd, pullbackAssoc_hom_fst,\n    pullback.lift_fst_assoc, pullbackSymmetry_hom_comp_fst, pullbackAssoc_inv_fst_snd,\n    pullbackSymmetry_hom_comp_snd_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t 𝒰 f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) h))","decl":"@[simp, reassoc]\ntheorem t_snd (i j : 𝒰.J) : t 𝒰 f g i j ≫ pullback.snd _ _ =\n    pullback.fst _ _ ≫ pullback.fst _ _ := by\n  simp only [t, Category.assoc, pullbackSymmetry_hom_comp_snd, pullbackAssoc_hom_fst,\n    pullback.lift_fst_assoc, pullbackSymmetry_hom_comp_fst, pullbackAssoc_inv_fst_snd,\n    pullbackSymmetry_hom_comp_snd_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t_id","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.t 𝒰 f g i i) (CategoryTheory.CategoryStruct.id (AlgebraicGeometry.Scheme.Pullback.v 𝒰 f g i i))","decl":"theorem t_id (i : 𝒰.J) : t 𝒰 f g i i = 𝟙 _ := by\n  apply pullback.hom_ext <;> rw [Category.id_comp]\n  · apply pullback.hom_ext\n    · rw [← cancel_mono (𝒰.map i)]; simp only [pullback.condition, Category.assoc, t_fst_fst]\n    · simp only [Category.assoc, t_fst_snd]\n  · rw [← cancel_mono (𝒰.map i)]; simp only [pullback.condition, t_snd, Category.assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) h))","decl":"@[simp, reassoc]\ntheorem t'_fst_fst_fst (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map k)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)))","decl":"@[simp, reassoc]\ntheorem t'_fst_fst_fst (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))","decl":"@[simp, reassoc]\ntheorem t'_fst_fst_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) h)))","decl":"@[simp, reassoc]\ntheorem t'_fst_fst_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map k)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map k)))","decl":"@[simp, reassoc]\ntheorem t'_fst_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_snd, pullback.lift_snd, Category.comp_id,\n    pullbackRightPullbackFstIso_hom_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map k)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map k)) h))","decl":"@[simp, reassoc]\ntheorem t'_fst_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_fst_assoc,\n    pullbackRightPullbackFstIso_inv_snd_snd, pullback.lift_snd, Category.comp_id,\n    pullbackRightPullbackFstIso_hom_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)))","decl":"@[simp, reassoc]\ntheorem t'_snd_fst_fst (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.snd _ _ ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) h))","decl":"@[simp, reassoc]\ntheorem t'_snd_fst_fst (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.snd _ _ ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_fst,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))","decl":"@[simp, reassoc]\ntheorem t'_snd_fst_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.snd _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) h)))","decl":"@[simp, reassoc]\ntheorem t'_snd_fst_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.snd _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_fst_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) h)))","decl":"@[simp, reassoc]\ntheorem t'_snd_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.fst _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.t'_snd_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j k) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g j i)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))","decl":"@[simp, reassoc]\ntheorem t'_snd_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.fst _ _ := by\n  simp only [t', Category.assoc, pullbackSymmetry_hom_comp_snd_assoc,\n    pullbackRightPullbackFstIso_inv_fst_assoc, pullback.lift_fst_assoc, t_snd,\n    pullbackRightPullbackFstIso_hom_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_fst_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))","decl":"theorem cocycle_fst_fst_fst (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j ≫ pullback.fst _ _ ≫ pullback.fst _ _ ≫\n      pullback.fst _ _ = pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.fst _ _ := by\n  simp only [t'_fst_fst_fst, t'_fst_snd, t'_snd_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_fst_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))","decl":"theorem cocycle_fst_fst_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j ≫ pullback.fst _ _ ≫ pullback.fst _ _ ≫\n      pullback.snd _ _ = pullback.fst _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t'_fst_fst_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)))","decl":"theorem cocycle_fst_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [t'_fst_snd, t'_snd_snd, t'_fst_fst_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_snd_fst_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map k)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map k)) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))","decl":"theorem cocycle_snd_fst_fst (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j ≫ pullback.snd _ _ ≫ pullback.fst _ _ ≫\n      pullback.fst _ _ = pullback.snd _ _ ≫ pullback.fst _ _ ≫ pullback.fst _ _ := by\n  rw [← cancel_mono (𝒰.map i)]\n  simp only [pullback.condition_assoc, t'_snd_fst_fst, t'_fst_snd, t'_snd_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_snd_fst_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)))","decl":"theorem cocycle_snd_fst_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j ≫ pullback.snd _ _ ≫ pullback.fst _ _ ≫\n      pullback.snd _ _ = pullback.snd _ _ ≫ pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp only [pullback.condition_assoc, t'_snd_fst_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle_snd_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g j k i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g k i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map k)))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map k)))","decl":"theorem cocycle_snd_snd (i j k : 𝒰.J) :\n    t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ pullback.snd _ _ := by\n  simp only [t'_snd_snd, t'_fst_fst_fst, t'_fst_snd]\n\n-- `by tidy` should solve it, but it times out.\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.cocycle","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g j k i) (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g k i j))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i j) (AlgebraicGeometry.Scheme.Pullback.fV 𝒰 f g i k)))","decl":"theorem cocycle (i j k : 𝒰.J) : t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j = 𝟙 _ := by\n  apply pullback.hom_ext <;> rw [Category.id_comp]\n  · apply pullback.hom_ext\n    · apply pullback.hom_ext\n      · simp_rw [Category.assoc, cocycle_fst_fst_fst 𝒰 f g i j k]\n      · simp_rw [Category.assoc, cocycle_fst_fst_snd 𝒰 f g i j k]\n    · simp_rw [Category.assoc, cocycle_fst_snd 𝒰 f g i j k]\n  · apply pullback.hom_ext\n    · apply pullback.hom_ext\n      · simp_rw [Category.assoc, cocycle_snd_fst_fst 𝒰 f g i j k]\n      · simp_rw [Category.assoc, cocycle_snd_fst_snd 𝒰 f g i j k]\n    · simp_rw [Category.assoc, cocycle_snd_snd 𝒰 f g i j k]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_U","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).U i) (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)","decl":"/-- Given `Uᵢ ×[Z] Y`, this is the glued fibered product `X ×[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U i := pullback (𝒰.map i ≫ f) g\n  V := fun ⟨i, j⟩ => v 𝒰 f g i j\n  -- `p⁻¹(Uᵢ ∩ Uⱼ)` where `p : Uᵢ ×[Z] Y ⟶ Uᵢ ⟶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t 𝒰 f g i j\n  t_id i := t_id 𝒰 f g i\n  t' i j k := t' 𝒰 f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle 𝒰 f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).J 𝒰.J","decl":"/-- Given `Uᵢ ×[Z] Y`, this is the glued fibered product `X ×[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U i := pullback (𝒰.map i ≫ f) g\n  V := fun ⟨i, j⟩ => v 𝒰 f g i j\n  -- `p⁻¹(Uᵢ ∩ Uⱼ)` where `p : Uᵢ ×[Z] Y ⟶ Uᵢ ⟶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t 𝒰 f g i j\n  t_id i := t_id 𝒰 f g i\n  t' i j k := t' 𝒰 f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle 𝒰 f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_t","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).t i j) (AlgebraicGeometry.Scheme.Pullback.t 𝒰 f g i j)","decl":"/-- Given `Uᵢ ×[Z] Y`, this is the glued fibered product `X ×[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U i := pullback (𝒰.map i ≫ f) g\n  V := fun ⟨i, j⟩ => v 𝒰 f g i j\n  -- `p⁻¹(Uᵢ ∩ Uⱼ)` where `p : Uᵢ ×[Z] Y ⟶ Uᵢ ⟶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t 𝒰 f g i j\n  t_id i := t_id 𝒰 f g i\n  t' i j k := t' 𝒰 f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle 𝒰 f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_V","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\nx✝ : Prod 𝒰.J 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).V x✝) (AlgebraicGeometry.Scheme.Pullback.gluing.match_1 𝒰 (fun x => AlgebraicGeometry.Scheme) x✝ fun i j => AlgebraicGeometry.Scheme.Pullback.v 𝒰 f g i j)","decl":"/-- Given `Uᵢ ×[Z] Y`, this is the glued fibered product `X ×[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U i := pullback (𝒰.map i ≫ f) g\n  V := fun ⟨i, j⟩ => v 𝒰 f g i j\n  -- `p⁻¹(Uᵢ ∩ Uⱼ)` where `p : Uᵢ ×[Z] Y ⟶ Uᵢ ⟶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t 𝒰 f g i j\n  t_id i := t_id 𝒰 f g i\n  t' i j k := t' 𝒰 f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle 𝒰 f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_t'","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j k : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).t' i j k) (AlgebraicGeometry.Scheme.Pullback.t' 𝒰 f g i j k)","decl":"/-- Given `Uᵢ ×[Z] Y`, this is the glued fibered product `X ×[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U i := pullback (𝒰.map i ≫ f) g\n  V := fun ⟨i, j⟩ => v 𝒰 f g i j\n  -- `p⁻¹(Uᵢ ∩ Uⱼ)` where `p : Uᵢ ×[Z] Y ⟶ Uᵢ ⟶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t 𝒰 f g i j\n  t_id i := t_id 𝒰 f g i\n  t' i j k := t' 𝒰 f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle 𝒰 f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_f","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\nx✝¹ x✝ : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).f x✝¹ x✝) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map x✝¹) f) g) (𝒰.map x✝¹)) (𝒰.map x✝))","decl":"/-- Given `Uᵢ ×[Z] Y`, this is the glued fibered product `X ×[Z] Y`. -/\n@[simps U V f t t', simps (config := .lemmasOnly) J]\ndef gluing : Scheme.GlueData.{u} where\n  J := 𝒰.J\n  U i := pullback (𝒰.map i ≫ f) g\n  V := fun ⟨i, j⟩ => v 𝒰 f g i j\n  -- `p⁻¹(Uᵢ ∩ Uⱼ)` where `p : Uᵢ ×[Z] Y ⟶ Uᵢ ⟶ X`.\n  f _ _ := pullback.fst _ _\n  f_id _ := inferInstance\n  f_open := inferInstance\n  t i j := t 𝒰 f g i j\n  t_id i := t_id 𝒰 f g i\n  t' i j k := t' 𝒰 f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    on_goal 1 => apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle 𝒰 f g i j k\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluing_ι","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\nj : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).ι j) (CategoryTheory.Limits.Multicoequalizer.π (AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).diagram j)","decl":"@[simp]\nlemma gluing_ι (j : 𝒰.J) :\n    (gluing 𝒰 f g).ι j = Multicoequalizer.π (gluing 𝒰 f g).diagram j := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.p_comm","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) f) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.p2 𝒰 f g) g)","decl":"theorem p_comm : p1 𝒰 f g ≫ f = p2 𝒰 f g ≫ g := by\n  apply Multicoequalizer.hom_ext\n  simp [p1, p2, pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\ni j : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap 𝒰 f g s i j) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 s.fst).map i) ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 s.fst).map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry s.fst (𝒰.map i)).hom (CategoryTheory.Limits.pullback.map (𝒰.map i) s.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g (CategoryTheory.CategoryStruct.id (𝒰.obj i)) s.snd f ⋯ ⋯)))","decl":"@[reassoc]\ntheorem gluedLiftPullbackMap_fst (i j : 𝒰.J) :\n    gluedLiftPullbackMap 𝒰 f g s i j ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫\n        (pullbackSymmetry _ _).hom ≫\n          pullback.map _ _ _ _ (𝟙 _) s.snd f (Category.id_comp _).symm s.condition := by\n  simp [gluedLiftPullbackMap]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\ni j : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap 𝒰 f g s i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 s.fst).map i) ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 s.fst).map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry s.fst (𝒰.map i)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map (𝒰.map i) s.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g (CategoryTheory.CategoryStruct.id (𝒰.obj i)) s.snd f ⋯ ⋯) h)))","decl":"@[reassoc]\ntheorem gluedLiftPullbackMap_fst (i j : 𝒰.J) :\n    gluedLiftPullbackMap 𝒰 f g s i j ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫\n        (pullbackSymmetry _ _).hom ≫\n          pullback.map _ _ _ _ (𝟙 _) s.snd f (Category.id_comp _).symm s.condition := by\n  simp [gluedLiftPullbackMap]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\ni j : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap 𝒰 f g s i j) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 s.fst).map i) ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 s.fst).map j)) (CategoryTheory.Limits.pullback.snd s.fst (𝒰.map j)))","decl":"@[reassoc]\ntheorem gluedLiftPullbackMap_snd (i j : 𝒰.J) :\n    gluedLiftPullbackMap 𝒰 f g s i j ≫ pullback.snd _ _ = pullback.snd _ _ ≫ pullback.snd _ _ := by\n  simp [gluedLiftPullbackMap]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\ni j : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap 𝒰 f g s i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) (𝒰.map i)) (𝒰.map j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 s.fst).map i) ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 s.fst).map j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd s.fst (𝒰.map j)) h))","decl":"@[reassoc]\ntheorem gluedLiftPullbackMap_snd (i j : 𝒰.J) :\n    gluedLiftPullbackMap 𝒰 f g s i j ≫ pullback.snd _ _ = pullback.snd _ _ ≫ pullback.snd _ _ := by\n  simp [gluedLiftPullbackMap]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLift_p1","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLift 𝒰 f g s) (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g)) s.fst","decl":"theorem gluedLift_p1 : gluedLift 𝒰 f g s ≫ p1 𝒰 f g = s.fst := by\n  rw [← cancel_epi (𝒰.pullbackCover s.fst).fromGlued]\n  apply Multicoequalizer.hom_ext\n  intro b\n  simp_rw [Cover.fromGlued, Multicoequalizer.π_desc_assoc, gluedLift, ← Category.assoc]\n  simp_rw [(𝒰.pullbackCover s.fst).ι_glueMorphisms]\n  simp [p1, pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.gluedLift_p2","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ns : CategoryTheory.Limits.PullbackCone f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.gluedLift 𝒰 f g s) (AlgebraicGeometry.Scheme.Pullback.p2 𝒰 f g)) s.snd","decl":"theorem gluedLift_p2 : gluedLift 𝒰 f g s ≫ p2 𝒰 f g = s.snd := by\n  rw [← cancel_epi (𝒰.pullbackCover s.fst).fromGlued]\n  apply Multicoequalizer.hom_ext\n  intro b\n  simp_rw [Cover.fromGlued, Multicoequalizer.π_desc_assoc, gluedLift, ← Category.assoc]\n  simp_rw [(𝒰.pullbackCover s.fst).ι_glueMorphisms]\n  simp [p2, pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackFstιToV_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackFstιToV 𝒰 f g i j) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).ι j))","decl":"@[simp, reassoc]\ntheorem pullbackFstιToV_fst (i j : 𝒰.J) :\n    pullbackFstιToV 𝒰 f g i j ≫ pullback.fst _ _ = pullback.snd _ _ := by\n  simp [pullbackFstιToV, p1]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackFstιToV_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackFstιToV 𝒰 f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).ι j)) h)","decl":"@[simp, reassoc]\ntheorem pullbackFstιToV_fst (i j : 𝒰.J) :\n    pullbackFstιToV 𝒰 f g i j ≫ pullback.fst _ _ = pullback.snd _ _ := by\n  simp [pullbackFstιToV, p1]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackFstιToV_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackFstιToV 𝒰 f g i j) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).ι j)) (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)))","decl":"@[simp, reassoc]\ntheorem pullbackFstιToV_snd (i j : 𝒰.J) :\n    pullbackFstιToV 𝒰 f g i j ≫ pullback.snd _ _ = pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp [pullbackFstιToV, p1]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackFstιToV_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni j : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackFstιToV 𝒰 f g i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map j) f) g) (𝒰.map j)) (𝒰.map i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).ι j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) h))","decl":"@[simp, reassoc]\ntheorem pullbackFstιToV_snd (i j : 𝒰.J) :\n    pullbackFstιToV 𝒰 f g i j ≫ pullback.snd _ _ = pullback.fst _ _ ≫ pullback.snd _ _ := by\n  simp [pullbackFstιToV, p1]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.lift_comp_ι","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) (AlgebraicGeometry.Scheme.Pullback.p2 𝒰 f g)) ⋯) ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).ι i)) (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i))","decl":"/-- We show that the map `W ×[X] Uᵢ ⟶ Uᵢ ×[Z] Y ⟶ W` is the first projection, where the\nfirst map is given by the lift of `W ×[X] Uᵢ ⟶ Uᵢ` and `W ×[X] Uᵢ ⟶ W ⟶ Y`.\n\nIt suffices to show that the two map agrees when restricted onto `Uⱼ ×[Z] Y`. In this case,\nboth maps factor through `V j i` via `pullback_fst_ι_to_V` -/\ntheorem lift_comp_ι (i : 𝒰.J) :\n    pullback.lift (pullback.snd _ _) (pullback.fst _ _ ≫ p2 𝒰 f g)\n          (by rw [← pullback.condition_assoc, Category.assoc, p_comm]) ≫\n        (gluing 𝒰 f g).ι i =\n      (pullback.fst _ _ : pullback (p1 𝒰 f g) (𝒰.map i) ⟶ _) := by\n  apply ((gluing 𝒰 f g).openCover.pullbackCover (pullback.fst _ _)).hom_ext\n  intro j\n  dsimp only [Cover.pullbackCover]\n  trans pullbackFstιToV 𝒰 f g i j ≫ fV 𝒰 f g j i ≫ (gluing 𝒰 f g).ι _\n  · rw [← show _ = fV 𝒰 f g j i ≫ _ from (gluing 𝒰 f g).glue_condition j i]\n    simp_rw [← Category.assoc]\n    congr 1\n    rw [gluing_f, gluing_t]\n    apply pullback.hom_ext <;> simp_rw [Category.assoc]\n    · simp_rw [t_fst_fst, pullback.lift_fst, pullbackFstιToV_snd, GlueData.openCover_map]\n    · simp_rw [t_fst_snd, pullback.lift_snd, pullbackFstιToV_fst_assoc, pullback.condition_assoc,\n        GlueData.openCover_map, p2]\n      simp\n  · rw [pullback.condition, ← Category.assoc]\n    simp_rw [pullbackFstιToV_fst, GlueData.openCover_map]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).hom (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)) (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i))","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_fst (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).hom ≫ pullback.fst _ _ = pullback.snd _ _ := by\n  simp_rw [pullbackP1Iso, pullback.lift_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) h)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_fst (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).hom ≫ pullback.fst _ _ = pullback.snd _ _ := by\n  simp_rw [pullbackP1Iso, pullback.lift_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.p2 𝒰 f g) h))","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_snd (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).hom ≫ pullback.snd _ _ = pullback.fst _ _ ≫ p2 𝒰 f g := by\n  simp_rw [pullbackP1Iso, pullback.lift_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).hom (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) (AlgebraicGeometry.Scheme.Pullback.p2 𝒰 f g))","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_snd (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).hom ≫ pullback.snd _ _ = pullback.fst _ _ ≫ p2 𝒰 f g := by\n  simp_rw [pullbackP1Iso, pullback.lift_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).inv (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i))) ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).ι i)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_inv_fst (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).inv ≫ pullback.fst _ _ = (gluing 𝒰 f g).ι i := by\n  simp_rw [pullbackP1Iso, pullback.lift_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).glued Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) h)) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).ι i) h)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_inv_fst (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).inv ≫ pullback.fst _ _ = (gluing 𝒰 f g).ι i := by\n  simp_rw [pullbackP1Iso, pullback.lift_fst]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).inv (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i))) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_inv_snd (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).inv ≫ pullback.snd _ _ = pullback.fst _ _ := by\n  simp_rw [pullbackP1Iso, pullback.lift_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (𝒰.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g) h)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_inv_snd (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).inv ≫ pullback.snd _ _ = pullback.fst _ _ := by\n  simp_rw [pullbackP1Iso, pullback.lift_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_ι_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (CategoryTheory.Limits.multicoequalizer (AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).diagram) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multicoequalizer.π (AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).diagram i) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i)) h)","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_ι (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).hom ≫ Multicoequalizer.π (gluing 𝒰 f g).diagram i =\n    pullback.fst _ _ := by\n  rw [← gluing_ι, ← pullbackP1Iso_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_ι","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\ni : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso 𝒰 f g i).hom (CategoryTheory.Limits.Multicoequalizer.π (AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g).diagram i)) (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Pullback.p1 𝒰 f g) (𝒰.map i))","decl":"@[simp, reassoc]\ntheorem pullbackP1Iso_hom_ι (i : 𝒰.J) :\n    (pullbackP1Iso 𝒰 f g i).hom ≫ Multicoequalizer.π (gluing 𝒰 f g).diagram i =\n    pullback.fst _ _ := by\n  rw [← gluing_ι, ← pullbackP1Iso_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.hasPullback_of_cover","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : ∀ (i : 𝒰.J), CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g\n⊢ CategoryTheory.Limits.HasPullback f g","decl":"include 𝒰 in\ntheorem hasPullback_of_cover : HasPullback f g :=\n  ⟨⟨⟨_, gluedIsLimit 𝒰 f g⟩⟩⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.affine_hasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"A B C : CommRingCat\nf : Quiver.Hom (AlgebraicGeometry.Spec A) (AlgebraicGeometry.Spec C)\ng : Quiver.Hom (AlgebraicGeometry.Spec B) (AlgebraicGeometry.Spec C)\n⊢ CategoryTheory.Limits.HasPullback f g","decl":"instance affine_hasPullback {A B C : CommRingCat}\n    (f : Spec A ⟶ Spec C)\n    (g : Spec B ⟶ Spec C) : HasPullback f g := by\n  rw [← Scheme.Spec.map_preimage f, ← Scheme.Spec.map_preimage g]\n  exact ⟨⟨⟨_, isLimitOfHasPullbackOfPreservesLimit\n    Scheme.Spec (Scheme.Spec.preimage f) (Scheme.Spec.preimage g)⟩⟩⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.affine_affine_hasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"B C : CommRingCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom X (AlgebraicGeometry.Spec C)\ng : Quiver.Hom (AlgebraicGeometry.Spec B) (AlgebraicGeometry.Spec C)\n⊢ CategoryTheory.Limits.HasPullback f g","decl":"theorem affine_affine_hasPullback {B C : CommRingCat} {X : Scheme}\n    (f : X ⟶ Spec C) (g : Spec B ⟶ Spec C) :\n    HasPullback f g :=\n  hasPullback_of_cover X.affineCover f g\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.base_affine_hasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"C : CommRingCat\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X (AlgebraicGeometry.Spec C)\ng : Quiver.Hom Y (AlgebraicGeometry.Spec C)\n⊢ CategoryTheory.Limits.HasPullback f g","decl":"instance base_affine_hasPullback {C : CommRingCat} {X Y : Scheme} (f : X ⟶ Spec C)\n    (g : Y ⟶ Spec C) : HasPullback f g :=\n  @hasPullback_symmetry _ _ _ _ _ _ _\n    (@hasPullback_of_cover _ _ _ Y.affineCover g f fun _ =>\n      @hasPullback_symmetry _ _ _ _ _ _ _ <| affine_affine_hasPullback _ _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.left_affine_comp_pullback_hasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : Z.affineCover.J\n⊢ CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover Z.affineCover f).map i) f) g","decl":"instance left_affine_comp_pullback_hasPullback {X Y Z : Scheme} (f : X ⟶ Z) (g : Y ⟶ Z)\n    (i : Z.affineCover.J) : HasPullback ((Z.affineCover.pullbackCover f).map i ≫ f) g := by\n  simp only [Cover.pullbackCover_obj, Cover.pullbackCover_map, pullback.condition]\n  exact hasPullback_assoc_symm f (Z.affineCover.map i) (Z.affineCover.map i) g\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.instHasPullback","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ CategoryTheory.Limits.HasPullback f g","decl":"instance {X Y Z : Scheme} (f : X ⟶ Z) (g : Y ⟶ Z) : HasPullback f g :=\n  hasPullback_of_cover (Z.affineCover.pullbackCover f) f g\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.instHasPullbacks","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"⊢ CategoryTheory.Limits.HasPullbacks AlgebraicGeometry.Scheme","decl":"instance : HasPullbacks Scheme :=\n  hasPullbacks_of_hasLimit_cospan _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.isAffine_of_isAffine_isAffine_isAffine","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝² : AlgebraicGeometry.IsAffine X\ninst✝¹ : AlgebraicGeometry.IsAffine Y\ninst✝ : AlgebraicGeometry.IsAffine Z\n⊢ AlgebraicGeometry.IsAffine (CategoryTheory.Limits.pullback f g)","decl":"instance isAffine_of_isAffine_isAffine_isAffine {X Y Z : Scheme}\n    (f : X ⟶ Z) (g : Y ⟶ Z) [IsAffine X] [IsAffine Y] [IsAffine Z] :\n    IsAffine (pullback f g) :=\n  isAffine_of_isIso\n    (pullback.map f g (Spec.map (Γ.map f.op)) (Spec.map (Γ.map g.op))\n        X.toSpecΓ Y.toSpecΓ Z.toSpecΓ\n        (Scheme.toSpecΓ_naturality f) (Scheme.toSpecΓ_naturality g) ≫\n      (PreservesPullback.iso Scheme.Spec _ _).inv)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft 𝒰 f g).J 𝒰.J","decl":"/-- Given an open cover `{ Xᵢ }` of `X`, then `X ×[Z] Y` is covered by `Xᵢ ×[Z] Y`. -/\n@[simps! J obj map]\ndef openCoverOfLeft (𝒰 : OpenCover X) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((gluing 𝒰 f g).openCover.pushforwardIso\n          (limit.isoLimitCone ⟨_, gluedIsLimit 𝒰 f g⟩).inv).copy\n      𝒰.J (fun i => pullback (𝒰.map i ≫ f) g)\n      (fun i => pullback.map _ _ _ _ (𝒰.map i) (𝟙 _) (𝟙 _) (Category.comp_id _) (by simp))\n      (Equiv.refl 𝒰.J) fun _ => Iso.refl _\n  rintro (i : 𝒰.J)\n  simp_rw [Cover.pushforwardIso_J, Cover.pushforwardIso_map, GlueData.openCover_map,\n    GlueData.openCover_J, gluing_J]\n  exact pullback.hom_ext (by simp [p1]) (by simp [p2])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft 𝒰 f g).map i) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g f g (𝒰.map i) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯)","decl":"/-- Given an open cover `{ Xᵢ }` of `X`, then `X ×[Z] Y` is covered by `Xᵢ ×[Z] Y`. -/\n@[simps! J obj map]\ndef openCoverOfLeft (𝒰 : OpenCover X) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((gluing 𝒰 f g).openCover.pushforwardIso\n          (limit.isoLimitCone ⟨_, gluedIsLimit 𝒰 f g⟩).inv).copy\n      𝒰.J (fun i => pullback (𝒰.map i ≫ f) g)\n      (fun i => pullback.map _ _ _ _ (𝒰.map i) (𝟙 _) (𝟙 _) (Category.comp_id _) (by simp))\n      (Equiv.refl 𝒰.J) fun _ => Iso.refl _\n  rintro (i : 𝒰.J)\n  simp_rw [Cover.pushforwardIso_J, Cover.pushforwardIso_map, GlueData.openCover_map,\n    GlueData.openCover_J, gluing_J]\n  exact pullback.hom_ext (by simp [p1]) (by simp [p2])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft_obj","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft 𝒰 f g).obj i) (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (𝒰.map i) f) g)","decl":"/-- Given an open cover `{ Xᵢ }` of `X`, then `X ×[Z] Y` is covered by `Xᵢ ×[Z] Y`. -/\n@[simps! J obj map]\ndef openCoverOfLeft (𝒰 : OpenCover X) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((gluing 𝒰 f g).openCover.pushforwardIso\n          (limit.isoLimitCone ⟨_, gluedIsLimit 𝒰 f g⟩).inv).copy\n      𝒰.J (fun i => pullback (𝒰.map i ≫ f) g)\n      (fun i => pullback.map _ _ _ _ (𝒰.map i) (𝟙 _) (𝟙 _) (Category.comp_id _) (by simp))\n      (Equiv.refl 𝒰.J) fun _ => Iso.refl _\n  rintro (i : 𝒰.J)\n  simp_rw [Cover.pushforwardIso_J, Cover.pushforwardIso_map, GlueData.openCover_map,\n    GlueData.openCover_J, gluing_J]\n  exact pullback.hom_ext (by simp [p1]) (by simp [p2])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfRight_obj","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfRight 𝒰 f g).obj i) (CategoryTheory.Limits.pullback f (CategoryTheory.CategoryStruct.comp (𝒰.map i) g))","decl":"/-- Given an open cover `{ Yᵢ }` of `Y`, then `X ×[Z] Y` is covered by `X ×[Z] Yᵢ`. -/\n@[simps! J obj map]\ndef openCoverOfRight (𝒰 : OpenCover Y) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((openCoverOfLeft 𝒰 g f).pushforwardIso (pullbackSymmetry _ _).hom).copy 𝒰.J\n      (fun i => pullback f (𝒰.map i ≫ g))\n      (fun i => pullback.map _ _ _ _ (𝟙 _) (𝒰.map i) (𝟙 _) (by simp) (Category.comp_id _))\n      (Equiv.refl _) fun i => pullbackSymmetry _ _\n  intro i\n  dsimp [Cover.bind]\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfRight_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfRight 𝒰 f g).map i) (CategoryTheory.Limits.pullback.map f (CategoryTheory.CategoryStruct.comp (𝒰.map i) g) f g (CategoryTheory.CategoryStruct.id X) (𝒰.map i) (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯)","decl":"/-- Given an open cover `{ Yᵢ }` of `Y`, then `X ×[Z] Y` is covered by `X ×[Z] Yᵢ`. -/\n@[simps! J obj map]\ndef openCoverOfRight (𝒰 : OpenCover Y) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((openCoverOfLeft 𝒰 g f).pushforwardIso (pullbackSymmetry _ _).hom).copy 𝒰.J\n      (fun i => pullback f (𝒰.map i ≫ g))\n      (fun i => pullback.map _ _ _ _ (𝟙 _) (𝒰.map i) (𝟙 _) (by simp) (Category.comp_id _))\n      (Equiv.refl _) fun i => pullbackSymmetry _ _\n  intro i\n  dsimp [Cover.bind]\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfRight_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.openCoverOfRight 𝒰 f g).J 𝒰.J","decl":"/-- Given an open cover `{ Yᵢ }` of `Y`, then `X ×[Z] Y` is covered by `X ×[Z] Yᵢ`. -/\n@[simps! J obj map]\ndef openCoverOfRight (𝒰 : OpenCover Y) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  fapply\n    ((openCoverOfLeft 𝒰 g f).pushforwardIso (pullbackSymmetry _ _).hom).copy 𝒰.J\n      (fun i => pullback f (𝒰.map i ≫ g))\n      (fun i => pullback.map _ _ _ _ (𝟙 _) (𝒰.map i) (𝟙 _) (by simp) (Category.comp_id _))\n      (Equiv.refl _) fun i => pullbackSymmetry _ _\n  intro i\n  dsimp [Cover.bind]\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight_obj","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰X : X.OpenCover\n𝒰Y : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nij : Prod 𝒰X.J 𝒰Y.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight 𝒰X 𝒰Y f g).obj ij) (CategoryTheory.Limits.pullback (CategoryTheory.CategoryStruct.comp (𝒰X.map ij.1) f) (CategoryTheory.CategoryStruct.comp (𝒰Y.map ij.2) g))","decl":"/-- Given an open cover `{ Xᵢ }` of `X` and an open cover `{ Yⱼ }` of `Y`, then\n`X ×[Z] Y` is covered by `Xᵢ ×[Z] Yⱼ`. -/\n@[simps! J obj map]\ndef openCoverOfLeftRight (𝒰X : X.OpenCover) (𝒰Y : Y.OpenCover) (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullback f g).OpenCover := by\n  fapply\n    ((openCoverOfLeft 𝒰X f g).bind fun x => openCoverOfRight 𝒰Y (𝒰X.map x ≫ f) g).copy\n      (𝒰X.J × 𝒰Y.J) (fun ij => pullback (𝒰X.map ij.1 ≫ f) (𝒰Y.map ij.2 ≫ g))\n      (fun ij =>\n        pullback.map _ _ _ _ (𝒰X.map ij.1) (𝒰Y.map ij.2) (𝟙 _) (Category.comp_id _)\n          (Category.comp_id _))\n      (Equiv.sigmaEquivProd _ _).symm fun _ => Iso.refl _\n  rintro ⟨i, j⟩\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰X : X.OpenCover\n𝒰Y : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight 𝒰X 𝒰Y f g).J (Prod 𝒰X.J 𝒰Y.J)","decl":"/-- Given an open cover `{ Xᵢ }` of `X` and an open cover `{ Yⱼ }` of `Y`, then\n`X ×[Z] Y` is covered by `Xᵢ ×[Z] Yⱼ`. -/\n@[simps! J obj map]\ndef openCoverOfLeftRight (𝒰X : X.OpenCover) (𝒰Y : Y.OpenCover) (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullback f g).OpenCover := by\n  fapply\n    ((openCoverOfLeft 𝒰X f g).bind fun x => openCoverOfRight 𝒰Y (𝒰X.map x ≫ f) g).copy\n      (𝒰X.J × 𝒰Y.J) (fun ij => pullback (𝒰X.map ij.1 ≫ f) (𝒰Y.map ij.2 ≫ g))\n      (fun ij =>\n        pullback.map _ _ _ _ (𝒰X.map ij.1) (𝒰Y.map ij.2) (𝟙 _) (Category.comp_id _)\n          (Category.comp_id _))\n      (Equiv.sigmaEquivProd _ _).symm fun _ => Iso.refl _\n  rintro ⟨i, j⟩\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰X : X.OpenCover\n𝒰Y : Y.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nij : Prod 𝒰X.J 𝒰Y.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight 𝒰X 𝒰Y f g).map ij) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (𝒰X.map ij.1) f) (CategoryTheory.CategoryStruct.comp (𝒰Y.map ij.2) g) f g (𝒰X.map ij.1) (𝒰Y.map ij.2) (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯)","decl":"/-- Given an open cover `{ Xᵢ }` of `X` and an open cover `{ Yⱼ }` of `Y`, then\n`X ×[Z] Y` is covered by `Xᵢ ×[Z] Yⱼ`. -/\n@[simps! J obj map]\ndef openCoverOfLeftRight (𝒰X : X.OpenCover) (𝒰Y : Y.OpenCover) (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullback f g).OpenCover := by\n  fapply\n    ((openCoverOfLeft 𝒰X f g).bind fun x => openCoverOfRight 𝒰Y (𝒰X.map x ≫ f) g).copy\n      (𝒰X.J × 𝒰Y.J) (fun ij => pullback (𝒰X.map ij.1 ≫ f) (𝒰Y.map ij.2 ≫ g))\n      (fun ij =>\n        pullback.map _ _ _ _ (𝒰X.map ij.1) (𝒰Y.map ij.2) (𝟙 _) (Category.comp_id _)\n          (Category.comp_id _))\n      (Equiv.sigmaEquivProd _ _).symm fun _ => Iso.refl _\n  rintro ⟨i, j⟩\n  apply pullback.hom_ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfBase'_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : Z.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : Sigma fun i => ((fun i => AlgebraicGeometry.Scheme.coverOfIsIso (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (CategoryTheory.Limits.pullback.snd f (𝒰.map i)) (CategoryTheory.Limits.pullback.snd g (𝒰.map i))).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone { cone := ⋯.cone, isLimit := ⋯.isLimit }).inv (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f (𝒰.map i)) (𝒰.map i)) g (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 f).map i) f) g (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback f (𝒰.map i))) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯)))) i).J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfBase' 𝒰 f g).map x) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackSymmetry (CategoryTheory.Limits.pullback.snd f (𝒰.map x.fst)) (CategoryTheory.Limits.pullback.snd g (𝒰.map x.fst))).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.isoLimitCone { cone := ⋯.cone, isLimit := ⋯.isLimit }).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f (𝒰.map x.fst)) (𝒰.map x.fst)) g (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f (𝒰.map x.fst)) f) g (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback f (𝒰.map x.fst))) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f (𝒰.map x.fst)) f) g f g (CategoryTheory.Limits.pullback.fst f (𝒰.map x.fst)) (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Z) ⋯ ⋯))))","decl":"/-- (Implementation). Use `openCoverOfBase` instead. -/\n@[simps! map]\ndef openCoverOfBase' (𝒰 : OpenCover Z) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  apply (openCoverOfLeft (𝒰.pullbackCover f) f g).bind\n  intro i\n  haveI := ((IsPullback.of_hasPullback (pullback.snd g (𝒰.map i))\n    (pullback.snd f (𝒰.map i))).paste_horiz (IsPullback.of_hasPullback _ _)).flip\n  refine\n    @coverOfIsIso _ _ _ _ _\n      (f := (pullbackSymmetry (pullback.snd f (𝒰.map i)) (pullback.snd g (𝒰.map i))).hom ≫\n        (limit.isoLimitCone ⟨_, this.isLimit⟩).inv ≫\n        pullback.map _ _ _ _ (𝟙 _) (𝟙 _) (𝟙 _) ?_ ?_) inferInstance\n  · simp [← pullback.condition]\n  · simp only [Category.comp_id, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfBase_J","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : Z.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.openCoverOfBase 𝒰 f g).J 𝒰.J","decl":"/-- Given an open cover `{ Zᵢ }` of `Z`, then `X ×[Z] Y` is covered by `Xᵢ ×[Zᵢ] Yᵢ`, where\n  `Xᵢ = X ×[Z] Zᵢ` and `Yᵢ = Y ×[Z] Zᵢ` is the preimage of `Zᵢ` in `X` and `Y`. -/\n@[simps! J obj map]\ndef openCoverOfBase (𝒰 : OpenCover Z) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  apply\n    (openCoverOfBase'.{u, u} 𝒰 f g).copy 𝒰.J\n      (fun i =>\n        pullback (pullback.snd _ _ : pullback f (𝒰.map i) ⟶ _)\n          (pullback.snd _ _ : pullback g (𝒰.map i) ⟶ _))\n      (fun i =>\n        pullback.map _ _ _ _ (pullback.fst _ _) (pullback.fst _ _) (𝒰.map i)\n          pullback.condition.symm pullback.condition.symm)\n      ((Equiv.prodPUnit 𝒰.J).symm.trans (Equiv.sigmaEquivProd 𝒰.J PUnit).symm) fun _ => Iso.refl _\n  intro i\n  rw [Iso.refl_hom, Category.id_comp, openCoverOfBase'_map]\n  ext : 1 <;>\n  · simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app, Equiv.trans_apply,\n      Equiv.prodPUnit_symm_apply, Category.assoc, limit.lift_π_assoc, cospan_left, Category.comp_id,\n      limit.isoLimitCone_inv_π_assoc, PullbackCone.π_app_left, IsPullback.cone_fst,\n      pullbackSymmetry_hom_comp_snd_assoc, limit.isoLimitCone_inv_π,\n      PullbackCone.π_app_right, IsPullback.cone_snd, pullbackSymmetry_hom_comp_fst_assoc]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfBase_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : Z.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfBase 𝒰 f g).map i) (CategoryTheory.Limits.pullback.map (CategoryTheory.Limits.pullback.snd f (𝒰.map i)) (CategoryTheory.Limits.pullback.snd g (𝒰.map i)) f g (CategoryTheory.Limits.pullback.fst f (𝒰.map i)) (CategoryTheory.Limits.pullback.fst g (𝒰.map i)) (𝒰.map i) ⋯ ⋯)","decl":"/-- Given an open cover `{ Zᵢ }` of `Z`, then `X ×[Z] Y` is covered by `Xᵢ ×[Zᵢ] Yᵢ`, where\n  `Xᵢ = X ×[Z] Zᵢ` and `Yᵢ = Y ×[Z] Zᵢ` is the preimage of `Zᵢ` in `X` and `Y`. -/\n@[simps! J obj map]\ndef openCoverOfBase (𝒰 : OpenCover Z) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  apply\n    (openCoverOfBase'.{u, u} 𝒰 f g).copy 𝒰.J\n      (fun i =>\n        pullback (pullback.snd _ _ : pullback f (𝒰.map i) ⟶ _)\n          (pullback.snd _ _ : pullback g (𝒰.map i) ⟶ _))\n      (fun i =>\n        pullback.map _ _ _ _ (pullback.fst _ _) (pullback.fst _ _) (𝒰.map i)\n          pullback.condition.symm pullback.condition.symm)\n      ((Equiv.prodPUnit 𝒰.J).symm.trans (Equiv.sigmaEquivProd 𝒰.J PUnit).symm) fun _ => Iso.refl _\n  intro i\n  rw [Iso.refl_hom, Category.id_comp, openCoverOfBase'_map]\n  ext : 1 <;>\n  · simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app, Equiv.trans_apply,\n      Equiv.prodPUnit_symm_apply, Category.assoc, limit.lift_π_assoc, cospan_left, Category.comp_id,\n      limit.isoLimitCone_inv_π_assoc, PullbackCone.π_app_left, IsPullback.cone_fst,\n      pullbackSymmetry_hom_comp_snd_assoc, limit.isoLimitCone_inv_π,\n      PullbackCone.π_app_right, IsPullback.cone_snd, pullbackSymmetry_hom_comp_fst_assoc]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.openCoverOfBase_obj","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\n𝒰 : Z.OpenCover\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ni : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.openCoverOfBase 𝒰 f g).obj i) (CategoryTheory.Limits.pullback (CategoryTheory.Limits.pullback.snd f (𝒰.map i)) (CategoryTheory.Limits.pullback.snd g (𝒰.map i)))","decl":"/-- Given an open cover `{ Zᵢ }` of `Z`, then `X ×[Z] Y` is covered by `Xᵢ ×[Zᵢ] Yᵢ`, where\n  `Xᵢ = X ×[Z] Zᵢ` and `Yᵢ = Y ×[Z] Zᵢ` is the preimage of `Zᵢ` in `X` and `Y`. -/\n@[simps! J obj map]\ndef openCoverOfBase (𝒰 : OpenCover Z) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g) := by\n  apply\n    (openCoverOfBase'.{u, u} 𝒰 f g).copy 𝒰.J\n      (fun i =>\n        pullback (pullback.snd _ _ : pullback f (𝒰.map i) ⟶ _)\n          (pullback.snd _ _ : pullback g (𝒰.map i) ⟶ _))\n      (fun i =>\n        pullback.map _ _ _ _ (pullback.fst _ _) (pullback.fst _ _) (𝒰.map i)\n          pullback.condition.symm pullback.condition.symm)\n      ((Equiv.prodPUnit 𝒰.J).symm.trans (Equiv.sigmaEquivProd 𝒰.J PUnit).symm) fun _ => Iso.refl _\n  intro i\n  rw [Iso.refl_hom, Category.id_comp, openCoverOfBase'_map]\n  ext : 1 <;>\n  · simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app, Equiv.trans_apply,\n      Equiv.prodPUnit_symm_apply, Category.assoc, limit.lift_π_assoc, cospan_left, Category.comp_id,\n      limit.isoLimitCone_inv_π_assoc, PullbackCone.π_app_left, IsPullback.cone_fst,\n      pullbackSymmetry_hom_comp_snd_assoc, limit.isoLimitCone_inv_π,\n      PullbackCone.π_app_right, IsPullback.cone_snd, pullbackSymmetry_hom_comp_fst_assoc]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.diagonalCover_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n𝒰 : Y.OpenCover\n𝒱 : (i : (AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 f).J) → ((AlgebraicGeometry.Scheme.Cover.pullbackCover 𝒰 f).obj i).OpenCover\nI : (AlgebraicGeometry.Scheme.Pullback.diagonalCover f 𝒰 𝒱).J\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.diagonalCover f 𝒰 𝒱).map I) (CategoryTheory.Limits.pullback.map (CategoryTheory.CategoryStruct.comp ((𝒱 I.fst).map I.snd.1) (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰 f I.fst)) (CategoryTheory.CategoryStruct.comp ((𝒱 I.fst).map I.snd.2) (AlgebraicGeometry.Scheme.Cover.pullbackHom 𝒰 f I.fst)) f f (CategoryTheory.CategoryStruct.comp ((𝒱 I.fst).map I.snd.1) (CategoryTheory.Limits.pullback.fst f (𝒰.map I.fst))) (CategoryTheory.CategoryStruct.comp ((𝒱 I.fst).map I.snd.2) (CategoryTheory.Limits.pullback.fst f (𝒰.map I.fst))) (𝒰.map I.fst) ⋯ ⋯)","decl":"lemma diagonalCover_map (I) : (diagonalCover f 𝒰 𝒱).map I =\n    pullback.map _ _ _ _\n    ((𝒱 I.fst).map _ ≫ pullback.fst _ _) ((𝒱 I.fst).map _ ≫ pullback.fst _ _) (𝒰.map _)\n    (by simp)\n    (by simp) := by\n  ext1 <;> simp [diagonalCover, Cover.pullbackHom]\n\n"}
{"name":"AlgebraicGeometry.Scheme.pullback_map_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"X Y S X' Y' S' : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nf' : Quiver.Hom X' S'\ng' : Quiver.Hom Y' S'\ni₁ : Quiver.Hom X X'\ni₂ : Quiver.Hom Y Y'\ni₃ : Quiver.Hom S S'\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₃) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₂ g')\ninst✝² : AlgebraicGeometry.IsOpenImmersion i₁\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion i₂\ninst✝ : CategoryTheory.Mono i₃\n⊢ AlgebraicGeometry.IsOpenImmersion (CategoryTheory.Limits.pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂)","decl":"instance Scheme.pullback_map_isOpenImmersion {X Y S X' Y' S' : Scheme}\n    (f : X ⟶ S) (g : Y ⟶ S) (f' : X' ⟶ S') (g' : Y' ⟶ S')\n    (i₁ : X ⟶ X') (i₂ : Y ⟶ Y') (i₃ : S ⟶ S') (e₁ : f ≫ i₃ = i₁ ≫ f') (e₂ : g ≫ i₃ = i₂ ≫ g')\n    [IsOpenImmersion i₁] [IsOpenImmersion i₂] [Mono i₃] :\n    IsOpenImmersion (pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂) := by\n  rw [pullback_map_eq_pullbackFstFstIso_inv]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_inv_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).inv (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T))))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom))","decl":"/--\nThe composition of the inverse of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S ⟶ Spec R` and `Spec T ⟶ Spec R` to `Spec (S ⊗[R] T)`) with the first projection is\nthe morphism `Spec (S ⊗[R] T) ⟶ Spec S` obtained by applying `Spec.map` to the ring morphism\n`s ↦ s ⊗ₜ[R] 1`.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_inv_fst :\n    (pullbackSpecIso R S T).inv ≫ pullback.fst _ _ = Spec.map (ofHom includeLeftRingHom) :=\n  limit.isoLimitCone_inv_π _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_inv_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of S)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T)))) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom)) h)","decl":"/--\nThe composition of the inverse of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S ⟶ Spec R` and `Spec T ⟶ Spec R` to `Spec (S ⊗[R] T)`) with the first projection is\nthe morphism `Spec (S ⊗[R] T) ⟶ Spec S` obtained by applying `Spec.map` to the ring morphism\n`s ↦ s ⊗ₜ[R] 1`.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_inv_fst :\n    (pullbackSpecIso R S T).inv ≫ pullback.fst _ _ = Spec.map (ofHom includeLeftRingHom) :=\n  limit.isoLimitCone_inv_π _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_inv_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of T)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T)))) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom ↑Algebra.TensorProduct.includeRight)) h)","decl":"/--\nThe composition of the inverse of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S ⟶ Spec R` and `Spec T ⟶ Spec R` to `Spec (S ⊗[R] T)`) with the second projection is\nthe morphism `Spec (S ⊗[R] T) ⟶ Spec T` obtained by applying `Spec.map` to the ring morphism\n`t ↦ 1 ⊗ₜ[R] t`.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_inv_snd :\n    (pullbackSpecIso R S T).inv ≫ pullback.snd _ _ =\n      Spec.map (ofHom (R := T) (S := S ⊗[R] T) (toRingHom includeRight)) :=\n  limit.isoLimitCone_inv_π _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_inv_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).inv (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T))))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom ↑Algebra.TensorProduct.includeRight))","decl":"/--\nThe composition of the inverse of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S ⟶ Spec R` and `Spec T ⟶ Spec R` to `Spec (S ⊗[R] T)`) with the second projection is\nthe morphism `Spec (S ⊗[R] T) ⟶ Spec T` obtained by applying `Spec.map` to the ring morphism\n`t ↦ 1 ⊗ₜ[R] t`.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_inv_snd :\n    (pullbackSpecIso R S T).inv ≫ pullback.snd _ _ =\n      Spec.map (ofHom (R := T) (S := S ⊗[R] T) (toRingHom includeRight)) :=\n  limit.isoLimitCone_inv_π _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_hom_fst","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).hom (AlgebraicGeometry.Spec.map (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom))) (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T))))","decl":"/--\nThe composition of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S ⟶ Spec R` and `Spec T ⟶ Spec R` to `Spec (S ⊗[R] T)`) with the morphism\n`Spec (S ⊗[R] T) ⟶ Spec S` obtained by applying `Spec.map` to the ring morphism `s ↦ s ⊗ₜ[R] 1`\nis the first projection.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_hom_fst :\n    (pullbackSpecIso R S T).hom ≫ Spec.map (ofHom includeLeftRingHom) = pullback.fst _ _ := by\n  rw [← pullbackSpecIso_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_hom_fst_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of S)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom Algebra.TensorProduct.includeLeftRingHom)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T)))) h)","decl":"/--\nThe composition of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S ⟶ Spec R` and `Spec T ⟶ Spec R` to `Spec (S ⊗[R] T)`) with the morphism\n`Spec (S ⊗[R] T) ⟶ Spec S` obtained by applying `Spec.map` to the ring morphism `s ↦ s ⊗ₜ[R] 1`\nis the first projection.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_hom_fst :\n    (pullbackSpecIso R S T).hom ≫ Spec.map (ofHom includeLeftRingHom) = pullback.fst _ _ := by\n  rw [← pullbackSpecIso_inv_fst, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_hom_snd","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).hom (AlgebraicGeometry.Spec.map (CommRingCat.ofHom ↑Algebra.TensorProduct.includeRight))) (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T))))","decl":"/--\nThe composition of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S ⟶ Spec R` and `Spec T ⟶ Spec R` to `Spec (S ⊗[R] T)`) with the morphism\n`Spec (S ⊗[R] T) ⟶ Spec T` obtained by applying `Spec.map` to the ring morphism `t ↦ 1 ⊗ₜ[R] t`\nis the second projection.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_hom_snd :\n    (pullbackSpecIso R S T).hom ≫ Spec.map (ofHom (toRingHom includeRight)) = pullback.snd _ _ := by\n  rw [← pullbackSpecIso_inv_snd, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.pullbackSpecIso_hom_snd_assoc","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S T : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec (CommRingCat.of T)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackSpecIso R S T).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom ↑Algebra.TensorProduct.includeRight)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S))) (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R T)))) h)","decl":"/--\nThe composition of the isomorphism `pullbackSepcIso R S T` (from the pullback of\n`Spec S ⟶ Spec R` and `Spec T ⟶ Spec R` to `Spec (S ⊗[R] T)`) with the morphism\n`Spec (S ⊗[R] T) ⟶ Spec T` obtained by applying `Spec.map` to the ring morphism `t ↦ 1 ⊗ₜ[R] t`\nis the second projection.\n-/\n@[reassoc (attr := simp)]\nlemma pullbackSpecIso_hom_snd :\n    (pullbackSpecIso R S T).hom ≫ Spec.map (ofHom (toRingHom includeRight)) = pullback.snd _ _ := by\n  rw [← pullbackSpecIso_inv_snd, Iso.hom_inv_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.isPullback_Spec_map_isPushout","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"A B C P : CommRingCat\nf : Quiver.Hom A B\ng : Quiver.Hom A C\ninl : Quiver.Hom B P\ninr : Quiver.Hom C P\nh : CategoryTheory.IsPushout f g inl inr\n⊢ CategoryTheory.IsPullback (AlgebraicGeometry.Spec.map inl) (AlgebraicGeometry.Spec.map inr) (AlgebraicGeometry.Spec.map f) (AlgebraicGeometry.Spec.map g)","decl":"lemma isPullback_Spec_map_isPushout {A B C P : CommRingCat} (f : A ⟶ B) (g : A ⟶ C)\n    (inl : B ⟶ P) (inr : C ⟶ P) (h : IsPushout f g inl inr) :\n    IsPullback (Spec.map inl) (Spec.map inr) (Spec.map f) (Spec.map g) :=\n  IsPullback.map Scheme.Spec h.op.flip\n\n"}
{"name":"AlgebraicGeometry.isPullback_Spec_map_pushout","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"A B C : CommRingCat\nf : Quiver.Hom A B\ng : Quiver.Hom A C\n⊢ CategoryTheory.IsPullback (AlgebraicGeometry.Spec.map (CategoryTheory.Limits.pushout.inl f g)) (AlgebraicGeometry.Spec.map (CategoryTheory.Limits.pushout.inr f g)) (AlgebraicGeometry.Spec.map f) (AlgebraicGeometry.Spec.map g)","decl":"lemma isPullback_Spec_map_pushout {A B C : CommRingCat} (f : A ⟶ B) (g : A ⟶ C) :\n    IsPullback (Spec.map (pushout.inl f g))\n      (Spec.map (pushout.inr f g)) (Spec.map f) (Spec.map g) := by\n  apply isPullback_Spec_map_isPushout\n  exact IsPushout.of_hasPushout f g\n\n"}
{"name":"AlgebraicGeometry.diagonal_Spec_map","module":"Mathlib.AlgebraicGeometry.Pullbacks","initialProofState":"R S : Type u\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq (CategoryTheory.Limits.pullback.diagonal (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S)))) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (Algebra.TensorProduct.lmul' R).toRingHom)) (AlgebraicGeometry.pullbackSpecIso R S S).inv)","decl":"lemma diagonal_Spec_map :\n    pullback.diagonal (Spec.map (CommRingCat.ofHom (algebraMap R S))) =\n      Spec.map (CommRingCat.ofHom (Algebra.TensorProduct.lmul' R : S ⊗[R] S →ₐ[R] S).toRingHom) ≫\n        (pullbackSpecIso R S S).inv := by\n  ext1 <;> simp only [pullback.diagonal_fst, pullback.diagonal_snd, ← Spec.map_comp, ← Spec.map_id,\n    AlgHom.toRingHom_eq_coe, Category.assoc, pullbackSpecIso_inv_fst, pullbackSpecIso_inv_snd]\n  · congr 1; ext x; show x = Algebra.TensorProduct.lmul' R (S := S) (x ⊗ₜ[R] 1); simp\n  · congr 1; ext x; show x = Algebra.TensorProduct.lmul' R (S := S) (1 ⊗ₜ[R] x); simp\n\n"}
