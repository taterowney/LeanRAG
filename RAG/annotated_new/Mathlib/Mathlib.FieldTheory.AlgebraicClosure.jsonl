{"name":"algebraicClosure_toSubalgebra","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (algebraicClosure F E).toSubalgebra (integralClosure F E)","decl":"theorem algebraicClosure_toSubalgebra :\n  (algebraicClosure F E).toSubalgebra = integralClosure F E := rfl\n\n"}
{"name":"mem_algebraicClosure_iff'","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\n⊢ Iff (Membership.mem (algebraicClosure F E) x) (IsIntegral F x)","decl":"/-- An element is contained in the algebraic closure of `F` in `E` if and only if\nit is an integral element. -/\ntheorem mem_algebraicClosure_iff' {x : E} :\n    x ∈ algebraicClosure F E ↔ IsIntegral F x := Iff.rfl\n\n"}
{"name":"mem_algebraicClosure_iff","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\n⊢ Iff (Membership.mem (algebraicClosure F E) x) (IsAlgebraic F x)","decl":"/-- An element is contained in the algebraic closure of `F` in `E` if and only if\nit is an algebraic element. -/\ntheorem mem_algebraicClosure_iff {x : E} :\n    x ∈ algebraicClosure F E ↔ IsAlgebraic F x := isAlgebraic_iff_isIntegral.symm\n\n"}
{"name":"map_mem_algebraicClosure_iff","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgHom F E K\nx : E\n⊢ Iff (Membership.mem (algebraicClosure F K) (i x)) (Membership.mem (algebraicClosure F E) x)","decl":"/-- If `i` is an `F`-algebra homomorphism from `E` to `K`, then `i x` is contained in\n`algebraicClosure F K` if and only if `x` is contained in `algebraicClosure F E`. -/\ntheorem map_mem_algebraicClosure_iff (i : E →ₐ[F] K) {x : E} :\n    i x ∈ algebraicClosure F K ↔ x ∈ algebraicClosure F E := by\n  simp_rw [mem_algebraicClosure_iff', ← minpoly.ne_zero_iff, minpoly.algHom_eq i i.injective]\n\n"}
{"name":"algebraicClosure.comap_eq_of_algHom","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgHom F E K\n⊢ Eq (IntermediateField.comap i (algebraicClosure F K)) (algebraicClosure F E)","decl":"/-- If `i` is an `F`-algebra homomorphism from `E` to `K`, then the preimage of\n`algebraicClosure F K` under the map `i` is equal to `algebraicClosure F E`. -/\ntheorem comap_eq_of_algHom (i : E →ₐ[F] K) :\n    (algebraicClosure F K).comap i = algebraicClosure F E := by\n  ext x\n  exact map_mem_algebraicClosure_iff i\n\n"}
{"name":"algebraicClosure.map_le_of_algHom","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgHom F E K\n⊢ LE.le (IntermediateField.map i (algebraicClosure F E)) (algebraicClosure F K)","decl":"/-- If `i` is an `F`-algebra homomorphism from `E` to `K`, then the image of `algebraicClosure F E`\nunder the map `i` is contained in `algebraicClosure F K`. -/\ntheorem map_le_of_algHom (i : E →ₐ[F] K) :\n    (algebraicClosure F E).map i ≤ algebraicClosure F K :=\n  map_le_iff_le_comap.2 (comap_eq_of_algHom i).ge\n\n"}
{"name":"algebraicClosure.map_eq_of_algebraicClosure_eq_bot","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\nh : Eq (algebraicClosure E K) Bot.bot\n⊢ Eq (IntermediateField.map (IsScalarTower.toAlgHom F E K) (algebraicClosure F E)) (algebraicClosure F K)","decl":"variable (F) in\n/-- If `K / E / F` is a field extension tower, such that `K / E` has no non-trivial algebraic\nsubextensions (this means that it is purely transcendental),\nthen the image of `algebraicClosure F E` in `K` is equal to `algebraicClosure F K`. -/\ntheorem map_eq_of_algebraicClosure_eq_bot [Algebra E K] [IsScalarTower F E K]\n    (h : algebraicClosure E K = ⊥) :\n    (algebraicClosure F E).map (IsScalarTower.toAlgHom F E K) = algebraicClosure F K := by\n  refine le_antisymm (map_le_of_algHom _) (fun x hx ↦ ?_)\n  obtain ⟨y, rfl⟩ := mem_bot.1 <| h ▸ mem_algebraicClosure_iff'.2\n    (IsIntegral.tower_top <| mem_algebraicClosure_iff'.1 hx)\n  exact ⟨y, (map_mem_algebraicClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rfl⟩\n\n"}
{"name":"algebraicClosure.map_eq_of_algEquiv","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgEquiv F E K\n⊢ Eq (IntermediateField.map (↑i) (algebraicClosure F E)) (algebraicClosure F K)","decl":"/-- If `i` is an `F`-algebra isomorphism of `E` and `K`, then the image of `algebraicClosure F E`\nunder the map `i` is equal to `algebraicClosure F K`. -/\ntheorem map_eq_of_algEquiv (i : E ≃ₐ[F] K) :\n    (algebraicClosure F E).map i = algebraicClosure F K :=\n  (map_le_of_algHom i.toAlgHom).antisymm\n    (fun x h ↦ ⟨_, (map_mem_algebraicClosure_iff i.symm).2 h, by simp⟩)\n\n"}
{"name":"algebraicClosure.isAlgebraic","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Algebra.IsAlgebraic F (Subtype fun x => Membership.mem (algebraicClosure F E) x)","decl":"/-- The algebraic closure of `F` in `E` is algebraic over `F`. -/\ninstance isAlgebraic : Algebra.IsAlgebraic F (algebraicClosure F E) :=\n  ⟨fun x ↦ isAlgebraic_iff.mpr x.2.isAlgebraic⟩\n\n"}
{"name":"algebraicClosure.isIntegralClosure","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ IsIntegralClosure (Subtype fun x => Membership.mem (algebraicClosure F E) x) F E","decl":"/-- The algebraic closure of `F` in `E` is the integral closure of `F` in `E`. -/\ninstance isIntegralClosure : IsIntegralClosure (algebraicClosure F E) F E :=\n  inferInstanceAs (IsIntegralClosure (integralClosure F E) F E)\n\n"}
{"name":"Transcendental.algebraicClosure","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\na : E\nha : Transcendental F a\n⊢ Transcendental (Subtype fun x => Membership.mem (algebraicClosure F E) x) a","decl":"protected theorem Transcendental.algebraicClosure {a : E} (ha : Transcendental F a) :\n    Transcendental (algebraicClosure F E) a :=\n  ha.extendScalars Subtype.val_injective\n\n"}
{"name":"le_algebraicClosure'","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nL : IntermediateField F E\nhs : ∀ (x : Subtype fun x => Membership.mem L x), IsAlgebraic F x\n⊢ LE.le L (algebraicClosure F E)","decl":"/-- An intermediate field of `E / F` is contained in the algebraic closure of `F` in `E`\nif all of its elements are algebraic over `F`. -/\ntheorem le_algebraicClosure' {L : IntermediateField F E} (hs : ∀ x : L, IsAlgebraic F x) :\n    L ≤ algebraicClosure F E := fun x h ↦ by\n  simpa only [mem_algebraicClosure_iff, IsAlgebraic, ne_eq, ← aeval_algebraMap_eq_zero_iff E,\n    Algebra.id.map_eq_id, RingHom.id_apply, IntermediateField.algebraMap_apply] using hs ⟨x, h⟩\n\n"}
{"name":"le_algebraicClosure","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nL : IntermediateField F E\ninst✝ : Algebra.IsAlgebraic F (Subtype fun x => Membership.mem L x)\n⊢ LE.le L (algebraicClosure F E)","decl":"/-- An intermediate field of `E / F` is contained in the algebraic closure of `F` in `E`\nif it is algebraic over `F`. -/\ntheorem le_algebraicClosure (L : IntermediateField F E) [Algebra.IsAlgebraic F L] :\n    L ≤ algebraicClosure F E := le_algebraicClosure' F E (Algebra.IsAlgebraic.isAlgebraic)\n\n"}
{"name":"le_algebraicClosure_iff","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nL : IntermediateField F E\n⊢ Iff (LE.le L (algebraicClosure F E)) (Algebra.IsAlgebraic F (Subtype fun x => Membership.mem L x))","decl":"/-- An intermediate field of `E / F` is contained in the algebraic closure of `F` in `E`\nif and only if it is algebraic over `F`. -/\ntheorem le_algebraicClosure_iff (L : IntermediateField F E) :\n    L ≤ algebraicClosure F E ↔ Algebra.IsAlgebraic F L :=\n  ⟨fun h ↦ ⟨fun x ↦ by simpa only [IsAlgebraic, ne_eq, ← aeval_algebraMap_eq_zero_iff E,\n    IntermediateField.algebraMap_apply,\n    Algebra.id.map_eq_id, RingHomCompTriple.comp_apply, mem_algebraicClosure_iff] using h x.2⟩,\n    fun _ ↦ le_algebraicClosure _ _ _⟩\n\n"}
{"name":"algebraicClosure.algebraicClosure_eq_bot","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (algebraicClosure (Subtype fun x => Membership.mem (algebraicClosure F E) x) E) Bot.bot","decl":"/-- The algebraic closure in `E` of the algebraic closure of `F` in `E` is equal to itself. -/\ntheorem algebraicClosure_eq_bot :\n    algebraicClosure (algebraicClosure F E) E = ⊥ :=\n  bot_unique fun x hx ↦ mem_bot.2\n    ⟨⟨x, isIntegral_trans x (mem_algebraicClosure_iff'.1 hx)⟩, rfl⟩\n\n"}
{"name":"algebraicClosure.normalClosure_eq_self","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (normalClosure F (Subtype fun x => Membership.mem (algebraicClosure F E) x) E) (algebraicClosure F E)","decl":"/-- The normal closure in `E/F` of the algebraic closure of `F` in `E` is equal to itself. -/\ntheorem normalClosure_eq_self :\n    normalClosure F (algebraicClosure F E) E = algebraicClosure F E :=\n  le_antisymm (normalClosure_le_iff.2 fun i ↦\n    haveI : Algebra.IsAlgebraic F i.fieldRange := (AlgEquiv.ofInjectiveField i).isAlgebraic\n    le_algebraicClosure F E _) (le_normalClosure _)\n\n"}
{"name":"IsAlgClosed.algebraicClosure_eq_bot_iff","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsAlgClosed E\n⊢ Iff (Eq (algebraicClosure F E) Bot.bot) (IsAlgClosed F)","decl":"/-- If `E / F` is a field extension and `E` is algebraically closed, then the algebraic closure\nof `F` in `E` is equal to `F` if and only if `F` is algebraically closed. -/\ntheorem IsAlgClosed.algebraicClosure_eq_bot_iff [IsAlgClosed E] :\n    algebraicClosure F E = ⊥ ↔ IsAlgClosed F := by\n  refine ⟨fun h ↦ IsAlgClosed.of_exists_root _ fun p hmon hirr ↦ ?_,\n    fun _ ↦ IntermediateField.eq_bot_of_isAlgClosed_of_isAlgebraic _⟩\n  obtain ⟨x, hx⟩ := IsAlgClosed.exists_aeval_eq_zero E p (degree_pos_of_irreducible hirr).ne'\n  obtain ⟨x, rfl⟩ := h ▸ mem_algebraicClosure_iff'.2 (minpoly.ne_zero_iff.1 <|\n    ne_zero_of_dvd_ne_zero hmon.ne_zero (minpoly.dvd _ x hx))\n  exact ⟨x, by simpa [Algebra.ofId_apply] using hx⟩\n\n"}
{"name":"IntermediateField.isAlgebraic_adjoin_iff_isAlgebraic","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nS : Set E\n⊢ Iff (Algebra.IsAlgebraic F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x)) (∀ (x : E), Membership.mem S x → IsAlgebraic F x)","decl":"/-- `F(S) / F` is a algebraic extension if and only if all elements of `S` are\nalgebraic elements. -/\ntheorem IntermediateField.isAlgebraic_adjoin_iff_isAlgebraic {S : Set E} :\n    Algebra.IsAlgebraic F (adjoin F S) ↔ ∀ x ∈ S, IsAlgebraic F x :=\n  ((le_algebraicClosure_iff F E _).symm.trans (adjoin_le_iff.trans <| forall_congr' <|\n    fun _ => Iff.imp Iff.rfl mem_algebraicClosure_iff))\n\n"}
{"name":"algebraicClosure.isAlgClosure","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsAlgClosed E\n⊢ IsAlgClosure F (Subtype fun x => Membership.mem (algebraicClosure F E) x)","decl":"/-- If `E` is algebraically closed, then the algebraic closure of `F` in `E` is an absolute\nalgebraic closure of `F`. -/\ninstance isAlgClosure [IsAlgClosed E] : IsAlgClosure F (algebraicClosure F E) :=\n  ⟨(IsAlgClosed.algebraicClosure_eq_bot_iff _ E).mp (algebraicClosure_eq_bot F E),\n    isAlgebraic F E⟩\n\n"}
{"name":"algebraicClosure.eq_top_iff","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Iff (Eq (algebraicClosure F E) Top.top) (Algebra.IsAlgebraic F E)","decl":"/-- The algebraic closure of `F` in `E` is equal to `E` if and only if `E / F` is\nalgebraic. -/\ntheorem eq_top_iff : algebraicClosure F E = ⊤ ↔ Algebra.IsAlgebraic F E :=\n  ⟨fun h ↦ ⟨fun _ ↦ mem_algebraicClosure_iff.1 (h ▸ mem_top)⟩,\n    fun _ ↦ top_unique fun x _ ↦ mem_algebraicClosure_iff.2 (Algebra.IsAlgebraic.isAlgebraic x)⟩\n\n"}
{"name":"algebraicClosure.le_restrictScalars","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ LE.le (algebraicClosure F K) (IntermediateField.restrictScalars F (algebraicClosure E K))","decl":"/-- If `K / E / F` is a field extension tower, then `algebraicClosure F K` is contained in\n`algebraicClosure E K`. -/\ntheorem le_restrictScalars [Algebra E K] [IsScalarTower F E K] :\n    algebraicClosure F K ≤ (algebraicClosure E K).restrictScalars F :=\n  fun _ h ↦ mem_algebraicClosure_iff.2 <| IsAlgebraic.tower_top E (mem_algebraicClosure_iff.1 h)\n\n"}
{"name":"algebraicClosure.eq_restrictScalars_of_isAlgebraic","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Eq (algebraicClosure F K) (IntermediateField.restrictScalars F (algebraicClosure E K))","decl":"/-- If `K / E / F` is a field extension tower, such that `E / F` is algebraic, then\n`algebraicClosure F K` is equal to `algebraicClosure E K`. -/\ntheorem eq_restrictScalars_of_isAlgebraic [Algebra E K] [IsScalarTower F E K]\n    [Algebra.IsAlgebraic F E] : algebraicClosure F K = (algebraicClosure E K).restrictScalars F :=\n  (algebraicClosure.le_restrictScalars F E K).antisymm fun _ h ↦\n    isIntegral_trans _ h\n\n"}
{"name":"algebraicClosure.adjoin_le","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ LE.le (IntermediateField.adjoin E ↑(algebraicClosure F K)) (algebraicClosure E K)","decl":"/-- If `K / E / F` is a field extension tower, then `E` adjoin `algebraicClosure F K` is contained\nin `algebraicClosure E K`. -/\ntheorem adjoin_le [Algebra E K] [IsScalarTower F E K] :\n    adjoin E (algebraicClosure F K) ≤ algebraicClosure E K :=\n  adjoin_le_iff.2 <| le_restrictScalars F E K\n\n"}
{"name":"Splits.algebraicClosure","module":"Mathlib.FieldTheory.AlgebraicClosure","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\np : Polynomial F\nh : Polynomial.Splits (algebraMap F E) p\n⊢ Polynomial.Splits (algebraMap F (Subtype fun x => Membership.mem (algebraicClosure F E) x)) p","decl":"/--\nLet `E / F` be a field extension. If a polynomial `p`\nsplits in `E`, then it splits in the relative algebraic closure of `F` in `E` already.\n-/\ntheorem Splits.algebraicClosure {p : F[X]} (h : p.Splits (algebraMap F E)) :\n    p.Splits (algebraMap F (algebraicClosure F E)) :=\n  splits_of_splits h fun _ hx ↦ (isAlgebraic_of_mem_rootSet hx).isIntegral\n"}
