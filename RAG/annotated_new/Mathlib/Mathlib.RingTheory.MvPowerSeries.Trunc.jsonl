{"name":"MvPowerSeries.coeff_truncFun","module":"Mathlib.RingTheory.MvPowerSeries.Trunc","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nn m : Finsupp σ Nat\nφ : MvPowerSeries σ R\n⊢ Eq (MvPolynomial.coeff m (MvPowerSeries.truncFun n φ)) (ite (LT.lt m n) ((MvPowerSeries.coeff R m) φ) 0)","decl":"theorem coeff_truncFun (m : σ →₀ ℕ) (φ : MvPowerSeries σ R) :\n    (truncFun n φ).coeff m = if m < n then coeff R m φ else 0 := by\n  classical\n  simp [truncFun, MvPolynomial.coeff_sum]\n\n"}
{"name":"MvPowerSeries.coeff_trunc","module":"Mathlib.RingTheory.MvPowerSeries.Trunc","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nn m : Finsupp σ Nat\nφ : MvPowerSeries σ R\n⊢ Eq (MvPolynomial.coeff m ((MvPowerSeries.trunc R n) φ)) (ite (LT.lt m n) ((MvPowerSeries.coeff R m) φ) 0)","decl":"theorem coeff_trunc (m : σ →₀ ℕ) (φ : MvPowerSeries σ R) :\n    (trunc R n φ).coeff m = if m < n then coeff R m φ else 0 := by\n  classical simp [trunc, coeff_truncFun]\n\n"}
{"name":"MvPowerSeries.trunc_one","module":"Mathlib.RingTheory.MvPowerSeries.Trunc","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nn : Finsupp σ Nat\nhnn : Ne n 0\n⊢ Eq ((MvPowerSeries.trunc R n) 1) 1","decl":"@[simp]\ntheorem trunc_one (n : σ →₀ ℕ) (hnn : n ≠ 0) : trunc R n 1 = 1 :=\n  MvPolynomial.ext _ _ fun m => by\n    classical\n    rw [coeff_trunc, coeff_one]\n    split_ifs with H H'\n    · subst m\n      simp\n    · symm\n      rw [MvPolynomial.coeff_one]\n      exact if_neg (Ne.symm H')\n    · symm\n      rw [MvPolynomial.coeff_one]\n      refine if_neg ?_\n      rintro rfl\n      apply H\n      exact Ne.bot_lt hnn\n\n"}
{"name":"MvPowerSeries.trunc_c","module":"Mathlib.RingTheory.MvPowerSeries.Trunc","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nn : Finsupp σ Nat\nhnn : Ne n 0\na : R\n⊢ Eq ((MvPowerSeries.trunc R n) ((MvPowerSeries.C σ R) a)) (MvPolynomial.C a)","decl":"@[simp]\ntheorem trunc_c (n : σ →₀ ℕ) (hnn : n ≠ 0) (a : R) : trunc R n (C σ R a) = MvPolynomial.C a :=\n  MvPolynomial.ext _ _ fun m => by\n    classical\n    rw [coeff_trunc, coeff_C, MvPolynomial.coeff_C]\n    split_ifs with H <;> first |rfl|try simp_all only [ne_eq, not_true_eq_false]\n    exfalso; apply H; subst m; exact Ne.bot_lt hnn\n\n"}
{"name":"MvPowerSeries.trunc_C_mul","module":"Mathlib.RingTheory.MvPowerSeries.Trunc","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : CommSemiring R\nn : Finsupp σ Nat\na : R\np : MvPowerSeries σ R\n⊢ Eq ((MvPowerSeries.trunc R n) (HMul.hMul ((MvPowerSeries.C σ R) a) p)) (HMul.hMul (MvPolynomial.C a) ((MvPowerSeries.trunc R n) p))","decl":"@[simp]\ntheorem trunc_C_mul (n : σ →₀ ℕ) (a : R) (p : MvPowerSeries σ R) :\n    trunc R n (C σ R a * p) = MvPolynomial.C a * trunc R n p := by\n  ext m; simp [coeff_trunc]\n\n"}
{"name":"MvPowerSeries.trunc_map","module":"Mathlib.RingTheory.MvPowerSeries.Trunc","initialProofState":"σ : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nn : Finsupp σ Nat\nf : RingHom R S\np : MvPowerSeries σ R\n⊢ Eq ((MvPowerSeries.trunc S n) ((MvPowerSeries.map σ f) p)) ((MvPolynomial.map f) ((MvPowerSeries.trunc R n) p))","decl":"@[simp]\ntheorem trunc_map [CommSemiring S] (n : σ →₀ ℕ) (f : R →+* S) (p : MvPowerSeries σ R) :\n    trunc S n (map σ f p) = MvPolynomial.map f (trunc R n p) := by\n  ext m; simp [coeff_trunc, MvPolynomial.coeff_map, apply_ite f]\n\n"}
