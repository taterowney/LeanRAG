{"name":"MvPowerSeries.coeff_inv_aux","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Ring R\ninst✝ : DecidableEq σ\nn : Finsupp σ Nat\na : R\nφ : MvPowerSeries σ R\n⊢ Eq ((MvPowerSeries.coeff R n) (MvPowerSeries.inv.aux a φ)) (ite (Eq n 0) a (HMul.hMul (Neg.neg a) ((Finset.HasAntidiagonal.antidiagonal n).sum fun x => ite (LT.lt x.2 n) (HMul.hMul ((MvPowerSeries.coeff R x.1) φ) ((MvPowerSeries.coeff R x.2) (MvPowerSeries.inv.aux a φ))) 0)))","decl":"theorem coeff_inv_aux [DecidableEq σ] (n : σ →₀ ℕ) (a : R) (φ : MvPowerSeries σ R) :\n    coeff R n (inv.aux a φ) =\n      if n = 0 then a\n      else\n        -a *\n          ∑ x ∈ antidiagonal n, if x.2 < n then coeff R x.1 φ * coeff R x.2 (inv.aux a φ) else 0 :=\n  show inv.aux a φ n = _ by\n    cases Subsingleton.elim ‹DecidableEq σ› (Classical.decEq σ)\n    rw [inv.aux]\n    rfl\n\n"}
{"name":"MvPowerSeries.coeff_invOfUnit","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : Ring R\ninst✝ : DecidableEq σ\nn : Finsupp σ Nat\nφ : MvPowerSeries σ R\nu : Units R\n⊢ Eq ((MvPowerSeries.coeff R n) (φ.invOfUnit u)) (ite (Eq n 0) (↑(Inv.inv u)) (HMul.hMul (Neg.neg ↑(Inv.inv u)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun x => ite (LT.lt x.2 n) (HMul.hMul ((MvPowerSeries.coeff R x.1) φ) ((MvPowerSeries.coeff R x.2) (φ.invOfUnit u))) 0)))","decl":"theorem coeff_invOfUnit [DecidableEq σ] (n : σ →₀ ℕ) (φ : MvPowerSeries σ R) (u : Rˣ) :\n    coeff R n (invOfUnit φ u) =\n      if n = 0 then ↑u⁻¹\n      else\n        -↑u⁻¹ *\n          ∑ x ∈ antidiagonal n,\n            if x.2 < n then coeff R x.1 φ * coeff R x.2 (invOfUnit φ u) else 0 := by\n  convert coeff_inv_aux n (↑u⁻¹) φ\n\n"}
{"name":"MvPowerSeries.constantCoeff_invOfUnit","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Ring R\nφ : MvPowerSeries σ R\nu : Units R\n⊢ Eq ((MvPowerSeries.constantCoeff σ R) (φ.invOfUnit u)) ↑(Inv.inv u)","decl":"@[simp]\ntheorem constantCoeff_invOfUnit (φ : MvPowerSeries σ R) (u : Rˣ) :\n    constantCoeff σ R (invOfUnit φ u) = ↑u⁻¹ := by\n  classical\n  rw [← coeff_zero_eq_constantCoeff_apply, coeff_invOfUnit, if_pos rfl]\n\n"}
{"name":"MvPowerSeries.mul_invOfUnit","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Ring R\nφ : MvPowerSeries σ R\nu : Units R\nh : Eq ((MvPowerSeries.constantCoeff σ R) φ) ↑u\n⊢ Eq (HMul.hMul φ (φ.invOfUnit u)) 1","decl":"@[simp]\ntheorem mul_invOfUnit (φ : MvPowerSeries σ R) (u : Rˣ) (h : constantCoeff σ R φ = u) :\n    φ * invOfUnit φ u = 1 :=\n  ext fun n =>\n    letI := Classical.decEq (σ →₀ ℕ)\n    if H : n = 0 then by\n      rw [H]\n      simp [coeff_mul, support_single_ne_zero, h]\n    else by\n      classical\n      have : ((0 : σ →₀ ℕ), n) ∈ antidiagonal n := by rw [mem_antidiagonal, zero_add]\n      rw [coeff_one, if_neg H, coeff_mul, ← Finset.insert_erase this,\n        Finset.sum_insert (Finset.not_mem_erase _ _), coeff_zero_eq_constantCoeff_apply, h,\n        coeff_invOfUnit, if_neg H, neg_mul, mul_neg, Units.mul_inv_cancel_left, ←\n        Finset.insert_erase this, Finset.sum_insert (Finset.not_mem_erase _ _),\n        Finset.insert_erase this, if_neg (not_lt_of_ge <| le_rfl), zero_add, add_comm, ←\n        sub_eq_add_neg, sub_eq_zero, Finset.sum_congr rfl]\n      rintro ⟨i, j⟩ hij\n      rw [Finset.mem_erase, mem_antidiagonal] at hij\n      cases' hij with h₁ h₂\n      subst n\n      rw [if_pos]\n      suffices 0 + j < i + j by simpa\n      apply add_lt_add_right\n      constructor\n      · intro s\n        exact Nat.zero_le _\n      · intro H\n        apply h₁\n        suffices i = 0 by simp [this]\n        ext1 s\n        exact Nat.eq_zero_of_le_zero (H s)\n\n-- TODO : can one prove equivalence?\n"}
{"name":"MvPowerSeries.invOfUnit_mul","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Ring R\nφ : MvPowerSeries σ R\nu : Units R\nh : Eq ((MvPowerSeries.constantCoeff σ R) φ) ↑u\n⊢ Eq (HMul.hMul (φ.invOfUnit u) φ) 1","decl":"@[simp]\ntheorem invOfUnit_mul (φ : MvPowerSeries σ R) (u : Rˣ) (h : constantCoeff σ R φ = u) :\n    invOfUnit φ u * φ = 1 := by\n  rw [← mul_cancel_right_mem_nonZeroDivisors (r := φ.invOfUnit u), mul_assoc, one_mul,\n    mul_invOfUnit _ _ h, mul_one]\n  apply mem_nonZeroDivisors_of_constantCoeff\n  simp only [constantCoeff_invOfUnit, IsUnit.mem_nonZeroDivisors (Units.isUnit u⁻¹)]\n\n"}
{"name":"MvPowerSeries.isUnit_iff_constantCoeff","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝ : Ring R\nφ : MvPowerSeries σ R\n⊢ Iff (IsUnit φ) (IsUnit ((MvPowerSeries.constantCoeff σ R) φ))","decl":"theorem isUnit_iff_constantCoeff {φ : MvPowerSeries σ R} :\n    IsUnit φ ↔ IsUnit (constantCoeff σ R φ) := by\n  constructor\n  · exact IsUnit.map _\n  · intro ⟨u, hu⟩\n    exact ⟨⟨_, φ.invOfUnit u, mul_invOfUnit φ u hu.symm, invOfUnit_mul φ u hu.symm⟩, rfl⟩\n\n"}
{"name":"MvPowerSeries.instIsLocalRing","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsLocalRing R\n⊢ IsLocalRing (MvPowerSeries σ R)","decl":"/-- Multivariate formal power series over a local ring form a local ring. -/\ninstance [IsLocalRing R] : IsLocalRing (MvPowerSeries σ R) :=\n  IsLocalRing.of_isUnit_or_isUnit_one_sub_self <| by\n    intro φ\n    obtain ⟨u, h⟩ | ⟨u, h⟩ := IsLocalRing.isUnit_or_isUnit_one_sub_self (constantCoeff σ R φ) <;>\n        [left; right] <;>\n      · refine isUnit_of_mul_eq_one _ _ (mul_invOfUnit _ u ?_)\n        simpa using h.symm\n\n-- TODO(jmc): once adic topology lands, show that this is complete\n"}
{"name":"MvPowerSeries.map.isLocalHom","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing S\nf : RingHom R S\ninst✝ : IsLocalHom f\n⊢ IsLocalHom (MvPowerSeries.map σ f)","decl":"/-- The map between multivariate formal power series over the same indexing set\n induced by a local ring hom `A → B` is local -/\n@[instance]\ntheorem map.isLocalHom : IsLocalHom (map σ f) :=\n  ⟨by\n    rintro φ ⟨ψ, h⟩\n    replace h := congr_arg (constantCoeff σ S) h\n    rw [constantCoeff_map] at h\n    have : IsUnit (constantCoeff σ S ↑ψ) := isUnit_constantCoeff _ ψ.isUnit\n    rw [h] at this\n    rcases isUnit_of_map_unit f _ this with ⟨c, hc⟩\n    exact isUnit_of_mul_eq_one φ (invOfUnit φ c) (mul_invOfUnit φ c hc.symm)⟩\n\n"}
{"name":"MvPowerSeries.map.isLocalRingHom","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝² : CommRing R\ninst✝¹ : CommRing S\nf : RingHom R S\ninst✝ : IsLocalHom f\n⊢ IsLocalHom (MvPowerSeries.map σ f)","decl":"@[deprecated (since := \"2024-10-10\")]\nalias map.isLocalRingHom := map.isLocalHom\n\n"}
{"name":"MvPowerSeries.coeff_inv","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝¹ : Field k\ninst✝ : DecidableEq σ\nn : Finsupp σ Nat\nφ : MvPowerSeries σ k\n⊢ Eq ((MvPowerSeries.coeff k n) (Inv.inv φ)) (ite (Eq n 0) (Inv.inv ((MvPowerSeries.constantCoeff σ k) φ)) (HMul.hMul (Neg.neg (Inv.inv ((MvPowerSeries.constantCoeff σ k) φ))) ((Finset.HasAntidiagonal.antidiagonal n).sum fun x => ite (LT.lt x.2 n) (HMul.hMul ((MvPowerSeries.coeff k x.1) φ) ((MvPowerSeries.coeff k x.2) (Inv.inv φ))) 0)))","decl":"theorem coeff_inv [DecidableEq σ] (n : σ →₀ ℕ) (φ : MvPowerSeries σ k) :\n    coeff k n φ⁻¹ =\n      if n = 0 then (constantCoeff σ k φ)⁻¹\n      else\n        -(constantCoeff σ k φ)⁻¹ *\n          ∑ x ∈ antidiagonal n, if x.2 < n then coeff k x.1 φ * coeff k x.2 φ⁻¹ else 0 :=\n  coeff_inv_aux n _ φ\n\n"}
{"name":"MvPowerSeries.constantCoeff_inv","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ : MvPowerSeries σ k\n⊢ Eq ((MvPowerSeries.constantCoeff σ k) (Inv.inv φ)) (Inv.inv ((MvPowerSeries.constantCoeff σ k) φ))","decl":"@[simp]\ntheorem constantCoeff_inv (φ : MvPowerSeries σ k) :\n    constantCoeff σ k φ⁻¹ = (constantCoeff σ k φ)⁻¹ := by\n  classical\n  rw [← coeff_zero_eq_constantCoeff_apply, coeff_inv, if_pos rfl]\n\n"}
{"name":"MvPowerSeries.inv_eq_zero","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ : MvPowerSeries σ k\n⊢ Iff (Eq (Inv.inv φ) 0) (Eq ((MvPowerSeries.constantCoeff σ k) φ) 0)","decl":"theorem inv_eq_zero {φ : MvPowerSeries σ k} : φ⁻¹ = 0 ↔ constantCoeff σ k φ = 0 :=\n  ⟨fun h => by simpa using congr_arg (constantCoeff σ k) h, fun h =>\n    ext fun n => by\n      classical\n      rw [coeff_inv]\n      split_ifs <;>\n        simp only [h, map_zero, zero_mul, inv_zero, neg_zero]⟩\n\n"}
{"name":"MvPowerSeries.zero_inv","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\n⊢ Eq (Inv.inv 0) 0","decl":"@[simp]\ntheorem zero_inv : (0 : MvPowerSeries σ k)⁻¹ = 0 := by\n  rw [inv_eq_zero, constantCoeff_zero]\n\n"}
{"name":"MvPowerSeries.invOfUnit_eq","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ : MvPowerSeries σ k\nh : Ne ((MvPowerSeries.constantCoeff σ k) φ) 0\n⊢ Eq (φ.invOfUnit (Units.mk0 ((MvPowerSeries.constantCoeff σ k) φ) h)) (Inv.inv φ)","decl":"@[simp]\ntheorem invOfUnit_eq (φ : MvPowerSeries σ k) (h : constantCoeff σ k φ ≠ 0) :\n    invOfUnit φ (Units.mk0 _ h) = φ⁻¹ :=\n  rfl\n\n"}
{"name":"MvPowerSeries.invOfUnit_eq'","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ : MvPowerSeries σ k\nu : Units k\nh : Eq ((MvPowerSeries.constantCoeff σ k) φ) ↑u\n⊢ Eq (φ.invOfUnit u) (Inv.inv φ)","decl":"@[simp]\ntheorem invOfUnit_eq' (φ : MvPowerSeries σ k) (u : Units k) (h : constantCoeff σ k φ = u) :\n    invOfUnit φ u = φ⁻¹ := by\n  rw [← invOfUnit_eq φ (h.symm ▸ u.ne_zero)]\n  apply congrArg (invOfUnit φ)\n  rw [Units.ext_iff]\n  exact h.symm\n\n"}
{"name":"MvPowerSeries.mul_inv_cancel","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ : MvPowerSeries σ k\nh : Ne ((MvPowerSeries.constantCoeff σ k) φ) 0\n⊢ Eq (HMul.hMul φ (Inv.inv φ)) 1","decl":"@[simp]\nprotected theorem mul_inv_cancel (φ : MvPowerSeries σ k) (h : constantCoeff σ k φ ≠ 0) :\n    φ * φ⁻¹ = 1 := by rw [← invOfUnit_eq φ h, mul_invOfUnit φ (Units.mk0 _ h) rfl]\n\n"}
{"name":"MvPowerSeries.inv_mul_cancel","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ : MvPowerSeries σ k\nh : Ne ((MvPowerSeries.constantCoeff σ k) φ) 0\n⊢ Eq (HMul.hMul (Inv.inv φ) φ) 1","decl":"@[simp]\nprotected theorem inv_mul_cancel (φ : MvPowerSeries σ k) (h : constantCoeff σ k φ ≠ 0) :\n    φ⁻¹ * φ = 1 := by rw [mul_comm, φ.mul_inv_cancel h]\n\n"}
{"name":"MvPowerSeries.eq_mul_inv_iff_mul_eq","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ₁ φ₂ φ₃ : MvPowerSeries σ k\nh : Ne ((MvPowerSeries.constantCoeff σ k) φ₃) 0\n⊢ Iff (Eq φ₁ (HMul.hMul φ₂ (Inv.inv φ₃))) (Eq (HMul.hMul φ₁ φ₃) φ₂)","decl":"protected theorem eq_mul_inv_iff_mul_eq {φ₁ φ₂ φ₃ : MvPowerSeries σ k}\n    (h : constantCoeff σ k φ₃ ≠ 0) : φ₁ = φ₂ * φ₃⁻¹ ↔ φ₁ * φ₃ = φ₂ :=\n  ⟨fun k => by simp [k, mul_assoc, MvPowerSeries.inv_mul_cancel _ h], fun k => by\n    simp [← k, mul_assoc, MvPowerSeries.mul_inv_cancel _ h]⟩\n\n"}
{"name":"MvPowerSeries.eq_inv_iff_mul_eq_one","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ ψ : MvPowerSeries σ k\nh : Ne ((MvPowerSeries.constantCoeff σ k) ψ) 0\n⊢ Iff (Eq φ (Inv.inv ψ)) (Eq (HMul.hMul φ ψ) 1)","decl":"protected theorem eq_inv_iff_mul_eq_one {φ ψ : MvPowerSeries σ k} (h : constantCoeff σ k ψ ≠ 0) :\n    φ = ψ⁻¹ ↔ φ * ψ = 1 := by rw [← MvPowerSeries.eq_mul_inv_iff_mul_eq h, one_mul]\n\n"}
{"name":"MvPowerSeries.inv_eq_iff_mul_eq_one","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ ψ : MvPowerSeries σ k\nh : Ne ((MvPowerSeries.constantCoeff σ k) ψ) 0\n⊢ Iff (Eq (Inv.inv ψ) φ) (Eq (HMul.hMul φ ψ) 1)","decl":"protected theorem inv_eq_iff_mul_eq_one {φ ψ : MvPowerSeries σ k} (h : constantCoeff σ k ψ ≠ 0) :\n    ψ⁻¹ = φ ↔ φ * ψ = 1 := by rw [eq_comm, MvPowerSeries.eq_inv_iff_mul_eq_one h]\n\n"}
{"name":"MvPowerSeries.mul_inv_rev","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nφ ψ : MvPowerSeries σ k\n⊢ Eq (Inv.inv (HMul.hMul φ ψ)) (HMul.hMul (Inv.inv ψ) (Inv.inv φ))","decl":"@[simp]\nprotected theorem mul_inv_rev (φ ψ : MvPowerSeries σ k) :\n    (φ * ψ)⁻¹ = ψ⁻¹ * φ⁻¹ := by\n  by_cases h : constantCoeff σ k (φ * ψ) = 0\n  · rw [inv_eq_zero.mpr h]\n    simp only [map_mul, mul_eq_zero] at h\n    -- we don't have `NoZeroDivisors (MvPowerSeries σ k)` yet,\n    cases' h with h h <;> simp [inv_eq_zero.mpr h]\n  · rw [MvPowerSeries.inv_eq_iff_mul_eq_one h]\n    simp only [not_or, map_mul, mul_eq_zero] at h\n    rw [← mul_assoc, mul_assoc _⁻¹, MvPowerSeries.inv_mul_cancel _ h.left, mul_one,\n      MvPowerSeries.inv_mul_cancel _ h.right]\n\n"}
{"name":"MvPowerSeries.C_inv","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nr : k\n⊢ Eq (Inv.inv ((MvPowerSeries.C σ k) r)) ((MvPowerSeries.C σ k) (Inv.inv r))","decl":"@[simp]\ntheorem C_inv (r : k) : (C σ k r)⁻¹ = C σ k r⁻¹ := by\n  rcases eq_or_ne r 0 with (rfl | hr)\n  · simp\n  rw [MvPowerSeries.inv_eq_iff_mul_eq_one, ← map_mul, inv_mul_cancel₀ hr, map_one]\n  simpa using hr\n\n"}
{"name":"MvPowerSeries.X_inv","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\ns : σ\n⊢ Eq (Inv.inv (MvPowerSeries.X s)) 0","decl":"@[simp]\ntheorem X_inv (s : σ) : (X s : MvPowerSeries σ k)⁻¹ = 0 := by\n  rw [inv_eq_zero, constantCoeff_X]\n\n"}
{"name":"MvPowerSeries.smul_inv","module":"Mathlib.RingTheory.MvPowerSeries.Inverse","initialProofState":"σ : Type u_1\nk : Type u_3\ninst✝ : Field k\nr : k\nφ : MvPowerSeries σ k\n⊢ Eq (Inv.inv (HSMul.hSMul r φ)) (HSMul.hSMul (Inv.inv r) (Inv.inv φ))","decl":"@[simp]\ntheorem smul_inv (r : k) (φ : MvPowerSeries σ k) : (r • φ)⁻¹ = r⁻¹ • φ⁻¹ := by\n  simp [smul_eq_C_mul, mul_comm]\n\n"}
