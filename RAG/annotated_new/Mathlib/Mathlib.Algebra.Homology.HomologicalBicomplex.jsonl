{"name":"HomologicalComplex₂.toGradedObjectMap_apply","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (HomologicalComplex₂.toGradedObjectMap φ { fst := i₁, snd := i₂ }) ((φ.f i₁).f i₂)","decl":"@[simp]\nlemma toGradedObjectMap_apply {K L : HomologicalComplex₂ C c₁ c₂} (φ : K ⟶ L) (i₁ : I₁) (i₂ : I₂) :\n    toGradedObjectMap φ ⟨i₁, i₂⟩ = (φ.f i₁).f i₂ := rfl\n\n"}
{"name":"HomologicalComplex₂.toGradedObjectFunctor_obj","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\n⊢ Eq ((HomologicalComplex₂.toGradedObjectFunctor C c₁ c₂).obj K) K.toGradedObject","decl":"variable (C c₁ c₂) in\n/-- The functor which sends a bicomplex to its associated graded object. -/\n@[simps]\ndef toGradedObjectFunctor : HomologicalComplex₂ C c₁ c₂ ⥤ GradedObject (I₁ × I₂) C where\n  obj K := K.toGradedObject\n  map φ := toGradedObjectMap φ\n\n"}
{"name":"HomologicalComplex₂.toGradedObjectFunctor_map","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nX✝ Y✝ : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom X✝ Y✝\ni : Prod I₁ I₂\n⊢ Eq ((HomologicalComplex₂.toGradedObjectFunctor C c₁ c₂).map φ i) (HomologicalComplex₂.toGradedObjectMap φ i)","decl":"variable (C c₁ c₂) in\n/-- The functor which sends a bicomplex to its associated graded object. -/\n@[simps]\ndef toGradedObjectFunctor : HomologicalComplex₂ C c₁ c₂ ⥤ GradedObject (I₁ × I₂) C where\n  obj K := K.toGradedObject\n  map φ := toGradedObjectMap φ\n\n"}
{"name":"HomologicalComplex₂.instFaithfulGradedObjectProdToGradedObjectFunctor","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\n⊢ (HomologicalComplex₂.toGradedObjectFunctor C c₁ c₂).Faithful","decl":"instance : (toGradedObjectFunctor C c₁ c₂).Faithful where\n  map_injective {_ _ φ₁ φ₂} h := by\n    ext i₁ i₂\n    exact congr_fun h ⟨i₁, i₂⟩\n\n"}
{"name":"HomologicalComplex₂.ofGradedObject_X_X","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nX : CategoryTheory.GradedObject (Prod I₁ I₂) C\nd₁ : (i₁ i₁' : I₁) → (i₂ : I₂) → Quiver.Hom (X { fst := i₁, snd := i₂ }) (X { fst := i₁', snd := i₂ })\nd₂ : (i₁ : I₁) → (i₂ i₂' : I₂) → Quiver.Hom (X { fst := i₁, snd := i₂ }) (X { fst := i₁, snd := i₂' })\nshape₂ : ∀ (i₁ : I₁) (i₂ i₂' : I₂), Not (c₂.Rel i₂ i₂') → Eq (d₂ i₁ i₂ i₂') 0\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (((HomologicalComplex₂.ofGradedObject c₁ c₂ X d₁ d₂ shape₂).X i₁).X i₂) (X { fst := i₁, snd := i₂ })","decl":"/-- Constructor for bicomplexes taking as inputs a graded object, horizontal differentials\nand vertical differentials satisfying suitable relations. -/\n@[simps]\ndef ofGradedObject :\n    HomologicalComplex₂ C c₁ c₂ where\n  X i₁ :=\n    { X := fun i₂ => X ⟨i₁, i₂⟩\n      d := fun i₂ i₂' => d₂ i₁ i₂ i₂'\n      shape := shape₂ i₁\n      d_comp_d' := by intros; apply d₂_comp_d₂ }\n  d i₁ i₁' :=\n    { f := fun i₂ => d₁ i₁ i₁' i₂\n      comm' := by intros; apply comm }\n  shape i₁ i₁' h := by\n    ext i₂\n    exact shape₁ i₁ i₁' h i₂\n  d_comp_d' i₁ i₁' i₁'' _ _ := by ext i₂; apply d₁_comp_d₁\n\n"}
{"name":"HomologicalComplex₂.ofGradedObject_d_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nX : CategoryTheory.GradedObject (Prod I₁ I₂) C\nd₁ : (i₁ i₁' : I₁) → (i₂ : I₂) → Quiver.Hom (X { fst := i₁, snd := i₂ }) (X { fst := i₁', snd := i₂ })\nd₂ : (i₁ : I₁) → (i₂ i₂' : I₂) → Quiver.Hom (X { fst := i₁, snd := i₂ }) (X { fst := i₁, snd := i₂' })\nshape₂ : ∀ (i₁ : I₁) (i₂ i₂' : I₂), Not (c₂.Rel i₂ i₂') → Eq (d₂ i₁ i₂ i₂') 0\ni₁ i₁' : I₁\ni₂ : I₂\n⊢ Eq (((HomologicalComplex₂.ofGradedObject c₁ c₂ X d₁ d₂ shape₂).d i₁ i₁').f i₂) (d₁ i₁ i₁' i₂)","decl":"/-- Constructor for bicomplexes taking as inputs a graded object, horizontal differentials\nand vertical differentials satisfying suitable relations. -/\n@[simps]\ndef ofGradedObject :\n    HomologicalComplex₂ C c₁ c₂ where\n  X i₁ :=\n    { X := fun i₂ => X ⟨i₁, i₂⟩\n      d := fun i₂ i₂' => d₂ i₁ i₂ i₂'\n      shape := shape₂ i₁\n      d_comp_d' := by intros; apply d₂_comp_d₂ }\n  d i₁ i₁' :=\n    { f := fun i₂ => d₁ i₁ i₁' i₂\n      comm' := by intros; apply comm }\n  shape i₁ i₁' h := by\n    ext i₂\n    exact shape₁ i₁ i₁' h i₂\n  d_comp_d' i₁ i₁' i₁'' _ _ := by ext i₂; apply d₁_comp_d₁\n\n"}
{"name":"HomologicalComplex₂.ofGradedObject_X_d","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nX : CategoryTheory.GradedObject (Prod I₁ I₂) C\nd₁ : (i₁ i₁' : I₁) → (i₂ : I₂) → Quiver.Hom (X { fst := i₁, snd := i₂ }) (X { fst := i₁', snd := i₂ })\nd₂ : (i₁ : I₁) → (i₂ i₂' : I₂) → Quiver.Hom (X { fst := i₁, snd := i₂ }) (X { fst := i₁, snd := i₂' })\nshape₂ : ∀ (i₁ : I₁) (i₂ i₂' : I₂), Not (c₂.Rel i₂ i₂') → Eq (d₂ i₁ i₂ i₂') 0\ni₁ : I₁\ni₂ i₂' : I₂\n⊢ Eq (((HomologicalComplex₂.ofGradedObject c₁ c₂ X d₁ d₂ shape₂).X i₁).d i₂ i₂') (d₂ i₁ i₂ i₂')","decl":"/-- Constructor for bicomplexes taking as inputs a graded object, horizontal differentials\nand vertical differentials satisfying suitable relations. -/\n@[simps]\ndef ofGradedObject :\n    HomologicalComplex₂ C c₁ c₂ where\n  X i₁ :=\n    { X := fun i₂ => X ⟨i₁, i₂⟩\n      d := fun i₂ i₂' => d₂ i₁ i₂ i₂'\n      shape := shape₂ i₁\n      d_comp_d' := by intros; apply d₂_comp_d₂ }\n  d i₁ i₁' :=\n    { f := fun i₂ => d₁ i₁ i₁' i₂\n      comm' := by intros; apply comm }\n  shape i₁ i₁' h := by\n    ext i₂\n    exact shape₁ i₁ i₁' h i₂\n  d_comp_d' i₁ i₁' i₁'' _ _ := by ext i₂; apply d₁_comp_d₁\n\n"}
{"name":"HomologicalComplex₂.ofGradedObject_toGradedObject","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nX : CategoryTheory.GradedObject (Prod I₁ I₂) C\n⊢ Eq (sorryAx (Unit → CategoryTheory.GradedObject (Prod I₁ I₂) C) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 102).num 4).num 102).num 90).num 4).num 90).str \"_sorry\").str \"_@\").str \"_hyg\").num 1038))) X","decl":"@[simp]\nlemma ofGradedObject_toGradedObject :\n    (ofGradedObject c₁ c₂ X d₁ d₂ shape₁ shape₂ d₁_comp_d₁ d₂_comp_d₂ comm).toGradedObject = X :=\n  rfl\n\n"}
{"name":"HomologicalComplex₂.homMk_f_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nf : Quiver.Hom K.toGradedObject L.toGradedObject\ncomm₁ : ∀ (i₁ i₁' : I₁) (i₂ : I₂), c₁.Rel i₁ i₁' → Eq (CategoryTheory.CategoryStruct.comp (f { fst := i₁, snd := i₂ }) ((L.d i₁ i₁').f i₂)) (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) (f { fst := i₁', snd := i₂ }))\ncomm₂ : ∀ (i₁ : I₁) (i₂ i₂' : I₂), c₂.Rel i₂ i₂' → Eq (CategoryTheory.CategoryStruct.comp (f { fst := i₁, snd := i₂ }) ((L.X i₁).d i₂ i₂')) (CategoryTheory.CategoryStruct.comp ((K.X i₁).d i₂ i₂') (f { fst := i₁, snd := i₂' }))\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (((HomologicalComplex₂.homMk f comm₁ comm₂).f i₁).f i₂) (f { fst := i₁, snd := i₂ })","decl":"/-- Constructor for a morphism `K ⟶ L` in the category `HomologicalComplex₂ C c₁ c₂` which\ntakes as inputs a morphism `f : K.toGradedObject ⟶ L.toGradedObject` and\nthe compatibilites with both horizontal and vertical differentials. -/\n@[simps!]\ndef homMk {K L : HomologicalComplex₂ C c₁ c₂}\n    (f : K.toGradedObject ⟶ L.toGradedObject)\n    (comm₁ : ∀ i₁ i₁' i₂, c₁.Rel i₁ i₁' →\n      f ⟨i₁, i₂⟩ ≫ (L.d i₁ i₁').f i₂ = (K.d i₁ i₁').f i₂ ≫ f ⟨i₁', i₂⟩)\n    (comm₂ : ∀ i₁ i₂ i₂', c₂.Rel i₂ i₂' →\n      f ⟨i₁, i₂⟩ ≫ (L.X i₁).d i₂ i₂' = (K.X i₁).d i₂ i₂' ≫ f ⟨i₁, i₂'⟩) : K ⟶ L where\n  f i₁ :=\n    { f := fun i₂ => f ⟨i₁, i₂⟩\n      comm' := comm₂ i₁ }\n  comm' i₁ i₁' h₁ := by\n    ext i₂\n    exact comm₁ i₁ i₁' i₂ h₁\n\n"}
{"name":"HomologicalComplex₂.shape_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\ni₁ i₁' : I₁\nh : Not (c₁.Rel i₁ i₁')\ni₂ : I₂\n⊢ Eq ((K.d i₁ i₁').f i₂) 0","decl":"lemma shape_f (K : HomologicalComplex₂ C c₁ c₂) (i₁ i₁' : I₁) (h : ¬ c₁.Rel i₁ i₁') (i₂ : I₂) :\n    (K.d i₁ i₁').f i₂ = 0 := by\n  rw [K.shape _ _ h, zero_f]\n\n"}
{"name":"HomologicalComplex₂.d_f_comp_d_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\ni₁ i₁' i₁'' : I₁\ni₂ : I₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) ((K.d i₁' i₁'').f i₂)) 0","decl":"@[reassoc (attr := simp)]\nlemma d_f_comp_d_f (K : HomologicalComplex₂ C c₁ c₂)\n    (i₁ i₁' i₁'' : I₁) (i₂ : I₂) :\n    (K.d i₁ i₁').f i₂ ≫ (K.d i₁' i₁'').f i₂ = 0 := by\n  rw [← comp_f, d_comp_d, zero_f]\n\n"}
{"name":"HomologicalComplex₂.d_f_comp_d_f_assoc","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\ni₁ i₁' i₁'' : I₁\ni₂ : I₂\nZ : C\nh : Quiver.Hom ((K.X i₁'').X i₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) (CategoryTheory.CategoryStruct.comp ((K.d i₁' i₁'').f i₂) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma d_f_comp_d_f (K : HomologicalComplex₂ C c₁ c₂)\n    (i₁ i₁' i₁'' : I₁) (i₂ : I₂) :\n    (K.d i₁ i₁').f i₂ ≫ (K.d i₁' i₁'').f i₂ = 0 := by\n  rw [← comp_f, d_comp_d, zero_f]\n\n"}
{"name":"HomologicalComplex₂.d_comm_assoc","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\ni₁ i₁' : I₁\ni₂ i₂' : I₂\nZ : C\nh : Quiver.Hom ((K.X i₁').X i₂') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) (CategoryTheory.CategoryStruct.comp ((K.X i₁').d i₂ i₂') h)) (CategoryTheory.CategoryStruct.comp ((K.X i₁).d i₂ i₂') (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂') h))","decl":"@[reassoc]\nlemma d_comm (K : HomologicalComplex₂ C c₁ c₂) (i₁ i₁' : I₁) (i₂ i₂' : I₂) :\n    (K.d i₁ i₁').f i₂ ≫ (K.X i₁').d i₂ i₂' = (K.X i₁).d i₂ i₂' ≫ (K.d i₁ i₁').f i₂' := by\n  simp\n\n"}
{"name":"HomologicalComplex₂.d_comm","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\ni₁ i₁' : I₁\ni₂ i₂' : I₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) ((K.X i₁').d i₂ i₂')) (CategoryTheory.CategoryStruct.comp ((K.X i₁).d i₂ i₂') ((K.d i₁ i₁').f i₂'))","decl":"@[reassoc]\nlemma d_comm (K : HomologicalComplex₂ C c₁ c₂) (i₁ i₁' : I₁) (i₂ i₂' : I₂) :\n    (K.d i₁ i₁').f i₂ ≫ (K.X i₁').d i₂ i₂' = (K.X i₁).d i₂ i₂' ≫ (K.d i₁ i₁').f i₂' := by\n  simp\n\n"}
{"name":"HomologicalComplex₂.comm_f_assoc","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nf : Quiver.Hom K L\ni₁ i₁' : I₁\ni₂ : I₂\nZ : C\nh : Quiver.Hom ((L.X i₁').X i₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((f.f i₁).f i₂) (CategoryTheory.CategoryStruct.comp ((L.d i₁ i₁').f i₂) h)) (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) (CategoryTheory.CategoryStruct.comp ((f.f i₁').f i₂) h))","decl":"@[reassoc (attr := simp)]\nlemma comm_f {K L : HomologicalComplex₂ C c₁ c₂} (f : K ⟶ L) (i₁ i₁' : I₁) (i₂ : I₂) :\n    (f.f i₁).f i₂ ≫ (L.d i₁ i₁').f i₂ = (K.d i₁ i₁').f i₂ ≫ (f.f i₁').f i₂ :=\n  congr_hom (f.comm i₁ i₁') i₂\n\n"}
{"name":"HomologicalComplex₂.comm_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nf : Quiver.Hom K L\ni₁ i₁' : I₁\ni₂ : I₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((f.f i₁).f i₂) ((L.d i₁ i₁').f i₂)) (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) ((f.f i₁').f i₂))","decl":"@[reassoc (attr := simp)]\nlemma comm_f {K L : HomologicalComplex₂ C c₁ c₂} (f : K ⟶ L) (i₁ i₁' : I₁) (i₂ : I₂) :\n    (f.f i₁).f i₂ ≫ (L.d i₁ i₁').f i₂ = (K.d i₁ i₁').f i₂ ≫ (f.f i₁').f i₂ :=\n  congr_hom (f.comm i₁ i₁') i₂\n\n"}
{"name":"HomologicalComplex₂.flip_X_d","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\ni : I₂\nj j' : I₁\n⊢ Eq ((K.flip.X i).d j j') ((K.d j j').f i)","decl":"/-- Flip a complex of complexes over the diagonal,\nexchanging the horizontal and vertical directions.\n-/\n@[simps]\ndef flip (K : HomologicalComplex₂ C c₁ c₂) : HomologicalComplex₂ C c₂ c₁ where\n  X i :=\n    { X := fun j => (K.X j).X i\n      d := fun j j' => (K.d j j').f i\n      shape := fun _ _ w => K.shape_f _ _ w i }\n  d i i' := { f := fun j => (K.X j).d i i' }\n  shape i i' w := by\n    ext j\n    exact (K.X j).shape i i' w\n\n"}
{"name":"HomologicalComplex₂.flip_X_X","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\ni : I₂\nj : I₁\n⊢ Eq ((K.flip.X i).X j) ((K.X j).X i)","decl":"/-- Flip a complex of complexes over the diagonal,\nexchanging the horizontal and vertical directions.\n-/\n@[simps]\ndef flip (K : HomologicalComplex₂ C c₁ c₂) : HomologicalComplex₂ C c₂ c₁ where\n  X i :=\n    { X := fun j => (K.X j).X i\n      d := fun j j' => (K.d j j').f i\n      shape := fun _ _ w => K.shape_f _ _ w i }\n  d i i' := { f := fun j => (K.X j).d i i' }\n  shape i i' w := by\n    ext j\n    exact (K.X j).shape i i' w\n\n"}
{"name":"HomologicalComplex₂.flip_d_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\ni i' : I₂\nj : I₁\n⊢ Eq ((K.flip.d i i').f j) ((K.X j).d i i')","decl":"/-- Flip a complex of complexes over the diagonal,\nexchanging the horizontal and vertical directions.\n-/\n@[simps]\ndef flip (K : HomologicalComplex₂ C c₁ c₂) : HomologicalComplex₂ C c₂ c₁ where\n  X i :=\n    { X := fun j => (K.X j).X i\n      d := fun j j' => (K.d j j').f i\n      shape := fun _ _ w => K.shape_f _ _ w i }\n  d i i' := { f := fun j => (K.X j).d i i' }\n  shape i i' w := by\n    ext j\n    exact (K.X j).shape i i' w\n\n"}
{"name":"HomologicalComplex₂.flip_flip","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\n⊢ Eq K.flip.flip K","decl":"@[simp]\nlemma flip_flip (K : HomologicalComplex₂ C c₁ c₂) : K.flip.flip = K := rfl\n\n"}
{"name":"HomologicalComplex₂.flipFunctor_obj","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\n⊢ Eq ((HomologicalComplex₂.flipFunctor C c₁ c₂).obj K) K.flip","decl":"/-- Flipping a complex of complexes over the diagonal, as a functor. -/\n@[simps]\ndef flipFunctor :\n    HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex₂ C c₂ c₁ where\n  obj K := K.flip\n  map {K L} f :=\n    { f := fun i =>\n        { f := fun j => (f.f j).f i\n          comm' := by intros; simp }\n      comm' := by intros; ext; simp }\n\n"}
{"name":"HomologicalComplex₂.flipFunctor_map_f_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nf : Quiver.Hom K L\ni : I₂\nj : I₁\n⊢ Eq ((((HomologicalComplex₂.flipFunctor C c₁ c₂).map f).f i).f j) ((f.f j).f i)","decl":"/-- Flipping a complex of complexes over the diagonal, as a functor. -/\n@[simps]\ndef flipFunctor :\n    HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex₂ C c₂ c₁ where\n  obj K := K.flip\n  map {K L} f :=\n    { f := fun i =>\n        { f := fun j => (f.f j).f i\n          comm' := by intros; simp }\n      comm' := by intros; ext; simp }\n\n"}
{"name":"HomologicalComplex₂.flipEquivalenceUnitIso_hom_app_f_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nX : HomologicalComplex₂ C c₁ c₂\ni✝ : I₁\ni : I₂\n⊢ Eq ((((HomologicalComplex₂.flipEquivalenceUnitIso C c₁ c₂).hom.app X).f i✝).f i) (CategoryTheory.CategoryStruct.id ((X.X i✝).X i))","decl":"/-- Auxiliary definition for `HomologicalComplex₂.flipEquivalence`. -/\n@[simps!]\ndef flipEquivalenceUnitIso :\n    𝟭 (HomologicalComplex₂ C c₁ c₂) ≅ flipFunctor C c₁ c₂ ⋙ flipFunctor C c₂ c₁ :=\n  NatIso.ofComponents (fun K => HomologicalComplex.Hom.isoOfComponents (fun i₁ =>\n    HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _)\n    (by simp)) (by aesop_cat)) (by aesop_cat)\n\n"}
{"name":"HomologicalComplex₂.flipEquivalenceUnitIso_inv_app_f_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nX : HomologicalComplex₂ C c₁ c₂\ni✝ : I₁\ni : I₂\n⊢ Eq ((((HomologicalComplex₂.flipEquivalenceUnitIso C c₁ c₂).inv.app X).f i✝).f i) (CategoryTheory.CategoryStruct.id ((X.X i✝).X i))","decl":"/-- Auxiliary definition for `HomologicalComplex₂.flipEquivalence`. -/\n@[simps!]\ndef flipEquivalenceUnitIso :\n    𝟭 (HomologicalComplex₂ C c₁ c₂) ≅ flipFunctor C c₁ c₂ ⋙ flipFunctor C c₂ c₁ :=\n  NatIso.ofComponents (fun K => HomologicalComplex.Hom.isoOfComponents (fun i₁ =>\n    HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _)\n    (by simp)) (by aesop_cat)) (by aesop_cat)\n\n"}
{"name":"HomologicalComplex₂.flipEquivalenceCounitIso_hom_app_f_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nX : HomologicalComplex₂ C c₂ c₁\ni✝ : I₂\ni : I₁\n⊢ Eq ((((HomologicalComplex₂.flipEquivalenceCounitIso C c₁ c₂).hom.app X).f i✝).f i) (CategoryTheory.CategoryStruct.id ((X.X i✝).X i))","decl":"/-- Auxiliary definition for `HomologicalComplex₂.flipEquivalence`. -/\n@[simps!]\ndef flipEquivalenceCounitIso :\n    flipFunctor C c₂ c₁ ⋙ flipFunctor C c₁ c₂ ≅ 𝟭 (HomologicalComplex₂ C c₂ c₁) :=\n  NatIso.ofComponents (fun K => HomologicalComplex.Hom.isoOfComponents (fun i₂ =>\n    HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _)\n    (by simp)) (by aesop_cat)) (by aesop_cat)\n\n"}
{"name":"HomologicalComplex₂.flipEquivalenceCounitIso_inv_app_f_f","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nX : HomologicalComplex₂ C c₂ c₁\ni✝ : I₂\ni : I₁\n⊢ Eq ((((HomologicalComplex₂.flipEquivalenceCounitIso C c₁ c₂).inv.app X).f i✝).f i) (CategoryTheory.CategoryStruct.id ((X.X i✝).X i))","decl":"/-- Auxiliary definition for `HomologicalComplex₂.flipEquivalence`. -/\n@[simps!]\ndef flipEquivalenceCounitIso :\n    flipFunctor C c₂ c₁ ⋙ flipFunctor C c₁ c₂ ≅ 𝟭 (HomologicalComplex₂ C c₂ c₁) :=\n  NatIso.ofComponents (fun K => HomologicalComplex.Hom.isoOfComponents (fun i₂ =>\n    HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _)\n    (by simp)) (by aesop_cat)) (by aesop_cat)\n\n"}
{"name":"HomologicalComplex₂.flipEquivalence_unitIso","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\n⊢ Eq (HomologicalComplex₂.flipEquivalence C c₁ c₂).unitIso (HomologicalComplex₂.flipEquivalenceUnitIso C c₁ c₂)","decl":"/-- Flipping a complex of complexes over the diagonal, as an equivalence of categories. -/\n@[simps]\ndef flipEquivalence :\n    HomologicalComplex₂ C c₁ c₂ ≌ HomologicalComplex₂ C c₂ c₁ where\n  functor := flipFunctor C c₁ c₂\n  inverse := flipFunctor C c₂ c₁\n  unitIso := flipEquivalenceUnitIso C c₁ c₂\n  counitIso := flipEquivalenceCounitIso C c₁ c₂\n\n"}
{"name":"HomologicalComplex₂.flipEquivalence_counitIso","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\n⊢ Eq (HomologicalComplex₂.flipEquivalence C c₁ c₂).counitIso (HomologicalComplex₂.flipEquivalenceCounitIso C c₁ c₂)","decl":"/-- Flipping a complex of complexes over the diagonal, as an equivalence of categories. -/\n@[simps]\ndef flipEquivalence :\n    HomologicalComplex₂ C c₁ c₂ ≌ HomologicalComplex₂ C c₂ c₁ where\n  functor := flipFunctor C c₁ c₂\n  inverse := flipFunctor C c₂ c₁\n  unitIso := flipEquivalenceUnitIso C c₁ c₂\n  counitIso := flipEquivalenceCounitIso C c₁ c₂\n\n"}
{"name":"HomologicalComplex₂.flipEquivalence_inverse","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\n⊢ Eq (HomologicalComplex₂.flipEquivalence C c₁ c₂).inverse (HomologicalComplex₂.flipFunctor C c₂ c₁)","decl":"/-- Flipping a complex of complexes over the diagonal, as an equivalence of categories. -/\n@[simps]\ndef flipEquivalence :\n    HomologicalComplex₂ C c₁ c₂ ≌ HomologicalComplex₂ C c₂ c₁ where\n  functor := flipFunctor C c₁ c₂\n  inverse := flipFunctor C c₂ c₁\n  unitIso := flipEquivalenceUnitIso C c₁ c₂\n  counitIso := flipEquivalenceCounitIso C c₁ c₂\n\n"}
{"name":"HomologicalComplex₂.flipEquivalence_functor","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\n⊢ Eq (HomologicalComplex₂.flipEquivalence C c₁ c₂).functor (HomologicalComplex₂.flipFunctor C c₁ c₂)","decl":"/-- Flipping a complex of complexes over the diagonal, as an equivalence of categories. -/\n@[simps]\ndef flipEquivalence :\n    HomologicalComplex₂ C c₁ c₂ ≌ HomologicalComplex₂ C c₂ c₁ where\n  functor := flipFunctor C c₁ c₂\n  inverse := flipFunctor C c₂ c₁\n  unitIso := flipEquivalenceUnitIso C c₁ c₂\n  counitIso := flipEquivalenceCounitIso C c₁ c₂\n\n"}
{"name":"HomologicalComplex₂.XXIsoOfEq_rfl","module":"Mathlib.Algebra.Homology.HomologicalBicomplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nI₁ : Type u_2\nI₂ : Type u_3\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\ni₁ : I₁\ni₂ : I₂\n⊢ Eq (HomologicalComplex₂.XXIsoOfEq C c₁ c₂ K ⋯ ⋯) (CategoryTheory.Iso.refl ((K.X i₁).X i₂))","decl":"@[simp]\nlemma XXIsoOfEq_rfl (i₁ : I₁) (i₂ : I₂) :\n    K.XXIsoOfEq _ _ _ (rfl : i₁ = i₁) (rfl : i₂ = i₂) = Iso.refl _ := rfl\n\n\n"}
