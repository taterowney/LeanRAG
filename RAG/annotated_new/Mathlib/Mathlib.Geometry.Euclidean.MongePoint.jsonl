{"name":"Affine.Simplex.mongePoint_eq_smul_vsub_vadd_circumcenter","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\n⊢ Eq s.mongePoint (HVAdd.hVAdd (HSMul.hSMul (HDiv.hDiv ↑(HAdd.hAdd n 1) ↑(HSub.hSub n 1)) (VSub.vsub (Finset.centroid Real Finset.univ s.points) s.circumcenter)) s.circumcenter)","decl":"/-- The position of the Monge point in relation to the circumcenter\nand centroid. -/\ntheorem mongePoint_eq_smul_vsub_vadd_circumcenter {n : ℕ} (s : Simplex ℝ P n) :\n    s.mongePoint =\n      (((n + 1 : ℕ) : ℝ) / ((n - 1 : ℕ) : ℝ)) •\n          ((univ : Finset (Fin (n + 1))).centroid ℝ s.points -ᵥ s.circumcenter) +ᵥ\n        s.circumcenter :=\n  rfl\n\n"}
{"name":"Affine.Simplex.mongePoint_mem_affineSpan","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\n⊢ Membership.mem (affineSpan Real (Set.range s.points)) s.mongePoint","decl":"/-- The Monge point lies in the affine span. -/\ntheorem mongePoint_mem_affineSpan {n : ℕ} (s : Simplex ℝ P n) :\n    s.mongePoint ∈ affineSpan ℝ (Set.range s.points) :=\n  smul_vsub_vadd_mem _ _ (centroid_mem_affineSpan_of_card_eq_add_one ℝ _ (card_fin (n + 1)))\n    s.circumcenter_mem_affineSpan s.circumcenter_mem_affineSpan\n\n"}
{"name":"Affine.Simplex.mongePoint_eq_of_range_eq","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns₁ s₂ : Affine.Simplex Real P n\nh : Eq (Set.range s₁.points) (Set.range s₂.points)\n⊢ Eq s₁.mongePoint s₂.mongePoint","decl":"/-- Two simplices with the same points have the same Monge point. -/\ntheorem mongePoint_eq_of_range_eq {n : ℕ} {s₁ s₂ : Simplex ℝ P n}\n    (h : Set.range s₁.points = Set.range s₂.points) : s₁.mongePoint = s₂.mongePoint := by\n  simp_rw [mongePoint_eq_smul_vsub_vadd_circumcenter, centroid_eq_of_range_eq h,\n    circumcenter_eq_of_range_eq h]\n\n"}
{"name":"Affine.Simplex.sum_mongePointWeightsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"n : Nat\n⊢ Eq (Finset.univ.sum fun i => Affine.Simplex.mongePointWeightsWithCircumcenter n i) 1","decl":"/-- `mongePointWeightsWithCircumcenter` sums to 1. -/\n@[simp]\ntheorem sum_mongePointWeightsWithCircumcenter (n : ℕ) :\n    ∑ i, mongePointWeightsWithCircumcenter n i = 1 := by\n  simp_rw [sum_pointsWithCircumcenter, mongePointWeightsWithCircumcenter, sum_const, card_fin,\n    nsmul_eq_mul]\n  -- Porting note: replaced\n  -- have hn1 : (n + 1 : ℝ) ≠ 0 := mod_cast Nat.succ_ne_zero _\n  -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp [n.cast_add_one_ne_zero]`, but was really slow\n  -- replaced by `simp only ...` to speed up. Reinstate `field_simp` once it is faster.\n  simp (disch := field_simp_discharge) only [Nat.cast_add, Nat.cast_ofNat, Nat.cast_one,\n    inv_eq_one_div, mul_div_assoc', mul_one, add_div', div_mul_cancel₀, div_eq_iff, one_mul]\n  ring\n\n"}
{"name":"Affine.Simplex.mongePoint_eq_affineCombination_of_pointsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 2)\n⊢ Eq s.mongePoint ((Finset.affineCombination Real Finset.univ s.pointsWithCircumcenter) (Affine.Simplex.mongePointWeightsWithCircumcenter n))","decl":"/-- The Monge point of an (n+2)-simplex, in terms of\n`pointsWithCircumcenter`. -/\ntheorem mongePoint_eq_affineCombination_of_pointsWithCircumcenter {n : ℕ}\n    (s : Simplex ℝ P (n + 2)) :\n    s.mongePoint =\n      (univ : Finset (PointsWithCircumcenterIndex (n + 2))).affineCombination ℝ\n        s.pointsWithCircumcenter (mongePointWeightsWithCircumcenter n) := by\n  rw [mongePoint_eq_smul_vsub_vadd_circumcenter,\n    centroid_eq_affineCombination_of_pointsWithCircumcenter,\n    circumcenter_eq_affineCombination_of_pointsWithCircumcenter, affineCombination_vsub,\n    ← LinearMap.map_smul, weightedVSub_vadd_affineCombination]\n  congr with i\n  rw [Pi.add_apply, Pi.smul_apply, smul_eq_mul, Pi.sub_apply]\n  -- Porting note: replaced\n  -- have hn1 : (n + 1 : ℝ) ≠ 0 := mod_cast Nat.succ_ne_zero _\n  have hn1 : (n + 1 : ℝ) ≠ 0 := n.cast_add_one_ne_zero\n  cases i <;>\n      simp_rw [centroidWeightsWithCircumcenter, circumcenterWeightsWithCircumcenter,\n        mongePointWeightsWithCircumcenter] <;>\n    rw [add_tsub_assoc_of_le (by decide : 1 ≤ 2), (by decide : 2 - 1 = 1)]\n  · rw [if_pos (mem_univ _), sub_zero, add_zero, card_fin]\n    -- Porting note: replaced\n    -- have hn3 : (n + 2 + 1 : ℝ) ≠ 0 := mod_cast Nat.succ_ne_zero _\n    have hn3 : (n + 2 + 1 : ℝ) ≠ 0 := by norm_cast\n    field_simp [hn1, hn3, mul_comm]\n  · -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp [hn1]`, but was really slow\n  -- replaced by `simp only ...` to speed up. Reinstate `field_simp` once it is faster.\n    simp (disch := field_simp_discharge) only\n      [Nat.cast_add, Nat.cast_ofNat, Nat.cast_one, zero_sub, mul_neg, mul_one, neg_div',\n      neg_add_rev, div_add', one_mul, eq_div_iff, div_mul_cancel₀]\n    ring\n\n"}
{"name":"Affine.Simplex.mongePointVSubFaceCentroidWeightsWithCircumcenter_eq_sub","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"n : Nat\ni₁ i₂ : Fin (HAdd.hAdd n 3)\nh : Ne i₁ i₂\n⊢ Eq (Affine.Simplex.mongePointVSubFaceCentroidWeightsWithCircumcenter i₁ i₂) (HSub.hSub (Affine.Simplex.mongePointWeightsWithCircumcenter n) (Affine.Simplex.centroidWeightsWithCircumcenter (HasCompl.compl (Insert.insert i₁ (Singleton.singleton i₂)))))","decl":"/-- `mongePointVSubFaceCentroidWeightsWithCircumcenter` is the\nresult of subtracting `centroidWeightsWithCircumcenter` from\n`mongePointWeightsWithCircumcenter`. -/\ntheorem mongePointVSubFaceCentroidWeightsWithCircumcenter_eq_sub {n : ℕ} {i₁ i₂ : Fin (n + 3)}\n    (h : i₁ ≠ i₂) :\n    mongePointVSubFaceCentroidWeightsWithCircumcenter i₁ i₂ =\n      mongePointWeightsWithCircumcenter n - centroidWeightsWithCircumcenter {i₁, i₂}ᶜ := by\n  ext i\n  cases' i with i\n  · rw [Pi.sub_apply, mongePointWeightsWithCircumcenter, centroidWeightsWithCircumcenter,\n      mongePointVSubFaceCentroidWeightsWithCircumcenter]\n    have hu : #{i₁, i₂}ᶜ = n + 1 := by\n      simp [card_compl, Fintype.card_fin, h]\n    rw [hu]\n    by_cases hi : i = i₁ ∨ i = i₂ <;> simp [compl_eq_univ_sdiff, hi]\n  · simp [mongePointWeightsWithCircumcenter, centroidWeightsWithCircumcenter,\n      mongePointVSubFaceCentroidWeightsWithCircumcenter]\n\n"}
{"name":"Affine.Simplex.sum_mongePointVSubFaceCentroidWeightsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"n : Nat\ni₁ i₂ : Fin (HAdd.hAdd n 3)\nh : Ne i₁ i₂\n⊢ Eq (Finset.univ.sum fun i => Affine.Simplex.mongePointVSubFaceCentroidWeightsWithCircumcenter i₁ i₂ i) 0","decl":"/-- `mongePointVSubFaceCentroidWeightsWithCircumcenter` sums to 0. -/\n@[simp]\ntheorem sum_mongePointVSubFaceCentroidWeightsWithCircumcenter {n : ℕ} {i₁ i₂ : Fin (n + 3)}\n    (h : i₁ ≠ i₂) : ∑ i, mongePointVSubFaceCentroidWeightsWithCircumcenter i₁ i₂ i = 0 := by\n  rw [mongePointVSubFaceCentroidWeightsWithCircumcenter_eq_sub h]\n  simp_rw [Pi.sub_apply, sum_sub_distrib, sum_mongePointWeightsWithCircumcenter]\n  rw [sum_centroidWeightsWithCircumcenter, sub_self]\n  simp [← card_pos, card_compl, h]\n\n"}
{"name":"Affine.Simplex.mongePoint_vsub_face_centroid_eq_weightedVSub_of_pointsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 2)\ni₁ i₂ : Fin (HAdd.hAdd n 3)\nh : Ne i₁ i₂\n⊢ Eq (VSub.vsub s.mongePoint (Finset.centroid Real (HasCompl.compl (Insert.insert i₁ (Singleton.singleton i₂))) s.points)) ((Finset.univ.weightedVSub s.pointsWithCircumcenter) (Affine.Simplex.mongePointVSubFaceCentroidWeightsWithCircumcenter i₁ i₂))","decl":"/-- The Monge point of an (n+2)-simplex, minus the centroid of an\nn-dimensional face, in terms of `pointsWithCircumcenter`. -/\ntheorem mongePoint_vsub_face_centroid_eq_weightedVSub_of_pointsWithCircumcenter {n : ℕ}\n    (s : Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)} (h : i₁ ≠ i₂) :\n    s.mongePoint -ᵥ ({i₁, i₂}ᶜ : Finset (Fin (n + 3))).centroid ℝ s.points =\n      (univ : Finset (PointsWithCircumcenterIndex (n + 2))).weightedVSub s.pointsWithCircumcenter\n        (mongePointVSubFaceCentroidWeightsWithCircumcenter i₁ i₂) := by\n  simp_rw [mongePoint_eq_affineCombination_of_pointsWithCircumcenter,\n    centroid_eq_affineCombination_of_pointsWithCircumcenter, affineCombination_vsub,\n    mongePointVSubFaceCentroidWeightsWithCircumcenter_eq_sub h]\n\n"}
{"name":"Affine.Simplex.inner_mongePoint_vsub_face_centroid_vsub","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 2)\ni₁ i₂ : Fin (HAdd.hAdd n 3)\n⊢ Eq (Inner.inner (VSub.vsub s.mongePoint (Finset.centroid Real (HasCompl.compl (Insert.insert i₁ (Singleton.singleton i₂))) s.points)) (VSub.vsub (s.points i₁) (s.points i₂))) 0","decl":"/-- The Monge point of an (n+2)-simplex, minus the centroid of an\nn-dimensional face, is orthogonal to the difference of the two\nvertices not in that face. -/\ntheorem inner_mongePoint_vsub_face_centroid_vsub {n : ℕ} (s : Simplex ℝ P (n + 2))\n    {i₁ i₂ : Fin (n + 3)} :\n    ⟪s.mongePoint -ᵥ ({i₁, i₂}ᶜ : Finset (Fin (n + 3))).centroid ℝ s.points,\n        s.points i₁ -ᵥ s.points i₂⟫ =\n      0 := by\n  by_cases h : i₁ = i₂\n  · simp [h]\n  simp_rw [mongePoint_vsub_face_centroid_eq_weightedVSub_of_pointsWithCircumcenter s h,\n    point_eq_affineCombination_of_pointsWithCircumcenter, affineCombination_vsub]\n  have hs : ∑ i, (pointWeightsWithCircumcenter i₁ - pointWeightsWithCircumcenter i₂) i = 0 := by\n    simp\n  rw [inner_weightedVSub _ (sum_mongePointVSubFaceCentroidWeightsWithCircumcenter h) _ hs,\n    sum_pointsWithCircumcenter, pointsWithCircumcenter_eq_circumcenter]\n  simp only [mongePointVSubFaceCentroidWeightsWithCircumcenter, pointsWithCircumcenter_point]\n  let fs : Finset (Fin (n + 3)) := {i₁, i₂}\n  have hfs : ∀ i : Fin (n + 3), i ∉ fs → i ≠ i₁ ∧ i ≠ i₂ := by\n    intro i hi\n    constructor <;> · intro hj; simp [fs, ← hj] at hi\n  rw [← sum_subset fs.subset_univ _]\n  · simp_rw [sum_pointsWithCircumcenter, pointsWithCircumcenter_eq_circumcenter,\n      pointsWithCircumcenter_point, Pi.sub_apply, pointWeightsWithCircumcenter]\n    rw [← sum_subset fs.subset_univ _]\n    · simp_rw [fs, sum_insert (not_mem_singleton.2 h), sum_singleton]\n      repeat rw [← sum_subset fs.subset_univ _]\n      · simp_rw [fs, sum_insert (not_mem_singleton.2 h), sum_singleton]\n        simp [h, Ne.symm h, dist_comm (s.points i₁)]\n      all_goals intro i _ hi; simp [hfs i hi]\n    · intro i _ hi\n      simp [hfs i hi, pointsWithCircumcenter]\n  · intro i _ hi\n    simp [hfs i hi]\n\n"}
{"name":"Affine.Simplex.mongePlane_def","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 2)\ni₁ i₂ : Fin (HAdd.hAdd n 3)\n⊢ Eq (s.mongePlane i₁ i₂) (Min.min (AffineSubspace.mk' (Finset.centroid Real (HasCompl.compl (Insert.insert i₁ (Singleton.singleton i₂))) s.points) (Submodule.span Real (Singleton.singleton (VSub.vsub (s.points i₁) (s.points i₂)))).orthogonal) (affineSpan Real (Set.range s.points)))","decl":"/-- The definition of a Monge plane. -/\ntheorem mongePlane_def {n : ℕ} (s : Simplex ℝ P (n + 2)) (i₁ i₂ : Fin (n + 3)) :\n    s.mongePlane i₁ i₂ =\n      mk' (({i₁, i₂}ᶜ : Finset (Fin (n + 3))).centroid ℝ s.points)\n          (ℝ ∙ s.points i₁ -ᵥ s.points i₂)ᗮ ⊓\n        affineSpan ℝ (Set.range s.points) :=\n  rfl\n\n"}
{"name":"Affine.Simplex.mongePlane_comm","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 2)\ni₁ i₂ : Fin (HAdd.hAdd n 3)\n⊢ Eq (s.mongePlane i₁ i₂) (s.mongePlane i₂ i₁)","decl":"/-- The Monge plane associated with vertices `i₁` and `i₂` equals that\nassociated with `i₂` and `i₁`. -/\ntheorem mongePlane_comm {n : ℕ} (s : Simplex ℝ P (n + 2)) (i₁ i₂ : Fin (n + 3)) :\n    s.mongePlane i₁ i₂ = s.mongePlane i₂ i₁ := by\n  simp_rw [mongePlane_def]\n  congr 3\n  · congr 1\n    exact pair_comm _ _\n  · ext\n    simp_rw [Submodule.mem_span_singleton]\n    constructor\n    all_goals rintro ⟨r, rfl⟩; use -r; rw [neg_smul, ← smul_neg, neg_vsub_eq_vsub_rev]\n\n"}
{"name":"Affine.Simplex.mongePoint_mem_mongePlane","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 2)\ni₁ i₂ : Fin (HAdd.hAdd n 3)\n⊢ Membership.mem (s.mongePlane i₁ i₂) s.mongePoint","decl":"/-- The Monge point lies in the Monge planes. -/\ntheorem mongePoint_mem_mongePlane {n : ℕ} (s : Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)} :\n    s.mongePoint ∈ s.mongePlane i₁ i₂ := by\n  rw [mongePlane_def, mem_inf_iff, ← vsub_right_mem_direction_iff_mem (self_mem_mk' _ _),\n    direction_mk', Submodule.mem_orthogonal']\n  refine ⟨?_, s.mongePoint_mem_affineSpan⟩\n  intro v hv\n  rcases Submodule.mem_span_singleton.mp hv with ⟨r, rfl⟩\n  rw [inner_smul_right, s.inner_mongePoint_vsub_face_centroid_vsub, mul_zero]\n\n"}
{"name":"Affine.Simplex.direction_mongePlane","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 2)\ni₁ i₂ : Fin (HAdd.hAdd n 3)\n⊢ Eq (s.mongePlane i₁ i₂).direction (Min.min (Submodule.span Real (Singleton.singleton (VSub.vsub (s.points i₁) (s.points i₂)))).orthogonal (vectorSpan Real (Set.range s.points)))","decl":"/-- The direction of a Monge plane. -/\ntheorem direction_mongePlane {n : ℕ} (s : Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)} :\n    (s.mongePlane i₁ i₂).direction =\n      (ℝ ∙ s.points i₁ -ᵥ s.points i₂)ᗮ ⊓ vectorSpan ℝ (Set.range s.points) := by\n  rw [mongePlane_def, direction_inf_of_mem_inf s.mongePoint_mem_mongePlane, direction_mk',\n    direction_affineSpan]\n\n"}
{"name":"Affine.Simplex.eq_mongePoint_of_forall_mem_mongePlane","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 2)\ni₁ : Fin (HAdd.hAdd n 3)\np : P\nh : ∀ (i₂ : Fin (HAdd.hAdd n 3)), Ne i₁ i₂ → Membership.mem (s.mongePlane i₁ i₂) p\n⊢ Eq p s.mongePoint","decl":"/-- The Monge point is the only point in all the Monge planes from any\none vertex. -/\ntheorem eq_mongePoint_of_forall_mem_mongePlane {n : ℕ} {s : Simplex ℝ P (n + 2)} {i₁ : Fin (n + 3)}\n    {p : P} (h : ∀ i₂, i₁ ≠ i₂ → p ∈ s.mongePlane i₁ i₂) : p = s.mongePoint := by\n  rw [← @vsub_eq_zero_iff_eq V]\n  have h' : ∀ i₂, i₁ ≠ i₂ → p -ᵥ s.mongePoint ∈\n      (ℝ ∙ s.points i₁ -ᵥ s.points i₂)ᗮ ⊓ vectorSpan ℝ (Set.range s.points) := by\n    intro i₂ hne\n    rw [← s.direction_mongePlane, vsub_right_mem_direction_iff_mem s.mongePoint_mem_mongePlane]\n    exact h i₂ hne\n  have hi : p -ᵥ s.mongePoint ∈ ⨅ i₂ : { i // i₁ ≠ i }, (ℝ ∙ s.points i₁ -ᵥ s.points i₂)ᗮ := by\n    rw [Submodule.mem_iInf]\n    exact fun i => (Submodule.mem_inf.1 (h' i i.property)).1\n  rw [Submodule.iInf_orthogonal, ← Submodule.span_iUnion] at hi\n  have hu :\n    ⋃ i : { i // i₁ ≠ i }, ({s.points i₁ -ᵥ s.points i} : Set V) =\n      (s.points i₁ -ᵥ ·) '' (s.points '' (Set.univ \\ {i₁})) := by\n    rw [Set.image_image]\n    ext x\n    simp_rw [Set.mem_iUnion, Set.mem_image, Set.mem_singleton_iff, Set.mem_diff_singleton]\n    constructor\n    · rintro ⟨i, rfl⟩\n      use i, ⟨Set.mem_univ _, i.property.symm⟩\n    · rintro ⟨i, ⟨-, hi⟩, rfl⟩\n      use ⟨i, hi.symm⟩\n  rw [hu, ← vectorSpan_image_eq_span_vsub_set_left_ne ℝ _ (Set.mem_univ _), Set.image_univ] at hi\n  have hv : p -ᵥ s.mongePoint ∈ vectorSpan ℝ (Set.range s.points) := by\n    let s₁ : Finset (Fin (n + 3)) := univ.erase i₁\n    obtain ⟨i₂, h₂⟩ := card_pos.1 (show 0 < #s₁ by simp [s₁, card_erase_of_mem])\n    have h₁₂ : i₁ ≠ i₂ := (ne_of_mem_erase h₂).symm\n    exact (Submodule.mem_inf.1 (h' i₂ h₁₂)).2\n  exact Submodule.disjoint_def.1 (vectorSpan ℝ (Set.range s.points)).orthogonal_disjoint _ hv hi\n\n"}
{"name":"Affine.Simplex.altitude_def","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq (s.altitude i) (Min.min (AffineSubspace.mk' (s.points i) (affineSpan Real (Set.image s.points ↑(Finset.univ.erase i))).direction.orthogonal) (affineSpan Real (Set.range s.points)))","decl":"/-- The definition of an altitude. -/\ntheorem altitude_def {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2)) :\n    s.altitude i =\n      mk' (s.points i) (affineSpan ℝ (s.points '' ↑(univ.erase i))).directionᗮ ⊓\n        affineSpan ℝ (Set.range s.points) :=\n  rfl\n\n"}
{"name":"Affine.Simplex.mem_altitude","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 2)\n⊢ Membership.mem (s.altitude i) (s.points i)","decl":"/-- A vertex lies in the corresponding altitude. -/\ntheorem mem_altitude {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2)) :\n    s.points i ∈ s.altitude i :=\n  (mem_inf_iff _ _ _).2 ⟨self_mem_mk' _ _, mem_affineSpan ℝ (Set.mem_range_self _)⟩\n\n"}
{"name":"Affine.Simplex.direction_altitude","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq (s.altitude i).direction (Min.min (vectorSpan Real (Set.image s.points ↑(Finset.univ.erase i))).orthogonal (vectorSpan Real (Set.range s.points)))","decl":"/-- The direction of an altitude. -/\ntheorem direction_altitude {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2)) :\n    (s.altitude i).direction =\n      (vectorSpan ℝ (s.points '' ↑(Finset.univ.erase i)))ᗮ ⊓ vectorSpan ℝ (Set.range s.points) := by\n  rw [altitude_def,\n    direction_inf_of_mem (self_mem_mk' (s.points i) _) (mem_affineSpan ℝ (Set.mem_range_self _)),\n    direction_mk', direction_affineSpan, direction_affineSpan]\n\n"}
{"name":"Affine.Simplex.vectorSpan_isOrtho_altitude_direction","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 2)\n⊢ (vectorSpan Real (Set.image s.points ↑(Finset.univ.erase i))).IsOrtho (s.altitude i).direction","decl":"/-- The vector span of the opposite face lies in the direction\northogonal to an altitude. -/\ntheorem vectorSpan_isOrtho_altitude_direction {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2)) :\n    vectorSpan ℝ (s.points '' ↑(Finset.univ.erase i)) ⟂ (s.altitude i).direction := by\n  rw [direction_altitude]\n  exact (Submodule.isOrtho_orthogonal_right _).mono_right inf_le_left\n\n"}
{"name":"Affine.Simplex.finiteDimensional_direction_altitude","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 2)\n⊢ FiniteDimensional Real (Subtype fun x => Membership.mem (s.altitude i).direction x)","decl":"/-- An altitude is finite-dimensional. -/\ninstance finiteDimensional_direction_altitude {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2)) :\n    FiniteDimensional ℝ (s.altitude i).direction := by\n  rw [direction_altitude]\n  infer_instance\n\n"}
{"name":"Affine.Simplex.finrank_direction_altitude","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq (Module.finrank Real (Subtype fun x => Membership.mem (s.altitude i).direction x)) 1","decl":"/-- An altitude is one-dimensional (i.e., a line). -/\n@[simp]\ntheorem finrank_direction_altitude {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2)) :\n    finrank ℝ (s.altitude i).direction = 1 := by\n  rw [direction_altitude]\n  have h := Submodule.finrank_add_inf_finrank_orthogonal\n    (vectorSpan_mono ℝ (Set.image_subset_range s.points ↑(univ.erase i)))\n  have hc : #(univ.erase i) = n + 1 := by rw [card_erase_of_mem (mem_univ _)]; simp\n  refine add_left_cancel (_root_.trans h ?_)\n  classical\n  rw [s.independent.finrank_vectorSpan (Fintype.card_fin _), ← Finset.coe_image,\n    s.independent.finrank_vectorSpan_image_finset hc]\n\n"}
{"name":"Affine.Simplex.affineSpan_pair_eq_altitude_iff","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 2)\np : P\n⊢ Iff (Eq (affineSpan Real (Insert.insert p (Singleton.singleton (s.points i)))) (s.altitude i)) (And (Ne p (s.points i)) (And (Membership.mem (affineSpan Real (Set.range s.points)) p) (Membership.mem (affineSpan Real (Set.image s.points ↑(Finset.univ.erase i))).direction.orthogonal (VSub.vsub p (s.points i)))))","decl":"/-- A line through a vertex is the altitude through that vertex if and\nonly if it is orthogonal to the opposite face. -/\ntheorem affineSpan_pair_eq_altitude_iff {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2))\n    (p : P) :\n    line[ℝ, p, s.points i] = s.altitude i ↔\n      p ≠ s.points i ∧\n        p ∈ affineSpan ℝ (Set.range s.points) ∧\n          p -ᵥ s.points i ∈ (affineSpan ℝ (s.points '' ↑(Finset.univ.erase i))).directionᗮ := by\n  rw [eq_iff_direction_eq_of_mem (mem_affineSpan ℝ (Set.mem_insert_of_mem _ (Set.mem_singleton _)))\n      (s.mem_altitude _),\n    ← vsub_right_mem_direction_iff_mem (mem_affineSpan ℝ (Set.mem_range_self i)) p,\n    direction_affineSpan, direction_affineSpan, direction_affineSpan]\n  constructor\n  · intro h\n    constructor\n    · intro heq\n      rw [heq, Set.pair_eq_singleton, vectorSpan_singleton] at h\n      have hd : finrank ℝ (s.altitude i).direction = 0 := by rw [← h, finrank_bot]\n      simp at hd\n    · rw [← Submodule.mem_inf, _root_.inf_comm, ← direction_altitude, ← h]\n      exact\n        vsub_mem_vectorSpan ℝ (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n  · rintro ⟨hne, h⟩\n    rw [← Submodule.mem_inf, _root_.inf_comm, ← direction_altitude] at h\n    rw [vectorSpan_eq_span_vsub_set_left_ne ℝ (Set.mem_insert _ _),\n      Set.insert_diff_of_mem _ (Set.mem_singleton _),\n      Set.diff_singleton_eq_self fun h => hne (Set.mem_singleton_iff.1 h), Set.image_singleton]\n    refine Submodule.eq_of_le_of_finrank_eq ?_ ?_\n    · rw [Submodule.span_le]\n      simpa using h\n    · rw [finrank_direction_altitude, finrank_span_set_eq_card]\n      · simp\n      · refine linearIndependent_singleton ?_\n        simpa using hne\n\n"}
{"name":"Affine.Triangle.orthocenter_eq_mongePoint","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\n⊢ Eq t.orthocenter (Affine.Simplex.mongePoint t)","decl":"/-- The orthocenter equals the Monge point. -/\ntheorem orthocenter_eq_mongePoint (t : Triangle ℝ P) : t.orthocenter = t.mongePoint :=\n  rfl\n\n"}
{"name":"Affine.Triangle.orthocenter_eq_smul_vsub_vadd_circumcenter","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\n⊢ Eq t.orthocenter (HVAdd.hVAdd (HSMul.hSMul 3 (VSub.vsub (Finset.centroid Real Finset.univ t.points) (Affine.Simplex.circumcenter t))) (Affine.Simplex.circumcenter t))","decl":"/-- The position of the orthocenter in relation to the circumcenter\nand centroid. -/\ntheorem orthocenter_eq_smul_vsub_vadd_circumcenter (t : Triangle ℝ P) :\n    t.orthocenter =\n      (3 : ℝ) • ((univ : Finset (Fin 3)).centroid ℝ t.points -ᵥ t.circumcenter : V) +ᵥ\n        t.circumcenter := by\n  rw [orthocenter_eq_mongePoint, mongePoint_eq_smul_vsub_vadd_circumcenter]\n  norm_num\n\n"}
{"name":"Affine.Triangle.orthocenter_mem_affineSpan","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\n⊢ Membership.mem (affineSpan Real (Set.range t.points)) t.orthocenter","decl":"/-- The orthocenter lies in the affine span. -/\ntheorem orthocenter_mem_affineSpan (t : Triangle ℝ P) :\n    t.orthocenter ∈ affineSpan ℝ (Set.range t.points) :=\n  t.mongePoint_mem_affineSpan\n\n"}
{"name":"Affine.Triangle.orthocenter_eq_of_range_eq","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt₁ t₂ : Affine.Triangle Real P\nh : Eq (Set.range t₁.points) (Set.range t₂.points)\n⊢ Eq t₁.orthocenter t₂.orthocenter","decl":"/-- Two triangles with the same points have the same orthocenter. -/\ntheorem orthocenter_eq_of_range_eq {t₁ t₂ : Triangle ℝ P}\n    (h : Set.range t₁.points = Set.range t₂.points) : t₁.orthocenter = t₂.orthocenter :=\n  mongePoint_eq_of_range_eq h\n\n"}
{"name":"Affine.Triangle.altitude_eq_mongePlane","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\ni₁ i₂ i₃ : Fin 3\nh₁₂ : Ne i₁ i₂\nh₁₃ : Ne i₁ i₃\nh₂₃ : Ne i₂ i₃\n⊢ Eq (Affine.Simplex.altitude t i₁) (Affine.Simplex.mongePlane t i₂ i₃)","decl":"/-- In the case of a triangle, altitudes are the same thing as Monge\nplanes. -/\ntheorem altitude_eq_mongePlane (t : Triangle ℝ P) {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃)\n    (h₂₃ : i₂ ≠ i₃) : t.altitude i₁ = t.mongePlane i₂ i₃ := by\n  have hs : ({i₂, i₃}ᶜ : Finset (Fin 3)) = {i₁} := by decide +revert\n  have he : univ.erase i₁ = {i₂, i₃} := by decide +revert\n  rw [mongePlane_def, altitude_def, direction_affineSpan, hs, he, centroid_singleton, coe_insert,\n    coe_singleton, vectorSpan_image_eq_span_vsub_set_left_ne ℝ _ (Set.mem_insert i₂ _)]\n  simp [h₂₃, Submodule.span_insert_eq_span]\n\n"}
{"name":"Affine.Triangle.orthocenter_mem_altitude","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\ni₁ : Fin 3\n⊢ Membership.mem (Affine.Simplex.altitude t i₁) t.orthocenter","decl":"/-- The orthocenter lies in the altitudes. -/\ntheorem orthocenter_mem_altitude (t : Triangle ℝ P) {i₁ : Fin 3} :\n    t.orthocenter ∈ t.altitude i₁ := by\n  obtain ⟨i₂, i₃, h₁₂, h₂₃, h₁₃⟩ : ∃ i₂ i₃, i₁ ≠ i₂ ∧ i₂ ≠ i₃ ∧ i₁ ≠ i₃ := by\n    decide +revert\n  rw [orthocenter_eq_mongePoint, t.altitude_eq_mongePlane h₁₂ h₁₃ h₂₃]\n  exact t.mongePoint_mem_mongePlane\n\n"}
{"name":"Affine.Triangle.eq_orthocenter_of_forall_mem_altitude","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\ni₁ i₂ : Fin 3\np : P\nh₁₂ : Ne i₁ i₂\nh₁ : Membership.mem (Affine.Simplex.altitude t i₁) p\nh₂ : Membership.mem (Affine.Simplex.altitude t i₂) p\n⊢ Eq p t.orthocenter","decl":"/-- The orthocenter is the only point lying in any two of the\naltitudes. -/\ntheorem eq_orthocenter_of_forall_mem_altitude {t : Triangle ℝ P} {i₁ i₂ : Fin 3} {p : P}\n    (h₁₂ : i₁ ≠ i₂) (h₁ : p ∈ t.altitude i₁) (h₂ : p ∈ t.altitude i₂) : p = t.orthocenter := by\n  obtain ⟨i₃, h₂₃, h₁₃⟩ : ∃ i₃, i₂ ≠ i₃ ∧ i₁ ≠ i₃ := by\n    clear h₁ h₂\n    decide +revert\n  rw [t.altitude_eq_mongePlane h₁₃ h₁₂ h₂₃.symm] at h₁\n  rw [t.altitude_eq_mongePlane h₂₃ h₁₂.symm h₁₃.symm] at h₂\n  rw [orthocenter_eq_mongePoint]\n  have ha : ∀ i, i₃ ≠ i → p ∈ t.mongePlane i₃ i := by\n    intro i hi\n    obtain rfl | rfl : i₁ = i ∨ i₂ = i := by omega\n    all_goals assumption\n  exact eq_mongePoint_of_forall_mem_mongePlane ha\n\n"}
{"name":"Affine.Triangle.dist_orthocenter_reflection_circumcenter","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\ni₁ i₂ : Fin 3\nh : Ne i₁ i₂\n⊢ Eq (Dist.dist t.orthocenter ((EuclideanGeometry.reflection (affineSpan Real (Set.image t.points (Insert.insert i₁ (Singleton.singleton i₂))))) (Affine.Simplex.circumcenter t))) (Affine.Simplex.circumradius t)","decl":"/-- The distance from the orthocenter to the reflection of the\ncircumcenter in a side equals the circumradius. -/\ntheorem dist_orthocenter_reflection_circumcenter (t : Triangle ℝ P) {i₁ i₂ : Fin 3} (h : i₁ ≠ i₂) :\n    dist t.orthocenter (reflection (affineSpan ℝ (t.points '' {i₁, i₂})) t.circumcenter) =\n      t.circumradius := by\n  rw [← mul_self_inj_of_nonneg dist_nonneg t.circumradius_nonneg,\n    t.reflection_circumcenter_eq_affineCombination_of_pointsWithCircumcenter h,\n    t.orthocenter_eq_mongePoint, mongePoint_eq_affineCombination_of_pointsWithCircumcenter,\n    dist_affineCombination t.pointsWithCircumcenter (sum_mongePointWeightsWithCircumcenter _)\n      (sum_reflectionCircumcenterWeightsWithCircumcenter h)]\n  simp_rw [sum_pointsWithCircumcenter, Pi.sub_apply, mongePointWeightsWithCircumcenter,\n    reflectionCircumcenterWeightsWithCircumcenter]\n  have hu : ({i₁, i₂} : Finset (Fin 3)) ⊆ univ := subset_univ _\n  obtain ⟨i₃, hi₃, hi₃₁, hi₃₂⟩ :\n      ∃ i₃, univ \\ ({i₁, i₂} : Finset (Fin 3)) = {i₃} ∧ i₃ ≠ i₁ ∧ i₃ ≠ i₂ := by\n    decide +revert\n  simp_rw [← sum_sdiff hu, hi₃]\n  norm_num [hi₃₁, hi₃₂]\n\n"}
{"name":"Affine.Triangle.dist_orthocenter_reflection_circumcenter_finset","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\ni₁ i₂ : Fin 3\nh : Ne i₁ i₂\n⊢ Eq (Dist.dist t.orthocenter ((EuclideanGeometry.reflection (affineSpan Real (Set.image t.points ↑(Insert.insert i₁ (Singleton.singleton i₂))))) (Affine.Simplex.circumcenter t))) (Affine.Simplex.circumradius t)","decl":"/-- The distance from the orthocenter to the reflection of the\ncircumcenter in a side equals the circumradius, variant using a\n`Finset`. -/\ntheorem dist_orthocenter_reflection_circumcenter_finset (t : Triangle ℝ P) {i₁ i₂ : Fin 3}\n    (h : i₁ ≠ i₂) :\n    dist t.orthocenter\n        (reflection (affineSpan ℝ (t.points '' ↑({i₁, i₂} : Finset (Fin 3)))) t.circumcenter) =\n      t.circumradius := by\n  simp only [mem_singleton, coe_insert, coe_singleton, Set.mem_singleton_iff]\n  exact dist_orthocenter_reflection_circumcenter _ h\n\n"}
{"name":"Affine.Triangle.affineSpan_orthocenter_point_le_altitude","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\ni : Fin 3\n⊢ LE.le (affineSpan Real (Insert.insert t.orthocenter (Singleton.singleton (t.points i)))) (Affine.Simplex.altitude t i)","decl":"/-- The affine span of the orthocenter and a vertex is contained in\nthe altitude. -/\ntheorem affineSpan_orthocenter_point_le_altitude (t : Triangle ℝ P) (i : Fin 3) :\n    line[ℝ, t.orthocenter, t.points i] ≤ t.altitude i := by\n  refine spanPoints_subset_coe_of_subset_coe ?_\n  rw [Set.insert_subset_iff, Set.singleton_subset_iff]\n  exact ⟨t.orthocenter_mem_altitude, t.mem_altitude i⟩\n\n"}
{"name":"Affine.Triangle.altitude_replace_orthocenter_eq_affineSpan","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt₁ t₂ : Affine.Triangle Real P\ni₁ i₂ i₃ j₁ j₂ j₃ : Fin 3\nhi₁₂ : Ne i₁ i₂\nhi₁₃ : Ne i₁ i₃\nhi₂₃ : Ne i₂ i₃\nhj₁₂ : Ne j₁ j₂\nhj₁₃ : Ne j₁ j₃\nhj₂₃ : Ne j₂ j₃\nh₁ : Eq (t₂.points j₁) t₁.orthocenter\nh₂ : Eq (t₂.points j₂) (t₁.points i₂)\nh₃ : Eq (t₂.points j₃) (t₁.points i₃)\n⊢ Eq (Affine.Simplex.altitude t₂ j₂) (affineSpan Real (Insert.insert (t₁.points i₁) (Singleton.singleton (t₁.points i₂))))","decl":"/-- Suppose we are given a triangle `t₁`, and replace one of its\nvertices by its orthocenter, yielding triangle `t₂` (with vertices not\nnecessarily listed in the same order).  Then an altitude of `t₂` from\na vertex that was not replaced is the corresponding side of `t₁`. -/\ntheorem altitude_replace_orthocenter_eq_affineSpan {t₁ t₂ : Triangle ℝ P}\n    {i₁ i₂ i₃ j₁ j₂ j₃ : Fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂)\n    (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter)\n    (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) :\n    t₂.altitude j₂ = line[ℝ, t₁.points i₁, t₁.points i₂] := by\n  symm\n  rw [← h₂, t₂.affineSpan_pair_eq_altitude_iff]\n  rw [h₂]\n  use t₁.independent.injective.ne hi₁₂\n  have he : affineSpan ℝ (Set.range t₂.points) = affineSpan ℝ (Set.range t₁.points) := by\n    refine ext_of_direction_eq ?_\n      ⟨t₁.points i₃, mem_affineSpan ℝ ⟨j₃, h₃⟩, mem_affineSpan ℝ (Set.mem_range_self _)⟩\n    refine Submodule.eq_of_le_of_finrank_eq (direction_le (spanPoints_subset_coe_of_subset_coe ?_))\n      ?_\n    · have hu : (Finset.univ : Finset (Fin 3)) = {j₁, j₂, j₃} := by\n        clear h₁ h₂ h₃\n        decide +revert\n      rw [← Set.image_univ, ← Finset.coe_univ, hu, Finset.coe_insert, Finset.coe_insert,\n        Finset.coe_singleton, Set.image_insert_eq, Set.image_insert_eq, Set.image_singleton, h₁, h₂,\n        h₃, Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff]\n      exact\n        ⟨t₁.orthocenter_mem_affineSpan, mem_affineSpan ℝ (Set.mem_range_self _),\n          mem_affineSpan ℝ (Set.mem_range_self _)⟩\n    · rw [direction_affineSpan, direction_affineSpan,\n        t₁.independent.finrank_vectorSpan (Fintype.card_fin _),\n        t₂.independent.finrank_vectorSpan (Fintype.card_fin _)]\n  rw [he]\n  use mem_affineSpan ℝ (Set.mem_range_self _)\n  have hu : Finset.univ.erase j₂ = {j₁, j₃} := by\n    clear h₁ h₂ h₃\n    decide +revert\n  rw [hu, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton, h₁, h₃]\n  have hle : (t₁.altitude i₃).directionᗮ ≤ line[ℝ, t₁.orthocenter, t₁.points i₃].directionᗮ :=\n    Submodule.orthogonal_le (direction_le (affineSpan_orthocenter_point_le_altitude _ _))\n  refine hle ((t₁.vectorSpan_isOrtho_altitude_direction i₃) ?_)\n  have hui : Finset.univ.erase i₃ = {i₁, i₂} := by\n    clear hle h₂ h₃\n    decide +revert\n  rw [hui, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton]\n  exact vsub_mem_vectorSpan ℝ (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n\n"}
{"name":"Affine.Triangle.orthocenter_replace_orthocenter_eq_point","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt₁ t₂ : Affine.Triangle Real P\ni₁ i₂ i₃ j₁ j₂ j₃ : Fin 3\nhi₁₂ : Ne i₁ i₂\nhi₁₃ : Ne i₁ i₃\nhi₂₃ : Ne i₂ i₃\nhj₁₂ : Ne j₁ j₂\nhj₁₃ : Ne j₁ j₃\nhj₂₃ : Ne j₂ j₃\nh₁ : Eq (t₂.points j₁) t₁.orthocenter\nh₂ : Eq (t₂.points j₂) (t₁.points i₂)\nh₃ : Eq (t₂.points j₃) (t₁.points i₃)\n⊢ Eq t₂.orthocenter (t₁.points i₁)","decl":"/-- Suppose we are given a triangle `t₁`, and replace one of its\nvertices by its orthocenter, yielding triangle `t₂` (with vertices not\nnecessarily listed in the same order).  Then the orthocenter of `t₂`\nis the vertex of `t₁` that was replaced. -/\ntheorem orthocenter_replace_orthocenter_eq_point {t₁ t₂ : Triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : Fin 3}\n    (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃)\n    (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂)\n    (h₃ : t₂.points j₃ = t₁.points i₃) : t₂.orthocenter = t₁.points i₁ := by\n  refine (Triangle.eq_orthocenter_of_forall_mem_altitude hj₂₃ ?_ ?_).symm\n  · rw [altitude_replace_orthocenter_eq_affineSpan hi₁₂ hi₁₃ hi₂₃ hj₁₂ hj₁₃ hj₂₃ h₁ h₂ h₃]\n    exact mem_affineSpan ℝ (Set.mem_insert _ _)\n  · rw [altitude_replace_orthocenter_eq_affineSpan hi₁₃ hi₁₂ hi₂₃.symm hj₁₃ hj₁₂ hj₂₃.symm h₁ h₃ h₂]\n    exact mem_affineSpan ℝ (Set.mem_insert _ _)\n\n"}
{"name":"EuclideanGeometry.exists_of_range_subset_orthocentricSystem","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\nho : Not (Membership.mem (Set.range t.points) t.orthocenter)\np : Fin 3 → P\nhps : HasSubset.Subset (Set.range p) (Insert.insert t.orthocenter (Set.range t.points))\nhpi : Function.Injective p\n⊢ Or (Exists fun i₁ => Exists fun i₂ => Exists fun i₃ => Exists fun j₂ => Exists fun j₃ => And (Ne i₁ i₂) (And (Ne i₁ i₃) (And (Ne i₂ i₃) (And (∀ (i : Fin 3), Or (Eq i i₁) (Or (Eq i i₂) (Eq i i₃))) (And (Eq (p i₁) t.orthocenter) (And (Ne j₂ j₃) (And (Eq (t.points j₂) (p i₂)) (Eq (t.points j₃) (p i₃))))))))) (Eq (Set.range p) (Set.range t.points))","decl":"/-- This is an auxiliary lemma giving information about the relation\nof two triangles in an orthocentric system; it abstracts some\nreasoning, with no geometric content, that is common to some other\nlemmas.  Suppose the orthocentric system is generated by triangle `t`,\nand we are given three points `p` in the orthocentric system.  Then\neither we can find indices `i₁`, `i₂` and `i₃` for `p` such that `p\ni₁` is the orthocenter of `t` and `p i₂` and `p i₃` are points `j₂`\nand `j₃` of `t`, or `p` has the same points as `t`. -/\ntheorem exists_of_range_subset_orthocentricSystem {t : Triangle ℝ P}\n    (ho : t.orthocenter ∉ Set.range t.points) {p : Fin 3 → P}\n    (hps : Set.range p ⊆ insert t.orthocenter (Set.range t.points)) (hpi : Function.Injective p) :\n    (∃ i₁ i₂ i₃ j₂ j₃ : Fin 3,\n      i₁ ≠ i₂ ∧ i₁ ≠ i₃ ∧ i₂ ≠ i₃ ∧ (∀ i : Fin 3, i = i₁ ∨ i = i₂ ∨ i = i₃) ∧\n        p i₁ = t.orthocenter ∧ j₂ ≠ j₃ ∧ t.points j₂ = p i₂ ∧ t.points j₃ = p i₃) ∨\n      Set.range p = Set.range t.points := by\n  by_cases h : t.orthocenter ∈ Set.range p\n  · left\n    rcases h with ⟨i₁, h₁⟩\n    obtain ⟨i₂, i₃, h₁₂, h₁₃, h₂₃, h₁₂₃⟩ :\n        ∃ i₂ i₃ : Fin 3, i₁ ≠ i₂ ∧ i₁ ≠ i₃ ∧ i₂ ≠ i₃ ∧ ∀ i : Fin 3, i = i₁ ∨ i = i₂ ∨ i = i₃ := by\n      clear h₁\n      decide +revert\n    have h : ∀ i, i₁ ≠ i → ∃ j : Fin 3, t.points j = p i := by\n      intro i hi\n      replace hps := Set.mem_of_mem_insert_of_ne\n        (Set.mem_of_mem_of_subset (Set.mem_range_self i) hps) (h₁ ▸ hpi.ne hi.symm)\n      exact hps\n    rcases h i₂ h₁₂ with ⟨j₂, h₂⟩\n    rcases h i₃ h₁₃ with ⟨j₃, h₃⟩\n    have hj₂₃ : j₂ ≠ j₃ := by\n      intro he\n      rw [he, h₃] at h₂\n      exact h₂₃.symm (hpi h₂)\n    exact ⟨i₁, i₂, i₃, j₂, j₃, h₁₂, h₁₃, h₂₃, h₁₂₃, h₁, hj₂₃, h₂, h₃⟩\n  · right\n    have hs := Set.subset_diff_singleton hps h\n    rw [Set.insert_diff_self_of_not_mem ho] at hs\n    classical\n    refine Set.eq_of_subset_of_card_le hs ?_\n    rw [Set.card_range_of_injective hpi, Set.card_range_of_injective t.independent.injective]\n\n"}
{"name":"EuclideanGeometry.exists_dist_eq_circumradius_of_subset_insert_orthocenter","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nt : Affine.Triangle Real P\nho : Not (Membership.mem (Set.range t.points) t.orthocenter)\np : Fin 3 → P\nhps : HasSubset.Subset (Set.range p) (Insert.insert t.orthocenter (Set.range t.points))\nhpi : Function.Injective p\n⊢ Exists fun c => And (Membership.mem (affineSpan Real (Set.range t.points)) c) (∀ (p₁ : P), Membership.mem (Set.range p) p₁ → Eq (Dist.dist p₁ c) (Affine.Simplex.circumradius t))","decl":"/-- For any three points in an orthocentric system generated by\ntriangle `t`, there is a point in the subspace spanned by the triangle\nfrom which the distance of all those three points equals the circumradius. -/\ntheorem exists_dist_eq_circumradius_of_subset_insert_orthocenter {t : Triangle ℝ P}\n    (ho : t.orthocenter ∉ Set.range t.points) {p : Fin 3 → P}\n    (hps : Set.range p ⊆ insert t.orthocenter (Set.range t.points)) (hpi : Function.Injective p) :\n    ∃ c ∈ affineSpan ℝ (Set.range t.points), ∀ p₁ ∈ Set.range p, dist p₁ c = t.circumradius := by\n  rcases exists_of_range_subset_orthocentricSystem ho hps hpi with\n    (⟨i₁, i₂, i₃, j₂, j₃, _, _, _, h₁₂₃, h₁, hj₂₃, h₂, h₃⟩ | hs)\n  · use reflection (affineSpan ℝ (t.points '' {j₂, j₃})) t.circumcenter,\n      reflection_mem_of_le_of_mem (affineSpan_mono ℝ (Set.image_subset_range _ _))\n        t.circumcenter_mem_affineSpan\n    intro p₁ hp₁\n    rcases hp₁ with ⟨i, rfl⟩\n    have h₁₂₃ := h₁₂₃ i\n    repeat' cases' h₁₂₃ with h₁₂₃ h₁₂₃\n    · convert Triangle.dist_orthocenter_reflection_circumcenter t hj₂₃\n    · rw [← h₂, dist_reflection_eq_of_mem _\n       (mem_affineSpan ℝ (Set.mem_image_of_mem _ (Set.mem_insert _ _)))]\n      exact t.dist_circumcenter_eq_circumradius _\n    · rw [← h₃,\n        dist_reflection_eq_of_mem _\n          (mem_affineSpan ℝ\n            (Set.mem_image_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))))]\n      exact t.dist_circumcenter_eq_circumradius _\n  · use t.circumcenter, t.circumcenter_mem_affineSpan\n    intro p₁ hp₁\n    rw [hs] at hp₁\n    rcases hp₁ with ⟨i, rfl⟩\n    exact t.dist_circumcenter_eq_circumradius _\n\n"}
{"name":"EuclideanGeometry.OrthocentricSystem.affineIndependent","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set P\nho : EuclideanGeometry.OrthocentricSystem s\np : Fin 3 → P\nhps : HasSubset.Subset (Set.range p) s\nhpi : Function.Injective p\n⊢ AffineIndependent Real p","decl":"/-- Any three points in an orthocentric system are affinely independent. -/\ntheorem OrthocentricSystem.affineIndependent {s : Set P} (ho : OrthocentricSystem s) {p : Fin 3 → P}\n    (hps : Set.range p ⊆ s) (hpi : Function.Injective p) : AffineIndependent ℝ p := by\n  rcases ho with ⟨t, hto, hst⟩\n  rw [hst] at hps\n  rcases exists_dist_eq_circumradius_of_subset_insert_orthocenter hto hps hpi with ⟨c, _, hc⟩\n  exact Cospherical.affineIndependent ⟨c, t.circumradius, hc⟩ Set.Subset.rfl hpi\n\n"}
{"name":"EuclideanGeometry.affineSpan_of_orthocentricSystem","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set P\nho : EuclideanGeometry.OrthocentricSystem s\np : Fin 3 → P\nhps : HasSubset.Subset (Set.range p) s\nhpi : Function.Injective p\n⊢ Eq (affineSpan Real (Set.range p)) (affineSpan Real s)","decl":"/-- Any three points in an orthocentric system span the same subspace\nas the whole orthocentric system. -/\ntheorem affineSpan_of_orthocentricSystem {s : Set P} (ho : OrthocentricSystem s) {p : Fin 3 → P}\n    (hps : Set.range p ⊆ s) (hpi : Function.Injective p) :\n    affineSpan ℝ (Set.range p) = affineSpan ℝ s := by\n  have ha := ho.affineIndependent hps hpi\n  rcases ho with ⟨t, _, hts⟩\n  have hs : affineSpan ℝ s = affineSpan ℝ (Set.range t.points) := by\n    rw [hts, affineSpan_insert_eq_affineSpan ℝ t.orthocenter_mem_affineSpan]\n  refine ext_of_direction_eq ?_\n    ⟨p 0, mem_affineSpan ℝ (Set.mem_range_self _), mem_affineSpan ℝ (hps (Set.mem_range_self _))⟩\n  have hfd : FiniteDimensional ℝ (affineSpan ℝ s).direction := by rw [hs]; infer_instance\n  haveI := hfd\n  refine Submodule.eq_of_le_of_finrank_eq (direction_le (affineSpan_mono ℝ hps)) ?_\n  rw [hs, direction_affineSpan, direction_affineSpan, ha.finrank_vectorSpan (Fintype.card_fin _),\n    t.independent.finrank_vectorSpan (Fintype.card_fin _)]\n\n"}
{"name":"EuclideanGeometry.OrthocentricSystem.exists_circumradius_eq","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set P\nho : EuclideanGeometry.OrthocentricSystem s\n⊢ Exists fun r => ∀ (t : Affine.Triangle Real P), HasSubset.Subset (Set.range t.points) s → Eq (Affine.Simplex.circumradius t) r","decl":"/-- All triangles in an orthocentric system have the same circumradius. -/\ntheorem OrthocentricSystem.exists_circumradius_eq {s : Set P} (ho : OrthocentricSystem s) :\n    ∃ r : ℝ, ∀ t : Triangle ℝ P, Set.range t.points ⊆ s → t.circumradius = r := by\n  rcases ho with ⟨t, hto, hts⟩\n  use t.circumradius\n  intro t₂ ht₂\n  have ht₂s := ht₂\n  rw [hts] at ht₂\n  rcases exists_dist_eq_circumradius_of_subset_insert_orthocenter hto ht₂\n      t₂.independent.injective with\n    ⟨c, hc, h⟩\n  rw [Set.forall_mem_range] at h\n  have hs : Set.range t.points ⊆ s := by\n    rw [hts]\n    exact Set.subset_insert _ _\n  rw [affineSpan_of_orthocentricSystem ⟨t, hto, hts⟩ hs t.independent.injective,\n    ← affineSpan_of_orthocentricSystem ⟨t, hto, hts⟩ ht₂s t₂.independent.injective] at hc\n  exact (t₂.eq_circumradius_of_dist_eq hc h).symm\n\n"}
{"name":"EuclideanGeometry.OrthocentricSystem.eq_insert_orthocenter","module":"Mathlib.Geometry.Euclidean.MongePoint","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set P\nho : EuclideanGeometry.OrthocentricSystem s\nt : Affine.Triangle Real P\nht : HasSubset.Subset (Set.range t.points) s\n⊢ Eq s (Insert.insert t.orthocenter (Set.range t.points))","decl":"/-- Given any triangle in an orthocentric system, the fourth point is\nits orthocenter. -/\ntheorem OrthocentricSystem.eq_insert_orthocenter {s : Set P} (ho : OrthocentricSystem s)\n    {t : Triangle ℝ P} (ht : Set.range t.points ⊆ s) :\n    s = insert t.orthocenter (Set.range t.points) := by\n  rcases ho with ⟨t₀, ht₀o, ht₀s⟩\n  rw [ht₀s] at ht\n  rcases exists_of_range_subset_orthocentricSystem ht₀o ht t.independent.injective with\n    (⟨i₁, i₂, i₃, j₂, j₃, h₁₂, h₁₃, h₂₃, h₁₂₃, h₁, hj₂₃, h₂, h₃⟩ | hs)\n  · obtain ⟨j₁, hj₁₂, hj₁₃, hj₁₂₃⟩ :\n        ∃ j₁ : Fin 3, j₁ ≠ j₂ ∧ j₁ ≠ j₃ ∧ ∀ j : Fin 3, j = j₁ ∨ j = j₂ ∨ j = j₃ := by\n      clear h₂ h₃\n      decide +revert\n    suffices h : t₀.points j₁ = t.orthocenter by\n      have hui : (Set.univ : Set (Fin 3)) = {i₁, i₂, i₃} := by ext x; simpa using h₁₂₃ x\n      have huj : (Set.univ : Set (Fin 3)) = {j₁, j₂, j₃} := by ext x; simpa using hj₁₂₃ x\n      rw [← h, ht₀s, ← Set.image_univ, huj, ← Set.image_univ, hui]\n      simp_rw [Set.image_insert_eq, Set.image_singleton, h₁, ← h₂, ← h₃]\n      rw [Set.insert_comm]\n    exact\n      (Triangle.orthocenter_replace_orthocenter_eq_point hj₁₂ hj₁₃ hj₂₃ h₁₂ h₁₃ h₂₃ h₁ h₂.symm\n          h₃.symm).symm\n  · rw [hs]\n    convert ht₀s using 2\n    exact Triangle.orthocenter_eq_of_range_eq hs\n\n"}
