{"name":"instNonemptyUniformFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Nonempty Î²\nâŠ¢ Nonempty (UniformFun Î± Î²)","decl":"instance [Nonempty Î²] : Nonempty (Î± â†’áµ¤ Î²) := Pi.instNonempty\n\n"}
{"name":"instNonemptyUniformOnFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Nonempty Î²\nâŠ¢ Nonempty (UniformOnFun Î± Î² ğ”–)","decl":"instance [Nonempty Î²] : Nonempty (Î± â†’áµ¤[ğ”–] Î²) := Pi.instNonempty\n\n"}
{"name":"instSubsingletonUniformFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Subsingleton Î²\nâŠ¢ Subsingleton (UniformFun Î± Î²)","decl":"instance [Subsingleton Î²] : Subsingleton (Î± â†’áµ¤ Î²) :=\n  inferInstanceAs <| Subsingleton <| Î± â†’ Î²\n\n"}
{"name":"instSubsingletonUniformOnFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Subsingleton Î²\nâŠ¢ Subsingleton (UniformOnFun Î± Î² ğ”–)","decl":"instance [Subsingleton Î²] : Subsingleton (Î± â†’áµ¤[ğ”–] Î²) :=\n  inferInstanceAs <| Subsingleton <| Î± â†’ Î²\n\n"}
{"name":"UniformFun.toFun_ofFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nâŠ¢ Eq (UniformFun.toFun (UniformFun.ofFun f)) f","decl":"@[simp] lemma UniformFun.toFun_ofFun (f : Î± â†’ Î²) : toFun (ofFun f) = f := rfl\n"}
{"name":"UniformFun.ofFun_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : UniformFun Î± Î²\nâŠ¢ Eq (UniformFun.ofFun (UniformFun.toFun f)) f","decl":"@[simp] lemma UniformFun.ofFun_toFun (f : Î± â†’áµ¤ Î²) : ofFun (toFun f) = f := rfl\n"}
{"name":"UniformOnFun.toFun_ofFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\nf : Î± â†’ Î²\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) ((UniformOnFun.ofFun ğ”–) f)) f","decl":"@[simp] lemma UniformOnFun.toFun_ofFun (f : Î± â†’ Î²) : toFun ğ”– (ofFun ğ”– f) = f := rfl\n"}
{"name":"UniformOnFun.ofFun_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\nf : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) ((UniformOnFun.toFun ğ”–) f)) f","decl":"@[simp] lemma UniformOnFun.ofFun_toFun (f : Î± â†’áµ¤[ğ”–] Î²) : ofFun ğ”– (toFun ğ”– f) = f := rfl\n\n-- Note: we don't declare a `CoeFun` instance because Lean wouldn't insert it when writing\n-- `f x` (because of definitional equality with `Î± â†’ Î²`).\n"}
{"name":"UniformFun.isBasis_gen","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ“‘ : Filter (Prod Î² Î²)\nâŠ¢ Filter.IsBasis (fun V => Membership.mem ğ“‘ V) (UniformFun.gen Î± Î²)","decl":"/-- If `ğ“•` is a filter on `Î² Ã— Î²`, then the set of all `UniformFun.gen Î± Î² V` for\n`V âˆˆ ğ“•` is a filter basis on `(Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)`. This will only be applied to `ğ“• = ğ“¤ Î²` when\n`Î²` is equipped with a `UniformSpace` structure, but it is useful to define it for any filter in\norder to be able to state that it has a lower adjoint (see `UniformFun.gc`). -/\nprotected theorem isBasis_gen (ğ“‘ : Filter <| Î² Ã— Î²) :\n    IsBasis (fun V : Set (Î² Ã— Î²) => V âˆˆ ğ“‘) (UniformFun.gen Î± Î²) :=\n  âŸ¨âŸ¨univ, univ_memâŸ©, @fun U V hU hV =>\n    âŸ¨U âˆ© V, inter_mem hU hV, fun _ huv => âŸ¨fun x => (huv x).left, fun x => (huv x).rightâŸ©âŸ©âŸ©\n\n"}
{"name":"UniformFun.gc","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nâŠ¢ GaloisConnection (fun ğ“ => Filter.map (UniformFun.phi Î± Î²) (SProd.sprod ğ“ Top.top)) fun ğ“• => UniformFun.filter Î± Î² ğ“•","decl":"/-- The function `UniformFun.filter Î± Î² : Filter (Î² Ã— Î²) â†’ Filter ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²))`\nhas a lower adjoint `l` (in the sense of `GaloisConnection`). The exact definition of `l` is not\ninteresting; we will only use that it exists (in `UniformFun.mono` and\n`UniformFun.iInf_eq`) and that\n`l (Filter.map (Prod.map f f) ğ“•) = Filter.map (Prod.map ((âˆ˜) f) ((âˆ˜) f)) (l ğ“•)` for each\n`ğ“• : Filter (Î³ Ã— Î³)` and `f : Î³ â†’ Î±` (in `UniformFun.comap_eq`). -/\nprotected theorem gc : GaloisConnection lowerAdjoint fun ğ“• => UniformFun.filter Î± Î² ğ“• := by\n  intro ğ“ ğ“•\n  symm\n  calc\n    ğ“ â‰¤ UniformFun.filter Î± Î² ğ“• â†” (UniformFun.basis Î± Î² ğ“•).sets âŠ† ğ“.sets := by\n      rw [UniformFun.filter, â† FilterBasis.generate, le_generate_iff]\n    _ â†” âˆ€ U âˆˆ ğ“•, UniformFun.gen Î± Î² U âˆˆ ğ“ := image_subset_iff\n    _ â†” âˆ€ U âˆˆ ğ“•,\n          { uv | âˆ€ x, (uv, x) âˆˆ { t : ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) Ã— Î± | (t.1.1 t.2, t.1.2 t.2) âˆˆ U } } âˆˆ\n            ğ“ :=\n      Iff.rfl\n    _ â†” âˆ€ U âˆˆ ğ“•,\n          { uvx : ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) Ã— Î± | (uvx.1.1 uvx.2, uvx.1.2 uvx.2) âˆˆ U } âˆˆ\n            ğ“ Ã—Ë¢ (âŠ¤ : Filter Î±) :=\n      forallâ‚‚_congr fun U _hU => mem_prod_top.symm\n    _ â†” lowerAdjoint ğ“ â‰¤ ğ“• := Iff.rfl\n\n"}
{"name":"UniformFun.hasBasis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nâŠ¢ (uniformity (UniformFun Î± Î²)).HasBasis (fun x => Membership.mem (uniformity Î²) x) (UniformFun.gen Î± Î²)","decl":"/-- By definition, the uniformity of `Î± â†’áµ¤ Î²` admits the family `{(f, g) | âˆ€ x, (f x, g x) âˆˆ V}`\nfor `V âˆˆ ğ“¤ Î²` as a filter basis. -/\nprotected theorem hasBasis_uniformity :\n    (ğ“¤ (Î± â†’áµ¤ Î²)).HasBasis (Â· âˆˆ ğ“¤ Î²) (UniformFun.gen Î± Î²) :=\n  (UniformFun.isBasis_gen Î± Î² (ğ“¤ Î²)).hasBasis\n\n"}
{"name":"UniformFun.hasBasis_uniformity_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nÎ¹ : Sort u_5\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set (Prod Î² Î²)\nh : (uniformity Î²).HasBasis p s\nâŠ¢ (uniformity (UniformFun Î± Î²)).HasBasis p (Function.comp (UniformFun.gen Î± Î²) s)","decl":"/-- The uniformity of `Î± â†’áµ¤ Î²` admits the family `{(f, g) | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“‘` as\na filter basis, for any basis `ğ“‘` of `ğ“¤ Î²` (in the case `ğ“‘ = (ğ“¤ Î²).as_basis` this is true by\ndefinition). -/\nprotected theorem hasBasis_uniformity_of_basis {Î¹ : Sort*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}\n    (h : (ğ“¤ Î²).HasBasis p s) : (ğ“¤ (Î± â†’áµ¤ Î²)).HasBasis p (UniformFun.gen Î± Î² âˆ˜ s) :=\n  (UniformFun.hasBasis_uniformity Î± Î²).to_hasBasis\n    (fun _ hU =>\n      let âŸ¨i, hi, hiUâŸ© := h.mem_iff.mp hU\n      âŸ¨i, hi, fun _ huv x => hiU (huv x)âŸ©)\n    fun i hi => âŸ¨s i, h.mem_of_mem hi, subset_refl _âŸ©\n\n"}
{"name":"UniformFun.hasBasis_nhds_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_4\ninstâœ : UniformSpace Î²\nf : UniformFun Î± Î²\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set (Prod Î² Î²)\nh : (uniformity Î²).HasBasis p s\nâŠ¢ (nhds f).HasBasis p fun i => setOf fun g => Membership.mem (UniformFun.gen Î± Î² (s i)) { fst := f, snd := g }","decl":"/-- For `f : Î± â†’áµ¤ Î²`, `ğ“ f` admits the family `{g | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“‘` as a filter\nbasis, for any basis `ğ“‘` of `ğ“¤ Î²`. -/\nprotected theorem hasBasis_nhds_of_basis (f) {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}\n    (h : HasBasis (ğ“¤ Î²) p s) :\n    (ğ“ f).HasBasis p fun i => { g | (f, g) âˆˆ UniformFun.gen Î± Î² (s i) } :=\n  nhds_basis_uniformity' (UniformFun.hasBasis_uniformity_of_basis Î± Î² h)\n\n"}
{"name":"UniformFun.hasBasis_nhds","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nf : UniformFun Î± Î²\nâŠ¢ (nhds f).HasBasis (fun V => Membership.mem (uniformity Î²) V) fun V => setOf fun g => Membership.mem (UniformFun.gen Î± Î² V) { fst := f, snd := g }","decl":"/-- For `f : Î± â†’áµ¤ Î²`, `ğ“ f` admits the family `{g | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“¤ Î²` as a\nfilter basis. -/\nprotected theorem hasBasis_nhds (f) :\n    (ğ“ f).HasBasis (fun V => V âˆˆ ğ“¤ Î²) fun V => { g | (f, g) âˆˆ UniformFun.gen Î± Î² V } :=\n  UniformFun.hasBasis_nhds_of_basis Î± Î² f (Filter.basis_sets _)\n\n"}
{"name":"UniformFun.uniformContinuous_eval","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nx : Î±\nâŠ¢ UniformContinuous (Function.comp (Function.eval x) â‡‘UniformFun.toFun)","decl":"/-- Evaluation at a fixed point is uniformly continuous on `Î± â†’áµ¤ Î²`. -/\ntheorem uniformContinuous_eval (x : Î±) :\n    UniformContinuous (Function.eval x âˆ˜ toFun : (Î± â†’áµ¤ Î²) â†’ Î²) := by\n  change _ â‰¤ _\n  rw [map_le_iff_le_comap,\n    (UniformFun.hasBasis_uniformity Î± Î²).le_basis_iff ((ğ“¤ _).basis_sets.comap _)]\n  exact fun U hU => âŸ¨U, hU, fun uv huv => huv xâŸ©\n\n"}
{"name":"UniformFun.mem_gen","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_5\nf g : UniformFun Î± Î²\nV : Set (Prod Î² Î²)\nâŠ¢ Iff (Membership.mem (UniformFun.gen Î± Î² V) { fst := f, snd := g }) (âˆ€ (x : Î±), Membership.mem V { fst := UniformFun.toFun f x, snd := UniformFun.toFun g x })","decl":"@[simp]\nprotected lemma mem_gen {Î²} {f g : Î± â†’áµ¤ Î²} {V : Set (Î² Ã— Î²)} :\n    (f, g) âˆˆ UniformFun.gen Î± Î² V â†” âˆ€ x, (toFun f x, toFun g x) âˆˆ V :=\n  .rfl\n\n"}
{"name":"UniformFun.mono","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ³ : Type u_3\nâŠ¢ Monotone (@UniformFun.uniformSpace Î± Î³)","decl":"/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³` and `uâ‚ â‰¤ uâ‚‚`, then\n`ğ’°(Î±, Î³, uâ‚) â‰¤ ğ’°(Î±, Î³, uâ‚‚)`. -/\nprotected theorem mono : Monotone (@UniformFun.uniformSpace Î± Î³) := fun _ _ hu =>\n  (UniformFun.gc Î± Î³).monotone_u hu\n\n"}
{"name":"UniformFun.iInf_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ³ : Type u_3\nÎ¹ : Type u_4\nu : Î¹ â†’ UniformSpace Î³\nâŠ¢ Eq (UniformFun.uniformSpace Î± Î³) (iInf fun i => UniformFun.uniformSpace Î± Î³)","decl":"/-- If `u` is a family of uniform structures on `Î³`, then\n`ğ’°(Î±, Î³, (â¨… i, u i)) = â¨… i, ğ’°(Î±, Î³, u i)`. -/\nprotected theorem iInf_eq {u : Î¹ â†’ UniformSpace Î³} : ğ’°(Î±, Î³, (â¨… i, u i)) = â¨… i, ğ’°(Î±, Î³, u i) := by\n  -- This follows directly from the fact that the upper adjoint in a Galois connection maps\n  -- infimas to infimas.\n  ext : 1\n  change UniformFun.filter Î± Î³ ğ“¤[â¨… i, u i] = ğ“¤[â¨… i, ğ’°(Î±, Î³, u i)]\n  rw [iInf_uniformity, iInf_uniformity]\n  exact (UniformFun.gc Î± Î³).u_iInf\n\n"}
{"name":"UniformFun.inf_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ³ : Type u_3\nuâ‚ uâ‚‚ : UniformSpace Î³\nâŠ¢ Eq (UniformFun.uniformSpace Î± Î³) (Min.min (UniformFun.uniformSpace Î± Î³) (UniformFun.uniformSpace Î± Î³))","decl":"/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³`, then\n`ğ’°(Î±, Î³, uâ‚ âŠ“ uâ‚‚) = ğ’°(Î±, Î³, uâ‚) âŠ“ ğ’°(Î±, Î³, uâ‚‚)`. -/\nprotected theorem inf_eq {uâ‚ uâ‚‚ : UniformSpace Î³} :\n    ğ’°(Î±, Î³, uâ‚ âŠ“ uâ‚‚) = ğ’°(Î±, Î³, uâ‚) âŠ“ ğ’°(Î±, Î³, uâ‚‚) := by\n  -- This follows directly from the fact that the upper adjoint in a Galois connection maps\n  -- infimas to infimas.\n  rw [inf_eq_iInf, inf_eq_iInf, UniformFun.iInf_eq]\n  refine iInf_congr fun i => ?_\n  cases i <;> rfl\n\n"}
{"name":"UniformFun.postcomp_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ IsUniformInducing (Function.comp (â‡‘UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) â‡‘UniformFun.toFun))","decl":"/-- Post-composition by a uniform inducing function is\na uniform inducing function for the uniform structures of uniform convergence.\n\nMore precisely, if `f : Î³ â†’ Î²` is uniform inducing,\nthen `(f âˆ˜ Â·) : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)` is uniform inducing. -/\nlemma postcomp_isUniformInducing [UniformSpace Î³] {f : Î³ â†’ Î²}\n    (hf : IsUniformInducing f) : IsUniformInducing (ofFun âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun : (Î± â†’áµ¤ Î³) â†’ Î± â†’áµ¤ Î²) :=\n  âŸ¨((UniformFun.hasBasis_uniformity _ _).comap _).eq_of_same_basis <|\n    UniformFun.hasBasis_uniformity_of_basis _ _ (hf.basis_uniformity (ğ“¤ Î²).basis_sets)âŸ©\n\n"}
{"name":"UniformFun.postcomp_uniformInducing","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ IsUniformInducing (Function.comp (â‡‘UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) â‡‘UniformFun.toFun))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias postcomp_uniformInducing := postcomp_isUniformInducing\n\n"}
{"name":"UniformFun.postcomp_isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : IsUniformEmbedding f\nâŠ¢ IsUniformEmbedding (Function.comp (â‡‘UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) â‡‘UniformFun.toFun))","decl":"/-- Post-composition by a uniform embedding is\na uniform embedding for the uniform structures of uniform convergence.\n\nMore precisely, if `f : Î³ â†’ Î²` is a uniform embedding,\nthen `(f âˆ˜ Â·) : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)` is a uniform embedding. -/\nprotected theorem postcomp_isUniformEmbedding [UniformSpace Î³] {f : Î³ â†’ Î²}\n    (hf : IsUniformEmbedding f) :\n    IsUniformEmbedding (ofFun âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun : (Î± â†’áµ¤ Î³) â†’ Î± â†’áµ¤ Î²) where\n  toIsUniformInducing := UniformFun.postcomp_isUniformInducing hf.isUniformInducing\n  injective _ _ H := funext fun _ â†¦ hf.injective (congrFun H _)\n\n"}
{"name":"UniformFun.postcomp_uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : IsUniformEmbedding f\nâŠ¢ IsUniformEmbedding (Function.comp (â‡‘UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) â‡‘UniformFun.toFun))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias postcomp_uniformEmbedding := UniformFun.postcomp_isUniformEmbedding\n\n-- Porting note: had to add a type annotation at `((f âˆ˜ Â·) : ((Î± â†’ Î³) â†’ (Î± â†’ Î²)))`\n"}
{"name":"UniformFun.comap_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : UniformSpace Î²\nf : Î³ â†’ Î²\nâŠ¢ Eq (UniformFun.uniformSpace Î± Î³) (UniformSpace.comap (fun x => Function.comp f x) (UniformFun.uniformSpace Î± Î²))","decl":"/-- If `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then\n`ğ’°(Î±, Î³, comap f u) = comap (fun g â†¦ f âˆ˜ g) ğ’°(Î±, Î³, uâ‚)`. -/\nprotected theorem comap_eq {f : Î³ â†’ Î²} :\n    ğ’°(Î±, Î³, â€¹UniformSpace Î²â€º.comap f) = ğ’°(Î±, Î², _).comap (f âˆ˜ Â·) := by\n  letI : UniformSpace Î³ := .comap f â€¹_â€º\n  exact (UniformFun.postcomp_isUniformInducing (f := f) âŸ¨rflâŸ©).comap_uniformSpace.symm\n\n"}
{"name":"UniformFun.postcomp_uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : UniformContinuous f\nâŠ¢ UniformContinuous (Function.comp (â‡‘UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) â‡‘UniformFun.toFun))","decl":"/-- Post-composition by a uniformly continuous function is uniformly continuous on `Î± â†’áµ¤ Î²`.\n\nMore precisely, if `f : Î³ â†’ Î²` is uniformly continuous, then `(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)`\nis uniformly continuous. -/\nprotected theorem postcomp_uniformContinuous [UniformSpace Î³] {f : Î³ â†’ Î²}\n    (hf : UniformContinuous f) :\n    UniformContinuous (ofFun âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun : (Î± â†’áµ¤ Î³) â†’ Î± â†’áµ¤ Î²) := by\n  -- This is a direct consequence of `UniformFun.comap_eq`\n    refine uniformContinuous_iff.mpr ?_\n    exact (UniformFun.mono (uniformContinuous_iff.mp hf)).trans_eq UniformFun.comap_eq\n    -- Porting note: the original calc proof below gives a deterministic timeout\n    --calc\n    --  ğ’°(Î±, Î³, _) â‰¤ ğ’°(Î±, Î³, â€¹UniformSpace Î²â€º.comap f) :=\n    --    UniformFun.mono (uniformContinuous_iff.mp hf)\n    --  _ = ğ’°(Î±, Î², _).comap (f âˆ˜ Â·) := @UniformFun.comap_eq Î± Î² Î³ _ f\n\n"}
{"name":"UniformFun.precomp_uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : UniformSpace Î²\nf : Î³ â†’ Î±\nâŠ¢ UniformContinuous fun g => UniformFun.ofFun (Function.comp (UniformFun.toFun g) f)","decl":"/-- Pre-composition by any function is uniformly continuous for the uniform structures of\nuniform convergence.\n\nMore precisely, for any `f : Î³ â†’ Î±`, the function `(Â· âˆ˜ f) : (Î± â†’áµ¤ Î²) â†’ (Î³ â†’áµ¤ Î²)` is uniformly\ncontinuous. -/\nprotected theorem precomp_uniformContinuous {f : Î³ â†’ Î±} :\n    UniformContinuous fun g : Î± â†’áµ¤ Î² => ofFun (toFun g âˆ˜ f) := by\n  -- Here we simply go back to filter bases.\n  rw [UniformContinuous,\n      (UniformFun.hasBasis_uniformity Î± Î²).tendsto_iff (UniformFun.hasBasis_uniformity Î³ Î²)]\n  exact fun U hU => âŸ¨U, hU, fun uv huv x => huv (f x)âŸ©\n\n"}
{"name":"UniformFun.uniformContinuous_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nâŠ¢ UniformContinuous â‡‘UniformFun.toFun","decl":"/-- The natural map `UniformFun.toFun` from `Î± â†’áµ¤ Î²` to `Î± â†’ Î²` is uniformly continuous.\n\nIn other words, the uniform structure of uniform convergence is finer than that of pointwise\nconvergence, aka the product uniform structure. -/\nprotected theorem uniformContinuous_toFun : UniformContinuous (toFun : (Î± â†’áµ¤ Î²) â†’ Î± â†’ Î²) := by\n  -- By definition of the product uniform structure, this is just `uniform_continuous_eval`.\n  rw [uniformContinuous_pi]\n  intro x\n  exact uniformContinuous_eval Î² x\n\n"}
{"name":"UniformFun.instT2Space","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : T2Space Î²\nâŠ¢ T2Space (UniformFun Î± Î²)","decl":"/-- The topology of uniform convergence is Tâ‚‚. -/\ninstance [T2Space Î²] : T2Space (Î± â†’áµ¤ Î²) :=\n  .of_injective_continuous toFun.injective UniformFun.uniformContinuous_toFun.continuous\n\n"}
{"name":"UniformFun.tendsto_iff_tendstoUniformly","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_4\np : Filter Î¹\ninstâœ : UniformSpace Î²\nF : Î¹ â†’ UniformFun Î± Î²\nf : UniformFun Î± Î²\nâŠ¢ Iff (Filter.Tendsto F p (nhds f)) (TendstoUniformly (Function.comp (â‡‘UniformFun.toFun) F) (UniformFun.toFun f) p)","decl":"/-- The topology of uniform convergence indeed gives the same notion of convergence as\n`TendstoUniformly`. -/\nprotected theorem tendsto_iff_tendstoUniformly {F : Î¹ â†’ Î± â†’áµ¤ Î²} {f : Î± â†’áµ¤ Î²} :\n    Tendsto F p (ğ“ f) â†” TendstoUniformly (toFun âˆ˜ F) (toFun f) p := by\n  rw [(UniformFun.hasBasis_nhds Î± Î² f).tendsto_right_iff, TendstoUniformly]\n  simp only [mem_setOf, UniformFun.gen, Function.comp_def]\n\n"}
{"name":"UniformFun.isClosed_setOf_continuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : TopologicalSpace Î±\nâŠ¢ IsClosed (setOf fun f => Continuous (UniformFun.toFun f))","decl":"/-- The set of continuous functions is closed in the uniform convergence topology.\nThis is a simple wrapper over `TendstoUniformly.continuous`. -/\ntheorem isClosed_setOf_continuous [TopologicalSpace Î±] :\n    IsClosed {f : Î± â†’áµ¤ Î² | Continuous (toFun f)} := by\n  refine isClosed_iff_forall_filter.2 fun f u _ hu huf â†¦ ?_\n  rw [â† tendsto_id', UniformFun.tendsto_iff_tendstoUniformly] at huf\n  exact huf.continuous (le_principal_iff.mp hu)\n\n"}
{"name":"UniformFun.uniformSpace_eq_inf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nÎ´â‚ : Type u_6\nÎ´â‚‚ : Type u_7\nÏ†â‚ : Î´â‚ â†’ Î±\nÏ†â‚‚ : Î´â‚‚ â†’ Î±\nh_cover : Eq (Union.union (Set.range Ï†â‚) (Set.range Ï†â‚‚)) Set.univ\nâŠ¢ Eq (UniformFun.uniformSpace Î± Î²) (Min.min (UniformSpace.comap (Function.comp (â‡‘UniformFun.ofFun) (Function.comp (fun x => Function.comp x Ï†â‚) â‡‘UniformFun.toFun)) (UniformFun.uniformSpace Î´â‚ Î²)) (UniformSpace.comap (Function.comp (â‡‘UniformFun.ofFun) (Function.comp (fun x => Function.comp x Ï†â‚‚) â‡‘UniformFun.toFun)) (UniformFun.uniformSpace Î´â‚‚ Î²)))","decl":"variable {Î±} (Î²) in\ntheorem uniformSpace_eq_inf_precomp_of_cover {Î´â‚ Î´â‚‚ : Type*} (Ï†â‚ : Î´â‚ â†’ Î±) (Ï†â‚‚ : Î´â‚‚ â†’ Î±)\n    (h_cover : range Ï†â‚ âˆª range Ï†â‚‚ = univ) :\n    ğ’°(Î±, Î², _) =\n      .comap (ofFun âˆ˜ (Â· âˆ˜ Ï†â‚) âˆ˜ toFun) ğ’°(Î´â‚, Î², _) âŠ“\n      .comap (ofFun âˆ˜ (Â· âˆ˜ Ï†â‚‚) âˆ˜ toFun) ğ’°(Î´â‚‚, Î², _) := by\n  ext : 1\n  refine le_antisymm (le_inf ?_ ?_) ?_\n  Â· exact tendsto_iff_comap.mp UniformFun.precomp_uniformContinuous\n  Â· exact tendsto_iff_comap.mp UniformFun.precomp_uniformContinuous\n  Â· refine\n      (UniformFun.hasBasis_uniformity Î´â‚ Î² |>.comap _).inf\n      (UniformFun.hasBasis_uniformity Î´â‚‚ Î² |>.comap _)\n        |>.le_basis_iff (UniformFun.hasBasis_uniformity Î± Î²) |>.mpr fun U hU â†¦\n        âŸ¨âŸ¨U, UâŸ©, âŸ¨hU, hUâŸ©, fun âŸ¨f, gâŸ© hfg x â†¦ ?_âŸ©\n    rcases h_cover.ge <| mem_univ x with (âŸ¨y, rflâŸ©|âŸ¨y, rflâŸ©)\n    Â· exact hfg.1 y\n    Â· exact hfg.2 y\n\n"}
{"name":"UniformFun.uniformSpace_eq_iInf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_4\ninstâœ : UniformSpace Î²\nÎ´ : Î¹ â†’ Type u_6\nÏ† : (i : Î¹) â†’ Î´ i â†’ Î±\nh_cover : Exists fun I => And I.Finite (Eq (Set.iUnion fun i => Set.iUnion fun h => Set.range (Ï† i)) Set.univ)\nâŠ¢ Eq (UniformFun.uniformSpace Î± Î²) (iInf fun i => UniformSpace.comap (Function.comp (â‡‘UniformFun.ofFun) (Function.comp (fun x => Function.comp x (Ï† i)) â‡‘UniformFun.toFun)) (UniformFun.uniformSpace (Î´ i) Î²))","decl":"variable {Î±} (Î²) in\ntheorem uniformSpace_eq_iInf_precomp_of_cover {Î´ : Î¹ â†’ Type*} (Ï† : Î  i, Î´ i â†’ Î±)\n    (h_cover : âˆƒ I : Set Î¹, I.Finite âˆ§ â‹ƒ i âˆˆ I, range (Ï† i) = univ) :\n    ğ’°(Î±, Î², _) = â¨… i, .comap (ofFun âˆ˜ (Â· âˆ˜ Ï† i) âˆ˜ toFun) ğ’°(Î´ i, Î², _) := by\n  ext : 1\n  simp_rw [iInf_uniformity, uniformity_comap]\n  refine le_antisymm (le_iInf fun i â†¦ tendsto_iff_comap.mp UniformFun.precomp_uniformContinuous) ?_\n  rcases h_cover with âŸ¨I, I_finite, I_coverâŸ©\n  refine Filter.hasBasis_iInf (fun i : Î¹ â†¦ UniformFun.hasBasis_uniformity (Î´ i) Î² |>.comap _)\n      |>.le_basis_iff (UniformFun.hasBasis_uniformity Î± Î²) |>.mpr fun U hU â†¦\n    âŸ¨âŸ¨I, fun _ â†¦ UâŸ©, âŸ¨I_finite, fun _ â†¦ hUâŸ©, fun âŸ¨f, gâŸ© hfg x â†¦ ?_âŸ©\n  rcases mem_iUnionâ‚‚.mp <| I_cover.ge <| mem_univ x with âŸ¨i, hi, y, rflâŸ©\n  exact mem_iInter.mp hfg âŸ¨i, hiâŸ© y\n\n"}
{"name":"UniformOnFun.gen_eq_preimage_restrict","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\nS : Set Î±\nV : Set (Prod Î² Î²)\nâŠ¢ Eq (UniformOnFun.gen ğ”– S V) (Set.preimage (Prod.map (Function.comp S.restrict â‡‘UniformFun.toFun) (Function.comp S.restrict â‡‘UniformFun.toFun)) (UniformFun.gen (â†‘S) Î² V))","decl":"/-- For `S : Set Î±` and `V : Set (Î² Ã— Î²)`, we have\n`UniformOnFun.gen ğ”– S V = (S.restrict Ã— S.restrict) â»Â¹' (UniformFun.gen S Î² V)`.\nThis is the crucial fact for proving that the family `UniformOnFun.gen S V` for `S âˆˆ ğ”–` and\n`V âˆˆ ğ“¤ Î²` is indeed a basis for the uniformity `Î± â†’áµ¤[ğ”–] Î²` endowed with `ğ’±(Î±, Î², ğ”–, uÎ²)`\nthe uniform structure of `ğ”–`-convergence, as defined in `UniformOnFun.uniformSpace`. -/\nprotected theorem gen_eq_preimage_restrict {ğ”–} (S : Set Î±) (V : Set (Î² Ã— Î²)) :\n    UniformOnFun.gen ğ”– S V =\n      Prod.map (S.restrict âˆ˜ UniformFun.toFun) (S.restrict âˆ˜ UniformFun.toFun) â»Â¹'\n        UniformFun.gen S Î² V := by\n  ext uv\n  exact âŸ¨fun h âŸ¨x, hxâŸ© => h x hx, fun h x hx => h âŸ¨x, hxâŸ©âŸ©\n\n"}
{"name":"UniformOnFun.gen_mono","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\nS S' : Set Î±\nV V' : Set (Prod Î² Î²)\nhS : HasSubset.Subset S' S\nhV : HasSubset.Subset V V'\nâŠ¢ HasSubset.Subset (UniformOnFun.gen ğ”– S V) (UniformOnFun.gen ğ”– S' V')","decl":"/-- `UniformOnFun.gen` is antitone in the first argument and monotone in the second. -/\nprotected theorem gen_mono {ğ”–} {S S' : Set Î±} {V V' : Set (Î² Ã— Î²)} (hS : S' âŠ† S) (hV : V âŠ† V') :\n    UniformOnFun.gen ğ”– S V âŠ† UniformOnFun.gen ğ”– S' V' := fun _uv h x hx => hV (h x <| hS hx)\n\n"}
{"name":"UniformOnFun.isBasis_gen","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\nh : ğ”–.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\nğ“‘ : FilterBasis (Prod Î² Î²)\nâŠ¢ Filter.IsBasis (fun SV => And (Membership.mem ğ”– SV.1) (Membership.mem ğ“‘ SV.2)) fun SV => UniformOnFun.gen ğ”– SV.1 SV.2","decl":"/-- If `ğ”– : Set (Set Î±)` is nonempty and directed and `ğ“‘` is a filter basis on `Î² Ã— Î²`, then the\nfamily `UniformOnFun.gen ğ”– S V` for `S âˆˆ ğ”–` and `V âˆˆ ğ“‘` is a filter basis on\n`(Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î²)`.\nWe will show in `has_basis_uniformity_of_basis` that, if `ğ“‘` is a basis for `ğ“¤ Î²`, then the\ncorresponding filter is the uniformity of `Î± â†’áµ¤[ğ”–] Î²`. -/\nprotected theorem isBasis_gen (ğ”– : Set (Set Î±)) (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–)\n    (ğ“‘ : FilterBasis <| Î² Ã— Î²) :\n    IsBasis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“‘) fun SV =>\n      UniformOnFun.gen ğ”– SV.1 SV.2 :=\n  âŸ¨h.prod ğ“‘.nonempty, fun {Uâ‚Vâ‚ Uâ‚‚Vâ‚‚} hâ‚ hâ‚‚ =>\n    let âŸ¨Uâ‚ƒ, hUâ‚ƒ, hUâ‚â‚ƒ, hUâ‚‚â‚ƒâŸ© := h' Uâ‚Vâ‚.1 hâ‚.1 Uâ‚‚Vâ‚‚.1 hâ‚‚.1\n    let âŸ¨Vâ‚ƒ, hVâ‚ƒ, hVâ‚â‚‚â‚ƒâŸ© := ğ“‘.inter_sets hâ‚.2 hâ‚‚.2\n    âŸ¨âŸ¨Uâ‚ƒ, Vâ‚ƒâŸ©,\n      âŸ¨âŸ¨hUâ‚ƒ, hVâ‚ƒâŸ©, fun _ H =>\n        âŸ¨fun x hx => (hVâ‚â‚‚â‚ƒ <| H x <| hUâ‚â‚ƒ hx).1, fun x hx => (hVâ‚â‚‚â‚ƒ <| H x <| hUâ‚‚â‚ƒ hx).2âŸ©âŸ©âŸ©âŸ©\n\n"}
{"name":"UniformOnFun.topologicalSpace_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nâŠ¢ Eq (UniformOnFun.topologicalSpace Î± Î² ğ”–) (iInf fun s => iInf fun x => TopologicalSpace.induced (Function.comp (â‡‘UniformFun.ofFun) (Function.comp s.restrict â‡‘(UniformOnFun.toFun ğ”–))) (UniformFun.topologicalSpace (â†‘s) Î²))","decl":"/-- The topology of `ğ”–`-convergence is the infimum, for `S âˆˆ ğ”–`, of topology induced by the map\nof `S.restrict : (Î± â†’áµ¤[ğ”–] Î²) â†’ (â†¥S â†’áµ¤ Î²)` of restriction to `S`, where `â†¥S â†’áµ¤ Î²` is endowed with\nthe topology of uniform convergence. -/\nprotected theorem topologicalSpace_eq :\n    UniformOnFun.topologicalSpace Î± Î² ğ”– =\n      â¨… (s : Set Î±) (_ : s âˆˆ ğ”–), TopologicalSpace.induced\n        (UniformFun.ofFun âˆ˜ s.restrict âˆ˜ toFun ğ”–) (UniformFun.topologicalSpace s Î²) := by\n  simp only [UniformOnFun.topologicalSpace, UniformSpace.toTopologicalSpace_iInf]\n  rfl\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_4\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set (Prod Î² Î²)\nhb : (uniformity Î²).HasBasis p s\nS : Set Î±\nâŠ¢ (uniformity (UniformOnFun Î± Î² ğ”–)).HasBasis p fun i => UniformOnFun.gen ğ”– S (s i)","decl":"protected theorem hasBasis_uniformity_of_basis_auxâ‚ {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)}\n    (hb : HasBasis (ğ“¤ Î²) p s) (S : Set Î±) :\n    (@uniformity (Î± â†’áµ¤[ğ”–] Î²) ((UniformFun.uniformSpace S Î²).comap S.restrict)).HasBasis p fun i =>\n      UniformOnFun.gen ğ”– S (s i) := by\n  simp_rw [UniformOnFun.gen_eq_preimage_restrict, uniformity_comap]\n  exact (UniformFun.hasBasis_uniformity_of_basis S Î² hb).comap _\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚‚","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_4\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nh : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set (Prod Î² Î²)\nhb : (uniformity Î²).HasBasis p s\nâŠ¢ DirectedOn (Order.Preimage (fun s => UniformSpace.comap s.restrict (UniformFun.uniformSpace (â†‘s) Î²)) GE.ge) ğ”–","decl":"protected theorem hasBasis_uniformity_of_basis_auxâ‚‚ (h : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop}\n    {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis (ğ“¤ Î²) p s) :\n    DirectedOn\n      ((fun s : Set Î± => (UniformFun.uniformSpace s Î²).comap (s.restrict : (Î± â†’áµ¤ Î²) â†’ s â†’áµ¤ Î²)) â»Â¹'o\n        GE.ge)\n      ğ”– :=\n  h.mono fun _ _ hst =>\n    ((UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb _).le_basis_iff\n          (UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb _)).mpr\n      fun V hV => âŸ¨V, hV, UniformOnFun.gen_mono hst subset_rflâŸ©\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_4\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nh : ğ”–.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set (Prod Î² Î²)\nhb : (uniformity Î²).HasBasis p s\nâŠ¢ (uniformity (UniformOnFun Î± Î² ğ”–)).HasBasis (fun Si => And (Membership.mem ğ”– Si.1) (p Si.2)) fun Si => UniformOnFun.gen ğ”– Si.1 (s Si.2)","decl":"/-- If `ğ”– : Set (Set Î±)` is nonempty and directed and `ğ“‘` is a filter basis of `ğ“¤ Î²`, then the\nuniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the family `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and\n`V âˆˆ ğ“‘` as a filter basis. -/\nprotected theorem hasBasis_uniformity_of_basis (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–)\n    {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis (ğ“¤ Î²) p s) :\n    (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).HasBasis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2) fun Si =>\n      UniformOnFun.gen ğ”– Si.1 (s Si.2) := by\n  simp only [iInf_uniformity]\n  exact\n    hasBasis_biInf_of_directed h (fun S => UniformOnFun.gen ğ”– S âˆ˜ s) _\n      (fun S _hS => UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb S)\n      (UniformOnFun.hasBasis_uniformity_of_basis_auxâ‚‚ Î± Î² ğ”– h' hb)\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nh : ğ”–.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\nâŠ¢ (uniformity (UniformOnFun Î± Î² ğ”–)).HasBasis (fun SV => And (Membership.mem ğ”– SV.1) (Membership.mem (uniformity Î²) SV.2)) fun SV => UniformOnFun.gen ğ”– SV.1 SV.2","decl":"/-- If `ğ”– : Set (Set Î±)` is nonempty and directed, then the uniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the\nfamily `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. -/\nprotected theorem hasBasis_uniformity (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) :\n    (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).HasBasis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²) fun SV =>\n      UniformOnFun.gen ğ”– SV.1 SV.2 :=\n  UniformOnFun.hasBasis_uniformity_of_basis Î± Î² ğ”– h h' (ğ“¤ Î²).basis_sets\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity_of_covering_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\nÎ¹ : Type u_5\nÎ¹' : Type u_6\ninstâœ : Nonempty Î¹\nt : Î¹ â†’ Set Î±\np : Î¹' â†’ Prop\nV : Î¹' â†’ Set (Prod Î² Î²)\nht : âˆ€ (i : Î¹), Membership.mem ğ”– (t i)\nhdir : Directed (fun x1 x2 => HasSubset.Subset x1 x2) t\nhex : âˆ€ (s : Set Î±), Membership.mem ğ”– s â†’ Exists fun i => HasSubset.Subset s (t i)\nhb : (uniformity Î²).HasBasis p V\nâŠ¢ (uniformity (UniformOnFun Î± Î² ğ”–)).HasBasis (fun i => p i.2) fun i => UniformOnFun.gen ğ”– (t i.1) (V i.2)","decl":"/-- Let `t i` be a nonempty directed subfamily of `ğ”–`\nsuch that every `s âˆˆ ğ”–` is included in some `t i`.\nLet `V` bounded by `p` be a basis of entourages of `Î²`.\n\nThen `UniformOnFun.gen ğ”– (t i) (V j)` bounded by `p j` is a basis of entourages of `Î± â†’áµ¤[ğ”–] Î²`. -/\nprotected theorem hasBasis_uniformity_of_covering_of_basis {Î¹ Î¹' : Type*} [Nonempty Î¹]\n    {t : Î¹ â†’ Set Î±} {p : Î¹' â†’ Prop} {V : Î¹' â†’ Set (Î² Ã— Î²)} (ht : âˆ€ i, t i âˆˆ ğ”–)\n    (hdir : Directed (Â· âŠ† Â·) t) (hex : âˆ€ s âˆˆ ğ”–, âˆƒ i, s âŠ† t i) (hb : HasBasis (ğ“¤ Î²) p V) :\n    (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).HasBasis (fun i : Î¹ Ã— Î¹' â†¦ p i.2) fun i â†¦\n      UniformOnFun.gen ğ”– (t i.1) (V i.2) := by\n  have hne : ğ”–.Nonempty := (range_nonempty t).mono (range_subset_iff.2 ht)\n  have hd : DirectedOn (Â· âŠ† Â·) ğ”– := fun sâ‚ hsâ‚ sâ‚‚ hsâ‚‚ â†¦ by\n    rcases hex sâ‚ hsâ‚, hex sâ‚‚ hsâ‚‚ with âŸ¨âŸ¨iâ‚, hisâ‚âŸ©, iâ‚‚, hisâ‚‚âŸ©\n    rcases hdir iâ‚ iâ‚‚ with âŸ¨i, hiâ‚, hiâ‚‚âŸ©\n    exact âŸ¨t i, ht _, hisâ‚.trans hiâ‚, hisâ‚‚.trans hiâ‚‚âŸ©\n  refine (UniformOnFun.hasBasis_uniformity_of_basis Î± Î² ğ”– hne hd hb).to_hasBasis\n    (fun âŸ¨s, i'âŸ© âŸ¨hs, hi'âŸ© â†¦ ?_) fun âŸ¨i, i'âŸ© hi' â†¦ âŸ¨(t i, i'), âŸ¨ht i, hi'âŸ©, Subset.rflâŸ©\n  rcases hex s hs with âŸ¨i, hiâŸ©\n  exact âŸ¨(i, i'), hi', UniformOnFun.gen_mono hi Subset.rflâŸ©\n\n"}
{"name":"UniformOnFun.hasAntitoneBasis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î²\nğ”– : Set (Set Î±)\nÎ¹ : Type u_5\ninstâœÂ¹ : Preorder Î¹\ninstâœ : IsDirected Î¹ fun x1 x2 => LE.le x1 x2\nt : Î¹ â†’ Set Î±\nV : Î¹ â†’ Set (Prod Î² Î²)\nht : âˆ€ (n : Î¹), Membership.mem ğ”– (t n)\nhmono : Monotone t\nhex : âˆ€ (s : Set Î±), Membership.mem ğ”– s â†’ Exists fun n => HasSubset.Subset s (t n)\nhb : (uniformity Î²).HasAntitoneBasis V\nâŠ¢ (uniformity (UniformOnFun Î± Î² ğ”–)).HasAntitoneBasis fun n => UniformOnFun.gen ğ”– (t n) (V n)","decl":"/-- If `t n` is a monotone sequence of sets in `ğ”–`\nsuch that each `s âˆˆ ğ”–` is included in some `t n`\nand `V n` is an antitone basis of entourages of `Î²`,\nthen `UniformOnFun.gen ğ”– (t n) (V n)` is an antitone basis of entourages of `Î± â†’áµ¤[ğ”–] Î²`. -/\nprotected theorem hasAntitoneBasis_uniformity {Î¹ : Type*} [Preorder Î¹] [IsDirected Î¹ (Â· â‰¤ Â·)]\n    {t : Î¹ â†’ Set Î±} {V : Î¹ â†’ Set (Î² Ã— Î²)}\n    (ht : âˆ€ n, t n âˆˆ ğ”–) (hmono : Monotone t) (hex : âˆ€ s âˆˆ ğ”–, âˆƒ n, s âŠ† t n)\n    (hb : HasAntitoneBasis (ğ“¤ Î²) V) :\n    (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).HasAntitoneBasis fun n â†¦ UniformOnFun.gen ğ”– (t n) (V n) := by\n  have := hb.nonempty\n  refine âŸ¨(UniformOnFun.hasBasis_uniformity_of_covering_of_basis ğ”–\n    ht hmono.directed_le hex hb.1).to_hasBasis ?_ fun i _ â†¦ âŸ¨(i, i), trivial, Subset.rflâŸ©, ?_âŸ©\n  Â· rintro âŸ¨k, lâŸ© -\n    rcases directed_of (Â· â‰¤ Â·) k l with âŸ¨n, hkn, hlnâŸ©\n    exact âŸ¨n, trivial, UniformOnFun.gen_mono (hmono hkn) (hb.2 <| hln)âŸ©\n  Â· exact fun k l h â†¦ UniformOnFun.gen_mono (hmono h) (hb.2 h)\n\n"}
{"name":"UniformOnFun.isCountablyGenerated_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : (uniformity Î²).IsCountablyGenerated\nt : Nat â†’ Set Î±\nht : âˆ€ (n : Nat), Membership.mem ğ”– (t n)\nhmono : Monotone t\nhex : âˆ€ (s : Set Î±), Membership.mem ğ”– s â†’ Exists fun n => HasSubset.Subset s (t n)\nâŠ¢ (uniformity (UniformOnFun Î± Î² ğ”–)).IsCountablyGenerated","decl":"protected theorem isCountablyGenerated_uniformity [IsCountablyGenerated (ğ“¤ Î²)] {t : â„• â†’ Set Î±}\n    (ht : âˆ€ n, t n âˆˆ ğ”–) (hmono : Monotone t) (hex : âˆ€ s âˆˆ ğ”–, âˆƒ n, s âŠ† t n) :\n    IsCountablyGenerated (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)) :=\n  let âŸ¨_V, hVâŸ© := exists_antitone_basis (ğ“¤ Î²)\n  (UniformOnFun.hasAntitoneBasis_uniformity ğ”– ht hmono hex hV).isCountablyGenerated\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_4\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nf : UniformOnFun Î± Î² ğ”–\nh : ğ”–.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set (Prod Î² Î²)\nhb : (uniformity Î²).HasBasis p s\nâŠ¢ (nhds f).HasBasis (fun Si => And (Membership.mem ğ”– Si.1) (p Si.2)) fun Si => setOf fun g => Membership.mem (UniformOnFun.gen ğ”– Si.1 (s Si.2)) { fst := g, snd := f }","decl":"/-- For `f : Î± â†’áµ¤[ğ”–] Î²`, where `ğ”– : Set (Set Î±)` is nonempty and directed, `ğ“ f` admits the\nfamily `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“‘` as a filter basis, for any basis\n`ğ“‘` of `ğ“¤ Î²`. -/\nprotected theorem hasBasis_nhds_of_basis (f : Î± â†’áµ¤[ğ”–] Î²) (h : ğ”–.Nonempty)\n    (h' : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set (Î² Ã— Î²)} (hb : HasBasis (ğ“¤ Î²) p s) :\n    (ğ“ f).HasBasis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2) fun Si =>\n      { g | (g, f) âˆˆ UniformOnFun.gen ğ”– Si.1 (s Si.2) } :=\n  letI : UniformSpace (Î± â†’ Î²) := UniformOnFun.uniformSpace Î± Î² ğ”–\n  nhds_basis_uniformity (UniformOnFun.hasBasis_uniformity_of_basis Î± Î² ğ”– h h' hb)\n\n"}
{"name":"UniformOnFun.hasBasis_nhds","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nf : UniformOnFun Î± Î² ğ”–\nh : ğ”–.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\nâŠ¢ (nhds f).HasBasis (fun SV => And (Membership.mem ğ”– SV.1) (Membership.mem (uniformity Î²) SV.2)) fun SV => setOf fun g => Membership.mem (UniformOnFun.gen ğ”– SV.1 SV.2) { fst := g, snd := f }","decl":"/-- For `f : Î± â†’áµ¤[ğ”–] Î²`, where `ğ”– : Set (Set Î±)` is nonempty and directed, `ğ“ f` admits the\nfamily `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. -/\nprotected theorem hasBasis_nhds (f : Î± â†’áµ¤[ğ”–] Î²) (h : ğ”–.Nonempty) (h' : DirectedOn (Â· âŠ† Â·) ğ”–) :\n    (ğ“ f).HasBasis (fun SV : Set Î± Ã— Set (Î² Ã— Î²) => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²) fun SV =>\n      { g | (g, f) âˆˆ UniformOnFun.gen ğ”– SV.1 SV.2 } :=\n  UniformOnFun.hasBasis_nhds_of_basis Î± Î² ğ”– f h h' (Filter.basis_sets _)\n\n"}
{"name":"UniformOnFun.uniformContinuous_restrict","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nh : Membership.mem ğ”– s\nâŠ¢ UniformContinuous (Function.comp (â‡‘UniformFun.ofFun) (Function.comp s.restrict â‡‘(UniformOnFun.toFun ğ”–)))","decl":"/-- If `S âˆˆ ğ”–`, then the restriction to `S` is a uniformly continuous map from `Î± â†’áµ¤[ğ”–] Î²` to\n`â†¥S â†’áµ¤ Î²`. -/\nprotected theorem uniformContinuous_restrict (h : s âˆˆ ğ”–) :\n    UniformContinuous (UniformFun.ofFun âˆ˜ (s.restrict : (Î± â†’ Î²) â†’ s â†’ Î²) âˆ˜ toFun ğ”–) := by\n  change _ â‰¤ _\n  simp only [UniformOnFun.uniformSpace, map_le_iff_le_comap, iInf_uniformity]\n  exact iInfâ‚‚_le s h\n\n"}
{"name":"UniformOnFun.uniformity_eq_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nÎ¹ : Sort u_5\np : Î¹ â†’ Prop\nV : Î¹ â†’ Set (Prod Î² Î²)\nh : (uniformity Î²).HasBasis p V\nâŠ¢ Eq (uniformity (UniformOnFun Î± Î² ğ”–)) (iInf fun s => iInf fun h => iInf fun i => iInf fun x => Filter.principal (UniformOnFun.gen ğ”– s (V i)))","decl":"/-- A version of `UniformOnFun.hasBasis_uniformity_of_basis`\nwith weaker conclusion and weaker assumptions.\n\nWe make no assumptions about the set `ğ”–`\nbut conclude only that the uniformity is equal to some indexed infimum. -/\nprotected theorem uniformity_eq_of_basis {Î¹ : Sort*} {p : Î¹ â†’ Prop} {V : Î¹ â†’ Set (Î² Ã— Î²)}\n    (h : (ğ“¤ Î²).HasBasis p V) :\n    ğ“¤ (Î± â†’áµ¤[ğ”–] Î²) = â¨… s âˆˆ ğ”–, â¨… (i) (_ : p i), ğ“Ÿ (UniformOnFun.gen ğ”– s (V i)) := by\n  simp_rw [iInf_uniformity, uniformity_comap,\n    (UniformFun.hasBasis_uniformity_of_basis _ _ h).eq_biInf, comap_iInf, comap_principal,\n    Function.comp_apply, UniformFun.gen, Subtype.forall, UniformOnFun.gen, preimage_setOf_eq,\n    Prod.map_fst, Prod.map_snd, Function.comp_apply, UniformFun.toFun_ofFun, restrict_apply]\n\n"}
{"name":"UniformOnFun.uniformity_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nâŠ¢ Eq (uniformity (UniformOnFun Î± Î² ğ”–)) (iInf fun s => iInf fun h => iInf fun V => iInf fun h => Filter.principal (UniformOnFun.gen ğ”– s V))","decl":"protected theorem uniformity_eq : ğ“¤ (Î± â†’áµ¤[ğ”–] Î²) = â¨… s âˆˆ ğ”–, â¨… V âˆˆ ğ“¤ Î², ğ“Ÿ (UniformOnFun.gen ğ”– s V) :=\n  UniformOnFun.uniformity_eq_of_basis _ _ (ğ“¤ Î²).basis_sets\n\n"}
{"name":"UniformOnFun.gen_mem_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nhs : Membership.mem ğ”– s\nV : Set (Prod Î² Î²)\nhV : Membership.mem (uniformity Î²) V\nâŠ¢ Membership.mem (uniformity (UniformOnFun Î± Î² ğ”–)) (UniformOnFun.gen ğ”– s V)","decl":"protected theorem gen_mem_uniformity (hs : s âˆˆ ğ”–) {V : Set (Î² Ã— Î²)} (hV : V âˆˆ ğ“¤ Î²) :\n    UniformOnFun.gen ğ”– s V âˆˆ ğ“¤ (Î± â†’áµ¤[ğ”–] Î²) := by\n  rw [UniformOnFun.uniformity_eq]\n  apply_rules [mem_iInf_of_mem, mem_principal_self]\n\n"}
{"name":"UniformOnFun.nhds_eq_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nÎ¹ : Sort u_5\np : Î¹ â†’ Prop\nV : Î¹ â†’ Set (Prod Î² Î²)\nh : (uniformity Î²).HasBasis p V\nf : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq (nhds f) (iInf fun s => iInf fun h => iInf fun i => iInf fun x => Filter.principal (setOf fun g => âˆ€ (x : Î±), Membership.mem s x â†’ Membership.mem (V i) { fst := (UniformOnFun.toFun ğ”–) f x, snd := (UniformOnFun.toFun ğ”–) g x }))","decl":"/-- A version of `UniformOnFun.hasBasis_nhds_of_basis`\nwith weaker conclusion and weaker assumptions.\n\nWe make no assumptions about the set `ğ”–`\nbut conclude only that the neighbourhoods filter is equal to some indexed infimum. -/\nprotected theorem nhds_eq_of_basis {Î¹ : Sort*} {p : Î¹ â†’ Prop} {V : Î¹ â†’ Set (Î² Ã— Î²)}\n    (h : (ğ“¤ Î²).HasBasis p V) (f : Î± â†’áµ¤[ğ”–] Î²) :\n    ğ“ f = â¨… s âˆˆ ğ”–, â¨… (i) (_ : p i), ğ“Ÿ {g | âˆ€ x âˆˆ s, (toFun ğ”– f x, toFun ğ”– g x) âˆˆ V i} := by\n  simp_rw [nhds_eq_comap_uniformity, UniformOnFun.uniformity_eq_of_basis _ _ h, comap_iInf,\n    comap_principal, UniformOnFun.gen, preimage_setOf_eq]\n\n"}
{"name":"UniformOnFun.nhds_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nf : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq (nhds f) (iInf fun s => iInf fun h => iInf fun V => iInf fun h => Filter.principal (setOf fun g => âˆ€ (x : Î±), Membership.mem s x â†’ Membership.mem V { fst := (UniformOnFun.toFun ğ”–) f x, snd := (UniformOnFun.toFun ğ”–) g x }))","decl":"protected theorem nhds_eq (f : Î± â†’áµ¤[ğ”–] Î²) :\n    ğ“ f = â¨… s âˆˆ ğ”–, â¨… V âˆˆ ğ“¤ Î², ğ“Ÿ {g | âˆ€ x âˆˆ s, (toFun ğ”– f x, toFun ğ”– g x) âˆˆ V} :=\n  UniformOnFun.nhds_eq_of_basis _ _ (ğ“¤ Î²).basis_sets f\n\n"}
{"name":"UniformOnFun.gen_mem_nhds","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nf : UniformOnFun Î± Î² ğ”–\nhs : Membership.mem ğ”– s\nV : Set (Prod Î² Î²)\nhV : Membership.mem (uniformity Î²) V\nâŠ¢ Membership.mem (nhds f) (setOf fun g => âˆ€ (x : Î±), Membership.mem s x â†’ Membership.mem V { fst := (UniformOnFun.toFun ğ”–) f x, snd := (UniformOnFun.toFun ğ”–) g x })","decl":"protected theorem gen_mem_nhds (f : Î± â†’áµ¤[ğ”–] Î²) (hs : s âˆˆ ğ”–) {V : Set (Î² Ã— Î²)} (hV : V âˆˆ ğ“¤ Î²) :\n    {g | âˆ€ x âˆˆ s, (toFun ğ”– f x, toFun ğ”– g x) âˆˆ V} âˆˆ ğ“ f := by\n  rw [UniformOnFun.nhds_eq]\n  apply_rules [mem_iInf_of_mem, mem_principal_self]\n\n"}
{"name":"UniformOnFun.uniformContinuous_ofUniformFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nâŠ¢ UniformContinuous fun f => (UniformOnFun.ofFun ğ”–) (UniformFun.toFun f)","decl":"theorem uniformContinuous_ofUniformFun :\n    UniformContinuous fun f : Î± â†’áµ¤ Î² â†¦ ofFun ğ”– (UniformFun.toFun f) := by\n  simp only [UniformContinuous, UniformOnFun.uniformity_eq, tendsto_iInf, tendsto_principal,\n    (UniformFun.hasBasis_uniformity _ _).eventually_iff]\n  exact fun _ _ U hU â†¦ âŸ¨U, hU, fun f hf x _ â†¦ hf xâŸ©\n\n"}
{"name":"UniformOnFun.mono","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ³ : Type u_3\nuâ‚ uâ‚‚ : UniformSpace Î³\nhu : LE.le uâ‚ uâ‚‚\nğ”–â‚ ğ”–â‚‚ : Set (Set Î±)\nhğ”– : HasSubset.Subset ğ”–â‚‚ ğ”–â‚\nâŠ¢ LE.le (UniformOnFun.uniformSpace Î± Î³ ğ”–â‚) (UniformOnFun.uniformSpace Î± Î³ ğ”–â‚‚)","decl":"/-- Let `uâ‚`, `uâ‚‚` be two uniform structures on `Î³` and `ğ”–â‚ ğ”–â‚‚ : Set (Set Î±)`. If `uâ‚ â‰¤ uâ‚‚` and\n`ğ”–â‚‚ âŠ† ğ”–â‚` then `ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚)`. -/\nprotected theorem mono â¦ƒuâ‚ uâ‚‚ : UniformSpace Î³â¦„ (hu : uâ‚ â‰¤ uâ‚‚) â¦ƒğ”–â‚ ğ”–â‚‚ : Set (Set Î±)â¦„\n    (hğ”– : ğ”–â‚‚ âŠ† ğ”–â‚) : ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚) :=\n  calc\n    ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚) := iInf_le_iInf_of_subset hğ”–\n    _ â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚) := iInfâ‚‚_mono fun _i _hi => UniformSpace.comap_mono <| UniformFun.mono hu\n\n"}
{"name":"UniformOnFun.uniformContinuous_eval_of_mem","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ns : Set Î±\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nx : Î±\nhxs : Membership.mem s x\nhs : Membership.mem ğ”– s\nâŠ¢ UniformContinuous (Function.comp (Function.eval x) â‡‘(UniformOnFun.toFun ğ”–))","decl":"/-- If `x : Î±` is in some `S âˆˆ ğ”–`, then evaluation at `x` is uniformly continuous on\n`Î± â†’áµ¤[ğ”–] Î²`. -/\ntheorem uniformContinuous_eval_of_mem {x : Î±} (hxs : x âˆˆ s) (hs : s âˆˆ ğ”–) :\n    UniformContinuous ((Function.eval x : (Î± â†’ Î²) â†’ Î²) âˆ˜ toFun ğ”–) :=\n  (UniformFun.uniformContinuous_eval Î² (âŸ¨x, hxsâŸ© : s)).comp\n    (UniformOnFun.uniformContinuous_restrict Î± Î² ğ”– hs)\n\n"}
{"name":"UniformOnFun.uniformContinuous_eval_of_mem_sUnion","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nx : Î±\nhx : Membership.mem ğ”–.sUnion x\nâŠ¢ UniformContinuous (Function.comp (Function.eval x) â‡‘(UniformOnFun.toFun ğ”–))","decl":"theorem uniformContinuous_eval_of_mem_sUnion {x : Î±} (hx : x âˆˆ â‹ƒâ‚€ ğ”–) :\n    UniformContinuous ((Function.eval x : (Î± â†’ Î²) â†’ Î²) âˆ˜ toFun ğ”–) :=\n  let âŸ¨_s, hs, hxsâŸ© := hx\n  uniformContinuous_eval_of_mem _ _ hxs hs\n\n"}
{"name":"UniformOnFun.uniformContinuous_eval","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nh : Eq ğ”–.sUnion Set.univ\nx : Î±\nâŠ¢ UniformContinuous (Function.comp (Function.eval x) â‡‘(UniformOnFun.toFun ğ”–))","decl":"theorem uniformContinuous_eval (h : â‹ƒâ‚€ ğ”– = univ) (x : Î±) :\n    UniformContinuous ((Function.eval x : (Î± â†’ Î²) â†’ Î²) âˆ˜ toFun ğ”–) :=\n  uniformContinuous_eval_of_mem_sUnion _ _ <| h.symm â–¸ mem_univ _\n\n"}
{"name":"UniformOnFun.iInf_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ³ : Type u_3\nÎ¹ : Type u_4\nğ”– : Set (Set Î±)\nu : Î¹ â†’ UniformSpace Î³\nâŠ¢ Eq (UniformOnFun.uniformSpace Î± Î³ ğ”–) (iInf fun i => UniformOnFun.uniformSpace Î± Î³ ğ”–)","decl":"/-- If `u` is a family of uniform structures on `Î³`, then\n`ğ’±(Î±, Î³, ğ”–, (â¨… i, u i)) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i)`. -/\nprotected theorem iInf_eq {u : Î¹ â†’ UniformSpace Î³} :\n    ğ’±(Î±, Î³, ğ”–, â¨… i, u i) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i) := by\n  simp_rw [UniformOnFun.uniformSpace, UniformFun.iInf_eq, UniformSpace.comap_iInf]\n  rw [iInf_comm]\n  exact iInf_congr fun s => iInf_comm\n\n"}
{"name":"UniformOnFun.inf_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ³ : Type u_3\nğ”– : Set (Set Î±)\nuâ‚ uâ‚‚ : UniformSpace Î³\nâŠ¢ Eq (UniformOnFun.uniformSpace Î± Î³ ğ”–) (Min.min (UniformOnFun.uniformSpace Î± Î³ ğ”–) (UniformOnFun.uniformSpace Î± Î³ ğ”–))","decl":"/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³`, then\n`ğ’±(Î±, Î³, ğ”–, uâ‚ âŠ“ uâ‚‚) = ğ’±(Î±, Î³, ğ”–, uâ‚) âŠ“ ğ’±(Î±, Î³, ğ”–, uâ‚‚)`. -/\nprotected theorem inf_eq {uâ‚ uâ‚‚ : UniformSpace Î³} :\n    ğ’±(Î±, Î³, ğ”–, uâ‚ âŠ“ uâ‚‚) = ğ’±(Î±, Î³, ğ”–, uâ‚) âŠ“ ğ’±(Î±, Î³, ğ”–, uâ‚‚) := by\n  rw [inf_eq_iInf, inf_eq_iInf, UniformOnFun.iInf_eq]\n  refine iInf_congr fun i => ?_\n  cases i <;> rfl\n\n"}
{"name":"UniformOnFun.comap_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nf : Î³ â†’ Î²\nâŠ¢ Eq (UniformOnFun.uniformSpace Î± Î³ ğ”–) (UniformSpace.comap (fun x => Function.comp f x) (UniformOnFun.uniformSpace Î± Î² ğ”–))","decl":"/-- If `u` is a uniform structure on `Î²` and `f : Î³ â†’ Î²`, then\n`ğ’±(Î±, Î³, ğ”–, comap f u) = comap (fun g â†¦ f âˆ˜ g) ğ’±(Î±, Î³, ğ”–, uâ‚)`. -/\nprotected theorem comap_eq {f : Î³ â†’ Î²} :\n    ğ’±(Î±, Î³, ğ”–, â€¹UniformSpace Î²â€º.comap f) = ğ’±(Î±, Î², ğ”–, _).comap (f âˆ˜ Â·) := by\n  -- We reduce this to `UniformFun.comap_eq` using the fact that `comap` distributes\n  -- on `iInf`.\n  simp_rw [UniformOnFun.uniformSpace, UniformSpace.comap_iInf, UniformFun.comap_eq, â†\n    UniformSpace.comap_comap]\n  -- By definition, `âˆ€ S âˆˆ ğ”–, (f âˆ˜ â€”) âˆ˜ S.restrict = S.restrict âˆ˜ (f âˆ˜ â€”)`.\n  rfl\n\n"}
{"name":"UniformOnFun.postcomp_uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : UniformContinuous f\nâŠ¢ UniformContinuous (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) (Function.comp (fun x => Function.comp f x) â‡‘(UniformOnFun.toFun ğ”–)))","decl":"/-- Post-composition by a uniformly continuous function is uniformly continuous for the\nuniform structures of `ğ”–`-convergence.\n\nMore precisely, if `f : Î³ â†’ Î²` is uniformly continuous, then\n`(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is uniformly continuous. -/\nprotected theorem postcomp_uniformContinuous [UniformSpace Î³] {f : Î³ â†’ Î²}\n    (hf : UniformContinuous f) : UniformContinuous (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–) := by\n  -- This is a direct consequence of `UniformOnFun.comap_eq`\n  rw [uniformContinuous_iff]\n  exact (UniformOnFun.mono (uniformContinuous_iff.mp hf) subset_rfl).trans_eq UniformOnFun.comap_eq\n\n"}
{"name":"UniformOnFun.postcomp_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ IsUniformInducing (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) (Function.comp (fun x => Function.comp f x) â‡‘(UniformOnFun.toFun ğ”–)))","decl":"/-- Post-composition by a uniform inducing is a uniform inducing for the\nuniform structures of `ğ”–`-convergence.\n\nMore precisely, if `f : Î³ â†’ Î²` is a uniform inducing, then\n`(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is a uniform inducing. -/\nlemma postcomp_isUniformInducing [UniformSpace Î³] {f : Î³ â†’ Î²}\n    (hf : IsUniformInducing f) : IsUniformInducing (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–) := by\n  -- This is a direct consequence of `UniformOnFun.comap_eq`\n  constructor\n  replace hf : (ğ“¤ Î²).comap (Prod.map f f) = _ := hf.comap_uniformity\n  change comap (Prod.map (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–) (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–)) _ = _\n  rw [â† uniformity_comap] at hf âŠ¢\n  congr\n  rw [â† UniformSpace.ext hf, UniformOnFun.comap_eq]\n  rfl\n\n"}
{"name":"UniformOnFun.postcomp_uniformInducing","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : IsUniformInducing f\nâŠ¢ IsUniformInducing (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) (Function.comp (fun x => Function.comp f x) â‡‘(UniformOnFun.toFun ğ”–)))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias postcomp_uniformInducing := postcomp_isUniformInducing\n\n"}
{"name":"UniformOnFun.postcomp_isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : IsUniformEmbedding f\nâŠ¢ IsUniformEmbedding (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) (Function.comp (fun x => Function.comp f x) â‡‘(UniformOnFun.toFun ğ”–)))","decl":"/-- Post-composition by a uniform embedding is a uniform embedding for the\nuniform structures of `ğ”–`-convergence.\n\nMore precisely, if `f : Î³ â†’ Î²` is a uniform embedding, then\n`(fun g â†¦ f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is a uniform embedding. -/\nprotected theorem postcomp_isUniformEmbedding [UniformSpace Î³] {f : Î³ â†’ Î²}\n    (hf : IsUniformEmbedding f) : IsUniformEmbedding (ofFun ğ”– âˆ˜ (f âˆ˜ Â·) âˆ˜ toFun ğ”–) where\n  toIsUniformInducing := UniformOnFun.postcomp_isUniformInducing hf.isUniformInducing\n  injective _ _ H := funext fun _ â†¦ hf.injective (congrFun H _)\n\n"}
{"name":"UniformOnFun.postcomp_uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : UniformSpace Î³\nf : Î³ â†’ Î²\nhf : IsUniformEmbedding f\nâŠ¢ IsUniformEmbedding (Function.comp (â‡‘(UniformOnFun.ofFun ğ”–)) (Function.comp (fun x => Function.comp f x) â‡‘(UniformOnFun.toFun ğ”–)))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias postcomp_uniformEmbedding := UniformOnFun.postcomp_isUniformEmbedding\n\n"}
{"name":"UniformOnFun.precomp_uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nğ”— : Set (Set Î³)\nf : Î³ â†’ Î±\nhf : Set.MapsTo (fun x => Set.image f x) ğ”— ğ”–\nâŠ¢ UniformContinuous fun g => (UniformOnFun.ofFun ğ”—) (Function.comp ((UniformOnFun.toFun ğ”–) g) f)","decl":"/-- Let `f : Î³ â†’ Î±`, `ğ”– : Set (Set Î±)`, `ğ”— : Set (Set Î³)`, and assume that `âˆ€ T âˆˆ ğ”—, f '' T âˆˆ ğ”–`.\nThen, the function `(fun g â†¦ g âˆ˜ f) : (Î± â†’áµ¤[ğ”–] Î²) â†’ (Î³ â†’áµ¤[ğ”—] Î²)` is uniformly continuous.\n\nNote that one can easily see that assuming `âˆ€ T âˆˆ ğ”—, âˆƒ S âˆˆ ğ”–, f '' T âŠ† S` would work too, but\nwe will get this for free when we prove that `ğ’±(Î±, Î², ğ”–, uÎ²) = ğ’±(Î±, Î², ğ”–', uÎ²)` where `ğ”–'` is the\n***noncovering*** bornology generated by `ğ”–`. -/\nprotected theorem precomp_uniformContinuous {ğ”— : Set (Set Î³)} {f : Î³ â†’ Î±}\n    (hf : MapsTo (f '' Â·) ğ”— ğ”–) :\n    UniformContinuous fun g : Î± â†’áµ¤[ğ”–] Î² => ofFun ğ”— (toFun ğ”– g âˆ˜ f) := by\n  -- This follows from the fact that `(Â· âˆ˜ f) Ã— (Â· âˆ˜ f)` maps `gen (f '' t) V` to `gen t V`.\n  simp_rw [UniformContinuous, UniformOnFun.uniformity_eq, tendsto_iInf]\n  refine fun t ht V hV â†¦ tendsto_iInf' (f '' t) <| tendsto_iInf' (hf ht) <|\n    tendsto_iInf' V <| tendsto_iInf' hV ?_\n  simpa only [tendsto_principal_principal, UniformOnFun.gen] using fun _ â†¦ forall_mem_image.1\n\n"}
{"name":"UniformOnFun.t2Space_of_covering","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : T2Space Î²\nh : Eq ğ”–.sUnion Set.univ\nâŠ¢ T2Space (UniformOnFun Î± Î² ğ”–)","decl":"/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/\ntheorem t2Space_of_covering [T2Space Î²] (h : â‹ƒâ‚€ ğ”– = univ) : T2Space (Î± â†’áµ¤[ğ”–] Î²) where\n  t2 f g hfg := by\n    obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext hfg)\n    obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ğ”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ True.intro)\n    exact separated_by_continuous (uniformContinuous_eval_of_mem Î² ğ”– hxs hs).continuous hx\n\n"}
{"name":"UniformOnFun.uniformContinuous_restrict_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nâŠ¢ UniformContinuous (Function.comp ğ”–.sUnion.restrict â‡‘(UniformOnFun.toFun ğ”–))","decl":"/-- The restriction map from `Î± â†’áµ¤[ğ”–] Î²` to `â‹ƒâ‚€ ğ”– â†’ Î²` is uniformly continuous. -/\ntheorem uniformContinuous_restrict_toFun :\n    UniformContinuous ((â‹ƒâ‚€ ğ”–).restrict âˆ˜ toFun ğ”– : (Î± â†’áµ¤[ğ”–] Î²) â†’ â‹ƒâ‚€ ğ”– â†’ Î²) := by\n  rw [uniformContinuous_pi]\n  intro âŸ¨x, hxâŸ©\n  obtain âŸ¨s : Set Î±, hs : s âˆˆ ğ”–, hxs : x âˆˆ sâŸ© := mem_sUnion.mpr hx\n  exact uniformContinuous_eval_of_mem Î² ğ”– hxs hs\n\n"}
{"name":"UniformOnFun.uniformContinuous_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nh : Eq ğ”–.sUnion Set.univ\nâŠ¢ UniformContinuous â‡‘(UniformOnFun.toFun ğ”–)","decl":"/-- If `ğ”–` covers `Î±`, the natural map `UniformOnFun.toFun` from `Î± â†’áµ¤[ğ”–] Î²` to `Î± â†’ Î²` is\nuniformly continuous.\n\nIn other words, if `ğ”–` covers `Î±`, then the uniform structure of `ğ”–`-convergence is finer than\nthat of pointwise convergence. -/\nprotected theorem uniformContinuous_toFun (h : â‹ƒâ‚€ ğ”– = univ) :\n    UniformContinuous (toFun ğ”– : (Î± â†’áµ¤[ğ”–] Î²) â†’ Î± â†’ Î²) := by\n  rw [uniformContinuous_pi]\n  exact uniformContinuous_eval h\n\n"}
{"name":"UniformOnFun.continuousAt_evalâ‚‚","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : TopologicalSpace Î±\nf : UniformOnFun Î± Î² ğ”–\nx : Î±\nhğ”– : Exists fun V => And (Membership.mem ğ”– V) (Membership.mem (nhds x) V)\nhc : ContinuousAt ((UniformOnFun.toFun ğ”–) f) x\nâŠ¢ ContinuousAt (fun fx => (UniformOnFun.toFun ğ”–) fx.1 fx.2) { fst := f, snd := x }","decl":"/-- If `f : Î± â†’áµ¤[ğ”–] Î²` is continuous at `x` and `x` admits a neighbourhood `V âˆˆ ğ”–`,\nthen evaluation of `g : Î± â†’áµ¤[ğ”–] Î²` at `y : Î±` is continuous in `(g, y)` at `(f, x)`. -/\nprotected theorem continuousAt_evalâ‚‚ [TopologicalSpace Î±] {f : Î± â†’áµ¤[ğ”–] Î²} {x : Î±}\n    (hğ”– : âˆƒ V âˆˆ ğ”–, V âˆˆ ğ“ x) (hc : ContinuousAt (toFun ğ”– f) x) :\n    ContinuousAt (fun fx : (Î± â†’áµ¤[ğ”–] Î²) Ã— Î± â†¦ toFun ğ”– fx.1 fx.2) (f, x) := by\n  rw [ContinuousAt, nhds_eq_comap_uniformity, tendsto_comap_iff, â† lift'_comp_uniformity,\n    tendsto_lift']\n  intro U hU\n  rcases hğ”– with âŸ¨V, hV, hVxâŸ©\n  filter_upwards [prod_mem_nhds (UniformOnFun.gen_mem_nhds _ _ _ hV hU)\n    (inter_mem hVx <| hc <| UniformSpace.ball_mem_nhds _ hU)]\n    with âŸ¨g, yâŸ© âŸ¨hg, hyV, hyâŸ© using âŸ¨toFun ğ”– f y, hy, hg y hyVâŸ©\n\n"}
{"name":"UniformOnFun.continuousOn_evalâ‚‚","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : TopologicalSpace Î±\nhğ”– : âˆ€ (x : Î±), Exists fun V => And (Membership.mem ğ”– V) (Membership.mem (nhds x) V)\nâŠ¢ ContinuousOn (fun fx => (UniformOnFun.toFun ğ”–) fx.1 fx.2) (setOf fun fx => ContinuousAt ((UniformOnFun.toFun ğ”–) fx.1) fx.2)","decl":"/-- If each point of `Î±` admits a neighbourhood `V âˆˆ ğ”–`,\nthen the evaluation of `f : Î± â†’áµ¤[ğ”–] Î²` at `x : Î±` is continuous in `(f, x)`\non the set of `(f, x)` such that `f` is continuous at `x`. -/\nprotected theorem continuousOn_evalâ‚‚ [TopologicalSpace Î±] (hğ”– : âˆ€ x, âˆƒ V âˆˆ ğ”–, V âˆˆ ğ“ x) :\n    ContinuousOn (fun fx : (Î± â†’áµ¤[ğ”–] Î²) Ã— Î± â†¦ toFun ğ”– fx.1 fx.2)\n      {fx | ContinuousAt (toFun ğ”– fx.1) fx.2} := fun (_f, x) hc â†¦\n  (UniformOnFun.continuousAt_evalâ‚‚ (hğ”– x) hc).continuousWithinAt\n\n"}
{"name":"UniformOnFun.tendsto_iff_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_4\np : Filter Î¹\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nF : Î¹ â†’ UniformOnFun Î± Î² ğ”–\nf : UniformOnFun Î± Î² ğ”–\nâŠ¢ Iff (Filter.Tendsto F p (nhds f)) (âˆ€ (s : Set Î±), Membership.mem ğ”– s â†’ TendstoUniformlyOn (Function.comp (â‡‘(UniformOnFun.toFun ğ”–)) F) ((UniformOnFun.toFun ğ”–) f) p s)","decl":"/-- Convergence in the topology of `ğ”–`-convergence means uniform convergence on `S` (in the sense\nof `TendstoUniformlyOn`) for all `S âˆˆ ğ”–`. -/\nprotected theorem tendsto_iff_tendstoUniformlyOn {F : Î¹ â†’ Î± â†’áµ¤[ğ”–] Î²} {f : Î± â†’áµ¤[ğ”–] Î²} :\n    Tendsto F p (ğ“ f) â†” âˆ€ s âˆˆ ğ”–, TendstoUniformlyOn (toFun ğ”– âˆ˜ F) (toFun ğ”– f) p s := by\n  simp only [UniformOnFun.nhds_eq, tendsto_iInf, tendsto_principal, TendstoUniformlyOn,\n    Function.comp_apply, mem_setOf]\n\n"}
{"name":"UniformOnFun.continuous_rng_iff","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\nX : Type u_5\ninstâœ : TopologicalSpace X\nf : X â†’ UniformOnFun Î± Î² ğ”–\nâŠ¢ Iff (Continuous f) (âˆ€ (s : Set Î±), Membership.mem ğ”– s â†’ Continuous (Function.comp (â‡‘UniformFun.ofFun) (Function.comp s.restrict (Function.comp (â‡‘(UniformOnFun.toFun ğ”–)) f))))","decl":"protected lemma continuous_rng_iff {X : Type*} [TopologicalSpace X] {f : X â†’ (Î± â†’áµ¤[ğ”–] Î²)} :\n    Continuous f â†” âˆ€ s âˆˆ ğ”–,\n      Continuous (UniformFun.ofFun âˆ˜ s.restrict âˆ˜ UniformOnFun.toFun ğ”– âˆ˜ f) := by\n  simp only [continuous_iff_continuousAt, ContinuousAt,\n    UniformOnFun.tendsto_iff_tendstoUniformlyOn, UniformFun.tendsto_iff_tendstoUniformly,\n    tendstoUniformlyOn_iff_tendstoUniformly_comp_coe, @forall_swap X, Function.comp_apply,\n    Function.comp_def, restrict_eq, UniformFun.toFun_ofFun]\n\n"}
{"name":"UniformOnFun.instCompleteSpace","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : CompleteSpace Î²\nâŠ¢ CompleteSpace (UniformOnFun Î± Î² ğ”–)","decl":"instance [CompleteSpace Î²] : CompleteSpace (Î± â†’áµ¤[ğ”–] Î²) := by\n  rcases isEmpty_or_nonempty Î²\n  Â· infer_instance\n  Â· refine âŸ¨fun {F} hF â†¦ ?_âŸ©\n    have := hF.1\n    have : âˆ€ x âˆˆ â‹ƒâ‚€ ğ”–, âˆƒ y : Î², Tendsto (toFun ğ”– Â· x) F (ğ“ y) := fun x hx â†¦\n      CompleteSpace.complete (hF.map (uniformContinuous_eval_of_mem_sUnion _ _ hx))\n    choose! g hg using this\n    use ofFun ğ”– g\n    simp_rw [UniformOnFun.nhds_eq_of_basis _ _ uniformity_hasBasis_closed, le_iInfâ‚‚_iff,\n      le_principal_iff]\n    intro s hs U âŸ¨hU, hUcâŸ©\n    rcases cauchy_iff.mp hF |>.2 _ <| UniformOnFun.gen_mem_uniformity _ _ hs hU\n      with âŸ¨V, hV, hVUâŸ©\n    filter_upwards [hV] with f hf x hx\n    refine hUc.mem_of_tendsto ((hg x âŸ¨s, hs, hxâŸ©).prod_mk_nhds tendsto_const_nhds) ?_\n    filter_upwards [hV] with g' hg' using hVU (mk_mem_prod hg' hf) _ hx\n\n"}
{"name":"UniformOnFun.isClosed_setOf_continuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\nğ”– : Set (Set Î±)\ninstâœ : TopologicalSpace Î±\nh : Topology.RestrictGenTopology ğ”–\nâŠ¢ IsClosed (setOf fun f => Continuous ((UniformOnFun.toFun ğ”–) f))","decl":"/-- Suppose that the topology on `Î±` is defined by its restrictions to the sets of `ğ”–`.\n\nThen the set of continuous functions is closed\nin the topology of uniform convergence on the sets of `ğ”–`. -/\ntheorem isClosed_setOf_continuous [TopologicalSpace Î±] (h : RestrictGenTopology ğ”–) :\n    IsClosed {f : Î± â†’áµ¤[ğ”–] Î² | Continuous (toFun ğ”– f)} := by\n  refine isClosed_iff_forall_filter.2 fun f u _ hu huf â†¦ h.continuous_iff.2 fun s hs â†¦ ?_\n  rw [â† tendsto_id', UniformOnFun.tendsto_iff_tendstoUniformlyOn] at huf\n  exact (huf s hs).continuousOn <| hu fun _ â†¦ Continuous.continuousOn\n\n"}
{"name":"UniformOnFun.uniformSpace_eq_inf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nÎ´â‚ : Type u_5\nÎ´â‚‚ : Type u_6\nÏ†â‚ : Î´â‚ â†’ Î±\nÏ†â‚‚ : Î´â‚‚ â†’ Î±\nğ”—â‚ : Set (Set Î´â‚)\nğ”—â‚‚ : Set (Set Î´â‚‚)\nh_imageâ‚ : Set.MapsTo (fun x => Set.image Ï†â‚ x) ğ”—â‚ ğ”–\nh_imageâ‚‚ : Set.MapsTo (fun x => Set.image Ï†â‚‚ x) ğ”—â‚‚ ğ”–\nh_preimageâ‚ : Set.MapsTo (fun x => Set.preimage Ï†â‚ x) ğ”– ğ”—â‚\nh_preimageâ‚‚ : Set.MapsTo (fun x => Set.preimage Ï†â‚‚ x) ğ”– ğ”—â‚‚\nh_cover : âˆ€ (S : Set Î±), Membership.mem ğ”– S â†’ HasSubset.Subset S (Union.union (Set.range Ï†â‚) (Set.range Ï†â‚‚))\nâŠ¢ Eq (UniformOnFun.uniformSpace Î± Î² ğ”–) (Min.min (UniformSpace.comap (Function.comp (â‡‘(UniformOnFun.ofFun ğ”—â‚)) (Function.comp (fun x => Function.comp x Ï†â‚) â‡‘(UniformOnFun.toFun ğ”–))) (UniformOnFun.uniformSpace Î´â‚ Î² ğ”—â‚)) (UniformSpace.comap (Function.comp (â‡‘(UniformOnFun.ofFun ğ”—â‚‚)) (Function.comp (fun x => Function.comp x Ï†â‚‚) â‡‘(UniformOnFun.toFun ğ”–))) (UniformOnFun.uniformSpace Î´â‚‚ Î² ğ”—â‚‚)))","decl":"variable (ğ”–) in\ntheorem uniformSpace_eq_inf_precomp_of_cover {Î´â‚ Î´â‚‚ : Type*} (Ï†â‚ : Î´â‚ â†’ Î±) (Ï†â‚‚ : Î´â‚‚ â†’ Î±)\n    (ğ”—â‚ : Set (Set Î´â‚)) (ğ”—â‚‚ : Set (Set Î´â‚‚))\n    (h_imageâ‚ : MapsTo (Ï†â‚ '' Â·) ğ”—â‚ ğ”–) (h_imageâ‚‚ : MapsTo (Ï†â‚‚ '' Â·) ğ”—â‚‚ ğ”–)\n    (h_preimageâ‚ : MapsTo (Ï†â‚ â»Â¹' Â·) ğ”– ğ”—â‚) (h_preimageâ‚‚ : MapsTo (Ï†â‚‚ â»Â¹' Â·) ğ”– ğ”—â‚‚)\n    (h_cover : âˆ€ S âˆˆ ğ”–, S âŠ† range Ï†â‚ âˆª range Ï†â‚‚) :\n    ğ’±(Î±, Î², ğ”–, _) =\n      .comap (ofFun ğ”—â‚ âˆ˜ (Â· âˆ˜ Ï†â‚) âˆ˜ toFun ğ”–) ğ’±(Î´â‚, Î², ğ”—â‚, _) âŠ“\n      .comap (ofFun ğ”—â‚‚ âˆ˜ (Â· âˆ˜ Ï†â‚‚) âˆ˜ toFun ğ”–) ğ’±(Î´â‚‚, Î², ğ”—â‚‚, _) := by\n  set Ïˆâ‚ : Î  S : Set Î±, Ï†â‚ â»Â¹' S â†’ S := fun S â†¦ S.restrictPreimage Ï†â‚\n  set Ïˆâ‚‚ : Î  S : Set Î±, Ï†â‚‚ â»Â¹' S â†’ S := fun S â†¦ S.restrictPreimage Ï†â‚‚\n  have : âˆ€ S âˆˆ ğ”–, ğ’°(S, Î², _) = .comap (Â· âˆ˜ Ïˆâ‚ S) ğ’°(_, Î², _) âŠ“ .comap (Â· âˆ˜ Ïˆâ‚‚ S) ğ’°(_, Î², _) := by\n    refine fun S hS â†¦ UniformFun.uniformSpace_eq_inf_precomp_of_cover Î² _ _ ?_\n    simpa only [â† univ_subset_iff, Ïˆâ‚, Ïˆâ‚‚, range_restrictPreimage, â† preimage_union,\n      â† image_subset_iff, image_univ, Subtype.range_val] using h_cover S hS\n  refine le_antisymm (le_inf ?_ ?_) (le_iInfâ‚‚ fun S hS â†¦ ?_)\n  Â· rw [â† uniformContinuous_iff]\n    exact UniformOnFun.precomp_uniformContinuous h_imageâ‚\n  Â· rw [â† uniformContinuous_iff]\n    exact UniformOnFun.precomp_uniformContinuous h_imageâ‚‚\n  Â· simp_rw [this S hS, UniformSpace.comap_iInf, UniformSpace.comap_inf, â† UniformSpace.comap_comap]\n    exact inf_le_inf\n      (iInfâ‚‚_le_of_le _ (h_preimageâ‚ hS) le_rfl)\n      (iInfâ‚‚_le_of_le _ (h_preimageâ‚‚ hS) le_rfl)\n\n"}
{"name":"UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_4\ninstâœ : UniformSpace Î²\nğ”– : Set (Set Î±)\nÎ´ : Î¹ â†’ Type u_5\nÏ† : (i : Î¹) â†’ Î´ i â†’ Î±\nğ”— : (i : Î¹) â†’ Set (Set (Î´ i))\nh_image : âˆ€ (i : Î¹), Set.MapsTo (fun x => Set.image (Ï† i) x) (ğ”— i) ğ”–\nh_preimage : âˆ€ (i : Î¹), Set.MapsTo (fun x => Set.preimage (Ï† i) x) ğ”– (ğ”— i)\nh_cover : âˆ€ (S : Set Î±), Membership.mem ğ”– S â†’ Exists fun I => And I.Finite (HasSubset.Subset S (Set.iUnion fun i => Set.iUnion fun h => Set.range (Ï† i)))\nâŠ¢ Eq (UniformOnFun.uniformSpace Î± Î² ğ”–) (iInf fun i => UniformSpace.comap (Function.comp (â‡‘(UniformOnFun.ofFun (ğ”— i))) (Function.comp (fun x => Function.comp x (Ï† i)) â‡‘(UniformOnFun.toFun ğ”–))) (UniformOnFun.uniformSpace (Î´ i) Î² (ğ”— i)))","decl":"variable (ğ”–) in\ntheorem uniformSpace_eq_iInf_precomp_of_cover {Î´ : Î¹ â†’ Type*} (Ï† : Î  i, Î´ i â†’ Î±)\n    (ğ”— : âˆ€ i, Set (Set (Î´ i))) (h_image : âˆ€ i, MapsTo (Ï† i '' Â·) (ğ”— i) ğ”–)\n    (h_preimage : âˆ€ i, MapsTo (Ï† i â»Â¹' Â·) ğ”– (ğ”— i))\n    (h_cover : âˆ€ S âˆˆ ğ”–, âˆƒ I : Set Î¹, I.Finite âˆ§ S âŠ† â‹ƒ i âˆˆ I, range (Ï† i)) :\n    ğ’±(Î±, Î², ğ”–, _) = â¨… i, .comap (ofFun (ğ”— i) âˆ˜ (Â· âˆ˜ Ï† i) âˆ˜ toFun ğ”–) ğ’±(Î´ i, Î², ğ”— i, _) := by\n  set Ïˆ : Î  S : Set Î±, Î  i : Î¹, (Ï† i) â»Â¹' S â†’ S := fun S i â†¦ S.restrictPreimage (Ï† i)\n  have : âˆ€ S âˆˆ ğ”–, ğ’°(S, Î², _) = â¨… i, .comap (Â· âˆ˜ Ïˆ S i) ğ’°(_, Î², _) := fun S hS â†¦ by\n    rcases h_cover S hS with âŸ¨I, I_finite, I_coverâŸ©\n    refine UniformFun.uniformSpace_eq_iInf_precomp_of_cover Î² _ âŸ¨I, I_finite, ?_âŸ©\n    simpa only [â† univ_subset_iff, Ïˆ, range_restrictPreimage, â† preimage_iUnionâ‚‚,\n      â† image_subset_iff, image_univ, Subtype.range_val] using I_cover\n  -- With a better theory of ideals we may be able to simplify the following by replacing `ğ”— i`\n  -- by `(Ï† i â»Â¹' Â·) '' ğ”–`.\n  refine le_antisymm (le_iInf fun i â†¦ ?_) (le_iInfâ‚‚ fun S hS â†¦ ?_)\n  Â· rw [â† uniformContinuous_iff]\n    exact UniformOnFun.precomp_uniformContinuous (h_image i)\n  Â· simp_rw [this S hS, UniformSpace.comap_iInf, â† UniformSpace.comap_comap]\n    exact iInf_mono fun i â†¦ iInfâ‚‚_le_of_le _ (h_preimage i hS) le_rfl\n\n"}
{"name":"UniformFun.instCompleteSpace","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : CompleteSpace Î²\nâŠ¢ CompleteSpace (UniformFun Î± Î²)","decl":"instance {Î± Î² : Type*} [UniformSpace Î²] [CompleteSpace Î²] : CompleteSpace (Î± â†’áµ¤ Î²) :=\n  (UniformOnFun.uniformEquivUniformFun Î² {univ} (mem_singleton _)).completeSpace_iff.1 inferInstance\n\n"}
{"name":"UniformContinuousOn.comp_tendstoUniformly","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\np : Filter Î¹\ns : Set Î²\nF : Î¹ â†’ Î± â†’ Î²\nf : Î± â†’ Î²\nhF : âˆ€ (i : Î¹) (x : Î±), Membership.mem s (F i x)\nhf : âˆ€ (x : Î±), Membership.mem s (f x)\ng : Î² â†’ Î³\nhg : UniformContinuousOn g s\nh : TendstoUniformly F f p\nâŠ¢ TendstoUniformly (fun i x => g (F i x)) (fun x => g (f x)) p","decl":"/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem UniformContinuousOn.comp_tendstoUniformly (s : Set Î²) (F : Î¹ â†’ Î± â†’ Î²) (f : Î± â†’ Î²)\n    (hF : âˆ€ i x, F i x âˆˆ s) (hf : âˆ€ x, f x âˆˆ s)\n    {g : Î² â†’ Î³} (hg : UniformContinuousOn g s) (h : TendstoUniformly F f p) :\n    TendstoUniformly (fun i x => g (F i x)) (fun x => g (f x)) p := by\n  rw [uniformContinuousOn_iff_restrict] at hg\n  lift F to Î¹ â†’ Î± â†’ s using hF with F' hF'\n  lift f to Î± â†’ s using hf with f' hf'\n  rw [tendstoUniformly_iff_tendsto] at h\n  have : Tendsto (fun q : Î¹ Ã— Î± â†¦ (f' q.2, (F' q.1 q.2))) (p Ã—Ë¢ âŠ¤) (ğ“¤ s) :=\n    h.of_tendsto_comp isUniformEmbedding_subtype_val.comap_uniformity.le\n  apply UniformContinuous.comp_tendstoUniformly hg ?_\n  rwa [â† tendstoUniformly_iff_tendsto] at this\n\n"}
{"name":"UniformContinuousOn.comp_tendstoUniformly_eventually","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ¹ : Type u_4\ninstâœÂ¹ : UniformSpace Î²\ninstâœ : UniformSpace Î³\np : Filter Î¹\ns : Set Î²\nF : Î¹ â†’ Î± â†’ Î²\nf : Î± â†’ Î²\nhF : Filter.Eventually (fun i => âˆ€ (x : Î±), Membership.mem s (F i x)) p\nhf : âˆ€ (x : Î±), Membership.mem s (f x)\ng : Î² â†’ Î³\nhg : UniformContinuousOn g s\nh : TendstoUniformly F f p\nâŠ¢ TendstoUniformly (fun i x => g (F i x)) (fun x => g (f x)) p","decl":"theorem UniformContinuousOn.comp_tendstoUniformly_eventually (s : Set Î²) (F : Î¹ â†’ Î± â†’ Î²) (f : Î± â†’ Î²)\n    (hF : âˆ€á¶  i in p, âˆ€ x, F i x âˆˆ s) (hf : âˆ€ x, f x âˆˆ s)\n    {g : Î² â†’ Î³} (hg : UniformContinuousOn g s) (h : TendstoUniformly F f p) :\n    TendstoUniformly (fun i => fun x => g (F i x)) (fun x => g (f x)) p := by\n  classical\n  rw [eventually_iff_exists_mem] at hF\n  obtain âŸ¨s', hs', hsâŸ© := hF\n  let F' : Î¹ â†’ Î± â†’ Î² := fun (i : Î¹) x => if i âˆˆ s' then F i x else f x\n  have hF : F =á¶ [p] F' :=  by\n    rw [eventuallyEq_iff_exists_mem]\n    refine âŸ¨s', hs', fun y hy => by aesopâŸ©\n  have h' : TendstoUniformly F' f p := by\n    rwa [tendstoUniformly_congr hF] at h\n  apply (tendstoUniformly_congr _).mpr\n    (UniformContinuousOn.comp_tendstoUniformly s F' f (by aesop) hf hg h')\n  rw [eventuallyEq_iff_exists_mem]\n  refine âŸ¨s', hs', fun i hi => by aesopâŸ©\n\n"}
