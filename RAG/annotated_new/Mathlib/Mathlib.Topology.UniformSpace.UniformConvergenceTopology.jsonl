{"name":"instNonemptyUniformFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty β\n⊢ Nonempty (UniformFun α β)","decl":"instance [Nonempty β] : Nonempty (α →ᵤ β) := Pi.instNonempty\n\n"}
{"name":"instNonemptyUniformOnFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Nonempty β\n⊢ Nonempty (UniformOnFun α β 𝔖)","decl":"instance [Nonempty β] : Nonempty (α →ᵤ[𝔖] β) := Pi.instNonempty\n\n"}
{"name":"instSubsingletonUniformFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Subsingleton β\n⊢ Subsingleton (UniformFun α β)","decl":"instance [Subsingleton β] : Subsingleton (α →ᵤ β) :=\n  inferInstanceAs <| Subsingleton <| α → β\n\n"}
{"name":"instSubsingletonUniformOnFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Subsingleton β\n⊢ Subsingleton (UniformOnFun α β 𝔖)","decl":"instance [Subsingleton β] : Subsingleton (α →ᵤ[𝔖] β) :=\n  inferInstanceAs <| Subsingleton <| α → β\n\n"}
{"name":"UniformFun.toFun_ofFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (UniformFun.toFun (UniformFun.ofFun f)) f","decl":"@[simp] lemma UniformFun.toFun_ofFun (f : α → β) : toFun (ofFun f) = f := rfl\n"}
{"name":"UniformFun.ofFun_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nf : UniformFun α β\n⊢ Eq (UniformFun.ofFun (UniformFun.toFun f)) f","decl":"@[simp] lemma UniformFun.ofFun_toFun (f : α →ᵤ β) : ofFun (toFun f) = f := rfl\n"}
{"name":"UniformOnFun.toFun_ofFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\nf : α → β\n⊢ Eq ((UniformOnFun.toFun 𝔖) ((UniformOnFun.ofFun 𝔖) f)) f","decl":"@[simp] lemma UniformOnFun.toFun_ofFun (f : α → β) : toFun 𝔖 (ofFun 𝔖 f) = f := rfl\n"}
{"name":"UniformOnFun.ofFun_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\nf : UniformOnFun α β 𝔖\n⊢ Eq ((UniformOnFun.ofFun 𝔖) ((UniformOnFun.toFun 𝔖) f)) f","decl":"@[simp] lemma UniformOnFun.ofFun_toFun (f : α →ᵤ[𝔖] β) : ofFun 𝔖 (toFun 𝔖 f) = f := rfl\n\n-- Note: we don't declare a `CoeFun` instance because Lean wouldn't insert it when writing\n-- `f x` (because of definitional equality with `α → β`).\n"}
{"name":"UniformFun.isBasis_gen","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\n𝓑 : Filter (Prod β β)\n⊢ Filter.IsBasis (fun V => Membership.mem 𝓑 V) (UniformFun.gen α β)","decl":"/-- If `𝓕` is a filter on `β × β`, then the set of all `UniformFun.gen α β V` for\n`V ∈ 𝓕` is a filter basis on `(α →ᵤ β) × (α →ᵤ β)`. This will only be applied to `𝓕 = 𝓤 β` when\n`β` is equipped with a `UniformSpace` structure, but it is useful to define it for any filter in\norder to be able to state that it has a lower adjoint (see `UniformFun.gc`). -/\nprotected theorem isBasis_gen (𝓑 : Filter <| β × β) :\n    IsBasis (fun V : Set (β × β) => V ∈ 𝓑) (UniformFun.gen α β) :=\n  ⟨⟨univ, univ_mem⟩, @fun U V hU hV =>\n    ⟨U ∩ V, inter_mem hU hV, fun _ huv => ⟨fun x => (huv x).left, fun x => (huv x).right⟩⟩⟩\n\n"}
{"name":"UniformFun.gc","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ GaloisConnection (fun 𝓐 => Filter.map (UniformFun.phi α β) (SProd.sprod 𝓐 Top.top)) fun 𝓕 => UniformFun.filter α β 𝓕","decl":"/-- The function `UniformFun.filter α β : Filter (β × β) → Filter ((α →ᵤ β) × (α →ᵤ β))`\nhas a lower adjoint `l` (in the sense of `GaloisConnection`). The exact definition of `l` is not\ninteresting; we will only use that it exists (in `UniformFun.mono` and\n`UniformFun.iInf_eq`) and that\n`l (Filter.map (Prod.map f f) 𝓕) = Filter.map (Prod.map ((∘) f) ((∘) f)) (l 𝓕)` for each\n`𝓕 : Filter (γ × γ)` and `f : γ → α` (in `UniformFun.comap_eq`). -/\nprotected theorem gc : GaloisConnection lowerAdjoint fun 𝓕 => UniformFun.filter α β 𝓕 := by\n  intro 𝓐 𝓕\n  symm\n  calc\n    𝓐 ≤ UniformFun.filter α β 𝓕 ↔ (UniformFun.basis α β 𝓕).sets ⊆ 𝓐.sets := by\n      rw [UniformFun.filter, ← FilterBasis.generate, le_generate_iff]\n    _ ↔ ∀ U ∈ 𝓕, UniformFun.gen α β U ∈ 𝓐 := image_subset_iff\n    _ ↔ ∀ U ∈ 𝓕,\n          { uv | ∀ x, (uv, x) ∈ { t : ((α →ᵤ β) × (α →ᵤ β)) × α | (t.1.1 t.2, t.1.2 t.2) ∈ U } } ∈\n            𝓐 :=\n      Iff.rfl\n    _ ↔ ∀ U ∈ 𝓕,\n          { uvx : ((α →ᵤ β) × (α →ᵤ β)) × α | (uvx.1.1 uvx.2, uvx.1.2 uvx.2) ∈ U } ∈\n            𝓐 ×ˢ (⊤ : Filter α) :=\n      forall₂_congr fun U _hU => mem_prod_top.symm\n    _ ↔ lowerAdjoint 𝓐 ≤ 𝓕 := Iff.rfl\n\n"}
{"name":"UniformFun.hasBasis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n⊢ (uniformity (UniformFun α β)).HasBasis (fun x => Membership.mem (uniformity β) x) (UniformFun.gen α β)","decl":"/-- By definition, the uniformity of `α →ᵤ β` admits the family `{(f, g) | ∀ x, (f x, g x) ∈ V}`\nfor `V ∈ 𝓤 β` as a filter basis. -/\nprotected theorem hasBasis_uniformity :\n    (𝓤 (α →ᵤ β)).HasBasis (· ∈ 𝓤 β) (UniformFun.gen α β) :=\n  (UniformFun.isBasis_gen α β (𝓤 β)).hasBasis\n\n"}
{"name":"UniformFun.hasBasis_uniformity_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\nι : Sort u_5\np : ι → Prop\ns : ι → Set (Prod β β)\nh : (uniformity β).HasBasis p s\n⊢ (uniformity (UniformFun α β)).HasBasis p (Function.comp (UniformFun.gen α β) s)","decl":"/-- The uniformity of `α →ᵤ β` admits the family `{(f, g) | ∀ x, (f x, g x) ∈ V}` for `V ∈ 𝓑` as\na filter basis, for any basis `𝓑` of `𝓤 β` (in the case `𝓑 = (𝓤 β).as_basis` this is true by\ndefinition). -/\nprotected theorem hasBasis_uniformity_of_basis {ι : Sort*} {p : ι → Prop} {s : ι → Set (β × β)}\n    (h : (𝓤 β).HasBasis p s) : (𝓤 (α →ᵤ β)).HasBasis p (UniformFun.gen α β ∘ s) :=\n  (UniformFun.hasBasis_uniformity α β).to_hasBasis\n    (fun _ hU =>\n      let ⟨i, hi, hiU⟩ := h.mem_iff.mp hU\n      ⟨i, hi, fun _ huv x => hiU (huv x)⟩)\n    fun i hi => ⟨s i, h.mem_of_mem hi, subset_refl _⟩\n\n"}
{"name":"UniformFun.hasBasis_nhds_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : UniformSpace β\nf : UniformFun α β\np : ι → Prop\ns : ι → Set (Prod β β)\nh : (uniformity β).HasBasis p s\n⊢ (nhds f).HasBasis p fun i => setOf fun g => Membership.mem (UniformFun.gen α β (s i)) { fst := f, snd := g }","decl":"/-- For `f : α →ᵤ β`, `𝓝 f` admits the family `{g | ∀ x, (f x, g x) ∈ V}` for `V ∈ 𝓑` as a filter\nbasis, for any basis `𝓑` of `𝓤 β`. -/\nprotected theorem hasBasis_nhds_of_basis (f) {p : ι → Prop} {s : ι → Set (β × β)}\n    (h : HasBasis (𝓤 β) p s) :\n    (𝓝 f).HasBasis p fun i => { g | (f, g) ∈ UniformFun.gen α β (s i) } :=\n  nhds_basis_uniformity' (UniformFun.hasBasis_uniformity_of_basis α β h)\n\n"}
{"name":"UniformFun.hasBasis_nhds","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\nf : UniformFun α β\n⊢ (nhds f).HasBasis (fun V => Membership.mem (uniformity β) V) fun V => setOf fun g => Membership.mem (UniformFun.gen α β V) { fst := f, snd := g }","decl":"/-- For `f : α →ᵤ β`, `𝓝 f` admits the family `{g | ∀ x, (f x, g x) ∈ V}` for `V ∈ 𝓤 β` as a\nfilter basis. -/\nprotected theorem hasBasis_nhds (f) :\n    (𝓝 f).HasBasis (fun V => V ∈ 𝓤 β) fun V => { g | (f, g) ∈ UniformFun.gen α β V } :=\n  UniformFun.hasBasis_nhds_of_basis α β f (Filter.basis_sets _)\n\n"}
{"name":"UniformFun.uniformContinuous_eval","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\nx : α\n⊢ UniformContinuous (Function.comp (Function.eval x) ⇑UniformFun.toFun)","decl":"/-- Evaluation at a fixed point is uniformly continuous on `α →ᵤ β`. -/\ntheorem uniformContinuous_eval (x : α) :\n    UniformContinuous (Function.eval x ∘ toFun : (α →ᵤ β) → β) := by\n  change _ ≤ _\n  rw [map_le_iff_le_comap,\n    (UniformFun.hasBasis_uniformity α β).le_basis_iff ((𝓤 _).basis_sets.comap _)]\n  exact fun U hU => ⟨U, hU, fun uv huv => huv x⟩\n\n"}
{"name":"UniformFun.mem_gen","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_5\nf g : UniformFun α β\nV : Set (Prod β β)\n⊢ Iff (Membership.mem (UniformFun.gen α β V) { fst := f, snd := g }) (∀ (x : α), Membership.mem V { fst := UniformFun.toFun f x, snd := UniformFun.toFun g x })","decl":"@[simp]\nprotected lemma mem_gen {β} {f g : α →ᵤ β} {V : Set (β × β)} :\n    (f, g) ∈ UniformFun.gen α β V ↔ ∀ x, (toFun f x, toFun g x) ∈ V :=\n  .rfl\n\n"}
{"name":"UniformFun.mono","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nγ : Type u_3\n⊢ Monotone (@UniformFun.uniformSpace α γ)","decl":"/-- If `u₁` and `u₂` are two uniform structures on `γ` and `u₁ ≤ u₂`, then\n`𝒰(α, γ, u₁) ≤ 𝒰(α, γ, u₂)`. -/\nprotected theorem mono : Monotone (@UniformFun.uniformSpace α γ) := fun _ _ hu =>\n  (UniformFun.gc α γ).monotone_u hu\n\n"}
{"name":"UniformFun.iInf_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nγ : Type u_3\nι : Type u_4\nu : ι → UniformSpace γ\n⊢ Eq (UniformFun.uniformSpace α γ) (iInf fun i => UniformFun.uniformSpace α γ)","decl":"/-- If `u` is a family of uniform structures on `γ`, then\n`𝒰(α, γ, (⨅ i, u i)) = ⨅ i, 𝒰(α, γ, u i)`. -/\nprotected theorem iInf_eq {u : ι → UniformSpace γ} : 𝒰(α, γ, (⨅ i, u i)) = ⨅ i, 𝒰(α, γ, u i) := by\n  -- This follows directly from the fact that the upper adjoint in a Galois connection maps\n  -- infimas to infimas.\n  ext : 1\n  change UniformFun.filter α γ 𝓤[⨅ i, u i] = 𝓤[⨅ i, 𝒰(α, γ, u i)]\n  rw [iInf_uniformity, iInf_uniformity]\n  exact (UniformFun.gc α γ).u_iInf\n\n"}
{"name":"UniformFun.inf_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nγ : Type u_3\nu₁ u₂ : UniformSpace γ\n⊢ Eq (UniformFun.uniformSpace α γ) (Min.min (UniformFun.uniformSpace α γ) (UniformFun.uniformSpace α γ))","decl":"/-- If `u₁` and `u₂` are two uniform structures on `γ`, then\n`𝒰(α, γ, u₁ ⊓ u₂) = 𝒰(α, γ, u₁) ⊓ 𝒰(α, γ, u₂)`. -/\nprotected theorem inf_eq {u₁ u₂ : UniformSpace γ} :\n    𝒰(α, γ, u₁ ⊓ u₂) = 𝒰(α, γ, u₁) ⊓ 𝒰(α, γ, u₂) := by\n  -- This follows directly from the fact that the upper adjoint in a Galois connection maps\n  -- infimas to infimas.\n  rw [inf_eq_iInf, inf_eq_iInf, UniformFun.iInf_eq]\n  refine iInf_congr fun i => ?_\n  cases i <;> rfl\n\n"}
{"name":"UniformFun.postcomp_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\ninst✝ : UniformSpace γ\nf : γ → β\nhf : IsUniformInducing f\n⊢ IsUniformInducing (Function.comp (⇑UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) ⇑UniformFun.toFun))","decl":"/-- Post-composition by a uniform inducing function is\na uniform inducing function for the uniform structures of uniform convergence.\n\nMore precisely, if `f : γ → β` is uniform inducing,\nthen `(f ∘ ·) : (α →ᵤ γ) → (α →ᵤ β)` is uniform inducing. -/\nlemma postcomp_isUniformInducing [UniformSpace γ] {f : γ → β}\n    (hf : IsUniformInducing f) : IsUniformInducing (ofFun ∘ (f ∘ ·) ∘ toFun : (α →ᵤ γ) → α →ᵤ β) :=\n  ⟨((UniformFun.hasBasis_uniformity _ _).comap _).eq_of_same_basis <|\n    UniformFun.hasBasis_uniformity_of_basis _ _ (hf.basis_uniformity (𝓤 β).basis_sets)⟩\n\n"}
{"name":"UniformFun.postcomp_uniformInducing","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\ninst✝ : UniformSpace γ\nf : γ → β\nhf : IsUniformInducing f\n⊢ IsUniformInducing (Function.comp (⇑UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) ⇑UniformFun.toFun))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias postcomp_uniformInducing := postcomp_isUniformInducing\n\n"}
{"name":"UniformFun.postcomp_isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\ninst✝ : UniformSpace γ\nf : γ → β\nhf : IsUniformEmbedding f\n⊢ IsUniformEmbedding (Function.comp (⇑UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) ⇑UniformFun.toFun))","decl":"/-- Post-composition by a uniform embedding is\na uniform embedding for the uniform structures of uniform convergence.\n\nMore precisely, if `f : γ → β` is a uniform embedding,\nthen `(f ∘ ·) : (α →ᵤ γ) → (α →ᵤ β)` is a uniform embedding. -/\nprotected theorem postcomp_isUniformEmbedding [UniformSpace γ] {f : γ → β}\n    (hf : IsUniformEmbedding f) :\n    IsUniformEmbedding (ofFun ∘ (f ∘ ·) ∘ toFun : (α →ᵤ γ) → α →ᵤ β) where\n  toIsUniformInducing := UniformFun.postcomp_isUniformInducing hf.isUniformInducing\n  injective _ _ H := funext fun _ ↦ hf.injective (congrFun H _)\n\n"}
{"name":"UniformFun.postcomp_uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\ninst✝ : UniformSpace γ\nf : γ → β\nhf : IsUniformEmbedding f\n⊢ IsUniformEmbedding (Function.comp (⇑UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) ⇑UniformFun.toFun))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias postcomp_uniformEmbedding := UniformFun.postcomp_isUniformEmbedding\n\n-- Porting note: had to add a type annotation at `((f ∘ ·) : ((α → γ) → (α → β)))`\n"}
{"name":"UniformFun.comap_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : UniformSpace β\nf : γ → β\n⊢ Eq (UniformFun.uniformSpace α γ) (UniformSpace.comap (fun x => Function.comp f x) (UniformFun.uniformSpace α β))","decl":"/-- If `u` is a uniform structures on `β` and `f : γ → β`, then\n`𝒰(α, γ, comap f u) = comap (fun g ↦ f ∘ g) 𝒰(α, γ, u₁)`. -/\nprotected theorem comap_eq {f : γ → β} :\n    𝒰(α, γ, ‹UniformSpace β›.comap f) = 𝒰(α, β, _).comap (f ∘ ·) := by\n  letI : UniformSpace γ := .comap f ‹_›\n  exact (UniformFun.postcomp_isUniformInducing (f := f) ⟨rfl⟩).comap_uniformSpace.symm\n\n"}
{"name":"UniformFun.postcomp_uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\ninst✝ : UniformSpace γ\nf : γ → β\nhf : UniformContinuous f\n⊢ UniformContinuous (Function.comp (⇑UniformFun.ofFun) (Function.comp (fun x => Function.comp f x) ⇑UniformFun.toFun))","decl":"/-- Post-composition by a uniformly continuous function is uniformly continuous on `α →ᵤ β`.\n\nMore precisely, if `f : γ → β` is uniformly continuous, then `(fun g ↦ f ∘ g) : (α →ᵤ γ) → (α →ᵤ β)`\nis uniformly continuous. -/\nprotected theorem postcomp_uniformContinuous [UniformSpace γ] {f : γ → β}\n    (hf : UniformContinuous f) :\n    UniformContinuous (ofFun ∘ (f ∘ ·) ∘ toFun : (α →ᵤ γ) → α →ᵤ β) := by\n  -- This is a direct consequence of `UniformFun.comap_eq`\n    refine uniformContinuous_iff.mpr ?_\n    exact (UniformFun.mono (uniformContinuous_iff.mp hf)).trans_eq UniformFun.comap_eq\n    -- Porting note: the original calc proof below gives a deterministic timeout\n    --calc\n    --  𝒰(α, γ, _) ≤ 𝒰(α, γ, ‹UniformSpace β›.comap f) :=\n    --    UniformFun.mono (uniformContinuous_iff.mp hf)\n    --  _ = 𝒰(α, β, _).comap (f ∘ ·) := @UniformFun.comap_eq α β γ _ f\n\n"}
{"name":"UniformFun.precomp_uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : UniformSpace β\nf : γ → α\n⊢ UniformContinuous fun g => UniformFun.ofFun (Function.comp (UniformFun.toFun g) f)","decl":"/-- Pre-composition by any function is uniformly continuous for the uniform structures of\nuniform convergence.\n\nMore precisely, for any `f : γ → α`, the function `(· ∘ f) : (α →ᵤ β) → (γ →ᵤ β)` is uniformly\ncontinuous. -/\nprotected theorem precomp_uniformContinuous {f : γ → α} :\n    UniformContinuous fun g : α →ᵤ β => ofFun (toFun g ∘ f) := by\n  -- Here we simply go back to filter bases.\n  rw [UniformContinuous,\n      (UniformFun.hasBasis_uniformity α β).tendsto_iff (UniformFun.hasBasis_uniformity γ β)]\n  exact fun U hU => ⟨U, hU, fun uv huv x => huv (f x)⟩\n\n"}
{"name":"UniformFun.uniformContinuous_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n⊢ UniformContinuous ⇑UniformFun.toFun","decl":"/-- The natural map `UniformFun.toFun` from `α →ᵤ β` to `α → β` is uniformly continuous.\n\nIn other words, the uniform structure of uniform convergence is finer than that of pointwise\nconvergence, aka the product uniform structure. -/\nprotected theorem uniformContinuous_toFun : UniformContinuous (toFun : (α →ᵤ β) → α → β) := by\n  -- By definition of the product uniform structure, this is just `uniform_continuous_eval`.\n  rw [uniformContinuous_pi]\n  intro x\n  exact uniformContinuous_eval β x\n\n"}
{"name":"UniformFun.instT2Space","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\ninst✝ : T2Space β\n⊢ T2Space (UniformFun α β)","decl":"/-- The topology of uniform convergence is T₂. -/\ninstance [T2Space β] : T2Space (α →ᵤ β) :=\n  .of_injective_continuous toFun.injective UniformFun.uniformContinuous_toFun.continuous\n\n"}
{"name":"UniformFun.tendsto_iff_tendstoUniformly","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\np : Filter ι\ninst✝ : UniformSpace β\nF : ι → UniformFun α β\nf : UniformFun α β\n⊢ Iff (Filter.Tendsto F p (nhds f)) (TendstoUniformly (Function.comp (⇑UniformFun.toFun) F) (UniformFun.toFun f) p)","decl":"/-- The topology of uniform convergence indeed gives the same notion of convergence as\n`TendstoUniformly`. -/\nprotected theorem tendsto_iff_tendstoUniformly {F : ι → α →ᵤ β} {f : α →ᵤ β} :\n    Tendsto F p (𝓝 f) ↔ TendstoUniformly (toFun ∘ F) (toFun f) p := by\n  rw [(UniformFun.hasBasis_nhds α β f).tendsto_right_iff, TendstoUniformly]\n  simp only [mem_setOf, UniformFun.gen, Function.comp_def]\n\n"}
{"name":"UniformFun.isClosed_setOf_continuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\ninst✝ : TopologicalSpace α\n⊢ IsClosed (setOf fun f => Continuous (UniformFun.toFun f))","decl":"/-- The set of continuous functions is closed in the uniform convergence topology.\nThis is a simple wrapper over `TendstoUniformly.continuous`. -/\ntheorem isClosed_setOf_continuous [TopologicalSpace α] :\n    IsClosed {f : α →ᵤ β | Continuous (toFun f)} := by\n  refine isClosed_iff_forall_filter.2 fun f u _ hu huf ↦ ?_\n  rw [← tendsto_id', UniformFun.tendsto_iff_tendstoUniformly] at huf\n  exact huf.continuous (le_principal_iff.mp hu)\n\n"}
{"name":"UniformFun.uniformSpace_eq_inf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\nδ₁ : Type u_6\nδ₂ : Type u_7\nφ₁ : δ₁ → α\nφ₂ : δ₂ → α\nh_cover : Eq (Union.union (Set.range φ₁) (Set.range φ₂)) Set.univ\n⊢ Eq (UniformFun.uniformSpace α β) (Min.min (UniformSpace.comap (Function.comp (⇑UniformFun.ofFun) (Function.comp (fun x => Function.comp x φ₁) ⇑UniformFun.toFun)) (UniformFun.uniformSpace δ₁ β)) (UniformSpace.comap (Function.comp (⇑UniformFun.ofFun) (Function.comp (fun x => Function.comp x φ₂) ⇑UniformFun.toFun)) (UniformFun.uniformSpace δ₂ β)))","decl":"variable {α} (β) in\ntheorem uniformSpace_eq_inf_precomp_of_cover {δ₁ δ₂ : Type*} (φ₁ : δ₁ → α) (φ₂ : δ₂ → α)\n    (h_cover : range φ₁ ∪ range φ₂ = univ) :\n    𝒰(α, β, _) =\n      .comap (ofFun ∘ (· ∘ φ₁) ∘ toFun) 𝒰(δ₁, β, _) ⊓\n      .comap (ofFun ∘ (· ∘ φ₂) ∘ toFun) 𝒰(δ₂, β, _) := by\n  ext : 1\n  refine le_antisymm (le_inf ?_ ?_) ?_\n  · exact tendsto_iff_comap.mp UniformFun.precomp_uniformContinuous\n  · exact tendsto_iff_comap.mp UniformFun.precomp_uniformContinuous\n  · refine\n      (UniformFun.hasBasis_uniformity δ₁ β |>.comap _).inf\n      (UniformFun.hasBasis_uniformity δ₂ β |>.comap _)\n        |>.le_basis_iff (UniformFun.hasBasis_uniformity α β) |>.mpr fun U hU ↦\n        ⟨⟨U, U⟩, ⟨hU, hU⟩, fun ⟨f, g⟩ hfg x ↦ ?_⟩\n    rcases h_cover.ge <| mem_univ x with (⟨y, rfl⟩|⟨y, rfl⟩)\n    · exact hfg.1 y\n    · exact hfg.2 y\n\n"}
{"name":"UniformFun.uniformSpace_eq_iInf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : UniformSpace β\nδ : ι → Type u_6\nφ : (i : ι) → δ i → α\nh_cover : Exists fun I => And I.Finite (Eq (Set.iUnion fun i => Set.iUnion fun h => Set.range (φ i)) Set.univ)\n⊢ Eq (UniformFun.uniformSpace α β) (iInf fun i => UniformSpace.comap (Function.comp (⇑UniformFun.ofFun) (Function.comp (fun x => Function.comp x (φ i)) ⇑UniformFun.toFun)) (UniformFun.uniformSpace (δ i) β))","decl":"variable {α} (β) in\ntheorem uniformSpace_eq_iInf_precomp_of_cover {δ : ι → Type*} (φ : Π i, δ i → α)\n    (h_cover : ∃ I : Set ι, I.Finite ∧ ⋃ i ∈ I, range (φ i) = univ) :\n    𝒰(α, β, _) = ⨅ i, .comap (ofFun ∘ (· ∘ φ i) ∘ toFun) 𝒰(δ i, β, _) := by\n  ext : 1\n  simp_rw [iInf_uniformity, uniformity_comap]\n  refine le_antisymm (le_iInf fun i ↦ tendsto_iff_comap.mp UniformFun.precomp_uniformContinuous) ?_\n  rcases h_cover with ⟨I, I_finite, I_cover⟩\n  refine Filter.hasBasis_iInf (fun i : ι ↦ UniformFun.hasBasis_uniformity (δ i) β |>.comap _)\n      |>.le_basis_iff (UniformFun.hasBasis_uniformity α β) |>.mpr fun U hU ↦\n    ⟨⟨I, fun _ ↦ U⟩, ⟨I_finite, fun _ ↦ hU⟩, fun ⟨f, g⟩ hfg x ↦ ?_⟩\n  rcases mem_iUnion₂.mp <| I_cover.ge <| mem_univ x with ⟨i, hi, y, rfl⟩\n  exact mem_iInter.mp hfg ⟨i, hi⟩ y\n\n"}
{"name":"UniformOnFun.gen_eq_preimage_restrict","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\nS : Set α\nV : Set (Prod β β)\n⊢ Eq (UniformOnFun.gen 𝔖 S V) (Set.preimage (Prod.map (Function.comp S.restrict ⇑UniformFun.toFun) (Function.comp S.restrict ⇑UniformFun.toFun)) (UniformFun.gen (↑S) β V))","decl":"/-- For `S : Set α` and `V : Set (β × β)`, we have\n`UniformOnFun.gen 𝔖 S V = (S.restrict × S.restrict) ⁻¹' (UniformFun.gen S β V)`.\nThis is the crucial fact for proving that the family `UniformOnFun.gen S V` for `S ∈ 𝔖` and\n`V ∈ 𝓤 β` is indeed a basis for the uniformity `α →ᵤ[𝔖] β` endowed with `𝒱(α, β, 𝔖, uβ)`\nthe uniform structure of `𝔖`-convergence, as defined in `UniformOnFun.uniformSpace`. -/\nprotected theorem gen_eq_preimage_restrict {𝔖} (S : Set α) (V : Set (β × β)) :\n    UniformOnFun.gen 𝔖 S V =\n      Prod.map (S.restrict ∘ UniformFun.toFun) (S.restrict ∘ UniformFun.toFun) ⁻¹'\n        UniformFun.gen S β V := by\n  ext uv\n  exact ⟨fun h ⟨x, hx⟩ => h x hx, fun h x hx => h ⟨x, hx⟩⟩\n\n"}
{"name":"UniformOnFun.gen_mono","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\nS S' : Set α\nV V' : Set (Prod β β)\nhS : HasSubset.Subset S' S\nhV : HasSubset.Subset V V'\n⊢ HasSubset.Subset (UniformOnFun.gen 𝔖 S V) (UniformOnFun.gen 𝔖 S' V')","decl":"/-- `UniformOnFun.gen` is antitone in the first argument and monotone in the second. -/\nprotected theorem gen_mono {𝔖} {S S' : Set α} {V V' : Set (β × β)} (hS : S' ⊆ S) (hV : V ⊆ V') :\n    UniformOnFun.gen 𝔖 S V ⊆ UniformOnFun.gen 𝔖 S' V' := fun _uv h x hx => hV (h x <| hS hx)\n\n"}
{"name":"UniformOnFun.isBasis_gen","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\nh : 𝔖.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\n𝓑 : FilterBasis (Prod β β)\n⊢ Filter.IsBasis (fun SV => And (Membership.mem 𝔖 SV.1) (Membership.mem 𝓑 SV.2)) fun SV => UniformOnFun.gen 𝔖 SV.1 SV.2","decl":"/-- If `𝔖 : Set (Set α)` is nonempty and directed and `𝓑` is a filter basis on `β × β`, then the\nfamily `UniformOnFun.gen 𝔖 S V` for `S ∈ 𝔖` and `V ∈ 𝓑` is a filter basis on\n`(α →ᵤ[𝔖] β) × (α →ᵤ[𝔖] β)`.\nWe will show in `has_basis_uniformity_of_basis` that, if `𝓑` is a basis for `𝓤 β`, then the\ncorresponding filter is the uniformity of `α →ᵤ[𝔖] β`. -/\nprotected theorem isBasis_gen (𝔖 : Set (Set α)) (h : 𝔖.Nonempty) (h' : DirectedOn (· ⊆ ·) 𝔖)\n    (𝓑 : FilterBasis <| β × β) :\n    IsBasis (fun SV : Set α × Set (β × β) => SV.1 ∈ 𝔖 ∧ SV.2 ∈ 𝓑) fun SV =>\n      UniformOnFun.gen 𝔖 SV.1 SV.2 :=\n  ⟨h.prod 𝓑.nonempty, fun {U₁V₁ U₂V₂} h₁ h₂ =>\n    let ⟨U₃, hU₃, hU₁₃, hU₂₃⟩ := h' U₁V₁.1 h₁.1 U₂V₂.1 h₂.1\n    let ⟨V₃, hV₃, hV₁₂₃⟩ := 𝓑.inter_sets h₁.2 h₂.2\n    ⟨⟨U₃, V₃⟩,\n      ⟨⟨hU₃, hV₃⟩, fun _ H =>\n        ⟨fun x hx => (hV₁₂₃ <| H x <| hU₁₃ hx).1, fun x hx => (hV₁₂₃ <| H x <| hU₂₃ hx).2⟩⟩⟩⟩\n\n"}
{"name":"UniformOnFun.topologicalSpace_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\n⊢ Eq (UniformOnFun.topologicalSpace α β 𝔖) (iInf fun s => iInf fun x => TopologicalSpace.induced (Function.comp (⇑UniformFun.ofFun) (Function.comp s.restrict ⇑(UniformOnFun.toFun 𝔖))) (UniformFun.topologicalSpace (↑s) β))","decl":"/-- The topology of `𝔖`-convergence is the infimum, for `S ∈ 𝔖`, of topology induced by the map\nof `S.restrict : (α →ᵤ[𝔖] β) → (↥S →ᵤ β)` of restriction to `S`, where `↥S →ᵤ β` is endowed with\nthe topology of uniform convergence. -/\nprotected theorem topologicalSpace_eq :\n    UniformOnFun.topologicalSpace α β 𝔖 =\n      ⨅ (s : Set α) (_ : s ∈ 𝔖), TopologicalSpace.induced\n        (UniformFun.ofFun ∘ s.restrict ∘ toFun 𝔖) (UniformFun.topologicalSpace s β) := by\n  simp only [UniformOnFun.topologicalSpace, UniformSpace.toTopologicalSpace_iInf]\n  rfl\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity_of_basis_aux₁","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\np : ι → Prop\ns : ι → Set (Prod β β)\nhb : (uniformity β).HasBasis p s\nS : Set α\n⊢ (uniformity (UniformOnFun α β 𝔖)).HasBasis p fun i => UniformOnFun.gen 𝔖 S (s i)","decl":"protected theorem hasBasis_uniformity_of_basis_aux₁ {p : ι → Prop} {s : ι → Set (β × β)}\n    (hb : HasBasis (𝓤 β) p s) (S : Set α) :\n    (@uniformity (α →ᵤ[𝔖] β) ((UniformFun.uniformSpace S β).comap S.restrict)).HasBasis p fun i =>\n      UniformOnFun.gen 𝔖 S (s i) := by\n  simp_rw [UniformOnFun.gen_eq_preimage_restrict, uniformity_comap]\n  exact (UniformFun.hasBasis_uniformity_of_basis S β hb).comap _\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity_of_basis_aux₂","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nh : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\np : ι → Prop\ns : ι → Set (Prod β β)\nhb : (uniformity β).HasBasis p s\n⊢ DirectedOn (Order.Preimage (fun s => UniformSpace.comap s.restrict (UniformFun.uniformSpace (↑s) β)) GE.ge) 𝔖","decl":"protected theorem hasBasis_uniformity_of_basis_aux₂ (h : DirectedOn (· ⊆ ·) 𝔖) {p : ι → Prop}\n    {s : ι → Set (β × β)} (hb : HasBasis (𝓤 β) p s) :\n    DirectedOn\n      ((fun s : Set α => (UniformFun.uniformSpace s β).comap (s.restrict : (α →ᵤ β) → s →ᵤ β)) ⁻¹'o\n        GE.ge)\n      𝔖 :=\n  h.mono fun _ _ hst =>\n    ((UniformOnFun.hasBasis_uniformity_of_basis_aux₁ α β 𝔖 hb _).le_basis_iff\n          (UniformOnFun.hasBasis_uniformity_of_basis_aux₁ α β 𝔖 hb _)).mpr\n      fun V hV => ⟨V, hV, UniformOnFun.gen_mono hst subset_rfl⟩\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nh : 𝔖.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\np : ι → Prop\ns : ι → Set (Prod β β)\nhb : (uniformity β).HasBasis p s\n⊢ (uniformity (UniformOnFun α β 𝔖)).HasBasis (fun Si => And (Membership.mem 𝔖 Si.1) (p Si.2)) fun Si => UniformOnFun.gen 𝔖 Si.1 (s Si.2)","decl":"/-- If `𝔖 : Set (Set α)` is nonempty and directed and `𝓑` is a filter basis of `𝓤 β`, then the\nuniformity of `α →ᵤ[𝔖] β` admits the family `{(f, g) | ∀ x ∈ S, (f x, g x) ∈ V}` for `S ∈ 𝔖` and\n`V ∈ 𝓑` as a filter basis. -/\nprotected theorem hasBasis_uniformity_of_basis (h : 𝔖.Nonempty) (h' : DirectedOn (· ⊆ ·) 𝔖)\n    {p : ι → Prop} {s : ι → Set (β × β)} (hb : HasBasis (𝓤 β) p s) :\n    (𝓤 (α →ᵤ[𝔖] β)).HasBasis (fun Si : Set α × ι => Si.1 ∈ 𝔖 ∧ p Si.2) fun Si =>\n      UniformOnFun.gen 𝔖 Si.1 (s Si.2) := by\n  simp only [iInf_uniformity]\n  exact\n    hasBasis_biInf_of_directed h (fun S => UniformOnFun.gen 𝔖 S ∘ s) _\n      (fun S _hS => UniformOnFun.hasBasis_uniformity_of_basis_aux₁ α β 𝔖 hb S)\n      (UniformOnFun.hasBasis_uniformity_of_basis_aux₂ α β 𝔖 h' hb)\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nh : 𝔖.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\n⊢ (uniformity (UniformOnFun α β 𝔖)).HasBasis (fun SV => And (Membership.mem 𝔖 SV.1) (Membership.mem (uniformity β) SV.2)) fun SV => UniformOnFun.gen 𝔖 SV.1 SV.2","decl":"/-- If `𝔖 : Set (Set α)` is nonempty and directed, then the uniformity of `α →ᵤ[𝔖] β` admits the\nfamily `{(f, g) | ∀ x ∈ S, (f x, g x) ∈ V}` for `S ∈ 𝔖` and `V ∈ 𝓤 β` as a filter basis. -/\nprotected theorem hasBasis_uniformity (h : 𝔖.Nonempty) (h' : DirectedOn (· ⊆ ·) 𝔖) :\n    (𝓤 (α →ᵤ[𝔖] β)).HasBasis (fun SV : Set α × Set (β × β) => SV.1 ∈ 𝔖 ∧ SV.2 ∈ 𝓤 β) fun SV =>\n      UniformOnFun.gen 𝔖 SV.1 SV.2 :=\n  UniformOnFun.hasBasis_uniformity_of_basis α β 𝔖 h h' (𝓤 β).basis_sets\n\n"}
{"name":"UniformOnFun.hasBasis_uniformity_of_covering_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\nι : Type u_5\nι' : Type u_6\ninst✝ : Nonempty ι\nt : ι → Set α\np : ι' → Prop\nV : ι' → Set (Prod β β)\nht : ∀ (i : ι), Membership.mem 𝔖 (t i)\nhdir : Directed (fun x1 x2 => HasSubset.Subset x1 x2) t\nhex : ∀ (s : Set α), Membership.mem 𝔖 s → Exists fun i => HasSubset.Subset s (t i)\nhb : (uniformity β).HasBasis p V\n⊢ (uniformity (UniformOnFun α β 𝔖)).HasBasis (fun i => p i.2) fun i => UniformOnFun.gen 𝔖 (t i.1) (V i.2)","decl":"/-- Let `t i` be a nonempty directed subfamily of `𝔖`\nsuch that every `s ∈ 𝔖` is included in some `t i`.\nLet `V` bounded by `p` be a basis of entourages of `β`.\n\nThen `UniformOnFun.gen 𝔖 (t i) (V j)` bounded by `p j` is a basis of entourages of `α →ᵤ[𝔖] β`. -/\nprotected theorem hasBasis_uniformity_of_covering_of_basis {ι ι' : Type*} [Nonempty ι]\n    {t : ι → Set α} {p : ι' → Prop} {V : ι' → Set (β × β)} (ht : ∀ i, t i ∈ 𝔖)\n    (hdir : Directed (· ⊆ ·) t) (hex : ∀ s ∈ 𝔖, ∃ i, s ⊆ t i) (hb : HasBasis (𝓤 β) p V) :\n    (𝓤 (α →ᵤ[𝔖] β)).HasBasis (fun i : ι × ι' ↦ p i.2) fun i ↦\n      UniformOnFun.gen 𝔖 (t i.1) (V i.2) := by\n  have hne : 𝔖.Nonempty := (range_nonempty t).mono (range_subset_iff.2 ht)\n  have hd : DirectedOn (· ⊆ ·) 𝔖 := fun s₁ hs₁ s₂ hs₂ ↦ by\n    rcases hex s₁ hs₁, hex s₂ hs₂ with ⟨⟨i₁, his₁⟩, i₂, his₂⟩\n    rcases hdir i₁ i₂ with ⟨i, hi₁, hi₂⟩\n    exact ⟨t i, ht _, his₁.trans hi₁, his₂.trans hi₂⟩\n  refine (UniformOnFun.hasBasis_uniformity_of_basis α β 𝔖 hne hd hb).to_hasBasis\n    (fun ⟨s, i'⟩ ⟨hs, hi'⟩ ↦ ?_) fun ⟨i, i'⟩ hi' ↦ ⟨(t i, i'), ⟨ht i, hi'⟩, Subset.rfl⟩\n  rcases hex s hs with ⟨i, hi⟩\n  exact ⟨(i, i'), hi', UniformOnFun.gen_mono hi Subset.rfl⟩\n\n"}
{"name":"UniformOnFun.hasAntitoneBasis_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace β\n𝔖 : Set (Set α)\nι : Type u_5\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nt : ι → Set α\nV : ι → Set (Prod β β)\nht : ∀ (n : ι), Membership.mem 𝔖 (t n)\nhmono : Monotone t\nhex : ∀ (s : Set α), Membership.mem 𝔖 s → Exists fun n => HasSubset.Subset s (t n)\nhb : (uniformity β).HasAntitoneBasis V\n⊢ (uniformity (UniformOnFun α β 𝔖)).HasAntitoneBasis fun n => UniformOnFun.gen 𝔖 (t n) (V n)","decl":"/-- If `t n` is a monotone sequence of sets in `𝔖`\nsuch that each `s ∈ 𝔖` is included in some `t n`\nand `V n` is an antitone basis of entourages of `β`,\nthen `UniformOnFun.gen 𝔖 (t n) (V n)` is an antitone basis of entourages of `α →ᵤ[𝔖] β`. -/\nprotected theorem hasAntitoneBasis_uniformity {ι : Type*} [Preorder ι] [IsDirected ι (· ≤ ·)]\n    {t : ι → Set α} {V : ι → Set (β × β)}\n    (ht : ∀ n, t n ∈ 𝔖) (hmono : Monotone t) (hex : ∀ s ∈ 𝔖, ∃ n, s ⊆ t n)\n    (hb : HasAntitoneBasis (𝓤 β) V) :\n    (𝓤 (α →ᵤ[𝔖] β)).HasAntitoneBasis fun n ↦ UniformOnFun.gen 𝔖 (t n) (V n) := by\n  have := hb.nonempty\n  refine ⟨(UniformOnFun.hasBasis_uniformity_of_covering_of_basis 𝔖\n    ht hmono.directed_le hex hb.1).to_hasBasis ?_ fun i _ ↦ ⟨(i, i), trivial, Subset.rfl⟩, ?_⟩\n  · rintro ⟨k, l⟩ -\n    rcases directed_of (· ≤ ·) k l with ⟨n, hkn, hln⟩\n    exact ⟨n, trivial, UniformOnFun.gen_mono (hmono hkn) (hb.2 <| hln)⟩\n  · exact fun k l h ↦ UniformOnFun.gen_mono (hmono h) (hb.2 h)\n\n"}
{"name":"UniformOnFun.isCountablyGenerated_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : (uniformity β).IsCountablyGenerated\nt : Nat → Set α\nht : ∀ (n : Nat), Membership.mem 𝔖 (t n)\nhmono : Monotone t\nhex : ∀ (s : Set α), Membership.mem 𝔖 s → Exists fun n => HasSubset.Subset s (t n)\n⊢ (uniformity (UniformOnFun α β 𝔖)).IsCountablyGenerated","decl":"protected theorem isCountablyGenerated_uniformity [IsCountablyGenerated (𝓤 β)] {t : ℕ → Set α}\n    (ht : ∀ n, t n ∈ 𝔖) (hmono : Monotone t) (hex : ∀ s ∈ 𝔖, ∃ n, s ⊆ t n) :\n    IsCountablyGenerated (𝓤 (α →ᵤ[𝔖] β)) :=\n  let ⟨_V, hV⟩ := exists_antitone_basis (𝓤 β)\n  (UniformOnFun.hasAntitoneBasis_uniformity 𝔖 ht hmono hex hV).isCountablyGenerated\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nf : UniformOnFun α β 𝔖\nh : 𝔖.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\np : ι → Prop\ns : ι → Set (Prod β β)\nhb : (uniformity β).HasBasis p s\n⊢ (nhds f).HasBasis (fun Si => And (Membership.mem 𝔖 Si.1) (p Si.2)) fun Si => setOf fun g => Membership.mem (UniformOnFun.gen 𝔖 Si.1 (s Si.2)) { fst := g, snd := f }","decl":"/-- For `f : α →ᵤ[𝔖] β`, where `𝔖 : Set (Set α)` is nonempty and directed, `𝓝 f` admits the\nfamily `{g | ∀ x ∈ S, (f x, g x) ∈ V}` for `S ∈ 𝔖` and `V ∈ 𝓑` as a filter basis, for any basis\n`𝓑` of `𝓤 β`. -/\nprotected theorem hasBasis_nhds_of_basis (f : α →ᵤ[𝔖] β) (h : 𝔖.Nonempty)\n    (h' : DirectedOn (· ⊆ ·) 𝔖) {p : ι → Prop} {s : ι → Set (β × β)} (hb : HasBasis (𝓤 β) p s) :\n    (𝓝 f).HasBasis (fun Si : Set α × ι => Si.1 ∈ 𝔖 ∧ p Si.2) fun Si =>\n      { g | (g, f) ∈ UniformOnFun.gen 𝔖 Si.1 (s Si.2) } :=\n  letI : UniformSpace (α → β) := UniformOnFun.uniformSpace α β 𝔖\n  nhds_basis_uniformity (UniformOnFun.hasBasis_uniformity_of_basis α β 𝔖 h h' hb)\n\n"}
{"name":"UniformOnFun.hasBasis_nhds","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nf : UniformOnFun α β 𝔖\nh : 𝔖.Nonempty\nh' : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\n⊢ (nhds f).HasBasis (fun SV => And (Membership.mem 𝔖 SV.1) (Membership.mem (uniformity β) SV.2)) fun SV => setOf fun g => Membership.mem (UniformOnFun.gen 𝔖 SV.1 SV.2) { fst := g, snd := f }","decl":"/-- For `f : α →ᵤ[𝔖] β`, where `𝔖 : Set (Set α)` is nonempty and directed, `𝓝 f` admits the\nfamily `{g | ∀ x ∈ S, (f x, g x) ∈ V}` for `S ∈ 𝔖` and `V ∈ 𝓤 β` as a filter basis. -/\nprotected theorem hasBasis_nhds (f : α →ᵤ[𝔖] β) (h : 𝔖.Nonempty) (h' : DirectedOn (· ⊆ ·) 𝔖) :\n    (𝓝 f).HasBasis (fun SV : Set α × Set (β × β) => SV.1 ∈ 𝔖 ∧ SV.2 ∈ 𝓤 β) fun SV =>\n      { g | (g, f) ∈ UniformOnFun.gen 𝔖 SV.1 SV.2 } :=\n  UniformOnFun.hasBasis_nhds_of_basis α β 𝔖 f h h' (Filter.basis_sets _)\n\n"}
{"name":"UniformOnFun.uniformContinuous_restrict","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nh : Membership.mem 𝔖 s\n⊢ UniformContinuous (Function.comp (⇑UniformFun.ofFun) (Function.comp s.restrict ⇑(UniformOnFun.toFun 𝔖)))","decl":"/-- If `S ∈ 𝔖`, then the restriction to `S` is a uniformly continuous map from `α →ᵤ[𝔖] β` to\n`↥S →ᵤ β`. -/\nprotected theorem uniformContinuous_restrict (h : s ∈ 𝔖) :\n    UniformContinuous (UniformFun.ofFun ∘ (s.restrict : (α → β) → s → β) ∘ toFun 𝔖) := by\n  change _ ≤ _\n  simp only [UniformOnFun.uniformSpace, map_le_iff_le_comap, iInf_uniformity]\n  exact iInf₂_le s h\n\n"}
{"name":"UniformOnFun.uniformity_eq_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nι : Sort u_5\np : ι → Prop\nV : ι → Set (Prod β β)\nh : (uniformity β).HasBasis p V\n⊢ Eq (uniformity (UniformOnFun α β 𝔖)) (iInf fun s => iInf fun h => iInf fun i => iInf fun x => Filter.principal (UniformOnFun.gen 𝔖 s (V i)))","decl":"/-- A version of `UniformOnFun.hasBasis_uniformity_of_basis`\nwith weaker conclusion and weaker assumptions.\n\nWe make no assumptions about the set `𝔖`\nbut conclude only that the uniformity is equal to some indexed infimum. -/\nprotected theorem uniformity_eq_of_basis {ι : Sort*} {p : ι → Prop} {V : ι → Set (β × β)}\n    (h : (𝓤 β).HasBasis p V) :\n    𝓤 (α →ᵤ[𝔖] β) = ⨅ s ∈ 𝔖, ⨅ (i) (_ : p i), 𝓟 (UniformOnFun.gen 𝔖 s (V i)) := by\n  simp_rw [iInf_uniformity, uniformity_comap,\n    (UniformFun.hasBasis_uniformity_of_basis _ _ h).eq_biInf, comap_iInf, comap_principal,\n    Function.comp_apply, UniformFun.gen, Subtype.forall, UniformOnFun.gen, preimage_setOf_eq,\n    Prod.map_fst, Prod.map_snd, Function.comp_apply, UniformFun.toFun_ofFun, restrict_apply]\n\n"}
{"name":"UniformOnFun.uniformity_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\n⊢ Eq (uniformity (UniformOnFun α β 𝔖)) (iInf fun s => iInf fun h => iInf fun V => iInf fun h => Filter.principal (UniformOnFun.gen 𝔖 s V))","decl":"protected theorem uniformity_eq : 𝓤 (α →ᵤ[𝔖] β) = ⨅ s ∈ 𝔖, ⨅ V ∈ 𝓤 β, 𝓟 (UniformOnFun.gen 𝔖 s V) :=\n  UniformOnFun.uniformity_eq_of_basis _ _ (𝓤 β).basis_sets\n\n"}
{"name":"UniformOnFun.gen_mem_uniformity","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nhs : Membership.mem 𝔖 s\nV : Set (Prod β β)\nhV : Membership.mem (uniformity β) V\n⊢ Membership.mem (uniformity (UniformOnFun α β 𝔖)) (UniformOnFun.gen 𝔖 s V)","decl":"protected theorem gen_mem_uniformity (hs : s ∈ 𝔖) {V : Set (β × β)} (hV : V ∈ 𝓤 β) :\n    UniformOnFun.gen 𝔖 s V ∈ 𝓤 (α →ᵤ[𝔖] β) := by\n  rw [UniformOnFun.uniformity_eq]\n  apply_rules [mem_iInf_of_mem, mem_principal_self]\n\n"}
{"name":"UniformOnFun.nhds_eq_of_basis","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nι : Sort u_5\np : ι → Prop\nV : ι → Set (Prod β β)\nh : (uniformity β).HasBasis p V\nf : UniformOnFun α β 𝔖\n⊢ Eq (nhds f) (iInf fun s => iInf fun h => iInf fun i => iInf fun x => Filter.principal (setOf fun g => ∀ (x : α), Membership.mem s x → Membership.mem (V i) { fst := (UniformOnFun.toFun 𝔖) f x, snd := (UniformOnFun.toFun 𝔖) g x }))","decl":"/-- A version of `UniformOnFun.hasBasis_nhds_of_basis`\nwith weaker conclusion and weaker assumptions.\n\nWe make no assumptions about the set `𝔖`\nbut conclude only that the neighbourhoods filter is equal to some indexed infimum. -/\nprotected theorem nhds_eq_of_basis {ι : Sort*} {p : ι → Prop} {V : ι → Set (β × β)}\n    (h : (𝓤 β).HasBasis p V) (f : α →ᵤ[𝔖] β) :\n    𝓝 f = ⨅ s ∈ 𝔖, ⨅ (i) (_ : p i), 𝓟 {g | ∀ x ∈ s, (toFun 𝔖 f x, toFun 𝔖 g x) ∈ V i} := by\n  simp_rw [nhds_eq_comap_uniformity, UniformOnFun.uniformity_eq_of_basis _ _ h, comap_iInf,\n    comap_principal, UniformOnFun.gen, preimage_setOf_eq]\n\n"}
{"name":"UniformOnFun.nhds_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nf : UniformOnFun α β 𝔖\n⊢ Eq (nhds f) (iInf fun s => iInf fun h => iInf fun V => iInf fun h => Filter.principal (setOf fun g => ∀ (x : α), Membership.mem s x → Membership.mem V { fst := (UniformOnFun.toFun 𝔖) f x, snd := (UniformOnFun.toFun 𝔖) g x }))","decl":"protected theorem nhds_eq (f : α →ᵤ[𝔖] β) :\n    𝓝 f = ⨅ s ∈ 𝔖, ⨅ V ∈ 𝓤 β, 𝓟 {g | ∀ x ∈ s, (toFun 𝔖 f x, toFun 𝔖 g x) ∈ V} :=\n  UniformOnFun.nhds_eq_of_basis _ _ (𝓤 β).basis_sets f\n\n"}
{"name":"UniformOnFun.gen_mem_nhds","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nf : UniformOnFun α β 𝔖\nhs : Membership.mem 𝔖 s\nV : Set (Prod β β)\nhV : Membership.mem (uniformity β) V\n⊢ Membership.mem (nhds f) (setOf fun g => ∀ (x : α), Membership.mem s x → Membership.mem V { fst := (UniformOnFun.toFun 𝔖) f x, snd := (UniformOnFun.toFun 𝔖) g x })","decl":"protected theorem gen_mem_nhds (f : α →ᵤ[𝔖] β) (hs : s ∈ 𝔖) {V : Set (β × β)} (hV : V ∈ 𝓤 β) :\n    {g | ∀ x ∈ s, (toFun 𝔖 f x, toFun 𝔖 g x) ∈ V} ∈ 𝓝 f := by\n  rw [UniformOnFun.nhds_eq]\n  apply_rules [mem_iInf_of_mem, mem_principal_self]\n\n"}
{"name":"UniformOnFun.uniformContinuous_ofUniformFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\n⊢ UniformContinuous fun f => (UniformOnFun.ofFun 𝔖) (UniformFun.toFun f)","decl":"theorem uniformContinuous_ofUniformFun :\n    UniformContinuous fun f : α →ᵤ β ↦ ofFun 𝔖 (UniformFun.toFun f) := by\n  simp only [UniformContinuous, UniformOnFun.uniformity_eq, tendsto_iInf, tendsto_principal,\n    (UniformFun.hasBasis_uniformity _ _).eventually_iff]\n  exact fun _ _ U hU ↦ ⟨U, hU, fun f hf x _ ↦ hf x⟩\n\n"}
{"name":"UniformOnFun.mono","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nγ : Type u_3\nu₁ u₂ : UniformSpace γ\nhu : LE.le u₁ u₂\n𝔖₁ 𝔖₂ : Set (Set α)\nh𝔖 : HasSubset.Subset 𝔖₂ 𝔖₁\n⊢ LE.le (UniformOnFun.uniformSpace α γ 𝔖₁) (UniformOnFun.uniformSpace α γ 𝔖₂)","decl":"/-- Let `u₁`, `u₂` be two uniform structures on `γ` and `𝔖₁ 𝔖₂ : Set (Set α)`. If `u₁ ≤ u₂` and\n`𝔖₂ ⊆ 𝔖₁` then `𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)`. -/\nprotected theorem mono ⦃u₁ u₂ : UniformSpace γ⦄ (hu : u₁ ≤ u₂) ⦃𝔖₁ 𝔖₂ : Set (Set α)⦄\n    (h𝔖 : 𝔖₂ ⊆ 𝔖₁) : 𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂) :=\n  calc\n    𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₁) := iInf_le_iInf_of_subset h𝔖\n    _ ≤ 𝒱(α, γ, 𝔖₂, u₂) := iInf₂_mono fun _i _hi => UniformSpace.comap_mono <| UniformFun.mono hu\n\n"}
{"name":"UniformOnFun.uniformContinuous_eval_of_mem","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nx : α\nhxs : Membership.mem s x\nhs : Membership.mem 𝔖 s\n⊢ UniformContinuous (Function.comp (Function.eval x) ⇑(UniformOnFun.toFun 𝔖))","decl":"/-- If `x : α` is in some `S ∈ 𝔖`, then evaluation at `x` is uniformly continuous on\n`α →ᵤ[𝔖] β`. -/\ntheorem uniformContinuous_eval_of_mem {x : α} (hxs : x ∈ s) (hs : s ∈ 𝔖) :\n    UniformContinuous ((Function.eval x : (α → β) → β) ∘ toFun 𝔖) :=\n  (UniformFun.uniformContinuous_eval β (⟨x, hxs⟩ : s)).comp\n    (UniformOnFun.uniformContinuous_restrict α β 𝔖 hs)\n\n"}
{"name":"UniformOnFun.uniformContinuous_eval_of_mem_sUnion","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nx : α\nhx : Membership.mem 𝔖.sUnion x\n⊢ UniformContinuous (Function.comp (Function.eval x) ⇑(UniformOnFun.toFun 𝔖))","decl":"theorem uniformContinuous_eval_of_mem_sUnion {x : α} (hx : x ∈ ⋃₀ 𝔖) :\n    UniformContinuous ((Function.eval x : (α → β) → β) ∘ toFun 𝔖) :=\n  let ⟨_s, hs, hxs⟩ := hx\n  uniformContinuous_eval_of_mem _ _ hxs hs\n\n"}
{"name":"UniformOnFun.uniformContinuous_eval","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nh : Eq 𝔖.sUnion Set.univ\nx : α\n⊢ UniformContinuous (Function.comp (Function.eval x) ⇑(UniformOnFun.toFun 𝔖))","decl":"theorem uniformContinuous_eval (h : ⋃₀ 𝔖 = univ) (x : α) :\n    UniformContinuous ((Function.eval x : (α → β) → β) ∘ toFun 𝔖) :=\n  uniformContinuous_eval_of_mem_sUnion _ _ <| h.symm ▸ mem_univ _\n\n"}
{"name":"UniformOnFun.iInf_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nγ : Type u_3\nι : Type u_4\n𝔖 : Set (Set α)\nu : ι → UniformSpace γ\n⊢ Eq (UniformOnFun.uniformSpace α γ 𝔖) (iInf fun i => UniformOnFun.uniformSpace α γ 𝔖)","decl":"/-- If `u` is a family of uniform structures on `γ`, then\n`𝒱(α, γ, 𝔖, (⨅ i, u i)) = ⨅ i, 𝒱(α, γ, 𝔖, u i)`. -/\nprotected theorem iInf_eq {u : ι → UniformSpace γ} :\n    𝒱(α, γ, 𝔖, ⨅ i, u i) = ⨅ i, 𝒱(α, γ, 𝔖, u i) := by\n  simp_rw [UniformOnFun.uniformSpace, UniformFun.iInf_eq, UniformSpace.comap_iInf]\n  rw [iInf_comm]\n  exact iInf_congr fun s => iInf_comm\n\n"}
{"name":"UniformOnFun.inf_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nγ : Type u_3\n𝔖 : Set (Set α)\nu₁ u₂ : UniformSpace γ\n⊢ Eq (UniformOnFun.uniformSpace α γ 𝔖) (Min.min (UniformOnFun.uniformSpace α γ 𝔖) (UniformOnFun.uniformSpace α γ 𝔖))","decl":"/-- If `u₁` and `u₂` are two uniform structures on `γ`, then\n`𝒱(α, γ, 𝔖, u₁ ⊓ u₂) = 𝒱(α, γ, 𝔖, u₁) ⊓ 𝒱(α, γ, 𝔖, u₂)`. -/\nprotected theorem inf_eq {u₁ u₂ : UniformSpace γ} :\n    𝒱(α, γ, 𝔖, u₁ ⊓ u₂) = 𝒱(α, γ, 𝔖, u₁) ⊓ 𝒱(α, γ, 𝔖, u₂) := by\n  rw [inf_eq_iInf, inf_eq_iInf, UniformOnFun.iInf_eq]\n  refine iInf_congr fun i => ?_\n  cases i <;> rfl\n\n"}
{"name":"UniformOnFun.comap_eq","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nf : γ → β\n⊢ Eq (UniformOnFun.uniformSpace α γ 𝔖) (UniformSpace.comap (fun x => Function.comp f x) (UniformOnFun.uniformSpace α β 𝔖))","decl":"/-- If `u` is a uniform structure on `β` and `f : γ → β`, then\n`𝒱(α, γ, 𝔖, comap f u) = comap (fun g ↦ f ∘ g) 𝒱(α, γ, 𝔖, u₁)`. -/\nprotected theorem comap_eq {f : γ → β} :\n    𝒱(α, γ, 𝔖, ‹UniformSpace β›.comap f) = 𝒱(α, β, 𝔖, _).comap (f ∘ ·) := by\n  -- We reduce this to `UniformFun.comap_eq` using the fact that `comap` distributes\n  -- on `iInf`.\n  simp_rw [UniformOnFun.uniformSpace, UniformSpace.comap_iInf, UniformFun.comap_eq, ←\n    UniformSpace.comap_comap]\n  -- By definition, `∀ S ∈ 𝔖, (f ∘ —) ∘ S.restrict = S.restrict ∘ (f ∘ —)`.\n  rfl\n\n"}
{"name":"UniformOnFun.postcomp_uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : UniformSpace γ\nf : γ → β\nhf : UniformContinuous f\n⊢ UniformContinuous (Function.comp (⇑(UniformOnFun.ofFun 𝔖)) (Function.comp (fun x => Function.comp f x) ⇑(UniformOnFun.toFun 𝔖)))","decl":"/-- Post-composition by a uniformly continuous function is uniformly continuous for the\nuniform structures of `𝔖`-convergence.\n\nMore precisely, if `f : γ → β` is uniformly continuous, then\n`(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)` is uniformly continuous. -/\nprotected theorem postcomp_uniformContinuous [UniformSpace γ] {f : γ → β}\n    (hf : UniformContinuous f) : UniformContinuous (ofFun 𝔖 ∘ (f ∘ ·) ∘ toFun 𝔖) := by\n  -- This is a direct consequence of `UniformOnFun.comap_eq`\n  rw [uniformContinuous_iff]\n  exact (UniformOnFun.mono (uniformContinuous_iff.mp hf) subset_rfl).trans_eq UniformOnFun.comap_eq\n\n"}
{"name":"UniformOnFun.postcomp_isUniformInducing","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : UniformSpace γ\nf : γ → β\nhf : IsUniformInducing f\n⊢ IsUniformInducing (Function.comp (⇑(UniformOnFun.ofFun 𝔖)) (Function.comp (fun x => Function.comp f x) ⇑(UniformOnFun.toFun 𝔖)))","decl":"/-- Post-composition by a uniform inducing is a uniform inducing for the\nuniform structures of `𝔖`-convergence.\n\nMore precisely, if `f : γ → β` is a uniform inducing, then\n`(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)` is a uniform inducing. -/\nlemma postcomp_isUniformInducing [UniformSpace γ] {f : γ → β}\n    (hf : IsUniformInducing f) : IsUniformInducing (ofFun 𝔖 ∘ (f ∘ ·) ∘ toFun 𝔖) := by\n  -- This is a direct consequence of `UniformOnFun.comap_eq`\n  constructor\n  replace hf : (𝓤 β).comap (Prod.map f f) = _ := hf.comap_uniformity\n  change comap (Prod.map (ofFun 𝔖 ∘ (f ∘ ·) ∘ toFun 𝔖) (ofFun 𝔖 ∘ (f ∘ ·) ∘ toFun 𝔖)) _ = _\n  rw [← uniformity_comap] at hf ⊢\n  congr\n  rw [← UniformSpace.ext hf, UniformOnFun.comap_eq]\n  rfl\n\n"}
{"name":"UniformOnFun.postcomp_uniformInducing","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : UniformSpace γ\nf : γ → β\nhf : IsUniformInducing f\n⊢ IsUniformInducing (Function.comp (⇑(UniformOnFun.ofFun 𝔖)) (Function.comp (fun x => Function.comp f x) ⇑(UniformOnFun.toFun 𝔖)))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias postcomp_uniformInducing := postcomp_isUniformInducing\n\n"}
{"name":"UniformOnFun.postcomp_isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : UniformSpace γ\nf : γ → β\nhf : IsUniformEmbedding f\n⊢ IsUniformEmbedding (Function.comp (⇑(UniformOnFun.ofFun 𝔖)) (Function.comp (fun x => Function.comp f x) ⇑(UniformOnFun.toFun 𝔖)))","decl":"/-- Post-composition by a uniform embedding is a uniform embedding for the\nuniform structures of `𝔖`-convergence.\n\nMore precisely, if `f : γ → β` is a uniform embedding, then\n`(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)` is a uniform embedding. -/\nprotected theorem postcomp_isUniformEmbedding [UniformSpace γ] {f : γ → β}\n    (hf : IsUniformEmbedding f) : IsUniformEmbedding (ofFun 𝔖 ∘ (f ∘ ·) ∘ toFun 𝔖) where\n  toIsUniformInducing := UniformOnFun.postcomp_isUniformInducing hf.isUniformInducing\n  injective _ _ H := funext fun _ ↦ hf.injective (congrFun H _)\n\n"}
{"name":"UniformOnFun.postcomp_uniformEmbedding","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : UniformSpace γ\nf : γ → β\nhf : IsUniformEmbedding f\n⊢ IsUniformEmbedding (Function.comp (⇑(UniformOnFun.ofFun 𝔖)) (Function.comp (fun x => Function.comp f x) ⇑(UniformOnFun.toFun 𝔖)))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias postcomp_uniformEmbedding := UniformOnFun.postcomp_isUniformEmbedding\n\n"}
{"name":"UniformOnFun.precomp_uniformContinuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\n𝔗 : Set (Set γ)\nf : γ → α\nhf : Set.MapsTo (fun x => Set.image f x) 𝔗 𝔖\n⊢ UniformContinuous fun g => (UniformOnFun.ofFun 𝔗) (Function.comp ((UniformOnFun.toFun 𝔖) g) f)","decl":"/-- Let `f : γ → α`, `𝔖 : Set (Set α)`, `𝔗 : Set (Set γ)`, and assume that `∀ T ∈ 𝔗, f '' T ∈ 𝔖`.\nThen, the function `(fun g ↦ g ∘ f) : (α →ᵤ[𝔖] β) → (γ →ᵤ[𝔗] β)` is uniformly continuous.\n\nNote that one can easily see that assuming `∀ T ∈ 𝔗, ∃ S ∈ 𝔖, f '' T ⊆ S` would work too, but\nwe will get this for free when we prove that `𝒱(α, β, 𝔖, uβ) = 𝒱(α, β, 𝔖', uβ)` where `𝔖'` is the\n***noncovering*** bornology generated by `𝔖`. -/\nprotected theorem precomp_uniformContinuous {𝔗 : Set (Set γ)} {f : γ → α}\n    (hf : MapsTo (f '' ·) 𝔗 𝔖) :\n    UniformContinuous fun g : α →ᵤ[𝔖] β => ofFun 𝔗 (toFun 𝔖 g ∘ f) := by\n  -- This follows from the fact that `(· ∘ f) × (· ∘ f)` maps `gen (f '' t) V` to `gen t V`.\n  simp_rw [UniformContinuous, UniformOnFun.uniformity_eq, tendsto_iInf]\n  refine fun t ht V hV ↦ tendsto_iInf' (f '' t) <| tendsto_iInf' (hf ht) <|\n    tendsto_iInf' V <| tendsto_iInf' hV ?_\n  simpa only [tendsto_principal_principal, UniformOnFun.gen] using fun _ ↦ forall_mem_image.1\n\n"}
{"name":"UniformOnFun.t2Space_of_covering","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : T2Space β\nh : Eq 𝔖.sUnion Set.univ\n⊢ T2Space (UniformOnFun α β 𝔖)","decl":"/-- If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. -/\ntheorem t2Space_of_covering [T2Space β] (h : ⋃₀ 𝔖 = univ) : T2Space (α →ᵤ[𝔖] β) where\n  t2 f g hfg := by\n    obtain ⟨x, hx⟩ := not_forall.mp (mt funext hfg)\n    obtain ⟨s, hs, hxs⟩ : ∃ s ∈ 𝔖, x ∈ s := mem_sUnion.mp (h.symm ▸ True.intro)\n    exact separated_by_continuous (uniformContinuous_eval_of_mem β 𝔖 hxs hs).continuous hx\n\n"}
{"name":"UniformOnFun.uniformContinuous_restrict_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\n⊢ UniformContinuous (Function.comp 𝔖.sUnion.restrict ⇑(UniformOnFun.toFun 𝔖))","decl":"/-- The restriction map from `α →ᵤ[𝔖] β` to `⋃₀ 𝔖 → β` is uniformly continuous. -/\ntheorem uniformContinuous_restrict_toFun :\n    UniformContinuous ((⋃₀ 𝔖).restrict ∘ toFun 𝔖 : (α →ᵤ[𝔖] β) → ⋃₀ 𝔖 → β) := by\n  rw [uniformContinuous_pi]\n  intro ⟨x, hx⟩\n  obtain ⟨s : Set α, hs : s ∈ 𝔖, hxs : x ∈ s⟩ := mem_sUnion.mpr hx\n  exact uniformContinuous_eval_of_mem β 𝔖 hxs hs\n\n"}
{"name":"UniformOnFun.uniformContinuous_toFun","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nh : Eq 𝔖.sUnion Set.univ\n⊢ UniformContinuous ⇑(UniformOnFun.toFun 𝔖)","decl":"/-- If `𝔖` covers `α`, the natural map `UniformOnFun.toFun` from `α →ᵤ[𝔖] β` to `α → β` is\nuniformly continuous.\n\nIn other words, if `𝔖` covers `α`, then the uniform structure of `𝔖`-convergence is finer than\nthat of pointwise convergence. -/\nprotected theorem uniformContinuous_toFun (h : ⋃₀ 𝔖 = univ) :\n    UniformContinuous (toFun 𝔖 : (α →ᵤ[𝔖] β) → α → β) := by\n  rw [uniformContinuous_pi]\n  exact uniformContinuous_eval h\n\n"}
{"name":"UniformOnFun.continuousAt_eval₂","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : TopologicalSpace α\nf : UniformOnFun α β 𝔖\nx : α\nh𝔖 : Exists fun V => And (Membership.mem 𝔖 V) (Membership.mem (nhds x) V)\nhc : ContinuousAt ((UniformOnFun.toFun 𝔖) f) x\n⊢ ContinuousAt (fun fx => (UniformOnFun.toFun 𝔖) fx.1 fx.2) { fst := f, snd := x }","decl":"/-- If `f : α →ᵤ[𝔖] β` is continuous at `x` and `x` admits a neighbourhood `V ∈ 𝔖`,\nthen evaluation of `g : α →ᵤ[𝔖] β` at `y : α` is continuous in `(g, y)` at `(f, x)`. -/\nprotected theorem continuousAt_eval₂ [TopologicalSpace α] {f : α →ᵤ[𝔖] β} {x : α}\n    (h𝔖 : ∃ V ∈ 𝔖, V ∈ 𝓝 x) (hc : ContinuousAt (toFun 𝔖 f) x) :\n    ContinuousAt (fun fx : (α →ᵤ[𝔖] β) × α ↦ toFun 𝔖 fx.1 fx.2) (f, x) := by\n  rw [ContinuousAt, nhds_eq_comap_uniformity, tendsto_comap_iff, ← lift'_comp_uniformity,\n    tendsto_lift']\n  intro U hU\n  rcases h𝔖 with ⟨V, hV, hVx⟩\n  filter_upwards [prod_mem_nhds (UniformOnFun.gen_mem_nhds _ _ _ hV hU)\n    (inter_mem hVx <| hc <| UniformSpace.ball_mem_nhds _ hU)]\n    with ⟨g, y⟩ ⟨hg, hyV, hy⟩ using ⟨toFun 𝔖 f y, hy, hg y hyV⟩\n\n"}
{"name":"UniformOnFun.continuousOn_eval₂","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : TopologicalSpace α\nh𝔖 : ∀ (x : α), Exists fun V => And (Membership.mem 𝔖 V) (Membership.mem (nhds x) V)\n⊢ ContinuousOn (fun fx => (UniformOnFun.toFun 𝔖) fx.1 fx.2) (setOf fun fx => ContinuousAt ((UniformOnFun.toFun 𝔖) fx.1) fx.2)","decl":"/-- If each point of `α` admits a neighbourhood `V ∈ 𝔖`,\nthen the evaluation of `f : α →ᵤ[𝔖] β` at `x : α` is continuous in `(f, x)`\non the set of `(f, x)` such that `f` is continuous at `x`. -/\nprotected theorem continuousOn_eval₂ [TopologicalSpace α] (h𝔖 : ∀ x, ∃ V ∈ 𝔖, V ∈ 𝓝 x) :\n    ContinuousOn (fun fx : (α →ᵤ[𝔖] β) × α ↦ toFun 𝔖 fx.1 fx.2)\n      {fx | ContinuousAt (toFun 𝔖 fx.1) fx.2} := fun (_f, x) hc ↦\n  (UniformOnFun.continuousAt_eval₂ (h𝔖 x) hc).continuousWithinAt\n\n"}
{"name":"UniformOnFun.tendsto_iff_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\np : Filter ι\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nF : ι → UniformOnFun α β 𝔖\nf : UniformOnFun α β 𝔖\n⊢ Iff (Filter.Tendsto F p (nhds f)) (∀ (s : Set α), Membership.mem 𝔖 s → TendstoUniformlyOn (Function.comp (⇑(UniformOnFun.toFun 𝔖)) F) ((UniformOnFun.toFun 𝔖) f) p s)","decl":"/-- Convergence in the topology of `𝔖`-convergence means uniform convergence on `S` (in the sense\nof `TendstoUniformlyOn`) for all `S ∈ 𝔖`. -/\nprotected theorem tendsto_iff_tendstoUniformlyOn {F : ι → α →ᵤ[𝔖] β} {f : α →ᵤ[𝔖] β} :\n    Tendsto F p (𝓝 f) ↔ ∀ s ∈ 𝔖, TendstoUniformlyOn (toFun 𝔖 ∘ F) (toFun 𝔖 f) p s := by\n  simp only [UniformOnFun.nhds_eq, tendsto_iInf, tendsto_principal, TendstoUniformlyOn,\n    Function.comp_apply, mem_setOf]\n\n"}
{"name":"UniformOnFun.continuous_rng_iff","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\nX : Type u_5\ninst✝ : TopologicalSpace X\nf : X → UniformOnFun α β 𝔖\n⊢ Iff (Continuous f) (∀ (s : Set α), Membership.mem 𝔖 s → Continuous (Function.comp (⇑UniformFun.ofFun) (Function.comp s.restrict (Function.comp (⇑(UniformOnFun.toFun 𝔖)) f))))","decl":"protected lemma continuous_rng_iff {X : Type*} [TopologicalSpace X] {f : X → (α →ᵤ[𝔖] β)} :\n    Continuous f ↔ ∀ s ∈ 𝔖,\n      Continuous (UniformFun.ofFun ∘ s.restrict ∘ UniformOnFun.toFun 𝔖 ∘ f) := by\n  simp only [continuous_iff_continuousAt, ContinuousAt,\n    UniformOnFun.tendsto_iff_tendstoUniformlyOn, UniformFun.tendsto_iff_tendstoUniformly,\n    tendstoUniformlyOn_iff_tendstoUniformly_comp_coe, @forall_swap X, Function.comp_apply,\n    Function.comp_def, restrict_eq, UniformFun.toFun_ofFun]\n\n"}
{"name":"UniformOnFun.instCompleteSpace","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : CompleteSpace β\n⊢ CompleteSpace (UniformOnFun α β 𝔖)","decl":"instance [CompleteSpace β] : CompleteSpace (α →ᵤ[𝔖] β) := by\n  rcases isEmpty_or_nonempty β\n  · infer_instance\n  · refine ⟨fun {F} hF ↦ ?_⟩\n    have := hF.1\n    have : ∀ x ∈ ⋃₀ 𝔖, ∃ y : β, Tendsto (toFun 𝔖 · x) F (𝓝 y) := fun x hx ↦\n      CompleteSpace.complete (hF.map (uniformContinuous_eval_of_mem_sUnion _ _ hx))\n    choose! g hg using this\n    use ofFun 𝔖 g\n    simp_rw [UniformOnFun.nhds_eq_of_basis _ _ uniformity_hasBasis_closed, le_iInf₂_iff,\n      le_principal_iff]\n    intro s hs U ⟨hU, hUc⟩\n    rcases cauchy_iff.mp hF |>.2 _ <| UniformOnFun.gen_mem_uniformity _ _ hs hU\n      with ⟨V, hV, hVU⟩\n    filter_upwards [hV] with f hf x hx\n    refine hUc.mem_of_tendsto ((hg x ⟨s, hs, hx⟩).prod_mk_nhds tendsto_const_nhds) ?_\n    filter_upwards [hV] with g' hg' using hVU (mk_mem_prod hg' hf) _ hx\n\n"}
{"name":"UniformOnFun.isClosed_setOf_continuous","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\n𝔖 : Set (Set α)\ninst✝ : TopologicalSpace α\nh : Topology.RestrictGenTopology 𝔖\n⊢ IsClosed (setOf fun f => Continuous ((UniformOnFun.toFun 𝔖) f))","decl":"/-- Suppose that the topology on `α` is defined by its restrictions to the sets of `𝔖`.\n\nThen the set of continuous functions is closed\nin the topology of uniform convergence on the sets of `𝔖`. -/\ntheorem isClosed_setOf_continuous [TopologicalSpace α] (h : RestrictGenTopology 𝔖) :\n    IsClosed {f : α →ᵤ[𝔖] β | Continuous (toFun 𝔖 f)} := by\n  refine isClosed_iff_forall_filter.2 fun f u _ hu huf ↦ h.continuous_iff.2 fun s hs ↦ ?_\n  rw [← tendsto_id', UniformOnFun.tendsto_iff_tendstoUniformlyOn] at huf\n  exact (huf s hs).continuousOn <| hu fun _ ↦ Continuous.continuousOn\n\n"}
{"name":"UniformOnFun.uniformSpace_eq_inf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nδ₁ : Type u_5\nδ₂ : Type u_6\nφ₁ : δ₁ → α\nφ₂ : δ₂ → α\n𝔗₁ : Set (Set δ₁)\n𝔗₂ : Set (Set δ₂)\nh_image₁ : Set.MapsTo (fun x => Set.image φ₁ x) 𝔗₁ 𝔖\nh_image₂ : Set.MapsTo (fun x => Set.image φ₂ x) 𝔗₂ 𝔖\nh_preimage₁ : Set.MapsTo (fun x => Set.preimage φ₁ x) 𝔖 𝔗₁\nh_preimage₂ : Set.MapsTo (fun x => Set.preimage φ₂ x) 𝔖 𝔗₂\nh_cover : ∀ (S : Set α), Membership.mem 𝔖 S → HasSubset.Subset S (Union.union (Set.range φ₁) (Set.range φ₂))\n⊢ Eq (UniformOnFun.uniformSpace α β 𝔖) (Min.min (UniformSpace.comap (Function.comp (⇑(UniformOnFun.ofFun 𝔗₁)) (Function.comp (fun x => Function.comp x φ₁) ⇑(UniformOnFun.toFun 𝔖))) (UniformOnFun.uniformSpace δ₁ β 𝔗₁)) (UniformSpace.comap (Function.comp (⇑(UniformOnFun.ofFun 𝔗₂)) (Function.comp (fun x => Function.comp x φ₂) ⇑(UniformOnFun.toFun 𝔖))) (UniformOnFun.uniformSpace δ₂ β 𝔗₂)))","decl":"variable (𝔖) in\ntheorem uniformSpace_eq_inf_precomp_of_cover {δ₁ δ₂ : Type*} (φ₁ : δ₁ → α) (φ₂ : δ₂ → α)\n    (𝔗₁ : Set (Set δ₁)) (𝔗₂ : Set (Set δ₂))\n    (h_image₁ : MapsTo (φ₁ '' ·) 𝔗₁ 𝔖) (h_image₂ : MapsTo (φ₂ '' ·) 𝔗₂ 𝔖)\n    (h_preimage₁ : MapsTo (φ₁ ⁻¹' ·) 𝔖 𝔗₁) (h_preimage₂ : MapsTo (φ₂ ⁻¹' ·) 𝔖 𝔗₂)\n    (h_cover : ∀ S ∈ 𝔖, S ⊆ range φ₁ ∪ range φ₂) :\n    𝒱(α, β, 𝔖, _) =\n      .comap (ofFun 𝔗₁ ∘ (· ∘ φ₁) ∘ toFun 𝔖) 𝒱(δ₁, β, 𝔗₁, _) ⊓\n      .comap (ofFun 𝔗₂ ∘ (· ∘ φ₂) ∘ toFun 𝔖) 𝒱(δ₂, β, 𝔗₂, _) := by\n  set ψ₁ : Π S : Set α, φ₁ ⁻¹' S → S := fun S ↦ S.restrictPreimage φ₁\n  set ψ₂ : Π S : Set α, φ₂ ⁻¹' S → S := fun S ↦ S.restrictPreimage φ₂\n  have : ∀ S ∈ 𝔖, 𝒰(S, β, _) = .comap (· ∘ ψ₁ S) 𝒰(_, β, _) ⊓ .comap (· ∘ ψ₂ S) 𝒰(_, β, _) := by\n    refine fun S hS ↦ UniformFun.uniformSpace_eq_inf_precomp_of_cover β _ _ ?_\n    simpa only [← univ_subset_iff, ψ₁, ψ₂, range_restrictPreimage, ← preimage_union,\n      ← image_subset_iff, image_univ, Subtype.range_val] using h_cover S hS\n  refine le_antisymm (le_inf ?_ ?_) (le_iInf₂ fun S hS ↦ ?_)\n  · rw [← uniformContinuous_iff]\n    exact UniformOnFun.precomp_uniformContinuous h_image₁\n  · rw [← uniformContinuous_iff]\n    exact UniformOnFun.precomp_uniformContinuous h_image₂\n  · simp_rw [this S hS, UniformSpace.comap_iInf, UniformSpace.comap_inf, ← UniformSpace.comap_comap]\n    exact inf_le_inf\n      (iInf₂_le_of_le _ (h_preimage₁ hS) le_rfl)\n      (iInf₂_le_of_le _ (h_preimage₂ hS) le_rfl)\n\n"}
{"name":"UniformOnFun.uniformSpace_eq_iInf_precomp_of_cover","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : UniformSpace β\n𝔖 : Set (Set α)\nδ : ι → Type u_5\nφ : (i : ι) → δ i → α\n𝔗 : (i : ι) → Set (Set (δ i))\nh_image : ∀ (i : ι), Set.MapsTo (fun x => Set.image (φ i) x) (𝔗 i) 𝔖\nh_preimage : ∀ (i : ι), Set.MapsTo (fun x => Set.preimage (φ i) x) 𝔖 (𝔗 i)\nh_cover : ∀ (S : Set α), Membership.mem 𝔖 S → Exists fun I => And I.Finite (HasSubset.Subset S (Set.iUnion fun i => Set.iUnion fun h => Set.range (φ i)))\n⊢ Eq (UniformOnFun.uniformSpace α β 𝔖) (iInf fun i => UniformSpace.comap (Function.comp (⇑(UniformOnFun.ofFun (𝔗 i))) (Function.comp (fun x => Function.comp x (φ i)) ⇑(UniformOnFun.toFun 𝔖))) (UniformOnFun.uniformSpace (δ i) β (𝔗 i)))","decl":"variable (𝔖) in\ntheorem uniformSpace_eq_iInf_precomp_of_cover {δ : ι → Type*} (φ : Π i, δ i → α)\n    (𝔗 : ∀ i, Set (Set (δ i))) (h_image : ∀ i, MapsTo (φ i '' ·) (𝔗 i) 𝔖)\n    (h_preimage : ∀ i, MapsTo (φ i ⁻¹' ·) 𝔖 (𝔗 i))\n    (h_cover : ∀ S ∈ 𝔖, ∃ I : Set ι, I.Finite ∧ S ⊆ ⋃ i ∈ I, range (φ i)) :\n    𝒱(α, β, 𝔖, _) = ⨅ i, .comap (ofFun (𝔗 i) ∘ (· ∘ φ i) ∘ toFun 𝔖) 𝒱(δ i, β, 𝔗 i, _) := by\n  set ψ : Π S : Set α, Π i : ι, (φ i) ⁻¹' S → S := fun S i ↦ S.restrictPreimage (φ i)\n  have : ∀ S ∈ 𝔖, 𝒰(S, β, _) = ⨅ i, .comap (· ∘ ψ S i) 𝒰(_, β, _) := fun S hS ↦ by\n    rcases h_cover S hS with ⟨I, I_finite, I_cover⟩\n    refine UniformFun.uniformSpace_eq_iInf_precomp_of_cover β _ ⟨I, I_finite, ?_⟩\n    simpa only [← univ_subset_iff, ψ, range_restrictPreimage, ← preimage_iUnion₂,\n      ← image_subset_iff, image_univ, Subtype.range_val] using I_cover\n  -- With a better theory of ideals we may be able to simplify the following by replacing `𝔗 i`\n  -- by `(φ i ⁻¹' ·) '' 𝔖`.\n  refine le_antisymm (le_iInf fun i ↦ ?_) (le_iInf₂ fun S hS ↦ ?_)\n  · rw [← uniformContinuous_iff]\n    exact UniformOnFun.precomp_uniformContinuous (h_image i)\n  · simp_rw [this S hS, UniformSpace.comap_iInf, ← UniformSpace.comap_comap]\n    exact iInf_mono fun i ↦ iInf₂_le_of_le _ (h_preimage i hS) le_rfl\n\n"}
{"name":"UniformFun.instCompleteSpace","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : UniformSpace β\ninst✝ : CompleteSpace β\n⊢ CompleteSpace (UniformFun α β)","decl":"instance {α β : Type*} [UniformSpace β] [CompleteSpace β] : CompleteSpace (α →ᵤ β) :=\n  (UniformOnFun.uniformEquivUniformFun β {univ} (mem_singleton _)).completeSpace_iff.1 inferInstance\n\n"}
{"name":"UniformContinuousOn.comp_tendstoUniformly","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Type u_4\ninst✝¹ : UniformSpace β\ninst✝ : UniformSpace γ\np : Filter ι\ns : Set β\nF : ι → α → β\nf : α → β\nhF : ∀ (i : ι) (x : α), Membership.mem s (F i x)\nhf : ∀ (x : α), Membership.mem s (f x)\ng : β → γ\nhg : UniformContinuousOn g s\nh : TendstoUniformly F f p\n⊢ TendstoUniformly (fun i x => g (F i x)) (fun x => g (f x)) p","decl":"/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem UniformContinuousOn.comp_tendstoUniformly (s : Set β) (F : ι → α → β) (f : α → β)\n    (hF : ∀ i x, F i x ∈ s) (hf : ∀ x, f x ∈ s)\n    {g : β → γ} (hg : UniformContinuousOn g s) (h : TendstoUniformly F f p) :\n    TendstoUniformly (fun i x => g (F i x)) (fun x => g (f x)) p := by\n  rw [uniformContinuousOn_iff_restrict] at hg\n  lift F to ι → α → s using hF with F' hF'\n  lift f to α → s using hf with f' hf'\n  rw [tendstoUniformly_iff_tendsto] at h\n  have : Tendsto (fun q : ι × α ↦ (f' q.2, (F' q.1 q.2))) (p ×ˢ ⊤) (𝓤 s) :=\n    h.of_tendsto_comp isUniformEmbedding_subtype_val.comap_uniformity.le\n  apply UniformContinuous.comp_tendstoUniformly hg ?_\n  rwa [← tendstoUniformly_iff_tendsto] at this\n\n"}
{"name":"UniformContinuousOn.comp_tendstoUniformly_eventually","module":"Mathlib.Topology.UniformSpace.UniformConvergenceTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Type u_4\ninst✝¹ : UniformSpace β\ninst✝ : UniformSpace γ\np : Filter ι\ns : Set β\nF : ι → α → β\nf : α → β\nhF : Filter.Eventually (fun i => ∀ (x : α), Membership.mem s (F i x)) p\nhf : ∀ (x : α), Membership.mem s (f x)\ng : β → γ\nhg : UniformContinuousOn g s\nh : TendstoUniformly F f p\n⊢ TendstoUniformly (fun i x => g (F i x)) (fun x => g (f x)) p","decl":"theorem UniformContinuousOn.comp_tendstoUniformly_eventually (s : Set β) (F : ι → α → β) (f : α → β)\n    (hF : ∀ᶠ i in p, ∀ x, F i x ∈ s) (hf : ∀ x, f x ∈ s)\n    {g : β → γ} (hg : UniformContinuousOn g s) (h : TendstoUniformly F f p) :\n    TendstoUniformly (fun i => fun x => g (F i x)) (fun x => g (f x)) p := by\n  classical\n  rw [eventually_iff_exists_mem] at hF\n  obtain ⟨s', hs', hs⟩ := hF\n  let F' : ι → α → β := fun (i : ι) x => if i ∈ s' then F i x else f x\n  have hF : F =ᶠ[p] F' :=  by\n    rw [eventuallyEq_iff_exists_mem]\n    refine ⟨s', hs', fun y hy => by aesop⟩\n  have h' : TendstoUniformly F' f p := by\n    rwa [tendstoUniformly_congr hF] at h\n  apply (tendstoUniformly_congr _).mpr\n    (UniformContinuousOn.comp_tendstoUniformly s F' f (by aesop) hf hg h')\n  rw [eventuallyEq_iff_exists_mem]\n  refine ⟨s', hs', fun i hi => by aesop⟩\n\n"}
