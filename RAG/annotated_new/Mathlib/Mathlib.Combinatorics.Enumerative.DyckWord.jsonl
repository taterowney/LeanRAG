{"name":"DyckStep.U.sizeOf_spec","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"⊢ Eq (SizeOf.sizeOf DyckStep.U) 1","decl":"/-- A `DyckStep` is either `U` or `D`, corresponding to `(` and `)` respectively. -/\ninductive DyckStep\n  | U : DyckStep\n  | D : DyckStep\n  deriving Inhabited, DecidableEq\n\n"}
{"name":"DyckStep.D.sizeOf_spec","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"⊢ Eq (SizeOf.sizeOf DyckStep.D) 1","decl":"/-- A `DyckStep` is either `U` or `D`, corresponding to `(` and `)` respectively. -/\ninductive DyckStep\n  | U : DyckStep\n  | D : DyckStep\n  deriving Inhabited, DecidableEq\n\n"}
{"name":"DyckStep.ofNat_toCtorIdx","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"x : DyckStep\n⊢ Eq (DyckStep.ofNat x.toCtorIdx) x","decl":"/-- A `DyckStep` is either `U` or `D`, corresponding to `(` and `)` respectively. -/\ninductive DyckStep\n  | U : DyckStep\n  | D : DyckStep\n  deriving Inhabited, DecidableEq\n\n"}
{"name":"DyckStep.dichotomy","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"s : DyckStep\n⊢ Or (Eq s DyckStep.U) (Eq s DyckStep.D)","decl":"/-- Named in analogy to `Bool.dichotomy`. -/\nlemma DyckStep.dichotomy (s : DyckStep) : s = U ∨ s = D := by cases s <;> tauto\n\n"}
{"name":"DyckWord.ext_iff","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"x y : DyckWord\n⊢ Iff (Eq x y) (Eq x.toList y.toList)","decl":"/-- A Dyck word is a list of `DyckStep`s with as many `U`s as `D`s and with every prefix having\nat least as many `U`s as `D`s. -/\n@[ext]\nstructure DyckWord where\n  /-- The underlying list -/\n  toList : List DyckStep\n  /-- There are as many `U`s as `D`s -/\n  count_U_eq_count_D : toList.count U = toList.count D\n  /-- Each prefix has as least as many `U`s as `D`s -/\n  count_D_le_count_U i : (toList.take i).count D ≤ (toList.take i).count U\n  deriving DecidableEq\n\n"}
{"name":"DyckWord.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"toList : List DyckStep\ncount_U_eq_count_D : Eq (List.count DyckStep.U toList) (List.count DyckStep.D toList)\ncount_D_le_count_U : ∀ (i : Nat), LE.le (List.count DyckStep.D (List.take i toList)) (List.count DyckStep.U (List.take i toList))\n⊢ Eq (SizeOf.sizeOf { toList := toList, count_U_eq_count_D := count_U_eq_count_D, count_D_le_count_U := count_D_le_count_U }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toList)) (SizeOf.sizeOf count_U_eq_count_D))","decl":"/-- A Dyck word is a list of `DyckStep`s with as many `U`s as `D`s and with every prefix having\nat least as many `U`s as `D`s. -/\n@[ext]\nstructure DyckWord where\n  /-- The underlying list -/\n  toList : List DyckStep\n  /-- There are as many `U`s as `D`s -/\n  count_U_eq_count_D : toList.count U = toList.count D\n  /-- Each prefix has as least as many `U`s as `D`s -/\n  count_D_le_count_U i : (toList.take i).count D ≤ (toList.take i).count U\n  deriving DecidableEq\n\n"}
{"name":"DyckWord.ext","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"x y : DyckWord\ntoList : Eq x.toList y.toList\n⊢ Eq x y","decl":"/-- A Dyck word is a list of `DyckStep`s with as many `U`s as `D`s and with every prefix having\nat least as many `U`s as `D`s. -/\n@[ext]\nstructure DyckWord where\n  /-- The underlying list -/\n  toList : List DyckStep\n  /-- There are as many `U`s as `D`s -/\n  count_U_eq_count_D : toList.count U = toList.count D\n  /-- Each prefix has as least as many `U`s as `D`s -/\n  count_D_le_count_U i : (toList.take i).count D ≤ (toList.take i).count U\n  deriving DecidableEq\n\n"}
{"name":"DyckWord.mk.inj","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"toList✝ : List DyckStep\ncount_U_eq_count_D✝ : Eq (List.count DyckStep.U toList✝) (List.count DyckStep.D toList✝)\ncount_D_le_count_U✝ : ∀ (i : Nat), LE.le (List.count DyckStep.D (List.take i toList✝)) (List.count DyckStep.U (List.take i toList✝))\ntoList : List DyckStep\ncount_U_eq_count_D : Eq (List.count DyckStep.U toList) (List.count DyckStep.D toList)\ncount_D_le_count_U : ∀ (i : Nat), LE.le (List.count DyckStep.D (List.take i toList)) (List.count DyckStep.U (List.take i toList))\nx✝ : Eq { toList := toList✝, count_U_eq_count_D := count_U_eq_count_D✝, count_D_le_count_U := count_D_le_count_U✝ } { toList := toList, count_U_eq_count_D := count_U_eq_count_D, count_D_le_count_U := count_D_le_count_U }\n⊢ Eq toList✝ toList","decl":"/-- A Dyck word is a list of `DyckStep`s with as many `U`s as `D`s and with every prefix having\nat least as many `U`s as `D`s. -/\n@[ext]\nstructure DyckWord where\n  /-- The underlying list -/\n  toList : List DyckStep\n  /-- There are as many `U`s as `D`s -/\n  count_U_eq_count_D : toList.count U = toList.count D\n  /-- Each prefix has as least as many `U`s as `D`s -/\n  count_D_le_count_U i : (toList.take i).count D ≤ (toList.take i).count U\n  deriving DecidableEq\n\n"}
{"name":"DyckWord.mk.injEq","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"toList✝ : List DyckStep\ncount_U_eq_count_D✝ : Eq (List.count DyckStep.U toList✝) (List.count DyckStep.D toList✝)\ncount_D_le_count_U✝ : ∀ (i : Nat), LE.le (List.count DyckStep.D (List.take i toList✝)) (List.count DyckStep.U (List.take i toList✝))\ntoList : List DyckStep\ncount_U_eq_count_D : Eq (List.count DyckStep.U toList) (List.count DyckStep.D toList)\ncount_D_le_count_U : ∀ (i : Nat), LE.le (List.count DyckStep.D (List.take i toList)) (List.count DyckStep.U (List.take i toList))\n⊢ Eq (Eq { toList := toList✝, count_U_eq_count_D := count_U_eq_count_D✝, count_D_le_count_U := count_D_le_count_U✝ } { toList := toList, count_U_eq_count_D := count_U_eq_count_D, count_D_le_count_U := count_D_le_count_U }) (Eq toList✝ toList)","decl":"/-- A Dyck word is a list of `DyckStep`s with as many `U`s as `D`s and with every prefix having\nat least as many `U`s as `D`s. -/\n@[ext]\nstructure DyckWord where\n  /-- The underlying list -/\n  toList : List DyckStep\n  /-- There are as many `U`s as `D`s -/\n  count_U_eq_count_D : toList.count U = toList.count D\n  /-- Each prefix has as least as many `U`s as `D`s -/\n  count_D_le_count_U i : (toList.take i).count D ≤ (toList.take i).count U\n  deriving DecidableEq\n\n"}
{"name":"DyckWord.count_U_eq_count_D","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"self : DyckWord\n⊢ Eq (List.count DyckStep.U self.toList) (List.count DyckStep.D self.toList)","decl":"/-- A Dyck word is a list of `DyckStep`s with as many `U`s as `D`s and with every prefix having\nat least as many `U`s as `D`s. -/\n@[ext]\nstructure DyckWord where\n  /-- The underlying list -/\n  toList : List DyckStep\n  /-- There are as many `U`s as `D`s -/\n  count_U_eq_count_D : toList.count U = toList.count D\n  /-- Each prefix has as least as many `U`s as `D`s -/\n  count_D_le_count_U i : (toList.take i).count D ≤ (toList.take i).count U\n  deriving DecidableEq\n\n"}
{"name":"DyckWord.count_D_le_count_U","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"self : DyckWord\ni : Nat\n⊢ LE.le (List.count DyckStep.D (List.take i self.toList)) (List.count DyckStep.U (List.take i self.toList))","decl":"/-- A Dyck word is a list of `DyckStep`s with as many `U`s as `D`s and with every prefix having\nat least as many `U`s as `D`s. -/\n@[ext]\nstructure DyckWord where\n  /-- The underlying list -/\n  toList : List DyckStep\n  /-- There are as many `U`s as `D`s -/\n  count_U_eq_count_D : toList.count U = toList.count D\n  /-- Each prefix has as least as many `U`s as `D`s -/\n  count_D_le_count_U i : (toList.take i).count D ≤ (toList.take i).count U\n  deriving DecidableEq\n\n"}
{"name":"DyckWord.toList_eq_nil","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Iff (Eq (↑p) List.nil) (Eq p 0)","decl":"lemma toList_eq_nil : p.toList = [] ↔ p = 0 := by rw [DyckWord.ext_iff]; rfl\n"}
{"name":"DyckWord.toList_ne_nil","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Iff (Ne (↑p) List.nil) (Ne p 0)","decl":"lemma toList_ne_nil : p.toList ≠ [] ↔ p ≠ 0 := toList_eq_nil.ne\n\n"}
{"name":"DyckWord.head_eq_U","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne (↑p) List.nil\n⊢ Eq ((↑p).head h) DyckStep.U","decl":"/-- The first element of a nonempty Dyck word is `U`. -/\nlemma head_eq_U (p : DyckWord) (h) : p.toList.head h = U := by\n  rcases p with - | s; · tauto\n  rw [head_cons]\n  by_contra f\n  rename_i _ nonneg\n  simpa [s.dichotomy.resolve_left f] using nonneg 1\n\n"}
{"name":"DyckWord.getLast_eq_D","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne (↑p) List.nil\n⊢ Eq ((↑p).getLast h) DyckStep.D","decl":"/-- The last element of a nonempty Dyck word is `D`. -/\nlemma getLast_eq_D (p : DyckWord) (h) : p.toList.getLast h = D := by\n  by_contra f; have s := p.count_U_eq_count_D\n  rw [← dropLast_append_getLast h, (dichotomy _).resolve_right f] at s\n  simp_rw [dropLast_eq_take, count_append, count_singleton', ite_true, reduceCtorEq, ite_false] at s\n  have := p.count_D_le_count_U (p.toList.length - 1); omega\n\n"}
{"name":"DyckWord.cons_tail_dropLast_concat","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne p 0\n⊢ Eq (HAppend.hAppend (List.cons DyckStep.U (↑p).dropLast.tail) (List.cons DyckStep.D List.nil)) ↑p","decl":"include h in\nlemma cons_tail_dropLast_concat : U :: p.toList.dropLast.tail ++ [D] = p := by\n  have h' := toList_ne_nil.mpr h\n  have : p.toList.dropLast.take 1 = [p.toList.head h'] := by\n    rcases p with - | ⟨s, ⟨- | ⟨t, r⟩⟩⟩\n    · tauto\n    · rename_i bal _\n      cases s <;> simp at bal\n    · tauto\n  nth_rw 2 [← p.toList.dropLast_append_getLast h', ← p.toList.dropLast.take_append_drop 1]\n  rw [getLast_eq_D, drop_one, this, head_eq_U]\n  rfl\n\n"}
{"name":"DyckWord.nest_ne_zero","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Ne p.nest 0","decl":"@[simp] lemma nest_ne_zero : p.nest ≠ 0 := by simp [← toList_ne_nil, nest]\n\n"}
{"name":"DyckWord.IsNested.nest","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ p.nest.IsNested","decl":"protected lemma IsNested.nest : p.nest.IsNested := ⟨nest_ne_zero, fun i lb ub ↦ by\n  simp_rw [nest, length_append, length_singleton] at ub ⊢\n  rw [take_append_of_le_length (by rw [singleton_append, length_cons]; omega),\n    take_append_eq_append_take, take_of_length_le (by rw [length_singleton]; omega),\n    length_singleton, singleton_append, count_cons_of_ne (by simp), count_cons_self,\n    Nat.lt_add_one_iff]\n  exact p.count_D_le_count_U _⟩\n\n"}
{"name":"DyckWord.nest_denest","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nhn : p.IsNested\n⊢ Eq (p.denest hn).nest p","decl":"variable (p) in\nlemma nest_denest (hn) : (p.denest hn).nest = p := by\n  simpa [DyckWord.ext_iff] using p.cons_tail_dropLast_concat hn.1\n\n"}
{"name":"DyckWord.denest_nest","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Eq (p.nest.denest ⋯) p","decl":"variable (p) in\nlemma denest_nest : p.nest.denest .nest = p := by\n  simp_rw [nest, denest, DyckWord.ext_iff, dropLast_concat]; rfl\n\n"}
{"name":"DyckWord.semilength_zero","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"⊢ Eq (DyckWord.semilength 0) 0","decl":"@[simp] lemma semilength_zero : semilength 0 = 0 := rfl\n"}
{"name":"DyckWord.semilength_add","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p q : DyckWord\n⊢ Eq (HAdd.hAdd p q).semilength (HAdd.hAdd p.semilength q.semilength)","decl":"@[simp] lemma semilength_add : (p + q).semilength = p.semilength + q.semilength := count_append ..\n"}
{"name":"DyckWord.semilength_nest","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Eq p.nest.semilength (HAdd.hAdd p.semilength 1)","decl":"@[simp] lemma semilength_nest : p.nest.semilength = p.semilength + 1 := by simp [semilength, nest]\n\n"}
{"name":"DyckWord.semilength_eq_count_D","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Eq p.semilength (List.count DyckStep.D ↑p)","decl":"lemma semilength_eq_count_D : p.semilength = p.toList.count D := by\n  rw [← count_U_eq_count_D]; rfl\n\n"}
{"name":"DyckWord.two_mul_semilength_eq_length","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Eq (HMul.hMul 2 p.semilength) (↑p).length","decl":"@[simp]\nlemma two_mul_semilength_eq_length : 2 * p.semilength = p.toList.length := by\n  nth_rw 1 [two_mul, semilength, p.count_U_eq_count_D, semilength]\n  convert (p.toList.length_eq_countP_add_countP (· == D)).symm\n  rw [count]; congr!; rename_i s; cases s <;> tauto\n\n"}
{"name":"DyckWord.firstReturn_zero","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"⊢ Eq (DyckWord.firstReturn 0) 0","decl":"@[simp] lemma firstReturn_zero : firstReturn 0 = 0 := rfl\n\n"}
{"name":"DyckWord.firstReturn_pos","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne p 0\n⊢ LT.lt 0 p.firstReturn","decl":"include h in\nlemma firstReturn_pos : 0 < p.firstReturn := by\n  by_contra! f\n  rw [Nat.le_zero, firstReturn, findIdx_eq] at f\n  #adaptation_note\n  /--\n  If we don't swap, then the second goal is dropped after completing the first goal.\n  What's going on?\n  -/\n  swap\n  · rw [length_range, length_pos]\n    exact toList_ne_nil.mpr h\n  · rw [getElem_range] at f\n    simp at f\n    rw [← p.cons_tail_dropLast_concat h] at f\n    simp at f\n\n"}
{"name":"DyckWord.firstReturn_lt_length","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne p 0\n⊢ LT.lt p.firstReturn (↑p).length","decl":"include h in\nlemma firstReturn_lt_length : p.firstReturn < p.toList.length := by\n  have lp := length_pos_of_ne_nil (toList_ne_nil.mpr h)\n  rw [← length_range p.toList.length]\n  apply findIdx_lt_length_of_exists\n  simp only [mem_range, decide_eq_true_eq]\n  use p.toList.length - 1\n  exact ⟨by omega, by rw [Nat.sub_add_cancel lp, take_of_length_le (le_refl _),\n    p.count_U_eq_count_D]⟩\n\n"}
{"name":"DyckWord.count_take_firstReturn_add_one","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne p 0\n⊢ Eq (List.count DyckStep.U (List.take (HAdd.hAdd p.firstReturn 1) ↑p)) (List.count DyckStep.D (List.take (HAdd.hAdd p.firstReturn 1) ↑p))","decl":"include h in\nlemma count_take_firstReturn_add_one :\n    (p.toList.take (p.firstReturn + 1)).count U = (p.toList.take (p.firstReturn + 1)).count D := by\n  have := findIdx_getElem (w := (length_range p.toList.length).symm ▸ firstReturn_lt_length h)\n  simpa using this\n\n"}
{"name":"DyckWord.count_D_lt_count_U_of_lt_firstReturn","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\ni : Nat\nhi : LT.lt i p.firstReturn\n⊢ LT.lt (List.count DyckStep.D (List.take (HAdd.hAdd i 1) ↑p)) (List.count DyckStep.U (List.take (HAdd.hAdd i 1) ↑p))","decl":"lemma count_D_lt_count_U_of_lt_firstReturn {i : ℕ} (hi : i < p.firstReturn) :\n    (p.toList.take (i + 1)).count D < (p.toList.take (i + 1)).count U := by\n  have ne := not_of_lt_findIdx hi\n  rw [decide_eq_false_iff_not, ← ne_eq, getElem_range] at ne\n  exact lt_of_le_of_ne (p.count_D_le_count_U (i + 1)) ne.symm\n\n"}
{"name":"DyckWord.firstReturn_add","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p q : DyckWord\n⊢ Eq (HAdd.hAdd p q).firstReturn (ite (Eq p 0) q.firstReturn p.firstReturn)","decl":"@[simp]\nlemma firstReturn_add : (p + q).firstReturn = if p = 0 then q.firstReturn else p.firstReturn := by\n  split_ifs with h; · simp [h]\n  have u : (p + q).toList = p.toList ++ q.toList := rfl\n  rw [firstReturn, findIdx_eq]\n  · simp_rw [u, decide_eq_true_eq, getElem_range]\n    have v := firstReturn_lt_length h\n    constructor\n    · rw [take_append_eq_append_take, show p.firstReturn + 1 - p.toList.length = 0 by omega,\n        take_zero, append_nil, count_take_firstReturn_add_one h]\n    · intro j hj\n      rw [take_append_eq_append_take, show j + 1 - p.toList.length = 0 by omega,\n        take_zero, append_nil]\n      simpa using (count_D_lt_count_U_of_lt_firstReturn hj).ne'\n  · rw [length_range, u, length_append]\n    exact Nat.lt_add_right _ (firstReturn_lt_length h)\n\n"}
{"name":"DyckWord.firstReturn_nest","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Eq p.nest.firstReturn (HAdd.hAdd (↑p).length 1)","decl":"@[simp]\nlemma firstReturn_nest : p.nest.firstReturn = p.toList.length + 1 := by\n  have u : p.nest.toList = U :: p.toList ++ [D] := rfl\n  rw [firstReturn, findIdx_eq]\n  · simp_rw [u, decide_eq_true_eq, getElem_range]\n    constructor\n    · rw [take_of_length_le (by simp), ← u, p.nest.count_U_eq_count_D]\n    · intro j hj\n      simp_rw [cons_append, take_succ_cons, count_cons, beq_self_eq_true, ite_true,\n        beq_iff_eq, reduceCtorEq, ite_false, take_append_eq_append_take,\n        show j - p.toList.length = 0 by omega, take_zero, append_nil]\n      have := p.count_D_le_count_U j\n      simp only [add_zero, decide_eq_false_iff_not, ne_eq]\n      omega\n  · simp_rw [length_range, u, length_append, length_cons]\n    exact Nat.lt_add_one _\n\n"}
{"name":"DyckWord.insidePart_zero","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"⊢ Eq (DyckWord.insidePart 0) 0","decl":"@[simp] lemma insidePart_zero : insidePart 0 = 0 := by simp [insidePart]\n"}
{"name":"DyckWord.outsidePart_zero","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"⊢ Eq (DyckWord.outsidePart 0) 0","decl":"@[simp] lemma outsidePart_zero : outsidePart 0 = 0 := by simp [outsidePart]\n\n"}
{"name":"DyckWord.insidePart_add","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p q : DyckWord\nh : Ne p 0\n⊢ Eq (HAdd.hAdd p q).insidePart p.insidePart","decl":"include h in\n@[simp]\nlemma insidePart_add : (p + q).insidePart = p.insidePart := by\n  simp_rw [insidePart, firstReturn_add, add_eq_zero', h, false_and, dite_false, ite_false,\n    DyckWord.ext_iff, take]\n  congr 3\n  exact take_append_of_le_length (firstReturn_lt_length h)\n\n"}
{"name":"DyckWord.outsidePart_add","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p q : DyckWord\nh : Ne p 0\n⊢ Eq (HAdd.hAdd p q).outsidePart (HAdd.hAdd p.outsidePart q)","decl":"include h in\n@[simp]\nlemma outsidePart_add : (p + q).outsidePart = p.outsidePart + q := by\n  simp_rw [outsidePart, firstReturn_add, add_eq_zero', h, false_and, dite_false, ite_false,\n    DyckWord.ext_iff, drop]\n  exact drop_append_of_le_length (firstReturn_lt_length h)\n\n"}
{"name":"DyckWord.insidePart_nest","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Eq p.nest.insidePart p","decl":"@[simp]\nlemma insidePart_nest : p.nest.insidePart = p := by\n  simp_rw [insidePart, nest_ne_zero, dite_false, firstReturn_nest]\n  convert p.denest_nest; rw [DyckWord.ext_iff]; apply take_of_length_le\n  simp_rw [nest, length_append, length_singleton]; omega\n\n"}
{"name":"DyckWord.outsidePart_nest","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Eq p.nest.outsidePart 0","decl":"@[simp]\nlemma outsidePart_nest : p.nest.outsidePart = 0 := by\n  simp_rw [outsidePart, nest_ne_zero, dite_false, firstReturn_nest]\n  rw [DyckWord.ext_iff]; apply drop_of_length_le\n  simp_rw [nest, length_append, length_singleton]; omega\n\n"}
{"name":"DyckWord.nest_insidePart_add_outsidePart","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne p 0\n⊢ Eq (HAdd.hAdd p.insidePart.nest p.outsidePart) p","decl":"include h in\n@[simp]\ntheorem nest_insidePart_add_outsidePart : p.insidePart.nest + p.outsidePart = p := by\n  simp_rw [insidePart, outsidePart, h, dite_false, nest_denest, DyckWord.ext_iff]\n  apply take_append_drop\n\n"}
{"name":"DyckWord.semilength_insidePart_add_semilength_outsidePart_add_one","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne p 0\n⊢ Eq (HAdd.hAdd (HAdd.hAdd p.insidePart.semilength p.outsidePart.semilength) 1) p.semilength","decl":"include h in\nlemma semilength_insidePart_add_semilength_outsidePart_add_one :\n    p.insidePart.semilength + p.outsidePart.semilength + 1 = p.semilength := by\n  rw [← congrArg semilength (nest_insidePart_add_outsidePart h), semilength_add, semilength_nest,\n    add_right_comm]\n\n"}
{"name":"DyckWord.semilength_insidePart_lt","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne p 0\n⊢ LT.lt p.insidePart.semilength p.semilength","decl":"include h in\ntheorem semilength_insidePart_lt : p.insidePart.semilength < p.semilength := by\n  have := semilength_insidePart_add_semilength_outsidePart_add_one h\n  omega\n\n"}
{"name":"DyckWord.semilength_outsidePart_lt","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\nh : Ne p 0\n⊢ LT.lt p.outsidePart.semilength p.semilength","decl":"include h in\ntheorem semilength_outsidePart_lt : p.outsidePart.semilength < p.semilength := by\n  have := semilength_insidePart_add_semilength_outsidePart_add_one h\n  omega\n\n"}
{"name":"DyckWord.le_add_self","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p q : DyckWord\n⊢ LE.le q (HAdd.hAdd p q)","decl":"lemma le_add_self (p q : DyckWord) : q ≤ p + q := by\n  by_cases h : p = 0\n  · simp [h]\n  · have := semilength_outsidePart_lt h\n    exact (le_add_self p.outsidePart q).trans\n      (Relation.ReflTransGen.single (Or.inr (outsidePart_add h).symm))\ntermination_by p.semilength\n\n"}
{"name":"DyckWord.zero_le","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ LE.le 0 p","decl":"variable (p) in protected lemma zero_le : 0 ≤ p := add_zero p ▸ le_add_self p 0\n\n"}
{"name":"DyckWord.infix_of_le","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p q : DyckWord\nh : LE.le p q\n⊢ (↑p).IsInfix ↑q","decl":"lemma infix_of_le (h : p ≤ q) : p.toList <:+: q.toList := by\n  induction h with\n  | refl => exact infix_refl _\n  | tail _pm mq ih =>\n    rename_i m r\n    rcases eq_or_ne r 0 with rfl | hr\n    · rw [insidePart_zero, outsidePart_zero, or_self] at mq\n      rwa [mq] at ih\n    · have : [U] ++ r.insidePart ++ [D] ++ r.outsidePart = r :=\n        DyckWord.ext_iff.mp (nest_insidePart_add_outsidePart hr)\n      rcases mq with hm | hm\n      · have : r.insidePart <:+: r.toList := by\n          use [U], [D] ++ r.outsidePart; rwa [← append_assoc]\n        exact ih.trans (hm ▸ this)\n      · have : r.outsidePart <:+: r.toList := by\n          use [U] ++ r.insidePart ++ [D], []; rwa [append_nil]\n        exact ih.trans (hm ▸ this)\n\n"}
{"name":"DyckWord.le_of_suffix","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p q : DyckWord\nh : (↑p).IsSuffix ↑q\n⊢ LE.le p q","decl":"lemma le_of_suffix (h : p.toList <:+ q.toList) : p ≤ q := by\n  obtain ⟨r', h⟩ := h\n  have hc : (q.toList.take (q.toList.length - p.toList.length)).count U =\n      (q.toList.take (q.toList.length - p.toList.length)).count D := by\n    have hq := q.count_U_eq_count_D\n    rw [← h] at hq ⊢\n    rw [count_append, count_append, p.count_U_eq_count_D, Nat.add_right_cancel_iff] at hq\n    simp [hq]\n  let r : DyckWord := q.take _ hc\n  have e : r' = r := by\n    simp_rw [r, take, ← h, length_append, add_tsub_cancel_right, take_left']\n  rw [e] at h; replace h : r + p = q := DyckWord.ext h; rw [← h]; exact le_add_self ..\n\n"}
{"name":"DyckWord.pos_iff_ne_zero","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Iff (LT.lt 0 p) (Ne p 0)","decl":"protected lemma pos_iff_ne_zero : 0 < p ↔ p ≠ 0 := by\n  rw [ne_comm, iff_comm, ne_iff_lt_iff_le]\n  exact DyckWord.zero_le p\n\n"}
{"name":"DyckWord.monotone_semilength","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"⊢ Monotone DyckWord.semilength","decl":"lemma monotone_semilength : Monotone semilength := fun p q pq ↦ by\n  induction pq with\n  | refl => rfl\n  | tail _ mq ih =>\n    rename_i m r _\n    rcases eq_or_ne r 0 with rfl | hr\n    · rw [insidePart_zero, outsidePart_zero, or_self] at mq\n      rwa [mq] at ih\n    · rcases mq with hm | hm\n      · exact ih.trans (hm ▸ semilength_insidePart_lt hr).le\n      · exact ih.trans (hm ▸ semilength_outsidePart_lt hr).le\n\n"}
{"name":"DyckWord.strictMono_semilength","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"⊢ StrictMono DyckWord.semilength","decl":"lemma strictMono_semilength : StrictMono semilength := fun p q pq ↦ by\n  obtain ⟨plq, pnq⟩ := lt_iff_le_and_ne.mp pq\n  apply lt_of_le_of_ne (monotone_semilength plq)\n  contrapose! pnq\n  replace pnq := congr(2 * $(pnq))\n  simp_rw [two_mul_semilength_eq_length] at pnq\n  exact DyckWord.ext ((infix_of_le plq).eq_of_length pnq)\n\n"}
{"name":"DyckWord.semilength_eq_numNodes_equivTree","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"p : DyckWord\n⊢ Eq p.semilength (DyckWord.equivTree p).numNodes","decl":"@[nolint unusedHavesSuffices]\nlemma semilength_eq_numNodes_equivTree (p) : p.semilength = (equivTree p).numNodes := by\n  by_cases h : p = 0\n  · simp [h, equivTree, equivTreeToFun]\n  · rw [equivTree, Equiv.coe_fn_mk, equivTreeToFun]\n    simp_rw [h, dite_false, numNodes]\n    have := semilength_insidePart_lt h\n    have := semilength_outsidePart_lt h\n    rw [← semilength_insidePart_add_semilength_outsidePart_add_one h,\n      semilength_eq_numNodes_equivTree p.insidePart,\n      semilength_eq_numNodes_equivTree p.outsidePart]; rfl\ntermination_by p.semilength\n\n"}
{"name":"DyckWord.card_dyckWord_semilength_eq_catalan","module":"Mathlib.Combinatorics.Enumerative.DyckWord","initialProofState":"n : Nat\n⊢ Eq (Fintype.card (Subtype fun p => Eq p.semilength n)) (catalan n)","decl":"/-- There are `catalan n` Dyck words of semilength `n` (or length `2 * n`). -/\ntheorem card_dyckWord_semilength_eq_catalan (n : ℕ) :\n    Fintype.card { p : DyckWord // p.semilength = n } = catalan n := by\n  rw [← Fintype.ofEquiv_card (equivTreesOfNumNodesEq n), ← treesOfNumNodesEq_card_eq_catalan]\n  convert Fintype.card_coe _\n\n"}
