{"name":"CategoryTheory.Abelian.PreservesImage.iso_hom_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesImage.iso F f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.image.ι (F.map f)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.image.ι f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesImage.iso_hom_ι :\n    (PreservesImage.iso F f).hom ≫ Abelian.image.ι (F.map f) = F.map (Abelian.image.ι f) := by\n  simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesImage.iso_hom_ι","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesImage.iso F f).hom (CategoryTheory.Abelian.image.ι (F.map f))) (F.map (CategoryTheory.Abelian.image.ι f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesImage.iso_hom_ι :\n    (PreservesImage.iso F f).hom ≫ Abelian.image.ι (F.map f) = F.map (Abelian.image.ι f) := by\n  simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesImage.factorThruImage_iso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (CategoryTheory.Abelian.image (F.map f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.factorThruImage f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesImage.iso F f).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.factorThruImage (F.map f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesImage.factorThruImage_iso_hom :\n    F.map (Abelian.factorThruImage f) ≫ (PreservesImage.iso F f).hom =\n      Abelian.factorThruImage (F.map f) := by\n  ext; simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesImage.factorThruImage_iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.factorThruImage f)) (CategoryTheory.Abelian.PreservesImage.iso F f).hom) (CategoryTheory.Abelian.factorThruImage (F.map f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesImage.factorThruImage_iso_hom :\n    F.map (Abelian.factorThruImage f) ≫ (PreservesImage.iso F f).hom =\n      Abelian.factorThruImage (F.map f) := by\n  ext; simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesImage.iso_inv_ι","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesImage.iso F f).inv (F.map (CategoryTheory.Abelian.image.ι f))) (CategoryTheory.Abelian.image.ι (F.map f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesImage.iso_inv_ι :\n    (PreservesImage.iso F f).inv ≫ F.map (Abelian.image.ι f) = Abelian.image.ι (F.map f) := by\n  simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesImage.iso_inv_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesImage.iso F f).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.image.ι f)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.image.ι (F.map f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesImage.iso_inv_ι :\n    (PreservesImage.iso F f).inv ≫ F.map (Abelian.image.ι f) = Abelian.image.ι (F.map f) := by\n  simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesImage.factorThruImage_iso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Abelian.image f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.factorThruImage (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesImage.iso F f).inv h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.factorThruImage f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesImage.factorThruImage_iso_inv :\n    Abelian.factorThruImage (F.map f) ≫ (PreservesImage.iso F f).inv =\n      F.map (Abelian.factorThruImage f) := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesImage.factorThruImage_iso_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.factorThruImage (F.map f)) (CategoryTheory.Abelian.PreservesImage.iso F f).inv) (F.map (CategoryTheory.Abelian.factorThruImage f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesImage.factorThruImage_iso_inv :\n    Abelian.factorThruImage (F.map f) ≫ (PreservesImage.iso F f).inv =\n      F.map (Abelian.factorThruImage f) := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimage.iso_hom_π","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.coimage.π f)) (CategoryTheory.Abelian.PreservesCoimage.iso F f).hom) (CategoryTheory.Abelian.coimage.π (F.map f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCoimage.iso_hom_π :\n    F.map (Abelian.coimage.π f) ≫ (PreservesCoimage.iso F f).hom = Abelian.coimage.π (F.map f) := by\n  simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimage.iso_hom_π_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (CategoryTheory.Abelian.coimage (F.map f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.coimage.π f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesCoimage.iso F f).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimage.π (F.map f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCoimage.iso_hom_π :\n    F.map (Abelian.coimage.π f) ≫ (PreservesCoimage.iso F f).hom = Abelian.coimage.π (F.map f) := by\n  simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimage.factorThruCoimage_iso_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesCoimage.iso F f).inv (F.map (CategoryTheory.Abelian.factorThruCoimage f))) (CategoryTheory.Abelian.factorThruCoimage (F.map f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCoimage.factorThruCoimage_iso_inv :\n    (PreservesCoimage.iso F f).inv ≫ F.map (Abelian.factorThruCoimage f)  =\n      Abelian.factorThruCoimage (F.map f) := by\n  ext; simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimage.factorThruCoimage_iso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesCoimage.iso F f).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.factorThruCoimage f)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.factorThruCoimage (F.map f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCoimage.factorThruCoimage_iso_inv :\n    (PreservesCoimage.iso F f).inv ≫ F.map (Abelian.factorThruCoimage f)  =\n      Abelian.factorThruCoimage (F.map f) := by\n  ext; simp [iso]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimage.factorThruCoimage_iso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesCoimage.iso F f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.factorThruCoimage (F.map f)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.factorThruCoimage f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCoimage.factorThruCoimage_iso_hom :\n    (PreservesCoimage.iso F f).hom ≫ Abelian.factorThruCoimage (F.map f) =\n      F.map (Abelian.factorThruCoimage f) := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimage.factorThruCoimage_iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesCoimage.iso F f).hom (CategoryTheory.Abelian.factorThruCoimage (F.map f))) (F.map (CategoryTheory.Abelian.factorThruCoimage f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCoimage.factorThruCoimage_iso_hom :\n    (PreservesCoimage.iso F f).hom ≫ Abelian.factorThruCoimage (F.map f) =\n      F.map (Abelian.factorThruCoimage f) := by\n  simp [← Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimage.iso_inv_π","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimage.π (F.map f)) (CategoryTheory.Abelian.PreservesCoimage.iso F f).inv) (F.map (CategoryTheory.Abelian.coimage.π f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCoimage.iso_inv_π :\n    Abelian.coimage.π (F.map f) ≫ (PreservesCoimage.iso F f).inv = F.map (Abelian.coimage.π f) := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimage.iso_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Abelian.coimage f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimage.π (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesCoimage.iso F f).inv h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.coimage.π f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCoimage.iso_inv_π :\n    Abelian.coimage.π (F.map f) ≫ (PreservesCoimage.iso F f).inv = F.map (Abelian.coimage.π f) := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimage.hom_coimageImageComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.PreservesCoimage.iso F f).hom (CategoryTheory.Abelian.coimageImageComparison (F.map f))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Abelian.coimageImageComparison f)) (CategoryTheory.Abelian.PreservesImage.iso F f).hom)","decl":"theorem PreservesCoimage.hom_coimageImageComparison :\n    (PreservesCoimage.iso F f).hom ≫ coimageImageComparison (F.map f) =\n      F.map (coimageImageComparison f) ≫ (PreservesImage.iso F f).hom := by\n  simp [← Functor.map_comp, ← Iso.eq_inv_comp, ← cancel_epi (Abelian.coimage.π (F.map f)),\n    ← cancel_mono (Abelian.image.ι (F.map f))]\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimageImageComparison.iso_inv_left","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.PreservesCoimageImageComparison.iso F f).inv.left (CategoryTheory.Abelian.PreservesCoimage.iso F f).inv","decl":"/-- If a functor preserves kernels and cokernels, it perserves coimage-image comparisons. -/\n@[simps!]\ndef PreservesCoimageImageComparison.iso :\n    Arrow.mk (F.map (coimageImageComparison f)) ≅ Arrow.mk (coimageImageComparison (F.map f)) :=\n  Arrow.isoMk' _ _ (PreservesCoimage.iso F f) (PreservesImage.iso F f)\n    (PreservesCoimage.hom_coimageImageComparison F f)\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimageImageComparison.iso_hom_right","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.PreservesCoimageImageComparison.iso F f).hom.right (CategoryTheory.Abelian.PreservesImage.iso F f).hom","decl":"/-- If a functor preserves kernels and cokernels, it perserves coimage-image comparisons. -/\n@[simps!]\ndef PreservesCoimageImageComparison.iso :\n    Arrow.mk (F.map (coimageImageComparison f)) ≅ Arrow.mk (coimageImageComparison (F.map f)) :=\n  Arrow.isoMk' _ _ (PreservesCoimage.iso F f) (PreservesImage.iso F f)\n    (PreservesCoimage.hom_coimageImageComparison F f)\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimageImageComparison.iso_inv_right","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.PreservesCoimageImageComparison.iso F f).inv.right (CategoryTheory.Abelian.PreservesImage.iso F f).inv","decl":"/-- If a functor preserves kernels and cokernels, it perserves coimage-image comparisons. -/\n@[simps!]\ndef PreservesCoimageImageComparison.iso :\n    Arrow.mk (F.map (coimageImageComparison f)) ≅ Arrow.mk (coimageImageComparison (F.map f)) :=\n  Arrow.isoMk' _ _ (PreservesCoimage.iso F f) (PreservesImage.iso F f)\n    (PreservesCoimage.hom_coimageImageComparison F f)\n\n"}
{"name":"CategoryTheory.Abelian.PreservesCoimageImageComparison.iso_hom_left","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.AbelianImages","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasKernels C\ninst✝⁷ : CategoryTheory.Limits.HasCokernels C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝⁴ : CategoryTheory.Limits.HasKernels D\ninst✝³ : CategoryTheory.Limits.HasCokernels D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.PreservesCoimageImageComparison.iso F f).hom.left (CategoryTheory.Abelian.PreservesCoimage.iso F f).hom","decl":"/-- If a functor preserves kernels and cokernels, it perserves coimage-image comparisons. -/\n@[simps!]\ndef PreservesCoimageImageComparison.iso :\n    Arrow.mk (F.map (coimageImageComparison f)) ≅ Arrow.mk (coimageImageComparison (F.map f)) :=\n  Arrow.isoMk' _ _ (PreservesCoimage.iso F f) (PreservesImage.iso F f)\n    (PreservesCoimage.hom_coimageImageComparison F f)\n\n"}
