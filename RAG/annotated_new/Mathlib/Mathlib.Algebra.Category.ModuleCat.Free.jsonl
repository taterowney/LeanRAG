{"name":"ModuleCat.disjoint_span_sum","module":"Mathlib.Algebra.Category.ModuleCat.Free","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS : S.Exact\nv : ι → ↑S.X₁\nu : Sum ι ι' → ↑S.X₂\nhw : LinearIndependent R (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom S.g)) (Function.comp u Sum.inr))\nhuv : Eq (Function.comp u Sum.inl) (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom S.f)) v)\n⊢ Disjoint (Submodule.span R (Set.range (Function.comp u Sum.inl))) (Submodule.span R (Set.range (Function.comp u Sum.inr)))","decl":"theorem disjoint_span_sum : Disjoint (span R (range (u ∘ Sum.inl)))\n    (span R (range (u ∘ Sum.inr))) := by\n  rw [huv, disjoint_comm]\n  refine Disjoint.mono_right (span_mono (range_comp_subset_range _ _)) ?_\n  rw [← LinearMap.range_coe, span_eq (LinearMap.range S.f.hom), hS.moduleCat_range_eq_ker]\n  exact range_ker_disjoint hw\n\n"}
{"name":"ModuleCat.linearIndependent_leftExact","module":"Mathlib.Algebra.Category.ModuleCat.Free","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS : S.Exact\nv : ι → ↑S.X₁\nhv : LinearIndependent R v\nu : Sum ι ι' → ↑S.X₂\nhw : LinearIndependent R (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom S.g)) (Function.comp u Sum.inr))\nhm : CategoryTheory.Mono S.f\nhuv : Eq (Function.comp u Sum.inl) (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom S.f)) v)\n⊢ LinearIndependent R u","decl":"include hv hm in\n\n/-- In the commutative diagram\n```\n             f     g\n    0 --→ X₁ --→ X₂ --→ X₃\n          ↑      ↑      ↑\n         v|     u|     w|\n          ι  → ι ⊕ ι' ← ι'\n```\nwhere the top row is an exact sequence of modules and the maps on the bottom are `Sum.inl` and\n`Sum.inr`. If `u` is injective and `v` and `w` are linearly independent, then `u` is linearly\nindependent. -/\ntheorem linearIndependent_leftExact : LinearIndependent R u := by\n  rw [linearIndependent_sum]\n  refine ⟨?_, LinearIndependent.of_comp S.g.hom hw, disjoint_span_sum hS hw huv⟩\n  rw [huv, LinearMap.linearIndependent_iff S.f.hom]; swap\n  · rw [LinearMap.ker_eq_bot, ← mono_iff_injective]\n    infer_instance\n  exact hv\n\n"}
{"name":"ModuleCat.linearIndependent_shortExact","module":"Mathlib.Algebra.Category.ModuleCat.Free","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS' : S.ShortExact\nv : ι → ↑S.X₁\nhv : LinearIndependent R v\nw : ι' → ↑S.X₃\nhw : LinearIndependent R w\n⊢ LinearIndependent R (Sum.elim (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom S.f)) v) (Function.comp (Function.invFun (ModuleCat.Hom.hom S.g).toFun) w))","decl":"include hS' hv in\n/-- Given a short exact sequence `0 ⟶ X₁ ⟶ X₂ ⟶ X₃ ⟶ 0` of `R`-modules and linearly independent\n    families `v : ι → N` and `w : ι' → P`, we get a linearly independent family `ι ⊕ ι' → M` -/\ntheorem linearIndependent_shortExact {w : ι' → S.X₃} (hw : LinearIndependent R w) :\n    LinearIndependent R (Sum.elim (S.f ∘ v) (S.g.hom.toFun.invFun ∘ w)) := by\n  apply linearIndependent_leftExact hS'.exact hv _ hS'.mono_f rfl\n  dsimp\n  convert hw\n  ext\n  apply Function.rightInverse_invFun ((epi_iff_surjective _).mp hS'.epi_g)\n\n"}
{"name":"ModuleCat.span_exact","module":"Mathlib.Algebra.Category.ModuleCat.Free","initialProofState":"ι : Type u_1\nR : Type u_3\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS : S.Exact\nv : ι → ↑S.X₁\nβ : Type u_4\nu : Sum ι β → ↑S.X₂\nhuv : Eq (Function.comp u Sum.inl) (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom S.f)) v)\nhv : LE.le Top.top (Submodule.span R (Set.range v))\nhw : LE.le Top.top (Submodule.span R (Set.range (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom S.g)) (Function.comp u Sum.inr))))\n⊢ LE.le Top.top (Submodule.span R (Set.range u))","decl":"include hS in\n/-- In the commutative diagram\n```\n    f     g\n X₁ --→ X₂ --→ X₃\n ↑      ↑      ↑\nv|     u|     w|\n ι  → ι ⊕ ι' ← ι'\n```\nwhere the top row is an exact sequence of modules and the maps on the bottom are `Sum.inl` and\n`Sum.inr`. If `v` spans `X₁` and `w` spans `X₃`, then `u` spans `X₂`. -/\ntheorem span_exact {β : Type*} {u : ι ⊕ β → S.X₂} (huv : u ∘ Sum.inl = S.f ∘ v)\n    (hv : ⊤ ≤ span R (range v))\n    (hw : ⊤ ≤ span R (range (S.g ∘ u ∘ Sum.inr))) :\n    ⊤ ≤ span R (range u) := by\n  intro m _\n  have hgm : S.g m ∈ span R (range (S.g ∘ u ∘ Sum.inr)) := hw mem_top\n  rw [Finsupp.mem_span_range_iff_exists_finsupp] at hgm\n  obtain ⟨cm, hm⟩ := hgm\n  let m' : S.X₂ := Finsupp.sum cm fun j a ↦ a • (u (Sum.inr j))\n  have hsub : m - m' ∈ LinearMap.range S.f.hom := by\n    rw [hS.moduleCat_range_eq_ker]\n    simp only [LinearMap.mem_ker, map_sub, sub_eq_zero]\n    rw [← hm, map_finsupp_sum]\n    simp only [Function.comp_apply, map_smul]\n  obtain ⟨n, hnm⟩ := hsub\n  have hn : n ∈ span R (range v) := hv mem_top\n  rw [Finsupp.mem_span_range_iff_exists_finsupp] at hn\n  obtain ⟨cn, hn⟩ := hn\n  rw [← hn, map_finsupp_sum] at hnm\n  rw [← sub_add_cancel m m', ← hnm,]\n  simp only [map_smul]\n  have hn' : (Finsupp.sum cn fun a b ↦ b • S.f (v a)) =\n      (Finsupp.sum cn fun a b ↦ b • u (Sum.inl a)) := by\n    congr; ext a b; rw [← Function.comp_apply (f := S.f), ← huv, Function.comp_apply]\n  rw [hn']\n  apply add_mem\n  · rw [Finsupp.mem_span_range_iff_exists_finsupp]\n    use cn.mapDomain (Sum.inl)\n    rw [Finsupp.sum_mapDomain_index_inj Sum.inl_injective]\n  · rw [Finsupp.mem_span_range_iff_exists_finsupp]\n    use cm.mapDomain (Sum.inr)\n    rw [Finsupp.sum_mapDomain_index_inj Sum.inr_injective]\n\n"}
{"name":"ModuleCat.span_rightExact","module":"Mathlib.Algebra.Category.ModuleCat.Free","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS : S.Exact\nv : ι → ↑S.X₁\nw : ι' → ↑S.X₃\nhv : LE.le Top.top (Submodule.span R (Set.range v))\nhw : LE.le Top.top (Submodule.span R (Set.range w))\nhE : CategoryTheory.Epi S.g\n⊢ LE.le Top.top (Submodule.span R (Set.range (Sum.elim (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom S.f)) v) (Function.comp (Function.invFun (ModuleCat.Hom.hom S.g).toFun) w))))","decl":"include hS in\n/-- Given an exact sequence `X₁ ⟶ X₂ ⟶ X₃ ⟶ 0` of `R`-modules and spanning\n    families `v : ι → X₁` and `w : ι' → X₃`, we get a spanning family `ι ⊕ ι' → X₂` -/\ntheorem span_rightExact {w : ι' → S.X₃} (hv : ⊤ ≤ span R (range v))\n    (hw : ⊤ ≤ span R (range w)) (hE : Epi S.g) :\n    ⊤ ≤ span R (range (Sum.elim (S.f ∘ v) (S.g.hom.toFun.invFun ∘ w))) := by\n  refine span_exact hS ?_ hv ?_\n  · simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, Sum.elim_comp_inl]\n  · convert hw\n    simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, Sum.elim_comp_inr]\n    rw [ModuleCat.epi_iff_surjective] at hE\n    rw [← Function.comp_assoc, Function.RightInverse.comp_eq_id (Function.rightInverse_invFun hE),\n      Function.id_comp]\n\n"}
{"name":"ModuleCat.free_shortExact","module":"Mathlib.Algebra.Category.ModuleCat.Free","initialProofState":"R : Type u_3\ninst✝² : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS' : S.ShortExact\ninst✝¹ : Module.Free R ↑S.X₁\ninst✝ : Module.Free R ↑S.X₃\n⊢ Module.Free R ↑S.X₂","decl":"/-- In a short exact sequence `0 ⟶ X₁ ⟶ X₂ ⟶ X₃ ⟶ 0`, if `X₁` and `X₃` are free,\nthen `X₂` is free. -/\ntheorem free_shortExact [Module.Free R S.X₁] [Module.Free R S.X₃] :\n    Module.Free R S.X₂ :=\n  Module.Free.of_basis (Basis.ofShortExact hS' (Module.Free.chooseBasis R S.X₁)\n    (Module.Free.chooseBasis R S.X₃))\n\n"}
{"name":"ModuleCat.free_shortExact_rank_add","module":"Mathlib.Algebra.Category.ModuleCat.Free","initialProofState":"R : Type u_3\ninst✝³ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS' : S.ShortExact\ninst✝² : Module.Free R ↑S.X₁\ninst✝¹ : Module.Free R ↑S.X₃\ninst✝ : StrongRankCondition R\n⊢ Eq (Module.rank R ↑S.X₂) (HAdd.hAdd (Module.rank R ↑S.X₁) (Module.rank R ↑S.X₃))","decl":"theorem free_shortExact_rank_add [Module.Free R S.X₁] [Module.Free R S.X₃]\n    [StrongRankCondition R] :\n    Module.rank R S.X₂ = Module.rank R S.X₁ + Module.rank R S.X₃ := by\n  haveI := free_shortExact hS'\n  rw [Module.Free.rank_eq_card_chooseBasisIndex, Module.Free.rank_eq_card_chooseBasisIndex R S.X₁,\n    Module.Free.rank_eq_card_chooseBasisIndex R S.X₃, Cardinal.add_def, Cardinal.eq]\n  exact ⟨Basis.indexEquiv (Module.Free.chooseBasis R S.X₂) (Basis.ofShortExact hS'\n    (Module.Free.chooseBasis R S.X₁) (Module.Free.chooseBasis R S.X₃))⟩\n\n"}
{"name":"ModuleCat.free_shortExact_finrank_add","module":"Mathlib.Algebra.Category.ModuleCat.Free","initialProofState":"R : Type u_3\ninst✝⁵ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS' : S.ShortExact\nn p : Nat\ninst✝⁴ : Module.Free R ↑S.X₁\ninst✝³ : Module.Free R ↑S.X₃\ninst✝² : Module.Finite R ↑S.X₁\ninst✝¹ : Module.Finite R ↑S.X₃\nhN : Eq (Module.finrank R ↑S.X₁) n\nhP : Eq (Module.finrank R ↑S.X₃) p\ninst✝ : StrongRankCondition R\n⊢ Eq (Module.finrank R ↑S.X₂) (HAdd.hAdd n p)","decl":"theorem free_shortExact_finrank_add {n p : ℕ} [Module.Free R S.X₁] [Module.Free R S.X₃]\n    [Module.Finite R S.X₁] [Module.Finite R S.X₃]\n    (hN : Module.finrank R S.X₁ = n)\n    (hP : Module.finrank R S.X₃ = p)\n    [StrongRankCondition R] :\n    finrank R S.X₂ = n + p := by\n  apply finrank_eq_of_rank_eq\n  rw [free_shortExact_rank_add hS', ← hN, ← hP]\n  simp only [Nat.cast_add, finrank_eq_rank]\n\n"}
