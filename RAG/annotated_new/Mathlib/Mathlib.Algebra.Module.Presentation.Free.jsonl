{"name":"Module.Relations.solutionFinsupp_var","module":"Mathlib.Algebra.Module.Presentation.Free","initialProofState":"A : Type u\ninst✝ : Ring A\nrelations : Module.Relations A\ng : relations.G\n⊢ Eq (relations.solutionFinsupp.var g) (Finsupp.single g 1)","decl":"/-- If `relations : Relations A` involved no relation, then it has an obvious\nsolution in the module `relations.G →₀ A`. -/\n@[simps]\nnoncomputable def solutionFinsupp : relations.Solution (relations.G →₀ A) where\n  var g := Finsupp.single g 1\n  linearCombination_var_relation r := by exfalso; exact IsEmpty.false r\n\n"}
{"name":"Module.Relations.solutionFinsupp_isPresentation","module":"Mathlib.Algebra.Module.Presentation.Free","initialProofState":"A : Type u\ninst✝¹ : Ring A\nrelations : Module.Relations A\ninst✝ : IsEmpty relations.R\n⊢ relations.solutionFinsupp.IsPresentation","decl":"lemma solutionFinsupp_isPresentation :\n    relations.solutionFinsupp.IsPresentation :=\n  (solutionFinsupp.isPresentationCore relations).isPresentation\n\n"}
{"name":"Module.Relations.Solution.IsPresentation.free","module":"Mathlib.Algebra.Module.Presentation.Free","initialProofState":"A : Type u\ninst✝³ : Ring A\nrelations : Module.Relations A\nM : Type v\ninst✝² : AddCommGroup M\ninst✝¹ : Module A M\ninst✝ : IsEmpty relations.R\nsolution : relations.Solution M\nh : solution.IsPresentation\n⊢ Module.Free A M","decl":"lemma Solution.IsPresentation.free {solution : relations.Solution M}\n    (h : solution.IsPresentation) :\n    Module.Free A M :=\n  Free.of_equiv ((solutionFinsupp_isPresentation relations).uniq h)\n\n"}
{"name":"Module.presentationFinsupp_var","module":"Mathlib.Algebra.Module.Presentation.Free","initialProofState":"A : Type u\ninst✝ : Ring A\nG : Type w₀\ng : { G := G, R := PEmpty.{w₁ + 1}, relation := fun r => PEmpty.casesOn (fun x => Finsupp G A) r }.G\n⊢ Eq ((Module.presentationFinsupp A G).var g) (Finsupp.single g 1)","decl":"/-- The presentation of the `A`-module `G →₀ A` with generators indexed by `G`,\nand no relation. (Note that there is an auxiliary universe parameter `w₁` for the\nempty type `R`.) -/\n@[simps! G R var]\nnoncomputable def presentationFinsupp (G : Type w₀) :\n    Presentation.{w₀, w₁} A (G →₀ A) where\n  G := G\n  R := PEmpty.{w₁ + 1}\n  relation := by rintro ⟨⟩\n  toSolution := Relations.solutionFinsupp _\n  toIsPresentation := Relations.solutionFinsupp_isPresentation _\n\n"}
{"name":"Module.presentationFinsupp_G","module":"Mathlib.Algebra.Module.Presentation.Free","initialProofState":"A : Type u\ninst✝ : Ring A\nG : Type w₀\n⊢ Eq (Module.presentationFinsupp A G).G G","decl":"/-- The presentation of the `A`-module `G →₀ A` with generators indexed by `G`,\nand no relation. (Note that there is an auxiliary universe parameter `w₁` for the\nempty type `R`.) -/\n@[simps! G R var]\nnoncomputable def presentationFinsupp (G : Type w₀) :\n    Presentation.{w₀, w₁} A (G →₀ A) where\n  G := G\n  R := PEmpty.{w₁ + 1}\n  relation := by rintro ⟨⟩\n  toSolution := Relations.solutionFinsupp _\n  toIsPresentation := Relations.solutionFinsupp_isPresentation _\n\n"}
{"name":"Module.presentationFinsupp_R","module":"Mathlib.Algebra.Module.Presentation.Free","initialProofState":"A : Type u\ninst✝ : Ring A\nG : Type w₀\n⊢ Eq (Module.presentationFinsupp A G).R PEmpty.{w₁ + 1}","decl":"/-- The presentation of the `A`-module `G →₀ A` with generators indexed by `G`,\nand no relation. (Note that there is an auxiliary universe parameter `w₁` for the\nempty type `R`.) -/\n@[simps! G R var]\nnoncomputable def presentationFinsupp (G : Type w₀) :\n    Presentation.{w₀, w₁} A (G →₀ A) where\n  G := G\n  R := PEmpty.{w₁ + 1}\n  relation := by rintro ⟨⟩\n  toSolution := Relations.solutionFinsupp _\n  toIsPresentation := Relations.solutionFinsupp_isPresentation _\n\n"}
{"name":"Module.free_iff_exists_presentation","module":"Mathlib.Algebra.Module.Presentation.Free","initialProofState":"A : Type u\ninst✝² : Ring A\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module A M\n⊢ Iff (Module.Free A M) (Exists fun p => IsEmpty p.R)","decl":"lemma free_iff_exists_presentation :\n    Free A M ↔ ∃ (p : Presentation.{v, w₁} A M), IsEmpty p.R := by\n  constructor\n  · rw [free_def.{_, _, v}]\n    rintro ⟨G, ⟨⟨e⟩⟩⟩\n    exact ⟨(presentationFinsupp A G).ofLinearEquiv e.symm,\n      by dsimp; infer_instance⟩\n  · rintro ⟨p, h⟩\n    exact p.toIsPresentation.free\n\n"}
