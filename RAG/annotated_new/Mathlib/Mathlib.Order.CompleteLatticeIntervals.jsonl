{"name":"subset_sSup_def","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ns : Set α\ninst✝² : Preorder α\ninst✝¹ : SupSet α\ninst✝ : Inhabited ↑s\n⊢ Eq SupSet.sSup fun t => dite (And t.Nonempty (And (BddAbove t) (Membership.mem s (SupSet.sSup (Set.image Subtype.val t))))) (fun ht => ⟨SupSet.sSup (Set.image Subtype.val t), ⋯⟩) fun ht => Inhabited.default","decl":"open Classical in\n@[simp]\ntheorem subset_sSup_def [Inhabited s] :\n    @sSup s _ = fun t =>\n      if ht : t.Nonempty ∧ BddAbove t ∧ sSup ((↑) '' t : Set α) ∈ s\n      then ⟨sSup ((↑) '' t : Set α), ht.2.2⟩\n      else default :=\n  rfl\n\n"}
{"name":"subset_sSup_of_within","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ns : Set α\ninst✝² : Preorder α\ninst✝¹ : SupSet α\ninst✝ : Inhabited ↑s\nt : Set ↑s\nh' : t.Nonempty\nh'' : BddAbove t\nh : Membership.mem s (SupSet.sSup (Set.image Subtype.val t))\n⊢ Eq (SupSet.sSup (Set.image Subtype.val t)) ↑(SupSet.sSup t)","decl":"theorem subset_sSup_of_within [Inhabited s] {t : Set s}\n    (h' : t.Nonempty) (h'' : BddAbove t) (h : sSup ((↑) '' t : Set α) ∈ s) :\n    sSup ((↑) '' t : Set α) = (@sSup s _ t : α) := by simp [dif_pos, h, h', h'']\n\n"}
{"name":"subset_sSup_emptyset","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ns : Set α\ninst✝² : Preorder α\ninst✝¹ : SupSet α\ninst✝ : Inhabited ↑s\n⊢ Eq (SupSet.sSup EmptyCollection.emptyCollection) Inhabited.default","decl":"theorem subset_sSup_emptyset [Inhabited s] :\n    sSup (∅ : Set s) = default := by\n  simp [sSup]\n\n"}
{"name":"subset_sSup_of_not_bddAbove","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ns : Set α\ninst✝² : Preorder α\ninst✝¹ : SupSet α\ninst✝ : Inhabited ↑s\nt : Set ↑s\nht : Not (BddAbove t)\n⊢ Eq (SupSet.sSup t) Inhabited.default","decl":"theorem subset_sSup_of_not_bddAbove [Inhabited s] {t : Set s} (ht : ¬BddAbove t) :\n    sSup t = default := by\n  simp [sSup, ht]\n\n"}
{"name":"subset_sInf_def","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ns : Set α\ninst✝² : Preorder α\ninst✝¹ : InfSet α\ninst✝ : Inhabited ↑s\n⊢ Eq InfSet.sInf fun t => dite (And t.Nonempty (And (BddBelow t) (Membership.mem s (InfSet.sInf (Set.image Subtype.val t))))) (fun ht => ⟨InfSet.sInf (Set.image Subtype.val t), ⋯⟩) fun ht => Inhabited.default","decl":"open Classical in\n@[simp]\ntheorem subset_sInf_def [Inhabited s] :\n    @sInf s _ = fun t =>\n      if ht : t.Nonempty ∧ BddBelow t ∧ sInf ((↑) '' t : Set α) ∈ s\n      then ⟨sInf ((↑) '' t : Set α), ht.2.2⟩ else\n      default :=\n  rfl\n\n"}
{"name":"subset_sInf_of_within","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ns : Set α\ninst✝² : Preorder α\ninst✝¹ : InfSet α\ninst✝ : Inhabited ↑s\nt : Set ↑s\nh' : t.Nonempty\nh'' : BddBelow t\nh : Membership.mem s (InfSet.sInf (Set.image Subtype.val t))\n⊢ Eq (InfSet.sInf (Set.image Subtype.val t)) ↑(InfSet.sInf t)","decl":"theorem subset_sInf_of_within [Inhabited s] {t : Set s}\n    (h' : t.Nonempty) (h'' : BddBelow t) (h : sInf ((↑) '' t : Set α) ∈ s) :\n    sInf ((↑) '' t : Set α) = (@sInf s _ t : α) := by simp [dif_pos, h, h', h'']\n\n"}
{"name":"subset_sInf_emptyset","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ns : Set α\ninst✝² : Preorder α\ninst✝¹ : InfSet α\ninst✝ : Inhabited ↑s\n⊢ Eq (InfSet.sInf EmptyCollection.emptyCollection) Inhabited.default","decl":"theorem subset_sInf_emptyset [Inhabited s] :\n    sInf (∅ : Set s) = default := by\n  simp [sInf]\n\n"}
{"name":"subset_sInf_of_not_bddBelow","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ns : Set α\ninst✝² : Preorder α\ninst✝¹ : InfSet α\ninst✝ : Inhabited ↑s\nt : Set ↑s\nht : Not (BddBelow t)\n⊢ Eq (InfSet.sInf t) Inhabited.default","decl":"theorem subset_sInf_of_not_bddBelow [Inhabited s] {t : Set s} (ht : ¬BddBelow t) :\n    sInf t = default := by\n  simp [sInf, ht]\n\n"}
{"name":"sSup_within_of_ordConnected","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nhs : s.OrdConnected\nt : Set ↑s\nht : t.Nonempty\nh_bdd : BddAbove t\n⊢ Membership.mem s (SupSet.sSup (Set.image Subtype.val t))","decl":"/-- The `sSup` function on a nonempty `OrdConnected` set `s` in a conditionally complete linear\norder takes values within `s`, for all nonempty bounded-above subsets of `s`. -/\ntheorem sSup_within_of_ordConnected {s : Set α} [hs : OrdConnected s] ⦃t : Set s⦄ (ht : t.Nonempty)\n    (h_bdd : BddAbove t) : sSup ((↑) '' t : Set α) ∈ s := by\n  obtain ⟨c, hct⟩ : ∃ c, c ∈ t := ht\n  obtain ⟨B, hB⟩ : ∃ B, B ∈ upperBounds t := h_bdd\n  refine hs.out c.2 B.2 ⟨?_, ?_⟩\n  · exact (Subtype.mono_coe s).le_csSup_image hct ⟨B, hB⟩\n  · exact (Subtype.mono_coe s).csSup_image_le ⟨c, hct⟩ hB\n\n"}
{"name":"sInf_within_of_ordConnected","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder α\ns : Set α\nhs : s.OrdConnected\nt : Set ↑s\nht : t.Nonempty\nh_bdd : BddBelow t\n⊢ Membership.mem s (InfSet.sInf (Set.image Subtype.val t))","decl":"/-- The `sInf` function on a nonempty `OrdConnected` set `s` in a conditionally complete linear\norder takes values within `s`, for all nonempty bounded-below subsets of `s`. -/\ntheorem sInf_within_of_ordConnected {s : Set α} [hs : OrdConnected s] ⦃t : Set s⦄ (ht : t.Nonempty)\n    (h_bdd : BddBelow t) : sInf ((↑) '' t : Set α) ∈ s := by\n  obtain ⟨c, hct⟩ : ∃ c, c ∈ t := ht\n  obtain ⟨B, hB⟩ : ∃ B, B ∈ lowerBounds t := h_bdd\n  refine hs.out B.2 c.2 ⟨?_, ?_⟩\n  · exact (Subtype.mono_coe s).le_csInf_image ⟨c, hct⟩ hB\n  · exact (Subtype.mono_coe s).csInf_image_le hct ⟨B, hB⟩\n\n"}
{"name":"Set.Icc.coe_sSup","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLattice α\na b : α\nh : LE.le a b\nS : Set ↑(Set.Icc a b)\nhS : S.Nonempty\n⊢ letFun ⋯ fun this => Eq (↑(SupSet.sSup S)) (SupSet.sSup (Set.image Subtype.val S))","decl":"lemma Set.Icc.coe_sSup [ConditionallyCompleteLattice α] {a b : α} (h : a ≤ b)\n    {S : Set (Set.Icc a b)} (hS : S.Nonempty) : have : Fact (a ≤ b) := ⟨h⟩\n    ↑(sSup S) = sSup ((↑) '' S : Set α) :=\n  congrArg Subtype.val (dif_neg hS.ne_empty)\n\n"}
{"name":"Set.Icc.coe_sInf","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ninst✝ : ConditionallyCompleteLattice α\na b : α\nh : LE.le a b\nS : Set ↑(Set.Icc a b)\nhS : S.Nonempty\n⊢ letFun ⋯ fun this => Eq (↑(InfSet.sInf S)) (InfSet.sInf (Set.image Subtype.val S))","decl":"lemma Set.Icc.coe_sInf [ConditionallyCompleteLattice α] {a b : α} (h : a ≤ b)\n    {S : Set (Set.Icc a b)} (hS : S.Nonempty) : have : Fact (a ≤ b) := ⟨h⟩\n    ↑(sInf S) = sInf ((↑) '' S : Set α) :=\n  congrArg Subtype.val (dif_neg hS.ne_empty)\n\n"}
{"name":"Set.Icc.coe_iSup","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\na b : α\nh : LE.le a b\ninst✝ : Nonempty ι\nS : ι → ↑(Set.Icc a b)\n⊢ letFun ⋯ fun this => Eq (↑(iSup S)) (iSup fun i => ↑(S i))","decl":"lemma Set.Icc.coe_iSup [ConditionallyCompleteLattice α] {a b : α} (h : a ≤ b)\n    [Nonempty ι] {S : ι → Set.Icc a b} : have : Fact (a ≤ b) := ⟨h⟩\n    ↑(iSup S) = (⨆ i, S i : α) :=\n  (Set.Icc.coe_sSup h (range_nonempty S)).trans (congrArg sSup (range_comp Subtype.val S).symm)\n\n"}
{"name":"Set.Icc.coe_iInf","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\na b : α\nh : LE.le a b\ninst✝ : Nonempty ι\nS : ι → ↑(Set.Icc a b)\n⊢ letFun ⋯ fun this => Eq (↑(iInf S)) (iInf fun i => ↑(S i))","decl":"lemma Set.Icc.coe_iInf [ConditionallyCompleteLattice α] {a b : α} (h : a ≤ b)\n    [Nonempty ι] {S : ι → Set.Icc a b} : have : Fact (a ≤ b) := ⟨h⟩\n    ↑(iInf S) = (⨅ i, S i : α) :=\n  (Set.Icc.coe_sInf h (range_nonempty S)).trans (congrArg sInf (range_comp Subtype.val S).symm)\n\n"}
{"name":"Set.Iic.coe_sSup","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\na : α\nS : Set ↑(Set.Iic a)\n⊢ Eq (↑(SupSet.sSup S)) (SupSet.sSup (Set.image Subtype.val S))","decl":"@[simp] theorem coe_sSup : (↑(sSup S) : α) = sSup ((↑) '' S) := rfl\n\n"}
{"name":"Set.Iic.coe_iSup","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : CompleteLattice α\na : α\nf : ι → ↑(Set.Iic a)\n⊢ Eq (↑(iSup fun i => f i)) (iSup fun i => ↑(f i))","decl":"@[simp] theorem coe_iSup : (↑(⨆ i, f i) : α) = ⨆ i, (f i : α) := by\n  rw [iSup, coe_sSup]; congr; ext; simp\n\n"}
{"name":"Set.Iic.coe_biSup","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : CompleteLattice α\na : α\nf : ι → ↑(Set.Iic a)\np : ι → Prop\n⊢ Eq (↑(iSup fun i => iSup fun x => f i)) (iSup fun i => iSup fun x => ↑(f i))","decl":"theorem coe_biSup : (↑(⨆ i, ⨆ (_ : p i), f i) : α) = ⨆ i, ⨆ (_ : p i), (f i : α) := by simp\n\n"}
{"name":"Set.Iic.coe_sInf","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\na : α\nS : Set ↑(Set.Iic a)\n⊢ Eq (↑(InfSet.sInf S)) (Min.min a (InfSet.sInf (Set.image Subtype.val S)))","decl":"@[simp] theorem coe_sInf : (↑(sInf S) : α) = a ⊓ sInf ((↑) '' S) := rfl\n\n"}
{"name":"Set.Iic.coe_iInf","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : CompleteLattice α\na : α\nf : ι → ↑(Set.Iic a)\n⊢ Eq (↑(iInf fun i => f i)) (Min.min a (iInf fun i => ↑(f i)))","decl":"@[simp] theorem coe_iInf : (↑(⨅ i, f i) : α) = a ⊓ ⨅ i, (f i : α) := by\n  rw [iInf, coe_sInf]; congr; ext; simp\n\n"}
{"name":"Set.Iic.coe_biInf","module":"Mathlib.Order.CompleteLatticeIntervals","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : CompleteLattice α\na : α\nf : ι → ↑(Set.Iic a)\np : ι → Prop\n⊢ Eq (↑(iInf fun i => iInf fun x => f i)) (Min.min a (iInf fun i => iInf fun x => ↑(f i)))","decl":"theorem coe_biInf : (↑(⨅ i, ⨅ (_ : p i), f i) : α) = a ⊓ ⨅ i, ⨅ (_ : p i), (f i : α) := by\n  cases isEmpty_or_nonempty ι\n  · simp\n  · simp_rw [coe_iInf, ← inf_iInf, ← inf_assoc, inf_idem]\n\n\n"}
