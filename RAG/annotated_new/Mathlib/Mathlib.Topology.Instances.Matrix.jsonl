{"name":"instT2SpaceMatrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"m : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝¹ : TopologicalSpace R\ninst✝ : T2Space R\n⊢ T2Space (Matrix m n R)","decl":"instance [TopologicalSpace R] [T2Space R] : T2Space (Matrix m n R) :=\n  Pi.t2Space\n\n"}
{"name":"instContinuousConstSMulMatrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"α : Type u_2\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝² : TopologicalSpace R\ninst✝¹ : SMul α R\ninst✝ : ContinuousConstSMul α R\n⊢ ContinuousConstSMul α (Matrix m n R)","decl":"instance [SMul α R] [ContinuousConstSMul α R] : ContinuousConstSMul α (Matrix m n R) :=\n  inferInstanceAs (ContinuousConstSMul α (m → n → R))\n\n"}
{"name":"instContinuousSMulMatrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"α : Type u_2\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace α\ninst✝¹ : SMul α R\ninst✝ : ContinuousSMul α R\n⊢ ContinuousSMul α (Matrix m n R)","decl":"instance [TopologicalSpace α] [SMul α R] [ContinuousSMul α R] : ContinuousSMul α (Matrix m n R) :=\n  inferInstanceAs (ContinuousSMul α (m → n → R))\n\n"}
{"name":"instContinuousAddMatrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"m : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝² : TopologicalSpace R\ninst✝¹ : Add R\ninst✝ : ContinuousAdd R\n⊢ ContinuousAdd (Matrix m n R)","decl":"instance [Add R] [ContinuousAdd R] : ContinuousAdd (Matrix m n R) :=\n  Pi.continuousAdd\n\n"}
{"name":"instContinuousNegMatrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"m : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝² : TopologicalSpace R\ninst✝¹ : Neg R\ninst✝ : ContinuousNeg R\n⊢ ContinuousNeg (Matrix m n R)","decl":"instance [Neg R] [ContinuousNeg R] : ContinuousNeg (Matrix m n R) :=\n  Pi.continuousNeg\n\n"}
{"name":"instTopologicalAddGroupMatrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"m : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝² : TopologicalSpace R\ninst✝¹ : AddGroup R\ninst✝ : TopologicalAddGroup R\n⊢ TopologicalAddGroup (Matrix m n R)","decl":"instance [AddGroup R] [TopologicalAddGroup R] : TopologicalAddGroup (Matrix m n R) :=\n  Pi.topologicalAddGroup\n\n"}
{"name":"continuous_matrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"α : Type u_2\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSpace α\nf : α → Matrix m n R\nh : ∀ (i : m) (j : n), Continuous fun a => f a i j\n⊢ Continuous f","decl":"/-- To show a function into matrices is continuous it suffices to show the coefficients of the\nresulting matrix are continuous -/\n@[continuity]\ntheorem continuous_matrix [TopologicalSpace α] {f : α → Matrix m n R}\n    (h : ∀ i j, Continuous fun a => f a i j) : Continuous f :=\n  continuous_pi fun _ => continuous_pi fun _ => h _ _\n\n"}
{"name":"Continuous.matrix_elem","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nA : X → Matrix m n R\nhA : Continuous A\ni : m\nj : n\n⊢ Continuous fun x => A x i j","decl":"theorem Continuous.matrix_elem {A : X → Matrix m n R} (hA : Continuous A) (i : m) (j : n) :\n    Continuous fun x => A x i j :=\n  (continuous_apply_apply i j).comp hA\n\n"}
{"name":"Continuous.matrix_map","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nS : Type u_7\nR : Type u_8\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalSpace S\nA : X → Matrix m n S\nf : S → R\nhA : Continuous A\nhf : Continuous f\n⊢ Continuous fun x => (A x).map f","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_map [TopologicalSpace S] {A : X → Matrix m n S} {f : S → R}\n    (hA : Continuous A) (hf : Continuous f) : Continuous fun x => (A x).map f :=\n  continuous_matrix fun _ _ => hf.comp <| hA.matrix_elem _ _\n\n"}
{"name":"Continuous.matrix_transpose","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nA : X → Matrix m n R\nhA : Continuous A\n⊢ Continuous fun x => (A x).transpose","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_transpose {A : X → Matrix m n R} (hA : Continuous A) :\n    Continuous fun x => (A x)ᵀ :=\n  continuous_matrix fun i j => hA.matrix_elem j i\n\n"}
{"name":"Continuous.matrix_conjTranspose","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace R\ninst✝¹ : Star R\ninst✝ : ContinuousStar R\nA : X → Matrix m n R\nhA : Continuous A\n⊢ Continuous fun x => (A x).conjTranspose","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_conjTranspose [Star R] [ContinuousStar R] {A : X → Matrix m n R}\n    (hA : Continuous A) : Continuous fun x => (A x)ᴴ :=\n  hA.matrix_transpose.matrix_map continuous_star\n\n"}
{"name":"instContinuousStarMatrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"m : Type u_4\nR : Type u_8\ninst✝² : TopologicalSpace R\ninst✝¹ : Star R\ninst✝ : ContinuousStar R\n⊢ ContinuousStar (Matrix m m R)","decl":"instance [Star R] [ContinuousStar R] : ContinuousStar (Matrix m m R) :=\n  ⟨continuous_id.matrix_conjTranspose⟩\n\n"}
{"name":"Continuous.matrix_col","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nι : Type u_11\nA : X → n → R\nhA : Continuous A\n⊢ Continuous fun x => Matrix.col ι (A x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_col {ι : Type*} {A : X → n → R} (hA : Continuous A) :\n    Continuous fun x => col ι (A x) :=\n  continuous_matrix fun i _ => (continuous_apply i).comp hA\n\n"}
{"name":"Continuous.matrix_row","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nι : Type u_11\nA : X → n → R\nhA : Continuous A\n⊢ Continuous fun x => Matrix.row ι (A x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_row {ι : Type*} {A : X → n → R} (hA : Continuous A) :\n    Continuous fun x => row ι (A x) :=\n  continuous_matrix fun _ _ => (continuous_apply _).comp hA\n\n"}
{"name":"Continuous.matrix_diagonal","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace R\ninst✝¹ : Zero R\ninst✝ : DecidableEq n\nA : X → n → R\nhA : Continuous A\n⊢ Continuous fun x => Matrix.diagonal (A x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_diagonal [Zero R] [DecidableEq n] {A : X → n → R} (hA : Continuous A) :\n    Continuous fun x => diagonal (A x) :=\n  continuous_matrix fun i _ => ((continuous_apply i).comp hA).if_const _ continuous_zero\n\n"}
{"name":"Continuous.matrix_dotProduct","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : Fintype n\ninst✝³ : Mul R\ninst✝² : AddCommMonoid R\ninst✝¹ : ContinuousAdd R\ninst✝ : ContinuousMul R\nA B : X → n → R\nhA : Continuous A\nhB : Continuous B\n⊢ Continuous fun x => dotProduct (A x) (B x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_dotProduct [Fintype n] [Mul R] [AddCommMonoid R] [ContinuousAdd R]\n    [ContinuousMul R] {A : X → n → R} {B : X → n → R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => dotProduct (A x) (B x) :=\n  continuous_finset_sum _ fun i _ =>\n    ((continuous_apply i).comp hA).mul ((continuous_apply i).comp hB)\n\n"}
{"name":"Continuous.matrix_mul","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : Fintype n\ninst✝³ : Mul R\ninst✝² : AddCommMonoid R\ninst✝¹ : ContinuousAdd R\ninst✝ : ContinuousMul R\nA : X → Matrix m n R\nB : X → Matrix n p R\nhA : Continuous A\nhB : Continuous B\n⊢ Continuous fun x => HMul.hMul (A x) (B x)","decl":"/-- For square matrices the usual `continuous_mul` can be used. -/\n@[continuity, fun_prop]\ntheorem Continuous.matrix_mul [Fintype n] [Mul R] [AddCommMonoid R] [ContinuousAdd R]\n    [ContinuousMul R] {A : X → Matrix m n R} {B : X → Matrix n p R} (hA : Continuous A)\n    (hB : Continuous B) : Continuous fun x => A x * B x :=\n  continuous_matrix fun _ _ =>\n    continuous_finset_sum _ fun _ _ => (hA.matrix_elem _ _).mul (hB.matrix_elem _ _)\n\n"}
{"name":"instContinuousMulMatrixOfContinuousAdd","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"n : Type u_5\nR : Type u_8\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : Fintype n\ninst✝³ : Mul R\ninst✝² : AddCommMonoid R\ninst✝¹ : ContinuousAdd R\ninst✝ : ContinuousMul R\n⊢ ContinuousMul (Matrix n n R)","decl":"instance [Fintype n] [Mul R] [AddCommMonoid R] [ContinuousAdd R] [ContinuousMul R] :\n    ContinuousMul (Matrix n n R) :=\n  ⟨continuous_fst.matrix_mul continuous_snd⟩\n\n"}
{"name":"instTopologicalSemiringMatrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"n : Type u_5\nR : Type u_8\ninst✝³ : TopologicalSpace R\ninst✝² : Fintype n\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : TopologicalSemiring R\n⊢ TopologicalSemiring (Matrix n n R)","decl":"instance [Fintype n] [NonUnitalNonAssocSemiring R] [TopologicalSemiring R] :\n    TopologicalSemiring (Matrix n n R) where\n\n"}
{"name":"Matrix.topologicalRing","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"n : Type u_5\nR : Type u_8\ninst✝³ : TopologicalSpace R\ninst✝² : Fintype n\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : TopologicalRing R\n⊢ TopologicalRing (Matrix n n R)","decl":"instance Matrix.topologicalRing [Fintype n] [NonUnitalNonAssocRing R] [TopologicalRing R] :\n    TopologicalRing (Matrix n n R) where\n\n"}
{"name":"Continuous.matrix_vecMulVec","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace R\ninst✝¹ : Mul R\ninst✝ : ContinuousMul R\nA : X → m → R\nB : X → n → R\nhA : Continuous A\nhB : Continuous B\n⊢ Continuous fun x => Matrix.vecMulVec (A x) (B x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_vecMulVec [Mul R] [ContinuousMul R] {A : X → m → R} {B : X → n → R}\n    (hA : Continuous A) (hB : Continuous B) : Continuous fun x => vecMulVec (A x) (B x) :=\n  continuous_matrix fun _ _ => ((continuous_apply _).comp hA).mul ((continuous_apply _).comp hB)\n\n"}
{"name":"Continuous.matrix_mulVec","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace R\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : ContinuousAdd R\ninst✝¹ : ContinuousMul R\ninst✝ : Fintype n\nA : X → Matrix m n R\nB : X → n → R\nhA : Continuous A\nhB : Continuous B\n⊢ Continuous fun x => (A x).mulVec (B x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_mulVec [NonUnitalNonAssocSemiring R] [ContinuousAdd R] [ContinuousMul R]\n    [Fintype n] {A : X → Matrix m n R} {B : X → n → R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => A x *ᵥ B x :=\n  continuous_pi fun i => ((continuous_apply i).comp hA).matrix_dotProduct hB\n\n"}
{"name":"Continuous.matrix_vecMul","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace R\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : ContinuousAdd R\ninst✝¹ : ContinuousMul R\ninst✝ : Fintype m\nA : X → m → R\nB : X → Matrix m n R\nhA : Continuous A\nhB : Continuous B\n⊢ Continuous fun x => Matrix.vecMul (A x) (B x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_vecMul [NonUnitalNonAssocSemiring R] [ContinuousAdd R] [ContinuousMul R]\n    [Fintype m] {A : X → m → R} {B : X → Matrix m n R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => A x ᵥ* B x :=\n  continuous_pi fun _i => hA.matrix_dotProduct <| continuous_pi fun _j => hB.matrix_elem _ _\n\n"}
{"name":"Continuous.matrix_submatrix","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nA : X → Matrix l n R\nhA : Continuous A\ne₁ : m → l\ne₂ : p → n\n⊢ Continuous fun x => (A x).submatrix e₁ e₂","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_submatrix {A : X → Matrix l n R} (hA : Continuous A) (e₁ : m → l)\n    (e₂ : p → n) : Continuous fun x => (A x).submatrix e₁ e₂ :=\n  continuous_matrix fun _i _j => hA.matrix_elem _ _\n\n"}
{"name":"Continuous.matrix_reindex","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nA : X → Matrix l n R\nhA : Continuous A\ne₁ : Equiv l m\ne₂ : Equiv n p\n⊢ Continuous fun x => (Matrix.reindex e₁ e₂) (A x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_reindex {A : X → Matrix l n R} (hA : Continuous A) (e₁ : l ≃ m)\n    (e₂ : n ≃ p) : Continuous fun x => reindex e₁ e₂ (A x) :=\n  hA.matrix_submatrix _ _\n\n"}
{"name":"Continuous.matrix_diag","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nA : X → Matrix n n R\nhA : Continuous A\n⊢ Continuous fun x => (A x).diag","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_diag {A : X → Matrix n n R} (hA : Continuous A) :\n    Continuous fun x => Matrix.diag (A x) :=\n  continuous_pi fun _ => hA.matrix_elem _ _\n\n-- note this doesn't elaborate well from the above\n"}
{"name":"continuous_matrix_diag","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"n : Type u_5\nR : Type u_8\ninst✝ : TopologicalSpace R\n⊢ Continuous Matrix.diag","decl":"theorem continuous_matrix_diag : Continuous (Matrix.diag : Matrix n n R → n → R) :=\n  show Continuous fun x : Matrix n n R => Matrix.diag x from continuous_id.matrix_diag\n\n"}
{"name":"Continuous.matrix_trace","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace R\ninst✝² : Fintype n\ninst✝¹ : AddCommMonoid R\ninst✝ : ContinuousAdd R\nA : X → Matrix n n R\nhA : Continuous A\n⊢ Continuous fun x => (A x).trace","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_trace [Fintype n] [AddCommMonoid R] [ContinuousAdd R]\n    {A : X → Matrix n n R} (hA : Continuous A) : Continuous fun x => trace (A x) :=\n  continuous_finset_sum _ fun _ _ => hA.matrix_elem _ _\n\n"}
{"name":"Continuous.matrix_det","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace R\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : TopologicalRing R\nA : X → Matrix n n R\nhA : Continuous A\n⊢ Continuous fun x => (A x).det","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_det [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R]\n    {A : X → Matrix n n R} (hA : Continuous A) : Continuous fun x => (A x).det := by\n  simp_rw [Matrix.det_apply]\n  refine continuous_finset_sum _ fun l _ => Continuous.const_smul ?_ _\n  exact continuous_finset_prod _ fun l _ => hA.matrix_elem _ _\n\n"}
{"name":"Continuous.matrix_updateCol","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq n\ni : n\nA : X → Matrix m n R\nB : X → m → R\nhA : Continuous A\nhB : Continuous B\n⊢ Continuous fun x => (A x).updateCol i (B x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_updateCol [DecidableEq n] (i : n) {A : X → Matrix m n R}\n    {B : X → m → R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => (A x).updateCol i (B x) :=\n  continuous_matrix fun _j k =>\n    (continuous_apply k).comp <|\n      ((continuous_apply _).comp hA).update i ((continuous_apply _).comp hB)\n\n"}
{"name":"Continuous.matrix_updateColumn","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq n\ni : n\nA : X → Matrix m n R\nB : X → m → R\nhA : Continuous A\nhB : Continuous B\n⊢ Continuous fun x => (A x).updateCol i (B x)","decl":"@[deprecated (since := \"2024-12-11\")]\nalias Continuous.matrix_updateColumn := Continuous.matrix_updateCol\n\n"}
{"name":"Continuous.matrix_updateRow","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq m\ni : m\nA : X → Matrix m n R\nB : X → n → R\nhA : Continuous A\nhB : Continuous B\n⊢ Continuous fun x => (A x).updateRow i (B x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_updateRow [DecidableEq m] (i : m) {A : X → Matrix m n R} {B : X → n → R}\n    (hA : Continuous A) (hB : Continuous B) : Continuous fun x => (A x).updateRow i (B x) :=\n  hA.update i hB\n\n"}
{"name":"Continuous.matrix_cramer","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace R\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : TopologicalRing R\nA : X → Matrix n n R\nB : X → n → R\nhA : Continuous A\nhB : Continuous B\n⊢ Continuous fun x => (A x).cramer (B x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_cramer [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R]\n    {A : X → Matrix n n R} {B : X → n → R} (hA : Continuous A) (hB : Continuous B) :\n    Continuous fun x => cramer (A x) (B x) :=\n  continuous_pi fun _ => (hA.matrix_updateCol _ hB).matrix_det\n\n"}
{"name":"Continuous.matrix_adjugate","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace R\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : TopologicalRing R\nA : X → Matrix n n R\nhA : Continuous A\n⊢ Continuous fun x => (A x).adjugate","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_adjugate [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R]\n    {A : X → Matrix n n R} (hA : Continuous A) : Continuous fun x => (A x).adjugate :=\n  continuous_matrix fun _j k =>\n    (hA.matrix_transpose.matrix_updateCol k continuous_const).matrix_det\n\n"}
{"name":"continuousAt_matrix_inv","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"n : Type u_5\nR : Type u_8\ninst✝⁴ : TopologicalSpace R\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : CommRing R\ninst✝ : TopologicalRing R\nA : Matrix n n R\nh : ContinuousAt Ring.inverse A.det\n⊢ ContinuousAt Inv.inv A","decl":"/-- When `Ring.inverse` is continuous at the determinant (such as in a `NormedRing`, or a\ntopological field), so is `Matrix.inv`. -/\ntheorem continuousAt_matrix_inv [Fintype n] [DecidableEq n] [CommRing R] [TopologicalRing R]\n    (A : Matrix n n R) (h : ContinuousAt Ring.inverse A.det) : ContinuousAt Inv.inv A :=\n  (h.comp continuous_id.matrix_det.continuousAt).smul continuous_id.matrix_adjugate.continuousAt\n\n-- lemmas about functions in `Data/Matrix/Block.lean`\n"}
{"name":"Continuous.matrix_fromBlocks","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nA : X → Matrix n l R\nB : X → Matrix n m R\nC : X → Matrix p l R\nD : X → Matrix p m R\nhA : Continuous A\nhB : Continuous B\nhC : Continuous C\nhD : Continuous D\n⊢ Continuous fun x => Matrix.fromBlocks (A x) (B x) (C x) (D x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_fromBlocks {A : X → Matrix n l R} {B : X → Matrix n m R}\n    {C : X → Matrix p l R} {D : X → Matrix p m R} (hA : Continuous A) (hB : Continuous B)\n    (hC : Continuous C) (hD : Continuous D) :\n    Continuous fun x => Matrix.fromBlocks (A x) (B x) (C x) (D x) :=\n  continuous_matrix <| by\n    rintro (i | i) (j | j) <;> refine Continuous.matrix_elem ?_ i j <;> assumption\n\n"}
{"name":"Continuous.matrix_blockDiagonal","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace R\ninst✝¹ : Zero R\ninst✝ : DecidableEq p\nA : X → p → Matrix m n R\nhA : Continuous A\n⊢ Continuous fun x => Matrix.blockDiagonal (A x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_blockDiagonal [Zero R] [DecidableEq p] {A : X → p → Matrix m n R}\n    (hA : Continuous A) : Continuous fun x => blockDiagonal (A x) :=\n  continuous_matrix fun ⟨i₁, i₂⟩ ⟨j₁, _j₂⟩ =>\n    (((continuous_apply i₂).comp hA).matrix_elem i₁ j₁).if_const _ continuous_zero\n\n"}
{"name":"Continuous.matrix_blockDiag","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nA : X → Matrix (Prod m p) (Prod n p) R\nhA : Continuous A\n⊢ Continuous fun x => (A x).blockDiag","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_blockDiag {A : X → Matrix (m × p) (n × p) R} (hA : Continuous A) :\n    Continuous fun x => blockDiag (A x) :=\n  continuous_pi fun _i => continuous_matrix fun _j _k => hA.matrix_elem _ _\n\n"}
{"name":"Continuous.matrix_blockDiagonal'","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nR : Type u_8\nm' : l → Type u_9\nn' : l → Type u_10\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace R\ninst✝¹ : Zero R\ninst✝ : DecidableEq l\nA : X → (i : l) → Matrix (m' i) (n' i) R\nhA : Continuous A\n⊢ Continuous fun x => Matrix.blockDiagonal' (A x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_blockDiagonal' [Zero R] [DecidableEq l]\n    {A : X → ∀ i, Matrix (m' i) (n' i) R} (hA : Continuous A) :\n    Continuous fun x => blockDiagonal' (A x) :=\n  continuous_matrix fun ⟨i₁, i₂⟩ ⟨j₁, j₂⟩ => by\n    dsimp only [blockDiagonal'_apply']\n    split_ifs with h\n    · subst h\n      exact ((continuous_apply i₁).comp hA).matrix_elem i₂ j₂\n    · exact continuous_const\n\n"}
{"name":"Continuous.matrix_blockDiag'","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nR : Type u_8\nm' : l → Type u_9\nn' : l → Type u_10\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace R\nA : X → Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) R\nhA : Continuous A\n⊢ Continuous fun x => (A x).blockDiag'","decl":"@[continuity, fun_prop]\ntheorem Continuous.matrix_blockDiag' {A : X → Matrix (Σi, m' i) (Σi, n' i) R} (hA : Continuous A) :\n    Continuous fun x => blockDiag' (A x) :=\n  continuous_pi fun _i => continuous_matrix fun _j _k => hA.matrix_elem _ _\n\n"}
{"name":"HasSum.matrix_transpose","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝¹ : AddCommMonoid R\ninst✝ : TopologicalSpace R\nf : X → Matrix m n R\na : Matrix m n R\nhf : HasSum f a\n⊢ HasSum (fun x => (f x).transpose) a.transpose","decl":"theorem HasSum.matrix_transpose {f : X → Matrix m n R} {a : Matrix m n R} (hf : HasSum f a) :\n    HasSum (fun x => (f x)ᵀ) aᵀ :=\n  (hf.map (Matrix.transposeAddEquiv m n R) continuous_id.matrix_transpose :)\n\n"}
{"name":"Summable.matrix_transpose","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝¹ : AddCommMonoid R\ninst✝ : TopologicalSpace R\nf : X → Matrix m n R\nhf : Summable f\n⊢ Summable fun x => (f x).transpose","decl":"theorem Summable.matrix_transpose {f : X → Matrix m n R} (hf : Summable f) :\n    Summable fun x => (f x)ᵀ :=\n  hf.hasSum.matrix_transpose.summable\n\n"}
{"name":"summable_matrix_transpose","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝¹ : AddCommMonoid R\ninst✝ : TopologicalSpace R\nf : X → Matrix m n R\n⊢ Iff (Summable fun x => (f x).transpose) (Summable f)","decl":"@[simp]\ntheorem summable_matrix_transpose {f : X → Matrix m n R} :\n    (Summable fun x => (f x)ᵀ) ↔ Summable f :=\n  Summable.map_iff_of_equiv (Matrix.transposeAddEquiv m n R)\n    continuous_id.matrix_transpose continuous_id.matrix_transpose\n\n"}
{"name":"Matrix.transpose_tsum","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : T2Space R\nf : X → Matrix m n R\n⊢ Eq (tsum fun x => f x).transpose (tsum fun x => (f x).transpose)","decl":"theorem Matrix.transpose_tsum [T2Space R] {f : X → Matrix m n R} : (∑' x, f x)ᵀ = ∑' x, (f x)ᵀ := by\n  by_cases hf : Summable f\n  · exact hf.hasSum.matrix_transpose.tsum_eq.symm\n  · have hft := summable_matrix_transpose.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft, transpose_zero]\n\n"}
{"name":"HasSum.matrix_conjTranspose","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝³ : AddCommMonoid R\ninst✝² : TopologicalSpace R\ninst✝¹ : StarAddMonoid R\ninst✝ : ContinuousStar R\nf : X → Matrix m n R\na : Matrix m n R\nhf : HasSum f a\n⊢ HasSum (fun x => (f x).conjTranspose) a.conjTranspose","decl":"theorem HasSum.matrix_conjTranspose [StarAddMonoid R] [ContinuousStar R] {f : X → Matrix m n R}\n    {a : Matrix m n R} (hf : HasSum f a) : HasSum (fun x => (f x)ᴴ) aᴴ :=\n  (hf.map (Matrix.conjTransposeAddEquiv m n R) continuous_id.matrix_conjTranspose :)\n\n"}
{"name":"Summable.matrix_conjTranspose","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝³ : AddCommMonoid R\ninst✝² : TopologicalSpace R\ninst✝¹ : StarAddMonoid R\ninst✝ : ContinuousStar R\nf : X → Matrix m n R\nhf : Summable f\n⊢ Summable fun x => (f x).conjTranspose","decl":"theorem Summable.matrix_conjTranspose [StarAddMonoid R] [ContinuousStar R] {f : X → Matrix m n R}\n    (hf : Summable f) : Summable fun x => (f x)ᴴ :=\n  hf.hasSum.matrix_conjTranspose.summable\n\n"}
{"name":"summable_matrix_conjTranspose","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝³ : AddCommMonoid R\ninst✝² : TopologicalSpace R\ninst✝¹ : StarAddMonoid R\ninst✝ : ContinuousStar R\nf : X → Matrix m n R\n⊢ Iff (Summable fun x => (f x).conjTranspose) (Summable f)","decl":"@[simp]\ntheorem summable_matrix_conjTranspose [StarAddMonoid R] [ContinuousStar R] {f : X → Matrix m n R} :\n    (Summable fun x => (f x)ᴴ) ↔ Summable f :=\n  Summable.map_iff_of_equiv (Matrix.conjTransposeAddEquiv m n R)\n    continuous_id.matrix_conjTranspose continuous_id.matrix_conjTranspose\n\n"}
{"name":"Matrix.conjTranspose_tsum","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\nR : Type u_8\ninst✝⁴ : AddCommMonoid R\ninst✝³ : TopologicalSpace R\ninst✝² : StarAddMonoid R\ninst✝¹ : ContinuousStar R\ninst✝ : T2Space R\nf : X → Matrix m n R\n⊢ Eq (tsum fun x => f x).conjTranspose (tsum fun x => (f x).conjTranspose)","decl":"theorem Matrix.conjTranspose_tsum [StarAddMonoid R] [ContinuousStar R] [T2Space R]\n    {f : X → Matrix m n R} : (∑' x, f x)ᴴ = ∑' x, (f x)ᴴ := by\n  by_cases hf : Summable f\n  · exact hf.hasSum.matrix_conjTranspose.tsum_eq.symm\n  · have hft := summable_matrix_conjTranspose.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft, conjTranspose_zero]\n\n"}
{"name":"HasSum.matrix_diagonal","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq n\nf : X → n → R\na : n → R\nhf : HasSum f a\n⊢ HasSum (fun x => Matrix.diagonal (f x)) (Matrix.diagonal a)","decl":"theorem HasSum.matrix_diagonal [DecidableEq n] {f : X → n → R} {a : n → R} (hf : HasSum f a) :\n    HasSum (fun x => diagonal (f x)) (diagonal a) :=\n  hf.map (diagonalAddMonoidHom n R) continuous_id.matrix_diagonal\n\n"}
{"name":"Summable.matrix_diagonal","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq n\nf : X → n → R\nhf : Summable f\n⊢ Summable fun x => Matrix.diagonal (f x)","decl":"theorem Summable.matrix_diagonal [DecidableEq n] {f : X → n → R} (hf : Summable f) :\n    Summable fun x => diagonal (f x) :=\n  hf.hasSum.matrix_diagonal.summable\n\n"}
{"name":"summable_matrix_diagonal","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq n\nf : X → n → R\n⊢ Iff (Summable fun x => Matrix.diagonal (f x)) (Summable f)","decl":"@[simp]\ntheorem summable_matrix_diagonal [DecidableEq n] {f : X → n → R} :\n    (Summable fun x => diagonal (f x)) ↔ Summable f :=\n  Summable.map_iff_of_leftInverse (Matrix.diagonalAddMonoidHom n R) (Matrix.diagAddMonoidHom n R)\n    continuous_id.matrix_diagonal continuous_matrix_diag fun A => diag_diagonal A\n\n"}
{"name":"Matrix.diagonal_tsum","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝³ : AddCommMonoid R\ninst✝² : TopologicalSpace R\ninst✝¹ : DecidableEq n\ninst✝ : T2Space R\nf : X → n → R\n⊢ Eq (Matrix.diagonal (tsum fun x => f x)) (tsum fun x => Matrix.diagonal (f x))","decl":"theorem Matrix.diagonal_tsum [DecidableEq n] [T2Space R] {f : X → n → R} :\n    diagonal (∑' x, f x) = ∑' x, diagonal (f x) := by\n  by_cases hf : Summable f\n  · exact hf.hasSum.matrix_diagonal.tsum_eq.symm\n  · have hft := summable_matrix_diagonal.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft]\n    exact diagonal_zero\n\n"}
{"name":"HasSum.matrix_diag","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝¹ : AddCommMonoid R\ninst✝ : TopologicalSpace R\nf : X → Matrix n n R\na : Matrix n n R\nhf : HasSum f a\n⊢ HasSum (fun x => (f x).diag) a.diag","decl":"theorem HasSum.matrix_diag {f : X → Matrix n n R} {a : Matrix n n R} (hf : HasSum f a) :\n    HasSum (fun x => diag (f x)) (diag a) :=\n  hf.map (diagAddMonoidHom n R) continuous_matrix_diag\n\n"}
{"name":"Summable.matrix_diag","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nn : Type u_5\nR : Type u_8\ninst✝¹ : AddCommMonoid R\ninst✝ : TopologicalSpace R\nf : X → Matrix n n R\nhf : Summable f\n⊢ Summable fun x => (f x).diag","decl":"theorem Summable.matrix_diag {f : X → Matrix n n R} (hf : Summable f) :\n    Summable fun x => diag (f x) :=\n  hf.hasSum.matrix_diag.summable\n\n"}
{"name":"HasSum.matrix_blockDiagonal","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq p\nf : X → p → Matrix m n R\na : p → Matrix m n R\nhf : HasSum f a\n⊢ HasSum (fun x => Matrix.blockDiagonal (f x)) (Matrix.blockDiagonal a)","decl":"theorem HasSum.matrix_blockDiagonal [DecidableEq p] {f : X → p → Matrix m n R}\n    {a : p → Matrix m n R} (hf : HasSum f a) :\n    HasSum (fun x => blockDiagonal (f x)) (blockDiagonal a) :=\n  hf.map (blockDiagonalAddMonoidHom m n p R) continuous_id.matrix_blockDiagonal\n\n"}
{"name":"Summable.matrix_blockDiagonal","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq p\nf : X → p → Matrix m n R\nhf : Summable f\n⊢ Summable fun x => Matrix.blockDiagonal (f x)","decl":"theorem Summable.matrix_blockDiagonal [DecidableEq p] {f : X → p → Matrix m n R} (hf : Summable f) :\n    Summable fun x => blockDiagonal (f x) :=\n  hf.hasSum.matrix_blockDiagonal.summable\n\n"}
{"name":"summable_matrix_blockDiagonal","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq p\nf : X → p → Matrix m n R\n⊢ Iff (Summable fun x => Matrix.blockDiagonal (f x)) (Summable f)","decl":"theorem summable_matrix_blockDiagonal [DecidableEq p] {f : X → p → Matrix m n R} :\n    (Summable fun x => blockDiagonal (f x)) ↔ Summable f :=\n  Summable.map_iff_of_leftInverse (blockDiagonalAddMonoidHom m n p R)\n    (blockDiagAddMonoidHom m n p R) continuous_id.matrix_blockDiagonal\n    continuous_id.matrix_blockDiag fun A => blockDiag_blockDiagonal A\n\n"}
{"name":"Matrix.blockDiagonal_tsum","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝³ : AddCommMonoid R\ninst✝² : TopologicalSpace R\ninst✝¹ : DecidableEq p\ninst✝ : T2Space R\nf : X → p → Matrix m n R\n⊢ Eq (Matrix.blockDiagonal (tsum fun x => f x)) (tsum fun x => Matrix.blockDiagonal (f x))","decl":"theorem Matrix.blockDiagonal_tsum [DecidableEq p] [T2Space R] {f : X → p → Matrix m n R} :\n    blockDiagonal (∑' x, f x) = ∑' x, blockDiagonal (f x) := by\n  by_cases hf : Summable f\n  · exact hf.hasSum.matrix_blockDiagonal.tsum_eq.symm\n  · have hft := summable_matrix_blockDiagonal.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft]\n    exact blockDiagonal_zero\n\n"}
{"name":"HasSum.matrix_blockDiag","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝¹ : AddCommMonoid R\ninst✝ : TopologicalSpace R\nf : X → Matrix (Prod m p) (Prod n p) R\na : Matrix (Prod m p) (Prod n p) R\nhf : HasSum f a\n⊢ HasSum (fun x => (f x).blockDiag) a.blockDiag","decl":"theorem HasSum.matrix_blockDiag {f : X → Matrix (m × p) (n × p) R} {a : Matrix (m × p) (n × p) R}\n    (hf : HasSum f a) : HasSum (fun x => blockDiag (f x)) (blockDiag a) :=\n  (hf.map (blockDiagAddMonoidHom m n p R) <| Continuous.matrix_blockDiag continuous_id :)\n\n"}
{"name":"Summable.matrix_blockDiag","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nm : Type u_4\nn : Type u_5\np : Type u_6\nR : Type u_8\ninst✝¹ : AddCommMonoid R\ninst✝ : TopologicalSpace R\nf : X → Matrix (Prod m p) (Prod n p) R\nhf : Summable f\n⊢ Summable fun x => (f x).blockDiag","decl":"theorem Summable.matrix_blockDiag {f : X → Matrix (m × p) (n × p) R} (hf : Summable f) :\n    Summable fun x => blockDiag (f x) :=\n  hf.hasSum.matrix_blockDiag.summable\n\n"}
{"name":"HasSum.matrix_blockDiagonal'","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nR : Type u_8\nm' : l → Type u_9\nn' : l → Type u_10\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq l\nf : X → (i : l) → Matrix (m' i) (n' i) R\na : (i : l) → Matrix (m' i) (n' i) R\nhf : HasSum f a\n⊢ HasSum (fun x => Matrix.blockDiagonal' (f x)) (Matrix.blockDiagonal' a)","decl":"theorem HasSum.matrix_blockDiagonal' [DecidableEq l] {f : X → ∀ i, Matrix (m' i) (n' i) R}\n    {a : ∀ i, Matrix (m' i) (n' i) R} (hf : HasSum f a) :\n    HasSum (fun x => blockDiagonal' (f x)) (blockDiagonal' a) :=\n  hf.map (blockDiagonal'AddMonoidHom m' n' R) continuous_id.matrix_blockDiagonal'\n\n"}
{"name":"Summable.matrix_blockDiagonal'","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nR : Type u_8\nm' : l → Type u_9\nn' : l → Type u_10\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq l\nf : X → (i : l) → Matrix (m' i) (n' i) R\nhf : Summable f\n⊢ Summable fun x => Matrix.blockDiagonal' (f x)","decl":"theorem Summable.matrix_blockDiagonal' [DecidableEq l] {f : X → ∀ i, Matrix (m' i) (n' i) R}\n    (hf : Summable f) : Summable fun x => blockDiagonal' (f x) :=\n  hf.hasSum.matrix_blockDiagonal'.summable\n\n"}
{"name":"summable_matrix_blockDiagonal'","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nR : Type u_8\nm' : l → Type u_9\nn' : l → Type u_10\ninst✝² : AddCommMonoid R\ninst✝¹ : TopologicalSpace R\ninst✝ : DecidableEq l\nf : X → (i : l) → Matrix (m' i) (n' i) R\n⊢ Iff (Summable fun x => Matrix.blockDiagonal' (f x)) (Summable f)","decl":"theorem summable_matrix_blockDiagonal' [DecidableEq l] {f : X → ∀ i, Matrix (m' i) (n' i) R} :\n    (Summable fun x => blockDiagonal' (f x)) ↔ Summable f :=\n  Summable.map_iff_of_leftInverse (blockDiagonal'AddMonoidHom m' n' R)\n    (blockDiag'AddMonoidHom m' n' R) continuous_id.matrix_blockDiagonal'\n    continuous_id.matrix_blockDiag' fun A => blockDiag'_blockDiagonal' A\n\n"}
{"name":"Matrix.blockDiagonal'_tsum","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nR : Type u_8\nm' : l → Type u_9\nn' : l → Type u_10\ninst✝³ : AddCommMonoid R\ninst✝² : TopologicalSpace R\ninst✝¹ : DecidableEq l\ninst✝ : T2Space R\nf : X → (i : l) → Matrix (m' i) (n' i) R\n⊢ Eq (Matrix.blockDiagonal' (tsum fun x => f x)) (tsum fun x => Matrix.blockDiagonal' (f x))","decl":"theorem Matrix.blockDiagonal'_tsum [DecidableEq l] [T2Space R]\n    {f : X → ∀ i, Matrix (m' i) (n' i) R} :\n    blockDiagonal' (∑' x, f x) = ∑' x, blockDiagonal' (f x) := by\n  by_cases hf : Summable f\n  · exact hf.hasSum.matrix_blockDiagonal'.tsum_eq.symm\n  · have hft := summable_matrix_blockDiagonal'.not.mpr hf\n    rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft]\n    exact blockDiagonal'_zero\n\n"}
{"name":"HasSum.matrix_blockDiag'","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nR : Type u_8\nm' : l → Type u_9\nn' : l → Type u_10\ninst✝¹ : AddCommMonoid R\ninst✝ : TopologicalSpace R\nf : X → Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) R\na : Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) R\nhf : HasSum f a\n⊢ HasSum (fun x => (f x).blockDiag') a.blockDiag'","decl":"theorem HasSum.matrix_blockDiag' {f : X → Matrix (Σi, m' i) (Σi, n' i) R}\n    {a : Matrix (Σi, m' i) (Σi, n' i) R} (hf : HasSum f a) :\n    HasSum (fun x => blockDiag' (f x)) (blockDiag' a) :=\n  hf.map (blockDiag'AddMonoidHom m' n' R) continuous_id.matrix_blockDiag'\n\n"}
{"name":"Summable.matrix_blockDiag'","module":"Mathlib.Topology.Instances.Matrix","initialProofState":"X : Type u_1\nl : Type u_3\nR : Type u_8\nm' : l → Type u_9\nn' : l → Type u_10\ninst✝¹ : AddCommMonoid R\ninst✝ : TopologicalSpace R\nf : X → Matrix (Sigma fun i => m' i) (Sigma fun i => n' i) R\nhf : Summable f\n⊢ Summable fun x => (f x).blockDiag'","decl":"theorem Summable.matrix_blockDiag' {f : X → Matrix (Σi, m' i) (Σi, n' i) R} (hf : Summable f) :\n    Summable fun x => blockDiag' (f x) :=\n  hf.hasSum.matrix_blockDiag'.summable\n\n"}
