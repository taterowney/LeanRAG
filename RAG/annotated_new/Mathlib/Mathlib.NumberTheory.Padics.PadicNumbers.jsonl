{"name":"PadicSeq.stationary","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : CauSeq Rat (padicNorm p)\nhf : Not (HasEquiv.Equiv f 0)\n⊢ Exists fun N => ∀ (m n : Nat), LE.le N m → LE.le N n → Eq (padicNorm p (↑f n)) (padicNorm p (↑f m))","decl":"/-- The `p`-adic norm of the entries of a nonzero Cauchy sequence of rationals is eventually\nconstant. -/\ntheorem stationary {f : CauSeq ℚ (padicNorm p)} (hf : ¬f ≈ 0) :\n    ∃ N, ∀ m n, N ≤ m → N ≤ n → padicNorm p (f n) = padicNorm p (f m) :=\n  have : ∃ ε > 0, ∃ N1, ∀ j ≥ N1, ε ≤ padicNorm p (f j) :=\n    CauSeq.abv_pos_of_not_limZero <| not_limZero_of_not_congr_zero hf\n  let ⟨ε, hε, N1, hN1⟩ := this\n  let ⟨N2, hN2⟩ := CauSeq.cauchy₂ f hε\n  ⟨max N1 N2, fun n m hn hm ↦ by\n    have : padicNorm p (f n - f m) < ε := hN2 _ (max_le_iff.1 hn).2 _ (max_le_iff.1 hm).2\n    have : padicNorm p (f n - f m) < padicNorm p (f n) :=\n      lt_of_lt_of_le this <| hN1 _ (max_le_iff.1 hn).1\n    have : padicNorm p (f n - f m) < max (padicNorm p (f n)) (padicNorm p (f m)) :=\n      lt_max_iff.2 (Or.inl this)\n    by_contra hne\n    rw [← padicNorm.neg (f m)] at hne\n    have hnam := add_eq_max_of_ne hne\n    rw [padicNorm.neg, max_comm] at hnam\n    rw [← hnam, sub_eq_add_neg, add_comm] at this\n    apply _root_.lt_irrefl _ this⟩\n\n"}
{"name":"PadicSeq.stationaryPoint_spec","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : Not (HasEquiv.Equiv f 0)\nm n : Nat\na✝¹ : LE.le (PadicSeq.stationaryPoint hf) m\na✝ : LE.le (PadicSeq.stationaryPoint hf) n\n⊢ Eq (padicNorm p (↑f n)) (padicNorm p (↑f m))","decl":"theorem stationaryPoint_spec {f : PadicSeq p} (hf : ¬f ≈ 0) :\n    ∀ {m n},\n      stationaryPoint hf ≤ m → stationaryPoint hf ≤ n → padicNorm p (f n) = padicNorm p (f m) :=\n  @(Classical.choose_spec <| stationary hf)\n\n"}
{"name":"PadicSeq.norm_zero_iff","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\n⊢ Iff (Eq f.norm 0) (HasEquiv.Equiv f 0)","decl":"theorem norm_zero_iff (f : PadicSeq p) : f.norm = 0 ↔ f ≈ 0 := by\n  constructor\n  · intro h\n    by_contra hf\n    unfold norm at h\n    split_ifs at h\n    apply hf\n    intro ε hε\n    exists stationaryPoint hf\n    intro j hj\n    have heq := stationaryPoint_spec hf le_rfl hj\n    simpa [h, heq]\n  · intro h\n    simp [norm, h]\n\n"}
{"name":"PadicSeq.equiv_zero_of_val_eq_of_equiv_zero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf g : PadicSeq p\nh : ∀ (k : Nat), Eq (padicNorm p (↑f k)) (padicNorm p (↑g k))\nhf : HasEquiv.Equiv f 0\n⊢ HasEquiv.Equiv g 0","decl":"theorem equiv_zero_of_val_eq_of_equiv_zero {f g : PadicSeq p}\n    (h : ∀ k, padicNorm p (f k) = padicNorm p (g k)) (hf : f ≈ 0) : g ≈ 0 := fun ε hε ↦\n  let ⟨i, hi⟩ := hf _ hε\n  ⟨i, fun j hj ↦ by simpa [h] using hi _ hj⟩\n\n"}
{"name":"PadicSeq.norm_nonzero_of_not_equiv_zero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : Not (HasEquiv.Equiv f 0)\n⊢ Ne f.norm 0","decl":"theorem norm_nonzero_of_not_equiv_zero {f : PadicSeq p} (hf : ¬f ≈ 0) : f.norm ≠ 0 :=\n  hf ∘ f.norm_zero_iff.1\n\n"}
{"name":"PadicSeq.norm_eq_norm_app_of_nonzero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : Not (HasEquiv.Equiv f 0)\n⊢ Exists fun k => And (Eq f.norm (padicNorm p k)) (Ne k 0)","decl":"theorem norm_eq_norm_app_of_nonzero {f : PadicSeq p} (hf : ¬f ≈ 0) :\n    ∃ k, f.norm = padicNorm p k ∧ k ≠ 0 :=\n  have heq : f.norm = padicNorm p (f <| stationaryPoint hf) := by simp [norm, hf]\n  ⟨f <| stationaryPoint hf, heq, fun h ↦\n    norm_nonzero_of_not_equiv_zero hf (by simpa [h] using heq)⟩\n\n"}
{"name":"PadicSeq.not_limZero_const_of_nonzero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq : Rat\nhq : Ne q 0\n⊢ Not (CauSeq.const (padicNorm p) q).LimZero","decl":"theorem not_limZero_const_of_nonzero {q : ℚ} (hq : q ≠ 0) : ¬LimZero (const (padicNorm p) q) :=\n  fun h' ↦ hq <| const_limZero.1 h'\n\n"}
{"name":"PadicSeq.not_equiv_zero_const_of_nonzero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq : Rat\nhq : Ne q 0\n⊢ Not (HasEquiv.Equiv (CauSeq.const (padicNorm p) q) 0)","decl":"theorem not_equiv_zero_const_of_nonzero {q : ℚ} (hq : q ≠ 0) : ¬const (padicNorm p) q ≈ 0 :=\n  fun h : LimZero (const (padicNorm p) q - 0) ↦\n    not_limZero_const_of_nonzero (p := p) hq <| by simpa using h\n\n"}
{"name":"PadicSeq.norm_nonneg","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\n⊢ LE.le 0 f.norm","decl":"theorem norm_nonneg (f : PadicSeq p) : 0 ≤ f.norm := by\n  classical exact if hf : f ≈ 0 then by simp [hf, norm] else by simp [norm, hf, padicNorm.nonneg]\n\n"}
{"name":"PadicSeq.lift_index_left_left","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : Not (HasEquiv.Equiv f 0)\nv2 v3 : Nat\n⊢ Eq (padicNorm p (↑f (PadicSeq.stationaryPoint hf))) (padicNorm p (↑f (Max.max (PadicSeq.stationaryPoint hf) (Max.max v2 v3))))","decl":"/-- An auxiliary lemma for manipulating sequence indices. -/\ntheorem lift_index_left_left {f : PadicSeq p} (hf : ¬f ≈ 0) (v2 v3 : ℕ) :\n    padicNorm p (f (stationaryPoint hf)) =\n    padicNorm p (f (max (stationaryPoint hf) (max v2 v3))) := by\n  apply stationaryPoint_spec hf\n  · apply le_max_left\n  · exact le_rfl\n\n"}
{"name":"PadicSeq.lift_index_left","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : Not (HasEquiv.Equiv f 0)\nv1 v3 : Nat\n⊢ Eq (padicNorm p (↑f (PadicSeq.stationaryPoint hf))) (padicNorm p (↑f (Max.max v1 (Max.max (PadicSeq.stationaryPoint hf) v3))))","decl":"/-- An auxiliary lemma for manipulating sequence indices. -/\ntheorem lift_index_left {f : PadicSeq p} (hf : ¬f ≈ 0) (v1 v3 : ℕ) :\n    padicNorm p (f (stationaryPoint hf)) =\n    padicNorm p (f (max v1 (max (stationaryPoint hf) v3))) := by\n  apply stationaryPoint_spec hf\n  · apply le_trans\n    · apply le_max_left _ v3\n    · apply le_max_right\n  · exact le_rfl\n\n"}
{"name":"PadicSeq.lift_index_right","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : Not (HasEquiv.Equiv f 0)\nv1 v2 : Nat\n⊢ Eq (padicNorm p (↑f (PadicSeq.stationaryPoint hf))) (padicNorm p (↑f (Max.max v1 (Max.max v2 (PadicSeq.stationaryPoint hf)))))","decl":"/-- An auxiliary lemma for manipulating sequence indices. -/\ntheorem lift_index_right {f : PadicSeq p} (hf : ¬f ≈ 0) (v1 v2 : ℕ) :\n    padicNorm p (f (stationaryPoint hf)) =\n    padicNorm p (f (max v1 (max v2 (stationaryPoint hf)))) := by\n  apply stationaryPoint_spec hf\n  · apply le_trans\n    · apply le_max_right v2\n    · apply le_max_right\n  · exact le_rfl\n\n"}
{"name":"PadicSeq.norm_eq_zpow_neg_valuation","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : Not (HasEquiv.Equiv f 0)\n⊢ Eq f.norm (HPow.hPow (↑p) (Neg.neg f.valuation))","decl":"theorem norm_eq_zpow_neg_valuation {f : PadicSeq p} (hf : ¬f ≈ 0) :\n    f.norm = (p : ℚ) ^ (-f.valuation : ℤ) := by\n  rw [norm, valuation, dif_neg hf, dif_neg hf, padicNorm, if_neg]\n  intro H\n  apply CauSeq.not_limZero_of_not_congr_zero hf\n  intro ε hε\n  use stationaryPoint hf\n  intro n hn\n  rw [stationaryPoint_spec hf le_rfl hn]\n  simpa [H] using hε\n\n"}
{"name":"PadicSeq.norm_eq_pow_val","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : Not (HasEquiv.Equiv f 0)\n⊢ Eq f.norm (HPow.hPow (↑p) (Neg.neg f.valuation))","decl":"@[deprecated (since := \"2024-12-10\")] alias norm_eq_pow_val := norm_eq_zpow_neg_valuation\n\n"}
{"name":"PadicSeq.val_eq_iff_norm_eq","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf g : PadicSeq p\nhf : Not (HasEquiv.Equiv f 0)\nhg : Not (HasEquiv.Equiv g 0)\n⊢ Iff (Eq f.valuation g.valuation) (Eq f.norm g.norm)","decl":"theorem val_eq_iff_norm_eq {f g : PadicSeq p} (hf : ¬f ≈ 0) (hg : ¬g ≈ 0) :\n    f.valuation = g.valuation ↔ f.norm = g.norm := by\n  rw [norm_eq_zpow_neg_valuation hf, norm_eq_zpow_neg_valuation hg, ← neg_inj, zpow_right_inj₀]\n  · exact mod_cast (Fact.out : p.Prime).pos\n  · exact mod_cast (Fact.out : p.Prime).ne_one\n\n"}
{"name":"PadicSeq.norm_mul","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nf g : PadicSeq p\n⊢ Eq (HMul.hMul f g).norm (HMul.hMul f.norm g.norm)","decl":"theorem norm_mul (f g : PadicSeq p) : (f * g).norm = f.norm * g.norm := by\n  classical\n  exact if hf : f ≈ 0 then by\n    have hg : f * g ≈ 0 := mul_equiv_zero' _ hf\n    simp only [hf, hg, norm, dif_pos, zero_mul]\n  else\n    if hg : g ≈ 0 then by\n      have hf : f * g ≈ 0 := mul_equiv_zero _ hg\n      simp only [hf, hg, norm, dif_pos, mul_zero]\n    else by\n      unfold norm\n      have hfg := mul_not_equiv_zero hf hg\n      simp only [hfg, hf, hg, dite_false]\n      -- Porting note: originally `padic_index_simp [hfg, hf, hg]`\n      rw [lift_index_left_left hfg, lift_index_left hf, lift_index_right hg]\n      apply padicNorm.mul\n\n"}
{"name":"PadicSeq.eq_zero_iff_equiv_zero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nf : PadicSeq p\n⊢ Iff (Eq (CauSeq.Completion.mk f) 0) (HasEquiv.Equiv f 0)","decl":"theorem eq_zero_iff_equiv_zero (f : PadicSeq p) : mk f = 0 ↔ f ≈ 0 :=\n  mk_eq\n\n"}
{"name":"PadicSeq.ne_zero_iff_nequiv_zero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nf : PadicSeq p\n⊢ Iff (Ne (CauSeq.Completion.mk f) 0) (Not (HasEquiv.Equiv f 0))","decl":"theorem ne_zero_iff_nequiv_zero (f : PadicSeq p) : mk f ≠ 0 ↔ ¬f ≈ 0 :=\n  eq_zero_iff_equiv_zero _ |>.not\n\n"}
{"name":"PadicSeq.norm_const","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Rat\n⊢ Eq (PadicSeq.norm (CauSeq.const (padicNorm p) q)) (padicNorm p q)","decl":"theorem norm_const (q : ℚ) : norm (const (padicNorm p) q) = padicNorm p q :=\n  if hq : q = 0 then by\n    have : const (padicNorm p) q ≈ 0 := by simpa [hq] using Setoid.refl (const (padicNorm p) 0)\n    subst hq; simp [norm, this]\n  else by\n    have : ¬const (padicNorm p) q ≈ 0 := not_equiv_zero_const_of_nonzero hq\n    simp [norm, this]\n\n"}
{"name":"PadicSeq.norm_values_discrete","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\na : PadicSeq p\nha : Not (HasEquiv.Equiv a 0)\n⊢ Exists fun z => Eq a.norm (HPow.hPow (↑p) (Neg.neg z))","decl":"theorem norm_values_discrete (a : PadicSeq p) (ha : ¬a ≈ 0) : ∃ z : ℤ, a.norm = (p : ℚ) ^ (-z) := by\n  let ⟨k, hk, hk'⟩ := norm_eq_norm_app_of_nonzero ha\n  simpa [hk] using padicNorm.values_discrete hk'\n\n"}
{"name":"PadicSeq.norm_one","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (PadicSeq.norm 1) 1","decl":"theorem norm_one : norm (1 : PadicSeq p) = 1 := by\n  have h1 : ¬(1 : PadicSeq p) ≈ 0 := one_not_equiv_zero _\n  simp [h1, norm, hp.1.one_lt]\n\n"}
{"name":"PadicSeq.norm_equiv","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nf g : PadicSeq p\nhfg : HasEquiv.Equiv f g\n⊢ Eq f.norm g.norm","decl":"theorem norm_equiv {f g : PadicSeq p} (hfg : f ≈ g) : f.norm = g.norm := by\n  classical\n  exact if hf : f ≈ 0 then by\n    have hg : g ≈ 0 := Setoid.trans (Setoid.symm hfg) hf\n    simp [norm, hf, hg]\n  else by\n    have hg : ¬g ≈ 0 := hf ∘ Setoid.trans hfg\n    unfold norm; split_ifs; exact norm_eq_of_equiv hf hg hfg\n\n"}
{"name":"PadicSeq.norm_nonarchimedean","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nf g : PadicSeq p\n⊢ LE.le (HAdd.hAdd f g).norm (Max.max f.norm g.norm)","decl":"theorem norm_nonarchimedean (f g : PadicSeq p) : (f + g).norm ≤ max f.norm g.norm := by\n  classical\n  exact if hfg : f + g ≈ 0 then by\n    have : 0 ≤ max f.norm g.norm := le_max_of_le_left (norm_nonneg _)\n    simpa only [hfg, norm]\n  else\n    if hf : f ≈ 0 then by\n      have hfg' : f + g ≈ g := by\n        change LimZero (f - 0) at hf\n        show LimZero (f + g - g); · simpa only [sub_zero, add_sub_cancel_right] using hf\n      have hcfg : (f + g).norm = g.norm := norm_equiv hfg'\n      have hcl : f.norm = 0 := (norm_zero_iff f).2 hf\n      have : max f.norm g.norm = g.norm := by rw [hcl]; exact max_eq_right (norm_nonneg _)\n      rw [this, hcfg]\n    else\n      if hg : g ≈ 0 then by\n        have hfg' : f + g ≈ f := by\n          change LimZero (g - 0) at hg\n          show LimZero (f + g - f); · simpa only [add_sub_cancel_left, sub_zero] using hg\n        have hcfg : (f + g).norm = f.norm := norm_equiv hfg'\n        have hcl : g.norm = 0 := (norm_zero_iff g).2 hg\n        have : max f.norm g.norm = f.norm := by rw [hcl]; exact max_eq_left (norm_nonneg _)\n        rw [this, hcfg]\n      else norm_nonarchimedean_aux hfg hf hg\n\n"}
{"name":"PadicSeq.norm_eq","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nf g : PadicSeq p\nh : ∀ (k : Nat), Eq (padicNorm p (↑f k)) (padicNorm p (↑g k))\n⊢ Eq f.norm g.norm","decl":"theorem norm_eq {f g : PadicSeq p} (h : ∀ k, padicNorm p (f k) = padicNorm p (g k)) :\n    f.norm = g.norm := by\n  classical\n  exact if hf : f ≈ 0 then by\n    have hg : g ≈ 0 := equiv_zero_of_val_eq_of_equiv_zero h hf\n    simp only [hf, hg, norm, dif_pos]\n  else by\n    have hg : ¬g ≈ 0 := fun hg ↦\n      hf <| equiv_zero_of_val_eq_of_equiv_zero (by simp only [h, forall_const, eq_self_iff_true]) hg\n    simp only [hg, hf, norm, dif_neg, not_false_iff]\n    let i := max (stationaryPoint hf) (stationaryPoint hg)\n    have hpf : padicNorm p (f (stationaryPoint hf)) = padicNorm p (f i) := by\n      apply stationaryPoint_spec\n      · apply le_max_left\n      · exact le_rfl\n    have hpg : padicNorm p (g (stationaryPoint hg)) = padicNorm p (g i) := by\n      apply stationaryPoint_spec\n      · apply le_max_right\n      · exact le_rfl\n    rw [hpf, hpg, h]\n\n"}
{"name":"PadicSeq.norm_neg","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\na : PadicSeq p\n⊢ Eq (Neg.neg a).norm a.norm","decl":"theorem norm_neg (a : PadicSeq p) : (-a).norm = a.norm :=\n  norm_eq <| by simp\n\n"}
{"name":"PadicSeq.norm_eq_of_add_equiv_zero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nf g : PadicSeq p\nh : HasEquiv.Equiv (HAdd.hAdd f g) 0\n⊢ Eq f.norm g.norm","decl":"theorem norm_eq_of_add_equiv_zero {f g : PadicSeq p} (h : f + g ≈ 0) : f.norm = g.norm := by\n  have : LimZero (f + g - 0) := h\n  have : f ≈ -g := show LimZero (f - -g) by simpa only [sub_zero, sub_neg_eq_add]\n  have : f.norm = (-g).norm := norm_equiv this\n  simpa only [norm_neg] using this\n\n"}
{"name":"PadicSeq.add_eq_max_of_ne","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nf g : PadicSeq p\nhfgne : Ne f.norm g.norm\n⊢ Eq (HAdd.hAdd f g).norm (Max.max f.norm g.norm)","decl":"theorem add_eq_max_of_ne {f g : PadicSeq p} (hfgne : f.norm ≠ g.norm) :\n    (f + g).norm = max f.norm g.norm := by\n  classical\n  have hfg : ¬f + g ≈ 0 := mt norm_eq_of_add_equiv_zero hfgne\n  exact if hf : f ≈ 0 then by\n    have : LimZero (f - 0) := hf\n    have : f + g ≈ g := show LimZero (f + g - g) by simpa only [sub_zero, add_sub_cancel_right]\n    have h1 : (f + g).norm = g.norm := norm_equiv this\n    have h2 : f.norm = 0 := (norm_zero_iff _).2 hf\n    rw [h1, h2, max_eq_right (norm_nonneg _)]\n  else\n    if hg : g ≈ 0 then by\n      have : LimZero (g - 0) := hg\n      have : f + g ≈ f := show LimZero (f + g - f) by simpa only [add_sub_cancel_left, sub_zero]\n      have h1 : (f + g).norm = f.norm := norm_equiv this\n      have h2 : g.norm = 0 := (norm_zero_iff _).2 hg\n      rw [h1, h2, max_eq_left (norm_nonneg _)]\n    else by\n      unfold norm at hfgne ⊢; split_ifs at hfgne ⊢\n      -- Porting note: originally `padic_index_simp [hfg, hf, hg] at hfgne ⊢`\n      rw [lift_index_left hf, lift_index_right hg] at hfgne\n      · rw [lift_index_left_left hfg, lift_index_left hf, lift_index_right hg]\n        exact padicNorm.add_eq_max_of_ne hfgne\n\n"}
{"name":"Padic.zero_def","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq 0 (Quotient.mk CauSeq.equiv 0)","decl":"theorem zero_def : (0 : ℚ_[p]) = ⟦0⟧ := rfl\n\n"}
{"name":"Padic.mk_eq","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf g : PadicSeq p\n⊢ Iff (Eq (Padic.mk f) (Padic.mk g)) (HasEquiv.Equiv f g)","decl":"theorem mk_eq {f g : PadicSeq p} : mk f = mk g ↔ f ≈ g :=\n  Quotient.eq'\n\n"}
{"name":"Padic.const_equiv","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq r : Rat\n⊢ Iff (HasEquiv.Equiv (CauSeq.const (padicNorm p) q) (CauSeq.const (padicNorm p) r)) (Eq q r)","decl":"theorem const_equiv {q r : ℚ} : const (padicNorm p) q ≈ const (padicNorm p) r ↔ q = r :=\n  ⟨fun heq ↦ eq_of_sub_eq_zero <| const_limZero.1 heq, fun heq ↦ by\n    rw [heq]⟩\n\n"}
{"name":"Padic.coe_inj","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq r : Rat\n⊢ Iff (Eq ↑q ↑r) (Eq q r)","decl":"@[norm_cast]\ntheorem coe_inj {q r : ℚ} : (↑q : ℚ_[p]) = ↑r ↔ q = r :=\n  ⟨(const_equiv p).1 ∘ Quotient.eq'.1, fun h ↦ by rw [h]⟩\n\n"}
{"name":"Padic.instCharZero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ CharZero (Padic p)","decl":"instance : CharZero ℚ_[p] :=\n  ⟨fun m n ↦ by\n    rw [← Rat.cast_natCast]\n    norm_cast\n    exact id⟩\n\n"}
{"name":"Padic.coe_add","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx y : Rat\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[norm_cast]\ntheorem coe_add : ∀ {x y : ℚ}, (↑(x + y) : ℚ_[p]) = ↑x + ↑y :=\n  Rat.cast_add _ _\n\n"}
{"name":"Padic.coe_neg","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx : Rat\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[norm_cast]\ntheorem coe_neg : ∀ {x : ℚ}, (↑(-x) : ℚ_[p]) = -↑x :=\n  Rat.cast_neg _\n\n"}
{"name":"Padic.coe_mul","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx y : Rat\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[norm_cast]\ntheorem coe_mul : ∀ {x y : ℚ}, (↑(x * y) : ℚ_[p]) = ↑x * ↑y :=\n  Rat.cast_mul _ _\n\n"}
{"name":"Padic.coe_sub","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx y : Rat\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"@[norm_cast]\ntheorem coe_sub : ∀ {x y : ℚ}, (↑(x - y) : ℚ_[p]) = ↑x - ↑y :=\n  Rat.cast_sub _ _\n\n"}
{"name":"Padic.coe_div","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx y : Rat\n⊢ Eq (↑(HDiv.hDiv x y)) (HDiv.hDiv ↑x ↑y)","decl":"@[norm_cast]\ntheorem coe_div : ∀ {x y : ℚ}, (↑(x / y) : ℚ_[p]) = ↑x / ↑y :=\n  Rat.cast_div _ _\n\n"}
{"name":"Padic.coe_one","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (↑1) 1","decl":"@[norm_cast]\ntheorem coe_one : (↑(1 : ℚ) : ℚ_[p]) = 1 := rfl\n\n"}
{"name":"Padic.coe_zero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (↑0) 0","decl":"@[norm_cast]\ntheorem coe_zero : (↑(0 : ℚ) : ℚ_[p]) = 0 := rfl\n\n"}
{"name":"padicNormE.defn","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : PadicSeq p\nε : Rat\nhε : LT.lt 0 ε\n⊢ Exists fun N => ∀ (i : Nat), GE.ge i N → LT.lt (padicNormE (HSub.hSub (Padic.mk f) ↑(↑f i))) ε","decl":"theorem defn (f : PadicSeq p) {ε : ℚ} (hε : 0 < ε) :\n    ∃ N, ∀ i ≥ N, padicNormE (Padic.mk f - f i : ℚ_[p]) < ε := by\n  dsimp [padicNormE]\n  -- `change ∃ N, ∀ i ≥ N, (f - const _ (f i)).norm < ε` also works, but is very slow\n  suffices hyp : ∃ N, ∀ i ≥ N, (f - const _ (f i)).norm < ε by peel hyp with N; use N\n  by_contra! h\n  cases' cauchy₂ f hε with N hN\n  rcases h N with ⟨i, hi, hge⟩\n  have hne : ¬f - const (padicNorm p) (f i) ≈ 0 := fun h ↦ by\n    rw [PadicSeq.norm, dif_pos h] at hge\n    exact not_lt_of_ge hge hε\n  unfold PadicSeq.norm at hge; split_ifs at hge\n  apply not_le_of_gt _ hge\n  cases _root_.le_total N (stationaryPoint hne) with\n  | inl hgen =>\n    exact hN _ hgen _ hi\n  | inr hngen =>\n    have := stationaryPoint_spec hne le_rfl hngen\n    rw [← this]\n    exact hN _ le_rfl _ hi\n\n"}
{"name":"padicNormE.nonarchimedean'","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq r : Padic p\n⊢ LE.le (padicNormE (HAdd.hAdd q r)) (Max.max (padicNormE q) (padicNormE r))","decl":"/-- Theorems about `padicNormE` are named with a `'` so the names do not conflict with the\nequivalent theorems about `norm` (`‖ ‖`). -/\ntheorem nonarchimedean' (q r : ℚ_[p]) :\n    padicNormE (q + r : ℚ_[p]) ≤ max (padicNormE q) (padicNormE r) :=\n  Quotient.inductionOn₂ q r <| norm_nonarchimedean\n\n"}
{"name":"padicNormE.add_eq_max_of_ne'","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq r : Padic p\na✝ : Ne (padicNormE q) (padicNormE r)\n⊢ Eq (padicNormE (HAdd.hAdd q r)) (Max.max (padicNormE q) (padicNormE r))","decl":"/-- Theorems about `padicNormE` are named with a `'` so the names do not conflict with the\nequivalent theorems about `norm` (`‖ ‖`). -/\ntheorem add_eq_max_of_ne' {q r : ℚ_[p]} :\n    padicNormE q ≠ padicNormE r → padicNormE (q + r : ℚ_[p]) = max (padicNormE q) (padicNormE r) :=\n  Quotient.inductionOn₂ q r fun _ _ ↦ PadicSeq.add_eq_max_of_ne\n\n"}
{"name":"padicNormE.eq_padic_norm'","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq : Rat\n⊢ Eq (padicNormE ↑q) (padicNorm p q)","decl":"@[simp]\ntheorem eq_padic_norm' (q : ℚ) : padicNormE (q : ℚ_[p]) = padicNorm p q :=\n  norm_const _\n\n"}
{"name":"padicNormE.image'","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq : Padic p\na✝ : Ne q 0\n⊢ Exists fun n => Eq (padicNormE q) (HPow.hPow (↑p) (Neg.neg n))","decl":"protected theorem image' {q : ℚ_[p]} : q ≠ 0 → ∃ n : ℤ, padicNormE q = (p : ℚ) ^ (-n) :=\n  Quotient.inductionOn q fun f hf ↦\n    have : ¬f ≈ 0 := (ne_zero_iff_nequiv_zero f).1 hf\n    norm_values_discrete f this\n\n"}
{"name":"Padic.rat_dense'","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq : Padic p\nε : Rat\nhε : LT.lt 0 ε\n⊢ Exists fun r => LT.lt (padicNormE (HSub.hSub q ↑r)) ε","decl":"theorem rat_dense' (q : ℚ_[p]) {ε : ℚ} (hε : 0 < ε) : ∃ r : ℚ, padicNormE (q - r : ℚ_[p]) < ε :=\n  Quotient.inductionOn q fun q' ↦\n    have : ∃ N, ∀ m ≥ N, ∀ n ≥ N, padicNorm p (q' m - q' n) < ε := cauchy₂ _ hε\n    let ⟨N, hN⟩ := this\n    ⟨q' N, by\n      classical\n      dsimp [padicNormE]\n      -- Porting note: `change` → `convert_to` (`change` times out!)\n      -- and add `PadicSeq p` type annotation\n      convert_to PadicSeq.norm (q' - const _ (q' N) : PadicSeq p) < ε\n      cases' Decidable.em (q' - const (padicNorm p) (q' N) ≈ 0) with heq hne'\n      · simpa only [heq, PadicSeq.norm, dif_pos]\n      · simp only [PadicSeq.norm, dif_neg hne']\n        change padicNorm p (q' _ - q' _) < ε\n        cases' Decidable.em (stationaryPoint hne' ≤ N) with hle hle\n        · -- Porting note: inlined `stationaryPoint_spec` invocation.\n          have := (stationaryPoint_spec hne' le_rfl hle).symm\n          simp only [const_apply, sub_apply, padicNorm.zero, sub_self] at this\n          simpa only [this]\n        · exact hN _ (lt_of_not_ge hle).le _ le_rfl⟩\n\n"}
{"name":"Padic.exi_rat_seq_conv","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : CauSeq (Padic p) ⇑padicNormE\nε : Rat\nhε : LT.lt 0 ε\n⊢ Exists fun N => ∀ (i : Nat), GE.ge i N → LT.lt (padicNormE (HSub.hSub (↑f i) ↑(Padic.limSeq f i))) ε","decl":"theorem exi_rat_seq_conv {ε : ℚ} (hε : 0 < ε) :\n    ∃ N, ∀ i ≥ N, padicNormE (f i - (limSeq f i : ℚ_[p]) : ℚ_[p]) < ε := by\n  refine (exists_nat_gt (1 / ε)).imp fun N hN i hi ↦ ?_\n  have h := Classical.choose_spec (rat_dense' (f i) (div_nat_pos i))\n  refine lt_of_lt_of_le h ((div_le_iff₀' <| mod_cast succ_pos _).mpr ?_)\n  rw [right_distrib]\n  apply le_add_of_le_of_nonneg\n  · exact (div_le_iff₀ hε).mp (le_trans (le_of_lt hN) (mod_cast hi))\n  · apply le_of_lt\n    simpa\n\n"}
{"name":"Padic.exi_rat_seq_conv_cauchy","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : CauSeq (Padic p) ⇑padicNormE\n⊢ IsCauSeq (padicNorm p) (Padic.limSeq f)","decl":"theorem exi_rat_seq_conv_cauchy : IsCauSeq (padicNorm p) (limSeq f) := fun ε hε ↦ by\n  have hε3 : 0 < ε / 3 := div_pos hε (by norm_num)\n  let ⟨N, hN⟩ := exi_rat_seq_conv f hε3\n  let ⟨N2, hN2⟩ := f.cauchy₂ hε3\n  exists max N N2\n  intro j hj\n  suffices\n    padicNormE (limSeq f j - f (max N N2) + (f (max N N2) - limSeq f (max N N2)) : ℚ_[p]) < ε by\n    ring_nf at this ⊢\n    rw [← padicNormE.eq_padic_norm']\n    exact mod_cast this\n  apply lt_of_le_of_lt\n  · apply padicNormE.add_le\n  · rw [← add_thirds ε]\n    apply _root_.add_lt_add\n    · suffices padicNormE (limSeq f j - f j + (f j - f (max N N2)) : ℚ_[p]) < ε / 3 + ε / 3 by\n        simpa only [sub_add_sub_cancel]\n      apply lt_of_le_of_lt\n      · apply padicNormE.add_le\n      · apply _root_.add_lt_add\n        · rw [padicNormE.map_sub]\n          apply mod_cast hN j\n          exact le_of_max_le_left hj\n        · exact hN2 _ (le_of_max_le_right hj) _ (le_max_right _ _)\n    · apply mod_cast hN (max N N2)\n      apply le_max_left\n\n"}
{"name":"Padic.complete'","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : CauSeq (Padic p) ⇑padicNormE\n⊢ Exists fun q => ∀ (ε : Rat), GT.gt ε 0 → Exists fun N => ∀ (i : Nat), GE.ge i N → LT.lt (padicNormE (HSub.hSub q (↑f i))) ε","decl":"theorem complete' : ∃ q : ℚ_[p], ∀ ε > 0, ∃ N, ∀ i ≥ N, padicNormE (q - f i : ℚ_[p]) < ε :=\n  ⟨lim f, fun ε hε ↦ by\n    obtain ⟨N, hN⟩ := exi_rat_seq_conv f (half_pos hε)\n    obtain ⟨N2, hN2⟩ := padicNormE.defn (lim' f) (half_pos hε)\n    refine ⟨max N N2, fun i hi ↦ ?_⟩\n    rw [← sub_add_sub_cancel _ (lim' f i : ℚ_[p]) _]\n    refine (padicNormE.add_le _ _).trans_lt ?_\n    rw [← add_halves ε]\n    apply _root_.add_lt_add\n    · apply hN2 _ (le_of_max_le_right hi)\n    · rw [padicNormE.map_sub]\n      exact hN _ (le_of_max_le_left hi)⟩\n\n"}
{"name":"Padic.complete''","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : CauSeq (Padic p) ⇑padicNormE\n⊢ Exists fun q => ∀ (ε : Rat), GT.gt ε 0 → Exists fun N => ∀ (i : Nat), GE.ge i N → LT.lt (padicNormE (HSub.hSub (↑f i) q)) ε","decl":"theorem complete'' : ∃ q : ℚ_[p], ∀ ε > 0, ∃ N, ∀ i ≥ N, padicNormE (f i - q : ℚ_[p]) < ε := by\n  obtain ⟨x, hx⟩ := complete' f\n  refine ⟨x, fun ε hε => ?_⟩\n  obtain ⟨N, hN⟩ := hx ε hε\n  refine ⟨N, fun i hi => ?_⟩\n  rw [padicNormE.map_sub]\n  exact hN i hi\n"}
{"name":"Padic.instIsUltrametricDist","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ IsUltrametricDist (Padic p)","decl":"instance : IsUltrametricDist ℚ_[p] :=\n  ⟨fun x y z ↦ by simpa [dist] using padicNormE.nonarchimedean' (x - y) (y - z)⟩\n\n"}
{"name":"Padic.isAbsoluteValue","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ IsAbsoluteValue fun a => Norm.norm a","decl":"instance isAbsoluteValue : IsAbsoluteValue fun a : ℚ_[p] ↦ ‖a‖ where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := norm_eq_zero\n  abv_add' := norm_add_le\n  abv_mul' := by simp [Norm.norm, map_mul]\n\n"}
{"name":"Padic.rat_dense","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nq : Padic p\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun r => LT.lt (Norm.norm (HSub.hSub q ↑r)) ε","decl":"theorem rat_dense (q : ℚ_[p]) {ε : ℝ} (hε : 0 < ε) : ∃ r : ℚ, ‖q - r‖ < ε :=\n  let ⟨ε', hε'l, hε'r⟩ := exists_rat_btwn hε\n  let ⟨r, hr⟩ := rat_dense' q (ε := ε') (by simpa using hε'l)\n  ⟨r, lt_trans (by simpa [Norm.norm] using hr) hε'r⟩\n\n"}
{"name":"padicNormE.mul","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Padic p\n⊢ Eq (Norm.norm (HMul.hMul q r)) (HMul.hMul (Norm.norm q) (Norm.norm r))","decl":"@[simp (high)]\nprotected theorem mul (q r : ℚ_[p]) : ‖q * r‖ = ‖q‖ * ‖r‖ := by simp [Norm.norm, map_mul]\n\n"}
{"name":"padicNormE.is_norm","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Padic p\n⊢ Eq (↑(padicNormE q)) (Norm.norm q)","decl":"protected theorem is_norm (q : ℚ_[p]) : ↑(padicNormE q) = ‖q‖ := rfl\n\n"}
{"name":"padicNormE.nonarchimedean","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Padic p\n⊢ LE.le (Norm.norm (HAdd.hAdd q r)) (Max.max (Norm.norm q) (Norm.norm r))","decl":"theorem nonarchimedean (q r : ℚ_[p]) : ‖q + r‖ ≤ max ‖q‖ ‖r‖ := by\n  dsimp [norm]\n  exact mod_cast nonarchimedean' _ _\n\n"}
{"name":"padicNormE.add_eq_max_of_ne","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Padic p\nh : Ne (Norm.norm q) (Norm.norm r)\n⊢ Eq (Norm.norm (HAdd.hAdd q r)) (Max.max (Norm.norm q) (Norm.norm r))","decl":"theorem add_eq_max_of_ne {q r : ℚ_[p]} (h : ‖q‖ ≠ ‖r‖) : ‖q + r‖ = max ‖q‖ ‖r‖ := by\n  dsimp [norm] at h ⊢\n  have : padicNormE q ≠ padicNormE r := mod_cast h\n  exact mod_cast add_eq_max_of_ne' this\n\n"}
{"name":"padicNormE.eq_padicNorm","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Rat\n⊢ Eq (Norm.norm ↑q) ↑(padicNorm p q)","decl":"@[simp]\ntheorem eq_padicNorm (q : ℚ) : ‖(q : ℚ_[p])‖ = padicNorm p q := by\n  dsimp [norm]\n  rw [← padicNormE.eq_padic_norm']\n\n"}
{"name":"padicNormE.norm_p","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (Norm.norm ↑p) (Inv.inv ↑p)","decl":"@[simp]\ntheorem norm_p : ‖(p : ℚ_[p])‖ = (p : ℝ)⁻¹ := by\n  rw [← @Rat.cast_natCast ℝ _ p]\n  rw [← @Rat.cast_natCast ℚ_[p] _ p]\n  simp [hp.1.ne_zero, hp.1.ne_one, norm, padicNorm, padicValRat, padicValInt, zpow_neg,\n    -Rat.cast_natCast]\n\n"}
{"name":"padicNormE.norm_p_lt_one","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ LT.lt (Norm.norm ↑p) 1","decl":"theorem norm_p_lt_one : ‖(p : ℚ_[p])‖ < 1 := by\n  rw [norm_p]\n  exact inv_lt_one_of_one_lt₀ <| mod_cast hp.1.one_lt\n\n-- Porting note: Linter thinks this is a duplicate simp lemma, so `priority` is assigned\n"}
{"name":"padicNormE.norm_p_zpow","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Int\n⊢ Eq (Norm.norm (HPow.hPow (↑p) n)) (HPow.hPow (↑p) (Neg.neg n))","decl":"@[simp (high)]\ntheorem norm_p_zpow (n : ℤ) : ‖(p : ℚ_[p]) ^ n‖ = (p : ℝ) ^ (-n) := by\n  rw [norm_zpow, norm_p, zpow_neg, inv_zpow]\n\n-- Porting note: Linter thinks this is a duplicate simp lemma, so `priority` is assigned\n"}
{"name":"padicNormE.norm_p_pow","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n⊢ Eq (Norm.norm (HPow.hPow (↑p) n)) (HPow.hPow (↑p) (Neg.neg ↑n))","decl":"@[simp (high)]\ntheorem norm_p_pow (n : ℕ) : ‖(p : ℚ_[p]) ^ n‖ = (p : ℝ) ^ (-n : ℤ) := by\n  rw [← norm_p_zpow, zpow_natCast]\n\n"}
{"name":"padicNormE.image","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Padic p\na✝ : Ne q 0\n⊢ Exists fun n => Eq (Norm.norm q) ↑(HPow.hPow (↑p) (Neg.neg n))","decl":"protected theorem image {q : ℚ_[p]} : q ≠ 0 → ∃ n : ℤ, ‖q‖ = ↑((p : ℚ) ^ (-n)) :=\n  Quotient.inductionOn q fun f hf ↦\n    have : ¬f ≈ 0 := (PadicSeq.ne_zero_iff_nequiv_zero f).1 hf\n    let ⟨n, hn⟩ := PadicSeq.norm_values_discrete f this\n    ⟨n, by rw [← hn]; rfl⟩\n\n"}
{"name":"padicNormE.is_rat","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Padic p\n⊢ Exists fun q' => Eq (Norm.norm q) ↑q'","decl":"protected theorem is_rat (q : ℚ_[p]) : ∃ q' : ℚ, ‖q‖ = q' := by\n  classical\n  exact if h : q = 0 then ⟨0, by simp [h]⟩\n  else\n    let ⟨n, hn⟩ := padicNormE.image h\n    ⟨_, hn⟩\n\n"}
{"name":"padicNormE.eq_ratNorm","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Padic p\n⊢ Eq (Norm.norm q) ↑(padicNormE.ratNorm q)","decl":"theorem eq_ratNorm (q : ℚ_[p]) : ‖q‖ = ratNorm q :=\n  Classical.choose_spec (padicNormE.is_rat q)\n\n"}
{"name":"padicNormE.norm_rat_le_one","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Rat\nx✝ : Not (Dvd.dvd p q.den)\n⊢ LE.le (Norm.norm ↑q) 1","decl":"theorem norm_rat_le_one : ∀ {q : ℚ} (_ : ¬p ∣ q.den), ‖(q : ℚ_[p])‖ ≤ 1\n  | ⟨n, d, hn, hd⟩ => fun hq : ¬p ∣ d ↦\n    if hnz : n = 0 then by\n      have : (⟨n, d, hn, hd⟩ : ℚ) = 0 := Rat.zero_iff_num_zero.mpr hnz\n      norm_num [this]\n    else by\n      have hnz' : (⟨n, d, hn, hd⟩ : ℚ) ≠ 0 := mt Rat.zero_iff_num_zero.1 hnz\n      rw [padicNormE.eq_padicNorm]\n      norm_cast\n      -- Porting note: `Nat.cast_zero` instead of another `norm_cast` call\n      rw [padicNorm.eq_zpow_of_nonzero hnz', padicValRat, neg_sub,\n        padicValNat.eq_zero_of_not_dvd hq, Nat.cast_zero, zero_sub, zpow_neg, zpow_natCast]\n      apply inv_le_one_of_one_le₀\n      norm_cast\n      apply one_le_pow\n      exact hp.1.pos\n\n"}
{"name":"padicNormE.norm_int_le_one","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : Int\n⊢ LE.le (Norm.norm ↑z) 1","decl":"theorem norm_int_le_one (z : ℤ) : ‖(z : ℚ_[p])‖ ≤ 1 :=\n  suffices ‖((z : ℚ) : ℚ_[p])‖ ≤ 1 by simpa\n  norm_rat_le_one <| by simp [hp.1.ne_one]\n\n"}
{"name":"padicNormE.norm_int_lt_one_iff_dvd","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Int\n⊢ Iff (LT.lt (Norm.norm ↑k) 1) (Dvd.dvd (↑p) k)","decl":"theorem norm_int_lt_one_iff_dvd (k : ℤ) : ‖(k : ℚ_[p])‖ < 1 ↔ ↑p ∣ k := by\n  constructor\n  · intro h\n    contrapose! h\n    apply le_of_eq\n    rw [eq_comm]\n    calc\n      ‖(k : ℚ_[p])‖ = ‖((k : ℚ) : ℚ_[p])‖ := by norm_cast\n      _ = padicNorm p k := padicNormE.eq_padicNorm _\n      _ = 1 := mod_cast (int_eq_one_iff k).mpr h\n  · rintro ⟨x, rfl⟩\n    push_cast\n    rw [padicNormE.mul]\n    calc\n      _ ≤ ‖(p : ℚ_[p])‖ * 1 :=\n        mul_le_mul le_rfl (by simpa using norm_int_le_one _) (norm_nonneg _) (norm_nonneg _)\n      _ < 1 := by\n        rw [mul_one, padicNormE.norm_p]\n        exact inv_lt_one_of_one_lt₀ <| mod_cast hp.1.one_lt\n\n"}
{"name":"padicNormE.norm_int_le_pow_iff_dvd","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Int\nn : Nat\n⊢ Iff (LE.le (Norm.norm ↑k) (HPow.hPow (↑p) (Neg.neg ↑n))) (Dvd.dvd (HPow.hPow (↑p) n) k)","decl":"theorem norm_int_le_pow_iff_dvd (k : ℤ) (n : ℕ) :\n    ‖(k : ℚ_[p])‖ ≤ (p : ℝ) ^ (-n : ℤ) ↔ (p ^ n : ℤ) ∣ k := by\n  have : (p : ℝ) ^ (-n : ℤ) = (p : ℚ) ^ (-n : ℤ) := by simp\n  rw [show (k : ℚ_[p]) = ((k : ℚ) : ℚ_[p]) by norm_cast, eq_padicNorm, this]\n  norm_cast\n  rw [← padicNorm.dvd_iff_norm_le]\n\n"}
{"name":"padicNormE.eq_of_norm_add_lt_right","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : Padic p\nh : LT.lt (Norm.norm (HAdd.hAdd z1 z2)) (Norm.norm z2)\n⊢ Eq (Norm.norm z1) (Norm.norm z2)","decl":"theorem eq_of_norm_add_lt_right {z1 z2 : ℚ_[p]} (h : ‖z1 + z2‖ < ‖z2‖) : ‖z1‖ = ‖z2‖ :=\n  _root_.by_contradiction fun hne ↦\n    not_lt_of_ge (by rw [padicNormE.add_eq_max_of_ne hne]; apply le_max_right) h\n\n"}
{"name":"padicNormE.eq_of_norm_add_lt_left","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : Padic p\nh : LT.lt (Norm.norm (HAdd.hAdd z1 z2)) (Norm.norm z1)\n⊢ Eq (Norm.norm z1) (Norm.norm z2)","decl":"theorem eq_of_norm_add_lt_left {z1 z2 : ℚ_[p]} (h : ‖z1 + z2‖ < ‖z1‖) : ‖z1‖ = ‖z2‖ :=\n  _root_.by_contradiction fun hne ↦\n    not_lt_of_ge (by rw [padicNormE.add_eq_max_of_ne hne]; apply le_max_left) h\n\n"}
{"name":"Padic.complete","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ CauSeq.IsComplete (Padic p) Norm.norm","decl":"instance complete : CauSeq.IsComplete ℚ_[p] norm where\n  isComplete f := by\n    have cau_seq_norm_e : IsCauSeq padicNormE f := fun ε hε => by\n      have h := isCauSeq f ε (mod_cast hε)\n      dsimp [norm] at h\n      exact mod_cast h\n    -- Porting note: Padic.complete' works with `f i - q`, but the goal needs `q - f i`,\n    -- using `rewrite [padicNormE.map_sub]` causes time out, so a separate lemma is created\n    cases' Padic.complete'' ⟨f, cau_seq_norm_e⟩ with q hq\n    exists q\n    intro ε hε\n    cases' exists_rat_btwn hε with ε' hε'\n    norm_cast at hε'\n    cases' hq ε' hε'.1 with N hN\n    exists N\n    intro i hi\n    have h := hN i hi\n    change norm (f i - q) < ε\n    refine lt_trans ?_ hε'.2\n    dsimp [norm]\n    exact mod_cast h\n\n"}
{"name":"Padic.padicNormE_lim_le","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nf : CauSeq (Padic p) Norm.norm\na : Real\nha : LT.lt 0 a\nhf : ∀ (i : Nat), LE.le (Norm.norm (↑f i)) a\n⊢ LE.le (Norm.norm f.lim) a","decl":"theorem padicNormE_lim_le {f : CauSeq ℚ_[p] norm} {a : ℝ} (ha : 0 < a) (hf : ∀ i, ‖f i‖ ≤ a) :\n    ‖f.lim‖ ≤ a := by\n  obtain ⟨N, hN⟩ := Setoid.symm (CauSeq.equiv_lim f) _ ha\n  calc\n    ‖f.lim‖ = ‖f.lim - f N + f N‖ := by simp\n    _ ≤ max ‖f.lim - f N‖ ‖f N‖ := padicNormE.nonarchimedean _ _\n    _ ≤ a := max_le (le_of_lt (hN _ le_rfl)) (hf _)\n\n"}
{"name":"Padic.instCompleteSpace","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ CompleteSpace (Padic p)","decl":"instance : CompleteSpace ℚ_[p] := by\n  apply complete_of_cauchySeq_tendsto\n  intro u hu\n  let c : CauSeq ℚ_[p] norm := ⟨u, Metric.cauchySeq_iff'.mp hu⟩\n  refine ⟨c.lim, fun s h ↦ ?_⟩\n  rcases Metric.mem_nhds_iff.1 h with ⟨ε, ε0, hε⟩\n  have := c.equiv_lim ε ε0\n  simp only [mem_map, mem_atTop_sets, mem_setOf_eq]\n  exact this.imp fun N hN n hn ↦ hε (hN n hn)\n\n"}
{"name":"Padic.valuation_zero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (Padic.valuation 0) 0","decl":"@[simp]\ntheorem valuation_zero : valuation (0 : ℚ_[p]) = 0 :=\n  dif_pos ((const_equiv p).2 rfl)\n\n"}
{"name":"Padic.norm_eq_zpow_neg_valuation","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : Padic p\na✝ : Ne x 0\n⊢ Eq (Norm.norm x) (HPow.hPow (↑p) (Neg.neg x.valuation))","decl":"theorem norm_eq_zpow_neg_valuation {x : ℚ_[p]} : x ≠ 0 → ‖x‖ = (p : ℝ) ^ (-x.valuation) := by\n  refine Quotient.inductionOn' x fun f hf => ?_\n  change (PadicSeq.norm _ : ℝ) = (p : ℝ) ^ (-PadicSeq.valuation _)\n  rw [PadicSeq.norm_eq_zpow_neg_valuation]\n  · rw [Rat.cast_zpow, Rat.cast_natCast]\n  · apply CauSeq.not_limZero_of_not_congr_zero\n    -- Porting note: was `contrapose! hf`\n    intro hf'\n    apply hf\n    apply Quotient.sound\n    simpa using hf'\n\n"}
{"name":"Padic.valuation_ratCast","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Rat\n⊢ Eq (↑q).valuation (padicValRat p q)","decl":"@[simp]\nlemma valuation_ratCast (q : ℚ) : valuation (q : ℚ_[p]) = padicValRat p q := by\n  rcases eq_or_ne q 0 with rfl | hq\n  · simp only [Rat.cast_zero, valuation_zero, padicValRat.zero]\n  refine neg_injective ((zpow_right_strictMono₀ (mod_cast hp.out.one_lt)).injective\n    <| (norm_eq_zpow_neg_valuation (mod_cast hq)).symm.trans ?_)\n  rw [padicNormE.eq_padicNorm, ← Rat.cast_natCast, ← Rat.cast_zpow, Rat.cast_inj]\n  exact padicNorm.eq_zpow_of_nonzero hq\n\n"}
{"name":"Padic.valuation_intCast","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Int\n⊢ Eq (↑n).valuation ↑(padicValInt p n)","decl":"@[simp]\nlemma valuation_intCast (n : ℤ) : valuation (n : ℚ_[p]) = padicValInt p n := by\n  rw [← Rat.cast_intCast, valuation_ratCast, padicValRat.of_int]\n\n"}
{"name":"Padic.valuation_natCast","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n⊢ Eq (↑n).valuation ↑(padicValNat p n)","decl":"@[simp]\nlemma valuation_natCast (n : ℕ) : valuation (n : ℚ_[p]) = padicValNat p n := by\n  rw [← Rat.cast_natCast, valuation_ratCast, padicValRat.of_nat]\n\n"}
{"name":"Padic.valuation_ofNat","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).valuation ↑(padicValNat p n)","decl":"@[simp]\nlemma valuation_ofNat (n : ℕ) [n.AtLeastTwo] :\n    valuation (ofNat(n) : ℚ_[p]) = padicValNat p n :=\n  valuation_natCast n\n\n"}
{"name":"Padic.valuation_one","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (Padic.valuation 1) 0","decl":"@[simp]\nlemma valuation_one : valuation (1 : ℚ_[p]) = 0 := by\n  rw [← Nat.cast_one, valuation_natCast, padicValNat.one, cast_zero]\n\n-- not @[simp], since simp can prove it\n"}
{"name":"Padic.valuation_p","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (↑p).valuation 1","decl":"lemma valuation_p : valuation (p : ℚ_[p]) = 1 := by\n  rw [valuation_natCast, padicValNat_self, cast_one]\n\n"}
{"name":"Padic.le_valuation_add","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx y : Padic p\nhxy : Ne (HAdd.hAdd x y) 0\n⊢ LE.le (Min.min x.valuation y.valuation) (HAdd.hAdd x y).valuation","decl":"theorem le_valuation_add {x y : ℚ_[p]} (hxy : x + y ≠ 0) :\n    min x.valuation y.valuation ≤ (x + y).valuation := by\n  by_cases hx : x = 0\n  · simpa only [hx, zero_add] using min_le_right _ _\n  by_cases hy : y = 0\n  · simpa only [hy, add_zero] using min_le_left _ _\n  have : ‖x + y‖ ≤ max ‖x‖ ‖y‖ := padicNormE.nonarchimedean x y\n  simpa only [norm_eq_zpow_neg_valuation hxy, norm_eq_zpow_neg_valuation hx,\n    norm_eq_zpow_neg_valuation hy, le_max_iff,\n    zpow_le_zpow_iff_right₀ (mod_cast hp.out.one_lt : 1 < (p : ℝ)), neg_le_neg_iff, ← min_le_iff]\n\n"}
{"name":"Padic.valuation_mul","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx y : Padic p\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (HMul.hMul x y).valuation (HAdd.hAdd x.valuation y.valuation)","decl":"@[simp]\nlemma valuation_mul {x y : ℚ_[p]} (hx : x ≠ 0) (hy : y ≠ 0) :\n    (x * y).valuation = x.valuation + y.valuation := by\n  have h_norm : ‖x * y‖ = ‖x‖ * ‖y‖ := norm_mul x y\n  have hp_ne_one : (p : ℝ) ≠ 1 := mod_cast (Fact.out : p.Prime).ne_one\n  have hp_pos : (0 : ℝ) < p := mod_cast NeZero.pos _\n  rwa [norm_eq_zpow_neg_valuation hx, norm_eq_zpow_neg_valuation hy,\n    norm_eq_zpow_neg_valuation (mul_ne_zero hx hy), ← zpow_add₀ hp_pos.ne',\n    zpow_right_inj₀ hp_pos hp_ne_one, ← neg_add, neg_inj] at h_norm\n\n"}
{"name":"Padic.valuation_inv","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : Padic p\n⊢ Eq (Inv.inv x).valuation (Neg.neg x.valuation)","decl":"@[simp]\nlemma valuation_inv (x : ℚ_[p]) : x⁻¹.valuation = -x.valuation := by\n  obtain rfl | hx := eq_or_ne x 0\n  · simp\n  have h_norm : ‖x⁻¹‖ = ‖x‖⁻¹ := norm_inv x\n  have hp_ne_one : (p : ℝ) ≠ 1 := mod_cast (Fact.out : p.Prime).ne_one\n  have hp_pos : (0 : ℝ) < p := mod_cast NeZero.pos _\n  rwa [norm_eq_zpow_neg_valuation hx, norm_eq_zpow_neg_valuation <| inv_ne_zero hx,\n    ← zpow_neg, zpow_right_inj₀ hp_pos hp_ne_one, neg_inj] at h_norm\n\n"}
{"name":"Padic.valuation_pow","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : Padic p\nn : Nat\n⊢ Eq (HPow.hPow x n).valuation (HMul.hMul (↑n) x.valuation)","decl":"@[simp]\nlemma valuation_pow (x : ℚ_[p]) : ∀ n : ℕ, (x ^ n).valuation = n * x.valuation\n  | 0 => by simp\n  | n + 1 => by\n    obtain rfl | hx := eq_or_ne x 0\n    · simp\n    · simp [pow_succ, hx, valuation_mul, valuation_pow, _root_.add_one_mul]\n\n"}
{"name":"Padic.valuation_zpow","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : Padic p\nn : Int\n⊢ Eq (HPow.hPow x n).valuation (HMul.hMul n x.valuation)","decl":"@[simp]\nlemma valuation_zpow (x : ℚ_[p]) : ∀ n : ℤ, (x ^ n).valuation = n * x.valuation\n  | (n : ℕ) => by simp\n  | .negSucc n => by simp [← neg_mul]; simp [Int.negSucc_eq]\n\n"}
{"name":"Padic.valuation_map_add","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx y : Padic p\nhxy : Ne (HAdd.hAdd x y) 0\n⊢ LE.le (Min.min x.valuation y.valuation) (HAdd.hAdd x y).valuation","decl":"@[deprecated (since := \"2024-12-10\")] alias valuation_map_add := le_valuation_add\n"}
{"name":"Padic.valuation_map_mul","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx y : Padic p\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (HMul.hMul x y).valuation (HAdd.hAdd x.valuation y.valuation)","decl":"@[deprecated (since := \"2024-12-10\")] alias valuation_map_mul := valuation_mul\n\n"}
{"name":"Padic.AddValuation.map_zero","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (Padic.addValuationDef 0) Top.top","decl":"@[simp]\ntheorem AddValuation.map_zero : addValuationDef (0 : ℚ_[p]) = ⊤ := by\n  rw [addValuationDef, if_pos rfl]\n\n"}
{"name":"Padic.AddValuation.map_one","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (Padic.addValuationDef 1) 0","decl":"@[simp]\ntheorem AddValuation.map_one : addValuationDef (1 : ℚ_[p]) = 0 := by\n  rw [addValuationDef, if_neg one_ne_zero, valuation_one, WithTop.coe_zero]\n\n"}
{"name":"Padic.AddValuation.map_mul","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx y : Padic p\n⊢ Eq (HMul.hMul x y).addValuationDef (HAdd.hAdd x.addValuationDef y.addValuationDef)","decl":"theorem AddValuation.map_mul (x y : ℚ_[p]) :\n    addValuationDef (x * y : ℚ_[p]) = addValuationDef x + addValuationDef y := by\n  simp only [addValuationDef]\n  by_cases hx : x = 0\n  · rw [hx, if_pos rfl, zero_mul, if_pos rfl, WithTop.top_add]\n  · by_cases hy : y = 0\n    · rw [hy, if_pos rfl, mul_zero, if_pos rfl, WithTop.add_top]\n    · rw [if_neg hx, if_neg hy, if_neg (mul_ne_zero hx hy), ← WithTop.coe_add, WithTop.coe_eq_coe,\n        valuation_mul hx hy]\n\n"}
{"name":"Padic.AddValuation.map_add","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx y : Padic p\n⊢ LE.le (Min.min x.addValuationDef y.addValuationDef) (HAdd.hAdd x y).addValuationDef","decl":"theorem AddValuation.map_add (x y : ℚ_[p]) :\n    min (addValuationDef x) (addValuationDef y) ≤ addValuationDef (x + y : ℚ_[p]) := by\n  simp only [addValuationDef]\n  by_cases hxy : x + y = 0\n  · rw [hxy, if_pos rfl]\n    exact le_top\n  · by_cases hx : x = 0\n    · rw [hx, if_pos rfl, min_eq_right, zero_add]\n      exact le_top\n    · by_cases hy : y = 0\n      · rw [hy, if_pos rfl, min_eq_left, add_zero]\n        exact le_top\n      · rw [if_neg hx, if_neg hy, if_neg hxy, ← WithTop.coe_min, WithTop.coe_le_coe]\n        exact le_valuation_add hxy\n\n"}
{"name":"Padic.addValuation.apply","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : Padic p\nhx : Ne x 0\n⊢ Eq (Padic.addValuation x) ↑x.valuation","decl":"@[simp]\ntheorem addValuation.apply {x : ℚ_[p]} (hx : x ≠ 0) :\n    Padic.addValuation x = (x.valuation : WithTop ℤ) := by\n  simp only [Padic.addValuation, AddValuation.of_apply, addValuationDef, if_neg hx]\n\n"}
{"name":"Padic.norm_le_pow_iff_norm_lt_pow_add_one","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : Padic p\nn : Int\n⊢ Iff (LE.le (Norm.norm x) (HPow.hPow (↑p) n)) (LT.lt (Norm.norm x) (HPow.hPow (↑p) (HAdd.hAdd n 1)))","decl":"theorem norm_le_pow_iff_norm_lt_pow_add_one (x : ℚ_[p]) (n : ℤ) :\n    ‖x‖ ≤ (p : ℝ) ^ n ↔ ‖x‖ < (p : ℝ) ^ (n + 1) := by\n  have aux (n : ℤ) : 0 < ((p : ℝ) ^ n) := zpow_pos (mod_cast hp.1.pos) _\n  by_cases hx0 : x = 0\n  · simp [hx0, norm_zero, aux, le_of_lt (aux _)]\n  rw [norm_eq_zpow_neg_valuation hx0]\n  have h1p : 1 < (p : ℝ) := mod_cast hp.1.one_lt\n  have H := zpow_right_strictMono₀ h1p\n  rw [H.le_iff_le, H.lt_iff_lt, Int.lt_add_one_iff]\n\n"}
{"name":"Padic.norm_lt_pow_iff_norm_le_pow_sub_one","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : Padic p\nn : Int\n⊢ Iff (LT.lt (Norm.norm x) (HPow.hPow (↑p) n)) (LE.le (Norm.norm x) (HPow.hPow (↑p) (HSub.hSub n 1)))","decl":"theorem norm_lt_pow_iff_norm_le_pow_sub_one (x : ℚ_[p]) (n : ℤ) :\n    ‖x‖ < (p : ℝ) ^ n ↔ ‖x‖ ≤ (p : ℝ) ^ (n - 1) := by\n  rw [norm_le_pow_iff_norm_lt_pow_add_one, sub_add_cancel]\n\n"}
{"name":"Padic.norm_le_one_iff_val_nonneg","module":"Mathlib.NumberTheory.Padics.PadicNumbers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : Padic p\n⊢ Iff (LE.le (Norm.norm x) 1) (LE.le 0 x.valuation)","decl":"theorem norm_le_one_iff_val_nonneg (x : ℚ_[p]) : ‖x‖ ≤ 1 ↔ 0 ≤ x.valuation := by\n  by_cases hx : x = 0\n  · simp only [hx, norm_zero, valuation_zero, zero_le_one, le_refl]\n  · rw [norm_eq_zpow_neg_valuation hx, ← zpow_zero (p : ℝ), zpow_le_zpow_iff_right₀, neg_nonpos]\n    exact Nat.one_lt_cast.2 (Nat.Prime.one_lt' p).1\n\n"}
