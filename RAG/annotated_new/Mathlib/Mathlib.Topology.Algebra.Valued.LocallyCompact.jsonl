{"name":"NormedField.v_eq_valuation","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ¹ : NontriviallyNormedField K\ninstâœ : IsUltrametricDist K\nx : K\nâŠ¢ Eq (Valued.v x) (NormedField.valuation x)","decl":"@[simp]\nlemma NormedField.v_eq_valuation (x : K) : Valued.v x = NormedField.valuation x := rfl\n\n"}
{"name":"Valued.integer.mem_iff","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ¹ : NontriviallyNormedField K\ninstâœ : IsUltrametricDist K\nx : K\nâŠ¢ Iff (Membership.mem (Valued.integer K) x) (LE.le (Norm.norm x) 1)","decl":"/-- An element is in the valuation ring if the norm is bounded by 1. This is a variant of\n`Valuation.mem_integer_iff`, phrased using norms instead of the valuation. -/\nlemma mem_iff {x : K} : x âˆˆ ğ’ª[K] â†” â€–xâ€– â‰¤ 1 := by\n  simp [Valuation.mem_integer_iff, â† NNReal.coe_le_coe]\n\n"}
{"name":"Valued.integer.norm_le_one","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ¹ : NontriviallyNormedField K\ninstâœ : IsUltrametricDist K\nx : Subtype fun x => Membership.mem (Valued.integer K) x\nâŠ¢ LE.le (Norm.norm x) 1","decl":"lemma norm_le_one (x : ğ’ª[K]) : â€–xâ€– â‰¤ 1 := mem_iff.mp x.prop\n\n"}
{"name":"Valued.integer.norm_coe_unit","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ¹ : NontriviallyNormedField K\ninstâœ : IsUltrametricDist K\nu : Units (Subtype fun x => Membership.mem (Valued.integer K) x)\nâŠ¢ Eq (Norm.norm â†‘â†‘u) 1","decl":"@[simp]\nlemma norm_coe_unit (u : ğ’ª[K]Ë£) : â€–((u : ğ’ª[K]) : K)â€– = 1 := by\n  simpa [â† NNReal.coe_inj] using\n    (Valuation.integer.integers (NormedField.valuation (K := K))).valuation_unit u\n\n"}
{"name":"Valued.integer.norm_unit","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ¹ : NontriviallyNormedField K\ninstâœ : IsUltrametricDist K\nu : Units (Subtype fun x => Membership.mem (Valued.integer K) x)\nâŠ¢ Eq (Norm.norm â†‘u) 1","decl":"lemma norm_unit (u : ğ’ª[K]Ë£) : â€–(u : ğ’ª[K])â€– = 1 := by\n  simp\n\n"}
{"name":"Valued.integer.isUnit_iff_norm_eq_one","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ¹ : NontriviallyNormedField K\ninstâœ : IsUltrametricDist K\nu : Subtype fun x => Membership.mem (Valued.integer K) x\nâŠ¢ Iff (IsUnit u) (Eq (Norm.norm u) 1)","decl":"lemma isUnit_iff_norm_eq_one {u : ğ’ª[K]} : IsUnit u â†” â€–uâ€– = 1 := by\n  simpa [â† NNReal.coe_inj] using\n    (Valuation.integer.integers (NormedField.valuation (K := K))).isUnit_iff_valuation_eq_one\n\n"}
{"name":"Valued.integer.norm_irreducible_lt_one","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ¹ : NontriviallyNormedField K\ninstâœ : IsUltrametricDist K\nÏ– : Subtype fun x => Membership.mem (Valued.integer K) x\nh : Irreducible Ï–\nâŠ¢ LT.lt (Norm.norm Ï–) 1","decl":"lemma norm_irreducible_lt_one {Ï– : ğ’ª[K]} (h : Irreducible Ï–) : â€–Ï–â€– < 1 :=\n  lt_of_le_of_ne (norm_le_one Ï–) (mt isUnit_iff_norm_eq_one.mpr h.not_unit)\n\n"}
{"name":"Valued.integer.norm_irreducible_pos","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ¹ : NontriviallyNormedField K\ninstâœ : IsUltrametricDist K\nÏ– : Subtype fun x => Membership.mem (Valued.integer K) x\nh : Irreducible Ï–\nâŠ¢ LT.lt 0 (Norm.norm Ï–)","decl":"lemma norm_irreducible_pos {Ï– : ğ’ª[K]} (h : Irreducible Ï–) : 0 < â€–Ï–â€– :=\n  lt_of_le_of_ne (_root_.norm_nonneg Ï–) (by simp [eq_comm, h.ne_zero])\n\n"}
{"name":"Valued.integer.coe_span_singleton_eq_closedBall","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ¹ : NontriviallyNormedField K\ninstâœ : IsUltrametricDist K\nx : Subtype fun x => Membership.mem (Valued.integer K) x\nâŠ¢ Eq (â†‘(Ideal.span (Singleton.singleton x))) (Metric.closedBall 0 (Norm.norm x))","decl":"lemma coe_span_singleton_eq_closedBall (x : ğ’ª[K]) :\n    (Ideal.span {x} : Set ğ’ª[K]) = Metric.closedBall 0 â€–xâ€– := by\n  rcases eq_or_ne x 0 with rfl|hx\n  Â· simp [Set.singleton_zero, Ideal.span_zero]\n  ext y\n  simp only [SetLike.mem_coe, Ideal.mem_span_singleton', AddSubgroupClass.coe_norm,\n    Metric.mem_closedBall, dist_zero_right]\n  constructor\n  Â· rintro âŸ¨z, rflâŸ©\n    simpa using mul_le_mul_of_nonneg_right (norm_le_one z) (_root_.norm_nonneg x)\n  Â· intro h\n    refine âŸ¨âŸ¨y / x, ?_âŸ©, ?_âŸ©\n    Â· simpa [mem_iff] using div_le_one_of_leâ‚€ h (_root_.norm_nonneg _)\n    Â· simpa only [Subtype.ext_iff] using div_mul_cancelâ‚€ (y : K) (by simpa using hx)\n\n"}
{"name":"Irreducible.maximalIdeal_eq_closedBall","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ² : NontriviallyNormedField K\ninstâœÂ¹ : IsUltrametricDist K\ninstâœ : IsDiscreteValuationRing (Subtype fun x => Membership.mem (Valued.integer K) x)\nÏ– : Subtype fun x => Membership.mem (Valued.integer K) x\nh : Irreducible Ï–\nâŠ¢ Eq (â†‘(Valued.maximalIdeal K)) (Metric.closedBall 0 (Norm.norm Ï–))","decl":"lemma _root_.Irreducible.maximalIdeal_eq_closedBall [IsDiscreteValuationRing ğ’ª[K]]\n    {Ï– : ğ’ª[K]} (h : Irreducible Ï–) :\n    (ğ“‚[K] : Set ğ’ª[K]) = Metric.closedBall 0 â€–Ï–â€– := by\n  rw [â† coe_span_singleton_eq_closedBall, â† h.maximalIdeal_eq]\n\n"}
{"name":"Irreducible.maximalIdeal_pow_eq_closedBall_pow","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_1\ninstâœÂ² : NontriviallyNormedField K\ninstâœÂ¹ : IsUltrametricDist K\ninstâœ : IsDiscreteValuationRing (Subtype fun x => Membership.mem (Valued.integer K) x)\nÏ– : Subtype fun x => Membership.mem (Valued.integer K) x\nh : Irreducible Ï–\nn : Nat\nâŠ¢ Eq (â†‘(HPow.hPow (Valued.maximalIdeal K) n)) (Metric.closedBall 0 (HPow.hPow (Norm.norm Ï–) n))","decl":"lemma _root_.Irreducible.maximalIdeal_pow_eq_closedBall_pow [IsDiscreteValuationRing ğ’ª[K]]\n    {Ï– : ğ’ª[K]} (h : Irreducible Ï–) (n : â„•) :\n    ((ğ“‚[K] ^ n : Ideal ğ’ª[K]) : Set ğ’ª[K]) = Metric.closedBall 0 (â€–Ï–â€– ^ n) := by\n  have : â€–Ï–â€– ^ n = â€–Ï– ^ nâ€– := by simp\n  rw [this, â† coe_span_singleton_eq_closedBall, â† Ideal.span_singleton_pow, â† h.maximalIdeal_eq]\n\n"}
{"name":"Valued.integer.finite_quotient_maximalIdeal_pow_of_finite_residueField","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_2\ninstâœÂ² : NontriviallyNormedField K\ninstâœÂ¹ : IsUltrametricDist K\ninstâœ : IsDiscreteValuationRing (Subtype fun x => Membership.mem (Valued.integer K) x)\nh : Finite (Valued.ResidueField K)\nn : Nat\nâŠ¢ Finite (HasQuotient.Quotient (Subtype fun x => Membership.mem (Valued.integer K) x) (HPow.hPow (Valued.maximalIdeal K) n))","decl":"lemma finite_quotient_maximalIdeal_pow_of_finite_residueField [IsDiscreteValuationRing ğ’ª[K]]\n    (h : Finite ğ“€[K]) (n : â„•) :\n    Finite (ğ’ª[K] â§¸ ğ“‚[K] ^ n) := by\n  induction n with\n  | zero =>\n    simp only [pow_zero, Ideal.one_eq_top]\n    exact Finite.of_fintype (â†¥ğ’ª[K] â§¸ âŠ¤)\n  | succ n ih =>\n    have : ğ“‚[K] ^ (n + 1) â‰¤ ğ“‚[K] ^ n := Ideal.pow_le_pow_right (by simp)\n    replace ih := Finite.of_equiv _ (DoubleQuot.quotQuotEquivQuotOfLE this).symm.toEquiv\n    suffices Finite (Ideal.map (Ideal.Quotient.mk (ğ“‚[K] ^ (n + 1))) (ğ“‚[K] ^ n)) from\n      Finite.of_finite_quot_finite_ideal\n        (I := Ideal.map (Ideal.Quotient.mk _) (ğ“‚[K] ^ n))\n    exact @Finite.of_equiv _ _ h\n      ((Ideal.quotEquivPowQuotPowSuccEquiv (IsPrincipalIdealRing.principal ğ“‚[K])\n        (IsDiscreteValuationRing.not_a_field _) n).trans\n        (Ideal.powQuotPowSuccEquivMapMkPowSuccPow _ n))\n\n"}
{"name":"Valued.integer.totallyBounded_iff_finite_residueField","module":"Mathlib.Topology.Algebra.Valued.LocallyCompact","initialProofState":"K : Type u_2\ninstâœÂ² : NontriviallyNormedField K\ninstâœÂ¹ : IsUltrametricDist K\ninstâœ : IsDiscreteValuationRing (Subtype fun x => Membership.mem (Valued.integer K) x)\nâŠ¢ Iff (TotallyBounded Set.univ) (Finite (Valued.ResidueField K))","decl":"lemma totallyBounded_iff_finite_residueField [IsDiscreteValuationRing ğ’ª[K]] :\n    TotallyBounded (Set.univ (Î± := ğ’ª[K])) â†” Finite ğ“€[K] := by\n  constructor\n  Â· intro H\n    obtain âŸ¨p, hpâŸ© := IsDiscreteValuationRing.exists_irreducible ğ’ª[K]\n    have := Metric.finite_approx_of_totallyBounded H â€–pâ€– (norm_pos_iff.mpr hp.ne_zero)\n    simp only [Set.subset_univ, Set.univ_subset_iff, true_and] at this\n    obtain âŸ¨t, ht, ht'âŸ© := this\n    rw [â† Set.finite_univ_iff]\n    refine (ht.image (IsLocalRing.residue _)).subset ?_\n    rintro âŸ¨xâŸ©\n    replace ht' := ht'.ge (Set.mem_univ x)\n    simp only [Set.mem_iUnion, Metric.mem_ball, exists_prop] at ht'\n    obtain âŸ¨y, hy, hy'âŸ© := ht'\n    simp only [Submodule.Quotient.quot_mk_eq_mk, Ideal.Quotient.mk_eq_mk, Set.mem_univ,\n      IsLocalRing.residue, Set.mem_image, true_implies]\n    refine âŸ¨y, hy, ?_âŸ©\n    convert (Ideal.Quotient.mk_eq_mk_iff_sub_mem (I := ğ“‚[K]) y x).mpr _\n    -- TODO: make Valued.maximalIdeal abbreviations instead of def\n    rw [Valued.maximalIdeal, hp.maximalIdeal_eq, â† SetLike.mem_coe,\n      coe_span_singleton_eq_closedBall]\n    rw [dist_comm] at hy'\n    simpa [dist_eq_norm] using hy'.le\n  Â· intro H\n    rw [Metric.totallyBounded_iff]\n    intro Îµ Îµpos\n    obtain âŸ¨p, hpâŸ© := IsDiscreteValuationRing.exists_irreducible ğ’ª[K]\n    have hp' := norm_irreducible_lt_one hp\n    obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, â€–pâ€– ^ n < Îµ := exists_pow_lt_of_lt_one Îµpos hp'\n    have hF := finite_quotient_maximalIdeal_pow_of_finite_residueField H n\n    refine âŸ¨Quotient.out '' (Set.univ (Î± := ğ’ª[K] â§¸ (ğ“‚[K] ^ n))), Set.toFinite _, ?_âŸ©\n    simp only [Ideal.univ_eq_iUnion_image_add (ğ“‚[K] ^ n), hp.maximalIdeal_pow_eq_closedBall_pow,\n      AddSubgroupClass.coe_norm, Set.image_add_left, preimage_add_closedBall, sub_neg_eq_add,\n      zero_add, Set.image_univ, Set.mem_range, Set.iUnion_exists, Set.iUnion_iUnion_eq',\n      Set.iUnion_subset_iff, Metric.vadd_closedBall, vadd_eq_add, add_zero]\n    intro\n    exact (Metric.closedBall_subset_ball hn).trans (Set.subset_iUnion_of_subset _ le_rfl)\n\n"}
