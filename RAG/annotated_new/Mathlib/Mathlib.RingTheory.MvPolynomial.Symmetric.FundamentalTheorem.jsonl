{"name":"Fin.accumulate_apply","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"n m : Nat\nt : Fin n → Nat\nj : Fin m\n⊢ Eq ((Fin.accumulate n m) t j) ((Finset.filter (fun i => LE.le ↑j ↑i) Finset.univ).sum fun i => t i)","decl":"/-- The `j`th entry of `accumulate n m t` is the sum of `t i` over all `i ≥ j`. -/\n@[simps] def accumulate (n m : ℕ) : (Fin n → ℕ) →+ (Fin m → ℕ) where\n  toFun t j := ∑ i : Fin n with j.val ≤ i.val, t i\n  map_zero' := funext <| fun _ ↦ sum_eq_zero <| fun _ _ ↦ rfl\n  map_add' t₁ t₂ := funext <| fun j ↦ by dsimp only; exact sum_add_distrib\n\n"}
{"name":"Fin.accumulate_rec","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"i n m : Nat\nhin : LT.lt i n\nhim : LT.lt (HAdd.hAdd i 1) m\nt : Fin n → Nat\n⊢ Eq ((Fin.accumulate n m) t ⟨i, ⋯⟩) (HAdd.hAdd (t ⟨i, hin⟩) ((Fin.accumulate n m) t ⟨HAdd.hAdd i 1, him⟩))","decl":"lemma accumulate_rec {i n m : ℕ} (hin : i < n) (him : i + 1 < m) (t : Fin n → ℕ) :\n    accumulate n m t ⟨i, Nat.lt_of_succ_lt him⟩ = t ⟨i, hin⟩ + accumulate n m t ⟨i + 1, him⟩ := by\n  simp_rw [accumulate_apply]\n  convert (add_sum_erase _ _ _).symm\n  · ext\n    rw [mem_erase]\n    simp_rw [mem_filter, mem_univ, true_and, i.succ_le_iff, lt_iff_le_and_ne]\n    rw [and_comm, ne_comm, ← Fin.val_ne_iff]\n  · exact mem_filter.2 ⟨mem_univ _, le_rfl⟩\n\n"}
{"name":"Fin.accumulate_last","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"i n m : Nat\nhin : LT.lt i n\nhmi : Eq m (HAdd.hAdd i 1)\nt : Fin n → Nat\nht : ∀ (j : Fin n), LE.le m ↑j → Eq (t j) 0\n⊢ Eq ((Fin.accumulate n m) t ⟨i, ⋯⟩) (t ⟨i, hin⟩)","decl":"lemma accumulate_last {i n m : ℕ} (hin : i < n) (hmi : m = i + 1) (t : Fin n → ℕ)\n    (ht : ∀ j : Fin n, m ≤ j → t j = 0) :\n    accumulate n m t ⟨i, i.lt_succ_self.trans_eq hmi.symm⟩ = t ⟨i, hin⟩ := by\n  rw [accumulate_apply]\n  apply sum_eq_single_of_mem\n  · rw [mem_filter]; exact ⟨mem_univ _, le_rfl⟩\n  refine fun j hij hji ↦ ht j ?_\n  simp_rw [mem_filter, mem_univ, true_and] at hij\n  exact hmi.trans_le (hij.lt_of_ne (Fin.val_ne_iff.2 hji).symm).nat_succ_le\n\n"}
{"name":"Fin.accumulate_injective","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"n m : Nat\nhnm : LE.le n m\n⊢ Function.Injective ⇑(Fin.accumulate n m)","decl":"lemma accumulate_injective {n m} (hnm : n ≤ m) : Function.Injective (accumulate n m) := by\n  refine fun t s he ↦ funext fun i ↦ ?_\n  obtain h|h := lt_or_le (i.1 + 1) m\n  · have := accumulate_rec i.2 h s\n    rwa [← he, accumulate_rec i.2 h t, add_right_cancel_iff] at this\n  · have := h.antisymm (i.2.nat_succ_le.trans hnm)\n    rw [← accumulate_last i.2 this t, ← accumulate_last i.2 this s, he]\n    iterate 2 { intro j hj; exact ((j.2.trans_le hnm).not_le hj).elim }\n\n"}
{"name":"Fin.accumulate_invAccumulate","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"n m : Nat\nhmn : LE.le m n\ns : Fin m → Nat\nhs : Antitone s\n⊢ Eq ((Fin.accumulate n m) (Fin.invAccumulate n m s)) s","decl":"lemma accumulate_invAccumulate {n m} (hmn : m ≤ n) {s : Fin m → ℕ} (hs : Antitone s) :\n    accumulate n m (invAccumulate n m s) = s := funext <| fun ⟨i, hi⟩ ↦ by\n  have := Nat.le_sub_one_of_lt hi\n  revert hi\n  refine Nat.decreasingInduction' (fun i hi _ ih him ↦ ?_) this fun hm ↦ ?_\n  · rw [← Nat.pred_eq_sub_one, Nat.lt_pred_iff, Nat.succ_eq_add_one] at hi\n    rw [accumulate_rec (him.trans_le hmn) hi, ih hi, invAccumulate, dif_pos him, dif_pos hi]\n    simp only\n    exact Nat.sub_add_cancel (hs i.le_succ)\n  · have := (Nat.sub_one_add_one <| Nat.not_eq_zero_of_lt hm).symm\n    rw [accumulate_last (hm.trans_le hmn) this, invAccumulate, dif_pos hm, dif_neg this.not_gt,\n      Nat.sub_zero]\n    intro j hj\n    rw [invAccumulate, dif_neg hj.not_lt, Nat.zero_sub]\n\n"}
{"name":"MvPolynomial.esymmAlgHom_apply","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\nn : Nat\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\np : MvPolynomial (Fin n) R\n⊢ Eq (↑((MvPolynomial.esymmAlgHom σ R n) p)) ((MvPolynomial.aeval fun i => MvPolynomial.esymm σ R (HAdd.hAdd (↑i) 1)) p)","decl":"lemma esymmAlgHom_apply (p : MvPolynomial (Fin n) R) :\n    (esymmAlgHom σ R n p).val = aeval (fun i : Fin n ↦ esymm σ R (i + 1)) p :=\n  (Subalgebra.mvPolynomial_aeval_coe _ _ _).symm\n\n"}
{"name":"MvPolynomial.rename_esymmAlgHom","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\nn : Nat\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : Fintype τ\ne : Equiv σ τ\n⊢ Eq ((↑(MvPolynomial.renameSymmetricSubalgebra e)).comp (MvPolynomial.esymmAlgHom σ R n)) (MvPolynomial.esymmAlgHom τ R n)","decl":"lemma rename_esymmAlgHom (e : σ ≃ τ) :\n    (renameSymmetricSubalgebra e).toAlgHom.comp (esymmAlgHom σ R n) = esymmAlgHom τ R n := by\n  ext i : 2\n  simp_rw [AlgHom.comp_apply, esymmAlgHom, aeval_X, AlgEquiv.toAlgHom_eq_coe, AlgHom.coe_coe,\n    renameSymmetricSubalgebra_apply_coe, rename_esymm]\n\n"}
{"name":"MvPolynomial.isSymmetric_esymmAlgHomMonomial","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\nn : Nat\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nt : Finsupp (Fin n) Nat\nr : R\n⊢ (MvPolynomial.esymmAlgHomMonomial σ t r).IsSymmetric","decl":"lemma isSymmetric_esymmAlgHomMonomial (t : Fin n →₀ ℕ) (r : R) :\n    (esymmAlgHomMonomial σ t r).IsSymmetric := (esymmAlgHom _ _ _ _).2\n\n"}
{"name":"MvPolynomial.esymmAlgHomMonomial_single","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\nn k : Nat\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\ni : Fin n\nr : R\n⊢ Eq (MvPolynomial.esymmAlgHomMonomial σ (Finsupp.single i k) r) (HMul.hMul (MvPolynomial.C r) (HPow.hPow (MvPolynomial.esymm σ R (HAdd.hAdd (↑i) 1)) k))","decl":"lemma esymmAlgHomMonomial_single :\n    esymmAlgHomMonomial σ (Finsupp.single i k) r = C r * esymm σ R (i + 1) ^ k := by\n  rw [esymmAlgHomMonomial, esymmAlgHom_apply, aeval_monomial, algebraMap_eq,\n    Finsupp.prod_single_index]\n  exact pow_zero _\n\n"}
{"name":"MvPolynomial.esymmAlgHomMonomial_single_one","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\nn k : Nat\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\ni : Fin n\n⊢ Eq (MvPolynomial.esymmAlgHomMonomial σ (Finsupp.single i k) 1) (HPow.hPow (MvPolynomial.esymm σ R (HAdd.hAdd (↑i) 1)) k)","decl":"lemma esymmAlgHomMonomial_single_one :\n    esymmAlgHomMonomial σ (Finsupp.single i k) 1 = esymm σ R (i + 1) ^ k := by\n  rw [esymmAlgHomMonomial_single, map_one, one_mul]\n\n"}
{"name":"MvPolynomial.esymmAlgHomMonomial_add","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\nn : Nat\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nr : R\nt s : Finsupp (Fin n) Nat\n⊢ Eq (MvPolynomial.esymmAlgHomMonomial σ (HAdd.hAdd t s) r) (HMul.hMul (MvPolynomial.esymmAlgHomMonomial σ t r) (MvPolynomial.esymmAlgHomMonomial σ s 1))","decl":"lemma esymmAlgHomMonomial_add {t s : Fin n →₀ ℕ} :\n    esymmAlgHomMonomial σ (t + s) r = esymmAlgHomMonomial σ t r * esymmAlgHomMonomial σ s 1 := by\n  simp_rw [esymmAlgHomMonomial, esymmAlgHom_apply, ← map_mul, monomial_mul, mul_one]\n\n"}
{"name":"MvPolynomial.esymmAlgHom_zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\nn : Nat\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nr : R\n⊢ Eq (MvPolynomial.esymmAlgHomMonomial σ 0 r) (MvPolynomial.C r)","decl":"lemma esymmAlgHom_zero : esymmAlgHomMonomial σ (0 : Fin n →₀ ℕ) r = C r := by\n  rw [esymmAlgHomMonomial, monomial_zero', esymmAlgHom_apply, aeval_C, algebraMap_eq]\n\n"}
{"name":"MvPolynomial.supDegree_esymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"R : Type u_3\nn m : Nat\ninst✝¹ : CommSemiring R\ni : Fin n\ninst✝ : Nontrivial R\nhim : LT.lt (↑i) m\n⊢ Eq (⇑(ofLex (AddMonoidAlgebra.supDegree (⇑toLex) (MvPolynomial.esymm (Fin m) R (HAdd.hAdd (↑i) 1))))) ((Fin.accumulate n m) ⇑(Finsupp.single i 1))","decl":"lemma supDegree_esymm [Nontrivial R] (him : i < m) :\n    ofLex (supDegree toLex <| esymm (Fin m) R (i + 1)) = accumulate n m (Finsupp.single i 1) := by\n  rw [(supDegree_monic_esymm him).1, ofLex_toLex]\n  ext j\n  simp_rw [Finsupp.indicator_apply, dite_eq_ite, mem_Iic, accumulate_apply, Finsupp.single_apply,\n    sum_ite_eq, mem_filter, mem_univ, true_and, Fin.le_def]\n\n"}
{"name":"MvPolynomial.monic_esymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"R : Type u_3\nm : Nat\ninst✝ : CommSemiring R\ni : Nat\nhim : LE.le i m\n⊢ AddMonoidAlgebra.Monic (⇑toLex) (MvPolynomial.esymm (Fin m) R i)","decl":"lemma monic_esymm {i : ℕ} (him : i ≤ m) : Monic toLex (esymm (Fin m) R i) := by\n  cases i with\n  | zero =>\n    rw [esymm_zero]\n    exact monic_one toLex.injective\n  | succ i =>\n    nontriviality R\n    exact (supDegree_monic_esymm him).2\n\n"}
{"name":"MvPolynomial.leadingCoeff_esymmAlgHomMonomial","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"R : Type u_3\nn m : Nat\ninst✝ : CommSemiring R\nr : R\nt : Finsupp (Fin n) Nat\nhnm : LE.le n m\n⊢ Eq (AddMonoidAlgebra.leadingCoeff (⇑toLex) (MvPolynomial.esymmAlgHomMonomial (Fin m) t r)) r","decl":"lemma leadingCoeff_esymmAlgHomMonomial (t : Fin n →₀ ℕ) (hnm : n ≤ m) :\n    leadingCoeff toLex (esymmAlgHomMonomial (Fin m) t r) = r := by\n  induction t using Finsupp.induction₂ with\n  | h0 => rw [esymmAlgHom_zero, leadingCoeff_toLex_C]\n  | ha i _ _ _ _ ih =>\n    rw [esymmAlgHomMonomial_add, esymmAlgHomMonomial_single_one,\n        ((monic_esymm <| i.2.trans_le hnm).pow toLex_add toLex.injective).leadingCoeff_mul_eq_left,\n        ih]\n    exacts [toLex.injective, toLex_add]\n\n"}
{"name":"MvPolynomial.supDegree_esymmAlgHomMonomial","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"R : Type u_3\nn m : Nat\ninst✝ : CommSemiring R\nr : R\nhr : Ne r 0\nt : Finsupp (Fin n) Nat\nhnm : LE.le n m\n⊢ Eq (⇑(ofLex (AddMonoidAlgebra.supDegree (⇑toLex) (MvPolynomial.esymmAlgHomMonomial (Fin m) t r)))) ((Fin.accumulate n m) ⇑t)","decl":"lemma supDegree_esymmAlgHomMonomial (hr : r ≠ 0) (t : Fin n →₀ ℕ) (hnm : n ≤ m) :\n    ofLex (supDegree toLex <| esymmAlgHomMonomial (Fin m) t r) = accumulate n m t := by\n  nontriviality R\n  induction t using Finsupp.induction₂ with\n  | h0 => simp_rw [esymmAlgHom_zero, supDegree_toLex_C, ofLex_zero, Finsupp.coe_zero, map_zero]\n  | ha  i _ _ _ _ ih =>\n    have := i.2.trans_le hnm\n    rw [esymmAlgHomMonomial_add, esymmAlgHomMonomial_single_one,\n        Monic.supDegree_mul_of_ne_zero_left toLex.injective toLex_add, ofLex_add, Finsupp.coe_add,\n        ih, Finsupp.coe_add, map_add, Monic.supDegree_pow rfl toLex_add toLex.injective, ofLex_smul,\n        Finsupp.coe_smul, supDegree_esymm this, ← map_nsmul, ← Finsupp.coe_smul,\n        Finsupp.smul_single, nsmul_one, Nat.cast_id]\n    · exact monic_esymm this\n    · exact (monic_esymm this).pow toLex_add toLex.injective\n    · rwa [Ne, ← leadingCoeff_eq_zero toLex.injective, leadingCoeff_esymmAlgHomMonomial _ hnm]\n\n"}
{"name":"MvPolynomial.IsSymmetric.antitone_supDegree","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : LinearOrder σ\np : MvPolynomial σ R\nhp : p.IsSymmetric\n⊢ Antitone ⇑(ofLex (AddMonoidAlgebra.supDegree (⇑toLex) p))","decl":"omit [Fintype σ] in\nlemma IsSymmetric.antitone_supDegree [LinearOrder σ] {p : MvPolynomial σ R} (hp : p.IsSymmetric) :\n    Antitone ↑(ofLex <| p.supDegree toLex) := by\n  obtain rfl | h0 := eq_or_ne p 0\n  · rw [supDegree_zero, Finsupp.bot_eq_zero]\n    exact Pi.zero_mono\n  rw [Antitone]\n  by_contra! h\n  obtain ⟨i, j, hle, hlt⟩ := h\n  apply (le_sup (s := p.support) (f := toLex) _).not_lt\n  pick_goal 3\n  · rw [← hp (Equiv.swap i j), mem_support_iff, coeff_rename_mapDomain _ (Equiv.injective _)]\n    rw [Ne, ← leadingCoeff_eq_zero toLex.injective, leadingCoeff_toLex] at h0\n    assumption\n  refine ⟨i, fun k hk ↦ ?_, ?_⟩\n  all_goals dsimp only [Pi.toLex_apply, ofLex_toLex]\n  · conv_rhs => rw [← Equiv.swap_apply_of_ne_of_ne hk.ne (hk.trans_le hle).ne]\n    rw [Finsupp.mapDomain_apply (Equiv.injective _), supDegree]; rfl\n  · apply hlt.trans_eq\n    simp_rw [Finsupp.mapDomain_equiv_apply, Equiv.symm_swap, Equiv.swap_apply_left]\n\n"}
{"name":"MvPolynomial.esymmAlgHom_fin_injective","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"R : Type u_3\nn m : Nat\ninst✝ : CommRing R\nh : LE.le n m\n⊢ Function.Injective ⇑(MvPolynomial.esymmAlgHom (Fin m) R n)","decl":"lemma esymmAlgHom_fin_injective (h : n ≤ m) :\n    Function.Injective (esymmAlgHom (Fin m) R n) := by\n  rw [injective_iff_map_eq_zero]\n  refine fun p ↦ (fun hp ↦ ?_).mtr\n  rw [p.as_sum, map_sum (esymmAlgHom (Fin m) R n), ← Subalgebra.coe_eq_zero,\n    AddSubmonoidClass.coe_finset_sum]\n  refine sum_ne_zero_of_injOn_supDegree (D := toLex) (support_eq_empty.not.2 hp) (fun t ht ↦ ?_)\n    (fun t ht s hs he ↦ DFunLike.ext' <| accumulate_injective h ?_)\n  · rw [← esymmAlgHomMonomial, Ne, ← leadingCoeff_eq_zero toLex.injective,\n      leadingCoeff_esymmAlgHomMonomial t h]\n    rwa [mem_support_iff] at ht\n  rw [mem_coe, mem_support_iff] at ht hs\n  dsimp only [Function.comp] at he\n  rwa [← esymmAlgHomMonomial, ← esymmAlgHomMonomial, ← ofLex_inj, DFunLike.ext'_iff,\n       supDegree_esymmAlgHomMonomial ht t h, supDegree_esymmAlgHomMonomial hs s h] at he\n\n"}
{"name":"MvPolynomial.esymmAlgHom_injective","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\nn : Nat\ninst✝¹ : Fintype σ\ninst✝ : CommRing R\nhn : LE.le n (Fintype.card σ)\n⊢ Function.Injective ⇑(MvPolynomial.esymmAlgHom σ R n)","decl":"lemma esymmAlgHom_injective (hn : n ≤ Fintype.card σ) :\n    Function.Injective (esymmAlgHom σ R n) := by\n  rw [← rename_esymmAlgHom (Fintype.equivFin σ).symm, AlgHom.coe_comp]\n  exact (AlgEquiv.injective _).comp (esymmAlgHom_fin_injective R hn)\n\n"}
{"name":"MvPolynomial.esymmAlgHom_fin_bijective","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nn : Nat\n⊢ Function.Bijective ⇑(MvPolynomial.esymmAlgHom (Fin n) R n)","decl":"lemma esymmAlgHom_fin_bijective (n : ℕ) :\n    Function.Bijective (esymmAlgHom (Fin n) R n) := by\n  use esymmAlgHom_fin_injective R le_rfl\n  rintro ⟨p, hp⟩\n  rw [← AlgHom.mem_range]\n  obtain rfl | h0 := eq_or_ne p 0\n  · exact Subalgebra.zero_mem _\n  induction' he : p.supDegree toLex using WellFoundedLT.induction with t ih generalizing p; subst he\n  let t := Finsupp.equivFunOnFinite.symm (invAccumulate n n <| ↑(ofLex <| p.supDegree toLex))\n  have hd :\n      (esymmAlgHomMonomial _ t <| p.leadingCoeff toLex).supDegree toLex = p.supDegree toLex := by\n    rw [← ofLex_inj, DFunLike.ext'_iff, supDegree_esymmAlgHomMonomial _ _ le_rfl]\n    · exact accumulate_invAccumulate le_rfl hp.antitone_supDegree\n    · rwa [Ne, leadingCoeff_eq_zero toLex.injective]\n  obtain he | hne := eq_or_ne p (esymmAlgHomMonomial _ t <| p.leadingCoeff toLex)\n  · convert AlgHom.mem_range_self _ (monomial t <| p.leadingCoeff toLex)\n  have := (supDegree_sub_lt_of_leadingCoeff_eq toLex.injective hd.symm ?_).resolve_right hne\n  · specialize ih _ this _ (Subalgebra.sub_mem _ hp <| isSymmetric_esymmAlgHomMonomial _ _) _ rfl\n    · rwa [sub_ne_zero]\n    convert ← Subalgebra.add_mem _ ih ⟨monomial t (p.leadingCoeff toLex), rfl⟩\n    apply sub_add_cancel p\n  · rw [leadingCoeff_esymmAlgHomMonomial t le_rfl]\n\n"}
{"name":"MvPolynomial.esymmAlgHom_fin_surjective","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"R : Type u_3\nn m : Nat\ninst✝ : CommRing R\nh : LE.le m n\n⊢ Function.Surjective ⇑(MvPolynomial.esymmAlgHom (Fin m) R n)","decl":"lemma esymmAlgHom_fin_surjective (h : m ≤ n) :\n    Function.Surjective (esymmAlgHom (Fin m) R n) := by\n  intro p\n  obtain ⟨q, rfl⟩ := (esymmAlgHom_fin_bijective R m).2 p\n  rw [← AlgHom.mem_range]\n  induction q using MvPolynomial.induction_on with\n  | h_C r => rw [← algebraMap_eq, AlgHom.commutes]; apply Subalgebra.algebraMap_mem\n  | h_add p q hp hq => rw [map_add]; exact Subalgebra.add_mem _ hp hq\n  | h_X p i hp =>\n    rw [map_mul]\n    apply Subalgebra.mul_mem _ hp\n    rw [AlgHom.mem_range]\n    refine ⟨X ⟨i, i.2.trans_le h⟩, ?_⟩\n    simp_rw [esymmAlgHom, aeval_X]\n\n"}
{"name":"MvPolynomial.esymmAlgHom_surjective","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\nn : Nat\ninst✝¹ : Fintype σ\ninst✝ : CommRing R\nhn : LE.le (Fintype.card σ) n\n⊢ Function.Surjective ⇑(MvPolynomial.esymmAlgHom σ R n)","decl":"lemma esymmAlgHom_surjective (hn : Fintype.card σ ≤ n) :\n    Function.Surjective (esymmAlgHom σ R n) := by\n  rw [← rename_esymmAlgHom (Fintype.equivFin σ).symm, AlgHom.coe_comp]\n  exact (AlgEquiv.surjective _).comp (esymmAlgHom_fin_surjective R hn)\n\n"}
{"name":"MvPolynomial.esymmAlgEquiv_apply","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.FundamentalTheorem","initialProofState":"σ : Type u_1\nR : Type u_3\nn : Nat\ninst✝¹ : Fintype σ\ninst✝ : CommRing R\nhn : Eq (Fintype.card σ) n\na : MvPolynomial (Fin n) R\n⊢ Eq ((MvPolynomial.esymmAlgEquiv R hn) a) ((MvPolynomial.esymmAlgHom σ R n) a)","decl":"/-- If the cardinality of `σ` is `n`, then `esymmAlgHom σ R n` is an isomorphism. -/\n@[simps! apply]\nnoncomputable def esymmAlgEquiv (hn : Fintype.card σ = n) :\n    MvPolynomial (Fin n) R ≃ₐ[R] symmetricSubalgebra σ R :=\n  AlgEquiv.ofBijective (esymmAlgHom σ R n)\n    ⟨esymmAlgHom_injective R hn.ge, esymmAlgHom_surjective R hn.le⟩\n\n"}
