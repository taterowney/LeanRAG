{"name":"CategoryTheory.Limits.multicospanIndexEnd_fstTo","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nf : CategoryTheory.Arrow J\n⊢ Eq ((CategoryTheory.Limits.multicospanIndexEnd F).fstTo f) f.left","decl":"/-- Given `F : Jᵒᵖ ⥤ J ⥤ C`, this is the multicospan index which shall be used\nto define the end of `F`. -/\n@[simps]\ndef multicospanIndexEnd : MulticospanIndex C where\n  L := J\n  R := Arrow J\n  fstTo f := f.left\n  sndTo f := f.right\n  left j := (F.obj (op j)).obj j\n  right f := (F.obj (op f.left)).obj f.right\n  fst f := (F.obj (op f.left)).map f.hom\n  snd f := (F.map f.hom.op).app f.right\n\n"}
{"name":"CategoryTheory.Limits.multicospanIndexEnd_sndTo","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nf : CategoryTheory.Arrow J\n⊢ Eq ((CategoryTheory.Limits.multicospanIndexEnd F).sndTo f) f.right","decl":"/-- Given `F : Jᵒᵖ ⥤ J ⥤ C`, this is the multicospan index which shall be used\nto define the end of `F`. -/\n@[simps]\ndef multicospanIndexEnd : MulticospanIndex C where\n  L := J\n  R := Arrow J\n  fstTo f := f.left\n  sndTo f := f.right\n  left j := (F.obj (op j)).obj j\n  right f := (F.obj (op f.left)).obj f.right\n  fst f := (F.obj (op f.left)).map f.hom\n  snd f := (F.map f.hom.op).app f.right\n\n"}
{"name":"CategoryTheory.Limits.multicospanIndexEnd_R","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\n⊢ Eq (CategoryTheory.Limits.multicospanIndexEnd F).R (CategoryTheory.Arrow J)","decl":"/-- Given `F : Jᵒᵖ ⥤ J ⥤ C`, this is the multicospan index which shall be used\nto define the end of `F`. -/\n@[simps]\ndef multicospanIndexEnd : MulticospanIndex C where\n  L := J\n  R := Arrow J\n  fstTo f := f.left\n  sndTo f := f.right\n  left j := (F.obj (op j)).obj j\n  right f := (F.obj (op f.left)).obj f.right\n  fst f := (F.obj (op f.left)).map f.hom\n  snd f := (F.map f.hom.op).app f.right\n\n"}
{"name":"CategoryTheory.Limits.multicospanIndexEnd_L","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\n⊢ Eq (CategoryTheory.Limits.multicospanIndexEnd F).L J","decl":"/-- Given `F : Jᵒᵖ ⥤ J ⥤ C`, this is the multicospan index which shall be used\nto define the end of `F`. -/\n@[simps]\ndef multicospanIndexEnd : MulticospanIndex C where\n  L := J\n  R := Arrow J\n  fstTo f := f.left\n  sndTo f := f.right\n  left j := (F.obj (op j)).obj j\n  right f := (F.obj (op f.left)).obj f.right\n  fst f := (F.obj (op f.left)).map f.hom\n  snd f := (F.map f.hom.op).app f.right\n\n"}
{"name":"CategoryTheory.Limits.multicospanIndexEnd_left","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nj : J\n⊢ Eq ((CategoryTheory.Limits.multicospanIndexEnd F).left j) ((F.obj { unop := j }).obj j)","decl":"/-- Given `F : Jᵒᵖ ⥤ J ⥤ C`, this is the multicospan index which shall be used\nto define the end of `F`. -/\n@[simps]\ndef multicospanIndexEnd : MulticospanIndex C where\n  L := J\n  R := Arrow J\n  fstTo f := f.left\n  sndTo f := f.right\n  left j := (F.obj (op j)).obj j\n  right f := (F.obj (op f.left)).obj f.right\n  fst f := (F.obj (op f.left)).map f.hom\n  snd f := (F.map f.hom.op).app f.right\n\n"}
{"name":"CategoryTheory.Limits.multicospanIndexEnd_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nf : CategoryTheory.Arrow J\n⊢ Eq ((CategoryTheory.Limits.multicospanIndexEnd F).fst f) ((F.obj { unop := f.left }).map f.hom)","decl":"/-- Given `F : Jᵒᵖ ⥤ J ⥤ C`, this is the multicospan index which shall be used\nto define the end of `F`. -/\n@[simps]\ndef multicospanIndexEnd : MulticospanIndex C where\n  L := J\n  R := Arrow J\n  fstTo f := f.left\n  sndTo f := f.right\n  left j := (F.obj (op j)).obj j\n  right f := (F.obj (op f.left)).obj f.right\n  fst f := (F.obj (op f.left)).map f.hom\n  snd f := (F.map f.hom.op).app f.right\n\n"}
{"name":"CategoryTheory.Limits.multicospanIndexEnd_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nf : CategoryTheory.Arrow J\n⊢ Eq ((CategoryTheory.Limits.multicospanIndexEnd F).snd f) ((F.map f.hom.op).app f.right)","decl":"/-- Given `F : Jᵒᵖ ⥤ J ⥤ C`, this is the multicospan index which shall be used\nto define the end of `F`. -/\n@[simps]\ndef multicospanIndexEnd : MulticospanIndex C where\n  L := J\n  R := Arrow J\n  fstTo f := f.left\n  sndTo f := f.right\n  left j := (F.obj (op j)).obj j\n  right f := (F.obj (op f.left)).obj f.right\n  fst f := (F.obj (op f.left)).map f.hom\n  snd f := (F.map f.hom.op).app f.right\n\n"}
{"name":"CategoryTheory.Limits.multicospanIndexEnd_right","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nf : CategoryTheory.Arrow J\n⊢ Eq ((CategoryTheory.Limits.multicospanIndexEnd F).right f) ((F.obj { unop := f.left }).obj f.right)","decl":"/-- Given `F : Jᵒᵖ ⥤ J ⥤ C`, this is the multicospan index which shall be used\nto define the end of `F`. -/\n@[simps]\ndef multicospanIndexEnd : MulticospanIndex C where\n  L := J\n  R := Arrow J\n  fstTo f := f.left\n  sndTo f := f.right\n  left j := (F.obj (op j)).obj j\n  right f := (F.obj (op f.left)).obj f.right\n  fst f := (F.obj (op f.left)).map f.hom\n  snd f := (F.map f.hom.op).app f.right\n\n"}
{"name":"CategoryTheory.Limits.Wedge.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\npt : C\nπ : (j : J) → Quiver.Hom pt ((F.obj { unop := j }).obj j)\nhπ : ∀ ⦃i j : J⦄ (f : Quiver.Hom i j), Eq (CategoryTheory.CategoryStruct.comp (π i) ((F.obj { unop := i }).map f)) (CategoryTheory.CategoryStruct.comp (π j) ((F.map f.op).app j))\n⊢ Eq (CategoryTheory.Limits.Wedge.mk pt π hπ).pt pt","decl":"/-- Constructor for wedges. -/\n@[simps! pt]\nabbrev mk : Wedge F :=\n  Multifork.ofι _ pt π (fun f ↦ hπ f.hom)\n\n"}
{"name":"CategoryTheory.Limits.Wedge.mk_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\npt : C\nπ : (j : J) → Quiver.Hom pt ((F.obj { unop := j }).obj j)\nhπ : ∀ ⦃i j : J⦄ (f : Quiver.Hom i j), Eq (CategoryTheory.CategoryStruct.comp (π i) ((F.obj { unop := i }).map f)) (CategoryTheory.CategoryStruct.comp (π j) ((F.map f.op).app j))\nj : J\n⊢ Eq (CategoryTheory.Limits.Multifork.ι (CategoryTheory.Limits.Wedge.mk pt π hπ) j) (π j)","decl":"@[simp]\nlemma mk_ι (j : J) : (mk pt π hπ).ι j = π j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Wedge.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nc : CategoryTheory.Limits.Wedge F\ni j : J\nf : Quiver.Hom i j\nZ : C\nh : Quiver.Hom ((F.obj { unop := i }).obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multifork.ι c i) (CategoryTheory.CategoryStruct.comp ((F.obj { unop := i }).map f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multifork.ι c j) (CategoryTheory.CategoryStruct.comp ((F.map f.op).app j) h))","decl":"@[reassoc]\nlemma condition (c : Wedge F) {i j : J} (f : i ⟶ j) :\n    c.ι i ≫ (F.obj (op i)).map f = c.ι j ≫ (F.map f.op).app j :=\n  Multifork.condition c (Arrow.mk f)\n\n"}
{"name":"CategoryTheory.Limits.Wedge.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nc : CategoryTheory.Limits.Wedge F\ni j : J\nf : Quiver.Hom i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multifork.ι c i) ((F.obj { unop := i }).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multifork.ι c j) ((F.map f.op).app j))","decl":"@[reassoc]\nlemma condition (c : Wedge F) {i j : J} (f : i ⟶ j) :\n    c.ι i ≫ (F.obj (op i)).map f = c.ι j ≫ (F.map f.op).app j :=\n  Multifork.condition c (Arrow.mk f)\n\n"}
{"name":"CategoryTheory.Limits.Wedge.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nc : CategoryTheory.Limits.Wedge F\nhc : CategoryTheory.Limits.IsLimit c\nX : C\nf g : Quiver.Hom X c.pt\nh : ∀ (j : (CategoryTheory.Limits.multicospanIndexEnd F).L), Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Multifork.ι c j)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.Multifork.ι c j))\n⊢ Eq f g","decl":"lemma hom_ext (hc : IsLimit c) {X : C} {f g : X ⟶ c.pt} (h : ∀ j, f ≫ c.ι j = g ≫ c.ι j) :\n    f = g :=\n  Multifork.IsLimit.hom_ext hc h\n\n"}
{"name":"CategoryTheory.Limits.Wedge.IsLimit.lift_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nc : CategoryTheory.Limits.Wedge F\nhc : CategoryTheory.Limits.IsLimit c\nX : C\nf : (j : J) → Quiver.Hom X ((F.obj { unop := j }).obj j)\nhf : ∀ ⦃i j : J⦄ (g : Quiver.Hom i j), Eq (CategoryTheory.CategoryStruct.comp (f i) ((F.obj { unop := i }).map g)) (CategoryTheory.CategoryStruct.comp (f j) ((F.map g.op).app j))\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Wedge.IsLimit.lift hc f hf) (CategoryTheory.Limits.Multifork.ι c j)) (f j)","decl":"@[reassoc (attr := simp)]\nlemma lift_ι (hc : IsLimit c) {X : C} (f : ∀ j, X ⟶ (F.obj (op j)).obj j)\n    (hf : ∀ ⦃i j : J⦄ (g : i ⟶ j), f i ≫ (F.obj (op i)).map g = f j ≫ (F.map g.op).app j) (j : J) :\n    lift hc f hf ≫ c.ι j = f j := by\n  apply IsLimit.fac\n\n\n"}
{"name":"CategoryTheory.Limits.Wedge.IsLimit.lift_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\nc : CategoryTheory.Limits.Wedge F\nhc : CategoryTheory.Limits.IsLimit c\nX : C\nf : (j : J) → Quiver.Hom X ((F.obj { unop := j }).obj j)\nhf : ∀ ⦃i j : J⦄ (g : Quiver.Hom i j), Eq (CategoryTheory.CategoryStruct.comp (f i) ((F.obj { unop := i }).map g)) (CategoryTheory.CategoryStruct.comp (f j) ((F.map g.op).app j))\nj : J\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.multicospanIndexEnd F).left j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Wedge.IsLimit.lift hc f hf) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multifork.ι c j) h)) (CategoryTheory.CategoryStruct.comp (f j) h)","decl":"@[reassoc (attr := simp)]\nlemma lift_ι (hc : IsLimit c) {X : C} (f : ∀ j, X ⟶ (F.obj (op j)).obj j)\n    (hf : ∀ ⦃i j : J⦄ (g : i ⟶ j), f i ≫ (F.obj (op i)).map g = f j ≫ (F.map g.op).app j) (j : J) :\n    lift hc f hf ≫ c.ι j = f j := by\n  apply IsLimit.fac\n\n\n"}
{"name":"CategoryTheory.Limits.end_.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\ninst✝ : CategoryTheory.Limits.HasEnd F\ni j : J\nf : Quiver.Hom i j\nZ : C\nh : Quiver.Hom ((F.obj { unop := i }).obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.end_.π F i) (CategoryTheory.CategoryStruct.comp ((F.obj { unop := i }).map f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.end_.π F j) (CategoryTheory.CategoryStruct.comp ((F.map f.op).app j) h))","decl":"@[reassoc]\nlemma end_.condition {i j : J} (f : i ⟶ j) :\n    π F i ≫ (F.obj (op i)).map f = π F j ≫ (F.map f.op).app j := by\n  apply Wedge.condition\n\n"}
{"name":"CategoryTheory.Limits.end_.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\ninst✝ : CategoryTheory.Limits.HasEnd F\ni j : J\nf : Quiver.Hom i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.end_.π F i) ((F.obj { unop := i }).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.end_.π F j) ((F.map f.op).app j))","decl":"@[reassoc]\nlemma end_.condition {i j : J} (f : i ⟶ j) :\n    π F i ≫ (F.obj (op i)).map f = π F j ≫ (F.map f.op).app j := by\n  apply Wedge.condition\n\n"}
{"name":"CategoryTheory.Limits.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\ninst✝ : CategoryTheory.Limits.HasEnd F\nX : C\nf g : Quiver.Hom X (CategoryTheory.Limits.end_ F)\nh : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.end_.π F j)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.end_.π F j))\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {X : C} {f g : X ⟶ end_ F} (h : ∀ j, f ≫ end_.π F j = g ≫ end_.π F j) :\n    f = g :=\n  Multiequalizer.hom_ext _ _ _ (fun _ ↦ h _)\n\n"}
{"name":"CategoryTheory.Limits.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\ninst✝ : CategoryTheory.Limits.HasEnd F\nX : C\nf g : Quiver.Hom X (CategoryTheory.Limits.end_ F)\n⊢ Iff (Eq f g) (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.end_.π F j)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.end_.π F j)))","decl":"@[ext]\nlemma hom_ext {X : C} {f g : X ⟶ end_ F} (h : ∀ j, f ≫ end_.π F j = g ≫ end_.π F j) :\n    f = g :=\n  Multiequalizer.hom_ext _ _ _ (fun _ ↦ h _)\n\n"}
{"name":"CategoryTheory.Limits.end_.lift_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\ninst✝ : CategoryTheory.Limits.HasEnd F\nX : C\nf : (j : J) → Quiver.Hom X ((F.obj { unop := j }).obj j)\nhf : ∀ ⦃i j : J⦄ (g : Quiver.Hom i j), Eq (CategoryTheory.CategoryStruct.comp (f i) ((F.obj { unop := i }).map g)) (CategoryTheory.CategoryStruct.comp (f j) ((F.map g.op).app j))\nj : J\nZ : C\nh : Quiver.Hom ((F.obj { unop := j }).obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.end_.lift f hf) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.end_.π F j) h)) (CategoryTheory.CategoryStruct.comp (f j) h)","decl":"@[reassoc (attr := simp)]\nlemma end_.lift_π (j : J) : lift f hf ≫ π F j = f j := by\n  apply IsLimit.fac\n\n"}
{"name":"CategoryTheory.Limits.end_.lift_π","module":"Mathlib.CategoryTheory.Limits.Shapes.End","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nC : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} C\nF : CategoryTheory.Functor (Opposite J) (CategoryTheory.Functor J C)\ninst✝ : CategoryTheory.Limits.HasEnd F\nX : C\nf : (j : J) → Quiver.Hom X ((F.obj { unop := j }).obj j)\nhf : ∀ ⦃i j : J⦄ (g : Quiver.Hom i j), Eq (CategoryTheory.CategoryStruct.comp (f i) ((F.obj { unop := i }).map g)) (CategoryTheory.CategoryStruct.comp (f j) ((F.map g.op).app j))\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.end_.lift f hf) (CategoryTheory.Limits.end_.π F j)) (f j)","decl":"@[reassoc (attr := simp)]\nlemma end_.lift_π (j : J) : lift f hf ≫ π F j = f j := by\n  apply IsLimit.fac\n\n"}
