{"name":"Finset.mem_finsuppAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\ns : Finset ι\nn : μ\nf : Finsupp ι μ\n⊢ Iff (Membership.mem (s.finsuppAntidiag n) f) (And (Eq (s.sum ⇑f) n) (HasSubset.Subset f.support s))","decl":"@[simp] lemma mem_finsuppAntidiag : f ∈ finsuppAntidiag s n ↔ s.sum f = n ∧ f.support ⊆ s := by\n  simp [finsuppAntidiag, ← DFunLike.coe_fn_eq, subset_iff]\n\n"}
{"name":"Finset.mem_finsuppAntidiag'","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\ns : Finset ι\nn : μ\nf : Finsupp ι μ\n⊢ Iff (Membership.mem (s.finsuppAntidiag n) f) (And (Eq (f.sum fun x x => x) n) (HasSubset.Subset f.support s))","decl":"lemma mem_finsuppAntidiag' :\n    f ∈ finsuppAntidiag s n ↔ f.sum (fun _ x ↦ x) = n ∧ f.support ⊆ s := by\n  simp only [mem_finsuppAntidiag, and_congr_left_iff]\n  rintro hf\n  rw [sum_of_support_subset (N := μ) f hf (fun _ x ↦ x) fun _ _ ↦ rfl]\n\n"}
{"name":"Finset.finsuppAntidiag_empty_zero","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\n⊢ Eq (EmptyCollection.emptyCollection.finsuppAntidiag 0) (Singleton.singleton 0)","decl":"@[simp] lemma finsuppAntidiag_empty_zero : finsuppAntidiag (∅ : Finset ι) (0 : μ) = {0} := by\n  ext f; simp [finsuppAntidiag, ← DFunLike.coe_fn_eq (g := f), eq_comm]\n\n"}
{"name":"Finset.finsuppAntidiag_empty_of_ne_zero","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\nn : μ\nhn : Ne n 0\n⊢ Eq (EmptyCollection.emptyCollection.finsuppAntidiag n) EmptyCollection.emptyCollection","decl":"@[simp] lemma finsuppAntidiag_empty_of_ne_zero (hn : n ≠ 0) :\n    finsuppAntidiag (∅ : Finset ι) n = ∅ :=\n  eq_empty_of_forall_not_mem (by simp [@eq_comm _ 0, hn.symm])\n\n"}
{"name":"Finset.finsuppAntidiag_empty","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\nn : μ\n⊢ Eq (EmptyCollection.emptyCollection.finsuppAntidiag n) (ite (Eq n 0) (Singleton.singleton 0) EmptyCollection.emptyCollection)","decl":"lemma finsuppAntidiag_empty (n : μ) :\n    finsuppAntidiag (∅ : Finset ι) n = if n = 0 then {0} else ∅ := by split_ifs with hn <;> simp [*]\n\n"}
{"name":"Finset.mem_finsuppAntidiag_insert","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\na : ι\ns : Finset ι\nh : Not (Membership.mem s a)\nn : μ\nf : Finsupp ι μ\n⊢ Iff (Membership.mem ((Insert.insert a s).finsuppAntidiag n) f) (Exists fun m => And (Membership.mem (Finset.HasAntidiagonal.antidiagonal n) m) (Exists fun g => And (Eq f (g.update a m.1)) (Membership.mem (s.finsuppAntidiag m.2) g)))","decl":"theorem mem_finsuppAntidiag_insert {a : ι} {s : Finset ι}\n    (h : a ∉ s) (n : μ) {f : ι →₀ μ} :\n    f ∈ finsuppAntidiag (insert a s) n ↔\n      ∃ m ∈ antidiagonal n, ∃ (g : ι →₀ μ),\n        f = Finsupp.update g a m.1 ∧ g ∈ finsuppAntidiag s m.2 := by\n  simp only [mem_finsuppAntidiag, mem_antidiagonal, Prod.exists, sum_insert h]\n  constructor\n  · rintro ⟨rfl, hsupp⟩\n    refine ⟨_, _, rfl, Finsupp.erase a f, ?_, ?_, ?_⟩\n    · rw [update_erase_eq_update, Finsupp.update_self]\n    · apply sum_congr rfl\n      intro x hx\n      rw [Finsupp.erase_ne (ne_of_mem_of_not_mem hx h)]\n    · rwa [support_erase, ← subset_insert_iff]\n  · rintro ⟨n1, n2, rfl, g, rfl, rfl, hgsupp⟩\n    refine ⟨?_, (support_update_subset _ _).trans (insert_subset_insert a hgsupp)⟩\n    simp only [coe_update]\n    apply congr_arg₂\n    · rw [Function.update_self]\n    · apply sum_congr rfl\n      intro x hx\n      rw [update_of_ne (ne_of_mem_of_not_mem hx h) n1 ⇑g]\n\n"}
{"name":"Finset.finsuppAntidiag_insert","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝³ : DecidableEq ι\ninst✝² : AddCommMonoid μ\ninst✝¹ : Finset.HasAntidiagonal μ\ninst✝ : DecidableEq μ\na : ι\ns : Finset ι\nh : Not (Membership.mem s a)\nn : μ\n⊢ Eq ((Insert.insert a s).finsuppAntidiag n) ((Finset.HasAntidiagonal.antidiagonal n).biUnion fun p => Finset.map { toFun := fun f => (↑f).update a p.1, inj' := ⋯ } (s.finsuppAntidiag p.2).attach)","decl":"theorem finsuppAntidiag_insert {a : ι} {s : Finset ι}\n    (h : a ∉ s) (n : μ) :\n    finsuppAntidiag (insert a s) n = (antidiagonal n).biUnion\n      (fun p : μ × μ =>\n        (finsuppAntidiag s p.snd).attach.map\n        ⟨fun f => Finsupp.update f.val a p.fst,\n        (fun ⟨f, hf⟩ ⟨g, hg⟩ hfg => Subtype.ext <| by\n          simp only [mem_val, mem_finsuppAntidiag] at hf hg\n          simp only [DFunLike.ext_iff] at hfg ⊢\n          intro x\n          obtain rfl | hx := eq_or_ne x a\n          · replace hf := mt (hf.2 ·) h\n            replace hg := mt (hg.2 ·) h\n            rw [not_mem_support_iff.mp hf, not_mem_support_iff.mp hg]\n          · simpa only [coe_update, Function.update, dif_neg hx] using hfg x)⟩) := by\n  ext f\n  rw [mem_finsuppAntidiag_insert h, mem_biUnion]\n  simp_rw [mem_map, mem_attach, true_and, Subtype.exists, Embedding.coeFn_mk, exists_prop, and_comm,\n    eq_comm]\n\n"}
{"name":"Finset.mapRange_finsuppAntidiag_subset","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\nμ' : Type u_3\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : AddCommMonoid μ\ninst✝⁴ : Finset.HasAntidiagonal μ\ninst✝³ : DecidableEq μ\ninst✝² : AddCommMonoid μ'\ninst✝¹ : Finset.HasAntidiagonal μ'\ninst✝ : DecidableEq μ'\ne : AddEquiv μ μ'\ns : Finset ι\nn : μ\n⊢ HasSubset.Subset (Finset.map (Finsupp.mapRange.addEquiv e).toEmbedding (s.finsuppAntidiag n)) (s.finsuppAntidiag (e n))","decl":"lemma mapRange_finsuppAntidiag_subset {e : μ ≃+ μ'} {s : Finset ι} {n : μ} :\n    (finsuppAntidiag s n).map (mapRange.addEquiv e).toEmbedding ⊆ finsuppAntidiag s (e n) := by\n  intro f\n  simp only [mem_map, mem_finsuppAntidiag']\n  rintro ⟨g, ⟨hsum, hsupp⟩, rfl⟩\n  simp only [AddEquiv.toEquiv_eq_coe, mapRange.addEquiv_toEquiv, Equiv.coe_toEmbedding,\n    mapRange.equiv_apply, EquivLike.coe_coe]\n  constructor\n  · rw [sum_mapRange_index (fun _ ↦ rfl), ← hsum, _root_.map_finsupp_sum]\n  · exact subset_trans (support_mapRange) hsupp\n\n"}
{"name":"Finset.mapRange_finsuppAntidiag_eq","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\nμ' : Type u_3\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : AddCommMonoid μ\ninst✝⁴ : Finset.HasAntidiagonal μ\ninst✝³ : DecidableEq μ\ninst✝² : AddCommMonoid μ'\ninst✝¹ : Finset.HasAntidiagonal μ'\ninst✝ : DecidableEq μ'\ne : AddEquiv μ μ'\ns : Finset ι\nn : μ\n⊢ Eq (Finset.map (Finsupp.mapRange.addEquiv e).toEmbedding (s.finsuppAntidiag n)) (s.finsuppAntidiag (e n))","decl":"lemma mapRange_finsuppAntidiag_eq {e : μ ≃+ μ'} {s : Finset ι} {n : μ} :\n    (finsuppAntidiag s n).map (mapRange.addEquiv e).toEmbedding = finsuppAntidiag s (e n) := by\n  ext f\n  constructor\n  · apply mapRange_finsuppAntidiag_subset\n  · set h := (mapRange.addEquiv e).toEquiv with hh\n    intro hf\n    have : n = e.symm (e n) := (AddEquiv.eq_symm_apply e).mpr rfl\n    rw [mem_map_equiv, this]\n    apply mapRange_finsuppAntidiag_subset\n    rw [← mem_map_equiv]\n    convert hf\n    rw [map_map, hh]\n    convert map_refl\n    apply Function.Embedding.equiv_symm_toEmbedding_trans_toEmbedding\n\n"}
{"name":"Finset.finsuppAntidiag_zero","module":"Mathlib.Algebra.Order.Antidiag.Finsupp","initialProofState":"ι : Type u_1\nμ : Type u_2\ninst✝⁴ : DecidableEq ι\ninst✝³ : DecidableEq μ\ninst✝² : OrderedAddCommMonoid μ\ninst✝¹ : CanonicallyOrderedAdd μ\ninst✝ : Finset.HasAntidiagonal μ\ns : Finset ι\n⊢ Eq (s.finsuppAntidiag 0) (Singleton.singleton 0)","decl":"@[simp] lemma finsuppAntidiag_zero (s : Finset ι) : finsuppAntidiag s (0 : μ) = {0} := by\n  ext f; simp [finsuppAntidiag, ← DFunLike.coe_fn_eq (g := f), -mem_piAntidiag, eq_comm]\n\n"}
