{"name":"Submodule.finite_quotient_smul","module":"Mathlib.RingTheory.Ideal.Quotient.Index","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nI : Ideal R\nN : Submodule R M\ninst✝¹ : Finite (HasQuotient.Quotient R I)\ninst✝ : Finite (HasQuotient.Quotient M N)\nhN : N.FG\n⊢ Finite (HasQuotient.Quotient M (HSMul.hSMul I N))","decl":"open TensorProduct in\n/-- Let `N` be a finite index f.g. `R`-submodule, and `I` be a finite index ideal.\nThen `I • N` also has finite index. -/\nlemma Submodule.finite_quotient_smul [Finite (R ⧸ I)] [Finite (M ⧸ N)] (hN : N.FG) :\n    Finite (M ⧸ I • N) := by\n  suffices (I • N).toAddSubgroup.FiniteIndex by\n    exact (I • N).toAddSubgroup.finite_quotient_of_finiteIndex\n  suffices Nat.card (N ⧸ (I • N).comap N.subtype) ≠ 0 by\n    constructor\n    rw [← AddSubgroup.relindex_mul_index\n      (H := (I • N).toAddSubgroup) (K := N.toAddSubgroup) Submodule.smul_le_right]\n    have inst : Finite (M ⧸ N.toAddSubgroup) := ‹_›\n    exact mul_ne_zero this AddSubgroup.index_ne_zero_of_finite\n  let e : (N ⧸ (I • N).comap N.subtype) ≃ₗ[R] (R ⧸ I) ⊗[R] N :=\n    Submodule.quotEquivOfEq _ (I • (⊤ : Submodule R N)) (Submodule.map_injective_of_injective\n      N.injective_subtype (by simp [Submodule.smul_le_right])) ≪≫ₗ\n        (quotTensorEquivQuotSMul N I).symm\n  rw [Nat.card_congr e.toEquiv]\n  have : Module.Finite R N := Module.Finite.iff_fg.mpr hN\n  have : Finite ((R ⧸ I) ⊗[R] N) := Module.finite_of_finite (R ⧸ I)\n  exact Nat.card_pos.ne'\n\n-- We have `hs` and `N` instead of using `span R s` in the goal to make it easier to use.\n-- Usually we would like to bound the index of some abstract `I • N`, and we may construct `s` while\n-- applying this lemma instead of having to provide it beforehand.\n"}
{"name":"Submodule.index_smul_le","module":"Mathlib.RingTheory.Ideal.Quotient.Index","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nI : Ideal R\nN : Submodule R M\ninst✝ : Finite (HasQuotient.Quotient R I)\ns : Finset M\nhs : Eq (Submodule.span R ↑s) N\n⊢ LE.le (HSMul.hSMul I N).toAddSubgroup.index (HMul.hMul (HPow.hPow (Submodule.toAddSubgroup I).index s.card) N.toAddSubgroup.index)","decl":"open TensorProduct in\nlemma Submodule.index_smul_le [Finite (R ⧸ I)]\n    (s : Finset M) (hs : Submodule.span R s = N) :\n    (I • N).toAddSubgroup.index ≤ I.toAddSubgroup.index ^ s.card * N.toAddSubgroup.index := by\n  classical\n  cases nonempty_fintype (R ⧸ I)\n  rw [← AddSubgroup.relindex_mul_index\n    (H := (I • N).toAddSubgroup) (K := N.toAddSubgroup) Submodule.smul_le_right]\n  gcongr\n  show (Nat.card (N ⧸ (I • N).comap N.subtype)) ≤ Nat.card (R ⧸ I) ^ s.card\n  let e : (N ⧸ (I • N).comap N.subtype) ≃ₗ[R] (R ⧸ I) ⊗[R] N :=\n    Submodule.quotEquivOfEq _ (I • (⊤ : Submodule R N)) (Submodule.map_injective_of_injective\n      N.injective_subtype (by simp [Submodule.smul_le_right])) ≪≫ₗ\n      (quotTensorEquivQuotSMul N I).symm\n  rw [Nat.card_congr e.toEquiv]\n  have H : LinearMap.range (Finsupp.linearCombination R (α := s) (↑)) = N := by\n    rw [Finsupp.range_linearCombination, ← hs, Subtype.range_val]; rfl\n  let f : (s →₀ R) →ₗ[R] N := (Finsupp.linearCombination R (↑)).codRestrict _\n    (Set.range_subset_iff (s := N.carrier).mp <| by exact H.le)\n  have hf : Function.Surjective f := fun x ↦ by\n    obtain ⟨y, hy⟩ := H.ge x.2; exact ⟨y, Subtype.ext hy⟩\n  have : Function.Surjective\n      (f.lTensor (R ⧸ I) ∘ₗ (finsuppScalarRight R (R ⧸ I) s).symm.toLinearMap) :=\n    (LinearMap.lTensor_surjective (R ⧸ I) hf).comp (LinearEquiv.surjective _)\n  refine (Nat.card_le_card_of_surjective _ this).trans ?_\n  simp only [Nat.card_eq_fintype_card, Fintype.card_finsupp, Fintype.card_coe, le_rfl]\n\n"}
{"name":"Ideal.finite_quotient_pow","module":"Mathlib.RingTheory.Ideal.Quotient.Index","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Ideal R\nhI : I.FG\ninst✝ : Finite (HasQuotient.Quotient R I)\nn : Nat\n⊢ Finite (HasQuotient.Quotient R (HPow.hPow I n))","decl":"lemma Ideal.finite_quotient_pow (hI : I.FG) [Finite (R ⧸ I)] (n) : Finite (R ⧸ I ^ n) := by\n  induction n with\n  | zero =>\n    simp only [pow_zero, Ideal.one_eq_top]\n    infer_instance\n  | succ n _ =>\n    exact Submodule.finite_quotient_smul (I ^ n) hI\n\n"}
{"name":"Ideal.index_pow_le","module":"Mathlib.RingTheory.Ideal.Quotient.Index","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Ideal R\ns : Finset R\nhs : Eq (Ideal.span ↑s) I\ninst✝ : Finite (HasQuotient.Quotient R I)\nn : Nat\n⊢ LE.le (Submodule.toAddSubgroup (HPow.hPow I n)).index (HPow.hPow (Submodule.toAddSubgroup I).index ((Finset.range n).sum fun i => HPow.hPow s.card i))","decl":"lemma Ideal.index_pow_le\n    (s : Finset R) (hs : Ideal.span s = I) [Finite (R ⧸ I)] (n) :\n    (I ^ n).toAddSubgroup.index ≤ I.toAddSubgroup.index ^ ∑ i ∈ Finset.range n, s.card ^ i := by\n  have := Ideal.finite_quotient_pow ⟨s, hs⟩\n  induction n with\n  | zero =>\n    simp\n  | succ n IH =>\n    refine (Submodule.index_smul_le (I ^ n) s hs).trans ?_\n    refine (Nat.mul_le_mul (Nat.pow_le_pow_left IH _) le_rfl).trans ?_\n    rw [← pow_mul, ← pow_succ, geom_sum_succ, mul_comm]\n"}
