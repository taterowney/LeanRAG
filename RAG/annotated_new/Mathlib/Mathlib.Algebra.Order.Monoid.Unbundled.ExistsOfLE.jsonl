{"name":"ExistsAddOfLE.exists_add_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝¹ : Add α\ninst✝ : LE α\nself : ExistsAddOfLE α\na b : α\na✝ : LE.le a b\n⊢ Exists fun c => Eq b (HAdd.hAdd a c)","decl":"/-- An `OrderedAddCommMonoid` with one-sided 'subtraction' in the sense that\nif `a ≤ b`, then there is some `c` for which `a + c = b`. This is a weaker version\nof the condition on canonical orderings defined by `CanonicallyOrderedAddCommMonoid`. -/\nclass ExistsAddOfLE (α : Type u) [Add α] [LE α] : Prop where\n  /-- For `a ≤ b`, there is a `c` so `b = a + c`. -/\n  exists_add_of_le : ∀ {a b : α}, a ≤ b → ∃ c : α, b = a + c\n\n"}
{"name":"ExistsMulOfLE.exists_mul_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝¹ : Mul α\ninst✝ : LE α\nself : ExistsMulOfLE α\na b : α\na✝ : LE.le a b\n⊢ Exists fun c => Eq b (HMul.hMul a c)","decl":"/-- An `OrderedCommMonoid` with one-sided 'division' in the sense that\nif `a ≤ b`, there is some `c` for which `a * c = b`. This is a weaker version\nof the condition on canonical orderings defined by `CanonicallyOrderedCommMonoid`. -/\n@[to_additive]\nclass ExistsMulOfLE (α : Type u) [Mul α] [LE α] : Prop where\n  /-- For `a ≤ b`, `a` left divides `b` -/\n  exists_mul_of_le : ∀ {a b : α}, a ≤ b → ∃ c : α, b = a * c\n\n"}
{"name":"Group.existsMulOfLE","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝¹ : Group α\ninst✝ : LE α\n⊢ ExistsMulOfLE α","decl":"@[to_additive]\ninstance (priority := 100) Group.existsMulOfLE (α : Type u) [Group α] [LE α] : ExistsMulOfLE α :=\n  ⟨fun {a b} _ => ⟨a⁻¹ * b, (mul_inv_cancel_left _ _).symm⟩⟩\n\n"}
{"name":"AddGroup.existsAddOfLE","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝¹ : AddGroup α\ninst✝ : LE α\n⊢ ExistsAddOfLE α","decl":"@[to_additive]\ninstance (priority := 100) Group.existsMulOfLE (α : Type u) [Group α] [LE α] : ExistsMulOfLE α :=\n  ⟨fun {a b} _ => ⟨a⁻¹ * b, (mul_inv_cancel_left _ _).symm⟩⟩\n\n"}
{"name":"exists_one_le_mul_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝³ : MulOneClass α\ninst✝² : Preorder α\ninst✝¹ : ExistsMulOfLE α\na b : α\ninst✝ : MulLeftReflectLE α\nh : LE.le a b\n⊢ Exists fun c => And (LE.le 1 c) (Eq (HMul.hMul a c) b)","decl":"@[to_additive] lemma exists_one_le_mul_of_le [MulLeftReflectLE α] (h : a ≤ b) :\n    ∃ c, 1 ≤ c ∧ a * c = b := by\n  obtain ⟨c, rfl⟩ := exists_mul_of_le h; exact ⟨c, one_le_of_le_mul_right h, rfl⟩\n\n"}
{"name":"exists_nonneg_add_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝³ : AddZeroClass α\ninst✝² : Preorder α\ninst✝¹ : ExistsAddOfLE α\na b : α\ninst✝ : AddLeftReflectLE α\nh : LE.le a b\n⊢ Exists fun c => And (LE.le 0 c) (Eq (HAdd.hAdd a c) b)","decl":"@[to_additive] lemma exists_one_le_mul_of_le [MulLeftReflectLE α] (h : a ≤ b) :\n    ∃ c, 1 ≤ c ∧ a * c = b := by\n  obtain ⟨c, rfl⟩ := exists_mul_of_le h; exact ⟨c, one_le_of_le_mul_right h, rfl⟩\n\n"}
{"name":"exists_one_lt_mul_of_lt'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝³ : MulOneClass α\ninst✝² : Preorder α\ninst✝¹ : ExistsMulOfLE α\na b : α\ninst✝ : MulLeftReflectLT α\nh : LT.lt a b\n⊢ Exists fun c => And (LT.lt 1 c) (Eq (HMul.hMul a c) b)","decl":"@[to_additive] lemma exists_one_lt_mul_of_lt' [MulLeftReflectLT α] (h : a < b) :\n    ∃ c, 1 < c ∧ a * c = b := by\n  obtain ⟨c, rfl⟩ := exists_mul_of_le h.le; exact ⟨c, one_lt_of_lt_mul_right h, rfl⟩\n\n"}
{"name":"exists_pos_add_of_lt'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝³ : AddZeroClass α\ninst✝² : Preorder α\ninst✝¹ : ExistsAddOfLE α\na b : α\ninst✝ : AddLeftReflectLT α\nh : LT.lt a b\n⊢ Exists fun c => And (LT.lt 0 c) (Eq (HAdd.hAdd a c) b)","decl":"@[to_additive] lemma exists_one_lt_mul_of_lt' [MulLeftReflectLT α] (h : a < b) :\n    ∃ c, 1 < c ∧ a * c = b := by\n  obtain ⟨c, rfl⟩ := exists_mul_of_le h.le; exact ⟨c, one_lt_of_lt_mul_right h, rfl⟩\n\n"}
{"name":"le_iff_exists_one_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁴ : MulOneClass α\ninst✝³ : Preorder α\ninst✝² : ExistsMulOfLE α\na b : α\ninst✝¹ : MulLeftMono α\ninst✝ : MulLeftReflectLE α\n⊢ Iff (LE.le a b) (Exists fun c => And (LE.le 1 c) (Eq (HMul.hMul a c) b))","decl":"@[to_additive] lemma le_iff_exists_one_le_mul [MulLeftMono α]\n    [MulLeftReflectLE α] : a ≤ b ↔ ∃ c, 1 ≤ c ∧ a * c = b :=\n  ⟨exists_one_le_mul_of_le, by rintro ⟨c, hc, rfl⟩; exact le_mul_of_one_le_right' hc⟩\n\n"}
{"name":"le_iff_exists_nonneg_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁴ : AddZeroClass α\ninst✝³ : Preorder α\ninst✝² : ExistsAddOfLE α\na b : α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\n⊢ Iff (LE.le a b) (Exists fun c => And (LE.le 0 c) (Eq (HAdd.hAdd a c) b))","decl":"@[to_additive] lemma le_iff_exists_one_le_mul [MulLeftMono α]\n    [MulLeftReflectLE α] : a ≤ b ↔ ∃ c, 1 ≤ c ∧ a * c = b :=\n  ⟨exists_one_le_mul_of_le, by rintro ⟨c, hc, rfl⟩; exact le_mul_of_one_le_right' hc⟩\n\n"}
{"name":"lt_iff_exists_pos_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁴ : AddZeroClass α\ninst✝³ : Preorder α\ninst✝² : ExistsAddOfLE α\na b : α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddLeftReflectLT α\n⊢ Iff (LT.lt a b) (Exists fun c => And (LT.lt 0 c) (Eq (HAdd.hAdd a c) b))","decl":"@[to_additive] lemma lt_iff_exists_one_lt_mul [MulLeftStrictMono α]\n    [MulLeftReflectLT α] : a < b ↔ ∃ c, 1 < c ∧ a * c = b :=\n  ⟨exists_one_lt_mul_of_lt', by rintro ⟨c, hc, rfl⟩; exact lt_mul_of_one_lt_right' _ hc⟩\n\n"}
{"name":"lt_iff_exists_one_lt_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁴ : MulOneClass α\ninst✝³ : Preorder α\ninst✝² : ExistsMulOfLE α\na b : α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulLeftReflectLT α\n⊢ Iff (LT.lt a b) (Exists fun c => And (LT.lt 1 c) (Eq (HMul.hMul a c) b))","decl":"@[to_additive] lemma lt_iff_exists_one_lt_mul [MulLeftStrictMono α]\n    [MulLeftReflectLT α] : a < b ↔ ∃ c, 1 < c ∧ a * c = b :=\n  ⟨exists_one_lt_mul_of_lt', by rintro ⟨c, hc, rfl⟩; exact lt_mul_of_one_lt_right' _ hc⟩\n\n"}
{"name":"le_of_forall_one_lt_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁴ : LinearOrder α\ninst✝³ : DenselyOrdered α\ninst✝² : Monoid α\ninst✝¹ : ExistsMulOfLE α\ninst✝ : MulLeftReflectLT α\na b : α\nh : ∀ (ε : α), LT.lt 1 ε → LE.le a (HMul.hMul b ε)\n⊢ LE.le a b","decl":"@[to_additive]\ntheorem le_of_forall_one_lt_le_mul (h : ∀ ε : α, 1 < ε → a ≤ b * ε) : a ≤ b :=\n  le_of_forall_gt_imp_ge_of_dense fun x hxb => by\n    obtain ⟨ε, rfl⟩ := exists_mul_of_le hxb.le\n    exact h _ (one_lt_of_lt_mul_right hxb)\n\n"}
{"name":"le_of_forall_pos_le_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁴ : LinearOrder α\ninst✝³ : DenselyOrdered α\ninst✝² : AddMonoid α\ninst✝¹ : ExistsAddOfLE α\ninst✝ : AddLeftReflectLT α\na b : α\nh : ∀ (ε : α), LT.lt 0 ε → LE.le a (HAdd.hAdd b ε)\n⊢ LE.le a b","decl":"@[to_additive]\ntheorem le_of_forall_one_lt_le_mul (h : ∀ ε : α, 1 < ε → a ≤ b * ε) : a ≤ b :=\n  le_of_forall_gt_imp_ge_of_dense fun x hxb => by\n    obtain ⟨ε, rfl⟩ := exists_mul_of_le hxb.le\n    exact h _ (one_lt_of_lt_mul_right hxb)\n\n"}
{"name":"le_of_forall_pos_lt_add'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁴ : LinearOrder α\ninst✝³ : DenselyOrdered α\ninst✝² : AddMonoid α\ninst✝¹ : ExistsAddOfLE α\ninst✝ : AddLeftReflectLT α\na b : α\nh : ∀ (ε : α), LT.lt 0 ε → LT.lt a (HAdd.hAdd b ε)\n⊢ LE.le a b","decl":"@[to_additive]\ntheorem le_of_forall_one_lt_lt_mul' (h : ∀ ε : α, 1 < ε → a < b * ε) : a ≤ b :=\n  le_of_forall_one_lt_le_mul fun ε hε => (h ε hε).le\n\n"}
{"name":"le_of_forall_one_lt_lt_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁴ : LinearOrder α\ninst✝³ : DenselyOrdered α\ninst✝² : Monoid α\ninst✝¹ : ExistsMulOfLE α\ninst✝ : MulLeftReflectLT α\na b : α\nh : ∀ (ε : α), LT.lt 1 ε → LT.lt a (HMul.hMul b ε)\n⊢ LE.le a b","decl":"@[to_additive]\ntheorem le_of_forall_one_lt_lt_mul' (h : ∀ ε : α, 1 < ε → a < b * ε) : a ≤ b :=\n  le_of_forall_one_lt_le_mul fun ε hε => (h ε hε).le\n\n"}
{"name":"le_iff_forall_one_lt_lt_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁵ : LinearOrder α\ninst✝⁴ : DenselyOrdered α\ninst✝³ : Monoid α\ninst✝² : ExistsMulOfLE α\ninst✝¹ : MulLeftReflectLT α\na b : α\ninst✝ : MulLeftStrictMono α\n⊢ Iff (LE.le a b) (∀ (ε : α), LT.lt 1 ε → LT.lt a (HMul.hMul b ε))","decl":"@[to_additive]\ntheorem le_iff_forall_one_lt_lt_mul' [MulLeftStrictMono α] :\n    a ≤ b ↔ ∀ ε, 1 < ε → a < b * ε :=\n  ⟨fun h _ => lt_mul_of_le_of_one_lt h, le_of_forall_one_lt_lt_mul'⟩\n\n"}
{"name":"le_iff_forall_pos_lt_add'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁵ : LinearOrder α\ninst✝⁴ : DenselyOrdered α\ninst✝³ : AddMonoid α\ninst✝² : ExistsAddOfLE α\ninst✝¹ : AddLeftReflectLT α\na b : α\ninst✝ : AddLeftStrictMono α\n⊢ Iff (LE.le a b) (∀ (ε : α), LT.lt 0 ε → LT.lt a (HAdd.hAdd b ε))","decl":"@[to_additive]\ntheorem le_iff_forall_one_lt_lt_mul' [MulLeftStrictMono α] :\n    a ≤ b ↔ ∀ ε, 1 < ε → a < b * ε :=\n  ⟨fun h _ => lt_mul_of_le_of_one_lt h, le_of_forall_one_lt_lt_mul'⟩\n\n"}
{"name":"le_iff_forall_one_lt_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁵ : LinearOrder α\ninst✝⁴ : DenselyOrdered α\ninst✝³ : Monoid α\ninst✝² : ExistsMulOfLE α\ninst✝¹ : MulLeftReflectLT α\na b : α\ninst✝ : MulLeftStrictMono α\n⊢ Iff (LE.le a b) (∀ (ε : α), LT.lt 1 ε → LE.le a (HMul.hMul b ε))","decl":"@[to_additive]\ntheorem le_iff_forall_one_lt_le_mul [MulLeftStrictMono α] :\n    a ≤ b ↔ ∀ ε, 1 < ε → a ≤ b * ε :=\n  ⟨fun h _ hε ↦ lt_mul_of_le_of_one_lt h hε |>.le, le_of_forall_one_lt_le_mul⟩\n\n"}
{"name":"le_iff_forall_pos_le_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.ExistsOfLE","initialProofState":"α : Type u\ninst✝⁵ : LinearOrder α\ninst✝⁴ : DenselyOrdered α\ninst✝³ : AddMonoid α\ninst✝² : ExistsAddOfLE α\ninst✝¹ : AddLeftReflectLT α\na b : α\ninst✝ : AddLeftStrictMono α\n⊢ Iff (LE.le a b) (∀ (ε : α), LT.lt 0 ε → LE.le a (HAdd.hAdd b ε))","decl":"@[to_additive]\ntheorem le_iff_forall_one_lt_le_mul [MulLeftStrictMono α] :\n    a ≤ b ↔ ∀ ε, 1 < ε → a ≤ b * ε :=\n  ⟨fun h _ hε ↦ lt_mul_of_le_of_one_lt h hε |>.le, le_of_forall_one_lt_le_mul⟩\n\n"}
