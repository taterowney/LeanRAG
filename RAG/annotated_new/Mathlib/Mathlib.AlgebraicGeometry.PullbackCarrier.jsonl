{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.mk.injEq","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx✝ : ↑↑X.toPresheafedSpace\ny✝ : ↑↑Y.toPresheafedSpace\ns✝ : ↑↑S.toPresheafedSpace\nhx✝ : Eq (f.base x✝) s✝\nhy✝ : Eq (g.base y✝) s✝\nx : ↑↑X.toPresheafedSpace\ny : ↑↑Y.toPresheafedSpace\ns : ↑↑S.toPresheafedSpace\nhx : Eq (f.base x) s\nhy : Eq (g.base y) s\n⊢ Eq (Eq { x := x✝, y := y✝, s := s✝, hx := hx✝, hy := hy✝ } { x := x, y := y, s := s, hx := hx, hy := hy }) (And (Eq x✝ x) (And (Eq y✝ y) (Eq s✝ s)))","decl":"/-- A `Triplet` over `f : X ⟶ S` and `g : Y ⟶ S` is a triple of points `x : X`, `y : Y`,\n`s : S` such that `f x = s = f y`. -/\nstructure Triplet {X Y S : Scheme.{u}} (f : X ⟶ S) (g : Y ⟶ S) where\n  /-- The point of `X`. -/\n  x : X\n  /-- The point of `Y`. -/\n  y : Y\n  /-- The point of `S` below `x` and `y`. -/\n  s : S\n  hx : f.base x = s\n  hy : g.base y = s\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.hy","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nself : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ Eq (g.base self.y) self.s","decl":"/-- A `Triplet` over `f : X ⟶ S` and `g : Y ⟶ S` is a triple of points `x : X`, `y : Y`,\n`s : S` such that `f x = s = f y`. -/\nstructure Triplet {X Y S : Scheme.{u}} (f : X ⟶ S) (g : Y ⟶ S) where\n  /-- The point of `X`. -/\n  x : X\n  /-- The point of `Y`. -/\n  y : Y\n  /-- The point of `S` below `x` and `y`. -/\n  s : S\n  hx : f.base x = s\n  hy : g.base y = s\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.mk.inj","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx✝¹ : ↑↑X.toPresheafedSpace\ny✝ : ↑↑Y.toPresheafedSpace\ns✝ : ↑↑S.toPresheafedSpace\nhx✝ : Eq (f.base x✝¹) s✝\nhy✝ : Eq (g.base y✝) s✝\nx : ↑↑X.toPresheafedSpace\ny : ↑↑Y.toPresheafedSpace\ns : ↑↑S.toPresheafedSpace\nhx : Eq (f.base x) s\nhy : Eq (g.base y) s\nx✝ : Eq { x := x✝¹, y := y✝, s := s✝, hx := hx✝, hy := hy✝ } { x := x, y := y, s := s, hx := hx, hy := hy }\n⊢ And (Eq x✝¹ x) (And (Eq y✝ y) (Eq s✝ s))","decl":"/-- A `Triplet` over `f : X ⟶ S` and `g : Y ⟶ S` is a triple of points `x : X`, `y : Y`,\n`s : S` such that `f x = s = f y`. -/\nstructure Triplet {X Y S : Scheme.{u}} (f : X ⟶ S) (g : Y ⟶ S) where\n  /-- The point of `X`. -/\n  x : X\n  /-- The point of `Y`. -/\n  y : Y\n  /-- The point of `S` below `x` and `y`. -/\n  s : S\n  hx : f.base x = s\n  hy : g.base y = s\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.hx","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nself : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ Eq (f.base self.x) self.s","decl":"/-- A `Triplet` over `f : X ⟶ S` and `g : Y ⟶ S` is a triple of points `x : X`, `y : Y`,\n`s : S` such that `f x = s = f y`. -/\nstructure Triplet {X Y S : Scheme.{u}} (f : X ⟶ S) (g : Y ⟶ S) where\n  /-- The point of `X`. -/\n  x : X\n  /-- The point of `Y`. -/\n  y : Y\n  /-- The point of `S` below `x` and `y`. -/\n  s : S\n  hx : f.base x = s\n  hy : g.base y = s\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx : ↑↑X.toPresheafedSpace\ny : ↑↑Y.toPresheafedSpace\ns : ↑↑S.toPresheafedSpace\nhx : Eq (f.base x) s\nhy : Eq (g.base y) s\n⊢ Eq (SizeOf.sizeOf { x := x, y := y, s := s, hx := hx, hy := hy }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf x)) (SizeOf.sizeOf y)) (SizeOf.sizeOf s)) (SizeOf.sizeOf hx)) (SizeOf.sizeOf hy))","decl":"/-- A `Triplet` over `f : X ⟶ S` and `g : Y ⟶ S` is a triple of points `x : X`, `y : Y`,\n`s : S` such that `f x = s = f y`. -/\nstructure Triplet {X Y S : Scheme.{u}} (f : X ⟶ S) (g : Y ⟶ S) where\n  /-- The point of `X`. -/\n  x : X\n  /-- The point of `Y`. -/\n  y : Y\n  /-- The point of `S` below `x` and `y`. -/\n  s : S\n  hx : f.base x = s\n  hy : g.base y = s\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.ext_iff","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nt₁ t₂ : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ Iff (Eq t₁ t₂) (And (Eq t₁.x t₂.x) (Eq t₁.y t₂.y))","decl":"@[ext]\nprotected lemma ext {t₁ t₂ : Triplet f g} (ex : t₁.x = t₂.x) (ey : t₁.y = t₂.y) : t₁ = t₂ := by\n  cases t₁; cases t₂; simp; aesop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.ext","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nt₁ t₂ : AlgebraicGeometry.Scheme.Pullback.Triplet f g\nex : Eq t₁.x t₂.x\ney : Eq t₁.y t₂.y\n⊢ Eq t₁ t₂","decl":"@[ext]\nprotected lemma ext {t₁ t₂ : Triplet f g} (ex : t₁.x = t₂.x) (ey : t₁.y = t₂.y) : t₁ = t₂ := by\n  cases t₁; cases t₂; simp; aesop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.mk'_s","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx : ↑↑X.toPresheafedSpace\ny : ↑↑Y.toPresheafedSpace\nh : Eq (f.base x) (g.base y)\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.mk' x y h).s (g.base y)","decl":"/-- Make a triplet from `x : X` and `y : Y` such that `f x = g y`. -/\n@[simps]\ndef mk' (x : X) (y : Y) (h : f.base x = g.base y) : Triplet f g where\n  x := x\n  y := y\n  s := g.base y\n  hx := h\n  hy := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.mk'_y","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx : ↑↑X.toPresheafedSpace\ny : ↑↑Y.toPresheafedSpace\nh : Eq (f.base x) (g.base y)\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.mk' x y h).y y","decl":"/-- Make a triplet from `x : X` and `y : Y` such that `f x = g y`. -/\n@[simps]\ndef mk' (x : X) (y : Y) (h : f.base x = g.base y) : Triplet f g where\n  x := x\n  y := y\n  s := g.base y\n  hx := h\n  hy := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.mk'_x","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx : ↑↑X.toPresheafedSpace\ny : ↑↑Y.toPresheafedSpace\nh : Eq (f.base x) (g.base y)\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.mk' x y h).x x","decl":"/-- Make a triplet from `x : X` and `y : Y` such that `f x = g y`. -/\n@[simps]\ndef mk' (x : X) (y : Y) (h : f.base x = g.base y) : Triplet f g where\n  x := x\n  y := y\n  s := g.base y\n  hx := h\n  hy := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.instNontrivialCarrierTensor","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ Nontrivial ↑T.tensor","decl":"instance (T : Triplet f g) : Nontrivial T.tensor :=\n  CommRingCat.nontrivial_of_isPushout_of_isField (Field.toIsField _)\n    (IsPushout.of_hasPushout _ _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.Spec_map_tensor_isPullback","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ CategoryTheory.IsPullback (AlgebraicGeometry.Spec.map T.tensorInl) (AlgebraicGeometry.Spec.map T.tensorInr) (AlgebraicGeometry.Spec.map (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.residueFieldCongr ⋯).inv (AlgebraicGeometry.Scheme.Hom.residueFieldMap f T.x))) (AlgebraicGeometry.Spec.map (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.residueFieldCongr ⋯).inv (AlgebraicGeometry.Scheme.Hom.residueFieldMap g T.y)))","decl":"lemma Spec_map_tensor_isPullback (T : Triplet f g) : CategoryTheory.IsPullback\n    (Spec.map T.tensorInl) (Spec.map T.tensorInr)\n        (Spec.map ((S.residueFieldCongr T.hx).inv ≫ f.residueFieldMap T.x))\n          (Spec.map ((S.residueFieldCongr T.hy).inv ≫ g.residueFieldMap T.y)) :=\n  isPullback_Spec_map_pushout _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr_refl","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr ⋯) (CategoryTheory.Iso.refl x.tensor)","decl":"@[simp]\nlemma tensorCongr_refl {x : Triplet f g} :\n    tensorCongr (refl x) = Iso.refl _ := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr_symm","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx y : AlgebraicGeometry.Scheme.Pullback.Triplet f g\ne : Eq x y\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr e).symm (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr ⋯)","decl":"@[simp]\nlemma tensorCongr_symm {x y : Triplet f g} (e : x = y) :\n    (tensorCongr e).symm = tensorCongr e.symm := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr_inv","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx y : AlgebraicGeometry.Scheme.Pullback.Triplet f g\ne : Eq x y\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr e).inv (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr ⋯).hom","decl":"@[simp]\nlemma tensorCongr_inv {x y : Triplet f g} (e : x = y) :\n    (tensorCongr e).inv = (tensorCongr e.symm).hom := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr_trans","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx y z : AlgebraicGeometry.Scheme.Pullback.Triplet f g\ne : Eq x y\ne' : Eq y z\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr e).trans (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr e')) (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr ⋯)","decl":"@[simp]\nlemma tensorCongr_trans {x y z : Triplet f g} (e : x = y) (e' : y = z) :\n    tensorCongr e ≪≫ tensorCongr e' =\n      tensorCongr (e.trans e') := by\n  subst e e'\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr_trans_hom","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx y z : AlgebraicGeometry.Scheme.Pullback.Triplet f g\ne : Eq x y\ne' : Eq y z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr e).hom (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr e').hom) (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr ⋯).hom","decl":"@[reassoc (attr := simp)]\nlemma tensorCongr_trans_hom {x y z : Triplet f g} (e : x = y) (e' : y = z) :\n    (tensorCongr e).hom ≫ (tensorCongr e').hom =\n      (tensorCongr (e.trans e')).hom := by\n  subst e e'\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr_trans_hom_assoc","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx y z : AlgebraicGeometry.Scheme.Pullback.Triplet f g\ne : Eq x y\ne' : Eq y z\nZ : CommRingCat\nh : Quiver.Hom z.tensor Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr e).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr e').hom h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr ⋯).hom h)","decl":"@[reassoc (attr := simp)]\nlemma tensorCongr_trans_hom {x y z : Triplet f g} (e : x = y) (e' : y = z) :\n    (tensorCongr e).hom ≫ (tensorCongr e').hom =\n      (tensorCongr (e.trans e')).hom := by\n  subst e e'\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.Spec_map_tensorInl_fromSpecResidueField","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map T.tensorInl) (X.fromSpecResidueField T.x)) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map T.tensorInr) (Y.fromSpecResidueField T.y)) g)","decl":"lemma Spec_map_tensorInl_fromSpecResidueField :\n    (Spec.map T.tensorInl ≫ X.fromSpecResidueField T.x) ≫ f =\n      (Spec.map T.tensorInr ≫ Y.fromSpecResidueField T.y) ≫ g := by\n  simp only [residueFieldCongr_inv, Category.assoc, tensorInl, tensorInr,\n    ← Hom.Spec_map_residueFieldMap_fromSpecResidueField]\n  rw [← residueFieldCongr_fromSpecResidueField T.hx.symm,\n    ← residueFieldCongr_fromSpecResidueField T.hy.symm]\n  simp only [← Category.assoc, ← Spec.map_comp, pushout.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.specTensorTo_base_fst","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\np : ↑↑(AlgebraicGeometry.Spec T.tensor).toPresheafedSpace\n⊢ Eq ((CategoryTheory.Limits.pullback.fst f g).base (T.SpecTensorTo.base p)) T.x","decl":"@[simp]\nlemma specTensorTo_base_fst (p : Spec T.tensor) :\n    (pullback.fst f g).base (T.SpecTensorTo.base p) = T.x := by\n  simp only [SpecTensorTo, residueFieldCongr_inv]\n  rw [← Scheme.comp_base_apply]\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.specTensorTo_base_snd","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\np : ↑↑(AlgebraicGeometry.Spec T.tensor).toPresheafedSpace\n⊢ Eq ((CategoryTheory.Limits.pullback.snd f g).base (T.SpecTensorTo.base p)) T.y","decl":"@[simp]\nlemma specTensorTo_base_snd (p : Spec T.tensor) :\n    (pullback.snd f g).base (T.SpecTensorTo.base p) = T.y := by\n  simp only [SpecTensorTo, residueFieldCongr_inv]\n  rw [← Scheme.comp_base_apply]\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.specTensorTo_fst","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.SpecTensorTo (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map T.tensorInl) (X.fromSpecResidueField T.x))","decl":"@[reassoc (attr := simp)]\nlemma specTensorTo_fst :\n    T.SpecTensorTo ≫ pullback.fst f g = Spec.map T.tensorInl ≫ X.fromSpecResidueField T.x :=\n  pullback.lift_fst _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.specTensorTo_fst_assoc","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.SpecTensorTo (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map T.tensorInl) (CategoryTheory.CategoryStruct.comp (X.fromSpecResidueField T.x) h))","decl":"@[reassoc (attr := simp)]\nlemma specTensorTo_fst :\n    T.SpecTensorTo ≫ pullback.fst f g = Spec.map T.tensorInl ≫ X.fromSpecResidueField T.x :=\n  pullback.lift_fst _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.specTensorTo_snd","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.SpecTensorTo (CategoryTheory.Limits.pullback.snd f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map T.tensorInr) (Y.fromSpecResidueField T.y))","decl":"@[reassoc (attr := simp)]\nlemma specTensorTo_snd :\n    T.SpecTensorTo ≫ pullback.snd f g = Spec.map T.tensorInr ≫ Y.fromSpecResidueField T.y :=\n  pullback.lift_snd _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.specTensorTo_snd_assoc","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp T.SpecTensorTo (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map T.tensorInr) (CategoryTheory.CategoryStruct.comp (Y.fromSpecResidueField T.y) h))","decl":"@[reassoc (attr := simp)]\nlemma specTensorTo_snd :\n    T.SpecTensorTo ≫ pullback.snd f g = Spec.map T.tensorInr ≫ Y.fromSpecResidueField T.y :=\n  pullback.lift_snd _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint_y","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nt : ↑↑(CategoryTheory.Limits.pullback f g).toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint t).y ((CategoryTheory.Limits.pullback.snd f g).base t)","decl":"/-- Given `t : X ×[S] Y`, it maps to `X` and `Y` with same image in `S`, yielding a\n`Triplet f g`. -/\n@[simps]\ndef ofPoint (t : ↑(pullback f g)) : Triplet f g :=\n  ⟨(pullback.fst f g).base t, (pullback.snd f g).base t, _, rfl,\n    congr((Scheme.Hom.toLRSHom $(pullback.condition (f := f) (g := g))).base t).symm⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint_s","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nt : ↑↑(CategoryTheory.Limits.pullback f g).toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint t).s (f.base ((CategoryTheory.Limits.pullback.fst f g).base t))","decl":"/-- Given `t : X ×[S] Y`, it maps to `X` and `Y` with same image in `S`, yielding a\n`Triplet f g`. -/\n@[simps]\ndef ofPoint (t : ↑(pullback f g)) : Triplet f g :=\n  ⟨(pullback.fst f g).base t, (pullback.snd f g).base t, _, rfl,\n    congr((Scheme.Hom.toLRSHom $(pullback.condition (f := f) (g := g))).base t).symm⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint_x","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nt : ↑↑(CategoryTheory.Limits.pullback f g).toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint t).x ((CategoryTheory.Limits.pullback.fst f g).base t)","decl":"/-- Given `t : X ×[S] Y`, it maps to `X` and `Y` with same image in `S`, yielding a\n`Triplet f g`. -/\n@[simps]\ndef ofPoint (t : ↑(pullback f g)) : Triplet f g :=\n  ⟨(pullback.fst f g).base t, (pullback.snd f g).base t, _, rfl,\n    congr((Scheme.Hom.toLRSHom $(pullback.condition (f := f) (g := g))).base t).symm⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint_SpecTensorTo","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\np : ↑↑(AlgebraicGeometry.Spec T.tensor).toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint (T.SpecTensorTo.base p)) T","decl":"@[simp]\nlemma ofPoint_SpecTensorTo (T : Triplet f g) (p : Spec T.tensor) :\n    ofPoint (T.SpecTensorTo.base p) = T := by\n  ext <;> simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.residueFieldCongr_inv_residueFieldMap_ofPoint","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nt : ↑↑(CategoryTheory.Limits.pullback f g).toPresheafedSpace\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.residueFieldCongr ⋯).inv (AlgebraicGeometry.Scheme.Hom.residueFieldMap f (AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint t).x)) (AlgebraicGeometry.Scheme.Hom.residueFieldMap (CategoryTheory.Limits.pullback.fst f g) t)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.residueFieldCongr ⋯).inv (AlgebraicGeometry.Scheme.Hom.residueFieldMap g (AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint t).y)) (AlgebraicGeometry.Scheme.Hom.residueFieldMap (CategoryTheory.Limits.pullback.snd f g) t))","decl":"lemma residueFieldCongr_inv_residueFieldMap_ofPoint (t : ↑(pullback f g)) :\n    ((S.residueFieldCongr (Triplet.ofPoint t).hx).inv ≫ f.residueFieldMap (Triplet.ofPoint t).x) ≫\n      (pullback.fst f g).residueFieldMap t = ((S.residueFieldCongr (Triplet.ofPoint t).hy).inv ≫\n          g.residueFieldMap (Triplet.ofPoint t).y) ≫ (pullback.snd f g).residueFieldMap t := by\n  simp [← residueFieldMap_comp, Scheme.Hom.residueFieldMap_congr pullback.condition]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.ofPointTensor_SpecTensorTo_assoc","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nt : ↑↑(CategoryTheory.Limits.pullback f g).toPresheafedSpace\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (CategoryTheory.Limits.pullback f g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Pullback.ofPointTensor t)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint t).SpecTensorTo h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.pullback f g).fromSpecResidueField t) h)","decl":"@[reassoc]\nlemma ofPointTensor_SpecTensorTo (t : ↑(pullback f g)) :\n    Spec.map (ofPointTensor t) ≫ (Triplet.ofPoint t).SpecTensorTo =\n      (pullback f g).fromSpecResidueField t := by\n  apply pullback.hom_ext\n  · rw [← Scheme.Hom.Spec_map_residueFieldMap_fromSpecResidueField]\n    simp only [Category.assoc, Triplet.specTensorTo_fst, Triplet.ofPoint_x]\n    rw [← pushout.inl_desc _ _ (residueFieldCongr_inv_residueFieldMap_ofPoint t), Spec.map_comp]\n    rfl\n  · rw [← Scheme.Hom.Spec_map_residueFieldMap_fromSpecResidueField]\n    simp only [Category.assoc, Triplet.specTensorTo_snd, Triplet.ofPoint_y]\n    rw [← pushout.inr_desc _ _ (residueFieldCongr_inv_residueFieldMap_ofPoint t), Spec.map_comp]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.ofPointTensor_SpecTensorTo","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nt : ↑↑(CategoryTheory.Limits.pullback f g).toPresheafedSpace\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Pullback.ofPointTensor t)) (AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint t).SpecTensorTo) ((CategoryTheory.Limits.pullback f g).fromSpecResidueField t)","decl":"@[reassoc]\nlemma ofPointTensor_SpecTensorTo (t : ↑(pullback f g)) :\n    Spec.map (ofPointTensor t) ≫ (Triplet.ofPoint t).SpecTensorTo =\n      (pullback f g).fromSpecResidueField t := by\n  apply pullback.hom_ext\n  · rw [← Scheme.Hom.Spec_map_residueFieldMap_fromSpecResidueField]\n    simp only [Category.assoc, Triplet.specTensorTo_fst, Triplet.ofPoint_x]\n    rw [← pushout.inl_desc _ _ (residueFieldCongr_inv_residueFieldMap_ofPoint t), Spec.map_comp]\n    rfl\n  · rw [← Scheme.Hom.Spec_map_residueFieldMap_fromSpecResidueField]\n    simp only [Category.assoc, Triplet.specTensorTo_snd, Triplet.ofPoint_y]\n    rw [← pushout.inr_desc _ _ (residueFieldCongr_inv_residueFieldMap_ofPoint t), Spec.map_comp]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.SpecTensorTo_SpecOfPoint","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nt : ↑↑(CategoryTheory.Limits.pullback f g).toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.Pullback.Triplet.ofPoint t).SpecTensorTo.base (AlgebraicGeometry.Scheme.Pullback.SpecOfPoint t)) t","decl":"@[simp]\nlemma SpecTensorTo_SpecOfPoint (t : ↑(pullback f g)) :\n    (Triplet.ofPoint t).SpecTensorTo.base (SpecOfPoint t) = t := by\n  simp [SpecOfPoint, ← Scheme.comp_base_apply, ofPointTensor_SpecTensorTo]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.tensorCongr_SpecTensorTo_assoc","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT T' : AlgebraicGeometry.Scheme.Pullback.Triplet f g\nh✝ : Eq T T'\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (CategoryTheory.Limits.pullback f g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr h✝).hom) (CategoryTheory.CategoryStruct.comp T.SpecTensorTo h)) (CategoryTheory.CategoryStruct.comp T'.SpecTensorTo h)","decl":"@[reassoc (attr := simp)]\nlemma tensorCongr_SpecTensorTo {T T' : Triplet f g} (h : T = T') :\n    Spec.map (Triplet.tensorCongr h).hom ≫ T.SpecTensorTo = T'.SpecTensorTo := by\n  subst h\n  simp only [Triplet.tensorCongr_refl, Iso.refl_hom, Spec.map_id, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.tensorCongr_SpecTensorTo","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT T' : AlgebraicGeometry.Scheme.Pullback.Triplet f g\nh : Eq T T'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr h).hom) T.SpecTensorTo) T'.SpecTensorTo","decl":"@[reassoc (attr := simp)]\nlemma tensorCongr_SpecTensorTo {T T' : Triplet f g} (h : T = T') :\n    Spec.map (Triplet.tensorCongr h).hom ≫ T.SpecTensorTo = T'.SpecTensorTo := by\n  subst h\n  simp only [Triplet.tensorCongr_refl, Iso.refl_hom, Spec.map_id, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.Spec_ofPointTensor_SpecTensorTo","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\np : ↑↑(AlgebraicGeometry.Spec T.tensor).toPresheafedSpace\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.residueFieldMap T.SpecTensorTo p)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Pullback.ofPointTensor (T.SpecTensorTo.base p))) (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr ⋯).hom))) ((AlgebraicGeometry.Spec T.tensor).fromSpecResidueField p)","decl":"lemma Triplet.Spec_ofPointTensor_SpecTensorTo (T : Triplet f g) (p : Spec T.tensor) :\n    Spec.map (Hom.residueFieldMap T.SpecTensorTo p) ≫\n      Spec.map (ofPointTensor (T.SpecTensorTo.base p)) ≫\n      Spec.map (tensorCongr (T.ofPoint_SpecTensorTo p).symm).hom =\n    (Spec T.tensor).fromSpecResidueField p := by\n  apply T.Spec_map_tensor_isPullback.hom_ext\n  · rw [← cancel_mono <| X.fromSpecResidueField T.x]\n    simp_rw [Category.assoc, ← T.specTensorTo_fst, tensorCongr_SpecTensorTo_assoc]\n    rw [← Hom.Spec_map_residueFieldMap_fromSpecResidueField_assoc, ofPointTensor_SpecTensorTo_assoc]\n  · rw [← cancel_mono <| Y.fromSpecResidueField T.y]\n    simp_rw [Category.assoc, ← T.specTensorTo_snd, tensorCongr_SpecTensorTo_assoc]\n    rw [← Hom.Spec_map_residueFieldMap_fromSpecResidueField_assoc, ofPointTensor_SpecTensorTo_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.carrierEquiv_eq_iff","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT₁ T₂ : Sigma fun T => ↑↑(AlgebraicGeometry.Spec T.tensor).toPresheafedSpace\n⊢ Iff (Eq T₁ T₂) (Exists fun e => Eq ((AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Pullback.Triplet.tensorCongr e).inv).base T₁.snd) T₂.snd)","decl":"/-- A helper lemma to work with `AlgebraicGeometry.Scheme.Pullback.carrierEquiv`. -/\nlemma carrierEquiv_eq_iff {T₁ T₂ : Σ T : Triplet f g, Spec T.tensor} :\n    T₁ = T₂ ↔ ∃ e : T₁.1 = T₂.1, (Spec.map (Triplet.tensorCongr e).inv).base T₁.2 = T₂.2 := by\n  constructor\n  · rintro rfl\n    simp\n  · obtain ⟨T, _⟩ := T₁\n    obtain ⟨T', _⟩ := T₂\n    rintro ⟨rfl : T = T', e⟩\n    simpa [e]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.carrierEquiv_symm_fst","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\np : ↑↑(AlgebraicGeometry.Spec T.tensor).toPresheafedSpace\n⊢ Eq ((CategoryTheory.Limits.pullback.fst f g).base (AlgebraicGeometry.Scheme.Pullback.carrierEquiv.symm ⟨T, p⟩)) T.x","decl":"@[simp]\nlemma carrierEquiv_symm_fst (T : Triplet f g) (p : Spec T.tensor) :\n    (pullback.fst f g).base (carrierEquiv.symm ⟨T, p⟩) = T.x := by\n  simp [carrierEquiv]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.carrierEquiv_symm_snd","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\np : ↑↑(AlgebraicGeometry.Spec T.tensor).toPresheafedSpace\n⊢ Eq ((CategoryTheory.Limits.pullback.snd f g).base (AlgebraicGeometry.Scheme.Pullback.carrierEquiv.symm ⟨T, p⟩)) T.y","decl":"@[simp]\nlemma carrierEquiv_symm_snd (T : Triplet f g) (p : Spec T.tensor) :\n    (pullback.snd f g).base (carrierEquiv.symm ⟨T, p⟩) = T.y := by\n  simp [carrierEquiv]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.Triplet.exists_preimage","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nT : AlgebraicGeometry.Scheme.Pullback.Triplet f g\n⊢ Exists fun t => And (Eq ((CategoryTheory.Limits.pullback.fst f g).base t) T.x) (Eq ((CategoryTheory.Limits.pullback.snd f g).base t) T.y)","decl":"/-- Given a triple `(x, y, s)` with `f x = s = f y` there exists `t : X ×[S] Y` above\n`x` and `ỳ`. For the unpacked version without `Triplet`, see\n`AlgebraicGeometry.Scheme.Pullback.exists_preimage`. -/\nlemma Triplet.exists_preimage (T : Triplet f g) :\n    ∃ t : ↑(pullback f g),\n    (pullback.fst f g).base t = T.x ∧ (pullback.snd f g).base t = T.y :=\n  ⟨carrierEquiv.symm ⟨T, Nonempty.some inferInstance⟩, by simp⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.exists_preimage_pullback","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nx : ↑↑X.toPresheafedSpace\ny : ↑↑Y.toPresheafedSpace\nh : Eq (f.base x) (g.base y)\n⊢ Exists fun z => And (Eq ((CategoryTheory.Limits.pullback.fst f g).base z) x) (Eq ((CategoryTheory.Limits.pullback.snd f g).base z) y)","decl":"/--\nIf `f : X ⟶ S` and `g : Y ⟶ S` are morphisms of schemes and `x : X` and `y : Y` are points such\nthat `f x = g y`, then there exists `z : X ×[S] Y` lying above `x` and `y`.\n\nIn other words, the map from the underlying topological space of `X ×[S] Y` to the fiber product\nof the underlying topological spaces of `X` and `Y` over `S` is surjective.\n-/\nlemma exists_preimage_pullback (x : X) (y : Y) (h : f.base x = g.base y) :\n    ∃ z : ↑(pullback f g),\n    (pullback.fst f g).base z = x ∧ (pullback.snd f g).base z = y :=\n  (Pullback.Triplet.mk' x y h).exists_preimage\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.range_fst","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.pullback.fst f g).base) (Set.preimage (⇑f.base) (Set.range ⇑g.base))","decl":"lemma range_fst : Set.range (pullback.fst f g).base = f.base ⁻¹' Set.range g.base := by\n  ext x\n  refine ⟨?_, fun ⟨y, hy⟩ ↦ ?_⟩\n  · rintro ⟨a, rfl⟩\n    simp only [Set.mem_preimage, Set.mem_range, ← Scheme.comp_base_apply, pullback.condition]\n    simp\n  · obtain ⟨a, ha⟩ := Triplet.exists_preimage (Triplet.mk' x y hy.symm)\n    use a, ha.left\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.range_snd","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.pullback.snd f g).base) (Set.preimage (⇑g.base) (Set.range ⇑f.base))","decl":"lemma range_snd : Set.range (pullback.snd f g).base = g.base ⁻¹' Set.range f.base := by\n  ext x\n  refine ⟨?_, fun ⟨y, hy⟩ ↦ ?_⟩\n  · rintro ⟨a, rfl⟩\n    simp only [Set.mem_preimage, Set.mem_range, ← Scheme.comp_base_apply, ← pullback.condition]\n    simp\n  · obtain ⟨a, ha⟩ := Triplet.exists_preimage (Triplet.mk' y x hy)\n    use a, ha.right\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.range_fst_comp","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\n⊢ Eq (Set.range ⇑(CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) f).base) (Inter.inter (Set.range ⇑f.base) (Set.range ⇑g.base))","decl":"lemma range_fst_comp :\n    Set.range (pullback.fst f g ≫ f).base = Set.range f.base ∩ Set.range g.base := by\n  simp [Set.range_comp, range_fst, Set.image_preimage_eq_range_inter]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.range_snd_comp","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\n⊢ Eq (Set.range ⇑(CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) g).base) (Inter.inter (Set.range ⇑f.base) (Set.range ⇑g.base))","decl":"lemma range_snd_comp :\n    Set.range (pullback.snd f g ≫ g).base = Set.range f.base ∩ Set.range g.base := by\n  rw [← pullback.condition, range_fst_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Pullback.range_map","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nX' Y' S' : AlgebraicGeometry.Scheme\nf' : Quiver.Hom X' S'\ng' : Quiver.Hom Y' S'\ni₁ : Quiver.Hom X X'\ni₂ : Quiver.Hom Y Y'\ni₃ : Quiver.Hom S S'\ne₁ : Eq (CategoryTheory.CategoryStruct.comp f i₃) (CategoryTheory.CategoryStruct.comp i₁ f')\ne₂ : Eq (CategoryTheory.CategoryStruct.comp g i₃) (CategoryTheory.CategoryStruct.comp i₂ g')\ninst✝ : CategoryTheory.Mono i₃\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂).base) (Inter.inter (Set.preimage (⇑(CategoryTheory.Limits.pullback.fst f' g').base) (Set.range ⇑i₁.base)) (Set.preimage (⇑(CategoryTheory.Limits.pullback.snd f' g').base) (Set.range ⇑i₂.base)))","decl":"lemma range_map {X' Y' S' : Scheme.{u}} (f' : X' ⟶ S') (g' : Y' ⟶ S') (i₁ : X ⟶ X')\n    (i₂ : Y ⟶ Y') (i₃ : S ⟶ S') (e₁ : f ≫ i₃ = i₁ ≫ f')\n    (e₂ : g ≫ i₃ = i₂ ≫ g') [Mono i₃] :\n    Set.range (pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂).base =\n      (pullback.fst f' g').base ⁻¹' Set.range i₁.base ∩\n        (pullback.snd f' g').base ⁻¹' Set.range i₂.base := by\n  ext z\n  constructor\n  · rintro ⟨t, rfl⟩\n    constructor\n    · use (pullback.fst f g).base t\n      rw [← Scheme.comp_base_apply, ← Scheme.comp_base_apply]\n      simp\n    · use (pullback.snd f g).base t\n      rw [← Scheme.comp_base_apply, ← Scheme.comp_base_apply]\n      simp\n  · intro ⟨⟨x, hx⟩, ⟨y, hy⟩⟩\n    let T₁ : Triplet (pullback.fst f' g') i₁ := Triplet.mk' z x hx.symm\n    obtain ⟨w₁, hw₁⟩ := T₁.exists_preimage\n    let T₂ : Triplet (pullback.snd f' g') i₂ := Triplet.mk' z y hy.symm\n    obtain ⟨w₂, hw₂⟩ := T₂.exists_preimage\n    let T : Triplet (pullback.fst (pullback.fst f' g') i₁) (pullback.fst (pullback.snd f' g') i₂) :=\n      Triplet.mk' w₁ w₂ <| by simp [hw₁.left, hw₂.left, T₁, T₂]\n    obtain ⟨t, _, ht₂⟩ := T.exists_preimage\n    use (pullbackFstFstIso f g f' g' i₁ i₂ i₃ e₁ e₂).hom.base t\n    rw [pullback_map_eq_pullbackFstFstIso_inv, ← Scheme.comp_base_apply, Iso.hom_inv_id_assoc]\n    simp [ht₂, T, hw₂.left, T₂]\n\n"}
{"name":"AlgebraicGeometry.Scheme.isJointlySurjectivePreserving","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\n⊢ AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P","decl":"instance isJointlySurjectivePreserving (P : MorphismProperty Scheme.{u}) :\n    IsJointlySurjectivePreserving P where\n  exists_preimage_fst_triplet_of_prop {X Y S} f g _ hg x y hxy := by\n    obtain ⟨a, b, h⟩ := Pullback.exists_preimage_pullback x y hxy\n    use a\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsStableUnderBaseChangeSurjective","module":"Mathlib.AlgebraicGeometry.PullbackCarrier","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.Surjective","decl":"instance : MorphismProperty.IsStableUnderBaseChange @Surjective := by\n  refine .mk' ?_\n  introv hg\n  simp only [surjective_iff, ← Set.range_eq_univ, Pullback.range_fst] at hg ⊢\n  rw [hg, Set.preimage_univ]\n\n"}
