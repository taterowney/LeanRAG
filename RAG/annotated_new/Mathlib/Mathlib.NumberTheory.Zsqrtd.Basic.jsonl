{"name":"Zsqrtd.mk.inj","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d re✝ im✝ re im : Int\nx✝ : Eq { re := re✝, im := im✝ } { re := re, im := im }\n⊢ And (Eq re✝ re) (Eq im✝ im)","decl":"/-- The ring of integers adjoined with a square root of `d`.\n  These have the form `a + b √d` where `a b : ℤ`. The components\n  are called `re` and `im` by analogy to the negative `d` case. -/\n@[ext]\nstructure Zsqrtd (d : ℤ) where\n  re : ℤ\n  im : ℤ\n  deriving DecidableEq\n\n"}
{"name":"Zsqrtd.ext","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nx y : Zsqrtd d\nre : Eq x.re y.re\nim : Eq x.im y.im\n⊢ Eq x y","decl":"/-- The ring of integers adjoined with a square root of `d`.\n  These have the form `a + b √d` where `a b : ℤ`. The components\n  are called `re` and `im` by analogy to the negative `d` case. -/\n@[ext]\nstructure Zsqrtd (d : ℤ) where\n  re : ℤ\n  im : ℤ\n  deriving DecidableEq\n\n"}
{"name":"Zsqrtd.mk.injEq","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d re✝ im✝ re im : Int\n⊢ Eq (Eq { re := re✝, im := im✝ } { re := re, im := im }) (And (Eq re✝ re) (Eq im✝ im))","decl":"/-- The ring of integers adjoined with a square root of `d`.\n  These have the form `a + b √d` where `a b : ℤ`. The components\n  are called `re` and `im` by analogy to the negative `d` case. -/\n@[ext]\nstructure Zsqrtd (d : ℤ) where\n  re : ℤ\n  im : ℤ\n  deriving DecidableEq\n\n"}
{"name":"Zsqrtd.ext_iff","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nx y : Zsqrtd d\n⊢ Iff (Eq x y) (And (Eq x.re y.re) (Eq x.im y.im))","decl":"/-- The ring of integers adjoined with a square root of `d`.\n  These have the form `a + b √d` where `a b : ℤ`. The components\n  are called `re` and `im` by analogy to the negative `d` case. -/\n@[ext]\nstructure Zsqrtd (d : ℤ) where\n  re : ℤ\n  im : ℤ\n  deriving DecidableEq\n\n"}
{"name":"Zsqrtd.mk.sizeOf_spec","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d re im : Int\n⊢ Eq (SizeOf.sizeOf { re := re, im := im }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf re)) (SizeOf.sizeOf im))","decl":"/-- The ring of integers adjoined with a square root of `d`.\n  These have the form `a + b √d` where `a b : ℤ`. The components\n  are called `re` and `im` by analogy to the negative `d` case. -/\n@[ext]\nstructure Zsqrtd (d : ℤ) where\n  re : ℤ\n  im : ℤ\n  deriving DecidableEq\n\n"}
{"name":"Zsqrtd.ofInt_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d n : Int\n⊢ Eq (Zsqrtd.ofInt n).re n","decl":"theorem ofInt_re (n : ℤ) : (ofInt n : ℤ√d).re = n :=\n  rfl\n\n"}
{"name":"Zsqrtd.ofInt_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d n : Int\n⊢ Eq (Zsqrtd.ofInt n).im 0","decl":"theorem ofInt_im (n : ℤ) : (ofInt n : ℤ√d).im = 0 :=\n  rfl\n\n"}
{"name":"Zsqrtd.zero_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq (Zsqrtd.re 0) 0","decl":"@[simp]\ntheorem zero_re : (0 : ℤ√d).re = 0 :=\n  rfl\n\n"}
{"name":"Zsqrtd.zero_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq (Zsqrtd.im 0) 0","decl":"@[simp]\ntheorem zero_im : (0 : ℤ√d).im = 0 :=\n  rfl\n\n"}
{"name":"Zsqrtd.one_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq (Zsqrtd.re 1) 1","decl":"@[simp]\ntheorem one_re : (1 : ℤ√d).re = 1 :=\n  rfl\n\n"}
{"name":"Zsqrtd.one_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq (Zsqrtd.im 1) 0","decl":"@[simp]\ntheorem one_im : (1 : ℤ√d).im = 0 :=\n  rfl\n\n"}
{"name":"Zsqrtd.sqrtd_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq Zsqrtd.sqrtd.re 0","decl":"@[simp]\ntheorem sqrtd_re : (sqrtd : ℤ√d).re = 0 :=\n  rfl\n\n"}
{"name":"Zsqrtd.sqrtd_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq Zsqrtd.sqrtd.im 1","decl":"@[simp]\ntheorem sqrtd_im : (sqrtd : ℤ√d).im = 1 :=\n  rfl\n\n"}
{"name":"Zsqrtd.add_def","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d x y x' y' : Int\n⊢ Eq (HAdd.hAdd { re := x, im := y } { re := x', im := y' }) { re := HAdd.hAdd x x', im := HAdd.hAdd y y' }","decl":"@[simp]\ntheorem add_def (x y x' y' : ℤ) : (⟨x, y⟩ + ⟨x', y'⟩ : ℤ√d) = ⟨x + x', y + y'⟩ :=\n  rfl\n\n"}
{"name":"Zsqrtd.add_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz w : Zsqrtd d\n⊢ Eq (HAdd.hAdd z w).re (HAdd.hAdd z.re w.re)","decl":"@[simp]\ntheorem add_re (z w : ℤ√d) : (z + w).re = z.re + w.re :=\n  rfl\n\n"}
{"name":"Zsqrtd.add_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz w : Zsqrtd d\n⊢ Eq (HAdd.hAdd z w).im (HAdd.hAdd z.im w.im)","decl":"@[simp]\ntheorem add_im (z w : ℤ√d) : (z + w).im = z.im + w.im :=\n  rfl\n\n"}
{"name":"Zsqrtd.neg_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz : Zsqrtd d\n⊢ Eq (Neg.neg z).re (Neg.neg z.re)","decl":"@[simp]\ntheorem neg_re (z : ℤ√d) : (-z).re = -z.re :=\n  rfl\n\n"}
{"name":"Zsqrtd.neg_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz : Zsqrtd d\n⊢ Eq (Neg.neg z).im (Neg.neg z.im)","decl":"@[simp]\ntheorem neg_im (z : ℤ√d) : (-z).im = -z.im :=\n  rfl\n\n"}
{"name":"Zsqrtd.mul_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz w : Zsqrtd d\n⊢ Eq (HMul.hMul z w).re (HAdd.hAdd (HMul.hMul z.re w.re) (HMul.hMul (HMul.hMul d z.im) w.im))","decl":"@[simp]\ntheorem mul_re (z w : ℤ√d) : (z * w).re = z.re * w.re + d * z.im * w.im :=\n  rfl\n\n"}
{"name":"Zsqrtd.mul_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz w : Zsqrtd d\n⊢ Eq (HMul.hMul z w).im (HAdd.hAdd (HMul.hMul z.re w.im) (HMul.hMul z.im w.re))","decl":"@[simp]\ntheorem mul_im (z w : ℤ√d) : (z * w).im = z.re * w.im + z.im * w.re :=\n  rfl\n\n"}
{"name":"Zsqrtd.sub_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz w : Zsqrtd d\n⊢ Eq (HSub.hSub z w).re (HSub.hSub z.re w.re)","decl":"@[simp]\ntheorem sub_re (z w : ℤ√d) : (z - w).re = z.re - w.re :=\n  rfl\n\n"}
{"name":"Zsqrtd.sub_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz w : Zsqrtd d\n⊢ Eq (HSub.hSub z w).im (HSub.hSub z.im w.im)","decl":"@[simp]\ntheorem sub_im (z w : ℤ√d) : (z - w).im = z.im - w.im :=\n  rfl\n\n"}
{"name":"Zsqrtd.star_mk","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d x y : Int\n⊢ Eq (Star.star { re := x, im := y }) { re := x, im := Neg.neg y }","decl":"@[simp]\ntheorem star_mk (x y : ℤ) : star (⟨x, y⟩ : ℤ√d) = ⟨x, -y⟩ :=\n  rfl\n\n"}
{"name":"Zsqrtd.star_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz : Zsqrtd d\n⊢ Eq (Star.star z).re z.re","decl":"@[simp]\ntheorem star_re (z : ℤ√d) : (star z).re = z.re :=\n  rfl\n\n"}
{"name":"Zsqrtd.star_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz : Zsqrtd d\n⊢ Eq (Star.star z).im (Neg.neg z.im)","decl":"@[simp]\ntheorem star_im (z : ℤ√d) : (star z).im = -z.im :=\n  rfl\n\n"}
{"name":"Zsqrtd.nontrivial","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Nontrivial (Zsqrtd d)","decl":"instance nontrivial : Nontrivial (ℤ√d) :=\n  ⟨⟨0, 1, Zsqrtd.ext_iff.not.mpr (by simp)⟩⟩\n\n"}
{"name":"Zsqrtd.natCast_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nn : Nat\n⊢ Eq (↑n).re ↑n","decl":"@[simp]\ntheorem natCast_re (n : ℕ) : (n : ℤ√d).re = n :=\n  rfl\n\n"}
{"name":"Zsqrtd.ofNat_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).re ↑n","decl":"@[simp]\ntheorem ofNat_re (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : ℤ√d).re = n :=\n  rfl\n\n"}
{"name":"Zsqrtd.natCast_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nn : Nat\n⊢ Eq (↑n).im 0","decl":"@[simp]\ntheorem natCast_im (n : ℕ) : (n : ℤ√d).im = 0 :=\n  rfl\n\n"}
{"name":"Zsqrtd.ofNat_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).im 0","decl":"@[simp]\ntheorem ofNat_im (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : ℤ√d).im = 0 :=\n  rfl\n\n"}
{"name":"Zsqrtd.natCast_val","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nn : Nat\n⊢ Eq ↑n { re := ↑n, im := 0 }","decl":"theorem natCast_val (n : ℕ) : (n : ℤ√d) = ⟨n, 0⟩ :=\n  rfl\n\n"}
{"name":"Zsqrtd.intCast_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d n : Int\n⊢ Eq (↑n).re n","decl":"@[simp]\ntheorem intCast_re (n : ℤ) : (n : ℤ√d).re = n := by cases n <;> rfl\n\n"}
{"name":"Zsqrtd.intCast_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d n : Int\n⊢ Eq (↑n).im 0","decl":"@[simp]\ntheorem intCast_im (n : ℤ) : (n : ℤ√d).im = 0 := by cases n <;> rfl\n\n"}
{"name":"Zsqrtd.intCast_val","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d n : Int\n⊢ Eq ↑n { re := n, im := 0 }","decl":"theorem intCast_val (n : ℤ) : (n : ℤ√d) = ⟨n, 0⟩ := by ext <;> simp\n\n"}
{"name":"Zsqrtd.instCharZero","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ CharZero (Zsqrtd d)","decl":"instance : CharZero (ℤ√d) where cast_injective m n := by simp [Zsqrtd.ext_iff]\n\n"}
{"name":"Zsqrtd.ofInt_eq_intCast","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d n : Int\n⊢ Eq (Zsqrtd.ofInt n) ↑n","decl":"@[simp]\ntheorem ofInt_eq_intCast (n : ℤ) : (ofInt n : ℤ√d) = n := by ext <;> simp [ofInt_re, ofInt_im]\n\n"}
{"name":"Zsqrtd.smul_val","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d n x y : Int\n⊢ Eq (HMul.hMul ↑n { re := x, im := y }) { re := HMul.hMul n x, im := HMul.hMul n y }","decl":"@[simp]\ntheorem smul_val (n x y : ℤ) : (n : ℤ√d) * ⟨x, y⟩ = ⟨n * x, n * y⟩ := by ext <;> simp\n\n"}
{"name":"Zsqrtd.smul_re","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d a : Int\nb : Zsqrtd d\n⊢ Eq (HMul.hMul (↑a) b).re (HMul.hMul a b.re)","decl":"theorem smul_re (a : ℤ) (b : ℤ√d) : (↑a * b).re = a * b.re := by simp\n\n"}
{"name":"Zsqrtd.smul_im","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d a : Int\nb : Zsqrtd d\n⊢ Eq (HMul.hMul (↑a) b).im (HMul.hMul a b.im)","decl":"theorem smul_im (a : ℤ) (b : ℤ√d) : (↑a * b).im = a * b.im := by simp\n\n"}
{"name":"Zsqrtd.muld_val","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d x y : Int\n⊢ Eq (HMul.hMul Zsqrtd.sqrtd { re := x, im := y }) { re := HMul.hMul d y, im := x }","decl":"@[simp]\ntheorem muld_val (x y : ℤ) : sqrtd (d := d) * ⟨x, y⟩ = ⟨d * y, x⟩ := by ext <;> simp\n\n"}
{"name":"Zsqrtd.dmuld","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq (HMul.hMul Zsqrtd.sqrtd Zsqrtd.sqrtd) ↑d","decl":"@[simp]\ntheorem dmuld : sqrtd (d := d) * sqrtd (d := d) = d := by ext <;> simp\n\n"}
{"name":"Zsqrtd.smuld_val","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d n x y : Int\n⊢ Eq (HMul.hMul (HMul.hMul Zsqrtd.sqrtd ↑n) { re := x, im := y }) { re := HMul.hMul (HMul.hMul d n) y, im := HMul.hMul n x }","decl":"@[simp]\ntheorem smuld_val (n x y : ℤ) : sqrtd * (n : ℤ√d) * ⟨x, y⟩ = ⟨d * n * y, n * x⟩ := by ext <;> simp\n\n"}
{"name":"Zsqrtd.decompose","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d x y : Int\n⊢ Eq { re := x, im := y } (HAdd.hAdd (↑x) (HMul.hMul Zsqrtd.sqrtd ↑y))","decl":"theorem decompose {x y : ℤ} : (⟨x, y⟩ : ℤ√d) = x + sqrtd (d := d) * y := by ext <;> simp\n\n"}
{"name":"Zsqrtd.mul_star","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d x y : Int\n⊢ Eq (HMul.hMul { re := x, im := y } (Star.star { re := x, im := y })) (HSub.hSub (HMul.hMul ↑x ↑x) (HMul.hMul (HMul.hMul ↑d ↑y) ↑y))","decl":"theorem mul_star {x y : ℤ} : (⟨x, y⟩ * star ⟨x, y⟩ : ℤ√d) = x * x - d * y * y := by\n  ext <;> simp [sub_eq_add_neg, mul_comm]\n\n"}
{"name":"Zsqrtd.intCast_dvd","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d z : Int\na : Zsqrtd d\n⊢ Iff (Dvd.dvd (↑z) a) (And (Dvd.dvd z a.re) (Dvd.dvd z a.im))","decl":"theorem intCast_dvd (z : ℤ) (a : ℤ√d) : ↑z ∣ a ↔ z ∣ a.re ∧ z ∣ a.im := by\n  constructor\n  · rintro ⟨x, rfl⟩\n    simp only [add_zero, intCast_re, zero_mul, mul_im, dvd_mul_right, and_self_iff,\n      mul_re, mul_zero, intCast_im]\n  · rintro ⟨⟨r, hr⟩, ⟨i, hi⟩⟩\n    use ⟨r, i⟩\n    rw [smul_val, Zsqrtd.ext_iff]\n    exact ⟨hr, hi⟩\n\n"}
{"name":"Zsqrtd.intCast_dvd_intCast","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d a b : Int\n⊢ Iff (Dvd.dvd ↑a ↑b) (Dvd.dvd a b)","decl":"@[simp, norm_cast]\ntheorem intCast_dvd_intCast (a b : ℤ) : (a : ℤ√d) ∣ b ↔ a ∣ b := by\n  rw [intCast_dvd]\n  constructor\n  · rintro ⟨hre, -⟩\n    rwa [intCast_re] at hre\n  · rw [intCast_re, intCast_im]\n    exact fun hc => ⟨hc, dvd_zero a⟩\n\n"}
{"name":"Zsqrtd.eq_of_smul_eq_smul_left","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d a : Int\nb c : Zsqrtd d\nha : Ne a 0\nh : Eq (HMul.hMul (↑a) b) (HMul.hMul (↑a) c)\n⊢ Eq b c","decl":"protected theorem eq_of_smul_eq_smul_left {a : ℤ} {b c : ℤ√d} (ha : a ≠ 0) (h : ↑a * b = a * c) :\n    b = c := by\n  rw [Zsqrtd.ext_iff] at h ⊢\n  apply And.imp _ _ h <;> simpa only [smul_re, smul_im] using mul_left_cancel₀ ha\n\n"}
{"name":"Zsqrtd.gcd_eq_zero_iff","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\na : Zsqrtd d\n⊢ Iff (Eq (a.re.gcd a.im) 0) (Eq a 0)","decl":"theorem gcd_eq_zero_iff (a : ℤ√d) : Int.gcd a.re a.im = 0 ↔ a = 0 := by\n  simp only [Int.gcd_eq_zero_iff, Zsqrtd.ext_iff, eq_self_iff_true, zero_im, zero_re]\n\n"}
{"name":"Zsqrtd.gcd_pos_iff","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\na : Zsqrtd d\n⊢ Iff (LT.lt 0 (a.re.gcd a.im)) (Ne a 0)","decl":"theorem gcd_pos_iff (a : ℤ√d) : 0 < Int.gcd a.re a.im ↔ a ≠ 0 :=\n  pos_iff_ne_zero.trans <| not_congr a.gcd_eq_zero_iff\n\n"}
{"name":"Zsqrtd.isCoprime_of_dvd_isCoprime","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\na b : Zsqrtd d\nhcoprime : IsCoprime a.re a.im\nhdvd : Dvd.dvd b a\n⊢ IsCoprime b.re b.im","decl":"theorem isCoprime_of_dvd_isCoprime {a b : ℤ√d} (hcoprime : IsCoprime a.re a.im) (hdvd : b ∣ a) :\n    IsCoprime b.re b.im := by\n  apply isCoprime_of_dvd\n  · rintro ⟨hre, him⟩\n    obtain rfl : b = 0 := Zsqrtd.ext hre him\n    rw [zero_dvd_iff] at hdvd\n    simp [hdvd, zero_im, zero_re, not_isCoprime_zero_zero] at hcoprime\n  · rintro z hz - hzdvdu hzdvdv\n    apply hz\n    obtain ⟨ha, hb⟩ : z ∣ a.re ∧ z ∣ a.im := by\n      rw [← intCast_dvd]\n      apply dvd_trans _ hdvd\n      rw [intCast_dvd]\n      exact ⟨hzdvdu, hzdvdv⟩\n    exact hcoprime.isUnit_of_dvd' ha hb\n\n"}
{"name":"Zsqrtd.coprime_of_dvd_coprime","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\na b : Zsqrtd d\nhcoprime : IsCoprime a.re a.im\nhdvd : Dvd.dvd b a\n⊢ IsCoprime b.re b.im","decl":"@[deprecated (since := \"2025-01-23\")] alias coprime_of_dvd_coprime := isCoprime_of_dvd_isCoprime\n\n"}
{"name":"Zsqrtd.exists_coprime_of_gcd_pos","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\na : Zsqrtd d\nhgcd : LT.lt 0 (a.re.gcd a.im)\n⊢ Exists fun b => And (Eq a (HMul.hMul (↑↑(a.re.gcd a.im)) b)) (IsCoprime b.re b.im)","decl":"theorem exists_coprime_of_gcd_pos {a : ℤ√d} (hgcd : 0 < Int.gcd a.re a.im) :\n    ∃ b : ℤ√d, a = ((Int.gcd a.re a.im : ℤ) : ℤ√d) * b ∧ IsCoprime b.re b.im := by\n  obtain ⟨re, im, H1, Hre, Him⟩ := Int.exists_gcd_one hgcd\n  rw [mul_comm] at Hre Him\n  refine ⟨⟨re, im⟩, ?_, ?_⟩\n  · rw [smul_val, ← Hre, ← Him]\n  · rw [Int.isCoprime_iff_gcd_eq_one, H1]\n\n"}
{"name":"Zsqrtd.sqLe_of_le","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d x y z w : Nat\nxz : LE.le z x\nyw : LE.le y w\nxy : Zsqrtd.SqLe x c y d\n⊢ Zsqrtd.SqLe z c w d","decl":"theorem sqLe_of_le {c d x y z w : ℕ} (xz : z ≤ x) (yw : y ≤ w) (xy : SqLe x c y d) : SqLe z c w d :=\n  le_trans (mul_le_mul (Nat.mul_le_mul_left _ xz) xz (Nat.zero_le _) (Nat.zero_le _)) <|\n    le_trans xy (mul_le_mul (Nat.mul_le_mul_left _ yw) yw (Nat.zero_le _) (Nat.zero_le _))\n\n"}
{"name":"Zsqrtd.sqLe_add_mixed","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d x y z w : Nat\nxy : Zsqrtd.SqLe x c y d\nzw : Zsqrtd.SqLe z c w d\n⊢ LE.le (HMul.hMul c (HMul.hMul x z)) (HMul.hMul d (HMul.hMul y w))","decl":"theorem sqLe_add_mixed {c d x y z w : ℕ} (xy : SqLe x c y d) (zw : SqLe z c w d) :\n    c * (x * z) ≤ d * (y * w) :=\n  Nat.mul_self_le_mul_self_iff.1 <| by\n    simpa [mul_comm, mul_left_comm] using mul_le_mul xy zw (Nat.zero_le _) (Nat.zero_le _)\n\n"}
{"name":"Zsqrtd.sqLe_add","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d x y z w : Nat\nxy : Zsqrtd.SqLe x c y d\nzw : Zsqrtd.SqLe z c w d\n⊢ Zsqrtd.SqLe (HAdd.hAdd x z) c (HAdd.hAdd y w) d","decl":"theorem sqLe_add {c d x y z w : ℕ} (xy : SqLe x c y d) (zw : SqLe z c w d) :\n    SqLe (x + z) c (y + w) d := by\n  have xz := sqLe_add_mixed xy zw\n  simp? [SqLe, mul_assoc] at xy zw says simp only [SqLe, mul_assoc] at xy zw\n  simp [SqLe, mul_add, mul_comm, mul_left_comm, add_le_add, *]\n\n"}
{"name":"Zsqrtd.sqLe_cancel","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d x y z w : Nat\nzw : Zsqrtd.SqLe y d x c\nh : Zsqrtd.SqLe (HAdd.hAdd x z) c (HAdd.hAdd y w) d\n⊢ Zsqrtd.SqLe z c w d","decl":"theorem sqLe_cancel {c d x y z w : ℕ} (zw : SqLe y d x c) (h : SqLe (x + z) c (y + w) d) :\n    SqLe z c w d := by\n  apply le_of_not_gt\n  intro l\n  refine not_le_of_gt ?_ h\n  simp only [SqLe, mul_add, mul_comm, mul_left_comm, add_assoc, gt_iff_lt]\n  have hm := sqLe_add_mixed zw (le_of_lt l)\n  simp only [SqLe, mul_assoc, gt_iff_lt] at l zw\n  exact\n    lt_of_le_of_lt (add_le_add_right zw _)\n      (add_lt_add_left (add_lt_add_of_le_of_lt hm (add_lt_add_of_le_of_lt hm l)) _)\n\n"}
{"name":"Zsqrtd.sqLe_smul","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d x y n : Nat\nxy : Zsqrtd.SqLe x c y d\n⊢ Zsqrtd.SqLe (HMul.hMul n x) c (HMul.hMul n y) d","decl":"theorem sqLe_smul {c d x y : ℕ} (n : ℕ) (xy : SqLe x c y d) : SqLe (n * x) c (n * y) d := by\n  simpa [SqLe, mul_left_comm, mul_assoc] using Nat.mul_le_mul_left (n * n) xy\n\n"}
{"name":"Zsqrtd.sqLe_mul","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d x y z w : Nat\n⊢ And (Zsqrtd.SqLe x 1 y d → Zsqrtd.SqLe z 1 w d → Zsqrtd.SqLe (HAdd.hAdd (HMul.hMul x w) (HMul.hMul y z)) d (HAdd.hAdd (HMul.hMul x z) (HMul.hMul (HMul.hMul d y) w)) 1) (And (Zsqrtd.SqLe x 1 y d → Zsqrtd.SqLe w d z 1 → Zsqrtd.SqLe (HAdd.hAdd (HMul.hMul x z) (HMul.hMul (HMul.hMul d y) w)) 1 (HAdd.hAdd (HMul.hMul x w) (HMul.hMul y z)) d) (And (Zsqrtd.SqLe y d x 1 → Zsqrtd.SqLe z 1 w d → Zsqrtd.SqLe (HAdd.hAdd (HMul.hMul x z) (HMul.hMul (HMul.hMul d y) w)) 1 (HAdd.hAdd (HMul.hMul x w) (HMul.hMul y z)) d) (Zsqrtd.SqLe y d x 1 → Zsqrtd.SqLe w d z 1 → Zsqrtd.SqLe (HAdd.hAdd (HMul.hMul x w) (HMul.hMul y z)) d (HAdd.hAdd (HMul.hMul x z) (HMul.hMul (HMul.hMul d y) w)) 1)))","decl":"theorem sqLe_mul {d x y z w : ℕ} :\n    (SqLe x 1 y d → SqLe z 1 w d → SqLe (x * w + y * z) d (x * z + d * y * w) 1) ∧\n      (SqLe x 1 y d → SqLe w d z 1 → SqLe (x * z + d * y * w) 1 (x * w + y * z) d) ∧\n        (SqLe y d x 1 → SqLe z 1 w d → SqLe (x * z + d * y * w) 1 (x * w + y * z) d) ∧\n          (SqLe y d x 1 → SqLe w d z 1 → SqLe (x * w + y * z) d (x * z + d * y * w) 1) := by\n  refine ⟨?_, ?_, ?_, ?_⟩ <;>\n    · intro xy zw\n      have :=\n        Int.mul_nonneg (sub_nonneg_of_le (Int.ofNat_le_ofNat_of_le xy))\n          (sub_nonneg_of_le (Int.ofNat_le_ofNat_of_le zw))\n      refine Int.le_of_ofNat_le_ofNat (le_of_sub_nonneg ?_)\n      convert this using 1\n      simp only [one_mul, Int.ofNat_add, Int.ofNat_mul]\n      ring\n\n"}
{"name":"Zsqrtd.nonnegg_comm","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d : Nat\nx y : Int\n⊢ Eq (Zsqrtd.Nonnegg c d x y) (Zsqrtd.Nonnegg d c y x)","decl":"theorem nonnegg_comm {c d : ℕ} {x y : ℤ} : Nonnegg c d x y = Nonnegg d c y x := by\n  induction x <;> induction y <;> rfl\n\n"}
{"name":"Zsqrtd.nonnegg_neg_pos","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d a b : Nat\n⊢ Iff (Zsqrtd.Nonnegg c d (Neg.neg ↑a) ↑b) (Zsqrtd.SqLe a d b c)","decl":"theorem nonnegg_neg_pos {c d} : ∀ {a b : ℕ}, Nonnegg c d (-a) b ↔ SqLe a d b c\n  | 0, b => ⟨by simp [SqLe, Nat.zero_le], fun _ => trivial⟩\n  | a + 1, b => by rw [← Int.negSucc_coe]; rfl\n\n"}
{"name":"Zsqrtd.nonnegg_pos_neg","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d a b : Nat\n⊢ Iff (Zsqrtd.Nonnegg c d (↑a) (Neg.neg ↑b)) (Zsqrtd.SqLe b c a d)","decl":"theorem nonnegg_pos_neg {c d} {a b : ℕ} : Nonnegg c d a (-b) ↔ SqLe b c a d := by\n  rw [nonnegg_comm]; exact nonnegg_neg_pos\n\n"}
{"name":"Zsqrtd.nonnegg_cases_right","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d a : Nat\nb : Int\na✝ : ∀ (x : Nat), Eq b (Neg.neg ↑x) → Zsqrtd.SqLe x c a d\n⊢ Zsqrtd.Nonnegg c d (↑a) b","decl":"open Int in\ntheorem nonnegg_cases_right {c d} {a : ℕ} :\n    ∀ {b : ℤ}, (∀ x : ℕ, b = -x → SqLe x c a d) → Nonnegg c d a b\n  | (b : Nat), _ => trivial\n  | -[b+1], h => h (b + 1) rfl\n\n"}
{"name":"Zsqrtd.nonnegg_cases_left","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d b : Nat\na : Int\nh : ∀ (x : Nat), Eq a (Neg.neg ↑x) → Zsqrtd.SqLe x d b c\n⊢ Zsqrtd.Nonnegg c d a ↑b","decl":"theorem nonnegg_cases_left {c d} {b : ℕ} {a : ℤ} (h : ∀ x : ℕ, a = -x → SqLe x d b c) :\n    Nonnegg c d a b :=\n  cast nonnegg_comm (nonnegg_cases_right h)\n\n"}
{"name":"Zsqrtd.norm_def","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nn : Zsqrtd d\n⊢ Eq n.norm (HSub.hSub (HMul.hMul n.re n.re) (HMul.hMul (HMul.hMul d n.im) n.im))","decl":"theorem norm_def (n : ℤ√d) : n.norm = n.re * n.re - d * n.im * n.im :=\n  rfl\n\n"}
{"name":"Zsqrtd.norm_zero","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq (Zsqrtd.norm 0) 0","decl":"@[simp]\ntheorem norm_zero : norm (0 : ℤ√d) = 0 := by simp [norm]\n\n"}
{"name":"Zsqrtd.norm_one","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq (Zsqrtd.norm 1) 1","decl":"@[simp]\ntheorem norm_one : norm (1 : ℤ√d) = 1 := by simp [norm]\n\n"}
{"name":"Zsqrtd.norm_intCast","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d n : Int\n⊢ Eq (↑n).norm (HMul.hMul n n)","decl":"@[simp]\ntheorem norm_intCast (n : ℤ) : norm (n : ℤ√d) = n * n := by simp [norm]\n\n"}
{"name":"Zsqrtd.norm_natCast","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nn : Nat\n⊢ Eq (↑n).norm (HMul.hMul ↑n ↑n)","decl":"@[simp]\ntheorem norm_natCast (n : ℕ) : norm (n : ℤ√d) = n * n :=\n  norm_intCast n\n\n"}
{"name":"Zsqrtd.norm_mul","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nn m : Zsqrtd d\n⊢ Eq (HMul.hMul n m).norm (HMul.hMul n.norm m.norm)","decl":"@[simp]\ntheorem norm_mul (n m : ℤ√d) : norm (n * m) = norm n * norm m := by\n  simp only [norm, mul_im, mul_re]\n  ring\n\n"}
{"name":"Zsqrtd.norm_eq_mul_conj","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nn : Zsqrtd d\n⊢ Eq (↑n.norm) (HMul.hMul n (Star.star n))","decl":"theorem norm_eq_mul_conj (n : ℤ√d) : (norm n : ℤ√d) = n * star n := by\n  ext <;> simp [norm, star, mul_comm, sub_eq_add_neg]\n\n"}
{"name":"Zsqrtd.norm_neg","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nx : Zsqrtd d\n⊢ Eq (Neg.neg x).norm x.norm","decl":"@[simp]\ntheorem norm_neg (x : ℤ√d) : (-x).norm = x.norm :=\n  -- Porting note: replaced `simp` with `rw`\n  -- See https://github.com/leanprover-community/mathlib4/issues/5026\n  (Int.cast_inj (α := ℤ√d)).1 <| by rw [norm_eq_mul_conj, star_neg, neg_mul_neg, norm_eq_mul_conj]\n\n"}
{"name":"Zsqrtd.norm_conj","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nx : Zsqrtd d\n⊢ Eq (Star.star x).norm x.norm","decl":"@[simp]\ntheorem norm_conj (x : ℤ√d) : (star x).norm = x.norm :=\n  -- Porting note: replaced `simp` with `rw`\n  -- See https://github.com/leanprover-community/mathlib4/issues/5026\n  (Int.cast_inj (α := ℤ√d)).1 <| by rw [norm_eq_mul_conj, star_star, mul_comm, norm_eq_mul_conj]\n\n"}
{"name":"Zsqrtd.norm_nonneg","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nhd : LE.le d 0\nn : Zsqrtd d\n⊢ LE.le 0 n.norm","decl":"theorem norm_nonneg (hd : d ≤ 0) (n : ℤ√d) : 0 ≤ n.norm :=\n  add_nonneg (mul_self_nonneg _)\n    (by\n      rw [mul_assoc, neg_mul_eq_neg_mul]\n      exact mul_nonneg (neg_nonneg.2 hd) (mul_self_nonneg _))\n\n"}
{"name":"Zsqrtd.norm_eq_one_iff","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nx : Zsqrtd d\n⊢ Iff (Eq x.norm.natAbs 1) (IsUnit x)","decl":"theorem norm_eq_one_iff {x : ℤ√d} : x.norm.natAbs = 1 ↔ IsUnit x :=\n  ⟨fun h =>\n    isUnit_iff_dvd_one.2 <|\n      (le_total 0 (norm x)).casesOn\n        (fun hx =>\n          ⟨star x, by\n            rwa [← Int.natCast_inj, Int.natAbs_of_nonneg hx, ← @Int.cast_inj (ℤ√d) _ _,\n              norm_eq_mul_conj, eq_comm] at h⟩)\n        fun hx =>\n          ⟨-star x, by\n            rwa [← Int.natCast_inj, Int.ofNat_natAbs_of_nonpos hx, ← @Int.cast_inj (ℤ√d) _ _,\n              Int.cast_neg, norm_eq_mul_conj, neg_mul_eq_mul_neg, eq_comm] at h⟩,\n    fun h => by\n    let ⟨y, hy⟩ := isUnit_iff_dvd_one.1 h\n    have := congr_arg (Int.natAbs ∘ norm) hy\n    rw [Function.comp_apply, Function.comp_apply, norm_mul, Int.natAbs_mul, norm_one,\n      Int.natAbs_one, eq_comm, mul_eq_one] at this\n    exact this.1⟩\n\n"}
{"name":"Zsqrtd.isUnit_iff_norm_isUnit","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nz : Zsqrtd d\n⊢ Iff (IsUnit z) (IsUnit z.norm)","decl":"theorem isUnit_iff_norm_isUnit {d : ℤ} (z : ℤ√d) : IsUnit z ↔ IsUnit z.norm := by\n  rw [Int.isUnit_iff_natAbs_eq, norm_eq_one_iff]\n\n"}
{"name":"Zsqrtd.norm_eq_one_iff'","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nhd : LE.le d 0\nz : Zsqrtd d\n⊢ Iff (Eq z.norm 1) (IsUnit z)","decl":"theorem norm_eq_one_iff' {d : ℤ} (hd : d ≤ 0) (z : ℤ√d) : z.norm = 1 ↔ IsUnit z := by\n  rw [← norm_eq_one_iff, ← Int.natCast_inj, Int.natAbs_of_nonneg (norm_nonneg hd z), Int.ofNat_one]\n\n"}
{"name":"Zsqrtd.norm_eq_zero_iff","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nhd : LT.lt d 0\nz : Zsqrtd d\n⊢ Iff (Eq z.norm 0) (Eq z 0)","decl":"theorem norm_eq_zero_iff {d : ℤ} (hd : d < 0) (z : ℤ√d) : z.norm = 0 ↔ z = 0 := by\n  constructor\n  · intro h\n    rw [norm_def, sub_eq_add_neg, mul_assoc] at h\n    have left := mul_self_nonneg z.re\n    have right := neg_nonneg.mpr (mul_nonpos_of_nonpos_of_nonneg hd.le (mul_self_nonneg z.im))\n    obtain ⟨ha, hb⟩ := (add_eq_zero_iff_of_nonneg left right).mp h\n    ext <;> apply eq_zero_of_mul_self_eq_zero\n    · exact ha\n    · rw [neg_eq_zero, mul_eq_zero] at hb\n      exact hb.resolve_left hd.ne\n  · rintro rfl\n    exact norm_zero\n\n"}
{"name":"Zsqrtd.norm_eq_of_associated","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nhd : LE.le d 0\nx y : Zsqrtd d\nh : Associated x y\n⊢ Eq x.norm y.norm","decl":"theorem norm_eq_of_associated {d : ℤ} (hd : d ≤ 0) {x y : ℤ√d} (h : Associated x y) :\n    x.norm = y.norm := by\n  obtain ⟨u, rfl⟩ := h\n  rw [norm_mul, (norm_eq_one_iff' hd _).mpr u.isUnit, mul_one]\n\n"}
{"name":"Zsqrtd.nonneg_cases","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na : Zsqrtd ↑d\na✝ : a.Nonneg\n⊢ Exists fun x => Exists fun y => Or (Eq a { re := ↑x, im := ↑y }) (Or (Eq a { re := ↑x, im := Neg.neg ↑y }) (Eq a { re := Neg.neg ↑x, im := ↑y }))","decl":"open Int in\ntheorem nonneg_cases : ∀ {a : ℤ√d}, Nonneg a → ∃ x y : ℕ, a = ⟨x, y⟩ ∨ a = ⟨x, -y⟩ ∨ a = ⟨-x, y⟩\n  | ⟨(x : ℕ), (y : ℕ)⟩, _ => ⟨x, y, Or.inl rfl⟩\n  | ⟨(x : ℕ), -[y+1]⟩, _ => ⟨x, y + 1, Or.inr <| Or.inl rfl⟩\n  | ⟨-[x+1], (y : ℕ)⟩, _ => ⟨x + 1, y, Or.inr <| Or.inr rfl⟩\n  | ⟨-[_+1], -[_+1]⟩, h => False.elim h\n\n"}
{"name":"Zsqrtd.nonneg_add_lem","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d x y z w : Nat\nxy : { re := ↑x, im := Neg.neg ↑y }.Nonneg\nzw : { re := Neg.neg ↑z, im := ↑w }.Nonneg\n⊢ (HAdd.hAdd { re := ↑x, im := Neg.neg ↑y } { re := Neg.neg ↑z, im := ↑w }).Nonneg","decl":"open Int in\ntheorem nonneg_add_lem {x y z w : ℕ} (xy : Nonneg (⟨x, -y⟩ : ℤ√d)) (zw : Nonneg (⟨-z, w⟩ : ℤ√d)) :\n    Nonneg (⟨x, -y⟩ + ⟨-z, w⟩ : ℤ√d) := by\n  have : Nonneg ⟨Int.subNatNat x z, Int.subNatNat w y⟩ :=\n    Int.subNatNat_elim x z\n      (fun m n i => SqLe y d m 1 → SqLe n 1 w d → Nonneg ⟨i, Int.subNatNat w y⟩)\n      (fun j k =>\n        Int.subNatNat_elim w y\n          (fun m n i => SqLe n d (k + j) 1 → SqLe k 1 m d → Nonneg ⟨Int.ofNat j, i⟩)\n          (fun _ _ _ _ => trivial) fun m n xy zw => sqLe_cancel zw xy)\n      (fun j k =>\n        Int.subNatNat_elim w y\n          (fun m n i => SqLe n d k 1 → SqLe (k + j + 1) 1 m d → Nonneg ⟨-[j+1], i⟩)\n          (fun m n xy zw => sqLe_cancel xy zw) fun m n xy zw =>\n          let t := Nat.le_trans zw (sqLe_of_le (Nat.le_add_right n (m + 1)) le_rfl xy)\n          have : k + j + 1 ≤ k :=\n            Nat.mul_self_le_mul_self_iff.1 (by simpa [one_mul] using t)\n          absurd this (not_le_of_gt <| Nat.succ_le_succ <| Nat.le_add_right _ _))\n      (nonnegg_pos_neg.1 xy) (nonnegg_neg_pos.1 zw)\n  rw [add_def, neg_add_eq_sub]\n  rwa [Int.subNatNat_eq_coe, Int.subNatNat_eq_coe] at this\n\n"}
{"name":"Zsqrtd.Nonneg.add","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na b : Zsqrtd ↑d\nha : a.Nonneg\nhb : b.Nonneg\n⊢ (HAdd.hAdd a b).Nonneg","decl":"theorem Nonneg.add {a b : ℤ√d} (ha : Nonneg a) (hb : Nonneg b) : Nonneg (a + b) := by\n  rcases nonneg_cases ha with ⟨x, y, rfl | rfl | rfl⟩ <;>\n    rcases nonneg_cases hb with ⟨z, w, rfl | rfl | rfl⟩\n  · trivial\n  · refine nonnegg_cases_right fun i h => sqLe_of_le ?_ ?_ (nonnegg_pos_neg.1 hb)\n    · dsimp only at h\n      exact Int.ofNat_le.1 (le_of_neg_le_neg (Int.le.intro y (by simp [add_comm, *])))\n    · apply Nat.le_add_left\n  · refine nonnegg_cases_left fun i h => sqLe_of_le ?_ ?_ (nonnegg_neg_pos.1 hb)\n    · dsimp only at h\n      exact Int.ofNat_le.1 (le_of_neg_le_neg (Int.le.intro x (by simp [add_comm, *])))\n    · apply Nat.le_add_left\n  · refine nonnegg_cases_right fun i h => sqLe_of_le ?_ ?_ (nonnegg_pos_neg.1 ha)\n    · dsimp only at h\n      exact Int.ofNat_le.1 (le_of_neg_le_neg (Int.le.intro w (by simp [*])))\n    · apply Nat.le_add_right\n  · have : Nonneg ⟨_, _⟩ :=\n      nonnegg_pos_neg.2 (sqLe_add (nonnegg_pos_neg.1 ha) (nonnegg_pos_neg.1 hb))\n    rw [Nat.cast_add, Nat.cast_add, neg_add] at this\n    rwa [add_def]\n    -- Porting note: was\n    -- simpa [add_comm] using\n    --   nonnegg_pos_neg.2 (sqLe_add (nonnegg_pos_neg.1 ha) (nonnegg_pos_neg.1 hb))\n  · exact nonneg_add_lem ha hb\n  · refine nonnegg_cases_left fun i h => sqLe_of_le ?_ ?_ (nonnegg_neg_pos.1 ha)\n    · dsimp only at h\n      exact Int.ofNat_le.1 (le_of_neg_le_neg (Int.le.intro _ h))\n    · apply Nat.le_add_right\n  · dsimp\n    rw [add_comm, add_comm (y : ℤ)]\n    exact nonneg_add_lem hb ha\n  · have : Nonneg ⟨_, _⟩ :=\n      nonnegg_neg_pos.2 (sqLe_add (nonnegg_neg_pos.1 ha) (nonnegg_neg_pos.1 hb))\n    rw [Nat.cast_add, Nat.cast_add, neg_add] at this\n    rwa [add_def]\n    -- Porting note: was\n    -- simpa [add_comm] using\n    --   nonnegg_neg_pos.2 (sqLe_add (nonnegg_neg_pos.1 ha) (nonnegg_neg_pos.1 hb))\n\n"}
{"name":"Zsqrtd.nonneg_iff_zero_le","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na : Zsqrtd ↑d\n⊢ Iff a.Nonneg (LE.le 0 a)","decl":"theorem nonneg_iff_zero_le {a : ℤ√d} : Nonneg a ↔ 0 ≤ a :=\n  show _ ↔ Nonneg _ by simp\n\n"}
{"name":"Zsqrtd.le_of_le_le","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\nx y z w : Int\nxz : LE.le x z\nyw : LE.le y w\n⊢ LE.le { re := x, im := y } { re := z, im := w }","decl":"theorem le_of_le_le {x y z w : ℤ} (xz : x ≤ z) (yw : y ≤ w) : (⟨x, y⟩ : ℤ√d) ≤ ⟨z, w⟩ :=\n  show Nonneg ⟨z - x, w - y⟩ from\n    match z - x, w - y, Int.le.dest_sub xz, Int.le.dest_sub yw with\n    | _, _, ⟨_, rfl⟩, ⟨_, rfl⟩ => trivial\n\n"}
{"name":"Zsqrtd.nonneg_total","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na : Zsqrtd ↑d\n⊢ Or a.Nonneg (Neg.neg a).Nonneg","decl":"open Int in\nprotected theorem nonneg_total : ∀ a : ℤ√d, Nonneg a ∨ Nonneg (-a)\n  | ⟨(x : ℕ), (y : ℕ)⟩ => Or.inl trivial\n  | ⟨-[_+1], -[_+1]⟩ => Or.inr trivial\n  | ⟨0, -[_+1]⟩ => Or.inr trivial\n  | ⟨-[_+1], 0⟩ => Or.inr trivial\n  | ⟨(_ + 1 : ℕ), -[_+1]⟩ => Nat.le_total _ _\n  | ⟨-[_+1], (_ + 1 : ℕ)⟩ => Nat.le_total _ _\n\n"}
{"name":"Zsqrtd.le_total","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na b : Zsqrtd ↑d\n⊢ Or (LE.le a b) (LE.le b a)","decl":"protected theorem le_total (a b : ℤ√d) : a ≤ b ∨ b ≤ a := by\n  have t := (b - a).nonneg_total\n  rwa [neg_sub] at t\n\n"}
{"name":"Zsqrtd.le_arch","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na : Zsqrtd ↑d\n⊢ Exists fun n => LE.le a ↑n","decl":"open Int in\ntheorem le_arch (a : ℤ√d) : ∃ n : ℕ, a ≤ n := by\n  obtain ⟨x, y, (h : a ≤ ⟨x, y⟩)⟩ : ∃ x y : ℕ, Nonneg (⟨x, y⟩ + -a) :=\n    match -a with\n    | ⟨Int.ofNat x, Int.ofNat y⟩ => ⟨0, 0, by trivial⟩\n    | ⟨Int.ofNat x, -[y+1]⟩ => ⟨0, y + 1, by simp [add_def, Int.negSucc_coe, add_assoc]; trivial⟩\n    | ⟨-[x+1], Int.ofNat y⟩ => ⟨x + 1, 0, by simp [Int.negSucc_coe, add_assoc]; trivial⟩\n    | ⟨-[x+1], -[y+1]⟩ => ⟨x + 1, y + 1, by simp [Int.negSucc_coe, add_assoc]; trivial⟩\n  refine ⟨x + d * y, h.trans ?_⟩\n  change Nonneg ⟨↑x + d * y - ↑x, 0 - ↑y⟩\n  cases' y with y\n  · simp\n    trivial\n  have h : ∀ y, SqLe y d (d * y) 1 := fun y => by\n    simpa [SqLe, mul_comm, mul_left_comm] using Nat.mul_le_mul_right (y * y) (Nat.le_mul_self d)\n  rw [show (x : ℤ) + d * Nat.succ y - x = d * Nat.succ y by simp]\n  exact h (y + 1)\n\n"}
{"name":"Zsqrtd.add_le_add_left","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na b : Zsqrtd ↑d\nab : LE.le a b\nc : Zsqrtd ↑d\n⊢ LE.le (HAdd.hAdd c a) (HAdd.hAdd c b)","decl":"protected theorem add_le_add_left (a b : ℤ√d) (ab : a ≤ b) (c : ℤ√d) : c + a ≤ c + b :=\n  show Nonneg _ by rw [add_sub_add_left_eq_sub]; exact ab\n\n"}
{"name":"Zsqrtd.le_of_add_le_add_left","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na b c : Zsqrtd ↑d\nh : LE.le (HAdd.hAdd c a) (HAdd.hAdd c b)\n⊢ LE.le a b","decl":"protected theorem le_of_add_le_add_left (a b c : ℤ√d) (h : c + a ≤ c + b) : a ≤ b := by\n  simpa using Zsqrtd.add_le_add_left _ _ h (-c)\n\n"}
{"name":"Zsqrtd.add_lt_add_left","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na b : Zsqrtd ↑d\nh : LT.lt a b\nc : Zsqrtd ↑d\n⊢ LT.lt (HAdd.hAdd c a) (HAdd.hAdd c b)","decl":"protected theorem add_lt_add_left (a b : ℤ√d) (h : a < b) (c) : c + a < c + b := fun h' =>\n  h (Zsqrtd.le_of_add_le_add_left _ _ _ h')\n\n"}
{"name":"Zsqrtd.nonneg_smul","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na : Zsqrtd ↑d\nn : Nat\nha : a.Nonneg\n⊢ (HMul.hMul (↑n) a).Nonneg","decl":"theorem nonneg_smul {a : ℤ√d} {n : ℕ} (ha : Nonneg a) : Nonneg ((n : ℤ√d) * a) := by\n  rw [← Int.cast_natCast n]\n  exact\n    match a, nonneg_cases ha, ha with\n    | _, ⟨x, y, Or.inl rfl⟩, _ => by rw [smul_val]; trivial\n    | _, ⟨x, y, Or.inr <| Or.inl rfl⟩, ha => by\n      rw [smul_val]; simpa using nonnegg_pos_neg.2 (sqLe_smul n <| nonnegg_pos_neg.1 ha)\n    | _, ⟨x, y, Or.inr <| Or.inr rfl⟩, ha => by\n      rw [smul_val]; simpa using nonnegg_neg_pos.2 (sqLe_smul n <| nonnegg_neg_pos.1 ha)\n\n"}
{"name":"Zsqrtd.nonneg_muld","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na : Zsqrtd ↑d\nha : a.Nonneg\n⊢ (HMul.hMul Zsqrtd.sqrtd a).Nonneg","decl":"theorem nonneg_muld {a : ℤ√d} (ha : Nonneg a) : Nonneg (sqrtd * a) :=\n  match a, nonneg_cases ha, ha with\n  | _, ⟨_, _, Or.inl rfl⟩, _ => trivial\n  | _, ⟨x, y, Or.inr <| Or.inl rfl⟩, ha => by\n    simp only [muld_val, mul_neg]\n    apply nonnegg_neg_pos.2\n    simpa [SqLe, mul_comm, mul_left_comm] using Nat.mul_le_mul_left d (nonnegg_pos_neg.1 ha)\n  | _, ⟨x, y, Or.inr <| Or.inr rfl⟩, ha => by\n    simp only [muld_val]\n    apply nonnegg_pos_neg.2\n    simpa [SqLe, mul_comm, mul_left_comm] using Nat.mul_le_mul_left d (nonnegg_neg_pos.1 ha)\n\n"}
{"name":"Zsqrtd.nonneg_mul_lem","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d x y : Nat\na : Zsqrtd ↑d\nha : a.Nonneg\n⊢ (HMul.hMul { re := ↑x, im := ↑y } a).Nonneg","decl":"theorem nonneg_mul_lem {x y : ℕ} {a : ℤ√d} (ha : Nonneg a) : Nonneg (⟨x, y⟩ * a) := by\n  have : (⟨x, y⟩ * a : ℤ√d) = (x : ℤ√d) * a + sqrtd * ((y : ℤ√d) * a) := by\n    rw [decompose, right_distrib, mul_assoc, Int.cast_natCast, Int.cast_natCast]\n  rw [this]\n  exact (nonneg_smul ha).add (nonneg_muld <| nonneg_smul ha)\n\n"}
{"name":"Zsqrtd.nonneg_mul","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na b : Zsqrtd ↑d\nha : a.Nonneg\nhb : b.Nonneg\n⊢ (HMul.hMul a b).Nonneg","decl":"theorem nonneg_mul {a b : ℤ√d} (ha : Nonneg a) (hb : Nonneg b) : Nonneg (a * b) :=\n  match a, b, nonneg_cases ha, nonneg_cases hb, ha, hb with\n  | _, _, ⟨_, _, Or.inl rfl⟩, ⟨_, _, Or.inl rfl⟩, _, _ => trivial\n  | _, _, ⟨x, y, Or.inl rfl⟩, ⟨z, w, Or.inr <| Or.inr rfl⟩, _, hb => nonneg_mul_lem hb\n  | _, _, ⟨x, y, Or.inl rfl⟩, ⟨z, w, Or.inr <| Or.inl rfl⟩, _, hb => nonneg_mul_lem hb\n  | _, _, ⟨x, y, Or.inr <| Or.inr rfl⟩, ⟨z, w, Or.inl rfl⟩, ha, _ => by\n    rw [mul_comm]; exact nonneg_mul_lem ha\n  | _, _, ⟨x, y, Or.inr <| Or.inl rfl⟩, ⟨z, w, Or.inl rfl⟩, ha, _ => by\n    rw [mul_comm]; exact nonneg_mul_lem ha\n  | _, _, ⟨x, y, Or.inr <| Or.inr rfl⟩, ⟨z, w, Or.inr <| Or.inr rfl⟩, ha, hb => by\n    rw [calc\n          (⟨-x, y⟩ * ⟨-z, w⟩ : ℤ√d) = ⟨_, _⟩ := rfl\n          _ = ⟨x * z + d * y * w, -(x * w + y * z)⟩ := by simp [add_comm]\n          ]\n    exact nonnegg_pos_neg.2 (sqLe_mul.left (nonnegg_neg_pos.1 ha) (nonnegg_neg_pos.1 hb))\n  | _, _, ⟨x, y, Or.inr <| Or.inr rfl⟩, ⟨z, w, Or.inr <| Or.inl rfl⟩, ha, hb => by\n    rw [calc\n          (⟨-x, y⟩ * ⟨z, -w⟩ : ℤ√d) = ⟨_, _⟩ := rfl\n          _ = ⟨-(x * z + d * y * w), x * w + y * z⟩ := by simp [add_comm]\n          ]\n    exact nonnegg_neg_pos.2 (sqLe_mul.right.left (nonnegg_neg_pos.1 ha) (nonnegg_pos_neg.1 hb))\n  | _, _, ⟨x, y, Or.inr <| Or.inl rfl⟩, ⟨z, w, Or.inr <| Or.inr rfl⟩, ha, hb => by\n    rw [calc\n          (⟨x, -y⟩ * ⟨-z, w⟩ : ℤ√d) = ⟨_, _⟩ := rfl\n          _ = ⟨-(x * z + d * y * w), x * w + y * z⟩ := by simp [add_comm]\n          ]\n    exact\n        nonnegg_neg_pos.2 (sqLe_mul.right.right.left (nonnegg_pos_neg.1 ha) (nonnegg_neg_pos.1 hb))\n  | _, _, ⟨x, y, Or.inr <| Or.inl rfl⟩, ⟨z, w, Or.inr <| Or.inl rfl⟩, ha, hb => by\n    rw [calc\n          (⟨x, -y⟩ * ⟨z, -w⟩ : ℤ√d) = ⟨_, _⟩ := rfl\n          _ = ⟨x * z + d * y * w, -(x * w + y * z)⟩ := by simp [add_comm]\n          ]\n    exact\n        nonnegg_pos_neg.2\n          (sqLe_mul.right.right.right (nonnegg_pos_neg.1 ha) (nonnegg_pos_neg.1 hb))\n\n"}
{"name":"Zsqrtd.mul_nonneg","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\na b : Zsqrtd ↑d\na✝¹ : LE.le 0 a\na✝ : LE.le 0 b\n⊢ LE.le 0 (HMul.hMul a b)","decl":"protected theorem mul_nonneg (a b : ℤ√d) : 0 ≤ a → 0 ≤ b → 0 ≤ a * b := by\n  simp_rw [← nonneg_iff_zero_le]\n  exact nonneg_mul\n\n"}
{"name":"Zsqrtd.not_sqLe_succ","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"c d y : Nat\nh : LT.lt 0 c\n⊢ Not (Zsqrtd.SqLe (HAdd.hAdd y 1) c 0 d)","decl":"theorem not_sqLe_succ (c d y) (h : 0 < c) : ¬SqLe (y + 1) c 0 d :=\n  not_le_of_gt <| mul_pos (mul_pos h <| Nat.succ_pos _) <| Nat.succ_pos _\n\n-- Porting note: renamed field and added theorem to make `x` explicit\n"}
{"name":"Zsqrtd.Nonsquare.ns'","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"x : Nat\nself : Zsqrtd.Nonsquare x\nn : Nat\n⊢ Ne x (HMul.hMul n n)","decl":"/-- A nonsquare is a natural number that is not equal to the square of an\n  integer. This is implemented as a typeclass because it's a necessary condition\n  for much of the Pell equation theory. -/\nclass Nonsquare (x : ℕ) : Prop where\n  ns' : ∀ n : ℕ, x ≠ n * n\n\n"}
{"name":"Zsqrtd.Nonsquare.ns","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"x : Nat\ninst✝ : Zsqrtd.Nonsquare x\nn : Nat\n⊢ Ne x (HMul.hMul n n)","decl":"theorem Nonsquare.ns (x : ℕ) [Nonsquare x] : ∀ n : ℕ, x ≠ n * n := ns'\n\n"}
{"name":"Zsqrtd.d_pos","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\n⊢ LT.lt 0 d","decl":"theorem d_pos : 0 < d :=\n  lt_of_le_of_ne (Nat.zero_le _) <| Ne.symm <| Nonsquare.ns d 0\n\n"}
{"name":"Zsqrtd.divides_sq_eq_zero","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\nx y : Nat\nh : Eq (HMul.hMul x x) (HMul.hMul (HMul.hMul d y) y)\n⊢ And (Eq x 0) (Eq y 0)","decl":"theorem divides_sq_eq_zero {x y} (h : x * x = d * y * y) : x = 0 ∧ y = 0 :=\n  let g := x.gcd y\n  Or.elim g.eq_zero_or_pos\n    (fun H => ⟨Nat.eq_zero_of_gcd_eq_zero_left H, Nat.eq_zero_of_gcd_eq_zero_right H⟩) fun gpos =>\n    False.elim <| by\n      let ⟨m, n, co, (hx : x = m * g), (hy : y = n * g)⟩ := Nat.exists_coprime _ _\n      rw [hx, hy] at h\n      have : m * m = d * (n * n) := by\n        refine mul_left_cancel₀ (mul_pos gpos gpos).ne' ?_\n        -- Porting note: was `simpa [mul_comm, mul_left_comm] using h`\n        calc\n          g * g * (m * m)\n          _ = m * g * (m * g) := by ring\n          _ = d * (n * g) * (n * g) := h\n          _ = g * g * (d * (n * n)) := by ring\n      have co2 :=\n        let co1 := co.mul_right co\n        co1.mul co1\n      exact\n        Nonsquare.ns d m\n          (Nat.dvd_antisymm (by rw [this]; apply dvd_mul_right) <|\n            co2.dvd_of_dvd_mul_right <| by simp [this])\n\n"}
{"name":"Zsqrtd.divides_sq_eq_zero_z","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\nx y : Int\nh : Eq (HMul.hMul x x) (HMul.hMul (HMul.hMul (↑d) y) y)\n⊢ And (Eq x 0) (Eq y 0)","decl":"theorem divides_sq_eq_zero_z {x y : ℤ} (h : x * x = d * y * y) : x = 0 ∧ y = 0 := by\n  rw [mul_assoc, ← Int.natAbs_mul_self, ← Int.natAbs_mul_self, ← Int.ofNat_mul, ← mul_assoc] at h\n  exact\n    let ⟨h1, h2⟩ := divides_sq_eq_zero (Int.ofNat.inj h)\n    ⟨Int.natAbs_eq_zero.mp h1, Int.natAbs_eq_zero.mp h2⟩\n\n"}
{"name":"Zsqrtd.not_divides_sq","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\nx y : Nat\n⊢ Ne (HMul.hMul (HAdd.hAdd x 1) (HAdd.hAdd x 1)) (HMul.hMul (HMul.hMul d (HAdd.hAdd y 1)) (HAdd.hAdd y 1))","decl":"theorem not_divides_sq (x y) : (x + 1) * (x + 1) ≠ d * (y + 1) * (y + 1) := fun e => by\n  have t := (divides_sq_eq_zero e).left\n  contradiction\n\n"}
{"name":"Zsqrtd.nonneg_antisymm","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\na : Zsqrtd ↑d\na✝¹ : a.Nonneg\na✝ : (Neg.neg a).Nonneg\n⊢ Eq a 0","decl":"open Int in\ntheorem nonneg_antisymm : ∀ {a : ℤ√d}, Nonneg a → Nonneg (-a) → a = 0\n  | ⟨0, 0⟩, _, _ => rfl\n  | ⟨-[_+1], -[_+1]⟩, xy, _ => False.elim xy\n  | ⟨(_ + 1 : Nat), (_ + 1 : Nat)⟩, _, yx => False.elim yx\n  | ⟨-[_+1], 0⟩, xy, _ => absurd xy (not_sqLe_succ _ _ _ (by decide))\n  | ⟨(_ + 1 : Nat), 0⟩, _, yx => absurd yx (not_sqLe_succ _ _ _ (by decide))\n  | ⟨0, -[_+1]⟩, xy, _ => absurd xy (not_sqLe_succ _ _ _ d_pos)\n  | ⟨0, (_ + 1 : Nat)⟩, _, yx => absurd yx (not_sqLe_succ _ _ _ d_pos)\n  | ⟨(x + 1 : Nat), -[y+1]⟩, (xy : SqLe _ _ _ _), (yx : SqLe _ _ _ _) => by\n    let t := le_antisymm yx xy\n    rw [one_mul] at t\n    exact absurd t (not_divides_sq _ _)\n  | ⟨-[x+1], (y + 1 : Nat)⟩, (xy : SqLe _ _ _ _), (yx : SqLe _ _ _ _) => by\n    let t := le_antisymm xy yx\n    rw [one_mul] at t\n    exact absurd t (not_divides_sq _ _)\n\n"}
{"name":"Zsqrtd.le_antisymm","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\na b : Zsqrtd ↑d\nab : LE.le a b\nba : LE.le b a\n⊢ Eq a b","decl":"theorem le_antisymm {a b : ℤ√d} (ab : a ≤ b) (ba : b ≤ a) : a = b :=\n  eq_of_sub_eq_zero <| nonneg_antisymm ba (by rwa [neg_sub])\n\n"}
{"name":"Zsqrtd.eq_zero_or_eq_zero_of_mul_eq_zero","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\na b : Zsqrtd ↑d\na✝ : Eq (HMul.hMul a b) 0\n⊢ Or (Eq a 0) (Eq b 0)","decl":"protected theorem eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : ℤ√d}, a * b = 0 → a = 0 ∨ b = 0\n  | ⟨x, y⟩, ⟨z, w⟩, h => by\n    injection h with h1 h2\n    have h1 : x * z = -(d * y * w) := eq_neg_of_add_eq_zero_left h1\n    have h2 : x * w = -(y * z) := eq_neg_of_add_eq_zero_left h2\n    have fin : x * x = d * y * y → (⟨x, y⟩ : ℤ√d) = 0 := fun e =>\n      match x, y, divides_sq_eq_zero_z e with\n      | _, _, ⟨rfl, rfl⟩ => rfl\n    exact\n      if z0 : z = 0 then\n        if w0 : w = 0 then\n          Or.inr\n            (match z, w, z0, w0 with\n            | _, _, rfl, rfl => rfl)\n        else\n          Or.inl <|\n            fin <|\n              mul_right_cancel₀ w0 <|\n                calc\n                  x * x * w = -y * (x * z) := by simp [h2, mul_assoc, mul_left_comm]\n                  _ = d * y * y * w := by simp [h1, mul_assoc, mul_left_comm]\n      else\n        Or.inl <|\n          fin <|\n            mul_right_cancel₀ z0 <|\n              calc\n                x * x * z = d * -y * (x * w) := by simp [h1, mul_assoc, mul_left_comm]\n                _ = d * y * y * z := by simp [h2, mul_assoc, mul_left_comm]\n\n"}
{"name":"Zsqrtd.instNoZeroDivisorsCastInt","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\n⊢ NoZeroDivisors (Zsqrtd ↑d)","decl":"instance : NoZeroDivisors (ℤ√d) where\n  eq_zero_or_eq_zero_of_mul_eq_zero := Zsqrtd.eq_zero_or_eq_zero_of_mul_eq_zero\n\n"}
{"name":"Zsqrtd.instIsDomainCastInt","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\n⊢ IsDomain (Zsqrtd ↑d)","decl":"instance : IsDomain (ℤ√d) :=\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"Zsqrtd.mul_pos","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Nat\ndnsq : Zsqrtd.Nonsquare d\na b : Zsqrtd ↑d\na0 : LT.lt 0 a\nb0 : LT.lt 0 b\n⊢ LT.lt 0 (HMul.hMul a b)","decl":"protected theorem mul_pos (a b : ℤ√d) (a0 : 0 < a) (b0 : 0 < b) : 0 < a * b := fun ab =>\n  Or.elim\n    (eq_zero_or_eq_zero_of_mul_eq_zero\n      (le_antisymm ab (Zsqrtd.mul_nonneg _ _ (le_of_lt a0) (le_of_lt b0))))\n    (fun e => ne_of_gt a0 e) fun e => ne_of_gt b0 e\n\n"}
{"name":"Zsqrtd.norm_eq_zero","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\nh_nonsquare : ∀ (n : Int), Ne d (HMul.hMul n n)\na : Zsqrtd d\n⊢ Iff (Eq a.norm 0) (Eq a 0)","decl":"theorem norm_eq_zero {d : ℤ} (h_nonsquare : ∀ n : ℤ, d ≠ n * n) (a : ℤ√d) : norm a = 0 ↔ a = 0 := by\n  refine ⟨fun ha => Zsqrtd.ext_iff.mpr ?_, fun h => by rw [h, norm_zero]⟩\n  dsimp only [norm] at ha\n  rw [sub_eq_zero] at ha\n  by_cases h : 0 ≤ d\n  · obtain ⟨d', rfl⟩ := Int.eq_ofNat_of_zero_le h\n    haveI : Nonsquare d' := ⟨fun n h => h_nonsquare n <| mod_cast h⟩\n    exact divides_sq_eq_zero_z ha\n  · push_neg at h\n    suffices a.re * a.re = 0 by\n      rw [eq_zero_of_mul_self_eq_zero this] at ha ⊢\n      simpa only [true_and, or_self_right, zero_re, zero_im, eq_self_iff_true, zero_eq_mul,\n        mul_zero, mul_eq_zero, h.ne, false_or, or_self_iff] using ha\n    apply _root_.le_antisymm _ (mul_self_nonneg _)\n    rw [ha, mul_assoc]\n    exact mul_nonpos_of_nonpos_of_nonneg h.le (mul_self_nonneg _)\n\n"}
{"name":"Zsqrtd.hom_ext","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"R : Type\ninst✝ : Ring R\nd : Int\nf g : RingHom (Zsqrtd d) R\nh : Eq (f Zsqrtd.sqrtd) (g Zsqrtd.sqrtd)\n⊢ Eq f g","decl":"@[ext]\ntheorem hom_ext [Ring R] {d : ℤ} (f g : ℤ√d →+* R) (h : f sqrtd = g sqrtd) : f = g := by\n  ext ⟨x_re, x_im⟩\n  simp [decompose, h]\n\n"}
{"name":"Zsqrtd.hom_ext_iff","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"R : Type\ninst✝ : Ring R\nd : Int\nf g : RingHom (Zsqrtd d) R\n⊢ Iff (Eq f g) (Eq (f Zsqrtd.sqrtd) (g Zsqrtd.sqrtd))","decl":"@[ext]\ntheorem hom_ext [Ring R] {d : ℤ} (f g : ℤ√d →+* R) (h : f sqrtd = g sqrtd) : f = g := by\n  ext ⟨x_re, x_im⟩\n  simp [decompose, h]\n\n"}
{"name":"Zsqrtd.lift_symm_apply_coe","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"R : Type\ninst✝ : CommRing R\nd : Int\nf : RingHom (Zsqrtd d) R\n⊢ Eq (↑(Zsqrtd.lift.symm f)) (f Zsqrtd.sqrtd)","decl":"/-- The unique `RingHom` from `ℤ√d` to a ring `R`, constructed by replacing `√d` with the provided\nroot. Conversely, this associates to every mapping `ℤ√d →+* R` a value of `√d` in `R`. -/\n@[simps]\ndef lift {d : ℤ} : { r : R // r * r = ↑d } ≃ (ℤ√d →+* R) where\n  toFun r :=\n    { toFun := fun a => a.1 + a.2 * (r : R)\n      map_zero' := by simp\n      map_add' := fun a b => by\n        simp only [add_re, Int.cast_add, add_im]\n        ring\n      map_one' := by simp\n      map_mul' := fun a b => by\n        have :\n          (a.re + a.im * r : R) * (b.re + b.im * r) =\n            a.re * b.re + (a.re * b.im + a.im * b.re) * r + a.im * b.im * (r * r) := by\n          ring\n        simp only [mul_re, Int.cast_add, Int.cast_mul, mul_im, this, r.prop]\n        ring }\n  invFun f := ⟨f sqrtd, by rw [← f.map_mul, dmuld, map_intCast]⟩\n  left_inv r := by simp\n  right_inv f := by\n    ext\n    simp\n\n"}
{"name":"Zsqrtd.lift_apply_apply","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"R : Type\ninst✝ : CommRing R\nd : Int\nr : Subtype fun r => Eq (HMul.hMul r r) ↑d\na : Zsqrtd d\n⊢ Eq ((Zsqrtd.lift r) a) (HAdd.hAdd (↑a.re) (HMul.hMul ↑a.im ↑r))","decl":"/-- The unique `RingHom` from `ℤ√d` to a ring `R`, constructed by replacing `√d` with the provided\nroot. Conversely, this associates to every mapping `ℤ√d →+* R` a value of `√d` in `R`. -/\n@[simps]\ndef lift {d : ℤ} : { r : R // r * r = ↑d } ≃ (ℤ√d →+* R) where\n  toFun r :=\n    { toFun := fun a => a.1 + a.2 * (r : R)\n      map_zero' := by simp\n      map_add' := fun a b => by\n        simp only [add_re, Int.cast_add, add_im]\n        ring\n      map_one' := by simp\n      map_mul' := fun a b => by\n        have :\n          (a.re + a.im * r : R) * (b.re + b.im * r) =\n            a.re * b.re + (a.re * b.im + a.im * b.re) * r + a.im * b.im * (r * r) := by\n          ring\n        simp only [mul_re, Int.cast_add, Int.cast_mul, mul_im, this, r.prop]\n        ring }\n  invFun f := ⟨f sqrtd, by rw [← f.map_mul, dmuld, map_intCast]⟩\n  left_inv r := by simp\n  right_inv f := by\n    ext\n    simp\n\n"}
{"name":"Zsqrtd.lift_injective","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"R : Type\ninst✝¹ : CommRing R\ninst✝ : CharZero R\nd : Int\nr : Subtype fun r => Eq (HMul.hMul r r) ↑d\nhd : ∀ (n : Int), Ne d (HMul.hMul n n)\n⊢ Function.Injective ⇑(Zsqrtd.lift r)","decl":"/-- `lift r` is injective if `d` is non-square, and R has characteristic zero (that is, the map from\n`ℤ` into `R` is injective). -/\ntheorem lift_injective [CharZero R] {d : ℤ} (r : { r : R // r * r = ↑d })\n    (hd : ∀ n : ℤ, d ≠ n * n) : Function.Injective (lift r) :=\n  (injective_iff_map_eq_zero (lift r)).mpr fun a ha => by\n    have h_inj : Function.Injective ((↑) : ℤ → R) := Int.cast_injective\n    suffices lift r a.norm = 0 by\n      simp only [intCast_re, add_zero, lift_apply_apply, intCast_im, Int.cast_zero,\n        zero_mul] at this\n      rwa [← Int.cast_zero, h_inj.eq_iff, norm_eq_zero hd] at this\n    rw [norm_eq_mul_conj, RingHom.map_mul, ha, zero_mul]\n\n"}
{"name":"Zsqrtd.norm_eq_one_iff_mem_unitary","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\na : Zsqrtd d\n⊢ Iff (Eq a.norm 1) (Membership.mem (unitary (Zsqrtd d)) a)","decl":"/-- An element of `ℤ√d` has norm equal to `1` if and only if it is contained in the submonoid\nof unitary elements. -/\ntheorem norm_eq_one_iff_mem_unitary {d : ℤ} {a : ℤ√d} : a.norm = 1 ↔ a ∈ unitary (ℤ√d) := by\n  rw [unitary.mem_iff_self_mul_star, ← norm_eq_mul_conj]\n  norm_cast\n\n"}
{"name":"Zsqrtd.mker_norm_eq_unitary","module":"Mathlib.NumberTheory.Zsqrtd.Basic","initialProofState":"d : Int\n⊢ Eq (MonoidHom.mker Zsqrtd.normMonoidHom) (unitary (Zsqrtd d))","decl":"/-- The kernel of the norm map on `ℤ√d` equals the submonoid of unitary elements. -/\ntheorem mker_norm_eq_unitary {d : ℤ} : MonoidHom.mker (@normMonoidHom d) = unitary (ℤ√d) :=\n  Submonoid.ext fun _ => norm_eq_one_iff_mem_unitary\n\n"}
