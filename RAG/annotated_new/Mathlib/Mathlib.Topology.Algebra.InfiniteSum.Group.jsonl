{"name":"HasProd.inv","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\na : α\nh : HasProd f a\n⊢ HasProd (fun b => Inv.inv (f b)) (Inv.inv a)","decl":"@[to_additive]\ntheorem HasProd.inv (h : HasProd f a) : HasProd (fun b ↦ (f b)⁻¹) a⁻¹ := by\n  simpa only using h.map (MonoidHom.id α)⁻¹ continuous_inv\n\n"}
{"name":"HasSum.neg","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\na : α\nh : HasSum f a\n⊢ HasSum (fun b => Neg.neg (f b)) (Neg.neg a)","decl":"@[to_additive]\ntheorem HasProd.inv (h : HasProd f a) : HasProd (fun b ↦ (f b)⁻¹) a⁻¹ := by\n  simpa only using h.map (MonoidHom.id α)⁻¹ continuous_inv\n\n"}
{"name":"Multipliable.inv","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\nhf : Multipliable f\n⊢ Multipliable fun b => Inv.inv (f b)","decl":"@[to_additive]\ntheorem Multipliable.inv (hf : Multipliable f) : Multipliable fun b ↦ (f b)⁻¹ :=\n  hf.hasProd.inv.multipliable\n\n"}
{"name":"Summable.neg","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\nhf : Summable f\n⊢ Summable fun b => Neg.neg (f b)","decl":"@[to_additive]\ntheorem Multipliable.inv (hf : Multipliable f) : Multipliable fun b ↦ (f b)⁻¹ :=\n  hf.hasProd.inv.multipliable\n\n"}
{"name":"Summable.of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\nhf : Summable fun b => Neg.neg (f b)\n⊢ Summable f","decl":"@[to_additive]\ntheorem Multipliable.of_inv (hf : Multipliable fun b ↦ (f b)⁻¹) : Multipliable f := by\n  simpa only [inv_inv] using hf.inv\n\n"}
{"name":"Multipliable.of_inv","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\nhf : Multipliable fun b => Inv.inv (f b)\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem Multipliable.of_inv (hf : Multipliable fun b ↦ (f b)⁻¹) : Multipliable f := by\n  simpa only [inv_inv] using hf.inv\n\n"}
{"name":"multipliable_inv_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\n⊢ Iff (Multipliable fun b => Inv.inv (f b)) (Multipliable f)","decl":"@[to_additive]\ntheorem multipliable_inv_iff : (Multipliable fun b ↦ (f b)⁻¹) ↔ Multipliable f :=\n  ⟨Multipliable.of_inv, Multipliable.inv⟩\n\n"}
{"name":"summable_neg_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\n⊢ Iff (Summable fun b => Neg.neg (f b)) (Summable f)","decl":"@[to_additive]\ntheorem multipliable_inv_iff : (Multipliable fun b ↦ (f b)⁻¹) ↔ Multipliable f :=\n  ⟨Multipliable.of_inv, Multipliable.inv⟩\n\n"}
{"name":"HasSum.sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf g : β → α\na₁ a₂ : α\nhf : HasSum f a₁\nhg : HasSum g a₂\n⊢ HasSum (fun b => HSub.hSub (f b) (g b)) (HSub.hSub a₁ a₂)","decl":"@[to_additive]\ntheorem HasProd.div (hf : HasProd f a₁) (hg : HasProd g a₂) :\n    HasProd (fun b ↦ f b / g b) (a₁ / a₂) := by\n  simp only [div_eq_mul_inv]\n  exact hf.mul hg.inv\n\n"}
{"name":"HasProd.div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf g : β → α\na₁ a₂ : α\nhf : HasProd f a₁\nhg : HasProd g a₂\n⊢ HasProd (fun b => HDiv.hDiv (f b) (g b)) (HDiv.hDiv a₁ a₂)","decl":"@[to_additive]\ntheorem HasProd.div (hf : HasProd f a₁) (hg : HasProd g a₂) :\n    HasProd (fun b ↦ f b / g b) (a₁ / a₂) := by\n  simp only [div_eq_mul_inv]\n  exact hf.mul hg.inv\n\n"}
{"name":"Multipliable.div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf g : β → α\nhf : Multipliable f\nhg : Multipliable g\n⊢ Multipliable fun b => HDiv.hDiv (f b) (g b)","decl":"@[to_additive]\ntheorem Multipliable.div (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable fun b ↦ f b / g b :=\n  (hf.hasProd.div hg.hasProd).multipliable\n\n"}
{"name":"Summable.sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf g : β → α\nhf : Summable f\nhg : Summable g\n⊢ Summable fun b => HSub.hSub (f b) (g b)","decl":"@[to_additive]\ntheorem Multipliable.div (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable fun b ↦ f b / g b :=\n  (hf.hasProd.div hg.hasProd).multipliable\n\n"}
{"name":"Multipliable.trans_div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf g : β → α\nhg : Multipliable g\nhfg : Multipliable fun b => HDiv.hDiv (f b) (g b)\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem Multipliable.trans_div (hg : Multipliable g) (hfg : Multipliable fun b ↦ f b / g b) :\n    Multipliable f := by\n  simpa only [div_mul_cancel] using hfg.mul hg\n\n"}
{"name":"Summable.trans_sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf g : β → α\nhg : Summable g\nhfg : Summable fun b => HSub.hSub (f b) (g b)\n⊢ Summable f","decl":"@[to_additive]\ntheorem Multipliable.trans_div (hg : Multipliable g) (hfg : Multipliable fun b ↦ f b / g b) :\n    Multipliable f := by\n  simpa only [div_mul_cancel] using hfg.mul hg\n\n"}
{"name":"summable_iff_of_summable_sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf g : β → α\nhfg : Summable fun b => HSub.hSub (f b) (g b)\n⊢ Iff (Summable f) (Summable g)","decl":"@[to_additive]\ntheorem multipliable_iff_of_multipliable_div (hfg : Multipliable fun b ↦ f b / g b) :\n    Multipliable f ↔ Multipliable g :=\n  ⟨fun hf ↦ hf.trans_div <| by simpa only [inv_div] using hfg.inv, fun hg ↦ hg.trans_div hfg⟩\n\n"}
{"name":"multipliable_iff_of_multipliable_div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf g : β → α\nhfg : Multipliable fun b => HDiv.hDiv (f b) (g b)\n⊢ Iff (Multipliable f) (Multipliable g)","decl":"@[to_additive]\ntheorem multipliable_iff_of_multipliable_div (hfg : Multipliable fun b ↦ f b / g b) :\n    Multipliable f ↔ Multipliable g :=\n  ⟨fun hf ↦ hf.trans_div <| by simpa only [inv_div] using hfg.inv, fun hg ↦ hg.trans_div hfg⟩\n\n"}
{"name":"HasProd.update","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalGroup α\nf : β → α\na₁ : α\nhf : HasProd f a₁\nb : β\ninst✝ : DecidableEq β\na : α\n⊢ HasProd (Function.update f b a) (HMul.hMul (HDiv.hDiv a (f b)) a₁)","decl":"@[to_additive]\ntheorem HasProd.update (hf : HasProd f a₁) (b : β) [DecidableEq β] (a : α) :\n    HasProd (update f b a) (a / f b * a₁) := by\n  convert (hasProd_ite_eq b (a / f b)).mul hf with b'\n  by_cases h : b' = b\n  · rw [h, update_self]\n    simp [eq_self_iff_true, if_true, sub_add_cancel]\n  · simp only [h, update_of_ne, if_false, Ne, one_mul, not_false_iff]\n\n"}
{"name":"HasSum.update","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalAddGroup α\nf : β → α\na₁ : α\nhf : HasSum f a₁\nb : β\ninst✝ : DecidableEq β\na : α\n⊢ HasSum (Function.update f b a) (HAdd.hAdd (HSub.hSub a (f b)) a₁)","decl":"@[to_additive]\ntheorem HasProd.update (hf : HasProd f a₁) (b : β) [DecidableEq β] (a : α) :\n    HasProd (update f b a) (a / f b * a₁) := by\n  convert (hasProd_ite_eq b (a / f b)).mul hf with b'\n  by_cases h : b' = b\n  · rw [h, update_self]\n    simp [eq_self_iff_true, if_true, sub_add_cancel]\n  · simp only [h, update_of_ne, if_false, Ne, one_mul, not_false_iff]\n\n"}
{"name":"Multipliable.update","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalGroup α\nf : β → α\nhf : Multipliable f\nb : β\ninst✝ : DecidableEq β\na : α\n⊢ Multipliable (Function.update f b a)","decl":"@[to_additive]\ntheorem Multipliable.update (hf : Multipliable f) (b : β) [DecidableEq β] (a : α) :\n    Multipliable (update f b a) :=\n  (hf.hasProd.update b a).multipliable\n\n"}
{"name":"Summable.update","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalAddGroup α\nf : β → α\nhf : Summable f\nb : β\ninst✝ : DecidableEq β\na : α\n⊢ Summable (Function.update f b a)","decl":"@[to_additive]\ntheorem Multipliable.update (hf : Multipliable f) (b : β) [DecidableEq β] (a : α) :\n    Multipliable (update f b a) :=\n  (hf.hasProd.update b a).multipliable\n\n"}
{"name":"HasProd.hasProd_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\na₁ a₂ : α\ns : Set β\nhf : HasProd (Function.comp f Subtype.val) a₁\n⊢ Iff (HasProd (Function.comp f Subtype.val) a₂) (HasProd f (HMul.hMul a₁ a₂))","decl":"@[to_additive]\ntheorem HasProd.hasProd_compl_iff {s : Set β} (hf : HasProd (f ∘ (↑) : s → α) a₁) :\n    HasProd (f ∘ (↑) : ↑sᶜ → α) a₂ ↔ HasProd f (a₁ * a₂) := by\n  refine ⟨fun h ↦ hf.mul_compl h, fun h ↦ ?_⟩\n  rw [hasProd_subtype_iff_mulIndicator] at hf ⊢\n  rw [Set.mulIndicator_compl]\n  simpa only [div_eq_mul_inv, mul_inv_cancel_comm] using h.div hf\n\n"}
{"name":"HasSum.hasSum_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\na₁ a₂ : α\ns : Set β\nhf : HasSum (Function.comp f Subtype.val) a₁\n⊢ Iff (HasSum (Function.comp f Subtype.val) a₂) (HasSum f (HAdd.hAdd a₁ a₂))","decl":"@[to_additive]\ntheorem HasProd.hasProd_compl_iff {s : Set β} (hf : HasProd (f ∘ (↑) : s → α) a₁) :\n    HasProd (f ∘ (↑) : ↑sᶜ → α) a₂ ↔ HasProd f (a₁ * a₂) := by\n  refine ⟨fun h ↦ hf.mul_compl h, fun h ↦ ?_⟩\n  rw [hasProd_subtype_iff_mulIndicator] at hf ⊢\n  rw [Set.mulIndicator_compl]\n  simpa only [div_eq_mul_inv, mul_inv_cancel_comm] using h.div hf\n\n"}
{"name":"HasProd.hasProd_iff_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\na₁ a₂ : α\ns : Set β\nhf : HasProd (Function.comp f Subtype.val) a₁\n⊢ Iff (HasProd f a₂) (HasProd (Function.comp f Subtype.val) (HDiv.hDiv a₂ a₁))","decl":"@[to_additive]\ntheorem HasProd.hasProd_iff_compl {s : Set β} (hf : HasProd (f ∘ (↑) : s → α) a₁) :\n    HasProd f a₂ ↔ HasProd (f ∘ (↑) : ↑sᶜ → α) (a₂ / a₁) :=\n  Iff.symm <| hf.hasProd_compl_iff.trans <| by rw [mul_div_cancel]\n\n"}
{"name":"HasSum.hasSum_iff_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\na₁ a₂ : α\ns : Set β\nhf : HasSum (Function.comp f Subtype.val) a₁\n⊢ Iff (HasSum f a₂) (HasSum (Function.comp f Subtype.val) (HSub.hSub a₂ a₁))","decl":"@[to_additive]\ntheorem HasProd.hasProd_iff_compl {s : Set β} (hf : HasProd (f ∘ (↑) : s → α) a₁) :\n    HasProd f a₂ ↔ HasProd (f ∘ (↑) : ↑sᶜ → α) (a₂ / a₁) :=\n  Iff.symm <| hf.hasProd_compl_iff.trans <| by rw [mul_div_cancel]\n\n"}
{"name":"Multipliable.multipliable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\ns : Set β\nhf : Multipliable (Function.comp f Subtype.val)\n⊢ Iff (Multipliable (Function.comp f Subtype.val)) (Multipliable f)","decl":"@[to_additive]\ntheorem Multipliable.multipliable_compl_iff {s : Set β} (hf : Multipliable (f ∘ (↑) : s → α)) :\n    Multipliable (f ∘ (↑) : ↑sᶜ → α) ↔ Multipliable f where\n  mp := fun ⟨_, ha⟩ ↦ (hf.hasProd.hasProd_compl_iff.1 ha).multipliable\n  mpr := fun ⟨_, ha⟩ ↦ (hf.hasProd.hasProd_iff_compl.1 ha).multipliable\n\n"}
{"name":"Summable.summable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\ns : Set β\nhf : Summable (Function.comp f Subtype.val)\n⊢ Iff (Summable (Function.comp f Subtype.val)) (Summable f)","decl":"@[to_additive]\ntheorem Multipliable.multipliable_compl_iff {s : Set β} (hf : Multipliable (f ∘ (↑) : s → α)) :\n    Multipliable (f ∘ (↑) : ↑sᶜ → α) ↔ Multipliable f where\n  mp := fun ⟨_, ha⟩ ↦ (hf.hasProd.hasProd_compl_iff.1 ha).multipliable\n  mpr := fun ⟨_, ha⟩ ↦ (hf.hasProd.hasProd_iff_compl.1 ha).multipliable\n\n"}
{"name":"Finset.hasSum_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\na : α\ns : Finset β\n⊢ Iff (HasSum (fun x => f ↑x) a) (HasSum f (HAdd.hAdd a (s.sum fun i => f i)))","decl":"@[to_additive]\nprotected theorem Finset.hasProd_compl_iff (s : Finset β) :\n    HasProd (fun x : { x // x ∉ s } ↦ f x) a ↔ HasProd f (a * ∏ i ∈ s, f i) :=\n  (s.hasProd f).hasProd_compl_iff.trans <| by rw [mul_comm]\n\n"}
{"name":"Finset.hasProd_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\na : α\ns : Finset β\n⊢ Iff (HasProd (fun x => f ↑x) a) (HasProd f (HMul.hMul a (s.prod fun i => f i)))","decl":"@[to_additive]\nprotected theorem Finset.hasProd_compl_iff (s : Finset β) :\n    HasProd (fun x : { x // x ∉ s } ↦ f x) a ↔ HasProd f (a * ∏ i ∈ s, f i) :=\n  (s.hasProd f).hasProd_compl_iff.trans <| by rw [mul_comm]\n\n"}
{"name":"Finset.hasSum_iff_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\na : α\ns : Finset β\n⊢ Iff (HasSum f a) (HasSum (fun x => f ↑x) (HSub.hSub a (s.sum fun i => f i)))","decl":"@[to_additive]\nprotected theorem Finset.hasProd_iff_compl (s : Finset β) :\n    HasProd f a ↔ HasProd (fun x : { x // x ∉ s } ↦ f x) (a / ∏ i ∈ s, f i) :=\n  (s.hasProd f).hasProd_iff_compl\n\n"}
{"name":"Finset.hasProd_iff_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\na : α\ns : Finset β\n⊢ Iff (HasProd f a) (HasProd (fun x => f ↑x) (HDiv.hDiv a (s.prod fun i => f i)))","decl":"@[to_additive]\nprotected theorem Finset.hasProd_iff_compl (s : Finset β) :\n    HasProd f a ↔ HasProd (fun x : { x // x ∉ s } ↦ f x) (a / ∏ i ∈ s, f i) :=\n  (s.hasProd f).hasProd_iff_compl\n\n"}
{"name":"Finset.summable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\ns : Finset β\n⊢ Iff (Summable fun x => f ↑x) (Summable f)","decl":"@[to_additive]\nprotected theorem Finset.multipliable_compl_iff (s : Finset β) :\n    (Multipliable fun x : { x // x ∉ s } ↦ f x) ↔ Multipliable f :=\n  (s.multipliable f).multipliable_compl_iff\n\n"}
{"name":"Finset.multipliable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\ns : Finset β\n⊢ Iff (Multipliable fun x => f ↑x) (Multipliable f)","decl":"@[to_additive]\nprotected theorem Finset.multipliable_compl_iff (s : Finset β) :\n    (Multipliable fun x : { x // x ∉ s } ↦ f x) ↔ Multipliable f :=\n  (s.multipliable f).multipliable_compl_iff\n\n"}
{"name":"Set.Finite.summable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf : β → α\ns : Set β\nhs : s.Finite\n⊢ Iff (Summable (Function.comp f Subtype.val)) (Summable f)","decl":"@[to_additive]\ntheorem Set.Finite.multipliable_compl_iff {s : Set β} (hs : s.Finite) :\n    Multipliable (f ∘ (↑) : ↑sᶜ → α) ↔ Multipliable f :=\n  (hs.multipliable f).multipliable_compl_iff\n\n"}
{"name":"Set.Finite.multipliable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf : β → α\ns : Set β\nhs : s.Finite\n⊢ Iff (Multipliable (Function.comp f Subtype.val)) (Multipliable f)","decl":"@[to_additive]\ntheorem Set.Finite.multipliable_compl_iff {s : Set β} (hs : s.Finite) :\n    Multipliable (f ∘ (↑) : ↑sᶜ → α) ↔ Multipliable f :=\n  (hs.multipliable f).multipliable_compl_iff\n\n"}
{"name":"hasProd_ite_div_hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalGroup α\nf : β → α\na : α\ninst✝ : DecidableEq β\nhf : HasProd f a\nb : β\n⊢ HasProd (fun n => ite (Eq n b) 1 (f n)) (HDiv.hDiv a (f b))","decl":"@[to_additive]\ntheorem hasProd_ite_div_hasProd [DecidableEq β] (hf : HasProd f a) (b : β) :\n    HasProd (fun n ↦ ite (n = b) 1 (f n)) (a / f b) := by\n  convert hf.update b 1 using 1\n  · ext n\n    rw [Function.update_apply]\n  · rw [div_mul_eq_mul_div, one_mul]\n\n"}
{"name":"hasSum_ite_sub_hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalAddGroup α\nf : β → α\na : α\ninst✝ : DecidableEq β\nhf : HasSum f a\nb : β\n⊢ HasSum (fun n => ite (Eq n b) 0 (f n)) (HSub.hSub a (f b))","decl":"@[to_additive]\ntheorem hasProd_ite_div_hasProd [DecidableEq β] (hf : HasProd f a) (b : β) :\n    HasProd (fun n ↦ ite (n = b) 1 (f n)) (a / f b) := by\n  convert hf.update b 1 using 1\n  · ext n\n    rw [Function.update_apply]\n  · rw [div_mul_eq_mul_div, one_mul]\n\n"}
{"name":"Summable.congr_cofinite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf g : β → α\nhf : Summable f\nhfg : Filter.cofinite.EventuallyEq f g\n⊢ Summable g","decl":"/-- A more general version of `Multipliable.congr`, allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"A more general version of `Summable.congr`, allowing the functions to\ndisagree on a finite set.\"]\ntheorem Multipliable.congr_cofinite (hf : Multipliable f) (hfg : f =ᶠ[cofinite] g) :\n    Multipliable g :=\n  hfg.multipliable_compl_iff.mp <| (hfg.multipliable_compl_iff.mpr hf).congr (by simp)\n\n"}
{"name":"Multipliable.congr_cofinite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf g : β → α\nhf : Multipliable f\nhfg : Filter.cofinite.EventuallyEq f g\n⊢ Multipliable g","decl":"/-- A more general version of `Multipliable.congr`, allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"A more general version of `Summable.congr`, allowing the functions to\ndisagree on a finite set.\"]\ntheorem Multipliable.congr_cofinite (hf : Multipliable f) (hfg : f =ᶠ[cofinite] g) :\n    Multipliable g :=\n  hfg.multipliable_compl_iff.mp <| (hfg.multipliable_compl_iff.mpr hf).congr (by simp)\n\n"}
{"name":"summable_congr_cofinite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf g : β → α\nhfg : Filter.cofinite.EventuallyEq f g\n⊢ Iff (Summable f) (Summable g)","decl":"/-- A more general version of `multipliable_congr`, allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"A more general version of `summable_congr`, allowing the functions to\ndisagree on a finite set.\"]\ntheorem multipliable_congr_cofinite (hfg : f =ᶠ[cofinite] g) :\n    Multipliable f ↔ Multipliable g :=\n  ⟨fun h ↦ h.congr_cofinite hfg, fun h ↦ h.congr_cofinite (hfg.mono fun _ h' ↦ h'.symm)⟩\n\n"}
{"name":"multipliable_congr_cofinite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf g : β → α\nhfg : Filter.cofinite.EventuallyEq f g\n⊢ Iff (Multipliable f) (Multipliable g)","decl":"/-- A more general version of `multipliable_congr`, allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"A more general version of `summable_congr`, allowing the functions to\ndisagree on a finite set.\"]\ntheorem multipliable_congr_cofinite (hfg : f =ᶠ[cofinite] g) :\n    Multipliable f ↔ Multipliable g :=\n  ⟨fun h ↦ h.congr_cofinite hfg, fun h ↦ h.congr_cofinite (hfg.mono fun _ h' ↦ h'.symm)⟩\n\n"}
{"name":"Multipliable.congr_atTop","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf₁ g₁ : Nat → α\nhf : Multipliable f₁\nhfg : Filter.atTop.EventuallyEq f₁ g₁\n⊢ Multipliable g₁","decl":"@[to_additive]\ntheorem Multipliable.congr_atTop {f₁ g₁ : ℕ → α} (hf : Multipliable f₁) (hfg : f₁ =ᶠ[atTop] g₁) :\n    Multipliable g₁ := hf.congr_cofinite (Nat.cofinite_eq_atTop ▸ hfg)\n\n"}
{"name":"Summable.congr_atTop","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf₁ g₁ : Nat → α\nhf : Summable f₁\nhfg : Filter.atTop.EventuallyEq f₁ g₁\n⊢ Summable g₁","decl":"@[to_additive]\ntheorem Multipliable.congr_atTop {f₁ g₁ : ℕ → α} (hf : Multipliable f₁) (hfg : f₁ =ᶠ[atTop] g₁) :\n    Multipliable g₁ := hf.congr_cofinite (Nat.cofinite_eq_atTop ▸ hfg)\n\n"}
{"name":"summable_congr_atTop","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\ninst✝² : AddCommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalAddGroup α\nf₁ g₁ : Nat → α\nhfg : Filter.atTop.EventuallyEq f₁ g₁\n⊢ Iff (Summable f₁) (Summable g₁)","decl":"@[to_additive]\ntheorem multipliable_congr_atTop {f₁ g₁ : ℕ → α} (hfg : f₁ =ᶠ[atTop] g₁) :\n    Multipliable f₁ ↔ Multipliable g₁ := multipliable_congr_cofinite (Nat.cofinite_eq_atTop ▸ hfg)\n\n"}
{"name":"multipliable_congr_atTop","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\ninst✝² : CommGroup α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalGroup α\nf₁ g₁ : Nat → α\nhfg : Filter.atTop.EventuallyEq f₁ g₁\n⊢ Iff (Multipliable f₁) (Multipliable g₁)","decl":"@[to_additive]\ntheorem multipliable_congr_atTop {f₁ g₁ : ℕ → α} (hfg : f₁ =ᶠ[atTop] g₁) :\n    Multipliable f₁ ↔ Multipliable g₁ := multipliable_congr_cofinite (Nat.cofinite_eq_atTop ▸ hfg)\n\n"}
{"name":"tsum_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalAddGroup α\nf : β → α\ninst✝ : T2Space α\n⊢ Eq (tsum fun b => Neg.neg (f b)) (Neg.neg (tsum fun b => f b))","decl":"@[to_additive]\ntheorem tprod_inv : ∏' b, (f b)⁻¹ = (∏' b, f b)⁻¹ := by\n  by_cases hf : Multipliable f\n  · exact hf.hasProd.inv.tprod_eq\n  · simp [tprod_eq_one_of_not_multipliable hf,\n      tprod_eq_one_of_not_multipliable (mt Multipliable.of_inv hf)]\n\n"}
{"name":"tprod_inv","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalGroup α\nf : β → α\ninst✝ : T2Space α\n⊢ Eq (tprod fun b => Inv.inv (f b)) (Inv.inv (tprod fun b => f b))","decl":"@[to_additive]\ntheorem tprod_inv : ∏' b, (f b)⁻¹ = (∏' b, f b)⁻¹ := by\n  by_cases hf : Multipliable f\n  · exact hf.hasProd.inv.tprod_eq\n  · simp [tprod_eq_one_of_not_multipliable hf,\n      tprod_eq_one_of_not_multipliable (mt Multipliable.of_inv hf)]\n\n"}
{"name":"tprod_div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalGroup α\nf g : β → α\ninst✝ : T2Space α\nhf : Multipliable f\nhg : Multipliable g\n⊢ Eq (tprod fun b => HDiv.hDiv (f b) (g b)) (HDiv.hDiv (tprod fun b => f b) (tprod fun b => g b))","decl":"@[to_additive]\ntheorem tprod_div (hf : Multipliable f) (hg : Multipliable g) :\n    ∏' b, (f b / g b) = (∏' b, f b) / ∏' b, g b :=\n  (hf.hasProd.div hg.hasProd).tprod_eq\n\n"}
{"name":"tsum_sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalAddGroup α\nf g : β → α\ninst✝ : T2Space α\nhf : Summable f\nhg : Summable g\n⊢ Eq (tsum fun b => HSub.hSub (f b) (g b)) (HSub.hSub (tsum fun b => f b) (tsum fun b => g b))","decl":"@[to_additive]\ntheorem tprod_div (hf : Multipliable f) (hg : Multipliable g) :\n    ∏' b, (f b / g b) = (∏' b, f b) / ∏' b, g b :=\n  (hf.hasProd.div hg.hasProd).tprod_eq\n\n"}
{"name":"prod_mul_tprod_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalGroup α\nf : β → α\ninst✝ : T2Space α\ns : Finset β\nhf : Multipliable f\n⊢ Eq (HMul.hMul (s.prod fun x => f x) (tprod fun x => f ↑x)) (tprod fun x => f x)","decl":"@[to_additive]\ntheorem prod_mul_tprod_compl {s : Finset β} (hf : Multipliable f) :\n    (∏ x ∈ s, f x) * ∏' x : ↑(s : Set β)ᶜ, f x = ∏' x, f x :=\n  ((s.hasProd f).mul_compl (s.multipliable_compl_iff.2 hf).hasProd).tprod_eq.symm\n\n"}
{"name":"sum_add_tsum_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalAddGroup α\nf : β → α\ninst✝ : T2Space α\ns : Finset β\nhf : Summable f\n⊢ Eq (HAdd.hAdd (s.sum fun x => f x) (tsum fun x => f ↑x)) (tsum fun x => f x)","decl":"@[to_additive]\ntheorem prod_mul_tprod_compl {s : Finset β} (hf : Multipliable f) :\n    (∏ x ∈ s, f x) * ∏' x : ↑(s : Set β)ᶜ, f x = ∏' x, f x :=\n  ((s.hasProd f).mul_compl (s.multipliable_compl_iff.2 hf).hasProd).tprod_eq.symm\n\n"}
{"name":"tprod_eq_mul_tprod_ite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : CommGroup α\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalGroup α\nf : β → α\ninst✝¹ : T2Space α\ninst✝ : DecidableEq β\nhf : Multipliable f\nb : β\n⊢ Eq (tprod fun n => f n) (HMul.hMul (f b) (tprod fun n => ite (Eq n b) 1 (f n)))","decl":"/-- Let `f : β → α` be a multipliable function and let `b ∈ β` be an index.\nLemma `tprod_eq_mul_tprod_ite` writes `∏ n, f n` as `f b` times the product of the\nremaining terms. -/\n@[to_additive \"Let `f : β → α` be a summable function and let `b ∈ β` be an index.\nLemma `tsum_eq_add_tsum_ite` writes `Σ' n, f n` as `f b` plus the sum of the\nremaining terms.\"]\ntheorem tprod_eq_mul_tprod_ite [DecidableEq β] (hf : Multipliable f) (b : β) :\n    ∏' n, f n = f b * ∏' n, ite (n = b) 1 (f n) := by\n  rw [(hasProd_ite_div_hasProd hf.hasProd b).tprod_eq]\n  exact (mul_div_cancel _ _).symm\n\n"}
{"name":"tsum_eq_add_tsum_ite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : AddCommGroup α\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalAddGroup α\nf : β → α\ninst✝¹ : T2Space α\ninst✝ : DecidableEq β\nhf : Summable f\nb : β\n⊢ Eq (tsum fun n => f n) (HAdd.hAdd (f b) (tsum fun n => ite (Eq n b) 0 (f n)))","decl":"/-- Let `f : β → α` be a multipliable function and let `b ∈ β` be an index.\nLemma `tprod_eq_mul_tprod_ite` writes `∏ n, f n` as `f b` times the product of the\nremaining terms. -/\n@[to_additive \"Let `f : β → α` be a summable function and let `b ∈ β` be an index.\nLemma `tsum_eq_add_tsum_ite` writes `Σ' n, f n` as `f b` plus the sum of the\nremaining terms.\"]\ntheorem tprod_eq_mul_tprod_ite [DecidableEq β] (hf : Multipliable f) (b : β) :\n    ∏' n, f n = f b * ∏' n, ite (n = b) 1 (f n) := by\n  rw [(hasProd_ite_div_hasProd hf.hasProd b).tprod_eq]\n  exact (mul_div_cancel _ _).symm\n\n"}
{"name":"summable_iff_cauchySeq_finset","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : UniformSpace α\ninst✝ : CompleteSpace α\nf : β → α\n⊢ Iff (Summable f) (CauchySeq fun s => s.sum fun b => f b)","decl":"/-- The **Cauchy criterion** for infinite products, also known as the **Cauchy convergence test** -/\n@[to_additive \"The **Cauchy criterion** for infinite sums, also known as the\n**Cauchy convergence test**\"]\ntheorem multipliable_iff_cauchySeq_finset [CompleteSpace α] {f : β → α} :\n    Multipliable f ↔ CauchySeq fun s : Finset β ↦ ∏ b ∈ s, f b := by\n  classical exact cauchy_map_iff_exists_tendsto.symm\n\n"}
{"name":"multipliable_iff_cauchySeq_finset","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : UniformSpace α\ninst✝ : CompleteSpace α\nf : β → α\n⊢ Iff (Multipliable f) (CauchySeq fun s => s.prod fun b => f b)","decl":"/-- The **Cauchy criterion** for infinite products, also known as the **Cauchy convergence test** -/\n@[to_additive \"The **Cauchy criterion** for infinite sums, also known as the\n**Cauchy convergence test**\"]\ntheorem multipliable_iff_cauchySeq_finset [CompleteSpace α] {f : β → α} :\n    Multipliable f ↔ CauchySeq fun s : Finset β ↦ ∏ b ∈ s, f b := by\n  classical exact cauchy_map_iff_exists_tendsto.symm\n\n"}
{"name":"cauchySeq_finset_iff_sum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : UniformSpace α\ninst✝ : UniformAddGroup α\nf : β → α\n⊢ Iff (CauchySeq fun s => s.sum fun b => f b) (∀ (e : Set α), Membership.mem (nhds 0) e → Exists fun s => ∀ (t : Finset β), Disjoint t s → Membership.mem e (t.sum fun b => f b))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_prod_vanishing :\n    (CauchySeq fun s : Finset β ↦ ∏ b ∈ s, f b) ↔\n      ∀ e ∈ 𝓝 (1 : α), ∃ s : Finset β, ∀ t, Disjoint t s → (∏ b ∈ t, f b) ∈ e := by\n  classical\n  simp only [CauchySeq, cauchy_map_iff, and_iff_right atTop_neBot, prod_atTop_atTop_eq,\n    uniformity_eq_comap_nhds_one α, tendsto_comap_iff, Function.comp_def, atTop_neBot, true_and]\n  rw [tendsto_atTop']\n  constructor\n  · intro h e he\n    obtain ⟨⟨s₁, s₂⟩, h⟩ := h e he\n    use s₁ ∪ s₂\n    intro t ht\n    specialize h (s₁ ∪ s₂, s₁ ∪ s₂ ∪ t) ⟨le_sup_left, le_sup_of_le_left le_sup_right⟩\n    simpa only [Finset.prod_union ht.symm, mul_div_cancel_left] using h\n  · rintro h e he\n    rcases exists_nhds_split_inv he with ⟨d, hd, hde⟩\n    rcases h d hd with ⟨s, h⟩\n    use (s, s)\n    rintro ⟨t₁, t₂⟩ ⟨ht₁, ht₂⟩\n    have : ((∏ b ∈ t₂, f b) / ∏ b ∈ t₁, f b) = (∏ b ∈ t₂ \\ s, f b) / ∏ b ∈ t₁ \\ s, f b := by\n      rw [← Finset.prod_sdiff ht₁, ← Finset.prod_sdiff ht₂, mul_div_mul_right_eq_div]\n    simp only [this]\n    exact hde _ (h _ Finset.sdiff_disjoint) _ (h _ Finset.sdiff_disjoint)\n\n"}
{"name":"cauchySeq_finset_iff_prod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : UniformSpace α\ninst✝ : UniformGroup α\nf : β → α\n⊢ Iff (CauchySeq fun s => s.prod fun b => f b) (∀ (e : Set α), Membership.mem (nhds 1) e → Exists fun s => ∀ (t : Finset β), Disjoint t s → Membership.mem e (t.prod fun b => f b))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_prod_vanishing :\n    (CauchySeq fun s : Finset β ↦ ∏ b ∈ s, f b) ↔\n      ∀ e ∈ 𝓝 (1 : α), ∃ s : Finset β, ∀ t, Disjoint t s → (∏ b ∈ t, f b) ∈ e := by\n  classical\n  simp only [CauchySeq, cauchy_map_iff, and_iff_right atTop_neBot, prod_atTop_atTop_eq,\n    uniformity_eq_comap_nhds_one α, tendsto_comap_iff, Function.comp_def, atTop_neBot, true_and]\n  rw [tendsto_atTop']\n  constructor\n  · intro h e he\n    obtain ⟨⟨s₁, s₂⟩, h⟩ := h e he\n    use s₁ ∪ s₂\n    intro t ht\n    specialize h (s₁ ∪ s₂, s₁ ∪ s₂ ∪ t) ⟨le_sup_left, le_sup_of_le_left le_sup_right⟩\n    simpa only [Finset.prod_union ht.symm, mul_div_cancel_left] using h\n  · rintro h e he\n    rcases exists_nhds_split_inv he with ⟨d, hd, hde⟩\n    rcases h d hd with ⟨s, h⟩\n    use (s, s)\n    rintro ⟨t₁, t₂⟩ ⟨ht₁, ht₂⟩\n    have : ((∏ b ∈ t₂, f b) / ∏ b ∈ t₁, f b) = (∏ b ∈ t₂ \\ s, f b) / ∏ b ∈ t₁ \\ s, f b := by\n      rw [← Finset.prod_sdiff ht₁, ← Finset.prod_sdiff ht₂, mul_div_mul_right_eq_div]\n    simp only [this]\n    exact hde _ (h _ Finset.sdiff_disjoint) _ (h _ Finset.sdiff_disjoint)\n\n"}
{"name":"cauchySeq_finset_iff_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommGroup α\ninst✝¹ : UniformSpace α\ninst✝ : UniformAddGroup α\nf : β → α\n⊢ Iff (CauchySeq fun s => s.sum fun b => f b) (∀ (e : Set α), Membership.mem (nhds 0) e → Exists fun s => ∀ (t : Set β), Disjoint t ↑s → Membership.mem e (tsum fun b => f ↑b))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_tprod_vanishing :\n    (CauchySeq fun s : Finset β ↦ ∏ b ∈ s, f b) ↔\n      ∀ e ∈ 𝓝 (1 : α), ∃ s : Finset β, ∀ t : Set β, Disjoint t s → (∏' b : t, f b) ∈ e := by\n  simp_rw [cauchySeq_finset_iff_prod_vanishing, Set.disjoint_left, disjoint_left]\n  refine ⟨fun vanish e he ↦ ?_, fun vanish e he ↦ ?_⟩\n  · obtain ⟨o, ho, o_closed, oe⟩ := exists_mem_nhds_isClosed_subset he\n    obtain ⟨s, hs⟩ := vanish o ho\n    refine ⟨s, fun t hts ↦ oe ?_⟩\n    by_cases ht : Multipliable fun a : t ↦ f a\n    · classical\n      refine o_closed.mem_of_tendsto ht.hasProd (Eventually.of_forall fun t' ↦ ?_)\n      rw [← prod_subtype_map_embedding fun _ _ ↦ by rfl]\n      apply hs\n      simp_rw [Finset.mem_map]\n      rintro _ ⟨b, -, rfl⟩\n      exact hts b.prop\n    · exact tprod_eq_one_of_not_multipliable ht ▸ mem_of_mem_nhds ho\n  · obtain ⟨s, hs⟩ := vanish _ he\n    exact ⟨s, fun t hts ↦ (t.tprod_subtype f).symm ▸ hs _ hts⟩\n\n"}
{"name":"cauchySeq_finset_iff_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommGroup α\ninst✝¹ : UniformSpace α\ninst✝ : UniformGroup α\nf : β → α\n⊢ Iff (CauchySeq fun s => s.prod fun b => f b) (∀ (e : Set α), Membership.mem (nhds 1) e → Exists fun s => ∀ (t : Set β), Disjoint t ↑s → Membership.mem e (tprod fun b => f ↑b))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_tprod_vanishing :\n    (CauchySeq fun s : Finset β ↦ ∏ b ∈ s, f b) ↔\n      ∀ e ∈ 𝓝 (1 : α), ∃ s : Finset β, ∀ t : Set β, Disjoint t s → (∏' b : t, f b) ∈ e := by\n  simp_rw [cauchySeq_finset_iff_prod_vanishing, Set.disjoint_left, disjoint_left]\n  refine ⟨fun vanish e he ↦ ?_, fun vanish e he ↦ ?_⟩\n  · obtain ⟨o, ho, o_closed, oe⟩ := exists_mem_nhds_isClosed_subset he\n    obtain ⟨s, hs⟩ := vanish o ho\n    refine ⟨s, fun t hts ↦ oe ?_⟩\n    by_cases ht : Multipliable fun a : t ↦ f a\n    · classical\n      refine o_closed.mem_of_tendsto ht.hasProd (Eventually.of_forall fun t' ↦ ?_)\n      rw [← prod_subtype_map_embedding fun _ _ ↦ by rfl]\n      apply hs\n      simp_rw [Finset.mem_map]\n      rintro _ ⟨b, -, rfl⟩\n      exact hts b.prop\n    · exact tprod_eq_one_of_not_multipliable ht ▸ mem_of_mem_nhds ho\n  · obtain ⟨s, hs⟩ := vanish _ he\n    exact ⟨s, fun t hts ↦ (t.tprod_subtype f).symm ▸ hs _ hts⟩\n\n"}
{"name":"summable_iff_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\nf : β → α\ninst✝ : CompleteSpace α\n⊢ Iff (Summable f) (∀ (e : Set α), Membership.mem (nhds 0) e → Exists fun s => ∀ (t : Finset β), Disjoint t s → Membership.mem e (t.sum fun b => f b))","decl":"@[to_additive]\ntheorem multipliable_iff_vanishing :\n    Multipliable f ↔\n    ∀ e ∈ 𝓝 (1 : α), ∃ s : Finset β, ∀ t, Disjoint t s → (∏ b ∈ t, f b) ∈ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_prod_vanishing]\n\n"}
{"name":"multipliable_iff_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\nf : β → α\ninst✝ : CompleteSpace α\n⊢ Iff (Multipliable f) (∀ (e : Set α), Membership.mem (nhds 1) e → Exists fun s => ∀ (t : Finset β), Disjoint t s → Membership.mem e (t.prod fun b => f b))","decl":"@[to_additive]\ntheorem multipliable_iff_vanishing :\n    Multipliable f ↔\n    ∀ e ∈ 𝓝 (1 : α), ∃ s : Finset β, ∀ t, Disjoint t s → (∏ b ∈ t, f b) ∈ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_prod_vanishing]\n\n"}
{"name":"summable_iff_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\nf : β → α\ninst✝ : CompleteSpace α\n⊢ Iff (Summable f) (∀ (e : Set α), Membership.mem (nhds 0) e → Exists fun s => ∀ (t : Set β), Disjoint t ↑s → Membership.mem e (tsum fun b => f ↑b))","decl":"@[to_additive]\ntheorem multipliable_iff_tprod_vanishing : Multipliable f ↔\n    ∀ e ∈ 𝓝 (1 : α), ∃ s : Finset β, ∀ t : Set β, Disjoint t s → (∏' b : t, f b) ∈ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_tprod_vanishing]\n\n-- TODO: generalize to monoid with a uniform continuous subtraction operator: `(a + b) - b = a`\n"}
{"name":"multipliable_iff_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\nf : β → α\ninst✝ : CompleteSpace α\n⊢ Iff (Multipliable f) (∀ (e : Set α), Membership.mem (nhds 1) e → Exists fun s => ∀ (t : Set β), Disjoint t ↑s → Membership.mem e (tprod fun b => f ↑b))","decl":"@[to_additive]\ntheorem multipliable_iff_tprod_vanishing : Multipliable f ↔\n    ∀ e ∈ 𝓝 (1 : α), ∃ s : Finset β, ∀ t : Set β, Disjoint t s → (∏' b : t, f b) ∈ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_tprod_vanishing]\n\n-- TODO: generalize to monoid with a uniform continuous subtraction operator: `(a + b) - b = a`\n"}
{"name":"Multipliable.multipliable_of_eq_one_or_self","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\nf g : β → α\ninst✝ : CompleteSpace α\nhf : Multipliable f\nh : ∀ (b : β), Or (Eq (g b) 1) (Eq (g b) (f b))\n⊢ Multipliable g","decl":"@[to_additive]\ntheorem Multipliable.multipliable_of_eq_one_or_self (hf : Multipliable f)\n    (h : ∀ b, g b = 1 ∨ g b = f b) : Multipliable g := by\n  classical\n  exact multipliable_iff_vanishing.2 fun e he ↦\n    let ⟨s, hs⟩ := multipliable_iff_vanishing.1 hf e he\n    ⟨s, fun t ht ↦\n      have eq : ∏ b ∈ t with g b = f b, f b = ∏ b ∈ t, g b :=\n        calc\n          ∏ b ∈ t with g b = f b, f b = ∏ b ∈ t with g b = f b, g b :=\n            Finset.prod_congr rfl fun b hb ↦ (Finset.mem_filter.1 hb).2.symm\n          _ = ∏ b ∈ t, g b := by\n           {refine Finset.prod_subset (Finset.filter_subset _ _) ?_\n            intro b hbt hb\n            simp only [Finset.mem_filter, and_iff_right hbt] at hb\n            exact (h b).resolve_right hb}\n      eq ▸ hs _ <| Finset.disjoint_of_subset_left (Finset.filter_subset _ _) ht⟩\n\n"}
{"name":"Summable.summable_of_eq_zero_or_self","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\nf g : β → α\ninst✝ : CompleteSpace α\nhf : Summable f\nh : ∀ (b : β), Or (Eq (g b) 0) (Eq (g b) (f b))\n⊢ Summable g","decl":"@[to_additive]\ntheorem Multipliable.multipliable_of_eq_one_or_self (hf : Multipliable f)\n    (h : ∀ b, g b = 1 ∨ g b = f b) : Multipliable g := by\n  classical\n  exact multipliable_iff_vanishing.2 fun e he ↦\n    let ⟨s, hs⟩ := multipliable_iff_vanishing.1 hf e he\n    ⟨s, fun t ht ↦\n      have eq : ∏ b ∈ t with g b = f b, f b = ∏ b ∈ t, g b :=\n        calc\n          ∏ b ∈ t with g b = f b, f b = ∏ b ∈ t with g b = f b, g b :=\n            Finset.prod_congr rfl fun b hb ↦ (Finset.mem_filter.1 hb).2.symm\n          _ = ∏ b ∈ t, g b := by\n           {refine Finset.prod_subset (Finset.filter_subset _ _) ?_\n            intro b hbt hb\n            simp only [Finset.mem_filter, and_iff_right hbt] at hb\n            exact (h b).resolve_right hb}\n      eq ▸ hs _ <| Finset.disjoint_of_subset_left (Finset.filter_subset _ _) ht⟩\n\n"}
{"name":"Multipliable.mulIndicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\nf : β → α\ninst✝ : CompleteSpace α\nhf : Multipliable f\ns : Set β\n⊢ Multipliable (s.mulIndicator f)","decl":"@[to_additive]\nprotected theorem Multipliable.mulIndicator (hf : Multipliable f) (s : Set β) :\n    Multipliable (s.mulIndicator f) :=\n  hf.multipliable_of_eq_one_or_self <| Set.mulIndicator_eq_one_or_self _ _\n\n"}
{"name":"Summable.indicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\nf : β → α\ninst✝ : CompleteSpace α\nhf : Summable f\ns : Set β\n⊢ Summable (s.indicator f)","decl":"@[to_additive]\nprotected theorem Multipliable.mulIndicator (hf : Multipliable f) (s : Set β) :\n    Multipliable (s.mulIndicator f) :=\n  hf.multipliable_of_eq_one_or_self <| Set.mulIndicator_eq_one_or_self _ _\n\n"}
{"name":"Summable.comp_injective","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\nf : β → α\ninst✝ : CompleteSpace α\ni : γ → β\nhf : Summable f\nhi : Function.Injective i\n⊢ Summable (Function.comp f i)","decl":"@[to_additive]\ntheorem Multipliable.comp_injective {i : γ → β} (hf : Multipliable f) (hi : Injective i) :\n    Multipliable (f ∘ i) := by\n  simpa only [Set.mulIndicator_range_comp] using\n    (hi.multipliable_iff (fun x hx ↦ Set.mulIndicator_of_not_mem hx _)).2\n    (hf.mulIndicator (Set.range i))\n\n"}
{"name":"Multipliable.comp_injective","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\nf : β → α\ninst✝ : CompleteSpace α\ni : γ → β\nhf : Multipliable f\nhi : Function.Injective i\n⊢ Multipliable (Function.comp f i)","decl":"@[to_additive]\ntheorem Multipliable.comp_injective {i : γ → β} (hf : Multipliable f) (hi : Injective i) :\n    Multipliable (f ∘ i) := by\n  simpa only [Set.mulIndicator_range_comp] using\n    (hi.multipliable_iff (fun x hx ↦ Set.mulIndicator_of_not_mem hx _)).2\n    (hf.mulIndicator (Set.range i))\n\n"}
{"name":"Summable.subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\nf : β → α\ninst✝ : CompleteSpace α\nhf : Summable f\ns : Set β\n⊢ Summable (Function.comp f Subtype.val)","decl":"@[to_additive]\ntheorem Multipliable.subtype (hf : Multipliable f) (s : Set β) : Multipliable (f ∘ (↑) : s → α) :=\n  hf.comp_injective Subtype.coe_injective\n\n"}
{"name":"Multipliable.subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\nf : β → α\ninst✝ : CompleteSpace α\nhf : Multipliable f\ns : Set β\n⊢ Multipliable (Function.comp f Subtype.val)","decl":"@[to_additive]\ntheorem Multipliable.subtype (hf : Multipliable f) (s : Set β) : Multipliable (f ∘ (↑) : s → α) :=\n  hf.comp_injective Subtype.coe_injective\n\n"}
{"name":"multipliable_subtype_and_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformGroup α\nf : β → α\ninst✝ : CompleteSpace α\ns : Set β\n⊢ Iff (And (Multipliable fun x => f ↑x) (Multipliable fun x => f ↑x)) (Multipliable f)","decl":"@[to_additive]\ntheorem multipliable_subtype_and_compl {s : Set β} :\n    ((Multipliable fun x : s ↦ f x) ∧ Multipliable fun x : ↑sᶜ ↦ f x) ↔ Multipliable f :=\n  ⟨and_imp.2 Multipliable.mul_compl, fun h ↦ ⟨h.subtype s, h.subtype sᶜ⟩⟩\n\n"}
{"name":"summable_subtype_and_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommGroup α\ninst✝² : UniformSpace α\ninst✝¹ : UniformAddGroup α\nf : β → α\ninst✝ : CompleteSpace α\ns : Set β\n⊢ Iff (And (Summable fun x => f ↑x) (Summable fun x => f ↑x)) (Summable f)","decl":"@[to_additive]\ntheorem multipliable_subtype_and_compl {s : Set β} :\n    ((Multipliable fun x : s ↦ f x) ∧ Multipliable fun x : ↑sᶜ ↦ f x) ↔ Multipliable f :=\n  ⟨and_imp.2 Multipliable.mul_compl, fun h ↦ ⟨h.subtype s, h.subtype sᶜ⟩⟩\n\n"}
{"name":"tprod_subtype_mul_tprod_subtype_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : CommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T2Space α\nf : β → α\nhf : Multipliable f\ns : Set β\n⊢ Eq (HMul.hMul (tprod fun x => f ↑x) (tprod fun x => f ↑x)) (tprod fun x => f x)","decl":"@[to_additive]\ntheorem tprod_subtype_mul_tprod_subtype_compl [T2Space α] {f : β → α} (hf : Multipliable f)\n    (s : Set β) : (∏' x : s, f x) * ∏' x : ↑sᶜ, f x = ∏' x, f x :=\n  ((hf.subtype s).hasProd.mul_compl (hf.subtype { x | x ∉ s }).hasProd).unique hf.hasProd\n\n"}
{"name":"tsum_subtype_add_tsum_subtype_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : AddCommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformAddGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T2Space α\nf : β → α\nhf : Summable f\ns : Set β\n⊢ Eq (HAdd.hAdd (tsum fun x => f ↑x) (tsum fun x => f ↑x)) (tsum fun x => f x)","decl":"@[to_additive]\ntheorem tprod_subtype_mul_tprod_subtype_compl [T2Space α] {f : β → α} (hf : Multipliable f)\n    (s : Set β) : (∏' x : s, f x) * ∏' x : ↑sᶜ, f x = ∏' x, f x :=\n  ((hf.subtype s).hasProd.mul_compl (hf.subtype { x | x ∉ s }).hasProd).unique hf.hasProd\n\n"}
{"name":"sum_add_tsum_subtype_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : AddCommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformAddGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T2Space α\nf : β → α\nhf : Summable f\ns : Finset β\n⊢ Eq (HAdd.hAdd (s.sum fun x => f x) (tsum fun x => f ↑x)) (tsum fun x => f x)","decl":"@[to_additive]\ntheorem prod_mul_tprod_subtype_compl [T2Space α] {f : β → α} (hf : Multipliable f) (s : Finset β) :\n    (∏ x ∈ s, f x) * ∏' x : { x // x ∉ s }, f x = ∏' x, f x := by\n  rw [← tprod_subtype_mul_tprod_subtype_compl hf s]\n  simp only [Finset.tprod_subtype', mul_right_inj]\n  rfl\n\n"}
{"name":"prod_mul_tprod_subtype_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : CommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T2Space α\nf : β → α\nhf : Multipliable f\ns : Finset β\n⊢ Eq (HMul.hMul (s.prod fun x => f x) (tprod fun x => f ↑x)) (tprod fun x => f x)","decl":"@[to_additive]\ntheorem prod_mul_tprod_subtype_compl [T2Space α] {f : β → α} (hf : Multipliable f) (s : Finset β) :\n    (∏ x ∈ s, f x) * ∏' x : { x // x ∉ s }, f x = ∏' x, f x := by\n  rw [← tprod_subtype_mul_tprod_subtype_compl hf s]\n  simp only [Finset.tprod_subtype', mul_right_inj]\n  rfl\n\n"}
{"name":"Multipliable.vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝² : TopologicalSpace G\ninst✝¹ : CommGroup G\ninst✝ : TopologicalGroup G\nf : α → G\nhf : Multipliable f\ne : Set G\nhe : Membership.mem (nhds 1) e\n⊢ Exists fun s => ∀ (t : Finset α), Disjoint t s → Membership.mem e (t.prod fun k => f k)","decl":"@[to_additive]\ntheorem Multipliable.vanishing (hf : Multipliable f) ⦃e : Set G⦄ (he : e ∈ 𝓝 (1 : G)) :\n    ∃ s : Finset α, ∀ t, Disjoint t s → (∏ k ∈ t, f k) ∈ e := by\n  classical\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  exact cauchySeq_finset_iff_prod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Summable.vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝² : TopologicalSpace G\ninst✝¹ : AddCommGroup G\ninst✝ : TopologicalAddGroup G\nf : α → G\nhf : Summable f\ne : Set G\nhe : Membership.mem (nhds 0) e\n⊢ Exists fun s => ∀ (t : Finset α), Disjoint t s → Membership.mem e (t.sum fun k => f k)","decl":"@[to_additive]\ntheorem Multipliable.vanishing (hf : Multipliable f) ⦃e : Set G⦄ (he : e ∈ 𝓝 (1 : G)) :\n    ∃ s : Finset α, ∀ t, Disjoint t s → (∏ k ∈ t, f k) ∈ e := by\n  classical\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  exact cauchySeq_finset_iff_prod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Multipliable.tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝² : TopologicalSpace G\ninst✝¹ : CommGroup G\ninst✝ : TopologicalGroup G\nf : α → G\nhf : Multipliable f\ne : Set G\nhe : Membership.mem (nhds 1) e\n⊢ Exists fun s => ∀ (t : Set α), Disjoint t ↑s → Membership.mem e (tprod fun b => f ↑b)","decl":"@[to_additive]\ntheorem Multipliable.tprod_vanishing (hf : Multipliable f) ⦃e : Set G⦄ (he : e ∈ 𝓝 1) :\n    ∃ s : Finset α, ∀ t : Set α, Disjoint t s → (∏' b : t, f b) ∈ e := by\n  classical\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  exact cauchySeq_finset_iff_tprod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Summable.tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝² : TopologicalSpace G\ninst✝¹ : AddCommGroup G\ninst✝ : TopologicalAddGroup G\nf : α → G\nhf : Summable f\ne : Set G\nhe : Membership.mem (nhds 0) e\n⊢ Exists fun s => ∀ (t : Set α), Disjoint t ↑s → Membership.mem e (tsum fun b => f ↑b)","decl":"@[to_additive]\ntheorem Multipliable.tprod_vanishing (hf : Multipliable f) ⦃e : Set G⦄ (he : e ∈ 𝓝 1) :\n    ∃ s : Finset α, ∀ t : Set α, Disjoint t s → (∏' b : t, f b) ∈ e := by\n  classical\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  exact cauchySeq_finset_iff_tprod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"tendsto_tprod_compl_atTop_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝² : TopologicalSpace G\ninst✝¹ : CommGroup G\ninst✝ : TopologicalGroup G\nf : α → G\n⊢ Filter.Tendsto (fun s => tprod fun a => f ↑a) Filter.atTop (nhds 1)","decl":"/-- The product over the complement of a finset tends to `1` when the finset grows to cover the\nwhole space. This does not need a multipliability assumption, as otherwise all such products are\none. -/\n@[to_additive \"The sum over the complement of a finset tends to `0` when the finset grows to cover\nthe whole space. This does not need a summability assumption, as otherwise all such sums are zero.\"]\ntheorem tendsto_tprod_compl_atTop_one (f : α → G) :\n    Tendsto (fun s : Finset α ↦ ∏' a : { x // x ∉ s }, f a) atTop (𝓝 1) := by\n  classical\n  by_cases H : Multipliable f\n  · intro e he\n    obtain ⟨s, hs⟩ := H.tprod_vanishing he\n    rw [Filter.mem_map, mem_atTop_sets]\n    exact ⟨s, fun t hts ↦ hs _ <| Set.disjoint_left.mpr fun a ha has ↦ ha (hts has)⟩\n  · refine tendsto_const_nhds.congr fun _ ↦ (tprod_eq_one_of_not_multipliable ?_).symm\n    rwa [Finset.multipliable_compl_iff]\n\n"}
{"name":"tendsto_tsum_compl_atTop_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝² : TopologicalSpace G\ninst✝¹ : AddCommGroup G\ninst✝ : TopologicalAddGroup G\nf : α → G\n⊢ Filter.Tendsto (fun s => tsum fun a => f ↑a) Filter.atTop (nhds 0)","decl":"/-- The product over the complement of a finset tends to `1` when the finset grows to cover the\nwhole space. This does not need a multipliability assumption, as otherwise all such products are\none. -/\n@[to_additive \"The sum over the complement of a finset tends to `0` when the finset grows to cover\nthe whole space. This does not need a summability assumption, as otherwise all such sums are zero.\"]\ntheorem tendsto_tprod_compl_atTop_one (f : α → G) :\n    Tendsto (fun s : Finset α ↦ ∏' a : { x // x ∉ s }, f a) atTop (𝓝 1) := by\n  classical\n  by_cases H : Multipliable f\n  · intro e he\n    obtain ⟨s, hs⟩ := H.tprod_vanishing he\n    rw [Filter.mem_map, mem_atTop_sets]\n    exact ⟨s, fun t hts ↦ hs _ <| Set.disjoint_left.mpr fun a ha has ↦ ha (hts has)⟩\n  · refine tendsto_const_nhds.congr fun _ ↦ (tprod_eq_one_of_not_multipliable ?_).symm\n    rwa [Finset.multipliable_compl_iff]\n\n"}
{"name":"Multipliable.tendsto_cofinite_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝² : TopologicalSpace G\ninst✝¹ : CommGroup G\ninst✝ : TopologicalGroup G\nf : α → G\nhf : Multipliable f\n⊢ Filter.Tendsto f Filter.cofinite (nhds 1)","decl":"/-- Product divergence test: if `f` is unconditionally multipliable, then `f x` tends to one along\n`cofinite`. -/\n@[to_additive \"Series divergence test: if `f` is unconditionally summable, then `f x` tends to zero\nalong `cofinite`.\"]\ntheorem Multipliable.tendsto_cofinite_one (hf : Multipliable f) : Tendsto f cofinite (𝓝 1) := by\n  intro e he\n  rw [Filter.mem_map]\n  rcases hf.vanishing he with ⟨s, hs⟩\n  refine s.eventually_cofinite_nmem.mono fun x hx ↦ ?_\n  · simpa using hs {x} (disjoint_singleton_left.2 hx)\n\n"}
{"name":"Summable.tendsto_cofinite_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝² : TopologicalSpace G\ninst✝¹ : AddCommGroup G\ninst✝ : TopologicalAddGroup G\nf : α → G\nhf : Summable f\n⊢ Filter.Tendsto f Filter.cofinite (nhds 0)","decl":"/-- Product divergence test: if `f` is unconditionally multipliable, then `f x` tends to one along\n`cofinite`. -/\n@[to_additive \"Series divergence test: if `f` is unconditionally summable, then `f x` tends to zero\nalong `cofinite`.\"]\ntheorem Multipliable.tendsto_cofinite_one (hf : Multipliable f) : Tendsto f cofinite (𝓝 1) := by\n  intro e he\n  rw [Filter.mem_map]\n  rcases hf.vanishing he with ⟨s, hs⟩\n  refine s.eventually_cofinite_nmem.mono fun x hx ↦ ?_\n  · simpa using hs {x} (disjoint_singleton_left.2 hx)\n\n"}
{"name":"Summable.countable_support","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝⁴ : TopologicalSpace G\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalAddGroup G\nf : α → G\ninst✝¹ : FirstCountableTopology G\ninst✝ : T1Space G\nhf : Summable f\n⊢ (Function.support f).Countable","decl":"@[to_additive]\ntheorem Multipliable.countable_mulSupport [FirstCountableTopology G] [T1Space G]\n    (hf : Multipliable f) : f.mulSupport.Countable := by\n  simpa only [ker_nhds] using hf.tendsto_cofinite_one.countable_compl_preimage_ker\n\n"}
{"name":"Multipliable.countable_mulSupport","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"α : Type u_1\nG : Type u_4\ninst✝⁴ : TopologicalSpace G\ninst✝³ : CommGroup G\ninst✝² : TopologicalGroup G\nf : α → G\ninst✝¹ : FirstCountableTopology G\ninst✝ : T1Space G\nhf : Multipliable f\n⊢ (Function.mulSupport f).Countable","decl":"@[to_additive]\ntheorem Multipliable.countable_mulSupport [FirstCountableTopology G] [T1Space G]\n    (hf : Multipliable f) : f.mulSupport.Countable := by\n  simpa only [ker_nhds] using hf.tendsto_cofinite_one.countable_compl_preimage_ker\n\n"}
{"name":"summable_const_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"β : Type u_2\nG : Type u_4\ninst✝⁴ : TopologicalSpace G\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : Infinite β\ninst✝ : T2Space G\na : G\n⊢ Iff (Summable fun x => a) (Eq a 0)","decl":"@[to_additive]\ntheorem multipliable_const_iff [Infinite β] [T2Space G] (a : G) :\n    Multipliable (fun _ : β ↦ a) ↔ a = 1 := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · by_contra ha\n    have : {a}ᶜ ∈ 𝓝 1 := compl_singleton_mem_nhds (Ne.symm ha)\n    have : Finite β := by\n      simpa [← Set.finite_univ_iff] using h.tendsto_cofinite_one this\n    exact not_finite β\n  · rintro rfl\n    exact multipliable_one\n\n"}
{"name":"multipliable_const_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"β : Type u_2\nG : Type u_4\ninst✝⁴ : TopologicalSpace G\ninst✝³ : CommGroup G\ninst✝² : TopologicalGroup G\ninst✝¹ : Infinite β\ninst✝ : T2Space G\na : G\n⊢ Iff (Multipliable fun x => a) (Eq a 1)","decl":"@[to_additive]\ntheorem multipliable_const_iff [Infinite β] [T2Space G] (a : G) :\n    Multipliable (fun _ : β ↦ a) ↔ a = 1 := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · by_contra ha\n    have : {a}ᶜ ∈ 𝓝 1 := compl_singleton_mem_nhds (Ne.symm ha)\n    have : Finite β := by\n      simpa [← Set.finite_univ_iff] using h.tendsto_cofinite_one this\n    exact not_finite β\n  · rintro rfl\n    exact multipliable_one\n\n"}
{"name":"tsum_const","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"β : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace G\ninst✝² : AddCommGroup G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : T2Space G\na : G\n⊢ Eq (tsum fun x => a) (HSMul.hSMul (Nat.card β) a)","decl":"@[to_additive (attr := simp)]\ntheorem tprod_const [T2Space G] (a : G) : ∏' _ : β, a = a ^ (Nat.card β) := by\n  rcases finite_or_infinite β with hβ|hβ\n  · letI : Fintype β := Fintype.ofFinite β\n    rw [tprod_eq_prod (s := univ) (fun x hx ↦ (hx (mem_univ x)).elim)]\n    simp only [prod_const, Nat.card_eq_fintype_card, Fintype.card]\n  · simp only [Nat.card_eq_zero_of_infinite, pow_zero]\n    rcases eq_or_ne a 1 with rfl|ha\n    · simp\n    · apply tprod_eq_one_of_not_multipliable\n      simpa [multipliable_const_iff] using ha\n\n"}
{"name":"tprod_const","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"β : Type u_2\nG : Type u_4\ninst✝³ : TopologicalSpace G\ninst✝² : CommGroup G\ninst✝¹ : TopologicalGroup G\ninst✝ : T2Space G\na : G\n⊢ Eq (tprod fun x => a) (HPow.hPow a (Nat.card β))","decl":"@[to_additive (attr := simp)]\ntheorem tprod_const [T2Space G] (a : G) : ∏' _ : β, a = a ^ (Nat.card β) := by\n  rcases finite_or_infinite β with hβ|hβ\n  · letI : Fintype β := Fintype.ofFinite β\n    rw [tprod_eq_prod (s := univ) (fun x hx ↦ (hx (mem_univ x)).elim)]\n    simp only [prod_const, Nat.card_eq_fintype_card, Fintype.card]\n  · simp only [Nat.card_eq_zero_of_infinite, pow_zero]\n    rcases eq_or_ne a 1 with rfl|ha\n    · simp\n    · apply tprod_eq_one_of_not_multipliable\n      simpa [multipliable_const_iff] using ha\n\n"}
