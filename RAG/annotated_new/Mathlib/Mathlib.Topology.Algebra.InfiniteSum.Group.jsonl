{"name":"HasProd.inv","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\na : Î±\nh : HasProd f a\nâŠ¢ HasProd (fun b => Inv.inv (f b)) (Inv.inv a)","decl":"@[to_additive]\ntheorem HasProd.inv (h : HasProd f a) : HasProd (fun b â†¦ (f b)â»Â¹) aâ»Â¹ := by\n  simpa only using h.map (MonoidHom.id Î±)â»Â¹ continuous_inv\n\n"}
{"name":"HasSum.neg","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\na : Î±\nh : HasSum f a\nâŠ¢ HasSum (fun b => Neg.neg (f b)) (Neg.neg a)","decl":"@[to_additive]\ntheorem HasProd.inv (h : HasProd f a) : HasProd (fun b â†¦ (f b)â»Â¹) aâ»Â¹ := by\n  simpa only using h.map (MonoidHom.id Î±)â»Â¹ continuous_inv\n\n"}
{"name":"Multipliable.inv","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\nhf : Multipliable f\nâŠ¢ Multipliable fun b => Inv.inv (f b)","decl":"@[to_additive]\ntheorem Multipliable.inv (hf : Multipliable f) : Multipliable fun b â†¦ (f b)â»Â¹ :=\n  hf.hasProd.inv.multipliable\n\n"}
{"name":"Summable.neg","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\nhf : Summable f\nâŠ¢ Summable fun b => Neg.neg (f b)","decl":"@[to_additive]\ntheorem Multipliable.inv (hf : Multipliable f) : Multipliable fun b â†¦ (f b)â»Â¹ :=\n  hf.hasProd.inv.multipliable\n\n"}
{"name":"Summable.of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\nhf : Summable fun b => Neg.neg (f b)\nâŠ¢ Summable f","decl":"@[to_additive]\ntheorem Multipliable.of_inv (hf : Multipliable fun b â†¦ (f b)â»Â¹) : Multipliable f := by\n  simpa only [inv_inv] using hf.inv\n\n"}
{"name":"Multipliable.of_inv","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\nhf : Multipliable fun b => Inv.inv (f b)\nâŠ¢ Multipliable f","decl":"@[to_additive]\ntheorem Multipliable.of_inv (hf : Multipliable fun b â†¦ (f b)â»Â¹) : Multipliable f := by\n  simpa only [inv_inv] using hf.inv\n\n"}
{"name":"multipliable_inv_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (Multipliable fun b => Inv.inv (f b)) (Multipliable f)","decl":"@[to_additive]\ntheorem multipliable_inv_iff : (Multipliable fun b â†¦ (f b)â»Â¹) â†” Multipliable f :=\n  âŸ¨Multipliable.of_inv, Multipliable.invâŸ©\n\n"}
{"name":"summable_neg_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (Summable fun b => Neg.neg (f b)) (Summable f)","decl":"@[to_additive]\ntheorem multipliable_inv_iff : (Multipliable fun b â†¦ (f b)â»Â¹) â†” Multipliable f :=\n  âŸ¨Multipliable.of_inv, Multipliable.invâŸ©\n\n"}
{"name":"HasSum.sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf g : Î² â†’ Î±\naâ‚ aâ‚‚ : Î±\nhf : HasSum f aâ‚\nhg : HasSum g aâ‚‚\nâŠ¢ HasSum (fun b => HSub.hSub (f b) (g b)) (HSub.hSub aâ‚ aâ‚‚)","decl":"@[to_additive]\ntheorem HasProd.div (hf : HasProd f aâ‚) (hg : HasProd g aâ‚‚) :\n    HasProd (fun b â†¦ f b / g b) (aâ‚ / aâ‚‚) := by\n  simp only [div_eq_mul_inv]\n  exact hf.mul hg.inv\n\n"}
{"name":"HasProd.div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf g : Î² â†’ Î±\naâ‚ aâ‚‚ : Î±\nhf : HasProd f aâ‚\nhg : HasProd g aâ‚‚\nâŠ¢ HasProd (fun b => HDiv.hDiv (f b) (g b)) (HDiv.hDiv aâ‚ aâ‚‚)","decl":"@[to_additive]\ntheorem HasProd.div (hf : HasProd f aâ‚) (hg : HasProd g aâ‚‚) :\n    HasProd (fun b â†¦ f b / g b) (aâ‚ / aâ‚‚) := by\n  simp only [div_eq_mul_inv]\n  exact hf.mul hg.inv\n\n"}
{"name":"Multipliable.div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf g : Î² â†’ Î±\nhf : Multipliable f\nhg : Multipliable g\nâŠ¢ Multipliable fun b => HDiv.hDiv (f b) (g b)","decl":"@[to_additive]\ntheorem Multipliable.div (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable fun b â†¦ f b / g b :=\n  (hf.hasProd.div hg.hasProd).multipliable\n\n"}
{"name":"Summable.sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf g : Î² â†’ Î±\nhf : Summable f\nhg : Summable g\nâŠ¢ Summable fun b => HSub.hSub (f b) (g b)","decl":"@[to_additive]\ntheorem Multipliable.div (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable fun b â†¦ f b / g b :=\n  (hf.hasProd.div hg.hasProd).multipliable\n\n"}
{"name":"Multipliable.trans_div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf g : Î² â†’ Î±\nhg : Multipliable g\nhfg : Multipliable fun b => HDiv.hDiv (f b) (g b)\nâŠ¢ Multipliable f","decl":"@[to_additive]\ntheorem Multipliable.trans_div (hg : Multipliable g) (hfg : Multipliable fun b â†¦ f b / g b) :\n    Multipliable f := by\n  simpa only [div_mul_cancel] using hfg.mul hg\n\n"}
{"name":"Summable.trans_sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf g : Î² â†’ Î±\nhg : Summable g\nhfg : Summable fun b => HSub.hSub (f b) (g b)\nâŠ¢ Summable f","decl":"@[to_additive]\ntheorem Multipliable.trans_div (hg : Multipliable g) (hfg : Multipliable fun b â†¦ f b / g b) :\n    Multipliable f := by\n  simpa only [div_mul_cancel] using hfg.mul hg\n\n"}
{"name":"summable_iff_of_summable_sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf g : Î² â†’ Î±\nhfg : Summable fun b => HSub.hSub (f b) (g b)\nâŠ¢ Iff (Summable f) (Summable g)","decl":"@[to_additive]\ntheorem multipliable_iff_of_multipliable_div (hfg : Multipliable fun b â†¦ f b / g b) :\n    Multipliable f â†” Multipliable g :=\n  âŸ¨fun hf â†¦ hf.trans_div <| by simpa only [inv_div] using hfg.inv, fun hg â†¦ hg.trans_div hfgâŸ©\n\n"}
{"name":"multipliable_iff_of_multipliable_div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf g : Î² â†’ Î±\nhfg : Multipliable fun b => HDiv.hDiv (f b) (g b)\nâŠ¢ Iff (Multipliable f) (Multipliable g)","decl":"@[to_additive]\ntheorem multipliable_iff_of_multipliable_div (hfg : Multipliable fun b â†¦ f b / g b) :\n    Multipliable f â†” Multipliable g :=\n  âŸ¨fun hf â†¦ hf.trans_div <| by simpa only [inv_div] using hfg.inv, fun hg â†¦ hg.trans_div hfgâŸ©\n\n"}
{"name":"HasProd.update","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalGroup Î±\nf : Î² â†’ Î±\naâ‚ : Î±\nhf : HasProd f aâ‚\nb : Î²\ninstâœ : DecidableEq Î²\na : Î±\nâŠ¢ HasProd (Function.update f b a) (HMul.hMul (HDiv.hDiv a (f b)) aâ‚)","decl":"@[to_additive]\ntheorem HasProd.update (hf : HasProd f aâ‚) (b : Î²) [DecidableEq Î²] (a : Î±) :\n    HasProd (update f b a) (a / f b * aâ‚) := by\n  convert (hasProd_ite_eq b (a / f b)).mul hf with b'\n  by_cases h : b' = b\n  Â· rw [h, update_self]\n    simp [eq_self_iff_true, if_true, sub_add_cancel]\n  Â· simp only [h, update_of_ne, if_false, Ne, one_mul, not_false_iff]\n\n"}
{"name":"HasSum.update","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\naâ‚ : Î±\nhf : HasSum f aâ‚\nb : Î²\ninstâœ : DecidableEq Î²\na : Î±\nâŠ¢ HasSum (Function.update f b a) (HAdd.hAdd (HSub.hSub a (f b)) aâ‚)","decl":"@[to_additive]\ntheorem HasProd.update (hf : HasProd f aâ‚) (b : Î²) [DecidableEq Î²] (a : Î±) :\n    HasProd (update f b a) (a / f b * aâ‚) := by\n  convert (hasProd_ite_eq b (a / f b)).mul hf with b'\n  by_cases h : b' = b\n  Â· rw [h, update_self]\n    simp [eq_self_iff_true, if_true, sub_add_cancel]\n  Â· simp only [h, update_of_ne, if_false, Ne, one_mul, not_false_iff]\n\n"}
{"name":"Multipliable.update","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalGroup Î±\nf : Î² â†’ Î±\nhf : Multipliable f\nb : Î²\ninstâœ : DecidableEq Î²\na : Î±\nâŠ¢ Multipliable (Function.update f b a)","decl":"@[to_additive]\ntheorem Multipliable.update (hf : Multipliable f) (b : Î²) [DecidableEq Î²] (a : Î±) :\n    Multipliable (update f b a) :=\n  (hf.hasProd.update b a).multipliable\n\n"}
{"name":"Summable.update","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\nhf : Summable f\nb : Î²\ninstâœ : DecidableEq Î²\na : Î±\nâŠ¢ Summable (Function.update f b a)","decl":"@[to_additive]\ntheorem Multipliable.update (hf : Multipliable f) (b : Î²) [DecidableEq Î²] (a : Î±) :\n    Multipliable (update f b a) :=\n  (hf.hasProd.update b a).multipliable\n\n"}
{"name":"HasProd.hasProd_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\naâ‚ aâ‚‚ : Î±\ns : Set Î²\nhf : HasProd (Function.comp f Subtype.val) aâ‚\nâŠ¢ Iff (HasProd (Function.comp f Subtype.val) aâ‚‚) (HasProd f (HMul.hMul aâ‚ aâ‚‚))","decl":"@[to_additive]\ntheorem HasProd.hasProd_compl_iff {s : Set Î²} (hf : HasProd (f âˆ˜ (â†‘) : s â†’ Î±) aâ‚) :\n    HasProd (f âˆ˜ (â†‘) : â†‘sá¶œ â†’ Î±) aâ‚‚ â†” HasProd f (aâ‚ * aâ‚‚) := by\n  refine âŸ¨fun h â†¦ hf.mul_compl h, fun h â†¦ ?_âŸ©\n  rw [hasProd_subtype_iff_mulIndicator] at hf âŠ¢\n  rw [Set.mulIndicator_compl]\n  simpa only [div_eq_mul_inv, mul_inv_cancel_comm] using h.div hf\n\n"}
{"name":"HasSum.hasSum_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\naâ‚ aâ‚‚ : Î±\ns : Set Î²\nhf : HasSum (Function.comp f Subtype.val) aâ‚\nâŠ¢ Iff (HasSum (Function.comp f Subtype.val) aâ‚‚) (HasSum f (HAdd.hAdd aâ‚ aâ‚‚))","decl":"@[to_additive]\ntheorem HasProd.hasProd_compl_iff {s : Set Î²} (hf : HasProd (f âˆ˜ (â†‘) : s â†’ Î±) aâ‚) :\n    HasProd (f âˆ˜ (â†‘) : â†‘sá¶œ â†’ Î±) aâ‚‚ â†” HasProd f (aâ‚ * aâ‚‚) := by\n  refine âŸ¨fun h â†¦ hf.mul_compl h, fun h â†¦ ?_âŸ©\n  rw [hasProd_subtype_iff_mulIndicator] at hf âŠ¢\n  rw [Set.mulIndicator_compl]\n  simpa only [div_eq_mul_inv, mul_inv_cancel_comm] using h.div hf\n\n"}
{"name":"HasProd.hasProd_iff_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\naâ‚ aâ‚‚ : Î±\ns : Set Î²\nhf : HasProd (Function.comp f Subtype.val) aâ‚\nâŠ¢ Iff (HasProd f aâ‚‚) (HasProd (Function.comp f Subtype.val) (HDiv.hDiv aâ‚‚ aâ‚))","decl":"@[to_additive]\ntheorem HasProd.hasProd_iff_compl {s : Set Î²} (hf : HasProd (f âˆ˜ (â†‘) : s â†’ Î±) aâ‚) :\n    HasProd f aâ‚‚ â†” HasProd (f âˆ˜ (â†‘) : â†‘sá¶œ â†’ Î±) (aâ‚‚ / aâ‚) :=\n  Iff.symm <| hf.hasProd_compl_iff.trans <| by rw [mul_div_cancel]\n\n"}
{"name":"HasSum.hasSum_iff_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\naâ‚ aâ‚‚ : Î±\ns : Set Î²\nhf : HasSum (Function.comp f Subtype.val) aâ‚\nâŠ¢ Iff (HasSum f aâ‚‚) (HasSum (Function.comp f Subtype.val) (HSub.hSub aâ‚‚ aâ‚))","decl":"@[to_additive]\ntheorem HasProd.hasProd_iff_compl {s : Set Î²} (hf : HasProd (f âˆ˜ (â†‘) : s â†’ Î±) aâ‚) :\n    HasProd f aâ‚‚ â†” HasProd (f âˆ˜ (â†‘) : â†‘sá¶œ â†’ Î±) (aâ‚‚ / aâ‚) :=\n  Iff.symm <| hf.hasProd_compl_iff.trans <| by rw [mul_div_cancel]\n\n"}
{"name":"Multipliable.multipliable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\ns : Set Î²\nhf : Multipliable (Function.comp f Subtype.val)\nâŠ¢ Iff (Multipliable (Function.comp f Subtype.val)) (Multipliable f)","decl":"@[to_additive]\ntheorem Multipliable.multipliable_compl_iff {s : Set Î²} (hf : Multipliable (f âˆ˜ (â†‘) : s â†’ Î±)) :\n    Multipliable (f âˆ˜ (â†‘) : â†‘sá¶œ â†’ Î±) â†” Multipliable f where\n  mp := fun âŸ¨_, haâŸ© â†¦ (hf.hasProd.hasProd_compl_iff.1 ha).multipliable\n  mpr := fun âŸ¨_, haâŸ© â†¦ (hf.hasProd.hasProd_iff_compl.1 ha).multipliable\n\n"}
{"name":"Summable.summable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\ns : Set Î²\nhf : Summable (Function.comp f Subtype.val)\nâŠ¢ Iff (Summable (Function.comp f Subtype.val)) (Summable f)","decl":"@[to_additive]\ntheorem Multipliable.multipliable_compl_iff {s : Set Î²} (hf : Multipliable (f âˆ˜ (â†‘) : s â†’ Î±)) :\n    Multipliable (f âˆ˜ (â†‘) : â†‘sá¶œ â†’ Î±) â†” Multipliable f where\n  mp := fun âŸ¨_, haâŸ© â†¦ (hf.hasProd.hasProd_compl_iff.1 ha).multipliable\n  mpr := fun âŸ¨_, haâŸ© â†¦ (hf.hasProd.hasProd_iff_compl.1 ha).multipliable\n\n"}
{"name":"Finset.hasSum_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\na : Î±\ns : Finset Î²\nâŠ¢ Iff (HasSum (fun x => f â†‘x) a) (HasSum f (HAdd.hAdd a (s.sum fun i => f i)))","decl":"@[to_additive]\nprotected theorem Finset.hasProd_compl_iff (s : Finset Î²) :\n    HasProd (fun x : { x // x âˆ‰ s } â†¦ f x) a â†” HasProd f (a * âˆ i âˆˆ s, f i) :=\n  (s.hasProd f).hasProd_compl_iff.trans <| by rw [mul_comm]\n\n"}
{"name":"Finset.hasProd_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\na : Î±\ns : Finset Î²\nâŠ¢ Iff (HasProd (fun x => f â†‘x) a) (HasProd f (HMul.hMul a (s.prod fun i => f i)))","decl":"@[to_additive]\nprotected theorem Finset.hasProd_compl_iff (s : Finset Î²) :\n    HasProd (fun x : { x // x âˆ‰ s } â†¦ f x) a â†” HasProd f (a * âˆ i âˆˆ s, f i) :=\n  (s.hasProd f).hasProd_compl_iff.trans <| by rw [mul_comm]\n\n"}
{"name":"Finset.hasSum_iff_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\na : Î±\ns : Finset Î²\nâŠ¢ Iff (HasSum f a) (HasSum (fun x => f â†‘x) (HSub.hSub a (s.sum fun i => f i)))","decl":"@[to_additive]\nprotected theorem Finset.hasProd_iff_compl (s : Finset Î²) :\n    HasProd f a â†” HasProd (fun x : { x // x âˆ‰ s } â†¦ f x) (a / âˆ i âˆˆ s, f i) :=\n  (s.hasProd f).hasProd_iff_compl\n\n"}
{"name":"Finset.hasProd_iff_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\na : Î±\ns : Finset Î²\nâŠ¢ Iff (HasProd f a) (HasProd (fun x => f â†‘x) (HDiv.hDiv a (s.prod fun i => f i)))","decl":"@[to_additive]\nprotected theorem Finset.hasProd_iff_compl (s : Finset Î²) :\n    HasProd f a â†” HasProd (fun x : { x // x âˆ‰ s } â†¦ f x) (a / âˆ i âˆˆ s, f i) :=\n  (s.hasProd f).hasProd_iff_compl\n\n"}
{"name":"Finset.summable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\ns : Finset Î²\nâŠ¢ Iff (Summable fun x => f â†‘x) (Summable f)","decl":"@[to_additive]\nprotected theorem Finset.multipliable_compl_iff (s : Finset Î²) :\n    (Multipliable fun x : { x // x âˆ‰ s } â†¦ f x) â†” Multipliable f :=\n  (s.multipliable f).multipliable_compl_iff\n\n"}
{"name":"Finset.multipliable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\ns : Finset Î²\nâŠ¢ Iff (Multipliable fun x => f â†‘x) (Multipliable f)","decl":"@[to_additive]\nprotected theorem Finset.multipliable_compl_iff (s : Finset Î²) :\n    (Multipliable fun x : { x // x âˆ‰ s } â†¦ f x) â†” Multipliable f :=\n  (s.multipliable f).multipliable_compl_iff\n\n"}
{"name":"Set.Finite.summable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\ns : Set Î²\nhs : s.Finite\nâŠ¢ Iff (Summable (Function.comp f Subtype.val)) (Summable f)","decl":"@[to_additive]\ntheorem Set.Finite.multipliable_compl_iff {s : Set Î²} (hs : s.Finite) :\n    Multipliable (f âˆ˜ (â†‘) : â†‘sá¶œ â†’ Î±) â†” Multipliable f :=\n  (hs.multipliable f).multipliable_compl_iff\n\n"}
{"name":"Set.Finite.multipliable_compl_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf : Î² â†’ Î±\ns : Set Î²\nhs : s.Finite\nâŠ¢ Iff (Multipliable (Function.comp f Subtype.val)) (Multipliable f)","decl":"@[to_additive]\ntheorem Set.Finite.multipliable_compl_iff {s : Set Î²} (hs : s.Finite) :\n    Multipliable (f âˆ˜ (â†‘) : â†‘sá¶œ â†’ Î±) â†” Multipliable f :=\n  (hs.multipliable f).multipliable_compl_iff\n\n"}
{"name":"hasProd_ite_div_hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalGroup Î±\nf : Î² â†’ Î±\na : Î±\ninstâœ : DecidableEq Î²\nhf : HasProd f a\nb : Î²\nâŠ¢ HasProd (fun n => ite (Eq n b) 1 (f n)) (HDiv.hDiv a (f b))","decl":"@[to_additive]\ntheorem hasProd_ite_div_hasProd [DecidableEq Î²] (hf : HasProd f a) (b : Î²) :\n    HasProd (fun n â†¦ ite (n = b) 1 (f n)) (a / f b) := by\n  convert hf.update b 1 using 1\n  Â· ext n\n    rw [Function.update_apply]\n  Â· rw [div_mul_eq_mul_div, one_mul]\n\n"}
{"name":"hasSum_ite_sub_hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\na : Î±\ninstâœ : DecidableEq Î²\nhf : HasSum f a\nb : Î²\nâŠ¢ HasSum (fun n => ite (Eq n b) 0 (f n)) (HSub.hSub a (f b))","decl":"@[to_additive]\ntheorem hasProd_ite_div_hasProd [DecidableEq Î²] (hf : HasProd f a) (b : Î²) :\n    HasProd (fun n â†¦ ite (n = b) 1 (f n)) (a / f b) := by\n  convert hf.update b 1 using 1\n  Â· ext n\n    rw [Function.update_apply]\n  Â· rw [div_mul_eq_mul_div, one_mul]\n\n"}
{"name":"Summable.congr_cofinite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf g : Î² â†’ Î±\nhf : Summable f\nhfg : Filter.cofinite.EventuallyEq f g\nâŠ¢ Summable g","decl":"/-- A more general version of `Multipliable.congr`, allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"A more general version of `Summable.congr`, allowing the functions to\ndisagree on a finite set.\"]\ntheorem Multipliable.congr_cofinite (hf : Multipliable f) (hfg : f =á¶ [cofinite] g) :\n    Multipliable g :=\n  hfg.multipliable_compl_iff.mp <| (hfg.multipliable_compl_iff.mpr hf).congr (by simp)\n\n"}
{"name":"Multipliable.congr_cofinite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf g : Î² â†’ Î±\nhf : Multipliable f\nhfg : Filter.cofinite.EventuallyEq f g\nâŠ¢ Multipliable g","decl":"/-- A more general version of `Multipliable.congr`, allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"A more general version of `Summable.congr`, allowing the functions to\ndisagree on a finite set.\"]\ntheorem Multipliable.congr_cofinite (hf : Multipliable f) (hfg : f =á¶ [cofinite] g) :\n    Multipliable g :=\n  hfg.multipliable_compl_iff.mp <| (hfg.multipliable_compl_iff.mpr hf).congr (by simp)\n\n"}
{"name":"summable_congr_cofinite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nf g : Î² â†’ Î±\nhfg : Filter.cofinite.EventuallyEq f g\nâŠ¢ Iff (Summable f) (Summable g)","decl":"/-- A more general version of `multipliable_congr`, allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"A more general version of `summable_congr`, allowing the functions to\ndisagree on a finite set.\"]\ntheorem multipliable_congr_cofinite (hfg : f =á¶ [cofinite] g) :\n    Multipliable f â†” Multipliable g :=\n  âŸ¨fun h â†¦ h.congr_cofinite hfg, fun h â†¦ h.congr_cofinite (hfg.mono fun _ h' â†¦ h'.symm)âŸ©\n\n"}
{"name":"multipliable_congr_cofinite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nf g : Î² â†’ Î±\nhfg : Filter.cofinite.EventuallyEq f g\nâŠ¢ Iff (Multipliable f) (Multipliable g)","decl":"/-- A more general version of `multipliable_congr`, allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"A more general version of `summable_congr`, allowing the functions to\ndisagree on a finite set.\"]\ntheorem multipliable_congr_cofinite (hfg : f =á¶ [cofinite] g) :\n    Multipliable f â†” Multipliable g :=\n  âŸ¨fun h â†¦ h.congr_cofinite hfg, fun h â†¦ h.congr_cofinite (hfg.mono fun _ h' â†¦ h'.symm)âŸ©\n\n"}
{"name":"Multipliable.congr_atTop","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nfâ‚ gâ‚ : Nat â†’ Î±\nhf : Multipliable fâ‚\nhfg : Filter.atTop.EventuallyEq fâ‚ gâ‚\nâŠ¢ Multipliable gâ‚","decl":"@[to_additive]\ntheorem Multipliable.congr_atTop {fâ‚ gâ‚ : â„• â†’ Î±} (hf : Multipliable fâ‚) (hfg : fâ‚ =á¶ [atTop] gâ‚) :\n    Multipliable gâ‚ := hf.congr_cofinite (Nat.cofinite_eq_atTop â–¸ hfg)\n\n"}
{"name":"Summable.congr_atTop","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nfâ‚ gâ‚ : Nat â†’ Î±\nhf : Summable fâ‚\nhfg : Filter.atTop.EventuallyEq fâ‚ gâ‚\nâŠ¢ Summable gâ‚","decl":"@[to_additive]\ntheorem Multipliable.congr_atTop {fâ‚ gâ‚ : â„• â†’ Î±} (hf : Multipliable fâ‚) (hfg : fâ‚ =á¶ [atTop] gâ‚) :\n    Multipliable gâ‚ := hf.congr_cofinite (Nat.cofinite_eq_atTop â–¸ hfg)\n\n"}
{"name":"summable_congr_atTop","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalAddGroup Î±\nfâ‚ gâ‚ : Nat â†’ Î±\nhfg : Filter.atTop.EventuallyEq fâ‚ gâ‚\nâŠ¢ Iff (Summable fâ‚) (Summable gâ‚)","decl":"@[to_additive]\ntheorem multipliable_congr_atTop {fâ‚ gâ‚ : â„• â†’ Î±} (hfg : fâ‚ =á¶ [atTop] gâ‚) :\n    Multipliable fâ‚ â†” Multipliable gâ‚ := multipliable_congr_cofinite (Nat.cofinite_eq_atTop â–¸ hfg)\n\n"}
{"name":"multipliable_congr_atTop","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalGroup Î±\nfâ‚ gâ‚ : Nat â†’ Î±\nhfg : Filter.atTop.EventuallyEq fâ‚ gâ‚\nâŠ¢ Iff (Multipliable fâ‚) (Multipliable gâ‚)","decl":"@[to_additive]\ntheorem multipliable_congr_atTop {fâ‚ gâ‚ : â„• â†’ Î±} (hfg : fâ‚ =á¶ [atTop] gâ‚) :\n    Multipliable fâ‚ â†” Multipliable gâ‚ := multipliable_congr_cofinite (Nat.cofinite_eq_atTop â–¸ hfg)\n\n"}
{"name":"tsum_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\ninstâœ : T2Space Î±\nâŠ¢ Eq (tsum fun b => Neg.neg (f b)) (Neg.neg (tsum fun b => f b))","decl":"@[to_additive]\ntheorem tprod_inv : âˆ' b, (f b)â»Â¹ = (âˆ' b, f b)â»Â¹ := by\n  by_cases hf : Multipliable f\n  Â· exact hf.hasProd.inv.tprod_eq\n  Â· simp [tprod_eq_one_of_not_multipliable hf,\n      tprod_eq_one_of_not_multipliable (mt Multipliable.of_inv hf)]\n\n"}
{"name":"tprod_inv","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalGroup Î±\nf : Î² â†’ Î±\ninstâœ : T2Space Î±\nâŠ¢ Eq (tprod fun b => Inv.inv (f b)) (Inv.inv (tprod fun b => f b))","decl":"@[to_additive]\ntheorem tprod_inv : âˆ' b, (f b)â»Â¹ = (âˆ' b, f b)â»Â¹ := by\n  by_cases hf : Multipliable f\n  Â· exact hf.hasProd.inv.tprod_eq\n  Â· simp [tprod_eq_one_of_not_multipliable hf,\n      tprod_eq_one_of_not_multipliable (mt Multipliable.of_inv hf)]\n\n"}
{"name":"tprod_div","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalGroup Î±\nf g : Î² â†’ Î±\ninstâœ : T2Space Î±\nhf : Multipliable f\nhg : Multipliable g\nâŠ¢ Eq (tprod fun b => HDiv.hDiv (f b) (g b)) (HDiv.hDiv (tprod fun b => f b) (tprod fun b => g b))","decl":"@[to_additive]\ntheorem tprod_div (hf : Multipliable f) (hg : Multipliable g) :\n    âˆ' b, (f b / g b) = (âˆ' b, f b) / âˆ' b, g b :=\n  (hf.hasProd.div hg.hasProd).tprod_eq\n\n"}
{"name":"tsum_sub","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalAddGroup Î±\nf g : Î² â†’ Î±\ninstâœ : T2Space Î±\nhf : Summable f\nhg : Summable g\nâŠ¢ Eq (tsum fun b => HSub.hSub (f b) (g b)) (HSub.hSub (tsum fun b => f b) (tsum fun b => g b))","decl":"@[to_additive]\ntheorem tprod_div (hf : Multipliable f) (hg : Multipliable g) :\n    âˆ' b, (f b / g b) = (âˆ' b, f b) / âˆ' b, g b :=\n  (hf.hasProd.div hg.hasProd).tprod_eq\n\n"}
{"name":"prod_mul_tprod_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalGroup Î±\nf : Î² â†’ Î±\ninstâœ : T2Space Î±\ns : Finset Î²\nhf : Multipliable f\nâŠ¢ Eq (HMul.hMul (s.prod fun x => f x) (tprod fun x => f â†‘x)) (tprod fun x => f x)","decl":"@[to_additive]\ntheorem prod_mul_tprod_compl {s : Finset Î²} (hf : Multipliable f) :\n    (âˆ x âˆˆ s, f x) * âˆ' x : â†‘(s : Set Î²)á¶œ, f x = âˆ' x, f x :=\n  ((s.hasProd f).mul_compl (s.multipliable_compl_iff.2 hf).hasProd).tprod_eq.symm\n\n"}
{"name":"sum_add_tsum_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalAddGroup Î±\nf : Î² â†’ Î±\ninstâœ : T2Space Î±\ns : Finset Î²\nhf : Summable f\nâŠ¢ Eq (HAdd.hAdd (s.sum fun x => f x) (tsum fun x => f â†‘x)) (tsum fun x => f x)","decl":"@[to_additive]\ntheorem prod_mul_tprod_compl {s : Finset Î²} (hf : Multipliable f) :\n    (âˆ x âˆˆ s, f x) * âˆ' x : â†‘(s : Set Î²)á¶œ, f x = âˆ' x, f x :=\n  ((s.hasProd f).mul_compl (s.multipliable_compl_iff.2 hf).hasProd).tprod_eq.symm\n\n"}
{"name":"tprod_eq_mul_tprod_ite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : CommGroup Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalGroup Î±\nf : Î² â†’ Î±\ninstâœÂ¹ : T2Space Î±\ninstâœ : DecidableEq Î²\nhf : Multipliable f\nb : Î²\nâŠ¢ Eq (tprod fun n => f n) (HMul.hMul (f b) (tprod fun n => ite (Eq n b) 1 (f n)))","decl":"/-- Let `f : Î² â†’ Î±` be a multipliable function and let `b âˆˆ Î²` be an index.\nLemma `tprod_eq_mul_tprod_ite` writes `âˆ n, f n` as `f b` times the product of the\nremaining terms. -/\n@[to_additive \"Let `f : Î² â†’ Î±` be a summable function and let `b âˆˆ Î²` be an index.\nLemma `tsum_eq_add_tsum_ite` writes `Î£' n, f n` as `f b` plus the sum of the\nremaining terms.\"]\ntheorem tprod_eq_mul_tprod_ite [DecidableEq Î²] (hf : Multipliable f) (b : Î²) :\n    âˆ' n, f n = f b * âˆ' n, ite (n = b) 1 (f n) := by\n  rw [(hasProd_ite_div_hasProd hf.hasProd b).tprod_eq]\n  exact (mul_div_cancel _ _).symm\n\n"}
{"name":"tsum_eq_add_tsum_ite","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalAddGroup Î±\nf : Î² â†’ Î±\ninstâœÂ¹ : T2Space Î±\ninstâœ : DecidableEq Î²\nhf : Summable f\nb : Î²\nâŠ¢ Eq (tsum fun n => f n) (HAdd.hAdd (f b) (tsum fun n => ite (Eq n b) 0 (f n)))","decl":"/-- Let `f : Î² â†’ Î±` be a multipliable function and let `b âˆˆ Î²` be an index.\nLemma `tprod_eq_mul_tprod_ite` writes `âˆ n, f n` as `f b` times the product of the\nremaining terms. -/\n@[to_additive \"Let `f : Î² â†’ Î±` be a summable function and let `b âˆˆ Î²` be an index.\nLemma `tsum_eq_add_tsum_ite` writes `Î£' n, f n` as `f b` plus the sum of the\nremaining terms.\"]\ntheorem tprod_eq_mul_tprod_ite [DecidableEq Î²] (hf : Multipliable f) (b : Î²) :\n    âˆ' n, f n = f b * âˆ' n, ite (n = b) 1 (f n) := by\n  rw [(hasProd_ite_div_hasProd hf.hasProd b).tprod_eq]\n  exact (mul_div_cancel _ _).symm\n\n"}
{"name":"summable_iff_cauchySeq_finset","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : CompleteSpace Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (Summable f) (CauchySeq fun s => s.sum fun b => f b)","decl":"/-- The **Cauchy criterion** for infinite products, also known as the **Cauchy convergence test** -/\n@[to_additive \"The **Cauchy criterion** for infinite sums, also known as the\n**Cauchy convergence test**\"]\ntheorem multipliable_iff_cauchySeq_finset [CompleteSpace Î±] {f : Î² â†’ Î±} :\n    Multipliable f â†” CauchySeq fun s : Finset Î² â†¦ âˆ b âˆˆ s, f b := by\n  classical exact cauchy_map_iff_exists_tendsto.symm\n\n"}
{"name":"multipliable_iff_cauchySeq_finset","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : CompleteSpace Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (Multipliable f) (CauchySeq fun s => s.prod fun b => f b)","decl":"/-- The **Cauchy criterion** for infinite products, also known as the **Cauchy convergence test** -/\n@[to_additive \"The **Cauchy criterion** for infinite sums, also known as the\n**Cauchy convergence test**\"]\ntheorem multipliable_iff_cauchySeq_finset [CompleteSpace Î±] {f : Î² â†’ Î±} :\n    Multipliable f â†” CauchySeq fun s : Finset Î² â†¦ âˆ b âˆˆ s, f b := by\n  classical exact cauchy_map_iff_exists_tendsto.symm\n\n"}
{"name":"cauchySeq_finset_iff_sum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformAddGroup Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (CauchySeq fun s => s.sum fun b => f b) (âˆ€ (e : Set Î±), Membership.mem (nhds 0) e â†’ Exists fun s => âˆ€ (t : Finset Î²), Disjoint t s â†’ Membership.mem e (t.sum fun b => f b))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_prod_vanishing :\n    (CauchySeq fun s : Finset Î² â†¦ âˆ b âˆˆ s, f b) â†”\n      âˆ€ e âˆˆ ğ“ (1 : Î±), âˆƒ s : Finset Î², âˆ€ t, Disjoint t s â†’ (âˆ b âˆˆ t, f b) âˆˆ e := by\n  classical\n  simp only [CauchySeq, cauchy_map_iff, and_iff_right atTop_neBot, prod_atTop_atTop_eq,\n    uniformity_eq_comap_nhds_one Î±, tendsto_comap_iff, Function.comp_def, atTop_neBot, true_and]\n  rw [tendsto_atTop']\n  constructor\n  Â· intro h e he\n    obtain âŸ¨âŸ¨sâ‚, sâ‚‚âŸ©, hâŸ© := h e he\n    use sâ‚ âˆª sâ‚‚\n    intro t ht\n    specialize h (sâ‚ âˆª sâ‚‚, sâ‚ âˆª sâ‚‚ âˆª t) âŸ¨le_sup_left, le_sup_of_le_left le_sup_rightâŸ©\n    simpa only [Finset.prod_union ht.symm, mul_div_cancel_left] using h\n  Â· rintro h e he\n    rcases exists_nhds_split_inv he with âŸ¨d, hd, hdeâŸ©\n    rcases h d hd with âŸ¨s, hâŸ©\n    use (s, s)\n    rintro âŸ¨tâ‚, tâ‚‚âŸ© âŸ¨htâ‚, htâ‚‚âŸ©\n    have : ((âˆ b âˆˆ tâ‚‚, f b) / âˆ b âˆˆ tâ‚, f b) = (âˆ b âˆˆ tâ‚‚ \\ s, f b) / âˆ b âˆˆ tâ‚ \\ s, f b := by\n      rw [â† Finset.prod_sdiff htâ‚, â† Finset.prod_sdiff htâ‚‚, mul_div_mul_right_eq_div]\n    simp only [this]\n    exact hde _ (h _ Finset.sdiff_disjoint) _ (h _ Finset.sdiff_disjoint)\n\n"}
{"name":"cauchySeq_finset_iff_prod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformGroup Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (CauchySeq fun s => s.prod fun b => f b) (âˆ€ (e : Set Î±), Membership.mem (nhds 1) e â†’ Exists fun s => âˆ€ (t : Finset Î²), Disjoint t s â†’ Membership.mem e (t.prod fun b => f b))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_prod_vanishing :\n    (CauchySeq fun s : Finset Î² â†¦ âˆ b âˆˆ s, f b) â†”\n      âˆ€ e âˆˆ ğ“ (1 : Î±), âˆƒ s : Finset Î², âˆ€ t, Disjoint t s â†’ (âˆ b âˆˆ t, f b) âˆˆ e := by\n  classical\n  simp only [CauchySeq, cauchy_map_iff, and_iff_right atTop_neBot, prod_atTop_atTop_eq,\n    uniformity_eq_comap_nhds_one Î±, tendsto_comap_iff, Function.comp_def, atTop_neBot, true_and]\n  rw [tendsto_atTop']\n  constructor\n  Â· intro h e he\n    obtain âŸ¨âŸ¨sâ‚, sâ‚‚âŸ©, hâŸ© := h e he\n    use sâ‚ âˆª sâ‚‚\n    intro t ht\n    specialize h (sâ‚ âˆª sâ‚‚, sâ‚ âˆª sâ‚‚ âˆª t) âŸ¨le_sup_left, le_sup_of_le_left le_sup_rightâŸ©\n    simpa only [Finset.prod_union ht.symm, mul_div_cancel_left] using h\n  Â· rintro h e he\n    rcases exists_nhds_split_inv he with âŸ¨d, hd, hdeâŸ©\n    rcases h d hd with âŸ¨s, hâŸ©\n    use (s, s)\n    rintro âŸ¨tâ‚, tâ‚‚âŸ© âŸ¨htâ‚, htâ‚‚âŸ©\n    have : ((âˆ b âˆˆ tâ‚‚, f b) / âˆ b âˆˆ tâ‚, f b) = (âˆ b âˆˆ tâ‚‚ \\ s, f b) / âˆ b âˆˆ tâ‚ \\ s, f b := by\n      rw [â† Finset.prod_sdiff htâ‚, â† Finset.prod_sdiff htâ‚‚, mul_div_mul_right_eq_div]\n    simp only [this]\n    exact hde _ (h _ Finset.sdiff_disjoint) _ (h _ Finset.sdiff_disjoint)\n\n"}
{"name":"cauchySeq_finset_iff_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformAddGroup Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (CauchySeq fun s => s.sum fun b => f b) (âˆ€ (e : Set Î±), Membership.mem (nhds 0) e â†’ Exists fun s => âˆ€ (t : Set Î²), Disjoint t â†‘s â†’ Membership.mem e (tsum fun b => f â†‘b))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_tprod_vanishing :\n    (CauchySeq fun s : Finset Î² â†¦ âˆ b âˆˆ s, f b) â†”\n      âˆ€ e âˆˆ ğ“ (1 : Î±), âˆƒ s : Finset Î², âˆ€ t : Set Î², Disjoint t s â†’ (âˆ' b : t, f b) âˆˆ e := by\n  simp_rw [cauchySeq_finset_iff_prod_vanishing, Set.disjoint_left, disjoint_left]\n  refine âŸ¨fun vanish e he â†¦ ?_, fun vanish e he â†¦ ?_âŸ©\n  Â· obtain âŸ¨o, ho, o_closed, oeâŸ© := exists_mem_nhds_isClosed_subset he\n    obtain âŸ¨s, hsâŸ© := vanish o ho\n    refine âŸ¨s, fun t hts â†¦ oe ?_âŸ©\n    by_cases ht : Multipliable fun a : t â†¦ f a\n    Â· classical\n      refine o_closed.mem_of_tendsto ht.hasProd (Eventually.of_forall fun t' â†¦ ?_)\n      rw [â† prod_subtype_map_embedding fun _ _ â†¦ by rfl]\n      apply hs\n      simp_rw [Finset.mem_map]\n      rintro _ âŸ¨b, -, rflâŸ©\n      exact hts b.prop\n    Â· exact tprod_eq_one_of_not_multipliable ht â–¸ mem_of_mem_nhds ho\n  Â· obtain âŸ¨s, hsâŸ© := vanish _ he\n    exact âŸ¨s, fun t hts â†¦ (t.tprod_subtype f).symm â–¸ hs _ htsâŸ©\n\n"}
{"name":"cauchySeq_finset_iff_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : CommGroup Î±\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformGroup Î±\nf : Î² â†’ Î±\nâŠ¢ Iff (CauchySeq fun s => s.prod fun b => f b) (âˆ€ (e : Set Î±), Membership.mem (nhds 1) e â†’ Exists fun s => âˆ€ (t : Set Î²), Disjoint t â†‘s â†’ Membership.mem e (tprod fun b => f â†‘b))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_tprod_vanishing :\n    (CauchySeq fun s : Finset Î² â†¦ âˆ b âˆˆ s, f b) â†”\n      âˆ€ e âˆˆ ğ“ (1 : Î±), âˆƒ s : Finset Î², âˆ€ t : Set Î², Disjoint t s â†’ (âˆ' b : t, f b) âˆˆ e := by\n  simp_rw [cauchySeq_finset_iff_prod_vanishing, Set.disjoint_left, disjoint_left]\n  refine âŸ¨fun vanish e he â†¦ ?_, fun vanish e he â†¦ ?_âŸ©\n  Â· obtain âŸ¨o, ho, o_closed, oeâŸ© := exists_mem_nhds_isClosed_subset he\n    obtain âŸ¨s, hsâŸ© := vanish o ho\n    refine âŸ¨s, fun t hts â†¦ oe ?_âŸ©\n    by_cases ht : Multipliable fun a : t â†¦ f a\n    Â· classical\n      refine o_closed.mem_of_tendsto ht.hasProd (Eventually.of_forall fun t' â†¦ ?_)\n      rw [â† prod_subtype_map_embedding fun _ _ â†¦ by rfl]\n      apply hs\n      simp_rw [Finset.mem_map]\n      rintro _ âŸ¨b, -, rflâŸ©\n      exact hts b.prop\n    Â· exact tprod_eq_one_of_not_multipliable ht â–¸ mem_of_mem_nhds ho\n  Â· obtain âŸ¨s, hsâŸ© := vanish _ he\n    exact âŸ¨s, fun t hts â†¦ (t.tprod_subtype f).symm â–¸ hs _ htsâŸ©\n\n"}
{"name":"summable_iff_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nâŠ¢ Iff (Summable f) (âˆ€ (e : Set Î±), Membership.mem (nhds 0) e â†’ Exists fun s => âˆ€ (t : Finset Î²), Disjoint t s â†’ Membership.mem e (t.sum fun b => f b))","decl":"@[to_additive]\ntheorem multipliable_iff_vanishing :\n    Multipliable f â†”\n    âˆ€ e âˆˆ ğ“ (1 : Î±), âˆƒ s : Finset Î², âˆ€ t, Disjoint t s â†’ (âˆ b âˆˆ t, f b) âˆˆ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_prod_vanishing]\n\n"}
{"name":"multipliable_iff_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nâŠ¢ Iff (Multipliable f) (âˆ€ (e : Set Î±), Membership.mem (nhds 1) e â†’ Exists fun s => âˆ€ (t : Finset Î²), Disjoint t s â†’ Membership.mem e (t.prod fun b => f b))","decl":"@[to_additive]\ntheorem multipliable_iff_vanishing :\n    Multipliable f â†”\n    âˆ€ e âˆˆ ğ“ (1 : Î±), âˆƒ s : Finset Î², âˆ€ t, Disjoint t s â†’ (âˆ b âˆˆ t, f b) âˆˆ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_prod_vanishing]\n\n"}
{"name":"summable_iff_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nâŠ¢ Iff (Summable f) (âˆ€ (e : Set Î±), Membership.mem (nhds 0) e â†’ Exists fun s => âˆ€ (t : Set Î²), Disjoint t â†‘s â†’ Membership.mem e (tsum fun b => f â†‘b))","decl":"@[to_additive]\ntheorem multipliable_iff_tprod_vanishing : Multipliable f â†”\n    âˆ€ e âˆˆ ğ“ (1 : Î±), âˆƒ s : Finset Î², âˆ€ t : Set Î², Disjoint t s â†’ (âˆ' b : t, f b) âˆˆ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_tprod_vanishing]\n\n-- TODO: generalize to monoid with a uniform continuous subtraction operator: `(a + b) - b = a`\n"}
{"name":"multipliable_iff_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nâŠ¢ Iff (Multipliable f) (âˆ€ (e : Set Î±), Membership.mem (nhds 1) e â†’ Exists fun s => âˆ€ (t : Set Î²), Disjoint t â†‘s â†’ Membership.mem e (tprod fun b => f â†‘b))","decl":"@[to_additive]\ntheorem multipliable_iff_tprod_vanishing : Multipliable f â†”\n    âˆ€ e âˆˆ ğ“ (1 : Î±), âˆƒ s : Finset Î², âˆ€ t : Set Î², Disjoint t s â†’ (âˆ' b : t, f b) âˆˆ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_tprod_vanishing]\n\n-- TODO: generalize to monoid with a uniform continuous subtraction operator: `(a + b) - b = a`\n"}
{"name":"Multipliable.multipliable_of_eq_one_or_self","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\nf g : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nhf : Multipliable f\nh : âˆ€ (b : Î²), Or (Eq (g b) 1) (Eq (g b) (f b))\nâŠ¢ Multipliable g","decl":"@[to_additive]\ntheorem Multipliable.multipliable_of_eq_one_or_self (hf : Multipliable f)\n    (h : âˆ€ b, g b = 1 âˆ¨ g b = f b) : Multipliable g := by\n  classical\n  exact multipliable_iff_vanishing.2 fun e he â†¦\n    let âŸ¨s, hsâŸ© := multipliable_iff_vanishing.1 hf e he\n    âŸ¨s, fun t ht â†¦\n      have eq : âˆ b âˆˆ t with g b = f b, f b = âˆ b âˆˆ t, g b :=\n        calc\n          âˆ b âˆˆ t with g b = f b, f b = âˆ b âˆˆ t with g b = f b, g b :=\n            Finset.prod_congr rfl fun b hb â†¦ (Finset.mem_filter.1 hb).2.symm\n          _ = âˆ b âˆˆ t, g b := by\n           {refine Finset.prod_subset (Finset.filter_subset _ _) ?_\n            intro b hbt hb\n            simp only [Finset.mem_filter, and_iff_right hbt] at hb\n            exact (h b).resolve_right hb}\n      eq â–¸ hs _ <| Finset.disjoint_of_subset_left (Finset.filter_subset _ _) htâŸ©\n\n"}
{"name":"Summable.summable_of_eq_zero_or_self","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\nf g : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nhf : Summable f\nh : âˆ€ (b : Î²), Or (Eq (g b) 0) (Eq (g b) (f b))\nâŠ¢ Summable g","decl":"@[to_additive]\ntheorem Multipliable.multipliable_of_eq_one_or_self (hf : Multipliable f)\n    (h : âˆ€ b, g b = 1 âˆ¨ g b = f b) : Multipliable g := by\n  classical\n  exact multipliable_iff_vanishing.2 fun e he â†¦\n    let âŸ¨s, hsâŸ© := multipliable_iff_vanishing.1 hf e he\n    âŸ¨s, fun t ht â†¦\n      have eq : âˆ b âˆˆ t with g b = f b, f b = âˆ b âˆˆ t, g b :=\n        calc\n          âˆ b âˆˆ t with g b = f b, f b = âˆ b âˆˆ t with g b = f b, g b :=\n            Finset.prod_congr rfl fun b hb â†¦ (Finset.mem_filter.1 hb).2.symm\n          _ = âˆ b âˆˆ t, g b := by\n           {refine Finset.prod_subset (Finset.filter_subset _ _) ?_\n            intro b hbt hb\n            simp only [Finset.mem_filter, and_iff_right hbt] at hb\n            exact (h b).resolve_right hb}\n      eq â–¸ hs _ <| Finset.disjoint_of_subset_left (Finset.filter_subset _ _) htâŸ©\n\n"}
{"name":"Multipliable.mulIndicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nhf : Multipliable f\ns : Set Î²\nâŠ¢ Multipliable (s.mulIndicator f)","decl":"@[to_additive]\nprotected theorem Multipliable.mulIndicator (hf : Multipliable f) (s : Set Î²) :\n    Multipliable (s.mulIndicator f) :=\n  hf.multipliable_of_eq_one_or_self <| Set.mulIndicator_eq_one_or_self _ _\n\n"}
{"name":"Summable.indicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nhf : Summable f\ns : Set Î²\nâŠ¢ Summable (s.indicator f)","decl":"@[to_additive]\nprotected theorem Multipliable.mulIndicator (hf : Multipliable f) (s : Set Î²) :\n    Multipliable (s.mulIndicator f) :=\n  hf.multipliable_of_eq_one_or_self <| Set.mulIndicator_eq_one_or_self _ _\n\n"}
{"name":"Summable.comp_injective","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\ni : Î³ â†’ Î²\nhf : Summable f\nhi : Function.Injective i\nâŠ¢ Summable (Function.comp f i)","decl":"@[to_additive]\ntheorem Multipliable.comp_injective {i : Î³ â†’ Î²} (hf : Multipliable f) (hi : Injective i) :\n    Multipliable (f âˆ˜ i) := by\n  simpa only [Set.mulIndicator_range_comp] using\n    (hi.multipliable_iff (fun x hx â†¦ Set.mulIndicator_of_not_mem hx _)).2\n    (hf.mulIndicator (Set.range i))\n\n"}
{"name":"Multipliable.comp_injective","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\ni : Î³ â†’ Î²\nhf : Multipliable f\nhi : Function.Injective i\nâŠ¢ Multipliable (Function.comp f i)","decl":"@[to_additive]\ntheorem Multipliable.comp_injective {i : Î³ â†’ Î²} (hf : Multipliable f) (hi : Injective i) :\n    Multipliable (f âˆ˜ i) := by\n  simpa only [Set.mulIndicator_range_comp] using\n    (hi.multipliable_iff (fun x hx â†¦ Set.mulIndicator_of_not_mem hx _)).2\n    (hf.mulIndicator (Set.range i))\n\n"}
{"name":"Summable.subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nhf : Summable f\ns : Set Î²\nâŠ¢ Summable (Function.comp f Subtype.val)","decl":"@[to_additive]\ntheorem Multipliable.subtype (hf : Multipliable f) (s : Set Î²) : Multipliable (f âˆ˜ (â†‘) : s â†’ Î±) :=\n  hf.comp_injective Subtype.coe_injective\n\n"}
{"name":"Multipliable.subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\nhf : Multipliable f\ns : Set Î²\nâŠ¢ Multipliable (Function.comp f Subtype.val)","decl":"@[to_additive]\ntheorem Multipliable.subtype (hf : Multipliable f) (s : Set Î²) : Multipliable (f âˆ˜ (â†‘) : s â†’ Î±) :=\n  hf.comp_injective Subtype.coe_injective\n\n"}
{"name":"multipliable_subtype_and_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : CommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\ns : Set Î²\nâŠ¢ Iff (And (Multipliable fun x => f â†‘x) (Multipliable fun x => f â†‘x)) (Multipliable f)","decl":"@[to_additive]\ntheorem multipliable_subtype_and_compl {s : Set Î²} :\n    ((Multipliable fun x : s â†¦ f x) âˆ§ Multipliable fun x : â†‘sá¶œ â†¦ f x) â†” Multipliable f :=\n  âŸ¨and_imp.2 Multipliable.mul_compl, fun h â†¦ âŸ¨h.subtype s, h.subtype sá¶œâŸ©âŸ©\n\n"}
{"name":"summable_subtype_and_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : UniformAddGroup Î±\nf : Î² â†’ Î±\ninstâœ : CompleteSpace Î±\ns : Set Î²\nâŠ¢ Iff (And (Summable fun x => f â†‘x) (Summable fun x => f â†‘x)) (Summable f)","decl":"@[to_additive]\ntheorem multipliable_subtype_and_compl {s : Set Î²} :\n    ((Multipliable fun x : s â†¦ f x) âˆ§ Multipliable fun x : â†‘sá¶œ â†¦ f x) â†” Multipliable f :=\n  âŸ¨and_imp.2 Multipliable.mul_compl, fun h â†¦ âŸ¨h.subtype s, h.subtype sá¶œâŸ©âŸ©\n\n"}
{"name":"tprod_subtype_mul_tprod_subtype_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : CommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T2Space Î±\nf : Î² â†’ Î±\nhf : Multipliable f\ns : Set Î²\nâŠ¢ Eq (HMul.hMul (tprod fun x => f â†‘x) (tprod fun x => f â†‘x)) (tprod fun x => f x)","decl":"@[to_additive]\ntheorem tprod_subtype_mul_tprod_subtype_compl [T2Space Î±] {f : Î² â†’ Î±} (hf : Multipliable f)\n    (s : Set Î²) : (âˆ' x : s, f x) * âˆ' x : â†‘sá¶œ, f x = âˆ' x, f x :=\n  ((hf.subtype s).hasProd.mul_compl (hf.subtype { x | x âˆ‰ s }).hasProd).unique hf.hasProd\n\n"}
{"name":"tsum_subtype_add_tsum_subtype_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformAddGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T2Space Î±\nf : Î² â†’ Î±\nhf : Summable f\ns : Set Î²\nâŠ¢ Eq (HAdd.hAdd (tsum fun x => f â†‘x) (tsum fun x => f â†‘x)) (tsum fun x => f x)","decl":"@[to_additive]\ntheorem tprod_subtype_mul_tprod_subtype_compl [T2Space Î±] {f : Î² â†’ Î±} (hf : Multipliable f)\n    (s : Set Î²) : (âˆ' x : s, f x) * âˆ' x : â†‘sá¶œ, f x = âˆ' x, f x :=\n  ((hf.subtype s).hasProd.mul_compl (hf.subtype { x | x âˆ‰ s }).hasProd).unique hf.hasProd\n\n"}
{"name":"sum_add_tsum_subtype_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformAddGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T2Space Î±\nf : Î² â†’ Î±\nhf : Summable f\ns : Finset Î²\nâŠ¢ Eq (HAdd.hAdd (s.sum fun x => f x) (tsum fun x => f â†‘x)) (tsum fun x => f x)","decl":"@[to_additive]\ntheorem prod_mul_tprod_subtype_compl [T2Space Î±] {f : Î² â†’ Î±} (hf : Multipliable f) (s : Finset Î²) :\n    (âˆ x âˆˆ s, f x) * âˆ' x : { x // x âˆ‰ s }, f x = âˆ' x, f x := by\n  rw [â† tprod_subtype_mul_tprod_subtype_compl hf s]\n  simp only [Finset.tprod_subtype', mul_right_inj]\n  rfl\n\n"}
{"name":"prod_mul_tprod_subtype_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : CommGroup Î±\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformGroup Î±\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : T2Space Î±\nf : Î² â†’ Î±\nhf : Multipliable f\ns : Finset Î²\nâŠ¢ Eq (HMul.hMul (s.prod fun x => f x) (tprod fun x => f â†‘x)) (tprod fun x => f x)","decl":"@[to_additive]\ntheorem prod_mul_tprod_subtype_compl [T2Space Î±] {f : Î² â†’ Î±} (hf : Multipliable f) (s : Finset Î²) :\n    (âˆ x âˆˆ s, f x) * âˆ' x : { x // x âˆ‰ s }, f x = âˆ' x, f x := by\n  rw [â† tprod_subtype_mul_tprod_subtype_compl hf s]\n  simp only [Finset.tprod_subtype', mul_right_inj]\n  rfl\n\n"}
{"name":"Multipliable.vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : CommGroup G\ninstâœ : TopologicalGroup G\nf : Î± â†’ G\nhf : Multipliable f\ne : Set G\nhe : Membership.mem (nhds 1) e\nâŠ¢ Exists fun s => âˆ€ (t : Finset Î±), Disjoint t s â†’ Membership.mem e (t.prod fun k => f k)","decl":"@[to_additive]\ntheorem Multipliable.vanishing (hf : Multipliable f) â¦ƒe : Set Gâ¦„ (he : e âˆˆ ğ“ (1 : G)) :\n    âˆƒ s : Finset Î±, âˆ€ t, Disjoint t s â†’ (âˆ k âˆˆ t, f k) âˆˆ e := by\n  classical\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  exact cauchySeq_finset_iff_prod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Summable.vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddCommGroup G\ninstâœ : TopologicalAddGroup G\nf : Î± â†’ G\nhf : Summable f\ne : Set G\nhe : Membership.mem (nhds 0) e\nâŠ¢ Exists fun s => âˆ€ (t : Finset Î±), Disjoint t s â†’ Membership.mem e (t.sum fun k => f k)","decl":"@[to_additive]\ntheorem Multipliable.vanishing (hf : Multipliable f) â¦ƒe : Set Gâ¦„ (he : e âˆˆ ğ“ (1 : G)) :\n    âˆƒ s : Finset Î±, âˆ€ t, Disjoint t s â†’ (âˆ k âˆˆ t, f k) âˆˆ e := by\n  classical\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  exact cauchySeq_finset_iff_prod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Multipliable.tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : CommGroup G\ninstâœ : TopologicalGroup G\nf : Î± â†’ G\nhf : Multipliable f\ne : Set G\nhe : Membership.mem (nhds 1) e\nâŠ¢ Exists fun s => âˆ€ (t : Set Î±), Disjoint t â†‘s â†’ Membership.mem e (tprod fun b => f â†‘b)","decl":"@[to_additive]\ntheorem Multipliable.tprod_vanishing (hf : Multipliable f) â¦ƒe : Set Gâ¦„ (he : e âˆˆ ğ“ 1) :\n    âˆƒ s : Finset Î±, âˆ€ t : Set Î±, Disjoint t s â†’ (âˆ' b : t, f b) âˆˆ e := by\n  classical\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  exact cauchySeq_finset_iff_tprod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Summable.tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddCommGroup G\ninstâœ : TopologicalAddGroup G\nf : Î± â†’ G\nhf : Summable f\ne : Set G\nhe : Membership.mem (nhds 0) e\nâŠ¢ Exists fun s => âˆ€ (t : Set Î±), Disjoint t â†‘s â†’ Membership.mem e (tsum fun b => f â†‘b)","decl":"@[to_additive]\ntheorem Multipliable.tprod_vanishing (hf : Multipliable f) â¦ƒe : Set Gâ¦„ (he : e âˆˆ ğ“ 1) :\n    âˆƒ s : Finset Î±, âˆ€ t : Set Î±, Disjoint t s â†’ (âˆ' b : t, f b) âˆˆ e := by\n  classical\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  exact cauchySeq_finset_iff_tprod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"tendsto_tprod_compl_atTop_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : CommGroup G\ninstâœ : TopologicalGroup G\nf : Î± â†’ G\nâŠ¢ Filter.Tendsto (fun s => tprod fun a => f â†‘a) Filter.atTop (nhds 1)","decl":"/-- The product over the complement of a finset tends to `1` when the finset grows to cover the\nwhole space. This does not need a multipliability assumption, as otherwise all such products are\none. -/\n@[to_additive \"The sum over the complement of a finset tends to `0` when the finset grows to cover\nthe whole space. This does not need a summability assumption, as otherwise all such sums are zero.\"]\ntheorem tendsto_tprod_compl_atTop_one (f : Î± â†’ G) :\n    Tendsto (fun s : Finset Î± â†¦ âˆ' a : { x // x âˆ‰ s }, f a) atTop (ğ“ 1) := by\n  classical\n  by_cases H : Multipliable f\n  Â· intro e he\n    obtain âŸ¨s, hsâŸ© := H.tprod_vanishing he\n    rw [Filter.mem_map, mem_atTop_sets]\n    exact âŸ¨s, fun t hts â†¦ hs _ <| Set.disjoint_left.mpr fun a ha has â†¦ ha (hts has)âŸ©\n  Â· refine tendsto_const_nhds.congr fun _ â†¦ (tprod_eq_one_of_not_multipliable ?_).symm\n    rwa [Finset.multipliable_compl_iff]\n\n"}
{"name":"tendsto_tsum_compl_atTop_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddCommGroup G\ninstâœ : TopologicalAddGroup G\nf : Î± â†’ G\nâŠ¢ Filter.Tendsto (fun s => tsum fun a => f â†‘a) Filter.atTop (nhds 0)","decl":"/-- The product over the complement of a finset tends to `1` when the finset grows to cover the\nwhole space. This does not need a multipliability assumption, as otherwise all such products are\none. -/\n@[to_additive \"The sum over the complement of a finset tends to `0` when the finset grows to cover\nthe whole space. This does not need a summability assumption, as otherwise all such sums are zero.\"]\ntheorem tendsto_tprod_compl_atTop_one (f : Î± â†’ G) :\n    Tendsto (fun s : Finset Î± â†¦ âˆ' a : { x // x âˆ‰ s }, f a) atTop (ğ“ 1) := by\n  classical\n  by_cases H : Multipliable f\n  Â· intro e he\n    obtain âŸ¨s, hsâŸ© := H.tprod_vanishing he\n    rw [Filter.mem_map, mem_atTop_sets]\n    exact âŸ¨s, fun t hts â†¦ hs _ <| Set.disjoint_left.mpr fun a ha has â†¦ ha (hts has)âŸ©\n  Â· refine tendsto_const_nhds.congr fun _ â†¦ (tprod_eq_one_of_not_multipliable ?_).symm\n    rwa [Finset.multipliable_compl_iff]\n\n"}
{"name":"Multipliable.tendsto_cofinite_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : CommGroup G\ninstâœ : TopologicalGroup G\nf : Î± â†’ G\nhf : Multipliable f\nâŠ¢ Filter.Tendsto f Filter.cofinite (nhds 1)","decl":"/-- Product divergence test: if `f` is unconditionally multipliable, then `f x` tends to one along\n`cofinite`. -/\n@[to_additive \"Series divergence test: if `f` is unconditionally summable, then `f x` tends to zero\nalong `cofinite`.\"]\ntheorem Multipliable.tendsto_cofinite_one (hf : Multipliable f) : Tendsto f cofinite (ğ“ 1) := by\n  intro e he\n  rw [Filter.mem_map]\n  rcases hf.vanishing he with âŸ¨s, hsâŸ©\n  refine s.eventually_cofinite_nmem.mono fun x hx â†¦ ?_\n  Â· simpa using hs {x} (disjoint_singleton_left.2 hx)\n\n"}
{"name":"Summable.tendsto_cofinite_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : AddCommGroup G\ninstâœ : TopologicalAddGroup G\nf : Î± â†’ G\nhf : Summable f\nâŠ¢ Filter.Tendsto f Filter.cofinite (nhds 0)","decl":"/-- Product divergence test: if `f` is unconditionally multipliable, then `f x` tends to one along\n`cofinite`. -/\n@[to_additive \"Series divergence test: if `f` is unconditionally summable, then `f x` tends to zero\nalong `cofinite`.\"]\ntheorem Multipliable.tendsto_cofinite_one (hf : Multipliable f) : Tendsto f cofinite (ğ“ 1) := by\n  intro e he\n  rw [Filter.mem_map]\n  rcases hf.vanishing he with âŸ¨s, hsâŸ©\n  refine s.eventually_cofinite_nmem.mono fun x hx â†¦ ?_\n  Â· simpa using hs {x} (disjoint_singleton_left.2 hx)\n\n"}
{"name":"Summable.countable_support","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalAddGroup G\nf : Î± â†’ G\ninstâœÂ¹ : FirstCountableTopology G\ninstâœ : T1Space G\nhf : Summable f\nâŠ¢ (Function.support f).Countable","decl":"@[to_additive]\ntheorem Multipliable.countable_mulSupport [FirstCountableTopology G] [T1Space G]\n    (hf : Multipliable f) : f.mulSupport.Countable := by\n  simpa only [ker_nhds] using hf.tendsto_cofinite_one.countable_compl_preimage_ker\n\n"}
{"name":"Multipliable.countable_mulSupport","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î± : Type u_1\nG : Type u_4\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : CommGroup G\ninstâœÂ² : TopologicalGroup G\nf : Î± â†’ G\ninstâœÂ¹ : FirstCountableTopology G\ninstâœ : T1Space G\nhf : Multipliable f\nâŠ¢ (Function.mulSupport f).Countable","decl":"@[to_additive]\ntheorem Multipliable.countable_mulSupport [FirstCountableTopology G] [T1Space G]\n    (hf : Multipliable f) : f.mulSupport.Countable := by\n  simpa only [ker_nhds] using hf.tendsto_cofinite_one.countable_compl_preimage_ker\n\n"}
{"name":"summable_const_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î² : Type u_2\nG : Type u_4\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalAddGroup G\ninstâœÂ¹ : Infinite Î²\ninstâœ : T2Space G\na : G\nâŠ¢ Iff (Summable fun x => a) (Eq a 0)","decl":"@[to_additive]\ntheorem multipliable_const_iff [Infinite Î²] [T2Space G] (a : G) :\n    Multipliable (fun _ : Î² â†¦ a) â†” a = 1 := by\n  refine âŸ¨fun h â†¦ ?_, ?_âŸ©\n  Â· by_contra ha\n    have : {a}á¶œ âˆˆ ğ“ 1 := compl_singleton_mem_nhds (Ne.symm ha)\n    have : Finite Î² := by\n      simpa [â† Set.finite_univ_iff] using h.tendsto_cofinite_one this\n    exact not_finite Î²\n  Â· rintro rfl\n    exact multipliable_one\n\n"}
{"name":"multipliable_const_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î² : Type u_2\nG : Type u_4\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : CommGroup G\ninstâœÂ² : TopologicalGroup G\ninstâœÂ¹ : Infinite Î²\ninstâœ : T2Space G\na : G\nâŠ¢ Iff (Multipliable fun x => a) (Eq a 1)","decl":"@[to_additive]\ntheorem multipliable_const_iff [Infinite Î²] [T2Space G] (a : G) :\n    Multipliable (fun _ : Î² â†¦ a) â†” a = 1 := by\n  refine âŸ¨fun h â†¦ ?_, ?_âŸ©\n  Â· by_contra ha\n    have : {a}á¶œ âˆˆ ğ“ 1 := compl_singleton_mem_nhds (Ne.symm ha)\n    have : Finite Î² := by\n      simpa [â† Set.finite_univ_iff] using h.tendsto_cofinite_one this\n    exact not_finite Î²\n  Â· rintro rfl\n    exact multipliable_one\n\n"}
{"name":"tsum_const","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î² : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : AddCommGroup G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : T2Space G\na : G\nâŠ¢ Eq (tsum fun x => a) (HSMul.hSMul (Nat.card Î²) a)","decl":"@[to_additive (attr := simp)]\ntheorem tprod_const [T2Space G] (a : G) : âˆ' _ : Î², a = a ^ (Nat.card Î²) := by\n  rcases finite_or_infinite Î² with hÎ²|hÎ²\n  Â· letI : Fintype Î² := Fintype.ofFinite Î²\n    rw [tprod_eq_prod (s := univ) (fun x hx â†¦ (hx (mem_univ x)).elim)]\n    simp only [prod_const, Nat.card_eq_fintype_card, Fintype.card]\n  Â· simp only [Nat.card_eq_zero_of_infinite, pow_zero]\n    rcases eq_or_ne a 1 with rfl|ha\n    Â· simp\n    Â· apply tprod_eq_one_of_not_multipliable\n      simpa [multipliable_const_iff] using ha\n\n"}
{"name":"tprod_const","module":"Mathlib.Topology.Algebra.InfiniteSum.Group","initialProofState":"Î² : Type u_2\nG : Type u_4\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : CommGroup G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : T2Space G\na : G\nâŠ¢ Eq (tprod fun x => a) (HPow.hPow a (Nat.card Î²))","decl":"@[to_additive (attr := simp)]\ntheorem tprod_const [T2Space G] (a : G) : âˆ' _ : Î², a = a ^ (Nat.card Î²) := by\n  rcases finite_or_infinite Î² with hÎ²|hÎ²\n  Â· letI : Fintype Î² := Fintype.ofFinite Î²\n    rw [tprod_eq_prod (s := univ) (fun x hx â†¦ (hx (mem_univ x)).elim)]\n    simp only [prod_const, Nat.card_eq_fintype_card, Fintype.card]\n  Â· simp only [Nat.card_eq_zero_of_infinite, pow_zero]\n    rcases eq_or_ne a 1 with rfl|ha\n    Â· simp\n    Â· apply tprod_eq_one_of_not_multipliable\n      simpa [multipliable_const_iff] using ha\n\n"}
