{"name":"CategoryTheory.IsFiltered.FilteredClosure.brecOn","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nα : Type w\nf : α → C\nmotive✝ : (a : C) → CategoryTheory.IsFiltered.FilteredClosure f a → Prop\na✝ : C\nx✝ : CategoryTheory.IsFiltered.FilteredClosure f a✝\nih✝ : ∀ (a : C) (x : CategoryTheory.IsFiltered.FilteredClosure f a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- The \"filtered closure\" of an `α`-indexed family of objects in `C` is the set of objects in `C`\n    obtained by starting with the family and successively adding maxima and coequalizers. -/\ninductive FilteredClosure : C → Prop\n  | base : (x : α) → FilteredClosure (f x)\n  | max : {j j' : C} → FilteredClosure j → FilteredClosure j' → FilteredClosure (max j j')\n  | coeq : {j j' : C} → FilteredClosure j → FilteredClosure j' → (f f' : j ⟶ j') →\n      FilteredClosure (coeq f f')\n\n"}
{"name":"CategoryTheory.IsFiltered.instIsFilteredOrEmptyFullSubcategoryFilteredClosure","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nα : Type w\nf : α → C\n⊢ CategoryTheory.IsFilteredOrEmpty (CategoryTheory.FullSubcategory (CategoryTheory.IsFiltered.FilteredClosure f))","decl":"/-- The full subcategory induced by the filtered closure of a family of objects is filtered. -/\ninstance : IsFilteredOrEmpty (FullSubcategory (FilteredClosure f)) where\n  cocone_objs j j' :=\n    ⟨⟨max j.1 j'.1, FilteredClosure.max j.2 j'.2⟩, leftToMax _ _, rightToMax _ _, trivial⟩\n  cocone_maps {j j'} f f' :=\n    ⟨⟨coeq f f', FilteredClosure.coeq j.2 j'.2 f f'⟩, coeqHom (C := C) f f', coeq_condition _ _⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.small_fullSubcategory_filteredClosure","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nα : Type w\nf : α → C\n⊢ Small.{max v w, u} (CategoryTheory.FullSubcategory (CategoryTheory.IsFiltered.FilteredClosure f))","decl":"theorem small_fullSubcategory_filteredClosure :\n    Small.{max v w} (FullSubcategory (FilteredClosure f)) := by\n  refine small_of_injective_of_exists (FilteredClosureSmall.abstractFilteredClosureRealization f)\n    (fun _ _ => FullSubcategory.ext) ?_\n  rintro ⟨j, h⟩\n  induction h with\n  | base x => exact ⟨⟨0, ⟨x⟩⟩, rfl⟩\n  | max hj₁ hj₂ ih ih' =>\n    rcases ih with ⟨⟨n, x⟩, rfl⟩\n    rcases ih' with ⟨⟨m, y⟩, rfl⟩\n    refine ⟨⟨(Max.max n m).succ, FilteredClosureSmall.InductiveStep.max ?_ ?_ x y⟩, rfl⟩\n    all_goals apply Nat.lt_succ_of_le\n    exacts [Nat.le_max_left _ _, Nat.le_max_right _ _]\n  | coeq hj₁ hj₂ g g' ih ih' =>\n    rcases ih with ⟨⟨n, x⟩, rfl⟩\n    rcases ih' with ⟨⟨m, y⟩, rfl⟩\n    refine ⟨⟨(Max.max n m).succ, FilteredClosureSmall.InductiveStep.coeq ?_ ?_ x y g g'⟩, rfl⟩\n    all_goals apply Nat.lt_succ_of_le\n    exacts [Nat.le_max_left _ _, Nat.le_max_right _ _]\n\n"}
{"name":"CategoryTheory.IsFiltered.instEssentiallySmallFullSubcategoryFilteredClosure","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nα : Type w\nf : α → C\n⊢ CategoryTheory.EssentiallySmall.{max v w, v, u} (CategoryTheory.FullSubcategory (CategoryTheory.IsFiltered.FilteredClosure f))","decl":"instance : EssentiallySmall.{max v w} (FullSubcategory (FilteredClosure f)) :=\n  have : LocallySmall.{max v w} (FullSubcategory (FilteredClosure f)) := locallySmall_max.{w, v, u}\n  have := small_fullSubcategory_filteredClosure f\n  essentiallySmall_of_small_of_locallySmall _\n\n"}
{"name":"CategoryTheory.IsFiltered.SmallFilteredIntermediate.instFaithfulInclusion","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor D C\n⊢ (CategoryTheory.IsFiltered.SmallFilteredIntermediate.inclusion F).Faithful","decl":"instance : (inclusion F).Faithful :=\n  show ((equivSmallModel _).inverse ⋙ fullSubcategoryInclusion _).Faithful from inferInstance\n\n"}
{"name":"CategoryTheory.IsFiltered.SmallFilteredIntermediate.instFullInclusion","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor D C\n⊢ (CategoryTheory.IsFiltered.SmallFilteredIntermediate.inclusion F).Full","decl":"noncomputable instance : (inclusion F).Full :=\n  show ((equivSmallModel _).inverse ⋙ fullSubcategoryInclusion _).Full from inferInstance\n\n"}
{"name":"CategoryTheory.IsFiltered.SmallFilteredIntermediate.instIsFilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor D C\n⊢ CategoryTheory.IsFilteredOrEmpty (CategoryTheory.IsFiltered.SmallFilteredIntermediate F)","decl":"instance : IsFilteredOrEmpty (SmallFilteredIntermediate F) :=\n  IsFilteredOrEmpty.of_equivalence (equivSmallModel _)\n\n"}
{"name":"CategoryTheory.IsFiltered.SmallFilteredIntermediate.instOfNonempty","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.IsFilteredOrEmpty C\nD : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor D C\ninst✝ : Nonempty D\n⊢ CategoryTheory.IsFiltered (CategoryTheory.IsFiltered.SmallFilteredIntermediate F)","decl":"instance [Nonempty D] : IsFiltered (SmallFilteredIntermediate F) :=\n  { (inferInstance : IsFilteredOrEmpty _) with\n    nonempty := Nonempty.map (factoring F).obj inferInstance }\n\n"}
{"name":"CategoryTheory.IsCofiltered.CofilteredClosure.brecOn","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nα : Type w\nf : α → C\nmotive✝ : (a : C) → CategoryTheory.IsCofiltered.CofilteredClosure f a → Prop\na✝ : C\nx✝ : CategoryTheory.IsCofiltered.CofilteredClosure f a✝\nih✝ : ∀ (a : C) (x : CategoryTheory.IsCofiltered.CofilteredClosure f a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- The \"cofiltered closure\" of an `α`-indexed family of objects in `C` is the set of objects in `C`\n    obtained by starting with the family and successively adding minima and equalizers. -/\ninductive CofilteredClosure : C → Prop\n  | base : (x : α) → CofilteredClosure (f x)\n  | min : {j j' : C} → CofilteredClosure j → CofilteredClosure j' → CofilteredClosure (min j j')\n  | eq : {j j' : C} → CofilteredClosure j → CofilteredClosure j' → (f f' : j ⟶ j') →\n      CofilteredClosure (eq f f')\n\n"}
{"name":"CategoryTheory.IsCofiltered.instIsCofilteredOrEmptyFullSubcategoryCofilteredClosure","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nα : Type w\nf : α → C\n⊢ CategoryTheory.IsCofilteredOrEmpty (CategoryTheory.FullSubcategory (CategoryTheory.IsCofiltered.CofilteredClosure f))","decl":"/-- The full subcategory induced by the cofiltered closure of a family is cofiltered. -/\ninstance : IsCofilteredOrEmpty (FullSubcategory (CofilteredClosure f)) where\n  cone_objs j j' :=\n    ⟨⟨min j.1 j'.1, CofilteredClosure.min j.2 j'.2⟩, minToLeft _ _, minToRight _ _, trivial⟩\n  cone_maps {j j'} f f' :=\n    ⟨⟨eq f f', CofilteredClosure.eq j.2 j'.2 f f'⟩, eqHom (C := C) f f', eq_condition _ _⟩\n\n"}
{"name":"CategoryTheory.IsCofiltered.small_fullSubcategory_cofilteredClosure","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nα : Type w\nf : α → C\n⊢ Small.{max v w, u} (CategoryTheory.FullSubcategory (CategoryTheory.IsCofiltered.CofilteredClosure f))","decl":"theorem small_fullSubcategory_cofilteredClosure :\n    Small.{max v w} (FullSubcategory (CofilteredClosure f)) := by\n  refine small_of_injective_of_exists\n    (CofilteredClosureSmall.abstractCofilteredClosureRealization f)\n    (fun _ _ => FullSubcategory.ext) ?_\n  rintro ⟨j, h⟩\n  induction h with\n  | base x => exact ⟨⟨0, ⟨x⟩⟩, rfl⟩\n  | min hj₁ hj₂ ih ih' =>\n    rcases ih with ⟨⟨n, x⟩, rfl⟩\n    rcases ih' with ⟨⟨m, y⟩, rfl⟩\n    refine ⟨⟨(Max.max n m).succ, CofilteredClosureSmall.InductiveStep.min ?_ ?_ x y⟩, rfl⟩\n    all_goals apply Nat.lt_succ_of_le\n    exacts [Nat.le_max_left _ _, Nat.le_max_right _ _]\n  | eq hj₁ hj₂ g g' ih ih' =>\n    rcases ih with ⟨⟨n, x⟩, rfl⟩\n    rcases ih' with ⟨⟨m, y⟩, rfl⟩\n    refine ⟨⟨(Max.max n m).succ, CofilteredClosureSmall.InductiveStep.eq ?_ ?_ x y g g'⟩, rfl⟩\n    all_goals apply Nat.lt_succ_of_le\n    exacts [Nat.le_max_left _ _, Nat.le_max_right _ _]\n\n"}
{"name":"CategoryTheory.IsCofiltered.instEssentiallySmallFullSubcategoryCofilteredClosure","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nα : Type w\nf : α → C\n⊢ CategoryTheory.EssentiallySmall.{max v w, v, u} (CategoryTheory.FullSubcategory (CategoryTheory.IsCofiltered.CofilteredClosure f))","decl":"instance : EssentiallySmall.{max v w} (FullSubcategory (CofilteredClosure f)) :=\n  have : LocallySmall.{max v w} (FullSubcategory (CofilteredClosure f)) :=\n    locallySmall_max.{w, v, u}\n  have := small_fullSubcategory_cofilteredClosure f\n  essentiallySmall_of_small_of_locallySmall _\n\n"}
{"name":"CategoryTheory.IsCofiltered.SmallCofilteredIntermediate.instFaithfulInclusion","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor D C\n⊢ (CategoryTheory.IsCofiltered.SmallCofilteredIntermediate.inclusion F).Faithful","decl":"instance : (inclusion F).Faithful :=\n  show ((equivSmallModel _).inverse ⋙ fullSubcategoryInclusion _).Faithful from inferInstance\n\n"}
{"name":"CategoryTheory.IsCofiltered.SmallCofilteredIntermediate.instFullInclusion","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor D C\n⊢ (CategoryTheory.IsCofiltered.SmallCofilteredIntermediate.inclusion F).Full","decl":"noncomputable instance : (inclusion F).Full :=\n  show ((equivSmallModel _).inverse ⋙ fullSubcategoryInclusion _).Full from inferInstance\n\n"}
{"name":"CategoryTheory.IsCofiltered.SmallCofilteredIntermediate.instIsCofilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor D C\n⊢ CategoryTheory.IsCofilteredOrEmpty (CategoryTheory.IsCofiltered.SmallCofilteredIntermediate F)","decl":"instance : IsCofilteredOrEmpty (SmallCofilteredIntermediate F) :=\n  IsCofilteredOrEmpty.of_equivalence (equivSmallModel _)\n\n"}
{"name":"CategoryTheory.IsCofiltered.SmallCofilteredIntermediate.instOfNonempty","module":"Mathlib.CategoryTheory.Filtered.Small","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.IsCofilteredOrEmpty C\nD : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor D C\ninst✝ : Nonempty D\n⊢ CategoryTheory.IsCofiltered (CategoryTheory.IsCofiltered.SmallCofilteredIntermediate F)","decl":"instance [Nonempty D] : IsCofiltered (SmallCofilteredIntermediate F) :=\n  { (inferInstance : IsCofilteredOrEmpty _) with\n    nonempty := Nonempty.map (factoring F).obj inferInstance }\n\n"}
