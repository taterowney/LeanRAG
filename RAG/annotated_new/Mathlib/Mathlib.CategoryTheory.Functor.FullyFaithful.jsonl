{"name":"CategoryTheory.Functor.Full.map_surjective","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : F.Full\nX Y : C\n‚ä¢ Function.Surjective F.map","decl":"/-- A functor `F : C ‚•§ D` is full if for each `X Y : C`, `F.map` is surjective. -/\n@[stacks 001C]\nclass Full (F : C ‚•§ D) : Prop where\n  map_surjective {X Y : C} : Function.Surjective (F.map (X := X) (Y := Y))\n\n"}
{"name":"CategoryTheory.Functor.Faithful.map_injective","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : F.Faithful\nX Y : C\n‚ä¢ Function.Injective F.map","decl":"/-- A functor `F : C ‚•§ D` is faithful if for each `X Y : C`, `F.map` is injective. -/\n@[stacks 001C]\nclass Faithful (F : C ‚•§ D) : Prop where\n  /-- `F.map` is injective for each `X Y : C`. -/\n  map_injective : ‚àÄ {X Y : C}, Function.Injective (F.map : (X ‚ü∂ Y) ‚Üí (F.obj X ‚ü∂ F.obj Y)) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.map_injective","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nF : CategoryTheory.Functor C D\ninst‚úù : F.Faithful\n‚ä¢ Function.Injective F.map","decl":"theorem map_injective (F : C ‚•§ D) [Faithful F] :\n    Function.Injective <| (F.map : (X ‚ü∂ Y) ‚Üí (F.obj X ‚ü∂ F.obj Y)) :=\n  Faithful.map_injective\n\n"}
{"name":"CategoryTheory.Functor.map_injective_iff","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Faithful\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq (F.map f) (F.map g)) (Eq f g)","decl":"lemma map_injective_iff (F : C ‚•§ D) [Faithful F] {X Y : C} (f g : X ‚ü∂ Y) :\n    F.map f = F.map g ‚Üî f = g :=\n  ‚ü®fun h => F.map_injective h, fun h => by rw [h]‚ü©\n\n"}
{"name":"CategoryTheory.Functor.mapIso_injective","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nF : CategoryTheory.Functor C D\ninst‚úù : F.Faithful\n‚ä¢ Function.Injective F.mapIso","decl":"theorem mapIso_injective (F : C ‚•§ D) [Faithful F] :\n    Function.Injective <| (F.mapIso : (X ‚âÖ Y) ‚Üí (F.obj X ‚âÖ F.obj Y))  := fun _ _ h =>\n  Iso.ext (map_injective F (congr_arg Iso.hom h :))\n\n"}
{"name":"CategoryTheory.Functor.map_surjective","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nF : CategoryTheory.Functor C D\ninst‚úù : F.Full\n‚ä¢ Function.Surjective F.map","decl":"theorem map_surjective (F : C ‚•§ D) [Full F] :\n    Function.Surjective (F.map : (X ‚ü∂ Y) ‚Üí (F.obj X ‚ü∂ F.obj Y)) :=\n  Full.map_surjective\n\n"}
{"name":"CategoryTheory.Functor.map_preimage","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Full\nX Y : C\nf : Quiver.Hom (F.obj X) (F.obj Y)\n‚ä¢ Eq (F.map (F.preimage f)) f","decl":"@[simp]\ntheorem map_preimage (F : C ‚•§ D) [Full F] {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) :\n    F.map (preimage F f) = f :=\n  (F.map_surjective f).choose_spec\n\n"}
{"name":"CategoryTheory.Functor.preimage_id","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (F.preimage (CategoryTheory.CategoryStruct.id (F.obj X))) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem preimage_id : F.preimage (ùüô (F.obj X)) = ùüô X :=\n  F.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.Functor.preimage_comp","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y Z : C\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nf : Quiver.Hom (F.obj X) (F.obj Y)\ng : Quiver.Hom (F.obj Y) (F.obj Z)\n‚ä¢ Eq (F.preimage (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.preimage f) (F.preimage g))","decl":"@[simp]\ntheorem preimage_comp (f : F.obj X ‚ü∂ F.obj Y) (g : F.obj Y ‚ü∂ F.obj Z) :\n    F.preimage (f ‚â´ g) = F.preimage f ‚â´ F.preimage g :=\n  F.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.Functor.preimage_map","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.preimage (F.map f)) f","decl":"@[simp]\ntheorem preimage_map (f : X ‚ü∂ Y) : F.preimage (F.map f) = f :=\n  F.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.Functor.preimageIso_inv","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nf : CategoryTheory.Iso (F.obj X) (F.obj Y)\n‚ä¢ Eq (F.preimageIso f).inv (F.preimage f.inv)","decl":"/-- If `F : C ‚•§ D` is fully faithful, every isomorphism `F.obj X ‚âÖ F.obj Y` has a preimage. -/\n@[simps]\nnoncomputable def preimageIso (f : F.obj X ‚âÖ F.obj Y) :\n    X ‚âÖ Y where\n  hom := F.preimage f.hom\n  inv := F.preimage f.inv\n  hom_inv_id := F.map_injective (by simp)\n  inv_hom_id := F.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.Functor.preimageIso_hom","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nf : CategoryTheory.Iso (F.obj X) (F.obj Y)\n‚ä¢ Eq (F.preimageIso f).hom (F.preimage f.hom)","decl":"/-- If `F : C ‚•§ D` is fully faithful, every isomorphism `F.obj X ‚âÖ F.obj Y` has a preimage. -/\n@[simps]\nnoncomputable def preimageIso (f : F.obj X ‚âÖ F.obj Y) :\n    X ‚âÖ Y where\n  hom := F.preimage f.hom\n  inv := F.preimage f.inv\n  hom_inv_id := F.map_injective (by simp)\n  inv_hom_id := F.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.Functor.preimageIso_mapIso","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq (F.preimageIso (F.mapIso f)) f","decl":"@[simp]\ntheorem preimageIso_mapIso (f : X ‚âÖ Y) : F.preimageIso (F.mapIso f) = f := by\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.mk.injEq","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\npreimage‚úù : {X Y : C} ‚Üí Quiver.Hom (F.obj X) (F.obj Y) ‚Üí Quiver.Hom X Y\nmap_preimage‚úù : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom (F.obj X) (F.obj Y)), Eq (F.map (preimage‚úù f)) f) _auto‚úù\npreimage_map‚úù : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom X Y), Eq (preimage‚úù (F.map f)) f) _auto‚úù\npreimage : {X Y : C} ‚Üí Quiver.Hom (F.obj X) (F.obj Y) ‚Üí Quiver.Hom X Y\nmap_preimage : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom (F.obj X) (F.obj Y)), Eq (F.map (preimage f)) f) _auto‚úù\npreimage_map : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom X Y), Eq (preimage (F.map f)) f) _auto‚úù\n‚ä¢ Eq (Eq { preimage := preimage‚úù, map_preimage := map_preimage‚úù, preimage_map := preimage_map‚úù } { preimage := preimage, map_preimage := map_preimage, preimage_map := preimage_map }) (Eq preimage‚úù preimage)","decl":"variable (F) in\n/-- Structure containing the data of inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`\nin order to express that `F` is a fully faithful functor. -/\nstructure FullyFaithful where\n  /-- The inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`. -/\n  preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : X ‚ü∂ Y\n  map_preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : F.map (preimage f) = f := by aesop_cat\n  preimage_map {X Y : C} (f : X ‚ü∂ Y) : preimage (F.map f) = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.mk.inj","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\npreimage‚úù : {X Y : C} ‚Üí Quiver.Hom (F.obj X) (F.obj Y) ‚Üí Quiver.Hom X Y\nmap_preimage‚úù : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom (F.obj X) (F.obj Y)), Eq (F.map (preimage‚úù f)) f) _auto‚úù\npreimage_map‚úù : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom X Y), Eq (preimage‚úù (F.map f)) f) _auto‚úù\npreimage : {X Y : C} ‚Üí Quiver.Hom (F.obj X) (F.obj Y) ‚Üí Quiver.Hom X Y\nmap_preimage : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom (F.obj X) (F.obj Y)), Eq (F.map (preimage f)) f) _auto‚úù\npreimage_map : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom X Y), Eq (preimage (F.map f)) f) _auto‚úù\nx‚úù : Eq { preimage := preimage‚úù, map_preimage := map_preimage‚úù, preimage_map := preimage_map‚úù } { preimage := preimage, map_preimage := map_preimage, preimage_map := preimage_map }\n‚ä¢ Eq preimage‚úù preimage","decl":"variable (F) in\n/-- Structure containing the data of inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`\nin order to express that `F` is a fully faithful functor. -/\nstructure FullyFaithful where\n  /-- The inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`. -/\n  preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : X ‚ü∂ Y\n  map_preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : F.map (preimage f) = f := by aesop_cat\n  preimage_map {X Y : C} (f : X ‚ü∂ Y) : preimage (F.map f) = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\npreimage : {X Y : C} ‚Üí Quiver.Hom (F.obj X) (F.obj Y) ‚Üí Quiver.Hom X Y\nmap_preimage : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom (F.obj X) (F.obj Y)), Eq (F.map (preimage f)) f) _auto‚úù\npreimage_map : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom X Y), Eq (preimage (F.map f)) f) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { preimage := preimage, map_preimage := map_preimage, preimage_map := preimage_map }) 1","decl":"variable (F) in\n/-- Structure containing the data of inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`\nin order to express that `F` is a fully faithful functor. -/\nstructure FullyFaithful where\n  /-- The inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`. -/\n  preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : X ‚ü∂ Y\n  map_preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : F.map (preimage f) = f := by aesop_cat\n  preimage_map {X Y : C} (f : X ‚ü∂ Y) : preimage (F.map f) = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.preimage_map","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : F.FullyFaithful\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (self.preimage (F.map f)) f","decl":"variable (F) in\n/-- Structure containing the data of inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`\nin order to express that `F` is a fully faithful functor. -/\nstructure FullyFaithful where\n  /-- The inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`. -/\n  preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : X ‚ü∂ Y\n  map_preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : F.map (preimage f) = f := by aesop_cat\n  preimage_map {X Y : C} (f : X ‚ü∂ Y) : preimage (F.map f) = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.map_preimage","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : F.FullyFaithful\nX Y : C\nf : Quiver.Hom (F.obj X) (F.obj Y)\n‚ä¢ Eq (F.map (self.preimage f)) f","decl":"variable (F) in\n/-- Structure containing the data of inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`\nin order to express that `F` is a fully faithful functor. -/\nstructure FullyFaithful where\n  /-- The inverse map `(F.obj X ‚ü∂ F.obj Y) ‚ü∂ (X ‚ü∂ Y)` of `F.map`. -/\n  preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : X ‚ü∂ Y\n  map_preimage {X Y : C} (f : F.obj X ‚ü∂ F.obj Y) : F.map (preimage f) = f := by aesop_cat\n  preimage_map {X Y : C} (f : X ‚ü∂ Y) : preimage (F.map f) = f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.id_preimage","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom ((CategoryTheory.Functor.id C).obj X‚úù) ((CategoryTheory.Functor.id C).obj Y‚úù)\n‚ä¢ Eq ((CategoryTheory.Functor.FullyFaithful.id C).preimage f) f","decl":"variable (C) in\n/-- The identity functor is fully faithful. -/\n@[simps]\ndef id : (ùü≠ C).FullyFaithful where\n  preimage f := f\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.homEquiv_apply","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\na‚úù : Quiver.Hom X Y\n‚ä¢ Eq (hF.homEquiv a‚úù) (F.map a‚úù)","decl":"/-- The equivalence `(X ‚ü∂ Y) ‚âÉ (F.obj X ‚ü∂ F.obj Y)` given by `h : F.FullyFaithful`. -/\n@[simps]\ndef homEquiv {X Y : C} : (X ‚ü∂ Y) ‚âÉ (F.obj X ‚ü∂ F.obj Y) where\n  toFun := F.map\n  invFun := hF.preimage\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.homEquiv_symm_apply","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\nf : Quiver.Hom (F.obj X) (F.obj Y)\n‚ä¢ Eq (hF.homEquiv.symm f) (hF.preimage f)","decl":"/-- The equivalence `(X ‚ü∂ Y) ‚âÉ (F.obj X ‚ü∂ F.obj Y)` given by `h : F.FullyFaithful`. -/\n@[simps]\ndef homEquiv {X Y : C} : (X ‚ü∂ Y) ‚âÉ (F.obj X ‚ü∂ F.obj Y) where\n  toFun := F.map\n  invFun := hF.preimage\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.map_injective","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\nf g : Quiver.Hom X Y\nh : Eq (F.map f) (F.map g)\n‚ä¢ Eq f g","decl":"lemma map_injective {X Y : C} {f g : X ‚ü∂ Y} (h : F.map f = F.map g) : f = g :=\n  hF.homEquiv.injective h\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.map_surjective","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\n‚ä¢ Function.Surjective F.map","decl":"lemma map_surjective {X Y : C} :\n    Function.Surjective (F.map : (X ‚ü∂ Y) ‚Üí (F.obj X ‚ü∂ F.obj Y)) :=\n  hF.homEquiv.surjective\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.map_bijective","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\n‚ä¢ Function.Bijective F.map","decl":"lemma map_bijective (X Y : C) :\n    Function.Bijective (F.map : (X ‚ü∂ Y) ‚Üí (F.obj X ‚ü∂ F.obj Y)) :=\n  hF.homEquiv.bijective\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.full","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\n‚ä¢ F.Full","decl":"lemma full : F.Full where\n  map_surjective := hF.map_surjective\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.faithful","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\n‚ä¢ F.Faithful","decl":"lemma faithful : F.Faithful where\n  map_injective := hF.map_injective\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.instSubsingleton","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton F.FullyFaithful","decl":"instance : Subsingleton F.FullyFaithful where\n  allEq h‚ÇÅ h‚ÇÇ := by\n    have := h‚ÇÅ.faithful\n    cases h‚ÇÅ with | mk f‚ÇÅ hf‚ÇÅ _ => cases h‚ÇÇ with | mk f‚ÇÇ hf‚ÇÇ _ =>\n    simp only [Functor.FullyFaithful.mk.injEq]\n    ext\n    apply F.map_injective\n    rw [hf‚ÇÅ, hf‚ÇÇ]\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.preimageIso_hom","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\ne : CategoryTheory.Iso (F.obj X) (F.obj Y)\n‚ä¢ Eq (hF.preimageIso e).hom (hF.preimage e.hom)","decl":"/-- The unique isomorphism `X ‚âÖ Y` which induces an isomorphism `F.obj X ‚âÖ F.obj Y`\nwhen `hF : F.FullyFaithful`. -/\n@[simps]\ndef preimageIso {X Y : C} (e : F.obj X ‚âÖ F.obj Y) : X ‚âÖ Y where\n  hom := hF.preimage e.hom\n  inv := hF.preimage e.inv\n  hom_inv_id := hF.map_injective (by simp)\n  inv_hom_id := hF.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.preimageIso_inv","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\ne : CategoryTheory.Iso (F.obj X) (F.obj Y)\n‚ä¢ Eq (hF.preimageIso e).inv (hF.preimage e.inv)","decl":"/-- The unique isomorphism `X ‚âÖ Y` which induces an isomorphism `F.obj X ‚âÖ F.obj Y`\nwhen `hF : F.FullyFaithful`. -/\n@[simps]\ndef preimageIso {X Y : C} (e : F.obj X ‚âÖ F.obj Y) : X ‚âÖ Y where\n  hom := hF.preimage e.hom\n  inv := hF.preimage e.inv\n  hom_inv_id := hF.map_injective (by simp)\n  inv_hom_id := hF.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.isIso_of_isIso_map","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso (F.map f)\n‚ä¢ CategoryTheory.IsIso f","decl":"lemma isIso_of_isIso_map {X Y : C} (f : X ‚ü∂ Y) [IsIso (F.map f)] :\n    IsIso f := by\n  simpa using (hF.preimageIso (asIso (F.map f))).isIso_hom\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.isoEquiv_apply","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\ni : CategoryTheory.Iso X Y\n‚ä¢ Eq (hF.isoEquiv i) (F.mapIso i)","decl":"/-- The equivalence `(X ‚âÖ Y) ‚âÉ (F.obj X ‚âÖ F.obj Y)` given by `h : F.FullyFaithful`. -/\n@[simps]\ndef isoEquiv {X Y : C} : (X ‚âÖ Y) ‚âÉ (F.obj X ‚âÖ F.obj Y) where\n  toFun := F.mapIso\n  invFun := hF.preimageIso\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.isoEquiv_symm_apply","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX Y : C\ne : CategoryTheory.Iso (F.obj X) (F.obj Y)\n‚ä¢ Eq (hF.isoEquiv.symm e) (hF.preimageIso e)","decl":"/-- The equivalence `(X ‚âÖ Y) ‚âÉ (F.obj X ‚âÖ F.obj Y)` given by `h : F.FullyFaithful`. -/\n@[simps]\ndef isoEquiv {X Y : C} : (X ‚âÖ Y) ‚âÉ (F.obj X ‚âÖ F.obj Y) where\n  toFun := F.mapIso\n  invFun := hF.preimageIso\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.comp_preimage","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nG : CategoryTheory.Functor D E\nhG : G.FullyFaithful\nX‚úù Y‚úù : C\nf : Quiver.Hom ((F.comp G).obj X‚úù) ((F.comp G).obj Y‚úù)\n‚ä¢ Eq ((hF.comp hG).preimage f) (hF.preimage (hG.preimage f))","decl":"/-- Fully faithful functors are stable by composition. -/\n@[simps]\ndef comp {G : D ‚•§ E} (hG : G.FullyFaithful) : (F ‚ãô G).FullyFaithful where\n  preimage f := hF.preimage (hG.preimage f)\n\n"}
{"name":"CategoryTheory.isIso_of_fully_faithful","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.Full\ninst‚úù¬π : F.Faithful\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso (F.map f)\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- If the image of a morphism under a fully faithful functor in an isomorphism,\nthen the original morphisms is also an isomorphism.\n-/\ntheorem isIso_of_fully_faithful (f : X ‚ü∂ Y) [IsIso (F.map f)] : IsIso f :=\n  ‚ü®‚ü®F.preimage (inv (F.map f)), ‚ü®F.map_injective (by simp), F.map_injective (by simp)‚ü©‚ü©‚ü©\n\n\n"}
{"name":"CategoryTheory.Functor.Full.id","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.Functor.id C).Full","decl":"instance Full.id : Full (ùü≠ C) where map_surjective := Function.surjective_id\n\n"}
{"name":"CategoryTheory.Functor.Faithful.id","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.Functor.id C).Faithful","decl":"instance Faithful.id : Functor.Faithful (ùü≠ C) := { }\n\n"}
{"name":"CategoryTheory.Functor.Faithful.comp","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : F.Faithful\ninst‚úù : G.Faithful\n‚ä¢ (F.comp G).Faithful","decl":"instance Faithful.comp [F.Faithful] [G.Faithful] :\n    (F ‚ãô G).Faithful where map_injective p := F.map_injective (G.map_injective p)\n\n"}
{"name":"CategoryTheory.Functor.Faithful.of_comp","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù : (F.comp G).Faithful\n‚ä¢ F.Faithful","decl":"theorem Faithful.of_comp [(F ‚ãô G).Faithful] : F.Faithful :=\n  -- Porting note: (F ‚ãô G).map_injective.of_comp has the incorrect type\n  { map_injective := fun {_ _} => Function.Injective.of_comp (F ‚ãô G).map_injective }\n\n"}
{"name":"CategoryTheory.Functor.instFaithfulOfIsThin","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : Quiver.IsThin C\n‚ä¢ F.Faithful","decl":"instance (priority := 100) [Quiver.IsThin C] : F.Faithful where\n\n"}
{"name":"CategoryTheory.Functor.Full.of_iso","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF F' : CategoryTheory.Functor C D\ninst‚úù : F.Full\nŒ± : CategoryTheory.Iso F F'\n‚ä¢ F'.Full","decl":"/-- If `F` is full, and naturally isomorphic to some `F'`, then `F'` is also full. -/\nlemma Full.of_iso [Full F] (Œ± : F ‚âÖ F') : Full F' where\n  map_surjective {X Y} f :=\n    ‚ü®F.preimage ((Œ±.app X).hom ‚â´ f ‚â´ (Œ±.app Y).inv), by simp [‚Üê NatIso.naturality_1 Œ±]‚ü©\n\n"}
{"name":"CategoryTheory.Functor.Faithful.of_iso","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF F' : CategoryTheory.Functor C D\ninst‚úù : F.Faithful\nŒ± : CategoryTheory.Iso F F'\n‚ä¢ F'.Faithful","decl":"theorem Faithful.of_iso [F.Faithful] (Œ± : F ‚âÖ F') : F'.Faithful :=\n  { map_injective := fun h =>\n      F.map_injective (by rw [‚Üê NatIso.naturality_1 Œ±.symm, h, NatIso.naturality_1 Œ±.symm]) }\n\n"}
{"name":"CategoryTheory.Functor.Faithful.of_comp_iso","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nH : CategoryTheory.Functor C E\ninst‚úù : H.Faithful\nh : CategoryTheory.Iso (F.comp G) H\n‚ä¢ F.Faithful","decl":"theorem Faithful.of_comp_iso {H : C ‚•§ E} [H.Faithful] (h : F ‚ãô G ‚âÖ H) : F.Faithful :=\n  @Faithful.of_comp _ _ _ _ _ _ F G (Faithful.of_iso h.symm)\n\n"}
{"name":"CategoryTheory.Iso.faithful_of_comp","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nH : CategoryTheory.Functor C E\ninst‚úù : H.Faithful\nh : CategoryTheory.Iso (F.comp G) H\n‚ä¢ F.Faithful","decl":"alias _root_.CategoryTheory.Iso.faithful_of_comp := Faithful.of_comp_iso\n\n-- We could prove this from `Faithful.of_comp_iso` using `eq_to_iso`,\n-- but that would introduce a cyclic import.\n"}
{"name":"CategoryTheory.Functor.Faithful.of_comp_eq","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nH : CategoryTheory.Functor C E\n‚Ñã : H.Faithful\nh : Eq (F.comp G) H\n‚ä¢ F.Faithful","decl":"theorem Faithful.of_comp_eq {H : C ‚•§ E} [‚Ñã : H.Faithful] (h : F ‚ãô G = H) : F.Faithful :=\n  @Faithful.of_comp _ _ _ _ _ _ F G (h.symm ‚ñ∏ ‚Ñã)\n\n"}
{"name":"Eq.faithful_of_comp","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nH : CategoryTheory.Functor C E\n‚Ñã : H.Faithful\nh : Eq (F.comp G) H\n‚ä¢ F.Faithful","decl":"alias _root_.Eq.faithful_of_comp := Faithful.of_comp_eq\n\n"}
{"name":"CategoryTheory.Functor.Faithful.div_comp","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\ninst‚úù¬π : F.Faithful\nG : CategoryTheory.Functor D E\ninst‚úù : G.Faithful\nobj : C ‚Üí D\nh_obj : ‚àÄ (X : C), Eq (G.obj (obj X)) (F.obj X)\nmap : {X Y : C} ‚Üí Quiver.Hom X Y ‚Üí Quiver.Hom (obj X) (obj Y)\nh_map : ‚àÄ {X Y : C} {f : Quiver.Hom X Y}, HEq (G.map (map f)) (F.map f)\n‚ä¢ Eq ((CategoryTheory.Functor.Faithful.div F G obj h_obj map h_map).comp G) F","decl":"theorem Faithful.div_comp (F : C ‚•§ E) [F.Faithful] (G : D ‚•§ E) [G.Faithful] (obj : C ‚Üí D)\n    (h_obj : ‚àÄ X, G.obj (obj X) = F.obj X) (map : ‚àÄ {X Y}, (X ‚ü∂ Y) ‚Üí (obj X ‚ü∂ obj Y))\n    (h_map : ‚àÄ {X Y} {f : X ‚ü∂ Y}, HEq (G.map (map f)) (F.map f)) :\n    Faithful.div F G obj @h_obj @map @h_map ‚ãô G = F := by\n  -- Porting note: Have to unfold the structure twice because the first one recovers only the\n  -- prefunctor `F_pre`\n  cases' F with F_pre _ _; cases' G with G_pre _ _\n  cases' F_pre with F_obj _; cases' G_pre with G_obj _\n  unfold Faithful.div Functor.comp\n  -- Porting note: unable to find the lean4 analogue to `unfold_projs`, works without it\n  have : F_obj = G_obj ‚àò obj := (funext h_obj).symm\n  subst this\n  congr\n  simp only [Function.comp_apply, heq_eq_eq] at h_map\n  ext\n  exact h_map\n\n"}
{"name":"CategoryTheory.Functor.Faithful.div_faithful","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\ninst‚úù¬π : F.Faithful\nG : CategoryTheory.Functor D E\ninst‚úù : G.Faithful\nobj : C ‚Üí D\nh_obj : ‚àÄ (X : C), Eq (G.obj (obj X)) (F.obj X)\nmap : {X Y : C} ‚Üí Quiver.Hom X Y ‚Üí Quiver.Hom (obj X) (obj Y)\nh_map : ‚àÄ {X Y : C} {f : Quiver.Hom X Y}, HEq (G.map (map f)) (F.map f)\n‚ä¢ (CategoryTheory.Functor.Faithful.div F G obj h_obj map h_map).Faithful","decl":"theorem Faithful.div_faithful (F : C ‚•§ E) [F.Faithful] (G : D ‚•§ E) [G.Faithful] (obj : C ‚Üí D)\n    (h_obj : ‚àÄ X, G.obj (obj X) = F.obj X) (map : ‚àÄ {X Y}, (X ‚ü∂ Y) ‚Üí (obj X ‚ü∂ obj Y))\n    (h_map : ‚àÄ {X Y} {f : X ‚ü∂ Y}, HEq (G.map (map f)) (F.map f)) :\n    Functor.Faithful (Faithful.div F G obj @h_obj @map @h_map) :=\n  (Faithful.div_comp F G _ h_obj _ @h_map).faithful_of_comp\n\n"}
{"name":"CategoryTheory.Functor.Full.comp","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : F.Full\ninst‚úù : G.Full\n‚ä¢ (F.comp G).Full","decl":"instance Full.comp [Full F] [Full G] : Full (F ‚ãô G) where\n  map_surjective f := ‚ü®F.preimage (G.preimage f), by simp‚ü©\n\n"}
{"name":"CategoryTheory.Functor.Full.of_comp_faithful","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : (F.comp G).Full\ninst‚úù : G.Faithful\n‚ä¢ F.Full","decl":"/-- If `F ‚ãô G` is full and `G` is faithful, then `F` is full. -/\nlemma Full.of_comp_faithful [Full <| F ‚ãô G] [G.Faithful] : Full F where\n  map_surjective f := ‚ü®(F ‚ãô G).preimage (G.map f), G.map_injective ((F ‚ãô G).map_preimage _)‚ü©\n\n"}
{"name":"CategoryTheory.Functor.Full.of_comp_faithful_iso","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nH : CategoryTheory.Functor C E\ninst‚úù¬π : H.Full\ninst‚úù : G.Faithful\nh : CategoryTheory.Iso (F.comp G) H\n‚ä¢ F.Full","decl":"/-- If `F ‚ãô G` is full and `G` is faithful, then `F` is full. -/\nlemma Full.of_comp_faithful_iso {F : C ‚•§ D} {G : D ‚•§ E} {H : C ‚•§ E} [Full H] [G.Faithful]\n    (h : F ‚ãô G ‚âÖ H) : Full F := by\n  have := Full.of_iso h.symm\n  exact Full.of_comp_faithful F G\n\n"}
{"name":"CategoryTheory.Functor.fullyFaithfulCancelRight_hom_app","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nH : CategoryTheory.Functor D E\ninst‚úù¬π : H.Full\ninst‚úù : H.Faithful\ncomp_iso : CategoryTheory.Iso (F.comp H) (G.comp H)\nX : C\n‚ä¢ Eq ((CategoryTheory.Functor.fullyFaithfulCancelRight H comp_iso).hom.app X) (H.preimage (comp_iso.hom.app X))","decl":"@[simp]\ntheorem fullyFaithfulCancelRight_hom_app {F G : C ‚•§ D} {H : D ‚•§ E} [Full H] [H.Faithful]\n    (comp_iso : F ‚ãô H ‚âÖ G ‚ãô H) (X : C) :\n    (fullyFaithfulCancelRight H comp_iso).hom.app X = H.preimage (comp_iso.hom.app X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.fullyFaithfulCancelRight_inv_app","module":"Mathlib.CategoryTheory.Functor.FullyFaithful","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nH : CategoryTheory.Functor D E\ninst‚úù¬π : H.Full\ninst‚úù : H.Faithful\ncomp_iso : CategoryTheory.Iso (F.comp H) (G.comp H)\nX : C\n‚ä¢ Eq ((CategoryTheory.Functor.fullyFaithfulCancelRight H comp_iso).inv.app X) (H.preimage (comp_iso.inv.app X))","decl":"@[simp]\ntheorem fullyFaithfulCancelRight_inv_app {F G : C ‚•§ D} {H : D ‚•§ E} [Full H] [H.Faithful]\n    (comp_iso : F ‚ãô H ‚âÖ G ‚ãô H) (X : C) :\n    (fullyFaithfulCancelRight H comp_iso).inv.app X = H.preimage (comp_iso.inv.app X) :=\n  rfl\n\n"}
