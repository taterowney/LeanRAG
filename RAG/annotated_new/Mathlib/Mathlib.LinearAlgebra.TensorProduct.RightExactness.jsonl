{"name":"le_comap_range_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_3\nP : Type u_4\nQ : Type u_5\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\ng : LinearMap (RingHom.id R) N P\nq : Q\n⊢ LE.le (LinearMap.range g) (Submodule.comap ((TensorProduct.mk R Q P) q) (LinearMap.range (LinearMap.lTensor Q g)))","decl":"lemma le_comap_range_lTensor (q : Q) :\n    LinearMap.range g ≤ (LinearMap.range (lTensor Q g)).comap (TensorProduct.mk R Q P q) := by\n  rintro x ⟨n, rfl⟩\n  exact ⟨q ⊗ₜ[R] n, rfl⟩\n\n"}
{"name":"le_comap_range_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_3\nP : Type u_4\nQ : Type u_5\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\ng : LinearMap (RingHom.id R) N P\nq : Q\n⊢ LE.le (LinearMap.range g) (Submodule.comap ((TensorProduct.mk R P Q).flip q) (LinearMap.range (LinearMap.rTensor Q g)))","decl":"lemma le_comap_range_rTensor (q : Q) :\n    LinearMap.range g ≤ (LinearMap.range (rTensor Q g)).comap\n      ((TensorProduct.mk R P Q).flip q) := by\n  rintro x ⟨n, rfl⟩\n  exact ⟨n ⊗ₜ[R] q, rfl⟩\n\n"}
{"name":"LinearMap.lTensor_surjective","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_3\nP : Type u_4\nQ : Type u_5\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\ng : LinearMap (RingHom.id R) N P\nhg : Function.Surjective ⇑g\n⊢ Function.Surjective ⇑(LinearMap.lTensor Q g)","decl":"/-- If `g` is surjective, then `lTensor Q g` is surjective -/\ntheorem LinearMap.lTensor_surjective (hg : Function.Surjective g) :\n    Function.Surjective (lTensor Q g) := by\n  intro z\n  induction z with\n  | zero => exact ⟨0, map_zero _⟩\n  | tmul q p =>\n    obtain ⟨n, rfl⟩ := hg p\n    exact ⟨q ⊗ₜ[R] n, rfl⟩\n  | add x y hx hy =>\n    obtain ⟨x, rfl⟩ := hx\n    obtain ⟨y, rfl⟩ := hy\n    exact ⟨x + y, map_add _ _ _⟩\n\n"}
{"name":"LinearMap.lTensor_range","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_3\nP : Type u_4\nQ : Type u_5\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\ng : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.range (LinearMap.lTensor Q g)) (LinearMap.range (LinearMap.lTensor Q (LinearMap.range g).subtype))","decl":"theorem LinearMap.lTensor_range :\n    range (lTensor Q g) =\n      range (lTensor Q (Submodule.subtype (range g))) := by\n  have : g = (Submodule.subtype _).comp g.rangeRestrict := rfl\n  nth_rewrite 1 [this]\n  rw [lTensor_comp]\n  apply range_comp_of_range_eq_top\n  rw [range_eq_top]\n  apply lTensor_surjective\n  rw [← range_eq_top, range_rangeRestrict]\n\n"}
{"name":"LinearMap.rTensor_surjective","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_3\nP : Type u_4\nQ : Type u_5\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\ng : LinearMap (RingHom.id R) N P\nhg : Function.Surjective ⇑g\n⊢ Function.Surjective ⇑(LinearMap.rTensor Q g)","decl":"/-- If `g` is surjective, then `rTensor Q g` is surjective -/\ntheorem LinearMap.rTensor_surjective (hg : Function.Surjective g) :\n    Function.Surjective (rTensor Q g) := by\n  intro z\n  induction z with\n  | zero => exact ⟨0, map_zero _⟩\n  | tmul p q =>\n    obtain ⟨n, rfl⟩ := hg p\n    exact ⟨n ⊗ₜ[R] q, rfl⟩\n  | add x y hx hy =>\n    obtain ⟨x, rfl⟩ := hx\n    obtain ⟨y, rfl⟩ := hy\n    exact ⟨x + y, map_add _ _ _⟩\n\n"}
{"name":"LinearMap.rTensor_range","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_3\nP : Type u_4\nQ : Type u_5\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\ng : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.range (LinearMap.rTensor Q g)) (LinearMap.range (LinearMap.rTensor Q (LinearMap.range g).subtype))","decl":"theorem LinearMap.rTensor_range :\n    range (rTensor Q g) =\n      range (rTensor Q (Submodule.subtype (range g))) := by\n  have : g = (Submodule.subtype _).comp g.rangeRestrict := rfl\n  nth_rewrite 1 [this]\n  rw [rTensor_comp]\n  apply range_comp_of_range_eq_top\n  rw [range_eq_top]\n  apply rTensor_surjective\n  rw [← range_eq_top, range_rangeRestrict]\n\n"}
{"name":"LinearMap.rTensor_exact_iff_lTensor_exact","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_2\nN : Type u_3\nP : Type u_4\nQ : Type u_5\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\n⊢ Iff (Function.Exact ⇑(LinearMap.rTensor Q f) ⇑(LinearMap.rTensor Q g)) (Function.Exact ⇑(LinearMap.lTensor Q f) ⇑(LinearMap.lTensor Q g))","decl":"lemma LinearMap.rTensor_exact_iff_lTensor_exact :\n    Function.Exact (f.rTensor Q) (g.rTensor Q) ↔\n    Function.Exact (f.lTensor Q) (g.lTensor Q) :=\n  Function.Exact.iff_of_ladder_linearEquiv (e₁ := TensorProduct.comm _ _ _)\n    (e₂ := TensorProduct.comm _ _ _) (e₃ := TensorProduct.comm _ _ _)\n    (by ext; simp) (by ext; simp)\n\n"}
{"name":"TensorProduct.map_surjective","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nN : Type u_3\nP : Type u_4\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : AddCommMonoid P\ninst✝⁵ : Module R N\ninst✝⁴ : Module R P\ng : LinearMap (RingHom.id R) N P\nhg : Function.Surjective ⇑g\nN' : Type u_6\nP' : Type u_7\ninst✝³ : AddCommMonoid N'\ninst✝² : AddCommMonoid P'\ninst✝¹ : Module R N'\ninst✝ : Module R P'\ng' : LinearMap (RingHom.id R) N' P'\nhg' : Function.Surjective ⇑g'\n⊢ Function.Surjective ⇑(TensorProduct.map g g')","decl":"include hg hg' in\ntheorem TensorProduct.map_surjective : Function.Surjective (TensorProduct.map g g') := by\n  rw [← lTensor_comp_rTensor, coe_comp]\n  exact Function.Surjective.comp (lTensor_surjective _ hg') (rTensor_surjective _ hg)\n\n"}
{"name":"TensorProduct.mk_surjective","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_8\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nh : Function.Surjective ⇑(algebraMap R S)\n⊢ Function.Surjective ⇑((TensorProduct.mk R S M) 1)","decl":"variable (M R) in\ntheorem TensorProduct.mk_surjective (S) [Semiring S] [Algebra R S]\n    (h : Function.Surjective (algebraMap R S)) :\n    Function.Surjective (TensorProduct.mk R S M 1) := by\n  rw [← LinearMap.range_eq_top, ← top_le_iff, ← span_tmul_eq_top, Submodule.span_le]\n  rintro _ ⟨x, y, rfl⟩\n  obtain ⟨x, rfl⟩ := h x\n  rw [Algebra.algebraMap_eq_smul_one, smul_tmul]\n  exact ⟨x • y, rfl⟩\n\n"}
{"name":"lTensor.inverse_of_rightInverse_apply","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nh : P → N\nhgh : Function.RightInverse h ⇑g\ny : TensorProduct R Q N\n⊢ Eq ((lTensor.inverse_of_rightInverse Q hfg hgh) ((LinearMap.lTensor Q g) y)) (Submodule.Quotient.mk y)","decl":"lemma lTensor.inverse_of_rightInverse_apply\n    {h : P → N} (hgh : Function.RightInverse h g) (y : Q ⊗[R] N) :\n    (lTensor.inverse_of_rightInverse Q hfg hgh) ((lTensor Q g) y) =\n      Submodule.Quotient.mk (p := (LinearMap.range (lTensor Q f))) y := by\n  simp only [← LinearMap.comp_apply, ← Submodule.mkQ_apply]\n  rw [exact_iff] at hfg\n  apply LinearMap.congr_fun\n  apply TensorProduct.ext'\n  intro n q\n  simp? [lTensor.inverse_of_rightInverse] says\n    simp only [inverse_of_rightInverse, coe_comp, Function.comp_apply, lTensor_tmul,\n      lift.tmul, flip_apply, coe_mk, AddHom.coe_mk, mk_apply, Submodule.mkQ_apply]\n  rw [Submodule.Quotient.eq, ← TensorProduct.tmul_sub]\n  apply le_comap_range_lTensor f n\n  rw [← hfg, mem_ker, map_sub, sub_eq_zero, hgh]\n\n"}
{"name":"lTensor.inverse_of_rightInverse_comp_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nh : P → N\nhgh : Function.RightInverse h ⇑g\n⊢ Eq ((lTensor.inverse_of_rightInverse Q hfg hgh).comp (LinearMap.lTensor Q g)) (LinearMap.range (LinearMap.lTensor Q f)).mkQ","decl":"lemma lTensor.inverse_of_rightInverse_comp_lTensor\n    {h : P → N} (hgh : Function.RightInverse h g) :\n    (lTensor.inverse_of_rightInverse Q hfg hgh).comp (lTensor Q g) =\n      Submodule.mkQ (p := LinearMap.range (lTensor Q f)) := by\n  rw [LinearMap.ext_iff]\n  intro y\n  simp only [coe_comp, Function.comp_apply, Submodule.mkQ_apply,\n    lTensor.inverse_of_rightInverse_apply]\n\n"}
{"name":"lTensor.inverse_apply","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\ny : TensorProduct R Q N\n⊢ Eq ((lTensor.inverse Q hfg hg) ((LinearMap.lTensor Q g) y)) (Submodule.Quotient.mk y)","decl":"lemma lTensor.inverse_apply (y : Q ⊗[R] N) :\n    (lTensor.inverse Q hfg hg) ((lTensor Q g) y) =\n      Submodule.Quotient.mk (p := (LinearMap.range (lTensor Q f))) y := by\n  rw [lTensor.inverse, lTensor.inverse_of_rightInverse_apply]\n\n"}
{"name":"lTensor.inverse_comp_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\n⊢ Eq ((lTensor.inverse Q hfg hg).comp (LinearMap.lTensor Q g)) (LinearMap.range (LinearMap.lTensor Q f)).mkQ","decl":"lemma lTensor.inverse_comp_lTensor :\n    (lTensor.inverse Q hfg hg).comp (lTensor Q g) =\n      Submodule.mkQ (p := LinearMap.range (lTensor Q f)) := by\n  rw [lTensor.inverse, lTensor.inverse_of_rightInverse_comp_lTensor]\n\n"}
{"name":"lTensor_exact","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\n⊢ Function.Exact ⇑(LinearMap.lTensor Q f) ⇑(LinearMap.lTensor Q g)","decl":"include hfg hg in\n/-- Tensoring an exact pair on the left gives an exact pair -/\ntheorem lTensor_exact : Exact (lTensor Q f) (lTensor Q g) := by\n  rw [exact_iff, ← Submodule.ker_mkQ (p := range (lTensor Q f)),\n    ← lTensor.inverse_comp_lTensor Q hfg hg]\n  apply symm\n  apply LinearMap.ker_comp_of_ker_eq_bot\n  rw [LinearMap.ker_eq_bot]\n  exact (lTensor.equiv Q hfg hg).symm.injective\n\n"}
{"name":"lTensor_mkQ","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nN : Submodule R M\n⊢ Eq (LinearMap.ker (LinearMap.lTensor Q N.mkQ)) (LinearMap.range (LinearMap.lTensor Q N.subtype))","decl":"/-- Right-exactness of tensor product -/\nlemma lTensor_mkQ (N : Submodule R M) :\n    ker (lTensor Q (N.mkQ)) = range (lTensor Q N.subtype) := by\n  rw [← exact_iff]\n  exact lTensor_exact Q (LinearMap.exact_subtype_mkQ N) (Submodule.mkQ_surjective N)\n\n"}
{"name":"rTensor.inverse_of_rightInverse_apply","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nh : P → N\nhgh : Function.RightInverse h ⇑g\ny : TensorProduct R N Q\n⊢ Eq ((rTensor.inverse_of_rightInverse Q hfg hgh) ((LinearMap.rTensor Q g) y)) (Submodule.Quotient.mk y)","decl":"lemma rTensor.inverse_of_rightInverse_apply\n    {h : P → N} (hgh : Function.RightInverse h g) (y : N ⊗[R] Q) :\n    (rTensor.inverse_of_rightInverse Q hfg hgh) ((rTensor Q g) y) =\n      Submodule.Quotient.mk (p := LinearMap.range (rTensor Q f)) y := by\n  simp only [← LinearMap.comp_apply, ← Submodule.mkQ_apply]\n  rw [exact_iff] at hfg\n  apply LinearMap.congr_fun\n  apply TensorProduct.ext'\n  intro n q\n  simp? [rTensor.inverse_of_rightInverse] says\n    simp only [inverse_of_rightInverse, coe_comp, Function.comp_apply, rTensor_tmul,\n      lift.tmul, coe_mk, AddHom.coe_mk, mk_apply, Submodule.mkQ_apply]\n  rw [Submodule.Quotient.eq, ← TensorProduct.sub_tmul]\n  apply le_comap_range_rTensor f\n  rw [← hfg, mem_ker, map_sub, sub_eq_zero, hgh]\n\n"}
{"name":"rTensor.inverse_of_rightInverse_comp_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nh : P → N\nhgh : Function.RightInverse h ⇑g\n⊢ Eq ((rTensor.inverse_of_rightInverse Q hfg hgh).comp (LinearMap.rTensor Q g)) (LinearMap.range (LinearMap.rTensor Q f)).mkQ","decl":"lemma rTensor.inverse_of_rightInverse_comp_rTensor\n    {h : P → N} (hgh : Function.RightInverse h g) :\n    (rTensor.inverse_of_rightInverse Q hfg hgh).comp (rTensor Q g) =\n      Submodule.mkQ (p := LinearMap.range (rTensor Q f)) := by\n  rw [LinearMap.ext_iff]\n  intro y\n  simp only [coe_comp, Function.comp_apply, Submodule.mkQ_apply,\n    rTensor.inverse_of_rightInverse_apply]\n\n"}
{"name":"rTensor.inverse_apply","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\ny : TensorProduct R N Q\n⊢ Eq ((rTensor.inverse Q hfg hg) ((LinearMap.rTensor Q g) y)) (Submodule.Quotient.mk y)","decl":"lemma rTensor.inverse_apply (y : N ⊗[R] Q) :\n    (rTensor.inverse Q hfg hg) ((rTensor Q g) y) =\n      Submodule.Quotient.mk (p := LinearMap.range (rTensor Q f)) y := by\n  rw [rTensor.inverse, rTensor.inverse_of_rightInverse_apply]\n\n"}
{"name":"rTensor.inverse_comp_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\n⊢ Eq ((rTensor.inverse Q hfg hg).comp (LinearMap.rTensor Q g)) (LinearMap.range (LinearMap.rTensor Q f)).mkQ","decl":"lemma rTensor.inverse_comp_rTensor :\n    (rTensor.inverse Q hfg hg).comp (rTensor Q g) =\n      Submodule.mkQ (p := LinearMap.range (rTensor Q f)) := by\n  rw [rTensor.inverse, rTensor.inverse_of_rightInverse_comp_rTensor]\n\n"}
{"name":"rTensor_exact","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\n⊢ Function.Exact ⇑(LinearMap.rTensor Q f) ⇑(LinearMap.rTensor Q g)","decl":"include hfg hg in\n/-- Tensoring an exact pair on the right gives an exact pair -/\ntheorem rTensor_exact : Exact (rTensor Q f) (rTensor Q g) := by\n  rw [rTensor_exact_iff_lTensor_exact]\n  exact lTensor_exact Q hfg hg\n\n"}
{"name":"rTensor_mkQ","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : Type u_5\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nN : Submodule R M\n⊢ Eq (LinearMap.ker (LinearMap.rTensor Q N.mkQ)) (LinearMap.range (LinearMap.rTensor Q N.subtype))","decl":"/-- Right-exactness of tensor product (`rTensor`) -/\nlemma rTensor_mkQ (N : Submodule R M) :\n    ker (rTensor Q (N.mkQ)) = range (rTensor Q N.subtype) := by\n  rw [← exact_iff]\n  exact rTensor_exact Q (LinearMap.exact_subtype_mkQ N) (Submodule.mkQ_surjective N)\n\n"}
{"name":"TensorProduct.map_ker","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : AddCommGroup N\ninst✝⁹ : AddCommGroup P\ninst✝⁸ : Module R M\ninst✝⁷ : Module R N\ninst✝⁶ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\nM' : Type u_6\nN' : Type u_7\nP' : Type u_8\ninst✝⁵ : AddCommGroup M'\ninst✝⁴ : AddCommGroup N'\ninst✝³ : AddCommGroup P'\ninst✝² : Module R M'\ninst✝¹ : Module R N'\ninst✝ : Module R P'\nf' : LinearMap (RingHom.id R) M' N'\ng' : LinearMap (RingHom.id R) N' P'\nhfg' : Function.Exact ⇑f' ⇑g'\nhg' : Function.Surjective ⇑g'\n⊢ Eq (LinearMap.ker (TensorProduct.map g g')) (Max.max (LinearMap.range (LinearMap.lTensor N f')) (LinearMap.range (LinearMap.rTensor N' f)))","decl":"include hg hg' hfg hfg' in\n/-- Kernel of a product map (right-exactness of tensor product) -/\ntheorem TensorProduct.map_ker :\n    ker (TensorProduct.map g g') = range (lTensor N f') ⊔ range (rTensor N' f) := by\n  rw [← lTensor_comp_rTensor]\n  rw [ker_comp]\n  rw [← Exact.linearMap_ker_eq (rTensor_exact N' hfg hg)]\n  rw [← Submodule.comap_map_eq]\n  apply congr_arg₂ _ rfl\n  rw [range_eq_map, ← Submodule.map_comp, rTensor_comp_lTensor,\n    Submodule.map_top]\n  rw [← lTensor_comp_rTensor, range_eq_map, Submodule.map_comp,\n    Submodule.map_top]\n  rw [range_eq_top.mpr (rTensor_surjective M' hg), Submodule.map_top]\n  rw [Exact.linearMap_ker_eq (lTensor_exact P hfg' hg')]\n\n"}
{"name":"Ideal.map_includeLeft_eq","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nA : Type u_2\nB : Type u_3\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nI : Ideal A\n⊢ Eq (Submodule.restrictScalars R (Ideal.map Algebra.TensorProduct.includeLeft I)) (LinearMap.range (LinearMap.rTensor B (Submodule.restrictScalars R I).subtype))","decl":"/-- The ideal of `A ⊗[R] B` generated by `I` is the image of `I ⊗[R] B` -/\nlemma Ideal.map_includeLeft_eq (I : Ideal A) :\n    (I.map (Algebra.TensorProduct.includeLeft : A →ₐ[R] A ⊗[R] B)).restrictScalars R\n      = LinearMap.range (LinearMap.rTensor B (Submodule.subtype (I.restrictScalars R))) := by\n  rw [← Submodule.carrier_inj]\n  apply le_antisymm\n  · intro x\n    simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n      Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem, LinearMap.mem_range]\n    intro hx\n    rw [Ideal.map, ← submodule_span_eq] at hx\n    refine Submodule.span_induction ?_ ?_ ?_ ?_ hx\n    · intro x\n      simp only [includeLeft_apply, Set.mem_image, SetLike.mem_coe]\n      rintro ⟨y, hy, rfl⟩\n      use ⟨y, hy⟩ ⊗ₜ[R] 1\n      rfl\n    · use 0\n      simp only [map_zero]\n    · rintro x y - - ⟨x, hx, rfl⟩ ⟨y, hy, rfl⟩\n      use x + y\n      simp only [map_add]\n    · rintro a x - ⟨x, hx, rfl⟩\n      induction a with\n      | zero =>\n        use 0\n        simp only [map_zero, smul_eq_mul, zero_mul]\n      | tmul a b =>\n        induction x with\n        | zero =>\n          use 0\n          simp only [map_zero, smul_eq_mul, mul_zero]\n        | tmul x y =>\n          use (a • x) ⊗ₜ[R] (b * y)\n          simp only [LinearMap.lTensor_tmul, Submodule.coe_subtype, smul_eq_mul, tmul_mul_tmul]\n          with_unfolding_all rfl\n        | add x y hx hy =>\n          obtain ⟨x', hx'⟩ := hx\n          obtain ⟨y', hy'⟩ := hy\n          use x' + y'\n          simp only [map_add, hx', smul_add, hy']\n      | add a b ha hb =>\n        obtain ⟨x', ha'⟩ := ha\n        obtain ⟨y', hb'⟩ := hb\n        use x' + y'\n        simp only [map_add, ha', add_smul, hb']\n\n  · rintro x ⟨y, rfl⟩\n    induction y with\n    | zero =>\n        rw [map_zero]\n        apply zero_mem\n    | tmul a b =>\n        simp only [LinearMap.rTensor_tmul, Submodule.coe_subtype]\n        suffices (a : A) ⊗ₜ[R] b = ((1 : A) ⊗ₜ[R] b) * ((a : A) ⊗ₜ[R] (1 : B)) by\n          simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n            Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem]\n          rw [this]\n          apply Ideal.mul_mem_left\n          -- Note: adding `includeLeft` as a hint fixes a timeout https://github.com/leanprover-community/mathlib4/pull/8386\n          apply Ideal.mem_map_of_mem includeLeft\n          exact Submodule.coe_mem a\n        simp only [Submodule.coe_restrictScalars, Algebra.TensorProduct.tmul_mul_tmul,\n          mul_one, one_mul]\n    | add x y hx hy =>\n        rw [map_add]\n        apply Submodule.add_mem _ hx hy\n\n"}
{"name":"Ideal.map_includeRight_eq","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nA : Type u_2\nB : Type u_3\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nI : Ideal B\n⊢ Eq (Submodule.restrictScalars R (Ideal.map Algebra.TensorProduct.includeRight I)) (LinearMap.range (LinearMap.lTensor A (Submodule.restrictScalars R I).subtype))","decl":"/-- The ideal of `A ⊗[R] B` generated by `I` is the image of `A ⊗[R] I` -/\nlemma Ideal.map_includeRight_eq (I : Ideal B) :\n    (I.map (Algebra.TensorProduct.includeRight : B →ₐ[R] A ⊗[R] B)).restrictScalars R\n      = LinearMap.range (LinearMap.lTensor A (Submodule.subtype (I.restrictScalars R))) := by\n  rw [← Submodule.carrier_inj]\n  apply le_antisymm\n  · intro x\n    simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n      Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem, LinearMap.mem_range]\n    intro hx\n    rw [Ideal.map, ← submodule_span_eq] at hx\n    refine Submodule.span_induction ?_ ?_ ?_ ?_ hx\n    · intro x\n      simp only [includeRight_apply, Set.mem_image, SetLike.mem_coe]\n      rintro ⟨y, hy, rfl⟩\n      use 1 ⊗ₜ[R] ⟨y, hy⟩\n      rfl\n    · use 0\n      simp only [map_zero]\n    · rintro x y - - ⟨x, hx, rfl⟩ ⟨y, hy, rfl⟩\n      use x + y\n      simp only [map_add]\n    · rintro a x - ⟨x, hx, rfl⟩\n      induction a with\n      | zero =>\n        use 0\n        simp only [map_zero, smul_eq_mul, zero_mul]\n      | tmul a b =>\n        induction x with\n        | zero =>\n          use 0\n          simp only [map_zero, smul_eq_mul, mul_zero]\n        | tmul x y =>\n          use (a * x) ⊗ₜ[R] (b •y)\n          simp only [LinearMap.lTensor_tmul, Submodule.coe_subtype, smul_eq_mul, tmul_mul_tmul]\n          rfl\n        | add x y hx hy =>\n          obtain ⟨x', hx'⟩ := hx\n          obtain ⟨y', hy'⟩ := hy\n          use x' + y'\n          simp only [map_add, hx', smul_add, hy']\n      | add a b ha hb =>\n        obtain ⟨x', ha'⟩ := ha\n        obtain ⟨y', hb'⟩ := hb\n        use x' + y'\n        simp only [map_add, ha', add_smul, hb']\n\n  · rintro x ⟨y, rfl⟩\n    induction y with\n    | zero =>\n        rw [map_zero]\n        apply zero_mem\n    | tmul a b =>\n        simp only [LinearMap.lTensor_tmul, Submodule.coe_subtype]\n        suffices a ⊗ₜ[R] (b : B) = (a ⊗ₜ[R] (1 : B)) * ((1 : A) ⊗ₜ[R] (b : B)) by\n          rw [this]\n          simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n            Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem]\n          apply Ideal.mul_mem_left\n          -- Note: adding `includeRight` as a hint fixes a timeout https://github.com/leanprover-community/mathlib4/pull/8386\n          apply Ideal.mem_map_of_mem includeRight\n          exact Submodule.coe_mem b\n        simp only [Submodule.coe_restrictScalars, Algebra.TensorProduct.tmul_mul_tmul,\n          mul_one, one_mul]\n    | add x y hx hy =>\n        rw [map_add]\n        apply Submodule.add_mem _ hx hy\n\n-- Now, we can prove the right exactness properties of the tensor product,\n-- in its versions for algebras\n\n"}
{"name":"Algebra.TensorProduct.lTensor_ker","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_4\ninst✝⁶ : CommRing R\nA : Type u_5\nC : Type u_7\nD : Type u_8\ninst✝⁵ : Ring A\ninst✝⁴ : Ring C\ninst✝³ : Ring D\ninst✝² : Algebra R A\ninst✝¹ : Algebra R C\ninst✝ : Algebra R D\ng : AlgHom R C D\nhg : Function.Surjective ⇑g\n⊢ Eq (RingHom.ker (Algebra.TensorProduct.map (AlgHom.id R A) g)) (Ideal.map Algebra.TensorProduct.includeRight (RingHom.ker g))","decl":"/-- If `g` is surjective, then the kernel of `(id A) ⊗ g` is generated by the kernel of `g` -/\nlemma Algebra.TensorProduct.lTensor_ker (hg : Function.Surjective g) :\n    RingHom.ker (map (AlgHom.id R A) g) =\n      (RingHom.ker g).map (Algebra.TensorProduct.includeRight : C →ₐ[R] A ⊗[R] C) := by\n  rw [← Submodule.restrictScalars_inj R]\n  have : (RingHom.ker (map (AlgHom.id R A) g)).restrictScalars R =\n    LinearMap.ker (LinearMap.lTensor A (AlgHom.toLinearMap g)) := rfl\n  rw [this, Ideal.map_includeRight_eq]\n  rw [(lTensor_exact A g.toLinearMap.exact_subtype_ker_map hg).linearMap_ker_eq]\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.rTensor_ker","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_4\ninst✝⁶ : CommRing R\nA : Type u_5\nB : Type u_6\nC : Type u_7\ninst✝⁵ : Ring A\ninst✝⁴ : Ring B\ninst✝³ : Ring C\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\nf : AlgHom R A B\nhf : Function.Surjective ⇑f\n⊢ Eq (RingHom.ker (Algebra.TensorProduct.map f (AlgHom.id R C))) (Ideal.map Algebra.TensorProduct.includeLeft (RingHom.ker f))","decl":"/-- If `f` is surjective, then the kernel of `f ⊗ (id B)` is generated by the kernel of `f` -/\nlemma Algebra.TensorProduct.rTensor_ker (hf : Function.Surjective f) :\n    RingHom.ker (map f (AlgHom.id R C)) =\n      (RingHom.ker f).map (Algebra.TensorProduct.includeLeft : A →ₐ[R] A ⊗[R] C) := by\n  rw [← Submodule.restrictScalars_inj R]\n  have : (RingHom.ker (map f (AlgHom.id R C))).restrictScalars R =\n    LinearMap.ker (LinearMap.rTensor C (AlgHom.toLinearMap f)) := rfl\n  rw [this, Ideal.map_includeLeft_eq]\n  rw [(rTensor_exact C f.toLinearMap.exact_subtype_ker_map hf).linearMap_ker_eq]\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.map_ker","module":"Mathlib.LinearAlgebra.TensorProduct.RightExactness","initialProofState":"R : Type u_4\ninst✝⁸ : CommRing R\nA : Type u_5\nB : Type u_6\nC : Type u_7\nD : Type u_8\ninst✝⁷ : Ring A\ninst✝⁶ : Ring B\ninst✝⁵ : Ring C\ninst✝⁴ : Ring D\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : Algebra R C\ninst✝ : Algebra R D\nf : AlgHom R A B\ng : AlgHom R C D\nhf : Function.Surjective ⇑f\nhg : Function.Surjective ⇑g\n⊢ Eq (RingHom.ker (Algebra.TensorProduct.map f g)) (Max.max (Ideal.map Algebra.TensorProduct.includeLeft (RingHom.ker f)) (Ideal.map Algebra.TensorProduct.includeRight (RingHom.ker g)))","decl":"/-- If `f` and `g` are surjective morphisms of algebras, then\n  the kernel of `Algebra.TensorProduct.map f g` is generated by the kernels of `f` and `g` -/\ntheorem Algebra.TensorProduct.map_ker (hf : Function.Surjective f) (hg : Function.Surjective g) :\n    RingHom.ker (map f g) =\n      (RingHom.ker f).map (Algebra.TensorProduct.includeLeft : A →ₐ[R] A ⊗[R] C) ⊔\n        (RingHom.ker g).map (Algebra.TensorProduct.includeRight : C →ₐ[R] A ⊗[R] C) := by\n  -- rewrite map f g as the composition of two maps\n  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl\n  rw [this]\n  -- this needs some rewriting to RingHom\n  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]\n  rw [← RingHom.comap_ker]\n  simp only [← AlgHom.coe_ker]\n  -- apply one step of exactness\n  rw [← Algebra.TensorProduct.lTensor_ker _ hg, RingHom.ker_eq_comap_bot (map (AlgHom.id R A) g)]\n  rw [← Ideal.comap_map_of_surjective (map (AlgHom.id R A) g) (LinearMap.lTensor_surjective A hg)]\n  -- apply the other step of exactness\n  rw [Algebra.TensorProduct.rTensor_ker _ hf]\n  apply congr_arg₂ _ rfl\n  simp only [AlgHom.coe_ideal_map, Ideal.map_map]\n  rw [← AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]\n  rfl\n\n"}
