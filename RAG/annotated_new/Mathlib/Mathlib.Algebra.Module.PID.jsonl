{"name":"Submodule.isSemisimple_torsionBy_of_irreducible","module":"Mathlib.Algebra.Module.PID","initialProofState":"R : Type u\ninst✝³ : CommRing R\ninst✝² : IsPrincipalIdealRing R\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\na : R\nh : Irreducible a\n⊢ IsSemisimpleModule R (Subtype fun x => Membership.mem (Submodule.torsionBy R M a) x)","decl":"theorem Submodule.isSemisimple_torsionBy_of_irreducible {a : R} (h : Irreducible a) :\n    IsSemisimpleModule R (torsionBy R M a) :=\n  haveI := PrincipalIdealRing.isMaximal_of_irreducible h\n  letI := Ideal.Quotient.field (R ∙ a)\n  (submodule_torsionBy_orderIso a).complementedLattice\n\n"}
{"name":"Submodule.isInternal_prime_power_torsion_of_pid","module":"Mathlib.Algebra.Module.PID","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : IsPrincipalIdealRing R\nM : Type v\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : IsDomain R\ninst✝¹ : DecidableEq (Ideal R)\ninst✝ : Module.Finite R M\nhM : Module.IsTorsion R M\n⊢ DirectSum.IsInternal fun p => Submodule.torsionBy R M (HPow.hPow (Submodule.IsPrincipal.generator ↑p) (Multiset.count (↑p) (UniqueFactorizationMonoid.factors Top.top.annihilator)))","decl":"/-- A finitely generated torsion module over a PID is an internal direct sum of its\n`p i ^ e i`-torsion submodules for some primes `p i` and numbers `e i`. -/\ntheorem Submodule.isInternal_prime_power_torsion_of_pid [DecidableEq (Ideal R)] [Module.Finite R M]\n    (hM : Module.IsTorsion R M) :\n    DirectSum.IsInternal fun p : (factors (⊤ : Submodule R M).annihilator).toFinset =>\n      torsionBy R M\n        (IsPrincipal.generator (p : Ideal R) ^\n          (factors (⊤ : Submodule R M).annihilator).count ↑p) := by\n  convert isInternal_prime_power_torsion hM\n  ext p : 1\n  rw [← torsionBySet_span_singleton_eq, Ideal.submodule_span_eq, ← Ideal.span_singleton_pow,\n    Ideal.span_singleton_generator]\n\n"}
{"name":"Submodule.exists_isInternal_prime_power_torsion_of_pid","module":"Mathlib.Algebra.Module.PID","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\ninst✝⁴ : IsPrincipalIdealRing R\nM : Type v\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsDomain R\ninst✝ : Module.Finite R M\nhM : Module.IsTorsion R M\n⊢ Exists fun ι => Exists fun x => Exists fun x => Exists fun p => Exists fun x_1 => Exists fun e => DirectSum.IsInternal fun i => Submodule.torsionBy R M (HPow.hPow (p i) (e i))","decl":"/-- A finitely generated torsion module over a PID is an internal direct sum of its\n`p i ^ e i`-torsion submodules for some primes `p i` and numbers `e i`. -/\ntheorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]\n    (hM : Module.IsTorsion R M) :\n    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)\n        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by\n  classical\n  refine ⟨_, ?_, _, _, ?_, _, Submodule.isInternal_prime_power_torsion_of_pid hM⟩\n  · exact Finset.fintypeCoeSort _\n  · rintro ⟨p, hp⟩\n    have hP := prime_of_factor p (Multiset.mem_toFinset.mp hp)\n    haveI := Ideal.isPrime_of_prime hP\n    exact (IsPrincipal.prime_generator_of_isPrime p hP.ne_zero).irreducible\n\n"}
{"name":"Ideal.torsionOf_eq_span_pow_pOrder","module":"Mathlib.Algebra.Module.PID","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsPrincipalIdealRing R\nM : Type v\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsDomain R\np : R\nhp : Irreducible p\nhM : Module.IsTorsion' M (Subtype fun x => Membership.mem (Submonoid.powers p) x)\ndec : (x : M) → Decidable (Eq x 0)\nx : M\n⊢ Eq (Ideal.torsionOf R M x) (Ideal.span (Singleton.singleton (HPow.hPow p (Submodule.pOrder hM x))))","decl":"theorem _root_.Ideal.torsionOf_eq_span_pow_pOrder (x : M) :\n    torsionOf R M x = span {p ^ pOrder hM x} := by\n  classical\n  dsimp only [pOrder]\n  rw [← (torsionOf R M x).span_singleton_generator, Ideal.span_singleton_eq_span_singleton, ←\n    Associates.mk_eq_mk_iff_associated, Associates.mk_pow]\n  have prop :\n    (fun n : ℕ => p ^ n • x = 0) = fun n : ℕ =>\n      (Associates.mk <| generator <| torsionOf R M x) ∣ Associates.mk p ^ n := by\n    ext n; rw [← Associates.mk_pow, Associates.mk_dvd_mk, ← mem_iff_generator_dvd]; rfl\n  have := (isTorsion'_powers_iff p).mp hM x; rw [prop] at this\n  convert Associates.eq_pow_find_of_dvd_irreducible_pow (Associates.irreducible_mk.mpr hp)\n    this.choose_spec\n\n"}
{"name":"Module.p_pow_smul_lift","module":"Mathlib.Algebra.Module.PID","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsPrincipalIdealRing R\nM : Type v\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsDomain R\np : R\nhp : Irreducible p\nhM : Module.IsTorsion' M (Subtype fun x => Membership.mem (Submonoid.powers p) x)\ndec : (x : M) → Decidable (Eq x 0)\nx y : M\nk : Nat\nhM' : Module.IsTorsionBy R M (HPow.hPow p (Submodule.pOrder hM y))\nh : Membership.mem (Submodule.span R (Singleton.singleton y)) (HSMul.hSMul (HPow.hPow p k) x)\n⊢ Exists fun a => Eq (HSMul.hSMul (HPow.hPow p k) x) (HSMul.hSMul (HPow.hPow p k) (HSMul.hSMul a y))","decl":"theorem p_pow_smul_lift {x y : M} {k : ℕ} (hM' : Module.IsTorsionBy R M (p ^ pOrder hM y))\n    (h : p ^ k • x ∈ R ∙ y) : ∃ a : R, p ^ k • x = p ^ k • a • y := by\n  -- Porting note: needed to make `smul_smul` work below.\n  letI : MulAction R M := MulActionWithZero.toMulAction\n  by_cases hk : k ≤ pOrder hM y\n  · let f :=\n      ((R ∙ p ^ (pOrder hM y - k) * p ^ k).quotEquivOfEq _ ?_).trans\n        (quotTorsionOfEquivSpanSingleton R M y)\n    · have : f.symm ⟨p ^ k • x, h⟩ ∈\n          R ∙ Ideal.Quotient.mk (R ∙ p ^ (pOrder hM y - k) * p ^ k) (p ^ k) := by\n        rw [← Quotient.torsionBy_eq_span_singleton, mem_torsionBy_iff, ← f.symm.map_smul]\n        · convert f.symm.map_zero; ext\n          rw [coe_smul_of_tower, coe_mk, coe_zero, smul_smul, ← pow_add, Nat.sub_add_cancel hk,\n            @hM' x]\n        · exact mem_nonZeroDivisors_of_ne_zero (pow_ne_zero _ hp.ne_zero)\n      rw [Submodule.mem_span_singleton] at this; obtain ⟨a, ha⟩ := this; use a\n      rw [f.eq_symm_apply, ← Ideal.Quotient.mk_eq_mk, ← Quotient.mk_smul] at ha\n      dsimp only [smul_eq_mul, LinearEquiv.trans_apply, Submodule.quotEquivOfEq_mk,\n        quotTorsionOfEquivSpanSingleton_apply_mk] at ha\n      rw [smul_smul, mul_comm]; exact congr_arg ((↑) : _ → M) ha.symm\n    · symm; convert Ideal.torsionOf_eq_span_pow_pOrder hp hM y\n      rw [← pow_add, Nat.sub_add_cancel hk]\n  · use 0\n    rw [zero_smul, smul_zero, ← Nat.sub_add_cancel (le_of_not_le hk), pow_add, mul_smul, hM',\n      smul_zero]\n\n"}
{"name":"Module.exists_smul_eq_zero_and_mk_eq","module":"Mathlib.Algebra.Module.PID","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsPrincipalIdealRing R\nM : Type v\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsDomain R\np : R\nhp : Irreducible p\nhM : Module.IsTorsion' M (Subtype fun x => Membership.mem (Submonoid.powers p) x)\ndec : (x : M) → Decidable (Eq x 0)\nz : M\nhz : Module.IsTorsionBy R M (HPow.hPow p (Submodule.pOrder hM z))\nk : Nat\nf : LinearMap (RingHom.id R) (HasQuotient.Quotient R (Submodule.span R (Singleton.singleton (HPow.hPow p k)))) (HasQuotient.Quotient M (Submodule.span R (Singleton.singleton z)))\n⊢ Exists fun x => And (Eq (HSMul.hSMul (HPow.hPow p k) x) 0) (Eq (Submodule.Quotient.mk x) (f 1))","decl":"theorem exists_smul_eq_zero_and_mk_eq {z : M} (hz : Module.IsTorsionBy R M (p ^ pOrder hM z))\n    {k : ℕ} (f : (R ⧸ R ∙ p ^ k) →ₗ[R] M ⧸ R ∙ z) :\n    ∃ x : M, p ^ k • x = 0 ∧ Submodule.Quotient.mk (p := span R {z}) x = f 1 := by\n  have f1 := mk_surjective (R ∙ z) (f 1)\n  have : p ^ k • f1.choose ∈ R ∙ z := by\n    rw [← Quotient.mk_eq_zero, mk_smul, f1.choose_spec, ← f.map_smul]\n    convert f.map_zero; change _ • Submodule.Quotient.mk _ = _\n    rw [← mk_smul, Quotient.mk_eq_zero, Algebra.id.smul_eq_mul, mul_one]\n    exact Submodule.mem_span_singleton_self _\n  obtain ⟨a, ha⟩ := p_pow_smul_lift hp hM hz this\n  refine ⟨f1.choose - a • z, by rw [smul_sub, sub_eq_zero, ha], ?_⟩\n  rw [mk_sub, mk_smul, (Quotient.mk_eq_zero _).mpr <| Submodule.mem_span_singleton_self _,\n    smul_zero, sub_zero, f1.choose_spec]\n\n"}
{"name":"Module.torsion_by_prime_power_decomposition","module":"Mathlib.Algebra.Module.PID","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsPrincipalIdealRing R\nN : Type (max u v)\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsDomain R\np : R\nhp : Irreducible p\nhN : Module.IsTorsion' N (Subtype fun x => Membership.mem (Submonoid.powers p) x)\nh' : Module.Finite R N\n⊢ Exists fun d => Exists fun k => Nonempty (LinearEquiv (RingHom.id R) N (DirectSum (Fin d) fun i => HasQuotient.Quotient R (Submodule.span R (Singleton.singleton (HPow.hPow p (k i))))))","decl":"/-- A finitely generated `p ^ ∞`-torsion module over a PID is isomorphic to a direct sum of some\n  `R ⧸ R ∙ (p ^ e i)` for some `e i`. -/\ntheorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))\n    [h' : Module.Finite R N] :\n    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) := by\n  obtain ⟨d, s, hs⟩ := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'\n  induction' d with d IH generalizing N\n  · -- Porting note: was `use fun i => finZeroElim i`\n    use finZeroElim\n    rw [Set.range_eq_empty, Submodule.span_empty] at hs\n    haveI : Unique N :=\n      ⟨⟨0⟩, fun x => by dsimp; rw [← Submodule.mem_bot R, hs]; exact Submodule.mem_top⟩\n    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))\n    exact ⟨0⟩\n  · have : ∀ x : N, Decidable (x = 0) := fun _ => by classical infer_instance\n    obtain ⟨j, hj⟩ := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs\n    let s' : Fin d → N ⧸ R ∙ s j := Submodule.Quotient.mk ∘ s ∘ j.succAbove\n    -- Porting note(https://github.com/leanprover-community/mathlib4/issues/5732):\n    -- `obtain` doesn't work with placeholders.\n    have := IH ?_ s' ?_\n    · obtain ⟨k, ⟨f⟩⟩ := this\n      clear IH\n      have : ∀ i : Fin d,\n          ∃ x : N, p ^ k i • x = 0 ∧ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by\n        intro i\n        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)\n        obtain ⟨x, h0, h1⟩ := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ⟨x, h0, ?_⟩; rw [h1]\n        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,\n          Function.comp_apply]\n      refine ⟨?_, ⟨?_⟩⟩\n      · exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ℕ)) (finSuccEquiv d a)\n      · refine (((lequivProdOfRightSplitExact\n          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)\n          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)\n              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ⧸ _ →ₗ[R] _)).comp\n            ULift.moduleEquiv.toLinearMap) (R ∙ s j).injective_subtype ?_ ?_).symm.trans\n          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans\n          (quotEquivOfEq (torsionOf R N (s j)) _\n          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod\n          (ULift.moduleEquiv))).trans\n          (@DirectSum.lequivProdDirectSum R _ _\n          (fun i => R ⧸ R ∙ p ^ @Option.rec _ (fun _ => ℕ) (pOrder hN <| s j) k i) _ _).symm).trans\n          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)\n        · rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]\n        · rw [← f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,\n            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ← LinearMap.comp_assoc,\n            ← LinearMap.comp_assoc]\n          suffices (f.toLinearMap.comp (R ∙ s j).mkQ).comp _ = LinearMap.id by\n            rw [this, LinearMap.id_comp]\n          ext i : 3\n          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]\n          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,\n            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,\n            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]\n    · exact (mk_surjective _).forall.mpr fun x =>\n        ⟨(@hN x).choose, by rw [← Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]⟩\n    · have hs' := congr_arg (Submodule.map <| mkQ <| R ∙ s j) hs\n      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'\n      simp only [s']; rw [← Function.comp_assoc, Set.range_comp (_ ∘ s), Fin.range_succAbove]\n      rw [← Set.range_comp, ← Set.insert_image_compl_eq_range _ j, Function.comp_apply,\n        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'\n      exact hs'\n\n"}
{"name":"Module.equiv_directSum_of_isTorsion","module":"Mathlib.Algebra.Module.PID","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsPrincipalIdealRing R\nN : Type (max u v)\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsDomain R\nh' : Module.Finite R N\nhN : Module.IsTorsion R N\n⊢ Exists fun ι => Exists fun x => Exists fun p => Exists fun x => Exists fun e => Nonempty (LinearEquiv (RingHom.id R) N (DirectSum ι fun i => HasQuotient.Quotient R (Submodule.span R (Singleton.singleton (HPow.hPow (p i) (e i))))))","decl":"/-- A finitely generated torsion module over a PID is isomorphic to a direct sum of some\n  `R ⧸ R ∙ (p i ^ e i)` where the `p i ^ e i` are prime powers. -/\ntheorem equiv_directSum_of_isTorsion [h' : Module.Finite R N] (hN : Module.IsTorsion R N) :\n    ∃ (ι : Type u) (_ : Fintype ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i) (e : ι → ℕ),\n      Nonempty <| N ≃ₗ[R] ⨁ i : ι, R ⧸ R ∙ p i ^ e i := by\n  obtain ⟨I, fI, _, p, hp, e, h⟩ := Submodule.exists_isInternal_prime_power_torsion_of_pid hN\n  haveI := fI\n  have :\n    ∀ i,\n      ∃ (d : ℕ) (k : Fin d → ℕ),\n        Nonempty <| torsionBy R N (p i ^ e i) ≃ₗ[R] ⨁ j, R ⧸ R ∙ p i ^ k j := by\n    haveI := fun i => isNoetherian_submodule' (torsionBy R N <| p i ^ e i)\n    exact fun i =>\n      torsion_by_prime_power_decomposition.{u, v} (hp i)\n        ((isTorsion'_powers_iff <| p i).mpr fun x => ⟨e i, smul_torsionBy _ _⟩)\n  classical\n  refine\n    ⟨Σ i, Fin (this i).choose, inferInstance, fun ⟨i, _⟩ => p i, fun ⟨i, _⟩ => hp i, fun ⟨i, j⟩ =>\n      (this i).choose_spec.choose j,\n      ⟨(LinearEquiv.ofBijective (DirectSum.coeLinearMap _) h).symm.trans <|\n          (DFinsupp.mapRange.linearEquiv fun i => (this i).choose_spec.choose_spec.some).trans <|\n            (DirectSum.sigmaLcurryEquiv R).symm.trans\n              (DFinsupp.mapRange.linearEquiv fun i => quotEquivOfEq _ _ ?_)⟩⟩\n  cases' i with i j\n  simp only\n\n"}
{"name":"Module.equiv_free_prod_directSum","module":"Mathlib.Algebra.Module.PID","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsPrincipalIdealRing R\nN : Type (max u v)\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : IsDomain R\nh' : Module.Finite R N\n⊢ Exists fun n => Exists fun ι => Exists fun x => Exists fun p => Exists fun x => Exists fun e => Nonempty (LinearEquiv (RingHom.id R) N (Prod (Finsupp (Fin n) R) (DirectSum ι fun i => HasQuotient.Quotient R (Submodule.span R (Singleton.singleton (HPow.hPow (p i) (e i)))))))","decl":"/-- **Structure theorem of finitely generated modules over a PID** : A finitely generated\n  module over a PID is isomorphic to the product of a free module and a direct sum of some\n  `R ⧸ R ∙ (p i ^ e i)` where the `p i ^ e i` are prime powers. -/\ntheorem equiv_free_prod_directSum [h' : Module.Finite R N] :\n    ∃ (n : ℕ) (ι : Type u) (_ : Fintype ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i) (e : ι → ℕ),\n      Nonempty <| N ≃ₗ[R] (Fin n →₀ R) × ⨁ i : ι, R ⧸ R ∙ p i ^ e i := by\n  haveI := isNoetherian_submodule' (torsion R N)\n  haveI := Module.Finite.of_surjective _ (torsion R N).mkQ_surjective\n  obtain ⟨I, fI, p, hp, e, ⟨h⟩⟩ :=\n    equiv_directSum_of_isTorsion.{u, v} (@torsion_isTorsion R N _ _ _)\n  obtain ⟨n, ⟨g⟩⟩ := @Module.basisOfFiniteTypeTorsionFree' R _ (N ⧸ torsion R N) _ _ _ _ _ _\n  haveI : Module.Projective R (N ⧸ torsion R N) := Module.Projective.of_basis ⟨g⟩\n  obtain ⟨f, hf⟩ := Module.projective_lifting_property _ LinearMap.id (torsion R N).mkQ_surjective\n  refine\n    ⟨n, I, fI, p, hp, e,\n      ⟨(lequivProdOfRightSplitExact (torsion R N).injective_subtype ?_ hf).symm.trans <|\n          (h.prod g).trans <| LinearEquiv.prodComm.{u, u} R _ (Fin n →₀ R) ⟩⟩\n  rw [range_subtype, ker_mkQ]\n\n"}
