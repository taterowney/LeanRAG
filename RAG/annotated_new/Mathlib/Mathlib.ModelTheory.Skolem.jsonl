{"name":"FirstOrder.Language.skolem₁_Functions","module":"Mathlib.ModelTheory.Skolem","initialProofState":"L : FirstOrder.Language\nn : Nat\n⊢ Eq (L.skolem₁.Functions n) (L.BoundedFormula Empty (HAdd.hAdd n 1))","decl":"/-- A language consisting of Skolem functions for another language.\nCalled `skolem₁` because it is the first step in building a Skolemization of a language. -/\n@[simps]\ndef skolem₁ : Language :=\n  ⟨fun n => L.BoundedFormula Empty (n + 1), fun _ => Empty⟩\n\n"}
{"name":"FirstOrder.Language.skolem₁_Relations","module":"Mathlib.ModelTheory.Skolem","initialProofState":"L : FirstOrder.Language\nx✝ : Nat\n⊢ Eq (L.skolem₁.Relations x✝) Empty","decl":"/-- A language consisting of Skolem functions for another language.\nCalled `skolem₁` because it is the first step in building a Skolemization of a language. -/\n@[simps]\ndef skolem₁ : Language :=\n  ⟨fun n => L.BoundedFormula Empty (n + 1), fun _ => Empty⟩\n\n"}
{"name":"FirstOrder.Language.card_functions_sum_skolem₁","module":"Mathlib.ModelTheory.Skolem","initialProofState":"L : FirstOrder.Language\n⊢ Eq (Cardinal.mk (Sigma fun n => (L.sum L.skolem₁).Functions n)) (Cardinal.mk (Sigma fun n => L.BoundedFormula Empty (HAdd.hAdd n 1)))","decl":"theorem card_functions_sum_skolem₁ :\n    #(Σ n, (L.sum L.skolem₁).Functions n) = #(Σ n, L.BoundedFormula Empty (n + 1)) := by\n  simp only [card_functions_sum, skolem₁_Functions, mk_sigma, sum_add_distrib']\n  conv_lhs => enter [2, 1, i]; rw [lift_id'.{u, v}]\n  rw [add_comm, add_eq_max, max_eq_left]\n  · refine sum_le_sum _ _ fun n => ?_\n    rw [← lift_le.{_, max u v}, lift_lift, lift_mk_le.{v}]\n    refine ⟨⟨fun f => (func f default).bdEqual (func f default), fun f g h => ?_⟩⟩\n    rcases h with ⟨rfl, ⟨rfl⟩⟩\n    rfl\n  · rw [← mk_sigma]\n    exact infinite_iff.1 (Infinite.of_injective (fun n => ⟨n, ⊥⟩) fun x y xy =>\n      (Sigma.mk.inj_iff.1 xy).1)\n\n"}
{"name":"FirstOrder.Language.card_functions_sum_skolem₁_le","module":"Mathlib.ModelTheory.Skolem","initialProofState":"L : FirstOrder.Language\n⊢ LE.le (Cardinal.mk (Sigma fun n => (L.sum L.skolem₁).Functions n)) (Max.max Cardinal.aleph0 L.card)","decl":"theorem card_functions_sum_skolem₁_le : #(Σ n, (L.sum L.skolem₁).Functions n) ≤ max ℵ₀ L.card := by\n  rw [card_functions_sum_skolem₁]\n  trans #(Σ n, L.BoundedFormula Empty n)\n  · exact\n      ⟨⟨Sigma.map Nat.succ fun _ => id,\n          Nat.succ_injective.sigma_map fun _ => Function.injective_id⟩⟩\n  · refine _root_.trans BoundedFormula.card_le (lift_le.{max u v}.1 ?_)\n    simp only [mk_empty, lift_zero, lift_uzero, zero_add]\n    rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.skolem₁_reduct_isElementary","module":"Mathlib.ModelTheory.Skolem","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : Nonempty M\ninst✝ : L.Structure M\nS : (L.sum L.skolem₁).Substructure M\n⊢ (FirstOrder.Language.LHom.sumInl.substructureReduct S).IsElementary","decl":"theorem skolem₁_reduct_isElementary (S : (L.sum L.skolem₁).Substructure M) :\n    (LHom.sumInl.substructureReduct S).IsElementary := by\n  apply (LHom.sumInl.substructureReduct S).isElementary_of_exists\n  intro n φ x a h\n  let φ' : (L.sum L.skolem₁).Functions n := LHom.sumInr.onFunction φ\n  use ⟨funMap φ' ((↑) ∘ x), ?_⟩\n  · exact Classical.epsilon_spec (p := fun a => BoundedFormula.Realize φ default\n          (Fin.snoc (Subtype.val ∘ x) a)) ⟨a, h⟩\n  · exact S.fun_mem (LHom.sumInr.onFunction φ) ((↑) ∘ x) (by\n      exact fun i => (x i).2)\n\n"}
{"name":"FirstOrder.Language.Substructure.coeSort_elementarySkolem₁Reduct","module":"Mathlib.ModelTheory.Skolem","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : Nonempty M\ninst✝ : L.Structure M\nS : (L.sum L.skolem₁).Substructure M\n⊢ Eq (Subtype fun x => Membership.mem S.elementarySkolem₁Reduct x) (Subtype fun x => Membership.mem S x)","decl":"theorem coeSort_elementarySkolem₁Reduct (S : (L.sum L.skolem₁).Substructure M) :\n    (S.elementarySkolem₁Reduct : Type w) = S :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Substructure.elementarySkolem₁Reduct.instSmall","module":"Mathlib.ModelTheory.Skolem","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : Nonempty M\ninst✝ : L.Structure M\n⊢ Small.{max u v, w} (Subtype fun x => Membership.mem Bot.bot.elementarySkolem₁Reduct x)","decl":"instance Substructure.elementarySkolem₁Reduct.instSmall :\n    Small.{max u v} (⊥ : (L.sum L.skolem₁).Substructure M).elementarySkolem₁Reduct := by\n  rw [coeSort_elementarySkolem₁Reduct]\n  infer_instance\n\n"}
{"name":"FirstOrder.Language.exists_small_elementarySubstructure","module":"Mathlib.ModelTheory.Skolem","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : Nonempty M\ninst✝ : L.Structure M\n⊢ Exists fun S => Small.{max u v, w} (Subtype fun x => Membership.mem S x)","decl":"theorem exists_small_elementarySubstructure : ∃ S : L.ElementarySubstructure M, Small.{max u v} S :=\n  ⟨Substructure.elementarySkolem₁Reduct ⊥, inferInstance⟩\n\n"}
{"name":"FirstOrder.Language.exists_elementarySubstructure_card_eq","module":"Mathlib.ModelTheory.Skolem","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : Nonempty M\ninst✝ : L.Structure M\ns : Set M\nκ : Cardinal.{w'}\nh1 : LE.le Cardinal.aleph0 κ\nh2 : LE.le (Cardinal.lift.{w', w} (Cardinal.mk ↑s)) (Cardinal.lift.{w, w'} κ)\nh3 : LE.le (Cardinal.lift.{w', max u v} L.card) (Cardinal.lift.{max u v, w'} κ)\nh4 : LE.le (Cardinal.lift.{w, w'} κ) (Cardinal.lift.{w', w} (Cardinal.mk M))\n⊢ Exists fun S => And (HasSubset.Subset s ↑S) (Eq (Cardinal.lift.{w', w} (Cardinal.mk (Subtype fun x => Membership.mem S x))) (Cardinal.lift.{w, w'} κ))","decl":"/-- The **Downward Löwenheim–Skolem theorem** :\n  If `s` is a set in an `L`-structure `M` and `κ` an infinite cardinal such that\n  `max (#s, L.card) ≤ κ` and `κ ≤ # M`, then `M` has an elementary substructure containing `s` of\n  cardinality `κ`. -/\ntheorem exists_elementarySubstructure_card_eq (s : Set M) (κ : Cardinal.{w'}) (h1 : ℵ₀ ≤ κ)\n    (h2 : Cardinal.lift.{w'} #s ≤ Cardinal.lift.{w} κ)\n    (h3 : Cardinal.lift.{w'} L.card ≤ Cardinal.lift.{max u v} κ)\n    (h4 : Cardinal.lift.{w} κ ≤ Cardinal.lift.{w'} #M) :\n    ∃ S : L.ElementarySubstructure M, s ⊆ S ∧ Cardinal.lift.{w'} #S = Cardinal.lift.{w} κ := by\n  obtain ⟨s', hs'⟩ := Cardinal.le_mk_iff_exists_set.1 h4\n  rw [← aleph0_le_lift.{_, w}] at h1\n  rw [← hs'] at h1 h2 ⊢\n  refine\n    ⟨elementarySkolem₁Reduct (closure (L.sum L.skolem₁) (s ∪ Equiv.ulift '' s')),\n      (s.subset_union_left).trans subset_closure, ?_⟩\n  have h := mk_image_eq_lift _ s' Equiv.ulift.injective\n  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h\n  rw [coeSort_elementarySkolem₁Reduct, ← h, lift_inj]\n  refine\n    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))\n      (mk_le_mk_of_subset ((s.subset_union_right).trans subset_closure))\n  rw [max_le_iff, aleph0_le_lift, ← aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]\n  · refine ⟨h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolem₁_le).trans ?_⟩\n    · rw [← lift_le, lift_add, h, add_comm, add_eq_max h1]\n      exact max_le le_rfl h2\n    · rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ← lift_le.{w'},\n        lift_lift, lift_lift, ← aleph0_le_lift, h]\n      refine ⟨?_, h1⟩\n      rw [← lift_lift.{w', w}]\n      refine _root_.trans (lift_le.{w}.2 h3) ?_\n      rw [lift_lift, ← lift_lift.{w, max u v}, ← hs', ← h, lift_lift]\n  · refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset Set.subset_union_right))\n    rw [aleph0_le_lift, ← aleph0_le_lift, h]\n    exact h1\n\n"}
