{"name":"Complex.isCauSeq_abs_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"z : Complex\n⊢ IsCauSeq abs fun n => (Finset.range n).sum fun m => Complex.abs (HDiv.hDiv (HPow.hPow z m) ↑m.factorial)","decl":"theorem isCauSeq_abs_exp (z : ℂ) :\n    IsCauSeq _root_.abs fun n => ∑ m ∈ range n, abs (z ^ m / m.factorial) :=\n  let ⟨n, hn⟩ := exists_nat_gt (abs z)\n  have hn0 : (0 : ℝ) < n := lt_of_le_of_lt (abs.nonneg _) hn\n  IsCauSeq.series_ratio_test n (abs z / n) (div_nonneg (abs.nonneg _) (le_of_lt hn0))\n    (by rwa [div_lt_iff₀ hn0, one_mul]) fun m hm => by\n      rw [abs_abs, abs_abs, Nat.factorial_succ, pow_succ', mul_comm m.succ, Nat.cast_mul, ← div_div,\n        mul_div_assoc, mul_div_right_comm, map_mul, map_div₀, abs_natCast]\n      gcongr\n      exact le_trans hm (Nat.le_succ _)\n\n"}
{"name":"Complex.isCauSeq_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"z : Complex\n⊢ IsCauSeq ⇑Complex.abs fun n => (Finset.range n).sum fun m => HDiv.hDiv (HPow.hPow z m) ↑m.factorial","decl":"theorem isCauSeq_exp (z : ℂ) : IsCauSeq abs fun n => ∑ m ∈ range n, z ^ m / m.factorial :=\n  (isCauSeq_abs_exp z).of_abv\n\n"}
{"name":"Complex.exp_zero","module":"Mathlib.Data.Complex.Exponential","initialProofState":"⊢ Eq (Complex.exp 0) 1","decl":"@[simp]\ntheorem exp_zero : exp 0 = 1 := by\n  rw [exp]\n  refine lim_eq_of_equiv_const fun ε ε0 => ⟨1, fun j hj => ?_⟩\n  convert (config := .unfoldSameFun) ε0 -- Porting note: ε0 : ε > 0 but goal is _ < ε\n  cases' j with j j\n  · exact absurd hj (not_le_of_gt zero_lt_one)\n  · dsimp [exp']\n    induction' j with j ih\n    · dsimp [exp']; simp [show Nat.succ 0 = 1 from rfl]\n    · rw [← ih (by simp [Nat.succ_le_succ])]\n      simp only [sum_range_succ, pow_succ]\n      simp\n\n"}
{"name":"Complex.exp_add","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x y : Complex\n⊢ Eq (Complex.exp (HAdd.hAdd x y)) (HMul.hMul (Complex.exp x) (Complex.exp y))","decl":"theorem exp_add : exp (x + y) = exp x * exp y := by\n  have hj : ∀ j : ℕ, (∑ m ∈ range j, (x + y) ^ m / m.factorial) =\n        ∑ i ∈ range j, ∑ k ∈ range (i + 1), x ^ k / k.factorial *\n          (y ^ (i - k) / (i - k).factorial) := by\n    intro j\n    refine Finset.sum_congr rfl fun m _ => ?_\n    rw [add_pow, div_eq_mul_inv, sum_mul]\n    refine Finset.sum_congr rfl fun I hi => ?_\n    have h₁ : (m.choose I : ℂ) ≠ 0 :=\n      Nat.cast_ne_zero.2 (pos_iff_ne_zero.1 (Nat.choose_pos (Nat.le_of_lt_succ (mem_range.1 hi))))\n    have h₂ := Nat.choose_mul_factorial_mul_factorial (Nat.le_of_lt_succ <| Finset.mem_range.1 hi)\n    rw [← h₂, Nat.cast_mul, Nat.cast_mul, mul_inv, mul_inv]\n    simp only [mul_left_comm (m.choose I : ℂ), mul_assoc, mul_left_comm (m.choose I : ℂ)⁻¹,\n      mul_comm (m.choose I : ℂ)]\n    rw [inv_mul_cancel₀ h₁]\n    simp [div_eq_mul_inv, mul_comm, mul_assoc, mul_left_comm]\n  simp_rw [exp, exp', lim_mul_lim]\n  apply (lim_eq_lim_of_equiv _).symm\n  simp only [hj]\n  exact cauchy_product (isCauSeq_abs_exp x) (isCauSeq_exp y)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11445): new definition\n"}
{"name":"Complex.expMonoidHom_apply","module":"Mathlib.Data.Complex.Exponential","initialProofState":"z : Multiplicative Complex\n⊢ Eq (Complex.expMonoidHom z) (Complex.exp (Multiplicative.toAdd z))","decl":"/-- the exponential function as a monoid hom from `Multiplicative ℂ` to `ℂ` -/\n@[simps]\nnoncomputable def expMonoidHom : MonoidHom (Multiplicative ℂ) ℂ :=\n  { toFun := fun z => exp z.toAdd,\n    map_one' := by simp,\n    map_mul' := by simp [exp_add] }\n\n"}
{"name":"Complex.exp_list_sum","module":"Mathlib.Data.Complex.Exponential","initialProofState":"l : List Complex\n⊢ Eq (Complex.exp l.sum) (List.map Complex.exp l).prod","decl":"theorem exp_list_sum (l : List ℂ) : exp l.sum = (l.map exp).prod :=\n  map_list_prod (M := Multiplicative ℂ) expMonoidHom l\n\n"}
{"name":"Complex.exp_multiset_sum","module":"Mathlib.Data.Complex.Exponential","initialProofState":"s : Multiset Complex\n⊢ Eq (Complex.exp s.sum) (Multiset.map Complex.exp s).prod","decl":"theorem exp_multiset_sum (s : Multiset ℂ) : exp s.sum = (s.map exp).prod :=\n  @MonoidHom.map_multiset_prod (Multiplicative ℂ) ℂ _ _ expMonoidHom s\n\n"}
{"name":"Complex.exp_sum","module":"Mathlib.Data.Complex.Exponential","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Complex\n⊢ Eq (Complex.exp (s.sum fun x => f x)) (s.prod fun x => Complex.exp (f x))","decl":"theorem exp_sum {α : Type*} (s : Finset α) (f : α → ℂ) :\n    exp (∑ x ∈ s, f x) = ∏ x ∈ s, exp (f x) :=\n  map_prod (β := Multiplicative ℂ) expMonoidHom f s\n\n"}
{"name":"Complex.exp_nsmul","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\nn : Nat\n⊢ Eq (Complex.exp (HSMul.hSMul n x)) (HPow.hPow (Complex.exp x) n)","decl":"lemma exp_nsmul (x : ℂ) (n : ℕ) : exp (n • x) = exp x ^ n :=\n  @MonoidHom.map_pow (Multiplicative ℂ) ℂ _ _  expMonoidHom _ _\n\n"}
{"name":"Complex.exp_nat_mul","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\nn : Nat\n⊢ Eq (Complex.exp (HMul.hMul (↑n) x)) (HPow.hPow (Complex.exp x) n)","decl":"theorem exp_nat_mul (x : ℂ) : ∀ n : ℕ, exp (n * x) = exp x ^ n\n  | 0 => by rw [Nat.cast_zero, zero_mul, exp_zero, pow_zero]\n  | Nat.succ n => by rw [pow_succ, Nat.cast_add_one, add_mul, exp_add, ← exp_nat_mul _ n, one_mul]\n\n"}
{"name":"Complex.exp_ne_zero","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\n⊢ Ne (Complex.exp x) 0","decl":"@[simp]\ntheorem exp_ne_zero : exp x ≠ 0 := fun h =>\n  zero_ne_one (α := ℂ) <| by rw [← exp_zero, ← add_neg_cancel x, exp_add, h]; simp\n\n"}
{"name":"Complex.exp_neg","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\n⊢ Eq (Complex.exp (Neg.neg x)) (Inv.inv (Complex.exp x))","decl":"theorem exp_neg : exp (-x) = (exp x)⁻¹ := by\n  rw [← mul_right_inj' (exp_ne_zero x), ← exp_add]; simp [mul_inv_cancel₀ (exp_ne_zero x)]\n\n"}
{"name":"Complex.exp_sub","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x y : Complex\n⊢ Eq (Complex.exp (HSub.hSub x y)) (HDiv.hDiv (Complex.exp x) (Complex.exp y))","decl":"theorem exp_sub : exp (x - y) = exp x / exp y := by\n  simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]\n\n"}
{"name":"Complex.exp_int_mul","module":"Mathlib.Data.Complex.Exponential","initialProofState":"z : Complex\nn : Int\n⊢ Eq (Complex.exp (HMul.hMul (↑n) z)) (HPow.hPow (Complex.exp z) n)","decl":"theorem exp_int_mul (z : ℂ) (n : ℤ) : Complex.exp (n * z) = Complex.exp z ^ n := by\n  cases n\n  · simp [exp_nat_mul]\n  · simp [exp_add, add_mul, pow_add, exp_neg, exp_nat_mul]\n\n"}
{"name":"Complex.exp_conj","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\n⊢ Eq (Complex.exp ((starRingEnd Complex) x)) ((starRingEnd Complex) (Complex.exp x))","decl":"@[simp]\ntheorem exp_conj : exp (conj x) = conj (exp x) := by\n  dsimp [exp]\n  rw [← lim_conj]\n  refine congr_arg CauSeq.lim (CauSeq.ext fun _ => ?_)\n  dsimp [exp', Function.comp_def, cauSeqConj]\n  rw [map_sum (starRingEnd _)]\n  refine sum_congr rfl fun n _ => ?_\n  rw [map_div₀, map_pow, ← ofReal_natCast, conj_ofReal]\n\n"}
{"name":"Complex.ofReal_exp_ofReal_re","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Eq (↑(Complex.exp ↑x).re) (Complex.exp ↑x)","decl":"@[simp]\ntheorem ofReal_exp_ofReal_re (x : ℝ) : ((exp x).re : ℂ) = exp x :=\n  conj_eq_iff_re.1 <| by rw [← exp_conj, conj_ofReal]\n\n"}
{"name":"Complex.ofReal_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Eq (↑(Real.exp x)) (Complex.exp ↑x)","decl":"@[simp, norm_cast]\ntheorem ofReal_exp (x : ℝ) : (Real.exp x : ℂ) = exp x :=\n  ofReal_exp_ofReal_re _\n\n"}
{"name":"Complex.exp_ofReal_im","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Eq (Complex.exp ↑x).im 0","decl":"@[simp]\ntheorem exp_ofReal_im (x : ℝ) : (exp x).im = 0 := by rw [← ofReal_exp_ofReal_re, ofReal_im]\n\n"}
{"name":"Complex.exp_ofReal_re","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Eq (Complex.exp ↑x).re (Real.exp x)","decl":"theorem exp_ofReal_re (x : ℝ) : (exp x).re = Real.exp x :=\n  rfl\n\n"}
{"name":"Real.exp_zero","module":"Mathlib.Data.Complex.Exponential","initialProofState":"⊢ Eq (Real.exp 0) 1","decl":"@[simp]\ntheorem exp_zero : exp 0 = 1 := by simp [Real.exp]\n\n"}
{"name":"Real.exp_add","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x y : Real\n⊢ Eq (Real.exp (HAdd.hAdd x y)) (HMul.hMul (Real.exp x) (Real.exp y))","decl":"nonrec theorem exp_add : exp (x + y) = exp x * exp y := by simp [exp_add, exp]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11445): new definition\n"}
{"name":"Real.expMonoidHom_apply","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Multiplicative Real\n⊢ Eq (Real.expMonoidHom x) (Real.exp (Multiplicative.toAdd x))","decl":"/-- the exponential function as a monoid hom from `Multiplicative ℝ` to `ℝ` -/\n@[simps]\nnoncomputable def expMonoidHom : MonoidHom (Multiplicative ℝ) ℝ :=\n  { toFun := fun x => exp x.toAdd,\n    map_one' := by simp,\n    map_mul' := by simp [exp_add] }\n\n"}
{"name":"Real.exp_list_sum","module":"Mathlib.Data.Complex.Exponential","initialProofState":"l : List Real\n⊢ Eq (Real.exp l.sum) (List.map Real.exp l).prod","decl":"theorem exp_list_sum (l : List ℝ) : exp l.sum = (l.map exp).prod :=\n  map_list_prod (M := Multiplicative ℝ) expMonoidHom l\n\n"}
{"name":"Real.exp_multiset_sum","module":"Mathlib.Data.Complex.Exponential","initialProofState":"s : Multiset Real\n⊢ Eq (Real.exp s.sum) (Multiset.map Real.exp s).prod","decl":"theorem exp_multiset_sum (s : Multiset ℝ) : exp s.sum = (s.map exp).prod :=\n  @MonoidHom.map_multiset_prod (Multiplicative ℝ) ℝ _ _ expMonoidHom s\n\n"}
{"name":"Real.exp_sum","module":"Mathlib.Data.Complex.Exponential","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Real\n⊢ Eq (Real.exp (s.sum fun x => f x)) (s.prod fun x => Real.exp (f x))","decl":"theorem exp_sum {α : Type*} (s : Finset α) (f : α → ℝ) :\n    exp (∑ x ∈ s, f x) = ∏ x ∈ s, exp (f x) :=\n  map_prod (β := Multiplicative ℝ) expMonoidHom f s\n\n"}
{"name":"Real.exp_nsmul","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nn : Nat\n⊢ Eq (Real.exp (HSMul.hSMul n x)) (HPow.hPow (Real.exp x) n)","decl":"lemma exp_nsmul (x : ℝ) (n : ℕ) : exp (n • x) = exp x ^ n :=\n  @MonoidHom.map_pow (Multiplicative ℝ) ℝ _ _  expMonoidHom _ _\n\n"}
{"name":"Real.exp_nat_mul","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nn : Nat\n⊢ Eq (Real.exp (HMul.hMul (↑n) x)) (HPow.hPow (Real.exp x) n)","decl":"nonrec theorem exp_nat_mul (x : ℝ) (n : ℕ) : exp (n * x) = exp x ^ n :=\n  ofReal_injective (by simp [exp_nat_mul])\n\n"}
{"name":"Real.exp_ne_zero","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Ne (Real.exp x) 0","decl":"@[simp]\nnonrec theorem exp_ne_zero : exp x ≠ 0 := fun h =>\n  exp_ne_zero x <| by rw [exp, ← ofReal_inj] at h; simp_all\n\n"}
{"name":"Real.exp_neg","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Eq (Real.exp (Neg.neg x)) (Inv.inv (Real.exp x))","decl":"nonrec theorem exp_neg : exp (-x) = (exp x)⁻¹ :=\n  ofReal_injective <| by simp [exp_neg]\n\n"}
{"name":"Real.exp_sub","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x y : Real\n⊢ Eq (Real.exp (HSub.hSub x y)) (HDiv.hDiv (Real.exp x) (Real.exp y))","decl":"theorem exp_sub : exp (x - y) = exp x / exp y := by\n  simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]\n\n"}
{"name":"Real.sum_le_exp_of_nonneg","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nhx : LE.le 0 x\nn : Nat\n⊢ LE.le ((Finset.range n).sum fun i => HDiv.hDiv (HPow.hPow x i) ↑i.factorial) (Real.exp x)","decl":"theorem sum_le_exp_of_nonneg {x : ℝ} (hx : 0 ≤ x) (n : ℕ) : ∑ i ∈ range n, x ^ i / i ! ≤ exp x :=\n  calc\n    ∑ i ∈ range n, x ^ i / i ! ≤ lim (⟨_, isCauSeq_re (exp' x)⟩ : CauSeq ℝ abs) := by\n      refine le_lim (CauSeq.le_of_exists ⟨n, fun j hj => ?_⟩)\n      simp only [exp', const_apply, re_sum]\n      norm_cast\n      refine sum_le_sum_of_subset_of_nonneg (range_mono hj) fun _ _ _ ↦ ?_\n      positivity\n    _ = exp x := by rw [exp, Complex.exp, ← cauSeqRe, lim_re]\n\n"}
{"name":"Real.pow_div_factorial_le_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nhx : LE.le 0 x\nn : Nat\n⊢ LE.le (HDiv.hDiv (HPow.hPow x n) ↑n.factorial) (Real.exp x)","decl":"lemma pow_div_factorial_le_exp (hx : 0 ≤ x) (n : ℕ) : x ^ n / n ! ≤ exp x :=\n  calc\n    x ^ n / n ! ≤ ∑ k ∈ range (n + 1), x ^ k / k ! :=\n        single_le_sum (f := fun k ↦ x ^ k / k !) (fun k _ ↦ by positivity) (self_mem_range_succ n)\n    _ ≤ exp x := sum_le_exp_of_nonneg hx _\n\n"}
{"name":"Real.quadratic_le_exp_of_nonneg","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nhx : LE.le 0 x\n⊢ LE.le (HAdd.hAdd (HAdd.hAdd 1 x) (HDiv.hDiv (HPow.hPow x 2) 2)) (Real.exp x)","decl":"theorem quadratic_le_exp_of_nonneg {x : ℝ} (hx : 0 ≤ x) : 1 + x + x ^ 2 / 2 ≤ exp x :=\n  calc\n    1 + x + x ^ 2 / 2 = ∑ i ∈ range 3, x ^ i / i ! := by\n        simp only [sum_range_succ, range_one, sum_singleton, _root_.pow_zero, factorial, cast_one,\n          ne_eq, one_ne_zero, not_false_eq_true, div_self, pow_one, mul_one, div_one, Nat.mul_one,\n          cast_succ, add_right_inj]\n        ring_nf\n    _ ≤ exp x := sum_le_exp_of_nonneg hx 3\n\n"}
{"name":"Real.one_le_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nhx : LE.le 0 x\n⊢ LE.le 1 (Real.exp x)","decl":"theorem one_le_exp {x : ℝ} (hx : 0 ≤ x) : 1 ≤ exp x := by linarith [add_one_le_exp_of_nonneg hx]\n\n"}
{"name":"Real.exp_pos","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ LT.lt 0 (Real.exp x)","decl":"@[bound]\ntheorem exp_pos (x : ℝ) : 0 < exp x :=\n  (le_total 0 x).elim (lt_of_lt_of_le zero_lt_one ∘ one_le_exp) fun h => by\n    rw [← neg_neg x, Real.exp_neg]\n    exact inv_pos.2 (lt_of_lt_of_le zero_lt_one (one_le_exp (neg_nonneg.2 h)))\n\n"}
{"name":"Real.exp_nonneg","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ LE.le 0 (Real.exp x)","decl":"@[bound]\nlemma exp_nonneg (x : ℝ) : 0 ≤ exp x := x.exp_pos.le\n\n"}
{"name":"Real.abs_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Eq (abs (Real.exp x)) (Real.exp x)","decl":"@[simp]\ntheorem abs_exp (x : ℝ) : |exp x| = exp x :=\n  abs_of_pos (exp_pos _)\n\n"}
{"name":"Real.exp_abs_le","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ LE.le (Real.exp (abs x)) (HAdd.hAdd (Real.exp x) (Real.exp (Neg.neg x)))","decl":"lemma exp_abs_le (x : ℝ) : exp |x| ≤ exp x + exp (-x) := by\n  cases le_total x 0 <;> simp [abs_of_nonpos, _root_.abs_of_nonneg, exp_nonneg, *]\n\n"}
{"name":"Real.exp_strictMono","module":"Mathlib.Data.Complex.Exponential","initialProofState":"⊢ StrictMono Real.exp","decl":"@[mono]\ntheorem exp_strictMono : StrictMono exp := fun x y h => by\n  rw [← sub_add_cancel y x, Real.exp_add]\n  exact (lt_mul_iff_one_lt_left (exp_pos _)).2\n      (lt_of_lt_of_le (by linarith) (add_one_le_exp_of_nonneg (by linarith)))\n\n"}
{"name":"Real.exp_lt_exp_of_lt","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x y : Real\nh : LT.lt x y\n⊢ LT.lt (Real.exp x) (Real.exp y)","decl":"@[gcongr]\ntheorem exp_lt_exp_of_lt {x y : ℝ} (h : x < y) : exp x < exp y := exp_strictMono h\n\n"}
{"name":"Real.exp_monotone","module":"Mathlib.Data.Complex.Exponential","initialProofState":"⊢ Monotone Real.exp","decl":"@[mono]\ntheorem exp_monotone : Monotone exp :=\n  exp_strictMono.monotone\n\n"}
{"name":"Real.exp_le_exp_of_le","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x y : Real\nh : LE.le x y\n⊢ LE.le (Real.exp x) (Real.exp y)","decl":"@[gcongr, bound]\ntheorem exp_le_exp_of_le {x y : ℝ} (h : x ≤ y) : exp x ≤ exp y := exp_monotone h\n\n"}
{"name":"Real.exp_lt_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x y : Real\n⊢ Iff (LT.lt (Real.exp x) (Real.exp y)) (LT.lt x y)","decl":"@[simp]\ntheorem exp_lt_exp {x y : ℝ} : exp x < exp y ↔ x < y :=\n  exp_strictMono.lt_iff_lt\n\n"}
{"name":"Real.exp_le_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x y : Real\n⊢ Iff (LE.le (Real.exp x) (Real.exp y)) (LE.le x y)","decl":"@[simp]\ntheorem exp_le_exp {x y : ℝ} : exp x ≤ exp y ↔ x ≤ y :=\n  exp_strictMono.le_iff_le\n\n"}
{"name":"Real.exp_injective","module":"Mathlib.Data.Complex.Exponential","initialProofState":"⊢ Function.Injective Real.exp","decl":"theorem exp_injective : Function.Injective exp :=\n  exp_strictMono.injective\n\n"}
{"name":"Real.exp_eq_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x y : Real\n⊢ Iff (Eq (Real.exp x) (Real.exp y)) (Eq x y)","decl":"@[simp]\ntheorem exp_eq_exp {x y : ℝ} : exp x = exp y ↔ x = y :=\n  exp_injective.eq_iff\n\n"}
{"name":"Real.exp_eq_one_iff","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Iff (Eq (Real.exp x) 1) (Eq x 0)","decl":"@[simp]\ntheorem exp_eq_one_iff : exp x = 1 ↔ x = 0 :=\n  exp_injective.eq_iff' exp_zero\n\n"}
{"name":"Real.one_lt_exp_iff","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Iff (LT.lt 1 (Real.exp x)) (LT.lt 0 x)","decl":"@[simp]\ntheorem one_lt_exp_iff {x : ℝ} : 1 < exp x ↔ 0 < x := by rw [← exp_zero, exp_lt_exp]\n\n"}
{"name":"Real.exp_lt_one_iff","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Iff (LT.lt (Real.exp x) 1) (LT.lt x 0)","decl":"@[simp]\ntheorem exp_lt_one_iff {x : ℝ} : exp x < 1 ↔ x < 0 := by rw [← exp_zero, exp_lt_exp]\n\n"}
{"name":"Real.exp_le_one_iff","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Iff (LE.le (Real.exp x) 1) (LE.le x 0)","decl":"@[simp]\ntheorem exp_le_one_iff {x : ℝ} : exp x ≤ 1 ↔ x ≤ 0 :=\n  exp_zero ▸ exp_le_exp\n\n"}
{"name":"Real.one_le_exp_iff","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Iff (LE.le 1 (Real.exp x)) (LE.le 0 x)","decl":"@[simp]\ntheorem one_le_exp_iff {x : ℝ} : 1 ≤ exp x ↔ 0 ≤ x :=\n  exp_zero ▸ exp_le_exp\n\n"}
{"name":"Complex.sum_div_factorial_le","module":"Mathlib.Data.Complex.Exponential","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nn j : Nat\nhn : LT.lt 0 n\n⊢ LE.le ((Finset.filter (fun m => LE.le n m) (Finset.range j)).sum fun m => HDiv.hDiv 1 ↑m.factorial) (HDiv.hDiv (↑n.succ) (HMul.hMul ↑n.factorial ↑n))","decl":"theorem sum_div_factorial_le {α : Type*} [LinearOrderedField α] (n j : ℕ) (hn : 0 < n) :\n    (∑ m ∈ range j with n ≤ m, (1 / m.factorial : α)) ≤ n.succ / (n.factorial * n) :=\n  calc\n    (∑ m ∈ range j with n ≤ m, (1 / m.factorial : α)) =\n        ∑ m ∈ range (j - n), (1 / ((m + n).factorial : α)) := by\n        refine sum_nbij' (· - n) (· + n) ?_ ?_ ?_ ?_ ?_ <;>\n          simp +contextual [lt_tsub_iff_right, tsub_add_cancel_of_le]\n    _ ≤ ∑ m ∈ range (j - n), ((n.factorial : α) * (n.succ : α) ^ m)⁻¹ := by\n      simp_rw [one_div]\n      gcongr\n      rw [← Nat.cast_pow, ← Nat.cast_mul, Nat.cast_le, add_comm]\n      exact Nat.factorial_mul_pow_le_factorial\n    _ = (n.factorial : α)⁻¹ * ∑ m ∈ range (j - n), (n.succ : α)⁻¹ ^ m := by\n      simp [mul_inv, ← mul_sum, ← sum_mul, mul_comm, inv_pow]\n    _ = ((n.succ : α) - n.succ * (n.succ : α)⁻¹ ^ (j - n)) / (n.factorial * n) := by\n      have h₁ : (n.succ : α) ≠ 1 :=\n        @Nat.cast_one α _ ▸ mt Nat.cast_inj.1 (mt Nat.succ.inj (pos_iff_ne_zero.1 hn))\n      have h₂ : (n.succ : α) ≠ 0 := by positivity\n      have h₃ : (n.factorial * n : α) ≠ 0 := by positivity\n      have h₄ : (n.succ - 1 : α) = n := by simp\n      rw [geom_sum_inv h₁ h₂, eq_div_iff_mul_eq h₃, mul_comm _ (n.factorial * n : α),\n          ← mul_assoc (n.factorial⁻¹ : α), ← mul_inv_rev, h₄, ← mul_assoc (n.factorial * n : α),\n          mul_comm (n : α) n.factorial, mul_inv_cancel₀ h₃, one_mul, mul_comm]\n    _ ≤ n.succ / (n.factorial * n : α) := by gcongr; apply sub_le_self; positivity\n\n"}
{"name":"Complex.exp_bound","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\nhx : LE.le (Complex.abs x) 1\nn : Nat\nhn : LT.lt 0 n\n⊢ LE.le (Complex.abs (HSub.hSub (Complex.exp x) ((Finset.range n).sum fun m => HDiv.hDiv (HPow.hPow x m) ↑m.factorial))) (HMul.hMul (HPow.hPow (Complex.abs x) n) (HMul.hMul (↑n.succ) (Inv.inv (HMul.hMul ↑n.factorial ↑n))))","decl":"theorem exp_bound {x : ℂ} (hx : abs x ≤ 1) {n : ℕ} (hn : 0 < n) :\n    abs (exp x - ∑ m ∈ range n, x ^ m / m.factorial) ≤\n      abs x ^ n * ((n.succ : ℝ) * (n.factorial * n : ℝ)⁻¹) := by\n  rw [← lim_const (abv := Complex.abs) (∑ m ∈ range n, _), exp, sub_eq_add_neg,\n    ← lim_neg, lim_add, ← lim_abs]\n  refine lim_le (CauSeq.le_of_exists ⟨n, fun j hj => ?_⟩)\n  simp_rw [← sub_eq_add_neg]\n  show\n    abs ((∑ m ∈ range j, x ^ m / m.factorial) - ∑ m ∈ range n, x ^ m / m.factorial) ≤\n      abs x ^ n * ((n.succ : ℝ) * (n.factorial * n : ℝ)⁻¹)\n  rw [sum_range_sub_sum_range hj]\n  calc\n    abs (∑ m ∈ range j with n ≤ m, (x ^ m / m.factorial : ℂ))\n      = abs (∑ m ∈ range j with n ≤ m, (x ^ n * (x ^ (m - n) / m.factorial) : ℂ)) := by\n      refine congr_arg abs (sum_congr rfl fun m hm => ?_)\n      rw [mem_filter, mem_range] at hm\n      rw [← mul_div_assoc, ← pow_add, add_tsub_cancel_of_le hm.2]\n    _ ≤ ∑ m ∈ range j with n ≤ m, abs (x ^ n * (x ^ (m - n) / m.factorial)) :=\n      IsAbsoluteValue.abv_sum Complex.abs ..\n    _ ≤ ∑ m ∈ range j with n ≤ m, abs x ^ n * (1 / m.factorial) := by\n      simp_rw [map_mul, map_pow, map_div₀, abs_natCast]\n      gcongr\n      rw [abv_pow abs]\n      exact pow_le_one₀ (abs.nonneg _) hx\n    _ = abs x ^ n * ∑ m ∈ range j with n ≤ m, (1 / m.factorial : ℝ) := by\n      simp [abs_mul, abv_pow abs, abs_div, ← mul_sum]\n    _ ≤ abs x ^ n * (n.succ * (n.factorial * n : ℝ)⁻¹) := by\n      gcongr\n      exact sum_div_factorial_le _ _ hn\n\n"}
{"name":"Complex.exp_bound'","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\nn : Nat\nhx : LE.le (HDiv.hDiv (Complex.abs x) ↑n.succ) (1 / 2)\n⊢ LE.le (Complex.abs (HSub.hSub (Complex.exp x) ((Finset.range n).sum fun m => HDiv.hDiv (HPow.hPow x m) ↑m.factorial))) (HMul.hMul (HDiv.hDiv (HPow.hPow (Complex.abs x) n) ↑n.factorial) 2)","decl":"theorem exp_bound' {x : ℂ} {n : ℕ} (hx : abs x / n.succ ≤ 1 / 2) :\n    abs (exp x - ∑ m ∈ range n, x ^ m / m.factorial) ≤ abs x ^ n / n.factorial * 2 := by\n  rw [← lim_const (abv := Complex.abs) (∑ m ∈ range n, _),\n    exp, sub_eq_add_neg, ← lim_neg, lim_add, ← lim_abs]\n  refine lim_le (CauSeq.le_of_exists ⟨n, fun j hj => ?_⟩)\n  simp_rw [← sub_eq_add_neg]\n  show abs ((∑ m ∈ range j, x ^ m / m.factorial) - ∑ m ∈ range n, x ^ m / m.factorial) ≤\n    abs x ^ n / n.factorial * 2\n  let k := j - n\n  have hj : j = n + k := (add_tsub_cancel_of_le hj).symm\n  rw [hj, sum_range_add_sub_sum_range]\n  calc\n    abs (∑ i ∈ range k, x ^ (n + i) / ((n + i).factorial : ℂ)) ≤\n        ∑ i ∈ range k, abs (x ^ (n + i) / ((n + i).factorial : ℂ)) :=\n      IsAbsoluteValue.abv_sum _ _ _\n    _ ≤ ∑ i ∈ range k, abs x ^ (n + i) / (n + i).factorial := by\n      simp [Complex.abs_natCast, map_div₀, abv_pow abs]\n    _ ≤ ∑ i ∈ range k, abs x ^ (n + i) / ((n.factorial : ℝ) * (n.succ : ℝ) ^ i) := ?_\n    _ = ∑ i ∈ range k, abs x ^ n / n.factorial * (abs x ^ i / (n.succ : ℝ) ^ i) := ?_\n    _ ≤ abs x ^ n / ↑n.factorial * 2 := ?_\n  · gcongr\n    exact mod_cast Nat.factorial_mul_pow_le_factorial\n  · refine Finset.sum_congr rfl fun _ _ => ?_\n    simp only [pow_add, div_eq_inv_mul, mul_inv, mul_left_comm, mul_assoc]\n  · rw [← mul_sum]\n    gcongr\n    simp_rw [← div_pow]\n    rw [geom_sum_eq, div_le_iff_of_neg]\n    · trans (-1 : ℝ)\n      · linarith\n      · simp only [neg_le_sub_iff_le_add, div_pow, Nat.cast_succ, le_add_iff_nonneg_left]\n        positivity\n    · linarith\n    · linarith\n\n"}
{"name":"Complex.abs_exp_sub_one_le","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\nhx : LE.le (Complex.abs x) 1\n⊢ LE.le (Complex.abs (HSub.hSub (Complex.exp x) 1)) (HMul.hMul 2 (Complex.abs x))","decl":"theorem abs_exp_sub_one_le {x : ℂ} (hx : abs x ≤ 1) : abs (exp x - 1) ≤ 2 * abs x :=\n  calc\n    abs (exp x - 1) = abs (exp x - ∑ m ∈ range 1, x ^ m / m.factorial) := by simp [sum_range_succ]\n    _ ≤ abs x ^ 1 * ((Nat.succ 1 : ℝ) * ((Nat.factorial 1) * (1 : ℕ) : ℝ)⁻¹) :=\n      (exp_bound hx (by decide))\n    _ = 2 * abs x := by simp [two_mul, mul_two, mul_add, mul_comm, add_mul, Nat.factorial]\n\n"}
{"name":"Complex.abs_exp_sub_one_sub_id_le","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\nhx : LE.le (Complex.abs x) 1\n⊢ LE.le (Complex.abs (HSub.hSub (HSub.hSub (Complex.exp x) 1) x)) (HPow.hPow (Complex.abs x) 2)","decl":"theorem abs_exp_sub_one_sub_id_le {x : ℂ} (hx : abs x ≤ 1) : abs (exp x - 1 - x) ≤ abs x ^ 2 :=\n  calc\n    abs (exp x - 1 - x) = abs (exp x - ∑ m ∈ range 2, x ^ m / m.factorial) := by\n      simp [sub_eq_add_neg, sum_range_succ_comm, add_assoc, Nat.factorial]\n    _ ≤ abs x ^ 2 * ((Nat.succ 2 : ℝ) * (Nat.factorial 2 * (2 : ℕ) : ℝ)⁻¹) :=\n      (exp_bound hx (by decide))\n    _ ≤ abs x ^ 2 * 1 := by gcongr; norm_num [Nat.factorial]\n    _ = abs x ^ 2 := by rw [mul_one]\n\n"}
{"name":"Complex.abs_exp_sub_sum_le_exp_abs_sub_sum","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\nn : Nat\n⊢ LE.le (Complex.abs (HSub.hSub (Complex.exp x) ((Finset.range n).sum fun m => HDiv.hDiv (HPow.hPow x m) ↑m.factorial))) (HSub.hSub (Real.exp (Complex.abs x)) ((Finset.range n).sum fun m => HDiv.hDiv (HPow.hPow (Complex.abs x) m) ↑m.factorial))","decl":"lemma abs_exp_sub_sum_le_exp_abs_sub_sum (x : ℂ) (n : ℕ) :\n    abs (exp x - ∑ m ∈ range n, x ^ m / m.factorial)\n      ≤ Real.exp (abs x) - ∑ m ∈ range n, (abs x) ^ m / m.factorial := by\n  rw [← CauSeq.lim_const (abv := Complex.abs) (∑ m ∈ range n, _), Complex.exp, sub_eq_add_neg,\n    ← CauSeq.lim_neg, CauSeq.lim_add, ← lim_abs]\n  refine CauSeq.lim_le (CauSeq.le_of_exists ⟨n, fun j hj => ?_⟩)\n  simp_rw [← sub_eq_add_neg]\n  calc abs ((∑ m ∈ range j, x ^ m / m.factorial) - ∑ m ∈ range n, x ^ m / m.factorial)\n  _ ≤ (∑ m ∈ range j, abs x ^ m / m.factorial) - ∑ m ∈ range n, abs x ^ m / m.factorial := by\n    rw [sum_range_sub_sum_range hj, sum_range_sub_sum_range hj]\n    refine (IsAbsoluteValue.abv_sum Complex.abs ..).trans_eq ?_\n    congr with i\n    simp\n  _ ≤ Real.exp (abs x) - ∑ m ∈ range n, (abs x) ^ m / m.factorial := by\n    gcongr\n    exact Real.sum_le_exp_of_nonneg (by exact AbsoluteValue.nonneg abs x) _\n\n"}
{"name":"Complex.abs_exp_le_exp_abs","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\n⊢ LE.le (Complex.abs (Complex.exp x)) (Real.exp (Complex.abs x))","decl":"lemma abs_exp_le_exp_abs (x : ℂ) : abs (exp x) ≤ Real.exp (abs x) := by\n  convert abs_exp_sub_sum_le_exp_abs_sub_sum x 0 using 1 <;> simp\n\n"}
{"name":"Complex.abs_exp_sub_sum_le_abs_mul_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Complex\nn : Nat\n⊢ LE.le (Complex.abs (HSub.hSub (Complex.exp x) ((Finset.range n).sum fun m => HDiv.hDiv (HPow.hPow x m) ↑m.factorial))) (HMul.hMul (HPow.hPow (Complex.abs x) n) (Real.exp (Complex.abs x)))","decl":"lemma abs_exp_sub_sum_le_abs_mul_exp (x : ℂ) (n : ℕ) :\n    abs (exp x - ∑ m ∈ range n, x ^ m / m.factorial) ≤ abs x ^ n * Real.exp (abs x) := by\n  rw [← CauSeq.lim_const (abv := Complex.abs) (∑ m ∈ range n, _), Complex.exp, sub_eq_add_neg,\n    ← CauSeq.lim_neg, CauSeq.lim_add, ← lim_abs]\n  refine CauSeq.lim_le (CauSeq.le_of_exists ⟨n, fun j hj => ?_⟩)\n  simp_rw [← sub_eq_add_neg]\n  show abs ((∑ m ∈ range j, x ^ m / m.factorial) - ∑ m ∈ range n, x ^ m / m.factorial) ≤ _\n  rw [sum_range_sub_sum_range hj]\n  calc\n    abs (∑ m ∈ range j with n ≤ m, (x ^ m / m.factorial : ℂ))\n      = abs (∑ m ∈ range j with n ≤ m, (x ^ n * (x ^ (m - n) / m.factorial) : ℂ)) := by\n      refine congr_arg abs (sum_congr rfl fun m hm => ?_)\n      rw [mem_filter, mem_range] at hm\n      rw [← mul_div_assoc, ← pow_add, add_tsub_cancel_of_le hm.2]\n    _ ≤ ∑ m ∈ range j with n ≤ m, abs (x ^ n * (x ^ (m - n) / m.factorial)) :=\n      IsAbsoluteValue.abv_sum Complex.abs ..\n    _ ≤ ∑ m ∈ range j with n ≤ m, abs x ^ n * (abs x ^ (m - n) / (m - n).factorial) := by\n      simp_rw [map_mul, map_pow, map_div₀, abs_natCast]\n      gcongr with i hi\n      · rw [IsAbsoluteValue.abv_pow abs]\n      · simp\n    _ = abs x ^ n * ∑ m ∈ range j with n ≤ m, (abs x ^ (m - n) / (m - n).factorial) := by\n      rw [← mul_sum]\n    _ = abs x ^ n * ∑ m ∈ range (j - n), (abs x ^ m / m.factorial) := by\n      congr 1\n      refine (sum_bij (fun m hm ↦ m + n) ?_ ?_ ?_ ?_).symm\n      · intro a ha\n        simp only [mem_filter, mem_range, le_add_iff_nonneg_left, zero_le, and_true]\n        simp only [mem_range] at ha\n        rwa [← lt_tsub_iff_right]\n      · intro a ha b hb hab\n        simpa using hab\n      · intro b hb\n        simp only [mem_range, exists_prop]\n        simp only [mem_filter, mem_range] at hb\n        refine ⟨b - n, ?_, ?_⟩\n        · rw [tsub_lt_tsub_iff_right hb.2]\n          exact hb.1\n        · rw [tsub_add_cancel_of_le hb.2]\n      · simp\n    _ ≤ abs x ^ n * Real.exp (abs x) := by\n      gcongr\n      refine Real.sum_le_exp_of_nonneg ?_ _\n      exact AbsoluteValue.nonneg abs x\n\n"}
{"name":"Real.exp_bound","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nhx : LE.le (abs x) 1\nn : Nat\nhn : LT.lt 0 n\n⊢ LE.le (abs (HSub.hSub (Real.exp x) ((Finset.range n).sum fun m => HDiv.hDiv (HPow.hPow x m) ↑m.factorial))) (HMul.hMul (HPow.hPow (abs x) n) (HDiv.hDiv (↑n.succ) (HMul.hMul ↑n.factorial ↑n)))","decl":"nonrec theorem exp_bound {x : ℝ} (hx : |x| ≤ 1) {n : ℕ} (hn : 0 < n) :\n    |exp x - ∑ m ∈ range n, x ^ m / m.factorial| ≤ |x| ^ n * (n.succ / (n.factorial * n)) := by\n  have hxc : Complex.abs x ≤ 1 := mod_cast hx\n  convert exp_bound hxc hn using 2 <;>\n  -- Porting note: was `norm_cast`\n  simp only [← abs_ofReal, ← ofReal_sub, ← ofReal_exp, ← ofReal_sum, ← ofReal_pow,\n    ← ofReal_div, ← ofReal_natCast]\n\n"}
{"name":"Real.exp_bound'","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nh1 : LE.le 0 x\nh2 : LE.le x 1\nn : Nat\nhn : LT.lt 0 n\n⊢ LE.le (Real.exp x) (HAdd.hAdd ((Finset.range n).sum fun m => HDiv.hDiv (HPow.hPow x m) ↑m.factorial) (HDiv.hDiv (HMul.hMul (HPow.hPow x n) (HAdd.hAdd (↑n) 1)) (HMul.hMul ↑n.factorial ↑n)))","decl":"theorem exp_bound' {x : ℝ} (h1 : 0 ≤ x) (h2 : x ≤ 1) {n : ℕ} (hn : 0 < n) :\n    Real.exp x ≤ (∑ m ∈ Finset.range n, x ^ m / m.factorial) +\n      x ^ n * (n + 1) / (n.factorial * n) := by\n  have h3 : |x| = x := by simpa\n  have h4 : |x| ≤ 1 := by rwa [h3]\n  have h' := Real.exp_bound h4 hn\n  rw [h3] at h'\n  have h'' := (abs_sub_le_iff.1 h').1\n  have t := sub_le_iff_le_add'.1 h''\n  simpa [mul_div_assoc] using t\n\n"}
{"name":"Real.abs_exp_sub_one_le","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nhx : LE.le (abs x) 1\n⊢ LE.le (abs (HSub.hSub (Real.exp x) 1)) (HMul.hMul 2 (abs x))","decl":"theorem abs_exp_sub_one_le {x : ℝ} (hx : |x| ≤ 1) : |exp x - 1| ≤ 2 * |x| := by\n  have : |x| ≤ 1 := mod_cast hx\n  -- Porting note: was\n  --exact_mod_cast Complex.abs_exp_sub_one_le (x := x) this\n  have := Complex.abs_exp_sub_one_le (x := x) (by simpa using this)\n  rw [← ofReal_exp, ← ofReal_one, ← ofReal_sub, abs_ofReal, abs_ofReal] at this\n  exact this\n\n"}
{"name":"Real.abs_exp_sub_one_sub_id_le","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nhx : LE.le (abs x) 1\n⊢ LE.le (abs (HSub.hSub (HSub.hSub (Real.exp x) 1) x)) (HPow.hPow x 2)","decl":"theorem abs_exp_sub_one_sub_id_le {x : ℝ} (hx : |x| ≤ 1) : |exp x - 1 - x| ≤ x ^ 2 := by\n  rw [← _root_.sq_abs]\n  -- Porting note: was\n  -- exact_mod_cast Complex.abs_exp_sub_one_sub_id_le this\n  have : Complex.abs x ≤ 1 := mod_cast hx\n  have := Complex.abs_exp_sub_one_sub_id_le this\n  rw [← ofReal_one, ← ofReal_exp, ← ofReal_sub, ← ofReal_sub, abs_ofReal, abs_ofReal] at this\n  exact this\n\n"}
{"name":"Real.expNear_zero","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x r : Real\n⊢ Eq (Real.expNear 0 x r) r","decl":"@[simp]\ntheorem expNear_zero (x r) : expNear 0 x r = r := by simp [expNear]\n\n"}
{"name":"Real.expNear_succ","module":"Mathlib.Data.Complex.Exponential","initialProofState":"n : Nat\nx r : Real\n⊢ Eq (Real.expNear (HAdd.hAdd n 1) x r) (Real.expNear n x (HAdd.hAdd 1 (HMul.hMul (HDiv.hDiv x (HAdd.hAdd (↑n) 1)) r)))","decl":"@[simp]\ntheorem expNear_succ (n x r) : expNear (n + 1) x r = expNear n x (1 + x / (n + 1) * r) := by\n  simp [expNear, range_succ, mul_add, add_left_comm, add_assoc, pow_succ, div_eq_mul_inv,\n      mul_inv, Nat.factorial]\n  ac_rfl\n\n"}
{"name":"Real.expNear_sub","module":"Mathlib.Data.Complex.Exponential","initialProofState":"n : Nat\nx r₁ r₂ : Real\n⊢ Eq (HSub.hSub (Real.expNear n x r₁) (Real.expNear n x r₂)) (HMul.hMul (HDiv.hDiv (HPow.hPow x n) ↑n.factorial) (HSub.hSub r₁ r₂))","decl":"theorem expNear_sub (n x r₁ r₂) : expNear n x r₁ -\n    expNear n x r₂ = x ^ n / n.factorial * (r₁ - r₂) := by\n  simp [expNear, mul_sub]\n\n"}
{"name":"Real.exp_approx_end","module":"Mathlib.Data.Complex.Exponential","initialProofState":"n m : Nat\nx : Real\ne₁ : Eq (HAdd.hAdd n 1) m\nh : LE.le (abs x) 1\n⊢ LE.le (abs (HSub.hSub (Real.exp x) (Real.expNear m x 0))) (HMul.hMul (HDiv.hDiv (HPow.hPow (abs x) m) ↑m.factorial) (HDiv.hDiv (HAdd.hAdd (↑m) 1) ↑m))","decl":"theorem exp_approx_end (n m : ℕ) (x : ℝ) (e₁ : n + 1 = m) (h : |x| ≤ 1) :\n    |exp x - expNear m x 0| ≤ |x| ^ m / m.factorial * ((m + 1) / m) := by\n  simp only [expNear, mul_zero, add_zero]\n  convert exp_bound (n := m) h ?_ using 1\n  · field_simp [mul_comm]\n  · omega\n\n"}
{"name":"Real.exp_approx_succ","module":"Mathlib.Data.Complex.Exponential","initialProofState":"n : Nat\nx a₁ b₁ : Real\nm : Nat\ne₁ : Eq (HAdd.hAdd n 1) m\na₂ b₂ : Real\ne : LE.le (abs (HSub.hSub (HAdd.hAdd 1 (HMul.hMul (HDiv.hDiv x ↑m) a₂)) a₁)) (HSub.hSub b₁ (HMul.hMul (HDiv.hDiv (abs x) ↑m) b₂))\nh : LE.le (abs (HSub.hSub (Real.exp x) (Real.expNear m x a₂))) (HMul.hMul (HDiv.hDiv (HPow.hPow (abs x) m) ↑m.factorial) b₂)\n⊢ LE.le (abs (HSub.hSub (Real.exp x) (Real.expNear n x a₁))) (HMul.hMul (HDiv.hDiv (HPow.hPow (abs x) n) ↑n.factorial) b₁)","decl":"theorem exp_approx_succ {n} {x a₁ b₁ : ℝ} (m : ℕ) (e₁ : n + 1 = m) (a₂ b₂ : ℝ)\n    (e : |1 + x / m * a₂ - a₁| ≤ b₁ - |x| / m * b₂)\n    (h : |exp x - expNear m x a₂| ≤ |x| ^ m / m.factorial * b₂) :\n    |exp x - expNear n x a₁| ≤ |x| ^ n / n.factorial * b₁ := by\n  refine (abs_sub_le _ _ _).trans ((add_le_add_right h _).trans ?_)\n  subst e₁; rw [expNear_succ, expNear_sub, abs_mul]\n  convert mul_le_mul_of_nonneg_left (a := |x| ^ n / ↑(Nat.factorial n))\n      (le_sub_iff_add_le'.1 e) ?_ using 1\n  · simp [mul_add, pow_succ', div_eq_mul_inv, abs_mul, abs_inv, ← pow_abs, mul_inv, Nat.factorial]\n    ac_rfl\n  · simp [div_nonneg, abs_nonneg]\n\n"}
{"name":"Real.exp_approx_end'","module":"Mathlib.Data.Complex.Exponential","initialProofState":"n : Nat\nx a b : Real\nm : Nat\ne₁ : Eq (HAdd.hAdd n 1) m\nrm : Real\ner : Eq (↑m) rm\nh : LE.le (abs x) 1\ne : LE.le (abs (HSub.hSub 1 a)) (HSub.hSub b (HMul.hMul (HDiv.hDiv (abs x) rm) (HDiv.hDiv (HAdd.hAdd rm 1) rm)))\n⊢ LE.le (abs (HSub.hSub (Real.exp x) (Real.expNear n x a))) (HMul.hMul (HDiv.hDiv (HPow.hPow (abs x) n) ↑n.factorial) b)","decl":"theorem exp_approx_end' {n} {x a b : ℝ} (m : ℕ) (e₁ : n + 1 = m) (rm : ℝ) (er : ↑m = rm)\n    (h : |x| ≤ 1) (e : |1 - a| ≤ b - |x| / rm * ((rm + 1) / rm)) :\n    |exp x - expNear n x a| ≤ |x| ^ n / n.factorial * b := by\n  subst er\n  exact exp_approx_succ _ e₁ _ _ (by simpa using e) (exp_approx_end _ _ _ e₁ h)\n\n"}
{"name":"Real.exp_1_approx_succ_eq","module":"Mathlib.Data.Complex.Exponential","initialProofState":"n : Nat\na₁ b₁ : Real\nm : Nat\nen : Eq (HAdd.hAdd n 1) m\nrm : Real\ner : Eq (↑m) rm\nh : LE.le (abs (HSub.hSub (Real.exp 1) (Real.expNear m 1 (HMul.hMul (HSub.hSub a₁ 1) rm)))) (HMul.hMul (HDiv.hDiv (HPow.hPow (abs 1) m) ↑m.factorial) (HMul.hMul b₁ rm))\n⊢ LE.le (abs (HSub.hSub (Real.exp 1) (Real.expNear n 1 a₁))) (HMul.hMul (HDiv.hDiv (HPow.hPow (abs 1) n) ↑n.factorial) b₁)","decl":"theorem exp_1_approx_succ_eq {n} {a₁ b₁ : ℝ} {m : ℕ} (en : n + 1 = m) {rm : ℝ} (er : ↑m = rm)\n    (h : |exp 1 - expNear m 1 ((a₁ - 1) * rm)| ≤ |1| ^ m / m.factorial * (b₁ * rm)) :\n    |exp 1 - expNear n 1 a₁| ≤ |1| ^ n / n.factorial * b₁ := by\n  subst er\n  refine exp_approx_succ _ en _ _ ?_ h\n  field_simp [show (m : ℝ) ≠ 0 by norm_cast; omega]\n\n"}
{"name":"Real.exp_approx_start","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x a b : Real\nh : LE.le (abs (HSub.hSub (Real.exp x) (Real.expNear 0 x a))) (HMul.hMul (HDiv.hDiv (HPow.hPow (abs x) 0) ↑(Nat.factorial 0)) b)\n⊢ LE.le (abs (HSub.hSub (Real.exp x) a)) b","decl":"theorem exp_approx_start (x a b : ℝ) (h : |exp x - expNear 0 x a| ≤ |x| ^ 0 / Nat.factorial 0 * b) :\n    |exp x - a| ≤ b := by simpa using h\n\n"}
{"name":"Real.exp_bound_div_one_sub_of_interval'","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nh1 : LT.lt 0 x\nh2 : LT.lt x 1\n⊢ LT.lt (Real.exp x) (HDiv.hDiv 1 (HSub.hSub 1 x))","decl":"theorem exp_bound_div_one_sub_of_interval' {x : ℝ} (h1 : 0 < x) (h2 : x < 1) :\n    Real.exp x < 1 / (1 - x) := by\n  have H : 0 < 1 - (1 + x + x ^ 2) * (1 - x) := calc\n    0 < x ^ 3 := by positivity\n    _ = 1 - (1 + x + x ^ 2) * (1 - x) := by ring\n  calc\n    exp x ≤ _ := exp_bound' h1.le h2.le zero_lt_three\n    _ ≤ 1 + x + x ^ 2 := by\n      -- Porting note: was `norm_num [Finset.sum] <;> nlinarith`\n      -- This proof should be restored after the norm_num plugin for big operators is ported.\n      -- (It may also need the positivity extensions in https://github.com/leanprover-community/mathlib4/pull/3907.)\n      erw [Finset.sum_range_succ]\n      repeat rw [Finset.sum_range_succ]\n      norm_num [Nat.factorial]\n      nlinarith\n    _ < 1 / (1 - x) := by rw [lt_div_iff₀] <;> nlinarith\n\n"}
{"name":"Real.exp_bound_div_one_sub_of_interval","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nh1 : LE.le 0 x\nh2 : LT.lt x 1\n⊢ LE.le (Real.exp x) (HDiv.hDiv 1 (HSub.hSub 1 x))","decl":"theorem exp_bound_div_one_sub_of_interval {x : ℝ} (h1 : 0 ≤ x) (h2 : x < 1) :\n    Real.exp x ≤ 1 / (1 - x) := by\n  rcases eq_or_lt_of_le h1 with (rfl | h1)\n  · simp\n  · exact (exp_bound_div_one_sub_of_interval' h1 h2).le\n\n"}
{"name":"Real.add_one_lt_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nhx : Ne x 0\n⊢ LT.lt (HAdd.hAdd x 1) (Real.exp x)","decl":"theorem add_one_lt_exp {x : ℝ} (hx : x ≠ 0) : x + 1 < Real.exp x := by\n  obtain hx | hx := hx.symm.lt_or_lt\n  · exact add_one_lt_exp_of_pos hx\n  obtain h' | h' := le_or_lt 1 (-x)\n  · linarith [x.exp_pos]\n  have hx' : 0 < x + 1 := by linarith\n  simpa [add_comm, exp_neg, inv_lt_inv₀ (exp_pos _) hx']\n    using exp_bound_div_one_sub_of_interval' (neg_pos.2 hx) h'\n\n"}
{"name":"Real.add_one_le_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ LE.le (HAdd.hAdd x 1) (Real.exp x)","decl":"theorem add_one_le_exp (x : ℝ) : x + 1 ≤ Real.exp x := by\n  obtain rfl | hx := eq_or_ne x 0\n  · simp\n  · exact (add_one_lt_exp hx).le\n\n"}
{"name":"Real.one_sub_lt_exp_neg","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\nhx : Ne x 0\n⊢ LT.lt (HSub.hSub 1 x) (Real.exp (Neg.neg x))","decl":"lemma one_sub_lt_exp_neg {x : ℝ} (hx : x ≠ 0) : 1 - x < exp (-x) :=\n  (sub_eq_neg_add _ _).trans_lt <| add_one_lt_exp <| neg_ne_zero.2 hx\n\n"}
{"name":"Real.one_sub_le_exp_neg","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ LE.le (HSub.hSub 1 x) (Real.exp (Neg.neg x))","decl":"lemma one_sub_le_exp_neg (x : ℝ) : 1 - x ≤ exp (-x) :=\n  (sub_eq_neg_add _ _).trans_le <| add_one_le_exp _\n\n"}
{"name":"Real.one_sub_div_pow_le_exp_neg","module":"Mathlib.Data.Complex.Exponential","initialProofState":"n : Nat\nt : Real\nht' : LE.le t ↑n\n⊢ LE.le (HPow.hPow (HSub.hSub 1 (HDiv.hDiv t ↑n)) n) (Real.exp (Neg.neg t))","decl":"theorem one_sub_div_pow_le_exp_neg {n : ℕ} {t : ℝ} (ht' : t ≤ n) : (1 - t / n) ^ n ≤ exp (-t) := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n    rwa [Nat.cast_zero] at ht'\n  calc\n    (1 - t / n) ^ n ≤ rexp (-(t / n)) ^ n := by\n      gcongr\n      · exact sub_nonneg.2 <| div_le_one_of_le₀ ht' n.cast_nonneg\n      · exact one_sub_le_exp_neg _\n    _ = rexp (-t) := by rw [← Real.exp_nat_mul, mul_neg, mul_comm, div_mul_cancel₀]; positivity\n\n"}
{"name":"Real.le_inv_mul_exp","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x c : Real\nhc : LT.lt 0 c\n⊢ LE.le x (HMul.hMul (Inv.inv c) (Real.exp (HMul.hMul c x)))","decl":"lemma le_inv_mul_exp (x : ℝ) {c : ℝ} (hc : 0 < c) : x ≤ c⁻¹ * exp (c * x) := by\n    rw [le_inv_mul_iff₀ hc]\n    calc c * x\n    _ ≤ c * x + 1 := le_add_of_nonneg_right zero_le_one\n    _ ≤ _ := Real.add_one_le_exp (c * x)\n\n"}
{"name":"Complex.abs_exp_ofReal","module":"Mathlib.Data.Complex.Exponential","initialProofState":"x : Real\n⊢ Eq (Complex.abs (Complex.exp ↑x)) (Real.exp x)","decl":"@[simp]\ntheorem abs_exp_ofReal (x : ℝ) : abs (exp x) = Real.exp x := by\n  rw [← ofReal_exp]\n  exact abs_of_nonneg (le_of_lt (Real.exp_pos _))\n\n"}
