{"name":"Urysohns.CU.mk.inj","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nC‚úù U‚úù : Set X\nP_C‚úù : P C‚úù\nclosed_C‚úù : IsClosed C‚úù\nopen_U‚úù : IsOpen U‚úù\nsubset‚úù : HasSubset.Subset C‚úù U‚úù\nhP‚úù : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí HasSubset.Subset c u ‚Üí Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\nC U : Set X\nP_C : P C\nclosed_C : IsClosed C\nopen_U : IsOpen U\nsubset : HasSubset.Subset C U\nhP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí HasSubset.Subset c u ‚Üí Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\nx‚úù : Eq { C := C‚úù, U := U‚úù, P_C := P_C‚úù, closed_C := closed_C‚úù, open_U := open_U‚úù, subset := subset‚úù, hP := hP‚úù } { C := C, U := U, P_C := P_C, closed_C := closed_C, open_U := open_U, subset := subset, hP := hP }\n‚ä¢ And (Eq C‚úù C) (Eq U‚úù U)","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X ‚Üí Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ‚äÜ U\n  protected hP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí c ‚äÜ u ‚Üí\n    ‚àÉ v, IsOpen v ‚àß c ‚äÜ v ‚àß closure v ‚äÜ u ‚àß P (closure v)\n\n"}
{"name":"Urysohns.CU.P_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nself : Urysohns.CU P\n‚ä¢ P self.C","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X ‚Üí Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ‚äÜ U\n  protected hP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí c ‚äÜ u ‚Üí\n    ‚àÉ v, IsOpen v ‚àß c ‚äÜ v ‚àß closure v ‚äÜ u ‚àß P (closure v)\n\n"}
{"name":"Urysohns.CU.mk.sizeOf_spec","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\nP : Set X ‚Üí Prop\ninst‚úù¬π : SizeOf X\ninst‚úù : (a : Set X) ‚Üí SizeOf (P a)\nC U : Set X\nP_C : P C\nclosed_C : IsClosed C\nopen_U : IsOpen U\nsubset : HasSubset.Subset C U\nhP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí HasSubset.Subset c u ‚Üí Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\n‚ä¢ Eq (SizeOf.sizeOf { C := C, U := U, P_C := P_C, closed_C := closed_C, open_U := open_U, subset := subset, hP := hP }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf P_C)) (SizeOf.sizeOf closed_C)) (SizeOf.sizeOf open_U))","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X ‚Üí Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ‚äÜ U\n  protected hP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí c ‚äÜ u ‚Üí\n    ‚àÉ v, IsOpen v ‚àß c ‚äÜ v ‚àß closure v ‚äÜ u ‚àß P (closure v)\n\n"}
{"name":"Urysohns.CU.mk.injEq","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nC‚úù U‚úù : Set X\nP_C‚úù : P C‚úù\nclosed_C‚úù : IsClosed C‚úù\nopen_U‚úù : IsOpen U‚úù\nsubset‚úù : HasSubset.Subset C‚úù U‚úù\nhP‚úù : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí HasSubset.Subset c u ‚Üí Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\nC U : Set X\nP_C : P C\nclosed_C : IsClosed C\nopen_U : IsOpen U\nsubset : HasSubset.Subset C U\nhP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí HasSubset.Subset c u ‚Üí Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\n‚ä¢ Eq (Eq { C := C‚úù, U := U‚úù, P_C := P_C‚úù, closed_C := closed_C‚úù, open_U := open_U‚úù, subset := subset‚úù, hP := hP‚úù } { C := C, U := U, P_C := P_C, closed_C := closed_C, open_U := open_U, subset := subset, hP := hP }) (And (Eq C‚úù C) (Eq U‚úù U))","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X ‚Üí Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ‚äÜ U\n  protected hP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí c ‚äÜ u ‚Üí\n    ‚àÉ v, IsOpen v ‚àß c ‚äÜ v ‚àß closure v ‚äÜ u ‚àß P (closure v)\n\n"}
{"name":"Urysohns.CU.subset","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nself : Urysohns.CU P\n‚ä¢ HasSubset.Subset self.C self.U","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X ‚Üí Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ‚äÜ U\n  protected hP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí c ‚äÜ u ‚Üí\n    ‚àÉ v, IsOpen v ‚àß c ‚äÜ v ‚àß closure v ‚äÜ u ‚àß P (closure v)\n\n"}
{"name":"Urysohns.CU.closed_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nself : Urysohns.CU P\n‚ä¢ IsClosed self.C","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X ‚Üí Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ‚äÜ U\n  protected hP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí c ‚äÜ u ‚Üí\n    ‚àÉ v, IsOpen v ‚àß c ‚äÜ v ‚àß closure v ‚äÜ u ‚àß P (closure v)\n\n"}
{"name":"Urysohns.CU.open_U","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nself : Urysohns.CU P\n‚ä¢ IsOpen self.U","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X ‚Üí Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ‚äÜ U\n  protected hP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí c ‚äÜ u ‚Üí\n    ‚àÉ v, IsOpen v ‚àß c ‚äÜ v ‚àß closure v ‚äÜ u ‚àß P (closure v)\n\n"}
{"name":"Urysohns.CU.hP","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nself : Urysohns.CU P\nc u : Set X\na‚úù¬≥ : IsClosed c\na‚úù¬≤ : P c\na‚úù¬π : IsOpen u\na‚úù : HasSubset.Subset c u\n‚ä¢ Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X ‚Üí Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ‚äÜ U\n  protected hP : ‚àÄ {c u : Set X}, IsClosed c ‚Üí P c ‚Üí IsOpen u ‚Üí c ‚äÜ u ‚Üí\n    ‚àÉ v, IsOpen v ‚àß c ‚äÜ v ‚àß closure v ‚äÜ u ‚àß P (closure v)\n\n"}
{"name":"Urysohns.CU.left_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\n‚ä¢ Eq c.left.C c.C","decl":"/-- By assumption, for each `c : CU P` there exists an open set `u`\nsuch that `c.C ‚äÜ u` and `closure u ‚äÜ c.U`. `c.left` is the pair `(c.C, u)`. -/\n@[simps C]\ndef left (c : CU P) : CU P where\n  C := c.C\n  U := (c.hP c.closed_C c.P_C c.open_U c.subset).choose\n  closed_C := c.closed_C\n  P_C := c.P_C\n  open_U := (c.hP c.closed_C c.P_C c.open_U c.subset).choose_spec.1\n  subset := (c.hP c.closed_C c.P_C c.open_U c.subset).choose_spec.2.1\n  hP := c.hP\n\n"}
{"name":"Urysohns.CU.right_U","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\n‚ä¢ Eq c.right.U c.U","decl":"/-- By assumption, for each `c : CU P` there exists an open set `u`\nsuch that `c.C ‚äÜ u` and `closure u ‚äÜ c.U`. `c.right` is the pair `(closure u, c.U)`. -/\n@[simps U]\ndef right (c : CU P) : CU P where\n  C := closure (c.hP c.closed_C c.P_C c.open_U c.subset).choose\n  U := c.U\n  closed_C := isClosed_closure\n  P_C := (c.hP c.closed_C c.P_C c.open_U c.subset).choose_spec.2.2.2\n  open_U := c.open_U\n  subset := (c.hP c.closed_C c.P_C c.open_U c.subset).choose_spec.2.2.1\n  hP := c.hP\n\n"}
{"name":"Urysohns.CU.left_U_subset_right_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\n‚ä¢ HasSubset.Subset c.left.U c.right.C","decl":"theorem left_U_subset_right_C (c : CU P) : c.left.U ‚äÜ c.right.C :=\n  subset_closure\n\n"}
{"name":"Urysohns.CU.left_U_subset","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\n‚ä¢ HasSubset.Subset c.left.U c.U","decl":"theorem left_U_subset (c : CU P) : c.left.U ‚äÜ c.U :=\n  Subset.trans c.left_U_subset_right_C c.right.subset\n\n"}
{"name":"Urysohns.CU.subset_right_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\n‚ä¢ HasSubset.Subset c.C c.right.C","decl":"theorem subset_right_C (c : CU P) : c.C ‚äÜ c.right.C :=\n  Subset.trans c.left.subset c.left_U_subset_right_C\n\n"}
{"name":"Urysohns.CU.approx_of_mem_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nn : Nat\nx : X\nhx : Membership.mem c.C x\n‚ä¢ Eq (Urysohns.CU.approx n c x) 0","decl":"theorem approx_of_mem_C (c : CU P) (n : ‚Ñï) {x : X} (hx : x ‚àà c.C) : c.approx n x = 0 := by\n  induction n generalizing c with\n  | zero => exact indicator_of_not_mem (fun (hU : x ‚àà c.U·∂ú) => hU <| c.subset hx) _\n  | succ n ihn =>\n    simp only [approx]\n    rw [ihn, ihn, midpoint_self]\n    exacts [c.subset_right_C hx, hx]\n\n"}
{"name":"Urysohns.CU.approx_of_nmem_U","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nn : Nat\nx : X\nhx : Not (Membership.mem c.U x)\n‚ä¢ Eq (Urysohns.CU.approx n c x) 1","decl":"theorem approx_of_nmem_U (c : CU P) (n : ‚Ñï) {x : X} (hx : x ‚àâ c.U) : c.approx n x = 1 := by\n  induction n generalizing c with\n  | zero =>\n    rw [‚Üê mem_compl_iff] at hx\n    exact indicator_of_mem hx _\n  | succ n ihn =>\n    simp only [approx]\n    rw [ihn, ihn, midpoint_self]\n    exacts [hx, fun hU => hx <| c.left_U_subset hU]\n\n"}
{"name":"Urysohns.CU.approx_nonneg","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nn : Nat\nx : X\n‚ä¢ LE.le 0 (Urysohns.CU.approx n c x)","decl":"theorem approx_nonneg (c : CU P) (n : ‚Ñï) (x : X) : 0 ‚â§ c.approx n x := by\n  induction n generalizing c with\n  | zero => exact indicator_nonneg (fun _ _ => zero_le_one) _\n  | succ n ihn =>\n    simp only [approx, midpoint_eq_smul_add, invOf_eq_inv]\n    refine mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg ?_ ?_) <;> apply ihn\n\n"}
{"name":"Urysohns.CU.approx_le_one","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nn : Nat\nx : X\n‚ä¢ LE.le (Urysohns.CU.approx n c x) 1","decl":"theorem approx_le_one (c : CU P) (n : ‚Ñï) (x : X) : c.approx n x ‚â§ 1 := by\n  induction n generalizing c with\n  | zero => exact indicator_apply_le' (fun _ => le_rfl) fun _ => zero_le_one\n  | succ n ihn =>\n    simp only [approx, midpoint_eq_smul_add, invOf_eq_inv, smul_eq_mul, ‚Üê div_eq_inv_mul]\n    have := add_le_add (ihn (left c)) (ihn (right c))\n    norm_num at this\n    exact Iff.mpr (div_le_one zero_lt_two) this\n\n"}
{"name":"Urysohns.CU.bddAbove_range_approx","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\n‚ä¢ BddAbove (Set.range fun n => Urysohns.CU.approx n c x)","decl":"theorem bddAbove_range_approx (c : CU P) (x : X) : BddAbove (range fun n => c.approx n x) :=\n  ‚ü®1, fun _ ‚ü®n, hn‚ü© => hn ‚ñ∏ c.approx_le_one n x‚ü©\n\n"}
{"name":"Urysohns.CU.approx_le_approx_of_U_sub_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc‚ÇÅ c‚ÇÇ : Urysohns.CU P\nh : HasSubset.Subset c‚ÇÅ.U c‚ÇÇ.C\nn‚ÇÅ n‚ÇÇ : Nat\nx : X\n‚ä¢ LE.le (Urysohns.CU.approx n‚ÇÇ c‚ÇÇ x) (Urysohns.CU.approx n‚ÇÅ c‚ÇÅ x)","decl":"theorem approx_le_approx_of_U_sub_C {c‚ÇÅ c‚ÇÇ : CU P} (h : c‚ÇÅ.U ‚äÜ c‚ÇÇ.C) (n‚ÇÅ n‚ÇÇ : ‚Ñï) (x : X) :\n    c‚ÇÇ.approx n‚ÇÇ x ‚â§ c‚ÇÅ.approx n‚ÇÅ x := by\n  by_cases hx : x ‚àà c‚ÇÅ.U\n  ¬∑ calc\n      approx n‚ÇÇ c‚ÇÇ x = 0 := approx_of_mem_C _ _ (h hx)\n      _ ‚â§ approx n‚ÇÅ c‚ÇÅ x := approx_nonneg _ _ _\n  ¬∑ calc\n      approx n‚ÇÇ c‚ÇÇ x ‚â§ 1 := approx_le_one _ _ _\n      _ = approx n‚ÇÅ c‚ÇÅ x := (approx_of_nmem_U _ _ hx).symm\n\n"}
{"name":"Urysohns.CU.approx_mem_Icc_right_left","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nn : Nat\nx : X\n‚ä¢ Membership.mem (Set.Icc (Urysohns.CU.approx n c.right x) (Urysohns.CU.approx n c.left x)) (Urysohns.CU.approx n c x)","decl":"theorem approx_mem_Icc_right_left (c : CU P) (n : ‚Ñï) (x : X) :\n    c.approx n x ‚àà Icc (c.right.approx n x) (c.left.approx n x) := by\n  induction' n with n ihn generalizing c\n  ¬∑ exact ‚ü®le_rfl, indicator_le_indicator_of_subset (compl_subset_compl.2 c.left_U_subset)\n      (fun _ => zero_le_one) _‚ü©\n  ¬∑ simp only [approx, mem_Icc]\n    refine ‚ü®midpoint_le_midpoint ?_ (ihn _).1, midpoint_le_midpoint (ihn _).2 ?_‚ü© <;>\n      apply approx_le_approx_of_U_sub_C\n    exacts [subset_closure, subset_closure]\n\n"}
{"name":"Urysohns.CU.approx_le_succ","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nn : Nat\nx : X\n‚ä¢ LE.le (Urysohns.CU.approx n c x) (Urysohns.CU.approx (HAdd.hAdd n 1) c x)","decl":"theorem approx_le_succ (c : CU P) (n : ‚Ñï) (x : X) : c.approx n x ‚â§ c.approx (n + 1) x := by\n  induction' n with n ihn generalizing c\n  ¬∑ simp only [approx, right_U, right_le_midpoint]\n    exact (approx_mem_Icc_right_left c 0 x).2\n  ¬∑ rw [approx, approx]\n    exact midpoint_le_midpoint (ihn _) (ihn _)\n\n"}
{"name":"Urysohns.CU.approx_mono","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\n‚ä¢ Monotone fun n => Urysohns.CU.approx n c x","decl":"theorem approx_mono (c : CU P) (x : X) : Monotone fun n => c.approx n x :=\n  monotone_nat_of_le_succ fun n => c.approx_le_succ n x\n\n"}
{"name":"Urysohns.CU.tendsto_approx_atTop","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\n‚ä¢ Filter.Tendsto (fun n => Urysohns.CU.approx n c x) Filter.atTop (nhds (c.lim x))","decl":"theorem tendsto_approx_atTop (c : CU P) (x : X) :\n    Tendsto (fun n => c.approx n x) atTop (ùìù <| c.lim x) :=\n  tendsto_atTop_ciSup (c.approx_mono x) ‚ü®1, fun _ ‚ü®_, hn‚ü© => hn ‚ñ∏ c.approx_le_one _ _‚ü©\n\n"}
{"name":"Urysohns.CU.lim_of_mem_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\nh : Membership.mem c.C x\n‚ä¢ Eq (c.lim x) 0","decl":"theorem lim_of_mem_C (c : CU P) (x : X) (h : x ‚àà c.C) : c.lim x = 0 := by\n  simp only [CU.lim, approx_of_mem_C, h, ciSup_const]\n\n"}
{"name":"Urysohns.CU.disjoint_C_support_lim","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\n‚ä¢ Disjoint c.C (Function.support c.lim)","decl":"theorem disjoint_C_support_lim (c : CU P) : Disjoint c.C (Function.support c.lim) :=\n  Function.disjoint_support_iff.mpr (fun x hx => lim_of_mem_C c x hx)\n\n"}
{"name":"Urysohns.CU.lim_of_nmem_U","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\nh : Not (Membership.mem c.U x)\n‚ä¢ Eq (c.lim x) 1","decl":"theorem lim_of_nmem_U (c : CU P) (x : X) (h : x ‚àâ c.U) : c.lim x = 1 := by\n  simp only [CU.lim, approx_of_nmem_U c _ h, ciSup_const]\n\n"}
{"name":"Urysohns.CU.lim_eq_midpoint","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\n‚ä¢ Eq (c.lim x) (midpoint Real (c.left.lim x) (c.right.lim x))","decl":"theorem lim_eq_midpoint (c : CU P) (x : X) :\n    c.lim x = midpoint ‚Ñù (c.left.lim x) (c.right.lim x) := by\n  refine tendsto_nhds_unique (c.tendsto_approx_atTop x) ((tendsto_add_atTop_iff_nat 1).1 ?_)\n  simp only [approx]\n  exact (c.left.tendsto_approx_atTop x).midpoint (c.right.tendsto_approx_atTop x)\n\n"}
{"name":"Urysohns.CU.approx_le_lim","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\nn : Nat\n‚ä¢ LE.le (Urysohns.CU.approx n c x) (c.lim x)","decl":"theorem approx_le_lim (c : CU P) (x : X) (n : ‚Ñï) : c.approx n x ‚â§ c.lim x :=\n  le_ciSup (c.bddAbove_range_approx x) _\n\n"}
{"name":"Urysohns.CU.lim_nonneg","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\n‚ä¢ LE.le 0 (c.lim x)","decl":"theorem lim_nonneg (c : CU P) (x : X) : 0 ‚â§ c.lim x :=\n  (c.approx_nonneg 0 x).trans (c.approx_le_lim x 0)\n\n"}
{"name":"Urysohns.CU.lim_le_one","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\n‚ä¢ LE.le (c.lim x) 1","decl":"theorem lim_le_one (c : CU P) (x : X) : c.lim x ‚â§ 1 :=\n  ciSup_le fun _ => c.approx_le_one _ _\n\n"}
{"name":"Urysohns.CU.lim_mem_Icc","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\nx : X\n‚ä¢ Membership.mem (Set.Icc 0 1) (c.lim x)","decl":"theorem lim_mem_Icc (c : CU P) (x : X) : c.lim x ‚àà Icc (0 : ‚Ñù) 1 :=\n  ‚ü®c.lim_nonneg x, c.lim_le_one x‚ü©\n\n"}
{"name":"Urysohns.CU.continuous_lim","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nP : Set X ‚Üí Prop\nc : Urysohns.CU P\n‚ä¢ Continuous c.lim","decl":"/-- Continuity of `Urysohns.CU.lim`. See module docstring for a sketch of the proofs. -/\ntheorem continuous_lim (c : CU P) : Continuous c.lim := by\n  obtain ‚ü®h0, h1234, h1‚ü© : 0 < (2‚Åª¬π : ‚Ñù) ‚àß (2‚Åª¬π : ‚Ñù) < 3 / 4 ‚àß (3 / 4 : ‚Ñù) < 1 := by norm_num\n  refine\n    continuous_iff_continuousAt.2 fun x =>\n      (Metric.nhds_basis_closedBall_pow (h0.trans h1234) h1).tendsto_right_iff.2 fun n _ => ?_\n  simp only [Metric.mem_closedBall]\n  induction' n with n ihn generalizing c\n  ¬∑ filter_upwards with y\n    rw [pow_zero]\n    exact Real.dist_le_of_mem_Icc_01 (c.lim_mem_Icc _) (c.lim_mem_Icc _)\n  ¬∑ by_cases hxl : x ‚àà c.left.U\n    ¬∑ filter_upwards [IsOpen.mem_nhds c.left.open_U hxl, ihn c.left] with _ hyl hyd\n      rw [pow_succ', c.lim_eq_midpoint, c.lim_eq_midpoint,\n        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hyl),\n        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hxl)]\n      refine (dist_midpoint_midpoint_le _ _ _ _).trans ?_\n      rw [dist_self, add_zero, div_eq_inv_mul]\n      gcongr\n    ¬∑ replace hxl : x ‚àà c.left.right.C·∂ú :=\n        compl_subset_compl.2 c.left.right.subset hxl\n      filter_upwards [IsOpen.mem_nhds (isOpen_compl_iff.2 c.left.right.closed_C) hxl,\n        ihn c.left.right, ihn c.right] with y hyl hydl hydr\n      replace hxl : x ‚àâ c.left.left.U :=\n        compl_subset_compl.2 c.left.left_U_subset_right_C hxl\n      replace hyl : y ‚àâ c.left.left.U :=\n        compl_subset_compl.2 c.left.left_U_subset_right_C hyl\n      simp only [pow_succ, c.lim_eq_midpoint, c.left.lim_eq_midpoint,\n        c.left.left.lim_of_nmem_U _ hxl, c.left.left.lim_of_nmem_U _ hyl]\n      refine (dist_midpoint_midpoint_le _ _ _ _).trans ?_\n      refine (div_le_div_of_nonneg_right (add_le_add_right (dist_midpoint_midpoint_le _ _ _ _) _)\n        zero_le_two).trans ?_\n      rw [dist_self, zero_add]\n      set r := (3 / 4 : ‚Ñù) ^ n\n      calc _ ‚â§ (r / 2 + r) / 2 := by gcongr\n        _ = _ := by field_simp; ring\n\n"}
{"name":"exists_continuous_zero_one_of_isClosed","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsClosed t\nhd : Disjoint s t\n‚ä¢ Exists fun f => And (Set.EqOn (‚áëf) 0 s) (And (Set.EqOn (‚áëf) 1 t) (‚àÄ (x : X), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nthen there exists a continuous function `f : X ‚Üí ‚Ñù` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ‚â§ f x ‚â§ 1` for all `x`.\n-/\ntheorem exists_continuous_zero_one_of_isClosed [NormalSpace X]\n    {s t : Set X} (hs : IsClosed s) (ht : IsClosed t)\n    (hd : Disjoint s t) : ‚àÉ f : C(X, ‚Ñù), EqOn f 0 s ‚àß EqOn f 1 t ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by\n  -- The actual proof is in the code above. Here we just repack it into the expected format.\n  let P : Set X ‚Üí Prop := fun _ ‚Ü¶ True\n  set c : Urysohns.CU P :=\n  { C := s\n    U := t·∂ú\n    P_C := trivial\n    closed_C := hs\n    open_U := ht.isOpen_compl\n    subset := disjoint_left.1 hd\n    hP := by\n      rintro c u c_closed - u_open cu\n      rcases normal_exists_closure_subset c_closed u_open cu with ‚ü®v, v_open, cv, hv‚ü©\n      exact ‚ü®v, v_open, cv, hv, trivial‚ü© }\n  exact ‚ü®‚ü®c.lim, c.continuous_lim‚ü©, c.lim_of_mem_C, fun x hx => c.lim_of_nmem_U _ fun h => h hx,\n    c.lim_mem_Icc‚ü©\n\n"}
{"name":"exists_continuous_zero_one_of_isCompact","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : RegularSpace X\ninst‚úù : LocallyCompactSpace X\ns t : Set X\nhs : IsCompact s\nht : IsClosed t\nhd : Disjoint s t\n‚ä¢ Exists fun f => And (Set.EqOn (‚áëf) 0 s) (And (Set.EqOn (‚áëf) 1 t) (‚àÄ (x : X), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint sets in a regular locally compact topological\nspace `X`, with `s` compact and `t` closed, then there exists a continuous\nfunction `f : X ‚Üí ‚Ñù` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ‚â§ f x ‚â§ 1` for all `x`.\n-/\ntheorem exists_continuous_zero_one_of_isCompact [RegularSpace X] [LocallyCompactSpace X]\n    {s t : Set X} (hs : IsCompact s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ‚àÉ f : C(X, ‚Ñù), EqOn f 0 s ‚àß EqOn f 1 t ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by\n  obtain ‚ü®k, k_comp, k_closed, sk, kt‚ü© : ‚àÉ k, IsCompact k ‚àß IsClosed k ‚àß s ‚äÜ interior k ‚àß k ‚äÜ t·∂ú :=\n    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left\n  let P : Set X ‚Üí Prop := IsCompact\n  set c : Urysohns.CU P :=\n  { C := k\n    U := t·∂ú\n    P_C := k_comp\n    closed_C := k_closed\n    open_U := ht.isOpen_compl\n    subset := kt\n    hP := by\n      rintro c u - c_comp u_open cu\n      rcases exists_compact_closed_between c_comp u_open cu with ‚ü®k, k_comp, k_closed, ck, ku‚ü©\n      have A : closure (interior k) ‚äÜ k :=\n        (IsClosed.closure_subset_iff k_closed).2 interior_subset\n      refine ‚ü®interior k, isOpen_interior, ck, A.trans ku,\n        k_comp.of_isClosed_subset isClosed_closure A‚ü© }\n  exact ‚ü®‚ü®c.lim, c.continuous_lim‚ü©, fun x hx ‚Ü¶ c.lim_of_mem_C _ (sk.trans interior_subset hx),\n    fun x hx => c.lim_of_nmem_U _ fun h => h hx, c.lim_mem_Icc‚ü©\n\n"}
{"name":"exists_continuous_zero_one_of_isCompact'","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : RegularSpace X\ninst‚úù : LocallyCompactSpace X\ns t : Set X\nhs : IsCompact s\nht : IsClosed t\nhd : Disjoint s t\n‚ä¢ Exists fun f => And (Set.EqOn (‚áëf) 0 t) (And (Set.EqOn (‚áëf) 1 s) (‚àÄ (x : X), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint sets in a regular locally compact topological\nspace `X`, with `s` compact and `t` closed, then there exists a continuous\nfunction `f : X ‚Üí ‚Ñù` such that\n\n* `f` equals zero on `t`;\n* `f` equals one on `s`;\n* `0 ‚â§ f x ‚â§ 1` for all `x`.\n-/\ntheorem exists_continuous_zero_one_of_isCompact' [RegularSpace X] [LocallyCompactSpace X]\n    {s t : Set X} (hs : IsCompact s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ‚àÉ f : C(X, ‚Ñù), EqOn f 0 t ‚àß EqOn f 1 s ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by\n  obtain ‚ü®g, hgs, hgt, (hicc : ‚àÄ x, 0 ‚â§ g x ‚àß g x ‚â§ 1)‚ü© := exists_continuous_zero_one_of_isCompact\n    hs ht hd\n  use 1 - g\n  refine ‚ü®?_, ?_, ?_‚ü©\n  ¬∑ intro x hx\n    simp only [ContinuousMap.sub_apply, ContinuousMap.one_apply, Pi.zero_apply]\n    exact sub_eq_zero_of_eq (id (EqOn.symm hgt) hx)\n  ¬∑ intro x hx\n    simp only [ContinuousMap.sub_apply, ContinuousMap.one_apply, Pi.one_apply, sub_eq_self]\n    exact hgs hx\n  ¬∑ intro x\n    simpa [and_comm] using hicc x\n\n"}
{"name":"exists_continuous_one_zero_of_isCompact","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : RegularSpace X\ninst‚úù : LocallyCompactSpace X\ns t : Set X\nhs : IsCompact s\nht : IsClosed t\nhd : Disjoint s t\n‚ä¢ Exists fun f => And (Set.EqOn (‚áëf) 1 s) (And (Set.EqOn (‚áëf) 0 t) (And (HasCompactSupport ‚áëf) (‚àÄ (x : X), Membership.mem (Set.Icc 0 1) (f x))))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint sets in a regular locally compact topological\nspace `X`, with `s` compact and `t` closed, then there exists a continuous compactly supported\nfunction `f : X ‚Üí ‚Ñù` such that\n\n* `f` equals one on `s`;\n* `f` equals zero on `t`;\n* `0 ‚â§ f x ‚â§ 1` for all `x`.\n-/\ntheorem exists_continuous_one_zero_of_isCompact [RegularSpace X] [LocallyCompactSpace X]\n    {s t : Set X} (hs : IsCompact s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ‚àÉ f : C(X, ‚Ñù), EqOn f 1 s ‚àß EqOn f 0 t ‚àß HasCompactSupport f ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by\n  obtain ‚ü®k, k_comp, k_closed, sk, kt‚ü© : ‚àÉ k, IsCompact k ‚àß IsClosed k ‚àß s ‚äÜ interior k ‚àß k ‚äÜ t·∂ú :=\n    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left\n  rcases exists_continuous_zero_one_of_isCompact hs isOpen_interior.isClosed_compl\n    (disjoint_compl_right_iff_subset.mpr sk) with ‚ü®‚ü®f, hf‚ü©, hfs, hft, h'f‚ü©\n  have A : t ‚äÜ (interior k)·∂ú := subset_compl_comm.mpr (interior_subset.trans kt)\n  refine ‚ü®‚ü®fun x ‚Ü¶ 1 - f x, continuous_const.sub hf‚ü©, fun x hx ‚Ü¶ by simpa using hfs hx,\n    fun x hx ‚Ü¶ by simpa [sub_eq_zero] using (hft (A hx)).symm, ?_, fun x ‚Ü¶ ?_‚ü©\n  ¬∑ apply HasCompactSupport.intro' k_comp k_closed (fun x hx ‚Ü¶ ?_)\n    simp only [ContinuousMap.coe_mk, sub_eq_zero]\n    apply (hft _).symm\n    contrapose! hx\n    simp only [mem_compl_iff, not_not] at hx\n    exact interior_subset hx\n  ¬∑ have : 0 ‚â§ f x ‚àß f x ‚â§ 1 := by simpa using h'f x\n    simp [this]\n\n"}
{"name":"exists_continuous_one_zero_of_isCompact_of_isGŒ¥","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : RegularSpace X\ninst‚úù : LocallyCompactSpace X\ns t : Set X\nhs : IsCompact s\nh's : IsGŒ¥ s\nht : IsClosed t\nhd : Disjoint s t\n‚ä¢ Exists fun f => And (Eq s (Set.preimage (‚áëf) (Singleton.singleton 1))) (And (Set.EqOn (‚áëf) 0 t) (And (HasCompactSupport ‚áëf) (‚àÄ (x : X), Membership.mem (Set.Icc 0 1) (f x))))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint sets in a regular locally compact topological\nspace `X`, with `s` compact and `t` closed, then there exists a continuous compactly supported\nfunction `f : X ‚Üí ‚Ñù` such that\n\n* `f` equals one on `s`;\n* `f` equals zero on `t`;\n* `0 ‚â§ f x ‚â§ 1` for all `x`.\n\nMoreover, if `s` is GŒ¥, one can ensure that `f ‚Åª¬π {1}` is exactly `s`.\n-/\ntheorem exists_continuous_one_zero_of_isCompact_of_isGŒ¥ [RegularSpace X] [LocallyCompactSpace X]\n    {s t : Set X} (hs : IsCompact s) (h's : IsGŒ¥ s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ‚àÉ f : C(X, ‚Ñù), s = f ‚Åª¬π' {1} ‚àß EqOn f 0 t ‚àß HasCompactSupport f\n      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by\n  rcases h's.eq_iInter_nat with ‚ü®U, U_open, hU‚ü©\n  obtain ‚ü®m, m_comp, -, sm, mt‚ü© : ‚àÉ m, IsCompact m ‚àß IsClosed m ‚àß s ‚äÜ interior m ‚àß m ‚äÜ t·∂ú :=\n    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left\n  have A n : ‚àÉ f : C(X, ‚Ñù), EqOn f 1 s ‚àß EqOn f 0 (U n ‚à© interior m)·∂ú ‚àß HasCompactSupport f\n      ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by\n    apply exists_continuous_one_zero_of_isCompact hs\n      ((U_open n).inter isOpen_interior).isClosed_compl\n    rw [disjoint_compl_right_iff_subset]\n    exact subset_inter ((hU.subset.trans (iInter_subset U n))) sm\n  choose f fs fm _hf f_range using A\n  obtain ‚ü®u, u_pos, u_sum, hu‚ü© : ‚àÉ (u : ‚Ñï ‚Üí ‚Ñù), (‚àÄ i, 0 < u i) ‚àß Summable u ‚àß ‚àë' i, u i = 1 :=\n    ‚ü®fun n ‚Ü¶ 1/2/2^n, fun n ‚Ü¶ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1‚ü©\n  let g : X ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë' n, u n * f n x\n  have hgmc : EqOn g 0 m·∂ú := by\n    intro x hx\n    have B n : f n x = 0 := by\n      have : m·∂ú ‚äÜ (U n ‚à© interior m)·∂ú := by\n        simpa using inter_subset_right.trans interior_subset\n      exact fm n (this hx)\n    simp [g, B]\n  have I n x : u n * f n x ‚â§ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2\n  have S x : Summable (fun n ‚Ü¶ u n * f n x) := Summable.of_nonneg_of_le\n      (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ‚Ü¶ I n x) u_sum\n  refine ‚ü®‚ü®g, ?_‚ü©, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©\n  ¬∑ apply continuous_tsum (fun n ‚Ü¶ continuous_const.mul (f n).continuous) u_sum (fun n x ‚Ü¶ ?_)\n    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x\n  ¬∑ apply Subset.antisymm (fun x hx ‚Ü¶ by simp [g, fs _ hx, hu]) ?_\n    apply compl_subset_compl.1\n    intro x hx\n    obtain ‚ü®n, hn‚ü© : ‚àÉ n, x ‚àâ U n := by simpa [hU] using hx\n    have fnx : f n x = 0 := fm _ (by simp [hn])\n    have : g x < 1 := by\n      apply lt_of_lt_of_le ?_ hu.le\n      exact tsum_lt_tsum (i := n) (fun i ‚Ü¶ I i x) (by simp [fnx, u_pos n]) (S x) u_sum\n    simpa using this.ne\n  ¬∑ exact HasCompactSupport.of_support_subset_isCompact m_comp\n      (Function.support_subset_iff'.mpr hgmc)\n  ¬∑ exact tsum_nonneg (fun n ‚Ü¶ mul_nonneg (u_pos n).le (f_range n x).1)\n  ¬∑ apply le_trans _ hu.le\n    exact tsum_le_tsum (fun n ‚Ü¶ I n x) (S x) u_sum\n\n"}
{"name":"exists_tsupport_one_of_isOpen_isClosed","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T2Space X\ns t : Set X\nhs : IsOpen s\nhscp : IsCompact (closure s)\nht : IsClosed t\nhst : HasSubset.Subset t s\n‚ä¢ Exists fun f => And (HasSubset.Subset (tsupport ‚áëf) s) (And (Set.EqOn (‚áëf) 1 t) (‚àÄ (x : X), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- A variation of Urysohn's lemma. In a `T2Space X`, for a closed set `t` and a relatively\ncompact open set `s` such that `t ‚äÜ s`, there is a continuous function `f` supported in `s`,\n`f x = 1` on `t` and `0 ‚â§ f x ‚â§ 1`. -/\nlemma exists_tsupport_one_of_isOpen_isClosed [T2Space X] {s t : Set X}\n    (hs : IsOpen s) (hscp : IsCompact (closure s)) (ht : IsClosed t) (hst : t ‚äÜ s) :\n    ‚àÉ f : C(X, ‚Ñù), tsupport f ‚äÜ s ‚àß EqOn f 1 t ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by\n-- separate `s·∂ú` and `t` by `u` and `v`.\n  rw [‚Üê compl_compl s] at hscp\n  obtain ‚ü®u, v, huIsOpen, hvIsOpen, hscompl_subset_u, ht_subset_v, hDjsjointuv‚ü© :=\n    SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed (isClosed_compl_iff.mpr hs)\n    hscp ht (HasSubset.Subset.disjoint_compl_left hst)\n  rw [‚Üê subset_compl_iff_disjoint_right] at hDjsjointuv\n  have huvc : closure u ‚äÜ v·∂ú := closure_minimal hDjsjointuv hvIsOpen.isClosed_compl\n-- although `s·∂ú` is not compact, `closure s` is compact and we can apply\n-- `SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed`. To apply the condition\n-- recursively, we need to make sure that `s·∂ú ‚äÜ C`.\n  let P : Set X ‚Üí Prop := fun C => s·∂ú ‚äÜ C\n  set c : Urysohns.CU P :=\n  { C := closure u\n    U := t·∂ú\n    P_C := hscompl_subset_u.trans subset_closure\n    closed_C := isClosed_closure\n    open_U := ht.isOpen_compl\n    subset := subset_compl_comm.mp\n      (Subset.trans ht_subset_v (subset_compl_comm.mp huvc))\n    hP := by\n      intro c u0 cIsClosed Pc u0IsOpen csubu0\n      obtain ‚ü®u1, hu1‚ü© := SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed cIsClosed\n        (IsCompact.of_isClosed_subset hscp isClosed_closure\n        (closure_mono (compl_subset_compl.mpr Pc)))\n        (isClosed_compl_iff.mpr u0IsOpen) (HasSubset.Subset.disjoint_compl_right csubu0)\n      simp_rw [‚Üê subset_compl_iff_disjoint_right, compl_subset_comm (s := u0)] at hu1\n      obtain ‚ü®v1, hu1, hv1, hcu1, hv1u, hu1v1‚ü© := hu1\n      refine ‚ü®u1, hu1, hcu1, ?_, (Pc.trans hcu1).trans subset_closure‚ü©\n      exact closure_minimal hu1v1 hv1.isClosed_compl |>.trans hv1u }\n-- `c.lim = 0` on `closure u` and `c.lim = 1` on `t`, so that `tsupport c.lim ‚äÜ s`.\n  use ‚ü®c.lim, c.continuous_lim‚ü©\n  simp only [ContinuousMap.coe_mk]\n  refine ‚ü®?_, ?_, Urysohns.CU.lim_mem_Icc c‚ü©\n  ¬∑ apply Subset.trans _ (compl_subset_comm.mp hscompl_subset_u)\n    rw [‚Üê IsClosed.closure_eq (isClosed_compl_iff.mpr huIsOpen)]\n    apply closure_mono\n    exact Disjoint.subset_compl_right (disjoint_of_subset_right subset_closure\n      (Disjoint.symm (Urysohns.CU.disjoint_C_support_lim c)))\n  ¬∑ intro x hx\n    apply Urysohns.CU.lim_of_nmem_U\n    exact not_mem_compl_iff.mpr hx\n\n"}
{"name":"exists_continuous_nonneg_pos","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : RegularSpace X\ninst‚úù : LocallyCompactSpace X\nx : X\n‚ä¢ Exists fun f => And (HasCompactSupport ‚áëf) (And (LE.le 0 ‚áëf) (Ne (f x) 0))","decl":"theorem exists_continuous_nonneg_pos [RegularSpace X] [LocallyCompactSpace X] (x : X) :\n    ‚àÉ f : C(X, ‚Ñù), HasCompactSupport f ‚àß 0 ‚â§ (f : X ‚Üí ‚Ñù) ‚àß f x ‚â† 0 := by\n  rcases exists_compact_mem_nhds x with ‚ü®k, hk, k_mem‚ü©\n  rcases exists_continuous_one_zero_of_isCompact hk isClosed_empty (disjoint_empty k)\n    with ‚ü®f, fk, -, f_comp, hf‚ü©\n  refine ‚ü®f, f_comp, fun x ‚Ü¶ (hf x).1, ?_‚ü©\n  have := fk (mem_of_mem_nhds k_mem)\n  simp only [ContinuousMap.coe_mk, Pi.one_apply] at this\n  simp [this]\n"}
