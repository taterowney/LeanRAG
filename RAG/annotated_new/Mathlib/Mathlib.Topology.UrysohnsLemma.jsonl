{"name":"Urysohns.CU.mk.inj","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nC✝ U✝ : Set X\nP_C✝ : P C✝\nclosed_C✝ : IsClosed C✝\nopen_U✝ : IsOpen U✝\nsubset✝ : HasSubset.Subset C✝ U✝\nhP✝ : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → HasSubset.Subset c u → Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\nC U : Set X\nP_C : P C\nclosed_C : IsClosed C\nopen_U : IsOpen U\nsubset : HasSubset.Subset C U\nhP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → HasSubset.Subset c u → Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\nx✝ : Eq { C := C✝, U := U✝, P_C := P_C✝, closed_C := closed_C✝, open_U := open_U✝, subset := subset✝, hP := hP✝ } { C := C, U := U, P_C := P_C, closed_C := closed_C, open_U := open_U, subset := subset, hP := hP }\n⊢ And (Eq C✝ C) (Eq U✝ U)","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X → Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ⊆ U\n  protected hP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → c ⊆ u →\n    ∃ v, IsOpen v ∧ c ⊆ v ∧ closure v ⊆ u ∧ P (closure v)\n\n"}
{"name":"Urysohns.CU.P_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nself : Urysohns.CU P\n⊢ P self.C","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X → Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ⊆ U\n  protected hP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → c ⊆ u →\n    ∃ v, IsOpen v ∧ c ⊆ v ∧ closure v ⊆ u ∧ P (closure v)\n\n"}
{"name":"Urysohns.CU.mk.sizeOf_spec","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst✝² : TopologicalSpace X\nP : Set X → Prop\ninst✝¹ : SizeOf X\ninst✝ : (a : Set X) → SizeOf (P a)\nC U : Set X\nP_C : P C\nclosed_C : IsClosed C\nopen_U : IsOpen U\nsubset : HasSubset.Subset C U\nhP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → HasSubset.Subset c u → Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\n⊢ Eq (SizeOf.sizeOf { C := C, U := U, P_C := P_C, closed_C := closed_C, open_U := open_U, subset := subset, hP := hP }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf P_C)) (SizeOf.sizeOf closed_C)) (SizeOf.sizeOf open_U))","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X → Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ⊆ U\n  protected hP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → c ⊆ u →\n    ∃ v, IsOpen v ∧ c ⊆ v ∧ closure v ⊆ u ∧ P (closure v)\n\n"}
{"name":"Urysohns.CU.mk.injEq","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nC✝ U✝ : Set X\nP_C✝ : P C✝\nclosed_C✝ : IsClosed C✝\nopen_U✝ : IsOpen U✝\nsubset✝ : HasSubset.Subset C✝ U✝\nhP✝ : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → HasSubset.Subset c u → Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\nC U : Set X\nP_C : P C\nclosed_C : IsClosed C\nopen_U : IsOpen U\nsubset : HasSubset.Subset C U\nhP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → HasSubset.Subset c u → Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))\n⊢ Eq (Eq { C := C✝, U := U✝, P_C := P_C✝, closed_C := closed_C✝, open_U := open_U✝, subset := subset✝, hP := hP✝ } { C := C, U := U, P_C := P_C, closed_C := closed_C, open_U := open_U, subset := subset, hP := hP }) (And (Eq C✝ C) (Eq U✝ U))","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X → Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ⊆ U\n  protected hP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → c ⊆ u →\n    ∃ v, IsOpen v ∧ c ⊆ v ∧ closure v ⊆ u ∧ P (closure v)\n\n"}
{"name":"Urysohns.CU.subset","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nself : Urysohns.CU P\n⊢ HasSubset.Subset self.C self.U","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X → Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ⊆ U\n  protected hP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → c ⊆ u →\n    ∃ v, IsOpen v ∧ c ⊆ v ∧ closure v ⊆ u ∧ P (closure v)\n\n"}
{"name":"Urysohns.CU.closed_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nself : Urysohns.CU P\n⊢ IsClosed self.C","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X → Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ⊆ U\n  protected hP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → c ⊆ u →\n    ∃ v, IsOpen v ∧ c ⊆ v ∧ closure v ⊆ u ∧ P (closure v)\n\n"}
{"name":"Urysohns.CU.open_U","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nself : Urysohns.CU P\n⊢ IsOpen self.U","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X → Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ⊆ U\n  protected hP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → c ⊆ u →\n    ∃ v, IsOpen v ∧ c ⊆ v ∧ closure v ⊆ u ∧ P (closure v)\n\n"}
{"name":"Urysohns.CU.hP","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nself : Urysohns.CU P\nc u : Set X\na✝³ : IsClosed c\na✝² : P c\na✝¹ : IsOpen u\na✝ : HasSubset.Subset c u\n⊢ Exists fun v => And (IsOpen v) (And (HasSubset.Subset c v) (And (HasSubset.Subset (closure v) u) (P (closure v))))","decl":"/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its\nopen neighborhood `U`, together with the assumption that `C` satisfies the property `P C`. The\nlatter assumption will make it possible to prove simultaneously both versions of Urysohn's lemma,\nin normal spaces (with `P` always true) and in locally compact spaces (with `P = IsCompact`).\nWe put also in the structure the assumption that, for any such pair, one may find an intermediate\npair in between satisfying `P`, to avoid carrying it around in the argument. -/\nstructure CU {X : Type*} [TopologicalSpace X] (P : Set X → Prop) where\n  /-- The inner set in the inductive construction towards Urysohn's lemma -/\n  protected C : Set X\n  /-- The outer set in the inductive construction towards Urysohn's lemma -/\n  protected U : Set X\n  protected P_C : P C\n  protected closed_C : IsClosed C\n  protected open_U : IsOpen U\n  protected subset : C ⊆ U\n  protected hP : ∀ {c u : Set X}, IsClosed c → P c → IsOpen u → c ⊆ u →\n    ∃ v, IsOpen v ∧ c ⊆ v ∧ closure v ⊆ u ∧ P (closure v)\n\n"}
{"name":"Urysohns.CU.left_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\n⊢ Eq c.left.C c.C","decl":"/-- By assumption, for each `c : CU P` there exists an open set `u`\nsuch that `c.C ⊆ u` and `closure u ⊆ c.U`. `c.left` is the pair `(c.C, u)`. -/\n@[simps C]\ndef left (c : CU P) : CU P where\n  C := c.C\n  U := (c.hP c.closed_C c.P_C c.open_U c.subset).choose\n  closed_C := c.closed_C\n  P_C := c.P_C\n  open_U := (c.hP c.closed_C c.P_C c.open_U c.subset).choose_spec.1\n  subset := (c.hP c.closed_C c.P_C c.open_U c.subset).choose_spec.2.1\n  hP := c.hP\n\n"}
{"name":"Urysohns.CU.right_U","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\n⊢ Eq c.right.U c.U","decl":"/-- By assumption, for each `c : CU P` there exists an open set `u`\nsuch that `c.C ⊆ u` and `closure u ⊆ c.U`. `c.right` is the pair `(closure u, c.U)`. -/\n@[simps U]\ndef right (c : CU P) : CU P where\n  C := closure (c.hP c.closed_C c.P_C c.open_U c.subset).choose\n  U := c.U\n  closed_C := isClosed_closure\n  P_C := (c.hP c.closed_C c.P_C c.open_U c.subset).choose_spec.2.2.2\n  open_U := c.open_U\n  subset := (c.hP c.closed_C c.P_C c.open_U c.subset).choose_spec.2.2.1\n  hP := c.hP\n\n"}
{"name":"Urysohns.CU.left_U_subset_right_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\n⊢ HasSubset.Subset c.left.U c.right.C","decl":"theorem left_U_subset_right_C (c : CU P) : c.left.U ⊆ c.right.C :=\n  subset_closure\n\n"}
{"name":"Urysohns.CU.left_U_subset","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\n⊢ HasSubset.Subset c.left.U c.U","decl":"theorem left_U_subset (c : CU P) : c.left.U ⊆ c.U :=\n  Subset.trans c.left_U_subset_right_C c.right.subset\n\n"}
{"name":"Urysohns.CU.subset_right_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\n⊢ HasSubset.Subset c.C c.right.C","decl":"theorem subset_right_C (c : CU P) : c.C ⊆ c.right.C :=\n  Subset.trans c.left.subset c.left_U_subset_right_C\n\n"}
{"name":"Urysohns.CU.approx_of_mem_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nn : Nat\nx : X\nhx : Membership.mem c.C x\n⊢ Eq (Urysohns.CU.approx n c x) 0","decl":"theorem approx_of_mem_C (c : CU P) (n : ℕ) {x : X} (hx : x ∈ c.C) : c.approx n x = 0 := by\n  induction n generalizing c with\n  | zero => exact indicator_of_not_mem (fun (hU : x ∈ c.Uᶜ) => hU <| c.subset hx) _\n  | succ n ihn =>\n    simp only [approx]\n    rw [ihn, ihn, midpoint_self]\n    exacts [c.subset_right_C hx, hx]\n\n"}
{"name":"Urysohns.CU.approx_of_nmem_U","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nn : Nat\nx : X\nhx : Not (Membership.mem c.U x)\n⊢ Eq (Urysohns.CU.approx n c x) 1","decl":"theorem approx_of_nmem_U (c : CU P) (n : ℕ) {x : X} (hx : x ∉ c.U) : c.approx n x = 1 := by\n  induction n generalizing c with\n  | zero =>\n    rw [← mem_compl_iff] at hx\n    exact indicator_of_mem hx _\n  | succ n ihn =>\n    simp only [approx]\n    rw [ihn, ihn, midpoint_self]\n    exacts [hx, fun hU => hx <| c.left_U_subset hU]\n\n"}
{"name":"Urysohns.CU.approx_nonneg","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nn : Nat\nx : X\n⊢ LE.le 0 (Urysohns.CU.approx n c x)","decl":"theorem approx_nonneg (c : CU P) (n : ℕ) (x : X) : 0 ≤ c.approx n x := by\n  induction n generalizing c with\n  | zero => exact indicator_nonneg (fun _ _ => zero_le_one) _\n  | succ n ihn =>\n    simp only [approx, midpoint_eq_smul_add, invOf_eq_inv]\n    refine mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg ?_ ?_) <;> apply ihn\n\n"}
{"name":"Urysohns.CU.approx_le_one","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nn : Nat\nx : X\n⊢ LE.le (Urysohns.CU.approx n c x) 1","decl":"theorem approx_le_one (c : CU P) (n : ℕ) (x : X) : c.approx n x ≤ 1 := by\n  induction n generalizing c with\n  | zero => exact indicator_apply_le' (fun _ => le_rfl) fun _ => zero_le_one\n  | succ n ihn =>\n    simp only [approx, midpoint_eq_smul_add, invOf_eq_inv, smul_eq_mul, ← div_eq_inv_mul]\n    have := add_le_add (ihn (left c)) (ihn (right c))\n    norm_num at this\n    exact Iff.mpr (div_le_one zero_lt_two) this\n\n"}
{"name":"Urysohns.CU.bddAbove_range_approx","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\n⊢ BddAbove (Set.range fun n => Urysohns.CU.approx n c x)","decl":"theorem bddAbove_range_approx (c : CU P) (x : X) : BddAbove (range fun n => c.approx n x) :=\n  ⟨1, fun _ ⟨n, hn⟩ => hn ▸ c.approx_le_one n x⟩\n\n"}
{"name":"Urysohns.CU.approx_le_approx_of_U_sub_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc₁ c₂ : Urysohns.CU P\nh : HasSubset.Subset c₁.U c₂.C\nn₁ n₂ : Nat\nx : X\n⊢ LE.le (Urysohns.CU.approx n₂ c₂ x) (Urysohns.CU.approx n₁ c₁ x)","decl":"theorem approx_le_approx_of_U_sub_C {c₁ c₂ : CU P} (h : c₁.U ⊆ c₂.C) (n₁ n₂ : ℕ) (x : X) :\n    c₂.approx n₂ x ≤ c₁.approx n₁ x := by\n  by_cases hx : x ∈ c₁.U\n  · calc\n      approx n₂ c₂ x = 0 := approx_of_mem_C _ _ (h hx)\n      _ ≤ approx n₁ c₁ x := approx_nonneg _ _ _\n  · calc\n      approx n₂ c₂ x ≤ 1 := approx_le_one _ _ _\n      _ = approx n₁ c₁ x := (approx_of_nmem_U _ _ hx).symm\n\n"}
{"name":"Urysohns.CU.approx_mem_Icc_right_left","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nn : Nat\nx : X\n⊢ Membership.mem (Set.Icc (Urysohns.CU.approx n c.right x) (Urysohns.CU.approx n c.left x)) (Urysohns.CU.approx n c x)","decl":"theorem approx_mem_Icc_right_left (c : CU P) (n : ℕ) (x : X) :\n    c.approx n x ∈ Icc (c.right.approx n x) (c.left.approx n x) := by\n  induction' n with n ihn generalizing c\n  · exact ⟨le_rfl, indicator_le_indicator_of_subset (compl_subset_compl.2 c.left_U_subset)\n      (fun _ => zero_le_one) _⟩\n  · simp only [approx, mem_Icc]\n    refine ⟨midpoint_le_midpoint ?_ (ihn _).1, midpoint_le_midpoint (ihn _).2 ?_⟩ <;>\n      apply approx_le_approx_of_U_sub_C\n    exacts [subset_closure, subset_closure]\n\n"}
{"name":"Urysohns.CU.approx_le_succ","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nn : Nat\nx : X\n⊢ LE.le (Urysohns.CU.approx n c x) (Urysohns.CU.approx (HAdd.hAdd n 1) c x)","decl":"theorem approx_le_succ (c : CU P) (n : ℕ) (x : X) : c.approx n x ≤ c.approx (n + 1) x := by\n  induction' n with n ihn generalizing c\n  · simp only [approx, right_U, right_le_midpoint]\n    exact (approx_mem_Icc_right_left c 0 x).2\n  · rw [approx, approx]\n    exact midpoint_le_midpoint (ihn _) (ihn _)\n\n"}
{"name":"Urysohns.CU.approx_mono","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\n⊢ Monotone fun n => Urysohns.CU.approx n c x","decl":"theorem approx_mono (c : CU P) (x : X) : Monotone fun n => c.approx n x :=\n  monotone_nat_of_le_succ fun n => c.approx_le_succ n x\n\n"}
{"name":"Urysohns.CU.tendsto_approx_atTop","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\n⊢ Filter.Tendsto (fun n => Urysohns.CU.approx n c x) Filter.atTop (nhds (c.lim x))","decl":"theorem tendsto_approx_atTop (c : CU P) (x : X) :\n    Tendsto (fun n => c.approx n x) atTop (𝓝 <| c.lim x) :=\n  tendsto_atTop_ciSup (c.approx_mono x) ⟨1, fun _ ⟨_, hn⟩ => hn ▸ c.approx_le_one _ _⟩\n\n"}
{"name":"Urysohns.CU.lim_of_mem_C","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\nh : Membership.mem c.C x\n⊢ Eq (c.lim x) 0","decl":"theorem lim_of_mem_C (c : CU P) (x : X) (h : x ∈ c.C) : c.lim x = 0 := by\n  simp only [CU.lim, approx_of_mem_C, h, ciSup_const]\n\n"}
{"name":"Urysohns.CU.disjoint_C_support_lim","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\n⊢ Disjoint c.C (Function.support c.lim)","decl":"theorem disjoint_C_support_lim (c : CU P) : Disjoint c.C (Function.support c.lim) :=\n  Function.disjoint_support_iff.mpr (fun x hx => lim_of_mem_C c x hx)\n\n"}
{"name":"Urysohns.CU.lim_of_nmem_U","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\nh : Not (Membership.mem c.U x)\n⊢ Eq (c.lim x) 1","decl":"theorem lim_of_nmem_U (c : CU P) (x : X) (h : x ∉ c.U) : c.lim x = 1 := by\n  simp only [CU.lim, approx_of_nmem_U c _ h, ciSup_const]\n\n"}
{"name":"Urysohns.CU.lim_eq_midpoint","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\n⊢ Eq (c.lim x) (midpoint Real (c.left.lim x) (c.right.lim x))","decl":"theorem lim_eq_midpoint (c : CU P) (x : X) :\n    c.lim x = midpoint ℝ (c.left.lim x) (c.right.lim x) := by\n  refine tendsto_nhds_unique (c.tendsto_approx_atTop x) ((tendsto_add_atTop_iff_nat 1).1 ?_)\n  simp only [approx]\n  exact (c.left.tendsto_approx_atTop x).midpoint (c.right.tendsto_approx_atTop x)\n\n"}
{"name":"Urysohns.CU.approx_le_lim","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\nn : Nat\n⊢ LE.le (Urysohns.CU.approx n c x) (c.lim x)","decl":"theorem approx_le_lim (c : CU P) (x : X) (n : ℕ) : c.approx n x ≤ c.lim x :=\n  le_ciSup (c.bddAbove_range_approx x) _\n\n"}
{"name":"Urysohns.CU.lim_nonneg","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\n⊢ LE.le 0 (c.lim x)","decl":"theorem lim_nonneg (c : CU P) (x : X) : 0 ≤ c.lim x :=\n  (c.approx_nonneg 0 x).trans (c.approx_le_lim x 0)\n\n"}
{"name":"Urysohns.CU.lim_le_one","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\n⊢ LE.le (c.lim x) 1","decl":"theorem lim_le_one (c : CU P) (x : X) : c.lim x ≤ 1 :=\n  ciSup_le fun _ => c.approx_le_one _ _\n\n"}
{"name":"Urysohns.CU.lim_mem_Icc","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\nx : X\n⊢ Membership.mem (Set.Icc 0 1) (c.lim x)","decl":"theorem lim_mem_Icc (c : CU P) (x : X) : c.lim x ∈ Icc (0 : ℝ) 1 :=\n  ⟨c.lim_nonneg x, c.lim_le_one x⟩\n\n"}
{"name":"Urysohns.CU.continuous_lim","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nP : Set X → Prop\nc : Urysohns.CU P\n⊢ Continuous c.lim","decl":"/-- Continuity of `Urysohns.CU.lim`. See module docstring for a sketch of the proofs. -/\ntheorem continuous_lim (c : CU P) : Continuous c.lim := by\n  obtain ⟨h0, h1234, h1⟩ : 0 < (2⁻¹ : ℝ) ∧ (2⁻¹ : ℝ) < 3 / 4 ∧ (3 / 4 : ℝ) < 1 := by norm_num\n  refine\n    continuous_iff_continuousAt.2 fun x =>\n      (Metric.nhds_basis_closedBall_pow (h0.trans h1234) h1).tendsto_right_iff.2 fun n _ => ?_\n  simp only [Metric.mem_closedBall]\n  induction' n with n ihn generalizing c\n  · filter_upwards with y\n    rw [pow_zero]\n    exact Real.dist_le_of_mem_Icc_01 (c.lim_mem_Icc _) (c.lim_mem_Icc _)\n  · by_cases hxl : x ∈ c.left.U\n    · filter_upwards [IsOpen.mem_nhds c.left.open_U hxl, ihn c.left] with _ hyl hyd\n      rw [pow_succ', c.lim_eq_midpoint, c.lim_eq_midpoint,\n        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hyl),\n        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hxl)]\n      refine (dist_midpoint_midpoint_le _ _ _ _).trans ?_\n      rw [dist_self, add_zero, div_eq_inv_mul]\n      gcongr\n    · replace hxl : x ∈ c.left.right.Cᶜ :=\n        compl_subset_compl.2 c.left.right.subset hxl\n      filter_upwards [IsOpen.mem_nhds (isOpen_compl_iff.2 c.left.right.closed_C) hxl,\n        ihn c.left.right, ihn c.right] with y hyl hydl hydr\n      replace hxl : x ∉ c.left.left.U :=\n        compl_subset_compl.2 c.left.left_U_subset_right_C hxl\n      replace hyl : y ∉ c.left.left.U :=\n        compl_subset_compl.2 c.left.left_U_subset_right_C hyl\n      simp only [pow_succ, c.lim_eq_midpoint, c.left.lim_eq_midpoint,\n        c.left.left.lim_of_nmem_U _ hxl, c.left.left.lim_of_nmem_U _ hyl]\n      refine (dist_midpoint_midpoint_le _ _ _ _).trans ?_\n      refine (div_le_div_of_nonneg_right (add_le_add_right (dist_midpoint_midpoint_le _ _ _ _) _)\n        zero_le_two).trans ?_\n      rw [dist_self, zero_add]\n      set r := (3 / 4 : ℝ) ^ n\n      calc _ ≤ (r / 2 + r) / 2 := by gcongr\n        _ = _ := by field_simp; ring\n\n"}
{"name":"exists_continuous_zero_one_of_isClosed","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsClosed t\nhd : Disjoint s t\n⊢ Exists fun f => And (Set.EqOn (⇑f) 0 s) (And (Set.EqOn (⇑f) 1 t) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nthen there exists a continuous function `f : X → ℝ` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ≤ f x ≤ 1` for all `x`.\n-/\ntheorem exists_continuous_zero_one_of_isClosed [NormalSpace X]\n    {s t : Set X} (hs : IsClosed s) (ht : IsClosed t)\n    (hd : Disjoint s t) : ∃ f : C(X, ℝ), EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by\n  -- The actual proof is in the code above. Here we just repack it into the expected format.\n  let P : Set X → Prop := fun _ ↦ True\n  set c : Urysohns.CU P :=\n  { C := s\n    U := tᶜ\n    P_C := trivial\n    closed_C := hs\n    open_U := ht.isOpen_compl\n    subset := disjoint_left.1 hd\n    hP := by\n      rintro c u c_closed - u_open cu\n      rcases normal_exists_closure_subset c_closed u_open cu with ⟨v, v_open, cv, hv⟩\n      exact ⟨v, v_open, cv, hv, trivial⟩ }\n  exact ⟨⟨c.lim, c.continuous_lim⟩, c.lim_of_mem_C, fun x hx => c.lim_of_nmem_U _ fun h => h hx,\n    c.lim_mem_Icc⟩\n\n"}
{"name":"exists_continuous_zero_one_of_isCompact","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : RegularSpace X\ninst✝ : LocallyCompactSpace X\ns t : Set X\nhs : IsCompact s\nht : IsClosed t\nhd : Disjoint s t\n⊢ Exists fun f => And (Set.EqOn (⇑f) 0 s) (And (Set.EqOn (⇑f) 1 t) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint sets in a regular locally compact topological\nspace `X`, with `s` compact and `t` closed, then there exists a continuous\nfunction `f : X → ℝ` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ≤ f x ≤ 1` for all `x`.\n-/\ntheorem exists_continuous_zero_one_of_isCompact [RegularSpace X] [LocallyCompactSpace X]\n    {s t : Set X} (hs : IsCompact s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ∃ f : C(X, ℝ), EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by\n  obtain ⟨k, k_comp, k_closed, sk, kt⟩ : ∃ k, IsCompact k ∧ IsClosed k ∧ s ⊆ interior k ∧ k ⊆ tᶜ :=\n    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left\n  let P : Set X → Prop := IsCompact\n  set c : Urysohns.CU P :=\n  { C := k\n    U := tᶜ\n    P_C := k_comp\n    closed_C := k_closed\n    open_U := ht.isOpen_compl\n    subset := kt\n    hP := by\n      rintro c u - c_comp u_open cu\n      rcases exists_compact_closed_between c_comp u_open cu with ⟨k, k_comp, k_closed, ck, ku⟩\n      have A : closure (interior k) ⊆ k :=\n        (IsClosed.closure_subset_iff k_closed).2 interior_subset\n      refine ⟨interior k, isOpen_interior, ck, A.trans ku,\n        k_comp.of_isClosed_subset isClosed_closure A⟩ }\n  exact ⟨⟨c.lim, c.continuous_lim⟩, fun x hx ↦ c.lim_of_mem_C _ (sk.trans interior_subset hx),\n    fun x hx => c.lim_of_nmem_U _ fun h => h hx, c.lim_mem_Icc⟩\n\n"}
{"name":"exists_continuous_zero_one_of_isCompact'","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : RegularSpace X\ninst✝ : LocallyCompactSpace X\ns t : Set X\nhs : IsCompact s\nht : IsClosed t\nhd : Disjoint s t\n⊢ Exists fun f => And (Set.EqOn (⇑f) 0 t) (And (Set.EqOn (⇑f) 1 s) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint sets in a regular locally compact topological\nspace `X`, with `s` compact and `t` closed, then there exists a continuous\nfunction `f : X → ℝ` such that\n\n* `f` equals zero on `t`;\n* `f` equals one on `s`;\n* `0 ≤ f x ≤ 1` for all `x`.\n-/\ntheorem exists_continuous_zero_one_of_isCompact' [RegularSpace X] [LocallyCompactSpace X]\n    {s t : Set X} (hs : IsCompact s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ∃ f : C(X, ℝ), EqOn f 0 t ∧ EqOn f 1 s ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by\n  obtain ⟨g, hgs, hgt, (hicc : ∀ x, 0 ≤ g x ∧ g x ≤ 1)⟩ := exists_continuous_zero_one_of_isCompact\n    hs ht hd\n  use 1 - g\n  refine ⟨?_, ?_, ?_⟩\n  · intro x hx\n    simp only [ContinuousMap.sub_apply, ContinuousMap.one_apply, Pi.zero_apply]\n    exact sub_eq_zero_of_eq (id (EqOn.symm hgt) hx)\n  · intro x hx\n    simp only [ContinuousMap.sub_apply, ContinuousMap.one_apply, Pi.one_apply, sub_eq_self]\n    exact hgs hx\n  · intro x\n    simpa [and_comm] using hicc x\n\n"}
{"name":"exists_continuous_one_zero_of_isCompact","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : RegularSpace X\ninst✝ : LocallyCompactSpace X\ns t : Set X\nhs : IsCompact s\nht : IsClosed t\nhd : Disjoint s t\n⊢ Exists fun f => And (Set.EqOn (⇑f) 1 s) (And (Set.EqOn (⇑f) 0 t) (And (HasCompactSupport ⇑f) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x))))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint sets in a regular locally compact topological\nspace `X`, with `s` compact and `t` closed, then there exists a continuous compactly supported\nfunction `f : X → ℝ` such that\n\n* `f` equals one on `s`;\n* `f` equals zero on `t`;\n* `0 ≤ f x ≤ 1` for all `x`.\n-/\ntheorem exists_continuous_one_zero_of_isCompact [RegularSpace X] [LocallyCompactSpace X]\n    {s t : Set X} (hs : IsCompact s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ∃ f : C(X, ℝ), EqOn f 1 s ∧ EqOn f 0 t ∧ HasCompactSupport f ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by\n  obtain ⟨k, k_comp, k_closed, sk, kt⟩ : ∃ k, IsCompact k ∧ IsClosed k ∧ s ⊆ interior k ∧ k ⊆ tᶜ :=\n    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left\n  rcases exists_continuous_zero_one_of_isCompact hs isOpen_interior.isClosed_compl\n    (disjoint_compl_right_iff_subset.mpr sk) with ⟨⟨f, hf⟩, hfs, hft, h'f⟩\n  have A : t ⊆ (interior k)ᶜ := subset_compl_comm.mpr (interior_subset.trans kt)\n  refine ⟨⟨fun x ↦ 1 - f x, continuous_const.sub hf⟩, fun x hx ↦ by simpa using hfs hx,\n    fun x hx ↦ by simpa [sub_eq_zero] using (hft (A hx)).symm, ?_, fun x ↦ ?_⟩\n  · apply HasCompactSupport.intro' k_comp k_closed (fun x hx ↦ ?_)\n    simp only [ContinuousMap.coe_mk, sub_eq_zero]\n    apply (hft _).symm\n    contrapose! hx\n    simp only [mem_compl_iff, not_not] at hx\n    exact interior_subset hx\n  · have : 0 ≤ f x ∧ f x ≤ 1 := by simpa using h'f x\n    simp [this]\n\n"}
{"name":"exists_continuous_one_zero_of_isCompact_of_isGδ","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : RegularSpace X\ninst✝ : LocallyCompactSpace X\ns t : Set X\nhs : IsCompact s\nh's : IsGδ s\nht : IsClosed t\nhd : Disjoint s t\n⊢ Exists fun f => And (Eq s (Set.preimage (⇑f) (Singleton.singleton 1))) (And (Set.EqOn (⇑f) 0 t) (And (HasCompactSupport ⇑f) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x))))","decl":"/-- Urysohn's lemma: if `s` and `t` are two disjoint sets in a regular locally compact topological\nspace `X`, with `s` compact and `t` closed, then there exists a continuous compactly supported\nfunction `f : X → ℝ` such that\n\n* `f` equals one on `s`;\n* `f` equals zero on `t`;\n* `0 ≤ f x ≤ 1` for all `x`.\n\nMoreover, if `s` is Gδ, one can ensure that `f ⁻¹ {1}` is exactly `s`.\n-/\ntheorem exists_continuous_one_zero_of_isCompact_of_isGδ [RegularSpace X] [LocallyCompactSpace X]\n    {s t : Set X} (hs : IsCompact s) (h's : IsGδ s) (ht : IsClosed t) (hd : Disjoint s t) :\n    ∃ f : C(X, ℝ), s = f ⁻¹' {1} ∧ EqOn f 0 t ∧ HasCompactSupport f\n      ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by\n  rcases h's.eq_iInter_nat with ⟨U, U_open, hU⟩\n  obtain ⟨m, m_comp, -, sm, mt⟩ : ∃ m, IsCompact m ∧ IsClosed m ∧ s ⊆ interior m ∧ m ⊆ tᶜ :=\n    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left\n  have A n : ∃ f : C(X, ℝ), EqOn f 1 s ∧ EqOn f 0 (U n ∩ interior m)ᶜ ∧ HasCompactSupport f\n      ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by\n    apply exists_continuous_one_zero_of_isCompact hs\n      ((U_open n).inter isOpen_interior).isClosed_compl\n    rw [disjoint_compl_right_iff_subset]\n    exact subset_inter ((hU.subset.trans (iInter_subset U n))) sm\n  choose f fs fm _hf f_range using A\n  obtain ⟨u, u_pos, u_sum, hu⟩ : ∃ (u : ℕ → ℝ), (∀ i, 0 < u i) ∧ Summable u ∧ ∑' i, u i = 1 :=\n    ⟨fun n ↦ 1/2/2^n, fun n ↦ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1⟩\n  let g : X → ℝ := fun x ↦ ∑' n, u n * f n x\n  have hgmc : EqOn g 0 mᶜ := by\n    intro x hx\n    have B n : f n x = 0 := by\n      have : mᶜ ⊆ (U n ∩ interior m)ᶜ := by\n        simpa using inter_subset_right.trans interior_subset\n      exact fm n (this hx)\n    simp [g, B]\n  have I n x : u n * f n x ≤ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2\n  have S x : Summable (fun n ↦ u n * f n x) := Summable.of_nonneg_of_le\n      (fun n ↦ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ↦ I n x) u_sum\n  refine ⟨⟨g, ?_⟩, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ↦ ⟨?_, ?_⟩⟩\n  · apply continuous_tsum (fun n ↦ continuous_const.mul (f n).continuous) u_sum (fun n x ↦ ?_)\n    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x\n  · apply Subset.antisymm (fun x hx ↦ by simp [g, fs _ hx, hu]) ?_\n    apply compl_subset_compl.1\n    intro x hx\n    obtain ⟨n, hn⟩ : ∃ n, x ∉ U n := by simpa [hU] using hx\n    have fnx : f n x = 0 := fm _ (by simp [hn])\n    have : g x < 1 := by\n      apply lt_of_lt_of_le ?_ hu.le\n      exact tsum_lt_tsum (i := n) (fun i ↦ I i x) (by simp [fnx, u_pos n]) (S x) u_sum\n    simpa using this.ne\n  · exact HasCompactSupport.of_support_subset_isCompact m_comp\n      (Function.support_subset_iff'.mpr hgmc)\n  · exact tsum_nonneg (fun n ↦ mul_nonneg (u_pos n).le (f_range n x).1)\n  · apply le_trans _ hu.le\n    exact tsum_le_tsum (fun n ↦ I n x) (S x) u_sum\n\n"}
{"name":"exists_tsupport_one_of_isOpen_isClosed","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T2Space X\ns t : Set X\nhs : IsOpen s\nhscp : IsCompact (closure s)\nht : IsClosed t\nhst : HasSubset.Subset t s\n⊢ Exists fun f => And (HasSubset.Subset (tsupport ⇑f) s) (And (Set.EqOn (⇑f) 1 t) (∀ (x : X), Membership.mem (Set.Icc 0 1) (f x)))","decl":"/-- A variation of Urysohn's lemma. In a `T2Space X`, for a closed set `t` and a relatively\ncompact open set `s` such that `t ⊆ s`, there is a continuous function `f` supported in `s`,\n`f x = 1` on `t` and `0 ≤ f x ≤ 1`. -/\nlemma exists_tsupport_one_of_isOpen_isClosed [T2Space X] {s t : Set X}\n    (hs : IsOpen s) (hscp : IsCompact (closure s)) (ht : IsClosed t) (hst : t ⊆ s) :\n    ∃ f : C(X, ℝ), tsupport f ⊆ s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by\n-- separate `sᶜ` and `t` by `u` and `v`.\n  rw [← compl_compl s] at hscp\n  obtain ⟨u, v, huIsOpen, hvIsOpen, hscompl_subset_u, ht_subset_v, hDjsjointuv⟩ :=\n    SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed (isClosed_compl_iff.mpr hs)\n    hscp ht (HasSubset.Subset.disjoint_compl_left hst)\n  rw [← subset_compl_iff_disjoint_right] at hDjsjointuv\n  have huvc : closure u ⊆ vᶜ := closure_minimal hDjsjointuv hvIsOpen.isClosed_compl\n-- although `sᶜ` is not compact, `closure s` is compact and we can apply\n-- `SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed`. To apply the condition\n-- recursively, we need to make sure that `sᶜ ⊆ C`.\n  let P : Set X → Prop := fun C => sᶜ ⊆ C\n  set c : Urysohns.CU P :=\n  { C := closure u\n    U := tᶜ\n    P_C := hscompl_subset_u.trans subset_closure\n    closed_C := isClosed_closure\n    open_U := ht.isOpen_compl\n    subset := subset_compl_comm.mp\n      (Subset.trans ht_subset_v (subset_compl_comm.mp huvc))\n    hP := by\n      intro c u0 cIsClosed Pc u0IsOpen csubu0\n      obtain ⟨u1, hu1⟩ := SeparatedNhds.of_isClosed_isCompact_closure_compl_isClosed cIsClosed\n        (IsCompact.of_isClosed_subset hscp isClosed_closure\n        (closure_mono (compl_subset_compl.mpr Pc)))\n        (isClosed_compl_iff.mpr u0IsOpen) (HasSubset.Subset.disjoint_compl_right csubu0)\n      simp_rw [← subset_compl_iff_disjoint_right, compl_subset_comm (s := u0)] at hu1\n      obtain ⟨v1, hu1, hv1, hcu1, hv1u, hu1v1⟩ := hu1\n      refine ⟨u1, hu1, hcu1, ?_, (Pc.trans hcu1).trans subset_closure⟩\n      exact closure_minimal hu1v1 hv1.isClosed_compl |>.trans hv1u }\n-- `c.lim = 0` on `closure u` and `c.lim = 1` on `t`, so that `tsupport c.lim ⊆ s`.\n  use ⟨c.lim, c.continuous_lim⟩\n  simp only [ContinuousMap.coe_mk]\n  refine ⟨?_, ?_, Urysohns.CU.lim_mem_Icc c⟩\n  · apply Subset.trans _ (compl_subset_comm.mp hscompl_subset_u)\n    rw [← IsClosed.closure_eq (isClosed_compl_iff.mpr huIsOpen)]\n    apply closure_mono\n    exact Disjoint.subset_compl_right (disjoint_of_subset_right subset_closure\n      (Disjoint.symm (Urysohns.CU.disjoint_C_support_lim c)))\n  · intro x hx\n    apply Urysohns.CU.lim_of_nmem_U\n    exact not_mem_compl_iff.mpr hx\n\n"}
{"name":"exists_continuous_nonneg_pos","module":"Mathlib.Topology.UrysohnsLemma","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : RegularSpace X\ninst✝ : LocallyCompactSpace X\nx : X\n⊢ Exists fun f => And (HasCompactSupport ⇑f) (And (LE.le 0 ⇑f) (Ne (f x) 0))","decl":"theorem exists_continuous_nonneg_pos [RegularSpace X] [LocallyCompactSpace X] (x : X) :\n    ∃ f : C(X, ℝ), HasCompactSupport f ∧ 0 ≤ (f : X → ℝ) ∧ f x ≠ 0 := by\n  rcases exists_compact_mem_nhds x with ⟨k, hk, k_mem⟩\n  rcases exists_continuous_one_zero_of_isCompact hk isClosed_empty (disjoint_empty k)\n    with ⟨f, fk, -, f_comp, hf⟩\n  refine ⟨f, f_comp, fun x ↦ (hf x).1, ?_⟩\n  have := fk (mem_of_mem_nhds k_mem)\n  simp only [ContinuousMap.coe_mk, Pi.one_apply] at this\n  simp [this]\n"}
