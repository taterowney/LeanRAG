{"name":"WittVector.coe_mkUnit","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst✝¹ : CommRing k\ninst✝ : CharP k p\na : Units k\nA : WittVector p k\nhA : Eq (A.coeff 0) ↑a\n⊢ Eq (↑(WittVector.mkUnit hA)) A","decl":"@[simp]\ntheorem coe_mkUnit {a : Units k} {A : 𝕎 k} (hA : A.coeff 0 = a) : (mkUnit hA : 𝕎 k) = A :=\n  rfl\n\n"}
{"name":"WittVector.isUnit_of_coeff_zero_ne_zero","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst✝¹ : Field k\ninst✝ : CharP k p\nx : WittVector p k\nhx : Ne (x.coeff 0) 0\n⊢ IsUnit x","decl":"theorem isUnit_of_coeff_zero_ne_zero (x : 𝕎 k) (hx : x.coeff 0 ≠ 0) : IsUnit x := by\n  let y : kˣ := Units.mk0 (x.coeff 0) hx\n  have hy : x.coeff 0 = y := rfl\n  exact (mkUnit hy).isUnit\n\n"}
{"name":"WittVector.irreducible","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst✝¹ : Field k\ninst✝ : CharP k p\n⊢ Irreducible ↑p","decl":"theorem irreducible : Irreducible (p : 𝕎 k) := by\n  have hp : ¬IsUnit (p : 𝕎 k) := by\n    intro hp\n    simpa only [constantCoeff_apply, coeff_p_zero, not_isUnit_zero] using\n      (constantCoeff : WittVector p k →+* _).isUnit_map hp\n  refine ⟨hp, fun a b hab => ?_⟩\n  obtain ⟨ha0, hb0⟩ : a ≠ 0 ∧ b ≠ 0 := by\n    rw [← mul_ne_zero_iff]; intro h; rw [h] at hab; exact p_nonzero p k hab\n  obtain ⟨m, a, ha, rfl⟩ := verschiebung_nonzero ha0\n  obtain ⟨n, b, hb, rfl⟩ := verschiebung_nonzero hb0\n  cases m; · exact Or.inl (isUnit_of_coeff_zero_ne_zero a ha)\n  cases' n with n; · exact Or.inr (isUnit_of_coeff_zero_ne_zero b hb)\n  rw [iterate_verschiebung_mul] at hab\n  apply_fun fun x => coeff x 1 at hab\n  simp only [coeff_p_one, Nat.add_succ, add_comm _ n, Function.iterate_succ', Function.comp_apply,\n    verschiebung_coeff_add_one, verschiebung_coeff_zero] at hab\n  exact (one_ne_zero hab).elim\n\n"}
{"name":"WittVector.exists_eq_pow_p_mul","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst✝² : CommRing k\ninst✝¹ : CharP k p\ninst✝ : PerfectRing k p\na : WittVector p k\nha : Ne a 0\n⊢ Exists fun m => Exists fun b => And (Ne (b.coeff 0) 0) (Eq a (HMul.hMul (HPow.hPow (↑p) m) b))","decl":"theorem exists_eq_pow_p_mul (a : 𝕎 k) (ha : a ≠ 0) :\n    ∃ (m : ℕ) (b : 𝕎 k), b.coeff 0 ≠ 0 ∧ a = (p : 𝕎 k) ^ m * b := by\n  obtain ⟨m, c, hc, hcm⟩ := WittVector.verschiebung_nonzero ha\n  obtain ⟨b, rfl⟩ := (frobenius_bijective p k).surjective.iterate m c\n  rw [WittVector.iterate_frobenius_coeff] at hc\n  have := congr_fun (WittVector.verschiebung_frobenius_comm.comp_iterate m) b\n  simp only [Function.comp_apply] at this\n  rw [← this] at hcm\n  refine ⟨m, b, ?_, ?_⟩\n  · contrapose! hc\n    simp [hc, zero_pow <| pow_ne_zero _ hp.out.ne_zero]\n  · simp_rw [← mul_left_iterate (p : 𝕎 k) m]\n    convert hcm using 2\n    ext1 x\n    rw [mul_comm, ← WittVector.verschiebung_frobenius x]; rfl\n\n"}
{"name":"WittVector.exists_eq_pow_p_mul'","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst✝² : Field k\ninst✝¹ : CharP k p\ninst✝ : PerfectRing k p\na : WittVector p k\nha : Ne a 0\n⊢ Exists fun m => Exists fun b => Eq a (HMul.hMul (HPow.hPow (↑p) m) ↑b)","decl":"theorem exists_eq_pow_p_mul' (a : 𝕎 k) (ha : a ≠ 0) :\n    ∃ (m : ℕ) (b : Units (𝕎 k)), a = (p : 𝕎 k) ^ m * b := by\n  obtain ⟨m, b, h₁, h₂⟩ := exists_eq_pow_p_mul a ha\n  let b₀ := Units.mk0 (b.coeff 0) h₁\n  have hb₀ : b.coeff 0 = b₀ := rfl\n  exact ⟨m, mkUnit hb₀, h₂⟩\n\n/-\nNote: The following lemma should be an instance, but it seems to cause some\nexponential blowups in certain typeclass resolution problems.\nSee the following Lean4 issue as well as the zulip discussion linked there:\nhttps://github.com/leanprover/lean4/issues/1102\n-/\n"}
{"name":"WittVector.isDiscreteValuationRing","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninst✝² : Field k\ninst✝¹ : CharP k p\ninst✝ : PerfectRing k p\n⊢ IsDiscreteValuationRing (WittVector p k)","decl":"/-- The ring of Witt Vectors of a perfect field of positive characteristic is a DVR.\n-/\ntheorem isDiscreteValuationRing : IsDiscreteValuationRing (𝕎 k) :=\n  IsDiscreteValuationRing.ofHasUnitMulPowIrreducibleFactorization (by\n    refine ⟨p, irreducible p, fun {x} hx => ?_⟩\n    obtain ⟨n, b, hb⟩ := exists_eq_pow_p_mul' x hx\n    exact ⟨n, b, hb.symm⟩)\n\n"}
