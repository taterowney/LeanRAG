{"name":"WittVector.coe_mkUnit","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ¹ : CommRing k\ninstâœ : CharP k p\na : Units k\nA : WittVector p k\nhA : Eq (A.coeff 0) â†‘a\nâŠ¢ Eq (â†‘(WittVector.mkUnit hA)) A","decl":"@[simp]\ntheorem coe_mkUnit {a : Units k} {A : ğ• k} (hA : A.coeff 0 = a) : (mkUnit hA : ğ• k) = A :=\n  rfl\n\n"}
{"name":"WittVector.isUnit_of_coeff_zero_ne_zero","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ¹ : Field k\ninstâœ : CharP k p\nx : WittVector p k\nhx : Ne (x.coeff 0) 0\nâŠ¢ IsUnit x","decl":"theorem isUnit_of_coeff_zero_ne_zero (x : ğ• k) (hx : x.coeff 0 â‰  0) : IsUnit x := by\n  let y : kË£ := Units.mk0 (x.coeff 0) hx\n  have hy : x.coeff 0 = y := rfl\n  exact (mkUnit hy).isUnit\n\n"}
{"name":"WittVector.irreducible","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ¹ : Field k\ninstâœ : CharP k p\nâŠ¢ Irreducible â†‘p","decl":"theorem irreducible : Irreducible (p : ğ• k) := by\n  have hp : Â¬IsUnit (p : ğ• k) := by\n    intro hp\n    simpa only [constantCoeff_apply, coeff_p_zero, not_isUnit_zero] using\n      (constantCoeff : WittVector p k â†’+* _).isUnit_map hp\n  refine âŸ¨hp, fun a b hab => ?_âŸ©\n  obtain âŸ¨ha0, hb0âŸ© : a â‰  0 âˆ§ b â‰  0 := by\n    rw [â† mul_ne_zero_iff]; intro h; rw [h] at hab; exact p_nonzero p k hab\n  obtain âŸ¨m, a, ha, rflâŸ© := verschiebung_nonzero ha0\n  obtain âŸ¨n, b, hb, rflâŸ© := verschiebung_nonzero hb0\n  cases m; Â· exact Or.inl (isUnit_of_coeff_zero_ne_zero a ha)\n  cases' n with n; Â· exact Or.inr (isUnit_of_coeff_zero_ne_zero b hb)\n  rw [iterate_verschiebung_mul] at hab\n  apply_fun fun x => coeff x 1 at hab\n  simp only [coeff_p_one, Nat.add_succ, add_comm _ n, Function.iterate_succ', Function.comp_apply,\n    verschiebung_coeff_add_one, verschiebung_coeff_zero] at hab\n  exact (one_ne_zero hab).elim\n\n"}
{"name":"WittVector.exists_eq_pow_p_mul","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : CommRing k\ninstâœÂ¹ : CharP k p\ninstâœ : PerfectRing k p\na : WittVector p k\nha : Ne a 0\nâŠ¢ Exists fun m => Exists fun b => And (Ne (b.coeff 0) 0) (Eq a (HMul.hMul (HPow.hPow (â†‘p) m) b))","decl":"theorem exists_eq_pow_p_mul (a : ğ• k) (ha : a â‰  0) :\n    âˆƒ (m : â„•) (b : ğ• k), b.coeff 0 â‰  0 âˆ§ a = (p : ğ• k) ^ m * b := by\n  obtain âŸ¨m, c, hc, hcmâŸ© := WittVector.verschiebung_nonzero ha\n  obtain âŸ¨b, rflâŸ© := (frobenius_bijective p k).surjective.iterate m c\n  rw [WittVector.iterate_frobenius_coeff] at hc\n  have := congr_fun (WittVector.verschiebung_frobenius_comm.comp_iterate m) b\n  simp only [Function.comp_apply] at this\n  rw [â† this] at hcm\n  refine âŸ¨m, b, ?_, ?_âŸ©\n  Â· contrapose! hc\n    simp [hc, zero_pow <| pow_ne_zero _ hp.out.ne_zero]\n  Â· simp_rw [â† mul_left_iterate (p : ğ• k) m]\n    convert hcm using 2\n    ext1 x\n    rw [mul_comm, â† WittVector.verschiebung_frobenius x]; rfl\n\n"}
{"name":"WittVector.exists_eq_pow_p_mul'","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : Field k\ninstâœÂ¹ : CharP k p\ninstâœ : PerfectRing k p\na : WittVector p k\nha : Ne a 0\nâŠ¢ Exists fun m => Exists fun b => Eq a (HMul.hMul (HPow.hPow (â†‘p) m) â†‘b)","decl":"theorem exists_eq_pow_p_mul' (a : ğ• k) (ha : a â‰  0) :\n    âˆƒ (m : â„•) (b : Units (ğ• k)), a = (p : ğ• k) ^ m * b := by\n  obtain âŸ¨m, b, hâ‚, hâ‚‚âŸ© := exists_eq_pow_p_mul a ha\n  let bâ‚€ := Units.mk0 (b.coeff 0) hâ‚\n  have hbâ‚€ : b.coeff 0 = bâ‚€ := rfl\n  exact âŸ¨m, mkUnit hbâ‚€, hâ‚‚âŸ©\n\n/-\nNote: The following lemma should be an instance, but it seems to cause some\nexponential blowups in certain typeclass resolution problems.\nSee the following Lean4 issue as well as the zulip discussion linked there:\nhttps://github.com/leanprover/lean4/issues/1102\n-/\n"}
{"name":"WittVector.isDiscreteValuationRing","module":"Mathlib.RingTheory.WittVector.DiscreteValuationRing","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Type u_1\ninstâœÂ² : Field k\ninstâœÂ¹ : CharP k p\ninstâœ : PerfectRing k p\nâŠ¢ IsDiscreteValuationRing (WittVector p k)","decl":"/-- The ring of Witt Vectors of a perfect field of positive characteristic is a DVR.\n-/\ntheorem isDiscreteValuationRing : IsDiscreteValuationRing (ğ• k) :=\n  IsDiscreteValuationRing.ofHasUnitMulPowIrreducibleFactorization (by\n    refine âŸ¨p, irreducible p, fun {x} hx => ?_âŸ©\n    obtain âŸ¨n, b, hbâŸ© := exists_eq_pow_p_mul' x hx\n    exact âŸ¨n, b, hb.symmâŸ©)\n\n"}
