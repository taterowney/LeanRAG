{"name":"AddLocalization.mk_le_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Order","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns : AddSubmonoid α\na₁ b₁ : α\na₂ b₂ : Subtype fun x => Membership.mem s x\n⊢ Iff (LE.le (AddLocalization.mk a₁ a₂) (AddLocalization.mk b₁ b₂)) (LE.le (HAdd.hAdd (↑b₂) a₁) (HAdd.hAdd (↑a₂) b₁))","decl":"@[to_additive]\ntheorem mk_le_mk : mk a₁ a₂ ≤ mk b₁ b₂ ↔ ↑b₂ * a₁ ≤ a₂ * b₁ :=\n  Iff.rfl\n\n"}
{"name":"Localization.mk_le_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Order","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns : Submonoid α\na₁ b₁ : α\na₂ b₂ : Subtype fun x => Membership.mem s x\n⊢ Iff (LE.le (Localization.mk a₁ a₂) (Localization.mk b₁ b₂)) (LE.le (HMul.hMul (↑b₂) a₁) (HMul.hMul (↑a₂) b₁))","decl":"@[to_additive]\ntheorem mk_le_mk : mk a₁ a₂ ≤ mk b₁ b₂ ↔ ↑b₂ * a₁ ≤ a₂ * b₁ :=\n  Iff.rfl\n\n"}
{"name":"AddLocalization.mk_lt_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Order","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns : AddSubmonoid α\na₁ b₁ : α\na₂ b₂ : Subtype fun x => Membership.mem s x\n⊢ Iff (LT.lt (AddLocalization.mk a₁ a₂) (AddLocalization.mk b₁ b₂)) (LT.lt (HAdd.hAdd (↑b₂) a₁) (HAdd.hAdd (↑a₂) b₁))","decl":"@[to_additive]\ntheorem mk_lt_mk : mk a₁ a₂ < mk b₁ b₂ ↔ ↑b₂ * a₁ < a₂ * b₁ :=\n  Iff.rfl\n\n-- declaring this separately to the instance below makes things faster\n"}
{"name":"Localization.mk_lt_mk","module":"Mathlib.GroupTheory.MonoidLocalization.Order","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns : Submonoid α\na₁ b₁ : α\na₂ b₂ : Subtype fun x => Membership.mem s x\n⊢ Iff (LT.lt (Localization.mk a₁ a₂) (Localization.mk b₁ b₂)) (LT.lt (HMul.hMul (↑b₂) a₁) (HMul.hMul (↑a₂) b₁))","decl":"@[to_additive]\ntheorem mk_lt_mk : mk a₁ a₂ < mk b₁ b₂ ↔ ↑b₂ * a₁ < a₂ * b₁ :=\n  Iff.rfl\n\n-- declaring this separately to the instance below makes things faster\n"}
{"name":"Localization.mkOrderEmbedding_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Order","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns : Submonoid α\nb : Subtype fun x => Membership.mem s x\na : α\n⊢ Eq ((Localization.mkOrderEmbedding b) a) (Localization.mk a b)","decl":"/-- An ordered cancellative monoid injects into its localization by sending `a` to `a / b`. -/\n@[to_additive (attr := simps!) \"An ordered cancellative monoid injects into its localization by\nsending `a` to `a - b`.\"]\ndef mkOrderEmbedding (b : s) : α ↪o Localization s where\n  toFun a := mk a b\n  inj' := mk_left_injective _\n  map_rel_iff' {a b} := by simp [mk_le_mk]\n\n"}
{"name":"AddLocalization.mkOrderEmbedding_apply","module":"Mathlib.GroupTheory.MonoidLocalization.Order","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns : AddSubmonoid α\nb : Subtype fun x => Membership.mem s x\na : α\n⊢ Eq ((AddLocalization.mkOrderEmbedding b) a) (AddLocalization.mk a b)","decl":"/-- An ordered cancellative monoid injects into its localization by sending `a` to `a / b`. -/\n@[to_additive (attr := simps!) \"An ordered cancellative monoid injects into its localization by\nsending `a` to `a - b`.\"]\ndef mkOrderEmbedding (b : s) : α ↪o Localization s where\n  toFun a := mk a b\n  inj' := mk_left_injective _\n  map_rel_iff' {a b} := by simp [mk_le_mk]\n\n"}
