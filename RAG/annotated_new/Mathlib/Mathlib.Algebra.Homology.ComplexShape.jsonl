{"name":"ComplexShape.next_eq","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nself : ComplexShape ι\ni j j' : ι\na✝¹ : self.Rel i j\na✝ : self.Rel i j'\n⊢ Eq j j'","decl":"/-- A `c : ComplexShape ι` describes the shape of a chain complex,\nwith chain groups indexed by `ι`.\nTypically `ι` will be `ℕ`, `ℤ`, or `Fin n`.\n\nThere is a relation `Rel : ι → ι → Prop`,\nand we will only allow a non-zero differential from `i` to `j` when `Rel i j`.\n\nThere are axioms which imply `{ j // c.Rel i j }` and `{ i // c.Rel i j }` are subsingletons.\nThis means that the shape consists of some union of lines, rays, intervals, and circles.\n\nBelow we define `c.next` and `c.prev` which provide these related elements.\n-/\n@[ext]\nstructure ComplexShape (ι : Type*) where\n  /-- Nonzero differentials `X i ⟶ X j` shall be allowed\n    on homological complexes when `Rel i j` holds. -/\n  Rel : ι → ι → Prop\n  /-- There is at most one nonzero differential from `X i`. -/\n  next_eq : ∀ {i j j'}, Rel i j → Rel i j' → j = j'\n  /-- There is at most one nonzero differential to `X j`. -/\n  prev_eq : ∀ {i i' j}, Rel i j → Rel i' j → i = i'\n\n"}
{"name":"ComplexShape.ext","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nx y : ComplexShape ι\nRel : Eq x.Rel y.Rel\n⊢ Eq x y","decl":"/-- A `c : ComplexShape ι` describes the shape of a chain complex,\nwith chain groups indexed by `ι`.\nTypically `ι` will be `ℕ`, `ℤ`, or `Fin n`.\n\nThere is a relation `Rel : ι → ι → Prop`,\nand we will only allow a non-zero differential from `i` to `j` when `Rel i j`.\n\nThere are axioms which imply `{ j // c.Rel i j }` and `{ i // c.Rel i j }` are subsingletons.\nThis means that the shape consists of some union of lines, rays, intervals, and circles.\n\nBelow we define `c.next` and `c.prev` which provide these related elements.\n-/\n@[ext]\nstructure ComplexShape (ι : Type*) where\n  /-- Nonzero differentials `X i ⟶ X j` shall be allowed\n    on homological complexes when `Rel i j` holds. -/\n  Rel : ι → ι → Prop\n  /-- There is at most one nonzero differential from `X i`. -/\n  next_eq : ∀ {i j j'}, Rel i j → Rel i j' → j = j'\n  /-- There is at most one nonzero differential to `X j`. -/\n  prev_eq : ∀ {i i' j}, Rel i j → Rel i' j → i = i'\n\n"}
{"name":"ComplexShape.ext_iff","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nx y : ComplexShape ι\n⊢ Iff (Eq x y) (Eq x.Rel y.Rel)","decl":"/-- A `c : ComplexShape ι` describes the shape of a chain complex,\nwith chain groups indexed by `ι`.\nTypically `ι` will be `ℕ`, `ℤ`, or `Fin n`.\n\nThere is a relation `Rel : ι → ι → Prop`,\nand we will only allow a non-zero differential from `i` to `j` when `Rel i j`.\n\nThere are axioms which imply `{ j // c.Rel i j }` and `{ i // c.Rel i j }` are subsingletons.\nThis means that the shape consists of some union of lines, rays, intervals, and circles.\n\nBelow we define `c.next` and `c.prev` which provide these related elements.\n-/\n@[ext]\nstructure ComplexShape (ι : Type*) where\n  /-- Nonzero differentials `X i ⟶ X j` shall be allowed\n    on homological complexes when `Rel i j` holds. -/\n  Rel : ι → ι → Prop\n  /-- There is at most one nonzero differential from `X i`. -/\n  next_eq : ∀ {i j j'}, Rel i j → Rel i j' → j = j'\n  /-- There is at most one nonzero differential to `X j`. -/\n  prev_eq : ∀ {i i' j}, Rel i j → Rel i' j → i = i'\n\n"}
{"name":"ComplexShape.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\ninst✝ : SizeOf ι\nRel : ι → ι → Prop\nnext_eq : ∀ {i j j' : ι}, Rel i j → Rel i j' → Eq j j'\nprev_eq : ∀ {i i' j : ι}, Rel i j → Rel i' j → Eq i i'\n⊢ Eq (SizeOf.sizeOf { Rel := Rel, next_eq := next_eq, prev_eq := prev_eq }) 1","decl":"/-- A `c : ComplexShape ι` describes the shape of a chain complex,\nwith chain groups indexed by `ι`.\nTypically `ι` will be `ℕ`, `ℤ`, or `Fin n`.\n\nThere is a relation `Rel : ι → ι → Prop`,\nand we will only allow a non-zero differential from `i` to `j` when `Rel i j`.\n\nThere are axioms which imply `{ j // c.Rel i j }` and `{ i // c.Rel i j }` are subsingletons.\nThis means that the shape consists of some union of lines, rays, intervals, and circles.\n\nBelow we define `c.next` and `c.prev` which provide these related elements.\n-/\n@[ext]\nstructure ComplexShape (ι : Type*) where\n  /-- Nonzero differentials `X i ⟶ X j` shall be allowed\n    on homological complexes when `Rel i j` holds. -/\n  Rel : ι → ι → Prop\n  /-- There is at most one nonzero differential from `X i`. -/\n  next_eq : ∀ {i j j'}, Rel i j → Rel i j' → j = j'\n  /-- There is at most one nonzero differential to `X j`. -/\n  prev_eq : ∀ {i i' j}, Rel i j → Rel i' j → i = i'\n\n"}
{"name":"ComplexShape.prev_eq","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nself : ComplexShape ι\ni i' j : ι\na✝¹ : self.Rel i j\na✝ : self.Rel i' j\n⊢ Eq i i'","decl":"/-- A `c : ComplexShape ι` describes the shape of a chain complex,\nwith chain groups indexed by `ι`.\nTypically `ι` will be `ℕ`, `ℤ`, or `Fin n`.\n\nThere is a relation `Rel : ι → ι → Prop`,\nand we will only allow a non-zero differential from `i` to `j` when `Rel i j`.\n\nThere are axioms which imply `{ j // c.Rel i j }` and `{ i // c.Rel i j }` are subsingletons.\nThis means that the shape consists of some union of lines, rays, intervals, and circles.\n\nBelow we define `c.next` and `c.prev` which provide these related elements.\n-/\n@[ext]\nstructure ComplexShape (ι : Type*) where\n  /-- Nonzero differentials `X i ⟶ X j` shall be allowed\n    on homological complexes when `Rel i j` holds. -/\n  Rel : ι → ι → Prop\n  /-- There is at most one nonzero differential from `X i`. -/\n  next_eq : ∀ {i j j'}, Rel i j → Rel i j' → j = j'\n  /-- There is at most one nonzero differential to `X j`. -/\n  prev_eq : ∀ {i i' j}, Rel i j → Rel i' j → i = i'\n\n"}
{"name":"ComplexShape.mk.injEq","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nRel✝ : ι → ι → Prop\nnext_eq✝ : ∀ {i j j' : ι}, Rel✝ i j → Rel✝ i j' → Eq j j'\nprev_eq✝ : ∀ {i i' j : ι}, Rel✝ i j → Rel✝ i' j → Eq i i'\nRel : ι → ι → Prop\nnext_eq : ∀ {i j j' : ι}, Rel i j → Rel i j' → Eq j j'\nprev_eq : ∀ {i i' j : ι}, Rel i j → Rel i' j → Eq i i'\n⊢ Eq (Eq { Rel := Rel✝, next_eq := next_eq✝, prev_eq := prev_eq✝ } { Rel := Rel, next_eq := next_eq, prev_eq := prev_eq }) (Eq Rel✝ Rel)","decl":"/-- A `c : ComplexShape ι` describes the shape of a chain complex,\nwith chain groups indexed by `ι`.\nTypically `ι` will be `ℕ`, `ℤ`, or `Fin n`.\n\nThere is a relation `Rel : ι → ι → Prop`,\nand we will only allow a non-zero differential from `i` to `j` when `Rel i j`.\n\nThere are axioms which imply `{ j // c.Rel i j }` and `{ i // c.Rel i j }` are subsingletons.\nThis means that the shape consists of some union of lines, rays, intervals, and circles.\n\nBelow we define `c.next` and `c.prev` which provide these related elements.\n-/\n@[ext]\nstructure ComplexShape (ι : Type*) where\n  /-- Nonzero differentials `X i ⟶ X j` shall be allowed\n    on homological complexes when `Rel i j` holds. -/\n  Rel : ι → ι → Prop\n  /-- There is at most one nonzero differential from `X i`. -/\n  next_eq : ∀ {i j j'}, Rel i j → Rel i j' → j = j'\n  /-- There is at most one nonzero differential to `X j`. -/\n  prev_eq : ∀ {i i' j}, Rel i j → Rel i' j → i = i'\n\n"}
{"name":"ComplexShape.mk.inj","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nRel✝ : ι → ι → Prop\nnext_eq✝ : ∀ {i j j' : ι}, Rel✝ i j → Rel✝ i j' → Eq j j'\nprev_eq✝ : ∀ {i i' j : ι}, Rel✝ i j → Rel✝ i' j → Eq i i'\nRel : ι → ι → Prop\nnext_eq : ∀ {i j j' : ι}, Rel i j → Rel i j' → Eq j j'\nprev_eq : ∀ {i i' j : ι}, Rel i j → Rel i' j → Eq i i'\nx✝ : Eq { Rel := Rel✝, next_eq := next_eq✝, prev_eq := prev_eq✝ } { Rel := Rel, next_eq := next_eq, prev_eq := prev_eq }\n⊢ Eq Rel✝ Rel","decl":"/-- A `c : ComplexShape ι` describes the shape of a chain complex,\nwith chain groups indexed by `ι`.\nTypically `ι` will be `ℕ`, `ℤ`, or `Fin n`.\n\nThere is a relation `Rel : ι → ι → Prop`,\nand we will only allow a non-zero differential from `i` to `j` when `Rel i j`.\n\nThere are axioms which imply `{ j // c.Rel i j }` and `{ i // c.Rel i j }` are subsingletons.\nThis means that the shape consists of some union of lines, rays, intervals, and circles.\n\nBelow we define `c.next` and `c.prev` which provide these related elements.\n-/\n@[ext]\nstructure ComplexShape (ι : Type*) where\n  /-- Nonzero differentials `X i ⟶ X j` shall be allowed\n    on homological complexes when `Rel i j` holds. -/\n  Rel : ι → ι → Prop\n  /-- There is at most one nonzero differential from `X i`. -/\n  next_eq : ∀ {i j j'}, Rel i j → Rel i j' → j = j'\n  /-- There is at most one nonzero differential to `X j`. -/\n  prev_eq : ∀ {i i' j}, Rel i j → Rel i' j → i = i'\n\n"}
{"name":"ComplexShape.refl_Rel","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_2\ni j : ι\n⊢ Eq ((ComplexShape.refl ι).Rel i j) (Eq i j)","decl":"/-- The complex shape where only differentials from each `X.i` to itself are allowed.\n\nThis is mostly only useful so we can describe the relation of \"related in `k` steps\" below.\n-/\n@[simps]\ndef refl (ι : Type*) : ComplexShape ι where\n  Rel i j := i = j\n  next_eq w w' := w.symm.trans w'\n  prev_eq w w' := w.trans w'.symm\n\n"}
{"name":"ComplexShape.symm_Rel","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\ni j : ι\n⊢ Eq (c.symm.Rel i j) (c.Rel j i)","decl":"/-- The reverse of a `ComplexShape`.\n-/\n@[simps]\ndef symm (c : ComplexShape ι) : ComplexShape ι where\n  Rel i j := c.Rel j i\n  next_eq w w' := c.prev_eq w w'\n  prev_eq w w' := c.next_eq w w'\n\n"}
{"name":"ComplexShape.symm_symm","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\n⊢ Eq c.symm.symm c","decl":"@[simp]\ntheorem symm_symm (c : ComplexShape ι) : c.symm.symm = c := rfl\n\n"}
{"name":"ComplexShape.symm_bijective","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\n⊢ Function.Bijective ComplexShape.symm","decl":"theorem symm_bijective :\n    Function.Bijective (ComplexShape.symm : ComplexShape ι → ComplexShape ι) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"ComplexShape.subsingleton_next","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\ni : ι\n⊢ Subsingleton (Subtype fun j => c.Rel i j)","decl":"instance subsingleton_next (c : ComplexShape ι) (i : ι) : Subsingleton { j // c.Rel i j } := by\n  constructor\n  rintro ⟨j, rij⟩ ⟨k, rik⟩\n  congr\n  exact c.next_eq rij rik\n\n"}
{"name":"ComplexShape.subsingleton_prev","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nj : ι\n⊢ Subsingleton (Subtype fun i => c.Rel i j)","decl":"instance subsingleton_prev (c : ComplexShape ι) (j : ι) : Subsingleton { i // c.Rel i j } := by\n  constructor\n  rintro ⟨i, rik⟩ ⟨j, rjk⟩\n  congr\n  exact c.prev_eq rik rjk\n\n"}
{"name":"ComplexShape.next_eq'","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\ni j : ι\nh : c.Rel i j\n⊢ Eq (c.next i) j","decl":"theorem next_eq' (c : ComplexShape ι) {i j : ι} (h : c.Rel i j) : c.next i = j := by\n  apply c.next_eq _ h\n  rw [next]\n  rw [dif_pos]\n  exact Exists.choose_spec ⟨j, h⟩\n\n"}
{"name":"ComplexShape.prev_eq'","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\ni j : ι\nh : c.Rel i j\n⊢ Eq (c.prev j) i","decl":"theorem prev_eq' (c : ComplexShape ι) {i j : ι} (h : c.Rel i j) : c.prev j = i := by\n  apply c.prev_eq _ h\n  rw [prev, dif_pos]\n  exact Exists.choose_spec (⟨i, h⟩ : ∃ k, c.Rel k j)\n\n"}
{"name":"ComplexShape.next_eq_self'","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nj : ι\nhj : ∀ (k : ι), Not (c.Rel j k)\n⊢ Eq (c.next j) j","decl":"lemma next_eq_self' (c : ComplexShape ι) (j : ι) (hj : ∀ k, ¬ c.Rel j k) :\n    c.next j = j :=\n  dif_neg (by simpa using hj)\n\n"}
{"name":"ComplexShape.prev_eq_self'","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nj : ι\nhj : ∀ (i : ι), Not (c.Rel i j)\n⊢ Eq (c.prev j) j","decl":"lemma prev_eq_self' (c : ComplexShape ι) (j : ι) (hj : ∀ i, ¬ c.Rel i j) :\n    c.prev j = j :=\n  dif_neg (by simpa using hj)\n\n"}
{"name":"ComplexShape.next_eq_self","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nj : ι\nhj : Not (c.Rel j (c.next j))\n⊢ Eq (c.next j) j","decl":"lemma next_eq_self (c : ComplexShape ι) (j : ι) (hj : ¬ c.Rel j (c.next j)) :\n    c.next j = j :=\n  c.next_eq_self' j (fun k hk' => hj (by simpa only [c.next_eq' hk'] using hk'))\n\n"}
{"name":"ComplexShape.prev_eq_self","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nj : ι\nhj : Not (c.Rel (c.prev j) j)\n⊢ Eq (c.prev j) j","decl":"lemma prev_eq_self (c : ComplexShape ι) (j : ι) (hj : ¬ c.Rel (c.prev j) j) :\n    c.prev j = j :=\n  c.prev_eq_self' j (fun k hk' => hj (by simpa only [c.prev_eq' hk'] using hk'))\n\n"}
{"name":"ComplexShape.up'_Rel","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"α : Type u_2\ninst✝ : AddRightCancelSemigroup α\na i j : α\n⊢ Eq ((ComplexShape.up' a).Rel i j) (Eq (HAdd.hAdd i a) j)","decl":"/-- The `ComplexShape` allowing differentials from `X i` to `X (i+a)`.\n(For example when `a = 1`, a cohomology theory indexed by `ℕ` or `ℤ`)\n-/\n@[simps]\ndef up' {α : Type*} [AddRightCancelSemigroup α] (a : α) : ComplexShape α where\n  Rel i j := i + a = j\n  next_eq hi hj := hi.symm.trans hj\n  prev_eq hi hj := add_right_cancel (hi.trans hj.symm)\n\n"}
{"name":"ComplexShape.down'_Rel","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"α : Type u_2\ninst✝ : AddRightCancelSemigroup α\na i j : α\n⊢ Eq ((ComplexShape.down' a).Rel i j) (Eq (HAdd.hAdd j a) i)","decl":"/-- The `ComplexShape` allowing differentials from `X (j+a)` to `X j`.\n(For example when `a = 1`, a homology theory indexed by `ℕ` or `ℤ`)\n-/\n@[simps]\ndef down' {α : Type*} [AddRightCancelSemigroup α] (a : α) : ComplexShape α where\n  Rel i j := j + a = i\n  next_eq hi hj := add_right_cancel (hi.trans hj.symm)\n  prev_eq hi hj := hi.symm.trans hj\n\n"}
{"name":"ComplexShape.down'_mk","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"α : Type u_2\ninst✝ : AddRightCancelSemigroup α\na i j : α\nh : Eq (HAdd.hAdd j a) i\n⊢ (ComplexShape.down' a).Rel i j","decl":"theorem down'_mk {α : Type*} [AddRightCancelSemigroup α] (a : α) (i j : α) (h : j + a = i) :\n    (down' a).Rel i j := h\n\n"}
{"name":"ComplexShape.up_Rel","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"α : Type u_2\ninst✝¹ : AddRightCancelSemigroup α\ninst✝ : One α\ni j : α\n⊢ Eq ((ComplexShape.up α).Rel i j) (Eq (HAdd.hAdd i 1) j)","decl":"/-- The `ComplexShape` appropriate for cohomology, so `d : X i ⟶ X j` only when `j = i + 1`.\n-/\n@[simps!]\ndef up (α : Type*) [AddRightCancelSemigroup α] [One α] : ComplexShape α :=\n  up' 1\n\n"}
{"name":"ComplexShape.down_Rel","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"α : Type u_2\ninst✝¹ : AddRightCancelSemigroup α\ninst✝ : One α\ni j : α\n⊢ Eq ((ComplexShape.down α).Rel i j) (Eq (HAdd.hAdd j 1) i)","decl":"/-- The `ComplexShape` appropriate for homology, so `d : X i ⟶ X j` only when `i = j + 1`.\n-/\n@[simps!]\ndef down (α : Type*) [AddRightCancelSemigroup α] [One α] : ComplexShape α :=\n  down' 1\n\n"}
{"name":"ComplexShape.down_mk","module":"Mathlib.Algebra.Homology.ComplexShape","initialProofState":"α : Type u_2\ninst✝¹ : AddRightCancelSemigroup α\ninst✝ : One α\ni j : α\nh : Eq (HAdd.hAdd j 1) i\n⊢ (ComplexShape.down α).Rel i j","decl":"theorem down_mk {α : Type*} [AddRightCancelSemigroup α] [One α] (i j : α) (h : j + 1 = i) :\n    (down α).Rel i j :=\n  down'_mk (1 : α) i j h\n\n"}
