{"name":"CategoryTheory.ExponentialIdeal.exp_closed","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts C\ninst‚úù : CategoryTheory.CartesianClosed C\nself : CategoryTheory.ExponentialIdeal i\nB : C\na‚úù : Membership.mem i.essImage B\nA : C\n‚ä¢ Membership.mem i.essImage ((CategoryTheory.exp A).obj B)","decl":"/-- The subcategory `D` of `C` expressed as an inclusion functor is an *exponential ideal* if\n`B ‚àà D` implies `A ‚üπ B ‚àà D` for all `A`.\n-/\nclass ExponentialIdeal : Prop where\n  exp_closed : ‚àÄ {B}, B ‚àà i.essImage ‚Üí ‚àÄ A, (A ‚üπ B) ‚àà i.essImage\n"}
{"name":"CategoryTheory.ExponentialIdeal.mk'","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts C\ninst‚úù : CategoryTheory.CartesianClosed C\nh : ‚àÄ (B : D) (A : C), Membership.mem i.essImage ((CategoryTheory.exp A).obj (i.obj B))\n‚ä¢ CategoryTheory.ExponentialIdeal i","decl":"/-- To show `i` is an exponential ideal it suffices to show that `A ‚üπ iB` is \"in\" `D` for any `A` in\n`C` and `B` in `D`.\n-/\ntheorem ExponentialIdeal.mk' (h : ‚àÄ (B : D) (A : C), (A ‚üπ i.obj B) ‚àà i.essImage) :\n    ExponentialIdeal i :=\n  ‚ü®fun hB A => by\n    rcases hB with ‚ü®B', ‚ü®iB'‚ü©‚ü©\n    exact Functor.essImage.ofIso ((exp A).mapIso iB') (h B' A)‚ü©\n\n"}
{"name":"CategoryTheory.instExponentialIdealId","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts C\ninst‚úù : CategoryTheory.CartesianClosed C\n‚ä¢ CategoryTheory.ExponentialIdeal (CategoryTheory.Functor.id C)","decl":"/-- The entire category viewed as a subcategory is an exponential ideal. -/\ninstance : ExponentialIdeal (ùü≠ C) :=\n  ExponentialIdeal.mk' _ fun _ _ => ‚ü®_, ‚ü®Iso.refl _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.instExponentialIdealSubterminalsSubterminalInclusion","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts C\ninst‚úù : CategoryTheory.CartesianClosed C\n‚ä¢ CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)","decl":"/-- The subcategory of subterminal objects is an exponential ideal. -/\ninstance : ExponentialIdeal (subterminalInclusion C) := by\n  apply ExponentialIdeal.mk'\n  intro B A\n  refine ‚ü®‚ü®A ‚üπ B.1, fun Z g h => ?_‚ü©, ‚ü®Iso.refl _‚ü©‚ü©\n  exact uncurry_injective (B.2 (CartesianClosed.uncurry g) (CartesianClosed.uncurry h))\n\n"}
{"name":"CategoryTheory.ExponentialIdeal.mk_of_iso","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts C\ninst‚úù¬π : CategoryTheory.CartesianClosed C\ninst‚úù : CategoryTheory.Reflective i\nh : (A : C) ‚Üí CategoryTheory.Iso (i.comp ((CategoryTheory.exp A).comp ((CategoryTheory.reflector i).comp i))) (i.comp (CategoryTheory.exp A))\n‚ä¢ CategoryTheory.ExponentialIdeal i","decl":"/-- Given a natural isomorphism `i ‚ãô exp A ‚ãô leftAdjoint i ‚ãô i ‚âÖ i ‚ãô exp A`, we can show `i`\nis an exponential ideal.\n-/\ntheorem ExponentialIdeal.mk_of_iso [Reflective i]\n    (h : ‚àÄ A : C, i ‚ãô exp A ‚ãô reflector i ‚ãô i ‚âÖ i ‚ãô exp A) : ExponentialIdeal i := by\n  apply ExponentialIdeal.mk'\n  intro B A\n  exact ‚ü®_, ‚ü®(h A).app B‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.reflective_products","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Reflective i\n‚ä¢ CategoryTheory.Limits.HasFiniteProducts D","decl":"theorem reflective_products [Limits.HasFiniteProducts C] [Reflective i] :\n    Limits.HasFiniteProducts D := ‚ü®fun _ => hasLimitsOfShape_of_reflective i‚ü©\n\n"}
{"name":"CategoryTheory.exponentialIdeal_of_preservesBinaryProducts","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù¬≥ : CategoryTheory.ChosenFiniteProducts C\ninst‚úù¬≤ : CategoryTheory.Reflective i\ninst‚úù¬π : CategoryTheory.CartesianClosed C\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) (CategoryTheory.reflector i)\n‚ä¢ CategoryTheory.ExponentialIdeal i","decl":"/-- If the reflector preserves binary products, the subcategory is an exponential ideal.\nThis is the converse of `preservesBinaryProductsOfExponentialIdeal`.\n-/\ninstance (priority := 10) exponentialIdeal_of_preservesBinaryProducts\n    [Limits.PreservesLimitsOfShape (Discrete Limits.WalkingPair) (reflector i)] :\n    ExponentialIdeal i := by\n  let ir := reflectorAdjunction i\n  let L : C ‚•§ D := reflector i\n  let Œ∑ : ùü≠ C ‚ü∂ L ‚ãô i := ir.unit\n  let Œµ : i ‚ãô L ‚ü∂ ùü≠ D := ir.counit\n  apply ExponentialIdeal.mk'\n  intro B A\n  let q : i.obj (L.obj (A ‚üπ i.obj B)) ‚ü∂ A ‚üπ i.obj B := by\n    apply CartesianClosed.curry (ir.homEquiv _ _ _)\n    apply _ ‚â´ (ir.homEquiv _ _).symm ((exp.ev A).app (i.obj B))\n    exact prodComparison L A _ ‚â´ (_ ‚óÅ (Œµ.app _)) ‚â´ inv (prodComparison _ _ _)\n  have : Œ∑.app (A ‚üπ i.obj B) ‚â´ q = ùüô (A ‚üπ i.obj B) := by\n    dsimp\n    rw [‚Üê curry_natural_left, curry_eq_iff, uncurry_id_eq_ev, ‚Üê ir.homEquiv_naturality_left,\n      ir.homEquiv_apply_eq, assoc, assoc, prodComparison_natural_whiskerLeft_assoc,\n      ‚Üê MonoidalCategory.whiskerLeft_comp_assoc,\n      ir.left_triangle_components, MonoidalCategory.whiskerLeft_id, id_comp]\n    apply IsIso.hom_inv_id_assoc\n  haveI : IsSplitMono (Œ∑.app (A ‚üπ i.obj B)) := IsSplitMono.mk' ‚ü®_, this‚ü©\n  apply mem_essImage_of_unit_isSplitMono\n\n"}
{"name":"CategoryTheory.bijection_symm_apply_id","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\ninst‚úù¬≥ : CategoryTheory.Reflective i\ninst‚úù¬≤ : CategoryTheory.CartesianClosed C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\ninst‚úù : CategoryTheory.ExponentialIdeal i\nA B : C\n‚ä¢ Eq ((CategoryTheory.bijection i A B (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.reflector i).obj A) ((CategoryTheory.reflector i).obj B))).symm (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.reflector i).obj A) ((CategoryTheory.reflector i).obj B)))) (CategoryTheory.ChosenFiniteProducts.prodComparison (CategoryTheory.reflector i) A B)","decl":"theorem bijection_symm_apply_id (A B : C) :\n    (bijection i A B _).symm (ùüô _) = prodComparison _ _ _ := by\n  dsimp [bijection]\n  -- Porting note: added\n  erw [homEquiv_symm_apply_eq, homEquiv_symm_apply_eq, homEquiv_apply_eq, homEquiv_apply_eq]\n  rw [comp_id, comp_id, comp_id, i.map_id, comp_id, unitCompPartialBijective_symm_apply,\n    unitCompPartialBijective_symm_apply, uncurry_natural_left, uncurry_curry,\n    uncurry_natural_left, uncurry_curry, ‚Üê BraidedCategory.braiding_naturality_left_assoc]\n  erw [SymmetricCategory.symmetry_assoc, ‚Üê MonoidalCategory.whisker_exchange_assoc]\n  -- Porting note: added\n  dsimp only [Functor.comp_obj]\n  rw [‚Üê tensorHom_def'_assoc, Adjunction.homEquiv_symm_apply,\n    ‚Üê Adjunction.eq_unit_comp_map_iff, Iso.comp_inv_eq, assoc]\n  rw [prodComparisonIso_hom i ((reflector i).obj A) ((reflector i).obj B)]\n  apply hom_ext\n  ¬∑ rw [tensorHom_fst, assoc, assoc, prodComparison_fst, ‚Üê i.map_comp,\n    prodComparison_fst]\n    apply (reflectorAdjunction i).unit.naturality\n  ¬∑ rw [tensorHom_snd, assoc, assoc, prodComparison_snd, ‚Üê i.map_comp,\n    prodComparison_snd]\n    apply (reflectorAdjunction i).unit.naturality\n\n"}
{"name":"CategoryTheory.bijection_natural","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\ninst‚úù¬≥ : CategoryTheory.Reflective i\ninst‚úù¬≤ : CategoryTheory.CartesianClosed C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\ninst‚úù : CategoryTheory.ExponentialIdeal i\nA B : C\nX X' : D\nf : Quiver.Hom ((CategoryTheory.reflector i).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj A B)) X\ng : Quiver.Hom X X'\n‚ä¢ Eq ((CategoryTheory.bijection i A B X') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.bijection i A B X) f) g)","decl":"theorem bijection_natural (A B : C) (X X' : D) (f : (reflector i).obj (A ‚äó B) ‚ü∂ X) (g : X ‚ü∂ X') :\n    bijection i _ _ _ (f ‚â´ g) = bijection i _ _ _ f ‚â´ g := by\n  dsimp [bijection]\n  -- Porting note: added\n  erw [homEquiv_symm_apply_eq, homEquiv_symm_apply_eq, homEquiv_apply_eq, homEquiv_apply_eq,\n    homEquiv_symm_apply_eq, homEquiv_symm_apply_eq, homEquiv_apply_eq, homEquiv_apply_eq]\n  apply i.map_injective\n  rw [Functor.FullyFaithful.map_preimage, i.map_comp,\n    Adjunction.homEquiv_unit, Adjunction.homEquiv_unit]\n  simp only [comp_id, Functor.map_comp, Functor.FullyFaithful.map_preimage, assoc]\n  rw [‚Üê assoc, ‚Üê assoc, curry_natural_right _ (i.map g),\n    unitCompPartialBijective_natural, uncurry_natural_right, ‚Üê assoc, curry_natural_right,\n    unitCompPartialBijective_natural, uncurry_natural_right, assoc]\n\n"}
{"name":"CategoryTheory.prodComparison_iso","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\ninst‚úù¬≥ : CategoryTheory.Reflective i\ninst‚úù¬≤ : CategoryTheory.CartesianClosed C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\ninst‚úù : CategoryTheory.ExponentialIdeal i\nA B : C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.ChosenFiniteProducts.prodComparison (CategoryTheory.reflector i) A B)","decl":"/--\nThe bijection allows us to show that `prodComparison L A B` is an isomorphism, where the inverse\nis the forward map of the identity morphism.\n-/\ntheorem prodComparison_iso (A B : C) : IsIso\n    (prodComparison (reflector i) A B) :=\n  ‚ü®‚ü®bijection i _ _ _ (ùüô _), by\n      rw [‚Üê (bijection i _ _ _).injective.eq_iff, bijection_natural, ‚Üê bijection_symm_apply_id,\n        Equiv.apply_symm_apply, id_comp],\n      by rw [‚Üê bijection_natural, id_comp, ‚Üê bijection_symm_apply_id, Equiv.apply_symm_apply]‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.preservesBinaryProducts_of_exponentialIdeal","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù‚Å¥ : CategoryTheory.ChosenFiniteProducts C\ninst‚úù¬≥ : CategoryTheory.Reflective i\ninst‚úù¬≤ : CategoryTheory.CartesianClosed C\ninst‚úù¬π : CategoryTheory.ChosenFiniteProducts D\ninst‚úù : CategoryTheory.ExponentialIdeal i\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) (CategoryTheory.reflector i)","decl":"/--\nIf a reflective subcategory is an exponential ideal, then the reflector preserves binary products.\nThis is the converse of `exponentialIdeal_of_preserves_binary_products`.\n-/\nlemma preservesBinaryProducts_of_exponentialIdeal :\n    PreservesLimitsOfShape (Discrete WalkingPair) (reflector i) where\n  preservesLimit {K} :=\n    letI := preservesLimit_pair_of_isIso_prodComparison\n      (reflector i) (K.obj ‚ü®WalkingPair.left‚ü©) (K.obj ‚ü®WalkingPair.right‚ü©)\n    Limits.preservesLimit_of_iso_diagram _ (diagramIsoPair K).symm\n\n"}
{"name":"CategoryTheory.preservesFiniteProducts_of_exponentialIdeal","module":"Mathlib.CategoryTheory.Closed.Ideal","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù‚Åµ : CategoryTheory.ChosenFiniteProducts C\ninst‚úù‚Å¥ : CategoryTheory.Reflective i\ninst‚úù¬≥ : CategoryTheory.CartesianClosed C\ninst‚úù¬≤ : CategoryTheory.ChosenFiniteProducts D\ninst‚úù¬π : CategoryTheory.ExponentialIdeal i\nJ : Type\ninst‚úù : Fintype J\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) (CategoryTheory.reflector i)","decl":"/--\nIf a reflective subcategory is an exponential ideal, then the reflector preserves finite products.\n-/\nlemma preservesFiniteProducts_of_exponentialIdeal (J : Type) [Fintype J] :\n    PreservesLimitsOfShape (Discrete J) (reflector i) := by\n  letI := preservesBinaryProducts_of_exponentialIdeal i\n  letI : PreservesLimitsOfShape _ (reflector i) := leftAdjoint_preservesTerminal_of_reflective.{0} i\n  apply preservesFiniteProducts_of_preserves_binary_and_terminal (reflector i) J\n\n"}
