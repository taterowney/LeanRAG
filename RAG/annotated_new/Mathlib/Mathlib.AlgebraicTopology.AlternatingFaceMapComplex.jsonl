{"name":"AlgebraicTopology.AlternatingFaceMapComplex.d_squared","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.AlternatingFaceMapComplex.objD X (HAdd.hAdd n 1)) (AlgebraicTopology.AlternatingFaceMapComplex.objD X n)) 0","decl":"/-- ## The chain complex relation `d ≫ d`\n-/\ntheorem d_squared (n : ℕ) : objD X (n + 1) ≫ objD X n = 0 := by\n  -- we start by expanding d ≫ d as a double sum\n  dsimp\n  simp only [comp_sum, sum_comp, ← Finset.sum_product']\n  -- then, we decompose the index set P into a subset S and its complement Sᶜ\n  let P := Fin (n + 2) × Fin (n + 3)\n  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)\n  erw [← Finset.sum_add_sum_compl S, ← eq_neg_iff_add_eq_zero, ← Finset.sum_neg_distrib]\n  /- we are reduced to showing that two sums are equal, and this is obtained\n    by constructing a bijection φ : S -> Sᶜ, which maps (i,j) to (j,i+1),\n    and by comparing the terms -/\n  let φ : ∀ ij : P, ij ∈ S → P := fun ij hij =>\n    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)\n  apply Finset.sum_bij φ\n  · -- φ(S) is contained in Sᶜ\n    intro ij hij\n    simp only [S, φ, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and,\n      Fin.val_succ, Fin.coe_castLT] at hij ⊢\n    omega\n  · -- φ : S → Sᶜ is injective\n    rintro ⟨i, j⟩ hij ⟨i', j'⟩ hij' h\n    rw [Prod.mk.inj_iff]\n    exact ⟨by simpa [φ] using congr_arg Prod.snd h,\n      by simpa [φ, Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)⟩\n  · -- φ : S → Sᶜ is surjective\n    rintro ⟨i', j'⟩ hij'\n    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, Finset.compl_filter,\n      not_le, Finset.mem_filter, true_and] at hij'\n    refine ⟨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_⟩\n    · rintro rfl\n      simp only [Fin.val_zero, not_lt_zero'] at hij'\n    · simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, Finset.mem_filter,\n        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'\n    · simp only [φ, Fin.castLT_castSucc, Fin.succ_pred]\n  · -- identification of corresponding terms in both sums\n    rintro ⟨i, j⟩ hij\n    dsimp\n    simp only [zsmul_comp, comp_zsmul, smul_smul, ← neg_smul]\n    congr 1\n    · simp only [φ, Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]\n      apply mul_comm\n    · rw [CategoryTheory.SimplicialObject.δ_comp_δ'']\n      simpa [S] using hij\n\n"}
{"name":"AlgebraicTopology.AlternatingFaceMapComplex.obj_X","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n⊢ Eq ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).X n) (X.obj { unop := SimplexCategory.mk n })","decl":"@[simp]\ntheorem obj_X (X : SimplicialObject C) (n : ℕ) : (AlternatingFaceMapComplex.obj X).X n = X _[n] :=\n  rfl\n\n"}
{"name":"AlgebraicTopology.AlternatingFaceMapComplex.obj_d_eq","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n⊢ Eq ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).d (HAdd.hAdd n 1) n) (Finset.univ.sum fun i => HSMul.hSMul (HPow.hPow (-1) ↑i) (X.δ i))","decl":"@[simp]\ntheorem obj_d_eq (X : SimplicialObject C) (n : ℕ) :\n    (AlternatingFaceMapComplex.obj X).d (n + 1) n\n      = ∑ i : Fin (n + 2), (-1 : ℤ) ^ (i : ℕ) • X.δ i := by\n  apply ChainComplex.of_d\n\n"}
{"name":"AlgebraicTopology.AlternatingFaceMapComplex.map_f","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X Y\nn : Nat\n⊢ Eq ((AlgebraicTopology.AlternatingFaceMapComplex.map f).f n) (f.app { unop := SimplexCategory.mk n })","decl":"@[simp]\ntheorem map_f (f : X ⟶ Y) (n : ℕ) : (map f).f n = f.app (op [n]) :=\n  rfl\n\n"}
{"name":"AlgebraicTopology.alternatingFaceMapComplex_obj_X","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n⊢ Eq (((AlgebraicTopology.alternatingFaceMapComplex C).obj X).X n) (X.obj { unop := SimplexCategory.mk n })","decl":"@[simp]\ntheorem alternatingFaceMapComplex_obj_X (X : SimplicialObject C) (n : ℕ) :\n    ((alternatingFaceMapComplex C).obj X).X n = X _[n] :=\n  rfl\n\n"}
{"name":"AlgebraicTopology.alternatingFaceMapComplex_obj_d","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n⊢ Eq (((AlgebraicTopology.alternatingFaceMapComplex C).obj X).d (HAdd.hAdd n 1) n) (AlgebraicTopology.AlternatingFaceMapComplex.objD X n)","decl":"@[simp]\ntheorem alternatingFaceMapComplex_obj_d (X : SimplicialObject C) (n : ℕ) :\n    ((alternatingFaceMapComplex C).obj X).d (n + 1) n = AlternatingFaceMapComplex.objD X n := by\n dsimp only [alternatingFaceMapComplex, AlternatingFaceMapComplex.obj]\n apply ChainComplex.of_d\n\n"}
{"name":"AlgebraicTopology.alternatingFaceMapComplex_map_f","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X Y\nn : Nat\n⊢ Eq (((AlgebraicTopology.alternatingFaceMapComplex C).map f).f n) (f.app { unop := SimplexCategory.mk n })","decl":"@[simp]\ntheorem alternatingFaceMapComplex_map_f {X Y : SimplicialObject C} (f : X ⟶ Y) (n : ℕ) :\n    ((alternatingFaceMapComplex C).map f).f n = f.app (op [n]) :=\n  rfl\n\n"}
{"name":"AlgebraicTopology.map_alternatingFaceMapComplex","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq ((AlgebraicTopology.alternatingFaceMapComplex C).comp (F.mapHomologicalComplex (ComplexShape.down Nat))) (((CategoryTheory.SimplicialObject.whiskering C D).obj F).comp (AlgebraicTopology.alternatingFaceMapComplex D))","decl":"theorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C ⥤ D)\n    [F.Additive] :\n    alternatingFaceMapComplex C ⋙ F.mapHomologicalComplex _ =\n      (SimplicialObject.whiskering C D).obj F ⋙ alternatingFaceMapComplex D := by\n  apply CategoryTheory.Functor.ext\n  · intro X Y f\n    ext n\n    simp only [Functor.comp_map, HomologicalComplex.comp_f, alternatingFaceMapComplex_map_f,\n      Functor.mapHomologicalComplex_map_f, HomologicalComplex.eqToHom_f, eqToHom_refl, comp_id,\n      id_comp, SimplicialObject.whiskering_obj_map_app]\n  · intro X\n    apply HomologicalComplex.ext\n    · rintro i j (rfl : j + 1 = i)\n      dsimp only [Functor.comp_obj]\n      simp only [Functor.mapHomologicalComplex_obj_d, alternatingFaceMapComplex_obj_d,\n        eqToHom_refl, id_comp, comp_id, AlternatingFaceMapComplex.objD, Functor.map_sum,\n        Functor.map_zsmul]\n      rfl\n    · ext n\n      rfl\n\n"}
{"name":"AlgebraicTopology.karoubi_alternatingFaceMapComplex_d","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.SimplicialObject C)\nn : Nat\n⊢ Eq ((AlgebraicTopology.AlternatingFaceMapComplex.obj (CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.obj P)).d (HAdd.hAdd n 1) n).f (CategoryTheory.CategoryStruct.comp (P.p.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) ((AlgebraicTopology.AlternatingFaceMapComplex.obj P.X).d (HAdd.hAdd n 1) n))","decl":"theorem karoubi_alternatingFaceMapComplex_d (P : Karoubi (SimplicialObject C)) (n : ℕ) :\n    ((AlternatingFaceMapComplex.obj (KaroubiFunctorCategoryEmbedding.obj P)).d (n + 1) n).f =\n      P.p.app (op [n + 1]) ≫ (AlternatingFaceMapComplex.obj P.X).d (n + 1) n := by\n  dsimp\n  simp only [AlternatingFaceMapComplex.obj_d_eq, Karoubi.sum_hom, Preadditive.comp_sum,\n    Karoubi.zsmul_hom, Preadditive.comp_zsmul]\n  rfl\n\n"}
{"name":"AlgebraicTopology.AlternatingFaceMapComplex.ε_app_f_zero","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX : CategoryTheory.SimplicialObject.Augmented C\n⊢ Eq ((AlgebraicTopology.AlternatingFaceMapComplex.ε.app X).f 0) (X.hom.app { unop := SimplexCategory.mk 0 })","decl":"@[simp]\nlemma ε_app_f_zero [Limits.HasZeroObject C] (X : SimplicialObject.Augmented C) :\n    (ε.app X).f 0 = X.hom.app (op [0]) :=\n  ChainComplex.toSingle₀Equiv_symm_apply_f_zero _ _\n\n"}
{"name":"AlgebraicTopology.AlternatingFaceMapComplex.ε_app_f_succ","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX : CategoryTheory.SimplicialObject.Augmented C\nn : Nat\n⊢ Eq ((AlgebraicTopology.AlternatingFaceMapComplex.ε.app X).f (HAdd.hAdd n 1)) 0","decl":"@[simp]\nlemma ε_app_f_succ [Limits.HasZeroObject C] (X : SimplicialObject.Augmented C) (n : ℕ) :\n    (ε.app X).f (n + 1) = 0 := rfl\n\n"}
{"name":"AlgebraicTopology.inclusionOfMooreComplexMap_f","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"A : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} A\ninst✝ : CategoryTheory.Abelian A\nX : CategoryTheory.SimplicialObject A\nn : Nat\n⊢ Eq ((AlgebraicTopology.inclusionOfMooreComplexMap X).f n) (AlgebraicTopology.NormalizedMooreComplex.objX X n).arrow","decl":"@[simp]\ntheorem inclusionOfMooreComplexMap_f (X : SimplicialObject A) (n : ℕ) :\n    (inclusionOfMooreComplexMap X).f n = (NormalizedMooreComplex.objX X n).arrow := by\n  dsimp only [inclusionOfMooreComplexMap]\n  exact ChainComplex.ofHom_f _ _ _ _ _ _ _ _ n\n\n"}
{"name":"AlgebraicTopology.inclusionOfMooreComplex_app","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"A : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} A\ninst✝ : CategoryTheory.Abelian A\nX : CategoryTheory.SimplicialObject A\n⊢ Eq ((AlgebraicTopology.inclusionOfMooreComplex A).app X) (AlgebraicTopology.inclusionOfMooreComplexMap X)","decl":"/-- The inclusion map of the Moore complex in the alternating face map complex,\nas a natural transformation -/\n@[simps]\ndef inclusionOfMooreComplex : normalizedMooreComplex A ⟶ alternatingFaceMapComplex A where\n  app := inclusionOfMooreComplexMap\n\n"}
{"name":"AlgebraicTopology.AlternatingCofaceMapComplex.d_eq_unop_d","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\n⊢ Eq (AlgebraicTopology.AlternatingCofaceMapComplex.objD X n) (AlgebraicTopology.AlternatingFaceMapComplex.objD ((CategoryTheory.cosimplicialSimplicialEquiv C).functor.obj { unop := X }) n).unop","decl":"theorem d_eq_unop_d (n : ℕ) :\n    objD X n =\n      (AlternatingFaceMapComplex.objD ((cosimplicialSimplicialEquiv C).functor.obj (op X))\n          n).unop := by\n  simp only [objD, AlternatingFaceMapComplex.objD, unop_sum, unop_zsmul]\n  rfl\n\n"}
{"name":"AlgebraicTopology.AlternatingCofaceMapComplex.d_squared","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.AlternatingCofaceMapComplex.objD X n) (AlgebraicTopology.AlternatingCofaceMapComplex.objD X (HAdd.hAdd n 1))) 0","decl":"theorem d_squared (n : ℕ) : objD X n ≫ objD X (n + 1) = 0 := by\n  simp only [d_eq_unop_d, ← unop_comp, AlternatingFaceMapComplex.d_squared, unop_zero]\n\n"}
{"name":"AlgebraicTopology.alternatingCofaceMapComplex_obj","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.CosimplicialObject C\n⊢ Eq ((AlgebraicTopology.alternatingCofaceMapComplex C).obj X) (AlgebraicTopology.AlternatingCofaceMapComplex.obj X)","decl":"/-- The alternating coface map complex, as a functor -/\n@[simps]\ndef alternatingCofaceMapComplex : CosimplicialObject C ⥤ CochainComplex C ℕ where\n  obj := AlternatingCofaceMapComplex.obj\n  map f := AlternatingCofaceMapComplex.map f\n\n"}
{"name":"AlgebraicTopology.alternatingCofaceMapComplex_map","module":"Mathlib.AlgebraicTopology.AlternatingFaceMapComplex","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX✝ Y✝ : CategoryTheory.CosimplicialObject C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((AlgebraicTopology.alternatingCofaceMapComplex C).map f) (AlgebraicTopology.AlternatingCofaceMapComplex.map f)","decl":"/-- The alternating coface map complex, as a functor -/\n@[simps]\ndef alternatingCofaceMapComplex : CosimplicialObject C ⥤ CochainComplex C ℕ where\n  obj := AlternatingCofaceMapComplex.obj\n  map f := AlternatingCofaceMapComplex.map f\n\n"}
