{"name":"RingCon.coe_algebraMap","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝² : CommSemiring S\nA : Type uA\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nc : RingCon A\ns : S\n⊢ Eq (↑((algebraMap S A) s)) ((algebraMap S c.Quotient) s)","decl":"@[simp, norm_cast]\ntheorem coe_algebraMap (c : RingCon A) (s : S) :\n    (algebraMap S A s : c.Quotient) = algebraMap S _ s :=\n  rfl\n\n"}
{"name":"RingQuot.Rel.brecOn","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\nmotive✝ : (a a_1 : R) → RingQuot.Rel r a a_1 → Prop\na✝¹ a✝ : R\nx✝ : RingQuot.Rel r a✝¹ a✝\nih✝ : ∀ (a a_1 : R) (x : RingQuot.Rel r a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- Given an arbitrary relation `r` on a ring, we strengthen it to a relation `Rel r`,\nsuch that the equivalence relation generated by `Rel r` has `x ~ y` if and only if\n`x - y` is in the ideal generated by elements `a - b` such that `r a b`.\n-/\ninductive Rel (r : R → R → Prop) : R → R → Prop\n  | of ⦃x y : R⦄ (h : r x y) : Rel r x y\n  | add_left ⦃a b c⦄ : Rel r a b → Rel r (a + c) (b + c)\n  | mul_left ⦃a b c⦄ : Rel r a b → Rel r (a * c) (b * c)\n  | mul_right ⦃a b c⦄ : Rel r b c → Rel r (a * b) (a * c)\n\n"}
{"name":"RingQuot.Rel.add_right","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\na b c : R\nh : RingQuot.Rel r b c\n⊢ RingQuot.Rel r (HAdd.hAdd a b) (HAdd.hAdd a c)","decl":"theorem Rel.add_right {r : R → R → Prop} ⦃a b c : R⦄ (h : Rel r b c) : Rel r (a + b) (a + c) := by\n  rw [add_comm a b, add_comm a c]\n  exact Rel.add_left h\n\n"}
{"name":"RingQuot.Rel.neg","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Ring R\nr : R → R → Prop\na b : R\nh : RingQuot.Rel r a b\n⊢ RingQuot.Rel r (Neg.neg a) (Neg.neg b)","decl":"theorem Rel.neg {R : Type uR} [Ring R] {r : R → R → Prop} ⦃a b : R⦄ (h : Rel r a b) :\n    Rel r (-a) (-b) := by simp only [neg_eq_neg_one_mul a, neg_eq_neg_one_mul b, Rel.mul_right h]\n\n"}
{"name":"RingQuot.Rel.sub_left","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Ring R\nr : R → R → Prop\na b c : R\nh : RingQuot.Rel r a b\n⊢ RingQuot.Rel r (HSub.hSub a c) (HSub.hSub b c)","decl":"theorem Rel.sub_left {R : Type uR} [Ring R] {r : R → R → Prop} ⦃a b c : R⦄ (h : Rel r a b) :\n    Rel r (a - c) (b - c) := by simp only [sub_eq_add_neg, h.add_left]\n\n"}
{"name":"RingQuot.Rel.sub_right","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Ring R\nr : R → R → Prop\na b c : R\nh : RingQuot.Rel r b c\n⊢ RingQuot.Rel r (HSub.hSub a b) (HSub.hSub a c)","decl":"theorem Rel.sub_right {R : Type uR} [Ring R] {r : R → R → Prop} ⦃a b c : R⦄ (h : Rel r b c) :\n    Rel r (a - b) (a - c) := by simp only [sub_eq_add_neg, h.neg.add_right]\n\n"}
{"name":"RingQuot.Rel.smul","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝² : CommSemiring S\nA : Type uA\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nr : A → A → Prop\nk : S\na b : A\nh : RingQuot.Rel r a b\n⊢ RingQuot.Rel r (HSMul.hSMul k a) (HSMul.hSMul k b)","decl":"theorem Rel.smul {r : A → A → Prop} (k : S) ⦃a b : A⦄ (h : Rel r a b) : Rel r (k • a) (k • b) := by\n  simp only [Algebra.smul_def, Rel.mul_right h]\n\n"}
{"name":"RingQuot.eqvGen_rel_eq","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\n⊢ Eq (Relation.EqvGen (RingQuot.Rel r)) (RingConGen.Rel r)","decl":"theorem eqvGen_rel_eq (r : R → R → Prop) : Relation.EqvGen (Rel r) = RingConGen.Rel r := by\n  ext x₁ x₂\n  constructor\n  · intro h\n    induction h with\n    | rel _ _ h => induction h with\n      | of => exact RingConGen.Rel.of _ _ ‹_›\n      | add_left _ h => exact h.add (RingConGen.Rel.refl _)\n      | mul_left _ h => exact h.mul (RingConGen.Rel.refl _)\n      | mul_right _ h => exact (RingConGen.Rel.refl _).mul h\n    | refl => exact RingConGen.Rel.refl _\n    | symm => exact RingConGen.Rel.symm ‹_›\n    | trans => exact RingConGen.Rel.trans ‹_› ‹_›\n  · intro h\n    induction h with\n    | of => exact Relation.EqvGen.rel _ _ (Rel.of ‹_›)\n    | refl => exact (RingQuot.ringCon r).refl _\n    | symm => exact (RingQuot.ringCon r).symm ‹_›\n    | trans => exact (RingQuot.ringCon r).trans ‹_› ‹_›\n    | add => exact (RingQuot.ringCon r).add ‹_› ‹_›\n    | mul => exact (RingQuot.ringCon r).mul ‹_› ‹_›\n\n"}
{"name":"RingQuot.mk.injEq","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\ntoQuot✝ toQuot : Quot (RingQuot.Rel r)\n⊢ Eq (Eq { toQuot := toQuot✝ } { toQuot := toQuot }) (Eq toQuot✝ toQuot)","decl":"/-- The quotient of a ring by an arbitrary relation. -/\nstructure RingQuot (r : R → R → Prop) where\n  toQuot : Quot (RingQuot.Rel r)\n\n"}
{"name":"RingQuot.mk.inj","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\ntoQuot✝ toQuot : Quot (RingQuot.Rel r)\nx✝ : Eq { toQuot := toQuot✝ } { toQuot := toQuot }\n⊢ Eq toQuot✝ toQuot","decl":"/-- The quotient of a ring by an arbitrary relation. -/\nstructure RingQuot (r : R → R → Prop) where\n  toQuot : Quot (RingQuot.Rel r)\n\n"}
{"name":"RingQuot.mk.sizeOf_spec","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝² : Semiring R\nr : R → R → Prop\ninst✝¹ : SizeOf R\ninst✝ : (a a_1 : R) → SizeOf (r a a_1)\ntoQuot : Quot (RingQuot.Rel r)\n⊢ Eq (SizeOf.sizeOf { toQuot := toQuot }) (HAdd.hAdd 1 (SizeOf.sizeOf toQuot))","decl":"/-- The quotient of a ring by an arbitrary relation. -/\nstructure RingQuot (r : R → R → Prop) where\n  toQuot : Quot (RingQuot.Rel r)\n\n"}
{"name":"RingQuot.zero_quot","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\n⊢ Eq { toQuot := Quot.mk (RingQuot.Rel r) 0 } 0","decl":"theorem zero_quot : (⟨Quot.mk _ 0⟩ : RingQuot r) = 0 :=\n  show _ = zero r by rw [zero_def]\n\n"}
{"name":"RingQuot.one_quot","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\n⊢ Eq { toQuot := Quot.mk (RingQuot.Rel r) 1 } 1","decl":"theorem one_quot : (⟨Quot.mk _ 1⟩ : RingQuot r) = 1 :=\n  show _ = one r by rw [one_def]\n\n"}
{"name":"RingQuot.add_quot","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\na b : R\n⊢ Eq (HAdd.hAdd { toQuot := Quot.mk (RingQuot.Rel r) a } { toQuot := Quot.mk (RingQuot.Rel r) b }) { toQuot := Quot.mk (RingQuot.Rel r) (HAdd.hAdd a b) }","decl":"theorem add_quot {a b} : (⟨Quot.mk _ a⟩ + ⟨Quot.mk _ b⟩ : RingQuot r) = ⟨Quot.mk _ (a + b)⟩ := by\n  show add r _ _ = _\n  rw [add_def]\n  rfl\n\n"}
{"name":"RingQuot.mul_quot","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\na b : R\n⊢ Eq (HMul.hMul { toQuot := Quot.mk (RingQuot.Rel r) a } { toQuot := Quot.mk (RingQuot.Rel r) b }) { toQuot := Quot.mk (RingQuot.Rel r) (HMul.hMul a b) }","decl":"theorem mul_quot {a b} : (⟨Quot.mk _ a⟩ * ⟨Quot.mk _ b⟩ : RingQuot r) = ⟨Quot.mk _ (a * b)⟩ := by\n  show mul r _ _ = _\n  rw [mul_def]\n  rfl\n\n"}
{"name":"RingQuot.pow_quot","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\na : R\nn : Nat\n⊢ Eq (HPow.hPow { toQuot := Quot.mk (RingQuot.Rel r) a } n) { toQuot := Quot.mk (RingQuot.Rel r) (HPow.hPow a n) }","decl":"theorem pow_quot {a} {n : ℕ} : (⟨Quot.mk _ a⟩ ^ n : RingQuot r) = ⟨Quot.mk _ (a ^ n)⟩ := by\n  show npow r _ _ = _\n  rw [npow_def]\n\n"}
{"name":"RingQuot.neg_quot","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Ring R\nr : R → R → Prop\na : R\n⊢ Eq (Neg.neg { toQuot := Quot.mk (RingQuot.Rel r) a }) { toQuot := Quot.mk (RingQuot.Rel r) (Neg.neg a) }","decl":"theorem neg_quot {R : Type uR} [Ring R] (r : R → R → Prop) {a} :\n    (-⟨Quot.mk _ a⟩ : RingQuot r) = ⟨Quot.mk _ (-a)⟩ := by\n  show neg r _ = _\n  rw [neg_def]\n  rfl\n\n"}
{"name":"RingQuot.sub_quot","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Ring R\nr : R → R → Prop\na b : R\n⊢ Eq (HSub.hSub { toQuot := Quot.mk (RingQuot.Rel r) a } { toQuot := Quot.mk (RingQuot.Rel r) b }) { toQuot := Quot.mk (RingQuot.Rel r) (HSub.hSub a b) }","decl":"theorem sub_quot {R : Type uR} [Ring R] (r : R → R → Prop) {a b} :\n    (⟨Quot.mk _ a⟩ - ⟨Quot.mk _ b⟩ : RingQuot r) = ⟨Quot.mk _ (a - b)⟩ := by\n  show sub r _ _ = _\n  rw [sub_def]\n  rfl\n\n"}
{"name":"RingQuot.smul_quot","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝² : Semiring R\nS : Type uS\ninst✝¹ : CommSemiring S\nr : R → R → Prop\ninst✝ : Algebra S R\nn : S\na : R\n⊢ Eq (HSMul.hSMul n { toQuot := Quot.mk (RingQuot.Rel r) a }) { toQuot := Quot.mk (RingQuot.Rel r) (HSMul.hSMul n a) }","decl":"theorem smul_quot [Algebra S R] {n : S} {a : R} :\n    (n • ⟨Quot.mk _ a⟩ : RingQuot r) = ⟨Quot.mk _ (n • a)⟩ := by\n  show smul r _ _ = _\n  rw [smul]\n  rfl\n\n"}
{"name":"RingQuot.instIsScalarTower","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝⁶ : Semiring R\nS : Type uS\ninst✝⁵ : CommSemiring S\nT : Type uT\nr : R → R → Prop\ninst✝⁴ : CommSemiring T\ninst✝³ : SMul S T\ninst✝² : Algebra S R\ninst✝¹ : Algebra T R\ninst✝ : IsScalarTower S T R\n⊢ IsScalarTower S T (RingQuot r)","decl":"instance instIsScalarTower [CommSemiring T] [SMul S T] [Algebra S R] [Algebra T R]\n    [IsScalarTower S T R] : IsScalarTower S T (RingQuot r) :=\n  ⟨fun s t ⟨a⟩ => Quot.inductionOn a fun a' => by simp only [RingQuot.smul_quot, smul_assoc]⟩\n\n"}
{"name":"RingQuot.instSMulCommClass","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝⁵ : Semiring R\nS : Type uS\ninst✝⁴ : CommSemiring S\nT : Type uT\nr : R → R → Prop\ninst✝³ : CommSemiring T\ninst✝² : Algebra S R\ninst✝¹ : Algebra T R\ninst✝ : SMulCommClass S T R\n⊢ SMulCommClass S T (RingQuot r)","decl":"instance instSMulCommClass [CommSemiring T] [Algebra S R] [Algebra T R] [SMulCommClass S T R] :\n    SMulCommClass S T (RingQuot r) :=\n  ⟨fun s t ⟨a⟩ => Quot.inductionOn a fun a' => by simp only [RingQuot.smul_quot, smul_comm]⟩\n\n"}
{"name":"RingQuot.mkRingHom_def","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R → R → Prop\n⊢ Eq (RingQuot.mkRingHom r) { toFun := fun x => { toQuot := Quot.mk (RingQuot.Rel r) x }, map_one' := ⋯, map_mul' := ⋯, map_zero' := ⋯, map_add' := ⋯ }","decl":"/-- The quotient map from a ring to its quotient, as a homomorphism of rings.\n-/\nirreducible_def mkRingHom (r : R → R → Prop) : R →+* RingQuot r :=\n  { toFun := fun x ↦ ⟨Quot.mk _ x⟩\n    map_one' := by simp [← one_quot]\n    map_mul' := by simp [mul_quot]\n    map_zero' := by simp [← zero_quot]\n    map_add' := by simp [add_quot] }\n\n"}
{"name":"RingQuot.mkRingHom_rel","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\nx y : R\nw : r x y\n⊢ Eq ((RingQuot.mkRingHom r) x) ((RingQuot.mkRingHom r) y)","decl":"theorem mkRingHom_rel {r : R → R → Prop} {x y : R} (w : r x y) : mkRingHom r x = mkRingHom r y := by\n  simp [mkRingHom_def, Quot.sound (Rel.of w)]\n\n"}
{"name":"RingQuot.mkRingHom_surjective","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝ : Semiring R\nr : R → R → Prop\n⊢ Function.Surjective ⇑(RingQuot.mkRingHom r)","decl":"theorem mkRingHom_surjective (r : R → R → Prop) : Function.Surjective (mkRingHom r) := by\n  simp only [mkRingHom_def, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk]\n  rintro ⟨⟨⟩⟩\n  simp\n\n"}
{"name":"RingQuot.ringQuot_ext_iff","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝¹ : Semiring R\nT : Type uT\ninst✝ : Semiring T\nr : R → R → Prop\nf g : RingHom (RingQuot r) T\n⊢ Iff (Eq f g) (Eq (f.comp (RingQuot.mkRingHom r)) (g.comp (RingQuot.mkRingHom r)))","decl":"@[ext 1100]\ntheorem ringQuot_ext [Semiring T] {r : R → R → Prop} (f g : RingQuot r →+* T)\n    (w : f.comp (mkRingHom r) = g.comp (mkRingHom r)) : f = g := by\n  ext x\n  rcases mkRingHom_surjective r x with ⟨x, rfl⟩\n  exact (RingHom.congr_fun w x :)\n\n"}
{"name":"RingQuot.ringQuot_ext","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝¹ : Semiring R\nT : Type uT\ninst✝ : Semiring T\nr : R → R → Prop\nf g : RingHom (RingQuot r) T\nw : Eq (f.comp (RingQuot.mkRingHom r)) (g.comp (RingQuot.mkRingHom r))\n⊢ Eq f g","decl":"@[ext 1100]\ntheorem ringQuot_ext [Semiring T] {r : R → R → Prop} (f g : RingQuot r →+* T)\n    (w : f.comp (mkRingHom r) = g.comp (mkRingHom r)) : f = g := by\n  ext x\n  rcases mkRingHom_surjective r x with ⟨x, rfl⟩\n  exact (RingHom.congr_fun w x :)\n\n"}
{"name":"RingQuot.preLift_def","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nT : Type u_2\ninst✝ : Semiring T\nr : R → R → Prop\nf : RingHom R T\nh : ∀ ⦃x y : R⦄, r x y → Eq (f x) (f y)\n⊢ Eq (RingQuot.preLift h) { toFun := fun x => Quot.lift ⇑f ⋯ x.toQuot, map_one' := ⋯, map_mul' := ⋯, map_zero' := ⋯, map_add' := ⋯ }","decl":"irreducible_def preLift {r : R → R → Prop} {f : R →+* T} (h : ∀ ⦃x y⦄, r x y → f x = f y) :\n  RingQuot r →+* T :=\n  { toFun := fun x ↦ Quot.lift f\n        (by\n          rintro _ _ r\n          induction r with\n          | of r => exact h r\n          | add_left _ r' => rw [map_add, map_add, r']\n          | mul_left _ r' => rw [map_mul, map_mul, r']\n          | mul_right _ r' => rw [map_mul, map_mul, r'])\n        x.toQuot\n    map_zero' := by simp only [← zero_quot, f.map_zero]\n    map_add' := by\n      rintro ⟨⟨x⟩⟩ ⟨⟨y⟩⟩\n      simp only [add_quot, f.map_add x y]\n    map_one' := by simp only [← one_quot, f.map_one]\n    map_mul' := by\n      rintro ⟨⟨x⟩⟩ ⟨⟨y⟩⟩\n      simp only [mul_quot, f.map_mul x y] }\n\n"}
{"name":"RingQuot.lift_def","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nT : Type u_2\ninst✝ : Semiring T\nr : R → R → Prop\n⊢ Eq RingQuot.lift { toFun := fun f => RingQuot.preLift ⋯, invFun := fun F => ⟨F.comp (RingQuot.mkRingHom r), ⋯⟩, left_inv := ⋯, right_inv := ⋯ }","decl":"/-- Any ring homomorphism `f : R →+* T` which respects a relation `r : R → R → Prop`\nfactors uniquely through a morphism `RingQuot r →+* T`.\n-/\nirreducible_def lift {r : R → R → Prop} :\n  { f : R →+* T // ∀ ⦃x y⦄, r x y → f x = f y } ≃ (RingQuot r →+* T) :=\n  { toFun := fun f ↦ preLift f.prop\n    invFun := fun F ↦ ⟨F.comp (mkRingHom r), fun _ _ h ↦ congr_arg F (mkRingHom_rel h)⟩\n    left_inv := fun f ↦ by\n      ext\n      simp only [preLift_def, mkRingHom_def, RingHom.coe_comp, RingHom.coe_mk, MonoidHom.coe_mk,\n                 OneHom.coe_mk, Function.comp_apply]\n    right_inv := fun F ↦ by\n      simp only [preLift_def]\n      ext\n      simp only [mkRingHom_def, RingHom.coe_comp, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk,\n                 Function.comp_apply, forall_const] }\n\n"}
{"name":"RingQuot.lift_mkRingHom_apply","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝¹ : Semiring R\nT : Type uT\ninst✝ : Semiring T\nf : RingHom R T\nr : R → R → Prop\nw : ∀ ⦃x y : R⦄, r x y → Eq (f x) (f y)\nx : R\n⊢ Eq ((RingQuot.lift ⟨f, w⟩) ((RingQuot.mkRingHom r) x)) (f x)","decl":"@[simp]\ntheorem lift_mkRingHom_apply (f : R →+* T) {r : R → R → Prop} (w : ∀ ⦃x y⦄, r x y → f x = f y) (x) :\n    lift ⟨f, w⟩ (mkRingHom r x) = f x := by\n  simp_rw [lift_def, preLift_def, mkRingHom_def]\n  rfl\n\n-- note this is essentially `lift.symm_apply_eq.mp h`\n"}
{"name":"RingQuot.lift_unique","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝¹ : Semiring R\nT : Type uT\ninst✝ : Semiring T\nf : RingHom R T\nr : R → R → Prop\nw : ∀ ⦃x y : R⦄, r x y → Eq (f x) (f y)\ng : RingHom (RingQuot r) T\nh : Eq (g.comp (RingQuot.mkRingHom r)) f\n⊢ Eq g (RingQuot.lift ⟨f, w⟩)","decl":"theorem lift_unique (f : R →+* T) {r : R → R → Prop} (w : ∀ ⦃x y⦄, r x y → f x = f y)\n    (g : RingQuot r →+* T) (h : g.comp (mkRingHom r) = f) : g = lift ⟨f, w⟩ := by\n  ext\n  simp [h]\n\n"}
{"name":"RingQuot.eq_lift_comp_mkRingHom","module":"Mathlib.Algebra.RingQuot","initialProofState":"R : Type uR\ninst✝¹ : Semiring R\nT : Type uT\ninst✝ : Semiring T\nr : R → R → Prop\nf : RingHom (RingQuot r) T\n⊢ Eq f (RingQuot.lift ⟨f.comp (RingQuot.mkRingHom r), ⋯⟩)","decl":"theorem eq_lift_comp_mkRingHom {r : R → R → Prop} (f : RingQuot r →+* T) :\n    f = lift ⟨f.comp (mkRingHom r), fun _ _ h ↦ congr_arg f (mkRingHom_rel h)⟩ := by\n  conv_lhs => rw [← lift.apply_symm_apply f]\n  rw [lift_def]\n  rfl\n\n"}
{"name":"RingQuot.ringQuotToIdealQuotient_apply","module":"Mathlib.Algebra.RingQuot","initialProofState":"B : Type uR\ninst✝ : CommRing B\nr : B → B → Prop\nx : B\n⊢ Eq ((RingQuot.ringQuotToIdealQuotient r) ((RingQuot.mkRingHom r) x)) ((Ideal.Quotient.mk (Ideal.ofRel r)) x)","decl":"@[simp]\ntheorem ringQuotToIdealQuotient_apply (r : B → B → Prop) (x : B) :\n    ringQuotToIdealQuotient r (mkRingHom r x) = Ideal.Quotient.mk (Ideal.ofRel r) x := by\n  simp_rw [ringQuotToIdealQuotient, lift_def, preLift_def, mkRingHom_def]\n  rfl\n\n"}
{"name":"RingQuot.idealQuotientToRingQuot_apply","module":"Mathlib.Algebra.RingQuot","initialProofState":"B : Type uR\ninst✝ : CommRing B\nr : B → B → Prop\nx : B\n⊢ Eq ((RingQuot.idealQuotientToRingQuot r) ((Ideal.Quotient.mk (Ideal.ofRel r)) x)) ((RingQuot.mkRingHom r) x)","decl":"@[simp]\ntheorem idealQuotientToRingQuot_apply (r : B → B → Prop) (x : B) :\n    idealQuotientToRingQuot r (Ideal.Quotient.mk _ x) = mkRingHom r x :=\n  rfl\n\n\n"}
{"name":"RingQuot.mkAlgHom_def","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type u_1\ninst✝² : CommSemiring S\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\ns : A → A → Prop\n⊢ Eq (RingQuot.mkAlgHom S s)\n    (let __src := RingQuot.mkRingHom s;\n    { toRingHom := __src, commutes' := ⋯ })","decl":"/-- The quotient map from an `S`-algebra to its quotient, as a homomorphism of `S`-algebras.\n-/\nirreducible_def mkAlgHom (s : A → A → Prop) : A →ₐ[S] RingQuot s :=\n  { mkRingHom s with\n    commutes' := fun _ ↦ by simp [mkRingHom_def]; rfl }\n\n"}
{"name":"RingQuot.mkAlgHom_coe","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝² : CommSemiring S\nA : Type uA\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\ns : A → A → Prop\n⊢ Eq (↑(RingQuot.mkAlgHom S s)) (RingQuot.mkRingHom s)","decl":"@[simp]\ntheorem mkAlgHom_coe (s : A → A → Prop) : (mkAlgHom S s : A →+* RingQuot s) = mkRingHom s := by\n  simp_rw [mkAlgHom_def, mkRingHom_def]\n  rfl\n\n"}
{"name":"RingQuot.mkAlgHom_rel","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝² : CommSemiring S\nA : Type uA\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\ns : A → A → Prop\nx y : A\nw : s x y\n⊢ Eq ((RingQuot.mkAlgHom S s) x) ((RingQuot.mkAlgHom S s) y)","decl":"theorem mkAlgHom_rel {s : A → A → Prop} {x y : A} (w : s x y) :\n    mkAlgHom S s x = mkAlgHom S s y := by\n  simp [mkAlgHom_def, mkRingHom_def, Quot.sound (Rel.of w)]\n\n"}
{"name":"RingQuot.mkAlgHom_surjective","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝² : CommSemiring S\nA : Type uA\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\ns : A → A → Prop\n⊢ Function.Surjective ⇑(RingQuot.mkAlgHom S s)","decl":"theorem mkAlgHom_surjective (s : A → A → Prop) : Function.Surjective (mkAlgHom S s) := by\n  suffices Function.Surjective fun x ↦ (⟨.mk (Rel s) x⟩ : RingQuot s) by\n    simpa [mkAlgHom_def, mkRingHom_def]\n  rintro ⟨⟨a⟩⟩\n  use a\n\n"}
{"name":"RingQuot.ringQuot_ext'_iff","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝⁴ : CommSemiring S\nA : Type uA\ninst✝³ : Semiring A\ninst✝² : Algebra S A\nB : Type u₄\ninst✝¹ : Semiring B\ninst✝ : Algebra S B\ns : A → A → Prop\nf g : AlgHom S (RingQuot s) B\n⊢ Iff (Eq f g) (Eq (f.comp (RingQuot.mkAlgHom S s)) (g.comp (RingQuot.mkAlgHom S s)))","decl":"@[ext 1100]\ntheorem ringQuot_ext' {s : A → A → Prop} (f g : RingQuot s →ₐ[S] B)\n    (w : f.comp (mkAlgHom S s) = g.comp (mkAlgHom S s)) : f = g := by\n  ext x\n  rcases mkAlgHom_surjective S s x with ⟨x, rfl⟩\n  exact AlgHom.congr_fun w x\n\n"}
{"name":"RingQuot.ringQuot_ext'","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝⁴ : CommSemiring S\nA : Type uA\ninst✝³ : Semiring A\ninst✝² : Algebra S A\nB : Type u₄\ninst✝¹ : Semiring B\ninst✝ : Algebra S B\ns : A → A → Prop\nf g : AlgHom S (RingQuot s) B\nw : Eq (f.comp (RingQuot.mkAlgHom S s)) (g.comp (RingQuot.mkAlgHom S s))\n⊢ Eq f g","decl":"@[ext 1100]\ntheorem ringQuot_ext' {s : A → A → Prop} (f g : RingQuot s →ₐ[S] B)\n    (w : f.comp (mkAlgHom S s) = g.comp (mkAlgHom S s)) : f = g := by\n  ext x\n  rcases mkAlgHom_surjective S s x with ⟨x, rfl⟩\n  exact AlgHom.congr_fun w x\n\n"}
{"name":"RingQuot.preLiftAlgHom_def","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type u_1\ninst✝⁴ : CommSemiring S\nA : Type u_2\ninst✝³ : Semiring A\ninst✝² : Algebra S A\nB : Type u_3\ninst✝¹ : Semiring B\ninst✝ : Algebra S B\ns : A → A → Prop\nf : AlgHom S A B\nh : ∀ ⦃x y : A⦄, s x y → Eq (f x) (f y)\n⊢ Eq (RingQuot.preLiftAlgHom S h) { toFun := fun x => Quot.lift ⇑f ⋯ x.toQuot, map_one' := ⋯, map_mul' := ⋯, map_zero' := ⋯, map_add' := ⋯, commutes' := ⋯ }","decl":"irreducible_def preLiftAlgHom {s : A → A → Prop} {f : A →ₐ[S] B}\n  (h : ∀ ⦃x y⦄, s x y → f x = f y) : RingQuot s →ₐ[S] B :=\n{ toFun := fun x ↦ Quot.lift f\n            (by\n              rintro _ _ r\n              induction r with\n              | of r => exact h r\n              | add_left _ r' => simp only [map_add, r']\n              | mul_left _ r' => simp only [map_mul, r']\n              | mul_right _ r' => simp only [map_mul, r'])\n            x.toQuot\n  map_zero' := by simp only [← zero_quot, map_zero]\n  map_add' := by\n    rintro ⟨⟨x⟩⟩ ⟨⟨y⟩⟩\n    simp only [add_quot, map_add _ x y]\n  map_one' := by simp only [← one_quot, map_one]\n  map_mul' := by\n    rintro ⟨⟨x⟩⟩ ⟨⟨y⟩⟩\n    simp only [mul_quot, map_mul _ x y]\n  commutes' := by\n    rintro x\n    simp [← one_quot, smul_quot, Algebra.algebraMap_eq_smul_one] }\n\n"}
{"name":"RingQuot.liftAlgHom_def","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type u_1\ninst✝⁴ : CommSemiring S\nA : Type u_2\ninst✝³ : Semiring A\ninst✝² : Algebra S A\nB : Type u_3\ninst✝¹ : Semiring B\ninst✝ : Algebra S B\ns : A → A → Prop\n⊢ Eq (RingQuot.liftAlgHom S) { toFun := fun f' => RingQuot.preLiftAlgHom S ⋯, invFun := fun F => ⟨F.comp (RingQuot.mkAlgHom S s), ⋯⟩, left_inv := ⋯, right_inv := ⋯ }","decl":"/-- Any `S`-algebra homomorphism `f : A →ₐ[S] B` which respects a relation `s : A → A → Prop`\nfactors uniquely through a morphism `RingQuot s →ₐ[S] B`.\n-/\nirreducible_def liftAlgHom {s : A → A → Prop} :\n  { f : A →ₐ[S] B // ∀ ⦃x y⦄, s x y → f x = f y } ≃ (RingQuot s →ₐ[S] B) :=\n  { toFun := fun f' ↦ preLiftAlgHom _ f'.prop\n    invFun := fun F ↦ ⟨F.comp (mkAlgHom S s), fun _ _ h ↦ congr_arg F (mkAlgHom_rel S h)⟩\n    left_inv := fun f ↦ by\n      ext\n      simp only [preLiftAlgHom_def, mkAlgHom_def, mkRingHom_def, RingHom.toMonoidHom_eq_coe,\n                 RingHom.coe_monoidHom_mk, AlgHom.coe_comp, AlgHom.coe_mk, RingHom.coe_mk,\n                 MonoidHom.coe_mk, OneHom.coe_mk, Function.comp_apply]\n    right_inv := fun F ↦ by\n      ext\n      simp only [preLiftAlgHom_def, mkAlgHom_def, mkRingHom_def, RingHom.toMonoidHom_eq_coe,\n                 RingHom.coe_monoidHom_mk, AlgHom.coe_comp, AlgHom.coe_mk, RingHom.coe_mk,\n                 MonoidHom.coe_mk, OneHom.coe_mk, Function.comp_apply] }\n\n"}
{"name":"RingQuot.liftAlgHom_mkAlgHom_apply","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝⁴ : CommSemiring S\nA : Type uA\ninst✝³ : Semiring A\ninst✝² : Algebra S A\nB : Type u₄\ninst✝¹ : Semiring B\ninst✝ : Algebra S B\nf : AlgHom S A B\ns : A → A → Prop\nw : ∀ ⦃x y : A⦄, s x y → Eq (f x) (f y)\nx : A\n⊢ Eq (((RingQuot.liftAlgHom S) ⟨f, w⟩) ((RingQuot.mkAlgHom S s) x)) (f x)","decl":"@[simp]\ntheorem liftAlgHom_mkAlgHom_apply (f : A →ₐ[S] B) {s : A → A → Prop}\n    (w : ∀ ⦃x y⦄, s x y → f x = f y) (x) : (liftAlgHom S ⟨f, w⟩) ((mkAlgHom S s) x) = f x := by\n  simp_rw [liftAlgHom_def, preLiftAlgHom_def, mkAlgHom_def, mkRingHom_def]\n  rfl\n\n-- note this is essentially `(liftAlgHom S).symm_apply_eq.mp h`\n"}
{"name":"RingQuot.liftAlgHom_unique","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝⁴ : CommSemiring S\nA : Type uA\ninst✝³ : Semiring A\ninst✝² : Algebra S A\nB : Type u₄\ninst✝¹ : Semiring B\ninst✝ : Algebra S B\nf : AlgHom S A B\ns : A → A → Prop\nw : ∀ ⦃x y : A⦄, s x y → Eq (f x) (f y)\ng : AlgHom S (RingQuot s) B\nh : Eq (g.comp (RingQuot.mkAlgHom S s)) f\n⊢ Eq g ((RingQuot.liftAlgHom S) ⟨f, w⟩)","decl":"theorem liftAlgHom_unique (f : A →ₐ[S] B) {s : A → A → Prop} (w : ∀ ⦃x y⦄, s x y → f x = f y)\n    (g : RingQuot s →ₐ[S] B) (h : g.comp (mkAlgHom S s) = f) : g = liftAlgHom S ⟨f, w⟩ := by\n  ext\n  simp [h]\n\n"}
{"name":"RingQuot.eq_liftAlgHom_comp_mkAlgHom","module":"Mathlib.Algebra.RingQuot","initialProofState":"S : Type uS\ninst✝⁴ : CommSemiring S\nA : Type uA\ninst✝³ : Semiring A\ninst✝² : Algebra S A\nB : Type u₄\ninst✝¹ : Semiring B\ninst✝ : Algebra S B\ns : A → A → Prop\nf : AlgHom S (RingQuot s) B\n⊢ Eq f ((RingQuot.liftAlgHom S) ⟨f.comp (RingQuot.mkAlgHom S s), ⋯⟩)","decl":"theorem eq_liftAlgHom_comp_mkAlgHom {s : A → A → Prop} (f : RingQuot s →ₐ[S] B) :\n    f = liftAlgHom S ⟨f.comp (mkAlgHom S s), fun _ _ h ↦ congr_arg f (mkAlgHom_rel S h)⟩ := by\n  conv_lhs => rw [← (liftAlgHom S).apply_symm_apply f]\n  rw [liftAlgHom]\n  rfl\n\n"}
