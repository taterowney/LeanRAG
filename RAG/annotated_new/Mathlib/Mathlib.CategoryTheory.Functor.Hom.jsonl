{"name":"CategoryTheory.Functor.hom_obj","module":"Mathlib.CategoryTheory.Functor.Hom","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\np : Prod (Opposite C) C\n⊢ Eq ((CategoryTheory.Functor.hom C).obj p) (Quiver.Hom (Opposite.unop p.1) p.2)","decl":"/-- `Functor.hom` is the hom-pairing, sending `(X, Y)` to `X ⟶ Y`, contravariant in `X` and\ncovariant in `Y`. -/\n@[simps]\ndef hom : Cᵒᵖ × C ⥤ Type v where\n  obj p := unop p.1 ⟶ p.2\n  map f h := f.1.unop ≫ h ≫ f.2\n\n"}
{"name":"CategoryTheory.Functor.hom_map","module":"Mathlib.CategoryTheory.Functor.Hom","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : Prod (Opposite C) C\nf : Quiver.Hom X✝ Y✝\nh : Quiver.Hom (Opposite.unop X✝.1) X✝.2\n⊢ Eq ((CategoryTheory.Functor.hom C).map f h) (CategoryTheory.CategoryStruct.comp f.1.unop (CategoryTheory.CategoryStruct.comp h f.2))","decl":"/-- `Functor.hom` is the hom-pairing, sending `(X, Y)` to `X ⟶ Y`, contravariant in `X` and\ncovariant in `Y`. -/\n@[simps]\ndef hom : Cᵒᵖ × C ⥤ Type v where\n  obj p := unop p.1 ⟶ p.2\n  map f h := f.1.unop ≫ h ≫ f.2\n\n"}
