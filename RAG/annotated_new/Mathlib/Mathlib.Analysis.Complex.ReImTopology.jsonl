{"name":"Complex.isHomeomorphicTrivialFiberBundle_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"⊢ IsHomeomorphicTrivialFiberBundle Real Complex.re","decl":"/-- `Complex.re` turns `ℂ` into a trivial topological fiber bundle over `ℝ`. -/\ntheorem isHomeomorphicTrivialFiberBundle_re : IsHomeomorphicTrivialFiberBundle ℝ re :=\n  ⟨equivRealProdCLM.toHomeomorph, fun _ => rfl⟩\n\n"}
{"name":"Complex.isHomeomorphicTrivialFiberBundle_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"⊢ IsHomeomorphicTrivialFiberBundle Real Complex.im","decl":"/-- `Complex.im` turns `ℂ` into a trivial topological fiber bundle over `ℝ`. -/\ntheorem isHomeomorphicTrivialFiberBundle_im : IsHomeomorphicTrivialFiberBundle ℝ im :=\n  ⟨equivRealProdCLM.toHomeomorph.trans (Homeomorph.prodComm ℝ ℝ), fun _ => rfl⟩\n\n"}
{"name":"Complex.isOpenMap_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"⊢ IsOpenMap Complex.re","decl":"theorem isOpenMap_re : IsOpenMap re :=\n  isHomeomorphicTrivialFiberBundle_re.isOpenMap_proj\n\n"}
{"name":"Complex.isOpenMap_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"⊢ IsOpenMap Complex.im","decl":"theorem isOpenMap_im : IsOpenMap im :=\n  isHomeomorphicTrivialFiberBundle_im.isOpenMap_proj\n\n"}
{"name":"Complex.isQuotientMap_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"⊢ Topology.IsQuotientMap Complex.re","decl":"theorem isQuotientMap_re : IsQuotientMap re :=\n  isHomeomorphicTrivialFiberBundle_re.isQuotientMap_proj\n\n"}
{"name":"Complex.quotientMap_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"⊢ Topology.IsQuotientMap Complex.re","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_re := isQuotientMap_re\n\n"}
{"name":"Complex.isQuotientMap_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"⊢ Topology.IsQuotientMap Complex.im","decl":"theorem isQuotientMap_im : IsQuotientMap im :=\n  isHomeomorphicTrivialFiberBundle_im.isQuotientMap_proj\n\n"}
{"name":"Complex.quotientMap_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"⊢ Topology.IsQuotientMap Complex.im","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_im := isQuotientMap_im\n\n"}
{"name":"Complex.interior_preimage_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s : Set Real\n⊢ Eq (interior (Set.preimage Complex.re s)) (Set.preimage Complex.re (interior s))","decl":"theorem interior_preimage_re (s : Set ℝ) : interior (re ⁻¹' s) = re ⁻¹' interior s :=\n  (isOpenMap_re.preimage_interior_eq_interior_preimage continuous_re _).symm\n\n"}
{"name":"Complex.interior_preimage_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s : Set Real\n⊢ Eq (interior (Set.preimage Complex.im s)) (Set.preimage Complex.im (interior s))","decl":"theorem interior_preimage_im (s : Set ℝ) : interior (im ⁻¹' s) = im ⁻¹' interior s :=\n  (isOpenMap_im.preimage_interior_eq_interior_preimage continuous_im _).symm\n\n"}
{"name":"Complex.closure_preimage_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s : Set Real\n⊢ Eq (closure (Set.preimage Complex.re s)) (Set.preimage Complex.re (closure s))","decl":"theorem closure_preimage_re (s : Set ℝ) : closure (re ⁻¹' s) = re ⁻¹' closure s :=\n  (isOpenMap_re.preimage_closure_eq_closure_preimage continuous_re _).symm\n\n"}
{"name":"Complex.closure_preimage_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s : Set Real\n⊢ Eq (closure (Set.preimage Complex.im s)) (Set.preimage Complex.im (closure s))","decl":"theorem closure_preimage_im (s : Set ℝ) : closure (im ⁻¹' s) = im ⁻¹' closure s :=\n  (isOpenMap_im.preimage_closure_eq_closure_preimage continuous_im _).symm\n\n"}
{"name":"Complex.frontier_preimage_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s : Set Real\n⊢ Eq (frontier (Set.preimage Complex.re s)) (Set.preimage Complex.re (frontier s))","decl":"theorem frontier_preimage_re (s : Set ℝ) : frontier (re ⁻¹' s) = re ⁻¹' frontier s :=\n  (isOpenMap_re.preimage_frontier_eq_frontier_preimage continuous_re _).symm\n\n"}
{"name":"Complex.frontier_preimage_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s : Set Real\n⊢ Eq (frontier (Set.preimage Complex.im s)) (Set.preimage Complex.im (frontier s))","decl":"theorem frontier_preimage_im (s : Set ℝ) : frontier (im ⁻¹' s) = im ⁻¹' frontier s :=\n  (isOpenMap_im.preimage_frontier_eq_frontier_preimage continuous_im _).symm\n\n"}
{"name":"Complex.interior_setOf_re_le","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (interior (setOf fun z => LE.le z.re a)) (setOf fun z => LT.lt z.re a)","decl":"@[simp]\ntheorem interior_setOf_re_le (a : ℝ) : interior { z : ℂ | z.re ≤ a } = { z | z.re < a } := by\n  simpa only [interior_Iic] using interior_preimage_re (Iic a)\n\n"}
{"name":"Complex.interior_setOf_im_le","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (interior (setOf fun z => LE.le z.im a)) (setOf fun z => LT.lt z.im a)","decl":"@[simp]\ntheorem interior_setOf_im_le (a : ℝ) : interior { z : ℂ | z.im ≤ a } = { z | z.im < a } := by\n  simpa only [interior_Iic] using interior_preimage_im (Iic a)\n\n"}
{"name":"Complex.interior_setOf_le_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (interior (setOf fun z => LE.le a z.re)) (setOf fun z => LT.lt a z.re)","decl":"@[simp]\ntheorem interior_setOf_le_re (a : ℝ) : interior { z : ℂ | a ≤ z.re } = { z | a < z.re } := by\n  simpa only [interior_Ici] using interior_preimage_re (Ici a)\n\n"}
{"name":"Complex.interior_setOf_le_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (interior (setOf fun z => LE.le a z.im)) (setOf fun z => LT.lt a z.im)","decl":"@[simp]\ntheorem interior_setOf_le_im (a : ℝ) : interior { z : ℂ | a ≤ z.im } = { z | a < z.im } := by\n  simpa only [interior_Ici] using interior_preimage_im (Ici a)\n\n"}
{"name":"Complex.closure_setOf_re_lt","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (closure (setOf fun z => LT.lt z.re a)) (setOf fun z => LE.le z.re a)","decl":"@[simp]\ntheorem closure_setOf_re_lt (a : ℝ) : closure { z : ℂ | z.re < a } = { z | z.re ≤ a } := by\n  simpa only [closure_Iio] using closure_preimage_re (Iio a)\n\n"}
{"name":"Complex.closure_setOf_im_lt","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (closure (setOf fun z => LT.lt z.im a)) (setOf fun z => LE.le z.im a)","decl":"@[simp]\ntheorem closure_setOf_im_lt (a : ℝ) : closure { z : ℂ | z.im < a } = { z | z.im ≤ a } := by\n  simpa only [closure_Iio] using closure_preimage_im (Iio a)\n\n"}
{"name":"Complex.closure_setOf_lt_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (closure (setOf fun z => LT.lt a z.re)) (setOf fun z => LE.le a z.re)","decl":"@[simp]\ntheorem closure_setOf_lt_re (a : ℝ) : closure { z : ℂ | a < z.re } = { z | a ≤ z.re } := by\n  simpa only [closure_Ioi] using closure_preimage_re (Ioi a)\n\n"}
{"name":"Complex.closure_setOf_lt_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (closure (setOf fun z => LT.lt a z.im)) (setOf fun z => LE.le a z.im)","decl":"@[simp]\ntheorem closure_setOf_lt_im (a : ℝ) : closure { z : ℂ | a < z.im } = { z | a ≤ z.im } := by\n  simpa only [closure_Ioi] using closure_preimage_im (Ioi a)\n\n"}
{"name":"Complex.frontier_setOf_re_le","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (frontier (setOf fun z => LE.le z.re a)) (setOf fun z => Eq z.re a)","decl":"@[simp]\ntheorem frontier_setOf_re_le (a : ℝ) : frontier { z : ℂ | z.re ≤ a } = { z | z.re = a } := by\n  simpa only [frontier_Iic] using frontier_preimage_re (Iic a)\n\n"}
{"name":"Complex.frontier_setOf_im_le","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (frontier (setOf fun z => LE.le z.im a)) (setOf fun z => Eq z.im a)","decl":"@[simp]\ntheorem frontier_setOf_im_le (a : ℝ) : frontier { z : ℂ | z.im ≤ a } = { z | z.im = a } := by\n  simpa only [frontier_Iic] using frontier_preimage_im (Iic a)\n\n"}
{"name":"Complex.frontier_setOf_le_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (frontier (setOf fun z => LE.le a z.re)) (setOf fun z => Eq z.re a)","decl":"@[simp]\ntheorem frontier_setOf_le_re (a : ℝ) : frontier { z : ℂ | a ≤ z.re } = { z | z.re = a } := by\n  simpa only [frontier_Ici] using frontier_preimage_re (Ici a)\n\n"}
{"name":"Complex.frontier_setOf_le_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (frontier (setOf fun z => LE.le a z.im)) (setOf fun z => Eq z.im a)","decl":"@[simp]\ntheorem frontier_setOf_le_im (a : ℝ) : frontier { z : ℂ | a ≤ z.im } = { z | z.im = a } := by\n  simpa only [frontier_Ici] using frontier_preimage_im (Ici a)\n\n"}
{"name":"Complex.frontier_setOf_re_lt","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (frontier (setOf fun z => LT.lt z.re a)) (setOf fun z => Eq z.re a)","decl":"@[simp]\ntheorem frontier_setOf_re_lt (a : ℝ) : frontier { z : ℂ | z.re < a } = { z | z.re = a } := by\n  simpa only [frontier_Iio] using frontier_preimage_re (Iio a)\n\n"}
{"name":"Complex.frontier_setOf_im_lt","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (frontier (setOf fun z => LT.lt z.im a)) (setOf fun z => Eq z.im a)","decl":"@[simp]\ntheorem frontier_setOf_im_lt (a : ℝ) : frontier { z : ℂ | z.im < a } = { z | z.im = a } := by\n  simpa only [frontier_Iio] using frontier_preimage_im (Iio a)\n\n"}
{"name":"Complex.frontier_setOf_lt_re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (frontier (setOf fun z => LT.lt a z.re)) (setOf fun z => Eq z.re a)","decl":"@[simp]\ntheorem frontier_setOf_lt_re (a : ℝ) : frontier { z : ℂ | a < z.re } = { z | z.re = a } := by\n  simpa only [frontier_Ioi] using frontier_preimage_re (Ioi a)\n\n"}
{"name":"Complex.frontier_setOf_lt_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a : Real\n⊢ Eq (frontier (setOf fun z => LT.lt a z.im)) (setOf fun z => Eq z.im a)","decl":"@[simp]\ntheorem frontier_setOf_lt_im (a : ℝ) : frontier { z : ℂ | a < z.im } = { z | z.im = a } := by\n  simpa only [frontier_Ioi] using frontier_preimage_im (Ioi a)\n\n"}
{"name":"Complex.closure_reProdIm","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s t : Set Real\n⊢ Eq (closure (Complex.reProdIm s t)) (Complex.reProdIm (closure s) (closure t))","decl":"theorem closure_reProdIm (s t : Set ℝ) : closure (s ×ℂ t) = closure s ×ℂ closure t := by\n  simpa only [← preimage_eq_preimage equivRealProdCLM.symm.toHomeomorph.surjective,\n    equivRealProdCLM.symm.toHomeomorph.preimage_closure] using @closure_prod_eq _ _ _ _ s t\n\n"}
{"name":"Complex.interior_reProdIm","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s t : Set Real\n⊢ Eq (interior (Complex.reProdIm s t)) (Complex.reProdIm (interior s) (interior t))","decl":"theorem interior_reProdIm (s t : Set ℝ) : interior (s ×ℂ t) = interior s ×ℂ interior t := by\n  rw [reProdIm, reProdIm, interior_inter, interior_preimage_re, interior_preimage_im]\n\n"}
{"name":"Complex.frontier_reProdIm","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s t : Set Real\n⊢ Eq (frontier (Complex.reProdIm s t)) (Union.union (Complex.reProdIm (closure s) (frontier t)) (Complex.reProdIm (frontier s) (closure t)))","decl":"theorem frontier_reProdIm (s t : Set ℝ) :\n    frontier (s ×ℂ t) = closure s ×ℂ frontier t ∪ frontier s ×ℂ closure t := by\n  simpa only [← preimage_eq_preimage equivRealProdCLM.symm.toHomeomorph.surjective,\n    equivRealProdCLM.symm.toHomeomorph.preimage_frontier] using frontier_prod_eq s t\n\n"}
{"name":"Complex.frontier_setOf_le_re_and_le_im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a b : Real\n⊢ Eq (frontier (setOf fun z => And (LE.le a z.re) (LE.le b z.im))) (setOf fun z => Or (And (LE.le a z.re) (Eq z.im b)) (And (Eq z.re a) (LE.le b z.im)))","decl":"theorem frontier_setOf_le_re_and_le_im (a b : ℝ) :\n    frontier { z | a ≤ re z ∧ b ≤ im z } = { z | a ≤ re z ∧ im z = b ∨ re z = a ∧ b ≤ im z } := by\n  simpa only [closure_Ici, frontier_Ici] using frontier_reProdIm (Ici a) (Ici b)\n\n"}
{"name":"Complex.frontier_setOf_le_re_and_im_le","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"a b : Real\n⊢ Eq (frontier (setOf fun z => And (LE.le a z.re) (LE.le z.im b))) (setOf fun z => Or (And (LE.le a z.re) (Eq z.im b)) (And (Eq z.re a) (LE.le z.im b)))","decl":"theorem frontier_setOf_le_re_and_im_le (a b : ℝ) :\n    frontier { z | a ≤ re z ∧ im z ≤ b } = { z | a ≤ re z ∧ im z = b ∨ re z = a ∧ im z ≤ b } := by\n  simpa only [closure_Ici, closure_Iic, frontier_Ici, frontier_Iic] using\n    frontier_reProdIm (Ici a) (Iic b)\n\n"}
{"name":"IsOpen.reProdIm","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s t : Set Real\nhs : IsOpen s\nht : IsOpen t\n⊢ IsOpen (Complex.reProdIm s t)","decl":"theorem IsOpen.reProdIm (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s ×ℂ t) :=\n  (hs.preimage continuous_re).inter (ht.preimage continuous_im)\n\n"}
{"name":"IsClosed.reProdIm","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s t : Set Real\nhs : IsClosed s\nht : IsClosed t\n⊢ IsClosed (Complex.reProdIm s t)","decl":"theorem IsClosed.reProdIm (hs : IsClosed s) (ht : IsClosed t) : IsClosed (s ×ℂ t) :=\n  (hs.preimage continuous_re).inter (ht.preimage continuous_im)\n\n"}
{"name":"Bornology.IsBounded.reProdIm","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"s t : Set Real\nhs : Bornology.IsBounded s\nht : Bornology.IsBounded t\n⊢ Bornology.IsBounded (Complex.reProdIm s t)","decl":"theorem Bornology.IsBounded.reProdIm (hs : IsBounded s) (ht : IsBounded t) : IsBounded (s ×ℂ t) :=\n  antilipschitz_equivRealProd.isBounded_preimage (hs.prod ht)\n\n"}
{"name":"TendstoUniformlyOn.re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → α → Complex\np : Filter ι\ng : α → Complex\nK : Set α\nhf : TendstoUniformlyOn f g p K\n⊢ TendstoUniformlyOn (fun n x => (f n x).re) (fun y => (g y).re) p K","decl":"protected lemma TendstoUniformlyOn.re {f : ι → α → ℂ} {p : Filter ι} {g : α → ℂ} {K : Set α}\n    (hf : TendstoUniformlyOn f g p K) :\n    TendstoUniformlyOn (fun n x => (f n x).re) (fun y => (g y).re) p K := by\n  apply UniformContinuous.comp_tendstoUniformlyOn uniformlyContinuous_re hf\n\n"}
{"name":"TendstoUniformly.re","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → α → Complex\np : Filter ι\ng : α → Complex\nhf : TendstoUniformly f g p\n⊢ TendstoUniformly (fun n x => (f n x).re) (fun y => (g y).re) p","decl":"protected lemma TendstoUniformly.re {f : ι → α → ℂ} {p : Filter ι} {g : α → ℂ}\n    (hf : TendstoUniformly f g p) :\n    TendstoUniformly (fun n x => (f n x).re) (fun y => (g y).re) p := by\n  apply UniformContinuous.comp_tendstoUniformly uniformlyContinuous_re hf\n\n"}
{"name":"TendstoUniformlyOn.im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → α → Complex\np : Filter ι\ng : α → Complex\nK : Set α\nhf : TendstoUniformlyOn f g p K\n⊢ TendstoUniformlyOn (fun n x => (f n x).im) (fun y => (g y).im) p K","decl":"protected lemma TendstoUniformlyOn.im {f : ι → α → ℂ} {p : Filter ι} {g : α → ℂ} {K : Set α}\n    (hf : TendstoUniformlyOn f g p K) :\n    TendstoUniformlyOn (fun n x => (f n x).im) (fun y => (g y).im) p K := by\n  apply UniformContinuous.comp_tendstoUniformlyOn uniformlyContinuous_im hf\n\n"}
{"name":"TendstoUniformly.im","module":"Mathlib.Analysis.Complex.ReImTopology","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → α → Complex\np : Filter ι\ng : α → Complex\nhf : TendstoUniformly f g p\n⊢ TendstoUniformly (fun n x => (f n x).im) (fun y => (g y).im) p","decl":"protected lemma TendstoUniformly.im {f : ι → α → ℂ} {p : Filter ι} {g : α → ℂ}\n    (hf : TendstoUniformly f g p) :\n    TendstoUniformly (fun n x => (f n x).im) (fun y => (g y).im) p := by\n  apply UniformContinuous.comp_tendstoUniformly uniformlyContinuous_im hf\n\n"}
