{"name":"OrderedSMul.lt_of_smul_lt_smul_of_pos","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœÂ² : OrderedSemiring R\ninstâœÂ¹ : OrderedAddCommMonoid M\ninstâœ : SMulWithZero R M\nself : OrderedSMul R M\na b : M\nc : R\naâœÂ¹ : LT.lt (HSMul.hSMul c a) (HSMul.hSMul c b)\naâœ : LT.lt 0 c\nâŠ¢ LT.lt a b","decl":"/-- The ordered scalar product property is when an ordered additive commutative monoid\nwith a partial order has a scalar multiplication which is compatible with the order. Note that this\nis different from `IsOrderedSMul`, which uses `â‰¤`, has no semiring assumption, and has no positivity\nconstraint on the defining conditions.\n-/\nclass OrderedSMul (R M : Type*) [OrderedSemiring R] [OrderedAddCommMonoid M] [SMulWithZero R M] :\n  Prop where\n  /-- Scalar multiplication by positive elements preserves the order. -/\n  protected smul_lt_smul_of_pos : âˆ€ {a b : M}, âˆ€ {c : R}, a < b â†’ 0 < c â†’ c â€¢ a < c â€¢ b\n  /-- If `c â€¢ a < c â€¢ b` for some positive `c`, then `a < b`. -/\n  protected lt_of_smul_lt_smul_of_pos : âˆ€ {a b : M}, âˆ€ {c : R}, c â€¢ a < c â€¢ b â†’ 0 < c â†’ a < b\n\n"}
{"name":"OrderedSMul.smul_lt_smul_of_pos","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"R : Type u_1\nM : Type u_2\ninstâœÂ² : OrderedSemiring R\ninstâœÂ¹ : OrderedAddCommMonoid M\ninstâœ : SMulWithZero R M\nself : OrderedSMul R M\na b : M\nc : R\naâœÂ¹ : LT.lt a b\naâœ : LT.lt 0 c\nâŠ¢ LT.lt (HSMul.hSMul c a) (HSMul.hSMul c b)","decl":"/-- The ordered scalar product property is when an ordered additive commutative monoid\nwith a partial order has a scalar multiplication which is compatible with the order. Note that this\nis different from `IsOrderedSMul`, which uses `â‰¤`, has no semiring assumption, and has no positivity\nconstraint on the defining conditions.\n-/\nclass OrderedSMul (R M : Type*) [OrderedSemiring R] [OrderedAddCommMonoid M] [SMulWithZero R M] :\n  Prop where\n  /-- Scalar multiplication by positive elements preserves the order. -/\n  protected smul_lt_smul_of_pos : âˆ€ {a b : M}, âˆ€ {c : R}, a < b â†’ 0 < c â†’ c â€¢ a < c â€¢ b\n  /-- If `c â€¢ a < c â€¢ b` for some positive `c`, then `a < b`. -/\n  protected lt_of_smul_lt_smul_of_pos : âˆ€ {a b : M}, âˆ€ {c : R}, c â€¢ a < c â€¢ b â†’ 0 < c â†’ a < b\n\n"}
{"name":"OrderedSMul.toPosSMulStrictMono","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"R : Type u_3\nM : Type u_4\ninstâœÂ³ : OrderedSemiring R\ninstâœÂ² : OrderedAddCommMonoid M\ninstâœÂ¹ : SMulWithZero R M\ninstâœ : OrderedSMul R M\nâŠ¢ PosSMulStrictMono R M","decl":"instance OrderedSMul.toPosSMulStrictMono : PosSMulStrictMono R M where\n  elim _a ha _bâ‚ _bâ‚‚ hb := OrderedSMul.smul_lt_smul_of_pos hb ha\n\n"}
{"name":"OrderedSMul.toPosSMulReflectLT","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"R : Type u_3\nM : Type u_4\ninstâœÂ³ : OrderedSemiring R\ninstâœÂ² : OrderedAddCommMonoid M\ninstâœÂ¹ : SMulWithZero R M\ninstâœ : OrderedSMul R M\nâŠ¢ PosSMulReflectLT R M","decl":"instance OrderedSMul.toPosSMulReflectLT : PosSMulReflectLT R M :=\n  PosSMulReflectLT.of_pos fun _a ha _bâ‚ _bâ‚‚ h â†¦ OrderedSMul.lt_of_smul_lt_smul_of_pos h ha\n\n"}
{"name":"OrderDual.instOrderedSMul","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"R : Type u_3\nM : Type u_4\ninstâœÂ³ : OrderedSemiring R\ninstâœÂ² : OrderedAddCommMonoid M\ninstâœÂ¹ : SMulWithZero R M\ninstâœ : OrderedSMul R M\nâŠ¢ OrderedSMul R (OrderDual M)","decl":"instance OrderDual.instOrderedSMul : OrderedSMul R Máµ’áµˆ where\n  smul_lt_smul_of_pos := OrderedSMul.smul_lt_smul_of_pos (M := M)\n  lt_of_smul_lt_smul_of_pos := OrderedSMul.lt_of_smul_lt_smul_of_pos (M := M)\n\n"}
{"name":"OrderedSMul.mk''","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"ğ•œ : Type u_2\nM : Type u_4\ninstâœÂ² : OrderedSemiring ğ•œ\ninstâœÂ¹ : LinearOrderedAddCommMonoid M\ninstâœ : SMulWithZero ğ•œ M\nh : âˆ€ â¦ƒc : ğ•œâ¦„, LT.lt 0 c â†’ StrictMono fun a => HSMul.hSMul c a\nâŠ¢ OrderedSMul ğ•œ M","decl":"/-- To prove that a linear ordered monoid is an ordered module, it suffices to verify only the first\naxiom of `OrderedSMul`. -/\ntheorem OrderedSMul.mk'' [OrderedSemiring ğ•œ] [LinearOrderedAddCommMonoid M] [SMulWithZero ğ•œ M]\n    (h : âˆ€ â¦ƒc : ğ•œâ¦„, 0 < c â†’ StrictMono fun a : M => c â€¢ a) : OrderedSMul ğ•œ M :=\n  { smul_lt_smul_of_pos := fun hab hc => h hc hab\n    lt_of_smul_lt_smul_of_pos := fun hab hc => (h hc).lt_iff_lt.1 hab }\n\n"}
{"name":"Nat.orderedSMul","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"M : Type u_4\ninstâœ : LinearOrderedCancelAddCommMonoid M\nâŠ¢ OrderedSMul Nat M","decl":"instance Nat.orderedSMul [LinearOrderedCancelAddCommMonoid M] : OrderedSMul â„• M :=\n  OrderedSMul.mk'' fun n hn a b hab => by\n    cases n with\n    | zero => cases hn\n    | succ n =>\n      induction n with\n      | zero => dsimp; rwa [one_nsmul, one_nsmul]\n      | succ n ih => simp only [succ_nsmul _ n.succ, _root_.add_lt_add (ih n.succ_pos) hab]\n\n"}
{"name":"Int.orderedSMul","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"M : Type u_4\ninstâœ : LinearOrderedAddCommGroup M\nâŠ¢ OrderedSMul Int M","decl":"instance Int.orderedSMul [LinearOrderedAddCommGroup M] : OrderedSMul â„¤ M :=\n  OrderedSMul.mk'' fun n hn => by\n    cases n\n    Â· simp only [Int.ofNat_eq_coe, Int.natCast_pos, natCast_zsmul] at hn âŠ¢\n      exact strictMono_smul_left_of_pos hn\n    Â· cases (Int.negSucc_not_pos _).1 hn\n\n"}
{"name":"LinearOrderedSemiring.toOrderedSMul","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"R : Type u_3\ninstâœ : LinearOrderedSemiring R\nâŠ¢ OrderedSMul R R","decl":"instance LinearOrderedSemiring.toOrderedSMul : OrderedSMul R R :=\n  OrderedSMul.mk'' fun _ => strictMono_mul_left_of_pos\n\n"}
{"name":"OrderedSMul.mk'","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"ğ•œ : Type u_2\nM : Type u_4\ninstâœÂ² : LinearOrderedSemifield ğ•œ\ninstâœÂ¹ : OrderedAddCommMonoid M\ninstâœ : MulActionWithZero ğ•œ M\nh : âˆ€ â¦ƒa b : Mâ¦„ â¦ƒc : ğ•œâ¦„, LT.lt a b â†’ LT.lt 0 c â†’ LE.le (HSMul.hSMul c a) (HSMul.hSMul c b)\nâŠ¢ OrderedSMul ğ•œ M","decl":"/-- To prove that a vector space over a linear ordered field is ordered, it suffices to verify only\nthe first axiom of `OrderedSMul`. -/\ntheorem OrderedSMul.mk' (h : âˆ€ â¦ƒa b : Mâ¦„ â¦ƒc : ğ•œâ¦„, a < b â†’ 0 < c â†’ c â€¢ a â‰¤ c â€¢ b) :\n    OrderedSMul ğ•œ M := by\n  have hlt' : âˆ€ (a b : M) (c : ğ•œ), a < b â†’ 0 < c â†’ c â€¢ a < c â€¢ b := by\n    refine fun a b c hab hc => (h hab hc).lt_of_ne ?_\n    rw [Ne, hc.ne'.isUnit.smul_left_cancel]\n    exact hab.ne\n  refine âŸ¨fun {a b c} => hlt' a b c, fun {a b c hab hc} => ?_âŸ©\n  obtain âŸ¨c, rflâŸ© := hc.ne'.isUnit\n  rw [â† inv_smul_smul c a, â† inv_smul_smul c b]\n  refine hlt' _ _ _ hab (pos_of_mul_pos_right ?_ hc.le)\n  simp only [c.mul_inv, zero_lt_one]\n\n"}
{"name":"instOrderedSMulProd","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"ğ•œ : Type u_2\nM : Type u_4\nN : Type u_5\ninstâœâ¶ : LinearOrderedSemifield ğ•œ\ninstâœâµ : OrderedAddCommMonoid M\ninstâœâ´ : OrderedAddCommMonoid N\ninstâœÂ³ : MulActionWithZero ğ•œ M\ninstâœÂ² : MulActionWithZero ğ•œ N\ninstâœÂ¹ : OrderedSMul ğ•œ M\ninstâœ : OrderedSMul ğ•œ N\nâŠ¢ OrderedSMul ğ•œ (Prod M N)","decl":"instance [OrderedSMul ğ•œ M] [OrderedSMul ğ•œ N] : OrderedSMul ğ•œ (M Ã— N) :=\n  OrderedSMul.mk' fun _ _ _ h hc =>\n    âŸ¨smul_le_smul_of_nonneg_left h.1.1 hc.le, smul_le_smul_of_nonneg_left h.1.2 hc.leâŸ©\n\n"}
{"name":"Pi.orderedSMul","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\ninstâœÂ³ : LinearOrderedSemifield ğ•œ\nM : Î¹ â†’ Type u_6\ninstâœÂ² : (i : Î¹) â†’ OrderedAddCommMonoid (M i)\ninstâœÂ¹ : (i : Î¹) â†’ MulActionWithZero ğ•œ (M i)\ninstâœ : âˆ€ (i : Î¹), OrderedSMul ğ•œ (M i)\nâŠ¢ OrderedSMul ğ•œ ((i : Î¹) â†’ M i)","decl":"instance Pi.orderedSMul {M : Î¹ â†’ Type*} [âˆ€ i, OrderedAddCommMonoid (M i)]\n    [âˆ€ i, MulActionWithZero ğ•œ (M i)] [âˆ€ i, OrderedSMul ğ•œ (M i)] : OrderedSMul ğ•œ (âˆ€ i, M i) :=\n  OrderedSMul.mk' fun _ _ _ h hc i => smul_le_smul_of_nonneg_left (h.le i) hc.le\n\n"}
{"name":"inf_eq_half_smul_add_sub_abs_sub","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"Î± : Type u_6\nÎ² : Type u_7\ninstâœâµ : Semiring Î±\ninstâœâ´ : Invertible 2\ninstâœÂ³ : Lattice Î²\ninstâœÂ² : AddCommGroup Î²\ninstâœÂ¹ : Module Î± Î²\ninstâœ : AddLeftMono Î²\nx y : Î²\nâŠ¢ Eq (Min.min x y) (HSMul.hSMul (Invertible.invOf 2) (HSub.hSub (HAdd.hAdd x y) (abs (HSub.hSub y x))))","decl":"lemma inf_eq_half_smul_add_sub_abs_sub (x y : Î²) : x âŠ“ y = (â…Ÿ2 : Î±) â€¢ (x + y - |y - x|) := by\n  rw [â† two_nsmul_inf_eq_add_sub_abs_sub x y, two_smul, â† two_smul Î±,\n    smul_smul, invOf_mul_self, one_smul]\n\n"}
{"name":"sup_eq_half_smul_add_add_abs_sub","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"Î± : Type u_6\nÎ² : Type u_7\ninstâœâµ : Semiring Î±\ninstâœâ´ : Invertible 2\ninstâœÂ³ : Lattice Î²\ninstâœÂ² : AddCommGroup Î²\ninstâœÂ¹ : Module Î± Î²\ninstâœ : AddLeftMono Î²\nx y : Î²\nâŠ¢ Eq (Max.max x y) (HSMul.hSMul (Invertible.invOf 2) (HAdd.hAdd (HAdd.hAdd x y) (abs (HSub.hSub y x))))","decl":"lemma sup_eq_half_smul_add_add_abs_sub (x y : Î²) : x âŠ” y = (â…Ÿ2 : Î±) â€¢ (x + y + |y - x|) := by\n  rw [â† two_nsmul_sup_eq_add_add_abs_sub x y, two_smul, â† two_smul Î±,\n    smul_smul, invOf_mul_self, one_smul]\n\n"}
{"name":"inf_eq_half_smul_add_sub_abs_sub'","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"Î± : Type u_6\nÎ² : Type u_7\ninstâœâµ : DivisionSemiring Î±\ninstâœâ´ : NeZero 2\ninstâœÂ³ : Lattice Î²\ninstâœÂ² : AddCommGroup Î²\ninstâœÂ¹ : Module Î± Î²\ninstâœ : AddLeftMono Î²\nx y : Î²\nâŠ¢ Eq (Min.min x y) (HSMul.hSMul (Inv.inv 2) (HSub.hSub (HAdd.hAdd x y) (abs (HSub.hSub y x))))","decl":"lemma inf_eq_half_smul_add_sub_abs_sub' (x y : Î²) : x âŠ“ y = (2â»Â¹ : Î±) â€¢ (x + y - |y - x|) := by\n  letI := invertibleOfNonzero (two_ne_zero' Î±)\n  exact inf_eq_half_smul_add_sub_abs_sub Î± x y\n\n"}
{"name":"sup_eq_half_smul_add_add_abs_sub'","module":"Mathlib.Algebra.Order.Module.OrderedSMul","initialProofState":"Î± : Type u_6\nÎ² : Type u_7\ninstâœâµ : DivisionSemiring Î±\ninstâœâ´ : NeZero 2\ninstâœÂ³ : Lattice Î²\ninstâœÂ² : AddCommGroup Î²\ninstâœÂ¹ : Module Î± Î²\ninstâœ : AddLeftMono Î²\nx y : Î²\nâŠ¢ Eq (Max.max x y) (HSMul.hSMul (Inv.inv 2) (HAdd.hAdd (HAdd.hAdd x y) (abs (HSub.hSub y x))))","decl":"lemma sup_eq_half_smul_add_add_abs_sub' (x y : Î²) : x âŠ” y = (2â»Â¹ : Î±) â€¢ (x + y + |y - x|) := by\n  letI := invertibleOfNonzero (two_ne_zero' Î±)\n  exact sup_eq_half_smul_add_add_abs_sub Î± x y\n\n"}
