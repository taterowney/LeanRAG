{"name":"IsAddFreimanHom.map_sum_eq_map_sum","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nn : Nat\nA : Set α\nB : Set β\nf : α → β\nself : IsAddFreimanHom n A B f\ns t : Multiset α\nhsA : ∀ ⦃x : α⦄, Membership.mem s x → Membership.mem A x\nhtA : ∀ ⦃x : α⦄, Membership.mem t x → Membership.mem A x\nhs : Eq s.card n\nht : Eq t.card n\nh : Eq s.sum t.sum\n⊢ Eq (Multiset.map f s).sum (Multiset.map f t).sum","decl":"/-- An additive `n`-Freiman homomorphism from a set `A` to a set `B` is a map which preserves sums\nof `n` elements. -/\nstructure IsAddFreimanHom [AddCommMonoid α] [AddCommMonoid β] (n : ℕ) (A : Set α) (B : Set β)\n    (f : α → β) : Prop where\n  mapsTo : MapsTo f A B\n  /-- An additive `n`-Freiman homomorphism preserves sums of `n` elements. -/\n  map_sum_eq_map_sum ⦃s t : Multiset α⦄ (hsA : ∀ ⦃x⦄, x ∈ s → x ∈ A) (htA : ∀ ⦃x⦄, x ∈ t → x ∈ A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) (h : s.sum = t.sum) :\n    (s.map f).sum = (t.map f).sum\n\n"}
{"name":"IsAddFreimanHom.mapsTo","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nn : Nat\nA : Set α\nB : Set β\nf : α → β\nself : IsAddFreimanHom n A B f\n⊢ Set.MapsTo f A B","decl":"/-- An additive `n`-Freiman homomorphism from a set `A` to a set `B` is a map which preserves sums\nof `n` elements. -/\nstructure IsAddFreimanHom [AddCommMonoid α] [AddCommMonoid β] (n : ℕ) (A : Set α) (B : Set β)\n    (f : α → β) : Prop where\n  mapsTo : MapsTo f A B\n  /-- An additive `n`-Freiman homomorphism preserves sums of `n` elements. -/\n  map_sum_eq_map_sum ⦃s t : Multiset α⦄ (hsA : ∀ ⦃x⦄, x ∈ s → x ∈ A) (htA : ∀ ⦃x⦄, x ∈ t → x ∈ A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) (h : s.sum = t.sum) :\n    (s.map f).sum = (t.map f).sum\n\n"}
{"name":"IsMulFreimanHom.map_prod_eq_map_prod","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nn : Nat\nA : Set α\nB : Set β\nf : α → β\nself : IsMulFreimanHom n A B f\ns t : Multiset α\nhsA : ∀ ⦃x : α⦄, Membership.mem s x → Membership.mem A x\nhtA : ∀ ⦃x : α⦄, Membership.mem t x → Membership.mem A x\nhs : Eq s.card n\nht : Eq t.card n\nh : Eq s.prod t.prod\n⊢ Eq (Multiset.map f s).prod (Multiset.map f t).prod","decl":"/-- An `n`-Freiman homomorphism from a set `A` to a set `B` is a map which preserves products of `n`\nelements. -/\n@[to_additive]\nstructure IsMulFreimanHom (n : ℕ) (A : Set α) (B : Set β) (f : α → β) : Prop where\n  mapsTo : MapsTo f A B\n  /-- An `n`-Freiman homomorphism preserves products of `n` elements. -/\n  map_prod_eq_map_prod ⦃s t : Multiset α⦄ (hsA : ∀ ⦃x⦄, x ∈ s → x ∈ A) (htA : ∀ ⦃x⦄, x ∈ t → x ∈ A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) (h : s.prod = t.prod) :\n    (s.map f).prod = (t.map f).prod\n\n"}
{"name":"IsMulFreimanHom.mapsTo","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nn : Nat\nA : Set α\nB : Set β\nf : α → β\nself : IsMulFreimanHom n A B f\n⊢ Set.MapsTo f A B","decl":"/-- An `n`-Freiman homomorphism from a set `A` to a set `B` is a map which preserves products of `n`\nelements. -/\n@[to_additive]\nstructure IsMulFreimanHom (n : ℕ) (A : Set α) (B : Set β) (f : α → β) : Prop where\n  mapsTo : MapsTo f A B\n  /-- An `n`-Freiman homomorphism preserves products of `n` elements. -/\n  map_prod_eq_map_prod ⦃s t : Multiset α⦄ (hsA : ∀ ⦃x⦄, x ∈ s → x ∈ A) (htA : ∀ ⦃x⦄, x ∈ t → x ∈ A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) (h : s.prod = t.prod) :\n    (s.map f).prod = (t.map f).prod\n\n"}
{"name":"IsAddFreimanIso.bijOn","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nn : Nat\nA : Set α\nB : Set β\nf : α → β\nself : IsAddFreimanIso n A B f\n⊢ Set.BijOn f A B","decl":"/-- An additive `n`-Freiman homomorphism from a set `A` to a set `B` is a bijective map which\npreserves sums of `n` elements. -/\nstructure IsAddFreimanIso [AddCommMonoid α] [AddCommMonoid β] (n : ℕ) (A : Set α) (B : Set β)\n    (f : α → β) : Prop where\n  bijOn : BijOn f A B\n  /-- An additive `n`-Freiman homomorphism preserves sums of `n` elements. -/\n  map_sum_eq_map_sum ⦃s t : Multiset α⦄ (hsA : ∀ ⦃x⦄, x ∈ s → x ∈ A) (htA : ∀ ⦃x⦄, x ∈ t → x ∈ A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) :\n    (s.map f).sum = (t.map f).sum ↔ s.sum = t.sum\n\n"}
{"name":"IsAddFreimanIso.map_sum_eq_map_sum","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nn : Nat\nA : Set α\nB : Set β\nf : α → β\nself : IsAddFreimanIso n A B f\ns t : Multiset α\nhsA : ∀ ⦃x : α⦄, Membership.mem s x → Membership.mem A x\nhtA : ∀ ⦃x : α⦄, Membership.mem t x → Membership.mem A x\nhs : Eq s.card n\nht : Eq t.card n\n⊢ Iff (Eq (Multiset.map f s).sum (Multiset.map f t).sum) (Eq s.sum t.sum)","decl":"/-- An additive `n`-Freiman homomorphism from a set `A` to a set `B` is a bijective map which\npreserves sums of `n` elements. -/\nstructure IsAddFreimanIso [AddCommMonoid α] [AddCommMonoid β] (n : ℕ) (A : Set α) (B : Set β)\n    (f : α → β) : Prop where\n  bijOn : BijOn f A B\n  /-- An additive `n`-Freiman homomorphism preserves sums of `n` elements. -/\n  map_sum_eq_map_sum ⦃s t : Multiset α⦄ (hsA : ∀ ⦃x⦄, x ∈ s → x ∈ A) (htA : ∀ ⦃x⦄, x ∈ t → x ∈ A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) :\n    (s.map f).sum = (t.map f).sum ↔ s.sum = t.sum\n\n"}
{"name":"IsMulFreimanIso.map_prod_eq_map_prod","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nn : Nat\nA : Set α\nB : Set β\nf : α → β\nself : IsMulFreimanIso n A B f\ns t : Multiset α\nhsA : ∀ ⦃x : α⦄, Membership.mem s x → Membership.mem A x\nhtA : ∀ ⦃x : α⦄, Membership.mem t x → Membership.mem A x\nhs : Eq s.card n\nht : Eq t.card n\n⊢ Iff (Eq (Multiset.map f s).prod (Multiset.map f t).prod) (Eq s.prod t.prod)","decl":"/-- An `n`-Freiman homomorphism from a set `A` to a set `B` is a map which preserves products of `n`\nelements. -/\n@[to_additive]\nstructure IsMulFreimanIso (n : ℕ) (A : Set α) (B : Set β) (f : α → β) : Prop where\n  bijOn : BijOn f A B\n  /-- An `n`-Freiman homomorphism preserves products of `n` elements. -/\n  map_prod_eq_map_prod ⦃s t : Multiset α⦄ (hsA : ∀ ⦃x⦄, x ∈ s → x ∈ A) (htA : ∀ ⦃x⦄, x ∈ t → x ∈ A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) :\n    (s.map f).prod = (t.map f).prod ↔ s.prod = t.prod\n\n"}
{"name":"IsMulFreimanIso.bijOn","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nn : Nat\nA : Set α\nB : Set β\nf : α → β\nself : IsMulFreimanIso n A B f\n⊢ Set.BijOn f A B","decl":"/-- An `n`-Freiman homomorphism from a set `A` to a set `B` is a map which preserves products of `n`\nelements. -/\n@[to_additive]\nstructure IsMulFreimanIso (n : ℕ) (A : Set α) (B : Set β) (f : α → β) : Prop where\n  bijOn : BijOn f A B\n  /-- An `n`-Freiman homomorphism preserves products of `n` elements. -/\n  map_prod_eq_map_prod ⦃s t : Multiset α⦄ (hsA : ∀ ⦃x⦄, x ∈ s → x ∈ A) (htA : ∀ ⦃x⦄, x ∈ t → x ∈ A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) :\n    (s.map f).prod = (t.map f).prod ↔ s.prod = t.prod\n\n"}
{"name":"IsAddFreimanIso.isAddFreimanHom","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nn : Nat\nhf : IsAddFreimanIso n A B f\n⊢ IsAddFreimanHom n A B f","decl":"@[to_additive]\nlemma IsMulFreimanIso.isMulFreimanHom (hf : IsMulFreimanIso n A B f) : IsMulFreimanHom n A B f where\n  mapsTo := hf.bijOn.mapsTo\n  map_prod_eq_map_prod _s _t hsA htA hs ht := (hf.map_prod_eq_map_prod hsA htA hs ht).2\n\n"}
{"name":"IsMulFreimanIso.isMulFreimanHom","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf : α → β\nn : Nat\nhf : IsMulFreimanIso n A B f\n⊢ IsMulFreimanHom n A B f","decl":"@[to_additive]\nlemma IsMulFreimanIso.isMulFreimanHom (hf : IsMulFreimanIso n A B f) : IsMulFreimanHom n A B f where\n  mapsTo := hf.bijOn.mapsTo\n  map_prod_eq_map_prod _s _t hsA htA hs ht := (hf.map_prod_eq_map_prod hsA htA hs ht).2\n\n"}
{"name":"IsMulFreimanHom.congr","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf₁ f₂ : α → β\nn : Nat\nhf₁ : IsMulFreimanHom n A B f₁\nh : Set.EqOn f₁ f₂ A\n⊢ IsMulFreimanHom n A B f₂","decl":"lemma IsMulFreimanHom.congr (hf₁ : IsMulFreimanHom n A B f₁) (h : EqOn f₁ f₂ A) :\n    IsMulFreimanHom n A B f₂ where\n  mapsTo := hf₁.mapsTo.congr h\n  map_prod_eq_map_prod s t hsA htA hs ht h' := by\n    rw [map_congr rfl fun x hx => (h (hsA hx)).symm, map_congr rfl fun x hx => (h (htA hx)).symm,\n      hf₁.map_prod_eq_map_prod hsA htA hs ht h']\n\n"}
{"name":"IsMulFreimanIso.congr","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf₁ f₂ : α → β\nn : Nat\nhf₁ : IsMulFreimanIso n A B f₁\nh : Set.EqOn f₁ f₂ A\n⊢ IsMulFreimanIso n A B f₂","decl":"lemma IsMulFreimanIso.congr (hf₁ : IsMulFreimanIso n A B f₁) (h : EqOn f₁ f₂ A) :\n    IsMulFreimanIso n A B f₂ where\n  bijOn := hf₁.bijOn.congr h\n  map_prod_eq_map_prod s t hsA htA hs ht := by\n    rw [map_congr rfl fun x hx => h.symm (hsA hx), map_congr rfl fun x hx => h.symm (htA hx),\n      hf₁.map_prod_eq_map_prod hsA htA hs ht]\n\n"}
{"name":"IsMulFreimanHom.mul_eq_mul","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf : α → β\nhf : IsMulFreimanHom 2 A B f\na b c d : α\nha : Membership.mem A a\nhb : Membership.mem A b\nhc : Membership.mem A c\nhd : Membership.mem A d\nh : Eq (HMul.hMul a b) (HMul.hMul c d)\n⊢ Eq (HMul.hMul (f a) (f b)) (HMul.hMul (f c) (f d))","decl":"@[to_additive]\nlemma IsMulFreimanHom.mul_eq_mul (hf : IsMulFreimanHom 2 A B f) {a b c d : α}\n    (ha : a ∈ A) (hb : b ∈ A) (hc : c ∈ A) (hd : d ∈ A) (h : a * b = c * d) :\n    f a * f b = f c * f d := by\n  simp_rw [← prod_pair] at h ⊢\n  refine hf.map_prod_eq_map_prod ?_ ?_ (card_pair _ _) (card_pair _ _) h <;> simp [ha, hb, hc, hd]\n\n"}
{"name":"IsAddFreimanHom.add_eq_add","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nhf : IsAddFreimanHom 2 A B f\na b c d : α\nha : Membership.mem A a\nhb : Membership.mem A b\nhc : Membership.mem A c\nhd : Membership.mem A d\nh : Eq (HAdd.hAdd a b) (HAdd.hAdd c d)\n⊢ Eq (HAdd.hAdd (f a) (f b)) (HAdd.hAdd (f c) (f d))","decl":"@[to_additive]\nlemma IsMulFreimanHom.mul_eq_mul (hf : IsMulFreimanHom 2 A B f) {a b c d : α}\n    (ha : a ∈ A) (hb : b ∈ A) (hc : c ∈ A) (hd : d ∈ A) (h : a * b = c * d) :\n    f a * f b = f c * f d := by\n  simp_rw [← prod_pair] at h ⊢\n  refine hf.map_prod_eq_map_prod ?_ ?_ (card_pair _ _) (card_pair _ _) h <;> simp [ha, hb, hc, hd]\n\n"}
{"name":"IsAddFreimanIso.add_eq_add","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nhf : IsAddFreimanIso 2 A B f\na b c d : α\nha : Membership.mem A a\nhb : Membership.mem A b\nhc : Membership.mem A c\nhd : Membership.mem A d\n⊢ Iff (Eq (HAdd.hAdd (f a) (f b)) (HAdd.hAdd (f c) (f d))) (Eq (HAdd.hAdd a b) (HAdd.hAdd c d))","decl":"@[to_additive]\nlemma IsMulFreimanIso.mul_eq_mul (hf : IsMulFreimanIso 2 A B f) {a b c d : α}\n    (ha : a ∈ A) (hb : b ∈ A) (hc : c ∈ A) (hd : d ∈ A) :\n    f a * f b = f c * f d ↔ a * b = c * d := by\n  simp_rw [← prod_pair]\n  refine hf.map_prod_eq_map_prod ?_ ?_ (card_pair _ _) (card_pair _ _) <;> simp [ha, hb, hc, hd]\n\n"}
{"name":"IsMulFreimanIso.mul_eq_mul","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf : α → β\nhf : IsMulFreimanIso 2 A B f\na b c d : α\nha : Membership.mem A a\nhb : Membership.mem A b\nhc : Membership.mem A c\nhd : Membership.mem A d\n⊢ Iff (Eq (HMul.hMul (f a) (f b)) (HMul.hMul (f c) (f d))) (Eq (HMul.hMul a b) (HMul.hMul c d))","decl":"@[to_additive]\nlemma IsMulFreimanIso.mul_eq_mul (hf : IsMulFreimanIso 2 A B f) {a b c d : α}\n    (ha : a ∈ A) (hb : b ∈ A) (hc : c ∈ A) (hd : d ∈ A) :\n    f a * f b = f c * f d ↔ a * b = c * d := by\n  simp_rw [← prod_pair]\n  refine hf.map_prod_eq_map_prod ?_ ?_ (card_pair _ _) (card_pair _ _) <;> simp [ha, hb, hc, hd]\n\n"}
{"name":"isAddFreimanHom_two","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsAddFreimanHom 2 A B f) (And (Set.MapsTo f A B) (∀ (a : α), Membership.mem A a → ∀ (b : α), Membership.mem A b → ∀ (c : α), Membership.mem A c → ∀ (d : α), Membership.mem A d → Eq (HAdd.hAdd a b) (HAdd.hAdd c d) → Eq (HAdd.hAdd (f a) (f b)) (HAdd.hAdd (f c) (f d))))","decl":"/-- Characterisation of `2`-Freiman homomorphisms. -/\n@[to_additive \"Characterisation of `2`-Freiman homomorphisms.\"]\nlemma isMulFreimanHom_two :\n    IsMulFreimanHom 2 A B f ↔ MapsTo f A B ∧ ∀ a ∈ A, ∀ b ∈ A, ∀ c ∈ A, ∀ d ∈ A,\n      a * b = c * d → f a * f b = f c * f d where\n  mp hf := ⟨hf.mapsTo, fun _ ha _ hb _ hc _ hd ↦ hf.mul_eq_mul ha hb hc hd⟩\n  mpr hf := ⟨hf.1, by aesop (add simp card_eq_two)⟩\n\n"}
{"name":"isMulFreimanHom_two","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsMulFreimanHom 2 A B f) (And (Set.MapsTo f A B) (∀ (a : α), Membership.mem A a → ∀ (b : α), Membership.mem A b → ∀ (c : α), Membership.mem A c → ∀ (d : α), Membership.mem A d → Eq (HMul.hMul a b) (HMul.hMul c d) → Eq (HMul.hMul (f a) (f b)) (HMul.hMul (f c) (f d))))","decl":"/-- Characterisation of `2`-Freiman homomorphisms. -/\n@[to_additive \"Characterisation of `2`-Freiman homomorphisms.\"]\nlemma isMulFreimanHom_two :\n    IsMulFreimanHom 2 A B f ↔ MapsTo f A B ∧ ∀ a ∈ A, ∀ b ∈ A, ∀ c ∈ A, ∀ d ∈ A,\n      a * b = c * d → f a * f b = f c * f d where\n  mp hf := ⟨hf.mapsTo, fun _ ha _ hb _ hc _ hd ↦ hf.mul_eq_mul ha hb hc hd⟩\n  mpr hf := ⟨hf.1, by aesop (add simp card_eq_two)⟩\n\n"}
{"name":"isAddFreimanIso_two","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsAddFreimanIso 2 A B f) (And (Set.BijOn f A B) (∀ (a : α), Membership.mem A a → ∀ (b : α), Membership.mem A b → ∀ (c : α), Membership.mem A c → ∀ (d : α), Membership.mem A d → Iff (Eq (HAdd.hAdd (f a) (f b)) (HAdd.hAdd (f c) (f d))) (Eq (HAdd.hAdd a b) (HAdd.hAdd c d))))","decl":"/-- Characterisation of `2`-Freiman homs. -/\n@[to_additive \"Characterisation of `2`-Freiman isomorphisms.\"]\nlemma isMulFreimanIso_two :\n    IsMulFreimanIso 2 A B f ↔ BijOn f A B ∧ ∀ a ∈ A, ∀ b ∈ A, ∀ c ∈ A, ∀ d ∈ A,\n      f a * f b = f c * f d ↔ a * b = c * d where\n  mp hf := ⟨hf.bijOn, fun _ ha _ hb _ hc _ hd => hf.mul_eq_mul ha hb hc hd⟩\n  mpr hf := ⟨hf.1, by aesop (add simp card_eq_two)⟩\n\n"}
{"name":"isMulFreimanIso_two","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsMulFreimanIso 2 A B f) (And (Set.BijOn f A B) (∀ (a : α), Membership.mem A a → ∀ (b : α), Membership.mem A b → ∀ (c : α), Membership.mem A c → ∀ (d : α), Membership.mem A d → Iff (Eq (HMul.hMul (f a) (f b)) (HMul.hMul (f c) (f d))) (Eq (HMul.hMul a b) (HMul.hMul c d))))","decl":"/-- Characterisation of `2`-Freiman homs. -/\n@[to_additive \"Characterisation of `2`-Freiman isomorphisms.\"]\nlemma isMulFreimanIso_two :\n    IsMulFreimanIso 2 A B f ↔ BijOn f A B ∧ ∀ a ∈ A, ∀ b ∈ A, ∀ c ∈ A, ∀ d ∈ A,\n      f a * f b = f c * f d ↔ a * b = c * d where\n  mp hf := ⟨hf.bijOn, fun _ ha _ hb _ hc _ hd => hf.mul_eq_mul ha hb hc hd⟩\n  mpr hf := ⟨hf.1, by aesop (add simp card_eq_two)⟩\n\n"}
{"name":"isMulFreimanHom_id","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\ninst✝ : CommMonoid α\nA₁ A₂ : Set α\nn : Nat\nhA : HasSubset.Subset A₁ A₂\n⊢ IsMulFreimanHom n A₁ A₂ id","decl":"@[to_additive] lemma isMulFreimanHom_id (hA : A₁ ⊆ A₂) : IsMulFreimanHom n A₁ A₂ id where\n  mapsTo := hA\n  map_prod_eq_map_prod s t _ _ _ _ h := by simpa using h\n\n"}
{"name":"isAddFreimanHom_id","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\ninst✝ : AddCommMonoid α\nA₁ A₂ : Set α\nn : Nat\nhA : HasSubset.Subset A₁ A₂\n⊢ IsAddFreimanHom n A₁ A₂ id","decl":"@[to_additive] lemma isMulFreimanHom_id (hA : A₁ ⊆ A₂) : IsMulFreimanHom n A₁ A₂ id where\n  mapsTo := hA\n  map_prod_eq_map_prod s t _ _ _ _ h := by simpa using h\n\n"}
{"name":"isAddFreimanIso_id","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\ninst✝ : AddCommMonoid α\nA : Set α\nn : Nat\n⊢ IsAddFreimanIso n A A id","decl":"@[to_additive] lemma isMulFreimanIso_id : IsMulFreimanIso n A A id where\n  bijOn := bijOn_id _\n  map_prod_eq_map_prod s t _ _ _ _ := by simp\n\n"}
{"name":"isMulFreimanIso_id","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\ninst✝ : CommMonoid α\nA : Set α\nn : Nat\n⊢ IsMulFreimanIso n A A id","decl":"@[to_additive] lemma isMulFreimanIso_id : IsMulFreimanIso n A A id where\n  bijOn := bijOn_id _\n  map_prod_eq_map_prod s t _ _ _ _ := by simp\n\n"}
{"name":"IsMulFreimanHom.comp","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : CommMonoid α\ninst✝¹ : CommMonoid β\ninst✝ : CommMonoid γ\nA : Set α\nB : Set β\nC : Set γ\nf : α → β\ng : β → γ\nn : Nat\nhg : IsMulFreimanHom n B C g\nhf : IsMulFreimanHom n A B f\n⊢ IsMulFreimanHom n A C (Function.comp g f)","decl":"@[to_additive] lemma IsMulFreimanHom.comp (hg : IsMulFreimanHom n B C g)\n    (hf : IsMulFreimanHom n A B f) : IsMulFreimanHom n A C (g ∘ f) where\n  mapsTo := hg.mapsTo.comp hf.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    rw [← map_map, ← map_map]\n    refine hg.map_prod_eq_map_prod ?_ ?_ (by rwa [card_map]) (by rwa [card_map])\n      (hf.map_prod_eq_map_prod hsA htA hs ht h)\n    · simpa using fun a h ↦ hf.mapsTo (hsA h)\n    · simpa using fun a h ↦ hf.mapsTo (htA h)\n\n"}
{"name":"IsAddFreimanHom.comp","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : AddCommMonoid α\ninst✝¹ : AddCommMonoid β\ninst✝ : AddCommMonoid γ\nA : Set α\nB : Set β\nC : Set γ\nf : α → β\ng : β → γ\nn : Nat\nhg : IsAddFreimanHom n B C g\nhf : IsAddFreimanHom n A B f\n⊢ IsAddFreimanHom n A C (Function.comp g f)","decl":"@[to_additive] lemma IsMulFreimanHom.comp (hg : IsMulFreimanHom n B C g)\n    (hf : IsMulFreimanHom n A B f) : IsMulFreimanHom n A C (g ∘ f) where\n  mapsTo := hg.mapsTo.comp hf.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    rw [← map_map, ← map_map]\n    refine hg.map_prod_eq_map_prod ?_ ?_ (by rwa [card_map]) (by rwa [card_map])\n      (hf.map_prod_eq_map_prod hsA htA hs ht h)\n    · simpa using fun a h ↦ hf.mapsTo (hsA h)\n    · simpa using fun a h ↦ hf.mapsTo (htA h)\n\n"}
{"name":"IsAddFreimanIso.comp","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : AddCommMonoid α\ninst✝¹ : AddCommMonoid β\ninst✝ : AddCommMonoid γ\nA : Set α\nB : Set β\nC : Set γ\nf : α → β\ng : β → γ\nn : Nat\nhg : IsAddFreimanIso n B C g\nhf : IsAddFreimanIso n A B f\n⊢ IsAddFreimanIso n A C (Function.comp g f)","decl":"@[to_additive] lemma IsMulFreimanIso.comp (hg : IsMulFreimanIso n B C g)\n    (hf : IsMulFreimanIso n A B f) : IsMulFreimanIso n A C (g ∘ f) where\n  bijOn := hg.bijOn.comp hf.bijOn\n  map_prod_eq_map_prod s t hsA htA hs ht := by\n    rw [← map_map, ← map_map]\n    rw [hg.map_prod_eq_map_prod _ _ (by rwa [card_map]) (by rwa [card_map]),\n      hf.map_prod_eq_map_prod hsA htA hs ht]\n    · simpa using fun a h ↦ hf.bijOn.mapsTo (hsA h)\n    · simpa using fun a h ↦ hf.bijOn.mapsTo (htA h)\n\n"}
{"name":"IsMulFreimanIso.comp","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : CommMonoid α\ninst✝¹ : CommMonoid β\ninst✝ : CommMonoid γ\nA : Set α\nB : Set β\nC : Set γ\nf : α → β\ng : β → γ\nn : Nat\nhg : IsMulFreimanIso n B C g\nhf : IsMulFreimanIso n A B f\n⊢ IsMulFreimanIso n A C (Function.comp g f)","decl":"@[to_additive] lemma IsMulFreimanIso.comp (hg : IsMulFreimanIso n B C g)\n    (hf : IsMulFreimanIso n A B f) : IsMulFreimanIso n A C (g ∘ f) where\n  bijOn := hg.bijOn.comp hf.bijOn\n  map_prod_eq_map_prod s t hsA htA hs ht := by\n    rw [← map_map, ← map_map]\n    rw [hg.map_prod_eq_map_prod _ _ (by rwa [card_map]) (by rwa [card_map]),\n      hf.map_prod_eq_map_prod hsA htA hs ht]\n    · simpa using fun a h ↦ hf.bijOn.mapsTo (hsA h)\n    · simpa using fun a h ↦ hf.bijOn.mapsTo (htA h)\n\n"}
{"name":"IsAddFreimanHom.subset","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA₁ A₂ : Set α\nB₁ B₂ : Set β\nf : α → β\nn : Nat\nhA : HasSubset.Subset A₁ A₂\nhf : IsAddFreimanHom n A₂ B₂ f\nhf' : Set.MapsTo f A₁ B₁\n⊢ IsAddFreimanHom n A₁ B₁ f","decl":"@[to_additive] lemma IsMulFreimanHom.subset (hA : A₁ ⊆ A₂) (hf : IsMulFreimanHom n A₂ B₂ f)\n    (hf' : MapsTo f A₁ B₁) : IsMulFreimanHom n A₁ B₁ f where\n  mapsTo := hf'\n  __ := hf.comp (isMulFreimanHom_id hA)\n\n"}
{"name":"IsMulFreimanHom.subset","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA₁ A₂ : Set α\nB₁ B₂ : Set β\nf : α → β\nn : Nat\nhA : HasSubset.Subset A₁ A₂\nhf : IsMulFreimanHom n A₂ B₂ f\nhf' : Set.MapsTo f A₁ B₁\n⊢ IsMulFreimanHom n A₁ B₁ f","decl":"@[to_additive] lemma IsMulFreimanHom.subset (hA : A₁ ⊆ A₂) (hf : IsMulFreimanHom n A₂ B₂ f)\n    (hf' : MapsTo f A₁ B₁) : IsMulFreimanHom n A₁ B₁ f where\n  mapsTo := hf'\n  __ := hf.comp (isMulFreimanHom_id hA)\n\n"}
{"name":"IsAddFreimanHom.superset","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB₁ B₂ : Set β\nf : α → β\nn : Nat\nhB : HasSubset.Subset B₁ B₂\nhf : IsAddFreimanHom n A B₁ f\n⊢ IsAddFreimanHom n A B₂ f","decl":"@[to_additive] lemma IsMulFreimanHom.superset (hB : B₁ ⊆ B₂) (hf : IsMulFreimanHom n A B₁ f) :\n    IsMulFreimanHom n A B₂ f := (isMulFreimanHom_id hB).comp hf\n\n"}
{"name":"IsMulFreimanHom.superset","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB₁ B₂ : Set β\nf : α → β\nn : Nat\nhB : HasSubset.Subset B₁ B₂\nhf : IsMulFreimanHom n A B₁ f\n⊢ IsMulFreimanHom n A B₂ f","decl":"@[to_additive] lemma IsMulFreimanHom.superset (hB : B₁ ⊆ B₂) (hf : IsMulFreimanHom n A B₁ f) :\n    IsMulFreimanHom n A B₂ f := (isMulFreimanHom_id hB).comp hf\n\n"}
{"name":"IsAddFreimanIso.subset","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA₁ A₂ : Set α\nB₁ B₂ : Set β\nf : α → β\nn : Nat\nhA : HasSubset.Subset A₁ A₂\nhf : IsAddFreimanIso n A₂ B₂ f\nhf' : Set.BijOn f A₁ B₁\n⊢ IsAddFreimanIso n A₁ B₁ f","decl":"@[to_additive] lemma IsMulFreimanIso.subset (hA : A₁ ⊆ A₂) (hf : IsMulFreimanIso n A₂ B₂ f)\n    (hf' : BijOn f A₁ B₁) : IsMulFreimanIso n A₁ B₁ f where\n  bijOn := hf'\n  map_prod_eq_map_prod s t hsA htA hs ht := by\n    refine hf.map_prod_eq_map_prod (fun a ha ↦ hA (hsA ha)) (fun a ha ↦ hA (htA ha)) hs ht\n\n"}
{"name":"IsMulFreimanIso.subset","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA₁ A₂ : Set α\nB₁ B₂ : Set β\nf : α → β\nn : Nat\nhA : HasSubset.Subset A₁ A₂\nhf : IsMulFreimanIso n A₂ B₂ f\nhf' : Set.BijOn f A₁ B₁\n⊢ IsMulFreimanIso n A₁ B₁ f","decl":"@[to_additive] lemma IsMulFreimanIso.subset (hA : A₁ ⊆ A₂) (hf : IsMulFreimanIso n A₂ B₂ f)\n    (hf' : BijOn f A₁ B₁) : IsMulFreimanIso n A₁ B₁ f where\n  bijOn := hf'\n  map_prod_eq_map_prod s t hsA htA hs ht := by\n    refine hf.map_prod_eq_map_prod (fun a ha ↦ hA (hsA ha)) (fun a ha ↦ hA (htA ha)) hs ht\n\n"}
{"name":"isMulFreimanHom_const","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nn : Nat\nb : β\nhb : Membership.mem B b\n⊢ IsMulFreimanHom n A B fun x => b","decl":"@[to_additive]\nlemma isMulFreimanHom_const {b : β} (hb : b ∈ B) : IsMulFreimanHom n A B fun _ ↦ b where\n  mapsTo _ _ := hb\n  map_prod_eq_map_prod s t _ _ hs ht _ := by simp only [map_const', hs, prod_replicate, ht]\n\n"}
{"name":"isAddFreimanHom_const","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nn : Nat\nb : β\nhb : Membership.mem B b\n⊢ IsAddFreimanHom n A B fun x => b","decl":"@[to_additive]\nlemma isMulFreimanHom_const {b : β} (hb : b ∈ B) : IsMulFreimanHom n A B fun _ ↦ b where\n  mapsTo _ _ := hb\n  map_prod_eq_map_prod s t _ _ hs ht _ := by simp only [map_const', hs, prod_replicate, ht]\n\n"}
{"name":"isAddFreimanHom_zero_iff","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsAddFreimanHom 0 A B f) (Set.MapsTo f A B)","decl":"@[to_additive (attr := simp)]\nlemma isMulFreimanHom_zero_iff : IsMulFreimanHom 0 A B f ↔ MapsTo f A B :=\n  ⟨fun h => h.mapsTo, fun h => ⟨h, by aesop⟩⟩\n\n"}
{"name":"isMulFreimanHom_zero_iff","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsMulFreimanHom 0 A B f) (Set.MapsTo f A B)","decl":"@[to_additive (attr := simp)]\nlemma isMulFreimanHom_zero_iff : IsMulFreimanHom 0 A B f ↔ MapsTo f A B :=\n  ⟨fun h => h.mapsTo, fun h => ⟨h, by aesop⟩⟩\n\n"}
{"name":"isAddFreimanIso_zero_iff","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsAddFreimanIso 0 A B f) (Set.BijOn f A B)","decl":"@[to_additive (attr := simp)]\nlemma isMulFreimanIso_zero_iff : IsMulFreimanIso 0 A B f ↔ BijOn f A B :=\n  ⟨fun h => h.bijOn, fun h => ⟨h, by aesop⟩⟩\n\n"}
{"name":"isMulFreimanIso_zero_iff","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsMulFreimanIso 0 A B f) (Set.BijOn f A B)","decl":"@[to_additive (attr := simp)]\nlemma isMulFreimanIso_zero_iff : IsMulFreimanIso 0 A B f ↔ BijOn f A B :=\n  ⟨fun h => h.bijOn, fun h => ⟨h, by aesop⟩⟩\n\n"}
{"name":"isMulFreimanHom_one_iff","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsMulFreimanHom 1 A B f) (Set.MapsTo f A B)","decl":"@[to_additive (attr := simp) isAddFreimanHom_one_iff]\nlemma isMulFreimanHom_one_iff : IsMulFreimanHom 1 A B f ↔ MapsTo f A B :=\n  ⟨fun h => h.mapsTo, fun h => ⟨h, by aesop (add simp card_eq_one)⟩⟩\n\n"}
{"name":"isAddFreimanHom_one_iff","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsAddFreimanHom 1 A B f) (Set.MapsTo f A B)","decl":"@[to_additive (attr := simp) isAddFreimanHom_one_iff]\nlemma isMulFreimanHom_one_iff : IsMulFreimanHom 1 A B f ↔ MapsTo f A B :=\n  ⟨fun h => h.mapsTo, fun h => ⟨h, by aesop (add simp card_eq_one)⟩⟩\n\n"}
{"name":"isMulFreimanIso_one_iff","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsMulFreimanIso 1 A B f) (Set.BijOn f A B)","decl":"@[to_additive (attr := simp) isAddFreimanIso_one_iff]\nlemma isMulFreimanIso_one_iff : IsMulFreimanIso 1 A B f ↔ BijOn f A B :=\n  ⟨fun h => h.bijOn, fun h => ⟨h, by aesop (add simp [card_eq_one, BijOn])⟩⟩\n\n"}
{"name":"isAddFreimanIso_one_iff","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB : Set β\nf : α → β\n⊢ Iff (IsAddFreimanIso 1 A B f) (Set.BijOn f A B)","decl":"@[to_additive (attr := simp) isAddFreimanIso_one_iff]\nlemma isMulFreimanIso_one_iff : IsMulFreimanIso 1 A B f ↔ BijOn f A B :=\n  ⟨fun h => h.bijOn, fun h => ⟨h, by aesop (add simp [card_eq_one, BijOn])⟩⟩\n\n"}
{"name":"isAddFreimanHom_empty","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nB : Set β\nf : α → β\nn : Nat\n⊢ IsAddFreimanHom n EmptyCollection.emptyCollection B f","decl":"@[to_additive (attr := simp)]\nlemma isMulFreimanHom_empty : IsMulFreimanHom n (∅ : Set α) B f where\n  mapsTo := mapsTo_empty f B\n  map_prod_eq_map_prod s t := by aesop (add simp eq_zero_of_forall_not_mem)\n\n"}
{"name":"isMulFreimanHom_empty","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nB : Set β\nf : α → β\nn : Nat\n⊢ IsMulFreimanHom n EmptyCollection.emptyCollection B f","decl":"@[to_additive (attr := simp)]\nlemma isMulFreimanHom_empty : IsMulFreimanHom n (∅ : Set α) B f where\n  mapsTo := mapsTo_empty f B\n  map_prod_eq_map_prod s t := by aesop (add simp eq_zero_of_forall_not_mem)\n\n"}
{"name":"isAddFreimanIso_empty","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nf : α → β\nn : Nat\n⊢ IsAddFreimanIso n EmptyCollection.emptyCollection EmptyCollection.emptyCollection f","decl":"@[to_additive (attr := simp)]\nlemma isMulFreimanIso_empty : IsMulFreimanIso n (∅ : Set α) (∅ : Set β) f where\n  bijOn := bijOn_empty _\n  map_prod_eq_map_prod s t hs ht := by\n    simp [eq_zero_of_forall_not_mem hs, eq_zero_of_forall_not_mem ht]\n\n"}
{"name":"isMulFreimanIso_empty","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nf : α → β\nn : Nat\n⊢ IsMulFreimanIso n EmptyCollection.emptyCollection EmptyCollection.emptyCollection f","decl":"@[to_additive (attr := simp)]\nlemma isMulFreimanIso_empty : IsMulFreimanIso n (∅ : Set α) (∅ : Set β) f where\n  bijOn := bijOn_empty _\n  map_prod_eq_map_prod s t hs ht := by\n    simp [eq_zero_of_forall_not_mem hs, eq_zero_of_forall_not_mem ht]\n\n"}
{"name":"IsAddFreimanHom.add","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nA : Set α\nB₁ B₂ : Set β\nf₁ f₂ : α → β\nn : Nat\nh₁ : IsAddFreimanHom n A B₁ f₁\nh₂ : IsAddFreimanHom n A B₂ f₂\n⊢ IsAddFreimanHom n A (HAdd.hAdd B₁ B₂) (HAdd.hAdd f₁ f₂)","decl":"@[to_additive] lemma IsMulFreimanHom.mul (h₁ : IsMulFreimanHom n A B₁ f₁)\n    (h₂ : IsMulFreimanHom n A B₂ f₂) : IsMulFreimanHom n A (B₁ * B₂) (f₁ * f₂) where\n  mapsTo := h₁.mapsTo.mul h₂.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    rw [Pi.mul_def, prod_map_mul, prod_map_mul, h₁.map_prod_eq_map_prod hsA htA hs ht h,\n      h₂.map_prod_eq_map_prod hsA htA hs ht h]\n\n"}
{"name":"IsMulFreimanHom.mul","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nA : Set α\nB₁ B₂ : Set β\nf₁ f₂ : α → β\nn : Nat\nh₁ : IsMulFreimanHom n A B₁ f₁\nh₂ : IsMulFreimanHom n A B₂ f₂\n⊢ IsMulFreimanHom n A (HMul.hMul B₁ B₂) (HMul.hMul f₁ f₂)","decl":"@[to_additive] lemma IsMulFreimanHom.mul (h₁ : IsMulFreimanHom n A B₁ f₁)\n    (h₂ : IsMulFreimanHom n A B₂ f₂) : IsMulFreimanHom n A (B₁ * B₂) (f₁ * f₂) where\n  mapsTo := h₁.mapsTo.mul h₂.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    rw [Pi.mul_def, prod_map_mul, prod_map_mul, h₁.map_prod_eq_map_prod hsA htA hs ht h,\n      h₂.map_prod_eq_map_prod hsA htA hs ht h]\n\n"}
{"name":"AddMonoidHomClass.isAddFreimanHom","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\nA : Set α\nB : Set β\nn : Nat\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\nhfAB : Set.MapsTo (⇑f) A B\n⊢ IsAddFreimanHom n A B ⇑f","decl":"@[to_additive] lemma MonoidHomClass.isMulFreimanHom [FunLike F α β] [MonoidHomClass F α β] (f : F)\n    (hfAB : MapsTo f A B) : IsMulFreimanHom n A B f where\n  mapsTo := hfAB\n  map_prod_eq_map_prod s t _ _ _ _ h := by rw [← map_multiset_prod, h, map_multiset_prod]\n\n"}
{"name":"MonoidHomClass.isMulFreimanHom","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : CommMonoid α\ninst✝² : CommMonoid β\nA : Set α\nB : Set β\nn : Nat\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\nhfAB : Set.MapsTo (⇑f) A B\n⊢ IsMulFreimanHom n A B ⇑f","decl":"@[to_additive] lemma MonoidHomClass.isMulFreimanHom [FunLike F α β] [MonoidHomClass F α β] (f : F)\n    (hfAB : MapsTo f A B) : IsMulFreimanHom n A B f where\n  mapsTo := hfAB\n  map_prod_eq_map_prod s t _ _ _ _ h := by rw [← map_multiset_prod, h, map_multiset_prod]\n\n"}
{"name":"MulEquivClass.isMulFreimanIso","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : CommMonoid α\ninst✝² : CommMonoid β\nA : Set α\nB : Set β\nn : Nat\ninst✝¹ : EquivLike F α β\ninst✝ : MulEquivClass F α β\nf : F\nhfAB : Set.BijOn (⇑f) A B\n⊢ IsMulFreimanIso n A B ⇑f","decl":"@[to_additive] lemma MulEquivClass.isMulFreimanIso [EquivLike F α β] [MulEquivClass F α β] (f : F)\n    (hfAB : BijOn f A B) : IsMulFreimanIso n A B f where\n  bijOn := hfAB\n  map_prod_eq_map_prod s t _ _ _ _ := by\n    rw [← map_multiset_prod, ← map_multiset_prod, EquivLike.apply_eq_iff_eq]\n\n"}
{"name":"AddEquivClass.isAddFreimanIso","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\nA : Set α\nB : Set β\nn : Nat\ninst✝¹ : EquivLike F α β\ninst✝ : AddEquivClass F α β\nf : F\nhfAB : Set.BijOn (⇑f) A B\n⊢ IsAddFreimanIso n A B ⇑f","decl":"@[to_additive] lemma MulEquivClass.isMulFreimanIso [EquivLike F α β] [MulEquivClass F α β] (f : F)\n    (hfAB : BijOn f A B) : IsMulFreimanIso n A B f where\n  bijOn := hfAB\n  map_prod_eq_map_prod s t _ _ _ _ := by\n    rw [← map_multiset_prod, ← map_multiset_prod, EquivLike.apply_eq_iff_eq]\n\n"}
{"name":"IsMulFreimanHom.subtypeVal","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\ninst✝² : CommMonoid α\nn : Nat\nS : Type u_5\ninst✝¹ : SetLike S α\ninst✝ : SubmonoidClass S α\ns : S\n⊢ IsMulFreimanHom n Set.univ Set.univ Subtype.val","decl":"@[to_additive]\nlemma IsMulFreimanHom.subtypeVal {S : Type*} [SetLike S α] [SubmonoidClass S α] {s : S} :\n    IsMulFreimanHom n (univ : Set s) univ Subtype.val :=\n  MonoidHomClass.isMulFreimanHom (SubmonoidClass.subtype s) (mapsTo_univ ..)\n\n"}
{"name":"IsAddFreimanHom.subtypeVal","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\ninst✝² : AddCommMonoid α\nn : Nat\nS : Type u_5\ninst✝¹ : SetLike S α\ninst✝ : AddSubmonoidClass S α\ns : S\n⊢ IsAddFreimanHom n Set.univ Set.univ Subtype.val","decl":"@[to_additive]\nlemma IsMulFreimanHom.subtypeVal {S : Type*} [SetLike S α] [SubmonoidClass S α] {s : S} :\n    IsMulFreimanHom n (univ : Set s) univ Subtype.val :=\n  MonoidHomClass.isMulFreimanHom (SubmonoidClass.subtype s) (mapsTo_univ ..)\n\n"}
{"name":"IsAddFreimanHom.mono","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCancelCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nm n : Nat\nhmn : LE.le m n\nhf : IsAddFreimanHom n A B f\n⊢ IsAddFreimanHom m A B f","decl":"@[to_additive]\nlemma IsMulFreimanHom.mono (hmn : m ≤ n) (hf : IsMulFreimanHom n A B f) :\n    IsMulFreimanHom m A B f where\n  mapsTo := hf.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    obtain rfl | hm := m.eq_zero_or_pos\n    · rw [card_eq_zero] at hs ht\n      rw [hs, ht]\n    simp only [← hs, card_pos_iff_exists_mem] at hm\n    obtain ⟨a, ha⟩ := hm\n    suffices ((s + replicate (n - m) a).map f).prod = ((t + replicate (n - m) a).map f).prod by\n      simp_rw [Multiset.map_add, prod_add] at this\n      exact mul_right_cancel this\n    replace ha := hsA ha\n    refine hf.map_prod_eq_map_prod (fun a ha ↦ ?_) (fun a ha ↦ ?_) ?_ ?_ ?_\n    · rw [Multiset.mem_add] at ha\n      obtain ha | ha := ha\n      · exact hsA ha\n      · rwa [eq_of_mem_replicate ha]\n    · rw [Multiset.mem_add] at ha\n      obtain ha | ha := ha\n      · exact htA ha\n      · rwa [eq_of_mem_replicate ha]\n    · rw [card_add, card_replicate, hs, Nat.add_sub_cancel' hmn]\n    · rw [card_add, card_replicate, ht, Nat.add_sub_cancel' hmn]\n    · rw [prod_add, prod_add, h]\n\n"}
{"name":"IsMulFreimanHom.mono","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CancelCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nm n : Nat\nhmn : LE.le m n\nhf : IsMulFreimanHom n A B f\n⊢ IsMulFreimanHom m A B f","decl":"@[to_additive]\nlemma IsMulFreimanHom.mono (hmn : m ≤ n) (hf : IsMulFreimanHom n A B f) :\n    IsMulFreimanHom m A B f where\n  mapsTo := hf.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    obtain rfl | hm := m.eq_zero_or_pos\n    · rw [card_eq_zero] at hs ht\n      rw [hs, ht]\n    simp only [← hs, card_pos_iff_exists_mem] at hm\n    obtain ⟨a, ha⟩ := hm\n    suffices ((s + replicate (n - m) a).map f).prod = ((t + replicate (n - m) a).map f).prod by\n      simp_rw [Multiset.map_add, prod_add] at this\n      exact mul_right_cancel this\n    replace ha := hsA ha\n    refine hf.map_prod_eq_map_prod (fun a ha ↦ ?_) (fun a ha ↦ ?_) ?_ ?_ ?_\n    · rw [Multiset.mem_add] at ha\n      obtain ha | ha := ha\n      · exact hsA ha\n      · rwa [eq_of_mem_replicate ha]\n    · rw [Multiset.mem_add] at ha\n      obtain ha | ha := ha\n      · exact htA ha\n      · rwa [eq_of_mem_replicate ha]\n    · rw [card_add, card_replicate, hs, Nat.add_sub_cancel' hmn]\n    · rw [card_add, card_replicate, ht, Nat.add_sub_cancel' hmn]\n    · rw [prod_add, prod_add, h]\n\n"}
{"name":"IsMulFreimanIso.mono","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CancelCommMonoid α\ninst✝ : CancelCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nm n : Nat\nhmn : LE.le m n\nhf : IsMulFreimanIso n A B f\n⊢ IsMulFreimanIso m A B f","decl":"@[to_additive]\nlemma IsMulFreimanIso.mono {hmn : m ≤ n} (hf : IsMulFreimanIso n A B f) :\n    IsMulFreimanIso m A B f where\n  bijOn := hf.bijOn\n  map_prod_eq_map_prod s t hsA htA hs ht := by\n    obtain rfl | hm := m.eq_zero_or_pos\n    · rw [card_eq_zero] at hs ht\n      simp [hs, ht]\n    simp only [← hs, card_pos_iff_exists_mem] at hm\n    obtain ⟨a, ha⟩ := hm\n    suffices\n      ((s + replicate (n - m) a).map f).prod = ((t + replicate (n - m) a).map f).prod ↔\n      (s + replicate (n - m) a).prod = (t + replicate (n - m) a).prod by\n      simpa only [Multiset.map_add, prod_add, mul_right_cancel_iff] using this\n    replace ha := hsA ha\n    refine hf.map_prod_eq_map_prod (fun a ha ↦ ?_) (fun a ha ↦ ?_) ?_ ?_\n    · rw [Multiset.mem_add] at ha\n      obtain ha | ha := ha\n      · exact hsA ha\n      · rwa [eq_of_mem_replicate ha]\n    · rw [Multiset.mem_add] at ha\n      obtain ha | ha := ha\n      · exact htA ha\n      · rwa [eq_of_mem_replicate ha]\n    · rw [card_add, card_replicate, hs, Nat.add_sub_cancel' hmn]\n    · rw [card_add, card_replicate, ht, Nat.add_sub_cancel' hmn]\n\n"}
{"name":"IsAddFreimanIso.mono","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCancelCommMonoid α\ninst✝ : AddCancelCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nm n : Nat\nhmn : LE.le m n\nhf : IsAddFreimanIso n A B f\n⊢ IsAddFreimanIso m A B f","decl":"@[to_additive]\nlemma IsMulFreimanIso.mono {hmn : m ≤ n} (hf : IsMulFreimanIso n A B f) :\n    IsMulFreimanIso m A B f where\n  bijOn := hf.bijOn\n  map_prod_eq_map_prod s t hsA htA hs ht := by\n    obtain rfl | hm := m.eq_zero_or_pos\n    · rw [card_eq_zero] at hs ht\n      simp [hs, ht]\n    simp only [← hs, card_pos_iff_exists_mem] at hm\n    obtain ⟨a, ha⟩ := hm\n    suffices\n      ((s + replicate (n - m) a).map f).prod = ((t + replicate (n - m) a).map f).prod ↔\n      (s + replicate (n - m) a).prod = (t + replicate (n - m) a).prod by\n      simpa only [Multiset.map_add, prod_add, mul_right_cancel_iff] using this\n    replace ha := hsA ha\n    refine hf.map_prod_eq_map_prod (fun a ha ↦ ?_) (fun a ha ↦ ?_) ?_ ?_\n    · rw [Multiset.mem_add] at ha\n      obtain ha | ha := ha\n      · exact hsA ha\n      · rwa [eq_of_mem_replicate ha]\n    · rw [Multiset.mem_add] at ha\n      obtain ha | ha := ha\n      · exact htA ha\n      · rwa [eq_of_mem_replicate ha]\n    · rw [card_add, card_replicate, hs, Nat.add_sub_cancel' hmn]\n    · rw [card_add, card_replicate, ht, Nat.add_sub_cancel' hmn]\n\n"}
{"name":"IsMulFreimanHom.inv","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : DivisionCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nn : Nat\nhf : IsMulFreimanHom n A B f\n⊢ IsMulFreimanHom n A (Inv.inv B) (Inv.inv f)","decl":"@[to_additive]\nlemma IsMulFreimanHom.inv (hf : IsMulFreimanHom n A B f) : IsMulFreimanHom n A B⁻¹ f⁻¹ where\n  mapsTo := hf.mapsTo.inv\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    rw [Pi.inv_def, prod_map_inv, prod_map_inv, hf.map_prod_eq_map_prod hsA htA hs ht h]\n\n"}
{"name":"IsAddFreimanHom.neg","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : SubtractionCommMonoid β\nA : Set α\nB : Set β\nf : α → β\nn : Nat\nhf : IsAddFreimanHom n A B f\n⊢ IsAddFreimanHom n A (Neg.neg B) (Neg.neg f)","decl":"@[to_additive]\nlemma IsMulFreimanHom.inv (hf : IsMulFreimanHom n A B f) : IsMulFreimanHom n A B⁻¹ f⁻¹ where\n  mapsTo := hf.mapsTo.inv\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    rw [Pi.inv_def, prod_map_inv, prod_map_inv, hf.map_prod_eq_map_prod hsA htA hs ht h]\n\n"}
{"name":"IsMulFreimanHom.div","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\ninst✝¹ : CommMonoid α\nA : Set α\nn : Nat\nβ : Type u_5\ninst✝ : DivisionCommMonoid β\nB₁ B₂ : Set β\nf₁ f₂ : α → β\nh₁ : IsMulFreimanHom n A B₁ f₁\nh₂ : IsMulFreimanHom n A B₂ f₂\n⊢ IsMulFreimanHom n A (HDiv.hDiv B₁ B₂) (HDiv.hDiv f₁ f₂)","decl":"@[to_additive] lemma IsMulFreimanHom.div {β : Type*} [DivisionCommMonoid β] {B₁ B₂ : Set β}\n    {f₁ f₂ : α → β} (h₁ : IsMulFreimanHom n A B₁ f₁) (h₂ : IsMulFreimanHom n A B₂ f₂) :\n    IsMulFreimanHom n A (B₁ / B₂) (f₁ / f₂) where\n  mapsTo := h₁.mapsTo.div h₂.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    rw [Pi.div_def, prod_map_div, prod_map_div, h₁.map_prod_eq_map_prod hsA htA hs ht h,\n      h₂.map_prod_eq_map_prod hsA htA hs ht h]\n\n"}
{"name":"IsAddFreimanHom.sub","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α : Type u_2\ninst✝¹ : AddCommMonoid α\nA : Set α\nn : Nat\nβ : Type u_5\ninst✝ : SubtractionCommMonoid β\nB₁ B₂ : Set β\nf₁ f₂ : α → β\nh₁ : IsAddFreimanHom n A B₁ f₁\nh₂ : IsAddFreimanHom n A B₂ f₂\n⊢ IsAddFreimanHom n A (HSub.hSub B₁ B₂) (HSub.hSub f₁ f₂)","decl":"@[to_additive] lemma IsMulFreimanHom.div {β : Type*} [DivisionCommMonoid β] {B₁ B₂ : Set β}\n    {f₁ f₂ : α → β} (h₁ : IsMulFreimanHom n A B₁ f₁) (h₂ : IsMulFreimanHom n A B₂ f₂) :\n    IsMulFreimanHom n A (B₁ / B₂) (f₁ / f₂) where\n  mapsTo := h₁.mapsTo.div h₂.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    rw [Pi.div_def, prod_map_div, prod_map_div, h₁.map_prod_eq_map_prod hsA htA hs ht h,\n      h₂.map_prod_eq_map_prod hsA htA hs ht h]\n\n"}
{"name":"IsMulFreimanHom.prod","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α₁ : Type u_5\nα₂ : Type u_6\nβ₁ : Type u_7\nβ₂ : Type u_8\ninst✝³ : CommMonoid α₁\ninst✝² : CommMonoid α₂\ninst✝¹ : CommMonoid β₁\ninst✝ : CommMonoid β₂\nA₁ : Set α₁\nA₂ : Set α₂\nB₁ : Set β₁\nB₂ : Set β₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\nn : Nat\nh₁ : IsMulFreimanHom n A₁ B₁ f₁\nh₂ : IsMulFreimanHom n A₂ B₂ f₂\n⊢ IsMulFreimanHom n (SProd.sprod A₁ A₂) (SProd.sprod B₁ B₂) (Prod.map f₁ f₂)","decl":"@[to_additive]\nlemma IsMulFreimanHom.prod (h₁ : IsMulFreimanHom n A₁ B₁ f₁) (h₂ : IsMulFreimanHom n A₂ B₂ f₂) :\n    IsMulFreimanHom n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where\n  mapsTo := h₁.mapsTo.prodMap h₂.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    simp only [mem_prod, forall_and, Prod.forall] at hsA htA\n    simp only [Prod.ext_iff, fst_prod, snd_prod, map_map, Function.comp_apply, Prod.map_fst,\n      Prod.map_snd] at h ⊢\n    rw [← Function.comp_def, ← map_map, ← map_map, ← Function.comp_def f₂, ← map_map, ← map_map]\n    exact ⟨h₁.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa)\n      (by simpa) h.1, h₂.map_prod_eq_map_prod (by simpa [@forall_swap α₁] using hsA.2)\n      (by simpa [@forall_swap α₁] using htA.2) (by simpa) (by simpa) h.2⟩\n\n"}
{"name":"IsAddFreimanHom.sum","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α₁ : Type u_5\nα₂ : Type u_6\nβ₁ : Type u_7\nβ₂ : Type u_8\ninst✝³ : AddCommMonoid α₁\ninst✝² : AddCommMonoid α₂\ninst✝¹ : AddCommMonoid β₁\ninst✝ : AddCommMonoid β₂\nA₁ : Set α₁\nA₂ : Set α₂\nB₁ : Set β₁\nB₂ : Set β₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\nn : Nat\nh₁ : IsAddFreimanHom n A₁ B₁ f₁\nh₂ : IsAddFreimanHom n A₂ B₂ f₂\n⊢ IsAddFreimanHom n (SProd.sprod A₁ A₂) (SProd.sprod B₁ B₂) (Prod.map f₁ f₂)","decl":"@[to_additive]\nlemma IsMulFreimanHom.prod (h₁ : IsMulFreimanHom n A₁ B₁ f₁) (h₂ : IsMulFreimanHom n A₂ B₂ f₂) :\n    IsMulFreimanHom n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where\n  mapsTo := h₁.mapsTo.prodMap h₂.mapsTo\n  map_prod_eq_map_prod s t hsA htA hs ht h := by\n    simp only [mem_prod, forall_and, Prod.forall] at hsA htA\n    simp only [Prod.ext_iff, fst_prod, snd_prod, map_map, Function.comp_apply, Prod.map_fst,\n      Prod.map_snd] at h ⊢\n    rw [← Function.comp_def, ← map_map, ← map_map, ← Function.comp_def f₂, ← map_map, ← map_map]\n    exact ⟨h₁.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa)\n      (by simpa) h.1, h₂.map_prod_eq_map_prod (by simpa [@forall_swap α₁] using hsA.2)\n      (by simpa [@forall_swap α₁] using htA.2) (by simpa) (by simpa) h.2⟩\n\n"}
{"name":"IsMulFreimanIso.prod","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α₁ : Type u_5\nα₂ : Type u_6\nβ₁ : Type u_7\nβ₂ : Type u_8\ninst✝³ : CommMonoid α₁\ninst✝² : CommMonoid α₂\ninst✝¹ : CommMonoid β₁\ninst✝ : CommMonoid β₂\nA₁ : Set α₁\nA₂ : Set α₂\nB₁ : Set β₁\nB₂ : Set β₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\nn : Nat\nh₁ : IsMulFreimanIso n A₁ B₁ f₁\nh₂ : IsMulFreimanIso n A₂ B₂ f₂\n⊢ IsMulFreimanIso n (SProd.sprod A₁ A₂) (SProd.sprod B₁ B₂) (Prod.map f₁ f₂)","decl":"@[to_additive]\nlemma IsMulFreimanIso.prod (h₁ : IsMulFreimanIso n A₁ B₁ f₁) (h₂ : IsMulFreimanIso n A₂ B₂ f₂) :\n    IsMulFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where\n  bijOn := h₁.bijOn.prodMap h₂.bijOn\n  map_prod_eq_map_prod s t hsA htA hs ht := by\n    simp only [mem_prod, forall_and, Prod.forall] at hsA htA\n    simp only [Prod.ext_iff, fst_prod, map_map, Function.comp_apply, Prod.map_fst, snd_prod,\n      Prod.map_snd]\n    rw [← Function.comp_def, ← map_map, ← map_map, ← Function.comp_def f₂, ← map_map, ← map_map,\n      h₁.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa) (by simpa),\n      h₂.map_prod_eq_map_prod (by simpa [@forall_swap α₁] using hsA.2)\n      (by simpa [@forall_swap α₁] using htA.2) (by simpa) (by simpa)]\n\n"}
{"name":"IsAddFreimanIso.sum","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"α₁ : Type u_5\nα₂ : Type u_6\nβ₁ : Type u_7\nβ₂ : Type u_8\ninst✝³ : AddCommMonoid α₁\ninst✝² : AddCommMonoid α₂\ninst✝¹ : AddCommMonoid β₁\ninst✝ : AddCommMonoid β₂\nA₁ : Set α₁\nA₂ : Set α₂\nB₁ : Set β₁\nB₂ : Set β₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\nn : Nat\nh₁ : IsAddFreimanIso n A₁ B₁ f₁\nh₂ : IsAddFreimanIso n A₂ B₂ f₂\n⊢ IsAddFreimanIso n (SProd.sprod A₁ A₂) (SProd.sprod B₁ B₂) (Prod.map f₁ f₂)","decl":"@[to_additive]\nlemma IsMulFreimanIso.prod (h₁ : IsMulFreimanIso n A₁ B₁ f₁) (h₂ : IsMulFreimanIso n A₂ B₂ f₂) :\n    IsMulFreimanIso n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where\n  bijOn := h₁.bijOn.prodMap h₂.bijOn\n  map_prod_eq_map_prod s t hsA htA hs ht := by\n    simp only [mem_prod, forall_and, Prod.forall] at hsA htA\n    simp only [Prod.ext_iff, fst_prod, map_map, Function.comp_apply, Prod.map_fst, snd_prod,\n      Prod.map_snd]\n    rw [← Function.comp_def, ← map_map, ← map_map, ← Function.comp_def f₂, ← map_map, ← map_map,\n      h₁.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa) (by simpa),\n      h₂.map_prod_eq_map_prod (by simpa [@forall_swap α₁] using hsA.2)\n      (by simpa [@forall_swap α₁] using htA.2) (by simpa) (by simpa)]\n\n"}
{"name":"Fin.isAddFreimanIso_Iic","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"k m n : Nat\nhm : Ne m 0\nhkmn : LE.le (HMul.hMul m k) n\n⊢ IsAddFreimanIso m (Set.Iic ↑k) (Set.Iic k) Fin.val","decl":"/-- **No wrap-around principle**.\n\nThe first `k + 1` elements of `Fin (n + 1)` are `m`-Freiman isomorphic to the first `k + 1` elements\nof `ℕ` assuming there is no wrap-around. -/\nlemma isAddFreimanIso_Iic (hm : m ≠ 0) (hkmn : m * k ≤ n) :\n    IsAddFreimanIso m (Iic (k : Fin (n + 1))) (Iic k) val where\n  bijOn.left := by simp [MapsTo, Fin.le_iff_val_le_val, Nat.mod_eq_of_lt, aux hm hkmn]\n  bijOn.right.left := val_injective.injOn\n  bijOn.right.right x (hx : x ≤ _) :=\n    ⟨x, by simpa [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, aux hm hkmn, hx.trans_lt]⟩\n  map_sum_eq_map_sum s t hsA htA hs ht := by\n    have (u : Multiset (Fin (n + 1))) : Nat.castRingHom _ (u.map val).sum = u.sum := by simp\n    rw [← this, ← this]\n    have {u : Multiset (Fin (n + 1))} (huk : ∀ x ∈ u, x ≤ k) (hu : card u = m) :\n        (u.map val).sum < (n + 1) := Nat.lt_succ_iff.2 <| hkmn.trans' <| by\n      rw [← hu, ← card_map]\n      refine sum_le_card_nsmul (u.map val) k ?_\n      simpa [le_iff_val_le_val, -val_fin_le, Nat.mod_eq_of_lt, aux hm hkmn] using huk\n    exact ⟨congr_arg _, CharP.natCast_injOn_Iio _ (n + 1) (this hsA hs) (this htA ht)⟩\n\n"}
{"name":"Fin.isAddFreimanIso_Iio","module":"Mathlib.Combinatorics.Additive.FreimanHom","initialProofState":"k m n : Nat\nhm : Ne m 0\nhkmn : LE.le (HMul.hMul m k) n\n⊢ IsAddFreimanIso m (Set.Iio ↑k) (Set.Iio k) Fin.val","decl":"/-- **No wrap-around principle**.\n\nThe first `k` elements of `Fin (n + 1)` are `m`-Freiman isomorphic to the first `k` elements of `ℕ`\nassuming there is no wrap-around. -/\nlemma isAddFreimanIso_Iio (hm : m ≠ 0) (hkmn : m * k ≤ n) :\n    IsAddFreimanIso m (Iio (k : Fin (n + 1))) (Iio k) val := by\n  obtain _ | k := k\n  · simp [← bot_eq_zero]; simp [← _root_.bot_eq_zero, -Nat.bot_eq_zero, -bot_eq_zero']\n  have hkmn' : m * k ≤ n := (Nat.mul_le_mul_left _ k.le_succ).trans hkmn\n  convert isAddFreimanIso_Iic hm hkmn' using 1 <;> ext x\n  · simp [lt_iff_val_lt_val, le_iff_val_le_val, -val_fin_le, -val_fin_lt, Nat.mod_eq_of_lt,\n      aux hm hkmn']\n    simp_rw [← Nat.cast_add_one]\n    rw [Fin.val_cast_of_lt (aux hm hkmn), Nat.lt_succ_iff]\n  · simp [Nat.lt_succ_iff]\n\n"}
