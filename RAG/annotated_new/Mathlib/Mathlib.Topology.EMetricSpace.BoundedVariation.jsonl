{"name":"eVariationOn.nonempty_monotone_mem","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nhs : s.Nonempty\n⊢ Nonempty (Subtype fun u => And (Monotone u) (∀ (i : Nat), Membership.mem s (u i)))","decl":"theorem nonempty_monotone_mem {s : Set α} (hs : s.Nonempty) :\n    Nonempty { u // Monotone u ∧ ∀ i : ℕ, u i ∈ s } := by\n  obtain ⟨x, hx⟩ := hs\n  exact ⟨⟨fun _ => x, fun i j _ => le_rfl, fun _ => hx⟩⟩\n\n"}
{"name":"eVariationOn.eq_of_edist_zero_on","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf f' : α → E\ns : Set α\nh : ∀ ⦃x : α⦄, Membership.mem s x → Eq (EDist.edist (f x) (f' x)) 0\n⊢ Eq (eVariationOn f s) (eVariationOn f' s)","decl":"theorem eq_of_edist_zero_on {f f' : α → E} {s : Set α} (h : ∀ ⦃x⦄, x ∈ s → edist (f x) (f' x) = 0) :\n    eVariationOn f s = eVariationOn f' s := by\n  dsimp only [eVariationOn]\n  congr 1 with p : 1\n  congr 1 with i : 1\n  rw [edist_congr_right (h <| p.snd.prop.2 (i + 1)), edist_congr_left (h <| p.snd.prop.2 i)]\n\n"}
{"name":"eVariationOn.eq_of_eqOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf f' : α → E\ns : Set α\nh : Set.EqOn f f' s\n⊢ Eq (eVariationOn f s) (eVariationOn f' s)","decl":"theorem eq_of_eqOn {f f' : α → E} {s : Set α} (h : EqOn f f' s) :\n    eVariationOn f s = eVariationOn f' s :=\n  eq_of_edist_zero_on fun x xs => by rw [h xs, edist_self]\n\n"}
{"name":"eVariationOn.sum_le","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nn : Nat\nu : Nat → α\nhu : Monotone u\nus : ∀ (i : Nat), Membership.mem s (u i)\n⊢ LE.le ((Finset.range n).sum fun i => EDist.edist (f (u (HAdd.hAdd i 1))) (f (u i))) (eVariationOn f s)","decl":"theorem sum_le (f : α → E) {s : Set α} (n : ℕ) {u : ℕ → α} (hu : Monotone u) (us : ∀ i, u i ∈ s) :\n    (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) ≤ eVariationOn f s :=\n  le_iSup_of_le ⟨n, u, hu, us⟩ le_rfl\n\n"}
{"name":"eVariationOn.sum_le_of_monotoneOn_Icc","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nm n : Nat\nu : Nat → α\nhu : MonotoneOn u (Set.Icc m n)\nus : ∀ (i : Nat), Membership.mem (Set.Icc m n) i → Membership.mem s (u i)\n⊢ LE.le ((Finset.Ico m n).sum fun i => EDist.edist (f (u (HAdd.hAdd i 1))) (f (u i))) (eVariationOn f s)","decl":"theorem sum_le_of_monotoneOn_Icc (f : α → E) {s : Set α} {m n : ℕ} {u : ℕ → α}\n    (hu : MonotoneOn u (Icc m n)) (us : ∀ i ∈ Icc m n, u i ∈ s) :\n    (∑ i ∈ Finset.Ico m n, edist (f (u (i + 1))) (f (u i))) ≤ eVariationOn f s := by\n  rcases le_total n m with hnm | hmn\n  · simp [Finset.Ico_eq_empty_of_le hnm]\n  let π := projIcc m n hmn\n  let v i := u (π i)\n  calc\n    ∑ i ∈ Finset.Ico m n, edist (f (u (i + 1))) (f (u i))\n        = ∑ i ∈ Finset.Ico m n, edist (f (v (i + 1))) (f (v i)) :=\n      Finset.sum_congr rfl fun i hi ↦ by\n        rw [Finset.mem_Ico] at hi\n        simp only [v, π, projIcc_of_mem hmn ⟨hi.1, hi.2.le⟩,\n          projIcc_of_mem hmn ⟨hi.1.trans i.le_succ, hi.2⟩]\n    _ ≤ ∑ i ∈ Finset.range n, edist (f (v (i + 1))) (f (v i)) :=\n      Finset.sum_mono_set _ (Nat.Iio_eq_range ▸ Finset.Ico_subset_Iio_self)\n    _ ≤ eVariationOn f s :=\n      sum_le _ _ (fun i j h ↦ hu (π i).2 (π j).2 (monotone_projIcc hmn h)) fun i ↦ us _ (π i).2\n\n"}
{"name":"eVariationOn.sum_le_of_monotoneOn_Iic","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nn : Nat\nu : Nat → α\nhu : MonotoneOn u (Set.Iic n)\nus : ∀ (i : Nat), LE.le i n → Membership.mem s (u i)\n⊢ LE.le ((Finset.range n).sum fun i => EDist.edist (f (u (HAdd.hAdd i 1))) (f (u i))) (eVariationOn f s)","decl":"theorem sum_le_of_monotoneOn_Iic (f : α → E) {s : Set α} {n : ℕ} {u : ℕ → α}\n    (hu : MonotoneOn u (Iic n)) (us : ∀ i ≤ n, u i ∈ s) :\n    (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) ≤ eVariationOn f s := by\n  simpa using sum_le_of_monotoneOn_Icc f (m := 0) (hu.mono Icc_subset_Iic_self) fun i hi ↦ us i hi.2\n\n"}
{"name":"eVariationOn.mono","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns t : Set α\nhst : HasSubset.Subset t s\n⊢ LE.le (eVariationOn f t) (eVariationOn f s)","decl":"theorem mono (f : α → E) {s t : Set α} (hst : t ⊆ s) : eVariationOn f t ≤ eVariationOn f s := by\n  apply iSup_le _\n  rintro ⟨n, ⟨u, hu, ut⟩⟩\n  exact sum_le f n hu fun i => hst (ut i)\n\n"}
{"name":"BoundedVariationOn.mono","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nh : BoundedVariationOn f s\nt : Set α\nht : HasSubset.Subset t s\n⊢ BoundedVariationOn f t","decl":"theorem _root_.BoundedVariationOn.mono {f : α → E} {s : Set α} (h : BoundedVariationOn f s)\n    {t : Set α} (ht : t ⊆ s) : BoundedVariationOn f t :=\n  ne_top_of_le_ne_top h (eVariationOn.mono f ht)\n\n"}
{"name":"BoundedVariationOn.locallyBoundedVariationOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nh : BoundedVariationOn f s\n⊢ LocallyBoundedVariationOn f s","decl":"theorem _root_.BoundedVariationOn.locallyBoundedVariationOn {f : α → E} {s : Set α}\n    (h : BoundedVariationOn f s) : LocallyBoundedVariationOn f s := fun _ _ _ _ =>\n  h.mono inter_subset_left\n\n"}
{"name":"eVariationOn.edist_le","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ LE.le (EDist.edist (f x) (f y)) (eVariationOn f s)","decl":"theorem edist_le (f : α → E) {s : Set α} {x y : α} (hx : x ∈ s) (hy : y ∈ s) :\n    edist (f x) (f y) ≤ eVariationOn f s := by\n  wlog hxy : y ≤ x generalizing x y\n  · rw [edist_comm]\n    exact this hy hx (le_of_not_le hxy)\n  let u : ℕ → α := fun n => if n = 0 then y else x\n  have hu : Monotone u := monotone_nat_of_le_succ fun\n  | 0 => hxy\n  | (_ + 1) => le_rfl\n  have us : ∀ i, u i ∈ s := fun\n  | 0 => hy\n  | (_ + 1) => hx\n  simpa only [Finset.sum_range_one] using sum_le f 1 hu us\n\n"}
{"name":"eVariationOn.eq_zero_iff","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\n⊢ Iff (Eq (eVariationOn f s) 0) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Eq (EDist.edist (f x) (f y)) 0)","decl":"theorem eq_zero_iff (f : α → E) {s : Set α} :\n    eVariationOn f s = 0 ↔ ∀ x ∈ s, ∀ y ∈ s, edist (f x) (f y) = 0 := by\n  constructor\n  · rintro h x xs y ys\n    rw [← le_zero_iff, ← h]\n    exact edist_le f xs ys\n  · rintro h\n    dsimp only [eVariationOn]\n    rw [ENNReal.iSup_eq_zero]\n    rintro ⟨n, u, um, us⟩\n    exact Finset.sum_eq_zero fun i _ => h _ (us i.succ) _ (us i)\n\n"}
{"name":"eVariationOn.constant_on","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : (Set.image f s).Subsingleton\n⊢ Eq (eVariationOn f s) 0","decl":"theorem constant_on {f : α → E} {s : Set α} (hf : (f '' s).Subsingleton) :\n    eVariationOn f s = 0 := by\n  rw [eq_zero_iff]\n  rintro x xs y ys\n  rw [hf ⟨x, xs, rfl⟩ ⟨y, ys, rfl⟩, edist_self]\n\n"}
{"name":"eVariationOn.subsingleton","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhs : s.Subsingleton\n⊢ Eq (eVariationOn f s) 0","decl":"@[simp]\nprotected theorem subsingleton (f : α → E) {s : Set α} (hs : s.Subsingleton) :\n    eVariationOn f s = 0 :=\n  constant_on (hs.image f)\n\n"}
{"name":"eVariationOn.lowerSemicontinuous_aux","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nι : Type u_3\nF : ι → α → E\np : Filter ι\nf : α → E\ns : Set α\nFfs : ∀ (x : α), Membership.mem s x → Filter.Tendsto (fun i => F i x) p (nhds (f x))\nv : ENNReal\nhv : LT.lt v (eVariationOn f s)\n⊢ Filter.Eventually (fun n => LT.lt v (eVariationOn (F n) s)) p","decl":"theorem lowerSemicontinuous_aux {ι : Type*} {F : ι → α → E} {p : Filter ι} {f : α → E} {s : Set α}\n    (Ffs : ∀ x ∈ s, Tendsto (fun i => F i x) p (𝓝 (f x))) {v : ℝ≥0∞} (hv : v < eVariationOn f s) :\n    ∀ᶠ n : ι in p, v < eVariationOn (F n) s := by\n  obtain ⟨⟨n, ⟨u, um, us⟩⟩, hlt⟩ :\n    ∃ p : ℕ × { u : ℕ → α // Monotone u ∧ ∀ i, u i ∈ s },\n      v < ∑ i ∈ Finset.range p.1, edist (f ((p.2 : ℕ → α) (i + 1))) (f ((p.2 : ℕ → α) i)) :=\n    lt_iSup_iff.mp hv\n  have : Tendsto (fun j => ∑ i ∈ Finset.range n, edist (F j (u (i + 1))) (F j (u i))) p\n      (𝓝 (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i)))) := by\n    apply tendsto_finset_sum\n    exact fun i _ => Tendsto.edist (Ffs (u i.succ) (us i.succ)) (Ffs (u i) (us i))\n  exact (this.eventually_const_lt hlt).mono fun i h => h.trans_le (sum_le (F i) n um us)\n\n"}
{"name":"eVariationOn.lowerSemicontinuous","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\ns : Set α\n⊢ LowerSemicontinuous fun f => eVariationOn f s","decl":"/-- The map `(eVariationOn · s)` is lower semicontinuous for pointwise convergence *on `s`*.\nPointwise convergence on `s` is encoded here as uniform convergence on the family consisting of the\nsingletons of elements of `s`.\n-/\nprotected theorem lowerSemicontinuous (s : Set α) :\n    LowerSemicontinuous fun f : α →ᵤ[s.image singleton] E => eVariationOn f s := fun f ↦ by\n  apply @lowerSemicontinuous_aux _ _ _ _ (UniformOnFun α E (s.image singleton)) id (𝓝 f) f s _\n  simpa only [UniformOnFun.tendsto_iff_tendstoUniformlyOn, mem_image, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff₂, tendstoUniformlyOn_singleton_iff_tendsto] using @tendsto_id _ (𝓝 f)\n\n"}
{"name":"eVariationOn.lowerSemicontinuous_uniformOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\ns : Set α\n⊢ LowerSemicontinuous fun f => eVariationOn f s","decl":"/-- The map `(eVariationOn · s)` is lower semicontinuous for uniform convergence on `s`. -/\ntheorem lowerSemicontinuous_uniformOn (s : Set α) :\n    LowerSemicontinuous fun f : α →ᵤ[{s}] E => eVariationOn f s := fun f ↦ by\n  apply @lowerSemicontinuous_aux _ _ _ _ (UniformOnFun α E {s}) id (𝓝 f) f s _\n  have := @tendsto_id _ (𝓝 f)\n  rw [UniformOnFun.tendsto_iff_tendstoUniformlyOn] at this\n  simp_rw [← tendstoUniformlyOn_singleton_iff_tendsto]\n  exact fun x xs => (this s rfl).mono (singleton_subset_iff.mpr xs)\n\n"}
{"name":"BoundedVariationOn.dist_le","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_3\ninst✝ : PseudoMetricSpace E\nf : α → E\ns : Set α\nh : BoundedVariationOn f s\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ LE.le (Dist.dist (f x) (f y)) (eVariationOn f s).toReal","decl":"theorem _root_.BoundedVariationOn.dist_le {E : Type*} [PseudoMetricSpace E] {f : α → E}\n    {s : Set α} (h : BoundedVariationOn f s) {x y : α} (hx : x ∈ s) (hy : y ∈ s) :\n    dist (f x) (f y) ≤ (eVariationOn f s).toReal := by\n  rw [← ENNReal.ofReal_le_ofReal_iff ENNReal.toReal_nonneg, ENNReal.ofReal_toReal h, ← edist_dist]\n  exact edist_le f hx hy\n\n"}
{"name":"BoundedVariationOn.sub_le","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf : α → Real\ns : Set α\nh : BoundedVariationOn f s\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ LE.le (HSub.hSub (f x) (f y)) (eVariationOn f s).toReal","decl":"theorem _root_.BoundedVariationOn.sub_le {f : α → ℝ} {s : Set α} (h : BoundedVariationOn f s)\n    {x y : α} (hx : x ∈ s) (hy : y ∈ s) : f x - f y ≤ (eVariationOn f s).toReal := by\n  apply (le_abs_self _).trans\n  rw [← Real.dist_eq]\n  exact h.dist_le hx hy\n\n"}
{"name":"eVariationOn.add_point","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nx : α\nhx : Membership.mem s x\nu : Nat → α\nhu : Monotone u\nus : ∀ (i : Nat), Membership.mem s (u i)\nn : Nat\n⊢ Exists fun v => Exists fun m => And (Monotone v) (And (∀ (i : Nat), Membership.mem s (v i)) (And (Membership.mem (Set.image v (Set.Iio m)) x) (LE.le ((Finset.range n).sum fun i => EDist.edist (f (u (HAdd.hAdd i 1))) (f (u i))) ((Finset.range m).sum fun j => EDist.edist (f (v (HAdd.hAdd j 1))) (f (v j))))))","decl":"/-- Consider a monotone function `u` parameterizing some points of a set `s`. Given `x ∈ s`, then\none can find another monotone function `v` parameterizing the same points as `u`, with `x` added.\nIn particular, the variation of a function along `u` is bounded by its variation along `v`. -/\ntheorem add_point (f : α → E) {s : Set α} {x : α} (hx : x ∈ s) (u : ℕ → α) (hu : Monotone u)\n    (us : ∀ i, u i ∈ s) (n : ℕ) :\n    ∃ (v : ℕ → α) (m : ℕ), Monotone v ∧ (∀ i, v i ∈ s) ∧ x ∈ v '' Iio m ∧\n      (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) ≤\n        ∑ j ∈ Finset.range m, edist (f (v (j + 1))) (f (v j)) := by\n  rcases le_or_lt (u n) x with (h | h)\n  · let v i := if i ≤ n then u i else x\n    have vs : ∀ i, v i ∈ s := fun i ↦ by\n      simp only [v]\n      split_ifs\n      · exact us i\n      · exact hx\n    have hv : Monotone v := by\n      refine monotone_nat_of_le_succ fun i => ?_\n      simp only [v]\n      rcases lt_trichotomy i n with (hi | rfl | hi)\n      · have : i + 1 ≤ n := Nat.succ_le_of_lt hi\n        simp only [hi.le, this, if_true]\n        exact hu (Nat.le_succ i)\n      · simp only [le_refl, if_true, add_le_iff_nonpos_right, Nat.le_zero, Nat.one_ne_zero,\n          if_false, h]\n      · have A : ¬i ≤ n := hi.not_le\n        have B : ¬i + 1 ≤ n := fun h => A (i.le_succ.trans h)\n        simp only [A, B, if_false, le_rfl]\n    refine ⟨v, n + 2, hv, vs, (mem_image _ _ _).2 ⟨n + 1, ?_, ?_⟩, ?_⟩\n    · rw [mem_Iio]; exact Nat.lt_succ_self (n + 1)\n    · have : ¬n + 1 ≤ n := Nat.not_succ_le_self n\n      simp only [v, this, ite_eq_right_iff, IsEmpty.forall_iff]\n    · calc\n        (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) =\n            ∑ i ∈ Finset.range n, edist (f (v (i + 1))) (f (v i)) := by\n          apply Finset.sum_congr rfl fun i hi => ?_\n          simp only [Finset.mem_range] at hi\n          have : i + 1 ≤ n := Nat.succ_le_of_lt hi\n          simp only [v, hi.le, this, if_true]\n        _ ≤ ∑ j ∈ Finset.range (n + 2), edist (f (v (j + 1))) (f (v j)) :=\n          Finset.sum_le_sum_of_subset (Finset.range_mono (Nat.le_add_right n 2))\n  have exists_N : ∃ N, N ≤ n ∧ x < u N := ⟨n, le_rfl, h⟩\n  let N := Nat.find exists_N\n  have hN : N ≤ n ∧ x < u N := Nat.find_spec exists_N\n  let w : ℕ → α := fun i => if i < N then u i else if i = N then x else u (i - 1)\n  have ws : ∀ i, w i ∈ s := by\n    dsimp only [w]\n    intro i\n    split_ifs\n    exacts [us _, hx, us _]\n  have hw : Monotone w := by\n    apply monotone_nat_of_le_succ fun i => ?_\n    dsimp only [w]\n    rcases lt_trichotomy (i + 1) N with (hi | hi | hi)\n    · have : i < N := Nat.lt_of_le_of_lt (Nat.le_succ i) hi\n      simp only [hi, this, if_true]\n      exact hu (Nat.le_succ _)\n    · have A : i < N := hi ▸ i.lt_succ_self\n      have B : ¬i + 1 < N := by rw [← hi]; exact fun h => h.ne rfl\n      rw [if_pos A, if_neg B, if_pos hi]\n      have T := Nat.find_min exists_N A\n      push_neg at T\n      exact T (A.le.trans hN.1)\n    · have A : ¬i < N := (Nat.lt_succ_iff.mp hi).not_lt\n      have B : ¬i + 1 < N := hi.not_lt\n      have C : ¬i + 1 = N := hi.ne.symm\n      have D : i + 1 - 1 = i := Nat.pred_succ i\n      rw [if_neg A, if_neg B, if_neg C, D]\n      split_ifs\n      · exact hN.2.le.trans (hu (le_of_not_lt A))\n      · exact hu (Nat.pred_le _)\n  refine ⟨w, n + 1, hw, ws, (mem_image _ _ _).2 ⟨N, hN.1.trans_lt (Nat.lt_succ_self n), ?_⟩, ?_⟩\n  · dsimp only [w]; rw [if_neg (lt_irrefl N), if_pos rfl]\n  rcases eq_or_lt_of_le (zero_le N) with (Npos | Npos)\n  · calc\n      (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) =\n          ∑ i ∈ Finset.range n, edist (f (w (1 + i + 1))) (f (w (1 + i))) := by\n        apply Finset.sum_congr rfl fun i _hi => ?_\n        dsimp only [w]\n        simp only [← Npos, Nat.not_lt_zero, Nat.add_succ_sub_one, add_zero, if_false,\n          add_eq_zero, Nat.one_ne_zero, false_and, Nat.succ_add_sub_one, zero_add]\n        rw [add_comm 1 i]\n      _ = ∑ i ∈ Finset.Ico 1 (n + 1), edist (f (w (i + 1))) (f (w i)) := by\n        rw [Finset.range_eq_Ico]\n        exact Finset.sum_Ico_add (fun i => edist (f (w (i + 1))) (f (w i))) 0 n 1\n      _ ≤ ∑ j ∈ Finset.range (n + 1), edist (f (w (j + 1))) (f (w j)) := by\n        apply Finset.sum_le_sum_of_subset _\n        rw [Finset.range_eq_Ico]\n        exact Finset.Ico_subset_Ico zero_le_one le_rfl\n  · calc\n      (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) =\n          ((∑ i ∈ Finset.Ico 0 (N - 1), edist (f (u (i + 1))) (f (u i))) +\n              ∑ i ∈ Finset.Ico (N - 1) N, edist (f (u (i + 1))) (f (u i))) +\n            ∑ i ∈ Finset.Ico N n, edist (f (u (i + 1))) (f (u i)) := by\n        rw [Finset.sum_Ico_consecutive, Finset.sum_Ico_consecutive, Finset.range_eq_Ico]\n        · exact zero_le _\n        · exact hN.1\n        · exact zero_le _\n        · exact Nat.pred_le _\n      _ = (∑ i ∈ Finset.Ico 0 (N - 1), edist (f (w (i + 1))) (f (w i))) +\n              edist (f (u N)) (f (u (N - 1))) +\n            ∑ i ∈ Finset.Ico N n, edist (f (w (1 + i + 1))) (f (w (1 + i))) := by\n        congr 1\n        · congr 1\n          · apply Finset.sum_congr rfl fun i hi => ?_\n            simp only [Finset.mem_Ico, zero_le', true_and] at hi\n            dsimp only [w]\n            have A : i + 1 < N := Nat.lt_pred_iff.1 hi\n            have B : i < N := Nat.lt_of_succ_lt A\n            rw [if_pos A, if_pos B]\n          · have A : N - 1 + 1 = N := Nat.succ_pred_eq_of_pos Npos\n            have : Finset.Ico (N - 1) N = {N - 1} := by rw [← Nat.Ico_succ_singleton, A]\n            simp only [this, A, Finset.sum_singleton]\n        · apply Finset.sum_congr rfl fun i hi => ?_\n          rw [Finset.mem_Ico] at hi\n          dsimp only [w]\n          have A : ¬1 + i + 1 < N := by omega\n          have B : ¬1 + i + 1 = N := by omega\n          have C : ¬1 + i < N := by omega\n          have D : ¬1 + i = N := by omega\n          rw [if_neg A, if_neg B, if_neg C, if_neg D]\n          congr 3 <;> · rw [add_comm, Nat.sub_one]; apply Nat.pred_succ\n      _ = (∑ i ∈ Finset.Ico 0 (N - 1), edist (f (w (i + 1))) (f (w i))) +\n              edist (f (w (N + 1))) (f (w (N - 1))) +\n            ∑ i ∈ Finset.Ico (N + 1) (n + 1), edist (f (w (i + 1))) (f (w i)) := by\n        congr 1\n        · congr 1\n          · dsimp only [w]\n            have A : ¬N + 1 < N := Nat.not_succ_lt_self\n            have B : N - 1 < N := Nat.pred_lt Npos.ne'\n            simp only [A, not_and, not_lt, Nat.succ_ne_self, Nat.add_succ_sub_one, add_zero,\n              if_false, B, if_true]\n        · exact Finset.sum_Ico_add (fun i => edist (f (w (i + 1))) (f (w i))) N n 1\n      _ ≤ ((∑ i ∈ Finset.Ico 0 (N - 1), edist (f (w (i + 1))) (f (w i))) +\n              ∑ i ∈ Finset.Ico (N - 1) (N + 1), edist (f (w (i + 1))) (f (w i))) +\n            ∑ i ∈ Finset.Ico (N + 1) (n + 1), edist (f (w (i + 1))) (f (w i)) := by\n        refine add_le_add (add_le_add le_rfl ?_) le_rfl\n        have A : N - 1 + 1 = N := Nat.succ_pred_eq_of_pos Npos\n        have B : N - 1 + 1 < N + 1 := A.symm ▸ N.lt_succ_self\n        have C : N - 1 < N + 1 := lt_of_le_of_lt N.pred_le N.lt_succ_self\n        rw [Finset.sum_eq_sum_Ico_succ_bot C, Finset.sum_eq_sum_Ico_succ_bot B, A, Finset.Ico_self,\n          Finset.sum_empty, add_zero, add_comm (edist _ _)]\n        exact edist_triangle _ _ _\n      _ = ∑ j ∈ Finset.range (n + 1), edist (f (w (j + 1))) (f (w j)) := by\n        rw [Finset.sum_Ico_consecutive, Finset.sum_Ico_consecutive, Finset.range_eq_Ico]\n        · exact zero_le _\n        · exact Nat.succ_le_succ hN.left\n        · exact zero_le _\n        · exact N.pred_le.trans N.le_succ\n\n"}
{"name":"eVariationOn.add_le_union","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns t : Set α\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LE.le x y\n⊢ LE.le (HAdd.hAdd (eVariationOn f s) (eVariationOn f t)) (eVariationOn f (Union.union s t))","decl":"/-- The variation of a function on the union of two sets `s` and `t`, with `s` to the left of `t`,\nbounds the sum of the variations along `s` and `t`. -/\ntheorem add_le_union (f : α → E) {s t : Set α} (h : ∀ x ∈ s, ∀ y ∈ t, x ≤ y) :\n    eVariationOn f s + eVariationOn f t ≤ eVariationOn f (s ∪ t) := by\n  by_cases hs : s = ∅\n  · simp [hs]\n  have : Nonempty { u // Monotone u ∧ ∀ i : ℕ, u i ∈ s } :=\n    nonempty_monotone_mem (nonempty_iff_ne_empty.2 hs)\n  by_cases ht : t = ∅\n  · simp [ht]\n  have : Nonempty { u // Monotone u ∧ ∀ i : ℕ, u i ∈ t } :=\n    nonempty_monotone_mem (nonempty_iff_ne_empty.2 ht)\n  refine ENNReal.iSup_add_iSup_le ?_\n  /- We start from two sequences `u` and `v` along `s` and `t` respectively, and we build a new\n    sequence `w` along `s ∪ t` by juxtaposing them. Its variation is larger than the sum of the\n    variations. -/\n  rintro ⟨n, ⟨u, hu, us⟩⟩ ⟨m, ⟨v, hv, vt⟩⟩\n  let w i := if i ≤ n then u i else v (i - (n + 1))\n  have wst : ∀ i, w i ∈ s ∪ t := by\n    intro i\n    by_cases hi : i ≤ n\n    · simp [w, hi, us]\n    · simp [w, hi, vt]\n  have hw : Monotone w := by\n    intro i j hij\n    dsimp only [w]\n    split_ifs with h_1 h_2 h_2\n    · exact hu hij\n    · apply h _ (us _) _ (vt _)\n    · exfalso; exact h_1 (hij.trans h_2)\n    · apply hv (tsub_le_tsub hij le_rfl)\n  calc\n    ((∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) +\n          ∑ i ∈ Finset.range m, edist (f (v (i + 1))) (f (v i))) =\n        (∑ i ∈ Finset.range n, edist (f (w (i + 1))) (f (w i))) +\n          ∑ i ∈ Finset.range m, edist (f (w (n + 1 + i + 1))) (f (w (n + 1 + i))) := by\n      dsimp only [w]\n      congr 1\n      · refine Finset.sum_congr rfl fun i hi => ?_\n        simp only [Finset.mem_range] at hi\n        have : i + 1 ≤ n := Nat.succ_le_of_lt hi\n        simp [hi.le, this]\n      · refine Finset.sum_congr rfl fun i hi => ?_\n        simp only [Finset.mem_range] at hi\n        have B : ¬n + 1 + i ≤ n := by omega\n        have A : ¬n + 1 + i + 1 ≤ n := fun h => B ((n + 1 + i).le_succ.trans h)\n        have C : n + 1 + i - n = i + 1 := by\n          rw [tsub_eq_iff_eq_add_of_le]\n          · abel\n          · exact n.le_succ.trans (n.succ.le_add_right i)\n        simp only [A, B, C, Nat.succ_sub_succ_eq_sub, if_false, add_tsub_cancel_left]\n    _ = (∑ i ∈ Finset.range n, edist (f (w (i + 1))) (f (w i))) +\n          ∑ i ∈ Finset.Ico (n + 1) (n + 1 + m), edist (f (w (i + 1))) (f (w i)) := by\n      congr 1\n      rw [Finset.range_eq_Ico]\n      convert Finset.sum_Ico_add (fun i : ℕ => edist (f (w (i + 1))) (f (w i))) 0 m (n + 1)\n        using 3 <;> abel\n    _ ≤ ∑ i ∈ Finset.range (n + 1 + m), edist (f (w (i + 1))) (f (w i)) := by\n      rw [← Finset.sum_union]\n      · apply Finset.sum_le_sum_of_subset _\n        rintro i hi\n        simp only [Finset.mem_union, Finset.mem_range, Finset.mem_Ico] at hi ⊢\n        cases' hi with hi hi\n        · exact lt_of_lt_of_le hi (n.le_succ.trans (n.succ.le_add_right m))\n        · exact hi.2\n      · refine Finset.disjoint_left.2 fun i hi h'i => ?_\n        simp only [Finset.mem_Ico, Finset.mem_range] at hi h'i\n        exact hi.not_lt (Nat.lt_of_succ_le h'i.left)\n    _ ≤ eVariationOn f (s ∪ t) := sum_le f _ hw wst\n\n"}
{"name":"eVariationOn.union","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns t : Set α\nx : α\nhs : IsGreatest s x\nht : IsLeast t x\n⊢ Eq (eVariationOn f (Union.union s t)) (HAdd.hAdd (eVariationOn f s) (eVariationOn f t))","decl":"/-- If a set `s` is to the left of a set `t`, and both contain the boundary point `x`, then\nthe variation of `f` along `s ∪ t` is the sum of the variations. -/\ntheorem union (f : α → E) {s t : Set α} {x : α} (hs : IsGreatest s x) (ht : IsLeast t x) :\n    eVariationOn f (s ∪ t) = eVariationOn f s + eVariationOn f t := by\n  classical\n  apply le_antisymm _ (eVariationOn.add_le_union f fun a ha b hb => le_trans (hs.2 ha) (ht.2 hb))\n  apply iSup_le _\n  rintro ⟨n, ⟨u, hu, ust⟩⟩\n  obtain ⟨v, m, hv, vst, xv, huv⟩ : ∃ (v : ℕ → α) (m : ℕ),\n    Monotone v ∧ (∀ i, v i ∈ s ∪ t) ∧ x ∈ v '' Iio m ∧\n      (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) ≤\n        ∑ j ∈ Finset.range m, edist (f (v (j + 1))) (f (v j)) :=\n    eVariationOn.add_point f (mem_union_left t hs.1) u hu ust n\n  obtain ⟨N, hN, Nx⟩ : ∃ N, N < m ∧ v N = x := xv\n  calc\n    (∑ j ∈ Finset.range n, edist (f (u (j + 1))) (f (u j))) ≤\n        ∑ j ∈ Finset.range m, edist (f (v (j + 1))) (f (v j)) :=\n      huv\n    _ = (∑ j ∈ Finset.Ico 0 N, edist (f (v (j + 1))) (f (v j))) +\n          ∑ j ∈ Finset.Ico N m, edist (f (v (j + 1))) (f (v j)) := by\n      rw [Finset.range_eq_Ico, Finset.sum_Ico_consecutive _ (zero_le _) hN.le]\n    _ ≤ eVariationOn f s + eVariationOn f t := by\n      refine add_le_add ?_ ?_\n      · apply sum_le_of_monotoneOn_Icc _ (hv.monotoneOn _) fun i hi => ?_\n        rcases vst i with (h | h); · exact h\n        have : v i = x := by\n          apply le_antisymm\n          · rw [← Nx]; exact hv hi.2\n          · exact ht.2 h\n        rw [this]\n        exact hs.1\n      · apply sum_le_of_monotoneOn_Icc _ (hv.monotoneOn _) fun i hi => ?_\n        rcases vst i with (h | h); swap; · exact h\n        have : v i = x := by\n          apply le_antisymm\n          · exact hs.2 h\n          · rw [← Nx]; exact hv hi.1\n        rw [this]\n        exact ht.1\n\n"}
{"name":"eVariationOn.Icc_add_Icc","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\na b c : α\nhab : LE.le a b\nhbc : LE.le b c\nhb : Membership.mem s b\n⊢ Eq (HAdd.hAdd (eVariationOn f (Inter.inter s (Set.Icc a b))) (eVariationOn f (Inter.inter s (Set.Icc b c)))) (eVariationOn f (Inter.inter s (Set.Icc a c)))","decl":"theorem Icc_add_Icc (f : α → E) {s : Set α} {a b c : α} (hab : a ≤ b) (hbc : b ≤ c) (hb : b ∈ s) :\n    eVariationOn f (s ∩ Icc a b) + eVariationOn f (s ∩ Icc b c) = eVariationOn f (s ∩ Icc a c) := by\n  have A : IsGreatest (s ∩ Icc a b) b :=\n    ⟨⟨hb, hab, le_rfl⟩, inter_subset_right.trans Icc_subset_Iic_self⟩\n  have B : IsLeast (s ∩ Icc b c) b :=\n    ⟨⟨hb, le_rfl, hbc⟩, inter_subset_right.trans Icc_subset_Ici_self⟩\n  rw [← eVariationOn.union f A B, ← inter_union_distrib_left, Icc_union_Icc_eq_Icc hab hbc]\n\n"}
{"name":"eVariationOn.comp_le_of_monotoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nβ : Type u_3\ninst✝ : LinearOrder β\nf : α → E\ns : Set α\nt : Set β\nφ : β → α\nhφ : MonotoneOn φ t\nφst : Set.MapsTo φ t s\n⊢ LE.le (eVariationOn (Function.comp f φ) t) (eVariationOn f s)","decl":"theorem comp_le_of_monotoneOn (f : α → E) {s : Set α} {t : Set β} (φ : β → α) (hφ : MonotoneOn φ t)\n    (φst : MapsTo φ t s) : eVariationOn (f ∘ φ) t ≤ eVariationOn f s :=\n  iSup_le fun ⟨n, u, hu, ut⟩ =>\n    le_iSup_of_le ⟨n, φ ∘ u, fun x y xy => hφ (ut x) (ut y) (hu xy), fun i => φst (ut i)⟩ le_rfl\n\n"}
{"name":"eVariationOn.comp_le_of_antitoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nβ : Type u_3\ninst✝ : LinearOrder β\nf : α → E\ns : Set α\nt : Set β\nφ : β → α\nhφ : AntitoneOn φ t\nφst : Set.MapsTo φ t s\n⊢ LE.le (eVariationOn (Function.comp f φ) t) (eVariationOn f s)","decl":"theorem comp_le_of_antitoneOn (f : α → E) {s : Set α} {t : Set β} (φ : β → α) (hφ : AntitoneOn φ t)\n    (φst : MapsTo φ t s) : eVariationOn (f ∘ φ) t ≤ eVariationOn f s := by\n  refine iSup_le ?_\n  rintro ⟨n, u, hu, ut⟩\n  rw [← Finset.sum_range_reflect]\n  refine (Finset.sum_congr rfl fun x hx => ?_).trans_le <| le_iSup_of_le\n    ⟨n, fun i => φ (u <| n - i), fun x y xy => hφ (ut _) (ut _) (hu <| Nat.sub_le_sub_left xy n),\n      fun i => φst (ut _)⟩\n    le_rfl\n  rw [Finset.mem_range] at hx\n  dsimp only [Subtype.coe_mk, Function.comp_apply]\n  rw [edist_comm]\n  congr 4 <;> omega\n\n"}
{"name":"eVariationOn.comp_eq_of_monotoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nβ : Type u_3\ninst✝ : LinearOrder β\nf : α → E\nt : Set β\nφ : β → α\nhφ : MonotoneOn φ t\n⊢ Eq (eVariationOn (Function.comp f φ) t) (eVariationOn f (Set.image φ t))","decl":"theorem comp_eq_of_monotoneOn (f : α → E) {t : Set β} (φ : β → α) (hφ : MonotoneOn φ t) :\n    eVariationOn (f ∘ φ) t = eVariationOn f (φ '' t) := by\n  apply le_antisymm (comp_le_of_monotoneOn f φ hφ (mapsTo_image φ t))\n  cases isEmpty_or_nonempty β\n  · convert zero_le (_ : ℝ≥0∞)\n    exact eVariationOn.subsingleton f <|\n      (subsingleton_of_subsingleton.image _).anti (surjOn_image φ t)\n  let ψ := φ.invFunOn t\n  have ψφs : EqOn (φ ∘ ψ) id (φ '' t) := (surjOn_image φ t).rightInvOn_invFunOn\n  have ψts : MapsTo ψ (φ '' t) t := (surjOn_image φ t).mapsTo_invFunOn\n  have hψ : MonotoneOn ψ (φ '' t) := Function.monotoneOn_of_rightInvOn_of_mapsTo hφ ψφs ψts\n  change eVariationOn (f ∘ id) (φ '' t) ≤ eVariationOn (f ∘ φ) t\n  rw [← eq_of_eqOn (ψφs.comp_left : EqOn (f ∘ φ ∘ ψ) (f ∘ id) (φ '' t))]\n  exact comp_le_of_monotoneOn _ ψ hψ ψts\n\n"}
{"name":"eVariationOn.comp_inter_Icc_eq_of_monotoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nβ : Type u_3\ninst✝ : LinearOrder β\nf : α → E\nt : Set β\nφ : β → α\nhφ : MonotoneOn φ t\nx y : β\nhx : Membership.mem t x\nhy : Membership.mem t y\n⊢ Eq (eVariationOn (Function.comp f φ) (Inter.inter t (Set.Icc x y))) (eVariationOn f (Inter.inter (Set.image φ t) (Set.Icc (φ x) (φ y))))","decl":"theorem comp_inter_Icc_eq_of_monotoneOn (f : α → E) {t : Set β} (φ : β → α) (hφ : MonotoneOn φ t)\n    {x y : β} (hx : x ∈ t) (hy : y ∈ t) :\n    eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' t ∩ Icc (φ x) (φ y)) := by\n  rcases le_total x y with (h | h)\n  · convert comp_eq_of_monotoneOn f φ (hφ.mono Set.inter_subset_left)\n    apply le_antisymm\n    · rintro _ ⟨⟨u, us, rfl⟩, vφx, vφy⟩\n      rcases le_total x u with (xu | ux)\n      · rcases le_total u y with (uy | yu)\n        · exact ⟨u, ⟨us, ⟨xu, uy⟩⟩, rfl⟩\n        · rw [le_antisymm vφy (hφ hy us yu)]\n          exact ⟨y, ⟨hy, ⟨h, le_rfl⟩⟩, rfl⟩\n      · rw [← le_antisymm vφx (hφ us hx ux)]\n        exact ⟨x, ⟨hx, ⟨le_rfl, h⟩⟩, rfl⟩\n    · rintro _ ⟨u, ⟨⟨hu, xu, uy⟩, rfl⟩⟩\n      exact ⟨⟨u, hu, rfl⟩, ⟨hφ hx hu xu, hφ hu hy uy⟩⟩\n  · rw [eVariationOn.subsingleton, eVariationOn.subsingleton]\n    exacts [(Set.subsingleton_Icc_of_ge (hφ hy hx h)).anti Set.inter_subset_right,\n      (Set.subsingleton_Icc_of_ge h).anti Set.inter_subset_right]\n\n"}
{"name":"eVariationOn.comp_eq_of_antitoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nβ : Type u_3\ninst✝ : LinearOrder β\nf : α → E\nt : Set β\nφ : β → α\nhφ : AntitoneOn φ t\n⊢ Eq (eVariationOn (Function.comp f φ) t) (eVariationOn f (Set.image φ t))","decl":"theorem comp_eq_of_antitoneOn (f : α → E) {t : Set β} (φ : β → α) (hφ : AntitoneOn φ t) :\n    eVariationOn (f ∘ φ) t = eVariationOn f (φ '' t) := by\n  apply le_antisymm (comp_le_of_antitoneOn f φ hφ (mapsTo_image φ t))\n  cases isEmpty_or_nonempty β\n  · convert zero_le (_ : ℝ≥0∞)\n    exact eVariationOn.subsingleton f <| (subsingleton_of_subsingleton.image _).anti\n      (surjOn_image φ t)\n  let ψ := φ.invFunOn t\n  have ψφs : EqOn (φ ∘ ψ) id (φ '' t) := (surjOn_image φ t).rightInvOn_invFunOn\n  have ψts := (surjOn_image φ t).mapsTo_invFunOn\n  have hψ : AntitoneOn ψ (φ '' t) := Function.antitoneOn_of_rightInvOn_of_mapsTo hφ ψφs ψts\n  change eVariationOn (f ∘ id) (φ '' t) ≤ eVariationOn (f ∘ φ) t\n  rw [← eq_of_eqOn (ψφs.comp_left : EqOn (f ∘ φ ∘ ψ) (f ∘ id) (φ '' t))]\n  exact comp_le_of_antitoneOn _ ψ hψ ψts\n\n"}
{"name":"eVariationOn.comp_ofDual","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\n⊢ Eq (eVariationOn (Function.comp f ⇑OrderDual.ofDual) (Set.preimage (⇑OrderDual.ofDual) s)) (eVariationOn f s)","decl":"theorem comp_ofDual (f : α → E) (s : Set α) :\n    eVariationOn (f ∘ ofDual) (ofDual ⁻¹' s) = eVariationOn f s := by\n  convert comp_eq_of_antitoneOn f ofDual fun _ _ _ _ => id\n  simp only [Equiv.image_preimage]\n\n"}
{"name":"MonotoneOn.eVariationOn_le","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf : α → Real\ns : Set α\nhf : MonotoneOn f s\na b : α\nas : Membership.mem s a\nbs : Membership.mem s b\n⊢ LE.le (eVariationOn f (Inter.inter s (Set.Icc a b))) (ENNReal.ofReal (HSub.hSub (f b) (f a)))","decl":"theorem MonotoneOn.eVariationOn_le {f : α → ℝ} {s : Set α} (hf : MonotoneOn f s) {a b : α}\n    (as : a ∈ s) (bs : b ∈ s) : eVariationOn f (s ∩ Icc a b) ≤ ENNReal.ofReal (f b - f a) := by\n  apply iSup_le _\n  rintro ⟨n, ⟨u, hu, us⟩⟩\n  calc\n    (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) =\n        ∑ i ∈ Finset.range n, ENNReal.ofReal (f (u (i + 1)) - f (u i)) := by\n      refine Finset.sum_congr rfl fun i hi => ?_\n      simp only [Finset.mem_range] at hi\n      rw [edist_dist, Real.dist_eq, abs_of_nonneg]\n      exact sub_nonneg_of_le (hf (us i).1 (us (i + 1)).1 (hu (Nat.le_succ _)))\n    _ = ENNReal.ofReal (∑ i ∈ Finset.range n, (f (u (i + 1)) - f (u i))) := by\n      rw [ENNReal.ofReal_sum_of_nonneg]\n      intro i _\n      exact sub_nonneg_of_le (hf (us i).1 (us (i + 1)).1 (hu (Nat.le_succ _)))\n    _ = ENNReal.ofReal (f (u n) - f (u 0)) := by rw [Finset.sum_range_sub fun i => f (u i)]\n    _ ≤ ENNReal.ofReal (f b - f a) := by\n      apply ENNReal.ofReal_le_ofReal\n      exact sub_le_sub (hf (us n).1 bs (us n).2.2) (hf as (us 0).1 (us 0).2.1)\n\n"}
{"name":"MonotoneOn.locallyBoundedVariationOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf : α → Real\ns : Set α\nhf : MonotoneOn f s\n⊢ LocallyBoundedVariationOn f s","decl":"theorem MonotoneOn.locallyBoundedVariationOn {f : α → ℝ} {s : Set α} (hf : MonotoneOn f s) :\n    LocallyBoundedVariationOn f s := fun _ _ as bs =>\n  ((hf.eVariationOn_le as bs).trans_lt ENNReal.ofReal_lt_top).ne\n\n"}
{"name":"variationOnFromTo.self","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\na : α\n⊢ Eq (variationOnFromTo f s a a) 0","decl":"protected theorem self (a : α) : variationOnFromTo f s a a = 0 := by\n  dsimp only [variationOnFromTo]\n  rw [if_pos le_rfl, Icc_self, eVariationOn.subsingleton, ENNReal.zero_toReal]\n  exact fun x hx y hy => hx.2.trans hy.2.symm\n\n"}
{"name":"variationOnFromTo.nonneg_of_le","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\na b : α\nh : LE.le a b\n⊢ LE.le 0 (variationOnFromTo f s a b)","decl":"protected theorem nonneg_of_le {a b : α} (h : a ≤ b) : 0 ≤ variationOnFromTo f s a b := by\n  simp only [variationOnFromTo, if_pos h, ENNReal.toReal_nonneg]\n\n"}
{"name":"variationOnFromTo.eq_neg_swap","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\na b : α\n⊢ Eq (variationOnFromTo f s a b) (Neg.neg (variationOnFromTo f s b a))","decl":"protected theorem eq_neg_swap (a b : α) :\n    variationOnFromTo f s a b = -variationOnFromTo f s b a := by\n  rcases lt_trichotomy a b with (ab | rfl | ba)\n  · simp only [variationOnFromTo, if_pos ab.le, if_neg ab.not_le, neg_neg]\n  · simp only [variationOnFromTo.self, neg_zero]\n  · simp only [variationOnFromTo, if_pos ba.le, if_neg ba.not_le, neg_neg]\n\n"}
{"name":"variationOnFromTo.nonpos_of_ge","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\na b : α\nh : LE.le b a\n⊢ LE.le (variationOnFromTo f s a b) 0","decl":"protected theorem nonpos_of_ge {a b : α} (h : b ≤ a) : variationOnFromTo f s a b ≤ 0 := by\n  rw [variationOnFromTo.eq_neg_swap]\n  exact neg_nonpos_of_nonneg (variationOnFromTo.nonneg_of_le f s h)\n\n"}
{"name":"variationOnFromTo.eq_of_le","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\na b : α\nh : LE.le a b\n⊢ Eq (variationOnFromTo f s a b) (eVariationOn f (Inter.inter s (Set.Icc a b))).toReal","decl":"protected theorem eq_of_le {a b : α} (h : a ≤ b) :\n    variationOnFromTo f s a b = (eVariationOn f (s ∩ Icc a b)).toReal :=\n  if_pos h\n\n"}
{"name":"variationOnFromTo.eq_of_ge","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\na b : α\nh : LE.le b a\n⊢ Eq (variationOnFromTo f s a b) (Neg.neg (eVariationOn f (Inter.inter s (Set.Icc b a))).toReal)","decl":"protected theorem eq_of_ge {a b : α} (h : b ≤ a) :\n    variationOnFromTo f s a b = -(eVariationOn f (s ∩ Icc b a)).toReal := by\n  rw [variationOnFromTo.eq_neg_swap, neg_inj, variationOnFromTo.eq_of_le f s h]\n\n"}
{"name":"variationOnFromTo.add","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\na b c : α\nha : Membership.mem s a\nhb : Membership.mem s b\nhc : Membership.mem s c\n⊢ Eq (HAdd.hAdd (variationOnFromTo f s a b) (variationOnFromTo f s b c)) (variationOnFromTo f s a c)","decl":"protected theorem add {f : α → E} {s : Set α} (hf : LocallyBoundedVariationOn f s) {a b c : α}\n    (ha : a ∈ s) (hb : b ∈ s) (hc : c ∈ s) :\n    variationOnFromTo f s a b + variationOnFromTo f s b c = variationOnFromTo f s a c := by\n  symm\n  refine additive_of_isTotal ((· : α) ≤ ·) (variationOnFromTo f s) (· ∈ s) ?_ ?_ ha hb hc\n  · rintro x y _xs _ys\n    simp only [variationOnFromTo.eq_neg_swap f s y x, Subtype.coe_mk, add_neg_cancel,\n      forall_true_left]\n  · rintro x y z xy yz xs ys zs\n    rw [variationOnFromTo.eq_of_le f s xy, variationOnFromTo.eq_of_le f s yz,\n      variationOnFromTo.eq_of_le f s (xy.trans yz),\n      ← ENNReal.toReal_add (hf x y xs ys) (hf y z ys zs), eVariationOn.Icc_add_Icc f xy yz ys]\n\n"}
{"name":"variationOnFromTo.edist_zero_of_eq_zero","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\nh : Eq (variationOnFromTo f s a b) 0\n⊢ Eq (EDist.edist (f a) (f b)) 0","decl":"variable {f s} in\nprotected theorem edist_zero_of_eq_zero (hf : LocallyBoundedVariationOn f s)\n    {a b : α} (ha : a ∈ s) (hb : b ∈ s) (h : variationOnFromTo f s a b = 0) :\n    edist (f a) (f b) = 0 := by\n  wlog h' : a ≤ b\n  · rw [edist_comm]\n    apply this hf hb ha _ (le_of_not_le h')\n    rw [variationOnFromTo.eq_neg_swap, h, neg_zero]\n  · apply le_antisymm _ (zero_le _)\n    rw [← ENNReal.ofReal_zero, ← h, variationOnFromTo.eq_of_le f s h',\n      ENNReal.ofReal_toReal (hf a b ha hb)]\n    apply eVariationOn.edist_le\n    exacts [⟨ha, ⟨le_rfl, h'⟩⟩, ⟨hb, ⟨h', le_rfl⟩⟩]\n\n"}
{"name":"variationOnFromTo.eq_left_iff","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\na b c : α\nha : Membership.mem s a\nhb : Membership.mem s b\nhc : Membership.mem s c\n⊢ Iff (Eq (variationOnFromTo f s a b) (variationOnFromTo f s a c)) (Eq (variationOnFromTo f s b c) 0)","decl":"protected theorem eq_left_iff {f : α → E} {s : Set α} (hf : LocallyBoundedVariationOn f s)\n    {a b c : α} (ha : a ∈ s) (hb : b ∈ s) (hc : c ∈ s) :\n    variationOnFromTo f s a b = variationOnFromTo f s a c ↔ variationOnFromTo f s b c = 0 := by\n  simp only [← variationOnFromTo.add hf ha hb hc, self_eq_add_right]\n\n"}
{"name":"variationOnFromTo.eq_zero_iff_of_le","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\nab : LE.le a b\n⊢ Iff (Eq (variationOnFromTo f s a b) 0) (∀ ⦃x : α⦄, Membership.mem (Inter.inter s (Set.Icc a b)) x → ∀ ⦃y : α⦄, Membership.mem (Inter.inter s (Set.Icc a b)) y → Eq (EDist.edist (f x) (f y)) 0)","decl":"protected theorem eq_zero_iff_of_le {f : α → E} {s : Set α} (hf : LocallyBoundedVariationOn f s)\n    {a b : α} (ha : a ∈ s) (hb : b ∈ s) (ab : a ≤ b) :\n    variationOnFromTo f s a b = 0 ↔\n      ∀ ⦃x⦄ (_hx : x ∈ s ∩ Icc a b) ⦃y⦄ (_hy : y ∈ s ∩ Icc a b), edist (f x) (f y) = 0 := by\n  rw [variationOnFromTo.eq_of_le _ _ ab, ENNReal.toReal_eq_zero_iff, or_iff_left (hf a b ha hb),\n    eVariationOn.eq_zero_iff]\n\n"}
{"name":"variationOnFromTo.eq_zero_iff_of_ge","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\nba : LE.le b a\n⊢ Iff (Eq (variationOnFromTo f s a b) 0) (∀ ⦃x : α⦄, Membership.mem (Inter.inter s (Set.Icc b a)) x → ∀ ⦃y : α⦄, Membership.mem (Inter.inter s (Set.Icc b a)) y → Eq (EDist.edist (f x) (f y)) 0)","decl":"protected theorem eq_zero_iff_of_ge {f : α → E} {s : Set α} (hf : LocallyBoundedVariationOn f s)\n    {a b : α} (ha : a ∈ s) (hb : b ∈ s) (ba : b ≤ a) :\n    variationOnFromTo f s a b = 0 ↔\n      ∀ ⦃x⦄ (_hx : x ∈ s ∩ Icc b a) ⦃y⦄ (_hy : y ∈ s ∩ Icc b a), edist (f x) (f y) = 0 := by\n  rw [variationOnFromTo.eq_of_ge _ _ ba, neg_eq_zero, ENNReal.toReal_eq_zero_iff,\n    or_iff_left (hf b a hb ha), eVariationOn.eq_zero_iff]\n\n"}
{"name":"variationOnFromTo.eq_zero_iff","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (Eq (variationOnFromTo f s a b) 0) (∀ ⦃x : α⦄, Membership.mem (Inter.inter s (Set.uIcc a b)) x → ∀ ⦃y : α⦄, Membership.mem (Inter.inter s (Set.uIcc a b)) y → Eq (EDist.edist (f x) (f y)) 0)","decl":"protected theorem eq_zero_iff {f : α → E} {s : Set α} (hf : LocallyBoundedVariationOn f s) {a b : α}\n    (ha : a ∈ s) (hb : b ∈ s) :\n    variationOnFromTo f s a b = 0 ↔\n      ∀ ⦃x⦄ (_hx : x ∈ s ∩ uIcc a b) ⦃y⦄ (_hy : y ∈ s ∩ uIcc a b), edist (f x) (f y) = 0 := by\n  rcases le_total a b with (ab | ba)\n  · rw [uIcc_of_le ab]\n    exact variationOnFromTo.eq_zero_iff_of_le hf ha hb ab\n  · rw [uIcc_of_ge ba]\n    exact variationOnFromTo.eq_zero_iff_of_ge hf ha hb ba\n\n"}
{"name":"variationOnFromTo.monotoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\na : α\nas : Membership.mem s a\n⊢ MonotoneOn (variationOnFromTo f s a) s","decl":"protected theorem monotoneOn (hf : LocallyBoundedVariationOn f s) {a : α} (as : a ∈ s) :\n    MonotoneOn (variationOnFromTo f s a) s := by\n  rintro b bs c cs bc\n  rw [← variationOnFromTo.add hf as bs cs]\n  exact le_add_of_nonneg_right (variationOnFromTo.nonneg_of_le f s bc)\n\n"}
{"name":"variationOnFromTo.antitoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nE : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : α → E\ns : Set α\nhf : LocallyBoundedVariationOn f s\nb : α\nbs : Membership.mem s b\n⊢ AntitoneOn (fun a => variationOnFromTo f s a b) s","decl":"protected theorem antitoneOn (hf : LocallyBoundedVariationOn f s) {b : α} (bs : b ∈ s) :\n    AntitoneOn (fun a => variationOnFromTo f s a b) s := by\n  rintro a as c cs ac\n  dsimp only\n  rw [← variationOnFromTo.add hf as cs bs]\n  exact le_add_of_nonneg_left (variationOnFromTo.nonneg_of_le f s ac)\n\n"}
{"name":"variationOnFromTo.sub_self_monotoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf : α → Real\ns : Set α\nhf : LocallyBoundedVariationOn f s\na : α\nas : Membership.mem s a\n⊢ MonotoneOn (HSub.hSub (variationOnFromTo f s a) f) s","decl":"protected theorem sub_self_monotoneOn {f : α → ℝ} {s : Set α} (hf : LocallyBoundedVariationOn f s)\n    {a : α} (as : a ∈ s) : MonotoneOn (variationOnFromTo f s a - f) s := by\n  rintro b bs c cs bc\n  rw [Pi.sub_apply, Pi.sub_apply, le_sub_iff_add_le, add_comm_sub, ← le_sub_iff_add_le']\n  calc\n    f c - f b ≤ |f c - f b| := le_abs_self _\n    _ = dist (f b) (f c) := by rw [dist_comm, Real.dist_eq]\n    _ ≤ variationOnFromTo f s b c := by\n      rw [variationOnFromTo.eq_of_le f s bc, dist_edist]\n      apply ENNReal.toReal_mono (hf b c bs cs)\n      apply eVariationOn.edist_le f\n      exacts [⟨bs, le_rfl, bc⟩, ⟨cs, bc, le_rfl⟩]\n    _ = variationOnFromTo f s a c - variationOnFromTo f s a b := by\n      rw [← variationOnFromTo.add hf as bs cs, add_sub_cancel_left]\n\n"}
{"name":"variationOnFromTo.comp_eq_of_monotoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nβ : Type u_3\ninst✝ : LinearOrder β\nf : α → E\nt : Set β\nφ : β → α\nhφ : MonotoneOn φ t\nx y : β\nhx : Membership.mem t x\nhy : Membership.mem t y\n⊢ Eq (variationOnFromTo (Function.comp f φ) t x y) (variationOnFromTo f (Set.image φ t) (φ x) (φ y))","decl":"protected theorem comp_eq_of_monotoneOn {β : Type*} [LinearOrder β] (f : α → E) {t : Set β}\n    (φ : β → α) (hφ : MonotoneOn φ t) {x y : β} (hx : x ∈ t) (hy : y ∈ t) :\n    variationOnFromTo (f ∘ φ) t x y = variationOnFromTo f (φ '' t) (φ x) (φ y) := by\n  rcases le_total x y with (h | h)\n  · rw [variationOnFromTo.eq_of_le _ _ h, variationOnFromTo.eq_of_le _ _ (hφ hx hy h),\n      eVariationOn.comp_inter_Icc_eq_of_monotoneOn f φ hφ hx hy]\n  · rw [variationOnFromTo.eq_of_ge _ _ h, variationOnFromTo.eq_of_ge _ _ (hφ hy hx h),\n      eVariationOn.comp_inter_Icc_eq_of_monotoneOn f φ hφ hy hx]\n\n"}
{"name":"LocallyBoundedVariationOn.exists_monotoneOn_sub_monotoneOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nf : α → Real\ns : Set α\nh : LocallyBoundedVariationOn f s\n⊢ Exists fun p => Exists fun q => And (MonotoneOn p s) (And (MonotoneOn q s) (Eq f (HSub.hSub p q)))","decl":"/-- If a real valued function has bounded variation on a set, then it is a difference of monotone\nfunctions there. -/\ntheorem LocallyBoundedVariationOn.exists_monotoneOn_sub_monotoneOn {f : α → ℝ} {s : Set α}\n    (h : LocallyBoundedVariationOn f s) :\n    ∃ p q : α → ℝ, MonotoneOn p s ∧ MonotoneOn q s ∧ f = p - q := by\n  rcases eq_empty_or_nonempty s with (rfl | ⟨c, cs⟩)\n  · exact ⟨f, 0, subsingleton_empty.monotoneOn _, subsingleton_empty.monotoneOn _,\n      (sub_zero f).symm⟩\n  · exact ⟨_, _, variationOnFromTo.monotoneOn h cs, variationOnFromTo.sub_self_monotoneOn h cs,\n      (sub_sub_cancel _ _).symm⟩\n\n"}
{"name":"LipschitzOnWith.comp_eVariationOn_le","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nF : Type u_3\ninst✝ : PseudoEMetricSpace F\nf : E → F\nC : NNReal\nt : Set E\nh : LipschitzOnWith C f t\ng : α → E\ns : Set α\nhg : Set.MapsTo g s t\n⊢ LE.le (eVariationOn (Function.comp f g) s) (HMul.hMul (↑C) (eVariationOn g s))","decl":"theorem LipschitzOnWith.comp_eVariationOn_le {f : E → F} {C : ℝ≥0} {t : Set E}\n    (h : LipschitzOnWith C f t) {g : α → E} {s : Set α} (hg : MapsTo g s t) :\n    eVariationOn (f ∘ g) s ≤ C * eVariationOn g s := by\n  apply iSup_le _\n  rintro ⟨n, ⟨u, hu, us⟩⟩\n  calc\n    (∑ i ∈ Finset.range n, edist (f (g (u (i + 1)))) (f (g (u i)))) ≤\n        ∑ i ∈ Finset.range n, C * edist (g (u (i + 1))) (g (u i)) :=\n      Finset.sum_le_sum fun i _ => h (hg (us _)) (hg (us _))\n    _ = C * ∑ i ∈ Finset.range n, edist (g (u (i + 1))) (g (u i)) := by rw [Finset.mul_sum]\n    _ ≤ C * eVariationOn g s := mul_le_mul_left' (eVariationOn.sum_le _ _ hu us) _\n\n"}
{"name":"LipschitzOnWith.comp_boundedVariationOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nF : Type u_3\ninst✝ : PseudoEMetricSpace F\nf : E → F\nC : NNReal\nt : Set E\nhf : LipschitzOnWith C f t\ng : α → E\ns : Set α\nhg : Set.MapsTo g s t\nh : BoundedVariationOn g s\n⊢ BoundedVariationOn (Function.comp f g) s","decl":"theorem LipschitzOnWith.comp_boundedVariationOn {f : E → F} {C : ℝ≥0} {t : Set E}\n    (hf : LipschitzOnWith C f t) {g : α → E} {s : Set α} (hg : MapsTo g s t)\n    (h : BoundedVariationOn g s) : BoundedVariationOn (f ∘ g) s :=\n  ne_top_of_le_ne_top (ENNReal.mul_ne_top ENNReal.coe_ne_top h) (hf.comp_eVariationOn_le hg)\n\n"}
{"name":"LipschitzOnWith.comp_locallyBoundedVariationOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nF : Type u_3\ninst✝ : PseudoEMetricSpace F\nf : E → F\nC : NNReal\nt : Set E\nhf : LipschitzOnWith C f t\ng : α → E\ns : Set α\nhg : Set.MapsTo g s t\nh : LocallyBoundedVariationOn g s\n⊢ LocallyBoundedVariationOn (Function.comp f g) s","decl":"theorem LipschitzOnWith.comp_locallyBoundedVariationOn {f : E → F} {C : ℝ≥0} {t : Set E}\n    (hf : LipschitzOnWith C f t) {g : α → E} {s : Set α} (hg : MapsTo g s t)\n    (h : LocallyBoundedVariationOn g s) : LocallyBoundedVariationOn (f ∘ g) s :=\n  fun x y xs ys =>\n  hf.comp_boundedVariationOn (hg.mono_left inter_subset_left) (h x y xs ys)\n\n"}
{"name":"LipschitzWith.comp_boundedVariationOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nF : Type u_3\ninst✝ : PseudoEMetricSpace F\nf : E → F\nC : NNReal\nhf : LipschitzWith C f\ng : α → E\ns : Set α\nh : BoundedVariationOn g s\n⊢ BoundedVariationOn (Function.comp f g) s","decl":"theorem LipschitzWith.comp_boundedVariationOn {f : E → F} {C : ℝ≥0} (hf : LipschitzWith C f)\n    {g : α → E} {s : Set α} (h : BoundedVariationOn g s) : BoundedVariationOn (f ∘ g) s :=\n  hf.lipschitzOnWith.comp_boundedVariationOn (mapsTo_univ _ _) h\n\n"}
{"name":"LipschitzWith.comp_locallyBoundedVariationOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\nE : Type u_2\ninst✝¹ : PseudoEMetricSpace E\nF : Type u_3\ninst✝ : PseudoEMetricSpace F\nf : E → F\nC : NNReal\nhf : LipschitzWith C f\ng : α → E\ns : Set α\nh : LocallyBoundedVariationOn g s\n⊢ LocallyBoundedVariationOn (Function.comp f g) s","decl":"theorem LipschitzWith.comp_locallyBoundedVariationOn {f : E → F} {C : ℝ≥0}\n    (hf : LipschitzWith C f) {g : α → E} {s : Set α} (h : LocallyBoundedVariationOn g s) :\n    LocallyBoundedVariationOn (f ∘ g) s :=\n  hf.lipschitzOnWith.comp_locallyBoundedVariationOn (mapsTo_univ _ _) h\n\n"}
{"name":"LipschitzOnWith.locallyBoundedVariationOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\nC : NNReal\ns : Set Real\nhf : LipschitzOnWith C f s\n⊢ LocallyBoundedVariationOn f s","decl":"theorem LipschitzOnWith.locallyBoundedVariationOn {f : ℝ → E} {C : ℝ≥0} {s : Set ℝ}\n    (hf : LipschitzOnWith C f s) : LocallyBoundedVariationOn f s :=\n  hf.comp_locallyBoundedVariationOn (mapsTo_id _)\n    (@monotoneOn_id ℝ _ s).locallyBoundedVariationOn\n\n"}
{"name":"LipschitzWith.locallyBoundedVariationOn","module":"Mathlib.Topology.EMetricSpace.BoundedVariation","initialProofState":"E : Type u_2\ninst✝ : PseudoEMetricSpace E\nf : Real → E\nC : NNReal\nhf : LipschitzWith C f\ns : Set Real\n⊢ LocallyBoundedVariationOn f s","decl":"theorem LipschitzWith.locallyBoundedVariationOn {f : ℝ → E} {C : ℝ≥0} (hf : LipschitzWith C f)\n    (s : Set ℝ) : LocallyBoundedVariationOn f s :=\n  hf.lipschitzOnWith.locallyBoundedVariationOn\n\n"}
