{"name":"CategoryTheory.Functor.PreservesHomology.preservesCokernels","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : F.PreservesHomology\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) F","decl":"/-- A functor preserves homology when it preserves both kernels and cokernels. -/\nclass PreservesHomology (F : C ⥤ D) [PreservesZeroMorphisms F] : Prop where\n  /-- the functor preserves kernels -/\n  preservesKernels ⦃X Y : C⦄ (f : X ⟶ Y) : PreservesLimit (parallelPair f 0) F := by\n    infer_instance\n  /-- the functor preserves cokernels -/\n  preservesCokernels ⦃X Y : C⦄ (f : X ⟶ Y) : PreservesColimit (parallelPair f 0) F := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Functor.PreservesHomology.preservesKernels","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : F.PreservesHomology\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F","decl":"/-- A functor preserves homology when it preserves both kernels and cokernels. -/\nclass PreservesHomology (F : C ⥤ D) [PreservesZeroMorphisms F] : Prop where\n  /-- the functor preserves kernels -/\n  preservesKernels ⦃X Y : C⦄ (f : X ⟶ Y) : PreservesLimit (parallelPair f 0) F := by\n    infer_instance\n  /-- the functor preserves cokernels -/\n  preservesCokernels ⦃X Y : C⦄ (f : X ⟶ Y) : PreservesColimit (parallelPair f 0) F := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Functor.PreservesHomology.preservesKernel","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : F.PreservesHomology\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F","decl":"/-- A functor which preserves homology preserves kernels. -/\nlemma PreservesHomology.preservesKernel [F.PreservesHomology] {X Y : C} (f : X ⟶ Y) :\n    PreservesLimit (parallelPair f 0) F :=\n  PreservesHomology.preservesKernels _\n\n"}
{"name":"CategoryTheory.Functor.PreservesHomology.preservesCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : F.PreservesHomology\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) F","decl":"/-- A functor which preserves homology preserves cokernels. -/\nlemma PreservesHomology.preservesCokernel [F.PreservesHomology] {X Y : C} (f : X ⟶ Y) :\n    PreservesColimit (parallelPair f 0) F :=\n  PreservesHomology.preservesCokernels _\n\n"}
{"name":"CategoryTheory.Functor.preservesHomologyOfExact","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits F\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ F.PreservesHomology","decl":"noncomputable instance preservesHomologyOfExact\n    [PreservesFiniteLimits F] [PreservesFiniteColimits F] :\n  F.PreservesHomology where\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy.f'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : h.IsPreservedBy F\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair h.f' 0) F","decl":"/-- A left homology data `h` of a short complex `S` is preserved by a functor `F` is\n`F` preserves the kernel of `S.g : S.X₂ ⟶ S.X₃` and the cokernel of `h.f' : S.X₁ ⟶ h.K`. -/\nclass IsPreservedBy [F.PreservesZeroMorphisms] : Prop where\n  /-- the functor preserves the kernel of `S.g : S.X₂ ⟶ S.X₃`. -/\n  g : PreservesLimit (parallelPair S.g 0) F\n  /-- the functor preserves the cokernel of `h.f' : S.X₁ ⟶ h.K`. -/\n  f' : PreservesColimit (parallelPair h.f' 0) F\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy.g","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : h.IsPreservedBy F\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair S.g 0) F","decl":"/-- A left homology data `h` of a short complex `S` is preserved by a functor `F` is\n`F` preserves the kernel of `S.g : S.X₂ ⟶ S.X₃` and the cokernel of `h.f' : S.X₁ ⟶ h.K`. -/\nclass IsPreservedBy [F.PreservesZeroMorphisms] : Prop where\n  /-- the functor preserves the kernel of `S.g : S.X₂ ⟶ S.X₃`. -/\n  g : PreservesLimit (parallelPair S.g 0) F\n  /-- the functor preserves the cokernel of `h.f' : S.X₁ ⟶ h.K`. -/\n  f' : PreservesColimit (parallelPair h.f' 0) F\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.isPreservedBy_of_preservesHomology","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : F.PreservesHomology\n⊢ h.IsPreservedBy F","decl":"noncomputable instance isPreservedBy_of_preservesHomology [F.PreservesHomology] :\n    h.IsPreservedBy F where\n  g := Functor.PreservesHomology.preservesKernel _ _\n  f' := Functor.PreservesHomology.preservesCokernel _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy.hg","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair S.g 0) F","decl":"include h in\n/-- When a left homology data is preserved by a functor `F`, this functor\npreserves the kernel of `S.g : S.X₂ ⟶ S.X₃`. -/\nlemma IsPreservedBy.hg : PreservesLimit (parallelPair S.g 0) F :=\n  @IsPreservedBy.g _ _ _ _ _ _ _ h F _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy.hf'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair h.f' 0) F","decl":"/-- When a left homology data `h` is preserved by a functor `F`, this functor\npreserves the cokernel of `h.f' : S.X₁ ⟶ h.K`. -/\nlemma IsPreservedBy.hf' : PreservesColimit (parallelPair h.f' 0) F := IsPreservedBy.f'\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.map_H","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).H (F.obj h.H)","decl":"/-- When a left homology data `h` of a short complex `S` is preserved by a functor `F`,\nthis is the induced left homology data `h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def map : (S.map F).LeftHomologyData := by\n  have := IsPreservedBy.hg h F\n  have := IsPreservedBy.hf' h F\n  have wi : F.map h.i ≫ F.map S.g = 0 := by rw [← F.map_comp, h.wi, F.map_zero]\n  have hi := KernelFork.mapIsLimit _ h.hi F\n  let f' : F.obj S.X₁ ⟶ F.obj h.K := hi.lift (KernelFork.ofι (S.map F).f (S.map F).zero)\n  have hf' : f' = F.map h.f' := Fork.IsLimit.hom_ext hi (by\n    rw [Fork.IsLimit.lift_ι hi]\n    simp only [KernelFork.map_ι, Fork.ι_ofι, map_f, ← F.map_comp, f'_i])\n  have wπ : f' ≫ F.map h.π = 0 := by rw [hf', ← F.map_comp, f'_π, F.map_zero]\n  have hπ : IsColimit (CokernelCofork.ofπ (F.map h.π) wπ) := by\n    let e : parallelPair f' 0 ≅ parallelPair (F.map h.f') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hf') (by simp)\n    refine IsColimit.precomposeInvEquiv e _\n      (IsColimit.ofIsoColimit (CokernelCofork.mapIsColimit _ h.hπ' F) ?_)\n    exact Cofork.ext (Iso.refl _) (by simp [e])\n  exact\n    { K := F.obj h.K\n      H := F.obj h.H\n      i := F.map h.i\n      π := F.map h.π\n      wi := wi\n      hi := hi\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.map_π","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).π (F.map h.π)","decl":"/-- When a left homology data `h` of a short complex `S` is preserved by a functor `F`,\nthis is the induced left homology data `h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def map : (S.map F).LeftHomologyData := by\n  have := IsPreservedBy.hg h F\n  have := IsPreservedBy.hf' h F\n  have wi : F.map h.i ≫ F.map S.g = 0 := by rw [← F.map_comp, h.wi, F.map_zero]\n  have hi := KernelFork.mapIsLimit _ h.hi F\n  let f' : F.obj S.X₁ ⟶ F.obj h.K := hi.lift (KernelFork.ofι (S.map F).f (S.map F).zero)\n  have hf' : f' = F.map h.f' := Fork.IsLimit.hom_ext hi (by\n    rw [Fork.IsLimit.lift_ι hi]\n    simp only [KernelFork.map_ι, Fork.ι_ofι, map_f, ← F.map_comp, f'_i])\n  have wπ : f' ≫ F.map h.π = 0 := by rw [hf', ← F.map_comp, f'_π, F.map_zero]\n  have hπ : IsColimit (CokernelCofork.ofπ (F.map h.π) wπ) := by\n    let e : parallelPair f' 0 ≅ parallelPair (F.map h.f') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hf') (by simp)\n    refine IsColimit.precomposeInvEquiv e _\n      (IsColimit.ofIsoColimit (CokernelCofork.mapIsColimit _ h.hπ' F) ?_)\n    exact Cofork.ext (Iso.refl _) (by simp [e])\n  exact\n    { K := F.obj h.K\n      H := F.obj h.H\n      i := F.map h.i\n      π := F.map h.π\n      wi := wi\n      hi := hi\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.map_i","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).i (F.map h.i)","decl":"/-- When a left homology data `h` of a short complex `S` is preserved by a functor `F`,\nthis is the induced left homology data `h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def map : (S.map F).LeftHomologyData := by\n  have := IsPreservedBy.hg h F\n  have := IsPreservedBy.hf' h F\n  have wi : F.map h.i ≫ F.map S.g = 0 := by rw [← F.map_comp, h.wi, F.map_zero]\n  have hi := KernelFork.mapIsLimit _ h.hi F\n  let f' : F.obj S.X₁ ⟶ F.obj h.K := hi.lift (KernelFork.ofι (S.map F).f (S.map F).zero)\n  have hf' : f' = F.map h.f' := Fork.IsLimit.hom_ext hi (by\n    rw [Fork.IsLimit.lift_ι hi]\n    simp only [KernelFork.map_ι, Fork.ι_ofι, map_f, ← F.map_comp, f'_i])\n  have wπ : f' ≫ F.map h.π = 0 := by rw [hf', ← F.map_comp, f'_π, F.map_zero]\n  have hπ : IsColimit (CokernelCofork.ofπ (F.map h.π) wπ) := by\n    let e : parallelPair f' 0 ≅ parallelPair (F.map h.f') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hf') (by simp)\n    refine IsColimit.precomposeInvEquiv e _\n      (IsColimit.ofIsoColimit (CokernelCofork.mapIsColimit _ h.hπ' F) ?_)\n    exact Cofork.ext (Iso.refl _) (by simp [e])\n  exact\n    { K := F.obj h.K\n      H := F.obj h.H\n      i := F.map h.i\n      π := F.map h.π\n      wi := wi\n      hi := hi\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.map_K","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).K (F.obj h.K)","decl":"/-- When a left homology data `h` of a short complex `S` is preserved by a functor `F`,\nthis is the induced left homology data `h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def map : (S.map F).LeftHomologyData := by\n  have := IsPreservedBy.hg h F\n  have := IsPreservedBy.hf' h F\n  have wi : F.map h.i ≫ F.map S.g = 0 := by rw [← F.map_comp, h.wi, F.map_zero]\n  have hi := KernelFork.mapIsLimit _ h.hi F\n  let f' : F.obj S.X₁ ⟶ F.obj h.K := hi.lift (KernelFork.ofι (S.map F).f (S.map F).zero)\n  have hf' : f' = F.map h.f' := Fork.IsLimit.hom_ext hi (by\n    rw [Fork.IsLimit.lift_ι hi]\n    simp only [KernelFork.map_ι, Fork.ι_ofι, map_f, ← F.map_comp, f'_i])\n  have wπ : f' ≫ F.map h.π = 0 := by rw [hf', ← F.map_comp, f'_π, F.map_zero]\n  have hπ : IsColimit (CokernelCofork.ofπ (F.map h.π) wπ) := by\n    let e : parallelPair f' 0 ≅ parallelPair (F.map h.f') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hf') (by simp)\n    refine IsColimit.precomposeInvEquiv e _\n      (IsColimit.ofIsoColimit (CokernelCofork.mapIsColimit _ h.hπ' F) ?_)\n    exact Cofork.ext (Iso.refl _) (by simp [e])\n  exact\n    { K := F.obj h.K\n      H := F.obj h.H\n      i := F.map h.i\n      π := F.map h.π\n      wi := wi\n      hi := hi\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.map_f'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).f' (F.map h.f')","decl":"@[simp]\nlemma map_f' : (h.map F).f' = F.map h.f' := by\n  rw [← cancel_mono (h.map F).i, f'_i, map_f, map_i, ← F.map_comp, f'_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.map_φK","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nψ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : h₁.IsPreservedBy F\ninst✝ : h₂.IsPreservedBy F\n⊢ Eq (ψ.map F).φK (F.map ψ.φK)","decl":"/-- Given a left homology map data `ψ : LeftHomologyMapData φ h₁ h₂` such that\nboth left homology data `h₁` and `h₂` are preserved by a functor `F`, this is\nthe induced left homology map data for the morphism `F.mapShortComplex.map φ`. -/\n@[simps]\ndef LeftHomologyMapData.map {φ : S₁ ⟶ S₂} {h₁ : S₁.LeftHomologyData}\n    {h₂ : S₂.LeftHomologyData} (ψ : LeftHomologyMapData φ h₁ h₂) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [h₁.IsPreservedBy F] [h₂.IsPreservedBy F] :\n    LeftHomologyMapData (F.mapShortComplex.map φ) (h₁.map F) (h₂.map F) where\n  φK := F.map ψ.φK\n  φH := F.map ψ.φH\n  commi := by simpa only [F.map_comp] using F.congr_map ψ.commi\n  commf' := by simpa only [LeftHomologyData.map_f', F.map_comp] using F.congr_map ψ.commf'\n  commπ := by simpa only [F.map_comp] using F.congr_map ψ.commπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.map_φH","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nψ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : h₁.IsPreservedBy F\ninst✝ : h₂.IsPreservedBy F\n⊢ Eq (ψ.map F).φH (F.map ψ.φH)","decl":"/-- Given a left homology map data `ψ : LeftHomologyMapData φ h₁ h₂` such that\nboth left homology data `h₁` and `h₂` are preserved by a functor `F`, this is\nthe induced left homology map data for the morphism `F.mapShortComplex.map φ`. -/\n@[simps]\ndef LeftHomologyMapData.map {φ : S₁ ⟶ S₂} {h₁ : S₁.LeftHomologyData}\n    {h₂ : S₂.LeftHomologyData} (ψ : LeftHomologyMapData φ h₁ h₂) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [h₁.IsPreservedBy F] [h₂.IsPreservedBy F] :\n    LeftHomologyMapData (F.mapShortComplex.map φ) (h₁.map F) (h₂.map F) where\n  φK := F.map ψ.φK\n  φH := F.map ψ.φH\n  commi := by simpa only [F.map_comp] using F.congr_map ψ.commi\n  commf' := by simpa only [LeftHomologyData.map_f', F.map_comp] using F.congr_map ψ.commf'\n  commπ := by simpa only [F.map_comp] using F.congr_map ψ.commπ\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.IsPreservedBy.g'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : h.IsPreservedBy F\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair h.g' 0) F","decl":"/-- A right homology data `h` of a short complex `S` is preserved by a functor `F` is\n`F` preserves the cokernel of `S.f : S.X₁ ⟶ S.X₂` and the kernel of `h.g' : h.Q ⟶ S.X₃`. -/\nclass IsPreservedBy [F.PreservesZeroMorphisms] : Prop where\n  /-- the functor preserves the cokernel of `S.f : S.X₁ ⟶ S.X₂`. -/\n  f : PreservesColimit (parallelPair S.f 0) F\n  /-- the functor preserves the kernel of `h.g' : h.Q ⟶ S.X₃`. -/\n  g' : PreservesLimit (parallelPair h.g' 0) F\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.IsPreservedBy.f","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : h.IsPreservedBy F\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair S.f 0) F","decl":"/-- A right homology data `h` of a short complex `S` is preserved by a functor `F` is\n`F` preserves the cokernel of `S.f : S.X₁ ⟶ S.X₂` and the kernel of `h.g' : h.Q ⟶ S.X₃`. -/\nclass IsPreservedBy [F.PreservesZeroMorphisms] : Prop where\n  /-- the functor preserves the cokernel of `S.f : S.X₁ ⟶ S.X₂`. -/\n  f : PreservesColimit (parallelPair S.f 0) F\n  /-- the functor preserves the kernel of `h.g' : h.Q ⟶ S.X₃`. -/\n  g' : PreservesLimit (parallelPair h.g' 0) F\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.isPreservedBy_of_preservesHomology","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : F.PreservesHomology\n⊢ h.IsPreservedBy F","decl":"noncomputable instance isPreservedBy_of_preservesHomology [F.PreservesHomology] :\n    h.IsPreservedBy F where\n  f := Functor.PreservesHomology.preservesCokernel F _\n  g' := Functor.PreservesHomology.preservesKernel F _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.IsPreservedBy.hf","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair S.f 0) F","decl":"include h in\n/-- When a right homology data is preserved by a functor `F`, this functor\npreserves the cokernel of `S.f : S.X₁ ⟶ S.X₂`. -/\nlemma IsPreservedBy.hf : PreservesColimit (parallelPair S.f 0) F :=\n  @IsPreservedBy.f _ _ _ _ _ _ _ h F _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.IsPreservedBy.hg'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair h.g' 0) F","decl":"/-- When a right homology data `h` is preserved by a functor `F`, this functor\npreserves the kernel of `h.g' : h.Q ⟶ S.X₃`. -/\nlemma IsPreservedBy.hg' : PreservesLimit (parallelPair h.g' 0) F :=\n  @IsPreservedBy.g' _ _ _ _ _ _ _ h F _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.map_H","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).H (F.obj h.H)","decl":"/-- When a right homology data `h` of a short complex `S` is preserved by a functor `F`,\nthis is the induced right homology data `h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def map : (S.map F).RightHomologyData := by\n  have := IsPreservedBy.hf h F\n  have := IsPreservedBy.hg' h F\n  have wp : F.map S.f ≫ F.map h.p = 0 := by rw [← F.map_comp, h.wp, F.map_zero]\n  have hp := CokernelCofork.mapIsColimit _ h.hp F\n  let g' : F.obj h.Q ⟶ F.obj S.X₃ := hp.desc (CokernelCofork.ofπ (S.map F).g (S.map F).zero)\n  have hg' : g' = F.map h.g' := by\n    apply Cofork.IsColimit.hom_ext hp\n    rw [Cofork.IsColimit.π_desc hp]\n    simp only [Cofork.π_ofπ, CokernelCofork.map_π, map_g, ← F.map_comp, p_g']\n  have wι : F.map h.ι ≫ g' = 0 := by rw [hg', ← F.map_comp, ι_g', F.map_zero]\n  have hι : IsLimit (KernelFork.ofι (F.map h.ι) wι) := by\n    let e : parallelPair g' 0 ≅ parallelPair (F.map h.g') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hg') (by simp)\n    refine IsLimit.postcomposeHomEquiv e _\n      (IsLimit.ofIsoLimit (KernelFork.mapIsLimit _ h.hι' F) ?_)\n    exact Fork.ext (Iso.refl _) (by simp [e])\n  exact\n    { Q := F.obj h.Q\n      H := F.obj h.H\n      p := F.map h.p\n      ι := F.map h.ι\n      wp := wp\n      hp := hp\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.map_ι","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).ι (F.map h.ι)","decl":"/-- When a right homology data `h` of a short complex `S` is preserved by a functor `F`,\nthis is the induced right homology data `h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def map : (S.map F).RightHomologyData := by\n  have := IsPreservedBy.hf h F\n  have := IsPreservedBy.hg' h F\n  have wp : F.map S.f ≫ F.map h.p = 0 := by rw [← F.map_comp, h.wp, F.map_zero]\n  have hp := CokernelCofork.mapIsColimit _ h.hp F\n  let g' : F.obj h.Q ⟶ F.obj S.X₃ := hp.desc (CokernelCofork.ofπ (S.map F).g (S.map F).zero)\n  have hg' : g' = F.map h.g' := by\n    apply Cofork.IsColimit.hom_ext hp\n    rw [Cofork.IsColimit.π_desc hp]\n    simp only [Cofork.π_ofπ, CokernelCofork.map_π, map_g, ← F.map_comp, p_g']\n  have wι : F.map h.ι ≫ g' = 0 := by rw [hg', ← F.map_comp, ι_g', F.map_zero]\n  have hι : IsLimit (KernelFork.ofι (F.map h.ι) wι) := by\n    let e : parallelPair g' 0 ≅ parallelPair (F.map h.g') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hg') (by simp)\n    refine IsLimit.postcomposeHomEquiv e _\n      (IsLimit.ofIsoLimit (KernelFork.mapIsLimit _ h.hι' F) ?_)\n    exact Fork.ext (Iso.refl _) (by simp [e])\n  exact\n    { Q := F.obj h.Q\n      H := F.obj h.H\n      p := F.map h.p\n      ι := F.map h.ι\n      wp := wp\n      hp := hp\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.map_Q","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).Q (F.obj h.Q)","decl":"/-- When a right homology data `h` of a short complex `S` is preserved by a functor `F`,\nthis is the induced right homology data `h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def map : (S.map F).RightHomologyData := by\n  have := IsPreservedBy.hf h F\n  have := IsPreservedBy.hg' h F\n  have wp : F.map S.f ≫ F.map h.p = 0 := by rw [← F.map_comp, h.wp, F.map_zero]\n  have hp := CokernelCofork.mapIsColimit _ h.hp F\n  let g' : F.obj h.Q ⟶ F.obj S.X₃ := hp.desc (CokernelCofork.ofπ (S.map F).g (S.map F).zero)\n  have hg' : g' = F.map h.g' := by\n    apply Cofork.IsColimit.hom_ext hp\n    rw [Cofork.IsColimit.π_desc hp]\n    simp only [Cofork.π_ofπ, CokernelCofork.map_π, map_g, ← F.map_comp, p_g']\n  have wι : F.map h.ι ≫ g' = 0 := by rw [hg', ← F.map_comp, ι_g', F.map_zero]\n  have hι : IsLimit (KernelFork.ofι (F.map h.ι) wι) := by\n    let e : parallelPair g' 0 ≅ parallelPair (F.map h.g') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hg') (by simp)\n    refine IsLimit.postcomposeHomEquiv e _\n      (IsLimit.ofIsoLimit (KernelFork.mapIsLimit _ h.hι' F) ?_)\n    exact Fork.ext (Iso.refl _) (by simp [e])\n  exact\n    { Q := F.obj h.Q\n      H := F.obj h.H\n      p := F.map h.p\n      ι := F.map h.ι\n      wp := wp\n      hp := hp\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.map_p","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).p (F.map h.p)","decl":"/-- When a right homology data `h` of a short complex `S` is preserved by a functor `F`,\nthis is the induced right homology data `h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def map : (S.map F).RightHomologyData := by\n  have := IsPreservedBy.hf h F\n  have := IsPreservedBy.hg' h F\n  have wp : F.map S.f ≫ F.map h.p = 0 := by rw [← F.map_comp, h.wp, F.map_zero]\n  have hp := CokernelCofork.mapIsColimit _ h.hp F\n  let g' : F.obj h.Q ⟶ F.obj S.X₃ := hp.desc (CokernelCofork.ofπ (S.map F).g (S.map F).zero)\n  have hg' : g' = F.map h.g' := by\n    apply Cofork.IsColimit.hom_ext hp\n    rw [Cofork.IsColimit.π_desc hp]\n    simp only [Cofork.π_ofπ, CokernelCofork.map_π, map_g, ← F.map_comp, p_g']\n  have wι : F.map h.ι ≫ g' = 0 := by rw [hg', ← F.map_comp, ι_g', F.map_zero]\n  have hι : IsLimit (KernelFork.ofι (F.map h.ι) wι) := by\n    let e : parallelPair g' 0 ≅ parallelPair (F.map h.g') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hg') (by simp)\n    refine IsLimit.postcomposeHomEquiv e _\n      (IsLimit.ofIsoLimit (KernelFork.mapIsLimit _ h.hι' F) ?_)\n    exact Fork.ext (Iso.refl _) (by simp [e])\n  exact\n    { Q := F.obj h.Q\n      H := F.obj h.H\n      p := F.map h.p\n      ι := F.map h.ι\n      wp := wp\n      hp := hp\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.map_g'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : h.IsPreservedBy F\n⊢ Eq (h.map F).g' (F.map h.g')","decl":"@[simp]\nlemma map_g' : (h.map F).g' = F.map h.g' := by\n  rw [← cancel_epi (h.map F).p, p_g', map_g, map_p, ← F.map_comp, p_g']\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.map_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nψ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : h₁.IsPreservedBy F\ninst✝ : h₂.IsPreservedBy F\n⊢ Eq (ψ.map F).φQ (F.map ψ.φQ)","decl":"/-- Given a right homology map data `ψ : RightHomologyMapData φ h₁ h₂` such that\nboth right homology data `h₁` and `h₂` are preserved by a functor `F`, this is\nthe induced right homology map data for the morphism `F.mapShortComplex.map φ`. -/\n@[simps]\ndef RightHomologyMapData.map {φ : S₁ ⟶ S₂} {h₁ : S₁.RightHomologyData}\n    {h₂ : S₂.RightHomologyData} (ψ : RightHomologyMapData φ h₁ h₂) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [h₁.IsPreservedBy F] [h₂.IsPreservedBy F] :\n    RightHomologyMapData (F.mapShortComplex.map φ) (h₁.map F) (h₂.map F) where\n  φQ := F.map ψ.φQ\n  φH := F.map ψ.φH\n  commp := by simpa only [F.map_comp] using F.congr_map ψ.commp\n  commg' := by simpa only [RightHomologyData.map_g', F.map_comp] using F.congr_map ψ.commg'\n  commι := by simpa only [F.map_comp] using F.congr_map ψ.commι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.map_φH","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nψ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : h₁.IsPreservedBy F\ninst✝ : h₂.IsPreservedBy F\n⊢ Eq (ψ.map F).φH (F.map ψ.φH)","decl":"/-- Given a right homology map data `ψ : RightHomologyMapData φ h₁ h₂` such that\nboth right homology data `h₁` and `h₂` are preserved by a functor `F`, this is\nthe induced right homology map data for the morphism `F.mapShortComplex.map φ`. -/\n@[simps]\ndef RightHomologyMapData.map {φ : S₁ ⟶ S₂} {h₁ : S₁.RightHomologyData}\n    {h₂ : S₂.RightHomologyData} (ψ : RightHomologyMapData φ h₁ h₂) (F : C ⥤ D)\n    [F.PreservesZeroMorphisms] [h₁.IsPreservedBy F] [h₂.IsPreservedBy F] :\n    RightHomologyMapData (F.mapShortComplex.map φ) (h₁.map F) (h₂.map F) where\n  φQ := F.map ψ.φQ\n  φH := F.map ψ.φH\n  commp := by simpa only [F.map_comp] using F.congr_map ψ.commp\n  commg' := by simpa only [RightHomologyData.map_g', F.map_comp] using F.congr_map ψ.commg'\n  commι := by simpa only [F.map_comp] using F.congr_map ψ.commι\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.map_right","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : h.left.IsPreservedBy F\ninst✝ : h.right.IsPreservedBy F\n⊢ Eq (h.map F).right (h.right.map F)","decl":"/-- When a homology data `h` of a short complex `S` is such that both `h.left` and\n`h.right` are preserved by a functor `F`, this is the induced homology data\n`h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def HomologyData.map (h : S.HomologyData) (F : C ⥤ D) [F.PreservesZeroMorphisms]\n    [h.left.IsPreservedBy F] [h.right.IsPreservedBy F] :\n    (S.map F).HomologyData where\n  left := h.left.map F\n  right := h.right.map F\n  iso := F.mapIso h.iso\n  comm := by simpa only [F.map_comp] using F.congr_map h.comm\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.map_left","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : h.left.IsPreservedBy F\ninst✝ : h.right.IsPreservedBy F\n⊢ Eq (h.map F).left (h.left.map F)","decl":"/-- When a homology data `h` of a short complex `S` is such that both `h.left` and\n`h.right` are preserved by a functor `F`, this is the induced homology data\n`h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def HomologyData.map (h : S.HomologyData) (F : C ⥤ D) [F.PreservesZeroMorphisms]\n    [h.left.IsPreservedBy F] [h.right.IsPreservedBy F] :\n    (S.map F).HomologyData where\n  left := h.left.map F\n  right := h.right.map F\n  iso := F.mapIso h.iso\n  comm := by simpa only [F.map_comp] using F.congr_map h.comm\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.map_iso","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : h.left.IsPreservedBy F\ninst✝ : h.right.IsPreservedBy F\n⊢ Eq (h.map F).iso (F.mapIso h.iso)","decl":"/-- When a homology data `h` of a short complex `S` is such that both `h.left` and\n`h.right` are preserved by a functor `F`, this is the induced homology data\n`h.map F` for the short complex `S.map F`. -/\n@[simps]\nnoncomputable def HomologyData.map (h : S.HomologyData) (F : C ⥤ D) [F.PreservesZeroMorphisms]\n    [h.left.IsPreservedBy F] [h.right.IsPreservedBy F] :\n    (S.map F).HomologyData where\n  left := h.left.map F\n  right := h.right.map F\n  iso := F.mapIso h.iso\n  comm := by simpa only [F.map_comp] using F.congr_map h.comm\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.map_right","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nψ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : h₁.left.IsPreservedBy F\ninst✝² : h₁.right.IsPreservedBy F\ninst✝¹ : h₂.left.IsPreservedBy F\ninst✝ : h₂.right.IsPreservedBy F\n⊢ Eq (ψ.map F).right (ψ.right.map F)","decl":"/-- Given a homology map data `ψ : HomologyMapData φ h₁ h₂` such that\n`h₁.left`, `h₁.right`, `h₂.left` and `h₂.right` are all preserved by a functor `F`, this is\nthe induced homology map data for the morphism `F.mapShortComplex.map φ`. -/\n@[simps]\ndef HomologyMapData.map {φ : S₁ ⟶ S₂} {h₁ : S₁.HomologyData} {h₂ : S₂.HomologyData}\n    (ψ : HomologyMapData φ h₁ h₂) (F : C ⥤ D) [F.PreservesZeroMorphisms]\n    [h₁.left.IsPreservedBy F] [h₁.right.IsPreservedBy F]\n    [h₂.left.IsPreservedBy F] [h₂.right.IsPreservedBy F] :\n    HomologyMapData (F.mapShortComplex.map φ) (h₁.map F) (h₂.map F) where\n  left := ψ.left.map F\n  right := ψ.right.map F\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.map_left","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nψ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : h₁.left.IsPreservedBy F\ninst✝² : h₁.right.IsPreservedBy F\ninst✝¹ : h₂.left.IsPreservedBy F\ninst✝ : h₂.right.IsPreservedBy F\n⊢ Eq (ψ.map F).left (ψ.left.map F)","decl":"/-- Given a homology map data `ψ : HomologyMapData φ h₁ h₂` such that\n`h₁.left`, `h₁.right`, `h₂.left` and `h₂.right` are all preserved by a functor `F`, this is\nthe induced homology map data for the morphism `F.mapShortComplex.map φ`. -/\n@[simps]\ndef HomologyMapData.map {φ : S₁ ⟶ S₂} {h₁ : S₁.HomologyData} {h₂ : S₂.HomologyData}\n    (ψ : HomologyMapData φ h₁ h₂) (F : C ⥤ D) [F.PreservesZeroMorphisms]\n    [h₁.left.IsPreservedBy F] [h₁.right.IsPreservedBy F]\n    [h₂.left.IsPreservedBy F] [h₂.right.IsPreservedBy F] :\n    HomologyMapData (F.mapShortComplex.map φ) (h₁.map F) (h₂.map F) where\n  left := ψ.left.map F\n  right := ψ.right.map F\n\n"}
{"name":"CategoryTheory.Functor.PreservesLeftHomologyOf.isPreservedBy","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\nself : F.PreservesLeftHomologyOf S\nh : S.LeftHomologyData\n⊢ h.IsPreservedBy F","decl":"/-- A functor preserves the left homology of a short complex `S` if it preserves all the\nleft homology data of `S`. -/\nclass PreservesLeftHomologyOf : Prop where\n  /-- the functor preserves all the left homology data of the short complex -/\n  isPreservedBy : ∀ (h : S.LeftHomologyData), h.IsPreservedBy F\n\n"}
{"name":"CategoryTheory.Functor.PreservesRightHomologyOf.isPreservedBy","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\nself : F.PreservesRightHomologyOf S\nh : S.RightHomologyData\n⊢ h.IsPreservedBy F","decl":"/-- A functor preserves the right homology of a short complex `S` if it preserves all the\nright homology data of `S`. -/\nclass PreservesRightHomologyOf : Prop where\n  /-- the functor preserves all the right homology data of the short complex -/\n  isPreservedBy : ∀ (h : S.RightHomologyData), h.IsPreservedBy F\n\n"}
{"name":"CategoryTheory.Functor.PreservesHomology.preservesLeftHomologyOf","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\ninst✝ : F.PreservesHomology\n⊢ F.PreservesLeftHomologyOf S","decl":"instance PreservesHomology.preservesLeftHomologyOf [F.PreservesHomology] :\n    F.PreservesLeftHomologyOf S := ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.Functor.PreservesHomology.preservesRightHomologyOf","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\ninst✝ : F.PreservesHomology\n⊢ F.PreservesRightHomologyOf S","decl":"instance PreservesHomology.preservesRightHomologyOf [F.PreservesHomology] :\n    F.PreservesRightHomologyOf S := ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.Functor.PreservesLeftHomologyOf.mk'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\ninst✝ : h.IsPreservedBy F\n⊢ F.PreservesLeftHomologyOf S","decl":"/-- If a functor preserves a certain left homology data of a short complex `S`, then it\npreserves the left homology of `S`. -/\nlemma PreservesLeftHomologyOf.mk' (h : S.LeftHomologyData) [h.IsPreservedBy F] :\n    F.PreservesLeftHomologyOf S where\n  isPreservedBy h' :=\n    { g := ShortComplex.LeftHomologyData.IsPreservedBy.hg h F\n      f' := by\n        have := ShortComplex.LeftHomologyData.IsPreservedBy.hf' h F\n        let e : parallelPair h.f' 0 ≅ parallelPair h'.f' 0 :=\n          parallelPair.ext (Iso.refl _) (ShortComplex.cyclesMapIso' (Iso.refl S) h h')\n            (by simp) (by simp)\n        exact preservesColimit_of_iso_diagram F e }\n\n"}
{"name":"CategoryTheory.Functor.PreservesRightHomologyOf.mk'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\ninst✝ : h.IsPreservedBy F\n⊢ F.PreservesRightHomologyOf S","decl":"/-- If a functor preserves a certain right homology data of a short complex `S`, then it\npreserves the right homology of `S`. -/\nlemma PreservesRightHomologyOf.mk' (h : S.RightHomologyData) [h.IsPreservedBy F] :\n    F.PreservesRightHomologyOf S where\n  isPreservedBy h' :=\n    { f := ShortComplex.RightHomologyData.IsPreservedBy.hf h F\n      g' := by\n        have := ShortComplex.RightHomologyData.IsPreservedBy.hg' h F\n        let e : parallelPair h.g' 0 ≅ parallelPair h'.g' 0 :=\n          parallelPair.ext (ShortComplex.opcyclesMapIso' (Iso.refl S) h h') (Iso.refl _)\n            (by simp) (by simp)\n        exact preservesLimit_of_iso_diagram F e }\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.isPreservedBy_of_preserves","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : F.PreservesLeftHomologyOf S\n⊢ h₁.IsPreservedBy F","decl":"instance LeftHomologyData.isPreservedBy_of_preserves [F.PreservesLeftHomologyOf S] :\n    h₁.IsPreservedBy F :=\n  Functor.PreservesLeftHomologyOf.isPreservedBy _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.isPreservedBy_of_preserves","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nh₂ : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : F.PreservesRightHomologyOf S\n⊢ h₂.IsPreservedBy F","decl":"instance RightHomologyData.isPreservedBy_of_preserves [F.PreservesRightHomologyOf S] :\n    h₂.IsPreservedBy F :=\n  Functor.PreservesRightHomologyOf.isPreservedBy _\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_of_preserves","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasLeftHomology\ninst✝ : F.PreservesLeftHomologyOf S\n⊢ (S.map F).HasLeftHomology","decl":"instance hasLeftHomology_of_preserves [S.HasLeftHomology] [F.PreservesLeftHomologyOf S] :\n    (S.map F).HasLeftHomology :=\n  HasLeftHomology.mk' (S.leftHomologyData.map F)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_of_preserves'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasLeftHomology\ninst✝ : F.PreservesLeftHomologyOf S\n⊢ (F.mapShortComplex.obj S).HasLeftHomology","decl":"instance hasLeftHomology_of_preserves' [S.HasLeftHomology] [F.PreservesLeftHomologyOf S] :\n    (F.mapShortComplex.obj S).HasLeftHomology := by\n  dsimp; infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.hasRightHomology_of_preserves","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasRightHomology\ninst✝ : F.PreservesRightHomologyOf S\n⊢ (S.map F).HasRightHomology","decl":"instance hasRightHomology_of_preserves [S.HasRightHomology] [F.PreservesRightHomologyOf S] :\n    (S.map F).HasRightHomology :=\n  HasRightHomology.mk' (S.rightHomologyData.map F)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasRightHomology_of_preserves'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasRightHomology\ninst✝ : F.PreservesRightHomologyOf S\n⊢ (F.mapShortComplex.obj S).HasRightHomology","decl":"instance hasRightHomology_of_preserves' [S.HasRightHomology] [F.PreservesRightHomologyOf S] :\n    (F.mapShortComplex.obj S).HasRightHomology := by\n  dsimp; infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_preserves","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : S.HasHomology\ninst✝¹ : F.PreservesLeftHomologyOf S\ninst✝ : F.PreservesRightHomologyOf S\n⊢ (S.map F).HasHomology","decl":"instance hasHomology_of_preserves [S.HasHomology] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] :\n    (S.map F).HasHomology :=\n  HasHomology.mk' (S.homologyData.map F)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_preserves'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : S.HasHomology\ninst✝¹ : F.PreservesLeftHomologyOf S\ninst✝ : F.PreservesRightHomologyOf S\n⊢ (F.mapShortComplex.obj S).HasHomology","decl":"instance hasHomology_of_preserves' [S.HasHomology] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] :\n    (F.mapShortComplex.obj S).HasHomology := by\n  dsimp; infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.map_cyclesMap'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhl₁ : S₁.LeftHomologyData\nhl₂ : S₂.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : hl₁.IsPreservedBy F\ninst✝ : hl₂.IsPreservedBy F\n⊢ Eq (F.map (CategoryTheory.ShortComplex.cyclesMap' φ hl₁ hl₂)) (CategoryTheory.ShortComplex.cyclesMap' (F.mapShortComplex.map φ) (hl₁.map F) (hl₂.map F))","decl":"lemma map_cyclesMap' : F.map (ShortComplex.cyclesMap' φ hl₁ hl₂) =\n    ShortComplex.cyclesMap' (F.mapShortComplex.map φ) (hl₁.map F) (hl₂.map F) := by\n  have γ : ShortComplex.LeftHomologyMapData φ hl₁ hl₂ := default\n  rw [γ.cyclesMap'_eq, (γ.map F).cyclesMap'_eq,  ShortComplex.LeftHomologyMapData.map_φK]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.map_leftHomologyMap'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhl₁ : S₁.LeftHomologyData\nhl₂ : S₂.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : hl₁.IsPreservedBy F\ninst✝ : hl₂.IsPreservedBy F\n⊢ Eq (F.map (CategoryTheory.ShortComplex.leftHomologyMap' φ hl₁ hl₂)) (CategoryTheory.ShortComplex.leftHomologyMap' (F.mapShortComplex.map φ) (hl₁.map F) (hl₂.map F))","decl":"lemma map_leftHomologyMap' : F.map (ShortComplex.leftHomologyMap' φ hl₁ hl₂) =\n    ShortComplex.leftHomologyMap' (F.mapShortComplex.map φ) (hl₁.map F) (hl₂.map F) := by\n  have γ : ShortComplex.LeftHomologyMapData φ hl₁ hl₂ := default\n  rw [γ.leftHomologyMap'_eq, (γ.map F).leftHomologyMap'_eq,\n    ShortComplex.LeftHomologyMapData.map_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.map_opcyclesMap'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhr₁ : S₁.RightHomologyData\nhr₂ : S₂.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : hr₁.IsPreservedBy F\ninst✝ : hr₂.IsPreservedBy F\n⊢ Eq (F.map (CategoryTheory.ShortComplex.opcyclesMap' φ hr₁ hr₂)) (CategoryTheory.ShortComplex.opcyclesMap' (F.mapShortComplex.map φ) (hr₁.map F) (hr₂.map F))","decl":"lemma map_opcyclesMap' : F.map (ShortComplex.opcyclesMap' φ hr₁ hr₂) =\n    ShortComplex.opcyclesMap' (F.mapShortComplex.map φ) (hr₁.map F) (hr₂.map F) := by\n  have γ : ShortComplex.RightHomologyMapData φ hr₁ hr₂ := default\n  rw [γ.opcyclesMap'_eq, (γ.map F).opcyclesMap'_eq,  ShortComplex.RightHomologyMapData.map_φQ]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.map_rightHomologyMap'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhr₁ : S₁.RightHomologyData\nhr₂ : S₂.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : hr₁.IsPreservedBy F\ninst✝ : hr₂.IsPreservedBy F\n⊢ Eq (F.map (CategoryTheory.ShortComplex.rightHomologyMap' φ hr₁ hr₂)) (CategoryTheory.ShortComplex.rightHomologyMap' (F.mapShortComplex.map φ) (hr₁.map F) (hr₂.map F))","decl":"lemma map_rightHomologyMap' : F.map (ShortComplex.rightHomologyMap' φ hr₁ hr₂) =\n    ShortComplex.rightHomologyMap' (F.mapShortComplex.map φ) (hr₁.map F) (hr₂.map F) := by\n  have γ : ShortComplex.RightHomologyMapData φ hr₁ hr₂ := default\n  rw [γ.rightHomologyMap'_eq, (γ.map F).rightHomologyMap'_eq,\n    ShortComplex.RightHomologyMapData.map_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.map_homologyMap'","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : h₁.left.IsPreservedBy F\ninst✝² : h₁.right.IsPreservedBy F\ninst✝¹ : h₂.left.IsPreservedBy F\ninst✝ : h₂.right.IsPreservedBy F\n⊢ Eq (F.map (CategoryTheory.ShortComplex.homologyMap' φ h₁ h₂)) (CategoryTheory.ShortComplex.homologyMap' (F.mapShortComplex.map φ) (h₁.map F) (h₂.map F))","decl":"lemma HomologyData.map_homologyMap'\n    [h₁.left.IsPreservedBy F] [h₁.right.IsPreservedBy F]\n    [h₂.left.IsPreservedBy F] [h₂.right.IsPreservedBy F] :\n    F.map (ShortComplex.homologyMap' φ h₁ h₂) =\n      ShortComplex.homologyMap' (F.mapShortComplex.map φ) (h₁.map F) (h₂.map F) :=\n  LeftHomologyData.map_leftHomologyMap' _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.mapCyclesIso_hom_iCycles","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasLeftHomology\ninst✝ : F.PreservesLeftHomologyOf S\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.mapCyclesIso F).hom (F.map S.iCycles)) (S.map F).iCycles","decl":"@[reassoc (attr := simp)]\nlemma mapCyclesIso_hom_iCycles [S.HasLeftHomology] [F.PreservesLeftHomologyOf S] :\n    (S.mapCyclesIso F).hom ≫ F.map S.iCycles = (S.map F).iCycles := by\n  apply LeftHomologyData.cyclesIso_hom_comp_i\n\n"}
{"name":"CategoryTheory.ShortComplex.mapCyclesIso_hom_iCycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasLeftHomology\ninst✝ : F.PreservesLeftHomologyOf S\nZ : D\nh : Quiver.Hom (F.obj S.X₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.mapCyclesIso F).hom (CategoryTheory.CategoryStruct.comp (F.map S.iCycles) h)) (CategoryTheory.CategoryStruct.comp (S.map F).iCycles h)","decl":"@[reassoc (attr := simp)]\nlemma mapCyclesIso_hom_iCycles [S.HasLeftHomology] [F.PreservesLeftHomologyOf S] :\n    (S.mapCyclesIso F).hom ≫ F.map S.iCycles = (S.map F).iCycles := by\n  apply LeftHomologyData.cyclesIso_hom_comp_i\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.mapCyclesIso_eq","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nhl : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasLeftHomology\ninst✝ : F.PreservesLeftHomologyOf S\n⊢ Eq (S.mapCyclesIso F) ((hl.map F).cyclesIso.trans (F.mapIso hl.cyclesIso.symm))","decl":"lemma LeftHomologyData.mapCyclesIso_eq [S.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S] :\n    S.mapCyclesIso F = (hl.map F).cyclesIso ≪≫ F.mapIso hl.cyclesIso.symm := by\n  ext\n  dsimp [mapCyclesIso, cyclesIso]\n  simp only [map_cyclesMap', ← cyclesMap'_comp, Functor.map_id, comp_id,\n    Functor.mapShortComplex_obj]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.mapLeftHomologyIso_eq","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nhl : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasLeftHomology\ninst✝ : F.PreservesLeftHomologyOf S\n⊢ Eq (S.mapLeftHomologyIso F) ((hl.map F).leftHomologyIso.trans (F.mapIso hl.leftHomologyIso.symm))","decl":"lemma LeftHomologyData.mapLeftHomologyIso_eq [S.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S] :\n    S.mapLeftHomologyIso F = (hl.map F).leftHomologyIso ≪≫ F.mapIso hl.leftHomologyIso.symm := by\n  ext\n  dsimp [mapLeftHomologyIso, leftHomologyIso]\n  simp only [map_leftHomologyMap', ← leftHomologyMap'_comp, Functor.map_id, comp_id,\n    Functor.mapShortComplex_obj]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.mapOpcyclesIso_eq","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nhr : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasRightHomology\ninst✝ : F.PreservesRightHomologyOf S\n⊢ Eq (S.mapOpcyclesIso F) ((hr.map F).opcyclesIso.trans (F.mapIso hr.opcyclesIso.symm))","decl":"lemma RightHomologyData.mapOpcyclesIso_eq [S.HasRightHomology]\n    [F.PreservesRightHomologyOf S] :\n    S.mapOpcyclesIso F = (hr.map F).opcyclesIso ≪≫ F.mapIso hr.opcyclesIso.symm := by\n  ext\n  dsimp [mapOpcyclesIso, opcyclesIso]\n  simp only [map_opcyclesMap', ← opcyclesMap'_comp, Functor.map_id, comp_id,\n    Functor.mapShortComplex_obj]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.mapRightHomologyIso_eq","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nhr : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : S.HasRightHomology\ninst✝ : F.PreservesRightHomologyOf S\n⊢ Eq (S.mapRightHomologyIso F) ((hr.map F).rightHomologyIso.trans (F.mapIso hr.rightHomologyIso.symm))","decl":"lemma RightHomologyData.mapRightHomologyIso_eq [S.HasRightHomology]\n    [F.PreservesRightHomologyOf S] :\n    S.mapRightHomologyIso F = (hr.map F).rightHomologyIso ≪≫\n      F.mapIso hr.rightHomologyIso.symm := by\n  ext\n  dsimp [mapRightHomologyIso, rightHomologyIso]\n  simp only [map_rightHomologyMap', ← rightHomologyMap'_comp, Functor.map_id, comp_id,\n    Functor.mapShortComplex_obj]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.mapHomologyIso_eq","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nhl : S.LeftHomologyData\nF : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : S.HasHomology\ninst✝¹ : (S.map F).HasHomology\ninst✝ : F.PreservesLeftHomologyOf S\n⊢ Eq (S.mapHomologyIso F) ((hl.map F).homologyIso.trans (F.mapIso hl.homologyIso.symm))","decl":"lemma LeftHomologyData.mapHomologyIso_eq [S.HasHomology]\n    [(S.map F).HasHomology] [F.PreservesLeftHomologyOf S] :\n    S.mapHomologyIso F = (hl.map F).homologyIso ≪≫ F.mapIso hl.homologyIso.symm := by\n  ext\n  dsimp only [mapHomologyIso, homologyIso, ShortComplex.leftHomologyIso,\n    leftHomologyMapIso', leftHomologyIso, Functor.mapIso,\n    Iso.symm, Iso.trans, Iso.refl]\n  simp only [F.map_comp, map_leftHomologyMap', ← leftHomologyMap'_comp, comp_id,\n    Functor.map_id, Functor.mapShortComplex_obj]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.mapHomologyIso'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nhr : S.RightHomologyData\nF : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : S.HasHomology\ninst✝¹ : (S.map F).HasHomology\ninst✝ : F.PreservesRightHomologyOf S\n⊢ Eq (S.mapHomologyIso' F) ((hr.map F).homologyIso.trans (F.mapIso hr.homologyIso.symm))","decl":"lemma RightHomologyData.mapHomologyIso'_eq [S.HasHomology]\n    [(S.map F).HasHomology] [F.PreservesRightHomologyOf S] :\n    S.mapHomologyIso' F = (hr.map F).homologyIso ≪≫ F.mapIso hr.homologyIso.symm := by\n  ext\n  dsimp only [Iso.trans, Iso.symm, Iso.refl, Functor.mapIso, mapHomologyIso', homologyIso,\n    rightHomologyIso, rightHomologyMapIso', ShortComplex.rightHomologyIso]\n  simp only [assoc, F.map_comp, map_rightHomologyMap', ← rightHomologyMap'_comp_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapCyclesIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasLeftHomology\ninst✝² : S₂.HasLeftHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap (F.mapShortComplex.map φ)) (S₂.mapCyclesIso F).hom) (CategoryTheory.CategoryStruct.comp (S₁.mapCyclesIso F).hom (F.map (CategoryTheory.ShortComplex.cyclesMap φ)))","decl":"@[reassoc]\nlemma mapCyclesIso_hom_naturality [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    cyclesMap (F.mapShortComplex.map φ) ≫ (S₂.mapCyclesIso F).hom =\n      (S₁.mapCyclesIso F).hom ≫ F.map (cyclesMap φ) := by\n  dsimp only [cyclesMap, mapCyclesIso, LeftHomologyData.cyclesIso, cyclesMapIso', Iso.refl]\n  simp only [LeftHomologyData.map_cyclesMap', Functor.mapShortComplex_obj, ← cyclesMap'_comp,\n    comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapCyclesIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasLeftHomology\ninst✝² : S₂.HasLeftHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\nZ : D\nh : Quiver.Hom (F.obj S₂.cycles) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap (F.mapShortComplex.map φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapCyclesIso F).hom h)) (CategoryTheory.CategoryStruct.comp (S₁.mapCyclesIso F).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.cyclesMap φ)) h))","decl":"@[reassoc]\nlemma mapCyclesIso_hom_naturality [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    cyclesMap (F.mapShortComplex.map φ) ≫ (S₂.mapCyclesIso F).hom =\n      (S₁.mapCyclesIso F).hom ≫ F.map (cyclesMap φ) := by\n  dsimp only [cyclesMap, mapCyclesIso, LeftHomologyData.cyclesIso, cyclesMapIso', Iso.refl]\n  simp only [LeftHomologyData.map_cyclesMap', Functor.mapShortComplex_obj, ← cyclesMap'_comp,\n    comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapCyclesIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasLeftHomology\ninst✝² : S₂.HasLeftHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\nZ : D\nh : Quiver.Hom (S₂.map F).cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.cyclesMap φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapCyclesIso F).inv h)) (CategoryTheory.CategoryStruct.comp (S₁.mapCyclesIso F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap (F.mapShortComplex.map φ)) h))","decl":"@[reassoc]\nlemma mapCyclesIso_inv_naturality [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    F.map (cyclesMap φ) ≫ (S₂.mapCyclesIso F).inv =\n      (S₁.mapCyclesIso F).inv ≫ cyclesMap (F.mapShortComplex.map φ) := by\n  rw [← cancel_epi (S₁.mapCyclesIso F).hom, ← mapCyclesIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapCyclesIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasLeftHomology\ninst✝² : S₂.HasLeftHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.cyclesMap φ)) (S₂.mapCyclesIso F).inv) (CategoryTheory.CategoryStruct.comp (S₁.mapCyclesIso F).inv (CategoryTheory.ShortComplex.cyclesMap (F.mapShortComplex.map φ)))","decl":"@[reassoc]\nlemma mapCyclesIso_inv_naturality [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    F.map (cyclesMap φ) ≫ (S₂.mapCyclesIso F).inv =\n      (S₁.mapCyclesIso F).inv ≫ cyclesMap (F.mapShortComplex.map φ) := by\n  rw [← cancel_epi (S₁.mapCyclesIso F).hom, ← mapCyclesIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapLeftHomologyIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasLeftHomology\ninst✝² : S₂.HasLeftHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap (F.mapShortComplex.map φ)) (S₂.mapLeftHomologyIso F).hom) (CategoryTheory.CategoryStruct.comp (S₁.mapLeftHomologyIso F).hom (F.map (CategoryTheory.ShortComplex.leftHomologyMap φ)))","decl":"@[reassoc]\nlemma mapLeftHomologyIso_hom_naturality [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    leftHomologyMap (F.mapShortComplex.map φ) ≫ (S₂.mapLeftHomologyIso F).hom =\n      (S₁.mapLeftHomologyIso F).hom ≫ F.map (leftHomologyMap φ) := by\n  dsimp only [leftHomologyMap, mapLeftHomologyIso, LeftHomologyData.leftHomologyIso,\n    leftHomologyMapIso', Iso.refl]\n  simp only [LeftHomologyData.map_leftHomologyMap', Functor.mapShortComplex_obj,\n    ← leftHomologyMap'_comp, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapLeftHomologyIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasLeftHomology\ninst✝² : S₂.HasLeftHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\nZ : D\nh : Quiver.Hom (F.obj S₂.leftHomology) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap (F.mapShortComplex.map φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapLeftHomologyIso F).hom h)) (CategoryTheory.CategoryStruct.comp (S₁.mapLeftHomologyIso F).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.leftHomologyMap φ)) h))","decl":"@[reassoc]\nlemma mapLeftHomologyIso_hom_naturality [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    leftHomologyMap (F.mapShortComplex.map φ) ≫ (S₂.mapLeftHomologyIso F).hom =\n      (S₁.mapLeftHomologyIso F).hom ≫ F.map (leftHomologyMap φ) := by\n  dsimp only [leftHomologyMap, mapLeftHomologyIso, LeftHomologyData.leftHomologyIso,\n    leftHomologyMapIso', Iso.refl]\n  simp only [LeftHomologyData.map_leftHomologyMap', Functor.mapShortComplex_obj,\n    ← leftHomologyMap'_comp, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapLeftHomologyIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasLeftHomology\ninst✝² : S₂.HasLeftHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\nZ : D\nh : Quiver.Hom (S₂.map F).leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.leftHomologyMap φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapLeftHomologyIso F).inv h)) (CategoryTheory.CategoryStruct.comp (S₁.mapLeftHomologyIso F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap (F.mapShortComplex.map φ)) h))","decl":"@[reassoc]\nlemma mapLeftHomologyIso_inv_naturality [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    F.map (leftHomologyMap φ) ≫ (S₂.mapLeftHomologyIso F).inv =\n      (S₁.mapLeftHomologyIso F).inv ≫ leftHomologyMap (F.mapShortComplex.map φ) := by\n  rw [← cancel_epi (S₁.mapLeftHomologyIso F).hom, ← mapLeftHomologyIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapLeftHomologyIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasLeftHomology\ninst✝² : S₂.HasLeftHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.leftHomologyMap φ)) (S₂.mapLeftHomologyIso F).inv) (CategoryTheory.CategoryStruct.comp (S₁.mapLeftHomologyIso F).inv (CategoryTheory.ShortComplex.leftHomologyMap (F.mapShortComplex.map φ)))","decl":"@[reassoc]\nlemma mapLeftHomologyIso_inv_naturality [S₁.HasLeftHomology] [S₂.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    F.map (leftHomologyMap φ) ≫ (S₂.mapLeftHomologyIso F).inv =\n      (S₁.mapLeftHomologyIso F).inv ≫ leftHomologyMap (F.mapShortComplex.map φ) := by\n  rw [← cancel_epi (S₁.mapLeftHomologyIso F).hom, ← mapLeftHomologyIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapOpcyclesIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasRightHomology\ninst✝² : S₂.HasRightHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\nZ : D\nh : Quiver.Hom (F.obj S₂.opcycles) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap (F.mapShortComplex.map φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapOpcyclesIso F).hom h)) (CategoryTheory.CategoryStruct.comp (S₁.mapOpcyclesIso F).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.opcyclesMap φ)) h))","decl":"@[reassoc]\nlemma mapOpcyclesIso_hom_naturality [S₁.HasRightHomology] [S₂.HasRightHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    opcyclesMap (F.mapShortComplex.map φ) ≫ (S₂.mapOpcyclesIso F).hom =\n      (S₁.mapOpcyclesIso F).hom ≫ F.map (opcyclesMap φ) := by\n  dsimp only [opcyclesMap, mapOpcyclesIso, RightHomologyData.opcyclesIso,\n    opcyclesMapIso', Iso.refl]\n  simp only [RightHomologyData.map_opcyclesMap', Functor.mapShortComplex_obj, ← opcyclesMap'_comp,\n    comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapOpcyclesIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasRightHomology\ninst✝² : S₂.HasRightHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap (F.mapShortComplex.map φ)) (S₂.mapOpcyclesIso F).hom) (CategoryTheory.CategoryStruct.comp (S₁.mapOpcyclesIso F).hom (F.map (CategoryTheory.ShortComplex.opcyclesMap φ)))","decl":"@[reassoc]\nlemma mapOpcyclesIso_hom_naturality [S₁.HasRightHomology] [S₂.HasRightHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    opcyclesMap (F.mapShortComplex.map φ) ≫ (S₂.mapOpcyclesIso F).hom =\n      (S₁.mapOpcyclesIso F).hom ≫ F.map (opcyclesMap φ) := by\n  dsimp only [opcyclesMap, mapOpcyclesIso, RightHomologyData.opcyclesIso,\n    opcyclesMapIso', Iso.refl]\n  simp only [RightHomologyData.map_opcyclesMap', Functor.mapShortComplex_obj, ← opcyclesMap'_comp,\n    comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapOpcyclesIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasRightHomology\ninst✝² : S₂.HasRightHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.opcyclesMap φ)) (S₂.mapOpcyclesIso F).inv) (CategoryTheory.CategoryStruct.comp (S₁.mapOpcyclesIso F).inv (CategoryTheory.ShortComplex.opcyclesMap (F.mapShortComplex.map φ)))","decl":"@[reassoc]\nlemma mapOpcyclesIso_inv_naturality [S₁.HasRightHomology] [S₂.HasRightHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    F.map (opcyclesMap φ) ≫ (S₂.mapOpcyclesIso F).inv =\n      (S₁.mapOpcyclesIso F).inv ≫ opcyclesMap (F.mapShortComplex.map φ) := by\n  rw [← cancel_epi (S₁.mapOpcyclesIso F).hom, ← mapOpcyclesIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapOpcyclesIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasRightHomology\ninst✝² : S₂.HasRightHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\nZ : D\nh : Quiver.Hom (S₂.map F).opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.opcyclesMap φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapOpcyclesIso F).inv h)) (CategoryTheory.CategoryStruct.comp (S₁.mapOpcyclesIso F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap (F.mapShortComplex.map φ)) h))","decl":"@[reassoc]\nlemma mapOpcyclesIso_inv_naturality [S₁.HasRightHomology] [S₂.HasRightHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    F.map (opcyclesMap φ) ≫ (S₂.mapOpcyclesIso F).inv =\n      (S₁.mapOpcyclesIso F).inv ≫ opcyclesMap (F.mapShortComplex.map φ) := by\n  rw [← cancel_epi (S₁.mapOpcyclesIso F).hom, ← mapOpcyclesIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapRightHomologyIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasRightHomology\ninst✝² : S₂.HasRightHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap (F.mapShortComplex.map φ)) (S₂.mapRightHomologyIso F).hom) (CategoryTheory.CategoryStruct.comp (S₁.mapRightHomologyIso F).hom (F.map (CategoryTheory.ShortComplex.rightHomologyMap φ)))","decl":"@[reassoc]\nlemma mapRightHomologyIso_hom_naturality [S₁.HasRightHomology] [S₂.HasRightHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    rightHomologyMap (F.mapShortComplex.map φ) ≫ (S₂.mapRightHomologyIso F).hom =\n      (S₁.mapRightHomologyIso F).hom ≫ F.map (rightHomologyMap φ) := by\n  dsimp only [rightHomologyMap, mapRightHomologyIso, RightHomologyData.rightHomologyIso,\n    rightHomologyMapIso', Iso.refl]\n  simp only [RightHomologyData.map_rightHomologyMap', Functor.mapShortComplex_obj,\n    ← rightHomologyMap'_comp, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapRightHomologyIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasRightHomology\ninst✝² : S₂.HasRightHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\nZ : D\nh : Quiver.Hom (F.obj S₂.rightHomology) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap (F.mapShortComplex.map φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapRightHomologyIso F).hom h)) (CategoryTheory.CategoryStruct.comp (S₁.mapRightHomologyIso F).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.rightHomologyMap φ)) h))","decl":"@[reassoc]\nlemma mapRightHomologyIso_hom_naturality [S₁.HasRightHomology] [S₂.HasRightHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    rightHomologyMap (F.mapShortComplex.map φ) ≫ (S₂.mapRightHomologyIso F).hom =\n      (S₁.mapRightHomologyIso F).hom ≫ F.map (rightHomologyMap φ) := by\n  dsimp only [rightHomologyMap, mapRightHomologyIso, RightHomologyData.rightHomologyIso,\n    rightHomologyMapIso', Iso.refl]\n  simp only [RightHomologyData.map_rightHomologyMap', Functor.mapShortComplex_obj,\n    ← rightHomologyMap'_comp, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapRightHomologyIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasRightHomology\ninst✝² : S₂.HasRightHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\nZ : D\nh : Quiver.Hom (S₂.map F).rightHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.rightHomologyMap φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapRightHomologyIso F).inv h)) (CategoryTheory.CategoryStruct.comp (S₁.mapRightHomologyIso F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap (F.mapShortComplex.map φ)) h))","decl":"@[reassoc]\nlemma mapRightHomologyIso_inv_naturality [S₁.HasRightHomology] [S₂.HasRightHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    F.map (rightHomologyMap φ) ≫ (S₂.mapRightHomologyIso F).inv =\n      (S₁.mapRightHomologyIso F).inv ≫ rightHomologyMap (F.mapShortComplex.map φ) := by\n  rw [← cancel_epi (S₁.mapRightHomologyIso F).hom, ← mapRightHomologyIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapRightHomologyIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\ninst✝³ : S₁.HasRightHomology\ninst✝² : S₂.HasRightHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.rightHomologyMap φ)) (S₂.mapRightHomologyIso F).inv) (CategoryTheory.CategoryStruct.comp (S₁.mapRightHomologyIso F).inv (CategoryTheory.ShortComplex.rightHomologyMap (F.mapShortComplex.map φ)))","decl":"@[reassoc]\nlemma mapRightHomologyIso_inv_naturality [S₁.HasRightHomology] [S₂.HasRightHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    F.map (rightHomologyMap φ) ≫ (S₂.mapRightHomologyIso F).inv =\n      (S₁.mapRightHomologyIso F).inv ≫ rightHomologyMap (F.mapShortComplex.map φ) := by\n  rw [← cancel_epi (S₁.mapRightHomologyIso F).hom, ← mapRightHomologyIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapHomologyIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : S₁.HasHomology\ninst✝⁴ : S₂.HasHomology\ninst✝³ : (S₁.map F).HasHomology\ninst✝² : (S₂.map F).HasHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (F.mapShortComplex.map φ)) (S₂.mapHomologyIso F).hom) (CategoryTheory.CategoryStruct.comp (S₁.mapHomologyIso F).hom (F.map (CategoryTheory.ShortComplex.homologyMap φ)))","decl":"@[reassoc]\nlemma mapHomologyIso_hom_naturality [S₁.HasHomology] [S₂.HasHomology]\n    [(S₁.map F).HasHomology] [(S₂.map F).HasHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    @homologyMap _ _ _ (S₁.map F) (S₂.map F) (F.mapShortComplex.map φ) _ _ ≫\n      (S₂.mapHomologyIso F).hom = (S₁.mapHomologyIso F).hom ≫ F.map (homologyMap φ) := by\n  dsimp only [homologyMap, homologyMap', mapHomologyIso, LeftHomologyData.homologyIso,\n    LeftHomologyData.leftHomologyIso, leftHomologyMapIso', leftHomologyIso,\n    Iso.symm, Iso.trans, Iso.refl]\n  simp only [LeftHomologyData.map_leftHomologyMap', ← leftHomologyMap'_comp, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapHomologyIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : S₁.HasHomology\ninst✝⁴ : S₂.HasHomology\ninst✝³ : (S₁.map F).HasHomology\ninst✝² : (S₂.map F).HasHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\nZ : D\nh : Quiver.Hom (F.obj S₂.homology) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (F.mapShortComplex.map φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapHomologyIso F).hom h)) (CategoryTheory.CategoryStruct.comp (S₁.mapHomologyIso F).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.homologyMap φ)) h))","decl":"@[reassoc]\nlemma mapHomologyIso_hom_naturality [S₁.HasHomology] [S₂.HasHomology]\n    [(S₁.map F).HasHomology] [(S₂.map F).HasHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    @homologyMap _ _ _ (S₁.map F) (S₂.map F) (F.mapShortComplex.map φ) _ _ ≫\n      (S₂.mapHomologyIso F).hom = (S₁.mapHomologyIso F).hom ≫ F.map (homologyMap φ) := by\n  dsimp only [homologyMap, homologyMap', mapHomologyIso, LeftHomologyData.homologyIso,\n    LeftHomologyData.leftHomologyIso, leftHomologyMapIso', leftHomologyIso,\n    Iso.symm, Iso.trans, Iso.refl]\n  simp only [LeftHomologyData.map_leftHomologyMap', ← leftHomologyMap'_comp, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapHomologyIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : S₁.HasHomology\ninst✝⁴ : S₂.HasHomology\ninst✝³ : (S₁.map F).HasHomology\ninst✝² : (S₂.map F).HasHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\nZ : D\nh : Quiver.Hom (S₂.map F).homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.homologyMap φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapHomologyIso F).inv h)) (CategoryTheory.CategoryStruct.comp (S₁.mapHomologyIso F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (F.mapShortComplex.map φ)) h))","decl":"@[reassoc]\nlemma mapHomologyIso_inv_naturality [S₁.HasHomology] [S₂.HasHomology]\n    [(S₁.map F).HasHomology] [(S₂.map F).HasHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    F.map (homologyMap φ) ≫ (S₂.mapHomologyIso F).inv =\n      (S₁.mapHomologyIso F).inv ≫\n      @homologyMap _ _ _ (S₁.map F) (S₂.map F) (F.mapShortComplex.map φ) _ _ := by\n  rw [← cancel_epi (S₁.mapHomologyIso F).hom, ← mapHomologyIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapHomologyIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : S₁.HasHomology\ninst✝⁴ : S₂.HasHomology\ninst✝³ : (S₁.map F).HasHomology\ninst✝² : (S₂.map F).HasHomology\ninst✝¹ : F.PreservesLeftHomologyOf S₁\ninst✝ : F.PreservesLeftHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.homologyMap φ)) (S₂.mapHomologyIso F).inv) (CategoryTheory.CategoryStruct.comp (S₁.mapHomologyIso F).inv (CategoryTheory.ShortComplex.homologyMap (F.mapShortComplex.map φ)))","decl":"@[reassoc]\nlemma mapHomologyIso_inv_naturality [S₁.HasHomology] [S₂.HasHomology]\n    [(S₁.map F).HasHomology] [(S₂.map F).HasHomology]\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂] :\n    F.map (homologyMap φ) ≫ (S₂.mapHomologyIso F).inv =\n      (S₁.mapHomologyIso F).inv ≫\n      @homologyMap _ _ _ (S₁.map F) (S₂.map F) (F.mapShortComplex.map φ) _ _ := by\n  rw [← cancel_epi (S₁.mapHomologyIso F).hom, ← mapHomologyIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapHomologyIso'_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : S₁.HasHomology\ninst✝⁴ : S₂.HasHomology\ninst✝³ : (S₁.map F).HasHomology\ninst✝² : (S₂.map F).HasHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\nZ : D\nh : Quiver.Hom (F.obj S₂.homology) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (F.mapShortComplex.map φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapHomologyIso' F).hom h)) (CategoryTheory.CategoryStruct.comp (S₁.mapHomologyIso' F).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.homologyMap φ)) h))","decl":"@[reassoc]\nlemma mapHomologyIso'_hom_naturality [S₁.HasHomology] [S₂.HasHomology]\n    [(S₁.map F).HasHomology] [(S₂.map F).HasHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    @homologyMap _ _ _ (S₁.map F) (S₂.map F) (F.mapShortComplex.map φ) _ _ ≫\n      (S₂.mapHomologyIso' F).hom = (S₁.mapHomologyIso' F).hom ≫ F.map (homologyMap φ) := by\n  dsimp only [Iso.trans, Iso.symm, Functor.mapIso, mapHomologyIso']\n  simp only [← RightHomologyData.rightHomologyIso_hom_naturality_assoc _\n    ((homologyData S₁).right.map F) ((homologyData S₂).right.map F), assoc,\n    ← RightHomologyData.map_rightHomologyMap', ← F.map_comp,\n    RightHomologyData.rightHomologyIso_inv_naturality _\n      (homologyData S₁).right (homologyData S₂).right]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapHomologyIso'_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : S₁.HasHomology\ninst✝⁴ : S₂.HasHomology\ninst✝³ : (S₁.map F).HasHomology\ninst✝² : (S₂.map F).HasHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (F.mapShortComplex.map φ)) (S₂.mapHomologyIso' F).hom) (CategoryTheory.CategoryStruct.comp (S₁.mapHomologyIso' F).hom (F.map (CategoryTheory.ShortComplex.homologyMap φ)))","decl":"@[reassoc]\nlemma mapHomologyIso'_hom_naturality [S₁.HasHomology] [S₂.HasHomology]\n    [(S₁.map F).HasHomology] [(S₂.map F).HasHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    @homologyMap _ _ _ (S₁.map F) (S₂.map F) (F.mapShortComplex.map φ) _ _ ≫\n      (S₂.mapHomologyIso' F).hom = (S₁.mapHomologyIso' F).hom ≫ F.map (homologyMap φ) := by\n  dsimp only [Iso.trans, Iso.symm, Functor.mapIso, mapHomologyIso']\n  simp only [← RightHomologyData.rightHomologyIso_hom_naturality_assoc _\n    ((homologyData S₁).right.map F) ((homologyData S₂).right.map F), assoc,\n    ← RightHomologyData.map_rightHomologyMap', ← F.map_comp,\n    RightHomologyData.rightHomologyIso_inv_naturality _\n      (homologyData S₁).right (homologyData S₂).right]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapHomologyIso'_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : S₁.HasHomology\ninst✝⁴ : S₂.HasHomology\ninst✝³ : (S₁.map F).HasHomology\ninst✝² : (S₂.map F).HasHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.homologyMap φ)) (S₂.mapHomologyIso' F).inv) (CategoryTheory.CategoryStruct.comp (S₁.mapHomologyIso' F).inv (CategoryTheory.ShortComplex.homologyMap (F.mapShortComplex.map φ)))","decl":"@[reassoc]\nlemma mapHomologyIso'_inv_naturality [S₁.HasHomology] [S₂.HasHomology]\n    [(S₁.map F).HasHomology] [(S₂.map F).HasHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    F.map (homologyMap φ) ≫ (S₂.mapHomologyIso' F).inv = (S₁.mapHomologyIso' F).inv ≫\n      @homologyMap _ _ _ (S₁.map F) (S₂.map F) (F.mapShortComplex.map φ) _ _ := by\n  rw [← cancel_epi (S₁.mapHomologyIso' F).hom, ← mapHomologyIso'_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapHomologyIso'_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : S₁.HasHomology\ninst✝⁴ : S₂.HasHomology\ninst✝³ : (S₁.map F).HasHomology\ninst✝² : (S₂.map F).HasHomology\ninst✝¹ : F.PreservesRightHomologyOf S₁\ninst✝ : F.PreservesRightHomologyOf S₂\nZ : D\nh : Quiver.Hom (S₂.map F).homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.ShortComplex.homologyMap φ)) (CategoryTheory.CategoryStruct.comp (S₂.mapHomologyIso' F).inv h)) (CategoryTheory.CategoryStruct.comp (S₁.mapHomologyIso' F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (F.mapShortComplex.map φ)) h))","decl":"@[reassoc]\nlemma mapHomologyIso'_inv_naturality [S₁.HasHomology] [S₂.HasHomology]\n    [(S₁.map F).HasHomology] [(S₂.map F).HasHomology]\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂] :\n    F.map (homologyMap φ) ≫ (S₂.mapHomologyIso' F).inv = (S₁.mapHomologyIso' F).inv ≫\n      @homologyMap _ _ _ (S₁.map F) (S₂.map F) (F.mapShortComplex.map φ) _ _ := by\n  rw [← cancel_epi (S₁.mapHomologyIso' F).hom, ← mapHomologyIso'_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.mapHomologyIso'_eq_mapHomologyIso","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : S.HasHomology\ninst✝¹ : F.PreservesLeftHomologyOf S\ninst✝ : F.PreservesRightHomologyOf S\n⊢ Eq (S.mapHomologyIso' F) (S.mapHomologyIso F)","decl":"lemma mapHomologyIso'_eq_mapHomologyIso [S.HasHomology] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] :\n    S.mapHomologyIso' F = S.mapHomologyIso F := by\n  ext\n  rw [S.homologyData.left.mapHomologyIso_eq F, S.homologyData.right.mapHomologyIso'_eq F]\n  dsimp only [Iso.trans, Iso.symm, Iso.refl, Functor.mapIso, RightHomologyData.homologyIso,\n    rightHomologyIso, RightHomologyData.rightHomologyIso, LeftHomologyData.homologyIso,\n    leftHomologyIso, LeftHomologyData.leftHomologyIso]\n  simp only [RightHomologyData.map_H, rightHomologyMapIso'_inv, rightHomologyMapIso'_hom, assoc,\n    Functor.map_comp, RightHomologyData.map_rightHomologyMap', Functor.mapShortComplex_obj,\n    Functor.map_id, LeftHomologyData.map_H, leftHomologyMapIso'_inv, leftHomologyMapIso'_hom,\n    LeftHomologyData.map_leftHomologyMap', ← rightHomologyMap'_comp_assoc, ← leftHomologyMap'_comp,\n    ← leftHomologyMap'_comp_assoc, id_comp]\n  have γ : HomologyMapData (𝟙 (S.map F)) (map S F).homologyData (S.homologyData.map F) := default\n  have eq := γ.comm\n  rw [← γ.left.leftHomologyMap'_eq, ← γ.right.rightHomologyMap'_eq] at eq\n  dsimp at eq\n  simp only [← reassoc_of% eq, ← F.map_comp, Iso.hom_inv_id, F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.natTransApp_φK","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF G : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : G.PreservesZeroMorphisms\ninst✝¹ : F.PreservesLeftHomologyOf S\ninst✝ : G.PreservesLeftHomologyOf S\nh : S.LeftHomologyData\nτ : Quiver.Hom F G\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.natTransApp h τ).φK (τ.app h.K)","decl":"/-- Given a natural transformation `τ : F ⟶ G` between functors `C ⥤ D` which preserve\nthe left homology of a short complex `S`, and a left homology data for `S`,\nthis is the left homology map data for the morphism `S.mapNatTrans τ`\nobtained by evaluating `τ`. -/\n@[simps]\ndef LeftHomologyMapData.natTransApp (h : LeftHomologyData S) (τ : F ⟶ G) :\n    LeftHomologyMapData (S.mapNatTrans τ) (h.map F) (h.map G) where\n  φK := τ.app h.K\n  φH := τ.app h.H\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.natTransApp_φH","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF G : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : G.PreservesZeroMorphisms\ninst✝¹ : F.PreservesLeftHomologyOf S\ninst✝ : G.PreservesLeftHomologyOf S\nh : S.LeftHomologyData\nτ : Quiver.Hom F G\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyMapData.natTransApp h τ).φH (τ.app h.H)","decl":"/-- Given a natural transformation `τ : F ⟶ G` between functors `C ⥤ D` which preserve\nthe left homology of a short complex `S`, and a left homology data for `S`,\nthis is the left homology map data for the morphism `S.mapNatTrans τ`\nobtained by evaluating `τ`. -/\n@[simps]\ndef LeftHomologyMapData.natTransApp (h : LeftHomologyData S) (τ : F ⟶ G) :\n    LeftHomologyMapData (S.mapNatTrans τ) (h.map F) (h.map G) where\n  φK := τ.app h.K\n  φH := τ.app h.H\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.natTransApp_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF G : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : G.PreservesZeroMorphisms\ninst✝¹ : F.PreservesRightHomologyOf S\ninst✝ : G.PreservesRightHomologyOf S\nh : S.RightHomologyData\nτ : Quiver.Hom F G\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.natTransApp h τ).φQ (τ.app h.Q)","decl":"/-- Given a natural transformation `τ : F ⟶ G` between functors `C ⥤ D` which preserve\nthe right homology of a short complex `S`, and a right homology data for `S`,\nthis is the right homology map data for the morphism `S.mapNatTrans τ`\nobtained by evaluating `τ`. -/\n@[simps]\ndef RightHomologyMapData.natTransApp (h : RightHomologyData S) (τ : F ⟶ G) :\n    RightHomologyMapData (S.mapNatTrans τ) (h.map F) (h.map G) where\n  φQ := τ.app h.Q\n  φH := τ.app h.H\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.natTransApp_φH","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF G : CategoryTheory.Functor C D\ninst✝³ : F.PreservesZeroMorphisms\ninst✝² : G.PreservesZeroMorphisms\ninst✝¹ : F.PreservesRightHomologyOf S\ninst✝ : G.PreservesRightHomologyOf S\nh : S.RightHomologyData\nτ : Quiver.Hom F G\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.natTransApp h τ).φH (τ.app h.H)","decl":"/-- Given a natural transformation `τ : F ⟶ G` between functors `C ⥤ D` which preserve\nthe right homology of a short complex `S`, and a right homology data for `S`,\nthis is the right homology map data for the morphism `S.mapNatTrans τ`\nobtained by evaluating `τ`. -/\n@[simps]\ndef RightHomologyMapData.natTransApp (h : RightHomologyData S) (τ : F ⟶ G) :\n    RightHomologyMapData (S.mapNatTrans τ) (h.map F) (h.map G) where\n  φQ := τ.app h.Q\n  φH := τ.app h.H\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.natTransApp_right","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF G : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesZeroMorphisms\ninst✝⁴ : G.PreservesZeroMorphisms\ninst✝³ : F.PreservesLeftHomologyOf S\ninst✝² : G.PreservesLeftHomologyOf S\ninst✝¹ : F.PreservesRightHomologyOf S\ninst✝ : G.PreservesRightHomologyOf S\nh : S.HomologyData\nτ : Quiver.Hom F G\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.natTransApp h τ).right (CategoryTheory.ShortComplex.RightHomologyMapData.natTransApp h.right τ)","decl":"/-- Given a natural transformation `τ : F ⟶ G` between functors `C ⥤ D` which preserve\nthe homology of a short complex `S`, and a homology data for `S`,\nthis is the homology map data for the morphism `S.mapNatTrans τ`\nobtained by evaluating `τ`. -/\n@[simps]\ndef HomologyMapData.natTransApp (h : HomologyData S) (τ : F ⟶ G) :\n    HomologyMapData (S.mapNatTrans τ) (h.map F) (h.map G) where\n  left := LeftHomologyMapData.natTransApp h.left τ\n  right := RightHomologyMapData.natTransApp h.right τ\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.natTransApp_left","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF G : CategoryTheory.Functor C D\ninst✝⁵ : F.PreservesZeroMorphisms\ninst✝⁴ : G.PreservesZeroMorphisms\ninst✝³ : F.PreservesLeftHomologyOf S\ninst✝² : G.PreservesLeftHomologyOf S\ninst✝¹ : F.PreservesRightHomologyOf S\ninst✝ : G.PreservesRightHomologyOf S\nh : S.HomologyData\nτ : Quiver.Hom F G\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.natTransApp h τ).left (CategoryTheory.ShortComplex.LeftHomologyMapData.natTransApp h.left τ)","decl":"/-- Given a natural transformation `τ : F ⟶ G` between functors `C ⥤ D` which preserve\nthe homology of a short complex `S`, and a homology data for `S`,\nthis is the homology map data for the morphism `S.mapNatTrans τ`\nobtained by evaluating `τ`. -/\n@[simps]\ndef HomologyMapData.natTransApp (h : HomologyData S) (τ : F ⟶ G) :\n    HomologyMapData (S.mapNatTrans τ) (h.map F) (h.map G) where\n  left := LeftHomologyMapData.natTransApp h.left τ\n  right := RightHomologyMapData.natTransApp h.right τ\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap_mapNatTrans","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nS : CategoryTheory.ShortComplex C\nF G : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : G.PreservesZeroMorphisms\ninst✝⁴ : F.PreservesLeftHomologyOf S\ninst✝³ : G.PreservesLeftHomologyOf S\ninst✝² : F.PreservesRightHomologyOf S\ninst✝¹ : G.PreservesRightHomologyOf S\ninst✝ : S.HasHomology\nτ : Quiver.Hom F G\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap (S.mapNatTrans τ)) (CategoryTheory.CategoryStruct.comp (S.mapHomologyIso F).hom (CategoryTheory.CategoryStruct.comp (τ.app S.homology) (S.mapHomologyIso G).inv))","decl":"lemma homologyMap_mapNatTrans [S.HasHomology] (τ : F ⟶ G) :\n    homologyMap (S.mapNatTrans τ) =\n      (S.mapHomologyIso F).hom ≫ τ.app S.homology ≫ (S.mapHomologyIso G).inv :=\n  (LeftHomologyMapData.natTransApp S.homologyData.left τ).homologyMap_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.quasiIso_map_iff","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhl₁ : S₁.LeftHomologyData\nhl₂ : S₂.LeftHomologyData\nψl : CategoryTheory.ShortComplex.LeftHomologyMapData φ hl₁ hl₂\ninst✝³ : (F.mapShortComplex.obj S₁).HasHomology\ninst✝² : (F.mapShortComplex.obj S₂).HasHomology\ninst✝¹ : hl₁.IsPreservedBy F\ninst✝ : hl₂.IsPreservedBy F\n⊢ Iff (CategoryTheory.ShortComplex.QuasiIso (F.mapShortComplex.map φ)) (CategoryTheory.IsIso (F.map ψl.φH))","decl":"lemma LeftHomologyMapData.quasiIso_map_iff\n    [(F.mapShortComplex.obj S₁).HasHomology]\n    [(F.mapShortComplex.obj S₂).HasHomology]\n    [hl₁.IsPreservedBy F] [hl₂.IsPreservedBy F] :\n    QuasiIso (F.mapShortComplex.map φ) ↔ IsIso (F.map ψl.φH) :=\n  (ψl.map F).quasiIso_iff\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.quasiIso_map_iff","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.PreservesZeroMorphisms\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhr₁ : S₁.RightHomologyData\nhr₂ : S₂.RightHomologyData\nψr : CategoryTheory.ShortComplex.RightHomologyMapData φ hr₁ hr₂\ninst✝³ : (F.mapShortComplex.obj S₁).HasHomology\ninst✝² : (F.mapShortComplex.obj S₂).HasHomology\ninst✝¹ : hr₁.IsPreservedBy F\ninst✝ : hr₂.IsPreservedBy F\n⊢ Iff (CategoryTheory.ShortComplex.QuasiIso (F.mapShortComplex.map φ)) (CategoryTheory.IsIso (F.map ψr.φH))","decl":"lemma RightHomologyMapData.quasiIso_map_iff\n    [(F.mapShortComplex.obj S₁).HasHomology]\n    [(F.mapShortComplex.obj S₂).HasHomology]\n    [hr₁.IsPreservedBy F] [hr₂.IsPreservedBy F] :\n    QuasiIso (F.mapShortComplex.map φ) ↔ IsIso (F.map ψr.φH) :=\n  (ψr.map F).quasiIso_iff\n\n"}
{"name":"CategoryTheory.ShortComplex.quasiIso_map_of_preservesLeftHomology","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹⁰ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝⁷ : F.PreservesZeroMorphisms\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝⁶ : S₁.HasHomology\ninst✝⁵ : S₂.HasHomology\ninst✝⁴ : (F.mapShortComplex.obj S₁).HasHomology\ninst✝³ : (F.mapShortComplex.obj S₂).HasHomology\ninst✝² : F.PreservesLeftHomologyOf S₁\ninst✝¹ : F.PreservesLeftHomologyOf S₂\ninst✝ : CategoryTheory.ShortComplex.QuasiIso φ\n⊢ CategoryTheory.ShortComplex.QuasiIso (F.mapShortComplex.map φ)","decl":"instance quasiIso_map_of_preservesLeftHomology\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂]\n    [QuasiIso φ] : QuasiIso (F.mapShortComplex.map φ) := by\n  have γ : LeftHomologyMapData φ S₁.leftHomologyData S₂.leftHomologyData := default\n  have : IsIso γ.φH := by\n    rw [← γ.quasiIso_iff]\n    infer_instance\n  rw [(γ.map F).quasiIso_iff, LeftHomologyMapData.map_φH]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.quasiIso_map_iff_of_preservesLeftHomology","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹⁰ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝⁷ : F.PreservesZeroMorphisms\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝⁶ : S₁.HasHomology\ninst✝⁵ : S₂.HasHomology\ninst✝⁴ : (F.mapShortComplex.obj S₁).HasHomology\ninst✝³ : (F.mapShortComplex.obj S₂).HasHomology\ninst✝² : F.PreservesLeftHomologyOf S₁\ninst✝¹ : F.PreservesLeftHomologyOf S₂\ninst✝ : F.ReflectsIsomorphisms\n⊢ Iff (CategoryTheory.ShortComplex.QuasiIso (F.mapShortComplex.map φ)) (CategoryTheory.ShortComplex.QuasiIso φ)","decl":"lemma quasiIso_map_iff_of_preservesLeftHomology\n    [F.PreservesLeftHomologyOf S₁] [F.PreservesLeftHomologyOf S₂]\n    [F.ReflectsIsomorphisms] :\n    QuasiIso (F.mapShortComplex.map φ) ↔ QuasiIso φ := by\n  have γ : LeftHomologyMapData φ S₁.leftHomologyData S₂.leftHomologyData := default\n  rw [γ.quasiIso_iff, (γ.map F).quasiIso_iff, LeftHomologyMapData.map_φH]\n  constructor\n  · intro\n    exact isIso_of_reflects_iso _ F\n  · intro\n    infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.quasiIso_map_of_preservesRightHomology","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹⁰ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝⁷ : F.PreservesZeroMorphisms\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝⁶ : S₁.HasHomology\ninst✝⁵ : S₂.HasHomology\ninst✝⁴ : (F.mapShortComplex.obj S₁).HasHomology\ninst✝³ : (F.mapShortComplex.obj S₂).HasHomology\ninst✝² : F.PreservesRightHomologyOf S₁\ninst✝¹ : F.PreservesRightHomologyOf S₂\ninst✝ : CategoryTheory.ShortComplex.QuasiIso φ\n⊢ CategoryTheory.ShortComplex.QuasiIso (F.mapShortComplex.map φ)","decl":"instance quasiIso_map_of_preservesRightHomology\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂]\n    [QuasiIso φ] : QuasiIso (F.mapShortComplex.map φ) := by\n  have γ : RightHomologyMapData φ S₁.rightHomologyData S₂.rightHomologyData := default\n  have : IsIso γ.φH := by\n    rw [← γ.quasiIso_iff]\n    infer_instance\n  rw [(γ.map F).quasiIso_iff, RightHomologyMapData.map_φH]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.quasiIso_map_iff_of_preservesRightHomology","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹⁰ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝⁷ : F.PreservesZeroMorphisms\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝⁶ : S₁.HasHomology\ninst✝⁵ : S₂.HasHomology\ninst✝⁴ : (F.mapShortComplex.obj S₁).HasHomology\ninst✝³ : (F.mapShortComplex.obj S₂).HasHomology\ninst✝² : F.PreservesRightHomologyOf S₁\ninst✝¹ : F.PreservesRightHomologyOf S₂\ninst✝ : F.ReflectsIsomorphisms\n⊢ Iff (CategoryTheory.ShortComplex.QuasiIso (F.mapShortComplex.map φ)) (CategoryTheory.ShortComplex.QuasiIso φ)","decl":"lemma quasiIso_map_iff_of_preservesRightHomology\n    [F.PreservesRightHomologyOf S₁] [F.PreservesRightHomologyOf S₂]\n    [F.ReflectsIsomorphisms] :\n    QuasiIso (F.mapShortComplex.map φ) ↔ QuasiIso φ := by\n  have γ : RightHomologyMapData φ S₁.rightHomologyData S₂.rightHomologyData := default\n  rw [γ.quasiIso_iff, (γ.map F).quasiIso_iff, RightHomologyMapData.map_φH]\n  constructor\n  · intro\n    exact isIso_of_reflects_iso _ F\n  · intro\n    infer_instance\n\n"}
{"name":"CategoryTheory.Functor.preservesLeftHomology_of_zero_f","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair S.g 0) F\n⊢ F.PreservesLeftHomologyOf S","decl":"/-- If a short complex `S` is such that `S.f = 0` and that the kernel of `S.g` is preserved\nby a functor `F`, then `F` preserves the left homology of `S`. -/\nlemma preservesLeftHomology_of_zero_f (hf : S.f = 0)\n    [PreservesLimit (parallelPair S.g 0) F] :\n    F.PreservesLeftHomologyOf S := ⟨fun h =>\n  { g := by infer_instance\n    f' := Limits.preservesCokernel_zero' _ _\n      (by rw [← cancel_mono h.i, h.f'_i, zero_comp, hf]) }⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesRightHomology_of_zero_g","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair S.f 0) F\n⊢ F.PreservesRightHomologyOf S","decl":"/-- If a short complex `S` is such that `S.g = 0` and that the cokernel of `S.f` is preserved\nby a functor `F`, then `F` preserves the right homology of `S`. -/\nlemma preservesRightHomology_of_zero_g (hg : S.g = 0)\n    [PreservesColimit (parallelPair S.f 0) F] :\n    F.PreservesRightHomologyOf S := ⟨fun h =>\n  { f := by infer_instance\n    g' := Limits.preservesKernel_zero' _ _\n      (by rw [← cancel_epi h.p, h.p_g', comp_zero, hg]) }⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesLeftHomology_of_zero_g","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair S.f 0) F\n⊢ F.PreservesLeftHomologyOf S","decl":"/-- If a short complex `S` is such that `S.g = 0` and that the cokernel of `S.f` is preserved\nby a functor `F`, then `F` preserves the left homology of `S`. -/\nlemma preservesLeftHomology_of_zero_g (hg : S.g = 0)\n    [PreservesColimit (parallelPair S.f 0) F] :\n    F.PreservesLeftHomologyOf S := ⟨fun h =>\n  { g := by\n      rw [hg]\n      infer_instance\n    f' := by\n      have := h.isIso_i hg\n      let e : parallelPair h.f' 0 ≅ parallelPair S.f 0 :=\n        parallelPair.ext (Iso.refl _) (asIso h.i) (by simp) (by simp)\n      exact Limits.preservesColimit_of_iso_diagram F e.symm}⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesRightHomology_of_zero_f","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair S.g 0) F\n⊢ F.PreservesRightHomologyOf S","decl":"/-- If a short complex `S` is such that `S.f = 0` and that the kernel of `S.g` is preserved\nby a functor `F`, then `F` preserves the right homology of `S`. -/\nlemma preservesRightHomology_of_zero_f (hf : S.f = 0)\n    [PreservesLimit (parallelPair S.g 0) F] :\n    F.PreservesRightHomologyOf S := ⟨fun h =>\n  { f := by\n      rw [hf]\n      infer_instance\n    g' := by\n      have := h.isIso_p hf\n      let e : parallelPair S.g 0 ≅ parallelPair h.g' 0 :=\n        parallelPair.ext (asIso h.p) (Iso.refl _) (by simp) (by simp)\n      exact Limits.preservesLimit_of_iso_diagram F e }⟩\n\n"}
{"name":"CategoryTheory.NatTrans.app_homology","module":"Mathlib.Algebra.Homology.ShortComplex.PreservesHomology","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁸ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nF G : CategoryTheory.Functor C D\nτ : Quiver.Hom F G\nS : CategoryTheory.ShortComplex C\ninst✝⁶ : S.HasHomology\ninst✝⁵ : F.PreservesZeroMorphisms\ninst✝⁴ : G.PreservesZeroMorphisms\ninst✝³ : F.PreservesLeftHomologyOf S\ninst✝² : G.PreservesLeftHomologyOf S\ninst✝¹ : F.PreservesRightHomologyOf S\ninst✝ : G.PreservesRightHomologyOf S\n⊢ Eq (τ.app S.homology) (CategoryTheory.CategoryStruct.comp (S.mapHomologyIso F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (S.mapNatTrans τ)) (S.mapHomologyIso G).hom))","decl":"lemma NatTrans.app_homology {F G : C ⥤ D} (τ : F ⟶ G)\n    (S : ShortComplex C) [S.HasHomology] [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms]\n    [F.PreservesLeftHomologyOf S] [G.PreservesLeftHomologyOf S] [F.PreservesRightHomologyOf S]\n    [G.PreservesRightHomologyOf S] :\n    τ.app S.homology = (S.mapHomologyIso F).inv ≫\n      ShortComplex.homologyMap (S.mapNatTrans τ) ≫ (S.mapHomologyIso G).hom := by\n  rw [ShortComplex.homologyMap_mapNatTrans, assoc, assoc, Iso.inv_hom_id,\n    comp_id, Iso.inv_hom_id_assoc]\n\n"}
