{"name":"Polynomial.revAtFun_invol","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"N i : Nat\n⊢ Eq (Polynomial.revAtFun N (Polynomial.revAtFun N i)) i","decl":"theorem revAtFun_invol {N i : ℕ} : revAtFun N (revAtFun N i) = i := by\n  unfold revAtFun\n  split_ifs with h j\n  · exact tsub_tsub_cancel_of_le h\n  · exfalso\n    apply j\n    exact Nat.sub_le N i\n  · rfl\n\n"}
{"name":"Polynomial.revAtFun_inj","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"N : Nat\n⊢ Function.Injective (Polynomial.revAtFun N)","decl":"theorem revAtFun_inj {N : ℕ} : Function.Injective (revAtFun N) := by\n  intro a b hab\n  rw [← @revAtFun_invol N a, hab, revAtFun_invol]\n\n"}
{"name":"Polynomial.revAtFun_eq","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"N i : Nat\n⊢ Eq (Polynomial.revAtFun N i) ((Polynomial.revAt N) i)","decl":"/-- We prefer to use the bundled `revAt` over unbundled `revAtFun`. -/\n@[simp]\ntheorem revAtFun_eq (N i : ℕ) : revAtFun N i = revAt N i :=\n  rfl\n\n"}
{"name":"Polynomial.revAt_invol","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"N i : Nat\n⊢ Eq ((Polynomial.revAt N) ((Polynomial.revAt N) i)) i","decl":"@[simp]\ntheorem revAt_invol {N i : ℕ} : (revAt N) (revAt N i) = i :=\n  revAtFun_invol\n\n"}
{"name":"Polynomial.revAt_le","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"N i : Nat\nH : LE.le i N\n⊢ Eq ((Polynomial.revAt N) i) (HSub.hSub N i)","decl":"@[simp]\ntheorem revAt_le {N i : ℕ} (H : i ≤ N) : revAt N i = N - i :=\n  if_pos H\n\n"}
{"name":"Polynomial.revAt_eq_self_of_lt","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"N i : Nat\nh : LT.lt N i\n⊢ Eq ((Polynomial.revAt N) i) i","decl":"lemma revAt_eq_self_of_lt {N i : ℕ} (h : N < i) : revAt N i = i := by simp [revAt, Nat.not_le.mpr h]\n\n"}
{"name":"Polynomial.revAt_add","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"N O n o : Nat\nhn : LE.le n N\nho : LE.le o O\n⊢ Eq ((Polynomial.revAt (HAdd.hAdd N O)) (HAdd.hAdd n o)) (HAdd.hAdd ((Polynomial.revAt N) n) ((Polynomial.revAt O) o))","decl":"theorem revAt_add {N O n o : ℕ} (hn : n ≤ N) (ho : o ≤ O) :\n    revAt (N + O) (n + o) = revAt N n + revAt O o := by\n  rcases Nat.le.dest hn with ⟨n', rfl⟩\n  rcases Nat.le.dest ho with ⟨o', rfl⟩\n  repeat' rw [revAt_le (le_add_right rfl.le)]\n  rw [add_assoc, add_left_comm n' o, ← add_assoc, revAt_le (le_add_right rfl.le)]\n  repeat' rw [add_tsub_cancel_left]\n\n"}
{"name":"Polynomial.revAt_zero","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"N : Nat\n⊢ Eq ((Polynomial.revAt N) 0) N","decl":"theorem revAt_zero (N : ℕ) : revAt N 0 = N := by simp\n\n"}
{"name":"Polynomial.reflect_support","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nN : Nat\nf : Polynomial R\n⊢ Eq (Polynomial.reflect N f).support (Finset.image (⇑(Polynomial.revAt N)) f.support)","decl":"theorem reflect_support (N : ℕ) (f : R[X]) :\n    (reflect N f).support = Finset.image (revAt N) f.support := by\n  rcases f with ⟨⟩\n  ext1\n  simp only [reflect, support_ofFinsupp, support_embDomain, Finset.mem_map, Finset.mem_image]\n\n"}
{"name":"Polynomial.coeff_reflect","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nN : Nat\nf : Polynomial R\ni : Nat\n⊢ Eq ((Polynomial.reflect N f).coeff i) (f.coeff ((Polynomial.revAt N) i))","decl":"@[simp]\ntheorem coeff_reflect (N : ℕ) (f : R[X]) (i : ℕ) : coeff (reflect N f) i = f.coeff (revAt N i) := by\n  rcases f with ⟨f⟩\n  simp only [reflect, coeff]\n  calc\n    Finsupp.embDomain (revAt N) f i = Finsupp.embDomain (revAt N) f (revAt N (revAt N i)) := by\n      rw [revAt_invol]\n    _ = f (revAt N i) := Finsupp.embDomain_apply _ _ _\n\n"}
{"name":"Polynomial.reflect_zero","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nN : Nat\n⊢ Eq (Polynomial.reflect N 0) 0","decl":"@[simp]\ntheorem reflect_zero {N : ℕ} : reflect N (0 : R[X]) = 0 :=\n  rfl\n\n"}
{"name":"Polynomial.reflect_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nN : Nat\nf : Polynomial R\n⊢ Iff (Eq (Polynomial.reflect N f) 0) (Eq f 0)","decl":"@[simp]\ntheorem reflect_eq_zero_iff {N : ℕ} {f : R[X]} : reflect N (f : R[X]) = 0 ↔ f = 0 := by\n  rw [ofFinsupp_eq_zero, reflect, embDomain_eq_zero, ofFinsupp_eq_zero]\n\n"}
{"name":"Polynomial.reflect_add","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : Polynomial R\nN : Nat\n⊢ Eq (Polynomial.reflect N (HAdd.hAdd f g)) (HAdd.hAdd (Polynomial.reflect N f) (Polynomial.reflect N g))","decl":"@[simp]\ntheorem reflect_add (f g : R[X]) (N : ℕ) : reflect N (f + g) = reflect N f + reflect N g := by\n  ext\n  simp only [coeff_add, coeff_reflect]\n\n"}
{"name":"Polynomial.reflect_C_mul","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nr : R\nN : Nat\n⊢ Eq (Polynomial.reflect N (HMul.hMul (Polynomial.C r) f)) (HMul.hMul (Polynomial.C r) (Polynomial.reflect N f))","decl":"@[simp]\ntheorem reflect_C_mul (f : R[X]) (r : R) (N : ℕ) : reflect N (C r * f) = C r * reflect N f := by\n  ext\n  simp only [coeff_reflect, coeff_C_mul]\n\n"}
{"name":"Polynomial.reflect_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nN n : Nat\nc : R\n⊢ Eq (Polynomial.reflect N (HMul.hMul (Polynomial.C c) (HPow.hPow Polynomial.X n))) (HMul.hMul (Polynomial.C c) (HPow.hPow Polynomial.X ((Polynomial.revAt N) n)))","decl":"theorem reflect_C_mul_X_pow (N n : ℕ) {c : R} : reflect N (C c * X ^ n) = C c * X ^ revAt N n := by\n  ext\n  rw [reflect_C_mul, coeff_C_mul, coeff_C_mul, coeff_X_pow, coeff_reflect]\n  split_ifs with h\n  · rw [h, revAt_invol, coeff_X_pow_self]\n  · rw [not_mem_support_iff.mp]\n    intro a\n    rw [← one_mul (X ^ n), ← C_1] at a\n    apply h\n    rw [← mem_support_C_mul_X_pow a, revAt_invol]\n\n"}
{"name":"Polynomial.reflect_C","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\nN : Nat\n⊢ Eq (Polynomial.reflect N (Polynomial.C r)) (HMul.hMul (Polynomial.C r) (HPow.hPow Polynomial.X N))","decl":"@[simp]\ntheorem reflect_C (r : R) (N : ℕ) : reflect N (C r) = C r * X ^ N := by\n  conv_lhs => rw [← mul_one (C r), ← pow_zero X, reflect_C_mul_X_pow, revAt_zero]\n\n"}
{"name":"Polynomial.reflect_monomial","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nN n : Nat\n⊢ Eq (Polynomial.reflect N (HPow.hPow Polynomial.X n)) (HPow.hPow Polynomial.X ((Polynomial.revAt N) n))","decl":"@[simp]\ntheorem reflect_monomial (N n : ℕ) : reflect N ((X : R[X]) ^ n) = X ^ revAt N n := by\n  rw [← one_mul (X ^ n), ← one_mul (X ^ revAt N n), ← C_1, reflect_C_mul_X_pow]\n\n"}
{"name":"Polynomial.reflect_one_X","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Polynomial.reflect 1 Polynomial.X) 1","decl":"@[simp] lemma reflect_one_X : reflect 1 (X : R[X]) = 1 := by\n  simpa using reflect_monomial 1 1 (R := R)\n\n"}
{"name":"Polynomial.reflect_map","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Type u_2\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\nn : Nat\n⊢ Eq (Polynomial.reflect n (Polynomial.map f p)) (Polynomial.map f (Polynomial.reflect n p))","decl":"lemma reflect_map {S : Type*} [Semiring S] (f : R →+* S) (p : R[X]) (n : ℕ) :\n    (p.map f).reflect n = (p.reflect n).map f := by\n  ext; simp\n\n"}
{"name":"Polynomial.reflect_one","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (Polynomial.reflect n 1) (HPow.hPow Polynomial.X n)","decl":"@[simp]\nlemma reflect_one (n : ℕ) : (1 : R[X]).reflect n = Polynomial.X ^ n := by\n  rw [← C.map_one, reflect_C, map_one, one_mul]\n\n"}
{"name":"Polynomial.reflect_mul_induction","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ncf cg N O : Nat\nf g : Polynomial R\na✝³ : LE.le f.support.card cf.succ\na✝² : LE.le g.support.card cg.succ\na✝¹ : LE.le f.natDegree N\na✝ : LE.le g.natDegree O\n⊢ Eq (Polynomial.reflect (HAdd.hAdd N O) (HMul.hMul f g)) (HMul.hMul (Polynomial.reflect N f) (Polynomial.reflect O g))","decl":"theorem reflect_mul_induction (cf cg : ℕ) :\n    ∀ N O : ℕ,\n      ∀ f g : R[X],\n        #f.support ≤ cf.succ →\n          #g.support ≤ cg.succ →\n            f.natDegree ≤ N →\n              g.natDegree ≤ O → reflect (N + O) (f * g) = reflect N f * reflect O g := by\n  induction' cf with cf hcf\n  --first induction (left): base case\n  · induction' cg with cg hcg\n    -- second induction (right): base case\n    · intro N O f g Cf Cg Nf Og\n      rw [← C_mul_X_pow_eq_self Cf, ← C_mul_X_pow_eq_self Cg]\n      simp_rw [mul_assoc, X_pow_mul, mul_assoc, ← pow_add (X : R[X]), reflect_C_mul,\n        reflect_monomial, add_comm, revAt_add Nf Og, mul_assoc, X_pow_mul, mul_assoc, ←\n        pow_add (X : R[X]), add_comm]\n    -- second induction (right): induction step\n    · intro N O f g Cf Cg Nf Og\n      by_cases g0 : g = 0\n      · rw [g0, reflect_zero, mul_zero, mul_zero, reflect_zero]\n      rw [← eraseLead_add_C_mul_X_pow g, mul_add, reflect_add, reflect_add, mul_add, hcg, hcg] <;>\n        try assumption\n      · exact le_add_left card_support_C_mul_X_pow_le_one\n      · exact le_trans (natDegree_C_mul_X_pow_le g.leadingCoeff g.natDegree) Og\n      · exact Nat.lt_succ_iff.mp (gt_of_ge_of_gt Cg (eraseLead_support_card_lt g0))\n      · exact le_trans eraseLead_natDegree_le_aux Og\n  --first induction (left): induction step\n  · intro N O f g Cf Cg Nf Og\n    by_cases f0 : f = 0\n    · rw [f0, reflect_zero, zero_mul, zero_mul, reflect_zero]\n    rw [← eraseLead_add_C_mul_X_pow f, add_mul, reflect_add, reflect_add, add_mul, hcf, hcf] <;>\n      try assumption\n    · exact le_add_left card_support_C_mul_X_pow_le_one\n    · exact le_trans (natDegree_C_mul_X_pow_le f.leadingCoeff f.natDegree) Nf\n    · exact Nat.lt_succ_iff.mp (gt_of_ge_of_gt Cf (eraseLead_support_card_lt f0))\n    · exact le_trans eraseLead_natDegree_le_aux Nf\n\n"}
{"name":"Polynomial.reflect_mul","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : Polynomial R\nF G : Nat\nFf : LE.le f.natDegree F\nGg : LE.le g.natDegree G\n⊢ Eq (Polynomial.reflect (HAdd.hAdd F G) (HMul.hMul f g)) (HMul.hMul (Polynomial.reflect F f) (Polynomial.reflect G g))","decl":"@[simp]\ntheorem reflect_mul (f g : R[X]) {F G : ℕ} (Ff : f.natDegree ≤ F) (Gg : g.natDegree ≤ G) :\n    reflect (F + G) (f * g) = reflect F f * reflect G g :=\n  reflect_mul_induction _ _ F G f g f.support.card.le_succ g.support.card.le_succ Ff Gg\n\n"}
{"name":"Polynomial.eval₂_reflect_mul_pow","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ni : RingHom R S\nx : S\ninst✝ : Invertible x\nN : Nat\nf : Polynomial R\nhf : LE.le f.natDegree N\n⊢ Eq (HMul.hMul (Polynomial.eval₂ i (Invertible.invOf x) (Polynomial.reflect N f)) (HPow.hPow x N)) (Polynomial.eval₂ i x f)","decl":"theorem eval₂_reflect_mul_pow (i : R →+* S) (x : S) [Invertible x] (N : ℕ) (f : R[X])\n    (hf : f.natDegree ≤ N) : eval₂ i (⅟ x) (reflect N f) * x ^ N = eval₂ i x f := by\n  refine\n    induction_with_natDegree_le (fun f => eval₂ i (⅟ x) (reflect N f) * x ^ N = eval₂ i x f) _ ?_ ?_\n      ?_ f hf\n  · simp\n  · intro n r _ hnN\n    simp only [revAt_le hnN, reflect_C_mul_X_pow, eval₂_X_pow, eval₂_C, eval₂_mul]\n    conv in x ^ N => rw [← Nat.sub_add_cancel hnN]\n    rw [pow_add, ← mul_assoc, mul_assoc (i r), ← mul_pow, invOf_mul_self, one_pow, mul_one]\n  · intros\n    simp [*, add_mul]\n\n"}
{"name":"Polynomial.eval₂_reflect_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ni : RingHom R S\nx : S\ninst✝ : Invertible x\nN : Nat\nf : Polynomial R\nhf : LE.le f.natDegree N\n⊢ Iff (Eq (Polynomial.eval₂ i (Invertible.invOf x) (Polynomial.reflect N f)) 0) (Eq (Polynomial.eval₂ i x f) 0)","decl":"theorem eval₂_reflect_eq_zero_iff (i : R →+* S) (x : S) [Invertible x] (N : ℕ) (f : R[X])\n    (hf : f.natDegree ≤ N) : eval₂ i (⅟ x) (reflect N f) = 0 ↔ eval₂ i x f = 0 := by\n  conv_rhs => rw [← eval₂_reflect_mul_pow i x N f hf]\n  constructor\n  · intro h\n    rw [h, zero_mul]\n  · intro h\n    rw [← mul_one (eval₂ i (⅟ x) _), ← one_pow N, ← mul_invOf_self x, mul_pow, ← mul_assoc, h,\n      zero_mul]\n\n"}
{"name":"Polynomial.coeff_reverse","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nn : Nat\n⊢ Eq (f.reverse.coeff n) (f.coeff ((Polynomial.revAt f.natDegree) n))","decl":"theorem coeff_reverse (f : R[X]) (n : ℕ) : f.reverse.coeff n = f.coeff (revAt f.natDegree n) := by\n  rw [reverse, coeff_reflect]\n\n"}
{"name":"Polynomial.coeff_zero_reverse","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq (f.reverse.coeff 0) f.leadingCoeff","decl":"@[simp]\ntheorem coeff_zero_reverse (f : R[X]) : coeff (reverse f) 0 = leadingCoeff f := by\n  rw [coeff_reverse, revAt_le (zero_le f.natDegree), tsub_zero, leadingCoeff]\n\n"}
{"name":"Polynomial.reverse_zero","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Polynomial.reverse 0) 0","decl":"@[simp]\ntheorem reverse_zero : reverse (0 : R[X]) = 0 :=\n  rfl\n\n"}
{"name":"Polynomial.reverse_eq_zero","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Iff (Eq f.reverse 0) (Eq f 0)","decl":"@[simp]\ntheorem reverse_eq_zero : f.reverse = 0 ↔ f = 0 := by simp [reverse]\n\n"}
{"name":"Polynomial.reverse_natDegree_le","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ LE.le f.reverse.natDegree f.natDegree","decl":"theorem reverse_natDegree_le (f : R[X]) : f.reverse.natDegree ≤ f.natDegree := by\n  rw [natDegree_le_iff_degree_le, degree_le_iff_coeff_zero]\n  intro n hn\n  rw [Nat.cast_lt] at hn\n  rw [coeff_reverse, revAt, Function.Embedding.coeFn_mk, if_neg (not_le_of_gt hn),\n    coeff_eq_zero_of_natDegree_lt hn]\n\n"}
{"name":"Polynomial.natDegree_eq_reverse_natDegree_add_natTrailingDegree","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq f.natDegree (HAdd.hAdd f.reverse.natDegree f.natTrailingDegree)","decl":"theorem natDegree_eq_reverse_natDegree_add_natTrailingDegree (f : R[X]) :\n    f.natDegree = f.reverse.natDegree + f.natTrailingDegree := by\n  by_cases hf : f = 0\n  · rw [hf, reverse_zero, natDegree_zero, natTrailingDegree_zero]\n  apply le_antisymm\n  · refine tsub_le_iff_right.mp ?_\n    apply le_natDegree_of_ne_zero\n    rw [reverse, coeff_reflect, ← revAt_le f.natTrailingDegree_le_natDegree, revAt_invol]\n    exact trailingCoeff_nonzero_iff_nonzero.mpr hf\n  · rw [← le_tsub_iff_left f.reverse_natDegree_le]\n    apply natTrailingDegree_le_of_ne_zero\n    have key := mt leadingCoeff_eq_zero.mp (mt reverse_eq_zero.mp hf)\n    rwa [leadingCoeff, coeff_reverse, revAt_le f.reverse_natDegree_le] at key\n\n"}
{"name":"Polynomial.reverse_natDegree","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq f.reverse.natDegree (HSub.hSub f.natDegree f.natTrailingDegree)","decl":"theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree := by\n  rw [f.natDegree_eq_reverse_natDegree_add_natTrailingDegree, add_tsub_cancel_right]\n\n"}
{"name":"Polynomial.reverse_leadingCoeff","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq f.reverse.leadingCoeff f.trailingCoeff","decl":"theorem reverse_leadingCoeff (f : R[X]) : f.reverse.leadingCoeff = f.trailingCoeff := by\n  rw [leadingCoeff, reverse_natDegree, ← revAt_le f.natTrailingDegree_le_natDegree,\n    coeff_reverse, revAt_invol, trailingCoeff]\n\n"}
{"name":"Polynomial.natTrailingDegree_reverse","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq f.reverse.natTrailingDegree 0","decl":"theorem natTrailingDegree_reverse (f : R[X]) : f.reverse.natTrailingDegree = 0 := by\n  rw [natTrailingDegree_eq_zero, reverse_eq_zero, coeff_zero_reverse, leadingCoeff_ne_zero]\n  exact eq_or_ne _ _\n\n"}
{"name":"Polynomial.reverse_trailingCoeff","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq f.reverse.trailingCoeff f.leadingCoeff","decl":"theorem reverse_trailingCoeff (f : R[X]) : f.reverse.trailingCoeff = f.leadingCoeff := by\n  rw [trailingCoeff, natTrailingDegree_reverse, coeff_zero_reverse]\n\n"}
{"name":"Polynomial.reverse_mul","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : Polynomial R\nfg : Ne (HMul.hMul f.leadingCoeff g.leadingCoeff) 0\n⊢ Eq (HMul.hMul f g).reverse (HMul.hMul f.reverse g.reverse)","decl":"theorem reverse_mul {f g : R[X]} (fg : f.leadingCoeff * g.leadingCoeff ≠ 0) :\n    reverse (f * g) = reverse f * reverse g := by\n  unfold reverse\n  rw [natDegree_mul' fg, reflect_mul f g rfl.le rfl.le]\n\n"}
{"name":"Polynomial.reverse_mul_of_domain","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_2\ninst✝¹ : Ring R\ninst✝ : NoZeroDivisors R\nf g : Polynomial R\n⊢ Eq (HMul.hMul f g).reverse (HMul.hMul f.reverse g.reverse)","decl":"@[simp]\ntheorem reverse_mul_of_domain {R : Type*} [Ring R] [NoZeroDivisors R] (f g : R[X]) :\n    reverse (f * g) = reverse f * reverse g := by\n  by_cases f0 : f = 0\n  · simp only [f0, zero_mul, reverse_zero]\n  by_cases g0 : g = 0\n  · rw [g0, mul_zero, reverse_zero, mul_zero]\n  simp [reverse_mul, *]\n\n"}
{"name":"Polynomial.trailingCoeff_mul","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_2\ninst✝¹ : Ring R\ninst✝ : NoZeroDivisors R\np q : Polynomial R\n⊢ Eq (HMul.hMul p q).trailingCoeff (HMul.hMul p.trailingCoeff q.trailingCoeff)","decl":"theorem trailingCoeff_mul {R : Type*} [Ring R] [NoZeroDivisors R] (p q : R[X]) :\n    (p * q).trailingCoeff = p.trailingCoeff * q.trailingCoeff := by\n  rw [← reverse_leadingCoeff, reverse_mul_of_domain, leadingCoeff_mul, reverse_leadingCoeff,\n    reverse_leadingCoeff]\n\n"}
{"name":"Polynomial.coeff_one_reverse","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq (f.reverse.coeff 1) f.nextCoeff","decl":"@[simp]\ntheorem coeff_one_reverse (f : R[X]) : coeff (reverse f) 1 = nextCoeff f := by\n  rw [coeff_reverse, nextCoeff]\n  split_ifs with hf\n  · have : coeff f 1 = 0 := coeff_eq_zero_of_natDegree_lt (by simp only [hf, zero_lt_one])\n    simp [*, revAt]\n  · rw [revAt_le]\n    exact Nat.succ_le_iff.2 (pos_iff_ne_zero.2 hf)\n\n"}
{"name":"Polynomial.reverse_C","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nt : R\n⊢ Eq (Polynomial.C t).reverse (Polynomial.C t)","decl":"@[simp] lemma reverse_C (t : R) :\n    reverse (C t) = C t := by\n  simp [reverse]\n\n"}
{"name":"Polynomial.reverse_mul_X","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (HMul.hMul p Polynomial.X).reverse p.reverse","decl":"@[simp] lemma reverse_mul_X (p : R[X]) : reverse (p * X) = reverse p := by\n  nontriviality R\n  rcases eq_or_ne p 0 with rfl | hp\n  · simp\n  · simp [reverse, hp]\n\n"}
{"name":"Polynomial.reverse_X_mul","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (HMul.hMul Polynomial.X p).reverse p.reverse","decl":"@[simp] lemma reverse_X_mul (p : R[X]) : reverse (X * p) = reverse p := by\n  rw [commute_X p, reverse_mul_X]\n\n"}
{"name":"Polynomial.reverse_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq (HMul.hMul p (HPow.hPow Polynomial.X n)).reverse p.reverse","decl":"@[simp] lemma reverse_mul_X_pow (p : R[X]) (n : ℕ) : reverse (p * X ^ n) = reverse p := by\n  induction n with\n  | zero => simp\n  | succ n ih => rw [pow_succ, ← mul_assoc, reverse_mul_X, ih]\n\n"}
{"name":"Polynomial.reverse_X_pow_mul","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq (HMul.hMul (HPow.hPow Polynomial.X n) p).reverse p.reverse","decl":"@[simp] lemma reverse_X_pow_mul (p : R[X]) (n : ℕ) : reverse (X ^ n * p) = reverse p := by\n  rw [commute_X_pow p, reverse_mul_X_pow]\n\n"}
{"name":"Polynomial.reverse_add_C","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nt : R\n⊢ Eq (HAdd.hAdd p (Polynomial.C t)).reverse (HAdd.hAdd p.reverse (HMul.hMul (Polynomial.C t) (HPow.hPow Polynomial.X p.natDegree)))","decl":"@[simp] lemma reverse_add_C (p : R[X]) (t : R) :\n    reverse (p + C t) = reverse p + C t * X ^ p.natDegree := by\n  simp [reverse]\n\n"}
{"name":"Polynomial.reverse_C_add","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nt : R\n⊢ Eq (HAdd.hAdd (Polynomial.C t) p).reverse (HAdd.hAdd (HMul.hMul (Polynomial.C t) (HPow.hPow Polynomial.X p.natDegree)) p.reverse)","decl":"@[simp] lemma reverse_C_add (p : R[X]) (t : R) :\n    reverse (C t + p) = C t * X ^ p.natDegree + reverse p := by\n  rw [add_comm, reverse_add_C, add_comm]\n\n"}
{"name":"Polynomial.eval₂_reverse_mul_pow","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ni : RingHom R S\nx : S\ninst✝ : Invertible x\nf : Polynomial R\n⊢ Eq (HMul.hMul (Polynomial.eval₂ i (Invertible.invOf x) f.reverse) (HPow.hPow x f.natDegree)) (Polynomial.eval₂ i x f)","decl":"theorem eval₂_reverse_mul_pow (i : R →+* S) (x : S) [Invertible x] (f : R[X]) :\n    eval₂ i (⅟ x) (reverse f) * x ^ f.natDegree = eval₂ i x f :=\n  eval₂_reflect_mul_pow i _ _ f le_rfl\n\n"}
{"name":"Polynomial.eval₂_reverse_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ni : RingHom R S\nx : S\ninst✝ : Invertible x\nf : Polynomial R\n⊢ Iff (Eq (Polynomial.eval₂ i (Invertible.invOf x) f.reverse) 0) (Eq (Polynomial.eval₂ i x f) 0)","decl":"@[simp]\ntheorem eval₂_reverse_eq_zero_iff (i : R →+* S) (x : S) [Invertible x] (f : R[X]) :\n    eval₂ i (⅟ x) (reverse f) = 0 ↔ eval₂ i x f = 0 :=\n  eval₂_reflect_eq_zero_iff i x _ _ le_rfl\n\n"}
{"name":"Polynomial.reflect_neg","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nf : Polynomial R\nN : Nat\n⊢ Eq (Polynomial.reflect N (Neg.neg f)) (Neg.neg (Polynomial.reflect N f))","decl":"@[simp]\ntheorem reflect_neg (f : R[X]) (N : ℕ) : reflect N (-f) = -reflect N f := by\n  rw [neg_eq_neg_one_mul, ← C_1, ← C_neg, reflect_C_mul, C_neg, C_1, ← neg_eq_neg_one_mul]\n\n"}
{"name":"Polynomial.reflect_sub","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nf g : Polynomial R\nN : Nat\n⊢ Eq (Polynomial.reflect N (HSub.hSub f g)) (HSub.hSub (Polynomial.reflect N f) (Polynomial.reflect N g))","decl":"@[simp]\ntheorem reflect_sub (f g : R[X]) (N : ℕ) : reflect N (f - g) = reflect N f - reflect N g := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, reflect_add, reflect_neg]\n\n"}
{"name":"Polynomial.reverse_neg","module":"Mathlib.Algebra.Polynomial.Reverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nf : Polynomial R\n⊢ Eq (Neg.neg f).reverse (Neg.neg f.reverse)","decl":"@[simp]\ntheorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f := by\n  rw [reverse, reverse, reflect_neg, natDegree_neg]\n\n"}
