{"name":"Submodule.quotientRel_def","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nx y : M\n⊢ Iff (p.quotientRel x y) (Membership.mem p (HSub.hSub x y))","decl":"theorem quotientRel_def {x y : M} : p.quotientRel x y ↔ x - y ∈ p :=\n  Iff.trans\n    (by\n      rw [leftRel_apply, sub_eq_add_neg, neg_add, neg_neg]\n      rfl)\n    neg_mem_iff\n\n"}
{"name":"Submodule.quotientRel_r_def","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nx y : M\n⊢ Iff (p.quotientRel x y) (Membership.mem p (HSub.hSub x y))","decl":"@[deprecated (since := \"2024-08-29\")] alias quotientRel_r_def := quotientRel_def\n\n"}
{"name":"Submodule.Quotient.mk'_eq_mk'","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nx : M\n⊢ Eq (Quotient.mk' x) (Submodule.Quotient.mk x)","decl":"theorem mk'_eq_mk' {p : Submodule R M} (x : M) :\n    @Quotient.mk' _ (quotientRel p) x = mk x :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.mk''_eq_mk","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nx : M\n⊢ Eq (Quotient.mk'' x) (Submodule.Quotient.mk x)","decl":"theorem mk''_eq_mk {p : Submodule R M} (x : M) : (Quotient.mk'' x : M ⧸ p) = mk x :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.quot_mk_eq_mk","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nx : M\n⊢ Eq (Quot.mk (⇑p.quotientRel) x) (Submodule.Quotient.mk x)","decl":"theorem quot_mk_eq_mk {p : Submodule R M} (x : M) : (Quot.mk _ x : M ⧸ p) = mk x :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.eq'","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nx y : M\n⊢ Iff (Eq (Submodule.Quotient.mk x) (Submodule.Quotient.mk y)) (Membership.mem p (HAdd.hAdd (Neg.neg x) y))","decl":"protected theorem eq' {x y : M} : (mk x : M ⧸ p) = mk y ↔ -x + y ∈ p :=\n  QuotientAddGroup.eq\n\n"}
{"name":"Submodule.Quotient.eq","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nx y : M\n⊢ Iff (Eq (Submodule.Quotient.mk x) (Submodule.Quotient.mk y)) (Membership.mem p (HSub.hSub x y))","decl":"protected theorem eq {x y : M} : (mk x : M ⧸ p) = mk y ↔ x - y ∈ p :=\n  (Submodule.Quotient.eq' p).trans (leftRel_apply.symm.trans p.quotientRel_def)\n\n"}
{"name":"Submodule.Quotient.mk_zero","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.Quotient.mk 0) 0","decl":"@[simp]\ntheorem mk_zero : mk 0 = (0 : M ⧸ p) :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.mk_eq_zero","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\nx : M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Iff (Eq (Submodule.Quotient.mk x) 0) (Membership.mem p x)","decl":"@[simp]\ntheorem mk_eq_zero : (mk x : M ⧸ p) = 0 ↔ x ∈ p := by simpa using (Quotient.eq' p : mk x = 0 ↔ _)\n\n"}
{"name":"Submodule.Quotient.mk_add","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\nx y : M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.Quotient.mk (HAdd.hAdd x y)) (HAdd.hAdd (Submodule.Quotient.mk x) (Submodule.Quotient.mk y))","decl":"@[simp]\ntheorem mk_add : (mk (x + y) : M ⧸ p) = mk x + mk y :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.mk_neg","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\nx : M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.Quotient.mk (Neg.neg x)) (Neg.neg (Submodule.Quotient.mk x))","decl":"@[simp]\ntheorem mk_neg : (mk (-x) : M ⧸ p) = -(mk x) :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.mk_sub","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\nx y : M\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.Quotient.mk (HSub.hSub x y)) (HSub.hSub (Submodule.Quotient.mk x) (Submodule.Quotient.mk y))","decl":"@[simp]\ntheorem mk_sub : (mk (x - y) : M ⧸ p) = mk x - mk y :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.forall","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nP : HasQuotient.Quotient M p → Prop\n⊢ Iff (∀ (a : HasQuotient.Quotient M p), P a) (∀ (a : M), P (Submodule.Quotient.mk a))","decl":"protected nonrec lemma «forall» {P : M ⧸ p → Prop} : (∀ a, P a) ↔ ∀ a, P (mk a) := Quotient.forall\n\n"}
{"name":"Submodule.Quotient.mk_smul","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nS : Type u_3\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\nr : S\nx : M\n⊢ Eq (Submodule.Quotient.mk (HSMul.hSMul r x)) (HSMul.hSMul r (Submodule.Quotient.mk x))","decl":"@[simp]\ntheorem mk_smul (r : S) (x : M) : (mk (r • x) : M ⧸ p) = r • mk x :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.smulCommClass","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁷ : Ring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nS : Type u_3\ninst✝⁴ : SMul S M\nP : Submodule R M\nT : Type u_4\ninst✝³ : SMul T R\ninst✝² : SMul T M\ninst✝¹ : IsScalarTower T R M\ninst✝ : SMulCommClass S T M\n⊢ SMulCommClass S T (HasQuotient.Quotient M P)","decl":"instance smulCommClass (T : Type*) [SMul T R] [SMul T M] [IsScalarTower T R M]\n    [SMulCommClass S T M] : SMulCommClass S T (M ⧸ P) where\n  smul_comm _x _y := Quotient.ind' fun _z => congr_arg mk (smul_comm _ _ _)\n\n"}
{"name":"Submodule.Quotient.isScalarTower","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁸ : Ring R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nS : Type u_3\ninst✝⁵ : SMul S M\nP : Submodule R M\nT : Type u_4\ninst✝⁴ : SMul T R\ninst✝³ : SMul T M\ninst✝² : IsScalarTower T R M\ninst✝¹ : SMul S T\ninst✝ : IsScalarTower S T M\n⊢ IsScalarTower S T (HasQuotient.Quotient M P)","decl":"instance isScalarTower (T : Type*) [SMul T R] [SMul T M] [IsScalarTower T R M] [SMul S T]\n    [IsScalarTower S T M] : IsScalarTower S T (M ⧸ P) where\n  smul_assoc _x _y := Quotient.ind' fun _z => congr_arg mk (smul_assoc _ _ _)\n\n"}
{"name":"Submodule.Quotient.isCentralScalar","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁷ : Ring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nS : Type u_3\ninst✝⁴ : SMul S M\nP : Submodule R M\ninst✝³ : SMul (MulOpposite S) R\ninst✝² : SMul (MulOpposite S) M\ninst✝¹ : IsScalarTower (MulOpposite S) R M\ninst✝ : IsCentralScalar S M\n⊢ IsCentralScalar S (HasQuotient.Quotient M P)","decl":"instance isCentralScalar [SMul Sᵐᵒᵖ R] [SMul Sᵐᵒᵖ M] [IsScalarTower Sᵐᵒᵖ R M]\n    [IsCentralScalar S M] : IsCentralScalar S (M ⧸ P) where\n  op_smul_eq_smul _x := Quotient.ind' fun _z => congr_arg mk <| op_smul_eq_smul _ _\n\n"}
{"name":"Submodule.Quotient.induction_on","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nC : HasQuotient.Quotient M p → Prop\nx : HasQuotient.Quotient M p\nH : ∀ (z : M), C (Submodule.Quotient.mk z)\n⊢ C x","decl":"@[elab_as_elim]\ntheorem induction_on {C : M ⧸ p → Prop} (x : M ⧸ p) (H : ∀ z, C (Submodule.Quotient.mk z)) :\n    C x := Quotient.inductionOn' x H\n\n"}
{"name":"Submodule.Quotient.mk_surjective","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Function.Surjective Submodule.Quotient.mk","decl":"theorem mk_surjective : Function.Surjective (@mk _ _ _ _ _ p) := by\n  rintro ⟨x⟩\n  exact ⟨x, rfl⟩\n\n"}
{"name":"Submodule.quot_hom_ext","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\np : Submodule R M\nM₂ : Type u_3\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nf g : LinearMap (RingHom.id R) (HasQuotient.Quotient M p) M₂\nh : ∀ (x : M), Eq (f (Submodule.Quotient.mk x)) (g (Submodule.Quotient.mk x))\n⊢ Eq f g","decl":"theorem quot_hom_ext (f g : (M ⧸ p) →ₗ[R] M₂) (h : ∀ x : M, f (Quotient.mk x) = g (Quotient.mk x)) :\n    f = g :=\n  LinearMap.ext fun x => Submodule.Quotient.induction_on _ x h\n\n"}
{"name":"Submodule.mkQ_apply","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nx : M\n⊢ Eq (p.mkQ x) (Submodule.Quotient.mk x)","decl":"@[simp]\ntheorem mkQ_apply (x : M) : p.mkQ x = Quotient.mk x :=\n  rfl\n\n"}
{"name":"Submodule.mkQ_surjective","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Function.Surjective ⇑p.mkQ","decl":"theorem mkQ_surjective : Function.Surjective p.mkQ := by\n  rintro ⟨x⟩; exact ⟨x, rfl⟩\n\n"}
{"name":"Submodule.linearMap_qext","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf g : LinearMap τ₁₂ (HasQuotient.Quotient M p) M₂\nh : Eq (f.comp p.mkQ) (g.comp p.mkQ)\n⊢ Eq f g","decl":"/-- Two `LinearMap`s from a quotient module are equal if their compositions with\n`submodule.mkQ` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext 1100] -- Porting note: increase priority so this applies before `LinearMap.ext`\ntheorem linearMap_qext ⦃f g : M ⧸ p →ₛₗ[τ₁₂] M₂⦄ (h : f.comp p.mkQ = g.comp p.mkQ) : f = g :=\n  LinearMap.ext fun x => Submodule.Quotient.induction_on _ x <| (LinearMap.congr_fun h :)\n\n"}
{"name":"Submodule.linearMap_qext_iff","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf g : LinearMap τ₁₂ (HasQuotient.Quotient M p) M₂\n⊢ Iff (Eq f g) (Eq (f.comp p.mkQ) (g.comp p.mkQ))","decl":"/-- Two `LinearMap`s from a quotient module are equal if their compositions with\n`submodule.mkQ` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext 1100] -- Porting note: increase priority so this applies before `LinearMap.ext`\ntheorem linearMap_qext ⦃f g : M ⧸ p →ₛₗ[τ₁₂] M₂⦄ (h : f.comp p.mkQ = g.comp p.mkQ) : f = g :=\n  LinearMap.ext fun x => Submodule.Quotient.induction_on _ x <| (LinearMap.congr_fun h :)\n\n"}
{"name":"Submodule.quotEquivOfEq_mk","module":"Mathlib.LinearAlgebra.Quotient.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\nh : Eq p p'\nx : M\n⊢ Eq ((p.quotEquivOfEq p' h) (Submodule.Quotient.mk x)) (Submodule.Quotient.mk x)","decl":"@[simp]\ntheorem quotEquivOfEq_mk (h : p = p') (x : M) :\n    Submodule.quotEquivOfEq p p' h (Submodule.Quotient.mk x) =\n      (Submodule.Quotient.mk x) :=\n  rfl\n\n"}
