{"name":"Matrix.permanent_diagonal","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nd : n → R\n⊢ Eq (Matrix.diagonal d).permanent (Finset.univ.prod fun i => d i)","decl":"@[simp]\ntheorem permanent_diagonal {d : n → R} : permanent (diagonal d) = ∏ i, d i := by\n  refine (sum_eq_single 1 (fun σ _ hσ ↦ ?_) (fun h ↦ (h <| mem_univ _).elim)).trans ?_\n  · match not_forall.mp (mt Equiv.ext hσ) with\n    | ⟨x, hx⟩ => exact Finset.prod_eq_zero (mem_univ x) (if_neg hx)\n  · simp only [Perm.one_apply, diagonal_apply_eq]\n\n"}
{"name":"Matrix.permanent_zero","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : Nonempty n\n⊢ Eq (Matrix.permanent 0) 0","decl":"@[simp]\ntheorem permanent_zero [Nonempty n] : permanent (0 : Matrix n n R) = 0 := by simp [permanent]\n\n"}
{"name":"Matrix.permanent_one","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\n⊢ Eq (Matrix.permanent 1) 1","decl":"@[simp]\ntheorem permanent_one : permanent (1 : Matrix n n R) = 1 := by\n  rw [← diagonal_one]; simp [-diagonal_one]\n\n"}
{"name":"Matrix.permanent_isEmpty","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : IsEmpty n\nA : Matrix n n R\n⊢ Eq A.permanent 1","decl":"theorem permanent_isEmpty [IsEmpty n] {A : Matrix n n R} : permanent A = 1 := by simp [permanent]\n\n"}
{"name":"Matrix.permanent_eq_one_of_card_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nA : Matrix n n R\nh : Eq (Fintype.card n) 0\n⊢ Eq A.permanent 1","decl":"theorem permanent_eq_one_of_card_eq_zero {A : Matrix n n R} (h : card n = 0) : permanent A = 1 :=\n  haveI : IsEmpty n := card_eq_zero_iff.mp h\n  permanent_isEmpty\n\n"}
{"name":"Matrix.permanent_unique","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"R : Type u_2\ninst✝³ : CommSemiring R\nn : Type u_3\ninst✝² : Unique n\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nA : Matrix n n R\n⊢ Eq A.permanent (A Inhabited.default Inhabited.default)","decl":"/-- If `n` has only one element, the permanent of an `n` by `n` matrix is just that element.\nAlthough `Unique` implies `DecidableEq` and `Fintype`, the instances might\nnot be syntactically equal. Thus, we need to fill in the args explicitly. -/\n@[simp]\ntheorem permanent_unique {n : Type*} [Unique n] [DecidableEq n] [Fintype n] (A : Matrix n n R) :\n    permanent A = A default default := by simp [permanent, univ_unique]\n\n"}
{"name":"Matrix.permanent_eq_elem_of_subsingleton","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nR : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : Subsingleton n\nA : Matrix n n R\nk : n\n⊢ Eq A.permanent (A k k)","decl":"theorem permanent_eq_elem_of_subsingleton [Subsingleton n] (A : Matrix n n R) (k : n) :\n    permanent A = A k k := by\n  have := uniqueOfSubsingleton k\n  convert permanent_unique A\n\n"}
{"name":"Matrix.permanent_eq_elem_of_card_eq_one","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nA : Matrix n n R\nh : Eq (Fintype.card n) 1\nk : n\n⊢ Eq A.permanent (A k k)","decl":"theorem permanent_eq_elem_of_card_eq_one {A : Matrix n n R} (h : card n = 1) (k : n) :\n    permanent A = A k k :=\n  haveI : Subsingleton n := card_le_one_iff_subsingleton.mp h.le\n  permanent_eq_elem_of_subsingleton _ _\n\n"}
{"name":"Matrix.permanent_transpose","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nM : Matrix n n R\n⊢ Eq M.transpose.permanent M.permanent","decl":"/-- Transposing a matrix preserves the permanent. -/\n@[simp]\ntheorem permanent_transpose (M : Matrix n n R) : Mᵀ.permanent = M.permanent := by\n  refine sum_bijective _ inv_involutive.bijective _ _ ?_\n  intro σ\n  apply Fintype.prod_equiv σ\n  simp\n\n"}
{"name":"Matrix.permanent_permute_cols","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nσ : Equiv.Perm n\nM : Matrix n n R\n⊢ Eq (M.submatrix (⇑σ) id).permanent M.permanent","decl":"/-- Permuting the columns does not change the permanent. -/\ntheorem permanent_permute_cols (σ : Perm n) (M : Matrix n n R) :\n    (M.submatrix σ id).permanent = M.permanent :=\n  (Group.mulLeft_bijective σ).sum_comp fun τ ↦ ∏ i : n, M (τ i) i\n\n"}
{"name":"Matrix.permanent_permute_rows","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nσ : Equiv.Perm n\nM : Matrix n n R\n⊢ Eq (M.submatrix id ⇑σ).permanent M.permanent","decl":"/-- Permuting the rows does not change the permanent. -/\ntheorem permanent_permute_rows (σ : Perm n) (M : Matrix n n R) :\n    (M.submatrix id σ).permanent = M.permanent := by\n  rw [← permanent_transpose, transpose_submatrix, permanent_permute_cols, permanent_transpose]\n\n"}
{"name":"Matrix.permanent_smul","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nM : Matrix n n R\nc : R\n⊢ Eq (HSMul.hSMul c M).permanent (HMul.hMul (HPow.hPow c (Fintype.card n)) M.permanent)","decl":"@[simp]\ntheorem permanent_smul (M : Matrix n n R) (c : R) :\n    permanent (c • M) = c ^ Fintype.card n * permanent M := by\n  simp only [permanent, smul_apply, smul_eq_mul, Finset.mul_sum]\n  congr\n  ext\n  rw [mul_comm]\n  conv in ∏ _ , c * _ => simp [mul_comm c];\n  exact prod_mul_pow_card.symm\n\n"}
{"name":"Matrix.permanent_updateCol_smul","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nM : Matrix n n R\nj : n\nc : R\nu : n → R\n⊢ Eq (M.updateCol j (HSMul.hSMul c u)).permanent (HMul.hMul c (M.updateCol j u).permanent)","decl":"@[simp]\ntheorem permanent_updateCol_smul (M : Matrix n n R) (j : n) (c : R) (u : n → R) :\n    permanent (updateCol M j <| c • u) = c * permanent (updateCol M j u) := by\n  simp only [permanent, ← mul_prod_erase _ _ (mem_univ j), updateCol_self, Pi.smul_apply,\n    smul_eq_mul, mul_sum, ← mul_assoc]\n  congr 1 with p\n  rw [Finset.prod_congr rfl (fun i hi ↦ ?_)]\n  simp only [ne_eq, ne_of_mem_erase hi, not_false_eq_true, updateCol_ne]\n\n"}
{"name":"Matrix.permanent_updateColumn_smul","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nM : Matrix n n R\nj : n\nc : R\nu : n → R\n⊢ Eq (M.updateCol j (HSMul.hSMul c u)).permanent (HMul.hMul c (M.updateCol j u).permanent)","decl":"@[deprecated (since := \"2024-12-11\")]\nalias permanent_updateColumn_smul := permanent_updateCol_smul\n\n"}
{"name":"Matrix.permanent_updateRow_smul","module":"Mathlib.LinearAlgebra.Matrix.Permanent","initialProofState":"n : Type u_1\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nR : Type u_2\ninst✝ : CommSemiring R\nM : Matrix n n R\nj : n\nc : R\nu : n → R\n⊢ Eq (M.updateRow j (HSMul.hSMul c u)).permanent (HMul.hMul c (M.updateRow j u).permanent)","decl":"@[simp]\ntheorem permanent_updateRow_smul (M : Matrix n n R) (j : n) (c : R) (u : n → R) :\n    permanent (updateRow M j <| c • u) = c * permanent (updateRow M j u) := by\n  rw [← permanent_transpose, ← updateCol_transpose, permanent_updateCol_smul,\n    updateCol_transpose, permanent_transpose]\n\n"}
