{"name":"Dynamics.IsDynNetIn.of_le","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nm n : Nat\nm_n : LE.le m n\ns : Set X\nh : Dynamics.IsDynNetIn T F U m s\n⊢ Dynamics.IsDynNetIn T F U n s","decl":"lemma IsDynNetIn.of_le {T : X → X} {F : Set X} {U : Set (X × X)} {m n : ℕ} (m_n : m ≤ n) {s : Set X}\n    (h : IsDynNetIn T F U m s) :\n    IsDynNetIn T F U n s :=\n  ⟨h.1, PairwiseDisjoint.mono h.2 (fun x ↦ ball_mono (dynEntourage_antitone T U m_n) x)⟩\n\n"}
{"name":"Dynamics.IsDynNetIn.of_entourage_subset","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU V : Set (Prod X X)\nU_V : HasSubset.Subset U V\nn : Nat\ns : Set X\nh : Dynamics.IsDynNetIn T F V n s\n⊢ Dynamics.IsDynNetIn T F U n s","decl":"lemma IsDynNetIn.of_entourage_subset {T : X → X} {F : Set X} {U V : Set (X × X)} (U_V : U ⊆ V)\n    {n : ℕ} {s : Set X} (h : IsDynNetIn T F V n s) :\n    IsDynNetIn T F U n s :=\n  ⟨h.1, PairwiseDisjoint.mono h.2 (fun x ↦ ball_mono (dynEntourage_monotone T n U_V) x)⟩\n\n"}
{"name":"Dynamics.isDynNetIn_empty","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n⊢ Dynamics.IsDynNetIn T F U n EmptyCollection.emptyCollection","decl":"lemma isDynNetIn_empty {T : X → X} {F : Set X} {U : Set (X × X)} {n : ℕ} :\n    IsDynNetIn T F U n ∅ :=\n  ⟨empty_subset F, pairwise_empty _⟩\n\n"}
{"name":"Dynamics.isDynNetIn_singleton","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\nx : X\nh : Membership.mem F x\n⊢ Dynamics.IsDynNetIn T F U n (Singleton.singleton x)","decl":"lemma isDynNetIn_singleton (T : X → X) {F : Set X} (U : Set (X × X)) (n : ℕ) {x : X} (h : x ∈ F) :\n    IsDynNetIn T F U n {x} :=\n  ⟨singleton_subset_iff.2 h, pairwise_singleton x _⟩\n\n"}
{"name":"Dynamics.IsDynNetIn.card_le_card_of_isDynCoverOf","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nn : Nat\ns t : Finset X\nhs : Dynamics.IsDynNetIn T F U n ↑s\nht : Dynamics.IsDynCoverOf T F U n ↑t\n⊢ LE.le s.card t.card","decl":"/-- Given an entourage `U` and a time `n`, a dynamical net has a smaller cardinality than\n  a dynamical cover. This lemma is the first of two key results to compare two versions of\n  topological entropy: with cover and with nets, the second being `coverMincard_le_netMaxcard`.-/\nlemma IsDynNetIn.card_le_card_of_isDynCoverOf {T : X → X} {F : Set X} {U : Set (X × X)}\n    (U_symm : SymmetricRel U) {n : ℕ} {s t : Finset X} (hs : IsDynNetIn T F U n s)\n    (ht : IsDynCoverOf T F U n t) :\n    s.card ≤ t.card := by\n  have (x : X) (x_s : x ∈ s) : ∃ z ∈ t, x ∈ ball z (dynEntourage T U n) := by\n    specialize ht (hs.1 x_s)\n    simp only [Finset.coe_sort_coe, mem_iUnion, Subtype.exists, exists_prop] at ht\n    exact ht\n  choose! F s_t using this\n  simp only [mem_ball_symmetry (U_symm.dynEntourage T n)] at s_t\n  apply Finset.card_le_card_of_injOn F (fun x x_s ↦ (s_t x x_s).1)\n  exact fun x x_s y y_s Fx_Fy ↦\n    PairwiseDisjoint.elim_set hs.2 x_s y_s (F x) (s_t x x_s).2 (Fx_Fy ▸ (s_t y y_s).2)\n\n"}
{"name":"Dynamics.IsDynNetIn.card_le_netMaxcard","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\ns : Finset X\nh : Dynamics.IsDynNetIn T F U n ↑s\n⊢ LE.le (↑s.card) (Dynamics.netMaxcard T F U n)","decl":"lemma IsDynNetIn.card_le_netMaxcard {T : X → X} {F : Set X} {U : Set (X × X)} {n : ℕ} {s : Finset X}\n    (h : IsDynNetIn T F U n s) :\n    s.card ≤ netMaxcard T F U n :=\n  le_iSup₂ (α := ℕ∞) s h\n\n"}
{"name":"Dynamics.netMaxcard_monotone_time","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\n⊢ Monotone fun n => Dynamics.netMaxcard T F U n","decl":"lemma netMaxcard_monotone_time (T : X → X) (F : Set X) (U : Set (X × X)) :\n    Monotone (fun n : ℕ ↦ netMaxcard T F U n) :=\n  fun _ _ m_n ↦ biSup_mono (fun _ h ↦ h.of_le m_n)\n\n"}
{"name":"Dynamics.netMaxcard_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nn : Nat\n⊢ Antitone fun U => Dynamics.netMaxcard T F U n","decl":"lemma netMaxcard_antitone (T : X → X) (F : Set X) (n : ℕ) :\n    Antitone (fun U : Set (X × X) ↦ netMaxcard T F U n) :=\n  fun _ _ U_V ↦ biSup_mono (fun _ h ↦ h.of_entourage_subset U_V)\n\n"}
{"name":"Dynamics.netMaxcard_finite_iff","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n⊢ Iff (LT.lt (Dynamics.netMaxcard T F U n) Top.top) (Exists fun s => And (Dynamics.IsDynNetIn T F U n ↑s) (Eq (↑s.card) (Dynamics.netMaxcard T F U n)))","decl":"lemma netMaxcard_finite_iff (T : X → X) (F : Set X) (U : Set (X × X)) (n : ℕ) :\n    netMaxcard T F U n < ⊤ ↔\n    ∃ s : Finset X, IsDynNetIn T F U n s ∧ (s.card : ℕ∞) = netMaxcard T F U n := by\n  apply Iff.intro <;> intro h\n  · rcases WithTop.ne_top_iff_exists.1 h.ne with ⟨k, k_max⟩\n    rw [← k_max]\n    simp only [ENat.some_eq_coe, Nat.cast_inj]\n    -- The criterion we want to use is `Nat.sSup_mem`. We rewrite `netMaxcard` with an `sSup`,\n    -- then check its `BddAbove` and `Nonempty` hypotheses.\n    have : netMaxcard T F U n\n      = sSup (WithTop.some '' (Finset.card '' {s : Finset X | IsDynNetIn T F U n s})) := by\n      rw [netMaxcard, ← image_comp, sSup_image]\n      simp only [mem_setOf_eq, ENat.some_eq_coe, Function.comp_apply]\n    rw [this] at k_max\n    have h_bdda : BddAbove (Finset.card '' {s : Finset X | IsDynNetIn T F U n s}) := by\n      refine ⟨k, mem_upperBounds.2 ?_⟩\n      simp only [mem_image, mem_setOf_eq, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n      intro s h\n      rw [← WithTop.coe_le_coe, k_max]\n      apply le_sSup\n      simp only [ENat.some_eq_coe, mem_image, mem_setOf_eq, Nat.cast_inj, exists_eq_right]\n      exact Filter.frequently_principal.mp fun a ↦ a h rfl\n    have h_nemp : (Finset.card '' {s : Finset X | IsDynNetIn T F U n s}).Nonempty := by\n      refine ⟨0, ?_⟩\n      simp only [mem_image, mem_setOf_eq, Finset.card_eq_zero, exists_eq_right, Finset.coe_empty]\n      exact isDynNetIn_empty\n    rw [← WithTop.coe_sSup' h_bdda, ENat.some_eq_coe, Nat.cast_inj] at k_max\n    have key := Nat.sSup_mem h_nemp h_bdda\n    rw [← k_max, mem_image] at key\n    simp only [mem_setOf_eq] at key\n    exact key\n  · rcases h with ⟨s, _, s_netMaxcard⟩\n    rw [← s_netMaxcard]\n    exact WithTop.coe_lt_top s.card\n\n"}
{"name":"Dynamics.netMaxcard_empty","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\nn : Nat\n⊢ Eq (Dynamics.netMaxcard T EmptyCollection.emptyCollection U n) 0","decl":"@[simp]\nlemma netMaxcard_empty {T : X → X} {U : Set (X × X)} {n : ℕ} : netMaxcard T ∅ U n = 0 := by\n  rw [netMaxcard, ← bot_eq_zero, iSup₂_eq_bot]\n  intro s s_net\n  replace s_net := subset_empty_iff.1 s_net.1\n  norm_cast at s_net\n  rw [s_net, Finset.card_empty, CharP.cast_eq_zero, bot_eq_zero']\n\n"}
{"name":"Dynamics.netMaxcard_eq_zero_iff","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n⊢ Iff (Eq (Dynamics.netMaxcard T F U n) 0) (Eq F EmptyCollection.emptyCollection)","decl":"lemma netMaxcard_eq_zero_iff (T : X → X) (F : Set X) (U : Set (X × X)) (n : ℕ) :\n    netMaxcard T F U n = 0 ↔ F = ∅ := by\n  refine Iff.intro (fun h ↦ ?_) (fun h ↦ by rw [h, netMaxcard_empty])\n  rw [eq_empty_iff_forall_not_mem]\n  intro x x_F\n  have key := isDynNetIn_singleton T U n x_F\n  rw [← Finset.coe_singleton] at key\n  replace key := key.card_le_netMaxcard\n  rw [Finset.card_singleton, Nat.cast_one, h] at key\n  exact key.not_lt zero_lt_one\n\n"}
{"name":"Dynamics.one_le_netMaxcard_iff","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n⊢ Iff (LE.le 1 (Dynamics.netMaxcard T F U n)) F.Nonempty","decl":"lemma one_le_netMaxcard_iff (T : X → X) (F : Set X) (U : Set (X × X)) (n : ℕ) :\n    1 ≤ netMaxcard T F U n ↔ F.Nonempty := by\n  rw [ENat.one_le_iff_ne_zero, nonempty_iff_ne_empty]\n  exact not_iff_not.2 (netMaxcard_eq_zero_iff T F U n)\n\n"}
{"name":"Dynamics.netMaxcard_zero","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n⊢ Eq (Dynamics.netMaxcard T F U 0) 1","decl":"lemma netMaxcard_zero (T : X → X) {F : Set X} (h : F.Nonempty) (U : Set (X × X)) :\n    netMaxcard T F U 0 = 1 := by\n  apply (iSup₂_le _).antisymm ((one_le_netMaxcard_iff T F U 0).2 h)\n  intro s ⟨_, s_net⟩\n  simp only [ball, dynEntourage_zero, preimage_univ] at s_net\n  norm_cast\n  refine Finset.card_le_one.2 (fun x x_s y y_s ↦ ?_)\n  exact PairwiseDisjoint.elim_set s_net x_s y_s x (mem_univ x) (mem_univ x)\n\n"}
{"name":"Dynamics.netMaxcard_univ","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nn : Nat\n⊢ Eq (Dynamics.netMaxcard T F Set.univ n) 1","decl":"lemma netMaxcard_univ (T : X → X) {F : Set X} (h : F.Nonempty) (n : ℕ) :\n    netMaxcard T F univ n = 1 := by\n  apply (iSup₂_le _).antisymm ((one_le_netMaxcard_iff T F univ n).2 h)\n  intro s ⟨_, s_net⟩\n  simp only [ball, dynEntourage_univ, preimage_univ] at s_net\n  norm_cast\n  refine Finset.card_le_one.2 (fun x x_s y y_s ↦ ?_)\n  exact PairwiseDisjoint.elim_set s_net x_s y_s x (mem_univ x) (mem_univ x)\n\n"}
{"name":"Dynamics.netMaxcard_infinite_iff","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n⊢ Iff (Eq (Dynamics.netMaxcard T F U n) Top.top) (∀ (k : Nat), Exists fun s => And (Dynamics.IsDynNetIn T F U n ↑s) (LE.le k s.card))","decl":"lemma netMaxcard_infinite_iff (T : X → X) (F : Set X) (U : Set (X × X)) (n : ℕ) :\n    netMaxcard T F U n = ⊤ ↔ ∀ k : ℕ, ∃ s : Finset X, IsDynNetIn T F U n s ∧ k ≤ s.card := by\n  apply Iff.intro <;> intro h\n  · intro k\n    rw [netMaxcard, iSup_subtype', iSup_eq_top] at h\n    specialize h k (ENat.coe_lt_top k)\n    simp only [Nat.cast_lt, Subtype.exists, exists_prop] at h\n    rcases h with ⟨s, s_net, s_k⟩\n    exact ⟨s, ⟨s_net, s_k.le⟩⟩\n  · refine WithTop.forall_gt_iff_eq_top.1 fun k ↦ ?_\n    specialize h (k + 1)\n    rcases h with ⟨s, s_net, s_card⟩\n    apply s_net.card_le_netMaxcard.trans_lt'\n    rw [ENat.some_eq_coe, Nat.cast_lt]\n    exact (lt_add_one k).trans_le s_card\n\n"}
{"name":"Dynamics.netMaxcard_le_coverMincard","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nn : Nat\n⊢ LE.le (Dynamics.netMaxcard T F U n) (Dynamics.coverMincard T F U n)","decl":"lemma netMaxcard_le_coverMincard (T : X → X) (F : Set X) {U : Set (X × X)} (U_symm : SymmetricRel U)\n    (n : ℕ) :\n    netMaxcard T F U n ≤ coverMincard T F U n := by\n  rcases eq_top_or_lt_top (coverMincard T F U n) with h | h\n  · exact h ▸ le_top\n  · rcases ((coverMincard_finite_iff T F U n).1 h) with ⟨t, t_cover, t_mincard⟩\n    rw [← t_mincard]\n    exact iSup₂_le (fun s s_net ↦ Nat.cast_le.2 (s_net.card_le_card_of_isDynCoverOf U_symm t_cover))\n\n"}
{"name":"Dynamics.coverMincard_le_netMaxcard","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nU_rfl : HasSubset.Subset idRel U\nU_symm : SymmetricRel U\nn : Nat\n⊢ LE.le (Dynamics.coverMincard T F (compRel U U) n) (Dynamics.netMaxcard T F U n)","decl":"/-- Given an entourage `U` and a time `n`, a minimal dynamical cover by `U ○ U` has a smaller\n  cardinality than a maximal dynamical net by `U`. This lemma is the second of two key results to\n  compare two versions topological entropy: with cover and with nets.-/\nlemma coverMincard_le_netMaxcard (T : X → X) (F : Set X) {U : Set (X × X)} (U_rfl : idRel ⊆ U)\n    (U_symm : SymmetricRel U) (n : ℕ) :\n    coverMincard T F (U ○ U) n ≤ netMaxcard T F U n := by\n  classical\n  -- WLOG, there exists a maximal dynamical net `s`.\n  rcases (eq_top_or_lt_top (netMaxcard T F U n)) with h | h\n  · exact h ▸ le_top\n  rcases ((netMaxcard_finite_iff T F U n).1 h) with ⟨s, s_net, s_netMaxcard⟩\n  rw [← s_netMaxcard]\n  apply IsDynCoverOf.coverMincard_le_card\n  --  We have to check that `s` is a cover for `dynEntourage T F (U ○ U) n`.\n  -- If `s` is not a cover, then we can add to `s` a point `x` which is not covered\n  -- and get a new net. This contradicts the maximality of `s`.\n  by_contra h\n  rcases not_subset.1 h with ⟨x, x_F, x_uncov⟩\n  simp only [Finset.mem_coe, mem_iUnion, exists_prop, not_exists, not_and] at x_uncov\n  have larger_net : IsDynNetIn T F U n (insert x s) :=\n    And.intro (insert_subset x_F s_net.1) (pairwiseDisjoint_insert.2 (And.intro s_net.2\n      (fun y y_s _ ↦ (disjoint_left.2 (fun z z_x z_y ↦ x_uncov y y_s\n        (mem_ball_dynEntourage_comp T n U_symm x y (nonempty_of_mem ⟨z_x, z_y⟩)))))))\n  rw [← Finset.coe_insert x s] at larger_net\n  apply larger_net.card_le_netMaxcard.not_lt\n  rw [← s_netMaxcard, Nat.cast_lt]\n  refine (lt_add_one s.card).trans_eq (Finset.card_insert_of_not_mem fun x_s ↦ ?_).symm\n  apply x_uncov x x_s (ball_mono (dynEntourage_monotone T n (subset_comp_self U_rfl)) x\n    (ball_mono (idRel_subset_dynEntourage T U_rfl n) x _))\n  simp only [ball, mem_preimage, mem_idRel]\n\n"}
{"name":"Dynamics.log_netMaxcard_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\nn : Nat\n⊢ LE.le 0 (↑(Dynamics.netMaxcard T F U n)).log","decl":"lemma log_netMaxcard_nonneg (T : X → X) {F : Set X} (h : F.Nonempty) (U : Set (X × X)) (n : ℕ) :\n    0 ≤ log (netMaxcard T F U n) := by\n  apply zero_le_log_iff.2\n  rw [← ENat.toENNReal_one, ENat.toENNReal_le]\n  exact (one_le_netMaxcard_iff T F U n).2 h\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\n⊢ Antitone fun U => Dynamics.netEntropyInfEntourage T F U","decl":"lemma netEntropyInfEntourage_antitone (T : X → X) (F : Set X) :\n    Antitone (fun U : Set (X × X) ↦ netEntropyInfEntourage T F U) :=\n  fun _ _ U_V ↦ (liminf_le_liminf) (Eventually.of_forall\n    fun n ↦ monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n      (log_monotone (ENat.toENNReal_mono (netMaxcard_antitone T F n U_V))))\n\n"}
{"name":"Dynamics.netEntropyEntourage_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\n⊢ Antitone fun U => Dynamics.netEntropyEntourage T F U","decl":"lemma netEntropyEntourage_antitone (T : X → X) (F : Set X) :\n    Antitone (fun U : Set (X × X) ↦ netEntropyEntourage T F U) :=\n  fun _ _ U_V ↦ (limsup_le_limsup) (Eventually.of_forall\n    fun n ↦ (monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n      (log_monotone (ENat.toENNReal_mono (netMaxcard_antitone T F n U_V)))))\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_le_netEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\n⊢ LE.le (Dynamics.netEntropyInfEntourage T F U) (Dynamics.netEntropyEntourage T F U)","decl":"lemma netEntropyInfEntourage_le_netEntropyEntourage (T : X → X) (F : Set X) (U : Set (X × X)) :\n    netEntropyInfEntourage T F U ≤ netEntropyEntourage T F U := liminf_le_limsup\n\n"}
{"name":"Dynamics.netEntropyEntourage_empty","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\n⊢ Eq (Dynamics.netEntropyEntourage T EmptyCollection.emptyCollection U) Bot.bot","decl":"@[simp]\nlemma netEntropyEntourage_empty {T : X → X} {U : Set (X × X)} : netEntropyEntourage T ∅ U = ⊥ := by\n  suffices h : ∀ᶠ n : ℕ in atTop, log (netMaxcard T ∅ U n) / n = ⊥ by\n    rw [netEntropyEntourage, limsup_congr h]\n    exact limsup_const ⊥\n  simp only [netMaxcard_empty, ENat.toENNReal_zero, log_zero, eventually_atTop]\n  exact ⟨1, fun n n_pos ↦ bot_div_of_pos_ne_top (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)⟩\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_empty","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\n⊢ Eq (Dynamics.netEntropyInfEntourage T EmptyCollection.emptyCollection U) Bot.bot","decl":"@[simp]\nlemma netEntropyInfEntourage_empty {T : X → X} {U : Set (X × X)} :\n    netEntropyInfEntourage T ∅ U = ⊥ :=\n  eq_bot_mono (netEntropyInfEntourage_le_netEntropyEntourage T ∅ U) netEntropyEntourage_empty\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n⊢ LE.le 0 (Dynamics.netEntropyInfEntourage T F U)","decl":"lemma netEntropyInfEntourage_nonneg (T : X → X) {F : Set X} (h : F.Nonempty) (U : Set (X × X)) :\n    0 ≤ netEntropyInfEntourage T F U :=\n  (le_iInf fun n ↦ div_nonneg (log_netMaxcard_nonneg T h U n) (Nat.cast_nonneg' n)).trans\n    iInf_le_liminf\n\n"}
{"name":"Dynamics.netEntropyEntourage_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n⊢ LE.le 0 (Dynamics.netEntropyEntourage T F U)","decl":"lemma netEntropyEntourage_nonneg (T : X → X) {F : Set X} (h : F.Nonempty) (U : Set (X × X)) :\n    0 ≤ netEntropyEntourage T F U :=\n  (netEntropyInfEntourage_nonneg T h U).trans (netEntropyInfEntourage_le_netEntropyEntourage T F U)\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_univ","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\n⊢ Eq (Dynamics.netEntropyInfEntourage T F Set.univ) 0","decl":"lemma netEntropyInfEntourage_univ (T : X → X) {F : Set X} (h : F.Nonempty) :\n    netEntropyInfEntourage T F univ = 0 := by simp [netEntropyInfEntourage, netMaxcard_univ T h]\n\n"}
{"name":"Dynamics.netEntropyEntourage_univ","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\n⊢ Eq (Dynamics.netEntropyEntourage T F Set.univ) 0","decl":"lemma netEntropyEntourage_univ (T : X → X) {F : Set X} (h : F.Nonempty) :\n    netEntropyEntourage T F univ = 0 := by simp [netEntropyEntourage, netMaxcard_univ T h]\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_le_coverEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nU_symm : SymmetricRel U\n⊢ LE.le (Dynamics.netEntropyInfEntourage T F U) (Dynamics.coverEntropyInfEntourage T F U)","decl":"lemma netEntropyInfEntourage_le_coverEntropyInfEntourage (T : X → X) (F : Set X) {U : Set (X × X)}\n    (U_symm : SymmetricRel U) :\n    netEntropyInfEntourage T F U ≤ coverEntropyInfEntourage T F U :=\n  (liminf_le_liminf) (Eventually.of_forall fun n ↦ (div_le_div_right_of_nonneg (Nat.cast_nonneg' n)\n    (log_monotone (ENat.toENNReal_le.2 (netMaxcard_le_coverMincard T F U_symm n)))))\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_le_netEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nU_rfl : HasSubset.Subset idRel U\nU_symm : SymmetricRel U\n⊢ LE.le (Dynamics.coverEntropyInfEntourage T F (compRel U U)) (Dynamics.netEntropyInfEntourage T F U)","decl":"lemma coverEntropyInfEntourage_le_netEntropyInfEntourage (T : X → X) (F : Set X) {U : Set (X × X)}\n    (U_rfl : idRel ⊆ U) (U_symm : SymmetricRel U) :\n    coverEntropyInfEntourage T F (U ○ U) ≤ netEntropyInfEntourage T F U := by\n  refine (liminf_le_liminf) (Eventually.of_forall fun n ↦ ?_)\n  apply div_le_div_right_of_nonneg (Nat.cast_nonneg' n) (log_monotone _)\n  exact ENat.toENNReal_le.2 (coverMincard_le_netMaxcard T F U_rfl U_symm n)\n\n"}
{"name":"Dynamics.netEntropyEntourage_le_coverEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nU_symm : SymmetricRel U\n⊢ LE.le (Dynamics.netEntropyEntourage T F U) (Dynamics.coverEntropyEntourage T F U)","decl":"lemma netEntropyEntourage_le_coverEntropyEntourage (T : X → X) (F : Set X) {U : Set (X × X)}\n    (U_symm : SymmetricRel U) :\n    netEntropyEntourage T F U ≤ coverEntropyEntourage T F U := by\n  refine (limsup_le_limsup) (Eventually.of_forall fun n ↦ ?_)\n  apply div_le_div_right_of_nonneg (Nat.cast_nonneg' n) (log_monotone _)\n  exact ENat.toENNReal_le.2 (netMaxcard_le_coverMincard T F U_symm n)\n\n"}
{"name":"Dynamics.coverEntropyEntourage_le_netEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nU_rfl : HasSubset.Subset idRel U\nU_symm : SymmetricRel U\n⊢ LE.le (Dynamics.coverEntropyEntourage T F (compRel U U)) (Dynamics.netEntropyEntourage T F U)","decl":"lemma coverEntropyEntourage_le_netEntropyEntourage (T : X → X) (F : Set X) {U : Set (X × X)}\n    (U_rfl : idRel ⊆ U) (U_symm : SymmetricRel U) :\n    coverEntropyEntourage T F (U ○ U) ≤ netEntropyEntourage T F U := by\n  refine (limsup_le_limsup) (Eventually.of_forall fun n ↦ ?_)\n  apply div_le_div_right_of_nonneg (Nat.cast_nonneg' n) (log_monotone _)\n  exact ENat.toENNReal_le.2 (coverMincard_le_netMaxcard T F U_rfl U_symm n)\n\n"}
{"name":"Dynamics.coverEntropyInf_eq_iSup_netEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\n⊢ Eq (Dynamics.coverEntropyInf T F) (iSup fun U => iSup fun h => Dynamics.netEntropyInfEntourage T F U)","decl":"/-- Bowen-Dinaburg's definition of topological entropy using nets is\n  `⨆ U ∈ 𝓤 X, netEntropyEntourage T F U`. This quantity is the same as the topological entropy using\n  covers, so there is no need to define a new notion of topological entropy. This version of the\n  theorem relates the `liminf` versions of topological entropy.-/\ntheorem coverEntropyInf_eq_iSup_netEntropyInfEntourage :\n    coverEntropyInf T F = ⨆ U ∈ 𝓤 X, netEntropyInfEntourage T F U := by\n  apply le_antisymm <;> refine iSup₂_le fun U U_uni ↦ ?_\n  · rcases (comp_symm_mem_uniformity_sets U_uni) with ⟨V, V_uni, V_symm, V_comp_U⟩\n    apply (coverEntropyInfEntourage_antitone T F V_comp_U).trans (le_iSup₂_of_le V V_uni _)\n    exact coverEntropyInfEntourage_le_netEntropyInfEntourage T F (refl_le_uniformity V_uni) V_symm\n  · apply (netEntropyInfEntourage_antitone T F (symmetrizeRel_subset_self U)).trans\n    apply (le_iSup₂ (symmetrizeRel U) (symmetrize_mem_uniformity U_uni)).trans'\n    exact netEntropyInfEntourage_le_coverEntropyInfEntourage T F (symmetric_symmetrizeRel U)\n\n"}
{"name":"Dynamics.coverEntropy_eq_iSup_netEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\n⊢ Eq (Dynamics.coverEntropy T F) (iSup fun U => iSup fun h => Dynamics.netEntropyEntourage T F U)","decl":"/-- Bowen-Dinaburg's definition of topological entropy using nets is\n  `⨆ U ∈ 𝓤 X, netEntropyEntourage T F U`. This quantity is the same as the topological entropy using\n  covers, so there is no need to define a new notion of topological entropy. This version of the\n  theorem relates the `limsup` versions of topological entropy.-/\ntheorem coverEntropy_eq_iSup_netEntropyEntourage :\n    coverEntropy T F = ⨆ U ∈ 𝓤 X, netEntropyEntourage T F U := by\n  apply le_antisymm <;> refine iSup₂_le fun U U_uni ↦ ?_\n  · rcases (comp_symm_mem_uniformity_sets U_uni) with ⟨V, V_uni, V_symm, V_comp_U⟩\n    apply (coverEntropyEntourage_antitone T F V_comp_U).trans (le_iSup₂_of_le V V_uni _)\n    exact coverEntropyEntourage_le_netEntropyEntourage T F (refl_le_uniformity V_uni) V_symm\n  · apply (netEntropyEntourage_antitone T F (symmetrizeRel_subset_self U)).trans\n    apply (le_iSup₂ (symmetrizeRel U) (symmetrize_mem_uniformity U_uni)).trans'\n    exact netEntropyEntourage_le_coverEntropyEntourage T F (symmetric_symmetrizeRel U)\n\n"}
{"name":"Dynamics.coverEntropyInf_eq_iSup_basis_netEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nι : Sort u_2\np : ι → Prop\ns : ι → Set (Prod X X)\nh : (uniformity X).HasBasis p s\nT : X → X\nF : Set X\n⊢ Eq (Dynamics.coverEntropyInf T F) (iSup fun i => iSup fun x => Dynamics.netEntropyInfEntourage T F (s i))","decl":"lemma coverEntropyInf_eq_iSup_basis_netEntropyInfEntourage {ι : Sort*} {p : ι → Prop}\n    {s : ι → Set (X × X)} (h : (𝓤 X).HasBasis p s) (T : X → X) (F : Set X) :\n    coverEntropyInf T F = ⨆ (i : ι) (_ : p i), netEntropyInfEntourage T F (s i) := by\n  rw [coverEntropyInf_eq_iSup_netEntropyInfEntourage T F]\n  apply (iSup₂_mono' fun i h_i ↦ ⟨s i, HasBasis.mem_of_mem h h_i, le_refl _⟩).antisymm'\n  refine iSup₂_le fun U U_uni ↦ ?_\n  rcases (HasBasis.mem_iff h).1 U_uni with ⟨i, h_i, si_U⟩\n  apply (netEntropyInfEntourage_antitone T F si_U).trans\n  exact le_iSup₂ (f := fun (i : ι) (_ : p i) ↦ netEntropyInfEntourage T F (s i)) i h_i\n\n"}
{"name":"Dynamics.coverEntropy_eq_iSup_basis_netEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nι : Sort u_2\np : ι → Prop\ns : ι → Set (Prod X X)\nh : (uniformity X).HasBasis p s\nT : X → X\nF : Set X\n⊢ Eq (Dynamics.coverEntropy T F) (iSup fun i => iSup fun x => Dynamics.netEntropyEntourage T F (s i))","decl":"lemma coverEntropy_eq_iSup_basis_netEntropyEntourage {ι : Sort*} {p : ι → Prop}\n    {s : ι → Set (X × X)} (h : (𝓤 X).HasBasis p s) (T : X → X) (F : Set X) :\n    coverEntropy T F = ⨆ (i : ι) (_ : p i), netEntropyEntourage T F (s i) := by\n  rw [coverEntropy_eq_iSup_netEntropyEntourage T F]\n  apply (iSup₂_mono' fun i h_i ↦ ⟨s i, HasBasis.mem_of_mem h h_i, le_refl _⟩).antisymm'\n  refine iSup₂_le fun U U_uni ↦ ?_\n  rcases (HasBasis.mem_iff h).1 U_uni with ⟨i, h_i, si_U⟩\n  apply (netEntropyEntourage_antitone T F si_U).trans _\n  exact le_iSup₂ (f := fun (i : ι) (_ : p i) ↦ netEntropyEntourage T F (s i)) i h_i\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_le_coverEntropyInf","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nU : Set (Prod X X)\nh : Membership.mem (uniformity X) U\n⊢ LE.le (Dynamics.netEntropyInfEntourage T F U) (Dynamics.coverEntropyInf T F)","decl":"lemma netEntropyInfEntourage_le_coverEntropyInf {U : Set (X × X)} (h : U ∈ 𝓤 X) :\n    netEntropyInfEntourage T F U ≤ coverEntropyInf T F :=\n  coverEntropyInf_eq_iSup_netEntropyInfEntourage T F ▸\n    le_iSup₂ (f := fun (U : Set (X × X)) (_ : U ∈ 𝓤 X) ↦ netEntropyInfEntourage T F U) U h\n\n"}
{"name":"Dynamics.netEntropyEntourage_le_coverEntropy","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nU : Set (Prod X X)\nh : Membership.mem (uniformity X) U\n⊢ LE.le (Dynamics.netEntropyEntourage T F U) (Dynamics.coverEntropy T F)","decl":"lemma netEntropyEntourage_le_coverEntropy {U : Set (X × X)} (h : U ∈ 𝓤 X) :\n    netEntropyEntourage T F U ≤ coverEntropy T F :=\n  coverEntropy_eq_iSup_netEntropyEntourage T F ▸\n    le_iSup₂ (f := fun (U : Set (X × X)) (_ : U ∈ 𝓤 X) ↦ netEntropyEntourage T F U) U h\n\n"}
