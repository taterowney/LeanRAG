{"name":"Dynamics.IsDynNetIn.of_le","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nm n : Nat\nm_n : LE.le m n\ns : Set X\nh : Dynamics.IsDynNetIn T F U m s\n‚ä¢ Dynamics.IsDynNetIn T F U n s","decl":"lemma IsDynNetIn.of_le {T : X ‚Üí X} {F : Set X} {U : Set (X √ó X)} {m n : ‚Ñï} (m_n : m ‚â§ n) {s : Set X}\n    (h : IsDynNetIn T F U m s) :\n    IsDynNetIn T F U n s :=\n  ‚ü®h.1, PairwiseDisjoint.mono h.2 (fun x ‚Ü¶ ball_mono (dynEntourage_antitone T U m_n) x)‚ü©\n\n"}
{"name":"Dynamics.IsDynNetIn.of_entourage_subset","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU V : Set (Prod X X)\nU_V : HasSubset.Subset U V\nn : Nat\ns : Set X\nh : Dynamics.IsDynNetIn T F V n s\n‚ä¢ Dynamics.IsDynNetIn T F U n s","decl":"lemma IsDynNetIn.of_entourage_subset {T : X ‚Üí X} {F : Set X} {U V : Set (X √ó X)} (U_V : U ‚äÜ V)\n    {n : ‚Ñï} {s : Set X} (h : IsDynNetIn T F V n s) :\n    IsDynNetIn T F U n s :=\n  ‚ü®h.1, PairwiseDisjoint.mono h.2 (fun x ‚Ü¶ ball_mono (dynEntourage_monotone T n U_V) x)‚ü©\n\n"}
{"name":"Dynamics.isDynNetIn_empty","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Dynamics.IsDynNetIn T F U n EmptyCollection.emptyCollection","decl":"lemma isDynNetIn_empty {T : X ‚Üí X} {F : Set X} {U : Set (X √ó X)} {n : ‚Ñï} :\n    IsDynNetIn T F U n ‚àÖ :=\n  ‚ü®empty_subset F, pairwise_empty _‚ü©\n\n"}
{"name":"Dynamics.isDynNetIn_singleton","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\nx : X\nh : Membership.mem F x\n‚ä¢ Dynamics.IsDynNetIn T F U n (Singleton.singleton x)","decl":"lemma isDynNetIn_singleton (T : X ‚Üí X) {F : Set X} (U : Set (X √ó X)) (n : ‚Ñï) {x : X} (h : x ‚àà F) :\n    IsDynNetIn T F U n {x} :=\n  ‚ü®singleton_subset_iff.2 h, pairwise_singleton x _‚ü©\n\n"}
{"name":"Dynamics.IsDynNetIn.card_le_card_of_isDynCoverOf","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nn : Nat\ns t : Finset X\nhs : Dynamics.IsDynNetIn T F U n ‚Üës\nht : Dynamics.IsDynCoverOf T F U n ‚Üët\n‚ä¢ LE.le s.card t.card","decl":"/-- Given an entourage `U` and a time `n`, a dynamical net has a smaller cardinality than\n  a dynamical cover. This lemma is the first of two key results to compare two versions of\n  topological entropy: with cover and with nets, the second being `coverMincard_le_netMaxcard`.-/\nlemma IsDynNetIn.card_le_card_of_isDynCoverOf {T : X ‚Üí X} {F : Set X} {U : Set (X √ó X)}\n    (U_symm : SymmetricRel U) {n : ‚Ñï} {s t : Finset X} (hs : IsDynNetIn T F U n s)\n    (ht : IsDynCoverOf T F U n t) :\n    s.card ‚â§ t.card := by\n  have (x : X) (x_s : x ‚àà s) : ‚àÉ z ‚àà t, x ‚àà ball z (dynEntourage T U n) := by\n    specialize ht (hs.1 x_s)\n    simp only [Finset.coe_sort_coe, mem_iUnion, Subtype.exists, exists_prop] at ht\n    exact ht\n  choose! F s_t using this\n  simp only [mem_ball_symmetry (U_symm.dynEntourage T n)] at s_t\n  apply Finset.card_le_card_of_injOn F (fun x x_s ‚Ü¶ (s_t x x_s).1)\n  exact fun x x_s y y_s Fx_Fy ‚Ü¶\n    PairwiseDisjoint.elim_set hs.2 x_s y_s (F x) (s_t x x_s).2 (Fx_Fy ‚ñ∏ (s_t y y_s).2)\n\n"}
{"name":"Dynamics.IsDynNetIn.card_le_netMaxcard","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\ns : Finset X\nh : Dynamics.IsDynNetIn T F U n ‚Üës\n‚ä¢ LE.le (‚Üës.card) (Dynamics.netMaxcard T F U n)","decl":"lemma IsDynNetIn.card_le_netMaxcard {T : X ‚Üí X} {F : Set X} {U : Set (X √ó X)} {n : ‚Ñï} {s : Finset X}\n    (h : IsDynNetIn T F U n s) :\n    s.card ‚â§ netMaxcard T F U n :=\n  le_iSup‚ÇÇ (Œ± := ‚Ñï‚àû) s h\n\n"}
{"name":"Dynamics.netMaxcard_monotone_time","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\n‚ä¢ Monotone fun n => Dynamics.netMaxcard T F U n","decl":"lemma netMaxcard_monotone_time (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) :\n    Monotone (fun n : ‚Ñï ‚Ü¶ netMaxcard T F U n) :=\n  fun _ _ m_n ‚Ü¶ biSup_mono (fun _ h ‚Ü¶ h.of_le m_n)\n\n"}
{"name":"Dynamics.netMaxcard_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nn : Nat\n‚ä¢ Antitone fun U => Dynamics.netMaxcard T F U n","decl":"lemma netMaxcard_antitone (T : X ‚Üí X) (F : Set X) (n : ‚Ñï) :\n    Antitone (fun U : Set (X √ó X) ‚Ü¶ netMaxcard T F U n) :=\n  fun _ _ U_V ‚Ü¶ biSup_mono (fun _ h ‚Ü¶ h.of_entourage_subset U_V)\n\n"}
{"name":"Dynamics.netMaxcard_finite_iff","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Iff (LT.lt (Dynamics.netMaxcard T F U n) Top.top) (Exists fun s => And (Dynamics.IsDynNetIn T F U n ‚Üës) (Eq (‚Üës.card) (Dynamics.netMaxcard T F U n)))","decl":"lemma netMaxcard_finite_iff (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) (n : ‚Ñï) :\n    netMaxcard T F U n < ‚ä§ ‚Üî\n    ‚àÉ s : Finset X, IsDynNetIn T F U n s ‚àß (s.card : ‚Ñï‚àû) = netMaxcard T F U n := by\n  apply Iff.intro <;> intro h\n  ¬∑ rcases WithTop.ne_top_iff_exists.1 h.ne with ‚ü®k, k_max‚ü©\n    rw [‚Üê k_max]\n    simp only [ENat.some_eq_coe, Nat.cast_inj]\n    -- The criterion we want to use is `Nat.sSup_mem`. We rewrite `netMaxcard` with an `sSup`,\n    -- then check its `BddAbove` and `Nonempty` hypotheses.\n    have : netMaxcard T F U n\n      = sSup (WithTop.some '' (Finset.card '' {s : Finset X | IsDynNetIn T F U n s})) := by\n      rw [netMaxcard, ‚Üê image_comp, sSup_image]\n      simp only [mem_setOf_eq, ENat.some_eq_coe, Function.comp_apply]\n    rw [this] at k_max\n    have h_bdda : BddAbove (Finset.card '' {s : Finset X | IsDynNetIn T F U n s}) := by\n      refine ‚ü®k, mem_upperBounds.2 ?_‚ü©\n      simp only [mem_image, mem_setOf_eq, forall_exists_index, and_imp, forall_apply_eq_imp_iff‚ÇÇ]\n      intro s h\n      rw [‚Üê WithTop.coe_le_coe, k_max]\n      apply le_sSup\n      simp only [ENat.some_eq_coe, mem_image, mem_setOf_eq, Nat.cast_inj, exists_eq_right]\n      exact Filter.frequently_principal.mp fun a ‚Ü¶ a h rfl\n    have h_nemp : (Finset.card '' {s : Finset X | IsDynNetIn T F U n s}).Nonempty := by\n      refine ‚ü®0, ?_‚ü©\n      simp only [mem_image, mem_setOf_eq, Finset.card_eq_zero, exists_eq_right, Finset.coe_empty]\n      exact isDynNetIn_empty\n    rw [‚Üê WithTop.coe_sSup' h_bdda, ENat.some_eq_coe, Nat.cast_inj] at k_max\n    have key := Nat.sSup_mem h_nemp h_bdda\n    rw [‚Üê k_max, mem_image] at key\n    simp only [mem_setOf_eq] at key\n    exact key\n  ¬∑ rcases h with ‚ü®s, _, s_netMaxcard‚ü©\n    rw [‚Üê s_netMaxcard]\n    exact WithTop.coe_lt_top s.card\n\n"}
{"name":"Dynamics.netMaxcard_empty","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Eq (Dynamics.netMaxcard T EmptyCollection.emptyCollection U n) 0","decl":"@[simp]\nlemma netMaxcard_empty {T : X ‚Üí X} {U : Set (X √ó X)} {n : ‚Ñï} : netMaxcard T ‚àÖ U n = 0 := by\n  rw [netMaxcard, ‚Üê bot_eq_zero, iSup‚ÇÇ_eq_bot]\n  intro s s_net\n  replace s_net := subset_empty_iff.1 s_net.1\n  norm_cast at s_net\n  rw [s_net, Finset.card_empty, CharP.cast_eq_zero, bot_eq_zero']\n\n"}
{"name":"Dynamics.netMaxcard_eq_zero_iff","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Iff (Eq (Dynamics.netMaxcard T F U n) 0) (Eq F EmptyCollection.emptyCollection)","decl":"lemma netMaxcard_eq_zero_iff (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) (n : ‚Ñï) :\n    netMaxcard T F U n = 0 ‚Üî F = ‚àÖ := by\n  refine Iff.intro (fun h ‚Ü¶ ?_) (fun h ‚Ü¶ by rw [h, netMaxcard_empty])\n  rw [eq_empty_iff_forall_not_mem]\n  intro x x_F\n  have key := isDynNetIn_singleton T U n x_F\n  rw [‚Üê Finset.coe_singleton] at key\n  replace key := key.card_le_netMaxcard\n  rw [Finset.card_singleton, Nat.cast_one, h] at key\n  exact key.not_lt zero_lt_one\n\n"}
{"name":"Dynamics.one_le_netMaxcard_iff","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Iff (LE.le 1 (Dynamics.netMaxcard T F U n)) F.Nonempty","decl":"lemma one_le_netMaxcard_iff (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) (n : ‚Ñï) :\n    1 ‚â§ netMaxcard T F U n ‚Üî F.Nonempty := by\n  rw [ENat.one_le_iff_ne_zero, nonempty_iff_ne_empty]\n  exact not_iff_not.2 (netMaxcard_eq_zero_iff T F U n)\n\n"}
{"name":"Dynamics.netMaxcard_zero","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n‚ä¢ Eq (Dynamics.netMaxcard T F U 0) 1","decl":"lemma netMaxcard_zero (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (U : Set (X √ó X)) :\n    netMaxcard T F U 0 = 1 := by\n  apply (iSup‚ÇÇ_le _).antisymm ((one_le_netMaxcard_iff T F U 0).2 h)\n  intro s ‚ü®_, s_net‚ü©\n  simp only [ball, dynEntourage_zero, preimage_univ] at s_net\n  norm_cast\n  refine Finset.card_le_one.2 (fun x x_s y y_s ‚Ü¶ ?_)\n  exact PairwiseDisjoint.elim_set s_net x_s y_s x (mem_univ x) (mem_univ x)\n\n"}
{"name":"Dynamics.netMaxcard_univ","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nn : Nat\n‚ä¢ Eq (Dynamics.netMaxcard T F Set.univ n) 1","decl":"lemma netMaxcard_univ (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (n : ‚Ñï) :\n    netMaxcard T F univ n = 1 := by\n  apply (iSup‚ÇÇ_le _).antisymm ((one_le_netMaxcard_iff T F univ n).2 h)\n  intro s ‚ü®_, s_net‚ü©\n  simp only [ball, dynEntourage_univ, preimage_univ] at s_net\n  norm_cast\n  refine Finset.card_le_one.2 (fun x x_s y y_s ‚Ü¶ ?_)\n  exact PairwiseDisjoint.elim_set s_net x_s y_s x (mem_univ x) (mem_univ x)\n\n"}
{"name":"Dynamics.netMaxcard_infinite_iff","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Iff (Eq (Dynamics.netMaxcard T F U n) Top.top) (‚àÄ (k : Nat), Exists fun s => And (Dynamics.IsDynNetIn T F U n ‚Üës) (LE.le k s.card))","decl":"lemma netMaxcard_infinite_iff (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) (n : ‚Ñï) :\n    netMaxcard T F U n = ‚ä§ ‚Üî ‚àÄ k : ‚Ñï, ‚àÉ s : Finset X, IsDynNetIn T F U n s ‚àß k ‚â§ s.card := by\n  apply Iff.intro <;> intro h\n  ¬∑ intro k\n    rw [netMaxcard, iSup_subtype', iSup_eq_top] at h\n    specialize h k (ENat.coe_lt_top k)\n    simp only [Nat.cast_lt, Subtype.exists, exists_prop] at h\n    rcases h with ‚ü®s, s_net, s_k‚ü©\n    exact ‚ü®s, ‚ü®s_net, s_k.le‚ü©‚ü©\n  ¬∑ refine WithTop.forall_gt_iff_eq_top.1 fun k ‚Ü¶ ?_\n    specialize h (k + 1)\n    rcases h with ‚ü®s, s_net, s_card‚ü©\n    apply s_net.card_le_netMaxcard.trans_lt'\n    rw [ENat.some_eq_coe, Nat.cast_lt]\n    exact (lt_add_one k).trans_le s_card\n\n"}
{"name":"Dynamics.netMaxcard_le_coverMincard","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nn : Nat\n‚ä¢ LE.le (Dynamics.netMaxcard T F U n) (Dynamics.coverMincard T F U n)","decl":"lemma netMaxcard_le_coverMincard (T : X ‚Üí X) (F : Set X) {U : Set (X √ó X)} (U_symm : SymmetricRel U)\n    (n : ‚Ñï) :\n    netMaxcard T F U n ‚â§ coverMincard T F U n := by\n  rcases eq_top_or_lt_top (coverMincard T F U n) with h | h\n  ¬∑ exact h ‚ñ∏ le_top\n  ¬∑ rcases ((coverMincard_finite_iff T F U n).1 h) with ‚ü®t, t_cover, t_mincard‚ü©\n    rw [‚Üê t_mincard]\n    exact iSup‚ÇÇ_le (fun s s_net ‚Ü¶ Nat.cast_le.2 (s_net.card_le_card_of_isDynCoverOf U_symm t_cover))\n\n"}
{"name":"Dynamics.coverMincard_le_netMaxcard","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nU_rfl : HasSubset.Subset idRel U\nU_symm : SymmetricRel U\nn : Nat\n‚ä¢ LE.le (Dynamics.coverMincard T F (compRel U U) n) (Dynamics.netMaxcard T F U n)","decl":"/-- Given an entourage `U` and a time `n`, a minimal dynamical cover by `U ‚óã U` has a smaller\n  cardinality than a maximal dynamical net by `U`. This lemma is the second of two key results to\n  compare two versions topological entropy: with cover and with nets.-/\nlemma coverMincard_le_netMaxcard (T : X ‚Üí X) (F : Set X) {U : Set (X √ó X)} (U_rfl : idRel ‚äÜ U)\n    (U_symm : SymmetricRel U) (n : ‚Ñï) :\n    coverMincard T F (U ‚óã U) n ‚â§ netMaxcard T F U n := by\n  classical\n  -- WLOG, there exists a maximal dynamical net `s`.\n  rcases (eq_top_or_lt_top (netMaxcard T F U n)) with h | h\n  ¬∑ exact h ‚ñ∏ le_top\n  rcases ((netMaxcard_finite_iff T F U n).1 h) with ‚ü®s, s_net, s_netMaxcard‚ü©\n  rw [‚Üê s_netMaxcard]\n  apply IsDynCoverOf.coverMincard_le_card\n  --  We have to check that `s` is a cover for `dynEntourage T F (U ‚óã U) n`.\n  -- If `s` is not a cover, then we can add to `s` a point `x` which is not covered\n  -- and get a new net. This contradicts the maximality of `s`.\n  by_contra h\n  rcases not_subset.1 h with ‚ü®x, x_F, x_uncov‚ü©\n  simp only [Finset.mem_coe, mem_iUnion, exists_prop, not_exists, not_and] at x_uncov\n  have larger_net : IsDynNetIn T F U n (insert x s) :=\n    And.intro (insert_subset x_F s_net.1) (pairwiseDisjoint_insert.2 (And.intro s_net.2\n      (fun y y_s _ ‚Ü¶ (disjoint_left.2 (fun z z_x z_y ‚Ü¶ x_uncov y y_s\n        (mem_ball_dynEntourage_comp T n U_symm x y (nonempty_of_mem ‚ü®z_x, z_y‚ü©)))))))\n  rw [‚Üê Finset.coe_insert x s] at larger_net\n  apply larger_net.card_le_netMaxcard.not_lt\n  rw [‚Üê s_netMaxcard, Nat.cast_lt]\n  refine (lt_add_one s.card).trans_eq (Finset.card_insert_of_not_mem fun x_s ‚Ü¶ ?_).symm\n  apply x_uncov x x_s (ball_mono (dynEntourage_monotone T n (subset_comp_self U_rfl)) x\n    (ball_mono (idRel_subset_dynEntourage T U_rfl n) x _))\n  simp only [ball, mem_preimage, mem_idRel]\n\n"}
{"name":"Dynamics.log_netMaxcard_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\nn : Nat\n‚ä¢ LE.le 0 (‚Üë(Dynamics.netMaxcard T F U n)).log","decl":"lemma log_netMaxcard_nonneg (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (U : Set (X √ó X)) (n : ‚Ñï) :\n    0 ‚â§ log (netMaxcard T F U n) := by\n  apply zero_le_log_iff.2\n  rw [‚Üê ENat.toENNReal_one, ENat.toENNReal_le]\n  exact (one_le_netMaxcard_iff T F U n).2 h\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\n‚ä¢ Antitone fun U => Dynamics.netEntropyInfEntourage T F U","decl":"lemma netEntropyInfEntourage_antitone (T : X ‚Üí X) (F : Set X) :\n    Antitone (fun U : Set (X √ó X) ‚Ü¶ netEntropyInfEntourage T F U) :=\n  fun _ _ U_V ‚Ü¶ (liminf_le_liminf) (Eventually.of_forall\n    fun n ‚Ü¶ monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n      (log_monotone (ENat.toENNReal_mono (netMaxcard_antitone T F n U_V))))\n\n"}
{"name":"Dynamics.netEntropyEntourage_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\n‚ä¢ Antitone fun U => Dynamics.netEntropyEntourage T F U","decl":"lemma netEntropyEntourage_antitone (T : X ‚Üí X) (F : Set X) :\n    Antitone (fun U : Set (X √ó X) ‚Ü¶ netEntropyEntourage T F U) :=\n  fun _ _ U_V ‚Ü¶ (limsup_le_limsup) (Eventually.of_forall\n    fun n ‚Ü¶ (monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n      (log_monotone (ENat.toENNReal_mono (netMaxcard_antitone T F n U_V)))))\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_le_netEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\n‚ä¢ LE.le (Dynamics.netEntropyInfEntourage T F U) (Dynamics.netEntropyEntourage T F U)","decl":"lemma netEntropyInfEntourage_le_netEntropyEntourage (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) :\n    netEntropyInfEntourage T F U ‚â§ netEntropyEntourage T F U := liminf_le_limsup\n\n"}
{"name":"Dynamics.netEntropyEntourage_empty","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nU : Set (Prod X X)\n‚ä¢ Eq (Dynamics.netEntropyEntourage T EmptyCollection.emptyCollection U) Bot.bot","decl":"@[simp]\nlemma netEntropyEntourage_empty {T : X ‚Üí X} {U : Set (X √ó X)} : netEntropyEntourage T ‚àÖ U = ‚ä• := by\n  suffices h : ‚àÄ·∂† n : ‚Ñï in atTop, log (netMaxcard T ‚àÖ U n) / n = ‚ä• by\n    rw [netEntropyEntourage, limsup_congr h]\n    exact limsup_const ‚ä•\n  simp only [netMaxcard_empty, ENat.toENNReal_zero, log_zero, eventually_atTop]\n  exact ‚ü®1, fun n n_pos ‚Ü¶ bot_div_of_pos_ne_top (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)‚ü©\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_empty","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nU : Set (Prod X X)\n‚ä¢ Eq (Dynamics.netEntropyInfEntourage T EmptyCollection.emptyCollection U) Bot.bot","decl":"@[simp]\nlemma netEntropyInfEntourage_empty {T : X ‚Üí X} {U : Set (X √ó X)} :\n    netEntropyInfEntourage T ‚àÖ U = ‚ä• :=\n  eq_bot_mono (netEntropyInfEntourage_le_netEntropyEntourage T ‚àÖ U) netEntropyEntourage_empty\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n‚ä¢ LE.le 0 (Dynamics.netEntropyInfEntourage T F U)","decl":"lemma netEntropyInfEntourage_nonneg (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (U : Set (X √ó X)) :\n    0 ‚â§ netEntropyInfEntourage T F U :=\n  (le_iInf fun n ‚Ü¶ div_nonneg (log_netMaxcard_nonneg T h U n) (Nat.cast_nonneg' n)).trans\n    iInf_le_liminf\n\n"}
{"name":"Dynamics.netEntropyEntourage_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n‚ä¢ LE.le 0 (Dynamics.netEntropyEntourage T F U)","decl":"lemma netEntropyEntourage_nonneg (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (U : Set (X √ó X)) :\n    0 ‚â§ netEntropyEntourage T F U :=\n  (netEntropyInfEntourage_nonneg T h U).trans (netEntropyInfEntourage_le_netEntropyEntourage T F U)\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_univ","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\n‚ä¢ Eq (Dynamics.netEntropyInfEntourage T F Set.univ) 0","decl":"lemma netEntropyInfEntourage_univ (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) :\n    netEntropyInfEntourage T F univ = 0 := by simp [netEntropyInfEntourage, netMaxcard_univ T h]\n\n"}
{"name":"Dynamics.netEntropyEntourage_univ","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\n‚ä¢ Eq (Dynamics.netEntropyEntourage T F Set.univ) 0","decl":"lemma netEntropyEntourage_univ (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) :\n    netEntropyEntourage T F univ = 0 := by simp [netEntropyEntourage, netMaxcard_univ T h]\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_le_coverEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nU_symm : SymmetricRel U\n‚ä¢ LE.le (Dynamics.netEntropyInfEntourage T F U) (Dynamics.coverEntropyInfEntourage T F U)","decl":"lemma netEntropyInfEntourage_le_coverEntropyInfEntourage (T : X ‚Üí X) (F : Set X) {U : Set (X √ó X)}\n    (U_symm : SymmetricRel U) :\n    netEntropyInfEntourage T F U ‚â§ coverEntropyInfEntourage T F U :=\n  (liminf_le_liminf) (Eventually.of_forall fun n ‚Ü¶ (div_le_div_right_of_nonneg (Nat.cast_nonneg' n)\n    (log_monotone (ENat.toENNReal_le.2 (netMaxcard_le_coverMincard T F U_symm n)))))\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_le_netEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nU_rfl : HasSubset.Subset idRel U\nU_symm : SymmetricRel U\n‚ä¢ LE.le (Dynamics.coverEntropyInfEntourage T F (compRel U U)) (Dynamics.netEntropyInfEntourage T F U)","decl":"lemma coverEntropyInfEntourage_le_netEntropyInfEntourage (T : X ‚Üí X) (F : Set X) {U : Set (X √ó X)}\n    (U_rfl : idRel ‚äÜ U) (U_symm : SymmetricRel U) :\n    coverEntropyInfEntourage T F (U ‚óã U) ‚â§ netEntropyInfEntourage T F U := by\n  refine (liminf_le_liminf) (Eventually.of_forall fun n ‚Ü¶ ?_)\n  apply div_le_div_right_of_nonneg (Nat.cast_nonneg' n) (log_monotone _)\n  exact ENat.toENNReal_le.2 (coverMincard_le_netMaxcard T F U_rfl U_symm n)\n\n"}
{"name":"Dynamics.netEntropyEntourage_le_coverEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nU_symm : SymmetricRel U\n‚ä¢ LE.le (Dynamics.netEntropyEntourage T F U) (Dynamics.coverEntropyEntourage T F U)","decl":"lemma netEntropyEntourage_le_coverEntropyEntourage (T : X ‚Üí X) (F : Set X) {U : Set (X √ó X)}\n    (U_symm : SymmetricRel U) :\n    netEntropyEntourage T F U ‚â§ coverEntropyEntourage T F U := by\n  refine (limsup_le_limsup) (Eventually.of_forall fun n ‚Ü¶ ?_)\n  apply div_le_div_right_of_nonneg (Nat.cast_nonneg' n) (log_monotone _)\n  exact ENat.toENNReal_le.2 (netMaxcard_le_coverMincard T F U_symm n)\n\n"}
{"name":"Dynamics.coverEntropyEntourage_le_netEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nU_rfl : HasSubset.Subset idRel U\nU_symm : SymmetricRel U\n‚ä¢ LE.le (Dynamics.coverEntropyEntourage T F (compRel U U)) (Dynamics.netEntropyEntourage T F U)","decl":"lemma coverEntropyEntourage_le_netEntropyEntourage (T : X ‚Üí X) (F : Set X) {U : Set (X √ó X)}\n    (U_rfl : idRel ‚äÜ U) (U_symm : SymmetricRel U) :\n    coverEntropyEntourage T F (U ‚óã U) ‚â§ netEntropyEntourage T F U := by\n  refine (limsup_le_limsup) (Eventually.of_forall fun n ‚Ü¶ ?_)\n  apply div_le_div_right_of_nonneg (Nat.cast_nonneg' n) (log_monotone _)\n  exact ENat.toENNReal_le.2 (coverMincard_le_netMaxcard T F U_rfl U_symm n)\n\n"}
{"name":"Dynamics.coverEntropyInf_eq_iSup_netEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\n‚ä¢ Eq (Dynamics.coverEntropyInf T F) (iSup fun U => iSup fun h => Dynamics.netEntropyInfEntourage T F U)","decl":"/-- Bowen-Dinaburg's definition of topological entropy using nets is\n  `‚®Ü U ‚àà ùì§ X, netEntropyEntourage T F U`. This quantity is the same as the topological entropy using\n  covers, so there is no need to define a new notion of topological entropy. This version of the\n  theorem relates the `liminf` versions of topological entropy.-/\ntheorem coverEntropyInf_eq_iSup_netEntropyInfEntourage :\n    coverEntropyInf T F = ‚®Ü U ‚àà ùì§ X, netEntropyInfEntourage T F U := by\n  apply le_antisymm <;> refine iSup‚ÇÇ_le fun U U_uni ‚Ü¶ ?_\n  ¬∑ rcases (comp_symm_mem_uniformity_sets U_uni) with ‚ü®V, V_uni, V_symm, V_comp_U‚ü©\n    apply (coverEntropyInfEntourage_antitone T F V_comp_U).trans (le_iSup‚ÇÇ_of_le V V_uni _)\n    exact coverEntropyInfEntourage_le_netEntropyInfEntourage T F (refl_le_uniformity V_uni) V_symm\n  ¬∑ apply (netEntropyInfEntourage_antitone T F (symmetrizeRel_subset_self U)).trans\n    apply (le_iSup‚ÇÇ (symmetrizeRel U) (symmetrize_mem_uniformity U_uni)).trans'\n    exact netEntropyInfEntourage_le_coverEntropyInfEntourage T F (symmetric_symmetrizeRel U)\n\n"}
{"name":"Dynamics.coverEntropy_eq_iSup_netEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\n‚ä¢ Eq (Dynamics.coverEntropy T F) (iSup fun U => iSup fun h => Dynamics.netEntropyEntourage T F U)","decl":"/-- Bowen-Dinaburg's definition of topological entropy using nets is\n  `‚®Ü U ‚àà ùì§ X, netEntropyEntourage T F U`. This quantity is the same as the topological entropy using\n  covers, so there is no need to define a new notion of topological entropy. This version of the\n  theorem relates the `limsup` versions of topological entropy.-/\ntheorem coverEntropy_eq_iSup_netEntropyEntourage :\n    coverEntropy T F = ‚®Ü U ‚àà ùì§ X, netEntropyEntourage T F U := by\n  apply le_antisymm <;> refine iSup‚ÇÇ_le fun U U_uni ‚Ü¶ ?_\n  ¬∑ rcases (comp_symm_mem_uniformity_sets U_uni) with ‚ü®V, V_uni, V_symm, V_comp_U‚ü©\n    apply (coverEntropyEntourage_antitone T F V_comp_U).trans (le_iSup‚ÇÇ_of_le V V_uni _)\n    exact coverEntropyEntourage_le_netEntropyEntourage T F (refl_le_uniformity V_uni) V_symm\n  ¬∑ apply (netEntropyEntourage_antitone T F (symmetrizeRel_subset_self U)).trans\n    apply (le_iSup‚ÇÇ (symmetrizeRel U) (symmetrize_mem_uniformity U_uni)).trans'\n    exact netEntropyEntourage_le_coverEntropyEntourage T F (symmetric_symmetrizeRel U)\n\n"}
{"name":"Dynamics.coverEntropyInf_eq_iSup_basis_netEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nŒπ : Sort u_2\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod X X)\nh : (uniformity X).HasBasis p s\nT : X ‚Üí X\nF : Set X\n‚ä¢ Eq (Dynamics.coverEntropyInf T F) (iSup fun i => iSup fun x => Dynamics.netEntropyInfEntourage T F (s i))","decl":"lemma coverEntropyInf_eq_iSup_basis_netEntropyInfEntourage {Œπ : Sort*} {p : Œπ ‚Üí Prop}\n    {s : Œπ ‚Üí Set (X √ó X)} (h : (ùì§ X).HasBasis p s) (T : X ‚Üí X) (F : Set X) :\n    coverEntropyInf T F = ‚®Ü (i : Œπ) (_ : p i), netEntropyInfEntourage T F (s i) := by\n  rw [coverEntropyInf_eq_iSup_netEntropyInfEntourage T F]\n  apply (iSup‚ÇÇ_mono' fun i h_i ‚Ü¶ ‚ü®s i, HasBasis.mem_of_mem h h_i, le_refl _‚ü©).antisymm'\n  refine iSup‚ÇÇ_le fun U U_uni ‚Ü¶ ?_\n  rcases (HasBasis.mem_iff h).1 U_uni with ‚ü®i, h_i, si_U‚ü©\n  apply (netEntropyInfEntourage_antitone T F si_U).trans\n  exact le_iSup‚ÇÇ (f := fun (i : Œπ) (_ : p i) ‚Ü¶ netEntropyInfEntourage T F (s i)) i h_i\n\n"}
{"name":"Dynamics.coverEntropy_eq_iSup_basis_netEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nŒπ : Sort u_2\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod X X)\nh : (uniformity X).HasBasis p s\nT : X ‚Üí X\nF : Set X\n‚ä¢ Eq (Dynamics.coverEntropy T F) (iSup fun i => iSup fun x => Dynamics.netEntropyEntourage T F (s i))","decl":"lemma coverEntropy_eq_iSup_basis_netEntropyEntourage {Œπ : Sort*} {p : Œπ ‚Üí Prop}\n    {s : Œπ ‚Üí Set (X √ó X)} (h : (ùì§ X).HasBasis p s) (T : X ‚Üí X) (F : Set X) :\n    coverEntropy T F = ‚®Ü (i : Œπ) (_ : p i), netEntropyEntourage T F (s i) := by\n  rw [coverEntropy_eq_iSup_netEntropyEntourage T F]\n  apply (iSup‚ÇÇ_mono' fun i h_i ‚Ü¶ ‚ü®s i, HasBasis.mem_of_mem h h_i, le_refl _‚ü©).antisymm'\n  refine iSup‚ÇÇ_le fun U U_uni ‚Ü¶ ?_\n  rcases (HasBasis.mem_iff h).1 U_uni with ‚ü®i, h_i, si_U‚ü©\n  apply (netEntropyEntourage_antitone T F si_U).trans _\n  exact le_iSup‚ÇÇ (f := fun (i : Œπ) (_ : p i) ‚Ü¶ netEntropyEntourage T F (s i)) i h_i\n\n"}
{"name":"Dynamics.netEntropyInfEntourage_le_coverEntropyInf","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nh : Membership.mem (uniformity X) U\n‚ä¢ LE.le (Dynamics.netEntropyInfEntourage T F U) (Dynamics.coverEntropyInf T F)","decl":"lemma netEntropyInfEntourage_le_coverEntropyInf {U : Set (X √ó X)} (h : U ‚àà ùì§ X) :\n    netEntropyInfEntourage T F U ‚â§ coverEntropyInf T F :=\n  coverEntropyInf_eq_iSup_netEntropyInfEntourage T F ‚ñ∏\n    le_iSup‚ÇÇ (f := fun (U : Set (X √ó X)) (_ : U ‚àà ùì§ X) ‚Ü¶ netEntropyInfEntourage T F U) U h\n\n"}
{"name":"Dynamics.netEntropyEntourage_le_coverEntropy","module":"Mathlib.Dynamics.TopologicalEntropy.NetEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nh : Membership.mem (uniformity X) U\n‚ä¢ LE.le (Dynamics.netEntropyEntourage T F U) (Dynamics.coverEntropy T F)","decl":"lemma netEntropyEntourage_le_coverEntropy {U : Set (X √ó X)} (h : U ‚àà ùì§ X) :\n    netEntropyEntourage T F U ‚â§ coverEntropy T F :=\n  coverEntropy_eq_iSup_netEntropyEntourage T F ‚ñ∏\n    le_iSup‚ÇÇ (f := fun (U : Set (X √ó X)) (_ : U ‚àà ùì§ X) ‚Ü¶ netEntropyEntourage T F U) U h\n\n"}
