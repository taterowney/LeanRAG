{"name":"CategoryTheory.Limits.map_id_left_eq_curry_map","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Prod J K) C\nj : J\nk k' : K\nf : Quiver.Hom k k'\nâŠ¢ Eq (F.map { fst := CategoryTheory.CategoryStruct.id j, snd := f }) (((CategoryTheory.curry.obj F).obj j).map f)","decl":"theorem map_id_left_eq_curry_map {j : J} {k k' : K} {f : k âŸ¶ k'} :\n    F.map ((ğŸ™ j, f) : (j, k) âŸ¶ (j, k')) = ((curry.obj F).obj j).map f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.map_id_right_eq_curry_swap_map","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Prod J K) C\nj j' : J\nf : Quiver.Hom j j'\nk : K\nâŠ¢ Eq (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id k }) (((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).obj k).map f)","decl":"theorem map_id_right_eq_curry_swap_map {j j' : J} {f : j âŸ¶ j'} {k : K} :\n    F.map ((f, ğŸ™ k) : (j, k) âŸ¶ (j', k)) = ((curry.obj (Prod.swap K J â‹™ F)).obj k).map f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Î¹_colimitLimitToLimitColimit_Ï€","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Prod J K) C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape K C\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).comp CategoryTheory.Limits.lim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitToLimitColimit F) (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj F).comp CategoryTheory.Limits.colim) j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).obj k) j) (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj F).obj j) k))","decl":"/-- Since `colimit_limit_to_limit_colimit` is a morphism from a colimit to a limit,\nthis lemma characterises it.\n-/\n@[reassoc (attr := simp)]\ntheorem Î¹_colimitLimitToLimitColimit_Ï€ (j) (k) :\n    colimit.Î¹ _ k â‰« colimitLimitToLimitColimit F â‰« limit.Ï€ _ j =\n      limit.Ï€ ((curry.obj (Prod.swap K J â‹™ F)).obj k) j â‰« colimit.Î¹ ((curry.obj F).obj j) k := by\n  dsimp [colimitLimitToLimitColimit]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Î¹_colimitLimitToLimitColimit_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Prod J K) C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape K C\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colim.obj ((CategoryTheory.curry.obj F).obj j)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).comp CategoryTheory.Limits.lim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitToLimitColimit F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj F).comp CategoryTheory.Limits.colim) j) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj F).obj j) k) h))","decl":"/-- Since `colimit_limit_to_limit_colimit` is a morphism from a colimit to a limit,\nthis lemma characterises it.\n-/\n@[reassoc (attr := simp)]\ntheorem Î¹_colimitLimitToLimitColimit_Ï€ (j) (k) :\n    colimit.Î¹ _ k â‰« colimitLimitToLimitColimit F â‰« limit.Ï€ _ j =\n      limit.Ï€ ((curry.obj (Prod.swap K J â‹™ F)).obj k) j â‰« colimit.Î¹ ((curry.obj F).obj j) k := by\n  dsimp [colimitLimitToLimitColimit]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Î¹_colimitLimitToLimitColimit_Ï€_apply","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœÂ¹ : Small.{v, uâ‚} J\ninstâœ : Small.{v, uâ‚‚} K\nF : CategoryTheory.Functor (Prod J K) (Type v)\nj : J\nk : K\nf : ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).comp CategoryTheory.Limits.lim).obj k\nâŠ¢ Eq (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj F).comp CategoryTheory.Limits.colim) j (CategoryTheory.Limits.colimitLimitToLimitColimit F (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).comp CategoryTheory.Limits.lim) k f))) (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj F).obj j) k (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).obj k) j f))","decl":"@[simp]\ntheorem Î¹_colimitLimitToLimitColimit_Ï€_apply [Small.{v} J] [Small.{v} K] (F : J Ã— K â¥¤ Type v)\n    (j : J) (k : K) (f) : limit.Ï€ (curry.obj F â‹™ colim) j\n        (colimitLimitToLimitColimit F (colimit.Î¹ (curry.obj (Prod.swap K J â‹™ F) â‹™ lim) k f)) =\n      colimit.Î¹ ((curry.obj F).obj j) k (limit.Ï€ ((curry.obj (Prod.swap K J â‹™ F)).obj k) j f) := by\n  dsimp [colimitLimitToLimitColimit]\n  rw [Types.Limit.lift_Ï€_apply]\n  dsimp only\n  rw [Types.Colimit.Î¹_desc_apply]\n  dsimp\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimitCone_hom","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape K C\nG : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœ : CategoryTheory.Limits.HasLimit G\nâŠ¢ Eq (CategoryTheory.Limits.colimitLimitToLimitColimitCone G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map (CategoryTheory.Limits.limitIsoSwapCompLim G).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitToLimitColimit (CategoryTheory.uncurry.obj G)) (CategoryTheory.Limits.lim.map (CategoryTheory.whiskerRight (CategoryTheory.currying.unitIso.app G).inv CategoryTheory.Limits.colim))))","decl":"/-- The map `colimit_limit_to_limit_colimit` realized as a map of cones. -/\n@[simps]\nnoncomputable def colimitLimitToLimitColimitCone (G : J â¥¤ K â¥¤ C) [HasLimit G] :\n    colim.mapCone (limit.cone G) âŸ¶ limit.cone (G â‹™ colim) where\n  hom :=\n    colim.map (limitIsoSwapCompLim G).hom â‰«\n      colimitLimitToLimitColimit (uncurry.obj G :) â‰«\n        lim.map (whiskerRight (currying.unitIso.app G).inv colim)\n  w j := by\n    dsimp\n    ext1 k\n    simp only [Category.assoc, limMap_Ï€, Functor.comp_obj, colim_obj, whiskerRight_app,\n      colim_map, Î¹_colimMap_assoc, lim_obj, limitIsoSwapCompLim_hom_app,\n      Î¹_colimitLimitToLimitColimit_Ï€_assoc, curry_obj_obj_obj, Prod.swap_obj,\n      uncurry_obj_obj, Î¹_colimMap, currying_unitIso_inv_app_app_app, Category.id_comp,\n      limMap_Ï€_assoc, Functor.flip_obj_obj, flipIsoCurrySwapUncurry_hom_app_app]\n    erw [limitObjIsoLimitCompEvaluation_hom_Ï€_assoc]\n\n"}
