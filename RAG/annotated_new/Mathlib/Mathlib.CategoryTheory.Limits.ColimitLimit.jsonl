{"name":"CategoryTheory.Limits.map_id_left_eq_curry_map","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type u₁\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Prod J K) C\nj : J\nk k' : K\nf : Quiver.Hom k k'\n⊢ Eq (F.map { fst := CategoryTheory.CategoryStruct.id j, snd := f }) (((CategoryTheory.curry.obj F).obj j).map f)","decl":"theorem map_id_left_eq_curry_map {j : J} {k k' : K} {f : k ⟶ k'} :\n    F.map ((𝟙 j, f) : (j, k) ⟶ (j, k')) = ((curry.obj F).obj j).map f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.map_id_right_eq_curry_swap_map","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type u₁\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Prod J K) C\nj j' : J\nf : Quiver.Hom j j'\nk : K\n⊢ Eq (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id k }) (((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).obj k).map f)","decl":"theorem map_id_right_eq_curry_swap_map {j j' : J} {f : j ⟶ j'} {k : K} :\n    F.map ((f, 𝟙 k) : (j, k) ⟶ (j', k)) = ((curry.obj (Prod.swap K J ⋙ F)).obj k).map f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitLimitToLimitColimit_π","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type u₁\nK : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Prod J K) C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape K C\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).comp CategoryTheory.Limits.lim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitToLimitColimit F) (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj F).comp CategoryTheory.Limits.colim) j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).obj k) j) (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj F).obj j) k))","decl":"/-- Since `colimit_limit_to_limit_colimit` is a morphism from a colimit to a limit,\nthis lemma characterises it.\n-/\n@[reassoc (attr := simp)]\ntheorem ι_colimitLimitToLimitColimit_π (j) (k) :\n    colimit.ι _ k ≫ colimitLimitToLimitColimit F ≫ limit.π _ j =\n      limit.π ((curry.obj (Prod.swap K J ⋙ F)).obj k) j ≫ colimit.ι ((curry.obj F).obj j) k := by\n  dsimp [colimitLimitToLimitColimit]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitLimitToLimitColimit_π_assoc","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type u₁\nK : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} J\ninst✝³ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Prod J K) C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape K C\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colim.obj ((CategoryTheory.curry.obj F).obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).comp CategoryTheory.Limits.lim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitToLimitColimit F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj F).comp CategoryTheory.Limits.colim) j) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj F).obj j) k) h))","decl":"/-- Since `colimit_limit_to_limit_colimit` is a morphism from a colimit to a limit,\nthis lemma characterises it.\n-/\n@[reassoc (attr := simp)]\ntheorem ι_colimitLimitToLimitColimit_π (j) (k) :\n    colimit.ι _ k ≫ colimitLimitToLimitColimit F ≫ limit.π _ j =\n      limit.π ((curry.obj (Prod.swap K J ⋙ F)).obj k) j ≫ colimit.ι ((curry.obj F).obj j) k := by\n  dsimp [colimitLimitToLimitColimit]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitLimitToLimitColimit_π_apply","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type u₁\nK : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\ninst✝¹ : Small.{v, u₁} J\ninst✝ : Small.{v, u₂} K\nF : CategoryTheory.Functor (Prod J K) (Type v)\nj : J\nk : K\nf : ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).comp CategoryTheory.Limits.lim).obj k\n⊢ Eq (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj F).comp CategoryTheory.Limits.colim) j (CategoryTheory.Limits.colimitLimitToLimitColimit F (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).comp CategoryTheory.Limits.lim) k f))) (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj F).obj j) k (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp F)).obj k) j f))","decl":"@[simp]\ntheorem ι_colimitLimitToLimitColimit_π_apply [Small.{v} J] [Small.{v} K] (F : J × K ⥤ Type v)\n    (j : J) (k : K) (f) : limit.π (curry.obj F ⋙ colim) j\n        (colimitLimitToLimitColimit F (colimit.ι (curry.obj (Prod.swap K J ⋙ F) ⋙ lim) k f)) =\n      colimit.ι ((curry.obj F).obj j) k (limit.π ((curry.obj (Prod.swap K J ⋙ F)).obj k) j f) := by\n  dsimp [colimitLimitToLimitColimit]\n  rw [Types.Limit.lift_π_apply]\n  dsimp only\n  rw [Types.Colimit.ι_desc_apply]\n  dsimp\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimitCone_hom","module":"Mathlib.CategoryTheory.Limits.ColimitLimit","initialProofState":"J : Type u₁\nK : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} J\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape K C\nG : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasLimit G\n⊢ Eq (CategoryTheory.Limits.colimitLimitToLimitColimitCone G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colim.map (CategoryTheory.Limits.limitIsoSwapCompLim G).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitToLimitColimit (CategoryTheory.uncurry.obj G)) (CategoryTheory.Limits.lim.map (CategoryTheory.whiskerRight (CategoryTheory.currying.unitIso.app G).inv CategoryTheory.Limits.colim))))","decl":"/-- The map `colimit_limit_to_limit_colimit` realized as a map of cones. -/\n@[simps]\nnoncomputable def colimitLimitToLimitColimitCone (G : J ⥤ K ⥤ C) [HasLimit G] :\n    colim.mapCone (limit.cone G) ⟶ limit.cone (G ⋙ colim) where\n  hom :=\n    colim.map (limitIsoSwapCompLim G).hom ≫\n      colimitLimitToLimitColimit (uncurry.obj G :) ≫\n        lim.map (whiskerRight (currying.unitIso.app G).inv colim)\n  w j := by\n    dsimp\n    ext1 k\n    simp only [Category.assoc, limMap_π, Functor.comp_obj, colim_obj, whiskerRight_app,\n      colim_map, ι_colimMap_assoc, lim_obj, limitIsoSwapCompLim_hom_app,\n      ι_colimitLimitToLimitColimit_π_assoc, curry_obj_obj_obj, Prod.swap_obj,\n      uncurry_obj_obj, ι_colimMap, currying_unitIso_inv_app_app_app, Category.id_comp,\n      limMap_π_assoc, Functor.flip_obj_obj, flipIsoCurrySwapUncurry_hom_app_app]\n    erw [limitObjIsoLimitCompEvaluation_hom_π_assoc]\n\n"}
