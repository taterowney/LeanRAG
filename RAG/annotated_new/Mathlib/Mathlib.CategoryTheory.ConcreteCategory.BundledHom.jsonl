{"name":"CategoryTheory.BundledHom.mk.inj","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u → Type u\nhom : ⦃α β : Type u⦄ → c α → c β → Type u\ntoFun✝ : {α β : Type u} → (Iα : c α) → (Iβ : c β) → hom Iα Iβ → α → β\nid✝ : {α : Type u} → (I : c α) → hom I I\ncomp✝ : {α β γ : Type u} → (Iα : c α) → (Iβ : c β) → (Iγ : c γ) → hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\nhom_ext✝ : autoParam (∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun✝ Iα Iβ)) _auto✝\nid_toFun✝ : autoParam (∀ {α : Type u} (I : c α), Eq (toFun✝ I I (id✝ I)) _root_.id) _auto✝\ncomp_toFun✝ : autoParam (∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ), Eq (toFun✝ Iα Iγ (comp✝ Iα Iβ Iγ g f)) (Function.comp (toFun✝ Iβ Iγ g) (toFun✝ Iα Iβ f))) _auto✝\ntoFun : {α β : Type u} → (Iα : c α) → (Iβ : c β) → hom Iα Iβ → α → β\nid : {α : Type u} → (I : c α) → hom I I\ncomp : {α β γ : Type u} → (Iα : c α) → (Iβ : c β) → (Iγ : c γ) → hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\nhom_ext : autoParam (∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun Iα Iβ)) _auto✝\nid_toFun : autoParam (∀ {α : Type u} (I : c α), Eq (toFun I I (id I)) _root_.id) _auto✝\ncomp_toFun : autoParam (∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ), Eq (toFun Iα Iγ (comp Iα Iβ Iγ g f)) (Function.comp (toFun Iβ Iγ g) (toFun Iα Iβ f))) _auto✝\nx✝ : Eq { toFun := toFun✝, id := id✝, comp := comp✝, hom_ext := hom_ext✝, id_toFun := id_toFun✝, comp_toFun := comp_toFun✝ } { toFun := toFun, id := id, comp := comp, hom_ext := hom_ext, id_toFun := id_toFun, comp_toFun := comp_toFun }\n⊢ And (Eq toFun✝ toFun) (And (Eq id✝ id) (Eq comp✝ comp))","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `⟨@MonoidHom.toFun, @MonoidHom.id ...⟩` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), hom Iα Iβ → α → β\n  /-- the identity as a bundled morphism -/\n  id : ∀ {α : Type u} (I : c α), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ), hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun Iα Iβ) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ∀ {α : Type u} (I : c α), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ),\n      toFun Iα Iγ (comp Iα Iβ Iγ g f) = toFun Iβ Iγ g ∘ toFun Iα Iβ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.mk.injEq","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u → Type u\nhom : ⦃α β : Type u⦄ → c α → c β → Type u\ntoFun✝ : {α β : Type u} → (Iα : c α) → (Iβ : c β) → hom Iα Iβ → α → β\nid✝ : {α : Type u} → (I : c α) → hom I I\ncomp✝ : {α β γ : Type u} → (Iα : c α) → (Iβ : c β) → (Iγ : c γ) → hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\nhom_ext✝ : autoParam (∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun✝ Iα Iβ)) _auto✝\nid_toFun✝ : autoParam (∀ {α : Type u} (I : c α), Eq (toFun✝ I I (id✝ I)) _root_.id) _auto✝\ncomp_toFun✝ : autoParam (∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ), Eq (toFun✝ Iα Iγ (comp✝ Iα Iβ Iγ g f)) (Function.comp (toFun✝ Iβ Iγ g) (toFun✝ Iα Iβ f))) _auto✝\ntoFun : {α β : Type u} → (Iα : c α) → (Iβ : c β) → hom Iα Iβ → α → β\nid : {α : Type u} → (I : c α) → hom I I\ncomp : {α β γ : Type u} → (Iα : c α) → (Iβ : c β) → (Iγ : c γ) → hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\nhom_ext : autoParam (∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun Iα Iβ)) _auto✝\nid_toFun : autoParam (∀ {α : Type u} (I : c α), Eq (toFun I I (id I)) _root_.id) _auto✝\ncomp_toFun : autoParam (∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ), Eq (toFun Iα Iγ (comp Iα Iβ Iγ g f)) (Function.comp (toFun Iβ Iγ g) (toFun Iα Iβ f))) _auto✝\n⊢ Eq (Eq { toFun := toFun✝, id := id✝, comp := comp✝, hom_ext := hom_ext✝, id_toFun := id_toFun✝, comp_toFun := comp_toFun✝ } { toFun := toFun, id := id, comp := comp, hom_ext := hom_ext, id_toFun := id_toFun, comp_toFun := comp_toFun }) (And (Eq toFun✝ toFun) (And (Eq id✝ id) (Eq comp✝ comp)))","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `⟨@MonoidHom.toFun, @MonoidHom.id ...⟩` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), hom Iα Iβ → α → β\n  /-- the identity as a bundled morphism -/\n  id : ∀ {α : Type u} (I : c α), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ), hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun Iα Iβ) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ∀ {α : Type u} (I : c α), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ),\n      toFun Iα Iγ (comp Iα Iβ Iγ g f) = toFun Iβ Iγ g ∘ toFun Iα Iβ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.id_toFun","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u → Type u\nhom : ⦃α β : Type u⦄ → c α → c β → Type u\nself : CategoryTheory.BundledHom hom\nα : Type u\nI : c α\n⊢ Eq (self.toFun I I (self.id I)) id","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `⟨@MonoidHom.toFun, @MonoidHom.id ...⟩` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), hom Iα Iβ → α → β\n  /-- the identity as a bundled morphism -/\n  id : ∀ {α : Type u} (I : c α), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ), hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun Iα Iβ) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ∀ {α : Type u} (I : c α), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ),\n      toFun Iα Iγ (comp Iα Iβ Iγ g f) = toFun Iβ Iγ g ∘ toFun Iα Iβ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u → Type u\nhom : ⦃α β : Type u⦄ → c α → c β → Type u\ninst✝¹ : (a : Type u) → SizeOf (c a)\ninst✝ : ⦃α β : Type u⦄ → (x : c α) → (x_1 : c β) → SizeOf (hom x x_1)\ntoFun : {α β : Type u} → (Iα : c α) → (Iβ : c β) → hom Iα Iβ → α → β\nid : {α : Type u} → (I : c α) → hom I I\ncomp : {α β γ : Type u} → (Iα : c α) → (Iβ : c β) → (Iγ : c γ) → hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\nhom_ext : autoParam (∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun Iα Iβ)) _auto✝\nid_toFun : autoParam (∀ {α : Type u} (I : c α), Eq (toFun I I (id I)) _root_.id) _auto✝\ncomp_toFun : autoParam (∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ), Eq (toFun Iα Iγ (comp Iα Iβ Iγ g f)) (Function.comp (toFun Iβ Iγ g) (toFun Iα Iβ f))) _auto✝\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, id := id, comp := comp, hom_ext := hom_ext, id_toFun := id_toFun, comp_toFun := comp_toFun }) 1","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `⟨@MonoidHom.toFun, @MonoidHom.id ...⟩` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), hom Iα Iβ → α → β\n  /-- the identity as a bundled morphism -/\n  id : ∀ {α : Type u} (I : c α), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ), hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun Iα Iβ) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ∀ {α : Type u} (I : c α), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ),\n      toFun Iα Iγ (comp Iα Iβ Iγ g f) = toFun Iβ Iγ g ∘ toFun Iα Iβ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.comp_toFun","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u → Type u\nhom : ⦃α β : Type u⦄ → c α → c β → Type u\nself : CategoryTheory.BundledHom hom\nα β γ : Type u\nIα : c α\nIβ : c β\nIγ : c γ\nf : hom Iα Iβ\ng : hom Iβ Iγ\n⊢ Eq (self.toFun Iα Iγ (self.comp Iα Iβ Iγ g f)) (Function.comp (self.toFun Iβ Iγ g) (self.toFun Iα Iβ f))","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `⟨@MonoidHom.toFun, @MonoidHom.id ...⟩` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), hom Iα Iβ → α → β\n  /-- the identity as a bundled morphism -/\n  id : ∀ {α : Type u} (I : c α), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ), hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun Iα Iβ) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ∀ {α : Type u} (I : c α), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ),\n      toFun Iα Iγ (comp Iα Iβ Iγ g f) = toFun Iβ Iγ g ∘ toFun Iα Iβ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.hom_ext","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u → Type u\nhom : ⦃α β : Type u⦄ → c α → c β → Type u\nself : CategoryTheory.BundledHom hom\nα β : Type u\nIα : c α\nIβ : c β\n⊢ Function.Injective (self.toFun Iα Iβ)","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `⟨@MonoidHom.toFun, @MonoidHom.id ...⟩` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), hom Iα Iβ → α → β\n  /-- the identity as a bundled morphism -/\n  id : ∀ {α : Type u} (I : c α), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ), hom Iβ Iγ → hom Iα Iβ → hom Iα Iγ\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ∀ {α β : Type u} (Iα : c α) (Iβ : c β), Function.Injective (toFun Iα Iβ) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ∀ {α : Type u} (I : c α), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ∀ {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ),\n      toFun Iα Iγ (comp Iα Iβ Iγ g f) = toFun Iβ Iγ g ∘ toFun Iα Iβ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.forget₂_full","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u → Type u\nhom : ⦃α β : Type u⦄ → c α → c β → Type u\n𝒞 : CategoryTheory.BundledHom hom\nd : Type u → Type u\nF : {α : Type u} → d α → c α\ninst✝ : CategoryTheory.BundledHom.ParentProjection F\n⊢ (CategoryTheory.forget₂ (CategoryTheory.Bundled d) (CategoryTheory.Bundled c)).Full","decl":"instance forget₂_full (F : ∀ {α}, d α → c α) [ParentProjection @F] :\n    Functor.Full (CategoryTheory.forget₂ (Bundled d) (Bundled c)) where\n  map_surjective f := ⟨f, rfl⟩\n\n"}
