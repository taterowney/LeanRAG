{"name":"CategoryTheory.BundledHom.mk.inj","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u ‚Üí Type u\nhom : ‚¶ÉŒ± Œ≤ : Type u‚¶Ñ ‚Üí c Œ± ‚Üí c Œ≤ ‚Üí Type u\ntoFun‚úù : {Œ± Œ≤ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\nid‚úù : {Œ± : Type u} ‚Üí (I : c Œ±) ‚Üí hom I I\ncomp‚úù : {Œ± Œ≤ Œ≥ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí (IŒ≥ : c Œ≥) ‚Üí hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\nhom_ext‚úù : autoParam (‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun‚úù IŒ± IŒ≤)) _auto‚úù\nid_toFun‚úù : autoParam (‚àÄ {Œ± : Type u} (I : c Œ±), Eq (toFun‚úù I I (id‚úù I)) _root_.id) _auto‚úù\ncomp_toFun‚úù : autoParam (‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥), Eq (toFun‚úù IŒ± IŒ≥ (comp‚úù IŒ± IŒ≤ IŒ≥ g f)) (Function.comp (toFun‚úù IŒ≤ IŒ≥ g) (toFun‚úù IŒ± IŒ≤ f))) _auto‚úù\ntoFun : {Œ± Œ≤ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\nid : {Œ± : Type u} ‚Üí (I : c Œ±) ‚Üí hom I I\ncomp : {Œ± Œ≤ Œ≥ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí (IŒ≥ : c Œ≥) ‚Üí hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\nhom_ext : autoParam (‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤)) _auto‚úù\nid_toFun : autoParam (‚àÄ {Œ± : Type u} (I : c Œ±), Eq (toFun I I (id I)) _root_.id) _auto‚úù\ncomp_toFun : autoParam (‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥), Eq (toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f)) (Function.comp (toFun IŒ≤ IŒ≥ g) (toFun IŒ± IŒ≤ f))) _auto‚úù\nx‚úù : Eq { toFun := toFun‚úù, id := id‚úù, comp := comp‚úù, hom_ext := hom_ext‚úù, id_toFun := id_toFun‚úù, comp_toFun := comp_toFun‚úù } { toFun := toFun, id := id, comp := comp, hom_ext := hom_ext, id_toFun := id_toFun, comp_toFun := comp_toFun }\n‚ä¢ And (Eq toFun‚úù toFun) (And (Eq id‚úù id) (Eq comp‚úù comp))","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `‚ü®@MonoidHom.toFun, @MonoidHom.id ...‚ü©` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\n  /-- the identity as a bundled morphism -/\n  id : ‚àÄ {Œ± : Type u} (I : c Œ±), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥), hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ‚àÄ {Œ± : Type u} (I : c Œ±), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥),\n      toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f) = toFun IŒ≤ IŒ≥ g ‚àò toFun IŒ± IŒ≤ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.mk.injEq","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u ‚Üí Type u\nhom : ‚¶ÉŒ± Œ≤ : Type u‚¶Ñ ‚Üí c Œ± ‚Üí c Œ≤ ‚Üí Type u\ntoFun‚úù : {Œ± Œ≤ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\nid‚úù : {Œ± : Type u} ‚Üí (I : c Œ±) ‚Üí hom I I\ncomp‚úù : {Œ± Œ≤ Œ≥ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí (IŒ≥ : c Œ≥) ‚Üí hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\nhom_ext‚úù : autoParam (‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun‚úù IŒ± IŒ≤)) _auto‚úù\nid_toFun‚úù : autoParam (‚àÄ {Œ± : Type u} (I : c Œ±), Eq (toFun‚úù I I (id‚úù I)) _root_.id) _auto‚úù\ncomp_toFun‚úù : autoParam (‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥), Eq (toFun‚úù IŒ± IŒ≥ (comp‚úù IŒ± IŒ≤ IŒ≥ g f)) (Function.comp (toFun‚úù IŒ≤ IŒ≥ g) (toFun‚úù IŒ± IŒ≤ f))) _auto‚úù\ntoFun : {Œ± Œ≤ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\nid : {Œ± : Type u} ‚Üí (I : c Œ±) ‚Üí hom I I\ncomp : {Œ± Œ≤ Œ≥ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí (IŒ≥ : c Œ≥) ‚Üí hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\nhom_ext : autoParam (‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤)) _auto‚úù\nid_toFun : autoParam (‚àÄ {Œ± : Type u} (I : c Œ±), Eq (toFun I I (id I)) _root_.id) _auto‚úù\ncomp_toFun : autoParam (‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥), Eq (toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f)) (Function.comp (toFun IŒ≤ IŒ≥ g) (toFun IŒ± IŒ≤ f))) _auto‚úù\n‚ä¢ Eq (Eq { toFun := toFun‚úù, id := id‚úù, comp := comp‚úù, hom_ext := hom_ext‚úù, id_toFun := id_toFun‚úù, comp_toFun := comp_toFun‚úù } { toFun := toFun, id := id, comp := comp, hom_ext := hom_ext, id_toFun := id_toFun, comp_toFun := comp_toFun }) (And (Eq toFun‚úù toFun) (And (Eq id‚úù id) (Eq comp‚úù comp)))","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `‚ü®@MonoidHom.toFun, @MonoidHom.id ...‚ü©` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\n  /-- the identity as a bundled morphism -/\n  id : ‚àÄ {Œ± : Type u} (I : c Œ±), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥), hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ‚àÄ {Œ± : Type u} (I : c Œ±), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥),\n      toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f) = toFun IŒ≤ IŒ≥ g ‚àò toFun IŒ± IŒ≤ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.id_toFun","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u ‚Üí Type u\nhom : ‚¶ÉŒ± Œ≤ : Type u‚¶Ñ ‚Üí c Œ± ‚Üí c Œ≤ ‚Üí Type u\nself : CategoryTheory.BundledHom hom\nŒ± : Type u\nI : c Œ±\n‚ä¢ Eq (self.toFun I I (self.id I)) id","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `‚ü®@MonoidHom.toFun, @MonoidHom.id ...‚ü©` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\n  /-- the identity as a bundled morphism -/\n  id : ‚àÄ {Œ± : Type u} (I : c Œ±), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥), hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ‚àÄ {Œ± : Type u} (I : c Œ±), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥),\n      toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f) = toFun IŒ≤ IŒ≥ g ‚àò toFun IŒ± IŒ≤ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u ‚Üí Type u\nhom : ‚¶ÉŒ± Œ≤ : Type u‚¶Ñ ‚Üí c Œ± ‚Üí c Œ≤ ‚Üí Type u\ninst‚úù¬π : (a : Type u) ‚Üí SizeOf (c a)\ninst‚úù : ‚¶ÉŒ± Œ≤ : Type u‚¶Ñ ‚Üí (x : c Œ±) ‚Üí (x_1 : c Œ≤) ‚Üí SizeOf (hom x x_1)\ntoFun : {Œ± Œ≤ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\nid : {Œ± : Type u} ‚Üí (I : c Œ±) ‚Üí hom I I\ncomp : {Œ± Œ≤ Œ≥ : Type u} ‚Üí (IŒ± : c Œ±) ‚Üí (IŒ≤ : c Œ≤) ‚Üí (IŒ≥ : c Œ≥) ‚Üí hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\nhom_ext : autoParam (‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤)) _auto‚úù\nid_toFun : autoParam (‚àÄ {Œ± : Type u} (I : c Œ±), Eq (toFun I I (id I)) _root_.id) _auto‚úù\ncomp_toFun : autoParam (‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥), Eq (toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f)) (Function.comp (toFun IŒ≤ IŒ≥ g) (toFun IŒ± IŒ≤ f))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toFun := toFun, id := id, comp := comp, hom_ext := hom_ext, id_toFun := id_toFun, comp_toFun := comp_toFun }) 1","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `‚ü®@MonoidHom.toFun, @MonoidHom.id ...‚ü©` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\n  /-- the identity as a bundled morphism -/\n  id : ‚àÄ {Œ± : Type u} (I : c Œ±), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥), hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ‚àÄ {Œ± : Type u} (I : c Œ±), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥),\n      toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f) = toFun IŒ≤ IŒ≥ g ‚àò toFun IŒ± IŒ≤ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.comp_toFun","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u ‚Üí Type u\nhom : ‚¶ÉŒ± Œ≤ : Type u‚¶Ñ ‚Üí c Œ± ‚Üí c Œ≤ ‚Üí Type u\nself : CategoryTheory.BundledHom hom\nŒ± Œ≤ Œ≥ : Type u\nIŒ± : c Œ±\nIŒ≤ : c Œ≤\nIŒ≥ : c Œ≥\nf : hom IŒ± IŒ≤\ng : hom IŒ≤ IŒ≥\n‚ä¢ Eq (self.toFun IŒ± IŒ≥ (self.comp IŒ± IŒ≤ IŒ≥ g f)) (Function.comp (self.toFun IŒ≤ IŒ≥ g) (self.toFun IŒ± IŒ≤ f))","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `‚ü®@MonoidHom.toFun, @MonoidHom.id ...‚ü©` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\n  /-- the identity as a bundled morphism -/\n  id : ‚àÄ {Œ± : Type u} (I : c Œ±), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥), hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ‚àÄ {Œ± : Type u} (I : c Œ±), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥),\n      toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f) = toFun IŒ≤ IŒ≥ g ‚àò toFun IŒ± IŒ≤ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.hom_ext","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u ‚Üí Type u\nhom : ‚¶ÉŒ± Œ≤ : Type u‚¶Ñ ‚Üí c Œ± ‚Üí c Œ≤ ‚Üí Type u\nself : CategoryTheory.BundledHom hom\nŒ± Œ≤ : Type u\nIŒ± : c Œ±\nIŒ≤ : c Œ≤\n‚ä¢ Function.Injective (self.toFun IŒ± IŒ≤)","decl":"/-- Class for bundled homs. Note that the arguments order follows that of lemmas for `MonoidHom`.\nThis way we can use `‚ü®@MonoidHom.toFun, @MonoidHom.id ...‚ü©` in an instance. -/\nstructure BundledHom where\n  /-- the underlying map of a bundled morphism -/\n  toFun : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤\n  /-- the identity as a bundled morphism -/\n  id : ‚àÄ {Œ± : Type u} (I : c Œ±), hom I I\n  /-- composition of bundled morphisms -/\n  comp : ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥), hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥\n  /-- a bundled morphism is determined by the underlying map -/\n  hom_ext : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤) := by\n   aesop_cat\n  /-- compatibility with identities -/\n  id_toFun : ‚àÄ {Œ± : Type u} (I : c Œ±), toFun I I (id I) = _root_.id := by aesop_cat\n  /-- compatibility with the composition -/\n  comp_toFun :\n    ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥),\n      toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f) = toFun IŒ≤ IŒ≥ g ‚àò toFun IŒ± IŒ≤ f := by\n   aesop_cat\n\n"}
{"name":"CategoryTheory.BundledHom.forget‚ÇÇ_full","module":"Mathlib.CategoryTheory.ConcreteCategory.BundledHom","initialProofState":"c : Type u ‚Üí Type u\nhom : ‚¶ÉŒ± Œ≤ : Type u‚¶Ñ ‚Üí c Œ± ‚Üí c Œ≤ ‚Üí Type u\nùíû : CategoryTheory.BundledHom hom\nd : Type u ‚Üí Type u\nF : {Œ± : Type u} ‚Üí d Œ± ‚Üí c Œ±\ninst‚úù : CategoryTheory.BundledHom.ParentProjection F\n‚ä¢ (CategoryTheory.forget‚ÇÇ (CategoryTheory.Bundled d) (CategoryTheory.Bundled c)).Full","decl":"instance forget‚ÇÇ_full (F : ‚àÄ {Œ±}, d Œ± ‚Üí c Œ±) [ParentProjection @F] :\n    Functor.Full (CategoryTheory.forget‚ÇÇ (Bundled d) (Bundled c)) where\n  map_surjective f := ‚ü®f, rfl‚ü©\n\n"}
