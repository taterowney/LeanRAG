{"name":"Metric.glueDist_glued_points","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst‚úù¬≤ : MetricSpace X\ninst‚úù¬π : MetricSpace Y\ninst‚úù : Nonempty Z\nŒ¶ : Z ‚Üí X\nŒ® : Z ‚Üí Y\nŒµ : Real\np : Z\n‚ä¢ Eq (Metric.glueDist Œ¶ Œ® Œµ (Sum.inl (Œ¶ p)) (Sum.inr (Œ® p))) Œµ","decl":"theorem glueDist_glued_points [Nonempty Z] (Œ¶ : Z ‚Üí X) (Œ® : Z ‚Üí Y) (Œµ : ‚Ñù) (p : Z) :\n    glueDist Œ¶ Œ® Œµ (.inl (Œ¶ p)) (.inr (Œ® p)) = Œµ := by\n  have : ‚®Ö q, dist (Œ¶ p) (Œ¶ q) + dist (Œ® p) (Œ® q) = 0 := by\n    have A : ‚àÄ q, 0 ‚â§ dist (Œ¶ p) (Œ¶ q) + dist (Œ® p) (Œ® q) := fun _ =>\n      add_nonneg dist_nonneg dist_nonneg\n    refine le_antisymm ?_ (le_ciInf A)\n    have : 0 = dist (Œ¶ p) (Œ¶ p) + dist (Œ® p) (Œ® p) := by simp\n    rw [this]\n    exact ciInf_le ‚ü®0, forall_mem_range.2 A‚ü© p\n  simp only [glueDist, this, zero_add]\n\n"}
{"name":"Metric.glueDist_swap","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nŒ¶ : Z ‚Üí X\nŒ® : Z ‚Üí Y\nŒµ : Real\nx y : Sum X Y\n‚ä¢ Eq (Metric.glueDist Œ® Œ¶ Œµ x.swap y.swap) (Metric.glueDist Œ¶ Œ® Œµ x y)","decl":"theorem glueDist_swap (Œ¶ : Z ‚Üí X) (Œ® : Z ‚Üí Y) (Œµ : ‚Ñù) :\n    ‚àÄ x y, glueDist Œ® Œ¶ Œµ x.swap y.swap = glueDist Œ¶ Œ® Œµ x y\n  | .inl _, .inl _ => rfl\n  | .inr _, .inr _ => rfl\n  | .inl _, .inr _ => by simp only [glueDist, Sum.swap_inl, Sum.swap_inr, dist_comm, add_comm]\n  | .inr _, .inl _ => by simp only [glueDist, Sum.swap_inl, Sum.swap_inr, dist_comm, add_comm]\n\n"}
{"name":"Metric.le_glueDist_inl_inr","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nŒ¶ : Z ‚Üí X\nŒ® : Z ‚Üí Y\nŒµ : Real\nx : X\ny : Y\n‚ä¢ LE.le Œµ (Metric.glueDist Œ¶ Œ® Œµ (Sum.inl x) (Sum.inr y))","decl":"theorem le_glueDist_inl_inr (Œ¶ : Z ‚Üí X) (Œ® : Z ‚Üí Y) (Œµ : ‚Ñù) (x y) :\n    Œµ ‚â§ glueDist Œ¶ Œ® Œµ (.inl x) (.inr y) :=\n  le_add_of_nonneg_left <| Real.iInf_nonneg fun _ => add_nonneg dist_nonneg dist_nonneg\n\n"}
{"name":"Metric.le_glueDist_inr_inl","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nŒ¶ : Z ‚Üí X\nŒ® : Z ‚Üí Y\nŒµ : Real\nx : Y\ny : X\n‚ä¢ LE.le Œµ (Metric.glueDist Œ¶ Œ® Œµ (Sum.inr x) (Sum.inl y))","decl":"theorem le_glueDist_inr_inl (Œ¶ : Z ‚Üí X) (Œ® : Z ‚Üí Y) (Œµ : ‚Ñù) (x y) :\n    Œµ ‚â§ glueDist Œ¶ Œ® Œµ (.inr x) (.inl y) := by\n  rw [glueDist_comm]; apply le_glueDist_inl_inr\n\n"}
{"name":"Metric.Sum.mem_uniformity_iff_glueDist","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nŒ¶ : Z ‚Üí X\nŒ® : Z ‚Üí Y\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\ns : Set (Prod (Sum X Y) (Sum X Y))\n‚ä¢ Iff (Membership.mem (uniformity (Sum X Y)) s) (Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ (a b : Sum X Y), LT.lt (Metric.glueDist Œ¶ Œ® Œµ a b) Œ¥ ‚Üí Membership.mem s { fst := a, snd := b }))","decl":"theorem Sum.mem_uniformity_iff_glueDist (hŒµ : 0 < Œµ) (s : Set ((X ‚äï Y) √ó (X ‚äï Y))) :\n    s ‚àà ùì§ (X ‚äï Y) ‚Üî ‚àÉ Œ¥ > 0, ‚àÄ a b, glueDist Œ¶ Œ® Œµ a b < Œ¥ ‚Üí (a, b) ‚àà s := by\n  simp only [Sum.uniformity, Filter.mem_sup, Filter.mem_map, mem_uniformity_dist, mem_preimage]\n  constructor\n  ¬∑ rintro ‚ü®‚ü®Œ¥X, Œ¥X0, hX‚ü©, Œ¥Y, Œ¥Y0, hY‚ü©\n    refine ‚ü®min (min Œ¥X Œ¥Y) Œµ, lt_min (lt_min Œ¥X0 Œ¥Y0) hŒµ, ?_‚ü©\n    rintro (a | a) (b | b) h <;> simp only [lt_min_iff] at h\n    ¬∑ exact hX h.1.1\n    ¬∑ exact absurd h.2 (le_glueDist_inl_inr _ _ _ _ _).not_lt\n    ¬∑ exact absurd h.2 (le_glueDist_inr_inl _ _ _ _ _).not_lt\n    ¬∑ exact hY h.1.2\n  ¬∑ rintro ‚ü®Œµ, Œµ0, H‚ü©\n    constructor <;> exact ‚ü®Œµ, Œµ0, fun _ _ h => H _ _ h‚ü©\n\n"}
{"name":"Metric.Sum.dist_eq_glueDist","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\np q : Sum X Y\nx : X\ny : Y\n‚ä¢ Eq (Metric.Sum.dist p q) (Metric.glueDist (fun x_1 => ‚ãØ.some) (fun x => ‚ãØ.some) 1 p q)","decl":"theorem Sum.dist_eq_glueDist {p q : X ‚äï Y} (x : X) (y : Y) :\n    Sum.dist p q =\n      glueDist (fun _ : Unit => Nonempty.some ‚ü®x‚ü©) (fun _ : Unit => Nonempty.some ‚ü®y‚ü©) 1 p q := by\n  cases p <;> cases q <;> first |rfl|simp [Sum.dist, glueDist, dist_comm, add_comm,\n    add_left_comm, add_assoc]\n\n"}
{"name":"Metric.Sum.one_le_dist_inl_inr","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nx : X\ny : Y\n‚ä¢ LE.le 1 (Metric.Sum.dist (Sum.inl x) (Sum.inr y))","decl":"theorem Sum.one_le_dist_inl_inr {x : X} {y : Y} : 1 ‚â§ Sum.dist (.inl x) (.inr y) :=\n  le_trans (le_add_of_nonneg_right dist_nonneg) <|\n    add_le_add_right (le_add_of_nonneg_left dist_nonneg) _\n\n"}
{"name":"Metric.Sum.one_le_dist_inr_inl","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nx : X\ny : Y\n‚ä¢ LE.le 1 (Metric.Sum.dist (Sum.inr y) (Sum.inl x))","decl":"theorem Sum.one_le_dist_inr_inl {x : X} {y : Y} : 1 ‚â§ Sum.dist (.inr y) (.inl x) := by\n  rw [Sum.dist_comm]; exact Sum.one_le_dist_inl_inr\n\n"}
{"name":"Metric.Sum.dist_eq","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nx y : Sum X Y\n‚ä¢ Eq (Dist.dist x y) (Metric.Sum.dist x y)","decl":"theorem Sum.dist_eq {x y : X ‚äï Y} : dist x y = Sum.dist x y := rfl\n\n"}
{"name":"Metric.isometry_inl","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\n‚ä¢ Isometry Sum.inl","decl":"/-- The left injection of a space in a disjoint union is an isometry -/\ntheorem isometry_inl : Isometry (Sum.inl : X ‚Üí X ‚äï Y) :=\n  Isometry.of_dist_eq fun _ _ => rfl\n\n"}
{"name":"Metric.isometry_inr","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\n‚ä¢ Isometry Sum.inr","decl":"/-- The right injection of a space in a disjoint union is an isometry -/\ntheorem isometry_inr : Isometry (Sum.inr : Y ‚Üí X ‚äï Y) :=\n  Isometry.of_dist_eq fun _ _ => rfl\n\n"}
{"name":"Metric.Sigma.dist_same","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (E i)\ni : Œπ\nx y : E i\n‚ä¢ Eq (Dist.dist ‚ü®i, x‚ü© ‚ü®i, y‚ü©) (Dist.dist x y)","decl":"@[simp]\ntheorem dist_same (i : Œπ) (x y : E i) : dist (Sigma.mk i x) ‚ü®i, y‚ü© = dist x y := by\n  simp [Dist.dist, Sigma.dist]\n\n"}
{"name":"Metric.Sigma.dist_ne","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (E i)\ni j : Œπ\nh : Ne i j\nx : E i\ny : E j\n‚ä¢ Eq (Dist.dist ‚ü®i, x‚ü© ‚ü®j, y‚ü©) (HAdd.hAdd (HAdd.hAdd (Dist.dist x ‚ãØ.some) 1) (Dist.dist ‚ãØ.some y))","decl":"@[simp]\ntheorem dist_ne {i j : Œπ} (h : i ‚â† j) (x : E i) (y : E j) :\n    dist (‚ü®i, x‚ü© : Œ£k, E k) ‚ü®j, y‚ü© = dist x (Nonempty.some ‚ü®x‚ü©) + 1 + dist (Nonempty.some ‚ü®y‚ü©) y :=\n  dif_neg h\n\n"}
{"name":"Metric.Sigma.one_le_dist_of_ne","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (E i)\ni j : Œπ\nh : Ne i j\nx : E i\ny : E j\n‚ä¢ LE.le 1 (Dist.dist ‚ü®i, x‚ü© ‚ü®j, y‚ü©)","decl":"theorem one_le_dist_of_ne {i j : Œπ} (h : i ‚â† j) (x : E i) (y : E j) :\n    1 ‚â§ dist (‚ü®i, x‚ü© : Œ£k, E k) ‚ü®j, y‚ü© := by\n  rw [Sigma.dist_ne h x y]\n  linarith [@dist_nonneg _ _ x (Nonempty.some ‚ü®x‚ü©), @dist_nonneg _ _ (Nonempty.some ‚ü®y‚ü©) y]\n\n"}
{"name":"Metric.Sigma.fst_eq_of_dist_lt_one","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (E i)\nx y : Sigma fun i => E i\nh : LT.lt (Dist.dist x y) 1\n‚ä¢ Eq x.fst y.fst","decl":"theorem fst_eq_of_dist_lt_one (x y : Œ£i, E i) (h : dist x y < 1) : x.1 = y.1 := by\n  cases x; cases y\n  contrapose! h\n  apply one_le_dist_of_ne h\n\n"}
{"name":"Metric.Sigma.dist_triangle","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (E i)\nx y z : Sigma fun i => E i\n‚ä¢ LE.le (Dist.dist x z) (HAdd.hAdd (Dist.dist x y) (Dist.dist y z))","decl":"protected theorem dist_triangle (x y z : Œ£i, E i) : dist x z ‚â§ dist x y + dist y z := by\n  rcases x with ‚ü®i, x‚ü©; rcases y with ‚ü®j, y‚ü©; rcases z with ‚ü®k, z‚ü©\n  rcases eq_or_ne i k with (rfl | hik)\n  ¬∑ rcases eq_or_ne i j with (rfl | hij)\n    ¬∑ simpa using dist_triangle x y z\n    ¬∑ simp only [Sigma.dist_same, Sigma.dist_ne hij, Sigma.dist_ne hij.symm]\n      calc\n        dist x z ‚â§ dist x (Nonempty.some ‚ü®x‚ü©) + 0 + 0 + (0 + 0 + dist (Nonempty.some ‚ü®z‚ü©) z) := by\n          simpa only [zero_add, add_zero] using dist_triangle _ _ _\n        _ ‚â§ _ := by apply_rules [add_le_add, le_rfl, dist_nonneg, zero_le_one]\n  ¬∑ rcases eq_or_ne i j with (rfl | hij)\n    ¬∑ simp only [Sigma.dist_ne hik, Sigma.dist_same]\n      calc\n        dist x (Nonempty.some ‚ü®x‚ü©) + 1 + dist (Nonempty.some ‚ü®z‚ü©) z ‚â§\n            dist x y + dist y (Nonempty.some ‚ü®y‚ü©) + 1 + dist (Nonempty.some ‚ü®z‚ü©) z := by\n          apply_rules [add_le_add, le_rfl, dist_triangle]\n        _ = _ := by abel\n    ¬∑ rcases eq_or_ne j k with (rfl | hjk)\n      ¬∑ simp only [Sigma.dist_ne hij, Sigma.dist_same]\n        calc\n          dist x (Nonempty.some ‚ü®x‚ü©) + 1 + dist (Nonempty.some ‚ü®z‚ü©) z ‚â§\n              dist x (Nonempty.some ‚ü®x‚ü©) + 1 + (dist (Nonempty.some ‚ü®z‚ü©) y + dist y z) := by\n            apply_rules [add_le_add, le_rfl, dist_triangle]\n          _ = _ := by abel\n      ¬∑ simp only [hik, hij, hjk, Sigma.dist_ne, Ne, not_false_iff]\n        calc\n          dist x (Nonempty.some ‚ü®x‚ü©) + 1 + dist (Nonempty.some ‚ü®z‚ü©) z =\n              dist x (Nonempty.some ‚ü®x‚ü©) + 1 + 0 + (0 + 0 + dist (Nonempty.some ‚ü®z‚ü©) z) := by\n            simp only [add_zero, zero_add]\n          _ ‚â§ _ := by apply_rules [add_le_add, zero_le_one, dist_nonneg, le_rfl]\n\n"}
{"name":"Metric.Sigma.isOpen_iff","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (E i)\ns : Set (Sigma fun i => E i)\n‚ä¢ Iff (IsOpen s) (‚àÄ (x : Sigma fun i => E i), Membership.mem s x ‚Üí Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ (y : Sigma fun i => E i), LT.lt (Dist.dist x y) Œµ ‚Üí Membership.mem s y))","decl":"protected theorem isOpen_iff (s : Set (Œ£i, E i)) :\n    IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, ‚àÄ y, dist x y < Œµ ‚Üí y ‚àà s := by\n  constructor\n  ¬∑ rintro hs ‚ü®i, x‚ü© hx\n    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ > 0, ball x Œµ ‚äÜ Sigma.mk i ‚Åª¬π' s :=\n      Metric.isOpen_iff.1 (isOpen_sigma_iff.1 hs i) x hx\n    refine ‚ü®min Œµ 1, lt_min Œµpos zero_lt_one, ?_‚ü©\n    rintro ‚ü®j, y‚ü© hy\n    rcases eq_or_ne i j with (rfl | hij)\n    ¬∑ simp only [Sigma.dist_same, lt_min_iff] at hy\n      exact hŒµ (mem_ball'.2 hy.1)\n    ¬∑ apply (lt_irrefl (1 : ‚Ñù) _).elim\n      calc\n        1 ‚â§ Sigma.dist ‚ü®i, x‚ü© ‚ü®j, y‚ü© := Sigma.one_le_dist_of_ne hij _ _\n        _ < 1 := hy.trans_le (min_le_right _ _)\n  ¬∑ refine fun H => isOpen_sigma_iff.2 fun i => Metric.isOpen_iff.2 fun x hx => ?_\n    obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ > 0, ‚àÄ y, dist (‚ü®i, x‚ü© : Œ£j, E j) y < Œµ ‚Üí y ‚àà s :=\n      H ‚ü®i, x‚ü© hx\n    refine ‚ü®Œµ, Œµpos, fun y hy => ?_‚ü©\n    apply hŒµ ‚ü®i, y‚ü©\n    rw [Sigma.dist_same]\n    exact mem_ball'.1 hy\n\n"}
{"name":"Metric.Sigma.isometry_mk","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (E i)\ni : Œπ\n‚ä¢ Isometry (Sigma.mk i)","decl":"/-- The injection of a space in a disjoint union is an isometry -/\ntheorem isometry_mk (i : Œπ) : Isometry (Sigma.mk i : E i ‚Üí Œ£k, E k) :=\n  Isometry.of_dist_eq fun x y => by simp\n\n"}
{"name":"Metric.Sigma.completeSpace","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù¬π : (i : Œπ) ‚Üí MetricSpace (E i)\ninst‚úù : ‚àÄ (i : Œπ), CompleteSpace (E i)\n‚ä¢ CompleteSpace (Sigma fun i => E i)","decl":"/-- A disjoint union of complete metric spaces is complete. -/\nprotected theorem completeSpace [‚àÄ i, CompleteSpace (E i)] : CompleteSpace (Œ£i, E i) := by\n  set s : Œπ ‚Üí Set (Œ£i, E i) := fun i => Sigma.fst ‚Åª¬π' {i}\n  set U := { p : (Œ£k, E k) √ó Œ£k, E k | dist p.1 p.2 < 1 }\n  have hc : ‚àÄ i, IsComplete (s i) := fun i => by\n    simp only [s, ‚Üê range_sigmaMk]\n    exact (isometry_mk i).isUniformInducing.isComplete_range\n  have hd : ‚àÄ (i j), ‚àÄ x ‚àà s i, ‚àÄ y ‚àà s j, (x, y) ‚àà U ‚Üí i = j := fun i j x hx y hy hxy =>\n    (Eq.symm hx).trans ((fst_eq_of_dist_lt_one _ _ hxy).trans hy)\n  refine completeSpace_of_isComplete_univ ?_\n  convert isComplete_iUnion_separated hc (dist_mem_uniformity zero_lt_one) hd\n  simp only [s, ‚Üê preimage_iUnion, iUnion_of_singleton, preimage_univ]\n\n"}
{"name":"Metric.toGlue_commute","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst‚úù¬≥ : Nonempty Z\ninst‚úù¬≤ : MetricSpace Z\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nŒ¶ : Z ‚Üí X\nŒ® : Z ‚Üí Y\nhŒ¶ : Isometry Œ¶\nhŒ® : Isometry Œ®\n‚ä¢ Eq (Function.comp (Metric.toGlueL hŒ¶ hŒ®) Œ¶) (Function.comp (Metric.toGlueR hŒ¶ hŒ®) Œ®)","decl":"theorem toGlue_commute (hŒ¶ : Isometry Œ¶) (hŒ® : Isometry Œ®) :\n    toGlueL hŒ¶ hŒ® ‚àò Œ¶ = toGlueR hŒ¶ hŒ® ‚àò Œ® := by\n  let i : PseudoMetricSpace (X ‚äï Y) := gluePremetric hŒ¶ hŒ®\n  let _ := i.toUniformSpace.toTopologicalSpace\n  funext\n  simp only [comp, toGlueL, toGlueR]\n  refine SeparationQuotient.mk_eq_mk.2 (Metric.inseparable_iff.2 ?_)\n  exact glueDist_glued_points Œ¶ Œ® 0 _\n\n"}
{"name":"Metric.toGlueL_isometry","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst‚úù¬≥ : Nonempty Z\ninst‚úù¬≤ : MetricSpace Z\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nŒ¶ : Z ‚Üí X\nŒ® : Z ‚Üí Y\nhŒ¶ : Isometry Œ¶\nhŒ® : Isometry Œ®\n‚ä¢ Isometry (Metric.toGlueL hŒ¶ hŒ®)","decl":"theorem toGlueL_isometry (hŒ¶ : Isometry Œ¶) (hŒ® : Isometry Œ®) : Isometry (toGlueL hŒ¶ hŒ®) :=\n  Isometry.of_dist_eq fun _ _ => rfl\n\n"}
{"name":"Metric.toGlueR_isometry","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Type u\nY : Type v\nZ : Type w\ninst‚úù¬≥ : Nonempty Z\ninst‚úù¬≤ : MetricSpace Z\ninst‚úù¬π : MetricSpace X\ninst‚úù : MetricSpace Y\nŒ¶ : Z ‚Üí X\nŒ® : Z ‚Üí Y\nhŒ¶ : Isometry Œ¶\nhŒ® : Isometry Œ®\n‚ä¢ Isometry (Metric.toGlueR hŒ¶ hŒ®)","decl":"theorem toGlueR_isometry (hŒ¶ : Isometry Œ¶) (hŒ® : Isometry Œ®) : Isometry (toGlueR hŒ¶ hŒ®) :=\n  Isometry.of_dist_eq fun _ _ => rfl\n\n"}
{"name":"Metric.inductiveLimitDist_eq_dist","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Nat ‚Üí Type u\ninst‚úù : (n : Nat) ‚Üí MetricSpace (X n)\nf : (n : Nat) ‚Üí X n ‚Üí X (HAdd.hAdd n 1)\nI : ‚àÄ (n : Nat), Isometry (f n)\nx y : Sigma fun n => X n\nm : Nat\nhx : LE.le x.fst m\nhy : LE.le y.fst m\n‚ä¢ Eq (Metric.inductiveLimitDist f x y) (Dist.dist (Nat.leRecOn hx (fun {k} => f k) x.snd) (Nat.leRecOn hy (fun {k} => f k) y.snd))","decl":"/-- The predistance on the disjoint union `Œ£ n, X n` can be computed in any `X k` for large\nenough `k`. -/\ntheorem inductiveLimitDist_eq_dist (I : ‚àÄ n, Isometry (f n)) (x y : Œ£n, X n) :\n    ‚àÄ m (hx : x.1 ‚â§ m) (hy : y.1 ‚â§ m), inductiveLimitDist f x y =\n      dist (leRecOn hx (f _) x.2 : X m) (leRecOn hy (f _) y.2 : X m)\n  | 0, hx, hy => by\n    cases' x with i x; cases' y with j y\n    obtain rfl : i = 0 := nonpos_iff_eq_zero.1 hx\n    obtain rfl : j = 0 := nonpos_iff_eq_zero.1 hy\n    rfl\n  | (m + 1), hx, hy => by\n    by_cases h : max x.1 y.1 = (m + 1)\n    ¬∑ generalize m + 1 = m' at *\n      subst m'\n      rfl\n    ¬∑ have : max x.1 y.1 ‚â§ succ m := by simp [hx, hy]\n      have : max x.1 y.1 ‚â§ m := by simpa [h] using of_le_succ this\n      have xm : x.1 ‚â§ m := le_trans (le_max_left _ _) this\n      have ym : y.1 ‚â§ m := le_trans (le_max_right _ _) this\n      rw [leRecOn_succ xm, leRecOn_succ ym, (I m).dist_eq]\n      exact inductiveLimitDist_eq_dist I x y m xm ym\n\n"}
{"name":"Metric.toInductiveLimit_isometry","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Nat ‚Üí Type u\ninst‚úù : (n : Nat) ‚Üí MetricSpace (X n)\nf : (n : Nat) ‚Üí X n ‚Üí X (HAdd.hAdd n 1)\nI : ‚àÄ (n : Nat), Isometry (f n)\nn : Nat\n‚ä¢ Isometry (Metric.toInductiveLimit I n)","decl":"/-- The map `toInductiveLimit n` mapping `X n` to the inductive limit is an isometry. -/\ntheorem toInductiveLimit_isometry (I : ‚àÄ n, Isometry (f n)) (n : ‚Ñï) :\n    Isometry (toInductiveLimit I n) :=\n  Isometry.of_dist_eq fun x y => by\n    change inductiveLimitDist f ‚ü®n, x‚ü© ‚ü®n, y‚ü© = dist x y\n    rw [inductiveLimitDist_eq_dist I ‚ü®n, x‚ü© ‚ü®n, y‚ü© n (le_refl n) (le_refl n), leRecOn_self,\n      leRecOn_self]\n\n"}
{"name":"Metric.toInductiveLimit_commute","module":"Mathlib.Topology.MetricSpace.Gluing","initialProofState":"X : Nat ‚Üí Type u\ninst‚úù : (n : Nat) ‚Üí MetricSpace (X n)\nf : (n : Nat) ‚Üí X n ‚Üí X (HAdd.hAdd n 1)\nI : ‚àÄ (n : Nat), Isometry (f n)\nn : Nat\n‚ä¢ Eq (Function.comp (Metric.toInductiveLimit I n.succ) (f n)) (Metric.toInductiveLimit I n)","decl":"/-- The maps `toInductiveLimit n` are compatible with the maps `f n`. -/\ntheorem toInductiveLimit_commute (I : ‚àÄ n, Isometry (f n)) (n : ‚Ñï) :\n    toInductiveLimit I n.succ ‚àò f n = toInductiveLimit I n := by\n  let h := inductivePremetric I\n  let _ := h.toUniformSpace.toTopologicalSpace\n  funext x\n  simp only [comp, toInductiveLimit]\n  refine SeparationQuotient.mk_eq_mk.2 (Metric.inseparable_iff.2 ?_)\n  show inductiveLimitDist f ‚ü®n.succ, f n x‚ü© ‚ü®n, x‚ü© = 0\n  rw [inductiveLimitDist_eq_dist I ‚ü®n.succ, f n x‚ü© ‚ü®n, x‚ü© n.succ, leRecOn_self,\n    leRecOn_succ, leRecOn_self, dist_self]\n  exact le_succ _\n\n"}
