{"name":"PiNat.firstDiff_def","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_2\nx y : (n : Nat) ‚Üí E n\n‚ä¢ Eq (PiNat.firstDiff x y) (dite (Ne x y) (fun h => Nat.find ‚ãØ) fun h => 0)","decl":"open Classical in\n/-- In a product space `Œ† n, E n`, then `firstDiff x y` is the first index at which `x` and `y`\ndiffer. If `x = y`, then by convention we set `firstDiff x x = 0`. -/\nirreducible_def firstDiff (x y : ‚àÄ n, E n) : ‚Ñï :=\n  if h : x ‚â† y then Nat.find (ne_iff.1 h) else 0\n\n"}
{"name":"PiNat.apply_firstDiff_ne","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nh : Ne x y\n‚ä¢ Ne (x (PiNat.firstDiff x y)) (y (PiNat.firstDiff x y))","decl":"theorem apply_firstDiff_ne {x y : ‚àÄ n, E n} (h : x ‚â† y) :\n    x (firstDiff x y) ‚â† y (firstDiff x y) := by\n  rw [firstDiff_def, dif_pos h]\n  classical\n  exact Nat.find_spec (ne_iff.1 h)\n\n"}
{"name":"PiNat.apply_eq_of_lt_firstDiff","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nn : Nat\nhn : LT.lt n (PiNat.firstDiff x y)\n‚ä¢ Eq (x n) (y n)","decl":"theorem apply_eq_of_lt_firstDiff {x y : ‚àÄ n, E n} {n : ‚Ñï} (hn : n < firstDiff x y) : x n = y n := by\n  rw [firstDiff_def] at hn\n  split_ifs at hn with h\n  ¬∑ convert Nat.find_min (ne_iff.1 h) hn\n    simp\n  ¬∑ exact (not_lt_zero' hn).elim\n\n"}
{"name":"PiNat.firstDiff_comm","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\n‚ä¢ Eq (PiNat.firstDiff x y) (PiNat.firstDiff y x)","decl":"theorem firstDiff_comm (x y : ‚àÄ n, E n) : firstDiff x y = firstDiff y x := by\n  classical\n  simp only [firstDiff_def, ne_comm]\n\n"}
{"name":"PiNat.min_firstDiff_le","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y z : (n : Nat) ‚Üí E n\nh : Ne x z\n‚ä¢ LE.le (Min.min (PiNat.firstDiff x y) (PiNat.firstDiff y z)) (PiNat.firstDiff x z)","decl":"theorem min_firstDiff_le (x y z : ‚àÄ n, E n) (h : x ‚â† z) :\n    min (firstDiff x y) (firstDiff y z) ‚â§ firstDiff x z := by\n  by_contra! H\n  rw [lt_min_iff] at H\n  refine apply_firstDiff_ne h ?_\n  calc\n    x (firstDiff x z) = y (firstDiff x z) := apply_eq_of_lt_firstDiff H.1\n    _ = z (firstDiff x z) := apply_eq_of_lt_firstDiff H.2\n\n"}
{"name":"PiNat.cylinder_eq_pi","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx : (n : Nat) ‚Üí E n\nn : Nat\n‚ä¢ Eq (PiNat.cylinder x n) ((‚Üë(Finset.range n)).pi fun i => Singleton.singleton (x i))","decl":"theorem cylinder_eq_pi (x : ‚àÄ n, E n) (n : ‚Ñï) :\n    cylinder x n = Set.pi (Finset.range n : Set ‚Ñï) fun i : ‚Ñï => {x i} := by\n  ext y\n  simp [cylinder]\n\n"}
{"name":"PiNat.cylinder_zero","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx : (n : Nat) ‚Üí E n\n‚ä¢ Eq (PiNat.cylinder x 0) Set.univ","decl":"@[simp]\ntheorem cylinder_zero (x : ‚àÄ n, E n) : cylinder x 0 = univ := by simp [cylinder_eq_pi]\n\n"}
{"name":"PiNat.cylinder_anti","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx : (n : Nat) ‚Üí E n\nm n : Nat\nh : LE.le m n\n‚ä¢ HasSubset.Subset (PiNat.cylinder x n) (PiNat.cylinder x m)","decl":"theorem cylinder_anti (x : ‚àÄ n, E n) {m n : ‚Ñï} (h : m ‚â§ n) : cylinder x n ‚äÜ cylinder x m :=\n  fun _y hy i hi => hy i (hi.trans_le h)\n\n"}
{"name":"PiNat.mem_cylinder_iff","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nn : Nat\n‚ä¢ Iff (Membership.mem (PiNat.cylinder x n) y) (‚àÄ (i : Nat), LT.lt i n ‚Üí Eq (y i) (x i))","decl":"@[simp]\ntheorem mem_cylinder_iff {x y : ‚àÄ n, E n} {n : ‚Ñï} : y ‚àà cylinder x n ‚Üî ‚àÄ i < n, y i = x i :=\n  Iff.rfl\n\n"}
{"name":"PiNat.self_mem_cylinder","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx : (n : Nat) ‚Üí E n\nn : Nat\n‚ä¢ Membership.mem (PiNat.cylinder x n) x","decl":"theorem self_mem_cylinder (x : ‚àÄ n, E n) (n : ‚Ñï) : x ‚àà cylinder x n := by simp\n\n"}
{"name":"PiNat.mem_cylinder_iff_eq","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nn : Nat\n‚ä¢ Iff (Membership.mem (PiNat.cylinder x n) y) (Eq (PiNat.cylinder y n) (PiNat.cylinder x n))","decl":"theorem mem_cylinder_iff_eq {x y : ‚àÄ n, E n} {n : ‚Ñï} :\n    y ‚àà cylinder x n ‚Üî cylinder y n = cylinder x n := by\n  constructor\n  ¬∑ intro hy\n    apply Subset.antisymm\n    ¬∑ intro z hz i hi\n      rw [‚Üê hy i hi]\n      exact hz i hi\n    ¬∑ intro z hz i hi\n      rw [hy i hi]\n      exact hz i hi\n  ¬∑ intro h\n    rw [‚Üê h]\n    exact self_mem_cylinder _ _\n\n"}
{"name":"PiNat.mem_cylinder_comm","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nn : Nat\n‚ä¢ Iff (Membership.mem (PiNat.cylinder x n) y) (Membership.mem (PiNat.cylinder y n) x)","decl":"theorem mem_cylinder_comm (x y : ‚àÄ n, E n) (n : ‚Ñï) : y ‚àà cylinder x n ‚Üî x ‚àà cylinder y n := by\n  simp [mem_cylinder_iff_eq, eq_comm]\n\n"}
{"name":"PiNat.mem_cylinder_iff_le_firstDiff","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nhne : Ne x y\ni : Nat\n‚ä¢ Iff (Membership.mem (PiNat.cylinder y i) x) (LE.le i (PiNat.firstDiff x y))","decl":"theorem mem_cylinder_iff_le_firstDiff {x y : ‚àÄ n, E n} (hne : x ‚â† y) (i : ‚Ñï) :\n    x ‚àà cylinder y i ‚Üî i ‚â§ firstDiff x y := by\n  constructor\n  ¬∑ intro h\n    by_contra!\n    exact apply_firstDiff_ne hne (h _ this)\n  ¬∑ intro hi j hj\n    exact apply_eq_of_lt_firstDiff (hj.trans_le hi)\n\n"}
{"name":"PiNat.mem_cylinder_firstDiff","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\n‚ä¢ Membership.mem (PiNat.cylinder y (PiNat.firstDiff x y)) x","decl":"theorem mem_cylinder_firstDiff (x y : ‚àÄ n, E n) : x ‚àà cylinder y (firstDiff x y) := fun _i hi =>\n  apply_eq_of_lt_firstDiff hi\n\n"}
{"name":"PiNat.cylinder_eq_cylinder_of_le_firstDiff","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nn : Nat\nhn : LE.le n (PiNat.firstDiff x y)\n‚ä¢ Eq (PiNat.cylinder x n) (PiNat.cylinder y n)","decl":"theorem cylinder_eq_cylinder_of_le_firstDiff (x y : ‚àÄ n, E n) {n : ‚Ñï} (hn : n ‚â§ firstDiff x y) :\n    cylinder x n = cylinder y n := by\n  rw [‚Üê mem_cylinder_iff_eq]\n  intro i hi\n  exact apply_eq_of_lt_firstDiff (hi.trans_le hn)\n\n"}
{"name":"PiNat.iUnion_cylinder_update","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx : (n : Nat) ‚Üí E n\nn : Nat\n‚ä¢ Eq (Set.iUnion fun k => PiNat.cylinder (Function.update x n k) (HAdd.hAdd n 1)) (PiNat.cylinder x n)","decl":"theorem iUnion_cylinder_update (x : ‚àÄ n, E n) (n : ‚Ñï) :\n    ‚ãÉ k, cylinder (update x n k) (n + 1) = cylinder x n := by\n  ext y\n  simp only [mem_cylinder_iff, mem_iUnion]\n  constructor\n  ¬∑ rintro ‚ü®k, hk‚ü© i hi\n    simpa [hi.ne] using hk i (Nat.lt_succ_of_lt hi)\n  ¬∑ intro H\n    refine ‚ü®y n, fun i hi => ?_‚ü©\n    rcases Nat.lt_succ_iff_lt_or_eq.1 hi with (h'i | rfl)\n    ¬∑ simp [H i h'i, h'i.ne]\n    ¬∑ simp\n\n"}
{"name":"PiNat.update_mem_cylinder","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx : (n : Nat) ‚Üí E n\nn : Nat\ny : E n\n‚ä¢ Membership.mem (PiNat.cylinder x n) (Function.update x n y)","decl":"theorem update_mem_cylinder (x : ‚àÄ n, E n) (n : ‚Ñï) (y : E n) : update x n y ‚àà cylinder x n :=\n  mem_cylinder_iff.2 fun i hi => by simp [hi.ne]\n\n"}
{"name":"PiNat.res_zero","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œ± : Type u_2\nx : Nat ‚Üí Œ±\n‚ä¢ Eq (PiNat.res x 0) List.nil","decl":"@[simp]\ntheorem res_zero (x : ‚Ñï ‚Üí Œ±) : res x 0 = @nil Œ± :=\n  rfl\n\n"}
{"name":"PiNat.res_succ","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œ± : Type u_2\nx : Nat ‚Üí Œ±\nn : Nat\n‚ä¢ Eq (PiNat.res x n.succ) (List.cons (x n) (PiNat.res x n))","decl":"@[simp]\ntheorem res_succ (x : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) : res x n.succ = x n :: res x n :=\n  rfl\n\n"}
{"name":"PiNat.res_length","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œ± : Type u_2\nx : Nat ‚Üí Œ±\nn : Nat\n‚ä¢ Eq (PiNat.res x n).length n","decl":"@[simp]\ntheorem res_length (x : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) : (res x n).length = n := by induction n <;> simp [*]\n\n"}
{"name":"PiNat.res_eq_res","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œ± : Type u_2\nx y : Nat ‚Üí Œ±\nn : Nat\n‚ä¢ Iff (Eq (PiNat.res x n) (PiNat.res y n)) (‚àÄ ‚¶Ém : Nat‚¶Ñ, LT.lt m n ‚Üí Eq (x m) (y m))","decl":"/-- The restrictions of `x` and `y` to `n` are equal if and only if `x m = y m` for all `m < n`. -/\ntheorem res_eq_res {x y : ‚Ñï ‚Üí Œ±} {n : ‚Ñï} :\n    res x n = res y n ‚Üî ‚àÄ ‚¶Ém‚¶Ñ, m < n ‚Üí x m = y m := by\n  constructor <;> intro h <;> induction' n with n ih; ¬∑ simp\n  ¬∑ intro m hm\n    rw [Nat.lt_succ_iff_lt_or_eq] at hm\n    simp only [res_succ, cons.injEq] at h\n    cases' hm with hm hm\n    ¬∑ exact ih h.2 hm\n    rw [hm]\n    exact h.1\n  ¬∑ simp\n  simp only [res_succ, cons.injEq]\n  refine ‚ü®h (Nat.lt_succ_self _), ih fun m hm => ?_‚ü©\n  exact h (hm.trans (Nat.lt_succ_self _))\n\n"}
{"name":"PiNat.res_injective","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œ± : Type u_2\n‚ä¢ Function.Injective PiNat.res","decl":"theorem res_injective : Injective (@res Œ±) := by\n  intro x y h\n  ext n\n  apply res_eq_res.mp _ (Nat.lt_succ_self _)\n  rw [h]\n\n"}
{"name":"PiNat.cylinder_eq_res","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œ± : Type u_2\nx : Nat ‚Üí Œ±\nn : Nat\n‚ä¢ Eq (PiNat.cylinder x n) (setOf fun y => Eq (PiNat.res y n) (PiNat.res x n))","decl":"/-- `cylinder x n` is equal to the set of sequences `y` with the same restriction to `n` as `x`. -/\ntheorem cylinder_eq_res (x : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) :\n    cylinder x n = { y | res y n = res x n } := by\n  ext y\n  dsimp [cylinder]\n  rw [res_eq_res]\n\n"}
{"name":"PiNat.dist_eq_of_ne","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nh : Ne x y\n‚ä¢ Eq (Dist.dist x y) (HPow.hPow (1 / 2) (PiNat.firstDiff x y))","decl":"theorem dist_eq_of_ne {x y : ‚àÄ n, E n} (h : x ‚â† y) : dist x y = (1 / 2 : ‚Ñù) ^ firstDiff x y := by\n  simp [dist, h]\n\n"}
{"name":"PiNat.dist_self","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx : (n : Nat) ‚Üí E n\n‚ä¢ Eq (Dist.dist x x) 0","decl":"protected theorem dist_self (x : ‚àÄ n, E n) : dist x x = 0 := by simp [dist]\n\n"}
{"name":"PiNat.dist_comm","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\n‚ä¢ Eq (Dist.dist x y) (Dist.dist y x)","decl":"protected theorem dist_comm (x y : ‚àÄ n, E n) : dist x y = dist y x := by\n  classical\n  simp [dist, @eq_comm _ x y, firstDiff_comm]\n\n"}
{"name":"PiNat.dist_nonneg","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\n‚ä¢ LE.le 0 (Dist.dist x y)","decl":"protected theorem dist_nonneg (x y : ‚àÄ n, E n) : 0 ‚â§ dist x y := by\n  rcases eq_or_ne x y with (rfl | h)\n  ¬∑ simp [dist]\n  ¬∑ simp [dist, h, zero_le_two]\n\n"}
{"name":"PiNat.dist_triangle_nonarch","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y z : (n : Nat) ‚Üí E n\n‚ä¢ LE.le (Dist.dist x z) (Max.max (Dist.dist x y) (Dist.dist y z))","decl":"theorem dist_triangle_nonarch (x y z : ‚àÄ n, E n) : dist x z ‚â§ max (dist x y) (dist y z) := by\n  rcases eq_or_ne x z with (rfl | hxz)\n  ¬∑ simp [PiNat.dist_self x, PiNat.dist_nonneg]\n  rcases eq_or_ne x y with (rfl | hxy)\n  ¬∑ simp\n  rcases eq_or_ne y z with (rfl | hyz)\n  ¬∑ simp\n  simp only [dist_eq_of_ne, hxz, hxy, hyz, inv_le_inv‚ÇÄ, one_div, inv_pow, zero_lt_two, Ne,\n    not_false_iff, le_max_iff, pow_le_pow_iff_right‚ÇÄ, one_lt_two, pow_pos,\n    min_le_iff.1 (min_firstDiff_le x y z hxz)]\n\n"}
{"name":"PiNat.dist_triangle","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y z : (n : Nat) ‚Üí E n\n‚ä¢ LE.le (Dist.dist x z) (HAdd.hAdd (Dist.dist x y) (Dist.dist y z))","decl":"protected theorem dist_triangle (x y z : ‚àÄ n, E n) : dist x z ‚â§ dist x y + dist y z :=\n  calc\n    dist x z ‚â§ max (dist x y) (dist y z) := dist_triangle_nonarch x y z\n    _ ‚â§ dist x y + dist y z := max_le_add_of_nonneg (PiNat.dist_nonneg _ _) (PiNat.dist_nonneg _ _)\n\n"}
{"name":"PiNat.eq_of_dist_eq_zero","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nhxy : Eq (Dist.dist x y) 0\n‚ä¢ Eq x y","decl":"protected theorem eq_of_dist_eq_zero (x y : ‚àÄ n, E n) (hxy : dist x y = 0) : x = y := by\n  rcases eq_or_ne x y with (rfl | h); ¬∑ rfl\n  simp [dist_eq_of_ne h] at hxy\n\n"}
{"name":"PiNat.mem_cylinder_iff_dist_le","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nn : Nat\n‚ä¢ Iff (Membership.mem (PiNat.cylinder x n) y) (LE.le (Dist.dist y x) (HPow.hPow (1 / 2) n))","decl":"theorem mem_cylinder_iff_dist_le {x y : ‚àÄ n, E n} {n : ‚Ñï} :\n    y ‚àà cylinder x n ‚Üî dist y x ‚â§ (1 / 2) ^ n := by\n  rcases eq_or_ne y x with (rfl | hne)\n  ¬∑ simp [PiNat.dist_self]\n  suffices (‚àÄ i : ‚Ñï, i < n ‚Üí y i = x i) ‚Üî n ‚â§ firstDiff y x by simpa [dist_eq_of_ne hne]\n  constructor\n  ¬∑ intro hy\n    by_contra! H\n    exact apply_firstDiff_ne hne (hy _ H)\n  ¬∑ intro h i hi\n    exact apply_eq_of_lt_firstDiff (hi.trans_le h)\n\n"}
{"name":"PiNat.apply_eq_of_dist_lt","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nx y : (n : Nat) ‚Üí E n\nn : Nat\nh : LT.lt (Dist.dist x y) (HPow.hPow (1 / 2) n)\ni : Nat\nhi : LE.le i n\n‚ä¢ Eq (x i) (y i)","decl":"theorem apply_eq_of_dist_lt {x y : ‚àÄ n, E n} {n : ‚Ñï} (h : dist x y < (1 / 2) ^ n) {i : ‚Ñï}\n    (hi : i ‚â§ n) : x i = y i := by\n  rcases eq_or_ne x y with (rfl | hne)\n  ¬∑ rfl\n  have : n < firstDiff x y := by\n    simpa [dist_eq_of_ne hne, inv_lt_inv‚ÇÄ, pow_lt_pow_iff_right‚ÇÄ, one_lt_two] using h\n  exact apply_eq_of_lt_firstDiff (hi.trans_lt this)\n\n"}
{"name":"PiNat.lipschitz_with_one_iff_forall_dist_image_le_of_mem_cylinder","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\nŒ± : Type u_2\ninst‚úù : PseudoMetricSpace Œ±\nf : ((n : Nat) ‚Üí E n) ‚Üí Œ±\n‚ä¢ Iff (‚àÄ (x y : (n : Nat) ‚Üí E n), LE.le (Dist.dist (f x) (f y)) (Dist.dist x y)) (‚àÄ (x y : (n : Nat) ‚Üí E n) (n : Nat), Membership.mem (PiNat.cylinder x n) y ‚Üí LE.le (Dist.dist (f x) (f y)) (HPow.hPow (1 / 2) n))","decl":"/-- A function to a pseudo-metric-space is `1`-Lipschitz if and only if points in the same cylinder\nof length `n` are sent to points within distance `(1/2)^n`.\nNot expressed using `LipschitzWith` as we don't have a metric space structure -/\ntheorem lipschitz_with_one_iff_forall_dist_image_le_of_mem_cylinder {Œ± : Type*}\n    [PseudoMetricSpace Œ±] {f : (‚àÄ n, E n) ‚Üí Œ±} :\n    (‚àÄ x y : ‚àÄ n, E n, dist (f x) (f y) ‚â§ dist x y) ‚Üî\n      ‚àÄ x y n, y ‚àà cylinder x n ‚Üí dist (f x) (f y) ‚â§ (1 / 2) ^ n := by\n  constructor\n  ¬∑ intro H x y n hxy\n    apply (H x y).trans\n    rw [PiNat.dist_comm]\n    exact mem_cylinder_iff_dist_le.1 hxy\n  ¬∑ intro H x y\n    rcases eq_or_ne x y with (rfl | hne)\n    ¬∑ simp [PiNat.dist_nonneg]\n    rw [dist_eq_of_ne hne]\n    apply H x y (firstDiff x y)\n    rw [firstDiff_comm]\n    exact mem_cylinder_firstDiff _ _\n\n"}
{"name":"PiNat.isOpen_cylinder","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\nx : (n : Nat) ‚Üí E n\nn : Nat\n‚ä¢ IsOpen (PiNat.cylinder x n)","decl":"theorem isOpen_cylinder (x : ‚àÄ n, E n) (n : ‚Ñï) : IsOpen (cylinder x n) := by\n  rw [PiNat.cylinder_eq_pi]\n  exact isOpen_set_pi (Finset.range n).finite_toSet fun a _ => isOpen_discrete _\n\n"}
{"name":"PiNat.isTopologicalBasis_cylinders","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\n‚ä¢ TopologicalSpace.IsTopologicalBasis (setOf fun s => Exists fun x => Exists fun n => Eq s (PiNat.cylinder x n))","decl":"theorem isTopologicalBasis_cylinders :\n    IsTopologicalBasis { s : Set (‚àÄ n, E n) | ‚àÉ (x : ‚àÄ n, E n) (n : ‚Ñï), s = cylinder x n } := by\n  apply isTopologicalBasis_of_isOpen_of_nhds\n  ¬∑ rintro u ‚ü®x, n, rfl‚ü©\n    apply isOpen_cylinder\n  ¬∑ intro x u hx u_open\n    obtain ‚ü®v, ‚ü®U, F, -, rfl‚ü©, xU, Uu‚ü© :\n        ‚àÉ v ‚àà { S : Set (‚àÄ i : ‚Ñï, E i) | ‚àÉ (U : ‚àÄ i : ‚Ñï, Set (E i)) (F : Finset ‚Ñï),\n          (‚àÄ i : ‚Ñï, i ‚àà F ‚Üí U i ‚àà { s : Set (E i) | IsOpen s }) ‚àß S = (F : Set ‚Ñï).pi U },\n        x ‚àà v ‚àß v ‚äÜ u :=\n      (isTopologicalBasis_pi fun n : ‚Ñï => isTopologicalBasis_opens).exists_subset_of_mem_open hx\n        u_open\n    rcases Finset.bddAbove F with ‚ü®n, hn‚ü©\n    refine ‚ü®cylinder x (n + 1), ‚ü®x, n + 1, rfl‚ü©, self_mem_cylinder _ _, Subset.trans ?_ Uu‚ü©\n    intro y hy\n    suffices ‚àÄ i : ‚Ñï, i ‚àà F ‚Üí y i ‚àà U i by simpa\n    intro i hi\n    have : y i = x i := mem_cylinder_iff.1 hy i ((hn hi).trans_lt (lt_add_one n))\n    rw [this]\n    simp only [Set.mem_pi, Finset.mem_coe] at xU\n    exact xU i hi\n\n"}
{"name":"PiNat.isOpen_iff_dist","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\n‚ä¢ Iff (IsOpen s) (‚àÄ (x : (n : Nat) ‚Üí E n), Membership.mem s x ‚Üí Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ (y : (n : Nat) ‚Üí E n), LT.lt (Dist.dist x y) Œµ ‚Üí Membership.mem s y))","decl":"theorem isOpen_iff_dist (s : Set (‚àÄ n, E n)) :\n    IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, ‚àÄ y, dist x y < Œµ ‚Üí y ‚àà s := by\n  constructor\n  ¬∑ intro hs x hx\n    obtain ‚ü®v, ‚ü®y, n, rfl‚ü©, h'x, h's‚ü© :\n        ‚àÉ v ‚àà { s | ‚àÉ (x : ‚àÄ n : ‚Ñï, E n) (n : ‚Ñï), s = cylinder x n }, x ‚àà v ‚àß v ‚äÜ s :=\n      (isTopologicalBasis_cylinders E).exists_subset_of_mem_open hx hs\n    rw [‚Üê mem_cylinder_iff_eq.1 h'x] at h's\n    exact\n      ‚ü®(1 / 2 : ‚Ñù) ^ n, by simp, fun y hy => h's fun i hi => (apply_eq_of_dist_lt hy hi.le).symm‚ü©\n  ¬∑ intro h\n    refine (isTopologicalBasis_cylinders E).isOpen_iff.2 fun x hx => ?_\n    rcases h x hx with ‚ü®Œµ, Œµpos, hŒµ‚ü©\n    obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, (1 / 2 : ‚Ñù) ^ n < Œµ := exists_pow_lt_of_lt_one Œµpos one_half_lt_one\n    refine ‚ü®cylinder x n, ‚ü®x, n, rfl‚ü©, self_mem_cylinder x n, fun y hy => hŒµ y ?_‚ü©\n    rw [PiNat.dist_comm]\n    exact (mem_cylinder_iff_dist_le.1 hy).trans_lt hn\n\n"}
{"name":"PiNat.completeSpace","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\n‚ä¢ CompleteSpace ((n : Nat) ‚Üí E n)","decl":"protected theorem completeSpace : CompleteSpace (‚àÄ n, E n) := by\n  refine Metric.complete_of_convergent_controlled_sequences (fun n => (1 / 2) ^ n) (by simp) ?_\n  intro u hu\n  refine ‚ü®fun n => u n n, tendsto_pi_nhds.2 fun i => ?_‚ü©\n  refine tendsto_const_nhds.congr' ?_\n  filter_upwards [Filter.Ici_mem_atTop i] with n hn\n  exact apply_eq_of_dist_lt (hu i i n le_rfl hn) le_rfl\n\n"}
{"name":"PiNat.exists_disjoint_cylinder","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nx : (n : Nat) ‚Üí E n\nhx : Not (Membership.mem s x)\n‚ä¢ Exists fun n => Disjoint s (PiNat.cylinder x n)","decl":"theorem exists_disjoint_cylinder {s : Set (‚àÄ n, E n)} (hs : IsClosed s) {x : ‚àÄ n, E n}\n    (hx : x ‚àâ s) : ‚àÉ n, Disjoint s (cylinder x n) := by\n  rcases eq_empty_or_nonempty s with (rfl | hne)\n  ¬∑ exact ‚ü®0, by simp‚ü©\n  have A : 0 < infDist x s := (hs.not_mem_iff_infDist_pos hne).1 hx\n  obtain ‚ü®n, hn‚ü© : ‚àÉ n, (1 / 2 : ‚Ñù) ^ n < infDist x s := exists_pow_lt_of_lt_one A one_half_lt_one\n  refine ‚ü®n, disjoint_left.2 fun y ys hy => ?_‚ü©\n  apply lt_irrefl (infDist x s)\n  calc\n    infDist x s ‚â§ dist x y := infDist_le_dist_of_mem ys\n    _ ‚â§ (1 / 2) ^ n := by\n      rw [mem_cylinder_comm] at hy\n      exact mem_cylinder_iff_dist_le.1 hy\n    _ < infDist x s := hn\n\n"}
{"name":"PiNat.firstDiff_lt_shortestPrefixDiff","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nx y : (n : Nat) ‚Üí E n\nhx : Not (Membership.mem s x)\nhy : Membership.mem s y\n‚ä¢ LT.lt (PiNat.firstDiff x y) (PiNat.shortestPrefixDiff x s)","decl":"theorem firstDiff_lt_shortestPrefixDiff {s : Set (‚àÄ n, E n)} (hs : IsClosed s) {x y : ‚àÄ n, E n}\n    (hx : x ‚àâ s) (hy : y ‚àà s) : firstDiff x y < shortestPrefixDiff x s := by\n  have A := exists_disjoint_cylinder hs hx\n  rw [shortestPrefixDiff, dif_pos A]\n  classical\n  have B := Nat.find_spec A\n  contrapose! B\n  rw [not_disjoint_iff_nonempty_inter]\n  refine ‚ü®y, hy, ?_‚ü©\n  rw [mem_cylinder_comm]\n  exact cylinder_anti y B (mem_cylinder_firstDiff x y)\n\n"}
{"name":"PiNat.shortestPrefixDiff_pos","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nhne : s.Nonempty\nx : (n : Nat) ‚Üí E n\nhx : Not (Membership.mem s x)\n‚ä¢ LT.lt 0 (PiNat.shortestPrefixDiff x s)","decl":"theorem shortestPrefixDiff_pos {s : Set (‚àÄ n, E n)} (hs : IsClosed s) (hne : s.Nonempty)\n    {x : ‚àÄ n, E n} (hx : x ‚àâ s) : 0 < shortestPrefixDiff x s := by\n  rcases hne with ‚ü®y, hy‚ü©\n  exact (zero_le _).trans_lt (firstDiff_lt_shortestPrefixDiff hs hx hy)\n\n"}
{"name":"PiNat.firstDiff_le_longestPrefix","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nx y : (n : Nat) ‚Üí E n\nhx : Not (Membership.mem s x)\nhy : Membership.mem s y\n‚ä¢ LE.le (PiNat.firstDiff x y) (PiNat.longestPrefix x s)","decl":"theorem firstDiff_le_longestPrefix {s : Set (‚àÄ n, E n)} (hs : IsClosed s) {x y : ‚àÄ n, E n}\n    (hx : x ‚àâ s) (hy : y ‚àà s) : firstDiff x y ‚â§ longestPrefix x s := by\n  rw [longestPrefix, le_tsub_iff_right]\n  ¬∑ exact firstDiff_lt_shortestPrefixDiff hs hx hy\n  ¬∑ exact shortestPrefixDiff_pos hs ‚ü®y, hy‚ü© hx\n\n"}
{"name":"PiNat.inter_cylinder_longestPrefix_nonempty","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nhne : s.Nonempty\nx : (n : Nat) ‚Üí E n\n‚ä¢ (Inter.inter s (PiNat.cylinder x (PiNat.longestPrefix x s))).Nonempty","decl":"theorem inter_cylinder_longestPrefix_nonempty {s : Set (‚àÄ n, E n)} (hs : IsClosed s)\n    (hne : s.Nonempty) (x : ‚àÄ n, E n) : (s ‚à© cylinder x (longestPrefix x s)).Nonempty := by\n  by_cases hx : x ‚àà s\n  ¬∑ exact ‚ü®x, hx, self_mem_cylinder _ _‚ü©\n  have A := exists_disjoint_cylinder hs hx\n  have B : longestPrefix x s < shortestPrefixDiff x s :=\n    Nat.pred_lt (shortestPrefixDiff_pos hs hne hx).ne'\n  rw [longestPrefix, shortestPrefixDiff, dif_pos A] at B ‚ä¢\n  classical\n  obtain ‚ü®y, ys, hy‚ü© : ‚àÉ y : ‚àÄ n : ‚Ñï, E n, y ‚àà s ‚àß x ‚àà cylinder y (Nat.find A - 1) := by\n    simpa only [not_disjoint_iff, mem_cylinder_comm] using Nat.find_min A B\n  refine ‚ü®y, ys, ?_‚ü©\n  rw [mem_cylinder_iff_eq] at hy ‚ä¢\n  rw [hy]\n\n"}
{"name":"PiNat.disjoint_cylinder_of_longestPrefix_lt","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nx : (n : Nat) ‚Üí E n\nhx : Not (Membership.mem s x)\nn : Nat\nhn : LT.lt (PiNat.longestPrefix x s) n\n‚ä¢ Disjoint s (PiNat.cylinder x n)","decl":"theorem disjoint_cylinder_of_longestPrefix_lt {s : Set (‚àÄ n, E n)} (hs : IsClosed s) {x : ‚àÄ n, E n}\n    (hx : x ‚àâ s) {n : ‚Ñï} (hn : longestPrefix x s < n) : Disjoint s (cylinder x n) := by\n  contrapose! hn\n  rcases not_disjoint_iff_nonempty_inter.1 hn with ‚ü®y, ys, hy‚ü©\n  apply le_trans _ (firstDiff_le_longestPrefix hs hx ys)\n  apply (mem_cylinder_iff_le_firstDiff (ne_of_mem_of_not_mem ys hx).symm _).1\n  rwa [mem_cylinder_comm]\n\n"}
{"name":"PiNat.cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\nx y : (n : Nat) ‚Üí E n\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nhne : s.Nonempty\nH : LT.lt (PiNat.longestPrefix x s) (PiNat.firstDiff x y)\nxs : Not (Membership.mem s x)\nys : Not (Membership.mem s y)\n‚ä¢ Eq (PiNat.cylinder x (PiNat.longestPrefix x s)) (PiNat.cylinder y (PiNat.longestPrefix y s))","decl":"/-- If two points `x, y` coincide up to length `n`, and the longest common prefix of `x` with `s`\nis strictly shorter than `n`, then the longest common prefix of `y` with `s` is the same, and both\ncylinders of this length based at `x` and `y` coincide. -/\ntheorem cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff {x y : ‚àÄ n, E n}\n    {s : Set (‚àÄ n, E n)} (hs : IsClosed s) (hne : s.Nonempty)\n    (H : longestPrefix x s < firstDiff x y) (xs : x ‚àâ s) (ys : y ‚àâ s) :\n    cylinder x (longestPrefix x s) = cylinder y (longestPrefix y s) := by\n  have l_eq : longestPrefix y s = longestPrefix x s := by\n    rcases lt_trichotomy (longestPrefix y s) (longestPrefix x s) with (L | L | L)\n    ¬∑ have Ax : (s ‚à© cylinder x (longestPrefix x s)).Nonempty :=\n        inter_cylinder_longestPrefix_nonempty hs hne x\n      have Z := disjoint_cylinder_of_longestPrefix_lt hs ys L\n      rw [firstDiff_comm] at H\n      rw [cylinder_eq_cylinder_of_le_firstDiff _ _ H.le] at Z\n      exact (Ax.not_disjoint Z).elim\n    ¬∑ exact L\n    ¬∑ have Ay : (s ‚à© cylinder y (longestPrefix y s)).Nonempty :=\n        inter_cylinder_longestPrefix_nonempty hs hne y\n      have A'y : (s ‚à© cylinder y (longestPrefix x s).succ).Nonempty :=\n        Ay.mono (inter_subset_inter_right s (cylinder_anti _ L))\n      have Z := disjoint_cylinder_of_longestPrefix_lt hs xs (Nat.lt_succ_self _)\n      rw [cylinder_eq_cylinder_of_le_firstDiff _ _ H] at Z\n      exact (A'y.not_disjoint Z).elim\n  rw [l_eq, ‚Üê mem_cylinder_iff_eq]\n  exact cylinder_anti y H.le (mem_cylinder_firstDiff x y)\n\n"}
{"name":"PiNat.exists_lipschitz_retraction_of_isClosed","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nhne : s.Nonempty\n‚ä¢ Exists fun f => And (‚àÄ (x : (n : Nat) ‚Üí E n), Membership.mem s x ‚Üí Eq (f x) x) (And (Eq (Set.range f) s) (LipschitzWith 1 f))","decl":"/-- Given a closed nonempty subset `s` of `Œ† (n : ‚Ñï), E n`, there exists a Lipschitz retraction\nonto this set, i.e., a Lipschitz map with range equal to `s`, equal to the identity on `s`. -/\ntheorem exists_lipschitz_retraction_of_isClosed {s : Set (‚àÄ n, E n)} (hs : IsClosed s)\n    (hne : s.Nonempty) :\n    ‚àÉ f : (‚àÄ n, E n) ‚Üí ‚àÄ n, E n, (‚àÄ x ‚àà s, f x = x) ‚àß range f = s ‚àß LipschitzWith 1 f := by\n  /- The map `f` is defined as follows. For `x ‚àà s`, let `f x = x`. Otherwise, consider the longest\n    prefix `w` that `x` shares with an element of `s`, and let `f x = z_w` where `z_w` is an element\n    of `s` starting with `w`. All the desired properties are clear, except the fact that `f` is\n    `1`-Lipschitz: if two points `x, y` belong to a common cylinder of length `n`, one should show\n    that their images also belong to a common cylinder of length `n`. This is a case analysis:\n    * if both `x, y ‚àà s`, then this is clear.\n    * if `x ‚àà s` but `y ‚àâ s`, then the longest prefix `w` of `y` shared by an element of `s` is of\n    length at least `n` (because of `x`), and then `f y` starts with `w` and therefore stays in the\n    same length `n` cylinder.\n    * if `x ‚àâ s`, `y ‚àâ s`, let `w` be the longest prefix of `x` shared by an element of `s`. If its\n    length is `< n`, then it is also the longest prefix of `y`, and we get `f x = f y = z_w`.\n    Otherwise, `f x` remains in the same `n`-cylinder as `x`. Similarly for `y`. Finally, `f x` and\n    `f y` are again in the same `n`-cylinder, as desired. -/\n  classical\n  set f := fun x => if x ‚àà s then x else (inter_cylinder_longestPrefix_nonempty hs hne x).some\n  have fs : ‚àÄ x ‚àà s, f x = x := fun x xs => by simp [f, xs]\n  refine ‚ü®f, fs, ?_, ?_‚ü©\n  -- check that the range of `f` is `s`.\n  ¬∑ apply Subset.antisymm\n    ¬∑ rintro x ‚ü®y, rfl‚ü©\n      by_cases hy : y ‚àà s\n      ¬∑ rwa [fs y hy]\n      simpa [f, if_neg hy] using (inter_cylinder_longestPrefix_nonempty hs hne y).choose_spec.1\n    ¬∑ intro x hx\n      rw [‚Üê fs x hx]\n      exact mem_range_self _\n  -- check that `f` is `1`-Lipschitz, by a case analysis.\n  ¬∑ refine LipschitzWith.mk_one fun x y => ?_\n    -- exclude the trivial cases where `x = y`, or `f x = f y`.\n    rcases eq_or_ne x y with (rfl | hxy)\n    ¬∑ simp\n    rcases eq_or_ne (f x) (f y) with (h' | hfxfy)\n    ¬∑ simp [h', dist_nonneg]\n    have I2 : cylinder x (firstDiff x y) = cylinder y (firstDiff x y) := by\n      rw [‚Üê mem_cylinder_iff_eq]\n      apply mem_cylinder_firstDiff\n    suffices firstDiff x y ‚â§ firstDiff (f x) (f y) by\n      simpa [dist_eq_of_ne hxy, dist_eq_of_ne hfxfy]\n    -- case where `x ‚àà s`\n    by_cases xs : x ‚àà s\n    ¬∑ rw [fs x xs] at hfxfy ‚ä¢\n      -- case where `y ‚àà s`, trivial\n      by_cases ys : y ‚àà s\n      ¬∑ rw [fs y ys]\n      -- case where `y ‚àâ s`\n      have A : (s ‚à© cylinder y (longestPrefix y s)).Nonempty :=\n        inter_cylinder_longestPrefix_nonempty hs hne y\n      have fy : f y = A.some := by simp_rw [f, if_neg ys]\n      have I : cylinder A.some (firstDiff x y) = cylinder y (firstDiff x y) := by\n        rw [‚Üê mem_cylinder_iff_eq, firstDiff_comm]\n        apply cylinder_anti y _ A.some_mem.2\n        exact firstDiff_le_longestPrefix hs ys xs\n      rwa [‚Üê fy, ‚Üê I2, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy.symm,\n        firstDiff_comm _ x] at I\n    -- case where `x ‚àâ s`\n    ¬∑ by_cases ys : y ‚àà s\n      -- case where `y ‚àà s` (similar to the above)\n      ¬∑ have A : (s ‚à© cylinder x (longestPrefix x s)).Nonempty :=\n          inter_cylinder_longestPrefix_nonempty hs hne x\n        have fx : f x = A.some := by simp_rw [f, if_neg xs]\n        have I : cylinder A.some (firstDiff x y) = cylinder x (firstDiff x y) := by\n          rw [‚Üê mem_cylinder_iff_eq]\n          apply cylinder_anti x _ A.some_mem.2\n          apply firstDiff_le_longestPrefix hs xs ys\n        rw [fs y ys] at hfxfy ‚ä¢\n        rwa [‚Üê fx, I2, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at I\n      -- case where `y ‚àâ s`\n      ¬∑ have Ax : (s ‚à© cylinder x (longestPrefix x s)).Nonempty :=\n          inter_cylinder_longestPrefix_nonempty hs hne x\n        have fx : f x = Ax.some := by simp_rw [f, if_neg xs]\n        have Ay : (s ‚à© cylinder y (longestPrefix y s)).Nonempty :=\n          inter_cylinder_longestPrefix_nonempty hs hne y\n        have fy : f y = Ay.some := by simp_rw [f, if_neg ys]\n        -- case where the common prefix to `x` and `s`, or `y` and `s`, is shorter than the\n        -- common part to `x` and `y` -- then `f x = f y`.\n        by_cases H : longestPrefix x s < firstDiff x y ‚à® longestPrefix y s < firstDiff x y\n        ¬∑ have : cylinder x (longestPrefix x s) = cylinder y (longestPrefix y s) := by\n            cases' H with H H\n            ¬∑ exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H xs ys\n            ¬∑ symm\n              rw [firstDiff_comm] at H\n              exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H ys xs\n          rw [fx, fy] at hfxfy\n          apply (hfxfy _).elim\n          congr\n        -- case where the common prefix to `x` and `s` is long, as well as the common prefix to\n        -- `y` and `s`. Then all points remain in the same cylinders.\n        ¬∑ push_neg at H\n          have I1 : cylinder Ax.some (firstDiff x y) = cylinder x (firstDiff x y) := by\n            rw [‚Üê mem_cylinder_iff_eq]\n            exact cylinder_anti x H.1 Ax.some_mem.2\n          have I3 : cylinder y (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by\n            rw [eq_comm, ‚Üê mem_cylinder_iff_eq]\n            exact cylinder_anti y H.2 Ay.some_mem.2\n          have : cylinder Ax.some (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by\n            rw [I1, I2, I3]\n          rw [‚Üê fx, ‚Üê fy, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at this\n          exact this\n\n"}
{"name":"PiNat.exists_retraction_of_isClosed","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nhne : s.Nonempty\n‚ä¢ Exists fun f => And (‚àÄ (x : (n : Nat) ‚Üí E n), Membership.mem s x ‚Üí Eq (f x) x) (And (Eq (Set.range f) s) (Continuous f))","decl":"/-- Given a closed nonempty subset `s` of `Œ† (n : ‚Ñï), E n`, there exists a retraction onto this\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. -/\ntheorem exists_retraction_of_isClosed {s : Set (‚àÄ n, E n)} (hs : IsClosed s) (hne : s.Nonempty) :\n    ‚àÉ f : (‚àÄ n, E n) ‚Üí ‚àÄ n, E n, (‚àÄ x ‚àà s, f x = x) ‚àß range f = s ‚àß Continuous f := by\n  rcases exists_lipschitz_retraction_of_isClosed hs hne with ‚ü®f, fs, frange, hf‚ü©\n  exact ‚ü®f, fs, frange, hf.continuous‚ü©\n\n"}
{"name":"PiNat.exists_retraction_subtype_of_isClosed","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"E : Nat ‚Üí Type u_1\ninst‚úù¬π : (n : Nat) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Nat), DiscreteTopology (E n)\ns : Set ((n : Nat) ‚Üí E n)\nhs : IsClosed s\nhne : s.Nonempty\n‚ä¢ Exists fun f => And (‚àÄ (x : ‚Üës), Eq (f ‚Üëx) x) (And (Function.Surjective f) (Continuous f))","decl":"theorem exists_retraction_subtype_of_isClosed {s : Set (‚àÄ n, E n)} (hs : IsClosed s)\n    (hne : s.Nonempty) :\n    ‚àÉ f : (‚àÄ n, E n) ‚Üí s, (‚àÄ x : s, f x = x) ‚àß Surjective f ‚àß Continuous f := by\n  obtain ‚ü®f, fs, rfl, f_cont‚ü© :\n    ‚àÉ f : (‚àÄ n, E n) ‚Üí ‚àÄ n, E n, (‚àÄ x ‚àà s, f x = x) ‚àß range f = s ‚àß Continuous f :=\n    exists_retraction_of_isClosed hs hne\n  have A : ‚àÄ x : range f, rangeFactorization f x = x := fun x ‚Ü¶ Subtype.eq <| fs x x.2\n  exact ‚ü®rangeFactorization f, A, fun x => ‚ü®x, A x‚ü©, f_cont.subtype_mk _‚ü©\n\n"}
{"name":"exists_nat_nat_continuous_surjective_of_completeSpace","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : MetricSpace Œ±\ninst‚úù¬≤ : CompleteSpace Œ±\ninst‚úù¬π : SecondCountableTopology Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ Exists fun f => And (Continuous f) (Function.Surjective f)","decl":"/-- Any nonempty complete second countable metric space is the continuous image of the\nfundamental space `‚Ñï ‚Üí ‚Ñï`. For a version of this theorem in the context of Polish spaces, see\n`exists_nat_nat_continuous_surjective_of_polishSpace`. -/\ntheorem exists_nat_nat_continuous_surjective_of_completeSpace (Œ± : Type*) [MetricSpace Œ±]\n    [CompleteSpace Œ±] [SecondCountableTopology Œ±] [Nonempty Œ±] :\n    ‚àÉ f : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±, Continuous f ‚àß Surjective f := by\n  /- First, we define a surjective map from a closed subset `s` of `‚Ñï ‚Üí ‚Ñï`. Then, we compose\n    this map with a retraction of `‚Ñï ‚Üí ‚Ñï` onto `s` to obtain the desired map.\n    Let us consider a dense sequence `u` in `Œ±`. Then `s` is the set of sequences `x‚Çô` such that the\n    balls `closedBall (u x‚Çô) (1/2^n)` have a nonempty intersection. This set is closed,\n    and we define `f x` there to be the unique point in the intersection.\n    This function is continuous and surjective by design. -/\n  letI : MetricSpace (‚Ñï ‚Üí ‚Ñï) := PiNat.metricSpaceNatNat\n  have I0 : (0 : ‚Ñù) < 1 / 2 := by norm_num\n  have I1 : (1 / 2 : ‚Ñù) < 1 := by norm_num\n  rcases exists_dense_seq Œ± with ‚ü®u, hu‚ü©\n  let s : Set (‚Ñï ‚Üí ‚Ñï) := { x | (‚ãÇ n : ‚Ñï, closedBall (u (x n)) ((1 / 2) ^ n)).Nonempty }\n  let g : s ‚Üí Œ± := fun x => x.2.some\n  have A : ‚àÄ (x : s) (n : ‚Ñï), dist (g x) (u ((x : ‚Ñï ‚Üí ‚Ñï) n)) ‚â§ (1 / 2) ^ n := fun x n =>\n    (mem_iInter.1 x.2.some_mem n :)\n  have g_cont : Continuous g := by\n    refine continuous_iff_continuousAt.2 fun y => ?_\n    refine continuousAt_of_locally_lipschitz zero_lt_one 4 fun x hxy => ?_\n    rcases eq_or_ne x y with (rfl | hne)\n    ¬∑ simp\n    have hne' : x.1 ‚â† y.1 := Subtype.coe_injective.ne hne\n    have dist' : dist x y = dist x.1 y.1 := rfl\n    let n := firstDiff x.1 y.1 - 1\n    have diff_pos : 0 < firstDiff x.1 y.1 := by\n      by_contra! h\n      apply apply_firstDiff_ne hne'\n      rw [Nat.le_zero.1 h]\n      apply apply_eq_of_dist_lt _ le_rfl\n      rw [pow_zero]\n      exact hxy\n    have hn : firstDiff x.1 y.1 = n + 1 := (Nat.succ_pred_eq_of_pos diff_pos).symm\n    rw [dist', dist_eq_of_ne hne', hn]\n    have B : x.1 n = y.1 n := mem_cylinder_firstDiff x.1 y.1 n (Nat.pred_lt diff_pos.ne')\n    calc\n      dist (g x) (g y) ‚â§ dist (g x) (u (x.1 n)) + dist (g y) (u (x.1 n)) :=\n        dist_triangle_right _ _ _\n      _ = dist (g x) (u (x.1 n)) + dist (g y) (u (y.1 n)) := by rw [‚Üê B]\n      _ ‚â§ (1 / 2) ^ n + (1 / 2) ^ n := add_le_add (A x n) (A y n)\n      _ = 4 * (1 / 2) ^ (n + 1) := by ring\n  have g_surj : Surjective g := fun y ‚Ü¶ by\n    have : ‚àÄ n : ‚Ñï, ‚àÉ j, y ‚àà closedBall (u j) ((1 / 2) ^ n) := fun n ‚Ü¶ by\n      rcases hu.exists_dist_lt y (by simp : (0 : ‚Ñù) < (1 / 2) ^ n) with ‚ü®j, hj‚ü©\n      exact ‚ü®j, hj.le‚ü©\n    choose x hx using this\n    have I : (‚ãÇ n : ‚Ñï, closedBall (u (x n)) ((1 / 2) ^ n)).Nonempty := ‚ü®y, mem_iInter.2 hx‚ü©\n    refine ‚ü®‚ü®x, I‚ü©, ?_‚ü©\n    refine dist_le_zero.1 ?_\n    have J : ‚àÄ n : ‚Ñï, dist (g ‚ü®x, I‚ü©) y ‚â§ (1 / 2) ^ n + (1 / 2) ^ n := fun n =>\n      calc\n        dist (g ‚ü®x, I‚ü©) y ‚â§ dist (g ‚ü®x, I‚ü©) (u (x n)) + dist y (u (x n)) :=\n          dist_triangle_right _ _ _\n        _ ‚â§ (1 / 2) ^ n + (1 / 2) ^ n := add_le_add (A ‚ü®x, I‚ü© n) (hx n)\n    have L : Tendsto (fun n : ‚Ñï => (1 / 2 : ‚Ñù) ^ n + (1 / 2) ^ n) atTop (ùìù (0 + 0)) :=\n      (tendsto_pow_atTop_nhds_zero_of_lt_one I0.le I1).add\n        (tendsto_pow_atTop_nhds_zero_of_lt_one I0.le I1)\n    rw [add_zero] at L\n    exact ge_of_tendsto' L J\n  have s_closed : IsClosed s := by\n    refine isClosed_iff_clusterPt.mpr fun x hx ‚Ü¶ ?_\n    have L : Tendsto (fun n : ‚Ñï => diam (closedBall (u (x n)) ((1 / 2) ^ n))) atTop (ùìù 0) := by\n      have : Tendsto (fun n : ‚Ñï => (2 : ‚Ñù) * (1 / 2) ^ n) atTop (ùìù (2 * 0)) :=\n        (tendsto_pow_atTop_nhds_zero_of_lt_one I0.le I1).const_mul _\n      rw [mul_zero] at this\n      exact\n        squeeze_zero (fun n => diam_nonneg) (fun n => diam_closedBall (pow_nonneg I0.le _)) this\n    refine nonempty_iInter_of_nonempty_biInter (fun n => isClosed_ball)\n      (fun n => isBounded_closedBall) (fun N ‚Ü¶ ?_) L\n    obtain ‚ü®y, hxy, ys‚ü© : ‚àÉ y, y ‚àà ball x ((1 / 2) ^ N) ‚à© s :=\n      clusterPt_principal_iff.1 hx _ (ball_mem_nhds x (pow_pos I0 N))\n    have E :\n      ‚ãÇ (n : ‚Ñï) (H : n ‚â§ N), closedBall (u (x n)) ((1 / 2) ^ n) =\n        ‚ãÇ (n : ‚Ñï) (H : n ‚â§ N), closedBall (u (y n)) ((1 / 2) ^ n) := by\n      refine iInter_congr fun n ‚Ü¶ iInter_congr fun hn ‚Ü¶ ?_\n      have : x n = y n := apply_eq_of_dist_lt (mem_ball'.1 hxy) hn\n      rw [this]\n    rw [E]\n    apply Nonempty.mono _ ys\n    apply iInter_subset_iInter‚ÇÇ\n  obtain ‚ü®f, -, f_surj, f_cont‚ü© :\n    ‚àÉ f : (‚Ñï ‚Üí ‚Ñï) ‚Üí s, (‚àÄ x : s, f x = x) ‚àß Surjective f ‚àß Continuous f := by\n    apply exists_retraction_subtype_of_isClosed s_closed\n    simpa only [nonempty_coe_sort] using g_surj.nonempty\n  exact ‚ü®g ‚àò f, g_cont.comp f_cont, g_surj.comp f_surj‚ü©\n\n"}
{"name":"PiCountable.dist_eq_tsum","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œπ : Type u_2\ninst‚úù¬π : Encodable Œπ\nF : Œπ ‚Üí Type u_3\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (F i)\nx y : (i : Œπ) ‚Üí F i\n‚ä¢ Eq (Dist.dist x y) (tsum fun i => Min.min (HPow.hPow (1 / 2) (Encodable.encode i)) (Dist.dist (x i) (y i)))","decl":"theorem dist_eq_tsum (x y : ‚àÄ i, F i) :\n    dist x y = ‚àë' i : Œπ, min ((1 / 2) ^ encode i : ‚Ñù) (dist (x i) (y i)) :=\n  rfl\n\n"}
{"name":"PiCountable.dist_summable","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œπ : Type u_2\ninst‚úù¬π : Encodable Œπ\nF : Œπ ‚Üí Type u_3\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (F i)\nx y : (i : Œπ) ‚Üí F i\n‚ä¢ Summable fun i => Min.min (HPow.hPow (1 / 2) (Encodable.encode i)) (Dist.dist (x i) (y i))","decl":"theorem dist_summable (x y : ‚àÄ i, F i) :\n    Summable fun i : Œπ => min ((1 / 2) ^ encode i : ‚Ñù) (dist (x i) (y i)) := by\n  refine .of_nonneg_of_le (fun i => ?_) (fun i => min_le_left _ _)\n    summable_geometric_two_encode\n  exact le_min (pow_nonneg (by norm_num) _) dist_nonneg\n\n"}
{"name":"PiCountable.min_dist_le_dist_pi","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œπ : Type u_2\ninst‚úù¬π : Encodable Œπ\nF : Œπ ‚Üí Type u_3\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (F i)\nx y : (i : Œπ) ‚Üí F i\ni : Œπ\n‚ä¢ LE.le (Min.min (HPow.hPow (1 / 2) (Encodable.encode i)) (Dist.dist (x i) (y i))) (Dist.dist x y)","decl":"theorem min_dist_le_dist_pi (x y : ‚àÄ i, F i) (i : Œπ) :\n    min ((1 / 2) ^ encode i : ‚Ñù) (dist (x i) (y i)) ‚â§ dist x y :=\n  le_tsum (dist_summable x y) i fun j _ => le_min (by simp) dist_nonneg\n\n"}
{"name":"PiCountable.dist_le_dist_pi_of_dist_lt","module":"Mathlib.Topology.MetricSpace.PiNat","initialProofState":"Œπ : Type u_2\ninst‚úù¬π : Encodable Œπ\nF : Œπ ‚Üí Type u_3\ninst‚úù : (i : Œπ) ‚Üí MetricSpace (F i)\nx y : (i : Œπ) ‚Üí F i\ni : Œπ\nh : LT.lt (Dist.dist x y) (HPow.hPow (1 / 2) (Encodable.encode i))\n‚ä¢ LE.le (Dist.dist (x i) (y i)) (Dist.dist x y)","decl":"theorem dist_le_dist_pi_of_dist_lt {x y : ‚àÄ i, F i} {i : Œπ} (h : dist x y < (1 / 2) ^ encode i) :\n    dist (x i) (y i) ‚â§ dist x y := by\n  simpa only [not_le.2 h, false_or] using min_le_iff.1 (min_dist_le_dist_pi x y i)\n\n"}
