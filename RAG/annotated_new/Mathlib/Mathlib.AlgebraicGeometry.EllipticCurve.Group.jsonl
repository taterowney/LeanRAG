{"name":"WeierstrassCurve.Affine.CoordinateRing.instIsScalarTowerPolynomial","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\n⊢ IsScalarTower R (Polynomial R) W.CoordinateRing","decl":"instance : IsScalarTower R R[X] W.CoordinateRing :=\n  Quotient.isScalarTower R R[X] _\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.instSubsingleton","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nW : WeierstrassCurve.Affine R\ninst✝ : Subsingleton R\n⊢ Subsingleton W.CoordinateRing","decl":"instance [Subsingleton R] : Subsingleton W.CoordinateRing :=\n  Module.subsingleton R[X] _\n\n-- Porting note: added the abbreviation `mk` for `AdjoinRoot.mk W.polynomial`\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.basis_apply","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\nn : Fin 2\n⊢ Eq ((WeierstrassCurve.Affine.CoordinateRing.basis W) n) (HPow.hPow (AdjoinRoot.powerBasis' ⋯).gen ↑n)","decl":"lemma basis_apply (n : Fin 2) :\n    CoordinateRing.basis W n = (AdjoinRoot.powerBasis' W.monic_polynomial).gen ^ (n : ℕ) := by\n  classical\n  nontriviality R\n  rw [CoordinateRing.basis, Or.by_cases, dif_neg <| not_subsingleton R, Basis.reindex_apply,\n    PowerBasis.basis_eq_pow]\n  rfl\n\n-- Porting note: added `@[simp]` in lieu of `coe_basis`\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.basis_zero","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\n⊢ Eq ((WeierstrassCurve.Affine.CoordinateRing.basis W) 0) 1","decl":"@[simp]\nlemma basis_zero : CoordinateRing.basis W 0 = 1 := by\n  simpa only [basis_apply] using pow_zero _\n\n-- Porting note: added `@[simp]` in lieu of `coe_basis`\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.basis_one","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\n⊢ Eq ((WeierstrassCurve.Affine.CoordinateRing.basis W) 1) ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X)","decl":"@[simp]\nlemma basis_one : CoordinateRing.basis W 1 = mk W Y := by\n  simpa only [basis_apply] using pow_one _\n\n-- Porting note: removed `@[simp]` in lieu of `basis_zero` and `basis_one`\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.coe_basis","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\n⊢ Eq (⇑(WeierstrassCurve.Affine.CoordinateRing.basis W)) (Matrix.vecCons 1 (Matrix.vecCons ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X) Matrix.vecEmpty))","decl":"lemma coe_basis : (CoordinateRing.basis W : Fin 2 → W.CoordinateRing) = ![1, mk W Y] := by\n  ext n\n  fin_cases n\n  exacts [basis_zero W, basis_one W]\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.smul","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\nx : Polynomial R\ny : W.CoordinateRing\n⊢ Eq (HSMul.hSMul x y) (HMul.hMul ((WeierstrassCurve.Affine.CoordinateRing.mk W) (Polynomial.C x)) y)","decl":"variable {W} in\nlemma smul (x : R[X]) (y : W.CoordinateRing) : x • y = mk W (C x) * y :=\n  (algebraMap_smul W.CoordinateRing x y).symm\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.smul_basis_eq_zero","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\np q : Polynomial R\nhpq : Eq (HAdd.hAdd (HSMul.hSMul p 1) (HSMul.hSMul q ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X))) 0\n⊢ And (Eq p 0) (Eq q 0)","decl":"variable {W} in\nlemma smul_basis_eq_zero {p q : R[X]} (hpq : p • (1 : W.CoordinateRing) + q • mk W Y = 0) :\n    p = 0 ∧ q = 0 := by\n  have h := Fintype.linearIndependent_iff.mp (CoordinateRing.basis W).linearIndependent ![p, q]\n  erw [Fin.sum_univ_succ, basis_zero, Fin.sum_univ_one, basis_one] at h\n  exact ⟨h hpq 0, h hpq 1⟩\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.exists_smul_basis_eq","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\nx : W.CoordinateRing\n⊢ Exists fun p => Exists fun q => Eq (HAdd.hAdd (HSMul.hSMul p 1) (HSMul.hSMul q ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X))) x","decl":"variable {W} in\nlemma exists_smul_basis_eq (x : W.CoordinateRing) :\n    ∃ p q : R[X], p • (1 : W.CoordinateRing) + q • mk W Y = x := by\n  have h := (CoordinateRing.basis W).sum_equivFun x\n  erw [Fin.sum_univ_succ, Fin.sum_univ_one, basis_zero, basis_one] at h\n  exact ⟨_, _, h⟩\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.smul_basis_mul_C","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\ny p q : Polynomial R\n⊢ Eq (HMul.hMul (HAdd.hAdd (HSMul.hSMul p 1) (HSMul.hSMul q ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X))) ((WeierstrassCurve.Affine.CoordinateRing.mk W) (Polynomial.C y))) (HAdd.hAdd (HSMul.hSMul (HMul.hMul p y) 1) (HSMul.hSMul (HMul.hMul q y) ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X)))","decl":"lemma smul_basis_mul_C (y : R[X]) (p q : R[X]) :\n    (p • (1 : W.CoordinateRing) + q • mk W Y) * mk W (C y) =\n      (p * y) • (1 : W.CoordinateRing) + (q * y) • mk W Y := by\n  simp only [smul, _root_.map_mul]\n  ring1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.smul_basis_mul_Y","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\np q : Polynomial R\n⊢ Eq (HMul.hMul (HAdd.hAdd (HSMul.hSMul p 1) (HSMul.hSMul q ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X))) ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X)) (HAdd.hAdd (HSMul.hSMul (HMul.hMul q (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow Polynomial.X 3) (HMul.hMul (Polynomial.C W.a₂) (HPow.hPow Polynomial.X 2))) (HMul.hMul (Polynomial.C W.a₄) Polynomial.X)) (Polynomial.C W.a₆))) 1) (HSMul.hSMul (HSub.hSub p (HMul.hMul q (HAdd.hAdd (HMul.hMul (Polynomial.C W.a₁) Polynomial.X) (Polynomial.C W.a₃)))) ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X)))","decl":"lemma smul_basis_mul_Y (p q : R[X]) : (p • (1 : W.CoordinateRing) + q • mk W Y) * mk W Y =\n    (q * (X ^ 3 + C W.a₂ * X ^ 2 + C W.a₄ * X + C W.a₆)) • (1 : W.CoordinateRing) +\n      (p - q * (C W.a₁ * X + C W.a₃)) • mk W Y := by\n  have Y_sq : mk W Y ^ 2 =\n      mk W (C (X ^ 3 + C W.a₂ * X ^ 2 + C W.a₄ * X + C W.a₆) - C (C W.a₁ * X + C W.a₃) * Y) := by\n    exact AdjoinRoot.mk_eq_mk.mpr ⟨1, by rw [polynomial]; ring1⟩\n  simp only [smul, add_mul, mul_assoc, ← sq, Y_sq, C_sub, map_sub, C_mul, _root_.map_mul]\n  ring1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.map_mk","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nW : WeierstrassCurve.Affine R\nf : RingHom R S\nx : Polynomial (Polynomial R)\n⊢ Eq ((WeierstrassCurve.Affine.CoordinateRing.map W f) ((WeierstrassCurve.Affine.CoordinateRing.mk W) x)) ((WeierstrassCurve.Affine.CoordinateRing.mk (WeierstrassCurve.map W f)) (Polynomial.map (Polynomial.mapRingHom f) x))","decl":"lemma map_mk (x : R[X][Y]) : map W f (mk W x) = mk (W.map f) (x.map <| mapRingHom f) := by\n  rw [map, AdjoinRoot.lift_mk, ← eval₂_map]\n  exact AdjoinRoot.aeval_eq <| x.map <| mapRingHom f\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.map_smul","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nW : WeierstrassCurve.Affine R\nf : RingHom R S\nx : Polynomial R\ny : W.CoordinateRing\n⊢ Eq ((WeierstrassCurve.Affine.CoordinateRing.map W f) (HSMul.hSMul x y)) (HSMul.hSMul (Polynomial.map f x) ((WeierstrassCurve.Affine.CoordinateRing.map W f) y))","decl":"variable {W} in\nprotected lemma map_smul (x : R[X]) (y : W.CoordinateRing) :\n    map W f (x • y) = x.map f • map W f y := by\n  rw [smul, _root_.map_mul, map_mk, map_C, smul]\n  rfl\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.map_injective","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nW : WeierstrassCurve.Affine R\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(WeierstrassCurve.Affine.CoordinateRing.map W f)","decl":"variable {f} in\nlemma map_injective (hf : Function.Injective f) : Function.Injective <| map W f :=\n  (injective_iff_map_eq_zero _).mpr fun y hy => by\n    obtain ⟨p, q, rfl⟩ := exists_smul_basis_eq y\n    simp_rw [map_add, CoordinateRing.map_smul, map_one, map_mk, map_X] at hy\n    obtain ⟨hp, hq⟩ := smul_basis_eq_zero hy\n    rw [Polynomial.map_eq_zero_iff hf] at hp hq\n    simp_rw [hp, hq, zero_smul, add_zero]\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.instIsDomain","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nW : WeierstrassCurve.Affine R\ninst✝ : IsDomain R\n⊢ IsDomain W.CoordinateRing","decl":"instance [IsDomain R] : IsDomain W.CoordinateRing :=\n  have : IsDomain (W.map <| algebraMap R <| FractionRing R).toAffine.CoordinateRing :=\n    AdjoinRoot.isDomain_of_prime (irreducible_polynomial _).prime\n  (map_injective W <| IsFractionRing.injective R <| FractionRing R).isDomain\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.XClass_ne_zero","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nW : WeierstrassCurve.Affine R\ninst✝ : Nontrivial R\nx : R\n⊢ Ne (WeierstrassCurve.Affine.CoordinateRing.XClass W x) 0","decl":"lemma XClass_ne_zero [Nontrivial R] (x : R) : XClass W x ≠ 0 :=\n  AdjoinRoot.mk_ne_zero_of_natDegree_lt W.monic_polynomial (C_ne_zero.mpr <| X_sub_C_ne_zero x) <|\n    by rw [natDegree_polynomial, natDegree_C]; norm_num1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.YClass_ne_zero","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nW : WeierstrassCurve.Affine R\ninst✝ : Nontrivial R\ny : Polynomial R\n⊢ Ne (WeierstrassCurve.Affine.CoordinateRing.YClass W y) 0","decl":"lemma YClass_ne_zero [Nontrivial R] (y : R[X]) : YClass W y ≠ 0 :=\n  AdjoinRoot.mk_ne_zero_of_natDegree_lt W.monic_polynomial (X_sub_C_ne_zero y) <|\n    by rw [natDegree_polynomial, natDegree_X_sub_C]; norm_num1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.C_addPolynomial","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\nx y L : R\n⊢ Eq ((WeierstrassCurve.Affine.CoordinateRing.mk W) (Polynomial.C (W.addPolynomial x y L))) ((WeierstrassCurve.Affine.CoordinateRing.mk W) (HMul.hMul (HSub.hSub Polynomial.X (Polynomial.C (WeierstrassCurve.Affine.linePolynomial x y L))) (HSub.hSub W.negPolynomial (Polynomial.C (WeierstrassCurve.Affine.linePolynomial x y L)))))","decl":"lemma C_addPolynomial (x y L : R) : mk W (C <| W.addPolynomial x y L) =\n    mk W ((Y - C (linePolynomial x y L)) * (W.negPolynomial - C (linePolynomial x y L))) :=\n  AdjoinRoot.mk_eq_mk.mpr ⟨1, by rw [W.C_addPolynomial, add_sub_cancel_left, mul_one]⟩\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.XYIdeal_eq₁","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\nx y L : R\n⊢ Eq (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W x (Polynomial.C y)) (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W x (WeierstrassCurve.Affine.linePolynomial x y L))","decl":"lemma XYIdeal_eq₁ (x y L : R) : XYIdeal W x (C y) = XYIdeal W x (linePolynomial x y L) := by\n  simp only [XYIdeal, XClass, YClass, linePolynomial]\n  rw [← span_pair_add_mul_right <| mk W <| C <| C <| -L, ← _root_.map_mul, ← map_add]\n  apply congr_arg (_ ∘ _ ∘ _ ∘ _)\n  C_simp\n  ring1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.XYIdeal_add_eq","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\nx₁ x₂ y₁ L : R\n⊢ Eq (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W (W.addX x₁ x₂ L) (Polynomial.C (W.addY x₁ x₂ y₁ L))) (Max.max (Ideal.span (Singleton.singleton ((WeierstrassCurve.Affine.CoordinateRing.mk W) (HSub.hSub W.negPolynomial (Polynomial.C (WeierstrassCurve.Affine.linePolynomial x₁ y₁ L)))))) (WeierstrassCurve.Affine.CoordinateRing.XIdeal W (W.addX x₁ x₂ L)))","decl":"lemma XYIdeal_add_eq (x₁ x₂ y₁ L : R) : XYIdeal W (W.addX x₁ x₂ L) (C <| W.addY x₁ x₂ y₁ L) =\n    span {mk W <| W.negPolynomial - C (linePolynomial x₁ y₁ L)} ⊔ XIdeal W (W.addX x₁ x₂ L) := by\n  simp only [XYIdeal, XIdeal, XClass, YClass, addY, negAddY, negY, negPolynomial, linePolynomial]\n  rw [sub_sub <| -(Y : R[X][Y]), neg_sub_left (Y : R[X][Y]), map_neg, span_singleton_neg, sup_comm,\n    ← span_insert, ← span_pair_add_mul_right <| mk W <| C <| C <| W.a₁ + L, ← _root_.map_mul,\n    ← map_add]\n  apply congr_arg (_ ∘ _ ∘ _ ∘ _)\n  C_simp\n  ring1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.C_addPolynomial_slope","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\nx₁ x₂ y₁ y₂ : F\nh₁ : W.Equation x₁ y₁\nh₂ : W.Equation x₂ y₂\nhxy : Eq x₁ x₂ → Ne y₁ (W.negY x₂ y₂)\n⊢ Eq ((WeierstrassCurve.Affine.CoordinateRing.mk W) (Polynomial.C (W.addPolynomial x₁ y₁ (W.slope x₁ x₂ y₁ y₂)))) (Neg.neg (HMul.hMul (HMul.hMul (WeierstrassCurve.Affine.CoordinateRing.XClass W x₁) (WeierstrassCurve.Affine.CoordinateRing.XClass W x₂)) (WeierstrassCurve.Affine.CoordinateRing.XClass W (W.addX x₁ x₂ (W.slope x₁ x₂ y₁ y₂)))))","decl":"lemma C_addPolynomial_slope {x₁ x₂ y₁ y₂ : F} (h₁ : W.Equation x₁ y₁) (h₂ : W.Equation x₂ y₂)\n    (hxy : x₁ = x₂ → y₁ ≠ W.negY x₂ y₂) : mk W (C <| W.addPolynomial x₁ y₁ <| W.slope x₁ x₂ y₁ y₂) =\n      -(XClass W x₁ * XClass W x₂ * XClass W (W.addX x₁ x₂ <| W.slope x₁ x₂ y₁ y₂)) := by\n  simp only [addPolynomial_slope h₁ h₂ hxy, C_neg, mk, map_neg, neg_inj, _root_.map_mul]\n  rfl\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.XYIdeal_eq₂","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\nx₁ x₂ y₁ y₂ : F\nh₁ : W.Equation x₁ y₁\nh₂ : W.Equation x₂ y₂\nhxy : Eq x₁ x₂ → Ne y₁ (W.negY x₂ y₂)\n⊢ Eq (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W x₂ (Polynomial.C y₂)) (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W x₂ (WeierstrassCurve.Affine.linePolynomial x₁ y₁ (W.slope x₁ x₂ y₁ y₂)))","decl":"lemma XYIdeal_eq₂ {x₁ x₂ y₁ y₂ : F} (h₁ : W.Equation x₁ y₁)\n    (h₂ : W.Equation x₂ y₂) (hxy : x₁ = x₂ → y₁ ≠ W.negY x₂ y₂) :\n    XYIdeal W x₂ (C y₂) = XYIdeal W x₂ (linePolynomial x₁ y₁ <| W.slope x₁ x₂ y₁ y₂) := by\n  have hy₂ : y₂ = (linePolynomial x₁ y₁ <| W.slope x₁ x₂ y₁ y₂).eval x₂ := by\n    by_cases hx : x₁ = x₂\n    · rcases hx, Y_eq_of_Y_ne h₁ h₂ hx <| hxy hx with ⟨rfl, rfl⟩\n      field_simp [linePolynomial, sub_ne_zero_of_ne <| hxy rfl]\n    · field_simp [linePolynomial, slope_of_X_ne hx, sub_ne_zero_of_ne hx]\n      ring1\n  nth_rw 1 [hy₂]\n  simp only [XYIdeal, XClass, YClass, linePolynomial]\n  rw [← span_pair_add_mul_right <| mk W <| C <| C <| -W.slope x₁ x₂ y₁ y₂, ← _root_.map_mul,\n    ← map_add]\n  apply congr_arg (_ ∘ _ ∘ _ ∘ _)\n  eval_simp\n  C_simp\n  ring1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.XYIdeal_neg_mul","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\nx y : F\nh : W.Nonsingular x y\n⊢ Eq (HMul.hMul (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W x (Polynomial.C (W.negY x y))) (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W x (Polynomial.C y))) (WeierstrassCurve.Affine.CoordinateRing.XIdeal W x)","decl":"lemma XYIdeal_neg_mul {x y : F} (h : W.Nonsingular x y) :\n    XYIdeal W x (C <| W.negY x y) * XYIdeal W x (C y) = XIdeal W x := by\n  have Y_rw : (Y - C (C y)) * (Y - C (C <| W.negY x y)) -\n      C (X - C x) * (C (X ^ 2 + C (x + W.a₂) * X + C (x ^ 2 + W.a₂ * x + W.a₄)) - C (C W.a₁) * Y) =\n        W.polynomial * 1 := by\n    linear_combination (norm := (rw [negY, polynomial]; C_simp; ring1))\n      congr_arg C (congr_arg C ((equation_iff ..).mp h.left).symm)\n  simp_rw [XYIdeal, XClass, YClass, span_pair_mul_span_pair, mul_comm, ← _root_.map_mul,\n    AdjoinRoot.mk_eq_mk.mpr ⟨1, Y_rw⟩, _root_.map_mul, span_insert,\n    ← span_singleton_mul_span_singleton, ← Ideal.mul_sup, ← span_insert]\n  convert mul_top (_ : Ideal W.CoordinateRing) using 2\n  simp_rw [← Set.image_singleton (f := mk W), ← Set.image_insert_eq, ← map_span]\n  convert map_top (R := F[X][Y]) (mk W) using 1\n  apply congr_arg\n  simp_rw [eq_top_iff_one, mem_span_insert', mem_span_singleton']\n  rcases ((nonsingular_iff' ..).mp h).right with hx | hy\n  · let W_X := W.a₁ * y - (3 * x ^ 2 + 2 * W.a₂ * x + W.a₄)\n    refine\n      ⟨C <| C W_X⁻¹ * -(X + C (2 * x + W.a₂)), C <| C <| W_X⁻¹ * W.a₁, 0, C <| C <| W_X⁻¹ * -1, ?_⟩\n    rw [← mul_right_inj' <| C_ne_zero.mpr <| C_ne_zero.mpr hx]\n    simp only [W_X, mul_add, ← mul_assoc, ← C_mul, mul_inv_cancel₀ hx]\n    C_simp\n    ring1\n  · let W_Y := 2 * y + W.a₁ * x + W.a₃\n    refine ⟨0, C <| C W_Y⁻¹, C <| C <| W_Y⁻¹ * -1, 0, ?_⟩\n    rw [negY, ← mul_right_inj' <| C_ne_zero.mpr <| C_ne_zero.mpr hy]\n    simp only [W_Y, mul_add, ← mul_assoc, ← C_mul, mul_inv_cancel₀ hy]\n    C_simp\n    ring1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.XYIdeal_mul_XYIdeal","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\nx₁ x₂ y₁ y₂ : F\nh₁ : W.Equation x₁ y₁\nh₂ : W.Equation x₂ y₂\nhxy : Eq x₁ x₂ → Ne y₁ (W.negY x₂ y₂)\n⊢ Eq (HMul.hMul (WeierstrassCurve.Affine.CoordinateRing.XIdeal W (W.addX x₁ x₂ (W.slope x₁ x₂ y₁ y₂))) (HMul.hMul (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W x₁ (Polynomial.C y₁)) (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W x₂ (Polynomial.C y₂)))) (HMul.hMul (WeierstrassCurve.Affine.CoordinateRing.YIdeal W (WeierstrassCurve.Affine.linePolynomial x₁ y₁ (W.slope x₁ x₂ y₁ y₂))) (WeierstrassCurve.Affine.CoordinateRing.XYIdeal W (W.addX x₁ x₂ (W.slope x₁ x₂ y₁ y₂)) (Polynomial.C (W.addY x₁ x₂ y₁ (W.slope x₁ x₂ y₁ y₂)))))","decl":"lemma XYIdeal_mul_XYIdeal {x₁ x₂ y₁ y₂ : F} (h₁ : W.Equation x₁ y₁) (h₂ : W.Equation x₂ y₂)\n    (hxy : x₁ = x₂ → y₁ ≠ W.negY x₂ y₂) :\n    XIdeal W (W.addX x₁ x₂ <| W.slope x₁ x₂ y₁ y₂) * (XYIdeal W x₁ (C y₁) * XYIdeal W x₂ (C y₂)) =\n      YIdeal W (linePolynomial x₁ y₁ <| W.slope x₁ x₂ y₁ y₂) *\n        XYIdeal W (W.addX x₁ x₂ <| W.slope x₁ x₂ y₁ y₂)\n          (C <| W.addY x₁ x₂ y₁ <| W.slope x₁ x₂ y₁ y₂) := by\n  have sup_rw : ∀ a b c d : Ideal W.CoordinateRing, a ⊔ (b ⊔ (c ⊔ d)) = a ⊔ d ⊔ b ⊔ c :=\n    fun _ _ c _ => by rw [← sup_assoc, sup_comm c, sup_sup_sup_comm, ← sup_assoc]\n  rw [XYIdeal_add_eq, XIdeal, mul_comm, XYIdeal_eq₁ W x₁ y₁ <| W.slope x₁ x₂ y₁ y₂, XYIdeal,\n    XYIdeal_eq₂ h₁ h₂ hxy, XYIdeal, span_pair_mul_span_pair]\n  simp_rw [span_insert, sup_rw, Ideal.sup_mul, span_singleton_mul_span_singleton]\n  rw [← neg_eq_iff_eq_neg.mpr <| C_addPolynomial_slope h₁ h₂ hxy, span_singleton_neg,\n    C_addPolynomial, _root_.map_mul, YClass]\n  simp_rw [mul_comm <| XClass W x₁, mul_assoc, ← span_singleton_mul_span_singleton, ← Ideal.mul_sup]\n  rw [span_singleton_mul_span_singleton, ← span_insert,\n    ← span_pair_add_mul_right <| -(XClass W <| W.addX x₁ x₂ <| W.slope x₁ x₂ y₁ y₂), mul_neg,\n    ← sub_eq_add_neg, ← sub_mul, ← map_sub <| mk W, sub_sub_sub_cancel_right, span_insert,\n    ← span_singleton_mul_span_singleton, ← sup_rw, ← Ideal.sup_mul, ← Ideal.sup_mul]\n  apply congr_arg (_ ∘ _)\n  convert top_mul (_ : Ideal W.CoordinateRing)\n  simp_rw [XClass, ← Set.image_singleton (f := mk W), ← map_span, ← Ideal.map_sup, eq_top_iff_one,\n    mem_map_iff_of_surjective _ AdjoinRoot.mk_surjective, ← span_insert, mem_span_insert',\n    mem_span_singleton']\n  by_cases hx : x₁ = x₂\n  · rcases hx, Y_eq_of_Y_ne h₁ h₂ hx (hxy hx) with ⟨rfl, rfl⟩\n    let y := (y₁ - W.negY x₁ y₁) ^ 2\n    replace hxy := pow_ne_zero 2 <| sub_ne_zero_of_ne <| hxy rfl\n    refine ⟨1 + C (C <| y⁻¹ * 4) * W.polynomial,\n      ⟨C <| C y⁻¹ * (C 4 * X ^ 2 + C (4 * x₁ + W.b₂) * X + C (4 * x₁ ^ 2 + W.b₂ * x₁ + 2 * W.b₄)),\n        0, C (C y⁻¹) * (Y - W.negPolynomial), ?_⟩, by\n      rw [map_add, map_one, _root_.map_mul <| mk W, AdjoinRoot.mk_self, mul_zero, add_zero]⟩\n    rw [polynomial, negPolynomial, ← mul_right_inj' <| C_ne_zero.mpr <| C_ne_zero.mpr hxy]\n    simp only [y, mul_add, ← mul_assoc, ← C_mul, mul_inv_cancel₀ hxy]\n    linear_combination (norm := (rw [b₂, b₄, negY]; C_simp; ring1))\n      -4 * congr_arg C (congr_arg C <| (equation_iff ..).mp h₁)\n  · replace hx := sub_ne_zero_of_ne hx\n    refine ⟨_, ⟨⟨C <| C (x₁ - x₂)⁻¹, C <| C <| (x₁ - x₂)⁻¹ * -1, 0, ?_⟩, map_one _⟩⟩\n    rw [← mul_right_inj' <| C_ne_zero.mpr <| C_ne_zero.mpr hx]\n    simp only [← mul_assoc, mul_add, ← C_mul, mul_inv_cancel₀ hx]\n    C_simp\n    ring1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.XYIdeal'_eq","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\nx y : F\nh : W.Nonsingular x y\n⊢ Eq ↑(WeierstrassCurve.Affine.CoordinateRing.XYIdeal' h) ↑(WeierstrassCurve.Affine.CoordinateRing.XYIdeal W x (Polynomial.C y))","decl":"lemma XYIdeal'_eq {x y : F} (h : W.Nonsingular x y) :\n    (XYIdeal' h : FractionalIdeal W.CoordinateRing⁰ W.FunctionField) = XYIdeal W x (C y) :=\n  rfl\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.mk_XYIdeal'_mul_mk_XYIdeal'_of_Yeq","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\nx y : F\nh : W.Nonsingular x y\n⊢ Eq (HMul.hMul (ClassGroup.mk (WeierstrassCurve.Affine.CoordinateRing.XYIdeal' ⋯)) (ClassGroup.mk (WeierstrassCurve.Affine.CoordinateRing.XYIdeal' h))) 1","decl":"lemma mk_XYIdeal'_mul_mk_XYIdeal'_of_Yeq {x y : F} (h : W.Nonsingular x y) :\n    ClassGroup.mk (XYIdeal' <| nonsingular_neg h) * ClassGroup.mk (XYIdeal' h) = 1 := by\n  rw [← _root_.map_mul]\n  exact\n    (ClassGroup.mk_eq_one_of_coe_ideal <| by exact (FractionalIdeal.coeIdeal_mul ..).symm.trans <|\n      FractionalIdeal.coeIdeal_inj.mpr <| XYIdeal_neg_mul h).mpr ⟨_, XClass_ne_zero W _, rfl⟩\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.mk_XYIdeal'_mul_mk_XYIdeal'","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\nx₁ x₂ y₁ y₂ : F\nh₁ : W.Nonsingular x₁ y₁\nh₂ : W.Nonsingular x₂ y₂\nhxy : Eq x₁ x₂ → Ne y₁ (W.negY x₂ y₂)\n⊢ Eq (HMul.hMul (ClassGroup.mk (WeierstrassCurve.Affine.CoordinateRing.XYIdeal' h₁)) (ClassGroup.mk (WeierstrassCurve.Affine.CoordinateRing.XYIdeal' h₂))) (ClassGroup.mk (WeierstrassCurve.Affine.CoordinateRing.XYIdeal' ⋯))","decl":"lemma mk_XYIdeal'_mul_mk_XYIdeal' {x₁ x₂ y₁ y₂ : F} (h₁ : W.Nonsingular x₁ y₁)\n    (h₂ : W.Nonsingular x₂ y₂) (hxy : x₁ = x₂ → y₁ ≠ W.negY x₂ y₂) :\n    ClassGroup.mk (XYIdeal' h₁) * ClassGroup.mk (XYIdeal' h₂) =\n      ClassGroup.mk (XYIdeal' <| nonsingular_add h₁ h₂ hxy) := by\n  rw [← _root_.map_mul]\n  exact (ClassGroup.mk_eq_mk_of_coe_ideal (by exact (FractionalIdeal.coeIdeal_mul ..).symm) <|\n      XYIdeal'_eq _).mpr\n    ⟨_, _, XClass_ne_zero W _, YClass_ne_zero W _, XYIdeal_mul_XYIdeal h₁.left h₂.left hxy⟩\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.norm_smul_basis","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\np q : Polynomial R\n⊢ Eq ((Algebra.norm (Polynomial R)) (HAdd.hAdd (HSMul.hSMul p 1) (HSMul.hSMul q ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X)))) (HSub.hSub (HSub.hSub (HPow.hPow p 2) (HMul.hMul (HMul.hMul p q) (HAdd.hAdd (HMul.hMul (Polynomial.C W.a₁) Polynomial.X) (Polynomial.C W.a₃)))) (HMul.hMul (HPow.hPow q 2) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow Polynomial.X 3) (HMul.hMul (Polynomial.C W.a₂) (HPow.hPow Polynomial.X 2))) (HMul.hMul (Polynomial.C W.a₄) Polynomial.X)) (Polynomial.C W.a₆))))","decl":"lemma norm_smul_basis (p q : R[X]) :\n    Algebra.norm R[X] (p • (1 : W.CoordinateRing) + q • mk W Y) =\n      p ^ 2 - p * q * (C W.a₁ * X + C W.a₃) -\n        q ^ 2 * (X ^ 3 + C W.a₂ * X ^ 2 + C W.a₄ * X + C W.a₆) := by\n  simp_rw [Algebra.norm_eq_matrix_det <| CoordinateRing.basis W, Matrix.det_fin_two,\n    Algebra.leftMulMatrix_eq_repr_mul, basis_zero, mul_one, basis_one, smul_basis_mul_Y, map_add,\n    Finsupp.add_apply, map_smul, Finsupp.smul_apply, ← basis_zero, ← basis_one,\n    Basis.repr_self_apply, if_pos, one_ne_zero, if_false, smul_eq_mul]\n  ring1\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.coe_norm_smul_basis","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝ : CommRing R\nW : WeierstrassCurve.Affine R\np q : Polynomial R\n⊢ Eq ((AdjoinRoot.of W.polynomial) ((Algebra.norm (Polynomial R)) (HAdd.hAdd (HSMul.hSMul p 1) (HSMul.hSMul q ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X))))) ((WeierstrassCurve.Affine.CoordinateRing.mk W) (HMul.hMul (HAdd.hAdd (Polynomial.C p) (HMul.hMul (Polynomial.C q) Polynomial.X)) (HAdd.hAdd (Polynomial.C p) (HMul.hMul (Polynomial.C q) (HSub.hSub (Neg.neg Polynomial.X) (Polynomial.C (HAdd.hAdd (HMul.hMul (Polynomial.C W.a₁) Polynomial.X) (Polynomial.C W.a₃))))))))","decl":"lemma coe_norm_smul_basis (p q : R[X]) :\n    Algebra.norm R[X] (p • (1 : W.CoordinateRing) + q • mk W Y) =\n      mk W ((C p + C q * X) * (C p + C q * (-(Y : R[X][Y]) - C (C W.a₁ * X + C W.a₃)))) :=\n  AdjoinRoot.mk_eq_mk.mpr\n    ⟨C q ^ 2, by simp only [norm_smul_basis, polynomial]; C_simp; ring1⟩\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.degree_norm_smul_basis","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nW : WeierstrassCurve.Affine R\ninst✝ : IsDomain R\np q : Polynomial R\n⊢ Eq ((Algebra.norm (Polynomial R)) (HAdd.hAdd (HSMul.hSMul p 1) (HSMul.hSMul q ((WeierstrassCurve.Affine.CoordinateRing.mk W) Polynomial.X)))).degree (Max.max (HSMul.hSMul 2 p.degree) (HAdd.hAdd (HSMul.hSMul 2 q.degree) 3))","decl":"lemma degree_norm_smul_basis [IsDomain R] (p q : R[X]) :\n    (Algebra.norm R[X] <| p • (1 : W.CoordinateRing) + q • mk W Y).degree =\n      max (2 • p.degree) (2 • q.degree + 3) := by\n  have hdp : (p ^ 2).degree = 2 • p.degree := degree_pow p 2\n  have hdpq : (p * q * (C W.a₁ * X + C W.a₃)).degree ≤ p.degree + q.degree + 1 := by\n    simpa only [degree_mul] using add_le_add_left degree_linear_le (p.degree + q.degree)\n  have hdq :\n      (q ^ 2 * (X ^ 3 + C W.a₂ * X ^ 2 + C W.a₄ * X + C W.a₆)).degree = 2 • q.degree + 3 := by\n    rw [degree_mul, degree_pow, ← one_mul <| X ^ 3, ← C_1, degree_cubic <| one_ne_zero' R]\n  rw [norm_smul_basis]\n  by_cases hp : p = 0\n  · simpa only [hp, hdq, neg_zero, zero_sub, zero_mul, zero_pow two_ne_zero, degree_neg] using\n      (max_bot_left _).symm\n  · by_cases hq : q = 0\n    · simpa only [hq, hdp, sub_zero, zero_mul, mul_zero, zero_pow two_ne_zero] using\n        (max_bot_right _).symm\n    · rw [← not_congr degree_eq_bot] at hp hq\n      -- Porting note: BUG `cases` tactic does not modify assumptions in `hp'` and `hq'`\n      rcases hp' : p.degree with _ | dp -- `hp' : ` should be redundant\n      · exact (hp hp').elim -- `hp'` should be `rfl`\n      · rw [hp'] at hdp hdpq -- line should be redundant\n        rcases hq' : q.degree with _ | dq -- `hq' : ` should be redundant\n        · exact (hq hq').elim -- `hq'` should be `rfl`\n        · rw [hq'] at hdpq hdq -- line should be redundant\n          rcases le_or_lt dp (dq + 1) with hpq | hpq\n          · convert (degree_sub_eq_right_of_degree_lt <| (degree_sub_le _ _).trans_lt <|\n                      max_lt_iff.mpr ⟨hdp.trans_lt _, hdpq.trans_lt _⟩).trans\n              (max_eq_right_of_lt _).symm <;> rw [hdq] <;>\n                exact WithBot.coe_lt_coe.mpr <| by dsimp; linarith only [hpq]\n          · rw [sub_sub]\n            convert (degree_sub_eq_left_of_degree_lt <| (degree_add_le _ _).trans_lt <|\n                      max_lt_iff.mpr ⟨hdpq.trans_lt _, hdq.trans_lt _⟩).trans\n              (max_eq_left_of_lt _).symm <;> rw [hdp] <;>\n                exact WithBot.coe_lt_coe.mpr <| by dsimp; linarith only [hpq]\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.degree_norm_ne_one","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nW : WeierstrassCurve.Affine R\ninst✝ : IsDomain R\nx : W.CoordinateRing\n⊢ Ne ((Algebra.norm (Polynomial R)) x).degree 1","decl":"variable {W} in\nlemma degree_norm_ne_one [IsDomain R] (x : W.CoordinateRing) :\n    (Algebra.norm R[X] x).degree ≠ 1 := by\n  rcases exists_smul_basis_eq x with ⟨p, q, rfl⟩\n  rw [degree_norm_smul_basis]\n  rcases p.degree with (_ | _ | _ | _) <;> cases q.degree\n  any_goals rintro (_ | _)\n  -- Porting note: replaced `dec_trivial` with `by exact (cmp_eq_lt_iff ..).mp rfl`\n  exact (lt_max_of_lt_right <| by exact (cmp_eq_lt_iff ..).mp rfl).ne'\n\n"}
{"name":"WeierstrassCurve.Affine.CoordinateRing.natDegree_norm_ne_one","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nW : WeierstrassCurve.Affine R\ninst✝ : IsDomain R\nx : W.CoordinateRing\n⊢ Ne ((Algebra.norm (Polynomial R)) x).natDegree 1","decl":"variable {W} in\nlemma natDegree_norm_ne_one [IsDomain R] (x : W.CoordinateRing) :\n    (Algebra.norm R[X] x).natDegree ≠ 1 :=\n  degree_norm_ne_one x ∘ (degree_eq_iff_natDegree_eq_of_pos zero_lt_one).mpr\n\n"}
{"name":"WeierstrassCurve.Affine.Point.toClass_apply","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\na✝ : W.Point\n⊢ Eq (WeierstrassCurve.Affine.Point.toClass a✝) a✝.toClassFun","decl":"/-- The group homomorphism mapping an affine point $(x, y)$ of `W` to the class of the non-zero\nfractional ideal $\\langle X - x, Y - y \\rangle$ of $F(W)$ in the class group of $F[W]$. -/\n@[simps]\nnoncomputable def toClass : W.Point →+ Additive (ClassGroup W.CoordinateRing) where\n  toFun := toClassFun\n  map_zero' := rfl\n  map_add' := by\n    rintro (_ | @⟨x₁, y₁, h₁⟩) (_ | @⟨x₂, y₂, h₂⟩)\n    any_goals simp only [zero_def, toClassFun, zero_add, add_zero]\n    obtain ⟨rfl, rfl⟩ | h := em (x₁ = x₂ ∧ y₁ = W.negY x₂ y₂)\n    · rw [add_of_Y_eq rfl rfl]\n      exact (CoordinateRing.mk_XYIdeal'_mul_mk_XYIdeal'_of_Yeq h₂).symm\n    · have h hx hy := h ⟨hx, hy⟩\n      rw [add_of_imp h]\n      exact (CoordinateRing.mk_XYIdeal'_mul_mk_XYIdeal' h₁ h₂ h).symm\n\n"}
{"name":"WeierstrassCurve.Affine.Point.toClass_zero","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\n⊢ Eq (WeierstrassCurve.Affine.Point.toClass 0) 0","decl":"lemma toClass_zero : toClass (0 : W.Point) = 0 :=\n  rfl\n\n"}
{"name":"WeierstrassCurve.Affine.Point.toClass_some","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\nx y : F\nh : W.Nonsingular x y\n⊢ Eq (WeierstrassCurve.Affine.Point.toClass (WeierstrassCurve.Affine.Point.some h)) (ClassGroup.mk (WeierstrassCurve.Affine.CoordinateRing.XYIdeal' h))","decl":"lemma toClass_some {x y : F} (h : W.Nonsingular x y) :\n    toClass (some h) = ClassGroup.mk (CoordinateRing.XYIdeal' h) :=\n  rfl\n\n"}
{"name":"WeierstrassCurve.Affine.Point.toClass_eq_zero","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\nP : W.Point\n⊢ Iff (Eq (WeierstrassCurve.Affine.Point.toClass P) 0) (Eq P 0)","decl":"lemma toClass_eq_zero (P : W.Point) : toClass P = 0 ↔ P = 0 := by\n  constructor\n  · intro hP\n    rcases P with (_ | ⟨h, _⟩)\n    · rfl\n    · rcases (ClassGroup.mk_eq_one_of_coe_ideal <| by rfl).mp hP with ⟨p, h0, hp⟩\n      apply (p.natDegree_norm_ne_one _).elim\n      rw [← finrank_quotient_span_eq_natDegree_norm (CoordinateRing.basis W) h0,\n        ← (quotientEquivAlgOfEq F hp).toLinearEquiv.finrank_eq,\n        (CoordinateRing.quotientXYIdealEquiv W h).toLinearEquiv.finrank_eq,\n        Module.finrank_self]\n  · exact congr_arg toClass\n\n"}
{"name":"WeierstrassCurve.Affine.Point.toClass_injective","module":"Mathlib.AlgebraicGeometry.EllipticCurve.Group","initialProofState":"F : Type u\ninst✝ : Field F\nW : WeierstrassCurve.Affine F\n⊢ Function.Injective ⇑WeierstrassCurve.Affine.Point.toClass","decl":"lemma toClass_injective : Function.Injective <| @toClass _ _ W := by\n  rintro (_ | h) _ hP\n  all_goals rw [← neg_inj, ← add_eq_zero, ← toClass_eq_zero, map_add, ← hP]\n  · exact zero_add 0\n  · exact CoordinateRing.mk_XYIdeal'_mul_mk_XYIdeal'_of_Yeq h\n\n"}
