{"name":"HomologicalComplex.mapBifunctorMapHomotopy.ιMapBifunctor_hom₁_assoc","module":"Mathlib.Algebra.Homology.BifunctorHomotopy","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\ninst✝¹¹ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁹ : CategoryTheory.Category.{u_7, u_3} D\ninst✝⁸ : CategoryTheory.Preadditive C₁\ninst✝⁷ : CategoryTheory.Preadditive C₂\ninst✝⁶ : CategoryTheory.Preadditive D\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ L₁ : HomologicalComplex C₁ c₁\nf₁ f₁' : Quiver.Hom K₁ L₁\nh₁ : Homotopy f₁ f₁'\nK₂ L₂ : HomologicalComplex C₂ c₂\nf₂ : Quiver.Hom K₂ L₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁵ : F.Additive\ninst✝⁴ : ∀ (X₁ : C₁), (F.obj X₁).Additive\nc : ComplexShape J\ninst✝³ : DecidableEq J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : L₁.HasMapBifunctor L₂ F c\ni₁ i₁' : I₁\ni₂ : I₂\nj j' : J\nh✝ : Eq (c₁.π c₂ c { fst := i₁', snd := i₂ }) j\nh' : Eq (c₁.prev i₁') i₁\nZ : D\nh : Quiver.Hom ((L₁.mapBifunctor L₂ F c).X j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁' i₂ j h✝) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.mapBifunctorMapHomotopy.hom₁ h₁ f₂ F c j j') h)) (CategoryTheory.CategoryStruct.comp (HSMul.hSMul (c₁.ε₁ c₂ c { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((F.map (h₁.hom i₁' i₁)).app (K₂.X i₂)) (CategoryTheory.CategoryStruct.comp ((F.obj (L₁.X i₁)).map (f₂.f i₂)) (L₁.ιMapBifunctorOrZero L₂ F c i₁ i₂ j')))) h)","decl":"@[reassoc]\nlemma ιMapBifunctor_hom₁ (i₁ i₁' : I₁) (i₂ : I₂) (j j' : J)\n    (h : ComplexShape.π c₁ c₂ c (i₁', i₂) = j) (h' : c₁.prev i₁' = i₁) :\n    ιMapBifunctor K₁ K₂ F c i₁' i₂ j h ≫ hom₁ h₁ f₂ F c j j' = ComplexShape.ε₁ c₁ c₂ c (i₁, i₂) •\n      (F.map (h₁.hom i₁' i₁)).app (K₂.X i₂) ≫ (F.obj (L₁.X i₁)).map (f₂.f i₂) ≫\n        ιMapBifunctorOrZero L₁ L₂ F c _ _ j' := by\n  subst h'\n  simp [hom₁]\n\n"}
{"name":"HomologicalComplex.mapBifunctorMapHomotopy.ιMapBifunctor_hom₁","module":"Mathlib.Algebra.Homology.BifunctorHomotopy","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\ninst✝¹¹ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁹ : CategoryTheory.Category.{u_7, u_3} D\ninst✝⁸ : CategoryTheory.Preadditive C₁\ninst✝⁷ : CategoryTheory.Preadditive C₂\ninst✝⁶ : CategoryTheory.Preadditive D\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ L₁ : HomologicalComplex C₁ c₁\nf₁ f₁' : Quiver.Hom K₁ L₁\nh₁ : Homotopy f₁ f₁'\nK₂ L₂ : HomologicalComplex C₂ c₂\nf₂ : Quiver.Hom K₂ L₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁵ : F.Additive\ninst✝⁴ : ∀ (X₁ : C₁), (F.obj X₁).Additive\nc : ComplexShape J\ninst✝³ : DecidableEq J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : L₁.HasMapBifunctor L₂ F c\ni₁ i₁' : I₁\ni₂ : I₂\nj j' : J\nh : Eq (c₁.π c₂ c { fst := i₁', snd := i₂ }) j\nh' : Eq (c₁.prev i₁') i₁\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K₁.ιMapBifunctor K₂ F c i₁' i₂ j h) (HomologicalComplex.mapBifunctorMapHomotopy.hom₁ h₁ f₂ F c j j')) (HSMul.hSMul (c₁.ε₁ c₂ c { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((F.map (h₁.hom i₁' i₁)).app (K₂.X i₂)) (CategoryTheory.CategoryStruct.comp ((F.obj (L₁.X i₁)).map (f₂.f i₂)) (L₁.ιMapBifunctorOrZero L₂ F c i₁ i₂ j'))))","decl":"@[reassoc]\nlemma ιMapBifunctor_hom₁ (i₁ i₁' : I₁) (i₂ : I₂) (j j' : J)\n    (h : ComplexShape.π c₁ c₂ c (i₁', i₂) = j) (h' : c₁.prev i₁' = i₁) :\n    ιMapBifunctor K₁ K₂ F c i₁' i₂ j h ≫ hom₁ h₁ f₂ F c j j' = ComplexShape.ε₁ c₁ c₂ c (i₁, i₂) •\n      (F.map (h₁.hom i₁' i₁)).app (K₂.X i₂) ≫ (F.obj (L₁.X i₁)).map (f₂.f i₂) ≫\n        ιMapBifunctorOrZero L₁ L₂ F c _ _ j' := by\n  subst h'\n  simp [hom₁]\n\n"}
{"name":"HomologicalComplex.mapBifunctorMapHomotopy.zero₁","module":"Mathlib.Algebra.Homology.BifunctorHomotopy","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\ninst✝¹¹ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁹ : CategoryTheory.Category.{u_7, u_3} D\ninst✝⁸ : CategoryTheory.Preadditive C₁\ninst✝⁷ : CategoryTheory.Preadditive C₂\ninst✝⁶ : CategoryTheory.Preadditive D\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ L₁ : HomologicalComplex C₁ c₁\nf₁ f₁' : Quiver.Hom K₁ L₁\nh₁ : Homotopy f₁ f₁'\nK₂ L₂ : HomologicalComplex C₂ c₂\nf₂ : Quiver.Hom K₂ L₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁵ : F.Additive\ninst✝⁴ : ∀ (X₁ : C₁), (F.obj X₁).Additive\nc : ComplexShape J\ninst✝³ : DecidableEq J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : L₁.HasMapBifunctor L₂ F c\nj j' : J\nh : Not (c.Rel j' j)\n⊢ Eq (HomologicalComplex.mapBifunctorMapHomotopy.hom₁ h₁ f₂ F c j j') 0","decl":"lemma zero₁ (j j' : J) (h : ¬ c.Rel j' j) :\n    hom₁ h₁ f₂ F c j j' = 0 := by\n  ext i₁ i₂ h'\n  dsimp [hom₁]\n  rw [comp_zero, HomologicalComplex₂.ι_totalDesc]\n  by_cases h₃ : c₁.Rel (c₁.prev i₁) i₁\n  · rw [ιMapBifunctorOrZero_eq_zero, comp_zero, comp_zero, smul_zero]\n    intro h₄\n    apply h\n    rw [← h', ← h₄]\n    exact ComplexShape.rel_π₁ c₂ c h₃ i₂\n  · dsimp\n    rw [h₁.zero _ _ h₃, Functor.map_zero, zero_app, zero_comp, smul_zero]\n\n"}
{"name":"HomologicalComplex.mapBifunctorMapHomotopy.comm₁_aux","module":"Mathlib.Algebra.Homology.BifunctorHomotopy","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\ninst✝¹¹ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁹ : CategoryTheory.Category.{u_7, u_3} D\ninst✝⁸ : CategoryTheory.Preadditive C₁\ninst✝⁷ : CategoryTheory.Preadditive C₂\ninst✝⁶ : CategoryTheory.Preadditive D\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ L₁ : HomologicalComplex C₁ c₁\nf₁ f₁' : Quiver.Hom K₁ L₁\nh₁ : Homotopy f₁ f₁'\nK₂ L₂ : HomologicalComplex C₂ c₂\nf₂ : Quiver.Hom K₂ L₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁵ : F.Additive\ninst✝⁴ : ∀ (X₁ : C₁), (F.obj X₁).Additive\nc : ComplexShape J\ninst✝³ : DecidableEq J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : L₁.HasMapBifunctor L₂ F c\ni₁ i₁' : I₁\nhi₁ : c₁.Rel i₁ i₁'\ni₂ i₂' : I₂\nhi₂ : c₂.Rel i₂ i₂'\nj : J\nhj : Eq (c₁.π c₂ c { fst := i₁', snd := i₂ }) j\n⊢ Eq (HSMul.hSMul (c₁.ε₁ c₂ c { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((F.map (h₁.hom i₁' i₁)).app (K₂.X i₂)) (CategoryTheory.CategoryStruct.comp ((F.obj (L₁.X i₁)).map (f₂.f i₂)) ((((F.mapBifunctorHomologicalComplex c₁ c₂).obj L₁).obj L₂).d₂ c i₁ i₂ j)))) (Neg.neg (CategoryTheory.CategoryStruct.comp ((((F.mapBifunctorHomologicalComplex c₁ c₂).obj K₁).obj K₂).d₂ c i₁' i₂ (c.next j)) (HomologicalComplex.mapBifunctorMapHomotopy.hom₁ h₁ f₂ F c (c.next j) j)))","decl":"lemma comm₁_aux {i₁ i₁' : I₁} (hi₁ : c₁.Rel i₁ i₁') {i₂ i₂' : I₂} (hi₂ : c₂.Rel i₂ i₂') (j : J)\n    (hj : ComplexShape.π c₁ c₂ c (i₁', i₂) = j) :\n    ComplexShape.ε₁ c₁ c₂ c (i₁, i₂) • (F.map (h₁.hom i₁' i₁)).app (K₂.X i₂) ≫\n      (F.obj (L₁.X i₁)).map (f₂.f i₂) ≫\n        (((F.mapBifunctorHomologicalComplex c₁ c₂).obj L₁).obj L₂).d₂ c i₁ i₂ j =\n    -(((F.mapBifunctorHomologicalComplex c₁ c₂).obj K₁).obj K₂).d₂ c i₁' i₂ (c.next j) ≫\n      hom₁ h₁ f₂ F c (c.next j) j := by\n  have hj' : ComplexShape.π c₁ c₂ c ⟨i₁, i₂'⟩ = j := by\n    rw [← hj, ← ComplexShape.next_π₂ c₁ c i₁ hi₂, ComplexShape.next_π₁ c₂ c hi₁ i₂]\n  rw [HomologicalComplex₂.d₂_eq _ _ _ hi₂ _ hj', HomologicalComplex₂.d₂_eq _ _ _ hi₂ _\n        (by rw [← c.next_eq' (ComplexShape.rel_π₂ c₁ c i₁' hi₂), hj]),\n    Linear.comp_units_smul, Linear.comp_units_smul, Linear.units_smul_comp, assoc,\n    ιMapBifunctor_hom₁ _ _ _ _ _ _ _ _ _ _ (c₁.prev_eq' hi₁),\n    ιMapBifunctorOrZero_eq _ _ _ _ _ _ _ hj',\n    Linear.comp_units_smul, smul_smul, smul_smul,\n    Functor.mapBifunctorHomologicalComplex_obj_obj_X_d,\n    Functor.mapBifunctorHomologicalComplex_obj_obj_X_d,\n    NatTrans.naturality_assoc, ComplexShape.ε₁_ε₂ c hi₁ hi₂, neg_mul, Units.neg_smul, neg_inj,\n    smul_left_cancel_iff, ← Functor.map_comp_assoc, ← Functor.map_comp_assoc, f₂.comm]\n\n"}
{"name":"HomologicalComplex.mapBifunctorMapHomotopy.comm₁","module":"Mathlib.Algebra.Homology.BifunctorHomotopy","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\nI₁ : Type u_4\nI₂ : Type u_5\nJ : Type u_6\ninst✝¹¹ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁹ : CategoryTheory.Category.{u_7, u_3} D\ninst✝⁸ : CategoryTheory.Preadditive C₁\ninst✝⁷ : CategoryTheory.Preadditive C₂\ninst✝⁶ : CategoryTheory.Preadditive D\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK₁ L₁ : HomologicalComplex C₁ c₁\nf₁ f₁' : Quiver.Hom K₁ L₁\nh₁ : Homotopy f₁ f₁'\nK₂ L₂ : HomologicalComplex C₂ c₂\nf₂ : Quiver.Hom K₂ L₂\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝⁵ : F.Additive\ninst✝⁴ : ∀ (X₁ : C₁), (F.obj X₁).Additive\nc : ComplexShape J\ninst✝³ : DecidableEq J\ninst✝² : TotalComplexShape c₁ c₂ c\ninst✝¹ : K₁.HasMapBifunctor K₂ F c\ninst✝ : L₁.HasMapBifunctor L₂ F c\nj : J\n⊢ Eq ((HomologicalComplex.mapBifunctorMap f₁ f₂ F c).f j) (HAdd.hAdd (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((K₁.mapBifunctor K₂ F c).d j (c.next j)) (HomologicalComplex.mapBifunctorMapHomotopy.hom₁ h₁ f₂ F c (c.next j) j)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.mapBifunctorMapHomotopy.hom₁ h₁ f₂ F c j (c.prev j)) ((L₁.mapBifunctor L₂ F c).d (c.prev j) j))) ((HomologicalComplex.mapBifunctorMap f₁' f₂ F c).f j))","decl":"lemma comm₁ (j : J) :\n    (mapBifunctorMap f₁ f₂ F c).f j =\n    (mapBifunctor K₁ K₂ F c).d j (c.next j) ≫\n          mapBifunctorMapHomotopy.hom₁ h₁ f₂ F c (c.next j) j +\n        mapBifunctorMapHomotopy.hom₁ h₁ f₂ F c j (c.prev j) ≫\n          (mapBifunctor L₁ L₂ F c).d (c.prev j) j +\n      (mapBifunctorMap f₁' f₂ F c).f j := by\n  ext i₁ i₂ h\n  simp? [HomologicalComplex₂.total_d, h₁.comm i₁, dFrom, fromNext, toPrev, dTo] says\n    simp only [ι_mapBifunctorMap, h₁.comm i₁, dNext_eq_dFrom_fromNext, dFrom, fromNext,\n      AddMonoidHom.mk'_apply, prevD_eq_toPrev_dTo, toPrev, dTo, Functor.map_add,\n      Functor.map_comp, NatTrans.app_add, NatTrans.comp_app,\n      Preadditive.add_comp, assoc, HomologicalComplex₂.total_d,\n      Functor.mapBifunctorHomologicalComplex_obj_obj_toGradedObject, Preadditive.comp_add,\n      HomologicalComplex₂.ι_D₁_assoc, Functor.mapBifunctorHomologicalComplex_obj_obj_X_X,\n      HomologicalComplex₂.ι_D₂_assoc, add_left_inj]\n  have : ∀ {X Y : D} (a b c d e f : X ⟶ Y), a = c → b = e → f = -d →\n      a + b = c + d + (e + f) := by rintro X Y a b _ d _ _ rfl rfl rfl; abel\n  apply this\n  · by_cases h₃ : c₁.Rel i₁ (c₁.next i₁)\n    · rw [HomologicalComplex₂.d₁_eq _ _ h₃ _ _ (by rw [← h, ComplexShape.next_π₁ c₂ c h₃]),\n        Functor.mapBifunctorHomologicalComplex_obj_obj_d_f, Linear.units_smul_comp, assoc,\n        ιMapBifunctor_hom₁ _ _ _ _ i₁ _ _ _ _ _ (c₁.prev_eq' h₃),\n        Linear.comp_units_smul, smul_smul, Int.units_mul_self, one_smul,\n        ιMapBifunctorOrZero_eq]\n    · rw [K₁.shape _ _ h₃, Functor.map_zero, zero_app, zero_comp,\n        HomologicalComplex₂.d₁_eq_zero _ _ _ _ _ h₃, zero_comp]\n  · rw [ιMapBifunctor_hom₁_assoc _ _ _ _ _ _ _ _ _ _ rfl]\n    by_cases h₃ : c₁.Rel (c₁.prev i₁) i₁\n    · rw [ιMapBifunctorOrZero_eq _ _ _ _ _ _ _ (by rw [← ComplexShape.prev_π₁ c₂ c h₃, h]),\n        Linear.units_smul_comp, assoc, assoc, HomologicalComplex₂.ι_D₁,\n        HomologicalComplex₂.d₁_eq _ _ h₃ _ _ h, Linear.comp_units_smul,\n        Linear.comp_units_smul, smul_smul, Int.units_mul_self, one_smul,\n        Functor.mapBifunctorHomologicalComplex_obj_obj_d_f, NatTrans.naturality_assoc]\n    · rw [h₁.zero _ _ h₃, Functor.map_zero, zero_app, zero_comp, zero_comp, smul_zero, zero_comp]\n  · rw [ιMapBifunctor_hom₁_assoc _ _ _ _ _ _ _ _ _ _ rfl]\n    by_cases h₃ : c₁.Rel (c₁.prev i₁) i₁\n    · dsimp\n      rw [Linear.units_smul_comp, assoc, assoc,\n        ιMapBifunctorOrZero_eq _ _ _ _ _ _ _ (by rw [← ComplexShape.prev_π₁ c₂ c h₃, h]),\n        HomologicalComplex₂.ι_D₂]\n      by_cases h₄ : c₂.Rel i₂ (c₂.next i₂)\n      · exact comm₁_aux h₁ f₂ F c h₃ h₄ j h\n      · rw [HomologicalComplex₂.d₂_eq_zero _ _ _ _ _ h₄, comp_zero, comp_zero, smul_zero,\n          HomologicalComplex₂.d₂_eq_zero _ _ _ _ _ h₄, zero_comp, neg_zero]\n    · rw [h₁.zero _ _ h₃, Functor.map_zero, zero_app, zero_comp,\n        smul_zero, zero_comp, zero_eq_neg]\n      by_cases h₄ : c₂.Rel i₂ (c₂.next i₂)\n      · by_cases h₅ : c.Rel j (c.next j)\n        · rw [HomologicalComplex₂.d₂_eq _ _ _ h₄ _ (by rw [← ComplexShape.next_π₂ c₁ c i₁ h₄, h]),\n            Linear.units_smul_comp, assoc, Functor.mapBifunctorHomologicalComplex_obj_obj_X_d,\n            ιMapBifunctor_hom₁ _ _ _ _ _ _ _ _ _ _ rfl, h₁.zero _ _ h₃,\n            Functor.map_zero, zero_app, zero_comp, smul_zero, comp_zero, smul_zero]\n        · rw [zero₁ _ _ _ _ _ _ h₅, comp_zero]\n      · rw [HomologicalComplex₂.d₂_eq_zero _ _ _ _ _ h₄, zero_comp]\n\n"}
