{"name":"UniformFun.toFun_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : One β\n⊢ Eq (UniformFun.toFun 1) 1","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_one [One β] : toFun (1 : α →ᵤ β) = 1 := rfl\n\n"}
{"name":"UniformFun.toFun_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Zero β\n⊢ Eq (UniformFun.toFun 0) 0","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_one [One β] : toFun (1 : α →ᵤ β) = 1 := rfl\n\n"}
{"name":"UniformFun.ofFun_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Zero β\n⊢ Eq (UniformFun.ofFun 0) 0","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_one [One β] : ofFun (1 : α → β) = 1 := rfl\n\n"}
{"name":"UniformFun.ofFun_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : One β\n⊢ Eq (UniformFun.ofFun 1) 1","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_one [One β] : ofFun (1 : α → β) = 1 := rfl\n\n"}
{"name":"UniformOnFun.toFun_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : One β\n⊢ Eq ((UniformOnFun.toFun 𝔖) 1) 1","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_one [One β] : toFun 𝔖 (1 : α →ᵤ[𝔖] β) = 1 := rfl\n\n"}
{"name":"UniformOnFun.toFun_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Zero β\n⊢ Eq ((UniformOnFun.toFun 𝔖) 0) 0","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_one [One β] : toFun 𝔖 (1 : α →ᵤ[𝔖] β) = 1 := rfl\n\n"}
{"name":"UniformOnFun.one_apply","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : One β\n⊢ Eq ((UniformOnFun.ofFun 𝔖) 1) 1","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.one_apply [One β] : ofFun 𝔖 (1 : α → β) = 1 := rfl\n\n"}
{"name":"UniformOnFun.zero_apply","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Zero β\n⊢ Eq ((UniformOnFun.ofFun 𝔖) 0) 0","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.one_apply [One β] : ofFun 𝔖 (1 : α → β) = 1 := rfl\n\n"}
{"name":"UniformFun.toFun_add","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Add β\nf g : UniformFun α β\n⊢ Eq (UniformFun.toFun (HAdd.hAdd f g)) (HAdd.hAdd (UniformFun.toFun f) (UniformFun.toFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_mul [Mul β] (f g : α →ᵤ β) : toFun (f * g) = toFun f * toFun g := rfl\n\n"}
{"name":"UniformFun.toFun_mul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Mul β\nf g : UniformFun α β\n⊢ Eq (UniformFun.toFun (HMul.hMul f g)) (HMul.hMul (UniformFun.toFun f) (UniformFun.toFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_mul [Mul β] (f g : α →ᵤ β) : toFun (f * g) = toFun f * toFun g := rfl\n\n"}
{"name":"UniformFun.ofFun_mul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Mul β\nf g : α → β\n⊢ Eq (UniformFun.ofFun (HMul.hMul f g)) (HMul.hMul (UniformFun.ofFun f) (UniformFun.ofFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_mul [Mul β] (f g : α → β) : ofFun (f * g) = ofFun f * ofFun g := rfl\n\n"}
{"name":"UniformFun.ofFun_add","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Add β\nf g : α → β\n⊢ Eq (UniformFun.ofFun (HAdd.hAdd f g)) (HAdd.hAdd (UniformFun.ofFun f) (UniformFun.ofFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_mul [Mul β] (f g : α → β) : ofFun (f * g) = ofFun f * ofFun g := rfl\n\n"}
{"name":"UniformOnFun.toFun_mul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Mul β\nf g : UniformOnFun α β 𝔖\n⊢ Eq ((UniformOnFun.toFun 𝔖) (HMul.hMul f g)) (HMul.hMul ((UniformOnFun.toFun 𝔖) f) ((UniformOnFun.toFun 𝔖) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_mul [Mul β] (f g : α →ᵤ[𝔖] β) :\n    toFun 𝔖 (f * g) = toFun 𝔖 f * toFun 𝔖 g :=\n  rfl\n\n"}
{"name":"UniformOnFun.toFun_add","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Add β\nf g : UniformOnFun α β 𝔖\n⊢ Eq ((UniformOnFun.toFun 𝔖) (HAdd.hAdd f g)) (HAdd.hAdd ((UniformOnFun.toFun 𝔖) f) ((UniformOnFun.toFun 𝔖) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_mul [Mul β] (f g : α →ᵤ[𝔖] β) :\n    toFun 𝔖 (f * g) = toFun 𝔖 f * toFun 𝔖 g :=\n  rfl\n\n"}
{"name":"UniformOnFun.ofFun_mul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Mul β\nf g : α → β\n⊢ Eq ((UniformOnFun.ofFun 𝔖) (HMul.hMul f g)) (HMul.hMul ((UniformOnFun.ofFun 𝔖) f) ((UniformOnFun.ofFun 𝔖) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_mul [Mul β] (f g : α → β) : ofFun 𝔖 (f * g) = ofFun 𝔖 f * ofFun 𝔖 g := rfl\n\n"}
{"name":"UniformOnFun.ofFun_add","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Add β\nf g : α → β\n⊢ Eq ((UniformOnFun.ofFun 𝔖) (HAdd.hAdd f g)) (HAdd.hAdd ((UniformOnFun.ofFun 𝔖) f) ((UniformOnFun.ofFun 𝔖) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_mul [Mul β] (f g : α → β) : ofFun 𝔖 (f * g) = ofFun 𝔖 f * ofFun 𝔖 g := rfl\n\n"}
{"name":"UniformFun.toFun_inv","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Inv β\nf : UniformFun α β\n⊢ Eq (UniformFun.toFun (Inv.inv f)) (Inv.inv (UniformFun.toFun f))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_inv [Inv β] (f : α →ᵤ β) : toFun (f⁻¹) = (toFun f)⁻¹ := rfl\n\n"}
{"name":"UniformFun.toFun_neg","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Neg β\nf : UniformFun α β\n⊢ Eq (UniformFun.toFun (Neg.neg f)) (Neg.neg (UniformFun.toFun f))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_inv [Inv β] (f : α →ᵤ β) : toFun (f⁻¹) = (toFun f)⁻¹ := rfl\n\n"}
{"name":"UniformFun.ofFun_neg","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Neg β\nf : α → β\n⊢ Eq (UniformFun.ofFun (Neg.neg f)) (Neg.neg (UniformFun.ofFun f))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_inv [Inv β] (f : α → β) : ofFun (f⁻¹) = (ofFun f)⁻¹ := rfl\n\n"}
{"name":"UniformFun.ofFun_inv","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Inv β\nf : α → β\n⊢ Eq (UniformFun.ofFun (Inv.inv f)) (Inv.inv (UniformFun.ofFun f))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_inv [Inv β] (f : α → β) : ofFun (f⁻¹) = (ofFun f)⁻¹ := rfl\n\n"}
{"name":"UniformOnFun.toFun_neg","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Neg β\nf : UniformOnFun α β 𝔖\n⊢ Eq ((UniformOnFun.toFun 𝔖) (Neg.neg f)) (Neg.neg ((UniformOnFun.toFun 𝔖) f))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_inv [Inv β] (f : α →ᵤ[𝔖] β) : toFun 𝔖 (f⁻¹) = (toFun 𝔖 f)⁻¹ := rfl\n\n"}
{"name":"UniformOnFun.toFun_inv","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Inv β\nf : UniformOnFun α β 𝔖\n⊢ Eq ((UniformOnFun.toFun 𝔖) (Inv.inv f)) (Inv.inv ((UniformOnFun.toFun 𝔖) f))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_inv [Inv β] (f : α →ᵤ[𝔖] β) : toFun 𝔖 (f⁻¹) = (toFun 𝔖 f)⁻¹ := rfl\n\n"}
{"name":"UniformOnFun.ofFun_neg","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Neg β\nf : α → β\n⊢ Eq ((UniformOnFun.ofFun 𝔖) (Neg.neg f)) (Neg.neg ((UniformOnFun.ofFun 𝔖) f))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_inv [Inv β] (f : α → β) : ofFun 𝔖 (f⁻¹) = (ofFun 𝔖 f)⁻¹ := rfl\n\n"}
{"name":"UniformOnFun.ofFun_inv","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Inv β\nf : α → β\n⊢ Eq ((UniformOnFun.ofFun 𝔖) (Inv.inv f)) (Inv.inv ((UniformOnFun.ofFun 𝔖) f))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_inv [Inv β] (f : α → β) : ofFun 𝔖 (f⁻¹) = (ofFun 𝔖 f)⁻¹ := rfl\n\n"}
{"name":"UniformFun.toFun_div","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Div β\nf g : UniformFun α β\n⊢ Eq (UniformFun.toFun (HDiv.hDiv f g)) (HDiv.hDiv (UniformFun.toFun f) (UniformFun.toFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_div [Div β] (f g : α →ᵤ β) : toFun (f / g) = toFun f / toFun g := rfl\n\n"}
{"name":"UniformFun.toFun_sub","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Sub β\nf g : UniformFun α β\n⊢ Eq (UniformFun.toFun (HSub.hSub f g)) (HSub.hSub (UniformFun.toFun f) (UniformFun.toFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_div [Div β] (f g : α →ᵤ β) : toFun (f / g) = toFun f / toFun g := rfl\n\n"}
{"name":"UniformFun.ofFun_div","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Div β\nf g : α → β\n⊢ Eq (UniformFun.ofFun (HDiv.hDiv f g)) (HDiv.hDiv (UniformFun.ofFun f) (UniformFun.ofFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_div [Div β] (f g : α → β) : ofFun (f / g) = ofFun f / ofFun g := rfl\n\n"}
{"name":"UniformFun.ofFun_sub","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Sub β\nf g : α → β\n⊢ Eq (UniformFun.ofFun (HSub.hSub f g)) (HSub.hSub (UniformFun.ofFun f) (UniformFun.ofFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_div [Div β] (f g : α → β) : ofFun (f / g) = ofFun f / ofFun g := rfl\n\n"}
{"name":"UniformOnFun.toFun_sub","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Sub β\nf g : UniformOnFun α β 𝔖\n⊢ Eq ((UniformOnFun.toFun 𝔖) (HSub.hSub f g)) (HSub.hSub ((UniformOnFun.toFun 𝔖) f) ((UniformOnFun.toFun 𝔖) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_div [Div β] (f g : α →ᵤ[𝔖] β) :\n    toFun 𝔖 (f / g) = toFun 𝔖 f / toFun 𝔖 g :=\n  rfl\n\n"}
{"name":"UniformOnFun.toFun_div","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Div β\nf g : UniformOnFun α β 𝔖\n⊢ Eq ((UniformOnFun.toFun 𝔖) (HDiv.hDiv f g)) (HDiv.hDiv ((UniformOnFun.toFun 𝔖) f) ((UniformOnFun.toFun 𝔖) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_div [Div β] (f g : α →ᵤ[𝔖] β) :\n    toFun 𝔖 (f / g) = toFun 𝔖 f / toFun 𝔖 g :=\n  rfl\n\n"}
{"name":"UniformOnFun.ofFun_sub","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Sub β\nf g : α → β\n⊢ Eq ((UniformOnFun.ofFun 𝔖) (HSub.hSub f g)) (HSub.hSub ((UniformOnFun.ofFun 𝔖) f) ((UniformOnFun.ofFun 𝔖) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_div [Div β] (f g : α → β) : ofFun 𝔖 (f / g) = ofFun 𝔖 f / ofFun 𝔖 g := rfl\n\n"}
{"name":"UniformOnFun.ofFun_div","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\ninst✝ : Div β\nf g : α → β\n⊢ Eq ((UniformOnFun.ofFun 𝔖) (HDiv.hDiv f g)) (HDiv.hDiv ((UniformOnFun.ofFun 𝔖) f) ((UniformOnFun.ofFun 𝔖) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_div [Div β] (f g : α → β) : ofFun 𝔖 (f / g) = ofFun 𝔖 f / ofFun 𝔖 g := rfl\n\n"}
{"name":"UniformFun.toFun_smul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : SMul M β\nc : M\nf : UniformFun α β\n⊢ Eq (UniformFun.toFun (HSMul.hSMul c f)) (HSMul.hSMul c (UniformFun.toFun f))","decl":"@[simp]\nlemma UniformFun.toFun_smul {M : Type*} [SMul M β] (c : M) (f : α →ᵤ β) :\n    toFun (c • f) = c • toFun f :=\n  rfl\n\n"}
{"name":"UniformFun.ofFun_smul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : SMul M β\nc : M\nf : α → β\n⊢ Eq (UniformFun.ofFun (HSMul.hSMul c f)) (HSMul.hSMul c (UniformFun.ofFun f))","decl":"@[simp]\nlemma UniformFun.ofFun_smul {M : Type*} [SMul M β] (c : M) (f : α → β) :\n    ofFun (c • f) = c • ofFun f :=\n  rfl\n\n"}
{"name":"UniformOnFun.toFun_smul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\nM : Type u_5\ninst✝ : SMul M β\nc : M\nf : UniformOnFun α β 𝔖\n⊢ Eq ((UniformOnFun.toFun 𝔖) (HSMul.hSMul c f)) (HSMul.hSMul c ((UniformOnFun.toFun 𝔖) f))","decl":"@[simp]\nlemma UniformOnFun.toFun_smul {M : Type*} [SMul M β] (c : M) (f : α →ᵤ[𝔖] β) :\n    toFun 𝔖 (c • f) = c • toFun 𝔖 f :=\n  rfl\n\n"}
{"name":"UniformOnFun.ofFun_smul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\nM : Type u_5\ninst✝ : SMul M β\nc : M\nf : α → β\n⊢ Eq ((UniformOnFun.ofFun 𝔖) (HSMul.hSMul c f)) (HSMul.hSMul c ((UniformOnFun.ofFun 𝔖) f))","decl":"@[simp]\nlemma UniformOnFun.ofFun_smul {M : Type*} [SMul M β] (c : M) (f : α → β) :\n    ofFun 𝔖 (c • f) = c • ofFun 𝔖 f :=\n  rfl\n\n"}
{"name":"instIsScalarTowerUniformFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_6\ninst✝³ : SMul M N\ninst✝² : SMul M β\ninst✝¹ : SMul N β\ninst✝ : IsScalarTower M N β\n⊢ IsScalarTower M N (UniformFun α β)","decl":"instance {M N : Type*} [SMul M N] [SMul M β] [SMul N β] [IsScalarTower M N β] :\n    IsScalarTower M N (α →ᵤ β) :=\n  Pi.isScalarTower\n\n"}
{"name":"instIsScalarTowerUniformOnFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\nM : Type u_5\nN : Type u_6\ninst✝³ : SMul M N\ninst✝² : SMul M β\ninst✝¹ : SMul N β\ninst✝ : IsScalarTower M N β\n⊢ IsScalarTower M N (UniformOnFun α β 𝔖)","decl":"instance {M N : Type*} [SMul M N] [SMul M β] [SMul N β] [IsScalarTower M N β] :\n    IsScalarTower M N (α →ᵤ[𝔖] β) :=\n  Pi.isScalarTower\n\n"}
{"name":"instSMulCommClassUniformFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\nN : Type u_6\ninst✝² : SMul M β\ninst✝¹ : SMul N β\ninst✝ : SMulCommClass M N β\n⊢ SMulCommClass M N (UniformFun α β)","decl":"instance {M N : Type*} [SMul M β] [SMul N β] [SMulCommClass M N β] :\n    SMulCommClass M N (α →ᵤ β) :=\n  Pi.smulCommClass\n\n"}
{"name":"instSMulCommClassUniformOnFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nβ : Type u_2\n𝔖 : Set (Set α)\nM : Type u_5\nN : Type u_6\ninst✝² : SMul M β\ninst✝¹ : SMul N β\ninst✝ : SMulCommClass M N β\n⊢ SMulCommClass M N (UniformOnFun α β 𝔖)","decl":"instance {M N : Type*} [SMul M β] [SMul N β] [SMulCommClass M N β] :\n    SMulCommClass M N (α →ᵤ[𝔖] β) :=\n  Pi.smulCommClass\n\n"}
{"name":"instUniformGroupUniformFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : UniformSpace G\ninst✝ : UniformGroup G\n⊢ UniformGroup (UniformFun α G)","decl":"/-- If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. -/\n@[to_additive \"If `G` is a uniform additive group,\nthen `α →ᵤ G` is a uniform additive group as well.\"]\ninstance : UniformGroup (α →ᵤ G) :=\n  ⟨(-- Since `(/) : G × G → G` is uniformly continuous,\n    -- `UniformFun.postcomp_uniformContinuous` tells us that\n    -- `((/) ∘ —) : (α →ᵤ G × G) → (α →ᵤ G)` is uniformly continuous too. By precomposing with\n    -- `UniformFun.uniformEquivProdArrow`, this gives that\n    -- `(/) : (α →ᵤ G) × (α →ᵤ G) → (α →ᵤ G)` is also uniformly continuous\n    UniformFun.postcomp_uniformContinuous uniformContinuous_div).comp\n    UniformFun.uniformEquivProdArrow.symm.uniformContinuous⟩\n\n"}
{"name":"instUniformAddGroupUniformFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : UniformSpace G\ninst✝ : UniformAddGroup G\n⊢ UniformAddGroup (UniformFun α G)","decl":"/-- If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. -/\n@[to_additive \"If `G` is a uniform additive group,\nthen `α →ᵤ G` is a uniform additive group as well.\"]\ninstance : UniformGroup (α →ᵤ G) :=\n  ⟨(-- Since `(/) : G × G → G` is uniformly continuous,\n    -- `UniformFun.postcomp_uniformContinuous` tells us that\n    -- `((/) ∘ —) : (α →ᵤ G × G) → (α →ᵤ G)` is uniformly continuous too. By precomposing with\n    -- `UniformFun.uniformEquivProdArrow`, this gives that\n    -- `(/) : (α →ᵤ G) × (α →ᵤ G) → (α →ᵤ G)` is also uniformly continuous\n    UniformFun.postcomp_uniformContinuous uniformContinuous_div).comp\n    UniformFun.uniformEquivProdArrow.symm.uniformContinuous⟩\n\n"}
{"name":"UniformFun.hasBasis_nhds_zero_of_basis","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\nι : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : UniformSpace G\ninst✝ : UniformAddGroup G\np : ι → Prop\nb : ι → Set G\nh : (nhds 0).HasBasis p b\n⊢ (nhds 0).HasBasis p fun i => setOf fun f => ∀ (x : α), Membership.mem (b i) (UniformFun.toFun f x)","decl":"@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one_of_basis {p : ι → Prop} {b : ι → Set G}\n    (h : (𝓝 1 : Filter G).HasBasis p b) :\n    (𝓝 1 : Filter (α →ᵤ G)).HasBasis p fun i => { f : α →ᵤ G | ∀ x, toFun f x ∈ b i } := by\n  convert UniformFun.hasBasis_nhds_of_basis α _ (1 : α →ᵤ G) h.uniformity_of_nhds_one\n  simp\n\n"}
{"name":"UniformFun.hasBasis_nhds_one_of_basis","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\nι : Type u_3\ninst✝² : Group G\ninst✝¹ : UniformSpace G\ninst✝ : UniformGroup G\np : ι → Prop\nb : ι → Set G\nh : (nhds 1).HasBasis p b\n⊢ (nhds 1).HasBasis p fun i => setOf fun f => ∀ (x : α), Membership.mem (b i) (UniformFun.toFun f x)","decl":"@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one_of_basis {p : ι → Prop} {b : ι → Set G}\n    (h : (𝓝 1 : Filter G).HasBasis p b) :\n    (𝓝 1 : Filter (α →ᵤ G)).HasBasis p fun i => { f : α →ᵤ G | ∀ x, toFun f x ∈ b i } := by\n  convert UniformFun.hasBasis_nhds_of_basis α _ (1 : α →ᵤ G) h.uniformity_of_nhds_one\n  simp\n\n"}
{"name":"UniformFun.hasBasis_nhds_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : UniformSpace G\ninst✝ : UniformGroup G\n⊢ (nhds 1).HasBasis (fun V => Membership.mem (nhds 1) V) fun V => setOf fun f => ∀ (x : α), Membership.mem V (f x)","decl":"@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one :\n    (𝓝 1 : Filter (α →ᵤ G)).HasBasis (fun V : Set G => V ∈ (𝓝 1 : Filter G)) fun V =>\n      { f : α → G | ∀ x, f x ∈ V } :=\n  UniformFun.hasBasis_nhds_one_of_basis (basis_sets _)\n\n"}
{"name":"UniformFun.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : UniformSpace G\ninst✝ : UniformAddGroup G\n⊢ (nhds 0).HasBasis (fun V => Membership.mem (nhds 0) V) fun V => setOf fun f => ∀ (x : α), Membership.mem V (f x)","decl":"@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one :\n    (𝓝 1 : Filter (α →ᵤ G)).HasBasis (fun V : Set G => V ∈ (𝓝 1 : Filter G)) fun V =>\n      { f : α → G | ∀ x, f x ∈ V } :=\n  UniformFun.hasBasis_nhds_one_of_basis (basis_sets _)\n\n"}
{"name":"instUniformGroupUniformOnFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\n𝔖 : Set (Set α)\ninst✝¹ : UniformSpace G\ninst✝ : UniformGroup G\n⊢ UniformGroup (UniformOnFun α G 𝔖)","decl":"/-- Let `𝔖 : Set (Set α)`. If `G` is a uniform group, then `α →ᵤ[𝔖] G` is a uniform group as\nwell. -/\n@[to_additive \"Let `𝔖 : Set (Set α)`. If `G` is a uniform additive group,\nthen `α →ᵤ[𝔖] G` is a uniform additive group as well.\"]\ninstance : UniformGroup (α →ᵤ[𝔖] G) :=\n  ⟨(-- Since `(/) : G × G → G` is uniformly continuous,\n    -- `UniformOnFun.postcomp_uniformContinuous` tells us that\n    -- `((/) ∘ —) : (α →ᵤ[𝔖] G × G) → (α →ᵤ[𝔖] G)` is uniformly continuous too. By precomposing with\n    -- `UniformOnFun.uniformEquivProdArrow`, this gives that\n    -- `(/) : (α →ᵤ[𝔖] G) × (α →ᵤ[𝔖] G) → (α →ᵤ[𝔖] G)` is also uniformly continuous\n    UniformOnFun.postcomp_uniformContinuous uniformContinuous_div).comp\n    UniformOnFun.uniformEquivProdArrow.symm.uniformContinuous⟩\n\n"}
{"name":"instUniformAddGroupUniformOnFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : AddGroup G\n𝔖 : Set (Set α)\ninst✝¹ : UniformSpace G\ninst✝ : UniformAddGroup G\n⊢ UniformAddGroup (UniformOnFun α G 𝔖)","decl":"/-- Let `𝔖 : Set (Set α)`. If `G` is a uniform group, then `α →ᵤ[𝔖] G` is a uniform group as\nwell. -/\n@[to_additive \"Let `𝔖 : Set (Set α)`. If `G` is a uniform additive group,\nthen `α →ᵤ[𝔖] G` is a uniform additive group as well.\"]\ninstance : UniformGroup (α →ᵤ[𝔖] G) :=\n  ⟨(-- Since `(/) : G × G → G` is uniformly continuous,\n    -- `UniformOnFun.postcomp_uniformContinuous` tells us that\n    -- `((/) ∘ —) : (α →ᵤ[𝔖] G × G) → (α →ᵤ[𝔖] G)` is uniformly continuous too. By precomposing with\n    -- `UniformOnFun.uniformEquivProdArrow`, this gives that\n    -- `(/) : (α →ᵤ[𝔖] G) × (α →ᵤ[𝔖] G) → (α →ᵤ[𝔖] G)` is also uniformly continuous\n    UniformOnFun.postcomp_uniformContinuous uniformContinuous_div).comp\n    UniformOnFun.uniformEquivProdArrow.symm.uniformContinuous⟩\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_zero_of_basis","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\nι : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : UniformSpace G\ninst✝ : UniformAddGroup G\n𝔖 : Set (Set α)\nh𝔖₁ : 𝔖.Nonempty\nh𝔖₂ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\np : ι → Prop\nb : ι → Set G\nh : (nhds 0).HasBasis p b\n⊢ (nhds 0).HasBasis (fun Si => And (Membership.mem 𝔖 Si.1) (p Si.2)) fun Si => setOf fun f => ∀ (x : α), Membership.mem Si.1 x → Membership.mem (b Si.2) ((UniformOnFun.toFun 𝔖) f x)","decl":"@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one_of_basis (𝔖 : Set <| Set α) (h𝔖₁ : 𝔖.Nonempty)\n    (h𝔖₂ : DirectedOn (· ⊆ ·) 𝔖) {p : ι → Prop} {b : ι → Set G}\n    (h : (𝓝 1 : Filter G).HasBasis p b) :\n    (𝓝 1 : Filter (α →ᵤ[𝔖] G)).HasBasis (fun Si : Set α × ι => Si.1 ∈ 𝔖 ∧ p Si.2) fun Si =>\n      { f : α →ᵤ[𝔖] G | ∀ x ∈ Si.1, toFun 𝔖 f x ∈ b Si.2 } := by\n  convert UniformOnFun.hasBasis_nhds_of_basis α _ 𝔖 (1 : α →ᵤ[𝔖] G) h𝔖₁ h𝔖₂ <|\n    h.uniformity_of_nhds_one_swapped\n  simp [UniformOnFun.gen]\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_one_of_basis","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\nι : Type u_3\ninst✝² : Group G\ninst✝¹ : UniformSpace G\ninst✝ : UniformGroup G\n𝔖 : Set (Set α)\nh𝔖₁ : 𝔖.Nonempty\nh𝔖₂ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\np : ι → Prop\nb : ι → Set G\nh : (nhds 1).HasBasis p b\n⊢ (nhds 1).HasBasis (fun Si => And (Membership.mem 𝔖 Si.1) (p Si.2)) fun Si => setOf fun f => ∀ (x : α), Membership.mem Si.1 x → Membership.mem (b Si.2) ((UniformOnFun.toFun 𝔖) f x)","decl":"@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one_of_basis (𝔖 : Set <| Set α) (h𝔖₁ : 𝔖.Nonempty)\n    (h𝔖₂ : DirectedOn (· ⊆ ·) 𝔖) {p : ι → Prop} {b : ι → Set G}\n    (h : (𝓝 1 : Filter G).HasBasis p b) :\n    (𝓝 1 : Filter (α →ᵤ[𝔖] G)).HasBasis (fun Si : Set α × ι => Si.1 ∈ 𝔖 ∧ p Si.2) fun Si =>\n      { f : α →ᵤ[𝔖] G | ∀ x ∈ Si.1, toFun 𝔖 f x ∈ b Si.2 } := by\n  convert UniformOnFun.hasBasis_nhds_of_basis α _ 𝔖 (1 : α →ᵤ[𝔖] G) h𝔖₁ h𝔖₂ <|\n    h.uniformity_of_nhds_one_swapped\n  simp [UniformOnFun.gen]\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : UniformSpace G\ninst✝ : UniformAddGroup G\n𝔖 : Set (Set α)\nh𝔖₁ : 𝔖.Nonempty\nh𝔖₂ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\n⊢ (nhds 0).HasBasis (fun SV => And (Membership.mem 𝔖 SV.1) (Membership.mem (nhds 0) SV.2)) fun SV => setOf fun f => ∀ (x : α), Membership.mem SV.1 x → Membership.mem SV.2 (f x)","decl":"@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one (𝔖 : Set <| Set α) (h𝔖₁ : 𝔖.Nonempty)\n    (h𝔖₂ : DirectedOn (· ⊆ ·) 𝔖) :\n    (𝓝 1 : Filter (α →ᵤ[𝔖] G)).HasBasis\n      (fun SV : Set α × Set G => SV.1 ∈ 𝔖 ∧ SV.2 ∈ (𝓝 1 : Filter G)) fun SV =>\n      { f : α →ᵤ[𝔖] G | ∀ x ∈ SV.1, f x ∈ SV.2 } :=\n  UniformOnFun.hasBasis_nhds_one_of_basis 𝔖 h𝔖₁ h𝔖₂ (basis_sets _)\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"α : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : UniformSpace G\ninst✝ : UniformGroup G\n𝔖 : Set (Set α)\nh𝔖₁ : 𝔖.Nonempty\nh𝔖₂ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) 𝔖\n⊢ (nhds 1).HasBasis (fun SV => And (Membership.mem 𝔖 SV.1) (Membership.mem (nhds 1) SV.2)) fun SV => setOf fun f => ∀ (x : α), Membership.mem SV.1 x → Membership.mem SV.2 (f x)","decl":"@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one (𝔖 : Set <| Set α) (h𝔖₁ : 𝔖.Nonempty)\n    (h𝔖₂ : DirectedOn (· ⊆ ·) 𝔖) :\n    (𝓝 1 : Filter (α →ᵤ[𝔖] G)).HasBasis\n      (fun SV : Set α × Set G => SV.1 ∈ 𝔖 ∧ SV.2 ∈ (𝓝 1 : Filter G)) fun SV =>\n      { f : α →ᵤ[𝔖] G | ∀ x ∈ SV.1, f x ∈ SV.2 } :=\n  UniformOnFun.hasBasis_nhds_one_of_basis 𝔖 h𝔖₁ h𝔖₂ (basis_sets _)\n\n"}
{"name":"UniformFun.uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"M : Type u_1\nα : Type u_2\nX : Type u_3\ninst✝² : SMul M X\ninst✝¹ : UniformSpace X\ninst✝ : UniformContinuousConstSMul M X\n⊢ UniformContinuousConstSMul M (UniformFun α X)","decl":"instance UniformFun.uniformContinuousConstSMul :\n    UniformContinuousConstSMul M (α →ᵤ X) where\n  uniformContinuous_const_smul c := UniformFun.postcomp_uniformContinuous <|\n    uniformContinuous_const_smul c\n\n"}
{"name":"UniformFunOn.uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"M : Type u_1\nα : Type u_2\nX : Type u_3\ninst✝² : SMul M X\ninst✝¹ : UniformSpace X\ninst✝ : UniformContinuousConstSMul M X\n𝔖 : Set (Set α)\n⊢ UniformContinuousConstSMul M (UniformOnFun α X 𝔖)","decl":"instance UniformFunOn.uniformContinuousConstSMul {𝔖 : Set (Set α)} :\n    UniformContinuousConstSMul M (α →ᵤ[𝔖] X) where\n  uniformContinuous_const_smul c := UniformOnFun.postcomp_uniformContinuous <|\n    uniformContinuous_const_smul c\n\n"}
