{"name":"UniformFun.toFun_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : One Î²\nâŠ¢ Eq (UniformFun.toFun 1) 1","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_one [One Î²] : toFun (1 : Î± â†’áµ¤ Î²) = 1 := rfl\n\n"}
{"name":"UniformFun.toFun_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Zero Î²\nâŠ¢ Eq (UniformFun.toFun 0) 0","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_one [One Î²] : toFun (1 : Î± â†’áµ¤ Î²) = 1 := rfl\n\n"}
{"name":"UniformFun.ofFun_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Zero Î²\nâŠ¢ Eq (UniformFun.ofFun 0) 0","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_one [One Î²] : ofFun (1 : Î± â†’ Î²) = 1 := rfl\n\n"}
{"name":"UniformFun.ofFun_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : One Î²\nâŠ¢ Eq (UniformFun.ofFun 1) 1","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_one [One Î²] : ofFun (1 : Î± â†’ Î²) = 1 := rfl\n\n"}
{"name":"UniformOnFun.toFun_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : One Î²\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) 1) 1","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_one [One Î²] : toFun ğ”– (1 : Î± â†’áµ¤[ğ”–] Î²) = 1 := rfl\n\n"}
{"name":"UniformOnFun.toFun_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Zero Î²\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) 0) 0","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_one [One Î²] : toFun ğ”– (1 : Î± â†’áµ¤[ğ”–] Î²) = 1 := rfl\n\n"}
{"name":"UniformOnFun.one_apply","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : One Î²\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) 1) 1","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.one_apply [One Î²] : ofFun ğ”– (1 : Î± â†’ Î²) = 1 := rfl\n\n"}
{"name":"UniformOnFun.zero_apply","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Zero Î²\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) 0) 0","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.one_apply [One Î²] : ofFun ğ”– (1 : Î± â†’ Î²) = 1 := rfl\n\n"}
{"name":"UniformFun.toFun_add","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Add Î²\nf g : UniformFun Î± Î²\nâŠ¢ Eq (UniformFun.toFun (HAdd.hAdd f g)) (HAdd.hAdd (UniformFun.toFun f) (UniformFun.toFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_mul [Mul Î²] (f g : Î± â†’áµ¤ Î²) : toFun (f * g) = toFun f * toFun g := rfl\n\n"}
{"name":"UniformFun.toFun_mul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Mul Î²\nf g : UniformFun Î± Î²\nâŠ¢ Eq (UniformFun.toFun (HMul.hMul f g)) (HMul.hMul (UniformFun.toFun f) (UniformFun.toFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_mul [Mul Î²] (f g : Î± â†’áµ¤ Î²) : toFun (f * g) = toFun f * toFun g := rfl\n\n"}
{"name":"UniformFun.ofFun_mul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Mul Î²\nf g : Î± â†’ Î²\nâŠ¢ Eq (UniformFun.ofFun (HMul.hMul f g)) (HMul.hMul (UniformFun.ofFun f) (UniformFun.ofFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_mul [Mul Î²] (f g : Î± â†’ Î²) : ofFun (f * g) = ofFun f * ofFun g := rfl\n\n"}
{"name":"UniformFun.ofFun_add","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Add Î²\nf g : Î± â†’ Î²\nâŠ¢ Eq (UniformFun.ofFun (HAdd.hAdd f g)) (HAdd.hAdd (UniformFun.ofFun f) (UniformFun.ofFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_mul [Mul Î²] (f g : Î± â†’ Î²) : ofFun (f * g) = ofFun f * ofFun g := rfl\n\n"}
{"name":"UniformOnFun.toFun_mul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Mul Î²\nf g : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) (HMul.hMul f g)) (HMul.hMul ((UniformOnFun.toFun ğ”–) f) ((UniformOnFun.toFun ğ”–) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_mul [Mul Î²] (f g : Î± â†’áµ¤[ğ”–] Î²) :\n    toFun ğ”– (f * g) = toFun ğ”– f * toFun ğ”– g :=\n  rfl\n\n"}
{"name":"UniformOnFun.toFun_add","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Add Î²\nf g : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) (HAdd.hAdd f g)) (HAdd.hAdd ((UniformOnFun.toFun ğ”–) f) ((UniformOnFun.toFun ğ”–) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_mul [Mul Î²] (f g : Î± â†’áµ¤[ğ”–] Î²) :\n    toFun ğ”– (f * g) = toFun ğ”– f * toFun ğ”– g :=\n  rfl\n\n"}
{"name":"UniformOnFun.ofFun_mul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Mul Î²\nf g : Î± â†’ Î²\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) (HMul.hMul f g)) (HMul.hMul ((UniformOnFun.ofFun ğ”–) f) ((UniformOnFun.ofFun ğ”–) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_mul [Mul Î²] (f g : Î± â†’ Î²) : ofFun ğ”– (f * g) = ofFun ğ”– f * ofFun ğ”– g := rfl\n\n"}
{"name":"UniformOnFun.ofFun_add","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Add Î²\nf g : Î± â†’ Î²\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) (HAdd.hAdd f g)) (HAdd.hAdd ((UniformOnFun.ofFun ğ”–) f) ((UniformOnFun.ofFun ğ”–) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_mul [Mul Î²] (f g : Î± â†’ Î²) : ofFun ğ”– (f * g) = ofFun ğ”– f * ofFun ğ”– g := rfl\n\n"}
{"name":"UniformFun.toFun_inv","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Inv Î²\nf : UniformFun Î± Î²\nâŠ¢ Eq (UniformFun.toFun (Inv.inv f)) (Inv.inv (UniformFun.toFun f))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_inv [Inv Î²] (f : Î± â†’áµ¤ Î²) : toFun (fâ»Â¹) = (toFun f)â»Â¹ := rfl\n\n"}
{"name":"UniformFun.toFun_neg","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Neg Î²\nf : UniformFun Î± Î²\nâŠ¢ Eq (UniformFun.toFun (Neg.neg f)) (Neg.neg (UniformFun.toFun f))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_inv [Inv Î²] (f : Î± â†’áµ¤ Î²) : toFun (fâ»Â¹) = (toFun f)â»Â¹ := rfl\n\n"}
{"name":"UniformFun.ofFun_neg","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Neg Î²\nf : Î± â†’ Î²\nâŠ¢ Eq (UniformFun.ofFun (Neg.neg f)) (Neg.neg (UniformFun.ofFun f))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_inv [Inv Î²] (f : Î± â†’ Î²) : ofFun (fâ»Â¹) = (ofFun f)â»Â¹ := rfl\n\n"}
{"name":"UniformFun.ofFun_inv","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Inv Î²\nf : Î± â†’ Î²\nâŠ¢ Eq (UniformFun.ofFun (Inv.inv f)) (Inv.inv (UniformFun.ofFun f))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_inv [Inv Î²] (f : Î± â†’ Î²) : ofFun (fâ»Â¹) = (ofFun f)â»Â¹ := rfl\n\n"}
{"name":"UniformOnFun.toFun_neg","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Neg Î²\nf : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) (Neg.neg f)) (Neg.neg ((UniformOnFun.toFun ğ”–) f))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_inv [Inv Î²] (f : Î± â†’áµ¤[ğ”–] Î²) : toFun ğ”– (fâ»Â¹) = (toFun ğ”– f)â»Â¹ := rfl\n\n"}
{"name":"UniformOnFun.toFun_inv","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Inv Î²\nf : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) (Inv.inv f)) (Inv.inv ((UniformOnFun.toFun ğ”–) f))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_inv [Inv Î²] (f : Î± â†’áµ¤[ğ”–] Î²) : toFun ğ”– (fâ»Â¹) = (toFun ğ”– f)â»Â¹ := rfl\n\n"}
{"name":"UniformOnFun.ofFun_neg","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Neg Î²\nf : Î± â†’ Î²\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) (Neg.neg f)) (Neg.neg ((UniformOnFun.ofFun ğ”–) f))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_inv [Inv Î²] (f : Î± â†’ Î²) : ofFun ğ”– (fâ»Â¹) = (ofFun ğ”– f)â»Â¹ := rfl\n\n"}
{"name":"UniformOnFun.ofFun_inv","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Inv Î²\nf : Î± â†’ Î²\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) (Inv.inv f)) (Inv.inv ((UniformOnFun.ofFun ğ”–) f))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_inv [Inv Î²] (f : Î± â†’ Î²) : ofFun ğ”– (fâ»Â¹) = (ofFun ğ”– f)â»Â¹ := rfl\n\n"}
{"name":"UniformFun.toFun_div","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Div Î²\nf g : UniformFun Î± Î²\nâŠ¢ Eq (UniformFun.toFun (HDiv.hDiv f g)) (HDiv.hDiv (UniformFun.toFun f) (UniformFun.toFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_div [Div Î²] (f g : Î± â†’áµ¤ Î²) : toFun (f / g) = toFun f / toFun g := rfl\n\n"}
{"name":"UniformFun.toFun_sub","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Sub Î²\nf g : UniformFun Î± Î²\nâŠ¢ Eq (UniformFun.toFun (HSub.hSub f g)) (HSub.hSub (UniformFun.toFun f) (UniformFun.toFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.toFun_div [Div Î²] (f g : Î± â†’áµ¤ Î²) : toFun (f / g) = toFun f / toFun g := rfl\n\n"}
{"name":"UniformFun.ofFun_div","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Div Î²\nf g : Î± â†’ Î²\nâŠ¢ Eq (UniformFun.ofFun (HDiv.hDiv f g)) (HDiv.hDiv (UniformFun.ofFun f) (UniformFun.ofFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_div [Div Î²] (f g : Î± â†’ Î²) : ofFun (f / g) = ofFun f / ofFun g := rfl\n\n"}
{"name":"UniformFun.ofFun_sub","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : Sub Î²\nf g : Î± â†’ Î²\nâŠ¢ Eq (UniformFun.ofFun (HSub.hSub f g)) (HSub.hSub (UniformFun.ofFun f) (UniformFun.ofFun g))","decl":"@[to_additive (attr := simp)]\nlemma UniformFun.ofFun_div [Div Î²] (f g : Î± â†’ Î²) : ofFun (f / g) = ofFun f / ofFun g := rfl\n\n"}
{"name":"UniformOnFun.toFun_sub","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Sub Î²\nf g : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) (HSub.hSub f g)) (HSub.hSub ((UniformOnFun.toFun ğ”–) f) ((UniformOnFun.toFun ğ”–) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_div [Div Î²] (f g : Î± â†’áµ¤[ğ”–] Î²) :\n    toFun ğ”– (f / g) = toFun ğ”– f / toFun ğ”– g :=\n  rfl\n\n"}
{"name":"UniformOnFun.toFun_div","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Div Î²\nf g : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) (HDiv.hDiv f g)) (HDiv.hDiv ((UniformOnFun.toFun ğ”–) f) ((UniformOnFun.toFun ğ”–) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.toFun_div [Div Î²] (f g : Î± â†’áµ¤[ğ”–] Î²) :\n    toFun ğ”– (f / g) = toFun ğ”– f / toFun ğ”– g :=\n  rfl\n\n"}
{"name":"UniformOnFun.ofFun_sub","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Sub Î²\nf g : Î± â†’ Î²\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) (HSub.hSub f g)) (HSub.hSub ((UniformOnFun.ofFun ğ”–) f) ((UniformOnFun.ofFun ğ”–) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_div [Div Î²] (f g : Î± â†’ Î²) : ofFun ğ”– (f / g) = ofFun ğ”– f / ofFun ğ”– g := rfl\n\n"}
{"name":"UniformOnFun.ofFun_div","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\ninstâœ : Div Î²\nf g : Î± â†’ Î²\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) (HDiv.hDiv f g)) (HDiv.hDiv ((UniformOnFun.ofFun ğ”–) f) ((UniformOnFun.ofFun ğ”–) g))","decl":"@[to_additive (attr := simp)]\nlemma UniformOnFun.ofFun_div [Div Î²] (f g : Î± â†’ Î²) : ofFun ğ”– (f / g) = ofFun ğ”– f / ofFun ğ”– g := rfl\n\n"}
{"name":"UniformFun.toFun_smul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nM : Type u_5\ninstâœ : SMul M Î²\nc : M\nf : UniformFun Î± Î²\nâŠ¢ Eq (UniformFun.toFun (HSMul.hSMul c f)) (HSMul.hSMul c (UniformFun.toFun f))","decl":"@[simp]\nlemma UniformFun.toFun_smul {M : Type*} [SMul M Î²] (c : M) (f : Î± â†’áµ¤ Î²) :\n    toFun (c â€¢ f) = c â€¢ toFun f :=\n  rfl\n\n"}
{"name":"UniformFun.ofFun_smul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nM : Type u_5\ninstâœ : SMul M Î²\nc : M\nf : Î± â†’ Î²\nâŠ¢ Eq (UniformFun.ofFun (HSMul.hSMul c f)) (HSMul.hSMul c (UniformFun.ofFun f))","decl":"@[simp]\nlemma UniformFun.ofFun_smul {M : Type*} [SMul M Î²] (c : M) (f : Î± â†’ Î²) :\n    ofFun (c â€¢ f) = c â€¢ ofFun f :=\n  rfl\n\n"}
{"name":"UniformOnFun.toFun_smul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\nM : Type u_5\ninstâœ : SMul M Î²\nc : M\nf : UniformOnFun Î± Î² ğ”–\nâŠ¢ Eq ((UniformOnFun.toFun ğ”–) (HSMul.hSMul c f)) (HSMul.hSMul c ((UniformOnFun.toFun ğ”–) f))","decl":"@[simp]\nlemma UniformOnFun.toFun_smul {M : Type*} [SMul M Î²] (c : M) (f : Î± â†’áµ¤[ğ”–] Î²) :\n    toFun ğ”– (c â€¢ f) = c â€¢ toFun ğ”– f :=\n  rfl\n\n"}
{"name":"UniformOnFun.ofFun_smul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\nM : Type u_5\ninstâœ : SMul M Î²\nc : M\nf : Î± â†’ Î²\nâŠ¢ Eq ((UniformOnFun.ofFun ğ”–) (HSMul.hSMul c f)) (HSMul.hSMul c ((UniformOnFun.ofFun ğ”–) f))","decl":"@[simp]\nlemma UniformOnFun.ofFun_smul {M : Type*} [SMul M Î²] (c : M) (f : Î± â†’ Î²) :\n    ofFun ğ”– (c â€¢ f) = c â€¢ ofFun ğ”– f :=\n  rfl\n\n"}
{"name":"instIsScalarTowerUniformFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nM : Type u_5\nN : Type u_6\ninstâœÂ³ : SMul M N\ninstâœÂ² : SMul M Î²\ninstâœÂ¹ : SMul N Î²\ninstâœ : IsScalarTower M N Î²\nâŠ¢ IsScalarTower M N (UniformFun Î± Î²)","decl":"instance {M N : Type*} [SMul M N] [SMul M Î²] [SMul N Î²] [IsScalarTower M N Î²] :\n    IsScalarTower M N (Î± â†’áµ¤ Î²) :=\n  Pi.isScalarTower\n\n"}
{"name":"instIsScalarTowerUniformOnFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\nM : Type u_5\nN : Type u_6\ninstâœÂ³ : SMul M N\ninstâœÂ² : SMul M Î²\ninstâœÂ¹ : SMul N Î²\ninstâœ : IsScalarTower M N Î²\nâŠ¢ IsScalarTower M N (UniformOnFun Î± Î² ğ”–)","decl":"instance {M N : Type*} [SMul M N] [SMul M Î²] [SMul N Î²] [IsScalarTower M N Î²] :\n    IsScalarTower M N (Î± â†’áµ¤[ğ”–] Î²) :=\n  Pi.isScalarTower\n\n"}
{"name":"instSMulCommClassUniformFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nM : Type u_5\nN : Type u_6\ninstâœÂ² : SMul M Î²\ninstâœÂ¹ : SMul N Î²\ninstâœ : SMulCommClass M N Î²\nâŠ¢ SMulCommClass M N (UniformFun Î± Î²)","decl":"instance {M N : Type*} [SMul M Î²] [SMul N Î²] [SMulCommClass M N Î²] :\n    SMulCommClass M N (Î± â†’áµ¤ Î²) :=\n  Pi.smulCommClass\n\n"}
{"name":"instSMulCommClassUniformOnFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nğ”– : Set (Set Î±)\nM : Type u_5\nN : Type u_6\ninstâœÂ² : SMul M Î²\ninstâœÂ¹ : SMul N Î²\ninstâœ : SMulCommClass M N Î²\nâŠ¢ SMulCommClass M N (UniformOnFun Î± Î² ğ”–)","decl":"instance {M N : Type*} [SMul M Î²] [SMul N Î²] [SMulCommClass M N Î²] :\n    SMulCommClass M N (Î± â†’áµ¤[ğ”–] Î²) :=\n  Pi.smulCommClass\n\n"}
{"name":"instUniformGroupUniformFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : Group G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformGroup G\nâŠ¢ UniformGroup (UniformFun Î± G)","decl":"/-- If `G` is a uniform group, then `Î± â†’áµ¤ G` is a uniform group as well. -/\n@[to_additive \"If `G` is a uniform additive group,\nthen `Î± â†’áµ¤ G` is a uniform additive group as well.\"]\ninstance : UniformGroup (Î± â†’áµ¤ G) :=\n  âŸ¨(-- Since `(/) : G Ã— G â†’ G` is uniformly continuous,\n    -- `UniformFun.postcomp_uniformContinuous` tells us that\n    -- `((/) âˆ˜ â€”) : (Î± â†’áµ¤ G Ã— G) â†’ (Î± â†’áµ¤ G)` is uniformly continuous too. By precomposing with\n    -- `UniformFun.uniformEquivProdArrow`, this gives that\n    -- `(/) : (Î± â†’áµ¤ G) Ã— (Î± â†’áµ¤ G) â†’ (Î± â†’áµ¤ G)` is also uniformly continuous\n    UniformFun.postcomp_uniformContinuous uniformContinuous_div).comp\n    UniformFun.uniformEquivProdArrow.symm.uniformContinuousâŸ©\n\n"}
{"name":"instUniformAddGroupUniformFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformAddGroup G\nâŠ¢ UniformAddGroup (UniformFun Î± G)","decl":"/-- If `G` is a uniform group, then `Î± â†’áµ¤ G` is a uniform group as well. -/\n@[to_additive \"If `G` is a uniform additive group,\nthen `Î± â†’áµ¤ G` is a uniform additive group as well.\"]\ninstance : UniformGroup (Î± â†’áµ¤ G) :=\n  âŸ¨(-- Since `(/) : G Ã— G â†’ G` is uniformly continuous,\n    -- `UniformFun.postcomp_uniformContinuous` tells us that\n    -- `((/) âˆ˜ â€”) : (Î± â†’áµ¤ G Ã— G) â†’ (Î± â†’áµ¤ G)` is uniformly continuous too. By precomposing with\n    -- `UniformFun.uniformEquivProdArrow`, this gives that\n    -- `(/) : (Î± â†’áµ¤ G) Ã— (Î± â†’áµ¤ G) â†’ (Î± â†’áµ¤ G)` is also uniformly continuous\n    UniformFun.postcomp_uniformContinuous uniformContinuous_div).comp\n    UniformFun.uniformEquivProdArrow.symm.uniformContinuousâŸ©\n\n"}
{"name":"UniformFun.hasBasis_nhds_zero_of_basis","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\nÎ¹ : Type u_3\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformAddGroup G\np : Î¹ â†’ Prop\nb : Î¹ â†’ Set G\nh : (nhds 0).HasBasis p b\nâŠ¢ (nhds 0).HasBasis p fun i => setOf fun f => âˆ€ (x : Î±), Membership.mem (b i) (UniformFun.toFun f x)","decl":"@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one_of_basis {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set G}\n    (h : (ğ“ 1 : Filter G).HasBasis p b) :\n    (ğ“ 1 : Filter (Î± â†’áµ¤ G)).HasBasis p fun i => { f : Î± â†’áµ¤ G | âˆ€ x, toFun f x âˆˆ b i } := by\n  convert UniformFun.hasBasis_nhds_of_basis Î± _ (1 : Î± â†’áµ¤ G) h.uniformity_of_nhds_one\n  simp\n\n"}
{"name":"UniformFun.hasBasis_nhds_one_of_basis","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\nÎ¹ : Type u_3\ninstâœÂ² : Group G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformGroup G\np : Î¹ â†’ Prop\nb : Î¹ â†’ Set G\nh : (nhds 1).HasBasis p b\nâŠ¢ (nhds 1).HasBasis p fun i => setOf fun f => âˆ€ (x : Î±), Membership.mem (b i) (UniformFun.toFun f x)","decl":"@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one_of_basis {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set G}\n    (h : (ğ“ 1 : Filter G).HasBasis p b) :\n    (ğ“ 1 : Filter (Î± â†’áµ¤ G)).HasBasis p fun i => { f : Î± â†’áµ¤ G | âˆ€ x, toFun f x âˆˆ b i } := by\n  convert UniformFun.hasBasis_nhds_of_basis Î± _ (1 : Î± â†’áµ¤ G) h.uniformity_of_nhds_one\n  simp\n\n"}
{"name":"UniformFun.hasBasis_nhds_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : Group G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformGroup G\nâŠ¢ (nhds 1).HasBasis (fun V => Membership.mem (nhds 1) V) fun V => setOf fun f => âˆ€ (x : Î±), Membership.mem V (f x)","decl":"@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one :\n    (ğ“ 1 : Filter (Î± â†’áµ¤ G)).HasBasis (fun V : Set G => V âˆˆ (ğ“ 1 : Filter G)) fun V =>\n      { f : Î± â†’ G | âˆ€ x, f x âˆˆ V } :=\n  UniformFun.hasBasis_nhds_one_of_basis (basis_sets _)\n\n"}
{"name":"UniformFun.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformAddGroup G\nâŠ¢ (nhds 0).HasBasis (fun V => Membership.mem (nhds 0) V) fun V => setOf fun f => âˆ€ (x : Î±), Membership.mem V (f x)","decl":"@[to_additive]\nprotected theorem UniformFun.hasBasis_nhds_one :\n    (ğ“ 1 : Filter (Î± â†’áµ¤ G)).HasBasis (fun V : Set G => V âˆˆ (ğ“ 1 : Filter G)) fun V =>\n      { f : Î± â†’ G | âˆ€ x, f x âˆˆ V } :=\n  UniformFun.hasBasis_nhds_one_of_basis (basis_sets _)\n\n"}
{"name":"instUniformGroupUniformOnFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : Group G\nğ”– : Set (Set Î±)\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformGroup G\nâŠ¢ UniformGroup (UniformOnFun Î± G ğ”–)","decl":"/-- Let `ğ”– : Set (Set Î±)`. If `G` is a uniform group, then `Î± â†’áµ¤[ğ”–] G` is a uniform group as\nwell. -/\n@[to_additive \"Let `ğ”– : Set (Set Î±)`. If `G` is a uniform additive group,\nthen `Î± â†’áµ¤[ğ”–] G` is a uniform additive group as well.\"]\ninstance : UniformGroup (Î± â†’áµ¤[ğ”–] G) :=\n  âŸ¨(-- Since `(/) : G Ã— G â†’ G` is uniformly continuous,\n    -- `UniformOnFun.postcomp_uniformContinuous` tells us that\n    -- `((/) âˆ˜ â€”) : (Î± â†’áµ¤[ğ”–] G Ã— G) â†’ (Î± â†’áµ¤[ğ”–] G)` is uniformly continuous too. By precomposing with\n    -- `UniformOnFun.uniformEquivProdArrow`, this gives that\n    -- `(/) : (Î± â†’áµ¤[ğ”–] G) Ã— (Î± â†’áµ¤[ğ”–] G) â†’ (Î± â†’áµ¤[ğ”–] G)` is also uniformly continuous\n    UniformOnFun.postcomp_uniformContinuous uniformContinuous_div).comp\n    UniformOnFun.uniformEquivProdArrow.symm.uniformContinuousâŸ©\n\n"}
{"name":"instUniformAddGroupUniformOnFun","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : AddGroup G\nğ”– : Set (Set Î±)\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformAddGroup G\nâŠ¢ UniformAddGroup (UniformOnFun Î± G ğ”–)","decl":"/-- Let `ğ”– : Set (Set Î±)`. If `G` is a uniform group, then `Î± â†’áµ¤[ğ”–] G` is a uniform group as\nwell. -/\n@[to_additive \"Let `ğ”– : Set (Set Î±)`. If `G` is a uniform additive group,\nthen `Î± â†’áµ¤[ğ”–] G` is a uniform additive group as well.\"]\ninstance : UniformGroup (Î± â†’áµ¤[ğ”–] G) :=\n  âŸ¨(-- Since `(/) : G Ã— G â†’ G` is uniformly continuous,\n    -- `UniformOnFun.postcomp_uniformContinuous` tells us that\n    -- `((/) âˆ˜ â€”) : (Î± â†’áµ¤[ğ”–] G Ã— G) â†’ (Î± â†’áµ¤[ğ”–] G)` is uniformly continuous too. By precomposing with\n    -- `UniformOnFun.uniformEquivProdArrow`, this gives that\n    -- `(/) : (Î± â†’áµ¤[ğ”–] G) Ã— (Î± â†’áµ¤[ğ”–] G) â†’ (Î± â†’áµ¤[ğ”–] G)` is also uniformly continuous\n    UniformOnFun.postcomp_uniformContinuous uniformContinuous_div).comp\n    UniformOnFun.uniformEquivProdArrow.symm.uniformContinuousâŸ©\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_zero_of_basis","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\nÎ¹ : Type u_3\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformAddGroup G\nğ”– : Set (Set Î±)\nhğ”–â‚ : ğ”–.Nonempty\nhğ”–â‚‚ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\np : Î¹ â†’ Prop\nb : Î¹ â†’ Set G\nh : (nhds 0).HasBasis p b\nâŠ¢ (nhds 0).HasBasis (fun Si => And (Membership.mem ğ”– Si.1) (p Si.2)) fun Si => setOf fun f => âˆ€ (x : Î±), Membership.mem Si.1 x â†’ Membership.mem (b Si.2) ((UniformOnFun.toFun ğ”–) f x)","decl":"@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one_of_basis (ğ”– : Set <| Set Î±) (hğ”–â‚ : ğ”–.Nonempty)\n    (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set G}\n    (h : (ğ“ 1 : Filter G).HasBasis p b) :\n    (ğ“ 1 : Filter (Î± â†’áµ¤[ğ”–] G)).HasBasis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2) fun Si =>\n      { f : Î± â†’áµ¤[ğ”–] G | âˆ€ x âˆˆ Si.1, toFun ğ”– f x âˆˆ b Si.2 } := by\n  convert UniformOnFun.hasBasis_nhds_of_basis Î± _ ğ”– (1 : Î± â†’áµ¤[ğ”–] G) hğ”–â‚ hğ”–â‚‚ <|\n    h.uniformity_of_nhds_one_swapped\n  simp [UniformOnFun.gen]\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_one_of_basis","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\nÎ¹ : Type u_3\ninstâœÂ² : Group G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformGroup G\nğ”– : Set (Set Î±)\nhğ”–â‚ : ğ”–.Nonempty\nhğ”–â‚‚ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\np : Î¹ â†’ Prop\nb : Î¹ â†’ Set G\nh : (nhds 1).HasBasis p b\nâŠ¢ (nhds 1).HasBasis (fun Si => And (Membership.mem ğ”– Si.1) (p Si.2)) fun Si => setOf fun f => âˆ€ (x : Î±), Membership.mem Si.1 x â†’ Membership.mem (b Si.2) ((UniformOnFun.toFun ğ”–) f x)","decl":"@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one_of_basis (ğ”– : Set <| Set Î±) (hğ”–â‚ : ğ”–.Nonempty)\n    (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–) {p : Î¹ â†’ Prop} {b : Î¹ â†’ Set G}\n    (h : (ğ“ 1 : Filter G).HasBasis p b) :\n    (ğ“ 1 : Filter (Î± â†’áµ¤[ğ”–] G)).HasBasis (fun Si : Set Î± Ã— Î¹ => Si.1 âˆˆ ğ”– âˆ§ p Si.2) fun Si =>\n      { f : Î± â†’áµ¤[ğ”–] G | âˆ€ x âˆˆ Si.1, toFun ğ”– f x âˆˆ b Si.2 } := by\n  convert UniformOnFun.hasBasis_nhds_of_basis Î± _ ğ”– (1 : Î± â†’áµ¤[ğ”–] G) hğ”–â‚ hğ”–â‚‚ <|\n    h.uniformity_of_nhds_one_swapped\n  simp [UniformOnFun.gen]\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformAddGroup G\nğ”– : Set (Set Î±)\nhğ”–â‚ : ğ”–.Nonempty\nhğ”–â‚‚ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\nâŠ¢ (nhds 0).HasBasis (fun SV => And (Membership.mem ğ”– SV.1) (Membership.mem (nhds 0) SV.2)) fun SV => setOf fun f => âˆ€ (x : Î±), Membership.mem SV.1 x â†’ Membership.mem SV.2 (f x)","decl":"@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one (ğ”– : Set <| Set Î±) (hğ”–â‚ : ğ”–.Nonempty)\n    (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–) :\n    (ğ“ 1 : Filter (Î± â†’áµ¤[ğ”–] G)).HasBasis\n      (fun SV : Set Î± Ã— Set G => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ (ğ“ 1 : Filter G)) fun SV =>\n      { f : Î± â†’áµ¤[ğ”–] G | âˆ€ x âˆˆ SV.1, f x âˆˆ SV.2 } :=\n  UniformOnFun.hasBasis_nhds_one_of_basis ğ”– hğ”–â‚ hğ”–â‚‚ (basis_sets _)\n\n"}
{"name":"UniformOnFun.hasBasis_nhds_one","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"Î± : Type u_1\nG : Type u_2\ninstâœÂ² : Group G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformGroup G\nğ”– : Set (Set Î±)\nhğ”–â‚ : ğ”–.Nonempty\nhğ”–â‚‚ : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) ğ”–\nâŠ¢ (nhds 1).HasBasis (fun SV => And (Membership.mem ğ”– SV.1) (Membership.mem (nhds 1) SV.2)) fun SV => setOf fun f => âˆ€ (x : Î±), Membership.mem SV.1 x â†’ Membership.mem SV.2 (f x)","decl":"@[to_additive]\nprotected theorem UniformOnFun.hasBasis_nhds_one (ğ”– : Set <| Set Î±) (hğ”–â‚ : ğ”–.Nonempty)\n    (hğ”–â‚‚ : DirectedOn (Â· âŠ† Â·) ğ”–) :\n    (ğ“ 1 : Filter (Î± â†’áµ¤[ğ”–] G)).HasBasis\n      (fun SV : Set Î± Ã— Set G => SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ (ğ“ 1 : Filter G)) fun SV =>\n      { f : Î± â†’áµ¤[ğ”–] G | âˆ€ x âˆˆ SV.1, f x âˆˆ SV.2 } :=\n  UniformOnFun.hasBasis_nhds_one_of_basis ğ”– hğ”–â‚ hğ”–â‚‚ (basis_sets _)\n\n"}
{"name":"UniformFun.uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"M : Type u_1\nÎ± : Type u_2\nX : Type u_3\ninstâœÂ² : SMul M X\ninstâœÂ¹ : UniformSpace X\ninstâœ : UniformContinuousConstSMul M X\nâŠ¢ UniformContinuousConstSMul M (UniformFun Î± X)","decl":"instance UniformFun.uniformContinuousConstSMul :\n    UniformContinuousConstSMul M (Î± â†’áµ¤ X) where\n  uniformContinuous_const_smul c := UniformFun.postcomp_uniformContinuous <|\n    uniformContinuous_const_smul c\n\n"}
{"name":"UniformFunOn.uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformConvergence","initialProofState":"M : Type u_1\nÎ± : Type u_2\nX : Type u_3\ninstâœÂ² : SMul M X\ninstâœÂ¹ : UniformSpace X\ninstâœ : UniformContinuousConstSMul M X\nğ”– : Set (Set Î±)\nâŠ¢ UniformContinuousConstSMul M (UniformOnFun Î± X ğ”–)","decl":"instance UniformFunOn.uniformContinuousConstSMul {ğ”– : Set (Set Î±)} :\n    UniformContinuousConstSMul M (Î± â†’áµ¤[ğ”–] X) where\n  uniformContinuous_const_smul c := UniformOnFun.postcomp_uniformContinuous <|\n    uniformContinuous_const_smul c\n\n"}
