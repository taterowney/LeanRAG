{"name":"MeasureTheory.Subsingleton.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : Subsingleton β\nf : α → β\n⊢ MeasureTheory.StronglyMeasurable f","decl":"@[simp]\ntheorem Subsingleton.stronglyMeasurable [Subsingleton β] (f : α → β) : StronglyMeasurable f := by\n  let f_sf : α →ₛ β := ⟨f, fun x => ?_, Set.Subsingleton.finite Set.subsingleton_of_subsingleton⟩\n  · exact ⟨fun _ => f_sf, fun x => tendsto_const_nhds⟩\n  · have h_univ : f ⁻¹' {x} = Set.univ := by\n      ext1 y\n      simp [eq_iff_true_of_subsingleton]\n    rw [h_univ]\n    exact MeasurableSet.univ\n\n"}
{"name":"MeasureTheory.SimpleFunc.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : TopologicalSpace β\nf : MeasureTheory.SimpleFunc α β\n⊢ MeasureTheory.StronglyMeasurable ⇑f","decl":"theorem SimpleFunc.stronglyMeasurable (f : α →ₛ β) : StronglyMeasurable f :=\n  ⟨fun _ => f, fun _ => tendsto_const_nhds⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.of_finite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Finite α\ninst✝ : MeasurableSingletonClass α\nf : α → β\n⊢ MeasureTheory.StronglyMeasurable f","decl":"@[nontriviality]\ntheorem StronglyMeasurable.of_finite [Finite α] [MeasurableSingletonClass α]\n    {f : α → β} : StronglyMeasurable f :=\n  ⟨fun _ => SimpleFunc.ofFinite f, fun _ => tendsto_const_nhds⟩\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : TopologicalSpace β\nb : β\n⊢ MeasureTheory.StronglyMeasurable fun x => b","decl":"theorem stronglyMeasurable_const {b : β} : StronglyMeasurable fun _ : α => b :=\n  ⟨fun _ => SimpleFunc.const α b, fun _ => tendsto_const_nhds⟩\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_one","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : One β\n⊢ MeasureTheory.StronglyMeasurable 1","decl":"@[to_additive]\ntheorem stronglyMeasurable_one [One β] : StronglyMeasurable (1 : α → β) := stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_zero","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : Zero β\n⊢ MeasureTheory.StronglyMeasurable 0","decl":"@[to_additive]\ntheorem stronglyMeasurable_one [One β] : StronglyMeasurable (1 : α → β) := stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_const'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : ∀ (x y : α), Eq (f x) (f y)\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- A version of `stronglyMeasurable_const` that assumes `f x = f y` for all `x, y`.\nThis version works for functions between empty types. -/\ntheorem stronglyMeasurable_const' (hf : ∀ x y, f x = f y) : StronglyMeasurable f := by\n  nontriviality α\n  inhabit α\n  convert stronglyMeasurable_const (β := β) using 1\n  exact funext fun x => hf x default\n\n-- Porting note: changed binding type of `MeasurableSpace α`.\n"}
{"name":"MeasureTheory.Subsingleton.stronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : Subsingleton α\nf : α → β\n⊢ MeasureTheory.StronglyMeasurable f","decl":"@[simp]\ntheorem Subsingleton.stronglyMeasurable' [Subsingleton α] (f : α → β) : StronglyMeasurable f :=\n  stronglyMeasurable_const' fun x y => by rw [Subsingleton.elim x y]\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.tendsto_approx","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝ : TopologicalSpace β\nx✝ : MeasurableSpace α\nhf : MeasureTheory.StronglyMeasurable f\nx : α\n⊢ Filter.Tendsto (fun n => (hf.approx n) x) Filter.atTop (nhds (f x))","decl":"protected theorem tendsto_approx {_ : MeasurableSpace α} (hf : StronglyMeasurable f) :\n    ∀ x, Tendsto (fun n => hf.approx n x) atTop (𝓝 (f x)) :=\n  hf.choose_spec\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.tendsto_approxBounded_of_norm_le","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_5\nf : α → β\ninst✝¹ : NormedAddCommGroup β\ninst✝ : NormedSpace Real β\nm : MeasurableSpace α\nhf : MeasureTheory.StronglyMeasurable f\nc : Real\nx : α\nhfx : LE.le (Norm.norm (f x)) c\n⊢ Filter.Tendsto (fun n => (hf.approxBounded c n) x) Filter.atTop (nhds (f x))","decl":"theorem tendsto_approxBounded_of_norm_le {β} {f : α → β} [NormedAddCommGroup β] [NormedSpace ℝ β]\n    {m : MeasurableSpace α} (hf : StronglyMeasurable[m] f) {c : ℝ} {x : α} (hfx : ‖f x‖ ≤ c) :\n    Tendsto (fun n => hf.approxBounded c n x) atTop (𝓝 (f x)) := by\n  have h_tendsto := hf.tendsto_approx x\n  simp only [StronglyMeasurable.approxBounded, SimpleFunc.coe_map, Function.comp_apply]\n  by_cases hfx0 : ‖f x‖ = 0\n  · rw [norm_eq_zero] at hfx0\n    rw [hfx0] at h_tendsto ⊢\n    have h_tendsto_norm : Tendsto (fun n => ‖hf.approx n x‖) atTop (𝓝 0) := by\n      convert h_tendsto.norm\n      rw [norm_zero]\n    refine squeeze_zero_norm (fun n => ?_) h_tendsto_norm\n    calc\n      ‖min 1 (c / ‖hf.approx n x‖) • hf.approx n x‖ =\n          ‖min 1 (c / ‖hf.approx n x‖)‖ * ‖hf.approx n x‖ :=\n        norm_smul _ _\n      _ ≤ ‖(1 : ℝ)‖ * ‖hf.approx n x‖ := by\n        refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)\n        rw [norm_one, Real.norm_of_nonneg]\n        · exact min_le_left _ _\n        · exact le_min zero_le_one (div_nonneg ((norm_nonneg _).trans hfx) (norm_nonneg _))\n      _ = ‖hf.approx n x‖ := by rw [norm_one, one_mul]\n  rw [← one_smul ℝ (f x)]\n  refine Tendsto.smul ?_ h_tendsto\n  have : min 1 (c / ‖f x‖) = 1 := by\n    rw [min_eq_left_iff, one_le_div (lt_of_le_of_ne (norm_nonneg _) (Ne.symm hfx0))]\n    exact hfx\n  nth_rw 2 [this.symm]\n  refine Tendsto.min tendsto_const_nhds ?_\n  exact Tendsto.div tendsto_const_nhds h_tendsto.norm hfx0\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.tendsto_approxBounded_ae","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_5\nf : α → β\ninst✝¹ : NormedAddCommGroup β\ninst✝ : NormedSpace Real β\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.StronglyMeasurable f\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun n => (hf.approxBounded c n) x) Filter.atTop (nhds (f x))) (MeasureTheory.ae μ)","decl":"theorem tendsto_approxBounded_ae {β} {f : α → β} [NormedAddCommGroup β] [NormedSpace ℝ β]\n    {m m0 : MeasurableSpace α} {μ : Measure α} (hf : StronglyMeasurable[m] f) {c : ℝ}\n    (hf_bound : ∀ᵐ x ∂μ, ‖f x‖ ≤ c) :\n    ∀ᵐ x ∂μ, Tendsto (fun n => hf.approxBounded c n x) atTop (𝓝 (f x)) := by\n  filter_upwards [hf_bound] with x hfx using tendsto_approxBounded_of_norm_le hf hfx\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.norm_approxBounded_le","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_5\nf : α → β\ninst✝¹ : SeminormedAddCommGroup β\ninst✝ : NormedSpace Real β\nm : MeasurableSpace α\nc : Real\nhf : MeasureTheory.StronglyMeasurable f\nhc : LE.le 0 c\nn : Nat\nx : α\n⊢ LE.le (Norm.norm ((hf.approxBounded c n) x)) c","decl":"theorem norm_approxBounded_le {β} {f : α → β} [SeminormedAddCommGroup β] [NormedSpace ℝ β]\n    {m : MeasurableSpace α} {c : ℝ} (hf : StronglyMeasurable[m] f) (hc : 0 ≤ c) (n : ℕ) (x : α) :\n    ‖hf.approxBounded c n x‖ ≤ c := by\n  simp only [StronglyMeasurable.approxBounded, SimpleFunc.coe_map, Function.comp_apply]\n  refine (norm_smul_le _ _).trans ?_\n  by_cases h0 : ‖hf.approx n x‖ = 0\n  · simp only [h0, _root_.div_zero, min_eq_right, zero_le_one, norm_zero, mul_zero]\n    exact hc\n  rcases le_total ‖hf.approx n x‖ c with h | h\n  · rw [min_eq_left _]\n    · simpa only [norm_one, one_mul] using h\n    · rwa [one_le_div (lt_of_le_of_ne (norm_nonneg _) (Ne.symm h0))]\n  · rw [min_eq_right _]\n    · rw [norm_div, norm_norm, mul_comm, mul_div, div_eq_mul_inv, mul_comm, ← mul_assoc,\n        inv_mul_cancel₀ h0, one_mul, Real.norm_of_nonneg hc]\n    · rwa [div_le_one (lt_of_le_of_ne (norm_nonneg _) (Ne.symm h0))]\n\n"}
{"name":"stronglyMeasurable_bot_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : Nonempty β\ninst✝ : T2Space β\n⊢ Iff (MeasureTheory.StronglyMeasurable f) (Exists fun c => Eq f fun x => c)","decl":"theorem _root_.stronglyMeasurable_bot_iff [Nonempty β] [T2Space β] :\n    StronglyMeasurable[⊥] f ↔ ∃ c, f = fun _ => c := by\n  cases' isEmpty_or_nonempty α with hα hα\n  · simp only [@Subsingleton.stronglyMeasurable' _ _ ⊥ _ _ f,\n      eq_iff_true_of_subsingleton, exists_const]\n  refine ⟨fun hf => ?_, fun hf_eq => ?_⟩\n  · refine ⟨f hα.some, ?_⟩\n    let fs := hf.approx\n    have h_fs_tendsto : ∀ x, Tendsto (fun n => fs n x) atTop (𝓝 (f x)) := hf.tendsto_approx\n    have : ∀ n, ∃ c, ∀ x, fs n x = c := fun n => SimpleFunc.simpleFunc_bot (fs n)\n    let cs n := (this n).choose\n    have h_cs_eq : ∀ n, ⇑(fs n) = fun _ => cs n := fun n => funext (this n).choose_spec\n    conv at h_fs_tendsto => enter [x, 1, n]; rw [h_cs_eq]\n    have h_tendsto : Tendsto cs atTop (𝓝 (f hα.some)) := h_fs_tendsto hα.some\n    ext1 x\n    exact tendsto_nhds_unique (h_fs_tendsto x) h_tendsto\n  · obtain ⟨c, rfl⟩ := hf_eq\n    exact stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.finStronglyMeasurable_of_set_sigmaFinite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : TopologicalSpace β\ninst✝ : Zero β\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhf_meas : MeasureTheory.StronglyMeasurable f\nt : Set α\nht : MeasurableSet t\nhft_zero : ∀ (x : α), Membership.mem (HasCompl.compl t) x → Eq (f x) 0\nhtμ : MeasureTheory.SigmaFinite (μ.restrict t)\n⊢ MeasureTheory.FinStronglyMeasurable f μ","decl":"theorem finStronglyMeasurable_of_set_sigmaFinite [TopologicalSpace β] [Zero β]\n    {m : MeasurableSpace α} {μ : Measure α} (hf_meas : StronglyMeasurable f) {t : Set α}\n    (ht : MeasurableSet t) (hft_zero : ∀ x ∈ tᶜ, f x = 0) (htμ : SigmaFinite (μ.restrict t)) :\n    FinStronglyMeasurable f μ := by\n  haveI : SigmaFinite (μ.restrict t) := htμ\n  let S := spanningSets (μ.restrict t)\n  have hS_meas : ∀ n, MeasurableSet (S n) := measurableSet_spanningSets (μ.restrict t)\n  let f_approx := hf_meas.approx\n  let fs n := SimpleFunc.restrict (f_approx n) (S n ∩ t)\n  have h_fs_t_compl : ∀ n, ∀ x, x ∉ t → fs n x = 0 := by\n    intro n x hxt\n    rw [SimpleFunc.restrict_apply _ ((hS_meas n).inter ht)]\n    refine Set.indicator_of_not_mem ?_ _\n    simp [hxt]\n  refine ⟨fs, ?_, fun x => ?_⟩\n  · simp_rw [SimpleFunc.support_eq, ← Finset.mem_coe]\n    classical\n    refine fun n => measure_biUnion_lt_top {y ∈ (fs n).range | y ≠ 0}.finite_toSet fun y hy => ?_\n    rw [SimpleFunc.restrict_preimage_singleton _ ((hS_meas n).inter ht)]\n    swap\n    · letI : (y : β) → Decidable (y = 0) := fun y => Classical.propDecidable _\n      rw [Finset.mem_coe, Finset.mem_filter] at hy\n      exact hy.2\n    refine (measure_mono Set.inter_subset_left).trans_lt ?_\n    have h_lt_top := measure_spanningSets_lt_top (μ.restrict t) n\n    rwa [Measure.restrict_apply' ht] at h_lt_top\n  · by_cases hxt : x ∈ t\n    swap\n    · rw [funext fun n => h_fs_t_compl n x hxt, hft_zero x hxt]\n      exact tendsto_const_nhds\n    have h : Tendsto (fun n => (f_approx n) x) atTop (𝓝 (f x)) := hf_meas.tendsto_approx x\n    obtain ⟨n₁, hn₁⟩ : ∃ n, ∀ m, n ≤ m → fs m x = f_approx m x := by\n      obtain ⟨n, hn⟩ : ∃ n, ∀ m, n ≤ m → x ∈ S m ∩ t := by\n        rsuffices ⟨n, hn⟩ : ∃ n, ∀ m, n ≤ m → x ∈ S m\n        · exact ⟨n, fun m hnm => Set.mem_inter (hn m hnm) hxt⟩\n        rsuffices ⟨n, hn⟩ : ∃ n, x ∈ S n\n        · exact ⟨n, fun m hnm => monotone_spanningSets (μ.restrict t) hnm hn⟩\n        rw [← Set.mem_iUnion, iUnion_spanningSets (μ.restrict t)]\n        trivial\n      refine ⟨n, fun m hnm => ?_⟩\n      simp_rw [fs, SimpleFunc.restrict_apply _ ((hS_meas m).inter ht),\n        Set.indicator_of_mem (hn m hnm)]\n    rw [tendsto_atTop'] at h ⊢\n    intro s hs\n    obtain ⟨n₂, hn₂⟩ := h s hs\n    refine ⟨max n₁ n₂, fun m hm => ?_⟩\n    rw [hn₁ m ((le_max_left _ _).trans hm.le)]\n    exact hn₂ m ((le_max_right _ _).trans hm.le)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.finStronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : Zero β\nm0 : MeasurableSpace α\nhf : MeasureTheory.StronglyMeasurable f\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.FinStronglyMeasurable f μ","decl":"/-- If the measure is sigma-finite, all strongly measurable functions are\n  `FinStronglyMeasurable`. -/\n@[aesop 5% apply (rule_sets := [Measurable])]\nprotected theorem finStronglyMeasurable [TopologicalSpace β] [Zero β] {m0 : MeasurableSpace α}\n    (hf : StronglyMeasurable f) (μ : Measure α) [SigmaFinite μ] : FinStronglyMeasurable f μ :=\n  hf.finStronglyMeasurable_of_set_sigmaFinite MeasurableSet.univ (by simp)\n    (by rwa [Measure.restrict_univ])\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx✝ : MeasurableSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Measurable f","decl":"/-- A strongly measurable function is measurable. -/\n@[aesop 5% apply (rule_sets := [Measurable])]\nprotected theorem measurable {_ : MeasurableSpace α} [TopologicalSpace β] [PseudoMetrizableSpace β]\n    [MeasurableSpace β] [BorelSpace β] (hf : StronglyMeasurable f) : Measurable f :=\n  measurable_of_tendsto_metrizable (fun n => (hf.approx n).measurable)\n    (tendsto_pi_nhds.mpr hf.tendsto_approx)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.aemeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx✝ : MeasurableSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.StronglyMeasurable f\n⊢ AEMeasurable f μ","decl":"/-- A strongly measurable function is almost everywhere measurable. -/\n@[aesop 5% apply (rule_sets := [Measurable])]\nprotected theorem aemeasurable {_ : MeasurableSpace α} [TopologicalSpace β]\n    [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β] {μ : Measure α}\n    (hf : StronglyMeasurable f) : AEMeasurable f μ :=\n  hf.measurable.aemeasurable\n\n"}
{"name":"Continuous.comp_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nx✝ : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\ng : β → γ\nf : α → β\nhg : Continuous g\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => g (f x)","decl":"theorem _root_.Continuous.comp_stronglyMeasurable {_ : MeasurableSpace α} [TopologicalSpace β]\n    [TopologicalSpace γ] {g : β → γ} {f : α → β} (hg : Continuous g) (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun x => g (f x) :=\n  ⟨fun n => SimpleFunc.map g (hf.approx n), fun x => (hg.tendsto _).comp (hf.tendsto_approx x)⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_mulSupport","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : MeasurableSpace α\ninst✝² : One β\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.MetrizableSpace β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasurableSet (Function.mulSupport f)","decl":"@[to_additive]\nnonrec theorem measurableSet_mulSupport {m : MeasurableSpace α} [One β] [TopologicalSpace β]\n    [MetrizableSpace β] (hf : StronglyMeasurable f) : MeasurableSet (mulSupport f) := by\n  borelize β\n  exact measurableSet_mulSupport hf.measurable\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_support","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : MeasurableSpace α\ninst✝² : Zero β\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.MetrizableSpace β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasurableSet (Function.support f)","decl":"@[to_additive]\nnonrec theorem measurableSet_mulSupport {m : MeasurableSpace α} [One β] [TopologicalSpace β]\n    [MetrizableSpace β] (hf : StronglyMeasurable f) : MeasurableSet (mulSupport f) := by\n  borelize β\n  exact measurableSet_mulSupport hf.measurable\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mono","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm m' : MeasurableSpace α\ninst✝ : TopologicalSpace β\nhf : MeasureTheory.StronglyMeasurable f\nh_mono : LE.le m' m\n⊢ MeasureTheory.StronglyMeasurable f","decl":"protected theorem mono {m m' : MeasurableSpace α} [TopologicalSpace β]\n    (hf : StronglyMeasurable[m'] f) (h_mono : m' ≤ m) : StronglyMeasurable[m] f := by\n  let f_approx : ℕ → @SimpleFunc α m β := fun n =>\n    @SimpleFunc.mk α m β\n      (hf.approx n)\n      (fun x => h_mono _ (SimpleFunc.measurableSet_fiber' _ x))\n      (SimpleFunc.finite_range (hf.approx n))\n  exact ⟨f_approx, hf.tendsto_approx⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.prod_mk","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace γ\nf : α → β\ng : α → γ\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable fun x => { fst := f x, snd := g x }","decl":"protected theorem prod_mk {m : MeasurableSpace α} [TopologicalSpace β] [TopologicalSpace γ]\n    {f : α → β} {g : α → γ} (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => (f x, g x) := by\n  refine ⟨fun n => SimpleFunc.pair (hf.approx n) (hg.approx n), fun x => ?_⟩\n  rw [nhds_prod_eq]\n  exact Tendsto.prod_mk (hf.tendsto_approx x) (hg.tendsto_approx x)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.comp_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : TopologicalSpace β\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace γ\nf : α → β\ng : γ → α\nhf : MeasureTheory.StronglyMeasurable f\nhg : Measurable g\n⊢ MeasureTheory.StronglyMeasurable (Function.comp f g)","decl":"theorem comp_measurable [TopologicalSpace β] {_ : MeasurableSpace α} {_ : MeasurableSpace γ}\n    {f : α → β} {g : γ → α} (hf : StronglyMeasurable f) (hg : Measurable g) :\n    StronglyMeasurable (f ∘ g) :=\n  ⟨fun n => SimpleFunc.comp (hf.approx n) g hg, fun x => hf.tendsto_approx (g x)⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.of_uncurry_left","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : TopologicalSpace β\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace γ\nf : α → γ → β\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\nx : α\n⊢ MeasureTheory.StronglyMeasurable (f x)","decl":"theorem of_uncurry_left [TopologicalSpace β] {_ : MeasurableSpace α} {_ : MeasurableSpace γ}\n    {f : α → γ → β} (hf : StronglyMeasurable (uncurry f)) {x : α} : StronglyMeasurable (f x) :=\n  hf.comp_measurable measurable_prod_mk_left\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.of_uncurry_right","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : TopologicalSpace β\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace γ\nf : α → γ → β\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\ny : γ\n⊢ MeasureTheory.StronglyMeasurable fun x => f x y","decl":"theorem of_uncurry_right [TopologicalSpace β] {_ : MeasurableSpace α} {_ : MeasurableSpace γ}\n    {f : α → γ → β} (hf : StronglyMeasurable (uncurry f)) {y : γ} :\n    StronglyMeasurable fun x => f x y :=\n  hf.comp_measurable measurable_prod_mk_right\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.prod_swap","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace β\ninst✝ : TopologicalSpace γ\nf : Prod β α → γ\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun z => f z.swap","decl":"protected theorem prod_swap {_ : MeasurableSpace α} {_ : MeasurableSpace β} [TopologicalSpace γ]\n    {f : β × α → γ} (hf : StronglyMeasurable f) :\n    StronglyMeasurable (fun z : α × β => f z.swap) :=\n  hf.comp_measurable measurable_swap\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.fst","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nx✝ : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : TopologicalSpace γ\nf : α → γ\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun z => f z.1","decl":"protected theorem fst {_ : MeasurableSpace α} [mβ : MeasurableSpace β] [TopologicalSpace γ]\n    {f : α → γ} (hf : StronglyMeasurable f) :\n    StronglyMeasurable (fun z : α × β => f z.1) :=\n  hf.comp_measurable measurable_fst\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.snd","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\nx✝ : MeasurableSpace β\ninst✝ : TopologicalSpace γ\nf : β → γ\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun z => f z.2","decl":"protected theorem snd [mα : MeasurableSpace α] {_ : MeasurableSpace β} [TopologicalSpace γ]\n    {f : β → γ} (hf : StronglyMeasurable f) :\n    StronglyMeasurable (fun z : α × β => f z.2) :=\n  hf.comp_measurable measurable_snd\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Mul β\ninst✝ : ContinuousMul β\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable (HMul.hMul f g)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem mul [Mul β] [ContinuousMul β] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f * g) :=\n  ⟨fun n => hf.approx n * hg.approx n, fun x => (hf.tendsto_approx x).mul (hg.tendsto_approx x)⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.add","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Add β\ninst✝ : ContinuousAdd β\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable (HAdd.hAdd f g)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem mul [Mul β] [ContinuousMul β] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f * g) :=\n  ⟨fun n => hf.approx n * hg.approx n, fun x => (hf.tendsto_approx x).mul (hg.tendsto_approx x)⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.add_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Add β\ninst✝ : ContinuousAdd β\nhf : MeasureTheory.StronglyMeasurable f\nc : β\n⊢ MeasureTheory.StronglyMeasurable fun x => HAdd.hAdd (f x) c","decl":"@[to_additive (attr := measurability)]\ntheorem mul_const [Mul β] [ContinuousMul β] (hf : StronglyMeasurable f) (c : β) :\n    StronglyMeasurable fun x => f x * c :=\n  hf.mul stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mul_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Mul β\ninst✝ : ContinuousMul β\nhf : MeasureTheory.StronglyMeasurable f\nc : β\n⊢ MeasureTheory.StronglyMeasurable fun x => HMul.hMul (f x) c","decl":"@[to_additive (attr := measurability)]\ntheorem mul_const [Mul β] [ContinuousMul β] (hf : StronglyMeasurable f) (c : β) :\n    StronglyMeasurable fun x => f x * c :=\n  hf.mul stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_add","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Add β\ninst✝ : ContinuousAdd β\nhf : MeasureTheory.StronglyMeasurable f\nc : β\n⊢ MeasureTheory.StronglyMeasurable fun x => HAdd.hAdd c (f x)","decl":"@[to_additive (attr := measurability)]\ntheorem const_mul [Mul β] [ContinuousMul β] (hf : StronglyMeasurable f) (c : β) :\n    StronglyMeasurable fun x => c * f x :=\n  stronglyMeasurable_const.mul hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_mul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Mul β\ninst✝ : ContinuousMul β\nhf : MeasureTheory.StronglyMeasurable f\nc : β\n⊢ MeasureTheory.StronglyMeasurable fun x => HMul.hMul c (f x)","decl":"@[to_additive (attr := measurability)]\ntheorem const_mul [Mul β] [ContinuousMul β] (hf : StronglyMeasurable f) (c : β) :\n    StronglyMeasurable fun x => c * f x :=\n  stronglyMeasurable_const.mul hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.pow","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Monoid β\ninst✝ : ContinuousMul β\nhf : MeasureTheory.StronglyMeasurable f\nn : Nat\n⊢ MeasureTheory.StronglyMeasurable (HPow.hPow f n)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable])) const_nsmul]\nprotected theorem pow [Monoid β] [ContinuousMul β] (hf : StronglyMeasurable f) (n : ℕ) :\n    StronglyMeasurable (f ^ n) :=\n  ⟨fun k => hf.approx k ^ n, fun x => (hf.tendsto_approx x).pow n⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_nsmul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddMonoid β\ninst✝ : ContinuousAdd β\nhf : MeasureTheory.StronglyMeasurable f\nn : Nat\n⊢ MeasureTheory.StronglyMeasurable (HSMul.hSMul n f)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable])) const_nsmul]\nprotected theorem pow [Monoid β] [ContinuousMul β] (hf : StronglyMeasurable f) (n : ℕ) :\n    StronglyMeasurable (f ^ n) :=\n  ⟨fun k => hf.approx k ^ n, fun x => (hf.tendsto_approx x).pow n⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.inv","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Inv β\ninst✝ : ContinuousInv β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable (Inv.inv f)","decl":"@[to_additive (attr := measurability)]\nprotected theorem inv [Inv β] [ContinuousInv β] (hf : StronglyMeasurable f) :\n    StronglyMeasurable f⁻¹ :=\n  ⟨fun n => (hf.approx n)⁻¹, fun x => (hf.tendsto_approx x).inv⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.neg","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Neg β\ninst✝ : ContinuousNeg β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable (Neg.neg f)","decl":"@[to_additive (attr := measurability)]\nprotected theorem inv [Inv β] [ContinuousInv β] (hf : StronglyMeasurable f) :\n    StronglyMeasurable f⁻¹ :=\n  ⟨fun n => (hf.approx n)⁻¹, fun x => (hf.tendsto_approx x).inv⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.sub","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Sub β\ninst✝ : ContinuousSub β\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable (HSub.hSub f g)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem div [Div β] [ContinuousDiv β] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f / g) :=\n  ⟨fun n => hf.approx n / hg.approx n, fun x => (hf.tendsto_approx x).div' (hg.tendsto_approx x)⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.div","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Div β\ninst✝ : ContinuousDiv β\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable (HDiv.hDiv f g)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem div [Div β] [ContinuousDiv β] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f / g) :=\n  ⟨fun n => hf.approx n / hg.approx n, fun x => (hf.tendsto_approx x).div' (hg.tendsto_approx x)⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mul_iff_right","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : CommGroup β\ninst✝ : TopologicalGroup β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Iff (MeasureTheory.StronglyMeasurable (HMul.hMul f g)) (MeasureTheory.StronglyMeasurable g)","decl":"@[to_additive]\ntheorem mul_iff_right [CommGroup β] [TopologicalGroup β] (hf : StronglyMeasurable f) :\n    StronglyMeasurable (f * g) ↔ StronglyMeasurable g :=\n  ⟨fun h ↦ show g = f * g * f⁻¹ by simp only [mul_inv_cancel_comm] ▸ h.mul hf.inv,\n    fun h ↦ hf.mul h⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.add_iff_right","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddCommGroup β\ninst✝ : TopologicalAddGroup β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Iff (MeasureTheory.StronglyMeasurable (HAdd.hAdd f g)) (MeasureTheory.StronglyMeasurable g)","decl":"@[to_additive]\ntheorem mul_iff_right [CommGroup β] [TopologicalGroup β] (hf : StronglyMeasurable f) :\n    StronglyMeasurable (f * g) ↔ StronglyMeasurable g :=\n  ⟨fun h ↦ show g = f * g * f⁻¹ by simp only [mul_inv_cancel_comm] ▸ h.mul hf.inv,\n    fun h ↦ hf.mul h⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.add_iff_left","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AddCommGroup β\ninst✝ : TopologicalAddGroup β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Iff (MeasureTheory.StronglyMeasurable (HAdd.hAdd g f)) (MeasureTheory.StronglyMeasurable g)","decl":"@[to_additive]\ntheorem mul_iff_left [CommGroup β] [TopologicalGroup β] (hf : StronglyMeasurable f) :\n    StronglyMeasurable (g * f) ↔ StronglyMeasurable g :=\n  mul_comm g f ▸ mul_iff_right hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mul_iff_left","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : CommGroup β\ninst✝ : TopologicalGroup β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Iff (MeasureTheory.StronglyMeasurable (HMul.hMul g f)) (MeasureTheory.StronglyMeasurable g)","decl":"@[to_additive]\ntheorem mul_iff_left [CommGroup β] [TopologicalGroup β] (hf : StronglyMeasurable f) :\n    StronglyMeasurable (g * f) ↔ StronglyMeasurable g :=\n  mul_comm g f ▸ mul_iff_right hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.smul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\ninst✝³ : TopologicalSpace β\n𝕜 : Type u_5\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : SMul 𝕜 β\ninst✝ : ContinuousSMul 𝕜 β\nf : α → 𝕜\ng : α → β\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul (f x) (g x)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem smul {𝕜} [TopologicalSpace 𝕜] [SMul 𝕜 β] [ContinuousSMul 𝕜 β] {f : α → 𝕜}\n    {g : α → β} (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => f x • g x :=\n  continuous_smul.comp_stronglyMeasurable (hf.prod_mk hg)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.vadd","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\ninst✝³ : TopologicalSpace β\n𝕜 : Type u_5\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : VAdd 𝕜 β\ninst✝ : ContinuousVAdd 𝕜 β\nf : α → 𝕜\ng : α → β\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable fun x => HVAdd.hVAdd (f x) (g x)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem smul {𝕜} [TopologicalSpace 𝕜] [SMul 𝕜 β] [ContinuousSMul 𝕜 β] {f : α → 𝕜}\n    {g : α → β} (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => f x • g x :=\n  continuous_smul.comp_stronglyMeasurable (hf.prod_mk hg)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_smul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\n𝕜 : Type u_5\ninst✝¹ : SMul 𝕜 β\ninst✝ : ContinuousConstSMul 𝕜 β\nhf : MeasureTheory.StronglyMeasurable f\nc : 𝕜\n⊢ MeasureTheory.StronglyMeasurable (HSMul.hSMul c f)","decl":"@[to_additive (attr := measurability)]\nprotected theorem const_smul {𝕜} [SMul 𝕜 β] [ContinuousConstSMul 𝕜 β] (hf : StronglyMeasurable f)\n    (c : 𝕜) : StronglyMeasurable (c • f) :=\n  ⟨fun n => c • hf.approx n, fun x => (hf.tendsto_approx x).const_smul c⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_vadd","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\n𝕜 : Type u_5\ninst✝¹ : VAdd 𝕜 β\ninst✝ : ContinuousConstVAdd 𝕜 β\nhf : MeasureTheory.StronglyMeasurable f\nc : 𝕜\n⊢ MeasureTheory.StronglyMeasurable (HVAdd.hVAdd c f)","decl":"@[to_additive (attr := measurability)]\nprotected theorem const_smul {𝕜} [SMul 𝕜 β] [ContinuousConstSMul 𝕜 β] (hf : StronglyMeasurable f)\n    (c : 𝕜) : StronglyMeasurable (c • f) :=\n  ⟨fun n => c • hf.approx n, fun x => (hf.tendsto_approx x).const_smul c⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_vadd'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\n𝕜 : Type u_5\ninst✝¹ : VAdd 𝕜 β\ninst✝ : ContinuousConstVAdd 𝕜 β\nhf : MeasureTheory.StronglyMeasurable f\nc : 𝕜\n⊢ MeasureTheory.StronglyMeasurable fun x => HVAdd.hVAdd c (f x)","decl":"@[to_additive (attr := measurability)]\nprotected theorem const_smul' {𝕜} [SMul 𝕜 β] [ContinuousConstSMul 𝕜 β] (hf : StronglyMeasurable f)\n    (c : 𝕜) : StronglyMeasurable fun x => c • f x :=\n  hf.const_smul c\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_smul'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝² : TopologicalSpace β\n𝕜 : Type u_5\ninst✝¹ : SMul 𝕜 β\ninst✝ : ContinuousConstSMul 𝕜 β\nhf : MeasureTheory.StronglyMeasurable f\nc : 𝕜\n⊢ MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul c (f x)","decl":"@[to_additive (attr := measurability)]\nprotected theorem const_smul' {𝕜} [SMul 𝕜 β] [ContinuousConstSMul 𝕜 β] (hf : StronglyMeasurable f)\n    (c : 𝕜) : StronglyMeasurable fun x => c • f x :=\n  hf.const_smul c\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.smul_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\ninst✝³ : TopologicalSpace β\n𝕜 : Type u_5\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : SMul 𝕜 β\ninst✝ : ContinuousSMul 𝕜 β\nf : α → 𝕜\nhf : MeasureTheory.StronglyMeasurable f\nc : β\n⊢ MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul (f x) c","decl":"@[to_additive (attr := measurability)]\nprotected theorem smul_const {𝕜} [TopologicalSpace 𝕜] [SMul 𝕜 β] [ContinuousSMul 𝕜 β] {f : α → 𝕜}\n    (hf : StronglyMeasurable f) (c : β) : StronglyMeasurable fun x => f x • c :=\n  continuous_smul.comp_stronglyMeasurable (hf.prod_mk stronglyMeasurable_const)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.vadd_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\ninst✝³ : TopologicalSpace β\n𝕜 : Type u_5\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : VAdd 𝕜 β\ninst✝ : ContinuousVAdd 𝕜 β\nf : α → 𝕜\nhf : MeasureTheory.StronglyMeasurable f\nc : β\n⊢ MeasureTheory.StronglyMeasurable fun x => HVAdd.hVAdd (f x) c","decl":"@[to_additive (attr := measurability)]\nprotected theorem smul_const {𝕜} [TopologicalSpace 𝕜] [SMul 𝕜 β] [ContinuousSMul 𝕜 β] {f : α → 𝕜}\n    (hf : StronglyMeasurable f) (c : β) : StronglyMeasurable fun x => f x • c :=\n  continuous_smul.comp_stronglyMeasurable (hf.prod_mk stronglyMeasurable_const)\n\n"}
{"name":"Measurable.add_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_5\nE : Type u_6\nx✝ : MeasurableSpace α\ninst✝⁵ : AddGroup E\ninst✝⁴ : TopologicalSpace E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\ninst✝¹ : ContinuousAdd E\ninst✝ : TopologicalSpace.PseudoMetrizableSpace E\ng f : α → E\nhg : Measurable g\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Measurable (HAdd.hAdd g f)","decl":"/-- In a normed vector space, the addition of a measurable function and a strongly measurable\nfunction is measurable. Note that this is not true without further second-countability assumptions\nfor the addition of two measurable functions. -/\ntheorem _root_.Measurable.add_stronglyMeasurable\n    {α E : Type*} {_ : MeasurableSpace α} [AddGroup E] [TopologicalSpace E]\n    [MeasurableSpace E] [BorelSpace E] [ContinuousAdd E] [PseudoMetrizableSpace E]\n    {g f : α → E} (hg : Measurable g) (hf : StronglyMeasurable f) :\n    Measurable (g + f) := by\n  rcases hf with ⟨φ, hφ⟩\n  have : Tendsto (fun n x ↦ g x + φ n x) atTop (𝓝 (g + f)) :=\n    tendsto_pi_nhds.2 (fun x ↦ tendsto_const_nhds.add (hφ x))\n  apply measurable_of_tendsto_metrizable (fun n ↦ ?_) this\n  exact hg.add_simpleFunc _\n\n"}
{"name":"Measurable.sub_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_5\nE : Type u_6\nx✝ : MeasurableSpace α\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\ninst✝² : ContinuousAdd E\ninst✝¹ : ContinuousNeg E\ninst✝ : TopologicalSpace.PseudoMetrizableSpace E\ng f : α → E\nhg : Measurable g\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Measurable (HSub.hSub g f)","decl":"/-- In a normed vector space, the subtraction of a measurable function and a strongly measurable\nfunction is measurable. Note that this is not true without further second-countability assumptions\nfor the subtraction of two measurable functions. -/\ntheorem _root_.Measurable.sub_stronglyMeasurable\n    {α E : Type*} {_ : MeasurableSpace α} [AddCommGroup E] [TopologicalSpace E]\n    [MeasurableSpace E] [BorelSpace E] [ContinuousAdd E] [ContinuousNeg E] [PseudoMetrizableSpace E]\n    {g f : α → E} (hg : Measurable g) (hf : StronglyMeasurable f) :\n    Measurable (g - f) := by\n  rw [sub_eq_add_neg]\n  exact hg.add_stronglyMeasurable hf.neg\n\n"}
{"name":"Measurable.stronglyMeasurable_add","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_5\nE : Type u_6\nx✝ : MeasurableSpace α\ninst✝⁵ : AddGroup E\ninst✝⁴ : TopologicalSpace E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\ninst✝¹ : ContinuousAdd E\ninst✝ : TopologicalSpace.PseudoMetrizableSpace E\ng f : α → E\nhg : Measurable g\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Measurable (HAdd.hAdd f g)","decl":"/-- In a normed vector space, the addition of a strongly measurable function and a measurable\nfunction is measurable. Note that this is not true without further second-countability assumptions\nfor the addition of two measurable functions. -/\ntheorem _root_.Measurable.stronglyMeasurable_add\n    {α E : Type*} {_ : MeasurableSpace α} [AddGroup E] [TopologicalSpace E]\n    [MeasurableSpace E] [BorelSpace E] [ContinuousAdd E] [PseudoMetrizableSpace E]\n    {g f : α → E} (hg : Measurable g) (hf : StronglyMeasurable f) :\n    Measurable (f + g) := by\n  rcases hf with ⟨φ, hφ⟩\n  have : Tendsto (fun n x ↦ φ n x + g x) atTop (𝓝 (f + g)) :=\n    tendsto_pi_nhds.2 (fun x ↦ (hφ x).add tendsto_const_nhds)\n  apply measurable_of_tendsto_metrizable (fun n ↦ ?_) this\n  exact hg.simpleFunc_add _\n\n"}
{"name":"stronglyMeasurable_const_smul_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nG : Type u_6\ninst✝³ : TopologicalSpace β\ninst✝² : Group G\ninst✝¹ : MulAction G β\ninst✝ : ContinuousConstSMul G β\nm : MeasurableSpace α\nc : G\n⊢ Iff (MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul c (f x)) (MeasureTheory.StronglyMeasurable f)","decl":"theorem _root_.stronglyMeasurable_const_smul_iff {m : MeasurableSpace α} (c : G) :\n    (StronglyMeasurable fun x => c • f x) ↔ StronglyMeasurable f :=\n  ⟨fun h => by simpa only [inv_smul_smul] using h.const_smul' c⁻¹, fun h => h.const_smul c⟩\n\n"}
{"name":"IsUnit.stronglyMeasurable_const_smul_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nM : Type u_5\ninst✝³ : TopologicalSpace β\ninst✝² : Monoid M\ninst✝¹ : MulAction M β\ninst✝ : ContinuousConstSMul M β\nx✝ : MeasurableSpace α\nc : M\nhc : IsUnit c\n⊢ Iff (MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul c (f x)) (MeasureTheory.StronglyMeasurable f)","decl":"nonrec theorem _root_.IsUnit.stronglyMeasurable_const_smul_iff {_ : MeasurableSpace α} {c : M}\n    (hc : IsUnit c) :\n    (StronglyMeasurable fun x => c • f x) ↔ StronglyMeasurable f :=\n  let ⟨u, hu⟩ := hc\n  hu ▸ stronglyMeasurable_const_smul_iff u\n\n"}
{"name":"stronglyMeasurable_const_smul_iff₀","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nG₀ : Type u_7\ninst✝³ : TopologicalSpace β\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ β\ninst✝ : ContinuousConstSMul G₀ β\nx✝ : MeasurableSpace α\nc : G₀\nhc : Ne c 0\n⊢ Iff (MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul c (f x)) (MeasureTheory.StronglyMeasurable f)","decl":"theorem _root_.stronglyMeasurable_const_smul_iff₀ {_ : MeasurableSpace α} {c : G₀} (hc : c ≠ 0) :\n    (StronglyMeasurable fun x => c • f x) ↔ StronglyMeasurable f :=\n  (IsUnit.mk0 _ hc).stronglyMeasurable_const_smul_iff\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.sup","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ninst✝³ : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Max β\ninst✝ : ContinuousSup β\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable (Max.max f g)","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem sup [Max β] [ContinuousSup β] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f ⊔ g) :=\n  ⟨fun n => hf.approx n ⊔ hg.approx n, fun x =>\n    (hf.tendsto_approx x).sup_nhds (hg.tendsto_approx x)⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.inf","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ninst✝³ : MeasurableSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : Min β\ninst✝ : ContinuousInf β\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable (Min.min f g)","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem inf [Min β] [ContinuousInf β] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f ⊓ g) :=\n  ⟨fun n => hf.approx n ⊓ hg.approx n, fun x =>\n    (hf.tendsto_approx x).inf_nhds (hg.tendsto_approx x)⟩\n\n"}
{"name":"List.stronglyMeasurable_sum'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : AddMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nm : MeasurableSpace α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable l.sum","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod' (l : List (α → M))\n    (hl : ∀ f ∈ l, StronglyMeasurable f) : StronglyMeasurable l.prod := by\n  induction' l with f l ihl; · exact stronglyMeasurable_one\n  rw [List.forall_mem_cons] at hl\n  rw [List.prod_cons]\n  exact hl.1.mul (ihl hl.2)\n\n"}
{"name":"List.stronglyMeasurable_prod'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : Monoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nm : MeasurableSpace α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable l.prod","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod' (l : List (α → M))\n    (hl : ∀ f ∈ l, StronglyMeasurable f) : StronglyMeasurable l.prod := by\n  induction' l with f l ihl; · exact stronglyMeasurable_one\n  rw [List.forall_mem_cons] at hl\n  rw [List.prod_cons]\n  exact hl.1.mul (ihl hl.2)\n\n"}
{"name":"List.stronglyMeasurable_sum","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : AddMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nm : MeasurableSpace α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => (List.map (fun f => f x) l).sum","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod (l : List (α → M))\n    (hl : ∀ f ∈ l, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (l.map fun f : α → M => f x).prod := by\n  simpa only [← Pi.list_prod_apply] using l.stronglyMeasurable_prod' hl\n\n"}
{"name":"List.stronglyMeasurable_prod","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : Monoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nm : MeasurableSpace α\nl : List (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => (List.map (fun f => f x) l).prod","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod (l : List (α → M))\n    (hl : ∀ f ∈ l, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (l.map fun f : α → M => f x).prod := by\n  simpa only [← Pi.list_prod_apply] using l.stronglyMeasurable_prod' hl\n\n"}
{"name":"Multiset.stronglyMeasurable_sum'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nm : MeasurableSpace α\nl : Multiset (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable l.sum","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod' (l : Multiset (α → M))\n    (hl : ∀ f ∈ l, StronglyMeasurable f) : StronglyMeasurable l.prod := by\n  rcases l with ⟨l⟩\n  simpa using l.stronglyMeasurable_prod' (by simpa using hl)\n\n"}
{"name":"Multiset.stronglyMeasurable_prod'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nm : MeasurableSpace α\nl : Multiset (α → M)\nhl : ∀ (f : α → M), Membership.mem l f → MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable l.prod","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod' (l : Multiset (α → M))\n    (hl : ∀ f ∈ l, StronglyMeasurable f) : StronglyMeasurable l.prod := by\n  rcases l with ⟨l⟩\n  simpa using l.stronglyMeasurable_prod' (by simpa using hl)\n\n"}
{"name":"Multiset.stronglyMeasurable_sum","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nm : MeasurableSpace α\ns : Multiset (α → M)\nhs : ∀ (f : α → M), Membership.mem s f → MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => (Multiset.map (fun f => f x) s).sum","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod (s : Multiset (α → M))\n    (hs : ∀ f ∈ s, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (s.map fun f : α → M => f x).prod := by\n  simpa only [← Pi.multiset_prod_apply] using s.stronglyMeasurable_prod' hs\n\n"}
{"name":"Multiset.stronglyMeasurable_prod","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nm : MeasurableSpace α\ns : Multiset (α → M)\nhs : ∀ (f : α → M), Membership.mem s f → MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => (Multiset.map (fun f => f x) s).prod","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod (s : Multiset (α → M))\n    (hs : ∀ f ∈ s, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (s.map fun f : α → M => f x).prod := by\n  simpa only [← Pi.multiset_prod_apply] using s.stronglyMeasurable_prod' hs\n\n"}
{"name":"Finset.stronglyMeasurable_sum'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nm : MeasurableSpace α\nι : Type u_6\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → MeasureTheory.StronglyMeasurable (f i)\n⊢ MeasureTheory.StronglyMeasurable (s.sum fun i => f i)","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod' {ι : Type*} {f : ι → α → M} (s : Finset ι)\n    (hf : ∀ i ∈ s, StronglyMeasurable (f i)) : StronglyMeasurable (∏ i ∈ s, f i) :=\n  Finset.prod_induction _ _ (fun _a _b ha hb => ha.mul hb) (@stronglyMeasurable_one α M _ _ _) hf\n\n"}
{"name":"Finset.stronglyMeasurable_prod'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nm : MeasurableSpace α\nι : Type u_6\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → MeasureTheory.StronglyMeasurable (f i)\n⊢ MeasureTheory.StronglyMeasurable (s.prod fun i => f i)","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod' {ι : Type*} {f : ι → α → M} (s : Finset ι)\n    (hf : ∀ i ∈ s, StronglyMeasurable (f i)) : StronglyMeasurable (∏ i ∈ s, f i) :=\n  Finset.prod_induction _ _ (fun _a _b ha hb => ha.mul hb) (@stronglyMeasurable_one α M _ _ _) hf\n\n"}
{"name":"Finset.stronglyMeasurable_sum","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nm : MeasurableSpace α\nι : Type u_6\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → MeasureTheory.StronglyMeasurable (f i)\n⊢ MeasureTheory.StronglyMeasurable fun a => s.sum fun i => f i a","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod {ι : Type*} {f : ι → α → M} (s : Finset ι)\n    (hf : ∀ i ∈ s, StronglyMeasurable (f i)) : StronglyMeasurable fun a => ∏ i ∈ s, f i a := by\n  simpa only [← Finset.prod_apply] using s.stronglyMeasurable_prod' hf\n\n"}
{"name":"Finset.stronglyMeasurable_prod","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nm : MeasurableSpace α\nι : Type u_6\nf : ι → α → M\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → MeasureTheory.StronglyMeasurable (f i)\n⊢ MeasureTheory.StronglyMeasurable fun a => s.prod fun i => f i a","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod {ι : Type*} {f : ι → α → M} (s : Finset ι)\n    (hf : ∀ i ∈ s, StronglyMeasurable (f i)) : StronglyMeasurable fun a => ∏ i ∈ s, f i a := by\n  simpa only [← Finset.prod_apply] using s.stronglyMeasurable_prod' hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.isSeparable_range","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : MeasurableSpace α\ninst✝ : TopologicalSpace β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ TopologicalSpace.IsSeparable (Set.range f)","decl":"/-- The range of a strongly measurable function is separable. -/\nprotected theorem isSeparable_range {m : MeasurableSpace α} [TopologicalSpace β]\n    (hf : StronglyMeasurable f) : TopologicalSpace.IsSeparable (range f) := by\n  have : IsSeparable (closure (⋃ n, range (hf.approx n))) :=\n    .closure <| .iUnion fun n => (hf.approx n).finite_range.isSeparable\n  apply this.mono\n  rintro _ ⟨x, rfl⟩\n  apply mem_closure_of_tendsto (hf.tendsto_approx x)\n  filter_upwards with n\n  apply mem_iUnion_of_mem n\n  exact mem_range_self _\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.separableSpace_range_union_singleton","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx✝ : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.PseudoMetrizableSpace β\nhf : MeasureTheory.StronglyMeasurable f\nb : β\n⊢ TopologicalSpace.SeparableSpace ↑(Union.union (Set.range f) (Singleton.singleton b))","decl":"theorem separableSpace_range_union_singleton {_ : MeasurableSpace α} [TopologicalSpace β]\n    [PseudoMetrizableSpace β] (hf : StronglyMeasurable f) {b : β} :\n    SeparableSpace (range f ∪ {b} : Set β) :=\n  letI := pseudoMetrizableSpacePseudoMetric β\n  (hf.isSeparable_range.union (finite_singleton _).isSeparable).separableSpace\n\n"}
{"name":"Measurable.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : SecondCountableTopology β\ninst✝ : OpensMeasurableSpace β\nhf : Measurable f\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- In a space with second countable topology, measurable implies strongly measurable. -/\n@[aesop 90% apply (rule_sets := [Measurable])]\ntheorem _root_.Measurable.stronglyMeasurable [TopologicalSpace β] [PseudoMetrizableSpace β]\n    [SecondCountableTopology β] [OpensMeasurableSpace β] (hf : Measurable f) :\n    StronglyMeasurable f := by\n  letI := pseudoMetrizableSpacePseudoMetric β\n  nontriviality β; inhabit β\n  exact ⟨SimpleFunc.approxOn f hf Set.univ default (Set.mem_univ _), fun x ↦\n    SimpleFunc.tendsto_approxOn hf (Set.mem_univ _) (by rw [closure_univ]; simp)⟩\n\n"}
{"name":"stronglyMeasurable_iff_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.MetrizableSpace β\ninst✝¹ : BorelSpace β\ninst✝ : SecondCountableTopology β\n⊢ Iff (MeasureTheory.StronglyMeasurable f) (Measurable f)","decl":"/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem _root_.stronglyMeasurable_iff_measurable [TopologicalSpace β] [MetrizableSpace β]\n    [BorelSpace β] [SecondCountableTopology β] : StronglyMeasurable f ↔ Measurable f :=\n  ⟨fun h => h.measurable, fun h => Measurable.stronglyMeasurable h⟩\n\n"}
{"name":"stronglyMeasurable_id","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace.PseudoMetrizableSpace α\ninst✝¹ : OpensMeasurableSpace α\ninst✝ : SecondCountableTopology α\n⊢ MeasureTheory.StronglyMeasurable id","decl":"@[measurability]\ntheorem _root_.stronglyMeasurable_id [TopologicalSpace α] [PseudoMetrizableSpace α]\n    [OpensMeasurableSpace α] [SecondCountableTopology α] : StronglyMeasurable (id : α → α) :=\n  measurable_id.stronglyMeasurable\n\n"}
{"name":"stronglyMeasurable_iff_measurable_separable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nm : MeasurableSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\n⊢ Iff (MeasureTheory.StronglyMeasurable f) (And (Measurable f) (TopologicalSpace.IsSeparable (Set.range f)))","decl":"/-- A function is strongly measurable if and only if it is measurable and has separable\nrange. -/\ntheorem _root_.stronglyMeasurable_iff_measurable_separable {m : MeasurableSpace α}\n    [TopologicalSpace β] [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β] :\n    StronglyMeasurable f ↔ Measurable f ∧ IsSeparable (range f) := by\n  refine ⟨fun H ↦ ⟨H.measurable, H.isSeparable_range⟩, fun ⟨Hm, Hsep⟩  ↦ ?_⟩\n  have := Hsep.secondCountableTopology\n  have Hm' : StronglyMeasurable (rangeFactorization f) := Hm.subtype_mk.stronglyMeasurable\n  exact continuous_subtype_val.comp_stronglyMeasurable Hm'\n\n"}
{"name":"Continuous.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : MeasurableSpace α\ninst✝³ : TopologicalSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.PseudoMetrizableSpace β\nh : SecondCountableTopologyEither α β\nf : α → β\nhf : Continuous f\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function is strongly measurable when either the source space or the target space\nis second-countable. -/\ntheorem _root_.Continuous.stronglyMeasurable [MeasurableSpace α] [TopologicalSpace α]\n    [OpensMeasurableSpace α] [TopologicalSpace β] [PseudoMetrizableSpace β]\n    [h : SecondCountableTopologyEither α β] {f : α → β} (hf : Continuous f) :\n    StronglyMeasurable f := by\n  borelize β\n  cases h.out\n  · rw [stronglyMeasurable_iff_measurable_separable]\n    refine ⟨hf.measurable, ?_⟩\n    exact isSeparable_range hf\n  · exact hf.measurable.stronglyMeasurable\n\n"}
{"name":"Continuous.stronglyMeasurable_of_support_subset_isCompact","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : MeasurableSpace α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : OpensMeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : BorelSpace β\ninst✝ : Zero β\nf : α → β\nhf : Continuous f\nk : Set α\nhk : IsCompact k\nh'f : HasSubset.Subset (Function.support f) k\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function whose support is contained in a compact set is strongly measurable. -/\n@[to_additive]\ntheorem _root_.Continuous.stronglyMeasurable_of_mulSupport_subset_isCompact\n    [MeasurableSpace α] [TopologicalSpace α] [OpensMeasurableSpace α] [MeasurableSpace β]\n    [TopologicalSpace β] [PseudoMetrizableSpace β] [BorelSpace β] [One β] {f : α → β}\n    (hf : Continuous f) {k : Set α} (hk : IsCompact k)\n    (h'f : mulSupport f ⊆ k) : StronglyMeasurable f := by\n  letI : PseudoMetricSpace β := pseudoMetrizableSpacePseudoMetric β\n  rw [stronglyMeasurable_iff_measurable_separable]\n  exact ⟨hf.measurable, (isCompact_range_of_mulSupport_subset_isCompact hf hk h'f).isSeparable⟩\n\n"}
{"name":"Continuous.stronglyMeasurable_of_mulSupport_subset_isCompact","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : MeasurableSpace α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : OpensMeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : BorelSpace β\ninst✝ : One β\nf : α → β\nhf : Continuous f\nk : Set α\nhk : IsCompact k\nh'f : HasSubset.Subset (Function.mulSupport f) k\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function whose support is contained in a compact set is strongly measurable. -/\n@[to_additive]\ntheorem _root_.Continuous.stronglyMeasurable_of_mulSupport_subset_isCompact\n    [MeasurableSpace α] [TopologicalSpace α] [OpensMeasurableSpace α] [MeasurableSpace β]\n    [TopologicalSpace β] [PseudoMetrizableSpace β] [BorelSpace β] [One β] {f : α → β}\n    (hf : Continuous f) {k : Set α} (hk : IsCompact k)\n    (h'f : mulSupport f ⊆ k) : StronglyMeasurable f := by\n  letI : PseudoMetricSpace β := pseudoMetrizableSpacePseudoMetric β\n  rw [stronglyMeasurable_iff_measurable_separable]\n  exact ⟨hf.measurable, (isCompact_range_of_mulSupport_subset_isCompact hf hk h'f).isSeparable⟩\n\n"}
{"name":"Continuous.stronglyMeasurable_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : MeasurableSpace α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : OpensMeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : BorelSpace β\ninst✝ : Zero β\nf : α → β\nhf : Continuous f\nh'f : HasCompactSupport f\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function with compact support is strongly measurable. -/\n@[to_additive]\ntheorem _root_.Continuous.stronglyMeasurable_of_hasCompactMulSupport\n    [MeasurableSpace α] [TopologicalSpace α] [OpensMeasurableSpace α] [MeasurableSpace β]\n    [TopologicalSpace β] [PseudoMetrizableSpace β] [BorelSpace β] [One β] {f : α → β}\n    (hf : Continuous f) (h'f : HasCompactMulSupport f) : StronglyMeasurable f :=\n  hf.stronglyMeasurable_of_mulSupport_subset_isCompact h'f (subset_mulTSupport f)\n\n"}
{"name":"Continuous.stronglyMeasurable_of_hasCompactMulSupport","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : MeasurableSpace α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : OpensMeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : BorelSpace β\ninst✝ : One β\nf : α → β\nhf : Continuous f\nh'f : HasCompactMulSupport f\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function with compact support is strongly measurable. -/\n@[to_additive]\ntheorem _root_.Continuous.stronglyMeasurable_of_hasCompactMulSupport\n    [MeasurableSpace α] [TopologicalSpace α] [OpensMeasurableSpace α] [MeasurableSpace β]\n    [TopologicalSpace β] [PseudoMetrizableSpace β] [BorelSpace β] [One β] {f : α → β}\n    (hf : Continuous f) (h'f : HasCompactMulSupport f) : StronglyMeasurable f :=\n  hf.stronglyMeasurable_of_mulSupport_subset_isCompact h'f (subset_mulTSupport f)\n\n"}
{"name":"HasCompactSupport.stronglyMeasurable_of_prod","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nX : Type u_5\nY : Type u_6\ninst✝⁸ : Zero α\ninst✝⁷ : TopologicalSpace X\ninst✝⁶ : TopologicalSpace Y\ninst✝⁵ : MeasurableSpace X\ninst✝⁴ : MeasurableSpace Y\ninst✝³ : OpensMeasurableSpace X\ninst✝² : OpensMeasurableSpace Y\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.PseudoMetrizableSpace α\nf : Prod X Y → α\nhf : Continuous f\nh'f : HasCompactSupport f\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function with compact support on a product space is strongly measurable for the\nproduct sigma-algebra. The subtlety is that we do not assume that the spaces are separable, so the\nproduct of the Borel sigma algebras might not contain all open sets, but still it contains enough\nof them to approximate compactly supported continuous functions. -/\nlemma _root_.HasCompactSupport.stronglyMeasurable_of_prod {X Y : Type*} [Zero α]\n    [TopologicalSpace X] [TopologicalSpace Y] [MeasurableSpace X] [MeasurableSpace Y]\n    [OpensMeasurableSpace X] [OpensMeasurableSpace Y] [TopologicalSpace α] [PseudoMetrizableSpace α]\n    {f : X × Y → α} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    StronglyMeasurable f := by\n  borelize α\n  apply stronglyMeasurable_iff_measurable_separable.2 ⟨h'f.measurable_of_prod hf, ?_⟩\n  letI : PseudoMetricSpace α := pseudoMetrizableSpacePseudoMetric α\n  exact IsCompact.isSeparable (s := range f) (h'f.isCompact_range hf)\n\n"}
{"name":"Embedding.comp_stronglyMeasurable_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : TopologicalSpace γ\ninst✝ : TopologicalSpace.PseudoMetrizableSpace γ\ng : β → γ\nf : α → β\nhg : Topology.IsEmbedding g\n⊢ Iff (MeasureTheory.StronglyMeasurable fun x => g (f x)) (MeasureTheory.StronglyMeasurable f)","decl":"/-- If `g` is a topological embedding, then `f` is strongly measurable iff `g ∘ f` is. -/\ntheorem _root_.Embedding.comp_stronglyMeasurable_iff {m : MeasurableSpace α} [TopologicalSpace β]\n    [PseudoMetrizableSpace β] [TopologicalSpace γ] [PseudoMetrizableSpace γ] {g : β → γ} {f : α → β}\n    (hg : IsEmbedding g) : (StronglyMeasurable fun x => g (f x)) ↔ StronglyMeasurable f := by\n  letI := pseudoMetrizableSpacePseudoMetric γ\n  borelize β γ\n  refine\n    ⟨fun H => stronglyMeasurable_iff_measurable_separable.2 ⟨?_, ?_⟩, fun H =>\n      hg.continuous.comp_stronglyMeasurable H⟩\n  · let G : β → range g := rangeFactorization g\n    have hG : IsClosedEmbedding G :=\n      { hg.codRestrict _ _ with\n        isClosed_range := by\n          rw [surjective_onto_range.range_eq]\n          exact isClosed_univ }\n    have : Measurable (G ∘ f) := Measurable.subtype_mk H.measurable\n    exact hG.measurableEmbedding.measurable_comp_iff.1 this\n  · have : IsSeparable (g ⁻¹' range (g ∘ f)) := hg.isSeparable_preimage H.isSeparable_range\n    rwa [range_comp, hg.injective.preimage_image] at this\n\n"}
{"name":"stronglyMeasurable_of_tendsto","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_5\nm : MeasurableSpace α\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\nu : Filter ι\ninst✝¹ : u.NeBot\ninst✝ : u.IsCountablyGenerated\nf : ι → α → β\ng : α → β\nhf : ∀ (i : ι), MeasureTheory.StronglyMeasurable (f i)\nlim : Filter.Tendsto f u (nhds g)\n⊢ MeasureTheory.StronglyMeasurable g","decl":"/-- A sequential limit of strongly measurable functions is strongly measurable. -/\ntheorem _root_.stronglyMeasurable_of_tendsto {ι : Type*} {m : MeasurableSpace α}\n    [TopologicalSpace β] [PseudoMetrizableSpace β] (u : Filter ι) [NeBot u] [IsCountablyGenerated u]\n    {f : ι → α → β} {g : α → β} (hf : ∀ i, StronglyMeasurable (f i)) (lim : Tendsto f u (𝓝 g)) :\n    StronglyMeasurable g := by\n  borelize β\n  refine stronglyMeasurable_iff_measurable_separable.2 ⟨?_, ?_⟩\n  · exact measurable_of_tendsto_metrizable' u (fun i => (hf i).measurable) lim\n  · rcases u.exists_seq_tendsto with ⟨v, hv⟩\n    have : IsSeparable (closure (⋃ i, range (f (v i)))) :=\n      .closure <| .iUnion fun i => (hf (v i)).isSeparable_range\n    apply this.mono\n    rintro _ ⟨x, rfl⟩\n    rw [tendsto_pi_nhds] at lim\n    apply mem_closure_of_tendsto ((lim x).comp hv)\n    filter_upwards with n\n    apply mem_iUnion_of_mem n\n    exact mem_range_self _\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.piecewise","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nm : MeasurableSpace α\ninst✝ : TopologicalSpace β\ns : Set α\nx✝ : DecidablePred fun x => Membership.mem s x\nhs : MeasurableSet s\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable (s.piecewise f g)","decl":"protected theorem piecewise {m : MeasurableSpace α} [TopologicalSpace β] {s : Set α}\n    {_ : DecidablePred (· ∈ s)} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (Set.piecewise s f g) := by\n  refine ⟨fun n => SimpleFunc.piecewise s hs (hf.approx n) (hg.approx n), fun x => ?_⟩\n  by_cases hx : x ∈ s\n  · simpa [@Set.piecewise_eq_of_mem _ _ _ _ _ (fun _ => Classical.propDecidable _) _ hx,\n      hx] using hf.tendsto_approx x\n  · simpa [@Set.piecewise_eq_of_not_mem _ _ _ _ _ (fun _ => Classical.propDecidable _) _ hx,\n      hx] using hg.tendsto_approx x\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nx✝¹ : MeasurableSpace α\ninst✝ : TopologicalSpace β\np : α → Prop\nx✝ : DecidablePred p\nhp : MeasurableSet (setOf fun a => p a)\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable fun x => ite (p x) (f x) (g x)","decl":"/-- this is slightly different from `StronglyMeasurable.piecewise`. It can be used to show\n`StronglyMeasurable (ite (x=0) 0 1)` by\n`exact StronglyMeasurable.ite (measurableSet_singleton 0) stronglyMeasurable_const\nstronglyMeasurable_const`, but replacing `StronglyMeasurable.ite` by\n`StronglyMeasurable.piecewise` in that example proof does not work. -/\nprotected theorem ite {_ : MeasurableSpace α} [TopologicalSpace β] {p : α → Prop}\n    {_ : DecidablePred p} (hp : MeasurableSet { a : α | p a }) (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg\n\n"}
{"name":"MeasurableEmbedding.stronglyMeasurable_extend","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : α → γ\ng' : γ → β\nmα : MeasurableSpace α\nmγ : MeasurableSpace γ\ninst✝ : TopologicalSpace β\nhg : MeasurableEmbedding g\nhf : MeasureTheory.StronglyMeasurable f\nhg' : MeasureTheory.StronglyMeasurable g'\n⊢ MeasureTheory.StronglyMeasurable (Function.extend g f g')","decl":"@[measurability]\ntheorem _root_.MeasurableEmbedding.stronglyMeasurable_extend {f : α → β} {g : α → γ} {g' : γ → β}\n    {mα : MeasurableSpace α} {mγ : MeasurableSpace γ} [TopologicalSpace β]\n    (hg : MeasurableEmbedding g) (hf : StronglyMeasurable f) (hg' : StronglyMeasurable g') :\n    StronglyMeasurable (Function.extend g f g') := by\n  refine ⟨fun n => SimpleFunc.extend (hf.approx n) g hg (hg'.approx n), ?_⟩\n  intro x\n  by_cases hx : ∃ y, g y = x\n  · rcases hx with ⟨y, rfl⟩\n    simpa only [SimpleFunc.extend_apply, hg.injective, Injective.extend_apply] using\n      hf.tendsto_approx y\n  · simpa only [hx, SimpleFunc.extend_apply', not_false_iff, extend_apply'] using\n      hg'.tendsto_approx x\n\n"}
{"name":"MeasurableEmbedding.exists_stronglyMeasurable_extend","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : α → γ\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace γ\ninst✝ : TopologicalSpace β\nhg : MeasurableEmbedding g\nhf : MeasureTheory.StronglyMeasurable f\nhne : γ → Nonempty β\n⊢ Exists fun f' => And (MeasureTheory.StronglyMeasurable f') (Eq (Function.comp f' g) f)","decl":"theorem _root_.MeasurableEmbedding.exists_stronglyMeasurable_extend {f : α → β} {g : α → γ}\n    {_ : MeasurableSpace α} {_ : MeasurableSpace γ} [TopologicalSpace β]\n    (hg : MeasurableEmbedding g) (hf : StronglyMeasurable f) (hne : γ → Nonempty β) :\n    ∃ f' : γ → β, StronglyMeasurable f' ∧ f' ∘ g = f :=\n  ⟨Function.extend g f fun x => Classical.choice (hne x),\n    hg.stronglyMeasurable_extend hf (stronglyMeasurable_const' fun _ _ => rfl),\n    funext fun _ => hg.injective.extend_apply _ _ _⟩\n\n"}
{"name":"stronglyMeasurable_of_stronglyMeasurable_union_cover","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns t : Set α\nhs : MeasurableSet s\nht : MeasurableSet t\nh : HasSubset.Subset Set.univ (Union.union s t)\nhc : MeasureTheory.StronglyMeasurable fun a => f ↑a\nhd : MeasureTheory.StronglyMeasurable fun a => f ↑a\n⊢ MeasureTheory.StronglyMeasurable f","decl":"theorem _root_.stronglyMeasurable_of_stronglyMeasurable_union_cover {m : MeasurableSpace α}\n    [TopologicalSpace β] {f : α → β} (s t : Set α) (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h : univ ⊆ s ∪ t) (hc : StronglyMeasurable fun a : s => f a)\n    (hd : StronglyMeasurable fun a : t => f a) : StronglyMeasurable f := by\n  nontriviality β; inhabit β\n  suffices Function.extend Subtype.val (fun x : s ↦ f x)\n      (Function.extend (↑) (fun x : t ↦ f x) fun _ ↦ default) = f from\n    this ▸ (MeasurableEmbedding.subtype_coe hs).stronglyMeasurable_extend hc <|\n      (MeasurableEmbedding.subtype_coe ht).stronglyMeasurable_extend hd stronglyMeasurable_const\n  ext x\n  by_cases hxs : x ∈ s\n  · lift x to s using hxs\n    simp [Subtype.coe_injective.extend_apply]\n  · lift x to t using (h trivial).resolve_left hxs\n    rw [extend_apply', Subtype.coe_injective.extend_apply]\n    exact fun ⟨y, hy⟩ ↦ hxs <| hy ▸ y.2\n\n"}
{"name":"stronglyMeasurable_of_restrict_of_restrict_compl","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝ : MeasurableSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns : Set α\nhs : MeasurableSet s\nh₁ : MeasureTheory.StronglyMeasurable (s.restrict f)\nh₂ : MeasureTheory.StronglyMeasurable ((HasCompl.compl s).restrict f)\n⊢ MeasureTheory.StronglyMeasurable f","decl":"theorem _root_.stronglyMeasurable_of_restrict_of_restrict_compl {_ : MeasurableSpace α}\n    [TopologicalSpace β] {f : α → β} {s : Set α} (hs : MeasurableSet s)\n    (h₁ : StronglyMeasurable (s.restrict f)) (h₂ : StronglyMeasurable (sᶜ.restrict f)) :\n    StronglyMeasurable f :=\n  stronglyMeasurable_of_stronglyMeasurable_union_cover s sᶜ hs hs.compl (union_compl_self s).ge h₁\n    h₂\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.indicator","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx✝ : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : Zero β\nhf : MeasureTheory.StronglyMeasurable f\ns : Set α\nhs : MeasurableSet s\n⊢ MeasureTheory.StronglyMeasurable (s.indicator f)","decl":"@[measurability]\nprotected theorem indicator {_ : MeasurableSpace α} [TopologicalSpace β] [Zero β]\n    (hf : StronglyMeasurable f) {s : Set α} (hs : MeasurableSet s) :\n    StronglyMeasurable (s.indicator f) :=\n  hf.piecewise hs stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.dist","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\nβ : Type u_5\ninst✝ : PseudoMetricSpace β\nf g : α → β\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasureTheory.StronglyMeasurable fun x => Dist.dist (f x) (g x)","decl":"@[aesop safe 20 apply (rule_sets := [Measurable])]\nprotected theorem dist {_ : MeasurableSpace α} {β : Type*} [PseudoMetricSpace β] {f g : α → β}\n    (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => dist (f x) (g x) :=\n  continuous_dist.comp_stronglyMeasurable (hf.prod_mk hg)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.norm","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\nβ : Type u_5\ninst✝ : SeminormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => Norm.norm (f x)","decl":"@[measurability]\nprotected theorem norm {_ : MeasurableSpace α} {β : Type*} [SeminormedAddCommGroup β] {f : α → β}\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => ‖f x‖ :=\n  continuous_norm.comp_stronglyMeasurable hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.nnnorm","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\nβ : Type u_5\ninst✝ : SeminormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => NNNorm.nnnorm (f x)","decl":"@[measurability]\nprotected theorem nnnorm {_ : MeasurableSpace α} {β : Type*} [SeminormedAddCommGroup β] {f : α → β}\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => ‖f x‖₊ :=\n  continuous_nnnorm.comp_stronglyMeasurable hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.enorm","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\nβ : Type u_5\ninst✝ : SeminormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Measurable fun x => ENorm.enorm (f x)","decl":"@[measurability]\nprotected theorem enorm {_ : MeasurableSpace α} {β : Type*} [SeminormedAddCommGroup β]\n    {f : α → β} (hf : StronglyMeasurable f) : Measurable (‖f ·‖ₑ) :=\n  (ENNReal.continuous_coe.comp_stronglyMeasurable hf.nnnorm).measurable\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ennnorm","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\nβ : Type u_5\ninst✝ : SeminormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.StronglyMeasurable f\n⊢ Measurable fun x => ENorm.enorm (f x)","decl":"@[deprecated (since := \"2025-01-21\")] alias ennnorm := StronglyMeasurable.enorm\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.real_toNNReal","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\nf : α → Real\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => (f x).toNNReal","decl":"@[measurability]\nprotected theorem real_toNNReal {_ : MeasurableSpace α} {f : α → ℝ} (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun x => (f x).toNNReal :=\n  continuous_real_toNNReal.comp_stronglyMeasurable hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_le","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nE : Type u_5\nm : MeasurableSpace α\nf g : α → E\ninst✝³ : TopologicalSpace E\ninst✝² : Preorder E\ninst✝¹ : OrderClosedTopology E\ninst✝ : TopologicalSpace.PseudoMetrizableSpace E\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasurableSet (setOf fun a => LE.le (f a) (g a))","decl":"lemma measurableSet_le (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    MeasurableSet[m] {a | f a ≤ g a} := by\n  borelize (E × E)\n  exact (hf.prod_mk hg).measurable isClosed_le_prod.measurableSet\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_lt","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nE : Type u_5\nm : MeasurableSpace α\nf g : α → E\ninst✝³ : TopologicalSpace E\ninst✝² : Preorder E\ninst✝¹ : OrderClosedTopology E\ninst✝ : TopologicalSpace.PseudoMetrizableSpace E\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasurableSet (setOf fun a => LT.lt (f a) (g a))","decl":"lemma measurableSet_lt (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    MeasurableSet[m] {a | f a < g a} := by\n  simpa only [lt_iff_le_not_le] using (hf.measurableSet_le hg).inter (hg.measurableSet_le hf).compl\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ae_le_trim_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nE : Type u_5\nm m₀ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → E\ninst✝³ : TopologicalSpace E\ninst✝² : Preorder E\ninst✝¹ : OrderClosedTopology E\ninst✝ : TopologicalSpace.PseudoMetrizableSpace E\nhm : LE.le m m₀\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nhfg : (MeasureTheory.ae μ).EventuallyLE f g\n⊢ (MeasureTheory.ae (μ.trim hm)).EventuallyLE f g","decl":"lemma ae_le_trim_of_stronglyMeasurable (hm : m ≤ m₀) (hf : StronglyMeasurable[m] f)\n    (hg : StronglyMeasurable[m] g) (hfg : f ≤ᵐ[μ] g) : f ≤ᵐ[μ.trim hm] g := by\n  rwa [EventuallyLE, ae_iff, trim_measurableSet_eq hm]\n  exact (hf.measurableSet_le hg).compl\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ae_le_trim_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nE : Type u_5\nm m₀ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → E\ninst✝³ : TopologicalSpace E\ninst✝² : Preorder E\ninst✝¹ : OrderClosedTopology E\ninst✝ : TopologicalSpace.PseudoMetrizableSpace E\nhm : LE.le m m₀\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ Iff ((MeasureTheory.ae (μ.trim hm)).EventuallyLE f g) ((MeasureTheory.ae μ).EventuallyLE f g)","decl":"lemma ae_le_trim_iff (hm : m ≤ m₀) (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    f ≤ᵐ[μ.trim hm] g ↔ f ≤ᵐ[μ] g :=\n  ⟨ae_le_of_ae_le_trim, ae_le_trim_of_stronglyMeasurable hm hf hg⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_eq_fun","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nE : Type u_5\nm : MeasurableSpace α\nf g : α → E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace.MetrizableSpace E\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ MeasurableSet (setOf fun a => Eq (f a) (g a))","decl":"lemma measurableSet_eq_fun (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    MeasurableSet[m] {a | f a = g a} := by\n  borelize (E × E)\n  exact (hf.prod_mk hg).measurable isClosed_diagonal.measurableSet\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ae_eq_trim_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nE : Type u_5\nm m₀ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace.MetrizableSpace E\nhm : LE.le m m₀\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ (MeasureTheory.ae (μ.trim hm)).EventuallyEq f g","decl":"lemma ae_eq_trim_of_stronglyMeasurable (hm : m ≤ m₀) (hf : StronglyMeasurable[m] f)\n    (hg : StronglyMeasurable[m] g) (hfg : f =ᵐ[μ] g) : f =ᵐ[μ.trim hm] g := by\n  rwa [EventuallyEq, ae_iff, trim_measurableSet_eq hm]\n  exact (hf.measurableSet_eq_fun hg).compl\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ae_eq_trim_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nE : Type u_5\nm m₀ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalSpace.MetrizableSpace E\nhm : LE.le m m₀\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\n⊢ Iff ((MeasureTheory.ae (μ.trim hm)).EventuallyEq f g) ((MeasureTheory.ae μ).EventuallyEq f g)","decl":"lemma ae_eq_trim_iff (hm : m ≤ m₀) (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    f =ᵐ[μ.trim hm] g ↔ f =ᵐ[μ] g :=\n  ⟨ae_eq_of_ae_eq_trim, ae_eq_trim_of_stronglyMeasurable hm hf hg⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.stronglyMeasurable_in_set","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : Zero β\ns : Set α\nf : α → β\nhs : MeasurableSet s\nhf : MeasureTheory.StronglyMeasurable f\nhf_zero : ∀ (x : α), Not (Membership.mem s x) → Eq (f x) 0\n⊢ Exists fun fs => And (∀ (x : α), Filter.Tendsto (fun n => (fs n) x) Filter.atTop (nhds (f x))) (∀ (x : α), Not (Membership.mem s x) → ∀ (n : Nat), Eq ((fs n) x) 0)","decl":"theorem stronglyMeasurable_in_set {m : MeasurableSpace α} [TopologicalSpace β] [Zero β] {s : Set α}\n    {f : α → β} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hf_zero : ∀ x, x ∉ s → f x = 0) :\n    ∃ fs : ℕ → α →ₛ β,\n      (∀ x, Tendsto (fun n => fs n x) atTop (𝓝 (f x))) ∧ ∀ x ∉ s, ∀ n, fs n x = 0 := by\n  let g_seq_s : ℕ → @SimpleFunc α m β := fun n => (hf.approx n).restrict s\n  have hg_eq : ∀ x ∈ s, ∀ n, g_seq_s n x = hf.approx n x := by\n    intro x hx n\n    rw [SimpleFunc.coe_restrict _ hs, Set.indicator_of_mem hx]\n  have hg_zero : ∀ x ∉ s, ∀ n, g_seq_s n x = 0 := by\n    intro x hx n\n    rw [SimpleFunc.coe_restrict _ hs, Set.indicator_of_not_mem hx]\n  refine ⟨g_seq_s, fun x => ?_, hg_zero⟩\n  by_cases hx : x ∈ s\n  · simp_rw [hg_eq x hx]\n    exact hf.tendsto_approx x\n  · simp_rw [hg_zero x hx, hf_zero x hx]\n    exact tendsto_const_nhds\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.stronglyMeasurable_of_measurableSpace_le_on","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_5\nE : Type u_6\nm m₂ : MeasurableSpace α\ninst✝¹ : TopologicalSpace E\ninst✝ : Zero E\ns : Set α\nf : α → E\nhs_m : MeasurableSet s\nhs : ∀ (t : Set α), MeasurableSet (Inter.inter s t) → MeasurableSet (Inter.inter s t)\nhf : MeasureTheory.StronglyMeasurable f\nhf_zero : ∀ (x : α), Not (Membership.mem s x) → Eq (f x) 0\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- If the restriction to a set `s` of a σ-algebra `m` is included in the restriction to `s` of\nanother σ-algebra `m₂` (hypothesis `hs`), the set `s` is `m` measurable and a function `f` supported\non `s` is `m`-strongly-measurable, then `f` is also `m₂`-strongly-measurable. -/\ntheorem stronglyMeasurable_of_measurableSpace_le_on {α E} {m m₂ : MeasurableSpace α}\n    [TopologicalSpace E] [Zero E] {s : Set α} {f : α → E} (hs_m : MeasurableSet[m] s)\n    (hs : ∀ t, MeasurableSet[m] (s ∩ t) → MeasurableSet[m₂] (s ∩ t))\n    (hf : StronglyMeasurable[m] f) (hf_zero : ∀ x ∉ s, f x = 0) :\n    StronglyMeasurable[m₂] f := by\n  have hs_m₂ : MeasurableSet[m₂] s := by\n    rw [← Set.inter_univ s]\n    refine hs Set.univ ?_\n    rwa [Set.inter_univ]\n  obtain ⟨g_seq_s, hg_seq_tendsto, hg_seq_zero⟩ := stronglyMeasurable_in_set hs_m hf hf_zero\n  let g_seq_s₂ : ℕ → @SimpleFunc α m₂ E := fun n =>\n    { toFun := g_seq_s n\n      measurableSet_fiber' := fun x => by\n        rw [← Set.inter_univ (g_seq_s n ⁻¹' {x}), ← Set.union_compl_self s,\n          Set.inter_union_distrib_left, Set.inter_comm (g_seq_s n ⁻¹' {x})]\n        refine MeasurableSet.union (hs _ (hs_m.inter ?_)) ?_\n        · exact @SimpleFunc.measurableSet_fiber _ _ m _ _\n        by_cases hx : x = 0\n        · suffices g_seq_s n ⁻¹' {x} ∩ sᶜ = sᶜ by\n            rw [this]\n            exact hs_m₂.compl\n          ext1 y\n          rw [hx, Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n          exact ⟨fun h => h.2, fun h => ⟨hg_seq_zero y h n, h⟩⟩\n        · suffices g_seq_s n ⁻¹' {x} ∩ sᶜ = ∅ by\n            rw [this]\n            exact MeasurableSet.empty\n          ext1 y\n          simp only [mem_inter_iff, mem_preimage, mem_singleton_iff, mem_compl_iff,\n            mem_empty_iff_false, iff_false, not_and, not_not_mem]\n          refine Function.mtr fun hys => ?_\n          rw [hg_seq_zero y hys n]\n          exact Ne.symm hx\n      finite_range' := @SimpleFunc.finite_range _ _ m (g_seq_s n) }\n  exact ⟨g_seq_s₂, hg_seq_tendsto⟩\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.exists_spanning_measurableSet_norm_le","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : SeminormedAddCommGroup β\nm m0 : MeasurableSpace α\nhm : LE.le m m0\nhf : MeasureTheory.StronglyMeasurable f\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\n⊢ Exists fun s => And (∀ (n : Nat), And (MeasurableSet (s n)) (And (LT.lt (μ (s n)) Top.top) (∀ (x : α), Membership.mem (s n) x → LE.le (Norm.norm (f x)) ↑n))) (Eq (Set.iUnion fun i => s i) Set.univ)","decl":"/-- If a function `f` is strongly measurable w.r.t. a sub-σ-algebra `m` and the measure is σ-finite\non `m`, then there exists spanning measurable sets with finite measure on which `f` has bounded\nnorm. In particular, `f` is integrable on each of those sets. -/\ntheorem exists_spanning_measurableSet_norm_le [SeminormedAddCommGroup β] {m m0 : MeasurableSpace α}\n    (hm : m ≤ m0) (hf : StronglyMeasurable[m] f) (μ : Measure α) [SigmaFinite (μ.trim hm)] :\n    ∃ s : ℕ → Set α,\n      (∀ n, MeasurableSet[m] (s n) ∧ μ (s n) < ∞ ∧ ∀ x ∈ s n, ‖f x‖ ≤ n) ∧\n      ⋃ i, s i = Set.univ := by\n  obtain ⟨s, hs, hs_univ⟩ :=\n    @exists_spanning_measurableSet_le _ m _ hf.nnnorm.measurable (μ.trim hm) _\n  refine ⟨s, fun n ↦ ⟨(hs n).1, (le_trim hm).trans_lt (hs n).2.1, fun x hx ↦ ?_⟩, hs_univ⟩\n  have hx_nnnorm : ‖f x‖₊ ≤ n := (hs n).2.2 x hx\n  rw [← coe_nnnorm]\n  norm_cast\n\n"}
{"name":"MeasureTheory.finStronglyMeasurable_zero","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : Zero β\ninst✝ : TopologicalSpace β\n⊢ MeasureTheory.FinStronglyMeasurable 0 μ","decl":"theorem finStronglyMeasurable_zero {α β} {m : MeasurableSpace α} {μ : Measure α} [Zero β]\n    [TopologicalSpace β] : FinStronglyMeasurable (0 : α → β) μ :=\n  ⟨0, by\n    simp only [Pi.zero_apply, SimpleFunc.coe_zero, support_zero', measure_empty,\n      zero_lt_top, forall_const],\n    fun _ => tendsto_const_nhds⟩\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.fin_support_approx","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\ninst✝¹ : Zero β\ninst✝ : TopologicalSpace β\nhf : MeasureTheory.FinStronglyMeasurable f μ\nn : Nat\n⊢ LT.lt (μ (Function.support ⇑(hf.approx n))) Top.top","decl":"protected theorem fin_support_approx : ∀ n, μ (support (hf.approx n)) < ∞ :=\n  hf.choose_spec.1\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.tendsto_approx","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\ninst✝¹ : Zero β\ninst✝ : TopologicalSpace β\nhf : MeasureTheory.FinStronglyMeasurable f μ\nx : α\n⊢ Filter.Tendsto (fun n => (hf.approx n) x) Filter.atTop (nhds (f x))","decl":"protected theorem tendsto_approx : ∀ x, Tendsto (fun n => hf.approx n x) atTop (𝓝 (f x)) :=\n  hf.choose_spec.2\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\ninst✝¹ : Zero β\ninst✝ : TopologicalSpace β\nhf : MeasureTheory.FinStronglyMeasurable f μ\n⊢ MeasureTheory.StronglyMeasurable f","decl":"/-- A finitely strongly measurable function is strongly measurable. -/\n@[aesop 5% apply (rule_sets := [Measurable])]\nprotected theorem stronglyMeasurable [Zero β] [TopologicalSpace β]\n    (hf : FinStronglyMeasurable f μ) : StronglyMeasurable f :=\n  ⟨hf.approx, hf.tendsto_approx⟩\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.exists_set_sigmaFinite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\ninst✝² : Zero β\ninst✝¹ : TopologicalSpace β\ninst✝ : T2Space β\nhf : MeasureTheory.FinStronglyMeasurable f μ\n⊢ Exists fun t => And (MeasurableSet t) (And (∀ (x : α), Membership.mem (HasCompl.compl t) x → Eq (f x) 0) (MeasureTheory.SigmaFinite (μ.restrict t)))","decl":"theorem exists_set_sigmaFinite [Zero β] [TopologicalSpace β] [T2Space β]\n    (hf : FinStronglyMeasurable f μ) :\n    ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) := by\n  rcases hf with ⟨fs, hT_lt_top, h_approx⟩\n  let T n := support (fs n)\n  have hT_meas : ∀ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)\n  let t := ⋃ n, T n\n  refine ⟨t, MeasurableSet.iUnion hT_meas, ?_, ?_⟩\n  · have h_fs_zero : ∀ n, ∀ x ∈ tᶜ, fs n x = 0 := by\n      intro n x hxt\n      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt\n      simpa [T] using hxt n\n    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_\n    rw [funext fun n => h_fs_zero n x hxt]\n    exact tendsto_const_nhds\n  · refine ⟨⟨⟨fun n => tᶜ ∪ T n, fun _ => trivial, fun n => ?_, ?_⟩⟩⟩\n    · rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,\n        Set.compl_inter_self t, Set.empty_union]\n      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)\n    · rw [← Set.union_iUnion tᶜ T]\n      exact Set.compl_union_self _\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\ninst✝⁴ : Zero β\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nhf : MeasureTheory.FinStronglyMeasurable f μ\n⊢ Measurable f","decl":"/-- A finitely strongly measurable function is measurable. -/\nprotected theorem measurable [Zero β] [TopologicalSpace β] [PseudoMetrizableSpace β]\n    [MeasurableSpace β] [BorelSpace β] (hf : FinStronglyMeasurable f μ) : Measurable f :=\n  hf.stronglyMeasurable.measurable\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.mul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : MonoidWithZero β\ninst✝ : ContinuousMul β\nhf : MeasureTheory.FinStronglyMeasurable f μ\nhg : MeasureTheory.FinStronglyMeasurable g μ\n⊢ MeasureTheory.FinStronglyMeasurable (HMul.hMul f g) μ","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem mul [MonoidWithZero β] [ContinuousMul β] (hf : FinStronglyMeasurable f μ)\n    (hg : FinStronglyMeasurable g μ) : FinStronglyMeasurable (f * g) μ := by\n  refine\n    ⟨fun n => hf.approx n * hg.approx n, ?_, fun x =>\n      (hf.tendsto_approx x).mul (hg.tendsto_approx x)⟩\n  intro n\n  exact (measure_mono (support_mul_subset_left _ _)).trans_lt (hf.fin_support_approx n)\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.add","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : AddMonoid β\ninst✝ : ContinuousAdd β\nhf : MeasureTheory.FinStronglyMeasurable f μ\nhg : MeasureTheory.FinStronglyMeasurable g μ\n⊢ MeasureTheory.FinStronglyMeasurable (HAdd.hAdd f g) μ","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem add [AddMonoid β] [ContinuousAdd β] (hf : FinStronglyMeasurable f μ)\n    (hg : FinStronglyMeasurable g μ) : FinStronglyMeasurable (f + g) μ :=\n  ⟨fun n => hf.approx n + hg.approx n, fun n =>\n    (measure_mono (Function.support_add _ _)).trans_lt\n      ((measure_union_le _ _).trans_lt\n        (ENNReal.add_lt_top.mpr ⟨hf.fin_support_approx n, hg.fin_support_approx n⟩)),\n    fun x => (hf.tendsto_approx x).add (hg.tendsto_approx x)⟩\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.neg","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : AddGroup β\ninst✝ : TopologicalAddGroup β\nhf : MeasureTheory.FinStronglyMeasurable f μ\n⊢ MeasureTheory.FinStronglyMeasurable (Neg.neg f) μ","decl":"@[measurability]\nprotected theorem neg [AddGroup β] [TopologicalAddGroup β] (hf : FinStronglyMeasurable f μ) :\n    FinStronglyMeasurable (-f) μ := by\n  refine ⟨fun n => -hf.approx n, fun n => ?_, fun x => (hf.tendsto_approx x).neg⟩\n  suffices μ (Function.support fun x => -(hf.approx n) x) < ∞ by convert this\n  rw [Function.support_neg (hf.approx n)]\n  exact hf.fin_support_approx n\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.sub","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : AddGroup β\ninst✝ : ContinuousSub β\nhf : MeasureTheory.FinStronglyMeasurable f μ\nhg : MeasureTheory.FinStronglyMeasurable g μ\n⊢ MeasureTheory.FinStronglyMeasurable (HSub.hSub f g) μ","decl":"@[measurability]\nprotected theorem sub [AddGroup β] [ContinuousSub β] (hf : FinStronglyMeasurable f μ)\n    (hg : FinStronglyMeasurable g μ) : FinStronglyMeasurable (f - g) μ :=\n  ⟨fun n => hf.approx n - hg.approx n, fun n =>\n    (measure_mono (Function.support_sub _ _)).trans_lt\n      ((measure_union_le _ _).trans_lt\n        (ENNReal.add_lt_top.mpr ⟨hf.fin_support_approx n, hg.fin_support_approx n⟩)),\n    fun x => (hf.tendsto_approx x).sub (hg.tendsto_approx x)⟩\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.const_smul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\ninst✝⁵ : TopologicalSpace β\n𝕜 : Type u_5\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : AddMonoid β\ninst✝² : Monoid 𝕜\ninst✝¹ : DistribMulAction 𝕜 β\ninst✝ : ContinuousSMul 𝕜 β\nhf : MeasureTheory.FinStronglyMeasurable f μ\nc : 𝕜\n⊢ MeasureTheory.FinStronglyMeasurable (HSMul.hSMul c f) μ","decl":"@[measurability]\nprotected theorem const_smul {𝕜} [TopologicalSpace 𝕜] [AddMonoid β] [Monoid 𝕜]\n    [DistribMulAction 𝕜 β] [ContinuousSMul 𝕜 β] (hf : FinStronglyMeasurable f μ) (c : 𝕜) :\n    FinStronglyMeasurable (c • f) μ := by\n  refine ⟨fun n => c • hf.approx n, fun n => ?_, fun x => (hf.tendsto_approx x).const_smul c⟩\n  rw [SimpleFunc.coe_smul]\n  exact (measure_mono (support_const_smul_subset c _)).trans_lt (hf.fin_support_approx n)\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.sup","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → β\ninst✝³ : TopologicalSpace β\ninst✝² : Zero β\ninst✝¹ : SemilatticeSup β\ninst✝ : ContinuousSup β\nhf : MeasureTheory.FinStronglyMeasurable f μ\nhg : MeasureTheory.FinStronglyMeasurable g μ\n⊢ MeasureTheory.FinStronglyMeasurable (Max.max f g) μ","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem sup [SemilatticeSup β] [ContinuousSup β] (hf : FinStronglyMeasurable f μ)\n    (hg : FinStronglyMeasurable g μ) : FinStronglyMeasurable (f ⊔ g) μ := by\n  refine\n    ⟨fun n => hf.approx n ⊔ hg.approx n, fun n => ?_, fun x =>\n      (hf.tendsto_approx x).sup_nhds (hg.tendsto_approx x)⟩\n  refine (measure_mono (support_sup _ _)).trans_lt ?_\n  exact measure_union_lt_top_iff.mpr ⟨hf.fin_support_approx n, hg.fin_support_approx n⟩\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.inf","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → β\ninst✝³ : TopologicalSpace β\ninst✝² : Zero β\ninst✝¹ : SemilatticeInf β\ninst✝ : ContinuousInf β\nhf : MeasureTheory.FinStronglyMeasurable f μ\nhg : MeasureTheory.FinStronglyMeasurable g μ\n⊢ MeasureTheory.FinStronglyMeasurable (Min.min f g) μ","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem inf [SemilatticeInf β] [ContinuousInf β] (hf : FinStronglyMeasurable f μ)\n    (hg : FinStronglyMeasurable g μ) : FinStronglyMeasurable (f ⊓ g) μ := by\n  refine\n    ⟨fun n => hf.approx n ⊓ hg.approx n, fun n => ?_, fun x =>\n      (hf.tendsto_approx x).inf_nhds (hg.tendsto_approx x)⟩\n  refine (measure_mono (support_inf _ _)).trans_lt ?_\n  exact measure_union_lt_top_iff.mpr ⟨hf.fin_support_approx n, hg.fin_support_approx n⟩\n\n"}
{"name":"MeasureTheory.finStronglyMeasurable_iff_stronglyMeasurable_and_exists_set_sigmaFinite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nf : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : T2Space β\ninst✝ : Zero β\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (MeasureTheory.FinStronglyMeasurable f μ) (And (MeasureTheory.StronglyMeasurable f) (Exists fun t => And (MeasurableSet t) (And (∀ (x : α), Membership.mem (HasCompl.compl t) x → Eq (f x) 0) (MeasureTheory.SigmaFinite (μ.restrict t)))))","decl":"theorem finStronglyMeasurable_iff_stronglyMeasurable_and_exists_set_sigmaFinite {α β} {f : α → β}\n    [TopologicalSpace β] [T2Space β] [Zero β] {_ : MeasurableSpace α} {μ : Measure α} :\n    FinStronglyMeasurable f μ ↔\n      StronglyMeasurable f ∧\n        ∃ t, MeasurableSet t ∧ (∀ x ∈ tᶜ, f x = 0) ∧ SigmaFinite (μ.restrict t) :=\n  ⟨fun hf => ⟨hf.stronglyMeasurable, hf.exists_set_sigmaFinite⟩, fun hf =>\n    hf.1.finStronglyMeasurable_of_set_sigmaFinite hf.2.choose_spec.1 hf.2.choose_spec.2.1\n      hf.2.choose_spec.2.2⟩\n\n"}
{"name":"MeasureTheory.finStronglyMeasurable_iff_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : MeasurableSpace G\ninst✝² : BorelSpace G\ninst✝¹ : SecondCountableTopology G\nf : α → G\n_m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ Iff (MeasureTheory.FinStronglyMeasurable f μ) (Measurable f)","decl":"/-- In a space with second countable topology and a sigma-finite measure, `FinStronglyMeasurable`\n  and `Measurable` are equivalent. -/\ntheorem finStronglyMeasurable_iff_measurable {_m0 : MeasurableSpace α} (μ : Measure α)\n    [SigmaFinite μ] : FinStronglyMeasurable f μ ↔ Measurable f :=\n  ⟨fun h => h.measurable, fun h => (Measurable.stronglyMeasurable h).finStronglyMeasurable μ⟩\n\n"}
{"name":"MeasureTheory.finStronglyMeasurable_of_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_1\nG : Type u_5\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : MeasurableSpace G\ninst✝² : BorelSpace G\ninst✝¹ : SecondCountableTopology G\nf : α → G\n_m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nhf : Measurable f\n⊢ MeasureTheory.FinStronglyMeasurable f μ","decl":"/-- In a space with second countable topology and a sigma-finite measure, a measurable function\nis `FinStronglyMeasurable`. -/\n@[aesop 90% apply (rule_sets := [Measurable])]\ntheorem finStronglyMeasurable_of_measurable {_m0 : MeasurableSpace α} (μ : Measure α)\n    [SigmaFinite μ] (hf : Measurable f) : FinStronglyMeasurable f μ :=\n  (finStronglyMeasurable_iff_measurable μ).mpr hf\n\n"}
{"name":"MeasureTheory.measurable_uncurry_of_continuous_of_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nι : Type u_7\ninst✝⁷ : TopologicalSpace ι\ninst✝⁶ : TopologicalSpace.MetrizableSpace ι\ninst✝⁵ : MeasurableSpace ι\ninst✝⁴ : SecondCountableTopology ι\ninst✝³ : OpensMeasurableSpace ι\nmβ : MeasurableSpace β\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace.PseudoMetrizableSpace β\ninst✝ : BorelSpace β\nm : MeasurableSpace α\nu : ι → α → β\nhu_cont : ∀ (x : α), Continuous fun i => u i x\nh : ∀ (i : ι), Measurable (u i)\n⊢ Measurable (Function.uncurry u)","decl":"theorem measurable_uncurry_of_continuous_of_measurable {α β ι : Type*} [TopologicalSpace ι]\n    [MetrizableSpace ι] [MeasurableSpace ι] [SecondCountableTopology ι] [OpensMeasurableSpace ι]\n    {mβ : MeasurableSpace β} [TopologicalSpace β] [PseudoMetrizableSpace β] [BorelSpace β]\n    {m : MeasurableSpace α} {u : ι → α → β} (hu_cont : ∀ x, Continuous fun i => u i x)\n    (h : ∀ i, Measurable (u i)) : Measurable (Function.uncurry u) := by\n  obtain ⟨t_sf, ht_sf⟩ :\n    ∃ t : ℕ → SimpleFunc ι ι, ∀ j x, Tendsto (fun n => u (t n j) x) atTop (𝓝 <| u j x) := by\n    have h_str_meas : StronglyMeasurable (id : ι → ι) := stronglyMeasurable_id\n    refine ⟨h_str_meas.approx, fun j x => ?_⟩\n    exact ((hu_cont x).tendsto j).comp (h_str_meas.tendsto_approx j)\n  let U (n : ℕ) (p : ι × α) := u (t_sf n p.fst) p.snd\n  have h_tendsto : Tendsto U atTop (𝓝 fun p => u p.fst p.snd) := by\n    rw [tendsto_pi_nhds]\n    exact fun p => ht_sf p.fst p.snd\n  refine measurable_of_tendsto_metrizable (fun n => ?_) h_tendsto\n  have h_meas : Measurable fun p : (t_sf n).range × α => u (↑p.fst) p.snd := by\n    have :\n      (fun p : ↥(t_sf n).range × α => u (↑p.fst) p.snd) =\n        (fun p : α × (t_sf n).range => u (↑p.snd) p.fst) ∘ Prod.swap :=\n      rfl\n    rw [this, @measurable_swap_iff α (↥(t_sf n).range) β m]\n    exact measurable_from_prod_countable fun j => h j\n  have :\n    (fun p : ι × α => u (t_sf n p.fst) p.snd) =\n      (fun p : ↥(t_sf n).range × α => u p.fst p.snd) ∘ fun p : ι × α =>\n        (⟨t_sf n p.fst, SimpleFunc.mem_range_self _ _⟩, p.snd) :=\n    rfl\n  simp_rw [U, this]\n  refine h_meas.comp (Measurable.prod_mk ?_ measurable_snd)\n  exact ((t_sf n).measurable.comp measurable_fst).subtype_mk\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_uncurry_of_continuous_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"α : Type u_5\nβ : Type u_6\nι : Type u_7\ninst✝⁷ : TopologicalSpace ι\ninst✝⁶ : TopologicalSpace.MetrizableSpace ι\ninst✝⁵ : MeasurableSpace ι\ninst✝⁴ : SecondCountableTopology ι\ninst✝³ : OpensMeasurableSpace ι\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace.PseudoMetrizableSpace β\ninst✝ : MeasurableSpace α\nu : ι → α → β\nhu_cont : ∀ (x : α), Continuous fun i => u i x\nh : ∀ (i : ι), MeasureTheory.StronglyMeasurable (u i)\n⊢ MeasureTheory.StronglyMeasurable (Function.uncurry u)","decl":"theorem stronglyMeasurable_uncurry_of_continuous_of_stronglyMeasurable {α β ι : Type*}\n    [TopologicalSpace ι] [MetrizableSpace ι] [MeasurableSpace ι] [SecondCountableTopology ι]\n    [OpensMeasurableSpace ι] [TopologicalSpace β] [PseudoMetrizableSpace β] [MeasurableSpace α]\n    {u : ι → α → β} (hu_cont : ∀ x, Continuous fun i => u i x) (h : ∀ i, StronglyMeasurable (u i)) :\n    StronglyMeasurable (Function.uncurry u) := by\n  borelize β\n  obtain ⟨t_sf, ht_sf⟩ :\n    ∃ t : ℕ → SimpleFunc ι ι, ∀ j x, Tendsto (fun n => u (t n j) x) atTop (𝓝 <| u j x) := by\n    have h_str_meas : StronglyMeasurable (id : ι → ι) := stronglyMeasurable_id\n    refine ⟨h_str_meas.approx, fun j x => ?_⟩\n    exact ((hu_cont x).tendsto j).comp (h_str_meas.tendsto_approx j)\n  let U (n : ℕ) (p : ι × α) := u (t_sf n p.fst) p.snd\n  have h_tendsto : Tendsto U atTop (𝓝 fun p => u p.fst p.snd) := by\n    rw [tendsto_pi_nhds]\n    exact fun p => ht_sf p.fst p.snd\n  refine stronglyMeasurable_of_tendsto _ (fun n => ?_) h_tendsto\n  have h_str_meas : StronglyMeasurable fun p : (t_sf n).range × α => u (↑p.fst) p.snd := by\n    refine stronglyMeasurable_iff_measurable_separable.2 ⟨?_, ?_⟩\n    · have :\n        (fun p : ↥(t_sf n).range × α => u (↑p.fst) p.snd) =\n          (fun p : α × (t_sf n).range => u (↑p.snd) p.fst) ∘ Prod.swap :=\n        rfl\n      rw [this, measurable_swap_iff]\n      exact measurable_from_prod_countable fun j => (h j).measurable\n    · have : IsSeparable (⋃ i : (t_sf n).range, range (u i)) :=\n        .iUnion fun i => (h i).isSeparable_range\n      apply this.mono\n      rintro _ ⟨⟨i, x⟩, rfl⟩\n      simp only [mem_iUnion, mem_range]\n      exact ⟨i, x, rfl⟩\n  have :\n    (fun p : ι × α => u (t_sf n p.fst) p.snd) =\n      (fun p : ↥(t_sf n).range × α => u p.fst p.snd) ∘ fun p : ι × α =>\n        (⟨t_sf n p.fst, SimpleFunc.mem_range_self _ _⟩, p.snd) :=\n    rfl\n  simp_rw [U, this]\n  refine h_str_meas.comp_measurable (Measurable.prod_mk ?_ measurable_snd)\n  exact ((t_sf n).measurable.comp measurable_fst).subtype_mk\n\n"}
