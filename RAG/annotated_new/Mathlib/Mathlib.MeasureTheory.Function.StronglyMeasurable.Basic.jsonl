{"name":"MeasureTheory.Subsingleton.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nxâœ : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : Subsingleton Î²\nf : Î± â†’ Î²\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"@[simp]\ntheorem Subsingleton.stronglyMeasurable [Subsingleton Î²] (f : Î± â†’ Î²) : StronglyMeasurable f := by\n  let f_sf : Î± â†’â‚› Î² := âŸ¨f, fun x => ?_, Set.Subsingleton.finite Set.subsingleton_of_subsingletonâŸ©\n  Â· exact âŸ¨fun _ => f_sf, fun x => tendsto_const_nhdsâŸ©\n  Â· have h_univ : f â»Â¹' {x} = Set.univ := by\n      ext1 y\n      simp [eq_iff_true_of_subsingleton]\n    rw [h_univ]\n    exact MeasurableSet.univ\n\n"}
{"name":"MeasureTheory.SimpleFunc.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nxâœ : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\nf : MeasureTheory.SimpleFunc Î± Î²\nâŠ¢ MeasureTheory.StronglyMeasurable â‡‘f","decl":"theorem SimpleFunc.stronglyMeasurable (f : Î± â†’â‚› Î²) : StronglyMeasurable f :=\n  âŸ¨fun _ => f, fun _ => tendsto_const_nhdsâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.of_finite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nxâœ : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Finite Î±\ninstâœ : MeasurableSingletonClass Î±\nf : Î± â†’ Î²\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"@[nontriviality]\ntheorem StronglyMeasurable.of_finite [Finite Î±] [MeasurableSingletonClass Î±]\n    {f : Î± â†’ Î²} : StronglyMeasurable f :=\n  âŸ¨fun _ => SimpleFunc.ofFinite f, fun _ => tendsto_const_nhdsâŸ©\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nxâœ : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\nb : Î²\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => b","decl":"theorem stronglyMeasurable_const {b : Î²} : StronglyMeasurable fun _ : Î± => b :=\n  âŸ¨fun _ => SimpleFunc.const Î± b, fun _ => tendsto_const_nhdsâŸ©\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_one","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nxâœ : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : One Î²\nâŠ¢ MeasureTheory.StronglyMeasurable 1","decl":"@[to_additive]\ntheorem stronglyMeasurable_one [One Î²] : StronglyMeasurable (1 : Î± â†’ Î²) := stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_zero","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nxâœ : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : Zero Î²\nâŠ¢ MeasureTheory.StronglyMeasurable 0","decl":"@[to_additive]\ntheorem stronglyMeasurable_one [One Î²] : StronglyMeasurable (1 : Î± â†’ Î²) := stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_const'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nxâœ : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\nhf : âˆ€ (x y : Î±), Eq (f x) (f y)\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- A version of `stronglyMeasurable_const` that assumes `f x = f y` for all `x, y`.\nThis version works for functions between empty types. -/\ntheorem stronglyMeasurable_const' (hf : âˆ€ x y, f x = f y) : StronglyMeasurable f := by\n  nontriviality Î±\n  inhabit Î±\n  convert stronglyMeasurable_const (Î² := Î²) using 1\n  exact funext fun x => hf x default\n\n-- Porting note: changed binding type of `MeasurableSpace Î±`.\n"}
{"name":"MeasureTheory.Subsingleton.stronglyMeasurable'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nxâœ : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : Subsingleton Î±\nf : Î± â†’ Î²\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"@[simp]\ntheorem Subsingleton.stronglyMeasurable' [Subsingleton Î±] (f : Î± â†’ Î²) : StronglyMeasurable f :=\n  stronglyMeasurable_const' fun x y => by rw [Subsingleton.elim x y]\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.tendsto_approx","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ninstâœ : TopologicalSpace Î²\nxâœ : MeasurableSpace Î±\nhf : MeasureTheory.StronglyMeasurable f\nx : Î±\nâŠ¢ Filter.Tendsto (fun n => (hf.approx n) x) Filter.atTop (nhds (f x))","decl":"protected theorem tendsto_approx {_ : MeasurableSpace Î±} (hf : StronglyMeasurable f) :\n    âˆ€ x, Tendsto (fun n => hf.approx n x) atTop (ğ“ (f x)) :=\n  hf.choose_spec\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.tendsto_approxBounded_of_norm_le","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_5\nf : Î± â†’ Î²\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedSpace Real Î²\nm : MeasurableSpace Î±\nhf : MeasureTheory.StronglyMeasurable f\nc : Real\nx : Î±\nhfx : LE.le (Norm.norm (f x)) c\nâŠ¢ Filter.Tendsto (fun n => (hf.approxBounded c n) x) Filter.atTop (nhds (f x))","decl":"theorem tendsto_approxBounded_of_norm_le {Î²} {f : Î± â†’ Î²} [NormedAddCommGroup Î²] [NormedSpace â„ Î²]\n    {m : MeasurableSpace Î±} (hf : StronglyMeasurable[m] f) {c : â„} {x : Î±} (hfx : â€–f xâ€– â‰¤ c) :\n    Tendsto (fun n => hf.approxBounded c n x) atTop (ğ“ (f x)) := by\n  have h_tendsto := hf.tendsto_approx x\n  simp only [StronglyMeasurable.approxBounded, SimpleFunc.coe_map, Function.comp_apply]\n  by_cases hfx0 : â€–f xâ€– = 0\n  Â· rw [norm_eq_zero] at hfx0\n    rw [hfx0] at h_tendsto âŠ¢\n    have h_tendsto_norm : Tendsto (fun n => â€–hf.approx n xâ€–) atTop (ğ“ 0) := by\n      convert h_tendsto.norm\n      rw [norm_zero]\n    refine squeeze_zero_norm (fun n => ?_) h_tendsto_norm\n    calc\n      â€–min 1 (c / â€–hf.approx n xâ€–) â€¢ hf.approx n xâ€– =\n          â€–min 1 (c / â€–hf.approx n xâ€–)â€– * â€–hf.approx n xâ€– :=\n        norm_smul _ _\n      _ â‰¤ â€–(1 : â„)â€– * â€–hf.approx n xâ€– := by\n        refine mul_le_mul_of_nonneg_right ?_ (norm_nonneg _)\n        rw [norm_one, Real.norm_of_nonneg]\n        Â· exact min_le_left _ _\n        Â· exact le_min zero_le_one (div_nonneg ((norm_nonneg _).trans hfx) (norm_nonneg _))\n      _ = â€–hf.approx n xâ€– := by rw [norm_one, one_mul]\n  rw [â† one_smul â„ (f x)]\n  refine Tendsto.smul ?_ h_tendsto\n  have : min 1 (c / â€–f xâ€–) = 1 := by\n    rw [min_eq_left_iff, one_le_div (lt_of_le_of_ne (norm_nonneg _) (Ne.symm hfx0))]\n    exact hfx\n  nth_rw 2 [this.symm]\n  refine Tendsto.min tendsto_const_nhds ?_\n  exact Tendsto.div tendsto_const_nhds h_tendsto.norm hfx0\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.tendsto_approxBounded_ae","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_5\nf : Î± â†’ Î²\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedSpace Real Î²\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhf : MeasureTheory.StronglyMeasurable f\nc : Real\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun n => (hf.approxBounded c n) x) Filter.atTop (nhds (f x))) (MeasureTheory.ae Î¼)","decl":"theorem tendsto_approxBounded_ae {Î²} {f : Î± â†’ Î²} [NormedAddCommGroup Î²] [NormedSpace â„ Î²]\n    {m m0 : MeasurableSpace Î±} {Î¼ : Measure Î±} (hf : StronglyMeasurable[m] f) {c : â„}\n    (hf_bound : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ c) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => hf.approxBounded c n x) atTop (ğ“ (f x)) := by\n  filter_upwards [hf_bound] with x hfx using tendsto_approxBounded_of_norm_le hf hfx\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.norm_approxBounded_le","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_5\nf : Î± â†’ Î²\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : NormedSpace Real Î²\nm : MeasurableSpace Î±\nc : Real\nhf : MeasureTheory.StronglyMeasurable f\nhc : LE.le 0 c\nn : Nat\nx : Î±\nâŠ¢ LE.le (Norm.norm ((hf.approxBounded c n) x)) c","decl":"theorem norm_approxBounded_le {Î²} {f : Î± â†’ Î²} [SeminormedAddCommGroup Î²] [NormedSpace â„ Î²]\n    {m : MeasurableSpace Î±} {c : â„} (hf : StronglyMeasurable[m] f) (hc : 0 â‰¤ c) (n : â„•) (x : Î±) :\n    â€–hf.approxBounded c n xâ€– â‰¤ c := by\n  simp only [StronglyMeasurable.approxBounded, SimpleFunc.coe_map, Function.comp_apply]\n  refine (norm_smul_le _ _).trans ?_\n  by_cases h0 : â€–hf.approx n xâ€– = 0\n  Â· simp only [h0, _root_.div_zero, min_eq_right, zero_le_one, norm_zero, mul_zero]\n    exact hc\n  rcases le_total â€–hf.approx n xâ€– c with h | h\n  Â· rw [min_eq_left _]\n    Â· simpa only [norm_one, one_mul] using h\n    Â· rwa [one_le_div (lt_of_le_of_ne (norm_nonneg _) (Ne.symm h0))]\n  Â· rw [min_eq_right _]\n    Â· rw [norm_div, norm_norm, mul_comm, mul_div, div_eq_mul_inv, mul_comm, â† mul_assoc,\n        inv_mul_cancelâ‚€ h0, one_mul, Real.norm_of_nonneg hc]\n    Â· rwa [div_le_one (lt_of_le_of_ne (norm_nonneg _) (Ne.symm h0))]\n\n"}
{"name":"stronglyMeasurable_bot_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Nonempty Î²\ninstâœ : T2Space Î²\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable f) (Exists fun c => Eq f fun x => c)","decl":"theorem _root_.stronglyMeasurable_bot_iff [Nonempty Î²] [T2Space Î²] :\n    StronglyMeasurable[âŠ¥] f â†” âˆƒ c, f = fun _ => c := by\n  cases' isEmpty_or_nonempty Î± with hÎ± hÎ±\n  Â· simp only [@Subsingleton.stronglyMeasurable' _ _ âŠ¥ _ _ f,\n      eq_iff_true_of_subsingleton, exists_const]\n  refine âŸ¨fun hf => ?_, fun hf_eq => ?_âŸ©\n  Â· refine âŸ¨f hÎ±.some, ?_âŸ©\n    let fs := hf.approx\n    have h_fs_tendsto : âˆ€ x, Tendsto (fun n => fs n x) atTop (ğ“ (f x)) := hf.tendsto_approx\n    have : âˆ€ n, âˆƒ c, âˆ€ x, fs n x = c := fun n => SimpleFunc.simpleFunc_bot (fs n)\n    let cs n := (this n).choose\n    have h_cs_eq : âˆ€ n, â‡‘(fs n) = fun _ => cs n := fun n => funext (this n).choose_spec\n    conv at h_fs_tendsto => enter [x, 1, n]; rw [h_cs_eq]\n    have h_tendsto : Tendsto cs atTop (ğ“ (f hÎ±.some)) := h_fs_tendsto hÎ±.some\n    ext1 x\n    exact tendsto_nhds_unique (h_fs_tendsto x) h_tendsto\n  Â· obtain âŸ¨c, rflâŸ© := hf_eq\n    exact stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.finStronglyMeasurable_of_set_sigmaFinite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : Zero Î²\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nhf_meas : MeasureTheory.StronglyMeasurable f\nt : Set Î±\nht : MeasurableSet t\nhft_zero : âˆ€ (x : Î±), Membership.mem (HasCompl.compl t) x â†’ Eq (f x) 0\nhtÎ¼ : MeasureTheory.SigmaFinite (Î¼.restrict t)\nâŠ¢ MeasureTheory.FinStronglyMeasurable f Î¼","decl":"theorem finStronglyMeasurable_of_set_sigmaFinite [TopologicalSpace Î²] [Zero Î²]\n    {m : MeasurableSpace Î±} {Î¼ : Measure Î±} (hf_meas : StronglyMeasurable f) {t : Set Î±}\n    (ht : MeasurableSet t) (hft_zero : âˆ€ x âˆˆ tá¶œ, f x = 0) (htÎ¼ : SigmaFinite (Î¼.restrict t)) :\n    FinStronglyMeasurable f Î¼ := by\n  haveI : SigmaFinite (Î¼.restrict t) := htÎ¼\n  let S := spanningSets (Î¼.restrict t)\n  have hS_meas : âˆ€ n, MeasurableSet (S n) := measurableSet_spanningSets (Î¼.restrict t)\n  let f_approx := hf_meas.approx\n  let fs n := SimpleFunc.restrict (f_approx n) (S n âˆ© t)\n  have h_fs_t_compl : âˆ€ n, âˆ€ x, x âˆ‰ t â†’ fs n x = 0 := by\n    intro n x hxt\n    rw [SimpleFunc.restrict_apply _ ((hS_meas n).inter ht)]\n    refine Set.indicator_of_not_mem ?_ _\n    simp [hxt]\n  refine âŸ¨fs, ?_, fun x => ?_âŸ©\n  Â· simp_rw [SimpleFunc.support_eq, â† Finset.mem_coe]\n    classical\n    refine fun n => measure_biUnion_lt_top {y âˆˆ (fs n).range | y â‰  0}.finite_toSet fun y hy => ?_\n    rw [SimpleFunc.restrict_preimage_singleton _ ((hS_meas n).inter ht)]\n    swap\n    Â· letI : (y : Î²) â†’ Decidable (y = 0) := fun y => Classical.propDecidable _\n      rw [Finset.mem_coe, Finset.mem_filter] at hy\n      exact hy.2\n    refine (measure_mono Set.inter_subset_left).trans_lt ?_\n    have h_lt_top := measure_spanningSets_lt_top (Î¼.restrict t) n\n    rwa [Measure.restrict_apply' ht] at h_lt_top\n  Â· by_cases hxt : x âˆˆ t\n    swap\n    Â· rw [funext fun n => h_fs_t_compl n x hxt, hft_zero x hxt]\n      exact tendsto_const_nhds\n    have h : Tendsto (fun n => (f_approx n) x) atTop (ğ“ (f x)) := hf_meas.tendsto_approx x\n    obtain âŸ¨nâ‚, hnâ‚âŸ© : âˆƒ n, âˆ€ m, n â‰¤ m â†’ fs m x = f_approx m x := by\n      obtain âŸ¨n, hnâŸ© : âˆƒ n, âˆ€ m, n â‰¤ m â†’ x âˆˆ S m âˆ© t := by\n        rsuffices âŸ¨n, hnâŸ© : âˆƒ n, âˆ€ m, n â‰¤ m â†’ x âˆˆ S m\n        Â· exact âŸ¨n, fun m hnm => Set.mem_inter (hn m hnm) hxtâŸ©\n        rsuffices âŸ¨n, hnâŸ© : âˆƒ n, x âˆˆ S n\n        Â· exact âŸ¨n, fun m hnm => monotone_spanningSets (Î¼.restrict t) hnm hnâŸ©\n        rw [â† Set.mem_iUnion, iUnion_spanningSets (Î¼.restrict t)]\n        trivial\n      refine âŸ¨n, fun m hnm => ?_âŸ©\n      simp_rw [fs, SimpleFunc.restrict_apply _ ((hS_meas m).inter ht),\n        Set.indicator_of_mem (hn m hnm)]\n    rw [tendsto_atTop'] at h âŠ¢\n    intro s hs\n    obtain âŸ¨nâ‚‚, hnâ‚‚âŸ© := h s hs\n    refine âŸ¨max nâ‚ nâ‚‚, fun m hm => ?_âŸ©\n    rw [hnâ‚ m ((le_max_left _ _).trans hm.le)]\n    exact hnâ‚‚ m ((le_max_right _ _).trans hm.le)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.finStronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Zero Î²\nm0 : MeasurableSpace Î±\nhf : MeasureTheory.StronglyMeasurable f\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nâŠ¢ MeasureTheory.FinStronglyMeasurable f Î¼","decl":"/-- If the measure is sigma-finite, all strongly measurable functions are\n  `FinStronglyMeasurable`. -/\n@[aesop 5% apply (rule_sets := [Measurable])]\nprotected theorem finStronglyMeasurable [TopologicalSpace Î²] [Zero Î²] {m0 : MeasurableSpace Î±}\n    (hf : StronglyMeasurable f) (Î¼ : Measure Î±) [SigmaFinite Î¼] : FinStronglyMeasurable f Î¼ :=\n  hf.finStronglyMeasurable_of_set_sigmaFinite MeasurableSet.univ (by simp)\n    (by rwa [Measure.restrict_univ])\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâœ : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Measurable f","decl":"/-- A strongly measurable function is measurable. -/\n@[aesop 5% apply (rule_sets := [Measurable])]\nprotected theorem measurable {_ : MeasurableSpace Î±} [TopologicalSpace Î²] [PseudoMetrizableSpace Î²]\n    [MeasurableSpace Î²] [BorelSpace Î²] (hf : StronglyMeasurable f) : Measurable f :=\n  measurable_of_tendsto_metrizable (fun n => (hf.approx n).measurable)\n    (tendsto_pi_nhds.mpr hf.tendsto_approx)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.aemeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâœ : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ AEMeasurable f Î¼","decl":"/-- A strongly measurable function is almost everywhere measurable. -/\n@[aesop 5% apply (rule_sets := [Measurable])]\nprotected theorem aemeasurable {_ : MeasurableSpace Î±} [TopologicalSpace Î²]\n    [PseudoMetrizableSpace Î²] [MeasurableSpace Î²] [BorelSpace Î²] {Î¼ : Measure Î±}\n    (hf : StronglyMeasurable f) : AEMeasurable f Î¼ :=\n  hf.measurable.aemeasurable\n\n"}
{"name":"Continuous.comp_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nxâœ : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : TopologicalSpace Î³\ng : Î² â†’ Î³\nf : Î± â†’ Î²\nhg : Continuous g\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => g (f x)","decl":"theorem _root_.Continuous.comp_stronglyMeasurable {_ : MeasurableSpace Î±} [TopologicalSpace Î²]\n    [TopologicalSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : Continuous g) (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun x => g (f x) :=\n  âŸ¨fun n => SimpleFunc.map g (hf.approx n), fun x => (hg.tendsto _).comp (hf.tendsto_approx x)âŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_mulSupport","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nm : MeasurableSpace Î±\ninstâœÂ² : One Î²\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : TopologicalSpace.MetrizableSpace Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasurableSet (Function.mulSupport f)","decl":"@[to_additive]\nnonrec theorem measurableSet_mulSupport {m : MeasurableSpace Î±} [One Î²] [TopologicalSpace Î²]\n    [MetrizableSpace Î²] (hf : StronglyMeasurable f) : MeasurableSet (mulSupport f) := by\n  borelize Î²\n  exact measurableSet_mulSupport hf.measurable\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_support","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nm : MeasurableSpace Î±\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : TopologicalSpace.MetrizableSpace Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasurableSet (Function.support f)","decl":"@[to_additive]\nnonrec theorem measurableSet_mulSupport {m : MeasurableSpace Î±} [One Î²] [TopologicalSpace Î²]\n    [MetrizableSpace Î²] (hf : StronglyMeasurable f) : MeasurableSet (mulSupport f) := by\n  borelize Î²\n  exact measurableSet_mulSupport hf.measurable\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mono","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nm m' : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\nhf : MeasureTheory.StronglyMeasurable f\nh_mono : LE.le m' m\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"protected theorem mono {m m' : MeasurableSpace Î±} [TopologicalSpace Î²]\n    (hf : StronglyMeasurable[m'] f) (h_mono : m' â‰¤ m) : StronglyMeasurable[m] f := by\n  let f_approx : â„• â†’ @SimpleFunc Î± m Î² := fun n =>\n    @SimpleFunc.mk Î± m Î²\n      (hf.approx n)\n      (fun x => h_mono _ (SimpleFunc.measurableSet_fiber' _ x))\n      (SimpleFunc.finite_range (hf.approx n))\n  exact âŸ¨f_approx, hf.tendsto_approxâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.prod_mk","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : TopologicalSpace Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => { fst := f x, snd := g x }","decl":"protected theorem prod_mk {m : MeasurableSpace Î±} [TopologicalSpace Î²] [TopologicalSpace Î³]\n    {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => (f x, g x) := by\n  refine âŸ¨fun n => SimpleFunc.pair (hf.approx n) (hg.approx n), fun x => ?_âŸ©\n  rw [nhds_prod_eq]\n  exact Tendsto.prod_mk (hf.tendsto_approx x) (hg.tendsto_approx x)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.comp_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : TopologicalSpace Î²\nxâœÂ¹ : MeasurableSpace Î±\nxâœ : MeasurableSpace Î³\nf : Î± â†’ Î²\ng : Î³ â†’ Î±\nhf : MeasureTheory.StronglyMeasurable f\nhg : Measurable g\nâŠ¢ MeasureTheory.StronglyMeasurable (Function.comp f g)","decl":"theorem comp_measurable [TopologicalSpace Î²] {_ : MeasurableSpace Î±} {_ : MeasurableSpace Î³}\n    {f : Î± â†’ Î²} {g : Î³ â†’ Î±} (hf : StronglyMeasurable f) (hg : Measurable g) :\n    StronglyMeasurable (f âˆ˜ g) :=\n  âŸ¨fun n => SimpleFunc.comp (hf.approx n) g hg, fun x => hf.tendsto_approx (g x)âŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.of_uncurry_left","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : TopologicalSpace Î²\nxâœÂ¹ : MeasurableSpace Î±\nxâœ : MeasurableSpace Î³\nf : Î± â†’ Î³ â†’ Î²\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\nx : Î±\nâŠ¢ MeasureTheory.StronglyMeasurable (f x)","decl":"theorem of_uncurry_left [TopologicalSpace Î²] {_ : MeasurableSpace Î±} {_ : MeasurableSpace Î³}\n    {f : Î± â†’ Î³ â†’ Î²} (hf : StronglyMeasurable (uncurry f)) {x : Î±} : StronglyMeasurable (f x) :=\n  hf.comp_measurable measurable_prod_mk_left\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.of_uncurry_right","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : TopologicalSpace Î²\nxâœÂ¹ : MeasurableSpace Î±\nxâœ : MeasurableSpace Î³\nf : Î± â†’ Î³ â†’ Î²\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\ny : Î³\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => f x y","decl":"theorem of_uncurry_right [TopologicalSpace Î²] {_ : MeasurableSpace Î±} {_ : MeasurableSpace Î³}\n    {f : Î± â†’ Î³ â†’ Î²} (hf : StronglyMeasurable (uncurry f)) {y : Î³} :\n    StronglyMeasurable fun x => f x y :=\n  hf.comp_measurable measurable_prod_mk_right\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.prod_swap","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nxâœÂ¹ : MeasurableSpace Î±\nxâœ : MeasurableSpace Î²\ninstâœ : TopologicalSpace Î³\nf : Prod Î² Î± â†’ Î³\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun z => f z.swap","decl":"protected theorem prod_swap {_ : MeasurableSpace Î±} {_ : MeasurableSpace Î²} [TopologicalSpace Î³]\n    {f : Î² Ã— Î± â†’ Î³} (hf : StronglyMeasurable f) :\n    StronglyMeasurable (fun z : Î± Ã— Î² => f z.swap) :=\n  hf.comp_measurable measurable_swap\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.fst","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nxâœ : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\ninstâœ : TopologicalSpace Î³\nf : Î± â†’ Î³\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun z => f z.1","decl":"protected theorem fst {_ : MeasurableSpace Î±} [mÎ² : MeasurableSpace Î²] [TopologicalSpace Î³]\n    {f : Î± â†’ Î³} (hf : StronglyMeasurable f) :\n    StronglyMeasurable (fun z : Î± Ã— Î² => f z.1) :=\n  hf.comp_measurable measurable_fst\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.snd","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nxâœ : MeasurableSpace Î²\ninstâœ : TopologicalSpace Î³\nf : Î² â†’ Î³\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun z => f z.2","decl":"protected theorem snd [mÎ± : MeasurableSpace Î±] {_ : MeasurableSpace Î²} [TopologicalSpace Î³]\n    {f : Î² â†’ Î³} (hf : StronglyMeasurable f) :\n    StronglyMeasurable (fun z : Î± Ã— Î² => f z.2) :=\n  hf.comp_measurable measurable_snd\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Mul Î²\ninstâœ : ContinuousMul Î²\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable (HMul.hMul f g)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem mul [Mul Î²] [ContinuousMul Î²] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f * g) :=\n  âŸ¨fun n => hf.approx n * hg.approx n, fun x => (hf.tendsto_approx x).mul (hg.tendsto_approx x)âŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.add","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Add Î²\ninstâœ : ContinuousAdd Î²\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable (HAdd.hAdd f g)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem mul [Mul Î²] [ContinuousMul Î²] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f * g) :=\n  âŸ¨fun n => hf.approx n * hg.approx n, fun x => (hf.tendsto_approx x).mul (hg.tendsto_approx x)âŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.add_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Add Î²\ninstâœ : ContinuousAdd Î²\nhf : MeasureTheory.StronglyMeasurable f\nc : Î²\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HAdd.hAdd (f x) c","decl":"@[to_additive (attr := measurability)]\ntheorem mul_const [Mul Î²] [ContinuousMul Î²] (hf : StronglyMeasurable f) (c : Î²) :\n    StronglyMeasurable fun x => f x * c :=\n  hf.mul stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mul_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Mul Î²\ninstâœ : ContinuousMul Î²\nhf : MeasureTheory.StronglyMeasurable f\nc : Î²\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HMul.hMul (f x) c","decl":"@[to_additive (attr := measurability)]\ntheorem mul_const [Mul Î²] [ContinuousMul Î²] (hf : StronglyMeasurable f) (c : Î²) :\n    StronglyMeasurable fun x => f x * c :=\n  hf.mul stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_add","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Add Î²\ninstâœ : ContinuousAdd Î²\nhf : MeasureTheory.StronglyMeasurable f\nc : Î²\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HAdd.hAdd c (f x)","decl":"@[to_additive (attr := measurability)]\ntheorem const_mul [Mul Î²] [ContinuousMul Î²] (hf : StronglyMeasurable f) (c : Î²) :\n    StronglyMeasurable fun x => c * f x :=\n  stronglyMeasurable_const.mul hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_mul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Mul Î²\ninstâœ : ContinuousMul Î²\nhf : MeasureTheory.StronglyMeasurable f\nc : Î²\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HMul.hMul c (f x)","decl":"@[to_additive (attr := measurability)]\ntheorem const_mul [Mul Î²] [ContinuousMul Î²] (hf : StronglyMeasurable f) (c : Î²) :\n    StronglyMeasurable fun x => c * f x :=\n  stronglyMeasurable_const.mul hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.pow","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Monoid Î²\ninstâœ : ContinuousMul Î²\nhf : MeasureTheory.StronglyMeasurable f\nn : Nat\nâŠ¢ MeasureTheory.StronglyMeasurable (HPow.hPow f n)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable])) const_nsmul]\nprotected theorem pow [Monoid Î²] [ContinuousMul Î²] (hf : StronglyMeasurable f) (n : â„•) :\n    StronglyMeasurable (f ^ n) :=\n  âŸ¨fun k => hf.approx k ^ n, fun x => (hf.tendsto_approx x).pow nâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_nsmul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : AddMonoid Î²\ninstâœ : ContinuousAdd Î²\nhf : MeasureTheory.StronglyMeasurable f\nn : Nat\nâŠ¢ MeasureTheory.StronglyMeasurable (HSMul.hSMul n f)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable])) const_nsmul]\nprotected theorem pow [Monoid Î²] [ContinuousMul Î²] (hf : StronglyMeasurable f) (n : â„•) :\n    StronglyMeasurable (f ^ n) :=\n  âŸ¨fun k => hf.approx k ^ n, fun x => (hf.tendsto_approx x).pow nâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.inv","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Inv Î²\ninstâœ : ContinuousInv Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable (Inv.inv f)","decl":"@[to_additive (attr := measurability)]\nprotected theorem inv [Inv Î²] [ContinuousInv Î²] (hf : StronglyMeasurable f) :\n    StronglyMeasurable fâ»Â¹ :=\n  âŸ¨fun n => (hf.approx n)â»Â¹, fun x => (hf.tendsto_approx x).invâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.neg","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Neg Î²\ninstâœ : ContinuousNeg Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable (Neg.neg f)","decl":"@[to_additive (attr := measurability)]\nprotected theorem inv [Inv Î²] [ContinuousInv Î²] (hf : StronglyMeasurable f) :\n    StronglyMeasurable fâ»Â¹ :=\n  âŸ¨fun n => (hf.approx n)â»Â¹, fun x => (hf.tendsto_approx x).invâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.sub","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Sub Î²\ninstâœ : ContinuousSub Î²\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable (HSub.hSub f g)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem div [Div Î²] [ContinuousDiv Î²] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f / g) :=\n  âŸ¨fun n => hf.approx n / hg.approx n, fun x => (hf.tendsto_approx x).div' (hg.tendsto_approx x)âŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.div","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Div Î²\ninstâœ : ContinuousDiv Î²\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable (HDiv.hDiv f g)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem div [Div Î²] [ContinuousDiv Î²] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f / g) :=\n  âŸ¨fun n => hf.approx n / hg.approx n, fun x => (hf.tendsto_approx x).div' (hg.tendsto_approx x)âŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mul_iff_right","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : CommGroup Î²\ninstâœ : TopologicalGroup Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable (HMul.hMul f g)) (MeasureTheory.StronglyMeasurable g)","decl":"@[to_additive]\ntheorem mul_iff_right [CommGroup Î²] [TopologicalGroup Î²] (hf : StronglyMeasurable f) :\n    StronglyMeasurable (f * g) â†” StronglyMeasurable g :=\n  âŸ¨fun h â†¦ show g = f * g * fâ»Â¹ by simp only [mul_inv_cancel_comm] â–¸ h.mul hf.inv,\n    fun h â†¦ hf.mul hâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.add_iff_right","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : AddCommGroup Î²\ninstâœ : TopologicalAddGroup Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable (HAdd.hAdd f g)) (MeasureTheory.StronglyMeasurable g)","decl":"@[to_additive]\ntheorem mul_iff_right [CommGroup Î²] [TopologicalGroup Î²] (hf : StronglyMeasurable f) :\n    StronglyMeasurable (f * g) â†” StronglyMeasurable g :=\n  âŸ¨fun h â†¦ show g = f * g * fâ»Â¹ by simp only [mul_inv_cancel_comm] â–¸ h.mul hf.inv,\n    fun h â†¦ hf.mul hâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.add_iff_left","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : AddCommGroup Î²\ninstâœ : TopologicalAddGroup Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable (HAdd.hAdd g f)) (MeasureTheory.StronglyMeasurable g)","decl":"@[to_additive]\ntheorem mul_iff_left [CommGroup Î²] [TopologicalGroup Î²] (hf : StronglyMeasurable f) :\n    StronglyMeasurable (g * f) â†” StronglyMeasurable g :=\n  mul_comm g f â–¸ mul_iff_right hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.mul_iff_left","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : CommGroup Î²\ninstâœ : TopologicalGroup Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable (HMul.hMul g f)) (MeasureTheory.StronglyMeasurable g)","decl":"@[to_additive]\ntheorem mul_iff_left [CommGroup Î²] [TopologicalGroup Î²] (hf : StronglyMeasurable f) :\n    StronglyMeasurable (g * f) â†” StronglyMeasurable g :=\n  mul_comm g f â–¸ mul_iff_right hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.smul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\nğ•œ : Type u_5\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : SMul ğ•œ Î²\ninstâœ : ContinuousSMul ğ•œ Î²\nf : Î± â†’ ğ•œ\ng : Î± â†’ Î²\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul (f x) (g x)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem smul {ğ•œ} [TopologicalSpace ğ•œ] [SMul ğ•œ Î²] [ContinuousSMul ğ•œ Î²] {f : Î± â†’ ğ•œ}\n    {g : Î± â†’ Î²} (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => f x â€¢ g x :=\n  continuous_smul.comp_stronglyMeasurable (hf.prod_mk hg)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.vadd","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\nğ•œ : Type u_5\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : VAdd ğ•œ Î²\ninstâœ : ContinuousVAdd ğ•œ Î²\nf : Î± â†’ ğ•œ\ng : Î± â†’ Î²\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HVAdd.hVAdd (f x) (g x)","decl":"@[to_additive (attr := aesop safe 20 apply (rule_sets := [Measurable]))]\nprotected theorem smul {ğ•œ} [TopologicalSpace ğ•œ] [SMul ğ•œ Î²] [ContinuousSMul ğ•œ Î²] {f : Î± â†’ ğ•œ}\n    {g : Î± â†’ Î²} (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => f x â€¢ g x :=\n  continuous_smul.comp_stronglyMeasurable (hf.prod_mk hg)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_smul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\nğ•œ : Type u_5\ninstâœÂ¹ : SMul ğ•œ Î²\ninstâœ : ContinuousConstSMul ğ•œ Î²\nhf : MeasureTheory.StronglyMeasurable f\nc : ğ•œ\nâŠ¢ MeasureTheory.StronglyMeasurable (HSMul.hSMul c f)","decl":"@[to_additive (attr := measurability)]\nprotected theorem const_smul {ğ•œ} [SMul ğ•œ Î²] [ContinuousConstSMul ğ•œ Î²] (hf : StronglyMeasurable f)\n    (c : ğ•œ) : StronglyMeasurable (c â€¢ f) :=\n  âŸ¨fun n => c â€¢ hf.approx n, fun x => (hf.tendsto_approx x).const_smul câŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_vadd","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\nğ•œ : Type u_5\ninstâœÂ¹ : VAdd ğ•œ Î²\ninstâœ : ContinuousConstVAdd ğ•œ Î²\nhf : MeasureTheory.StronglyMeasurable f\nc : ğ•œ\nâŠ¢ MeasureTheory.StronglyMeasurable (HVAdd.hVAdd c f)","decl":"@[to_additive (attr := measurability)]\nprotected theorem const_smul {ğ•œ} [SMul ğ•œ Î²] [ContinuousConstSMul ğ•œ Î²] (hf : StronglyMeasurable f)\n    (c : ğ•œ) : StronglyMeasurable (c â€¢ f) :=\n  âŸ¨fun n => c â€¢ hf.approx n, fun x => (hf.tendsto_approx x).const_smul câŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_vadd'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\nğ•œ : Type u_5\ninstâœÂ¹ : VAdd ğ•œ Î²\ninstâœ : ContinuousConstVAdd ğ•œ Î²\nhf : MeasureTheory.StronglyMeasurable f\nc : ğ•œ\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HVAdd.hVAdd c (f x)","decl":"@[to_additive (attr := measurability)]\nprotected theorem const_smul' {ğ•œ} [SMul ğ•œ Î²] [ContinuousConstSMul ğ•œ Î²] (hf : StronglyMeasurable f)\n    (c : ğ•œ) : StronglyMeasurable fun x => c â€¢ f x :=\n  hf.const_smul c\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.const_smul'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\nğ•œ : Type u_5\ninstâœÂ¹ : SMul ğ•œ Î²\ninstâœ : ContinuousConstSMul ğ•œ Î²\nhf : MeasureTheory.StronglyMeasurable f\nc : ğ•œ\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul c (f x)","decl":"@[to_additive (attr := measurability)]\nprotected theorem const_smul' {ğ•œ} [SMul ğ•œ Î²] [ContinuousConstSMul ğ•œ Î²] (hf : StronglyMeasurable f)\n    (c : ğ•œ) : StronglyMeasurable fun x => c â€¢ f x :=\n  hf.const_smul c\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.smul_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\nğ•œ : Type u_5\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : SMul ğ•œ Î²\ninstâœ : ContinuousSMul ğ•œ Î²\nf : Î± â†’ ğ•œ\nhf : MeasureTheory.StronglyMeasurable f\nc : Î²\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul (f x) c","decl":"@[to_additive (attr := measurability)]\nprotected theorem smul_const {ğ•œ} [TopologicalSpace ğ•œ] [SMul ğ•œ Î²] [ContinuousSMul ğ•œ Î²] {f : Î± â†’ ğ•œ}\n    (hf : StronglyMeasurable f) (c : Î²) : StronglyMeasurable fun x => f x â€¢ c :=\n  continuous_smul.comp_stronglyMeasurable (hf.prod_mk stronglyMeasurable_const)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.vadd_const","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\nğ•œ : Type u_5\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : VAdd ğ•œ Î²\ninstâœ : ContinuousVAdd ğ•œ Î²\nf : Î± â†’ ğ•œ\nhf : MeasureTheory.StronglyMeasurable f\nc : Î²\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => HVAdd.hVAdd (f x) c","decl":"@[to_additive (attr := measurability)]\nprotected theorem smul_const {ğ•œ} [TopologicalSpace ğ•œ] [SMul ğ•œ Î²] [ContinuousSMul ğ•œ Î²] {f : Î± â†’ ğ•œ}\n    (hf : StronglyMeasurable f) (c : Î²) : StronglyMeasurable fun x => f x â€¢ c :=\n  continuous_smul.comp_stronglyMeasurable (hf.prod_mk stronglyMeasurable_const)\n\n"}
{"name":"Measurable.add_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_5\nE : Type u_6\nxâœ : MeasurableSpace Î±\ninstâœâµ : AddGroup E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : ContinuousAdd E\ninstâœ : TopologicalSpace.PseudoMetrizableSpace E\ng f : Î± â†’ E\nhg : Measurable g\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Measurable (HAdd.hAdd g f)","decl":"/-- In a normed vector space, the addition of a measurable function and a strongly measurable\nfunction is measurable. Note that this is not true without further second-countability assumptions\nfor the addition of two measurable functions. -/\ntheorem _root_.Measurable.add_stronglyMeasurable\n    {Î± E : Type*} {_ : MeasurableSpace Î±} [AddGroup E] [TopologicalSpace E]\n    [MeasurableSpace E] [BorelSpace E] [ContinuousAdd E] [PseudoMetrizableSpace E]\n    {g f : Î± â†’ E} (hg : Measurable g) (hf : StronglyMeasurable f) :\n    Measurable (g + f) := by\n  rcases hf with âŸ¨Ï†, hÏ†âŸ©\n  have : Tendsto (fun n x â†¦ g x + Ï† n x) atTop (ğ“ (g + f)) :=\n    tendsto_pi_nhds.2 (fun x â†¦ tendsto_const_nhds.add (hÏ† x))\n  apply measurable_of_tendsto_metrizable (fun n â†¦ ?_) this\n  exact hg.add_simpleFunc _\n\n"}
{"name":"Measurable.sub_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_5\nE : Type u_6\nxâœ : MeasurableSpace Î±\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : MeasurableSpace E\ninstâœÂ³ : BorelSpace E\ninstâœÂ² : ContinuousAdd E\ninstâœÂ¹ : ContinuousNeg E\ninstâœ : TopologicalSpace.PseudoMetrizableSpace E\ng f : Î± â†’ E\nhg : Measurable g\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Measurable (HSub.hSub g f)","decl":"/-- In a normed vector space, the subtraction of a measurable function and a strongly measurable\nfunction is measurable. Note that this is not true without further second-countability assumptions\nfor the subtraction of two measurable functions. -/\ntheorem _root_.Measurable.sub_stronglyMeasurable\n    {Î± E : Type*} {_ : MeasurableSpace Î±} [AddCommGroup E] [TopologicalSpace E]\n    [MeasurableSpace E] [BorelSpace E] [ContinuousAdd E] [ContinuousNeg E] [PseudoMetrizableSpace E]\n    {g f : Î± â†’ E} (hg : Measurable g) (hf : StronglyMeasurable f) :\n    Measurable (g - f) := by\n  rw [sub_eq_add_neg]\n  exact hg.add_stronglyMeasurable hf.neg\n\n"}
{"name":"Measurable.stronglyMeasurable_add","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_5\nE : Type u_6\nxâœ : MeasurableSpace Î±\ninstâœâµ : AddGroup E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : ContinuousAdd E\ninstâœ : TopologicalSpace.PseudoMetrizableSpace E\ng f : Î± â†’ E\nhg : Measurable g\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Measurable (HAdd.hAdd f g)","decl":"/-- In a normed vector space, the addition of a strongly measurable function and a measurable\nfunction is measurable. Note that this is not true without further second-countability assumptions\nfor the addition of two measurable functions. -/\ntheorem _root_.Measurable.stronglyMeasurable_add\n    {Î± E : Type*} {_ : MeasurableSpace Î±} [AddGroup E] [TopologicalSpace E]\n    [MeasurableSpace E] [BorelSpace E] [ContinuousAdd E] [PseudoMetrizableSpace E]\n    {g f : Î± â†’ E} (hg : Measurable g) (hf : StronglyMeasurable f) :\n    Measurable (f + g) := by\n  rcases hf with âŸ¨Ï†, hÏ†âŸ©\n  have : Tendsto (fun n x â†¦ Ï† n x + g x) atTop (ğ“ (f + g)) :=\n    tendsto_pi_nhds.2 (fun x â†¦ (hÏ† x).add tendsto_const_nhds)\n  apply measurable_of_tendsto_metrizable (fun n â†¦ ?_) this\n  exact hg.simpleFunc_add _\n\n"}
{"name":"stronglyMeasurable_const_smul_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nG : Type u_6\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Group G\ninstâœÂ¹ : MulAction G Î²\ninstâœ : ContinuousConstSMul G Î²\nm : MeasurableSpace Î±\nc : G\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul c (f x)) (MeasureTheory.StronglyMeasurable f)","decl":"theorem _root_.stronglyMeasurable_const_smul_iff {m : MeasurableSpace Î±} (c : G) :\n    (StronglyMeasurable fun x => c â€¢ f x) â†” StronglyMeasurable f :=\n  âŸ¨fun h => by simpa only [inv_smul_smul] using h.const_smul' câ»Â¹, fun h => h.const_smul câŸ©\n\n"}
{"name":"IsUnit.stronglyMeasurable_const_smul_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nM : Type u_5\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Monoid M\ninstâœÂ¹ : MulAction M Î²\ninstâœ : ContinuousConstSMul M Î²\nxâœ : MeasurableSpace Î±\nc : M\nhc : IsUnit c\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul c (f x)) (MeasureTheory.StronglyMeasurable f)","decl":"nonrec theorem _root_.IsUnit.stronglyMeasurable_const_smul_iff {_ : MeasurableSpace Î±} {c : M}\n    (hc : IsUnit c) :\n    (StronglyMeasurable fun x => c â€¢ f x) â†” StronglyMeasurable f :=\n  let âŸ¨u, huâŸ© := hc\n  hu â–¸ stronglyMeasurable_const_smul_iff u\n\n"}
{"name":"stronglyMeasurable_const_smul_iffâ‚€","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nGâ‚€ : Type u_7\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : GroupWithZero Gâ‚€\ninstâœÂ¹ : MulAction Gâ‚€ Î²\ninstâœ : ContinuousConstSMul Gâ‚€ Î²\nxâœ : MeasurableSpace Î±\nc : Gâ‚€\nhc : Ne c 0\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable fun x => HSMul.hSMul c (f x)) (MeasureTheory.StronglyMeasurable f)","decl":"theorem _root_.stronglyMeasurable_const_smul_iffâ‚€ {_ : MeasurableSpace Î±} {c : Gâ‚€} (hc : c â‰  0) :\n    (StronglyMeasurable fun x => c â€¢ f x) â†” StronglyMeasurable f :=\n  (IsUnit.mk0 _ hc).stronglyMeasurable_const_smul_iff\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.sup","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Max Î²\ninstâœ : ContinuousSup Î²\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable (Max.max f g)","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem sup [Max Î²] [ContinuousSup Î²] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f âŠ” g) :=\n  âŸ¨fun n => hf.approx n âŠ” hg.approx n, fun x =>\n    (hf.tendsto_approx x).sup_nhds (hg.tendsto_approx x)âŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.inf","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Min Î²\ninstâœ : ContinuousInf Î²\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable (Min.min f g)","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem inf [Min Î²] [ContinuousInf Î²] (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (f âŠ“ g) :=\n  âŸ¨fun n => hf.approx n âŠ“ hg.approx n, fun x =>\n    (hf.tendsto_approx x).inf_nhds (hg.tendsto_approx x)âŸ©\n\n"}
{"name":"List.stronglyMeasurable_sum'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nm : MeasurableSpace Î±\nl : List (Î± â†’ M)\nhl : âˆ€ (f : Î± â†’ M), Membership.mem l f â†’ MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable l.sum","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod' (l : List (Î± â†’ M))\n    (hl : âˆ€ f âˆˆ l, StronglyMeasurable f) : StronglyMeasurable l.prod := by\n  induction' l with f l ihl; Â· exact stronglyMeasurable_one\n  rw [List.forall_mem_cons] at hl\n  rw [List.prod_cons]\n  exact hl.1.mul (ihl hl.2)\n\n"}
{"name":"List.stronglyMeasurable_prod'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : Monoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nm : MeasurableSpace Î±\nl : List (Î± â†’ M)\nhl : âˆ€ (f : Î± â†’ M), Membership.mem l f â†’ MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable l.prod","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod' (l : List (Î± â†’ M))\n    (hl : âˆ€ f âˆˆ l, StronglyMeasurable f) : StronglyMeasurable l.prod := by\n  induction' l with f l ihl; Â· exact stronglyMeasurable_one\n  rw [List.forall_mem_cons] at hl\n  rw [List.prod_cons]\n  exact hl.1.mul (ihl hl.2)\n\n"}
{"name":"List.stronglyMeasurable_sum","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nm : MeasurableSpace Î±\nl : List (Î± â†’ M)\nhl : âˆ€ (f : Î± â†’ M), Membership.mem l f â†’ MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => (List.map (fun f => f x) l).sum","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod (l : List (Î± â†’ M))\n    (hl : âˆ€ f âˆˆ l, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (l.map fun f : Î± â†’ M => f x).prod := by\n  simpa only [â† Pi.list_prod_apply] using l.stronglyMeasurable_prod' hl\n\n"}
{"name":"List.stronglyMeasurable_prod","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : Monoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nm : MeasurableSpace Î±\nl : List (Î± â†’ M)\nhl : âˆ€ (f : Î± â†’ M), Membership.mem l f â†’ MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => (List.map (fun f => f x) l).prod","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.List.stronglyMeasurable_prod (l : List (Î± â†’ M))\n    (hl : âˆ€ f âˆˆ l, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (l.map fun f : Î± â†’ M => f x).prod := by\n  simpa only [â† Pi.list_prod_apply] using l.stronglyMeasurable_prod' hl\n\n"}
{"name":"Multiset.stronglyMeasurable_sum'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nm : MeasurableSpace Î±\nl : Multiset (Î± â†’ M)\nhl : âˆ€ (f : Î± â†’ M), Membership.mem l f â†’ MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable l.sum","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod' (l : Multiset (Î± â†’ M))\n    (hl : âˆ€ f âˆˆ l, StronglyMeasurable f) : StronglyMeasurable l.prod := by\n  rcases l with âŸ¨lâŸ©\n  simpa using l.stronglyMeasurable_prod' (by simpa using hl)\n\n"}
{"name":"Multiset.stronglyMeasurable_prod'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nm : MeasurableSpace Î±\nl : Multiset (Î± â†’ M)\nhl : âˆ€ (f : Î± â†’ M), Membership.mem l f â†’ MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable l.prod","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod' (l : Multiset (Î± â†’ M))\n    (hl : âˆ€ f âˆˆ l, StronglyMeasurable f) : StronglyMeasurable l.prod := by\n  rcases l with âŸ¨lâŸ©\n  simpa using l.stronglyMeasurable_prod' (by simpa using hl)\n\n"}
{"name":"Multiset.stronglyMeasurable_sum","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nm : MeasurableSpace Î±\ns : Multiset (Î± â†’ M)\nhs : âˆ€ (f : Î± â†’ M), Membership.mem s f â†’ MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => (Multiset.map (fun f => f x) s).sum","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod (s : Multiset (Î± â†’ M))\n    (hs : âˆ€ f âˆˆ s, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (s.map fun f : Î± â†’ M => f x).prod := by\n  simpa only [â† Pi.multiset_prod_apply] using s.stronglyMeasurable_prod' hs\n\n"}
{"name":"Multiset.stronglyMeasurable_prod","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nm : MeasurableSpace Î±\ns : Multiset (Î± â†’ M)\nhs : âˆ€ (f : Î± â†’ M), Membership.mem s f â†’ MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => (Multiset.map (fun f => f x) s).prod","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Multiset.stronglyMeasurable_prod (s : Multiset (Î± â†’ M))\n    (hs : âˆ€ f âˆˆ s, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (s.map fun f : Î± â†’ M => f x).prod := by\n  simpa only [â† Pi.multiset_prod_apply] using s.stronglyMeasurable_prod' hs\n\n"}
{"name":"Finset.stronglyMeasurable_sum'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nm : MeasurableSpace Î±\nÎ¹ : Type u_6\nf : Î¹ â†’ Î± â†’ M\ns : Finset Î¹\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.StronglyMeasurable (f i)\nâŠ¢ MeasureTheory.StronglyMeasurable (s.sum fun i => f i)","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod' {Î¹ : Type*} {f : Î¹ â†’ Î± â†’ M} (s : Finset Î¹)\n    (hf : âˆ€ i âˆˆ s, StronglyMeasurable (f i)) : StronglyMeasurable (âˆ i âˆˆ s, f i) :=\n  Finset.prod_induction _ _ (fun _a _b ha hb => ha.mul hb) (@stronglyMeasurable_one Î± M _ _ _) hf\n\n"}
{"name":"Finset.stronglyMeasurable_prod'","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nm : MeasurableSpace Î±\nÎ¹ : Type u_6\nf : Î¹ â†’ Î± â†’ M\ns : Finset Î¹\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.StronglyMeasurable (f i)\nâŠ¢ MeasureTheory.StronglyMeasurable (s.prod fun i => f i)","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod' {Î¹ : Type*} {f : Î¹ â†’ Î± â†’ M} (s : Finset Î¹)\n    (hf : âˆ€ i âˆˆ s, StronglyMeasurable (f i)) : StronglyMeasurable (âˆ i âˆˆ s, f i) :=\n  Finset.prod_induction _ _ (fun _a _b ha hb => ha.mul hb) (@stronglyMeasurable_one Î± M _ _ _) hf\n\n"}
{"name":"Finset.stronglyMeasurable_sum","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nm : MeasurableSpace Î±\nÎ¹ : Type u_6\nf : Î¹ â†’ Î± â†’ M\ns : Finset Î¹\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.StronglyMeasurable (f i)\nâŠ¢ MeasureTheory.StronglyMeasurable fun a => s.sum fun i => f i a","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod {Î¹ : Type*} {f : Î¹ â†’ Î± â†’ M} (s : Finset Î¹)\n    (hf : âˆ€ i âˆˆ s, StronglyMeasurable (f i)) : StronglyMeasurable fun a => âˆ i âˆˆ s, f i a := by\n  simpa only [â† Finset.prod_apply] using s.stronglyMeasurable_prod' hf\n\n"}
{"name":"Finset.stronglyMeasurable_prod","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nM : Type u_5\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nm : MeasurableSpace Î±\nÎ¹ : Type u_6\nf : Î¹ â†’ Î± â†’ M\ns : Finset Î¹\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.StronglyMeasurable (f i)\nâŠ¢ MeasureTheory.StronglyMeasurable fun a => s.prod fun i => f i a","decl":"@[to_additive (attr := measurability)]\ntheorem _root_.Finset.stronglyMeasurable_prod {Î¹ : Type*} {f : Î¹ â†’ Î± â†’ M} (s : Finset Î¹)\n    (hf : âˆ€ i âˆˆ s, StronglyMeasurable (f i)) : StronglyMeasurable fun a => âˆ i âˆˆ s, f i a := by\n  simpa only [â† Finset.prod_apply] using s.stronglyMeasurable_prod' hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.isSeparable_range","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nm : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ TopologicalSpace.IsSeparable (Set.range f)","decl":"/-- The range of a strongly measurable function is separable. -/\nprotected theorem isSeparable_range {m : MeasurableSpace Î±} [TopologicalSpace Î²]\n    (hf : StronglyMeasurable f) : TopologicalSpace.IsSeparable (range f) := by\n  have : IsSeparable (closure (â‹ƒ n, range (hf.approx n))) :=\n    .closure <| .iUnion fun n => (hf.approx n).finite_range.isSeparable\n  apply this.mono\n  rintro _ âŸ¨x, rflâŸ©\n  apply mem_closure_of_tendsto (hf.tendsto_approx x)\n  filter_upwards with n\n  apply mem_iUnion_of_mem n\n  exact mem_range_self _\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.separableSpace_range_union_singleton","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâœ : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : TopologicalSpace.PseudoMetrizableSpace Î²\nhf : MeasureTheory.StronglyMeasurable f\nb : Î²\nâŠ¢ TopologicalSpace.SeparableSpace â†‘(Union.union (Set.range f) (Singleton.singleton b))","decl":"theorem separableSpace_range_union_singleton {_ : MeasurableSpace Î±} [TopologicalSpace Î²]\n    [PseudoMetrizableSpace Î²] (hf : StronglyMeasurable f) {b : Î²} :\n    SeparableSpace (range f âˆª {b} : Set Î²) :=\n  letI := pseudoMetrizableSpacePseudoMetric Î²\n  (hf.isSeparable_range.union (finite_singleton _).isSeparable).separableSpace\n\n"}
{"name":"Measurable.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : SecondCountableTopology Î²\ninstâœ : OpensMeasurableSpace Î²\nhf : Measurable f\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- In a space with second countable topology, measurable implies strongly measurable. -/\n@[aesop 90% apply (rule_sets := [Measurable])]\ntheorem _root_.Measurable.stronglyMeasurable [TopologicalSpace Î²] [PseudoMetrizableSpace Î²]\n    [SecondCountableTopology Î²] [OpensMeasurableSpace Î²] (hf : Measurable f) :\n    StronglyMeasurable f := by\n  letI := pseudoMetrizableSpacePseudoMetric Î²\n  nontriviality Î²; inhabit Î²\n  exact âŸ¨SimpleFunc.approxOn f hf Set.univ default (Set.mem_univ _), fun x â†¦\n    SimpleFunc.tendsto_approxOn hf (Set.mem_univ _) (by rw [closure_univ]; simp)âŸ©\n\n"}
{"name":"stronglyMeasurable_iff_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.MetrizableSpace Î²\ninstâœÂ¹ : BorelSpace Î²\ninstâœ : SecondCountableTopology Î²\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable f) (Measurable f)","decl":"/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem _root_.stronglyMeasurable_iff_measurable [TopologicalSpace Î²] [MetrizableSpace Î²]\n    [BorelSpace Î²] [SecondCountableTopology Î²] : StronglyMeasurable f â†” Measurable f :=\n  âŸ¨fun h => h.measurable, fun h => Measurable.stronglyMeasurable hâŸ©\n\n"}
{"name":"stronglyMeasurable_id","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\ninstâœ : SecondCountableTopology Î±\nâŠ¢ MeasureTheory.StronglyMeasurable id","decl":"@[measurability]\ntheorem _root_.stronglyMeasurable_id [TopologicalSpace Î±] [PseudoMetrizableSpace Î±]\n    [OpensMeasurableSpace Î±] [SecondCountableTopology Î±] : StronglyMeasurable (id : Î± â†’ Î±) :=\n  measurable_id.stronglyMeasurable\n\n"}
{"name":"stronglyMeasurable_iff_measurable_separable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nm : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable f) (And (Measurable f) (TopologicalSpace.IsSeparable (Set.range f)))","decl":"/-- A function is strongly measurable if and only if it is measurable and has separable\nrange. -/\ntheorem _root_.stronglyMeasurable_iff_measurable_separable {m : MeasurableSpace Î±}\n    [TopologicalSpace Î²] [PseudoMetrizableSpace Î²] [MeasurableSpace Î²] [BorelSpace Î²] :\n    StronglyMeasurable f â†” Measurable f âˆ§ IsSeparable (range f) := by\n  refine âŸ¨fun H â†¦ âŸ¨H.measurable, H.isSeparable_rangeâŸ©, fun âŸ¨Hm, HsepâŸ©  â†¦ ?_âŸ©\n  have := Hsep.secondCountableTopology\n  have Hm' : StronglyMeasurable (rangeFactorization f) := Hm.subtype_mk.stronglyMeasurable\n  exact continuous_subtype_val.comp_stronglyMeasurable Hm'\n\n"}
{"name":"Continuous.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : TopologicalSpace.PseudoMetrizableSpace Î²\nh : SecondCountableTopologyEither Î± Î²\nf : Î± â†’ Î²\nhf : Continuous f\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function is strongly measurable when either the source space or the target space\nis second-countable. -/\ntheorem _root_.Continuous.stronglyMeasurable [MeasurableSpace Î±] [TopologicalSpace Î±]\n    [OpensMeasurableSpace Î±] [TopologicalSpace Î²] [PseudoMetrizableSpace Î²]\n    [h : SecondCountableTopologyEither Î± Î²] {f : Î± â†’ Î²} (hf : Continuous f) :\n    StronglyMeasurable f := by\n  borelize Î²\n  cases h.out\n  Â· rw [stronglyMeasurable_iff_measurable_separable]\n    refine âŸ¨hf.measurable, ?_âŸ©\n    exact isSeparable_range hf\n  Â· exact hf.measurable.stronglyMeasurable\n\n"}
{"name":"Continuous.stronglyMeasurable_of_support_subset_isCompact","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : OpensMeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : BorelSpace Î²\ninstâœ : Zero Î²\nf : Î± â†’ Î²\nhf : Continuous f\nk : Set Î±\nhk : IsCompact k\nh'f : HasSubset.Subset (Function.support f) k\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function whose support is contained in a compact set is strongly measurable. -/\n@[to_additive]\ntheorem _root_.Continuous.stronglyMeasurable_of_mulSupport_subset_isCompact\n    [MeasurableSpace Î±] [TopologicalSpace Î±] [OpensMeasurableSpace Î±] [MeasurableSpace Î²]\n    [TopologicalSpace Î²] [PseudoMetrizableSpace Î²] [BorelSpace Î²] [One Î²] {f : Î± â†’ Î²}\n    (hf : Continuous f) {k : Set Î±} (hk : IsCompact k)\n    (h'f : mulSupport f âŠ† k) : StronglyMeasurable f := by\n  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²\n  rw [stronglyMeasurable_iff_measurable_separable]\n  exact âŸ¨hf.measurable, (isCompact_range_of_mulSupport_subset_isCompact hf hk h'f).isSeparableâŸ©\n\n"}
{"name":"Continuous.stronglyMeasurable_of_mulSupport_subset_isCompact","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : OpensMeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : BorelSpace Î²\ninstâœ : One Î²\nf : Î± â†’ Î²\nhf : Continuous f\nk : Set Î±\nhk : IsCompact k\nh'f : HasSubset.Subset (Function.mulSupport f) k\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function whose support is contained in a compact set is strongly measurable. -/\n@[to_additive]\ntheorem _root_.Continuous.stronglyMeasurable_of_mulSupport_subset_isCompact\n    [MeasurableSpace Î±] [TopologicalSpace Î±] [OpensMeasurableSpace Î±] [MeasurableSpace Î²]\n    [TopologicalSpace Î²] [PseudoMetrizableSpace Î²] [BorelSpace Î²] [One Î²] {f : Î± â†’ Î²}\n    (hf : Continuous f) {k : Set Î±} (hk : IsCompact k)\n    (h'f : mulSupport f âŠ† k) : StronglyMeasurable f := by\n  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²\n  rw [stronglyMeasurable_iff_measurable_separable]\n  exact âŸ¨hf.measurable, (isCompact_range_of_mulSupport_subset_isCompact hf hk h'f).isSeparableâŸ©\n\n"}
{"name":"Continuous.stronglyMeasurable_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : OpensMeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : BorelSpace Î²\ninstâœ : Zero Î²\nf : Î± â†’ Î²\nhf : Continuous f\nh'f : HasCompactSupport f\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function with compact support is strongly measurable. -/\n@[to_additive]\ntheorem _root_.Continuous.stronglyMeasurable_of_hasCompactMulSupport\n    [MeasurableSpace Î±] [TopologicalSpace Î±] [OpensMeasurableSpace Î±] [MeasurableSpace Î²]\n    [TopologicalSpace Î²] [PseudoMetrizableSpace Î²] [BorelSpace Î²] [One Î²] {f : Î± â†’ Î²}\n    (hf : Continuous f) (h'f : HasCompactMulSupport f) : StronglyMeasurable f :=\n  hf.stronglyMeasurable_of_mulSupport_subset_isCompact h'f (subset_mulTSupport f)\n\n"}
{"name":"Continuous.stronglyMeasurable_of_hasCompactMulSupport","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : OpensMeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : BorelSpace Î²\ninstâœ : One Î²\nf : Î± â†’ Î²\nhf : Continuous f\nh'f : HasCompactMulSupport f\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function with compact support is strongly measurable. -/\n@[to_additive]\ntheorem _root_.Continuous.stronglyMeasurable_of_hasCompactMulSupport\n    [MeasurableSpace Î±] [TopologicalSpace Î±] [OpensMeasurableSpace Î±] [MeasurableSpace Î²]\n    [TopologicalSpace Î²] [PseudoMetrizableSpace Î²] [BorelSpace Î²] [One Î²] {f : Î± â†’ Î²}\n    (hf : Continuous f) (h'f : HasCompactMulSupport f) : StronglyMeasurable f :=\n  hf.stronglyMeasurable_of_mulSupport_subset_isCompact h'f (subset_mulTSupport f)\n\n"}
{"name":"HasCompactSupport.stronglyMeasurable_of_prod","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nX : Type u_5\nY : Type u_6\ninstâœâ¸ : Zero Î±\ninstâœâ· : TopologicalSpace X\ninstâœâ¶ : TopologicalSpace Y\ninstâœâµ : MeasurableSpace X\ninstâœâ´ : MeasurableSpace Y\ninstâœÂ³ : OpensMeasurableSpace X\ninstâœÂ² : OpensMeasurableSpace Y\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace.PseudoMetrizableSpace Î±\nf : Prod X Y â†’ Î±\nhf : Continuous f\nh'f : HasCompactSupport f\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- A continuous function with compact support on a product space is strongly measurable for the\nproduct sigma-algebra. The subtlety is that we do not assume that the spaces are separable, so the\nproduct of the Borel sigma algebras might not contain all open sets, but still it contains enough\nof them to approximate compactly supported continuous functions. -/\nlemma _root_.HasCompactSupport.stronglyMeasurable_of_prod {X Y : Type*} [Zero Î±]\n    [TopologicalSpace X] [TopologicalSpace Y] [MeasurableSpace X] [MeasurableSpace Y]\n    [OpensMeasurableSpace X] [OpensMeasurableSpace Y] [TopologicalSpace Î±] [PseudoMetrizableSpace Î±]\n    {f : X Ã— Y â†’ Î±} (hf : Continuous f) (h'f : HasCompactSupport f) :\n    StronglyMeasurable f := by\n  borelize Î±\n  apply stronglyMeasurable_iff_measurable_separable.2 âŸ¨h'f.measurable_of_prod hf, ?_âŸ©\n  letI : PseudoMetricSpace Î± := pseudoMetrizableSpacePseudoMetric Î±\n  exact IsCompact.isSeparable (s := range f) (h'f.isCompact_range hf)\n\n"}
{"name":"Embedding.comp_stronglyMeasurable_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : TopologicalSpace.PseudoMetrizableSpace Î³\ng : Î² â†’ Î³\nf : Î± â†’ Î²\nhg : Topology.IsEmbedding g\nâŠ¢ Iff (MeasureTheory.StronglyMeasurable fun x => g (f x)) (MeasureTheory.StronglyMeasurable f)","decl":"/-- If `g` is a topological embedding, then `f` is strongly measurable iff `g âˆ˜ f` is. -/\ntheorem _root_.Embedding.comp_stronglyMeasurable_iff {m : MeasurableSpace Î±} [TopologicalSpace Î²]\n    [PseudoMetrizableSpace Î²] [TopologicalSpace Î³] [PseudoMetrizableSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²}\n    (hg : IsEmbedding g) : (StronglyMeasurable fun x => g (f x)) â†” StronglyMeasurable f := by\n  letI := pseudoMetrizableSpacePseudoMetric Î³\n  borelize Î² Î³\n  refine\n    âŸ¨fun H => stronglyMeasurable_iff_measurable_separable.2 âŸ¨?_, ?_âŸ©, fun H =>\n      hg.continuous.comp_stronglyMeasurable HâŸ©\n  Â· let G : Î² â†’ range g := rangeFactorization g\n    have hG : IsClosedEmbedding G :=\n      { hg.codRestrict _ _ with\n        isClosed_range := by\n          rw [surjective_onto_range.range_eq]\n          exact isClosed_univ }\n    have : Measurable (G âˆ˜ f) := Measurable.subtype_mk H.measurable\n    exact hG.measurableEmbedding.measurable_comp_iff.1 this\n  Â· have : IsSeparable (g â»Â¹' range (g âˆ˜ f)) := hg.isSeparable_preimage H.isSeparable_range\n    rwa [range_comp, hg.injective.preimage_image] at this\n\n"}
{"name":"stronglyMeasurable_of_tendsto","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_5\nm : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\nu : Filter Î¹\ninstâœÂ¹ : u.NeBot\ninstâœ : u.IsCountablyGenerated\nf : Î¹ â†’ Î± â†’ Î²\ng : Î± â†’ Î²\nhf : âˆ€ (i : Î¹), MeasureTheory.StronglyMeasurable (f i)\nlim : Filter.Tendsto f u (nhds g)\nâŠ¢ MeasureTheory.StronglyMeasurable g","decl":"/-- A sequential limit of strongly measurable functions is strongly measurable. -/\ntheorem _root_.stronglyMeasurable_of_tendsto {Î¹ : Type*} {m : MeasurableSpace Î±}\n    [TopologicalSpace Î²] [PseudoMetrizableSpace Î²] (u : Filter Î¹) [NeBot u] [IsCountablyGenerated u]\n    {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ i, StronglyMeasurable (f i)) (lim : Tendsto f u (ğ“ g)) :\n    StronglyMeasurable g := by\n  borelize Î²\n  refine stronglyMeasurable_iff_measurable_separable.2 âŸ¨?_, ?_âŸ©\n  Â· exact measurable_of_tendsto_metrizable' u (fun i => (hf i).measurable) lim\n  Â· rcases u.exists_seq_tendsto with âŸ¨v, hvâŸ©\n    have : IsSeparable (closure (â‹ƒ i, range (f (v i)))) :=\n      .closure <| .iUnion fun i => (hf (v i)).isSeparable_range\n    apply this.mono\n    rintro _ âŸ¨x, rflâŸ©\n    rw [tendsto_pi_nhds] at lim\n    apply mem_closure_of_tendsto ((lim x).comp hv)\n    filter_upwards with n\n    apply mem_iUnion_of_mem n\n    exact mem_range_self _\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.piecewise","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nm : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\ns : Set Î±\nxâœ : DecidablePred fun x => Membership.mem s x\nhs : MeasurableSet s\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable (s.piecewise f g)","decl":"protected theorem piecewise {m : MeasurableSpace Î±} [TopologicalSpace Î²] {s : Set Î±}\n    {_ : DecidablePred (Â· âˆˆ s)} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable (Set.piecewise s f g) := by\n  refine âŸ¨fun n => SimpleFunc.piecewise s hs (hf.approx n) (hg.approx n), fun x => ?_âŸ©\n  by_cases hx : x âˆˆ s\n  Â· simpa [@Set.piecewise_eq_of_mem _ _ _ _ _ (fun _ => Classical.propDecidable _) _ hx,\n      hx] using hf.tendsto_approx x\n  Â· simpa [@Set.piecewise_eq_of_not_mem _ _ _ _ _ (fun _ => Classical.propDecidable _) _ hx,\n      hx] using hg.tendsto_approx x\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Î± â†’ Î²\nxâœÂ¹ : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\np : Î± â†’ Prop\nxâœ : DecidablePred p\nhp : MeasurableSet (setOf fun a => p a)\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => ite (p x) (f x) (g x)","decl":"/-- this is slightly different from `StronglyMeasurable.piecewise`. It can be used to show\n`StronglyMeasurable (ite (x=0) 0 1)` by\n`exact StronglyMeasurable.ite (measurableSet_singleton 0) stronglyMeasurable_const\nstronglyMeasurable_const`, but replacing `StronglyMeasurable.ite` by\n`StronglyMeasurable.piecewise` in that example proof does not work. -/\nprotected theorem ite {_ : MeasurableSpace Î±} [TopologicalSpace Î²] {p : Î± â†’ Prop}\n    {_ : DecidablePred p} (hp : MeasurableSet { a : Î± | p a }) (hf : StronglyMeasurable f)\n    (hg : StronglyMeasurable g) : StronglyMeasurable fun x => ite (p x) (f x) (g x) :=\n  StronglyMeasurable.piecewise hp hf hg\n\n"}
{"name":"MeasurableEmbedding.stronglyMeasurable_extend","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ng : Î± â†’ Î³\ng' : Î³ â†’ Î²\nmÎ± : MeasurableSpace Î±\nmÎ³ : MeasurableSpace Î³\ninstâœ : TopologicalSpace Î²\nhg : MeasurableEmbedding g\nhf : MeasureTheory.StronglyMeasurable f\nhg' : MeasureTheory.StronglyMeasurable g'\nâŠ¢ MeasureTheory.StronglyMeasurable (Function.extend g f g')","decl":"@[measurability]\ntheorem _root_.MeasurableEmbedding.stronglyMeasurable_extend {f : Î± â†’ Î²} {g : Î± â†’ Î³} {g' : Î³ â†’ Î²}\n    {mÎ± : MeasurableSpace Î±} {mÎ³ : MeasurableSpace Î³} [TopologicalSpace Î²]\n    (hg : MeasurableEmbedding g) (hf : StronglyMeasurable f) (hg' : StronglyMeasurable g') :\n    StronglyMeasurable (Function.extend g f g') := by\n  refine âŸ¨fun n => SimpleFunc.extend (hf.approx n) g hg (hg'.approx n), ?_âŸ©\n  intro x\n  by_cases hx : âˆƒ y, g y = x\n  Â· rcases hx with âŸ¨y, rflâŸ©\n    simpa only [SimpleFunc.extend_apply, hg.injective, Injective.extend_apply] using\n      hf.tendsto_approx y\n  Â· simpa only [hx, SimpleFunc.extend_apply', not_false_iff, extend_apply'] using\n      hg'.tendsto_approx x\n\n"}
{"name":"MeasurableEmbedding.exists_stronglyMeasurable_extend","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nxâœÂ¹ : MeasurableSpace Î±\nxâœ : MeasurableSpace Î³\ninstâœ : TopologicalSpace Î²\nhg : MeasurableEmbedding g\nhf : MeasureTheory.StronglyMeasurable f\nhne : Î³ â†’ Nonempty Î²\nâŠ¢ Exists fun f' => And (MeasureTheory.StronglyMeasurable f') (Eq (Function.comp f' g) f)","decl":"theorem _root_.MeasurableEmbedding.exists_stronglyMeasurable_extend {f : Î± â†’ Î²} {g : Î± â†’ Î³}\n    {_ : MeasurableSpace Î±} {_ : MeasurableSpace Î³} [TopologicalSpace Î²]\n    (hg : MeasurableEmbedding g) (hf : StronglyMeasurable f) (hne : Î³ â†’ Nonempty Î²) :\n    âˆƒ f' : Î³ â†’ Î², StronglyMeasurable f' âˆ§ f' âˆ˜ g = f :=\n  âŸ¨Function.extend g f fun x => Classical.choice (hne x),\n    hg.stronglyMeasurable_extend hf (stronglyMeasurable_const' fun _ _ => rfl),\n    funext fun _ => hg.injective.extend_apply _ _ _âŸ©\n\n"}
{"name":"stronglyMeasurable_of_stronglyMeasurable_union_cover","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\ns t : Set Î±\nhs : MeasurableSet s\nht : MeasurableSet t\nh : HasSubset.Subset Set.univ (Union.union s t)\nhc : MeasureTheory.StronglyMeasurable fun a => f â†‘a\nhd : MeasureTheory.StronglyMeasurable fun a => f â†‘a\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"theorem _root_.stronglyMeasurable_of_stronglyMeasurable_union_cover {m : MeasurableSpace Î±}\n    [TopologicalSpace Î²] {f : Î± â†’ Î²} (s t : Set Î±) (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h : univ âŠ† s âˆª t) (hc : StronglyMeasurable fun a : s => f a)\n    (hd : StronglyMeasurable fun a : t => f a) : StronglyMeasurable f := by\n  nontriviality Î²; inhabit Î²\n  suffices Function.extend Subtype.val (fun x : s â†¦ f x)\n      (Function.extend (â†‘) (fun x : t â†¦ f x) fun _ â†¦ default) = f from\n    this â–¸ (MeasurableEmbedding.subtype_coe hs).stronglyMeasurable_extend hc <|\n      (MeasurableEmbedding.subtype_coe ht).stronglyMeasurable_extend hd stronglyMeasurable_const\n  ext x\n  by_cases hxs : x âˆˆ s\n  Â· lift x to s using hxs\n    simp [Subtype.coe_injective.extend_apply]\n  Â· lift x to t using (h trivial).resolve_left hxs\n    rw [extend_apply', Subtype.coe_injective.extend_apply]\n    exact fun âŸ¨y, hyâŸ© â†¦ hxs <| hy â–¸ y.2\n\n"}
{"name":"stronglyMeasurable_of_restrict_of_restrict_compl","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nxâœ : MeasurableSpace Î±\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\ns : Set Î±\nhs : MeasurableSet s\nhâ‚ : MeasureTheory.StronglyMeasurable (s.restrict f)\nhâ‚‚ : MeasureTheory.StronglyMeasurable ((HasCompl.compl s).restrict f)\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"theorem _root_.stronglyMeasurable_of_restrict_of_restrict_compl {_ : MeasurableSpace Î±}\n    [TopologicalSpace Î²] {f : Î± â†’ Î²} {s : Set Î±} (hs : MeasurableSet s)\n    (hâ‚ : StronglyMeasurable (s.restrict f)) (hâ‚‚ : StronglyMeasurable (sá¶œ.restrict f)) :\n    StronglyMeasurable f :=\n  stronglyMeasurable_of_stronglyMeasurable_union_cover s sá¶œ hs hs.compl (union_compl_self s).ge hâ‚\n    hâ‚‚\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.indicator","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nxâœ : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : Zero Î²\nhf : MeasureTheory.StronglyMeasurable f\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.StronglyMeasurable (s.indicator f)","decl":"@[measurability]\nprotected theorem indicator {_ : MeasurableSpace Î±} [TopologicalSpace Î²] [Zero Î²]\n    (hf : StronglyMeasurable f) {s : Set Î±} (hs : MeasurableSet s) :\n    StronglyMeasurable (s.indicator f) :=\n  hf.piecewise hs stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.dist","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nxâœ : MeasurableSpace Î±\nÎ² : Type u_5\ninstâœ : PseudoMetricSpace Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => Dist.dist (f x) (g x)","decl":"@[aesop safe 20 apply (rule_sets := [Measurable])]\nprotected theorem dist {_ : MeasurableSpace Î±} {Î² : Type*} [PseudoMetricSpace Î²] {f g : Î± â†’ Î²}\n    (hf : StronglyMeasurable f) (hg : StronglyMeasurable g) :\n    StronglyMeasurable fun x => dist (f x) (g x) :=\n  continuous_dist.comp_stronglyMeasurable (hf.prod_mk hg)\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.norm","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nxâœ : MeasurableSpace Î±\nÎ² : Type u_5\ninstâœ : SeminormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => Norm.norm (f x)","decl":"@[measurability]\nprotected theorem norm {_ : MeasurableSpace Î±} {Î² : Type*} [SeminormedAddCommGroup Î²] {f : Î± â†’ Î²}\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => â€–f xâ€– :=\n  continuous_norm.comp_stronglyMeasurable hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.nnnorm","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nxâœ : MeasurableSpace Î±\nÎ² : Type u_5\ninstâœ : SeminormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => NNNorm.nnnorm (f x)","decl":"@[measurability]\nprotected theorem nnnorm {_ : MeasurableSpace Î±} {Î² : Type*} [SeminormedAddCommGroup Î²] {f : Î± â†’ Î²}\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => â€–f xâ€–â‚Š :=\n  continuous_nnnorm.comp_stronglyMeasurable hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.enorm","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nxâœ : MeasurableSpace Î±\nÎ² : Type u_5\ninstâœ : SeminormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Measurable fun x => ENorm.enorm (f x)","decl":"@[measurability]\nprotected theorem enorm {_ : MeasurableSpace Î±} {Î² : Type*} [SeminormedAddCommGroup Î²]\n    {f : Î± â†’ Î²} (hf : StronglyMeasurable f) : Measurable (â€–f Â·â€–â‚‘) :=\n  (ENNReal.continuous_coe.comp_stronglyMeasurable hf.nnnorm).measurable\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ennnorm","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nxâœ : MeasurableSpace Î±\nÎ² : Type u_5\ninstâœ : SeminormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Measurable fun x => ENorm.enorm (f x)","decl":"@[deprecated (since := \"2025-01-21\")] alias ennnorm := StronglyMeasurable.enorm\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.real_toNNReal","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nxâœ : MeasurableSpace Î±\nf : Î± â†’ Real\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => (f x).toNNReal","decl":"@[measurability]\nprotected theorem real_toNNReal {_ : MeasurableSpace Î±} {f : Î± â†’ â„} (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun x => (f x).toNNReal :=\n  continuous_real_toNNReal.comp_stronglyMeasurable hf\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_le","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nE : Type u_5\nm : MeasurableSpace Î±\nf g : Î± â†’ E\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : Preorder E\ninstâœÂ¹ : OrderClosedTopology E\ninstâœ : TopologicalSpace.PseudoMetrizableSpace E\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasurableSet (setOf fun a => LE.le (f a) (g a))","decl":"lemma measurableSet_le (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    MeasurableSet[m] {a | f a â‰¤ g a} := by\n  borelize (E Ã— E)\n  exact (hf.prod_mk hg).measurable isClosed_le_prod.measurableSet\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_lt","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nE : Type u_5\nm : MeasurableSpace Î±\nf g : Î± â†’ E\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : Preorder E\ninstâœÂ¹ : OrderClosedTopology E\ninstâœ : TopologicalSpace.PseudoMetrizableSpace E\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasurableSet (setOf fun a => LT.lt (f a) (g a))","decl":"lemma measurableSet_lt (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    MeasurableSet[m] {a | f a < g a} := by\n  simpa only [lt_iff_le_not_le] using (hf.measurableSet_le hg).inter (hg.measurableSet_le hf).compl\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ae_le_trim_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nE : Type u_5\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : Preorder E\ninstâœÂ¹ : OrderClosedTopology E\ninstâœ : TopologicalSpace.PseudoMetrizableSpace E\nhm : LE.le m mâ‚€\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nhfg : (MeasureTheory.ae Î¼).EventuallyLE f g\nâŠ¢ (MeasureTheory.ae (Î¼.trim hm)).EventuallyLE f g","decl":"lemma ae_le_trim_of_stronglyMeasurable (hm : m â‰¤ mâ‚€) (hf : StronglyMeasurable[m] f)\n    (hg : StronglyMeasurable[m] g) (hfg : f â‰¤áµ[Î¼] g) : f â‰¤áµ[Î¼.trim hm] g := by\n  rwa [EventuallyLE, ae_iff, trim_measurableSet_eq hm]\n  exact (hf.measurableSet_le hg).compl\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ae_le_trim_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nE : Type u_5\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : Preorder E\ninstâœÂ¹ : OrderClosedTopology E\ninstâœ : TopologicalSpace.PseudoMetrizableSpace E\nhm : LE.le m mâ‚€\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ Iff ((MeasureTheory.ae (Î¼.trim hm)).EventuallyLE f g) ((MeasureTheory.ae Î¼).EventuallyLE f g)","decl":"lemma ae_le_trim_iff (hm : m â‰¤ mâ‚€) (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    f â‰¤áµ[Î¼.trim hm] g â†” f â‰¤áµ[Î¼] g :=\n  âŸ¨ae_le_of_ae_le_trim, ae_le_trim_of_stronglyMeasurable hm hf hgâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.measurableSet_eq_fun","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nE : Type u_5\nm : MeasurableSpace Î±\nf g : Î± â†’ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalSpace.MetrizableSpace E\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ MeasurableSet (setOf fun a => Eq (f a) (g a))","decl":"lemma measurableSet_eq_fun (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    MeasurableSet[m] {a | f a = g a} := by\n  borelize (E Ã— E)\n  exact (hf.prod_mk hg).measurable isClosed_diagonal.measurableSet\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ae_eq_trim_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nE : Type u_5\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalSpace.MetrizableSpace E\nhm : LE.le m mâ‚€\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nhfg : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ (MeasureTheory.ae (Î¼.trim hm)).EventuallyEq f g","decl":"lemma ae_eq_trim_of_stronglyMeasurable (hm : m â‰¤ mâ‚€) (hf : StronglyMeasurable[m] f)\n    (hg : StronglyMeasurable[m] g) (hfg : f =áµ[Î¼] g) : f =áµ[Î¼.trim hm] g := by\n  rwa [EventuallyEq, ae_iff, trim_measurableSet_eq hm]\n  exact (hf.measurableSet_eq_fun hg).compl\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.ae_eq_trim_iff","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nE : Type u_5\nm mâ‚€ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalSpace.MetrizableSpace E\nhm : LE.le m mâ‚€\nhf : MeasureTheory.StronglyMeasurable f\nhg : MeasureTheory.StronglyMeasurable g\nâŠ¢ Iff ((MeasureTheory.ae (Î¼.trim hm)).EventuallyEq f g) ((MeasureTheory.ae Î¼).EventuallyEq f g)","decl":"lemma ae_eq_trim_iff (hm : m â‰¤ mâ‚€) (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    f =áµ[Î¼.trim hm] g â†” f =áµ[Î¼] g :=\n  âŸ¨ae_eq_of_ae_eq_trim, ae_eq_trim_of_stronglyMeasurable hm hf hgâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.stronglyMeasurable_in_set","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : Zero Î²\ns : Set Î±\nf : Î± â†’ Î²\nhs : MeasurableSet s\nhf : MeasureTheory.StronglyMeasurable f\nhf_zero : âˆ€ (x : Î±), Not (Membership.mem s x) â†’ Eq (f x) 0\nâŠ¢ Exists fun fs => And (âˆ€ (x : Î±), Filter.Tendsto (fun n => (fs n) x) Filter.atTop (nhds (f x))) (âˆ€ (x : Î±), Not (Membership.mem s x) â†’ âˆ€ (n : Nat), Eq ((fs n) x) 0)","decl":"theorem stronglyMeasurable_in_set {m : MeasurableSpace Î±} [TopologicalSpace Î²] [Zero Î²] {s : Set Î±}\n    {f : Î± â†’ Î²} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hf_zero : âˆ€ x, x âˆ‰ s â†’ f x = 0) :\n    âˆƒ fs : â„• â†’ Î± â†’â‚› Î²,\n      (âˆ€ x, Tendsto (fun n => fs n x) atTop (ğ“ (f x))) âˆ§ âˆ€ x âˆ‰ s, âˆ€ n, fs n x = 0 := by\n  let g_seq_s : â„• â†’ @SimpleFunc Î± m Î² := fun n => (hf.approx n).restrict s\n  have hg_eq : âˆ€ x âˆˆ s, âˆ€ n, g_seq_s n x = hf.approx n x := by\n    intro x hx n\n    rw [SimpleFunc.coe_restrict _ hs, Set.indicator_of_mem hx]\n  have hg_zero : âˆ€ x âˆ‰ s, âˆ€ n, g_seq_s n x = 0 := by\n    intro x hx n\n    rw [SimpleFunc.coe_restrict _ hs, Set.indicator_of_not_mem hx]\n  refine âŸ¨g_seq_s, fun x => ?_, hg_zeroâŸ©\n  by_cases hx : x âˆˆ s\n  Â· simp_rw [hg_eq x hx]\n    exact hf.tendsto_approx x\n  Â· simp_rw [hg_zero x hx, hf_zero x hx]\n    exact tendsto_const_nhds\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.stronglyMeasurable_of_measurableSpace_le_on","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_5\nE : Type u_6\nm mâ‚‚ : MeasurableSpace Î±\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Zero E\ns : Set Î±\nf : Î± â†’ E\nhs_m : MeasurableSet s\nhs : âˆ€ (t : Set Î±), MeasurableSet (Inter.inter s t) â†’ MeasurableSet (Inter.inter s t)\nhf : MeasureTheory.StronglyMeasurable f\nhf_zero : âˆ€ (x : Î±), Not (Membership.mem s x) â†’ Eq (f x) 0\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- If the restriction to a set `s` of a Ïƒ-algebra `m` is included in the restriction to `s` of\nanother Ïƒ-algebra `mâ‚‚` (hypothesis `hs`), the set `s` is `m` measurable and a function `f` supported\non `s` is `m`-strongly-measurable, then `f` is also `mâ‚‚`-strongly-measurable. -/\ntheorem stronglyMeasurable_of_measurableSpace_le_on {Î± E} {m mâ‚‚ : MeasurableSpace Î±}\n    [TopologicalSpace E] [Zero E] {s : Set Î±} {f : Î± â†’ E} (hs_m : MeasurableSet[m] s)\n    (hs : âˆ€ t, MeasurableSet[m] (s âˆ© t) â†’ MeasurableSet[mâ‚‚] (s âˆ© t))\n    (hf : StronglyMeasurable[m] f) (hf_zero : âˆ€ x âˆ‰ s, f x = 0) :\n    StronglyMeasurable[mâ‚‚] f := by\n  have hs_mâ‚‚ : MeasurableSet[mâ‚‚] s := by\n    rw [â† Set.inter_univ s]\n    refine hs Set.univ ?_\n    rwa [Set.inter_univ]\n  obtain âŸ¨g_seq_s, hg_seq_tendsto, hg_seq_zeroâŸ© := stronglyMeasurable_in_set hs_m hf hf_zero\n  let g_seq_sâ‚‚ : â„• â†’ @SimpleFunc Î± mâ‚‚ E := fun n =>\n    { toFun := g_seq_s n\n      measurableSet_fiber' := fun x => by\n        rw [â† Set.inter_univ (g_seq_s n â»Â¹' {x}), â† Set.union_compl_self s,\n          Set.inter_union_distrib_left, Set.inter_comm (g_seq_s n â»Â¹' {x})]\n        refine MeasurableSet.union (hs _ (hs_m.inter ?_)) ?_\n        Â· exact @SimpleFunc.measurableSet_fiber _ _ m _ _\n        by_cases hx : x = 0\n        Â· suffices g_seq_s n â»Â¹' {x} âˆ© sá¶œ = sá¶œ by\n            rw [this]\n            exact hs_mâ‚‚.compl\n          ext1 y\n          rw [hx, Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n          exact âŸ¨fun h => h.2, fun h => âŸ¨hg_seq_zero y h n, hâŸ©âŸ©\n        Â· suffices g_seq_s n â»Â¹' {x} âˆ© sá¶œ = âˆ… by\n            rw [this]\n            exact MeasurableSet.empty\n          ext1 y\n          simp only [mem_inter_iff, mem_preimage, mem_singleton_iff, mem_compl_iff,\n            mem_empty_iff_false, iff_false, not_and, not_not_mem]\n          refine Function.mtr fun hys => ?_\n          rw [hg_seq_zero y hys n]\n          exact Ne.symm hx\n      finite_range' := @SimpleFunc.finite_range _ _ m (g_seq_s n) }\n  exact âŸ¨g_seq_sâ‚‚, hg_seq_tendstoâŸ©\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.exists_spanning_measurableSet_norm_le","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\ninstâœÂ¹ : SeminormedAddCommGroup Î²\nm m0 : MeasurableSpace Î±\nhm : LE.le m m0\nhf : MeasureTheory.StronglyMeasurable f\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nâŠ¢ Exists fun s => And (âˆ€ (n : Nat), And (MeasurableSet (s n)) (And (LT.lt (Î¼ (s n)) Top.top) (âˆ€ (x : Î±), Membership.mem (s n) x â†’ LE.le (Norm.norm (f x)) â†‘n))) (Eq (Set.iUnion fun i => s i) Set.univ)","decl":"/-- If a function `f` is strongly measurable w.r.t. a sub-Ïƒ-algebra `m` and the measure is Ïƒ-finite\non `m`, then there exists spanning measurable sets with finite measure on which `f` has bounded\nnorm. In particular, `f` is integrable on each of those sets. -/\ntheorem exists_spanning_measurableSet_norm_le [SeminormedAddCommGroup Î²] {m m0 : MeasurableSpace Î±}\n    (hm : m â‰¤ m0) (hf : StronglyMeasurable[m] f) (Î¼ : Measure Î±) [SigmaFinite (Î¼.trim hm)] :\n    âˆƒ s : â„• â†’ Set Î±,\n      (âˆ€ n, MeasurableSet[m] (s n) âˆ§ Î¼ (s n) < âˆ âˆ§ âˆ€ x âˆˆ s n, â€–f xâ€– â‰¤ n) âˆ§\n      â‹ƒ i, s i = Set.univ := by\n  obtain âŸ¨s, hs, hs_univâŸ© :=\n    @exists_spanning_measurableSet_le _ m _ hf.nnnorm.measurable (Î¼.trim hm) _\n  refine âŸ¨s, fun n â†¦ âŸ¨(hs n).1, (le_trim hm).trans_lt (hs n).2.1, fun x hx â†¦ ?_âŸ©, hs_univâŸ©\n  have hx_nnnorm : â€–f xâ€–â‚Š â‰¤ n := (hs n).2.2 x hx\n  rw [â† coe_nnnorm]\n  norm_cast\n\n"}
{"name":"MeasureTheory.finStronglyMeasurable_zero","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î²\nâŠ¢ MeasureTheory.FinStronglyMeasurable 0 Î¼","decl":"theorem finStronglyMeasurable_zero {Î± Î²} {m : MeasurableSpace Î±} {Î¼ : Measure Î±} [Zero Î²]\n    [TopologicalSpace Î²] : FinStronglyMeasurable (0 : Î± â†’ Î²) Î¼ :=\n  âŸ¨0, by\n    simp only [Pi.zero_apply, SimpleFunc.coe_zero, support_zero', measure_empty,\n      zero_lt_top, forall_const],\n    fun _ => tendsto_const_nhdsâŸ©\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.fin_support_approx","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nn : Nat\nâŠ¢ LT.lt (Î¼ (Function.support â‡‘(hf.approx n))) Top.top","decl":"protected theorem fin_support_approx : âˆ€ n, Î¼ (support (hf.approx n)) < âˆ :=\n  hf.choose_spec.1\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.tendsto_approx","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nx : Î±\nâŠ¢ Filter.Tendsto (fun n => (hf.approx n) x) Filter.atTop (nhds (f x))","decl":"protected theorem tendsto_approx : âˆ€ x, Tendsto (fun n => hf.approx n x) atTop (ğ“ (f x)) :=\n  hf.choose_spec.2\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nâŠ¢ MeasureTheory.StronglyMeasurable f","decl":"/-- A finitely strongly measurable function is strongly measurable. -/\n@[aesop 5% apply (rule_sets := [Measurable])]\nprotected theorem stronglyMeasurable [Zero Î²] [TopologicalSpace Î²]\n    (hf : FinStronglyMeasurable f Î¼) : StronglyMeasurable f :=\n  âŸ¨hf.approx, hf.tendsto_approxâŸ©\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.exists_set_sigmaFinite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : T2Space Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nâŠ¢ Exists fun t => And (MeasurableSet t) (And (âˆ€ (x : Î±), Membership.mem (HasCompl.compl t) x â†’ Eq (f x) 0) (MeasureTheory.SigmaFinite (Î¼.restrict t)))","decl":"theorem exists_set_sigmaFinite [Zero Î²] [TopologicalSpace Î²] [T2Space Î²]\n    (hf : FinStronglyMeasurable f Î¼) :\n    âˆƒ t, MeasurableSet t âˆ§ (âˆ€ x âˆˆ tá¶œ, f x = 0) âˆ§ SigmaFinite (Î¼.restrict t) := by\n  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©\n  let T n := support (fs n)\n  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)\n  let t := â‹ƒ n, T n\n  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©\n  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by\n      intro n x hxt\n      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt\n      simpa [T] using hxt n\n    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_\n    rw [funext fun n => h_fs_zero n x hxt]\n    exact tendsto_const_nhds\n  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©\n    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,\n        Set.compl_inter_self t, Set.empty_union]\n      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)\n    Â· rw [â† Set.union_iUnion tá¶œ T]\n      exact Set.compl_union_self _\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\ninstâœâ´ : Zero Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nâŠ¢ Measurable f","decl":"/-- A finitely strongly measurable function is measurable. -/\nprotected theorem measurable [Zero Î²] [TopologicalSpace Î²] [PseudoMetrizableSpace Î²]\n    [MeasurableSpace Î²] [BorelSpace Î²] (hf : FinStronglyMeasurable f Î¼) : Measurable f :=\n  hf.stronglyMeasurable.measurable\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.mul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : MonoidWithZero Î²\ninstâœ : ContinuousMul Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nhg : MeasureTheory.FinStronglyMeasurable g Î¼\nâŠ¢ MeasureTheory.FinStronglyMeasurable (HMul.hMul f g) Î¼","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem mul [MonoidWithZero Î²] [ContinuousMul Î²] (hf : FinStronglyMeasurable f Î¼)\n    (hg : FinStronglyMeasurable g Î¼) : FinStronglyMeasurable (f * g) Î¼ := by\n  refine\n    âŸ¨fun n => hf.approx n * hg.approx n, ?_, fun x =>\n      (hf.tendsto_approx x).mul (hg.tendsto_approx x)âŸ©\n  intro n\n  exact (measure_mono (support_mul_subset_left _ _)).trans_lt (hf.fin_support_approx n)\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.add","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : AddMonoid Î²\ninstâœ : ContinuousAdd Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nhg : MeasureTheory.FinStronglyMeasurable g Î¼\nâŠ¢ MeasureTheory.FinStronglyMeasurable (HAdd.hAdd f g) Î¼","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem add [AddMonoid Î²] [ContinuousAdd Î²] (hf : FinStronglyMeasurable f Î¼)\n    (hg : FinStronglyMeasurable g Î¼) : FinStronglyMeasurable (f + g) Î¼ :=\n  âŸ¨fun n => hf.approx n + hg.approx n, fun n =>\n    (measure_mono (Function.support_add _ _)).trans_lt\n      ((measure_union_le _ _).trans_lt\n        (ENNReal.add_lt_top.mpr âŸ¨hf.fin_support_approx n, hg.fin_support_approx nâŸ©)),\n    fun x => (hf.tendsto_approx x).add (hg.tendsto_approx x)âŸ©\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.neg","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : AddGroup Î²\ninstâœ : TopologicalAddGroup Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nâŠ¢ MeasureTheory.FinStronglyMeasurable (Neg.neg f) Î¼","decl":"@[measurability]\nprotected theorem neg [AddGroup Î²] [TopologicalAddGroup Î²] (hf : FinStronglyMeasurable f Î¼) :\n    FinStronglyMeasurable (-f) Î¼ := by\n  refine âŸ¨fun n => -hf.approx n, fun n => ?_, fun x => (hf.tendsto_approx x).negâŸ©\n  suffices Î¼ (Function.support fun x => -(hf.approx n) x) < âˆ by convert this\n  rw [Function.support_neg (hf.approx n)]\n  exact hf.fin_support_approx n\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.sub","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : AddGroup Î²\ninstâœ : ContinuousSub Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nhg : MeasureTheory.FinStronglyMeasurable g Î¼\nâŠ¢ MeasureTheory.FinStronglyMeasurable (HSub.hSub f g) Î¼","decl":"@[measurability]\nprotected theorem sub [AddGroup Î²] [ContinuousSub Î²] (hf : FinStronglyMeasurable f Î¼)\n    (hg : FinStronglyMeasurable g Î¼) : FinStronglyMeasurable (f - g) Î¼ :=\n  âŸ¨fun n => hf.approx n - hg.approx n, fun n =>\n    (measure_mono (Function.support_sub _ _)).trans_lt\n      ((measure_union_le _ _).trans_lt\n        (ENNReal.add_lt_top.mpr âŸ¨hf.fin_support_approx n, hg.fin_support_approx nâŸ©)),\n    fun x => (hf.tendsto_approx x).sub (hg.tendsto_approx x)âŸ©\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.const_smul","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\ninstâœâµ : TopologicalSpace Î²\nğ•œ : Type u_5\ninstâœâ´ : TopologicalSpace ğ•œ\ninstâœÂ³ : AddMonoid Î²\ninstâœÂ² : Monoid ğ•œ\ninstâœÂ¹ : DistribMulAction ğ•œ Î²\ninstâœ : ContinuousSMul ğ•œ Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nc : ğ•œ\nâŠ¢ MeasureTheory.FinStronglyMeasurable (HSMul.hSMul c f) Î¼","decl":"@[measurability]\nprotected theorem const_smul {ğ•œ} [TopologicalSpace ğ•œ] [AddMonoid Î²] [Monoid ğ•œ]\n    [DistribMulAction ğ•œ Î²] [ContinuousSMul ğ•œ Î²] (hf : FinStronglyMeasurable f Î¼) (c : ğ•œ) :\n    FinStronglyMeasurable (c â€¢ f) Î¼ := by\n  refine âŸ¨fun n => c â€¢ hf.approx n, fun n => ?_, fun x => (hf.tendsto_approx x).const_smul câŸ©\n  rw [SimpleFunc.coe_smul]\n  exact (measure_mono (support_const_smul_subset c _)).trans_lt (hf.fin_support_approx n)\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.sup","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : SemilatticeSup Î²\ninstâœ : ContinuousSup Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nhg : MeasureTheory.FinStronglyMeasurable g Î¼\nâŠ¢ MeasureTheory.FinStronglyMeasurable (Max.max f g) Î¼","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem sup [SemilatticeSup Î²] [ContinuousSup Î²] (hf : FinStronglyMeasurable f Î¼)\n    (hg : FinStronglyMeasurable g Î¼) : FinStronglyMeasurable (f âŠ” g) Î¼ := by\n  refine\n    âŸ¨fun n => hf.approx n âŠ” hg.approx n, fun n => ?_, fun x =>\n      (hf.tendsto_approx x).sup_nhds (hg.tendsto_approx x)âŸ©\n  refine (measure_mono (support_sup _ _)).trans_lt ?_\n  exact measure_union_lt_top_iff.mpr âŸ¨hf.fin_support_approx n, hg.fin_support_approx nâŸ©\n\n"}
{"name":"MeasureTheory.FinStronglyMeasurable.inf","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Î²\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : SemilatticeInf Î²\ninstâœ : ContinuousInf Î²\nhf : MeasureTheory.FinStronglyMeasurable f Î¼\nhg : MeasureTheory.FinStronglyMeasurable g Î¼\nâŠ¢ MeasureTheory.FinStronglyMeasurable (Min.min f g) Î¼","decl":"@[aesop safe 20 (rule_sets := [Measurable])]\nprotected theorem inf [SemilatticeInf Î²] [ContinuousInf Î²] (hf : FinStronglyMeasurable f Î¼)\n    (hg : FinStronglyMeasurable g Î¼) : FinStronglyMeasurable (f âŠ“ g) Î¼ := by\n  refine\n    âŸ¨fun n => hf.approx n âŠ“ hg.approx n, fun n => ?_, fun x =>\n      (hf.tendsto_approx x).inf_nhds (hg.tendsto_approx x)âŸ©\n  refine (measure_mono (support_inf _ _)).trans_lt ?_\n  exact measure_union_lt_top_iff.mpr âŸ¨hf.fin_support_approx n, hg.fin_support_approx nâŸ©\n\n"}
{"name":"MeasureTheory.finStronglyMeasurable_iff_stronglyMeasurable_and_exists_set_sigmaFinite","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nf : Î± â†’ Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : T2Space Î²\ninstâœ : Zero Î²\nxâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Iff (MeasureTheory.FinStronglyMeasurable f Î¼) (And (MeasureTheory.StronglyMeasurable f) (Exists fun t => And (MeasurableSet t) (And (âˆ€ (x : Î±), Membership.mem (HasCompl.compl t) x â†’ Eq (f x) 0) (MeasureTheory.SigmaFinite (Î¼.restrict t)))))","decl":"theorem finStronglyMeasurable_iff_stronglyMeasurable_and_exists_set_sigmaFinite {Î± Î²} {f : Î± â†’ Î²}\n    [TopologicalSpace Î²] [T2Space Î²] [Zero Î²] {_ : MeasurableSpace Î±} {Î¼ : Measure Î±} :\n    FinStronglyMeasurable f Î¼ â†”\n      StronglyMeasurable f âˆ§\n        âˆƒ t, MeasurableSet t âˆ§ (âˆ€ x âˆˆ tá¶œ, f x = 0) âˆ§ SigmaFinite (Î¼.restrict t) :=\n  âŸ¨fun hf => âŸ¨hf.stronglyMeasurable, hf.exists_set_sigmaFiniteâŸ©, fun hf =>\n    hf.1.finStronglyMeasurable_of_set_sigmaFinite hf.2.choose_spec.1 hf.2.choose_spec.2.1\n      hf.2.choose_spec.2.2âŸ©\n\n"}
{"name":"MeasureTheory.finStronglyMeasurable_iff_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : BorelSpace G\ninstâœÂ¹ : SecondCountableTopology G\nf : Î± â†’ G\n_m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nâŠ¢ Iff (MeasureTheory.FinStronglyMeasurable f Î¼) (Measurable f)","decl":"/-- In a space with second countable topology and a sigma-finite measure, `FinStronglyMeasurable`\n  and `Measurable` are equivalent. -/\ntheorem finStronglyMeasurable_iff_measurable {_m0 : MeasurableSpace Î±} (Î¼ : Measure Î±)\n    [SigmaFinite Î¼] : FinStronglyMeasurable f Î¼ â†” Measurable f :=\n  âŸ¨fun h => h.measurable, fun h => (Measurable.stronglyMeasurable h).finStronglyMeasurable Î¼âŸ©\n\n"}
{"name":"MeasureTheory.finStronglyMeasurable_of_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : BorelSpace G\ninstâœÂ¹ : SecondCountableTopology G\nf : Î± â†’ G\n_m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nhf : Measurable f\nâŠ¢ MeasureTheory.FinStronglyMeasurable f Î¼","decl":"/-- In a space with second countable topology and a sigma-finite measure, a measurable function\nis `FinStronglyMeasurable`. -/\n@[aesop 90% apply (rule_sets := [Measurable])]\ntheorem finStronglyMeasurable_of_measurable {_m0 : MeasurableSpace Î±} (Î¼ : Measure Î±)\n    [SigmaFinite Î¼] (hf : Measurable f) : FinStronglyMeasurable f Î¼ :=\n  (finStronglyMeasurable_iff_measurable Î¼).mpr hf\n\n"}
{"name":"MeasureTheory.measurable_uncurry_of_continuous_of_measurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nÎ¹ : Type u_7\ninstâœâ· : TopologicalSpace Î¹\ninstâœâ¶ : TopologicalSpace.MetrizableSpace Î¹\ninstâœâµ : MeasurableSpace Î¹\ninstâœâ´ : SecondCountableTopology Î¹\ninstâœÂ³ : OpensMeasurableSpace Î¹\nmÎ² : MeasurableSpace Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœ : BorelSpace Î²\nm : MeasurableSpace Î±\nu : Î¹ â†’ Î± â†’ Î²\nhu_cont : âˆ€ (x : Î±), Continuous fun i => u i x\nh : âˆ€ (i : Î¹), Measurable (u i)\nâŠ¢ Measurable (Function.uncurry u)","decl":"theorem measurable_uncurry_of_continuous_of_measurable {Î± Î² Î¹ : Type*} [TopologicalSpace Î¹]\n    [MetrizableSpace Î¹] [MeasurableSpace Î¹] [SecondCountableTopology Î¹] [OpensMeasurableSpace Î¹]\n    {mÎ² : MeasurableSpace Î²} [TopologicalSpace Î²] [PseudoMetrizableSpace Î²] [BorelSpace Î²]\n    {m : MeasurableSpace Î±} {u : Î¹ â†’ Î± â†’ Î²} (hu_cont : âˆ€ x, Continuous fun i => u i x)\n    (h : âˆ€ i, Measurable (u i)) : Measurable (Function.uncurry u) := by\n  obtain âŸ¨t_sf, ht_sfâŸ© :\n    âˆƒ t : â„• â†’ SimpleFunc Î¹ Î¹, âˆ€ j x, Tendsto (fun n => u (t n j) x) atTop (ğ“ <| u j x) := by\n    have h_str_meas : StronglyMeasurable (id : Î¹ â†’ Î¹) := stronglyMeasurable_id\n    refine âŸ¨h_str_meas.approx, fun j x => ?_âŸ©\n    exact ((hu_cont x).tendsto j).comp (h_str_meas.tendsto_approx j)\n  let U (n : â„•) (p : Î¹ Ã— Î±) := u (t_sf n p.fst) p.snd\n  have h_tendsto : Tendsto U atTop (ğ“ fun p => u p.fst p.snd) := by\n    rw [tendsto_pi_nhds]\n    exact fun p => ht_sf p.fst p.snd\n  refine measurable_of_tendsto_metrizable (fun n => ?_) h_tendsto\n  have h_meas : Measurable fun p : (t_sf n).range Ã— Î± => u (â†‘p.fst) p.snd := by\n    have :\n      (fun p : â†¥(t_sf n).range Ã— Î± => u (â†‘p.fst) p.snd) =\n        (fun p : Î± Ã— (t_sf n).range => u (â†‘p.snd) p.fst) âˆ˜ Prod.swap :=\n      rfl\n    rw [this, @measurable_swap_iff Î± (â†¥(t_sf n).range) Î² m]\n    exact measurable_from_prod_countable fun j => h j\n  have :\n    (fun p : Î¹ Ã— Î± => u (t_sf n p.fst) p.snd) =\n      (fun p : â†¥(t_sf n).range Ã— Î± => u p.fst p.snd) âˆ˜ fun p : Î¹ Ã— Î± =>\n        (âŸ¨t_sf n p.fst, SimpleFunc.mem_range_self _ _âŸ©, p.snd) :=\n    rfl\n  simp_rw [U, this]\n  refine h_meas.comp (Measurable.prod_mk ?_ measurable_snd)\n  exact ((t_sf n).measurable.comp measurable_fst).subtype_mk\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_uncurry_of_continuous_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\nÎ¹ : Type u_7\ninstâœâ· : TopologicalSpace Î¹\ninstâœâ¶ : TopologicalSpace.MetrizableSpace Î¹\ninstâœâµ : MeasurableSpace Î¹\ninstâœâ´ : SecondCountableTopology Î¹\ninstâœÂ³ : OpensMeasurableSpace Î¹\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœ : MeasurableSpace Î±\nu : Î¹ â†’ Î± â†’ Î²\nhu_cont : âˆ€ (x : Î±), Continuous fun i => u i x\nh : âˆ€ (i : Î¹), MeasureTheory.StronglyMeasurable (u i)\nâŠ¢ MeasureTheory.StronglyMeasurable (Function.uncurry u)","decl":"theorem stronglyMeasurable_uncurry_of_continuous_of_stronglyMeasurable {Î± Î² Î¹ : Type*}\n    [TopologicalSpace Î¹] [MetrizableSpace Î¹] [MeasurableSpace Î¹] [SecondCountableTopology Î¹]\n    [OpensMeasurableSpace Î¹] [TopologicalSpace Î²] [PseudoMetrizableSpace Î²] [MeasurableSpace Î±]\n    {u : Î¹ â†’ Î± â†’ Î²} (hu_cont : âˆ€ x, Continuous fun i => u i x) (h : âˆ€ i, StronglyMeasurable (u i)) :\n    StronglyMeasurable (Function.uncurry u) := by\n  borelize Î²\n  obtain âŸ¨t_sf, ht_sfâŸ© :\n    âˆƒ t : â„• â†’ SimpleFunc Î¹ Î¹, âˆ€ j x, Tendsto (fun n => u (t n j) x) atTop (ğ“ <| u j x) := by\n    have h_str_meas : StronglyMeasurable (id : Î¹ â†’ Î¹) := stronglyMeasurable_id\n    refine âŸ¨h_str_meas.approx, fun j x => ?_âŸ©\n    exact ((hu_cont x).tendsto j).comp (h_str_meas.tendsto_approx j)\n  let U (n : â„•) (p : Î¹ Ã— Î±) := u (t_sf n p.fst) p.snd\n  have h_tendsto : Tendsto U atTop (ğ“ fun p => u p.fst p.snd) := by\n    rw [tendsto_pi_nhds]\n    exact fun p => ht_sf p.fst p.snd\n  refine stronglyMeasurable_of_tendsto _ (fun n => ?_) h_tendsto\n  have h_str_meas : StronglyMeasurable fun p : (t_sf n).range Ã— Î± => u (â†‘p.fst) p.snd := by\n    refine stronglyMeasurable_iff_measurable_separable.2 âŸ¨?_, ?_âŸ©\n    Â· have :\n        (fun p : â†¥(t_sf n).range Ã— Î± => u (â†‘p.fst) p.snd) =\n          (fun p : Î± Ã— (t_sf n).range => u (â†‘p.snd) p.fst) âˆ˜ Prod.swap :=\n        rfl\n      rw [this, measurable_swap_iff]\n      exact measurable_from_prod_countable fun j => (h j).measurable\n    Â· have : IsSeparable (â‹ƒ i : (t_sf n).range, range (u i)) :=\n        .iUnion fun i => (h i).isSeparable_range\n      apply this.mono\n      rintro _ âŸ¨âŸ¨i, xâŸ©, rflâŸ©\n      simp only [mem_iUnion, mem_range]\n      exact âŸ¨i, x, rflâŸ©\n  have :\n    (fun p : Î¹ Ã— Î± => u (t_sf n p.fst) p.snd) =\n      (fun p : â†¥(t_sf n).range Ã— Î± => u p.fst p.snd) âˆ˜ fun p : Î¹ Ã— Î± =>\n        (âŸ¨t_sf n p.fst, SimpleFunc.mem_range_self _ _âŸ©, p.snd) :=\n    rfl\n  simp_rw [U, this]\n  refine h_str_meas.comp_measurable (Measurable.prod_mk ?_ measurable_snd)\n  exact ((t_sf n).measurable.comp measurable_fst).subtype_mk\n\n"}
