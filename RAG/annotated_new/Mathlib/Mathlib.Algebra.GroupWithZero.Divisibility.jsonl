{"name":"eq_zero_of_zero_dvd","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : SemigroupWithZero α\na : α\nh : Dvd.dvd 0 a\n⊢ Eq a 0","decl":"theorem eq_zero_of_zero_dvd (h : 0 ∣ a) : a = 0 :=\n  Dvd.elim h fun c H' => H'.trans (zero_mul c)\n\n"}
{"name":"zero_dvd_iff","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : SemigroupWithZero α\na : α\n⊢ Iff (Dvd.dvd 0 a) (Eq a 0)","decl":"/-- Given an element `a` of a commutative semigroup with zero, there exists another element whose\n    product with zero equals `a` iff `a` equals zero. -/\n@[simp]\ntheorem zero_dvd_iff : 0 ∣ a ↔ a = 0 :=\n  ⟨eq_zero_of_zero_dvd, fun h => by\n    rw [h]\n    exact ⟨0, by simp⟩⟩\n\n"}
{"name":"dvd_zero","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : SemigroupWithZero α\na : α\n⊢ Dvd.dvd a 0","decl":"@[simp]\ntheorem dvd_zero (a : α) : a ∣ 0 :=\n  Dvd.intro 0 (by simp)\n\n"}
{"name":"mul_dvd_mul_iff_left","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : CancelMonoidWithZero α\na b c : α\nha : Ne a 0\n⊢ Iff (Dvd.dvd (HMul.hMul a b) (HMul.hMul a c)) (Dvd.dvd b c)","decl":"/-- Given two elements `b`, `c` of a `CancelMonoidWithZero` and a nonzero element `a`,\n `a*b` divides `a*c` iff `b` divides `c`. -/\ntheorem mul_dvd_mul_iff_left [CancelMonoidWithZero α] {a b c : α} (ha : a ≠ 0) :\n    a * b ∣ a * c ↔ b ∣ c :=\n  exists_congr fun d => by rw [mul_assoc, mul_right_inj' ha]\n\n"}
{"name":"mul_dvd_mul_iff_right","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\na b c : α\nhc : Ne c 0\n⊢ Iff (Dvd.dvd (HMul.hMul a c) (HMul.hMul b c)) (Dvd.dvd a b)","decl":"/-- Given two elements `a`, `b` of a commutative `CancelMonoidWithZero` and a nonzero\n  element `c`, `a*c` divides `b*c` iff `a` divides `b`. -/\ntheorem mul_dvd_mul_iff_right [CancelCommMonoidWithZero α] {a b c : α} (hc : c ≠ 0) :\n    a * c ∣ b * c ↔ a ∣ b :=\n  exists_congr fun d => by rw [mul_right_comm, mul_left_inj' hc]\n\n"}
{"name":"dvdNotUnit_of_dvd_of_not_dvd","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : CommMonoidWithZero α\na b : α\nhd : Dvd.dvd a b\nhnd : Not (Dvd.dvd b a)\n⊢ DvdNotUnit a b","decl":"theorem dvdNotUnit_of_dvd_of_not_dvd {a b : α} (hd : a ∣ b) (hnd : ¬b ∣ a) : DvdNotUnit a b := by\n  constructor\n  · rintro rfl\n    exact hnd (dvd_zero _)\n  · rcases hd with ⟨c, rfl⟩\n    refine ⟨c, ?_, rfl⟩\n    rintro ⟨u, rfl⟩\n    simp at hnd\n\n"}
{"name":"isRelPrime_zero_left","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : CommMonoidWithZero α\nx : α\n⊢ Iff (IsRelPrime 0 x) (IsUnit x)","decl":"theorem isRelPrime_zero_left : IsRelPrime 0 x ↔ IsUnit x :=\n  ⟨(· (dvd_zero _) dvd_rfl), IsUnit.isRelPrime_right⟩\n\n"}
{"name":"isRelPrime_zero_right","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : CommMonoidWithZero α\nx : α\n⊢ Iff (IsRelPrime x 0) (IsUnit x)","decl":"theorem isRelPrime_zero_right : IsRelPrime x 0 ↔ IsUnit x :=\n  isRelPrime_comm.trans isRelPrime_zero_left\n\n"}
{"name":"not_isRelPrime_zero_zero","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoidWithZero α\ninst✝ : Nontrivial α\n⊢ Not (IsRelPrime 0 0)","decl":"theorem not_isRelPrime_zero_zero [Nontrivial α] : ¬IsRelPrime (0 : α) 0 :=\n  mt isRelPrime_zero_right.mp not_isUnit_zero\n\n"}
{"name":"IsRelPrime.ne_zero_or_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoidWithZero α\nx y : α\ninst✝ : Nontrivial α\nh : IsRelPrime x y\n⊢ Or (Ne x 0) (Ne y 0)","decl":"theorem IsRelPrime.ne_zero_or_ne_zero [Nontrivial α] (h : IsRelPrime x y) : x ≠ 0 ∨ y ≠ 0 :=\n  not_or_of_imp <| by rintro rfl rfl; exact not_isRelPrime_zero_zero h\n\n"}
{"name":"isRelPrime_of_no_nonunits_factors","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : MonoidWithZero α\nx y : α\nnonzero : Not (And (Eq x 0) (Eq y 0))\nH : ∀ (z : α), Not (IsUnit z) → Ne z 0 → Dvd.dvd z x → Not (Dvd.dvd z y)\n⊢ IsRelPrime x y","decl":"theorem isRelPrime_of_no_nonunits_factors [MonoidWithZero α] {x y : α} (nonzero : ¬(x = 0 ∧ y = 0))\n    (H : ∀ z, ¬ IsUnit z → z ≠ 0 → z ∣ x → ¬z ∣ y) : IsRelPrime x y := by\n  refine fun z hx hy ↦ by_contra fun h ↦ H z h ?_ hx hy\n  rintro rfl; exact nonzero ⟨zero_dvd_iff.1 hx, zero_dvd_iff.1 hy⟩\n\n"}
{"name":"dvd_and_not_dvd_iff","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\nx y : α\n⊢ Iff (And (Dvd.dvd x y) (Not (Dvd.dvd y x))) (DvdNotUnit x y)","decl":"theorem dvd_and_not_dvd_iff [CancelCommMonoidWithZero α] {x y : α} :\n    x ∣ y ∧ ¬y ∣ x ↔ DvdNotUnit x y :=\n  ⟨fun ⟨⟨d, hd⟩, hyx⟩ =>\n    ⟨fun hx0 => by simp [hx0] at hyx,\n      ⟨d, mt isUnit_iff_dvd_one.1 fun ⟨e, he⟩ => hyx ⟨e, by rw [hd, mul_assoc, ← he, mul_one]⟩,\n        hd⟩⟩,\n    fun ⟨hx0, d, hdu, hdx⟩ =>\n    ⟨⟨d, hdx⟩, fun ⟨e, he⟩ =>\n      hdu\n        (isUnit_of_dvd_one\n          ⟨e, mul_left_cancel₀ hx0 <| by conv =>\n            lhs\n            rw [he, hdx]\n            simp [mul_assoc]⟩)⟩⟩\n\n"}
{"name":"ne_zero_of_dvd_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : MonoidWithZero α\np q : α\nh₁ : Ne q 0\nh₂ : Dvd.dvd p q\n⊢ Ne p 0","decl":"theorem ne_zero_of_dvd_ne_zero {p q : α} (h₁ : q ≠ 0) (h₂ : p ∣ q) : p ≠ 0 := by\n  rcases h₂ with ⟨u, rfl⟩\n  exact left_ne_zero_of_mul h₁\n\n"}
{"name":"isPrimal_zero","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : MonoidWithZero α\n⊢ IsPrimal 0","decl":"theorem isPrimal_zero : IsPrimal (0 : α) :=\n  fun a b h ↦ ⟨a, b, dvd_rfl, dvd_rfl, (zero_dvd_iff.mp h).symm⟩\n\n"}
{"name":"IsPrimal.mul","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nm n : α\nhm : IsPrimal m\nhn : IsPrimal n\n⊢ IsPrimal (HMul.hMul m n)","decl":"theorem IsPrimal.mul {α} [CancelCommMonoidWithZero α] {m n : α}\n    (hm : IsPrimal m) (hn : IsPrimal n) : IsPrimal (m * n) := by\n  obtain rfl | h0 := eq_or_ne m 0; · rwa [zero_mul]\n  intro b c h\n  obtain ⟨a₁, a₂, ⟨b, rfl⟩, ⟨c, rfl⟩, rfl⟩ := hm (dvd_of_mul_right_dvd h)\n  rw [mul_mul_mul_comm, mul_dvd_mul_iff_left h0] at h\n  obtain ⟨a₁', a₂', h₁, h₂, rfl⟩ := hn h\n  exact ⟨a₁ * a₁', a₂ * a₂', mul_dvd_mul_left _ h₁, mul_dvd_mul_left _ h₂, mul_mul_mul_comm _ _ _ _⟩\n\n"}
{"name":"dvd_antisymm","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\na b : α\ninst✝ : Subsingleton (Units α)\na✝¹ : Dvd.dvd a b\na✝ : Dvd.dvd b a\n⊢ Eq a b","decl":"theorem dvd_antisymm : a ∣ b → b ∣ a → a = b := by\n  rintro ⟨c, rfl⟩ ⟨d, hcd⟩\n  rw [mul_assoc, eq_comm, mul_right_eq_self₀, mul_eq_one] at hcd\n  obtain ⟨rfl, -⟩ | rfl := hcd <;> simp\n\n"}
{"name":"dvd_antisymm'","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\na b : α\ninst✝ : Subsingleton (Units α)\na✝¹ : Dvd.dvd a b\na✝ : Dvd.dvd b a\n⊢ Eq b a","decl":"theorem dvd_antisymm' : a ∣ b → b ∣ a → b = a :=\n  flip dvd_antisymm\n\n"}
{"name":"Dvd.dvd.antisymm","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\na b : α\ninst✝ : Subsingleton (Units α)\na✝¹ : Dvd.dvd a b\na✝ : Dvd.dvd b a\n⊢ Eq a b","decl":"alias Dvd.dvd.antisymm := dvd_antisymm\n\n"}
{"name":"Dvd.dvd.antisymm'","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\na b : α\ninst✝ : Subsingleton (Units α)\na✝¹ : Dvd.dvd a b\na✝ : Dvd.dvd b a\n⊢ Eq b a","decl":"alias Dvd.dvd.antisymm' := dvd_antisymm'\n\n"}
{"name":"eq_of_forall_dvd","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\na b : α\ninst✝ : Subsingleton (Units α)\nh : ∀ (c : α), Iff (Dvd.dvd a c) (Dvd.dvd b c)\n⊢ Eq a b","decl":"theorem eq_of_forall_dvd (h : ∀ c, a ∣ c ↔ b ∣ c) : a = b :=\n  ((h _).2 dvd_rfl).antisymm <| (h _).1 dvd_rfl\n\n"}
{"name":"eq_of_forall_dvd'","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\na b : α\ninst✝ : Subsingleton (Units α)\nh : ∀ (c : α), Iff (Dvd.dvd c a) (Dvd.dvd c b)\n⊢ Eq a b","decl":"theorem eq_of_forall_dvd' (h : ∀ c, c ∣ a ↔ c ∣ b) : a = b :=\n  ((h _).1 dvd_rfl).antisymm <| (h _).2 dvd_rfl\n\n"}
{"name":"pow_dvd_pow_iff","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\na : α\nm n : Nat\nha₀ : Ne a 0\nha : Not (IsUnit a)\n⊢ Iff (Dvd.dvd (HPow.hPow a n) (HPow.hPow a m)) (LE.le n m)","decl":"lemma pow_dvd_pow_iff (ha₀ : a ≠ 0) (ha : ¬IsUnit a) : a ^ n ∣ a ^ m ↔ n ≤ m := by\n  constructor\n  · intro h\n    rw [← not_lt]\n    intro hmn\n    apply ha\n    have : a ^ m * a ∣ a ^ m * 1 := by\n      rw [← pow_succ, mul_one]\n      exact (pow_dvd_pow _ (Nat.succ_le_of_lt hmn)).trans h\n    rwa [mul_dvd_mul_iff_left, ← isUnit_iff_dvd_one] at this\n    apply pow_ne_zero m ha₀\n  · apply pow_dvd_pow\n\n"}
{"name":"GroupWithZero.dvd_iff","module":"Mathlib.Algebra.GroupWithZero.Divisibility","initialProofState":"α : Type u_1\ninst✝ : GroupWithZero α\nm n : α\n⊢ Iff (Dvd.dvd m n) (Eq m 0 → Eq n 0)","decl":"/-- `∣` is not a useful definition if an inverse is available. -/\n@[simp]\nlemma GroupWithZero.dvd_iff {m n : α} : m ∣ n ↔ (m = 0 → n = 0) := by\n  refine ⟨fun ⟨a, ha⟩ hm => ?_, fun h => ?_⟩\n  · simp [hm, ha]\n  · refine ⟨m⁻¹ * n, ?_⟩\n    obtain rfl | hn := eq_or_ne n 0\n    · simp\n    · rw [mul_inv_cancel_left₀ (mt h hn)]\n\n"}
