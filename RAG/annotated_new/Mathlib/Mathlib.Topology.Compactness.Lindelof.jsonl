{"name":"IsLindelof.compl_mem_sets","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nf : Filter X\ninst✝ : CountableInterFilter f\nhf : ∀ (x : X), Membership.mem s x → Membership.mem (Min.min (nhds x) f) (HasCompl.compl s)\n⊢ Membership.mem f (HasCompl.compl s)","decl":"/-- The complement to a Lindelöf set belongs to a filter `f` with the countable intersection\n  property if it belongs to each filter `𝓝 x ⊓ f`, `x ∈ s`. -/\ntheorem IsLindelof.compl_mem_sets (hs : IsLindelof s) {f : Filter X} [CountableInterFilter f]\n    (hf : ∀ x ∈ s, sᶜ ∈ 𝓝 x ⊓ f) : sᶜ ∈ f := by\n  contrapose! hf\n  simp only [not_mem_iff_inf_principal_compl, compl_compl, inf_assoc] at hf ⊢\n  exact hs inf_le_right\n\n"}
{"name":"IsLindelof.compl_mem_sets_of_nhdsWithin","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nf : Filter X\ninst✝ : CountableInterFilter f\nhf : ∀ (x : X), Membership.mem s x → Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Membership.mem f (HasCompl.compl t))\n⊢ Membership.mem f (HasCompl.compl s)","decl":"/-- The complement to a Lindelöf set belongs to a filter `f` with the countable intersection\n  property if each `x ∈ s` has a neighborhood `t` within `s` such that `tᶜ` belongs to `f`. -/\ntheorem IsLindelof.compl_mem_sets_of_nhdsWithin (hs : IsLindelof s) {f : Filter X}\n    [CountableInterFilter f] (hf : ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, tᶜ ∈ f) : sᶜ ∈ f := by\n  refine hs.compl_mem_sets fun x hx ↦ ?_\n  rw [← disjoint_principal_right, disjoint_right_comm, (basis_sets _).disjoint_iff_left]\n  exact hf x hx\n\n"}
{"name":"IsLindelof.induction_on","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\np : Set X → Prop\nhmono : ∀ ⦃s t : Set X⦄, HasSubset.Subset s t → p t → p s\nhcountable_union : ∀ (S : Set (Set X)), S.Countable → (∀ (s : Set X), Membership.mem S s → p s) → p S.sUnion\nhnhds : ∀ (x : X), Membership.mem s x → Exists fun t => And (Membership.mem (nhdsWithin x s) t) (p t)\n⊢ p s","decl":"/-- If `p : Set X → Prop` is stable under restriction and union, and each point `x`\n  of a Lindelöf set `s` has a neighborhood `t` within `s` such that `p t`, then `p s` holds. -/\n@[elab_as_elim]\ntheorem IsLindelof.induction_on (hs : IsLindelof s) {p : Set X → Prop}\n    (hmono : ∀ ⦃s t⦄, s ⊆ t → p t → p s)\n    (hcountable_union : ∀ (S : Set (Set X)), S.Countable → (∀ s ∈ S, p s) → p (⋃₀ S))\n    (hnhds : ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, p t) : p s := by\n  let f : Filter X := ofCountableUnion p hcountable_union (fun t ht _ hsub ↦ hmono hsub ht)\n  have : sᶜ ∈ f := hs.compl_mem_sets_of_nhdsWithin (by simpa [f] using hnhds)\n  rwa [← compl_compl s]\n\n"}
{"name":"IsLindelof.inter_right","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsLindelof s\nht : IsClosed t\n⊢ IsLindelof (Inter.inter s t)","decl":"/-- The intersection of a Lindelöf set and a closed set is a Lindelöf set. -/\ntheorem IsLindelof.inter_right (hs : IsLindelof s) (ht : IsClosed t) : IsLindelof (s ∩ t) := by\n  intro f hnf _ hstf\n  rw [← inf_principal, le_inf_iff] at hstf\n  obtain ⟨x, hsx, hx⟩ : ∃ x ∈ s, ClusterPt x f := hs hstf.1\n  have hxt : x ∈ t := ht.mem_of_nhdsWithin_neBot <| hx.mono hstf.2\n  exact ⟨x, ⟨hsx, hxt⟩, hx⟩\n\n"}
{"name":"IsLindelof.inter_left","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nht : IsLindelof t\nhs : IsClosed s\n⊢ IsLindelof (Inter.inter s t)","decl":"/-- The intersection of a closed set and a Lindelöf set is a Lindelöf set. -/\ntheorem IsLindelof.inter_left (ht : IsLindelof t) (hs : IsClosed s) : IsLindelof (s ∩ t) :=\n  inter_comm t s ▸ ht.inter_right hs\n\n"}
{"name":"IsLindelof.diff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsLindelof s\nht : IsOpen t\n⊢ IsLindelof (SDiff.sdiff s t)","decl":"/-- The set difference of a Lindelöf set and an open set is a Lindelöf set. -/\ntheorem IsLindelof.diff (hs : IsLindelof s) (ht : IsOpen t) : IsLindelof (s \\ t) :=\n  hs.inter_right (isClosed_compl_iff.mpr ht)\n\n"}
{"name":"IsLindelof.of_isClosed_subset","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsLindelof s\nht : IsClosed t\nh : HasSubset.Subset t s\n⊢ IsLindelof t","decl":"/-- A closed subset of a Lindelöf set is a Lindelöf set. -/\ntheorem IsLindelof.of_isClosed_subset (hs : IsLindelof s) (ht : IsClosed t) (h : t ⊆ s) :\n    IsLindelof t := inter_eq_self_of_subset_right h ▸ hs.inter_right ht\n\n"}
{"name":"IsLindelof.image_of_continuousOn","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhs : IsLindelof s\nhf : ContinuousOn f s\n⊢ IsLindelof (Set.image f s)","decl":"/-- A continuous image of a Lindelöf set is a Lindelöf set. -/\ntheorem IsLindelof.image_of_continuousOn {f : X → Y} (hs : IsLindelof s) (hf : ContinuousOn f s) :\n    IsLindelof (f '' s) := by\n  intro l lne _ ls\n  have : NeBot (l.comap f ⊓ 𝓟 s) :=\n    comap_inf_principal_neBot_of_image_mem lne (le_principal_iff.1 ls)\n  obtain ⟨x, hxs, hx⟩ : ∃ x ∈ s, ClusterPt x (l.comap f ⊓ 𝓟 s) := @hs _ this _ inf_le_right\n  haveI := hx.neBot\n  use f x, mem_image_of_mem f hxs\n  have : Tendsto f (𝓝 x ⊓ (comap f l ⊓ 𝓟 s)) (𝓝 (f x) ⊓ l) := by\n    convert (hf x hxs).inf (@tendsto_comap _ _ f l) using 1\n    rw [nhdsWithin]\n    ac_rfl\n  exact this.neBot\n\n"}
{"name":"IsLindelof.image","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhs : IsLindelof s\nhf : Continuous f\n⊢ IsLindelof (Set.image f s)","decl":"/-- A continuous image of a Lindelöf set is a Lindelöf set within the codomain. -/\ntheorem IsLindelof.image {f : X → Y} (hs : IsLindelof s) (hf : Continuous f) :\n    IsLindelof (f '' s) := hs.image_of_continuousOn hf.continuousOn\n\n"}
{"name":"IsLindelof.adherence_nhdset","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns t : Set X\nf : Filter X\ninst✝ : CountableInterFilter f\nhs : IsLindelof s\nhf₂ : LE.le f (Filter.principal s)\nht₁ : IsOpen t\nht₂ : ∀ (x : X), Membership.mem s x → ClusterPt x f → Membership.mem t x\n⊢ Membership.mem f t","decl":"/-- A filter with the countable intersection property that is finer than the principal filter on\na Lindelöf set `s` contains any open set that contains all clusterpoints of `s`. -/\ntheorem IsLindelof.adherence_nhdset {f : Filter X} [CountableInterFilter f] (hs : IsLindelof s)\n    (hf₂ : f ≤ 𝓟 s) (ht₁ : IsOpen t) (ht₂ : ∀ x ∈ s, ClusterPt x f → x ∈ t) : t ∈ f :=\n  (eq_or_neBot _).casesOn mem_of_eq_bot fun _ ↦\n    let ⟨x, hx, hfx⟩ := @hs (f ⊓ 𝓟 tᶜ) _ _ <| inf_le_of_left_le hf₂\n    have : x ∈ t := ht₂ x hx hfx.of_inf_left\n    have : tᶜ ∩ t ∈ 𝓝[tᶜ] x := inter_mem_nhdsWithin _ (ht₁.mem_nhds this)\n    have A : 𝓝[tᶜ] x = ⊥ := empty_mem_iff_bot.1 <| compl_inter_self t ▸ this\n    have : 𝓝[tᶜ] x ≠ ⊥ := hfx.of_inf_right.ne\n    absurd A this\n\n"}
{"name":"IsLindelof.elim_countable_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nι : Type v\nhs : IsLindelof s\nU : ι → Set X\nhUo : ∀ (i : ι), IsOpen (U i)\nhsU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun r => And r.Countable (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i))","decl":"/-- For every open cover of a Lindelöf set, there exists a countable subcover. -/\ntheorem IsLindelof.elim_countable_subcover {ι : Type v} (hs : IsLindelof s) (U : ι → Set X)\n    (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i) :\n    ∃ r : Set ι, r.Countable ∧ (s ⊆ ⋃ i ∈ r, U i) := by\n  have hmono : ∀ ⦃s t : Set X⦄, s ⊆ t → (∃ r : Set ι, r.Countable ∧ t ⊆ ⋃ i ∈ r, U i)\n      → (∃ r : Set ι, r.Countable ∧ s ⊆ ⋃ i ∈ r, U i) := by\n    intro _ _ hst ⟨r, ⟨hrcountable, hsub⟩⟩\n    exact ⟨r, hrcountable, Subset.trans hst hsub⟩\n  have hcountable_union : ∀ (S : Set (Set X)), S.Countable\n      → (∀ s ∈ S, ∃ r : Set ι, r.Countable ∧ (s ⊆ ⋃ i ∈ r, U i))\n      → ∃ r : Set ι, r.Countable ∧ (⋃₀ S ⊆ ⋃ i ∈ r, U i) := by\n    intro S hS hsr\n    choose! r hr using hsr\n    refine ⟨⋃ s ∈ S, r s, hS.biUnion_iff.mpr (fun s hs ↦ (hr s hs).1), ?_⟩\n    refine sUnion_subset ?h.right.h\n    simp only [mem_iUnion, exists_prop, iUnion_exists, biUnion_and']\n    exact fun i is x hx ↦ mem_biUnion is ((hr i is).2 hx)\n  have h_nhds : ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, ∃ r : Set ι, r.Countable ∧ (t ⊆ ⋃ i ∈ r, U i) := by\n    intro x hx\n    let ⟨i, hi⟩ := mem_iUnion.1 (hsU hx)\n    refine ⟨U i, mem_nhdsWithin_of_mem_nhds ((hUo i).mem_nhds hi), {i}, by simp, ?_⟩\n    simp only [mem_singleton_iff, iUnion_iUnion_eq_left]\n    exact Subset.refl _\n  exact hs.induction_on hmono hcountable_union h_nhds\n\n"}
{"name":"IsLindelof.elim_nhds_subcover'","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nU : (x : X) → Membership.mem s x → Set X\nhU : ∀ (x : X), Membership.mem s x → Membership.mem (nhds x) (U x ⋯)\n⊢ Exists fun t => And t.Countable (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => U ↑x ⋯))","decl":"theorem IsLindelof.elim_nhds_subcover' (hs : IsLindelof s) (U : ∀ x ∈ s, Set X)\n    (hU : ∀ x (hx : x ∈ s), U x ‹x ∈ s› ∈ 𝓝 x) :\n    ∃ t : Set s, t.Countable ∧ s ⊆ ⋃ x ∈ t, U (x : s) x.2 := by\n  have := hs.elim_countable_subcover (fun x : s ↦ interior (U x x.2)) (fun _ ↦ isOpen_interior)\n    fun x hx ↦\n      mem_iUnion.2 ⟨⟨x, hx⟩, mem_interior_iff_mem_nhds.2 <| hU _ _⟩\n  rcases this with ⟨r, ⟨hr, hs⟩⟩\n  use r, hr\n  apply Subset.trans hs\n  apply iUnion₂_subset\n  intro i hi\n  apply Subset.trans interior_subset\n  exact subset_iUnion_of_subset i (subset_iUnion_of_subset hi (Subset.refl _))\n\n"}
{"name":"IsLindelof.elim_nhds_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nU : X → Set X\nhU : ∀ (x : X), Membership.mem s x → Membership.mem (nhds x) (U x)\n⊢ Exists fun t => And t.Countable (And (∀ (x : X), Membership.mem t x → Membership.mem s x) (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => U x)))","decl":"theorem IsLindelof.elim_nhds_subcover (hs : IsLindelof s) (U : X → Set X)\n    (hU : ∀ x ∈ s, U x ∈ 𝓝 x) :\n    ∃ t : Set X, t.Countable ∧ (∀ x ∈ t, x ∈ s) ∧ s ⊆ ⋃ x ∈ t, U x := by\n  let ⟨t, ⟨htc, htsub⟩⟩ := hs.elim_nhds_subcover' (fun x _ ↦ U x) hU\n  refine ⟨↑t, Countable.image htc Subtype.val, ?_⟩\n  constructor\n  · intro _\n    simp only [mem_image, Subtype.exists, exists_and_right, exists_eq_right, forall_exists_index]\n    tauto\n  · have : ⋃ x ∈ t, U ↑x = ⋃ x ∈ Subtype.val '' t, U x := biUnion_image.symm\n    rwa [← this]\n\n"}
{"name":"IsLindelof.indexed_countable_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\nι : Type v\ninst✝ : Nonempty ι\nhs : IsLindelof s\nU : ι → Set X\nhUo : ∀ (i : ι), IsOpen (U i)\nhsU : HasSubset.Subset s (Set.iUnion fun i => U i)\n⊢ Exists fun f => HasSubset.Subset s (Set.iUnion fun n => U (f n))","decl":"/-- For every nonempty open cover of a Lindelöf set, there exists a subcover indexed by ℕ. -/\ntheorem IsLindelof.indexed_countable_subcover {ι : Type v} [Nonempty ι]\n    (hs : IsLindelof s) (U : ι → Set X) (hUo : ∀ i, IsOpen (U i)) (hsU : s ⊆ ⋃ i, U i) :\n    ∃ f : ℕ → ι, s ⊆ ⋃ n, U (f n) := by\n  obtain ⟨c, ⟨c_count, c_cov⟩⟩ := hs.elim_countable_subcover U hUo hsU\n  rcases c.eq_empty_or_nonempty with rfl | c_nonempty\n  · simp only [mem_empty_iff_false, iUnion_of_empty, iUnion_empty] at c_cov\n    simp only [subset_eq_empty c_cov rfl, empty_subset, exists_const]\n  obtain ⟨f, f_surj⟩ := (Set.countable_iff_exists_surjective c_nonempty).mp c_count\n  refine ⟨fun x ↦ f x, c_cov.trans <| iUnion₂_subset_iff.mpr (?_ : ∀ i ∈ c, U i ⊆ ⋃ n, U (f n))⟩\n  intro x hx\n  obtain ⟨n, hn⟩ := f_surj ⟨x, hx⟩\n  exact subset_iUnion_of_subset n <| subset_of_eq (by rw [hn])\n\n"}
{"name":"IsLindelof.disjoint_nhdsSet_left","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\nl : Filter X\ninst✝ : CountableInterFilter l\nhs : IsLindelof s\n⊢ Iff (Disjoint (nhdsSet s) l) (∀ (x : X), Membership.mem s x → Disjoint (nhds x) l)","decl":"/-- The neighborhood filter of a Lindelöf set is disjoint with a filter `l` with the countable\nintersection property if and only if the neighborhood filter of each point of this set\nis disjoint with `l`. -/\ntheorem IsLindelof.disjoint_nhdsSet_left {l : Filter X} [CountableInterFilter l]\n    (hs : IsLindelof s) :\n    Disjoint (𝓝ˢ s) l ↔ ∀ x ∈ s, Disjoint (𝓝 x) l := by\n  refine ⟨fun h x hx ↦ h.mono_left <| nhds_le_nhdsSet hx, fun H ↦ ?_⟩\n  choose! U hxU hUl using fun x hx ↦ (nhds_basis_opens x).disjoint_iff_left.1 (H x hx)\n  choose hxU hUo using hxU\n  rcases hs.elim_nhds_subcover U fun x hx ↦ (hUo x hx).mem_nhds (hxU x hx) with ⟨t, htc, hts, hst⟩\n  refine (hasBasis_nhdsSet _).disjoint_iff_left.2\n    ⟨⋃ x ∈ t, U x, ⟨isOpen_biUnion fun x hx ↦ hUo x (hts x hx), hst⟩, ?_⟩\n  rw [compl_iUnion₂]\n  exact (countable_bInter_mem htc).mpr (fun i hi ↦ hUl _ (hts _ hi))\n\n"}
{"name":"IsLindelof.disjoint_nhdsSet_right","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\nl : Filter X\ninst✝ : CountableInterFilter l\nhs : IsLindelof s\n⊢ Iff (Disjoint l (nhdsSet s)) (∀ (x : X), Membership.mem s x → Disjoint l (nhds x))","decl":"/-- A filter `l` with the countable intersection property is disjoint with the neighborhood\nfilter of a Lindelöf set if and only if it is disjoint with the neighborhood filter of each point\nof this set. -/\ntheorem IsLindelof.disjoint_nhdsSet_right {l : Filter X} [CountableInterFilter l]\n    (hs : IsLindelof s) : Disjoint l (𝓝ˢ s) ↔ ∀ x ∈ s, Disjoint l (𝓝 x) := by\n  simpa only [disjoint_comm] using hs.disjoint_nhdsSet_left\n\n"}
{"name":"IsLindelof.elim_countable_subfamily_closed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nι : Type v\nhs : IsLindelof s\nt : ι → Set X\nhtc : ∀ (i : ι), IsClosed (t i)\nhst : Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection\n⊢ Exists fun u => And u.Countable (Eq (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)) EmptyCollection.emptyCollection)","decl":"/-- For every family of closed sets whose intersection avoids a Lindelö set,\nthere exists a countable subfamily whose intersection avoids this Lindelöf set. -/\ntheorem IsLindelof.elim_countable_subfamily_closed {ι : Type v} (hs : IsLindelof s)\n    (t : ι → Set X) (htc : ∀ i, IsClosed (t i)) (hst : (s ∩ ⋂ i, t i) = ∅) :\n    ∃ u : Set ι, u.Countable ∧ (s ∩ ⋂ i ∈ u, t i) = ∅ := by\n  let U := tᶜ\n  have hUo : ∀ i, IsOpen (U i) := by simp only [U, Pi.compl_apply, isOpen_compl_iff]; exact htc\n  have hsU : s ⊆ ⋃ i, U i := by\n    simp only [U, Pi.compl_apply]\n    rw [← compl_iInter]\n    apply disjoint_compl_left_iff_subset.mp\n    simp only [compl_iInter, compl_iUnion, compl_compl]\n    apply Disjoint.symm\n    exact disjoint_iff_inter_eq_empty.mpr hst\n  rcases hs.elim_countable_subcover U hUo hsU with ⟨u, ⟨hucount, husub⟩⟩\n  use u, hucount\n  rw [← disjoint_compl_left_iff_subset] at husub\n  simp only [U, Pi.compl_apply, compl_iUnion, compl_compl] at husub\n  exact disjoint_iff_inter_eq_empty.mp (Disjoint.symm husub)\n\n"}
{"name":"IsLindelof.inter_iInter_nonempty","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nι : Type v\nhs : IsLindelof s\nt : ι → Set X\nhtc : ∀ (i : ι), IsClosed (t i)\nhst : ∀ (u : Set ι), And u.Countable (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)).Nonempty\n⊢ (Inter.inter s (Set.iInter fun i => t i)).Nonempty","decl":"/-- To show that a Lindelöf set intersects the intersection of a family of closed sets,\n  it is sufficient to show that it intersects every countable subfamily. -/\ntheorem IsLindelof.inter_iInter_nonempty {ι : Type v} (hs : IsLindelof s) (t : ι → Set X)\n    (htc : ∀ i, IsClosed (t i)) (hst : ∀ u : Set ι, u.Countable ∧ (s ∩ ⋂ i ∈ u, t i).Nonempty) :\n    (s ∩ ⋂ i, t i).Nonempty := by\n  contrapose! hst\n  rcases hs.elim_countable_subfamily_closed t htc hst with ⟨u, ⟨_, husub⟩⟩\n  exact ⟨u, fun _ ↦ husub⟩\n\n"}
{"name":"IsLindelof.elim_countable_subcover_image","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nb : Set ι\nc : ι → Set X\nhs : IsLindelof s\nhc₁ : ∀ (i : ι), Membership.mem b i → IsOpen (c i)\nhc₂ : HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => c i)\n⊢ Exists fun b' => And (HasSubset.Subset b' b) (And b'.Countable (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => c i)))","decl":"/-- For every open cover of a Lindelöf set, there exists a countable subcover. -/\ntheorem IsLindelof.elim_countable_subcover_image {b : Set ι} {c : ι → Set X} (hs : IsLindelof s)\n    (hc₁ : ∀ i ∈ b, IsOpen (c i)) (hc₂ : s ⊆ ⋃ i ∈ b, c i) :\n    ∃ b', b' ⊆ b ∧ Set.Countable b' ∧ s ⊆ ⋃ i ∈ b', c i := by\n  simp only [Subtype.forall', biUnion_eq_iUnion] at hc₁ hc₂\n  rcases hs.elim_countable_subcover (fun i ↦ c i : b → Set X) hc₁ hc₂ with ⟨d, hd⟩\n  refine ⟨Subtype.val '' d, by simp, Countable.image hd.1 Subtype.val, ?_⟩\n  rw [biUnion_image]\n  exact hd.2\n\n\n"}
{"name":"isLindelof_of_countable_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nh : ∀ {ι : Type u} (U : ι → Set X), (∀ (i : ι), IsOpen (U i)) → HasSubset.Subset s (Set.iUnion fun i => U i) → Exists fun t => And t.Countable (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i))\n⊢ IsLindelof s","decl":"/-- A set `s` is Lindelöf if for every open cover of `s`, there exists a countable subcover. -/\ntheorem isLindelof_of_countable_subcover\n    (h : ∀ {ι : Type u} (U : ι → Set X), (∀ i, IsOpen (U i)) → (s ⊆ ⋃ i, U i) →\n    ∃ t : Set ι, t.Countable ∧ s ⊆ ⋃ i ∈ t, U i) :\n    IsLindelof s := fun f hf hfs ↦ by\n  contrapose! h\n  simp only [ClusterPt, not_neBot, ← disjoint_iff, SetCoe.forall',\n    (nhds_basis_opens _).disjoint_iff_left] at h\n  choose fsub U hU hUf using h\n  refine ⟨s, U, fun x ↦ (hU x).2, fun x hx ↦ mem_iUnion.2 ⟨⟨x, hx⟩, (hU _).1 ⟩, ?_⟩\n  intro t ht h\n  have uinf := f.sets_of_superset (le_principal_iff.1 fsub) h\n  have uninf : ⋂ i ∈ t, (U i)ᶜ ∈ f := (countable_bInter_mem ht).mpr (fun _ _ ↦ hUf _)\n  rw [← compl_iUnion₂] at uninf\n  have uninf := compl_not_mem uninf\n  simp only [compl_compl] at uninf\n  contradiction\n\n"}
{"name":"isLindelof_of_countable_subfamily_closed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nh : ∀ {ι : Type u} (t : ι → Set X), (∀ (i : ι), IsClosed (t i)) → Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection → Exists fun u => And u.Countable (Eq (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)) EmptyCollection.emptyCollection)\n⊢ IsLindelof s","decl":"/-- A set `s` is Lindelöf if for every family of closed sets whose intersection avoids `s`,\nthere exists a countable subfamily whose intersection avoids `s`. -/\ntheorem isLindelof_of_countable_subfamily_closed\n    (h :\n      ∀ {ι : Type u} (t : ι → Set X), (∀ i, IsClosed (t i)) → (s ∩ ⋂ i, t i) = ∅ →\n        ∃ u : Set ι, u.Countable ∧ (s ∩ ⋂ i ∈ u, t i) = ∅) :\n    IsLindelof s :=\n  isLindelof_of_countable_subcover fun U hUo hsU ↦ by\n    rw [← disjoint_compl_right_iff_subset, compl_iUnion, disjoint_iff] at hsU\n    rcases h (fun i ↦ (U i)ᶜ) (fun i ↦ (hUo _).isClosed_compl) hsU with ⟨t, ht⟩\n    refine ⟨t, ?_⟩\n    rwa [← disjoint_compl_right_iff_subset, compl_iUnion₂, disjoint_iff]\n\n"}
{"name":"isLindelof_iff_countable_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsLindelof s) (∀ {ι : Type u} (U : ι → Set X), (∀ (i : ι), IsOpen (U i)) → HasSubset.Subset s (Set.iUnion fun i => U i) → Exists fun t => And t.Countable (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i)))","decl":"/-- A set `s` is Lindelöf if and only if\nfor every open cover of `s`, there exists a countable subcover. -/\ntheorem isLindelof_iff_countable_subcover :\n    IsLindelof s ↔ ∀ {ι : Type u} (U : ι → Set X),\n      (∀ i, IsOpen (U i)) → (s ⊆ ⋃ i, U i) → ∃ t : Set ι, t.Countable ∧ s ⊆ ⋃ i ∈ t, U i :=\n  ⟨fun hs ↦ hs.elim_countable_subcover, isLindelof_of_countable_subcover⟩\n\n"}
{"name":"isLindelof_iff_countable_subfamily_closed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsLindelof s) (∀ {ι : Type u} (t : ι → Set X), (∀ (i : ι), IsClosed (t i)) → Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection → Exists fun u => And u.Countable (Eq (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)) EmptyCollection.emptyCollection))","decl":"/-- A set `s` is Lindelöf if and only if\nfor every family of closed sets whose intersection avoids `s`,\nthere exists a countable subfamily whose intersection avoids `s`. -/\ntheorem isLindelof_iff_countable_subfamily_closed :\n    IsLindelof s ↔ ∀ {ι : Type u} (t : ι → Set X),\n    (∀ i, IsClosed (t i)) → (s ∩ ⋂ i, t i) = ∅\n    → ∃ u : Set ι, u.Countable ∧ (s ∩ ⋂ i ∈ u, t i) = ∅ :=\n  ⟨fun hs ↦ hs.elim_countable_subfamily_closed, isLindelof_of_countable_subfamily_closed⟩\n\n"}
{"name":"isLindelof_empty","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsLindelof EmptyCollection.emptyCollection","decl":"/-- The empty set is a Lindelof set. -/\n@[simp]\ntheorem isLindelof_empty : IsLindelof (∅ : Set X) := fun _f hnf _ hsf ↦\n  Not.elim hnf.ne <| empty_mem_iff_bot.1 <| le_principal_iff.1 hsf\n\n"}
{"name":"isLindelof_singleton","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ IsLindelof (Singleton.singleton x)","decl":"/-- A singleton set is a Lindelof set. -/\n@[simp]\ntheorem isLindelof_singleton {x : X} : IsLindelof ({x} : Set X) := fun _ hf _ hfa ↦\n  ⟨x, rfl, ClusterPt.of_le_nhds'\n    (hfa.trans <| by simpa only [principal_singleton] using pure_le_nhds x) hf⟩\n\n"}
{"name":"Set.Subsingleton.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : s.Subsingleton\n⊢ IsLindelof s","decl":"theorem Set.Subsingleton.isLindelof (hs : s.Subsingleton) : IsLindelof s :=\n  Subsingleton.induction_on hs isLindelof_empty fun _ ↦ isLindelof_singleton\n\n"}
{"name":"Set.Countable.isLindelof_biUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\ns : Set ι\nf : ι → Set X\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → IsLindelof (f i)\n⊢ IsLindelof (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Set.Countable.isLindelof_biUnion {s : Set ι} {f : ι → Set X} (hs : s.Countable)\n    (hf : ∀ i ∈ s, IsLindelof (f i)) : IsLindelof (⋃ i ∈ s, f i) := by\n  apply isLindelof_of_countable_subcover\n  intro i U hU hUcover\n  have hiU : ∀ i ∈ s, f i ⊆ ⋃ i, U i :=\n    fun _ is ↦ _root_.subset_trans (subset_biUnion_of_mem is) hUcover\n  have iSets := fun i is ↦ (hf i is).elim_countable_subcover U hU (hiU i is)\n  choose! r hr using iSets\n  use ⋃ i ∈ s, r i\n  constructor\n  · refine (Countable.biUnion_iff hs).mpr ?h.left.a\n    exact fun s hs ↦ (hr s hs).1\n  · refine iUnion₂_subset ?h.right.h\n    intro i is\n    simp only [mem_iUnion, exists_prop, iUnion_exists, biUnion_and']\n    intro x hx\n    exact mem_biUnion is ((hr i is).2 hx)\n\n\n"}
{"name":"Set.Finite.isLindelof_biUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\ns : Set ι\nf : ι → Set X\nhs : s.Finite\nhf : ∀ (i : ι), Membership.mem s i → IsLindelof (f i)\n⊢ IsLindelof (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Set.Finite.isLindelof_biUnion {s : Set ι} {f : ι → Set X} (hs : s.Finite)\n    (hf : ∀ i ∈ s, IsLindelof (f i)) : IsLindelof (⋃ i ∈ s, f i) :=\n  Set.Countable.isLindelof_biUnion (countable hs) hf\n\n"}
{"name":"Finset.isLindelof_biUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\ns : Finset ι\nf : ι → Set X\nhf : ∀ (i : ι), Membership.mem s i → IsLindelof (f i)\n⊢ IsLindelof (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Finset.isLindelof_biUnion (s : Finset ι) {f : ι → Set X} (hf : ∀ i ∈ s, IsLindelof (f i)) :\n    IsLindelof (⋃ i ∈ s, f i) :=\n  s.finite_toSet.isLindelof_biUnion hf\n\n"}
{"name":"isLindelof_accumulate","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nK : Nat → Set X\nhK : ∀ (n : Nat), IsLindelof (K n)\nn : Nat\n⊢ IsLindelof (Set.Accumulate K n)","decl":"theorem isLindelof_accumulate {K : ℕ → Set X} (hK : ∀ n, IsLindelof (K n)) (n : ℕ) :\n    IsLindelof (Accumulate K n) :=\n  (finite_le_nat n).isLindelof_biUnion fun k _ => hK k\n\n"}
{"name":"Set.Countable.isLindelof_sUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhf : S.Countable\nhc : ∀ (s : Set X), Membership.mem S s → IsLindelof s\n⊢ IsLindelof S.sUnion","decl":"theorem Set.Countable.isLindelof_sUnion {S : Set (Set X)} (hf : S.Countable)\n    (hc : ∀ s ∈ S, IsLindelof s) : IsLindelof (⋃₀ S) := by\n  rw [sUnion_eq_biUnion]; exact hf.isLindelof_biUnion hc\n\n"}
{"name":"Set.Finite.isLindelof_sUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhf : S.Finite\nhc : ∀ (s : Set X), Membership.mem S s → IsLindelof s\n⊢ IsLindelof S.sUnion","decl":"theorem Set.Finite.isLindelof_sUnion {S : Set (Set X)} (hf : S.Finite)\n    (hc : ∀ s ∈ S, IsLindelof s) : IsLindelof (⋃₀ S) := by\n  rw [sUnion_eq_biUnion]; exact hf.isLindelof_biUnion hc\n\n"}
{"name":"isLindelof_iUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nι : Sort u_2\nf : ι → Set X\ninst✝ : Countable ι\nh : ∀ (i : ι), IsLindelof (f i)\n⊢ IsLindelof (Set.iUnion fun i => f i)","decl":"theorem isLindelof_iUnion {ι : Sort*} {f : ι → Set X} [Countable ι] (h : ∀ i, IsLindelof (f i)) :\n    IsLindelof (⋃ i, f i) := (countable_range f).isLindelof_sUnion  <| forall_mem_range.2 h\n\n"}
{"name":"Set.Countable.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : s.Countable\n⊢ IsLindelof s","decl":"theorem Set.Countable.isLindelof (hs : s.Countable) : IsLindelof s :=\n  biUnion_of_singleton s ▸ hs.isLindelof_biUnion fun _ _ => isLindelof_singleton\n\n"}
{"name":"Set.Finite.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : s.Finite\n⊢ IsLindelof s","decl":"theorem Set.Finite.isLindelof (hs : s.Finite) : IsLindelof s :=\n  biUnion_of_singleton s ▸ hs.isLindelof_biUnion fun _ _ => isLindelof_singleton\n\n"}
{"name":"IsLindelof.countable_of_discrete","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : DiscreteTopology X\nhs : IsLindelof s\n⊢ s.Countable","decl":"theorem IsLindelof.countable_of_discrete [DiscreteTopology X] (hs : IsLindelof s) :\n    s.Countable := by\n  have : ∀ x : X, ({x} : Set X) ∈ 𝓝 x := by simp [nhds_discrete]\n  rcases hs.elim_nhds_subcover (fun x => {x}) fun x _ => this x with ⟨t, ht, _, hssubt⟩\n  rw [biUnion_of_singleton] at hssubt\n  exact ht.mono hssubt\n\n"}
{"name":"isLindelof_iff_countable","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : DiscreteTopology X\n⊢ Iff (IsLindelof s) s.Countable","decl":"theorem isLindelof_iff_countable [DiscreteTopology X] : IsLindelof s ↔ s.Countable :=\n  ⟨fun h => h.countable_of_discrete, fun h => h.isLindelof⟩\n\n"}
{"name":"IsLindelof.union","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsLindelof s\nht : IsLindelof t\n⊢ IsLindelof (Union.union s t)","decl":"theorem IsLindelof.union (hs : IsLindelof s) (ht : IsLindelof t) : IsLindelof (s ∪ t) := by\n  rw [union_eq_iUnion]; exact isLindelof_iUnion fun b => by cases b <;> assumption\n\n"}
{"name":"IsLindelof.insert","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\na : X\n⊢ IsLindelof (Insert.insert a s)","decl":"protected theorem IsLindelof.insert (hs : IsLindelof s) (a) : IsLindelof (insert a s) :=\n  isLindelof_singleton.union hs\n\n"}
{"name":"isLindelof_open_iff_eq_countable_iUnion_of_isTopologicalBasis","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nι : Type u_1\ninst✝ : TopologicalSpace X\nb : ι → Set X\nhb : TopologicalSpace.IsTopologicalBasis (Set.range b)\nhb' : ∀ (i : ι), IsLindelof (b i)\nU : Set X\n⊢ Iff (And (IsLindelof U) (IsOpen U)) (Exists fun s => And s.Countable (Eq U (Set.iUnion fun i => Set.iUnion fun h => b i)))","decl":"/-- If `X` has a basis consisting of compact opens, then an open set in `X` is compact open iff\nit is a finite union of some elements in the basis -/\ntheorem isLindelof_open_iff_eq_countable_iUnion_of_isTopologicalBasis (b : ι → Set X)\n    (hb : IsTopologicalBasis (Set.range b)) (hb' : ∀ i, IsLindelof (b i)) (U : Set X) :\n    IsLindelof U ∧ IsOpen U ↔ ∃ s : Set ι, s.Countable ∧ U = ⋃ i ∈ s, b i := by\n  constructor\n  · rintro ⟨h₁, h₂⟩\n    obtain ⟨Y, f, rfl, hf⟩ := hb.open_eq_iUnion h₂\n    choose f' hf' using hf\n    have : b ∘ f' = f := funext hf'\n    subst this\n    obtain ⟨t, ht⟩ :=\n      h₁.elim_countable_subcover (b ∘ f') (fun i => hb.isOpen (Set.mem_range_self _)) Subset.rfl\n    refine ⟨t.image f', Countable.image (ht.1) f', le_antisymm ?_ ?_⟩\n    · refine Set.Subset.trans ht.2 ?_\n      simp only [Set.iUnion_subset_iff]\n      intro i hi\n      rw [← Set.iUnion_subtype (fun x : ι => x ∈ t.image f') fun i => b i.1]\n      exact Set.subset_iUnion (fun i : t.image f' => b i) ⟨_, mem_image_of_mem _ hi⟩\n    · apply Set.iUnion₂_subset\n      rintro i hi\n      obtain ⟨j, -, rfl⟩ := (mem_image ..).mp hi\n      exact Set.subset_iUnion (b ∘ f') j\n  · rintro ⟨s, hs, rfl⟩\n    constructor\n    · exact hs.isLindelof_biUnion fun i _ => hb' i\n    · exact isOpen_biUnion fun i _ => hb.isOpen (Set.mem_range_self _)\n\n"}
{"name":"hasBasis_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ (Filter.coLindelof X).HasBasis IsLindelof HasCompl.compl","decl":"theorem hasBasis_coLindelof : (coLindelof X).HasBasis IsLindelof compl :=\n  hasBasis_biInf_principal'\n    (fun s hs t ht =>\n      ⟨s ∪ t, hs.union ht, compl_subset_compl.2 subset_union_left,\n        compl_subset_compl.2 subset_union_right⟩)\n    ⟨∅, isLindelof_empty⟩\n\n"}
{"name":"mem_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Membership.mem (Filter.coLindelof X) s) (Exists fun t => And (IsLindelof t) (HasSubset.Subset (HasCompl.compl t) s))","decl":"theorem mem_coLindelof : s ∈ coLindelof X ↔ ∃ t, IsLindelof t ∧ tᶜ ⊆ s :=\n  hasBasis_coLindelof.mem_iff\n\n"}
{"name":"mem_coLindelof'","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Membership.mem (Filter.coLindelof X) s) (Exists fun t => And (IsLindelof t) (HasSubset.Subset (HasCompl.compl s) t))","decl":"theorem mem_coLindelof' : s ∈ coLindelof X ↔ ∃ t, IsLindelof t ∧ sᶜ ⊆ t :=\n  mem_coLindelof.trans <| exists_congr fun _ => and_congr_right fun _ => compl_subset_comm\n\n"}
{"name":"IsLindelof.compl_mem_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\n⊢ Membership.mem (Filter.coLindelof X) (HasCompl.compl s)","decl":"theorem _root_.IsLindelof.compl_mem_coLindelof (hs : IsLindelof s) : sᶜ ∈ coLindelof X :=\n  hasBasis_coLindelof.mem_of_mem hs\n\n"}
{"name":"coLindelof_le_cofinite","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ LE.le (Filter.coLindelof X) Filter.cofinite","decl":"theorem coLindelof_le_cofinite : coLindelof X ≤ cofinite := fun s hs =>\n  compl_compl s ▸ hs.isLindelof.compl_mem_coLindelof\n\n"}
{"name":"Tendsto.isLindelof_insert_range_of_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ny : Y\nhf : Filter.Tendsto f (Filter.coLindelof X) (nhds y)\nhfc : Continuous f\n⊢ IsLindelof (Insert.insert y (Set.range f))","decl":"theorem Tendsto.isLindelof_insert_range_of_coLindelof {f : X → Y} {y}\n    (hf : Tendsto f (coLindelof X) (𝓝 y)) (hfc : Continuous f) :\n    IsLindelof (insert y (range f)) := by\n  intro l hne _ hle\n  by_cases hy : ClusterPt y l\n  · exact ⟨y, Or.inl rfl, hy⟩\n  simp only [clusterPt_iff, not_forall, ← not_disjoint_iff_nonempty_inter, not_not] at hy\n  rcases hy with ⟨s, hsy, t, htl, hd⟩\n  rcases mem_coLindelof.1 (hf hsy) with ⟨K, hKc, hKs⟩\n  have : f '' K ∈ l := by\n    filter_upwards [htl, le_principal_iff.1 hle] with y hyt hyf\n    rcases hyf with (rfl | ⟨x, rfl⟩)\n    exacts [(hd.le_bot ⟨mem_of_mem_nhds hsy, hyt⟩).elim,\n      mem_image_of_mem _ (not_not.1 fun hxK => hd.le_bot ⟨hKs hxK, hyt⟩)]\n  rcases hKc.image hfc (le_principal_iff.2 this) with ⟨y, hy, hyl⟩\n  exact ⟨y, Or.inr <| image_subset_range _ _ hy, hyl⟩\n\n"}
{"name":"hasBasis_coclosedLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ (Filter.coclosedLindelof X).HasBasis (fun s => And (IsClosed s) (IsLindelof s)) HasCompl.compl","decl":"theorem hasBasis_coclosedLindelof :\n    (Filter.coclosedLindelof X).HasBasis (fun s => IsClosed s ∧ IsLindelof s) compl := by\n  simp only [Filter.coclosedLindelof, iInf_and']\n  refine hasBasis_biInf_principal' ?_ ⟨∅, isClosed_empty, isLindelof_empty⟩\n  rintro s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩\n  exact ⟨s ∪ t, ⟨⟨hs₁.union ht₁, hs₂.union ht₂⟩, compl_subset_compl.2 subset_union_left,\n    compl_subset_compl.2 subset_union_right⟩⟩\n\n"}
{"name":"mem_coclosedLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Membership.mem (Filter.coclosedLindelof X) s) (Exists fun t => And (IsClosed t) (And (IsLindelof t) (HasSubset.Subset (HasCompl.compl t) s)))","decl":"theorem mem_coclosedLindelof : s ∈ coclosedLindelof X ↔\n    ∃ t, IsClosed t ∧ IsLindelof t ∧ tᶜ ⊆ s := by\n  simp only [hasBasis_coclosedLindelof.mem_iff, and_assoc]\n\n"}
{"name":"mem_coclosed_Lindelof'","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Membership.mem (Filter.coclosedLindelof X) s) (Exists fun t => And (IsClosed t) (And (IsLindelof t) (HasSubset.Subset (HasCompl.compl s) t)))","decl":"theorem mem_coclosed_Lindelof' : s ∈ coclosedLindelof X ↔\n    ∃ t, IsClosed t ∧ IsLindelof t ∧ sᶜ ⊆ t := by\n  simp only [mem_coclosedLindelof, compl_subset_comm]\n\n"}
{"name":"coLindelof_le_coclosedLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ LE.le (Filter.coLindelof X) (Filter.coclosedLindelof X)","decl":"theorem coLindelof_le_coclosedLindelof : coLindelof X ≤ coclosedLindelof X :=\n  iInf_mono fun _ => le_iInf fun _ => le_rfl\n\n"}
{"name":"IsLindeof.compl_mem_coclosedLindelof_of_isClosed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nhs' : IsClosed s\n⊢ Membership.mem (Filter.coclosedLindelof X) (HasCompl.compl s)","decl":"theorem IsLindeof.compl_mem_coclosedLindelof_of_isClosed (hs : IsLindelof s) (hs' : IsClosed s) :\n    sᶜ ∈ Filter.coclosedLindelof X :=\n  hasBasis_coclosedLindelof.mem_of_mem ⟨hs', hs⟩\n\n"}
{"name":"LindelofSpace.isLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nself : LindelofSpace X\n⊢ IsLindelof Set.univ","decl":"/-- X is a Lindelöf space iff every open cover has a countable subcover. -/\nclass LindelofSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- In a Lindelöf space, `Set.univ` is a Lindelöf set. -/\n  isLindelof_univ : IsLindelof (univ : Set X)\n\n"}
{"name":"Subsingleton.lindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : Subsingleton X\n⊢ LindelofSpace X","decl":"instance (priority := 10) Subsingleton.lindelofSpace [Subsingleton X] : LindelofSpace X :=\n  ⟨subsingleton_univ.isLindelof⟩\n\n"}
{"name":"isLindelof_univ_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Iff (IsLindelof Set.univ) (LindelofSpace X)","decl":"theorem isLindelof_univ_iff : IsLindelof (univ : Set X) ↔ LindelofSpace X :=\n  ⟨fun h => ⟨h⟩, fun h => h.1⟩\n\n"}
{"name":"isLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nh : LindelofSpace X\n⊢ IsLindelof Set.univ","decl":"theorem isLindelof_univ [h : LindelofSpace X] : IsLindelof (univ : Set X) :=\n  h.isLindelof_univ\n\n"}
{"name":"cluster_point_of_Lindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝³ : TopologicalSpace X\ninst✝² : LindelofSpace X\nf : Filter X\ninst✝¹ : f.NeBot\ninst✝ : CountableInterFilter f\n⊢ Exists fun x => ClusterPt x f","decl":"theorem cluster_point_of_Lindelof [LindelofSpace X] (f : Filter X) [NeBot f]\n    [CountableInterFilter f] : ∃ x, ClusterPt x f := by\n  simpa using isLindelof_univ (show f ≤ 𝓟 univ by simp)\n\n"}
{"name":"LindelofSpace.elim_nhds_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : LindelofSpace X\nU : X → Set X\nhU : ∀ (x : X), Membership.mem (nhds x) (U x)\n⊢ Exists fun t => And t.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => U x) Set.univ)","decl":"theorem LindelofSpace.elim_nhds_subcover [LindelofSpace X] (U : X → Set X) (hU : ∀ x, U x ∈ 𝓝 x) :\n    ∃ t : Set X, t.Countable ∧ ⋃ x ∈ t, U x = univ := by\n  obtain ⟨t, tc, -, s⟩ := IsLindelof.elim_nhds_subcover isLindelof_univ U fun x _ => hU x\n  use t, tc\n  apply top_unique s\n\n"}
{"name":"lindelofSpace_of_countable_subfamily_closed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nh : ∀ {ι : Type u} (t : ι → Set X), (∀ (i : ι), IsClosed (t i)) → Eq (Set.iInter fun i => t i) EmptyCollection.emptyCollection → Exists fun u => And u.Countable (Eq (Set.iInter fun i => Set.iInter fun h => t i) EmptyCollection.emptyCollection)\n⊢ LindelofSpace X","decl":"theorem lindelofSpace_of_countable_subfamily_closed\n    (h : ∀ {ι : Type u} (t : ι → Set X), (∀ i, IsClosed (t i)) → ⋂ i, t i = ∅ →\n      ∃ u : Set ι, u.Countable ∧ ⋂ i ∈ u, t i = ∅) :\n    LindelofSpace X where\n  isLindelof_univ := isLindelof_of_countable_subfamily_closed fun t => by simpa using h t\n\n"}
{"name":"IsClosed.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : LindelofSpace X\nh : IsClosed s\n⊢ IsLindelof s","decl":"theorem IsClosed.isLindelof [LindelofSpace X] (h : IsClosed s) : IsLindelof s :=\n  isLindelof_univ.of_isClosed_subset h (subset_univ _)\n\n"}
{"name":"IsCompact.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\n⊢ IsLindelof s","decl":"/-- A compact set `s` is Lindelöf. -/\ntheorem IsCompact.isLindelof (hs : IsCompact s) :\n    IsLindelof s := by tauto\n\n"}
{"name":"IsSigmaCompact.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsSigmaCompact s\n⊢ IsLindelof s","decl":"/-- A σ-compact set `s` is Lindelöf -/\ntheorem IsSigmaCompact.isLindelof (hs : IsSigmaCompact s) :\n    IsLindelof s := by\n  rw [IsSigmaCompact] at hs\n  rcases hs with ⟨K, ⟨hc, huniv⟩⟩\n  rw [← huniv]\n  have hl : ∀ n, IsLindelof (K n) := fun n ↦ IsCompact.isLindelof (hc n)\n  exact isLindelof_iUnion hl\n\n"}
{"name":"instLindelofSpaceOfCompactSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\n⊢ LindelofSpace X","decl":"/-- A compact space `X` is Lindelöf. -/\ninstance (priority := 100) [CompactSpace X] : LindelofSpace X :=\n  { isLindelof_univ := isCompact_univ.isLindelof}\n\n"}
{"name":"instLindelofSpaceOfSigmaCompactSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : SigmaCompactSpace X\n⊢ LindelofSpace X","decl":"/-- A sigma-compact space `X` is Lindelöf. -/\ninstance (priority := 100) [SigmaCompactSpace X] : LindelofSpace X :=\n  { isLindelof_univ := isSigmaCompact_univ.isLindelof}\n\n"}
{"name":"NonLindelofSpace.nonLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nself : NonLindelofSpace X\n⊢ Not (IsLindelof Set.univ)","decl":"/-- `X` is a non-Lindelöf topological space if it is not a Lindelöf space. -/\nclass NonLindelofSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- In a non-Lindelöf space, `Set.univ` is not a Lindelöf set. -/\n  nonLindelof_univ : ¬IsLindelof (univ : Set X)\n\n"}
{"name":"nonLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : NonLindelofSpace X\n⊢ Not (IsLindelof Set.univ)","decl":"lemma nonLindelof_univ (X : Type*) [TopologicalSpace X] [NonLindelofSpace X] :\n    ¬IsLindelof (univ : Set X) :=\n  NonLindelofSpace.nonLindelof_univ\n\n"}
{"name":"IsLindelof.ne_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : NonLindelofSpace X\nhs : IsLindelof s\n⊢ Ne s Set.univ","decl":"theorem IsLindelof.ne_univ [NonLindelofSpace X] (hs : IsLindelof s) : s ≠ univ := fun h ↦\n  nonLindelof_univ X (h ▸ hs)\n\n"}
{"name":"instNeBotCoLindelofOfNonLindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : NonLindelofSpace X\n⊢ (Filter.coLindelof X).NeBot","decl":"instance [NonLindelofSpace X] : NeBot (Filter.coLindelof X) := by\n  refine hasBasis_coLindelof.neBot_iff.2 fun {s} hs => ?_\n  contrapose hs\n  rw [not_nonempty_iff_eq_empty, compl_empty_iff] at hs\n  rw [hs]\n  exact nonLindelof_univ X\n\n"}
{"name":"Filter.coLindelof_eq_bot","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : LindelofSpace X\n⊢ Eq (Filter.coLindelof X) Bot.bot","decl":"@[simp]\ntheorem Filter.coLindelof_eq_bot [LindelofSpace X] : Filter.coLindelof X = ⊥ :=\n  hasBasis_coLindelof.eq_bot_iff.mpr ⟨Set.univ, isLindelof_univ, Set.compl_univ⟩\n\n"}
{"name":"instNeBotCoclosedLindelofOfNonLindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : NonLindelofSpace X\n⊢ (Filter.coclosedLindelof X).NeBot","decl":"instance [NonLindelofSpace X] : NeBot (Filter.coclosedLindelof X) :=\n  neBot_of_le coLindelof_le_coclosedLindelof\n\n"}
{"name":"nonLindelofSpace_of_neBot","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx✝ : (Filter.coLindelof X).NeBot\n⊢ NonLindelofSpace X","decl":"theorem nonLindelofSpace_of_neBot (_ : NeBot (Filter.coLindelof X)) : NonLindelofSpace X :=\n  ⟨fun h' => (Filter.nonempty_of_mem h'.compl_mem_coLindelof).ne_empty compl_univ⟩\n\n"}
{"name":"Filter.coLindelof_neBot_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Iff (Filter.coLindelof X).NeBot (NonLindelofSpace X)","decl":"theorem Filter.coLindelof_neBot_iff : NeBot (Filter.coLindelof X) ↔ NonLindelofSpace X :=\n  ⟨nonLindelofSpace_of_neBot, fun _ => inferInstance⟩\n\n\n"}
{"name":"not_LindelofSpace_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Iff (Not (LindelofSpace X)) (NonLindelofSpace X)","decl":"theorem not_LindelofSpace_iff : ¬LindelofSpace X ↔ NonLindelofSpace X :=\n  ⟨fun h₁ => ⟨fun h₂ => h₁ ⟨h₂⟩⟩, fun ⟨h₁⟩ ⟨h₂⟩ => h₁ h₂⟩\n\n"}
{"name":"instLindelofSpaceOfCompactSpace_1","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : CompactSpace X\n⊢ LindelofSpace X","decl":"/-- A compact space `X` is Lindelöf. -/\ninstance (priority := 100) [CompactSpace X] : LindelofSpace X :=\n  { isLindelof_univ := isCompact_univ.isLindelof}\n\n"}
{"name":"countable_of_Lindelof_of_discrete","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝² : TopologicalSpace X\ninst✝¹ : LindelofSpace X\ninst✝ : DiscreteTopology X\n⊢ Countable X","decl":"theorem countable_of_Lindelof_of_discrete [LindelofSpace X] [DiscreteTopology X] : Countable X :=\n  countable_univ_iff.mp isLindelof_univ.countable_of_discrete\n\n"}
{"name":"countable_cover_nhds_interior","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : LindelofSpace X\nU : X → Set X\nhU : ∀ (x : X), Membership.mem (nhds x) (U x)\n⊢ Exists fun t => And t.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => interior (U x)) Set.univ)","decl":"theorem countable_cover_nhds_interior [LindelofSpace X] {U : X → Set X} (hU : ∀ x, U x ∈ 𝓝 x) :\n    ∃ t : Set X, t.Countable ∧ ⋃ x ∈ t, interior (U x) = univ :=\n  let ⟨t, ht⟩ := isLindelof_univ.elim_countable_subcover (fun x => interior (U x))\n    (fun _ => isOpen_interior) fun x _ => mem_iUnion.2 ⟨x, mem_interior_iff_mem_nhds.2 (hU x)⟩\n  ⟨t, ⟨ht.1, univ_subset_iff.1 ht.2⟩⟩\n\n"}
{"name":"countable_cover_nhds","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : LindelofSpace X\nU : X → Set X\nhU : ∀ (x : X), Membership.mem (nhds x) (U x)\n⊢ Exists fun t => And t.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => U x) Set.univ)","decl":"theorem countable_cover_nhds [LindelofSpace X] {U : X → Set X} (hU : ∀ x, U x ∈ 𝓝 x) :\n    ∃ t : Set X, t.Countable ∧ ⋃ x ∈ t, U x = univ :=\n  let ⟨t, ht⟩ := countable_cover_nhds_interior hU\n  ⟨t, ⟨ht.1, univ_subset_iff.1 <| ht.2.symm.subset.trans <|\n    iUnion₂_mono fun _ _ => interior_subset⟩⟩\n\n"}
{"name":"Filter.comap_coLindelof_le","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\n⊢ LE.le (Filter.comap f (Filter.coLindelof Y)) (Filter.coLindelof X)","decl":"/-- The comap of the coLindelöf filter on `Y` by a continuous function `f : X → Y` is less than or\nequal to the coLindelöf filter on `X`.\nThis is a reformulation of the fact that images of Lindelöf sets are Lindelöf. -/\ntheorem Filter.comap_coLindelof_le {f : X → Y} (hf : Continuous f) :\n    (Filter.coLindelof Y).comap f ≤ Filter.coLindelof X := by\n  rw [(hasBasis_coLindelof.comap f).le_basis_iff hasBasis_coLindelof]\n  intro t ht\n  refine ⟨f '' t, ht.image hf, ?_⟩\n  simpa using t.subset_preimage_image f\n\n"}
{"name":"isLindelof_range","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : LindelofSpace X\nf : X → Y\nhf : Continuous f\n⊢ IsLindelof (Set.range f)","decl":"theorem isLindelof_range [LindelofSpace X] {f : X → Y} (hf : Continuous f) :\n    IsLindelof (range f) := by rw [← image_univ]; exact isLindelof_univ.image hf\n\n"}
{"name":"isLindelof_diagonal","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : LindelofSpace X\n⊢ IsLindelof (Set.diagonal X)","decl":"theorem isLindelof_diagonal [LindelofSpace X] : IsLindelof (diagonal X) :=\n  @range_diag X ▸ isLindelof_range (continuous_id.prod_mk continuous_id)\n\n"}
{"name":"Topology.IsInducing.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (IsLindelof s) (IsLindelof (Set.image f s))","decl":"/-- If `f : X → Y` is an inducing map, the image `f '' s` of a set `s` is Lindelöf\n  if and only if `s` is compact. -/\ntheorem Topology.IsInducing.isLindelof_iff {f : X → Y} (hf : IsInducing f) :\n    IsLindelof s ↔ IsLindelof (f '' s) := by\n  refine ⟨fun hs => hs.image hf.continuous, fun hs F F_ne_bot _ F_le => ?_⟩\n  obtain ⟨_, ⟨x, x_in : x ∈ s, rfl⟩, hx : ClusterPt (f x) (map f F)⟩ :=\n    hs ((map_mono F_le).trans_eq map_principal)\n  exact ⟨x, x_in, hf.mapClusterPt_iff.1 hx⟩\n\n"}
{"name":"Inducing.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (IsLindelof s) (IsLindelof (Set.image f s))","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.isLindelof_iff := IsInducing.isLindelof_iff\n\n"}
{"name":"Topology.IsEmbedding.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsEmbedding f\n⊢ Iff (IsLindelof s) (IsLindelof (Set.image f s))","decl":"/-- If `f : X → Y` is an embedding, the image `f '' s` of a set `s` is Lindelöf\nif and only if `s` is Lindelöf. -/\ntheorem Topology.IsEmbedding.isLindelof_iff {f : X → Y} (hf : IsEmbedding f) :\n    IsLindelof s ↔ IsLindelof (f '' s) := hf.isInducing.isLindelof_iff\n\n"}
{"name":"Embedding.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Topology.IsEmbedding f\n⊢ Iff (IsLindelof s) (IsLindelof (Set.image f s))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.isLindelof_iff := IsEmbedding.isLindelof_iff\n\n"}
{"name":"Topology.IsInducing.isLindelof_preimage","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nhf' : IsClosed (Set.range f)\nK : Set Y\nhK : IsLindelof K\n⊢ IsLindelof (Set.preimage f K)","decl":"/-- The preimage of a Lindelöf set under an inducing map is a Lindelöf set. -/\ntheorem Topology.IsInducing.isLindelof_preimage {f : X → Y} (hf : IsInducing f)\n    (hf' : IsClosed (range f)) {K : Set Y} (hK : IsLindelof K) : IsLindelof (f ⁻¹' K) := by\n  replace hK := hK.inter_right hf'\n  rwa [hf.isLindelof_iff, image_preimage_eq_inter_range]\n\n"}
{"name":"Inducing.isLindelof_preimage","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsInducing f\nhf' : IsClosed (Set.range f)\nK : Set Y\nhK : IsLindelof K\n⊢ IsLindelof (Set.preimage f K)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isLindelof_preimage := IsInducing.isLindelof_preimage\n\n"}
{"name":"Topology.IsClosedEmbedding.isLindelof_preimage","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\nK : Set Y\nhK : IsLindelof K\n⊢ IsLindelof (Set.preimage f K)","decl":"/-- The preimage of a Lindelöf set under a closed embedding is a Lindelöf set. -/\ntheorem Topology.IsClosedEmbedding.isLindelof_preimage {f : X → Y} (hf : IsClosedEmbedding f)\n    {K : Set Y} (hK : IsLindelof K) : IsLindelof (f ⁻¹' K) :=\n  hf.isInducing.isLindelof_preimage (hf.isClosed_range) hK\n\n"}
{"name":"ClosedEmbedding.isLindelof_preimage","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\nK : Set Y\nhK : IsLindelof K\n⊢ IsLindelof (Set.preimage f K)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.isLindelof_preimage := IsClosedEmbedding.isLindelof_preimage\n\n"}
{"name":"Topology.IsClosedEmbedding.tendsto_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ Filter.Tendsto f (Filter.coLindelof X) (Filter.coLindelof Y)","decl":"/-- A closed embedding is proper, ie, inverse images of Lindelöf sets are contained in Lindelöf.\nMoreover, the preimage of a Lindelöf set is Lindelöf, see\n`Topology.IsClosedEmbedding.isLindelof_preimage`. -/\ntheorem Topology.IsClosedEmbedding.tendsto_coLindelof {f : X → Y} (hf : IsClosedEmbedding f) :\n    Tendsto f (Filter.coLindelof X) (Filter.coLindelof Y) :=\n  hasBasis_coLindelof.tendsto_right_iff.mpr fun _K hK =>\n    (hf.isLindelof_preimage hK).compl_mem_coLindelof\n\n"}
{"name":"ClosedEmbedding.tendsto_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ Filter.Tendsto f (Filter.coLindelof X) (Filter.coLindelof Y)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.tendsto_coLindelof := IsClosedEmbedding.tendsto_coLindelof\n\n"}
{"name":"Subtype.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\ns : Set (Subtype fun x => p x)\n⊢ Iff (IsLindelof s) (IsLindelof (Set.image Subtype.val s))","decl":"/-- Sets of subtype are Lindelöf iff the image under a coercion is. -/\ntheorem Subtype.isLindelof_iff {p : X → Prop} {s : Set { x // p x }} :\n    IsLindelof s ↔ IsLindelof ((↑) '' s : Set X) :=\n  IsEmbedding.subtypeVal.isLindelof_iff\n\n"}
{"name":"isLindelof_iff_isLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsLindelof s) (IsLindelof Set.univ)","decl":"theorem isLindelof_iff_isLindelof_univ : IsLindelof s ↔ IsLindelof (univ : Set s) := by\n  rw [Subtype.isLindelof_iff, image_univ, Subtype.range_coe]\n\n"}
{"name":"isLindelof_iff_LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsLindelof s) (LindelofSpace ↑s)","decl":"theorem isLindelof_iff_LindelofSpace : IsLindelof s ↔ LindelofSpace s :=\n  isLindelof_iff_isLindelof_univ.trans isLindelof_univ_iff\n\n"}
{"name":"IsLindelof.of_coe","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : LindelofSpace ↑s\n⊢ IsLindelof s","decl":"lemma IsLindelof.of_coe [LindelofSpace s] : IsLindelof s := isLindelof_iff_LindelofSpace.mpr ‹_›\n\n"}
{"name":"IsLindelof.countable","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nhs' : DiscreteTopology ↑s\n⊢ s.Countable","decl":"theorem IsLindelof.countable (hs : IsLindelof s) (hs' : DiscreteTopology s) : s.Countable :=\n  countable_coe_iff.mp\n  (@countable_of_Lindelof_of_discrete _ _ (isLindelof_iff_LindelofSpace.mp hs) hs')\n\n"}
{"name":"Topology.IsClosedEmbedding.nonLindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NonLindelofSpace X\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ NonLindelofSpace Y","decl":"protected theorem Topology.IsClosedEmbedding.nonLindelofSpace [NonLindelofSpace X] {f : X → Y}\n    (hf : IsClosedEmbedding f) : NonLindelofSpace Y :=\n  nonLindelofSpace_of_neBot hf.tendsto_coLindelof.neBot\n\n"}
{"name":"ClosedEmbedding.nonLindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NonLindelofSpace X\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ NonLindelofSpace Y","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.nonLindelofSpace := IsClosedEmbedding.nonLindelofSpace\n\n"}
{"name":"Topology.IsClosedEmbedding.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nh : LindelofSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ LindelofSpace X","decl":"protected theorem Topology.IsClosedEmbedding.LindelofSpace [h : LindelofSpace Y] {f : X → Y}\n    (hf : IsClosedEmbedding f) : LindelofSpace X :=\n  ⟨by rw [hf.isInducing.isLindelof_iff, image_univ]; exact hf.isClosed_range.isLindelof⟩\n\n"}
{"name":"ClosedEmbedding.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nh : LindelofSpace Y\nf : X → Y\nhf : Topology.IsClosedEmbedding f\n⊢ LindelofSpace X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.LindelofSpace := IsClosedEmbedding.LindelofSpace\n\n"}
{"name":"Countable.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : Countable X\n⊢ LindelofSpace X","decl":"/-- Countable topological spaces are Lindelof. -/\ninstance (priority := 100) Countable.LindelofSpace [Countable X] : LindelofSpace X where\n  isLindelof_univ := countable_univ.isLindelof\n\n"}
{"name":"instLindelofSpaceSum","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : LindelofSpace X\ninst✝ : LindelofSpace Y\n⊢ LindelofSpace (Sum X Y)","decl":"/-- The disjoint union of two Lindelöf spaces is Lindelöf. -/\ninstance [LindelofSpace X] [LindelofSpace Y] : LindelofSpace (X ⊕ Y) where\n  isLindelof_univ := by\n    rw [← range_inl_union_range_inr]\n    exact (isLindelof_range continuous_inl).union (isLindelof_range continuous_inr)\n\n"}
{"name":"instLindelofSpaceSigmaOfCountable","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝² : Countable ι\ninst✝¹ : (i : ι) → TopologicalSpace (X i)\ninst✝ : ∀ (i : ι), LindelofSpace (X i)\n⊢ LindelofSpace (Sigma fun i => X i)","decl":"instance {X : ι → Type*} [Countable ι] [∀ i, TopologicalSpace (X i)] [∀ i, LindelofSpace (X i)] :\n    LindelofSpace (Σi, X i) where\n  isLindelof_univ := by\n    rw [Sigma.univ]\n    exact isLindelof_iUnion fun i => isLindelof_range continuous_sigmaMk\n\n"}
{"name":"Quot.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nr : X → X → Prop\ninst✝ : LindelofSpace X\n⊢ LindelofSpace (Quot r)","decl":"instance Quot.LindelofSpace {r : X → X → Prop} [LindelofSpace X] : LindelofSpace (Quot r) where\n  isLindelof_univ := by\n    rw [← range_quot_mk]\n    exact isLindelof_range continuous_quot_mk\n\n"}
{"name":"Quotient.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ns : Setoid X\ninst✝ : LindelofSpace X\n⊢ LindelofSpace (Quotient s)","decl":"instance Quotient.LindelofSpace {s : Setoid X} [LindelofSpace X] : LindelofSpace (Quotient s) :=\n  Quot.LindelofSpace\n\n"}
{"name":"LindelofSpace.of_continuous_surjective","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nf : X → Y\ninst✝ : LindelofSpace X\nhf : Continuous f\nhsur : Function.Surjective f\n⊢ LindelofSpace Y","decl":"/-- A continuous image of a Lindelöf set is a Lindelöf set within the codomain. -/\ntheorem LindelofSpace.of_continuous_surjective {f : X → Y} [LindelofSpace X] (hf : Continuous f)\n    (hsur : Function.Surjective f) : LindelofSpace Y where\n  isLindelof_univ := by\n    rw [← Set.image_univ_of_surjective hsur]\n    exact IsLindelof.image (isLindelof_univ_iff.mpr ‹_›) hf\n\n"}
{"name":"HereditarilyLindelofSpace.isHereditarilyLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u_2\ninst✝ : TopologicalSpace X\nself : HereditarilyLindelofSpace X\n⊢ IsHereditarilyLindelof Set.univ","decl":"/-- Type class for Hereditarily Lindelöf spaces. -/\nclass HereditarilyLindelofSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- In a Hereditarily Lindelöf space, `Set.univ` is a Hereditarily Lindelöf set. -/\n  isHereditarilyLindelof_univ : IsHereditarilyLindelof (univ : Set X)\n\n"}
{"name":"IsHereditarilyLindelof.isLindelof_subset","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsHereditarilyLindelof s\nht : HasSubset.Subset t s\n⊢ IsLindelof t","decl":"lemma IsHereditarilyLindelof.isLindelof_subset (hs : IsHereditarilyLindelof s) (ht : t ⊆ s) :\n    IsLindelof t := hs t ht\n\n"}
{"name":"IsHereditarilyLindelof.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsHereditarilyLindelof s\n⊢ IsLindelof s","decl":"lemma IsHereditarilyLindelof.isLindelof (hs : IsHereditarilyLindelof s) :\n    IsLindelof s := hs.isLindelof_subset Subset.rfl\n\n"}
{"name":"HereditarilyLindelof.to_Lindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : HereditarilyLindelofSpace X\n⊢ LindelofSpace X","decl":"instance (priority := 100) HereditarilyLindelof.to_Lindelof [HereditarilyLindelofSpace X] :\n    LindelofSpace X where\n  isLindelof_univ := HereditarilyLindelofSpace.isHereditarilyLindelof_univ.isLindelof\n\n"}
{"name":"HereditarilyLindelof_LindelofSets","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : HereditarilyLindelofSpace X\ns : Set X\n⊢ IsLindelof s","decl":"theorem HereditarilyLindelof_LindelofSets [HereditarilyLindelofSpace X] (s : Set X) :\n    IsLindelof s := by\n  apply HereditarilyLindelofSpace.isHereditarilyLindelof_univ\n  exact subset_univ s\n\n"}
{"name":"SecondCountableTopology.toHereditarilyLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : SecondCountableTopology X\n⊢ HereditarilyLindelofSpace X","decl":"instance (priority := 100) SecondCountableTopology.toHereditarilyLindelof\n    [SecondCountableTopology X] : HereditarilyLindelofSpace X where\n  isHereditarilyLindelof_univ t _ _ := by\n    apply isLindelof_iff_countable_subcover.mpr\n    intro ι U hι hcover\n    have := @isOpen_iUnion_countable X _ _ ι U hι\n    rcases this with ⟨t, ⟨htc, htu⟩⟩\n    use t, htc\n    exact subset_of_subset_of_eq hcover (id htu.symm)\n\n"}
{"name":"eq_open_union_countable","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : HereditarilyLindelofSpace X\nι : Type u\nU : ι → Set X\nh : ∀ (i : ι), IsOpen (U i)\n⊢ Exists fun t => And t.Countable (Eq (Set.iUnion fun i => Set.iUnion fun h => U i) (Set.iUnion fun i => U i))","decl":"lemma eq_open_union_countable [HereditarilyLindelofSpace X] {ι : Type u} (U : ι → Set X)\n    (h : ∀ i, IsOpen (U i)) : ∃ t : Set ι, t.Countable ∧ ⋃ i∈t, U i = ⋃ i, U i := by\n  have : IsLindelof (⋃ i, U i) := HereditarilyLindelof_LindelofSets (⋃ i, U i)\n  rcases isLindelof_iff_countable_subcover.mp this U h (Eq.subset rfl) with ⟨t, ⟨htc, htu⟩⟩\n  use t, htc\n  apply eq_of_subset_of_subset (iUnion₂_subset_iUnion (fun i ↦ i ∈ t) fun i ↦ U i) htu\n\n"}
{"name":"HereditarilyLindelof.lindelofSpace_subtype","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : HereditarilyLindelofSpace X\np : X → Prop\n⊢ LindelofSpace (Subtype fun x => p x)","decl":"instance HereditarilyLindelof.lindelofSpace_subtype [HereditarilyLindelofSpace X] (p : X → Prop) :\n    LindelofSpace {x // p x} := by\n  apply isLindelof_iff_LindelofSpace.mp\n  exact HereditarilyLindelof_LindelofSets fun x ↦ p x\n\n"}
