{"name":"IsLindelof.compl_mem_sets","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nf : Filter X\ninstâœ : CountableInterFilter f\nhf : âˆ€ (x : X), Membership.mem s x â†’ Membership.mem (Min.min (nhds x) f) (HasCompl.compl s)\nâŠ¢ Membership.mem f (HasCompl.compl s)","decl":"/-- The complement to a LindelÃ¶f set belongs to a filter `f` with the countable intersection\n  property if it belongs to each filter `ğ“ x âŠ“ f`, `x âˆˆ s`. -/\ntheorem IsLindelof.compl_mem_sets (hs : IsLindelof s) {f : Filter X} [CountableInterFilter f]\n    (hf : âˆ€ x âˆˆ s, sá¶œ âˆˆ ğ“ x âŠ“ f) : sá¶œ âˆˆ f := by\n  contrapose! hf\n  simp only [not_mem_iff_inf_principal_compl, compl_compl, inf_assoc] at hf âŠ¢\n  exact hs inf_le_right\n\n"}
{"name":"IsLindelof.compl_mem_sets_of_nhdsWithin","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nf : Filter X\ninstâœ : CountableInterFilter f\nhf : âˆ€ (x : X), Membership.mem s x â†’ Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Membership.mem f (HasCompl.compl t))\nâŠ¢ Membership.mem f (HasCompl.compl s)","decl":"/-- The complement to a LindelÃ¶f set belongs to a filter `f` with the countable intersection\n  property if each `x âˆˆ s` has a neighborhood `t` within `s` such that `tá¶œ` belongs to `f`. -/\ntheorem IsLindelof.compl_mem_sets_of_nhdsWithin (hs : IsLindelof s) {f : Filter X}\n    [CountableInterFilter f] (hf : âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, tá¶œ âˆˆ f) : sá¶œ âˆˆ f := by\n  refine hs.compl_mem_sets fun x hx â†¦ ?_\n  rw [â† disjoint_principal_right, disjoint_right_comm, (basis_sets _).disjoint_iff_left]\n  exact hf x hx\n\n"}
{"name":"IsLindelof.induction_on","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\np : Set X â†’ Prop\nhmono : âˆ€ â¦ƒs t : Set Xâ¦„, HasSubset.Subset s t â†’ p t â†’ p s\nhcountable_union : âˆ€ (S : Set (Set X)), S.Countable â†’ (âˆ€ (s : Set X), Membership.mem S s â†’ p s) â†’ p S.sUnion\nhnhds : âˆ€ (x : X), Membership.mem s x â†’ Exists fun t => And (Membership.mem (nhdsWithin x s) t) (p t)\nâŠ¢ p s","decl":"/-- If `p : Set X â†’ Prop` is stable under restriction and union, and each point `x`\n  of a LindelÃ¶f set `s` has a neighborhood `t` within `s` such that `p t`, then `p s` holds. -/\n@[elab_as_elim]\ntheorem IsLindelof.induction_on (hs : IsLindelof s) {p : Set X â†’ Prop}\n    (hmono : âˆ€ â¦ƒs tâ¦„, s âŠ† t â†’ p t â†’ p s)\n    (hcountable_union : âˆ€ (S : Set (Set X)), S.Countable â†’ (âˆ€ s âˆˆ S, p s) â†’ p (â‹ƒâ‚€ S))\n    (hnhds : âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, p t) : p s := by\n  let f : Filter X := ofCountableUnion p hcountable_union (fun t ht _ hsub â†¦ hmono hsub ht)\n  have : sá¶œ âˆˆ f := hs.compl_mem_sets_of_nhdsWithin (by simpa [f] using hnhds)\n  rwa [â† compl_compl s]\n\n"}
{"name":"IsLindelof.inter_right","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nhs : IsLindelof s\nht : IsClosed t\nâŠ¢ IsLindelof (Inter.inter s t)","decl":"/-- The intersection of a LindelÃ¶f set and a closed set is a LindelÃ¶f set. -/\ntheorem IsLindelof.inter_right (hs : IsLindelof s) (ht : IsClosed t) : IsLindelof (s âˆ© t) := by\n  intro f hnf _ hstf\n  rw [â† inf_principal, le_inf_iff] at hstf\n  obtain âŸ¨x, hsx, hxâŸ© : âˆƒ x âˆˆ s, ClusterPt x f := hs hstf.1\n  have hxt : x âˆˆ t := ht.mem_of_nhdsWithin_neBot <| hx.mono hstf.2\n  exact âŸ¨x, âŸ¨hsx, hxtâŸ©, hxâŸ©\n\n"}
{"name":"IsLindelof.inter_left","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nht : IsLindelof t\nhs : IsClosed s\nâŠ¢ IsLindelof (Inter.inter s t)","decl":"/-- The intersection of a closed set and a LindelÃ¶f set is a LindelÃ¶f set. -/\ntheorem IsLindelof.inter_left (ht : IsLindelof t) (hs : IsClosed s) : IsLindelof (s âˆ© t) :=\n  inter_comm t s â–¸ ht.inter_right hs\n\n"}
{"name":"IsLindelof.diff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nhs : IsLindelof s\nht : IsOpen t\nâŠ¢ IsLindelof (SDiff.sdiff s t)","decl":"/-- The set difference of a LindelÃ¶f set and an open set is a LindelÃ¶f set. -/\ntheorem IsLindelof.diff (hs : IsLindelof s) (ht : IsOpen t) : IsLindelof (s \\ t) :=\n  hs.inter_right (isClosed_compl_iff.mpr ht)\n\n"}
{"name":"IsLindelof.of_isClosed_subset","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nhs : IsLindelof s\nht : IsClosed t\nh : HasSubset.Subset t s\nâŠ¢ IsLindelof t","decl":"/-- A closed subset of a LindelÃ¶f set is a LindelÃ¶f set. -/\ntheorem IsLindelof.of_isClosed_subset (hs : IsLindelof s) (ht : IsClosed t) (h : t âŠ† s) :\n    IsLindelof t := inter_eq_self_of_subset_right h â–¸ hs.inter_right ht\n\n"}
{"name":"IsLindelof.image_of_continuousOn","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nf : X â†’ Y\nhs : IsLindelof s\nhf : ContinuousOn f s\nâŠ¢ IsLindelof (Set.image f s)","decl":"/-- A continuous image of a LindelÃ¶f set is a LindelÃ¶f set. -/\ntheorem IsLindelof.image_of_continuousOn {f : X â†’ Y} (hs : IsLindelof s) (hf : ContinuousOn f s) :\n    IsLindelof (f '' s) := by\n  intro l lne _ ls\n  have : NeBot (l.comap f âŠ“ ğ“Ÿ s) :=\n    comap_inf_principal_neBot_of_image_mem lne (le_principal_iff.1 ls)\n  obtain âŸ¨x, hxs, hxâŸ© : âˆƒ x âˆˆ s, ClusterPt x (l.comap f âŠ“ ğ“Ÿ s) := @hs _ this _ inf_le_right\n  haveI := hx.neBot\n  use f x, mem_image_of_mem f hxs\n  have : Tendsto f (ğ“ x âŠ“ (comap f l âŠ“ ğ“Ÿ s)) (ğ“ (f x) âŠ“ l) := by\n    convert (hf x hxs).inf (@tendsto_comap _ _ f l) using 1\n    rw [nhdsWithin]\n    ac_rfl\n  exact this.neBot\n\n"}
{"name":"IsLindelof.image","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nf : X â†’ Y\nhs : IsLindelof s\nhf : Continuous f\nâŠ¢ IsLindelof (Set.image f s)","decl":"/-- A continuous image of a LindelÃ¶f set is a LindelÃ¶f set within the codomain. -/\ntheorem IsLindelof.image {f : X â†’ Y} (hs : IsLindelof s) (hf : Continuous f) :\n    IsLindelof (f '' s) := hs.image_of_continuousOn hf.continuousOn\n\n"}
{"name":"IsLindelof.adherence_nhdset","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns t : Set X\nf : Filter X\ninstâœ : CountableInterFilter f\nhs : IsLindelof s\nhfâ‚‚ : LE.le f (Filter.principal s)\nhtâ‚ : IsOpen t\nhtâ‚‚ : âˆ€ (x : X), Membership.mem s x â†’ ClusterPt x f â†’ Membership.mem t x\nâŠ¢ Membership.mem f t","decl":"/-- A filter with the countable intersection property that is finer than the principal filter on\na LindelÃ¶f set `s` contains any open set that contains all clusterpoints of `s`. -/\ntheorem IsLindelof.adherence_nhdset {f : Filter X} [CountableInterFilter f] (hs : IsLindelof s)\n    (hfâ‚‚ : f â‰¤ ğ“Ÿ s) (htâ‚ : IsOpen t) (htâ‚‚ : âˆ€ x âˆˆ s, ClusterPt x f â†’ x âˆˆ t) : t âˆˆ f :=\n  (eq_or_neBot _).casesOn mem_of_eq_bot fun _ â†¦\n    let âŸ¨x, hx, hfxâŸ© := @hs (f âŠ“ ğ“Ÿ tá¶œ) _ _ <| inf_le_of_left_le hfâ‚‚\n    have : x âˆˆ t := htâ‚‚ x hx hfx.of_inf_left\n    have : tá¶œ âˆ© t âˆˆ ğ“[tá¶œ] x := inter_mem_nhdsWithin _ (htâ‚.mem_nhds this)\n    have A : ğ“[tá¶œ] x = âŠ¥ := empty_mem_iff_bot.1 <| compl_inter_self t â–¸ this\n    have : ğ“[tá¶œ] x â‰  âŠ¥ := hfx.of_inf_right.ne\n    absurd A this\n\n"}
{"name":"IsLindelof.elim_countable_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nÎ¹ : Type v\nhs : IsLindelof s\nU : Î¹ â†’ Set X\nhUo : âˆ€ (i : Î¹), IsOpen (U i)\nhsU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun r => And r.Countable (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i))","decl":"/-- For every open cover of a LindelÃ¶f set, there exists a countable subcover. -/\ntheorem IsLindelof.elim_countable_subcover {Î¹ : Type v} (hs : IsLindelof s) (U : Î¹ â†’ Set X)\n    (hUo : âˆ€ i, IsOpen (U i)) (hsU : s âŠ† â‹ƒ i, U i) :\n    âˆƒ r : Set Î¹, r.Countable âˆ§ (s âŠ† â‹ƒ i âˆˆ r, U i) := by\n  have hmono : âˆ€ â¦ƒs t : Set Xâ¦„, s âŠ† t â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i)\n      â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ r, U i) := by\n    intro _ _ hst âŸ¨r, âŸ¨hrcountable, hsubâŸ©âŸ©\n    exact âŸ¨r, hrcountable, Subset.trans hst hsubâŸ©\n  have hcountable_union : âˆ€ (S : Set (Set X)), S.Countable\n      â†’ (âˆ€ s âˆˆ S, âˆƒ r : Set Î¹, r.Countable âˆ§ (s âŠ† â‹ƒ i âˆˆ r, U i))\n      â†’ âˆƒ r : Set Î¹, r.Countable âˆ§ (â‹ƒâ‚€ S âŠ† â‹ƒ i âˆˆ r, U i) := by\n    intro S hS hsr\n    choose! r hr using hsr\n    refine âŸ¨â‹ƒ s âˆˆ S, r s, hS.biUnion_iff.mpr (fun s hs â†¦ (hr s hs).1), ?_âŸ©\n    refine sUnion_subset ?h.right.h\n    simp only [mem_iUnion, exists_prop, iUnion_exists, biUnion_and']\n    exact fun i is x hx â†¦ mem_biUnion is ((hr i is).2 hx)\n  have h_nhds : âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆƒ r : Set Î¹, r.Countable âˆ§ (t âŠ† â‹ƒ i âˆˆ r, U i) := by\n    intro x hx\n    let âŸ¨i, hiâŸ© := mem_iUnion.1 (hsU hx)\n    refine âŸ¨U i, mem_nhdsWithin_of_mem_nhds ((hUo i).mem_nhds hi), {i}, by simp, ?_âŸ©\n    simp only [mem_singleton_iff, iUnion_iUnion_eq_left]\n    exact Subset.refl _\n  exact hs.induction_on hmono hcountable_union h_nhds\n\n"}
{"name":"IsLindelof.elim_nhds_subcover'","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nU : (x : X) â†’ Membership.mem s x â†’ Set X\nhU : âˆ€ (x : X), Membership.mem s x â†’ Membership.mem (nhds x) (U x â‹¯)\nâŠ¢ Exists fun t => And t.Countable (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => U â†‘x â‹¯))","decl":"theorem IsLindelof.elim_nhds_subcover' (hs : IsLindelof s) (U : âˆ€ x âˆˆ s, Set X)\n    (hU : âˆ€ x (hx : x âˆˆ s), U x â€¹x âˆˆ sâ€º âˆˆ ğ“ x) :\n    âˆƒ t : Set s, t.Countable âˆ§ s âŠ† â‹ƒ x âˆˆ t, U (x : s) x.2 := by\n  have := hs.elim_countable_subcover (fun x : s â†¦ interior (U x x.2)) (fun _ â†¦ isOpen_interior)\n    fun x hx â†¦\n      mem_iUnion.2 âŸ¨âŸ¨x, hxâŸ©, mem_interior_iff_mem_nhds.2 <| hU _ _âŸ©\n  rcases this with âŸ¨r, âŸ¨hr, hsâŸ©âŸ©\n  use r, hr\n  apply Subset.trans hs\n  apply iUnionâ‚‚_subset\n  intro i hi\n  apply Subset.trans interior_subset\n  exact subset_iUnion_of_subset i (subset_iUnion_of_subset hi (Subset.refl _))\n\n"}
{"name":"IsLindelof.elim_nhds_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nU : X â†’ Set X\nhU : âˆ€ (x : X), Membership.mem s x â†’ Membership.mem (nhds x) (U x)\nâŠ¢ Exists fun t => And t.Countable (And (âˆ€ (x : X), Membership.mem t x â†’ Membership.mem s x) (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => U x)))","decl":"theorem IsLindelof.elim_nhds_subcover (hs : IsLindelof s) (U : X â†’ Set X)\n    (hU : âˆ€ x âˆˆ s, U x âˆˆ ğ“ x) :\n    âˆƒ t : Set X, t.Countable âˆ§ (âˆ€ x âˆˆ t, x âˆˆ s) âˆ§ s âŠ† â‹ƒ x âˆˆ t, U x := by\n  let âŸ¨t, âŸ¨htc, htsubâŸ©âŸ© := hs.elim_nhds_subcover' (fun x _ â†¦ U x) hU\n  refine âŸ¨â†‘t, Countable.image htc Subtype.val, ?_âŸ©\n  constructor\n  Â· intro _\n    simp only [mem_image, Subtype.exists, exists_and_right, exists_eq_right, forall_exists_index]\n    tauto\n  Â· have : â‹ƒ x âˆˆ t, U â†‘x = â‹ƒ x âˆˆ Subtype.val '' t, U x := biUnion_image.symm\n    rwa [â† this]\n\n"}
{"name":"IsLindelof.indexed_countable_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\nÎ¹ : Type v\ninstâœ : Nonempty Î¹\nhs : IsLindelof s\nU : Î¹ â†’ Set X\nhUo : âˆ€ (i : Î¹), IsOpen (U i)\nhsU : HasSubset.Subset s (Set.iUnion fun i => U i)\nâŠ¢ Exists fun f => HasSubset.Subset s (Set.iUnion fun n => U (f n))","decl":"/-- For every nonempty open cover of a LindelÃ¶f set, there exists a subcover indexed by â„•. -/\ntheorem IsLindelof.indexed_countable_subcover {Î¹ : Type v} [Nonempty Î¹]\n    (hs : IsLindelof s) (U : Î¹ â†’ Set X) (hUo : âˆ€ i, IsOpen (U i)) (hsU : s âŠ† â‹ƒ i, U i) :\n    âˆƒ f : â„• â†’ Î¹, s âŠ† â‹ƒ n, U (f n) := by\n  obtain âŸ¨c, âŸ¨c_count, c_covâŸ©âŸ© := hs.elim_countable_subcover U hUo hsU\n  rcases c.eq_empty_or_nonempty with rfl | c_nonempty\n  Â· simp only [mem_empty_iff_false, iUnion_of_empty, iUnion_empty] at c_cov\n    simp only [subset_eq_empty c_cov rfl, empty_subset, exists_const]\n  obtain âŸ¨f, f_surjâŸ© := (Set.countable_iff_exists_surjective c_nonempty).mp c_count\n  refine âŸ¨fun x â†¦ f x, c_cov.trans <| iUnionâ‚‚_subset_iff.mpr (?_ : âˆ€ i âˆˆ c, U i âŠ† â‹ƒ n, U (f n))âŸ©\n  intro x hx\n  obtain âŸ¨n, hnâŸ© := f_surj âŸ¨x, hxâŸ©\n  exact subset_iUnion_of_subset n <| subset_of_eq (by rw [hn])\n\n"}
{"name":"IsLindelof.disjoint_nhdsSet_left","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\nl : Filter X\ninstâœ : CountableInterFilter l\nhs : IsLindelof s\nâŠ¢ Iff (Disjoint (nhdsSet s) l) (âˆ€ (x : X), Membership.mem s x â†’ Disjoint (nhds x) l)","decl":"/-- The neighborhood filter of a LindelÃ¶f set is disjoint with a filter `l` with the countable\nintersection property if and only if the neighborhood filter of each point of this set\nis disjoint with `l`. -/\ntheorem IsLindelof.disjoint_nhdsSet_left {l : Filter X} [CountableInterFilter l]\n    (hs : IsLindelof s) :\n    Disjoint (ğ“Ë¢ s) l â†” âˆ€ x âˆˆ s, Disjoint (ğ“ x) l := by\n  refine âŸ¨fun h x hx â†¦ h.mono_left <| nhds_le_nhdsSet hx, fun H â†¦ ?_âŸ©\n  choose! U hxU hUl using fun x hx â†¦ (nhds_basis_opens x).disjoint_iff_left.1 (H x hx)\n  choose hxU hUo using hxU\n  rcases hs.elim_nhds_subcover U fun x hx â†¦ (hUo x hx).mem_nhds (hxU x hx) with âŸ¨t, htc, hts, hstâŸ©\n  refine (hasBasis_nhdsSet _).disjoint_iff_left.2\n    âŸ¨â‹ƒ x âˆˆ t, U x, âŸ¨isOpen_biUnion fun x hx â†¦ hUo x (hts x hx), hstâŸ©, ?_âŸ©\n  rw [compl_iUnionâ‚‚]\n  exact (countable_bInter_mem htc).mpr (fun i hi â†¦ hUl _ (hts _ hi))\n\n"}
{"name":"IsLindelof.disjoint_nhdsSet_right","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\nl : Filter X\ninstâœ : CountableInterFilter l\nhs : IsLindelof s\nâŠ¢ Iff (Disjoint l (nhdsSet s)) (âˆ€ (x : X), Membership.mem s x â†’ Disjoint l (nhds x))","decl":"/-- A filter `l` with the countable intersection property is disjoint with the neighborhood\nfilter of a LindelÃ¶f set if and only if it is disjoint with the neighborhood filter of each point\nof this set. -/\ntheorem IsLindelof.disjoint_nhdsSet_right {l : Filter X} [CountableInterFilter l]\n    (hs : IsLindelof s) : Disjoint l (ğ“Ë¢ s) â†” âˆ€ x âˆˆ s, Disjoint l (ğ“ x) := by\n  simpa only [disjoint_comm] using hs.disjoint_nhdsSet_left\n\n"}
{"name":"IsLindelof.elim_countable_subfamily_closed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nÎ¹ : Type v\nhs : IsLindelof s\nt : Î¹ â†’ Set X\nhtc : âˆ€ (i : Î¹), IsClosed (t i)\nhst : Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection\nâŠ¢ Exists fun u => And u.Countable (Eq (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)) EmptyCollection.emptyCollection)","decl":"/-- For every family of closed sets whose intersection avoids a LindelÃ¶ set,\nthere exists a countable subfamily whose intersection avoids this LindelÃ¶f set. -/\ntheorem IsLindelof.elim_countable_subfamily_closed {Î¹ : Type v} (hs : IsLindelof s)\n    (t : Î¹ â†’ Set X) (htc : âˆ€ i, IsClosed (t i)) (hst : (s âˆ© â‹‚ i, t i) = âˆ…) :\n    âˆƒ u : Set Î¹, u.Countable âˆ§ (s âˆ© â‹‚ i âˆˆ u, t i) = âˆ… := by\n  let U := tá¶œ\n  have hUo : âˆ€ i, IsOpen (U i) := by simp only [U, Pi.compl_apply, isOpen_compl_iff]; exact htc\n  have hsU : s âŠ† â‹ƒ i, U i := by\n    simp only [U, Pi.compl_apply]\n    rw [â† compl_iInter]\n    apply disjoint_compl_left_iff_subset.mp\n    simp only [compl_iInter, compl_iUnion, compl_compl]\n    apply Disjoint.symm\n    exact disjoint_iff_inter_eq_empty.mpr hst\n  rcases hs.elim_countable_subcover U hUo hsU with âŸ¨u, âŸ¨hucount, husubâŸ©âŸ©\n  use u, hucount\n  rw [â† disjoint_compl_left_iff_subset] at husub\n  simp only [U, Pi.compl_apply, compl_iUnion, compl_compl] at husub\n  exact disjoint_iff_inter_eq_empty.mp (Disjoint.symm husub)\n\n"}
{"name":"IsLindelof.inter_iInter_nonempty","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nÎ¹ : Type v\nhs : IsLindelof s\nt : Î¹ â†’ Set X\nhtc : âˆ€ (i : Î¹), IsClosed (t i)\nhst : âˆ€ (u : Set Î¹), And u.Countable (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)).Nonempty\nâŠ¢ (Inter.inter s (Set.iInter fun i => t i)).Nonempty","decl":"/-- To show that a LindelÃ¶f set intersects the intersection of a family of closed sets,\n  it is sufficient to show that it intersects every countable subfamily. -/\ntheorem IsLindelof.inter_iInter_nonempty {Î¹ : Type v} (hs : IsLindelof s) (t : Î¹ â†’ Set X)\n    (htc : âˆ€ i, IsClosed (t i)) (hst : âˆ€ u : Set Î¹, u.Countable âˆ§ (s âˆ© â‹‚ i âˆˆ u, t i).Nonempty) :\n    (s âˆ© â‹‚ i, t i).Nonempty := by\n  contrapose! hst\n  rcases hs.elim_countable_subfamily_closed t htc hst with âŸ¨u, âŸ¨_, husubâŸ©âŸ©\n  exact âŸ¨u, fun _ â†¦ husubâŸ©\n\n"}
{"name":"IsLindelof.elim_countable_subcover_image","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nÎ¹ : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nb : Set Î¹\nc : Î¹ â†’ Set X\nhs : IsLindelof s\nhcâ‚ : âˆ€ (i : Î¹), Membership.mem b i â†’ IsOpen (c i)\nhcâ‚‚ : HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => c i)\nâŠ¢ Exists fun b' => And (HasSubset.Subset b' b) (And b'.Countable (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => c i)))","decl":"/-- For every open cover of a LindelÃ¶f set, there exists a countable subcover. -/\ntheorem IsLindelof.elim_countable_subcover_image {b : Set Î¹} {c : Î¹ â†’ Set X} (hs : IsLindelof s)\n    (hcâ‚ : âˆ€ i âˆˆ b, IsOpen (c i)) (hcâ‚‚ : s âŠ† â‹ƒ i âˆˆ b, c i) :\n    âˆƒ b', b' âŠ† b âˆ§ Set.Countable b' âˆ§ s âŠ† â‹ƒ i âˆˆ b', c i := by\n  simp only [Subtype.forall', biUnion_eq_iUnion] at hcâ‚ hcâ‚‚\n  rcases hs.elim_countable_subcover (fun i â†¦ c i : b â†’ Set X) hcâ‚ hcâ‚‚ with âŸ¨d, hdâŸ©\n  refine âŸ¨Subtype.val '' d, by simp, Countable.image hd.1 Subtype.val, ?_âŸ©\n  rw [biUnion_image]\n  exact hd.2\n\n\n"}
{"name":"isLindelof_of_countable_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nh : âˆ€ {Î¹ : Type u} (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ HasSubset.Subset s (Set.iUnion fun i => U i) â†’ Exists fun t => And t.Countable (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i))\nâŠ¢ IsLindelof s","decl":"/-- A set `s` is LindelÃ¶f if for every open cover of `s`, there exists a countable subcover. -/\ntheorem isLindelof_of_countable_subcover\n    (h : âˆ€ {Î¹ : Type u} (U : Î¹ â†’ Set X), (âˆ€ i, IsOpen (U i)) â†’ (s âŠ† â‹ƒ i, U i) â†’\n    âˆƒ t : Set Î¹, t.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ t, U i) :\n    IsLindelof s := fun f hf hfs â†¦ by\n  contrapose! h\n  simp only [ClusterPt, not_neBot, â† disjoint_iff, SetCoe.forall',\n    (nhds_basis_opens _).disjoint_iff_left] at h\n  choose fsub U hU hUf using h\n  refine âŸ¨s, U, fun x â†¦ (hU x).2, fun x hx â†¦ mem_iUnion.2 âŸ¨âŸ¨x, hxâŸ©, (hU _).1 âŸ©, ?_âŸ©\n  intro t ht h\n  have uinf := f.sets_of_superset (le_principal_iff.1 fsub) h\n  have uninf : â‹‚ i âˆˆ t, (U i)á¶œ âˆˆ f := (countable_bInter_mem ht).mpr (fun _ _ â†¦ hUf _)\n  rw [â† compl_iUnionâ‚‚] at uninf\n  have uninf := compl_not_mem uninf\n  simp only [compl_compl] at uninf\n  contradiction\n\n"}
{"name":"isLindelof_of_countable_subfamily_closed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nh : âˆ€ {Î¹ : Type u} (t : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsClosed (t i)) â†’ Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection â†’ Exists fun u => And u.Countable (Eq (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)) EmptyCollection.emptyCollection)\nâŠ¢ IsLindelof s","decl":"/-- A set `s` is LindelÃ¶f if for every family of closed sets whose intersection avoids `s`,\nthere exists a countable subfamily whose intersection avoids `s`. -/\ntheorem isLindelof_of_countable_subfamily_closed\n    (h :\n      âˆ€ {Î¹ : Type u} (t : Î¹ â†’ Set X), (âˆ€ i, IsClosed (t i)) â†’ (s âˆ© â‹‚ i, t i) = âˆ… â†’\n        âˆƒ u : Set Î¹, u.Countable âˆ§ (s âˆ© â‹‚ i âˆˆ u, t i) = âˆ…) :\n    IsLindelof s :=\n  isLindelof_of_countable_subcover fun U hUo hsU â†¦ by\n    rw [â† disjoint_compl_right_iff_subset, compl_iUnion, disjoint_iff] at hsU\n    rcases h (fun i â†¦ (U i)á¶œ) (fun i â†¦ (hUo _).isClosed_compl) hsU with âŸ¨t, htâŸ©\n    refine âŸ¨t, ?_âŸ©\n    rwa [â† disjoint_compl_right_iff_subset, compl_iUnionâ‚‚, disjoint_iff]\n\n"}
{"name":"isLindelof_iff_countable_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Iff (IsLindelof s) (âˆ€ {Î¹ : Type u} (U : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsOpen (U i)) â†’ HasSubset.Subset s (Set.iUnion fun i => U i) â†’ Exists fun t => And t.Countable (HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun h => U i)))","decl":"/-- A set `s` is LindelÃ¶f if and only if\nfor every open cover of `s`, there exists a countable subcover. -/\ntheorem isLindelof_iff_countable_subcover :\n    IsLindelof s â†” âˆ€ {Î¹ : Type u} (U : Î¹ â†’ Set X),\n      (âˆ€ i, IsOpen (U i)) â†’ (s âŠ† â‹ƒ i, U i) â†’ âˆƒ t : Set Î¹, t.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ t, U i :=\n  âŸ¨fun hs â†¦ hs.elim_countable_subcover, isLindelof_of_countable_subcoverâŸ©\n\n"}
{"name":"isLindelof_iff_countable_subfamily_closed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Iff (IsLindelof s) (âˆ€ {Î¹ : Type u} (t : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsClosed (t i)) â†’ Eq (Inter.inter s (Set.iInter fun i => t i)) EmptyCollection.emptyCollection â†’ Exists fun u => And u.Countable (Eq (Inter.inter s (Set.iInter fun i => Set.iInter fun h => t i)) EmptyCollection.emptyCollection))","decl":"/-- A set `s` is LindelÃ¶f if and only if\nfor every family of closed sets whose intersection avoids `s`,\nthere exists a countable subfamily whose intersection avoids `s`. -/\ntheorem isLindelof_iff_countable_subfamily_closed :\n    IsLindelof s â†” âˆ€ {Î¹ : Type u} (t : Î¹ â†’ Set X),\n    (âˆ€ i, IsClosed (t i)) â†’ (s âˆ© â‹‚ i, t i) = âˆ…\n    â†’ âˆƒ u : Set Î¹, u.Countable âˆ§ (s âˆ© â‹‚ i âˆˆ u, t i) = âˆ… :=\n  âŸ¨fun hs â†¦ hs.elim_countable_subfamily_closed, isLindelof_of_countable_subfamily_closedâŸ©\n\n"}
{"name":"isLindelof_empty","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsLindelof EmptyCollection.emptyCollection","decl":"/-- The empty set is a Lindelof set. -/\n@[simp]\ntheorem isLindelof_empty : IsLindelof (âˆ… : Set X) := fun _f hnf _ hsf â†¦\n  Not.elim hnf.ne <| empty_mem_iff_bot.1 <| le_principal_iff.1 hsf\n\n"}
{"name":"isLindelof_singleton","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nx : X\nâŠ¢ IsLindelof (Singleton.singleton x)","decl":"/-- A singleton set is a Lindelof set. -/\n@[simp]\ntheorem isLindelof_singleton {x : X} : IsLindelof ({x} : Set X) := fun _ hf _ hfa â†¦\n  âŸ¨x, rfl, ClusterPt.of_le_nhds'\n    (hfa.trans <| by simpa only [principal_singleton] using pure_le_nhds x) hfâŸ©\n\n"}
{"name":"Set.Subsingleton.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : s.Subsingleton\nâŠ¢ IsLindelof s","decl":"theorem Set.Subsingleton.isLindelof (hs : s.Subsingleton) : IsLindelof s :=\n  Subsingleton.induction_on hs isLindelof_empty fun _ â†¦ isLindelof_singleton\n\n"}
{"name":"Set.Countable.isLindelof_biUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nÎ¹ : Type u_1\ninstâœ : TopologicalSpace X\ns : Set Î¹\nf : Î¹ â†’ Set X\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ IsLindelof (f i)\nâŠ¢ IsLindelof (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Set.Countable.isLindelof_biUnion {s : Set Î¹} {f : Î¹ â†’ Set X} (hs : s.Countable)\n    (hf : âˆ€ i âˆˆ s, IsLindelof (f i)) : IsLindelof (â‹ƒ i âˆˆ s, f i) := by\n  apply isLindelof_of_countable_subcover\n  intro i U hU hUcover\n  have hiU : âˆ€ i âˆˆ s, f i âŠ† â‹ƒ i, U i :=\n    fun _ is â†¦ _root_.subset_trans (subset_biUnion_of_mem is) hUcover\n  have iSets := fun i is â†¦ (hf i is).elim_countable_subcover U hU (hiU i is)\n  choose! r hr using iSets\n  use â‹ƒ i âˆˆ s, r i\n  constructor\n  Â· refine (Countable.biUnion_iff hs).mpr ?h.left.a\n    exact fun s hs â†¦ (hr s hs).1\n  Â· refine iUnionâ‚‚_subset ?h.right.h\n    intro i is\n    simp only [mem_iUnion, exists_prop, iUnion_exists, biUnion_and']\n    intro x hx\n    exact mem_biUnion is ((hr i is).2 hx)\n\n\n"}
{"name":"Set.Finite.isLindelof_biUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nÎ¹ : Type u_1\ninstâœ : TopologicalSpace X\ns : Set Î¹\nf : Î¹ â†’ Set X\nhs : s.Finite\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ IsLindelof (f i)\nâŠ¢ IsLindelof (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Set.Finite.isLindelof_biUnion {s : Set Î¹} {f : Î¹ â†’ Set X} (hs : s.Finite)\n    (hf : âˆ€ i âˆˆ s, IsLindelof (f i)) : IsLindelof (â‹ƒ i âˆˆ s, f i) :=\n  Set.Countable.isLindelof_biUnion (countable hs) hf\n\n"}
{"name":"Finset.isLindelof_biUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nÎ¹ : Type u_1\ninstâœ : TopologicalSpace X\ns : Finset Î¹\nf : Î¹ â†’ Set X\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ IsLindelof (f i)\nâŠ¢ IsLindelof (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Finset.isLindelof_biUnion (s : Finset Î¹) {f : Î¹ â†’ Set X} (hf : âˆ€ i âˆˆ s, IsLindelof (f i)) :\n    IsLindelof (â‹ƒ i âˆˆ s, f i) :=\n  s.finite_toSet.isLindelof_biUnion hf\n\n"}
{"name":"isLindelof_accumulate","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nK : Nat â†’ Set X\nhK : âˆ€ (n : Nat), IsLindelof (K n)\nn : Nat\nâŠ¢ IsLindelof (Set.Accumulate K n)","decl":"theorem isLindelof_accumulate {K : â„• â†’ Set X} (hK : âˆ€ n, IsLindelof (K n)) (n : â„•) :\n    IsLindelof (Accumulate K n) :=\n  (finite_le_nat n).isLindelof_biUnion fun k _ => hK k\n\n"}
{"name":"Set.Countable.isLindelof_sUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nS : Set (Set X)\nhf : S.Countable\nhc : âˆ€ (s : Set X), Membership.mem S s â†’ IsLindelof s\nâŠ¢ IsLindelof S.sUnion","decl":"theorem Set.Countable.isLindelof_sUnion {S : Set (Set X)} (hf : S.Countable)\n    (hc : âˆ€ s âˆˆ S, IsLindelof s) : IsLindelof (â‹ƒâ‚€ S) := by\n  rw [sUnion_eq_biUnion]; exact hf.isLindelof_biUnion hc\n\n"}
{"name":"Set.Finite.isLindelof_sUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nS : Set (Set X)\nhf : S.Finite\nhc : âˆ€ (s : Set X), Membership.mem S s â†’ IsLindelof s\nâŠ¢ IsLindelof S.sUnion","decl":"theorem Set.Finite.isLindelof_sUnion {S : Set (Set X)} (hf : S.Finite)\n    (hc : âˆ€ s âˆˆ S, IsLindelof s) : IsLindelof (â‹ƒâ‚€ S) := by\n  rw [sUnion_eq_biUnion]; exact hf.isLindelof_biUnion hc\n\n"}
{"name":"isLindelof_iUnion","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nÎ¹ : Sort u_2\nf : Î¹ â†’ Set X\ninstâœ : Countable Î¹\nh : âˆ€ (i : Î¹), IsLindelof (f i)\nâŠ¢ IsLindelof (Set.iUnion fun i => f i)","decl":"theorem isLindelof_iUnion {Î¹ : Sort*} {f : Î¹ â†’ Set X} [Countable Î¹] (h : âˆ€ i, IsLindelof (f i)) :\n    IsLindelof (â‹ƒ i, f i) := (countable_range f).isLindelof_sUnion  <| forall_mem_range.2 h\n\n"}
{"name":"Set.Countable.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : s.Countable\nâŠ¢ IsLindelof s","decl":"theorem Set.Countable.isLindelof (hs : s.Countable) : IsLindelof s :=\n  biUnion_of_singleton s â–¸ hs.isLindelof_biUnion fun _ _ => isLindelof_singleton\n\n"}
{"name":"Set.Finite.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : s.Finite\nâŠ¢ IsLindelof s","decl":"theorem Set.Finite.isLindelof (hs : s.Finite) : IsLindelof s :=\n  biUnion_of_singleton s â–¸ hs.isLindelof_biUnion fun _ _ => isLindelof_singleton\n\n"}
{"name":"IsLindelof.countable_of_discrete","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\ninstâœ : DiscreteTopology X\nhs : IsLindelof s\nâŠ¢ s.Countable","decl":"theorem IsLindelof.countable_of_discrete [DiscreteTopology X] (hs : IsLindelof s) :\n    s.Countable := by\n  have : âˆ€ x : X, ({x} : Set X) âˆˆ ğ“ x := by simp [nhds_discrete]\n  rcases hs.elim_nhds_subcover (fun x => {x}) fun x _ => this x with âŸ¨t, ht, _, hssubtâŸ©\n  rw [biUnion_of_singleton] at hssubt\n  exact ht.mono hssubt\n\n"}
{"name":"isLindelof_iff_countable","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\ninstâœ : DiscreteTopology X\nâŠ¢ Iff (IsLindelof s) s.Countable","decl":"theorem isLindelof_iff_countable [DiscreteTopology X] : IsLindelof s â†” s.Countable :=\n  âŸ¨fun h => h.countable_of_discrete, fun h => h.isLindelofâŸ©\n\n"}
{"name":"IsLindelof.union","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nhs : IsLindelof s\nht : IsLindelof t\nâŠ¢ IsLindelof (Union.union s t)","decl":"theorem IsLindelof.union (hs : IsLindelof s) (ht : IsLindelof t) : IsLindelof (s âˆª t) := by\n  rw [union_eq_iUnion]; exact isLindelof_iUnion fun b => by cases b <;> assumption\n\n"}
{"name":"IsLindelof.insert","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\na : X\nâŠ¢ IsLindelof (Insert.insert a s)","decl":"protected theorem IsLindelof.insert (hs : IsLindelof s) (a) : IsLindelof (insert a s) :=\n  isLindelof_singleton.union hs\n\n"}
{"name":"isLindelof_open_iff_eq_countable_iUnion_of_isTopologicalBasis","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nÎ¹ : Type u_1\ninstâœ : TopologicalSpace X\nb : Î¹ â†’ Set X\nhb : TopologicalSpace.IsTopologicalBasis (Set.range b)\nhb' : âˆ€ (i : Î¹), IsLindelof (b i)\nU : Set X\nâŠ¢ Iff (And (IsLindelof U) (IsOpen U)) (Exists fun s => And s.Countable (Eq U (Set.iUnion fun i => Set.iUnion fun h => b i)))","decl":"/-- If `X` has a basis consisting of compact opens, then an open set in `X` is compact open iff\nit is a finite union of some elements in the basis -/\ntheorem isLindelof_open_iff_eq_countable_iUnion_of_isTopologicalBasis (b : Î¹ â†’ Set X)\n    (hb : IsTopologicalBasis (Set.range b)) (hb' : âˆ€ i, IsLindelof (b i)) (U : Set X) :\n    IsLindelof U âˆ§ IsOpen U â†” âˆƒ s : Set Î¹, s.Countable âˆ§ U = â‹ƒ i âˆˆ s, b i := by\n  constructor\n  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n    obtain âŸ¨Y, f, rfl, hfâŸ© := hb.open_eq_iUnion hâ‚‚\n    choose f' hf' using hf\n    have : b âˆ˜ f' = f := funext hf'\n    subst this\n    obtain âŸ¨t, htâŸ© :=\n      hâ‚.elim_countable_subcover (b âˆ˜ f') (fun i => hb.isOpen (Set.mem_range_self _)) Subset.rfl\n    refine âŸ¨t.image f', Countable.image (ht.1) f', le_antisymm ?_ ?_âŸ©\n    Â· refine Set.Subset.trans ht.2 ?_\n      simp only [Set.iUnion_subset_iff]\n      intro i hi\n      rw [â† Set.iUnion_subtype (fun x : Î¹ => x âˆˆ t.image f') fun i => b i.1]\n      exact Set.subset_iUnion (fun i : t.image f' => b i) âŸ¨_, mem_image_of_mem _ hiâŸ©\n    Â· apply Set.iUnionâ‚‚_subset\n      rintro i hi\n      obtain âŸ¨j, -, rflâŸ© := (mem_image ..).mp hi\n      exact Set.subset_iUnion (b âˆ˜ f') j\n  Â· rintro âŸ¨s, hs, rflâŸ©\n    constructor\n    Â· exact hs.isLindelof_biUnion fun i _ => hb' i\n    Â· exact isOpen_biUnion fun i _ => hb.isOpen (Set.mem_range_self _)\n\n"}
{"name":"hasBasis_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ (Filter.coLindelof X).HasBasis IsLindelof HasCompl.compl","decl":"theorem hasBasis_coLindelof : (coLindelof X).HasBasis IsLindelof compl :=\n  hasBasis_biInf_principal'\n    (fun s hs t ht =>\n      âŸ¨s âˆª t, hs.union ht, compl_subset_compl.2 subset_union_left,\n        compl_subset_compl.2 subset_union_rightâŸ©)\n    âŸ¨âˆ…, isLindelof_emptyâŸ©\n\n"}
{"name":"mem_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Iff (Membership.mem (Filter.coLindelof X) s) (Exists fun t => And (IsLindelof t) (HasSubset.Subset (HasCompl.compl t) s))","decl":"theorem mem_coLindelof : s âˆˆ coLindelof X â†” âˆƒ t, IsLindelof t âˆ§ tá¶œ âŠ† s :=\n  hasBasis_coLindelof.mem_iff\n\n"}
{"name":"mem_coLindelof'","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Iff (Membership.mem (Filter.coLindelof X) s) (Exists fun t => And (IsLindelof t) (HasSubset.Subset (HasCompl.compl s) t))","decl":"theorem mem_coLindelof' : s âˆˆ coLindelof X â†” âˆƒ t, IsLindelof t âˆ§ sá¶œ âŠ† t :=\n  mem_coLindelof.trans <| exists_congr fun _ => and_congr_right fun _ => compl_subset_comm\n\n"}
{"name":"IsLindelof.compl_mem_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nâŠ¢ Membership.mem (Filter.coLindelof X) (HasCompl.compl s)","decl":"theorem _root_.IsLindelof.compl_mem_coLindelof (hs : IsLindelof s) : sá¶œ âˆˆ coLindelof X :=\n  hasBasis_coLindelof.mem_of_mem hs\n\n"}
{"name":"coLindelof_le_cofinite","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ LE.le (Filter.coLindelof X) Filter.cofinite","decl":"theorem coLindelof_le_cofinite : coLindelof X â‰¤ cofinite := fun s hs =>\n  compl_compl s â–¸ hs.isLindelof.compl_mem_coLindelof\n\n"}
{"name":"Tendsto.isLindelof_insert_range_of_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\ny : Y\nhf : Filter.Tendsto f (Filter.coLindelof X) (nhds y)\nhfc : Continuous f\nâŠ¢ IsLindelof (Insert.insert y (Set.range f))","decl":"theorem Tendsto.isLindelof_insert_range_of_coLindelof {f : X â†’ Y} {y}\n    (hf : Tendsto f (coLindelof X) (ğ“ y)) (hfc : Continuous f) :\n    IsLindelof (insert y (range f)) := by\n  intro l hne _ hle\n  by_cases hy : ClusterPt y l\n  Â· exact âŸ¨y, Or.inl rfl, hyâŸ©\n  simp only [clusterPt_iff, not_forall, â† not_disjoint_iff_nonempty_inter, not_not] at hy\n  rcases hy with âŸ¨s, hsy, t, htl, hdâŸ©\n  rcases mem_coLindelof.1 (hf hsy) with âŸ¨K, hKc, hKsâŸ©\n  have : f '' K âˆˆ l := by\n    filter_upwards [htl, le_principal_iff.1 hle] with y hyt hyf\n    rcases hyf with (rfl | âŸ¨x, rflâŸ©)\n    exacts [(hd.le_bot âŸ¨mem_of_mem_nhds hsy, hytâŸ©).elim,\n      mem_image_of_mem _ (not_not.1 fun hxK => hd.le_bot âŸ¨hKs hxK, hytâŸ©)]\n  rcases hKc.image hfc (le_principal_iff.2 this) with âŸ¨y, hy, hylâŸ©\n  exact âŸ¨y, Or.inr <| image_subset_range _ _ hy, hylâŸ©\n\n"}
{"name":"hasBasis_coclosedLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ (Filter.coclosedLindelof X).HasBasis (fun s => And (IsClosed s) (IsLindelof s)) HasCompl.compl","decl":"theorem hasBasis_coclosedLindelof :\n    (Filter.coclosedLindelof X).HasBasis (fun s => IsClosed s âˆ§ IsLindelof s) compl := by\n  simp only [Filter.coclosedLindelof, iInf_and']\n  refine hasBasis_biInf_principal' ?_ âŸ¨âˆ…, isClosed_empty, isLindelof_emptyâŸ©\n  rintro s âŸ¨hsâ‚, hsâ‚‚âŸ© t âŸ¨htâ‚, htâ‚‚âŸ©\n  exact âŸ¨s âˆª t, âŸ¨âŸ¨hsâ‚.union htâ‚, hsâ‚‚.union htâ‚‚âŸ©, compl_subset_compl.2 subset_union_left,\n    compl_subset_compl.2 subset_union_rightâŸ©âŸ©\n\n"}
{"name":"mem_coclosedLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Iff (Membership.mem (Filter.coclosedLindelof X) s) (Exists fun t => And (IsClosed t) (And (IsLindelof t) (HasSubset.Subset (HasCompl.compl t) s)))","decl":"theorem mem_coclosedLindelof : s âˆˆ coclosedLindelof X â†”\n    âˆƒ t, IsClosed t âˆ§ IsLindelof t âˆ§ tá¶œ âŠ† s := by\n  simp only [hasBasis_coclosedLindelof.mem_iff, and_assoc]\n\n"}
{"name":"mem_coclosed_Lindelof'","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Iff (Membership.mem (Filter.coclosedLindelof X) s) (Exists fun t => And (IsClosed t) (And (IsLindelof t) (HasSubset.Subset (HasCompl.compl s) t)))","decl":"theorem mem_coclosed_Lindelof' : s âˆˆ coclosedLindelof X â†”\n    âˆƒ t, IsClosed t âˆ§ IsLindelof t âˆ§ sá¶œ âŠ† t := by\n  simp only [mem_coclosedLindelof, compl_subset_comm]\n\n"}
{"name":"coLindelof_le_coclosedLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ LE.le (Filter.coLindelof X) (Filter.coclosedLindelof X)","decl":"theorem coLindelof_le_coclosedLindelof : coLindelof X â‰¤ coclosedLindelof X :=\n  iInf_mono fun _ => le_iInf fun _ => le_rfl\n\n"}
{"name":"IsLindeof.compl_mem_coclosedLindelof_of_isClosed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nhs' : IsClosed s\nâŠ¢ Membership.mem (Filter.coclosedLindelof X) (HasCompl.compl s)","decl":"theorem IsLindeof.compl_mem_coclosedLindelof_of_isClosed (hs : IsLindelof s) (hs' : IsClosed s) :\n    sá¶œ âˆˆ Filter.coclosedLindelof X :=\n  hasBasis_coclosedLindelof.mem_of_mem âŸ¨hs', hsâŸ©\n\n"}
{"name":"LindelofSpace.isLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u_2\ninstâœ : TopologicalSpace X\nself : LindelofSpace X\nâŠ¢ IsLindelof Set.univ","decl":"/-- X is a LindelÃ¶f space iff every open cover has a countable subcover. -/\nclass LindelofSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- In a LindelÃ¶f space, `Set.univ` is a LindelÃ¶f set. -/\n  isLindelof_univ : IsLindelof (univ : Set X)\n\n"}
{"name":"Subsingleton.lindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Subsingleton X\nâŠ¢ LindelofSpace X","decl":"instance (priority := 10) Subsingleton.lindelofSpace [Subsingleton X] : LindelofSpace X :=\n  âŸ¨subsingleton_univ.isLindelofâŸ©\n\n"}
{"name":"isLindelof_univ_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (IsLindelof Set.univ) (LindelofSpace X)","decl":"theorem isLindelof_univ_iff : IsLindelof (univ : Set X) â†” LindelofSpace X :=\n  âŸ¨fun h => âŸ¨hâŸ©, fun h => h.1âŸ©\n\n"}
{"name":"isLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nh : LindelofSpace X\nâŠ¢ IsLindelof Set.univ","decl":"theorem isLindelof_univ [h : LindelofSpace X] : IsLindelof (univ : Set X) :=\n  h.isLindelof_univ\n\n"}
{"name":"cluster_point_of_Lindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : LindelofSpace X\nf : Filter X\ninstâœÂ¹ : f.NeBot\ninstâœ : CountableInterFilter f\nâŠ¢ Exists fun x => ClusterPt x f","decl":"theorem cluster_point_of_Lindelof [LindelofSpace X] (f : Filter X) [NeBot f]\n    [CountableInterFilter f] : âˆƒ x, ClusterPt x f := by\n  simpa using isLindelof_univ (show f â‰¤ ğ“Ÿ univ by simp)\n\n"}
{"name":"LindelofSpace.elim_nhds_subcover","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : LindelofSpace X\nU : X â†’ Set X\nhU : âˆ€ (x : X), Membership.mem (nhds x) (U x)\nâŠ¢ Exists fun t => And t.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => U x) Set.univ)","decl":"theorem LindelofSpace.elim_nhds_subcover [LindelofSpace X] (U : X â†’ Set X) (hU : âˆ€ x, U x âˆˆ ğ“ x) :\n    âˆƒ t : Set X, t.Countable âˆ§ â‹ƒ x âˆˆ t, U x = univ := by\n  obtain âŸ¨t, tc, -, sâŸ© := IsLindelof.elim_nhds_subcover isLindelof_univ U fun x _ => hU x\n  use t, tc\n  apply top_unique s\n\n"}
{"name":"lindelofSpace_of_countable_subfamily_closed","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nh : âˆ€ {Î¹ : Type u} (t : Î¹ â†’ Set X), (âˆ€ (i : Î¹), IsClosed (t i)) â†’ Eq (Set.iInter fun i => t i) EmptyCollection.emptyCollection â†’ Exists fun u => And u.Countable (Eq (Set.iInter fun i => Set.iInter fun h => t i) EmptyCollection.emptyCollection)\nâŠ¢ LindelofSpace X","decl":"theorem lindelofSpace_of_countable_subfamily_closed\n    (h : âˆ€ {Î¹ : Type u} (t : Î¹ â†’ Set X), (âˆ€ i, IsClosed (t i)) â†’ â‹‚ i, t i = âˆ… â†’\n      âˆƒ u : Set Î¹, u.Countable âˆ§ â‹‚ i âˆˆ u, t i = âˆ…) :\n    LindelofSpace X where\n  isLindelof_univ := isLindelof_of_countable_subfamily_closed fun t => by simpa using h t\n\n"}
{"name":"IsClosed.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\ninstâœ : LindelofSpace X\nh : IsClosed s\nâŠ¢ IsLindelof s","decl":"theorem IsClosed.isLindelof [LindelofSpace X] (h : IsClosed s) : IsLindelof s :=\n  isLindelof_univ.of_isClosed_subset h (subset_univ _)\n\n"}
{"name":"IsCompact.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nâŠ¢ IsLindelof s","decl":"/-- A compact set `s` is LindelÃ¶f. -/\ntheorem IsCompact.isLindelof (hs : IsCompact s) :\n    IsLindelof s := by tauto\n\n"}
{"name":"IsSigmaCompact.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsSigmaCompact s\nâŠ¢ IsLindelof s","decl":"/-- A Ïƒ-compact set `s` is LindelÃ¶f -/\ntheorem IsSigmaCompact.isLindelof (hs : IsSigmaCompact s) :\n    IsLindelof s := by\n  rw [IsSigmaCompact] at hs\n  rcases hs with âŸ¨K, âŸ¨hc, hunivâŸ©âŸ©\n  rw [â† huniv]\n  have hl : âˆ€ n, IsLindelof (K n) := fun n â†¦ IsCompact.isLindelof (hc n)\n  exact isLindelof_iUnion hl\n\n"}
{"name":"instLindelofSpaceOfCompactSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nâŠ¢ LindelofSpace X","decl":"/-- A compact space `X` is LindelÃ¶f. -/\ninstance (priority := 100) [CompactSpace X] : LindelofSpace X :=\n  { isLindelof_univ := isCompact_univ.isLindelof}\n\n"}
{"name":"instLindelofSpaceOfSigmaCompactSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : SigmaCompactSpace X\nâŠ¢ LindelofSpace X","decl":"/-- A sigma-compact space `X` is LindelÃ¶f. -/\ninstance (priority := 100) [SigmaCompactSpace X] : LindelofSpace X :=\n  { isLindelof_univ := isSigmaCompact_univ.isLindelof}\n\n"}
{"name":"NonLindelofSpace.nonLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u_2\ninstâœ : TopologicalSpace X\nself : NonLindelofSpace X\nâŠ¢ Not (IsLindelof Set.univ)","decl":"/-- `X` is a non-LindelÃ¶f topological space if it is not a LindelÃ¶f space. -/\nclass NonLindelofSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- In a non-LindelÃ¶f space, `Set.univ` is not a LindelÃ¶f set. -/\n  nonLindelof_univ : Â¬IsLindelof (univ : Set X)\n\n"}
{"name":"nonLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : NonLindelofSpace X\nâŠ¢ Not (IsLindelof Set.univ)","decl":"lemma nonLindelof_univ (X : Type*) [TopologicalSpace X] [NonLindelofSpace X] :\n    Â¬IsLindelof (univ : Set X) :=\n  NonLindelofSpace.nonLindelof_univ\n\n"}
{"name":"IsLindelof.ne_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\ninstâœ : NonLindelofSpace X\nhs : IsLindelof s\nâŠ¢ Ne s Set.univ","decl":"theorem IsLindelof.ne_univ [NonLindelofSpace X] (hs : IsLindelof s) : s â‰  univ := fun h â†¦\n  nonLindelof_univ X (h â–¸ hs)\n\n"}
{"name":"instNeBotCoLindelofOfNonLindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : NonLindelofSpace X\nâŠ¢ (Filter.coLindelof X).NeBot","decl":"instance [NonLindelofSpace X] : NeBot (Filter.coLindelof X) := by\n  refine hasBasis_coLindelof.neBot_iff.2 fun {s} hs => ?_\n  contrapose hs\n  rw [not_nonempty_iff_eq_empty, compl_empty_iff] at hs\n  rw [hs]\n  exact nonLindelof_univ X\n\n"}
{"name":"Filter.coLindelof_eq_bot","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : LindelofSpace X\nâŠ¢ Eq (Filter.coLindelof X) Bot.bot","decl":"@[simp]\ntheorem Filter.coLindelof_eq_bot [LindelofSpace X] : Filter.coLindelof X = âŠ¥ :=\n  hasBasis_coLindelof.eq_bot_iff.mpr âŸ¨Set.univ, isLindelof_univ, Set.compl_univâŸ©\n\n"}
{"name":"instNeBotCoclosedLindelofOfNonLindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : NonLindelofSpace X\nâŠ¢ (Filter.coclosedLindelof X).NeBot","decl":"instance [NonLindelofSpace X] : NeBot (Filter.coclosedLindelof X) :=\n  neBot_of_le coLindelof_le_coclosedLindelof\n\n"}
{"name":"nonLindelofSpace_of_neBot","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nxâœ : (Filter.coLindelof X).NeBot\nâŠ¢ NonLindelofSpace X","decl":"theorem nonLindelofSpace_of_neBot (_ : NeBot (Filter.coLindelof X)) : NonLindelofSpace X :=\n  âŸ¨fun h' => (Filter.nonempty_of_mem h'.compl_mem_coLindelof).ne_empty compl_univâŸ©\n\n"}
{"name":"Filter.coLindelof_neBot_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (Filter.coLindelof X).NeBot (NonLindelofSpace X)","decl":"theorem Filter.coLindelof_neBot_iff : NeBot (Filter.coLindelof X) â†” NonLindelofSpace X :=\n  âŸ¨nonLindelofSpace_of_neBot, fun _ => inferInstanceâŸ©\n\n\n"}
{"name":"not_LindelofSpace_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Iff (Not (LindelofSpace X)) (NonLindelofSpace X)","decl":"theorem not_LindelofSpace_iff : Â¬LindelofSpace X â†” NonLindelofSpace X :=\n  âŸ¨fun hâ‚ => âŸ¨fun hâ‚‚ => hâ‚ âŸ¨hâ‚‚âŸ©âŸ©, fun âŸ¨hâ‚âŸ© âŸ¨hâ‚‚âŸ© => hâ‚ hâ‚‚âŸ©\n\n"}
{"name":"instLindelofSpaceOfCompactSpace_1","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompactSpace X\nâŠ¢ LindelofSpace X","decl":"/-- A compact space `X` is LindelÃ¶f. -/\ninstance (priority := 100) [CompactSpace X] : LindelofSpace X :=\n  { isLindelof_univ := isCompact_univ.isLindelof}\n\n"}
{"name":"countable_of_Lindelof_of_discrete","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : LindelofSpace X\ninstâœ : DiscreteTopology X\nâŠ¢ Countable X","decl":"theorem countable_of_Lindelof_of_discrete [LindelofSpace X] [DiscreteTopology X] : Countable X :=\n  countable_univ_iff.mp isLindelof_univ.countable_of_discrete\n\n"}
{"name":"countable_cover_nhds_interior","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : LindelofSpace X\nU : X â†’ Set X\nhU : âˆ€ (x : X), Membership.mem (nhds x) (U x)\nâŠ¢ Exists fun t => And t.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => interior (U x)) Set.univ)","decl":"theorem countable_cover_nhds_interior [LindelofSpace X] {U : X â†’ Set X} (hU : âˆ€ x, U x âˆˆ ğ“ x) :\n    âˆƒ t : Set X, t.Countable âˆ§ â‹ƒ x âˆˆ t, interior (U x) = univ :=\n  let âŸ¨t, htâŸ© := isLindelof_univ.elim_countable_subcover (fun x => interior (U x))\n    (fun _ => isOpen_interior) fun x _ => mem_iUnion.2 âŸ¨x, mem_interior_iff_mem_nhds.2 (hU x)âŸ©\n  âŸ¨t, âŸ¨ht.1, univ_subset_iff.1 ht.2âŸ©âŸ©\n\n"}
{"name":"countable_cover_nhds","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : LindelofSpace X\nU : X â†’ Set X\nhU : âˆ€ (x : X), Membership.mem (nhds x) (U x)\nâŠ¢ Exists fun t => And t.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => U x) Set.univ)","decl":"theorem countable_cover_nhds [LindelofSpace X] {U : X â†’ Set X} (hU : âˆ€ x, U x âˆˆ ğ“ x) :\n    âˆƒ t : Set X, t.Countable âˆ§ â‹ƒ x âˆˆ t, U x = univ :=\n  let âŸ¨t, htâŸ© := countable_cover_nhds_interior hU\n  âŸ¨t, âŸ¨ht.1, univ_subset_iff.1 <| ht.2.symm.subset.trans <|\n    iUnionâ‚‚_mono fun _ _ => interior_subsetâŸ©âŸ©\n\n"}
{"name":"Filter.comap_coLindelof_le","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Continuous f\nâŠ¢ LE.le (Filter.comap f (Filter.coLindelof Y)) (Filter.coLindelof X)","decl":"/-- The comap of the coLindelÃ¶f filter on `Y` by a continuous function `f : X â†’ Y` is less than or\nequal to the coLindelÃ¶f filter on `X`.\nThis is a reformulation of the fact that images of LindelÃ¶f sets are LindelÃ¶f. -/\ntheorem Filter.comap_coLindelof_le {f : X â†’ Y} (hf : Continuous f) :\n    (Filter.coLindelof Y).comap f â‰¤ Filter.coLindelof X := by\n  rw [(hasBasis_coLindelof.comap f).le_basis_iff hasBasis_coLindelof]\n  intro t ht\n  refine âŸ¨f '' t, ht.image hf, ?_âŸ©\n  simpa using t.subset_preimage_image f\n\n"}
{"name":"isLindelof_range","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : LindelofSpace X\nf : X â†’ Y\nhf : Continuous f\nâŠ¢ IsLindelof (Set.range f)","decl":"theorem isLindelof_range [LindelofSpace X] {f : X â†’ Y} (hf : Continuous f) :\n    IsLindelof (range f) := by rw [â† image_univ]; exact isLindelof_univ.image hf\n\n"}
{"name":"isLindelof_diagonal","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : LindelofSpace X\nâŠ¢ IsLindelof (Set.diagonal X)","decl":"theorem isLindelof_diagonal [LindelofSpace X] : IsLindelof (diagonal X) :=\n  @range_diag X â–¸ isLindelof_range (continuous_id.prod_mk continuous_id)\n\n"}
{"name":"Topology.IsInducing.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nf : X â†’ Y\nhf : Topology.IsInducing f\nâŠ¢ Iff (IsLindelof s) (IsLindelof (Set.image f s))","decl":"/-- If `f : X â†’ Y` is an inducing map, the image `f '' s` of a set `s` is LindelÃ¶f\n  if and only if `s` is compact. -/\ntheorem Topology.IsInducing.isLindelof_iff {f : X â†’ Y} (hf : IsInducing f) :\n    IsLindelof s â†” IsLindelof (f '' s) := by\n  refine âŸ¨fun hs => hs.image hf.continuous, fun hs F F_ne_bot _ F_le => ?_âŸ©\n  obtain âŸ¨_, âŸ¨x, x_in : x âˆˆ s, rflâŸ©, hx : ClusterPt (f x) (map f F)âŸ© :=\n    hs ((map_mono F_le).trans_eq map_principal)\n  exact âŸ¨x, x_in, hf.mapClusterPt_iff.1 hxâŸ©\n\n"}
{"name":"Inducing.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nf : X â†’ Y\nhf : Topology.IsInducing f\nâŠ¢ Iff (IsLindelof s) (IsLindelof (Set.image f s))","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.isLindelof_iff := IsInducing.isLindelof_iff\n\n"}
{"name":"Topology.IsEmbedding.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nf : X â†’ Y\nhf : Topology.IsEmbedding f\nâŠ¢ Iff (IsLindelof s) (IsLindelof (Set.image f s))","decl":"/-- If `f : X â†’ Y` is an embedding, the image `f '' s` of a set `s` is LindelÃ¶f\nif and only if `s` is LindelÃ¶f. -/\ntheorem Topology.IsEmbedding.isLindelof_iff {f : X â†’ Y} (hf : IsEmbedding f) :\n    IsLindelof s â†” IsLindelof (f '' s) := hf.isInducing.isLindelof_iff\n\n"}
{"name":"Embedding.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nf : X â†’ Y\nhf : Topology.IsEmbedding f\nâŠ¢ Iff (IsLindelof s) (IsLindelof (Set.image f s))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.isLindelof_iff := IsEmbedding.isLindelof_iff\n\n"}
{"name":"Topology.IsInducing.isLindelof_preimage","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsInducing f\nhf' : IsClosed (Set.range f)\nK : Set Y\nhK : IsLindelof K\nâŠ¢ IsLindelof (Set.preimage f K)","decl":"/-- The preimage of a LindelÃ¶f set under an inducing map is a LindelÃ¶f set. -/\ntheorem Topology.IsInducing.isLindelof_preimage {f : X â†’ Y} (hf : IsInducing f)\n    (hf' : IsClosed (range f)) {K : Set Y} (hK : IsLindelof K) : IsLindelof (f â»Â¹' K) := by\n  replace hK := hK.inter_right hf'\n  rwa [hf.isLindelof_iff, image_preimage_eq_inter_range]\n\n"}
{"name":"Inducing.isLindelof_preimage","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsInducing f\nhf' : IsClosed (Set.range f)\nK : Set Y\nhK : IsLindelof K\nâŠ¢ IsLindelof (Set.preimage f K)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isLindelof_preimage := IsInducing.isLindelof_preimage\n\n"}
{"name":"Topology.IsClosedEmbedding.isLindelof_preimage","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nK : Set Y\nhK : IsLindelof K\nâŠ¢ IsLindelof (Set.preimage f K)","decl":"/-- The preimage of a LindelÃ¶f set under a closed embedding is a LindelÃ¶f set. -/\ntheorem Topology.IsClosedEmbedding.isLindelof_preimage {f : X â†’ Y} (hf : IsClosedEmbedding f)\n    {K : Set Y} (hK : IsLindelof K) : IsLindelof (f â»Â¹' K) :=\n  hf.isInducing.isLindelof_preimage (hf.isClosed_range) hK\n\n"}
{"name":"ClosedEmbedding.isLindelof_preimage","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nK : Set Y\nhK : IsLindelof K\nâŠ¢ IsLindelof (Set.preimage f K)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.isLindelof_preimage := IsClosedEmbedding.isLindelof_preimage\n\n"}
{"name":"Topology.IsClosedEmbedding.tendsto_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nâŠ¢ Filter.Tendsto f (Filter.coLindelof X) (Filter.coLindelof Y)","decl":"/-- A closed embedding is proper, ie, inverse images of LindelÃ¶f sets are contained in LindelÃ¶f.\nMoreover, the preimage of a LindelÃ¶f set is LindelÃ¶f, see\n`Topology.IsClosedEmbedding.isLindelof_preimage`. -/\ntheorem Topology.IsClosedEmbedding.tendsto_coLindelof {f : X â†’ Y} (hf : IsClosedEmbedding f) :\n    Tendsto f (Filter.coLindelof X) (Filter.coLindelof Y) :=\n  hasBasis_coLindelof.tendsto_right_iff.mpr fun _K hK =>\n    (hf.isLindelof_preimage hK).compl_mem_coLindelof\n\n"}
{"name":"ClosedEmbedding.tendsto_coLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nâŠ¢ Filter.Tendsto f (Filter.coLindelof X) (Filter.coLindelof Y)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.tendsto_coLindelof := IsClosedEmbedding.tendsto_coLindelof\n\n"}
{"name":"Subtype.isLindelof_iff","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\ns : Set (Subtype fun x => p x)\nâŠ¢ Iff (IsLindelof s) (IsLindelof (Set.image Subtype.val s))","decl":"/-- Sets of subtype are LindelÃ¶f iff the image under a coercion is. -/\ntheorem Subtype.isLindelof_iff {p : X â†’ Prop} {s : Set { x // p x }} :\n    IsLindelof s â†” IsLindelof ((â†‘) '' s : Set X) :=\n  IsEmbedding.subtypeVal.isLindelof_iff\n\n"}
{"name":"isLindelof_iff_isLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Iff (IsLindelof s) (IsLindelof Set.univ)","decl":"theorem isLindelof_iff_isLindelof_univ : IsLindelof s â†” IsLindelof (univ : Set s) := by\n  rw [Subtype.isLindelof_iff, image_univ, Subtype.range_coe]\n\n"}
{"name":"isLindelof_iff_LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nâŠ¢ Iff (IsLindelof s) (LindelofSpace â†‘s)","decl":"theorem isLindelof_iff_LindelofSpace : IsLindelof s â†” LindelofSpace s :=\n  isLindelof_iff_isLindelof_univ.trans isLindelof_univ_iff\n\n"}
{"name":"IsLindelof.of_coe","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Set X\ninstâœ : LindelofSpace â†‘s\nâŠ¢ IsLindelof s","decl":"lemma IsLindelof.of_coe [LindelofSpace s] : IsLindelof s := isLindelof_iff_LindelofSpace.mpr â€¹_â€º\n\n"}
{"name":"IsLindelof.countable","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nhs' : DiscreteTopology â†‘s\nâŠ¢ s.Countable","decl":"theorem IsLindelof.countable (hs : IsLindelof s) (hs' : DiscreteTopology s) : s.Countable :=\n  countable_coe_iff.mp\n  (@countable_of_Lindelof_of_discrete _ _ (isLindelof_iff_LindelofSpace.mp hs) hs')\n\n"}
{"name":"Topology.IsClosedEmbedding.nonLindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : NonLindelofSpace X\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nâŠ¢ NonLindelofSpace Y","decl":"protected theorem Topology.IsClosedEmbedding.nonLindelofSpace [NonLindelofSpace X] {f : X â†’ Y}\n    (hf : IsClosedEmbedding f) : NonLindelofSpace Y :=\n  nonLindelofSpace_of_neBot hf.tendsto_coLindelof.neBot\n\n"}
{"name":"ClosedEmbedding.nonLindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : NonLindelofSpace X\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nâŠ¢ NonLindelofSpace Y","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.nonLindelofSpace := IsClosedEmbedding.nonLindelofSpace\n\n"}
{"name":"Topology.IsClosedEmbedding.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nh : LindelofSpace Y\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nâŠ¢ LindelofSpace X","decl":"protected theorem Topology.IsClosedEmbedding.LindelofSpace [h : LindelofSpace Y] {f : X â†’ Y}\n    (hf : IsClosedEmbedding f) : LindelofSpace X :=\n  âŸ¨by rw [hf.isInducing.isLindelof_iff, image_univ]; exact hf.isClosed_range.isLindelofâŸ©\n\n"}
{"name":"ClosedEmbedding.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nh : LindelofSpace Y\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nâŠ¢ LindelofSpace X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.LindelofSpace := IsClosedEmbedding.LindelofSpace\n\n"}
{"name":"Countable.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Countable X\nâŠ¢ LindelofSpace X","decl":"/-- Countable topological spaces are Lindelof. -/\ninstance (priority := 100) Countable.LindelofSpace [Countable X] : LindelofSpace X where\n  isLindelof_univ := countable_univ.isLindelof\n\n"}
{"name":"instLindelofSpaceSum","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : LindelofSpace X\ninstâœ : LindelofSpace Y\nâŠ¢ LindelofSpace (Sum X Y)","decl":"/-- The disjoint union of two LindelÃ¶f spaces is LindelÃ¶f. -/\ninstance [LindelofSpace X] [LindelofSpace Y] : LindelofSpace (X âŠ• Y) where\n  isLindelof_univ := by\n    rw [â† range_inl_union_range_inr]\n    exact (isLindelof_range continuous_inl).union (isLindelof_range continuous_inr)\n\n"}
{"name":"instLindelofSpaceSigmaOfCountable","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"Î¹ : Type u_1\nX : Î¹ â†’ Type u_2\ninstâœÂ² : Countable Î¹\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (X i)\ninstâœ : âˆ€ (i : Î¹), LindelofSpace (X i)\nâŠ¢ LindelofSpace (Sigma fun i => X i)","decl":"instance {X : Î¹ â†’ Type*} [Countable Î¹] [âˆ€ i, TopologicalSpace (X i)] [âˆ€ i, LindelofSpace (X i)] :\n    LindelofSpace (Î£i, X i) where\n  isLindelof_univ := by\n    rw [Sigma.univ]\n    exact isLindelof_iUnion fun i => isLindelof_range continuous_sigmaMk\n\n"}
{"name":"Quot.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nr : X â†’ X â†’ Prop\ninstâœ : LindelofSpace X\nâŠ¢ LindelofSpace (Quot r)","decl":"instance Quot.LindelofSpace {r : X â†’ X â†’ Prop} [LindelofSpace X] : LindelofSpace (Quot r) where\n  isLindelof_univ := by\n    rw [â† range_quot_mk]\n    exact isLindelof_range continuous_quot_mk\n\n"}
{"name":"Quotient.LindelofSpace","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ns : Setoid X\ninstâœ : LindelofSpace X\nâŠ¢ LindelofSpace (Quotient s)","decl":"instance Quotient.LindelofSpace {s : Setoid X} [LindelofSpace X] : LindelofSpace (Quotient s) :=\n  Quot.LindelofSpace\n\n"}
{"name":"LindelofSpace.of_continuous_surjective","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\nY : Type v\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\nf : X â†’ Y\ninstâœ : LindelofSpace X\nhf : Continuous f\nhsur : Function.Surjective f\nâŠ¢ LindelofSpace Y","decl":"/-- A continuous image of a LindelÃ¶f set is a LindelÃ¶f set within the codomain. -/\ntheorem LindelofSpace.of_continuous_surjective {f : X â†’ Y} [LindelofSpace X] (hf : Continuous f)\n    (hsur : Function.Surjective f) : LindelofSpace Y where\n  isLindelof_univ := by\n    rw [â† Set.image_univ_of_surjective hsur]\n    exact IsLindelof.image (isLindelof_univ_iff.mpr â€¹_â€º) hf\n\n"}
{"name":"HereditarilyLindelofSpace.isHereditarilyLindelof_univ","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u_2\ninstâœ : TopologicalSpace X\nself : HereditarilyLindelofSpace X\nâŠ¢ IsHereditarilyLindelof Set.univ","decl":"/-- Type class for Hereditarily LindelÃ¶f spaces. -/\nclass HereditarilyLindelofSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- In a Hereditarily LindelÃ¶f space, `Set.univ` is a Hereditarily LindelÃ¶f set. -/\n  isHereditarilyLindelof_univ : IsHereditarilyLindelof (univ : Set X)\n\n"}
{"name":"IsHereditarilyLindelof.isLindelof_subset","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nhs : IsHereditarilyLindelof s\nht : HasSubset.Subset t s\nâŠ¢ IsLindelof t","decl":"lemma IsHereditarilyLindelof.isLindelof_subset (hs : IsHereditarilyLindelof s) (ht : t âŠ† s) :\n    IsLindelof t := hs t ht\n\n"}
{"name":"IsHereditarilyLindelof.isLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsHereditarilyLindelof s\nâŠ¢ IsLindelof s","decl":"lemma IsHereditarilyLindelof.isLindelof (hs : IsHereditarilyLindelof s) :\n    IsLindelof s := hs.isLindelof_subset Subset.rfl\n\n"}
{"name":"HereditarilyLindelof.to_Lindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : HereditarilyLindelofSpace X\nâŠ¢ LindelofSpace X","decl":"instance (priority := 100) HereditarilyLindelof.to_Lindelof [HereditarilyLindelofSpace X] :\n    LindelofSpace X where\n  isLindelof_univ := HereditarilyLindelofSpace.isHereditarilyLindelof_univ.isLindelof\n\n"}
{"name":"HereditarilyLindelof_LindelofSets","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : HereditarilyLindelofSpace X\ns : Set X\nâŠ¢ IsLindelof s","decl":"theorem HereditarilyLindelof_LindelofSets [HereditarilyLindelofSpace X] (s : Set X) :\n    IsLindelof s := by\n  apply HereditarilyLindelofSpace.isHereditarilyLindelof_univ\n  exact subset_univ s\n\n"}
{"name":"SecondCountableTopology.toHereditarilyLindelof","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : SecondCountableTopology X\nâŠ¢ HereditarilyLindelofSpace X","decl":"instance (priority := 100) SecondCountableTopology.toHereditarilyLindelof\n    [SecondCountableTopology X] : HereditarilyLindelofSpace X where\n  isHereditarilyLindelof_univ t _ _ := by\n    apply isLindelof_iff_countable_subcover.mpr\n    intro Î¹ U hÎ¹ hcover\n    have := @isOpen_iUnion_countable X _ _ Î¹ U hÎ¹\n    rcases this with âŸ¨t, âŸ¨htc, htuâŸ©âŸ©\n    use t, htc\n    exact subset_of_subset_of_eq hcover (id htu.symm)\n\n"}
{"name":"eq_open_union_countable","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : HereditarilyLindelofSpace X\nÎ¹ : Type u\nU : Î¹ â†’ Set X\nh : âˆ€ (i : Î¹), IsOpen (U i)\nâŠ¢ Exists fun t => And t.Countable (Eq (Set.iUnion fun i => Set.iUnion fun h => U i) (Set.iUnion fun i => U i))","decl":"lemma eq_open_union_countable [HereditarilyLindelofSpace X] {Î¹ : Type u} (U : Î¹ â†’ Set X)\n    (h : âˆ€ i, IsOpen (U i)) : âˆƒ t : Set Î¹, t.Countable âˆ§ â‹ƒ iâˆˆt, U i = â‹ƒ i, U i := by\n  have : IsLindelof (â‹ƒ i, U i) := HereditarilyLindelof_LindelofSets (â‹ƒ i, U i)\n  rcases isLindelof_iff_countable_subcover.mp this U h (Eq.subset rfl) with âŸ¨t, âŸ¨htc, htuâŸ©âŸ©\n  use t, htc\n  apply eq_of_subset_of_subset (iUnionâ‚‚_subset_iUnion (fun i â†¦ i âˆˆ t) fun i â†¦ U i) htu\n\n"}
{"name":"HereditarilyLindelof.lindelofSpace_subtype","module":"Mathlib.Topology.Compactness.Lindelof","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : HereditarilyLindelofSpace X\np : X â†’ Prop\nâŠ¢ LindelofSpace (Subtype fun x => p x)","decl":"instance HereditarilyLindelof.lindelofSpace_subtype [HereditarilyLindelofSpace X] (p : X â†’ Prop) :\n    LindelofSpace {x // p x} := by\n  apply isLindelof_iff_LindelofSpace.mp\n  exact HereditarilyLindelof_LindelofSets fun x â†¦ p x\n\n"}
