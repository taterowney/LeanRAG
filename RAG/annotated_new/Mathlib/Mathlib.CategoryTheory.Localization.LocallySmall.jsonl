{"name":"CategoryTheory.MorphismProperty.hasLocalizationOfLocallySmall'_def","module":"Mathlib.CategoryTheory.Localization.LocallySmall","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\nW : CategoryTheory.MorphismProperty C\nD : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} D\ninst✝¹ : CategoryTheory.LocallySmall.{u_5, u_4, u_3} D\nL : CategoryTheory.Functor C D\ninst✝ : L.IsLocalization W\n⊢ Eq (W.hasLocalizationOfLocallySmall' L)\n    (letFun ⋯ fun this =>\n      let L' := { obj := fun X => X, map := fun {X Y} f => L.map f, map_id := ⋯, map_comp := ⋯ };\n      letFun ⋯ fun this_1 =>\n        letFun ⋯ fun this_2 =>\n          letFun ⋯ fun this_3 =>\n            let e := (CategoryTheory.inducedFunctor L.obj).asEquivalence;\n            let e' := (L'.associator e.functor e.inverse).trans ((CategoryTheory.isoWhiskerLeft L' e.unitIso.symm).trans L'.rightUnitor);\n            letFun ⋯ fun this_4 => W.hasLocalizationOfLocallySmall L')","decl":"/-- If `L : C ⥤ D` is a localization functor for a class of morphisms\n`W : MorphismProperty C`, and `D` is locally `w`-small, we may obtain\na `HasLocalization.{w} W` instance. This should be used only in the\nunlikely situation where the types of objects of `C` and `D` are in\ndifferent universes. Otherwise, use `hasLocalizationOfLocallySmall`. -/\nnoncomputable irreducible_def hasLocalizationOfLocallySmall'\n    {D : Type u₂} [Category.{v₂} D] [LocallySmall.{w} D]\n    (L : C ⥤ D) [L.IsLocalization W] :\n    HasLocalization.{w} W := by\n  have : LocallySmall.{w} (InducedCategory _ L.obj) :=\n    ⟨fun X Y ↦ inferInstanceAs (Small.{w} (L.obj X ⟶ L.obj Y))⟩\n  let L' : C ⥤ (InducedCategory _ L.obj) :=\n    { obj X := X\n      map f := L.map f }\n  have := Localization.essSurj L W\n  have : (inducedFunctor L.obj).EssSurj := ⟨fun Y ↦ ⟨_, ⟨L.objObjPreimageIso Y⟩⟩⟩\n  have : (inducedFunctor L.obj).IsEquivalence := { }\n  let e := (inducedFunctor L.obj).asEquivalence\n  let e' : (L' ⋙ e.functor) ⋙ e.inverse ≅ L' :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft L' e.unitIso.symm ≪≫ L'.rightUnitor\n  have : L'.IsLocalization W :=\n    Functor.IsLocalization.of_iso W (L₁ := L ⋙ e.inverse) e'\n  exact hasLocalizationOfLocallySmall.{w} W L'\n\n"}
{"name":"CategoryTheory.MorphismProperty.locallySmall_of_hasLocalization","module":"Mathlib.CategoryTheory.Localization.LocallySmall","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLocalization\n⊢ CategoryTheory.LocallySmall.{w, v₂, u₂} D","decl":"/-- If a class of morphisms `W : MorphismProperty C` satisfies `HasLocalization.{w} W`,\nthen any localized category for `W` (i.e. any target of a localization functor\n`L : C ⥤ D` for `W`) is locally `w`-small. -/\nlemma locallySmall_of_hasLocalization {D : Type u₂} [Category.{v₂} D]\n    (L : C ⥤ D) [L.IsLocalization W] [HasLocalization.{w} W] :\n    LocallySmall.{w} D where\n  hom_small _ _ := small_of_injective (fun _ _ h ↦\n    (Localization.uniq L W.Q' W).functor.map_injective h)\n\n"}
