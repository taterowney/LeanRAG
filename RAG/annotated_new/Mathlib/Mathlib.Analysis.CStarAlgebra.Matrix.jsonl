{"name":"entry_norm_bound_of_unitary","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nn : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nU : Matrix n n ğ•œ\nhU : Membership.mem (Matrix.unitaryGroup n ğ•œ) U\ni j : n\nâŠ¢ LE.le (Norm.norm (U i j)) 1","decl":"theorem entry_norm_bound_of_unitary {U : Matrix n n ğ•œ} (hU : U âˆˆ Matrix.unitaryGroup n ğ•œ)\n    (i j : n) : â€–U i jâ€– â‰¤ 1 := by\n  -- The norm squared of an entry is at most the L2 norm of its row.\n  have norm_sum : â€–U i jâ€– ^ 2 â‰¤ âˆ‘ x, â€–U i xâ€– ^ 2 := by\n    apply Multiset.single_le_sum\n    Â· intro x h_x\n      rw [Multiset.mem_map] at h_x\n      cases' h_x with a h_a\n      rw [â† h_a.2]\n      apply sq_nonneg\n    Â· rw [Multiset.mem_map]\n      use j\n      simp only [eq_self_iff_true, Finset.mem_univ_val, and_self_iff, sq_eq_sqâ‚€]\n  -- The L2 norm of a row is a diagonal entry of U * Uá´´\n  have diag_eq_norm_sum : (U * Uá´´) i i = (âˆ‘ x : n, â€–U i xâ€– ^ 2 : â„) := by\n    simp only [Matrix.mul_apply, Matrix.conjTranspose_apply, â† starRingEnd_apply, RCLike.mul_conj,\n      RCLike.normSq_eq_def', RCLike.ofReal_pow]; norm_cast\n  -- The L2 norm of a row is a diagonal entry of U * Uá´´, real part\n  have re_diag_eq_norm_sum : RCLike.re ((U * Uá´´) i i) = âˆ‘ x : n, â€–U i xâ€– ^ 2 := by\n    rw [RCLike.ext_iff] at diag_eq_norm_sum\n    rw [diag_eq_norm_sum.1]\n    norm_cast\n  -- Since U is unitary, the diagonal entries of U * Uá´´ are all 1\n  have mul_eq_one : U * Uá´´ = 1 := unitary.mul_star_self_of_mem hU\n  have diag_eq_one : RCLike.re ((U * Uá´´) i i) = 1 := by\n    simp only [mul_eq_one, eq_self_iff_true, Matrix.one_apply_eq, RCLike.one_re]\n  -- Putting it all together\n  rw [â† sq_le_one_iffâ‚€ (norm_nonneg (U i j)), â† diag_eq_one, re_diag_eq_norm_sum]\n  exact norm_sum\n\n"}
{"name":"entrywise_sup_norm_bound_of_unitary","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nn : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nU : Matrix n n ğ•œ\nhU : Membership.mem (Matrix.unitaryGroup n ğ•œ) U\nâŠ¢ LE.le (Norm.norm U) 1","decl":"/-- The entrywise sup norm of a unitary matrix is at most 1. -/\ntheorem entrywise_sup_norm_bound_of_unitary {U : Matrix n n ğ•œ} (hU : U âˆˆ Matrix.unitaryGroup n ğ•œ) :\n    â€–Uâ€– â‰¤ 1 := by\n  conv => -- Porting note: was `simp_rw [pi_norm_le_iff_of_nonneg zero_le_one]`\n    rw [pi_norm_le_iff_of_nonneg zero_le_one]\n    intro\n    rw [pi_norm_le_iff_of_nonneg zero_le_one]\n  intros\n  exact entry_norm_bound_of_unitary hU _ _\n\n"}
{"name":"Matrix.coe_toEuclideanCLM_eq_toEuclideanLin","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nn : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nâŠ¢ Eq (â†‘(Matrix.toEuclideanCLM A)) (Matrix.toEuclideanLin A)","decl":"lemma coe_toEuclideanCLM_eq_toEuclideanLin (A : Matrix n n ğ•œ) :\n    (toEuclideanCLM (n := n) (ğ•œ := ğ•œ) A : _ â†’â‚—[ğ•œ] _) = toEuclideanLin A :=\n  rfl\n\n"}
{"name":"Matrix.toEuclideanCLM_piLp_equiv_symm","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nn : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nx : n â†’ ğ•œ\nâŠ¢ Eq ((Matrix.toEuclideanCLM A) ((WithLp.equiv 2 ((i : n) â†’ (fun x => ğ•œ) i)).symm x)) ((WithLp.equiv 2 (n â†’ ğ•œ)).symm ((Matrix.toLin' A) x))","decl":"@[simp]\nlemma toEuclideanCLM_piLp_equiv_symm (A : Matrix n n ğ•œ) (x : n â†’ ğ•œ) :\n    toEuclideanCLM (n := n) (ğ•œ := ğ•œ) A ((WithLp.equiv _ _).symm x) =\n      (WithLp.equiv _ _).symm (toLin' A x) :=\n  rfl\n\n"}
{"name":"Matrix.piLp_equiv_toEuclideanCLM","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nn : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nx : EuclideanSpace ğ•œ n\nâŠ¢ Eq ((WithLp.equiv 2 ((i : n) â†’ (fun x => ğ•œ) i)) ((Matrix.toEuclideanCLM A) x)) ((Matrix.toLin' A) ((WithLp.equiv 2 (n â†’ ğ•œ)) x))","decl":"@[simp]\nlemma piLp_equiv_toEuclideanCLM (A : Matrix n n ğ•œ) (x : EuclideanSpace ğ•œ n) :\n    WithLp.equiv _ _ (toEuclideanCLM (n := n) (ğ•œ := ğ•œ) A x) =\n      toLin' A (WithLp.equiv _ _ x) :=\n  rfl\n\n"}
{"name":"Matrix.l2_opNorm_def","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : Fintype m\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m n ğ•œ\nâŠ¢ Eq (Norm.norm A) (Norm.norm ((Matrix.toEuclideanLin.trans LinearMap.toContinuousLinearMap) A))","decl":"lemma l2_opNorm_def (A : Matrix m n ğ•œ) :\n    â€–Aâ€– = â€–(toEuclideanLin (ğ•œ := ğ•œ) (m := m) (n := n)).trans toContinuousLinearMap Aâ€– := rfl\n\n"}
{"name":"Matrix.l2_opNNNorm_def","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : Fintype m\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m n ğ•œ\nâŠ¢ Eq (NNNorm.nnnorm A) (NNNorm.nnnorm ((Matrix.toEuclideanLin.trans LinearMap.toContinuousLinearMap) A))","decl":"lemma l2_opNNNorm_def (A : Matrix m n ğ•œ) :\n    â€–Aâ€–â‚Š = â€–(toEuclideanLin (ğ•œ := ğ•œ) (m := m) (n := n)).trans toContinuousLinearMap Aâ€–â‚Š := rfl\n\n"}
{"name":"Matrix.l2_opNorm_conjTranspose","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : Fintype m\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\ninstâœ : DecidableEq m\nA : Matrix m n ğ•œ\nâŠ¢ Eq (Norm.norm A.conjTranspose) (Norm.norm A)","decl":"lemma l2_opNorm_conjTranspose [DecidableEq m] (A : Matrix m n ğ•œ) : â€–Aá´´â€– = â€–Aâ€– := by\n  rw [l2_opNorm_def, toEuclideanLin_eq_toLin_orthonormal, LinearEquiv.trans_apply,\n    toLin_conjTranspose, adjoint_toContinuousLinearMap]\n  exact ContinuousLinearMap.adjoint.norm_map _\n\n"}
{"name":"Matrix.l2_opNNNorm_conjTranspose","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : Fintype m\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq n\ninstâœ : DecidableEq m\nA : Matrix m n ğ•œ\nâŠ¢ Eq (NNNorm.nnnorm A.conjTranspose) (NNNorm.nnnorm A)","decl":"lemma l2_opNNNorm_conjTranspose [DecidableEq m] (A : Matrix m n ğ•œ) : â€–Aá´´â€–â‚Š = â€–Aâ€–â‚Š :=\n  Subtype.ext <| l2_opNorm_conjTranspose _\n\n"}
{"name":"Matrix.l2_opNorm_conjTranspose_mul_self","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : Fintype m\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m n ğ•œ\nâŠ¢ Eq (Norm.norm (HMul.hMul A.conjTranspose A)) (HMul.hMul (Norm.norm A) (Norm.norm A))","decl":"lemma l2_opNorm_conjTranspose_mul_self (A : Matrix m n ğ•œ) : â€–Aá´´ * Aâ€– = â€–Aâ€– * â€–Aâ€– := by\n  classical\n  rw [l2_opNorm_def, toEuclideanLin_eq_toLin_orthonormal, LinearEquiv.trans_apply,\n    Matrix.toLin_mul (vâ‚‚ := (EuclideanSpace.basisFun m ğ•œ).toBasis), toLin_conjTranspose]\n  exact ContinuousLinearMap.norm_adjoint_comp_self _\n\n"}
{"name":"Matrix.l2_opNNNorm_conjTranspose_mul_self","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : Fintype m\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m n ğ•œ\nâŠ¢ Eq (NNNorm.nnnorm (HMul.hMul A.conjTranspose A)) (HMul.hMul (NNNorm.nnnorm A) (NNNorm.nnnorm A))","decl":"lemma l2_opNNNorm_conjTranspose_mul_self (A : Matrix m n ğ•œ) : â€–Aá´´ * Aâ€–â‚Š = â€–Aâ€–â‚Š * â€–Aâ€–â‚Š :=\n  Subtype.ext <| l2_opNorm_conjTranspose_mul_self _\n\n-- note: with only a type ascription in the left-hand side, Lean picks the wrong norm.\n"}
{"name":"Matrix.l2_opNorm_mulVec","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : Fintype m\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m n ğ•œ\nx : EuclideanSpace ğ•œ n\nâŠ¢ LE.le (Norm.norm ((EuclideanSpace.equiv m ğ•œ).symm (A.mulVec x))) (HMul.hMul (Norm.norm A) (Norm.norm x))","decl":"lemma l2_opNorm_mulVec (A : Matrix m n ğ•œ) (x : EuclideanSpace ğ•œ n) :\n    â€–(EuclideanSpace.equiv m ğ•œ).symm <| A *áµ¥ xâ€– â‰¤ â€–Aâ€– * â€–xâ€– :=\n  toEuclideanLin (n := n) (m := m) (ğ•œ := ğ•œ) |>.trans toContinuousLinearMap A |>.le_opNorm x\n\n"}
{"name":"Matrix.l2_opNNNorm_mulVec","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : Fintype m\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix m n ğ•œ\nx : EuclideanSpace ğ•œ n\nâŠ¢ LE.le (NNNorm.nnnorm ((EuclideanSpace.equiv m ğ•œ).symm (A.mulVec x))) (HMul.hMul (NNNorm.nnnorm A) (NNNorm.nnnorm x))","decl":"lemma l2_opNNNorm_mulVec (A : Matrix m n ğ•œ) (x : EuclideanSpace ğ•œ n) :\n    â€–(EuclideanSpace.equiv m ğ•œ).symm <| A *áµ¥ xâ€–â‚Š â‰¤ â€–Aâ€–â‚Š * â€–xâ€–â‚Š :=\n  A.l2_opNorm_mulVec x\n\n"}
{"name":"Matrix.l2_opNorm_mul","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\nl : Type u_4\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : Fintype l\ninstâœ : DecidableEq l\nA : Matrix m n ğ•œ\nB : Matrix n l ğ•œ\nâŠ¢ LE.le (Norm.norm (HMul.hMul A B)) (HMul.hMul (Norm.norm A) (Norm.norm B))","decl":"lemma l2_opNorm_mul (A : Matrix m n ğ•œ) (B : Matrix n l ğ•œ) :\n    â€–A * Bâ€– â‰¤ â€–Aâ€– * â€–Bâ€– := by\n  simp only [l2_opNorm_def]\n  have := (toEuclideanLin (n := n) (m := m) (ğ•œ := ğ•œ) â‰ªâ‰«â‚— toContinuousLinearMap) A\n    |>.opNorm_comp_le <| (toEuclideanLin (n := l) (m := n) (ğ•œ := ğ•œ) â‰ªâ‰«â‚— toContinuousLinearMap) B\n  convert this\n  ext1 x\n  exact congr($(Matrix.toLin'_mul A B) x)\n\n"}
{"name":"Matrix.l2_opNNNorm_mul","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nm : Type u_2\nn : Type u_3\nl : Type u_4\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : Fintype m\ninstâœÂ³ : Fintype n\ninstâœÂ² : DecidableEq n\ninstâœÂ¹ : Fintype l\ninstâœ : DecidableEq l\nA : Matrix m n ğ•œ\nB : Matrix n l ğ•œ\nâŠ¢ LE.le (NNNorm.nnnorm (HMul.hMul A B)) (HMul.hMul (NNNorm.nnnorm A) (NNNorm.nnnorm B))","decl":"lemma l2_opNNNorm_mul (A : Matrix m n ğ•œ) (B : Matrix n l ğ•œ) : â€–A * Bâ€–â‚Š â‰¤ â€–Aâ€–â‚Š * â€–Bâ€–â‚Š :=\n  l2_opNorm_mul A B\n\n"}
{"name":"Matrix.cstar_norm_def","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nn : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nâŠ¢ Eq (Norm.norm A) (Norm.norm (Matrix.toEuclideanCLM A))","decl":"/-- This is the same as `Matrix.l2_opNorm_def`, but with a more bundled RHS for square matrices. -/\nlemma cstar_norm_def (A : Matrix n n ğ•œ) : â€–Aâ€– = â€–toEuclideanCLM (n := n) (ğ•œ := ğ•œ) Aâ€– := rfl\n\n"}
{"name":"Matrix.cstar_nnnorm_def","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nn : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nA : Matrix n n ğ•œ\nâŠ¢ Eq (NNNorm.nnnorm A) (NNNorm.nnnorm (Matrix.toEuclideanCLM A))","decl":"/-- This is the same as `Matrix.l2_opNNNorm_def`, but with a more bundled RHS for square\nmatrices. -/\nlemma cstar_nnnorm_def (A : Matrix n n ğ•œ) : â€–Aâ€–â‚Š = â€–toEuclideanCLM (n := n) (ğ•œ := ğ•œ) Aâ€–â‚Š := rfl\n\n"}
{"name":"Matrix.instCStarRing","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"ğ•œ : Type u_1\nn : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nâŠ¢ CStarRing (Matrix n n ğ•œ)","decl":"/-- The operator norm on `Matrix n n ğ•œ` given by the identification with (continuous) linear\nendmorphisms of `EuclideanSpace ğ•œ n` makes it into a `L2OpRing`. -/\nlemma instCStarRing : CStarRing (Matrix n n ğ•œ) where\n  norm_mul_self_le M := le_of_eq <| Eq.symm <| l2_opNorm_conjTranspose_mul_self M\n\n"}
