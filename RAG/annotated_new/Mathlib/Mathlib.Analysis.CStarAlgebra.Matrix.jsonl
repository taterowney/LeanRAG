{"name":"entry_norm_bound_of_unitary","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nn : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nU : Matrix n n 𝕜\nhU : Membership.mem (Matrix.unitaryGroup n 𝕜) U\ni j : n\n⊢ LE.le (Norm.norm (U i j)) 1","decl":"theorem entry_norm_bound_of_unitary {U : Matrix n n 𝕜} (hU : U ∈ Matrix.unitaryGroup n 𝕜)\n    (i j : n) : ‖U i j‖ ≤ 1 := by\n  -- The norm squared of an entry is at most the L2 norm of its row.\n  have norm_sum : ‖U i j‖ ^ 2 ≤ ∑ x, ‖U i x‖ ^ 2 := by\n    apply Multiset.single_le_sum\n    · intro x h_x\n      rw [Multiset.mem_map] at h_x\n      cases' h_x with a h_a\n      rw [← h_a.2]\n      apply sq_nonneg\n    · rw [Multiset.mem_map]\n      use j\n      simp only [eq_self_iff_true, Finset.mem_univ_val, and_self_iff, sq_eq_sq₀]\n  -- The L2 norm of a row is a diagonal entry of U * Uᴴ\n  have diag_eq_norm_sum : (U * Uᴴ) i i = (∑ x : n, ‖U i x‖ ^ 2 : ℝ) := by\n    simp only [Matrix.mul_apply, Matrix.conjTranspose_apply, ← starRingEnd_apply, RCLike.mul_conj,\n      RCLike.normSq_eq_def', RCLike.ofReal_pow]; norm_cast\n  -- The L2 norm of a row is a diagonal entry of U * Uᴴ, real part\n  have re_diag_eq_norm_sum : RCLike.re ((U * Uᴴ) i i) = ∑ x : n, ‖U i x‖ ^ 2 := by\n    rw [RCLike.ext_iff] at diag_eq_norm_sum\n    rw [diag_eq_norm_sum.1]\n    norm_cast\n  -- Since U is unitary, the diagonal entries of U * Uᴴ are all 1\n  have mul_eq_one : U * Uᴴ = 1 := unitary.mul_star_self_of_mem hU\n  have diag_eq_one : RCLike.re ((U * Uᴴ) i i) = 1 := by\n    simp only [mul_eq_one, eq_self_iff_true, Matrix.one_apply_eq, RCLike.one_re]\n  -- Putting it all together\n  rw [← sq_le_one_iff₀ (norm_nonneg (U i j)), ← diag_eq_one, re_diag_eq_norm_sum]\n  exact norm_sum\n\n"}
{"name":"entrywise_sup_norm_bound_of_unitary","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nn : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nU : Matrix n n 𝕜\nhU : Membership.mem (Matrix.unitaryGroup n 𝕜) U\n⊢ LE.le (Norm.norm U) 1","decl":"/-- The entrywise sup norm of a unitary matrix is at most 1. -/\ntheorem entrywise_sup_norm_bound_of_unitary {U : Matrix n n 𝕜} (hU : U ∈ Matrix.unitaryGroup n 𝕜) :\n    ‖U‖ ≤ 1 := by\n  conv => -- Porting note: was `simp_rw [pi_norm_le_iff_of_nonneg zero_le_one]`\n    rw [pi_norm_le_iff_of_nonneg zero_le_one]\n    intro\n    rw [pi_norm_le_iff_of_nonneg zero_le_one]\n  intros\n  exact entry_norm_bound_of_unitary hU _ _\n\n"}
{"name":"Matrix.coe_toEuclideanCLM_eq_toEuclideanLin","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nn : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\n⊢ Eq (↑(Matrix.toEuclideanCLM A)) (Matrix.toEuclideanLin A)","decl":"lemma coe_toEuclideanCLM_eq_toEuclideanLin (A : Matrix n n 𝕜) :\n    (toEuclideanCLM (n := n) (𝕜 := 𝕜) A : _ →ₗ[𝕜] _) = toEuclideanLin A :=\n  rfl\n\n"}
{"name":"Matrix.toEuclideanCLM_piLp_equiv_symm","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nn : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\nx : n → 𝕜\n⊢ Eq ((Matrix.toEuclideanCLM A) ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)).symm x)) ((WithLp.equiv 2 (n → 𝕜)).symm ((Matrix.toLin' A) x))","decl":"@[simp]\nlemma toEuclideanCLM_piLp_equiv_symm (A : Matrix n n 𝕜) (x : n → 𝕜) :\n    toEuclideanCLM (n := n) (𝕜 := 𝕜) A ((WithLp.equiv _ _).symm x) =\n      (WithLp.equiv _ _).symm (toLin' A x) :=\n  rfl\n\n"}
{"name":"Matrix.piLp_equiv_toEuclideanCLM","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nn : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\nx : EuclideanSpace 𝕜 n\n⊢ Eq ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)) ((Matrix.toEuclideanCLM A) x)) ((Matrix.toLin' A) ((WithLp.equiv 2 (n → 𝕜)) x))","decl":"@[simp]\nlemma piLp_equiv_toEuclideanCLM (A : Matrix n n 𝕜) (x : EuclideanSpace 𝕜 n) :\n    WithLp.equiv _ _ (toEuclideanCLM (n := n) (𝕜 := 𝕜) A x) =\n      toLin' A (WithLp.equiv _ _ x) :=\n  rfl\n\n"}
{"name":"Matrix.l2_opNorm_def","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝³ : RCLike 𝕜\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m n 𝕜\n⊢ Eq (Norm.norm A) (Norm.norm ((Matrix.toEuclideanLin.trans LinearMap.toContinuousLinearMap) A))","decl":"lemma l2_opNorm_def (A : Matrix m n 𝕜) :\n    ‖A‖ = ‖(toEuclideanLin (𝕜 := 𝕜) (m := m) (n := n)).trans toContinuousLinearMap A‖ := rfl\n\n"}
{"name":"Matrix.l2_opNNNorm_def","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝³ : RCLike 𝕜\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m n 𝕜\n⊢ Eq (NNNorm.nnnorm A) (NNNorm.nnnorm ((Matrix.toEuclideanLin.trans LinearMap.toContinuousLinearMap) A))","decl":"lemma l2_opNNNorm_def (A : Matrix m n 𝕜) :\n    ‖A‖₊ = ‖(toEuclideanLin (𝕜 := 𝕜) (m := m) (n := n)).trans toContinuousLinearMap A‖₊ := rfl\n\n"}
{"name":"Matrix.l2_opNorm_conjTranspose","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝⁴ : RCLike 𝕜\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nA : Matrix m n 𝕜\n⊢ Eq (Norm.norm A.conjTranspose) (Norm.norm A)","decl":"lemma l2_opNorm_conjTranspose [DecidableEq m] (A : Matrix m n 𝕜) : ‖Aᴴ‖ = ‖A‖ := by\n  rw [l2_opNorm_def, toEuclideanLin_eq_toLin_orthonormal, LinearEquiv.trans_apply,\n    toLin_conjTranspose, adjoint_toContinuousLinearMap]\n  exact ContinuousLinearMap.adjoint.norm_map _\n\n"}
{"name":"Matrix.l2_opNNNorm_conjTranspose","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝⁴ : RCLike 𝕜\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : DecidableEq m\nA : Matrix m n 𝕜\n⊢ Eq (NNNorm.nnnorm A.conjTranspose) (NNNorm.nnnorm A)","decl":"lemma l2_opNNNorm_conjTranspose [DecidableEq m] (A : Matrix m n 𝕜) : ‖Aᴴ‖₊ = ‖A‖₊ :=\n  Subtype.ext <| l2_opNorm_conjTranspose _\n\n"}
{"name":"Matrix.l2_opNorm_conjTranspose_mul_self","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝³ : RCLike 𝕜\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m n 𝕜\n⊢ Eq (Norm.norm (HMul.hMul A.conjTranspose A)) (HMul.hMul (Norm.norm A) (Norm.norm A))","decl":"lemma l2_opNorm_conjTranspose_mul_self (A : Matrix m n 𝕜) : ‖Aᴴ * A‖ = ‖A‖ * ‖A‖ := by\n  classical\n  rw [l2_opNorm_def, toEuclideanLin_eq_toLin_orthonormal, LinearEquiv.trans_apply,\n    Matrix.toLin_mul (v₂ := (EuclideanSpace.basisFun m 𝕜).toBasis), toLin_conjTranspose]\n  exact ContinuousLinearMap.norm_adjoint_comp_self _\n\n"}
{"name":"Matrix.l2_opNNNorm_conjTranspose_mul_self","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝³ : RCLike 𝕜\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m n 𝕜\n⊢ Eq (NNNorm.nnnorm (HMul.hMul A.conjTranspose A)) (HMul.hMul (NNNorm.nnnorm A) (NNNorm.nnnorm A))","decl":"lemma l2_opNNNorm_conjTranspose_mul_self (A : Matrix m n 𝕜) : ‖Aᴴ * A‖₊ = ‖A‖₊ * ‖A‖₊ :=\n  Subtype.ext <| l2_opNorm_conjTranspose_mul_self _\n\n-- note: with only a type ascription in the left-hand side, Lean picks the wrong norm.\n"}
{"name":"Matrix.l2_opNorm_mulVec","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝³ : RCLike 𝕜\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m n 𝕜\nx : EuclideanSpace 𝕜 n\n⊢ LE.le (Norm.norm ((EuclideanSpace.equiv m 𝕜).symm (A.mulVec x))) (HMul.hMul (Norm.norm A) (Norm.norm x))","decl":"lemma l2_opNorm_mulVec (A : Matrix m n 𝕜) (x : EuclideanSpace 𝕜 n) :\n    ‖(EuclideanSpace.equiv m 𝕜).symm <| A *ᵥ x‖ ≤ ‖A‖ * ‖x‖ :=\n  toEuclideanLin (n := n) (m := m) (𝕜 := 𝕜) |>.trans toContinuousLinearMap A |>.le_opNorm x\n\n"}
{"name":"Matrix.l2_opNNNorm_mulVec","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝³ : RCLike 𝕜\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix m n 𝕜\nx : EuclideanSpace 𝕜 n\n⊢ LE.le (NNNorm.nnnorm ((EuclideanSpace.equiv m 𝕜).symm (A.mulVec x))) (HMul.hMul (NNNorm.nnnorm A) (NNNorm.nnnorm x))","decl":"lemma l2_opNNNorm_mulVec (A : Matrix m n 𝕜) (x : EuclideanSpace 𝕜 n) :\n    ‖(EuclideanSpace.equiv m 𝕜).symm <| A *ᵥ x‖₊ ≤ ‖A‖₊ * ‖x‖₊ :=\n  A.l2_opNorm_mulVec x\n\n"}
{"name":"Matrix.l2_opNorm_mul","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\nl : Type u_4\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Fintype l\ninst✝ : DecidableEq l\nA : Matrix m n 𝕜\nB : Matrix n l 𝕜\n⊢ LE.le (Norm.norm (HMul.hMul A B)) (HMul.hMul (Norm.norm A) (Norm.norm B))","decl":"lemma l2_opNorm_mul (A : Matrix m n 𝕜) (B : Matrix n l 𝕜) :\n    ‖A * B‖ ≤ ‖A‖ * ‖B‖ := by\n  simp only [l2_opNorm_def]\n  have := (toEuclideanLin (n := n) (m := m) (𝕜 := 𝕜) ≪≫ₗ toContinuousLinearMap) A\n    |>.opNorm_comp_le <| (toEuclideanLin (n := l) (m := n) (𝕜 := 𝕜) ≪≫ₗ toContinuousLinearMap) B\n  convert this\n  ext1 x\n  exact congr($(Matrix.toLin'_mul A B) x)\n\n"}
{"name":"Matrix.l2_opNNNorm_mul","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nm : Type u_2\nn : Type u_3\nl : Type u_4\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\ninst✝¹ : Fintype l\ninst✝ : DecidableEq l\nA : Matrix m n 𝕜\nB : Matrix n l 𝕜\n⊢ LE.le (NNNorm.nnnorm (HMul.hMul A B)) (HMul.hMul (NNNorm.nnnorm A) (NNNorm.nnnorm B))","decl":"lemma l2_opNNNorm_mul (A : Matrix m n 𝕜) (B : Matrix n l 𝕜) : ‖A * B‖₊ ≤ ‖A‖₊ * ‖B‖₊ :=\n  l2_opNorm_mul A B\n\n"}
{"name":"Matrix.cstar_norm_def","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nn : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\n⊢ Eq (Norm.norm A) (Norm.norm (Matrix.toEuclideanCLM A))","decl":"/-- This is the same as `Matrix.l2_opNorm_def`, but with a more bundled RHS for square matrices. -/\nlemma cstar_norm_def (A : Matrix n n 𝕜) : ‖A‖ = ‖toEuclideanCLM (n := n) (𝕜 := 𝕜) A‖ := rfl\n\n"}
{"name":"Matrix.cstar_nnnorm_def","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nn : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n 𝕜\n⊢ Eq (NNNorm.nnnorm A) (NNNorm.nnnorm (Matrix.toEuclideanCLM A))","decl":"/-- This is the same as `Matrix.l2_opNNNorm_def`, but with a more bundled RHS for square\nmatrices. -/\nlemma cstar_nnnorm_def (A : Matrix n n 𝕜) : ‖A‖₊ = ‖toEuclideanCLM (n := n) (𝕜 := 𝕜) A‖₊ := rfl\n\n"}
{"name":"Matrix.instCStarRing","module":"Mathlib.Analysis.CStarAlgebra.Matrix","initialProofState":"𝕜 : Type u_1\nn : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ CStarRing (Matrix n n 𝕜)","decl":"/-- The operator norm on `Matrix n n 𝕜` given by the identification with (continuous) linear\nendmorphisms of `EuclideanSpace 𝕜 n` makes it into a `L2OpRing`. -/\nlemma instCStarRing : CStarRing (Matrix n n 𝕜) where\n  norm_mul_self_le M := le_of_eq <| Eq.symm <| l2_opNorm_conjTranspose_mul_self M\n\n"}
