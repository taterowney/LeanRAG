{"name":"Finsupp.Lex.acc","module":"Mathlib.Data.Finsupp.WellFounded","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝ : Zero N\nr : α → α → Prop\ns : N → N → Prop\nhbot : ∀ ⦃n : N⦄, Not (s n 0)\nhs : WellFounded s\nx : Finsupp α N\nh : ∀ (a : α), Membership.mem x.support a → Acc (Min.min (HasCompl.compl r) fun x1 x2 => Ne x1 x2) a\n⊢ Acc (Finsupp.Lex r s) x","decl":"/-- Transferred from `DFinsupp.Lex.acc`. See the top of that file for an explanation for the\n  appearance of the relation `rᶜ ⊓ (≠)`. -/\ntheorem Lex.acc (hbot : ∀ ⦃n⦄, ¬s n 0) (hs : WellFounded s) (x : α →₀ N)\n    (h : ∀ a ∈ x.support, Acc (rᶜ ⊓ (· ≠ ·)) a) :\n    Acc (Finsupp.Lex r s) x := by\n  rw [lex_eq_invImage_dfinsupp_lex]\n  classical\n    refine InvImage.accessible toDFinsupp (DFinsupp.Lex.acc (fun _ => hbot) (fun _ => hs) _ ?_)\n    simpa only [toDFinsupp_support] using h\n\n"}
{"name":"Finsupp.Lex.wellFounded","module":"Mathlib.Data.Finsupp.WellFounded","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝ : Zero N\nr : α → α → Prop\ns : N → N → Prop\nhbot : ∀ ⦃n : N⦄, Not (s n 0)\nhs : WellFounded s\nhr : WellFounded (Min.min (HasCompl.compl r) fun x1 x2 => Ne x1 x2)\n⊢ WellFounded (Finsupp.Lex r s)","decl":"theorem Lex.wellFounded (hbot : ∀ ⦃n⦄, ¬s n 0) (hs : WellFounded s)\n    (hr : WellFounded <| rᶜ ⊓ (· ≠ ·)) : WellFounded (Finsupp.Lex r s) :=\n  ⟨fun x => Lex.acc hbot hs x fun a _ => hr.apply a⟩\n\n"}
{"name":"Finsupp.Lex.wellFounded'","module":"Mathlib.Data.Finsupp.WellFounded","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝¹ : Zero N\nr : α → α → Prop\ns : N → N → Prop\nhbot : ∀ ⦃n : N⦄, Not (s n 0)\nhs : WellFounded s\ninst✝ : IsTrichotomous α r\nhr : WellFounded (Function.swap r)\n⊢ WellFounded (Finsupp.Lex r s)","decl":"theorem Lex.wellFounded' (hbot : ∀ ⦃n⦄, ¬s n 0) (hs : WellFounded s)\n    [IsTrichotomous α r] (hr : WellFounded (Function.swap r)) : WellFounded (Finsupp.Lex r s) :=\n  (lex_eq_invImage_dfinsupp_lex r s).symm ▸\n    InvImage.wf _ (DFinsupp.Lex.wellFounded' (fun _ => hbot) (fun _ => hs) hr)\n\n"}
{"name":"Finsupp.Lex.wellFoundedLT","module":"Mathlib.Data.Finsupp.WellFounded","initialProofState":"α : Type u_3\nN : Type u_4\ninst✝⁴ : LT α\ninst✝³ : IsTrichotomous α fun x1 x2 => LT.lt x1 x2\nhα : WellFoundedGT α\ninst✝² : AddMonoid N\ninst✝¹ : PartialOrder N\ninst✝ : CanonicallyOrderedAdd N\nhN : WellFoundedLT N\n⊢ WellFoundedLT (Lex (Finsupp α N))","decl":"instance Lex.wellFoundedLT {α N} [LT α] [IsTrichotomous α (· < ·)] [hα : WellFoundedGT α]\n    [AddMonoid N] [PartialOrder N] [CanonicallyOrderedAdd N]\n    [hN : WellFoundedLT N] : WellFoundedLT (Lex (α →₀ N)) :=\n  ⟨Lex.wellFounded' (fun n => (zero_le n).not_lt) hN.wf hα.wf⟩\n\n"}
{"name":"Finsupp.Lex.wellFounded_of_finite","module":"Mathlib.Data.Finsupp.WellFounded","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝² : Zero N\nr : α → α → Prop\ns : N → N → Prop\ninst✝¹ : IsStrictTotalOrder α r\ninst✝ : Finite α\nhs : WellFounded s\n⊢ WellFounded (Finsupp.Lex r s)","decl":"theorem Lex.wellFounded_of_finite [IsStrictTotalOrder α r] [Finite α]\n    (hs : WellFounded s) : WellFounded (Finsupp.Lex r s) :=\n  InvImage.wf (@equivFunOnFinite α N _ _) (Pi.Lex.wellFounded r fun _ => hs)\n\n"}
{"name":"Finsupp.Lex.wellFoundedLT_of_finite","module":"Mathlib.Data.Finsupp.WellFounded","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝³ : Zero N\ninst✝² : LinearOrder α\ninst✝¹ : Finite α\ninst✝ : LT N\nhwf : WellFoundedLT N\n⊢ WellFoundedLT (Lex (Finsupp α N))","decl":"theorem Lex.wellFoundedLT_of_finite [LinearOrder α] [Finite α] [LT N]\n    [hwf : WellFoundedLT N] : WellFoundedLT (Lex (α →₀ N)) :=\n  ⟨Finsupp.Lex.wellFounded_of_finite (· < ·) hwf.1⟩\n\n"}
{"name":"Finsupp.wellFoundedLT","module":"Mathlib.Data.Finsupp.WellFounded","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝² : Zero N\ninst✝¹ : Preorder N\ninst✝ : WellFoundedLT N\nhbot : ∀ (n : N), Not (LT.lt n 0)\n⊢ WellFoundedLT (Finsupp α N)","decl":"protected theorem wellFoundedLT [Preorder N] [WellFoundedLT N] (hbot : ∀ n : N, ¬n < 0) :\n    WellFoundedLT (α →₀ N) :=\n  ⟨InvImage.wf toDFinsupp (DFinsupp.wellFoundedLT fun _ a => hbot a).wf⟩\n\n"}
{"name":"Finsupp.wellFoundedLT'","module":"Mathlib.Data.Finsupp.WellFounded","initialProofState":"α : Type u_1\nN : Type u_3\ninst✝³ : AddMonoid N\ninst✝² : PartialOrder N\ninst✝¹ : CanonicallyOrderedAdd N\ninst✝ : WellFoundedLT N\n⊢ WellFoundedLT (Finsupp α N)","decl":"instance wellFoundedLT' {N}\n    [AddMonoid N] [PartialOrder N] [CanonicallyOrderedAdd N] [WellFoundedLT N] :\n    WellFoundedLT (α →₀ N) :=\n  Finsupp.wellFoundedLT fun a => (zero_le a).not_lt\n\n"}
{"name":"Finsupp.wellFoundedLT_of_finite","module":"Mathlib.Data.Finsupp.WellFounded","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝³ : Zero N\ninst✝² : Finite α\ninst✝¹ : Preorder N\ninst✝ : WellFoundedLT N\n⊢ WellFoundedLT (Finsupp α N)","decl":"instance wellFoundedLT_of_finite [Finite α] [Preorder N] [WellFoundedLT N] :\n    WellFoundedLT (α →₀ N) :=\n  ⟨InvImage.wf equivFunOnFinite Function.wellFoundedLT.wf⟩\n\n"}
