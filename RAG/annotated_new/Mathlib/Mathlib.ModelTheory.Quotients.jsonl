{"name":"FirstOrder.Language.Prestructure.rel_equiv","module":"Mathlib.ModelTheory.Quotients","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ns : Setoid M\nself : L.Prestructure s\nn : Nat\nr : L.Relations n\nx y : Fin n → M\nx✝ : HasEquiv.Equiv x y\n⊢ Eq (FirstOrder.Language.Structure.RelMap r x) (FirstOrder.Language.Structure.RelMap r y)","decl":"/-- A prestructure is a first-order structure with a `Setoid` equivalence relation on it,\n  such that quotienting by that equivalence relation is still a structure. -/\nclass Prestructure (s : Setoid M) where\n  toStructure : L.Structure M\n  fun_equiv : ∀ {n} {f : L.Functions n} (x y : Fin n → M), x ≈ y → funMap f x ≈ funMap f y\n  rel_equiv : ∀ {n} {r : L.Relations n} (x y : Fin n → M) (_ : x ≈ y), RelMap r x = RelMap r y\n\n"}
{"name":"FirstOrder.Language.Prestructure.fun_equiv","module":"Mathlib.ModelTheory.Quotients","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ns : Setoid M\nself : L.Prestructure s\nn : Nat\nf : L.Functions n\nx y : Fin n → M\na✝ : HasEquiv.Equiv x y\n⊢ HasEquiv.Equiv (FirstOrder.Language.Structure.funMap f x) (FirstOrder.Language.Structure.funMap f y)","decl":"/-- A prestructure is a first-order structure with a `Setoid` equivalence relation on it,\n  such that quotienting by that equivalence relation is still a structure. -/\nclass Prestructure (s : Setoid M) where\n  toStructure : L.Structure M\n  fun_equiv : ∀ {n} {f : L.Functions n} (x y : Fin n → M), x ≈ y → funMap f x ≈ funMap f y\n  rel_equiv : ∀ {n} {r : L.Relations n} (x y : Fin n → M) (_ : x ≈ y), RelMap r x = RelMap r y\n\n"}
{"name":"FirstOrder.Language.funMap_quotient_mk'","module":"Mathlib.ModelTheory.Quotients","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ns : Setoid M\nps : L.Prestructure s\nn : Nat\nf : L.Functions n\nx : Fin n → M\n⊢ Eq (FirstOrder.Language.Structure.funMap f fun i => Quotient.mk s (x i)) (Quotient.mk s (FirstOrder.Language.Structure.funMap f x))","decl":"theorem funMap_quotient_mk' {n : ℕ} (f : L.Functions n) (x : Fin n → M) :\n    (funMap f fun i => (⟦x i⟧ : Quotient s)) = ⟦@funMap _ _ ps.toStructure _ f x⟧ := by\n  change\n    Quotient.map (@funMap L M ps.toStructure n f) Prestructure.fun_equiv (Quotient.finChoice _) =\n      _\n  rw [Quotient.finChoice_eq, Quotient.map_mk]\n\n"}
{"name":"FirstOrder.Language.relMap_quotient_mk'","module":"Mathlib.ModelTheory.Quotients","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ns : Setoid M\nps : L.Prestructure s\nn : Nat\nr : L.Relations n\nx : Fin n → M\n⊢ Iff (FirstOrder.Language.Structure.RelMap r fun i => Quotient.mk s (x i)) (FirstOrder.Language.Structure.RelMap r x)","decl":"theorem relMap_quotient_mk' {n : ℕ} (r : L.Relations n) (x : Fin n → M) :\n    (RelMap r fun i => (⟦x i⟧ : Quotient s)) ↔ @RelMap _ _ ps.toStructure _ r x := by\n  change\n    Quotient.lift (@RelMap L M ps.toStructure n r) Prestructure.rel_equiv (Quotient.finChoice _) ↔\n      _\n  rw [Quotient.finChoice_eq, Quotient.lift_mk]\n\n"}
{"name":"FirstOrder.Language.Term.realize_quotient_mk'","module":"Mathlib.ModelTheory.Quotients","initialProofState":"L : FirstOrder.Language\nM : Type u_1\ns : Setoid M\nps : L.Prestructure s\nβ : Type u_2\nt : L.Term β\nx : β → M\n⊢ Eq (FirstOrder.Language.Term.realize (fun i => Quotient.mk s (x i)) t) (Quotient.mk s (FirstOrder.Language.Term.realize x t))","decl":"theorem Term.realize_quotient_mk' {β : Type*} (t : L.Term β) (x : β → M) :\n    (t.realize fun i => (⟦x i⟧ : Quotient s)) = ⟦@Term.realize _ _ ps.toStructure _ x t⟧ := by\n  induction t with\n  | var => rfl\n  | func _ _ ih => simp only [ih, funMap_quotient_mk', Term.realize]\n\n"}
