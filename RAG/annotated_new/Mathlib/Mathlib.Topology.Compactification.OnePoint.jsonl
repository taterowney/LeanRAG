{"name":"OnePoint.some_eq_iff","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nx₁ x₂ : X\n⊢ Iff (Eq ↑x₁ ↑x₂) (Eq x₁ x₂)","decl":"@[simp]\nlemma some_eq_iff (x₁ x₂ : X) : (some x₁ = some x₂) ↔ (x₁ = x₂) := by\n  rw [iff_eq_eq]\n  exact Option.some.injEq x₁ x₂\n\n"}
{"name":"OnePoint.forall","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\np : OnePoint X → Prop\n⊢ Iff (∀ (x : OnePoint X), p x) (And (p OnePoint.infty) (∀ (x : X), p ↑x))","decl":"protected lemma «forall» {p : OnePoint X → Prop} :\n    (∀ (x : OnePoint X), p x) ↔ p ∞ ∧ ∀ (x : X), p x :=\n  Option.forall\n\n"}
{"name":"OnePoint.exists","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\np : OnePoint X → Prop\n⊢ Iff (Exists fun x => p x) (Or (p OnePoint.infty) (Exists fun x => p ↑x))","decl":"protected lemma «exists» {p : OnePoint X → Prop} :\n    (∃ x, p x) ↔ p ∞ ∨ ∃ (x : X), p x :=\n  Option.exists\n\n"}
{"name":"OnePoint.infinite","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : Infinite X\n⊢ Infinite (OnePoint X)","decl":"instance infinite [Infinite X] : Infinite (OnePoint X) :=\n  inferInstanceAs (Infinite (Option X))\n\n"}
{"name":"OnePoint.coe_injective","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ Function.Injective OnePoint.some","decl":"theorem coe_injective : Function.Injective ((↑) : X → OnePoint X) :=\n  Option.some_injective X\n\n"}
{"name":"OnePoint.coe_eq_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nx y : X\n⊢ Iff (Eq ↑x ↑y) (Eq x y)","decl":"@[norm_cast]\ntheorem coe_eq_coe {x y : X} : (x : OnePoint X) = y ↔ x = y :=\n  coe_injective.eq_iff\n\n"}
{"name":"OnePoint.coe_ne_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nx : X\n⊢ Ne (↑x) OnePoint.infty","decl":"@[simp]\ntheorem coe_ne_infty (x : X) : (x : OnePoint X) ≠ ∞ :=\n  nofun\n\n"}
{"name":"OnePoint.infty_ne_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nx : X\n⊢ Ne OnePoint.infty ↑x","decl":"@[simp]\ntheorem infty_ne_coe (x : X) : ∞ ≠ (x : OnePoint X) :=\n  nofun\n\n"}
{"name":"OnePoint.elim_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\ny : Y\nf : X → Y\n⊢ Eq (OnePoint.infty.elim y f) y","decl":"@[simp] theorem elim_infty (y : Y) (f : X → Y) : ∞.elim y f = y := rfl\n\n"}
{"name":"OnePoint.elim_some","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\ny : Y\nf : X → Y\nx : X\n⊢ Eq ((↑x).elim y f) (f x)","decl":"@[simp] theorem elim_some (y : Y) (f : X → Y) (x : X) : (some x).elim y f = f x := rfl\n\n"}
{"name":"OnePoint.isCompl_range_coe_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ IsCompl (Set.range OnePoint.some) (Singleton.singleton OnePoint.infty)","decl":"theorem isCompl_range_coe_infty : IsCompl (range ((↑) : X → OnePoint X)) {∞} :=\n  isCompl_range_some_none X\n\n"}
{"name":"OnePoint.range_coe_union_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ Eq (Union.union (Set.range OnePoint.some) (Singleton.singleton OnePoint.infty)) Set.univ","decl":"theorem range_coe_union_infty : range ((↑) : X → OnePoint X) ∪ {∞} = univ :=\n  range_some_union_none X\n\n"}
{"name":"OnePoint.insert_infty_range_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ Eq (Insert.insert OnePoint.infty (Set.range OnePoint.some)) Set.univ","decl":"@[simp]\ntheorem insert_infty_range_coe : insert ∞ (range (@some X)) = univ :=\n  insert_none_range_some _\n\n"}
{"name":"OnePoint.range_coe_inter_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ Eq (Inter.inter (Set.range OnePoint.some) (Singleton.singleton OnePoint.infty)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_coe_inter_infty : range ((↑) : X → OnePoint X) ∩ {∞} = ∅ :=\n  range_some_inter_none X\n\n"}
{"name":"OnePoint.compl_range_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ Eq (HasCompl.compl (Set.range OnePoint.some)) (Singleton.singleton OnePoint.infty)","decl":"@[simp]\ntheorem compl_range_coe : (range ((↑) : X → OnePoint X))ᶜ = {∞} :=\n  compl_range_some X\n\n"}
{"name":"OnePoint.compl_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ Eq (HasCompl.compl (Singleton.singleton OnePoint.infty)) (Set.range OnePoint.some)","decl":"theorem compl_infty : ({∞}ᶜ : Set (OnePoint X)) = range ((↑) : X → OnePoint X) :=\n  (@isCompl_range_coe_infty X).symm.compl_eq\n\n"}
{"name":"OnePoint.compl_image_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ns : Set X\n⊢ Eq (HasCompl.compl (Set.image OnePoint.some s)) (Union.union (Set.image OnePoint.some (HasCompl.compl s)) (Singleton.singleton OnePoint.infty))","decl":"theorem compl_image_coe (s : Set X) : ((↑) '' s : Set (OnePoint X))ᶜ = (↑) '' sᶜ ∪ {∞} := by\n  rw [coe_injective.compl_image_eq, compl_range_coe]\n\n"}
{"name":"OnePoint.ne_infty_iff_exists","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nx : OnePoint X\n⊢ Iff (Ne x OnePoint.infty) (Exists fun y => Eq (↑y) x)","decl":"theorem ne_infty_iff_exists {x : OnePoint X} : x ≠ ∞ ↔ ∃ y : X, (y : OnePoint X) = x := by\n  induction x using OnePoint.rec <;> simp\n\n"}
{"name":"OnePoint.canLift","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ CanLift (OnePoint X) X OnePoint.some fun x => Ne x OnePoint.infty","decl":"instance canLift : CanLift (OnePoint X) X (↑) fun x => x ≠ ∞ :=\n  WithTop.canLift\n\n"}
{"name":"OnePoint.not_mem_range_coe_iff","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nx : OnePoint X\n⊢ Iff (Not (Membership.mem (Set.range OnePoint.some) x)) (Eq x OnePoint.infty)","decl":"theorem not_mem_range_coe_iff {x : OnePoint X} : x ∉ range some ↔ x = ∞ := by\n  rw [← mem_compl_iff, compl_range_coe, mem_singleton_iff]\n\n"}
{"name":"OnePoint.infty_not_mem_range_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ Not (Membership.mem (Set.range OnePoint.some) OnePoint.infty)","decl":"theorem infty_not_mem_range_coe : ∞ ∉ range ((↑) : X → OnePoint X) :=\n  not_mem_range_coe_iff.2 rfl\n\n"}
{"name":"OnePoint.infty_not_mem_image_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ns : Set X\n⊢ Not (Membership.mem (Set.image OnePoint.some s) OnePoint.infty)","decl":"theorem infty_not_mem_image_coe {s : Set X} : ∞ ∉ ((↑) : X → OnePoint X) '' s :=\n  not_mem_subset (image_subset_range _ _) infty_not_mem_range_coe\n\n"}
{"name":"OnePoint.coe_preimage_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ Eq (Set.preimage OnePoint.some (Singleton.singleton OnePoint.infty)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem coe_preimage_infty : ((↑) : X → OnePoint X) ⁻¹' {∞} = ∅ := by\n  ext\n  simp\n\n"}
{"name":"OnePoint.map_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\nf : X → Y\n⊢ Eq (OnePoint.map f OnePoint.infty) OnePoint.infty","decl":"@[simp] theorem map_infty (f : X → Y) : OnePoint.map f ∞ = ∞ := rfl\n"}
{"name":"OnePoint.map_some","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\nf : X → Y\nx : X\n⊢ Eq (OnePoint.map f ↑x) ↑(f x)","decl":"@[simp] theorem map_some (f : X → Y) (x : X) : (x : OnePoint X).map f = f x := rfl\n"}
{"name":"OnePoint.map_id","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\n⊢ Eq (OnePoint.map id) id","decl":"@[simp] theorem map_id : OnePoint.map (id : X → X) = id := Option.map_id\n\n"}
{"name":"OnePoint.map_comp","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nf : Y → Z\ng : X → Y\n⊢ Eq (OnePoint.map (Function.comp f g)) (Function.comp (OnePoint.map f) (OnePoint.map g))","decl":"theorem map_comp {Z : Type*} (f : Y → Z) (g : X → Y) :\n    OnePoint.map (f ∘ g) = OnePoint.map f ∘ OnePoint.map g :=\n  (Option.map_comp_map _ _).symm\n\n"}
{"name":"OnePoint.isOpen_def","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set (OnePoint X)\n⊢ Iff (IsOpen s) (And (Membership.mem s OnePoint.infty → IsCompact (HasCompl.compl (Set.preimage OnePoint.some s))) (IsOpen (Set.preimage OnePoint.some s)))","decl":"theorem isOpen_def :\n    IsOpen s ↔ (∞ ∈ s → IsCompact ((↑) ⁻¹' s : Set X)ᶜ) ∧ IsOpen ((↑) ⁻¹' s : Set X) :=\n  Iff.rfl\n\n"}
{"name":"OnePoint.isOpen_iff_of_mem'","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set (OnePoint X)\nh : Membership.mem s OnePoint.infty\n⊢ Iff (IsOpen s) (And (IsCompact (HasCompl.compl (Set.preimage OnePoint.some s))) (IsOpen (Set.preimage OnePoint.some s)))","decl":"theorem isOpen_iff_of_mem' (h : ∞ ∈ s) :\n    IsOpen s ↔ IsCompact ((↑) ⁻¹' s : Set X)ᶜ ∧ IsOpen ((↑) ⁻¹' s : Set X) := by\n  simp [isOpen_def, h]\n\n"}
{"name":"OnePoint.isOpen_iff_of_mem","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set (OnePoint X)\nh : Membership.mem s OnePoint.infty\n⊢ Iff (IsOpen s) (And (IsClosed (HasCompl.compl (Set.preimage OnePoint.some s))) (IsCompact (HasCompl.compl (Set.preimage OnePoint.some s))))","decl":"theorem isOpen_iff_of_mem (h : ∞ ∈ s) :\n    IsOpen s ↔ IsClosed ((↑) ⁻¹' s : Set X)ᶜ ∧ IsCompact ((↑) ⁻¹' s : Set X)ᶜ := by\n  simp only [isOpen_iff_of_mem' h, isClosed_compl_iff, and_comm]\n\n"}
{"name":"OnePoint.isOpen_iff_of_not_mem","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set (OnePoint X)\nh : Not (Membership.mem s OnePoint.infty)\n⊢ Iff (IsOpen s) (IsOpen (Set.preimage OnePoint.some s))","decl":"theorem isOpen_iff_of_not_mem (h : ∞ ∉ s) : IsOpen s ↔ IsOpen ((↑) ⁻¹' s : Set X) := by\n  simp [isOpen_def, h]\n\n"}
{"name":"OnePoint.isClosed_iff_of_mem","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set (OnePoint X)\nh : Membership.mem s OnePoint.infty\n⊢ Iff (IsClosed s) (IsClosed (Set.preimage OnePoint.some s))","decl":"theorem isClosed_iff_of_mem (h : ∞ ∈ s) : IsClosed s ↔ IsClosed ((↑) ⁻¹' s : Set X) := by\n  have : ∞ ∉ sᶜ := fun H => H h\n  rw [← isOpen_compl_iff, isOpen_iff_of_not_mem this, ← isOpen_compl_iff, preimage_compl]\n\n"}
{"name":"OnePoint.isClosed_iff_of_not_mem","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set (OnePoint X)\nh : Not (Membership.mem s OnePoint.infty)\n⊢ Iff (IsClosed s) (And (IsClosed (Set.preimage OnePoint.some s)) (IsCompact (Set.preimage OnePoint.some s)))","decl":"theorem isClosed_iff_of_not_mem (h : ∞ ∉ s) :\n    IsClosed s ↔ IsClosed ((↑) ⁻¹' s : Set X) ∧ IsCompact ((↑) ⁻¹' s : Set X) := by\n  rw [← isOpen_compl_iff, isOpen_iff_of_mem (mem_compl h), ← preimage_compl, compl_compl]\n\n"}
{"name":"OnePoint.isOpen_image_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsOpen (Set.image OnePoint.some s)) (IsOpen s)","decl":"@[simp]\ntheorem isOpen_image_coe {s : Set X} : IsOpen ((↑) '' s : Set (OnePoint X)) ↔ IsOpen s := by\n  rw [isOpen_iff_of_not_mem infty_not_mem_image_coe, preimage_image_eq _ coe_injective]\n\n"}
{"name":"OnePoint.isOpen_compl_image_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsOpen (HasCompl.compl (Set.image OnePoint.some s))) (And (IsClosed s) (IsCompact s))","decl":"theorem isOpen_compl_image_coe {s : Set X} :\n    IsOpen ((↑) '' s : Set (OnePoint X))ᶜ ↔ IsClosed s ∧ IsCompact s := by\n  rw [isOpen_iff_of_mem, ← preimage_compl, compl_compl, preimage_image_eq _ coe_injective]\n  exact infty_not_mem_image_coe\n\n"}
{"name":"OnePoint.isClosed_image_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsClosed (Set.image OnePoint.some s)) (And (IsClosed s) (IsCompact s))","decl":"@[simp]\ntheorem isClosed_image_coe {s : Set X} :\n    IsClosed ((↑) '' s : Set (OnePoint X)) ↔ IsClosed s ∧ IsCompact s := by\n  rw [← isOpen_compl_iff, isOpen_compl_image_coe]\n\n"}
{"name":"OnePoint.infty_mem_opensOfCompl","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nh₁ : IsClosed s\nh₂ : IsCompact s\n⊢ Membership.mem (OnePoint.opensOfCompl s h₁ h₂) OnePoint.infty","decl":"theorem infty_mem_opensOfCompl {s : Set X} (h₁ : IsClosed s) (h₂ : IsCompact s) :\n    ∞ ∈ opensOfCompl s h₁ h₂ :=\n  mem_compl infty_not_mem_image_coe\n\n"}
{"name":"OnePoint.continuous_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Continuous OnePoint.some","decl":"@[continuity]\ntheorem continuous_coe : Continuous ((↑) : X → OnePoint X) :=\n  continuous_def.mpr fun _s hs => hs.right\n\n"}
{"name":"OnePoint.isOpenMap_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ IsOpenMap OnePoint.some","decl":"theorem isOpenMap_coe : IsOpenMap ((↑) : X → OnePoint X) := fun _ => isOpen_image_coe.2\n\n"}
{"name":"OnePoint.isOpenEmbedding_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Topology.IsOpenEmbedding OnePoint.some","decl":"theorem isOpenEmbedding_coe : IsOpenEmbedding ((↑) : X → OnePoint X) :=\n  .of_continuous_injective_isOpenMap continuous_coe coe_injective isOpenMap_coe\n\n"}
{"name":"OnePoint.openEmbedding_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Topology.IsOpenEmbedding OnePoint.some","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_coe := isOpenEmbedding_coe\n\n"}
{"name":"OnePoint.isOpen_range_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ IsOpen (Set.range OnePoint.some)","decl":"theorem isOpen_range_coe : IsOpen (range ((↑) : X → OnePoint X)) :=\n  isOpenEmbedding_coe.isOpen_range\n\n"}
{"name":"OnePoint.isClosed_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ IsClosed (Singleton.singleton OnePoint.infty)","decl":"theorem isClosed_infty : IsClosed ({∞} : Set (OnePoint X)) := by\n  rw [← compl_range_coe, isClosed_compl_iff]\n  exact isOpen_range_coe\n\n"}
{"name":"OnePoint.nhds_coe_eq","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (nhds ↑x) (Filter.map OnePoint.some (nhds x))","decl":"theorem nhds_coe_eq (x : X) : 𝓝 ↑x = map ((↑) : X → OnePoint X) (𝓝 x) :=\n  (isOpenEmbedding_coe.map_nhds_eq x).symm\n\n"}
{"name":"OnePoint.nhdsWithin_coe_image","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nx : X\n⊢ Eq (nhdsWithin (↑x) (Set.image OnePoint.some s)) (Filter.map OnePoint.some (nhdsWithin x s))","decl":"theorem nhdsWithin_coe_image (s : Set X) (x : X) :\n    𝓝[(↑) '' s] (x : OnePoint X) = map (↑) (𝓝[s] x) :=\n  (isOpenEmbedding_coe.isEmbedding.map_nhdsWithin_eq _ _).symm\n\n"}
{"name":"OnePoint.nhdsWithin_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set (OnePoint X)\nx : X\n⊢ Eq (nhdsWithin (↑x) s) (Filter.map OnePoint.some (nhdsWithin x (Set.preimage OnePoint.some s)))","decl":"theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : 𝓝[s] ↑x = map (↑) (𝓝[(↑) ⁻¹' s] x) :=\n  (isOpenEmbedding_coe.map_nhdsWithin_preimage_eq _ _).symm\n\n"}
{"name":"OnePoint.comap_coe_nhds","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (Filter.comap OnePoint.some (nhds ↑x)) (nhds x)","decl":"theorem comap_coe_nhds (x : X) : comap ((↑) : X → OnePoint X) (𝓝 x) = 𝓝 x :=\n  (isOpenEmbedding_coe.isInducing.nhds_eq_comap x).symm\n\n"}
{"name":"OnePoint.nhdsWithin_compl_coe_neBot","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\n⊢ (nhdsWithin (↑x) (HasCompl.compl (Singleton.singleton ↑x))).NeBot","decl":"/-- If `x` is not an isolated point of `X`, then `x : OnePoint X` is not an isolated point\nof `OnePoint X`. -/\ninstance nhdsWithin_compl_coe_neBot (x : X) [h : NeBot (𝓝[≠] x)] :\n    NeBot (𝓝[≠] (x : OnePoint X)) := by\n  simpa [nhdsWithin_coe, preimage, coe_eq_coe] using h.map some\n\n"}
{"name":"OnePoint.nhdsWithin_compl_infty_eq","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Eq (nhdsWithin OnePoint.infty (HasCompl.compl (Singleton.singleton OnePoint.infty))) (Filter.map OnePoint.some (Filter.coclosedCompact X))","decl":"theorem nhdsWithin_compl_infty_eq : 𝓝[≠] (∞ : OnePoint X) = map (↑) (coclosedCompact X) := by\n  refine (nhdsWithin_basis_open ∞ _).ext (hasBasis_coclosedCompact.map _) ?_ ?_\n  · rintro s ⟨hs, hso⟩\n    refine ⟨_, (isOpen_iff_of_mem hs).mp hso, ?_⟩\n    simp [Subset.rfl]\n  · rintro s ⟨h₁, h₂⟩\n    refine ⟨_, ⟨mem_compl infty_not_mem_image_coe, isOpen_compl_image_coe.2 ⟨h₁, h₂⟩⟩, ?_⟩\n    simp [compl_image_coe, ← diff_eq, subset_preimage_image]\n\n"}
{"name":"OnePoint.nhdsWithin_compl_infty_neBot","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : NoncompactSpace X\n⊢ (nhdsWithin OnePoint.infty (HasCompl.compl (Singleton.singleton OnePoint.infty))).NeBot","decl":"/-- If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. -/\ninstance nhdsWithin_compl_infty_neBot [NoncompactSpace X] : NeBot (𝓝[≠] (∞ : OnePoint X)) := by\n  rw [nhdsWithin_compl_infty_eq]\n  infer_instance\n\n"}
{"name":"OnePoint.nhdsWithin_compl_neBot","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : ∀ (x : X), (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\ninst✝ : NoncompactSpace X\nx : OnePoint X\n⊢ (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot","decl":"instance (priority := 900) nhdsWithin_compl_neBot [∀ x : X, NeBot (𝓝[≠] x)] [NoncompactSpace X]\n    (x : OnePoint X) : NeBot (𝓝[≠] x) :=\n  OnePoint.rec OnePoint.nhdsWithin_compl_infty_neBot\n    (fun y => OnePoint.nhdsWithin_compl_coe_neBot y) x\n\n"}
{"name":"OnePoint.nhds_infty_eq","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Eq (nhds OnePoint.infty) (Max.max (Filter.map OnePoint.some (Filter.coclosedCompact X)) (Pure.pure OnePoint.infty))","decl":"theorem nhds_infty_eq : 𝓝 (∞ : OnePoint X) = map (↑) (coclosedCompact X) ⊔ pure ∞ := by\n  rw [← nhdsWithin_compl_infty_eq, nhdsWithin_compl_singleton_sup_pure]\n\n"}
{"name":"OnePoint.tendsto_coe_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Filter.Tendsto OnePoint.some (Filter.coclosedCompact X) (nhds OnePoint.infty)","decl":"theorem tendsto_coe_infty : Tendsto (↑) (coclosedCompact X) (𝓝 (∞ : OnePoint X)) := by\n  rw [nhds_infty_eq]\n  exact Filter.Tendsto.mono_right tendsto_map le_sup_left\n\n"}
{"name":"OnePoint.hasBasis_nhds_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ (nhds OnePoint.infty).HasBasis (fun s => And (IsClosed s) (IsCompact s)) fun s => Union.union (Set.image OnePoint.some (HasCompl.compl s)) (Singleton.singleton OnePoint.infty)","decl":"theorem hasBasis_nhds_infty :\n    (𝓝 (∞ : OnePoint X)).HasBasis (fun s : Set X => IsClosed s ∧ IsCompact s) fun s =>\n      (↑) '' sᶜ ∪ {∞} := by\n  rw [nhds_infty_eq]\n  exact (hasBasis_coclosedCompact.map _).sup_pure _\n\n"}
{"name":"OnePoint.comap_coe_nhds_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Eq (Filter.comap OnePoint.some (nhds OnePoint.infty)) (Filter.coclosedCompact X)","decl":"@[simp]\ntheorem comap_coe_nhds_infty : comap ((↑) : X → OnePoint X) (𝓝 ∞) = coclosedCompact X := by\n  simp [nhds_infty_eq, comap_sup, comap_map coe_injective]\n\n"}
{"name":"OnePoint.le_nhds_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nf : Filter (OnePoint X)\n⊢ Iff (LE.le f (nhds OnePoint.infty)) (∀ (s : Set X), IsClosed s → IsCompact s → Membership.mem f (Union.union (Set.image OnePoint.some (HasCompl.compl s)) (Singleton.singleton OnePoint.infty)))","decl":"theorem le_nhds_infty {f : Filter (OnePoint X)} :\n    f ≤ 𝓝 ∞ ↔ ∀ s : Set X, IsClosed s → IsCompact s → (↑) '' sᶜ ∪ {∞} ∈ f := by\n  simp only [hasBasis_nhds_infty.ge_iff, and_imp]\n\n"}
{"name":"OnePoint.ultrafilter_le_nhds_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nf : Ultrafilter (OnePoint X)\n⊢ Iff (LE.le (↑f) (nhds OnePoint.infty)) (∀ (s : Set X), IsClosed s → IsCompact s → Not (Membership.mem f (Set.image OnePoint.some s)))","decl":"theorem ultrafilter_le_nhds_infty {f : Ultrafilter (OnePoint X)} :\n    (f : Filter (OnePoint X)) ≤ 𝓝 ∞ ↔ ∀ s : Set X, IsClosed s → IsCompact s → (↑) '' s ∉ f := by\n  simp only [le_nhds_infty, ← compl_image_coe, Ultrafilter.mem_coe,\n    Ultrafilter.compl_mem_iff_not_mem]\n\n"}
{"name":"OnePoint.tendsto_nhds_infty'","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nα : Type u_3\nf : OnePoint X → α\nl : Filter α\n⊢ Iff (Filter.Tendsto f (nhds OnePoint.infty) l) (And (Filter.Tendsto f (Pure.pure OnePoint.infty) l) (Filter.Tendsto (Function.comp f OnePoint.some) (Filter.coclosedCompact X) l))","decl":"theorem tendsto_nhds_infty' {α : Type*} {f : OnePoint X → α} {l : Filter α} :\n    Tendsto f (𝓝 ∞) l ↔ Tendsto f (pure ∞) l ∧ Tendsto (f ∘ (↑)) (coclosedCompact X) l := by\n  simp [nhds_infty_eq, and_comm]\n\n"}
{"name":"OnePoint.tendsto_nhds_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nα : Type u_3\nf : OnePoint X → α\nl : Filter α\n⊢ Iff (Filter.Tendsto f (nhds OnePoint.infty) l) (∀ (s : Set α), Membership.mem l s → And (Membership.mem s (f OnePoint.infty)) (Exists fun t => And (IsClosed t) (And (IsCompact t) (Set.MapsTo (Function.comp f OnePoint.some) (HasCompl.compl t) s))))","decl":"theorem tendsto_nhds_infty {α : Type*} {f : OnePoint X → α} {l : Filter α} :\n    Tendsto f (𝓝 ∞) l ↔\n      ∀ s ∈ l, f ∞ ∈ s ∧ ∃ t : Set X, IsClosed t ∧ IsCompact t ∧ MapsTo (f ∘ (↑)) tᶜ s :=\n  tendsto_nhds_infty'.trans <| by\n    simp only [tendsto_pure_left, hasBasis_coclosedCompact.tendsto_left_iff, forall_and,\n      and_assoc, exists_prop]\n\n"}
{"name":"OnePoint.continuousAt_infty'","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nY : Type u_3\ninst✝ : TopologicalSpace Y\nf : OnePoint X → Y\n⊢ Iff (ContinuousAt f OnePoint.infty) (Filter.Tendsto (Function.comp f OnePoint.some) (Filter.coclosedCompact X) (nhds (f OnePoint.infty)))","decl":"theorem continuousAt_infty' {Y : Type*} [TopologicalSpace Y] {f : OnePoint X → Y} :\n    ContinuousAt f ∞ ↔ Tendsto (f ∘ (↑)) (coclosedCompact X) (𝓝 (f ∞)) :=\n  tendsto_nhds_infty'.trans <| and_iff_right (tendsto_pure_nhds _ _)\n\n"}
{"name":"OnePoint.continuousAt_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nY : Type u_3\ninst✝ : TopologicalSpace Y\nf : OnePoint X → Y\n⊢ Iff (ContinuousAt f OnePoint.infty) (∀ (s : Set Y), Membership.mem (nhds (f OnePoint.infty)) s → Exists fun t => And (IsClosed t) (And (IsCompact t) (Set.MapsTo (Function.comp f OnePoint.some) (HasCompl.compl t) s)))","decl":"theorem continuousAt_infty {Y : Type*} [TopologicalSpace Y] {f : OnePoint X → Y} :\n    ContinuousAt f ∞ ↔\n      ∀ s ∈ 𝓝 (f ∞), ∃ t : Set X, IsClosed t ∧ IsCompact t ∧ MapsTo (f ∘ (↑)) tᶜ s :=\n  continuousAt_infty'.trans <| by simp only [hasBasis_coclosedCompact.tendsto_left_iff, and_assoc]\n\n"}
{"name":"OnePoint.continuousAt_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nY : Type u_3\ninst✝ : TopologicalSpace Y\nf : OnePoint X → Y\nx : X\n⊢ Iff (ContinuousAt f ↑x) (ContinuousAt (Function.comp f OnePoint.some) x)","decl":"theorem continuousAt_coe {Y : Type*} [TopologicalSpace Y] {f : OnePoint X → Y} {x : X} :\n    ContinuousAt f x ↔ ContinuousAt (f ∘ (↑)) x := by\n  rw [ContinuousAt, nhds_coe_eq, tendsto_map'_iff, ContinuousAt]; rfl\n\n"}
{"name":"OnePoint.continuous_iff","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nY : Type u_3\ninst✝ : TopologicalSpace Y\nf : OnePoint X → Y\n⊢ Iff (Continuous f) (And (Filter.Tendsto (fun x => f ↑x) (Filter.coclosedCompact X) (nhds (f OnePoint.infty))) (Continuous fun x => f ↑x))","decl":"lemma continuous_iff {Y : Type*} [TopologicalSpace Y] (f : OnePoint X → Y) : Continuous f ↔\n    Tendsto (fun x : X ↦ f x) (coclosedCompact X) (𝓝 (f ∞)) ∧ Continuous (fun x : X ↦ f x) := by\n  simp only [continuous_iff_continuousAt, OnePoint.forall, continuousAt_coe, continuousAt_infty',\n    Function.comp_def]\n\n"}
{"name":"OnePoint.continuous_iff_from_discrete","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\nY : Type u_3\ninst✝¹ : TopologicalSpace Y\ninst✝ : DiscreteTopology X\nf : OnePoint X → Y\n⊢ Iff (Continuous f) (Filter.Tendsto (fun x => f ↑x) Filter.cofinite (nhds (f OnePoint.infty)))","decl":"lemma continuous_iff_from_discrete {Y : Type*} [TopologicalSpace Y]\n    [DiscreteTopology X] (f : OnePoint X → Y) :\n    Continuous f ↔ Tendsto (fun x : X ↦ f x) cofinite (𝓝 (f ∞)) := by\n  simp [continuous_iff, cocompact_eq_cofinite, continuous_of_discreteTopology]\n\n"}
{"name":"OnePoint.continuous_iff_from_nat","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"Y : Type u_3\ninst✝ : TopologicalSpace Y\nf : OnePoint Nat → Y\n⊢ Iff (Continuous f) (Filter.Tendsto (fun x => f ↑x) Filter.atTop (nhds (f OnePoint.infty)))","decl":"lemma continuous_iff_from_nat {Y : Type*} [TopologicalSpace Y] (f : OnePoint ℕ → Y) :\n    Continuous f ↔ Tendsto (fun x : ℕ ↦ f x) atTop (𝓝 (f ∞)) := by\n  rw [continuous_iff_from_discrete, Nat.cofinite_eq_atTop]\n\n"}
{"name":"OnePoint.denseRange_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : NoncompactSpace X\n⊢ DenseRange OnePoint.some","decl":"/-- If `X` is not a compact space, then the natural embedding `X → OnePoint X` has dense range.\n-/\ntheorem denseRange_coe [NoncompactSpace X] : DenseRange ((↑) : X → OnePoint X) := by\n  rw [DenseRange, ← compl_infty]\n  exact dense_compl_singleton _\n\n"}
{"name":"OnePoint.isDenseEmbedding_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : NoncompactSpace X\n⊢ IsDenseEmbedding OnePoint.some","decl":"theorem isDenseEmbedding_coe [NoncompactSpace X] : IsDenseEmbedding ((↑) : X → OnePoint X) :=\n  { isOpenEmbedding_coe with dense := denseRange_coe }\n\n"}
{"name":"OnePoint.denseEmbedding_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : NoncompactSpace X\n⊢ IsDenseEmbedding OnePoint.some","decl":"@[deprecated (since := \"2024-09-30\")]\nalias denseEmbedding_coe := isDenseEmbedding_coe\n\n"}
{"name":"OnePoint.specializes_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Specializes ↑x ↑y) (Specializes x y)","decl":"@[simp, norm_cast]\ntheorem specializes_coe {x y : X} : (x : OnePoint X) ⤳ y ↔ x ⤳ y :=\n  isOpenEmbedding_coe.isInducing.specializes_iff\n\n"}
{"name":"OnePoint.inseparable_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Inseparable ↑x ↑y) (Inseparable x y)","decl":"@[simp, norm_cast]\ntheorem inseparable_coe {x y : X} : Inseparable (x : OnePoint X) y ↔ Inseparable x y :=\n  isOpenEmbedding_coe.isInducing.inseparable_iff\n\n"}
{"name":"OnePoint.not_specializes_infty_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Not (Specializes OnePoint.infty ↑x)","decl":"theorem not_specializes_infty_coe {x : X} : ¬Specializes ∞ (x : OnePoint X) :=\n  isClosed_infty.not_specializes rfl (coe_ne_infty x)\n\n"}
{"name":"OnePoint.not_inseparable_infty_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Not (Inseparable OnePoint.infty ↑x)","decl":"theorem not_inseparable_infty_coe {x : X} : ¬Inseparable ∞ (x : OnePoint X) := fun h =>\n  not_specializes_infty_coe h.specializes\n\n"}
{"name":"OnePoint.not_inseparable_coe_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Not (Inseparable (↑x) OnePoint.infty)","decl":"theorem not_inseparable_coe_infty {x : X} : ¬Inseparable (x : OnePoint X) ∞ := fun h =>\n  not_specializes_infty_coe h.specializes'\n\n"}
{"name":"OnePoint.inseparable_iff","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : OnePoint X\n⊢ Iff (Inseparable x y) (Or (And (Eq x OnePoint.infty) (Eq y OnePoint.infty)) (Exists fun x' => And (Eq x ↑x') (Exists fun y' => And (Eq y ↑y') (Inseparable x' y'))))","decl":"theorem inseparable_iff {x y : OnePoint X} :\n    Inseparable x y ↔ x = ∞ ∧ y = ∞ ∨ ∃ x' : X, x = x' ∧ ∃ y' : X, y = y' ∧ Inseparable x' y' := by\n  induction x using OnePoint.rec <;> induction y using OnePoint.rec <;>\n    simp [not_inseparable_infty_coe, not_inseparable_coe_infty, coe_eq_coe, Inseparable.refl]\n\n"}
{"name":"OnePoint.continuous_map_iff","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\n⊢ Iff (Continuous (OnePoint.map f)) (And (Continuous f) (Filter.Tendsto f (Filter.coclosedCompact X) (Filter.coclosedCompact Y)))","decl":"theorem continuous_map_iff [TopologicalSpace Y] {f : X → Y} :\n    Continuous (OnePoint.map f) ↔\n      Continuous f ∧ Tendsto f (coclosedCompact X) (coclosedCompact Y) := by\n  simp_rw [continuous_iff, map_some, ← comap_coe_nhds_infty, tendsto_comap_iff, map_infty,\n    isOpenEmbedding_coe.isInducing.continuous_iff (Y := Y)]\n  exact and_comm\n\n"}
{"name":"OnePoint.continuous_map","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhc : Continuous f\nh : Filter.Tendsto f (Filter.coclosedCompact X) (Filter.coclosedCompact Y)\n⊢ Continuous (OnePoint.map f)","decl":"theorem continuous_map [TopologicalSpace Y] {f : X → Y} (hc : Continuous f)\n    (h : Tendsto f (coclosedCompact X) (coclosedCompact Y)) :\n    Continuous (OnePoint.map f) :=\n  continuous_map_iff.mpr ⟨hc, h⟩\n\n"}
{"name":"OnePoint.instCompactSpace","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ CompactSpace (OnePoint X)","decl":"/-- For any topological space `X`, its one point compactification is a compact space. -/\ninstance : CompactSpace (OnePoint X) where\n  isCompact_univ := by\n    have : Tendsto ((↑) : X → OnePoint X) (cocompact X) (𝓝 ∞) := by\n      rw [nhds_infty_eq]\n      exact (tendsto_map.mono_left cocompact_le_coclosedCompact).mono_right le_sup_left\n    rw [← insert_none_range_some X]\n    exact this.isCompact_insert_range_of_cocompact continuous_coe\n\n"}
{"name":"OnePoint.instT0Space","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T0Space X\n⊢ T0Space (OnePoint X)","decl":"/-- The one point compactification of a `T0Space` space is a `T0Space`. -/\ninstance [T0Space X] : T0Space (OnePoint X) := by\n  refine ⟨fun x y hxy => ?_⟩\n  rcases inseparable_iff.1 hxy with (⟨rfl, rfl⟩ | ⟨x, rfl, y, rfl, h⟩)\n  exacts [rfl, congr_arg some h.eq]\n\n"}
{"name":"OnePoint.instT1Space","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T1Space X\n⊢ T1Space (OnePoint X)","decl":"/-- The one point compactification of a `T1Space` space is a `T1Space`. -/\ninstance [T1Space X] : T1Space (OnePoint X) where\n  t1 z := by\n    induction z using OnePoint.rec\n    · exact isClosed_infty\n    · rw [← image_singleton, isClosed_image_coe]\n      exact ⟨isClosed_singleton, isCompact_singleton⟩\n\n"}
{"name":"OnePoint.instNormalSpaceOfLocallyCompactSpaceOfR1Space","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : LocallyCompactSpace X\ninst✝ : R1Space X\n⊢ NormalSpace (OnePoint X)","decl":"/-- The one point compactification of a locally compact R₁ space is a normal topological space. -/\ninstance [LocallyCompactSpace X] [R1Space X] : NormalSpace (OnePoint X) := by\n  suffices R1Space (OnePoint X) by infer_instance\n  have key : ∀ z : X, Disjoint (𝓝 (some z)) (𝓝 ∞) := fun z ↦ by\n    rw [nhds_infty_eq, disjoint_sup_right, nhds_coe_eq, coclosedCompact_eq_cocompact,\n      disjoint_map coe_injective, ← principal_singleton, disjoint_principal_right, compl_infty]\n    exact ⟨disjoint_nhds_cocompact z, range_mem_map⟩\n  refine ⟨fun x y ↦ ?_⟩\n  induction x using OnePoint.rec <;> induction y using OnePoint.rec\n  · exact .inl le_rfl\n  · exact .inr (key _).symm\n  · exact .inr (key _)\n  · rw [nhds_coe_eq, nhds_coe_eq, disjoint_map coe_injective, specializes_coe]\n    apply specializes_or_disjoint_nhds\n\n"}
{"name":"OnePoint.instConnectedSpaceOfPreconnectedSpaceOfNoncompactSpace","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : PreconnectedSpace X\ninst✝ : NoncompactSpace X\n⊢ ConnectedSpace (OnePoint X)","decl":"/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ninstance [PreconnectedSpace X] [NoncompactSpace X] : ConnectedSpace (OnePoint X) where\n  toPreconnectedSpace := isDenseEmbedding_coe.isDenseInducing.preconnectedSpace\n  toNonempty := inferInstance\n\n"}
{"name":"OnePoint.not_continuous_cofiniteTopology_of_symm","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : Infinite X\ninst✝ : DiscreteTopology X\n⊢ Not (Continuous ⇑CofiniteTopology.of.symm)","decl":"/-- If `X` is an infinite type with discrete topology (e.g., `ℕ`), then the identity map from\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. -/\ntheorem not_continuous_cofiniteTopology_of_symm [Infinite X] [DiscreteTopology X] :\n    ¬Continuous (@CofiniteTopology.of (OnePoint X)).symm := by\n  inhabit X\n  simp only [continuous_iff_continuousAt, ContinuousAt, not_forall]\n  use CofiniteTopology.of ↑(default : X)\n  simpa [nhds_coe_eq, nhds_discrete, CofiniteTopology.nhds_eq] using\n    (finite_singleton ((default : X) : OnePoint X)).infinite_compl\n\n"}
{"name":"OnePoint.instTotallySeparatedSpaceOfDiscreteTopology","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_3\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ TotallySeparatedSpace (OnePoint X)","decl":"instance (X : Type*) [TopologicalSpace X] [DiscreteTopology X] :\n    TotallySeparatedSpace (OnePoint X) where\n  isTotallySeparated_univ x _ y _ hxy := by\n    cases x with\n    | infty =>\n      refine ⟨{y}ᶜ, {y}, isOpen_compl_singleton, ?_, hxy, rfl, (compl_union_self _).symm.subset,\n        disjoint_compl_left⟩\n      rw [OnePoint.isOpen_iff_of_not_mem]\n      exacts [isOpen_discrete _, hxy]\n    | coe val =>\n      refine ⟨{some val}, {some val}ᶜ, ?_, isOpen_compl_singleton, rfl, hxy.symm, by simp,\n        disjoint_compl_right⟩\n      rw [OnePoint.isOpen_iff_of_not_mem]\n      exacts [isOpen_discrete _, (Option.some_ne_none val).symm]\n\n"}
{"name":"OnePoint.equivOfIsEmbeddingOfRangeEq_apply_coe","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : T2Space Y\ninst✝ : CompactSpace Y\nf : X → Y\nx : X\n⊢ Eq (sorryAx (Unit → Y) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 611).num 4).num 611).num 43).num 4).num 43).str \"_sorry\").str \"_@\").str \"_hyg\").num 4561))) (f x)","decl":"@[simp]\nlemma equivOfIsEmbeddingOfRangeEq_apply_coe (x : X) :\n    equivOfIsEmbeddingOfRangeEq y f hf hy x = f x :=\n  rfl\n\n"}
{"name":"OnePoint.equivOfIsEmbeddingOfRangeEq_apply_infty","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"Y : Type u_2\ninst✝² : TopologicalSpace Y\ninst✝¹ : T2Space Y\ninst✝ : CompactSpace Y\ny : Y\n⊢ Eq (sorryAx (Unit → Y) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 616).num 4).num 616).num 43).num 4).num 43).str \"_sorry\").str \"_@\").str \"_hyg\").num 4649))) y","decl":"@[simp]\nlemma equivOfIsEmbeddingOfRangeEq_apply_infty :\n    equivOfIsEmbeddingOfRangeEq y f hf hy ∞ = y :=\n  rfl\n\n"}
{"name":"Homeomorph.onePointCongr_symm_apply","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nh : Homeomorph X Y\na✝ : OnePoint Y\n⊢ Eq (h.onePointCongr.symm a✝) (OnePoint.map (⇑h.symm) a✝)","decl":"/-- Extend a homeomorphism of topological spaces\nto the homeomorphism of their one point compactifications. -/\n@[simps]\ndef onePointCongr (h : X ≃ₜ Y) : OnePoint X ≃ₜ OnePoint Y where\n  __ := h.toEquiv.optionCongr\n  toFun := OnePoint.map h\n  invFun := OnePoint.map h.symm\n  continuous_toFun := continuous_map (map_continuous h) h.map_coclosedCompact.le\n  continuous_invFun := continuous_map (map_continuous h.symm) h.symm.map_coclosedCompact.le\n\n"}
{"name":"Homeomorph.onePointCongr_apply","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nh : Homeomorph X Y\na✝ : OnePoint X\n⊢ Eq (h.onePointCongr a✝) (OnePoint.map (⇑h) a✝)","decl":"/-- Extend a homeomorphism of topological spaces\nto the homeomorphism of their one point compactifications. -/\n@[simps]\ndef onePointCongr (h : X ≃ₜ Y) : OnePoint X ≃ₜ OnePoint Y where\n  __ := h.toEquiv.optionCongr\n  toFun := OnePoint.map h\n  invFun := OnePoint.map h.symm\n  continuous_toFun := continuous_map (map_continuous h) h.map_coclosedCompact.le\n  continuous_invFun := continuous_map (map_continuous h.symm) h.symm.map_coclosedCompact.le\n\n"}
{"name":"Continuous.homeoOfEquivCompactToT2.t1_counterexample","module":"Mathlib.Topology.Compactification.OnePoint","initialProofState":"⊢ Exists fun α => Exists fun β => Exists fun x => Exists fun x_1 => And (CompactSpace α) (And (T1Space β) (Exists fun f => And (Continuous ⇑f) (Not (Continuous ⇑f.symm))))","decl":"/-- A concrete counterexample shows that `Continuous.homeoOfEquivCompactToT2`\ncannot be generalized from `T2Space` to `T1Space`.\n\nLet `α = OnePoint ℕ` be the one-point compactification of `ℕ`, and let `β` be the same space\n`OnePoint ℕ` with the cofinite topology.  Then `α` is compact, `β` is T1, and the identity map\n`id : α → β` is a continuous equivalence that is not a homeomorphism.\n-/\ntheorem Continuous.homeoOfEquivCompactToT2.t1_counterexample :\n    ∃ (α β : Type) (_ : TopologicalSpace α) (_ : TopologicalSpace β),\n      CompactSpace α ∧ T1Space β ∧ ∃ f : α ≃ β, Continuous f ∧ ¬Continuous f.symm :=\n  ⟨OnePoint ℕ, CofiniteTopology (OnePoint ℕ), inferInstance, inferInstance, inferInstance,\n    inferInstance, CofiniteTopology.of, CofiniteTopology.continuous_of,\n    OnePoint.not_continuous_cofiniteTopology_of_symm⟩\n"}
