{"name":"Nat.Partrec.merge'","module":"Mathlib.Computability.Halting","initialProofState":"f g : PFun Nat Nat\nhf : Nat.Partrec f\nhg : Nat.Partrec g\n⊢ Exists fun h => And (Nat.Partrec h) (∀ (a : Nat), And (∀ (x : Nat), Membership.mem (h a) x → Or (Membership.mem (f a) x) (Membership.mem (g a) x)) (Iff (h a).Dom (Or (f a).Dom (g a).Dom)))","decl":"theorem merge' {f g} (hf : Nat.Partrec f) (hg : Nat.Partrec g) :\n    ∃ h, Nat.Partrec h ∧\n      ∀ a, (∀ x ∈ h a, x ∈ f a ∨ x ∈ g a) ∧ ((h a).Dom ↔ (f a).Dom ∨ (g a).Dom) := by\n  obtain ⟨cf, rfl⟩ := Code.exists_code.1 hf\n  obtain ⟨cg, rfl⟩ := Code.exists_code.1 hg\n  have : Nat.Partrec fun n => Nat.rfindOpt fun k => cf.evaln k n <|> cg.evaln k n :=\n    Partrec.nat_iff.1\n      (Partrec.rfindOpt <|\n        Primrec.option_orElse.to_comp.comp\n          (Code.evaln_prim.to_comp.comp <| (snd.pair (const cf)).pair fst)\n          (Code.evaln_prim.to_comp.comp <| (snd.pair (const cg)).pair fst))\n  refine ⟨_, this, fun n => ?_⟩\n  have : ∀ x ∈ rfindOpt fun k ↦ HOrElse.hOrElse (Code.evaln k cf n) fun _x ↦ Code.evaln k cg n,\n      x ∈ Code.eval cf n ∨ x ∈ Code.eval cg n := by\n    intro x h\n    obtain ⟨k, e⟩ := Nat.rfindOpt_spec h\n    revert e\n    simp only [Option.mem_def]\n    cases' e' : cf.evaln k n with y <;> simp <;> intro e\n    · exact Or.inr (Code.evaln_sound e)\n    · subst y\n      exact Or.inl (Code.evaln_sound e')\n  refine ⟨this, ⟨fun h => (this _ ⟨h, rfl⟩).imp Exists.fst Exists.fst, ?_⟩⟩\n  intro h\n  rw [Nat.rfindOpt_dom]\n  simp only [dom_iff_mem, Code.evaln_complete, Option.mem_def] at h\n  obtain ⟨x, k, e⟩ | ⟨x, k, e⟩ := h\n  · refine ⟨k, x, ?_⟩\n    simp only [e, Option.some_orElse, Option.mem_def]\n  · refine ⟨k, ?_⟩\n    cases' cf.evaln k n with y\n    · exact ⟨x, by simp only [e, Option.mem_def, Option.none_orElse]⟩\n    · exact ⟨y, by simp only [Option.some_orElse, Option.mem_def]⟩\n\n"}
{"name":"Partrec.merge'","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf g : PFun α σ\nhf : Partrec f\nhg : Partrec g\n⊢ Exists fun k => And (Partrec k) (∀ (a : α), And (∀ (x : σ), Membership.mem (k a) x → Or (Membership.mem (f a) x) (Membership.mem (g a) x)) (Iff (k a).Dom (Or (f a).Dom (g a).Dom)))","decl":"theorem merge' {f g : α →. σ} (hf : Partrec f) (hg : Partrec g) :\n    ∃ k : α →. σ,\n      Partrec k ∧ ∀ a, (∀ x ∈ k a, x ∈ f a ∨ x ∈ g a) ∧ ((k a).Dom ↔ (f a).Dom ∨ (g a).Dom) := by\n  let ⟨k, hk, H⟩ := Nat.Partrec.merge' (bind_decode₂_iff.1 hf) (bind_decode₂_iff.1 hg)\n  let k' (a : α) := (k (encode a)).bind fun n => (decode (α := σ) n : Part σ)\n  refine\n    ⟨k', ((nat_iff.2 hk).comp Computable.encode).bind (Computable.decode.ofOption.comp snd).to₂,\n      fun a => ?_⟩\n  have : ∀ x ∈ k' a, x ∈ f a ∨ x ∈ g a := by\n    intro x h'\n    simp only [k', exists_prop, mem_coe, mem_bind_iff, Option.mem_def] at h'\n    obtain ⟨n, hn, hx⟩ := h'\n    have := (H _).1 _ hn\n    simp only [decode₂_encode, coe_some, bind_some, mem_map_iff] at this\n    obtain ⟨a', ha, rfl⟩ | ⟨a', ha, rfl⟩ := this <;> simp only [encodek, Option.some_inj] at hx <;>\n      rw [hx] at ha\n    · exact Or.inl ha\n    · exact Or.inr ha\n  refine ⟨this, ⟨fun h => (this _ ⟨h, rfl⟩).imp Exists.fst Exists.fst, ?_⟩⟩\n  intro h\n  rw [bind_dom]\n  have hk : (k (encode a)).Dom :=\n    (H _).2.2 (by simpa only [encodek₂, bind_some, coe_some] using h)\n  exists hk\n  simp only [exists_prop, mem_map_iff, mem_coe, mem_bind_iff, Option.mem_def] at H\n  obtain ⟨a', _, y, _, e⟩ | ⟨a', _, y, _, e⟩ := (H _).1 _ ⟨hk, rfl⟩ <;>\n    simp only [e.symm, encodek, coe_some, some_dom]\n\n"}
{"name":"Partrec.merge","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nf g : PFun α σ\nhf : Partrec f\nhg : Partrec g\nH : ∀ (a : α) (x : σ), Membership.mem (f a) x → ∀ (y : σ), Membership.mem (g a) y → Eq x y\n⊢ Exists fun k => And (Partrec k) (∀ (a : α) (x : σ), Iff (Membership.mem (k a) x) (Or (Membership.mem (f a) x) (Membership.mem (g a) x)))","decl":"theorem merge {f g : α →. σ} (hf : Partrec f) (hg : Partrec g)\n    (H : ∀ (a), ∀ x ∈ f a, ∀ y ∈ g a, x = y) :\n    ∃ k : α →. σ, Partrec k ∧ ∀ a x, x ∈ k a ↔ x ∈ f a ∨ x ∈ g a :=\n  let ⟨k, hk, K⟩ := merge' hf hg\n  ⟨k, hk, fun a x =>\n    ⟨(K _).1 _, fun h => by\n      have : (k a).Dom := (K _).2.2 (h.imp Exists.fst Exists.fst)\n      refine ⟨this, ?_⟩\n      cases' h with h h <;> cases' (K _).1 _ ⟨this, rfl⟩ with h' h'\n      · exact mem_unique h' h\n      · exact (H _ _ h _ h').symm\n      · exact H _ _ h' _ h\n      · exact mem_unique h' h⟩⟩\n\n"}
{"name":"Partrec.cond","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\nσ : Type u_4\ninst✝¹ : Primcodable α\ninst✝ : Primcodable σ\nc : α → Bool\nf g : PFun α σ\nhc : Computable c\nhf : Partrec f\nhg : Partrec g\n⊢ Partrec fun a => cond (c a) (f a) (g a)","decl":"theorem cond {c : α → Bool} {f : α →. σ} {g : α →. σ} (hc : Computable c) (hf : Partrec f)\n    (hg : Partrec g) : Partrec fun a => cond (c a) (f a) (g a) :=\n  let ⟨cf, ef⟩ := exists_code.1 hf\n  let ⟨cg, eg⟩ := exists_code.1 hg\n  ((eval_part.comp (Computable.cond hc (const cf) (const cg)) Computable.encode).bind\n    ((@Computable.decode σ _).comp snd).ofOption.to₂).of_eq\n    fun a => by cases c a <;> simp [ef, eg, encodek]\n\n"}
{"name":"Partrec.sum_casesOn","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nσ : Type u_4\ninst✝³ : Primcodable α\ninst✝² : Primcodable β\ninst✝¹ : Primcodable γ\ninst✝ : Primcodable σ\nf : α → Sum β γ\ng : α → PFun β σ\nh : α → PFun γ σ\nhf : Computable f\nhg : Partrec₂ g\nhh : Partrec₂ h\n⊢ Partrec fun a => Sum.casesOn (f a) (g a) (h a)","decl":"nonrec theorem sum_casesOn {f : α → β ⊕ γ} {g : α → β →. σ} {h : α → γ →. σ} (hf : Computable f)\n    (hg : Partrec₂ g) (hh : Partrec₂ h) : @Partrec _ σ _ _ fun a => Sum.casesOn (f a) (g a) (h a) :=\n  option_some_iff.1 <|\n    (cond (sum_casesOn hf (const true).to₂ (const false).to₂)\n          (sum_casesOn_left hf (option_some_iff.2 hg).to₂ (const Option.none).to₂)\n          (sum_casesOn_right hf (const Option.none).to₂ (option_some_iff.2 hh).to₂)).of_eq\n      fun a => by cases f a <;> simp only [Bool.cond_true, Bool.cond_false]\n\n"}
{"name":"RePred.of_eq","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\np q : α → Prop\nhp : RePred p\nH : ∀ (a : α), Iff (p a) (q a)\n⊢ RePred q","decl":"theorem RePred.of_eq {α} [Primcodable α] {p q : α → Prop} (hp : RePred p) (H : ∀ a, p a ↔ q a) :\n    RePred q :=\n  (funext fun a => propext (H a) : p = q) ▸ hp\n\n"}
{"name":"Partrec.dom_re","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Primcodable α\ninst✝ : Primcodable β\nf : PFun α β\nh : Partrec f\n⊢ RePred fun a => (f a).Dom","decl":"theorem Partrec.dom_re {α β} [Primcodable α] [Primcodable β] {f : α →. β} (h : Partrec f) :\n    RePred fun a => (f a).Dom :=\n  (h.map (Computable.const ()).to₂).of_eq fun n => Part.ext fun _ => by simp [Part.dom_iff_mem]\n\n"}
{"name":"ComputablePred.of_eq","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\np q : α → Prop\nhp : ComputablePred p\nH : ∀ (a : α), Iff (p a) (q a)\n⊢ ComputablePred q","decl":"theorem ComputablePred.of_eq {α} [Primcodable α] {p q : α → Prop} (hp : ComputablePred p)\n    (H : ∀ a, p a ↔ q a) : ComputablePred q :=\n  (funext fun a => propext (H a) : p = q) ▸ hp\n\n"}
{"name":"ComputablePred.computable_iff","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\np : α → Prop\n⊢ Iff (ComputablePred p) (Exists fun f => And (Computable f) (Eq p fun a => Eq (f a) Bool.true))","decl":"theorem computable_iff {p : α → Prop} :\n    ComputablePred p ↔ ∃ f : α → Bool, Computable f ∧ p = fun a => (f a : Prop) :=\n  ⟨fun ⟨_, h⟩ => ⟨_, h, funext fun _ => propext (Bool.decide_iff _).symm⟩, by\n    rintro ⟨f, h, rfl⟩; exact ⟨by infer_instance, by simpa using h⟩⟩\n\n"}
{"name":"ComputablePred.not","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\np : α → Prop\nhp : ComputablePred p\n⊢ ComputablePred fun a => Not (p a)","decl":"protected theorem not {p : α → Prop} (hp : ComputablePred p) : ComputablePred fun a => ¬p a := by\n  obtain ⟨f, hf, rfl⟩ := computable_iff.1 hp\n  exact\n    ⟨by infer_instance,\n      (cond hf (const false) (const true)).of_eq fun n => by\n        simp only [Bool.not_eq_true]\n        cases f n <;> rfl⟩\n\n"}
{"name":"ComputablePred.ite","module":"Mathlib.Computability.Halting","initialProofState":"f₁ f₂ : Nat → Nat\nhf₁ : Computable f₁\nhf₂ : Computable f₂\nc : Nat → Prop\ninst✝ : DecidablePred c\nhc : ComputablePred c\n⊢ Computable fun k => ite (c k) (f₁ k) (f₂ k)","decl":"/-- The computable functions are closed under if-then-else definitions\nwith computable predicates. -/\ntheorem ite {f₁ f₂ : ℕ → ℕ} (hf₁ : Computable f₁) (hf₂ : Computable f₂)\n    {c : ℕ → Prop} [DecidablePred c] (hc : ComputablePred c) :\n    Computable fun k ↦ if c k then f₁ k else f₂ k := by\n  simp_rw [← Bool.cond_decide]\n  obtain ⟨inst, hc⟩ := hc\n  convert hc.cond hf₁ hf₂\n\n"}
{"name":"ComputablePred.to_re","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\np : α → Prop\nhp : ComputablePred p\n⊢ RePred p","decl":"theorem to_re {p : α → Prop} (hp : ComputablePred p) : RePred p := by\n  obtain ⟨f, hf, rfl⟩ := computable_iff.1 hp\n  unfold RePred\n  dsimp only []\n  refine\n    (Partrec.cond hf (Decidable.Partrec.const' (Part.some ())) Partrec.none).of_eq fun n =>\n      Part.ext fun a => ?_\n  cases a; cases f n <;> simp\n\n"}
{"name":"ComputablePred.rice","module":"Mathlib.Computability.Halting","initialProofState":"C : Set (PFun Nat Nat)\nh : ComputablePred fun c => Membership.mem C c.eval\nf g : PFun Nat Nat\nhf : Nat.Partrec f\nhg : Nat.Partrec g\nfC : Membership.mem C f\n⊢ Membership.mem C g","decl":"/-- **Rice's Theorem** -/\ntheorem rice (C : Set (ℕ →. ℕ)) (h : ComputablePred fun c => eval c ∈ C) {f g} (hf : Nat.Partrec f)\n    (hg : Nat.Partrec g) (fC : f ∈ C) : g ∈ C := by\n  cases' h with _ h\n  obtain ⟨c, e⟩ :=\n    fixed_point₂\n      (Partrec.cond (h.comp fst) ((Partrec.nat_iff.2 hg).comp snd).to₂\n          ((Partrec.nat_iff.2 hf).comp snd).to₂).to₂\n  simp only [Bool.cond_decide] at e\n  by_cases H : eval c ∈ C\n  · simp only [H, if_true] at e\n    change (fun b => g b) ∈ C\n    rwa [← e]\n  · simp only [H, if_false] at e\n    rw [e] at H\n    contradiction\n\n"}
{"name":"ComputablePred.rice₂","module":"Mathlib.Computability.Halting","initialProofState":"C : Set Nat.Partrec.Code\nH : ∀ (cf cg : Nat.Partrec.Code), Eq cf.eval cg.eval → Iff (Membership.mem C cf) (Membership.mem C cg)\n⊢ Iff (ComputablePred fun c => Membership.mem C c) (Or (Eq C EmptyCollection.emptyCollection) (Eq C Set.univ))","decl":"theorem rice₂ (C : Set Code) (H : ∀ cf cg, eval cf = eval cg → (cf ∈ C ↔ cg ∈ C)) :\n    (ComputablePred fun c => c ∈ C) ↔ C = ∅ ∨ C = Set.univ := by\n  classical exact\n      have hC : ∀ f, f ∈ C ↔ eval f ∈ eval '' C := fun f =>\n        ⟨Set.mem_image_of_mem _, fun ⟨g, hg, e⟩ => (H _ _ e).1 hg⟩\n      ⟨fun h =>\n        or_iff_not_imp_left.2 fun C0 =>\n          Set.eq_univ_of_forall fun cg =>\n            let ⟨cf, fC⟩ := Set.nonempty_iff_ne_empty.2 C0\n            (hC _).2 <|\n              rice (eval '' C) (h.of_eq hC)\n                (Partrec.nat_iff.1 <| eval_part.comp (const cf) Computable.id)\n                (Partrec.nat_iff.1 <| eval_part.comp (const cg) Computable.id) ((hC _).1 fC),\n        fun h => by {\n          obtain rfl | rfl := h <;> simpa [ComputablePred, Set.mem_empty_iff_false] using\n            Computable.const _}⟩\n\n"}
{"name":"ComputablePred.halting_problem_re","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\n⊢ RePred fun c => (c.eval n).Dom","decl":"/-- The Halting problem is recursively enumerable -/\ntheorem halting_problem_re (n) : RePred fun c => (eval c n).Dom :=\n  (eval_part.comp Computable.id (Computable.const _)).dom_re\n\n"}
{"name":"ComputablePred.halting_problem","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\n⊢ Not (ComputablePred fun c => (c.eval n).Dom)","decl":"/-- The **Halting problem** is not computable -/\ntheorem halting_problem (n) : ¬ComputablePred fun c => (eval c n).Dom\n  | h => rice { f | (f n).Dom } h Nat.Partrec.zero Nat.Partrec.none trivial\n\n-- Post's theorem on the equivalence of r.e., co-r.e. sets and\n-- computable sets. The assumption that p is decidable is required\n-- unless we assume Markov's principle or LEM.\n-- @[nolint decidable_classical]\n"}
{"name":"ComputablePred.computable_iff_re_compl_re","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\ninst✝¹ : Primcodable α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Iff (ComputablePred p) (And (RePred p) (RePred fun a => Not (p a)))","decl":"theorem computable_iff_re_compl_re {p : α → Prop} [DecidablePred p] :\n    ComputablePred p ↔ RePred p ∧ RePred fun a => ¬p a :=\n  ⟨fun h => ⟨h.to_re, h.not.to_re⟩, fun ⟨h₁, h₂⟩ =>\n    ⟨‹_›, by\n      obtain ⟨k, pk, hk⟩ :=\n        Partrec.merge (h₁.map (Computable.const true).to₂) (h₂.map (Computable.const false).to₂)\n        (by\n          intro a x hx y hy\n          simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop,\n            and_true, exists_const] at hx hy\n          cases hy.1 hx.1)\n      refine Partrec.of_eq pk fun n => Part.eq_some_iff.2 ?_\n      rw [hk]\n      simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop, and_true,\n        true_eq_decide_iff, and_self, exists_const, false_eq_decide_iff]\n      apply Decidable.em⟩⟩\n\n"}
{"name":"ComputablePred.computable_iff_re_compl_re'","module":"Mathlib.Computability.Halting","initialProofState":"α : Type u_1\ninst✝ : Primcodable α\np : α → Prop\n⊢ Iff (ComputablePred p) (And (RePred p) (RePred fun a => Not (p a)))","decl":"theorem computable_iff_re_compl_re' {p : α → Prop} :\n    ComputablePred p ↔ RePred p ∧ RePred fun a => ¬p a := by\n  classical exact computable_iff_re_compl_re\n\n"}
{"name":"ComputablePred.halting_problem_not_re","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\n⊢ Not (RePred fun c => Not (c.eval n).Dom)","decl":"theorem halting_problem_not_re (n) : ¬RePred fun c => ¬(eval c n).Dom\n  | h => halting_problem _ <| computable_iff_re_compl_re'.2 ⟨halting_problem_re _, h⟩\n\n"}
{"name":"Nat.Partrec'.brecOn","module":"Mathlib.Computability.Halting","initialProofState":"motive✝ : {n : Nat} → (a : PFun (List.Vector Nat n) Nat) → Nat.Partrec' a → Prop\nn : Nat\na✝ : PFun (List.Vector Nat n) Nat\nx✝ : Nat.Partrec' a✝\nih✝ : ∀ {n : Nat} (a : PFun (List.Vector Nat n) Nat) (x : Nat.Partrec' a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- A simplified basis for `Partrec`. -/\ninductive Partrec' : ∀ {n}, (List.Vector ℕ n →. ℕ) → Prop\n  | prim {n f} : @Primrec' n f → @Partrec' n f\n  | comp {m n f} (g : Fin n → List.Vector ℕ m →. ℕ) :\n    Partrec' f → (∀ i, Partrec' (g i)) →\n      Partrec' fun v => (List.Vector.mOfFn fun i => g i v) >>= f\n  | rfind {n} {f : List.Vector ℕ (n + 1) → ℕ} :\n    @Partrec' (n + 1) f → Partrec' fun v => rfind fun n => some (f (n ::ᵥ v) = 0)\n\n"}
{"name":"Nat.Partrec'.to_part","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf : PFun (List.Vector Nat n) Nat\npf : Nat.Partrec' f\n⊢ Partrec f","decl":"theorem to_part {n f} (pf : @Partrec' n f) : _root_.Partrec f := by\n  induction pf with\n  | prim hf => exact hf.to_prim.to_comp\n  | comp _ _ _ hf hg => exact (Partrec.vector_mOfFn hg).bind (hf.comp snd)\n  | rfind _ hf =>\n    have := hf.comp (vector_cons.comp snd fst)\n    have :=\n      ((Primrec.eq.comp _root_.Primrec.id (_root_.Primrec.const 0)).to_comp.comp\n        this).to₂.partrec₂\n    exact _root_.Partrec.rfind this\n\n"}
{"name":"Nat.Partrec'.of_eq","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf g : PFun (List.Vector Nat n) Nat\nhf : Nat.Partrec' f\nH : ∀ (i : List.Vector Nat n), Eq (f i) (g i)\n⊢ Nat.Partrec' g","decl":"theorem of_eq {n} {f g : List.Vector ℕ n →. ℕ} (hf : Partrec' f) (H : ∀ i, f i = g i) :\n    Partrec' g :=\n  (funext H : f = g) ▸ hf\n\n"}
{"name":"Nat.Partrec'.of_prim","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf : List.Vector Nat n → Nat\nhf : Primrec f\n⊢ Nat.Partrec' ↑f","decl":"theorem of_prim {n} {f : List.Vector ℕ n → ℕ} (hf : Primrec f) : @Partrec' n f :=\n  prim (Nat.Primrec'.of_prim hf)\n\n"}
{"name":"Nat.Partrec'.head","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\n⊢ Nat.Partrec' ↑List.Vector.head","decl":"theorem head {n : ℕ} : @Partrec' n.succ (@head ℕ n) :=\n  prim Nat.Primrec'.head\n\n"}
{"name":"Nat.Partrec'.tail","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf : PFun (List.Vector Nat n) Nat\nhf : Nat.Partrec' f\n⊢ Nat.Partrec' fun v => f v.tail","decl":"theorem tail {n f} (hf : @Partrec' n f) : @Partrec' n.succ fun v => f v.tail :=\n  (hf.comp _ fun i => @prim _ _ <| Nat.Primrec'.get i.succ).of_eq fun v => by\n    simp; rw [← ofFn_get v.tail]; congr; funext i; simp\n\n"}
{"name":"Nat.Partrec'.bind","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf : PFun (List.Vector Nat n) Nat\ng : PFun (List.Vector Nat (HAdd.hAdd n 1)) Nat\nhf : Nat.Partrec' f\nhg : Nat.Partrec' g\n⊢ Nat.Partrec' fun v => (f v).bind fun a => g (List.Vector.cons a v)","decl":"protected theorem bind {n f g} (hf : @Partrec' n f) (hg : @Partrec' (n + 1) g) :\n    @Partrec' n fun v => (f v).bind fun a => g (a ::ᵥ v) :=\n  (@comp n (n + 1) g (fun i => Fin.cases f (fun i v => some (v.get i)) i) hg fun i => by\n      refine Fin.cases ?_ (fun i => ?_) i <;> simp [*]\n      exact prim (Nat.Primrec'.get _)).of_eq\n    fun v => by simp [mOfFn, Part.bind_assoc, pure]\n\n"}
{"name":"Nat.Partrec'.map","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf : PFun (List.Vector Nat n) Nat\ng : List.Vector Nat (HAdd.hAdd n 1) → Nat\nhf : Nat.Partrec' f\nhg : Nat.Partrec' ↑g\n⊢ Nat.Partrec' fun v => Part.map (fun a => g (List.Vector.cons a v)) (f v)","decl":"protected theorem map {n f} {g : List.Vector ℕ (n + 1) → ℕ} (hf : @Partrec' n f)\n    (hg : @Partrec' (n + 1) g) : @Partrec' n fun v => (f v).map fun a => g (a ::ᵥ v) := by\n  simpa [(Part.bind_some_eq_map _ _).symm] using hf.bind hg\n\n"}
{"name":"Nat.Partrec'.Vec.prim","module":"Mathlib.Computability.Halting","initialProofState":"n m : Nat\nf : List.Vector Nat n → List.Vector Nat m\nhf : Nat.Primrec'.Vec f\n⊢ Nat.Partrec'.Vec f","decl":"nonrec theorem Vec.prim {n m f} (hf : @Nat.Primrec'.Vec n m f) : Vec f := fun i => prim <| hf i\n\n"}
{"name":"Nat.Partrec'.nil","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\n⊢ Nat.Partrec'.Vec fun x => List.Vector.nil","decl":"protected theorem nil {n} : @Vec n 0 fun _ => nil := fun i => i.elim0\n\n"}
{"name":"Nat.Partrec'.cons","module":"Mathlib.Computability.Halting","initialProofState":"n m : Nat\nf : List.Vector Nat n → Nat\ng : List.Vector Nat n → List.Vector Nat m\nhf : Nat.Partrec' ↑f\nhg : Nat.Partrec'.Vec g\n⊢ Nat.Partrec'.Vec fun v => List.Vector.cons (f v) (g v)","decl":"protected theorem cons {n m} {f : List.Vector ℕ n → ℕ} {g} (hf : @Partrec' n f)\n    (hg : @Vec n m g) : Vec fun v => f v ::ᵥ g v := fun i =>\n  Fin.cases (by simpa using hf) (fun i => by simp only [hg i, get_cons_succ]) i\n\n"}
{"name":"Nat.Partrec'.idv","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\n⊢ Nat.Partrec'.Vec id","decl":"theorem idv {n} : @Vec n n id :=\n  Vec.prim Nat.Primrec'.idv\n\n"}
{"name":"Nat.Partrec'.comp'","module":"Mathlib.Computability.Halting","initialProofState":"n m : Nat\nf : PFun (List.Vector Nat m) Nat\ng : List.Vector Nat n → List.Vector Nat m\nhf : Nat.Partrec' f\nhg : Nat.Partrec'.Vec g\n⊢ Nat.Partrec' fun v => f (g v)","decl":"theorem comp' {n m f g} (hf : @Partrec' m f) (hg : @Vec n m g) : Partrec' fun v => f (g v) :=\n  (hf.comp _ hg).of_eq fun v => by simp\n\n"}
{"name":"Nat.Partrec'.comp₁","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf : PFun Nat Nat\ng : List.Vector Nat n → Nat\nhf : Nat.Partrec' fun v => f v.head\nhg : Nat.Partrec' ↑g\n⊢ Nat.Partrec' fun v => f (g v)","decl":"theorem comp₁ {n} (f : ℕ →. ℕ) {g : List.Vector ℕ n → ℕ} (hf : @Partrec' 1 fun v => f v.head)\n    (hg : @Partrec' n g) : @Partrec' n fun v => f (g v) := by\n  simpa using hf.comp' (Partrec'.cons hg Partrec'.nil)\n\n"}
{"name":"Nat.Partrec'.rfindOpt","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf : List.Vector Nat (HAdd.hAdd n 1) → Nat\nhf : Nat.Partrec' ↑f\n⊢ Nat.Partrec' fun v => Nat.rfindOpt fun a => Denumerable.ofNat (Option Nat) (f (List.Vector.cons a v))","decl":"theorem rfindOpt {n} {f : List.Vector ℕ (n + 1) → ℕ} (hf : @Partrec' (n + 1) f) :\n    @Partrec' n fun v => Nat.rfindOpt fun a => ofNat (Option ℕ) (f (a ::ᵥ v)) :=\n  ((rfind <|\n        (of_prim (Primrec.nat_sub.comp (_root_.Primrec.const 1) Primrec.vector_head)).comp₁\n          (fun n => Part.some (1 - n)) hf).bind\n    ((prim Nat.Primrec'.pred).comp₁ Nat.pred hf)).of_eq\n    fun v =>\n    Part.ext fun b => by\n      simp only [Nat.rfindOpt, exists_prop, Nat.sub_eq_zero_iff_le, PFun.coe_val, Part.mem_bind_iff,\n        Part.mem_some_iff, Option.mem_def, Part.mem_coe]\n      refine\n        exists_congr fun a => (and_congr (iff_of_eq ?_) Iff.rfl).trans (and_congr_right fun h => ?_)\n      · congr\n        funext n\n        cases f (n ::ᵥ v) <;> simp [Nat.succ_le_succ] <;> rfl\n      · have := Nat.rfind_spec h\n        simp only [Part.coe_some, Part.mem_some_iff] at this\n        revert this; cases' f (a ::ᵥ v) with c <;> intro this\n        · cases this\n        rw [← Option.some_inj, eq_comm]\n        rfl\n\n"}
{"name":"Nat.Partrec'.of_part","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf : PFun (List.Vector Nat n) Nat\na✝ : Partrec f\n⊢ Nat.Partrec' f","decl":"theorem of_part : ∀ {n f}, _root_.Partrec f → @Partrec' n f :=\n  @(suffices ∀ f, Nat.Partrec f → @Partrec' 1 fun v => f v.head from fun {n f} hf => by\n      let g := fun n₁ =>\n        (Part.ofOption (decode (α := List.Vector ℕ n) n₁)).bind (fun a => Part.map encode (f a))\n      exact\n        (comp₁ g (this g hf) (prim Nat.Primrec'.encode)).of_eq fun i => by\n          dsimp only [g]; simp [encodek, Part.map_id']\n    fun f hf => by\n    obtain ⟨c, rfl⟩ := exists_code.1 hf\n    simpa [eval_eq_rfindOpt] using\n      rfindOpt <|\n        of_prim <|\n          Primrec.encode_iff.2 <|\n            evaln_prim.comp <|\n              (Primrec.vector_head.pair (_root_.Primrec.const c)).pair <|\n                Primrec.vector_head.comp Primrec.vector_tail)\n\n"}
{"name":"Nat.Partrec'.part_iff","module":"Mathlib.Computability.Halting","initialProofState":"n : Nat\nf : PFun (List.Vector Nat n) Nat\n⊢ Iff (Nat.Partrec' f) (Partrec f)","decl":"theorem part_iff {n f} : @Partrec' n f ↔ _root_.Partrec f :=\n  ⟨to_part, of_part⟩\n\n"}
{"name":"Nat.Partrec'.part_iff₁","module":"Mathlib.Computability.Halting","initialProofState":"f : PFun Nat Nat\n⊢ Iff (Nat.Partrec' fun v => f v.head) (Partrec f)","decl":"theorem part_iff₁ {f : ℕ →. ℕ} : (@Partrec' 1 fun v => f v.head) ↔ _root_.Partrec f :=\n  part_iff.trans\n    ⟨fun h =>\n      (h.comp <| (Primrec.vector_ofFn fun _ => _root_.Primrec.id).to_comp).of_eq fun v => by\n        simp only [id, head_ofFn],\n      fun h => h.comp vector_head⟩\n\n"}
{"name":"Nat.Partrec'.part_iff₂","module":"Mathlib.Computability.Halting","initialProofState":"f : Nat → PFun Nat Nat\n⊢ Iff (Nat.Partrec' fun v => f v.head v.tail.head) (Partrec₂ f)","decl":"theorem part_iff₂ {f : ℕ → ℕ →. ℕ} : (@Partrec' 2 fun v => f v.head v.tail.head) ↔ Partrec₂ f :=\n  part_iff.trans\n    ⟨fun h =>\n      (h.comp <| vector_cons.comp fst <| vector_cons.comp snd (const nil)).of_eq fun v => by\n        simp only [head_cons, tail_cons],\n      fun h => h.comp vector_head (vector_head.comp vector_tail)⟩\n\n"}
{"name":"Nat.Partrec'.vec_iff","module":"Mathlib.Computability.Halting","initialProofState":"m n : Nat\nf : List.Vector Nat m → List.Vector Nat n\n⊢ Iff (Nat.Partrec'.Vec f) (Computable f)","decl":"theorem vec_iff {m n f} : @Vec m n f ↔ Computable f :=\n  ⟨fun h => by simpa only [ofFn_get] using vector_ofFn fun i => to_part (h i), fun h i =>\n    of_part <| vector_get.comp h (const i)⟩\n\n"}
