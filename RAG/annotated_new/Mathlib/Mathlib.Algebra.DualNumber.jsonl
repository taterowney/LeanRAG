{"name":"DualNumber.fst_eps","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq (TrivSqZeroExt.fst DualNumber.eps) 0","decl":"@[simp]\ntheorem fst_eps [Zero R] [One R] : fst ε = (0 : R) :=\n  fst_inr _ _\n\n"}
{"name":"DualNumber.snd_eps","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq (TrivSqZeroExt.snd DualNumber.eps) 1","decl":"@[simp]\ntheorem snd_eps [Zero R] [One R] : snd ε = (1 : R) :=\n  snd_inr _ _\n\n"}
{"name":"DualNumber.snd_mul","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : DualNumber R\n⊢ Eq (TrivSqZeroExt.snd (HMul.hMul x y)) (HAdd.hAdd (HMul.hMul (TrivSqZeroExt.fst x) (TrivSqZeroExt.snd y)) (HMul.hMul (TrivSqZeroExt.snd x) (TrivSqZeroExt.fst y)))","decl":"/-- A version of `TrivSqZeroExt.snd_mul` with `*` instead of `•`. -/\n@[simp]\ntheorem snd_mul [Semiring R] (x y : R[ε]) : snd (x * y) = fst x * snd y + snd x * fst y :=\n  TrivSqZeroExt.snd_mul _ _\n\n"}
{"name":"DualNumber.eps_mul_eps","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (HMul.hMul DualNumber.eps DualNumber.eps) 0","decl":"@[simp]\ntheorem eps_mul_eps [Semiring R] : (ε * ε : R[ε]) = 0 :=\n  inr_mul_inr _ _ _\n\n"}
{"name":"DualNumber.inv_eps","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\ninst✝ : DivisionRing R\n⊢ Eq (Inv.inv DualNumber.eps) 0","decl":"@[simp]\ntheorem inv_eps [DivisionRing R] : (ε : R[ε])⁻¹ = 0 :=\n  TrivSqZeroExt.inv_inr 1\n\n"}
{"name":"DualNumber.inr_eq_smul_eps","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\ninst✝ : MulZeroOneClass R\nr : R\n⊢ Eq (TrivSqZeroExt.inr r) (HSMul.hSMul r DualNumber.eps)","decl":"@[simp]\ntheorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r • ε : R[ε]) :=\n  ext (mul_zero r).symm (mul_one r).symm\n\n"}
{"name":"DualNumber.commute_eps_left","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : DualNumber R\n⊢ Commute DualNumber.eps x","decl":"/-- `ε` commutes with every element of the algebra. -/\ntheorem commute_eps_left [Semiring R] (x : DualNumber R) : Commute ε x := by\n  ext <;> simp\n\n"}
{"name":"DualNumber.commute_eps_right","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : DualNumber R\n⊢ Commute x DualNumber.eps","decl":"/-- `ε` commutes with every element of the algebra. -/\ntheorem commute_eps_right [Semiring R] (x : DualNumber R) : Commute x ε := (commute_eps_left x).symm\n\n"}
{"name":"DualNumber.algHom_ext'_iff","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nB : Type u_3\nA : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf g : AlgHom R (DualNumber A) B\n⊢ Iff (Eq f g) (And (Eq (f.comp (TrivSqZeroExt.inlAlgHom R A A)) (g.comp (TrivSqZeroExt.inlAlgHom R A A))) (Eq (f.toLinearMap.comp (↑R (LinearMap.toSpanSingleton A (DualNumber A) DualNumber.eps))) (g.toLinearMap.comp (↑R (LinearMap.toSpanSingleton A (DualNumber A) DualNumber.eps)))))","decl":"/-- For two `R`-algebra morphisms out of `A[ε]` to agree, it suffices for them to agree on the\nelements of `A` and the `A`-multiples of `ε`. -/\n@[ext 1100]\nnonrec theorem algHom_ext' ⦃f g : A[ε] →ₐ[R] B⦄\n    (hinl : f.comp (inlAlgHom _ _ _) = g.comp (inlAlgHom _ _ _))\n    (hinr : f.toLinearMap ∘ₗ (LinearMap.toSpanSingleton A A[ε] ε).restrictScalars R =\n        g.toLinearMap ∘ₗ (LinearMap.toSpanSingleton A A[ε] ε).restrictScalars R) :\n      f = g :=\n  algHom_ext' hinl (by\n    ext a\n    show f (inr a) = g (inr a)\n    simpa only [inr_eq_smul_eps] using DFunLike.congr_fun hinr a)\n\n"}
{"name":"DualNumber.algHom_ext'","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nB : Type u_3\nA : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf g : AlgHom R (DualNumber A) B\nhinl : Eq (f.comp (TrivSqZeroExt.inlAlgHom R A A)) (g.comp (TrivSqZeroExt.inlAlgHom R A A))\nhinr : Eq (f.toLinearMap.comp (↑R (LinearMap.toSpanSingleton A (DualNumber A) DualNumber.eps))) (g.toLinearMap.comp (↑R (LinearMap.toSpanSingleton A (DualNumber A) DualNumber.eps)))\n⊢ Eq f g","decl":"/-- For two `R`-algebra morphisms out of `A[ε]` to agree, it suffices for them to agree on the\nelements of `A` and the `A`-multiples of `ε`. -/\n@[ext 1100]\nnonrec theorem algHom_ext' ⦃f g : A[ε] →ₐ[R] B⦄\n    (hinl : f.comp (inlAlgHom _ _ _) = g.comp (inlAlgHom _ _ _))\n    (hinr : f.toLinearMap ∘ₗ (LinearMap.toSpanSingleton A A[ε] ε).restrictScalars R =\n        g.toLinearMap ∘ₗ (LinearMap.toSpanSingleton A A[ε] ε).restrictScalars R) :\n      f = g :=\n  algHom_ext' hinl (by\n    ext a\n    show f (inr a) = g (inr a)\n    simpa only [inr_eq_smul_eps] using DFunLike.congr_fun hinr a)\n\n"}
{"name":"DualNumber.algHom_ext","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nA : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (DualNumber R) A\nhε : Eq (f DualNumber.eps) (g DualNumber.eps)\n⊢ Eq f g","decl":"/-- For two `R`-algebra morphisms out of `R[ε]` to agree, it suffices for them to agree on `ε`. -/\n@[ext 1200]\nnonrec theorem algHom_ext ⦃f g : R[ε] →ₐ[R] A⦄ (hε : f ε = g ε) : f = g := by\n  ext\n  dsimp\n  simp only [one_smul, hε]\n\n"}
{"name":"DualNumber.algHom_ext_iff","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nA : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (DualNumber R) A\n⊢ Iff (Eq f g) (Eq (f DualNumber.eps) (g DualNumber.eps))","decl":"/-- For two `R`-algebra morphisms out of `R[ε]` to agree, it suffices for them to agree on `ε`. -/\n@[ext 1200]\nnonrec theorem algHom_ext ⦃f g : R[ε] →ₐ[R] A⦄ (hε : f ε = g ε) : f = g := by\n  ext\n  dsimp\n  simp only [one_smul, hε]\n\n"}
{"name":"DualNumber.lift_apply_apply","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nB : Type u_3\nA : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nfe : Subtype fun _fe => And (Eq (HMul.hMul _fe.2 _fe.2) 0) (∀ (a : A), Commute _fe.2 (_fe.1 a))\na : DualNumber A\n⊢ Eq ((DualNumber.lift fe) a) (HAdd.hAdd ((↑fe).1 (TrivSqZeroExt.fst a)) (HMul.hMul ((↑fe).1 (TrivSqZeroExt.snd a)) (↑fe).2))","decl":"theorem lift_apply_apply (fe : {_fe : (A →ₐ[R] B) × B // _}) (a : A[ε]) :\n    lift fe a = fe.val.1 a.fst + fe.val.1 a.snd * fe.val.2 := rfl\n\n"}
{"name":"DualNumber.coe_lift_symm_apply","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nB : Type u_3\nA : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nF : AlgHom R (DualNumber A) B\n⊢ Eq ↑(DualNumber.lift.symm F) { fst := F.comp (TrivSqZeroExt.inlAlgHom R A A), snd := F DualNumber.eps }","decl":"@[simp] theorem coe_lift_symm_apply (F : A[ε] →ₐ[R] B) :\n    (lift.symm F).val = (F.comp (inlAlgHom _ _ _), F ε) := rfl\n\n"}
{"name":"DualNumber.lift_apply_inl","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nB : Type u_3\nA : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nfe : Subtype fun fe => And (Eq (HMul.hMul fe.2 fe.2) 0) (∀ (a : A), Commute fe.2 (fe.1 a))\na : A\n⊢ Eq ((DualNumber.lift fe) (TrivSqZeroExt.inl a)) ((↑fe).1 a)","decl":"set_option linter.unusedVariables false in\n/-- When applied to `inl`, `DualNumber.lift` applies the map `f : A →ₐ[R] B`. -/\n@[simp] theorem lift_apply_inl (fe : {fe : (A →ₐ[R] B) × B // _}) (a : A) :\n    lift fe (inl a : A[ε]) = fe.val.1 a := by\n  rw [lift_apply_apply, fst_inl, snd_inl, map_zero, zero_mul, add_zero]\n\n"}
{"name":"DualNumber.lift_smul","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nB : Type u_3\nA : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nfe : Subtype fun fe => And (Eq (HMul.hMul fe.2 fe.2) 0) (∀ (a : A), Commute fe.2 (fe.1 a))\na : A\nad : DualNumber A\n⊢ Eq ((DualNumber.lift fe) (HSMul.hSMul a ad)) (HMul.hMul ((↑fe).1 a) ((DualNumber.lift fe) ad))","decl":"set_option linter.unusedVariables false in\n/-- Scaling on the left is sent by `DualNumber.lift` to multiplication on the left -/\n@[simp] theorem lift_smul (fe : {fe : (A →ₐ[R] B) × B // _}) (a : A) (ad : A[ε]) :\n    lift fe (a • ad) = fe.val.1 a * lift fe ad := by\n  rw [← inl_mul_eq_smul, map_mul, lift_apply_inl]\n\n"}
{"name":"DualNumber.lift_op_smul","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nB : Type u_3\nA : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nfe : Subtype fun fe => And (Eq (HMul.hMul fe.2 fe.2) 0) (∀ (a : A), Commute fe.2 (fe.1 a))\na : A\nad : DualNumber A\n⊢ Eq ((DualNumber.lift fe) (HSMul.hSMul (MulOpposite.op a) ad)) (HMul.hMul ((DualNumber.lift fe) ad) ((↑fe).1 a))","decl":"set_option linter.unusedVariables false in\n/-- Scaling on the right is sent by `DualNumber.lift` to multiplication on the right -/\n@[simp] theorem lift_op_smul (fe : {fe : (A →ₐ[R] B) × B // _}) (a : A) (ad : A[ε]) :\n    lift fe (MulOpposite.op a • ad) = lift fe ad * fe.val.1 a := by\n  rw [← mul_inl_eq_op_smul, map_mul, lift_apply_inl]\n\n"}
{"name":"DualNumber.lift_apply_eps","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nB : Type u_3\nA : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nfe : Subtype fun fe => And (Eq (HMul.hMul fe.2 fe.2) 0) (∀ (a : A), Commute fe.2 (fe.1 a))\n⊢ Eq ((DualNumber.lift fe) DualNumber.eps) (↑fe).2","decl":"/-- When applied to `ε`, `DualNumber.lift` produces the element of `B` that squares to 0. -/\n@[simp] theorem lift_apply_eps\n    (fe : {fe : (A →ₐ[R] B) × B // fe.2 * fe.2 = 0 ∧ ∀ a, Commute fe.2 (fe.1 a)}) :\n    lift fe (ε : A[ε]) = fe.val.2 := by\n  simp only [lift_apply_apply, fst_eps, map_zero, snd_eps, map_one, one_mul, zero_add]\n\n"}
{"name":"DualNumber.lift_inlAlgHom_eps","module":"Mathlib.Algebra.DualNumber","initialProofState":"R : Type u_1\nA : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (DualNumber.lift ⟨{ fst := TrivSqZeroExt.inlAlgHom R A A, snd := DualNumber.eps }, ⋯⟩) (AlgHom.id R (DualNumber A))","decl":"/-- Lifting `DualNumber.eps` itself gives the identity. -/\n@[simp]\ntheorem lift_inlAlgHom_eps :\n    lift ⟨(inlAlgHom _ _ _, ε), eps_mul_eps, fun _ => commute_eps_left _⟩ = AlgHom.id R A[ε] :=\n  lift.apply_symm_apply <| AlgHom.id R A[ε]\n\n"}
