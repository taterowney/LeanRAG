{"name":"PerfectPairing.restrict_toLin","module":"Mathlib.LinearAlgebra.PerfectPairing.Restrict","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\np : PerfectPairing R M N\nM' : Type u_4\nN' : Type u_5\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\ni : LinearMap (RingHom.id R) M' M\nj : LinearMap (RingHom.id R) N' N\nhi : Function.Injective ⇑i\nhj : Function.Injective ⇑j\nhij : p.IsPerfectCompl (LinearMap.range i) (LinearMap.range j)\n⊢ Eq (p.restrict i j hi hj hij).toLin (p.toLin.compl₁₂ i j)","decl":"/-- The restriction of a perfect pairing to submodules (expressed as injections to provide\ndefinitional control). -/\n@[simps]\ndef restrict :\n    PerfectPairing R M' N' where\n  toLin := p.toLin.compl₁₂ i j\n  bijectiveLeft := p.restrict_aux i j hi hj hij\n  bijectiveRight := p.flip.restrict_aux j i hj hi hij.flip\n\n"}
{"name":"PerfectPairing.restrict_apply_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Restrict","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\np : PerfectPairing R M N\nM' : Type u_4\nN' : Type u_5\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\ninst✝¹ : AddCommGroup N'\ninst✝ : Module R N'\ni : LinearMap (RingHom.id R) M' M\nj : LinearMap (RingHom.id R) N' N\nhi : Function.Injective ⇑i\nhj : Function.Injective ⇑j\nhij : p.IsPerfectCompl (LinearMap.range i) (LinearMap.range j)\nx : M'\ny : N'\n⊢ Eq (((p.restrict i j hi hj hij) x) y) ((p (i x)) (j y))","decl":"@[simp]\nlemma restrict_apply_apply (x : M') (y : N') :\n    p.restrict i j hi hj hij x y = p (i x) (j y) :=\n  rfl\n\n"}
{"name":"PerfectPairing.exists_basis_basis_of_span_eq_top_of_mem_algebraMap","module":"Mathlib.LinearAlgebra.PerfectPairing.Restrict","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁹ : Field K\ninst✝⁸ : Field L\ninst✝⁷ : Algebra K L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module L M\ninst✝³ : Module L N\ninst✝² : Module K M\ninst✝¹ : Module K N\ninst✝ : IsScalarTower K L M\np : PerfectPairing L M N\nM' : Submodule K M\nN' : Submodule K N\nhM : Eq (Submodule.span L ↑M') Top.top\nhN : Eq (Submodule.span L ↑N') Top.top\nhp : ∀ (x : M), Membership.mem M' x → ∀ (y : N), Membership.mem N' y → Membership.mem (algebraMap K L).range ((p x) y)\n⊢ Exists fun n => Exists fun b => Exists fun b' => ∀ (i : Fin n), Eq (b i) ↑(b' i)","decl":"/-- If a perfect pairing over a field `L` takes values in a subfield `K` along two `K`-subspaces\nwhose `L` span is full, then these subspaces induce a `K`-structure in the sense of\n[*Algebra I*, Bourbaki : Chapter II, §8.1 Definition 1][bourbaki1989]. -/\nlemma exists_basis_basis_of_span_eq_top_of_mem_algebraMap\n    (M' : Submodule K M) (N' : Submodule K N)\n    (hM : span L (M' : Set M) = ⊤)\n    (hN : span L (N' : Set N) = ⊤)\n    (hp : ∀ᵉ (x ∈ M') (y ∈ N'), p x y ∈ (algebraMap K L).range) :\n    ∃ (n : ℕ) (b : Basis (Fin n) L M) (b' : Basis (Fin n) K M'), ∀ i, b i = b' i := by\n  classical\n  have : IsReflexive L M := p.reflexive_left\n  have : IsReflexive L N := p.reflexive_right\n  obtain ⟨v, hv₁, hv₂, hv₃⟩ := exists_linearIndependent L (M' : Set M)\n  rw [hM] at hv₂\n  let b : Basis _ L M := Basis.mk hv₃ <| by rw [← hv₂, Subtype.range_coe_subtype, Set.setOf_mem_eq]\n  have : Fintype v := Set.Finite.fintype <| Module.Finite.finite_basis b\n  set v' : v → M' := fun i ↦ ⟨i, hv₁ (Subtype.coe_prop i)⟩\n  have hv' : LinearIndependent K v' := by\n    replace hv₃ := hv₃.restrict_scalars (R := K) <| by\n      simp_rw [← Algebra.algebraMap_eq_smul_one]\n      exact NoZeroSMulDivisors.algebraMap_injective K L\n    rw [show ((↑) : v → M) = M'.subtype ∘ v' from rfl] at hv₃\n    exact hv₃.of_comp\n  suffices span K (Set.range v') = ⊤ by\n    let e := (Module.Finite.finite_basis b).equivFin\n    let b' : Basis _ K M' := Basis.mk hv' (by rw [this])\n    exact ⟨_, b.reindex e, b'.reindex e, fun i ↦ by simp [b, b', v']⟩\n  suffices span K v = M' by\n    apply Submodule.map_injective_of_injective M'.injective_subtype\n    rw [Submodule.map_span, ← Set.image_univ, Set.image_image]\n    simpa [v']\n  refine le_antisymm (Submodule.span_le.mpr hv₁) fun m hm ↦ ?_\n  obtain ⟨w, hw₁, hw₂, hw₃⟩ := exists_linearIndependent L (N' : Set N)\n  rw [hN] at hw₂\n  let bN : Basis _ L N := Basis.mk hw₃ <| by rw [← hw₂, Subtype.range_coe_subtype, Set.setOf_mem_eq]\n  have : Fintype w := Set.Finite.fintype <| Module.Finite.finite_basis bN\n  have e : v ≃ w := Fintype.equivOfCardEq <| by rw [← Module.finrank_eq_card_basis b,\n    ← Module.finrank_eq_card_basis bN, p.finrank_eq]\n  let bM := bN.dualBasis.map p.toDualLeft.symm\n  have hbM (j : w) (x : M) (hx : x ∈ M') : bM.repr x j = p x (j : N) := by simp [bM, bN]\n  have hj (j : w) : bM.repr m j ∈ (algebraMap K L).range := (hbM _ _ hm) ▸ hp m hm j (hw₁ j.2)\n  replace hp (i : w) (j : v) :\n      (bN.dualBasis.map p.toDualLeft.symm).toMatrix b i j ∈ (algebraMap K L).fieldRange := by\n    simp only [Basis.toMatrix, Basis.map_repr, LinearEquiv.symm_symm, LinearEquiv.trans_apply,\n      toDualLeft_apply, Basis.dualBasis_repr]\n    exact hp (b j) (by simpa [b] using hv₁ j.2) (bN i) (by simpa [bN] using hw₁ i.2)\n  have hA (i j) : b.toMatrix bM i j ∈ (algebraMap K L).range :=\n    Matrix.mem_subfield_of_mul_eq_one_of_mem_subfield_left e _ (by simp [bM]) hp i j\n  have h_span : span K v = span K (Set.range b) := by simp [b]\n  rw [h_span, Basis.mem_span_iff_repr_mem, ← Basis.toMatrix_mulVec_repr bM b m]\n  exact fun i ↦ Subring.sum_mem _ fun j _ ↦ Subring.mul_mem _ (hA i j) (hj j)\n\n"}
{"name":"PerfectPairing.restrictScalarsField_apply_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Restrict","initialProofState":"K : Type u_1\nL : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝¹⁴ : Field K\ninst✝¹³ : Field L\ninst✝¹² : Algebra K L\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : AddCommGroup N\ninst✝⁹ : Module L M\ninst✝⁸ : Module L N\ninst✝⁷ : Module K M\ninst✝⁶ : Module K N\ninst✝⁵ : IsScalarTower K L M\np : PerfectPairing L M N\nM' : Type u_5\nN' : Type u_6\ninst✝⁴ : AddCommGroup M'\ninst✝³ : AddCommGroup N'\ninst✝² : Module K M'\ninst✝¹ : Module K N'\ninst✝ : IsScalarTower K L N\ni : LinearMap (RingHom.id K) M' M\nj : LinearMap (RingHom.id K) N' N\nhij : p.IsPerfectCompl (Submodule.span L ↑(LinearMap.range i)) (Submodule.span L ↑(LinearMap.range j))\nhp : ∀ (m : M') (n : N'), Membership.mem (algebraMap K L).range ((p (i m)) (j n))\nx : M'\ny : N'\n⊢ Eq ((algebraMap K L) (sorryAx (Unit → K) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 260).num 20).num 260).num 63).num 20).num 63).str \"_sorry\").str \"_@\").str \"_hyg\").num 2413)))) ((p (i x)) (j y))","decl":"@[simp] lemma restrictScalarsField_apply_apply\n    (hij : p.IsPerfectCompl (span L <| LinearMap.range i) (span L <| LinearMap.range j))\n    (hp : ∀ m n, p (i m) (j n) ∈ (algebraMap K L).range)\n    (x : M') (y : N') :\n    algebraMap K L (p.restrictScalarsField i j hi hj hij hp x y) = p (i x) (j y) :=\n  LinearMap.restrictScalarsRange_apply i j (Algebra.linearMap K L)\n    (NoZeroSMulDivisors.algebraMap_injective K L) p.toLin hp x y\n\n"}
