{"name":"intermediate_value_univâ‚‚","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : PreconnectedSpace X\na b : X\nf g : X â†’ Î±\nhf : Continuous f\nhg : Continuous g\nha : LE.le (f a) (g a)\nhb : LE.le (g b) (f b)\nâŠ¢ Exists fun x => Eq (f x) (g x)","decl":"/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem intermediate_value_univâ‚‚ [PreconnectedSpace X] {a b : X} {f g : X â†’ Î±} (hf : Continuous f)\n    (hg : Continuous g) (ha : f a â‰¤ g a) (hb : g b â‰¤ f b) : âˆƒ x, f x = g x := by\n  obtain âŸ¨x, _, hfg, hgfâŸ© : (univ âˆ© { x | f x â‰¤ g x âˆ§ g x â‰¤ f x }).Nonempty :=\n    isPreconnected_closed_iff.1 PreconnectedSpace.isPreconnected_univ _ _ (isClosed_le hf hg)\n      (isClosed_le hg hf) (fun _ _ => le_total _ _) âŸ¨a, trivial, haâŸ© âŸ¨b, trivial, hbâŸ©\n  exact âŸ¨x, le_antisymm hfg hgfâŸ©\n\n"}
{"name":"intermediate_value_univâ‚‚_eventuallyâ‚","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : PreconnectedSpace X\na : X\nl : Filter X\ninstâœ : l.NeBot\nf g : X â†’ Î±\nhf : Continuous f\nhg : Continuous g\nha : LE.le (f a) (g a)\nhe : l.EventuallyLE g f\nâŠ¢ Exists fun x => Eq (f x) (g x)","decl":"theorem intermediate_value_univâ‚‚_eventuallyâ‚ [PreconnectedSpace X] {a : X} {l : Filter X} [NeBot l]\n    {f g : X â†’ Î±} (hf : Continuous f) (hg : Continuous g) (ha : f a â‰¤ g a) (he : g â‰¤á¶ [l] f) :\n    âˆƒ x, f x = g x :=\n  let âŸ¨_, hâŸ© := he.exists; intermediate_value_univâ‚‚ hf hg ha h\n\n"}
{"name":"intermediate_value_univâ‚‚_eventuallyâ‚‚","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : LinearOrder Î±\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : OrderClosedTopology Î±\ninstâœÂ² : PreconnectedSpace X\nlâ‚ lâ‚‚ : Filter X\ninstâœÂ¹ : lâ‚.NeBot\ninstâœ : lâ‚‚.NeBot\nf g : X â†’ Î±\nhf : Continuous f\nhg : Continuous g\nheâ‚ : lâ‚.EventuallyLE f g\nheâ‚‚ : lâ‚‚.EventuallyLE g f\nâŠ¢ Exists fun x => Eq (f x) (g x)","decl":"theorem intermediate_value_univâ‚‚_eventuallyâ‚‚ [PreconnectedSpace X] {lâ‚ lâ‚‚ : Filter X} [NeBot lâ‚]\n    [NeBot lâ‚‚] {f g : X â†’ Î±} (hf : Continuous f) (hg : Continuous g) (heâ‚ : f â‰¤á¶ [lâ‚] g)\n    (heâ‚‚ : g â‰¤á¶ [lâ‚‚] f) : âˆƒ x, f x = g x :=\n  let âŸ¨_, hâ‚âŸ© := heâ‚.exists\n  let âŸ¨_, hâ‚‚âŸ© := heâ‚‚.exists\n  intermediate_value_univâ‚‚ hf hg hâ‚ hâ‚‚\n\n"}
{"name":"IsPreconnected.intermediate_valueâ‚‚","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\na b : X\nha : Membership.mem s a\nhb : Membership.mem s b\nf g : X â†’ Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nha' : LE.le (f a) (g a)\nhb' : LE.le (g b) (f b)\nâŠ¢ Exists fun x => And (Membership.mem s x) (Eq (f x) (g x))","decl":"/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,\nthen for some `x âˆˆ s` we have `f x = g x`. -/\ntheorem IsPreconnected.intermediate_valueâ‚‚ {s : Set X} (hs : IsPreconnected s) {a b : X}\n    (ha : a âˆˆ s) (hb : b âˆˆ s) {f g : X â†’ Î±} (hf : ContinuousOn f s) (hg : ContinuousOn g s)\n    (ha' : f a â‰¤ g a) (hb' : g b â‰¤ f b) : âˆƒ x âˆˆ s, f x = g x :=\n  let âŸ¨x, hxâŸ© :=\n    @intermediate_value_univâ‚‚ s Î± _ _ _ _ (Subtype.preconnectedSpace hs) âŸ¨a, haâŸ© âŸ¨b, hbâŸ© _ _\n      (continuousOn_iff_continuous_restrict.1 hf) (continuousOn_iff_continuous_restrict.1 hg) ha'\n      hb'\n  âŸ¨x, x.2, hxâŸ©\n\n"}
{"name":"IsPreconnected.intermediate_valueâ‚‚_eventuallyâ‚","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninstâœ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf g : X â†’ Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nha' : LE.le (f a) (g a)\nhe : l.EventuallyLE g f\nâŠ¢ Exists fun x => And (Membership.mem s x) (Eq (f x) (g x))","decl":"theorem IsPreconnected.intermediate_valueâ‚‚_eventuallyâ‚ {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a âˆˆ s) [NeBot l] (hl : l â‰¤ ğ“Ÿ s) {f g : X â†’ Î±} (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) (ha' : f a â‰¤ g a) (he : g â‰¤á¶ [l] f) : âˆƒ x âˆˆ s, f x = g x := by\n  rw [continuousOn_iff_continuous_restrict] at hf hg\n  obtain âŸ¨b, hâŸ© :=\n    @intermediate_value_univâ‚‚_eventuallyâ‚ _ _ _ _ _ _ (Subtype.preconnectedSpace hs) âŸ¨a, haâŸ© _\n      (comap_coe_neBot_of_le_principal hl) _ _ hf hg ha' (he.comap _)\n  exact âŸ¨b, b.prop, hâŸ©\n\n"}
{"name":"IsPreconnected.intermediate_valueâ‚‚_eventuallyâ‚‚","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\nlâ‚ lâ‚‚ : Filter X\ninstâœÂ¹ : lâ‚.NeBot\ninstâœ : lâ‚‚.NeBot\nhlâ‚ : LE.le lâ‚ (Filter.principal s)\nhlâ‚‚ : LE.le lâ‚‚ (Filter.principal s)\nf g : X â†’ Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nheâ‚ : lâ‚.EventuallyLE f g\nheâ‚‚ : lâ‚‚.EventuallyLE g f\nâŠ¢ Exists fun x => And (Membership.mem s x) (Eq (f x) (g x))","decl":"theorem IsPreconnected.intermediate_valueâ‚‚_eventuallyâ‚‚ {s : Set X} (hs : IsPreconnected s)\n    {lâ‚ lâ‚‚ : Filter X} [NeBot lâ‚] [NeBot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f g : X â†’ Î±}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) (heâ‚ : f â‰¤á¶ [lâ‚] g) (heâ‚‚ : g â‰¤á¶ [lâ‚‚] f) :\n    âˆƒ x âˆˆ s, f x = g x := by\n  rw [continuousOn_iff_continuous_restrict] at hf hg\n  obtain âŸ¨b, hâŸ© :=\n    @intermediate_value_univâ‚‚_eventuallyâ‚‚ _ _ _ _ _ _ (Subtype.preconnectedSpace hs) _ _\n      (comap_coe_neBot_of_le_principal hlâ‚) (comap_coe_neBot_of_le_principal hlâ‚‚) _ _ hf hg\n      (heâ‚.comap _) (heâ‚‚.comap _)\n  exact âŸ¨b, b.prop, hâŸ©\n\n"}
{"name":"IsPreconnected.intermediate_value","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\na b : X\nha : Membership.mem s a\nhb : Membership.mem s b\nf : X â†’ Î±\nhf : ContinuousOn f s\nâŠ¢ HasSubset.Subset (Set.Icc (f a) (f b)) (Set.image f s)","decl":"/-- **Intermediate Value Theorem** for continuous functions on connected sets. -/\ntheorem IsPreconnected.intermediate_value {s : Set X} (hs : IsPreconnected s) {a b : X} (ha : a âˆˆ s)\n    (hb : b âˆˆ s) {f : X â†’ Î±} (hf : ContinuousOn f s) : Icc (f a) (f b) âŠ† f '' s := fun _x hx =>\n  hs.intermediate_valueâ‚‚ ha hb hf continuousOn_const hx.1 hx.2\n\n"}
{"name":"IsPreconnected.intermediate_value_Ico","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninstâœ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf : X â†’ Î±\nhf : ContinuousOn f s\nv : Î±\nht : Filter.Tendsto f l (nhds v)\nâŠ¢ HasSubset.Subset (Set.Ico (f a) v) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ico {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a âˆˆ s) [NeBot l] (hl : l â‰¤ ğ“Ÿ s) {f : X â†’ Î±} (hf : ContinuousOn f s) {v : Î±}\n    (ht : Tendsto f l (ğ“ v)) : Ico (f a) v âŠ† f '' s := fun _ h =>\n  hs.intermediate_valueâ‚‚_eventuallyâ‚ ha hl hf continuousOn_const h.1 (ht.eventually_const_le h.2)\n\n"}
{"name":"IsPreconnected.intermediate_value_Ioc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninstâœ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf : X â†’ Î±\nhf : ContinuousOn f s\nv : Î±\nht : Filter.Tendsto f l (nhds v)\nâŠ¢ HasSubset.Subset (Set.Ioc v (f a)) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ioc {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a âˆˆ s) [NeBot l] (hl : l â‰¤ ğ“Ÿ s) {f : X â†’ Î±} (hf : ContinuousOn f s) {v : Î±}\n    (ht : Tendsto f l (ğ“ v)) : Ioc v (f a) âŠ† f '' s := fun _ h =>\n  (hs.intermediate_valueâ‚‚_eventuallyâ‚ ha hl continuousOn_const hf h.2\n    (ht.eventually_le_const h.1)).imp fun _ h => h.imp_right Eq.symm\n\n"}
{"name":"IsPreconnected.intermediate_value_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\nlâ‚ lâ‚‚ : Filter X\ninstâœÂ¹ : lâ‚.NeBot\ninstâœ : lâ‚‚.NeBot\nhlâ‚ : LE.le lâ‚ (Filter.principal s)\nhlâ‚‚ : LE.le lâ‚‚ (Filter.principal s)\nf : X â†’ Î±\nhf : ContinuousOn f s\nvâ‚ vâ‚‚ : Î±\nhtâ‚ : Filter.Tendsto f lâ‚ (nhds vâ‚)\nhtâ‚‚ : Filter.Tendsto f lâ‚‚ (nhds vâ‚‚)\nâŠ¢ HasSubset.Subset (Set.Ioo vâ‚ vâ‚‚) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ioo {s : Set X} (hs : IsPreconnected s) {lâ‚ lâ‚‚ : Filter X}\n    [NeBot lâ‚] [NeBot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f : X â†’ Î±} (hf : ContinuousOn f s)\n    {vâ‚ vâ‚‚ : Î±} (htâ‚ : Tendsto f lâ‚ (ğ“ vâ‚)) (htâ‚‚ : Tendsto f lâ‚‚ (ğ“ vâ‚‚)) :\n    Ioo vâ‚ vâ‚‚ âŠ† f '' s := fun _ h =>\n  hs.intermediate_valueâ‚‚_eventuallyâ‚‚ hlâ‚ hlâ‚‚ hf continuousOn_const\n    (htâ‚.eventually_le_const h.1) (htâ‚‚.eventually_const_le h.2)\n\n"}
{"name":"IsPreconnected.intermediate_value_Ici","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninstâœ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf : X â†’ Î±\nhf : ContinuousOn f s\nht : Filter.Tendsto f l Filter.atTop\nâŠ¢ HasSubset.Subset (Set.Ici (f a)) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ici {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a âˆˆ s) [NeBot l] (hl : l â‰¤ ğ“Ÿ s) {f : X â†’ Î±} (hf : ContinuousOn f s)\n    (ht : Tendsto f l atTop) : Ici (f a) âŠ† f '' s := fun y h =>\n  hs.intermediate_valueâ‚‚_eventuallyâ‚ ha hl hf continuousOn_const h (tendsto_atTop.1 ht y)\n\n"}
{"name":"IsPreconnected.intermediate_value_Iic","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninstâœ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf : X â†’ Î±\nhf : ContinuousOn f s\nht : Filter.Tendsto f l Filter.atBot\nâŠ¢ HasSubset.Subset (Set.Iic (f a)) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Iic {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a âˆˆ s) [NeBot l] (hl : l â‰¤ ğ“Ÿ s) {f : X â†’ Î±} (hf : ContinuousOn f s)\n    (ht : Tendsto f l atBot) : Iic (f a) âŠ† f '' s := fun y h =>\n  (hs.intermediate_valueâ‚‚_eventuallyâ‚ ha hl continuousOn_const hf h (tendsto_atBot.1 ht y)).imp\n    fun _ h => h.imp_right Eq.symm\n\n"}
{"name":"IsPreconnected.intermediate_value_Ioi","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\nlâ‚ lâ‚‚ : Filter X\ninstâœÂ¹ : lâ‚.NeBot\ninstâœ : lâ‚‚.NeBot\nhlâ‚ : LE.le lâ‚ (Filter.principal s)\nhlâ‚‚ : LE.le lâ‚‚ (Filter.principal s)\nf : X â†’ Î±\nhf : ContinuousOn f s\nv : Î±\nhtâ‚ : Filter.Tendsto f lâ‚ (nhds v)\nhtâ‚‚ : Filter.Tendsto f lâ‚‚ Filter.atTop\nâŠ¢ HasSubset.Subset (Set.Ioi v) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ioi {s : Set X} (hs : IsPreconnected s) {lâ‚ lâ‚‚ : Filter X}\n    [NeBot lâ‚] [NeBot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f : X â†’ Î±} (hf : ContinuousOn f s)\n    {v : Î±} (htâ‚ : Tendsto f lâ‚ (ğ“ v)) (htâ‚‚ : Tendsto f lâ‚‚ atTop) : Ioi v âŠ† f '' s := fun y h =>\n  hs.intermediate_valueâ‚‚_eventuallyâ‚‚ hlâ‚ hlâ‚‚ hf continuousOn_const\n    (htâ‚.eventually_le_const h) (htâ‚‚.eventually_ge_atTop y)\n\n"}
{"name":"IsPreconnected.intermediate_value_Iio","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\nlâ‚ lâ‚‚ : Filter X\ninstâœÂ¹ : lâ‚.NeBot\ninstâœ : lâ‚‚.NeBot\nhlâ‚ : LE.le lâ‚ (Filter.principal s)\nhlâ‚‚ : LE.le lâ‚‚ (Filter.principal s)\nf : X â†’ Î±\nhf : ContinuousOn f s\nv : Î±\nhtâ‚ : Filter.Tendsto f lâ‚ Filter.atBot\nhtâ‚‚ : Filter.Tendsto f lâ‚‚ (nhds v)\nâŠ¢ HasSubset.Subset (Set.Iio v) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Iio {s : Set X} (hs : IsPreconnected s) {lâ‚ lâ‚‚ : Filter X}\n    [NeBot lâ‚] [NeBot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f : X â†’ Î±} (hf : ContinuousOn f s)\n    {v : Î±} (htâ‚ : Tendsto f lâ‚ atBot) (htâ‚‚ : Tendsto f lâ‚‚ (ğ“ v)) : Iio v âŠ† f '' s := fun y h =>\n  hs.intermediate_valueâ‚‚_eventuallyâ‚‚ hlâ‚ hlâ‚‚ hf continuousOn_const (htâ‚.eventually_le_atBot y)\n    (htâ‚‚.eventually_const_le h)\n\n"}
{"name":"IsPreconnected.intermediate_value_Iii","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ns : Set X\nhs : IsPreconnected s\nlâ‚ lâ‚‚ : Filter X\ninstâœÂ¹ : lâ‚.NeBot\ninstâœ : lâ‚‚.NeBot\nhlâ‚ : LE.le lâ‚ (Filter.principal s)\nhlâ‚‚ : LE.le lâ‚‚ (Filter.principal s)\nf : X â†’ Î±\nhf : ContinuousOn f s\nhtâ‚ : Filter.Tendsto f lâ‚ Filter.atBot\nhtâ‚‚ : Filter.Tendsto f lâ‚‚ Filter.atTop\nâŠ¢ HasSubset.Subset Set.univ (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Iii {s : Set X} (hs : IsPreconnected s) {lâ‚ lâ‚‚ : Filter X}\n    [NeBot lâ‚] [NeBot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f : X â†’ Î±} (hf : ContinuousOn f s)\n    (htâ‚ : Tendsto f lâ‚ atBot) (htâ‚‚ : Tendsto f lâ‚‚ atTop) : univ âŠ† f '' s := fun y _ =>\n  hs.intermediate_valueâ‚‚_eventuallyâ‚‚ hlâ‚ hlâ‚‚ hf continuousOn_const (htâ‚.eventually_le_atBot y)\n    (htâ‚‚.eventually_ge_atTop y)\n\n"}
{"name":"intermediate_value_univ","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : PreconnectedSpace X\na b : X\nf : X â†’ Î±\nhf : Continuous f\nâŠ¢ HasSubset.Subset (Set.Icc (f a) (f b)) (Set.range f)","decl":"/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/\ntheorem intermediate_value_univ [PreconnectedSpace X] (a b : X) {f : X â†’ Î±} (hf : Continuous f) :\n    Icc (f a) (f b) âŠ† range f := fun _ hx => intermediate_value_univâ‚‚ hf continuous_const hx.1 hx.2\n\n"}
{"name":"mem_range_of_exists_le_of_exists_ge","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nÎ± : Type v\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : PreconnectedSpace X\nc : Î±\nf : X â†’ Î±\nhf : Continuous f\nhâ‚ : Exists fun a => LE.le (f a) c\nhâ‚‚ : Exists fun b => LE.le c (f b)\nâŠ¢ Membership.mem (Set.range f) c","decl":"/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/\ntheorem mem_range_of_exists_le_of_exists_ge [PreconnectedSpace X] {c : Î±} {f : X â†’ Î±}\n    (hf : Continuous f) (hâ‚ : âˆƒ a, f a â‰¤ c) (hâ‚‚ : âˆƒ b, c â‰¤ f b) : c âˆˆ range f :=\n  let âŸ¨a, haâŸ© := hâ‚; let âŸ¨b, hbâŸ© := hâ‚‚; intermediate_value_univ a b hf âŸ¨ha, hbâŸ©\n\n"}
{"name":"IsPreconnected.Icc_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type v\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderClosedTopology Î±\ns : Set Î±\nhs : IsPreconnected s\na b : Î±\nha : Membership.mem s a\nhb : Membership.mem s b\nâŠ¢ HasSubset.Subset (Set.Icc a b) s","decl":"/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/\ntheorem IsPreconnected.Icc_subset {s : Set Î±} (hs : IsPreconnected s) {a b : Î±} (ha : a âˆˆ s)\n    (hb : b âˆˆ s) : Icc a b âŠ† s := by\n  simpa only [image_id] using hs.intermediate_value ha hb continuousOn_id\n\n"}
{"name":"IsPreconnected.ordConnected","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type v\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderClosedTopology Î±\ns : Set Î±\nh : IsPreconnected s\nâŠ¢ s.OrdConnected","decl":"theorem IsPreconnected.ordConnected {s : Set Î±} (h : IsPreconnected s) : OrdConnected s :=\n  âŸ¨fun _ hx _ hy => h.Icc_subset hx hyâŸ©\n\n"}
{"name":"IsConnected.Icc_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type v\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderClosedTopology Î±\ns : Set Î±\nhs : IsConnected s\na b : Î±\nha : Membership.mem s a\nhb : Membership.mem s b\nâŠ¢ HasSubset.Subset (Set.Icc a b) s","decl":"/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/\ntheorem IsConnected.Icc_subset {s : Set Î±} (hs : IsConnected s) {a b : Î±} (ha : a âˆˆ s)\n    (hb : b âˆˆ s) : Icc a b âŠ† s :=\n  hs.2.Icc_subset ha hb\n\n"}
{"name":"IsPreconnected.eq_univ_of_unbounded","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type v\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderClosedTopology Î±\ns : Set Î±\nhs : IsPreconnected s\nhb : Not (BddBelow s)\nha : Not (BddAbove s)\nâŠ¢ Eq s Set.univ","decl":"/-- If preconnected set in a linear order space is unbounded below and above, then it is the whole\nspace. -/\ntheorem IsPreconnected.eq_univ_of_unbounded {s : Set Î±} (hs : IsPreconnected s) (hb : Â¬BddBelow s)\n    (ha : Â¬BddAbove s) : s = univ := by\n  refine eq_univ_of_forall fun x => ?_\n  obtain âŸ¨y, ys, hyâŸ© : âˆƒ y âˆˆ s, y < x := not_bddBelow_iff.1 hb x\n  obtain âŸ¨z, zs, hzâŸ© : âˆƒ z âˆˆ s, x < z := not_bddAbove_iff.1 ha x\n  exact hs.Icc_subset ys zs âŸ¨le_of_lt hy, le_of_lt hzâŸ©\n\n"}
{"name":"IsConnected.Ioo_csInf_csSup_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\ns : Set Î±\nhs : IsConnected s\nhb : BddBelow s\nha : BddAbove s\nâŠ¢ HasSubset.Subset (Set.Ioo (InfSet.sInf s) (SupSet.sSup s)) s","decl":"/-- A bounded connected subset of a conditionally complete linear order includes the open interval\n`(Inf s, Sup s)`. -/\ntheorem IsConnected.Ioo_csInf_csSup_subset {s : Set Î±} (hs : IsConnected s) (hb : BddBelow s)\n    (ha : BddAbove s) : Ioo (sInf s) (sSup s) âŠ† s := fun _x hx =>\n  let âŸ¨_y, ys, hyâŸ© := (isGLB_lt_iff (isGLB_csInf hs.nonempty hb)).1 hx.1\n  let âŸ¨_z, zs, hzâŸ© := (lt_isLUB_iff (isLUB_csSup hs.nonempty ha)).1 hx.2\n  hs.Icc_subset ys zs âŸ¨hy.le, hz.leâŸ©\n\n"}
{"name":"eq_Icc_csInf_csSup_of_connected_bdd_closed","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\ns : Set Î±\nhc : IsConnected s\nhb : BddBelow s\nha : BddAbove s\nhcl : IsClosed s\nâŠ¢ Eq s (Set.Icc (InfSet.sInf s) (SupSet.sSup s))","decl":"theorem eq_Icc_csInf_csSup_of_connected_bdd_closed {s : Set Î±} (hc : IsConnected s)\n    (hb : BddBelow s) (ha : BddAbove s) (hcl : IsClosed s) : s = Icc (sInf s) (sSup s) :=\n  (subset_Icc_csInf_csSup hb ha).antisymm <|\n    hc.Icc_subset (hcl.csInf_mem hc.nonempty hb) (hcl.csSup_mem hc.nonempty ha)\n\n"}
{"name":"IsPreconnected.Ioi_csInf_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\ns : Set Î±\nhs : IsPreconnected s\nhb : BddBelow s\nha : Not (BddAbove s)\nâŠ¢ HasSubset.Subset (Set.Ioi (InfSet.sInf s)) s","decl":"theorem IsPreconnected.Ioi_csInf_subset {s : Set Î±} (hs : IsPreconnected s) (hb : BddBelow s)\n    (ha : Â¬BddAbove s) : Ioi (sInf s) âŠ† s := fun x hx =>\n  have sne : s.Nonempty := nonempty_of_not_bddAbove ha\n  let âŸ¨_y, ys, hyâŸ© : âˆƒ y âˆˆ s, y < x := (isGLB_lt_iff (isGLB_csInf sne hb)).1 hx\n  let âŸ¨_z, zs, hzâŸ© : âˆƒ z âˆˆ s, x < z := not_bddAbove_iff.1 ha x\n  hs.Icc_subset ys zs âŸ¨hy.le, hz.leâŸ©\n\n"}
{"name":"IsPreconnected.Iio_csSup_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\ns : Set Î±\nhs : IsPreconnected s\nhb : Not (BddBelow s)\nha : BddAbove s\nâŠ¢ HasSubset.Subset (Set.Iio (SupSet.sSup s)) s","decl":"theorem IsPreconnected.Iio_csSup_subset {s : Set Î±} (hs : IsPreconnected s) (hb : Â¬BddBelow s)\n    (ha : BddAbove s) : Iio (sSup s) âŠ† s :=\n  IsPreconnected.Ioi_csInf_subset (Î± := Î±áµ’áµˆ) hs ha hb\n\n"}
{"name":"IsPreconnected.mem_intervals","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\ns : Set Î±\nhs : IsPreconnected s\nâŠ¢ Membership.mem (Insert.insert (Set.Icc (InfSet.sInf s) (SupSet.sSup s)) (Insert.insert (Set.Ico (InfSet.sInf s) (SupSet.sSup s)) (Insert.insert (Set.Ioc (InfSet.sInf s) (SupSet.sSup s)) (Insert.insert (Set.Ioo (InfSet.sInf s) (SupSet.sSup s)) (Insert.insert (Set.Ici (InfSet.sInf s)) (Insert.insert (Set.Ioi (InfSet.sInf s)) (Insert.insert (Set.Iic (SupSet.sSup s)) (Insert.insert (Set.Iio (SupSet.sSup s)) (Insert.insert Set.univ (Singleton.singleton EmptyCollection.emptyCollection)))))))))) s","decl":"/-- A preconnected set in a conditionally complete linear order is either one of the intervals\n`[Inf s, Sup s]`, `[Inf s, Sup s)`, `(Inf s, Sup s]`, `(Inf s, Sup s)`, `[Inf s, +âˆ)`,\n`(Inf s, +âˆ)`, `(-âˆ, Sup s]`, `(-âˆ, Sup s)`, `(-âˆ, +âˆ)`, or `âˆ…`. The converse statement requires\n`Î±` to be densely ordered. -/\ntheorem IsPreconnected.mem_intervals {s : Set Î±} (hs : IsPreconnected s) :\n    s âˆˆ\n      ({Icc (sInf s) (sSup s), Ico (sInf s) (sSup s), Ioc (sInf s) (sSup s), Ioo (sInf s) (sSup s),\n          Ici (sInf s), Ioi (sInf s), Iic (sSup s), Iio (sSup s), univ, âˆ…} : Set (Set Î±)) := by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  Â· apply_rules [Or.inr, mem_singleton]\n  have hs' : IsConnected s := âŸ¨hne, hsâŸ©\n  by_cases hb : BddBelow s <;> by_cases ha : BddAbove s\n  Â· refine mem_of_subset_of_mem ?_ <| mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset\n      (hs'.Ioo_csInf_csSup_subset hb ha) (subset_Icc_csInf_csSup hb ha)\n    simp only [insert_subset_iff, mem_insert_iff, mem_singleton_iff, true_or, or_true,\n      singleton_subset_iff, and_self]\n  Â· refine Or.inr <| Or.inr <| Or.inr <| Or.inr ?_\n    cases'\n      mem_Ici_Ioi_of_subset_of_subset (hs.Ioi_csInf_subset hb ha) fun x hx => csInf_le hb hx with\n      hs hs\n    Â· exact Or.inl hs\n    Â· exact Or.inr (Or.inl hs)\n  Â· iterate 6 apply Or.inr\n    cases' mem_Iic_Iio_of_subset_of_subset (hs.Iio_csSup_subset hb ha) fun x hx => le_csSup ha hx\n      with hs hs\n    Â· exact Or.inl hs\n    Â· exact Or.inr (Or.inl hs)\n  Â· iterate 8 apply Or.inr\n    exact Or.inl (hs.eq_univ_of_unbounded hb ha)\n\n"}
{"name":"setOf_isPreconnected_subset_of_ordered","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\nâŠ¢ HasSubset.Subset (setOf fun s => IsPreconnected s) (Union.union (Union.union (Union.union (Union.union (Set.range (Function.uncurry Set.Icc)) (Set.range (Function.uncurry Set.Ico))) (Set.range (Function.uncurry Set.Ioc))) (Set.range (Function.uncurry Set.Ioo))) (Union.union (Union.union (Union.union (Union.union (Set.range Set.Ici) (Set.range Set.Ioi)) (Set.range Set.Iic)) (Set.range Set.Iio)) (Insert.insert Set.univ (Singleton.singleton EmptyCollection.emptyCollection))))","decl":"/-- A preconnected set is either one of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`,\n`Iic`, `Iio`, or `univ`, or `âˆ…`. The converse statement requires `Î±` to be densely ordered. Though\none can represent `âˆ…` as `(Inf âˆ…, Inf âˆ…)`, we include it into the list of possible cases to improve\nreadability. -/\ntheorem setOf_isPreconnected_subset_of_ordered :\n    { s : Set Î± | IsPreconnected s } âŠ†\n      -- bounded intervals\n      (range (uncurry Icc) âˆª range (uncurry Ico) âˆª range (uncurry Ioc) âˆª range (uncurry Ioo)) âˆª\n      -- unbounded intervals and `univ`\n      (range Ici âˆª range Ioi âˆª range Iic âˆª range Iio âˆª {univ, âˆ…}) := by\n  intro s hs\n  rcases hs.mem_intervals with (hs | hs | hs | hs | hs | hs | hs | hs | hs | hs) <;> rw [hs] <;>\n    simp only [union_insert, union_singleton, mem_insert_iff, mem_union, mem_range, Prod.exists,\n      uncurry_apply_pair, exists_apply_eq_apply, true_or, or_true, exists_apply_eq_apply2]\n\n"}
{"name":"IsClosed.mem_of_ge_of_forall_exists_gt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\na b : Î±\ns : Set Î±\nhs : IsClosed (Inter.inter s (Set.Icc a b))\nha : Membership.mem s a\nhab : LE.le a b\nhgt : âˆ€ (x : Î±), Membership.mem (Inter.inter s (Set.Ico a b)) x â†’ (Inter.inter s (Set.Ioc x b)).Nonempty\nâŠ¢ Membership.mem s b","decl":"/-- A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and the set `s âˆ© [a, b)` has no maximal point, then `b âˆˆ s`. -/\ntheorem IsClosed.mem_of_ge_of_forall_exists_gt {a b : Î±} {s : Set Î±} (hs : IsClosed (s âˆ© Icc a b))\n    (ha : a âˆˆ s) (hab : a â‰¤ b) (hgt : âˆ€ x âˆˆ s âˆ© Ico a b, (s âˆ© Ioc x b).Nonempty) : b âˆˆ s := by\n  let S := s âˆ© Icc a b\n  replace ha : a âˆˆ S := âŸ¨ha, left_mem_Icc.2 habâŸ©\n  have Sbd : BddAbove S := âŸ¨b, fun z hz => hz.2.2âŸ©\n  let c := sSup (s âˆ© Icc a b)\n  have c_mem : c âˆˆ S := hs.csSup_mem âŸ¨_, haâŸ© Sbd\n  have c_le : c â‰¤ b := csSup_le âŸ¨_, haâŸ© fun x hx => hx.2.2\n  cases' eq_or_lt_of_le c_le with hc hc\n  Â· exact hc â–¸ c_mem.1\n  exfalso\n  rcases hgt c âŸ¨c_mem.1, c_mem.2.1, hcâŸ© with âŸ¨x, xs, cx, xbâŸ©\n  exact not_lt_of_le (le_csSup Sbd âŸ¨xs, le_trans (le_csSup Sbd ha) (le_of_lt cx), xbâŸ©) cx\n\n"}
{"name":"IsClosed.Icc_subset_of_forall_exists_gt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\na b : Î±\ns : Set Î±\nhs : IsClosed (Inter.inter s (Set.Icc a b))\nha : Membership.mem s a\nhgt : âˆ€ (x : Î±), Membership.mem (Inter.inter s (Set.Ico a b)) x â†’ âˆ€ (y : Î±), Membership.mem (Set.Ioi x) y â†’ (Inter.inter s (Set.Ioc x y)).Nonempty\nâŠ¢ HasSubset.Subset (Set.Icc a b) s","decl":"/-- A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and for any `a â‰¤ x < y â‰¤ b`, `x âˆˆ s`, the set `s âˆ© (x, y]`\nis not empty, then `[a, b] âŠ† s`. -/\ntheorem IsClosed.Icc_subset_of_forall_exists_gt {a b : Î±} {s : Set Î±} (hs : IsClosed (s âˆ© Icc a b))\n    (ha : a âˆˆ s) (hgt : âˆ€ x âˆˆ s âˆ© Ico a b, âˆ€ y âˆˆ Ioi x, (s âˆ© Ioc x y).Nonempty) : Icc a b âŠ† s := by\n  intro y hy\n  have : IsClosed (s âˆ© Icc a y) := by\n    suffices s âˆ© Icc a y = s âˆ© Icc a b âˆ© Icc a y by\n      rw [this]\n      exact IsClosed.inter hs isClosed_Icc\n    rw [inter_assoc]\n    congr\n    exact (inter_eq_self_of_subset_right <| Icc_subset_Icc_right hy.2).symm\n  exact\n    IsClosed.mem_of_ge_of_forall_exists_gt this ha hy.1 fun x hx =>\n      hgt x âŸ¨hx.1, Ico_subset_Ico_right hy.2 hx.2âŸ© y hx.2.2\n\n"}
{"name":"IsClosed.Icc_subset_of_forall_mem_nhdsWithin","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\ns : Set Î±\nhs : IsClosed (Inter.inter s (Set.Icc a b))\nha : Membership.mem s a\nhgt : âˆ€ (x : Î±), Membership.mem (Inter.inter s (Set.Ico a b)) x â†’ Membership.mem (nhdsWithin x (Set.Ioi x)) s\nâŠ¢ HasSubset.Subset (Set.Icc a b) s","decl":"/-- A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and for any `x âˆˆ s âˆ© [a, b)` the set `s` includes some open\nneighborhood of `x` within `(x, +âˆ)`, then `[a, b] âŠ† s`. -/\ntheorem IsClosed.Icc_subset_of_forall_mem_nhdsWithin {a b : Î±} {s : Set Î±}\n    (hs : IsClosed (s âˆ© Icc a b)) (ha : a âˆˆ s) (hgt : âˆ€ x âˆˆ s âˆ© Ico a b, s âˆˆ ğ“[>] x) :\n    Icc a b âŠ† s := by\n  apply hs.Icc_subset_of_forall_exists_gt ha\n  rintro x âŸ¨hxs, hxabâŸ© y hyxb\n  have : s âˆ© Ioc x y âˆˆ ğ“[>] x := inter_mem (hgt x âŸ¨hxs, hxabâŸ©) (Ioc_mem_nhdsGT hyxb)\n  exact (nhdsGT_neBot_of_exists_gt âŸ¨b, hxab.2âŸ©).nonempty_of_mem this\n\n"}
{"name":"isPreconnected_Icc_aux","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b x y : Î±\ns t : Set Î±\nhxy : LE.le x y\nhs : IsClosed s\nht : IsClosed t\nhab : HasSubset.Subset (Set.Icc a b) (Union.union s t)\nhx : Membership.mem (Inter.inter (Set.Icc a b) s) x\nhy : Membership.mem (Inter.inter (Set.Icc a b) t) y\nâŠ¢ (Inter.inter (Set.Icc a b) (Inter.inter s t)).Nonempty","decl":"theorem isPreconnected_Icc_aux (x y : Î±) (s t : Set Î±) (hxy : x â‰¤ y) (hs : IsClosed s)\n    (ht : IsClosed t) (hab : Icc a b âŠ† s âˆª t) (hx : x âˆˆ Icc a b âˆ© s) (hy : y âˆˆ Icc a b âˆ© t) :\n    (Icc a b âˆ© (s âˆ© t)).Nonempty := by\n  have xyab : Icc x y âŠ† Icc a b := Icc_subset_Icc hx.1.1 hy.1.2\n  by_contra hst\n  suffices Icc x y âŠ† s from\n    hst âŸ¨y, xyab <| right_mem_Icc.2 hxy, this <| right_mem_Icc.2 hxy, hy.2âŸ©\n  apply (IsClosed.inter hs isClosed_Icc).Icc_subset_of_forall_mem_nhdsWithin hx.2\n  rintro z âŸ¨zs, hzâŸ©\n  have zt : z âˆˆ tá¶œ := fun zt => hst âŸ¨z, xyab <| Ico_subset_Icc_self hz, zs, ztâŸ©\n  have : tá¶œ âˆ© Ioc z y âˆˆ ğ“[>] z := by\n    rw [â† nhdsWithin_Ioc_eq_nhdsGT hz.2]\n    exact mem_nhdsWithin.2 âŸ¨tá¶œ, ht.isOpen_compl, zt, Subset.rflâŸ©\n  apply mem_of_superset this\n  have : Ioc z y âŠ† s âˆª t := fun w hw => hab (xyab âŸ¨le_trans hz.1 (le_of_lt hw.1), hw.2âŸ©)\n  exact fun w âŸ¨wt, wzyâŸ© => (this wzy).elim id fun h => (wt h).elim\n\n"}
{"name":"isPreconnected_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nâŠ¢ IsPreconnected (Set.Icc a b)","decl":"/-- A closed interval in a densely ordered conditionally complete linear order is preconnected. -/\ntheorem isPreconnected_Icc : IsPreconnected (Icc a b) :=\n  isPreconnected_closed_iff.2\n    (by\n      rintro s t hs ht hab âŸ¨x, hxâŸ© âŸ¨y, hyâŸ©\n      -- This used to use `wlog`, but it was causing timeouts.\n      rcases le_total x y with h | h\n      Â· exact isPreconnected_Icc_aux x y s t h hs ht hab hx hy\n      Â· rw [inter_comm s t]\n        rw [union_comm s t] at hab\n        exact isPreconnected_Icc_aux y x t s h ht hs hab hy hx)\n\n"}
{"name":"isPreconnected_uIcc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nâŠ¢ IsPreconnected (Set.uIcc a b)","decl":"theorem isPreconnected_uIcc : IsPreconnected ([[a, b]]) :=\n  isPreconnected_Icc\n\n"}
{"name":"Set.OrdConnected.isPreconnected","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\ns : Set Î±\nh : s.OrdConnected\nâŠ¢ IsPreconnected s","decl":"theorem Set.OrdConnected.isPreconnected {s : Set Î±} (h : s.OrdConnected) : IsPreconnected s :=\n  isPreconnected_of_forall_pair fun x hx y hy =>\n    âŸ¨[[x, y]], h.uIcc_subset hx hy, left_mem_uIcc, right_mem_uIcc, isPreconnected_uIccâŸ©\n\n"}
{"name":"isPreconnected_iff_ordConnected","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\ns : Set Î±\nâŠ¢ Iff (IsPreconnected s) s.OrdConnected","decl":"theorem isPreconnected_iff_ordConnected {s : Set Î±} : IsPreconnected s â†” OrdConnected s :=\n  âŸ¨IsPreconnected.ordConnected, Set.OrdConnected.isPreconnectedâŸ©\n\n"}
{"name":"isPreconnected_Ici","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na : Î±\nâŠ¢ IsPreconnected (Set.Ici a)","decl":"theorem isPreconnected_Ici : IsPreconnected (Ici a) :=\n  ordConnected_Ici.isPreconnected\n\n"}
{"name":"isPreconnected_Iic","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na : Î±\nâŠ¢ IsPreconnected (Set.Iic a)","decl":"theorem isPreconnected_Iic : IsPreconnected (Iic a) :=\n  ordConnected_Iic.isPreconnected\n\n"}
{"name":"isPreconnected_Iio","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na : Î±\nâŠ¢ IsPreconnected (Set.Iio a)","decl":"theorem isPreconnected_Iio : IsPreconnected (Iio a) :=\n  ordConnected_Iio.isPreconnected\n\n"}
{"name":"isPreconnected_Ioi","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na : Î±\nâŠ¢ IsPreconnected (Set.Ioi a)","decl":"theorem isPreconnected_Ioi : IsPreconnected (Ioi a) :=\n  ordConnected_Ioi.isPreconnected\n\n"}
{"name":"isPreconnected_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nâŠ¢ IsPreconnected (Set.Ioo a b)","decl":"theorem isPreconnected_Ioo : IsPreconnected (Ioo a b) :=\n  ordConnected_Ioo.isPreconnected\n\n"}
{"name":"isPreconnected_Ioc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nâŠ¢ IsPreconnected (Set.Ioc a b)","decl":"theorem isPreconnected_Ioc : IsPreconnected (Ioc a b) :=\n  ordConnected_Ioc.isPreconnected\n\n"}
{"name":"isPreconnected_Ico","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nâŠ¢ IsPreconnected (Set.Ico a b)","decl":"theorem isPreconnected_Ico : IsPreconnected (Ico a b) :=\n  ordConnected_Ico.isPreconnected\n\n"}
{"name":"isConnected_Ici","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na : Î±\nâŠ¢ IsConnected (Set.Ici a)","decl":"theorem isConnected_Ici : IsConnected (Ici a) :=\n  âŸ¨nonempty_Ici, isPreconnected_IciâŸ©\n\n"}
{"name":"isConnected_Iic","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na : Î±\nâŠ¢ IsConnected (Set.Iic a)","decl":"theorem isConnected_Iic : IsConnected (Iic a) :=\n  âŸ¨nonempty_Iic, isPreconnected_IicâŸ©\n\n"}
{"name":"isConnected_Ioi","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ´ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : DenselyOrdered Î±\na : Î±\ninstâœ : NoMaxOrder Î±\nâŠ¢ IsConnected (Set.Ioi a)","decl":"theorem isConnected_Ioi [NoMaxOrder Î±] : IsConnected (Ioi a) :=\n  âŸ¨nonempty_Ioi, isPreconnected_IoiâŸ©\n\n"}
{"name":"isConnected_Iio","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ´ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : DenselyOrdered Î±\na : Î±\ninstâœ : NoMinOrder Î±\nâŠ¢ IsConnected (Set.Iio a)","decl":"theorem isConnected_Iio [NoMinOrder Î±] : IsConnected (Iio a) :=\n  âŸ¨nonempty_Iio, isPreconnected_IioâŸ©\n\n"}
{"name":"isConnected_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nh : LE.le a b\nâŠ¢ IsConnected (Set.Icc a b)","decl":"theorem isConnected_Icc (h : a â‰¤ b) : IsConnected (Icc a b) :=\n  âŸ¨nonempty_Icc.2 h, isPreconnected_IccâŸ©\n\n"}
{"name":"isConnected_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nh : LT.lt a b\nâŠ¢ IsConnected (Set.Ioo a b)","decl":"theorem isConnected_Ioo (h : a < b) : IsConnected (Ioo a b) :=\n  âŸ¨nonempty_Ioo.2 h, isPreconnected_IooâŸ©\n\n"}
{"name":"isConnected_Ioc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nh : LT.lt a b\nâŠ¢ IsConnected (Set.Ioc a b)","decl":"theorem isConnected_Ioc (h : a < b) : IsConnected (Ioc a b) :=\n  âŸ¨nonempty_Ioc.2 h, isPreconnected_IocâŸ©\n\n"}
{"name":"isConnected_Ico","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nh : LT.lt a b\nâŠ¢ IsConnected (Set.Ico a b)","decl":"theorem isConnected_Ico (h : a < b) : IsConnected (Ico a b) :=\n  âŸ¨nonempty_Ico.2 h, isPreconnected_IcoâŸ©\n\n"}
{"name":"ordered_connected_space","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\nâŠ¢ PreconnectedSpace Î±","decl":"instance (priority := 100) ordered_connected_space : PreconnectedSpace Î± :=\n  âŸ¨ordConnected_univ.isPreconnectedâŸ©\n\n"}
{"name":"setOf_isPreconnected_eq_of_ordered","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\nâŠ¢ Eq (setOf fun s => IsPreconnected s) (Union.union (Union.union (Union.union (Union.union (Set.range (Function.uncurry Set.Icc)) (Set.range (Function.uncurry Set.Ico))) (Set.range (Function.uncurry Set.Ioc))) (Set.range (Function.uncurry Set.Ioo))) (Union.union (Union.union (Union.union (Union.union (Set.range Set.Ici) (Set.range Set.Ioi)) (Set.range Set.Iic)) (Set.range Set.Iio)) (Insert.insert Set.univ (Singleton.singleton EmptyCollection.emptyCollection))))","decl":"/-- In a dense conditionally complete linear order, the set of preconnected sets is exactly\nthe set of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`, `Iic`, `Iio`, `(-âˆ, +âˆ)`,\nor `âˆ…`. Though one can represent `âˆ…` as `(sInf s, sInf s)`, we include it into the list of\npossible cases to improve readability. -/\ntheorem setOf_isPreconnected_eq_of_ordered :\n    { s : Set Î± | IsPreconnected s } =\n      -- bounded intervals\n      range (uncurry Icc) âˆª range (uncurry Ico) âˆª range (uncurry Ioc) âˆª range (uncurry Ioo) âˆª\n      -- unbounded intervals and `univ`\n      (range Ici âˆª range Ioi âˆª range Iic âˆª range Iio âˆª {univ, âˆ…}) := by\n  refine Subset.antisymm setOf_isPreconnected_subset_of_ordered ?_\n  simp only [subset_def, forall_mem_range, uncurry, or_imp, forall_and, mem_union,\n    mem_setOf_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true,\n    isPreconnected_Icc, isPreconnected_Ico, isPreconnected_Ioc, isPreconnected_Ioo,\n    isPreconnected_Ioi, isPreconnected_Iio, isPreconnected_Ici, isPreconnected_Iic,\n    isPreconnected_univ, isPreconnected_empty]\n\n"}
{"name":"isTotallyDisconnected_iff_lt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\ns : Set Î±\nâŠ¢ Iff (IsTotallyDisconnected s) (âˆ€ (x : Î±), Membership.mem s x â†’ âˆ€ (y : Î±), Membership.mem s y â†’ LT.lt x y â†’ Exists fun z => And (Not (Membership.mem s z)) (Membership.mem (Set.Ioo x y) z))","decl":"/-- This lemmas characterizes when a subset `s` of a densely ordered conditionally complete linear\norder is totally disconnected with respect to the order topology: between any two distinct points\nof `s` must lie a point not in `s`. -/\nlemma isTotallyDisconnected_iff_lt {s : Set Î±} :\n    IsTotallyDisconnected s â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, x < y â†’ âˆƒ z âˆ‰ s, z âˆˆ Ioo x y := by\n  simp only [IsTotallyDisconnected, isPreconnected_iff_ordConnected, â† not_nontrivial_iff,\n    nontrivial_iff_exists_lt, not_exists, not_and]\n  refine âŸ¨fun h x hx y hy hxy â†¦ ?_, fun h t hts ht x hx y hy hxy â†¦ ?_âŸ©\n  Â· simp_rw [â† not_ordConnected_inter_Icc_iff hx hy]\n    exact fun hs â†¦ h _ inter_subset_left hs _ âŸ¨hx, le_rfl, hxy.leâŸ© _ âŸ¨hy, hxy.le, le_rflâŸ© hxy\n  Â· obtain âŸ¨z, h1z, h2zâŸ© := h x (hts hx) y (hts hy) hxy\n    exact h1z <| hts <| ht.1 hx hy âŸ¨h2z.1.le, h2z.2.leâŸ©\n\n"}
{"name":"intermediate_value_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nhab : LE.le a b\nf : Î± â†’ Î´\nhf : ContinuousOn f (Set.Icc a b)\nâŠ¢ HasSubset.Subset (Set.Icc (f a) (f b)) (Set.image f (Set.Icc a b))","decl":"/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a â‰¤ t â‰¤ f b`. -/\ntheorem intermediate_value_Icc {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : ContinuousOn f (Icc a b)) :\n    Icc (f a) (f b) âŠ† f '' Icc a b :=\n  isPreconnected_Icc.intermediate_value (left_mem_Icc.2 hab) (right_mem_Icc.2 hab) hf\n\n"}
{"name":"intermediate_value_Icc'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nhab : LE.le a b\nf : Î± â†’ Î´\nhf : ContinuousOn f (Set.Icc a b)\nâŠ¢ HasSubset.Subset (Set.Icc (f b) (f a)) (Set.image f (Set.Icc a b))","decl":"/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a â‰¥ t â‰¥ f b`. -/\ntheorem intermediate_value_Icc' {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´}\n    (hf : ContinuousOn f (Icc a b)) : Icc (f b) (f a) âŠ† f '' Icc a b :=\n  isPreconnected_Icc.intermediate_value (right_mem_Icc.2 hab) (left_mem_Icc.2 hab) hf\n\n"}
{"name":"intermediate_value_uIcc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nf : Î± â†’ Î´\nhf : ContinuousOn f (Set.uIcc a b)\nâŠ¢ HasSubset.Subset (Set.uIcc (f a) (f b)) (Set.image f (Set.uIcc a b))","decl":"/-- **Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. -/\ntheorem intermediate_value_uIcc {a b : Î±} {f : Î± â†’ Î´} (hf : ContinuousOn f [[a, b]]) :\n    [[f a, f b]] âŠ† f '' uIcc a b := by\n  cases le_total (f a) (f b) <;> simp [*, isPreconnected_uIcc.intermediate_value]\n\n"}
{"name":"exists_mem_uIcc_isFixedPt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nf : Î± â†’ Î±\nhf : ContinuousOn f (Set.uIcc a b)\nha : LE.le a (f a)\nhb : LE.le (f b) b\nâŠ¢ Exists fun c => And (Membership.mem (Set.uIcc a b) c) (Function.IsFixedPt f c)","decl":"/-- If `f : Î± â†’ Î±` is continuous on `[[a, b]]`, `a â‰¤ f a`, and `f b â‰¤ b`,\nthen `f` has a fixed point on `[[a, b]]`. -/\ntheorem exists_mem_uIcc_isFixedPt {a b : Î±} {f : Î± â†’ Î±} (hf : ContinuousOn f (uIcc a b))\n    (ha : a â‰¤ f a) (hb : f b â‰¤ b) : âˆƒ c âˆˆ [[a, b]], IsFixedPt f c :=\n  isPreconnected_uIcc.intermediate_valueâ‚‚ right_mem_uIcc left_mem_uIcc hf continuousOn_id hb ha\n\n"}
{"name":"exists_mem_Icc_isFixedPt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nf : Î± â†’ Î±\nhf : ContinuousOn f (Set.Icc a b)\nhle : LE.le a b\nha : LE.le a (f a)\nhb : LE.le (f b) b\nâŠ¢ Exists fun c => And (Membership.mem (Set.Icc a b) c) (Function.IsFixedPt f c)","decl":"/-- If `f : Î± â†’ Î±` is continuous on `[a, b]`, `a â‰¤ b`, `a â‰¤ f a`, and `f b â‰¤ b`,\nthen `f` has a fixed point on `[a, b]`.\n\nIn particular, if `[a, b]` is forward-invariant under `f`,\nthen `f` has a fixed point on `[a, b]`, see `exists_mem_Icc_isFixedPt_of_mapsTo`. -/\ntheorem exists_mem_Icc_isFixedPt {a b : Î±} {f : Î± â†’ Î±} (hf : ContinuousOn f (Icc a b))\n    (hle : a â‰¤ b) (ha : a â‰¤ f a) (hb : f b â‰¤ b) : âˆƒ c âˆˆ Icc a b, IsFixedPt f c :=\n  isPreconnected_Icc.intermediate_valueâ‚‚\n    (right_mem_Icc.2 hle) (left_mem_Icc.2 hle) hf continuousOn_id hb ha\n\n"}
{"name":"exists_mem_Icc_isFixedPt_of_mapsTo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\na b : Î±\nf : Î± â†’ Î±\nhf : ContinuousOn f (Set.Icc a b)\nhle : LE.le a b\nhmaps : Set.MapsTo f (Set.Icc a b) (Set.Icc a b)\nâŠ¢ Exists fun c => And (Membership.mem (Set.Icc a b) c) (Function.IsFixedPt f c)","decl":"/-- If a closed interval is forward-invariant under a continuous map `f : Î± â†’ Î±`,\nthen this map has a fixed point on this interval. -/\ntheorem exists_mem_Icc_isFixedPt_of_mapsTo {a b : Î±} {f : Î± â†’ Î±} (hf : ContinuousOn f (Icc a b))\n    (hle : a â‰¤ b) (hmaps : MapsTo f (Icc a b) (Icc a b)) : âˆƒ c âˆˆ Icc a b, IsFixedPt f c :=\n  exists_mem_Icc_isFixedPt hf hle (hmaps <| left_mem_Icc.2 hle).1 (hmaps <| right_mem_Icc.2 hle).2\n\n"}
{"name":"intermediate_value_Ico","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nhab : LE.le a b\nf : Î± â†’ Î´\nhf : ContinuousOn f (Set.Icc a b)\nâŠ¢ HasSubset.Subset (Set.Ico (f a) (f b)) (Set.image f (Set.Ico a b))","decl":"theorem intermediate_value_Ico {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : ContinuousOn f (Icc a b)) :\n    Ico (f a) (f b) âŠ† f '' Ico a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.2 (not_lt_of_le (he â–¸ h.1))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ico _ _ _ _ _ _ _ isPreconnected_Ico _ _ âŸ¨refl a, hltâŸ©\n      (right_nhdsWithin_Ico_neBot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self) _\n      ((hf.continuousWithinAt âŸ¨hab, refl bâŸ©).mono Ico_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ico'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nhab : LE.le a b\nf : Î± â†’ Î´\nhf : ContinuousOn f (Set.Icc a b)\nâŠ¢ HasSubset.Subset (Set.Ioc (f b) (f a)) (Set.image f (Set.Ico a b))","decl":"theorem intermediate_value_Ico' {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´}\n    (hf : ContinuousOn f (Icc a b)) : Ioc (f b) (f a) âŠ† f '' Ico a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.1 (not_lt_of_le (he â–¸ h.2))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioc _ _ _ _ _ _ _ isPreconnected_Ico _ _ âŸ¨refl a, hltâŸ©\n      (right_nhdsWithin_Ico_neBot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self) _\n      ((hf.continuousWithinAt âŸ¨hab, refl bâŸ©).mono Ico_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ioc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nhab : LE.le a b\nf : Î± â†’ Î´\nhf : ContinuousOn f (Set.Icc a b)\nâŠ¢ HasSubset.Subset (Set.Ioc (f a) (f b)) (Set.image f (Set.Ioc a b))","decl":"theorem intermediate_value_Ioc {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : ContinuousOn f (Icc a b)) :\n    Ioc (f a) (f b) âŠ† f '' Ioc a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.2 (not_le_of_lt (he â–¸ h.1))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioc _ _ _ _ _ _ _ isPreconnected_Ioc _ _ âŸ¨hlt, refl bâŸ©\n      (left_nhdsWithin_Ioc_neBot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self) _\n      ((hf.continuousWithinAt âŸ¨refl a, habâŸ©).mono Ioc_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ioc'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nhab : LE.le a b\nf : Î± â†’ Î´\nhf : ContinuousOn f (Set.Icc a b)\nâŠ¢ HasSubset.Subset (Set.Ico (f b) (f a)) (Set.image f (Set.Ioc a b))","decl":"theorem intermediate_value_Ioc' {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´}\n    (hf : ContinuousOn f (Icc a b)) : Ico (f b) (f a) âŠ† f '' Ioc a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.1 (not_le_of_lt (he â–¸ h.2))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ico _ _ _ _ _ _ _ isPreconnected_Ioc _ _ âŸ¨hlt, refl bâŸ©\n      (left_nhdsWithin_Ioc_neBot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self) _\n      ((hf.continuousWithinAt âŸ¨refl a, habâŸ©).mono Ioc_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nhab : LE.le a b\nf : Î± â†’ Î´\nhf : ContinuousOn f (Set.Icc a b)\nâŠ¢ HasSubset.Subset (Set.Ioo (f a) (f b)) (Set.image f (Set.Ioo a b))","decl":"theorem intermediate_value_Ioo {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : ContinuousOn f (Icc a b)) :\n    Ioo (f a) (f b) âŠ† f '' Ioo a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.2 (not_lt_of_lt (he â–¸ h.1))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioo _ _ _ _ _ _ _ isPreconnected_Ioo _ _\n      (left_nhdsWithin_Ioo_neBot hlt) (right_nhdsWithin_Ioo_neBot hlt) inf_le_right inf_le_right _\n      (hf.mono Ioo_subset_Icc_self) _ _\n      ((hf.continuousWithinAt âŸ¨refl a, habâŸ©).mono Ioo_subset_Icc_self)\n      ((hf.continuousWithinAt âŸ¨hab, refl bâŸ©).mono Ioo_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ioo'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nhab : LE.le a b\nf : Î± â†’ Î´\nhf : ContinuousOn f (Set.Icc a b)\nâŠ¢ HasSubset.Subset (Set.Ioo (f b) (f a)) (Set.image f (Set.Ioo a b))","decl":"theorem intermediate_value_Ioo' {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´}\n    (hf : ContinuousOn f (Icc a b)) : Ioo (f b) (f a) âŠ† f '' Ioo a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.1 (not_lt_of_lt (he â–¸ h.2))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioo _ _ _ _ _ _ _ isPreconnected_Ioo _ _\n      (right_nhdsWithin_Ioo_neBot hlt) (left_nhdsWithin_Ioo_neBot hlt) inf_le_right inf_le_right _\n      (hf.mono Ioo_subset_Icc_self) _ _\n      ((hf.continuousWithinAt âŸ¨hab, refl bâŸ©).mono Ioo_subset_Icc_self)\n      ((hf.continuousWithinAt âŸ¨refl a, habâŸ©).mono Ioo_subset_Icc_self)\n\n"}
{"name":"ContinuousOn.surjOn_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\ns : Set Î±\nhs : s.OrdConnected\nf : Î± â†’ Î´\nhf : ContinuousOn f s\na b : Î±\nha : Membership.mem s a\nhb : Membership.mem s b\nâŠ¢ Set.SurjOn f s (Set.Icc (f a) (f b))","decl":"/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `Icc (f x) (f y)`. -/\ntheorem ContinuousOn.surjOn_Icc {s : Set Î±} [hs : OrdConnected s] {f : Î± â†’ Î´}\n    (hf : ContinuousOn f s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) : SurjOn f s (Icc (f a) (f b)) :=\n  hs.isPreconnected.intermediate_value ha hb hf\n\n"}
{"name":"ContinuousOn.surjOn_uIcc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\ns : Set Î±\nhs : s.OrdConnected\nf : Î± â†’ Î´\nhf : ContinuousOn f s\na b : Î±\nha : Membership.mem s a\nhb : Membership.mem s b\nâŠ¢ Set.SurjOn f s (Set.uIcc (f a) (f b))","decl":"/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. -/\ntheorem ContinuousOn.surjOn_uIcc {s : Set Î±} [hs : OrdConnected s] {f : Î± â†’ Î´}\n    (hf : ContinuousOn f s) {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) :\n    SurjOn f s (uIcc (f a) (f b)) := by\n  rcases le_total (f a) (f b) with hab | hab <;> simp [hf.surjOn_Icc, *]\n\n"}
{"name":"Continuous.surjective","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\nf : Î± â†’ Î´\nhf : Continuous f\nh_top : Filter.Tendsto f Filter.atTop Filter.atTop\nh_bot : Filter.Tendsto f Filter.atBot Filter.atBot\nâŠ¢ Function.Surjective f","decl":"/-- A continuous function which tendsto `Filter.atTop` along `Filter.atTop` and to `atBot` along\n`at_bot` is surjective. -/\ntheorem Continuous.surjective {f : Î± â†’ Î´} (hf : Continuous f) (h_top : Tendsto f atTop atTop)\n    (h_bot : Tendsto f atBot atBot) : Function.Surjective f := fun p =>\n  mem_range_of_exists_le_of_exists_ge hf (h_bot.eventually (eventually_le_atBot p)).exists\n    (h_top.eventually (eventually_ge_atTop p)).exists\n\n"}
{"name":"Continuous.surjective'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\nf : Î± â†’ Î´\nhf : Continuous f\nh_top : Filter.Tendsto f Filter.atBot Filter.atTop\nh_bot : Filter.Tendsto f Filter.atTop Filter.atBot\nâŠ¢ Function.Surjective f","decl":"/-- A continuous function which tendsto `Filter.atBot` along `Filter.atTop` and to `Filter.atTop`\nalong `atBot` is surjective. -/\ntheorem Continuous.surjective' {f : Î± â†’ Î´} (hf : Continuous f) (h_top : Tendsto f atBot atTop)\n    (h_bot : Tendsto f atTop atBot) : Function.Surjective f :=\n  Continuous.surjective (Î± := Î±áµ’áµˆ) hf h_top h_bot\n\n"}
{"name":"ContinuousOn.surjOn_of_tendsto","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ· : ConditionallyCompleteLinearOrder Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : OrderTopology Î±\ninstâœâ´ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ³ : LinearOrder Î´\ninstâœÂ² : TopologicalSpace Î´\ninstâœÂ¹ : OrderClosedTopology Î´\nf : Î± â†’ Î´\ns : Set Î±\ninstâœ : s.OrdConnected\nhs : s.Nonempty\nhf : ContinuousOn f s\nhbot : Filter.Tendsto (fun x => f â†‘x) Filter.atBot Filter.atBot\nhtop : Filter.Tendsto (fun x => f â†‘x) Filter.atTop Filter.atTop\nâŠ¢ Set.SurjOn f s Set.univ","decl":"/-- If a function `f : Î± â†’ Î²` is continuous on a nonempty interval `s`, its restriction to `s`\ntends to `at_bot : Filter Î²` along `at_bot : Filter â†¥s` and tends to `Filter.atTop : Filter Î²` along\n`Filter.atTop : Filter â†¥s`, then the restriction of `f` to `s` is surjective. We formulate the\nconclusion as `Function.surjOn f s Set.univ`. -/\ntheorem ContinuousOn.surjOn_of_tendsto {f : Î± â†’ Î´} {s : Set Î±} [OrdConnected s] (hs : s.Nonempty)\n    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atBot)\n    (htop : Tendsto (fun x : s => f x) atTop atTop) : SurjOn f s univ :=\n  haveI := Classical.inhabited_of_nonempty hs.to_subtype\n  surjOn_iff_surjective.2 <| hf.restrict.surjective htop hbot\n\n"}
{"name":"ContinuousOn.surjOn_of_tendsto'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ· : ConditionallyCompleteLinearOrder Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : OrderTopology Î±\ninstâœâ´ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ³ : LinearOrder Î´\ninstâœÂ² : TopologicalSpace Î´\ninstâœÂ¹ : OrderClosedTopology Î´\nf : Î± â†’ Î´\ns : Set Î±\ninstâœ : s.OrdConnected\nhs : s.Nonempty\nhf : ContinuousOn f s\nhbot : Filter.Tendsto (fun x => f â†‘x) Filter.atBot Filter.atTop\nhtop : Filter.Tendsto (fun x => f â†‘x) Filter.atTop Filter.atBot\nâŠ¢ Set.SurjOn f s Set.univ","decl":"/-- If a function `f : Î± â†’ Î²` is continuous on a nonempty interval `s`, its restriction to `s`\ntends to `Filter.atTop : Filter Î²` along `Filter.atBot : Filter â†¥s` and tends to\n`Filter.atBot : Filter Î²` along `Filter.atTop : Filter â†¥s`, then the restriction of `f` to `s` is\nsurjective. We formulate the conclusion as `Function.surjOn f s Set.univ`. -/\ntheorem ContinuousOn.surjOn_of_tendsto' {f : Î± â†’ Î´} {s : Set Î±} [OrdConnected s] (hs : s.Nonempty)\n    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atTop)\n    (htop : Tendsto (fun x : s => f x) atTop atBot) : SurjOn f s univ :=\n  ContinuousOn.surjOn_of_tendsto (Î´ := Î´áµ’áµˆ) hs hf hbot htop\n\n"}
{"name":"Continuous.strictMono_of_inj_boundedOrder","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ· : ConditionallyCompleteLinearOrder Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : OrderTopology Î±\ninstâœâ´ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ³ : LinearOrder Î´\ninstâœÂ² : TopologicalSpace Î´\ninstâœÂ¹ : OrderClosedTopology Î´\ninstâœ : BoundedOrder Î±\nf : Î± â†’ Î´\nhf_c : Continuous f\nhf : LE.le (f Bot.bot) (f Top.top)\nhf_i : Function.Injective f\nâŠ¢ StrictMono f","decl":"theorem Continuous.strictMono_of_inj_boundedOrder [BoundedOrder Î±] {f : Î± â†’ Î´}\n    (hf_c : Continuous f) (hf : f âŠ¥ â‰¤ f âŠ¤) (hf_i : Injective f) : StrictMono f := by\n  intro a b hab\n  by_contra! h\n  have H : f b < f a := lt_of_le_of_ne h <| hf_i.ne hab.ne'\n  by_cases ha : f a â‰¤ f âŠ¥\n  Â· obtain âŸ¨u, huâŸ© := intermediate_value_Ioc le_top hf_c.continuousOn âŸ¨H.trans_le ha, hfâŸ©\n    have : u = âŠ¥ := hf_i hu.2\n    aesop\n  Â· by_cases hb : f âŠ¥ < f b\n    Â· obtain âŸ¨u, huâŸ© := intermediate_value_Ioo bot_le hf_c.continuousOn âŸ¨hb, HâŸ©\n      rw [hf_i hu.2] at hu\n      exact (hab.trans hu.1.2).false\n    Â· push_neg at ha hb\n      replace hb : f b < f âŠ¥ := lt_of_le_of_ne hb <| hf_i.ne (lt_of_lt_of_le' hab bot_le).ne'\n      obtain âŸ¨u, huâŸ© := intermediate_value_Ioo' hab.le hf_c.continuousOn âŸ¨hb, haâŸ©\n      have : u = âŠ¥ := hf_i hu.2\n      aesop\n\n"}
{"name":"Continuous.strictAnti_of_inj_boundedOrder","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ· : ConditionallyCompleteLinearOrder Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : OrderTopology Î±\ninstâœâ´ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ³ : LinearOrder Î´\ninstâœÂ² : TopologicalSpace Î´\ninstâœÂ¹ : OrderClosedTopology Î´\ninstâœ : BoundedOrder Î±\nf : Î± â†’ Î´\nhf_c : Continuous f\nhf : LE.le (f Top.top) (f Bot.bot)\nhf_i : Function.Injective f\nâŠ¢ StrictAnti f","decl":"theorem Continuous.strictAnti_of_inj_boundedOrder [BoundedOrder Î±] {f : Î± â†’ Î´}\n    (hf_c : Continuous f) (hf : f âŠ¤ â‰¤ f âŠ¥) (hf_i : Injective f) : StrictAnti f :=\n  hf_c.strictMono_of_inj_boundedOrder (Î´ := Î´áµ’áµˆ) hf hf_i\n\n"}
{"name":"Continuous.strictMono_of_inj_boundedOrder'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ· : ConditionallyCompleteLinearOrder Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : OrderTopology Î±\ninstâœâ´ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ³ : LinearOrder Î´\ninstâœÂ² : TopologicalSpace Î´\ninstâœÂ¹ : OrderClosedTopology Î´\ninstâœ : BoundedOrder Î±\nf : Î± â†’ Î´\nhf_c : Continuous f\nhf_i : Function.Injective f\nâŠ¢ Or (StrictMono f) (StrictAnti f)","decl":"theorem Continuous.strictMono_of_inj_boundedOrder' [BoundedOrder Î±] {f : Î± â†’ Î´}\n    (hf_c : Continuous f) (hf_i : Injective f) : StrictMono f âˆ¨ StrictAnti f :=\n  (le_total (f âŠ¥) (f âŠ¤)).imp\n    (hf_c.strictMono_of_inj_boundedOrder Â· hf_i)\n    (hf_c.strictAnti_of_inj_boundedOrder Â· hf_i)\n\n"}
{"name":"Continuous.strictMonoOn_of_inj_rigidity","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\nf : Î± â†’ Î´\nhf_c : Continuous f\nhf_i : Function.Injective f\na b : Î±\nhab : LT.lt a b\nhf_mono : StrictMonoOn f (Set.Icc a b)\nâŠ¢ StrictMono f","decl":"/-- Suppose `Î±` is equipped with a conditionally complete linear dense order and `f : Î± â†’ Î´` is\ncontinuous and injective. Then `f` is strictly monotone (increasing) if\nit is strictly monotone (increasing) on some closed interval `[a, b]`. -/\ntheorem Continuous.strictMonoOn_of_inj_rigidity {f : Î± â†’ Î´}\n    (hf_c : Continuous f) (hf_i : Injective f) {a b : Î±} (hab : a < b)\n    (hf_mono : StrictMonoOn f (Icc a b)) : StrictMono f := by\n  intro x y hxy\n  let s := min a x\n  let t := max b y\n  have hsa : s â‰¤ a := min_le_left a x\n  have hbt : b â‰¤ t := le_max_left b y\n  have hf_mono_st : StrictMonoOn f (Icc s t) âˆ¨ StrictAntiOn f (Icc s t) := by\n    have : Fact (s â‰¤ t) := âŸ¨hsa.trans <| hbt.trans' hab.leâŸ©\n    have := Continuous.strictMono_of_inj_boundedOrder' (f := Set.restrict (Icc s t) f)\n      hf_c.continuousOn.restrict hf_i.injOn.injective\n    exact this.imp strictMono_restrict.mp strictAntiOn_iff_strictAnti.mpr\n  have (h : StrictAntiOn f (Icc s t)) : False := by\n    have : Icc a b âŠ† Icc s t := Icc_subset_Icc hsa hbt\n    replace : StrictAntiOn f (Icc a b) := StrictAntiOn.mono h this\n    replace : IsAntichain (Â· â‰¤ Â·) (Icc a b) :=\n      IsAntichain.of_strictMonoOn_antitoneOn hf_mono this.antitoneOn\n    exact this.not_lt (left_mem_Icc.mpr (le_of_lt hab)) (right_mem_Icc.mpr (le_of_lt hab)) hab\n  replace hf_mono_st : StrictMonoOn f (Icc s t) := hf_mono_st.resolve_right this\n  have hsx : s â‰¤ x := min_le_right a x\n  have hyt : y â‰¤ t := le_max_right b y\n  replace : Icc x y âŠ† Icc s t := Icc_subset_Icc hsx hyt\n  replace : StrictMonoOn f (Icc x y) := StrictMonoOn.mono hf_mono_st this\n  exact this (left_mem_Icc.mpr (le_of_lt hxy)) (right_mem_Icc.mpr (le_of_lt hxy)) hxy\n\n"}
{"name":"ContinuousOn.strictMonoOn_of_injOn_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nf : Î± â†’ Î´\nhab : LE.le a b\nhfab : LE.le (f a) (f b)\nhf_c : ContinuousOn f (Set.Icc a b)\nhf_i : Set.InjOn f (Set.Icc a b)\nâŠ¢ StrictMonoOn f (Set.Icc a b)","decl":"/-- Suppose `f : [a, b] â†’ Î´` is\ncontinuous and injective. Then `f` is strictly monotone (increasing) if `f(a) â‰¤ f(b)`. -/\ntheorem ContinuousOn.strictMonoOn_of_injOn_Icc {a b : Î±} {f : Î± â†’ Î´}\n    (hab : a â‰¤ b) (hfab : f a â‰¤ f b)\n    (hf_c : ContinuousOn f (Icc a b)) (hf_i : InjOn f (Icc a b)) :\n    StrictMonoOn f (Icc a b) := by\n  have : Fact (a â‰¤ b) := âŸ¨habâŸ©\n  refine StrictMono.of_restrict ?_\n  set g : Icc a b â†’ Î´ := Set.restrict (Icc a b) f\n  have hgab : g âŠ¥ â‰¤ g âŠ¤ := by aesop\n  exact Continuous.strictMono_of_inj_boundedOrder (f := g) hf_c.restrict hgab hf_i.injective\n\n"}
{"name":"ContinuousOn.strictAntiOn_of_injOn_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nf : Î± â†’ Î´\nhab : LE.le a b\nhfab : LE.le (f b) (f a)\nhf_c : ContinuousOn f (Set.Icc a b)\nhf_i : Set.InjOn f (Set.Icc a b)\nâŠ¢ StrictAntiOn f (Set.Icc a b)","decl":"/-- Suppose `f : [a, b] â†’ Î´` is\ncontinuous and injective. Then `f` is strictly antitone (decreasing) if `f(b) â‰¤ f(a)`. -/\ntheorem ContinuousOn.strictAntiOn_of_injOn_Icc {a b : Î±} {f : Î± â†’ Î´}\n    (hab : a â‰¤ b) (hfab : f b â‰¤ f a)\n    (hf_c : ContinuousOn f (Icc a b)) (hf_i : InjOn f (Icc a b)) :\n    StrictAntiOn f (Icc a b) := ContinuousOn.strictMonoOn_of_injOn_Icc (Î´ := Î´áµ’áµˆ) hab hfab hf_c hf_i\n\n"}
{"name":"ContinuousOn.strictMonoOn_of_injOn_Icc'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nf : Î± â†’ Î´\nhab : LE.le a b\nhf_c : ContinuousOn f (Set.Icc a b)\nhf_i : Set.InjOn f (Set.Icc a b)\nâŠ¢ Or (StrictMonoOn f (Set.Icc a b)) (StrictAntiOn f (Set.Icc a b))","decl":"/-- Suppose `f : [a, b] â†’ Î´` is continuous and injective. Then `f` is strictly monotone\nor antitone (increasing or decreasing). -/\ntheorem ContinuousOn.strictMonoOn_of_injOn_Icc' {a b : Î±} {f : Î± â†’ Î´} (hab : a â‰¤ b)\n    (hf_c : ContinuousOn f (Icc a b)) (hf_i : InjOn f (Icc a b)) :\n    StrictMonoOn f (Icc a b) âˆ¨ StrictAntiOn f (Icc a b) :=\n  (le_total (f a) (f b)).imp\n    (ContinuousOn.strictMonoOn_of_injOn_Icc hab Â· hf_c hf_i)\n    (ContinuousOn.strictAntiOn_of_injOn_Icc hab Â· hf_c hf_i)\n\n"}
{"name":"Continuous.strictMono_of_inj","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\nf : Î± â†’ Î´\nhf_c : Continuous f\nhf_i : Function.Injective f\nâŠ¢ Or (StrictMono f) (StrictAnti f)","decl":"/-- Suppose `Î±` is equipped with a conditionally complete linear dense order and `f : Î± â†’ Î´` is\ncontinuous and injective. Then `f` is strictly monotone or antitone (increasing or decreasing). -/\ntheorem Continuous.strictMono_of_inj {f : Î± â†’ Î´}\n    (hf_c : Continuous f) (hf_i : Injective f) : StrictMono f âˆ¨ StrictAnti f := by\n  have H {c d : Î±} (hcd : c < d) : StrictMono f âˆ¨ StrictAnti f :=\n    (hf_c.continuousOn.strictMonoOn_of_injOn_Icc' hcd.le hf_i.injOn).imp\n      (hf_c.strictMonoOn_of_inj_rigidity hf_i hcd)\n      (hf_c.strictMonoOn_of_inj_rigidity (Î´ := Î´áµ’áµˆ) hf_i hcd)\n  by_cases hn : Nonempty Î±\n  Â· let a : Î± := Classical.choice â€¹_â€º\n    by_cases h : âˆƒ b : Î±, a â‰  b\n    Â· choose b hb using h\n      by_cases hab : a < b\n      Â· exact H hab\n      Â· push_neg at hab\n        have : b < a := by exact Ne.lt_of_le (id (Ne.symm hb)) hab\n        exact H this\n    Â· push_neg at h\n      haveI : Subsingleton Î± := âŸ¨fun c d => Trans.trans (h c).symm (h d)âŸ©\n      exact Or.inl <| Subsingleton.strictMono f\n  Â· aesop\n\n"}
{"name":"ContinuousOn.strictMonoOn_of_injOn_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"Î± : Type u\ninstâœâ¶ : ConditionallyCompleteLinearOrder Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : OrderTopology Î±\ninstâœÂ³ : DenselyOrdered Î±\nÎ´ : Type u_1\ninstâœÂ² : LinearOrder Î´\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OrderClosedTopology Î´\na b : Î±\nf : Î± â†’ Î´\nhab : LT.lt a b\nhf_c : ContinuousOn f (Set.Ioo a b)\nhf_i : Set.InjOn f (Set.Ioo a b)\nâŠ¢ Or (StrictMonoOn f (Set.Ioo a b)) (StrictAntiOn f (Set.Ioo a b))","decl":"/-- Every continuous injective `f : (a, b) â†’ Î´` is strictly monotone\nor antitone (increasing or decreasing). -/\ntheorem ContinuousOn.strictMonoOn_of_injOn_Ioo {a b : Î±} {f : Î± â†’ Î´} (hab : a < b)\n    (hf_c : ContinuousOn f (Ioo a b)) (hf_i : InjOn f (Ioo a b)) :\n    StrictMonoOn f (Ioo a b) âˆ¨ StrictAntiOn f (Ioo a b) := by\n  haveI : Inhabited (Ioo a b) := Classical.inhabited_of_nonempty (nonempty_Ioo_subtype hab)\n  let g : Ioo a b â†’ Î´ := Set.restrict (Ioo a b) f\n  have : StrictMono g âˆ¨ StrictAnti g :=\n    Continuous.strictMono_of_inj hf_c.restrict hf_i.injective\n  exact this.imp strictMono_restrict.mp strictAntiOn_iff_strictAnti.mpr\n"}
