{"name":"intermediate_value_univ₂","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁴ : TopologicalSpace X\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : PreconnectedSpace X\na b : X\nf g : X → α\nhf : Continuous f\nhg : Continuous g\nha : LE.le (f a) (g a)\nhb : LE.le (g b) (f b)\n⊢ Exists fun x => Eq (f x) (g x)","decl":"/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem intermediate_value_univ₂ [PreconnectedSpace X] {a b : X} {f g : X → α} (hf : Continuous f)\n    (hg : Continuous g) (ha : f a ≤ g a) (hb : g b ≤ f b) : ∃ x, f x = g x := by\n  obtain ⟨x, _, hfg, hgf⟩ : (univ ∩ { x | f x ≤ g x ∧ g x ≤ f x }).Nonempty :=\n    isPreconnected_closed_iff.1 PreconnectedSpace.isPreconnected_univ _ _ (isClosed_le hf hg)\n      (isClosed_le hg hf) (fun _ _ => le_total _ _) ⟨a, trivial, ha⟩ ⟨b, trivial, hb⟩\n  exact ⟨x, le_antisymm hfg hgf⟩\n\n"}
{"name":"intermediate_value_univ₂_eventually₁","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : PreconnectedSpace X\na : X\nl : Filter X\ninst✝ : l.NeBot\nf g : X → α\nhf : Continuous f\nhg : Continuous g\nha : LE.le (f a) (g a)\nhe : l.EventuallyLE g f\n⊢ Exists fun x => Eq (f x) (g x)","decl":"theorem intermediate_value_univ₂_eventually₁ [PreconnectedSpace X] {a : X} {l : Filter X} [NeBot l]\n    {f g : X → α} (hf : Continuous f) (hg : Continuous g) (ha : f a ≤ g a) (he : g ≤ᶠ[l] f) :\n    ∃ x, f x = g x :=\n  let ⟨_, h⟩ := he.exists; intermediate_value_univ₂ hf hg ha h\n\n"}
{"name":"intermediate_value_univ₂_eventually₂","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : LinearOrder α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : OrderClosedTopology α\ninst✝² : PreconnectedSpace X\nl₁ l₂ : Filter X\ninst✝¹ : l₁.NeBot\ninst✝ : l₂.NeBot\nf g : X → α\nhf : Continuous f\nhg : Continuous g\nhe₁ : l₁.EventuallyLE f g\nhe₂ : l₂.EventuallyLE g f\n⊢ Exists fun x => Eq (f x) (g x)","decl":"theorem intermediate_value_univ₂_eventually₂ [PreconnectedSpace X] {l₁ l₂ : Filter X} [NeBot l₁]\n    [NeBot l₂] {f g : X → α} (hf : Continuous f) (hg : Continuous g) (he₁ : f ≤ᶠ[l₁] g)\n    (he₂ : g ≤ᶠ[l₂] f) : ∃ x, f x = g x :=\n  let ⟨_, h₁⟩ := he₁.exists\n  let ⟨_, h₂⟩ := he₂.exists\n  intermediate_value_univ₂ hf hg h₁ h₂\n\n"}
{"name":"IsPreconnected.intermediate_value₂","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\na b : X\nha : Membership.mem s a\nhb : Membership.mem s b\nf g : X → α\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nha' : LE.le (f a) (g a)\nhb' : LE.le (g b) (f b)\n⊢ Exists fun x => And (Membership.mem s x) (Eq (f x) (g x))","decl":"/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\nthen for some `x ∈ s` we have `f x = g x`. -/\ntheorem IsPreconnected.intermediate_value₂ {s : Set X} (hs : IsPreconnected s) {a b : X}\n    (ha : a ∈ s) (hb : b ∈ s) {f g : X → α} (hf : ContinuousOn f s) (hg : ContinuousOn g s)\n    (ha' : f a ≤ g a) (hb' : g b ≤ f b) : ∃ x ∈ s, f x = g x :=\n  let ⟨x, hx⟩ :=\n    @intermediate_value_univ₂ s α _ _ _ _ (Subtype.preconnectedSpace hs) ⟨a, ha⟩ ⟨b, hb⟩ _ _\n      (continuousOn_iff_continuous_restrict.1 hf) (continuousOn_iff_continuous_restrict.1 hg) ha'\n      hb'\n  ⟨x, x.2, hx⟩\n\n"}
{"name":"IsPreconnected.intermediate_value₂_eventually₁","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁴ : TopologicalSpace X\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninst✝ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf g : X → α\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nha' : LE.le (f a) (g a)\nhe : l.EventuallyLE g f\n⊢ Exists fun x => And (Membership.mem s x) (Eq (f x) (g x))","decl":"theorem IsPreconnected.intermediate_value₂_eventually₁ {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a ∈ s) [NeBot l] (hl : l ≤ 𝓟 s) {f g : X → α} (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) (ha' : f a ≤ g a) (he : g ≤ᶠ[l] f) : ∃ x ∈ s, f x = g x := by\n  rw [continuousOn_iff_continuous_restrict] at hf hg\n  obtain ⟨b, h⟩ :=\n    @intermediate_value_univ₂_eventually₁ _ _ _ _ _ _ (Subtype.preconnectedSpace hs) ⟨a, ha⟩ _\n      (comap_coe_neBot_of_le_principal hl) _ _ hf hg ha' (he.comap _)\n  exact ⟨b, b.prop, h⟩\n\n"}
{"name":"IsPreconnected.intermediate_value₂_eventually₂","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\nl₁ l₂ : Filter X\ninst✝¹ : l₁.NeBot\ninst✝ : l₂.NeBot\nhl₁ : LE.le l₁ (Filter.principal s)\nhl₂ : LE.le l₂ (Filter.principal s)\nf g : X → α\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nhe₁ : l₁.EventuallyLE f g\nhe₂ : l₂.EventuallyLE g f\n⊢ Exists fun x => And (Membership.mem s x) (Eq (f x) (g x))","decl":"theorem IsPreconnected.intermediate_value₂_eventually₂ {s : Set X} (hs : IsPreconnected s)\n    {l₁ l₂ : Filter X} [NeBot l₁] [NeBot l₂] (hl₁ : l₁ ≤ 𝓟 s) (hl₂ : l₂ ≤ 𝓟 s) {f g : X → α}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) (he₁ : f ≤ᶠ[l₁] g) (he₂ : g ≤ᶠ[l₂] f) :\n    ∃ x ∈ s, f x = g x := by\n  rw [continuousOn_iff_continuous_restrict] at hf hg\n  obtain ⟨b, h⟩ :=\n    @intermediate_value_univ₂_eventually₂ _ _ _ _ _ _ (Subtype.preconnectedSpace hs) _ _\n      (comap_coe_neBot_of_le_principal hl₁) (comap_coe_neBot_of_le_principal hl₂) _ _ hf hg\n      (he₁.comap _) (he₂.comap _)\n  exact ⟨b, b.prop, h⟩\n\n"}
{"name":"IsPreconnected.intermediate_value","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\na b : X\nha : Membership.mem s a\nhb : Membership.mem s b\nf : X → α\nhf : ContinuousOn f s\n⊢ HasSubset.Subset (Set.Icc (f a) (f b)) (Set.image f s)","decl":"/-- **Intermediate Value Theorem** for continuous functions on connected sets. -/\ntheorem IsPreconnected.intermediate_value {s : Set X} (hs : IsPreconnected s) {a b : X} (ha : a ∈ s)\n    (hb : b ∈ s) {f : X → α} (hf : ContinuousOn f s) : Icc (f a) (f b) ⊆ f '' s := fun _x hx =>\n  hs.intermediate_value₂ ha hb hf continuousOn_const hx.1 hx.2\n\n"}
{"name":"IsPreconnected.intermediate_value_Ico","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁴ : TopologicalSpace X\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninst✝ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf : X → α\nhf : ContinuousOn f s\nv : α\nht : Filter.Tendsto f l (nhds v)\n⊢ HasSubset.Subset (Set.Ico (f a) v) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ico {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a ∈ s) [NeBot l] (hl : l ≤ 𝓟 s) {f : X → α} (hf : ContinuousOn f s) {v : α}\n    (ht : Tendsto f l (𝓝 v)) : Ico (f a) v ⊆ f '' s := fun _ h =>\n  hs.intermediate_value₂_eventually₁ ha hl hf continuousOn_const h.1 (ht.eventually_const_le h.2)\n\n"}
{"name":"IsPreconnected.intermediate_value_Ioc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁴ : TopologicalSpace X\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninst✝ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf : X → α\nhf : ContinuousOn f s\nv : α\nht : Filter.Tendsto f l (nhds v)\n⊢ HasSubset.Subset (Set.Ioc v (f a)) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ioc {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a ∈ s) [NeBot l] (hl : l ≤ 𝓟 s) {f : X → α} (hf : ContinuousOn f s) {v : α}\n    (ht : Tendsto f l (𝓝 v)) : Ioc v (f a) ⊆ f '' s := fun _ h =>\n  (hs.intermediate_value₂_eventually₁ ha hl continuousOn_const hf h.2\n    (ht.eventually_le_const h.1)).imp fun _ h => h.imp_right Eq.symm\n\n"}
{"name":"IsPreconnected.intermediate_value_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\nl₁ l₂ : Filter X\ninst✝¹ : l₁.NeBot\ninst✝ : l₂.NeBot\nhl₁ : LE.le l₁ (Filter.principal s)\nhl₂ : LE.le l₂ (Filter.principal s)\nf : X → α\nhf : ContinuousOn f s\nv₁ v₂ : α\nht₁ : Filter.Tendsto f l₁ (nhds v₁)\nht₂ : Filter.Tendsto f l₂ (nhds v₂)\n⊢ HasSubset.Subset (Set.Ioo v₁ v₂) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ioo {s : Set X} (hs : IsPreconnected s) {l₁ l₂ : Filter X}\n    [NeBot l₁] [NeBot l₂] (hl₁ : l₁ ≤ 𝓟 s) (hl₂ : l₂ ≤ 𝓟 s) {f : X → α} (hf : ContinuousOn f s)\n    {v₁ v₂ : α} (ht₁ : Tendsto f l₁ (𝓝 v₁)) (ht₂ : Tendsto f l₂ (𝓝 v₂)) :\n    Ioo v₁ v₂ ⊆ f '' s := fun _ h =>\n  hs.intermediate_value₂_eventually₂ hl₁ hl₂ hf continuousOn_const\n    (ht₁.eventually_le_const h.1) (ht₂.eventually_const_le h.2)\n\n"}
{"name":"IsPreconnected.intermediate_value_Ici","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁴ : TopologicalSpace X\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninst✝ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf : X → α\nhf : ContinuousOn f s\nht : Filter.Tendsto f l Filter.atTop\n⊢ HasSubset.Subset (Set.Ici (f a)) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ici {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a ∈ s) [NeBot l] (hl : l ≤ 𝓟 s) {f : X → α} (hf : ContinuousOn f s)\n    (ht : Tendsto f l atTop) : Ici (f a) ⊆ f '' s := fun y h =>\n  hs.intermediate_value₂_eventually₁ ha hl hf continuousOn_const h (tendsto_atTop.1 ht y)\n\n"}
{"name":"IsPreconnected.intermediate_value_Iic","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁴ : TopologicalSpace X\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\na : X\nl : Filter X\nha : Membership.mem s a\ninst✝ : l.NeBot\nhl : LE.le l (Filter.principal s)\nf : X → α\nhf : ContinuousOn f s\nht : Filter.Tendsto f l Filter.atBot\n⊢ HasSubset.Subset (Set.Iic (f a)) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Iic {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a ∈ s) [NeBot l] (hl : l ≤ 𝓟 s) {f : X → α} (hf : ContinuousOn f s)\n    (ht : Tendsto f l atBot) : Iic (f a) ⊆ f '' s := fun y h =>\n  (hs.intermediate_value₂_eventually₁ ha hl continuousOn_const hf h (tendsto_atBot.1 ht y)).imp\n    fun _ h => h.imp_right Eq.symm\n\n"}
{"name":"IsPreconnected.intermediate_value_Ioi","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\nl₁ l₂ : Filter X\ninst✝¹ : l₁.NeBot\ninst✝ : l₂.NeBot\nhl₁ : LE.le l₁ (Filter.principal s)\nhl₂ : LE.le l₂ (Filter.principal s)\nf : X → α\nhf : ContinuousOn f s\nv : α\nht₁ : Filter.Tendsto f l₁ (nhds v)\nht₂ : Filter.Tendsto f l₂ Filter.atTop\n⊢ HasSubset.Subset (Set.Ioi v) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Ioi {s : Set X} (hs : IsPreconnected s) {l₁ l₂ : Filter X}\n    [NeBot l₁] [NeBot l₂] (hl₁ : l₁ ≤ 𝓟 s) (hl₂ : l₂ ≤ 𝓟 s) {f : X → α} (hf : ContinuousOn f s)\n    {v : α} (ht₁ : Tendsto f l₁ (𝓝 v)) (ht₂ : Tendsto f l₂ atTop) : Ioi v ⊆ f '' s := fun y h =>\n  hs.intermediate_value₂_eventually₂ hl₁ hl₂ hf continuousOn_const\n    (ht₁.eventually_le_const h) (ht₂.eventually_ge_atTop y)\n\n"}
{"name":"IsPreconnected.intermediate_value_Iio","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\nl₁ l₂ : Filter X\ninst✝¹ : l₁.NeBot\ninst✝ : l₂.NeBot\nhl₁ : LE.le l₁ (Filter.principal s)\nhl₂ : LE.le l₂ (Filter.principal s)\nf : X → α\nhf : ContinuousOn f s\nv : α\nht₁ : Filter.Tendsto f l₁ Filter.atBot\nht₂ : Filter.Tendsto f l₂ (nhds v)\n⊢ HasSubset.Subset (Set.Iio v) (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Iio {s : Set X} (hs : IsPreconnected s) {l₁ l₂ : Filter X}\n    [NeBot l₁] [NeBot l₂] (hl₁ : l₁ ≤ 𝓟 s) (hl₂ : l₂ ≤ 𝓟 s) {f : X → α} (hf : ContinuousOn f s)\n    {v : α} (ht₁ : Tendsto f l₁ atBot) (ht₂ : Tendsto f l₂ (𝓝 v)) : Iio v ⊆ f '' s := fun y h =>\n  hs.intermediate_value₂_eventually₂ hl₁ hl₂ hf continuousOn_const (ht₁.eventually_le_atBot y)\n    (ht₂.eventually_const_le h)\n\n"}
{"name":"IsPreconnected.intermediate_value_Iii","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ns : Set X\nhs : IsPreconnected s\nl₁ l₂ : Filter X\ninst✝¹ : l₁.NeBot\ninst✝ : l₂.NeBot\nhl₁ : LE.le l₁ (Filter.principal s)\nhl₂ : LE.le l₂ (Filter.principal s)\nf : X → α\nhf : ContinuousOn f s\nht₁ : Filter.Tendsto f l₁ Filter.atBot\nht₂ : Filter.Tendsto f l₂ Filter.atTop\n⊢ HasSubset.Subset Set.univ (Set.image f s)","decl":"theorem IsPreconnected.intermediate_value_Iii {s : Set X} (hs : IsPreconnected s) {l₁ l₂ : Filter X}\n    [NeBot l₁] [NeBot l₂] (hl₁ : l₁ ≤ 𝓟 s) (hl₂ : l₂ ≤ 𝓟 s) {f : X → α} (hf : ContinuousOn f s)\n    (ht₁ : Tendsto f l₁ atBot) (ht₂ : Tendsto f l₂ atTop) : univ ⊆ f '' s := fun y _ =>\n  hs.intermediate_value₂_eventually₂ hl₁ hl₂ hf continuousOn_const (ht₁.eventually_le_atBot y)\n    (ht₂.eventually_ge_atTop y)\n\n"}
{"name":"intermediate_value_univ","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁴ : TopologicalSpace X\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : PreconnectedSpace X\na b : X\nf : X → α\nhf : Continuous f\n⊢ HasSubset.Subset (Set.Icc (f a) (f b)) (Set.range f)","decl":"/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/\ntheorem intermediate_value_univ [PreconnectedSpace X] (a b : X) {f : X → α} (hf : Continuous f) :\n    Icc (f a) (f b) ⊆ range f := fun _ hx => intermediate_value_univ₂ hf continuous_const hx.1 hx.2\n\n"}
{"name":"mem_range_of_exists_le_of_exists_ge","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"X : Type u\nα : Type v\ninst✝⁴ : TopologicalSpace X\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : PreconnectedSpace X\nc : α\nf : X → α\nhf : Continuous f\nh₁ : Exists fun a => LE.le (f a) c\nh₂ : Exists fun b => LE.le c (f b)\n⊢ Membership.mem (Set.range f) c","decl":"/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/\ntheorem mem_range_of_exists_le_of_exists_ge [PreconnectedSpace X] {c : α} {f : X → α}\n    (hf : Continuous f) (h₁ : ∃ a, f a ≤ c) (h₂ : ∃ b, c ≤ f b) : c ∈ range f :=\n  let ⟨a, ha⟩ := h₁; let ⟨b, hb⟩ := h₂; intermediate_value_univ a b hf ⟨ha, hb⟩\n\n"}
{"name":"IsPreconnected.Icc_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type v\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderClosedTopology α\ns : Set α\nhs : IsPreconnected s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ HasSubset.Subset (Set.Icc a b) s","decl":"/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/\ntheorem IsPreconnected.Icc_subset {s : Set α} (hs : IsPreconnected s) {a b : α} (ha : a ∈ s)\n    (hb : b ∈ s) : Icc a b ⊆ s := by\n  simpa only [image_id] using hs.intermediate_value ha hb continuousOn_id\n\n"}
{"name":"IsPreconnected.ordConnected","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type v\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderClosedTopology α\ns : Set α\nh : IsPreconnected s\n⊢ s.OrdConnected","decl":"theorem IsPreconnected.ordConnected {s : Set α} (h : IsPreconnected s) : OrdConnected s :=\n  ⟨fun _ hx _ hy => h.Icc_subset hx hy⟩\n\n"}
{"name":"IsConnected.Icc_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type v\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderClosedTopology α\ns : Set α\nhs : IsConnected s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ HasSubset.Subset (Set.Icc a b) s","decl":"/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/\ntheorem IsConnected.Icc_subset {s : Set α} (hs : IsConnected s) {a b : α} (ha : a ∈ s)\n    (hb : b ∈ s) : Icc a b ⊆ s :=\n  hs.2.Icc_subset ha hb\n\n"}
{"name":"IsPreconnected.eq_univ_of_unbounded","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type v\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderClosedTopology α\ns : Set α\nhs : IsPreconnected s\nhb : Not (BddBelow s)\nha : Not (BddAbove s)\n⊢ Eq s Set.univ","decl":"/-- If preconnected set in a linear order space is unbounded below and above, then it is the whole\nspace. -/\ntheorem IsPreconnected.eq_univ_of_unbounded {s : Set α} (hs : IsPreconnected s) (hb : ¬BddBelow s)\n    (ha : ¬BddAbove s) : s = univ := by\n  refine eq_univ_of_forall fun x => ?_\n  obtain ⟨y, ys, hy⟩ : ∃ y ∈ s, y < x := not_bddBelow_iff.1 hb x\n  obtain ⟨z, zs, hz⟩ : ∃ z ∈ s, x < z := not_bddAbove_iff.1 ha x\n  exact hs.Icc_subset ys zs ⟨le_of_lt hy, le_of_lt hz⟩\n\n"}
{"name":"IsConnected.Ioo_csInf_csSup_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\ns : Set α\nhs : IsConnected s\nhb : BddBelow s\nha : BddAbove s\n⊢ HasSubset.Subset (Set.Ioo (InfSet.sInf s) (SupSet.sSup s)) s","decl":"/-- A bounded connected subset of a conditionally complete linear order includes the open interval\n`(Inf s, Sup s)`. -/\ntheorem IsConnected.Ioo_csInf_csSup_subset {s : Set α} (hs : IsConnected s) (hb : BddBelow s)\n    (ha : BddAbove s) : Ioo (sInf s) (sSup s) ⊆ s := fun _x hx =>\n  let ⟨_y, ys, hy⟩ := (isGLB_lt_iff (isGLB_csInf hs.nonempty hb)).1 hx.1\n  let ⟨_z, zs, hz⟩ := (lt_isLUB_iff (isLUB_csSup hs.nonempty ha)).1 hx.2\n  hs.Icc_subset ys zs ⟨hy.le, hz.le⟩\n\n"}
{"name":"eq_Icc_csInf_csSup_of_connected_bdd_closed","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\ns : Set α\nhc : IsConnected s\nhb : BddBelow s\nha : BddAbove s\nhcl : IsClosed s\n⊢ Eq s (Set.Icc (InfSet.sInf s) (SupSet.sSup s))","decl":"theorem eq_Icc_csInf_csSup_of_connected_bdd_closed {s : Set α} (hc : IsConnected s)\n    (hb : BddBelow s) (ha : BddAbove s) (hcl : IsClosed s) : s = Icc (sInf s) (sSup s) :=\n  (subset_Icc_csInf_csSup hb ha).antisymm <|\n    hc.Icc_subset (hcl.csInf_mem hc.nonempty hb) (hcl.csSup_mem hc.nonempty ha)\n\n"}
{"name":"IsPreconnected.Ioi_csInf_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\ns : Set α\nhs : IsPreconnected s\nhb : BddBelow s\nha : Not (BddAbove s)\n⊢ HasSubset.Subset (Set.Ioi (InfSet.sInf s)) s","decl":"theorem IsPreconnected.Ioi_csInf_subset {s : Set α} (hs : IsPreconnected s) (hb : BddBelow s)\n    (ha : ¬BddAbove s) : Ioi (sInf s) ⊆ s := fun x hx =>\n  have sne : s.Nonempty := nonempty_of_not_bddAbove ha\n  let ⟨_y, ys, hy⟩ : ∃ y ∈ s, y < x := (isGLB_lt_iff (isGLB_csInf sne hb)).1 hx\n  let ⟨_z, zs, hz⟩ : ∃ z ∈ s, x < z := not_bddAbove_iff.1 ha x\n  hs.Icc_subset ys zs ⟨hy.le, hz.le⟩\n\n"}
{"name":"IsPreconnected.Iio_csSup_subset","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\ns : Set α\nhs : IsPreconnected s\nhb : Not (BddBelow s)\nha : BddAbove s\n⊢ HasSubset.Subset (Set.Iio (SupSet.sSup s)) s","decl":"theorem IsPreconnected.Iio_csSup_subset {s : Set α} (hs : IsPreconnected s) (hb : ¬BddBelow s)\n    (ha : BddAbove s) : Iio (sSup s) ⊆ s :=\n  IsPreconnected.Ioi_csInf_subset (α := αᵒᵈ) hs ha hb\n\n"}
{"name":"IsPreconnected.mem_intervals","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\ns : Set α\nhs : IsPreconnected s\n⊢ Membership.mem (Insert.insert (Set.Icc (InfSet.sInf s) (SupSet.sSup s)) (Insert.insert (Set.Ico (InfSet.sInf s) (SupSet.sSup s)) (Insert.insert (Set.Ioc (InfSet.sInf s) (SupSet.sSup s)) (Insert.insert (Set.Ioo (InfSet.sInf s) (SupSet.sSup s)) (Insert.insert (Set.Ici (InfSet.sInf s)) (Insert.insert (Set.Ioi (InfSet.sInf s)) (Insert.insert (Set.Iic (SupSet.sSup s)) (Insert.insert (Set.Iio (SupSet.sSup s)) (Insert.insert Set.univ (Singleton.singleton EmptyCollection.emptyCollection)))))))))) s","decl":"/-- A preconnected set in a conditionally complete linear order is either one of the intervals\n`[Inf s, Sup s]`, `[Inf s, Sup s)`, `(Inf s, Sup s]`, `(Inf s, Sup s)`, `[Inf s, +∞)`,\n`(Inf s, +∞)`, `(-∞, Sup s]`, `(-∞, Sup s)`, `(-∞, +∞)`, or `∅`. The converse statement requires\n`α` to be densely ordered. -/\ntheorem IsPreconnected.mem_intervals {s : Set α} (hs : IsPreconnected s) :\n    s ∈\n      ({Icc (sInf s) (sSup s), Ico (sInf s) (sSup s), Ioc (sInf s) (sSup s), Ioo (sInf s) (sSup s),\n          Ici (sInf s), Ioi (sInf s), Iic (sSup s), Iio (sSup s), univ, ∅} : Set (Set α)) := by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  · apply_rules [Or.inr, mem_singleton]\n  have hs' : IsConnected s := ⟨hne, hs⟩\n  by_cases hb : BddBelow s <;> by_cases ha : BddAbove s\n  · refine mem_of_subset_of_mem ?_ <| mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset\n      (hs'.Ioo_csInf_csSup_subset hb ha) (subset_Icc_csInf_csSup hb ha)\n    simp only [insert_subset_iff, mem_insert_iff, mem_singleton_iff, true_or, or_true,\n      singleton_subset_iff, and_self]\n  · refine Or.inr <| Or.inr <| Or.inr <| Or.inr ?_\n    cases'\n      mem_Ici_Ioi_of_subset_of_subset (hs.Ioi_csInf_subset hb ha) fun x hx => csInf_le hb hx with\n      hs hs\n    · exact Or.inl hs\n    · exact Or.inr (Or.inl hs)\n  · iterate 6 apply Or.inr\n    cases' mem_Iic_Iio_of_subset_of_subset (hs.Iio_csSup_subset hb ha) fun x hx => le_csSup ha hx\n      with hs hs\n    · exact Or.inl hs\n    · exact Or.inr (Or.inl hs)\n  · iterate 8 apply Or.inr\n    exact Or.inl (hs.eq_univ_of_unbounded hb ha)\n\n"}
{"name":"setOf_isPreconnected_subset_of_ordered","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\n⊢ HasSubset.Subset (setOf fun s => IsPreconnected s) (Union.union (Union.union (Union.union (Union.union (Set.range (Function.uncurry Set.Icc)) (Set.range (Function.uncurry Set.Ico))) (Set.range (Function.uncurry Set.Ioc))) (Set.range (Function.uncurry Set.Ioo))) (Union.union (Union.union (Union.union (Union.union (Set.range Set.Ici) (Set.range Set.Ioi)) (Set.range Set.Iic)) (Set.range Set.Iio)) (Insert.insert Set.univ (Singleton.singleton EmptyCollection.emptyCollection))))","decl":"/-- A preconnected set is either one of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`,\n`Iic`, `Iio`, or `univ`, or `∅`. The converse statement requires `α` to be densely ordered. Though\none can represent `∅` as `(Inf ∅, Inf ∅)`, we include it into the list of possible cases to improve\nreadability. -/\ntheorem setOf_isPreconnected_subset_of_ordered :\n    { s : Set α | IsPreconnected s } ⊆\n      -- bounded intervals\n      (range (uncurry Icc) ∪ range (uncurry Ico) ∪ range (uncurry Ioc) ∪ range (uncurry Ioo)) ∪\n      -- unbounded intervals and `univ`\n      (range Ici ∪ range Ioi ∪ range Iic ∪ range Iio ∪ {univ, ∅}) := by\n  intro s hs\n  rcases hs.mem_intervals with (hs | hs | hs | hs | hs | hs | hs | hs | hs | hs) <;> rw [hs] <;>\n    simp only [union_insert, union_singleton, mem_insert_iff, mem_union, mem_range, Prod.exists,\n      uncurry_apply_pair, exists_apply_eq_apply, true_or, or_true, exists_apply_eq_apply2]\n\n"}
{"name":"IsClosed.mem_of_ge_of_forall_exists_gt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\na b : α\ns : Set α\nhs : IsClosed (Inter.inter s (Set.Icc a b))\nha : Membership.mem s a\nhab : LE.le a b\nhgt : ∀ (x : α), Membership.mem (Inter.inter s (Set.Ico a b)) x → (Inter.inter s (Set.Ioc x b)).Nonempty\n⊢ Membership.mem s b","decl":"/-- A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and the set `s ∩ [a, b)` has no maximal point, then `b ∈ s`. -/\ntheorem IsClosed.mem_of_ge_of_forall_exists_gt {a b : α} {s : Set α} (hs : IsClosed (s ∩ Icc a b))\n    (ha : a ∈ s) (hab : a ≤ b) (hgt : ∀ x ∈ s ∩ Ico a b, (s ∩ Ioc x b).Nonempty) : b ∈ s := by\n  let S := s ∩ Icc a b\n  replace ha : a ∈ S := ⟨ha, left_mem_Icc.2 hab⟩\n  have Sbd : BddAbove S := ⟨b, fun z hz => hz.2.2⟩\n  let c := sSup (s ∩ Icc a b)\n  have c_mem : c ∈ S := hs.csSup_mem ⟨_, ha⟩ Sbd\n  have c_le : c ≤ b := csSup_le ⟨_, ha⟩ fun x hx => hx.2.2\n  cases' eq_or_lt_of_le c_le with hc hc\n  · exact hc ▸ c_mem.1\n  exfalso\n  rcases hgt c ⟨c_mem.1, c_mem.2.1, hc⟩ with ⟨x, xs, cx, xb⟩\n  exact not_lt_of_le (le_csSup Sbd ⟨xs, le_trans (le_csSup Sbd ha) (le_of_lt cx), xb⟩) cx\n\n"}
{"name":"IsClosed.Icc_subset_of_forall_exists_gt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\na b : α\ns : Set α\nhs : IsClosed (Inter.inter s (Set.Icc a b))\nha : Membership.mem s a\nhgt : ∀ (x : α), Membership.mem (Inter.inter s (Set.Ico a b)) x → ∀ (y : α), Membership.mem (Set.Ioi x) y → (Inter.inter s (Set.Ioc x y)).Nonempty\n⊢ HasSubset.Subset (Set.Icc a b) s","decl":"/-- A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and for any `a ≤ x < y ≤ b`, `x ∈ s`, the set `s ∩ (x, y]`\nis not empty, then `[a, b] ⊆ s`. -/\ntheorem IsClosed.Icc_subset_of_forall_exists_gt {a b : α} {s : Set α} (hs : IsClosed (s ∩ Icc a b))\n    (ha : a ∈ s) (hgt : ∀ x ∈ s ∩ Ico a b, ∀ y ∈ Ioi x, (s ∩ Ioc x y).Nonempty) : Icc a b ⊆ s := by\n  intro y hy\n  have : IsClosed (s ∩ Icc a y) := by\n    suffices s ∩ Icc a y = s ∩ Icc a b ∩ Icc a y by\n      rw [this]\n      exact IsClosed.inter hs isClosed_Icc\n    rw [inter_assoc]\n    congr\n    exact (inter_eq_self_of_subset_right <| Icc_subset_Icc_right hy.2).symm\n  exact\n    IsClosed.mem_of_ge_of_forall_exists_gt this ha hy.1 fun x hx =>\n      hgt x ⟨hx.1, Ico_subset_Ico_right hy.2 hx.2⟩ y hx.2.2\n\n"}
{"name":"IsClosed.Icc_subset_of_forall_mem_nhdsWithin","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\ns : Set α\nhs : IsClosed (Inter.inter s (Set.Icc a b))\nha : Membership.mem s a\nhgt : ∀ (x : α), Membership.mem (Inter.inter s (Set.Ico a b)) x → Membership.mem (nhdsWithin x (Set.Ioi x)) s\n⊢ HasSubset.Subset (Set.Icc a b) s","decl":"/-- A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and for any `x ∈ s ∩ [a, b)` the set `s` includes some open\nneighborhood of `x` within `(x, +∞)`, then `[a, b] ⊆ s`. -/\ntheorem IsClosed.Icc_subset_of_forall_mem_nhdsWithin {a b : α} {s : Set α}\n    (hs : IsClosed (s ∩ Icc a b)) (ha : a ∈ s) (hgt : ∀ x ∈ s ∩ Ico a b, s ∈ 𝓝[>] x) :\n    Icc a b ⊆ s := by\n  apply hs.Icc_subset_of_forall_exists_gt ha\n  rintro x ⟨hxs, hxab⟩ y hyxb\n  have : s ∩ Ioc x y ∈ 𝓝[>] x := inter_mem (hgt x ⟨hxs, hxab⟩) (Ioc_mem_nhdsGT hyxb)\n  exact (nhdsGT_neBot_of_exists_gt ⟨b, hxab.2⟩).nonempty_of_mem this\n\n"}
{"name":"isPreconnected_Icc_aux","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b x y : α\ns t : Set α\nhxy : LE.le x y\nhs : IsClosed s\nht : IsClosed t\nhab : HasSubset.Subset (Set.Icc a b) (Union.union s t)\nhx : Membership.mem (Inter.inter (Set.Icc a b) s) x\nhy : Membership.mem (Inter.inter (Set.Icc a b) t) y\n⊢ (Inter.inter (Set.Icc a b) (Inter.inter s t)).Nonempty","decl":"theorem isPreconnected_Icc_aux (x y : α) (s t : Set α) (hxy : x ≤ y) (hs : IsClosed s)\n    (ht : IsClosed t) (hab : Icc a b ⊆ s ∪ t) (hx : x ∈ Icc a b ∩ s) (hy : y ∈ Icc a b ∩ t) :\n    (Icc a b ∩ (s ∩ t)).Nonempty := by\n  have xyab : Icc x y ⊆ Icc a b := Icc_subset_Icc hx.1.1 hy.1.2\n  by_contra hst\n  suffices Icc x y ⊆ s from\n    hst ⟨y, xyab <| right_mem_Icc.2 hxy, this <| right_mem_Icc.2 hxy, hy.2⟩\n  apply (IsClosed.inter hs isClosed_Icc).Icc_subset_of_forall_mem_nhdsWithin hx.2\n  rintro z ⟨zs, hz⟩\n  have zt : z ∈ tᶜ := fun zt => hst ⟨z, xyab <| Ico_subset_Icc_self hz, zs, zt⟩\n  have : tᶜ ∩ Ioc z y ∈ 𝓝[>] z := by\n    rw [← nhdsWithin_Ioc_eq_nhdsGT hz.2]\n    exact mem_nhdsWithin.2 ⟨tᶜ, ht.isOpen_compl, zt, Subset.rfl⟩\n  apply mem_of_superset this\n  have : Ioc z y ⊆ s ∪ t := fun w hw => hab (xyab ⟨le_trans hz.1 (le_of_lt hw.1), hw.2⟩)\n  exact fun w ⟨wt, wzy⟩ => (this wzy).elim id fun h => (wt h).elim\n\n"}
{"name":"isPreconnected_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\n⊢ IsPreconnected (Set.Icc a b)","decl":"/-- A closed interval in a densely ordered conditionally complete linear order is preconnected. -/\ntheorem isPreconnected_Icc : IsPreconnected (Icc a b) :=\n  isPreconnected_closed_iff.2\n    (by\n      rintro s t hs ht hab ⟨x, hx⟩ ⟨y, hy⟩\n      -- This used to use `wlog`, but it was causing timeouts.\n      rcases le_total x y with h | h\n      · exact isPreconnected_Icc_aux x y s t h hs ht hab hx hy\n      · rw [inter_comm s t]\n        rw [union_comm s t] at hab\n        exact isPreconnected_Icc_aux y x t s h ht hs hab hy hx)\n\n"}
{"name":"isPreconnected_uIcc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\n⊢ IsPreconnected (Set.uIcc a b)","decl":"theorem isPreconnected_uIcc : IsPreconnected ([[a, b]]) :=\n  isPreconnected_Icc\n\n"}
{"name":"Set.OrdConnected.isPreconnected","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\ns : Set α\nh : s.OrdConnected\n⊢ IsPreconnected s","decl":"theorem Set.OrdConnected.isPreconnected {s : Set α} (h : s.OrdConnected) : IsPreconnected s :=\n  isPreconnected_of_forall_pair fun x hx y hy =>\n    ⟨[[x, y]], h.uIcc_subset hx hy, left_mem_uIcc, right_mem_uIcc, isPreconnected_uIcc⟩\n\n"}
{"name":"isPreconnected_iff_ordConnected","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\ns : Set α\n⊢ Iff (IsPreconnected s) s.OrdConnected","decl":"theorem isPreconnected_iff_ordConnected {s : Set α} : IsPreconnected s ↔ OrdConnected s :=\n  ⟨IsPreconnected.ordConnected, Set.OrdConnected.isPreconnected⟩\n\n"}
{"name":"isPreconnected_Ici","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na : α\n⊢ IsPreconnected (Set.Ici a)","decl":"theorem isPreconnected_Ici : IsPreconnected (Ici a) :=\n  ordConnected_Ici.isPreconnected\n\n"}
{"name":"isPreconnected_Iic","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na : α\n⊢ IsPreconnected (Set.Iic a)","decl":"theorem isPreconnected_Iic : IsPreconnected (Iic a) :=\n  ordConnected_Iic.isPreconnected\n\n"}
{"name":"isPreconnected_Iio","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na : α\n⊢ IsPreconnected (Set.Iio a)","decl":"theorem isPreconnected_Iio : IsPreconnected (Iio a) :=\n  ordConnected_Iio.isPreconnected\n\n"}
{"name":"isPreconnected_Ioi","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na : α\n⊢ IsPreconnected (Set.Ioi a)","decl":"theorem isPreconnected_Ioi : IsPreconnected (Ioi a) :=\n  ordConnected_Ioi.isPreconnected\n\n"}
{"name":"isPreconnected_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\n⊢ IsPreconnected (Set.Ioo a b)","decl":"theorem isPreconnected_Ioo : IsPreconnected (Ioo a b) :=\n  ordConnected_Ioo.isPreconnected\n\n"}
{"name":"isPreconnected_Ioc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\n⊢ IsPreconnected (Set.Ioc a b)","decl":"theorem isPreconnected_Ioc : IsPreconnected (Ioc a b) :=\n  ordConnected_Ioc.isPreconnected\n\n"}
{"name":"isPreconnected_Ico","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\n⊢ IsPreconnected (Set.Ico a b)","decl":"theorem isPreconnected_Ico : IsPreconnected (Ico a b) :=\n  ordConnected_Ico.isPreconnected\n\n"}
{"name":"isConnected_Ici","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na : α\n⊢ IsConnected (Set.Ici a)","decl":"theorem isConnected_Ici : IsConnected (Ici a) :=\n  ⟨nonempty_Ici, isPreconnected_Ici⟩\n\n"}
{"name":"isConnected_Iic","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na : α\n⊢ IsConnected (Set.Iic a)","decl":"theorem isConnected_Iic : IsConnected (Iic a) :=\n  ⟨nonempty_Iic, isPreconnected_Iic⟩\n\n"}
{"name":"isConnected_Ioi","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁴ : ConditionallyCompleteLinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderTopology α\ninst✝¹ : DenselyOrdered α\na : α\ninst✝ : NoMaxOrder α\n⊢ IsConnected (Set.Ioi a)","decl":"theorem isConnected_Ioi [NoMaxOrder α] : IsConnected (Ioi a) :=\n  ⟨nonempty_Ioi, isPreconnected_Ioi⟩\n\n"}
{"name":"isConnected_Iio","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁴ : ConditionallyCompleteLinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderTopology α\ninst✝¹ : DenselyOrdered α\na : α\ninst✝ : NoMinOrder α\n⊢ IsConnected (Set.Iio a)","decl":"theorem isConnected_Iio [NoMinOrder α] : IsConnected (Iio a) :=\n  ⟨nonempty_Iio, isPreconnected_Iio⟩\n\n"}
{"name":"isConnected_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\nh : LE.le a b\n⊢ IsConnected (Set.Icc a b)","decl":"theorem isConnected_Icc (h : a ≤ b) : IsConnected (Icc a b) :=\n  ⟨nonempty_Icc.2 h, isPreconnected_Icc⟩\n\n"}
{"name":"isConnected_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\nh : LT.lt a b\n⊢ IsConnected (Set.Ioo a b)","decl":"theorem isConnected_Ioo (h : a < b) : IsConnected (Ioo a b) :=\n  ⟨nonempty_Ioo.2 h, isPreconnected_Ioo⟩\n\n"}
{"name":"isConnected_Ioc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\nh : LT.lt a b\n⊢ IsConnected (Set.Ioc a b)","decl":"theorem isConnected_Ioc (h : a < b) : IsConnected (Ioc a b) :=\n  ⟨nonempty_Ioc.2 h, isPreconnected_Ioc⟩\n\n"}
{"name":"isConnected_Ico","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\nh : LT.lt a b\n⊢ IsConnected (Set.Ico a b)","decl":"theorem isConnected_Ico (h : a < b) : IsConnected (Ico a b) :=\n  ⟨nonempty_Ico.2 h, isPreconnected_Ico⟩\n\n"}
{"name":"ordered_connected_space","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\n⊢ PreconnectedSpace α","decl":"instance (priority := 100) ordered_connected_space : PreconnectedSpace α :=\n  ⟨ordConnected_univ.isPreconnected⟩\n\n"}
{"name":"setOf_isPreconnected_eq_of_ordered","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\n⊢ Eq (setOf fun s => IsPreconnected s) (Union.union (Union.union (Union.union (Union.union (Set.range (Function.uncurry Set.Icc)) (Set.range (Function.uncurry Set.Ico))) (Set.range (Function.uncurry Set.Ioc))) (Set.range (Function.uncurry Set.Ioo))) (Union.union (Union.union (Union.union (Union.union (Set.range Set.Ici) (Set.range Set.Ioi)) (Set.range Set.Iic)) (Set.range Set.Iio)) (Insert.insert Set.univ (Singleton.singleton EmptyCollection.emptyCollection))))","decl":"/-- In a dense conditionally complete linear order, the set of preconnected sets is exactly\nthe set of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`, `Iic`, `Iio`, `(-∞, +∞)`,\nor `∅`. Though one can represent `∅` as `(sInf s, sInf s)`, we include it into the list of\npossible cases to improve readability. -/\ntheorem setOf_isPreconnected_eq_of_ordered :\n    { s : Set α | IsPreconnected s } =\n      -- bounded intervals\n      range (uncurry Icc) ∪ range (uncurry Ico) ∪ range (uncurry Ioc) ∪ range (uncurry Ioo) ∪\n      -- unbounded intervals and `univ`\n      (range Ici ∪ range Ioi ∪ range Iic ∪ range Iio ∪ {univ, ∅}) := by\n  refine Subset.antisymm setOf_isPreconnected_subset_of_ordered ?_\n  simp only [subset_def, forall_mem_range, uncurry, or_imp, forall_and, mem_union,\n    mem_setOf_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true,\n    isPreconnected_Icc, isPreconnected_Ico, isPreconnected_Ioc, isPreconnected_Ioo,\n    isPreconnected_Ioi, isPreconnected_Iio, isPreconnected_Ici, isPreconnected_Iic,\n    isPreconnected_univ, isPreconnected_empty]\n\n"}
{"name":"isTotallyDisconnected_iff_lt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\ns : Set α\n⊢ Iff (IsTotallyDisconnected s) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LT.lt x y → Exists fun z => And (Not (Membership.mem s z)) (Membership.mem (Set.Ioo x y) z))","decl":"/-- This lemmas characterizes when a subset `s` of a densely ordered conditionally complete linear\norder is totally disconnected with respect to the order topology: between any two distinct points\nof `s` must lie a point not in `s`. -/\nlemma isTotallyDisconnected_iff_lt {s : Set α} :\n    IsTotallyDisconnected s ↔ ∀ x ∈ s, ∀ y ∈ s, x < y → ∃ z ∉ s, z ∈ Ioo x y := by\n  simp only [IsTotallyDisconnected, isPreconnected_iff_ordConnected, ← not_nontrivial_iff,\n    nontrivial_iff_exists_lt, not_exists, not_and]\n  refine ⟨fun h x hx y hy hxy ↦ ?_, fun h t hts ht x hx y hy hxy ↦ ?_⟩\n  · simp_rw [← not_ordConnected_inter_Icc_iff hx hy]\n    exact fun hs ↦ h _ inter_subset_left hs _ ⟨hx, le_rfl, hxy.le⟩ _ ⟨hy, hxy.le, le_rfl⟩ hxy\n  · obtain ⟨z, h1z, h2z⟩ := h x (hts hx) y (hts hy) hxy\n    exact h1z <| hts <| ht.1 hx hy ⟨h2z.1.le, h2z.2.le⟩\n\n"}
{"name":"intermediate_value_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nhab : LE.le a b\nf : α → δ\nhf : ContinuousOn f (Set.Icc a b)\n⊢ HasSubset.Subset (Set.Icc (f a) (f b)) (Set.image f (Set.Icc a b))","decl":"/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a ≤ t ≤ f b`. -/\ntheorem intermediate_value_Icc {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Icc (f a) (f b) ⊆ f '' Icc a b :=\n  isPreconnected_Icc.intermediate_value (left_mem_Icc.2 hab) (right_mem_Icc.2 hab) hf\n\n"}
{"name":"intermediate_value_Icc'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nhab : LE.le a b\nf : α → δ\nhf : ContinuousOn f (Set.Icc a b)\n⊢ HasSubset.Subset (Set.Icc (f b) (f a)) (Set.image f (Set.Icc a b))","decl":"/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a ≥ t ≥ f b`. -/\ntheorem intermediate_value_Icc' {a b : α} (hab : a ≤ b) {f : α → δ}\n    (hf : ContinuousOn f (Icc a b)) : Icc (f b) (f a) ⊆ f '' Icc a b :=\n  isPreconnected_Icc.intermediate_value (right_mem_Icc.2 hab) (left_mem_Icc.2 hab) hf\n\n"}
{"name":"intermediate_value_uIcc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nf : α → δ\nhf : ContinuousOn f (Set.uIcc a b)\n⊢ HasSubset.Subset (Set.uIcc (f a) (f b)) (Set.image f (Set.uIcc a b))","decl":"/-- **Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. -/\ntheorem intermediate_value_uIcc {a b : α} {f : α → δ} (hf : ContinuousOn f [[a, b]]) :\n    [[f a, f b]] ⊆ f '' uIcc a b := by\n  cases le_total (f a) (f b) <;> simp [*, isPreconnected_uIcc.intermediate_value]\n\n"}
{"name":"exists_mem_uIcc_isFixedPt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\nf : α → α\nhf : ContinuousOn f (Set.uIcc a b)\nha : LE.le a (f a)\nhb : LE.le (f b) b\n⊢ Exists fun c => And (Membership.mem (Set.uIcc a b) c) (Function.IsFixedPt f c)","decl":"/-- If `f : α → α` is continuous on `[[a, b]]`, `a ≤ f a`, and `f b ≤ b`,\nthen `f` has a fixed point on `[[a, b]]`. -/\ntheorem exists_mem_uIcc_isFixedPt {a b : α} {f : α → α} (hf : ContinuousOn f (uIcc a b))\n    (ha : a ≤ f a) (hb : f b ≤ b) : ∃ c ∈ [[a, b]], IsFixedPt f c :=\n  isPreconnected_uIcc.intermediate_value₂ right_mem_uIcc left_mem_uIcc hf continuousOn_id hb ha\n\n"}
{"name":"exists_mem_Icc_isFixedPt","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\nf : α → α\nhf : ContinuousOn f (Set.Icc a b)\nhle : LE.le a b\nha : LE.le a (f a)\nhb : LE.le (f b) b\n⊢ Exists fun c => And (Membership.mem (Set.Icc a b) c) (Function.IsFixedPt f c)","decl":"/-- If `f : α → α` is continuous on `[a, b]`, `a ≤ b`, `a ≤ f a`, and `f b ≤ b`,\nthen `f` has a fixed point on `[a, b]`.\n\nIn particular, if `[a, b]` is forward-invariant under `f`,\nthen `f` has a fixed point on `[a, b]`, see `exists_mem_Icc_isFixedPt_of_mapsTo`. -/\ntheorem exists_mem_Icc_isFixedPt {a b : α} {f : α → α} (hf : ContinuousOn f (Icc a b))\n    (hle : a ≤ b) (ha : a ≤ f a) (hb : f b ≤ b) : ∃ c ∈ Icc a b, IsFixedPt f c :=\n  isPreconnected_Icc.intermediate_value₂\n    (right_mem_Icc.2 hle) (left_mem_Icc.2 hle) hf continuousOn_id hb ha\n\n"}
{"name":"exists_mem_Icc_isFixedPt_of_mapsTo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\na b : α\nf : α → α\nhf : ContinuousOn f (Set.Icc a b)\nhle : LE.le a b\nhmaps : Set.MapsTo f (Set.Icc a b) (Set.Icc a b)\n⊢ Exists fun c => And (Membership.mem (Set.Icc a b) c) (Function.IsFixedPt f c)","decl":"/-- If a closed interval is forward-invariant under a continuous map `f : α → α`,\nthen this map has a fixed point on this interval. -/\ntheorem exists_mem_Icc_isFixedPt_of_mapsTo {a b : α} {f : α → α} (hf : ContinuousOn f (Icc a b))\n    (hle : a ≤ b) (hmaps : MapsTo f (Icc a b) (Icc a b)) : ∃ c ∈ Icc a b, IsFixedPt f c :=\n  exists_mem_Icc_isFixedPt hf hle (hmaps <| left_mem_Icc.2 hle).1 (hmaps <| right_mem_Icc.2 hle).2\n\n"}
{"name":"intermediate_value_Ico","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nhab : LE.le a b\nf : α → δ\nhf : ContinuousOn f (Set.Icc a b)\n⊢ HasSubset.Subset (Set.Ico (f a) (f b)) (Set.image f (Set.Ico a b))","decl":"theorem intermediate_value_Ico {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Ico (f a) (f b) ⊆ f '' Ico a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.2 (not_lt_of_le (he ▸ h.1))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ico _ _ _ _ _ _ _ isPreconnected_Ico _ _ ⟨refl a, hlt⟩\n      (right_nhdsWithin_Ico_neBot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self) _\n      ((hf.continuousWithinAt ⟨hab, refl b⟩).mono Ico_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ico'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nhab : LE.le a b\nf : α → δ\nhf : ContinuousOn f (Set.Icc a b)\n⊢ HasSubset.Subset (Set.Ioc (f b) (f a)) (Set.image f (Set.Ico a b))","decl":"theorem intermediate_value_Ico' {a b : α} (hab : a ≤ b) {f : α → δ}\n    (hf : ContinuousOn f (Icc a b)) : Ioc (f b) (f a) ⊆ f '' Ico a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.1 (not_lt_of_le (he ▸ h.2))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioc _ _ _ _ _ _ _ isPreconnected_Ico _ _ ⟨refl a, hlt⟩\n      (right_nhdsWithin_Ico_neBot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self) _\n      ((hf.continuousWithinAt ⟨hab, refl b⟩).mono Ico_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ioc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nhab : LE.le a b\nf : α → δ\nhf : ContinuousOn f (Set.Icc a b)\n⊢ HasSubset.Subset (Set.Ioc (f a) (f b)) (Set.image f (Set.Ioc a b))","decl":"theorem intermediate_value_Ioc {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Ioc (f a) (f b) ⊆ f '' Ioc a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.2 (not_le_of_lt (he ▸ h.1))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioc _ _ _ _ _ _ _ isPreconnected_Ioc _ _ ⟨hlt, refl b⟩\n      (left_nhdsWithin_Ioc_neBot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self) _\n      ((hf.continuousWithinAt ⟨refl a, hab⟩).mono Ioc_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ioc'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nhab : LE.le a b\nf : α → δ\nhf : ContinuousOn f (Set.Icc a b)\n⊢ HasSubset.Subset (Set.Ico (f b) (f a)) (Set.image f (Set.Ioc a b))","decl":"theorem intermediate_value_Ioc' {a b : α} (hab : a ≤ b) {f : α → δ}\n    (hf : ContinuousOn f (Icc a b)) : Ico (f b) (f a) ⊆ f '' Ioc a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.1 (not_le_of_lt (he ▸ h.2))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ico _ _ _ _ _ _ _ isPreconnected_Ioc _ _ ⟨hlt, refl b⟩\n      (left_nhdsWithin_Ioc_neBot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self) _\n      ((hf.continuousWithinAt ⟨refl a, hab⟩).mono Ioc_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nhab : LE.le a b\nf : α → δ\nhf : ContinuousOn f (Set.Icc a b)\n⊢ HasSubset.Subset (Set.Ioo (f a) (f b)) (Set.image f (Set.Ioo a b))","decl":"theorem intermediate_value_Ioo {a b : α} (hab : a ≤ b) {f : α → δ} (hf : ContinuousOn f (Icc a b)) :\n    Ioo (f a) (f b) ⊆ f '' Ioo a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.2 (not_lt_of_lt (he ▸ h.1))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioo _ _ _ _ _ _ _ isPreconnected_Ioo _ _\n      (left_nhdsWithin_Ioo_neBot hlt) (right_nhdsWithin_Ioo_neBot hlt) inf_le_right inf_le_right _\n      (hf.mono Ioo_subset_Icc_self) _ _\n      ((hf.continuousWithinAt ⟨refl a, hab⟩).mono Ioo_subset_Icc_self)\n      ((hf.continuousWithinAt ⟨hab, refl b⟩).mono Ioo_subset_Icc_self)\n\n"}
{"name":"intermediate_value_Ioo'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nhab : LE.le a b\nf : α → δ\nhf : ContinuousOn f (Set.Icc a b)\n⊢ HasSubset.Subset (Set.Ioo (f b) (f a)) (Set.image f (Set.Ioo a b))","decl":"theorem intermediate_value_Ioo' {a b : α} (hab : a ≤ b) {f : α → δ}\n    (hf : ContinuousOn f (Icc a b)) : Ioo (f b) (f a) ⊆ f '' Ioo a b :=\n  Or.elim (eq_or_lt_of_le hab) (fun he _ h => absurd h.1 (not_lt_of_lt (he ▸ h.2))) fun hlt =>\n    @IsPreconnected.intermediate_value_Ioo _ _ _ _ _ _ _ isPreconnected_Ioo _ _\n      (right_nhdsWithin_Ioo_neBot hlt) (left_nhdsWithin_Ioo_neBot hlt) inf_le_right inf_le_right _\n      (hf.mono Ioo_subset_Icc_self) _ _\n      ((hf.continuousWithinAt ⟨hab, refl b⟩).mono Ioo_subset_Icc_self)\n      ((hf.continuousWithinAt ⟨refl a, hab⟩).mono Ioo_subset_Icc_self)\n\n"}
{"name":"ContinuousOn.surjOn_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\ns : Set α\nhs : s.OrdConnected\nf : α → δ\nhf : ContinuousOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Set.SurjOn f s (Set.Icc (f a) (f b))","decl":"/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `Icc (f x) (f y)`. -/\ntheorem ContinuousOn.surjOn_Icc {s : Set α} [hs : OrdConnected s] {f : α → δ}\n    (hf : ContinuousOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) : SurjOn f s (Icc (f a) (f b)) :=\n  hs.isPreconnected.intermediate_value ha hb hf\n\n"}
{"name":"ContinuousOn.surjOn_uIcc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\ns : Set α\nhs : s.OrdConnected\nf : α → δ\nhf : ContinuousOn f s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Set.SurjOn f s (Set.uIcc (f a) (f b))","decl":"/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. -/\ntheorem ContinuousOn.surjOn_uIcc {s : Set α} [hs : OrdConnected s] {f : α → δ}\n    (hf : ContinuousOn f s) {a b : α} (ha : a ∈ s) (hb : b ∈ s) :\n    SurjOn f s (uIcc (f a) (f b)) := by\n  rcases le_total (f a) (f b) with hab | hab <;> simp [hf.surjOn_Icc, *]\n\n"}
{"name":"Continuous.surjective","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\nf : α → δ\nhf : Continuous f\nh_top : Filter.Tendsto f Filter.atTop Filter.atTop\nh_bot : Filter.Tendsto f Filter.atBot Filter.atBot\n⊢ Function.Surjective f","decl":"/-- A continuous function which tendsto `Filter.atTop` along `Filter.atTop` and to `atBot` along\n`at_bot` is surjective. -/\ntheorem Continuous.surjective {f : α → δ} (hf : Continuous f) (h_top : Tendsto f atTop atTop)\n    (h_bot : Tendsto f atBot atBot) : Function.Surjective f := fun p =>\n  mem_range_of_exists_le_of_exists_ge hf (h_bot.eventually (eventually_le_atBot p)).exists\n    (h_top.eventually (eventually_ge_atTop p)).exists\n\n"}
{"name":"Continuous.surjective'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\nf : α → δ\nhf : Continuous f\nh_top : Filter.Tendsto f Filter.atBot Filter.atTop\nh_bot : Filter.Tendsto f Filter.atTop Filter.atBot\n⊢ Function.Surjective f","decl":"/-- A continuous function which tendsto `Filter.atBot` along `Filter.atTop` and to `Filter.atTop`\nalong `atBot` is surjective. -/\ntheorem Continuous.surjective' {f : α → δ} (hf : Continuous f) (h_top : Tendsto f atBot atTop)\n    (h_bot : Tendsto f atTop atBot) : Function.Surjective f :=\n  Continuous.surjective (α := αᵒᵈ) hf h_top h_bot\n\n"}
{"name":"ContinuousOn.surjOn_of_tendsto","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁷ : ConditionallyCompleteLinearOrder α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : OrderTopology α\ninst✝⁴ : DenselyOrdered α\nδ : Type u_1\ninst✝³ : LinearOrder δ\ninst✝² : TopologicalSpace δ\ninst✝¹ : OrderClosedTopology δ\nf : α → δ\ns : Set α\ninst✝ : s.OrdConnected\nhs : s.Nonempty\nhf : ContinuousOn f s\nhbot : Filter.Tendsto (fun x => f ↑x) Filter.atBot Filter.atBot\nhtop : Filter.Tendsto (fun x => f ↑x) Filter.atTop Filter.atTop\n⊢ Set.SurjOn f s Set.univ","decl":"/-- If a function `f : α → β` is continuous on a nonempty interval `s`, its restriction to `s`\ntends to `at_bot : Filter β` along `at_bot : Filter ↥s` and tends to `Filter.atTop : Filter β` along\n`Filter.atTop : Filter ↥s`, then the restriction of `f` to `s` is surjective. We formulate the\nconclusion as `Function.surjOn f s Set.univ`. -/\ntheorem ContinuousOn.surjOn_of_tendsto {f : α → δ} {s : Set α} [OrdConnected s] (hs : s.Nonempty)\n    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atBot)\n    (htop : Tendsto (fun x : s => f x) atTop atTop) : SurjOn f s univ :=\n  haveI := Classical.inhabited_of_nonempty hs.to_subtype\n  surjOn_iff_surjective.2 <| hf.restrict.surjective htop hbot\n\n"}
{"name":"ContinuousOn.surjOn_of_tendsto'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁷ : ConditionallyCompleteLinearOrder α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : OrderTopology α\ninst✝⁴ : DenselyOrdered α\nδ : Type u_1\ninst✝³ : LinearOrder δ\ninst✝² : TopologicalSpace δ\ninst✝¹ : OrderClosedTopology δ\nf : α → δ\ns : Set α\ninst✝ : s.OrdConnected\nhs : s.Nonempty\nhf : ContinuousOn f s\nhbot : Filter.Tendsto (fun x => f ↑x) Filter.atBot Filter.atTop\nhtop : Filter.Tendsto (fun x => f ↑x) Filter.atTop Filter.atBot\n⊢ Set.SurjOn f s Set.univ","decl":"/-- If a function `f : α → β` is continuous on a nonempty interval `s`, its restriction to `s`\ntends to `Filter.atTop : Filter β` along `Filter.atBot : Filter ↥s` and tends to\n`Filter.atBot : Filter β` along `Filter.atTop : Filter ↥s`, then the restriction of `f` to `s` is\nsurjective. We formulate the conclusion as `Function.surjOn f s Set.univ`. -/\ntheorem ContinuousOn.surjOn_of_tendsto' {f : α → δ} {s : Set α} [OrdConnected s] (hs : s.Nonempty)\n    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atTop)\n    (htop : Tendsto (fun x : s => f x) atTop atBot) : SurjOn f s univ :=\n  ContinuousOn.surjOn_of_tendsto (δ := δᵒᵈ) hs hf hbot htop\n\n"}
{"name":"Continuous.strictMono_of_inj_boundedOrder","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁷ : ConditionallyCompleteLinearOrder α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : OrderTopology α\ninst✝⁴ : DenselyOrdered α\nδ : Type u_1\ninst✝³ : LinearOrder δ\ninst✝² : TopologicalSpace δ\ninst✝¹ : OrderClosedTopology δ\ninst✝ : BoundedOrder α\nf : α → δ\nhf_c : Continuous f\nhf : LE.le (f Bot.bot) (f Top.top)\nhf_i : Function.Injective f\n⊢ StrictMono f","decl":"theorem Continuous.strictMono_of_inj_boundedOrder [BoundedOrder α] {f : α → δ}\n    (hf_c : Continuous f) (hf : f ⊥ ≤ f ⊤) (hf_i : Injective f) : StrictMono f := by\n  intro a b hab\n  by_contra! h\n  have H : f b < f a := lt_of_le_of_ne h <| hf_i.ne hab.ne'\n  by_cases ha : f a ≤ f ⊥\n  · obtain ⟨u, hu⟩ := intermediate_value_Ioc le_top hf_c.continuousOn ⟨H.trans_le ha, hf⟩\n    have : u = ⊥ := hf_i hu.2\n    aesop\n  · by_cases hb : f ⊥ < f b\n    · obtain ⟨u, hu⟩ := intermediate_value_Ioo bot_le hf_c.continuousOn ⟨hb, H⟩\n      rw [hf_i hu.2] at hu\n      exact (hab.trans hu.1.2).false\n    · push_neg at ha hb\n      replace hb : f b < f ⊥ := lt_of_le_of_ne hb <| hf_i.ne (lt_of_lt_of_le' hab bot_le).ne'\n      obtain ⟨u, hu⟩ := intermediate_value_Ioo' hab.le hf_c.continuousOn ⟨hb, ha⟩\n      have : u = ⊥ := hf_i hu.2\n      aesop\n\n"}
{"name":"Continuous.strictAnti_of_inj_boundedOrder","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁷ : ConditionallyCompleteLinearOrder α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : OrderTopology α\ninst✝⁴ : DenselyOrdered α\nδ : Type u_1\ninst✝³ : LinearOrder δ\ninst✝² : TopologicalSpace δ\ninst✝¹ : OrderClosedTopology δ\ninst✝ : BoundedOrder α\nf : α → δ\nhf_c : Continuous f\nhf : LE.le (f Top.top) (f Bot.bot)\nhf_i : Function.Injective f\n⊢ StrictAnti f","decl":"theorem Continuous.strictAnti_of_inj_boundedOrder [BoundedOrder α] {f : α → δ}\n    (hf_c : Continuous f) (hf : f ⊤ ≤ f ⊥) (hf_i : Injective f) : StrictAnti f :=\n  hf_c.strictMono_of_inj_boundedOrder (δ := δᵒᵈ) hf hf_i\n\n"}
{"name":"Continuous.strictMono_of_inj_boundedOrder'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁷ : ConditionallyCompleteLinearOrder α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : OrderTopology α\ninst✝⁴ : DenselyOrdered α\nδ : Type u_1\ninst✝³ : LinearOrder δ\ninst✝² : TopologicalSpace δ\ninst✝¹ : OrderClosedTopology δ\ninst✝ : BoundedOrder α\nf : α → δ\nhf_c : Continuous f\nhf_i : Function.Injective f\n⊢ Or (StrictMono f) (StrictAnti f)","decl":"theorem Continuous.strictMono_of_inj_boundedOrder' [BoundedOrder α] {f : α → δ}\n    (hf_c : Continuous f) (hf_i : Injective f) : StrictMono f ∨ StrictAnti f :=\n  (le_total (f ⊥) (f ⊤)).imp\n    (hf_c.strictMono_of_inj_boundedOrder · hf_i)\n    (hf_c.strictAnti_of_inj_boundedOrder · hf_i)\n\n"}
{"name":"Continuous.strictMonoOn_of_inj_rigidity","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\nf : α → δ\nhf_c : Continuous f\nhf_i : Function.Injective f\na b : α\nhab : LT.lt a b\nhf_mono : StrictMonoOn f (Set.Icc a b)\n⊢ StrictMono f","decl":"/-- Suppose `α` is equipped with a conditionally complete linear dense order and `f : α → δ` is\ncontinuous and injective. Then `f` is strictly monotone (increasing) if\nit is strictly monotone (increasing) on some closed interval `[a, b]`. -/\ntheorem Continuous.strictMonoOn_of_inj_rigidity {f : α → δ}\n    (hf_c : Continuous f) (hf_i : Injective f) {a b : α} (hab : a < b)\n    (hf_mono : StrictMonoOn f (Icc a b)) : StrictMono f := by\n  intro x y hxy\n  let s := min a x\n  let t := max b y\n  have hsa : s ≤ a := min_le_left a x\n  have hbt : b ≤ t := le_max_left b y\n  have hf_mono_st : StrictMonoOn f (Icc s t) ∨ StrictAntiOn f (Icc s t) := by\n    have : Fact (s ≤ t) := ⟨hsa.trans <| hbt.trans' hab.le⟩\n    have := Continuous.strictMono_of_inj_boundedOrder' (f := Set.restrict (Icc s t) f)\n      hf_c.continuousOn.restrict hf_i.injOn.injective\n    exact this.imp strictMono_restrict.mp strictAntiOn_iff_strictAnti.mpr\n  have (h : StrictAntiOn f (Icc s t)) : False := by\n    have : Icc a b ⊆ Icc s t := Icc_subset_Icc hsa hbt\n    replace : StrictAntiOn f (Icc a b) := StrictAntiOn.mono h this\n    replace : IsAntichain (· ≤ ·) (Icc a b) :=\n      IsAntichain.of_strictMonoOn_antitoneOn hf_mono this.antitoneOn\n    exact this.not_lt (left_mem_Icc.mpr (le_of_lt hab)) (right_mem_Icc.mpr (le_of_lt hab)) hab\n  replace hf_mono_st : StrictMonoOn f (Icc s t) := hf_mono_st.resolve_right this\n  have hsx : s ≤ x := min_le_right a x\n  have hyt : y ≤ t := le_max_right b y\n  replace : Icc x y ⊆ Icc s t := Icc_subset_Icc hsx hyt\n  replace : StrictMonoOn f (Icc x y) := StrictMonoOn.mono hf_mono_st this\n  exact this (left_mem_Icc.mpr (le_of_lt hxy)) (right_mem_Icc.mpr (le_of_lt hxy)) hxy\n\n"}
{"name":"ContinuousOn.strictMonoOn_of_injOn_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nf : α → δ\nhab : LE.le a b\nhfab : LE.le (f a) (f b)\nhf_c : ContinuousOn f (Set.Icc a b)\nhf_i : Set.InjOn f (Set.Icc a b)\n⊢ StrictMonoOn f (Set.Icc a b)","decl":"/-- Suppose `f : [a, b] → δ` is\ncontinuous and injective. Then `f` is strictly monotone (increasing) if `f(a) ≤ f(b)`. -/\ntheorem ContinuousOn.strictMonoOn_of_injOn_Icc {a b : α} {f : α → δ}\n    (hab : a ≤ b) (hfab : f a ≤ f b)\n    (hf_c : ContinuousOn f (Icc a b)) (hf_i : InjOn f (Icc a b)) :\n    StrictMonoOn f (Icc a b) := by\n  have : Fact (a ≤ b) := ⟨hab⟩\n  refine StrictMono.of_restrict ?_\n  set g : Icc a b → δ := Set.restrict (Icc a b) f\n  have hgab : g ⊥ ≤ g ⊤ := by aesop\n  exact Continuous.strictMono_of_inj_boundedOrder (f := g) hf_c.restrict hgab hf_i.injective\n\n"}
{"name":"ContinuousOn.strictAntiOn_of_injOn_Icc","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nf : α → δ\nhab : LE.le a b\nhfab : LE.le (f b) (f a)\nhf_c : ContinuousOn f (Set.Icc a b)\nhf_i : Set.InjOn f (Set.Icc a b)\n⊢ StrictAntiOn f (Set.Icc a b)","decl":"/-- Suppose `f : [a, b] → δ` is\ncontinuous and injective. Then `f` is strictly antitone (decreasing) if `f(b) ≤ f(a)`. -/\ntheorem ContinuousOn.strictAntiOn_of_injOn_Icc {a b : α} {f : α → δ}\n    (hab : a ≤ b) (hfab : f b ≤ f a)\n    (hf_c : ContinuousOn f (Icc a b)) (hf_i : InjOn f (Icc a b)) :\n    StrictAntiOn f (Icc a b) := ContinuousOn.strictMonoOn_of_injOn_Icc (δ := δᵒᵈ) hab hfab hf_c hf_i\n\n"}
{"name":"ContinuousOn.strictMonoOn_of_injOn_Icc'","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nf : α → δ\nhab : LE.le a b\nhf_c : ContinuousOn f (Set.Icc a b)\nhf_i : Set.InjOn f (Set.Icc a b)\n⊢ Or (StrictMonoOn f (Set.Icc a b)) (StrictAntiOn f (Set.Icc a b))","decl":"/-- Suppose `f : [a, b] → δ` is continuous and injective. Then `f` is strictly monotone\nor antitone (increasing or decreasing). -/\ntheorem ContinuousOn.strictMonoOn_of_injOn_Icc' {a b : α} {f : α → δ} (hab : a ≤ b)\n    (hf_c : ContinuousOn f (Icc a b)) (hf_i : InjOn f (Icc a b)) :\n    StrictMonoOn f (Icc a b) ∨ StrictAntiOn f (Icc a b) :=\n  (le_total (f a) (f b)).imp\n    (ContinuousOn.strictMonoOn_of_injOn_Icc hab · hf_c hf_i)\n    (ContinuousOn.strictAntiOn_of_injOn_Icc hab · hf_c hf_i)\n\n"}
{"name":"Continuous.strictMono_of_inj","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\nf : α → δ\nhf_c : Continuous f\nhf_i : Function.Injective f\n⊢ Or (StrictMono f) (StrictAnti f)","decl":"/-- Suppose `α` is equipped with a conditionally complete linear dense order and `f : α → δ` is\ncontinuous and injective. Then `f` is strictly monotone or antitone (increasing or decreasing). -/\ntheorem Continuous.strictMono_of_inj {f : α → δ}\n    (hf_c : Continuous f) (hf_i : Injective f) : StrictMono f ∨ StrictAnti f := by\n  have H {c d : α} (hcd : c < d) : StrictMono f ∨ StrictAnti f :=\n    (hf_c.continuousOn.strictMonoOn_of_injOn_Icc' hcd.le hf_i.injOn).imp\n      (hf_c.strictMonoOn_of_inj_rigidity hf_i hcd)\n      (hf_c.strictMonoOn_of_inj_rigidity (δ := δᵒᵈ) hf_i hcd)\n  by_cases hn : Nonempty α\n  · let a : α := Classical.choice ‹_›\n    by_cases h : ∃ b : α, a ≠ b\n    · choose b hb using h\n      by_cases hab : a < b\n      · exact H hab\n      · push_neg at hab\n        have : b < a := by exact Ne.lt_of_le (id (Ne.symm hb)) hab\n        exact H this\n    · push_neg at h\n      haveI : Subsingleton α := ⟨fun c d => Trans.trans (h c).symm (h d)⟩\n      exact Or.inl <| Subsingleton.strictMono f\n  · aesop\n\n"}
{"name":"ContinuousOn.strictMonoOn_of_injOn_Ioo","module":"Mathlib.Topology.Order.IntermediateValue","initialProofState":"α : Type u\ninst✝⁶ : ConditionallyCompleteLinearOrder α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : OrderTopology α\ninst✝³ : DenselyOrdered α\nδ : Type u_1\ninst✝² : LinearOrder δ\ninst✝¹ : TopologicalSpace δ\ninst✝ : OrderClosedTopology δ\na b : α\nf : α → δ\nhab : LT.lt a b\nhf_c : ContinuousOn f (Set.Ioo a b)\nhf_i : Set.InjOn f (Set.Ioo a b)\n⊢ Or (StrictMonoOn f (Set.Ioo a b)) (StrictAntiOn f (Set.Ioo a b))","decl":"/-- Every continuous injective `f : (a, b) → δ` is strictly monotone\nor antitone (increasing or decreasing). -/\ntheorem ContinuousOn.strictMonoOn_of_injOn_Ioo {a b : α} {f : α → δ} (hab : a < b)\n    (hf_c : ContinuousOn f (Ioo a b)) (hf_i : InjOn f (Ioo a b)) :\n    StrictMonoOn f (Ioo a b) ∨ StrictAntiOn f (Ioo a b) := by\n  haveI : Inhabited (Ioo a b) := Classical.inhabited_of_nonempty (nonempty_Ioo_subtype hab)\n  let g : Ioo a b → δ := Set.restrict (Ioo a b) f\n  have : StrictMono g ∨ StrictAnti g :=\n    Continuous.strictMono_of_inj hf_c.restrict hf_i.injective\n  exact this.imp strictMono_restrict.mp strictAntiOn_iff_strictAnti.mpr\n"}
