{"name":"MonCat.HasLimits.hasLimit","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J MonCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget MonCat)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget MonCat).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ⋙ forget AddMonCat).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"AddMonCat.HasLimits.hasLimit","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddMonCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget AddMonCat)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget MonCat).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ⋙ forget AddMonCat).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"MonCat.HasLimits.hasLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J MonCat","decl":"/-- If `J` is `u`-small, `MonCat.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddMonCat.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J MonCat.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"AddMonCat.HasLimits.hasLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J AddMonCat","decl":"/-- If `J` is `u`-small, `MonCat.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddMonCat.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J MonCat.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"MonCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} MonCat","decl":"/-- The category of monoids has all limits. -/\n@[to_additive \"The category of additive monoids has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} MonCat.{u} where\n  has_limits_of_shape _ _ := { }\n\n"}
{"name":"AddMonCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} AddMonCat","decl":"/-- The category of monoids has all limits. -/\n@[to_additive \"The category of additive monoids has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} MonCat.{u} where\n  has_limits_of_shape _ _ := { }\n\n"}
{"name":"MonCat.hasLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits MonCat","decl":"@[to_additive]\ninstance hasLimits : HasLimits MonCat.{u} :=\n  MonCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"AddMonCat.hasLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits AddMonCat","decl":"@[to_additive]\ninstance hasLimits : HasLimits MonCat.{u} :=\n  MonCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"AddMonCat.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget AddMonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `MonCat.{u}` preserves limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddMonCat.{u}`\\n\npreserves limits of shape `J`.\"]\nnoncomputable instance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget MonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ⋙ forget _))\n\n"}
{"name":"MonCat.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget MonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `MonCat.{u}` preserves limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddMonCat.{u}`\\n\npreserves limits of shape `J`.\"]\nnoncomputable instance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget MonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ⋙ forget _))\n\n"}
{"name":"MonCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget MonCat)","decl":"/-- The forgetful functor from monoids to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive\n  \"The forgetful functor from additive monoids to types preserves all limits.\\n\\n\n  This means the underlying type of a limit can be computed as a limit in the category of types.\",\n  to_additive_relevant_arg 2]\nnoncomputable instance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget MonCat.{u}) where\n  preservesLimitsOfShape := { }\n\n"}
{"name":"AddMonCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget AddMonCat)","decl":"/-- The forgetful functor from monoids to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive\n  \"The forgetful functor from additive monoids to types preserves all limits.\\n\\n\n  This means the underlying type of a limit can be computed as a limit in the category of types.\",\n  to_additive_relevant_arg 2]\nnoncomputable instance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget MonCat.{u}) where\n  preservesLimitsOfShape := { }\n\n"}
{"name":"MonCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget MonCat)","decl":"@[to_additive]\nnoncomputable instance forget_preservesLimits : PreservesLimits (forget MonCat.{u}) :=\n  MonCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddMonCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget AddMonCat)","decl":"@[to_additive]\nnoncomputable instance forget_preservesLimits : PreservesLimits (forget MonCat.{u}) :=\n  MonCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddCommMonCat.instSmallElemForallObjCompMonCatForget₂ForgetSections","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddCommMonCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget AddCommMonCat)).sections\n⊢ Small.{u, max u v} ↑((F.comp (CategoryTheory.forget₂ AddCommMonCat AddMonCat)).comp (CategoryTheory.forget AddMonCat)).sections","decl":"@[to_additive]\ninstance : Small.{u} (Functor.sections ((F ⋙ forget₂ CommMonCat MonCat) ⋙ forget MonCat)) :=\n  inferInstanceAs <| Small.{u} (Functor.sections (F ⋙ forget CommMonCat))\n\n"}
{"name":"CommMonCat.instSmallElemForallObjCompMonCatForget₂ForgetSections","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J CommMonCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget CommMonCat)).sections\n⊢ Small.{u, max u v} ↑((F.comp (CategoryTheory.forget₂ CommMonCat MonCat)).comp (CategoryTheory.forget MonCat)).sections","decl":"@[to_additive]\ninstance : Small.{u} (Functor.sections ((F ⋙ forget₂ CommMonCat MonCat) ⋙ forget MonCat)) :=\n  inferInstanceAs <| Small.{u} (Functor.sections (F ⋙ forget CommMonCat))\n\n"}
{"name":"AddCommMonCat.hasLimit","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddCommMonCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget AddCommMonCat)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget CommMonCat).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ⋙ forget AddCommMonCat).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"CommMonCat.hasLimit","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J CommMonCat\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget CommMonCat)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget CommMonCat).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ⋙ forget AddCommMonCat).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"AddCommMonCat.hasLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J AddCommMonCat","decl":"/-- If `J` is `u`-small, `CommMonCat.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddCommMonCat.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J CommMonCat.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"CommMonCat.hasLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J CommMonCat","decl":"/-- If `J` is `u`-small, `CommMonCat.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddCommMonCat.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J CommMonCat.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"CommMonCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} CommMonCat","decl":"/-- The category of commutative monoids has all limits. -/\n@[to_additive \"The category of additive commutative monoids has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} CommMonCat.{u} where\n  has_limits_of_shape _ _ := { }\n\n"}
{"name":"AddCommMonCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} AddCommMonCat","decl":"/-- The category of commutative monoids has all limits. -/\n@[to_additive \"The category of additive commutative monoids has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} CommMonCat.{u} where\n  has_limits_of_shape _ _ := { }\n\n"}
{"name":"AddCommMonCat.hasLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits AddCommMonCat","decl":"@[to_additive]\ninstance hasLimits : HasLimits CommMonCat.{u} :=\n  CommMonCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"CommMonCat.hasLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits CommMonCat","decl":"@[to_additive]\ninstance hasLimits : HasLimits CommMonCat.{u} :=\n  CommMonCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"AddCommMonCat.forget₂AddMonPreservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ AddCommMonCat AddMonCat)","decl":"/-- The forgetful functor from commutative monoids to monoids preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of monoids. -/\n@[to_additive AddCommMonCat.forget₂AddMonPreservesLimitsOfSize \"The forgetful functor from\n  additive commutative monoids to additive monoids preserves all limits.\\n\\n\n  This means the underlying type of a limit can be computed as a limit in the category of additive\\n\n  monoids.\",\n  to_additive_relevant_arg 2]\ninstance forget₂Mon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ CommMonCat.{u} MonCat.{u}) where\n  preservesLimitsOfShape {J} 𝒥 := { }\n\n"}
{"name":"CommMonCat.forget₂Mon_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ CommMonCat MonCat)","decl":"/-- The forgetful functor from commutative monoids to monoids preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of monoids. -/\n@[to_additive AddCommMonCat.forget₂AddMonPreservesLimitsOfSize \"The forgetful functor from\n  additive commutative monoids to additive monoids preserves all limits.\\n\\n\n  This means the underlying type of a limit can be computed as a limit in the category of additive\\n\n  monoids.\",\n  to_additive_relevant_arg 2]\ninstance forget₂Mon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ CommMonCat.{u} MonCat.{u}) where\n  preservesLimitsOfShape {J} 𝒥 := { }\n\n"}
{"name":"AddCommMonCat.forget₂Mon_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ AddCommMonCat AddMonCat)","decl":"@[to_additive]\ninstance forget₂Mon_preservesLimits :\n    PreservesLimits (forget₂ CommMonCat.{u} MonCat.{u}) :=\n  CommMonCat.forget₂Mon_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommMonCat.forget₂Mon_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ CommMonCat MonCat)","decl":"@[to_additive]\ninstance forget₂Mon_preservesLimits :\n    PreservesLimits (forget₂ CommMonCat.{u} MonCat.{u}) :=\n  CommMonCat.forget₂Mon_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddCommMonCat.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget AddCommMonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `CommMonCat.{u}` preserves limits of\nshape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddCommMonCat.{u}`\\n\npreserves limits of shape `J`.\"]\ninstance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget CommMonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ⋙ forget _))\n\n"}
{"name":"CommMonCat.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget CommMonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `CommMonCat.{u}` preserves limits of\nshape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddCommMonCat.{u}`\\n\npreserves limits of shape `J`.\"]\ninstance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget CommMonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ⋙ forget _))\n\n"}
{"name":"CommMonCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, u, u, u + 1, u + 1} (CategoryTheory.forget CommMonCat)","decl":"/-- The forgetful functor from commutative monoids to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive \"The forgetful functor from additive commutative monoids to types preserves all\\n\nlimits.\\n\\n\nThis means the underlying type of a limit can be computed as a limit in the category of types.\"]\ninstance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{v, v} (forget CommMonCat.{u}) where\n  preservesLimitsOfShape {_} _ := { }\n\n"}
{"name":"AddCommMonCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, u, u, u + 1, u + 1} (CategoryTheory.forget AddCommMonCat)","decl":"/-- The forgetful functor from commutative monoids to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive \"The forgetful functor from additive commutative monoids to types preserves all\\n\nlimits.\\n\\n\nThis means the underlying type of a limit can be computed as a limit in the category of types.\"]\ninstance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{v, v} (forget CommMonCat.{u}) where\n  preservesLimitsOfShape {_} _ := { }\n\n"}
{"name":"AddCommMonCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget AddCommMonCat)","decl":"instance _root_.AddCommMonCat.forget_preservesLimits :\n    PreservesLimits (forget AddCommMonCat.{u}) :=\n  AddCommMonCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommMonCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget CommMonCat)","decl":"@[to_additive existing]\ninstance forget_preservesLimits : PreservesLimits (forget CommMonCat.{u}) :=\n  CommMonCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
