{"name":"MonCat.HasLimits.hasLimit","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J MonCat\ninst‚úù : Small.{u, max u v} ‚Üë(F.comp (CategoryTheory.forget MonCat)).sections\n‚ä¢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ‚ãô forget MonCat).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ‚ãô forget AddMonCat).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"AddMonCat.HasLimits.hasLimit","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddMonCat\ninst‚úù : Small.{u, max u v} ‚Üë(F.comp (CategoryTheory.forget AddMonCat)).sections\n‚ä¢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ‚ãô forget MonCat).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ‚ãô forget AddMonCat).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"MonCat.HasLimits.hasLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\ninst‚úù : Small.{u, v} J\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J MonCat","decl":"/-- If `J` is `u`-small, `MonCat.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddMonCat.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J MonCat.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"AddMonCat.HasLimits.hasLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\ninst‚úù : Small.{u, v} J\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J AddMonCat","decl":"/-- If `J` is `u`-small, `MonCat.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddMonCat.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J MonCat.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"MonCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} MonCat","decl":"/-- The category of monoids has all limits. -/\n@[to_additive \"The category of additive monoids has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} MonCat.{u} where\n  has_limits_of_shape _ _ := { }\n\n"}
{"name":"AddMonCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} AddMonCat","decl":"/-- The category of monoids has all limits. -/\n@[to_additive \"The category of additive monoids has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} MonCat.{u} where\n  has_limits_of_shape _ _ := { }\n\n"}
{"name":"MonCat.hasLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasLimits MonCat","decl":"@[to_additive]\ninstance hasLimits : HasLimits MonCat.{u} :=\n  MonCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"AddMonCat.hasLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasLimits AddMonCat","decl":"@[to_additive]\ninstance hasLimits : HasLimits MonCat.{u} :=\n  MonCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"AddMonCat.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\ninst‚úù : Small.{u, v} J\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget AddMonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `MonCat.{u}` preserves limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddMonCat.{u}`\\n\npreserves limits of shape `J`.\"]\nnoncomputable instance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget MonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ‚ãô forget _))\n\n"}
{"name":"MonCat.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\ninst‚úù : Small.{u, v} J\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget MonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `MonCat.{u}` preserves limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddMonCat.{u}`\\n\npreserves limits of shape `J`.\"]\nnoncomputable instance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget MonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ‚ãô forget _))\n\n"}
{"name":"MonCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget MonCat)","decl":"/-- The forgetful functor from monoids to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive\n  \"The forgetful functor from additive monoids to types preserves all limits.\\n\\n\n  This means the underlying type of a limit can be computed as a limit in the category of types.\",\n  to_additive_relevant_arg 2]\nnoncomputable instance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget MonCat.{u}) where\n  preservesLimitsOfShape := { }\n\n"}
{"name":"AddMonCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget AddMonCat)","decl":"/-- The forgetful functor from monoids to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive\n  \"The forgetful functor from additive monoids to types preserves all limits.\\n\\n\n  This means the underlying type of a limit can be computed as a limit in the category of types.\",\n  to_additive_relevant_arg 2]\nnoncomputable instance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget MonCat.{u}) where\n  preservesLimitsOfShape := { }\n\n"}
{"name":"MonCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget MonCat)","decl":"@[to_additive]\nnoncomputable instance forget_preservesLimits : PreservesLimits (forget MonCat.{u}) :=\n  MonCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddMonCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget AddMonCat)","decl":"@[to_additive]\nnoncomputable instance forget_preservesLimits : PreservesLimits (forget MonCat.{u}) :=\n  MonCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddCommMonCat.instSmallElemForallObjCompMonCatForget‚ÇÇForgetSections","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddCommMonCat\ninst‚úù : Small.{u, max u v} ‚Üë(F.comp (CategoryTheory.forget AddCommMonCat)).sections\n‚ä¢ Small.{u, max u v} ‚Üë((F.comp (CategoryTheory.forget‚ÇÇ AddCommMonCat AddMonCat)).comp (CategoryTheory.forget AddMonCat)).sections","decl":"@[to_additive]\ninstance : Small.{u} (Functor.sections ((F ‚ãô forget‚ÇÇ CommMonCat MonCat) ‚ãô forget MonCat)) :=\n  inferInstanceAs <| Small.{u} (Functor.sections (F ‚ãô forget CommMonCat))\n\n"}
{"name":"CommMonCat.instSmallElemForallObjCompMonCatForget‚ÇÇForgetSections","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J CommMonCat\ninst‚úù : Small.{u, max u v} ‚Üë(F.comp (CategoryTheory.forget CommMonCat)).sections\n‚ä¢ Small.{u, max u v} ‚Üë((F.comp (CategoryTheory.forget‚ÇÇ CommMonCat MonCat)).comp (CategoryTheory.forget MonCat)).sections","decl":"@[to_additive]\ninstance : Small.{u} (Functor.sections ((F ‚ãô forget‚ÇÇ CommMonCat MonCat) ‚ãô forget MonCat)) :=\n  inferInstanceAs <| Small.{u} (Functor.sections (F ‚ãô forget CommMonCat))\n\n"}
{"name":"AddCommMonCat.hasLimit","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddCommMonCat\ninst‚úù : Small.{u, max u v} ‚Üë(F.comp (CategoryTheory.forget AddCommMonCat)).sections\n‚ä¢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ‚ãô forget CommMonCat).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ‚ãô forget AddCommMonCat).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"CommMonCat.hasLimit","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J CommMonCat\ninst‚úù : Small.{u, max u v} ‚Üë(F.comp (CategoryTheory.forget CommMonCat)).sections\n‚ä¢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ‚ãô forget CommMonCat).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ‚ãô forget AddCommMonCat).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"AddCommMonCat.hasLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\ninst‚úù : Small.{u, v} J\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J AddCommMonCat","decl":"/-- If `J` is `u`-small, `CommMonCat.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddCommMonCat.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J CommMonCat.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"CommMonCat.hasLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\ninst‚úù : Small.{u, v} J\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J CommMonCat","decl":"/-- If `J` is `u`-small, `CommMonCat.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddCommMonCat.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J CommMonCat.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"CommMonCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} CommMonCat","decl":"/-- The category of commutative monoids has all limits. -/\n@[to_additive \"The category of additive commutative monoids has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} CommMonCat.{u} where\n  has_limits_of_shape _ _ := { }\n\n"}
{"name":"AddCommMonCat.hasLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} AddCommMonCat","decl":"/-- The category of commutative monoids has all limits. -/\n@[to_additive \"The category of additive commutative monoids has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} CommMonCat.{u} where\n  has_limits_of_shape _ _ := { }\n\n"}
{"name":"AddCommMonCat.hasLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasLimits AddCommMonCat","decl":"@[to_additive]\ninstance hasLimits : HasLimits CommMonCat.{u} :=\n  CommMonCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"CommMonCat.hasLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.HasLimits CommMonCat","decl":"@[to_additive]\ninstance hasLimits : HasLimits CommMonCat.{u} :=\n  CommMonCat.hasLimitsOfSize.{u, u}\n\n"}
{"name":"AddCommMonCat.forget‚ÇÇAddMonPreservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget‚ÇÇ AddCommMonCat AddMonCat)","decl":"/-- The forgetful functor from commutative monoids to monoids preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of monoids. -/\n@[to_additive AddCommMonCat.forget‚ÇÇAddMonPreservesLimitsOfSize \"The forgetful functor from\n  additive commutative monoids to additive monoids preserves all limits.\\n\\n\n  This means the underlying type of a limit can be computed as a limit in the category of additive\\n\n  monoids.\",\n  to_additive_relevant_arg 2]\ninstance forget‚ÇÇMon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget‚ÇÇ CommMonCat.{u} MonCat.{u}) where\n  preservesLimitsOfShape {J} ùí• := { }\n\n"}
{"name":"CommMonCat.forget‚ÇÇMon_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget‚ÇÇ CommMonCat MonCat)","decl":"/-- The forgetful functor from commutative monoids to monoids preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of monoids. -/\n@[to_additive AddCommMonCat.forget‚ÇÇAddMonPreservesLimitsOfSize \"The forgetful functor from\n  additive commutative monoids to additive monoids preserves all limits.\\n\\n\n  This means the underlying type of a limit can be computed as a limit in the category of additive\\n\n  monoids.\",\n  to_additive_relevant_arg 2]\ninstance forget‚ÇÇMon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget‚ÇÇ CommMonCat.{u} MonCat.{u}) where\n  preservesLimitsOfShape {J} ùí• := { }\n\n"}
{"name":"AddCommMonCat.forget‚ÇÇMon_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget‚ÇÇ AddCommMonCat AddMonCat)","decl":"@[to_additive]\ninstance forget‚ÇÇMon_preservesLimits :\n    PreservesLimits (forget‚ÇÇ CommMonCat.{u} MonCat.{u}) :=\n  CommMonCat.forget‚ÇÇMon_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommMonCat.forget‚ÇÇMon_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget‚ÇÇ CommMonCat MonCat)","decl":"@[to_additive]\ninstance forget‚ÇÇMon_preservesLimits :\n    PreservesLimits (forget‚ÇÇ CommMonCat.{u} MonCat.{u}) :=\n  CommMonCat.forget‚ÇÇMon_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddCommMonCat.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\ninst‚úù : Small.{u, v} J\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget AddCommMonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `CommMonCat.{u}` preserves limits of\nshape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddCommMonCat.{u}`\\n\npreserves limits of shape `J`.\"]\ninstance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget CommMonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ‚ãô forget _))\n\n"}
{"name":"CommMonCat.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"J : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} J\ninst‚úù : Small.{u, v} J\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget CommMonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `CommMonCat.{u}` preserves limits of\nshape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddCommMonCat.{u}`\\n\npreserves limits of shape `J`.\"]\ninstance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget CommMonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ‚ãô forget _))\n\n"}
{"name":"CommMonCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, u, u, u + 1, u + 1} (CategoryTheory.forget CommMonCat)","decl":"/-- The forgetful functor from commutative monoids to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive \"The forgetful functor from additive commutative monoids to types preserves all\\n\nlimits.\\n\\n\nThis means the underlying type of a limit can be computed as a limit in the category of types.\"]\ninstance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{v, v} (forget CommMonCat.{u}) where\n  preservesLimitsOfShape {_} _ := { }\n\n"}
{"name":"AddCommMonCat.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"inst‚úù : UnivLE.{v, u}\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, v, u, u, u + 1, u + 1} (CategoryTheory.forget AddCommMonCat)","decl":"/-- The forgetful functor from commutative monoids to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive \"The forgetful functor from additive commutative monoids to types preserves all\\n\nlimits.\\n\\n\nThis means the underlying type of a limit can be computed as a limit in the category of types.\"]\ninstance forget_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{v, v} (forget CommMonCat.{u}) where\n  preservesLimitsOfShape {_} _ := { }\n\n"}
{"name":"AddCommMonCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget AddCommMonCat)","decl":"instance _root_.AddCommMonCat.forget_preservesLimits :\n    PreservesLimits (forget AddCommMonCat.{u}) :=\n  AddCommMonCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommMonCat.forget_preservesLimits","module":"Mathlib.Algebra.Category.MonCat.Limits","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget CommMonCat)","decl":"@[to_additive existing]\ninstance forget_preservesLimits : PreservesLimits (forget CommMonCat.{u}) :=\n  CommMonCat.forget_preservesLimitsOfSize.{u, u}\n\n"}
