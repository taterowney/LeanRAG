{"name":"unitInterval.zero_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Membership.mem unitInterval 0","decl":"theorem zero_mem : (0 : ℝ) ∈ I :=\n  ⟨le_rfl, zero_le_one⟩\n\n"}
{"name":"unitInterval.one_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Membership.mem unitInterval 1","decl":"theorem one_mem : (1 : ℝ) ∈ I :=\n  ⟨zero_le_one, le_rfl⟩\n\n"}
{"name":"unitInterval.mul_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"x y : Real\nhx : Membership.mem unitInterval x\nhy : Membership.mem unitInterval y\n⊢ Membership.mem unitInterval (HMul.hMul x y)","decl":"theorem mul_mem {x y : ℝ} (hx : x ∈ I) (hy : y ∈ I) : x * y ∈ I :=\n  ⟨mul_nonneg hx.1 hy.1, mul_le_one₀ hx.2 hy.1 hy.2⟩\n\n"}
{"name":"unitInterval.div_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"x y : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhxy : LE.le x y\n⊢ Membership.mem unitInterval (HDiv.hDiv x y)","decl":"theorem div_mem {x y : ℝ} (hx : 0 ≤ x) (hy : 0 ≤ y) (hxy : x ≤ y) : x / y ∈ I :=\n  ⟨div_nonneg hx hy, div_le_one_of_le₀ hxy hy⟩\n\n"}
{"name":"unitInterval.fract_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : Real\n⊢ Membership.mem unitInterval (Int.fract x)","decl":"theorem fract_mem (x : ℝ) : fract x ∈ I :=\n  ⟨fract_nonneg _, (fract_lt_one _).le⟩\n\n"}
{"name":"unitInterval.mem_iff_one_sub_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : Real\n⊢ Iff (Membership.mem unitInterval t) (Membership.mem unitInterval (HSub.hSub 1 t))","decl":"theorem mem_iff_one_sub_mem {t : ℝ} : t ∈ I ↔ 1 - t ∈ I := by\n  rw [mem_Icc, mem_Icc]\n  constructor <;> intro <;> constructor <;> linarith\n\n"}
{"name":"unitInterval.instZeroLEOneClassElemReal","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ ZeroLEOneClass ↑unitInterval","decl":"instance : ZeroLEOneClass I := ⟨zero_le_one (α := ℝ)⟩\n\n"}
{"name":"unitInterval.univ_eq_Icc","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Eq Set.univ (Set.Icc 0 1)","decl":"lemma univ_eq_Icc : (univ : Set I) = Icc (0 : I) (1 : I) := Icc_bot_top.symm\n\n"}
{"name":"unitInterval.coe_ne_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ Iff (Ne (↑x) 0) (Ne x 0)","decl":"@[norm_cast] theorem coe_ne_zero {x : I} : (x : ℝ) ≠ 0 ↔ x ≠ 0 := coe_eq_zero.not\n"}
{"name":"unitInterval.coe_ne_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ Iff (Ne (↑x) 1) (Ne x 1)","decl":"@[norm_cast] theorem coe_ne_one {x : I} : (x : ℝ) ≠ 1 ↔ x ≠ 1 := coe_eq_one.not\n"}
{"name":"unitInterval.coe_pos","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ Iff (LT.lt 0 ↑x) (LT.lt 0 x)","decl":"@[simp, norm_cast] theorem coe_pos {x : I} : (0 : ℝ) < x ↔ 0 < x := Iff.rfl\n"}
{"name":"unitInterval.coe_lt_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ Iff (LT.lt (↑x) 1) (LT.lt x 1)","decl":"@[simp, norm_cast] theorem coe_lt_one {x : I} : (x : ℝ) < 1 ↔ x < 1 := Iff.rfl\n\n"}
{"name":"unitInterval.instNonemptyElemReal","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Nonempty ↑unitInterval","decl":"instance : Nonempty I :=\n  ⟨0⟩\n\n"}
{"name":"unitInterval.mul_le_left","module":"Mathlib.Topology.UnitInterval","initialProofState":"x y : ↑unitInterval\n⊢ LE.le (HMul.hMul x y) x","decl":"theorem mul_le_left {x y : I} : x * y ≤ x :=\n  Subtype.coe_le_coe.mp <| mul_le_of_le_one_right x.2.1 y.2.2\n\n"}
{"name":"unitInterval.mul_le_right","module":"Mathlib.Topology.UnitInterval","initialProofState":"x y : ↑unitInterval\n⊢ LE.le (HMul.hMul x y) y","decl":"theorem mul_le_right {x y : I} : x * y ≤ y :=\n  Subtype.coe_le_coe.mp <| mul_le_of_le_one_left y.2.1 x.2.2\n\n"}
{"name":"unitInterval.symm_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Eq (unitInterval.symm 0) 1","decl":"@[simp]\ntheorem symm_zero : σ 0 = 1 :=\n  Subtype.ext <| by simp [symm]\n\n"}
{"name":"unitInterval.symm_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Eq (unitInterval.symm 1) 0","decl":"@[simp]\ntheorem symm_one : σ 1 = 0 :=\n  Subtype.ext <| by simp [symm]\n\n"}
{"name":"unitInterval.symm_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ Eq (unitInterval.symm (unitInterval.symm x)) x","decl":"@[simp]\ntheorem symm_symm (x : I) : σ (σ x) = x :=\n  Subtype.ext <| by simp [symm]\n\n"}
{"name":"unitInterval.symm_involutive","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Function.Involutive unitInterval.symm","decl":"theorem symm_involutive : Function.Involutive (symm : I → I) := symm_symm\n\n"}
{"name":"unitInterval.symm_bijective","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Function.Bijective unitInterval.symm","decl":"theorem symm_bijective : Function.Bijective (symm : I → I) := symm_involutive.bijective\n\n"}
{"name":"unitInterval.coe_symm_eq","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ Eq (↑(unitInterval.symm x)) (HSub.hSub 1 ↑x)","decl":"@[simp]\ntheorem coe_symm_eq (x : I) : (σ x : ℝ) = 1 - x :=\n  rfl\n\n-- Porting note: Proof used to be `by continuity!`\n"}
{"name":"unitInterval.continuous_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Continuous unitInterval.symm","decl":"@[continuity, fun_prop]\ntheorem continuous_symm : Continuous σ := by\n  apply Continuous.subtype_mk (by fun_prop)\n\n"}
{"name":"unitInterval.symmHomeomorph_symm_apply","module":"Mathlib.Topology.UnitInterval","initialProofState":"a✝ : ↑unitInterval\n⊢ Eq (unitInterval.symmHomeomorph.symm a✝) (unitInterval.symm a✝)","decl":"/-- `unitInterval.symm` as a `Homeomorph`. -/\n@[simps]\ndef symmHomeomorph : I ≃ₜ I where\n  toFun := symm\n  invFun := symm\n  left_inv := symm_symm\n  right_inv := symm_symm\n\n"}
{"name":"unitInterval.symmHomeomorph_apply","module":"Mathlib.Topology.UnitInterval","initialProofState":"a✝ : ↑unitInterval\n⊢ Eq (unitInterval.symmHomeomorph a✝) (unitInterval.symm a✝)","decl":"/-- `unitInterval.symm` as a `Homeomorph`. -/\n@[simps]\ndef symmHomeomorph : I ≃ₜ I where\n  toFun := symm\n  invFun := symm\n  left_inv := symm_symm\n  right_inv := symm_symm\n\n"}
{"name":"unitInterval.strictAnti_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ StrictAnti unitInterval.symm","decl":"theorem strictAnti_symm : StrictAnti σ := fun _ _ h ↦ sub_lt_sub_left (α := ℝ) h _\n\n\n"}
{"name":"unitInterval.symm_inj","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ↑unitInterval\n⊢ Iff (Eq (unitInterval.symm i) (unitInterval.symm j)) (Eq i j)","decl":"@[simp]\ntheorem symm_inj {i j : I} : σ i = σ j ↔ i = j := symm_bijective.injective.eq_iff\n\n"}
{"name":"unitInterval.half_le_symm_iff","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : ↑unitInterval\n⊢ Iff (LE.le (1 / 2) ↑(unitInterval.symm t)) (LE.le (↑t) (1 / 2))","decl":"theorem half_le_symm_iff (t : I) : 1 / 2 ≤ (σ t : ℝ) ↔ (t : ℝ) ≤ 1 / 2 := by\n  rw [coe_symm_eq, le_sub_iff_add_le, add_comm, ← le_sub_iff_add_le, sub_half]\n\n"}
{"name":"unitInterval.symm_eq_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"i : ↑unitInterval\n⊢ Iff (Eq (unitInterval.symm i) 1) (Eq i 0)","decl":"@[simp]\nlemma symm_eq_one {i : I} : σ i = 1 ↔ i = 0 := by\n  rw [← symm_zero, symm_inj]\n\n"}
{"name":"unitInterval.symm_eq_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"i : ↑unitInterval\n⊢ Iff (Eq (unitInterval.symm i) 0) (Eq i 1)","decl":"@[simp]\nlemma symm_eq_zero {i : I} : σ i = 0 ↔ i = 1 := by\n  rw [← symm_one, symm_inj]\n\n"}
{"name":"unitInterval.symm_le_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ↑unitInterval\n⊢ Iff (LE.le (unitInterval.symm i) (unitInterval.symm j)) (LE.le j i)","decl":"@[simp]\ntheorem symm_le_symm {i j : I} : σ i ≤ σ j ↔ j ≤ i := by\n  simp only [symm, Subtype.mk_le_mk, sub_le_sub_iff, add_le_add_iff_left, Subtype.coe_le_coe]\n\n"}
{"name":"unitInterval.le_symm_comm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ↑unitInterval\n⊢ Iff (LE.le i (unitInterval.symm j)) (LE.le j (unitInterval.symm i))","decl":"theorem le_symm_comm {i j : I} : i ≤ σ j ↔ j ≤ σ i := by\n  rw [← symm_le_symm, symm_symm]\n\n"}
{"name":"unitInterval.symm_le_comm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ↑unitInterval\n⊢ Iff (LE.le (unitInterval.symm i) j) (LE.le (unitInterval.symm j) i)","decl":"theorem symm_le_comm {i j : I} : σ i ≤ j ↔ σ j ≤ i := by\n  rw [← symm_le_symm, symm_symm]\n\n"}
{"name":"unitInterval.symm_lt_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ↑unitInterval\n⊢ Iff (LT.lt (unitInterval.symm i) (unitInterval.symm j)) (LT.lt j i)","decl":"@[simp]\ntheorem symm_lt_symm {i j : I} : σ i < σ j ↔ j < i := by\n  simp only [symm, Subtype.mk_lt_mk, sub_lt_sub_iff_left, Subtype.coe_lt_coe]\n\n"}
{"name":"unitInterval.lt_symm_comm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ↑unitInterval\n⊢ Iff (LT.lt i (unitInterval.symm j)) (LT.lt j (unitInterval.symm i))","decl":"theorem lt_symm_comm {i j : I} : i < σ j ↔ j < σ i := by\n  rw [← symm_lt_symm, symm_symm]\n\n"}
{"name":"unitInterval.symm_lt_comm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ↑unitInterval\n⊢ Iff (LT.lt (unitInterval.symm i) j) (LT.lt (unitInterval.symm j) i)","decl":"theorem symm_lt_comm {i j : I} : σ i < j ↔ σ j < i := by\n  rw [← symm_lt_symm, symm_symm]\n\n"}
{"name":"unitInterval.instConnectedSpaceElemReal","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ ConnectedSpace ↑unitInterval","decl":"instance : ConnectedSpace I :=\n  Subtype.connectedSpace ⟨nonempty_Icc.mpr zero_le_one, isPreconnected_Icc⟩\n\n"}
{"name":"unitInterval.nonneg","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ LE.le 0 ↑x","decl":"theorem nonneg (x : I) : 0 ≤ (x : ℝ) :=\n  x.2.1\n\n"}
{"name":"unitInterval.one_minus_nonneg","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ LE.le 0 (HSub.hSub 1 ↑x)","decl":"theorem one_minus_nonneg (x : I) : 0 ≤ 1 - (x : ℝ) := by simpa using x.2.2\n\n"}
{"name":"unitInterval.le_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ LE.le (↑x) 1","decl":"theorem le_one (x : I) : (x : ℝ) ≤ 1 :=\n  x.2.2\n\n"}
{"name":"unitInterval.one_minus_le_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ LE.le (HSub.hSub 1 ↑x) 1","decl":"theorem one_minus_le_one (x : I) : 1 - (x : ℝ) ≤ 1 := by simpa using x.2.1\n\n"}
{"name":"unitInterval.add_pos","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : ↑unitInterval\nx : Real\nhx : LT.lt 0 x\n⊢ LT.lt 0 (HAdd.hAdd x ↑t)","decl":"theorem add_pos {t : I} {x : ℝ} (hx : 0 < x) : 0 < (x + t : ℝ) :=\n  add_pos_of_pos_of_nonneg hx <| nonneg _\n\n"}
{"name":"unitInterval.nonneg'","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : ↑unitInterval\n⊢ LE.le 0 t","decl":"/-- like `unitInterval.nonneg`, but with the inequality in `I`. -/\ntheorem nonneg' {t : I} : 0 ≤ t :=\n  t.2.1\n\n"}
{"name":"unitInterval.le_one'","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : ↑unitInterval\n⊢ LE.le t 1","decl":"/-- like `unitInterval.le_one`, but with the inequality in `I`. -/\ntheorem le_one' {t : I} : t ≤ 1 :=\n  t.2.2\n\n"}
{"name":"unitInterval.pos_iff_ne_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ Iff (LT.lt 0 x) (Ne x 0)","decl":"protected lemma pos_iff_ne_zero {x : I} : 0 < x ↔ x ≠ 0 := bot_lt_iff_ne_bot\n\n"}
{"name":"unitInterval.lt_one_iff_ne_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ↑unitInterval\n⊢ Iff (LT.lt x 1) (Ne x 1)","decl":"protected lemma lt_one_iff_ne_one {x : I} : x < 1 ↔ x ≠ 1 := lt_top_iff_ne_top\n\n"}
{"name":"unitInterval.eq_one_or_eq_zero_of_le_mul","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ↑unitInterval\nh : LE.le i (HMul.hMul j i)\n⊢ Or (Eq i 0) (Eq j 1)","decl":"lemma eq_one_or_eq_zero_of_le_mul {i j : I} (h : i ≤ j * i) : i = 0 ∨ j = 1 := by\n  contrapose! h\n  rw [← unitInterval.lt_one_iff_ne_one, ← coe_lt_one, ← unitInterval.pos_iff_ne_zero,\n    ← coe_pos] at h\n  rw [← Subtype.coe_lt_coe, coe_mul]\n  simpa using mul_lt_mul_of_pos_right h.right h.left\n\n"}
{"name":"unitInterval.instNontrivialElemReal","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Nontrivial ↑unitInterval","decl":"instance : Nontrivial I := ⟨⟨1, 0, (one_ne_zero <| congrArg Subtype.val ·)⟩⟩\n\n"}
{"name":"unitInterval.mul_pos_mem_iff","module":"Mathlib.Topology.UnitInterval","initialProofState":"a t : Real\nha : LT.lt 0 a\n⊢ Iff (Membership.mem unitInterval (HMul.hMul a t)) (Membership.mem (Set.Icc 0 (HDiv.hDiv 1 a)) t)","decl":"theorem mul_pos_mem_iff {a t : ℝ} (ha : 0 < a) : a * t ∈ I ↔ t ∈ Set.Icc (0 : ℝ) (1 / a) := by\n  constructor <;> rintro ⟨h₁, h₂⟩ <;> constructor\n  · exact nonneg_of_mul_nonneg_right h₁ ha\n  · rwa [le_div_iff₀ ha, mul_comm]\n  · exact mul_nonneg ha.le h₁\n  · rwa [le_div_iff₀ ha, mul_comm] at h₂\n\n"}
{"name":"unitInterval.two_mul_sub_one_mem_iff","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : Real\n⊢ Iff (Membership.mem unitInterval (HSub.hSub (HMul.hMul 2 t) 1)) (Membership.mem (Set.Icc (1 / 2) 1) t)","decl":"theorem two_mul_sub_one_mem_iff {t : ℝ} : 2 * t - 1 ∈ I ↔ t ∈ Set.Icc (1 / 2 : ℝ) 1 := by\n  constructor <;> rintro ⟨h₁, h₂⟩ <;> constructor <;> linarith\n\n"}
{"name":"unitInterval.coe_unitIntervalSubmonoid","module":"Mathlib.Topology.UnitInterval","initialProofState":"⊢ Eq (↑unitInterval.submonoid) unitInterval","decl":"@[simp] theorem coe_unitIntervalSubmonoid : submonoid = unitInterval := rfl\n"}
{"name":"unitInterval.mem_unitIntervalSubmonoid","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : Real\n⊢ Iff (Membership.mem unitInterval.submonoid x) (Membership.mem unitInterval x)","decl":"@[simp] theorem mem_unitIntervalSubmonoid {x} : x ∈ submonoid ↔ x ∈ unitInterval :=\n  Iff.rfl\n\n"}
{"name":"unitInterval.prod_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"ι : Type u_1\nt : Finset ι\nf : ι → Real\nh : ∀ (c : ι), Membership.mem t c → Membership.mem unitInterval (f c)\n⊢ Membership.mem unitInterval (t.prod fun c => f c)","decl":"protected theorem prod_mem {ι : Type*} {t : Finset ι} {f : ι → ℝ}\n    (h : ∀ c ∈ t, f c ∈ unitInterval) :\n    ∏ c ∈ t, f c ∈ unitInterval := _root_.prod_mem (S := unitInterval.submonoid) h\n\n"}
{"name":"Set.abs_projIcc_sub_projIcc","module":"Mathlib.Topology.UnitInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\na b c d : α\nh : LE.le a b\n⊢ LE.le (abs (HSub.hSub ↑(Set.projIcc a b h c) ↑(Set.projIcc a b h d))) (abs (HSub.hSub c d))","decl":"/-- `Set.projIcc` is a contraction. -/\nlemma _root_.Set.abs_projIcc_sub_projIcc : (|projIcc a b h c - projIcc a b h d| : α) ≤ |c - d| := by\n  wlog hdc : d ≤ c generalizing c d\n  · rw [abs_sub_comm, abs_sub_comm c]; exact this (le_of_not_le hdc)\n  rw [abs_eq_self.2 (sub_nonneg.2 hdc), abs_eq_self.2 (sub_nonneg.2 <| monotone_projIcc h hdc)]\n  rw [← sub_nonneg] at hdc\n  refine (max_sub_max_le_max _ _ _ _).trans (max_le (by rwa [sub_self]) ?_)\n  refine ((le_abs_self _).trans <| abs_min_sub_min_le_max _ _ _ _).trans (max_le ?_ ?_)\n  · rwa [sub_self, abs_zero]\n  · exact (abs_eq_self.mpr hdc).le\n\n"}
{"name":"Set.Icc.addNSMul_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\na b : α\nh : LE.le a b\nδ : α\n⊢ Eq (↑(Set.Icc.addNSMul h δ 0)) a","decl":"lemma addNSMul_zero : addNSMul h δ 0 = a := by\n  rw [addNSMul, zero_smul, add_zero, projIcc_left]\n\n"}
{"name":"Set.Icc.addNSMul_eq_right","module":"Mathlib.Topology.UnitInterval","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup α\na b : α\nh : LE.le a b\nδ : α\ninst✝ : Archimedean α\nhδ : LT.lt 0 δ\n⊢ Exists fun m => ∀ (n : Nat), GE.ge n m → Eq (↑(Set.Icc.addNSMul h δ n)) b","decl":"lemma addNSMul_eq_right [Archimedean α] (hδ : 0 < δ) :\n    ∃ m, ∀ n ≥ m, addNSMul h δ n = b := by\n  obtain ⟨m, hm⟩ := Archimedean.arch (b - a) hδ\n  refine ⟨m, fun n hn ↦ ?_⟩\n  rw [addNSMul, coe_projIcc, add_comm, min_eq_left_iff.mpr, max_eq_right h]\n  exact sub_le_iff_le_add.mp (hm.trans <| nsmul_le_nsmul_left hδ.le hn)\n\n"}
{"name":"Set.Icc.monotone_addNSMul","module":"Mathlib.Topology.UnitInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\na b : α\nh : LE.le a b\nδ : α\nhδ : LE.le 0 δ\n⊢ Monotone (Set.Icc.addNSMul h δ)","decl":"lemma monotone_addNSMul (hδ : 0 ≤ δ) : Monotone (addNSMul h δ) :=\n  fun _ _ hnm ↦ monotone_projIcc h <| (add_le_add_iff_left _).mpr (nsmul_le_nsmul_left hδ hnm)\n\n"}
{"name":"Set.Icc.abs_sub_addNSMul_le","module":"Mathlib.Topology.UnitInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\na b : α\nh : LE.le a b\nδ : α\nhδ : LE.le 0 δ\nt : ↑(Set.Icc a b)\nn : Nat\nht : Membership.mem (Set.Icc (Set.Icc.addNSMul h δ n) (Set.Icc.addNSMul h δ (HAdd.hAdd n 1))) t\n⊢ LE.le (abs (HSub.hSub ↑t ↑(Set.Icc.addNSMul h δ n))) δ","decl":"lemma abs_sub_addNSMul_le (hδ : 0 ≤ δ) {t : Icc a b} (n : ℕ)\n    (ht : t ∈ Icc (addNSMul h δ n) (addNSMul h δ (n+1))) :\n    (|t - addNSMul h δ n| : α) ≤ δ :=\n  calc\n    (|t - addNSMul h δ n| : α) = t - addNSMul h δ n            := abs_eq_self.2 <| sub_nonneg.2 ht.1\n    _ ≤ projIcc a b h (a + (n+1) • δ) - addNSMul h δ n := by apply sub_le_sub_right; exact ht.2\n    _ ≤ (|projIcc a b h (a + (n+1) • δ) - addNSMul h δ n| : α) := le_abs_self _\n    _ ≤ |a + (n+1) • δ - (a + n • δ)|                          := abs_projIcc_sub_projIcc h\n    _ ≤ δ := by\n          rw [add_sub_add_comm, sub_self, zero_add, succ_nsmul', add_sub_cancel_right]\n          exact (abs_eq_self.mpr hδ).le\n\n"}
{"name":"exists_monotone_Icc_subset_open_cover_Icc","module":"Mathlib.Topology.UnitInterval","initialProofState":"ι : Sort u_1\na b : Real\nh : LE.le a b\nc : ι → Set ↑(Set.Icc a b)\nhc₁ : ∀ (i : ι), IsOpen (c i)\nhc₂ : HasSubset.Subset Set.univ (Set.iUnion fun i => c i)\n⊢ Exists fun t => And (Eq (↑(t 0)) a) (And (Monotone t) (And (Exists fun m => ∀ (n : Nat), GE.ge n m → Eq (↑(t n)) b) (∀ (n : Nat), Exists fun i => HasSubset.Subset (Set.Icc (t n) (t (HAdd.hAdd n 1))) (c i))))","decl":"/-- Any open cover `c` of a closed interval `[a, b]` in ℝ can be refined to\n  a finite partition into subintervals. -/\nlemma exists_monotone_Icc_subset_open_cover_Icc {ι} {a b : ℝ} (h : a ≤ b) {c : ι → Set (Icc a b)}\n    (hc₁ : ∀ i, IsOpen (c i)) (hc₂ : univ ⊆ ⋃ i, c i) : ∃ t : ℕ → Icc a b, t 0 = a ∧\n      Monotone t ∧ (∃ m, ∀ n ≥ m, t n = b) ∧ ∀ n, ∃ i, Icc (t n) (t (n + 1)) ⊆ c i := by\n  obtain ⟨δ, δ_pos, ball_subset⟩ := lebesgue_number_lemma_of_metric isCompact_univ hc₁ hc₂\n  have hδ := half_pos δ_pos\n  refine ⟨addNSMul h (δ/2), addNSMul_zero h,\n    monotone_addNSMul h hδ.le, addNSMul_eq_right h hδ, fun n ↦ ?_⟩\n  obtain ⟨i, hsub⟩ := ball_subset (addNSMul h (δ/2) n) trivial\n  exact ⟨i, fun t ht ↦ hsub ((abs_sub_addNSMul_le h hδ.le n ht).trans_lt <| half_lt_self δ_pos)⟩\n\n"}
{"name":"exists_monotone_Icc_subset_open_cover_unitInterval","module":"Mathlib.Topology.UnitInterval","initialProofState":"ι : Sort u_1\nc : ι → Set ↑unitInterval\nhc₁ : ∀ (i : ι), IsOpen (c i)\nhc₂ : HasSubset.Subset Set.univ (Set.iUnion fun i => c i)\n⊢ Exists fun t => And (Eq (t 0) 0) (And (Monotone t) (And (Exists fun n => ∀ (m : Nat), GE.ge m n → Eq (t m) 1) (∀ (n : Nat), Exists fun i => HasSubset.Subset (Set.Icc (t n) (t (HAdd.hAdd n 1))) (c i))))","decl":"/-- Any open cover of the unit interval can be refined to a finite partition into subintervals. -/\nlemma exists_monotone_Icc_subset_open_cover_unitInterval {ι} {c : ι → Set I}\n    (hc₁ : ∀ i, IsOpen (c i)) (hc₂ : univ ⊆ ⋃ i, c i) : ∃ t : ℕ → I, t 0 = 0 ∧\n      Monotone t ∧ (∃ n, ∀ m ≥ n, t m = 1) ∧ ∀ n, ∃ i, Icc (t n) (t (n + 1)) ⊆ c i := by\n  simp_rw [← Subtype.coe_inj]\n  exact exists_monotone_Icc_subset_open_cover_Icc zero_le_one hc₁ hc₂\n\n"}
{"name":"exists_monotone_Icc_subset_open_cover_unitInterval_prod_self","module":"Mathlib.Topology.UnitInterval","initialProofState":"ι : Sort u_1\nc : ι → Set (Prod ↑unitInterval ↑unitInterval)\nhc₁ : ∀ (i : ι), IsOpen (c i)\nhc₂ : HasSubset.Subset Set.univ (Set.iUnion fun i => c i)\n⊢ Exists fun t => And (Eq (t 0) 0) (And (Monotone t) (And (Exists fun n => ∀ (m : Nat), GE.ge m n → Eq (t m) 1) (∀ (n m : Nat), Exists fun i => HasSubset.Subset (SProd.sprod (Set.Icc (t n) (t (HAdd.hAdd n 1))) (Set.Icc (t m) (t (HAdd.hAdd m 1)))) (c i))))","decl":"lemma exists_monotone_Icc_subset_open_cover_unitInterval_prod_self {ι} {c : ι → Set (I × I)}\n    (hc₁ : ∀ i, IsOpen (c i)) (hc₂ : univ ⊆ ⋃ i, c i) :\n    ∃ t : ℕ → I, t 0 = 0 ∧ Monotone t ∧ (∃ n, ∀ m ≥ n, t m = 1) ∧\n      ∀ n m, ∃ i, Icc (t n) (t (n + 1)) ×ˢ Icc (t m) (t (m + 1)) ⊆ c i := by\n  obtain ⟨δ, δ_pos, ball_subset⟩ := lebesgue_number_lemma_of_metric isCompact_univ hc₁ hc₂\n  have hδ := half_pos δ_pos\n  simp_rw [Subtype.ext_iff]\n  have h : (0 : ℝ) ≤ 1 := zero_le_one\n  refine ⟨addNSMul h (δ/2), addNSMul_zero h,\n    monotone_addNSMul h hδ.le, addNSMul_eq_right h hδ, fun n m ↦ ?_⟩\n  obtain ⟨i, hsub⟩ := ball_subset (addNSMul h (δ/2) n, addNSMul h (δ/2) m) trivial\n  exact ⟨i, fun t ht ↦ hsub (Metric.mem_ball.mpr <| (max_le (abs_sub_addNSMul_le h hδ.le n ht.1) <|\n    abs_sub_addNSMul_le h hδ.le m ht.2).trans_lt <| half_lt_self δ_pos)⟩\n\n"}
{"name":"projIcc_eq_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : Real\n⊢ Iff (Eq (Set.projIcc 0 1 ⋯ x) 0) (LE.le x 0)","decl":"@[simp]\ntheorem projIcc_eq_zero {x : ℝ} : projIcc (0 : ℝ) 1 zero_le_one x = 0 ↔ x ≤ 0 :=\n  projIcc_eq_left zero_lt_one\n\n"}
{"name":"projIcc_eq_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : Real\n⊢ Iff (Eq (Set.projIcc 0 1 ⋯ x) 1) (LE.le 1 x)","decl":"@[simp]\ntheorem projIcc_eq_one {x : ℝ} : projIcc (0 : ℝ) 1 zero_le_one x = 1 ↔ 1 ≤ x :=\n  projIcc_eq_right zero_lt_one\n\n"}
{"name":"affineHomeomorph_image_I","module":"Mathlib.Topology.UnitInterval","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : TopologicalRing 𝕜\na b : 𝕜\nh : LT.lt 0 a\n⊢ Eq (Set.image (⇑(affineHomeomorph a b ⋯)) (Set.Icc 0 1)) (Set.Icc b (HAdd.hAdd a b))","decl":"/-- The image of `[0,1]` under the homeomorphism `fun x ↦ a * x + b` is `[b, a+b]`.\n-/\ntheorem affineHomeomorph_image_I (a b : 𝕜) (h : 0 < a) :\n    affineHomeomorph a b h.ne.symm '' Set.Icc 0 1 = Set.Icc b (a + b) := by simp [h]\n\n"}
{"name":"iccHomeoI_apply_coe","module":"Mathlib.Topology.UnitInterval","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : TopologicalRing 𝕜\na b : 𝕜\nh : LT.lt a b\nx : ↑(Set.Icc a b)\n⊢ Eq (↑((iccHomeoI a b h) x)) (HDiv.hDiv (HSub.hSub (↑x) a) (HSub.hSub b a))","decl":"@[simp]\ntheorem iccHomeoI_apply_coe (a b : 𝕜) (h : a < b) (x : Set.Icc a b) :\n    ((iccHomeoI a b h) x : 𝕜) = (x - a) / (b - a) :=\n  rfl\n\n"}
{"name":"iccHomeoI_symm_apply_coe","module":"Mathlib.Topology.UnitInterval","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : TopologicalRing 𝕜\na b : 𝕜\nh : LT.lt a b\nx : ↑(Set.Icc 0 1)\n⊢ Eq (↑((iccHomeoI a b h).symm x)) (HAdd.hAdd (HMul.hMul (HSub.hSub b a) ↑x) a)","decl":"@[simp]\ntheorem iccHomeoI_symm_apply_coe (a b : 𝕜) (h : a < b) (x : Set.Icc (0 : 𝕜) (1 : 𝕜)) :\n    ((iccHomeoI a b h).symm x : 𝕜) = (b - a) * x + a :=\n  rfl\n\n"}
