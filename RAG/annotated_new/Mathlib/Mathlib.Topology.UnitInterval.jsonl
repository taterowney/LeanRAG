{"name":"unitInterval.zero_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Membership.mem unitInterval 0","decl":"theorem zero_mem : (0 : ‚Ñù) ‚àà I :=\n  ‚ü®le_rfl, zero_le_one‚ü©\n\n"}
{"name":"unitInterval.one_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Membership.mem unitInterval 1","decl":"theorem one_mem : (1 : ‚Ñù) ‚àà I :=\n  ‚ü®zero_le_one, le_rfl‚ü©\n\n"}
{"name":"unitInterval.mul_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"x y : Real\nhx : Membership.mem unitInterval x\nhy : Membership.mem unitInterval y\n‚ä¢ Membership.mem unitInterval (HMul.hMul x y)","decl":"theorem mul_mem {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=\n  ‚ü®mul_nonneg hx.1 hy.1, mul_le_one‚ÇÄ hx.2 hy.1 hy.2‚ü©\n\n"}
{"name":"unitInterval.div_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"x y : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\nhxy : LE.le x y\n‚ä¢ Membership.mem unitInterval (HDiv.hDiv x y)","decl":"theorem div_mem {x y : ‚Ñù} (hx : 0 ‚â§ x) (hy : 0 ‚â§ y) (hxy : x ‚â§ y) : x / y ‚àà I :=\n  ‚ü®div_nonneg hx hy, div_le_one_of_le‚ÇÄ hxy hy‚ü©\n\n"}
{"name":"unitInterval.fract_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : Real\n‚ä¢ Membership.mem unitInterval (Int.fract x)","decl":"theorem fract_mem (x : ‚Ñù) : fract x ‚àà I :=\n  ‚ü®fract_nonneg _, (fract_lt_one _).le‚ü©\n\n"}
{"name":"unitInterval.mem_iff_one_sub_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : Real\n‚ä¢ Iff (Membership.mem unitInterval t) (Membership.mem unitInterval (HSub.hSub 1 t))","decl":"theorem mem_iff_one_sub_mem {t : ‚Ñù} : t ‚àà I ‚Üî 1 - t ‚àà I := by\n  rw [mem_Icc, mem_Icc]\n  constructor <;> intro <;> constructor <;> linarith\n\n"}
{"name":"unitInterval.instZeroLEOneClassElemReal","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ ZeroLEOneClass ‚ÜëunitInterval","decl":"instance : ZeroLEOneClass I := ‚ü®zero_le_one (Œ± := ‚Ñù)‚ü©\n\n"}
{"name":"unitInterval.univ_eq_Icc","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Eq Set.univ (Set.Icc 0 1)","decl":"lemma univ_eq_Icc : (univ : Set I) = Icc (0 : I) (1 : I) := Icc_bot_top.symm\n\n"}
{"name":"unitInterval.coe_ne_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ Iff (Ne (‚Üëx) 0) (Ne x 0)","decl":"@[norm_cast] theorem coe_ne_zero {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 := coe_eq_zero.not\n"}
{"name":"unitInterval.coe_ne_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ Iff (Ne (‚Üëx) 1) (Ne x 1)","decl":"@[norm_cast] theorem coe_ne_one {x : I} : (x : ‚Ñù) ‚â† 1 ‚Üî x ‚â† 1 := coe_eq_one.not\n"}
{"name":"unitInterval.coe_pos","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ Iff (LT.lt 0 ‚Üëx) (LT.lt 0 x)","decl":"@[simp, norm_cast] theorem coe_pos {x : I} : (0 : ‚Ñù) < x ‚Üî 0 < x := Iff.rfl\n"}
{"name":"unitInterval.coe_lt_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ Iff (LT.lt (‚Üëx) 1) (LT.lt x 1)","decl":"@[simp, norm_cast] theorem coe_lt_one {x : I} : (x : ‚Ñù) < 1 ‚Üî x < 1 := Iff.rfl\n\n"}
{"name":"unitInterval.instNonemptyElemReal","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Nonempty ‚ÜëunitInterval","decl":"instance : Nonempty I :=\n  ‚ü®0‚ü©\n\n"}
{"name":"unitInterval.mul_le_left","module":"Mathlib.Topology.UnitInterval","initialProofState":"x y : ‚ÜëunitInterval\n‚ä¢ LE.le (HMul.hMul x y) x","decl":"theorem mul_le_left {x y : I} : x * y ‚â§ x :=\n  Subtype.coe_le_coe.mp <| mul_le_of_le_one_right x.2.1 y.2.2\n\n"}
{"name":"unitInterval.mul_le_right","module":"Mathlib.Topology.UnitInterval","initialProofState":"x y : ‚ÜëunitInterval\n‚ä¢ LE.le (HMul.hMul x y) y","decl":"theorem mul_le_right {x y : I} : x * y ‚â§ y :=\n  Subtype.coe_le_coe.mp <| mul_le_of_le_one_left y.2.1 x.2.2\n\n"}
{"name":"unitInterval.symm_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Eq (unitInterval.symm 0) 1","decl":"@[simp]\ntheorem symm_zero : œÉ 0 = 1 :=\n  Subtype.ext <| by simp [symm]\n\n"}
{"name":"unitInterval.symm_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Eq (unitInterval.symm 1) 0","decl":"@[simp]\ntheorem symm_one : œÉ 1 = 0 :=\n  Subtype.ext <| by simp [symm]\n\n"}
{"name":"unitInterval.symm_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ Eq (unitInterval.symm (unitInterval.symm x)) x","decl":"@[simp]\ntheorem symm_symm (x : I) : œÉ (œÉ x) = x :=\n  Subtype.ext <| by simp [symm]\n\n"}
{"name":"unitInterval.symm_involutive","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Function.Involutive unitInterval.symm","decl":"theorem symm_involutive : Function.Involutive (symm : I ‚Üí I) := symm_symm\n\n"}
{"name":"unitInterval.symm_bijective","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Function.Bijective unitInterval.symm","decl":"theorem symm_bijective : Function.Bijective (symm : I ‚Üí I) := symm_involutive.bijective\n\n"}
{"name":"unitInterval.coe_symm_eq","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ Eq (‚Üë(unitInterval.symm x)) (HSub.hSub 1 ‚Üëx)","decl":"@[simp]\ntheorem coe_symm_eq (x : I) : (œÉ x : ‚Ñù) = 1 - x :=\n  rfl\n\n-- Porting note: Proof used to be `by continuity!`\n"}
{"name":"unitInterval.continuous_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Continuous unitInterval.symm","decl":"@[continuity, fun_prop]\ntheorem continuous_symm : Continuous œÉ := by\n  apply Continuous.subtype_mk (by fun_prop)\n\n"}
{"name":"unitInterval.symmHomeomorph_symm_apply","module":"Mathlib.Topology.UnitInterval","initialProofState":"a‚úù : ‚ÜëunitInterval\n‚ä¢ Eq (unitInterval.symmHomeomorph.symm a‚úù) (unitInterval.symm a‚úù)","decl":"/-- `unitInterval.symm` as a `Homeomorph`. -/\n@[simps]\ndef symmHomeomorph : I ‚âÉ‚Çú I where\n  toFun := symm\n  invFun := symm\n  left_inv := symm_symm\n  right_inv := symm_symm\n\n"}
{"name":"unitInterval.symmHomeomorph_apply","module":"Mathlib.Topology.UnitInterval","initialProofState":"a‚úù : ‚ÜëunitInterval\n‚ä¢ Eq (unitInterval.symmHomeomorph a‚úù) (unitInterval.symm a‚úù)","decl":"/-- `unitInterval.symm` as a `Homeomorph`. -/\n@[simps]\ndef symmHomeomorph : I ‚âÉ‚Çú I where\n  toFun := symm\n  invFun := symm\n  left_inv := symm_symm\n  right_inv := symm_symm\n\n"}
{"name":"unitInterval.strictAnti_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ StrictAnti unitInterval.symm","decl":"theorem strictAnti_symm : StrictAnti œÉ := fun _ _ h ‚Ü¶ sub_lt_sub_left (Œ± := ‚Ñù) h _\n\n\n"}
{"name":"unitInterval.symm_inj","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ‚ÜëunitInterval\n‚ä¢ Iff (Eq (unitInterval.symm i) (unitInterval.symm j)) (Eq i j)","decl":"@[simp]\ntheorem symm_inj {i j : I} : œÉ i = œÉ j ‚Üî i = j := symm_bijective.injective.eq_iff\n\n"}
{"name":"unitInterval.half_le_symm_iff","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : ‚ÜëunitInterval\n‚ä¢ Iff (LE.le (1 / 2) ‚Üë(unitInterval.symm t)) (LE.le (‚Üët) (1 / 2))","decl":"theorem half_le_symm_iff (t : I) : 1 / 2 ‚â§ (œÉ t : ‚Ñù) ‚Üî (t : ‚Ñù) ‚â§ 1 / 2 := by\n  rw [coe_symm_eq, le_sub_iff_add_le, add_comm, ‚Üê le_sub_iff_add_le, sub_half]\n\n"}
{"name":"unitInterval.symm_eq_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"i : ‚ÜëunitInterval\n‚ä¢ Iff (Eq (unitInterval.symm i) 1) (Eq i 0)","decl":"@[simp]\nlemma symm_eq_one {i : I} : œÉ i = 1 ‚Üî i = 0 := by\n  rw [‚Üê symm_zero, symm_inj]\n\n"}
{"name":"unitInterval.symm_eq_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"i : ‚ÜëunitInterval\n‚ä¢ Iff (Eq (unitInterval.symm i) 0) (Eq i 1)","decl":"@[simp]\nlemma symm_eq_zero {i : I} : œÉ i = 0 ‚Üî i = 1 := by\n  rw [‚Üê symm_one, symm_inj]\n\n"}
{"name":"unitInterval.symm_le_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ‚ÜëunitInterval\n‚ä¢ Iff (LE.le (unitInterval.symm i) (unitInterval.symm j)) (LE.le j i)","decl":"@[simp]\ntheorem symm_le_symm {i j : I} : œÉ i ‚â§ œÉ j ‚Üî j ‚â§ i := by\n  simp only [symm, Subtype.mk_le_mk, sub_le_sub_iff, add_le_add_iff_left, Subtype.coe_le_coe]\n\n"}
{"name":"unitInterval.le_symm_comm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ‚ÜëunitInterval\n‚ä¢ Iff (LE.le i (unitInterval.symm j)) (LE.le j (unitInterval.symm i))","decl":"theorem le_symm_comm {i j : I} : i ‚â§ œÉ j ‚Üî j ‚â§ œÉ i := by\n  rw [‚Üê symm_le_symm, symm_symm]\n\n"}
{"name":"unitInterval.symm_le_comm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ‚ÜëunitInterval\n‚ä¢ Iff (LE.le (unitInterval.symm i) j) (LE.le (unitInterval.symm j) i)","decl":"theorem symm_le_comm {i j : I} : œÉ i ‚â§ j ‚Üî œÉ j ‚â§ i := by\n  rw [‚Üê symm_le_symm, symm_symm]\n\n"}
{"name":"unitInterval.symm_lt_symm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ‚ÜëunitInterval\n‚ä¢ Iff (LT.lt (unitInterval.symm i) (unitInterval.symm j)) (LT.lt j i)","decl":"@[simp]\ntheorem symm_lt_symm {i j : I} : œÉ i < œÉ j ‚Üî j < i := by\n  simp only [symm, Subtype.mk_lt_mk, sub_lt_sub_iff_left, Subtype.coe_lt_coe]\n\n"}
{"name":"unitInterval.lt_symm_comm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ‚ÜëunitInterval\n‚ä¢ Iff (LT.lt i (unitInterval.symm j)) (LT.lt j (unitInterval.symm i))","decl":"theorem lt_symm_comm {i j : I} : i < œÉ j ‚Üî j < œÉ i := by\n  rw [‚Üê symm_lt_symm, symm_symm]\n\n"}
{"name":"unitInterval.symm_lt_comm","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ‚ÜëunitInterval\n‚ä¢ Iff (LT.lt (unitInterval.symm i) j) (LT.lt (unitInterval.symm j) i)","decl":"theorem symm_lt_comm {i j : I} : œÉ i < j ‚Üî œÉ j < i := by\n  rw [‚Üê symm_lt_symm, symm_symm]\n\n"}
{"name":"unitInterval.instConnectedSpaceElemReal","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ ConnectedSpace ‚ÜëunitInterval","decl":"instance : ConnectedSpace I :=\n  Subtype.connectedSpace ‚ü®nonempty_Icc.mpr zero_le_one, isPreconnected_Icc‚ü©\n\n"}
{"name":"unitInterval.nonneg","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ LE.le 0 ‚Üëx","decl":"theorem nonneg (x : I) : 0 ‚â§ (x : ‚Ñù) :=\n  x.2.1\n\n"}
{"name":"unitInterval.one_minus_nonneg","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ LE.le 0 (HSub.hSub 1 ‚Üëx)","decl":"theorem one_minus_nonneg (x : I) : 0 ‚â§ 1 - (x : ‚Ñù) := by simpa using x.2.2\n\n"}
{"name":"unitInterval.le_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ LE.le (‚Üëx) 1","decl":"theorem le_one (x : I) : (x : ‚Ñù) ‚â§ 1 :=\n  x.2.2\n\n"}
{"name":"unitInterval.one_minus_le_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ LE.le (HSub.hSub 1 ‚Üëx) 1","decl":"theorem one_minus_le_one (x : I) : 1 - (x : ‚Ñù) ‚â§ 1 := by simpa using x.2.1\n\n"}
{"name":"unitInterval.add_pos","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : ‚ÜëunitInterval\nx : Real\nhx : LT.lt 0 x\n‚ä¢ LT.lt 0 (HAdd.hAdd x ‚Üët)","decl":"theorem add_pos {t : I} {x : ‚Ñù} (hx : 0 < x) : 0 < (x + t : ‚Ñù) :=\n  add_pos_of_pos_of_nonneg hx <| nonneg _\n\n"}
{"name":"unitInterval.nonneg'","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : ‚ÜëunitInterval\n‚ä¢ LE.le 0 t","decl":"/-- like `unitInterval.nonneg`, but with the inequality in `I`. -/\ntheorem nonneg' {t : I} : 0 ‚â§ t :=\n  t.2.1\n\n"}
{"name":"unitInterval.le_one'","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : ‚ÜëunitInterval\n‚ä¢ LE.le t 1","decl":"/-- like `unitInterval.le_one`, but with the inequality in `I`. -/\ntheorem le_one' {t : I} : t ‚â§ 1 :=\n  t.2.2\n\n"}
{"name":"unitInterval.pos_iff_ne_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ Iff (LT.lt 0 x) (Ne x 0)","decl":"protected lemma pos_iff_ne_zero {x : I} : 0 < x ‚Üî x ‚â† 0 := bot_lt_iff_ne_bot\n\n"}
{"name":"unitInterval.lt_one_iff_ne_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : ‚ÜëunitInterval\n‚ä¢ Iff (LT.lt x 1) (Ne x 1)","decl":"protected lemma lt_one_iff_ne_one {x : I} : x < 1 ‚Üî x ‚â† 1 := lt_top_iff_ne_top\n\n"}
{"name":"unitInterval.eq_one_or_eq_zero_of_le_mul","module":"Mathlib.Topology.UnitInterval","initialProofState":"i j : ‚ÜëunitInterval\nh : LE.le i (HMul.hMul j i)\n‚ä¢ Or (Eq i 0) (Eq j 1)","decl":"lemma eq_one_or_eq_zero_of_le_mul {i j : I} (h : i ‚â§ j * i) : i = 0 ‚à® j = 1 := by\n  contrapose! h\n  rw [‚Üê unitInterval.lt_one_iff_ne_one, ‚Üê coe_lt_one, ‚Üê unitInterval.pos_iff_ne_zero,\n    ‚Üê coe_pos] at h\n  rw [‚Üê Subtype.coe_lt_coe, coe_mul]\n  simpa using mul_lt_mul_of_pos_right h.right h.left\n\n"}
{"name":"unitInterval.instNontrivialElemReal","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Nontrivial ‚ÜëunitInterval","decl":"instance : Nontrivial I := ‚ü®‚ü®1, 0, (one_ne_zero <| congrArg Subtype.val ¬∑)‚ü©‚ü©\n\n"}
{"name":"unitInterval.mul_pos_mem_iff","module":"Mathlib.Topology.UnitInterval","initialProofState":"a t : Real\nha : LT.lt 0 a\n‚ä¢ Iff (Membership.mem unitInterval (HMul.hMul a t)) (Membership.mem (Set.Icc 0 (HDiv.hDiv 1 a)) t)","decl":"theorem mul_pos_mem_iff {a t : ‚Ñù} (ha : 0 < a) : a * t ‚àà I ‚Üî t ‚àà Set.Icc (0 : ‚Ñù) (1 / a) := by\n  constructor <;> rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© <;> constructor\n  ¬∑ exact nonneg_of_mul_nonneg_right h‚ÇÅ ha\n  ¬∑ rwa [le_div_iff‚ÇÄ ha, mul_comm]\n  ¬∑ exact mul_nonneg ha.le h‚ÇÅ\n  ¬∑ rwa [le_div_iff‚ÇÄ ha, mul_comm] at h‚ÇÇ\n\n"}
{"name":"unitInterval.two_mul_sub_one_mem_iff","module":"Mathlib.Topology.UnitInterval","initialProofState":"t : Real\n‚ä¢ Iff (Membership.mem unitInterval (HSub.hSub (HMul.hMul 2 t) 1)) (Membership.mem (Set.Icc (1 / 2) 1) t)","decl":"theorem two_mul_sub_one_mem_iff {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 := by\n  constructor <;> rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© <;> constructor <;> linarith\n\n"}
{"name":"unitInterval.coe_unitIntervalSubmonoid","module":"Mathlib.Topology.UnitInterval","initialProofState":"‚ä¢ Eq (‚ÜëunitInterval.submonoid) unitInterval","decl":"@[simp] theorem coe_unitIntervalSubmonoid : submonoid = unitInterval := rfl\n"}
{"name":"unitInterval.mem_unitIntervalSubmonoid","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : Real\n‚ä¢ Iff (Membership.mem unitInterval.submonoid x) (Membership.mem unitInterval x)","decl":"@[simp] theorem mem_unitIntervalSubmonoid {x} : x ‚àà submonoid ‚Üî x ‚àà unitInterval :=\n  Iff.rfl\n\n"}
{"name":"unitInterval.prod_mem","module":"Mathlib.Topology.UnitInterval","initialProofState":"Œπ : Type u_1\nt : Finset Œπ\nf : Œπ ‚Üí Real\nh : ‚àÄ (c : Œπ), Membership.mem t c ‚Üí Membership.mem unitInterval (f c)\n‚ä¢ Membership.mem unitInterval (t.prod fun c => f c)","decl":"protected theorem prod_mem {Œπ : Type*} {t : Finset Œπ} {f : Œπ ‚Üí ‚Ñù}\n    (h : ‚àÄ c ‚àà t, f c ‚àà unitInterval) :\n    ‚àè c ‚àà t, f c ‚àà unitInterval := _root_.prod_mem (S := unitInterval.submonoid) h\n\n"}
{"name":"Set.abs_projIcc_sub_projIcc","module":"Mathlib.Topology.UnitInterval","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrderedAddCommGroup Œ±\na b c d : Œ±\nh : LE.le a b\n‚ä¢ LE.le (abs (HSub.hSub ‚Üë(Set.projIcc a b h c) ‚Üë(Set.projIcc a b h d))) (abs (HSub.hSub c d))","decl":"/-- `Set.projIcc` is a contraction. -/\nlemma _root_.Set.abs_projIcc_sub_projIcc : (|projIcc a b h c - projIcc a b h d| : Œ±) ‚â§ |c - d| := by\n  wlog hdc : d ‚â§ c generalizing c d\n  ¬∑ rw [abs_sub_comm, abs_sub_comm c]; exact this (le_of_not_le hdc)\n  rw [abs_eq_self.2 (sub_nonneg.2 hdc), abs_eq_self.2 (sub_nonneg.2 <| monotone_projIcc h hdc)]\n  rw [‚Üê sub_nonneg] at hdc\n  refine (max_sub_max_le_max _ _ _ _).trans (max_le (by rwa [sub_self]) ?_)\n  refine ((le_abs_self _).trans <| abs_min_sub_min_le_max _ _ _ _).trans (max_le ?_ ?_)\n  ¬∑ rwa [sub_self, abs_zero]\n  ¬∑ exact (abs_eq_self.mpr hdc).le\n\n"}
{"name":"Set.Icc.addNSMul_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrderedAddCommGroup Œ±\na b : Œ±\nh : LE.le a b\nŒ¥ : Œ±\n‚ä¢ Eq (‚Üë(Set.Icc.addNSMul h Œ¥ 0)) a","decl":"lemma addNSMul_zero : addNSMul h Œ¥ 0 = a := by\n  rw [addNSMul, zero_smul, add_zero, projIcc_left]\n\n"}
{"name":"Set.Icc.addNSMul_eq_right","module":"Mathlib.Topology.UnitInterval","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : LinearOrderedAddCommGroup Œ±\na b : Œ±\nh : LE.le a b\nŒ¥ : Œ±\ninst‚úù : Archimedean Œ±\nhŒ¥ : LT.lt 0 Œ¥\n‚ä¢ Exists fun m => ‚àÄ (n : Nat), GE.ge n m ‚Üí Eq (‚Üë(Set.Icc.addNSMul h Œ¥ n)) b","decl":"lemma addNSMul_eq_right [Archimedean Œ±] (hŒ¥ : 0 < Œ¥) :\n    ‚àÉ m, ‚àÄ n ‚â• m, addNSMul h Œ¥ n = b := by\n  obtain ‚ü®m, hm‚ü© := Archimedean.arch (b - a) hŒ¥\n  refine ‚ü®m, fun n hn ‚Ü¶ ?_‚ü©\n  rw [addNSMul, coe_projIcc, add_comm, min_eq_left_iff.mpr, max_eq_right h]\n  exact sub_le_iff_le_add.mp (hm.trans <| nsmul_le_nsmul_left hŒ¥.le hn)\n\n"}
{"name":"Set.Icc.monotone_addNSMul","module":"Mathlib.Topology.UnitInterval","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrderedAddCommGroup Œ±\na b : Œ±\nh : LE.le a b\nŒ¥ : Œ±\nhŒ¥ : LE.le 0 Œ¥\n‚ä¢ Monotone (Set.Icc.addNSMul h Œ¥)","decl":"lemma monotone_addNSMul (hŒ¥ : 0 ‚â§ Œ¥) : Monotone (addNSMul h Œ¥) :=\n  fun _ _ hnm ‚Ü¶ monotone_projIcc h <| (add_le_add_iff_left _).mpr (nsmul_le_nsmul_left hŒ¥ hnm)\n\n"}
{"name":"Set.Icc.abs_sub_addNSMul_le","module":"Mathlib.Topology.UnitInterval","initialProofState":"Œ± : Type u_1\ninst‚úù : LinearOrderedAddCommGroup Œ±\na b : Œ±\nh : LE.le a b\nŒ¥ : Œ±\nhŒ¥ : LE.le 0 Œ¥\nt : ‚Üë(Set.Icc a b)\nn : Nat\nht : Membership.mem (Set.Icc (Set.Icc.addNSMul h Œ¥ n) (Set.Icc.addNSMul h Œ¥ (HAdd.hAdd n 1))) t\n‚ä¢ LE.le (abs (HSub.hSub ‚Üët ‚Üë(Set.Icc.addNSMul h Œ¥ n))) Œ¥","decl":"lemma abs_sub_addNSMul_le (hŒ¥ : 0 ‚â§ Œ¥) {t : Icc a b} (n : ‚Ñï)\n    (ht : t ‚àà Icc (addNSMul h Œ¥ n) (addNSMul h Œ¥ (n+1))) :\n    (|t - addNSMul h Œ¥ n| : Œ±) ‚â§ Œ¥ :=\n  calc\n    (|t - addNSMul h Œ¥ n| : Œ±) = t - addNSMul h Œ¥ n            := abs_eq_self.2 <| sub_nonneg.2 ht.1\n    _ ‚â§ projIcc a b h (a + (n+1) ‚Ä¢ Œ¥) - addNSMul h Œ¥ n := by apply sub_le_sub_right; exact ht.2\n    _ ‚â§ (|projIcc a b h (a + (n+1) ‚Ä¢ Œ¥) - addNSMul h Œ¥ n| : Œ±) := le_abs_self _\n    _ ‚â§ |a + (n+1) ‚Ä¢ Œ¥ - (a + n ‚Ä¢ Œ¥)|                          := abs_projIcc_sub_projIcc h\n    _ ‚â§ Œ¥ := by\n          rw [add_sub_add_comm, sub_self, zero_add, succ_nsmul', add_sub_cancel_right]\n          exact (abs_eq_self.mpr hŒ¥).le\n\n"}
{"name":"exists_monotone_Icc_subset_open_cover_Icc","module":"Mathlib.Topology.UnitInterval","initialProofState":"Œπ : Sort u_1\na b : Real\nh : LE.le a b\nc : Œπ ‚Üí Set ‚Üë(Set.Icc a b)\nhc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i)\nhc‚ÇÇ : HasSubset.Subset Set.univ (Set.iUnion fun i => c i)\n‚ä¢ Exists fun t => And (Eq (‚Üë(t 0)) a) (And (Monotone t) (And (Exists fun m => ‚àÄ (n : Nat), GE.ge n m ‚Üí Eq (‚Üë(t n)) b) (‚àÄ (n : Nat), Exists fun i => HasSubset.Subset (Set.Icc (t n) (t (HAdd.hAdd n 1))) (c i))))","decl":"/-- Any open cover `c` of a closed interval `[a, b]` in ‚Ñù can be refined to\n  a finite partition into subintervals. -/\nlemma exists_monotone_Icc_subset_open_cover_Icc {Œπ} {a b : ‚Ñù} (h : a ‚â§ b) {c : Œπ ‚Üí Set (Icc a b)}\n    (hc‚ÇÅ : ‚àÄ i, IsOpen (c i)) (hc‚ÇÇ : univ ‚äÜ ‚ãÉ i, c i) : ‚àÉ t : ‚Ñï ‚Üí Icc a b, t 0 = a ‚àß\n      Monotone t ‚àß (‚àÉ m, ‚àÄ n ‚â• m, t n = b) ‚àß ‚àÄ n, ‚àÉ i, Icc (t n) (t (n + 1)) ‚äÜ c i := by\n  obtain ‚ü®Œ¥, Œ¥_pos, ball_subset‚ü© := lebesgue_number_lemma_of_metric isCompact_univ hc‚ÇÅ hc‚ÇÇ\n  have hŒ¥ := half_pos Œ¥_pos\n  refine ‚ü®addNSMul h (Œ¥/2), addNSMul_zero h,\n    monotone_addNSMul h hŒ¥.le, addNSMul_eq_right h hŒ¥, fun n ‚Ü¶ ?_‚ü©\n  obtain ‚ü®i, hsub‚ü© := ball_subset (addNSMul h (Œ¥/2) n) trivial\n  exact ‚ü®i, fun t ht ‚Ü¶ hsub ((abs_sub_addNSMul_le h hŒ¥.le n ht).trans_lt <| half_lt_self Œ¥_pos)‚ü©\n\n"}
{"name":"exists_monotone_Icc_subset_open_cover_unitInterval","module":"Mathlib.Topology.UnitInterval","initialProofState":"Œπ : Sort u_1\nc : Œπ ‚Üí Set ‚ÜëunitInterval\nhc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i)\nhc‚ÇÇ : HasSubset.Subset Set.univ (Set.iUnion fun i => c i)\n‚ä¢ Exists fun t => And (Eq (t 0) 0) (And (Monotone t) (And (Exists fun n => ‚àÄ (m : Nat), GE.ge m n ‚Üí Eq (t m) 1) (‚àÄ (n : Nat), Exists fun i => HasSubset.Subset (Set.Icc (t n) (t (HAdd.hAdd n 1))) (c i))))","decl":"/-- Any open cover of the unit interval can be refined to a finite partition into subintervals. -/\nlemma exists_monotone_Icc_subset_open_cover_unitInterval {Œπ} {c : Œπ ‚Üí Set I}\n    (hc‚ÇÅ : ‚àÄ i, IsOpen (c i)) (hc‚ÇÇ : univ ‚äÜ ‚ãÉ i, c i) : ‚àÉ t : ‚Ñï ‚Üí I, t 0 = 0 ‚àß\n      Monotone t ‚àß (‚àÉ n, ‚àÄ m ‚â• n, t m = 1) ‚àß ‚àÄ n, ‚àÉ i, Icc (t n) (t (n + 1)) ‚äÜ c i := by\n  simp_rw [‚Üê Subtype.coe_inj]\n  exact exists_monotone_Icc_subset_open_cover_Icc zero_le_one hc‚ÇÅ hc‚ÇÇ\n\n"}
{"name":"exists_monotone_Icc_subset_open_cover_unitInterval_prod_self","module":"Mathlib.Topology.UnitInterval","initialProofState":"Œπ : Sort u_1\nc : Œπ ‚Üí Set (Prod ‚ÜëunitInterval ‚ÜëunitInterval)\nhc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i)\nhc‚ÇÇ : HasSubset.Subset Set.univ (Set.iUnion fun i => c i)\n‚ä¢ Exists fun t => And (Eq (t 0) 0) (And (Monotone t) (And (Exists fun n => ‚àÄ (m : Nat), GE.ge m n ‚Üí Eq (t m) 1) (‚àÄ (n m : Nat), Exists fun i => HasSubset.Subset (SProd.sprod (Set.Icc (t n) (t (HAdd.hAdd n 1))) (Set.Icc (t m) (t (HAdd.hAdd m 1)))) (c i))))","decl":"lemma exists_monotone_Icc_subset_open_cover_unitInterval_prod_self {Œπ} {c : Œπ ‚Üí Set (I √ó I)}\n    (hc‚ÇÅ : ‚àÄ i, IsOpen (c i)) (hc‚ÇÇ : univ ‚äÜ ‚ãÉ i, c i) :\n    ‚àÉ t : ‚Ñï ‚Üí I, t 0 = 0 ‚àß Monotone t ‚àß (‚àÉ n, ‚àÄ m ‚â• n, t m = 1) ‚àß\n      ‚àÄ n m, ‚àÉ i, Icc (t n) (t (n + 1)) √óÀ¢ Icc (t m) (t (m + 1)) ‚äÜ c i := by\n  obtain ‚ü®Œ¥, Œ¥_pos, ball_subset‚ü© := lebesgue_number_lemma_of_metric isCompact_univ hc‚ÇÅ hc‚ÇÇ\n  have hŒ¥ := half_pos Œ¥_pos\n  simp_rw [Subtype.ext_iff]\n  have h : (0 : ‚Ñù) ‚â§ 1 := zero_le_one\n  refine ‚ü®addNSMul h (Œ¥/2), addNSMul_zero h,\n    monotone_addNSMul h hŒ¥.le, addNSMul_eq_right h hŒ¥, fun n m ‚Ü¶ ?_‚ü©\n  obtain ‚ü®i, hsub‚ü© := ball_subset (addNSMul h (Œ¥/2) n, addNSMul h (Œ¥/2) m) trivial\n  exact ‚ü®i, fun t ht ‚Ü¶ hsub (Metric.mem_ball.mpr <| (max_le (abs_sub_addNSMul_le h hŒ¥.le n ht.1) <|\n    abs_sub_addNSMul_le h hŒ¥.le m ht.2).trans_lt <| half_lt_self Œ¥_pos)‚ü©\n\n"}
{"name":"projIcc_eq_zero","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : Real\n‚ä¢ Iff (Eq (Set.projIcc 0 1 ‚ãØ x) 0) (LE.le x 0)","decl":"@[simp]\ntheorem projIcc_eq_zero {x : ‚Ñù} : projIcc (0 : ‚Ñù) 1 zero_le_one x = 0 ‚Üî x ‚â§ 0 :=\n  projIcc_eq_left zero_lt_one\n\n"}
{"name":"projIcc_eq_one","module":"Mathlib.Topology.UnitInterval","initialProofState":"x : Real\n‚ä¢ Iff (Eq (Set.projIcc 0 1 ‚ãØ x) 1) (LE.le 1 x)","decl":"@[simp]\ntheorem projIcc_eq_one {x : ‚Ñù} : projIcc (0 : ‚Ñù) 1 zero_le_one x = 1 ‚Üî 1 ‚â§ x :=\n  projIcc_eq_right zero_lt_one\n\n"}
{"name":"affineHomeomorph_image_I","module":"Mathlib.Topology.UnitInterval","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : LinearOrderedField ùïú\ninst‚úù¬π : TopologicalSpace ùïú\ninst‚úù : TopologicalRing ùïú\na b : ùïú\nh : LT.lt 0 a\n‚ä¢ Eq (Set.image (‚áë(affineHomeomorph a b ‚ãØ)) (Set.Icc 0 1)) (Set.Icc b (HAdd.hAdd a b))","decl":"/-- The image of `[0,1]` under the homeomorphism `fun x ‚Ü¶ a * x + b` is `[b, a+b]`.\n-/\ntheorem affineHomeomorph_image_I (a b : ùïú) (h : 0 < a) :\n    affineHomeomorph a b h.ne.symm '' Set.Icc 0 1 = Set.Icc b (a + b) := by simp [h]\n\n"}
{"name":"iccHomeoI_apply_coe","module":"Mathlib.Topology.UnitInterval","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : LinearOrderedField ùïú\ninst‚úù¬π : TopologicalSpace ùïú\ninst‚úù : TopologicalRing ùïú\na b : ùïú\nh : LT.lt a b\nx : ‚Üë(Set.Icc a b)\n‚ä¢ Eq (‚Üë((iccHomeoI a b h) x)) (HDiv.hDiv (HSub.hSub (‚Üëx) a) (HSub.hSub b a))","decl":"@[simp]\ntheorem iccHomeoI_apply_coe (a b : ùïú) (h : a < b) (x : Set.Icc a b) :\n    ((iccHomeoI a b h) x : ùïú) = (x - a) / (b - a) :=\n  rfl\n\n"}
{"name":"iccHomeoI_symm_apply_coe","module":"Mathlib.Topology.UnitInterval","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : LinearOrderedField ùïú\ninst‚úù¬π : TopologicalSpace ùïú\ninst‚úù : TopologicalRing ùïú\na b : ùïú\nh : LT.lt a b\nx : ‚Üë(Set.Icc 0 1)\n‚ä¢ Eq (‚Üë((iccHomeoI a b h).symm x)) (HAdd.hAdd (HMul.hMul (HSub.hSub b a) ‚Üëx) a)","decl":"@[simp]\ntheorem iccHomeoI_symm_apply_coe (a b : ùïú) (h : a < b) (x : Set.Icc (0 : ùïú) (1 : ùïú)) :\n    ((iccHomeoI a b h).symm x : ùïú) = (b - a) * x + a :=\n  rfl\n\n"}
