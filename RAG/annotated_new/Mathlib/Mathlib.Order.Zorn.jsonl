{"name":"exists_maximal_of_chains_bounded","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : ∀ (c : Set α), IsChain r c → Exists fun ub => ∀ (a : α), Membership.mem c a → r a ub\ntrans : ∀ {a b c : α}, r a b → r b c → r a c\n⊢ Exists fun m => ∀ (a : α), r m a → r a m","decl":"/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem exists_maximal_of_chains_bounded (h : ∀ c, IsChain r c → ∃ ub, ∀ a ∈ c, a ≺ ub)\n    (trans : ∀ {a b c}, a ≺ b → b ≺ c → a ≺ c) : ∃ m, ∀ a, m ≺ a → a ≺ m :=\n  have : ∃ ub, ∀ a ∈ maxChain r, a ≺ ub := h _ <| maxChain_spec.left\n  let ⟨ub, (hub : ∀ a ∈ maxChain r, a ≺ ub)⟩ := this\n  ⟨ub, fun a ha =>\n    have : IsChain r (insert a <| maxChain r) :=\n      maxChain_spec.1.insert fun b hb _ => Or.inr <| trans (hub b hb) ha\n    hub a <| by\n      rw [maxChain_spec.right this (subset_insert _ _)]\n      exact mem_insert _ _⟩\n\n"}
{"name":"exists_maximal_of_nonempty_chains_bounded","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : Nonempty α\nh : ∀ (c : Set α), IsChain r c → c.Nonempty → Exists fun ub => ∀ (a : α), Membership.mem c a → r a ub\ntrans : ∀ {a b c : α}, r a b → r b c → r a c\n⊢ Exists fun m => ∀ (a : α), r m a → r a m","decl":"/-- A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\nthere is a maximal element.\n-/\ntheorem exists_maximal_of_nonempty_chains_bounded [Nonempty α]\n    (h : ∀ c, IsChain r c → c.Nonempty → ∃ ub, ∀ a ∈ c, a ≺ ub)\n    (trans : ∀ {a b c}, a ≺ b → b ≺ c → a ≺ c) : ∃ m, ∀ a, m ≺ a → a ≺ m :=\n  exists_maximal_of_chains_bounded\n    (fun c hc =>\n      (eq_empty_or_nonempty c).elim\n        (fun h => ⟨Classical.arbitrary α, fun x hx => (h ▸ hx : x ∈ (∅ : Set α)).elim⟩) (h c hc))\n    trans\n\n"}
{"name":"zorn_le","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nh : ∀ (c : Set α), IsChain (fun x1 x2 => LE.le x1 x2) c → BddAbove c\n⊢ Exists fun m => IsMax m","decl":"theorem zorn_le (h : ∀ c : Set α, IsChain (· ≤ ·) c → BddAbove c) : ∃ m : α, IsMax m :=\n  exists_maximal_of_chains_bounded h le_trans\n\n"}
{"name":"zorn_le_nonempty","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\nh : ∀ (c : Set α), IsChain (fun x1 x2 => LE.le x1 x2) c → c.Nonempty → BddAbove c\n⊢ Exists fun m => IsMax m","decl":"theorem zorn_le_nonempty [Nonempty α]\n    (h : ∀ c : Set α, IsChain (· ≤ ·) c → c.Nonempty → BddAbove c) : ∃ m : α, IsMax m :=\n  exists_maximal_of_nonempty_chains_bounded h le_trans\n\n"}
{"name":"zorn_le₀","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nih : ∀ (c : Set α), HasSubset.Subset c s → IsChain (fun x1 x2 => LE.le x1 x2) c → Exists fun ub => And (Membership.mem s ub) (∀ (z : α), Membership.mem c z → LE.le z ub)\n⊢ Exists fun m => Maximal (fun x => Membership.mem s x) m","decl":"theorem zorn_le₀ (s : Set α) (ih : ∀ c ⊆ s, IsChain (· ≤ ·) c → ∃ ub ∈ s, ∀ z ∈ c, z ≤ ub) :\n    ∃ m, Maximal (· ∈ s) m :=\n  let ⟨⟨m, hms⟩, h⟩ :=\n    @zorn_le s _ fun c hc =>\n      let ⟨ub, hubs, hub⟩ :=\n        ih (Subtype.val '' c) (fun _ ⟨⟨_, hx⟩, _, h⟩ => h ▸ hx)\n          (by\n            rintro _ ⟨p, hpc, rfl⟩ _ ⟨q, hqc, rfl⟩ hpq\n            exact hc hpc hqc fun t => hpq (Subtype.ext_iff.1 t))\n      ⟨⟨ub, hubs⟩, fun ⟨_, _⟩ hc => hub _ ⟨_, hc, rfl⟩⟩\n  ⟨m, hms, fun z hzs hmz => @h ⟨z, hzs⟩ hmz⟩\n\n"}
{"name":"zorn_le_nonempty₀","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nih : ∀ (c : Set α), HasSubset.Subset c s → IsChain (fun x1 x2 => LE.le x1 x2) c → ∀ (y : α), Membership.mem c y → Exists fun ub => And (Membership.mem s ub) (∀ (z : α), Membership.mem c z → LE.le z ub)\nx : α\nhxs : Membership.mem s x\n⊢ Exists fun m => And (LE.le x m) (Maximal (fun x => Membership.mem s x) m)","decl":"theorem zorn_le_nonempty₀ (s : Set α)\n    (ih : ∀ c ⊆ s, IsChain (· ≤ ·) c → ∀ y ∈ c, ∃ ub ∈ s, ∀ z ∈ c, z ≤ ub) (x : α) (hxs : x ∈ s) :\n    ∃ m, x ≤ m ∧ Maximal (· ∈ s) m := by\n  -- Porting note: the first three lines replace the following two lines in mathlib3.\n  -- The mathlib3 `rcases` supports holes for proof obligations, this is not yet implemented in 4.\n  -- rcases zorn_preorder₀ ({ y ∈ s | x ≤ y }) fun c hcs hc => ?_ with ⟨m, ⟨hms, hxm⟩, hm⟩\n  -- · exact ⟨m, hms, hxm, fun z hzs hmz => hm _ ⟨hzs, hxm.trans hmz⟩ hmz⟩\n  have H := zorn_le₀ ({ y ∈ s | x ≤ y }) fun c hcs hc => ?_\n  · rcases H with ⟨m, ⟨hms, hxm⟩, hm⟩\n    exact ⟨m, hxm, hms, fun z hzs hmz => @hm _ ⟨hzs, hxm.trans hmz⟩ hmz⟩\n  · rcases c.eq_empty_or_nonempty with (rfl | ⟨y, hy⟩)\n    · exact ⟨x, ⟨hxs, le_rfl⟩, fun z => False.elim⟩\n    · rcases ih c (fun z hz => (hcs hz).1) hc y hy with ⟨z, hzs, hz⟩\n      exact ⟨z, ⟨hzs, (hcs hy).2.trans <| hz _ hy⟩, hz⟩\n\n"}
{"name":"zorn_le_nonempty_Ici₀","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nih : ∀ (c : Set α), HasSubset.Subset c (Set.Ici a) → IsChain (fun x1 x2 => LE.le x1 x2) c → ∀ (y : α), Membership.mem c y → Exists fun ub => ∀ (z : α), Membership.mem c z → LE.le z ub\nx : α\nhax : LE.le a x\n⊢ Exists fun m => And (LE.le x m) (IsMax m)","decl":"theorem zorn_le_nonempty_Ici₀ (a : α)\n    (ih : ∀ c ⊆ Ici a, IsChain (· ≤ ·) c → ∀ y ∈ c, ∃ ub, ∀ z ∈ c, z ≤ ub) (x : α) (hax : a ≤ x) :\n    ∃ m, x ≤ m ∧ IsMax m := by\n  let ⟨m, hxm, ham, hm⟩ := zorn_le_nonempty₀ (Ici a) (fun c hca hc y hy ↦ ?_) x hax\n  · exact ⟨m, hxm, fun z hmz => hm (ham.trans hmz) hmz⟩\n  · have ⟨ub, hub⟩ := ih c hca hc y hy\n    exact ⟨ub, (hca hy).trans (hub y hy), hub⟩\n\n"}
{"name":"zorn_subset","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\nS : Set (Set α)\nh : ∀ (c : Set (Set α)), HasSubset.Subset c S → IsChain (fun x1 x2 => HasSubset.Subset x1 x2) c → Exists fun ub => And (Membership.mem S ub) (∀ (s : Set α), Membership.mem c s → HasSubset.Subset s ub)\n⊢ Exists fun m => Maximal (fun x => Membership.mem S x) m","decl":"theorem zorn_subset (S : Set (Set α))\n    (h : ∀ c ⊆ S, IsChain (· ⊆ ·) c → ∃ ub ∈ S, ∀ s ∈ c, s ⊆ ub) : ∃ m, Maximal (· ∈ S) m :=\n  zorn_le₀ S h\n\n"}
{"name":"zorn_subset_nonempty","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\nS : Set (Set α)\nH : ∀ (c : Set (Set α)), HasSubset.Subset c S → IsChain (fun x1 x2 => HasSubset.Subset x1 x2) c → c.Nonempty → Exists fun ub => And (Membership.mem S ub) (∀ (s : Set α), Membership.mem c s → HasSubset.Subset s ub)\nx : Set α\nhx : Membership.mem S x\n⊢ Exists fun m => And (HasSubset.Subset x m) (Maximal (fun x => Membership.mem S x) m)","decl":"theorem zorn_subset_nonempty (S : Set (Set α))\n    (H : ∀ c ⊆ S, IsChain (· ⊆ ·) c → c.Nonempty → ∃ ub ∈ S, ∀ s ∈ c, s ⊆ ub) (x) (hx : x ∈ S) :\n    ∃ m, x ⊆ m ∧ Maximal (· ∈ S) m :=\n  zorn_le_nonempty₀ _ (fun _ cS hc y yc => H _ cS hc ⟨y, yc⟩) _ hx\n\n"}
{"name":"zorn_superset","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\nS : Set (Set α)\nh : ∀ (c : Set (Set α)), HasSubset.Subset c S → IsChain (fun x1 x2 => HasSubset.Subset x1 x2) c → Exists fun lb => And (Membership.mem S lb) (∀ (s : Set α), Membership.mem c s → HasSubset.Subset lb s)\n⊢ Exists fun m => Minimal (fun x => Membership.mem S x) m","decl":"theorem zorn_superset (S : Set (Set α))\n    (h : ∀ c ⊆ S, IsChain (· ⊆ ·) c → ∃ lb ∈ S, ∀ s ∈ c, lb ⊆ s) : ∃ m, Minimal (· ∈ S) m :=\n  (@zorn_le₀ (Set α)ᵒᵈ _ S) fun c cS hc => h c cS hc.symm\n\n"}
{"name":"zorn_superset_nonempty","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\nS : Set (Set α)\nH : ∀ (c : Set (Set α)), HasSubset.Subset c S → IsChain (fun x1 x2 => HasSubset.Subset x1 x2) c → c.Nonempty → Exists fun lb => And (Membership.mem S lb) (∀ (s : Set α), Membership.mem c s → HasSubset.Subset lb s)\nx : Set α\nhx : Membership.mem S x\n⊢ Exists fun m => And (HasSubset.Subset m x) (Minimal (fun x => Membership.mem S x) m)","decl":"theorem zorn_superset_nonempty (S : Set (Set α))\n    (H : ∀ c ⊆ S, IsChain (· ⊆ ·) c → c.Nonempty → ∃ lb ∈ S, ∀ s ∈ c, lb ⊆ s) (x) (hx : x ∈ S) :\n    ∃ m, m ⊆ x ∧ Minimal (· ∈ S) m :=\n  @zorn_le_nonempty₀ (Set α)ᵒᵈ _ S (fun _ cS hc y yc => H _ cS hc.symm ⟨y, yc⟩) _ hx\n\n"}
{"name":"IsChain.exists_maxChain","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\nr : α → α → Prop\nc : Set α\nhc : IsChain r c\n⊢ Exists fun M => And (IsMaxChain r M) (HasSubset.Subset c M)","decl":"/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\n-/\ntheorem IsChain.exists_maxChain (hc : IsChain r c) : ∃ M, @IsMaxChain _ r M ∧ c ⊆ M := by\n  -- Porting note: the first three lines replace the following two lines in mathlib3.\n  -- The mathlib3 `obtain` supports holes for proof obligations, this is not yet implemented in 4.\n  -- obtain ⟨M, ⟨_, hM₀⟩, hM₁, hM₂⟩ :=\n  --   zorn_subset_nonempty { s | c ⊆ s ∧ IsChain r s } _ c ⟨Subset.rfl, hc⟩\n  have H := zorn_subset_nonempty { s | c ⊆ s ∧ IsChain r s } ?_ c ⟨Subset.rfl, hc⟩\n  · obtain ⟨M, hcM, hM⟩ := H\n    exact ⟨M, ⟨hM.prop.2, fun d hd hMd ↦ hM.eq_of_subset ⟨hcM.trans hMd, hd⟩ hMd⟩, hcM⟩\n  rintro cs hcs₀ hcs₁ ⟨s, hs⟩\n  refine\n    ⟨⋃₀cs, ⟨fun _ ha => Set.mem_sUnion_of_mem ((hcs₀ hs).left ha) hs, ?_⟩, fun _ =>\n      Set.subset_sUnion_of_mem⟩\n  rintro y ⟨sy, hsy, hysy⟩ z ⟨sz, hsz, hzsz⟩ hyz\n  obtain rfl | hsseq := eq_or_ne sy sz\n  · exact (hcs₀ hsy).right hysy hzsz hyz\n  cases' hcs₁ hsy hsz hsseq with h h\n  · exact (hcs₀ hsz).right (h hysy) hzsz hyz\n  · exact (hcs₀ hsy).right hysy (h hzsz) hyz\n\n"}
{"name":"IsChain.exists_subset_flag","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nc : Set α\nhc : IsChain (fun x1 x2 => LE.le x1 x2) c\n⊢ Exists fun s => HasSubset.Subset c ↑s","decl":"lemma _root_.IsChain.exists_subset_flag (hc : IsChain (· ≤ ·) c) : ∃ s : Flag α, c ⊆ s :=\n  let ⟨s, hs, hcs⟩ := hc.exists_maxChain; ⟨ofIsMaxChain s hs, hcs⟩\n\n"}
{"name":"Flag.exists_mem","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Exists fun s => Membership.mem s a","decl":"lemma exists_mem (a : α) : ∃ s : Flag α, a ∈ s :=\n  let ⟨s, hs⟩ := Set.subsingleton_singleton (a := a).isChain.exists_subset_flag\n  ⟨s, hs rfl⟩\n\n"}
{"name":"Flag.exists_mem_mem","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\n⊢ Exists fun s => And (Membership.mem s a) (Membership.mem s b)","decl":"lemma exists_mem_mem (hab : a ≤ b) : ∃ s : Flag α, a ∈ s ∧ b ∈ s := by\n  simpa [Set.insert_subset_iff] using (IsChain.pair hab).exists_subset_flag\n\n"}
{"name":"Flag.instNonempty","module":"Mathlib.Order.Zorn","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Nonempty (Flag α)","decl":"instance : Nonempty (Flag α) := ⟨.ofIsMaxChain _ maxChain_spec⟩\n\n"}
