{"name":"QuadraticMap.prod_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\na : Prod M₁ M₂\n⊢ Eq ((Q₁.prod Q₂) a) (HAdd.hAdd (Q₁ a.1) (Q₂ a.2))","decl":"/-- Construct a quadratic form on a product of two modules from the quadratic form on each module.\n-/\n@[simps!]\ndef prod (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P) : QuadraticMap R (M₁ × M₂) P :=\n  Q₁.comp (LinearMap.fst _ _ _) + Q₂.comp (LinearMap.snd _ _ _)\n\n"}
{"name":"QuadraticMap.IsometryEquiv.prod_toLinearEquiv","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\nP : Type u_7\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid N₁\ninst✝⁶ : AddCommMonoid N₂\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Module R N₁\ninst✝¹ : Module R N₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nQ₁' : QuadraticMap R N₁ P\nQ₂' : QuadraticMap R N₂ P\ne₁ : Q₁.IsometryEquiv Q₁'\ne₂ : Q₂.IsometryEquiv Q₂'\n⊢ Eq (e₁.prod e₂).toLinearEquiv (e₁.prod e₂.toLinearEquiv)","decl":"/-- An isometry between quadratic forms generated by `QuadraticForm.prod` can be constructed\nfrom a pair of isometries between the left and right parts. -/\n@[simps toLinearEquiv]\ndef IsometryEquiv.prod\n    {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P}\n    {Q₁' : QuadraticMap R N₁ P} {Q₂' : QuadraticMap R N₂ P}\n    (e₁ : Q₁.IsometryEquiv Q₁') (e₂ : Q₂.IsometryEquiv Q₂') :\n    (Q₁.prod Q₂).IsometryEquiv (Q₁'.prod Q₂') where\n  map_app' x := congr_arg₂ (· + ·) (e₁.map_app x.1) (e₂.map_app x.2)\n  toLinearEquiv := LinearEquiv.prod e₁.toLinearEquiv e₂.toLinearEquiv\n\n"}
{"name":"QuadraticMap.Isometry.inl_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\ni : M₁\n⊢ Eq ((QuadraticMap.Isometry.inl Q₁ Q₂) i) { fst := i, snd := 0 }","decl":"/-- `LinearMap.inl` as an isometry. -/\n@[simps!]\ndef Isometry.inl (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P) : Q₁ →qᵢ (Q₁.prod Q₂) where\n  toLinearMap := LinearMap.inl R _ _\n  map_app' m₁ := by simp\n\n"}
{"name":"QuadraticMap.Isometry.inr_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\ni : M₂\n⊢ Eq ((QuadraticMap.Isometry.inr Q₁ Q₂) i) { fst := 0, snd := i }","decl":"/-- `LinearMap.inr` as an isometry. -/\n@[simps!]\ndef Isometry.inr (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P) : Q₂ →qᵢ (Q₁.prod Q₂) where\n  toLinearMap := LinearMap.inr R _ _\n  map_app' m₁ := by simp\n\n"}
{"name":"QuadraticMap.Isometry.fst_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nself : Prod M₁ M₂\n⊢ Eq ((QuadraticMap.Isometry.fst M₂ Q₁) self) self.1","decl":"variable (M₂) in\n/-- `LinearMap.fst` as an isometry, when the second space has the zero quadratic form. -/\n@[simps!]\ndef Isometry.fst (Q₁ : QuadraticMap R M₁ P) : (Q₁.prod (0 : QuadraticMap R M₂ P)) →qᵢ Q₁ where\n  toLinearMap := LinearMap.fst R _ _\n  map_app' m₁ := by simp\n\n"}
{"name":"QuadraticMap.Isometry.snd_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₂ : QuadraticMap R M₂ P\nself : Prod M₁ M₂\n⊢ Eq ((QuadraticMap.Isometry.snd M₁ Q₂) self) self.2","decl":"variable (M₁) in\n/-- `LinearMap.snd` as an isometry, when the first space has the zero quadratic form. -/\n@[simps!]\ndef Isometry.snd (Q₂ : QuadraticMap R M₂ P) : ((0 : QuadraticMap R M₁ P).prod Q₂) →qᵢ Q₂ where\n  toLinearMap := LinearMap.snd R _ _\n  map_app' m₁ := by simp\n\n"}
{"name":"QuadraticMap.Isometry.fst_comp_inl","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\n⊢ Eq ((QuadraticMap.Isometry.fst M₂ Q₁).comp (QuadraticMap.Isometry.inl Q₁ 0)) (QuadraticMap.Isometry.id Q₁)","decl":"@[simp]\nlemma Isometry.fst_comp_inl (Q₁ : QuadraticMap R M₁ P) :\n    (fst M₂ Q₁).comp (inl Q₁ (0 : QuadraticMap R M₂ P)) = .id _ :=\n  ext fun _ => rfl\n\n"}
{"name":"QuadraticMap.Isometry.snd_comp_inr","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₂ : QuadraticMap R M₂ P\n⊢ Eq ((QuadraticMap.Isometry.snd M₁ Q₂).comp (QuadraticMap.Isometry.inr 0 Q₂)) (QuadraticMap.Isometry.id Q₂)","decl":"@[simp]\nlemma Isometry.snd_comp_inr (Q₂ : QuadraticMap R M₂ P) :\n    (snd M₁ Q₂).comp (inr (0 : QuadraticMap R M₁ P) Q₂) = .id _ :=\n  ext fun _ => rfl\n\n"}
{"name":"QuadraticMap.Isometry.snd_comp_inl","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₂ : QuadraticMap R M₂ P\n⊢ Eq ((QuadraticMap.Isometry.snd M₁ Q₂).comp (QuadraticMap.Isometry.inl 0 Q₂)) 0","decl":"@[simp]\nlemma Isometry.snd_comp_inl (Q₂ : QuadraticMap R M₂ P) :\n    (snd M₁ Q₂).comp (inl (0 : QuadraticMap R M₁ P) Q₂) = 0 :=\n  ext fun _ => rfl\n\n"}
{"name":"QuadraticMap.Isometry.fst_comp_inr","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\n⊢ Eq ((QuadraticMap.Isometry.fst M₂ Q₁).comp (QuadraticMap.Isometry.inr Q₁ 0)) 0","decl":"@[simp]\nlemma Isometry.fst_comp_inr (Q₁ : QuadraticMap R M₁ P) :\n    (fst M₂ Q₁).comp (inr Q₁ (0 : QuadraticMap R M₂ P)) = 0 :=\n  ext fun _ => rfl\n\n"}
{"name":"QuadraticMap.Equivalent.prod","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\nP : Type u_7\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid N₁\ninst✝⁶ : AddCommMonoid N₂\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Module R N₁\ninst✝¹ : Module R N₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nQ₁' : QuadraticMap R N₁ P\nQ₂' : QuadraticMap R N₂ P\ne₁ : Q₁.Equivalent Q₁'\ne₂ : Q₂.Equivalent Q₂'\n⊢ (Q₁.prod Q₂).Equivalent (Q₁'.prod Q₂')","decl":"theorem Equivalent.prod {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P}\n    {Q₁' : QuadraticMap R N₁ P} {Q₂' : QuadraticMap R N₂ P} (e₁ : Q₁.Equivalent Q₁')\n    (e₂ : Q₂.Equivalent Q₂') : (Q₁.prod Q₂).Equivalent (Q₁'.prod Q₂') :=\n  Nonempty.map2 IsometryEquiv.prod e₁ e₂\n\n"}
{"name":"QuadraticMap.IsometryEquiv.prodComm_invFun","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\na✝ : Prod M₂ M₁\n⊢ Eq ((QuadraticMap.IsometryEquiv.prodComm Q₁ Q₂).invFun a✝) a✝.swap","decl":"/-- `LinearEquiv.prodComm` is isometric. -/\n@[simps!]\ndef IsometryEquiv.prodComm (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P) :\n    (Q₁.prod Q₂).IsometryEquiv (Q₂.prod Q₁) where\n  toLinearEquiv := LinearEquiv.prodComm _ _ _\n  map_app' _ := add_comm _ _\n\n"}
{"name":"QuadraticMap.IsometryEquiv.prodComm_toFun","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\na✝ : Prod M₁ M₂\n⊢ Eq ((QuadraticMap.IsometryEquiv.prodComm Q₁ Q₂) a✝) a✝.swap","decl":"/-- `LinearEquiv.prodComm` is isometric. -/\n@[simps!]\ndef IsometryEquiv.prodComm (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P) :\n    (Q₁.prod Q₂).IsometryEquiv (Q₂.prod Q₁) where\n  toLinearEquiv := LinearEquiv.prodComm _ _ _\n  map_app' _ := add_comm _ _\n\n"}
{"name":"QuadraticMap.IsometryEquiv.prodProdProdComm_invFun","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\nP : Type u_7\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid N₁\ninst✝⁶ : AddCommMonoid N₂\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Module R N₁\ninst✝¹ : Module R N₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nQ₃ : QuadraticMap R N₁ P\nQ₄ : QuadraticMap R N₂ P\nmmnn : Prod (Prod M₁ N₁) (Prod M₂ N₂)\n⊢ Eq ((QuadraticMap.IsometryEquiv.prodProdProdComm Q₁ Q₂ Q₃ Q₄).invFun mmnn) { fst := { fst := mmnn.1.1, snd := mmnn.2.1 }, snd := { fst := mmnn.1.2, snd := mmnn.2.2 } }","decl":"/-- `LinearEquiv.prodProdProdComm` is isometric. -/\n@[simps!]\ndef IsometryEquiv.prodProdProdComm\n    (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P)\n    (Q₃ : QuadraticMap R N₁ P) (Q₄ : QuadraticMap R N₂ P) :\n    ((Q₁.prod Q₂).prod (Q₃.prod Q₄)).IsometryEquiv ((Q₁.prod Q₃).prod (Q₂.prod Q₄)) where\n  toLinearEquiv := LinearEquiv.prodProdProdComm _ _ _ _ _\n  map_app' _ := add_add_add_comm _ _ _ _\n\n"}
{"name":"QuadraticMap.IsometryEquiv.prodProdProdComm_toFun","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\nP : Type u_7\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid N₁\ninst✝⁶ : AddCommMonoid N₂\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Module R N₁\ninst✝¹ : Module R N₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nQ₃ : QuadraticMap R N₁ P\nQ₄ : QuadraticMap R N₂ P\nmnmn : Prod (Prod M₁ M₂) (Prod N₁ N₂)\n⊢ Eq ((QuadraticMap.IsometryEquiv.prodProdProdComm Q₁ Q₂ Q₃ Q₄) mnmn) { fst := { fst := mnmn.1.1, snd := mnmn.2.1 }, snd := { fst := mnmn.1.2, snd := mnmn.2.2 } }","decl":"/-- `LinearEquiv.prodProdProdComm` is isometric. -/\n@[simps!]\ndef IsometryEquiv.prodProdProdComm\n    (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P)\n    (Q₃ : QuadraticMap R N₁ P) (Q₄ : QuadraticMap R N₂ P) :\n    ((Q₁.prod Q₂).prod (Q₃.prod Q₄)).IsometryEquiv ((Q₁.prod Q₃).prod (Q₂.prod Q₄)) where\n  toLinearEquiv := LinearEquiv.prodProdProdComm _ _ _ _ _\n  map_app' _ := add_add_add_comm _ _ _ _\n\n"}
{"name":"QuadraticMap.anisotropic_of_prod","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nh : (Q₁.prod Q₂).Anisotropic\n⊢ And Q₁.Anisotropic Q₂.Anisotropic","decl":"/-- If a product is anisotropic then its components must be. The converse is not true. -/\ntheorem anisotropic_of_prod\n    {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P} (h : (Q₁.prod Q₂).Anisotropic) :\n    Q₁.Anisotropic ∧ Q₂.Anisotropic := by\n  simp_rw [Anisotropic, prod_apply, Prod.forall, Prod.mk_eq_zero] at h\n  constructor\n  · intro x hx\n    refine (h x 0 ?_).1\n    rw [hx, zero_add, map_zero]\n  · intro x hx\n    refine (h 0 x ?_).2\n    rw [hx, add_zero, map_zero]\n\n"}
{"name":"QuadraticMap.nonneg_prod_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Module R P\ninst✝¹ : Preorder P\ninst✝ : AddLeftMono P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\n⊢ Iff (∀ (x : Prod M₁ M₂), LE.le 0 ((Q₁.prod Q₂) x)) (And (∀ (x : M₁), LE.le 0 (Q₁ x)) (∀ (x : M₂), LE.le 0 (Q₂ x)))","decl":"theorem nonneg_prod_iff [Preorder P] [AddLeftMono P]\n    {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P} :\n    (∀ x, 0 ≤ (Q₁.prod Q₂) x) ↔ (∀ x, 0 ≤ Q₁ x) ∧ ∀ x, 0 ≤ Q₂ x := by\n  simp_rw [Prod.forall, prod_apply]\n  constructor\n  · intro h\n    constructor\n    · intro x; simpa only [add_zero, map_zero] using h x 0\n    · intro x; simpa only [zero_add, map_zero] using h 0 x\n  · rintro ⟨h₁, h₂⟩ x₁ x₂\n    exact add_nonneg (h₁ x₁) (h₂ x₂)\n\n"}
{"name":"QuadraticMap.posDef_prod_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Module R P\ninst✝¹ : PartialOrder P\ninst✝ : AddLeftMono P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\n⊢ Iff (Q₁.prod Q₂).PosDef (And Q₁.PosDef Q₂.PosDef)","decl":"theorem posDef_prod_iff [PartialOrder P] [AddLeftMono P]\n    {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P} :\n    (Q₁.prod Q₂).PosDef ↔ Q₁.PosDef ∧ Q₂.PosDef := by\n  simp_rw [posDef_iff_nonneg, nonneg_prod_iff]\n  constructor\n  · rintro ⟨⟨hle₁, hle₂⟩, ha⟩\n    obtain ⟨ha₁, ha₂⟩ := anisotropic_of_prod ha\n    exact ⟨⟨hle₁, ha₁⟩, ⟨hle₂, ha₂⟩⟩\n  · rintro ⟨⟨hle₁, ha₁⟩, ⟨hle₂, ha₂⟩⟩\n    refine ⟨⟨hle₁, hle₂⟩, ?_⟩\n    rintro ⟨x₁, x₂⟩ (hx : Q₁ x₁ + Q₂ x₂ = 0)\n    rw [add_eq_zero_iff_of_nonneg (hle₁ x₁) (hle₂ x₂), ha₁.eq_zero_iff, ha₂.eq_zero_iff] at hx\n    rwa [Prod.mk_eq_zero]\n\n"}
{"name":"QuadraticMap.PosDef.prod","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Module R P\ninst✝¹ : PartialOrder P\ninst✝ : AddLeftMono P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nh₁ : Q₁.PosDef\nh₂ : Q₂.PosDef\n⊢ (Q₁.prod Q₂).PosDef","decl":"theorem PosDef.prod [PartialOrder P] [AddLeftMono P]\n    {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P} (h₁ : Q₁.PosDef) (h₂ : Q₂.PosDef) :\n    (Q₁.prod Q₂).PosDef :=\n  posDef_prod_iff.mpr ⟨h₁, h₂⟩\n\n"}
{"name":"QuadraticMap.IsOrtho.prod","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nv w : Prod M₁ M₂\nh₁ : Q₁.IsOrtho v.1 w.1\nh₂ : Q₂.IsOrtho v.2 w.2\n⊢ (Q₁.prod Q₂).IsOrtho v w","decl":"theorem IsOrtho.prod {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P}\n    {v w : M₁ × M₂} (h₁ : Q₁.IsOrtho v.1 w.1) (h₂ : Q₂.IsOrtho v.2 w.2) :\n    (Q₁.prod Q₂).IsOrtho v w :=\n  (congr_arg₂ HAdd.hAdd h₁ h₂).trans <| add_add_add_comm _ _ _ _\n\n"}
{"name":"QuadraticMap.IsOrtho.inl_inr","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nm₁ : M₁\nm₂ : M₂\n⊢ (Q₁.prod Q₂).IsOrtho { fst := m₁, snd := 0 } { fst := 0, snd := m₂ }","decl":"@[simp] theorem IsOrtho.inl_inr {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P}\n    (m₁ : M₁) (m₂ : M₂) :\n    (Q₁.prod Q₂).IsOrtho (m₁, 0) (0, m₂) :=\n      QuadraticMap.IsOrtho.prod (.zero_right _) (.zero_left _)\n\n"}
{"name":"QuadraticMap.IsOrtho.inr_inl","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nm₁ : M₁\nm₂ : M₂\n⊢ (Q₁.prod Q₂).IsOrtho { fst := 0, snd := m₂ } { fst := m₁, snd := 0 }","decl":"@[simp] theorem IsOrtho.inr_inl {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P}\n    (m₁ : M₁) (m₂ : M₂) :\n    (Q₁.prod Q₂).IsOrtho (0, m₂) (m₁, 0) := (IsOrtho.inl_inr _ _).symm\n\n"}
{"name":"QuadraticMap.isOrtho_inl_inl_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nm₁ m₁' : M₁\n⊢ Iff ((Q₁.prod Q₂).IsOrtho { fst := m₁, snd := 0 } { fst := m₁', snd := 0 }) (Q₁.IsOrtho m₁ m₁')","decl":"@[simp] theorem isOrtho_inl_inl_iff {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P}\n    (m₁ m₁' : M₁) :\n    (Q₁.prod Q₂).IsOrtho (m₁, 0) (m₁', 0) ↔ Q₁.IsOrtho m₁ m₁' := by\n  simp [isOrtho_def]\n\n"}
{"name":"QuadraticMap.isOrtho_inr_inr_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nm₂ m₂' : M₂\n⊢ Iff ((Q₁.prod Q₂).IsOrtho { fst := 0, snd := m₂ } { fst := 0, snd := m₂' }) (Q₂.IsOrtho m₂ m₂')","decl":"@[simp] theorem isOrtho_inr_inr_iff {Q₁ : QuadraticMap R M₁ P} {Q₂ : QuadraticMap R M₂ P}\n    (m₂ m₂' : M₂) :\n    (Q₁.prod Q₂).IsOrtho (0, m₂) (0, m₂') ↔ Q₂.IsOrtho m₂ m₂' := by\n  simp [isOrtho_def]\n\n"}
{"name":"QuadraticMap.polar_prod","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : AddCommGroup P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\nx y : Prod M₁ M₂\n⊢ Eq (QuadraticMap.polar (⇑(Q₁.prod Q₂)) x y) (HAdd.hAdd (QuadraticMap.polar (⇑Q₁) x.1 y.1) (QuadraticMap.polar (⇑Q₂) x.2 y.2))","decl":"@[simp] theorem polar_prod (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P) (x y : M₁ × M₂) :\n    polar (Q₁.prod Q₂) x y = polar Q₁ x.1 y.1 + polar Q₂ x.2 y.2 := by\n  dsimp [polar]\n  abel\n\n"}
{"name":"QuadraticMap.polarBilin_prod","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : AddCommGroup P\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R P\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\n⊢ Eq (Q₁.prod Q₂).polarBilin (HAdd.hAdd (LinearMap.compl₁₂ Q₁.polarBilin (LinearMap.fst R M₁ M₂) (LinearMap.fst R M₁ M₂)) (LinearMap.compl₁₂ Q₂.polarBilin (LinearMap.snd R M₁ M₂) (LinearMap.snd R M₁ M₂)))","decl":"@[simp] theorem polarBilin_prod (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P) :\n    (Q₁.prod Q₂).polarBilin =\n      Q₁.polarBilin.compl₁₂ (.fst R M₁ M₂) (.fst R M₁ M₂) +\n      Q₂.polarBilin.compl₁₂ (.snd R M₁ M₂) (.snd R M₁ M₂) :=\n  LinearMap.ext₂ <| polar_prod _ _\n\n"}
{"name":"QuadraticMap.associated_prod","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"R : Type u_2\nM₁ : Type u_3\nM₂ : Type u_4\nP : Type u_7\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M₁\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : AddCommGroup P\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\ninst✝¹ : Module R P\ninst✝ : Invertible 2\nQ₁ : QuadraticMap R M₁ P\nQ₂ : QuadraticMap R M₂ P\n⊢ Eq (QuadraticMap.associated (Q₁.prod Q₂)) (HAdd.hAdd (LinearMap.compl₁₂ (QuadraticMap.associated Q₁) (LinearMap.fst R M₁ M₂) (LinearMap.fst R M₁ M₂)) (LinearMap.compl₁₂ (QuadraticMap.associated Q₂) (LinearMap.snd R M₁ M₂) (LinearMap.snd R M₁ M₂)))","decl":"@[simp] theorem associated_prod [Invertible (2 : R)]\n    (Q₁ : QuadraticMap R M₁ P) (Q₂ : QuadraticMap R M₂ P) :\n    associated (Q₁.prod Q₂) =\n      (associated Q₁).compl₁₂ (.fst R M₁ M₂) (.fst R M₁ M₂) +\n      (associated Q₂).compl₁₂ (.snd R M₁ M₂) (.snd R M₁ M₂) := by\n  dsimp [associated, associatedHom]\n  rw [polarBilin_prod, smul_add]\n  rfl\n\n"}
{"name":"QuadraticMap.pi_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁵ : CommSemiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝³ : AddCommMonoid P\ninst✝² : (i : ι) → Module R (Mᵢ i)\ninst✝¹ : Module R P\ninst✝ : Fintype ι\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\nx : (i : ι) → Mᵢ i\n⊢ Eq ((QuadraticMap.pi Q) x) (Finset.univ.sum fun i => (Q i) (x i))","decl":"@[simp]\ntheorem pi_apply [Fintype ι] (Q : ∀ i, QuadraticMap R (Mᵢ i) P) (x : ∀ i, Mᵢ i) :\n    pi Q x = ∑ i, Q i (x i) :=\n  sum_apply _ _ _\n\n"}
{"name":"QuadraticMap.pi_apply_single","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝⁴ : AddCommMonoid P\ninst✝³ : (i : ι) → Module R (Mᵢ i)\ninst✝² : Module R P\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\ni : ι\nm : Mᵢ i\n⊢ Eq ((QuadraticMap.pi Q) (Pi.single i m)) ((Q i) m)","decl":"theorem pi_apply_single [Fintype ι] [DecidableEq ι]\n    (Q : ∀ i, QuadraticMap R (Mᵢ i) P) (i : ι) (m : Mᵢ i) :\n    pi Q (Pi.single i m) = Q i m := by\n  rw [pi_apply, Fintype.sum_eq_single i fun j hj => ?_, Pi.single_eq_same]\n  rw [Pi.single_eq_of_ne hj, map_zero]\n\n"}
{"name":"QuadraticMap.IsometryEquiv.pi_toLinearEquiv","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\nNᵢ : ι → Type u_9\ninst✝⁷ : CommSemiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝⁵ : (i : ι) → AddCommMonoid (Nᵢ i)\ninst✝⁴ : AddCommMonoid P\ninst✝³ : (i : ι) → Module R (Mᵢ i)\ninst✝² : (i : ι) → Module R (Nᵢ i)\ninst✝¹ : Module R P\ninst✝ : Fintype ι\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\nQ' : (i : ι) → QuadraticMap R (Nᵢ i) P\ne : (i : ι) → (Q i).IsometryEquiv (Q' i)\n⊢ Eq (QuadraticMap.IsometryEquiv.pi e).toLinearEquiv (LinearEquiv.piCongrRight fun i => (e i).toLinearEquiv)","decl":"/-- An isometry between quadratic forms generated by `QuadraticMap.pi` can be constructed\nfrom a pair of isometries between the left and right parts. -/\n@[simps toLinearEquiv]\ndef IsometryEquiv.pi [Fintype ι]\n    {Q : ∀ i, QuadraticMap R (Mᵢ i) P} {Q' : ∀ i, QuadraticMap R (Nᵢ i) P}\n    (e : ∀ i, (Q i).IsometryEquiv (Q' i)) : (pi Q).IsometryEquiv (pi Q') where\n  map_app' x := by\n    simp only [pi_apply, LinearEquiv.piCongrRight, LinearEquiv.toFun_eq_coe,\n      IsometryEquiv.coe_toLinearEquiv, IsometryEquiv.map_app]\n  toLinearEquiv := LinearEquiv.piCongrRight fun i => (e i : Mᵢ i ≃ₗ[R] Nᵢ i)\n\n"}
{"name":"QuadraticMap.Isometry.single_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝⁴ : AddCommMonoid P\ninst✝³ : (i : ι) → Module R (Mᵢ i)\ninst✝² : Module R P\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\ni : ι\nx : Mᵢ i\nj : ι\n⊢ Eq ((QuadraticMap.Isometry.single Q i) x j) (Pi.single i x j)","decl":"/-- `LinearMap.single` as an isometry. -/\n@[simps!]\ndef Isometry.single [Fintype ι] [DecidableEq ι] (Q : ∀ i, QuadraticMap R (Mᵢ i) P) (i : ι) :\n    Q i →qᵢ pi Q where\n  toLinearMap := LinearMap.single _ _ i\n  map_app' := pi_apply_single _ _\n\n"}
{"name":"QuadraticMap.Isometry.proj_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝⁴ : AddCommMonoid P\ninst✝³ : (i : ι) → Module R (Mᵢ i)\ninst✝² : Module R P\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ni : ι\nQ : QuadraticMap R (Mᵢ i) P\nf : (x : ι) → Mᵢ x\n⊢ Eq ((QuadraticMap.Isometry.proj i Q) f) (f i)","decl":"/-- `LinearMap.proj` as an isometry, when all but one quadratic form is zero. -/\n@[simps!]\ndef Isometry.proj [Fintype ι] [DecidableEq ι] (i : ι) (Q : QuadraticMap R (Mᵢ i) P) :\n    pi (Pi.single i Q) →qᵢ Q where\n  toLinearMap := LinearMap.proj i\n  map_app' m := by\n    dsimp\n    rw [pi_apply, Fintype.sum_eq_single i (fun j hij => ?_), Pi.single_eq_same]\n    rw [Pi.single_eq_of_ne hij, zero_apply]\n\n"}
{"name":"QuadraticMap.Isometry.proj_comp_single_of_same","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝⁴ : AddCommMonoid P\ninst✝³ : (i : ι) → Module R (Mᵢ i)\ninst✝² : Module R P\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ni : ι\nQ : QuadraticMap R (Mᵢ i) P\n⊢ Eq ((QuadraticMap.Isometry.proj i Q).comp (QuadraticMap.Isometry.single (Pi.single i Q) i)) (QuadraticMap.Isometry.ofEq ⋯)","decl":"/-- Note that `QuadraticMap.Isometry.id` would not be well-typed as the RHS. -/\n@[simp]\ntheorem Isometry.proj_comp_single_of_same [Fintype ι] [DecidableEq ι]\n    (i : ι) (Q : QuadraticMap R (Mᵢ i) P) :\n    (proj i Q).comp (single _ i) = .ofEq (Pi.single_eq_same _ _) :=\n  ext fun _ => Pi.single_eq_same _ _\n\n"}
{"name":"QuadraticMap.Isometry.proj_comp_single_of_ne","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝⁴ : AddCommMonoid P\ninst✝³ : (i : ι) → Module R (Mᵢ i)\ninst✝² : Module R P\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne i j\nQ : QuadraticMap R (Mᵢ i) P\n⊢ Eq ((QuadraticMap.Isometry.proj i Q).comp (QuadraticMap.Isometry.single (Pi.single i Q) j)) (QuadraticMap.Isometry.comp 0 (QuadraticMap.Isometry.ofEq ⋯))","decl":"/-- Note that `0 : 0 →qᵢ Q` alone would not be well-typed as the RHS. -/\n@[simp]\ntheorem Isometry.proj_comp_single_of_ne [Fintype ι] [DecidableEq ι]\n    {i j : ι} (h : i ≠ j) (Q : QuadraticMap R (Mᵢ i) P) :\n    (proj i Q).comp (single _ j) = (0 : 0 →qᵢ Q).comp (ofEq (Pi.single_eq_of_ne h.symm _)) :=\n  ext fun _ => Pi.single_eq_of_ne h _\n\n"}
{"name":"QuadraticMap.Equivalent.pi","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\nNᵢ : ι → Type u_9\ninst✝⁷ : CommSemiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝⁵ : (i : ι) → AddCommMonoid (Nᵢ i)\ninst✝⁴ : AddCommMonoid P\ninst✝³ : (i : ι) → Module R (Mᵢ i)\ninst✝² : (i : ι) → Module R (Nᵢ i)\ninst✝¹ : Module R P\ninst✝ : Fintype ι\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\nQ' : (i : ι) → QuadraticMap R (Nᵢ i) P\ne : ∀ (i : ι), (Q i).Equivalent (Q' i)\n⊢ (QuadraticMap.pi Q).Equivalent (QuadraticMap.pi Q')","decl":"theorem Equivalent.pi [Fintype ι] {Q : ∀ i, QuadraticMap R (Mᵢ i) P}\n    {Q' : ∀ i, QuadraticMap R (Nᵢ i) P} (e : ∀ i, (Q i).Equivalent (Q' i)) :\n    (pi Q).Equivalent (pi Q') :=\n  ⟨IsometryEquiv.pi fun i => Classical.choice (e i)⟩\n\n"}
{"name":"QuadraticMap.anisotropic_of_pi","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁵ : CommSemiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝³ : AddCommMonoid P\ninst✝² : (i : ι) → Module R (Mᵢ i)\ninst✝¹ : Module R P\ninst✝ : Fintype ι\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\nh : (QuadraticMap.pi Q).Anisotropic\ni : ι\n⊢ (Q i).Anisotropic","decl":"/-- If a family is anisotropic then its components must be. The converse is not true. -/\ntheorem anisotropic_of_pi [Fintype ι]\n    {Q : ∀ i, QuadraticMap R (Mᵢ i) P} (h : (pi Q).Anisotropic) : ∀ i, (Q i).Anisotropic := by\n  simp_rw [Anisotropic, pi_apply, funext_iff, Pi.zero_apply] at h\n  intro i x hx\n  classical\n  have := h (Pi.single i x) ?_ i\n  · rw [Pi.single_eq_same] at this\n    exact this\n  apply Finset.sum_eq_zero\n  intro j _\n  by_cases hji : j = i\n  · subst hji; rw [Pi.single_eq_same, hx]\n  · rw [Pi.single_eq_of_ne hji, map_zero]\n\n"}
{"name":"QuadraticMap.nonneg_pi_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nMᵢ : ι → Type u_8\ninst✝⁵ : CommSemiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝³ : (i : ι) → Module R (Mᵢ i)\nP : Type u_10\ninst✝² : Fintype ι\ninst✝¹ : OrderedAddCommMonoid P\ninst✝ : Module R P\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\n⊢ Iff (∀ (x : (i : ι) → Mᵢ i), LE.le 0 ((QuadraticMap.pi Q) x)) (∀ (i : ι) (x : Mᵢ i), LE.le 0 ((Q i) x))","decl":"theorem nonneg_pi_iff {P} [Fintype ι] [OrderedAddCommMonoid P] [Module R P]\n    {Q : ∀ i, QuadraticMap R (Mᵢ i) P} : (∀ x, 0 ≤ pi Q x) ↔ ∀ i x, 0 ≤ Q i x := by\n  simp_rw [pi, sum_apply, comp_apply, LinearMap.proj_apply]\n  constructor\n  -- TODO: does this generalize to a useful lemma independent of `QuadraticMap`?\n  · intro h i x\n    classical\n    convert h (Pi.single i x) using 1\n    rw [Finset.sum_eq_single_of_mem i (Finset.mem_univ _) fun j _ hji => ?_, Pi.single_eq_same]\n    rw [Pi.single_eq_of_ne hji, map_zero]\n  · rintro h x\n    exact Finset.sum_nonneg fun i _ => h i (x i)\n\n"}
{"name":"QuadraticMap.posDef_pi_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nMᵢ : ι → Type u_8\ninst✝⁵ : CommSemiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (Mᵢ i)\ninst✝³ : (i : ι) → Module R (Mᵢ i)\nP : Type u_10\ninst✝² : Fintype ι\ninst✝¹ : OrderedAddCommMonoid P\ninst✝ : Module R P\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\n⊢ Iff (QuadraticMap.pi Q).PosDef (∀ (i : ι), (Q i).PosDef)","decl":"theorem posDef_pi_iff {P} [Fintype ι] [OrderedAddCommMonoid P] [Module R P]\n    {Q : ∀ i, QuadraticMap R (Mᵢ i) P} : (pi Q).PosDef ↔ ∀ i, (Q i).PosDef := by\n  simp_rw [posDef_iff_nonneg, nonneg_pi_iff]\n  constructor\n  · rintro ⟨hle, ha⟩\n    intro i\n    exact ⟨hle i, anisotropic_of_pi ha i⟩\n  · intro h\n    refine ⟨fun i => (h i).1, fun x hx => funext fun i => (h i).2 _ ?_⟩\n    rw [pi_apply, Finset.sum_eq_zero_iff_of_nonneg fun j _ => ?_] at hx\n    · exact hx _ (Finset.mem_univ _)\n    exact (h j).1 _\n\n"}
{"name":"QuadraticMap.Ring.polar_pi","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁵ : CommRing R\ninst✝⁴ : (i : ι) → AddCommGroup (Mᵢ i)\ninst✝³ : AddCommGroup P\ninst✝² : (i : ι) → Module R (Mᵢ i)\ninst✝¹ : Module R P\ninst✝ : Fintype ι\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\nx y : (i : ι) → Mᵢ i\n⊢ Eq (QuadraticMap.polar (⇑(QuadraticMap.pi Q)) x y) (Finset.univ.sum fun i => QuadraticMap.polar (⇑(Q i)) (x i) (y i))","decl":"@[simp] theorem polar_pi (Q : ∀ i, QuadraticMap R (Mᵢ i) P) (x y : ∀ i, Mᵢ i) :\n    polar (pi Q) x y = ∑ i, polar (Q i) (x i) (y i) := by\n  dsimp [polar]\n  simp_rw [Finset.sum_sub_distrib, pi_apply, Pi.add_apply]\n\n"}
{"name":"QuadraticMap.Ring.polarBilin_pi","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁵ : CommRing R\ninst✝⁴ : (i : ι) → AddCommGroup (Mᵢ i)\ninst✝³ : AddCommGroup P\ninst✝² : (i : ι) → Module R (Mᵢ i)\ninst✝¹ : Module R P\ninst✝ : Fintype ι\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\n⊢ Eq (QuadraticMap.pi Q).polarBilin (Finset.univ.sum fun i => LinearMap.compl₁₂ (Q i).polarBilin (LinearMap.proj i) (LinearMap.proj i))","decl":"@[simp] theorem polarBilin_pi (Q : ∀ i, QuadraticMap R (Mᵢ i) P) :\n    (pi Q).polarBilin = ∑ i, (Q i).polarBilin.compl₁₂ (.proj i) (.proj i) :=\n  LinearMap.ext₂ fun x y => (polar_pi _ _ _).trans <| by simp\n\n"}
{"name":"QuadraticMap.Ring.associated_pi","module":"Mathlib.LinearAlgebra.QuadraticForm.Prod","initialProofState":"ι : Type u_1\nR : Type u_2\nP : Type u_7\nMᵢ : ι → Type u_8\ninst✝⁶ : CommRing R\ninst✝⁵ : (i : ι) → AddCommGroup (Mᵢ i)\ninst✝⁴ : AddCommGroup P\ninst✝³ : (i : ι) → Module R (Mᵢ i)\ninst✝² : Module R P\ninst✝¹ : Fintype ι\ninst✝ : Invertible 2\nQ : (i : ι) → QuadraticMap R (Mᵢ i) P\n⊢ Eq (QuadraticMap.associated (QuadraticMap.pi Q)) (Finset.univ.sum fun i => LinearMap.compl₁₂ (QuadraticMap.associated (Q i)) (LinearMap.proj i) (LinearMap.proj i))","decl":"@[simp] theorem associated_pi [Invertible (2 : R)] (Q : ∀ i, QuadraticMap R (Mᵢ i) P) :\n    associated (pi Q) = ∑ i, (Q i).associated.compl₁₂ (.proj i) (.proj i) := by\n  dsimp [associated, associatedHom]\n  rw [polarBilin_pi, Finset.smul_sum]\n  rfl\n\n"}
