{"name":"Module.dualPairing_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : Module.Dual R M\nx : M\n⊢ Eq (((Module.dualPairing R M) v) x) (v x)","decl":"@[simp]\ntheorem dualPairing_apply (v x) : dualPairing R M v x = v x :=\n  rfl\n\n"}
{"name":"Module.Dual.eval_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : M\na : Module.Dual R M\n⊢ Eq (((Module.Dual.eval R M) v) a) (a v)","decl":"@[simp]\ntheorem eval_apply (v : M) (a : Dual R M) : eval R M v a = a v :=\n  rfl\n\n"}
{"name":"Module.Dual.transpose_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type uM'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nu : LinearMap (RingHom.id R) M M'\nl : Module.Dual R M'\n⊢ Eq ((Module.Dual.transpose u) l) (LinearMap.comp l u)","decl":"theorem transpose_apply (u : M →ₗ[R] M') (l : Dual R M') : transpose (R := R) u l = l.comp u :=\n  rfl\n\n"}
{"name":"Module.Dual.transpose_comp","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nM' : Type uM'\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M'\nM'' : Type uM''\ninst✝¹ : AddCommMonoid M''\ninst✝ : Module R M''\nu : LinearMap (RingHom.id R) M' M''\nv : LinearMap (RingHom.id R) M M'\n⊢ Eq (Module.Dual.transpose (u.comp v)) ((Module.Dual.transpose v).comp (Module.Dual.transpose u))","decl":"theorem transpose_comp (u : M' →ₗ[R] M'') (v : M →ₗ[R] M') :\n    transpose (R := R) (u.comp v) = (transpose (R := R) v).comp (transpose (R := R) u) :=\n  rfl\n\n"}
{"name":"Module.dualProdDualEquivDual_apply_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type uM'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : Prod (LinearMap (RingHom.id R) M R) (LinearMap (RingHom.id R) M' R)\na : Prod M M'\n⊢ Eq (((Module.dualProdDualEquivDual R M M') f) a) (HAdd.hAdd (f.1 a.1) (f.2 a.2))","decl":"/-- Taking duals distributes over products. -/\n@[simps!]\ndef dualProdDualEquivDual : (Module.Dual R M × Module.Dual R M') ≃ₗ[R] Module.Dual R (M × M') :=\n  LinearMap.coprodEquiv R\n\n"}
{"name":"Module.dualProdDualEquivDual_symm_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type uM'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) (Prod M M') R\n⊢ Eq ((Module.dualProdDualEquivDual R M M').symm f) { fst := f.comp (LinearMap.inl R M M'), snd := f.comp (LinearMap.inr R M M') }","decl":"/-- Taking duals distributes over products. -/\n@[simps!]\ndef dualProdDualEquivDual : (Module.Dual R M × Module.Dual R M') ≃ₗ[R] Module.Dual R (M × M') :=\n  LinearMap.coprodEquiv R\n\n"}
{"name":"Module.dualProdDualEquivDual_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nM' : Type uM'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nφ : Module.Dual R M\nψ : Module.Dual R M'\n⊢ Eq ((Module.dualProdDualEquivDual R M M') { fst := φ, snd := ψ }) (LinearMap.coprod φ ψ)","decl":"@[simp]\ntheorem dualProdDualEquivDual_apply (φ : Module.Dual R M) (ψ : Module.Dual R M') :\n    dualProdDualEquivDual R M M' (φ, ψ) = φ.coprod ψ :=\n  rfl\n\n"}
{"name":"LinearMap.dualMap_eq_lcomp","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq f.dualMap (LinearMap.lcomp R R f)","decl":"lemma LinearMap.dualMap_eq_lcomp (f : M₁ →ₗ[R] M₂) : f.dualMap = f.lcomp R R := rfl\n\n-- Porting note: with reducible def need to specify some parameters to transpose explicitly\n"}
{"name":"LinearMap.dualMap_def","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq f.dualMap (Module.Dual.transpose f)","decl":"theorem LinearMap.dualMap_def (f : M₁ →ₗ[R] M₂) : f.dualMap = Module.Dual.transpose (R := R) f :=\n  rfl\n\n"}
{"name":"LinearMap.dualMap_apply'","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\ng : Module.Dual R M₂\n⊢ Eq (f.dualMap g) (LinearMap.comp g f)","decl":"theorem LinearMap.dualMap_apply' (f : M₁ →ₗ[R] M₂) (g : Dual R M₂) : f.dualMap g = g.comp f :=\n  rfl\n\n"}
{"name":"LinearMap.dualMap_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\ng : Module.Dual R M₂\nx : M₁\n⊢ Eq ((f.dualMap g) x) (g (f x))","decl":"@[simp]\ntheorem LinearMap.dualMap_apply (f : M₁ →ₗ[R] M₂) (g : Dual R M₂) (x : M₁) :\n    f.dualMap g x = g (f x) :=\n  rfl\n\n"}
{"name":"LinearMap.dualMap_id","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nM₁ : Type v\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\n⊢ Eq LinearMap.id.dualMap LinearMap.id","decl":"@[simp]\ntheorem LinearMap.dualMap_id : (LinearMap.id : M₁ →ₗ[R] M₁).dualMap = LinearMap.id := by\n  ext\n  rfl\n\n"}
{"name":"LinearMap.dualMap_comp_dualMap","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁶ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : Module R M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nM₃ : Type u_1\ninst✝¹ : AddCommGroup M₃\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M₁ M₂\ng : LinearMap (RingHom.id R) M₂ M₃\n⊢ Eq (f.dualMap.comp g.dualMap) (g.comp f).dualMap","decl":"theorem LinearMap.dualMap_comp_dualMap {M₃ : Type*} [AddCommGroup M₃] [Module R M₃]\n    (f : M₁ →ₗ[R] M₂) (g : M₂ →ₗ[R] M₃) : f.dualMap.comp g.dualMap = (g.comp f).dualMap :=\n  rfl\n\n"}
{"name":"LinearMap.dualMap_injective_of_surjective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\nhf : Function.Surjective ⇑f\n⊢ Function.Injective ⇑f.dualMap","decl":"/-- If a linear map is surjective, then its dual is injective. -/\ntheorem LinearMap.dualMap_injective_of_surjective {f : M₁ →ₗ[R] M₂} (hf : Function.Surjective f) :\n    Function.Injective f.dualMap := by\n  intro φ ψ h\n  ext x\n  obtain ⟨y, rfl⟩ := hf x\n  exact congr_arg (fun g : Module.Dual R M₁ => g y) h\n\n"}
{"name":"LinearEquiv.dualMap_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearEquiv (RingHom.id R) M₁ M₂\ng : Module.Dual R M₂\nx : M₁\n⊢ Eq ((f.dualMap g) x) (g (f x))","decl":"@[simp]\ntheorem LinearEquiv.dualMap_apply (f : M₁ ≃ₗ[R] M₂) (g : Dual R M₂) (x : M₁) :\n    f.dualMap g x = g (f x) :=\n  rfl\n\n"}
{"name":"LinearEquiv.dualMap_refl","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nM₁ : Type v\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\n⊢ Eq (LinearEquiv.refl R M₁).dualMap (LinearEquiv.refl R (Module.Dual R M₁))","decl":"@[simp]\ntheorem LinearEquiv.dualMap_refl :\n    (LinearEquiv.refl R M₁).dualMap = LinearEquiv.refl R (Dual R M₁) := by\n  ext\n  rfl\n\n"}
{"name":"LinearEquiv.dualMap_symm","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearEquiv (RingHom.id R) M₁ M₂\n⊢ Eq f.dualMap.symm f.symm.dualMap","decl":"@[simp]\ntheorem LinearEquiv.dualMap_symm {f : M₁ ≃ₗ[R] M₂} :\n    (LinearEquiv.dualMap f).symm = LinearEquiv.dualMap f.symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.dualMap_trans","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁶ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : Module R M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nM₃ : Type u_1\ninst✝¹ : AddCommGroup M₃\ninst✝ : Module R M₃\nf : LinearEquiv (RingHom.id R) M₁ M₂\ng : LinearEquiv (RingHom.id R) M₂ M₃\n⊢ Eq (g.dualMap.trans f.dualMap) (f.trans g).dualMap","decl":"theorem LinearEquiv.dualMap_trans {M₃ : Type*} [AddCommGroup M₃] [Module R M₃] (f : M₁ ≃ₗ[R] M₂)\n    (g : M₂ ≃ₗ[R] M₃) : g.dualMap.trans f.dualMap = (f.trans g).dualMap :=\n  rfl\n\n"}
{"name":"Module.Dual.eval_naturality","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nM₁ : Type v\nM₂ : Type v'\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq (f.dualMap.dualMap.comp (Module.Dual.eval R M₁)) ((Module.Dual.eval R M₂).comp f)","decl":"theorem Module.Dual.eval_naturality (f : M₁ →ₗ[R] M₂) :\n    f.dualMap.dualMap ∘ₗ eval R M₁ = eval R M₂ ∘ₗ f := by\n  rfl\n\n"}
{"name":"Dual.apply_one_mul_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Module.Dual R R\nr : R\n⊢ Eq (HMul.hMul (f 1) r) (f r)","decl":"@[simp]\nlemma Dual.apply_one_mul_eq (f : Dual R R) (r : R) :\n    f 1 * r = f r := by\n  conv_rhs => rw [← mul_one r, ← smul_eq_mul]\n  rw [map_smul, smul_eq_mul, mul_comm]\n\n"}
{"name":"LinearMap.range_dualMap_dual_eq_span_singleton","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nM₁ : Type v\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nf : Module.Dual R M₁\n⊢ Eq (LinearMap.range (LinearMap.dualMap f)) (Submodule.span R (Singleton.singleton f))","decl":"@[simp]\nlemma LinearMap.range_dualMap_dual_eq_span_singleton (f : Dual R M₁) :\n    range f.dualMap = R ∙ f := by\n  ext m\n  rw [Submodule.mem_span_singleton]\n  refine ⟨fun ⟨r, hr⟩ ↦ ⟨r 1, ?_⟩, fun ⟨r, hr⟩ ↦ ⟨r • LinearMap.id, ?_⟩⟩\n  · ext; simp [dualMap_apply', ← hr]\n  · ext; simp [dualMap_apply', ← hr]\n\n"}
{"name":"Basis.toDual_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\ni j : ι\n⊢ Eq ((b.toDual (b i)) (b j)) (ite (Eq i j) 1 0)","decl":"theorem toDual_apply (i j : ι) : b.toDual (b i) (b j) = if i = j then 1 else 0 := by\n  erw [constr_basis b, constr_basis b]\n  simp only [eq_comm]\n\n"}
{"name":"Basis.toDual_linearCombination_left","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\nf : Finsupp ι R\ni : ι\n⊢ Eq ((b.toDual ((Finsupp.linearCombination R ⇑b) f)) (b i)) (f i)","decl":"@[simp]\ntheorem toDual_linearCombination_left (f : ι →₀ R) (i : ι) :\n    b.toDual (Finsupp.linearCombination R b f) (b i) = f i := by\n  rw [Finsupp.linearCombination_apply, Finsupp.sum, _root_.map_sum, LinearMap.sum_apply]\n  simp_rw [LinearMap.map_smul, LinearMap.smul_apply, toDual_apply, smul_eq_mul, mul_boole,\n    Finset.sum_ite_eq']\n  split_ifs with h\n  · rfl\n  · rw [Finsupp.not_mem_support_iff.mp h]\n\n"}
{"name":"Basis.toDual_total_left","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\nf : Finsupp ι R\ni : ι\n⊢ Eq ((b.toDual ((Finsupp.linearCombination R ⇑b) f)) (b i)) (f i)","decl":"@[deprecated (since := \"2024-08-29\")] alias toDual_total_left := toDual_linearCombination_left\n\n"}
{"name":"Basis.toDual_linearCombination_right","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\nf : Finsupp ι R\ni : ι\n⊢ Eq ((b.toDual (b i)) ((Finsupp.linearCombination R ⇑b) f)) (f i)","decl":"@[simp]\ntheorem toDual_linearCombination_right (f : ι →₀ R) (i : ι) :\n    b.toDual (b i) (Finsupp.linearCombination R b f) = f i := by\n  rw [Finsupp.linearCombination_apply, Finsupp.sum, _root_.map_sum]\n  simp_rw [LinearMap.map_smul, toDual_apply, smul_eq_mul, mul_boole, Finset.sum_ite_eq]\n  split_ifs with h\n  · rfl\n  · rw [Finsupp.not_mem_support_iff.mp h]\n\n"}
{"name":"Basis.toDual_total_right","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\nf : Finsupp ι R\ni : ι\n⊢ Eq ((b.toDual (b i)) ((Finsupp.linearCombination R ⇑b) f)) (f i)","decl":"@[deprecated (since := \"2024-08-29\")] alias toDual_total_right :=\n  toDual_linearCombination_right\n\n"}
{"name":"Basis.toDual_apply_left","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\nm : M\ni : ι\n⊢ Eq ((b.toDual m) (b i)) ((b.repr m) i)","decl":"theorem toDual_apply_left (m : M) (i : ι) : b.toDual m (b i) = b.repr m i := by\n  rw [← b.toDual_linearCombination_left, b.linearCombination_repr]\n\n"}
{"name":"Basis.toDual_apply_right","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\ni : ι\nm : M\n⊢ Eq ((b.toDual (b i)) m) ((b.repr m) i)","decl":"theorem toDual_apply_right (i : ι) (m : M) : b.toDual (b i) m = b.repr m i := by\n  rw [← b.toDual_linearCombination_right, b.linearCombination_repr]\n\n"}
{"name":"Basis.coe_toDual_self","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\ni : ι\n⊢ Eq (b.toDual (b i)) (b.coord i)","decl":"theorem coe_toDual_self (i : ι) : b.toDual (b i) = b.coord i := by\n  ext\n  apply toDual_apply_right\n\n"}
{"name":"Basis.toDualFlip_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\nm₁ m₂ : M\n⊢ Eq ((b.toDualFlip m₁) m₂) ((b.toDual m₂) m₁)","decl":"theorem toDualFlip_apply (m₁ m₂ : M) : b.toDualFlip m₁ m₂ = b.toDual m₂ m₁ :=\n  rfl\n\n"}
{"name":"Basis.toDual_eq_repr","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\nm : M\ni : ι\n⊢ Eq ((b.toDual m) (b i)) ((b.repr m) i)","decl":"theorem toDual_eq_repr (m : M) (i : ι) : b.toDual m (b i) = b.repr m i :=\n  b.toDual_apply_left m i\n\n"}
{"name":"Basis.toDual_eq_equivFun","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\nm : M\ni : ι\n⊢ Eq ((b.toDual m) (b i)) (b.equivFun m i)","decl":"theorem toDual_eq_equivFun [Finite ι] (m : M) (i : ι) : b.toDual m (b i) = b.equivFun m i := by\n  rw [b.equivFun_apply, toDual_eq_repr]\n\n"}
{"name":"Basis.toDual_injective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\n⊢ Function.Injective ⇑b.toDual","decl":"theorem toDual_injective : Injective b.toDual := fun x y h ↦ b.ext_elem_iff.mpr fun i ↦ by\n  simp_rw [← toDual_eq_repr]; exact DFunLike.congr_fun h _\n\n"}
{"name":"Basis.toDual_inj","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\nm : M\na : Eq (b.toDual m) 0\n⊢ Eq m 0","decl":"theorem toDual_inj (m : M) (a : b.toDual m = 0) : m = 0 :=\n  b.toDual_injective (by rwa [_root_.map_zero])\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629 LinearMap.ker\n"}
{"name":"Basis.toDual_ker","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nb : Basis ι R M\n⊢ Eq (LinearMap.ker b.toDual) Bot.bot","decl":"theorem toDual_ker : LinearMap.ker b.toDual = ⊥ :=\n  ker_eq_bot'.mpr b.toDual_inj\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629 LinearMap.range\n"}
{"name":"Basis.toDual_range","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\n⊢ Eq (LinearMap.range b.toDual) Top.top","decl":"theorem toDual_range [Finite ι] : LinearMap.range b.toDual = ⊤ := by\n  refine eq_top_iff'.2 fun f => ?_\n  let lin_comb : ι →₀ R := Finsupp.equivFunOnFinite.symm fun i => f (b i)\n  refine ⟨Finsupp.linearCombination R b lin_comb, b.ext fun i => ?_⟩\n  rw [b.toDual_eq_repr _ i, repr_linearCombination b]\n  rfl\n\n"}
{"name":"Basis.sum_dual_apply_smul_coord","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\nb : Basis ι R M\nf : Module.Dual R M\n⊢ Eq (Finset.univ.sum fun x => HSMul.hSMul (f (b x)) (b.coord x)) f","decl":"@[simp]\ntheorem sum_dual_apply_smul_coord (f : Module.Dual R M) :\n    (∑ x, f (b x) • b.coord x) = f := by\n  ext m\n  simp_rw [LinearMap.sum_apply, LinearMap.smul_apply, smul_eq_mul, mul_comm (f _), ← smul_eq_mul, ←\n    f.map_smul, ← _root_.map_sum, Basis.coord_apply, Basis.sum_repr]\n\n"}
{"name":"Basis.toDualEquiv_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\nm : M\n⊢ Eq (b.toDualEquiv m) (b.toDual m)","decl":"@[simp]\ntheorem toDualEquiv_apply (m : M) : b.toDualEquiv m = b.toDual m :=\n  rfl\n\n-- Not sure whether this is true for free modules over a commutative ring\n"}
{"name":"Basis.linearEquiv_dual_iff_finiteDimensional","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\n⊢ Iff (Nonempty (LinearEquiv (RingHom.id K) V (Module.Dual K V))) (FiniteDimensional K V)","decl":"/-- A vector space over a field is isomorphic to its dual if and only if it is finite-dimensional:\n  a consequence of the Erdős-Kaplansky theorem. -/\ntheorem linearEquiv_dual_iff_finiteDimensional [Field K] [AddCommGroup V] [Module K V] :\n    Nonempty (V ≃ₗ[K] Dual K V) ↔ FiniteDimensional K V := by\n  refine ⟨fun ⟨e⟩ ↦ ?_, fun h ↦ ⟨(Module.Free.chooseBasis K V).toDualEquiv⟩⟩\n  rw [FiniteDimensional, ← Module.rank_lt_aleph0_iff]\n  by_contra!\n  apply (lift_rank_lt_rank_dual this).ne\n  have := e.lift_rank_eq\n  rwa [lift_umax.{uV,uK}, lift_id'.{uV,uK}] at this\n\n"}
{"name":"Basis.dualBasis_apply_self","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\ni j : ι\n⊢ Eq ((b.dualBasis i) (b j)) (ite (Eq j i) 1 0)","decl":"theorem dualBasis_apply_self (i j : ι) : b.dualBasis i (b j) =\n    if j = i then 1 else 0 := by\n  convert b.toDual_apply i j using 2\n  rw [@eq_comm _ j i]\n\n"}
{"name":"Basis.linearCombination_dualBasis","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\nf : Finsupp ι R\ni : ι\n⊢ Eq (((Finsupp.linearCombination R ⇑b.dualBasis) f) (b i)) (f i)","decl":"theorem linearCombination_dualBasis (f : ι →₀ R) (i : ι) :\n    Finsupp.linearCombination R b.dualBasis f (b i) = f i := by\n  cases nonempty_fintype ι\n  rw [Finsupp.linearCombination_apply, Finsupp.sum_fintype, LinearMap.sum_apply]\n  · simp_rw [LinearMap.smul_apply, smul_eq_mul, dualBasis_apply_self, mul_boole,\n    Finset.sum_ite_eq, if_pos (Finset.mem_univ i)]\n  · intro\n    rw [zero_smul]\n\n"}
{"name":"Basis.total_dualBasis","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\nf : Finsupp ι R\ni : ι\n⊢ Eq (((Finsupp.linearCombination R ⇑b.dualBasis) f) (b i)) (f i)","decl":"@[deprecated (since := \"2024-08-29\")] alias total_dualBasis := linearCombination_dualBasis\n\n"}
{"name":"Basis.dualBasis_repr","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\nl : Module.Dual R M\ni : ι\n⊢ Eq ((b.dualBasis.repr l) i) (l (b i))","decl":"@[simp] theorem dualBasis_repr (l : Dual R M) (i : ι) : b.dualBasis.repr l i = l (b i) := by\n  rw [← linearCombination_dualBasis b, Basis.linearCombination_repr b.dualBasis l]\n\n"}
{"name":"Basis.dualBasis_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\ni : ι\nm : M\n⊢ Eq ((b.dualBasis i) m) ((b.repr m) i)","decl":"theorem dualBasis_apply (i : ι) (m : M) : b.dualBasis i m = b.repr m i :=\n  b.toDual_apply_right i m\n\n"}
{"name":"Basis.coe_dualBasis","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\n⊢ Eq (⇑b.dualBasis) b.coord","decl":"@[simp]\ntheorem coe_dualBasis : ⇑b.dualBasis = b.coord := by\n  ext i x\n  apply dualBasis_apply\n\n"}
{"name":"Basis.toDual_toDual","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\n⊢ Eq (b.dualBasis.toDual.comp b.toDual) (Module.Dual.eval R M)","decl":"@[simp]\ntheorem toDual_toDual : b.dualBasis.toDual.comp b.toDual = Dual.eval R M := by\n  refine b.ext fun i => b.dualBasis.ext fun j => ?_\n  rw [LinearMap.comp_apply, toDual_apply_left, coe_toDual_self, ← coe_dualBasis,\n    Dual.eval_apply, Basis.repr_self, Finsupp.single_apply, dualBasis_apply_self]\n\n"}
{"name":"Basis.dualBasis_equivFun","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : DecidableEq ι\nb : Basis ι R M\ninst✝ : Finite ι\nl : Module.Dual R M\ni : ι\n⊢ Eq (b.dualBasis.equivFun l i) (l (b i))","decl":"theorem dualBasis_equivFun [Finite ι] (l : Dual R M) (i : ι) :\n    b.dualBasis.equivFun l i = l (b i) := by rw [Basis.equivFun_apply, dualBasis_repr]\n\n"}
{"name":"Basis.eval_ker","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nι : Type u_1\nb : Basis ι R M\n⊢ Eq (LinearMap.ker (Module.Dual.eval R M)) Bot.bot","decl":"theorem eval_ker {ι : Type*} (b : Basis ι R M) :\n    LinearMap.ker (Dual.eval R M) = ⊥ := by\n  rw [ker_eq_bot']\n  intro m hm\n  simp_rw [LinearMap.ext_iff, Dual.eval_apply, zero_apply] at hm\n  exact (Basis.forall_coord_eq_zero_iff _).mp fun i => hm (b.coord i)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629 LinearMap.range\n"}
{"name":"Basis.eval_range","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_1\ninst✝ : Finite ι\nb : Basis ι R M\n⊢ Eq (LinearMap.range (Module.Dual.eval R M)) Top.top","decl":"theorem eval_range {ι : Type*} [Finite ι] (b : Basis ι R M) :\n    LinearMap.range (Dual.eval R M) = ⊤ := by\n  classical\n    cases nonempty_fintype ι\n    rw [← b.toDual_toDual, range_comp, b.toDual_range, Submodule.map_top, toDual_range _]\n\n"}
{"name":"Basis.dual_free","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\n⊢ Module.Free R (Module.Dual R M)","decl":"instance dual_free [Free R M] : Free R (Dual R M) :=\n  Free.of_basis (Free.chooseBasis R M).dualBasis\n\n"}
{"name":"Basis.dual_projective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Projective R M\n⊢ Module.Projective R (Module.Dual R M)","decl":"instance dual_projective [Projective R M] : Projective R (Dual R M) :=\n  have ⟨_, f, g, _, _, hfg⟩ := Finite.exists_comp_eq_id_of_projective R M\n  .of_split f.dualMap g.dualMap (congr_arg dualMap hfg)\n\n"}
{"name":"Basis.dual_finite","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Projective R M\n⊢ Module.Finite R (Module.Dual R M)","decl":"instance dual_finite [Projective R M] : Module.Finite R (Dual R M) :=\n  have ⟨n, f, g, _, _, hfg⟩ := Finite.exists_comp_eq_id_of_projective R M\n  have := Finite.of_basis (Free.chooseBasis R <| Fin n → R).dualBasis\n  .of_surjective _ (surjective_of_comp_eq_id f.dualMap g.dualMap <| congr_arg dualMap hfg)\n\n"}
{"name":"Basis.linearCombination_coord","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Finite ι\nb : Basis ι R M\nf : Finsupp ι R\ni : ι\n⊢ Eq (((Finsupp.linearCombination R b.coord) f) (b i)) (f i)","decl":"/-- `simp` normal form version of `linearCombination_dualBasis` -/\n@[simp]\ntheorem linearCombination_coord [CommRing R] [AddCommGroup M] [Module R M] [Finite ι]\n    (b : Basis ι R M) (f : ι →₀ R) (i : ι) : Finsupp.linearCombination R b.coord f (b i) = f i := by\n  haveI := Classical.decEq ι\n  rw [← coe_dualBasis, linearCombination_dualBasis]\n\n"}
{"name":"Basis.total_coord","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\nM : Type uM\nι : Type uι\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Finite ι\nb : Basis ι R M\nf : Finsupp ι R\ni : ι\n⊢ Eq (((Finsupp.linearCombination R b.coord) f) (b i)) (f i)","decl":"@[deprecated (since := \"2024-08-29\")] alias total_coord := linearCombination_coord\n\n"}
{"name":"Basis.dual_rank_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\nι : Type uι\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Finite ι\nb : Basis ι K V\n⊢ Eq (Cardinal.lift.{uK, uV} (Module.rank K V)) (Module.rank K (Module.Dual K V))","decl":"theorem dual_rank_eq [CommRing K] [AddCommGroup V] [Module K V] [Finite ι] (b : Basis ι K V) :\n    Cardinal.lift.{uK,uV} (Module.rank K V) = Module.rank K (Dual K V) := by\n  classical rw [← lift_umax.{uV,uK}, b.toDualEquiv.lift_rank_eq, lift_id'.{uV,uK}]\n\n"}
{"name":"Module.eval_ker","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Projective K V\n⊢ Eq (LinearMap.ker (Module.Dual.eval K V)) Bot.bot","decl":"theorem eval_ker : LinearMap.ker (eval K V) = ⊥ :=\n  have ⟨s, hs⟩ := Module.projective_def'.mp ‹Projective K V›\n  ker_eq_bot.mpr <| .of_comp (f := s.dualMap.dualMap) <| (ker_eq_bot.mp <|\n    Finsupp.basisSingleOne (R := K).eval_ker).comp (injective_of_comp_eq_id s _ hs)\n\n"}
{"name":"Module.map_eval_injective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Projective K V\n⊢ Function.Injective (Submodule.map (Module.Dual.eval K V))","decl":"theorem map_eval_injective : (Submodule.map (eval K V)).Injective := by\n  apply Submodule.map_injective_of_injective\n  rw [← LinearMap.ker_eq_bot]\n  exact eval_ker K V\n\n"}
{"name":"Module.comap_eval_surjective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Projective K V\n⊢ Function.Surjective (Submodule.comap (Module.Dual.eval K V))","decl":"theorem comap_eval_surjective : (Submodule.comap (eval K V)).Surjective := by\n  apply Submodule.comap_surjective_of_injective\n  rw [← LinearMap.ker_eq_bot]\n  exact eval_ker K V\n\n"}
{"name":"Module.eval_apply_eq_zero_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Projective K V\nv : V\n⊢ Iff (Eq ((Module.Dual.eval K V) v) 0) (Eq v 0)","decl":"theorem eval_apply_eq_zero_iff (v : V) : (eval K V) v = 0 ↔ v = 0 := by\n  simpa only using SetLike.ext_iff.mp (eval_ker K V) v\n\n"}
{"name":"Module.eval_apply_injective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Projective K V\n⊢ Function.Injective ⇑(Module.Dual.eval K V)","decl":"theorem eval_apply_injective : Function.Injective (eval K V) :=\n  (injective_iff_map_eq_zero' (eval K V)).mpr (eval_apply_eq_zero_iff K)\n\n"}
{"name":"Module.forall_dual_apply_eq_zero_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Projective K V\nv : V\n⊢ Iff (∀ (φ : Module.Dual K V), Eq (φ v) 0) (Eq v 0)","decl":"theorem forall_dual_apply_eq_zero_iff (v : V) : (∀ φ : Module.Dual K V, φ v = 0) ↔ v = 0 := by\n  rw [← eval_apply_eq_zero_iff K v, LinearMap.ext_iff]\n  rfl\n\n"}
{"name":"Module.subsingleton_dual_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Projective K V\n⊢ Iff (Subsingleton (Module.Dual K V)) (Subsingleton V)","decl":"@[simp]\ntheorem subsingleton_dual_iff :\n    Subsingleton (Dual K V) ↔ Subsingleton V := by\n  refine ⟨fun h ↦ ⟨fun v w ↦ ?_⟩, fun _ ↦ inferInstance⟩\n  rw [← sub_eq_zero, ← forall_dual_apply_eq_zero_iff K (v - w)]\n  intros f\n  simp [Subsingleton.elim f 0]\n\n"}
{"name":"Module.nontrivial_dual_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Projective K V\n⊢ Iff (Nontrivial (Module.Dual K V)) (Nontrivial V)","decl":"@[simp]\ntheorem nontrivial_dual_iff :\n    Nontrivial (Dual K V) ↔ Nontrivial V := by\n  rw [← not_iff_not, not_nontrivial_iff_subsingleton, not_nontrivial_iff_subsingleton,\n    subsingleton_dual_iff]\n\n"}
{"name":"Module.instNontrivialDual","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝⁴ : CommRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Projective K V\ninst✝ : Nontrivial V\n⊢ Nontrivial (Module.Dual K V)","decl":"instance instNontrivialDual [Nontrivial V] : Nontrivial (Dual K V) :=\n  (nontrivial_dual_iff K).mpr inferInstance\n\n"}
{"name":"Module.finite_dual_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝³ : CommRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.Free K V\n⊢ Iff (Module.Finite K (Module.Dual K V)) (Module.Finite K V)","decl":"omit [Projective K V] in\ntheorem finite_dual_iff [Free K V] : Module.Finite K (Dual K V) ↔ Module.Finite K V := by\n  constructor <;> intro h\n  · obtain ⟨⟨ι, b⟩⟩ := Free.exists_basis (R := K) (M := V)\n    nontriviality K\n    obtain ⟨⟨s, span_s⟩⟩ := h\n    classical\n    haveI := (b.linearIndependent.map' _ b.toDual_ker).finite_of_le_span_finite _ s ?_\n    · exact Finite.of_basis b\n    · rw [span_s]; apply le_top\n  · infer_instance\n\n"}
{"name":"Module.dual_rank_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\nV : Type uV\ninst✝⁴ : CommRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : Module.Free K V\ninst✝ : Module.Finite K V\n⊢ Eq (Cardinal.lift.{uK, uV} (Module.rank K V)) (Module.rank K (Module.Dual K V))","decl":"theorem dual_rank_eq [Free K V] [Module.Finite K V] :\n    Cardinal.lift.{uK,uV} (Module.rank K V) = Module.rank K (Dual K V) :=\n  (Module.Free.chooseBasis K V).dual_rank_eq\n\n"}
{"name":"Module.IsReflexive.bijective_dual_eval'","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : Module.IsReflexive R M\n⊢ Function.Bijective ⇑(Module.Dual.eval R M)","decl":"/-- A reflexive module is one for which the natural map to its double dual is a bijection.\n\nAny finitely-generated projective module (and thus any finite-dimensional vector space)\nis reflexive. See `Module.instIsReflexiveOfFiniteOfProjective`. -/\nclass IsReflexive : Prop where\n  /-- A reflexive module is one for which the natural map to its double dual is a bijection. -/\n  bijective_dual_eval' : Bijective (Dual.eval R M)\n\n"}
{"name":"Module.bijective_dual_eval","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\n⊢ Function.Bijective ⇑(Module.Dual.eval R M)","decl":"lemma bijective_dual_eval [IsReflexive R M] : Bijective (Dual.eval R M) :=\n  IsReflexive.bijective_dual_eval'\n\n"}
{"name":"Module.IsReflexive.of_finite_of_free","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\n⊢ Module.IsReflexive R M","decl":"/-- See also `Module.instFiniteDimensionalOfIsReflexive` for the converse over a field. -/\ninstance (priority := 900) IsReflexive.of_finite_of_free [Module.Finite R M] [Free R M] :\n    IsReflexive R M where\n  bijective_dual_eval'.left := ker_eq_bot.mp (Free.chooseBasis R M).eval_ker\n  bijective_dual_eval'.right := range_eq_top.mp (Free.chooseBasis R M).eval_range\n\n"}
{"name":"Module.erange_coe","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\n⊢ Eq (LinearMap.range (Module.Dual.eval R M)) Top.top","decl":"theorem erange_coe : LinearMap.range (eval R M) = ⊤ :=\n  range_eq_top.mpr (bijective_dual_eval _ _).2\n\n"}
{"name":"Module.evalEquiv_toLinearMap","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\n⊢ Eq (↑(Module.evalEquiv R M)) (Module.Dual.eval R M)","decl":"@[simp] lemma evalEquiv_toLinearMap : evalEquiv R M = Dual.eval R M := rfl\n\n"}
{"name":"Module.evalEquiv_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\nm : M\n⊢ Eq ((Module.evalEquiv R M) m) ((Module.Dual.eval R M) m)","decl":"@[simp] lemma evalEquiv_apply (m : M) : evalEquiv R M m = Dual.eval R M m := rfl\n\n"}
{"name":"Module.apply_evalEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\nf : Module.Dual R M\ng : Module.Dual R (Module.Dual R M)\n⊢ Eq (f ((Module.evalEquiv R M).symm g)) (g f)","decl":"@[simp] lemma apply_evalEquiv_symm_apply (f : Dual R M) (g : Dual R (Dual R M)) :\n    f ((evalEquiv R M).symm g) = g f := by\n  set m := (evalEquiv R M).symm g\n  rw [← (evalEquiv R M).apply_symm_apply g, evalEquiv_apply, Dual.eval_apply]\n\n"}
{"name":"Module.symm_dualMap_evalEquiv","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\n⊢ Eq (↑(Module.evalEquiv R M).symm.dualMap) (Module.Dual.eval R (Module.Dual R M))","decl":"@[simp] lemma symm_dualMap_evalEquiv :\n    (evalEquiv R M).symm.dualMap = Dual.eval R (Dual R M) := by\n  ext; simp\n\n"}
{"name":"Module.Dual.eval_comp_comp_evalEquiv_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Module.IsReflexive R M\nM' : Type u_4\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\n⊢ Eq ((Module.Dual.eval R M').comp (f.comp ↑(Module.evalEquiv R M).symm)) f.dualMap.dualMap","decl":"@[simp] lemma Dual.eval_comp_comp_evalEquiv_eq\n    {M' : Type*} [AddCommGroup M'] [Module R M'] {f : M →ₗ[R] M'} :\n    Dual.eval R M' ∘ₗ f ∘ₗ (evalEquiv R M).symm = f.dualMap.dualMap := by\n  rw [← LinearMap.comp_assoc, LinearEquiv.comp_toLinearMap_symm_eq,\n    evalEquiv_toLinearMap, eval_naturality]\n\n"}
{"name":"Module.dualMap_dualMap_eq_iff_of_injective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Module.IsReflexive R M\nM' : Type u_4\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nf g : LinearMap (RingHom.id R) M M'\nh : Function.Injective ⇑(Module.Dual.eval R M')\n⊢ Iff (Eq f.dualMap.dualMap g.dualMap.dualMap) (Eq f g)","decl":"lemma dualMap_dualMap_eq_iff_of_injective\n    {M' : Type*} [AddCommGroup M'] [Module R M'] {f g : M →ₗ[R] M'}\n    (h : Injective (Dual.eval R M')) :\n    f.dualMap.dualMap = g.dualMap.dualMap ↔ f = g := by\n  simp only [← Dual.eval_comp_comp_evalEquiv_eq]\n  refine ⟨fun hfg => ?_, fun a ↦ congrArg (Dual.eval R M').comp\n    (congrFun (congrArg LinearMap.comp a) (evalEquiv R M).symm.toLinearMap)⟩\n  rw [propext (cancel_left h), LinearEquiv.eq_comp_toLinearMap_iff] at hfg\n  exact hfg\n\n"}
{"name":"Module.dualMap_dualMap_eq_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : Module.IsReflexive R M\nM' : Type u_4\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : Module.IsReflexive R M'\nf g : LinearMap (RingHom.id R) M M'\n⊢ Iff (Eq f.dualMap.dualMap g.dualMap.dualMap) (Eq f g)","decl":"@[simp] lemma dualMap_dualMap_eq_iff\n    {M' : Type*} [AddCommGroup M'] [Module R M'] [IsReflexive R M'] {f g : M →ₗ[R] M'} :\n    f.dualMap.dualMap = g.dualMap.dualMap ↔ f = g :=\n  dualMap_dualMap_eq_iff_of_injective _ _ (bijective_dual_eval R M').injective\n\n"}
{"name":"Module.Dual.instIsReflecive","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Module.IsReflexive R (Module.Dual R M)","decl":"/-- The dual of a reflexive module is reflexive. -/\ninstance Dual.instIsReflecive : IsReflexive R (Dual R M) :=\n  ⟨by simpa only [← symm_dualMap_evalEquiv] using (evalEquiv R M).dualMap.symm.bijective⟩\n\n"}
{"name":"Module.IsReflexive.of_split","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ni : LinearMap (RingHom.id R) N M\ns : LinearMap (RingHom.id R) M N\nH : Eq (s.comp i) LinearMap.id\n⊢ Module.IsReflexive R N","decl":"variable {R M N} in\n/-- A direct summand of a reflexive module is reflexive. -/\nlemma IsReflexive.of_split (i : N →ₗ[R] M) (s : M →ₗ[R] N) (H : s ∘ₗ i = .id) :\n    IsReflexive R N where\n  bijective_dual_eval' :=\n    ⟨.of_comp (f := i.dualMap.dualMap) <|\n      (bijective_dual_eval R M).1.comp (injective_of_comp_eq_id i _ H),\n    .of_comp (g := s) <| (surjective_of_comp_eq_id i.dualMap.dualMap s.dualMap.dualMap <|\n      congr_arg (dualMap ∘ dualMap) H).comp (bijective_dual_eval R M).2⟩\n\n"}
{"name":"Module.instIsReflexiveOfFiniteOfProjective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : Module.Finite R N\ninst✝ : Module.Projective R N\n⊢ Module.IsReflexive R N","decl":"instance (priority := 900) [Module.Finite R N] [Projective R N] : IsReflexive R N :=\n  have ⟨_, f, hf⟩ := Finite.exists_fin' R N\n  have ⟨g, H⟩ := projective_lifting_property f .id hf\n  .of_split g f H\n\n"}
{"name":"Module.mapEvalEquiv_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\nW : Submodule R M\n⊢ Eq ((Module.mapEvalEquiv R M) W) (Submodule.map (Module.Dual.eval R M) W)","decl":"@[simp]\ntheorem mapEvalEquiv_apply (W : Submodule R M) :\n    mapEvalEquiv R M W = W.map (Dual.eval R M) :=\n  rfl\n\n"}
{"name":"Module.mapEvalEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\nW'' : Submodule R (Module.Dual R (Module.Dual R M))\n⊢ Eq ((Module.mapEvalEquiv R M).symm W'') (Submodule.comap (Module.Dual.eval R M) W'')","decl":"@[simp]\ntheorem mapEvalEquiv_symm_apply (W'' : Submodule R (Dual R (Dual R M))) :\n    (mapEvalEquiv R M).symm W'' = W''.comap (Dual.eval R M) :=\n  rfl\n\n"}
{"name":"Prod.instModuleIsReflexive","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R N\n⊢ Module.IsReflexive R (Prod M N)","decl":"instance _root_.Prod.instModuleIsReflexive [IsReflexive R N] :\n    IsReflexive R (M × N) where\n  bijective_dual_eval' := by\n    let e : Dual R (Dual R (M × N)) ≃ₗ[R] Dual R (Dual R M) × Dual R (Dual R N) :=\n      (dualProdDualEquivDual R M N).dualMap.trans\n        (dualProdDualEquivDual R (Dual R M) (Dual R N)).symm\n    have : Dual.eval R (M × N) = e.symm.comp ((Dual.eval R M).prodMap (Dual.eval R N)) := by\n      ext m f <;> simp [e]\n    simp only [this, LinearEquiv.trans_symm, LinearEquiv.symm_symm, LinearEquiv.dualMap_symm,\n      coe_comp, LinearEquiv.coe_coe, EquivLike.comp_bijective]\n    exact (bijective_dual_eval R M).prodMap (bijective_dual_eval R N)\n\n"}
{"name":"Module.equiv","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) M N\n⊢ Module.IsReflexive R N","decl":"variable {R M N} in\nlemma equiv (e : M ≃ₗ[R] N) : IsReflexive R N where\n  bijective_dual_eval' := by\n    let ed : Dual R (Dual R N) ≃ₗ[R] Dual R (Dual R M) := e.symm.dualMap.dualMap\n    have : Dual.eval R N = ed.symm.comp ((Dual.eval R M).comp e.symm.toLinearMap) := by\n      ext m f\n      exact DFunLike.congr_arg f (e.apply_symm_apply m).symm\n    simp only [this, LinearEquiv.trans_symm, LinearEquiv.symm_symm, LinearEquiv.dualMap_symm,\n      coe_comp, LinearEquiv.coe_coe, EquivLike.comp_bijective]\n    exact Bijective.comp (bijective_dual_eval R M) (LinearEquiv.bijective _)\n\n"}
{"name":"MulOpposite.instModuleIsReflexive","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\n⊢ Module.IsReflexive R (MulOpposite M)","decl":"instance _root_.MulOpposite.instModuleIsReflexive : IsReflexive R (MulOpposite M) :=\n  equiv <| MulOpposite.opLinearEquiv _\n\n"}
{"name":"ULift.instModuleIsReflexive","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\n⊢ Module.IsReflexive R (ULift.{w, u_2} M)","decl":"instance _root_.ULift.instModuleIsReflexive.{w} : IsReflexive R (ULift.{w} M) :=\n  equiv ULift.moduleEquiv.symm\n\n"}
{"name":"Module.instFiniteDimensionalOfIsReflexive","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u_4\nV : Type u_5\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Module.IsReflexive K V\n⊢ FiniteDimensional K V","decl":"instance instFiniteDimensionalOfIsReflexive (K V : Type*)\n    [Field K] [AddCommGroup V] [Module K V] [IsReflexive K V] :\n    FiniteDimensional K V := by\n  rw [FiniteDimensional, ← rank_lt_aleph0_iff]\n  by_contra! contra\n  suffices lift (Module.rank K V) < Module.rank K (Dual K (Dual K V)) by\n    have heq := lift_rank_eq_of_equiv_equiv (R := K) (R' := K) (M := V) (M' := Dual K (Dual K V))\n      (ZeroHom.id K) (evalEquiv K V) bijective_id (fun r v ↦ (evalEquiv K V).map_smul _ _)\n    rw [← lift_umax, heq, lift_id'] at this\n    exact lt_irrefl _ this\n  have h₁ : lift (Module.rank K V) < Module.rank K (Dual K V) := lift_rank_lt_rank_dual contra\n  have h₂ : Module.rank K (Dual K V) < Module.rank K (Dual K (Dual K V)) := by\n    convert lift_rank_lt_rank_dual <| le_trans (by simpa) h₁.le\n    rw [lift_id']\n  exact lt_trans h₁ h₂\n\n"}
{"name":"Module.instNoZeroSMulDivisorsOfIsDomain","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsDomain R\n⊢ NoZeroSMulDivisors R M","decl":"instance [IsDomain R] : NoZeroSMulDivisors R M := by\n  refine (noZeroSMulDivisors_iff R M).mpr ?_\n  intro r m hrm\n  rw [or_iff_not_imp_left]\n  intro hr\n  suffices Dual.eval R M m = Dual.eval R M 0 from (bijective_dual_eval R M).injective this\n  ext n\n  simp only [Dual.eval_apply, map_zero, LinearMap.zero_apply]\n  suffices r • n m = 0 from eq_zero_of_ne_zero_of_mul_left_eq_zero hr this\n  rw [← LinearMap.map_smul_of_tower, hrm, LinearMap.map_zero]\n\n"}
{"name":"Submodule.exists_dual_map_eq_bot_of_nmem","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nx : M\nhx : Not (Membership.mem p x)\nhp' : Module.Free R (HasQuotient.Quotient M p)\n⊢ Exists fun f => And (Ne (f x) 0) (Eq (Submodule.map f p) Bot.bot)","decl":"theorem exists_dual_map_eq_bot_of_nmem {x : M} (hx : x ∉ p) (hp' : Free R (M ⧸ p)) :\n    ∃ f : Dual R M, f x ≠ 0 ∧ p.map f = ⊥ := by\n  suffices ∃ f : Dual R (M ⧸ p), f (p.mkQ x) ≠ 0 by\n    obtain ⟨f, hf⟩ := this; exact ⟨f.comp p.mkQ, hf, by simp [Submodule.map_comp]⟩\n  rwa [← Submodule.Quotient.mk_eq_zero, ← Submodule.mkQ_apply,\n    ← forall_dual_apply_eq_zero_iff (K := R), not_forall] at hx\n\n"}
{"name":"Submodule.exists_dual_map_eq_bot_of_lt_top","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nhp : LT.lt p Top.top\nhp' : Module.Free R (HasQuotient.Quotient M p)\n⊢ Exists fun f => And (Ne f 0) (Eq (Submodule.map f p) Bot.bot)","decl":"theorem exists_dual_map_eq_bot_of_lt_top (hp : p < ⊤) (hp' : Free R (M ⧸ p)) :\n    ∃ f : Dual R M, f ≠ 0 ∧ p.map f = ⊥ := by\n  obtain ⟨x, hx⟩ : ∃ x : M, x ∉ p := by rw [lt_top_iff_ne_top] at hp; contrapose! hp; ext; simp [hp]\n  obtain ⟨f, hf, hf'⟩ := p.exists_dual_map_eq_bot_of_nmem hx hp'\n  exact ⟨f, by aesop, hf'⟩\n\n"}
{"name":"Submodule.span_eq_top_of_ne_zero","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.IsReflexive R M\ns : Set (LinearMap (RingHom.id R) M R)\ninst✝ : Module.Free R (HasQuotient.Quotient (LinearMap (RingHom.id R) M R) (Submodule.span R s))\nh : ∀ (z : M), Ne z 0 → Exists fun f => And (Membership.mem s f) (Ne (f z) 0)\n⊢ Eq (Submodule.span R s) Top.top","decl":"/-- Consider a reflexive module and a set `s` of linear forms. If for any `z ≠ 0` there exists\n`f ∈ s` such that `f z ≠ 0`, then `s` spans the whole dual space. -/\ntheorem span_eq_top_of_ne_zero [IsReflexive R M]\n    {s : Set (M →ₗ[R] R)} [Free R ((M →ₗ[R] R) ⧸ (span R s))]\n    (h : ∀ z ≠ 0, ∃ f ∈ s, f z ≠ 0) : span R s = ⊤ := by\n  by_contra! hn\n  obtain ⟨φ, φne, hφ⟩ := exists_dual_map_eq_bot_of_lt_top hn.lt_top inferInstance\n  let φs := (evalEquiv R M).symm φ\n  have this f (hf : f ∈ s) : f φs = 0 := by\n    rw [← mem_bot R, ← hφ, mem_map]\n    exact ⟨f, subset_span hf, (apply_evalEquiv_symm_apply R M f φ).symm⟩\n  obtain ⟨x, xs, hx⟩ := h φs (by simp [φne, φs])\n  exact hx <| this x xs\n\n"}
{"name":"FiniteDimensional.mem_span_of_iInf_ker_le_ker","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"ι : Type u_3\n𝕜 : Type u_4\nE : Type u_5\ninst✝³ : Field 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : FiniteDimensional 𝕜 E\nL : ι → LinearMap (RingHom.id 𝕜) E 𝕜\nK : LinearMap (RingHom.id 𝕜) E 𝕜\nh : LE.le (iInf fun i => LinearMap.ker (L i)) (LinearMap.ker K)\n⊢ Membership.mem (Submodule.span 𝕜 (Set.range L)) K","decl":"theorem _root_.FiniteDimensional.mem_span_of_iInf_ker_le_ker [FiniteDimensional 𝕜 E]\n    {L : ι → E →ₗ[𝕜] 𝕜} {K : E →ₗ[𝕜] 𝕜}\n    (h : ⨅ i, LinearMap.ker (L i) ≤ ker K) : K ∈ span 𝕜 (range L) := by\n  by_contra hK\n  rcases exists_dual_map_eq_bot_of_nmem hK inferInstance with ⟨φ, φne, hφ⟩\n  let φs := (Module.evalEquiv 𝕜 E).symm φ\n  have : K φs = 0 := by\n    refine h <| (Submodule.mem_iInf _).2 fun i ↦ (mem_bot 𝕜).1 ?_\n    rw [← hφ, Submodule.mem_map]\n    exact ⟨L i, Submodule.subset_span ⟨i, rfl⟩, (apply_evalEquiv_symm_apply 𝕜 E _ φ).symm⟩\n  simp only [apply_evalEquiv_symm_apply, φs, φne] at this\n\n"}
{"name":"mem_span_of_iInf_ker_le_ker","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"ι : Type u_3\n𝕜 : Type u_4\nE : Type u_5\ninst✝³ : Field 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : Finite ι\nL : ι → LinearMap (RingHom.id 𝕜) E 𝕜\nK : LinearMap (RingHom.id 𝕜) E 𝕜\nh : LE.le (iInf fun i => LinearMap.ker (L i)) (LinearMap.ker K)\n⊢ Membership.mem (Submodule.span 𝕜 (Set.range L)) K","decl":"/-- Given some linear forms $L_1, ..., L_n, K$ over a vector space $E$, if\n$\\bigcap_{i=1}^n \\mathrm{ker}(L_i) \\subseteq \\mathrm{ker}(K)$, then $K$ is in the space generated\nby $L_1, ..., L_n$. -/\ntheorem _root_.mem_span_of_iInf_ker_le_ker [Finite ι] {L : ι → E →ₗ[𝕜] 𝕜} {K : E →ₗ[𝕜] 𝕜}\n    (h : ⨅ i, ker (L i) ≤ ker K) : K ∈ span 𝕜 (range L) := by\n  have _ := Fintype.ofFinite ι\n  let φ : E →ₗ[𝕜] ι → 𝕜 := LinearMap.pi L\n  let p := ⨅ i, ker (L i)\n  have p_eq : p = ker φ := (ker_pi L).symm\n  let ψ : (E ⧸ p) →ₗ[𝕜] ι → 𝕜 := p.liftQ φ p_eq.le\n  have _ : FiniteDimensional 𝕜 (E ⧸ p) := of_injective ψ (ker_eq_bot.1 (ker_liftQ_eq_bot' p φ p_eq))\n  let L' i : (E ⧸ p) →ₗ[𝕜] 𝕜 := p.liftQ (L i) (iInf_le _ i)\n  let K' : (E ⧸ p) →ₗ[𝕜] 𝕜 := p.liftQ K h\n  have : ⨅ i, ker (L' i) ≤ ker K' := by\n    simp_rw +zetaDelta [← ker_pi, pi_liftQ_eq_liftQ_pi, ker_liftQ_eq_bot' p φ p_eq]\n    exact bot_le\n  obtain ⟨c, hK'⟩ :=\n    (mem_span_range_iff_exists_fun 𝕜).1 (FiniteDimensional.mem_span_of_iInf_ker_le_ker this)\n  refine (mem_span_range_iff_exists_fun 𝕜).2 ⟨c, ?_⟩\n  conv_lhs => enter [2]; intro i; rw [← p.liftQ_mkQ (L i) (iInf_le _ i)]\n  rw [← p.liftQ_mkQ K h]\n  ext x\n  convert LinearMap.congr_fun hK' (p.mkQ x)\n  simp only [L',coeFn_sum, Finset.sum_apply, smul_apply, coe_comp, Function.comp_apply,\n    smul_eq_mul]\n\n"}
{"name":"Module.DualBases.total","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nself : Module.DualBases e ε\nm : M\na✝ : ∀ (i : ι), Eq ((ε i) m) 0\n⊢ Eq m 0","decl":"/-- `e` and `ε` have characteristic properties of a basis and its dual -/\nstructure Module.DualBases (e : ι → M) (ε : ι → Dual R M) : Prop where\n  eval_same : ∀ i, ε i (e i) = 1\n  eval_of_ne : Pairwise fun i j ↦ ε i (e j) = 0\n  protected total : ∀ {m : M}, (∀ i, ε i m = 0) → m = 0\n  protected finite : ∀ m : M, {i | ε i m ≠ 0}.Finite := by use_finite_instance\n\n"}
{"name":"Module.DualBases.eval_same","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nself : Module.DualBases e ε\ni : ι\n⊢ Eq ((ε i) (e i)) 1","decl":"/-- `e` and `ε` have characteristic properties of a basis and its dual -/\nstructure Module.DualBases (e : ι → M) (ε : ι → Dual R M) : Prop where\n  eval_same : ∀ i, ε i (e i) = 1\n  eval_of_ne : Pairwise fun i j ↦ ε i (e j) = 0\n  protected total : ∀ {m : M}, (∀ i, ε i m = 0) → m = 0\n  protected finite : ∀ m : M, {i | ε i m ≠ 0}.Finite := by use_finite_instance\n\n"}
{"name":"Module.DualBases.finite","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nself : Module.DualBases e ε\nm : M\n⊢ (setOf fun i => Ne ((ε i) m) 0).Finite","decl":"/-- `e` and `ε` have characteristic properties of a basis and its dual -/\nstructure Module.DualBases (e : ι → M) (ε : ι → Dual R M) : Prop where\n  eval_same : ∀ i, ε i (e i) = 1\n  eval_of_ne : Pairwise fun i j ↦ ε i (e j) = 0\n  protected total : ∀ {m : M}, (∀ i, ε i m = 0) → m = 0\n  protected finite : ∀ m : M, {i | ε i m ≠ 0}.Finite := by use_finite_instance\n\n"}
{"name":"Module.DualBases.eval_of_ne","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nself : Module.DualBases e ε\n⊢ Pairwise fun i j => Eq ((ε i) (e j)) 0","decl":"/-- `e` and `ε` have characteristic properties of a basis and its dual -/\nstructure Module.DualBases (e : ι → M) (ε : ι → Dual R M) : Prop where\n  eval_same : ∀ i, ε i (e i) = 1\n  eval_of_ne : Pairwise fun i j ↦ ε i (e j) = 0\n  protected total : ∀ {m : M}, (∀ i, ε i m = 0) → m = 0\n  protected finite : ∀ m : M, {i | ε i m ≠ 0}.Finite := by use_finite_instance\n\n"}
{"name":"Module.DualBases.coeffs_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nh : Module.DualBases e ε\nm : M\ni : ι\n⊢ Eq ((h.coeffs m) i) ((ε i) m)","decl":"@[simp]\ntheorem coeffs_apply (h : DualBases e ε) (m : M) (i : ι) : h.coeffs m i = ε i m :=\n  rfl\n\n"}
{"name":"Module.DualBases.lc_def","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : ι → M\nl : Finsupp ι R\n⊢ Eq (Module.DualBases.lc e l) ((Finsupp.linearCombination R e) l)","decl":"theorem lc_def (e : ι → M) (l : ι →₀ R) : lc e l = Finsupp.linearCombination R e l :=\n  rfl\n\n"}
{"name":"Module.DualBases.dual_lc","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nh : Module.DualBases e ε\nl : Finsupp ι R\ni : ι\n⊢ Eq ((ε i) (Module.DualBases.lc e l)) (l i)","decl":"theorem dual_lc (l : ι →₀ R) (i : ι) : ε i (DualBases.lc e l) = l i := by\n  rw [lc, _root_.map_finsupp_sum, Finsupp.sum_eq_single i (g := fun a b ↦ (ε i) (b • e a))]\n  -- Porting note: cannot get at •\n  -- simp only [h.eval, map_smul, smul_eq_mul]\n  · simp [h.eval_same, smul_eq_mul]\n  · intro q _ q_ne\n    simp [h.eval_of_ne q_ne.symm, smul_eq_mul]\n  · simp\n\n"}
{"name":"Module.DualBases.coeffs_lc","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nh : Module.DualBases e ε\nl : Finsupp ι R\n⊢ Eq (h.coeffs (Module.DualBases.lc e l)) l","decl":"@[simp]\ntheorem coeffs_lc (l : ι →₀ R) : h.coeffs (DualBases.lc e l) = l := by\n  ext i\n  rw [h.coeffs_apply, h.dual_lc]\n\n"}
{"name":"Module.DualBases.lc_coeffs","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nh : Module.DualBases e ε\nm : M\n⊢ Eq (Module.DualBases.lc e (h.coeffs m)) m","decl":"/-- For any m : M n, \\sum_{p ∈ Q n} (ε p m) • e p = m -/\n@[simp]\ntheorem lc_coeffs (m : M) : DualBases.lc e (h.coeffs m) = m := by\n  refine eq_of_sub_eq_zero <| h.total fun i ↦ ?_\n  simp [LinearMap.map_sub, h.dual_lc, sub_eq_zero]\n\n"}
{"name":"Module.DualBases.basis_repr_symm_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nh : Module.DualBases e ε\nl : Finsupp ι R\n⊢ Eq (h.basis.repr.symm l) (Module.DualBases.lc e l)","decl":"/-- `(h : DualBases e ε).basis` shows the family of vectors `e` forms a basis. -/\n@[simps repr_apply, simps (config := .lemmasOnly) repr_symm_apply]\ndef basis : Basis ι R M :=\n  Basis.ofRepr\n    { toFun := coeffs h\n      invFun := lc e\n      left_inv := lc_coeffs h\n      right_inv := coeffs_lc h\n      map_add' := fun v w => by\n        ext i\n        exact (ε i).map_add v w\n      map_smul' := fun c v => by\n        ext i\n        exact (ε i).map_smul c v }\n\n"}
{"name":"Module.DualBases.basis_repr_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nh : Module.DualBases e ε\nm : M\n⊢ Eq (h.basis.repr m) (h.coeffs m)","decl":"/-- `(h : DualBases e ε).basis` shows the family of vectors `e` forms a basis. -/\n@[simps repr_apply, simps (config := .lemmasOnly) repr_symm_apply]\ndef basis : Basis ι R M :=\n  Basis.ofRepr\n    { toFun := coeffs h\n      invFun := lc e\n      left_inv := lc_coeffs h\n      right_inv := coeffs_lc h\n      map_add' := fun v w => by\n        ext i\n        exact (ε i).map_add v w\n      map_smul' := fun c v => by\n        ext i\n        exact (ε i).map_smul c v }\n\n"}
{"name":"Module.DualBases.coe_basis","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nh : Module.DualBases e ε\n⊢ Eq (⇑h.basis) e","decl":"@[simp]\ntheorem coe_basis : ⇑h.basis = e := by\n  ext i\n  rw [Basis.apply_eq_iff]\n  ext j\n  rcases eq_or_ne i j with rfl | hne\n  · simp [h.eval_same]\n  · simp [hne, h.eval_of_ne hne.symm]\n\n"}
{"name":"Module.DualBases.mem_of_mem_span","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nh : Module.DualBases e ε\nH : Set ι\nx : M\nhmem : Membership.mem (Submodule.span R (Set.image e H)) x\ni : ι\na✝ : Ne ((ε i) x) 0\n⊢ Membership.mem H i","decl":"theorem mem_of_mem_span {H : Set ι} {x : M} (hmem : x ∈ Submodule.span R (e '' H)) :\n    ∀ i : ι, ε i x ≠ 0 → i ∈ H := by\n  intro i hi\n  rcases (Finsupp.mem_span_image_iff_linearCombination _).mp hmem with ⟨l, supp_l, rfl⟩\n  apply not_imp_comm.mp ((Finsupp.mem_supported' _ _).mp supp_l i)\n  rwa [← lc_def, h.dual_lc] at hi\n\n"}
{"name":"Module.DualBases.coe_dualBasis","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ne : ι → M\nε : ι → Module.Dual R M\nh : Module.DualBases e ε\ninst✝¹ : DecidableEq ι\ninst✝ : Finite ι\n⊢ Eq (⇑h.basis.dualBasis) ε","decl":"theorem coe_dualBasis [DecidableEq ι] [_root_.Finite ι] : ⇑h.basis.dualBasis = ε :=\n  funext fun i => h.basis.ext fun j => by simp\n\n"}
{"name":"Submodule.dualRestrict_def","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nW : Submodule R M\n⊢ Eq W.dualRestrict W.subtype.dualMap","decl":"theorem dualRestrict_def (W : Submodule R M) : W.dualRestrict = W.subtype.dualMap :=\n  rfl\n\n"}
{"name":"Submodule.dualRestrict_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nW : Submodule R M\nφ : Module.Dual R M\nx : Subtype fun x => Membership.mem W x\n⊢ Eq ((W.dualRestrict φ) x) (φ ↑x)","decl":"@[simp]\ntheorem dualRestrict_apply (W : Submodule R M) (φ : Module.Dual R M) (x : W) :\n    W.dualRestrict φ x = φ (x : M) :=\n  rfl\n\n"}
{"name":"Submodule.mem_dualAnnihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nW : Submodule R M\nφ : Module.Dual R M\n⊢ Iff (Membership.mem W.dualAnnihilator φ) (∀ (w : M), Membership.mem W w → Eq (φ w) 0)","decl":"@[simp]\ntheorem mem_dualAnnihilator (φ : Module.Dual R M) : φ ∈ W.dualAnnihilator ↔ ∀ w ∈ W, φ w = 0 := by\n  refine LinearMap.mem_ker.trans ?_\n  simp_rw [LinearMap.ext_iff, dualRestrict_apply]\n  exact ⟨fun h w hw => h ⟨w, hw⟩, fun h w => h w.1 w.2⟩\n\n"}
{"name":"Submodule.dualRestrict_ker_eq_dualAnnihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nW : Submodule R M\n⊢ Eq (LinearMap.ker W.dualRestrict) W.dualAnnihilator","decl":"/-- That $\\operatorname{ker}(\\iota^* : V^* \\to W^*) = \\operatorname{ann}(W)$.\nThis is the definition of the dual annihilator of the submodule $W$. -/\ntheorem dualRestrict_ker_eq_dualAnnihilator (W : Submodule R M) :\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629 LinearMap.ker\n    LinearMap.ker W.dualRestrict = W.dualAnnihilator :=\n  rfl\n\n"}
{"name":"Submodule.mem_dualCoannihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nΦ : Submodule R (Module.Dual R M)\nx : M\n⊢ Iff (Membership.mem Φ.dualCoannihilator x) (∀ (φ : Module.Dual R M), Membership.mem Φ φ → Eq (φ x) 0)","decl":"@[simp]\ntheorem mem_dualCoannihilator {Φ : Submodule R (Module.Dual R M)} (x : M) :\n    x ∈ Φ.dualCoannihilator ↔ ∀ φ ∈ Φ, (φ x : R) = 0 := by\n  simp_rw [dualCoannihilator, mem_comap, mem_dualAnnihilator, Module.Dual.eval_apply]\n\n"}
{"name":"Submodule.comap_dualAnnihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nΦ : Submodule R (Module.Dual R M)\n⊢ Eq (Submodule.comap (Module.Dual.eval R M) Φ.dualAnnihilator) Φ.dualCoannihilator","decl":"theorem comap_dualAnnihilator (Φ : Submodule R (Module.Dual R M)) :\n    Φ.dualAnnihilator.comap (Module.Dual.eval R M) = Φ.dualCoannihilator := rfl\n\n"}
{"name":"Submodule.map_dualCoannihilator_le","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nΦ : Submodule R (Module.Dual R M)\n⊢ LE.le (Submodule.map (Module.Dual.eval R M) Φ.dualCoannihilator) Φ.dualAnnihilator","decl":"theorem map_dualCoannihilator_le (Φ : Submodule R (Module.Dual R M)) :\n    Φ.dualCoannihilator.map (Module.Dual.eval R M) ≤ Φ.dualAnnihilator :=\n  map_le_iff_le_comap.mpr (comap_dualAnnihilator Φ).le\n\n"}
{"name":"Submodule.dualAnnihilator_gc","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ GaloisConnection (Function.comp (⇑OrderDual.toDual) Submodule.dualAnnihilator) (Function.comp Submodule.dualCoannihilator ⇑OrderDual.ofDual)","decl":"variable (R M) in\ntheorem dualAnnihilator_gc :\n    GaloisConnection\n      (OrderDual.toDual ∘ (dualAnnihilator : Submodule R M → Submodule R (Module.Dual R M)))\n      (dualCoannihilator ∘ OrderDual.ofDual) := by\n  intro a b\n  induction b using OrderDual.rec\n  simp only [Function.comp_apply, OrderDual.toDual_le_toDual, OrderDual.ofDual_toDual]\n  constructor <;>\n    · intro h x hx\n      simp only [mem_dualAnnihilator, mem_dualCoannihilator]\n      intro y hy\n      have := h hy\n      simp only [mem_dualAnnihilator, mem_dualCoannihilator] at this\n      exact this x hx\n\n"}
{"name":"Submodule.le_dualAnnihilator_iff_le_dualCoannihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU : Submodule R (Module.Dual R M)\nV : Submodule R M\n⊢ Iff (LE.le U V.dualAnnihilator) (LE.le V U.dualCoannihilator)","decl":"theorem le_dualAnnihilator_iff_le_dualCoannihilator {U : Submodule R (Module.Dual R M)}\n    {V : Submodule R M} : U ≤ V.dualAnnihilator ↔ V ≤ U.dualCoannihilator :=\n  (dualAnnihilator_gc R M).le_iff_le\n\n"}
{"name":"Submodule.dualAnnihilator_bot","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq Bot.bot.dualAnnihilator Top.top","decl":"@[simp]\ntheorem dualAnnihilator_bot : (⊥ : Submodule R M).dualAnnihilator = ⊤ :=\n  (dualAnnihilator_gc R M).l_bot\n\n"}
{"name":"Submodule.dualAnnihilator_top","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq Top.top.dualAnnihilator Bot.bot","decl":"@[simp]\ntheorem dualAnnihilator_top : (⊤ : Submodule R M).dualAnnihilator = ⊥ := by\n  rw [eq_bot_iff]\n  intro v\n  simp_rw [mem_dualAnnihilator, mem_bot, mem_top, forall_true_left]\n  exact fun h => LinearMap.ext h\n\n"}
{"name":"Submodule.dualCoannihilator_bot","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq Bot.bot.dualCoannihilator Top.top","decl":"@[simp]\ntheorem dualCoannihilator_bot : (⊥ : Submodule R (Module.Dual R M)).dualCoannihilator = ⊤ :=\n  (dualAnnihilator_gc R M).u_top\n\n"}
{"name":"Submodule.dualAnnihilator_anti","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU V : Submodule R M\nhUV : LE.le U V\n⊢ LE.le V.dualAnnihilator U.dualAnnihilator","decl":"@[mono]\ntheorem dualAnnihilator_anti {U V : Submodule R M} (hUV : U ≤ V) :\n    V.dualAnnihilator ≤ U.dualAnnihilator :=\n  (dualAnnihilator_gc R M).monotone_l hUV\n\n"}
{"name":"Submodule.dualCoannihilator_anti","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU V : Submodule R (Module.Dual R M)\nhUV : LE.le U V\n⊢ LE.le V.dualCoannihilator U.dualCoannihilator","decl":"@[mono]\ntheorem dualCoannihilator_anti {U V : Submodule R (Module.Dual R M)} (hUV : U ≤ V) :\n    V.dualCoannihilator ≤ U.dualCoannihilator :=\n  (dualAnnihilator_gc R M).monotone_u hUV\n\n"}
{"name":"Submodule.le_dualAnnihilator_dualCoannihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU : Submodule R M\n⊢ LE.le U U.dualAnnihilator.dualCoannihilator","decl":"theorem le_dualAnnihilator_dualCoannihilator (U : Submodule R M) :\n    U ≤ U.dualAnnihilator.dualCoannihilator :=\n  (dualAnnihilator_gc R M).le_u_l U\n\n"}
{"name":"Submodule.le_dualCoannihilator_dualAnnihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU : Submodule R (Module.Dual R M)\n⊢ LE.le U U.dualCoannihilator.dualAnnihilator","decl":"theorem le_dualCoannihilator_dualAnnihilator (U : Submodule R (Module.Dual R M)) :\n    U ≤ U.dualCoannihilator.dualAnnihilator :=\n  (dualAnnihilator_gc R M).l_u_le U\n\n"}
{"name":"Submodule.dualAnnihilator_dualCoannihilator_dualAnnihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU : Submodule R M\n⊢ Eq U.dualAnnihilator.dualCoannihilator.dualAnnihilator U.dualAnnihilator","decl":"theorem dualAnnihilator_dualCoannihilator_dualAnnihilator (U : Submodule R M) :\n    U.dualAnnihilator.dualCoannihilator.dualAnnihilator = U.dualAnnihilator :=\n  (dualAnnihilator_gc R M).l_u_l_eq_l U\n\n"}
{"name":"Submodule.dualCoannihilator_dualAnnihilator_dualCoannihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU : Submodule R (Module.Dual R M)\n⊢ Eq U.dualCoannihilator.dualAnnihilator.dualCoannihilator U.dualCoannihilator","decl":"theorem dualCoannihilator_dualAnnihilator_dualCoannihilator (U : Submodule R (Module.Dual R M)) :\n    U.dualCoannihilator.dualAnnihilator.dualCoannihilator = U.dualCoannihilator :=\n  (dualAnnihilator_gc R M).u_l_u_eq_u U\n\n"}
{"name":"Submodule.dualAnnihilator_sup_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU V : Submodule R M\n⊢ Eq (Max.max U V).dualAnnihilator (Min.min U.dualAnnihilator V.dualAnnihilator)","decl":"theorem dualAnnihilator_sup_eq (U V : Submodule R M) :\n    (U ⊔ V).dualAnnihilator = U.dualAnnihilator ⊓ V.dualAnnihilator :=\n  (dualAnnihilator_gc R M).l_sup\n\n"}
{"name":"Submodule.dualCoannihilator_sup_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU V : Submodule R (Module.Dual R M)\n⊢ Eq (Max.max U V).dualCoannihilator (Min.min U.dualCoannihilator V.dualCoannihilator)","decl":"theorem dualCoannihilator_sup_eq (U V : Submodule R (Module.Dual R M)) :\n    (U ⊔ V).dualCoannihilator = U.dualCoannihilator ⊓ V.dualCoannihilator :=\n  (dualAnnihilator_gc R M).u_inf\n\n"}
{"name":"Submodule.dualAnnihilator_iSup_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_1\nU : ι → Submodule R M\n⊢ Eq (iSup fun i => U i).dualAnnihilator (iInf fun i => (U i).dualAnnihilator)","decl":"theorem dualAnnihilator_iSup_eq {ι : Sort*} (U : ι → Submodule R M) :\n    (⨆ i : ι, U i).dualAnnihilator = ⨅ i : ι, (U i).dualAnnihilator :=\n  (dualAnnihilator_gc R M).l_iSup\n\n"}
{"name":"Submodule.dualCoannihilator_iSup_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_1\nU : ι → Submodule R (Module.Dual R M)\n⊢ Eq (iSup fun i => U i).dualCoannihilator (iInf fun i => (U i).dualCoannihilator)","decl":"theorem dualCoannihilator_iSup_eq {ι : Sort*} (U : ι → Submodule R (Module.Dual R M)) :\n    (⨆ i : ι, U i).dualCoannihilator = ⨅ i : ι, (U i).dualCoannihilator :=\n  (dualAnnihilator_gc R M).u_iInf\n\n"}
{"name":"Submodule.sup_dualAnnihilator_le_inf","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nU V : Submodule R M\n⊢ LE.le (Max.max U.dualAnnihilator V.dualAnnihilator) (Min.min U V).dualAnnihilator","decl":"/-- See also `Subspace.dualAnnihilator_inf_eq` for vector subspaces. -/\ntheorem sup_dualAnnihilator_le_inf (U V : Submodule R M) :\n    U.dualAnnihilator ⊔ V.dualAnnihilator ≤ (U ⊓ V).dualAnnihilator := by\n  rw [le_dualAnnihilator_iff_le_dualCoannihilator, dualCoannihilator_sup_eq]\n  apply inf_le_inf <;> exact le_dualAnnihilator_dualCoannihilator _\n\n"}
{"name":"Submodule.iSup_dualAnnihilator_le_iInf","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort u_1\nU : ι → Submodule R M\n⊢ LE.le (iSup fun i => (U i).dualAnnihilator) (iInf fun i => U i).dualAnnihilator","decl":"/-- See also `Subspace.dualAnnihilator_iInf_eq` for vector subspaces when `ι` is finite. -/\ntheorem iSup_dualAnnihilator_le_iInf {ι : Sort*} (U : ι → Submodule R M) :\n    ⨆ i : ι, (U i).dualAnnihilator ≤ (⨅ i : ι, U i).dualAnnihilator := by\n  rw [le_dualAnnihilator_iff_le_dualCoannihilator, dualCoannihilator_iSup_eq]\n  apply iInf_mono\n  exact fun i : ι => le_dualAnnihilator_dualCoannihilator (U i)\n\n"}
{"name":"Submodule.coe_dualAnnihilator_span","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (↑(Submodule.span R s).dualAnnihilator) (setOf fun f => HasSubset.Subset s ↑(LinearMap.ker f))","decl":"@[simp]\nlemma coe_dualAnnihilator_span (s : Set M) :\n    ((span R s).dualAnnihilator : Set (Module.Dual R M)) = {f | s ⊆ LinearMap.ker f} := by\n  ext f\n  simp only [SetLike.mem_coe, mem_dualAnnihilator, Set.mem_setOf_eq, ← LinearMap.mem_ker]\n  exact span_le\n\n"}
{"name":"Submodule.coe_dualCoannihilator_span","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set (Module.Dual R M)\n⊢ Eq (↑(Submodule.span R s).dualCoannihilator) (setOf fun x => ∀ (f : Module.Dual R M), Membership.mem s f → Eq (f x) 0)","decl":"@[simp]\nlemma coe_dualCoannihilator_span (s : Set (Module.Dual R M)) :\n    ((span R s).dualCoannihilator : Set M) = {x | ∀ f ∈ s, f x = 0} := by\n  ext x\n  have (φ) : x ∈ LinearMap.ker φ ↔ φ ∈ LinearMap.ker (Module.Dual.eval R M x) := by simp\n  simp only [SetLike.mem_coe, mem_dualCoannihilator, Set.mem_setOf_eq, ← LinearMap.mem_ker, this]\n  exact span_le\n\n"}
{"name":"Subspace.dualCoannihilator_top","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ Eq (Submodule.dualCoannihilator Top.top) Bot.bot","decl":"@[simp]\ntheorem dualCoannihilator_top (W : Subspace K V) :\n    (⊤ : Subspace K (Module.Dual K W)).dualCoannihilator = ⊥ := by\n  rw [dualCoannihilator, dualAnnihilator_top, comap_bot, Module.eval_ker]\n\n"}
{"name":"Subspace.dualAnnihilator_dualCoannihilator_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ Eq (Submodule.dualAnnihilator W).dualCoannihilator W","decl":"@[simp]\ntheorem dualAnnihilator_dualCoannihilator_eq {W : Subspace K V} :\n    W.dualAnnihilator.dualCoannihilator = W := by\n  refine le_antisymm (fun v ↦ Function.mtr ?_) (le_dualAnnihilator_dualCoannihilator _)\n  simp only [mem_dualAnnihilator, mem_dualCoannihilator]\n  rw [← Quotient.mk_eq_zero W, ← Module.forall_dual_apply_eq_zero_iff K]\n  push_neg\n  refine fun ⟨φ, hφ⟩ ↦ ⟨φ.comp W.mkQ, fun w hw ↦ ?_, hφ⟩\n  rw [comp_apply, mkQ_apply, (Quotient.mk_eq_zero W).mpr hw, φ.map_zero]\n\n-- exact elaborates slowly\n"}
{"name":"Subspace.forall_mem_dualAnnihilator_apply_eq_zero_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\nv : V\n⊢ Iff (∀ (φ : Module.Dual K V), Membership.mem (Submodule.dualAnnihilator W) φ → Eq (φ v) 0) (Membership.mem W v)","decl":"theorem forall_mem_dualAnnihilator_apply_eq_zero_iff (W : Subspace K V) (v : V) :\n    (∀ φ : Module.Dual K V, φ ∈ W.dualAnnihilator → φ v = 0) ↔ v ∈ W := by\n  rw [← SetLike.ext_iff.mp dualAnnihilator_dualCoannihilator_eq v, mem_dualCoannihilator]\n\n"}
{"name":"Subspace.comap_dualAnnihilator_dualAnnihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ Eq (Submodule.comap (Module.Dual.eval K V) (Submodule.dualAnnihilator W).dualAnnihilator) W","decl":"theorem comap_dualAnnihilator_dualAnnihilator (W : Subspace K V) :\n    W.dualAnnihilator.dualAnnihilator.comap (Module.Dual.eval K V) = W := by\n  ext; rw [Iff.comm, ← forall_mem_dualAnnihilator_apply_eq_zero_iff]; simp\n\n"}
{"name":"Subspace.map_le_dualAnnihilator_dualAnnihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ LE.le (Submodule.map (Module.Dual.eval K V) W) (Submodule.dualAnnihilator W).dualAnnihilator","decl":"theorem map_le_dualAnnihilator_dualAnnihilator (W : Subspace K V) :\n    W.map (Module.Dual.eval K V) ≤ W.dualAnnihilator.dualAnnihilator :=\n  map_le_iff_le_comap.mpr (comap_dualAnnihilator_dualAnnihilator W).ge\n\n"}
{"name":"Subspace.dualAnnihilator_le_dualAnnihilator_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW W' : Subspace K V\n⊢ Iff (LE.le (Submodule.dualAnnihilator W) (Submodule.dualAnnihilator W')) (LE.le W' W)","decl":"theorem dualAnnihilator_le_dualAnnihilator_iff {W W' : Subspace K V} :\n    W.dualAnnihilator ≤ W'.dualAnnihilator ↔ W' ≤ W :=\n  (dualAnnihilatorGci K V).l_le_l_iff\n\n"}
{"name":"Subspace.dualAnnihilator_inj","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW W' : Subspace K V\n⊢ Iff (Eq (Submodule.dualAnnihilator W) (Submodule.dualAnnihilator W')) (Eq W W')","decl":"theorem dualAnnihilator_inj {W W' : Subspace K V} :\n    W.dualAnnihilator = W'.dualAnnihilator ↔ W = W' :=\n  ⟨fun h ↦ (dualAnnihilatorGci K V).l_injective h, congr_arg _⟩\n\n"}
{"name":"Subspace.dualLift_of_subtype","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\nφ : Module.Dual K (Subtype fun x => Membership.mem W x)\nw : Subtype fun x => Membership.mem W x\n⊢ Eq ((W.dualLift φ) ↑w) (φ w)","decl":"@[simp]\ntheorem dualLift_of_subtype {φ : Module.Dual K W} (w : W) : W.dualLift φ (w : V) = φ w :=\n  congr_arg φ <| DFunLike.congr_fun\n    (Classical.choose_spec <| W.subtype.exists_leftInverse_of_injective W.ker_subtype) w\n\n"}
{"name":"Subspace.dualLift_of_mem","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\nφ : Module.Dual K (Subtype fun x => Membership.mem W x)\nw : V\nhw : Membership.mem W w\n⊢ Eq ((W.dualLift φ) w) (φ ⟨w, hw⟩)","decl":"theorem dualLift_of_mem {φ : Module.Dual K W} {w : V} (hw : w ∈ W) : W.dualLift φ w = φ ⟨w, hw⟩ :=\n  dualLift_of_subtype ⟨w, hw⟩\n\n"}
{"name":"Subspace.dualRestrict_comp_dualLift","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ Eq ((Submodule.dualRestrict W).comp W.dualLift) 1","decl":"@[simp]\ntheorem dualRestrict_comp_dualLift (W : Subspace K V) : W.dualRestrict.comp W.dualLift = 1 := by\n  ext φ x\n  simp\n\n"}
{"name":"Subspace.dualRestrict_leftInverse","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ Function.LeftInverse ⇑(Submodule.dualRestrict W) ⇑W.dualLift","decl":"theorem dualRestrict_leftInverse (W : Subspace K V) :\n    Function.LeftInverse W.dualRestrict W.dualLift := fun x =>\n  show W.dualRestrict.comp W.dualLift x = x by\n    rw [dualRestrict_comp_dualLift]\n    rfl\n\n"}
{"name":"Subspace.dualLift_rightInverse","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ Function.RightInverse ⇑W.dualLift ⇑(Submodule.dualRestrict W)","decl":"theorem dualLift_rightInverse (W : Subspace K V) :\n    Function.RightInverse W.dualLift W.dualRestrict :=\n  W.dualRestrict_leftInverse\n\n"}
{"name":"Subspace.dualRestrict_surjective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ Function.Surjective ⇑(Submodule.dualRestrict W)","decl":"theorem dualRestrict_surjective : Function.Surjective W.dualRestrict :=\n  W.dualLift_rightInverse.surjective\n\n"}
{"name":"Subspace.dualLift_injective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ Function.Injective ⇑W.dualLift","decl":"theorem dualLift_injective : Function.Injective W.dualLift :=\n  W.dualRestrict_leftInverse.injective\n\n"}
{"name":"Subspace.quotAnnihilatorEquiv_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\nφ : Module.Dual K V\n⊢ Eq (W.quotAnnihilatorEquiv (Submodule.Quotient.mk φ)) ((Submodule.dualRestrict W) φ)","decl":"@[simp]\ntheorem quotAnnihilatorEquiv_apply (W : Subspace K V) (φ : Module.Dual K V) :\n    W.quotAnnihilatorEquiv (Submodule.Quotient.mk φ) = W.dualRestrict φ := by\n  ext\n  rfl\n\n"}
{"name":"Subspace.dualEquivDual_def","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\n⊢ Eq (↑W.dualEquivDual) W.dualLift.rangeRestrict","decl":"theorem dualEquivDual_def (W : Subspace K V) :\n    W.dualEquivDual.toLinearMap = W.dualLift.rangeRestrict :=\n  rfl\n\n"}
{"name":"Subspace.dualEquivDual_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Subspace K V\nφ : Module.Dual K (Subtype fun x => Membership.mem W x)\n⊢ Eq (W.dualEquivDual φ) ⟨W.dualLift φ, ⋯⟩","decl":"@[simp]\ntheorem dualEquivDual_apply (φ : Module.Dual K W) :\n    W.dualEquivDual φ = ⟨W.dualLift φ, mem_range.2 ⟨φ, rfl⟩⟩ :=\n  rfl\n\n"}
{"name":"Subspace.instModuleDualFiniteDimensional","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\n⊢ FiniteDimensional K (Module.Dual K V)","decl":"instance instModuleDualFiniteDimensional [FiniteDimensional K V] :\n    FiniteDimensional K (Module.Dual K V) := by\n  infer_instance\n\n"}
{"name":"Subspace.dual_finrank_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\n⊢ Eq (Module.finrank K (Module.Dual K V)) (Module.finrank K V)","decl":"@[simp]\ntheorem dual_finrank_eq : finrank K (Module.Dual K V) = finrank K V := by\n  by_cases h : FiniteDimensional K V\n  · classical exact LinearEquiv.finrank_eq (Basis.ofVectorSpace K V).toDualEquiv.symm\n  rw [finrank_eq_zero_of_basis_imp_false, finrank_eq_zero_of_basis_imp_false]\n  · exact fun _ b ↦ h (Module.Finite.of_basis b)\n  · exact fun _ b ↦ h ((Module.finite_dual_iff K).mp <| Module.Finite.of_basis b)\n\n"}
{"name":"Subspace.dualAnnihilator_dualAnnihilator_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nW : Subspace K V\n⊢ Eq (Submodule.dualAnnihilator W).dualAnnihilator ((Module.mapEvalEquiv K V) W)","decl":"theorem dualAnnihilator_dualAnnihilator_eq (W : Subspace K V) :\n    W.dualAnnihilator.dualAnnihilator = Module.mapEvalEquiv K V W := by\n  have : _ = W := Subspace.dualAnnihilator_dualCoannihilator_eq\n  rw [dualCoannihilator, ← Module.mapEvalEquiv_symm_apply] at this\n  rwa [← OrderIso.symm_apply_eq]\n\n"}
{"name":"Subspace.finrank_add_finrank_dualAnnihilator_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nW : Subspace K V\n⊢ Eq (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem W x)) (Module.finrank K (Subtype fun x => Membership.mem (Submodule.dualAnnihilator W) x))) (Module.finrank K V)","decl":"theorem finrank_add_finrank_dualAnnihilator_eq (W : Subspace K V) :\n    finrank K W + finrank K W.dualAnnihilator = finrank K V := by\n  rw [← W.quotEquivAnnihilator.finrank_eq (M₂ := dualAnnihilator W),\n    add_comm, Submodule.finrank_quotient_add_finrank]\n\n"}
{"name":"Subspace.finrank_dualCoannihilator_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nΦ : Subspace K (Module.Dual K V)\n⊢ Eq (Module.finrank K (Subtype fun x => Membership.mem (Submodule.dualCoannihilator Φ) x)) (Module.finrank K (Subtype fun x => Membership.mem (Submodule.dualAnnihilator Φ) x))","decl":"@[simp]\ntheorem finrank_dualCoannihilator_eq {Φ : Subspace K (Module.Dual K V)} :\n    finrank K Φ.dualCoannihilator = finrank K Φ.dualAnnihilator := by\n  rw [Submodule.dualCoannihilator, ← Module.evalEquiv_toLinearMap]\n  exact LinearEquiv.finrank_eq (LinearEquiv.ofSubmodule' _ _)\n\n"}
{"name":"Subspace.finrank_add_finrank_dualCoannihilator_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u\nV : Type v\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nW : Subspace K (Module.Dual K V)\n⊢ Eq (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem W x)) (Module.finrank K (Subtype fun x => Membership.mem (Submodule.dualCoannihilator W) x))) (Module.finrank K V)","decl":"theorem finrank_add_finrank_dualCoannihilator_eq (W : Subspace K (Module.Dual K V)) :\n    finrank K W + finrank K W.dualCoannihilator = finrank K V := by\n  rw [finrank_dualCoannihilator_eq, finrank_add_finrank_dualAnnihilator_eq, dual_finrank_eq]\n\n"}
{"name":"LinearMap.ker_dualMap_eq_dualAnnihilator_range","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\ninst✝⁴ : CommSemiring R\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq (LinearMap.ker f.dualMap) (LinearMap.range f).dualAnnihilator","decl":"theorem ker_dualMap_eq_dualAnnihilator_range :\n    LinearMap.ker f.dualMap = f.range.dualAnnihilator := by\n  ext\n  simp_rw [mem_ker, LinearMap.ext_iff, Submodule.mem_dualAnnihilator,\n    ← SetLike.mem_coe, range_coe, Set.forall_mem_range]\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629 LinearMap.range\n"}
{"name":"LinearMap.range_dualMap_le_dualAnnihilator_ker","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type uR\ninst✝⁴ : CommSemiring R\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\n⊢ LE.le (LinearMap.range f.dualMap) (LinearMap.ker f).dualAnnihilator","decl":"theorem range_dualMap_le_dualAnnihilator_ker :\n    LinearMap.range f.dualMap ≤ f.ker.dualAnnihilator := by\n  rintro _ ⟨ψ, rfl⟩\n  simp_rw [Submodule.mem_dualAnnihilator, mem_ker]\n  rintro x hx\n  rw [dualMap_apply, hx, map_zero]\n\n"}
{"name":"Submodule.dualCopairing_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R M\nφ : Subtype fun x => Membership.mem W.dualAnnihilator x\nx : M\n⊢ Eq ((W.dualCopairing φ) (Submodule.Quotient.mk x)) (φ x)","decl":"@[simp]\ntheorem dualCopairing_apply {W : Submodule R M} (φ : W.dualAnnihilator) (x : M) :\n    W.dualCopairing φ (Quotient.mk x) = φ x :=\n  rfl\n\n"}
{"name":"Submodule.dualPairing_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R M\nφ : Module.Dual R M\nx : Subtype fun x => Membership.mem W x\n⊢ Eq ((W.dualPairing (Submodule.Quotient.mk φ)) x) (φ ↑x)","decl":"@[simp]\ntheorem dualPairing_apply {W : Submodule R M} (φ : Module.Dual R M) (x : W) :\n    W.dualPairing (Quotient.mk φ) x = φ x :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629 LinearMap.range\n"}
{"name":"Submodule.range_dualMap_mkQ_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R M\n⊢ Eq (LinearMap.range W.mkQ.dualMap) W.dualAnnihilator","decl":"/-- That $\\operatorname{im}(q^* : (V/W)^* \\to V^*) = \\operatorname{ann}(W)$. -/\ntheorem range_dualMap_mkQ_eq (W : Submodule R M) :\n    LinearMap.range W.mkQ.dualMap = W.dualAnnihilator := by\n  ext φ\n  rw [LinearMap.mem_range]\n  constructor\n  · rintro ⟨ψ, rfl⟩\n    have := LinearMap.mem_range_self W.mkQ.dualMap ψ\n    simpa only [ker_mkQ] using W.mkQ.range_dualMap_le_dualAnnihilator_ker this\n  · intro hφ\n    exists W.dualCopairing ⟨φ, hφ⟩\n\n"}
{"name":"Submodule.dualQuotEquivDualAnnihilator_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R M\nφ : Module.Dual R (HasQuotient.Quotient M W)\nx : M\n⊢ Eq ((W.dualQuotEquivDualAnnihilator φ) x) (φ (Submodule.Quotient.mk x))","decl":"@[simp]\ntheorem dualQuotEquivDualAnnihilator_apply (W : Submodule R M) (φ : Module.Dual R (M ⧸ W)) (x : M) :\n    dualQuotEquivDualAnnihilator W φ x = φ (Quotient.mk x) :=\n  rfl\n\n"}
{"name":"Submodule.dualCopairing_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R M\n⊢ Eq W.dualCopairing ↑W.dualQuotEquivDualAnnihilator.symm","decl":"theorem dualCopairing_eq (W : Submodule R M) :\n    W.dualCopairing = (dualQuotEquivDualAnnihilator W).symm.toLinearMap :=\n  rfl\n\n"}
{"name":"Submodule.dualQuotEquivDualAnnihilator_symm_apply_mk","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R M\nφ : Subtype fun x => Membership.mem W.dualAnnihilator x\nx : M\n⊢ Eq ((W.dualQuotEquivDualAnnihilator.symm φ) (Submodule.Quotient.mk x)) (φ x)","decl":"@[simp]\ntheorem dualQuotEquivDualAnnihilator_symm_apply_mk (W : Submodule R M) (φ : W.dualAnnihilator)\n    (x : M) : (dualQuotEquivDualAnnihilator W).symm φ (Quotient.mk x) = φ x :=\n  rfl\n\n"}
{"name":"Submodule.finite_dualAnnihilator_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nW : Submodule R M\ninst✝ : Module.Free R (HasQuotient.Quotient M W)\n⊢ Iff (Module.Finite R (Subtype fun x => Membership.mem W.dualAnnihilator x)) (Module.Finite R (HasQuotient.Quotient M W))","decl":"theorem finite_dualAnnihilator_iff {W : Submodule R M} [Free R (M ⧸ W)] :\n    Module.Finite R W.dualAnnihilator ↔ Module.Finite R (M ⧸ W) :=\n  (Finite.equiv_iff W.dualQuotEquivDualAnnihilator.symm).trans (finite_dual_iff R)\n\n"}
{"name":"Submodule.quotDualCoannihilatorToDual_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R (Module.Dual R M)\nm : M\nw : Subtype fun x => Membership.mem W x\n⊢ Eq ((W.quotDualCoannihilatorToDual (Submodule.Quotient.mk m)) w) (↑w m)","decl":"@[simp]\ntheorem quotDualCoannihilatorToDual_apply (W : Submodule R (Dual R M)) (m : M) (w : W) :\n    W.quotDualCoannihilatorToDual (Quotient.mk m) w = w.1 m := rfl\n\n"}
{"name":"Submodule.quotDualCoannihilatorToDual_injective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R (Module.Dual R M)\n⊢ Function.Injective ⇑W.quotDualCoannihilatorToDual","decl":"theorem quotDualCoannihilatorToDual_injective (W : Submodule R (Dual R M)) :\n    Function.Injective W.quotDualCoannihilatorToDual :=\n  LinearMap.ker_eq_bot.mp (ker_liftQ_eq_bot _ _ _ le_rfl)\n\n"}
{"name":"Submodule.flip_quotDualCoannihilatorToDual_injective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R (Module.Dual R M)\n⊢ Function.Injective ⇑W.quotDualCoannihilatorToDual.flip","decl":"theorem flip_quotDualCoannihilatorToDual_injective (W : Submodule R (Dual R M)) :\n    Function.Injective W.quotDualCoannihilatorToDual.flip :=\n  fun _ _ he ↦ Subtype.ext <| LinearMap.ext fun m ↦ DFunLike.congr_fun he ⟦m⟧\n\n"}
{"name":"Submodule.quotDualCoannihilatorToDual_nondegenerate","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nW : Submodule R (Module.Dual R M)\n⊢ W.quotDualCoannihilatorToDual.Nondegenerate","decl":"open LinearMap in\ntheorem quotDualCoannihilatorToDual_nondegenerate (W : Submodule R (Dual R M)) :\n    W.quotDualCoannihilatorToDual.Nondegenerate := by\n  rw [Nondegenerate, separatingLeft_iff_ker_eq_bot, separatingRight_iff_flip_ker_eq_bot]\n  letI : AddCommGroup W := inferInstance\n  simp_rw [ker_eq_bot]\n  exact ⟨W.quotDualCoannihilatorToDual_injective, W.flip_quotDualCoannihilatorToDual_injective⟩\n\n"}
{"name":"LinearMap.range_dualMap_eq_dualAnnihilator_ker_of_surjective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhf : Function.Surjective ⇑f\n⊢ Eq (LinearMap.range f.dualMap) (LinearMap.ker f).dualAnnihilator","decl":"theorem range_dualMap_eq_dualAnnihilator_ker_of_surjective (f : M →ₗ[R] M')\n    (hf : Function.Surjective f) : LinearMap.range f.dualMap = f.ker.dualAnnihilator :=\n  ((f.quotKerEquivOfSurjective hf).dualMap.range_comp _).trans f.ker.range_dualMap_mkQ_eq\n\n-- Note, this can be specialized to the case where `R` is an injective `R`-module, or when\n-- `f.coker` is a projective `R`-module.\n"}
{"name":"LinearMap.range_dualMap_eq_dualAnnihilator_ker_of_subtype_range_surjective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhf : Function.Surjective ⇑(LinearMap.range f).subtype.dualMap\n⊢ Eq (LinearMap.range f.dualMap) (LinearMap.ker f).dualAnnihilator","decl":"theorem range_dualMap_eq_dualAnnihilator_ker_of_subtype_range_surjective (f : M →ₗ[R] M')\n    (hf : Function.Surjective f.range.subtype.dualMap) :\n    LinearMap.range f.dualMap = f.ker.dualAnnihilator := by\n  have rr_surj : Function.Surjective f.rangeRestrict := by\n    rw [← range_eq_top, range_rangeRestrict]\n  have := range_dualMap_eq_dualAnnihilator_ker_of_surjective f.rangeRestrict rr_surj\n  convert this using 1\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629\n  · calc\n      _ = range ((range f).subtype.comp f.rangeRestrict).dualMap := by simp\n      _ = _ := ?_\n    rw [← dualMap_comp_dualMap, range_comp_of_range_eq_top]\n    rwa [range_eq_top]\n  · apply congr_arg\n    exact (ker_rangeRestrict f).symm\n\n"}
{"name":"LinearMap.ker_dualMap_eq_dualCoannihilator_range","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\n⊢ Eq (LinearMap.ker f.dualMap) (LinearMap.range ((Module.Dual.eval R M').comp f)).dualCoannihilator","decl":"theorem ker_dualMap_eq_dualCoannihilator_range (f : M →ₗ[R] M') :\n    LinearMap.ker f.dualMap = (Dual.eval R M' ∘ₗ f).range.dualCoannihilator := by\n  ext x; simp [LinearMap.ext_iff (f := dualMap f x)]\n\n"}
{"name":"LinearMap.dualCoannihilator_range_eq_ker_flip","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M' R)\n⊢ Eq (LinearMap.range B).dualCoannihilator (LinearMap.ker B.flip)","decl":"@[simp]\nlemma dualCoannihilator_range_eq_ker_flip (B : M →ₗ[R] M' →ₗ[R] R) :\n    (range B).dualCoannihilator = LinearMap.ker B.flip := by\n  ext x; simp [LinearMap.ext_iff (f := B.flip x)]\n\n"}
{"name":"Module.Dual.range_eq_top_of_ne_zero","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝² : Field K\nV₁ : Type uV₁\ninst✝¹ : AddCommGroup V₁\ninst✝ : Module K V₁\nf : Module.Dual K V₁\nhf : Ne f 0\n⊢ Eq (LinearMap.range f) Top.top","decl":"lemma range_eq_top_of_ne_zero :\n    LinearMap.range f = ⊤ := by\n  obtain ⟨v, hv⟩ : ∃ v, f v ≠ 0 := by contrapose! hf; ext v; simpa using hf v\n  rw [eq_top_iff]\n  exact fun x _ ↦ ⟨x • (f v)⁻¹ • v, by simp [inv_mul_cancel₀ hv]⟩\n\n"}
{"name":"Module.Dual.finrank_ker_add_one_of_ne_zero","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝³ : Field K\nV₁ : Type uV₁\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module K V₁\nf : Module.Dual K V₁\nhf : Ne f 0\ninst✝ : FiniteDimensional K V₁\n⊢ Eq (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem (LinearMap.ker f) x)) 1) (Module.finrank K V₁)","decl":"lemma finrank_ker_add_one_of_ne_zero :\n    finrank K (LinearMap.ker f) + 1 = finrank K V₁ := by\n  suffices finrank K (LinearMap.range f) = 1 by\n    rw [← (LinearMap.ker f).finrank_quotient_add_finrank, add_comm, add_left_inj,\n    f.quotKerEquivRange.finrank_eq, this]\n  rw [range_eq_top_of_ne_zero hf, finrank_top, finrank_self]\n\n"}
{"name":"Module.Dual.isCompl_ker_of_disjoint_of_ne_bot","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝³ : Field K\nV₁ : Type uV₁\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module K V₁\nf : Module.Dual K V₁\nhf : Ne f 0\ninst✝ : FiniteDimensional K V₁\np : Submodule K V₁\nhpf : Disjoint (LinearMap.ker f) p\nhp : Ne p Bot.bot\n⊢ IsCompl (LinearMap.ker f) p","decl":"lemma isCompl_ker_of_disjoint_of_ne_bot {p : Submodule K V₁}\n    (hpf : Disjoint (LinearMap.ker f) p) (hp : p ≠ ⊥) :\n    IsCompl (LinearMap.ker f) p := by\n  refine ⟨hpf, codisjoint_iff.mpr <| eq_of_le_of_finrank_le le_top ?_⟩\n  have : finrank K ↑(LinearMap.ker f ⊔ p) = finrank K (LinearMap.ker f) + finrank K p := by\n    simp [← Submodule.finrank_sup_add_finrank_inf_eq (LinearMap.ker f) p, hpf.eq_bot]\n  rwa [finrank_top, this, ← finrank_ker_add_one_of_ne_zero hf, add_le_add_iff_left,\n    Submodule.one_le_finrank_iff]\n\n"}
{"name":"Module.Dual.eq_of_ker_eq_of_apply_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝³ : Field K\nV₁ : Type uV₁\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module K V₁\ninst✝ : FiniteDimensional K V₁\nf g : Module.Dual K V₁\nx : V₁\nh : Eq (LinearMap.ker f) (LinearMap.ker g)\nh' : Eq (f x) (g x)\nhx : Ne (f x) 0\n⊢ Eq f g","decl":"lemma eq_of_ker_eq_of_apply_eq [FiniteDimensional K V₁] {f g : Module.Dual K V₁} (x : V₁)\n    (h : LinearMap.ker f = LinearMap.ker g) (h' : f x = g x) (hx : f x ≠ 0) :\n    f = g := by\n  let p := K ∙ x\n  have hp : p ≠ ⊥ := by aesop\n  have hpf : Disjoint (LinearMap.ker f) p := by\n    rw [disjoint_iff, Submodule.eq_bot_iff]\n    rintro y ⟨hfy : f y = 0, hpy : y ∈ p⟩\n    obtain ⟨t, rfl⟩ := Submodule.mem_span_singleton.mp hpy\n    have ht : t = 0 := by simpa [hx] using hfy\n    simp [ht]\n  have hf : f ≠ 0 := by aesop\n  ext v\n  obtain ⟨y, hy, z, hz, rfl⟩ : ∃ᵉ (y ∈ LinearMap.ker f) (z ∈ p), y + z = v := by\n    have : v ∈ (⊤ : Submodule K V₁) := Submodule.mem_top\n    rwa [← (isCompl_ker_of_disjoint_of_ne_bot hf hpf hp).sup_eq_top, Submodule.mem_sup] at this\n  have hy' : g y = 0 := by rwa [← LinearMap.mem_ker, ← h]\n  replace hy : f y = 0 := by rwa [LinearMap.mem_ker] at hy\n  obtain ⟨t, rfl⟩ := Submodule.mem_span_singleton.mp hz\n  simp [h', hy, hy']\n\n"}
{"name":"LinearMap.dualPairing_nondegenerate","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝² : Field K\nV₁ : Type uV₁\ninst✝¹ : AddCommGroup V₁\ninst✝ : Module K V₁\n⊢ (Module.dualPairing K V₁).Nondegenerate","decl":"theorem dualPairing_nondegenerate : (dualPairing K V₁).Nondegenerate :=\n  ⟨separatingLeft_iff_ker_eq_bot.mpr ker_id, fun x => (forall_dual_apply_eq_zero_iff K x).mp⟩\n\n"}
{"name":"LinearMap.dualMap_surjective_of_injective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁴ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝³ : AddCommGroup V₁\ninst✝² : Module K V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V₁ V₂\nhf : Function.Injective ⇑f\n⊢ Function.Surjective ⇑f.dualMap","decl":"theorem dualMap_surjective_of_injective {f : V₁ →ₗ[K] V₂} (hf : Function.Injective f) :\n    Function.Surjective f.dualMap := fun φ ↦\n  have ⟨f', hf'⟩ := f.exists_leftInverse_of_injective (ker_eq_bot.mpr hf)\n  ⟨φ.comp f', ext fun x ↦ congr(φ <| $hf' x)⟩\n\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629 LinearMap.range\n"}
{"name":"LinearMap.range_dualMap_eq_dualAnnihilator_ker","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁴ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝³ : AddCommGroup V₁\ninst✝² : Module K V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V₁ V₂\n⊢ Eq (LinearMap.range f.dualMap) (LinearMap.ker f).dualAnnihilator","decl":"theorem range_dualMap_eq_dualAnnihilator_ker (f : V₁ →ₗ[K] V₂) :\n    LinearMap.range f.dualMap = f.ker.dualAnnihilator :=\n  range_dualMap_eq_dualAnnihilator_ker_of_subtype_range_surjective f <|\n    dualMap_surjective_of_injective (range f).injective_subtype\n\n"}
{"name":"LinearMap.dualMap_surjective_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁴ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝³ : AddCommGroup V₁\ninst✝² : Module K V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V₁ V₂\n⊢ Iff (Function.Surjective ⇑f.dualMap) (Function.Injective ⇑f)","decl":"/-- For vector spaces, `f.dualMap` is surjective if and only if `f` is injective -/\n@[simp]\ntheorem dualMap_surjective_iff {f : V₁ →ₗ[K] V₂} :\n    Function.Surjective f.dualMap ↔ Function.Injective f := by\n  rw [← LinearMap.range_eq_top, range_dualMap_eq_dualAnnihilator_ker,\n      ← Submodule.dualAnnihilator_bot, Subspace.dualAnnihilator_inj, LinearMap.ker_eq_bot]\n\n"}
{"name":"Subspace.dualPairing_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝² : Field K\nV₁ : Type uV₁\ninst✝¹ : AddCommGroup V₁\ninst✝ : Module K V₁\nW : Subspace K V₁\n⊢ Eq (Submodule.dualPairing W) ↑W.quotAnnihilatorEquiv","decl":"theorem dualPairing_eq (W : Subspace K V₁) :\n    W.dualPairing = W.quotAnnihilatorEquiv.toLinearMap := by\n  ext\n  rfl\n\n"}
{"name":"Subspace.dualPairing_nondegenerate","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝² : Field K\nV₁ : Type uV₁\ninst✝¹ : AddCommGroup V₁\ninst✝ : Module K V₁\nW : Subspace K V₁\n⊢ (Submodule.dualPairing W).Nondegenerate","decl":"theorem dualPairing_nondegenerate (W : Subspace K V₁) : W.dualPairing.Nondegenerate := by\n  constructor\n  · rw [LinearMap.separatingLeft_iff_ker_eq_bot, dualPairing_eq]\n    apply LinearEquiv.ker\n  · intro x h\n    rw [← forall_dual_apply_eq_zero_iff K x]\n    intro φ\n    simpa only [Submodule.dualPairing_apply, dualLift_of_subtype] using\n      h (Submodule.Quotient.mk (W.dualLift φ))\n\n"}
{"name":"Subspace.dualCopairing_nondegenerate","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝² : Field K\nV₁ : Type uV₁\ninst✝¹ : AddCommGroup V₁\ninst✝ : Module K V₁\nW : Subspace K V₁\n⊢ (Submodule.dualCopairing W).Nondegenerate","decl":"theorem dualCopairing_nondegenerate (W : Subspace K V₁) : W.dualCopairing.Nondegenerate := by\n  constructor\n  · rw [LinearMap.separatingLeft_iff_ker_eq_bot, dualCopairing_eq]\n    apply LinearEquiv.ker\n  · rintro ⟨x⟩\n    simp only [Quotient.quot_mk_eq_mk, dualCopairing_apply, Quotient.mk_eq_zero]\n    rw [← forall_mem_dualAnnihilator_apply_eq_zero_iff, SetLike.forall]\n    exact id\n\n-- Argument from https://math.stackexchange.com/a/2423263/172988\n"}
{"name":"Subspace.dualAnnihilator_inf_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝² : Field K\nV₁ : Type uV₁\ninst✝¹ : AddCommGroup V₁\ninst✝ : Module K V₁\nW W' : Subspace K V₁\n⊢ Eq (Submodule.dualAnnihilator (Min.min W W')) (Max.max (Submodule.dualAnnihilator W) (Submodule.dualAnnihilator W'))","decl":"theorem dualAnnihilator_inf_eq (W W' : Subspace K V₁) :\n    (W ⊓ W').dualAnnihilator = W.dualAnnihilator ⊔ W'.dualAnnihilator := by\n  refine le_antisymm ?_ (sup_dualAnnihilator_le_inf W W')\n  let F : V₁ →ₗ[K] (V₁ ⧸ W) × V₁ ⧸ W' := (Submodule.mkQ W).prod (Submodule.mkQ W')\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629 LinearMap.ker\n  have : LinearMap.ker F = W ⊓ W' := by simp only [F, LinearMap.ker_prod, ker_mkQ]\n  rw [← this, ← LinearMap.range_dualMap_eq_dualAnnihilator_ker]\n  intro φ\n  rw [LinearMap.mem_range]\n  rintro ⟨x, rfl⟩\n  rw [Submodule.mem_sup]\n  obtain ⟨⟨a, b⟩, rfl⟩ := (dualProdDualEquivDual K (V₁ ⧸ W) (V₁ ⧸ W')).surjective x\n  obtain ⟨a', rfl⟩ := (dualQuotEquivDualAnnihilator W).symm.surjective a\n  obtain ⟨b', rfl⟩ := (dualQuotEquivDualAnnihilator W').symm.surjective b\n  use a', a'.property, b', b'.property\n  rfl\n\n-- This is also true if `V₁` is finite dimensional since one can restrict `ι` to some subtype\n-- for which the infi and supr are the same.\n-- The obstruction to the `dualAnnihilator_inf_eq` argument carrying through is that we need\n-- for `Module.Dual R (Π (i : ι), V ⧸ W i) ≃ₗ[K] Π (i : ι), Module.Dual R (V ⧸ W i)`, which is not\n-- true for infinite `ι`. One would need to add additional hypothesis on `W` (for example, it might\n-- be true when the family is inf-closed).\n-- TODO: generalize to `Sort`\n"}
{"name":"Subspace.dualAnnihilator_iInf_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝³ : Field K\nV₁ : Type uV₁\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module K V₁\nι : Type u_1\ninst✝ : Finite ι\nW : ι → Subspace K V₁\n⊢ Eq (Submodule.dualAnnihilator (iInf fun i => W i)) (iSup fun i => Submodule.dualAnnihilator (W i))","decl":"theorem dualAnnihilator_iInf_eq {ι : Type*} [Finite ι] (W : ι → Subspace K V₁) :\n    (⨅ i : ι, W i).dualAnnihilator = ⨆ i : ι, (W i).dualAnnihilator := by\n  revert ι\n  apply Finite.induction_empty_option\n  · intro α β h hyp W\n    rw [← h.iInf_comp, hyp _, ← h.iSup_comp]\n  · intro W\n    rw [iSup_of_empty', iInf_of_isEmpty, sInf_empty, sSup_empty, dualAnnihilator_top]\n  · intro α _ h W\n    rw [iInf_option, iSup_option, dualAnnihilator_inf_eq, h]\n\n"}
{"name":"Subspace.isCompl_dualAnnihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝² : Field K\nV₁ : Type uV₁\ninst✝¹ : AddCommGroup V₁\ninst✝ : Module K V₁\nW W' : Subspace K V₁\nh : IsCompl W W'\n⊢ IsCompl (Submodule.dualAnnihilator W) (Submodule.dualAnnihilator W')","decl":"/-- For vector spaces, dual annihilators carry direct sum decompositions\nto direct sum decompositions. -/\ntheorem isCompl_dualAnnihilator {W W' : Subspace K V₁} (h : IsCompl W W') :\n    IsCompl W.dualAnnihilator W'.dualAnnihilator := by\n  rw [isCompl_iff, disjoint_iff, codisjoint_iff] at h ⊢\n  rw [← dualAnnihilator_inf_eq, ← dualAnnihilator_sup_eq, h.1, h.2, dualAnnihilator_top,\n    dualAnnihilator_bot]\n  exact ⟨rfl, rfl⟩\n\n"}
{"name":"LinearMap.finrank_range_dualMap_eq_finrank_range","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁴ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝³ : AddCommGroup V₁\ninst✝² : Module K V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V₁ V₂\n⊢ Eq (Module.finrank K (Subtype fun x => Membership.mem (LinearMap.range f.dualMap) x)) (Module.finrank K (Subtype fun x => Membership.mem (LinearMap.range f) x))","decl":"@[simp]\ntheorem finrank_range_dualMap_eq_finrank_range (f : V₁ →ₗ[K] V₂) :\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): broken dot notation https://github.com/leanprover/lean4/issues/1629\n    finrank K (LinearMap.range f.dualMap) = finrank K (LinearMap.range f) := by\n  rw [congr_arg dualMap (show f = (range f).subtype.comp f.rangeRestrict by rfl),\n    ← dualMap_comp_dualMap, range_comp,\n    range_eq_top.mpr (dualMap_surjective_of_injective (range f).injective_subtype),\n    Submodule.map_top, finrank_range_of_inj, Subspace.dual_finrank_eq]\n  exact dualMap_injective_of_surjective (range_eq_top.mp f.range_rangeRestrict)\n\n"}
{"name":"LinearMap.dualMap_injective_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁴ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝³ : AddCommGroup V₁\ninst✝² : Module K V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V₁ V₂\n⊢ Iff (Function.Injective ⇑f.dualMap) (Function.Surjective ⇑f)","decl":"/-- `f.dualMap` is injective if and only if `f` is surjective -/\n@[simp]\ntheorem dualMap_injective_iff {f : V₁ →ₗ[K] V₂} :\n    Function.Injective f.dualMap ↔ Function.Surjective f := by\n  refine ⟨Function.mtr fun not_surj inj ↦ ?_, dualMap_injective_of_surjective⟩\n  rw [← range_eq_top, ← Ne, ← lt_top_iff_ne_top] at not_surj\n  obtain ⟨φ, φ0, range_le_ker⟩ := (range f).exists_le_ker_of_lt_top not_surj\n  exact φ0 (inj <| ext fun x ↦ range_le_ker ⟨x, rfl⟩)\n\n"}
{"name":"LinearMap.dualMap_bijective_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁴ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝³ : AddCommGroup V₁\ninst✝² : Module K V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V₁ V₂\n⊢ Iff (Function.Bijective ⇑f.dualMap) (Function.Bijective ⇑f)","decl":"/-- `f.dualMap` is bijective if and only if `f` is -/\n@[simp]\ntheorem dualMap_bijective_iff {f : V₁ →ₗ[K] V₂} :\n    Function.Bijective f.dualMap ↔ Function.Bijective f := by\n  simp_rw [Function.Bijective, dualMap_surjective_iff, dualMap_injective_iff, and_comm]\n\n"}
{"name":"LinearMap.dualAnnihilator_ker_eq_range_flip","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁵ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module K V₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nB : LinearMap (RingHom.id K) V₁ (LinearMap (RingHom.id K) V₂ K)\ninst✝ : Module.IsReflexive K V₂\n⊢ Eq (LinearMap.ker B).dualAnnihilator (LinearMap.range B.flip)","decl":"@[simp]\nlemma dualAnnihilator_ker_eq_range_flip [IsReflexive K V₂] :\n    (ker B).dualAnnihilator = range B.flip := by\n  change _ = range (B.dualMap.comp (Module.evalEquiv K V₂).toLinearMap)\n  rw [← range_dualMap_eq_dualAnnihilator_ker, range_comp_of_range_eq_top _ (LinearEquiv.range _)]\n\n"}
{"name":"LinearMap.flip_injective_iff₁","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁵ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module K V₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nB : LinearMap (RingHom.id K) V₁ (LinearMap (RingHom.id K) V₂ K)\ninst✝ : FiniteDimensional K V₁\n⊢ Iff (Function.Injective ⇑B.flip) (Function.Surjective ⇑B)","decl":"theorem flip_injective_iff₁ [FiniteDimensional K V₁] : Injective B.flip ↔ Surjective B := by\n  rw [← dualMap_surjective_iff, ← (evalEquiv K V₁).toEquiv.surjective_comp]; rfl\n\n"}
{"name":"LinearMap.flip_injective_iff₂","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁵ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module K V₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nB : LinearMap (RingHom.id K) V₁ (LinearMap (RingHom.id K) V₂ K)\ninst✝ : FiniteDimensional K V₂\n⊢ Iff (Function.Injective ⇑B.flip) (Function.Surjective ⇑B)","decl":"theorem flip_injective_iff₂ [FiniteDimensional K V₂] : Injective B.flip ↔ Surjective B := by\n  rw [← dualMap_injective_iff]; exact (evalEquiv K V₂).toEquiv.injective_comp B.dualMap\n\n"}
{"name":"LinearMap.flip_surjective_iff₁","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁵ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module K V₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nB : LinearMap (RingHom.id K) V₁ (LinearMap (RingHom.id K) V₂ K)\ninst✝ : FiniteDimensional K V₁\n⊢ Iff (Function.Surjective ⇑B.flip) (Function.Injective ⇑B)","decl":"theorem flip_surjective_iff₁ [FiniteDimensional K V₁] : Surjective B.flip ↔ Injective B :=\n  flip_injective_iff₂.symm\n\n"}
{"name":"LinearMap.flip_surjective_iff₂","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁵ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module K V₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nB : LinearMap (RingHom.id K) V₁ (LinearMap (RingHom.id K) V₂ K)\ninst✝ : FiniteDimensional K V₂\n⊢ Iff (Function.Surjective ⇑B.flip) (Function.Injective ⇑B)","decl":"theorem flip_surjective_iff₂ [FiniteDimensional K V₂] : Surjective B.flip ↔ Injective B :=\n  flip_injective_iff₁.symm\n\n"}
{"name":"LinearMap.flip_bijective_iff₁","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁵ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module K V₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nB : LinearMap (RingHom.id K) V₁ (LinearMap (RingHom.id K) V₂ K)\ninst✝ : FiniteDimensional K V₁\n⊢ Iff (Function.Bijective ⇑B.flip) (Function.Bijective ⇑B)","decl":"theorem flip_bijective_iff₁ [FiniteDimensional K V₁] : Bijective B.flip ↔ Bijective B := by\n  simp_rw [Bijective, flip_injective_iff₁, flip_surjective_iff₁, and_comm]\n\n"}
{"name":"LinearMap.flip_bijective_iff₂","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type uK\ninst✝⁵ : Field K\nV₁ : Type uV₁\nV₂ : Type uV₂\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module K V₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nB : LinearMap (RingHom.id K) V₁ (LinearMap (RingHom.id K) V₂ K)\ninst✝ : FiniteDimensional K V₂\n⊢ Iff (Function.Bijective ⇑B.flip) (Function.Bijective ⇑B)","decl":"theorem flip_bijective_iff₂ [FiniteDimensional K V₂] : Bijective B.flip ↔ Bijective B :=\n  flip_bijective_iff₁.symm\n\n"}
{"name":"Subspace.quotDualCoannihilatorToDual_bijective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nW : Subspace K (Module.Dual K V)\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem W x)\n⊢ Function.Bijective ⇑(Submodule.quotDualCoannihilatorToDual W)","decl":"theorem quotDualCoannihilatorToDual_bijective (W : Subspace K (Dual K V)) [FiniteDimensional K W] :\n    Function.Bijective W.quotDualCoannihilatorToDual :=\n  ⟨W.quotDualCoannihilatorToDual_injective, letI : AddCommGroup W := inferInstance\n    flip_injective_iff₂.mp W.flip_quotDualCoannihilatorToDual_injective⟩\n\n"}
{"name":"Subspace.flip_quotDualCoannihilatorToDual_bijective","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nW : Subspace K (Module.Dual K V)\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem W x)\n⊢ Function.Bijective ⇑(Submodule.quotDualCoannihilatorToDual W).flip","decl":"theorem flip_quotDualCoannihilatorToDual_bijective (W : Subspace K (Dual K V))\n    [FiniteDimensional K W] : Function.Bijective W.quotDualCoannihilatorToDual.flip :=\n  letI : AddCommGroup W := inferInstance\n  flip_bijective_iff₂.mpr W.quotDualCoannihilatorToDual_bijective\n\n"}
{"name":"Subspace.dualCoannihilator_dualAnnihilator_eq","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nW : Subspace K (Module.Dual K V)\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem W x)\n⊢ Eq (Submodule.dualCoannihilator W).dualAnnihilator W","decl":"theorem dualCoannihilator_dualAnnihilator_eq {W : Subspace K (Dual K V)} [FiniteDimensional K W] :\n    W.dualCoannihilator.dualAnnihilator = W :=\n  let e := (LinearEquiv.ofBijective _ W.flip_quotDualCoannihilatorToDual_bijective).trans\n    (Submodule.dualQuotEquivDualAnnihilator _)\n  letI : AddCommGroup W := inferInstance\n  haveI : FiniteDimensional K W.dualCoannihilator.dualAnnihilator := LinearEquiv.finiteDimensional e\n  (eq_of_le_of_finrank_eq W.le_dualCoannihilator_dualAnnihilator e.finrank_eq).symm\n\n"}
{"name":"Subspace.finiteDimensional_quot_dualCoannihilator_iff","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nW : Submodule K (Module.Dual K V)\n⊢ Iff (FiniteDimensional K (HasQuotient.Quotient V W.dualCoannihilator)) (FiniteDimensional K (Subtype fun x => Membership.mem W x))","decl":"theorem finiteDimensional_quot_dualCoannihilator_iff {W : Submodule K (Dual K V)} :\n    FiniteDimensional K (V ⧸ W.dualCoannihilator) ↔ FiniteDimensional K W :=\n  ⟨fun _ ↦ FiniteDimensional.of_injective _ W.flip_quotDualCoannihilatorToDual_injective,\n    fun _ ↦ by\n      #adaptation_note /-- https://github.com/leanprover/lean4/pull/4119\n      the `Free K W` instance isn't found unless we use `set_option maxSynthPendingDepth 2`, or add\n      explicit instances:\n      ```\n      have := Free.of_divisionRing K ↥W\n      have := Basis.dual_finite (R := K) (M := W)\n      ```\n      -/\n      set_option maxSynthPendingDepth 2 in\n      exact FiniteDimensional.of_injective _ W.quotDualCoannihilatorToDual_injective⟩\n\n"}
{"name":"Subspace.dualAnnihilator_dualAnnihilator_eq_map","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nW : Subspace K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem W x)\n⊢ Eq (Submodule.dualAnnihilator W).dualAnnihilator (Submodule.map (Module.Dual.eval K V) W)","decl":"open Submodule in\ntheorem dualAnnihilator_dualAnnihilator_eq_map (W : Subspace K V) [FiniteDimensional K W] :\n    W.dualAnnihilator.dualAnnihilator = W.map (Dual.eval K V) := by\n  let e1 := (Free.chooseBasis K W).toDualEquiv ≪≫ₗ W.quotAnnihilatorEquiv.symm\n  haveI := e1.finiteDimensional\n  let e2 := (Free.chooseBasis K _).toDualEquiv ≪≫ₗ W.dualAnnihilator.dualQuotEquivDualAnnihilator\n  haveI := LinearEquiv.finiteDimensional (V₂ := W.dualAnnihilator.dualAnnihilator) e2\n  rw [eq_of_le_of_finrank_eq (map_le_dualAnnihilator_dualAnnihilator W)]\n  rw [← (equivMapOfInjective _ (eval_apply_injective K (V := V)) W).finrank_eq, e1.finrank_eq]\n  exact e2.finrank_eq\n\n"}
{"name":"Subspace.map_dualCoannihilator","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nW : Subspace K (Module.Dual K V)\ninst✝ : FiniteDimensional K V\n⊢ Eq (Submodule.map (Module.Dual.eval K V) (Submodule.dualCoannihilator W)) (Submodule.dualAnnihilator W)","decl":"theorem map_dualCoannihilator (W : Subspace K (Dual K V)) [FiniteDimensional K V] :\n    W.dualCoannihilator.map (Dual.eval K V) = W.dualAnnihilator := by\n  rw [← dualAnnihilator_dualAnnihilator_eq_map, dualCoannihilator_dualAnnihilator_eq]\n\n"}
{"name":"TensorProduct.dualDistrib_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : Module.Dual R M\ng : Module.Dual R N\nm : M\nn : N\n⊢ Eq (((TensorProduct.dualDistrib R M N) (TensorProduct.tmul R f g)) (TensorProduct.tmul R m n)) (HMul.hMul (f m) (g n))","decl":"@[simp]\ntheorem dualDistrib_apply (f : Dual R M) (g : Dual R N) (m : M) (n : N) :\n    dualDistrib R M N (f ⊗ₜ g) (m ⊗ₜ n) = f m * g n :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.dualDistrib_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module A M\ninst✝¹ : Module R N\ninst✝ : IsScalarTower R A M\nf : Module.Dual A M\ng : Module.Dual R N\nm : M\nn : N\n⊢ Eq (((TensorProduct.AlgebraTensorModule.dualDistrib R A M N) (TensorProduct.tmul R f g)) (TensorProduct.tmul R m n)) (HSMul.hSMul (g n) (f m))","decl":"@[simp]\ntheorem dualDistrib_apply (f : Dual A M) (g : Dual R N) (m : M) (n : N) :\n    dualDistrib R A M N (f ⊗ₜ g) (m ⊗ₜ n) = g n • f m :=\n  rfl\n\n"}
{"name":"TensorProduct.dualDistribInvOfBasis_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\nκ : Type u_6\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : DecidableEq κ\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype κ\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nb : Basis ι R M\nc : Basis κ R N\nf : Module.Dual R (TensorProduct R M N)\n⊢ Eq ((TensorProduct.dualDistribInvOfBasis b c) f) (Finset.univ.sum fun i => Finset.univ.sum fun j => HSMul.hSMul (f (TensorProduct.tmul R (b i) (c j))) (TensorProduct.tmul R (b.dualBasis i) (c.dualBasis j)))","decl":"@[simp]\ntheorem dualDistribInvOfBasis_apply (b : Basis ι R M) (c : Basis κ R N) (f : Dual R (M ⊗[R] N)) :\n    dualDistribInvOfBasis b c f = ∑ i, ∑ j, f (b i ⊗ₜ c j) • b.dualBasis i ⊗ₜ c.dualBasis j := by\n  simp [dualDistribInvOfBasis]\n\n-- Porting note: introduced to help with timeout in dualDistribEquivOfBasis\n"}
{"name":"TensorProduct.dualDistrib_dualDistribInvOfBasis_left_inverse","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\nκ : Type u_6\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : DecidableEq κ\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype κ\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nb : Basis ι R M\nc : Basis κ R N\n⊢ Eq ((TensorProduct.dualDistrib R M N).comp (TensorProduct.dualDistribInvOfBasis b c)) LinearMap.id","decl":"theorem dualDistrib_dualDistribInvOfBasis_left_inverse (b : Basis ι R M) (c : Basis κ R N) :\n    comp (dualDistrib R M N) (dualDistribInvOfBasis b c) = LinearMap.id := by\n  apply (b.tensorProduct c).dualBasis.ext\n  rintro ⟨i, j⟩\n  apply (b.tensorProduct c).ext\n  rintro ⟨i', j'⟩\n  simp only [dualDistrib, Basis.coe_dualBasis, coe_comp, Function.comp_apply,\n    dualDistribInvOfBasis_apply, Basis.coord_apply, Basis.tensorProduct_repr_tmul_apply,\n    Basis.repr_self, ne_eq, _root_.map_sum, map_smul, homTensorHomMap_apply, compRight_apply,\n    Basis.tensorProduct_apply, coeFn_sum, Finset.sum_apply, smul_apply, LinearEquiv.coe_coe,\n    map_tmul, lid_tmul, smul_eq_mul, id_coe, id_eq]\n  rw [Finset.sum_eq_single i, Finset.sum_eq_single j]\n  · simpa using mul_comm _ _\n  all_goals { intros; simp [*] at * }\n\n-- Porting note: introduced to help with timeout in dualDistribEquivOfBasis\n"}
{"name":"TensorProduct.dualDistrib_dualDistribInvOfBasis_right_inverse","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\nκ : Type u_6\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : DecidableEq κ\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype κ\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nb : Basis ι R M\nc : Basis κ R N\n⊢ Eq ((TensorProduct.dualDistribInvOfBasis b c).comp (TensorProduct.dualDistrib R M N)) LinearMap.id","decl":"theorem dualDistrib_dualDistribInvOfBasis_right_inverse (b : Basis ι R M) (c : Basis κ R N) :\n    comp (dualDistribInvOfBasis b c) (dualDistrib R M N) = LinearMap.id := by\n  apply (b.dualBasis.tensorProduct c.dualBasis).ext\n  rintro ⟨i, j⟩\n  simp only [Basis.tensorProduct_apply, Basis.coe_dualBasis, coe_comp, Function.comp_apply,\n    dualDistribInvOfBasis_apply, dualDistrib_apply, Basis.coord_apply, Basis.repr_self,\n    ne_eq, id_coe, id_eq]\n  rw [Finset.sum_eq_single i, Finset.sum_eq_single j]\n  · simp\n  all_goals { intros; simp [*] at * }\n\n"}
{"name":"TensorProduct.dualDistribEquivOfBasis_symm_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\nκ : Type u_6\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : DecidableEq κ\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype κ\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nb : Basis ι R M\nc : Basis κ R N\na : Module.Dual R (TensorProduct R M N)\n⊢ Eq ((TensorProduct.dualDistribEquivOfBasis b c).symm a) (Finset.univ.sum fun x => Finset.univ.sum fun x_1 => HSMul.hSMul (a (TensorProduct.tmul R (b x) (c x_1))) (TensorProduct.tmul R (b.coord x) (c.coord x_1)))","decl":"/-- A linear equivalence between `Dual M ⊗ Dual N` and `Dual (M ⊗ N)` given bases for `M` and `N`.\nIt sends `f ⊗ g` to the composition of `TensorProduct.map f g` with the natural\nisomorphism `R ⊗ R ≃ R`.\n-/\n@[simps!]\nnoncomputable def dualDistribEquivOfBasis (b : Basis ι R M) (c : Basis κ R N) :\n    Dual R M ⊗[R] Dual R N ≃ₗ[R] Dual R (M ⊗[R] N) := by\n  refine LinearEquiv.ofLinear (dualDistrib R M N) (dualDistribInvOfBasis b c) ?_ ?_\n  · exact dualDistrib_dualDistribInvOfBasis_left_inverse _ _\n  · exact dualDistrib_dualDistribInvOfBasis_right_inverse _ _\n\n"}
{"name":"TensorProduct.dualDistribEquivOfBasis_apply_apply","module":"Mathlib.LinearAlgebra.Dual","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\nκ : Type u_6\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : DecidableEq κ\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype κ\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nb : Basis ι R M\nc : Basis κ R N\na✝¹ : TensorProduct R (Module.Dual R M) (Module.Dual R N)\na✝ : TensorProduct R M N\n⊢ Eq (((TensorProduct.dualDistribEquivOfBasis b c) a✝¹) a✝) ((TensorProduct.lid R R) (((TensorProduct.homTensorHomMap R M N R R) a✝¹) a✝))","decl":"/-- A linear equivalence between `Dual M ⊗ Dual N` and `Dual (M ⊗ N)` given bases for `M` and `N`.\nIt sends `f ⊗ g` to the composition of `TensorProduct.map f g` with the natural\nisomorphism `R ⊗ R ≃ R`.\n-/\n@[simps!]\nnoncomputable def dualDistribEquivOfBasis (b : Basis ι R M) (c : Basis κ R N) :\n    Dual R M ⊗[R] Dual R N ≃ₗ[R] Dual R (M ⊗[R] N) := by\n  refine LinearEquiv.ofLinear (dualDistrib R M N) (dualDistribInvOfBasis b c) ?_ ?_\n  · exact dualDistrib_dualDistribInvOfBasis_left_inverse _ _\n  · exact dualDistrib_dualDistribInvOfBasis_right_inverse _ _\n\n"}
