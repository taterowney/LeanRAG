{"name":"Set.le_einfsep_iff","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nd : ENNReal\n⊢ Iff (LE.le d s.einfsep) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → LE.le d (EDist.edist x y))","decl":"theorem le_einfsep_iff {d} :\n    d ≤ s.einfsep ↔ ∀ x ∈ s, ∀ y ∈ s, x ≠ y → d ≤ edist x y := by\n  simp_rw [einfsep, le_iInf_iff]\n\n"}
{"name":"Set.einfsep_zero","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\n⊢ Iff (Eq s.einfsep 0) (∀ (C : ENNReal), GT.gt C 0 → Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (LT.lt (EDist.edist x y) C))))","decl":"theorem einfsep_zero : s.einfsep = 0 ↔ ∀ C > 0, ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ edist x y < C := by\n  simp_rw [einfsep, ← _root_.bot_eq_zero, iInf_eq_bot, iInf_lt_iff, exists_prop]\n\n"}
{"name":"Set.einfsep_pos","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\n⊢ Iff (LT.lt 0 s.einfsep) (Exists fun C => And (GT.gt C 0) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → LE.le C (EDist.edist x y)))","decl":"theorem einfsep_pos : 0 < s.einfsep ↔ ∃ C > 0, ∀ x ∈ s, ∀ y ∈ s, x ≠ y → C ≤ edist x y := by\n  rw [pos_iff_ne_zero, Ne, einfsep_zero]\n  simp only [not_forall, not_exists, not_lt, exists_prop, not_and]\n\n"}
{"name":"Set.einfsep_top","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\n⊢ Iff (Eq s.einfsep Top.top) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → Eq (EDist.edist x y) Top.top)","decl":"theorem einfsep_top :\n    s.einfsep = ∞ ↔ ∀ x ∈ s, ∀ y ∈ s, x ≠ y → edist x y = ∞ := by\n  simp_rw [einfsep, iInf_eq_top]\n\n"}
{"name":"Set.einfsep_lt_top","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\n⊢ Iff (LT.lt s.einfsep Top.top) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (LT.lt (EDist.edist x y) Top.top))))","decl":"theorem einfsep_lt_top :\n    s.einfsep < ∞ ↔ ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ edist x y < ∞ := by\n  simp_rw [einfsep, iInf_lt_iff, exists_prop]\n\n"}
{"name":"Set.einfsep_ne_top","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\n⊢ Iff (Ne s.einfsep Top.top) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (Ne (EDist.edist x y) Top.top))))","decl":"theorem einfsep_ne_top :\n    s.einfsep ≠ ∞ ↔ ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ edist x y ≠ ∞ := by\n  simp_rw [← lt_top_iff_ne_top, einfsep_lt_top]\n\n"}
{"name":"Set.einfsep_lt_iff","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nd : ENNReal\n⊢ Iff (LT.lt s.einfsep d) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (LT.lt (EDist.edist x y) d))))","decl":"theorem einfsep_lt_iff {d} :\n    s.einfsep < d ↔ ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ edist x y < d := by\n  simp_rw [einfsep, iInf_lt_iff, exists_prop]\n\n"}
{"name":"Set.nontrivial_of_einfsep_lt_top","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nhs : LT.lt s.einfsep Top.top\n⊢ s.Nontrivial","decl":"theorem nontrivial_of_einfsep_lt_top (hs : s.einfsep < ∞) : s.Nontrivial := by\n  rcases einfsep_lt_top.1 hs with ⟨_, hx, _, hy, hxy, _⟩\n  exact ⟨_, hx, _, hy, hxy⟩\n\n"}
{"name":"Set.nontrivial_of_einfsep_ne_top","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nhs : Ne s.einfsep Top.top\n⊢ s.Nontrivial","decl":"theorem nontrivial_of_einfsep_ne_top (hs : s.einfsep ≠ ∞) : s.Nontrivial :=\n  nontrivial_of_einfsep_lt_top (lt_top_iff_ne_top.mpr hs)\n\n"}
{"name":"Set.Subsingleton.einfsep","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nhs : s.Subsingleton\n⊢ Eq s.einfsep Top.top","decl":"theorem Subsingleton.einfsep (hs : s.Subsingleton) : s.einfsep = ∞ := by\n  rw [einfsep_top]\n  exact fun _ hx _ hy hxy => (hxy <| hs hx hy).elim\n\n"}
{"name":"Set.le_einfsep_image_iff","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : EDist α\nd : ENNReal\nf : β → α\ns : Set β\n⊢ Iff (LE.le d (Set.image f s).einfsep) (∀ (x : β), Membership.mem s x → ∀ (y : β), Membership.mem s y → Ne (f x) (f y) → LE.le d (EDist.edist (f x) (f y)))","decl":"theorem le_einfsep_image_iff {d} {f : β → α} {s : Set β} : d ≤ einfsep (f '' s)\n    ↔ ∀ x ∈ s, ∀ y ∈ s, f x ≠ f y → d ≤ edist (f x) (f y) := by\n  simp_rw [le_einfsep_iff, forall_mem_image]\n\n"}
{"name":"Set.le_edist_of_le_einfsep","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nd : ENNReal\nx : α\nhx : Membership.mem s x\ny : α\nhy : Membership.mem s y\nhxy : Ne x y\nhd : LE.le d s.einfsep\n⊢ LE.le d (EDist.edist x y)","decl":"theorem le_edist_of_le_einfsep {d x} (hx : x ∈ s) {y} (hy : y ∈ s) (hxy : x ≠ y)\n    (hd : d ≤ s.einfsep) : d ≤ edist x y :=\n  le_einfsep_iff.1 hd x hx y hy hxy\n\n"}
{"name":"Set.einfsep_le_edist_of_mem","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nx : α\nhx : Membership.mem s x\ny : α\nhy : Membership.mem s y\nhxy : Ne x y\n⊢ LE.le s.einfsep (EDist.edist x y)","decl":"theorem einfsep_le_edist_of_mem {x} (hx : x ∈ s) {y} (hy : y ∈ s) (hxy : x ≠ y) :\n    s.einfsep ≤ edist x y :=\n  le_edist_of_le_einfsep hx hy hxy le_rfl\n\n"}
{"name":"Set.einfsep_le_of_mem_of_edist_le","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nd : ENNReal\nx : α\nhx : Membership.mem s x\ny : α\nhy : Membership.mem s y\nhxy : Ne x y\nhxy' : LE.le (EDist.edist x y) d\n⊢ LE.le s.einfsep d","decl":"theorem einfsep_le_of_mem_of_edist_le {d x} (hx : x ∈ s) {y} (hy : y ∈ s) (hxy : x ≠ y)\n    (hxy' : edist x y ≤ d) : s.einfsep ≤ d :=\n  le_trans (einfsep_le_edist_of_mem hx hy hxy) hxy'\n\n"}
{"name":"Set.le_einfsep","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nd : ENNReal\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → LE.le d (EDist.edist x y)\n⊢ LE.le d s.einfsep","decl":"theorem le_einfsep {d} (h : ∀ x ∈ s, ∀ y ∈ s, x ≠ y → d ≤ edist x y) : d ≤ s.einfsep :=\n  le_einfsep_iff.2 h\n\n"}
{"name":"Set.einfsep_empty","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\n⊢ Eq EmptyCollection.emptyCollection.einfsep Top.top","decl":"@[simp]\ntheorem einfsep_empty : (∅ : Set α).einfsep = ∞ :=\n  subsingleton_empty.einfsep\n\n"}
{"name":"Set.einfsep_singleton","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\nx : α\n⊢ Eq (Singleton.singleton x).einfsep Top.top","decl":"@[simp]\ntheorem einfsep_singleton : ({x} : Set α).einfsep = ∞ :=\n  subsingleton_singleton.einfsep\n\n"}
{"name":"Set.einfsep_iUnion_mem_option","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\nι : Type u_3\no : Option ι\ns : ι → Set α\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun h => s i).einfsep (iInf fun i => iInf fun h => (s i).einfsep)","decl":"theorem einfsep_iUnion_mem_option {ι : Type*} (o : Option ι) (s : ι → Set α) :\n    (⋃ i ∈ o, s i).einfsep = ⨅ i ∈ o, (s i).einfsep := by cases o <;> simp\n\n"}
{"name":"Set.einfsep_anti","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns t : Set α\nhst : HasSubset.Subset s t\n⊢ LE.le t.einfsep s.einfsep","decl":"theorem einfsep_anti (hst : s ⊆ t) : t.einfsep ≤ s.einfsep :=\n  le_einfsep fun _x hx _y hy => einfsep_le_edist_of_mem (hst hx) (hst hy)\n\n"}
{"name":"Set.einfsep_insert_le","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\nx : α\ns : Set α\n⊢ LE.le (Insert.insert x s).einfsep (iInf fun y => iInf fun h => iInf fun x_1 => EDist.edist x y)","decl":"theorem einfsep_insert_le : (insert x s).einfsep ≤ ⨅ (y ∈ s) (_ : x ≠ y), edist x y := by\n  simp_rw [le_iInf_iff]\n  exact fun _ hy hxy => einfsep_le_edist_of_mem (mem_insert _ _) (mem_insert_of_mem _ hy) hxy\n\n"}
{"name":"Set.le_einfsep_pair","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\nx y : α\n⊢ LE.le (Min.min (EDist.edist x y) (EDist.edist y x)) (Insert.insert x (Singleton.singleton y)).einfsep","decl":"theorem le_einfsep_pair : edist x y ⊓ edist y x ≤ ({x, y} : Set α).einfsep := by\n  simp_rw [le_einfsep_iff, inf_le_iff, mem_insert_iff, mem_singleton_iff]\n  rintro a (rfl | rfl) b (rfl | rfl) hab <;> (try simp only [le_refl, true_or, or_true]) <;>\n    contradiction\n\n"}
{"name":"Set.einfsep_pair_le_left","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\nx y : α\nhxy : Ne x y\n⊢ LE.le (Insert.insert x (Singleton.singleton y)).einfsep (EDist.edist x y)","decl":"theorem einfsep_pair_le_left (hxy : x ≠ y) : ({x, y} : Set α).einfsep ≤ edist x y :=\n  einfsep_le_edist_of_mem (mem_insert _ _) (mem_insert_of_mem _ (mem_singleton _)) hxy\n\n"}
{"name":"Set.einfsep_pair_le_right","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\nx y : α\nhxy : Ne x y\n⊢ LE.le (Insert.insert x (Singleton.singleton y)).einfsep (EDist.edist y x)","decl":"theorem einfsep_pair_le_right (hxy : x ≠ y) : ({x, y} : Set α).einfsep ≤ edist y x := by\n  rw [pair_comm]; exact einfsep_pair_le_left hxy.symm\n\n"}
{"name":"Set.einfsep_pair_eq_inf","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\nx y : α\nhxy : Ne x y\n⊢ Eq (Insert.insert x (Singleton.singleton y)).einfsep (Min.min (EDist.edist x y) (EDist.edist y x))","decl":"theorem einfsep_pair_eq_inf (hxy : x ≠ y) : ({x, y} : Set α).einfsep = edist x y ⊓ edist y x :=\n  le_antisymm (le_inf (einfsep_pair_le_left hxy) (einfsep_pair_le_right hxy)) le_einfsep_pair\n\n"}
{"name":"Set.einfsep_eq_iInf","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\n⊢ Eq s.einfsep (iInf fun d => Function.uncurry EDist.edist ↑d)","decl":"theorem einfsep_eq_iInf : s.einfsep = ⨅ d : s.offDiag, (uncurry edist) (d : α × α) := by\n  refine eq_of_forall_le_iff fun _ => ?_\n  simp_rw [le_einfsep_iff, le_iInf_iff, imp_forall_iff, SetCoe.forall, mem_offDiag,\n    Prod.forall, uncurry_apply_pair, and_imp]\n\n"}
{"name":"Set.einfsep_of_fintype","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝² : EDist α\ns : Set α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype ↑s\n⊢ Eq s.einfsep (s.offDiag.toFinset.inf (Function.uncurry EDist.edist))","decl":"theorem einfsep_of_fintype [DecidableEq α] [Fintype s] :\n    s.einfsep = s.offDiag.toFinset.inf (uncurry edist) := by\n  refine eq_of_forall_le_iff fun _ => ?_\n  simp_rw [le_einfsep_iff, imp_forall_iff, Finset.le_inf_iff, mem_toFinset, mem_offDiag,\n    Prod.forall, uncurry_apply_pair, and_imp]\n\n"}
{"name":"Set.Finite.einfsep","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nhs : s.Finite\n⊢ Eq s.einfsep (⋯.toFinset.inf (Function.uncurry EDist.edist))","decl":"theorem Finite.einfsep (hs : s.Finite) : s.einfsep = hs.offDiag.toFinset.inf (uncurry edist) := by\n  refine eq_of_forall_le_iff fun _ => ?_\n  simp_rw [le_einfsep_iff, imp_forall_iff, Finset.le_inf_iff, Finite.mem_toFinset, mem_offDiag,\n    Prod.forall, uncurry_apply_pair, and_imp]\n\n"}
{"name":"Set.Finset.coe_einfsep","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : EDist α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (↑s).einfsep (s.offDiag.inf (Function.uncurry EDist.edist))","decl":"theorem Finset.coe_einfsep [DecidableEq α] {s : Finset α} :\n    (s : Set α).einfsep = s.offDiag.inf (uncurry edist) := by\n  simp_rw [einfsep_of_fintype, ← Finset.coe_offDiag, Finset.toFinset_coe]\n\n"}
{"name":"Set.Nontrivial.einfsep_exists_of_finite","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : EDist α\ns : Set α\ninst✝ : Finite ↑s\nhs : s.Nontrivial\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (Eq s.einfsep (EDist.edist x y))))","decl":"theorem Nontrivial.einfsep_exists_of_finite [Finite s] (hs : s.Nontrivial) :\n    ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ s.einfsep = edist x y := by\n  classical\n    cases nonempty_fintype s\n    simp_rw [einfsep_of_fintype]\n    rcases Finset.exists_mem_eq_inf s.offDiag.toFinset (by simpa) (uncurry edist) with ⟨w, hxy, hed⟩\n    simp_rw [mem_toFinset] at hxy\n    exact ⟨w.fst, hxy.1, w.snd, hxy.2.1, hxy.2.2, hed⟩\n\n"}
{"name":"Set.Finite.einfsep_exists_of_nontrivial","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nhsf : s.Finite\nhs : s.Nontrivial\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (Eq s.einfsep (EDist.edist x y))))","decl":"theorem Finite.einfsep_exists_of_nontrivial (hsf : s.Finite) (hs : s.Nontrivial) :\n    ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ s.einfsep = edist x y :=\n  letI := hsf.fintype\n  hs.einfsep_exists_of_finite\n\n"}
{"name":"Set.einfsep_pair","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nx y : α\nhxy : Ne x y\n⊢ Eq (Insert.insert x (Singleton.singleton y)).einfsep (EDist.edist x y)","decl":"theorem einfsep_pair (hxy : x ≠ y) : ({x, y} : Set α).einfsep = edist x y := by\n  nth_rw 1 [← min_self (edist x y)]\n  convert einfsep_pair_eq_inf hxy using 2\n  rw [edist_comm]\n\n"}
{"name":"Set.einfsep_insert","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\n⊢ Eq (Insert.insert x s).einfsep (Min.min (iInf fun y => iInf fun h => iInf fun x_1 => EDist.edist x y) s.einfsep)","decl":"theorem einfsep_insert : einfsep (insert x s) =\n    (⨅ (y ∈ s) (_ : x ≠ y), edist x y) ⊓ s.einfsep := by\n  refine le_antisymm (le_min einfsep_insert_le (einfsep_anti (subset_insert _ _))) ?_\n  simp_rw [le_einfsep_iff, inf_le_iff, mem_insert_iff]\n  rintro y (rfl | hy) z (rfl | hz) hyz\n  · exact False.elim (hyz rfl)\n  · exact Or.inl (iInf_le_of_le _ (iInf₂_le hz hyz))\n  · rw [edist_comm]\n    exact Or.inl (iInf_le_of_le _ (iInf₂_le hy hyz.symm))\n  · exact Or.inr (einfsep_le_edist_of_mem hy hz hyz)\n\n"}
{"name":"Set.einfsep_triple","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nx y z : α\nhxy : Ne x y\nhyz : Ne y z\nhxz : Ne x z\n⊢ Eq (Insert.insert x (Insert.insert y (Singleton.singleton z))).einfsep (Min.min (Min.min (EDist.edist x y) (EDist.edist x z)) (EDist.edist y z))","decl":"theorem einfsep_triple (hxy : x ≠ y) (hyz : y ≠ z) (hxz : x ≠ z) :\n    einfsep ({x, y, z} : Set α) = edist x y ⊓ edist x z ⊓ edist y z := by\n  simp_rw [einfsep_insert, iInf_insert, iInf_singleton, einfsep_singleton, inf_top_eq,\n    ciInf_pos hxy, ciInf_pos hyz, ciInf_pos hxz]\n\n"}
{"name":"Set.le_einfsep_pi_of_le","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"β : Type u_2\nπ : β → Type u_3\ninst✝¹ : Fintype β\ninst✝ : (b : β) → PseudoEMetricSpace (π b)\ns : (b : β) → Set (π b)\nc : ENNReal\nh : ∀ (b : β), LE.le c (s b).einfsep\n⊢ LE.le c (Set.univ.pi s).einfsep","decl":"theorem le_einfsep_pi_of_le {π : β → Type*} [Fintype β] [∀ b, PseudoEMetricSpace (π b)]\n    {s : ∀ b : β, Set (π b)} {c : ℝ≥0∞} (h : ∀ b, c ≤ einfsep (s b)) :\n    c ≤ einfsep (Set.pi univ s) := by\n  refine le_einfsep fun x hx y hy hxy => ?_\n  rw [mem_univ_pi] at hx hy\n  rcases Function.ne_iff.mp hxy with ⟨i, hi⟩\n  exact le_trans (le_einfsep_iff.1 (h i) _ (hx _) _ (hy _) hi) (edist_le_pi_edist _ _ i)\n\n"}
{"name":"Set.subsingleton_of_einfsep_eq_top","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : Eq s.einfsep Top.top\n⊢ s.Subsingleton","decl":"theorem subsingleton_of_einfsep_eq_top (hs : s.einfsep = ∞) : s.Subsingleton := by\n  rw [einfsep_top] at hs\n  exact fun _ hx _ hy => of_not_not fun hxy => edist_ne_top _ _ (hs _ hx _ hy hxy)\n\n"}
{"name":"Set.einfsep_eq_top_iff","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Eq s.einfsep Top.top) s.Subsingleton","decl":"theorem einfsep_eq_top_iff : s.einfsep = ∞ ↔ s.Subsingleton :=\n  ⟨subsingleton_of_einfsep_eq_top, Subsingleton.einfsep⟩\n\n"}
{"name":"Set.Nontrivial.einfsep_ne_top","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : s.Nontrivial\n⊢ Ne s.einfsep Top.top","decl":"theorem Nontrivial.einfsep_ne_top (hs : s.Nontrivial) : s.einfsep ≠ ∞ := by\n  contrapose! hs\n  rw [not_nontrivial_iff]\n  exact subsingleton_of_einfsep_eq_top hs\n\n"}
{"name":"Set.Nontrivial.einfsep_lt_top","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : s.Nontrivial\n⊢ LT.lt s.einfsep Top.top","decl":"theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by\n  rw [lt_top_iff_ne_top]\n  exact hs.einfsep_ne_top\n\n"}
{"name":"Set.einfsep_lt_top_iff","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (LT.lt s.einfsep Top.top) s.Nontrivial","decl":"theorem einfsep_lt_top_iff : s.einfsep < ∞ ↔ s.Nontrivial :=\n  ⟨nontrivial_of_einfsep_lt_top, Nontrivial.einfsep_lt_top⟩\n\n"}
{"name":"Set.einfsep_ne_top_iff","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Ne s.einfsep Top.top) s.Nontrivial","decl":"theorem einfsep_ne_top_iff : s.einfsep ≠ ∞ ↔ s.Nontrivial :=\n  ⟨nontrivial_of_einfsep_ne_top, Nontrivial.einfsep_ne_top⟩\n\n"}
{"name":"Set.le_einfsep_of_forall_dist_le","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nd : Real\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → LE.le d (Dist.dist x y)\n⊢ LE.le (ENNReal.ofReal d) s.einfsep","decl":"theorem le_einfsep_of_forall_dist_le {d} (h : ∀ x ∈ s, ∀ y ∈ s, x ≠ y → d ≤ dist x y) :\n    ENNReal.ofReal d ≤ s.einfsep :=\n  le_einfsep fun x hx y hy hxy => (edist_dist x y).symm ▸ ENNReal.ofReal_le_ofReal (h x hx y hy hxy)\n\n"}
{"name":"Set.einfsep_pos_of_finite","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : EMetricSpace α\ns : Set α\ninst✝ : Finite ↑s\n⊢ LT.lt 0 s.einfsep","decl":"theorem einfsep_pos_of_finite [Finite s] : 0 < s.einfsep := by\n  cases nonempty_fintype s\n  by_cases hs : s.Nontrivial\n  · rcases hs.einfsep_exists_of_finite with ⟨x, _hx, y, _hy, hxy, hxy'⟩\n    exact hxy'.symm ▸ edist_pos.2 hxy\n  · rw [not_nontrivial_iff] at hs\n    exact hs.einfsep.symm ▸ WithTop.top_pos\n\n"}
{"name":"Set.relatively_discrete_of_finite","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : EMetricSpace α\ns : Set α\ninst✝ : Finite ↑s\n⊢ Exists fun C => And (GT.gt C 0) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → LE.le C (EDist.edist x y))","decl":"theorem relatively_discrete_of_finite [Finite s] :\n    ∃ C > 0, ∀ x ∈ s, ∀ y ∈ s, x ≠ y → C ≤ edist x y := by\n  rw [← einfsep_pos]\n  exact einfsep_pos_of_finite\n\n"}
{"name":"Set.Finite.einfsep_pos","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EMetricSpace α\ns : Set α\nhs : s.Finite\n⊢ LT.lt 0 s.einfsep","decl":"theorem Finite.einfsep_pos (hs : s.Finite) : 0 < s.einfsep :=\n  letI := hs.fintype\n  einfsep_pos_of_finite\n\n"}
{"name":"Set.Finite.relatively_discrete","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EMetricSpace α\ns : Set α\nhs : s.Finite\n⊢ Exists fun C => And (GT.gt C 0) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → LE.le C (EDist.edist x y))","decl":"theorem Finite.relatively_discrete (hs : s.Finite) :\n    ∃ C > 0, ∀ x ∈ s, ∀ y ∈ s, x ≠ y → C ≤ edist x y :=\n  letI := hs.fintype\n  relatively_discrete_of_finite\n\n"}
{"name":"Set.infsep_zero","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\n⊢ Iff (Eq s.infsep 0) (Or (Eq s.einfsep 0) (Eq s.einfsep Top.top))","decl":"theorem infsep_zero : s.infsep = 0 ↔ s.einfsep = 0 ∨ s.einfsep = ∞ := by\n  rw [infsep, ENNReal.toReal_eq_zero_iff]\n\n"}
{"name":"Set.infsep_nonneg","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\n⊢ LE.le 0 s.infsep","decl":"theorem infsep_nonneg : 0 ≤ s.infsep :=\n  ENNReal.toReal_nonneg\n\n"}
{"name":"Set.infsep_pos","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\n⊢ Iff (LT.lt 0 s.infsep) (And (LT.lt 0 s.einfsep) (LT.lt s.einfsep Top.top))","decl":"theorem infsep_pos : 0 < s.infsep ↔ 0 < s.einfsep ∧ s.einfsep < ∞ := by\n  simp_rw [infsep, ENNReal.toReal_pos_iff]\n\n"}
{"name":"Set.Subsingleton.infsep_zero","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nhs : s.Subsingleton\n⊢ Eq s.infsep 0","decl":"theorem Subsingleton.infsep_zero (hs : s.Subsingleton) : s.infsep = 0 :=\n  Set.infsep_zero.mpr <| Or.inr hs.einfsep\n\n"}
{"name":"Set.nontrivial_of_infsep_pos","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\ns : Set α\nhs : LT.lt 0 s.infsep\n⊢ s.Nontrivial","decl":"theorem nontrivial_of_infsep_pos (hs : 0 < s.infsep) : s.Nontrivial := by\n  contrapose hs\n  rw [not_nontrivial_iff] at hs\n  exact hs.infsep_zero ▸ lt_irrefl _\n\n"}
{"name":"Set.infsep_empty","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\n⊢ Eq EmptyCollection.emptyCollection.infsep 0","decl":"theorem infsep_empty : (∅ : Set α).infsep = 0 :=\n  subsingleton_empty.infsep_zero\n\n"}
{"name":"Set.infsep_singleton","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\nx : α\n⊢ Eq (Singleton.singleton x).infsep 0","decl":"theorem infsep_singleton : ({x} : Set α).infsep = 0 :=\n  subsingleton_singleton.infsep_zero\n\n"}
{"name":"Set.infsep_pair_le_toReal_inf","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : EDist α\nx y : α\nhxy : Ne x y\n⊢ LE.le (Insert.insert x (Singleton.singleton y)).infsep (Min.min (EDist.edist x y) (EDist.edist y x)).toReal","decl":"theorem infsep_pair_le_toReal_inf (hxy : x ≠ y) :\n    ({x, y} : Set α).infsep ≤ (edist x y ⊓ edist y x).toReal := by\n  simp_rw [infsep, einfsep_pair_eq_inf hxy]\n  simp\n\n"}
{"name":"Set.infsep_pair_eq_toReal","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nx y : α\n⊢ Eq (Insert.insert x (Singleton.singleton y)).infsep (EDist.edist x y).toReal","decl":"theorem infsep_pair_eq_toReal : ({x, y} : Set α).infsep = (edist x y).toReal := by\n  by_cases hxy : x = y\n  · rw [hxy]\n    simp only [infsep_singleton, pair_eq_singleton, edist_self, ENNReal.zero_toReal]\n  · rw [infsep, einfsep_pair hxy]\n\n"}
{"name":"Set.Nontrivial.le_infsep_iff","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nd : Real\nhs : s.Nontrivial\n⊢ Iff (LE.le d s.infsep) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → LE.le d (Dist.dist x y))","decl":"theorem Nontrivial.le_infsep_iff {d} (hs : s.Nontrivial) :\n    d ≤ s.infsep ↔ ∀ x ∈ s, ∀ y ∈ s, x ≠ y → d ≤ dist x y := by\n  simp_rw [infsep, ← ENNReal.ofReal_le_iff_le_toReal hs.einfsep_ne_top, le_einfsep_iff, edist_dist,\n    ENNReal.ofReal_le_ofReal_iff dist_nonneg]\n\n"}
{"name":"Set.Nontrivial.infsep_lt_iff","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nd : Real\nhs : s.Nontrivial\n⊢ Iff (LT.lt s.infsep d) (Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (LT.lt (Dist.dist x y) d))))","decl":"theorem Nontrivial.infsep_lt_iff {d} (hs : s.Nontrivial) :\n    s.infsep < d ↔ ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ dist x y < d := by\n  rw [← not_iff_not]\n  push_neg\n  exact hs.le_infsep_iff\n\n"}
{"name":"Set.Nontrivial.le_infsep","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nd : Real\nhs : s.Nontrivial\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → LE.le d (Dist.dist x y)\n⊢ LE.le d s.infsep","decl":"theorem Nontrivial.le_infsep {d} (hs : s.Nontrivial)\n    (h : ∀ x ∈ s, ∀ y ∈ s, x ≠ y → d ≤ dist x y) : d ≤ s.infsep :=\n  hs.le_infsep_iff.2 h\n\n"}
{"name":"Set.le_edist_of_le_infsep","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nd : Real\nx : α\nhx : Membership.mem s x\ny : α\nhy : Membership.mem s y\nhxy : Ne x y\nhd : LE.le d s.infsep\n⊢ LE.le d (Dist.dist x y)","decl":"theorem le_edist_of_le_infsep {d x} (hx : x ∈ s) {y} (hy : y ∈ s) (hxy : x ≠ y)\n    (hd : d ≤ s.infsep) : d ≤ dist x y := by\n  by_cases hs : s.Nontrivial\n  · exact hs.le_infsep_iff.1 hd x hx y hy hxy\n  · rw [not_nontrivial_iff] at hs\n    rw [hs.infsep_zero] at hd\n    exact le_trans hd dist_nonneg\n\n"}
{"name":"Set.infsep_le_dist_of_mem","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\nx y : α\ns : Set α\nhx : Membership.mem s x\nhy : Membership.mem s y\nhxy : Ne x y\n⊢ LE.le s.infsep (Dist.dist x y)","decl":"theorem infsep_le_dist_of_mem (hx : x ∈ s) (hy : y ∈ s) (hxy : x ≠ y) : s.infsep ≤ dist x y :=\n  le_edist_of_le_infsep hx hy hxy le_rfl\n\n"}
{"name":"Set.infsep_le_of_mem_of_edist_le","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nd : Real\nx : α\nhx : Membership.mem s x\ny : α\nhy : Membership.mem s y\nhxy : Ne x y\nhxy' : LE.le (Dist.dist x y) d\n⊢ LE.le s.infsep d","decl":"theorem infsep_le_of_mem_of_edist_le {d x} (hx : x ∈ s) {y} (hy : y ∈ s) (hxy : x ≠ y)\n    (hxy' : dist x y ≤ d) : s.infsep ≤ d :=\n  le_trans (infsep_le_dist_of_mem hx hy hxy) hxy'\n\n"}
{"name":"Set.infsep_pair","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (Insert.insert x (Singleton.singleton y)).infsep (Dist.dist x y)","decl":"theorem infsep_pair : ({x, y} : Set α).infsep = dist x y := by\n  rw [infsep_pair_eq_toReal, edist_dist]\n  exact ENNReal.toReal_ofReal dist_nonneg\n\n"}
{"name":"Set.infsep_triple","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\nx y z : α\nhxy : Ne x y\nhyz : Ne y z\nhxz : Ne x z\n⊢ Eq (Insert.insert x (Insert.insert y (Singleton.singleton z))).infsep (Min.min (Min.min (Dist.dist x y) (Dist.dist x z)) (Dist.dist y z))","decl":"theorem infsep_triple (hxy : x ≠ y) (hyz : y ≠ z) (hxz : x ≠ z) :\n    ({x, y, z} : Set α).infsep = dist x y ⊓ dist x z ⊓ dist y z := by\n  simp only [infsep, einfsep_triple hxy hyz hxz, ENNReal.toReal_inf, edist_ne_top x y,\n    edist_ne_top x z, edist_ne_top y z, dist_edist, Ne, inf_eq_top_iff, and_self_iff,\n    not_false_iff]\n\n"}
{"name":"Set.Nontrivial.infsep_anti","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns t : Set α\nhs : s.Nontrivial\nhst : HasSubset.Subset s t\n⊢ LE.le t.infsep s.infsep","decl":"theorem Nontrivial.infsep_anti (hs : s.Nontrivial) (hst : s ⊆ t) : t.infsep ≤ s.infsep :=\n  ENNReal.toReal_mono hs.einfsep_ne_top (einfsep_anti hst)\n\n"}
{"name":"Set.infsep_eq_iInf","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : Decidable s.Nontrivial\n⊢ Eq s.infsep (ite s.Nontrivial (iInf fun d => Function.uncurry Dist.dist ↑d) 0)","decl":"theorem infsep_eq_iInf [Decidable s.Nontrivial] :\n    s.infsep = if s.Nontrivial then ⨅ d : s.offDiag, (uncurry dist) (d : α × α) else 0 := by\n  split_ifs with hs\n  · have hb : BddBelow (uncurry dist '' s.offDiag) := by\n      refine ⟨0, fun d h => ?_⟩\n      simp_rw [mem_image, Prod.exists, uncurry_apply_pair] at h\n      rcases h with ⟨_, _, _, rfl⟩\n      exact dist_nonneg\n    refine eq_of_forall_le_iff fun _ => ?_\n    simp_rw [hs.le_infsep_iff, le_ciInf_set_iff (offDiag_nonempty.mpr hs) hb, imp_forall_iff,\n      mem_offDiag, Prod.forall, uncurry_apply_pair, and_imp]\n  · exact (not_nontrivial_iff.mp hs).infsep_zero\n\n"}
{"name":"Set.Nontrivial.infsep_eq_iInf","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : s.Nontrivial\n⊢ Eq s.infsep (iInf fun d => Function.uncurry Dist.dist ↑d)","decl":"theorem Nontrivial.infsep_eq_iInf (hs : s.Nontrivial) :\n    s.infsep = ⨅ d : s.offDiag, (uncurry dist) (d : α × α) := by\n  classical rw [Set.infsep_eq_iInf, if_pos hs]\n\n"}
{"name":"Set.infsep_of_fintype","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝³ : PseudoMetricSpace α\ns : Set α\ninst✝² : Decidable s.Nontrivial\ninst✝¹ : DecidableEq α\ninst✝ : Fintype ↑s\n⊢ Eq s.infsep (dite s.Nontrivial (fun hs => s.offDiag.toFinset.inf' ⋯ (Function.uncurry Dist.dist)) fun hs => 0)","decl":"theorem infsep_of_fintype [Decidable s.Nontrivial] [DecidableEq α] [Fintype s] : s.infsep =\n    if hs : s.Nontrivial then s.offDiag.toFinset.inf' (by simpa) (uncurry dist) else 0 := by\n  split_ifs with hs\n  · refine eq_of_forall_le_iff fun _ => ?_\n    simp_rw [hs.le_infsep_iff, imp_forall_iff, Finset.le_inf'_iff, mem_toFinset, mem_offDiag,\n      Prod.forall, uncurry_apply_pair, and_imp]\n  · rw [not_nontrivial_iff] at hs\n    exact hs.infsep_zero\n\n"}
{"name":"Set.Nontrivial.infsep_of_fintype","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ns : Set α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype ↑s\nhs : s.Nontrivial\n⊢ Eq s.infsep (s.offDiag.toFinset.inf' ⋯ (Function.uncurry Dist.dist))","decl":"theorem Nontrivial.infsep_of_fintype [DecidableEq α] [Fintype s] (hs : s.Nontrivial) :\n    s.infsep = s.offDiag.toFinset.inf' (by simpa) (uncurry dist) := by\n  classical rw [Set.infsep_of_fintype, dif_pos hs]\n\n"}
{"name":"Set.Finite.infsep","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : Decidable s.Nontrivial\nhsf : s.Finite\n⊢ Eq s.infsep (dite s.Nontrivial (fun hs => ⋯.toFinset.inf' ⋯ (Function.uncurry Dist.dist)) fun hs => 0)","decl":"theorem Finite.infsep [Decidable s.Nontrivial] (hsf : s.Finite) :\n    s.infsep =\n      if hs : s.Nontrivial then hsf.offDiag.toFinset.inf' (by simpa) (uncurry dist) else 0 := by\n  split_ifs with hs\n  · refine eq_of_forall_le_iff fun _ => ?_\n    simp_rw [hs.le_infsep_iff, imp_forall_iff, Finset.le_inf'_iff, Finite.mem_toFinset,\n      mem_offDiag, Prod.forall, uncurry_apply_pair, and_imp]\n  · rw [not_nontrivial_iff] at hs\n    exact hs.infsep_zero\n\n"}
{"name":"Set.Finite.infsep_of_nontrivial","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nhsf : s.Finite\nhs : s.Nontrivial\n⊢ Eq s.infsep (⋯.toFinset.inf' ⋯ (Function.uncurry Dist.dist))","decl":"theorem Finite.infsep_of_nontrivial (hsf : s.Finite) (hs : s.Nontrivial) :\n    s.infsep = hsf.offDiag.toFinset.inf' (by simpa) (uncurry dist) := by\n  classical simp_rw [hsf.infsep, dif_pos hs]\n\n"}
{"name":"Finset.coe_infsep","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (↑s).infsep (dite s.offDiag.Nonempty (fun hs => s.offDiag.inf' hs (Function.uncurry Dist.dist)) fun hs => 0)","decl":"theorem _root_.Finset.coe_infsep [DecidableEq α] (s : Finset α) : (s : Set α).infsep =\n    if hs : s.offDiag.Nonempty then s.offDiag.inf' hs (uncurry dist) else 0 := by\n  have H : (s : Set α).Nontrivial ↔ s.offDiag.Nonempty := by\n    rw [← Set.offDiag_nonempty, ← Finset.coe_offDiag, Finset.coe_nonempty]\n  split_ifs with hs\n  · simp_rw [(H.mpr hs).infsep_of_fintype, ← Finset.coe_offDiag, Finset.toFinset_coe]\n  · exact (not_nontrivial_iff.mp (H.mp.mt hs)).infsep_zero\n\n"}
{"name":"Finset.coe_infsep_of_offDiag_nonempty","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\ninst✝ : DecidableEq α\ns : Finset α\nhs : s.offDiag.Nonempty\n⊢ Eq (↑s).infsep (s.offDiag.inf' hs (Function.uncurry Dist.dist))","decl":"theorem _root_.Finset.coe_infsep_of_offDiag_nonempty [DecidableEq α] {s : Finset α}\n    (hs : s.offDiag.Nonempty) : (s : Set α).infsep = s.offDiag.inf' hs (uncurry dist) := by\n  rw [Finset.coe_infsep, dif_pos hs]\n\n"}
{"name":"Finset.coe_infsep_of_offDiag_empty","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\ninst✝ : DecidableEq α\ns : Finset α\nhs : Eq s.offDiag EmptyCollection.emptyCollection\n⊢ Eq (↑s).infsep 0","decl":"theorem _root_.Finset.coe_infsep_of_offDiag_empty\n    [DecidableEq α] {s : Finset α} (hs : s.offDiag = ∅) : (s : Set α).infsep = 0 := by\n  rw [← Finset.not_nonempty_iff_eq_empty] at hs\n  rw [Finset.coe_infsep, dif_neg hs]\n\n"}
{"name":"Set.Nontrivial.infsep_exists_of_finite","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : Finite ↑s\nhs : s.Nontrivial\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (Eq s.infsep (Dist.dist x y))))","decl":"theorem Nontrivial.infsep_exists_of_finite [Finite s] (hs : s.Nontrivial) :\n    ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ s.infsep = dist x y := by\n  classical\n    cases nonempty_fintype s\n    simp_rw [hs.infsep_of_fintype]\n    rcases Finset.exists_mem_eq_inf' (s := s.offDiag.toFinset) (by simpa) (uncurry dist) with\n      ⟨w, hxy, hed⟩\n    simp_rw [mem_toFinset] at hxy\n    exact ⟨w.fst, hxy.1, w.snd, hxy.2.1, hxy.2.2, hed⟩\n\n"}
{"name":"Set.Finite.infsep_exists_of_nontrivial","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : PseudoMetricSpace α\ns : Set α\nhsf : s.Finite\nhs : s.Nontrivial\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (Eq s.infsep (Dist.dist x y))))","decl":"theorem Finite.infsep_exists_of_nontrivial (hsf : s.Finite) (hs : s.Nontrivial) :\n    ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ s.infsep = dist x y :=\n  letI := hsf.fintype\n  hs.infsep_exists_of_finite\n\n"}
{"name":"Set.infsep_zero_iff_subsingleton_of_finite","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : MetricSpace α\ns : Set α\ninst✝ : Finite ↑s\n⊢ Iff (Eq s.infsep 0) s.Subsingleton","decl":"theorem infsep_zero_iff_subsingleton_of_finite [Finite s] : s.infsep = 0 ↔ s.Subsingleton := by\n  rw [infsep_zero, einfsep_eq_top_iff, or_iff_right_iff_imp]\n  exact fun H => (einfsep_pos_of_finite.ne' H).elim\n\n"}
{"name":"Set.infsep_pos_iff_nontrivial_of_finite","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝¹ : MetricSpace α\ns : Set α\ninst✝ : Finite ↑s\n⊢ Iff (LT.lt 0 s.infsep) s.Nontrivial","decl":"theorem infsep_pos_iff_nontrivial_of_finite [Finite s] : 0 < s.infsep ↔ s.Nontrivial := by\n  rw [infsep_pos, einfsep_lt_top_iff, and_iff_right_iff_imp]\n  exact fun _ => einfsep_pos_of_finite\n\n"}
{"name":"Set.Finite.infsep_zero_iff_subsingleton","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\ns : Set α\nhs : s.Finite\n⊢ Iff (Eq s.infsep 0) s.Subsingleton","decl":"theorem Finite.infsep_zero_iff_subsingleton (hs : s.Finite) : s.infsep = 0 ↔ s.Subsingleton :=\n  letI := hs.fintype\n  infsep_zero_iff_subsingleton_of_finite\n\n"}
{"name":"Set.Finite.infsep_pos_iff_nontrivial","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\ns : Set α\nhs : s.Finite\n⊢ Iff (LT.lt 0 s.infsep) s.Nontrivial","decl":"theorem Finite.infsep_pos_iff_nontrivial (hs : s.Finite) : 0 < s.infsep ↔ s.Nontrivial :=\n  letI := hs.fintype\n  infsep_pos_iff_nontrivial_of_finite\n\n"}
{"name":"Finset.infsep_zero_iff_subsingleton","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\ns : Finset α\n⊢ Iff (Eq (↑s).infsep 0) (↑s).Subsingleton","decl":"theorem _root_.Finset.infsep_zero_iff_subsingleton (s : Finset α) :\n    (s : Set α).infsep = 0 ↔ (s : Set α).Subsingleton :=\n  infsep_zero_iff_subsingleton_of_finite\n\n"}
{"name":"Finset.infsep_pos_iff_nontrivial","module":"Mathlib.Topology.MetricSpace.Infsep","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\ns : Finset α\n⊢ Iff (LT.lt 0 (↑s).infsep) (↑s).Nontrivial","decl":"theorem _root_.Finset.infsep_pos_iff_nontrivial (s : Finset α) :\n    0 < (s : Set α).infsep ↔ (s : Set α).Nontrivial :=\n  infsep_pos_iff_nontrivial_of_finite\n\n"}
