{"name":"SSet.Path.arrow_tgt","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nself : X.Path n\ni : Fin n\n⊢ Eq (CategoryTheory.SimplicialObject.δ X 0 (self.arrow i)) (self.vertex i.succ)","decl":"/-- A path in a simplicial set `X` of length `n` is a directed path of `n` edges.-/\n@[ext]\nstructure Path (n : ℕ) where\n  /-- A path includes the data of `n+1` 0-simplices in `X`.-/\n  vertex (i : Fin (n + 1)) : X _[0]\n  /-- A path includes the data of `n` 1-simplices in `X`.-/\n  arrow (i : Fin n) : X _[1]\n  /-- The sources of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_src (i : Fin n) : X.δ 1 (arrow i) = vertex i.castSucc\n  /-- The targets of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_tgt (i : Fin n) : X.δ 0 (arrow i) = vertex i.succ\n\n\n"}
{"name":"SSet.Path.mk.injEq","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nvertex✝ : Fin (HAdd.hAdd n 1) → X.obj { unop := SimplexCategory.mk 0 }\narrow✝ : Fin n → X.obj { unop := SimplexCategory.mk 1 }\narrow_src✝ : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 1 (arrow✝ i)) (vertex✝ i.castSucc)\narrow_tgt✝ : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 0 (arrow✝ i)) (vertex✝ i.succ)\nvertex : Fin (HAdd.hAdd n 1) → X.obj { unop := SimplexCategory.mk 0 }\narrow : Fin n → X.obj { unop := SimplexCategory.mk 1 }\narrow_src : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 1 (arrow i)) (vertex i.castSucc)\narrow_tgt : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 0 (arrow i)) (vertex i.succ)\n⊢ Eq (Eq { vertex := vertex✝, arrow := arrow✝, arrow_src := arrow_src✝, arrow_tgt := arrow_tgt✝ } { vertex := vertex, arrow := arrow, arrow_src := arrow_src, arrow_tgt := arrow_tgt }) (And (Eq vertex✝ vertex) (Eq arrow✝ arrow))","decl":"/-- A path in a simplicial set `X` of length `n` is a directed path of `n` edges.-/\n@[ext]\nstructure Path (n : ℕ) where\n  /-- A path includes the data of `n+1` 0-simplices in `X`.-/\n  vertex (i : Fin (n + 1)) : X _[0]\n  /-- A path includes the data of `n` 1-simplices in `X`.-/\n  arrow (i : Fin n) : X _[1]\n  /-- The sources of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_src (i : Fin n) : X.δ 1 (arrow i) = vertex i.castSucc\n  /-- The targets of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_tgt (i : Fin n) : X.δ 0 (arrow i) = vertex i.succ\n\n\n"}
{"name":"SSet.Path.mk.inj","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nvertex✝ : Fin (HAdd.hAdd n 1) → X.obj { unop := SimplexCategory.mk 0 }\narrow✝ : Fin n → X.obj { unop := SimplexCategory.mk 1 }\narrow_src✝ : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 1 (arrow✝ i)) (vertex✝ i.castSucc)\narrow_tgt✝ : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 0 (arrow✝ i)) (vertex✝ i.succ)\nvertex : Fin (HAdd.hAdd n 1) → X.obj { unop := SimplexCategory.mk 0 }\narrow : Fin n → X.obj { unop := SimplexCategory.mk 1 }\narrow_src : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 1 (arrow i)) (vertex i.castSucc)\narrow_tgt : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 0 (arrow i)) (vertex i.succ)\nx✝ : Eq { vertex := vertex✝, arrow := arrow✝, arrow_src := arrow_src✝, arrow_tgt := arrow_tgt✝ } { vertex := vertex, arrow := arrow, arrow_src := arrow_src, arrow_tgt := arrow_tgt }\n⊢ And (Eq vertex✝ vertex) (Eq arrow✝ arrow)","decl":"/-- A path in a simplicial set `X` of length `n` is a directed path of `n` edges.-/\n@[ext]\nstructure Path (n : ℕ) where\n  /-- A path includes the data of `n+1` 0-simplices in `X`.-/\n  vertex (i : Fin (n + 1)) : X _[0]\n  /-- A path includes the data of `n` 1-simplices in `X`.-/\n  arrow (i : Fin n) : X _[1]\n  /-- The sources of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_src (i : Fin n) : X.δ 1 (arrow i) = vertex i.castSucc\n  /-- The targets of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_tgt (i : Fin n) : X.δ 0 (arrow i) = vertex i.succ\n\n\n"}
{"name":"SSet.Path.ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nx y : X.Path n\n⊢ Iff (Eq x y) (And (Eq x.vertex y.vertex) (Eq x.arrow y.arrow))","decl":"/-- A path in a simplicial set `X` of length `n` is a directed path of `n` edges.-/\n@[ext]\nstructure Path (n : ℕ) where\n  /-- A path includes the data of `n+1` 0-simplices in `X`.-/\n  vertex (i : Fin (n + 1)) : X _[0]\n  /-- A path includes the data of `n` 1-simplices in `X`.-/\n  arrow (i : Fin n) : X _[1]\n  /-- The sources of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_src (i : Fin n) : X.δ 1 (arrow i) = vertex i.castSucc\n  /-- The targets of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_tgt (i : Fin n) : X.δ 0 (arrow i) = vertex i.succ\n\n\n"}
{"name":"SSet.Path.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nvertex : Fin (HAdd.hAdd n 1) → X.obj { unop := SimplexCategory.mk 0 }\narrow : Fin n → X.obj { unop := SimplexCategory.mk 1 }\narrow_src : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 1 (arrow i)) (vertex i.castSucc)\narrow_tgt : ∀ (i : Fin n), Eq (CategoryTheory.SimplicialObject.δ X 0 (arrow i)) (vertex i.succ)\n⊢ Eq (SizeOf.sizeOf { vertex := vertex, arrow := arrow, arrow_src := arrow_src, arrow_tgt := arrow_tgt }) 1","decl":"/-- A path in a simplicial set `X` of length `n` is a directed path of `n` edges.-/\n@[ext]\nstructure Path (n : ℕ) where\n  /-- A path includes the data of `n+1` 0-simplices in `X`.-/\n  vertex (i : Fin (n + 1)) : X _[0]\n  /-- A path includes the data of `n` 1-simplices in `X`.-/\n  arrow (i : Fin n) : X _[1]\n  /-- The sources of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_src (i : Fin n) : X.δ 1 (arrow i) = vertex i.castSucc\n  /-- The targets of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_tgt (i : Fin n) : X.δ 0 (arrow i) = vertex i.succ\n\n\n"}
{"name":"SSet.Path.arrow_src","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nself : X.Path n\ni : Fin n\n⊢ Eq (CategoryTheory.SimplicialObject.δ X 1 (self.arrow i)) (self.vertex i.castSucc)","decl":"/-- A path in a simplicial set `X` of length `n` is a directed path of `n` edges.-/\n@[ext]\nstructure Path (n : ℕ) where\n  /-- A path includes the data of `n+1` 0-simplices in `X`.-/\n  vertex (i : Fin (n + 1)) : X _[0]\n  /-- A path includes the data of `n` 1-simplices in `X`.-/\n  arrow (i : Fin n) : X _[1]\n  /-- The sources of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_src (i : Fin n) : X.δ 1 (arrow i) = vertex i.castSucc\n  /-- The targets of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_tgt (i : Fin n) : X.δ 0 (arrow i) = vertex i.succ\n\n\n"}
{"name":"SSet.Path.ext","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nx y : X.Path n\nvertex : Eq x.vertex y.vertex\narrow : Eq x.arrow y.arrow\n⊢ Eq x y","decl":"/-- A path in a simplicial set `X` of length `n` is a directed path of `n` edges.-/\n@[ext]\nstructure Path (n : ℕ) where\n  /-- A path includes the data of `n+1` 0-simplices in `X`.-/\n  vertex (i : Fin (n + 1)) : X _[0]\n  /-- A path includes the data of `n` 1-simplices in `X`.-/\n  arrow (i : Fin n) : X _[1]\n  /-- The sources of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_src (i : Fin n) : X.δ 1 (arrow i) = vertex i.castSucc\n  /-- The targets of the 1-simplices in a path are identified with appropriate 0-simplices.-/\n  arrow_tgt (i : Fin n) : X.δ 0 (arrow i) = vertex i.succ\n\n\n"}
{"name":"SSet.spine_arrow","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nΔ : X.obj { unop := SimplexCategory.mk n }\ni : Fin n\n⊢ Eq ((X.spine n Δ).arrow i) (X.map (SimplexCategory.mkOfSucc i).op Δ)","decl":"/-- The spine of an `n`-simplex in `X` is the path of edges of length `n` formed by\ntraversing through its vertices in order.-/\n@[simps]\ndef spine (n : ℕ) (Δ : X _[n]) : X.Path n where\n  vertex i := X.map (SimplexCategory.const [0] [n] i).op Δ\n  arrow i := X.map (SimplexCategory.mkOfSucc i).op Δ\n  arrow_src i := by\n    dsimp [SimplicialObject.δ]\n    simp only [← FunctorToTypes.map_comp_apply, ← op_comp]\n    rw [SimplexCategory.δ_one_mkOfSucc]\n    simp only [len_mk, Fin.coe_castSucc, Fin.coe_eq_castSucc]\n  arrow_tgt i := by\n    dsimp [SimplicialObject.δ]\n    simp only [← FunctorToTypes.map_comp_apply, ← op_comp]\n    rw [SimplexCategory.δ_zero_mkOfSucc]\n\n"}
{"name":"SSet.spine_vertex","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nΔ : X.obj { unop := SimplexCategory.mk n }\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((X.spine n Δ).vertex i) (X.map ((SimplexCategory.mk 0).const (SimplexCategory.mk n) i).op Δ)","decl":"/-- The spine of an `n`-simplex in `X` is the path of edges of length `n` formed by\ntraversing through its vertices in order.-/\n@[simps]\ndef spine (n : ℕ) (Δ : X _[n]) : X.Path n where\n  vertex i := X.map (SimplexCategory.const [0] [n] i).op Δ\n  arrow i := X.map (SimplexCategory.mkOfSucc i).op Δ\n  arrow_src i := by\n    dsimp [SimplicialObject.δ]\n    simp only [← FunctorToTypes.map_comp_apply, ← op_comp]\n    rw [SimplexCategory.δ_one_mkOfSucc]\n    simp only [len_mk, Fin.coe_castSucc, Fin.coe_eq_castSucc]\n  arrow_tgt i := by\n    dsimp [SimplicialObject.δ]\n    simp only [← FunctorToTypes.map_comp_apply, ← op_comp]\n    rw [SimplexCategory.δ_zero_mkOfSucc]\n\n"}
{"name":"SSet.spine_map_vertex","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nx : X.obj { unop := SimplexCategory.mk n }\nm : Nat\nφ : Quiver.Hom (SimplexCategory.mk m) (SimplexCategory.mk n)\ni : Fin (HAdd.hAdd m 1)\n⊢ Eq ((X.spine m (X.map φ.op x)).vertex i) ((X.spine n x).vertex ((SimplexCategory.Hom.toOrderHom φ) i))","decl":"lemma spine_map_vertex {n : ℕ} (x : X _[n]) {m : ℕ} (φ : ([m] : SimplexCategory) ⟶ [n])\n    (i : Fin (m + 1)) :\n    (spine X m (X.map φ.op x)).vertex i = (spine X n x).vertex (φ.toOrderHom i) := by\n  dsimp [spine]\n  rw [← FunctorToTypes.map_comp_apply]\n  rfl\n\n"}
{"name":"SSet.spine_map_subinterval","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn j l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\nΔ : X.obj { unop := SimplexCategory.mk n }\n⊢ Eq (X.spine l (X.map (SimplexCategory.subinterval j l ⋯).op Δ)) ((X.spine n Δ).interval j l ⋯)","decl":"lemma spine_map_subinterval {n : ℕ} (j l : ℕ) (hjl : j + l ≤ n) (Δ : X _[n]) :\n    X.spine l (X.map (subinterval j l (by omega)).op Δ) =\n      (X.spine n Δ).interval j l (by omega) := by\n  ext i\n  · simp only [spine_vertex, Path.interval, ← FunctorToTypes.map_comp_apply, ← op_comp,\n      const_subinterval_eq]\n  · simp only [spine_arrow, Path.interval, ← FunctorToTypes.map_comp_apply, ← op_comp,\n      mkOfSucc_subinterval_eq]\n\n"}
{"name":"SSet.Path.ext'_iff","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nf g : X.Path (HAdd.hAdd n 1)\n⊢ Iff (Eq f g) (∀ (i : Fin (HAdd.hAdd n 1)), Eq (f.arrow i) (g.arrow i))","decl":"/-- Two paths of the same nonzero length are equal if all of their arrows are equal. -/\n@[ext]\nlemma Path.ext' {n : ℕ} {f g : Path X (n + 1)}\n    (h : ∀ i : Fin (n + 1), f.arrow i = g.arrow i) :\n    f = g := by\n  ext j\n  · rcases Fin.eq_castSucc_or_eq_last j with ⟨k, hk⟩ | hl\n    · rw [hk, ← f.arrow_src k, ← g.arrow_src k, h]\n    · simp only [hl, ← Fin.succ_last]\n      rw [← f.arrow_tgt (Fin.last n), ← g.arrow_tgt (Fin.last n), h]\n  · exact h j\n\n"}
{"name":"SSet.Path.ext'","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X : SSet\nn : Nat\nf g : X.Path (HAdd.hAdd n 1)\nh : ∀ (i : Fin (HAdd.hAdd n 1)), Eq (f.arrow i) (g.arrow i)\n⊢ Eq f g","decl":"/-- Two paths of the same nonzero length are equal if all of their arrows are equal. -/\n@[ext]\nlemma Path.ext' {n : ℕ} {f g : Path X (n + 1)}\n    (h : ∀ i : Fin (n + 1), f.arrow i = g.arrow i) :\n    f = g := by\n  ext j\n  · rcases Fin.eq_castSucc_or_eq_last j with ⟨k, hk⟩ | hl\n    · rw [hk, ← f.arrow_src k, ← g.arrow_src k, h]\n    · simp only [hl, ← Fin.succ_last]\n      rw [← f.arrow_tgt (Fin.last n), ← g.arrow_tgt (Fin.last n), h]\n  · exact h j\n\n"}
{"name":"SSet.Path.map_arrow","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X Y : SSet\nn : Nat\nf : X.Path n\nσ : Quiver.Hom X Y\ni : Fin n\n⊢ Eq ((f.map σ).arrow i) (σ.app { unop := SimplexCategory.mk 1 } (f.arrow i))","decl":"/-- Maps of simplicial sets induce maps of paths in a simplicial set.-/\n@[simps]\ndef Path.map {X Y : SSet.{u}} {n : ℕ} (f : X.Path n) (σ : X ⟶ Y) : Y.Path n where\n  vertex i := σ.app (Opposite.op [0]) (f.vertex i)\n  arrow i := σ.app (Opposite.op [1]) (f.arrow i)\n  arrow_src i := by\n    simp only [← f.arrow_src i]\n    exact congr (σ.naturality (δ 1).op) rfl |>.symm\n  arrow_tgt i := by\n    simp only [← f.arrow_tgt i]\n    exact congr (σ.naturality (δ 0).op) rfl |>.symm\n\n"}
{"name":"SSet.Path.map_vertex","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X Y : SSet\nn : Nat\nf : X.Path n\nσ : Quiver.Hom X Y\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((f.map σ).vertex i) (σ.app { unop := SimplexCategory.mk 0 } (f.vertex i))","decl":"/-- Maps of simplicial sets induce maps of paths in a simplicial set.-/\n@[simps]\ndef Path.map {X Y : SSet.{u}} {n : ℕ} (f : X.Path n) (σ : X ⟶ Y) : Y.Path n where\n  vertex i := σ.app (Opposite.op [0]) (f.vertex i)\n  arrow i := σ.app (Opposite.op [1]) (f.arrow i)\n  arrow_src i := by\n    simp only [← f.arrow_src i]\n    exact congr (σ.naturality (δ 1).op) rfl |>.symm\n  arrow_tgt i := by\n    simp only [← f.arrow_tgt i]\n    exact congr (σ.naturality (δ 0).op) rfl |>.symm\n\n"}
{"name":"SSet.map_interval","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"X Y : SSet\nn : Nat\nf : X.Path n\nσ : Quiver.Hom X Y\nj l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\n⊢ Eq ((f.map σ).interval j l hjl) ((f.interval j l hjl).map σ)","decl":"/-- `Path.map` respects subintervals of paths.-/\nlemma map_interval {X Y : SSet.{u}} {n : ℕ} (f : X.Path n) (σ : X ⟶ Y)\n    (j l : ℕ) (hjl : j + l ≤ n) :\n    (f.map σ).interval j l hjl = (f.interval j l hjl).map σ := rfl\n\n"}
{"name":"SSet.horn.spineId_vertex_coe","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 3)\nh₀ : LT.lt 0 i\nhₙ : LT.lt i (Fin.last (HAdd.hAdd n 2))\nj : Fin (HAdd.hAdd (HAdd.hAdd n 2) 1)\n⊢ Eq (↑((SSet.horn.spineId i h₀ hₙ).vertex j)) ((SSet.stdSimplex.spineId (HAdd.hAdd n 2)).vertex j)","decl":"/-- Any inner horn contains the spine of the unique non-degenerate `n`-simplex\nin `Δ[n]`.-/\n@[simps]\ndef horn.spineId {n : ℕ} (i : Fin (n + 3))\n    (h₀ : 0 < i) (hₙ : i < Fin.last (n + 2)) :\n    Path Λ[n + 2, i] (n + 2) where\n  vertex j := ⟨stdSimplex.spineId _ |>.vertex j, (horn.const n i j _).property⟩\n  arrow j := ⟨stdSimplex.spineId _ |>.arrow j, by\n    let edge := horn.primitiveEdge h₀ hₙ j\n    have ha : (stdSimplex.spineId _).arrow j = edge.val := by\n      dsimp only [edge, stdSimplex.spineId, stdSimplex.id, spine_arrow,\n        mkOfSucc, horn.primitiveEdge, horn.edge, stdSimplex.edge,\n        stdSimplex.map_apply]\n      aesop\n    rw [ha]\n    exact edge.property⟩\n  arrow_src := by\n    simp only [horn, SimplicialObject.δ, Subtype.mk.injEq]\n    exact stdSimplex.spineId _ |>.arrow_src\n  arrow_tgt := by\n    simp only [horn, SimplicialObject.δ, Subtype.mk.injEq]\n    exact stdSimplex.spineId _ |>.arrow_tgt\n\n"}
{"name":"SSet.horn.spineId_arrow_coe","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 3)\nh₀ : LT.lt 0 i\nhₙ : LT.lt i (Fin.last (HAdd.hAdd n 2))\nj : Fin (HAdd.hAdd n 2)\n⊢ Eq (↑((SSet.horn.spineId i h₀ hₙ).arrow j)) ((SSet.stdSimplex.spineId (HAdd.hAdd n 2)).arrow j)","decl":"/-- Any inner horn contains the spine of the unique non-degenerate `n`-simplex\nin `Δ[n]`.-/\n@[simps]\ndef horn.spineId {n : ℕ} (i : Fin (n + 3))\n    (h₀ : 0 < i) (hₙ : i < Fin.last (n + 2)) :\n    Path Λ[n + 2, i] (n + 2) where\n  vertex j := ⟨stdSimplex.spineId _ |>.vertex j, (horn.const n i j _).property⟩\n  arrow j := ⟨stdSimplex.spineId _ |>.arrow j, by\n    let edge := horn.primitiveEdge h₀ hₙ j\n    have ha : (stdSimplex.spineId _).arrow j = edge.val := by\n      dsimp only [edge, stdSimplex.spineId, stdSimplex.id, spine_arrow,\n        mkOfSucc, horn.primitiveEdge, horn.edge, stdSimplex.edge,\n        stdSimplex.map_apply]\n      aesop\n    rw [ha]\n    exact edge.property⟩\n  arrow_src := by\n    simp only [horn, SimplicialObject.δ, Subtype.mk.injEq]\n    exact stdSimplex.spineId _ |>.arrow_src\n  arrow_tgt := by\n    simp only [horn, SimplicialObject.δ, Subtype.mk.injEq]\n    exact stdSimplex.spineId _ |>.arrow_tgt\n\n"}
{"name":"SSet.horn.spineId_map_hornInclusion","module":"Mathlib.AlgebraicTopology.SimplicialSet.Path","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 3)\nh₀ : LT.lt 0 i\nhₙ : LT.lt i (Fin.last (HAdd.hAdd n 2))\n⊢ Eq ((SSet.horn.spineId i h₀ hₙ).map (SSet.hornInclusion (HAdd.hAdd n 2) i)) (SSet.stdSimplex.spineId (HAdd.hAdd n 2))","decl":"@[simp]\nlemma horn.spineId_map_hornInclusion {n : ℕ} (i : Fin (n + 3))\n    (h₀ : 0 < i) (hₙ : i < Fin.last (n + 2)) :\n    Path.map (horn.spineId i h₀ hₙ) (hornInclusion (n + 2) i) =\n      stdSimplex.spineId (n + 2) := rfl\n\n"}
