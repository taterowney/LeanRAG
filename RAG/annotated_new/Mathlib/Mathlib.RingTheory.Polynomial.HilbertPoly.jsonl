{"name":"Polynomial.natDegree_preHilbertPoly","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\nd k : Nat\n⊢ Eq (Polynomial.preHilbertPoly F d k).natDegree d","decl":"lemma natDegree_preHilbertPoly [CharZero F] (d k : ℕ) :\n    (preHilbertPoly F d k).natDegree = d := by\n  have hne : (d ! : F) ≠ 0 := by norm_cast; positivity\n  rw [preHilbertPoly, natDegree_smul _ (inv_ne_zero hne), natDegree_comp, ascPochhammer_natDegree,\n    add_comm_sub, ← C_1, ← map_sub, natDegree_add_C, natDegree_X, mul_one]\n\n"}
{"name":"Polynomial.coeff_preHilbertPoly_self","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\nd k : Nat\n⊢ Eq ((Polynomial.preHilbertPoly F d k).coeff d) (Inv.inv ↑d.factorial)","decl":"lemma coeff_preHilbertPoly_self [CharZero F] (d k : ℕ) :\n    (preHilbertPoly F d k).coeff d = (d ! : F)⁻¹ := by\n  delta preHilbertPoly\n  have hne : (d ! : F) ≠ 0 := by norm_cast; positivity\n  have heq : d = ((ascPochhammer F d).comp (X - C (k : F) + 1)).natDegree :=\n    (natDegree_preHilbertPoly F d k).symm.trans (natDegree_smul _ (inv_ne_zero hne))\n  nth_rw 3 [heq]\n  calc\n  _ = (d ! : F)⁻¹ • ((ascPochhammer F d).comp (X - C ((k : F) - 1))).leadingCoeff := by\n    simp only [sub_add, ← C_1, ← map_sub, coeff_smul, coeff_natDegree]\n  _ = (d ! : F)⁻¹ := by\n    simp only [leadingCoeff_comp (ne_of_eq_of_ne (natDegree_X_sub_C _) one_ne_zero), Monic.def.1\n      (monic_ascPochhammer _ _), one_mul, leadingCoeff_X_sub_C, one_pow, smul_eq_mul, mul_one]\n\n"}
{"name":"Polynomial.leadingCoeff_preHilbertPoly","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\nd k : Nat\n⊢ Eq (Polynomial.preHilbertPoly F d k).leadingCoeff (Inv.inv ↑d.factorial)","decl":"lemma leadingCoeff_preHilbertPoly [CharZero F] (d k : ℕ) :\n    (preHilbertPoly F d k).leadingCoeff = (d ! : F)⁻¹ := by\n  rw [leadingCoeff, natDegree_preHilbertPoly, coeff_preHilbertPoly_self]\n\n"}
{"name":"Polynomial.preHilbertPoly_eq_choose_sub_add","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\nd k n : Nat\nhkn : LE.le k n\n⊢ Eq (Polynomial.eval (↑n) (Polynomial.preHilbertPoly F d k)) ↑((HAdd.hAdd (HSub.hSub n k) d).choose d)","decl":"lemma preHilbertPoly_eq_choose_sub_add [CharZero F] (d : ℕ) {k n : ℕ} (hkn : k ≤ n):\n    (preHilbertPoly F d k).eval (n : F) = (n - k + d).choose d := by\n  have : (d ! : F) ≠ 0 := by norm_cast; positivity\n  calc\n  _ = (↑d !)⁻¹ * eval (↑(n - k + 1)) (ascPochhammer F d) := by simp [cast_sub hkn, preHilbertPoly]\n  _ = (n - k + d).choose d := by\n    rw [ascPochhammer_nat_eq_natCast_ascFactorial];\n    field_simp [ascFactorial_eq_factorial_mul_choose]\n\n"}
{"name":"Polynomial.hilbertPoly_zero_left","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝ : Field F\nd : Nat\n⊢ Eq (Polynomial.hilbertPoly 0 d) 0","decl":"lemma hilbertPoly_zero_left (d : ℕ) : hilbertPoly (0 : F[X]) d = 0 := by\n  delta hilbertPoly; induction d with\n  | zero => simp only\n  | succ d _ => simp only [coeff_zero, zero_smul, Finset.sum_const_zero]\n\n"}
{"name":"Polynomial.hilbertPoly_zero_right","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝ : Field F\np : Polynomial F\n⊢ Eq (p.hilbertPoly 0) 0","decl":"lemma hilbertPoly_zero_right (p : F[X]) : hilbertPoly p 0 = 0 := rfl\n\n"}
{"name":"Polynomial.hilbertPoly_succ","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝ : Field F\np : Polynomial F\nd : Nat\n⊢ Eq (p.hilbertPoly (HAdd.hAdd d 1)) (p.support.sum fun i => HSMul.hSMul (p.coeff i) (Polynomial.preHilbertPoly F d i))","decl":"lemma hilbertPoly_succ (p : F[X]) (d : ℕ) :\n    hilbertPoly p (d + 1) = ∑ i ∈ p.support, (p.coeff i) • preHilbertPoly F d i := rfl\n\n"}
{"name":"Polynomial.hilbertPoly_X_pow_succ","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝ : Field F\nd k : Nat\n⊢ Eq ((HPow.hPow Polynomial.X k).hilbertPoly (HAdd.hAdd d 1)) (Polynomial.preHilbertPoly F d k)","decl":"lemma hilbertPoly_X_pow_succ (d k : ℕ) :\n    hilbertPoly ((X : F[X]) ^ k) (d + 1) = preHilbertPoly F d k := by\n  delta hilbertPoly; simp\n\n"}
{"name":"Polynomial.hilbertPoly_add_left","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝ : Field F\np q : Polynomial F\nd : Nat\n⊢ Eq ((HAdd.hAdd p q).hilbertPoly d) (HAdd.hAdd (p.hilbertPoly d) (q.hilbertPoly d))","decl":"lemma hilbertPoly_add_left (p q : F[X]) (d : ℕ) :\n    hilbertPoly (p + q) d = hilbertPoly p d + hilbertPoly q d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [add_zero]\n  | succ d _ =>\n      simp only [← coeff_add]\n      rw [← sum_def _ fun _ r => r • _]\n      exact sum_add_index _ _ _ (fun _ => zero_smul ..) (fun _ _ _ => add_smul ..)\n\n"}
{"name":"Polynomial.hilbertPoly_smul","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝ : Field F\na : F\np : Polynomial F\nd : Nat\n⊢ Eq ((HSMul.hSMul a p).hilbertPoly d) (HSMul.hSMul a (p.hilbertPoly d))","decl":"lemma hilbertPoly_smul (a : F) (p : F[X]) (d : ℕ) :\n    hilbertPoly (a • p) d = a • hilbertPoly p d := by\n  delta hilbertPoly\n  induction d with\n  | zero => simp only [smul_zero]\n  | succ d _ =>\n      simp only\n      rw [← sum_def _ fun _ r => r • _, ← sum_def _ fun _ r => r • _, Polynomial.smul_sum,\n        sum_smul_index' _ _ _ fun i => zero_smul F (preHilbertPoly F d i)]\n      simp only [smul_assoc]\n\n"}
{"name":"Polynomial.coeff_mul_invOneSubPow_eq_hilbertPoly_eval","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\np : Polynomial F\nd n : Nat\nhn : LT.lt p.natDegree n\n⊢ Eq ((PowerSeries.coeff F n) (HMul.hMul ↑p ↑(PowerSeries.invOneSubPow F d))) (Polynomial.eval (↑n) (p.hilbertPoly d))","decl":"/--\nThe key property of Hilbert polynomials. If `F` is a field with characteristic `0`, `p : F[X]` and\n`d : ℕ`, then for any large enough `n : ℕ`, `(Polynomial.hilbertPoly p d).eval (n : F)` equals the\ncoefficient of `Xⁿ` in the power series expansion of `p/(1 - X)ᵈ`.\n-/\ntheorem coeff_mul_invOneSubPow_eq_hilbertPoly_eval\n    {p : F[X]} (d : ℕ) {n : ℕ} (hn : p.natDegree < n) :\n    PowerSeries.coeff F n (p * invOneSubPow F d) = (hilbertPoly p d).eval (n : F) := by\n  delta hilbertPoly; induction d with\n  | zero => simp only [invOneSubPow_zero, Units.val_one, mul_one, coeff_coe, eval_zero]\n            exact coeff_eq_zero_of_natDegree_lt hn\n  | succ d hd =>\n      simp only [eval_finset_sum, eval_smul, smul_eq_mul]\n      rw [← Finset.sum_coe_sort]\n      have h_le (i : p.support) : (i : ℕ) ≤ n :=\n        le_trans (le_natDegree_of_ne_zero <| mem_support_iff.1 i.2) hn.le\n      have h (i : p.support) : eval ↑n (preHilbertPoly F d ↑i) = (n + d - ↑i).choose d := by\n        rw [preHilbertPoly_eq_choose_sub_add _ _ (h_le i), Nat.sub_add_comm (h_le i)]\n      simp_rw [h]\n      rw [Finset.sum_coe_sort _ (fun x => (p.coeff ↑x) * (_ + d - ↑x).choose _),\n        PowerSeries.coeff_mul, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk,\n        invOneSubPow_val_eq_mk_sub_one_add_choose_of_pos _ _ (zero_lt_succ d)]\n      simp only [coeff_coe, coeff_mk]\n      symm\n      refine Finset.sum_subset_zero_on_sdiff (fun s hs ↦ ?_) (fun x hx ↦ ?_) (fun x hx ↦ ?_)\n      · rw [Finset.mem_range_succ_iff]\n        exact h_le ⟨s, hs⟩\n      · simp only [Finset.mem_sdiff, mem_support_iff, not_not] at hx\n        rw [hx.2, zero_mul]\n      · rw [add_comm, Nat.add_sub_assoc (h_le ⟨x, hx⟩), succ_eq_add_one, add_tsub_cancel_right]\n\n"}
{"name":"Polynomial.existsUnique_hilbertPoly","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\np : Polynomial F\nd : Nat\n⊢ ExistsUnique fun h => Exists fun N => ∀ (n : Nat), GT.gt n N → Eq ((PowerSeries.coeff F n) (HMul.hMul ↑p ↑(PowerSeries.invOneSubPow F d))) (Polynomial.eval (↑n) h)","decl":"/--\nThe polynomial satisfying the key property of `Polynomial.hilbertPoly p d` is unique.\n-/\ntheorem existsUnique_hilbertPoly (p : F[X]) (d : ℕ) :\n    ∃! h : F[X], ∃ N : ℕ, ∀ n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F) := by\n  use hilbertPoly p d; constructor\n  · use p.natDegree\n    exact fun n => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d\n  · rintro h ⟨N, hhN⟩\n    apply eq_of_infinite_eval_eq h (hilbertPoly p d)\n    apply ((Set.Ioi_infinite (max N p.natDegree)).image cast_injective.injOn).mono\n    rintro x ⟨n, hn, rfl⟩\n    simp only [Set.mem_Ioi, sup_lt_iff, Set.mem_setOf_eq] at hn ⊢\n    rw [← coeff_mul_invOneSubPow_eq_hilbertPoly_eval d hn.2, hhN n hn.1]\n\n"}
{"name":"Polynomial.exists_unique_hilbertPoly","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\np : Polynomial F\nd : Nat\n⊢ ExistsUnique fun h => Exists fun N => ∀ (n : Nat), GT.gt n N → Eq ((PowerSeries.coeff F n) (HMul.hMul ↑p ↑(PowerSeries.invOneSubPow F d))) (Polynomial.eval (↑n) h)","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_hilbertPoly := existsUnique_hilbertPoly\n\n"}
{"name":"Polynomial.eq_hilbertPoly_of_forall_coeff_eq_eval","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\np h : Polynomial F\nd N : Nat\nhhN : ∀ (n : Nat), GT.gt n N → Eq ((PowerSeries.coeff F n) (HMul.hMul ↑p ↑(PowerSeries.invOneSubPow F d))) (Polynomial.eval (↑n) h)\n⊢ Eq h (p.hilbertPoly d)","decl":"/--\nIf `h : F[X]` and there exists some `N : ℕ` such that for any number `n : ℕ` bigger than `N`\nwe have `PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)`, then `h` is exactly\n`Polynomial.hilbertPoly p d`.\n-/\ntheorem eq_hilbertPoly_of_forall_coeff_eq_eval\n    {p h : F[X]} {d : ℕ} (N : ℕ) (hhN : ∀ n > N,\n    PowerSeries.coeff F n (p * invOneSubPow F d) = h.eval (n : F)) :\n    h = hilbertPoly p d :=\n  ExistsUnique.unique (existsUnique_hilbertPoly p d) ⟨N, hhN⟩\n    ⟨p.natDegree, fun _ x => coeff_mul_invOneSubPow_eq_hilbertPoly_eval d x⟩\n\n"}
{"name":"Polynomial.hilbertPoly_mul_one_sub_succ","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\np : Polynomial F\nd : Nat\n⊢ Eq ((HMul.hMul p (HSub.hSub 1 Polynomial.X)).hilbertPoly (HAdd.hAdd d 1)) (p.hilbertPoly d)","decl":"lemma hilbertPoly_mul_one_sub_succ (p : F[X]) (d : ℕ) :\n    hilbertPoly (p * (1 - X)) (d + 1) = hilbertPoly p d := by\n  apply eq_hilbertPoly_of_forall_coeff_eq_eval (p * (1 - X)).natDegree\n  intro n hn\n  have heq : 1 - PowerSeries.X = ((1 - X : F[X]) : F⟦X⟧) := by simp only [coe_sub, coe_one, coe_X]\n  rw [← one_sub_pow_mul_invOneSubPow_val_add_eq_invOneSubPow_val F d 1, pow_one, ← mul_assoc, heq,\n    ← coe_mul, coeff_mul_invOneSubPow_eq_hilbertPoly_eval (d + 1) hn]\n\n"}
{"name":"Polynomial.hilbertPoly_mul_one_sub_pow_add","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\np : Polynomial F\nd e : Nat\n⊢ Eq ((HMul.hMul p (HPow.hPow (HSub.hSub 1 Polynomial.X) e)).hilbertPoly (HAdd.hAdd d e)) (p.hilbertPoly d)","decl":"lemma hilbertPoly_mul_one_sub_pow_add (p : F[X]) (d e : ℕ) :\n    hilbertPoly (p * (1 - X) ^ e) (d + e) = hilbertPoly p d := by\n  induction e with\n  | zero => simp\n  | succ e he => rw [pow_add, pow_one, ← mul_assoc, ← add_assoc, hilbertPoly_mul_one_sub_succ, he]\n\n"}
{"name":"Polynomial.hilbertPoly_eq_zero_of_le_rootMultiplicity_one","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\np : Polynomial F\nd : Nat\nhdp : LE.le d (Polynomial.rootMultiplicity 1 p)\n⊢ Eq (p.hilbertPoly d) 0","decl":"lemma hilbertPoly_eq_zero_of_le_rootMultiplicity_one\n    {p : F[X]} {d : ℕ} (hdp : d ≤ p.rootMultiplicity 1) :\n    hilbertPoly p d = 0 := by\n  by_cases hp : p = 0\n  · rw [hp, hilbertPoly_zero_left]\n  · rcases exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp 1 with ⟨q, hq1, hq2⟩\n    have heq : p = q * (- 1) ^ p.rootMultiplicity 1 * (1 - X) ^ p.rootMultiplicity 1 := by\n      simp only [mul_assoc, ← mul_pow, neg_mul, one_mul, neg_sub]\n      exact hq1.trans (mul_comm _ _)\n    rw [heq, ← zero_add d, ← Nat.sub_add_cancel hdp, pow_add (1 - X), ← mul_assoc,\n      hilbertPoly_mul_one_sub_pow_add, hilbertPoly]\n\n"}
{"name":"Polynomial.natDegree_hilbertPoly_of_ne_zero_of_rootMultiplicity_lt","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\np : Polynomial F\nd : Nat\nhp : Ne p 0\nhpd : LT.lt (Polynomial.rootMultiplicity 1 p) d\n⊢ Eq (p.hilbertPoly d).natDegree (HSub.hSub (HSub.hSub d (Polynomial.rootMultiplicity 1 p)) 1)","decl":"theorem natDegree_hilbertPoly_of_ne_zero_of_rootMultiplicity_lt\n    {p : F[X]} {d : ℕ} (hp : p ≠ 0) (hpd : p.rootMultiplicity 1 < d) :\n    (hilbertPoly p d).natDegree = d - p.rootMultiplicity 1 - 1 := by\n  rcases exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp 1 with ⟨q, hq1, hq2⟩\n  have heq : p = q * (- 1) ^ p.rootMultiplicity 1 * (1 - X) ^ p.rootMultiplicity 1 := by\n    simp only [mul_assoc, ← mul_pow, neg_mul, one_mul, neg_sub]\n    exact hq1.trans (mul_comm _ _)\n  nth_rw 1 [heq, ← Nat.sub_add_cancel (le_of_lt hpd), hilbertPoly_mul_one_sub_pow_add,\n    ← Nat.sub_add_cancel (Nat.le_sub_of_add_le' <| add_one_le_of_lt hpd)]\n  delta hilbertPoly\n  apply natDegree_eq_of_le_of_coeff_ne_zero\n  · apply natDegree_sum_le_of_forall_le _ _ <| fun _ _ => ?_\n    apply le_trans (natDegree_smul_le _ _)\n    rw [natDegree_preHilbertPoly]\n  · have : (fun (x : ℕ) (a : F) => a) = fun x a => a * 1 ^ x := by simp only [one_pow, mul_one]\n    simp only [finset_sum_coeff, coeff_smul, smul_eq_mul, coeff_preHilbertPoly_self,\n      ← Finset.sum_mul, ← sum_def _ (fun _ a => a), this, ← eval_eq_sum, eval_mul, eval_pow,\n      eval_neg, eval_one, _root_.mul_eq_zero, pow_eq_zero_iff', neg_eq_zero, one_ne_zero, ne_eq,\n      false_and, or_false, inv_eq_zero, cast_eq_zero, not_or]\n    exact ⟨(not_iff_not.2 dvd_iff_isRoot).1 hq2, factorial_ne_zero _⟩\n\n"}
{"name":"Polynomial.natDegree_hilbertPoly_of_ne_zero","module":"Mathlib.RingTheory.Polynomial.HilbertPoly","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : CharZero F\np : Polynomial F\nd : Nat\nhh : Ne (p.hilbertPoly d) 0\n⊢ Eq (p.hilbertPoly d).natDegree (HSub.hSub (HSub.hSub d (Polynomial.rootMultiplicity 1 p)) 1)","decl":"theorem natDegree_hilbertPoly_of_ne_zero\n    {p : F[X]} {d : ℕ} (hh : hilbertPoly p d ≠ 0) :\n    (hilbertPoly p d).natDegree = d - p.rootMultiplicity 1 - 1 := by\n  have hp : p ≠ 0 := by\n    intro h\n    rw [h] at hh\n    exact hh (hilbertPoly_zero_left d)\n  have hpd : p.rootMultiplicity 1 < d := by\n    by_contra h\n    exact hh (hilbertPoly_eq_zero_of_le_rootMultiplicity_one <| not_lt.1 h)\n  exact natDegree_hilbertPoly_of_ne_zero_of_rootMultiplicity_lt hp hpd\n\n"}
