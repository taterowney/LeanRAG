{"name":"CategoryTheory.Limits.PreservesLimit.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesLimit K F\nc : CategoryTheory.Limits.Cone K\nhc : CategoryTheory.Limits.IsLimit c\n‚ä¢ Nonempty (CategoryTheory.Limits.IsLimit (F.mapCone c))","decl":"/-- A functor `F` preserves limits of `K` (written as `PreservesLimit K F`)\nif `F` maps any limit cone over `K` to a limit cone.\n-/\nclass PreservesLimit (K : J ‚•§ C) (F : C ‚•§ D) : Prop where\n  preserves {c : Cone K} (hc : IsLimit c) : Nonempty (IsLimit (F.mapCone c))\n\n"}
{"name":"CategoryTheory.Limits.PreservesColimit.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesColimit K F\nc : CategoryTheory.Limits.Cocone K\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Nonempty (CategoryTheory.Limits.IsColimit (F.mapCocone c))","decl":"/-- A functor `F` preserves colimits of `K` (written as `PreservesColimit K F`)\nif `F` maps any colimit cocone over `K` to a colimit cocone.\n-/\nclass PreservesColimit (K : J ‚•§ C) (F : C ‚•§ D) : Prop where\n  preserves {c : Cocone K} (hc : IsColimit c) : Nonempty (IsColimit (F.mapCocone c))\n\n"}
{"name":"CategoryTheory.Limits.PreservesLimitsOfShape.preservesLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesLimitsOfShape J F\nK : CategoryTheory.Functor J C\n‚ä¢ CategoryTheory.Limits.PreservesLimit K F","decl":"/-- We say that `F` preserves limits of shape `J` if `F` preserves limits for every diagram\n    `K : J ‚•§ C`, i.e., `F` maps limit cones over `K` to limit cones. -/\nclass PreservesLimitsOfShape (J : Type w) [Category.{w'} J] (F : C ‚•§ D) : Prop where\n  preservesLimit : ‚àÄ {K : J ‚•§ C}, PreservesLimit K F := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.PreservesColimitsOfShape.preservesColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesColimitsOfShape J F\nK : CategoryTheory.Functor J C\n‚ä¢ CategoryTheory.Limits.PreservesColimit K F","decl":"/-- We say that `F` preserves colimits of shape `J` if `F` preserves colimits for every diagram\n    `K : J ‚•§ C`, i.e., `F` maps colimit cocones over `K` to colimit cocones. -/\nclass PreservesColimitsOfShape (J : Type w) [Category.{w'} J] (F : C ‚•§ D) : Prop where\n  preservesColimit : ‚àÄ {K : J ‚•§ C}, PreservesColimit K F := by infer_instance\n\n-- This should be used with explicit universe variables.\n"}
{"name":"CategoryTheory.Limits.PreservesLimitsOfSize.preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- `PreservesLimitsOfSize.{v u} F` means that `F` sends all limit cones over any\ndiagram `J ‚•§ C` to limit cones, where `J : Type u` with `[Category.{v} J]`. -/\n@[nolint checkUnivs, pp_with_univ]\nclass PreservesLimitsOfSize (F : C ‚•§ D) : Prop where\n  preservesLimitsOfShape : ‚àÄ {J : Type w} [Category.{w'} J], PreservesLimitsOfShape J F := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.PreservesColimitsOfSize.preservesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- `PreservesColimitsOfSize.{v u} F` means that `F` sends all colimit cocones over any\ndiagram `J ‚•§ C` to colimit cocones, where `J : Type u` with `[Category.{v} J]`. -/\n@[nolint checkUnivs, pp_with_univ]\nclass PreservesColimitsOfSize (F : C ‚•§ D) : Prop where\n  preservesColimitsOfShape : ‚àÄ {J : Type w} [Category.{w'} J], PreservesColimitsOfShape J F := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.PreservesLimit K F)","decl":"instance preservesLimit_subsingleton (K : J ‚•§ C) (F : C ‚•§ D) :\n    Subsingleton (PreservesLimit K F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.PreservesColimit K F)","decl":"instance preservesColimit_subsingleton (K : J ‚•§ C) (F : C ‚•§ D) :\n    Subsingleton (PreservesColimit K F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.PreservesLimitsOfShape J F)","decl":"instance preservesLimitsOfShape_subsingleton (J : Type w) [Category.{w'} J] (F : C ‚•§ D) :\n    Subsingleton (PreservesLimitsOfShape J F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.PreservesColimitsOfShape J F)","decl":"instance preservesColimitsOfShape_subsingleton (J : Type w) [Category.{w'} J] (F : C ‚•§ D) :\n    Subsingleton (PreservesColimitsOfShape J F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F)","decl":"instance preservesLimitsOfSize_subsingleton (F : C ‚•§ D) :\n    Subsingleton (PreservesLimitsOfSize.{w', w} F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F)","decl":"instance preservesColimitsOfSize_subsingleton (F : C ‚•§ D) :\n    Subsingleton (PreservesColimitsOfSize.{w', w} F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.id_preservesLimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (CategoryTheory.Functor.id C)","decl":"instance id_preservesLimitsOfSize : PreservesLimitsOfSize.{w', w} (ùü≠ C) where\n  preservesLimitsOfShape {J} ùí• :=\n    {\n      preservesLimit := fun {K} =>\n        ‚ü®fun {c} h =>\n          ‚ü®fun s => h.lift ‚ü®s.pt, fun j => s.œÄ.app j, fun _ _ f => s.œÄ.naturality f‚ü©, by\n            cases K; rcases c with ‚ü®_, _, _‚ü©; intro s j; cases s; exact h.fac _ j, by\n            cases K; rcases c with ‚ü®_, _, _‚ü©; intro s m w; rcases s with ‚ü®_, _, _‚ü©;\n              exact h.uniq _ m w‚ü©‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.idPreservesLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (CategoryTheory.Functor.id C)","decl":"@[deprecated \"use id_preservesLimitsOfSize\" (since := \"2024-11-19\")]\nlemma idPreservesLimits : PreservesLimitsOfSize.{w', w} (ùü≠ C) :=\n  id_preservesLimitsOfSize\n\n"}
{"name":"CategoryTheory.Limits.id_preservesColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (CategoryTheory.Functor.id C)","decl":"instance id_preservesColimitsOfSize : PreservesColimitsOfSize.{w', w} (ùü≠ C) where\n  preservesColimitsOfShape {J} ùí• :=\n    {\n      preservesColimit := fun {K} =>\n        ‚ü®fun {c} h =>\n          ‚ü®fun s => h.desc ‚ü®s.pt, fun j => s.Œπ.app j, fun _ _ f => s.Œπ.naturality f‚ü©, by\n            cases K; rcases c with ‚ü®_, _, _‚ü©; intro s j; cases s; exact h.fac _ j, by\n            cases K; rcases c with ‚ü®_, _, _‚ü©; intro s m w; rcases s with ‚ü®_, _, _‚ü©;\n              exact h.uniq _ m w‚ü©‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.idPreservesColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (CategoryTheory.Functor.id C)","decl":"@[deprecated \"use id_preservesColimitsOfSize\" (since := \"2024-11-19\")]\nlemma idPreservesColimits : PreservesColimitsOfSize.{w', w} (ùü≠ C) :=\n  id_preservesColimitsOfSize\n\n"}
{"name":"CategoryTheory.Limits.instHasLimitCompOfPreservesLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\ninst‚úù¬π : CategoryTheory.Limits.HasLimit K\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimit K F\n‚ä¢ CategoryTheory.Limits.HasLimit (K.comp F)","decl":"instance [HasLimit K] {F : C ‚•§ D} [PreservesLimit K F] : HasLimit (K ‚ãô F) where\n  exists_limit := ‚ü®_, isLimitOfPreserves F (limit.isLimit K)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.instHasColimitCompOfPreservesColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit K\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesColimit K F\n‚ä¢ CategoryTheory.Limits.HasColimit (K.comp F)","decl":"instance [HasColimit K] {F : C ‚•§ D} [PreservesColimit K F] : HasColimit (K ‚ãô F) where\n  exists_colimit := ‚ü®_, isColimitOfPreserves F (colimit.isColimit K)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimit K F\ninst‚úù : CategoryTheory.Limits.PreservesLimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.PreservesLimit K (F.comp G)","decl":"instance comp_preservesLimit [PreservesLimit K F] [PreservesLimit (K ‚ãô F) G] :\n    PreservesLimit K (F ‚ãô G) where\n  preserves hc := ‚ü®isLimitOfPreserves G (isLimitOfPreserves F hc)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfShape J F\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J (F.comp G)","decl":"instance comp_preservesLimitsOfShape [PreservesLimitsOfShape J F] [PreservesLimitsOfShape J G] :\n    PreservesLimitsOfShape J (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)","decl":"instance comp_preservesLimits [PreservesLimitsOfSize.{w', w} F] [PreservesLimitsOfSize.{w', w} G] :\n    PreservesLimitsOfSize.{w', w} (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit K F\ninst‚úù : CategoryTheory.Limits.PreservesColimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.PreservesColimit K (F.comp G)","decl":"instance comp_preservesColimit [PreservesColimit K F] [PreservesColimit (K ‚ãô F) G] :\n    PreservesColimit K (F ‚ãô G) where\n  preserves hc := ‚ü®isColimitOfPreserves G (isColimitOfPreserves F hc)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape J F\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J (F.comp G)","decl":"instance comp_preservesColimitsOfShape [PreservesColimitsOfShape J F]\n    [PreservesColimitsOfShape J G] : PreservesColimitsOfShape J (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)","decl":"instance comp_preservesColimits [PreservesColimitsOfSize.{w', w} F]\n    [PreservesColimitsOfSize.{w', w} G] : PreservesColimitsOfSize.{w', w} (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Limits.compPreservesLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimit K F\ninst‚úù : CategoryTheory.Limits.PreservesLimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.PreservesLimit K (F.comp G)","decl":"@[deprecated \"use comp_preservesLimit\" (since := \"2024-11-19\")]\nlemma compPreservesLimit [PreservesLimit K F] [PreservesLimit (K ‚ãô F) G] :\n    PreservesLimit K (F ‚ãô G) := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.compPreservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfShape J F\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J (F.comp G)","decl":"@[deprecated \"use comp_preservesLimitsOfShape\" (since := \"2024-11-19\")]\nlemma compPreservesLimitsOfShape [PreservesLimitsOfShape J F] [PreservesLimitsOfShape J G] :\n    PreservesLimitsOfShape J (F ‚ãô G) :=\n  comp_preservesLimitsOfShape _ _\n\n"}
{"name":"CategoryTheory.Limits.compPreservesLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)","decl":"@[deprecated \"use comp_preservesLimits\" (since := \"2024-11-19\")]\nlemma compPreservesLimits [PreservesLimitsOfSize.{w', w} F] [PreservesLimitsOfSize.{w', w} G] :\n    PreservesLimitsOfSize.{w', w} (F ‚ãô G) :=\n  comp_preservesLimits _ _\n\n"}
{"name":"CategoryTheory.Limits.compPreservesColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit K F\ninst‚úù : CategoryTheory.Limits.PreservesColimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.PreservesColimit K (F.comp G)","decl":"@[deprecated \"use comp_preservesColimit\" (since := \"2024-11-19\")]\nlemma compPreservesColimit [PreservesColimit K F] [PreservesColimit (K ‚ãô F) G] :\n    PreservesColimit K (F ‚ãô G) := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.compPreservesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape J F\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J (F.comp G)","decl":"@[deprecated \"use comp_preservesColimitsOfShape\" (since := \"2024-11-19\")]\nlemma compPreservesColimitsOfShape [PreservesColimitsOfShape J F] [PreservesColimitsOfShape J G] :\n    PreservesColimitsOfShape J (F ‚ãô G) :=\n  comp_preservesColimitsOfShape _ _\n\n"}
{"name":"CategoryTheory.Limits.compPreservesColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)","decl":"@[deprecated \"use comp_preservesColimits\" (since := \"2024-11-19\")]\nlemma compPreservesColimits [PreservesColimitsOfSize.{w', w} F]\n    [PreservesColimitsOfSize.{w', w} G] :\n    PreservesColimitsOfSize.{w', w} (F ‚ãô G) :=\n  comp_preservesColimits _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_preserves_limit_cone","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cone K\nh : CategoryTheory.Limits.IsLimit t\nhF : CategoryTheory.Limits.IsLimit (F.mapCone t)\n‚ä¢ CategoryTheory.Limits.PreservesLimit K F","decl":"/-- If F preserves one limit cone for the diagram K,\n  then it preserves any limit cone for K. -/\nlemma preservesLimit_of_preserves_limit_cone {F : C ‚•§ D} {t : Cone K} (h : IsLimit t)\n    (hF : IsLimit (F.mapCone t)) : PreservesLimit K F where\n  preserves h' := ‚ü®IsLimit.ofIsoLimit hF (Functor.mapIso _ (IsLimit.uniqueUpToIso h h'))‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitOfPreservesLimitCone","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cone K\nh : CategoryTheory.Limits.IsLimit t\nhF : CategoryTheory.Limits.IsLimit (F.mapCone t)\n‚ä¢ CategoryTheory.Limits.PreservesLimit K F","decl":"@[deprecated \"use preservesLimit_of_preserves_limit_cone\" (since := \"2024-11-19\")]\nlemma preservesLimitOfPreservesLimitCone {F : C ‚•§ D} {t : Cone K} (h : IsLimit t)\n    (hF : IsLimit (F.mapCone t)) : PreservesLimit K F :=\npreservesLimit_of_preserves_limit_cone h hF\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_iso_diagram","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK‚ÇÅ K‚ÇÇ : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Iso K‚ÇÅ K‚ÇÇ\ninst‚úù : CategoryTheory.Limits.PreservesLimit K‚ÇÅ F\n‚ä¢ CategoryTheory.Limits.PreservesLimit K‚ÇÇ F","decl":"/-- Transfer preservation of limits along a natural isomorphism in the diagram. -/\nlemma preservesLimit_of_iso_diagram {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ)\n    [PreservesLimit K‚ÇÅ F] : PreservesLimit K‚ÇÇ F where\n  preserves {c} t := ‚ü®by\n    apply IsLimit.postcomposeInvEquiv (isoWhiskerRight h F :) _ _\n    have := (IsLimit.postcomposeInvEquiv h c).symm t\n    apply IsLimit.ofIsoLimit (isLimitOfPreserves F this)\n    exact Cones.ext (Iso.refl _)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitOfIsoDiagram","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK‚ÇÅ K‚ÇÇ : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Iso K‚ÇÅ K‚ÇÇ\ninst‚úù : CategoryTheory.Limits.PreservesLimit K‚ÇÅ F\n‚ä¢ CategoryTheory.Limits.PreservesLimit K‚ÇÇ F","decl":"@[deprecated \"use preservesLimit_of_iso_diagram\" (since := \"2024-11-19\")]\nlemma preservesLimitOfIsoDiagram {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ)\n    [PreservesLimit K‚ÇÅ F] : PreservesLimit K‚ÇÇ F :=\n  preservesLimit_of_iso_diagram F h\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesLimit K F\n‚ä¢ CategoryTheory.Limits.PreservesLimit K G","decl":"/-- Transfer preservation of a limit along a natural isomorphism in the functor. -/\nlemma preservesLimit_of_natIso (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesLimit K F] :\n    PreservesLimit K G where\n  preserves t := ‚ü®IsLimit.mapConeEquiv h (isLimitOfPreserves F t)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesLimit K F\n‚ä¢ CategoryTheory.Limits.PreservesLimit K G","decl":"@[deprecated \"use preservesLimit_of_natIso\" (since := \"2024-11-19\")]\nlemma preservesLimitOfNatIso (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesLimit K F] :\n    PreservesLimit K G :=\n  preservesLimit_of_natIso K h\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J G","decl":"/-- Transfer preservation of limits of shape along a natural isomorphism in the functor. -/\nlemma preservesLimitsOfShape_of_natIso {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesLimitsOfShape J F] :\n    PreservesLimitsOfShape J G where\n  preservesLimit {K} := preservesLimit_of_natIso K h\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShapeOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J G","decl":"@[deprecated \"use preservesLimitsOfShape_of_natIso\" (since := \"2024-11-19\")]\nlemma preservesLimitsOfShapeOfNatIso {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesLimitsOfShape J F] :\n    PreservesLimitsOfShape J G :=\n  preservesLimitsOfShape_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"/-- Transfer preservation of limits along a natural isomorphism in the functor. -/\nlemma preservesLimits_of_natIso {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesLimitsOfSize.{w, w'} F] :\n    PreservesLimitsOfSize.{w, w'} G where\n  preservesLimitsOfShape := preservesLimitsOfShape_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"@[deprecated \"use preservesLimits_of_natIso\" (since := \"2024-11-19\")]\nlemma preservesLimitsOfNatIso {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesLimitsOfSize.{w, w'} F] :\n    PreservesLimitsOfSize.{w, w'} G :=\n  preservesLimits_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_of_equiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nJ' : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÇ', w‚ÇÇ} J'\ne : CategoryTheory.Equivalence J J'\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J' F","decl":"/-- Transfer preservation of limits along an equivalence in the shape. -/\nlemma preservesLimitsOfShape_of_equiv {J' : Type w‚ÇÇ} [Category.{w‚ÇÇ'} J'] (e : J ‚âå J') (F : C ‚•§ D)\n    [PreservesLimitsOfShape J F] : PreservesLimitsOfShape J' F where\n  preservesLimit {K} :=\n    { preserves := fun {c} t => ‚ü®by\n        let equ := e.invFunIdAssoc (K ‚ãô F)\n        have := (isLimitOfPreserves F (t.whiskerEquivalence e)).whiskerEquivalence e.symm\n        apply ((IsLimit.postcomposeHomEquiv equ _).symm this).ofIsoLimit\n        refine Cones.ext (Iso.refl _) fun j => ?_\n        dsimp\n        simp [equ, ‚Üê Functor.map_comp]‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShapeOfEquiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nJ' : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÇ', w‚ÇÇ} J'\ne : CategoryTheory.Equivalence J J'\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J' F","decl":"@[deprecated \"use preservesLimitsOfShape_of_equiv\" (since := \"2024-11-19\")]\nlemma preservesLimitsOfShapeOfEquiv {J' : Type w‚ÇÇ} [Category.{w‚ÇÇ'} J'] (e : J ‚âå J') (F : C ‚•§ D)\n    [PreservesLimitsOfShape J F] : PreservesLimitsOfShape J' F :=\n  preservesLimitsOfShape_of_equiv e F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : UnivLE.{w, w'}\ninst‚úù¬π : UnivLE.{w‚ÇÇ, w‚ÇÇ'}\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w‚ÇÇ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- A functor preserving larger limits also preserves smaller limits. -/\nlemma preservesLimitsOfSize_of_univLE (F : C ‚•§ D) [UnivLE.{w, w'}] [UnivLE.{w‚ÇÇ, w‚ÇÇ'}]\n    [PreservesLimitsOfSize.{w', w‚ÇÇ'} F] : PreservesLimitsOfSize.{w, w‚ÇÇ} F where\n  preservesLimitsOfShape {J} := preservesLimitsOfShape_of_equiv\n    ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSizeOfUnivLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : UnivLE.{w, w'}\ninst‚úù¬π : UnivLE.{w‚ÇÇ, w‚ÇÇ'}\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w‚ÇÇ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use preservesLimitsOfSize_of_univLE\" (since := \"2024-11-19\")]\nlemma preservesLimitsOfSizeOfUnivLE (F : C ‚•§ D) [UnivLE.{w, w'}] [UnivLE.{w‚ÇÇ, w‚ÇÇ'}]\n    [PreservesLimitsOfSize.{w', w‚ÇÇ'} F] : PreservesLimitsOfSize.{w, w‚ÇÇ} F :=\n  preservesLimitsOfSize_of_univLE.{w', w‚ÇÇ'} F\n\n-- See library note [dsimp, simp].\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- `PreservesLimitsOfSize_shrink.{w w'} F` tries to obtain `PreservesLimitsOfSize.{w w'} F`\nfrom some other `PreservesLimitsOfSize F`.\n-/\nlemma preservesLimitsOfSize_shrink (F : C ‚•§ D) [PreservesLimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ'} F] :\n    PreservesLimitsOfSize.{w, w'} F := preservesLimitsOfSize_of_univLE.{max w w‚ÇÇ, max w' w‚ÇÇ'} F\n\n"}
{"name":"CategoryTheory.Limits.PreservesLimitsOfSizeShrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use preservesLimitsOfSize_shrink\" (since := \"2024-11-19\")]\nlemma PreservesLimitsOfSizeShrink (F : C ‚•§ D) [PreservesLimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ'} F] :\n    PreservesLimitsOfSize.{w, w'} F :=\n  preservesLimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.preservesSmallestLimits_of_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{v‚ÇÉ, u‚ÇÉ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- Preserving limits at any universe level implies preserving limits in universe `0`. -/\nlemma preservesSmallestLimits_of_preservesLimits (F : C ‚•§ D) [PreservesLimitsOfSize.{v‚ÇÉ, u‚ÇÉ} F] :\n    PreservesLimitsOfSize.{0, 0} F :=\n  preservesLimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.preservesSmallestLimitsOfPreservesLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{v‚ÇÉ, u‚ÇÉ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use preservesSmallestLimits_of_preservesLimits\" (since := \"2024-11-19\")]\nlemma preservesSmallestLimitsOfPreservesLimits (F : C ‚•§ D) [PreservesLimitsOfSize.{v‚ÇÉ, u‚ÇÉ} F] :\n    PreservesLimitsOfSize.{0, 0} F :=\n  preservesSmallestLimits_of_preservesLimits F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_preserves_colimit_cocone","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cocone K\nh : CategoryTheory.Limits.IsColimit t\nhF : CategoryTheory.Limits.IsColimit (F.mapCocone t)\n‚ä¢ CategoryTheory.Limits.PreservesColimit K F","decl":"/-- If F preserves one colimit cocone for the diagram K,\n  then it preserves any colimit cocone for K. -/\nlemma preservesColimit_of_preserves_colimit_cocone {F : C ‚•§ D} {t : Cocone K} (h : IsColimit t)\n    (hF : IsColimit (F.mapCocone t)) : PreservesColimit K F :=\n  ‚ü®fun h' => ‚ü®IsColimit.ofIsoColimit hF (Functor.mapIso _ (IsColimit.uniqueUpToIso h h'))‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitOfPreservesColimitCocone","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nt : CategoryTheory.Limits.Cocone K\nh : CategoryTheory.Limits.IsColimit t\nhF : CategoryTheory.Limits.IsColimit (F.mapCocone t)\n‚ä¢ CategoryTheory.Limits.PreservesColimit K F","decl":"@[deprecated \"use preservesColimit_of_preserves_colimit_cocone\" (since := \"2024-11-19\")]\nlemma preservesColimitOfPreservesColimitCocone {F : C ‚•§ D} {t : Cocone K} (h : IsColimit t)\n    (hF : IsColimit (F.mapCocone t)) : PreservesColimit K F :=\npreservesColimit_of_preserves_colimit_cocone h hF\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_iso_diagram","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK‚ÇÅ K‚ÇÇ : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Iso K‚ÇÅ K‚ÇÇ\ninst‚úù : CategoryTheory.Limits.PreservesColimit K‚ÇÅ F\n‚ä¢ CategoryTheory.Limits.PreservesColimit K‚ÇÇ F","decl":"/-- Transfer preservation of colimits along a natural isomorphism in the shape. -/\nlemma preservesColimit_of_iso_diagram {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ)\n    [PreservesColimit K‚ÇÅ F] :\n    PreservesColimit K‚ÇÇ F where\n  preserves {c} t := ‚ü®by\n    apply IsColimit.precomposeHomEquiv (isoWhiskerRight h F :) _ _\n    have := (IsColimit.precomposeHomEquiv h c).symm t\n    apply IsColimit.ofIsoColimit (isColimitOfPreserves F this)\n    exact Cocones.ext (Iso.refl _)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitOfIsoDiagram","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK‚ÇÅ K‚ÇÇ : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Iso K‚ÇÅ K‚ÇÇ\ninst‚úù : CategoryTheory.Limits.PreservesColimit K‚ÇÅ F\n‚ä¢ CategoryTheory.Limits.PreservesColimit K‚ÇÇ F","decl":"@[deprecated \"use preservesColimit_of_iso_diagram\" (since := \"2024-11-19\")]\nlemma preservesColimitOfIsoDiagram {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ)\n    [PreservesColimit K‚ÇÅ F] :\n    PreservesColimit K‚ÇÇ F :=\n  preservesColimit_of_iso_diagram F h\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesColimit K F\n‚ä¢ CategoryTheory.Limits.PreservesColimit K G","decl":"/-- Transfer preservation of a colimit along a natural isomorphism in the functor. -/\nlemma preservesColimit_of_natIso (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesColimit K F] :\n    PreservesColimit K G where\n  preserves t := ‚ü®IsColimit.mapCoconeEquiv h (isColimitOfPreserves F t)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesColimit K F\n‚ä¢ CategoryTheory.Limits.PreservesColimit K G","decl":"@[deprecated preservesColimit_of_natIso (since := \"2024-11-19\")]\nlemma preservesColimitOfNatIso (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesColimit K F] :\n    PreservesColimit K G :=\n  preservesColimit_of_natIso K h\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J G","decl":"/-- Transfer preservation of colimits of shape along a natural isomorphism in the functor. -/\nlemma preservesColimitsOfShape_of_natIso {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesColimitsOfShape J F] :\n    PreservesColimitsOfShape J G where\n  preservesColimit {K} := preservesColimit_of_natIso K h\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShapeOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J G","decl":"@[deprecated \"use preservesColimitsOfShape_of_natIso\" (since := \"2024-11-19\")]\nlemma preservesColimitsOfShapeOfNatIso {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesColimitsOfShape J F] :\n    PreservesColimitsOfShape J G :=\n  preservesColimitsOfShape_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"/-- Transfer preservation of colimits along a natural isomorphism in the functor. -/\nlemma preservesColimits_of_natIso {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesColimitsOfSize.{w, w'} F] :\n    PreservesColimitsOfSize.{w, w'} G where\n  preservesColimitsOfShape {_J} _ùí•‚ÇÅ := preservesColimitsOfShape_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"@[deprecated \"use preservesColimits_of_natIso\" (since := \"2024-11-19\")]\nlemma preservesColimitsOfNatIso {F G : C ‚•§ D} (h : F ‚âÖ G) [PreservesColimitsOfSize.{w, w'} F] :\n    PreservesColimitsOfSize.{w, w'} G :=\n  preservesColimits_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_of_equiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nJ' : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÇ', w‚ÇÇ} J'\ne : CategoryTheory.Equivalence J J'\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J' F","decl":"/-- Transfer preservation of colimits along an equivalence in the shape. -/\nlemma preservesColimitsOfShape_of_equiv {J' : Type w‚ÇÇ} [Category.{w‚ÇÇ'} J'] (e : J ‚âå J') (F : C ‚•§ D)\n    [PreservesColimitsOfShape J F] : PreservesColimitsOfShape J' F where\n  preservesColimit {K} :=\n    { preserves := fun {c} t => ‚ü®by\n        let equ := e.invFunIdAssoc (K ‚ãô F)\n        have := (isColimitOfPreserves F (t.whiskerEquivalence e)).whiskerEquivalence e.symm\n        apply ((IsColimit.precomposeInvEquiv equ _).symm this).ofIsoColimit\n        refine Cocones.ext (Iso.refl _) fun j => ?_\n        dsimp\n        simp [equ, ‚Üê Functor.map_comp]‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShapeOfEquiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nJ' : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÇ', w‚ÇÇ} J'\ne : CategoryTheory.Equivalence J J'\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J' F","decl":"@[deprecated \"use preservesColimitsOfShape_of_equiv\" (since := \"2024-11-19\")]\nlemma preservesColimitsOfShapeOfEquiv {J' : Type w‚ÇÇ} [Category.{w‚ÇÇ'} J'] (e : J ‚âå J') (F : C ‚•§ D)\n    [PreservesColimitsOfShape J F] : PreservesColimitsOfShape J' F :=\n  preservesColimitsOfShape_of_equiv e F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : UnivLE.{w, w'}\ninst‚úù¬π : UnivLE.{w‚ÇÇ, w‚ÇÇ'}\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w‚ÇÇ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- A functor preserving larger colimits also preserves smaller colimits. -/\nlemma preservesColimitsOfSize_of_univLE (F : C ‚•§ D) [UnivLE.{w, w'}] [UnivLE.{w‚ÇÇ, w‚ÇÇ'}]\n    [PreservesColimitsOfSize.{w', w‚ÇÇ'} F] : PreservesColimitsOfSize.{w, w‚ÇÇ} F where\n  preservesColimitsOfShape {J} := preservesColimitsOfShape_of_equiv\n    ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSizeOfUnivLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : UnivLE.{w, w'}\ninst‚úù¬π : UnivLE.{w‚ÇÇ, w‚ÇÇ'}\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w‚ÇÇ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use preservesColimitsOfSize_of_univLE\" (since := \"2024-11-19\")]\nlemma preservesColimitsOfSizeOfUnivLE (F : C ‚•§ D) [UnivLE.{w, w'}] [UnivLE.{w‚ÇÇ, w‚ÇÇ'}]\n    [PreservesColimitsOfSize.{w', w‚ÇÇ'} F] : PreservesColimitsOfSize.{w, w‚ÇÇ} F :=\n  preservesColimitsOfSize_of_univLE.{w', w‚ÇÇ'} F\n\n-- See library note [dsimp, simp].\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/--\n`PreservesColimitsOfSize_shrink.{w w'} F` tries to obtain `PreservesColimitsOfSize.{w w'} F`\nfrom some other `PreservesColimitsOfSize F`.\n-/\nlemma preservesColimitsOfSize_shrink (F : C ‚•§ D)\n    [PreservesColimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ'} F] :\n    PreservesColimitsOfSize.{w, w'} F := preservesColimitsOfSize_of_univLE.{max w w‚ÇÇ, max w' w‚ÇÇ'} F\n\n"}
{"name":"CategoryTheory.Limits.PreservesColimitsOfSizeShrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use preservesColimitsOfSize_shrink\" (since := \"2024-11-19\")]\nlemma PreservesColimitsOfSizeShrink (F : C ‚•§ D)\n    [PreservesColimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ'} F] :\n    PreservesColimitsOfSize.{w, w'} F :=\n  preservesColimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.preservesSmallestColimits_of_preservesColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{v‚ÇÉ, u‚ÇÉ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- Preserving colimits at any universe implies preserving colimits at universe `0`. -/\nlemma preservesSmallestColimits_of_preservesColimits (F : C ‚•§ D)\n    [PreservesColimitsOfSize.{v‚ÇÉ, u‚ÇÉ} F] :\n    PreservesColimitsOfSize.{0, 0} F :=\n  preservesColimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.preservesSmallestColimitsOfPreservesColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{v‚ÇÉ, u‚ÇÉ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use preservesSmallestColimits_of_preservesColimits\" (since := \"2024-11-19\")]\nlemma preservesSmallestColimitsOfPreservesColimits (F : C ‚•§ D)\n    [PreservesColimitsOfSize.{v‚ÇÉ, u‚ÇÉ} F] :\n    PreservesColimitsOfSize.{0, 0} F :=\n  preservesSmallestColimits_of_preservesColimits F\n\n"}
{"name":"CategoryTheory.Limits.ReflectsLimit.reflects","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsLimit K F\nc : CategoryTheory.Limits.Cone K\nhc : CategoryTheory.Limits.IsLimit (F.mapCone c)\n‚ä¢ Nonempty (CategoryTheory.Limits.IsLimit c)","decl":"/-- A functor `F : C ‚•§ D` reflects limits for `K : J ‚•§ C` if\nwhenever the image of a cone over `K` under `F` is a limit cone in `D`,\nthe cone was already a limit cone in `C`.\nNote that we do not assume a priori that `D` actually has any limits.\n-/\nclass ReflectsLimit (K : J ‚•§ C) (F : C ‚•§ D) : Prop where\n  reflects {c : Cone K} (hc : IsLimit (F.mapCone c)) : Nonempty (IsLimit c)\n\n"}
{"name":"CategoryTheory.Limits.ReflectsColimit.reflects","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsColimit K F\nc : CategoryTheory.Limits.Cocone K\nhc : CategoryTheory.Limits.IsColimit (F.mapCocone c)\n‚ä¢ Nonempty (CategoryTheory.Limits.IsColimit c)","decl":"/-- A functor `F : C ‚•§ D` reflects colimits for `K : J ‚•§ C` if\nwhenever the image of a cocone over `K` under `F` is a colimit cocone in `D`,\nthe cocone was already a colimit cocone in `C`.\nNote that we do not assume a priori that `D` actually has any colimits.\n-/\nclass ReflectsColimit (K : J ‚•§ C) (F : C ‚•§ D) : Prop where\n  reflects {c : Cocone K} (hc : IsColimit (F.mapCocone c)) : Nonempty (IsColimit c)\n\n"}
{"name":"CategoryTheory.Limits.ReflectsLimitsOfShape.reflectsLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsLimitsOfShape J F\nK : CategoryTheory.Functor J C\n‚ä¢ CategoryTheory.Limits.ReflectsLimit K F","decl":"/-- A functor `F : C ‚•§ D` reflects limits of shape `J` if\nwhenever the image of a cone over some `K : J ‚•§ C` under `F` is a limit cone in `D`,\nthe cone was already a limit cone in `C`.\nNote that we do not assume a priori that `D` actually has any limits.\n-/\nclass ReflectsLimitsOfShape (J : Type w) [Category.{w'} J] (F : C ‚•§ D) : Prop where\n  reflectsLimit : ‚àÄ {K : J ‚•§ C}, ReflectsLimit K F := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.ReflectsColimitsOfShape.reflectsColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsColimitsOfShape J F\nK : CategoryTheory.Functor J C\n‚ä¢ CategoryTheory.Limits.ReflectsColimit K F","decl":"/-- A functor `F : C ‚•§ D` reflects colimits of shape `J` if\nwhenever the image of a cocone over some `K : J ‚•§ C` under `F` is a colimit cocone in `D`,\nthe cocone was already a colimit cocone in `C`.\nNote that we do not assume a priori that `D` actually has any colimits.\n-/\nclass ReflectsColimitsOfShape (J : Type w) [Category.{w'} J] (F : C ‚•§ D) : Prop where\n  reflectsColimit : ‚àÄ {K : J ‚•§ C}, ReflectsColimit K F := by infer_instance\n\n-- This should be used with explicit universe variables.\n"}
{"name":"CategoryTheory.Limits.ReflectsLimitsOfSize.reflectsLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J F","decl":"/-- A functor `F : C ‚•§ D` reflects limits if\nwhenever the image of a cone over some `K : J ‚•§ C` under `F` is a limit cone in `D`,\nthe cone was already a limit cone in `C`.\nNote that we do not assume a priori that `D` actually has any limits.\n-/\n@[nolint checkUnivs, pp_with_univ]\nclass ReflectsLimitsOfSize (F : C ‚•§ D) : Prop where\n  reflectsLimitsOfShape : ‚àÄ {J : Type w} [Category.{w'} J], ReflectsLimitsOfShape J F := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.ReflectsColimitsOfSize.reflectsColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J F","decl":"/-- A functor `F : C ‚•§ D` reflects colimits if\nwhenever the image of a cocone over some `K : J ‚•§ C` under `F` is a colimit cocone in `D`,\nthe cocone was already a colimit cocone in `C`.\nNote that we do not assume a priori that `D` actually has any colimits.\n-/\n@[nolint checkUnivs, pp_with_univ]\nclass ReflectsColimitsOfSize (F : C ‚•§ D) : Prop where\n  reflectsColimitsOfShape : ‚àÄ {J : Type w} [Category.{w'} J], ReflectsColimitsOfShape J F := by\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimit_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.ReflectsLimit K F)","decl":"instance reflectsLimit_subsingleton (K : J ‚•§ C) (F : C ‚•§ D) : Subsingleton (ReflectsLimit K F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimit_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.ReflectsColimit K F)","decl":"instance\n  reflectsColimit_subsingleton (K : J ‚•§ C) (F : C ‚•§ D) : Subsingleton (ReflectsColimit K F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfShape_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.ReflectsLimitsOfShape J F)","decl":"instance reflectsLimitsOfShape_subsingleton (J : Type w) [Category.{w'} J] (F : C ‚•§ D) :\n    Subsingleton (ReflectsLimitsOfShape J F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfShape_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.ReflectsColimitsOfShape J F)","decl":"instance reflectsColimitsOfShape_subsingleton (J : Type w) [Category.{w'} J] (F : C ‚•§ D) :\n    Subsingleton (ReflectsColimitsOfShape J F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.reflects_limits_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F)","decl":"instance\n  reflects_limits_subsingleton (F : C ‚•§ D) : Subsingleton (ReflectsLimitsOfSize.{w', w} F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n"}
{"name":"CategoryTheory.Limits.reflects_colimits_subsingleton","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Subsingleton (CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F)","decl":"instance reflects_colimits_subsingleton (F : C ‚•§ D) :\n    Subsingleton (ReflectsColimitsOfSize.{w', w} F) := by\n  constructor; rintro ‚ü®a‚ü© ‚ü®b‚ü©; congr!\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.reflectsLimit_of_reflectsLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsLimit K F","decl":"instance (priority := 100) reflectsLimit_of_reflectsLimitsOfShape (K : J ‚•§ C) (F : C ‚•§ D)\n    [ReflectsLimitsOfShape J F] : ReflectsLimit K F :=\n  ReflectsLimitsOfShape.reflectsLimit\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.reflectsColimit_of_reflectsColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsColimit K F","decl":"instance (priority := 100) reflectsColimit_of_reflectsColimitsOfShape (K : J ‚•§ C) (F : C ‚•§ D)\n    [ReflectsColimitsOfShape J F] : ReflectsColimit K F :=\n  ReflectsColimitsOfShape.reflectsColimit\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfShape_of_reflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J F","decl":"instance (priority := 100) reflectsLimitsOfShape_of_reflectsLimits (J : Type w) [Category.{w'} J]\n    (F : C ‚•§ D) [ReflectsLimitsOfSize.{w', w} F] : ReflectsLimitsOfShape J F :=\n  ReflectsLimitsOfSize.reflectsLimitsOfShape\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfShape_of_reflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J F","decl":"instance (priority := 100) reflectsColimitsOfShape_of_reflectsColimits\n    (J : Type w) [Category.{w'} J]\n    (F : C ‚•§ D) [ReflectsColimitsOfSize.{w', w} F] : ReflectsColimitsOfShape J F :=\n  ReflectsColimitsOfSize.reflectsColimitsOfShape\n\n"}
{"name":"CategoryTheory.Limits.id_reflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (CategoryTheory.Functor.id C)","decl":"instance id_reflectsLimits : ReflectsLimitsOfSize.{w, w'} (ùü≠ C) where\n  reflectsLimitsOfShape {J} ùí• :=\n    { reflectsLimit := fun {K} =>\n        ‚ü®fun {c} h =>\n          ‚ü®fun s => h.lift ‚ü®s.pt, fun j => s.œÄ.app j, fun _ _ f => s.œÄ.naturality f‚ü©, by\n            cases K; rcases c with ‚ü®_, _, _‚ü©; intro s j; cases s; exact h.fac _ j, by\n            cases K; rcases c with ‚ü®_, _, _‚ü©; intro s m w; rcases s with ‚ü®_, _, _‚ü©;\n              exact h.uniq _ m w‚ü©‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.idReflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (CategoryTheory.Functor.id C)","decl":"@[deprecated \"use id_reflectsLimits\" (since := \"2024-11-19\")]\nlemma idReflectsLimits : ReflectsLimitsOfSize.{w, w'} (ùü≠ C) := id_reflectsLimits\n\n"}
{"name":"CategoryTheory.Limits.id_reflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (CategoryTheory.Functor.id C)","decl":"instance id_reflectsColimits : ReflectsColimitsOfSize.{w, w'} (ùü≠ C) where\n  reflectsColimitsOfShape {J} ùí• :=\n    { reflectsColimit := fun {K} =>\n        ‚ü®fun {c} h =>\n          ‚ü®fun s => h.desc ‚ü®s.pt, fun j => s.Œπ.app j, fun _ _ f => s.Œπ.naturality f‚ü©, by\n            cases K; rcases c with ‚ü®_, _, _‚ü©; intro s j; cases s; exact h.fac _ j, by\n            cases K; rcases c with ‚ü®_, _, _‚ü©; intro s m w; rcases s with ‚ü®_, _, _‚ü©;\n              exact h.uniq _ m w‚ü©‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.idReflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (CategoryTheory.Functor.id C)","decl":"@[deprecated \"use id_reflectsColimits\" (since := \"2024-11-19\")]\nlemma idReflectsColimits : ReflectsColimitsOfSize.{w, w'} (ùü≠ C) := id_reflectsColimits\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsLimit K F\ninst‚úù : CategoryTheory.Limits.ReflectsLimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.ReflectsLimit K (F.comp G)","decl":"instance comp_reflectsLimit [ReflectsLimit K F] [ReflectsLimit (K ‚ãô F) G] :\n    ReflectsLimit K (F ‚ãô G) :=\n  ‚ü®fun h => ReflectsLimit.reflects (isLimitOfReflects G h)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsLimitsOfShape J F\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J (F.comp G)","decl":"instance comp_reflectsLimitsOfShape [ReflectsLimitsOfShape J F] [ReflectsLimitsOfShape J G] :\n    ReflectsLimitsOfShape J (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)","decl":"instance comp_reflectsLimits [ReflectsLimitsOfSize.{w', w} F] [ReflectsLimitsOfSize.{w', w} G] :\n    ReflectsLimitsOfSize.{w', w} (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsColimit K F\ninst‚úù : CategoryTheory.Limits.ReflectsColimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.ReflectsColimit K (F.comp G)","decl":"instance comp_reflectsColimit [ReflectsColimit K F] [ReflectsColimit (K ‚ãô F) G] :\n    ReflectsColimit K (F ‚ãô G) :=\n  ‚ü®fun h => ReflectsColimit.reflects (isColimitOfReflects G h)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsColimitsOfShape J F\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J (F.comp G)","decl":"instance comp_reflectsColimitsOfShape [ReflectsColimitsOfShape J F] [ReflectsColimitsOfShape J G] :\n    ReflectsColimitsOfShape J (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)","decl":"instance comp_reflectsColimits [ReflectsColimitsOfSize.{w', w} F]\n    [ReflectsColimitsOfSize.{w', w} G] : ReflectsColimitsOfSize.{w', w} (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Limits.compReflectsLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsLimit K F\ninst‚úù : CategoryTheory.Limits.ReflectsLimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.ReflectsLimit K (F.comp G)","decl":"@[deprecated \"use comp_reflectsLimit\" (since := \"2024-11-19\")]\nlemma compReflectsLimit [ReflectsLimit K F] [ReflectsLimit (K ‚ãô F) G] :\n    ReflectsLimit K (F ‚ãô G) := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.compReflectsLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsLimitsOfShape J F\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J (F.comp G)","decl":"@[deprecated \"use comp_reflectsLimitsOfShape \" (since := \"2024-11-19\")]\nlemma compReflectsLimitsOfShape [ReflectsLimitsOfShape J F] [ReflectsLimitsOfShape J G] :\n    ReflectsLimitsOfShape J (F ‚ãô G) := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.compReflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)","decl":"@[deprecated \"use comp_reflectsLimits\" (since := \"2024-11-19\")]\nlemma compReflectsLimits [ReflectsLimitsOfSize.{w', w} F] [ReflectsLimitsOfSize.{w', w} G] :\n    ReflectsLimitsOfSize.{w', w} (F ‚ãô G) := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.compReflectsColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsColimit K F\ninst‚úù : CategoryTheory.Limits.ReflectsColimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.ReflectsColimit K (F.comp G)","decl":"@[deprecated \"use comp_reflectsColimit\" (since := \"2024-11-19\")]\nlemma compReflectsColimit [ReflectsColimit K F] [ReflectsColimit (K ‚ãô F) G] :\n    ReflectsColimit K (F ‚ãô G) := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.compReflectsColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsColimitsOfShape J F\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J (F.comp G)","decl":"@[deprecated \"use comp_reflectsColimitsOfShape \" (since := \"2024-11-19\")]\nlemma compReflectsColimitsOfShape [ReflectsColimitsOfShape J F] [ReflectsColimitsOfShape J G] :\n    ReflectsColimitsOfShape J (F ‚ãô G) := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.compReflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)","decl":"@[deprecated \"use comp_reflectsColimits\" (since := \"2024-11-19\")]\nlemma compReflectsColimits [ReflectsColimitsOfSize.{w', w} F] [ReflectsColimitsOfSize.{w', w} G] :\n    ReflectsColimitsOfSize.{w', w} (F ‚ãô G) := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimit K (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsLimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.PreservesLimit K F","decl":"/-- If `F ‚ãô G` preserves limits for `K`, and `G` reflects limits for `K ‚ãô F`,\nthen `F` preserves limits for `K`. -/\nlemma preservesLimit_of_reflects_of_preserves [PreservesLimit K (F ‚ãô G)] [ReflectsLimit (K ‚ãô F) G] :\n    PreservesLimit K F :=\n  ‚ü®fun h => ‚ü®by\n    apply isLimitOfReflects G\n    apply isLimitOfPreserves (F ‚ãô G) h‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitOfReflectsOfPreserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimit K (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsLimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.PreservesLimit K F","decl":"@[deprecated \"use preservesLimit_of_reflects_of_preserves\" (since := \"2024-11-19\")]\nlemma preservesLimitOfReflectsOfPreserves [PreservesLimit K (F ‚ãô G)] [ReflectsLimit (K ‚ãô F) G] :\n    PreservesLimit K F :=\n  preservesLimit_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfShape J (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/--\nIf `F ‚ãô G` preserves limits of shape `J` and `G` reflects limits of shape `J`, then `F` preserves\nlimits of shape `J`.\n-/\nlemma preservesLimitsOfShape_of_reflects_of_preserves [PreservesLimitsOfShape J (F ‚ãô G)]\n    [ReflectsLimitsOfShape J G] : PreservesLimitsOfShape J F where\n  preservesLimit := preservesLimit_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShapeOfReflectsOfPreserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfShape J (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"@[deprecated \"use preservesLimitsOfShape_of_reflects_of_preserves\" (since := \"2024-11-19\")]\nlemma preservesLimitsOfShapeOfReflectsOfPreserves [PreservesLimitsOfShape J (F ‚ãô G)]\n    [ReflectsLimitsOfShape J G] : PreservesLimitsOfShape J F :=\n  preservesLimitsOfShape_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- If `F ‚ãô G` preserves limits and `G` reflects limits, then `F` preserves limits. -/\nlemma preservesLimits_of_reflects_of_preserves [PreservesLimitsOfSize.{w', w} (F ‚ãô G)]\n    [ReflectsLimitsOfSize.{w', w} G] : PreservesLimitsOfSize.{w', w} F where\n  preservesLimitsOfShape := preservesLimitsOfShape_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfReflectsOfPreserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use preservesLimits_of_reflects_of_preserves\" (since := \"2024-11-19\")]\nlemma preservesLimitsOfReflectsOfPreserves [PreservesLimitsOfSize.{w', w} (F ‚ãô G)]\n    [ReflectsLimitsOfSize.{w', w} G] : PreservesLimitsOfSize.{w', w} F :=\n  preservesLimits_of_reflects_of_preserves.{w', w} F G\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimit_of_iso_diagram","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK‚ÇÅ K‚ÇÇ : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Iso K‚ÇÅ K‚ÇÇ\ninst‚úù : CategoryTheory.Limits.ReflectsLimit K‚ÇÅ F\n‚ä¢ CategoryTheory.Limits.ReflectsLimit K‚ÇÇ F","decl":"/-- Transfer reflection of limits along a natural isomorphism in the diagram. -/\nlemma reflectsLimit_of_iso_diagram {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ) [ReflectsLimit K‚ÇÅ F] :\n    ReflectsLimit K‚ÇÇ F where\n  reflects {c} t := ‚ü®by\n    apply IsLimit.postcomposeInvEquiv h c (isLimitOfReflects F _)\n    apply ((IsLimit.postcomposeInvEquiv (isoWhiskerRight h F :) _).symm t).ofIsoLimit _\n    exact Cones.ext (Iso.refl _)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitOfIsoDiagram","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK‚ÇÅ K‚ÇÇ : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Iso K‚ÇÅ K‚ÇÇ\ninst‚úù : CategoryTheory.Limits.ReflectsLimit K‚ÇÅ F\n‚ä¢ CategoryTheory.Limits.ReflectsLimit K‚ÇÇ F","decl":"@[deprecated \"use reflectsLimit_of_iso_diagram\" (since := \"2024-11-19\")]\nlemma reflectsLimitOfIsoDiagram {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ) [ReflectsLimit K‚ÇÅ F] :\n    ReflectsLimit K‚ÇÇ F :=\n  reflectsLimit_of_iso_diagram F h\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimit_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsLimit K F\n‚ä¢ CategoryTheory.Limits.ReflectsLimit K G","decl":"/-- Transfer reflection of a limit along a natural isomorphism in the functor. -/\nlemma reflectsLimit_of_natIso (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsLimit K F] :\n    ReflectsLimit K G where\n  reflects t := ReflectsLimit.reflects (IsLimit.mapConeEquiv h.symm t)\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsLimit K F\n‚ä¢ CategoryTheory.Limits.ReflectsLimit K G","decl":"@[deprecated \"use reflectsLimit_of_natIso\" (since := \"2024-11-19\")]\nlemma reflectsLimitOfNatIso (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsLimit K F] :\n    ReflectsLimit K G :=\n  reflectsLimit_of_natIso K h\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfShape_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J G","decl":"/-- Transfer reflection of limits of shape along a natural isomorphism in the functor. -/\nlemma reflectsLimitsOfShape_of_natIso {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsLimitsOfShape J F] :\n    ReflectsLimitsOfShape J G where\n  reflectsLimit {K} := reflectsLimit_of_natIso K h\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfShapeOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J G","decl":"@[deprecated \"use reflectsLimitsOfShape_of_natIso\" (since := \"2024-11-19\")]\nlemma reflectsLimitsOfShapeOfNatIso {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsLimitsOfShape J F] :\n    ReflectsLimitsOfShape J G :=\n  reflectsLimitsOfShape_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimits_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"/-- Transfer reflection of limits along a natural isomorphism in the functor. -/\nlemma reflectsLimits_of_natIso {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsLimitsOfSize.{w', w} F] :\n    ReflectsLimitsOfSize.{w', w} G where\n  reflectsLimitsOfShape := reflectsLimitsOfShape_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"@[deprecated \"use reflectsLimits_of_natIso\" (since := \"2024-11-19\")]\nlemma reflectsLimitsOfNatIso {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsLimitsOfSize.{w', w} F] :\n    ReflectsLimitsOfSize.{w', w} G :=\n  reflectsLimits_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfShape_of_equiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nJ' : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÇ', w‚ÇÇ} J'\ne : CategoryTheory.Equivalence J J'\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J' F","decl":"/-- Transfer reflection of limits along an equivalence in the shape. -/\nlemma reflectsLimitsOfShape_of_equiv {J' : Type w‚ÇÇ} [Category.{w‚ÇÇ'} J'] (e : J ‚âå J') (F : C ‚•§ D)\n    [ReflectsLimitsOfShape J F] : ReflectsLimitsOfShape J' F where\n  reflectsLimit {K} :=\n    { reflects := fun {c} t => ‚ü®by\n        apply IsLimit.ofWhiskerEquivalence e\n        apply isLimitOfReflects F\n        apply IsLimit.ofIsoLimit _ (Functor.mapConeWhisker _).symm\n        exact IsLimit.whiskerEquivalence t _‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfShapeOfEquiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nJ' : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÇ', w‚ÇÇ} J'\ne : CategoryTheory.Equivalence J J'\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J' F","decl":"@[deprecated \"use reflectsLimitsOfShape_of_equiv\" (since := \"2024-11-19\")]\nlemma reflectsLimitsOfShapeOfEquiv {J' : Type w‚ÇÇ} [Category.{w‚ÇÇ'} J'] (e : J ‚âå J') (F : C ‚•§ D)\n    [ReflectsLimitsOfShape J F] : ReflectsLimitsOfShape J' F :=\n  reflectsLimitsOfShape_of_equiv e F\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : UnivLE.{w, w'}\ninst‚úù¬π : UnivLE.{w‚ÇÇ, w‚ÇÇ'}\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w‚ÇÇ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- A functor reflecting larger limits also reflects smaller limits. -/\nlemma reflectsLimitsOfSize_of_univLE (F : C ‚•§ D) [UnivLE.{w, w'}] [UnivLE.{w‚ÇÇ, w‚ÇÇ'}]\n    [ReflectsLimitsOfSize.{w', w‚ÇÇ'} F] : ReflectsLimitsOfSize.{w, w‚ÇÇ} F where\n  reflectsLimitsOfShape {J} := reflectsLimitsOfShape_of_equiv\n    ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm F\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfSizeOfUnivLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : UnivLE.{w, w'}\ninst‚úù¬π : UnivLE.{w‚ÇÇ, w‚ÇÇ'}\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w‚ÇÇ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use reflectsLimitsOfSize_of_univLE\" (since := \"2024-11-19\")]\nlemma reflectsLimitsOfSizeOfUnivLE (F : C ‚•§ D) [UnivLE.{w, w'}] [UnivLE.{w‚ÇÇ, w‚ÇÇ'}]\n    [ReflectsLimitsOfSize.{w', w‚ÇÇ'} F] : ReflectsLimitsOfSize.{w, w‚ÇÇ} F :=\n  reflectsLimitsOfSize_of_univLE.{w'} F\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- `reflectsLimitsOfSize_shrink.{w w'} F` tries to obtain `reflectsLimitsOfSize.{w w'} F`\nfrom some other `reflectsLimitsOfSize F`.\n-/\nlemma reflectsLimitsOfSize_shrink (F : C ‚•§ D) [ReflectsLimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ'} F] :\n    ReflectsLimitsOfSize.{w, w'} F := reflectsLimitsOfSize_of_univLE.{max w w‚ÇÇ, max w' w‚ÇÇ'} F\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfSizeShrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use reflectsLimitsOfSize_shrink\" (since := \"2024-11-19\")]\nlemma reflectsLimitsOfSizeShrink (F : C ‚•§ D) [ReflectsLimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ'} F] :\n    ReflectsLimitsOfSize.{w, w'} F :=\n  reflectsLimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.reflectsSmallestLimits_of_reflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{v‚ÇÉ, u‚ÇÉ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- Reflecting limits at any universe implies reflecting limits at universe `0`. -/\nlemma reflectsSmallestLimits_of_reflectsLimits (F : C ‚•§ D) [ReflectsLimitsOfSize.{v‚ÇÉ, u‚ÇÉ} F] :\n    ReflectsLimitsOfSize.{0, 0} F :=\n  reflectsLimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.reflectsSmallestLimitsOfReflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{v‚ÇÉ, u‚ÇÉ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use reflectsSmallestLimits_of_reflectsLimits\" (since := \"2024-11-19\")]\nlemma reflectsSmallestLimitsOfReflectsLimits (F : C ‚•§ D) [ReflectsLimitsOfSize.{v‚ÇÉ, u‚ÇÉ} F] :\n    ReflectsLimitsOfSize.{0, 0} F :=\n  reflectsSmallestLimits_of_reflectsLimits F\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimit_of_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasLimit F\ninst‚úù : CategoryTheory.Limits.PreservesLimit F G\n‚ä¢ CategoryTheory.Limits.ReflectsLimit F G","decl":"/-- If the limit of `F` exists and `G` preserves it, then if `G` reflects isomorphisms then it\nreflects the limit of `F`.\n-/ -- Porting note: previous behavior of apply pushed instance holes into hypotheses, this errors\nlemma reflectsLimit_of_reflectsIsomorphisms (F : J ‚•§ C) (G : C ‚•§ D) [G.ReflectsIsomorphisms]\n    [HasLimit F] [PreservesLimit F G] : ReflectsLimit F G where\n  reflects {c} t := by\n    suffices IsIso (IsLimit.lift (limit.isLimit F) c) from ‚ü®by\n      apply IsLimit.ofPointIso (limit.isLimit F)‚ü©\n    change IsIso ((Cones.forget _).map ((limit.isLimit F).liftConeMorphism c))\n    suffices IsIso (IsLimit.liftConeMorphism (limit.isLimit F) c) from by\n      apply (Cones.forget F).map_isIso _\n    suffices IsIso (Prefunctor.map (Cones.functoriality F G).toPrefunctor\n      (IsLimit.liftConeMorphism (limit.isLimit F) c)) from by\n        apply isIso_of_reflects_iso _ (Cones.functoriality F G)\n    exact t.hom_isIso (isLimitOfPreserves G (limit.isLimit F)) _\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitOfReflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasLimit F\ninst‚úù : CategoryTheory.Limits.PreservesLimit F G\n‚ä¢ CategoryTheory.Limits.ReflectsLimit F G","decl":"@[deprecated \"use reflectsLimit_of_reflectsIsomorphisms\" (since := \"2024-11-19\")]\nlemma reflectsLimitOfReflectsIsomorphisms (F : J ‚•§ C) (G : C ‚•§ D) [G.ReflectsIsomorphisms]\n    [HasLimit F] [PreservesLimit F G] : ReflectsLimit F G :=\n  reflectsLimit_of_reflectsIsomorphisms F G\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfShape_of_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} J\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape J C\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J G","decl":"/-- If `C` has limits of shape `J` and `G` preserves them, then if `G` reflects isomorphisms then it\nreflects limits of shape `J`.\n-/\nlemma reflectsLimitsOfShape_of_reflectsIsomorphisms {G : C ‚•§ D} [G.ReflectsIsomorphisms]\n    [HasLimitsOfShape J C] [PreservesLimitsOfShape J G] : ReflectsLimitsOfShape J G where\n  reflectsLimit {F} := reflectsLimit_of_reflectsIsomorphisms F G\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfShapeOfReflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} J\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape J C\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfShape J G","decl":"@[deprecated \"use reflectsLimitsOfShape_of_reflectsIsomorphisms\" (since := \"2024-11-19\")]\nlemma reflectsLimitsOfShapeOfReflectsIsomorphisms {G : C ‚•§ D} [G.ReflectsIsomorphisms]\n    [HasLimitsOfShape J C] [PreservesLimitsOfShape J G] : ReflectsLimitsOfShape J G :=\n  reflectsLimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimits_of_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfSize.{w', w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"/-- If `C` has limits and `G` preserves limits, then if `G` reflects isomorphisms then it reflects\nlimits.\n-/\nlemma reflectsLimits_of_reflectsIsomorphisms {G : C ‚•§ D} [G.ReflectsIsomorphisms]\n    [HasLimitsOfSize.{w', w} C] [PreservesLimitsOfSize.{w', w} G] :\n    ReflectsLimitsOfSize.{w', w} G where\n  reflectsLimitsOfShape := reflectsLimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.reflectsLimitsOfReflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfSize.{w', w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"@[deprecated \"use reflectsLimits_of_reflectsIsomorphisms\" (since := \"2024-11-19\")]\nlemma reflectsLimitsOfReflectsIsomorphisms {G : C ‚•§ D} [G.ReflectsIsomorphisms]\n    [HasLimitsOfSize.{w', w} C] [PreservesLimitsOfSize.{w', w} G] :\n    ReflectsLimitsOfSize.{w', w} G :=\n  reflectsLimits_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit K (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsColimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.PreservesColimit K F","decl":"/-- If `F ‚ãô G` preserves colimits for `K`, and `G` reflects colimits for `K ‚ãô F`,\nthen `F` preserves colimits for `K`. -/\nlemma preservesColimit_of_reflects_of_preserves\n    [PreservesColimit K (F ‚ãô G)] [ReflectsColimit (K ‚ãô F) G] :\n    PreservesColimit K F :=\n  ‚ü®fun {c} h => ‚ü®by\n    apply isColimitOfReflects G\n    apply isColimitOfPreserves (F ‚ãô G) h‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitOfReflectsOfPreserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimit K (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsColimit (K.comp F) G\n‚ä¢ CategoryTheory.Limits.PreservesColimit K F","decl":"@[deprecated \"use preservesColimit_of_reflects_of_preserves\" (since := \"2024-11-19\")]\nlemma preservesColimitOfReflectsOfPreserves\n    [PreservesColimit K (F ‚ãô G)] [ReflectsColimit (K ‚ãô F) G] :\n    PreservesColimit K F :=\n  preservesColimit_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape J (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- If `F ‚ãô G` preserves colimits of shape `J` and `G` reflects colimits of shape `J`, then `F`\npreserves colimits of shape `J`.\n-/\nlemma preservesColimitsOfShape_of_reflects_of_preserves [PreservesColimitsOfShape J (F ‚ãô G)]\n    [ReflectsColimitsOfShape J G] : PreservesColimitsOfShape J F where\n  preservesColimit := preservesColimit_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShapeOfReflectsOfPreserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape J (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"@[deprecated \"use preservesColimitsOfShape_of_reflects_of_preserves\" (since := \"2024-11-19\")]\nlemma preservesColimitsOfShapeOfReflectsOfPreserves [PreservesColimitsOfShape J (F ‚ãô G)]\n    [ReflectsColimitsOfShape J G] : PreservesColimitsOfShape J F :=\n  preservesColimitsOfShape_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_of_reflects_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- If `F ‚ãô G` preserves colimits and `G` reflects colimits, then `F` preserves colimits. -/\nlemma preservesColimits_of_reflects_of_preserves [PreservesColimitsOfSize.{w', w} (F ‚ãô G)]\n    [ReflectsColimitsOfSize.{w', w} G] : PreservesColimitsOfSize.{w', w} F where\n  preservesColimitsOfShape := preservesColimitsOfShape_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfReflectsOfPreserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÉ, u‚ÇÅ, u‚ÇÉ} (F.comp G)\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use preservesColimits_of_reflects_of_preserves\" (since := \"2024-11-19\")]\nlemma preservesColimitsOfReflectsOfPreserves [PreservesColimitsOfSize.{w', w} (F ‚ãô G)]\n    [ReflectsColimitsOfSize.{w', w} G] : PreservesColimitsOfSize.{w', w} F :=\n  preservesColimits_of_reflects_of_preserves F G\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimit_of_iso_diagram","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK‚ÇÅ K‚ÇÇ : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Iso K‚ÇÅ K‚ÇÇ\ninst‚úù : CategoryTheory.Limits.ReflectsColimit K‚ÇÅ F\n‚ä¢ CategoryTheory.Limits.ReflectsColimit K‚ÇÇ F","decl":"/-- Transfer reflection of colimits along a natural isomorphism in the diagram. -/\nlemma reflectsColimit_of_iso_diagram {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ)\n    [ReflectsColimit K‚ÇÅ F] :\n    ReflectsColimit K‚ÇÇ F where\n  reflects {c} t := ‚ü®by\n    apply IsColimit.precomposeHomEquiv h c (isColimitOfReflects F _)\n    apply ((IsColimit.precomposeHomEquiv (isoWhiskerRight h F :) _).symm t).ofIsoColimit _\n    exact Cocones.ext (Iso.refl _)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitOfIsoDiagram","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK‚ÇÅ K‚ÇÇ : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\nh : CategoryTheory.Iso K‚ÇÅ K‚ÇÇ\ninst‚úù : CategoryTheory.Limits.ReflectsColimit K‚ÇÅ F\n‚ä¢ CategoryTheory.Limits.ReflectsColimit K‚ÇÇ F","decl":"@[deprecated \"use reflectsColimit_of_iso_diagram\" (since := \"2024-11-19\")]\nlemma reflectsColimitOfIsoDiagram {K‚ÇÅ K‚ÇÇ : J ‚•§ C} (F : C ‚•§ D) (h : K‚ÇÅ ‚âÖ K‚ÇÇ)\n    [ReflectsColimit K‚ÇÅ F] :\n    ReflectsColimit K‚ÇÇ F :=\n  reflectsColimit_of_iso_diagram F h\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimit_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsColimit K F\n‚ä¢ CategoryTheory.Limits.ReflectsColimit K G","decl":"/-- Transfer reflection of a colimit along a natural isomorphism in the functor. -/\nlemma reflectsColimit_of_natIso (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsColimit K F] :\n    ReflectsColimit K G where\n  reflects t := ReflectsColimit.reflects (IsColimit.mapCoconeEquiv h.symm t)\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsColimit K F\n‚ä¢ CategoryTheory.Limits.ReflectsColimit K G","decl":"@[deprecated \"use reflectsColimit_of_natIso\" (since := \"2024-11-19\")]\nlemma reflectsColimitOfNatIso (K : J ‚•§ C) {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsColimit K F] :\n    ReflectsColimit K G :=\n  reflectsColimit_of_natIso K h\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfShape_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J G","decl":"/-- Transfer reflection of colimits of shape along a natural isomorphism in the functor. -/\nlemma reflectsColimitsOfShape_of_natIso {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsColimitsOfShape J F] :\n    ReflectsColimitsOfShape J G where\n  reflectsColimit {K} := reflectsColimit_of_natIso K h\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfShapeOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬π : CategoryTheory.Category.{w', w} J\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J G","decl":"@[deprecated \"use reflectsColimitsOfShape_of_natIso\" (since := \"2024-11-19\")]\nlemma reflectsColimitsOfShapeOfNatIso {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsColimitsOfShape J F] :\n    ReflectsColimitsOfShape J G :=\n  reflectsColimitsOfShape_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimits_of_natIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"/-- Transfer reflection of colimits along a natural isomorphism in the functor. -/\nlemma reflectsColimits_of_natIso {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsColimitsOfSize.{w, w'} F] :\n    ReflectsColimitsOfSize.{w, w'} G where\n  reflectsColimitsOfShape := reflectsColimitsOfShape_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfNatIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"@[deprecated \"use reflectsColimits_of_natIso\" (since := \"2024-11-19\")]\nlemma reflectsColimitsOfNatIso {F G : C ‚•§ D} (h : F ‚âÖ G) [ReflectsColimitsOfSize.{w, w'} F] :\n    ReflectsColimitsOfSize.{w, w'} G :=\n  reflectsColimits_of_natIso h\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfShape_of_equiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nJ' : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÇ', w‚ÇÇ} J'\ne : CategoryTheory.Equivalence J J'\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J' F","decl":"/-- Transfer reflection of colimits along an equivalence in the shape. -/\nlemma reflectsColimitsOfShape_of_equiv {J' : Type w‚ÇÇ} [Category.{w‚ÇÇ'} J'] (e : J ‚âå J') (F : C ‚•§ D)\n    [ReflectsColimitsOfShape J F] : ReflectsColimitsOfShape J' F where\n  reflectsColimit :=\n    { reflects := fun {c} t => ‚ü®by\n        apply IsColimit.ofWhiskerEquivalence e\n        apply isColimitOfReflects F\n        apply IsColimit.ofIsoColimit _ (Functor.mapCoconeWhisker _).symm\n        exact IsColimit.whiskerEquivalence t _‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfShapeOfEquiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} J\nJ' : Type w‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{w‚ÇÇ', w‚ÇÇ} J'\ne : CategoryTheory.Equivalence J J'\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J' F","decl":"@[deprecated \"use reflectsColimitsOfShape_of_equiv\" (since := \"2024-11-19\")]\nlemma reflectsColimitsOfShapeOfEquiv {J' : Type w‚ÇÇ} [Category.{w‚ÇÇ'} J'] (e : J ‚âå J') (F : C ‚•§ D)\n    [ReflectsColimitsOfShape J F] : ReflectsColimitsOfShape J' F :=\n  reflectsColimitsOfShape_of_equiv e F\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : UnivLE.{w, w'}\ninst‚úù¬π : UnivLE.{w‚ÇÇ, w‚ÇÇ'}\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w‚ÇÇ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- A functor reflecting larger colimits also reflects smaller colimits. -/\nlemma reflectsColimitsOfSize_of_univLE (F : C ‚•§ D) [UnivLE.{w, w'}] [UnivLE.{w‚ÇÇ, w‚ÇÇ'}]\n    [ReflectsColimitsOfSize.{w', w‚ÇÇ'} F] : ReflectsColimitsOfSize.{w, w‚ÇÇ} F where\n  reflectsColimitsOfShape {J} := reflectsColimitsOfShape_of_equiv\n    ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm F\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfSizeOfUnivLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : UnivLE.{w, w'}\ninst‚úù¬π : UnivLE.{w‚ÇÇ, w‚ÇÇ'}\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w‚ÇÇ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use reflectsColimitsOfSize_of_univLE\" (since := \"2024-11-19\")]\nlemma reflectsColimitsOfSizeOfUnivLE (F : C ‚•§ D) [UnivLE.{w, w'}] [UnivLE.{w‚ÇÇ, w‚ÇÇ'}]\n    [ReflectsColimitsOfSize.{w', w‚ÇÇ'} F] : ReflectsColimitsOfSize.{w, w‚ÇÇ} F :=\n  reflectsColimitsOfSize_of_univLE.{w'} F\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- `reflectsColimitsOfSize_shrink.{w w'} F` tries to obtain `reflectsColimitsOfSize.{w w'} F`\nfrom some other `reflectsColimitsOfSize F`.\n-/\nlemma reflectsColimitsOfSize_shrink (F : C ‚•§ D) [ReflectsColimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ'} F] :\n    ReflectsColimitsOfSize.{w, w'} F := reflectsColimitsOfSize_of_univLE.{max w w‚ÇÇ, max w' w‚ÇÇ'} F\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfSizeShrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use reflectsColimitsOfSize_shrink\" (since := \"2024-11-19\")]\nlemma reflectsColimitsOfSizeShrink (F : C ‚•§ D) [ReflectsColimitsOfSize.{max w w‚ÇÇ, max w' w‚ÇÇ'} F] :\n    ReflectsColimitsOfSize.{w, w'} F :=\n  reflectsColimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.reflectsSmallestColimits_of_reflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{v‚ÇÉ, u‚ÇÉ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- Reflecting colimits at any universe implies reflecting colimits at universe `0`. -/\nlemma reflectsSmallestColimits_of_reflectsColimits (F : C ‚•§ D) [ReflectsColimitsOfSize.{v‚ÇÉ, u‚ÇÉ} F] :\n    ReflectsColimitsOfSize.{0, 0} F :=\n  reflectsColimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.reflectsSmallestColimitsOfReflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfSize.{v‚ÇÉ, u‚ÇÉ, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use reflectsSmallestColimits_of_reflectsColimits\" (since := \"2024-11-19\")]\nlemma reflectsSmallestColimitsOfReflectsColimits (F : C ‚•§ D) [ReflectsColimitsOfSize.{v‚ÇÉ, u‚ÇÉ} F] :\n    ReflectsColimitsOfSize.{0, 0} F :=\n  reflectsSmallestColimits_of_reflectsColimits F\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimit_of_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.PreservesColimit F G\n‚ä¢ CategoryTheory.Limits.ReflectsColimit F G","decl":"/-- If the colimit of `F` exists and `G` preserves it, then if `G` reflects isomorphisms then it\nreflects the colimit of `F`.\n-/ -- Porting note: previous behavior of apply pushed instance holes into hypotheses, this errors\nlemma reflectsColimit_of_reflectsIsomorphisms (F : J ‚•§ C) (G : C ‚•§ D) [G.ReflectsIsomorphisms]\n    [HasColimit F] [PreservesColimit F G] : ReflectsColimit F G where\n  reflects {c} t := by\n    suffices IsIso (IsColimit.desc (colimit.isColimit F) c) from ‚ü®by\n      apply IsColimit.ofPointIso (colimit.isColimit F)‚ü©\n    change IsIso ((Cocones.forget _).map ((colimit.isColimit F).descCoconeMorphism c))\n    suffices IsIso (IsColimit.descCoconeMorphism (colimit.isColimit F) c) from by\n      apply (Cocones.forget F).map_isIso _\n    suffices IsIso (Prefunctor.map (Cocones.functoriality F G).toPrefunctor\n      (IsColimit.descCoconeMorphism (colimit.isColimit F) c)) from by\n        apply isIso_of_reflects_iso _ (Cocones.functoriality F G)\n    exact (isColimitOfPreserves G (colimit.isColimit F)).hom_isIso t _\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitOfReflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.PreservesColimit F G\n‚ä¢ CategoryTheory.Limits.ReflectsColimit F G","decl":"@[deprecated \"use reflectsColimit_of_reflectsIsomorphisms\" (since := \"2024-11-19\")]\nlemma reflectsColimitOfReflectsIsomorphisms (F : J ‚•§ C) (G : C ‚•§ D) [G.ReflectsIsomorphisms]\n    [HasColimit F] [PreservesColimit F G] : ReflectsColimit F G :=\n  reflectsColimit_of_reflectsIsomorphisms F G\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfShape_of_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} J\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape J C\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J G","decl":"/--\nIf `C` has colimits of shape `J` and `G` preserves them, then if `G` reflects isomorphisms then it\nreflects colimits of shape `J`.\n-/\nlemma reflectsColimitsOfShape_of_reflectsIsomorphisms {G : C ‚•§ D} [G.ReflectsIsomorphisms]\n    [HasColimitsOfShape J C] [PreservesColimitsOfShape J G] : ReflectsColimitsOfShape J G where\n  reflectsColimit {F} := reflectsColimit_of_reflectsIsomorphisms F G\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfShapeOfReflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{w', w} J\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape J C\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J G\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfShape J G","decl":"@[deprecated \"use reflectsColimitsOfShape_of_reflectsIsomorphisms\" (since := \"2024-11-19\")]\nlemma reflectsColimitsOfShapeOfReflectsIsomorphisms {G : C ‚•§ D} [G.ReflectsIsomorphisms]\n    [HasColimitsOfShape J C] [PreservesColimitsOfShape J G] : ReflectsColimitsOfShape J G :=\n  reflectsColimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimits_of_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfSize.{w', w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"/--\nIf `C` has colimits and `G` preserves colimits, then if `G` reflects isomorphisms then it reflects\ncolimits.\n-/\nlemma reflectsColimits_of_reflectsIsomorphisms {G : C ‚•§ D} [G.ReflectsIsomorphisms]\n    [HasColimitsOfSize.{w', w} C] [PreservesColimitsOfSize.{w', w} G] :\n    ReflectsColimitsOfSize.{w', w} G where\n  reflectsColimitsOfShape := reflectsColimitsOfShape_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.reflectsColimitsOfReflectsIsomorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.ReflectsIsomorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfSize.{w', w, v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w', w, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} G","decl":"@[deprecated \"use reflectsColimits_of_reflectsIsomorphisms\" (since := \"2024-11-19\")]\nlemma reflectsColimitsOfReflectsIsomorphisms {G : C ‚•§ D} [G.ReflectsIsomorphisms]\n    [HasColimitsOfSize.{w', w} C] [PreservesColimitsOfSize.{w', w} G] :\n    ReflectsColimitsOfSize.{w', w} G :=\n  reflectsColimits_of_reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Limits.fullyFaithful_reflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- A fully faithful functor reflects limits. -/\ninstance fullyFaithful_reflectsLimits [F.Full] [F.Faithful] : ReflectsLimitsOfSize.{w, w'} F where\n  reflectsLimitsOfShape {J} ùí•‚ÇÅ :=\n    { reflectsLimit := fun {K} =>\n        { reflects := fun {c} t =>\n            ‚ü®(IsLimit.mkConeMorphism fun _ =>\n                (Cones.functoriality K F).preimage (t.liftConeMorphism _)) <| by\n              apply fun s m => (Cones.functoriality K F).map_injective _\n              intro s m\n              rw [Functor.map_preimage]\n              apply t.uniq_cone_morphism‚ü© } }\n\n"}
{"name":"CategoryTheory.Limits.fullyFaithfulReflectsLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use fullyFaithful_reflectsLimits\" (since := \"2024-11-19\")]\nlemma fullyFaithfulReflectsLimits [F.Full] [F.Faithful] : ReflectsLimitsOfSize.{w, w'} F :=\n  inferInstance\n\n"}
{"name":"CategoryTheory.Limits.fullyFaithful_reflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"/-- A fully faithful functor reflects colimits. -/\ninstance fullyFaithful_reflectsColimits [F.Full] [F.Faithful] :\n    ReflectsColimitsOfSize.{w, w'} F where\n  reflectsColimitsOfShape {J} ùí•‚ÇÅ :=\n    { reflectsColimit := fun {K} =>\n        { reflects := fun {c} t =>\n            ‚ü®(IsColimit.mkCoconeMorphism fun _ =>\n                (Cocones.functoriality K F).preimage (t.descCoconeMorphism _)) <| by\n              apply fun s m => (Cocones.functoriality K F).map_injective _\n              intro s m\n              rw [Functor.map_preimage]\n              apply t.uniq_cocone_morphism‚ü© }}\n\n"}
{"name":"CategoryTheory.Limits.fullyFaithfulReflectsColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"@[deprecated \"use fullyFaithful_reflectsColimits\" (since := \"2024-11-19\")]\nlemma fullyFaithfulReflectsColimits [F.Full] [F.Faithful] : ReflectsColimitsOfSize.{w, w'} F :=\n  inferInstance\n\n"}
