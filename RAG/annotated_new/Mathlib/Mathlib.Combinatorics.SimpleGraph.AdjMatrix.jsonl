{"name":"Matrix.IsAdjMatrix.symm","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝¹ : Zero α\ninst✝ : One α\nA : Matrix V V α\nself : A.IsAdjMatrix\n⊢ A.IsSymm","decl":"/-- `A : Matrix V V α` is qualified as an \"adjacency matrix\" if\n    (1) every entry of `A` is `0` or `1`,\n    (2) `A` is symmetric,\n    (3) every diagonal entry of `A` is `0`. -/\nstructure IsAdjMatrix [Zero α] [One α] (A : Matrix V V α) : Prop where\n  zero_or_one : ∀ i j, A i j = 0 ∨ A i j = 1 := by aesop\n  symm : A.IsSymm := by aesop\n  apply_diag : ∀ i, A i i = 0 := by aesop\n\n"}
{"name":"Matrix.IsAdjMatrix.zero_or_one","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝¹ : Zero α\ninst✝ : One α\nA : Matrix V V α\nself : A.IsAdjMatrix\ni j : V\n⊢ Or (Eq (A i j) 0) (Eq (A i j) 1)","decl":"/-- `A : Matrix V V α` is qualified as an \"adjacency matrix\" if\n    (1) every entry of `A` is `0` or `1`,\n    (2) `A` is symmetric,\n    (3) every diagonal entry of `A` is `0`. -/\nstructure IsAdjMatrix [Zero α] [One α] (A : Matrix V V α) : Prop where\n  zero_or_one : ∀ i j, A i j = 0 ∨ A i j = 1 := by aesop\n  symm : A.IsSymm := by aesop\n  apply_diag : ∀ i, A i i = 0 := by aesop\n\n"}
{"name":"Matrix.IsAdjMatrix.apply_diag","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝¹ : Zero α\ninst✝ : One α\nA : Matrix V V α\nself : A.IsAdjMatrix\ni : V\n⊢ Eq (A i i) 0","decl":"/-- `A : Matrix V V α` is qualified as an \"adjacency matrix\" if\n    (1) every entry of `A` is `0` or `1`,\n    (2) `A` is symmetric,\n    (3) every diagonal entry of `A` is `0`. -/\nstructure IsAdjMatrix [Zero α] [One α] (A : Matrix V V α) : Prop where\n  zero_or_one : ∀ i j, A i j = 0 ∨ A i j = 1 := by aesop\n  symm : A.IsSymm := by aesop\n  apply_diag : ∀ i, A i i = 0 := by aesop\n\n"}
{"name":"Matrix.IsAdjMatrix.apply_diag_ne","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nA : Matrix V V α\ninst✝¹ : MulZeroOneClass α\ninst✝ : Nontrivial α\nh : A.IsAdjMatrix\ni : V\n⊢ Not (Eq (A i i) 1)","decl":"@[simp]\ntheorem apply_diag_ne [MulZeroOneClass α] [Nontrivial α] (h : IsAdjMatrix A) (i : V) :\n    ¬A i i = 1 := by simp [h.apply_diag i]\n\n"}
{"name":"Matrix.IsAdjMatrix.apply_ne_one_iff","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nA : Matrix V V α\ninst✝¹ : MulZeroOneClass α\ninst✝ : Nontrivial α\nh : A.IsAdjMatrix\ni j : V\n⊢ Iff (Not (Eq (A i j) 1)) (Eq (A i j) 0)","decl":"@[simp]\ntheorem apply_ne_one_iff [MulZeroOneClass α] [Nontrivial α] (h : IsAdjMatrix A) (i j : V) :\n    ¬A i j = 1 ↔ A i j = 0 := by obtain h | h := h.zero_or_one i j <;> simp [h]\n\n"}
{"name":"Matrix.IsAdjMatrix.apply_ne_zero_iff","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nA : Matrix V V α\ninst✝¹ : MulZeroOneClass α\ninst✝ : Nontrivial α\nh : A.IsAdjMatrix\ni j : V\n⊢ Iff (Not (Eq (A i j) 0)) (Eq (A i j) 1)","decl":"@[simp]\ntheorem apply_ne_zero_iff [MulZeroOneClass α] [Nontrivial α] (h : IsAdjMatrix A) (i j : V) :\n    ¬A i j = 0 ↔ A i j = 1 := by rw [← apply_ne_one_iff h, Classical.not_not]\n\n"}
{"name":"Matrix.IsAdjMatrix.toGraph_adj","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nA : Matrix V V α\ninst✝¹ : MulZeroOneClass α\ninst✝ : Nontrivial α\nh : A.IsAdjMatrix\ni j : V\n⊢ Eq (h.toGraph.Adj i j) (Eq (A i j) 1)","decl":"/-- For `A : Matrix V V α` and `h : IsAdjMatrix A`,\n    `h.toGraph` is the simple graph whose adjacency matrix is `A`. -/\n@[simps]\ndef toGraph [MulZeroOneClass α] [Nontrivial α] (h : IsAdjMatrix A) : SimpleGraph V where\n  Adj i j := A i j = 1\n  symm i j hij := by simp only; rwa [h.symm.apply i j]\n  loopless i := by simp [h]\n\n"}
{"name":"Matrix.compl_apply_diag","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq V\nA : Matrix V V α\ninst✝¹ : Zero α\ninst✝ : One α\ni : V\n⊢ Eq (A.compl i i) 0","decl":"@[simp]\ntheorem compl_apply_diag [Zero α] [One α] (i : V) : A.compl i i = 0 := by simp [compl]\n\n"}
{"name":"Matrix.compl_apply","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq V\nA : Matrix V V α\ninst✝¹ : Zero α\ninst✝ : One α\ni j : V\n⊢ Or (Eq (A.compl i j) 0) (Eq (A.compl i j) 1)","decl":"@[simp]\ntheorem compl_apply [Zero α] [One α] (i j : V) : A.compl i j = 0 ∨ A.compl i j = 1 := by\n  unfold compl\n  split_ifs <;> simp\n\n"}
{"name":"Matrix.isSymm_compl","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq V\nA : Matrix V V α\ninst✝¹ : Zero α\ninst✝ : One α\nh : A.IsSymm\n⊢ A.compl.IsSymm","decl":"@[simp]\ntheorem isSymm_compl [Zero α] [One α] (h : A.IsSymm) : A.compl.IsSymm := by\n  ext\n  simp [compl, h.apply, eq_comm]\n\n"}
{"name":"Matrix.isAdjMatrix_compl","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq V\nA : Matrix V V α\ninst✝¹ : Zero α\ninst✝ : One α\nh : A.IsSymm\n⊢ A.compl.IsAdjMatrix","decl":"@[simp]\ntheorem isAdjMatrix_compl [Zero α] [One α] (h : A.IsSymm) : IsAdjMatrix A.compl :=\n  { symm := by simp [h] }\n\n"}
{"name":"Matrix.IsAdjMatrix.compl","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq V\nA : Matrix V V α\ninst✝¹ : Zero α\ninst✝ : One α\nh : A.IsAdjMatrix\n⊢ A.compl.IsAdjMatrix","decl":"@[simp]\ntheorem compl [Zero α] [One α] (h : IsAdjMatrix A) : IsAdjMatrix A.compl :=\n  isAdjMatrix_compl A h.symm\n\n"}
{"name":"Matrix.IsAdjMatrix.toGraph_compl_eq","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq V\nA : Matrix V V α\ninst✝¹ : MulZeroOneClass α\ninst✝ : Nontrivial α\nh : A.IsAdjMatrix\n⊢ Eq ⋯.toGraph (HasCompl.compl h.toGraph)","decl":"theorem toGraph_compl_eq [MulZeroOneClass α] [Nontrivial α] (h : IsAdjMatrix A) :\n    h.compl.toGraph = h.toGraphᶜ := by\n  ext v w\n  cases' h.zero_or_one v w with h h <;> by_cases hvw : v = w <;> simp [Matrix.compl, h, hvw]\n\n"}
{"name":"SimpleGraph.adjMatrix_apply","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\nv w : V\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq (SimpleGraph.adjMatrix α G v w) (ite (G.Adj v w) 1 0)","decl":"@[simp]\ntheorem adjMatrix_apply (v w : V) [Zero α] [One α] :\n    G.adjMatrix α v w = if G.Adj v w then 1 else 0 :=\n  rfl\n\n"}
{"name":"SimpleGraph.transpose_adjMatrix","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq (SimpleGraph.adjMatrix α G).transpose (SimpleGraph.adjMatrix α G)","decl":"@[simp]\ntheorem transpose_adjMatrix [Zero α] [One α] : (G.adjMatrix α)ᵀ = G.adjMatrix α := by\n  ext\n  simp [adj_comm]\n\n"}
{"name":"SimpleGraph.isSymm_adjMatrix","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ (SimpleGraph.adjMatrix α G).IsSymm","decl":"@[simp]\ntheorem isSymm_adjMatrix [Zero α] [One α] : (G.adjMatrix α).IsSymm :=\n  transpose_adjMatrix G\n\n"}
{"name":"SimpleGraph.isAdjMatrix_adjMatrix","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ (SimpleGraph.adjMatrix α G).IsAdjMatrix","decl":"/-- The adjacency matrix of `G` is an adjacency matrix. -/\n@[simp]\ntheorem isAdjMatrix_adjMatrix [Zero α] [One α] : (G.adjMatrix α).IsAdjMatrix :=\n  { zero_or_one := fun i j => by by_cases h : G.Adj i j <;> simp [h] }\n\n"}
{"name":"SimpleGraph.toGraph_adjMatrix_eq","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : MulZeroOneClass α\ninst✝ : Nontrivial α\n⊢ Eq ⋯.toGraph G","decl":"/-- The graph induced by the adjacency matrix of `G` is `G` itself. -/\ntheorem toGraph_adjMatrix_eq [MulZeroOneClass α] [Nontrivial α] :\n    (G.isAdjMatrix_adjMatrix α).toGraph = G := by\n  ext\n  simp only [IsAdjMatrix.toGraph_adj, adjMatrix_apply, ite_eq_left_iff, zero_ne_one]\n  apply Classical.not_not\n\n"}
{"name":"SimpleGraph.one_add_adjMatrix_add_compl_adjMatrix_eq_allOnes","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝³ : DecidableRel G.Adj\ninst✝² : DecidableEq V\ninst✝¹ : DecidableEq α\ninst✝ : NonAssocSemiring α\n⊢ Eq (HAdd.hAdd (HAdd.hAdd 1 (SimpleGraph.adjMatrix α G)) (SimpleGraph.adjMatrix α G).compl) (Matrix.of fun x x => 1)","decl":"/-- The sum of the identity, the adjacency matrix, and its complement is the all-ones matrix. -/\ntheorem one_add_adjMatrix_add_compl_adjMatrix_eq_allOnes [DecidableEq V] [DecidableEq α]\n    [NonAssocSemiring α] : 1 + G.adjMatrix α + (G.adjMatrix α).compl = Matrix.of fun _ _ ↦ 1 := by\n  ext i j\n  unfold Matrix.compl\n  rw [of_apply, add_apply, adjMatrix_apply, add_apply, adjMatrix_apply, one_apply]\n  by_cases h : G.Adj i j\n  · aesop\n  · split_ifs <;> simp_all\n\n"}
{"name":"SimpleGraph.adjMatrix_dotProduct","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\nv : V\nvec : V → α\n⊢ Eq (dotProduct (SimpleGraph.adjMatrix α G v) vec) ((G.neighborFinset v).sum fun u => vec u)","decl":"@[simp]\ntheorem adjMatrix_dotProduct [NonAssocSemiring α] (v : V) (vec : V → α) :\n    dotProduct (G.adjMatrix α v) vec = ∑ u ∈ G.neighborFinset v, vec u := by\n  simp [neighborFinset_eq_filter, dotProduct, sum_filter]\n\n"}
{"name":"SimpleGraph.dotProduct_adjMatrix","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\nv : V\nvec : V → α\n⊢ Eq (dotProduct vec (SimpleGraph.adjMatrix α G v)) ((G.neighborFinset v).sum fun u => vec u)","decl":"@[simp]\ntheorem dotProduct_adjMatrix [NonAssocSemiring α] (v : V) (vec : V → α) :\n    dotProduct vec (G.adjMatrix α v) = ∑ u ∈ G.neighborFinset v, vec u := by\n  simp [neighborFinset_eq_filter, dotProduct, sum_filter, Finset.sum_apply]\n\n"}
{"name":"SimpleGraph.adjMatrix_mulVec_apply","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\nv : V\nvec : V → α\n⊢ Eq ((SimpleGraph.adjMatrix α G).mulVec vec v) ((G.neighborFinset v).sum fun u => vec u)","decl":"@[simp]\ntheorem adjMatrix_mulVec_apply [NonAssocSemiring α] (v : V) (vec : V → α) :\n    (G.adjMatrix α *ᵥ vec) v = ∑ u ∈ G.neighborFinset v, vec u := by\n  rw [mulVec, adjMatrix_dotProduct]\n\n"}
{"name":"SimpleGraph.adjMatrix_vecMul_apply","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\nv : V\nvec : V → α\n⊢ Eq (Matrix.vecMul vec (SimpleGraph.adjMatrix α G) v) ((G.neighborFinset v).sum fun u => vec u)","decl":"@[simp]\ntheorem adjMatrix_vecMul_apply [NonAssocSemiring α] (v : V) (vec : V → α) :\n    (vec ᵥ* G.adjMatrix α) v = ∑ u ∈ G.neighborFinset v, vec u := by\n  simp only [← dotProduct_adjMatrix, vecMul]\n  refine congr rfl ?_; ext x\n  rw [← transpose_apply (adjMatrix α G) x v, transpose_adjMatrix]\n\n"}
{"name":"SimpleGraph.adjMatrix_mul_apply","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\nM : Matrix V V α\nv w : V\n⊢ Eq (HMul.hMul (SimpleGraph.adjMatrix α G) M v w) ((G.neighborFinset v).sum fun u => M u w)","decl":"@[simp]\ntheorem adjMatrix_mul_apply [NonAssocSemiring α] (M : Matrix V V α) (v w : V) :\n    (G.adjMatrix α * M) v w = ∑ u ∈ G.neighborFinset v, M u w := by\n  simp [mul_apply, neighborFinset_eq_filter, sum_filter]\n\n"}
{"name":"SimpleGraph.mul_adjMatrix_apply","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\nM : Matrix V V α\nv w : V\n⊢ Eq (HMul.hMul M (SimpleGraph.adjMatrix α G) v w) ((G.neighborFinset w).sum fun u => M v u)","decl":"@[simp]\ntheorem mul_adjMatrix_apply [NonAssocSemiring α] (M : Matrix V V α) (v w : V) :\n    (M * G.adjMatrix α) v w = ∑ u ∈ G.neighborFinset w, M v u := by\n  simp [mul_apply, neighborFinset_eq_filter, sum_filter, adj_comm]\n\n"}
{"name":"SimpleGraph.trace_adjMatrix","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝³ : DecidableRel G.Adj\ninst✝² : Fintype V\ninst✝¹ : AddCommMonoid α\ninst✝ : One α\n⊢ Eq (SimpleGraph.adjMatrix α G).trace 0","decl":"@[simp]\ntheorem trace_adjMatrix [AddCommMonoid α] [One α] : Matrix.trace (G.adjMatrix α) = 0 := by\n  simp [Matrix.trace]\n\n"}
{"name":"SimpleGraph.adjMatrix_mul_self_apply_self","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\ni : V\n⊢ Eq (HMul.hMul (SimpleGraph.adjMatrix α G) (SimpleGraph.adjMatrix α G) i i) ↑(G.degree i)","decl":"theorem adjMatrix_mul_self_apply_self [NonAssocSemiring α] (i : V) :\n    (G.adjMatrix α * G.adjMatrix α) i i = degree G i := by simp [filter_true_of_mem]\n\n"}
{"name":"SimpleGraph.adjMatrix_mulVec_const_apply","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\na : α\nv : V\n⊢ Eq ((SimpleGraph.adjMatrix α G).mulVec (Function.const V a) v) (HMul.hMul (↑(G.degree v)) a)","decl":"theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :\n    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by simp\n\n"}
{"name":"SimpleGraph.adjMatrix_mulVec_const_apply_of_regular","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\nd : Nat\na : α\nhd : G.IsRegularOfDegree d\nv : V\n⊢ Eq ((SimpleGraph.adjMatrix α G).mulVec (Function.const V a) v) (HMul.hMul (↑d) a)","decl":"theorem adjMatrix_mulVec_const_apply_of_regular [NonAssocSemiring α] {d : ℕ} {a : α}\n    (hd : G.IsRegularOfDegree d) {v : V} : (G.adjMatrix α *ᵥ Function.const _ a) v = d * a := by\n  simp [hd v]\n\n"}
{"name":"SimpleGraph.adjMatrix_pow_apply_eq_card_walk","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝³ : DecidableRel G.Adj\ninst✝² : Fintype V\ninst✝¹ : DecidableEq V\ninst✝ : Semiring α\nn : Nat\nu v : V\n⊢ Eq (HPow.hPow (SimpleGraph.adjMatrix α G) n u v) ↑(Fintype.card ↑(setOf fun p => Eq p.length n))","decl":"theorem adjMatrix_pow_apply_eq_card_walk [DecidableEq V] [Semiring α] (n : ℕ) (u v : V) :\n    (G.adjMatrix α ^ n) u v = Fintype.card { p : G.Walk u v | p.length = n } := by\n  rw [card_set_walk_length_eq]\n  induction' n with n ih generalizing u v\n  · obtain rfl | h := eq_or_ne u v <;> simp [finsetWalkLength, *]\n  · simp only [pow_succ', finsetWalkLength, ih, adjMatrix_mul_apply]\n    rw [Finset.card_biUnion]\n    · norm_cast\n      simp only [Nat.cast_sum, card_map, neighborFinset_def]\n      apply Finset.sum_toFinset_eq_subtype\n    -- Disjointness for card_bUnion\n    · rintro ⟨x, hx⟩ - ⟨y, hy⟩ - hxy\n      rw [disjoint_iff_inf_le]\n      intro p hp\n      simp only [inf_eq_inter, mem_inter, mem_map, Function.Embedding.coeFn_mk, exists_prop] at hp\n      obtain ⟨⟨px, _, rfl⟩, ⟨py, hpy, hp⟩⟩ := hp\n      cases hp\n      simp at hxy\n\n"}
{"name":"SimpleGraph.dotProduct_mulVec_adjMatrix","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\nG : SimpleGraph V\ninst✝² : DecidableRel G.Adj\ninst✝¹ : Fintype V\ninst✝ : NonAssocSemiring α\nx y : V → α\n⊢ Eq (dotProduct x ((SimpleGraph.adjMatrix α G).mulVec y)) (Finset.univ.sum fun i => Finset.univ.sum fun j => ite (G.Adj i j) (HMul.hMul (x i) (y j)) 0)","decl":"theorem dotProduct_mulVec_adjMatrix [NonAssocSemiring α] (x y : V → α) :\n    x ⬝ᵥ (G.adjMatrix α).mulVec y = ∑ i : V, ∑ j : V, if G.Adj i j then x i * y j else 0 := by\n  simp only [dotProduct, mulVec, adjMatrix_apply, ite_mul, one_mul, zero_mul, mul_sum, mul_ite,\n    mul_zero]\n\n"}
{"name":"Matrix.IsAdjMatrix.adjMatrix_toGraph_eq","module":"Mathlib.Combinatorics.SimpleGraph.AdjMatrix","initialProofState":"V : Type u_1\nα : Type u_2\ninst✝² : MulZeroOneClass α\ninst✝¹ : Nontrivial α\nA : Matrix V V α\nh : A.IsAdjMatrix\ninst✝ : DecidableEq α\n⊢ Eq (SimpleGraph.adjMatrix α h.toGraph) A","decl":"/-- If `A` is qualified as an adjacency matrix,\n    then the adjacency matrix of the graph induced by `A` is itself. -/\ntheorem adjMatrix_toGraph_eq [DecidableEq α] : h.toGraph.adjMatrix α = A := by\n  ext i j\n  obtain h' | h' := h.zero_or_one i j <;> simp [h']\n\n"}
