{"name":"StandardBorelSpace.polish","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nself : StandardBorelSpace Î±\nâŠ¢ Exists fun x => And (BorelSpace Î±) (PolishSpace Î±)","decl":"/-- A standard Borel space is a measurable space arising as the Borel sets of some Polish topology.\nThis is useful in situations where a space has no natural topology or\nthe natural topology in a space is non-Polish.\n\nTo endow a standard Borel space `Î±` with a compatible Polish topology, use\n`letI := upgradeStandardBorel Î±`. One can then use `eq_borel_upgradeStandardBorel Î±` to\nrewrite the `MeasurableSpace Î±` instance to `borel Î± t`, where `t` is the new topology. -/\nclass StandardBorelSpace [MeasurableSpace Î±] : Prop where\n  /-- There exists a compatible Polish topology. -/\n  polish : âˆƒ _ : TopologicalSpace Î±, BorelSpace Î± âˆ§ PolishSpace Î±\n\n"}
{"name":"UpgradedStandardBorel.toPolishSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\nself : UpgradedStandardBorel Î±\nâŠ¢ PolishSpace Î±","decl":"/-- A convenience class similar to `UpgradedPolishSpace`. No instance should be registered.\nInstead one should use `letI := upgradeStandardBorel Î±`. -/\nclass UpgradedStandardBorel extends MeasurableSpace Î±, TopologicalSpace Î±,\n  BorelSpace Î±, PolishSpace Î±\n\n"}
{"name":"UpgradedStandardBorel.toBorelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\nself : UpgradedStandardBorel Î±\nâŠ¢ BorelSpace Î±","decl":"/-- A convenience class similar to `UpgradedPolishSpace`. No instance should be registered.\nInstead one should use `letI := upgradeStandardBorel Î±`. -/\nclass UpgradedStandardBorel extends MeasurableSpace Î±, TopologicalSpace Î±,\n  BorelSpace Î±, PolishSpace Î±\n\n"}
{"name":"eq_borel_upgradeStandardBorel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : StandardBorelSpace Î±\nâŠ¢ Eq instâœÂ¹ (borel Î±)","decl":"/-- The `MeasurableSpace Î±` instance on a `StandardBorelSpace` `Î±` is equal to\nthe borel sets of `upgradeStandardBorel Î±`. -/\ntheorem eq_borel_upgradeStandardBorel [MeasurableSpace Î±] [StandardBorelSpace Î±] :\n    â€¹MeasurableSpace Î±â€º = @borel _ (upgradeStandardBorel Î±).toTopologicalSpace :=\n  @BorelSpace.measurable_eq _ (upgradeStandardBorel Î±).toTopologicalSpace _\n    (upgradeStandardBorel Î±).toBorelSpace\n\n"}
{"name":"standardBorel_of_polish","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : MeasurableSpace Î±\nÏ„ : TopologicalSpace Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : PolishSpace Î±\nâŠ¢ StandardBorelSpace Î±","decl":"instance (priority := 100) standardBorel_of_polish [Ï„ : TopologicalSpace Î±]\n    [BorelSpace Î±] [PolishSpace Î±] : StandardBorelSpace Î± := by exists Ï„\n\n-- See note [lower instance priority]\n"}
{"name":"standardBorelSpace_of_discreteMeasurableSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : DiscreteMeasurableSpace Î±\ninstâœ : Countable Î±\nâŠ¢ StandardBorelSpace Î±","decl":"instance (priority := 100) standardBorelSpace_of_discreteMeasurableSpace [DiscreteMeasurableSpace Î±]\n    [Countable Î±] : StandardBorelSpace Î± :=\n  let _ : TopologicalSpace Î± := âŠ¥\n  have : DiscreteTopology Î± := âŸ¨rflâŸ©\n  inferInstance\n\n-- See note [lower instance priority]\n"}
{"name":"countablyGenerated_of_standardBorel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : StandardBorelSpace Î±\nâŠ¢ MeasurableSpace.CountablyGenerated Î±","decl":"instance (priority := 100) countablyGenerated_of_standardBorel [StandardBorelSpace Î±] :\n    MeasurableSpace.CountablyGenerated Î± :=\n  letI := upgradeStandardBorel Î±\n  inferInstance\n\n-- See note [lower instance priority]\n"}
{"name":"measurableSingleton_of_standardBorel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : StandardBorelSpace Î±\nâŠ¢ MeasurableSingletonClass Î±","decl":"instance (priority := 100) measurableSingleton_of_standardBorel [StandardBorelSpace Î±] :\n    MeasurableSingletonClass Î± :=\n  letI := upgradeStandardBorel Î±\n  inferInstance\n\n"}
{"name":"StandardBorelSpace.prod","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : MeasurableSpace Î±\nÎ² : Type u_2\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : StandardBorelSpace Î±\ninstâœ : StandardBorelSpace Î²\nâŠ¢ StandardBorelSpace (Prod Î± Î²)","decl":"/-- A product of two standard Borel spaces is standard Borel. -/\ninstance prod [StandardBorelSpace Î±] [StandardBorelSpace Î²] : StandardBorelSpace (Î± Ã— Î²) :=\n  letI := upgradeStandardBorel Î±\n  letI := upgradeStandardBorel Î²\n  inferInstance\n\n"}
{"name":"StandardBorelSpace.pi_countable","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î¹ : Type u_3\ninstâœÂ² : Countable Î¹\nÎ± : Î¹ â†’ Type u_4\ninstâœÂ¹ : (n : Î¹) â†’ MeasurableSpace (Î± n)\ninstâœ : âˆ€ (n : Î¹), StandardBorelSpace (Î± n)\nâŠ¢ StandardBorelSpace ((n : Î¹) â†’ Î± n)","decl":"/-- A product of countably many standard Borel spaces is standard Borel. -/\ninstance pi_countable {Î¹ : Type*} [Countable Î¹] {Î± : Î¹ â†’ Type*} [âˆ€ n, MeasurableSpace (Î± n)]\n    [âˆ€ n, StandardBorelSpace (Î± n)] : StandardBorelSpace (âˆ€ n, Î± n) :=\n  letI := fun n => upgradeStandardBorel (Î± n)\n  inferInstance\n\n"}
{"name":"MeasureTheory.AnalyticSet_def","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_3\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nâŠ¢ Eq (MeasureTheory.AnalyticSet s) (Or (Eq s EmptyCollection.emptyCollection) (Exists fun f => And (Continuous f) (Eq (Set.range f) s)))","decl":"/-- An analytic set is a set which is the continuous image of some Polish space. There are several\nequivalent characterizations of this definition. For the definition, we pick one that avoids\nuniverse issues: a set is analytic if and only if it is a continuous image of `â„• â†’ â„•` (or if it\nis empty). The above more usual characterization is given\nin `analyticSet_iff_exists_polishSpace_range`.\n\nWarning: these are analytic sets in the context of descriptive set theory (which is why they are\nregistered in the namespace `MeasureTheory`). They have nothing to do with analytic sets in the\ncontext of complex analysis. -/\nirreducible_def AnalyticSet (s : Set Î±) : Prop :=\n  s = âˆ… âˆ¨ âˆƒ f : (â„• â†’ â„•) â†’ Î±, Continuous f âˆ§ range f = s\n\n"}
{"name":"MeasureTheory.analyticSet_empty","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nâŠ¢ MeasureTheory.AnalyticSet EmptyCollection.emptyCollection","decl":"theorem analyticSet_empty : AnalyticSet (âˆ… : Set Î±) := by\n  rw [AnalyticSet]\n  exact Or.inl rfl\n\n"}
{"name":"MeasureTheory.analyticSet_range_of_polishSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : PolishSpace Î²\nf : Î² â†’ Î±\nf_cont : Continuous f\nâŠ¢ MeasureTheory.AnalyticSet (Set.range f)","decl":"theorem analyticSet_range_of_polishSpace {Î² : Type*} [TopologicalSpace Î²] [PolishSpace Î²]\n    {f : Î² â†’ Î±} (f_cont : Continuous f) : AnalyticSet (range f) := by\n  cases isEmpty_or_nonempty Î²\n  Â· rw [range_eq_empty]\n    exact analyticSet_empty\n  Â· rw [AnalyticSet]\n    obtain âŸ¨g, g_cont, hgâŸ© : âˆƒ g : (â„• â†’ â„•) â†’ Î², Continuous g âˆ§ Surjective g :=\n      exists_nat_nat_continuous_surjective Î²\n    refine Or.inr âŸ¨f âˆ˜ g, f_cont.comp g_cont, ?_âŸ©\n    rw [hg.range_comp]\n\n"}
{"name":"IsOpen.analyticSet_image","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : TopologicalSpace Î±\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : PolishSpace Î²\ns : Set Î²\nhs : IsOpen s\nf : Î² â†’ Î±\nf_cont : Continuous f\nâŠ¢ MeasureTheory.AnalyticSet (Set.image f s)","decl":"/-- The image of an open set under a continuous map is analytic. -/\ntheorem _root_.IsOpen.analyticSet_image {Î² : Type*} [TopologicalSpace Î²] [PolishSpace Î²]\n    {s : Set Î²} (hs : IsOpen s) {f : Î² â†’ Î±} (f_cont : Continuous f) : AnalyticSet (f '' s) := by\n  rw [image_eq_range]\n  haveI : PolishSpace s := hs.polishSpace\n  exact analyticSet_range_of_polishSpace (f_cont.comp continuous_subtype_val)\n\n"}
{"name":"MeasureTheory.analyticSet_iff_exists_polishSpace_range","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nâŠ¢ Iff (MeasureTheory.AnalyticSet s) (Exists fun Î² => Exists fun h => Exists fun x => Exists fun f => And (Continuous f) (Eq (Set.range f) s))","decl":"/-- A set is analytic if and only if it is the continuous image of some Polish space. -/\ntheorem analyticSet_iff_exists_polishSpace_range {s : Set Î±} :\n    AnalyticSet s â†”\n      âˆƒ (Î² : Type) (h : TopologicalSpace Î²) (_ : @PolishSpace Î² h) (f : Î² â†’ Î±),\n        @Continuous _ _ h _ f âˆ§ range f = s := by\n  constructor\n  Â· intro h\n    rw [AnalyticSet] at h\n    cases' h with h h\n    Â· refine âŸ¨Empty, inferInstance, inferInstance, Empty.elim, continuous_bot, ?_âŸ©\n      rw [h]\n      exact range_eq_empty _\n    Â· exact âŸ¨â„• â†’ â„•, inferInstance, inferInstance, hâŸ©\n  Â· rintro âŸ¨Î², h, h', f, f_cont, f_rangeâŸ©\n    rw [â† f_range]\n    exact analyticSet_range_of_polishSpace f_cont\n\n"}
{"name":"MeasureTheory.AnalyticSet.image_of_continuousOn","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\ns : Set Î±\nhs : MeasureTheory.AnalyticSet s\nf : Î± â†’ Î²\nhf : ContinuousOn f s\nâŠ¢ MeasureTheory.AnalyticSet (Set.image f s)","decl":"/-- The continuous image of an analytic set is analytic -/\ntheorem AnalyticSet.image_of_continuousOn {Î² : Type*} [TopologicalSpace Î²] {s : Set Î±}\n    (hs : AnalyticSet s) {f : Î± â†’ Î²} (hf : ContinuousOn f s) : AnalyticSet (f '' s) := by\n  rcases analyticSet_iff_exists_polishSpace_range.1 hs with âŸ¨Î³, Î³top, Î³polish, g, g_cont, gsâŸ©\n  have : f '' s = range (f âˆ˜ g) := by rw [range_comp, gs]\n  rw [this]\n  apply analyticSet_range_of_polishSpace\n  apply hf.comp_continuous g_cont fun x => _\n  rw [â† gs]\n  exact mem_range_self\n\n"}
{"name":"MeasureTheory.AnalyticSet.image_of_continuous","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\nÎ² : Type u_3\ninstâœ : TopologicalSpace Î²\ns : Set Î±\nhs : MeasureTheory.AnalyticSet s\nf : Î± â†’ Î²\nhf : Continuous f\nâŠ¢ MeasureTheory.AnalyticSet (Set.image f s)","decl":"theorem AnalyticSet.image_of_continuous {Î² : Type*} [TopologicalSpace Î²] {s : Set Î±}\n    (hs : AnalyticSet s) {f : Î± â†’ Î²} (hf : Continuous f) : AnalyticSet (f '' s) :=\n  hs.image_of_continuousOn hf.continuousOn\n\n"}
{"name":"MeasureTheory.AnalyticSet.iInter","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : TopologicalSpace Î±\nhÎ¹ : Nonempty Î¹\ninstâœÂ¹ : Countable Î¹\ninstâœ : T2Space Î±\ns : Î¹ â†’ Set Î±\nhs : âˆ€ (n : Î¹), MeasureTheory.AnalyticSet (s n)\nâŠ¢ MeasureTheory.AnalyticSet (Set.iInter fun n => s n)","decl":"/-- A countable intersection of analytic sets is analytic. -/\ntheorem AnalyticSet.iInter [hÎ¹ : Nonempty Î¹] [Countable Î¹] [T2Space Î±] {s : Î¹ â†’ Set Î±}\n    (hs : âˆ€ n, AnalyticSet (s n)) : AnalyticSet (â‹‚ n, s n) := by\n  rcases hÎ¹ with âŸ¨iâ‚€âŸ©\n  /- For the proof, write each `s n` as the continuous image under a map `f n` of a\n    Polish space `Î² n`. The product space `Î³ = Î  n, Î² n` is also Polish, and so is the subset\n    `t` of sequences `x n` for which `f n (x n)` is independent of `n`. The set `t` is Polish, and\n    the range of `x â†¦ f 0 (x 0)` on `t` is exactly `â‹‚ n, s n`, so this set is analytic. -/\n  choose Î² hÎ² h'Î² f f_cont f_range using fun n =>\n    analyticSet_iff_exists_polishSpace_range.1 (hs n)\n  let Î³ := âˆ€ n, Î² n\n  let t : Set Î³ := â‹‚ n, { x | f n (x n) = f iâ‚€ (x iâ‚€) }\n  have t_closed : IsClosed t := by\n    apply isClosed_iInter\n    intro n\n    exact\n      isClosed_eq ((f_cont n).comp (continuous_apply n)) ((f_cont iâ‚€).comp (continuous_apply iâ‚€))\n  haveI : PolishSpace t := t_closed.polishSpace\n  let F : t â†’ Î± := fun x => f iâ‚€ ((x : Î³) iâ‚€)\n  have F_cont : Continuous F := (f_cont iâ‚€).comp ((continuous_apply iâ‚€).comp continuous_subtype_val)\n  have F_range : range F = â‹‚ n : Î¹, s n := by\n    apply Subset.antisymm\n    Â· rintro y âŸ¨x, rflâŸ©\n      refine mem_iInter.2 fun n => ?_\n      have : f n ((x : Î³) n) = F x := (mem_iInter.1 x.2 n :)\n      rw [â† this, â† f_range n]\n      exact mem_range_self _\n    Â· intro y hy\n      have A : âˆ€ n, âˆƒ x : Î² n, f n x = y := by\n        intro n\n        rw [â† mem_range, f_range n]\n        exact mem_iInter.1 hy n\n      choose x hx using A\n      have xt : x âˆˆ t := by\n        refine mem_iInter.2 fun n => ?_\n        simp [Î³, t, F, hx]\n      refine âŸ¨âŸ¨x, xtâŸ©, ?_âŸ©\n      exact hx iâ‚€\n  rw [â† F_range]\n  exact analyticSet_range_of_polishSpace F_cont\n\n"}
{"name":"MeasureTheory.AnalyticSet.iUnion","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set Î±\nhs : âˆ€ (n : Î¹), MeasureTheory.AnalyticSet (s n)\nâŠ¢ MeasureTheory.AnalyticSet (Set.iUnion fun n => s n)","decl":"/-- A countable union of analytic sets is analytic. -/\ntheorem AnalyticSet.iUnion [Countable Î¹] {s : Î¹ â†’ Set Î±} (hs : âˆ€ n, AnalyticSet (s n)) :\n    AnalyticSet (â‹ƒ n, s n) := by\n  /- For the proof, write each `s n` as the continuous image under a map `f n` of a\n    Polish space `Î² n`. The union space `Î³ = Î£ n, Î² n` is also Polish, and the map `F : Î³ â†’ Î±` which\n    coincides with `f n` on `Î² n` sends it to `â‹ƒ n, s n`. -/\n  choose Î² hÎ² h'Î² f f_cont f_range using fun n =>\n    analyticSet_iff_exists_polishSpace_range.1 (hs n)\n  let Î³ := Î£n, Î² n\n  let F : Î³ â†’ Î± := fun âŸ¨n, xâŸ© â†¦ f n x\n  have F_cont : Continuous F := continuous_sigma f_cont\n  have F_range : range F = â‹ƒ n, s n := by\n    simp only [Î³, F, range_sigma_eq_iUnion_range, f_range]\n  rw [â† F_range]\n  exact analyticSet_range_of_polishSpace F_cont\n\n"}
{"name":"IsClosed.analyticSet","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PolishSpace Î±\ns : Set Î±\nhs : IsClosed s\nâŠ¢ MeasureTheory.AnalyticSet s","decl":"theorem _root_.IsClosed.analyticSet [PolishSpace Î±] {s : Set Î±} (hs : IsClosed s) :\n    AnalyticSet s := by\n  haveI : PolishSpace s := hs.polishSpace\n  rw [â† @Subtype.range_val Î± s]\n  exact analyticSet_range_of_polishSpace continuous_subtype_val\n\n"}
{"name":"MeasurableSet.isClopenable","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PolishSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : BorelSpace Î±\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ PolishSpace.IsClopenable s","decl":"/-- Given a Borel-measurable set in a Polish space, there exists a finer Polish topology making\nit clopen. This is in fact an equivalence, see `isClopenable_iff_measurableSet`. -/\ntheorem _root_.MeasurableSet.isClopenable [PolishSpace Î±] [MeasurableSpace Î±] [BorelSpace Î±]\n    {s : Set Î±} (hs : MeasurableSet s) : IsClopenable s := by\n  revert s\n  apply MeasurableSet.induction_on_open\n  Â· exact fun u hu => hu.isClopenable\n  Â· exact fun u _ h'u => h'u.compl\n  Â· exact fun f _ _ hf => IsClopenable.iUnion hf\n\n"}
{"name":"MeasurableSet.analyticSet","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_3\nt : TopologicalSpace Î±\ninstâœÂ² : PolishSpace Î±\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : BorelSpace Î±\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.AnalyticSet s","decl":"/-- A Borel-measurable set in a Polish space is analytic. -/\ntheorem _root_.MeasurableSet.analyticSet {Î± : Type*} [t : TopologicalSpace Î±] [PolishSpace Î±]\n    [MeasurableSpace Î±] [BorelSpace Î±] {s : Set Î±} (hs : MeasurableSet s) : AnalyticSet s := by\n  /- For a short proof (avoiding measurable induction), one sees `s` as a closed set for a finer\n    topology `t'`. It is analytic for this topology. As the identity from `t'` to `t` is continuous\n    and the image of an analytic set is analytic, it follows that `s` is also analytic for `t`. -/\n  obtain âŸ¨t', t't, t'_polish, s_closed, _âŸ© :\n      âˆƒ t' : TopologicalSpace Î±, t' â‰¤ t âˆ§ @PolishSpace Î± t' âˆ§ IsClosed[t'] s âˆ§ IsOpen[t'] s :=\n    hs.isClopenable\n  have A := @IsClosed.analyticSet Î± t' t'_polish s s_closed\n  convert @AnalyticSet.image_of_continuous Î± t' Î± t s A id (continuous_id_of_le t't)\n  simp only [id, image_id']\n\n"}
{"name":"Measurable.exists_continuous","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_3\nÎ² : Type u_4\nt : TopologicalSpace Î±\ninstâœâµ : PolishSpace Î±\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\ntÎ² : TopologicalSpace Î²\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : OpensMeasurableSpace Î²\nf : Î± â†’ Î²\ninstâœ : SecondCountableTopology â†‘(Set.range f)\nhf : Measurable f\nâŠ¢ Exists fun t' => And (LE.le t' t) (And (Continuous f) (PolishSpace Î±))","decl":"/-- Given a Borel-measurable function from a Polish space to a second-countable space, there exists\na finer Polish topology on the source space for which the function is continuous. -/\ntheorem _root_.Measurable.exists_continuous {Î± Î² : Type*} [t : TopologicalSpace Î±] [PolishSpace Î±]\n    [MeasurableSpace Î±] [BorelSpace Î±] [tÎ² : TopologicalSpace Î²] [MeasurableSpace Î²]\n    [OpensMeasurableSpace Î²] {f : Î± â†’ Î²} [SecondCountableTopology (range f)] (hf : Measurable f) :\n    âˆƒ t' : TopologicalSpace Î±, t' â‰¤ t âˆ§ @Continuous Î± Î² t' tÎ² f âˆ§ @PolishSpace Î± t' := by\n  obtain âŸ¨b, b_count, -, hbâŸ© :\n      âˆƒ b : Set (Set (range f)), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b :=\n    exists_countable_basis (range f)\n  haveI : Countable b := b_count.to_subtype\n  have : âˆ€ s : b, IsClopenable (rangeFactorization f â»Â¹' s) := fun s â†¦ by\n    apply MeasurableSet.isClopenable\n    exact hf.subtype_mk (hb.isOpen s.2).measurableSet\n  choose T Tt Tpolish _ Topen using this\n  obtain âŸ¨t', t'T, t't, t'_polishâŸ© :\n      âˆƒ t' : TopologicalSpace Î±, (âˆ€ i, t' â‰¤ T i) âˆ§ t' â‰¤ t âˆ§ @PolishSpace Î± t' :=\n    exists_polishSpace_forall_le (t := t) T Tt Tpolish\n  refine âŸ¨t', t't, ?_, t'_polishâŸ©\n  have : Continuous[t', _] (rangeFactorization f) :=\n    hb.continuous_iff.2 fun s hs => t'T âŸ¨s, hsâŸ© _ (Topen âŸ¨s, hsâŸ©)\n  exact continuous_subtype_val.comp this\n\n"}
{"name":"MeasurableSet.analyticSet_image","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœâµ : MeasurableSpace X\ninstâœâ´ : StandardBorelSpace X\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : MeasurableSpace Y\ninstâœÂ¹ : OpensMeasurableSpace Y\nf : X â†’ Y\ninstâœ : SecondCountableTopology â†‘(Set.range f)\ns : Set X\nhs : MeasurableSet s\nhf : Measurable f\nâŠ¢ MeasureTheory.AnalyticSet (Set.image f s)","decl":"/-- The image of a measurable set in a standard Borel space under a measurable map\nis an analytic set. -/\ntheorem _root_.MeasurableSet.analyticSet_image {X Y : Type*} [MeasurableSpace X]\n    [StandardBorelSpace X] [TopologicalSpace Y] [MeasurableSpace Y]\n    [OpensMeasurableSpace Y] {f : X â†’ Y} [SecondCountableTopology (range f)] {s : Set X}\n    (hs : MeasurableSet s) (hf : Measurable f) : AnalyticSet (f '' s) := by\n  letI := upgradeStandardBorel X\n  rw [eq_borel_upgradeStandardBorel X] at hs\n  rcases hf.exists_continuous with âŸ¨Ï„', hle, hfc, hÏ„'âŸ©\n  letI m' : MeasurableSpace X := @borel _ Ï„'\n  haveI b' : BorelSpace X := âŸ¨rflâŸ©\n  have hle := borel_anti hle\n  exact (hle _ hs).analyticSet.image_of_continuous hfc\n\n"}
{"name":"MeasureTheory.AnalyticSet.preimage","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : PolishSpace X\ninstâœ : T2Space Y\ns : Set Y\nhs : MeasureTheory.AnalyticSet s\nf : X â†’ Y\nhf : Continuous f\nâŠ¢ MeasureTheory.AnalyticSet (Set.preimage f s)","decl":"/-- Preimage of an analytic set is an analytic set. -/\nprotected lemma AnalyticSet.preimage {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [PolishSpace X] [T2Space Y] {s : Set Y} (hs : AnalyticSet s) {f : X â†’ Y} (hf : Continuous f) :\n    AnalyticSet (f â»Â¹' s) := by\n  rcases analyticSet_iff_exists_polishSpace_range.1 hs with âŸ¨Z, _, _, g, hg, rflâŸ©\n  have : IsClosed {x : X Ã— Z | f x.1 = g x.2} := isClosed_eq hf.fst' hg.snd'\n  convert this.analyticSet.image_of_continuous continuous_fst\n  ext x\n  simp [eq_comm]\n\n"}
{"name":"MeasureTheory.MeasurablySeparable.iUnion","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î¹ : Type u_2\ninstâœÂ¹ : Countable Î¹\nÎ± : Type u_3\ninstâœ : MeasurableSpace Î±\ns t : Î¹ â†’ Set Î±\nh : âˆ€ (m n : Î¹), MeasureTheory.MeasurablySeparable (s m) (t n)\nâŠ¢ MeasureTheory.MeasurablySeparable (Set.iUnion fun n => s n) (Set.iUnion fun m => t m)","decl":"theorem MeasurablySeparable.iUnion [Countable Î¹] {Î± : Type*} [MeasurableSpace Î±] {s t : Î¹ â†’ Set Î±}\n    (h : âˆ€ m n, MeasurablySeparable (s m) (t n)) : MeasurablySeparable (â‹ƒ n, s n) (â‹ƒ m, t m) := by\n  choose u hsu htu hu using h\n  refine âŸ¨â‹ƒ m, â‹‚ n, u m n, ?_, ?_, ?_âŸ©\n  Â· refine iUnion_subset fun m => subset_iUnion_of_subset m ?_\n    exact subset_iInter fun n => hsu m n\n  Â· simp_rw [disjoint_iUnion_left, disjoint_iUnion_right]\n    intro n m\n    apply Disjoint.mono_right _ (htu m n)\n    apply iInter_subset\n  Â· refine MeasurableSet.iUnion fun m => ?_\n    exact MeasurableSet.iInter fun n => hu m n\n\n"}
{"name":"MeasureTheory.measurablySeparable_range_of_disjoint","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : T2Space Î±\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : OpensMeasurableSpace Î±\nf g : (Nat â†’ Nat) â†’ Î±\nhf : Continuous f\nhg : Continuous g\nh : Disjoint (Set.range f) (Set.range g)\nâŠ¢ MeasureTheory.MeasurablySeparable (Set.range f) (Set.range g)","decl":"/-- The hard part of the Lusin separation theorem saying that two disjoint analytic sets are\ncontained in disjoint Borel sets (see the full statement in `AnalyticSet.measurablySeparable`).\nHere, we prove this when our analytic sets are the ranges of functions from `â„• â†’ â„•`.\n-/\ntheorem measurablySeparable_range_of_disjoint [T2Space Î±] [MeasurableSpace Î±]\n    [OpensMeasurableSpace Î±] {f g : (â„• â†’ â„•) â†’ Î±} (hf : Continuous f) (hg : Continuous g)\n    (h : Disjoint (range f) (range g)) : MeasurablySeparable (range f) (range g) := by\n  /- We follow [Kechris, *Classical Descriptive Set Theory* (Theorem 14.7)][kechris1995].\n    If the ranges are not Borel-separated, then one can find two cylinders of length one whose\n    images are not Borel-separated, and then two smaller cylinders of length two whose images are\n    not Borel-separated, and so on. One thus gets two sequences of cylinders, that decrease to two\n    points `x` and `y`. Their images are different by the disjointness assumption, hence contained\n    in two disjoint open sets by the T2 property. By continuity, long enough cylinders around `x`\n    and `y` have images which are separated by these two disjoint open sets, a contradiction.\n    -/\n  by_contra hfg\n  have I : âˆ€ n x y, Â¬MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) â†’\n      âˆƒ x' y', x' âˆˆ cylinder x n âˆ§ y' âˆˆ cylinder y n âˆ§\n      Â¬MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by\n    intro n x y\n    contrapose!\n    intro H\n    rw [â† iUnion_cylinder_update x n, â† iUnion_cylinder_update y n, image_iUnion, image_iUnion]\n    refine MeasurablySeparable.iUnion fun i j => ?_\n    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)\n  -- consider the set of pairs of cylinders of some length whose images are not Borel-separated\n  let A :=\n    { p : â„• Ã— (â„• â†’ â„•) Ã— (â„• â†’ â„•) //\n      Â¬MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }\n  -- for each such pair, one can find longer cylinders whose images are not Borel-separated either\n  have : âˆ€ p : A, âˆƒ q : A,\n      q.1.1 = p.1.1 + 1 âˆ§ q.1.2.1 âˆˆ cylinder p.1.2.1 p.1.1 âˆ§ q.1.2.2 âˆˆ cylinder p.1.2.2 p.1.1 := by\n    rintro âŸ¨âŸ¨n, x, yâŸ©, hpâŸ©\n    rcases I n x y hp with âŸ¨x', y', hx', hy', h'âŸ©\n    exact âŸ¨âŸ¨âŸ¨n + 1, x', y'âŸ©, h'âŸ©, rfl, hx', hy'âŸ©\n  choose F hFn hFx hFy using this\n  let p0 : A := âŸ¨âŸ¨0, fun _ => 0, fun _ => 0âŸ©, by simp [hfg]âŸ©\n  -- construct inductively decreasing sequences of cylinders whose images are not separated\n  let p : â„• â†’ A := fun n => F^[n] p0\n  have prec : âˆ€ n, p (n + 1) = F (p n) := fun n => by simp only [p, iterate_succ', Function.comp]\n  -- check that at the `n`-th step we deal with cylinders of length `n`\n  have pn_fst : âˆ€ n, (p n).1.1 = n := by\n    intro n\n    induction' n with n IH\n    Â· rfl\n    Â· simp only [prec, hFn, IH]\n  -- check that the cylinders we construct are indeed decreasing, by checking that the coordinates\n  -- are stationary.\n  have Ix : âˆ€ m n, m + 1 â‰¤ n â†’ (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by\n    intro m\n    apply Nat.le_induction\n    Â· rfl\n    intro n hmn IH\n    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by\n      apply hFx (p n) m\n      rw [pn_fst]\n      exact hmn\n    rw [prec, I, IH]\n  have Iy : âˆ€ m n, m + 1 â‰¤ n â†’ (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by\n    intro m\n    apply Nat.le_induction\n    Â· rfl\n    intro n hmn IH\n    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by\n      apply hFy (p n) m\n      rw [pn_fst]\n      exact hmn\n    rw [prec, I, IH]\n  -- denote by `x` and `y` the limit points of these two sequences of cylinders.\n  set x : â„• â†’ â„• := fun n => (p (n + 1)).1.2.1 n with hx\n  set y : â„• â†’ â„• := fun n => (p (n + 1)).1.2.2 n with hy\n  -- by design, the cylinders around these points have images which are not Borel-separable.\n  have M : âˆ€ n, Â¬MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by\n    intro n\n    convert (p n).2 using 3\n    Â· rw [pn_fst, â† mem_cylinder_iff_eq, mem_cylinder_iff]\n      intro i hi\n      rw [hx]\n      exact (Ix i n hi).symm\n    Â· rw [pn_fst, â† mem_cylinder_iff_eq, mem_cylinder_iff]\n      intro i hi\n      rw [hy]\n      exact (Iy i n hi).symm\n  -- consider two open sets separating `f x` and `g y`.\n  obtain âŸ¨u, v, u_open, v_open, xu, yv, huvâŸ© :\n      âˆƒ u v : Set Î±, IsOpen u âˆ§ IsOpen v âˆ§ f x âˆˆ u âˆ§ g y âˆˆ v âˆ§ Disjoint u v := by\n    apply t2_separation\n    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)\n  letI : MetricSpace (â„• â†’ â„•) := metricSpaceNatNat\n  obtain âŸ¨Îµx, Îµxpos, hÎµxâŸ© : âˆƒ (Îµx : â„), Îµx > 0 âˆ§ Metric.ball x Îµx âŠ† f â»Â¹' u := by\n    apply Metric.mem_nhds_iff.1\n    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)\n  obtain âŸ¨Îµy, Îµypos, hÎµyâŸ© : âˆƒ (Îµy : â„), Îµy > 0 âˆ§ Metric.ball y Îµy âŠ† g â»Â¹' v := by\n    apply Metric.mem_nhds_iff.1\n    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)\n  obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, (1 / 2 : â„) ^ n < min Îµx Îµy :=\n    exists_pow_lt_of_lt_one (lt_min Îµxpos Îµypos) (by norm_num)\n  -- for large enough `n`, these open sets separate the images of long cylinders around `x` and `y`\n  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by\n    refine âŸ¨u, ?_, ?_, u_open.measurableSetâŸ©\n    Â· rw [image_subset_iff]\n      apply Subset.trans _ hÎµx\n      intro z hz\n      rw [mem_cylinder_iff_dist_le] at hz\n      exact hz.trans_lt (hn.trans_le (min_le_left _ _))\n    Â· refine Disjoint.mono_left ?_ huv.symm\n      change g '' cylinder y n âŠ† v\n      rw [image_subset_iff]\n      apply Subset.trans _ hÎµy\n      intro z hz\n      rw [mem_cylinder_iff_dist_le] at hz\n      exact hz.trans_lt (hn.trans_le (min_le_right _ _))\n  -- this is a contradiction.\n  exact M n B\n\n"}
{"name":"MeasureTheory.AnalyticSet.measurablySeparable","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : T2Space Î±\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : OpensMeasurableSpace Î±\ns t : Set Î±\nhs : MeasureTheory.AnalyticSet s\nht : MeasureTheory.AnalyticSet t\nh : Disjoint s t\nâŠ¢ MeasureTheory.MeasurablySeparable s t","decl":"/-- The **Lusin separation theorem**: if two analytic sets are disjoint, then they are contained in\ndisjoint Borel sets. -/\ntheorem AnalyticSet.measurablySeparable [T2Space Î±] [MeasurableSpace Î±] [OpensMeasurableSpace Î±]\n    {s t : Set Î±} (hs : AnalyticSet s) (ht : AnalyticSet t) (h : Disjoint s t) :\n    MeasurablySeparable s t := by\n  rw [AnalyticSet] at hs ht\n  rcases hs with (rfl | âŸ¨f, f_cont, rflâŸ©)\n  Â· refine âŸ¨âˆ…, Subset.refl _, by simp, MeasurableSet.emptyâŸ©\n  rcases ht with (rfl | âŸ¨g, g_cont, rflâŸ©)\n  Â· exact âŸ¨univ, subset_univ _, by simp, MeasurableSet.univâŸ©\n  exact measurablySeparable_range_of_disjoint f_cont g_cont h\n\n"}
{"name":"MeasureTheory.AnalyticSet.measurableSet_of_compl","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : T2Space Î±\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : OpensMeasurableSpace Î±\ns : Set Î±\nhs : MeasureTheory.AnalyticSet s\nhsc : MeasureTheory.AnalyticSet (HasCompl.compl s)\nâŠ¢ MeasurableSet s","decl":"/-- **Suslin's Theorem**: in a Hausdorff topological space, an analytic set with an analytic\ncomplement is measurable. -/\ntheorem AnalyticSet.measurableSet_of_compl [T2Space Î±] [MeasurableSpace Î±] [OpensMeasurableSpace Î±]\n    {s : Set Î±} (hs : AnalyticSet s) (hsc : AnalyticSet sá¶œ) : MeasurableSet s := by\n  rcases hs.measurablySeparable hsc disjoint_compl_right with âŸ¨u, hsu, hdu, hmuâŸ©\n  obtain rfl : s = u := hsu.antisymm (disjoint_compl_left_iff_subset.1 hdu)\n  exact hmu\n\n"}
{"name":"Measurable.measurableSet_preimage_iff_of_surjective","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : StandardBorelSpace X\ninstâœÂ¹ : MeasurableSpace Z\ninstâœ : MeasurableSpace.CountablySeparated Z\nf : X â†’ Z\nhf : Measurable f\nhsurj : Function.Surjective f\ns : Set Z\nâŠ¢ Iff (MeasurableSet (Set.preimage f s)) (MeasurableSet s)","decl":"/-- If `f : X â†’ Z` is a surjective Borel measurable map from a standard Borel space\nto a countably separated measurable space, then the preimage of a set `s`\nis measurable if and only if the set is measurable.\nOne implication is the definition of measurability, the other one heavily relies on `X` being a\nstandard Borel space. -/\ntheorem measurableSet_preimage_iff_of_surjective [CountablySeparated Z]\n    {f : X â†’ Z} (hf : Measurable f) (hsurj : Surjective f) {s : Set Z} :\n    MeasurableSet (f â»Â¹' s) â†” MeasurableSet s := by\n  refine âŸ¨fun h => ?_, fun h => hf hâŸ©\n  rcases exists_opensMeasurableSpace_of_countablySeparated Z with âŸ¨Ï„, _, _, _âŸ©\n  apply AnalyticSet.measurableSet_of_compl\n  Â· rw [â† image_preimage_eq s hsurj]\n    exact h.analyticSet_image hf\n  Â· rw [â† image_preimage_eq sá¶œ hsurj]\n    exact h.compl.analyticSet_image hf\n\n"}
{"name":"Measurable.map_measurableSpace_eq","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : StandardBorelSpace X\ninstâœÂ¹ : MeasurableSpace Z\ninstâœ : MeasurableSpace.CountablySeparated Z\nf : X â†’ Z\nhf : Measurable f\nhsurj : Function.Surjective f\nâŠ¢ Eq (MeasurableSpace.map f instâœÂ³) instâœÂ¹","decl":"theorem map_measurableSpace_eq [CountablySeparated Z]\n    {f : X â†’ Z} (hf : Measurable f)\n    (hsurj : Surjective f) : MeasurableSpace.map f â€¹MeasurableSpace Xâ€º = â€¹MeasurableSpace Zâ€º :=\n  MeasurableSpace.ext fun _ => hf.measurableSet_preimage_iff_of_surjective hsurj\n\n"}
{"name":"Measurable.map_measurableSpace_eq_borel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœâ¶ : MeasurableSpace X\ninstâœâµ : StandardBorelSpace X\ninstâœâ´ : TopologicalSpace Y\ninstâœÂ³ : T0Space Y\ninstâœÂ² : MeasurableSpace Y\ninstâœÂ¹ : OpensMeasurableSpace Y\ninstâœ : SecondCountableTopology Y\nf : X â†’ Y\nhf : Measurable f\nhsurj : Function.Surjective f\nâŠ¢ Eq (MeasurableSpace.map f instâœâ¶) (borel Y)","decl":"theorem map_measurableSpace_eq_borel [SecondCountableTopology Y] {f : X â†’ Y} (hf : Measurable f)\n    (hsurj : Surjective f) : MeasurableSpace.map f â€¹MeasurableSpace Xâ€º = borel Y := by\n  have d := hf.mono le_rfl OpensMeasurableSpace.borel_le\n  letI := borel Y; haveI : BorelSpace Y := âŸ¨rflâŸ©\n  exact d.map_measurableSpace_eq hsurj\n\n"}
{"name":"Measurable.borelSpace_codomain","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœâ¶ : MeasurableSpace X\ninstâœâµ : StandardBorelSpace X\ninstâœâ´ : TopologicalSpace Y\ninstâœÂ³ : T0Space Y\ninstâœÂ² : MeasurableSpace Y\ninstâœÂ¹ : OpensMeasurableSpace Y\ninstâœ : SecondCountableTopology Y\nf : X â†’ Y\nhf : Measurable f\nhsurj : Function.Surjective f\nâŠ¢ BorelSpace Y","decl":"theorem borelSpace_codomain [SecondCountableTopology Y] {f : X â†’ Y} (hf : Measurable f)\n    (hsurj : Surjective f) : BorelSpace Y :=\n  âŸ¨(hf.map_measurableSpace_eq hsurj).symm.trans <| hf.map_measurableSpace_eq_borel hsurjâŸ©\n\n"}
{"name":"Measurable.measurableSet_preimage_iff_preimage_val","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : StandardBorelSpace X\ninstâœÂ¹ : MeasurableSpace Z\nf : X â†’ Z\ninstâœ : MeasurableSpace.CountablySeparated â†‘(Set.range f)\nhf : Measurable f\ns : Set Z\nâŠ¢ Iff (MeasurableSet (Set.preimage f s)) (MeasurableSet (Set.preimage Subtype.val s))","decl":"/-- If `f : X â†’ Z` is a Borel measurable map from a standard Borel space to a\ncountably separated measurable space then the preimage of a set `s` is measurable\nif and only if the set is measurable in `Set.range f`. -/\ntheorem measurableSet_preimage_iff_preimage_val {f : X â†’ Z} [CountablySeparated (range f)]\n    (hf : Measurable f) {s : Set Z} :\n    MeasurableSet (f â»Â¹' s) â†” MeasurableSet ((â†‘) â»Â¹' s : Set (range f)) :=\n  have hf' : Measurable (rangeFactorization f) := hf.subtype_mk\n  hf'.measurableSet_preimage_iff_of_surjective (s := Subtype.val â»Â¹' s) surjective_onto_range\n\n"}
{"name":"Measurable.measurableSet_preimage_iff_inter_range","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : StandardBorelSpace X\ninstâœÂ¹ : MeasurableSpace Z\nf : X â†’ Z\ninstâœ : MeasurableSpace.CountablySeparated â†‘(Set.range f)\nhf : Measurable f\nhr : MeasurableSet (Set.range f)\ns : Set Z\nâŠ¢ Iff (MeasurableSet (Set.preimage f s)) (MeasurableSet (Inter.inter s (Set.range f)))","decl":"/-- If `f : X â†’ Z` is a Borel measurable map from a standard Borel space to a\ncountably separated measurable space and the range of `f` is measurable,\nthen the preimage of a set `s` is measurable\nif and only if the intersection with `Set.range f` is measurable. -/\ntheorem measurableSet_preimage_iff_inter_range {f : X â†’ Z} [CountablySeparated (range f)]\n    (hf : Measurable f) (hr : MeasurableSet (range f)) {s : Set Z} :\n    MeasurableSet (f â»Â¹' s) â†” MeasurableSet (s âˆ© range f) := by\n  rw [hf.measurableSet_preimage_iff_preimage_val, inter_comm,\n    â† (MeasurableEmbedding.subtype_coe hr).measurableSet_image, Subtype.image_preimage_coe]\n\n"}
{"name":"Measurable.measurable_comp_iff_restrict","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\nÎ² : Type u_6\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : StandardBorelSpace X\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : MeasurableSpace Z\nf : X â†’ Z\ninstâœ : MeasurableSpace.CountablySeparated â†‘(Set.range f)\nhf : Measurable f\ng : Z â†’ Î²\nâŠ¢ Iff (Measurable (Function.comp g f)) (Measurable ((Set.range f).restrict g))","decl":"/-- If `f : X â†’ Z` is a Borel measurable map from a standard Borel space\nto a countably separated measurable space,\nthen for any measurable space `Î²` and `g : Z â†’ Î²`, the composition `g âˆ˜ f` is\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. -/\ntheorem measurable_comp_iff_restrict {f : X â†’ Z}\n    [CountablySeparated (range f)]\n    (hf : Measurable f) {g : Z â†’ Î²} : Measurable (g âˆ˜ f) â†” Measurable (restrict (range f) g) :=\n  forallâ‚‚_congr fun s _ => measurableSet_preimage_iff_preimage_val hf (s := g â»Â¹' s)\n\n"}
{"name":"Measurable.measurable_comp_iff_of_surjective","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\nÎ² : Type u_6\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : StandardBorelSpace X\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : MeasurableSpace Z\ninstâœ : MeasurableSpace.CountablySeparated Z\nf : X â†’ Z\nhf : Measurable f\nhsurj : Function.Surjective f\ng : Z â†’ Î²\nâŠ¢ Iff (Measurable (Function.comp g f)) (Measurable g)","decl":"/-- If `f : X â†’ Z` is a surjective Borel measurable map from a standard Borel space\nto a countably separated measurable space,\nthen for any measurable space `Î±` and `g : Z â†’ Î±`, the composition\n`g âˆ˜ f` is measurable if and only if `g` is measurable. -/\ntheorem measurable_comp_iff_of_surjective [CountablySeparated Z]\n    {f : X â†’ Z} (hf : Measurable f) (hsurj : Surjective f)\n    {g : Z â†’ Î²} : Measurable (g âˆ˜ f) â†” Measurable g :=\n  forallâ‚‚_congr fun s _ => measurableSet_preimage_iff_of_surjective hf hsurj (s := g â»Â¹' s)\n\n"}
{"name":"Continuous.map_eq_borel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : PolishSpace X\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : BorelSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : T0Space Y\ninstâœ : SecondCountableTopology Y\nf : X â†’ Y\nhf : Continuous f\nhsurj : Function.Surjective f\nâŠ¢ Eq (MeasurableSpace.map f instâœâ´) (borel Y)","decl":"theorem Continuous.map_eq_borel {X Y : Type*} [TopologicalSpace X] [PolishSpace X]\n    [MeasurableSpace X] [BorelSpace X] [TopologicalSpace Y] [T0Space Y] [SecondCountableTopology Y]\n    {f : X â†’ Y} (hf : Continuous f) (hsurj : Surjective f) :\n    MeasurableSpace.map f â€¹MeasurableSpace Xâ€º = borel Y := by\n  borelize Y\n  exact hf.measurable.map_measurableSpace_eq hsurj\n\n"}
{"name":"Continuous.map_borel_eq","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : PolishSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : T0Space Y\ninstâœ : SecondCountableTopology Y\nf : X â†’ Y\nhf : Continuous f\nhsurj : Function.Surjective f\nâŠ¢ Eq (MeasurableSpace.map f (borel X)) (borel Y)","decl":"theorem Continuous.map_borel_eq {X Y : Type*} [TopologicalSpace X] [PolishSpace X]\n    [TopologicalSpace Y] [T0Space Y] [SecondCountableTopology Y] {f : X â†’ Y} (hf : Continuous f)\n    (hsurj : Surjective f) : MeasurableSpace.map f (borel X) = borel Y := by\n  borelize X\n  exact hf.map_eq_borel hsurj\n\n"}
{"name":"Quotient.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : PolishSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ns : Setoid X\ninstâœÂ¹ : T0Space (Quotient s)\ninstâœ : SecondCountableTopology (Quotient s)\nâŠ¢ BorelSpace (Quotient s)","decl":"instance Quotient.borelSpace {X : Type*} [TopologicalSpace X] [PolishSpace X] [MeasurableSpace X]\n    [BorelSpace X] {s : Setoid X} [T0Space (Quotient s)] [SecondCountableTopology (Quotient s)] :\n    BorelSpace (Quotient s) :=\n  âŸ¨continuous_quotient_mk'.map_eq_borel Quotient.mk'_surjectiveâŸ©\n\n"}
{"name":"AddCosetSpace.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"G : Type u_3\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : PolishSpace G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : BorelSpace G\nN : AddSubgroup G\ninstâœÂ¹ : T2Space (HasQuotient.Quotient G N)\ninstâœ : SecondCountableTopology (HasQuotient.Quotient G N)\nâŠ¢ BorelSpace (HasQuotient.Quotient G N)","decl":"/-- When the subgroup `N < G` is not necessarily `Normal`, we have a `CosetSpace` as opposed\nto `QuotientGroup` (the next `instance`).\nTODO: typeclass inference should normally find this, but currently doesn't.\nE.g., `MeasurableSMul G (G â§¸ Î“)` fails to synthesize, even though `G â§¸ Î“` is the quotient\nof `G` by the action of `Î“`; it seems unable to pick up the `BorelSpace` instance. -/\n@[to_additive AddCosetSpace.borelSpace]\ninstance CosetSpace.borelSpace {G : Type*} [TopologicalSpace G] [PolishSpace G] [Group G]\n    [MeasurableSpace G] [BorelSpace G] {N : Subgroup G} [T2Space (G â§¸ N)]\n    [SecondCountableTopology (G â§¸ N)] : BorelSpace (G â§¸ N) := Quotient.borelSpace\n\n"}
{"name":"CosetSpace.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"G : Type u_3\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : PolishSpace G\ninstâœâ´ : Group G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : BorelSpace G\nN : Subgroup G\ninstâœÂ¹ : T2Space (HasQuotient.Quotient G N)\ninstâœ : SecondCountableTopology (HasQuotient.Quotient G N)\nâŠ¢ BorelSpace (HasQuotient.Quotient G N)","decl":"/-- When the subgroup `N < G` is not necessarily `Normal`, we have a `CosetSpace` as opposed\nto `QuotientGroup` (the next `instance`).\nTODO: typeclass inference should normally find this, but currently doesn't.\nE.g., `MeasurableSMul G (G â§¸ Î“)` fails to synthesize, even though `G â§¸ Î“` is the quotient\nof `G` by the action of `Î“`; it seems unable to pick up the `BorelSpace` instance. -/\n@[to_additive AddCosetSpace.borelSpace]\ninstance CosetSpace.borelSpace {G : Type*} [TopologicalSpace G] [PolishSpace G] [Group G]\n    [MeasurableSpace G] [BorelSpace G] {N : Subgroup G} [T2Space (G â§¸ N)]\n    [SecondCountableTopology (G â§¸ N)] : BorelSpace (G â§¸ N) := Quotient.borelSpace\n\n"}
{"name":"QuotientAddGroup.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"G : Type u_3\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : PolishSpace G\ninstâœâµ : AddGroup G\ninstâœâ´ : TopologicalAddGroup G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : BorelSpace G\nN : AddSubgroup G\ninstâœÂ¹ : N.Normal\ninstâœ : IsClosed â†‘N\nâŠ¢ BorelSpace (HasQuotient.Quotient G N)","decl":"@[to_additive]\ninstance QuotientGroup.borelSpace {G : Type*} [TopologicalSpace G] [PolishSpace G] [Group G]\n    [TopologicalGroup G] [MeasurableSpace G] [BorelSpace G] {N : Subgroup G} [N.Normal]\n    [IsClosed (N : Set G)] : BorelSpace (G â§¸ N) :=\n  âŸ¨continuous_mk.map_eq_borel mk_surjectiveâŸ©\n\n"}
{"name":"QuotientGroup.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"G : Type u_3\ninstâœâ· : TopologicalSpace G\ninstâœâ¶ : PolishSpace G\ninstâœâµ : Group G\ninstâœâ´ : TopologicalGroup G\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : BorelSpace G\nN : Subgroup G\ninstâœÂ¹ : N.Normal\ninstâœ : IsClosed â†‘N\nâŠ¢ BorelSpace (HasQuotient.Quotient G N)","decl":"@[to_additive]\ninstance QuotientGroup.borelSpace {G : Type*} [TopologicalSpace G] [PolishSpace G] [Group G]\n    [TopologicalGroup G] [MeasurableSpace G] [BorelSpace G] {N : Subgroup G} [N.Normal]\n    [IsClosed (N : Set G)] : BorelSpace (G â§¸ N) :=\n  âŸ¨continuous_mk.map_eq_borel mk_surjectiveâŸ©\n\n"}
{"name":"MeasureTheory.measurableSet_range_of_continuous_injective","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î³ : Type u_3\nÎ² : Type u_4\ninstâœâµ : TopologicalSpace Î³\ninstâœâ´ : PolishSpace Î³\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : T2Space Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : OpensMeasurableSpace Î²\nf : Î³ â†’ Î²\nf_cont : Continuous f\nf_inj : Function.Injective f\nâŠ¢ MeasurableSet (Set.range f)","decl":"/-- The **Lusin-Souslin theorem**: the range of a continuous injective function defined on a Polish\nspace is Borel-measurable. -/\ntheorem measurableSet_range_of_continuous_injective {Î² : Type*} [TopologicalSpace Î³]\n    [PolishSpace Î³] [TopologicalSpace Î²] [T2Space Î²] [MeasurableSpace Î²] [OpensMeasurableSpace Î²]\n    {f : Î³ â†’ Î²} (f_cont : Continuous f) (f_inj : Injective f) :\n    MeasurableSet (range f) := by\n  /- We follow [Fremlin, *Measure Theory* (volume 4, 423I)][fremlin_vol4].\n    Let `b = {s i}` be a countable basis for `Î±`. When `s i` and `s j` are disjoint, their images\n    are disjoint analytic sets, hence by the separation theorem one can find a Borel-measurable set\n    `q i j` separating them.\n    Let `E i = closure (f '' s i) âˆ© â‹‚ j, q i j \\ q j i`. It contains `f '' (s i)` and it is\n    measurable. Let `F n = â‹ƒ E i`, where the union is taken over those `i` for which `diam (s i)`\n    is bounded by some number `u n` tending to `0` with `n`.\n    We claim that `range f = â‹‚ F n`, from which the measurability is obvious. The inclusion `âŠ†` is\n    straightforward. To show `âŠ‡`, consider a point `x` in the intersection. For each `n`, it belongs\n    to some `E i` with `diam (s i) â‰¤ u n`. Pick a point `y i âˆˆ s i`. We claim that for such `i`\n    and `j`, the intersection `s i âˆ© s j` is nonempty: if it were empty, then thanks to the\n    separating set `q i j` in the definition of `E i` one could not have `x âˆˆ E i âˆ© E j`.\n    Since these two sets have small diameter, it follows that `y i` and `y j` are close.\n    Thus, `y` is a Cauchy sequence, converging to a limit `z`. We claim that `f z = x`, completing\n    the proof.\n    Otherwise, one could find open sets `v` and `w` separating `f z` from `x`. Then, for large `n`,\n    the image `f '' (s i)` would be included in `v` by continuity of `f`, so its closure would be\n    contained in the closure of `v`, and therefore it would be disjoint from `w`. This is a\n    contradiction since `x` belongs both to this closure and to `w`. -/\n  letI := upgradePolishSpace Î³\n  obtain âŸ¨b, b_count, b_nonempty, hbâŸ© :\n    âˆƒ b : Set (Set Î³), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b := exists_countable_basis Î³\n  haveI : Encodable b := b_count.toEncodable\n  let A := { p : b Ã— b // Disjoint (p.1 : Set Î³) p.2 }\n  -- for each pair of disjoint sets in the topological basis `b`, consider Borel sets separating\n  -- their images, by injectivity of `f` and the Lusin separation theorem.\n  have : âˆ€ p : A, âˆƒ q : Set Î²,\n      f '' (p.1.1 : Set Î³) âŠ† q âˆ§ Disjoint (f '' (p.1.2 : Set Î³)) q âˆ§ MeasurableSet q := by\n    intro p\n    apply\n      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)\n        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)\n    exact Disjoint.image p.2 f_inj.injOn (subset_univ _) (subset_univ _)\n  choose q hq1 hq2 q_meas using this\n  -- define sets `E i` and `F n` as in the proof sketch above\n  let E : b â†’ Set Î² := fun s =>\n    closure (f '' s) âˆ© â‹‚ (t : b) (ht : Disjoint s.1 t.1), q âŸ¨(s, t), htâŸ© \\ q âŸ¨(t, s), ht.symmâŸ©\n  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :\n      âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=\n    exists_seq_strictAnti_tendsto (0 : â„)\n  let F : â„• â†’ Set Î² := fun n => â‹ƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), E s\n  -- it is enough to show that `range f = â‹‚ F n`, as the latter set is obviously measurable.\n  suffices range f = â‹‚ n, F n by\n    have E_meas : âˆ€ s : b, MeasurableSet (E s) := by\n      intro b\n      refine isClosed_closure.measurableSet.inter ?_\n      refine MeasurableSet.iInter fun s => ?_\n      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)\n    have F_meas : âˆ€ n, MeasurableSet (F n) := by\n      intro n\n      refine MeasurableSet.iUnion fun s => ?_\n      exact MeasurableSet.iUnion fun _ => E_meas _\n    rw [this]\n    exact MeasurableSet.iInter fun n => F_meas n\n  -- we check both inclusions.\n  apply Subset.antisymm\n  -- we start with the easy inclusion `range f âŠ† â‹‚ F n`. One just needs to unfold the definitions.\n  Â· rintro x âŸ¨y, rflâŸ©\n    refine mem_iInter.2 fun n => ?_\n    obtain âŸ¨s, sb, ys, hsâŸ© : âˆƒ (s : Set Î³), s âˆˆ b âˆ§ y âˆˆ s âˆ§ s âŠ† ball y (u n / 2) := by\n      apply hb.mem_nhds_iff.1\n      exact ball_mem_nhds _ (half_pos (u_pos n))\n    have diam_s : diam s â‰¤ u n := by\n      apply (diam_mono hs isBounded_ball).trans\n      convert diam_ball (x := y) (half_pos (u_pos n)).le\n      ring\n    refine mem_iUnion.2 âŸ¨âŸ¨s, sbâŸ©, ?_âŸ©\n    refine mem_iUnion.2 âŸ¨âŸ¨isBounded_ball.subset hs, diam_sâŸ©, ?_âŸ©\n    apply mem_inter (subset_closure (mem_image_of_mem _ ys))\n    refine mem_iInter.2 fun t => mem_iInter.2 fun ht => âŸ¨?_, ?_âŸ©\n    Â· apply hq1\n      exact mem_image_of_mem _ ys\n    Â· apply disjoint_left.1 (hq2 âŸ¨(t, âŸ¨s, sbâŸ©), ht.symmâŸ©)\n      exact mem_image_of_mem _ ys\n  -- Now, let us prove the harder inclusion `â‹‚ F n âŠ† range f`.\n  Â· intro x hx\n    -- pick for each `n` a good set `s n` of small diameter for which `x âˆˆ E (s n)`.\n    have C1 : âˆ€ n, âˆƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), x âˆˆ E s := fun n => by\n      simpa only [F, mem_iUnion] using mem_iInter.1 hx n\n    choose s hs hxs using C1\n    have C2 : âˆ€ n, (s n).1.Nonempty := by\n      intro n\n      rw [nonempty_iff_ne_empty]\n      intro hn\n      have := (s n).2\n      rw [hn] at this\n      exact b_nonempty this\n    -- choose a point `y n âˆˆ s n`.\n    choose y hy using C2\n    have I : âˆ€ m n, ((s m).1 âˆ© (s n).1).Nonempty := by\n      intro m n\n      rw [â† not_disjoint_iff_nonempty_inter]\n      by_contra! h\n      have A : x âˆˆ q âŸ¨(s m, s n), hâŸ© \\ q âŸ¨(s n, s m), h.symmâŸ© :=\n        haveI := mem_iInter.1 (hxs m).2 (s n)\n        (mem_iInter.1 this h :)\n      have B : x âˆˆ q âŸ¨(s n, s m), h.symmâŸ© \\ q âŸ¨(s m, s n), hâŸ© :=\n        haveI := mem_iInter.1 (hxs n).2 (s m)\n        (mem_iInter.1 this h.symm :)\n      exact A.2 B.1\n    -- the points `y n` are nearby, and therefore they form a Cauchy sequence.\n    have cauchy_y : CauchySeq y := by\n      have : Tendsto (fun n => 2 * u n) atTop (ğ“ 0) := by\n        simpa only [mul_zero] using u_lim.const_mul 2\n      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this\n      rcases I m n with âŸ¨z, zsm, zsnâŸ©\n      calc\n        dist (y m) (y n) â‰¤ dist (y m) z + dist z (y n) := dist_triangle _ _ _\n        _ â‰¤ u m + u n :=\n          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)\n            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))\n        _ â‰¤ 2 * u m := by linarith [u_anti.antitone hmn]\n    haveI : Nonempty Î³ := âŸ¨y 0âŸ©\n    -- let `z` be its limit.\n    let z := limUnder atTop y\n    have y_lim : Tendsto y atTop (ğ“ z) := cauchy_y.tendsto_limUnder\n    suffices f z = x by\n      rw [â† this]\n      exact mem_range_self _\n    -- assume for a contradiction that `f z â‰  x`.\n    by_contra! hne\n    -- introduce disjoint open sets `v` and `w` separating `f z` from `x`.\n    obtain âŸ¨v, w, v_open, w_open, fzv, xw, hvwâŸ© := t2_separation hne\n    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ > (0 : â„), ball z Î´ âŠ† f â»Â¹' v := by\n      apply Metric.mem_nhds_iff.1\n      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)\n    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n + dist (y n) z < Î´ :=\n      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (ğ“ 0) := by\n        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)\n      ((tendsto_order.1 this).2 _ Î´pos).exists\n    -- for large enough `n`, the image of `s n` is contained in `v`, by continuity of `f`.\n    have fsnv : f '' s n âŠ† v := by\n      rw [image_subset_iff]\n      apply Subset.trans _ hÎ´\n      intro a ha\n      calc\n        dist a z â‰¤ dist a (y n) + dist (y n) z := dist_triangle _ _ _\n        _ â‰¤ u n + dist (y n) z :=\n          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)\n        _ < Î´ := hn\n    -- as `x` belongs to the closure of `f '' (s n)`, it belongs to the closure of `v`.\n    have : x âˆˆ closure v := closure_mono fsnv (hxs n).1\n    -- this is a contradiction, as `x` is supposed to belong to `w`, which is disjoint from\n    -- the closure of `v`.\n    exact disjoint_left.1 (hvw.closure_left w_open) this xw\n\n"}
{"name":"IsClosed.measurableSet_image_of_continuousOn_injOn","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î³ : Type u_3\ninstâœâµ : TopologicalSpace Î³\ninstâœâ´ : PolishSpace Î³\nÎ² : Type u_4\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : T2Space Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : OpensMeasurableSpace Î²\ns : Set Î³\nhs : IsClosed s\nf : Î³ â†’ Î²\nf_cont : ContinuousOn f s\nf_inj : Set.InjOn f s\nâŠ¢ MeasurableSet (Set.image f s)","decl":"theorem _root_.IsClosed.measurableSet_image_of_continuousOn_injOn\n    [TopologicalSpace Î³] [PolishSpace Î³] {Î² : Type*} [TopologicalSpace Î²] [T2Space Î²]\n    [MeasurableSpace Î²] [OpensMeasurableSpace Î²] {s : Set Î³} (hs : IsClosed s) {f : Î³ â†’ Î²}\n    (f_cont : ContinuousOn f s) (f_inj : InjOn f s) : MeasurableSet (f '' s) := by\n  rw [image_eq_range]\n  haveI : PolishSpace s := IsClosed.polishSpace hs\n  apply measurableSet_range_of_continuous_injective\n  Â· rwa [continuousOn_iff_continuous_restrict] at f_cont\n  Â· rwa [injOn_iff_injective] at f_inj\n\n"}
{"name":"MeasurableSet.image_of_continuousOn_injOn","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î³ : Type u_3\nÎ² : Type u_5\ninstâœâµ : MeasurableSpace Î²\ntÎ² : TopologicalSpace Î²\ninstâœâ´ : T2Space Î²\ns : Set Î³\nf : Î³ â†’ Î²\ninstâœÂ³ : OpensMeasurableSpace Î²\ntÎ³ : TopologicalSpace Î³\ninstâœÂ² : PolishSpace Î³\ninstâœÂ¹ : MeasurableSpace Î³\ninstâœ : BorelSpace Î³\nhs : MeasurableSet s\nf_cont : ContinuousOn f s\nf_inj : Set.InjOn f s\nâŠ¢ MeasurableSet (Set.image f s)","decl":"/-- The Lusin-Souslin theorem: if `s` is Borel-measurable in a Polish space, then its image under\na continuous injective map is also Borel-measurable. -/\ntheorem _root_.MeasurableSet.image_of_continuousOn_injOn [OpensMeasurableSpace Î²]\n    [tÎ³ : TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³]\n    (hs : MeasurableSet s)\n    (f_cont : ContinuousOn f s) (f_inj : InjOn f s) : MeasurableSet (f '' s) := by\n  obtain âŸ¨t', t't, t'_polish, s_closed, _âŸ© :\n      âˆƒ t' : TopologicalSpace Î³, t' â‰¤ tÎ³ âˆ§ @PolishSpace Î³ t' âˆ§ IsClosed[t'] s âˆ§ IsOpen[t'] s :=\n    hs.isClopenable\n  exact\n    @IsClosed.measurableSet_image_of_continuousOn_injOn Î³ t' t'_polish Î² _ _ _ _ s s_closed f\n      (f_cont.mono_dom t't) f_inj\n\n"}
{"name":"MeasurableSet.image_of_measurable_injOn","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î³ : Type u_3\nÎ± : Type u_4\ninstâœÂ³ : MeasurableSpace Î±\ns : Set Î³\nf : Î³ â†’ Î±\ninstâœÂ² : MeasurableSpace.CountablySeparated Î±\ninstâœÂ¹ : MeasurableSpace Î³\ninstâœ : StandardBorelSpace Î³\nhs : MeasurableSet s\nf_meas : Measurable f\nf_inj : Set.InjOn f s\nâŠ¢ MeasurableSet (Set.image f s)","decl":"/-- The Lusin-Souslin theorem: if `s` is Borel-measurable in a standard Borel space,\nthen its image under a measurable injective map taking values in a\ncountably separate measurable space is also Borel-measurable. -/\ntheorem _root_.MeasurableSet.image_of_measurable_injOn {f : Î³ â†’ Î±}\n    [MeasurableSpace.CountablySeparated Î±]\n    [MeasurableSpace Î³] [StandardBorelSpace Î³]\n    (hs : MeasurableSet s) (f_meas : Measurable f) (f_inj : InjOn f s) :\n    MeasurableSet (f '' s) := by\n  letI := upgradeStandardBorel Î³\n  let tÎ³ : TopologicalSpace Î³ := inferInstance\n  rcases exists_opensMeasurableSpace_of_countablySeparated Î± with âŸ¨Ï„, _, _, _âŸ©\n  -- for a finer Polish topology, `f` is continuous. Therefore, one may apply the corresponding\n  -- result for continuous maps.\n  obtain âŸ¨t', t't, f_cont, t'_polishâŸ© :\n      âˆƒ t' : TopologicalSpace Î³, t' â‰¤ tÎ³ âˆ§ @Continuous Î³ _ t' _ f âˆ§ @PolishSpace Î³ t' :=\n    f_meas.exists_continuous\n  have M : MeasurableSet[@borel Î³ t'] s :=\n    @Continuous.measurable Î³ Î³ t' (@borel Î³ t')\n      (@BorelSpace.opensMeasurable Î³ t' (@borel Î³ t') (@BorelSpace.mk _ _ (borel Î³) rfl))\n      tÎ³ _ _ _ (continuous_id_of_le t't) s hs\n  exact\n    @MeasurableSet.image_of_continuousOn_injOn Î³\n      _ _ _ _  s f _ t' t'_polish (@borel Î³ t') (@BorelSpace.mk _ _ (borel Î³) rfl)\n      M (@Continuous.continuousOn Î³ _ t' _ f s f_cont) f_inj\n\n"}
{"name":"Continuous.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î³ : Type u_3\nÎ² : Type u_5\ninstâœâ¶ : MeasurableSpace Î²\ntÎ² : TopologicalSpace Î²\ninstâœâµ : T2Space Î²\nf : Î³ â†’ Î²\ninstâœâ´ : BorelSpace Î²\ninstâœÂ³ : TopologicalSpace Î³\ninstâœÂ² : PolishSpace Î³\ninstâœÂ¹ : MeasurableSpace Î³\ninstâœ : BorelSpace Î³\nf_cont : Continuous f\nf_inj : Function.Injective f\nâŠ¢ MeasurableEmbedding f","decl":"/-- An injective continuous function on a Polish space is a measurable embedding. -/\ntheorem _root_.Continuous.measurableEmbedding [BorelSpace Î²]\n    [TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³]\n    (f_cont : Continuous f) (f_inj : Injective f) :\n    MeasurableEmbedding f :=\n  { injective := f_inj\n    measurable := f_cont.measurable\n    measurableSet_image' := fun _u hu =>\n      hu.image_of_continuousOn_injOn f_cont.continuousOn f_inj.injOn }\n\n"}
{"name":"ContinuousOn.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î³ : Type u_3\nÎ² : Type u_5\ninstâœâ¶ : MeasurableSpace Î²\ntÎ² : TopologicalSpace Î²\ninstâœâµ : T2Space Î²\ns : Set Î³\nf : Î³ â†’ Î²\ninstâœâ´ : BorelSpace Î²\ninstâœÂ³ : TopologicalSpace Î³\ninstâœÂ² : PolishSpace Î³\ninstâœÂ¹ : MeasurableSpace Î³\ninstâœ : BorelSpace Î³\nhs : MeasurableSet s\nf_cont : ContinuousOn f s\nf_inj : Set.InjOn f s\nâŠ¢ MeasurableEmbedding (s.restrict f)","decl":"/-- If `s` is Borel-measurable in a Polish space and `f` is continuous injective on `s`, then\nthe restriction of `f` to `s` is a measurable embedding. -/\ntheorem _root_.ContinuousOn.measurableEmbedding [BorelSpace Î²]\n    [TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³]\n    (hs : MeasurableSet s) (f_cont : ContinuousOn f s)\n    (f_inj : InjOn f s) : MeasurableEmbedding (s.restrict f) :=\n  { injective := injOn_iff_injective.1 f_inj\n    measurable := (continuousOn_iff_continuous_restrict.1 f_cont).measurable\n    measurableSet_image' := by\n      intro u hu\n      have A : MeasurableSet (((â†‘) : s â†’ Î³) '' u) :=\n        (MeasurableEmbedding.subtype_coe hs).measurableSet_image.2 hu\n      have B : MeasurableSet (f '' (((â†‘) : s â†’ Î³) '' u)) :=\n        A.image_of_continuousOn_injOn (f_cont.mono (Subtype.coe_image_subset s u))\n          (f_inj.mono (Subtype.coe_image_subset s u))\n      rwa [â† image_comp] at B }\n\n"}
{"name":"Measurable.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î³ : Type u_3\nÎ± : Type u_4\ninstâœÂ³ : MeasurableSpace Î±\nf : Î³ â†’ Î±\ninstâœÂ² : MeasurableSpace.CountablySeparated Î±\ninstâœÂ¹ : MeasurableSpace Î³\ninstâœ : StandardBorelSpace Î³\nf_meas : Measurable f\nf_inj : Function.Injective f\nâŠ¢ MeasurableEmbedding f","decl":"/-- An injective measurable function from a standard Borel space to a\ncountably separated measurable space is a measurable embedding. -/\ntheorem _root_.Measurable.measurableEmbedding {f : Î³ â†’ Î±}\n    [MeasurableSpace.CountablySeparated Î±]\n    [MeasurableSpace Î³] [StandardBorelSpace Î³]\n    (f_meas : Measurable f) (f_inj : Injective f) : MeasurableEmbedding f :=\n  { injective := f_inj\n    measurable := f_meas\n    measurableSet_image' := fun _u hu => hu.image_of_measurable_injOn f_meas f_inj.injOn }\n\n"}
{"name":"MeasureTheory.borel_eq_borel_of_le","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î³ : Type u_3\nt t' : TopologicalSpace Î³\nht : PolishSpace Î³\nht' : PolishSpace Î³\nhle : LE.le t t'\nâŠ¢ Eq (borel Î³) (borel Î³)","decl":"/-- If one Polish topology on a type refines another, they have the same Borel sets. -/\ntheorem borel_eq_borel_of_le {t t' : TopologicalSpace Î³}\n    (ht : PolishSpace (h := t)) (ht' : PolishSpace (h := t')) (hle : t â‰¤ t') :\n    @borel _ t = @borel _ t' := by\n  refine le_antisymm ?_ (borel_anti hle)\n  intro s hs\n  have e := @Continuous.measurableEmbedding\n    _ _ (@borel _ t') t' _ _ (@BorelSpace.mk _ _ (borel Î³) rfl)\n    t _ (@borel _ t) (@BorelSpace.mk _ t (@borel _ t) rfl) (continuous_id_of_le hle) injective_id\n  convert e.measurableSet_image.2 hs\n  simp only [id_eq, image_id']\n\n"}
{"name":"MeasureTheory.isClopenable_iff_measurableSet","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î³ : Type u_3\ns : Set Î³\ntÎ³ : TopologicalSpace Î³\ninstâœÂ² : PolishSpace Î³\ninstâœÂ¹ : MeasurableSpace Î³\ninstâœ : BorelSpace Î³\nâŠ¢ Iff (PolishSpace.IsClopenable s) (MeasurableSet s)","decl":"/-- In a Polish space, a set is clopenable if and only if it is Borel-measurable. -/\ntheorem isClopenable_iff_measurableSet\n    [tÎ³ : TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³] [BorelSpace Î³] :\n    IsClopenable s â†” MeasurableSet s := by\n  -- we already know that a measurable set is clopenable. Conversely, assume that `s` is clopenable.\n  refine âŸ¨fun hs => ?_, fun hs => hs.isClopenableâŸ©\n  borelize Î³\n  -- consider a finer topology `t'` in which `s` is open and closed.\n  obtain âŸ¨t', t't, t'_polish, _, s_openâŸ© :\n    âˆƒ t' : TopologicalSpace Î³, t' â‰¤ tÎ³ âˆ§ @PolishSpace Î³ t' âˆ§ IsClosed[t'] s âˆ§ IsOpen[t'] s := hs\n  rw [â† borel_eq_borel_of_le t'_polish _ t't]\n  Â· exact MeasurableSpace.measurableSet_generateFrom s_open\n  infer_instance\n\n"}
{"name":"MeasureTheory.measurableSet_tendsto_fun","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î¹ : Type u_2\nÎ³ : Type u_3\nÎ² : Type u_5\ninstâœâ· : MeasurableSpace Î²\ninstâœâ¶ : MeasurableSpace Î³\ninstâœâµ : Countable Î¹\nl : Filter Î¹\ninstâœâ´ : l.IsCountablyGenerated\ninstâœÂ³ : TopologicalSpace Î³\ninstâœÂ² : SecondCountableTopology Î³\ninstâœÂ¹ : TopologicalSpace.PseudoMetrizableSpace Î³\ninstâœ : OpensMeasurableSpace Î³\nf : Î¹ â†’ Î² â†’ Î³\nhf : âˆ€ (i : Î¹), Measurable (f i)\ng : Î² â†’ Î³\nhg : Measurable g\nâŠ¢ MeasurableSet (setOf fun x => Filter.Tendsto (fun n => f n x) l (nhds (g x)))","decl":"/-- The set of points for which a sequence of measurable functions converges to a given function\nis measurable. -/\n@[measurability]\nlemma measurableSet_tendsto_fun [MeasurableSpace Î³] [Countable Î¹]\n    {l : Filter Î¹} [l.IsCountablyGenerated]\n    [TopologicalSpace Î³] [SecondCountableTopology Î³] [PseudoMetrizableSpace Î³]\n    [OpensMeasurableSpace Î³]\n    {f : Î¹ â†’ Î² â†’ Î³} (hf : âˆ€ i, Measurable (f i)) {g : Î² â†’ Î³} (hg : Measurable g) :\n    MeasurableSet { x | Tendsto (fun n â†¦ f n x) l (ğ“ (g x)) } := by\n  letI := TopologicalSpace.pseudoMetrizableSpacePseudoMetric Î³\n  simp_rw [tendsto_iff_dist_tendsto_zero (f := fun n â†¦ f n _)]\n  exact measurableSet_tendsto (ğ“ 0) (fun n â†¦ (hf n).dist hg)\n\n"}
{"name":"MeasureTheory.measurableSet_exists_tendsto","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î¹ : Type u_2\nÎ³ : Type u_3\nÎ² : Type u_5\ninstâœâµ : MeasurableSpace Î²\ninstâœâ´ : TopologicalSpace Î³\ninstâœÂ³ : PolishSpace Î³\ninstâœÂ² : MeasurableSpace Î³\nhÎ³ : OpensMeasurableSpace Î³\ninstâœÂ¹ : Countable Î¹\nl : Filter Î¹\ninstâœ : l.IsCountablyGenerated\nf : Î¹ â†’ Î² â†’ Î³\nhf : âˆ€ (i : Î¹), Measurable (f i)\nâŠ¢ MeasurableSet (setOf fun x => Exists fun c => Filter.Tendsto (fun n => f n x) l (nhds c))","decl":"/-- The set of points for which a measurable sequence of functions converges is measurable. -/\n@[measurability]\ntheorem measurableSet_exists_tendsto [TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³]\n    [hÎ³ : OpensMeasurableSpace Î³] [Countable Î¹] {l : Filter Î¹}\n    [l.IsCountablyGenerated] {f : Î¹ â†’ Î² â†’ Î³} (hf : âˆ€ i, Measurable (f i)) :\n    MeasurableSet { x | âˆƒ c, Tendsto (fun n => f n x) l (ğ“ c) } := by\n  rcases l.eq_or_neBot with rfl | hl\n  Â· simp\n  letI := upgradePolishSpace Î³\n  rcases l.exists_antitone_basis with âŸ¨u, huâŸ©\n  simp_rw [â† cauchy_map_iff_exists_tendsto]\n  change MeasurableSet { x | _ âˆ§ _ }\n  have : âˆ€ x, (map (f Â· x) l Ã—Ë¢ map (f Â· x) l).HasAntitoneBasis fun n =>\n      ((f Â· x) '' u n) Ã—Ë¢ ((f Â· x) '' u n) := fun x => (hu.map _).prod (hu.map _)\n  simp_rw [and_iff_right (hl.map _),\n    Filter.HasBasis.le_basis_iff (this _).toHasBasis Metric.uniformity_basis_dist_inv_nat_succ,\n    Set.setOf_forall]\n  refine MeasurableSet.biInter Set.countable_univ fun K _ => ?_\n  simp_rw [Set.setOf_exists, true_and]\n  refine MeasurableSet.iUnion fun N => ?_\n  simp_rw [prod_image_image_eq, image_subset_iff, prod_subset_iff, Set.setOf_forall]\n  exact\n    MeasurableSet.biInter (to_countable (u N)) fun i _ =>\n      MeasurableSet.biInter (to_countable (u N)) fun j _ =>\n        measurableSet_lt (Measurable.dist (hf i) (hf j)) measurable_const\n\n"}
{"name":"MeasurableSet.isClopenable'","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : StandardBorelSpace Î±\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Exists fun x => And (BorelSpace Î±) (And (PolishSpace Î±) (And (IsClosed s) (IsOpen s)))","decl":"/-- If `s` is a measurable set in a standard Borel space, there is a compatible Polish topology\nmaking `s` clopen. -/\ntheorem _root_.MeasurableSet.isClopenable' {s : Set Î±} (hs : MeasurableSet s) :\n    âˆƒ _ : TopologicalSpace Î±, BorelSpace Î± âˆ§ PolishSpace Î± âˆ§ IsClosed s âˆ§ IsOpen s := by\n  letI := upgradeStandardBorel Î±\n  obtain âŸ¨t, hle, ht, s_clopenâŸ© := hs.isClopenable\n  refine âŸ¨t, ?_, ht, s_clopenâŸ©\n  constructor\n  rw [eq_borel_upgradeStandardBorel Î±, borel_eq_borel_of_le ht _ hle]\n  infer_instance\n\n"}
{"name":"MeasurableSet.standardBorel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : StandardBorelSpace Î±\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ StandardBorelSpace â†‘s","decl":"/-- A measurable subspace of a standard Borel space is standard Borel. -/\ntheorem _root_.MeasurableSet.standardBorel {s : Set Î±} (hs : MeasurableSet s) :\n    StandardBorelSpace s := by\n  obtain âŸ¨_, _, _, s_closed, _âŸ© := hs.isClopenable'\n  haveI := s_closed.polishSpace\n  infer_instance\n\n"}
