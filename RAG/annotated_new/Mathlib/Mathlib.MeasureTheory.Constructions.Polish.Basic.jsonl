{"name":"StandardBorelSpace.polish","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nself : StandardBorelSpace α\n⊢ Exists fun x => And (BorelSpace α) (PolishSpace α)","decl":"/-- A standard Borel space is a measurable space arising as the Borel sets of some Polish topology.\nThis is useful in situations where a space has no natural topology or\nthe natural topology in a space is non-Polish.\n\nTo endow a standard Borel space `α` with a compatible Polish topology, use\n`letI := upgradeStandardBorel α`. One can then use `eq_borel_upgradeStandardBorel α` to\nrewrite the `MeasurableSpace α` instance to `borel α t`, where `t` is the new topology. -/\nclass StandardBorelSpace [MeasurableSpace α] : Prop where\n  /-- There exists a compatible Polish topology. -/\n  polish : ∃ _ : TopologicalSpace α, BorelSpace α ∧ PolishSpace α\n\n"}
{"name":"UpgradedStandardBorel.toPolishSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\nself : UpgradedStandardBorel α\n⊢ PolishSpace α","decl":"/-- A convenience class similar to `UpgradedPolishSpace`. No instance should be registered.\nInstead one should use `letI := upgradeStandardBorel α`. -/\nclass UpgradedStandardBorel extends MeasurableSpace α, TopologicalSpace α,\n  BorelSpace α, PolishSpace α\n\n"}
{"name":"UpgradedStandardBorel.toBorelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\nself : UpgradedStandardBorel α\n⊢ BorelSpace α","decl":"/-- A convenience class similar to `UpgradedPolishSpace`. No instance should be registered.\nInstead one should use `letI := upgradeStandardBorel α`. -/\nclass UpgradedStandardBorel extends MeasurableSpace α, TopologicalSpace α,\n  BorelSpace α, PolishSpace α\n\n"}
{"name":"eq_borel_upgradeStandardBorel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : StandardBorelSpace α\n⊢ Eq inst✝¹ (borel α)","decl":"/-- The `MeasurableSpace α` instance on a `StandardBorelSpace` `α` is equal to\nthe borel sets of `upgradeStandardBorel α`. -/\ntheorem eq_borel_upgradeStandardBorel [MeasurableSpace α] [StandardBorelSpace α] :\n    ‹MeasurableSpace α› = @borel _ (upgradeStandardBorel α).toTopologicalSpace :=\n  @BorelSpace.measurable_eq _ (upgradeStandardBorel α).toTopologicalSpace _\n    (upgradeStandardBorel α).toBorelSpace\n\n"}
{"name":"standardBorel_of_polish","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\nτ : TopologicalSpace α\ninst✝¹ : BorelSpace α\ninst✝ : PolishSpace α\n⊢ StandardBorelSpace α","decl":"instance (priority := 100) standardBorel_of_polish [τ : TopologicalSpace α]\n    [BorelSpace α] [PolishSpace α] : StandardBorelSpace α := by exists τ\n\n-- See note [lower instance priority]\n"}
{"name":"standardBorelSpace_of_discreteMeasurableSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : DiscreteMeasurableSpace α\ninst✝ : Countable α\n⊢ StandardBorelSpace α","decl":"instance (priority := 100) standardBorelSpace_of_discreteMeasurableSpace [DiscreteMeasurableSpace α]\n    [Countable α] : StandardBorelSpace α :=\n  let _ : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  inferInstance\n\n-- See note [lower instance priority]\n"}
{"name":"countablyGenerated_of_standardBorel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : StandardBorelSpace α\n⊢ MeasurableSpace.CountablyGenerated α","decl":"instance (priority := 100) countablyGenerated_of_standardBorel [StandardBorelSpace α] :\n    MeasurableSpace.CountablyGenerated α :=\n  letI := upgradeStandardBorel α\n  inferInstance\n\n-- See note [lower instance priority]\n"}
{"name":"measurableSingleton_of_standardBorel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : StandardBorelSpace α\n⊢ MeasurableSingletonClass α","decl":"instance (priority := 100) measurableSingleton_of_standardBorel [StandardBorelSpace α] :\n    MeasurableSingletonClass α :=\n  letI := upgradeStandardBorel α\n  inferInstance\n\n"}
{"name":"StandardBorelSpace.prod","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝³ : MeasurableSpace α\nβ : Type u_2\ninst✝² : MeasurableSpace β\ninst✝¹ : StandardBorelSpace α\ninst✝ : StandardBorelSpace β\n⊢ StandardBorelSpace (Prod α β)","decl":"/-- A product of two standard Borel spaces is standard Borel. -/\ninstance prod [StandardBorelSpace α] [StandardBorelSpace β] : StandardBorelSpace (α × β) :=\n  letI := upgradeStandardBorel α\n  letI := upgradeStandardBorel β\n  inferInstance\n\n"}
{"name":"StandardBorelSpace.pi_countable","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"ι : Type u_3\ninst✝² : Countable ι\nα : ι → Type u_4\ninst✝¹ : (n : ι) → MeasurableSpace (α n)\ninst✝ : ∀ (n : ι), StandardBorelSpace (α n)\n⊢ StandardBorelSpace ((n : ι) → α n)","decl":"/-- A product of countably many standard Borel spaces is standard Borel. -/\ninstance pi_countable {ι : Type*} [Countable ι] {α : ι → Type*} [∀ n, MeasurableSpace (α n)]\n    [∀ n, StandardBorelSpace (α n)] : StandardBorelSpace (∀ n, α n) :=\n  letI := fun n => upgradeStandardBorel (α n)\n  inferInstance\n\n"}
{"name":"MeasureTheory.AnalyticSet_def","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_3\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Eq (MeasureTheory.AnalyticSet s) (Or (Eq s EmptyCollection.emptyCollection) (Exists fun f => And (Continuous f) (Eq (Set.range f) s)))","decl":"/-- An analytic set is a set which is the continuous image of some Polish space. There are several\nequivalent characterizations of this definition. For the definition, we pick one that avoids\nuniverse issues: a set is analytic if and only if it is a continuous image of `ℕ → ℕ` (or if it\nis empty). The above more usual characterization is given\nin `analyticSet_iff_exists_polishSpace_range`.\n\nWarning: these are analytic sets in the context of descriptive set theory (which is why they are\nregistered in the namespace `MeasureTheory`). They have nothing to do with analytic sets in the\ncontext of complex analysis. -/\nirreducible_def AnalyticSet (s : Set α) : Prop :=\n  s = ∅ ∨ ∃ f : (ℕ → ℕ) → α, Continuous f ∧ range f = s\n\n"}
{"name":"MeasureTheory.analyticSet_empty","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ MeasureTheory.AnalyticSet EmptyCollection.emptyCollection","decl":"theorem analyticSet_empty : AnalyticSet (∅ : Set α) := by\n  rw [AnalyticSet]\n  exact Or.inl rfl\n\n"}
{"name":"MeasureTheory.analyticSet_range_of_polishSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\ninst✝ : PolishSpace β\nf : β → α\nf_cont : Continuous f\n⊢ MeasureTheory.AnalyticSet (Set.range f)","decl":"theorem analyticSet_range_of_polishSpace {β : Type*} [TopologicalSpace β] [PolishSpace β]\n    {f : β → α} (f_cont : Continuous f) : AnalyticSet (range f) := by\n  cases isEmpty_or_nonempty β\n  · rw [range_eq_empty]\n    exact analyticSet_empty\n  · rw [AnalyticSet]\n    obtain ⟨g, g_cont, hg⟩ : ∃ g : (ℕ → ℕ) → β, Continuous g ∧ Surjective g :=\n      exists_nat_nat_continuous_surjective β\n    refine Or.inr ⟨f ∘ g, f_cont.comp g_cont, ?_⟩\n    rw [hg.range_comp]\n\n"}
{"name":"IsOpen.analyticSet_image","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\ninst✝ : PolishSpace β\ns : Set β\nhs : IsOpen s\nf : β → α\nf_cont : Continuous f\n⊢ MeasureTheory.AnalyticSet (Set.image f s)","decl":"/-- The image of an open set under a continuous map is analytic. -/\ntheorem _root_.IsOpen.analyticSet_image {β : Type*} [TopologicalSpace β] [PolishSpace β]\n    {s : Set β} (hs : IsOpen s) {f : β → α} (f_cont : Continuous f) : AnalyticSet (f '' s) := by\n  rw [image_eq_range]\n  haveI : PolishSpace s := hs.polishSpace\n  exact analyticSet_range_of_polishSpace (f_cont.comp continuous_subtype_val)\n\n"}
{"name":"MeasureTheory.analyticSet_iff_exists_polishSpace_range","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Iff (MeasureTheory.AnalyticSet s) (Exists fun β => Exists fun h => Exists fun x => Exists fun f => And (Continuous f) (Eq (Set.range f) s))","decl":"/-- A set is analytic if and only if it is the continuous image of some Polish space. -/\ntheorem analyticSet_iff_exists_polishSpace_range {s : Set α} :\n    AnalyticSet s ↔\n      ∃ (β : Type) (h : TopologicalSpace β) (_ : @PolishSpace β h) (f : β → α),\n        @Continuous _ _ h _ f ∧ range f = s := by\n  constructor\n  · intro h\n    rw [AnalyticSet] at h\n    cases' h with h h\n    · refine ⟨Empty, inferInstance, inferInstance, Empty.elim, continuous_bot, ?_⟩\n      rw [h]\n      exact range_eq_empty _\n    · exact ⟨ℕ → ℕ, inferInstance, inferInstance, h⟩\n  · rintro ⟨β, h, h', f, f_cont, f_range⟩\n    rw [← f_range]\n    exact analyticSet_range_of_polishSpace f_cont\n\n"}
{"name":"MeasureTheory.AnalyticSet.image_of_continuousOn","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\nβ : Type u_3\ninst✝ : TopologicalSpace β\ns : Set α\nhs : MeasureTheory.AnalyticSet s\nf : α → β\nhf : ContinuousOn f s\n⊢ MeasureTheory.AnalyticSet (Set.image f s)","decl":"/-- The continuous image of an analytic set is analytic -/\ntheorem AnalyticSet.image_of_continuousOn {β : Type*} [TopologicalSpace β] {s : Set α}\n    (hs : AnalyticSet s) {f : α → β} (hf : ContinuousOn f s) : AnalyticSet (f '' s) := by\n  rcases analyticSet_iff_exists_polishSpace_range.1 hs with ⟨γ, γtop, γpolish, g, g_cont, gs⟩\n  have : f '' s = range (f ∘ g) := by rw [range_comp, gs]\n  rw [this]\n  apply analyticSet_range_of_polishSpace\n  apply hf.comp_continuous g_cont fun x => _\n  rw [← gs]\n  exact mem_range_self\n\n"}
{"name":"MeasureTheory.AnalyticSet.image_of_continuous","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\nβ : Type u_3\ninst✝ : TopologicalSpace β\ns : Set α\nhs : MeasureTheory.AnalyticSet s\nf : α → β\nhf : Continuous f\n⊢ MeasureTheory.AnalyticSet (Set.image f s)","decl":"theorem AnalyticSet.image_of_continuous {β : Type*} [TopologicalSpace β] {s : Set α}\n    (hs : AnalyticSet s) {f : α → β} (hf : Continuous f) : AnalyticSet (f '' s) :=\n  hs.image_of_continuousOn hf.continuousOn\n\n"}
{"name":"MeasureTheory.AnalyticSet.iInter","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : TopologicalSpace α\nhι : Nonempty ι\ninst✝¹ : Countable ι\ninst✝ : T2Space α\ns : ι → Set α\nhs : ∀ (n : ι), MeasureTheory.AnalyticSet (s n)\n⊢ MeasureTheory.AnalyticSet (Set.iInter fun n => s n)","decl":"/-- A countable intersection of analytic sets is analytic. -/\ntheorem AnalyticSet.iInter [hι : Nonempty ι] [Countable ι] [T2Space α] {s : ι → Set α}\n    (hs : ∀ n, AnalyticSet (s n)) : AnalyticSet (⋂ n, s n) := by\n  rcases hι with ⟨i₀⟩\n  /- For the proof, write each `s n` as the continuous image under a map `f n` of a\n    Polish space `β n`. The product space `γ = Π n, β n` is also Polish, and so is the subset\n    `t` of sequences `x n` for which `f n (x n)` is independent of `n`. The set `t` is Polish, and\n    the range of `x ↦ f 0 (x 0)` on `t` is exactly `⋂ n, s n`, so this set is analytic. -/\n  choose β hβ h'β f f_cont f_range using fun n =>\n    analyticSet_iff_exists_polishSpace_range.1 (hs n)\n  let γ := ∀ n, β n\n  let t : Set γ := ⋂ n, { x | f n (x n) = f i₀ (x i₀) }\n  have t_closed : IsClosed t := by\n    apply isClosed_iInter\n    intro n\n    exact\n      isClosed_eq ((f_cont n).comp (continuous_apply n)) ((f_cont i₀).comp (continuous_apply i₀))\n  haveI : PolishSpace t := t_closed.polishSpace\n  let F : t → α := fun x => f i₀ ((x : γ) i₀)\n  have F_cont : Continuous F := (f_cont i₀).comp ((continuous_apply i₀).comp continuous_subtype_val)\n  have F_range : range F = ⋂ n : ι, s n := by\n    apply Subset.antisymm\n    · rintro y ⟨x, rfl⟩\n      refine mem_iInter.2 fun n => ?_\n      have : f n ((x : γ) n) = F x := (mem_iInter.1 x.2 n :)\n      rw [← this, ← f_range n]\n      exact mem_range_self _\n    · intro y hy\n      have A : ∀ n, ∃ x : β n, f n x = y := by\n        intro n\n        rw [← mem_range, f_range n]\n        exact mem_iInter.1 hy n\n      choose x hx using A\n      have xt : x ∈ t := by\n        refine mem_iInter.2 fun n => ?_\n        simp [γ, t, F, hx]\n      refine ⟨⟨x, xt⟩, ?_⟩\n      exact hx i₀\n  rw [← F_range]\n  exact analyticSet_range_of_polishSpace F_cont\n\n"}
{"name":"MeasureTheory.AnalyticSet.iUnion","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : Countable ι\ns : ι → Set α\nhs : ∀ (n : ι), MeasureTheory.AnalyticSet (s n)\n⊢ MeasureTheory.AnalyticSet (Set.iUnion fun n => s n)","decl":"/-- A countable union of analytic sets is analytic. -/\ntheorem AnalyticSet.iUnion [Countable ι] {s : ι → Set α} (hs : ∀ n, AnalyticSet (s n)) :\n    AnalyticSet (⋃ n, s n) := by\n  /- For the proof, write each `s n` as the continuous image under a map `f n` of a\n    Polish space `β n`. The union space `γ = Σ n, β n` is also Polish, and the map `F : γ → α` which\n    coincides with `f n` on `β n` sends it to `⋃ n, s n`. -/\n  choose β hβ h'β f f_cont f_range using fun n =>\n    analyticSet_iff_exists_polishSpace_range.1 (hs n)\n  let γ := Σn, β n\n  let F : γ → α := fun ⟨n, x⟩ ↦ f n x\n  have F_cont : Continuous F := continuous_sigma f_cont\n  have F_range : range F = ⋃ n, s n := by\n    simp only [γ, F, range_sigma_eq_iUnion_range, f_range]\n  rw [← F_range]\n  exact analyticSet_range_of_polishSpace F_cont\n\n"}
{"name":"IsClosed.analyticSet","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : PolishSpace α\ns : Set α\nhs : IsClosed s\n⊢ MeasureTheory.AnalyticSet s","decl":"theorem _root_.IsClosed.analyticSet [PolishSpace α] {s : Set α} (hs : IsClosed s) :\n    AnalyticSet s := by\n  haveI : PolishSpace s := hs.polishSpace\n  rw [← @Subtype.range_val α s]\n  exact analyticSet_range_of_polishSpace continuous_subtype_val\n\n"}
{"name":"MeasurableSet.isClopenable","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : PolishSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : BorelSpace α\ns : Set α\nhs : MeasurableSet s\n⊢ PolishSpace.IsClopenable s","decl":"/-- Given a Borel-measurable set in a Polish space, there exists a finer Polish topology making\nit clopen. This is in fact an equivalence, see `isClopenable_iff_measurableSet`. -/\ntheorem _root_.MeasurableSet.isClopenable [PolishSpace α] [MeasurableSpace α] [BorelSpace α]\n    {s : Set α} (hs : MeasurableSet s) : IsClopenable s := by\n  revert s\n  apply MeasurableSet.induction_on_open\n  · exact fun u hu => hu.isClopenable\n  · exact fun u _ h'u => h'u.compl\n  · exact fun f _ _ hf => IsClopenable.iUnion hf\n\n"}
{"name":"MeasurableSet.analyticSet","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_3\nt : TopologicalSpace α\ninst✝² : PolishSpace α\ninst✝¹ : MeasurableSpace α\ninst✝ : BorelSpace α\ns : Set α\nhs : MeasurableSet s\n⊢ MeasureTheory.AnalyticSet s","decl":"/-- A Borel-measurable set in a Polish space is analytic. -/\ntheorem _root_.MeasurableSet.analyticSet {α : Type*} [t : TopologicalSpace α] [PolishSpace α]\n    [MeasurableSpace α] [BorelSpace α] {s : Set α} (hs : MeasurableSet s) : AnalyticSet s := by\n  /- For a short proof (avoiding measurable induction), one sees `s` as a closed set for a finer\n    topology `t'`. It is analytic for this topology. As the identity from `t'` to `t` is continuous\n    and the image of an analytic set is analytic, it follows that `s` is also analytic for `t`. -/\n  obtain ⟨t', t't, t'_polish, s_closed, _⟩ :\n      ∃ t' : TopologicalSpace α, t' ≤ t ∧ @PolishSpace α t' ∧ IsClosed[t'] s ∧ IsOpen[t'] s :=\n    hs.isClopenable\n  have A := @IsClosed.analyticSet α t' t'_polish s s_closed\n  convert @AnalyticSet.image_of_continuous α t' α t s A id (continuous_id_of_le t't)\n  simp only [id, image_id']\n\n"}
{"name":"Measurable.exists_continuous","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nt : TopologicalSpace α\ninst✝⁵ : PolishSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\ntβ : TopologicalSpace β\ninst✝² : MeasurableSpace β\ninst✝¹ : OpensMeasurableSpace β\nf : α → β\ninst✝ : SecondCountableTopology ↑(Set.range f)\nhf : Measurable f\n⊢ Exists fun t' => And (LE.le t' t) (And (Continuous f) (PolishSpace α))","decl":"/-- Given a Borel-measurable function from a Polish space to a second-countable space, there exists\na finer Polish topology on the source space for which the function is continuous. -/\ntheorem _root_.Measurable.exists_continuous {α β : Type*} [t : TopologicalSpace α] [PolishSpace α]\n    [MeasurableSpace α] [BorelSpace α] [tβ : TopologicalSpace β] [MeasurableSpace β]\n    [OpensMeasurableSpace β] {f : α → β} [SecondCountableTopology (range f)] (hf : Measurable f) :\n    ∃ t' : TopologicalSpace α, t' ≤ t ∧ @Continuous α β t' tβ f ∧ @PolishSpace α t' := by\n  obtain ⟨b, b_count, -, hb⟩ :\n      ∃ b : Set (Set (range f)), b.Countable ∧ ∅ ∉ b ∧ IsTopologicalBasis b :=\n    exists_countable_basis (range f)\n  haveI : Countable b := b_count.to_subtype\n  have : ∀ s : b, IsClopenable (rangeFactorization f ⁻¹' s) := fun s ↦ by\n    apply MeasurableSet.isClopenable\n    exact hf.subtype_mk (hb.isOpen s.2).measurableSet\n  choose T Tt Tpolish _ Topen using this\n  obtain ⟨t', t'T, t't, t'_polish⟩ :\n      ∃ t' : TopologicalSpace α, (∀ i, t' ≤ T i) ∧ t' ≤ t ∧ @PolishSpace α t' :=\n    exists_polishSpace_forall_le (t := t) T Tt Tpolish\n  refine ⟨t', t't, ?_, t'_polish⟩\n  have : Continuous[t', _] (rangeFactorization f) :=\n    hb.continuous_iff.2 fun s hs => t'T ⟨s, hs⟩ _ (Topen ⟨s, hs⟩)\n  exact continuous_subtype_val.comp this\n\n"}
{"name":"MeasurableSet.analyticSet_image","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝⁵ : MeasurableSpace X\ninst✝⁴ : StandardBorelSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : MeasurableSpace Y\ninst✝¹ : OpensMeasurableSpace Y\nf : X → Y\ninst✝ : SecondCountableTopology ↑(Set.range f)\ns : Set X\nhs : MeasurableSet s\nhf : Measurable f\n⊢ MeasureTheory.AnalyticSet (Set.image f s)","decl":"/-- The image of a measurable set in a standard Borel space under a measurable map\nis an analytic set. -/\ntheorem _root_.MeasurableSet.analyticSet_image {X Y : Type*} [MeasurableSpace X]\n    [StandardBorelSpace X] [TopologicalSpace Y] [MeasurableSpace Y]\n    [OpensMeasurableSpace Y] {f : X → Y} [SecondCountableTopology (range f)] {s : Set X}\n    (hs : MeasurableSet s) (hf : Measurable f) : AnalyticSet (f '' s) := by\n  letI := upgradeStandardBorel X\n  rw [eq_borel_upgradeStandardBorel X] at hs\n  rcases hf.exists_continuous with ⟨τ', hle, hfc, hτ'⟩\n  letI m' : MeasurableSpace X := @borel _ τ'\n  haveI b' : BorelSpace X := ⟨rfl⟩\n  have hle := borel_anti hle\n  exact (hle _ hs).analyticSet.image_of_continuous hfc\n\n"}
{"name":"MeasureTheory.AnalyticSet.preimage","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : PolishSpace X\ninst✝ : T2Space Y\ns : Set Y\nhs : MeasureTheory.AnalyticSet s\nf : X → Y\nhf : Continuous f\n⊢ MeasureTheory.AnalyticSet (Set.preimage f s)","decl":"/-- Preimage of an analytic set is an analytic set. -/\nprotected lemma AnalyticSet.preimage {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [PolishSpace X] [T2Space Y] {s : Set Y} (hs : AnalyticSet s) {f : X → Y} (hf : Continuous f) :\n    AnalyticSet (f ⁻¹' s) := by\n  rcases analyticSet_iff_exists_polishSpace_range.1 hs with ⟨Z, _, _, g, hg, rfl⟩\n  have : IsClosed {x : X × Z | f x.1 = g x.2} := isClosed_eq hf.fst' hg.snd'\n  convert this.analyticSet.image_of_continuous continuous_fst\n  ext x\n  simp [eq_comm]\n\n"}
{"name":"MeasureTheory.MeasurablySeparable.iUnion","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"ι : Type u_2\ninst✝¹ : Countable ι\nα : Type u_3\ninst✝ : MeasurableSpace α\ns t : ι → Set α\nh : ∀ (m n : ι), MeasureTheory.MeasurablySeparable (s m) (t n)\n⊢ MeasureTheory.MeasurablySeparable (Set.iUnion fun n => s n) (Set.iUnion fun m => t m)","decl":"theorem MeasurablySeparable.iUnion [Countable ι] {α : Type*} [MeasurableSpace α] {s t : ι → Set α}\n    (h : ∀ m n, MeasurablySeparable (s m) (t n)) : MeasurablySeparable (⋃ n, s n) (⋃ m, t m) := by\n  choose u hsu htu hu using h\n  refine ⟨⋃ m, ⋂ n, u m n, ?_, ?_, ?_⟩\n  · refine iUnion_subset fun m => subset_iUnion_of_subset m ?_\n    exact subset_iInter fun n => hsu m n\n  · simp_rw [disjoint_iUnion_left, disjoint_iUnion_right]\n    intro n m\n    apply Disjoint.mono_right _ (htu m n)\n    apply iInter_subset\n  · refine MeasurableSet.iUnion fun m => ?_\n    exact MeasurableSet.iInter fun n => hu m n\n\n"}
{"name":"MeasureTheory.measurablySeparable_range_of_disjoint","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : T2Space α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\nf g : (Nat → Nat) → α\nhf : Continuous f\nhg : Continuous g\nh : Disjoint (Set.range f) (Set.range g)\n⊢ MeasureTheory.MeasurablySeparable (Set.range f) (Set.range g)","decl":"/-- The hard part of the Lusin separation theorem saying that two disjoint analytic sets are\ncontained in disjoint Borel sets (see the full statement in `AnalyticSet.measurablySeparable`).\nHere, we prove this when our analytic sets are the ranges of functions from `ℕ → ℕ`.\n-/\ntheorem measurablySeparable_range_of_disjoint [T2Space α] [MeasurableSpace α]\n    [OpensMeasurableSpace α] {f g : (ℕ → ℕ) → α} (hf : Continuous f) (hg : Continuous g)\n    (h : Disjoint (range f) (range g)) : MeasurablySeparable (range f) (range g) := by\n  /- We follow [Kechris, *Classical Descriptive Set Theory* (Theorem 14.7)][kechris1995].\n    If the ranges are not Borel-separated, then one can find two cylinders of length one whose\n    images are not Borel-separated, and then two smaller cylinders of length two whose images are\n    not Borel-separated, and so on. One thus gets two sequences of cylinders, that decrease to two\n    points `x` and `y`. Their images are different by the disjointness assumption, hence contained\n    in two disjoint open sets by the T2 property. By continuity, long enough cylinders around `x`\n    and `y` have images which are separated by these two disjoint open sets, a contradiction.\n    -/\n  by_contra hfg\n  have I : ∀ n x y, ¬MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) →\n      ∃ x' y', x' ∈ cylinder x n ∧ y' ∈ cylinder y n ∧\n      ¬MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by\n    intro n x y\n    contrapose!\n    intro H\n    rw [← iUnion_cylinder_update x n, ← iUnion_cylinder_update y n, image_iUnion, image_iUnion]\n    refine MeasurablySeparable.iUnion fun i j => ?_\n    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)\n  -- consider the set of pairs of cylinders of some length whose images are not Borel-separated\n  let A :=\n    { p : ℕ × (ℕ → ℕ) × (ℕ → ℕ) //\n      ¬MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }\n  -- for each such pair, one can find longer cylinders whose images are not Borel-separated either\n  have : ∀ p : A, ∃ q : A,\n      q.1.1 = p.1.1 + 1 ∧ q.1.2.1 ∈ cylinder p.1.2.1 p.1.1 ∧ q.1.2.2 ∈ cylinder p.1.2.2 p.1.1 := by\n    rintro ⟨⟨n, x, y⟩, hp⟩\n    rcases I n x y hp with ⟨x', y', hx', hy', h'⟩\n    exact ⟨⟨⟨n + 1, x', y'⟩, h'⟩, rfl, hx', hy'⟩\n  choose F hFn hFx hFy using this\n  let p0 : A := ⟨⟨0, fun _ => 0, fun _ => 0⟩, by simp [hfg]⟩\n  -- construct inductively decreasing sequences of cylinders whose images are not separated\n  let p : ℕ → A := fun n => F^[n] p0\n  have prec : ∀ n, p (n + 1) = F (p n) := fun n => by simp only [p, iterate_succ', Function.comp]\n  -- check that at the `n`-th step we deal with cylinders of length `n`\n  have pn_fst : ∀ n, (p n).1.1 = n := by\n    intro n\n    induction' n with n IH\n    · rfl\n    · simp only [prec, hFn, IH]\n  -- check that the cylinders we construct are indeed decreasing, by checking that the coordinates\n  -- are stationary.\n  have Ix : ∀ m n, m + 1 ≤ n → (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by\n    intro m\n    apply Nat.le_induction\n    · rfl\n    intro n hmn IH\n    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by\n      apply hFx (p n) m\n      rw [pn_fst]\n      exact hmn\n    rw [prec, I, IH]\n  have Iy : ∀ m n, m + 1 ≤ n → (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by\n    intro m\n    apply Nat.le_induction\n    · rfl\n    intro n hmn IH\n    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by\n      apply hFy (p n) m\n      rw [pn_fst]\n      exact hmn\n    rw [prec, I, IH]\n  -- denote by `x` and `y` the limit points of these two sequences of cylinders.\n  set x : ℕ → ℕ := fun n => (p (n + 1)).1.2.1 n with hx\n  set y : ℕ → ℕ := fun n => (p (n + 1)).1.2.2 n with hy\n  -- by design, the cylinders around these points have images which are not Borel-separable.\n  have M : ∀ n, ¬MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by\n    intro n\n    convert (p n).2 using 3\n    · rw [pn_fst, ← mem_cylinder_iff_eq, mem_cylinder_iff]\n      intro i hi\n      rw [hx]\n      exact (Ix i n hi).symm\n    · rw [pn_fst, ← mem_cylinder_iff_eq, mem_cylinder_iff]\n      intro i hi\n      rw [hy]\n      exact (Iy i n hi).symm\n  -- consider two open sets separating `f x` and `g y`.\n  obtain ⟨u, v, u_open, v_open, xu, yv, huv⟩ :\n      ∃ u v : Set α, IsOpen u ∧ IsOpen v ∧ f x ∈ u ∧ g y ∈ v ∧ Disjoint u v := by\n    apply t2_separation\n    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)\n  letI : MetricSpace (ℕ → ℕ) := metricSpaceNatNat\n  obtain ⟨εx, εxpos, hεx⟩ : ∃ (εx : ℝ), εx > 0 ∧ Metric.ball x εx ⊆ f ⁻¹' u := by\n    apply Metric.mem_nhds_iff.1\n    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)\n  obtain ⟨εy, εypos, hεy⟩ : ∃ (εy : ℝ), εy > 0 ∧ Metric.ball y εy ⊆ g ⁻¹' v := by\n    apply Metric.mem_nhds_iff.1\n    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)\n  obtain ⟨n, hn⟩ : ∃ n : ℕ, (1 / 2 : ℝ) ^ n < min εx εy :=\n    exists_pow_lt_of_lt_one (lt_min εxpos εypos) (by norm_num)\n  -- for large enough `n`, these open sets separate the images of long cylinders around `x` and `y`\n  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by\n    refine ⟨u, ?_, ?_, u_open.measurableSet⟩\n    · rw [image_subset_iff]\n      apply Subset.trans _ hεx\n      intro z hz\n      rw [mem_cylinder_iff_dist_le] at hz\n      exact hz.trans_lt (hn.trans_le (min_le_left _ _))\n    · refine Disjoint.mono_left ?_ huv.symm\n      change g '' cylinder y n ⊆ v\n      rw [image_subset_iff]\n      apply Subset.trans _ hεy\n      intro z hz\n      rw [mem_cylinder_iff_dist_le] at hz\n      exact hz.trans_lt (hn.trans_le (min_le_right _ _))\n  -- this is a contradiction.\n  exact M n B\n\n"}
{"name":"MeasureTheory.AnalyticSet.measurablySeparable","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : T2Space α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\ns t : Set α\nhs : MeasureTheory.AnalyticSet s\nht : MeasureTheory.AnalyticSet t\nh : Disjoint s t\n⊢ MeasureTheory.MeasurablySeparable s t","decl":"/-- The **Lusin separation theorem**: if two analytic sets are disjoint, then they are contained in\ndisjoint Borel sets. -/\ntheorem AnalyticSet.measurablySeparable [T2Space α] [MeasurableSpace α] [OpensMeasurableSpace α]\n    {s t : Set α} (hs : AnalyticSet s) (ht : AnalyticSet t) (h : Disjoint s t) :\n    MeasurablySeparable s t := by\n  rw [AnalyticSet] at hs ht\n  rcases hs with (rfl | ⟨f, f_cont, rfl⟩)\n  · refine ⟨∅, Subset.refl _, by simp, MeasurableSet.empty⟩\n  rcases ht with (rfl | ⟨g, g_cont, rfl⟩)\n  · exact ⟨univ, subset_univ _, by simp, MeasurableSet.univ⟩\n  exact measurablySeparable_range_of_disjoint f_cont g_cont h\n\n"}
{"name":"MeasureTheory.AnalyticSet.measurableSet_of_compl","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : T2Space α\ninst✝¹ : MeasurableSpace α\ninst✝ : OpensMeasurableSpace α\ns : Set α\nhs : MeasureTheory.AnalyticSet s\nhsc : MeasureTheory.AnalyticSet (HasCompl.compl s)\n⊢ MeasurableSet s","decl":"/-- **Suslin's Theorem**: in a Hausdorff topological space, an analytic set with an analytic\ncomplement is measurable. -/\ntheorem AnalyticSet.measurableSet_of_compl [T2Space α] [MeasurableSpace α] [OpensMeasurableSpace α]\n    {s : Set α} (hs : AnalyticSet s) (hsc : AnalyticSet sᶜ) : MeasurableSet s := by\n  rcases hs.measurablySeparable hsc disjoint_compl_right with ⟨u, hsu, hdu, hmu⟩\n  obtain rfl : s = u := hsu.antisymm (disjoint_compl_left_iff_subset.1 hdu)\n  exact hmu\n\n"}
{"name":"Measurable.measurableSet_preimage_iff_of_surjective","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\ninst✝³ : MeasurableSpace X\ninst✝² : StandardBorelSpace X\ninst✝¹ : MeasurableSpace Z\ninst✝ : MeasurableSpace.CountablySeparated Z\nf : X → Z\nhf : Measurable f\nhsurj : Function.Surjective f\ns : Set Z\n⊢ Iff (MeasurableSet (Set.preimage f s)) (MeasurableSet s)","decl":"/-- If `f : X → Z` is a surjective Borel measurable map from a standard Borel space\nto a countably separated measurable space, then the preimage of a set `s`\nis measurable if and only if the set is measurable.\nOne implication is the definition of measurability, the other one heavily relies on `X` being a\nstandard Borel space. -/\ntheorem measurableSet_preimage_iff_of_surjective [CountablySeparated Z]\n    {f : X → Z} (hf : Measurable f) (hsurj : Surjective f) {s : Set Z} :\n    MeasurableSet (f ⁻¹' s) ↔ MeasurableSet s := by\n  refine ⟨fun h => ?_, fun h => hf h⟩\n  rcases exists_opensMeasurableSpace_of_countablySeparated Z with ⟨τ, _, _, _⟩\n  apply AnalyticSet.measurableSet_of_compl\n  · rw [← image_preimage_eq s hsurj]\n    exact h.analyticSet_image hf\n  · rw [← image_preimage_eq sᶜ hsurj]\n    exact h.compl.analyticSet_image hf\n\n"}
{"name":"Measurable.map_measurableSpace_eq","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\ninst✝³ : MeasurableSpace X\ninst✝² : StandardBorelSpace X\ninst✝¹ : MeasurableSpace Z\ninst✝ : MeasurableSpace.CountablySeparated Z\nf : X → Z\nhf : Measurable f\nhsurj : Function.Surjective f\n⊢ Eq (MeasurableSpace.map f inst✝³) inst✝¹","decl":"theorem map_measurableSpace_eq [CountablySeparated Z]\n    {f : X → Z} (hf : Measurable f)\n    (hsurj : Surjective f) : MeasurableSpace.map f ‹MeasurableSpace X› = ‹MeasurableSpace Z› :=\n  MeasurableSpace.ext fun _ => hf.measurableSet_preimage_iff_of_surjective hsurj\n\n"}
{"name":"Measurable.map_measurableSpace_eq_borel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝⁶ : MeasurableSpace X\ninst✝⁵ : StandardBorelSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : T0Space Y\ninst✝² : MeasurableSpace Y\ninst✝¹ : OpensMeasurableSpace Y\ninst✝ : SecondCountableTopology Y\nf : X → Y\nhf : Measurable f\nhsurj : Function.Surjective f\n⊢ Eq (MeasurableSpace.map f inst✝⁶) (borel Y)","decl":"theorem map_measurableSpace_eq_borel [SecondCountableTopology Y] {f : X → Y} (hf : Measurable f)\n    (hsurj : Surjective f) : MeasurableSpace.map f ‹MeasurableSpace X› = borel Y := by\n  have d := hf.mono le_rfl OpensMeasurableSpace.borel_le\n  letI := borel Y; haveI : BorelSpace Y := ⟨rfl⟩\n  exact d.map_measurableSpace_eq hsurj\n\n"}
{"name":"Measurable.borelSpace_codomain","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝⁶ : MeasurableSpace X\ninst✝⁵ : StandardBorelSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : T0Space Y\ninst✝² : MeasurableSpace Y\ninst✝¹ : OpensMeasurableSpace Y\ninst✝ : SecondCountableTopology Y\nf : X → Y\nhf : Measurable f\nhsurj : Function.Surjective f\n⊢ BorelSpace Y","decl":"theorem borelSpace_codomain [SecondCountableTopology Y] {f : X → Y} (hf : Measurable f)\n    (hsurj : Surjective f) : BorelSpace Y :=\n  ⟨(hf.map_measurableSpace_eq hsurj).symm.trans <| hf.map_measurableSpace_eq_borel hsurj⟩\n\n"}
{"name":"Measurable.measurableSet_preimage_iff_preimage_val","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\ninst✝³ : MeasurableSpace X\ninst✝² : StandardBorelSpace X\ninst✝¹ : MeasurableSpace Z\nf : X → Z\ninst✝ : MeasurableSpace.CountablySeparated ↑(Set.range f)\nhf : Measurable f\ns : Set Z\n⊢ Iff (MeasurableSet (Set.preimage f s)) (MeasurableSet (Set.preimage Subtype.val s))","decl":"/-- If `f : X → Z` is a Borel measurable map from a standard Borel space to a\ncountably separated measurable space then the preimage of a set `s` is measurable\nif and only if the set is measurable in `Set.range f`. -/\ntheorem measurableSet_preimage_iff_preimage_val {f : X → Z} [CountablySeparated (range f)]\n    (hf : Measurable f) {s : Set Z} :\n    MeasurableSet (f ⁻¹' s) ↔ MeasurableSet ((↑) ⁻¹' s : Set (range f)) :=\n  have hf' : Measurable (rangeFactorization f) := hf.subtype_mk\n  hf'.measurableSet_preimage_iff_of_surjective (s := Subtype.val ⁻¹' s) surjective_onto_range\n\n"}
{"name":"Measurable.measurableSet_preimage_iff_inter_range","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\ninst✝³ : MeasurableSpace X\ninst✝² : StandardBorelSpace X\ninst✝¹ : MeasurableSpace Z\nf : X → Z\ninst✝ : MeasurableSpace.CountablySeparated ↑(Set.range f)\nhf : Measurable f\nhr : MeasurableSet (Set.range f)\ns : Set Z\n⊢ Iff (MeasurableSet (Set.preimage f s)) (MeasurableSet (Inter.inter s (Set.range f)))","decl":"/-- If `f : X → Z` is a Borel measurable map from a standard Borel space to a\ncountably separated measurable space and the range of `f` is measurable,\nthen the preimage of a set `s` is measurable\nif and only if the intersection with `Set.range f` is measurable. -/\ntheorem measurableSet_preimage_iff_inter_range {f : X → Z} [CountablySeparated (range f)]\n    (hf : Measurable f) (hr : MeasurableSet (range f)) {s : Set Z} :\n    MeasurableSet (f ⁻¹' s) ↔ MeasurableSet (s ∩ range f) := by\n  rw [hf.measurableSet_preimage_iff_preimage_val, inter_comm,\n    ← (MeasurableEmbedding.subtype_coe hr).measurableSet_image, Subtype.image_preimage_coe]\n\n"}
{"name":"Measurable.measurable_comp_iff_restrict","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\nβ : Type u_6\ninst✝⁴ : MeasurableSpace X\ninst✝³ : StandardBorelSpace X\ninst✝² : MeasurableSpace β\ninst✝¹ : MeasurableSpace Z\nf : X → Z\ninst✝ : MeasurableSpace.CountablySeparated ↑(Set.range f)\nhf : Measurable f\ng : Z → β\n⊢ Iff (Measurable (Function.comp g f)) (Measurable ((Set.range f).restrict g))","decl":"/-- If `f : X → Z` is a Borel measurable map from a standard Borel space\nto a countably separated measurable space,\nthen for any measurable space `β` and `g : Z → β`, the composition `g ∘ f` is\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. -/\ntheorem measurable_comp_iff_restrict {f : X → Z}\n    [CountablySeparated (range f)]\n    (hf : Measurable f) {g : Z → β} : Measurable (g ∘ f) ↔ Measurable (restrict (range f) g) :=\n  forall₂_congr fun s _ => measurableSet_preimage_iff_preimage_val hf (s := g ⁻¹' s)\n\n"}
{"name":"Measurable.measurable_comp_iff_of_surjective","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nZ : Type u_5\nβ : Type u_6\ninst✝⁴ : MeasurableSpace X\ninst✝³ : StandardBorelSpace X\ninst✝² : MeasurableSpace β\ninst✝¹ : MeasurableSpace Z\ninst✝ : MeasurableSpace.CountablySeparated Z\nf : X → Z\nhf : Measurable f\nhsurj : Function.Surjective f\ng : Z → β\n⊢ Iff (Measurable (Function.comp g f)) (Measurable g)","decl":"/-- If `f : X → Z` is a surjective Borel measurable map from a standard Borel space\nto a countably separated measurable space,\nthen for any measurable space `α` and `g : Z → α`, the composition\n`g ∘ f` is measurable if and only if `g` is measurable. -/\ntheorem measurable_comp_iff_of_surjective [CountablySeparated Z]\n    {f : X → Z} (hf : Measurable f) (hsurj : Surjective f)\n    {g : Z → β} : Measurable (g ∘ f) ↔ Measurable g :=\n  forall₂_congr fun s _ => measurableSet_preimage_iff_of_surjective hf hsurj (s := g ⁻¹' s)\n\n"}
{"name":"Continuous.map_eq_borel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : PolishSpace X\ninst✝⁴ : MeasurableSpace X\ninst✝³ : BorelSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : T0Space Y\ninst✝ : SecondCountableTopology Y\nf : X → Y\nhf : Continuous f\nhsurj : Function.Surjective f\n⊢ Eq (MeasurableSpace.map f inst✝⁴) (borel Y)","decl":"theorem Continuous.map_eq_borel {X Y : Type*} [TopologicalSpace X] [PolishSpace X]\n    [MeasurableSpace X] [BorelSpace X] [TopologicalSpace Y] [T0Space Y] [SecondCountableTopology Y]\n    {f : X → Y} (hf : Continuous f) (hsurj : Surjective f) :\n    MeasurableSpace.map f ‹MeasurableSpace X› = borel Y := by\n  borelize Y\n  exact hf.measurable.map_measurableSpace_eq hsurj\n\n"}
{"name":"Continuous.map_borel_eq","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\nY : Type u_4\ninst✝⁴ : TopologicalSpace X\ninst✝³ : PolishSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : T0Space Y\ninst✝ : SecondCountableTopology Y\nf : X → Y\nhf : Continuous f\nhsurj : Function.Surjective f\n⊢ Eq (MeasurableSpace.map f (borel X)) (borel Y)","decl":"theorem Continuous.map_borel_eq {X Y : Type*} [TopologicalSpace X] [PolishSpace X]\n    [TopologicalSpace Y] [T0Space Y] [SecondCountableTopology Y] {f : X → Y} (hf : Continuous f)\n    (hsurj : Surjective f) : MeasurableSpace.map f (borel X) = borel Y := by\n  borelize X\n  exact hf.map_eq_borel hsurj\n\n"}
{"name":"Quotient.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"X : Type u_3\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : PolishSpace X\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ns : Setoid X\ninst✝¹ : T0Space (Quotient s)\ninst✝ : SecondCountableTopology (Quotient s)\n⊢ BorelSpace (Quotient s)","decl":"instance Quotient.borelSpace {X : Type*} [TopologicalSpace X] [PolishSpace X] [MeasurableSpace X]\n    [BorelSpace X] {s : Setoid X} [T0Space (Quotient s)] [SecondCountableTopology (Quotient s)] :\n    BorelSpace (Quotient s) :=\n  ⟨continuous_quotient_mk'.map_eq_borel Quotient.mk'_surjective⟩\n\n"}
{"name":"AddCosetSpace.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"G : Type u_3\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : PolishSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableSpace G\ninst✝² : BorelSpace G\nN : AddSubgroup G\ninst✝¹ : T2Space (HasQuotient.Quotient G N)\ninst✝ : SecondCountableTopology (HasQuotient.Quotient G N)\n⊢ BorelSpace (HasQuotient.Quotient G N)","decl":"/-- When the subgroup `N < G` is not necessarily `Normal`, we have a `CosetSpace` as opposed\nto `QuotientGroup` (the next `instance`).\nTODO: typeclass inference should normally find this, but currently doesn't.\nE.g., `MeasurableSMul G (G ⧸ Γ)` fails to synthesize, even though `G ⧸ Γ` is the quotient\nof `G` by the action of `Γ`; it seems unable to pick up the `BorelSpace` instance. -/\n@[to_additive AddCosetSpace.borelSpace]\ninstance CosetSpace.borelSpace {G : Type*} [TopologicalSpace G] [PolishSpace G] [Group G]\n    [MeasurableSpace G] [BorelSpace G] {N : Subgroup G} [T2Space (G ⧸ N)]\n    [SecondCountableTopology (G ⧸ N)] : BorelSpace (G ⧸ N) := Quotient.borelSpace\n\n"}
{"name":"CosetSpace.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"G : Type u_3\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : PolishSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableSpace G\ninst✝² : BorelSpace G\nN : Subgroup G\ninst✝¹ : T2Space (HasQuotient.Quotient G N)\ninst✝ : SecondCountableTopology (HasQuotient.Quotient G N)\n⊢ BorelSpace (HasQuotient.Quotient G N)","decl":"/-- When the subgroup `N < G` is not necessarily `Normal`, we have a `CosetSpace` as opposed\nto `QuotientGroup` (the next `instance`).\nTODO: typeclass inference should normally find this, but currently doesn't.\nE.g., `MeasurableSMul G (G ⧸ Γ)` fails to synthesize, even though `G ⧸ Γ` is the quotient\nof `G` by the action of `Γ`; it seems unable to pick up the `BorelSpace` instance. -/\n@[to_additive AddCosetSpace.borelSpace]\ninstance CosetSpace.borelSpace {G : Type*} [TopologicalSpace G] [PolishSpace G] [Group G]\n    [MeasurableSpace G] [BorelSpace G] {N : Subgroup G} [T2Space (G ⧸ N)]\n    [SecondCountableTopology (G ⧸ N)] : BorelSpace (G ⧸ N) := Quotient.borelSpace\n\n"}
{"name":"QuotientAddGroup.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"G : Type u_3\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : PolishSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : TopologicalAddGroup G\ninst✝³ : MeasurableSpace G\ninst✝² : BorelSpace G\nN : AddSubgroup G\ninst✝¹ : N.Normal\ninst✝ : IsClosed ↑N\n⊢ BorelSpace (HasQuotient.Quotient G N)","decl":"@[to_additive]\ninstance QuotientGroup.borelSpace {G : Type*} [TopologicalSpace G] [PolishSpace G] [Group G]\n    [TopologicalGroup G] [MeasurableSpace G] [BorelSpace G] {N : Subgroup G} [N.Normal]\n    [IsClosed (N : Set G)] : BorelSpace (G ⧸ N) :=\n  ⟨continuous_mk.map_eq_borel mk_surjective⟩\n\n"}
{"name":"QuotientGroup.borelSpace","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"G : Type u_3\ninst✝⁷ : TopologicalSpace G\ninst✝⁶ : PolishSpace G\ninst✝⁵ : Group G\ninst✝⁴ : TopologicalGroup G\ninst✝³ : MeasurableSpace G\ninst✝² : BorelSpace G\nN : Subgroup G\ninst✝¹ : N.Normal\ninst✝ : IsClosed ↑N\n⊢ BorelSpace (HasQuotient.Quotient G N)","decl":"@[to_additive]\ninstance QuotientGroup.borelSpace {G : Type*} [TopologicalSpace G] [PolishSpace G] [Group G]\n    [TopologicalGroup G] [MeasurableSpace G] [BorelSpace G] {N : Subgroup G} [N.Normal]\n    [IsClosed (N : Set G)] : BorelSpace (G ⧸ N) :=\n  ⟨continuous_mk.map_eq_borel mk_surjective⟩\n\n"}
{"name":"MeasureTheory.measurableSet_range_of_continuous_injective","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"γ : Type u_3\nβ : Type u_4\ninst✝⁵ : TopologicalSpace γ\ninst✝⁴ : PolishSpace γ\ninst✝³ : TopologicalSpace β\ninst✝² : T2Space β\ninst✝¹ : MeasurableSpace β\ninst✝ : OpensMeasurableSpace β\nf : γ → β\nf_cont : Continuous f\nf_inj : Function.Injective f\n⊢ MeasurableSet (Set.range f)","decl":"/-- The **Lusin-Souslin theorem**: the range of a continuous injective function defined on a Polish\nspace is Borel-measurable. -/\ntheorem measurableSet_range_of_continuous_injective {β : Type*} [TopologicalSpace γ]\n    [PolishSpace γ] [TopologicalSpace β] [T2Space β] [MeasurableSpace β] [OpensMeasurableSpace β]\n    {f : γ → β} (f_cont : Continuous f) (f_inj : Injective f) :\n    MeasurableSet (range f) := by\n  /- We follow [Fremlin, *Measure Theory* (volume 4, 423I)][fremlin_vol4].\n    Let `b = {s i}` be a countable basis for `α`. When `s i` and `s j` are disjoint, their images\n    are disjoint analytic sets, hence by the separation theorem one can find a Borel-measurable set\n    `q i j` separating them.\n    Let `E i = closure (f '' s i) ∩ ⋂ j, q i j \\ q j i`. It contains `f '' (s i)` and it is\n    measurable. Let `F n = ⋃ E i`, where the union is taken over those `i` for which `diam (s i)`\n    is bounded by some number `u n` tending to `0` with `n`.\n    We claim that `range f = ⋂ F n`, from which the measurability is obvious. The inclusion `⊆` is\n    straightforward. To show `⊇`, consider a point `x` in the intersection. For each `n`, it belongs\n    to some `E i` with `diam (s i) ≤ u n`. Pick a point `y i ∈ s i`. We claim that for such `i`\n    and `j`, the intersection `s i ∩ s j` is nonempty: if it were empty, then thanks to the\n    separating set `q i j` in the definition of `E i` one could not have `x ∈ E i ∩ E j`.\n    Since these two sets have small diameter, it follows that `y i` and `y j` are close.\n    Thus, `y` is a Cauchy sequence, converging to a limit `z`. We claim that `f z = x`, completing\n    the proof.\n    Otherwise, one could find open sets `v` and `w` separating `f z` from `x`. Then, for large `n`,\n    the image `f '' (s i)` would be included in `v` by continuity of `f`, so its closure would be\n    contained in the closure of `v`, and therefore it would be disjoint from `w`. This is a\n    contradiction since `x` belongs both to this closure and to `w`. -/\n  letI := upgradePolishSpace γ\n  obtain ⟨b, b_count, b_nonempty, hb⟩ :\n    ∃ b : Set (Set γ), b.Countable ∧ ∅ ∉ b ∧ IsTopologicalBasis b := exists_countable_basis γ\n  haveI : Encodable b := b_count.toEncodable\n  let A := { p : b × b // Disjoint (p.1 : Set γ) p.2 }\n  -- for each pair of disjoint sets in the topological basis `b`, consider Borel sets separating\n  -- their images, by injectivity of `f` and the Lusin separation theorem.\n  have : ∀ p : A, ∃ q : Set β,\n      f '' (p.1.1 : Set γ) ⊆ q ∧ Disjoint (f '' (p.1.2 : Set γ)) q ∧ MeasurableSet q := by\n    intro p\n    apply\n      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)\n        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)\n    exact Disjoint.image p.2 f_inj.injOn (subset_univ _) (subset_univ _)\n  choose q hq1 hq2 q_meas using this\n  -- define sets `E i` and `F n` as in the proof sketch above\n  let E : b → Set β := fun s =>\n    closure (f '' s) ∩ ⋂ (t : b) (ht : Disjoint s.1 t.1), q ⟨(s, t), ht⟩ \\ q ⟨(t, s), ht.symm⟩\n  obtain ⟨u, u_anti, u_pos, u_lim⟩ :\n      ∃ u : ℕ → ℝ, StrictAnti u ∧ (∀ n : ℕ, 0 < u n) ∧ Tendsto u atTop (𝓝 0) :=\n    exists_seq_strictAnti_tendsto (0 : ℝ)\n  let F : ℕ → Set β := fun n => ⋃ (s : b) (_ : IsBounded s.1 ∧ diam s.1 ≤ u n), E s\n  -- it is enough to show that `range f = ⋂ F n`, as the latter set is obviously measurable.\n  suffices range f = ⋂ n, F n by\n    have E_meas : ∀ s : b, MeasurableSet (E s) := by\n      intro b\n      refine isClosed_closure.measurableSet.inter ?_\n      refine MeasurableSet.iInter fun s => ?_\n      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)\n    have F_meas : ∀ n, MeasurableSet (F n) := by\n      intro n\n      refine MeasurableSet.iUnion fun s => ?_\n      exact MeasurableSet.iUnion fun _ => E_meas _\n    rw [this]\n    exact MeasurableSet.iInter fun n => F_meas n\n  -- we check both inclusions.\n  apply Subset.antisymm\n  -- we start with the easy inclusion `range f ⊆ ⋂ F n`. One just needs to unfold the definitions.\n  · rintro x ⟨y, rfl⟩\n    refine mem_iInter.2 fun n => ?_\n    obtain ⟨s, sb, ys, hs⟩ : ∃ (s : Set γ), s ∈ b ∧ y ∈ s ∧ s ⊆ ball y (u n / 2) := by\n      apply hb.mem_nhds_iff.1\n      exact ball_mem_nhds _ (half_pos (u_pos n))\n    have diam_s : diam s ≤ u n := by\n      apply (diam_mono hs isBounded_ball).trans\n      convert diam_ball (x := y) (half_pos (u_pos n)).le\n      ring\n    refine mem_iUnion.2 ⟨⟨s, sb⟩, ?_⟩\n    refine mem_iUnion.2 ⟨⟨isBounded_ball.subset hs, diam_s⟩, ?_⟩\n    apply mem_inter (subset_closure (mem_image_of_mem _ ys))\n    refine mem_iInter.2 fun t => mem_iInter.2 fun ht => ⟨?_, ?_⟩\n    · apply hq1\n      exact mem_image_of_mem _ ys\n    · apply disjoint_left.1 (hq2 ⟨(t, ⟨s, sb⟩), ht.symm⟩)\n      exact mem_image_of_mem _ ys\n  -- Now, let us prove the harder inclusion `⋂ F n ⊆ range f`.\n  · intro x hx\n    -- pick for each `n` a good set `s n` of small diameter for which `x ∈ E (s n)`.\n    have C1 : ∀ n, ∃ (s : b) (_ : IsBounded s.1 ∧ diam s.1 ≤ u n), x ∈ E s := fun n => by\n      simpa only [F, mem_iUnion] using mem_iInter.1 hx n\n    choose s hs hxs using C1\n    have C2 : ∀ n, (s n).1.Nonempty := by\n      intro n\n      rw [nonempty_iff_ne_empty]\n      intro hn\n      have := (s n).2\n      rw [hn] at this\n      exact b_nonempty this\n    -- choose a point `y n ∈ s n`.\n    choose y hy using C2\n    have I : ∀ m n, ((s m).1 ∩ (s n).1).Nonempty := by\n      intro m n\n      rw [← not_disjoint_iff_nonempty_inter]\n      by_contra! h\n      have A : x ∈ q ⟨(s m, s n), h⟩ \\ q ⟨(s n, s m), h.symm⟩ :=\n        haveI := mem_iInter.1 (hxs m).2 (s n)\n        (mem_iInter.1 this h :)\n      have B : x ∈ q ⟨(s n, s m), h.symm⟩ \\ q ⟨(s m, s n), h⟩ :=\n        haveI := mem_iInter.1 (hxs n).2 (s m)\n        (mem_iInter.1 this h.symm :)\n      exact A.2 B.1\n    -- the points `y n` are nearby, and therefore they form a Cauchy sequence.\n    have cauchy_y : CauchySeq y := by\n      have : Tendsto (fun n => 2 * u n) atTop (𝓝 0) := by\n        simpa only [mul_zero] using u_lim.const_mul 2\n      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this\n      rcases I m n with ⟨z, zsm, zsn⟩\n      calc\n        dist (y m) (y n) ≤ dist (y m) z + dist z (y n) := dist_triangle _ _ _\n        _ ≤ u m + u n :=\n          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)\n            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))\n        _ ≤ 2 * u m := by linarith [u_anti.antitone hmn]\n    haveI : Nonempty γ := ⟨y 0⟩\n    -- let `z` be its limit.\n    let z := limUnder atTop y\n    have y_lim : Tendsto y atTop (𝓝 z) := cauchy_y.tendsto_limUnder\n    suffices f z = x by\n      rw [← this]\n      exact mem_range_self _\n    -- assume for a contradiction that `f z ≠ x`.\n    by_contra! hne\n    -- introduce disjoint open sets `v` and `w` separating `f z` from `x`.\n    obtain ⟨v, w, v_open, w_open, fzv, xw, hvw⟩ := t2_separation hne\n    obtain ⟨δ, δpos, hδ⟩ : ∃ δ > (0 : ℝ), ball z δ ⊆ f ⁻¹' v := by\n      apply Metric.mem_nhds_iff.1\n      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)\n    obtain ⟨n, hn⟩ : ∃ n, u n + dist (y n) z < δ :=\n      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (𝓝 0) := by\n        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)\n      ((tendsto_order.1 this).2 _ δpos).exists\n    -- for large enough `n`, the image of `s n` is contained in `v`, by continuity of `f`.\n    have fsnv : f '' s n ⊆ v := by\n      rw [image_subset_iff]\n      apply Subset.trans _ hδ\n      intro a ha\n      calc\n        dist a z ≤ dist a (y n) + dist (y n) z := dist_triangle _ _ _\n        _ ≤ u n + dist (y n) z :=\n          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)\n        _ < δ := hn\n    -- as `x` belongs to the closure of `f '' (s n)`, it belongs to the closure of `v`.\n    have : x ∈ closure v := closure_mono fsnv (hxs n).1\n    -- this is a contradiction, as `x` is supposed to belong to `w`, which is disjoint from\n    -- the closure of `v`.\n    exact disjoint_left.1 (hvw.closure_left w_open) this xw\n\n"}
{"name":"IsClosed.measurableSet_image_of_continuousOn_injOn","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"γ : Type u_3\ninst✝⁵ : TopologicalSpace γ\ninst✝⁴ : PolishSpace γ\nβ : Type u_4\ninst✝³ : TopologicalSpace β\ninst✝² : T2Space β\ninst✝¹ : MeasurableSpace β\ninst✝ : OpensMeasurableSpace β\ns : Set γ\nhs : IsClosed s\nf : γ → β\nf_cont : ContinuousOn f s\nf_inj : Set.InjOn f s\n⊢ MeasurableSet (Set.image f s)","decl":"theorem _root_.IsClosed.measurableSet_image_of_continuousOn_injOn\n    [TopologicalSpace γ] [PolishSpace γ] {β : Type*} [TopologicalSpace β] [T2Space β]\n    [MeasurableSpace β] [OpensMeasurableSpace β] {s : Set γ} (hs : IsClosed s) {f : γ → β}\n    (f_cont : ContinuousOn f s) (f_inj : InjOn f s) : MeasurableSet (f '' s) := by\n  rw [image_eq_range]\n  haveI : PolishSpace s := IsClosed.polishSpace hs\n  apply measurableSet_range_of_continuous_injective\n  · rwa [continuousOn_iff_continuous_restrict] at f_cont\n  · rwa [injOn_iff_injective] at f_inj\n\n"}
{"name":"MeasurableSet.image_of_continuousOn_injOn","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"γ : Type u_3\nβ : Type u_5\ninst✝⁵ : MeasurableSpace β\ntβ : TopologicalSpace β\ninst✝⁴ : T2Space β\ns : Set γ\nf : γ → β\ninst✝³ : OpensMeasurableSpace β\ntγ : TopologicalSpace γ\ninst✝² : PolishSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nhs : MeasurableSet s\nf_cont : ContinuousOn f s\nf_inj : Set.InjOn f s\n⊢ MeasurableSet (Set.image f s)","decl":"/-- The Lusin-Souslin theorem: if `s` is Borel-measurable in a Polish space, then its image under\na continuous injective map is also Borel-measurable. -/\ntheorem _root_.MeasurableSet.image_of_continuousOn_injOn [OpensMeasurableSpace β]\n    [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ]\n    (hs : MeasurableSet s)\n    (f_cont : ContinuousOn f s) (f_inj : InjOn f s) : MeasurableSet (f '' s) := by\n  obtain ⟨t', t't, t'_polish, s_closed, _⟩ :\n      ∃ t' : TopologicalSpace γ, t' ≤ tγ ∧ @PolishSpace γ t' ∧ IsClosed[t'] s ∧ IsOpen[t'] s :=\n    hs.isClopenable\n  exact\n    @IsClosed.measurableSet_image_of_continuousOn_injOn γ t' t'_polish β _ _ _ _ s s_closed f\n      (f_cont.mono_dom t't) f_inj\n\n"}
{"name":"MeasurableSet.image_of_measurable_injOn","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"γ : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace α\ns : Set γ\nf : γ → α\ninst✝² : MeasurableSpace.CountablySeparated α\ninst✝¹ : MeasurableSpace γ\ninst✝ : StandardBorelSpace γ\nhs : MeasurableSet s\nf_meas : Measurable f\nf_inj : Set.InjOn f s\n⊢ MeasurableSet (Set.image f s)","decl":"/-- The Lusin-Souslin theorem: if `s` is Borel-measurable in a standard Borel space,\nthen its image under a measurable injective map taking values in a\ncountably separate measurable space is also Borel-measurable. -/\ntheorem _root_.MeasurableSet.image_of_measurable_injOn {f : γ → α}\n    [MeasurableSpace.CountablySeparated α]\n    [MeasurableSpace γ] [StandardBorelSpace γ]\n    (hs : MeasurableSet s) (f_meas : Measurable f) (f_inj : InjOn f s) :\n    MeasurableSet (f '' s) := by\n  letI := upgradeStandardBorel γ\n  let tγ : TopologicalSpace γ := inferInstance\n  rcases exists_opensMeasurableSpace_of_countablySeparated α with ⟨τ, _, _, _⟩\n  -- for a finer Polish topology, `f` is continuous. Therefore, one may apply the corresponding\n  -- result for continuous maps.\n  obtain ⟨t', t't, f_cont, t'_polish⟩ :\n      ∃ t' : TopologicalSpace γ, t' ≤ tγ ∧ @Continuous γ _ t' _ f ∧ @PolishSpace γ t' :=\n    f_meas.exists_continuous\n  have M : MeasurableSet[@borel γ t'] s :=\n    @Continuous.measurable γ γ t' (@borel γ t')\n      (@BorelSpace.opensMeasurable γ t' (@borel γ t') (@BorelSpace.mk _ _ (borel γ) rfl))\n      tγ _ _ _ (continuous_id_of_le t't) s hs\n  exact\n    @MeasurableSet.image_of_continuousOn_injOn γ\n      _ _ _ _  s f _ t' t'_polish (@borel γ t') (@BorelSpace.mk _ _ (borel γ) rfl)\n      M (@Continuous.continuousOn γ _ t' _ f s f_cont) f_inj\n\n"}
{"name":"Continuous.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"γ : Type u_3\nβ : Type u_5\ninst✝⁶ : MeasurableSpace β\ntβ : TopologicalSpace β\ninst✝⁵ : T2Space β\nf : γ → β\ninst✝⁴ : BorelSpace β\ninst✝³ : TopologicalSpace γ\ninst✝² : PolishSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nf_cont : Continuous f\nf_inj : Function.Injective f\n⊢ MeasurableEmbedding f","decl":"/-- An injective continuous function on a Polish space is a measurable embedding. -/\ntheorem _root_.Continuous.measurableEmbedding [BorelSpace β]\n    [TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ]\n    (f_cont : Continuous f) (f_inj : Injective f) :\n    MeasurableEmbedding f :=\n  { injective := f_inj\n    measurable := f_cont.measurable\n    measurableSet_image' := fun _u hu =>\n      hu.image_of_continuousOn_injOn f_cont.continuousOn f_inj.injOn }\n\n"}
{"name":"ContinuousOn.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"γ : Type u_3\nβ : Type u_5\ninst✝⁶ : MeasurableSpace β\ntβ : TopologicalSpace β\ninst✝⁵ : T2Space β\ns : Set γ\nf : γ → β\ninst✝⁴ : BorelSpace β\ninst✝³ : TopologicalSpace γ\ninst✝² : PolishSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\nhs : MeasurableSet s\nf_cont : ContinuousOn f s\nf_inj : Set.InjOn f s\n⊢ MeasurableEmbedding (s.restrict f)","decl":"/-- If `s` is Borel-measurable in a Polish space and `f` is continuous injective on `s`, then\nthe restriction of `f` to `s` is a measurable embedding. -/\ntheorem _root_.ContinuousOn.measurableEmbedding [BorelSpace β]\n    [TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ]\n    (hs : MeasurableSet s) (f_cont : ContinuousOn f s)\n    (f_inj : InjOn f s) : MeasurableEmbedding (s.restrict f) :=\n  { injective := injOn_iff_injective.1 f_inj\n    measurable := (continuousOn_iff_continuous_restrict.1 f_cont).measurable\n    measurableSet_image' := by\n      intro u hu\n      have A : MeasurableSet (((↑) : s → γ) '' u) :=\n        (MeasurableEmbedding.subtype_coe hs).measurableSet_image.2 hu\n      have B : MeasurableSet (f '' (((↑) : s → γ) '' u)) :=\n        A.image_of_continuousOn_injOn (f_cont.mono (Subtype.coe_image_subset s u))\n          (f_inj.mono (Subtype.coe_image_subset s u))\n      rwa [← image_comp] at B }\n\n"}
{"name":"Measurable.measurableEmbedding","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"γ : Type u_3\nα : Type u_4\ninst✝³ : MeasurableSpace α\nf : γ → α\ninst✝² : MeasurableSpace.CountablySeparated α\ninst✝¹ : MeasurableSpace γ\ninst✝ : StandardBorelSpace γ\nf_meas : Measurable f\nf_inj : Function.Injective f\n⊢ MeasurableEmbedding f","decl":"/-- An injective measurable function from a standard Borel space to a\ncountably separated measurable space is a measurable embedding. -/\ntheorem _root_.Measurable.measurableEmbedding {f : γ → α}\n    [MeasurableSpace.CountablySeparated α]\n    [MeasurableSpace γ] [StandardBorelSpace γ]\n    (f_meas : Measurable f) (f_inj : Injective f) : MeasurableEmbedding f :=\n  { injective := f_inj\n    measurable := f_meas\n    measurableSet_image' := fun _u hu => hu.image_of_measurable_injOn f_meas f_inj.injOn }\n\n"}
{"name":"MeasureTheory.borel_eq_borel_of_le","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"γ : Type u_3\nt t' : TopologicalSpace γ\nht : PolishSpace γ\nht' : PolishSpace γ\nhle : LE.le t t'\n⊢ Eq (borel γ) (borel γ)","decl":"/-- If one Polish topology on a type refines another, they have the same Borel sets. -/\ntheorem borel_eq_borel_of_le {t t' : TopologicalSpace γ}\n    (ht : PolishSpace (h := t)) (ht' : PolishSpace (h := t')) (hle : t ≤ t') :\n    @borel _ t = @borel _ t' := by\n  refine le_antisymm ?_ (borel_anti hle)\n  intro s hs\n  have e := @Continuous.measurableEmbedding\n    _ _ (@borel _ t') t' _ _ (@BorelSpace.mk _ _ (borel γ) rfl)\n    t _ (@borel _ t) (@BorelSpace.mk _ t (@borel _ t) rfl) (continuous_id_of_le hle) injective_id\n  convert e.measurableSet_image.2 hs\n  simp only [id_eq, image_id']\n\n"}
{"name":"MeasureTheory.isClopenable_iff_measurableSet","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"γ : Type u_3\ns : Set γ\ntγ : TopologicalSpace γ\ninst✝² : PolishSpace γ\ninst✝¹ : MeasurableSpace γ\ninst✝ : BorelSpace γ\n⊢ Iff (PolishSpace.IsClopenable s) (MeasurableSet s)","decl":"/-- In a Polish space, a set is clopenable if and only if it is Borel-measurable. -/\ntheorem isClopenable_iff_measurableSet\n    [tγ : TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ] :\n    IsClopenable s ↔ MeasurableSet s := by\n  -- we already know that a measurable set is clopenable. Conversely, assume that `s` is clopenable.\n  refine ⟨fun hs => ?_, fun hs => hs.isClopenable⟩\n  borelize γ\n  -- consider a finer topology `t'` in which `s` is open and closed.\n  obtain ⟨t', t't, t'_polish, _, s_open⟩ :\n    ∃ t' : TopologicalSpace γ, t' ≤ tγ ∧ @PolishSpace γ t' ∧ IsClosed[t'] s ∧ IsOpen[t'] s := hs\n  rw [← borel_eq_borel_of_le t'_polish _ t't]\n  · exact MeasurableSpace.measurableSet_generateFrom s_open\n  infer_instance\n\n"}
{"name":"MeasureTheory.measurableSet_tendsto_fun","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"ι : Type u_2\nγ : Type u_3\nβ : Type u_5\ninst✝⁷ : MeasurableSpace β\ninst✝⁶ : MeasurableSpace γ\ninst✝⁵ : Countable ι\nl : Filter ι\ninst✝⁴ : l.IsCountablyGenerated\ninst✝³ : TopologicalSpace γ\ninst✝² : SecondCountableTopology γ\ninst✝¹ : TopologicalSpace.PseudoMetrizableSpace γ\ninst✝ : OpensMeasurableSpace γ\nf : ι → β → γ\nhf : ∀ (i : ι), Measurable (f i)\ng : β → γ\nhg : Measurable g\n⊢ MeasurableSet (setOf fun x => Filter.Tendsto (fun n => f n x) l (nhds (g x)))","decl":"/-- The set of points for which a sequence of measurable functions converges to a given function\nis measurable. -/\n@[measurability]\nlemma measurableSet_tendsto_fun [MeasurableSpace γ] [Countable ι]\n    {l : Filter ι} [l.IsCountablyGenerated]\n    [TopologicalSpace γ] [SecondCountableTopology γ] [PseudoMetrizableSpace γ]\n    [OpensMeasurableSpace γ]\n    {f : ι → β → γ} (hf : ∀ i, Measurable (f i)) {g : β → γ} (hg : Measurable g) :\n    MeasurableSet { x | Tendsto (fun n ↦ f n x) l (𝓝 (g x)) } := by\n  letI := TopologicalSpace.pseudoMetrizableSpacePseudoMetric γ\n  simp_rw [tendsto_iff_dist_tendsto_zero (f := fun n ↦ f n _)]\n  exact measurableSet_tendsto (𝓝 0) (fun n ↦ (hf n).dist hg)\n\n"}
{"name":"MeasureTheory.measurableSet_exists_tendsto","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"ι : Type u_2\nγ : Type u_3\nβ : Type u_5\ninst✝⁵ : MeasurableSpace β\ninst✝⁴ : TopologicalSpace γ\ninst✝³ : PolishSpace γ\ninst✝² : MeasurableSpace γ\nhγ : OpensMeasurableSpace γ\ninst✝¹ : Countable ι\nl : Filter ι\ninst✝ : l.IsCountablyGenerated\nf : ι → β → γ\nhf : ∀ (i : ι), Measurable (f i)\n⊢ MeasurableSet (setOf fun x => Exists fun c => Filter.Tendsto (fun n => f n x) l (nhds c))","decl":"/-- The set of points for which a measurable sequence of functions converges is measurable. -/\n@[measurability]\ntheorem measurableSet_exists_tendsto [TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ]\n    [hγ : OpensMeasurableSpace γ] [Countable ι] {l : Filter ι}\n    [l.IsCountablyGenerated] {f : ι → β → γ} (hf : ∀ i, Measurable (f i)) :\n    MeasurableSet { x | ∃ c, Tendsto (fun n => f n x) l (𝓝 c) } := by\n  rcases l.eq_or_neBot with rfl | hl\n  · simp\n  letI := upgradePolishSpace γ\n  rcases l.exists_antitone_basis with ⟨u, hu⟩\n  simp_rw [← cauchy_map_iff_exists_tendsto]\n  change MeasurableSet { x | _ ∧ _ }\n  have : ∀ x, (map (f · x) l ×ˢ map (f · x) l).HasAntitoneBasis fun n =>\n      ((f · x) '' u n) ×ˢ ((f · x) '' u n) := fun x => (hu.map _).prod (hu.map _)\n  simp_rw [and_iff_right (hl.map _),\n    Filter.HasBasis.le_basis_iff (this _).toHasBasis Metric.uniformity_basis_dist_inv_nat_succ,\n    Set.setOf_forall]\n  refine MeasurableSet.biInter Set.countable_univ fun K _ => ?_\n  simp_rw [Set.setOf_exists, true_and]\n  refine MeasurableSet.iUnion fun N => ?_\n  simp_rw [prod_image_image_eq, image_subset_iff, prod_subset_iff, Set.setOf_forall]\n  exact\n    MeasurableSet.biInter (to_countable (u N)) fun i _ =>\n      MeasurableSet.biInter (to_countable (u N)) fun j _ =>\n        measurableSet_lt (Measurable.dist (hf i) (hf j)) measurable_const\n\n"}
{"name":"MeasurableSet.isClopenable'","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : StandardBorelSpace α\ns : Set α\nhs : MeasurableSet s\n⊢ Exists fun x => And (BorelSpace α) (And (PolishSpace α) (And (IsClosed s) (IsOpen s)))","decl":"/-- If `s` is a measurable set in a standard Borel space, there is a compatible Polish topology\nmaking `s` clopen. -/\ntheorem _root_.MeasurableSet.isClopenable' {s : Set α} (hs : MeasurableSet s) :\n    ∃ _ : TopologicalSpace α, BorelSpace α ∧ PolishSpace α ∧ IsClosed s ∧ IsOpen s := by\n  letI := upgradeStandardBorel α\n  obtain ⟨t, hle, ht, s_clopen⟩ := hs.isClopenable\n  refine ⟨t, ?_, ht, s_clopen⟩\n  constructor\n  rw [eq_borel_upgradeStandardBorel α, borel_eq_borel_of_le ht _ hle]\n  infer_instance\n\n"}
{"name":"MeasurableSet.standardBorel","module":"Mathlib.MeasureTheory.Constructions.Polish.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : StandardBorelSpace α\ns : Set α\nhs : MeasurableSet s\n⊢ StandardBorelSpace ↑s","decl":"/-- A measurable subspace of a standard Borel space is standard Borel. -/\ntheorem _root_.MeasurableSet.standardBorel {s : Set α} (hs : MeasurableSet s) :\n    StandardBorelSpace s := by\n  obtain ⟨_, _, _, s_closed, _⟩ := hs.isClopenable'\n  haveI := s_closed.polishSpace\n  infer_instance\n\n"}
