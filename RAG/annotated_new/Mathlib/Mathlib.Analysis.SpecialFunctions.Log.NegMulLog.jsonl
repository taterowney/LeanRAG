{"name":"Real.continuous_mul_log","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ Continuous fun x => HMul.hMul x (Real.log x)","decl":"@[fun_prop]\nlemma continuous_mul_log : Continuous fun x ‚Ü¶ x * log x := by\n  rw [continuous_iff_continuousAt]\n  intro x\n  obtain hx | rfl := ne_or_eq x 0\n  ¬∑ exact (continuous_id'.continuousAt).mul (continuousAt_log hx)\n  rw [ContinuousAt, zero_mul]\n  simp_rw [mul_comm _ (log _)]\n  nth_rewrite 1 [‚Üê nhdsWithin_univ]\n  have : (Set.univ : Set ‚Ñù) = Set.Iio 0 ‚à™ Set.Ioi 0 ‚à™ {0} := by ext; simp [em]\n  rw [this, nhdsWithin_union, nhdsWithin_union]\n  simp only [nhdsWithin_singleton, sup_le_iff, Filter.nonpos_iff, Filter.tendsto_sup]\n  refine ‚ü®‚ü®tendsto_log_mul_self_nhds_zero_left, ?_‚ü©, ?_‚ü©\n  ¬∑ simpa only [rpow_one] using tendsto_log_mul_rpow_nhds_zero zero_lt_one\n  ¬∑ convert tendsto_pure_nhds (fun x ‚Ü¶ log x * x) 0\n    simp\n\n"}
{"name":"Real.Continuous.mul_log","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\nhf : Continuous f\n‚ä¢ Continuous fun a => HMul.hMul (f a) (Real.log (f a))","decl":"@[fun_prop]\nlemma Continuous.mul_log {Œ± : Type*} [TopologicalSpace Œ±] {f : Œ± ‚Üí ‚Ñù} (hf : Continuous f) :\n    Continuous fun a ‚Ü¶ f a * log (f a) := continuous_mul_log.comp hf\n\n"}
{"name":"Real.differentiableOn_mul_log","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ DifferentiableOn Real (fun x => HMul.hMul x (Real.log x)) (HasCompl.compl (Singleton.singleton 0))","decl":"lemma differentiableOn_mul_log : DifferentiableOn ‚Ñù (fun x ‚Ü¶ x * log x) {0}·∂ú :=\n  differentiable_id'.differentiableOn.mul differentiableOn_log\n\n"}
{"name":"Real.deriv_mul_log","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ Eq (deriv (fun x => HMul.hMul x (Real.log x)) x) (HAdd.hAdd (Real.log x) 1)","decl":"lemma deriv_mul_log {x : ‚Ñù} (hx : x ‚â† 0) : deriv (fun x ‚Ü¶ x * log x) x = log x + 1 := by\n  rw [deriv_mul differentiableAt_id' (differentiableAt_log hx)]\n  simp only [deriv_id'', one_mul, deriv_log', ne_eq, add_right_inj]\n  exact mul_inv_cancel‚ÇÄ hx\n\n"}
{"name":"Real.hasDerivAt_mul_log","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ HasDerivAt (fun x => HMul.hMul x (Real.log x)) (HAdd.hAdd (Real.log x) 1) x","decl":"lemma hasDerivAt_mul_log {x : ‚Ñù} (hx : x ‚â† 0) : HasDerivAt (fun x ‚Ü¶ x * log x) (log x + 1) x := by\n  rw [‚Üê deriv_mul_log hx, hasDerivAt_deriv_iff]\n  refine DifferentiableOn.differentiableAt differentiableOn_mul_log ?_\n  simp [hx]\n\n"}
{"name":"Real.not_DifferentiableAt_log_mul_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ Not (DifferentiableAt Real (fun x => HMul.hMul x (Real.log x)) 0)","decl":"/-- At `x=0`, `(fun x ‚Ü¶ x * log x)` is not differentiable\n(but note that it is continuous, see `continuous_mul_log`). -/\nlemma not_DifferentiableAt_log_mul_zero :\n    ¬¨ DifferentiableAt ‚Ñù (fun x ‚Ü¶ x * log x) 0 := fun h ‚Ü¶\n  (not_differentiableWithinAt_of_deriv_tendsto_atBot_Ioi (fun x : ‚Ñù ‚Ü¶ x * log x) (a := 0))\n    tendsto_deriv_mul_log_nhdsWithin_zero\n    (h.differentiableWithinAt (s := Set.Ioi 0))\n\n"}
{"name":"Real.deriv_mul_log_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ Eq (deriv (fun x => HMul.hMul x (Real.log x)) 0) 0","decl":"/-- Not differentiable, hence `deriv` has junk value zero. -/\nlemma deriv_mul_log_zero : deriv (fun x ‚Ü¶ x * log x) 0 = 0 :=\n  deriv_zero_of_not_differentiableAt not_DifferentiableAt_log_mul_zero\n\n"}
{"name":"Real.not_continuousAt_deriv_mul_log_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ Not (ContinuousAt (deriv fun x => HMul.hMul x (Real.log x)) 0)","decl":"lemma not_continuousAt_deriv_mul_log_zero :\n    ¬¨ ContinuousAt (deriv (fun (x : ‚Ñù) ‚Ü¶ x * log x)) 0 :=\n  not_continuousAt_of_tendsto tendsto_deriv_mul_log_nhdsWithin_zero nhdsWithin_le_nhds (by simp)\n\n"}
{"name":"Real.deriv2_mul_log","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\n‚ä¢ Eq (Nat.iterate deriv 2 (fun x => HMul.hMul x (Real.log x)) x) (Inv.inv x)","decl":"lemma deriv2_mul_log (x : ‚Ñù) : deriv^[2] (fun x ‚Ü¶ x * log x) x = x‚Åª¬π := by\n  simp only [Function.iterate_succ, Function.iterate_zero, Function.id_comp, Function.comp_apply]\n  by_cases hx : x = 0\n  ¬∑ rw [hx, inv_zero]\n    exact deriv_zero_of_not_differentiableAt\n      (fun h ‚Ü¶ not_continuousAt_deriv_mul_log_zero h.continuousAt)\n  ¬∑ suffices ‚àÄ·∂† y in (ùìù x), deriv (fun x ‚Ü¶ x * log x) y = log y + 1 by\n      refine (Filter.EventuallyEq.deriv_eq this).trans ?_\n      rw [deriv_add_const, deriv_log x]\n    filter_upwards [eventually_ne_nhds hx] with y hy using deriv_mul_log hy\n\n"}
{"name":"Real.strictConvexOn_mul_log","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ StrictConvexOn Real (Set.Ici 0) fun x => HMul.hMul x (Real.log x)","decl":"lemma strictConvexOn_mul_log : StrictConvexOn ‚Ñù (Set.Ici (0 : ‚Ñù)) (fun x ‚Ü¶ x * log x) := by\n  refine strictConvexOn_of_deriv2_pos (convex_Ici 0) (continuous_mul_log.continuousOn) ?_\n  intro x hx\n  simp only [Set.nonempty_Iio, interior_Ici', Set.mem_Ioi] at hx\n  rw [deriv2_mul_log]\n  positivity\n\n"}
{"name":"Real.convexOn_mul_log","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ ConvexOn Real (Set.Ici 0) fun x => HMul.hMul x (Real.log x)","decl":"lemma convexOn_mul_log : ConvexOn ‚Ñù (Set.Ici (0 : ‚Ñù)) (fun x ‚Ü¶ x * log x) :=\n  strictConvexOn_mul_log.convexOn\n\n"}
{"name":"Real.mul_log_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\nhx : LE.le 1 x\n‚ä¢ LE.le 0 (HMul.hMul x (Real.log x))","decl":"lemma mul_log_nonneg {x : ‚Ñù} (hx : 1 ‚â§ x) : 0 ‚â§ x * log x :=\n  mul_nonneg (zero_le_one.trans hx) (log_nonneg hx)\n\n"}
{"name":"Real.mul_log_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\nhx‚ÇÄ : LE.le 0 x\nhx‚ÇÅ : LE.le x 1\n‚ä¢ LE.le (HMul.hMul x (Real.log x)) 0","decl":"lemma mul_log_nonpos {x : ‚Ñù} (hx‚ÇÄ : 0 ‚â§ x) (hx‚ÇÅ : x ‚â§ 1) : x * log x ‚â§ 0 :=\n  mul_nonpos_of_nonneg_of_nonpos hx‚ÇÄ (log_nonpos hx‚ÇÄ hx‚ÇÅ)\n\n"}
{"name":"Real.negMulLog_def","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ Eq Real.negMulLog fun x => HMul.hMul (Neg.neg x) (Real.log x)","decl":"lemma negMulLog_def : negMulLog = fun x ‚Ü¶ - x * log x := rfl\n\n"}
{"name":"Real.negMulLog_eq_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ Eq Real.negMulLog fun x => Neg.neg (HMul.hMul x (Real.log x))","decl":"lemma negMulLog_eq_neg : negMulLog = fun x ‚Ü¶ - (x * log x) := by simp [negMulLog_def]\n\n"}
{"name":"Real.negMulLog_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ Eq (Real.negMulLog 0) 0","decl":"@[simp] lemma negMulLog_zero : negMulLog (0 : ‚Ñù) = 0 := by simp [negMulLog]\n\n"}
{"name":"Real.negMulLog_one","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ Eq (Real.negMulLog 1) 0","decl":"@[simp] lemma negMulLog_one : negMulLog (1 : ‚Ñù) = 0 := by simp [negMulLog]\n\n"}
{"name":"Real.negMulLog_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\nh1 : LE.le 0 x\nh2 : LE.le x 1\n‚ä¢ LE.le 0 x.negMulLog","decl":"lemma negMulLog_nonneg {x : ‚Ñù} (h1 : 0 ‚â§ x) (h2 : x ‚â§ 1) : 0 ‚â§ negMulLog x := by\n  simpa only [negMulLog_eq_neg, neg_nonneg] using mul_log_nonpos h1 h2\n\n"}
{"name":"Real.negMulLog_mul","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x y : Real\n‚ä¢ Eq (HMul.hMul x y).negMulLog (HAdd.hAdd (HMul.hMul y x.negMulLog) (HMul.hMul x y.negMulLog))","decl":"lemma negMulLog_mul (x y : ‚Ñù) : negMulLog (x * y) = y * negMulLog x + x * negMulLog y := by\n  simp only [negMulLog, neg_mul, neg_add_rev]\n  by_cases hx : x = 0\n  ¬∑ simp [hx]\n  by_cases hy : y = 0\n  ¬∑ simp [hy]\n  rw [log_mul hx hy]\n  ring\n\n"}
{"name":"Real.continuous_negMulLog","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ Continuous Real.negMulLog","decl":"@[fun_prop] lemma continuous_negMulLog : Continuous negMulLog := by\n  simpa only [negMulLog_eq_neg] using continuous_mul_log.neg\n\n"}
{"name":"Real.differentiableOn_negMulLog","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ DifferentiableOn Real Real.negMulLog (HasCompl.compl (Singleton.singleton 0))","decl":"lemma differentiableOn_negMulLog : DifferentiableOn ‚Ñù negMulLog {0}·∂ú := by\n  simpa only [negMulLog_eq_neg] using differentiableOn_mul_log.neg\n\n"}
{"name":"Real.differentiableAt_negMulLog_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\n‚ä¢ Iff (DifferentiableAt Real Real.negMulLog x) (Ne x 0)","decl":"lemma differentiableAt_negMulLog_iff {x : ‚Ñù} : DifferentiableAt ‚Ñù negMulLog x ‚Üî x ‚â† 0 := by\n  constructor\n  ¬∑ unfold negMulLog\n    intro h eq0\n    simp only [neg_mul, differentiableAt_neg_iff, eq0] at h\n    exact not_DifferentiableAt_log_mul_zero h\n  ¬∑ intro hx\n    have : x ‚àà ({0} : Set ‚Ñù)·∂ú := by\n      simp_all only [ne_eq, Set.mem_compl_iff, Set.mem_singleton_iff, not_false_eq_true]\n    have := differentiableOn_negMulLog x this\n    apply DifferentiableWithinAt.differentiableAt (s := {0}·∂ú) <;>\n    simp_all only [ne_eq, Set.mem_compl_iff, Set.mem_singleton_iff, not_false_eq_true,\n      compl_singleton_mem_nhds_iff]\n\n"}
{"name":"Real.differentiableAt_negMulLog","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\na‚úù : Ne x 0\n‚ä¢ DifferentiableAt Real Real.negMulLog x","decl":"@[fun_prop] alias ‚ü®_, differentiableAt_negMulLog‚ü© := differentiableAt_negMulLog_iff\n\n"}
{"name":"Real.deriv_negMulLog","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ Eq (deriv Real.negMulLog x) (HSub.hSub (Neg.neg (Real.log x)) 1)","decl":"lemma deriv_negMulLog {x : ‚Ñù} (hx : x ‚â† 0) : deriv negMulLog x = - log x - 1 := by\n  rw [negMulLog_eq_neg, deriv.neg, deriv_mul_log hx]\n  ring\n\n"}
{"name":"Real.hasDerivAt_negMulLog","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ HasDerivAt Real.negMulLog (HSub.hSub (Neg.neg (Real.log x)) 1) x","decl":"lemma hasDerivAt_negMulLog {x : ‚Ñù} (hx : x ‚â† 0) : HasDerivAt negMulLog (- log x - 1) x := by\n  rw [‚Üê deriv_negMulLog hx, hasDerivAt_deriv_iff]\n  refine DifferentiableOn.differentiableAt differentiableOn_negMulLog ?_\n  simp [hx]\n\n"}
{"name":"Real.deriv2_negMulLog","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"x : Real\n‚ä¢ Eq (Nat.iterate deriv 2 Real.negMulLog x) (Neg.neg (Inv.inv x))","decl":"lemma deriv2_negMulLog (x : ‚Ñù) : deriv^[2] negMulLog x = - x‚Åª¬π := by\n  rw [negMulLog_eq_neg]\n  have h := deriv2_mul_log\n  simp only [Function.iterate_succ, Function.iterate_zero, Function.id_comp,\n    Function.comp_apply, deriv.neg', differentiableAt_id', differentiableAt_log_iff, ne_eq] at h ‚ä¢\n  rw [h]\n\n"}
{"name":"Real.strictConcaveOn_negMulLog","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ StrictConcaveOn Real (Set.Ici 0) Real.negMulLog","decl":"lemma strictConcaveOn_negMulLog : StrictConcaveOn ‚Ñù (Set.Ici (0 : ‚Ñù)) negMulLog := by\n  simpa only [negMulLog_eq_neg] using strictConvexOn_mul_log.neg\n\n"}
{"name":"Real.concaveOn_negMulLog","module":"Mathlib.Analysis.SpecialFunctions.Log.NegMulLog","initialProofState":"‚ä¢ ConcaveOn Real (Set.Ici 0) Real.negMulLog","decl":"lemma concaveOn_negMulLog : ConcaveOn ‚Ñù (Set.Ici (0 : ‚Ñù)) negMulLog :=\n  strictConcaveOn_negMulLog.concaveOn\n\n"}
