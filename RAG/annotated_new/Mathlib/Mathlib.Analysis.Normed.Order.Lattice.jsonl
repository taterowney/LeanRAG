{"name":"HasSolidNorm.solid","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : NormedAddCommGroup α\ninst✝ : Lattice α\nself : HasSolidNorm α\nx y : α\na✝ : LE.le (abs x) (abs y)\n⊢ LE.le (Norm.norm x) (Norm.norm y)","decl":"/-- Let `α` be an `AddCommGroup` with a `Lattice` structure. A norm on `α` is *solid* if, for `a`\nand `b` in `α`, with absolute values `|a|` and `|b|` respectively, `|a| ≤ |b|` implies `‖a‖ ≤ ‖b‖`.\n-/\nclass HasSolidNorm (α : Type*) [NormedAddCommGroup α] [Lattice α] : Prop where\n  solid : ∀ ⦃x y : α⦄, |x| ≤ |y| → ‖x‖ ≤ ‖y‖\n\n"}
{"name":"norm_le_norm_of_abs_le_abs","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝² : NormedAddCommGroup α\ninst✝¹ : Lattice α\ninst✝ : HasSolidNorm α\na b : α\nh : LE.le (abs a) (abs b)\n⊢ LE.le (Norm.norm a) (Norm.norm b)","decl":"theorem norm_le_norm_of_abs_le_abs {a b : α} (h : |a| ≤ |b|) : ‖a‖ ≤ ‖b‖ :=\n  HasSolidNorm.solid h\n\n"}
{"name":"LatticeOrderedAddCommGroup.isSolid_ball","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝² : NormedAddCommGroup α\ninst✝¹ : Lattice α\ninst✝ : HasSolidNorm α\nr : Real\n⊢ LatticeOrderedAddCommGroup.IsSolid (Metric.ball 0 r)","decl":"/-- If `α` has a solid norm, then the balls centered at the origin of `α` are solid sets. -/\ntheorem LatticeOrderedAddCommGroup.isSolid_ball (r : ℝ) :\n    LatticeOrderedAddCommGroup.IsSolid (Metric.ball (0 : α) r) := fun _ hx _ hxy =>\n  mem_ball_zero_iff.mpr ((HasSolidNorm.solid hxy).trans_lt (mem_ball_zero_iff.mp hx))\n\n"}
{"name":"instHasSolidNormReal","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"⊢ HasSolidNorm Real","decl":"instance : HasSolidNorm ℝ := ⟨fun _ _ => id⟩\n\n"}
{"name":"instHasSolidNormRat","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"⊢ HasSolidNorm Rat","decl":"instance : HasSolidNorm ℚ := ⟨fun _ _ _ => by simpa only [norm, ← Rat.cast_abs, Rat.cast_le]⟩\n\n"}
{"name":"NormedLatticeAddCommGroup.toHasSolidNorm","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\nself : NormedLatticeAddCommGroup α\n⊢ HasSolidNorm α","decl":"/--\nLet `α` be a normed commutative group equipped with a partial order covariant with addition, with\nrespect which `α` forms a lattice. Suppose that `α` is *solid*, that is to say, for `a` and `b` in\n`α`, with absolute values `|a|` and `|b|` respectively, `|a| ≤ |b|` implies `‖a‖ ≤ ‖b‖`. Then `α` is\nsaid to be a normed lattice ordered group.\n-/\nclass NormedLatticeAddCommGroup (α : Type*) extends\n    NormedAddCommGroup α, Lattice α, HasSolidNorm α where\n  add_le_add_left : ∀ a b : α, a ≤ b → ∀ c : α, c + a ≤ c + b\n\n"}
{"name":"NormedLatticeAddCommGroup.add_le_add_left","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\nself : NormedLatticeAddCommGroup α\na b : α\na✝ : LE.le a b\nc : α\n⊢ LE.le (HAdd.hAdd c a) (HAdd.hAdd c b)","decl":"/--\nLet `α` be a normed commutative group equipped with a partial order covariant with addition, with\nrespect which `α` forms a lattice. Suppose that `α` is *solid*, that is to say, for `a` and `b` in\n`α`, with absolute values `|a|` and `|b|` respectively, `|a| ≤ |b|` implies `‖a‖ ≤ ‖b‖`. Then `α` is\nsaid to be a normed lattice ordered group.\n-/\nclass NormedLatticeAddCommGroup (α : Type*) extends\n    NormedAddCommGroup α, Lattice α, HasSolidNorm α where\n  add_le_add_left : ∀ a b : α, a ≤ b → ∀ c : α, c + a ≤ c + b\n\n"}
{"name":"dual_solid","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\na b : α\nh : LE.le (Min.min b (Neg.neg b)) (Min.min a (Neg.neg a))\n⊢ LE.le (Norm.norm a) (Norm.norm b)","decl":"theorem dual_solid (a b : α) (h : b ⊓ -b ≤ a ⊓ -a) : ‖a‖ ≤ ‖b‖ := by\n  apply solid\n  rw [abs]\n  nth_rw 1 [← neg_neg a]\n  rw [← neg_inf]\n  rw [abs]\n  nth_rw 1 [← neg_neg b]\n  rwa [← neg_inf, neg_le_neg_iff, inf_comm _ b, inf_comm _ a]\n\n-- see Note [lower instance priority]\n"}
{"name":"norm_abs_eq_norm","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\na : α\n⊢ Eq (Norm.norm (abs a)) (Norm.norm a)","decl":"theorem norm_abs_eq_norm (a : α) : ‖|a|‖ = ‖a‖ :=\n  (solid (abs_abs a).le).antisymm (solid (abs_abs a).symm.le)\n\n"}
{"name":"norm_inf_sub_inf_le_add_norm","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\na b c d : α\n⊢ LE.le (Norm.norm (HSub.hSub (Min.min a b) (Min.min c d))) (HAdd.hAdd (Norm.norm (HSub.hSub a c)) (Norm.norm (HSub.hSub b d)))","decl":"theorem norm_inf_sub_inf_le_add_norm (a b c d : α) : ‖a ⊓ b - c ⊓ d‖ ≤ ‖a - c‖ + ‖b - d‖ := by\n  rw [← norm_abs_eq_norm (a - c), ← norm_abs_eq_norm (b - d)]\n  refine le_trans (solid ?_) (norm_add_le |a - c| |b - d|)\n  rw [abs_of_nonneg (add_nonneg (abs_nonneg (a - c)) (abs_nonneg (b - d)))]\n  calc\n    |a ⊓ b - c ⊓ d| = |a ⊓ b - c ⊓ b + (c ⊓ b - c ⊓ d)| := by rw [sub_add_sub_cancel]\n    _ ≤ |a ⊓ b - c ⊓ b| + |c ⊓ b - c ⊓ d| := abs_add_le _ _\n    _ ≤ |a - c| + |b - d| := by\n      apply add_le_add\n      · exact abs_inf_sub_inf_le_abs _ _ _\n      · rw [inf_comm c, inf_comm c]\n        exact abs_inf_sub_inf_le_abs _ _ _\n\n"}
{"name":"norm_sup_sub_sup_le_add_norm","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\na b c d : α\n⊢ LE.le (Norm.norm (HSub.hSub (Max.max a b) (Max.max c d))) (HAdd.hAdd (Norm.norm (HSub.hSub a c)) (Norm.norm (HSub.hSub b d)))","decl":"theorem norm_sup_sub_sup_le_add_norm (a b c d : α) : ‖a ⊔ b - c ⊔ d‖ ≤ ‖a - c‖ + ‖b - d‖ := by\n  rw [← norm_abs_eq_norm (a - c), ← norm_abs_eq_norm (b - d)]\n  refine le_trans (solid ?_) (norm_add_le |a - c| |b - d|)\n  rw [abs_of_nonneg (add_nonneg (abs_nonneg (a - c)) (abs_nonneg (b - d)))]\n  calc\n    |a ⊔ b - c ⊔ d| = |a ⊔ b - c ⊔ b + (c ⊔ b - c ⊔ d)| := by rw [sub_add_sub_cancel]\n    _ ≤ |a ⊔ b - c ⊔ b| + |c ⊔ b - c ⊔ d| := abs_add_le _ _\n    _ ≤ |a - c| + |b - d| := by\n      apply add_le_add\n      · exact abs_sup_sub_sup_le_abs _ _ _\n      · rw [sup_comm c, sup_comm c]\n        exact abs_sup_sub_sup_le_abs _ _ _\n\n"}
{"name":"norm_inf_le_add","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\nx y : α\n⊢ LE.le (Norm.norm (Min.min x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y))","decl":"theorem norm_inf_le_add (x y : α) : ‖x ⊓ y‖ ≤ ‖x‖ + ‖y‖ := by\n  have h : ‖x ⊓ y - 0 ⊓ 0‖ ≤ ‖x - 0‖ + ‖y - 0‖ := norm_inf_sub_inf_le_add_norm x y 0 0\n  simpa only [inf_idem, sub_zero] using h\n\n"}
{"name":"norm_sup_le_add","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\nx y : α\n⊢ LE.le (Norm.norm (Max.max x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y))","decl":"theorem norm_sup_le_add (x y : α) : ‖x ⊔ y‖ ≤ ‖x‖ + ‖y‖ := by\n  have h : ‖x ⊔ y - 0 ⊔ 0‖ ≤ ‖x - 0‖ + ‖y - 0‖ := norm_sup_sub_sup_le_add_norm x y 0 0\n  simpa only [sup_idem, sub_zero] using h\n\n-- see Note [lower instance priority]\n"}
{"name":"NormedLatticeAddCommGroup.continuousInf","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\n⊢ ContinuousInf α","decl":"/-- Let `α` be a normed lattice ordered group. Then the infimum is jointly continuous.\n-/\ninstance (priority := 100) NormedLatticeAddCommGroup.continuousInf : ContinuousInf α := by\n  refine ⟨continuous_iff_continuousAt.2 fun q => tendsto_iff_norm_sub_tendsto_zero.2 <| ?_⟩\n  have : ∀ p : α × α, ‖p.1 ⊓ p.2 - q.1 ⊓ q.2‖ ≤ ‖p.1 - q.1‖ + ‖p.2 - q.2‖ := fun _ =>\n    norm_inf_sub_inf_le_add_norm _ _ _ _\n  refine squeeze_zero (fun e => norm_nonneg _) this ?_\n  convert ((continuous_fst.tendsto q).sub <| tendsto_const_nhds).norm.add\n    ((continuous_snd.tendsto q).sub <| tendsto_const_nhds).norm\n  simp\n\n-- see Note [lower instance priority]\n"}
{"name":"NormedLatticeAddCommGroup.continuousSup","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_2\ninst✝ : NormedLatticeAddCommGroup α\n⊢ ContinuousSup α","decl":"instance (priority := 100) NormedLatticeAddCommGroup.continuousSup {α : Type*}\n    [NormedLatticeAddCommGroup α] : ContinuousSup α :=\n  OrderDual.continuousSup αᵒᵈ\n\n-- see Note [lower instance priority]\n"}
{"name":"NormedLatticeAddCommGroup.toTopologicalLattice","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\n⊢ TopologicalLattice α","decl":"/--\nLet `α` be a normed lattice ordered group. Then `α` is a topological lattice in the norm topology.\n-/\ninstance (priority := 100) NormedLatticeAddCommGroup.toTopologicalLattice : TopologicalLattice α :=\n  TopologicalLattice.mk\n\n"}
{"name":"norm_abs_sub_abs","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\na b : α\n⊢ LE.le (Norm.norm (HSub.hSub (abs a) (abs b))) (Norm.norm (HSub.hSub a b))","decl":"theorem norm_abs_sub_abs (a b : α) : ‖|a| - |b|‖ ≤ ‖a - b‖ := solid (abs_abs_sub_abs_le _ _)\n\n"}
{"name":"norm_sup_sub_sup_le_norm","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\nx y z : α\n⊢ LE.le (Norm.norm (HSub.hSub (Max.max x z) (Max.max y z))) (Norm.norm (HSub.hSub x y))","decl":"theorem norm_sup_sub_sup_le_norm (x y z : α) : ‖x ⊔ z - y ⊔ z‖ ≤ ‖x - y‖ :=\n  solid (abs_sup_sub_sup_le_abs x y z)\n\n"}
{"name":"norm_inf_sub_inf_le_norm","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\nx y z : α\n⊢ LE.le (Norm.norm (HSub.hSub (Min.min x z) (Min.min y z))) (Norm.norm (HSub.hSub x y))","decl":"theorem norm_inf_sub_inf_le_norm (x y z : α) : ‖x ⊓ z - y ⊓ z‖ ≤ ‖x - y‖ :=\n  solid (abs_inf_sub_inf_le_abs x y z)\n\n"}
{"name":"lipschitzWith_sup_right","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\nz : α\n⊢ LipschitzWith 1 fun x => Max.max x z","decl":"theorem lipschitzWith_sup_right (z : α) : LipschitzWith 1 fun x => x ⊔ z :=\n  LipschitzWith.of_dist_le_mul fun x y => by\n    rw [NNReal.coe_one, one_mul, dist_eq_norm, dist_eq_norm]\n    exact norm_sup_sub_sup_le_norm x y z\n\n"}
{"name":"lipschitzWith_posPart","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\n⊢ LipschitzWith 1 PosPart.posPart","decl":"lemma lipschitzWith_posPart : LipschitzWith 1 (posPart : α → α) :=\n  lipschitzWith_sup_right 0\n\n"}
{"name":"lipschitzWith_negPart","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\n⊢ LipschitzWith 1 NegPart.negPart","decl":"lemma lipschitzWith_negPart : LipschitzWith 1 (negPart : α → α) := by\n  simpa [Function.comp] using lipschitzWith_posPart.comp LipschitzWith.id.neg\n\n"}
{"name":"continuous_posPart","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\n⊢ Continuous PosPart.posPart","decl":"@[fun_prop]\nlemma continuous_posPart : Continuous (posPart : α → α) := lipschitzWith_posPart.continuous\n\n"}
{"name":"continuous_negPart","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\n⊢ Continuous NegPart.negPart","decl":"@[fun_prop]\nlemma continuous_negPart : Continuous (negPart : α → α) := lipschitzWith_negPart.continuous\n\n"}
{"name":"isClosed_nonneg","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"α : Type u_1\ninst✝ : NormedLatticeAddCommGroup α\n⊢ IsClosed (setOf fun x => LE.le 0 x)","decl":"lemma isClosed_nonneg : IsClosed {x : α | 0 ≤ x} := by\n  have : {x : α | 0 ≤ x} = negPart ⁻¹' {0} := by ext; simp [negPart_eq_zero]\n  rw [this]\n  exact isClosed_singleton.preimage continuous_negPart\n\n"}
{"name":"isClosed_le_of_isClosed_nonneg","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"G : Type u_2\ninst✝² : OrderedAddCommGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : ContinuousSub G\nh : IsClosed (setOf fun x => LE.le 0 x)\n⊢ IsClosed (setOf fun p => LE.le p.1 p.2)","decl":"theorem isClosed_le_of_isClosed_nonneg {G} [OrderedAddCommGroup G] [TopologicalSpace G]\n    [ContinuousSub G] (h : IsClosed { x : G | 0 ≤ x }) :\n    IsClosed { p : G × G | p.fst ≤ p.snd } := by\n  have : { p : G × G | p.fst ≤ p.snd } = (fun p : G × G => p.snd - p.fst) ⁻¹' { x : G | 0 ≤ x } :=\n    by ext1 p; simp only [sub_nonneg, Set.preimage_setOf_eq]\n  rw [this]\n  exact IsClosed.preimage (continuous_snd.sub continuous_fst) h\n\n-- See note [lower instance priority]\n"}
{"name":"NormedLatticeAddCommGroup.orderClosedTopology","module":"Mathlib.Analysis.Normed.Order.Lattice","initialProofState":"E : Type u_2\ninst✝ : NormedLatticeAddCommGroup E\n⊢ OrderClosedTopology E","decl":"instance (priority := 100) NormedLatticeAddCommGroup.orderClosedTopology {E}\n    [NormedLatticeAddCommGroup E] : OrderClosedTopology E :=\n  ⟨isClosed_le_of_isClosed_nonneg isClosed_nonneg⟩\n"}
