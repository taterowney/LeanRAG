{"name":"MvPolynomial.sum_eval_eq_zero","module":"Mathlib.FieldTheory.ChevalleyWarning","initialProofState":"K : Type u_1\nσ : Type u_2\ninst✝³ : Fintype K\ninst✝² : Field K\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\nf : MvPolynomial σ K\nh : LT.lt f.totalDegree (HMul.hMul (HSub.hSub (Fintype.card K) 1) (Fintype.card σ))\n⊢ Eq (Finset.univ.sum fun x => (MvPolynomial.eval x) f) 0","decl":"theorem MvPolynomial.sum_eval_eq_zero (f : MvPolynomial σ K)\n    (h : f.totalDegree < (q - 1) * Fintype.card σ) : ∑ x, eval x f = 0 := by\n  haveI : DecidableEq K := Classical.decEq K\n  calc\n    ∑ x, eval x f = ∑ x : σ → K, ∑ d ∈ f.support, f.coeff d * ∏ i, x i ^ d i := by\n      simp only [eval_eq']\n    _ = ∑ d ∈ f.support, ∑ x : σ → K, f.coeff d * ∏ i, x i ^ d i := sum_comm\n    _ = 0 := sum_eq_zero ?_\n  intro d hd\n  obtain ⟨i, hi⟩ : ∃ i, d i < q - 1 := f.exists_degree_lt (q - 1) h hd\n  calc\n    (∑ x : σ → K, f.coeff d * ∏ i, x i ^ d i) = f.coeff d * ∑ x : σ → K, ∏ i, x i ^ d i :=\n      (mul_sum ..).symm\n    _ = 0 := (mul_eq_zero.mpr ∘ Or.inr) ?_\n  calc\n    (∑ x : σ → K, ∏ i, x i ^ d i) =\n        ∑ x₀ : { j // j ≠ i } → K, ∑ x : { x : σ → K // x ∘ (↑) = x₀ }, ∏ j, (x : σ → K) j ^ d j :=\n      (Fintype.sum_fiberwise _ _).symm\n    _ = 0 := Fintype.sum_eq_zero _ ?_\n  intro x₀\n  let e : K ≃ { x // x ∘ ((↑) : _ → σ) = x₀ } := (Equiv.subtypeEquivCodomain _).symm\n  calc\n    (∑ x : { x : σ → K // x ∘ (↑) = x₀ }, ∏ j, (x : σ → K) j ^ d j) =\n        ∑ a : K, ∏ j : σ, (e a : σ → K) j ^ d j := (e.sum_comp _).symm\n    _ = ∑ a : K, (∏ j, x₀ j ^ d j) * a ^ d i := Fintype.sum_congr _ _ ?_\n    _ = (∏ j, x₀ j ^ d j) * ∑ a : K, a ^ d i := by rw [mul_sum]\n    _ = 0 := by rw [sum_pow_lt_card_sub_one K _ hi, mul_zero]\n  intro a\n  let e' : { j // j = i } ⊕ { j // j ≠ i } ≃ σ := Equiv.sumCompl _\n  letI : Unique { j // j = i } :=\n    { default := ⟨i, rfl⟩\n      uniq := fun ⟨j, h⟩ => Subtype.val_injective h }\n  calc\n    (∏ j : σ, (e a : σ → K) j ^ d j) =\n        (e a : σ → K) i ^ d i * ∏ j : { j // j ≠ i }, (e a : σ → K) j ^ d j := by\n      rw [← e'.prod_comp, Fintype.prod_sum_type, univ_unique, prod_singleton]; rfl\n    _ = a ^ d i * ∏ j : { j // j ≠ i }, (e a : σ → K) j ^ d j := by\n      rw [Equiv.subtypeEquivCodomain_symm_apply_eq]\n    _ = a ^ d i * ∏ j, x₀ j ^ d j := congr_arg _ (Fintype.prod_congr _ _ ?_)\n    -- see below\n    _ = (∏ j, x₀ j ^ d j) * a ^ d i := mul_comm _ _\n  -- the remaining step of the calculation above\n  rintro ⟨j, hj⟩\n  show (e a : σ → K) j ^ d j = x₀ ⟨j, hj⟩ ^ d j\n  rw [Equiv.subtypeEquivCodomain_symm_apply_ne]\n\n"}
{"name":"char_dvd_card_solutions_of_sum_lt","module":"Mathlib.FieldTheory.ChevalleyWarning","initialProofState":"K : Type u_1\nσ : Type u_2\nι : Type u_3\ninst✝⁵ : Fintype K\ninst✝⁴ : Field K\ninst✝³ : Fintype σ\ninst✝² : DecidableEq σ\ninst✝¹ : DecidableEq K\np : Nat\ninst✝ : CharP K p\ns : Finset ι\nf : ι → MvPolynomial σ K\nh : LT.lt (s.sum fun i => (f i).totalDegree) (Fintype.card σ)\n⊢ Dvd.dvd p (Fintype.card (Subtype fun x => ∀ (i : ι), Membership.mem s i → Eq ((MvPolynomial.eval x) (f i)) 0))","decl":"/-- The **Chevalley–Warning theorem**, finitary version.\nLet `(f i)` be a finite family of multivariate polynomials\nin finitely many variables (`X s`, `s : σ`) over a finite field of characteristic `p`.\nAssume that the sum of the total degrees of the `f i` is less than the cardinality of `σ`.\nThen the number of common solutions of the `f i` is divisible by `p`. -/\ntheorem char_dvd_card_solutions_of_sum_lt {s : Finset ι} {f : ι → MvPolynomial σ K}\n    (h : (∑ i ∈ s, (f i).totalDegree) < Fintype.card σ) :\n    p ∣ Fintype.card { x : σ → K // ∀ i ∈ s, eval x (f i) = 0 } := by\n  have hq : 0 < q - 1 := by rw [← Fintype.card_units, Fintype.card_pos_iff]; exact ⟨1⟩\n  let S : Finset (σ → K) := {x | ∀ i ∈ s, eval x (f i) = 0}\n  have hS (x : σ → K) : x ∈ S ↔ ∀ i ∈ s, eval x (f i) = 0 := by simp [S]\n  /- The polynomial `F = ∏ i ∈ s, (1 - (f i)^(q - 1))` has the nice property\n    that it takes the value `1` on elements of `{x : σ → K // ∀ i ∈ s, (f i).eval x = 0}`\n    while it is `0` outside that locus.\n    Hence the sum of its values is equal to the cardinality of\n    `{x : σ → K // ∀ i ∈ s, (f i).eval x = 0}` modulo `p`. -/\n  let F : MvPolynomial σ K := ∏ i ∈ s, (1 - f i ^ (q - 1))\n  have hF : ∀ x, eval x F = if x ∈ S then 1 else 0 := by\n    intro x\n    calc\n      eval x F = ∏ i ∈ s, eval x (1 - f i ^ (q - 1)) := eval_prod s _ x\n      _ = if x ∈ S then 1 else 0 := ?_\n    simp only [(eval x).map_sub, (eval x).map_pow, (eval x).map_one]\n    split_ifs with hx\n    · apply Finset.prod_eq_one\n      intro i hi\n      rw [hS] at hx\n      rw [hx i hi, zero_pow hq.ne', sub_zero]\n    · obtain ⟨i, hi, hx⟩ : ∃ i ∈ s, eval x (f i) ≠ 0 := by\n        simpa [hS, not_forall, Classical.not_imp] using hx\n      apply Finset.prod_eq_zero hi\n      rw [pow_card_sub_one_eq_one (eval x (f i)) hx, sub_self]\n  -- In particular, we can now show:\n  have key : ∑ x, eval x F = Fintype.card { x : σ → K // ∀ i ∈ s, eval x (f i) = 0 } := by\n    rw [Fintype.card_of_subtype S hS, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one, ←\n      Fintype.sum_extend_by_zero S, sum_congr rfl fun x _ => hF x]\n  -- With these preparations under our belt, we will approach the main goal.\n  show p ∣ Fintype.card { x // ∀ i : ι, i ∈ s → eval x (f i) = 0 }\n  rw [← CharP.cast_eq_zero_iff K, ← key]\n  show (∑ x, eval x F) = 0\n  -- We are now ready to apply the main machine, proven before.\n  apply F.sum_eval_eq_zero\n  -- It remains to verify the crucial assumption of this machine\n  show F.totalDegree < (q - 1) * Fintype.card σ\n  calc\n    F.totalDegree ≤ ∑ i ∈ s, (1 - f i ^ (q - 1)).totalDegree := totalDegree_finset_prod s _\n    _ ≤ ∑ i ∈ s, (q - 1) * (f i).totalDegree := sum_le_sum fun i _ => ?_\n    -- see ↓\n    _ = (q - 1) * ∑ i ∈ s, (f i).totalDegree := (mul_sum ..).symm\n    _ < (q - 1) * Fintype.card σ := by rwa [mul_lt_mul_left hq]\n  -- Now we prove the remaining step from the preceding calculation\n  show (1 - f i ^ (q - 1)).totalDegree ≤ (q - 1) * (f i).totalDegree\n  calc\n    (1 - f i ^ (q - 1)).totalDegree ≤\n        max (1 : MvPolynomial σ K).totalDegree (f i ^ (q - 1)).totalDegree := totalDegree_sub _ _\n    _ ≤ (f i ^ (q - 1)).totalDegree := by simp\n    _ ≤ (q - 1) * (f i).totalDegree := totalDegree_pow _ _\n\n"}
{"name":"char_dvd_card_solutions_of_fintype_sum_lt","module":"Mathlib.FieldTheory.ChevalleyWarning","initialProofState":"K : Type u_1\nσ : Type u_2\nι : Type u_3\ninst✝⁶ : Fintype K\ninst✝⁵ : Field K\ninst✝⁴ : Fintype σ\ninst✝³ : DecidableEq σ\ninst✝² : DecidableEq K\np : Nat\ninst✝¹ : CharP K p\ninst✝ : Fintype ι\nf : ι → MvPolynomial σ K\nh : LT.lt (Finset.univ.sum fun i => (f i).totalDegree) (Fintype.card σ)\n⊢ Dvd.dvd p (Fintype.card (Subtype fun x => ∀ (i : ι), Eq ((MvPolynomial.eval x) (f i)) 0))","decl":"/-- The **Chevalley–Warning theorem**, `Fintype` version.\nLet `(f i)` be a finite family of multivariate polynomials\nin finitely many variables (`X s`, `s : σ`) over a finite field of characteristic `p`.\nAssume that the sum of the total degrees of the `f i` is less than the cardinality of `σ`.\nThen the number of common solutions of the `f i` is divisible by `p`. -/\ntheorem char_dvd_card_solutions_of_fintype_sum_lt [Fintype ι] {f : ι → MvPolynomial σ K}\n    (h : (∑ i, (f i).totalDegree) < Fintype.card σ) :\n    p ∣ Fintype.card { x : σ → K // ∀ i, eval x (f i) = 0 } := by\n  simpa using char_dvd_card_solutions_of_sum_lt p h\n\n"}
{"name":"char_dvd_card_solutions","module":"Mathlib.FieldTheory.ChevalleyWarning","initialProofState":"K : Type u_1\nσ : Type u_2\ninst✝⁵ : Fintype K\ninst✝⁴ : Field K\ninst✝³ : Fintype σ\ninst✝² : DecidableEq σ\ninst✝¹ : DecidableEq K\np : Nat\ninst✝ : CharP K p\nf : MvPolynomial σ K\nh : LT.lt f.totalDegree (Fintype.card σ)\n⊢ Dvd.dvd p (Fintype.card (Subtype fun x => Eq ((MvPolynomial.eval x) f) 0))","decl":"/-- The **Chevalley–Warning theorem**, unary version.\nLet `f` be a multivariate polynomial in finitely many variables (`X s`, `s : σ`)\nover a finite field of characteristic `p`.\nAssume that the total degree of `f` is less than the cardinality of `σ`.\nThen the number of solutions of `f` is divisible by `p`.\nSee `char_dvd_card_solutions_of_sum_lt` for a version that takes a family of polynomials `f i`. -/\ntheorem char_dvd_card_solutions {f : MvPolynomial σ K} (h : f.totalDegree < Fintype.card σ) :\n    p ∣ Fintype.card { x : σ → K // eval x f = 0 } := by\n  let F : Unit → MvPolynomial σ K := fun _ => f\n  have : (∑ i : Unit, (F i).totalDegree) < Fintype.card σ := h\n  -- Porting note: was\n  -- `simpa only [F, Fintype.univ_punit, forall_eq, mem_singleton] using`\n  -- `  char_dvd_card_solutions_of_sum_lt p this`\n  convert char_dvd_card_solutions_of_sum_lt p this\n  aesop\n\n"}
{"name":"char_dvd_card_solutions_of_add_lt","module":"Mathlib.FieldTheory.ChevalleyWarning","initialProofState":"K : Type u_1\nσ : Type u_2\ninst✝⁵ : Fintype K\ninst✝⁴ : Field K\ninst✝³ : Fintype σ\ninst✝² : DecidableEq σ\ninst✝¹ : DecidableEq K\np : Nat\ninst✝ : CharP K p\nf₁ f₂ : MvPolynomial σ K\nh : LT.lt (HAdd.hAdd f₁.totalDegree f₂.totalDegree) (Fintype.card σ)\n⊢ Dvd.dvd p (Fintype.card (Subtype fun x => And (Eq ((MvPolynomial.eval x) f₁) 0) (Eq ((MvPolynomial.eval x) f₂) 0)))","decl":"/-- The **Chevalley–Warning theorem**, binary version.\nLet `f₁`, `f₂` be two multivariate polynomials in finitely many variables (`X s`, `s : σ`) over a\nfinite field of characteristic `p`.\nAssume that the sum of the total degrees of `f₁` and `f₂` is less than the cardinality of `σ`.\nThen the number of common solutions of the `f₁` and `f₂` is divisible by `p`. -/\ntheorem char_dvd_card_solutions_of_add_lt {f₁ f₂ : MvPolynomial σ K}\n    (h : f₁.totalDegree + f₂.totalDegree < Fintype.card σ) :\n    p ∣ Fintype.card { x : σ → K // eval x f₁ = 0 ∧ eval x f₂ = 0 } := by\n  let F : Bool → MvPolynomial σ K := fun b => cond b f₂ f₁\n  have : (∑ b : Bool, (F b).totalDegree) < Fintype.card σ := (add_comm _ _).trans_lt h\n  simpa only [Bool.forall_bool] using char_dvd_card_solutions_of_fintype_sum_lt p this\n\n"}
