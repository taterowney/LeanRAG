{"name":"Preord.coe_of","module":"Mathlib.Order.Category.Preord","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (↑(Preord.of α)) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [Preorder α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"Preord.Iso.mk_inv","module":"Mathlib.Order.Category.Preord","initialProofState":"α β : Preord\ne : OrderIso ↑α ↑β\n⊢ Eq (Preord.Iso.mk e).inv ↑e.symm","decl":"/-- Constructs an equivalence between preorders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : Preord.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : OrderHom α β)\n  inv := (e.symm : OrderHom β α)\n  hom_inv_id := by\n    ext x\n    exact e.symm_apply_apply x\n  inv_hom_id := by\n    ext x\n    exact e.apply_symm_apply x\n\n"}
{"name":"Preord.Iso.mk_hom","module":"Mathlib.Order.Category.Preord","initialProofState":"α β : Preord\ne : OrderIso ↑α ↑β\n⊢ Eq (Preord.Iso.mk e).hom ↑e","decl":"/-- Constructs an equivalence between preorders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : Preord.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : OrderHom α β)\n  inv := (e.symm : OrderHom β α)\n  hom_inv_id := by\n    ext x\n    exact e.symm_apply_apply x\n  inv_hom_id := by\n    ext x\n    exact e.apply_symm_apply x\n\n"}
{"name":"Preord.dual_map","module":"Mathlib.Order.Category.Preord","initialProofState":"X✝ Y✝ : Preord\na : OrderHom ↑X✝ ↑Y✝\n⊢ Eq (Preord.dual.map a) (OrderHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : Preord ⥤ Preord where\n  obj X := of Xᵒᵈ\n  map := OrderHom.dual\n\n"}
{"name":"Preord.dual_obj","module":"Mathlib.Order.Category.Preord","initialProofState":"X : Preord\n⊢ Eq (Preord.dual.obj X) (Preord.of (OrderDual ↑X))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : Preord ⥤ Preord where\n  obj X := of Xᵒᵈ\n  map := OrderHom.dual\n\n"}
{"name":"Preord.dualEquiv_functor","module":"Mathlib.Order.Category.Preord","initialProofState":"⊢ Eq Preord.dualEquiv.functor Preord.dual","decl":"/-- The equivalence between `Preord` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : Preord ≌ Preord where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"Preord.dualEquiv_inverse","module":"Mathlib.Order.Category.Preord","initialProofState":"⊢ Eq Preord.dualEquiv.inverse Preord.dual","decl":"/-- The equivalence between `Preord` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : Preord ≌ Preord where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"preordToCat_map","module":"Mathlib.Order.Category.Preord","initialProofState":"X✝ Y✝ : Preord\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (preordToCat.map f) ⋯.functor","decl":"/-- The embedding of `Preord` into `Cat`.\n-/\n@[simps]\ndef preordToCat : Preord.{u} ⥤ Cat where\n  obj X := Cat.of X.1\n  map f := f.monotone.functor\n\n"}
{"name":"preordToCat_obj","module":"Mathlib.Order.Category.Preord","initialProofState":"X : Preord\n⊢ Eq (preordToCat.obj X) (CategoryTheory.Cat.of ↑X)","decl":"/-- The embedding of `Preord` into `Cat`.\n-/\n@[simps]\ndef preordToCat : Preord.{u} ⥤ Cat where\n  obj X := Cat.of X.1\n  map f := f.monotone.functor\n\n"}
{"name":"instFaithfulPreordCatPreordToCat","module":"Mathlib.Order.Category.Preord","initialProofState":"⊢ preordToCat.Faithful","decl":"instance : preordToCat.{u}.Faithful where\n  map_injective h := by ext x; exact Functor.congr_obj h x\n\n"}
{"name":"instFullPreordCatPreordToCat","module":"Mathlib.Order.Category.Preord","initialProofState":"⊢ preordToCat.Full","decl":"instance : preordToCat.{u}.Full where\n  map_surjective {X Y} f := ⟨⟨f.obj, @CategoryTheory.Functor.monotone X Y _ _ f⟩, rfl⟩\n"}
