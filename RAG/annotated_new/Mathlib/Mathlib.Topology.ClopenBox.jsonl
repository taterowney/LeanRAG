{"name":"TopologicalSpace.Clopens.exists_prod_subset","module":"Mathlib.Topology.ClopenBox","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : CompactSpace Y\nW : TopologicalSpace.Clopens (Prod X Y)\na : Prod X Y\nh : Membership.mem W a\n⊢ Exists fun U => And (Membership.mem U a.1) (Exists fun V => And (Membership.mem V a.2) (LE.le (SProd.sprod U V) W))","decl":"theorem exists_prod_subset (W : Clopens (X × Y)) {a : X × Y} (h : a ∈ W) :\n    ∃ U : Clopens X, a.1 ∈ U ∧ ∃ V : Clopens Y, a.2 ∈ V ∧ U ×ˢ V ≤ W := by\n  have hp : Continuous (fun y : Y ↦ (a.1, y)) := Continuous.Prod.mk _\n  let V : Set Y := {y | (a.1, y) ∈ W}\n  have hV : IsCompact V := (W.2.1.preimage hp).isCompact\n  let U : Set X := {x | MapsTo (Prod.mk x) V W}\n  have hUV : U ×ˢ V ⊆ W := fun ⟨_, _⟩ hw ↦ hw.1 hw.2\n  exact ⟨⟨U, (ContinuousMap.isClopen_setOf_mapsTo hV W.2).preimage\n    (ContinuousMap.id (X × Y)).curry.2⟩, by simp [U, V, MapsTo], ⟨V, W.2.preimage hp⟩, h, hUV⟩\n\n"}
{"name":"TopologicalSpace.Clopens.exists_finset_eq_sup_prod","module":"Mathlib.Topology.ClopenBox","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : CompactSpace X\nW : TopologicalSpace.Clopens (Prod X Y)\n⊢ Exists fun I => Eq W (I.sup fun i => SProd.sprod i.1 i.2)","decl":"/-- Every clopen set in a product of two compact spaces\nis a union of finitely many clopen boxes. -/\ntheorem exists_finset_eq_sup_prod (W : Clopens (X × Y)) :\n    ∃ (I : Finset (Clopens X × Clopens Y)), W = I.sup fun i ↦ i.1 ×ˢ i.2 := by\n  choose! U hxU V hxV hUV using fun x ↦ W.exists_prod_subset (a := x)\n  rcases W.2.1.isCompact.elim_nhds_subcover (fun x ↦ U x ×ˢ V x) (fun x hx ↦\n    (U x ×ˢ V x).2.isOpen.mem_nhds ⟨hxU x hx, hxV x hx⟩) with ⟨I, hIW, hWI⟩\n  classical\n  use I.image fun x ↦ (U x, V x)\n  rw [Finset.sup_image]\n  refine le_antisymm (fun x hx ↦ ?_) (Finset.sup_le fun x hx ↦ ?_)\n  · rcases Set.mem_iUnion₂.1 (hWI hx) with ⟨i, hi, hxi⟩\n    exact SetLike.le_def.1 (Finset.le_sup hi) hxi\n  · exact hUV _ <| hIW _ hx\n\n"}
{"name":"TopologicalSpace.Clopens.surjective_finset_sup_prod","module":"Mathlib.Topology.ClopenBox","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : CompactSpace Y\ninst✝ : CompactSpace X\n⊢ Function.Surjective fun I => I.sup fun i => SProd.sprod i.1 i.2","decl":"lemma surjective_finset_sup_prod :\n    Surjective fun I : Finset (Clopens X × Clopens Y) ↦ I.sup fun i ↦ i.1 ×ˢ i.2 := fun W ↦\n  let ⟨I, hI⟩ := W.exists_finset_eq_sup_prod; ⟨I, hI.symm⟩\n\n"}
{"name":"TopologicalSpace.Clopens.countable_prod","module":"Mathlib.Topology.ClopenBox","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : CompactSpace Y\ninst✝² : CompactSpace X\ninst✝¹ : Countable (TopologicalSpace.Clopens X)\ninst✝ : Countable (TopologicalSpace.Clopens Y)\n⊢ Countable (TopologicalSpace.Clopens (Prod X Y))","decl":"instance countable_prod [Countable (Clopens X)]\n    [Countable (Clopens Y)] : Countable (Clopens (X × Y)) :=\n  surjective_finset_sup_prod.countable\n\n"}
{"name":"TopologicalSpace.Clopens.finite_prod","module":"Mathlib.Topology.ClopenBox","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : Finite (TopologicalSpace.Clopens X)\ninst✝ : Finite (TopologicalSpace.Clopens Y)\n⊢ Finite (TopologicalSpace.Clopens (Prod X Y))","decl":"instance finite_prod [Finite (Clopens X)] [Finite (Clopens Y)] :\n    Finite (Clopens (X × Y)) := by\n  cases nonempty_fintype (Clopens X)\n  cases nonempty_fintype (Clopens Y)\n  exact .of_surjective _ surjective_finset_sup_prod\n\n"}
{"name":"TopologicalSpace.Clopens.countable_iff_secondCountable","module":"Mathlib.Topology.ClopenBox","initialProofState":"X : Type u_1\ninst✝³ : TopologicalSpace X\ninst✝² : CompactSpace X\ninst✝¹ : T2Space X\ninst✝ : TotallyDisconnectedSpace X\n⊢ Iff (Countable (TopologicalSpace.Clopens X)) (SecondCountableTopology X)","decl":"lemma countable_iff_secondCountable [T2Space X]\n    [TotallyDisconnectedSpace X] : Countable (Clopens X) ↔ SecondCountableTopology X := by\n  refine ⟨fun h ↦ ⟨{s : Set X | IsClopen s}, ?_, ?_⟩, fun h ↦ ?_⟩\n  · let f : {s : Set X | IsClopen s} → Clopens X := fun s ↦ ⟨s.1, s.2⟩\n    exact (injective_of_le_imp_le f fun a ↦ a).countable\n  · apply IsTopologicalBasis.eq_generateFrom\n    exact loc_compact_Haus_tot_disc_of_zero_dim\n  · have : ∀ (s : Clopens X), ∃ (t : Finset (countableBasis X)), s.1 = t.toSet.sUnion :=\n      fun s ↦ eq_sUnion_finset_of_isTopologicalBasis_of_isCompact_open _\n        (isBasis_countableBasis X) s.1 s.2.1.isCompact s.2.2\n    let f : Clopens X → Finset (countableBasis X) := fun s ↦ (this s).choose\n    have hf : f.Injective := by\n      intro s t (h : Exists.choose _ = Exists.choose _)\n      ext1; change s.carrier = t.carrier\n      rw [(this s).choose_spec, (this t).choose_spec, h]\n    exact hf.countable\n\n"}
{"name":"TopologicalSpace.Clopens.countable_iff_second_countable","module":"Mathlib.Topology.ClopenBox","initialProofState":"X : Type u_1\ninst✝³ : TopologicalSpace X\ninst✝² : CompactSpace X\ninst✝¹ : T2Space X\ninst✝ : TotallyDisconnectedSpace X\n⊢ Iff (Countable (TopologicalSpace.Clopens X)) (SecondCountableTopology X)","decl":"@[deprecated (since := \"2024-11-12\")]\nalias countable_iff_second_countable := countable_iff_secondCountable\n\n"}
