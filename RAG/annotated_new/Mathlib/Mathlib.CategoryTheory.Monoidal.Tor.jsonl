{"name":"CategoryTheory.Tor_obj","module":"Mathlib.CategoryTheory.Monoidal.Tor","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.MonoidalPreadditive C\ninst✝ : CategoryTheory.HasProjectiveResolutions C\nn : Nat\nX : C\n⊢ Eq ((CategoryTheory.Tor C n).obj X) (((CategoryTheory.MonoidalCategory.tensoringLeft C).obj X).leftDerived n)","decl":"/-- We define `Tor C n : C ⥤ C ⥤ C` by left-deriving in the second factor of `(X, Y) ↦ X ⊗ Y`. -/\n@[simps]\ndef Tor (n : ℕ) : C ⥤ C ⥤ C where\n  obj X := Functor.leftDerived ((tensoringLeft C).obj X) n\n  map f := NatTrans.leftDerived ((tensoringLeft C).map f) n\n\n"}
{"name":"CategoryTheory.Tor_map","module":"Mathlib.CategoryTheory.Monoidal.Tor","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.MonoidalPreadditive C\ninst✝ : CategoryTheory.HasProjectiveResolutions C\nn : Nat\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Tor C n).map f) (CategoryTheory.NatTrans.leftDerived ((CategoryTheory.MonoidalCategory.tensoringLeft C).map f) n)","decl":"/-- We define `Tor C n : C ⥤ C ⥤ C` by left-deriving in the second factor of `(X, Y) ↦ X ⊗ Y`. -/\n@[simps]\ndef Tor (n : ℕ) : C ⥤ C ⥤ C where\n  obj X := Functor.leftDerived ((tensoringLeft C).obj X) n\n  map f := NatTrans.leftDerived ((tensoringLeft C).map f) n\n\n"}
{"name":"CategoryTheory.Tor'_obj_obj","module":"Mathlib.CategoryTheory.Monoidal.Tor","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.MonoidalPreadditive C\ninst✝ : CategoryTheory.HasProjectiveResolutions C\nn : Nat\nk j : C\n⊢ Eq (((CategoryTheory.Tor' C n).obj k).obj j) ((((CategoryTheory.MonoidalCategory.tensoringRight C).obj j).leftDerived n).obj k)","decl":"/-- An alternative definition of `Tor`, where we left-derive in the first factor instead. -/\n@[simps! obj_obj]\ndef Tor' (n : ℕ) : C ⥤ C ⥤ C :=\n  Functor.flip\n    { obj := fun X => Functor.leftDerived ((tensoringRight C).obj X) n\n      map := fun f => NatTrans.leftDerived ((tensoringRight C).map f) n }\n\n-- Porting note: the `checkType` linter complains about the automatically generated\n-- lemma `Tor'_map_app`, but not about this one\n"}
{"name":"CategoryTheory.Tor'_map_app'","module":"Mathlib.CategoryTheory.Monoidal.Tor","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.MonoidalPreadditive C\ninst✝ : CategoryTheory.HasProjectiveResolutions C\nn : Nat\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n⊢ Eq (((CategoryTheory.Tor' C n).map f).app Z) ((((CategoryTheory.MonoidalCategory.tensoringRight C).obj Z).leftDerived n).map f)","decl":"@[simp]\nlemma Tor'_map_app' (n : ℕ) {X Y : C} (f : X ⟶ Y) (Z : C) :\n    ((Tor' C n).map f).app Z = (Functor.leftDerived ((tensoringRight C).obj Z) n).map f := by\n  rfl\n\n-- Porting note: this specific lemma was added because otherwise the internals of\n-- `NatTrans.leftDerived` leaks into the RHS (it was already so in mathlib)\n"}
{"name":"CategoryTheory.Tor'_obj_map","module":"Mathlib.CategoryTheory.Monoidal.Tor","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.MonoidalPreadditive C\ninst✝ : CategoryTheory.HasProjectiveResolutions C\nn : Nat\nX Y Z : C\nf : Quiver.Hom X Y\n⊢ Eq (((CategoryTheory.Tor' C n).obj Z).map f) ((CategoryTheory.NatTrans.leftDerived ((CategoryTheory.MonoidalCategory.tensoringRight C).map f) n).app Z)","decl":"@[simp]\nlemma Tor'_obj_map (n : ℕ) {X Y : C} (Z : C) (f : X ⟶ Y) :\n    ((Tor' C n).obj Z).map f = (NatTrans.leftDerived ((tensoringRight C).map f) n).app Z := rfl\n\n"}
{"name":"CategoryTheory.isZero_Tor_succ_of_projective","module":"Mathlib.CategoryTheory.Monoidal.Tor","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.MonoidalPreadditive C\ninst✝¹ : CategoryTheory.HasProjectiveResolutions C\nX Y : C\ninst✝ : CategoryTheory.Projective Y\nn : Nat\n⊢ CategoryTheory.Limits.IsZero (((CategoryTheory.Tor C (HAdd.hAdd n 1)).obj X).obj Y)","decl":"/-- The higher `Tor` groups for `X` and `Y` are zero if `Y` is projective. -/\nlemma isZero_Tor_succ_of_projective (X Y : C) [Projective Y] (n : ℕ) :\n    IsZero (((Tor C (n + 1)).obj X).obj Y) := by\n  apply Functor.isZero_leftDerived_obj_projective_succ\n\n"}
{"name":"CategoryTheory.isZero_Tor'_succ_of_projective","module":"Mathlib.CategoryTheory.Monoidal.Tor","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.MonoidalPreadditive C\ninst✝¹ : CategoryTheory.HasProjectiveResolutions C\nX Y : C\ninst✝ : CategoryTheory.Projective X\nn : Nat\n⊢ CategoryTheory.Limits.IsZero (((CategoryTheory.Tor' C (HAdd.hAdd n 1)).obj X).obj Y)","decl":"/-- The higher `Tor'` groups for `X` and `Y` are zero if `X` is projective. -/\nlemma isZero_Tor'_succ_of_projective (X Y : C) [Projective X] (n : ℕ) :\n    IsZero (((Tor' C (n + 1)).obj X).obj Y) := by\n  apply Functor.isZero_leftDerived_obj_projective_succ\n\n"}
