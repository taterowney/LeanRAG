{"name":"exists_isTranscendenceBasis","module":"Mathlib.RingTheory.AlgebraicIndependent.TranscendenceBasis","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nh : Function.Injective ⇑(algebraMap R A)\n⊢ Exists fun s => IsTranscendenceBasis R Subtype.val","decl":"theorem exists_isTranscendenceBasis (h : Injective (algebraMap R A)) :\n    ∃ s : Set A, IsTranscendenceBasis R ((↑) : s → A) := by\n  cases' exists_maximal_algebraicIndependent (∅ : Set A) Set.univ (Set.subset_univ _)\n      ((algebraicIndependent_empty_iff R A).2 h) with\n    s hs\n  refine ⟨s, hs.2.1.1, fun t ht hst ↦ ?_⟩\n  simp only [Subtype.range_coe_subtype, setOf_mem_eq] at *\n  exact hs.2.eq_of_le ⟨ht, subset_univ _⟩ hst\n\n"}
{"name":"exists_isTranscendenceBasis'","module":"Mathlib.RingTheory.AlgebraicIndependent.TranscendenceBasis","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nh : Function.Injective ⇑(algebraMap R A)\n⊢ Exists fun ι => Exists fun x => IsTranscendenceBasis R x","decl":"/-- `Type` version of `exists_isTranscendenceBasis`. -/\ntheorem exists_isTranscendenceBasis' (R : Type u) {A : Type v} [CommRing R] [CommRing A]\n    [Algebra R A] (h : Injective (algebraMap R A)) :\n    ∃ (ι : Type v) (x : ι → A), IsTranscendenceBasis R x := by\n  obtain ⟨s, h⟩ := exists_isTranscendenceBasis R h\n  exact ⟨s, Subtype.val, h⟩\n\n"}
{"name":"AlgebraicIndependent.isTranscendenceBasis_iff","module":"Mathlib.RingTheory.AlgebraicIndependent.TranscendenceBasis","initialProofState":"ι : Type w\nR : Type u\ninst✝³ : CommRing R\ninst✝² : Nontrivial R\nA : Type v\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx : ι → A\ni : AlgebraicIndependent R x\n⊢ Iff (IsTranscendenceBasis R x) (∀ (κ : Type v) (w : κ → A), AlgebraicIndependent R w → ∀ (j : ι → κ), Eq (Function.comp w j) x → Function.Surjective j)","decl":"theorem AlgebraicIndependent.isTranscendenceBasis_iff {ι : Type w} {R : Type u} [CommRing R]\n    [Nontrivial R] {A : Type v} [CommRing A] [Algebra R A] {x : ι → A}\n    (i : AlgebraicIndependent R x) :\n    IsTranscendenceBasis R x ↔\n      ∀ (κ : Type v) (w : κ → A) (_ : AlgebraicIndependent R w) (j : ι → κ) (_ : w ∘ j = x),\n        Surjective j := by\n  fconstructor\n  · rintro p κ w i' j rfl\n    have p := p.2 (range w) i'.coe_range (range_comp_subset_range _ _)\n    rw [range_comp, ← @image_univ _ _ w] at p\n    exact range_eq_univ.mp (image_injective.mpr i'.injective p)\n  · intro p\n    use i\n    intro w i' h\n    specialize p w ((↑) : w → A) i' (fun i => ⟨x i, range_subset_iff.mp h i⟩) (by ext; simp)\n    have q := congr_arg (fun s => ((↑) : w → A) '' s) p.range_eq\n    dsimp at q\n    rw [← image_univ, image_image] at q\n    simpa using q\n\n"}
{"name":"IsTranscendenceBasis.isAlgebraic","module":"Mathlib.RingTheory.AlgebraicIndependent.TranscendenceBasis","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\nhx : IsTranscendenceBasis R x\n⊢ Algebra.IsAlgebraic (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Set.range x)) x_1) A","decl":"theorem IsTranscendenceBasis.isAlgebraic [Nontrivial R] (hx : IsTranscendenceBasis R x) :\n    Algebra.IsAlgebraic (adjoin R (range x)) A := by\n  constructor\n  intro a\n  rw [← not_iff_comm.1 (hx.1.option_iff _).symm]\n  intro ai\n  have h₁ : range x ⊆ range fun o : Option ι => o.elim a x := by\n    rintro x ⟨y, rfl⟩\n    exact ⟨some y, rfl⟩\n  have h₂ : range x ≠ range fun o : Option ι => o.elim a x := by\n    intro h\n    have : a ∈ range x := by\n      rw [h]\n      exact ⟨none, rfl⟩\n    rcases this with ⟨b, rfl⟩\n    have : some b = none := ai.injective rfl\n    simpa\n  exact h₂ (hx.2 (Set.range fun o : Option ι => o.elim a x)\n    ((algebraicIndependent_subtype_range ai.injective).2 ai) h₁)\n\n"}
{"name":"IsTranscendenceBasis.isEmpty_iff_isAlgebraic","module":"Mathlib.RingTheory.AlgebraicIndependent.TranscendenceBasis","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\nhx : IsTranscendenceBasis R x\n⊢ Iff (IsEmpty ι) (Algebra.IsAlgebraic R A)","decl":"/-- If `x` is a transcendence basis of `A/R`, then it is empty if and only if\n`A/R` is algebraic. -/\ntheorem IsTranscendenceBasis.isEmpty_iff_isAlgebraic [Nontrivial R]\n    (hx : IsTranscendenceBasis R x) :\n    IsEmpty ι ↔ Algebra.IsAlgebraic R A := by\n  refine ⟨fun _ ↦ ?_, fun _ ↦ hx.1.isEmpty_of_isAlgebraic⟩\n  have := hx.isAlgebraic\n  rw [Set.range_eq_empty x, adjoin_empty] at this\n  exact algebra_isAlgebraic_of_algebra_isAlgebraic_bot_left R A\n\n"}
{"name":"IsTranscendenceBasis.nonempty_iff_transcendental","module":"Mathlib.RingTheory.AlgebraicIndependent.TranscendenceBasis","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\nhx : IsTranscendenceBasis R x\n⊢ Iff (Nonempty ι) (Algebra.Transcendental R A)","decl":"/-- If `x` is a transcendence basis of `A/R`, then it is not empty if and only if\n`A/R` is transcendental. -/\ntheorem IsTranscendenceBasis.nonempty_iff_transcendental [Nontrivial R]\n    (hx : IsTranscendenceBasis R x) :\n    Nonempty ι ↔ Algebra.Transcendental R A := by\n  rw [← not_isEmpty_iff, Algebra.transcendental_iff_not_isAlgebraic, hx.isEmpty_iff_isAlgebraic]\n\n"}
{"name":"IsTranscendenceBasis.isAlgebraic_field","module":"Mathlib.RingTheory.AlgebraicIndependent.TranscendenceBasis","initialProofState":"ι : Type u_1\nF : Type u_7\nE : Type u_8\nx : ι → E\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nhx : IsTranscendenceBasis F x\n⊢ Algebra.IsAlgebraic (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Set.range x)) x_1) E","decl":"theorem IsTranscendenceBasis.isAlgebraic_field {F E : Type*} {x : ι → E}\n    [Field F] [Field E] [Algebra F E] (hx : IsTranscendenceBasis F x) :\n    Algebra.IsAlgebraic (IntermediateField.adjoin F (range x)) E := by\n  haveI := hx.isAlgebraic\n  set S := range x\n  letI : Algebra (adjoin F S) (IntermediateField.adjoin F S) :=\n    (Subalgebra.inclusion (IntermediateField.algebra_adjoin_le_adjoin F S)).toRingHom.toAlgebra\n  haveI : IsScalarTower (adjoin F S) (IntermediateField.adjoin F S) E :=\n    IsScalarTower.of_algebraMap_eq (congrFun rfl)\n  exact Algebra.IsAlgebraic.extendScalars (R := adjoin F S) (Subalgebra.inclusion_injective _)\n"}
