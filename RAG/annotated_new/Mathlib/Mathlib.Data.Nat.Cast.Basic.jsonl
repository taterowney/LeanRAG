{"name":"Nat.coe_castAddMonoidHom","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\ninst✝ : AddMonoidWithOne α\n⊢ Eq (⇑(Nat.castAddMonoidHom α)) Nat.cast","decl":"@[simp]\ntheorem coe_castAddMonoidHom [AddMonoidWithOne α] : (castAddMonoidHom α : ℕ → α) = Nat.cast :=\n  rfl\n\n"}
{"name":"Even.natCast","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\ninst✝ : AddMonoidWithOne α\nn : Nat\nhn : Even n\n⊢ Even ↑n","decl":"lemma _root_.Even.natCast [AddMonoidWithOne α] {n : ℕ} (hn : Even n) : Even (n : α) :=\n  hn.map <| Nat.castAddMonoidHom α\n\n"}
{"name":"Nat.cast_mul","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\ninst✝ : NonAssocSemiring α\nm n : Nat\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp, norm_cast] lemma cast_mul (m n : ℕ) : ((m * n : ℕ) : α) = m * n := by\n  induction n <;> simp [mul_succ, mul_add, *]\n\n"}
{"name":"Nat.coe_castRingHom","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\ninst✝ : NonAssocSemiring α\n⊢ Eq (⇑(Nat.castRingHom α)) Nat.cast","decl":"@[simp, norm_cast] lemma coe_castRingHom : (castRingHom α : ℕ → α) = Nat.cast := rfl\n\n"}
{"name":"nsmul_eq_mul'","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\ninst✝ : NonAssocSemiring α\na : α\nn : Nat\n⊢ Eq (HSMul.hSMul n a) (HMul.hMul a ↑n)","decl":"lemma _root_.nsmul_eq_mul' (a : α) (n : ℕ) : n • a = a * n := by\n  induction n with\n  | zero => rw [zero_nsmul, Nat.cast_zero, mul_zero]\n  | succ n ih => rw [succ_nsmul, ih, Nat.cast_succ, mul_add, mul_one]\n\n"}
{"name":"nsmul_eq_mul","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\ninst✝ : NonAssocSemiring α\nn : Nat\na : α\n⊢ Eq (HSMul.hSMul n a) (HMul.hMul (↑n) a)","decl":"@[simp] lemma _root_.nsmul_eq_mul (n : ℕ) (a : α) : n • a = n * a := by\n  induction n with\n  | zero => rw [zero_nsmul, Nat.cast_zero, zero_mul]\n  | succ n ih => rw [succ_nsmul, ih, Nat.cast_succ, add_mul, one_mul]\n\n"}
{"name":"Nat.cast_pow","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nm n : Nat\n⊢ Eq (↑(HPow.hPow m n)) (HPow.hPow (↑m) n)","decl":"@[simp, norm_cast]\nlemma cast_pow (m : ℕ) : ∀ n : ℕ, ↑(m ^ n) = (m ^ n : α)\n  | 0 => by simp\n  | n + 1 => by rw [_root_.pow_succ', _root_.pow_succ', cast_mul, cast_pow m n]\n\n"}
{"name":"Nat.cast_dvd_cast","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nm n : Nat\nh : Dvd.dvd m n\n⊢ Dvd.dvd ↑m ↑n","decl":"lemma cast_dvd_cast (h : m ∣ n) : (m : α) ∣ (n : α) := map_dvd (Nat.castRingHom α) h\n\n"}
{"name":"Dvd.dvd.natCast","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nm n : Nat\nh : Dvd.dvd m n\n⊢ Dvd.dvd ↑m ↑n","decl":"alias _root_.Dvd.dvd.natCast := cast_dvd_cast\n\n"}
{"name":"eq_natCast'","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"A : Type u_3\nF : Type u_5\ninst✝² : FunLike F Nat A\ninst✝¹ : AddMonoidWithOne A\ninst✝ : AddMonoidHomClass F Nat A\nf : F\nh1 : Eq (f 1) 1\nn : Nat\n⊢ Eq (f n) ↑n","decl":"theorem eq_natCast' [AddMonoidHomClass F ℕ A] (f : F) (h1 : f 1 = 1) : ∀ n : ℕ, f n = n\n  | 0 => by simp [map_zero f]\n  | n + 1 => by rw [map_add, h1, eq_natCast' f h1 n, Nat.cast_add_one]\n\n"}
{"name":"map_natCast'","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"B : Type u_4\nF : Type u_5\ninst✝³ : AddMonoidWithOne B\nA : Type u_6\ninst✝² : AddMonoidWithOne A\ninst✝¹ : FunLike F A B\ninst✝ : AddMonoidHomClass F A B\nf : F\nh : Eq (f 1) 1\nn : Nat\n⊢ Eq (f ↑n) ↑n","decl":"theorem map_natCast' {A} [AddMonoidWithOne A] [FunLike F A B] [AddMonoidHomClass F A B]\n    (f : F) (h : f 1 = 1) :\n    ∀ n : ℕ, f n = n :=\n  eq_natCast' ((f : A →+ B).comp <| Nat.castAddMonoidHom _) (by simpa)\n\n"}
{"name":"map_ofNat'","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"B : Type u_4\nF : Type u_5\ninst✝⁴ : AddMonoidWithOne B\nA : Type u_6\ninst✝³ : AddMonoidWithOne A\ninst✝² : FunLike F A B\ninst✝¹ : AddMonoidHomClass F A B\nf : F\nh : Eq (f 1) 1\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (f (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"theorem map_ofNat' {A} [AddMonoidWithOne A] [FunLike F A B] [AddMonoidHomClass F A B]\n    (f : F) (h : f 1 = 1) (n : ℕ) [n.AtLeastTwo] : f (OfNat.ofNat n) = OfNat.ofNat n :=\n  map_natCast' f h n\n\n"}
{"name":"ext_nat''","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"A : Type u_3\nF : Type u_4\ninst✝² : MulZeroOneClass A\ninst✝¹ : FunLike F Nat A\ninst✝ : MonoidWithZeroHomClass F Nat A\nf g : F\nh_pos : ∀ {n : Nat}, LT.lt 0 n → Eq (f n) (g n)\n⊢ Eq f g","decl":"/-- If two `MonoidWithZeroHom`s agree on the positive naturals they are equal. -/\ntheorem ext_nat'' [MonoidWithZeroHomClass F ℕ A] (f g : F) (h_pos : ∀ {n : ℕ}, 0 < n → f n = g n) :\n    f = g := by\n  apply DFunLike.ext\n  rintro (_ | n)\n  · simp [map_zero f, map_zero g]\n  · exact h_pos n.succ_pos\n\n"}
{"name":"MonoidWithZeroHom.ext_nat_iff","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"A : Type u_3\ninst✝ : MulZeroOneClass A\nf g : MonoidWithZeroHom Nat A\n⊢ Iff (Eq f g) (∀ {n : Nat}, LT.lt 0 n → Eq (f n) (g n))","decl":"@[ext]\ntheorem MonoidWithZeroHom.ext_nat {f g : ℕ →*₀ A} : (∀ {n : ℕ}, 0 < n → f n = g n) → f = g :=\n  ext_nat'' f g\n\n"}
{"name":"MonoidWithZeroHom.ext_nat","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"A : Type u_3\ninst✝ : MulZeroOneClass A\nf g : MonoidWithZeroHom Nat A\na✝ : ∀ {n : Nat}, LT.lt 0 n → Eq (f n) (g n)\n⊢ Eq f g","decl":"@[ext]\ntheorem MonoidWithZeroHom.ext_nat {f g : ℕ →*₀ A} : (∀ {n : ℕ}, 0 < n → f n = g n) → f = g :=\n  ext_nat'' f g\n\n"}
{"name":"eq_natCast","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"R : Type u_3\nF : Type u_5\ninst✝² : NonAssocSemiring R\ninst✝¹ : FunLike F Nat R\ninst✝ : RingHomClass F Nat R\nf : F\nn : Nat\n⊢ Eq (f n) ↑n","decl":"@[simp]\ntheorem eq_natCast [FunLike F ℕ R] [RingHomClass F ℕ R] (f : F) : ∀ n, f n = n :=\n  eq_natCast' f <| map_one f\n\n"}
{"name":"map_natCast","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nF : Type u_5\ninst✝³ : NonAssocSemiring R\ninst✝² : NonAssocSemiring S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\nn : Nat\n⊢ Eq (f ↑n) ↑n","decl":"@[simp]\ntheorem map_natCast [FunLike F R S] [RingHomClass F R S] (f : F) : ∀ n : ℕ, f (n : R) = n :=\n  map_natCast' f <| map_one f\n\n"}
{"name":"map_ofNat","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nF : Type u_5\ninst✝⁴ : NonAssocSemiring R\ninst✝³ : NonAssocSemiring S\ninst✝² : FunLike F R S\ninst✝¹ : RingHomClass F R S\nf : F\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (f (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"/-- This lemma is not marked `@[simp]` lemma because its `#discr_tree_key` (for the LHS) would just\nbe `DFunLike.coe _ _`, due to the `ofNat` that https://github.com/leanprover/lean4/issues/2867\nforces us to include, and therefore it would negatively impact performance.\n\nIf that issue is resolved, this can be marked `@[simp]`. -/\ntheorem map_ofNat [FunLike F R S] [RingHomClass F R S] (f : F) (n : ℕ) [Nat.AtLeastTwo n] :\n    (f ofNat(n) : S) = OfNat.ofNat n :=\n  map_natCast f n\n\n"}
{"name":"ext_nat","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"R : Type u_3\nF : Type u_5\ninst✝² : NonAssocSemiring R\ninst✝¹ : FunLike F Nat R\ninst✝ : RingHomClass F Nat R\nf g : F\n⊢ Eq f g","decl":"theorem ext_nat [FunLike F ℕ R] [RingHomClass F ℕ R] (f g : F) : f = g :=\n  ext_nat' f g <| by simp only [map_one f, map_one g]\n\n"}
{"name":"NeZero.nat_of_neZero","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"R : Type u_6\nS : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring S\nF : Type u_8\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\nn : Nat\nhn : NeZero ↑n\n⊢ NeZero ↑n","decl":"theorem NeZero.nat_of_neZero {R S} [Semiring R] [Semiring S]\n    {F} [FunLike F R S] [RingHomClass F R S] (f : F)\n    {n : ℕ} [hn : NeZero (n : S)] : NeZero (n : R) :=\n  .of_map (f := f) (neZero := by simp only [map_natCast, hn])\n\n"}
{"name":"RingHom.eq_natCast'","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"R : Type u_3\ninst✝ : NonAssocSemiring R\nf : RingHom Nat R\n⊢ Eq f (Nat.castRingHom R)","decl":"/-- This is primed to match `eq_intCast'`. -/\ntheorem eq_natCast' {R} [NonAssocSemiring R] (f : ℕ →+* R) : f = Nat.castRingHom R :=\n  RingHom.ext <| eq_natCast f\n\n"}
{"name":"Nat.cast_id","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n) n","decl":"@[simp, norm_cast]\ntheorem Nat.cast_id (n : ℕ) : n.cast = n :=\n  rfl\n\n"}
{"name":"Nat.castRingHom_nat","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"⊢ Eq (Nat.castRingHom Nat) (RingHom.id Nat)","decl":"@[simp]\ntheorem Nat.castRingHom_nat : Nat.castRingHom ℕ = RingHom.id ℕ :=\n  rfl\n\n"}
{"name":"Pi.natCast_apply","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\nπ : α → Type u_3\ninst✝ : (a : α) → NatCast (π a)\nn : Nat\na : α\n⊢ Eq (↑n a) ↑n","decl":"theorem natCast_apply (n : ℕ) (a : α) : (n : ∀ a, π a) a = n :=\n  rfl\n\n"}
{"name":"Pi.natCast_def","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\nπ : α → Type u_3\ninst✝ : (a : α) → NatCast (π a)\nn : Nat\n⊢ Eq ↑n fun x => ↑n","decl":"@[simp]\ntheorem natCast_def (n : ℕ) : (n : ∀ a, π a) = fun _ ↦ ↑n :=\n  rfl\n\n"}
{"name":"Pi.ofNat_apply","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\nπ : α → Type u_3\ninst✝¹ : (a : α) → NatCast (π a)\nn : Nat\ninst✝ : n.AtLeastTwo\na : α\n⊢ Eq (OfNat.ofNat n a) ↑n","decl":"@[simp]\ntheorem ofNat_apply (n : ℕ) [n.AtLeastTwo] (a : α) : (OfNat.ofNat n : ∀ a, π a) a = n := rfl\n\n"}
{"name":"Pi.ofNat_def","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_1\nπ : α → Type u_3\ninst✝¹ : (a : α) → NatCast (π a)\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n) fun x => OfNat.ofNat n","decl":"lemma ofNat_def (n : ℕ) [n.AtLeastTwo] : (OfNat.ofNat n : ∀ a, π a) = fun _ ↦ OfNat.ofNat n := rfl\n\n"}
{"name":"Sum.elim_natCast_natCast","module":"Mathlib.Data.Nat.Cast.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : NatCast γ\nn : Nat\n⊢ Eq (Sum.elim ↑n ↑n) ↑n","decl":"theorem Sum.elim_natCast_natCast {α β γ : Type*} [NatCast γ] (n : ℕ) :\n    Sum.elim (n : α → γ) (n : β → γ) = n :=\n  Sum.elim_lam_const_lam_const (γ := γ) n\n"}
