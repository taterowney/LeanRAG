{"name":"Matroid.comap_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nI : Set α\nN : Matroid β\n⊢ Iff ((N.comap f).Indep I) (And (N.Indep (Set.image f I)) (Set.InjOn f I))","decl":"@[simp] lemma comap_indep_iff : (N.comap f).Indep I ↔ N.Indep (f '' I) ∧ InjOn f I := Iff.rfl\n\n"}
{"name":"Matroid.comap_ground_eq","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nN : Matroid β\nf : α → β\n⊢ Eq (N.comap f).E (Set.preimage f N.E)","decl":"@[simp] lemma comap_ground_eq (N : Matroid β) (f : α → β) : (N.comap f).E = f ⁻¹' N.E := rfl\n\n"}
{"name":"Matroid.comap_dep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nI : Set α\nN : Matroid β\n⊢ Iff ((N.comap f).Dep I) (Or (N.Dep (Set.image f I)) (And (N.Indep (Set.image f I)) (Not (Set.InjOn f I))))","decl":"@[simp] lemma comap_dep_iff :\n    (N.comap f).Dep I ↔ N.Dep (f '' I) ∨ (N.Indep (f '' I) ∧ ¬ InjOn f I) := by\n  rw [Dep, comap_indep_iff, not_and, comap_ground_eq, Dep, image_subset_iff]\n  refine ⟨fun ⟨hi, h⟩ ↦ ?_, ?_⟩\n  · rw [and_iff_left h, ← imp_iff_not_or]\n    exact fun hI ↦ ⟨hI, hi hI⟩\n  rintro (⟨hI, hIE⟩ | hI)\n  · exact ⟨fun h ↦ (hI h).elim, hIE⟩\n  rw [iff_true_intro hI.1, iff_true_intro hI.2, implies_true, true_and]\n  simpa using hI.1.subset_ground\n\n"}
{"name":"Matroid.comap_id","module":"Mathlib.Data.Matroid.Map","initialProofState":"β : Type u_2\nN : Matroid β\n⊢ Eq (N.comap id) N","decl":"@[simp] lemma comap_id (N : Matroid β) : N.comap id = N :=\n  ext_indep rfl <| by simp [injective_id.injOn]\n\n"}
{"name":"Matroid.comap_indep_iff_of_injOn","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nI : Set α\nN : Matroid β\nhf : Set.InjOn f (Set.preimage f N.E)\n⊢ Iff ((N.comap f).Indep I) (N.Indep (Set.image f I))","decl":"lemma comap_indep_iff_of_injOn (hf : InjOn f (f ⁻¹' N.E)) :\n    (N.comap f).Indep I ↔ N.Indep (f '' I) := by\n  rw [comap_indep_iff, and_iff_left_iff_imp]\n  refine fun hi ↦ hf.mono <| subset_trans ?_ (preimage_mono hi.subset_ground)\n  apply subset_preimage_image\n\n"}
{"name":"Matroid.comap_emptyOn","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq ((Matroid.emptyOn β).comap f) (Matroid.emptyOn α)","decl":"@[simp] lemma comap_emptyOn (f : α → β) : comap (emptyOn β) f = emptyOn α := by\n  simp [← ground_eq_empty_iff]\n\n"}
{"name":"Matroid.comap_loopyOn","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nE : Set β\n⊢ Eq ((Matroid.loopyOn E).comap f) (Matroid.loopyOn (Set.preimage f E))","decl":"@[simp] lemma comap_loopyOn (f : α → β) (E : Set β) : comap (loopyOn E) f = loopyOn (f ⁻¹' E) := by\n  rw [eq_loopyOn_iff]; aesop\n\n"}
{"name":"Matroid.comap_basis_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nI X : Set α\n⊢ Iff ((N.comap f).Basis I X) (And (N.Basis (Set.image f I) (Set.image f X)) (And (Set.InjOn f I) (HasSubset.Subset I X)))","decl":"@[simp] lemma comap_basis_iff {I X : Set α} :\n    (N.comap f).Basis I X ↔ N.Basis (f '' I) (f '' X) ∧ I.InjOn f ∧ I ⊆ X  := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · obtain ⟨hI, hinj⟩ := comap_indep_iff.1 h.indep\n    refine ⟨hI.basis_of_forall_insert (image_subset f h.subset) fun e he ↦ ?_, hinj, h.subset⟩\n    simp only [mem_diff, mem_image, not_exists, not_and, and_imp, forall_exists_index,\n      forall_apply_eq_imp_iff₂] at he\n    obtain ⟨⟨e, heX, rfl⟩, he⟩ := he\n    have heI : e ∉ I := fun heI ↦ (he e heI rfl)\n    replace h := h.insert_dep ⟨heX, heI⟩\n    simp only [comap_dep_iff, image_insert_eq, or_iff_not_imp_right, injOn_insert heI,\n      hinj, mem_image, not_exists, not_and, true_and, not_forall, Classical.not_imp, not_not] at h\n    exact h (fun _ ↦ he)\n  refine Indep.basis_of_forall_insert ?_ h.2.2 fun e ⟨heX, heI⟩ ↦ ?_\n  · simp [comap_indep_iff, h.1.indep, h.2]\n  have hIE : insert e I ⊆ (N.comap f).E := by\n      simp_rw [comap_ground_eq, ← image_subset_iff]\n      exact (image_subset _ (insert_subset heX h.2.2)).trans h.1.subset_ground\n  suffices N.Indep (insert (f e) (f '' I)) → ∃ x ∈ I, f x = f e\n    by simpa [← not_indep_iff hIE, injOn_insert heI, h.2.1, image_insert_eq]\n  exact h.1.mem_of_insert_indep (mem_image_of_mem f heX)\n\n"}
{"name":"Matroid.comap_base_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nB : Set α\n⊢ Iff ((N.comap f).Base B) (And (N.Basis (Set.image f B) (Set.image f (Set.preimage f N.E))) (And (Set.InjOn f B) (HasSubset.Subset B (Set.preimage f N.E))))","decl":"@[simp] lemma comap_base_iff {B : Set α} :\n    (N.comap f).Base B ↔ N.Basis (f '' B) (f '' (f ⁻¹' N.E)) ∧ B.InjOn f ∧ B ⊆ f ⁻¹' N.E := by\n  rw [← basis_ground_iff, comap_basis_iff]; rfl\n\n"}
{"name":"Matroid.comap_basis'_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nI X : Set α\n⊢ Iff ((N.comap f).Basis' I X) (And (N.Basis' (Set.image f I) (Set.image f X)) (And (Set.InjOn f I) (HasSubset.Subset I X)))","decl":"@[simp] lemma comap_basis'_iff {I X : Set α} :\n    (N.comap f).Basis' I X ↔ N.Basis' (f '' I) (f '' X) ∧ I.InjOn f ∧ I ⊆ X := by\n  simp only [basis'_iff_basis_inter_ground, comap_ground_eq, comap_basis_iff, image_inter_preimage,\n    subset_inter_iff, ← and_assoc, and_congr_left_iff, and_iff_left_iff_imp, and_imp]\n  exact fun h _ _ ↦ (image_subset_iff.1 h.indep.subset_ground)\n\n"}
{"name":"Matroid.comap_finitary","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nN : Matroid β\ninst✝ : N.Finitary\nf : α → β\n⊢ (N.comap f).Finitary","decl":"instance comap_finitary (N : Matroid β) [N.Finitary] (f : α → β) : (N.comap f).Finitary := by\n  refine ⟨fun I hI ↦ ?_⟩\n  rw [comap_indep_iff, indep_iff_forall_finite_subset_indep]\n  simp only [forall_subset_image_iff]\n  refine ⟨fun J hJ hfin ↦ ?_,\n    fun x hx y hy ↦ (hI _ (pair_subset hx hy) (by simp)).2 (by simp) (by simp)⟩\n  obtain ⟨J', hJ'J, hJ'⟩ := (surjOn_image f J).exists_bijOn_subset\n  rw [← hJ'.image_eq] at hfin ⊢\n  exact (hI J' (hJ'J.trans hJ) (hfin.of_finite_image hJ'.injOn)).1\n\n"}
{"name":"Matroid.comap_finiteRk","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nN : Matroid β\ninst✝ : N.FiniteRk\nf : α → β\n⊢ (N.comap f).FiniteRk","decl":"instance comap_finiteRk (N : Matroid β) [N.FiniteRk] (f : α → β) : (N.comap f).FiniteRk := by\n  obtain ⟨B, hB⟩ := (N.comap f).exists_base\n  refine hB.finiteRk_of_finite ?_\n  simp only [comap_base_iff] at hB\n  exact (hB.1.indep.finite.of_finite_image hB.2.1)\n\n"}
{"name":"Matroid.comapOn_preimage_eq","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nN : Matroid β\nf : α → β\n⊢ Eq (N.comapOn (Set.preimage f N.E) f) (N.comap f)","decl":"lemma comapOn_preimage_eq (N : Matroid β) (f : α → β) : N.comapOn (f ⁻¹' N.E) f = N.comap f := by\n  rw [comapOn, restrict_eq_self_iff]; rfl\n\n"}
{"name":"Matroid.comapOn_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nE I : Set α\n⊢ Iff ((N.comapOn E f).Indep I) (And (N.Indep (Set.image f I)) (And (Set.InjOn f I) (HasSubset.Subset I E)))","decl":"@[simp] lemma comapOn_indep_iff :\n    (N.comapOn E f).Indep I ↔ (N.Indep (f '' I) ∧ InjOn f I ∧ I ⊆ E) := by\n  simp [comapOn, and_assoc]\n\n"}
{"name":"Matroid.comapOn_ground_eq","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nE : Set α\n⊢ Eq (N.comapOn E f).E E","decl":"@[simp] lemma comapOn_ground_eq : (N.comapOn E f).E = E := rfl\n\n"}
{"name":"Matroid.comapOn_base_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nE B : Set α\n⊢ Iff ((N.comapOn E f).Base B) (And (N.Basis' (Set.image f B) (Set.image f E)) (And (Set.InjOn f B) (HasSubset.Subset B E)))","decl":"lemma comapOn_base_iff :\n    (N.comapOn E f).Base B ↔ N.Basis' (f '' B) (f '' E) ∧ B.InjOn f ∧ B ⊆ E := by\n  rw [comapOn, base_restrict_iff', comap_basis'_iff]\n\n"}
{"name":"Matroid.comapOn_base_iff_of_surjOn","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nE B : Set α\nh : Set.SurjOn f E N.E\n⊢ Iff ((N.comapOn E f).Base B) (And (N.Base (Set.image f B)) (And (Set.InjOn f B) (HasSubset.Subset B E)))","decl":"lemma comapOn_base_iff_of_surjOn (h : SurjOn f E N.E) :\n    (N.comapOn E f).Base B ↔ (N.Base (f '' B) ∧ InjOn f B ∧ B ⊆ E) := by\n  simp_rw [comapOn_base_iff, and_congr_left_iff, and_imp,\n    basis'_iff_basis_inter_ground, inter_eq_self_of_subset_right h, basis_ground_iff, implies_true]\n\n"}
{"name":"Matroid.comapOn_base_iff_of_bijOn","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nE B : Set α\nh : Set.BijOn f E N.E\n⊢ Iff ((N.comapOn E f).Base B) (And (N.Base (Set.image f B)) (HasSubset.Subset B E))","decl":"lemma comapOn_base_iff_of_bijOn (h : BijOn f E N.E) :\n    (N.comapOn E f).Base B ↔ N.Base (f '' B) ∧ B ⊆ E := by\n  rw [← and_iff_left_of_imp (Base.subset_ground (M := N.comapOn E f) (B := B)),\n    comapOn_ground_eq, and_congr_left_iff]\n  suffices h' : B ⊆ E → InjOn f B from fun hB ↦\n    by simp [hB, comapOn_base_iff_of_surjOn h.surjOn, h']\n  exact fun hBE ↦ h.injOn.mono hBE\n\n"}
{"name":"Matroid.comapOn_dual_eq_of_bijOn","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nE : Set α\nh : Set.BijOn f E N.E\n⊢ Eq (N.comapOn E f).dual (N.dual.comapOn E f)","decl":"lemma comapOn_dual_eq_of_bijOn (h : BijOn f E N.E) :\n    (N.comapOn E f)✶ = N✶.comapOn E f := by\n  refine ext_base (by simp) (fun B hB ↦ ?_)\n  rw [comapOn_base_iff_of_bijOn (by simpa), dual_base_iff, comapOn_base_iff_of_bijOn h,\n    dual_base_iff _, comapOn_ground_eq, and_iff_left diff_subset, and_iff_left (by simpa),\n    h.injOn.image_diff_subset (by simpa), h.image_eq]\n  exact (h.mapsTo.mono_left (show B ⊆ E by simpa)).image_subset\n\n"}
{"name":"Matroid.comapOn_finitary","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nE : Set α\ninst✝ : N.Finitary\n⊢ (N.comapOn E f).Finitary","decl":"instance comapOn_finitary [N.Finitary] : (N.comapOn E f).Finitary := by\n  rw [comapOn]; infer_instance\n\n"}
{"name":"Matroid.comapOn_finiteRk","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nN : Matroid β\nE : Set α\ninst✝ : N.FiniteRk\n⊢ (N.comapOn E f).FiniteRk","decl":"instance comapOn_finiteRk [N.FiniteRk] : (N.comapOn E f).FiniteRk := by\n  rw [comapOn]; infer_instance\n\n"}
{"name":"Matroid.mapSetEmbedding_ground","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Function.Embedding (↑M.E) β\n⊢ Eq (M.mapSetEmbedding f).E (Set.range ⇑f)","decl":"@[simp] lemma mapSetEmbedding_ground (M : Matroid α) (f : M.E ↪ β) :\n    (M.mapSetEmbedding f).E = range f := rfl\n\n"}
{"name":"Matroid.mapSetEmbedding_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Function.Embedding (↑M.E) β\nI : Set β\n⊢ Iff ((M.mapSetEmbedding f).Indep I) (And (M.Indep (Set.image Subtype.val (Set.preimage (⇑f) I))) (HasSubset.Subset I (Set.range ⇑f)))","decl":"@[simp] lemma mapSetEmbedding_indep_iff {f : M.E ↪ β} {I : Set β} :\n    (M.mapSetEmbedding f).Indep I ↔ M.Indep ↑(f ⁻¹' I) ∧ I ⊆ range f := Iff.rfl\n\n"}
{"name":"Matroid.Indep.exists_eq_image_of_mapSetEmbedding","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Function.Embedding (↑M.E) β\nI : Set β\nhI : (M.mapSetEmbedding f).Indep I\n⊢ Exists fun I₀ => And (M.Indep (Set.image Subtype.val I₀)) (Eq I (Set.image (⇑f) I₀))","decl":"lemma Indep.exists_eq_image_of_mapSetEmbedding {f : M.E ↪ β} {I : Set β}\n    (hI : (M.mapSetEmbedding f).Indep I) : ∃ (I₀ : Set M.E), M.Indep I₀ ∧ I = f '' I₀ :=\n  ⟨f ⁻¹' I, hI.1, Eq.symm <| image_preimage_eq_of_subset hI.2⟩\n\n"}
{"name":"Matroid.mapSetEmbedding_indep_iff'","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Function.Embedding (↑M.E) β\nI : Set β\n⊢ Iff ((M.mapSetEmbedding f).Indep I) (Exists fun I₀ => And (M.Indep (Set.image Subtype.val I₀)) (Eq I (Set.image (⇑f) I₀)))","decl":"lemma mapSetEmbedding_indep_iff' {f : M.E ↪ β} {I : Set β} :\n    (M.mapSetEmbedding f).Indep I ↔ ∃ (I₀ : Set M.E), M.Indep ↑I₀ ∧ I = f '' I₀ := by\n  simp only [mapSetEmbedding_indep_iff, subset_range_iff_exists_image_eq]\n  constructor\n  · rintro ⟨hI, I, rfl⟩\n    exact ⟨I, by rwa [preimage_image_eq _ f.injective] at hI, rfl⟩\n  rintro ⟨I, hI, rfl⟩\n  rw [preimage_image_eq _ f.injective]\n  exact ⟨hI, _, rfl⟩\n\n"}
{"name":"Matroid.map_ground","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : α → β\nhf : Set.InjOn f M.E\n⊢ Eq (M.map f hf).E (Set.image f M.E)","decl":"@[simp] lemma map_ground (M : Matroid α) (f : α → β) (hf) : (M.map f hf).E = f '' M.E := rfl\n\n"}
{"name":"Matroid.map_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nM : Matroid α\nhf : Set.InjOn f M.E\nI : Set β\n⊢ Iff ((M.map f hf).Indep I) (Exists fun I₀ => And (M.Indep I₀) (Eq I (Set.image f I₀)))","decl":"@[simp] lemma map_indep_iff {hf} {I : Set β} :\n    (M.map f hf).Indep I ↔ ∃ I₀, M.Indep I₀ ∧ I = f '' I₀ := Iff.rfl\n\n"}
{"name":"Matroid.Indep.map","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nI : Set α\nM : Matroid α\nhI : M.Indep I\nf : α → β\nhf : Set.InjOn f M.E\n⊢ (M.map f hf).Indep (Set.image f I)","decl":"lemma Indep.map (hI : M.Indep I) (f : α → β) (hf) : (M.map f hf).Indep (f '' I) :=\n  map_indep_iff.2 ⟨I, hI, rfl⟩\n\n"}
{"name":"Matroid.Indep.exists_bijOn_of_map","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nM : Matroid α\nI : Set β\nhf : Set.InjOn f M.E\nhI : (M.map f hf).Indep I\n⊢ Exists fun I₀ => And (M.Indep I₀) (Set.BijOn f I₀ I)","decl":"lemma Indep.exists_bijOn_of_map {I : Set β} (hf) (hI : (M.map f hf).Indep I) :\n    ∃ I₀, M.Indep I₀ ∧ BijOn f I₀ I := by\n  obtain ⟨I₀, hI₀, rfl⟩ := hI\n  exact ⟨I₀, hI₀, (hf.mono hI₀.subset_ground).bijOn_image⟩\n\n"}
{"name":"Matroid.map_image_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nM : Matroid α\nhf : Set.InjOn f M.E\nI : Set α\nhI : HasSubset.Subset I M.E\n⊢ Iff ((M.map f hf).Indep (Set.image f I)) (M.Indep I)","decl":"lemma map_image_indep_iff {hf} {I : Set α} (hI : I ⊆ M.E) :\n    (M.map f hf).Indep (f '' I) ↔ M.Indep I := by\n  rw [map_indep_iff]\n  refine ⟨fun ⟨J, hJ, hIJ⟩ ↦ ?_, fun h ↦ ⟨I, h, rfl⟩⟩\n  rw [hf.image_eq_image_iff hI hJ.subset_ground] at hIJ; rwa [hIJ]\n\n"}
{"name":"Matroid.map_base_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : α → β\nhf : Set.InjOn f M.E\nB : Set β\n⊢ Iff ((M.map f hf).Base B) (Exists fun B₀ => And (M.Base B₀) (Eq B (Set.image f B₀)))","decl":"@[simp] lemma map_base_iff (M : Matroid α) (f : α → β) (hf) {B : Set β} :\n    (M.map f hf).Base B ↔ ∃ B₀, M.Base B₀ ∧ B = f '' B₀ := by\n  rw [base_iff_maximal_indep]\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · obtain ⟨B₀, hB₀, hbij⟩ := h.prop.exists_bijOn_of_map\n    refine ⟨B₀, hB₀.base_of_maximal fun J hJ hB₀J ↦ ?_, hbij.image_eq.symm⟩\n    rw [← hf.image_eq_image_iff hB₀.subset_ground hJ.subset_ground, hbij.image_eq]\n    exact h.eq_of_subset (hJ.map f hf) (hbij.image_eq ▸ image_subset f hB₀J)\n  rintro ⟨B, hB, rfl⟩\n  rw [maximal_subset_iff]\n  refine ⟨hB.indep.map f hf, fun I hI hBI ↦ ?_⟩\n  obtain ⟨I₀, hI₀, hbij⟩ := hI.exists_bijOn_of_map\n  rw [← hbij.image_eq, hf.image_subset_image_iff hB.subset_ground hI₀.subset_ground] at hBI\n  rw [hB.eq_of_subset_indep hI₀ hBI, hbij.image_eq]\n\n"}
{"name":"Matroid.Base.map","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nB : Set α\nhB : M.Base B\nf : α → β\nhf : Set.InjOn f M.E\n⊢ (M.map f hf).Base (Set.image f B)","decl":"lemma Base.map {B : Set α} (hB : M.Base B) {f : α → β} (hf) : (M.map f hf).Base (f '' B) := by\n  rw [map_base_iff]; exact ⟨B, hB, rfl⟩\n\n"}
{"name":"Matroid.map_dep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nM : Matroid α\nhf : Set.InjOn f M.E\nD : Set β\n⊢ Iff ((M.map f hf).Dep D) (Exists fun D₀ => And (M.Dep D₀) (Eq D (Set.image f D₀)))","decl":"lemma map_dep_iff {hf} {D : Set β} :\n    (M.map f hf).Dep D ↔ ∃ D₀, M.Dep D₀ ∧ D = f '' D₀ := by\n  simp only [Dep, map_indep_iff, not_exists, not_and, map_ground, subset_image_iff]\n  constructor\n  · rintro ⟨h, D₀, hD₀E, rfl⟩\n    exact ⟨D₀, ⟨fun hd ↦ h _ hd rfl, hD₀E⟩, rfl⟩\n  rintro ⟨D₀, ⟨hD₀, hD₀E⟩, rfl⟩\n  refine ⟨fun I hI h_eq ↦ ?_, ⟨_, hD₀E, rfl⟩⟩\n  rw [hf.image_eq_image_iff hD₀E hI.subset_ground] at h_eq\n  subst h_eq; contradiction\n\n"}
{"name":"Matroid.map_image_base_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nM : Matroid α\nhf : Set.InjOn f M.E\nB : Set α\nhB : HasSubset.Subset B M.E\n⊢ Iff ((M.map f hf).Base (Set.image f B)) (M.Base B)","decl":"lemma map_image_base_iff {hf} {B : Set α} (hB : B ⊆ M.E) :\n    (M.map f hf).Base (f '' B) ↔ M.Base B := by\n  rw [map_base_iff]\n  refine ⟨fun ⟨J, hJ, hIJ⟩ ↦ ?_, fun h ↦ ⟨B, h, rfl⟩⟩\n  rw [hf.image_eq_image_iff hB hJ.subset_ground] at hIJ; rwa [hIJ]\n\n"}
{"name":"Matroid.Basis.map","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nI : Set α\nM : Matroid α\nX : Set α\nhIX : M.Basis I X\nf : α → β\nhf : Set.InjOn f M.E\n⊢ (M.map f hf).Basis (Set.image f I) (Set.image f X)","decl":"lemma Basis.map {X : Set α} (hIX : M.Basis I X) {f : α → β} (hf) :\n    (M.map f hf).Basis (f '' I) (f '' X) := by\n  refine (hIX.indep.map f hf).basis_of_forall_insert (image_subset _ hIX.subset) ?_\n  rintro _ ⟨⟨e,he,rfl⟩, he'⟩\n  have hss := insert_subset (hIX.subset_ground he) hIX.indep.subset_ground\n  rw [← not_indep_iff (by simpa [← image_insert_eq] using image_subset f hss)]\n  simp only [map_indep_iff, not_exists, not_and]\n  intro J hJ hins\n  rw [← image_insert_eq, hf.image_eq_image_iff hss hJ.subset_ground] at hins\n  obtain rfl := hins\n  exact he' (mem_image_of_mem f (hIX.mem_of_insert_indep he hJ))\n\n"}
{"name":"Matroid.map_basis_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nI X : Set α\nf : α → β\nhf : Set.InjOn f M.E\nhI : HasSubset.Subset I M.E\nhX : HasSubset.Subset X M.E\n⊢ Iff ((M.map f hf).Basis (Set.image f I) (Set.image f X)) (M.Basis I X)","decl":"lemma map_basis_iff {I X : Set α} (f : α → β) (hf) (hI : I ⊆ M.E) (hX : X ⊆ M.E) :\n    (M.map f hf).Basis (f '' I) (f '' X) ↔ M.Basis I X := by\n  refine ⟨fun h ↦ ?_, fun h ↦ h.map hf⟩\n  obtain ⟨I', hI', hII'⟩ := map_indep_iff.1 h.indep\n  rw [hf.image_eq_image_iff hI hI'.subset_ground] at hII'\n  obtain rfl := hII'\n  have hss := (hf.image_subset_image_iff hI hX).1 h.subset\n  refine hI'.basis_of_maximal_subset hss (fun J hJ hIJ hJX ↦ ?_)\n  have hIJ' := h.eq_of_subset_indep (hJ.map f hf) (image_subset f hIJ) (image_subset f hJX)\n  rw [hf.image_eq_image_iff hI hJ.subset_ground] at hIJ'\n  exact hIJ'.symm.subset\n\n"}
{"name":"Matroid.map_basis_iff'","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nM : Matroid α\nI X : Set β\nhf : Set.InjOn f M.E\n⊢ Iff ((M.map f hf).Basis I X) (Exists fun I₀ => Exists fun X₀ => And (M.Basis I₀ X₀) (And (Eq I (Set.image f I₀)) (Eq X (Set.image f X₀))))","decl":"lemma map_basis_iff' {I X : Set β} {hf} :\n    (M.map f hf).Basis I X ↔ ∃ I₀ X₀, M.Basis I₀ X₀ ∧ I = f '' I₀ ∧ X = f '' X₀ := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · obtain ⟨I, hI, rfl⟩ := subset_image_iff.1 h.indep.subset_ground\n    obtain ⟨X, hX, rfl⟩ := subset_image_iff.1 h.subset_ground\n    rw [map_basis_iff _ _ hI hX] at h\n    exact ⟨I, X, h, rfl, rfl⟩\n  rintro ⟨I, X, hIX, rfl, rfl⟩\n  exact hIX.map hf\n\n"}
{"name":"Matroid.map_dual","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nM : Matroid α\nhf : Set.InjOn f M.E\n⊢ Eq (M.map f hf).dual (M.dual.map f hf)","decl":"@[simp] lemma map_dual {hf} : (M.map f hf)✶ = M✶.map f hf := by\n  apply ext_base (by simp)\n  simp only [dual_ground, map_ground, subset_image_iff, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff₂, dual_base_iff']\n  intro B hB\n  simp_rw [← hf.image_diff_subset hB, map_image_base_iff diff_subset,\n    map_image_base_iff (show B ⊆ M✶.E from hB), dual_base_iff hB, and_iff_left_iff_imp]\n  exact fun _ ↦ ⟨B, hB, rfl⟩\n\n"}
{"name":"Matroid.map_emptyOn","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq ((Matroid.emptyOn α).map f ⋯) (Matroid.emptyOn β)","decl":"@[simp] lemma map_emptyOn (f : α → β) : (emptyOn α).map f (by simp) = emptyOn β := by\n  simp [← ground_eq_empty_iff]\n\n"}
{"name":"Matroid.map_loopyOn","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nE : Set α\nf : α → β\nhf : Set.InjOn f (Matroid.loopyOn E).E\n⊢ Eq ((Matroid.loopyOn E).map f hf) (Matroid.loopyOn (Set.image f E))","decl":"@[simp] lemma map_loopyOn (f : α → β) (hf) : (loopyOn E).map f hf = loopyOn (f '' E) := by\n  simp [eq_loopyOn_iff]\n\n"}
{"name":"Matroid.map_freeOn","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nE : Set α\nf : α → β\nhf : Set.InjOn f (Matroid.freeOn E).E\n⊢ Eq ((Matroid.freeOn E).map f hf) (Matroid.freeOn (Set.image f E))","decl":"@[simp] lemma map_freeOn (f : α → β) (hf) : (freeOn E).map f hf = freeOn (f '' E) := by\n  rw [← dual_inj]; simp\n\n"}
{"name":"Matroid.map_id","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq (M.map id ⋯) M","decl":"@[simp] lemma map_id : M.map id (injOn_id M.E) = M := by\n  simp [ext_iff_indep]\n\n"}
{"name":"Matroid.map_comap","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nN : Matroid β\nf : α → β\nh_range : HasSubset.Subset N.E (Set.range f)\nhf : Set.InjOn f (Set.preimage f N.E)\n⊢ Eq ((N.comap f).map f hf) N","decl":"lemma map_comap {f : α → β} (h_range : N.E ⊆ range f) (hf : InjOn f (f ⁻¹' N.E)) :\n    (N.comap f).map f hf = N := by\n  refine ext_indep (by simpa [image_preimage_eq_iff]) ?_\n  simp only [map_ground, comap_ground_eq, map_indep_iff, comap_indep_iff, forall_subset_image_iff]\n  refine fun I hI ↦ ⟨fun ⟨I₀, ⟨hI₀, _⟩, hII₀⟩ ↦ ?_, fun h ↦ ⟨_, ⟨h, hf.mono hI⟩, rfl⟩⟩\n  suffices h : I₀ ⊆ f ⁻¹' N.E by rw [InjOn.image_eq_image_iff hf hI h] at hII₀; rwa [hII₀]\n  exact (subset_preimage_image f I₀).trans <| preimage_mono (f := f) hI₀.subset_ground\n\n"}
{"name":"Matroid.comap_map","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : α → β\nhf : Function.Injective f\n⊢ Eq ((M.map f ⋯).comap f) M","decl":"lemma comap_map {f : α → β} (hf : f.Injective) : (M.map f hf.injOn).comap f = M := by\n  simp [ext_iff_indep, preimage_image_eq _ hf, and_iff_left hf.injOn,\n    image_eq_image hf]\n\n"}
{"name":"Matroid.instNonemptyMap","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.Nonempty\nf : α → β\nhf : Set.InjOn f M.E\n⊢ (M.map f hf).Nonempty","decl":"instance [M.Nonempty] {f : α → β} (hf) : (M.map f hf).Nonempty :=\n  ⟨by simp [M.ground_nonempty]⟩\n\n"}
{"name":"Matroid.instFiniteMap","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.Finite\nf : α → β\nhf : Set.InjOn f M.E\n⊢ (M.map f hf).Finite","decl":"instance [M.Finite] {f : α → β} (hf) : (M.map f hf).Finite :=\n  ⟨M.ground_finite.image f⟩\n\n"}
{"name":"Matroid.instFinitaryMap","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.Finitary\nf : α → β\nhf : Set.InjOn f M.E\n⊢ (M.map f hf).Finitary","decl":"instance [M.Finitary] {f : α → β} (hf) : (M.map f hf).Finitary := by\n  refine ⟨fun I hI ↦ ?_⟩\n  simp only [map_indep_iff]\n  have h' : I ⊆ f '' M.E := by\n    intro e he\n    obtain ⟨I₀, hI₀, h_eq⟩ := hI {e} (by simpa) (by simp)\n    exact image_subset f hI₀.subset_ground <| h_eq.subset rfl\n  obtain ⟨I₀, hI₀E, rfl⟩ := subset_image_iff.1 h'\n  refine ⟨I₀, indep_of_forall_finite_subset_indep _ fun J₀ hJ₀I₀ hJ₀ ↦ ?_, rfl⟩\n  specialize hI (f '' J₀) (image_subset f hJ₀I₀) (hJ₀.image _)\n  rwa [map_image_indep_iff (hJ₀I₀.trans hI₀E)] at hI\n\n"}
{"name":"Matroid.instFiniteRkMap","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.FiniteRk\nf : α → β\nhf : Set.InjOn f M.E\n⊢ (M.map f hf).FiniteRk","decl":"instance [M.FiniteRk] {f : α → β} (hf) : (M.map f hf).FiniteRk :=\n  let ⟨_, hB⟩ := M.exists_base\n  (hB.map hf).finiteRk_of_finite (hB.finite.image _)\n\n"}
{"name":"Matroid.instRkPosMap","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.RkPos\nf : α → β\nhf : Set.InjOn f M.E\n⊢ (M.map f hf).RkPos","decl":"instance [M.RkPos] {f : α → β} (hf) : (M.map f hf).RkPos :=\n  let ⟨_, hB⟩ := M.exists_base\n  (hB.map hf).rkPos_of_nonempty (hB.nonempty.image _)\n\n"}
{"name":"Matroid.mapSetEquiv_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nE : Set β\ne : Equiv ↑M.E ↑E\nI : Set β\n⊢ Iff ((M.mapSetEquiv e).Indep I) (And (M.Indep (Set.image Subtype.val (Set.image (⇑e.symm) (Set.preimage Subtype.val I)))) (HasSubset.Subset I E))","decl":"@[simp] lemma mapSetEquiv_indep_iff (M : Matroid α) {E : Set β} (e : M.E ≃ E) {I : Set β} :\n    (M.mapSetEquiv e).Indep I ↔ M.Indep ↑(e.symm '' (E ↓∩ I)) ∧ I ⊆ E := Iff.rfl\n\n"}
{"name":"Matroid.mapSetEquiv.ground","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nE : Set β\ne : Equiv ↑M.E ↑E\n⊢ Eq (M.mapSetEquiv e).E E","decl":"@[simp] lemma mapSetEquiv.ground (M : Matroid α) {E : Set β} (e : M.E ≃ E) :\n    (M.mapSetEquiv e).E = E := rfl\n\n"}
{"name":"Matroid.mapEmbedding_ground_eq","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Function.Embedding α β\n⊢ Eq (M.mapEmbedding f).E (Set.image (⇑f) M.E)","decl":"@[simp] lemma mapEmbedding_ground_eq (M : Matroid α) (f : α ↪ β) :\n    (M.mapEmbedding f).E = f '' M.E := rfl\n\n"}
{"name":"Matroid.mapEmbedding_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Function.Embedding α β\nI : Set β\n⊢ Iff ((M.mapEmbedding f).Indep I) (And (M.Indep (Set.preimage (⇑f) I)) (HasSubset.Subset I (Set.range ⇑f)))","decl":"@[simp] lemma mapEmbedding_indep_iff {f : α ↪ β} {I : Set β} :\n    (M.mapEmbedding f).Indep I ↔ M.Indep (f ⁻¹' I) ∧ I ⊆ range f := by\n  rw [mapEmbedding, map_indep_iff]\n  refine ⟨?_, fun ⟨h,h'⟩ ↦ ⟨f ⁻¹' I, h, by rwa [eq_comm, image_preimage_eq_iff]⟩⟩\n  rintro ⟨I, hI, rfl⟩\n  rw [preimage_image_eq _ f.injective]\n  exact ⟨hI, image_subset_range _ _⟩\n\n"}
{"name":"Matroid.Indep.mapEmbedding","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nI : Set α\nM : Matroid α\nhI : M.Indep I\nf : Function.Embedding α β\n⊢ (M.mapEmbedding f).Indep (Set.image (⇑f) I)","decl":"lemma Indep.mapEmbedding (hI : M.Indep I) (f : α ↪ β) : (M.mapEmbedding f).Indep (f '' I) := by\n  simpa [preimage_image_eq I f.injective]\n\n"}
{"name":"Matroid.Base.mapEmbedding","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nB : Set α\nhB : M.Base B\nf : Function.Embedding α β\n⊢ (M.mapEmbedding f).Base (Set.image (⇑f) B)","decl":"lemma Base.mapEmbedding {B : Set α} (hB : M.Base B) (f : α ↪ β) :\n    (M.mapEmbedding f).Base (f '' B) := by\n  rw [Matroid.mapEmbedding, map_base_iff]\n  exact ⟨B, hB, rfl⟩\n\n"}
{"name":"Matroid.Basis.mapEmbedding","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nI : Set α\nM : Matroid α\nX : Set α\nhIX : M.Basis I X\nf : Function.Embedding α β\n⊢ (M.mapEmbedding f).Basis (Set.image (⇑f) I) (Set.image (⇑f) X)","decl":"lemma Basis.mapEmbedding {X : Set α} (hIX : M.Basis I X) (f : α ↪ β) :\n    (M.mapEmbedding f).Basis (f '' I) (f '' X) := by\n  apply hIX.map\n\n"}
{"name":"Matroid.mapEmbedding_base_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Function.Embedding α β\nB : Set β\n⊢ Iff ((M.mapEmbedding f).Base B) (And (M.Base (Set.preimage (⇑f) B)) (HasSubset.Subset B (Set.range ⇑f)))","decl":"@[simp] lemma mapEmbedding_base_iff {f : α ↪ β} {B : Set β} :\n    (M.mapEmbedding f).Base B ↔ M.Base (f ⁻¹' B) ∧ B ⊆ range f := by\n  rw [mapEmbedding, map_base_iff]\n  refine ⟨?_, fun ⟨h,h'⟩ ↦ ⟨f ⁻¹' B, h, by rwa [eq_comm, image_preimage_eq_iff]⟩⟩\n  rintro ⟨B, hB, rfl⟩\n  rw [preimage_image_eq _ f.injective]\n  exact ⟨hB, image_subset_range _ _⟩\n\n"}
{"name":"Matroid.mapEmbedding_basis_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Function.Embedding α β\nI X : Set β\n⊢ Iff ((M.mapEmbedding f).Basis I X) (And (M.Basis (Set.preimage (⇑f) I) (Set.preimage (⇑f) X)) (And (HasSubset.Subset I X) (HasSubset.Subset X (Set.range ⇑f))))","decl":"@[simp] lemma mapEmbedding_basis_iff {f : α ↪ β} {I X : Set β} :\n    (M.mapEmbedding f).Basis I X ↔ M.Basis (f ⁻¹' I) (f ⁻¹' X) ∧ I ⊆ X ∧ X ⊆ range f := by\n  rw [mapEmbedding, map_basis_iff']\n  refine ⟨?_, fun ⟨hb, hIX, hX⟩ ↦ ?_⟩\n  · rintro ⟨I, X, hIX, rfl, rfl⟩\n    simp [preimage_image_eq _ f.injective, image_subset f hIX.subset, hIX]\n  obtain ⟨X, rfl⟩ := subset_range_iff_exists_image_eq.1 hX\n  obtain ⟨I, -, rfl⟩ := subset_image_iff.1 hIX\n  exact ⟨I, X, by simpa [preimage_image_eq _ f.injective] using hb⟩\n\n"}
{"name":"Matroid.instNonemptyMapEmbedding","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.Nonempty\nf : Function.Embedding α β\n⊢ (M.mapEmbedding f).Nonempty","decl":"instance [M.Nonempty] {f : α ↪ β} : (M.mapEmbedding f).Nonempty :=\n  inferInstanceAs (M.map f f.injective.injOn).Nonempty\n\n"}
{"name":"Matroid.instFiniteMapEmbedding","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.Finite\nf : Function.Embedding α β\n⊢ (M.mapEmbedding f).Finite","decl":"instance [M.Finite] {f : α ↪ β} : (M.mapEmbedding f).Finite :=\n  inferInstanceAs (M.map f f.injective.injOn).Finite\n\n"}
{"name":"Matroid.instFinitaryMapEmbedding","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.Finitary\nf : Function.Embedding α β\n⊢ (M.mapEmbedding f).Finitary","decl":"instance [M.Finitary] {f : α ↪ β} : (M.mapEmbedding f).Finitary :=\n  inferInstanceAs (M.map f f.injective.injOn).Finitary\n\n"}
{"name":"Matroid.instFiniteRkMapEmbedding","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.FiniteRk\nf : Function.Embedding α β\n⊢ (M.mapEmbedding f).FiniteRk","decl":"instance [M.FiniteRk] {f : α ↪ β} : (M.mapEmbedding f).FiniteRk :=\n  inferInstanceAs (M.map f f.injective.injOn).FiniteRk\n\n"}
{"name":"Matroid.instRkPosMapEmbedding","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.RkPos\nf : Function.Embedding α β\n⊢ (M.mapEmbedding f).RkPos","decl":"instance [M.RkPos] {f : α ↪ β} : (M.mapEmbedding f).RkPos :=\n  inferInstanceAs (M.map f f.injective.injOn).RkPos\n\n"}
{"name":"Matroid.mapEquiv_ground_eq","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Equiv α β\n⊢ Eq (M.mapEquiv f).E (Set.image (⇑f) M.E)","decl":"@[simp] lemma mapEquiv_ground_eq (M : Matroid α) (f : α ≃ β) :\n    (M.mapEquiv f).E = f '' M.E := rfl\n\n"}
{"name":"Matroid.mapEquiv_eq_map","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Equiv α β\n⊢ Eq (M.mapEquiv f) (M.map ⇑f ⋯)","decl":"lemma mapEquiv_eq_map (f : α ≃ β) : M.mapEquiv f = M.map f f.injective.injOn := rfl\n\n"}
{"name":"Matroid.mapEquiv_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Equiv α β\nI : Set β\n⊢ Iff ((M.mapEquiv f).Indep I) (M.Indep (Set.image (⇑f.symm) I))","decl":"@[simp] lemma mapEquiv_indep_iff {I : Set β} : (M.mapEquiv f).Indep I ↔ M.Indep (f.symm '' I) := by\n  rw [mapEquiv_eq_map, map_indep_iff]\n  exact ⟨by rintro ⟨I, hI, rfl⟩; simpa, fun h ↦ ⟨_, h, by simp⟩⟩\n\n"}
{"name":"Matroid.mapEquiv_dep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Equiv α β\nD : Set β\n⊢ Iff ((M.mapEquiv f).Dep D) (M.Dep (Set.image (⇑f.symm) D))","decl":"@[simp] lemma mapEquiv_dep_iff {D : Set β} : (M.mapEquiv f).Dep D ↔ M.Dep (f.symm '' D) := by\n  rw [mapEquiv_eq_map, map_dep_iff]\n  exact ⟨by rintro ⟨I, hI, rfl⟩; simpa, fun h ↦ ⟨_, h, by simp⟩⟩\n\n"}
{"name":"Matroid.mapEquiv_base_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\nf : Equiv α β\nB : Set β\n⊢ Iff ((M.mapEquiv f).Base B) (M.Base (Set.image (⇑f.symm) B))","decl":"@[simp] lemma mapEquiv_base_iff {B : Set β} : (M.mapEquiv f).Base B ↔ M.Base (f.symm '' B) := by\n  rw [mapEquiv_eq_map, map_base_iff]\n  exact ⟨by rintro ⟨I, hI, rfl⟩; simpa, fun h ↦ ⟨_, h, by simp⟩⟩\n\n"}
{"name":"Matroid.mapEquiv_basis_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_3\nβ : Type u_4\nM : Matroid α\nf : Equiv α β\nI X : Set β\n⊢ Iff ((M.mapEquiv f).Basis I X) (M.Basis (Set.image (⇑f.symm) I) (Set.image (⇑f.symm) X))","decl":"@[simp] lemma mapEquiv_basis_iff {α β : Type*} {M : Matroid α} (f : α ≃ β) {I X : Set β} :\n    (M.mapEquiv f).Basis I X ↔ M.Basis (f.symm '' I) (f.symm '' X) := by\n  rw [mapEquiv_eq_map, map_basis_iff']\n  refine ⟨fun h ↦ ?_, fun h ↦ ⟨_, _, h, by simp, by simp⟩⟩\n  obtain ⟨I, X, hIX, rfl, rfl⟩ := h\n  simpa\n\n"}
{"name":"Matroid.instNonemptyMapEquiv","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.Nonempty\nf : Equiv α β\n⊢ (M.mapEquiv f).Nonempty","decl":"instance [M.Nonempty] {f : α ≃ β} : (M.mapEquiv f).Nonempty :=\n  inferInstanceAs (M.map f f.injective.injOn).Nonempty\n\n"}
{"name":"Matroid.instFiniteMapEquiv","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.Finite\nf : Equiv α β\n⊢ (M.mapEquiv f).Finite","decl":"instance [M.Finite] {f : α ≃ β} : (M.mapEquiv f).Finite :=\n  inferInstanceAs (M.map f f.injective.injOn).Finite\n\n"}
{"name":"Matroid.instFinitaryMapEquiv","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.Finitary\nf : Equiv α β\n⊢ (M.mapEquiv f).Finitary","decl":"instance [M.Finitary] {f : α ≃ β} : (M.mapEquiv f).Finitary :=\n  inferInstanceAs (M.map f f.injective.injOn).Finitary\n\n"}
{"name":"Matroid.instFiniteRkMapEquiv","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.FiniteRk\nf : Equiv α β\n⊢ (M.mapEquiv f).FiniteRk","decl":"instance [M.FiniteRk] {f : α ≃ β} : (M.mapEquiv f).FiniteRk :=\n  inferInstanceAs (M.map f f.injective.injOn).FiniteRk\n\n"}
{"name":"Matroid.instRkPosMapEquiv","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Matroid α\ninst✝ : M.RkPos\nf : Equiv α β\n⊢ (M.mapEquiv f).RkPos","decl":"instance [M.RkPos] {f : α ≃ β} : (M.mapEquiv f).RkPos :=\n  inferInstanceAs (M.map f f.injective.injOn).RkPos\n\n"}
{"name":"Matroid.restrictSubtype_ground","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nX : Set α\nM : Matroid α\n⊢ Eq (M.restrictSubtype X).E Set.univ","decl":"@[simp] lemma restrictSubtype_ground : (M.restrictSubtype X).E = univ := by\n  simp [restrictSubtype]\n\n"}
{"name":"Matroid.restrictSubtype_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nX : Set α\nM : Matroid α\nI : Set ↑X\n⊢ Iff ((M.restrictSubtype X).Indep I) (M.Indep ↑I)","decl":"@[simp] lemma restrictSubtype_indep_iff {I : Set X} :\n    (M.restrictSubtype X).Indep I ↔ M.Indep ((↑) '' I) := by\n  simp [restrictSubtype, Subtype.val_injective.injOn]\n\n"}
{"name":"Matroid.restrictSubtype_indep_iff_of_subset","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nX I : Set α\nM : Matroid α\nhIX : HasSubset.Subset I X\n⊢ Iff ((M.restrictSubtype X).Indep (Set.preimage Subtype.val I)) (M.Indep I)","decl":"lemma restrictSubtype_indep_iff_of_subset (hIX : I ⊆ X) :\n    (M.restrictSubtype X).Indep (X ↓∩ I) ↔ M.Indep I := by\n  rw [restrictSubtype_indep_iff, image_preimage_eq_iff.2]; simpa\n\n"}
{"name":"Matroid.restrictSubtype_inter_indep_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nX I : Set α\nM : Matroid α\n⊢ Iff ((M.restrictSubtype X).Indep (Set.preimage Subtype.val I)) (M.Indep (Inter.inter X I))","decl":"lemma restrictSubtype_inter_indep_iff :\n    (M.restrictSubtype X).Indep (X ↓∩ I) ↔ M.Indep (X ∩ I) := by\n  simp [restrictSubtype, Subtype.val_injective.injOn]\n\n"}
{"name":"Matroid.restrictSubtype_basis_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\nY : Set α\nI X : Set ↑Y\n⊢ Iff ((M.restrictSubtype Y).Basis I X) (M.Basis' (Set.image Subtype.val I) (Set.image Subtype.val X))","decl":"lemma restrictSubtype_basis_iff {Y : Set α} {I X : Set Y} :\n    (M.restrictSubtype Y).Basis I X ↔ M.Basis' I X := by\n  rw [restrictSubtype, comap_basis_iff, and_iff_right Subtype.val_injective.injOn,\n    and_iff_left_of_imp, basis_restrict_iff', basis'_iff_basis_inter_ground]\n  · simp\n  exact fun h ↦ (image_subset_image_iff Subtype.val_injective).1 h.subset\n\n"}
{"name":"Matroid.restrictSubtype_base_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nX : Set α\nM : Matroid α\nB : Set ↑X\n⊢ Iff ((M.restrictSubtype X).Base B) (M.Basis' (Set.image Subtype.val B) X)","decl":"lemma restrictSubtype_base_iff {B : Set X} : (M.restrictSubtype X).Base B ↔ M.Basis' B X := by\n  rw [restrictSubtype, comap_base_iff]\n  simp [Subtype.val_injective.injOn, Subset.rfl, basis_restrict_iff', basis'_iff_basis_inter_ground]\n\n"}
{"name":"Matroid.restrictSubtype_ground_base_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set ↑M.E\n⊢ Iff ((M.restrictSubtype M.E).Base B) (M.Base (Set.image Subtype.val B))","decl":"@[simp] lemma restrictSubtype_ground_base_iff {B : Set M.E} :\n    (M.restrictSubtype M.E).Base B ↔ M.Base B := by\n  rw [restrictSubtype_base_iff, basis'_iff_basis, basis_ground_iff]\n\n"}
{"name":"Matroid.restrictSubtype_ground_basis_iff","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set ↑M.E\n⊢ Iff ((M.restrictSubtype M.E).Basis I X) (M.Basis (Set.image Subtype.val I) (Set.image Subtype.val X))","decl":"@[simp] lemma restrictSubtype_ground_basis_iff {I X : Set M.E} :\n    (M.restrictSubtype M.E).Basis I X ↔ M.Basis I X := by\n  rw [restrictSubtype_basis_iff, basis'_iff_basis]\n\n"}
{"name":"Matroid.eq_of_restrictSubtype_eq","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nE : Set α\nM N : Matroid α\nhM : Eq M.E E\nhN : Eq N.E E\nh : Eq (M.restrictSubtype E) (N.restrictSubtype E)\n⊢ Eq M N","decl":"lemma eq_of_restrictSubtype_eq {N : Matroid α} (hM : M.E = E) (hN : N.E = E)\n    (h : M.restrictSubtype E = N.restrictSubtype E) : M = N := by\n  subst hM\n  refine ext_indep (by rw [hN]) (fun I hI ↦ ?_)\n  rwa [← restrictSubtype_indep_iff_of_subset hI, h, restrictSubtype_indep_iff_of_subset]\n\n"}
{"name":"Matroid.restrictSubtype_dual","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq (M.restrictSubtype M.E).dual (M.dual.restrictSubtype M.E)","decl":"@[simp] lemma restrictSubtype_dual : (M.restrictSubtype M.E)✶ = M✶.restrictSubtype M.E := by\n  rw [restrictSubtype, ← comapOn_preimage_eq, comapOn_dual_eq_of_bijOn, restrict_ground_eq_self,\n    ← dual_ground, comapOn_preimage_eq, restrictSubtype, restrict_ground_eq_self]\n  exact ⟨by simp [MapsTo], Subtype.val_injective.injOn, by simp [SurjOn, Subset.rfl]⟩\n\n"}
{"name":"Matroid.restrictSubtype_dual'","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nE : Set α\nM : Matroid α\nhM : Eq M.E E\n⊢ Eq (M.restrictSubtype E).dual (M.dual.restrictSubtype E)","decl":"lemma restrictSubtype_dual' (hM : M.E = E) : (M.restrictSubtype E)✶ = M✶.restrictSubtype E := by\n  rw [← hM, restrictSubtype_dual]\n\n"}
{"name":"Matroid.map_val_restrictSubtype_eq","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\n⊢ Eq ((M.restrictSubtype X).map Subtype.val ⋯) (M.restrict X)","decl":"/-- `M.restrictSubtype X` is isomorphic to `M ↾ X`. -/\n@[simp] lemma map_val_restrictSubtype_eq (M : Matroid α) (X : Set α) :\n    (M.restrictSubtype X).map (↑) Subtype.val_injective.injOn = M ↾ X := by\n  simp [restrictSubtype, map_comap, Subset.rfl]\n\n"}
{"name":"Matroid.map_val_restrictSubtype_ground_eq","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq ((M.restrictSubtype M.E).map Subtype.val ⋯) M","decl":"/-- `M.restrictSubtype M.E` is isomorphic to `M`. -/\nlemma map_val_restrictSubtype_ground_eq (M : Matroid α) :\n    (M.restrictSubtype M.E).map (↑) Subtype.val_injective.injOn = M := by\n  simp\n\n"}
{"name":"Matroid.instFinitaryElemRestrictSubtype","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Finitary\nX : Set α\n⊢ (M.restrictSubtype X).Finitary","decl":"instance [M.Finitary] {X : Set α} : (M.restrictSubtype X).Finitary := by\n  rw [restrictSubtype]; infer_instance\n\n"}
{"name":"Matroid.instFiniteRkElemRestrictSubtype","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.FiniteRk\nX : Set α\n⊢ (M.restrictSubtype X).FiniteRk","decl":"instance [M.FiniteRk] {X : Set α} : (M.restrictSubtype X).FiniteRk := by\n  rw [restrictSubtype]; infer_instance\n\n"}
{"name":"Matroid.instFiniteElemERestrictSubtype","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Finite\n⊢ (M.restrictSubtype M.E).Finite","decl":"instance [M.Finite] : (M.restrictSubtype M.E).Finite :=\n  have := M.ground_finite.to_subtype\n  ⟨Finite.ground_finite⟩\n\n"}
{"name":"Matroid.instNonemptyElemERestrictSubtype","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Nonempty\n⊢ (M.restrictSubtype M.E).Nonempty","decl":"instance [M.Nonempty] : (M.restrictSubtype M.E).Nonempty :=\n  have := M.ground_nonempty.coe_sort\n  ⟨by simp⟩\n\n"}
{"name":"Matroid.instRkPosElemERestrictSubtype","module":"Mathlib.Data.Matroid.Map","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.RkPos\n⊢ (M.restrictSubtype M.E).RkPos","decl":"instance [M.RkPos] : (M.restrictSubtype M.E).RkPos := by\n  obtain ⟨B, hB⟩ := (M.restrictSubtype M.E).exists_base\n  have hB' : M.Base ↑B := by simpa using hB.map Subtype.val_injective.injOn\n  exact hB.rkPos_of_nonempty <| by simpa using hB'.nonempty\n\n"}
