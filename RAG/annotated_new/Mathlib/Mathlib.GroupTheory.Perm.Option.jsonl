{"name":"Equiv.optionCongr_one","module":"Mathlib.GroupTheory.Perm.Option","initialProofState":"α : Type u_1\n⊢ Eq (Equiv.optionCongr 1) 1","decl":"@[simp]\ntheorem Equiv.optionCongr_one {α : Type*} : (1 : Perm α).optionCongr = 1 :=\n  Equiv.optionCongr_refl\n\n"}
{"name":"Equiv.optionCongr_swap","module":"Mathlib.GroupTheory.Perm.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : α\n⊢ Eq (Equiv.optionCongr (Equiv.swap x y)) (Equiv.swap (Option.some x) (Option.some y))","decl":"@[simp]\ntheorem Equiv.optionCongr_swap {α : Type*} [DecidableEq α] (x y : α) :\n    optionCongr (swap x y) = swap (some x) (some y) := by\n  ext (_ | i)\n  · simp [swap_apply_of_ne_of_ne]\n  · by_cases hx : i = x\n    · simp only [hx, optionCongr_apply, Option.map_some', swap_apply_left, Option.mem_def,\n             Option.some.injEq]\n    by_cases hy : i = y <;> simp [hx, hy, swap_apply_of_ne_of_ne]\n\n"}
{"name":"Equiv.optionCongr_sign","module":"Mathlib.GroupTheory.Perm.Option","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ne : Equiv.Perm α\n⊢ Eq (Equiv.Perm.sign (Equiv.optionCongr e)) (Equiv.Perm.sign e)","decl":"@[simp]\ntheorem Equiv.optionCongr_sign {α : Type*} [DecidableEq α] [Fintype α] (e : Perm α) :\n    Perm.sign e.optionCongr = Perm.sign e := by\n  refine Perm.swap_induction_on e ?_ ?_\n  · simp [Perm.one_def]\n  · intro f x y hne h\n    simp [h, hne, Perm.mul_def, ← Equiv.optionCongr_trans]\n\n"}
{"name":"map_equiv_removeNone","module":"Mathlib.GroupTheory.Perm.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nσ : Equiv.Perm (Option α)\n⊢ Eq (Equiv.removeNone σ).optionCongr (HMul.hMul (Equiv.swap Option.none (σ Option.none)) σ)","decl":"@[simp]\ntheorem map_equiv_removeNone {α : Type*} [DecidableEq α] (σ : Perm (Option α)) :\n    (removeNone σ).optionCongr = swap none (σ none) * σ := by\n  ext1 x\n  have : Option.map (⇑(removeNone σ)) x = (swap none (σ none)) (σ x) := by\n    cases' x with x\n    · simp\n    · cases h : σ (some _)\n      · simp [removeNone_none _ h]\n      · have hn : σ (some x) ≠ none := by simp [h]\n        have hσn : σ (some x) ≠ σ none := σ.injective.ne (by simp)\n        simp [removeNone_some _ ⟨_, h⟩, ← h, swap_apply_of_ne_of_ne hn hσn]\n  simpa using this\n\n"}
{"name":"Equiv.Perm.decomposeOption_symm_apply","module":"Mathlib.GroupTheory.Perm.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ni : Prod (Option α) (Equiv.Perm α)\n⊢ Eq (Equiv.Perm.decomposeOption.symm i) (HMul.hMul (Equiv.swap Option.none i.1) (Equiv.optionCongr i.2))","decl":"/-- Permutations of `Option α` are equivalent to fixing an\n`Option α` and permuting the remaining with a `Perm α`.\nThe fixed `Option α` is swapped with `none`. -/\n@[simps]\ndef Equiv.Perm.decomposeOption {α : Type*} [DecidableEq α] :\n    Perm (Option α) ≃ Option α × Perm α where\n  toFun σ := (σ none, removeNone σ)\n  invFun i := swap none i.1 * i.2.optionCongr\n  left_inv σ := by simp\n  right_inv := fun ⟨x, σ⟩ => by\n    have : removeNone (swap none x * σ.optionCongr) = σ :=\n      Equiv.optionCongr_injective (by simp [← mul_assoc])\n    simp [← Perm.eq_inv_iff_eq, this]\n\n"}
{"name":"Equiv.Perm.decomposeOption_apply","module":"Mathlib.GroupTheory.Perm.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nσ : Equiv.Perm (Option α)\n⊢ Eq (Equiv.Perm.decomposeOption σ) { fst := σ Option.none, snd := Equiv.removeNone σ }","decl":"/-- Permutations of `Option α` are equivalent to fixing an\n`Option α` and permuting the remaining with a `Perm α`.\nThe fixed `Option α` is swapped with `none`. -/\n@[simps]\ndef Equiv.Perm.decomposeOption {α : Type*} [DecidableEq α] :\n    Perm (Option α) ≃ Option α × Perm α where\n  toFun σ := (σ none, removeNone σ)\n  invFun i := swap none i.1 * i.2.optionCongr\n  left_inv σ := by simp\n  right_inv := fun ⟨x, σ⟩ => by\n    have : removeNone (swap none x * σ.optionCongr) = σ :=\n      Equiv.optionCongr_injective (by simp [← mul_assoc])\n    simp [← Perm.eq_inv_iff_eq, this]\n\n"}
{"name":"Equiv.Perm.decomposeOption_symm_of_none_apply","module":"Mathlib.GroupTheory.Perm.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ne : Equiv.Perm α\ni : Option α\n⊢ Eq ((Equiv.Perm.decomposeOption.symm { fst := Option.none, snd := e }) i) (Option.map (⇑e) i)","decl":"theorem Equiv.Perm.decomposeOption_symm_of_none_apply {α : Type*} [DecidableEq α] (e : Perm α)\n    (i : Option α) : Equiv.Perm.decomposeOption.symm (none, e) i = i.map e := by simp\n\n"}
{"name":"Equiv.Perm.decomposeOption_symm_sign","module":"Mathlib.GroupTheory.Perm.Option","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ne : Equiv.Perm α\n⊢ Eq (Equiv.Perm.sign (Equiv.Perm.decomposeOption.symm { fst := Option.none, snd := e })) (Equiv.Perm.sign e)","decl":"theorem Equiv.Perm.decomposeOption_symm_sign {α : Type*} [DecidableEq α] [Fintype α] (e : Perm α) :\n    Perm.sign (Equiv.Perm.decomposeOption.symm (none, e)) = Perm.sign e := by simp\n\n"}
{"name":"Finset.univ_perm_option","module":"Mathlib.GroupTheory.Perm.Option","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq Finset.univ (Finset.map Equiv.Perm.decomposeOption.symm.toEmbedding Finset.univ)","decl":"/-- The set of all permutations of `Option α` can be constructed by augmenting the set of\npermutations of `α` by each element of `Option α` in turn. -/\ntheorem Finset.univ_perm_option {α : Type*} [DecidableEq α] [Fintype α] :\n    @Finset.univ (Perm <| Option α) _ =\n      (Finset.univ : Finset <| Option α × Perm α).map Equiv.Perm.decomposeOption.symm.toEmbedding :=\n  (Finset.univ_map_equiv_to_embedding _).symm\n"}
