{"name":"IsPrimePow.minFac_pow_factorization_eq","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\nhn : IsPrimePow n\n⊢ Eq (HPow.hPow n.minFac (n.factorization n.minFac)) n","decl":"theorem IsPrimePow.minFac_pow_factorization_eq {n : ℕ} (hn : IsPrimePow n) :\n    n.minFac ^ n.factorization n.minFac = n := by\n  obtain ⟨p, k, hp, hk, rfl⟩ := hn\n  rw [← Nat.prime_iff] at hp\n  rw [hp.pow_minFac hk.ne', hp.factorization_pow, Finsupp.single_eq_same]\n\n"}
{"name":"isPrimePow_of_minFac_pow_factorization_eq","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\nh : Eq (HPow.hPow n.minFac (n.factorization n.minFac)) n\nhn : Ne n 1\n⊢ IsPrimePow n","decl":"theorem isPrimePow_of_minFac_pow_factorization_eq {n : ℕ}\n    (h : n.minFac ^ n.factorization n.minFac = n) (hn : n ≠ 1) : IsPrimePow n := by\n  rcases eq_or_ne n 0 with (rfl | hn')\n  · simp_all\n  refine ⟨_, _, (Nat.minFac_prime hn).prime, ?_, h⟩\n  simp [pos_iff_ne_zero, ← Finsupp.mem_support_iff, Nat.support_factorization, hn',\n    Nat.minFac_prime hn, Nat.minFac_dvd]\n\n"}
{"name":"isPrimePow_iff_minFac_pow_factorization_eq","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\nhn : Ne n 1\n⊢ Iff (IsPrimePow n) (Eq (HPow.hPow n.minFac (n.factorization n.minFac)) n)","decl":"theorem isPrimePow_iff_minFac_pow_factorization_eq {n : ℕ} (hn : n ≠ 1) :\n    IsPrimePow n ↔ n.minFac ^ n.factorization n.minFac = n :=\n  ⟨fun h => h.minFac_pow_factorization_eq, fun h => isPrimePow_of_minFac_pow_factorization_eq h hn⟩\n\n"}
{"name":"isPrimePow_iff_factorization_eq_single","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\n⊢ Iff (IsPrimePow n) (Exists fun p => Exists fun k => And (LT.lt 0 k) (Eq n.factorization (Finsupp.single p k)))","decl":"theorem isPrimePow_iff_factorization_eq_single {n : ℕ} :\n    IsPrimePow n ↔ ∃ p k : ℕ, 0 < k ∧ n.factorization = Finsupp.single p k := by\n  rw [isPrimePow_nat_iff]\n  refine exists₂_congr fun p k => ?_\n  constructor\n  · rintro ⟨hp, hk, hn⟩\n    exact ⟨hk, by rw [← hn, Nat.Prime.factorization_pow hp]⟩\n  · rintro ⟨hk, hn⟩\n    have hn0 : n ≠ 0 := by\n      rintro rfl\n      simp_all only [Finsupp.single_eq_zero, eq_comm, Nat.factorization_zero, hk.ne']\n    rw [Nat.eq_pow_of_factorization_eq_single hn0 hn]\n    exact ⟨Nat.prime_of_mem_primeFactors <|\n      Finsupp.mem_support_iff.2 (by simp [hn, hk.ne'] : n.factorization p ≠ 0), hk, rfl⟩\n\n"}
{"name":"isPrimePow_iff_card_primeFactors_eq_one","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\n⊢ Iff (IsPrimePow n) (Eq n.primeFactors.card 1)","decl":"theorem isPrimePow_iff_card_primeFactors_eq_one {n : ℕ} :\n    IsPrimePow n ↔ n.primeFactors.card = 1 := by\n  simp_rw [isPrimePow_iff_factorization_eq_single, ← Nat.support_factorization,\n    Finsupp.card_support_eq_one', pos_iff_ne_zero]\n\n"}
{"name":"IsPrimePow.exists_ordCompl_eq_one","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\nh : IsPrimePow n\n⊢ Exists fun p => And (Nat.Prime p) (Eq (HDiv.hDiv n (HPow.hPow p (n.factorization p))) 1)","decl":"theorem IsPrimePow.exists_ordCompl_eq_one {n : ℕ} (h : IsPrimePow n) :\n    ∃ p : ℕ, p.Prime ∧ ordCompl[p] n = 1 := by\n  rcases eq_or_ne n 0 with (rfl | hn0); · cases not_isPrimePow_zero h\n  rcases isPrimePow_iff_factorization_eq_single.mp h with ⟨p, k, hk0, h1⟩\n  rcases em' p.Prime with (pp | pp)\n  · refine absurd ?_ hk0.ne'\n    simp [← Nat.factorization_eq_zero_of_non_prime n pp, h1]\n  refine ⟨p, pp, ?_⟩\n  refine Nat.eq_of_factorization_eq (Nat.ordCompl_pos p hn0).ne' (by simp) fun q => ?_\n  rw [Nat.factorization_ordCompl n p, h1]\n  simp\n\n"}
{"name":"IsPrimePow.exists_ord_compl_eq_one","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\nh : IsPrimePow n\n⊢ Exists fun p => And (Nat.Prime p) (Eq (HDiv.hDiv n (HPow.hPow p (n.factorization p))) 1)","decl":"@[deprecated (since := \"2024-10-24\")]\nalias IsPrimePow.exists_ord_compl_eq_one := IsPrimePow.exists_ordCompl_eq_one\n\n"}
{"name":"exists_ordCompl_eq_one_iff_isPrimePow","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\nhn : Ne n 1\n⊢ Iff (IsPrimePow n) (Exists fun p => And (Nat.Prime p) (Eq (HDiv.hDiv n (HPow.hPow p (n.factorization p))) 1))","decl":"theorem exists_ordCompl_eq_one_iff_isPrimePow {n : ℕ} (hn : n ≠ 1) :\n    IsPrimePow n ↔ ∃ p : ℕ, p.Prime ∧ ordCompl[p] n = 1 := by\n  refine ⟨fun h => IsPrimePow.exists_ordCompl_eq_one h, fun h => ?_⟩\n  rcases h with ⟨p, pp, h⟩\n  rw [isPrimePow_nat_iff]\n  rw [← Nat.eq_of_dvd_of_div_eq_one (Nat.ordProj_dvd n p) h] at hn ⊢\n  refine ⟨p, n.factorization p, pp, ?_, by simp⟩\n  contrapose! hn\n  simp [Nat.le_zero.1 hn]\n\n"}
{"name":"exists_ord_compl_eq_one_iff_isPrimePow","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\nhn : Ne n 1\n⊢ Iff (IsPrimePow n) (Exists fun p => And (Nat.Prime p) (Eq (HDiv.hDiv n (HPow.hPow p (n.factorization p))) 1))","decl":"@[deprecated (since := \"2024-10-24\")]\nalias exists_ord_compl_eq_one_iff_isPrimePow := exists_ordCompl_eq_one_iff_isPrimePow\n\n"}
{"name":"isPrimePow_iff_unique_prime_dvd","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\n⊢ Iff (IsPrimePow n) (ExistsUnique fun p => And (Nat.Prime p) (Dvd.dvd p n))","decl":"/-- An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime\ndividing it. -/\ntheorem isPrimePow_iff_unique_prime_dvd {n : ℕ} : IsPrimePow n ↔ ∃! p : ℕ, p.Prime ∧ p ∣ n := by\n  rw [isPrimePow_nat_iff]\n  constructor\n  · rintro ⟨p, k, hp, hk, rfl⟩\n    refine ⟨p, ⟨hp, dvd_pow_self _ hk.ne'⟩, ?_⟩\n    rintro q ⟨hq, hq'⟩\n    exact (Nat.prime_dvd_prime_iff_eq hq hp).1 (hq.dvd_of_dvd_pow hq')\n  rintro ⟨p, ⟨hp, hn⟩, hq⟩\n  rcases eq_or_ne n 0 with (rfl | hn₀)\n  · cases (hq 2 ⟨Nat.prime_two, dvd_zero 2⟩).trans (hq 3 ⟨Nat.prime_three, dvd_zero 3⟩).symm\n  refine ⟨p, n.factorization p, hp, hp.factorization_pos_of_dvd hn₀ hn, ?_⟩\n  simp only [and_imp] at hq\n  apply Nat.dvd_antisymm (Nat.ordProj_dvd _ _)\n  -- We need to show n ∣ p ^ n.factorization p\n  apply Nat.dvd_of_primeFactorsList_subperm hn₀\n  rw [hp.primeFactorsList_pow, List.subperm_ext_iff]\n  intro q hq'\n  rw [Nat.mem_primeFactorsList hn₀] at hq'\n  cases hq _ hq'.1 hq'.2\n  simp\n\n"}
{"name":"isPrimePow_pow_iff","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n k : Nat\nhk : Ne k 0\n⊢ Iff (IsPrimePow (HPow.hPow n k)) (IsPrimePow n)","decl":"theorem isPrimePow_pow_iff {n k : ℕ} (hk : k ≠ 0) : IsPrimePow (n ^ k) ↔ IsPrimePow n := by\n  simp only [isPrimePow_iff_unique_prime_dvd]\n  apply existsUnique_congr\n  simp only [and_congr_right_iff]\n  intro p hp\n  exact ⟨hp.dvd_of_dvd_pow, fun t => t.trans (dvd_pow_self _ hk)⟩\n\n"}
{"name":"Nat.Coprime.isPrimePow_dvd_mul","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n a b : Nat\nhab : a.Coprime b\nhn : IsPrimePow n\n⊢ Iff (Dvd.dvd n (HMul.hMul a b)) (Or (Dvd.dvd n a) (Dvd.dvd n b))","decl":"theorem Nat.Coprime.isPrimePow_dvd_mul {n a b : ℕ} (hab : Nat.Coprime a b) (hn : IsPrimePow n) :\n    n ∣ a * b ↔ n ∣ a ∨ n ∣ b := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp only [Nat.coprime_zero_left] at hab\n    simp [hab, Finset.filter_singleton, not_isPrimePow_one]\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simp only [Nat.coprime_zero_right] at hab\n    simp [hab, Finset.filter_singleton, not_isPrimePow_one]\n  refine\n    ⟨?_, fun h =>\n      Or.elim h (fun i => i.trans ((@dvd_mul_right a b a hab).mpr (dvd_refl a)))\n          fun i => i.trans ((@dvd_mul_left a b b hab.symm).mpr (dvd_refl b))⟩\n  obtain ⟨p, k, hp, _, rfl⟩ := (isPrimePow_nat_iff _).1 hn\n  simp only [hp.pow_dvd_iff_le_factorization (mul_ne_zero ha hb), Nat.factorization_mul ha hb,\n    hp.pow_dvd_iff_le_factorization ha, hp.pow_dvd_iff_le_factorization hb, Pi.add_apply,\n    Finsupp.coe_add]\n  have : a.factorization p = 0 ∨ b.factorization p = 0 := by\n    rw [← Finsupp.not_mem_support_iff, ← Finsupp.not_mem_support_iff, ← not_and_or, ←\n      Finset.mem_inter]\n    intro t -- Porting note: used to be `exact` below, but the definition of `∈` has changed.\n    simpa using hab.disjoint_primeFactors.le_bot t\n  cases' this with h h <;> simp [h, imp_or]\n\n"}
{"name":"Nat.mul_divisors_filter_prime_pow","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"a b : Nat\nhab : a.Coprime b\n⊢ Eq (Finset.filter IsPrimePow (HMul.hMul a b).divisors) (Finset.filter IsPrimePow (Union.union a.divisors b.divisors))","decl":"theorem Nat.mul_divisors_filter_prime_pow {a b : ℕ} (hab : a.Coprime b) :\n    (a * b).divisors.filter IsPrimePow = (a.divisors ∪ b.divisors).filter IsPrimePow := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp only [Nat.coprime_zero_left] at hab\n    simp [hab, Finset.filter_singleton, not_isPrimePow_one]\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simp only [Nat.coprime_zero_right] at hab\n    simp [hab, Finset.filter_singleton, not_isPrimePow_one]\n  ext n\n  simp only [ha, hb, Finset.mem_union, Finset.mem_filter, Nat.mul_eq_zero, and_true, Ne,\n    and_congr_left_iff, not_false_iff, Nat.mem_divisors, or_self_iff]\n  apply hab.isPrimePow_dvd_mul\n\n"}
{"name":"IsPrimePow.factorization_minFac_ne_zero","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\nhn : IsPrimePow n\n⊢ Ne (n.factorization n.minFac) 0","decl":"lemma IsPrimePow.factorization_minFac_ne_zero {n : ℕ} (hn : IsPrimePow n) :\n    n.factorization n.minFac ≠ 0 := by\n  refine mt (Nat.factorization_eq_zero_iff _ _).mp ?_\n  push_neg\n  exact ⟨n.minFac_prime hn.ne_one, n.minFac_dvd, hn.ne_zero⟩\n\n"}
{"name":"Nat.Primes.prodNatEquiv_apply","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"p : Nat.Primes\nk : Nat\n⊢ Eq (Nat.Primes.prodNatEquiv { fst := p, snd := k }) ⟨HPow.hPow (↑p) (HAdd.hAdd k 1), ⋯⟩","decl":"@[simp]\nlemma Nat.Primes.prodNatEquiv_apply (p : Nat.Primes) (k : ℕ) :\n    prodNatEquiv (p, k) = ⟨p ^ (k + 1), p, k + 1, prime_iff.mp p.prop, k.add_one_pos, rfl⟩ := by\n  rfl\n\n"}
{"name":"Nat.Primes.coe_prodNatEquiv_apply","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"p : Nat.Primes\nk : Nat\n⊢ Eq (↑(Nat.Primes.prodNatEquiv { fst := p, snd := k })) (HPow.hPow (↑p) (HAdd.hAdd k 1))","decl":"@[simp]\nlemma Nat.Primes.coe_prodNatEquiv_apply (p : Nat.Primes) (k : ℕ) :\n    (prodNatEquiv (p, k) : ℕ) = p ^ (k + 1) :=\n  rfl\n\n"}
{"name":"Nat.Primes.prodNatEquiv_symm_apply","module":"Mathlib.Data.Nat.Factorization.PrimePow","initialProofState":"n : Nat\nhn : IsPrimePow n\n⊢ Eq (Nat.Primes.prodNatEquiv.symm ⟨n, hn⟩) { fst := ⟨n.minFac, ⋯⟩, snd := HSub.hSub (n.factorization n.minFac) 1 }","decl":"@[simp]\nlemma Nat.Primes.prodNatEquiv_symm_apply {n : ℕ} (hn : IsPrimePow n) :\n    prodNatEquiv.symm ⟨n, hn⟩ =\n      (⟨n.minFac, minFac_prime hn.ne_one⟩, n.factorization n.minFac - 1) :=\n  rfl\n"}
