{"name":"Submodule.apply_mem_map₂","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nm : M\nn : N\np : Submodule R M\nq : Submodule R N\nhm : Membership.mem p m\nhn : Membership.mem q n\n⊢ Membership.mem (Submodule.map₂ f p q) ((f m) n)","decl":"theorem apply_mem_map₂ (f : M →ₗ[R] N →ₗ[R] P) {m : M} {n : N} {p : Submodule R M}\n    {q : Submodule R N} (hm : m ∈ p) (hn : n ∈ q) : f m n ∈ map₂ f p q :=\n  (le_iSup _ ⟨m, hm⟩ : _ ≤ map₂ f p q) ⟨n, hn, by rfl⟩\n\n"}
{"name":"Submodule.map₂_le","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np : Submodule R M\nq : Submodule R N\nr : Submodule R P\n⊢ Iff (LE.le (Submodule.map₂ f p q) r) (∀ (m : M), Membership.mem p m → ∀ (n : N), Membership.mem q n → Membership.mem r ((f m) n))","decl":"theorem map₂_le {f : M →ₗ[R] N →ₗ[R] P} {p : Submodule R M} {q : Submodule R N}\n    {r : Submodule R P} : map₂ f p q ≤ r ↔ ∀ m ∈ p, ∀ n ∈ q, f m n ∈ r :=\n  ⟨fun H _m hm _n hn => H <| apply_mem_map₂ _ hm hn, fun H =>\n    iSup_le fun ⟨m, hm⟩ => map_le_iff_le_comap.2 fun n hn => H m hm n hn⟩\n\n"}
{"name":"Submodule.map₂_span_span","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\ns : Set M\nt : Set N\n⊢ Eq (Submodule.map₂ f (Submodule.span R s) (Submodule.span R t)) (Submodule.span R (Set.image2 (fun m n => (f m) n) s t))","decl":"theorem map₂_span_span (f : M →ₗ[R] N →ₗ[R] P) (s : Set M) (t : Set N) :\n    map₂ f (span R s) (span R t) = span R (Set.image2 (fun m n => f m n) s t) := by\n  apply le_antisymm\n  · rw [map₂_le]\n    apply @span_induction R M _ _ _ s\n    on_goal 1 =>\n      intro a ha\n      apply @span_induction R N _ _ _ t\n      · intro b hb\n        exact subset_span ⟨_, ‹_›, _, ‹_›, rfl⟩\n    all_goals\n      intros\n      simp only [*, add_mem, smul_mem, zero_mem, _root_.map_zero, map_add,\n        LinearMap.zero_apply, LinearMap.add_apply, LinearMap.smul_apply, map_smul]\n  · rw [span_le, image2_subset_iff]\n    intro a ha b hb\n    exact apply_mem_map₂ _ (subset_span ha) (subset_span hb)\n"}
{"name":"Submodule.map₂_bot_right","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np : Submodule R M\n⊢ Eq (Submodule.map₂ f p Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map₂_bot_right (f : M →ₗ[R] N →ₗ[R] P) (p : Submodule R M) : map₂ f p ⊥ = ⊥ :=\n  eq_bot_iff.2 <|\n    map₂_le.2 fun m _hm n hn => by\n      rw [Submodule.mem_bot] at hn\n      rw [hn, LinearMap.map_zero]; simp only [mem_bot]\n\n"}
{"name":"Submodule.map₂_bot_left","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nq : Submodule R N\n⊢ Eq (Submodule.map₂ f Bot.bot q) Bot.bot","decl":"@[simp]\ntheorem map₂_bot_left (f : M →ₗ[R] N →ₗ[R] P) (q : Submodule R N) : map₂ f ⊥ q = ⊥ :=\n  eq_bot_iff.2 <|\n    map₂_le.2 fun m hm n _ => by\n      rw [Submodule.mem_bot] at hm ⊢\n      rw [hm, LinearMap.map_zero₂]\n\n"}
{"name":"Submodule.map₂_le_map₂","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np₁ p₂ : Submodule R M\nq₁ q₂ : Submodule R N\nhp : LE.le p₁ p₂\nhq : LE.le q₁ q₂\n⊢ LE.le (Submodule.map₂ f p₁ q₁) (Submodule.map₂ f p₂ q₂)","decl":"@[gcongr, mono]\ntheorem map₂_le_map₂ {f : M →ₗ[R] N →ₗ[R] P} {p₁ p₂ : Submodule R M} {q₁ q₂ : Submodule R N}\n    (hp : p₁ ≤ p₂) (hq : q₁ ≤ q₂) : map₂ f p₁ q₁ ≤ map₂ f p₂ q₂ :=\n  map₂_le.2 fun _m hm _n hn => apply_mem_map₂ _ (hp hm) (hq hn)\n\n"}
{"name":"Submodule.map₂_le_map₂_left","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np₁ p₂ : Submodule R M\nq : Submodule R N\nh : LE.le p₁ p₂\n⊢ LE.le (Submodule.map₂ f p₁ q) (Submodule.map₂ f p₂ q)","decl":"theorem map₂_le_map₂_left {f : M →ₗ[R] N →ₗ[R] P} {p₁ p₂ : Submodule R M} {q : Submodule R N}\n    (h : p₁ ≤ p₂) : map₂ f p₁ q ≤ map₂ f p₂ q :=\n  map₂_le_map₂ h (le_refl q)\n\n"}
{"name":"Submodule.map₂_le_map₂_right","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np : Submodule R M\nq₁ q₂ : Submodule R N\nh : LE.le q₁ q₂\n⊢ LE.le (Submodule.map₂ f p q₁) (Submodule.map₂ f p q₂)","decl":"theorem map₂_le_map₂_right {f : M →ₗ[R] N →ₗ[R] P} {p : Submodule R M} {q₁ q₂ : Submodule R N}\n    (h : q₁ ≤ q₂) : map₂ f p q₁ ≤ map₂ f p q₂ :=\n  map₂_le_map₂ (le_refl p) h\n\n"}
{"name":"Submodule.map₂_sup_right","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np : Submodule R M\nq₁ q₂ : Submodule R N\n⊢ Eq (Submodule.map₂ f p (Max.max q₁ q₂)) (Max.max (Submodule.map₂ f p q₁) (Submodule.map₂ f p q₂))","decl":"theorem map₂_sup_right (f : M →ₗ[R] N →ₗ[R] P) (p : Submodule R M) (q₁ q₂ : Submodule R N) :\n    map₂ f p (q₁ ⊔ q₂) = map₂ f p q₁ ⊔ map₂ f p q₂ :=\n  le_antisymm\n    (map₂_le.2 fun _m hm _np hnp =>\n      let ⟨_n, hn, _p, hp, hnp⟩ := mem_sup.1 hnp\n      mem_sup.2 ⟨_, apply_mem_map₂ _ hm hn, _, apply_mem_map₂ _ hm hp, hnp ▸ (map_add _ _ _).symm⟩)\n    (sup_le (map₂_le_map₂_right le_sup_left) (map₂_le_map₂_right le_sup_right))\n\n"}
{"name":"Submodule.map₂_sup_left","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np₁ p₂ : Submodule R M\nq : Submodule R N\n⊢ Eq (Submodule.map₂ f (Max.max p₁ p₂) q) (Max.max (Submodule.map₂ f p₁ q) (Submodule.map₂ f p₂ q))","decl":"theorem map₂_sup_left (f : M →ₗ[R] N →ₗ[R] P) (p₁ p₂ : Submodule R M) (q : Submodule R N) :\n    map₂ f (p₁ ⊔ p₂) q = map₂ f p₁ q ⊔ map₂ f p₂ q :=\n  le_antisymm\n    (map₂_le.2 fun _mn hmn _p hp =>\n      let ⟨_m, hm, _n, hn, hmn⟩ := mem_sup.1 hmn\n      mem_sup.2\n        ⟨_, apply_mem_map₂ _ hm hp, _, apply_mem_map₂ _ hn hp,\n          hmn ▸ (LinearMap.map_add₂ _ _ _ _).symm⟩)\n    (sup_le (map₂_le_map₂_left le_sup_left) (map₂_le_map₂_left le_sup_right))\n\n"}
{"name":"Submodule.image2_subset_map₂","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np : Submodule R M\nq : Submodule R N\n⊢ HasSubset.Subset (Set.image2 (fun m n => (f m) n) ↑p ↑q) ↑(Submodule.map₂ f p q)","decl":"theorem image2_subset_map₂ (f : M →ₗ[R] N →ₗ[R] P) (p : Submodule R M) (q : Submodule R N) :\n    Set.image2 (fun m n => f m n) (↑p : Set M) (↑q : Set N) ⊆ (↑(map₂ f p q) : Set P) := by\n  rintro _ ⟨i, hi, j, hj, rfl⟩\n  exact apply_mem_map₂ _ hi hj\n\n"}
{"name":"Submodule.map₂_eq_span_image2","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np : Submodule R M\nq : Submodule R N\n⊢ Eq (Submodule.map₂ f p q) (Submodule.span R (Set.image2 (fun m n => (f m) n) ↑p ↑q))","decl":"theorem map₂_eq_span_image2 (f : M →ₗ[R] N →ₗ[R] P) (p : Submodule R M) (q : Submodule R N) :\n    map₂ f p q = span R (Set.image2 (fun m n => f m n) (p : Set M) (q : Set N)) := by\n  rw [← map₂_span_span, span_eq, span_eq]\n\n"}
{"name":"Submodule.map₂_flip","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\np : Submodule R M\nq : Submodule R N\n⊢ Eq (Submodule.map₂ f.flip q p) (Submodule.map₂ f p q)","decl":"theorem map₂_flip (f : M →ₗ[R] N →ₗ[R] P) (p : Submodule R M) (q : Submodule R N) :\n    map₂ f.flip q p = map₂ f p q := by\n  rw [map₂_eq_span_image2, map₂_eq_span_image2, Set.image2_swap]\n  rfl\n\n"}
{"name":"Submodule.map₂_iSup_left","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"ι : Sort uι\nR : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\ns : ι → Submodule R M\nt : Submodule R N\n⊢ Eq (Submodule.map₂ f (iSup fun i => s i) t) (iSup fun i => Submodule.map₂ f (s i) t)","decl":"theorem map₂_iSup_left (f : M →ₗ[R] N →ₗ[R] P) (s : ι → Submodule R M) (t : Submodule R N) :\n    map₂ f (⨆ i, s i) t = ⨆ i, map₂ f (s i) t := by\n  suffices map₂ f (⨆ i, span R (s i : Set M)) (span R t) = ⨆ i, map₂ f (span R (s i)) (span R t) by\n    simpa only [span_eq] using this\n  simp_rw [map₂_span_span, ← span_iUnion, map₂_span_span, Set.image2_iUnion_left]\n\n"}
{"name":"Submodule.map₂_iSup_right","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"ι : Sort uι\nR : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\ns : Submodule R M\nt : ι → Submodule R N\n⊢ Eq (Submodule.map₂ f s (iSup fun i => t i)) (iSup fun i => Submodule.map₂ f s (t i))","decl":"theorem map₂_iSup_right (f : M →ₗ[R] N →ₗ[R] P) (s : Submodule R M) (t : ι → Submodule R N) :\n    map₂ f s (⨆ i, t i) = ⨆ i, map₂ f s (t i) := by\n  suffices map₂ f (span R s) (⨆ i, span R (t i : Set N)) = ⨆ i, map₂ f (span R s) (span R (t i)) by\n    simpa only [span_eq] using this\n  simp_rw [map₂_span_span, ← span_iUnion, map₂_span_span, Set.image2_iUnion_right]\n\n"}
{"name":"Submodule.map₂_span_singleton_eq_map","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nm : M\n⊢ Eq (Submodule.map₂ f (Submodule.span R (Singleton.singleton m))) (Submodule.map (f m))","decl":"theorem map₂_span_singleton_eq_map (f : M →ₗ[R] N →ₗ[R] P) (m : M) :\n    map₂ f (span R {m}) = map (f m) := by\n  funext s\n  rw [← span_eq s, map₂_span_span, image2_singleton_left, map_span]\n\n"}
{"name":"Submodule.map₂_span_singleton_eq_map_flip","module":"Mathlib.Algebra.Module.Submodule.Bilinear","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\ns : Submodule R M\nn : N\n⊢ Eq (Submodule.map₂ f s (Submodule.span R (Singleton.singleton n))) (Submodule.map (f.flip n) s)","decl":"theorem map₂_span_singleton_eq_map_flip (f : M →ₗ[R] N →ₗ[R] P) (s : Submodule R M) (n : N) :\n    map₂ f s (span R {n}) = map (f.flip n) s := by rw [← map₂_span_singleton_eq_map, map₂_flip]\n\n"}
