{"name":"Nat.choose_mul_add","module":"Mathlib.Data.Nat.Choose.Mul","initialProofState":"m n : Nat\nhn : Ne n 0\n⊢ Eq ((HAdd.hAdd (HMul.hMul m n) n).choose n) (HMul.hMul (HAdd.hAdd m 1) ((HSub.hSub (HAdd.hAdd (HMul.hMul m n) n) 1).choose (HSub.hSub n 1)))","decl":"theorem choose_mul_add {m n : ℕ} (hn : n ≠ 0) :\n    (m * n + n).choose n = (m + 1) * (m * n + n - 1).choose (n - 1) := by\n  rw [← Nat.mul_left_inj (mul_ne_zero (factorial_ne_zero (m * n)) (factorial_ne_zero n))]\n  set p := n - 1\n  have hp : n = p + 1 := (succ_pred_eq_of_ne_zero hn).symm\n  simp only [hp, add_succ_sub_one]\n  calc\n    (m * (p + 1) + (p + 1)).choose (p + 1) * ((m * (p+1))! * (p+1)!)\n      = (m * (p + 1) + (p + 1)).choose (p + 1) * (m * (p+1))! * (p+1)! := by ring\n    _ = (m * (p+ 1) + (p + 1))! := by rw [add_choose_mul_factorial_mul_factorial]\n    _ = ((m * (p+ 1) + p) + 1)! := by ring_nf\n    _ = ((m * (p + 1) + p) + 1) * (m * (p + 1) + p)! := by rw [factorial_succ]\n    _ = (m * (p + 1) + p)! * ((p + 1) * (m + 1)) := by ring\n    _ = ((m * (p + 1) + p).choose p * (m * (p+1))! * (p)!) * ((p + 1) * (m + 1)) := by\n      rw [add_choose_mul_factorial_mul_factorial]\n    _ = (m * (p + 1) + p).choose p * (m * (p+1))! * (((p + 1) * (p)!) * (m + 1)) := by ring\n    _ = (m * (p + 1) + p).choose p * (m * (p+1))! * ((p + 1)! * (m + 1)) := by rw [factorial_succ]\n    _ = (m + 1) * (m * (p + 1) + p).choose p * ((m * (p + 1))! * (p + 1)!) := by ring\n\n"}
{"name":"Nat.choose_mul_right","module":"Mathlib.Data.Nat.Choose.Mul","initialProofState":"m n : Nat\nhn : Ne n 0\n⊢ Eq ((HMul.hMul m n).choose n) (HMul.hMul m ((HSub.hSub (HMul.hMul m n) 1).choose (HSub.hSub n 1)))","decl":"theorem choose_mul_right {m n : ℕ} (hn : n ≠ 0) :\n    (m * n).choose n = m * (m * n - 1).choose (n - 1) := by\n  by_cases hm : m = 0\n  · simp only [hm, zero_mul, choose_eq_zero_iff]\n    exact Nat.pos_of_ne_zero hn\n  · set p := m - 1; have hp : m = p + 1 := (succ_pred_eq_of_ne_zero hm).symm\n    simp only [hp]\n    rw [add_mul, one_mul, choose_mul_add hn]\n\n"}
