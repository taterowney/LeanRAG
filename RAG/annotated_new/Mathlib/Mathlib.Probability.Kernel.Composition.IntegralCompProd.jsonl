{"name":"ProbabilityTheory.hasFiniteIntegral_prod_mk_left","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ns : Set (Prod Î² Î³)\nh2s : Ne (((Îº.compProd Î·) a) s) Top.top\nâŠ¢ MeasureTheory.HasFiniteIntegral (fun b => ((Î· { fst := a, snd := b }) (Set.preimage (Prod.mk b) s)).toReal) (Îº a)","decl":"theorem hasFiniteIntegral_prod_mk_left (a : Î±) {s : Set (Î² Ã— Î³)} (h2s : (Îº âŠ—â‚– Î·) a s â‰  âˆ) :\n    HasFiniteIntegral (fun b => (Î· (a, b) (Prod.mk b â»Â¹' s)).toReal) (Îº a) := by\n  let t := toMeasurable ((Îº âŠ—â‚– Î·) a) s\n  simp_rw [hasFiniteIntegral_iff_enorm, enorm_eq_ofReal toReal_nonneg]\n  calc\n    âˆ«â» b, ENNReal.ofReal (Î· (a, b) (Prod.mk b â»Â¹' s)).toReal âˆ‚Îº a\n    _ â‰¤ âˆ«â» b, Î· (a, b) (Prod.mk b â»Â¹' t) âˆ‚Îº a := by\n      refine lintegral_mono_ae ?_\n      filter_upwards [ae_kernel_lt_top a h2s] with b hb\n      rw [ofReal_toReal hb.ne]\n      exact measure_mono (preimage_mono (subset_toMeasurable _ _))\n    _ â‰¤ (Îº âŠ—â‚– Î·) a t := le_compProd_apply _ _ _ _\n    _ = (Îº âŠ—â‚– Î·) a s := measure_toMeasurable s\n    _ < âŠ¤ := h2s.lt_top\n\n"}
{"name":"ProbabilityTheory.integrable_kernel_prod_mk_left","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ns : Set (Prod Î² Î³)\nhs : MeasurableSet s\nh2s : Ne (((Îº.compProd Î·) a) s) Top.top\nâŠ¢ MeasureTheory.Integrable (fun b => ((Î· { fst := a, snd := b }) (Set.preimage (Prod.mk b) s)).toReal) (Îº a)","decl":"theorem integrable_kernel_prod_mk_left (a : Î±) {s : Set (Î² Ã— Î³)} (hs : MeasurableSet s)\n    (h2s : (Îº âŠ—â‚– Î·) a s â‰  âˆ) : Integrable (fun b => (Î· (a, b) (Prod.mk b â»Â¹' s)).toReal) (Îº a) := by\n  constructor\n  Â· exact (measurable_kernel_prod_mk_left' hs a).ennreal_toReal.aestronglyMeasurable\n  Â· exact hasFiniteIntegral_prod_mk_left a h2s\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf : Prod Î² Î³ â†’ E\nhf : MeasureTheory.AEStronglyMeasurable f ((Îº.compProd Î·) a)\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (Îº a)","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace â„ E]\n    â¦ƒf : Î² Ã— Î³ â†’ Eâ¦„ (hf : AEStronglyMeasurable f ((Îº âŠ—â‚– Î·) a)) :\n    AEStronglyMeasurable (fun x => âˆ« y, f (x, y) âˆ‚Î· (a, x)) (Îº a) :=\n  âŸ¨fun x => âˆ« y, hf.mk f (x, y) âˆ‚Î· (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by\n    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hxâŸ©\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.compProd_mk_left","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\nÎ´ : Type u_5\ninstâœ : TopologicalSpace Î´\nf : Prod Î² Î³ â†’ Î´\nhf : MeasureTheory.AEStronglyMeasurable f ((Îº.compProd Î·) a)\nâŠ¢ Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (fun y => f { fst := x, snd := y }) (Î· { fst := a, snd := x })) (MeasureTheory.ae (Îº a))","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.compProd_mk_left {Î´ : Type*} [TopologicalSpace Î´]\n    {f : Î² Ã— Î³ â†’ Î´} (hf : AEStronglyMeasurable f ((Îº âŠ—â‚– Î·) a)) :\n    âˆ€áµ x âˆ‚Îº a, AEStronglyMeasurable (fun y => f (x, y)) (Î· (a, x)) := by\n  filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with x hx using\n    âŸ¨fun y => hf.mk f (x, y), hf.stronglyMeasurable_mk.comp_measurable measurable_prod_mk_left, hxâŸ©\n\n"}
{"name":"ProbabilityTheory.hasFiniteIntegral_compProd_iff","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ² : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\nf : Prod Î² Î³ â†’ E\nh1f : MeasureTheory.StronglyMeasurable f\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f ((Îº.compProd Î·) a)) (And (Filter.Eventually (fun x => MeasureTheory.HasFiniteIntegral (fun y => f { fst := x, snd := y }) (Î· { fst := a, snd := x })) (MeasureTheory.ae (Îº a))) (MeasureTheory.HasFiniteIntegral (fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => Norm.norm (f { fst := x, snd := y })) (Îº a)))","decl":"theorem hasFiniteIntegral_compProd_iff â¦ƒf : Î² Ã— Î³ â†’ Eâ¦„ (h1f : StronglyMeasurable f) :\n    HasFiniteIntegral f ((Îº âŠ—â‚– Î·) a) â†”\n      (âˆ€áµ x âˆ‚Îº a, HasFiniteIntegral (fun y => f (x, y)) (Î· (a, x))) âˆ§\n        HasFiniteIntegral (fun x => âˆ« y, â€–f (x, y)â€– âˆ‚Î· (a, x)) (Îº a) := by\n  simp only [hasFiniteIntegral_iff_enorm]\n  rw [lintegral_compProd _ _ _ h1f.enorm]\n  have : âˆ€ x, âˆ€áµ y âˆ‚Î· (a, x), 0 â‰¤ â€–f (x, y)â€– := fun x => Eventually.of_forall fun y => norm_nonneg _\n  simp_rw [integral_eq_lintegral_of_nonneg_ae (this _)\n      (h1f.norm.comp_measurable measurable_prod_mk_left).aestronglyMeasurable,\n    enorm_eq_ofReal toReal_nonneg, ofReal_norm_eq_enorm]\n  have : âˆ€ {p q r : Prop} (_ : r â†’ p), (r â†” p âˆ§ q) â†” p â†’ (r â†” q) := fun {p q r} h1 => by\n    rw [â† and_congr_right_iff, and_iff_right_of_imp h1]\n  rw [this]\n  Â· intro h2f; rw [lintegral_congr_ae]\n    filter_upwards [h2f] with x hx\n    rw [ofReal_toReal]; rw [â† lt_top_iff_ne_top]; exact hx\n  Â· intro h2f; refine ae_lt_top ?_ h2f.ne; exact h1f.enorm.lintegral_kernel_prod_right''\n\n"}
{"name":"ProbabilityTheory.hasFiniteIntegral_compProd_iff'","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ² : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\nf : Prod Î² Î³ â†’ E\nh1f : MeasureTheory.AEStronglyMeasurable f ((Îº.compProd Î·) a)\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f ((Îº.compProd Î·) a)) (And (Filter.Eventually (fun x => MeasureTheory.HasFiniteIntegral (fun y => f { fst := x, snd := y }) (Î· { fst := a, snd := x })) (MeasureTheory.ae (Îº a))) (MeasureTheory.HasFiniteIntegral (fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => Norm.norm (f { fst := x, snd := y })) (Îº a)))","decl":"theorem hasFiniteIntegral_compProd_iff' â¦ƒf : Î² Ã— Î³ â†’ Eâ¦„\n    (h1f : AEStronglyMeasurable f ((Îº âŠ—â‚– Î·) a)) :\n    HasFiniteIntegral f ((Îº âŠ—â‚– Î·) a) â†”\n      (âˆ€áµ x âˆ‚Îº a, HasFiniteIntegral (fun y => f (x, y)) (Î· (a, x))) âˆ§\n        HasFiniteIntegral (fun x => âˆ« y, â€–f (x, y)â€– âˆ‚Î· (a, x)) (Îº a) := by\n  rw [hasFiniteIntegral_congr h1f.ae_eq_mk,\n    hasFiniteIntegral_compProd_iff h1f.stronglyMeasurable_mk]\n  apply and_congr\n  Â· apply eventually_congr\n    filter_upwards [ae_ae_of_ae_compProd h1f.ae_eq_mk.symm] with x hx using\n      hasFiniteIntegral_congr hx\n  Â· apply hasFiniteIntegral_congr\n    filter_upwards [ae_ae_of_ae_compProd h1f.ae_eq_mk.symm] with _ hx using\n      integral_congr_ae (EventuallyEq.fun_comp hx _)\n\n"}
{"name":"ProbabilityTheory.integrable_compProd_iff","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ² : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\nf : Prod Î² Î³ â†’ E\nhf : MeasureTheory.AEStronglyMeasurable f ((Îº.compProd Î·) a)\nâŠ¢ Iff (MeasureTheory.Integrable f ((Îº.compProd Î·) a)) (And (Filter.Eventually (fun x => MeasureTheory.Integrable (fun y => f { fst := x, snd := y }) (Î· { fst := a, snd := x })) (MeasureTheory.ae (Îº a))) (MeasureTheory.Integrable (fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => Norm.norm (f { fst := x, snd := y })) (Îº a)))","decl":"theorem integrable_compProd_iff â¦ƒf : Î² Ã— Î³ â†’ Eâ¦„ (hf : AEStronglyMeasurable f ((Îº âŠ—â‚– Î·) a)) :\n    Integrable f ((Îº âŠ—â‚– Î·) a) â†”\n      (âˆ€áµ x âˆ‚Îº a, Integrable (fun y => f (x, y)) (Î· (a, x))) âˆ§\n        Integrable (fun x => âˆ« y, â€–f (x, y)â€– âˆ‚Î· (a, x)) (Îº a) := by\n  simp only [Integrable, hasFiniteIntegral_compProd_iff' hf, hf.norm.integral_kernel_compProd,\n    hf, hf.compProd_mk_left, eventually_and, true_and]\n\n"}
{"name":"MeasureTheory.Integrable.compProd_mk_left_ae","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ² : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\nf : Prod Î² Î³ â†’ E\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nâŠ¢ Filter.Eventually (fun x => MeasureTheory.Integrable (fun y => f { fst := x, snd := y }) (Î· { fst := a, snd := x })) (MeasureTheory.ae (Îº a))","decl":"theorem _root_.MeasureTheory.Integrable.compProd_mk_left_ae â¦ƒf : Î² Ã— Î³ â†’ Eâ¦„\n    (hf : Integrable f ((Îº âŠ—â‚– Î·) a)) : âˆ€áµ x âˆ‚Îº a, Integrable (fun y => f (x, y)) (Î· (a, x)) :=\n  ((integrable_compProd_iff hf.aestronglyMeasurable).mp hf).1\n\n"}
{"name":"MeasureTheory.Integrable.integral_norm_compProd","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ² : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\nf : Prod Î² Î³ â†’ E\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nâŠ¢ MeasureTheory.Integrable (fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => Norm.norm (f { fst := x, snd := y })) (Îº a)","decl":"theorem _root_.MeasureTheory.Integrable.integral_norm_compProd â¦ƒf : Î² Ã— Î³ â†’ Eâ¦„\n    (hf : Integrable f ((Îº âŠ—â‚– Î·) a)) : Integrable (fun x => âˆ« y, â€–f (x, y)â€– âˆ‚Î· (a, x)) (Îº a) :=\n  ((integrable_compProd_iff hf.aestronglyMeasurable).mp hf).2\n\n"}
{"name":"MeasureTheory.Integrable.integral_compProd","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf : Prod Î² Î³ â†’ E\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nâŠ¢ MeasureTheory.Integrable (fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (Îº a)","decl":"theorem _root_.MeasureTheory.Integrable.integral_compProd [NormedSpace â„ E]\n    â¦ƒf : Î² Ã— Î³ â†’ Eâ¦„ (hf : Integrable f ((Îº âŠ—â‚– Î·) a)) :\n    Integrable (fun x => âˆ« y, f (x, y) âˆ‚Î· (a, x)) (Îº a) :=\n  Integrable.mono hf.integral_norm_compProd hf.aestronglyMeasurable.integral_kernel_compProd <|\n    Eventually.of_forall fun x =>\n      (norm_integral_le_integral_norm _).trans_eq <|\n        (norm_of_nonneg <|\n            integral_nonneg_of_ae <|\n              Eventually.of_forall fun y => (norm_nonneg (f (x, y)) :)).symm\n\n"}
{"name":"ProbabilityTheory.Kernel.integral_fn_integral_add","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœâµ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœâ´ : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ³ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœÂ² : NormedSpace Real E\nE' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup E'\ninstâœ : NormedSpace Real E'\nf g : Prod Î² Î³ â†’ E\nF : E â†’ E'\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nhg : MeasureTheory.Integrable g ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral (Îº a) fun x => F (MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => HAdd.hAdd (f { fst := x, snd := y }) (g { fst := x, snd := y }))) (MeasureTheory.integral (Îº a) fun x => F (HAdd.hAdd (MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => g { fst := x, snd := y })))","decl":"theorem Kernel.integral_fn_integral_add â¦ƒf g : Î² Ã— Î³ â†’ Eâ¦„ (F : E â†’ E')\n    (hf : Integrable f ((Îº âŠ—â‚– Î·) a)) (hg : Integrable g ((Îº âŠ—â‚– Î·) a)) :\n    âˆ« x, F (âˆ« y, f (x, y) + g (x, y) âˆ‚Î· (a, x)) âˆ‚Îº a =\n      âˆ« x, F (âˆ« y, f (x, y) âˆ‚Î· (a, x) + âˆ« y, g (x, y) âˆ‚Î· (a, x)) âˆ‚Îº a := by\n  refine integral_congr_ae ?_\n  filter_upwards [hf.compProd_mk_left_ae, hg.compProd_mk_left_ae] with _ h2f h2g\n  simp [integral_add h2f h2g]\n\n"}
{"name":"ProbabilityTheory.Kernel.integral_fn_integral_sub","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœâµ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœâ´ : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ³ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœÂ² : NormedSpace Real E\nE' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup E'\ninstâœ : NormedSpace Real E'\nf g : Prod Î² Î³ â†’ E\nF : E â†’ E'\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nhg : MeasureTheory.Integrable g ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral (Îº a) fun x => F (MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => HSub.hSub (f { fst := x, snd := y }) (g { fst := x, snd := y }))) (MeasureTheory.integral (Îº a) fun x => F (HSub.hSub (MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => g { fst := x, snd := y })))","decl":"theorem Kernel.integral_fn_integral_sub â¦ƒf g : Î² Ã— Î³ â†’ Eâ¦„ (F : E â†’ E')\n    (hf : Integrable f ((Îº âŠ—â‚– Î·) a)) (hg : Integrable g ((Îº âŠ—â‚– Î·) a)) :\n    âˆ« x, F (âˆ« y, f (x, y) - g (x, y) âˆ‚Î· (a, x)) âˆ‚Îº a =\n      âˆ« x, F (âˆ« y, f (x, y) âˆ‚Î· (a, x) - âˆ« y, g (x, y) âˆ‚Î· (a, x)) âˆ‚Îº a := by\n  refine integral_congr_ae ?_\n  filter_upwards [hf.compProd_mk_left_ae, hg.compProd_mk_left_ae] with _ h2f h2g\n  simp [integral_sub h2f h2g]\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_fn_integral_sub","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf g : Prod Î² Î³ â†’ E\nF : E â†’ ENNReal\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nhg : MeasureTheory.Integrable g ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.lintegral (Îº a) fun x => F (MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => HSub.hSub (f { fst := x, snd := y }) (g { fst := x, snd := y }))) (MeasureTheory.lintegral (Îº a) fun x => F (HSub.hSub (MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => g { fst := x, snd := y })))","decl":"theorem Kernel.lintegral_fn_integral_sub â¦ƒf g : Î² Ã— Î³ â†’ Eâ¦„ (F : E â†’ â„â‰¥0âˆ)\n    (hf : Integrable f ((Îº âŠ—â‚– Î·) a)) (hg : Integrable g ((Îº âŠ—â‚– Î·) a)) :\n    âˆ«â» x, F (âˆ« y, f (x, y) - g (x, y) âˆ‚Î· (a, x)) âˆ‚Îº a =\n      âˆ«â» x, F (âˆ« y, f (x, y) âˆ‚Î· (a, x) - âˆ« y, g (x, y) âˆ‚Î· (a, x)) âˆ‚Îº a := by\n  refine lintegral_congr_ae ?_\n  filter_upwards [hf.compProd_mk_left_ae, hg.compProd_mk_left_ae] with _ h2f h2g\n  simp [integral_sub h2f h2g]\n\n"}
{"name":"ProbabilityTheory.Kernel.integral_integral_add","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf g : Prod Î² Î³ â†’ E\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nhg : MeasureTheory.Integrable g ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => HAdd.hAdd (f { fst := x, snd := y }) (g { fst := x, snd := y })) (HAdd.hAdd (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => g { fst := x, snd := y }))","decl":"theorem Kernel.integral_integral_add â¦ƒf g : Î² Ã— Î³ â†’ Eâ¦„ (hf : Integrable f ((Îº âŠ—â‚– Î·) a))\n    (hg : Integrable g ((Îº âŠ—â‚– Î·) a)) :\n    âˆ« x, âˆ« y, f (x, y) + g (x, y) âˆ‚Î· (a, x) âˆ‚Îº a =\n      âˆ« x, âˆ« y, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a + âˆ« x, âˆ« y, g (x, y) âˆ‚Î· (a, x) âˆ‚Îº a :=\n  (Kernel.integral_fn_integral_add id hf hg).trans <|\n    integral_add hf.integral_compProd hg.integral_compProd\n\n"}
{"name":"ProbabilityTheory.Kernel.integral_integral_add'","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf g : Prod Î² Î³ â†’ E\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nhg : MeasureTheory.Integrable g ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => HAdd.hAdd f g { fst := x, snd := y }) (HAdd.hAdd (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => g { fst := x, snd := y }))","decl":"theorem Kernel.integral_integral_add' â¦ƒf g : Î² Ã— Î³ â†’ Eâ¦„ (hf : Integrable f ((Îº âŠ—â‚– Î·) a))\n    (hg : Integrable g ((Îº âŠ—â‚– Î·) a)) :\n    âˆ« x, âˆ« y, (f + g) (x, y) âˆ‚Î· (a, x) âˆ‚Îº a =\n      âˆ« x, âˆ« y, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a + âˆ« x, âˆ« y, g (x, y) âˆ‚Î· (a, x) âˆ‚Îº a :=\n  Kernel.integral_integral_add hf hg\n\n"}
{"name":"ProbabilityTheory.Kernel.integral_integral_sub","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf g : Prod Î² Î³ â†’ E\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nhg : MeasureTheory.Integrable g ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => HSub.hSub (f { fst := x, snd := y }) (g { fst := x, snd := y })) (HSub.hSub (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => g { fst := x, snd := y }))","decl":"theorem Kernel.integral_integral_sub â¦ƒf g : Î² Ã— Î³ â†’ Eâ¦„ (hf : Integrable f ((Îº âŠ—â‚– Î·) a))\n    (hg : Integrable g ((Îº âŠ—â‚– Î·) a)) :\n    âˆ« x, âˆ« y, f (x, y) - g (x, y) âˆ‚Î· (a, x) âˆ‚Îº a =\n      âˆ« x, âˆ« y, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a - âˆ« x, âˆ« y, g (x, y) âˆ‚Î· (a, x) âˆ‚Îº a :=\n  (Kernel.integral_fn_integral_sub id hf hg).trans <|\n    integral_sub hf.integral_compProd hg.integral_compProd\n\n"}
{"name":"ProbabilityTheory.Kernel.integral_integral_sub'","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf g : Prod Î² Î³ â†’ E\nhf : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nhg : MeasureTheory.Integrable g ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => HSub.hSub f g { fst := x, snd := y }) (HSub.hSub (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => g { fst := x, snd := y }))","decl":"theorem Kernel.integral_integral_sub' â¦ƒf g : Î² Ã— Î³ â†’ Eâ¦„ (hf : Integrable f ((Îº âŠ—â‚– Î·) a))\n    (hg : Integrable g ((Îº âŠ—â‚– Î·) a)) :\n    âˆ« x, âˆ« y, (f - g) (x, y) âˆ‚Î· (a, x) âˆ‚Îº a =\n      âˆ« x, âˆ« y, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a - âˆ« x, âˆ« y, g (x, y) âˆ‚Î· (a, x) âˆ‚Îº a :=\n  Kernel.integral_integral_sub hf hg\n\n-- Porting note: couldn't get the `â†’â‚[]` syntax to work\n"}
{"name":"ProbabilityTheory.Kernel.continuous_integral_integral","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nâŠ¢ Continuous fun f => MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => â†‘â†‘f { fst := x, snd := y }","decl":"theorem Kernel.continuous_integral_integral :\n    -- Continuous fun f : Î± Ã— Î² â†’â‚[(Îº âŠ—â‚– Î·) a] E => âˆ« x, âˆ« y, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a := by\n    Continuous fun f : (MeasureTheory.Lp (Î± := Î² Ã— Î³) E 1 (((Îº âŠ—â‚– Î·) a) : Measure (Î² Ã— Î³))) =>\n        âˆ« x, âˆ« y, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a := by\n  rw [continuous_iff_continuousAt]; intro g\n  refine\n    tendsto_integral_of_L1 _ (L1.integrable_coeFn g).integral_compProd\n      (Eventually.of_forall fun h => (L1.integrable_coeFn h).integral_compProd) ?_\n  simp_rw [â† lintegral_fn_integral_sub (â€–Â·â€–â‚‘) (L1.integrable_coeFn _) (L1.integrable_coeFn g)]\n  apply tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (fun i => zero_le _) _\n  Â· exact fun i => âˆ«â» x, âˆ«â» y, â€–i (x, y) - g (x, y)â€–â‚‘ âˆ‚Î· (a, x) âˆ‚Îº a\n  swap; Â· exact fun i => lintegral_mono fun x => enorm_integral_le_lintegral_enorm _\n  show\n    Tendsto\n      (fun i : Î² Ã— Î³ â†’â‚[(Îº âŠ—â‚– Î·) a] E => âˆ«â» x, âˆ«â» y : Î³, â€–i (x, y) - g (x, y)â€–â‚‘ âˆ‚Î· (a, x) âˆ‚Îº a)\n      (ğ“ g) (ğ“ 0)\n  have this (i : Lp (Î± := Î² Ã— Î³) E 1 (((Îº âŠ—â‚– Î·) a) : Measure (Î² Ã— Î³))) :\n      Measurable fun z => â€–i z - g zâ€–â‚‘ :=\n    ((Lp.stronglyMeasurable i).sub (Lp.stronglyMeasurable g)).enorm\n  simp_rw [â† lintegral_compProd _ _ _ (this _), â† L1.ofReal_norm_sub_eq_lintegral, â† ofReal_zero]\n  refine (continuous_ofReal.tendsto 0).comp ?_\n  rw [â† tendsto_iff_norm_sub_tendsto_zero]\n  exact tendsto_id\n\n"}
{"name":"ProbabilityTheory.integral_compProd","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf : Prod Î² Î³ â†’ E\nxâœ : MeasureTheory.Integrable f ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral ((Îº.compProd Î·) a) fun z => f z) (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y })","decl":"theorem integral_compProd :\n    âˆ€ {f : Î² Ã— Î³ â†’ E} (_ : Integrable f ((Îº âŠ—â‚– Î·) a)),\n      âˆ« z, f z âˆ‚(Îº âŠ—â‚– Î·) a = âˆ« x, âˆ« y, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a := by\n  by_cases hE : CompleteSpace E; swap\n  Â· simp [integral, hE]\n  apply Integrable.induction\n  Â· intro c s hs h2s\n    simp_rw [integral_indicator hs, â† indicator_comp_right, Function.comp_def,\n      integral_indicator (measurable_prod_mk_left hs), MeasureTheory.setIntegral_const,\n      integral_smul_const]\n    congr 1\n    rw [integral_toReal]\n    rotate_left\n    Â· exact (Kernel.measurable_kernel_prod_mk_left' hs _).aemeasurable\n    Â· exact ae_kernel_lt_top a h2s.ne\n    rw [Kernel.compProd_apply hs]\n    rfl\n  Â· intro f g _ i_f i_g hf hg\n    simp_rw [integral_add' i_f i_g, Kernel.integral_integral_add' i_f i_g, hf, hg]\n  Â· exact isClosed_eq continuous_integral Kernel.continuous_integral_integral\n  Â· intro f g hfg _ hf\n    convert hf using 1\n    Â· exact integral_congr_ae hfg.symm\n    Â· apply integral_congr_ae\n      filter_upwards [ae_ae_of_ae_compProd hfg] with x hfgx using\n        integral_congr_ae (ae_eq_symm hfgx)\n\n"}
{"name":"ProbabilityTheory.setIntegral_compProd","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf : Prod Î² Î³ â†’ E\ns : Set Î²\nt : Set Î³\nhs : MeasurableSet s\nht : MeasurableSet t\nhf : MeasureTheory.IntegrableOn f (SProd.sprod s t) ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral (((Îº.compProd Î·) a).restrict (SProd.sprod s t)) fun z => f z) (MeasureTheory.integral ((Îº a).restrict s) fun x => MeasureTheory.integral ((Î· { fst := a, snd := x }).restrict t) fun y => f { fst := x, snd := y })","decl":"theorem setIntegral_compProd {f : Î² Ã— Î³ â†’ E} {s : Set Î²} {t : Set Î³} (hs : MeasurableSet s)\n    (ht : MeasurableSet t) (hf : IntegrableOn f (s Ã—Ë¢ t) ((Îº âŠ—â‚– Î·) a)) :\n    âˆ« z in s Ã—Ë¢ t, f z âˆ‚(Îº âŠ—â‚– Î·) a = âˆ« x in s, âˆ« y in t, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a := by\n  -- Porting note: `compProd_restrict` needed some explicit arguments\n  rw [â† Kernel.restrict_apply (Îº âŠ—â‚– Î·) (hs.prod ht), â† compProd_restrict hs ht, integral_compProd]\n  Â· simp_rw [Kernel.restrict_apply]\n  Â· rw [compProd_restrict, Kernel.restrict_apply]; exact hf\n\n"}
{"name":"ProbabilityTheory.setIntegral_compProd_univ_right","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf : Prod Î² Î³ â†’ E\ns : Set Î²\nhs : MeasurableSet s\nhf : MeasureTheory.IntegrableOn f (SProd.sprod s Set.univ) ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral (((Îº.compProd Î·) a).restrict (SProd.sprod s Set.univ)) fun z => f z) (MeasureTheory.integral ((Îº a).restrict s) fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y })","decl":"theorem setIntegral_compProd_univ_right (f : Î² Ã— Î³ â†’ E) {s : Set Î²} (hs : MeasurableSet s)\n    (hf : IntegrableOn f (s Ã—Ë¢ univ) ((Îº âŠ—â‚– Î·) a)) :\n    âˆ« z in s Ã—Ë¢ univ, f z âˆ‚(Îº âŠ—â‚– Î·) a = âˆ« x in s, âˆ« y, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a := by\n  simp_rw [setIntegral_compProd hs MeasurableSet.univ hf, Measure.restrict_univ]\n\n"}
{"name":"ProbabilityTheory.setIntegral_compProd_univ_left","module":"Mathlib.Probability.Kernel.Composition.IntegralCompProd","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nE : Type u_4\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : NormedAddCommGroup E\nÎº : ProbabilityTheory.Kernel Î± Î²\ninstâœÂ² : ProbabilityTheory.IsSFiniteKernel Îº\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\na : Î±\ninstâœ : NormedSpace Real E\nf : Prod Î² Î³ â†’ E\nt : Set Î³\nht : MeasurableSet t\nhf : MeasureTheory.IntegrableOn f (SProd.sprod Set.univ t) ((Îº.compProd Î·) a)\nâŠ¢ Eq (MeasureTheory.integral (((Îº.compProd Î·) a).restrict (SProd.sprod Set.univ t)) fun z => f z) (MeasureTheory.integral (Îº a) fun x => MeasureTheory.integral ((Î· { fst := a, snd := x }).restrict t) fun y => f { fst := x, snd := y })","decl":"theorem setIntegral_compProd_univ_left (f : Î² Ã— Î³ â†’ E) {t : Set Î³} (ht : MeasurableSet t)\n    (hf : IntegrableOn f (univ Ã—Ë¢ t) ((Îº âŠ—â‚– Î·) a)) :\n    âˆ« z in univ Ã—Ë¢ t, f z âˆ‚(Îº âŠ—â‚– Î·) a = âˆ« x, âˆ« y in t, f (x, y) âˆ‚Î· (a, x) âˆ‚Îº a := by\n  simp_rw [setIntegral_compProd MeasurableSet.univ ht hf, Measure.restrict_univ]\n\n"}
