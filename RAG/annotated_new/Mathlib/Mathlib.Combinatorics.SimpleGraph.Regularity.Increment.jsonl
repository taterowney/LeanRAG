{"name":"SzemerediRegularity.card_increment","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Increment","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\nP : Finpartition Finset.univ\nhP : P.IsEquipartition\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : Real\nhPα : LE.le (HMul.hMul P.parts.card (HPow.hPow 16 P.parts.card)) (Fintype.card α)\nhPG : Not (P.IsUniform G ε)\n⊢ Eq (SzemerediRegularity.increment hP G ε).parts.card (SzemerediRegularity.stepBound P.parts.card)","decl":"/-- The increment partition has a prescribed (very big) size in terms of the original partition. -/\ntheorem card_increment (hPα : #P.parts * 16 ^ #P.parts ≤ card α) (hPG : ¬P.IsUniform G ε) :\n    #(increment hP G ε).parts = stepBound #P.parts := by\n  have hPα' : stepBound #P.parts ≤ card α :=\n    (mul_le_mul_left' (pow_le_pow_left' (by norm_num) _) _).trans hPα\n  have hPpos : 0 < stepBound #P.parts := stepBound_pos (nonempty_of_not_uniform hPG).card_pos\n  rw [increment, card_bind]\n  simp_rw [chunk, apply_dite Finpartition.parts, apply_dite card, sum_dite]\n  rw [sum_const_nat, sum_const_nat, univ_eq_attach, univ_eq_attach, card_attach, card_attach]\n  any_goals exact fun x hx => card_parts_equitabilise _ _ (Nat.div_pos hPα' hPpos).ne'\n  rw [Nat.sub_add_cancel a_add_one_le_four_pow_parts_card,\n    Nat.sub_add_cancel ((Nat.le_succ _).trans a_add_one_le_four_pow_parts_card), ← add_mul]\n  congr\n  rw [filter_card_add_filter_neg_card_eq_card, card_attach]\n\n"}
{"name":"SzemerediRegularity.increment_isEquipartition","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Increment","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\nP : Finpartition Finset.univ\nhP : P.IsEquipartition\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : Real\n⊢ (SzemerediRegularity.increment hP G ε).IsEquipartition","decl":"theorem increment_isEquipartition : (increment hP G ε).IsEquipartition := by\n  simp_rw [IsEquipartition, Set.equitableOn_iff_exists_eq_eq_add_one]\n  refine ⟨m, fun A hA => ?_⟩\n  rw [mem_coe, increment, mem_bind] at hA\n  obtain ⟨U, hU, hA⟩ := hA\n  exact card_eq_of_mem_parts_chunk hA\n\n"}
{"name":"SzemerediRegularity.le_sum_distinctPairs_edgeDensity_sq","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Increment","initialProofState":"α : Type u_1\ninst✝³ : Fintype α\ninst✝² : DecidableEq α\nP : Finpartition Finset.univ\nhP : P.IsEquipartition\nG : SimpleGraph α\ninst✝¹ : DecidableRel G.Adj\nε : Real\ninst✝ : Nonempty α\nx : Subtype fun i => Membership.mem P.parts.offDiag i\nhε₁ : LE.le ε 1\nhPα : LE.le (HMul.hMul P.parts.card (HPow.hPow 16 P.parts.card)) (Fintype.card α)\nhPε : LE.le 100 (HMul.hMul (HPow.hPow 4 P.parts.card) (HPow.hPow ε 5))\n⊢ LE.le (HAdd.hAdd (HPow.hPow (↑(G.edgeDensity (↑x).1 (↑x).2)) 2) (HSub.hSub (ite (G.IsUniform ε (↑x).1 (↑x).2) 0 (HDiv.hDiv (HPow.hPow ε 4) 3)) (HDiv.hDiv (HPow.hPow ε 5) 25))) (HDiv.hDiv ((SzemerediRegularity.distinctPairs hP G ε x).sum fun i => HPow.hPow (↑(G.edgeDensity i.1 i.2)) 2) (HPow.hPow 16 P.parts.card))","decl":"lemma le_sum_distinctPairs_edgeDensity_sq (x : {i // i ∈ P.parts.offDiag}) (hε₁ : ε ≤ 1)\n    (hPα : #P.parts * 16 ^ #P.parts ≤ card α) (hPε : ↑100 ≤ ↑4 ^ #P.parts * ε ^ 5) :\n    (G.edgeDensity x.1.1 x.1.2 : ℝ) ^ 2 +\n      ((if G.IsUniform ε x.1.1 x.1.2 then 0 else ε ^ 4 / 3) - ε ^ 5 / 25) ≤\n    (∑ i ∈ distinctPairs hP G ε x, G.edgeDensity i.1 i.2 ^ 2 : ℝ) / 16 ^ #P.parts := by\n  rw [distinctPairs, ← add_sub_assoc, add_sub_right_comm]\n  split_ifs with h\n  · rw [add_zero]\n    exact edgeDensity_chunk_uniform hPα hPε _ _\n  · exact edgeDensity_chunk_not_uniform hPα hPε hε₁ (mem_offDiag.1 x.2).2.2 h\n\n"}
{"name":"SzemerediRegularity.energy_increment","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Increment","initialProofState":"α : Type u_1\ninst✝³ : Fintype α\ninst✝² : DecidableEq α\nP : Finpartition Finset.univ\nG : SimpleGraph α\ninst✝¹ : DecidableRel G.Adj\nε : Real\ninst✝ : Nonempty α\nhP : P.IsEquipartition\nhP₇ : LE.le 7 P.parts.card\nhPε : LE.le 100 (HMul.hMul (HPow.hPow 4 P.parts.card) (HPow.hPow ε 5))\nhPα : LE.le (HMul.hMul P.parts.card (HPow.hPow 16 P.parts.card)) (Fintype.card α)\nhPG : Not (P.IsUniform G ε)\nhε₀ : LE.le 0 ε\nhε₁ : LE.le ε 1\n⊢ LE.le (HAdd.hAdd (↑(P.energy G)) (HDiv.hDiv (HPow.hPow ε 5) 4)) ↑((SzemerediRegularity.increment hP G ε).energy G)","decl":"/-- The increment partition has energy greater than the original one by a known fixed amount. -/\ntheorem energy_increment (hP : P.IsEquipartition) (hP₇ : 7 ≤ #P.parts)\n    (hPε : 100 ≤ 4 ^ #P.parts * ε ^ 5) (hPα : #P.parts * 16 ^ #P.parts ≤ card α)\n    (hPG : ¬P.IsUniform G ε) (hε₀ : 0 ≤ ε) (hε₁ : ε ≤ 1) :\n    ↑(P.energy G) + ε ^ 5 / 4 ≤ (increment hP G ε).energy G := by\n  calc\n    _ = (∑ x ∈ P.parts.offDiag, (G.edgeDensity x.1 x.2 : ℝ) ^ 2 +\n          #P.parts ^ 2 * (ε ^ 5 / 4) : ℝ) / #P.parts ^ 2 := by\n        rw [coe_energy, add_div, mul_div_cancel_left₀]; positivity\n    _ ≤ (∑ x ∈ P.parts.offDiag.attach, (∑ i ∈ distinctPairs hP G ε x,\n          G.edgeDensity i.1 i.2 ^ 2 : ℝ) / 16 ^ #P.parts) / #P.parts ^ 2 := ?_\n    _ = (∑ x ∈ P.parts.offDiag.attach, ∑ i ∈ distinctPairs hP G ε x,\n          G.edgeDensity i.1 i.2 ^ 2 : ℝ) / #(increment hP G ε).parts ^ 2 := by\n        rw [card_increment hPα hPG, coe_stepBound, mul_pow, pow_right_comm,\n          div_mul_eq_div_div_swap, ← sum_div]; norm_num\n    _ ≤ _ := by\n        rw [coe_energy]\n        gcongr\n        rw [← sum_biUnion pairwiseDisjoint_distinctPairs]\n        exact sum_le_sum_of_subset_of_nonneg distinctPairs_increment fun i _ _ ↦ sq_nonneg _\n  gcongr\n  rw [Finpartition.IsUniform, not_le, mul_tsub, mul_one, ← offDiag_card] at hPG\n  calc\n    _ ≤ ∑ x ∈ P.parts.offDiag, (edgeDensity G x.1 x.2 : ℝ) ^ 2 +\n        (#(nonUniforms P G ε) * (ε ^ 4 / 3) - #P.parts.offDiag * (ε ^ 5 / 25)) :=\n        add_le_add_left ?_ _\n    _ = ∑ x ∈ P.parts.offDiag, ((G.edgeDensity x.1 x.2 : ℝ) ^ 2 +\n        ((if G.IsUniform ε x.1 x.2 then (0 : ℝ) else ε ^ 4 / 3) - ε ^ 5 / 25) : ℝ) := by\n        rw [sum_add_distrib, sum_sub_distrib, sum_const, nsmul_eq_mul, sum_ite, sum_const_zero,\n          zero_add, sum_const, nsmul_eq_mul, ← Finpartition.nonUniforms, ← add_sub_assoc,\n          add_sub_right_comm]\n    _ = _ := (sum_attach ..).symm\n    _ ≤ _ := sum_le_sum fun i _ ↦ le_sum_distinctPairs_edgeDensity_sq i hε₁ hPα hPε\n  calc\n    _ = (6/7 * #P.parts ^ 2) * ε ^ 5 * (7 / 24) := by ring\n    _ ≤ #P.parts.offDiag * ε ^ 5 * (22 / 75) := by\n        gcongr ?_ * _ * ?_\n        · rw [← mul_div_right_comm, div_le_iff₀ (by norm_num), offDiag_card]\n          norm_cast\n          rw [tsub_mul]\n          refine le_tsub_of_add_le_left ?_\n          nlinarith\n        · norm_num\n    _ = (#P.parts.offDiag * ε * (ε ^ 4 / 3) - #P.parts.offDiag * (ε ^ 5 / 25)) := by ring\n    _ ≤ (#(nonUniforms P G ε) * (ε ^ 4 / 3) - #P.parts.offDiag * (ε ^ 5 / 25)) := by gcongr\n\n"}
