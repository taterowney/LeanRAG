{"name":"ZeroHom.map_zero'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : Zero M\ninst✝ : Zero N\nself : ZeroHom M N\n⊢ Eq (self.toFun 0) 0","decl":"/-- `ZeroHom M N` is the type of functions `M → N` that preserve zero.\n\nWhen possible, instead of parametrizing results over `(f : ZeroHom M N)`,\nyou should parametrize over `(F : Type*) [ZeroHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `ZeroHomClass`.\n-/\nstructure ZeroHom (M : Type*) (N : Type*) [Zero M] [Zero N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves 0 -/\n  protected map_zero' : toFun 0 = 0\n\n"}
{"name":"ZeroHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝³ : Zero M\ninst✝² : Zero N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoFun : M → N\nmap_zero' : Eq (toFun 0) 0\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_zero' := map_zero' }) (HAdd.hAdd 1 (SizeOf.sizeOf map_zero'))","decl":"/-- `ZeroHom M N` is the type of functions `M → N` that preserve zero.\n\nWhen possible, instead of parametrizing results over `(f : ZeroHom M N)`,\nyou should parametrize over `(F : Type*) [ZeroHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `ZeroHomClass`.\n-/\nstructure ZeroHom (M : Type*) (N : Type*) [Zero M] [Zero N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves 0 -/\n  protected map_zero' : toFun 0 = 0\n\n"}
{"name":"ZeroHom.mk.injEq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : Zero M\ninst✝ : Zero N\ntoFun✝ : M → N\nmap_zero'✝ : Eq (toFun✝ 0) 0\ntoFun : M → N\nmap_zero' : Eq (toFun 0) 0\n⊢ Eq (Eq { toFun := toFun✝, map_zero' := map_zero'✝ } { toFun := toFun, map_zero' := map_zero' }) (Eq toFun✝ toFun)","decl":"/-- `ZeroHom M N` is the type of functions `M → N` that preserve zero.\n\nWhen possible, instead of parametrizing results over `(f : ZeroHom M N)`,\nyou should parametrize over `(F : Type*) [ZeroHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `ZeroHomClass`.\n-/\nstructure ZeroHom (M : Type*) (N : Type*) [Zero M] [Zero N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves 0 -/\n  protected map_zero' : toFun 0 = 0\n\n"}
{"name":"ZeroHom.mk.inj","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : Zero M\ninst✝ : Zero N\ntoFun✝ : M → N\nmap_zero'✝ : Eq (toFun✝ 0) 0\ntoFun : M → N\nmap_zero' : Eq (toFun 0) 0\nx✝ : Eq { toFun := toFun✝, map_zero' := map_zero'✝ } { toFun := toFun, map_zero' := map_zero' }\n⊢ Eq toFun✝ toFun","decl":"/-- `ZeroHom M N` is the type of functions `M → N` that preserve zero.\n\nWhen possible, instead of parametrizing results over `(f : ZeroHom M N)`,\nyou should parametrize over `(F : Type*) [ZeroHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `ZeroHomClass`.\n-/\nstructure ZeroHom (M : Type*) (N : Type*) [Zero M] [Zero N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves 0 -/\n  protected map_zero' : toFun 0 = 0\n\n"}
{"name":"ZeroHomClass.map_zero","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : FunLike F M N\nself : ZeroHomClass F M N\nf : F\n⊢ Eq (f 0) 0","decl":"/-- `ZeroHomClass F M N` states that `F` is a type of zero-preserving homomorphisms.\n\nYou should extend this typeclass when you extend `ZeroHom`.\n-/\nclass ZeroHomClass (F : Type*) (M N : outParam Type*) [Zero M] [Zero N] [FunLike F M N] :\n    Prop where\n  /-- The proposition that the function preserves 0 -/\n  map_zero : ∀ f : F, f 0 = 0\n\n-- Instances and lemmas are defined below through `@[to_additive]`.\n"}
{"name":"AddHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoFun : M → N\nmap_add' : ∀ (x y : M), Eq (toFun (HAdd.hAdd x y)) (HAdd.hAdd (toFun x) (toFun y))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_add' := map_add' }) 1","decl":"/-- `M →ₙ+ N` is the type of functions `M → N` that preserve addition. The `ₙ` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `NonUnitalAlgHom` and\n`NonUnitalRingHom`, so a `AddHom` is a non-unital additive monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : AddHom M N)`,\nyou should parametrize over `(F : Type*) [AddHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddHomClass`.\n-/\nstructure AddHom (M : Type*) (N : Type*) [Add M] [Add N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves addition -/\n  protected map_add' : ∀ x y, toFun (x + y) = toFun x + toFun y\n\n"}
{"name":"AddHom.mk.injEq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : Add M\ninst✝ : Add N\ntoFun✝ : M → N\nmap_add'✝ : ∀ (x y : M), Eq (toFun✝ (HAdd.hAdd x y)) (HAdd.hAdd (toFun✝ x) (toFun✝ y))\ntoFun : M → N\nmap_add' : ∀ (x y : M), Eq (toFun (HAdd.hAdd x y)) (HAdd.hAdd (toFun x) (toFun y))\n⊢ Eq (Eq { toFun := toFun✝, map_add' := map_add'✝ } { toFun := toFun, map_add' := map_add' }) (Eq toFun✝ toFun)","decl":"/-- `M →ₙ+ N` is the type of functions `M → N` that preserve addition. The `ₙ` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `NonUnitalAlgHom` and\n`NonUnitalRingHom`, so a `AddHom` is a non-unital additive monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : AddHom M N)`,\nyou should parametrize over `(F : Type*) [AddHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddHomClass`.\n-/\nstructure AddHom (M : Type*) (N : Type*) [Add M] [Add N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves addition -/\n  protected map_add' : ∀ x y, toFun (x + y) = toFun x + toFun y\n\n"}
{"name":"AddHom.map_add'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : Add M\ninst✝ : Add N\nself : AddHom M N\nx y : M\n⊢ Eq (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- `M →ₙ+ N` is the type of functions `M → N` that preserve addition. The `ₙ` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `NonUnitalAlgHom` and\n`NonUnitalRingHom`, so a `AddHom` is a non-unital additive monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : AddHom M N)`,\nyou should parametrize over `(F : Type*) [AddHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddHomClass`.\n-/\nstructure AddHom (M : Type*) (N : Type*) [Add M] [Add N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves addition -/\n  protected map_add' : ∀ x y, toFun (x + y) = toFun x + toFun y\n\n"}
{"name":"AddHom.mk.inj","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : Add M\ninst✝ : Add N\ntoFun✝ : M → N\nmap_add'✝ : ∀ (x y : M), Eq (toFun✝ (HAdd.hAdd x y)) (HAdd.hAdd (toFun✝ x) (toFun✝ y))\ntoFun : M → N\nmap_add' : ∀ (x y : M), Eq (toFun (HAdd.hAdd x y)) (HAdd.hAdd (toFun x) (toFun y))\nx✝ : Eq { toFun := toFun✝, map_add' := map_add'✝ } { toFun := toFun, map_add' := map_add' }\n⊢ Eq toFun✝ toFun","decl":"/-- `M →ₙ+ N` is the type of functions `M → N` that preserve addition. The `ₙ` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `NonUnitalAlgHom` and\n`NonUnitalRingHom`, so a `AddHom` is a non-unital additive monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : AddHom M N)`,\nyou should parametrize over `(F : Type*) [AddHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddHomClass`.\n-/\nstructure AddHom (M : Type*) (N : Type*) [Add M] [Add N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves addition -/\n  protected map_add' : ∀ x y, toFun (x + y) = toFun x + toFun y\n\n"}
{"name":"AddHomClass.map_add","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : FunLike F M N\nself : AddHomClass F M N\nf : F\nx y : M\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"/-- `AddHomClass F M N` states that `F` is a type of addition-preserving homomorphisms.\nYou should declare an instance of this typeclass when you extend `AddHom`.\n-/\nclass AddHomClass (F : Type*) (M N : outParam Type*) [Add M] [Add N] [FunLike F M N] : Prop where\n  /-- The proposition that the function preserves addition -/\n  map_add : ∀ (f : F) (x y : M), f (x + y) = f x + f y\n\n-- Instances and lemmas are defined below through `@[to_additive]`.\n"}
{"name":"AddMonoidHom.map_add'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nself : AddMonoidHom M N\nx y : M\n⊢ Eq (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- `M →+ N` is the type of functions `M → N` that preserve the `AddZeroClass` structure.\n\n`AddMonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →+ N)`,\nyou should parametrize over `(F : Type*) [AddMonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddMonoidHomClass`.\n-/\nstructure AddMonoidHom (M : Type*) (N : Type*) [AddZeroClass M] [AddZeroClass N] extends\n  ZeroHom M N, AddHom M N\n\n"}
{"name":"AddMonoidHom.mk.inj","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ntoZeroHom✝ : ZeroHom M N\nmap_add'✝ : ∀ (x y : M), Eq (toZeroHom✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toZeroHom✝.toFun x) (toZeroHom✝.toFun y))\ntoZeroHom : ZeroHom M N\nmap_add' : ∀ (x y : M), Eq (toZeroHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toZeroHom.toFun x) (toZeroHom.toFun y))\nx✝ : Eq { toZeroHom := toZeroHom✝, map_add' := map_add'✝ } { toZeroHom := toZeroHom, map_add' := map_add' }\n⊢ Eq toZeroHom✝ toZeroHom","decl":"/-- `M →+ N` is the type of functions `M → N` that preserve the `AddZeroClass` structure.\n\n`AddMonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →+ N)`,\nyou should parametrize over `(F : Type*) [AddMonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddMonoidHomClass`.\n-/\nstructure AddMonoidHom (M : Type*) (N : Type*) [AddZeroClass M] [AddZeroClass N] extends\n  ZeroHom M N, AddHom M N\n\n"}
{"name":"AddMonoidHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoZeroHom : ZeroHom M N\nmap_add' : ∀ (x y : M), Eq (toZeroHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toZeroHom.toFun x) (toZeroHom.toFun y))\n⊢ Eq (SizeOf.sizeOf { toZeroHom := toZeroHom, map_add' := map_add' }) (HAdd.hAdd 1 (SizeOf.sizeOf toZeroHom))","decl":"/-- `M →+ N` is the type of functions `M → N` that preserve the `AddZeroClass` structure.\n\n`AddMonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →+ N)`,\nyou should parametrize over `(F : Type*) [AddMonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddMonoidHomClass`.\n-/\nstructure AddMonoidHom (M : Type*) (N : Type*) [AddZeroClass M] [AddZeroClass N] extends\n  ZeroHom M N, AddHom M N\n\n"}
{"name":"AddMonoidHom.mk.injEq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ntoZeroHom✝ : ZeroHom M N\nmap_add'✝ : ∀ (x y : M), Eq (toZeroHom✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toZeroHom✝.toFun x) (toZeroHom✝.toFun y))\ntoZeroHom : ZeroHom M N\nmap_add' : ∀ (x y : M), Eq (toZeroHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toZeroHom.toFun x) (toZeroHom.toFun y))\n⊢ Eq (Eq { toZeroHom := toZeroHom✝, map_add' := map_add'✝ } { toZeroHom := toZeroHom, map_add' := map_add' }) (Eq toZeroHom✝ toZeroHom)","decl":"/-- `M →+ N` is the type of functions `M → N` that preserve the `AddZeroClass` structure.\n\n`AddMonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →+ N)`,\nyou should parametrize over `(F : Type*) [AddMonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `AddMonoidHomClass`.\n-/\nstructure AddMonoidHom (M : Type*) (N : Type*) [AddZeroClass M] [AddZeroClass N] extends\n  ZeroHom M N, AddHom M N\n\n"}
{"name":"AddMonoidHomClass.toAddHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : FunLike F M N\nself : AddMonoidHomClass F M N\n⊢ AddHomClass F M N","decl":"/-- `AddMonoidHomClass F M N` states that `F` is a type of `AddZeroClass`-preserving\nhomomorphisms.\n\nYou should also extend this typeclass when you extend `AddMonoidHom`.\n-/\nclass AddMonoidHomClass (F : Type*) (M N : outParam Type*)\n    [AddZeroClass M] [AddZeroClass N] [FunLike F M N]\n    extends AddHomClass F M N, ZeroHomClass F M N : Prop\n\n-- Instances and lemmas are defined below through `@[to_additive]`.\n"}
{"name":"AddMonoidHomClass.toZeroHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : FunLike F M N\nself : AddMonoidHomClass F M N\n⊢ ZeroHomClass F M N","decl":"/-- `AddMonoidHomClass F M N` states that `F` is a type of `AddZeroClass`-preserving\nhomomorphisms.\n\nYou should also extend this typeclass when you extend `AddMonoidHom`.\n-/\nclass AddMonoidHomClass (F : Type*) (M N : outParam Type*)\n    [AddZeroClass M] [AddZeroClass N] [FunLike F M N]\n    extends AddHomClass F M N, ZeroHomClass F M N : Prop\n\n-- Instances and lemmas are defined below through `@[to_additive]`.\n"}
{"name":"OneHom.mk.inj","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : One M\ninst✝ : One N\ntoFun✝ : M → N\nmap_one'✝ : Eq (toFun✝ 1) 1\ntoFun : M → N\nmap_one' : Eq (toFun 1) 1\nx✝ : Eq { toFun := toFun✝, map_one' := map_one'✝ } { toFun := toFun, map_one' := map_one' }\n⊢ Eq toFun✝ toFun","decl":"/-- `OneHom M N` is the type of functions `M → N` that preserve one.\n\nWhen possible, instead of parametrizing results over `(f : OneHom M N)`,\nyou should parametrize over `(F : Type*) [OneHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `OneHomClass`.\n-/\n@[to_additive]\nstructure OneHom (M : Type*) (N : Type*) [One M] [One N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves 1 -/\n  protected map_one' : toFun 1 = 1\n\n"}
{"name":"OneHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝³ : One M\ninst✝² : One N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoFun : M → N\nmap_one' : Eq (toFun 1) 1\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_one' := map_one' }) (HAdd.hAdd 1 (SizeOf.sizeOf map_one'))","decl":"/-- `OneHom M N` is the type of functions `M → N` that preserve one.\n\nWhen possible, instead of parametrizing results over `(f : OneHom M N)`,\nyou should parametrize over `(F : Type*) [OneHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `OneHomClass`.\n-/\n@[to_additive]\nstructure OneHom (M : Type*) (N : Type*) [One M] [One N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves 1 -/\n  protected map_one' : toFun 1 = 1\n\n"}
{"name":"OneHom.map_one'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : One M\ninst✝ : One N\nself : OneHom M N\n⊢ Eq (self.toFun 1) 1","decl":"/-- `OneHom M N` is the type of functions `M → N` that preserve one.\n\nWhen possible, instead of parametrizing results over `(f : OneHom M N)`,\nyou should parametrize over `(F : Type*) [OneHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `OneHomClass`.\n-/\n@[to_additive]\nstructure OneHom (M : Type*) (N : Type*) [One M] [One N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves 1 -/\n  protected map_one' : toFun 1 = 1\n\n"}
{"name":"OneHom.mk.injEq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : One M\ninst✝ : One N\ntoFun✝ : M → N\nmap_one'✝ : Eq (toFun✝ 1) 1\ntoFun : M → N\nmap_one' : Eq (toFun 1) 1\n⊢ Eq (Eq { toFun := toFun✝, map_one' := map_one'✝ } { toFun := toFun, map_one' := map_one' }) (Eq toFun✝ toFun)","decl":"/-- `OneHom M N` is the type of functions `M → N` that preserve one.\n\nWhen possible, instead of parametrizing results over `(f : OneHom M N)`,\nyou should parametrize over `(F : Type*) [OneHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `OneHomClass`.\n-/\n@[to_additive]\nstructure OneHom (M : Type*) (N : Type*) [One M] [One N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves 1 -/\n  protected map_one' : toFun 1 = 1\n\n"}
{"name":"OneHomClass.map_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : FunLike F M N\nself : OneHomClass F M N\nf : F\n⊢ Eq (f 1) 1","decl":"/-- `OneHomClass F M N` states that `F` is a type of one-preserving homomorphisms.\nYou should extend this typeclass when you extend `OneHom`.\n-/\n@[to_additive]\nclass OneHomClass (F : Type*) (M N : outParam Type*) [One M] [One N] [FunLike F M N] : Prop where\n  /-- The proposition that the function preserves 1 -/\n  map_one : ∀ f : F, f 1 = 1\n\n"}
{"name":"OneHom.oneHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\n⊢ OneHomClass (OneHom M N) M N","decl":"@[to_additive]\ninstance OneHom.oneHomClass : OneHomClass (OneHom M N) M N where\n  map_one := OneHom.map_one'\n\n"}
{"name":"ZeroHom.zeroHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\n⊢ ZeroHomClass (ZeroHom M N) M N","decl":"@[to_additive]\ninstance OneHom.oneHomClass : OneHomClass (OneHom M N) M N where\n  map_one := OneHom.map_one'\n\n"}
{"name":"map_zero","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Zero M\ninst✝² : Zero N\ninst✝¹ : FunLike F M N\ninst✝ : ZeroHomClass F M N\nf : F\n⊢ Eq (f 0) 0","decl":"/-- See note [low priority simp lemmas] -/\n@[to_additive (attr := simp low)]\ntheorem map_one [OneHomClass F M N] (f : F) : f 1 = 1 :=\n  OneHomClass.map_one f\n\n"}
{"name":"map_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : One M\ninst✝² : One N\ninst✝¹ : FunLike F M N\ninst✝ : OneHomClass F M N\nf : F\n⊢ Eq (f 1) 1","decl":"/-- See note [low priority simp lemmas] -/\n@[to_additive (attr := simp low)]\ntheorem map_one [OneHomClass F M N] (f : F) : f 1 = 1 :=\n  OneHomClass.map_one f\n\n"}
{"name":"map_comp_zero","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Zero M\ninst✝² : Zero N\ninst✝¹ : FunLike F M N\ninst✝ : ZeroHomClass F M N\nf : F\n⊢ Eq (Function.comp (⇑f) 0) 0","decl":"@[to_additive] lemma map_comp_one [OneHomClass F M N] (f : F) : f ∘ (1 : ι → M) = 1 := by simp\n\n"}
{"name":"map_comp_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : One M\ninst✝² : One N\ninst✝¹ : FunLike F M N\ninst✝ : OneHomClass F M N\nf : F\n⊢ Eq (Function.comp (⇑f) 1) 1","decl":"@[to_additive] lemma map_comp_one [OneHomClass F M N] (f : F) : f ∘ (1 : ι → M) = 1 := by simp\n\n"}
{"name":"Subsingleton.of_zeroHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝⁴ : Zero M\ninst✝³ : Zero N\ninst✝² : FunLike F M N\ninst✝¹ : Subsingleton M\ninst✝ : ZeroHomClass F M N\n⊢ Subsingleton F","decl":"/-- In principle this could be an instance, but in practice it causes performance issues. -/\n@[to_additive]\ntheorem Subsingleton.of_oneHomClass [Subsingleton M] [OneHomClass F M N] :\n    Subsingleton F where\n  allEq f g := DFunLike.ext _ _ fun x ↦ by simp [Subsingleton.elim x 1]\n\n"}
{"name":"Subsingleton.of_oneHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝⁴ : One M\ninst✝³ : One N\ninst✝² : FunLike F M N\ninst✝¹ : Subsingleton M\ninst✝ : OneHomClass F M N\n⊢ Subsingleton F","decl":"/-- In principle this could be an instance, but in practice it causes performance issues. -/\n@[to_additive]\ntheorem Subsingleton.of_oneHomClass [Subsingleton M] [OneHomClass F M N] :\n    Subsingleton F where\n  allEq f g := DFunLike.ext _ _ fun x ↦ by simp [Subsingleton.elim x 1]\n\n"}
{"name":"instSubsingletonOneHom","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : Subsingleton M\n⊢ Subsingleton (OneHom M N)","decl":"@[to_additive] instance [Subsingleton M] : Subsingleton (OneHom M N) := .of_oneHomClass\n\n"}
{"name":"instSubsingletonZeroHom","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Subsingleton M\n⊢ Subsingleton (ZeroHom M N)","decl":"@[to_additive] instance [Subsingleton M] : Subsingleton (OneHom M N) := .of_oneHomClass\n\n"}
{"name":"map_eq_zero_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Zero M\ninst✝² : Zero N\ninst✝¹ : FunLike F M N\ninst✝ : ZeroHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nx : M\n⊢ Iff (Eq (f x) 0) (Eq x 0)","decl":"@[to_additive]\ntheorem map_eq_one_iff [OneHomClass F M N] (f : F) (hf : Function.Injective f)\n    {x : M} :\n    f x = 1 ↔ x = 1 := hf.eq_iff' (map_one f)\n\n"}
{"name":"map_eq_one_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : One M\ninst✝² : One N\ninst✝¹ : FunLike F M N\ninst✝ : OneHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nx : M\n⊢ Iff (Eq (f x) 1) (Eq x 1)","decl":"@[to_additive]\ntheorem map_eq_one_iff [OneHomClass F M N] (f : F) (hf : Function.Injective f)\n    {x : M} :\n    f x = 1 ↔ x = 1 := hf.eq_iff' (map_one f)\n\n"}
{"name":"map_ne_one_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"R : Type u_10\nS : Type u_11\nF : Type u_12\ninst✝³ : One R\ninst✝² : One S\ninst✝¹ : FunLike F R S\ninst✝ : OneHomClass F R S\nf : F\nhf : Function.Injective ⇑f\nx : R\n⊢ Iff (Ne (f x) 1) (Ne x 1)","decl":"@[to_additive]\ntheorem map_ne_one_iff {R S F : Type*} [One R] [One S] [FunLike F R S] [OneHomClass F R S] (f : F)\n    (hf : Function.Injective f) {x : R} : f x ≠ 1 ↔ x ≠ 1 := (map_eq_one_iff f hf).not\n\n"}
{"name":"map_ne_zero_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"R : Type u_10\nS : Type u_11\nF : Type u_12\ninst✝³ : Zero R\ninst✝² : Zero S\ninst✝¹ : FunLike F R S\ninst✝ : ZeroHomClass F R S\nf : F\nhf : Function.Injective ⇑f\nx : R\n⊢ Iff (Ne (f x) 0) (Ne x 0)","decl":"@[to_additive]\ntheorem map_ne_one_iff {R S F : Type*} [One R] [One S] [FunLike F R S] [OneHomClass F R S] (f : F)\n    (hf : Function.Injective f) {x : R} : f x ≠ 1 ↔ x ≠ 1 := (map_eq_one_iff f hf).not\n\n"}
{"name":"ne_zero_of_map","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"R : Type u_10\nS : Type u_11\nF : Type u_12\ninst✝³ : Zero R\ninst✝² : Zero S\ninst✝¹ : FunLike F R S\ninst✝ : ZeroHomClass F R S\nf : F\nx : R\nhx : Ne (f x) 0\n⊢ Ne x 0","decl":"@[to_additive]\ntheorem ne_one_of_map {R S F : Type*} [One R] [One S] [FunLike F R S] [OneHomClass F R S]\n    {f : F} {x : R} (hx : f x ≠ 1) : x ≠ 1 := ne_of_apply_ne f <| (by rwa [(map_one f)])\n\n"}
{"name":"ne_one_of_map","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"R : Type u_10\nS : Type u_11\nF : Type u_12\ninst✝³ : One R\ninst✝² : One S\ninst✝¹ : FunLike F R S\ninst✝ : OneHomClass F R S\nf : F\nx : R\nhx : Ne (f x) 1\n⊢ Ne x 1","decl":"@[to_additive]\ntheorem ne_one_of_map {R S F : Type*} [One R] [One S] [FunLike F R S] [OneHomClass F R S]\n    {f : F} {x : R} (hx : f x ≠ 1) : x ≠ 1 := ne_of_apply_ne f <| (by rwa [(map_one f)])\n\n"}
{"name":"OneHom.coe_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : One M\ninst✝² : One N\ninst✝¹ : FunLike F M N\ninst✝ : OneHomClass F M N\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.coe_coe [OneHomClass F M N] (f : F) :\n    ((f : OneHom M N) : M → N) = f := rfl\n\n"}
{"name":"ZeroHom.coe_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Zero M\ninst✝² : Zero N\ninst✝¹ : FunLike F M N\ninst✝ : ZeroHomClass F M N\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.coe_coe [OneHomClass F M N] (f : F) :\n    ((f : OneHom M N) : M → N) = f := rfl\n\n"}
{"name":"MulHom.mk.injEq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : Mul M\ninst✝ : Mul N\ntoFun✝ : M → N\nmap_mul'✝ : ∀ (x y : M), Eq (toFun✝ (HMul.hMul x y)) (HMul.hMul (toFun✝ x) (toFun✝ y))\ntoFun : M → N\nmap_mul' : ∀ (x y : M), Eq (toFun (HMul.hMul x y)) (HMul.hMul (toFun x) (toFun y))\n⊢ Eq (Eq { toFun := toFun✝, map_mul' := map_mul'✝ } { toFun := toFun, map_mul' := map_mul' }) (Eq toFun✝ toFun)","decl":"/-- `M →ₙ* N` is the type of functions `M → N` that preserve multiplication. The `ₙ` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `NonUnitalAlgHom` and\n`NonUnitalRingHom`, so a `MulHom` is a non-unital monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : M →ₙ* N)`,\nyou should parametrize over `(F : Type*) [MulHomClass F M N] (f : F)`.\nWhen you extend this structure, make sure to extend `MulHomClass`.\n-/\n@[to_additive]\nstructure MulHom (M : Type*) (N : Type*) [Mul M] [Mul N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves multiplication -/\n  protected map_mul' : ∀ x y, toFun (x * y) = toFun x * toFun y\n\n"}
{"name":"MulHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoFun : M → N\nmap_mul' : ∀ (x y : M), Eq (toFun (HMul.hMul x y)) (HMul.hMul (toFun x) (toFun y))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_mul' := map_mul' }) 1","decl":"/-- `M →ₙ* N` is the type of functions `M → N` that preserve multiplication. The `ₙ` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `NonUnitalAlgHom` and\n`NonUnitalRingHom`, so a `MulHom` is a non-unital monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : M →ₙ* N)`,\nyou should parametrize over `(F : Type*) [MulHomClass F M N] (f : F)`.\nWhen you extend this structure, make sure to extend `MulHomClass`.\n-/\n@[to_additive]\nstructure MulHom (M : Type*) (N : Type*) [Mul M] [Mul N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves multiplication -/\n  protected map_mul' : ∀ x y, toFun (x * y) = toFun x * toFun y\n\n"}
{"name":"MulHom.map_mul'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : Mul M\ninst✝ : Mul N\nself : MulHom M N\nx y : M\n⊢ Eq (self.toFun (HMul.hMul x y)) (HMul.hMul (self.toFun x) (self.toFun y))","decl":"/-- `M →ₙ* N` is the type of functions `M → N` that preserve multiplication. The `ₙ` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `NonUnitalAlgHom` and\n`NonUnitalRingHom`, so a `MulHom` is a non-unital monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : M →ₙ* N)`,\nyou should parametrize over `(F : Type*) [MulHomClass F M N] (f : F)`.\nWhen you extend this structure, make sure to extend `MulHomClass`.\n-/\n@[to_additive]\nstructure MulHom (M : Type*) (N : Type*) [Mul M] [Mul N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves multiplication -/\n  protected map_mul' : ∀ x y, toFun (x * y) = toFun x * toFun y\n\n"}
{"name":"MulHom.mk.inj","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : Mul M\ninst✝ : Mul N\ntoFun✝ : M → N\nmap_mul'✝ : ∀ (x y : M), Eq (toFun✝ (HMul.hMul x y)) (HMul.hMul (toFun✝ x) (toFun✝ y))\ntoFun : M → N\nmap_mul' : ∀ (x y : M), Eq (toFun (HMul.hMul x y)) (HMul.hMul (toFun x) (toFun y))\nx✝ : Eq { toFun := toFun✝, map_mul' := map_mul'✝ } { toFun := toFun, map_mul' := map_mul' }\n⊢ Eq toFun✝ toFun","decl":"/-- `M →ₙ* N` is the type of functions `M → N` that preserve multiplication. The `ₙ` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `NonUnitalAlgHom` and\n`NonUnitalRingHom`, so a `MulHom` is a non-unital monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : M →ₙ* N)`,\nyou should parametrize over `(F : Type*) [MulHomClass F M N] (f : F)`.\nWhen you extend this structure, make sure to extend `MulHomClass`.\n-/\n@[to_additive]\nstructure MulHom (M : Type*) (N : Type*) [Mul M] [Mul N] where\n  /-- The underlying function -/\n  protected toFun : M → N\n  /-- The proposition that the function preserves multiplication -/\n  protected map_mul' : ∀ x y, toFun (x * y) = toFun x * toFun y\n\n"}
{"name":"MulHomClass.map_mul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : FunLike F M N\nself : MulHomClass F M N\nf : F\nx y : M\n⊢ Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))","decl":"/-- `MulHomClass F M N` states that `F` is a type of multiplication-preserving homomorphisms.\n\nYou should declare an instance of this typeclass when you extend `MulHom`.\n-/\n@[to_additive]\nclass MulHomClass (F : Type*) (M N : outParam Type*) [Mul M] [Mul N] [FunLike F M N] : Prop where\n  /-- The proposition that the function preserves multiplication -/\n  map_mul : ∀ (f : F) (x y : M), f (x * y) = f x * f y\n\n"}
{"name":"AddHom.addHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\n⊢ AddHomClass (AddHom M N) M N","decl":"/-- `MulHom` is a type of multiplication-preserving homomorphisms -/\n@[to_additive \"`AddHom` is a type of addition-preserving homomorphisms\"]\ninstance MulHom.mulHomClass : MulHomClass (M →ₙ* N) M N where\n  map_mul := MulHom.map_mul'\n\n"}
{"name":"MulHom.mulHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\n⊢ MulHomClass (MulHom M N) M N","decl":"/-- `MulHom` is a type of multiplication-preserving homomorphisms -/\n@[to_additive \"`AddHom` is a type of addition-preserving homomorphisms\"]\ninstance MulHom.mulHomClass : MulHomClass (M →ₙ* N) M N where\n  map_mul := MulHom.map_mul'\n\n"}
{"name":"map_mul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : FunLike F M N\ninst✝ : MulHomClass F M N\nf : F\nx y : M\n⊢ Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))","decl":"/-- See note [low priority simp lemmas] -/\n@[to_additive (attr := simp low)]\ntheorem map_mul [MulHomClass F M N] (f : F) (x y : M) : f (x * y) = f x * f y :=\n  MulHomClass.map_mul f x y\n\n"}
{"name":"map_add","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : FunLike F M N\ninst✝ : AddHomClass F M N\nf : F\nx y : M\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"/-- See note [low priority simp lemmas] -/\n@[to_additive (attr := simp low)]\ntheorem map_mul [MulHomClass F M N] (f : F) (x y : M) : f (x * y) = f x * f y :=\n  MulHomClass.map_mul f x y\n\n"}
{"name":"map_comp_add","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : FunLike F M N\ninst✝ : AddHomClass F M N\nf : F\ng h : ι → M\n⊢ Eq (Function.comp (⇑f) (HAdd.hAdd g h)) (HAdd.hAdd (Function.comp (⇑f) g) (Function.comp (⇑f) h))","decl":"@[to_additive (attr := simp)]\nlemma map_comp_mul [MulHomClass F M N] (f : F) (g h : ι → M) : f ∘ (g * h) = f ∘ g * f ∘ h := by\n  ext; simp\n\n"}
{"name":"map_comp_mul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : FunLike F M N\ninst✝ : MulHomClass F M N\nf : F\ng h : ι → M\n⊢ Eq (Function.comp (⇑f) (HMul.hMul g h)) (HMul.hMul (Function.comp (⇑f) g) (Function.comp (⇑f) h))","decl":"@[to_additive (attr := simp)]\nlemma map_comp_mul [MulHomClass F M N] (f : F) (g h : ι → M) : f ∘ (g * h) = f ∘ g * f ∘ h := by\n  ext; simp\n\n"}
{"name":"MulHom.coe_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : FunLike F M N\ninst✝ : MulHomClass F M N\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.coe_coe [MulHomClass F M N] (f : F) : ((f : MulHom M N) : M → N) = f := rfl\n\n"}
{"name":"AddHom.coe_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : FunLike F M N\ninst✝ : AddHomClass F M N\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.coe_coe [MulHomClass F M N] (f : F) : ((f : MulHom M N) : M → N) = f := rfl\n\n"}
{"name":"MonoidHom.mk.inj","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ntoOneHom✝ : OneHom M N\nmap_mul'✝ : ∀ (x y : M), Eq (toOneHom✝.toFun (HMul.hMul x y)) (HMul.hMul (toOneHom✝.toFun x) (toOneHom✝.toFun y))\ntoOneHom : OneHom M N\nmap_mul' : ∀ (x y : M), Eq (toOneHom.toFun (HMul.hMul x y)) (HMul.hMul (toOneHom.toFun x) (toOneHom.toFun y))\nx✝ : Eq { toOneHom := toOneHom✝, map_mul' := map_mul'✝ } { toOneHom := toOneHom, map_mul' := map_mul' }\n⊢ Eq toOneHom✝ toOneHom","decl":"/-- `M →* N` is the type of functions `M → N` that preserve the `Monoid` structure.\n`MonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →* N)`,\nyou should parametrize over `(F : Type*) [MonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `MonoidHomClass`.\n-/\n@[to_additive]\nstructure MonoidHom (M : Type*) (N : Type*) [MulOneClass M] [MulOneClass N] extends\n  OneHom M N, M →ₙ* N\n\n"}
{"name":"MonoidHom.mk.injEq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ntoOneHom✝ : OneHom M N\nmap_mul'✝ : ∀ (x y : M), Eq (toOneHom✝.toFun (HMul.hMul x y)) (HMul.hMul (toOneHom✝.toFun x) (toOneHom✝.toFun y))\ntoOneHom : OneHom M N\nmap_mul' : ∀ (x y : M), Eq (toOneHom.toFun (HMul.hMul x y)) (HMul.hMul (toOneHom.toFun x) (toOneHom.toFun y))\n⊢ Eq (Eq { toOneHom := toOneHom✝, map_mul' := map_mul'✝ } { toOneHom := toOneHom, map_mul' := map_mul' }) (Eq toOneHom✝ toOneHom)","decl":"/-- `M →* N` is the type of functions `M → N` that preserve the `Monoid` structure.\n`MonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →* N)`,\nyou should parametrize over `(F : Type*) [MonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `MonoidHomClass`.\n-/\n@[to_additive]\nstructure MonoidHom (M : Type*) (N : Type*) [MulOneClass M] [MulOneClass N] extends\n  OneHom M N, M →ₙ* N\n\n"}
{"name":"MonoidHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoOneHom : OneHom M N\nmap_mul' : ∀ (x y : M), Eq (toOneHom.toFun (HMul.hMul x y)) (HMul.hMul (toOneHom.toFun x) (toOneHom.toFun y))\n⊢ Eq (SizeOf.sizeOf { toOneHom := toOneHom, map_mul' := map_mul' }) (HAdd.hAdd 1 (SizeOf.sizeOf toOneHom))","decl":"/-- `M →* N` is the type of functions `M → N` that preserve the `Monoid` structure.\n`MonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →* N)`,\nyou should parametrize over `(F : Type*) [MonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `MonoidHomClass`.\n-/\n@[to_additive]\nstructure MonoidHom (M : Type*) (N : Type*) [MulOneClass M] [MulOneClass N] extends\n  OneHom M N, M →ₙ* N\n\n"}
{"name":"MonoidHom.map_mul'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\nN : Type u_11\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nself : MonoidHom M N\nx y : M\n⊢ Eq (self.toFun (HMul.hMul x y)) (HMul.hMul (self.toFun x) (self.toFun y))","decl":"/-- `M →* N` is the type of functions `M → N` that preserve the `Monoid` structure.\n`MonoidHom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M →* N)`,\nyou should parametrize over `(F : Type*) [MonoidHomClass F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `MonoidHomClass`.\n-/\n@[to_additive]\nstructure MonoidHom (M : Type*) (N : Type*) [MulOneClass M] [MulOneClass N] extends\n  OneHom M N, M →ₙ* N\n\n"}
{"name":"MonoidHomClass.toOneHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : FunLike F M N\nself : MonoidHomClass F M N\n⊢ OneHomClass F M N","decl":"/-- `MonoidHomClass F M N` states that `F` is a type of `Monoid`-preserving homomorphisms.\nYou should also extend this typeclass when you extend `MonoidHom`. -/\n@[to_additive]\nclass MonoidHomClass (F : Type*) (M N : outParam Type*) [MulOneClass M] [MulOneClass N]\n  [FunLike F M N]\n  extends MulHomClass F M N, OneHomClass F M N : Prop\n\n"}
{"name":"MonoidHomClass.toMulHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : FunLike F M N\nself : MonoidHomClass F M N\n⊢ MulHomClass F M N","decl":"/-- `MonoidHomClass F M N` states that `F` is a type of `Monoid`-preserving homomorphisms.\nYou should also extend this typeclass when you extend `MonoidHom`. -/\n@[to_additive]\nclass MonoidHomClass (F : Type*) (M N : outParam Type*) [MulOneClass M] [MulOneClass N]\n  [FunLike F M N]\n  extends MulHomClass F M N, OneHomClass F M N : Prop\n\n"}
{"name":"MonoidHom.instMonoidHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ MonoidHomClass (MonoidHom M N) M N","decl":"@[to_additive]\ninstance MonoidHom.instMonoidHomClass : MonoidHomClass (M →* N) M N where\n  map_mul := MonoidHom.map_mul'\n  map_one f := f.toOneHom.map_one'\n\n"}
{"name":"AddMonoidHom.instAddMonoidHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ AddMonoidHomClass (AddMonoidHom M N) M N","decl":"@[to_additive]\ninstance MonoidHom.instMonoidHomClass : MonoidHomClass (M →* N) M N where\n  map_mul := MonoidHom.map_mul'\n  map_one f := f.toOneHom.map_one'\n\n"}
{"name":"instSubsingletonAddMonoidHom","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : Subsingleton M\n⊢ Subsingleton (AddMonoidHom M N)","decl":"@[to_additive] instance [Subsingleton M] : Subsingleton (M →* N) := .of_oneHomClass\n\n"}
{"name":"instSubsingletonMonoidHom","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Subsingleton M\n⊢ Subsingleton (MonoidHom M N)","decl":"@[to_additive] instance [Subsingleton M] : Subsingleton (M →* N) := .of_oneHomClass\n\n"}
{"name":"MonoidHom.coe_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_coe [MonoidHomClass F M N] (f : F) : ((f : M →* N) : M → N) = f := rfl\n\n"}
{"name":"AddMonoidHom.coe_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : FunLike F M N\ninst✝ : AddMonoidHomClass F M N\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_coe [MonoidHomClass F M N] (f : F) : ((f : M →* N) : M → N) = f := rfl\n\n"}
{"name":"map_mul_eq_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nf : F\na b : M\nh : Eq (HMul.hMul a b) 1\n⊢ Eq (HMul.hMul (f a) (f b)) 1","decl":"@[to_additive]\ntheorem map_mul_eq_one [MonoidHomClass F M N] (f : F) {a b : M} (h : a * b = 1) :\n    f a * f b = 1 := by\n  rw [← map_mul, h, map_one]\n\n"}
{"name":"map_add_eq_zero","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : FunLike F M N\ninst✝ : AddMonoidHomClass F M N\nf : F\na b : M\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq (HAdd.hAdd (f a) (f b)) 0","decl":"@[to_additive]\ntheorem map_mul_eq_one [MonoidHomClass F M N] (f : F) {a b : M} (h : a * b = 1) :\n    f a * f b = 1 := by\n  rw [← map_mul, h, map_one]\n\n"}
{"name":"map_sub'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : SubNegMonoid G\ninst✝¹ : SubNegMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\nhf : ∀ (a : G), Eq (f (Neg.neg a)) (Neg.neg (f a))\na b : G\n⊢ Eq (f (HSub.hSub a b)) (HSub.hSub (f a) (f b))","decl":"@[to_additive]\ntheorem map_div' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H]\n    (f : F) (hf : ∀ a, f a⁻¹ = (f a)⁻¹) (a b : G) : f (a / b) = f a / f b := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, map_mul, hf]\n\n"}
{"name":"map_div'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : DivInvMonoid G\ninst✝¹ : DivInvMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\nhf : ∀ (a : G), Eq (f (Inv.inv a)) (Inv.inv (f a))\na b : G\n⊢ Eq (f (HDiv.hDiv a b)) (HDiv.hDiv (f a) (f b))","decl":"@[to_additive]\ntheorem map_div' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H]\n    (f : F) (hf : ∀ a, f a⁻¹ = (f a)⁻¹) (a b : G) : f (a / b) = f a / f b := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, map_mul, hf]\n\n"}
{"name":"map_comp_div'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : DivInvMonoid G\ninst✝¹ : DivInvMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\nhf : ∀ (a : G), Eq (f (Inv.inv a)) (Inv.inv (f a))\ng h : ι → G\n⊢ Eq (Function.comp (⇑f) (HDiv.hDiv g h)) (HDiv.hDiv (Function.comp (⇑f) g) (Function.comp (⇑f) h))","decl":"@[to_additive]\nlemma map_comp_div' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H] (f : F)\n    (hf : ∀ a, f a⁻¹ = (f a)⁻¹) (g h : ι → G) : f ∘ (g / h) = f ∘ g / f ∘ h := by\n  ext; simp [map_div' f hf]\n\n"}
{"name":"map_comp_sub'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : SubNegMonoid G\ninst✝¹ : SubNegMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\nhf : ∀ (a : G), Eq (f (Neg.neg a)) (Neg.neg (f a))\ng h : ι → G\n⊢ Eq (Function.comp (⇑f) (HSub.hSub g h)) (HSub.hSub (Function.comp (⇑f) g) (Function.comp (⇑f) h))","decl":"@[to_additive]\nlemma map_comp_div' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H] (f : F)\n    (hf : ∀ a, f a⁻¹ = (f a)⁻¹) (g h : ι → G) : f ∘ (g / h) = f ∘ g / f ∘ h := by\n  ext; simp [map_div' f hf]\n\n"}
{"name":"map_neg","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddGroup G\ninst✝¹ : SubtractionMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\na : G\n⊢ Eq (f (Neg.neg a)) (Neg.neg (f a))","decl":"/-- Group homomorphisms preserve inverse.\n\nSee note [low priority simp lemmas] -/\n@[to_additive (attr := simp low) \"Additive group homomorphisms preserve negation.\"]\ntheorem map_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H]\n    (f : F) (a : G) : f a⁻¹ = (f a)⁻¹ :=\n  eq_inv_of_mul_eq_one_left <| map_mul_eq_one f <| inv_mul_cancel _\n\n"}
{"name":"map_inv","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Group G\ninst✝¹ : DivisionMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\na : G\n⊢ Eq (f (Inv.inv a)) (Inv.inv (f a))","decl":"/-- Group homomorphisms preserve inverse.\n\nSee note [low priority simp lemmas] -/\n@[to_additive (attr := simp low) \"Additive group homomorphisms preserve negation.\"]\ntheorem map_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H]\n    (f : F) (a : G) : f a⁻¹ = (f a)⁻¹ :=\n  eq_inv_of_mul_eq_one_left <| map_mul_eq_one f <| inv_mul_cancel _\n\n"}
{"name":"map_comp_inv","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Group G\ninst✝¹ : DivisionMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\ng : ι → G\n⊢ Eq (Function.comp (⇑f) (Inv.inv g)) (Inv.inv (Function.comp (⇑f) g))","decl":"@[to_additive (attr := simp)]\nlemma map_comp_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (g : ι → G) :\n    f ∘ g⁻¹ = (f ∘ g)⁻¹ := by ext; simp\n\n"}
{"name":"map_comp_neg","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddGroup G\ninst✝¹ : SubtractionMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\ng : ι → G\n⊢ Eq (Function.comp (⇑f) (Neg.neg g)) (Neg.neg (Function.comp (⇑f) g))","decl":"@[to_additive (attr := simp)]\nlemma map_comp_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (g : ι → G) :\n    f ∘ g⁻¹ = (f ∘ g)⁻¹ := by ext; simp\n\n"}
{"name":"map_add_neg","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddGroup G\ninst✝¹ : SubtractionMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\na b : G\n⊢ Eq (f (HAdd.hAdd a (Neg.neg b))) (HAdd.hAdd (f a) (Neg.neg (f b)))","decl":"/-- Group homomorphisms preserve division. -/\n@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\ntheorem map_mul_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (a b : G) :\n    f (a * b⁻¹) = f a * (f b)⁻¹ := by rw [map_mul, map_inv]\n\n"}
{"name":"map_mul_inv","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Group G\ninst✝¹ : DivisionMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\na b : G\n⊢ Eq (f (HMul.hMul a (Inv.inv b))) (HMul.hMul (f a) (Inv.inv (f b)))","decl":"/-- Group homomorphisms preserve division. -/\n@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\ntheorem map_mul_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (a b : G) :\n    f (a * b⁻¹) = f a * (f b)⁻¹ := by rw [map_mul, map_inv]\n\n"}
{"name":"map_comp_add_neg","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddGroup G\ninst✝¹ : SubtractionMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\ng h : ι → G\n⊢ Eq (Function.comp (⇑f) (HAdd.hAdd g (Neg.neg h))) (HAdd.hAdd (Function.comp (⇑f) g) (Neg.neg (Function.comp (⇑f) h)))","decl":"@[to_additive]\nlemma map_comp_mul_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (g h : ι → G) :\n    f ∘ (g * h⁻¹) = f ∘ g * (f ∘ h)⁻¹ := by simp\n\n"}
{"name":"map_comp_mul_inv","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Group G\ninst✝¹ : DivisionMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\ng h : ι → G\n⊢ Eq (Function.comp (⇑f) (HMul.hMul g (Inv.inv h))) (HMul.hMul (Function.comp (⇑f) g) (Inv.inv (Function.comp (⇑f) h)))","decl":"@[to_additive]\nlemma map_comp_mul_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (g h : ι → G) :\n    f ∘ (g * h⁻¹) = f ∘ g * (f ∘ h)⁻¹ := by simp\n\n"}
{"name":"map_sub","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddGroup G\ninst✝¹ : SubtractionMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\na b : G\n⊢ Eq (f (HSub.hSub a b)) (HSub.hSub (f a) (f b))","decl":"/-- Group homomorphisms preserve division.\n\nSee note [low priority simp lemmas] -/\n@[to_additive (attr := simp low) \"Additive group homomorphisms preserve subtraction.\"]\ntheorem map_div [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) :\n    ∀ a b, f (a / b) = f a / f b := map_div' _ <| map_inv f\n\n"}
{"name":"map_div","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Group G\ninst✝¹ : DivisionMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\na b : G\n⊢ Eq (f (HDiv.hDiv a b)) (HDiv.hDiv (f a) (f b))","decl":"/-- Group homomorphisms preserve division.\n\nSee note [low priority simp lemmas] -/\n@[to_additive (attr := simp low) \"Additive group homomorphisms preserve subtraction.\"]\ntheorem map_div [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) :\n    ∀ a b, f (a / b) = f a / f b := map_div' _ <| map_inv f\n\n"}
{"name":"map_comp_div","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Group G\ninst✝¹ : DivisionMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\ng h : ι → G\n⊢ Eq (Function.comp (⇑f) (HDiv.hDiv g h)) (HDiv.hDiv (Function.comp (⇑f) g) (Function.comp (⇑f) h))","decl":"@[to_additive (attr := simp)]\nlemma map_comp_div [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (g h : ι → G) :\n    f ∘ (g / h) = f ∘ g / f ∘ h := by ext; simp\n\n"}
{"name":"map_comp_sub","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddGroup G\ninst✝¹ : SubtractionMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\ng h : ι → G\n⊢ Eq (Function.comp (⇑f) (HSub.hSub g h)) (HSub.hSub (Function.comp (⇑f) g) (Function.comp (⇑f) h))","decl":"@[to_additive (attr := simp)]\nlemma map_comp_div [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (g h : ι → G) :\n    f ∘ (g / h) = f ∘ g / f ∘ h := by ext; simp\n\n"}
{"name":"map_pow","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Monoid G\ninst✝¹ : Monoid H\ninst✝ : MonoidHomClass F G H\nf : F\na : G\nn : Nat\n⊢ Eq (f (HPow.hPow a n)) (HPow.hPow (f a) n)","decl":"/-- See note [low priority simp lemmas] -/\n@[to_additive (attr := simp low) (reorder := 9 10)]\ntheorem map_pow [Monoid G] [Monoid H] [MonoidHomClass F G H] (f : F) (a : G) :\n    ∀ n : ℕ, f (a ^ n) = f a ^ n\n  | 0 => by rw [pow_zero, pow_zero, map_one]\n  | n + 1 => by rw [pow_succ, pow_succ, map_mul, map_pow f a n]\n\n"}
{"name":"map_nsmul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddMonoid G\ninst✝¹ : AddMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\nn : Nat\na : G\n⊢ Eq (f (HSMul.hSMul n a)) (HSMul.hSMul n (f a))","decl":"/-- See note [low priority simp lemmas] -/\n@[to_additive (attr := simp low) (reorder := 9 10)]\ntheorem map_pow [Monoid G] [Monoid H] [MonoidHomClass F G H] (f : F) (a : G) :\n    ∀ n : ℕ, f (a ^ n) = f a ^ n\n  | 0 => by rw [pow_zero, pow_zero, map_one]\n  | n + 1 => by rw [pow_succ, pow_succ, map_mul, map_pow f a n]\n\n"}
{"name":"map_comp_pow","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Monoid G\ninst✝¹ : Monoid H\ninst✝ : MonoidHomClass F G H\nf : F\ng : ι → G\nn : Nat\n⊢ Eq (Function.comp (⇑f) (HPow.hPow g n)) (HPow.hPow (Function.comp (⇑f) g) n)","decl":"@[to_additive (attr := simp)]\nlemma map_comp_pow [Monoid G] [Monoid H] [MonoidHomClass F G H] (f : F) (g : ι → G) (n : ℕ) :\n    f ∘ (g ^ n) = f ∘ g ^ n := by ext; simp\n\n"}
{"name":"map_comp_nsmul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddMonoid G\ninst✝¹ : AddMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\ng : ι → G\nn : Nat\n⊢ Eq (Function.comp (⇑f) (HSMul.hSMul n g)) (HSMul.hSMul n (Function.comp (⇑f) g))","decl":"@[to_additive (attr := simp)]\nlemma map_comp_pow [Monoid G] [Monoid H] [MonoidHomClass F G H] (f : F) (g : ι → G) (n : ℕ) :\n    f ∘ (g ^ n) = f ∘ g ^ n := by ext; simp\n\n"}
{"name":"map_zpow'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : DivInvMonoid G\ninst✝¹ : DivInvMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\nhf : ∀ (x : G), Eq (f (Inv.inv x)) (Inv.inv (f x))\na : G\nn : Int\n⊢ Eq (f (HPow.hPow a n)) (HPow.hPow (f a) n)","decl":"@[to_additive]\ntheorem map_zpow' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H]\n    (f : F) (hf : ∀ x : G, f x⁻¹ = (f x)⁻¹) (a : G) : ∀ n : ℤ, f (a ^ n) = f a ^ n\n  | (n : ℕ) => by rw [zpow_natCast, map_pow, zpow_natCast]\n  | Int.negSucc n => by rw [zpow_negSucc, hf, map_pow, ← zpow_negSucc]\n\n"}
{"name":"map_zsmul'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : SubNegMonoid G\ninst✝¹ : SubNegMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\nhf : ∀ (x : G), Eq (f (Neg.neg x)) (Neg.neg (f x))\na : G\nn : Int\n⊢ Eq (f (HSMul.hSMul n a)) (HSMul.hSMul n (f a))","decl":"@[to_additive]\ntheorem map_zpow' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H]\n    (f : F) (hf : ∀ x : G, f x⁻¹ = (f x)⁻¹) (a : G) : ∀ n : ℤ, f (a ^ n) = f a ^ n\n  | (n : ℕ) => by rw [zpow_natCast, map_pow, zpow_natCast]\n  | Int.negSucc n => by rw [zpow_negSucc, hf, map_pow, ← zpow_negSucc]\n\n"}
{"name":"map_comp_zpow'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : DivInvMonoid G\ninst✝¹ : DivInvMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\nhf : ∀ (x : G), Eq (f (Inv.inv x)) (Inv.inv (f x))\ng : ι → G\nn : Int\n⊢ Eq (Function.comp (⇑f) (HPow.hPow g n)) (HPow.hPow (Function.comp (⇑f) g) n)","decl":"@[to_additive (attr := simp)]\nlemma map_comp_zpow' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H] (f : F)\n    (hf : ∀ x : G, f x⁻¹ = (f x)⁻¹) (g : ι → G) (n : ℤ) : f ∘ (g ^ n) = f ∘ g ^ n := by\n  ext; simp [map_zpow' f hf]\n\n"}
{"name":"map_comp_zsmul'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : SubNegMonoid G\ninst✝¹ : SubNegMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\nhf : ∀ (x : G), Eq (f (Neg.neg x)) (Neg.neg (f x))\ng : ι → G\nn : Int\n⊢ Eq (Function.comp (⇑f) (HSMul.hSMul n g)) (HSMul.hSMul n (Function.comp (⇑f) g))","decl":"@[to_additive (attr := simp)]\nlemma map_comp_zpow' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H] (f : F)\n    (hf : ∀ x : G, f x⁻¹ = (f x)⁻¹) (g : ι → G) (n : ℤ) : f ∘ (g ^ n) = f ∘ g ^ n := by\n  ext; simp [map_zpow' f hf]\n\n"}
{"name":"map_zpow","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Group G\ninst✝¹ : DivisionMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\ng : G\nn : Int\n⊢ Eq (f (HPow.hPow g n)) (HPow.hPow (f g) n)","decl":"/-- Group homomorphisms preserve integer power.\n\nSee note [low priority simp lemmas] -/\n@[to_additive (attr := simp low) (reorder := 9 10)\n\"Additive group homomorphisms preserve integer scaling.\"]\ntheorem map_zpow [Group G] [DivisionMonoid H] [MonoidHomClass F G H]\n    (f : F) (g : G) (n : ℤ) : f (g ^ n) = f g ^ n := map_zpow' f (map_inv f) g n\n\n"}
{"name":"map_zsmul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"G : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddGroup G\ninst✝¹ : SubtractionMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\nn : Int\ng : G\n⊢ Eq (f (HSMul.hSMul n g)) (HSMul.hSMul n (f g))","decl":"/-- Group homomorphisms preserve integer power.\n\nSee note [low priority simp lemmas] -/\n@[to_additive (attr := simp low) (reorder := 9 10)\n\"Additive group homomorphisms preserve integer scaling.\"]\ntheorem map_zpow [Group G] [DivisionMonoid H] [MonoidHomClass F G H]\n    (f : F) (g : G) (n : ℤ) : f (g ^ n) = f g ^ n := map_zpow' f (map_inv f) g n\n\n"}
{"name":"map_comp_zsmul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : AddGroup G\ninst✝¹ : SubtractionMonoid H\ninst✝ : AddMonoidHomClass F G H\nf : F\ng : ι → G\nn : Int\n⊢ Eq (Function.comp (⇑f) (HSMul.hSMul n g)) (HSMul.hSMul n (Function.comp (⇑f) g))","decl":"@[to_additive]\nlemma map_comp_zpow [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (g : ι → G)\n    (n : ℤ) : f ∘ (g ^ n) = f ∘ g ^ n := by simp\n\n"}
{"name":"map_comp_zpow","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"ι : Type u_1\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst✝³ : FunLike F G H\ninst✝² : Group G\ninst✝¹ : DivisionMonoid H\ninst✝ : MonoidHomClass F G H\nf : F\ng : ι → G\nn : Int\n⊢ Eq (Function.comp (⇑f) (HPow.hPow g n)) (HPow.hPow (Function.comp (⇑f) g) n)","decl":"@[to_additive]\nlemma map_comp_zpow [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (g : ι → G)\n    (n : ℤ) : f ∘ (g ^ n) = f ∘ g ^ n := by simp\n\n"}
{"name":"OneHom.coe_mk","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nf : M → N\nh1 : Eq (f 1) 1\n⊢ Eq (⇑{ toFun := f, map_one' := h1 }) f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.coe_mk [One M] [One N] (f : M → N) (h1) : (OneHom.mk f h1 : M → N) = f := rfl\n\n"}
{"name":"ZeroHom.coe_mk","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : M → N\nh1 : Eq (f 0) 0\n⊢ Eq (⇑{ toFun := f, map_zero' := h1 }) f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.coe_mk [One M] [One N] (f : M → N) (h1) : (OneHom.mk f h1 : M → N) = f := rfl\n\n"}
{"name":"OneHom.toFun_eq_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nf : OneHom M N\n⊢ Eq f.toFun ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.toFun_eq_coe [One M] [One N] (f : OneHom M N) : f.toFun = f := rfl\n\n"}
{"name":"ZeroHom.toFun_eq_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : ZeroHom M N\n⊢ Eq f.toFun ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.toFun_eq_coe [One M] [One N] (f : OneHom M N) : f.toFun = f := rfl\n\n"}
{"name":"MulHom.coe_mk","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : M → N\nhmul : ∀ (x y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq (⇑{ toFun := f, map_mul' := hmul }) f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.coe_mk [Mul M] [Mul N] (f : M → N) (hmul) : (MulHom.mk f hmul : M → N) = f := rfl\n\n"}
{"name":"AddHom.coe_mk","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : M → N\nhmul : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\n⊢ Eq (⇑{ toFun := f, map_add' := hmul }) f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.coe_mk [Mul M] [Mul N] (f : M → N) (hmul) : (MulHom.mk f hmul : M → N) = f := rfl\n\n"}
{"name":"MulHom.toFun_eq_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Eq f.toFun ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.toFun_eq_coe [Mul M] [Mul N] (f : M →ₙ* N) : f.toFun = f := rfl\n\n"}
{"name":"AddHom.toFun_eq_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Eq f.toFun ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.toFun_eq_coe [Mul M] [Mul N] (f : M →ₙ* N) : f.toFun = f := rfl\n\n"}
{"name":"AddMonoidHom.coe_mk","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : ZeroHom M N\nhmul : ∀ (x y : M), Eq (f.toFun (HAdd.hAdd x y)) (HAdd.hAdd (f.toFun x) (f.toFun y))\n⊢ Eq ⇑{ toZeroHom := f, map_add' := hmul } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_mk [MulOneClass M] [MulOneClass N] (f hmul) :\n    (MonoidHom.mk f hmul : M → N) = f := rfl\n\n"}
{"name":"MonoidHom.coe_mk","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : OneHom M N\nhmul : ∀ (x y : M), Eq (f.toFun (HMul.hMul x y)) (HMul.hMul (f.toFun x) (f.toFun y))\n⊢ Eq ⇑{ toOneHom := f, map_mul' := hmul } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_mk [MulOneClass M] [MulOneClass N] (f hmul) :\n    (MonoidHom.mk f hmul : M → N) = f := rfl\n\n"}
{"name":"MonoidHom.toOneHom_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.toOneHom_coe [MulOneClass M] [MulOneClass N] (f : M →* N) :\n    (f.toOneHom : M → N) = f := rfl\n\n"}
{"name":"AddMonoidHom.toZeroHom_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.toOneHom_coe [MulOneClass M] [MulOneClass N] (f : M →* N) :\n    (f.toOneHom : M → N) = f := rfl\n\n"}
{"name":"AddMonoidHom.toAddHom_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq (↑f).toFun ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.toMulHom_coe [MulOneClass M] [MulOneClass N] (f : M →* N) :\n    f.toMulHom.toFun = f := rfl\n\n"}
{"name":"MonoidHom.toMulHom_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\n⊢ Eq (↑f).toFun ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.toMulHom_coe [MulOneClass M] [MulOneClass N] (f : M →* N) :\n    f.toMulHom.toFun = f := rfl\n\n"}
{"name":"MonoidHom.toFun_eq_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\n⊢ Eq (↑f).toFun ⇑f","decl":"@[to_additive]\ntheorem MonoidHom.toFun_eq_coe [MulOneClass M] [MulOneClass N] (f : M →* N) : f.toFun = f := rfl\n\n"}
{"name":"AddMonoidHom.toFun_eq_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq (↑f).toFun ⇑f","decl":"@[to_additive]\ntheorem MonoidHom.toFun_eq_coe [MulOneClass M] [MulOneClass N] (f : M →* N) : f.toFun = f := rfl\n\n"}
{"name":"ZeroHom.ext_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nf g : ZeroHom M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem OneHom.ext [One M] [One N] ⦃f g : OneHom M N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"OneHom.ext","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nf g : OneHom M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem OneHom.ext [One M] [One N] ⦃f g : OneHom M N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"OneHom.ext_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nf g : OneHom M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem OneHom.ext [One M] [One N] ⦃f g : OneHom M N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ZeroHom.ext","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nf g : ZeroHom M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem OneHom.ext [One M] [One N] ⦃f g : OneHom M N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AddHom.ext_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf g : AddHom M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem MulHom.ext [Mul M] [Mul N] ⦃f g : M →ₙ* N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MulHom.ext","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf g : MulHom M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem MulHom.ext [Mul M] [Mul N] ⦃f g : M →ₙ* N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AddHom.ext","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf g : AddHom M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem MulHom.ext [Mul M] [Mul N] ⦃f g : M →ₙ* N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MulHom.ext_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf g : MulHom M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem MulHom.ext [Mul M] [Mul N] ⦃f g : M →ₙ* N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MonoidHom.ext","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf g : MonoidHom M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem MonoidHom.ext [MulOneClass M] [MulOneClass N] ⦃f g : M →* N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AddMonoidHom.ext","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf g : AddMonoidHom M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem MonoidHom.ext [MulOneClass M] [MulOneClass N] ⦃f g : M →* N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AddMonoidHom.ext_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf g : AddMonoidHom M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem MonoidHom.ext [MulOneClass M] [MulOneClass N] ⦃f g : M →* N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MonoidHom.ext_iff","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf g : MonoidHom M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem MonoidHom.ext [MulOneClass M] [MulOneClass N] ⦃f g : M →* N⦄ (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MonoidHom.mk'_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nG : Type u_7\ninst✝¹ : Group G\ninst✝ : MulOneClass M\nf : M → G\nmap_mul : ∀ (a b : M), Eq (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))\n⊢ Eq (⇑(MonoidHom.mk' f map_mul)) f","decl":"/-- Makes a group homomorphism from a proof that the map preserves multiplication. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Makes an additive group homomorphism from a proof that the map preserves addition.\"]\ndef mk' (f : M → G) (map_mul : ∀ a b : M, f (a * b) = f a * f b) : M →* G where\n  toFun := f\n  map_mul' := map_mul\n  map_one' := by rw [← mul_right_cancel_iff, ← map_mul _ 1, one_mul, one_mul]\n\n"}
{"name":"AddMonoidHom.mk'_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nG : Type u_7\ninst✝¹ : AddGroup G\ninst✝ : AddZeroClass M\nf : M → G\nmap_mul : ∀ (a b : M), Eq (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))\n⊢ Eq (⇑(AddMonoidHom.mk' f map_mul)) f","decl":"/-- Makes a group homomorphism from a proof that the map preserves multiplication. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"Makes an additive group homomorphism from a proof that the map preserves addition.\"]\ndef mk' (f : M → G) (map_mul : ∀ a b : M, f (a * b) = f a * f b) : M →* G where\n  toFun := f\n  map_mul' := map_mul\n  map_one' := by rw [← mul_right_cancel_iff, ← map_mul _ 1, one_mul, one_mul]\n\n"}
{"name":"OneHom.mk_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nf : OneHom M N\nh1 : Eq (f 1) 1\n⊢ Eq { toFun := ⇑f, map_one' := h1 } f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.mk_coe [One M] [One N] (f : OneHom M N) (h1) : OneHom.mk f h1 = f :=\n  OneHom.ext fun _ => rfl\n\n"}
{"name":"ZeroHom.mk_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : ZeroHom M N\nh1 : Eq (f 0) 0\n⊢ Eq { toFun := ⇑f, map_zero' := h1 } f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.mk_coe [One M] [One N] (f : OneHom M N) (h1) : OneHom.mk f h1 = f :=\n  OneHom.ext fun _ => rfl\n\n"}
{"name":"AddHom.mk_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhmul : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\n⊢ Eq { toFun := ⇑f, map_add' := hmul } f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.mk_coe [Mul M] [Mul N] (f : M →ₙ* N) (hmul) : MulHom.mk f hmul = f :=\n  MulHom.ext fun _ => rfl\n\n"}
{"name":"MulHom.mk_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhmul : ∀ (x y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq { toFun := ⇑f, map_mul' := hmul } f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.mk_coe [Mul M] [Mul N] (f : M →ₙ* N) (hmul) : MulHom.mk f hmul = f :=\n  MulHom.ext fun _ => rfl\n\n"}
{"name":"MonoidHom.mk_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\nhmul : ∀ (x y : M), Eq ((↑f).toFun (HMul.hMul x y)) (HMul.hMul ((↑f).toFun x) ((↑f).toFun y))\n⊢ Eq { toOneHom := ↑f, map_mul' := hmul } f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.mk_coe [MulOneClass M] [MulOneClass N] (f : M →* N) (hmul) :\n    MonoidHom.mk f hmul = f := MonoidHom.ext fun _ => rfl\n\n"}
{"name":"AddMonoidHom.mk_coe","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\nhmul : ∀ (x y : M), Eq ((↑f).toFun (HAdd.hAdd x y)) (HAdd.hAdd ((↑f).toFun x) ((↑f).toFun y))\n⊢ Eq { toZeroHom := ↑f, map_add' := hmul } f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.mk_coe [MulOneClass M] [MulOneClass N] (f : M →* N) (hmul) :\n    MonoidHom.mk f hmul = f := MonoidHom.ext fun _ => rfl\n\n"}
{"name":"OneHom.coe_copy","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : One M\nx✝ : One N\nf : OneHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.coe_copy {_ : One M} {_ : One N} (f : OneHom M N) (f' : M → N) (h : f' = f) :\n    (f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"ZeroHom.coe_copy","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : Zero M\nx✝ : Zero N\nf : ZeroHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.coe_copy {_ : One M} {_ : One N} (f : OneHom M N) (f' : M → N) (h : f' = f) :\n    (f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"OneHom.coe_copy_eq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : One M\nx✝ : One N\nf : OneHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"@[to_additive]\ntheorem OneHom.coe_copy_eq {_ : One M} {_ : One N} (f : OneHom M N) (f' : M → N) (h : f' = f) :\n    f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"ZeroHom.coe_copy_eq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : Zero M\nx✝ : Zero N\nf : ZeroHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"@[to_additive]\ntheorem OneHom.coe_copy_eq {_ : One M} {_ : One N} (f : OneHom M N) (f' : M → N) (h : f' = f) :\n    f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"MulHom.coe_copy","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : Mul M\nx✝ : Mul N\nf : MulHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.coe_copy {_ : Mul M} {_ : Mul N} (f : M →ₙ* N) (f' : M → N) (h : f' = f) :\n    (f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"AddHom.coe_copy","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : Add M\nx✝ : Add N\nf : AddHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.coe_copy {_ : Mul M} {_ : Mul N} (f : M →ₙ* N) (f' : M → N) (h : f' = f) :\n    (f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"MulHom.coe_copy_eq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : Mul M\nx✝ : Mul N\nf : MulHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"@[to_additive]\ntheorem MulHom.coe_copy_eq {_ : Mul M} {_ : Mul N} (f : M →ₙ* N) (f' : M → N) (h : f' = f) :\n    f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"AddHom.coe_copy_eq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : Add M\nx✝ : Add N\nf : AddHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"@[to_additive]\ntheorem MulHom.coe_copy_eq {_ : Mul M} {_ : Mul N} (f : M →ₙ* N) (f' : M → N) (h : f' = f) :\n    f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"MonoidHom.coe_copy","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : MulOneClass M\nx✝ : MulOneClass N\nf : MonoidHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_copy {_ : MulOneClass M} {_ : MulOneClass N} (f : M →* N) (f' : M → N)\n    (h : f' = f) : (f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_copy","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : AddZeroClass M\nx✝ : AddZeroClass N\nf : AddMonoidHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_copy {_ : MulOneClass M} {_ : MulOneClass N} (f : M →* N) (f' : M → N)\n    (h : f' = f) : (f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"AddMonoidHom.copy_eq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : AddZeroClass M\nx✝ : AddZeroClass N\nf : AddMonoidHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"@[to_additive]\ntheorem MonoidHom.copy_eq {_ : MulOneClass M} {_ : MulOneClass N} (f : M →* N) (f' : M → N)\n    (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"MonoidHom.copy_eq","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nx✝¹ : MulOneClass M\nx✝ : MulOneClass N\nf : MonoidHom M N\nf' : M → N\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"@[to_additive]\ntheorem MonoidHom.copy_eq {_ : MulOneClass M} {_ : MulOneClass N} (f : M →* N) (f' : M → N)\n    (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"OneHom.map_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nf : OneHom M N\n⊢ Eq (f 1) 1","decl":"@[to_additive]\nprotected theorem OneHom.map_one [One M] [One N] (f : OneHom M N) : f 1 = 1 :=\n  f.map_one'\n\n"}
{"name":"ZeroHom.map_zero","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : ZeroHom M N\n⊢ Eq (f 0) 0","decl":"@[to_additive]\nprotected theorem OneHom.map_one [One M] [One N] (f : OneHom M N) : f 1 = 1 :=\n  f.map_one'\n\n"}
{"name":"MonoidHom.map_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\n⊢ Eq (f 1) 1","decl":"/-- If `f` is a monoid homomorphism then `f 1 = 1`. -/\n@[to_additive \"If `f` is an additive monoid homomorphism then `f 0 = 0`.\"]\nprotected theorem MonoidHom.map_one [MulOneClass M] [MulOneClass N] (f : M →* N) : f 1 = 1 :=\n  f.map_one'\n\n"}
{"name":"AddMonoidHom.map_zero","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq (f 0) 0","decl":"/-- If `f` is a monoid homomorphism then `f 1 = 1`. -/\n@[to_additive \"If `f` is an additive monoid homomorphism then `f 0 = 0`.\"]\nprotected theorem MonoidHom.map_one [MulOneClass M] [MulOneClass N] (f : M →* N) : f 1 = 1 :=\n  f.map_one'\n\n"}
{"name":"AddHom.map_add","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\na b : M\n⊢ Eq (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))","decl":"@[to_additive]\nprotected theorem MulHom.map_mul [Mul M] [Mul N] (f : M →ₙ* N) (a b : M) : f (a * b) = f a * f b :=\n  f.map_mul' a b\n\n"}
{"name":"MulHom.map_mul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\na b : M\n⊢ Eq (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))","decl":"@[to_additive]\nprotected theorem MulHom.map_mul [Mul M] [Mul N] (f : M →ₙ* N) (a b : M) : f (a * b) = f a * f b :=\n  f.map_mul' a b\n\n"}
{"name":"MonoidHom.map_mul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\na b : M\n⊢ Eq (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))","decl":"/-- If `f` is a monoid homomorphism then `f (a * b) = f a * f b`. -/\n@[to_additive \"If `f` is an additive monoid homomorphism then `f (a + b) = f a + f b`.\"]\nprotected theorem MonoidHom.map_mul [MulOneClass M] [MulOneClass N] (f : M →* N) (a b : M) :\n    f (a * b) = f a * f b := f.map_mul' a b\n\n"}
{"name":"AddMonoidHom.map_add","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\na b : M\n⊢ Eq (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))","decl":"/-- If `f` is a monoid homomorphism then `f (a * b) = f a * f b`. -/\n@[to_additive \"If `f` is an additive monoid homomorphism then `f (a + b) = f a + f b`.\"]\nprotected theorem MonoidHom.map_mul [MulOneClass M] [MulOneClass N] (f : M →* N) (a b : M) :\n    f (a * b) = f a * f b := f.map_mul' a b\n\n"}
{"name":"AddMonoidHom.map_exists_right_neg","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : FunLike F M N\ninst✝ : AddMonoidHomClass F M N\nf : F\nx : M\nhx : Exists fun y => Eq (HAdd.hAdd x y) 0\n⊢ Exists fun y => Eq (HAdd.hAdd (f x) y) 0","decl":"/-- Given a monoid homomorphism `f : M →* N` and an element `x : M`, if `x` has a right inverse,\nthen `f x` has a right inverse too. For elements invertible on both sides see `IsUnit.map`. -/\n@[to_additive\n  \"Given an AddMonoid homomorphism `f : M →+ N` and an element `x : M`, if `x` has\n  a right inverse, then `f x` has a right inverse too.\"]\ntheorem map_exists_right_inv (f : F) {x : M} (hx : ∃ y, x * y = 1) : ∃ y, f x * y = 1 :=\n  let ⟨y, hy⟩ := hx\n  ⟨f y, map_mul_eq_one f hy⟩\n\n"}
{"name":"MonoidHom.map_exists_right_inv","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nf : F\nx : M\nhx : Exists fun y => Eq (HMul.hMul x y) 1\n⊢ Exists fun y => Eq (HMul.hMul (f x) y) 1","decl":"/-- Given a monoid homomorphism `f : M →* N` and an element `x : M`, if `x` has a right inverse,\nthen `f x` has a right inverse too. For elements invertible on both sides see `IsUnit.map`. -/\n@[to_additive\n  \"Given an AddMonoid homomorphism `f : M →+ N` and an element `x : M`, if `x` has\n  a right inverse, then `f x` has a right inverse too.\"]\ntheorem map_exists_right_inv (f : F) {x : M} (hx : ∃ y, x * y = 1) : ∃ y, f x * y = 1 :=\n  let ⟨y, hy⟩ := hx\n  ⟨f y, map_mul_eq_one f hy⟩\n\n"}
{"name":"AddMonoidHom.map_exists_left_neg","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : FunLike F M N\ninst✝ : AddMonoidHomClass F M N\nf : F\nx : M\nhx : Exists fun y => Eq (HAdd.hAdd y x) 0\n⊢ Exists fun y => Eq (HAdd.hAdd y (f x)) 0","decl":"/-- Given a monoid homomorphism `f : M →* N` and an element `x : M`, if `x` has a left inverse,\nthen `f x` has a left inverse too. For elements invertible on both sides see `IsUnit.map`. -/\n@[to_additive\n  \"Given an AddMonoid homomorphism `f : M →+ N` and an element `x : M`, if `x` has\n  a left inverse, then `f x` has a left inverse too. For elements invertible on both sides see\n  `IsAddUnit.map`.\"]\ntheorem map_exists_left_inv (f : F) {x : M} (hx : ∃ y, y * x = 1) : ∃ y, y * f x = 1 :=\n  let ⟨y, hy⟩ := hx\n  ⟨f y, map_mul_eq_one f hy⟩\n\n"}
{"name":"MonoidHom.map_exists_left_inv","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nF : Type u_9\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nf : F\nx : M\nhx : Exists fun y => Eq (HMul.hMul y x) 1\n⊢ Exists fun y => Eq (HMul.hMul y (f x)) 1","decl":"/-- Given a monoid homomorphism `f : M →* N` and an element `x : M`, if `x` has a left inverse,\nthen `f x` has a left inverse too. For elements invertible on both sides see `IsUnit.map`. -/\n@[to_additive\n  \"Given an AddMonoid homomorphism `f : M →+ N` and an element `x : M`, if `x` has\n  a left inverse, then `f x` has a left inverse too. For elements invertible on both sides see\n  `IsAddUnit.map`.\"]\ntheorem map_exists_left_inv (f : F) {x : M} (hx : ∃ y, y * x = 1) : ∃ y, y * f x = 1 :=\n  let ⟨y, hy⟩ := hx\n  ⟨f y, map_mul_eq_one f hy⟩\n\n"}
{"name":"OneHom.id_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : One M\nx : M\n⊢ Eq ((OneHom.id M) x) x","decl":"/-- The identity map from a type with 1 to itself. -/\n@[to_additive (attr := simps) \"The identity map from a type with zero to itself.\"]\ndef OneHom.id (M : Type*) [One M] : OneHom M M where\n  toFun x := x\n  map_one' := rfl\n\n"}
{"name":"ZeroHom.id_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : Zero M\nx : M\n⊢ Eq ((ZeroHom.id M) x) x","decl":"/-- The identity map from a type with 1 to itself. -/\n@[to_additive (attr := simps) \"The identity map from a type with zero to itself.\"]\ndef OneHom.id (M : Type*) [One M] : OneHom M M where\n  toFun x := x\n  map_one' := rfl\n\n"}
{"name":"MulHom.id_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : Mul M\nx : M\n⊢ Eq ((MulHom.id M) x) x","decl":"/-- The identity map from a type with multiplication to itself. -/\n@[to_additive (attr := simps) \"The identity map from a type with addition to itself.\"]\ndef MulHom.id (M : Type*) [Mul M] : M →ₙ* M where\n  toFun x := x\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddHom.id_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : Add M\nx : M\n⊢ Eq ((AddHom.id M) x) x","decl":"/-- The identity map from a type with multiplication to itself. -/\n@[to_additive (attr := simps) \"The identity map from a type with addition to itself.\"]\ndef MulHom.id (M : Type*) [Mul M] : M →ₙ* M where\n  toFun x := x\n  map_mul' _ _ := rfl\n\n"}
{"name":"MonoidHom.id_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : MulOneClass M\nx : M\n⊢ Eq ((MonoidHom.id M) x) x","decl":"/-- The identity map from a monoid to itself. -/\n@[to_additive (attr := simps) \"The identity map from an additive monoid to itself.\"]\ndef MonoidHom.id (M : Type*) [MulOneClass M] : M →* M where\n  toFun x := x\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddMonoidHom.id_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : AddZeroClass M\nx : M\n⊢ Eq ((AddMonoidHom.id M) x) x","decl":"/-- The identity map from a monoid to itself. -/\n@[to_additive (attr := simps) \"The identity map from an additive monoid to itself.\"]\ndef MonoidHom.id (M : Type*) [MulOneClass M] : M →* M where\n  toFun x := x\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"ZeroHom.coe_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : Zero M\n⊢ Eq (⇑(ZeroHom.id M)) id","decl":"@[to_additive (attr := simp)]\nlemma OneHom.coe_id {M : Type*} [One M] : (OneHom.id M : M → M) = _root_.id := rfl\n\n"}
{"name":"OneHom.coe_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : One M\n⊢ Eq (⇑(OneHom.id M)) id","decl":"@[to_additive (attr := simp)]\nlemma OneHom.coe_id {M : Type*} [One M] : (OneHom.id M : M → M) = _root_.id := rfl\n\n"}
{"name":"MulHom.coe_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : Mul M\n⊢ Eq (⇑(MulHom.id M)) id","decl":"@[to_additive (attr := simp)]\nlemma MulHom.coe_id {M : Type*} [Mul M] : (MulHom.id M : M → M) = _root_.id := rfl\n\n"}
{"name":"AddHom.coe_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : Add M\n⊢ Eq (⇑(AddHom.id M)) id","decl":"@[to_additive (attr := simp)]\nlemma MulHom.coe_id {M : Type*} [Mul M] : (MulHom.id M : M → M) = _root_.id := rfl\n\n"}
{"name":"AddMonoidHom.coe_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : AddZeroClass M\n⊢ Eq (⇑(AddMonoidHom.id M)) id","decl":"@[to_additive (attr := simp)]\nlemma MonoidHom.coe_id {M : Type*} [MulOneClass M] : (MonoidHom.id M : M → M) = _root_.id := rfl\n\n"}
{"name":"MonoidHom.coe_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_10\ninst✝ : MulOneClass M\n⊢ Eq (⇑(MonoidHom.id M)) id","decl":"@[to_additive (attr := simp)]\nlemma MonoidHom.coe_id {M : Type*} [MulOneClass M] : (MonoidHom.id M : M → M) = _root_.id := rfl\n\n"}
{"name":"OneHom.coe_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : One P\ng : OneHom N P\nf : OneHom M N\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.coe_comp [One M] [One N] [One P] (g : OneHom N P) (f : OneHom M N) :\n    ↑(g.comp f) = g ∘ f := rfl\n\n"}
{"name":"ZeroHom.coe_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\ng : ZeroHom N P\nf : ZeroHom M N\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.coe_comp [One M] [One N] [One P] (g : OneHom N P) (f : OneHom M N) :\n    ↑(g.comp f) = g ∘ f := rfl\n\n"}
{"name":"MulHom.coe_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\ng : MulHom N P\nf : MulHom M N\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.coe_comp [Mul M] [Mul N] [Mul P] (g : N →ₙ* P) (f : M →ₙ* N) :\n    ↑(g.comp f) = g ∘ f := rfl\n\n"}
{"name":"AddHom.coe_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\ng : AddHom N P\nf : AddHom M N\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.coe_comp [Mul M] [Mul N] [Mul P] (g : N →ₙ* P) (f : M →ₙ* N) :\n    ↑(g.comp f) = g ∘ f := rfl\n\n"}
{"name":"MonoidHom.coe_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\ng : MonoidHom N P\nf : MonoidHom M N\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_comp [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    (g : N →* P) (f : M →* N) : ↑(g.comp f) = g ∘ f := rfl\n\n"}
{"name":"AddMonoidHom.coe_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\ng : AddMonoidHom N P\nf : AddMonoidHom M N\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_comp [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    (g : N →* P) (f : M →* N) : ↑(g.comp f) = g ∘ f := rfl\n\n"}
{"name":"OneHom.comp_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : One P\ng : OneHom N P\nf : OneHom M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[to_additive]\ntheorem OneHom.comp_apply [One M] [One N] [One P] (g : OneHom N P) (f : OneHom M N) (x : M) :\n    g.comp f x = g (f x) := rfl\n\n"}
{"name":"ZeroHom.comp_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\ng : ZeroHom N P\nf : ZeroHom M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[to_additive]\ntheorem OneHom.comp_apply [One M] [One N] [One P] (g : OneHom N P) (f : OneHom M N) (x : M) :\n    g.comp f x = g (f x) := rfl\n\n"}
{"name":"MulHom.comp_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\ng : MulHom N P\nf : MulHom M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[to_additive]\ntheorem MulHom.comp_apply [Mul M] [Mul N] [Mul P] (g : N →ₙ* P) (f : M →ₙ* N) (x : M) :\n    g.comp f x = g (f x) := rfl\n\n"}
{"name":"AddHom.comp_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\ng : AddHom N P\nf : AddHom M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[to_additive]\ntheorem MulHom.comp_apply [Mul M] [Mul N] [Mul P] (g : N →ₙ* P) (f : M →ₙ* N) (x : M) :\n    g.comp f x = g (f x) := rfl\n\n"}
{"name":"MonoidHom.comp_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\ng : MonoidHom N P\nf : MonoidHom M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[to_additive]\ntheorem MonoidHom.comp_apply [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    (g : N →* P) (f : M →* N) (x : M) : g.comp f x = g (f x) := rfl\n\n"}
{"name":"AddMonoidHom.comp_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\ng : AddMonoidHom N P\nf : AddMonoidHom M N\nx : M\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[to_additive]\ntheorem MonoidHom.comp_apply [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    (g : N →* P) (f : M →* N) (x : M) : g.comp f x = g (f x) := rfl\n\n"}
{"name":"ZeroHom.comp_assoc","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_10\ninst✝³ : Zero M\ninst✝² : Zero N\ninst✝¹ : Zero P\ninst✝ : Zero Q\nf : ZeroHom M N\ng : ZeroHom N P\nh : ZeroHom P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"/-- Composition of monoid homomorphisms is associative. -/\n@[to_additive \"Composition of additive monoid homomorphisms is associative.\"]\ntheorem OneHom.comp_assoc {Q : Type*} [One M] [One N] [One P] [One Q]\n    (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q) :\n    (h.comp g).comp f = h.comp (g.comp f) := rfl\n\n"}
{"name":"OneHom.comp_assoc","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_10\ninst✝³ : One M\ninst✝² : One N\ninst✝¹ : One P\ninst✝ : One Q\nf : OneHom M N\ng : OneHom N P\nh : OneHom P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"/-- Composition of monoid homomorphisms is associative. -/\n@[to_additive \"Composition of additive monoid homomorphisms is associative.\"]\ntheorem OneHom.comp_assoc {Q : Type*} [One M] [One N] [One P] [One Q]\n    (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q) :\n    (h.comp g).comp f = h.comp (g.comp f) := rfl\n\n"}
{"name":"AddHom.comp_assoc","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_10\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : Add P\ninst✝ : Add Q\nf : AddHom M N\ng : AddHom N P\nh : AddHom P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"@[to_additive]\ntheorem MulHom.comp_assoc {Q : Type*} [Mul M] [Mul N] [Mul P] [Mul Q]\n    (f : M →ₙ* N) (g : N →ₙ* P) (h : P →ₙ* Q) : (h.comp g).comp f = h.comp (g.comp f) := rfl\n\n"}
{"name":"MulHom.comp_assoc","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_10\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : Mul P\ninst✝ : Mul Q\nf : MulHom M N\ng : MulHom N P\nh : MulHom P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"@[to_additive]\ntheorem MulHom.comp_assoc {Q : Type*} [Mul M] [Mul N] [Mul P] [Mul Q]\n    (f : M →ₙ* N) (g : N →ₙ* P) (h : P →ₙ* Q) : (h.comp g).comp f = h.comp (g.comp f) := rfl\n\n"}
{"name":"AddMonoidHom.comp_assoc","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_10\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass P\ninst✝ : AddZeroClass Q\nf : AddMonoidHom M N\ng : AddMonoidHom N P\nh : AddMonoidHom P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"@[to_additive]\ntheorem MonoidHom.comp_assoc {Q : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    [MulOneClass Q] (f : M →* N) (g : N →* P) (h : P →* Q) :\n    (h.comp g).comp f = h.comp (g.comp f) := rfl\n\n"}
{"name":"MonoidHom.comp_assoc","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_10\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass P\ninst✝ : MulOneClass Q\nf : MonoidHom M N\ng : MonoidHom N P\nh : MonoidHom P Q\n⊢ Eq ((h.comp g).comp f) (h.comp (g.comp f))","decl":"@[to_additive]\ntheorem MonoidHom.comp_assoc {Q : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    [MulOneClass Q] (f : M →* N) (g : N →* P) (h : P →* Q) :\n    (h.comp g).comp f = h.comp (g.comp f) := rfl\n\n"}
{"name":"ZeroHom.cancel_right","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\ng₁ g₂ : ZeroHom N P\nf : ZeroHom M N\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[to_additive]\ntheorem OneHom.cancel_right [One M] [One N] [One P] {g₁ g₂ : OneHom N P} {f : OneHom M N}\n    (hf : Function.Surjective f) : g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => OneHom.ext <| hf.forall.2 (DFunLike.ext_iff.1 h), fun h => h ▸ rfl⟩\n\n"}
{"name":"OneHom.cancel_right","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : One P\ng₁ g₂ : OneHom N P\nf : OneHom M N\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[to_additive]\ntheorem OneHom.cancel_right [One M] [One N] [One P] {g₁ g₂ : OneHom N P} {f : OneHom M N}\n    (hf : Function.Surjective f) : g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => OneHom.ext <| hf.forall.2 (DFunLike.ext_iff.1 h), fun h => h ▸ rfl⟩\n\n"}
{"name":"AddHom.cancel_right","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\ng₁ g₂ : AddHom N P\nf : AddHom M N\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[to_additive]\ntheorem MulHom.cancel_right [Mul M] [Mul N] [Mul P] {g₁ g₂ : N →ₙ* P} {f : M →ₙ* N}\n    (hf : Function.Surjective f) : g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => MulHom.ext <| hf.forall.2 (DFunLike.ext_iff.1 h), fun h => h ▸ rfl⟩\n\n"}
{"name":"MulHom.cancel_right","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\ng₁ g₂ : MulHom N P\nf : MulHom M N\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[to_additive]\ntheorem MulHom.cancel_right [Mul M] [Mul N] [Mul P] {g₁ g₂ : N →ₙ* P} {f : M →ₙ* N}\n    (hf : Function.Surjective f) : g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => MulHom.ext <| hf.forall.2 (DFunLike.ext_iff.1 h), fun h => h ▸ rfl⟩\n\n"}
{"name":"MonoidHom.cancel_right","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\ng₁ g₂ : MonoidHom N P\nf : MonoidHom M N\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[to_additive]\ntheorem MonoidHom.cancel_right [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    {g₁ g₂ : N →* P} {f : M →* N} (hf : Function.Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => MonoidHom.ext <| hf.forall.2 (DFunLike.ext_iff.1 h), fun h => h ▸ rfl⟩\n\n"}
{"name":"AddMonoidHom.cancel_right","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\ng₁ g₂ : AddMonoidHom N P\nf : AddMonoidHom M N\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[to_additive]\ntheorem MonoidHom.cancel_right [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    {g₁ g₂ : N →* P} {f : M →* N} (hf : Function.Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => MonoidHom.ext <| hf.forall.2 (DFunLike.ext_iff.1 h), fun h => h ▸ rfl⟩\n\n"}
{"name":"OneHom.cancel_left","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : One P\ng : OneHom N P\nf₁ f₂ : OneHom M N\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[to_additive]\ntheorem OneHom.cancel_left [One M] [One N] [One P] {g : OneHom N P} {f₁ f₂ : OneHom M N}\n    (hg : Function.Injective g) : g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => OneHom.ext fun x => hg <| by rw [← OneHom.comp_apply, h, OneHom.comp_apply],\n    fun h => h ▸ rfl⟩\n\n"}
{"name":"ZeroHom.cancel_left","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\ng : ZeroHom N P\nf₁ f₂ : ZeroHom M N\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[to_additive]\ntheorem OneHom.cancel_left [One M] [One N] [One P] {g : OneHom N P} {f₁ f₂ : OneHom M N}\n    (hg : Function.Injective g) : g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => OneHom.ext fun x => hg <| by rw [← OneHom.comp_apply, h, OneHom.comp_apply],\n    fun h => h ▸ rfl⟩\n\n"}
{"name":"MulHom.cancel_left","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Mul P\ng : MulHom N P\nf₁ f₂ : MulHom M N\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[to_additive]\ntheorem MulHom.cancel_left [Mul M] [Mul N] [Mul P] {g : N →ₙ* P} {f₁ f₂ : M →ₙ* N}\n    (hg : Function.Injective g) : g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => MulHom.ext fun x => hg <| by rw [← MulHom.comp_apply, h, MulHom.comp_apply],\n    fun h => h ▸ rfl⟩\n\n"}
{"name":"AddHom.cancel_left","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : Add P\ng : AddHom N P\nf₁ f₂ : AddHom M N\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[to_additive]\ntheorem MulHom.cancel_left [Mul M] [Mul N] [Mul P] {g : N →ₙ* P} {f₁ f₂ : M →ₙ* N}\n    (hg : Function.Injective g) : g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => MulHom.ext fun x => hg <| by rw [← MulHom.comp_apply, h, MulHom.comp_apply],\n    fun h => h ▸ rfl⟩\n\n"}
{"name":"MonoidHom.cancel_left","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\ng : MonoidHom N P\nf₁ f₂ : MonoidHom M N\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[to_additive]\ntheorem MonoidHom.cancel_left [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    {g : N →* P} {f₁ f₂ : M →* N} (hg : Function.Injective g) : g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => MonoidHom.ext fun x => hg <| by rw [← MonoidHom.comp_apply, h, MonoidHom.comp_apply],\n    fun h => h ▸ rfl⟩\n\n"}
{"name":"AddMonoidHom.cancel_left","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\ng : AddMonoidHom N P\nf₁ f₂ : AddMonoidHom M N\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[to_additive]\ntheorem MonoidHom.cancel_left [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    {g : N →* P} {f₁ f₂ : M →* N} (hg : Function.Injective g) : g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => MonoidHom.ext fun x => hg <| by rw [← MonoidHom.comp_apply, h, MonoidHom.comp_apply],\n    fun h => h ▸ rfl⟩\n\n"}
{"name":"AddMonoidHom.toZeroHom_injective","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Function.Injective AddMonoidHom.toZeroHom","decl":"@[to_additive]\ntheorem MonoidHom.toOneHom_injective [MulOneClass M] [MulOneClass N] :\n    Function.Injective (MonoidHom.toOneHom : (M →* N) → OneHom M N) :=\n  Function.Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective\n\n"}
{"name":"MonoidHom.toOneHom_injective","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Function.Injective MonoidHom.toOneHom","decl":"@[to_additive]\ntheorem MonoidHom.toOneHom_injective [MulOneClass M] [MulOneClass N] :\n    Function.Injective (MonoidHom.toOneHom : (M →* N) → OneHom M N) :=\n  Function.Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective\n\n"}
{"name":"MonoidHom.toMulHom_injective","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Function.Injective MonoidHom.toMulHom","decl":"@[to_additive]\ntheorem MonoidHom.toMulHom_injective [MulOneClass M] [MulOneClass N] :\n    Function.Injective (MonoidHom.toMulHom : (M →* N) → M →ₙ* N) :=\n  Function.Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective\n\n"}
{"name":"AddMonoidHom.toAddHom_injective","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Function.Injective AddMonoidHom.toAddHom","decl":"@[to_additive]\ntheorem MonoidHom.toMulHom_injective [MulOneClass M] [MulOneClass N] :\n    Function.Injective (MonoidHom.toMulHom : (M →* N) → M →ₙ* N) :=\n  Function.Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective\n\n"}
{"name":"OneHom.comp_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nf : OneHom M N\n⊢ Eq (f.comp (OneHom.id M)) f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.comp_id [One M] [One N] (f : OneHom M N) : f.comp (OneHom.id M) = f :=\n  OneHom.ext fun _ => rfl\n\n"}
{"name":"ZeroHom.comp_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : ZeroHom M N\n⊢ Eq (f.comp (ZeroHom.id M)) f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.comp_id [One M] [One N] (f : OneHom M N) : f.comp (OneHom.id M) = f :=\n  OneHom.ext fun _ => rfl\n\n"}
{"name":"MulHom.comp_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Eq (f.comp (MulHom.id M)) f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.comp_id [Mul M] [Mul N] (f : M →ₙ* N) : f.comp (MulHom.id M) = f :=\n  MulHom.ext fun _ => rfl\n\n"}
{"name":"AddHom.comp_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Eq (f.comp (AddHom.id M)) f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.comp_id [Mul M] [Mul N] (f : M →ₙ* N) : f.comp (MulHom.id M) = f :=\n  MulHom.ext fun _ => rfl\n\n"}
{"name":"AddMonoidHom.comp_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq (f.comp (AddMonoidHom.id M)) f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.comp_id [MulOneClass M] [MulOneClass N] (f : M →* N) :\n    f.comp (MonoidHom.id M) = f := MonoidHom.ext fun _ => rfl\n\n"}
{"name":"MonoidHom.comp_id","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\n⊢ Eq (f.comp (MonoidHom.id M)) f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.comp_id [MulOneClass M] [MulOneClass N] (f : M →* N) :\n    f.comp (MonoidHom.id M) = f := MonoidHom.ext fun _ => rfl\n\n"}
{"name":"OneHom.id_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nf : OneHom M N\n⊢ Eq ((OneHom.id N).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.id_comp [One M] [One N] (f : OneHom M N) : (OneHom.id N).comp f = f :=\n  OneHom.ext fun _ => rfl\n\n"}
{"name":"ZeroHom.id_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : ZeroHom M N\n⊢ Eq ((ZeroHom.id N).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.id_comp [One M] [One N] (f : OneHom M N) : (OneHom.id N).comp f = f :=\n  OneHom.ext fun _ => rfl\n\n"}
{"name":"MulHom.id_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\n⊢ Eq ((MulHom.id N).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.id_comp [Mul M] [Mul N] (f : M →ₙ* N) : (MulHom.id N).comp f = f :=\n  MulHom.ext fun _ => rfl\n\n"}
{"name":"AddHom.id_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\n⊢ Eq ((AddHom.id N).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem MulHom.id_comp [Mul M] [Mul N] (f : M →ₙ* N) : (MulHom.id N).comp f = f :=\n  MulHom.ext fun _ => rfl\n\n"}
{"name":"MonoidHom.id_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\n⊢ Eq ((MonoidHom.id N).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.id_comp [MulOneClass M] [MulOneClass N] (f : M →* N) :\n    (MonoidHom.id N).comp f = f := MonoidHom.ext fun _ => rfl\n\n"}
{"name":"AddMonoidHom.id_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq ((AddMonoidHom.id N).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.id_comp [MulOneClass M] [MulOneClass N] (f : M →* N) :\n    (MonoidHom.id N).comp f = f := MonoidHom.ext fun _ => rfl\n\n"}
{"name":"MonoidHom.map_pow","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\na : M\nn : Nat\n⊢ Eq (f (HPow.hPow a n)) (HPow.hPow (f a) n)","decl":"@[to_additive]\nprotected theorem MonoidHom.map_pow [Monoid M] [Monoid N] (f : M →* N) (a : M) (n : ℕ) :\n    f (a ^ n) = f a ^ n := map_pow f a n\n\n"}
{"name":"AddMonoidHom.map_nsmul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\na : M\nn : Nat\n⊢ Eq (f (HSMul.hSMul n a)) (HSMul.hSMul n (f a))","decl":"@[to_additive]\nprotected theorem MonoidHom.map_pow [Monoid M] [Monoid N] (f : M →* N) (a : M) (n : ℕ) :\n    f (a ^ n) = f a ^ n := map_pow f a n\n\n"}
{"name":"AddMonoidHom.map_zsmul'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : SubNegMonoid M\ninst✝ : SubNegMonoid N\nf : AddMonoidHom M N\nhf : ∀ (x : M), Eq (f (Neg.neg x)) (Neg.neg (f x))\na : M\nn : Int\n⊢ Eq (f (HSMul.hSMul n a)) (HSMul.hSMul n (f a))","decl":"@[to_additive]\nprotected theorem MonoidHom.map_zpow' [DivInvMonoid M] [DivInvMonoid N] (f : M →* N)\n    (hf : ∀ x, f x⁻¹ = (f x)⁻¹) (a : M) (n : ℤ) :\n    f (a ^ n) = f a ^ n := map_zpow' f hf a n\n\n"}
{"name":"MonoidHom.map_zpow'","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : DivInvMonoid M\ninst✝ : DivInvMonoid N\nf : MonoidHom M N\nhf : ∀ (x : M), Eq (f (Inv.inv x)) (Inv.inv (f x))\na : M\nn : Int\n⊢ Eq (f (HPow.hPow a n)) (HPow.hPow (f a) n)","decl":"@[to_additive]\nprotected theorem MonoidHom.map_zpow' [DivInvMonoid M] [DivInvMonoid N] (f : M →* N)\n    (hf : ∀ x, f x⁻¹ = (f x)⁻¹) (a : M) (n : ℤ) :\n    f (a ^ n) = f a ^ n := map_zpow' f hf a n\n\n"}
{"name":"OneHom.inverse_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nf : OneHom M N\ng : N → M\nh₁ : Function.LeftInverse g ⇑f\na✝ : N\n⊢ Eq ((f.inverse g h₁) a✝) (g a✝)","decl":"/-- Makes a `OneHom` inverse from the bijective inverse of a `OneHom` -/\n@[to_additive (attr := simps)\n  \"Make a `ZeroHom` inverse from the bijective inverse of a `ZeroHom`\"]\ndef OneHom.inverse [One M] [One N]\n    (f : OneHom M N) (g : N → M)\n    (h₁ : Function.LeftInverse g f) :\n  OneHom N M :=\n  { toFun := g,\n    map_one' := by rw [← f.map_one, h₁] }\n\n"}
{"name":"ZeroHom.inverse_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : ZeroHom M N\ng : N → M\nh₁ : Function.LeftInverse g ⇑f\na✝ : N\n⊢ Eq ((f.inverse g h₁) a✝) (g a✝)","decl":"/-- Makes a `OneHom` inverse from the bijective inverse of a `OneHom` -/\n@[to_additive (attr := simps)\n  \"Make a `ZeroHom` inverse from the bijective inverse of a `ZeroHom`\"]\ndef OneHom.inverse [One M] [One N]\n    (f : OneHom M N) (g : N → M)\n    (h₁ : Function.LeftInverse g f) :\n  OneHom N M :=\n  { toFun := g,\n    map_one' := by rw [← f.map_one, h₁] }\n\n"}
{"name":"AddHom.inverse_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\ng : N → M\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : N\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- Makes a multiplicative inverse from a bijection which preserves multiplication. -/\n@[to_additive (attr := simps)\n  \"Makes an additive inverse from a bijection which preserves addition.\"]\ndef MulHom.inverse [Mul M] [Mul N] (f : M →ₙ* N) (g : N → M)\n    (h₁ : Function.LeftInverse g f)\n    (h₂ : Function.RightInverse g f) : N →ₙ* M where\n  toFun := g\n  map_mul' x y :=\n    calc\n      g (x * y) = g (f (g x) * f (g y)) := by rw [h₂ x, h₂ y]\n      _ = g (f (g x * g y)) := by rw [f.map_mul]\n      _ = g x * g y := h₁ _\n\n"}
{"name":"MulHom.inverse_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\ng : N → M\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : N\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- Makes a multiplicative inverse from a bijection which preserves multiplication. -/\n@[to_additive (attr := simps)\n  \"Makes an additive inverse from a bijection which preserves addition.\"]\ndef MulHom.inverse [Mul M] [Mul N] (f : M →ₙ* N) (g : N → M)\n    (h₁ : Function.LeftInverse g f)\n    (h₂ : Function.RightInverse g f) : N →ₙ* M where\n  toFun := g\n  map_mul' x y :=\n    calc\n      g (x * y) = g (f (g x) * f (g y)) := by rw [h₂ x, h₂ y]\n      _ = g (f (g x * g y)) := by rw [f.map_mul]\n      _ = g x * g y := h₁ _\n\n"}
{"name":"MonoidHom.inverse_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"A : Type u_10\nB : Type u_11\ninst✝¹ : Monoid A\ninst✝ : Monoid B\nf : MonoidHom A B\ng : B → A\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : B\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- The inverse of a bijective `MonoidHom` is a `MonoidHom`. -/\n@[to_additive (attr := simps)\n  \"The inverse of a bijective `AddMonoidHom` is an `AddMonoidHom`.\"]\ndef MonoidHom.inverse {A B : Type*} [Monoid A] [Monoid B] (f : A →* B) (g : B → A)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) : B →* A :=\n  { (f : OneHom A B).inverse g h₁,\n    (f : A →ₙ* B).inverse g h₁ h₂ with toFun := g }\n\n"}
{"name":"AddMonoidHom.inverse_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"A : Type u_10\nB : Type u_11\ninst✝¹ : AddMonoid A\ninst✝ : AddMonoid B\nf : AddMonoidHom A B\ng : B → A\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : B\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- The inverse of a bijective `MonoidHom` is a `MonoidHom`. -/\n@[to_additive (attr := simps)\n  \"The inverse of a bijective `AddMonoidHom` is an `AddMonoidHom`.\"]\ndef MonoidHom.inverse {A B : Type*} [Monoid A] [Monoid B] (f : A →* B) (g : B → A)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) : B →* A :=\n  { (f : OneHom A B).inverse g h₁,\n    (f : A →ₙ* B).inverse g h₁ h₂ with toFun := g }\n\n"}
{"name":"Monoid.End.instMonoidHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\n⊢ MonoidHomClass (Monoid.End M) M M","decl":"@[to_additive]\ninstance instMonoidHomClass : MonoidHomClass (Monoid.End M) M M := MonoidHom.instMonoidHomClass\n\n"}
{"name":"AddMonoid.End.instAddMonoidHomClass","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\n⊢ AddMonoidHomClass (AddMonoid.End M) M M","decl":"@[to_additive]\ninstance instMonoidHomClass : MonoidHomClass (Monoid.End M) M M := MonoidHom.instMonoidHomClass\n\n"}
{"name":"Monoid.End.coe_pow","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nf : Monoid.End M\nn : Nat\n⊢ Eq (⇑(HPow.hPow f n)) (Nat.iterate (⇑f) n)","decl":"@[to_additive (attr := simp, norm_cast) coe_pow]\nlemma coe_pow (f : Monoid.End M) (n : ℕ) : (↑(f ^ n) : M → M) = f^[n] := rfl\n\n"}
{"name":"AddMonoid.End.coe_pow","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nf : AddMonoid.End M\nn : Nat\n⊢ Eq (⇑(HPow.hPow f n)) (Nat.iterate (⇑f) n)","decl":"@[to_additive (attr := simp, norm_cast) coe_pow]\nlemma coe_pow (f : Monoid.End M) (n : ℕ) : (↑(f ^ n) : M → M) = f^[n] := rfl\n\n"}
{"name":"Monoid.End.coe_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\n⊢ Eq (⇑1) id","decl":"@[to_additive (attr := simp) coe_one]\ntheorem coe_one : ((1 : Monoid.End M) : M → M) = id := rfl\n\n"}
{"name":"AddMonoid.End.coe_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\n⊢ Eq (⇑1) id","decl":"@[to_additive (attr := simp) coe_one]\ntheorem coe_one : ((1 : Monoid.End M) : M → M) = id := rfl\n\n"}
{"name":"AddMonoid.End.coe_mul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\nf g : AddMonoid.End M\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"@[to_additive (attr := simp) coe_mul]\ntheorem coe_mul (f g) : ((f * g : Monoid.End M) : M → M) = f ∘ g := rfl\n\n"}
{"name":"Monoid.End.coe_mul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nf g : Monoid.End M\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"@[to_additive (attr := simp) coe_mul]\ntheorem coe_mul (f g) : ((f * g : Monoid.End M) : M → M) = f ∘ g := rfl\n\n"}
{"name":"Monoid.coe_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\n⊢ Eq (⇑1) id","decl":"@[deprecated (since := \"2024-11-20\")] protected alias coe_one := End.coe_one\n"}
{"name":"Monoid.coe_mul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\nf g : Monoid.End M\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"@[deprecated (since := \"2024-11-20\")] protected alias coe_mul := End.coe_mul\n\n"}
{"name":"ZeroHom.zero_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Zero M\ninst✝ : Zero N\nx : M\n⊢ Eq (0 x) 0","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.one_apply [One M] [One N] (x : M) : (1 : OneHom M N) x = 1 := rfl\n\n"}
{"name":"OneHom.one_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : One M\ninst✝ : One N\nx : M\n⊢ Eq (1 x) 1","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.one_apply [One M] [One N] (x : M) : (1 : OneHom M N) x = 1 := rfl\n\n"}
{"name":"MonoidHom.one_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nx : M\n⊢ Eq (1 x) 1","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.one_apply [MulOneClass M] [MulOneClass N] (x : M) : (1 : M →* N) x = 1 := rfl\n\n"}
{"name":"AddMonoidHom.zero_apply","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nx : M\n⊢ Eq (0 x) 0","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.one_apply [MulOneClass M] [MulOneClass N] (x : M) : (1 : M →* N) x = 1 := rfl\n\n"}
{"name":"OneHom.one_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : One P\nf : OneHom M N\n⊢ Eq (OneHom.comp 1 f) 1","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.one_comp [One M] [One N] [One P] (f : OneHom M N) :\n    (1 : OneHom N P).comp f = 1 := rfl\n\n"}
{"name":"ZeroHom.zero_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\nf : ZeroHom M N\n⊢ Eq (ZeroHom.comp 0 f) 0","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.one_comp [One M] [One N] [One P] (f : OneHom M N) :\n    (1 : OneHom N P).comp f = 1 := rfl\n\n"}
{"name":"OneHom.comp_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : One P\nf : OneHom N P\n⊢ Eq (f.comp 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.comp_one [One M] [One N] [One P] (f : OneHom N P) : f.comp (1 : OneHom M N) = 1 := by\n  ext\n  simp only [OneHom.map_one, OneHom.coe_comp, Function.comp_apply, OneHom.one_apply]\n\n"}
{"name":"ZeroHom.comp_zero","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\nf : ZeroHom N P\n⊢ Eq (f.comp 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.comp_one [One M] [One N] [One P] (f : OneHom N P) : f.comp (1 : OneHom M N) = 1 := by\n  ext\n  simp only [OneHom.map_one, OneHom.coe_comp, Function.comp_apply, OneHom.one_apply]\n\n"}
{"name":"AddMonoidHom.zero_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom M N\n⊢ Eq (AddMonoidHom.comp 0 f) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_comp [MulOneClass M] [MulOneClass N] [MulOneClass P] (f : M →* N) :\n    (1 : N →* P).comp f = 1 := rfl\n\n"}
{"name":"MonoidHom.one_comp","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom M N\n⊢ Eq (MonoidHom.comp 1 f) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_comp [MulOneClass M] [MulOneClass N] [MulOneClass P] (f : M →* N) :\n    (1 : N →* P).comp f = 1 := rfl\n\n"}
{"name":"MonoidHom.comp_one","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom N P\n⊢ Eq (f.comp 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem comp_one [MulOneClass M] [MulOneClass N] [MulOneClass P] (f : N →* P) :\n    f.comp (1 : M →* N) = 1 := by\n  ext\n  simp only [map_one, coe_comp, Function.comp_apply, one_apply]\n\n"}
{"name":"AddMonoidHom.comp_zero","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom N P\n⊢ Eq (f.comp 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem comp_one [MulOneClass M] [MulOneClass N] [MulOneClass P] (f : N →* P) :\n    f.comp (1 : M →* N) = 1 := by\n  ext\n  simp only [map_one, coe_comp, Function.comp_apply, one_apply]\n\n"}
{"name":"MonoidHom.map_inv","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : DivisionMonoid β\nf : MonoidHom α β\na : α\n⊢ Eq (f (Inv.inv a)) (Inv.inv (f a))","decl":"/-- Group homomorphisms preserve inverse. -/\n@[to_additive \"Additive group homomorphisms preserve negation.\"]\nprotected theorem map_inv [Group α] [DivisionMonoid β] (f : α →* β) (a : α) : f a⁻¹ = (f a)⁻¹ :=\n  map_inv f _\n\n"}
{"name":"AddMonoidHom.map_neg","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : SubtractionMonoid β\nf : AddMonoidHom α β\na : α\n⊢ Eq (f (Neg.neg a)) (Neg.neg (f a))","decl":"/-- Group homomorphisms preserve inverse. -/\n@[to_additive \"Additive group homomorphisms preserve negation.\"]\nprotected theorem map_inv [Group α] [DivisionMonoid β] (f : α →* β) (a : α) : f a⁻¹ = (f a)⁻¹ :=\n  map_inv f _\n\n"}
{"name":"MonoidHom.map_zpow","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : DivisionMonoid β\nf : MonoidHom α β\ng : α\nn : Int\n⊢ Eq (f (HPow.hPow g n)) (HPow.hPow (f g) n)","decl":"/-- Group homomorphisms preserve integer power. -/\n@[to_additive \"Additive group homomorphisms preserve integer scaling.\"]\nprotected theorem map_zpow [Group α] [DivisionMonoid β] (f : α →* β) (g : α) (n : ℤ) :\n    f (g ^ n) = f g ^ n := map_zpow f g n\n\n"}
{"name":"AddMonoidHom.map_zsmul","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : SubtractionMonoid β\nf : AddMonoidHom α β\ng : α\nn : Int\n⊢ Eq (f (HSMul.hSMul n g)) (HSMul.hSMul n (f g))","decl":"/-- Group homomorphisms preserve integer power. -/\n@[to_additive \"Additive group homomorphisms preserve integer scaling.\"]\nprotected theorem map_zpow [Group α] [DivisionMonoid β] (f : α →* β) (g : α) (n : ℤ) :\n    f (g ^ n) = f g ^ n := map_zpow f g n\n\n"}
{"name":"AddMonoidHom.map_sub","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : SubtractionMonoid β\nf : AddMonoidHom α β\ng h : α\n⊢ Eq (f (HSub.hSub g h)) (HSub.hSub (f g) (f h))","decl":"/-- Group homomorphisms preserve division. -/\n@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\nprotected theorem map_div [Group α] [DivisionMonoid β] (f : α →* β) (g h : α) :\n    f (g / h) = f g / f h := map_div f g h\n\n"}
{"name":"MonoidHom.map_div","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : DivisionMonoid β\nf : MonoidHom α β\ng h : α\n⊢ Eq (f (HDiv.hDiv g h)) (HDiv.hDiv (f g) (f h))","decl":"/-- Group homomorphisms preserve division. -/\n@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\nprotected theorem map_div [Group α] [DivisionMonoid β] (f : α →* β) (g h : α) :\n    f (g / h) = f g / f h := map_div f g h\n\n"}
{"name":"AddMonoidHom.map_add_neg","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddGroup α\ninst✝ : SubtractionMonoid β\nf : AddMonoidHom α β\ng h : α\n⊢ Eq (f (HAdd.hAdd g (Neg.neg h))) (HAdd.hAdd (f g) (Neg.neg (f h)))","decl":"/-- Group homomorphisms preserve division. -/\n@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\nprotected theorem map_mul_inv [Group α] [DivisionMonoid β] (f : α →* β) (g h : α) :\n    f (g * h⁻¹) = f g * (f h)⁻¹ := by simp\n\n"}
{"name":"MonoidHom.map_mul_inv","module":"Mathlib.Algebra.Group.Hom.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Group α\ninst✝ : DivisionMonoid β\nf : MonoidHom α β\ng h : α\n⊢ Eq (f (HMul.hMul g (Inv.inv h))) (HMul.hMul (f g) (Inv.inv (f h)))","decl":"/-- Group homomorphisms preserve division. -/\n@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\nprotected theorem map_mul_inv [Group α] [DivisionMonoid β] (f : α →* β) (g h : α) :\n    f (g * h⁻¹) = f g * (f h)⁻¹ := by simp\n\n"}
