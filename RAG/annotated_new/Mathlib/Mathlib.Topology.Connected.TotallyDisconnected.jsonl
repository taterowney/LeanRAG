{"name":"isTotallyDisconnected_empty","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ IsTotallyDisconnected EmptyCollection.emptyCollection","decl":"theorem isTotallyDisconnected_empty : IsTotallyDisconnected (∅ : Set α) := fun _ ht _ _ x_in _ _ =>\n  (ht x_in).elim\n\n"}
{"name":"isTotallyDisconnected_singleton","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ IsTotallyDisconnected (Singleton.singleton x)","decl":"theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set α) := fun _ ht _ =>\n  subsingleton_singleton.anti ht\n\n"}
{"name":"TotallyDisconnectedSpace.isTotallyDisconnected_univ","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nself : TotallyDisconnectedSpace α\n⊢ IsTotallyDisconnected Set.univ","decl":"/-- A space is totally disconnected if all of its connected components are singletons. -/\n@[mk_iff]\nclass TotallyDisconnectedSpace (α : Type u) [TopologicalSpace α] : Prop where\n  /-- The universal set `Set.univ` in a totally disconnected space is totally disconnected. -/\n  isTotallyDisconnected_univ : IsTotallyDisconnected (univ : Set α)\n\n"}
{"name":"totallyDisconnectedSpace_iff","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Iff (TotallyDisconnectedSpace α) (IsTotallyDisconnected Set.univ)","decl":"/-- A space is totally disconnected if all of its connected components are singletons. -/\n@[mk_iff]\nclass TotallyDisconnectedSpace (α : Type u) [TopologicalSpace α] : Prop where\n  /-- The universal set `Set.univ` in a totally disconnected space is totally disconnected. -/\n  isTotallyDisconnected_univ : IsTotallyDisconnected (univ : Set α)\n\n"}
{"name":"IsPreconnected.subsingleton","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : TotallyDisconnectedSpace α\ns : Set α\nh : IsPreconnected s\n⊢ s.Subsingleton","decl":"theorem IsPreconnected.subsingleton [TotallyDisconnectedSpace α] {s : Set α}\n    (h : IsPreconnected s) : s.Subsingleton :=\n  TotallyDisconnectedSpace.isTotallyDisconnected_univ s (subset_univ s) h\n\n"}
{"name":"Pi.totallyDisconnectedSpace","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u_3\nβ : α → Type u_4\ninst✝¹ : (a : α) → TopologicalSpace (β a)\ninst✝ : ∀ (a : α), TotallyDisconnectedSpace (β a)\n⊢ TotallyDisconnectedSpace ((a : α) → β a)","decl":"instance Pi.totallyDisconnectedSpace {α : Type*} {β : α → Type*}\n    [∀ a, TopologicalSpace (β a)] [∀ a, TotallyDisconnectedSpace (β a)] :\n    TotallyDisconnectedSpace (∀ a : α, β a) :=\n  ⟨fun t _ h2 =>\n    have this : ∀ a, IsPreconnected ((fun x : ∀ a, β a => x a) '' t) := fun a =>\n      h2.image (fun x => x a) (continuous_apply a).continuousOn\n    fun x x_in y y_in => funext fun a => (this a).subsingleton ⟨x, x_in, rfl⟩ ⟨y, y_in, rfl⟩⟩\n\n"}
{"name":"Prod.totallyDisconnectedSpace","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TotallyDisconnectedSpace α\ninst✝ : TotallyDisconnectedSpace β\n⊢ TotallyDisconnectedSpace (Prod α β)","decl":"instance Prod.totallyDisconnectedSpace [TopologicalSpace β] [TotallyDisconnectedSpace α]\n    [TotallyDisconnectedSpace β] : TotallyDisconnectedSpace (α × β) :=\n  ⟨fun t _ h2 =>\n    have H1 : IsPreconnected (Prod.fst '' t) := h2.image Prod.fst continuous_fst.continuousOn\n    have H2 : IsPreconnected (Prod.snd '' t) := h2.image Prod.snd continuous_snd.continuousOn\n    fun x hx y hy =>\n    Prod.ext (H1.subsingleton ⟨x, hx, rfl⟩ ⟨y, hy, rfl⟩)\n      (H2.subsingleton ⟨x, hx, rfl⟩ ⟨y, hy, rfl⟩)⟩\n\n"}
{"name":"instTotallyDisconnectedSpaceSum","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TotallyDisconnectedSpace α\ninst✝ : TotallyDisconnectedSpace β\n⊢ TotallyDisconnectedSpace (Sum α β)","decl":"instance [TopologicalSpace β] [TotallyDisconnectedSpace α] [TotallyDisconnectedSpace β] :\n    TotallyDisconnectedSpace (α ⊕ β) := by\n  refine ⟨fun s _ hs => ?_⟩\n  obtain ⟨t, ht, rfl⟩ | ⟨t, ht, rfl⟩ := Sum.isPreconnected_iff.1 hs\n  · exact ht.subsingleton.image _\n  · exact ht.subsingleton.image _\n\n"}
{"name":"instTotallyDisconnectedSpaceSigma","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝¹ : (i : ι) → TopologicalSpace (π i)\ninst✝ : ∀ (i : ι), TotallyDisconnectedSpace (π i)\n⊢ TotallyDisconnectedSpace (Sigma fun i => π i)","decl":"instance [∀ i, TopologicalSpace (π i)] [∀ i, TotallyDisconnectedSpace (π i)] :\n    TotallyDisconnectedSpace (Σi, π i) := by\n  refine ⟨fun s _ hs => ?_⟩\n  obtain rfl | h := s.eq_empty_or_nonempty\n  · exact subsingleton_empty\n  · obtain ⟨a, t, ht, rfl⟩ := Sigma.isConnected_iff.1 ⟨h, hs⟩\n    exact ht.isPreconnected.subsingleton.image _\n\n-- Porting note: reformulated using `Pairwise`\n"}
{"name":"isTotallyDisconnected_of_isClopen_set","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"X : Type u_3\ninst✝ : TopologicalSpace X\nhX : Pairwise fun x y => Exists fun U => And (IsClopen U) (And (Membership.mem U x) (Not (Membership.mem U y)))\n⊢ IsTotallyDisconnected Set.univ","decl":"/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\n  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem isTotallyDisconnected_of_isClopen_set {X : Type*} [TopologicalSpace X]\n    (hX : Pairwise fun x y => ∃ (U : Set X), IsClopen U ∧ x ∈ U ∧ y ∉ U) :\n    IsTotallyDisconnected (Set.univ : Set X) := by\n  rintro S - hS\n  unfold Set.Subsingleton\n  by_contra! h_contra\n  rcases h_contra with ⟨x, hx, y, hy, hxy⟩\n  obtain ⟨U, hU, hxU, hyU⟩ := hX hxy\n  specialize\n    hS U Uᶜ hU.2 hU.compl.2 (fun a _ => em (a ∈ U)) ⟨x, hx, hxU⟩ ⟨y, hy, hyU⟩\n  rw [inter_compl_self, Set.inter_empty] at hS\n  exact Set.not_nonempty_empty hS\n\n"}
{"name":"totallyDisconnectedSpace_iff_connectedComponent_subsingleton","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Iff (TotallyDisconnectedSpace α) (∀ (x : α), (connectedComponent x).Subsingleton)","decl":"/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem totallyDisconnectedSpace_iff_connectedComponent_subsingleton :\n    TotallyDisconnectedSpace α ↔ ∀ x : α, (connectedComponent x).Subsingleton := by\n  constructor\n  · intro h x\n    apply h.1\n    · exact subset_univ _\n    exact isPreconnected_connectedComponent\n  intro h; constructor\n  intro s s_sub hs\n  rcases eq_empty_or_nonempty s with (rfl | ⟨x, x_in⟩)\n  · exact subsingleton_empty\n  · exact (h x).anti (hs.subset_connectedComponent x_in)\n\n"}
{"name":"totallyDisconnectedSpace_iff_connectedComponent_singleton","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Iff (TotallyDisconnectedSpace α) (∀ (x : α), Eq (connectedComponent x) (Singleton.singleton x))","decl":"/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem totallyDisconnectedSpace_iff_connectedComponent_singleton :\n    TotallyDisconnectedSpace α ↔ ∀ x : α, connectedComponent x = {x} := by\n  rw [totallyDisconnectedSpace_iff_connectedComponent_subsingleton]\n  refine forall_congr' fun x => ?_\n  rw [subsingleton_iff_singleton]\n  exact mem_connectedComponent\n\n"}
{"name":"connectedComponent_eq_singleton","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : TotallyDisconnectedSpace α\nx : α\n⊢ Eq (connectedComponent x) (Singleton.singleton x)","decl":"@[simp] theorem connectedComponent_eq_singleton [TotallyDisconnectedSpace α] (x : α) :\n    connectedComponent x = {x} :=\n  totallyDisconnectedSpace_iff_connectedComponent_singleton.1 ‹_› x\n\n"}
{"name":"Continuous.image_connectedComponent_eq_singleton","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝² : TopologicalSpace α\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\ninst✝ : TotallyDisconnectedSpace β\nf : α → β\nh : Continuous f\na : α\n⊢ Eq (Set.image f (connectedComponent a)) (Singleton.singleton (f a))","decl":"/-- The image of a connected component in a totally disconnected space is a singleton. -/\n@[simp]\ntheorem Continuous.image_connectedComponent_eq_singleton {β : Type*} [TopologicalSpace β]\n    [TotallyDisconnectedSpace β] {f : α → β} (h : Continuous f) (a : α) :\n    f '' connectedComponent a = {f a} :=\n  (Set.subsingleton_iff_singleton <| mem_image_of_mem f mem_connectedComponent).mp\n    (isPreconnected_connectedComponent.image f h.continuousOn).subsingleton\n\n"}
{"name":"isTotallyDisconnected_of_totallyDisconnectedSpace","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : TotallyDisconnectedSpace α\ns : Set α\n⊢ IsTotallyDisconnected s","decl":"theorem isTotallyDisconnected_of_totallyDisconnectedSpace [TotallyDisconnectedSpace α] (s : Set α) :\n    IsTotallyDisconnected s := fun t _ ht =>\n  TotallyDisconnectedSpace.isTotallyDisconnected_univ _ t.subset_univ ht\n\n"}
{"name":"isTotallyDisconnected_of_image","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : ContinuousOn f s\nhf' : Function.Injective f\nh : IsTotallyDisconnected (Set.image f s)\n⊢ IsTotallyDisconnected s","decl":"theorem isTotallyDisconnected_of_image [TopologicalSpace β] {f : α → β} (hf : ContinuousOn f s)\n    (hf' : Injective f) (h : IsTotallyDisconnected (f '' s)) : IsTotallyDisconnected s :=\n  fun _t hts ht _x x_in _y y_in =>\n  hf' <|\n    h _ (image_subset f hts) (ht.image f <| hf.mono hts) (mem_image_of_mem f x_in)\n      (mem_image_of_mem f y_in)\n\n"}
{"name":"Topology.IsEmbedding.isTotallyDisconnected","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns : Set α\nhf : Topology.IsEmbedding f\nh : IsTotallyDisconnected (Set.image f s)\n⊢ IsTotallyDisconnected s","decl":"lemma Topology.IsEmbedding.isTotallyDisconnected [TopologicalSpace β] {f : α → β} {s : Set α}\n    (hf : IsEmbedding f) (h : IsTotallyDisconnected (f '' s)) : IsTotallyDisconnected s :=\n  isTotallyDisconnected_of_image hf.continuous.continuousOn hf.injective h\n\n"}
{"name":"Embedding.isTotallyDisconnected","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns : Set α\nhf : Topology.IsEmbedding f\nh : IsTotallyDisconnected (Set.image f s)\n⊢ IsTotallyDisconnected s","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.isTotallyDisconnected := IsEmbedding.isTotallyDisconnected\n\n"}
{"name":"Topology.IsEmbedding.isTotallyDisconnected_image","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns : Set α\nhf : Topology.IsEmbedding f\n⊢ Iff (IsTotallyDisconnected (Set.image f s)) (IsTotallyDisconnected s)","decl":"lemma Topology.IsEmbedding.isTotallyDisconnected_image [TopologicalSpace β] {f : α → β} {s : Set α}\n    (hf : IsEmbedding f) : IsTotallyDisconnected (f '' s) ↔ IsTotallyDisconnected s := by\n  refine ⟨hf.isTotallyDisconnected, fun hs u hus hu ↦ ?_⟩\n  obtain ⟨v, hvs, rfl⟩ : ∃ v, v ⊆ s ∧ f '' v = u :=\n    ⟨f ⁻¹' u ∩ s, inter_subset_right, by rwa [image_preimage_inter, inter_eq_left]⟩\n  rw [hf.isInducing.isPreconnected_image] at hu\n  exact (hs v hvs hu).image _\n\n"}
{"name":"Embedding.isTotallyDisconnected_image","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns : Set α\nhf : Topology.IsEmbedding f\n⊢ Iff (IsTotallyDisconnected (Set.image f s)) (IsTotallyDisconnected s)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.isTotallyDisconnected_image := IsEmbedding.isTotallyDisconnected_image\n\n"}
{"name":"Topology.IsEmbedding.isTotallyDisconnected_range","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Topology.IsEmbedding f\n⊢ Iff (IsTotallyDisconnected (Set.range f)) (TotallyDisconnectedSpace α)","decl":"lemma Topology.IsEmbedding.isTotallyDisconnected_range [TopologicalSpace β] {f : α → β}\n    (hf : IsEmbedding f) : IsTotallyDisconnected (range f) ↔ TotallyDisconnectedSpace α := by\n  rw [totallyDisconnectedSpace_iff, ← image_univ, hf.isTotallyDisconnected_image]\n\n"}
{"name":"Embedding.isTotallyDisconnected_range","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Topology.IsEmbedding f\n⊢ Iff (IsTotallyDisconnected (Set.range f)) (TotallyDisconnectedSpace α)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.isTotallyDisconnected_range := IsEmbedding.isTotallyDisconnected_range\n\n"}
{"name":"totallyDisconnectedSpace_subtype_iff","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Iff (TotallyDisconnectedSpace ↑s) (IsTotallyDisconnected s)","decl":"lemma totallyDisconnectedSpace_subtype_iff {s : Set α} :\n    TotallyDisconnectedSpace s ↔ IsTotallyDisconnected s := by\n  rw [← IsEmbedding.subtypeVal.isTotallyDisconnected_range, Subtype.range_val]\n\n"}
{"name":"Subtype.totallyDisconnectedSpace","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u_3\np : α → Prop\ninst✝¹ : TopologicalSpace α\ninst✝ : TotallyDisconnectedSpace α\n⊢ TotallyDisconnectedSpace (Subtype p)","decl":"instance Subtype.totallyDisconnectedSpace {α : Type*} {p : α → Prop} [TopologicalSpace α]\n    [TotallyDisconnectedSpace α] : TotallyDisconnectedSpace (Subtype p) :=\n  totallyDisconnectedSpace_subtype_iff.2 (isTotallyDisconnected_of_totallyDisconnectedSpace _)\n\n"}
{"name":"isTotallySeparated_empty","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ IsTotallySeparated EmptyCollection.emptyCollection","decl":"theorem isTotallySeparated_empty : IsTotallySeparated (∅ : Set α) := fun _ => False.elim\n\n"}
{"name":"isTotallySeparated_singleton","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\n⊢ IsTotallySeparated (Singleton.singleton x)","decl":"theorem isTotallySeparated_singleton {x} : IsTotallySeparated ({x} : Set α) := fun _ hp _ hq hpq =>\n  (hpq <| (eq_of_mem_singleton hp).symm ▸ (eq_of_mem_singleton hq).symm).elim\n\n"}
{"name":"isTotallyDisconnected_of_isTotallySeparated","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nH : IsTotallySeparated s\n⊢ IsTotallyDisconnected s","decl":"theorem isTotallyDisconnected_of_isTotallySeparated {s : Set α} (H : IsTotallySeparated s) :\n    IsTotallyDisconnected s := by\n  intro t hts ht x x_in y y_in\n  by_contra h\n  obtain\n    ⟨u : Set α, v : Set α, hu : IsOpen u, hv : IsOpen v, hxu : x ∈ u, hyv : y ∈ v, hs : s ⊆ u ∪ v,\n      huv⟩ :=\n    H (hts x_in) (hts y_in) h\n  refine (ht _ _ hu hv (hts.trans hs) ⟨x, x_in, hxu⟩ ⟨y, y_in, hyv⟩).ne_empty ?_\n  rw [huv.inter_eq, inter_empty]\n\n"}
{"name":"IsTotallySeparated.isTotallyDisconnected","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nH : IsTotallySeparated s\n⊢ IsTotallyDisconnected s","decl":"alias IsTotallySeparated.isTotallyDisconnected := isTotallyDisconnected_of_isTotallySeparated\n\n"}
{"name":"TotallySeparatedSpace.isTotallySeparated_univ","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nself : TotallySeparatedSpace α\n⊢ IsTotallySeparated Set.univ","decl":"/-- A space is totally separated if any two points can be separated by two disjoint open sets\ncovering the whole space. -/\n@[mk_iff] class TotallySeparatedSpace (α : Type u) [TopologicalSpace α] : Prop where\n  /-- The universal set `Set.univ` in a totally separated space is totally separated. -/\n  isTotallySeparated_univ : IsTotallySeparated (univ : Set α)\n\n-- see Note [lower instance priority]\n"}
{"name":"totallySeparatedSpace_iff","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ Iff (TotallySeparatedSpace α) (IsTotallySeparated Set.univ)","decl":"/-- A space is totally separated if any two points can be separated by two disjoint open sets\ncovering the whole space. -/\n@[mk_iff] class TotallySeparatedSpace (α : Type u) [TopologicalSpace α] : Prop where\n  /-- The universal set `Set.univ` in a totally separated space is totally separated. -/\n  isTotallySeparated_univ : IsTotallySeparated (univ : Set α)\n\n-- see Note [lower instance priority]\n"}
{"name":"TotallySeparatedSpace.totallyDisconnectedSpace","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\ninst✝ : TotallySeparatedSpace α\n⊢ TotallyDisconnectedSpace α","decl":"instance (priority := 100) TotallySeparatedSpace.totallyDisconnectedSpace (α : Type u)\n    [TopologicalSpace α] [TotallySeparatedSpace α] : TotallyDisconnectedSpace α :=\n  ⟨TotallySeparatedSpace.isTotallySeparated_univ.isTotallyDisconnected⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"TotallySeparatedSpace.of_discrete","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : DiscreteTopology α\n⊢ TotallySeparatedSpace α","decl":"instance (priority := 100) TotallySeparatedSpace.of_discrete (α : Type*) [TopologicalSpace α]\n    [DiscreteTopology α] : TotallySeparatedSpace α :=\n  ⟨fun _ _ b _ h => ⟨{b}ᶜ, {b}, isOpen_discrete _, isOpen_discrete _, h, rfl,\n    (compl_union_self _).symm.subset, disjoint_compl_left⟩⟩\n\n"}
{"name":"totallySeparatedSpace_iff_exists_isClopen","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u_3\ninst✝ : TopologicalSpace α\n⊢ Iff (TotallySeparatedSpace α) (∀ (x y : α), Ne x y → Exists fun U => And (IsClopen U) (And (Membership.mem U x) (Membership.mem (HasCompl.compl U) y)))","decl":"theorem totallySeparatedSpace_iff_exists_isClopen {α : Type*} [TopologicalSpace α] :\n    TotallySeparatedSpace α ↔ ∀ x y : α, x ≠ y → ∃ U : Set α, IsClopen U ∧ x ∈ U ∧ y ∈ Uᶜ := by\n  simp only [totallySeparatedSpace_iff, IsTotallySeparated, Set.Pairwise, mem_univ, true_implies]\n  refine forall₃_congr fun x y _ ↦\n    ⟨fun ⟨U, V, hU, hV, Ux, Vy, f, disj⟩ ↦ ?_, fun ⟨U, hU, Ux, Ucy⟩ ↦ ?_⟩\n  · exact ⟨U, isClopen_of_disjoint_cover_open f hU hV disj,\n      Ux, fun Uy ↦ Set.disjoint_iff.mp disj ⟨Uy, Vy⟩⟩\n  · exact ⟨U, Uᶜ, hU.2, hU.compl.2, Ux, Ucy, (Set.union_compl_self U).ge, disjoint_compl_right⟩\n\n"}
{"name":"exists_isClopen_of_totally_separated","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TotallySeparatedSpace α\nx y : α\nhxy : Ne x y\n⊢ Exists fun U => And (IsClopen U) (And (Membership.mem U x) (Membership.mem (HasCompl.compl U) y))","decl":"theorem exists_isClopen_of_totally_separated {α : Type*} [TopologicalSpace α]\n    [TotallySeparatedSpace α] {x y : α} (hxy : x ≠ y) :\n    ∃ U : Set α, IsClopen U ∧ x ∈ U ∧ y ∈ Uᶜ :=\n  totallySeparatedSpace_iff_exists_isClopen.mp ‹_› _ _ hxy\n\n"}
{"name":"Continuous.image_eq_of_connectedComponent_eq","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TotallyDisconnectedSpace β\nf : α → β\nh : Continuous f\na b : α\nhab : Eq (connectedComponent a) (connectedComponent b)\n⊢ Eq (f a) (f b)","decl":"theorem Continuous.image_eq_of_connectedComponent_eq (h : Continuous f) (a b : α)\n    (hab : connectedComponent a = connectedComponent b) : f a = f b :=\n  singleton_eq_singleton_iff.1 <|\n    h.image_connectedComponent_eq_singleton a ▸\n      h.image_connectedComponent_eq_singleton b ▸ hab ▸ rfl\n\n"}
{"name":"Continuous.connectedComponentsLift_continuous","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TotallyDisconnectedSpace β\nf : α → β\nh : Continuous f\n⊢ Continuous h.connectedComponentsLift","decl":"@[continuity]\ntheorem Continuous.connectedComponentsLift_continuous (h : Continuous f) :\n    Continuous h.connectedComponentsLift :=\n  h.quotient_liftOn' <| by convert h.image_eq_of_connectedComponent_eq\n\n"}
{"name":"Continuous.connectedComponentsLift_apply_coe","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TotallyDisconnectedSpace β\nf : α → β\nh : Continuous f\nx : α\n⊢ Eq (h.connectedComponentsLift (ConnectedComponents.mk x)) (f x)","decl":"@[simp]\ntheorem Continuous.connectedComponentsLift_apply_coe (h : Continuous f) (x : α) :\n    h.connectedComponentsLift x = f x :=\n  rfl\n\n"}
{"name":"Continuous.connectedComponentsLift_comp_coe","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TotallyDisconnectedSpace β\nf : α → β\nh : Continuous f\n⊢ Eq (Function.comp h.connectedComponentsLift ConnectedComponents.mk) f","decl":"@[simp]\ntheorem Continuous.connectedComponentsLift_comp_coe (h : Continuous f) :\n    h.connectedComponentsLift ∘ (↑) = f :=\n  rfl\n\n"}
{"name":"connectedComponents_lift_unique'","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nβ : Sort u_3\ng₁ g₂ : ConnectedComponents α → β\nhg : Eq (Function.comp g₁ ConnectedComponents.mk) (Function.comp g₂ ConnectedComponents.mk)\n⊢ Eq g₁ g₂","decl":"theorem connectedComponents_lift_unique' {β : Sort*} {g₁ g₂ : ConnectedComponents α → β}\n    (hg : g₁ ∘ ((↑) : α → ConnectedComponents α) = g₂ ∘ (↑)) : g₁ = g₂ :=\n  ConnectedComponents.surjective_coe.injective_comp_right hg\n\n"}
{"name":"Continuous.connectedComponentsLift_unique","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TotallyDisconnectedSpace β\nf : α → β\nh : Continuous f\ng : ConnectedComponents α → β\nhg : Eq (Function.comp g ConnectedComponents.mk) f\n⊢ Eq g h.connectedComponentsLift","decl":"theorem Continuous.connectedComponentsLift_unique (h : Continuous f) (g : ConnectedComponents α → β)\n    (hg : g ∘ (↑) = f) : g = h.connectedComponentsLift :=\n  connectedComponents_lift_unique' <| hg.trans h.connectedComponentsLift_comp_coe.symm\n\n"}
{"name":"ConnectedComponents.totallyDisconnectedSpace","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\n⊢ TotallyDisconnectedSpace (ConnectedComponents α)","decl":"instance ConnectedComponents.totallyDisconnectedSpace :\n    TotallyDisconnectedSpace (ConnectedComponents α) := by\n  rw [totallyDisconnectedSpace_iff_connectedComponent_singleton]\n  refine ConnectedComponents.surjective_coe.forall.2 fun x => ?_\n  rw [← ConnectedComponents.isQuotientMap_coe.image_connectedComponent, ←\n    connectedComponents_preimage_singleton, image_preimage_eq _ ConnectedComponents.surjective_coe]\n  refine ConnectedComponents.surjective_coe.forall.2 fun y => ?_\n  rw [connectedComponents_preimage_singleton]\n  exact isConnected_connectedComponent\n\n"}
{"name":"Continuous.connectedComponentsMap_continuous","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\nβ : Type u_3\ninst✝ : TopologicalSpace β\nf : α → β\nh : Continuous f\n⊢ Continuous h.connectedComponentsMap","decl":"theorem Continuous.connectedComponentsMap_continuous {β : Type*} [TopologicalSpace β] {f : α → β}\n    (h : Continuous f) : Continuous h.connectedComponentsMap :=\n  Continuous.connectedComponentsLift_continuous (ConnectedComponents.continuous_coe.comp h)\n\n"}
{"name":"IsPreconnected.constant","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝² : TopologicalSpace α\nY : Type u_3\ninst✝¹ : TopologicalSpace Y\ninst✝ : DiscreteTopology Y\ns : Set α\nhs : IsPreconnected s\nf : α → Y\nhf : ContinuousOn f s\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Eq (f x) (f y)","decl":"/-- A preconnected set `s` has the property that every map to a\ndiscrete space that is continuous on `s` is constant on `s` -/\ntheorem IsPreconnected.constant {Y : Type*} [TopologicalSpace Y] [DiscreteTopology Y] {s : Set α}\n    (hs : IsPreconnected s) {f : α → Y} (hf : ContinuousOn f s) {x y : α} (hx : x ∈ s)\n    (hy : y ∈ s) : f x = f y :=\n  (hs.image f hf).subsingleton (mem_image_of_mem f hx) (mem_image_of_mem f hy)\n\n"}
{"name":"PreconnectedSpace.constant","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝² : TopologicalSpace α\nY : Type u_3\ninst✝¹ : TopologicalSpace Y\ninst✝ : DiscreteTopology Y\nhp : PreconnectedSpace α\nf : α → Y\nhf : Continuous f\nx y : α\n⊢ Eq (f x) (f y)","decl":"/-- A `PreconnectedSpace` version of `isPreconnected.constant` -/\ntheorem PreconnectedSpace.constant {Y : Type*} [TopologicalSpace Y] [DiscreteTopology Y]\n    (hp : PreconnectedSpace α) {f : α → Y} (hf : Continuous f) {x y : α} : f x = f y :=\n  IsPreconnected.constant hp.isPreconnected_univ (Continuous.continuousOn hf) trivial trivial\n\n"}
{"name":"IsPreconnected.constant_of_mapsTo","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝² : TopologicalSpace α\nS : Set α\nhS : IsPreconnected S\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\nT : Set β\ninst✝ : DiscreteTopology ↑T\nf : α → β\nhc : ContinuousOn f S\nhTm : Set.MapsTo f S T\nx y : α\nhx : Membership.mem S x\nhy : Membership.mem S y\n⊢ Eq (f x) (f y)","decl":"/-- Refinement of `IsPreconnected.constant` only assuming the map factors through a\ndiscrete subset of the target. -/\ntheorem IsPreconnected.constant_of_mapsTo {S : Set α} (hS : IsPreconnected S)\n    {β} [TopologicalSpace β] {T : Set β} [DiscreteTopology T] {f : α → β} (hc : ContinuousOn f S)\n    (hTm : MapsTo f S T) {x y : α} (hx : x ∈ S) (hy : y ∈ S) : f x = f y := by\n  let F : S → T := hTm.restrict f S T\n  suffices F ⟨x, hx⟩ = F ⟨y, hy⟩ by rwa [← Subtype.coe_inj] at this\n  exact (isPreconnected_iff_preconnectedSpace.mp hS).constant (hc.restrict_mapsTo _)\n\n"}
{"name":"IsPreconnected.eqOn_const_of_mapsTo","module":"Mathlib.Topology.Connected.TotallyDisconnected","initialProofState":"α : Type u\ninst✝² : TopologicalSpace α\nS : Set α\nhS : IsPreconnected S\nβ : Type u_3\ninst✝¹ : TopologicalSpace β\nT : Set β\ninst✝ : DiscreteTopology ↑T\nf : α → β\nhc : ContinuousOn f S\nhTm : Set.MapsTo f S T\nhne : T.Nonempty\n⊢ Exists fun y => And (Membership.mem T y) (Set.EqOn f (Function.const α y) S)","decl":"/-- A version of `IsPreconnected.constant_of_mapsTo` that assumes that the codomain is nonempty and\nproves that `f` is equal to `const α y` on `S` for some `y ∈ T`. -/\ntheorem IsPreconnected.eqOn_const_of_mapsTo {S : Set α} (hS : IsPreconnected S)\n    {β} [TopologicalSpace β] {T : Set β} [DiscreteTopology T] {f : α → β} (hc : ContinuousOn f S)\n    (hTm : MapsTo f S T) (hne : T.Nonempty) : ∃ y ∈ T, EqOn f (const α y) S := by\n  rcases S.eq_empty_or_nonempty with (rfl | ⟨x, hx⟩)\n  · exact hne.imp fun _ hy => ⟨hy, eqOn_empty _ _⟩\n  · exact ⟨f x, hTm hx, fun x' hx' => hS.constant_of_mapsTo hc hTm hx' hx⟩\n"}
