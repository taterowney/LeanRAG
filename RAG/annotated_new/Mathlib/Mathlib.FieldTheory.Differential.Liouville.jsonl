{"name":"IsLiouville.isLiouville","module":"Mathlib.FieldTheory.Differential.Liouville","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Differential F\ninst✝² : Differential K\ninst✝¹ : Algebra F K\nself : IsLiouville F K\na : F\nι : Type\ninst✝ : Fintype ι\nc : ι → F\nhc : ∀ (x : ι), Eq (c x)′ 0\nu : ι → K\nv : K\nh : Eq (↑a) (HAdd.hAdd (Finset.univ.sum fun x => HMul.hMul (↑(c x)) (Differential.logDeriv (u x))) v′)\n⊢ Exists fun ι₀ => Exists fun x => Exists fun c₀ => Exists fun x_1 => Exists fun u₀ => Exists fun v₀ => Eq a (HAdd.hAdd (Finset.univ.sum fun x => HMul.hMul (c₀ x) (Differential.logDeriv (u₀ x))) v₀′)","decl":"/--\nWe say that a differential field extension `K / F` is Liouville if, whenever an element `a ∈ F` can\nbe written as `a = v + ∑ cᵢ * logDeriv uᵢ` for `v, cᵢ, uᵢ ∈ K` and `cᵢ` constant, it can also be\nwritten in that way with `v, cᵢ, uᵢ ∈ F`.\n-/\nclass IsLiouville : Prop where\n  isLiouville (a : F) (ι : Type) [Fintype ι] (c : ι → F) (hc : ∀ x, (c x)′ = 0)\n    (u : ι → K) (v : K) (h : a = ∑ x, c x * logDeriv (u x) + v′) :\n    ∃ (ι₀ : Type) (_ : Fintype ι₀) (c₀ : ι₀ → F) (_ : ∀ x, (c₀ x)′ = 0)\n      (u₀ : ι₀ → F) (v₀ : F), a = ∑ x, c₀ x * logDeriv (u₀ x) + v₀′\n\n"}
{"name":"IsLiouville.rfl","module":"Mathlib.FieldTheory.Differential.Liouville","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : Differential F\n⊢ IsLiouville F F","decl":"instance IsLiouville.rfl : IsLiouville F F where\n  isLiouville (a : F) (ι : Type) [Fintype ι] (c : ι → F) (hc : ∀ x, (c x)′ = 0)\n      (u : ι → F) (v : F) (h : a = ∑ x, c x * logDeriv (u x) + v′) :=\n    ⟨ι, _, c, hc, u, v, h⟩\n\n"}
{"name":"IsLiouville.trans","module":"Mathlib.FieldTheory.Differential.Liouville","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝¹¹ : Field F\ninst✝¹⁰ : Field K\ninst✝⁹ : Differential F\ninst✝⁸ : Differential K\ninst✝⁷ : Algebra F K\ninst✝⁶ : DifferentialAlgebra F K\nA : Type u_3\ninst✝⁵ : Field A\ninst✝⁴ : Algebra K A\ninst✝³ : Algebra F A\ninst✝² : Differential A\ninst✝¹ : IsScalarTower F K A\ninst✝ : Differential.ContainConstants F K\ninst1 : IsLiouville F K\ninst2 : IsLiouville K A\n⊢ IsLiouville F A","decl":"lemma IsLiouville.trans {A : Type*} [Field A] [Algebra K A] [Algebra F A]\n    [Differential A] [IsScalarTower F K A] [Differential.ContainConstants F K]\n    (inst1 : IsLiouville F K) (inst2 : IsLiouville K A) : IsLiouville F A where\n  isLiouville (a : F) (ι : Type) [Fintype ι] (c : ι → F) (hc : ∀ x, (c x)′ = 0)\n      (u : ι → A) (v : A) (h : a = ∑ x, c x * logDeriv (u x) + v′) := by\n    obtain ⟨ι₀, _, c₀, hc₀, u₀, v₀, h₀⟩ := inst2.isLiouville (a : K) ι\n        ((↑) ∘ c)\n        (fun _ ↦ by simp only [Function.comp_apply, ← coe_deriv, lift_map_eq_zero_iff, hc])\n        ((↑) ∘ u) v (by simpa only [Function.comp_apply, ← IsScalarTower.algebraMap_apply])\n    have hc (x : ι₀) := mem_range_of_deriv_eq_zero F (hc₀ x)\n    choose c₀ hc using hc\n    apply inst1.isLiouville a ι₀ c₀ _ u₀ v₀\n    · rw [h₀]\n      simp [hc]\n    · intro\n      apply_fun ((↑) : F → K)\n      · simp only [Function.comp_apply, coe_deriv, hc, algebraMap.coe_zero]\n        apply hc₀\n      · apply NoZeroSMulDivisors.algebraMap_injective\n\n"}
{"name":"instIsLiouvilleSubtypeMemIntermediateField","module":"Mathlib.FieldTheory.Differential.Liouville","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁶ : Field F\ninst✝⁵ : Field K\ninst✝⁴ : Differential F\ninst✝³ : Differential K\ninst✝² : Algebra F K\ninst✝¹ : CharZero F\nB : IntermediateField F K\ninst✝ : FiniteDimensional F (Subtype fun x => Membership.mem B x)\ninst : IsLiouville F K\n⊢ IsLiouville F (Subtype fun x => Membership.mem B x)","decl":"/--\nIf `K` is a Liouville extension of `F` and `B` is a finite dimensional intermediate\nfield `K / B / F`, then it's also a Liouville extension of `F`.\n-/\ninstance (B : IntermediateField F K)\n    [FiniteDimensional F B] [inst : IsLiouville F K] :\n    IsLiouville F B where\n  isLiouville (a : F) (ι : Type) [Fintype ι] (c : ι → F) (hc : ∀ x, (c x)′ = 0)\n      (u : ι → B) (v : B) (h : a = ∑ x, c x * logDeriv (u x) + v′) := by\n    apply inst.isLiouville a ι c hc (B.val ∘ u) (B.val v)\n    dsimp only [coe_val, Function.comp_apply]\n    conv =>\n      rhs\n      congr\n      · rhs\n        intro x\n        rhs\n        apply logDeriv_algebraMap (u x)\n      · apply (deriv_algebraMap v)\n    simp_rw [IsScalarTower.algebraMap_apply F B K]\n    norm_cast\n\n\n"}
{"name":"IsLiouville.equiv","module":"Mathlib.FieldTheory.Differential.Liouville","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝¹¹ : Field F\ninst✝¹⁰ : Field K\ninst✝⁹ : Differential F\ninst✝⁸ : Differential K\ninst✝⁷ : Algebra F K\ninst✝⁶ : DifferentialAlgebra F K\ninst✝⁵ : CharZero F\nK' : Type u_3\ninst✝⁴ : Field K'\ninst✝³ : Differential K'\ninst✝² : Algebra F K'\ninst✝¹ : DifferentialAlgebra F K'\ninst✝ : Algebra.IsAlgebraic F K'\ninst : IsLiouville F K\ne : AlgEquiv F K K'\n⊢ IsLiouville F K'","decl":"/--\nTransfer an `IsLiouville` instance using an equivalence `K ≃ₐ[F] K'`.\nRequires an algebraic `K'` to show that the equivalence commutes with the derivative.\n-/\nlemma IsLiouville.equiv {K' : Type*} [Field K'] [Differential K'] [Algebra F K']\n    [DifferentialAlgebra F K'] [Algebra.IsAlgebraic F K']\n    [inst : IsLiouville F K] (e : K ≃ₐ[F] K') : IsLiouville F K' where\n  isLiouville (a : F) (ι : Type) [Fintype ι] (c : ι → F) (hc : ∀ x, (c x)′ = 0)\n      (u : ι → K') (v : K') (h : a = ∑ x, c x * logDeriv (u x) + v′) := by\n    apply inst.isLiouville a ι c hc (e.symm ∘ u) (e.symm v)\n    apply_fun e.symm at h\n    simpa [AlgEquiv.commutes, map_add, map_sum, map_mul, logDeriv, algEquiv_deriv'] using h\n\n"}
{"name":"isLiouville_of_finiteDimensional","module":"Mathlib.FieldTheory.Differential.Liouville","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁷ : Field F\ninst✝⁶ : Field K\ninst✝⁵ : Differential F\ninst✝⁴ : Differential K\ninst✝³ : Algebra F K\ninst✝² : DifferentialAlgebra F K\ninst✝¹ : CharZero F\ninst✝ : FiniteDimensional F K\n⊢ IsLiouville F K","decl":"/--\nWe lift `isLiouville_of_finiteDimensional_galois` to non-Galois field extensions by using it for the\nnormal closure then obtaining it for `F`.\n-/\ninstance isLiouville_of_finiteDimensional [FiniteDimensional F K] :\n    IsLiouville F K :=\n  let map := IsAlgClosed.lift (M := AlgebraicClosure F) (R := F) (S := K)\n  let K' := map.fieldRange\n  have : FiniteDimensional F K' :=\n    LinearMap.finiteDimensional_range map.toLinearMap\n  let K'' := normalClosure F K' (AlgebraicClosure F)\n  let B : IntermediateField F K'' := IntermediateField.restrict\n    (F := K') (IntermediateField.le_normalClosure ..)\n  have kequiv : K ≃ₐ[F] ↥B := (show K ≃ₐ[F] K' from AlgEquiv.ofInjectiveField map).trans\n    (IntermediateField.restrict_algEquiv _)\n  IsLiouville.equiv kequiv.symm\n\n"}
