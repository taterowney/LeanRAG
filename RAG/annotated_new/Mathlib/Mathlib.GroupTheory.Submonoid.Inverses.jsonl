{"name":"Submonoid.IsUnit.Submonoid.coe_inv","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : Subtype fun x => Membership.mem (IsUnit.submonoid M) x\n⊢ Eq ↑(Inv.inv x) ↑(Inv.inv (IsUnit.unit ⋯))","decl":"@[to_additive]\ntheorem IsUnit.Submonoid.coe_inv [Monoid M] (x : IsUnit.submonoid M) :\n    ↑x⁻¹ = (↑x.prop.unit⁻¹ : M) :=\n  rfl\n\n"}
{"name":"AddSubmonoid.IsUnit.Submonoid.coe_neg","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nx : Subtype fun x => Membership.mem (IsAddUnit.addSubmonoid M) x\n⊢ Eq ↑(Neg.neg x) ↑(Neg.neg (IsAddUnit.addUnit ⋯))","decl":"@[to_additive]\ntheorem IsUnit.Submonoid.coe_inv [Monoid M] (x : IsUnit.submonoid M) :\n    ↑x⁻¹ = (↑x.prop.unit⁻¹ : M) :=\n  rfl\n\n"}
{"name":"Submonoid.leftInv_leftInv_le","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\n⊢ LE.le S.leftInv.leftInv S","decl":"@[to_additive]\ntheorem leftInv_leftInv_le : S.leftInv.leftInv ≤ S := by\n  rintro x ⟨⟨y, z, h₁⟩, h₂ : x * y = 1⟩\n  convert z.prop\n  rw [← mul_one x, ← h₁, ← mul_assoc, h₂, one_mul]\n\n"}
{"name":"AddSubmonoid.leftNeg_leftNeg_le","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\n⊢ LE.le S.leftNeg.leftNeg S","decl":"@[to_additive]\ntheorem leftInv_leftInv_le : S.leftInv.leftInv ≤ S := by\n  rintro x ⟨⟨y, z, h₁⟩, h₂ : x * y = 1⟩\n  convert z.prop\n  rw [← mul_one x, ← h₁, ← mul_assoc, h₂, one_mul]\n\n"}
{"name":"AddSubmonoid.addUnit_mem_leftNeg","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits M\nhx : Membership.mem S ↑x\n⊢ Membership.mem S.leftNeg ↑(Neg.neg x)","decl":"@[to_additive]\ntheorem unit_mem_leftInv (x : Mˣ) (hx : (x : M) ∈ S) : ((x⁻¹ :) : M) ∈ S.leftInv :=\n  ⟨⟨x, hx⟩, x.inv_val⟩\n\n"}
{"name":"Submonoid.unit_mem_leftInv","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units M\nhx : Membership.mem S ↑x\n⊢ Membership.mem S.leftInv ↑(Inv.inv x)","decl":"@[to_additive]\ntheorem unit_mem_leftInv (x : Mˣ) (hx : (x : M) ∈ S) : ((x⁻¹ :) : M) ∈ S.leftInv :=\n  ⟨⟨x, hx⟩, x.inv_val⟩\n\n"}
{"name":"AddSubmonoid.leftNeg_leftNeg_eq","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nhS : LE.le S (IsAddUnit.addSubmonoid M)\n⊢ Eq S.leftNeg.leftNeg S","decl":"@[to_additive]\ntheorem leftInv_leftInv_eq (hS : S ≤ IsUnit.submonoid M) : S.leftInv.leftInv = S := by\n  refine le_antisymm S.leftInv_leftInv_le ?_\n  intro x hx\n  have : x = ((hS hx).unit⁻¹⁻¹ : Mˣ) := by\n    rw [inv_inv (hS hx).unit]\n    rfl\n  rw [this]\n  exact S.leftInv.unit_mem_leftInv _ (S.unit_mem_leftInv _ hx)\n\n"}
{"name":"Submonoid.leftInv_leftInv_eq","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nhS : LE.le S (IsUnit.submonoid M)\n⊢ Eq S.leftInv.leftInv S","decl":"@[to_additive]\ntheorem leftInv_leftInv_eq (hS : S ≤ IsUnit.submonoid M) : S.leftInv.leftInv = S := by\n  refine le_antisymm S.leftInv_leftInv_le ?_\n  intro x hx\n  have : x = ((hS hx).unit⁻¹⁻¹ : Mˣ) := by\n    rw [inv_inv (hS hx).unit]\n    rfl\n  rw [this]\n  exact S.leftInv.unit_mem_leftInv _ (S.unit_mem_leftInv _ hx)\n\n"}
{"name":"AddSubmonoid.add_fromLeftNeg","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : Subtype fun x => Membership.mem S.leftNeg x\n⊢ Eq (HAdd.hAdd ↑x ↑(S.fromLeftNeg x)) 0","decl":"@[to_additive (attr := simp)]\ntheorem mul_fromLeftInv (x : S.leftInv) : (x : M) * S.fromLeftInv x = 1 :=\n  x.prop.choose_spec\n\n"}
{"name":"Submonoid.mul_fromLeftInv","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Subtype fun x => Membership.mem S.leftInv x\n⊢ Eq (HMul.hMul ↑x ↑(S.fromLeftInv x)) 1","decl":"@[to_additive (attr := simp)]\ntheorem mul_fromLeftInv (x : S.leftInv) : (x : M) * S.fromLeftInv x = 1 :=\n  x.prop.choose_spec\n\n"}
{"name":"AddSubmonoid.fromLeftNeg_zero","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\n⊢ Eq (S.fromLeftNeg 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem fromLeftInv_one : S.fromLeftInv 1 = 1 :=\n  (one_mul _).symm.trans (Subtype.eq <| S.mul_fromLeftInv 1)\n\n"}
{"name":"Submonoid.fromLeftInv_one","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\n⊢ Eq (S.fromLeftInv 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem fromLeftInv_one : S.fromLeftInv 1 = 1 :=\n  (one_mul _).symm.trans (Subtype.eq <| S.mul_fromLeftInv 1)\n\n"}
{"name":"Submonoid.fromLeftInv_mul","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nx : Subtype fun x => Membership.mem S.leftInv x\n⊢ Eq (HMul.hMul ↑(S.fromLeftInv x) ↑x) 1","decl":"@[to_additive (attr := simp)]\ntheorem fromLeftInv_mul (x : S.leftInv) : (S.fromLeftInv x : M) * x = 1 := by\n  rw [mul_comm, mul_fromLeftInv]\n\n"}
{"name":"AddSubmonoid.fromLeftNeg_add","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nx : Subtype fun x => Membership.mem S.leftNeg x\n⊢ Eq (HAdd.hAdd ↑(S.fromLeftNeg x) ↑x) 0","decl":"@[to_additive (attr := simp)]\ntheorem fromLeftInv_mul (x : S.leftInv) : (S.fromLeftInv x : M) * x = 1 := by\n  rw [mul_comm, mul_fromLeftInv]\n\n"}
{"name":"AddSubmonoid.leftNeg_le_isAddUnit","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\n⊢ LE.le S.leftNeg (IsAddUnit.addSubmonoid M)","decl":"@[to_additive]\ntheorem leftInv_le_isUnit : S.leftInv ≤ IsUnit.submonoid M := fun x ⟨y, hx⟩ ↦\n  ⟨⟨x, y, hx, mul_comm x y ▸ hx⟩, rfl⟩\n\n"}
{"name":"Submonoid.leftInv_le_isUnit","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\n⊢ LE.le S.leftInv (IsUnit.submonoid M)","decl":"@[to_additive]\ntheorem leftInv_le_isUnit : S.leftInv ≤ IsUnit.submonoid M := fun x ⟨y, hx⟩ ↦\n  ⟨⟨x, y, hx, mul_comm x y ▸ hx⟩, rfl⟩\n\n"}
{"name":"Submonoid.fromLeftInv_eq_iff","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\na : Subtype fun x => Membership.mem S.leftInv x\nb : M\n⊢ Iff (Eq (↑(S.fromLeftInv a)) b) (Eq (HMul.hMul (↑a) b) 1)","decl":"@[to_additive]\ntheorem fromLeftInv_eq_iff (a : S.leftInv) (b : M) :\n    (S.fromLeftInv a : M) = b ↔ (a : M) * b = 1 := by\n  rw [← IsUnit.mul_right_inj (leftInv_le_isUnit _ a.prop), S.mul_fromLeftInv, eq_comm]\n\n"}
{"name":"AddSubmonoid.fromLeftNeg_eq_iff","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\na : Subtype fun x => Membership.mem S.leftNeg x\nb : M\n⊢ Iff (Eq (↑(S.fromLeftNeg a)) b) (Eq (HAdd.hAdd (↑a) b) 0)","decl":"@[to_additive]\ntheorem fromLeftInv_eq_iff (a : S.leftInv) (b : M) :\n    (S.fromLeftInv a : M) = b ↔ (a : M) * b = 1 := by\n  rw [← IsUnit.mul_right_inj (leftInv_le_isUnit _ a.prop), S.mul_fromLeftInv, eq_comm]\n\n"}
{"name":"AddSubmonoid.fromCommLeftNeg_apply","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\na✝ : Subtype fun x => Membership.mem S.leftNeg x\n⊢ Eq (S.fromCommLeftNeg a✝) (S.fromLeftNeg a✝)","decl":"/-- The `MonoidHom` from `S.leftInv` to `S` sending an element to its right inverse in `S`. -/\n@[to_additive (attr := simps)\n    \"The `AddMonoidHom` from `S.leftNeg` to `S` sending an element to its\n    right additive inverse in `S`.\"]\nnoncomputable def fromCommLeftInv : S.leftInv →* S where\n  toFun := S.fromLeftInv\n  map_one' := S.fromLeftInv_one\n  map_mul' x y :=\n    Subtype.ext <| by\n      rw [fromLeftInv_eq_iff, mul_comm x, Submonoid.coe_mul, Submonoid.coe_mul, mul_assoc, ←\n        mul_assoc (x : M), mul_fromLeftInv, one_mul, mul_fromLeftInv]\n\n"}
{"name":"Submonoid.fromCommLeftInv_apply","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\na✝ : Subtype fun x => Membership.mem S.leftInv x\n⊢ Eq (S.fromCommLeftInv a✝) (S.fromLeftInv a✝)","decl":"/-- The `MonoidHom` from `S.leftInv` to `S` sending an element to its right inverse in `S`. -/\n@[to_additive (attr := simps)\n    \"The `AddMonoidHom` from `S.leftNeg` to `S` sending an element to its\n    right additive inverse in `S`.\"]\nnoncomputable def fromCommLeftInv : S.leftInv →* S where\n  toFun := S.fromLeftInv\n  map_one' := S.fromLeftInv_one\n  map_mul' x y :=\n    Subtype.ext <| by\n      rw [fromLeftInv_eq_iff, mul_comm x, Submonoid.coe_mul, Submonoid.coe_mul, mul_assoc, ←\n        mul_assoc (x : M), mul_fromLeftInv, one_mul, mul_fromLeftInv]\n\n"}
{"name":"Submonoid.leftInvEquiv_apply","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nhS : LE.le S (IsUnit.submonoid M)\na✝ : Subtype fun x => Membership.mem S.leftInv x\n⊢ Eq ((S.leftInvEquiv hS) a✝) ((↑S.fromCommLeftInv).toFun a✝)","decl":"/-- The submonoid of pointwise inverse of `S` is `MulEquiv` to `S`. -/\n@[to_additive (attr := simps apply) \"The additive submonoid of pointwise additive inverse of `S` is\n`AddEquiv` to `S`.\"]\nnoncomputable def leftInvEquiv : S.leftInv ≃* S :=\n  { S.fromCommLeftInv with\n    invFun := fun x ↦ ⟨↑(hS x.2).unit⁻¹, x, by simp⟩\n    left_inv := by\n      intro x\n      ext\n      simp [← Units.mul_eq_one_iff_inv_eq]\n    right_inv := by\n      rintro ⟨x, hx⟩\n      ext\n      simp [fromLeftInv_eq_iff] }\n\n"}
{"name":"AddSubmonoid.leftNegEquiv_apply","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nhS : LE.le S (IsAddUnit.addSubmonoid M)\na✝ : Subtype fun x => Membership.mem S.leftNeg x\n⊢ Eq ((S.leftNegEquiv hS) a✝) ((↑S.fromCommLeftNeg).toFun a✝)","decl":"/-- The submonoid of pointwise inverse of `S` is `MulEquiv` to `S`. -/\n@[to_additive (attr := simps apply) \"The additive submonoid of pointwise additive inverse of `S` is\n`AddEquiv` to `S`.\"]\nnoncomputable def leftInvEquiv : S.leftInv ≃* S :=\n  { S.fromCommLeftInv with\n    invFun := fun x ↦ ⟨↑(hS x.2).unit⁻¹, x, by simp⟩\n    left_inv := by\n      intro x\n      ext\n      simp [← Units.mul_eq_one_iff_inv_eq]\n    right_inv := by\n      rintro ⟨x, hx⟩\n      ext\n      simp [fromLeftInv_eq_iff] }\n\n"}
{"name":"AddSubmonoid.fromLeftNeg_leftNegEquiv_symm","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nhS : LE.le S (IsAddUnit.addSubmonoid M)\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (S.fromLeftNeg ((S.leftNegEquiv hS).symm x)) x","decl":"@[to_additive (attr := simp)]\ntheorem fromLeftInv_leftInvEquiv_symm (x : S) : S.fromLeftInv ((S.leftInvEquiv hS).symm x) = x :=\n  (S.leftInvEquiv hS).right_inv x\n\n"}
{"name":"Submonoid.fromLeftInv_leftInvEquiv_symm","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nhS : LE.le S (IsUnit.submonoid M)\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (S.fromLeftInv ((S.leftInvEquiv hS).symm x)) x","decl":"@[to_additive (attr := simp)]\ntheorem fromLeftInv_leftInvEquiv_symm (x : S) : S.fromLeftInv ((S.leftInvEquiv hS).symm x) = x :=\n  (S.leftInvEquiv hS).right_inv x\n\n"}
{"name":"AddSubmonoid.leftNegEquiv_symm_fromLeftNeg","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nhS : LE.le S (IsAddUnit.addSubmonoid M)\nx : Subtype fun x => Membership.mem S.leftNeg x\n⊢ Eq ((S.leftNegEquiv hS).symm (S.fromLeftNeg x)) x","decl":"@[to_additive (attr := simp)]\ntheorem leftInvEquiv_symm_fromLeftInv (x : S.leftInv) :\n    (S.leftInvEquiv hS).symm (S.fromLeftInv x) = x :=\n  (S.leftInvEquiv hS).left_inv x\n\n"}
{"name":"Submonoid.leftInvEquiv_symm_fromLeftInv","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nhS : LE.le S (IsUnit.submonoid M)\nx : Subtype fun x => Membership.mem S.leftInv x\n⊢ Eq ((S.leftInvEquiv hS).symm (S.fromLeftInv x)) x","decl":"@[to_additive (attr := simp)]\ntheorem leftInvEquiv_symm_fromLeftInv (x : S.leftInv) :\n    (S.leftInvEquiv hS).symm (S.fromLeftInv x) = x :=\n  (S.leftInvEquiv hS).left_inv x\n\n"}
{"name":"Submonoid.leftInvEquiv_mul","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nhS : LE.le S (IsUnit.submonoid M)\nx : Subtype fun x => Membership.mem S.leftInv x\n⊢ Eq (HMul.hMul ↑((S.leftInvEquiv hS) x) ↑x) 1","decl":"@[to_additive]\ntheorem leftInvEquiv_mul (x : S.leftInv) : (S.leftInvEquiv hS x : M) * x = 1 := by\n  simpa only [leftInvEquiv_apply, fromCommLeftInv] using fromLeftInv_mul S x\n\n"}
{"name":"AddSubmonoid.leftNegEquiv_add","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nhS : LE.le S (IsAddUnit.addSubmonoid M)\nx : Subtype fun x => Membership.mem S.leftNeg x\n⊢ Eq (HAdd.hAdd ↑((S.leftNegEquiv hS) x) ↑x) 0","decl":"@[to_additive]\ntheorem leftInvEquiv_mul (x : S.leftInv) : (S.leftInvEquiv hS x : M) * x = 1 := by\n  simpa only [leftInvEquiv_apply, fromCommLeftInv] using fromLeftInv_mul S x\n\n"}
{"name":"AddSubmonoid.add_leftNegEquiv","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nhS : LE.le S (IsAddUnit.addSubmonoid M)\nx : Subtype fun x => Membership.mem S.leftNeg x\n⊢ Eq (HAdd.hAdd ↑x ↑((S.leftNegEquiv hS) x)) 0","decl":"@[to_additive]\ntheorem mul_leftInvEquiv (x : S.leftInv) : (x : M) * S.leftInvEquiv hS x = 1 := by\n  simp only [leftInvEquiv_apply, fromCommLeftInv, mul_fromLeftInv]\n\n"}
{"name":"Submonoid.mul_leftInvEquiv","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nhS : LE.le S (IsUnit.submonoid M)\nx : Subtype fun x => Membership.mem S.leftInv x\n⊢ Eq (HMul.hMul ↑x ↑((S.leftInvEquiv hS) x)) 1","decl":"@[to_additive]\ntheorem mul_leftInvEquiv (x : S.leftInv) : (x : M) * S.leftInvEquiv hS x = 1 := by\n  simp only [leftInvEquiv_apply, fromCommLeftInv, mul_fromLeftInv]\n\n"}
{"name":"AddSubmonoid.leftNegEquiv_symm_add","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nhS : LE.le S (IsAddUnit.addSubmonoid M)\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd ↑((S.leftNegEquiv hS).symm x) ↑x) 0","decl":"@[to_additive (attr := simp)]\ntheorem leftInvEquiv_symm_mul (x : S) : ((S.leftInvEquiv hS).symm x : M) * x = 1 := by\n  convert S.mul_leftInvEquiv hS ((S.leftInvEquiv hS).symm x)\n  simp\n\n"}
{"name":"Submonoid.leftInvEquiv_symm_mul","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nhS : LE.le S (IsUnit.submonoid M)\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul ↑((S.leftInvEquiv hS).symm x) ↑x) 1","decl":"@[to_additive (attr := simp)]\ntheorem leftInvEquiv_symm_mul (x : S) : ((S.leftInvEquiv hS).symm x : M) * x = 1 := by\n  convert S.mul_leftInvEquiv hS ((S.leftInvEquiv hS).symm x)\n  simp\n\n"}
{"name":"AddSubmonoid.add_leftNegEquiv_symm","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nS : AddSubmonoid M\nhS : LE.le S (IsAddUnit.addSubmonoid M)\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd ↑x ↑((S.leftNegEquiv hS).symm x)) 0","decl":"@[to_additive (attr := simp)]\ntheorem mul_leftInvEquiv_symm (x : S) : (x : M) * (S.leftInvEquiv hS).symm x = 1 := by\n  convert S.leftInvEquiv_mul hS ((S.leftInvEquiv hS).symm x)\n  simp\n\n"}
{"name":"Submonoid.mul_leftInvEquiv_symm","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nS : Submonoid M\nhS : LE.le S (IsUnit.submonoid M)\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul ↑x ↑((S.leftInvEquiv hS).symm x)) 1","decl":"@[to_additive (attr := simp)]\ntheorem mul_leftInvEquiv_symm (x : S) : (x : M) * (S.leftInvEquiv hS).symm x = 1 := by\n  convert S.leftInvEquiv_mul hS ((S.leftInvEquiv hS).symm x)\n  simp\n\n"}
{"name":"Submonoid.leftInv_eq_inv","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : Group M\nS : Submonoid M\n⊢ Eq S.leftInv (Inv.inv S)","decl":"@[to_additive]\ntheorem leftInv_eq_inv : S.leftInv = S⁻¹ :=\n  Submonoid.ext fun _ ↦\n    ⟨fun h ↦ Submonoid.mem_inv.mpr ((inv_eq_of_mul_eq_one_right h.choose_spec).symm ▸\n      h.choose.prop),\n      fun h ↦ ⟨⟨_, h⟩, mul_inv_cancel _⟩⟩\n\n"}
{"name":"AddSubmonoid.leftNeg_eq_neg","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddGroup M\nS : AddSubmonoid M\n⊢ Eq S.leftNeg (Neg.neg S)","decl":"@[to_additive]\ntheorem leftInv_eq_inv : S.leftInv = S⁻¹ :=\n  Submonoid.ext fun _ ↦\n    ⟨fun h ↦ Submonoid.mem_inv.mpr ((inv_eq_of_mul_eq_one_right h.choose_spec).symm ▸\n      h.choose.prop),\n      fun h ↦ ⟨⟨_, h⟩, mul_inv_cancel _⟩⟩\n\n"}
{"name":"Submonoid.fromLeftInv_eq_inv","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : Group M\nS : Submonoid M\nx : Subtype fun x => Membership.mem S.leftInv x\n⊢ Eq (↑(S.fromLeftInv x)) (Inv.inv ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem fromLeftInv_eq_inv (x : S.leftInv) : (S.fromLeftInv x : M) = (x : M)⁻¹ := by\n  rw [← mul_right_inj (x : M), mul_inv_cancel, mul_fromLeftInv]\n\n"}
{"name":"AddSubmonoid.fromLeftNeg_eq_neg","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddGroup M\nS : AddSubmonoid M\nx : Subtype fun x => Membership.mem S.leftNeg x\n⊢ Eq (↑(S.fromLeftNeg x)) (Neg.neg ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem fromLeftInv_eq_inv (x : S.leftInv) : (S.fromLeftInv x : M) = (x : M)⁻¹ := by\n  rw [← mul_right_inj (x : M), mul_inv_cancel, mul_fromLeftInv]\n\n"}
{"name":"AddSubmonoid.leftNegEquiv_symm_eq_neg","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : AddCommGroup M\nS : AddSubmonoid M\nhS : LE.le S (IsAddUnit.addSubmonoid M)\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((S.leftNegEquiv hS).symm x)) (Neg.neg ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem leftInvEquiv_symm_eq_inv (x : S) : ((S.leftInvEquiv hS).symm x : M) = (x : M)⁻¹ := by\n  rw [← mul_right_inj (x : M), mul_inv_cancel, mul_leftInvEquiv_symm]\n\n"}
{"name":"Submonoid.leftInvEquiv_symm_eq_inv","module":"Mathlib.GroupTheory.Submonoid.Inverses","initialProofState":"M : Type u_1\ninst✝ : CommGroup M\nS : Submonoid M\nhS : LE.le S (IsUnit.submonoid M)\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((S.leftInvEquiv hS).symm x)) (Inv.inv ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem leftInvEquiv_symm_eq_inv (x : S) : ((S.leftInvEquiv hS).symm x : M) = (x : M)⁻¹ := by\n  rw [← mul_right_inj (x : M), mul_inv_cancel, mul_leftInvEquiv_symm]\n\n"}
