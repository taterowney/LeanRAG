{"name":"NonUnitalStarRingHom.mk.injEq","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\ntoNonUnitalRingHom✝ : NonUnitalRingHom A B\nmap_star'✝ : ∀ (a : A), Eq (toNonUnitalRingHom✝.toFun (Star.star a)) (Star.star (toNonUnitalRingHom✝.toFun a))\ntoNonUnitalRingHom : NonUnitalRingHom A B\nmap_star' : ∀ (a : A), Eq (toNonUnitalRingHom.toFun (Star.star a)) (Star.star (toNonUnitalRingHom.toFun a))\n⊢ Eq (Eq { toNonUnitalRingHom := toNonUnitalRingHom✝, map_star' := map_star'✝ } { toNonUnitalRingHom := toNonUnitalRingHom, map_star' := map_star' }) (Eq toNonUnitalRingHom✝ toNonUnitalRingHom)","decl":"/-- A *non-unital ⋆-ring homomorphism* is a non-unital ring homomorphism between non-unital\nnon-associative semirings `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. -/\nstructure NonUnitalStarRingHom (A B : Type*) [NonUnitalNonAssocSemiring A]\n    [Star A] [NonUnitalNonAssocSemiring B] [Star B] extends A →ₙ+* B where\n  /-- By definition, a non-unital ⋆-ring homomorphism preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"NonUnitalStarRingHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : Star A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : Star B\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoNonUnitalRingHom : NonUnitalRingHom A B\nmap_star' : ∀ (a : A), Eq (toNonUnitalRingHom.toFun (Star.star a)) (Star.star (toNonUnitalRingHom.toFun a))\n⊢ Eq (SizeOf.sizeOf { toNonUnitalRingHom := toNonUnitalRingHom, map_star' := map_star' }) (HAdd.hAdd 1 (SizeOf.sizeOf toNonUnitalRingHom))","decl":"/-- A *non-unital ⋆-ring homomorphism* is a non-unital ring homomorphism between non-unital\nnon-associative semirings `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. -/\nstructure NonUnitalStarRingHom (A B : Type*) [NonUnitalNonAssocSemiring A]\n    [Star A] [NonUnitalNonAssocSemiring B] [Star B] extends A →ₙ+* B where\n  /-- By definition, a non-unital ⋆-ring homomorphism preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"NonUnitalStarRingHom.mk.inj","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\ntoNonUnitalRingHom✝ : NonUnitalRingHom A B\nmap_star'✝ : ∀ (a : A), Eq (toNonUnitalRingHom✝.toFun (Star.star a)) (Star.star (toNonUnitalRingHom✝.toFun a))\ntoNonUnitalRingHom : NonUnitalRingHom A B\nmap_star' : ∀ (a : A), Eq (toNonUnitalRingHom.toFun (Star.star a)) (Star.star (toNonUnitalRingHom.toFun a))\nx✝ : Eq { toNonUnitalRingHom := toNonUnitalRingHom✝, map_star' := map_star'✝ } { toNonUnitalRingHom := toNonUnitalRingHom, map_star' := map_star' }\n⊢ Eq toNonUnitalRingHom✝ toNonUnitalRingHom","decl":"/-- A *non-unital ⋆-ring homomorphism* is a non-unital ring homomorphism between non-unital\nnon-associative semirings `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. -/\nstructure NonUnitalStarRingHom (A B : Type*) [NonUnitalNonAssocSemiring A]\n    [Star A] [NonUnitalNonAssocSemiring B] [Star B] extends A →ₙ+* B where\n  /-- By definition, a non-unital ⋆-ring homomorphism preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"NonUnitalStarRingHom.map_star'","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nself : NonUnitalStarRingHom A B\na : A\n⊢ Eq (self.toFun (Star.star a)) (Star.star (self.toFun a))","decl":"/-- A *non-unital ⋆-ring homomorphism* is a non-unital ring homomorphism between non-unital\nnon-associative semirings `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. -/\nstructure NonUnitalStarRingHom (A B : Type*) [NonUnitalNonAssocSemiring A]\n    [Star A] [NonUnitalNonAssocSemiring B] [Star B] extends A →ₙ+* B where\n  /-- By definition, a non-unital ⋆-ring homomorphism preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"NonUnitalStarRingHomClass.toStarHomClass","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"F : Type u_1\nA : outParam (Type u_2)\nB : outParam (Type u_3)\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : Star A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : Star B\ninst✝¹ : FunLike F A B\ninst✝ : NonUnitalRingHomClass F A B\nself : NonUnitalStarRingHomClass F A B\n⊢ StarHomClass F A B","decl":"/-- `NonUnitalStarRingHomClass F A B` states that `F` is a type of non-unital ⋆-ring homomorphisms.\nYou should also extend this typeclass when you extend `NonUnitalStarRingHom`. -/\nclass NonUnitalStarRingHomClass (F : Type*) (A B : outParam Type*)\n    [NonUnitalNonAssocSemiring A] [Star A] [NonUnitalNonAssocSemiring B] [Star B]\n    [FunLike F A B] [NonUnitalRingHomClass F A B] extends StarHomClass F A B : Prop\n\n"}
{"name":"NonUnitalStarRingHom.instNonUnitalRingHomClass","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\n⊢ NonUnitalRingHomClass (NonUnitalStarRingHom A B) A B","decl":"instance : NonUnitalRingHomClass (A →⋆ₙ+* B) A B where\n  map_mul f := f.map_mul'\n  map_add f := f.map_add'\n  map_zero f := f.map_zero'\n\n"}
{"name":"NonUnitalStarRingHom.instNonUnitalStarRingHomClass","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\n⊢ NonUnitalStarRingHomClass (NonUnitalStarRingHom A B) A B","decl":"instance : NonUnitalStarRingHomClass (A →⋆ₙ+* B) A B where\n  map_star f := f.map_star'\n\n"}
{"name":"NonUnitalStarRingHom.coe_coe","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁶ : NonUnitalNonAssocSemiring A\ninst✝⁵ : Star A\ninst✝⁴ : NonUnitalNonAssocSemiring B\ninst✝³ : Star B\nF : Type u_5\ninst✝² : FunLike F A B\ninst✝¹ : NonUnitalRingHomClass F A B\ninst✝ : NonUnitalStarRingHomClass F A B\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\nprotected theorem coe_coe {F : Type*} [FunLike F A B] [NonUnitalRingHomClass F A B]\n    [NonUnitalStarRingHomClass F A B] (f : F) : ⇑(f : A →⋆ₙ+* B) = f :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.coe_toNonUnitalRingHom","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nf : NonUnitalStarRingHom A B\n⊢ Eq ⇑f.toNonUnitalRingHom ⇑f","decl":"@[simp]\ntheorem coe_toNonUnitalRingHom (f : A →⋆ₙ+* B) : ⇑f.toNonUnitalRingHom = f :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.ext","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nf g : NonUnitalStarRingHom A B\nh : ∀ (x : A), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : A →⋆ₙ+* B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"NonUnitalStarRingHom.ext_iff","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nf g : NonUnitalStarRingHom A B\n⊢ Iff (Eq f g) (∀ (x : A), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : A →⋆ₙ+* B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"NonUnitalStarRingHom.coe_copy","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nf : NonUnitalStarRingHom A B\nf' : A → B\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : A →⋆ₙ+* B) (f' : A → B) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.copy_eq","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nf : NonUnitalStarRingHom A B\nf' : A → B\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : A →⋆ₙ+* B) (f' : A → B) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"NonUnitalStarRingHom.coe_mk","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nf : NonUnitalRingHom A B\nh : ∀ (a : A), Eq (f.toFun (Star.star a)) (Star.star (f.toFun a))\n⊢ Eq ⇑{ toNonUnitalRingHom := f, map_star' := h } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : A →ₙ+* B) (h) :\n    ((⟨f, h⟩ : A  →⋆ₙ+* B) : A → B) = f :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.mk_coe","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nf : NonUnitalStarRingHom A B\nh₁ : ∀ (x y : A), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nh₂ : Eq ({ toFun := ⇑f, map_mul' := h₁ }.toFun 0) 0\nh₃ : ∀ (x y : A), Eq ({ toFun := ⇑f, map_mul' := h₁ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑f, map_mul' := h₁ }.toFun x) ({ toFun := ⇑f, map_mul' := h₁ }.toFun y))\nh₄ : ∀ (a : A), Eq ({ toFun := ⇑f, map_mul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun (Star.star a)) (Star.star ({ toFun := ⇑f, map_mul' := h₁, map_zero' := h₂, map_add' := h₃ }.toFun a))\n⊢ Eq { toFun := ⇑f, map_mul' := h₁, map_zero' := h₂, map_add' := h₃, map_star' := h₄ } f","decl":"@[simp]\ntheorem mk_coe (f : A →⋆ₙ+* B) (h₁ h₂ h₃ h₄) :\n    (⟨⟨⟨f, h₁⟩, h₂, h₃⟩, h₄⟩ : A →⋆ₙ+* B) = f := by\n  ext\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.coe_id","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : Star A\n⊢ Eq (⇑(NonUnitalStarRingHom.id A)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(NonUnitalStarRingHom.id A) = id :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.coe_comp","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : Star A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : Star B\ninst✝¹ : NonUnitalNonAssocSemiring C\ninst✝ : Star C\nf : NonUnitalStarRingHom B C\ng : NonUnitalStarRingHom A B\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : B →⋆ₙ+* C) (g : A →⋆ₙ+* B) : ⇑(comp f g) = f ∘ g :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.comp_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝⁵ : NonUnitalNonAssocSemiring A\ninst✝⁴ : Star A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : Star B\ninst✝¹ : NonUnitalNonAssocSemiring C\ninst✝ : Star C\nf : NonUnitalStarRingHom B C\ng : NonUnitalStarRingHom A B\na : A\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : B →⋆ₙ+* C) (g : A →⋆ₙ+* B) (a : A) : comp f g a = f (g a) :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.comp_assoc","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\nD : Type u_4\ninst✝⁷ : NonUnitalNonAssocSemiring A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : Star B\ninst✝³ : NonUnitalNonAssocSemiring C\ninst✝² : Star C\ninst✝¹ : NonUnitalNonAssocSemiring D\ninst✝ : Star D\nf : NonUnitalStarRingHom C D\ng : NonUnitalStarRingHom B C\nh : NonUnitalStarRingHom A B\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : C →⋆ₙ+* D) (g : B →⋆ₙ+* C) (h : A →⋆ₙ+* B) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.id_comp","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nf : NonUnitalStarRingHom A B\n⊢ Eq ((NonUnitalStarRingHom.id B).comp f) f","decl":"@[simp]\ntheorem id_comp (f : A →⋆ₙ+* B) : (NonUnitalStarRingHom.id _).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"NonUnitalStarRingHom.comp_id","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Star A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : Star B\nf : NonUnitalStarRingHom A B\n⊢ Eq (f.comp (NonUnitalStarRingHom.id A)) f","decl":"@[simp]\ntheorem comp_id (f : A →⋆ₙ+* B) : f.comp (NonUnitalStarRingHom.id _) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"NonUnitalStarRingHom.coe_one","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : Star A\n⊢ Eq (⇑1) id","decl":"@[simp]\ntheorem coe_one : ((1 : A →⋆ₙ+* A) : A → A) = id :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.one_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : Star A\na : A\n⊢ Eq (1 a) a","decl":"theorem one_apply (a : A) : (1 : A →⋆ₙ+* A) a = a :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.coe_zero","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : StarAddMonoid A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : StarAddMonoid B\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ((0 : A →⋆ₙ+* B) : A → B) = 0 :=\n  rfl\n\n"}
{"name":"NonUnitalStarRingHom.zero_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : StarAddMonoid A\ninst✝¹ : NonUnitalNonAssocSemiring B\ninst✝ : StarAddMonoid B\na : A\n⊢ Eq (0 a) 0","decl":"theorem zero_apply (a : A) : (0 : A →⋆ₙ+* B) a = 0 :=\n  rfl\n\n"}
{"name":"StarRingEquiv.mk.injEq","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ntoRingEquiv✝ : RingEquiv A B\nmap_star'✝ : ∀ (a : A), Eq (toRingEquiv✝.toFun (Star.star a)) (Star.star (toRingEquiv✝.toFun a))\ntoRingEquiv : RingEquiv A B\nmap_star' : ∀ (a : A), Eq (toRingEquiv.toFun (Star.star a)) (Star.star (toRingEquiv.toFun a))\n⊢ Eq (Eq { toRingEquiv := toRingEquiv✝, map_star' := map_star'✝ } { toRingEquiv := toRingEquiv, map_star' := map_star' }) (Eq toRingEquiv✝ toRingEquiv)","decl":"/-- A *⋆-ring* equivalence is an equivalence preserving addition, multiplication, and the star\noperation, which allows for considering both unital and non-unital equivalences with a single\nstructure. -/\nstructure StarRingEquiv (A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [Star A] [Star B]\n    extends A ≃+* B where\n  /-- By definition, a ⋆-ring equivalence preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"StarRingEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁷ : Add A\ninst✝⁶ : Add B\ninst✝⁵ : Mul A\ninst✝⁴ : Mul B\ninst✝³ : Star A\ninst✝² : Star B\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoRingEquiv : RingEquiv A B\nmap_star' : ∀ (a : A), Eq (toRingEquiv.toFun (Star.star a)) (Star.star (toRingEquiv.toFun a))\n⊢ Eq (SizeOf.sizeOf { toRingEquiv := toRingEquiv, map_star' := map_star' }) (HAdd.hAdd 1 (SizeOf.sizeOf toRingEquiv))","decl":"/-- A *⋆-ring* equivalence is an equivalence preserving addition, multiplication, and the star\noperation, which allows for considering both unital and non-unital equivalences with a single\nstructure. -/\nstructure StarRingEquiv (A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [Star A] [Star B]\n    extends A ≃+* B where\n  /-- By definition, a ⋆-ring equivalence preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"StarRingEquiv.mk.inj","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ntoRingEquiv✝ : RingEquiv A B\nmap_star'✝ : ∀ (a : A), Eq (toRingEquiv✝.toFun (Star.star a)) (Star.star (toRingEquiv✝.toFun a))\ntoRingEquiv : RingEquiv A B\nmap_star' : ∀ (a : A), Eq (toRingEquiv.toFun (Star.star a)) (Star.star (toRingEquiv.toFun a))\nx✝ : Eq { toRingEquiv := toRingEquiv✝, map_star' := map_star'✝ } { toRingEquiv := toRingEquiv, map_star' := map_star' }\n⊢ Eq toRingEquiv✝ toRingEquiv","decl":"/-- A *⋆-ring* equivalence is an equivalence preserving addition, multiplication, and the star\noperation, which allows for considering both unital and non-unital equivalences with a single\nstructure. -/\nstructure StarRingEquiv (A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [Star A] [Star B]\n    extends A ≃+* B where\n  /-- By definition, a ⋆-ring equivalence preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"StarRingEquiv.map_star'","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\nself : StarRingEquiv A B\na : A\n⊢ Eq (self.toFun (Star.star a)) (Star.star (self.toFun a))","decl":"/-- A *⋆-ring* equivalence is an equivalence preserving addition, multiplication, and the star\noperation, which allows for considering both unital and non-unital equivalences with a single\nstructure. -/\nstructure StarRingEquiv (A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [Star A] [Star B]\n    extends A ≃+* B where\n  /-- By definition, a ⋆-ring equivalence preserves the `star` operation. -/\n  map_star' : ∀ a : A, toFun (star a) = star (toFun a)\n\n"}
{"name":"StarRingEquivClass.map_star","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"F : Type u_1\nA : outParam (Type u_2)\nB : outParam (Type u_3)\ninst✝⁶ : Add A\ninst✝⁵ : Mul A\ninst✝⁴ : Star A\ninst✝³ : Add B\ninst✝² : Mul B\ninst✝¹ : Star B\ninst✝ : EquivLike F A B\nself : StarRingEquivClass F A B\nf : F\na : A\n⊢ Eq (f (Star.star a)) (Star.star (f a))","decl":"/-- `StarRingEquivClass F A B` asserts `F` is a type of bundled ⋆-ring equivalences between `A` and\n`B`.\nYou should also extend this typeclass when you extend `StarRingEquiv`. -/\nclass StarRingEquivClass (F : Type*) (A B : outParam Type*)\n    [Add A] [Mul A] [Star A] [Add B] [Mul B] [Star B] [EquivLike F A B]\n    extends RingEquivClass F A B : Prop where\n  /-- By definition, a ⋆-ring equivalence preserves the `star` operation. -/\n  map_star : ∀ (f : F) (a : A), f (star a) = star (f a)\n\n"}
{"name":"StarRingEquivClass.toRingEquivClass","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"F : Type u_1\nA : outParam (Type u_2)\nB : outParam (Type u_3)\ninst✝⁶ : Add A\ninst✝⁵ : Mul A\ninst✝⁴ : Star A\ninst✝³ : Add B\ninst✝² : Mul B\ninst✝¹ : Star B\ninst✝ : EquivLike F A B\nself : StarRingEquivClass F A B\n⊢ RingEquivClass F A B","decl":"/-- `StarRingEquivClass F A B` asserts `F` is a type of bundled ⋆-ring equivalences between `A` and\n`B`.\nYou should also extend this typeclass when you extend `StarRingEquiv`. -/\nclass StarRingEquivClass (F : Type*) (A B : outParam Type*)\n    [Add A] [Mul A] [Star A] [Add B] [Mul B] [Star B] [EquivLike F A B]\n    extends RingEquivClass F A B : Prop where\n  /-- By definition, a ⋆-ring equivalence preserves the `star` operation. -/\n  map_star : ∀ (f : F) (a : A), f (star a) = star (f a)\n\n"}
{"name":"StarRingEquivClass.instStarHomClass","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : Add A\ninst✝⁵ : Mul A\ninst✝⁴ : Star A\ninst✝³ : Add B\ninst✝² : Mul B\ninst✝¹ : Star B\ninst✝ : EquivLike F A B\nhF : StarRingEquivClass F A B\n⊢ StarHomClass F A B","decl":"instance (priority := 50) {F A B : Type*} [Add A] [Mul A] [Star A] [Add B] [Mul B] [Star B]\n    [EquivLike F A B] [hF : StarRingEquivClass F A B] :\n    StarHomClass F A B :=\n  { hF with }\n\n-- See note [lower instance priority]\n"}
{"name":"StarRingEquivClass.instNonUnitalStarRingHomClass","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : NonUnitalNonAssocSemiring A\ninst✝⁵ : Star A\ninst✝⁴ : NonUnitalNonAssocSemiring B\ninst✝³ : Star B\ninst✝² : EquivLike F A B\ninst✝¹ : RingEquivClass F A B\ninst✝ : StarRingEquivClass F A B\n⊢ NonUnitalStarRingHomClass F A B","decl":"instance (priority := 100) {F A B : Type*} [NonUnitalNonAssocSemiring A] [Star A]\n    [NonUnitalNonAssocSemiring B] [Star B] [EquivLike F A B] [RingEquivClass F A B]\n    [StarRingEquivClass F A B] : NonUnitalStarRingHomClass F A B :=\n  { }\n\n"}
{"name":"StarRingEquiv.instRingEquivClass","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\n⊢ RingEquivClass (StarRingEquiv A B) A B","decl":"instance : RingEquivClass (A ≃⋆+* B) A B where\n  map_mul f := f.map_mul'\n  map_add f := f.map_add'\n\n"}
{"name":"StarRingEquiv.instStarRingEquivClass","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\n⊢ StarRingEquivClass (StarRingEquiv A B) A B","decl":"instance : StarRingEquivClass (A ≃⋆+* B) A B where\n  map_star := map_star'\n\n"}
{"name":"StarRingEquiv.toRingEquiv_eq_coe","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarRingEquiv A B\n⊢ Eq e.toRingEquiv ↑e","decl":"@[simp]\ntheorem toRingEquiv_eq_coe (e : A ≃⋆+* B) : e.toRingEquiv = e :=\n  rfl\n\n"}
{"name":"StarRingEquiv.ext","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\nf g : StarRingEquiv A B\nh : ∀ (a : A), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : A ≃⋆+* B} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"StarRingEquiv.ext_iff","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\nf g : StarRingEquiv A B\n⊢ Iff (Eq f g) (∀ (a : A), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : A ≃⋆+* B} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"StarRingEquiv.coe_refl","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\ninst✝² : Add A\ninst✝¹ : Mul A\ninst✝ : Star A\n⊢ Eq (⇑StarRingEquiv.refl) id","decl":"@[simp]\ntheorem coe_refl : ⇑(refl : A ≃⋆+* A) = id :=\n  rfl\n\n"}
{"name":"StarRingEquiv.invFun_eq_symm","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarRingEquiv A B\n⊢ Eq (EquivLike.inv e) ⇑e.symm","decl":"@[simp]\ntheorem invFun_eq_symm {e : A ≃⋆+* B} : EquivLike.inv e = e.symm :=\n  rfl\n\n"}
{"name":"StarRingEquiv.symm_symm","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarRingEquiv A B\n⊢ Eq e.symm.symm e","decl":"@[simp]\ntheorem symm_symm (e : A ≃⋆+* B) : e.symm.symm = e := rfl\n\n"}
{"name":"StarRingEquiv.symm_bijective","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\n⊢ Function.Bijective StarRingEquiv.symm","decl":"theorem symm_bijective : Function.Bijective (symm : (A ≃⋆+* B) → B ≃⋆+* A) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"StarRingEquiv.coe_mk","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ne : RingEquiv A B\nh₁ : ∀ (a : A), Eq (e.toFun (Star.star a)) (Star.star (e.toFun a))\n⊢ Eq ⇑{ toRingEquiv := e, map_star' := h₁ } ⇑e","decl":"theorem coe_mk (e h₁) : ⇑(⟨e, h₁⟩ : A ≃⋆+* B) = e := rfl\n\n"}
{"name":"StarRingEquiv.mk_coe","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarRingEquiv A B\ne' : B → A\nh₁ : Function.LeftInverse e' ⇑e\nh₂ : Function.RightInverse e' ⇑e\nh₃ : ∀ (x y : A), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂ }.toFun y))\nh₅ : ∀ (a : A), Eq ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun (Star.star a)) (Star.star ({ toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun a))\n⊢ Eq { toFun := ⇑e, invFun := e', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄, map_star' := h₅ } e","decl":"@[simp]\ntheorem mk_coe (e : A ≃⋆+* B) (e' h₁ h₂ h₃ h₄ h₅) :\n    (⟨⟨⟨e, e', h₁, h₂⟩, h₃, h₄⟩, h₅⟩ : A ≃⋆+* B) = e := ext fun _ => rfl\n\n"}
{"name":"StarRingEquiv.symm_mk","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\nf : A → B\nf' : B → A\nh₁ : Function.LeftInverse f' f\nh₂ : Function.RightInverse f' f\nh₃ : ∀ (x y : A), Eq ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun (HMul.hMul x y)) (HMul.hMul ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun y))\nh₄ : ∀ (x y : A), Eq ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun (HAdd.hAdd x y)) (HAdd.hAdd ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun x) ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂ }.toFun y))\nh₅ : ∀ (a : A), Eq ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun (Star.star a)) (Star.star ({ toFun := f, invFun := f', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄ }.toFun a))\n⊢ Eq { toFun := f, invFun := f', left_inv := h₁, right_inv := h₂, map_mul' := h₃, map_add' := h₄, map_star' := h₅ }.symm\n    (let __src := StarRingEquiv.symm_mk.aux f f' h₁ h₂ h₃ h₄ h₅;\n    { toFun := f', invFun := f, left_inv := ⋯, right_inv := ⋯, map_mul' := ⋯, map_add' := ⋯, map_star' := ⋯ })","decl":"@[simp]\ntheorem symm_mk (f f') (h₁ h₂ h₃ h₄ h₅) :\n    (⟨⟨⟨f, f', h₁, h₂⟩, h₃, h₄⟩, h₅⟩ : A ≃⋆+* B).symm =\n      { symm_mk.aux f f' h₁ h₂ h₃ h₄ h₅ with\n        toFun := f'\n        invFun := f } :=\n  rfl\n\n"}
{"name":"StarRingEquiv.refl_symm","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\ninst✝² : Add A\ninst✝¹ : Mul A\ninst✝ : Star A\n⊢ Eq StarRingEquiv.refl.symm StarRingEquiv.refl","decl":"@[simp]\ntheorem refl_symm : (StarRingEquiv.refl : A ≃⋆+* A).symm = StarRingEquiv.refl :=\n  rfl\n\n"}
{"name":"StarRingEquiv.apply_symm_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarRingEquiv A B\nx : B\n⊢ Eq (e (e.symm x)) x","decl":"@[simp]\ntheorem apply_symm_apply (e : A ≃⋆+* B) : ∀ x, e (e.symm x) = x :=\n  e.toRingEquiv.apply_symm_apply\n\n"}
{"name":"StarRingEquiv.symm_apply_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarRingEquiv A B\nx : A\n⊢ Eq (e.symm (e x)) x","decl":"@[simp]\ntheorem symm_apply_apply (e : A ≃⋆+* B) : ∀ x, e.symm (e x) = x :=\n  e.toRingEquiv.symm_apply_apply\n\n"}
{"name":"StarRingEquiv.symm_trans_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝⁸ : Add A\ninst✝⁷ : Add B\ninst✝⁶ : Mul A\ninst✝⁵ : Mul B\ninst✝⁴ : Star A\ninst✝³ : Star B\ninst✝² : Add C\ninst✝¹ : Mul C\ninst✝ : Star C\ne₁ : StarRingEquiv A B\ne₂ : StarRingEquiv B C\nx : C\n⊢ Eq ((e₁.trans e₂).symm x) (e₁.symm (e₂.symm x))","decl":"@[simp]\ntheorem symm_trans_apply (e₁ : A ≃⋆+* B) (e₂ : B≃⋆+* C) (x : C) :\n    (e₁.trans e₂).symm x = e₁.symm (e₂.symm x) :=\n  rfl\n\n"}
{"name":"StarRingEquiv.coe_trans","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝⁸ : Add A\ninst✝⁷ : Add B\ninst✝⁶ : Mul A\ninst✝⁵ : Mul B\ninst✝⁴ : Star A\ninst✝³ : Star B\ninst✝² : Add C\ninst✝¹ : Mul C\ninst✝ : Star C\ne₁ : StarRingEquiv A B\ne₂ : StarRingEquiv B C\n⊢ Eq (⇑(e₁.trans e₂)) (Function.comp ⇑e₂ ⇑e₁)","decl":"@[simp]\ntheorem coe_trans (e₁ : A ≃⋆+* B) (e₂ : B ≃⋆+* C) : ⇑(e₁.trans e₂) = e₂ ∘ e₁ :=\n  rfl\n\n"}
{"name":"StarRingEquiv.trans_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝⁸ : Add A\ninst✝⁷ : Add B\ninst✝⁶ : Mul A\ninst✝⁵ : Mul B\ninst✝⁴ : Star A\ninst✝³ : Star B\ninst✝² : Add C\ninst✝¹ : Mul C\ninst✝ : Star C\ne₁ : StarRingEquiv A B\ne₂ : StarRingEquiv B C\nx : A\n⊢ Eq ((e₁.trans e₂) x) (e₂ (e₁ x))","decl":"@[simp]\ntheorem trans_apply (e₁ : A ≃⋆+* B) (e₂ : B ≃⋆+* C) (x : A) : (e₁.trans e₂) x = e₂ (e₁ x) :=\n  rfl\n\n"}
{"name":"StarRingEquiv.leftInverse_symm","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarRingEquiv A B\n⊢ Function.LeftInverse ⇑e.symm ⇑e","decl":"theorem leftInverse_symm (e : A ≃⋆+* B) : Function.LeftInverse e.symm e :=\n  e.left_inv\n\n"}
{"name":"StarRingEquiv.rightInverse_symm","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : Add A\ninst✝⁴ : Add B\ninst✝³ : Mul A\ninst✝² : Mul B\ninst✝¹ : Star A\ninst✝ : Star B\ne : StarRingEquiv A B\n⊢ Function.RightInverse ⇑e.symm ⇑e","decl":"theorem rightInverse_symm (e : A ≃⋆+* B) : Function.RightInverse e.symm e :=\n  e.right_inv\n\n"}
{"name":"StarRingEquiv.ofStarRingHom_symm_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"F : Type u_1\nG : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : NonUnitalNonAssocSemiring A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : Star B\ninst✝³ : FunLike F A B\ninst✝² : NonUnitalRingHomClass F A B\ninst✝¹ : NonUnitalStarRingHomClass F A B\ninst✝ : FunLike G B A\nf : F\ng : G\nh₁ : ∀ (x : A), Eq (g (f x)) x\nh₂ : ∀ (x : B), Eq (f (g x)) x\na : B\n⊢ Eq ((StarRingEquiv.ofStarRingHom f g h₁ h₂).symm a) (g a)","decl":"/-- If a (unital or non-unital) star ring morphism has an inverse, it is an isomorphism of\nstar rings. -/\n@[simps]\ndef ofStarRingHom (f : F) (g : G) (h₁ : ∀ x, g (f x) = x) (h₂ : ∀ x, f (g x) = x) : A ≃⋆+* B where\n  toFun := f\n  invFun := g\n  left_inv := h₁\n  right_inv := h₂\n  map_add' := map_add f\n  map_mul' := map_mul f\n  map_star' := map_star f\n\n"}
{"name":"StarRingEquiv.ofStarRingHom_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"F : Type u_1\nG : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁷ : NonUnitalNonAssocSemiring A\ninst✝⁶ : Star A\ninst✝⁵ : NonUnitalNonAssocSemiring B\ninst✝⁴ : Star B\ninst✝³ : FunLike F A B\ninst✝² : NonUnitalRingHomClass F A B\ninst✝¹ : NonUnitalStarRingHomClass F A B\ninst✝ : FunLike G B A\nf : F\ng : G\nh₁ : ∀ (x : A), Eq (g (f x)) x\nh₂ : ∀ (x : B), Eq (f (g x)) x\na : A\n⊢ Eq ((StarRingEquiv.ofStarRingHom f g h₁ h₂) a) (f a)","decl":"/-- If a (unital or non-unital) star ring morphism has an inverse, it is an isomorphism of\nstar rings. -/\n@[simps]\ndef ofStarRingHom (f : F) (g : G) (h₁ : ∀ x, g (f x) = x) (h₂ : ∀ x, f (g x) = x) : A ≃⋆+* B where\n  toFun := f\n  invFun := g\n  left_inv := h₁\n  right_inv := h₂\n  map_add' := map_add f\n  map_mul' := map_mul f\n  map_star' := map_star f\n\n"}
{"name":"StarRingEquiv.coe_ofBijective","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"F : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁶ : NonUnitalNonAssocSemiring A\ninst✝⁵ : Star A\ninst✝⁴ : NonUnitalNonAssocSemiring B\ninst✝³ : Star B\ninst✝² : FunLike F A B\ninst✝¹ : NonUnitalRingHomClass F A B\ninst✝ : NonUnitalStarRingHomClass F A B\nf : F\nhf : Function.Bijective ⇑f\n⊢ Eq ⇑(StarRingEquiv.ofBijective f hf) ⇑f","decl":"@[simp]\ntheorem coe_ofBijective {f : F} (hf : Function.Bijective f) :\n    (StarRingEquiv.ofBijective f hf : A → B) = f :=\n  rfl\n\n"}
{"name":"StarRingEquiv.ofBijective_apply","module":"Mathlib.Algebra.Star.StarRingHom","initialProofState":"F : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁶ : NonUnitalNonAssocSemiring A\ninst✝⁵ : Star A\ninst✝⁴ : NonUnitalNonAssocSemiring B\ninst✝³ : Star B\ninst✝² : FunLike F A B\ninst✝¹ : NonUnitalRingHomClass F A B\ninst✝ : NonUnitalStarRingHomClass F A B\nf : F\nhf : Function.Bijective ⇑f\na : A\n⊢ Eq ((StarRingEquiv.ofBijective f hf) a) (f a)","decl":"theorem ofBijective_apply {f : F} (hf : Function.Bijective f) (a : A) :\n    (StarRingEquiv.ofBijective f hf) a = f a :=\n  rfl\n\n"}
