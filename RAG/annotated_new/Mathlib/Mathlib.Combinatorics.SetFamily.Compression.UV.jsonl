{"name":"sup_sdiff_injOn","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝ : GeneralizedBooleanAlgebra α\nu v : α\n⊢ Set.InjOn (fun x => SDiff.sdiff (Max.max x u) v) (setOf fun x => And (Disjoint u x) (LE.le v x))","decl":"/-- UV-compression is injective on the elements it moves. See `UV.compress`. -/\ntheorem sup_sdiff_injOn [GeneralizedBooleanAlgebra α] (u v : α) :\n    { x | Disjoint u x ∧ v ≤ x }.InjOn fun x => (x ⊔ u) \\ v := by\n  rintro a ha b hb hab\n  have h : ((a ⊔ u) \\ v) \\ u ⊔ v = ((b ⊔ u) \\ v) \\ u ⊔ v := by\n    dsimp at hab\n    rw [hab]\n  rwa [sdiff_sdiff_comm, ha.1.symm.sup_sdiff_cancel_right, sdiff_sdiff_comm,\n    hb.1.symm.sup_sdiff_cancel_right, sdiff_sup_cancel ha.2, sdiff_sup_cancel hb.2] at h\n\n-- The namespace is here to distinguish from other compressions.\n"}
{"name":"UV.compress_of_disjoint_of_le","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : DecidableRel Disjoint\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nu v a : α\nhua : Disjoint u a\nhva : LE.le v a\n⊢ Eq (UV.compress u v a) (SDiff.sdiff (Max.max a u) v)","decl":"theorem compress_of_disjoint_of_le (hua : Disjoint u a) (hva : v ≤ a) :\n    compress u v a = (a ⊔ u) \\ v :=\n  if_pos ⟨hua, hva⟩\n\n"}
{"name":"UV.compress_of_disjoint_of_le'","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : DecidableRel Disjoint\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nu v a : α\nhva : Disjoint v a\nhua : LE.le u a\n⊢ Eq (UV.compress u v (SDiff.sdiff (Max.max a v) u)) a","decl":"theorem compress_of_disjoint_of_le' (hva : Disjoint v a) (hua : u ≤ a) :\n    compress u v ((a ⊔ v) \\ u) = a := by\n  rw [compress_of_disjoint_of_le disjoint_sdiff_self_right\n      (le_sdiff.2 ⟨(le_sup_right : v ≤ a ⊔ v), hva.mono_right hua⟩),\n    sdiff_sup_cancel (le_sup_of_le_left hua), hva.symm.sup_sdiff_cancel_right]\n\n"}
{"name":"UV.compress_self","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : DecidableRel Disjoint\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nu a : α\n⊢ Eq (UV.compress u u a) a","decl":"@[simp]\ntheorem compress_self (u a : α) : compress u u a = a := by\n  unfold compress\n  split_ifs with h\n  · exact h.1.symm.sup_sdiff_cancel_right\n  · rfl\n\n"}
{"name":"UV.compress_sdiff_sdiff","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : DecidableRel Disjoint\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\n⊢ Eq (UV.compress (SDiff.sdiff a b) (SDiff.sdiff b a) b) a","decl":"/-- An element can be compressed to any other element by removing/adding the differences. -/\n@[simp]\ntheorem compress_sdiff_sdiff (a b : α) : compress (a \\ b) (b \\ a) b = a := by\n  refine (compress_of_disjoint_of_le disjoint_sdiff_self_left sdiff_le).trans ?_\n  rw [sup_sdiff_self_right, sup_sdiff, disjoint_sdiff_self_right.sdiff_eq_left, sup_eq_right]\n  exact sdiff_sdiff_le\n\n"}
{"name":"UV.compress_idem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝² : GeneralizedBooleanAlgebra α\ninst✝¹ : DecidableRel Disjoint\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nu v a : α\n⊢ Eq (UV.compress u v (UV.compress u v a)) (UV.compress u v a)","decl":"/-- Compressing an element is idempotent. -/\n@[simp]\ntheorem compress_idem (u v a : α) : compress u v (compress u v a) = compress u v a := by\n  unfold compress\n  split_ifs with h h'\n  · rw [le_sdiff_iff.1 h'.2, sdiff_bot, sdiff_bot, sup_assoc, sup_idem]\n  · rfl\n  · rfl\n\n"}
{"name":"UV.compress_injOn","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v : α\ninst✝ : DecidableEq α\n⊢ Set.InjOn (UV.compress u v) ↑(Finset.filter (fun a => Not (Membership.mem s (UV.compress u v a))) s)","decl":"/-- UV-compression is injective on the sets that are not UV-compressed. -/\ntheorem compress_injOn : Set.InjOn (compress u v) ↑{a ∈ s | compress u v a ∉ s} := by\n  intro a ha b hb hab\n  rw [mem_coe, mem_filter] at ha hb\n  rw [compress] at ha hab\n  split_ifs at ha hab with has\n  · rw [compress] at hb hab\n    split_ifs at hb hab with hbs\n    · exact sup_sdiff_injOn u v has hbs hab\n    · exact (hb.2 hb.1).elim\n  · exact (ha.2 ha.1).elim\n\n"}
{"name":"UV.mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v a : α\ninst✝ : DecidableEq α\n⊢ Iff (Membership.mem (UV.compression u v s) a) (Or (And (Membership.mem s a) (Membership.mem s (UV.compress u v a))) (And (Not (Membership.mem s a)) (Exists fun b => And (Membership.mem s b) (Eq (UV.compress u v b) a))))","decl":"/-- `a` is in the UV-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. -/\ntheorem mem_compression :\n    a ∈ 𝓒 u v s ↔ a ∈ s ∧ compress u v a ∈ s ∨ a ∉ s ∧ ∃ b ∈ s, compress u v b = a := by\n  simp_rw [compression, mem_union, mem_filter, mem_image, and_comm]\n\n"}
{"name":"UV.IsCompressed.eq","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v : α\ninst✝ : DecidableEq α\nh : UV.IsCompressed u v s\n⊢ Eq (UV.compression u v s) s","decl":"protected theorem IsCompressed.eq (h : IsCompressed u v s) : 𝓒 u v s = s := h\n\n"}
{"name":"UV.compression_self","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableEq α\nu : α\ns : Finset α\n⊢ Eq (UV.compression u u s) s","decl":"@[simp]\ntheorem compression_self (u : α) (s : Finset α) : 𝓒 u u s = s := by\n  unfold compression\n  convert union_empty s\n  · ext a\n    rw [mem_filter, compress_self, and_self_iff]\n  · refine eq_empty_of_forall_not_mem fun a ha ↦ ?_\n    simp_rw [mem_filter, mem_image, compress_self] at ha\n    obtain ⟨⟨b, hb, rfl⟩, hb'⟩ := ha\n    exact hb' hb\n\n"}
{"name":"UV.isCompressed_self","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableEq α\nu : α\ns : Finset α\n⊢ UV.IsCompressed u u s","decl":"/-- Any family is compressed along two identical elements. -/\ntheorem isCompressed_self (u : α) (s : Finset α) : IsCompressed u u s := compression_self u s\n\n"}
{"name":"UV.compress_disjoint","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v : α\ninst✝ : DecidableEq α\n⊢ Disjoint (Finset.filter (fun a => Membership.mem s (UV.compress u v a)) s) (Finset.filter (fun a => Not (Membership.mem s a)) (Finset.image (UV.compress u v) s))","decl":"theorem compress_disjoint :\n    Disjoint {a ∈ s | compress u v a ∈ s} {a ∈ s.image <| compress u v | a ∉ s} :=\n  disjoint_left.2 fun _a ha₁ ha₂ ↦ (mem_filter.1 ha₂).2 (mem_filter.1 ha₁).1\n\n"}
{"name":"UV.compress_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v a : α\ninst✝ : DecidableEq α\nha : Membership.mem s a\n⊢ Membership.mem (UV.compression u v s) (UV.compress u v a)","decl":"theorem compress_mem_compression (ha : a ∈ s) : compress u v a ∈ 𝓒 u v s := by\n  rw [mem_compression]\n  by_cases h : compress u v a ∈ s\n  · rw [compress_idem]\n    exact Or.inl ⟨h, h⟩\n  · exact Or.inr ⟨h, a, ha, rfl⟩\n\n-- This is a special case of `compress_mem_compression` once we have `compression_idem`.\n"}
{"name":"UV.compress_mem_compression_of_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v a : α\ninst✝ : DecidableEq α\nha : Membership.mem (UV.compression u v s) a\n⊢ Membership.mem (UV.compression u v s) (UV.compress u v a)","decl":"theorem compress_mem_compression_of_mem_compression (ha : a ∈ 𝓒 u v s) :\n    compress u v a ∈ 𝓒 u v s := by\n  rw [mem_compression] at ha ⊢\n  simp only [compress_idem, exists_prop]\n  obtain ⟨_, ha⟩ | ⟨_, b, hb, rfl⟩ := ha\n  · exact Or.inl ⟨ha, ha⟩\n  · exact Or.inr ⟨by rwa [compress_idem], b, hb, (compress_idem _ _ _).symm⟩\n\n"}
{"name":"UV.compression_idem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableEq α\nu v : α\ns : Finset α\n⊢ Eq (UV.compression u v (UV.compression u v s)) (UV.compression u v s)","decl":"/-- Compressing a family is idempotent. -/\n@[simp]\ntheorem compression_idem (u v : α) (s : Finset α) : 𝓒 u v (𝓒 u v s) = 𝓒 u v s := by\n  have h : {a ∈ 𝓒 u v s | compress u v a ∉ 𝓒 u v s} = ∅ :=\n    filter_false_of_mem fun a ha h ↦ h <| compress_mem_compression_of_mem_compression ha\n  rw [compression, filter_image, h, image_empty, ← h]\n  exact filter_union_filter_neg_eq _ (compression u v s)\n\n"}
{"name":"UV.card_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableEq α\nu v : α\ns : Finset α\n⊢ Eq (UV.compression u v s).card s.card","decl":"/-- Compressing a family doesn't change its size. -/\n@[simp]\ntheorem card_compression (u v : α) (s : Finset α) : #(𝓒 u v s) = #s := by\n  rw [compression, card_union_of_disjoint compress_disjoint, filter_image,\n    card_image_of_injOn compress_injOn, ← card_union_of_disjoint (disjoint_filter_filter_neg s _ _),\n    filter_union_filter_neg_eq]\n\n"}
{"name":"UV.le_of_mem_compression_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v a : α\ninst✝ : DecidableEq α\nh : Membership.mem (UV.compression u v s) a\nha : Not (Membership.mem s a)\n⊢ LE.le u a","decl":"theorem le_of_mem_compression_of_not_mem (h : a ∈ 𝓒 u v s) (ha : a ∉ s) : u ≤ a := by\n  rw [mem_compression] at h\n  obtain h | ⟨-, b, hb, hba⟩ := h\n  · cases ha h.1\n  unfold compress at hba\n  split_ifs at hba with h\n  · rw [← hba, le_sdiff]\n    exact ⟨le_sup_right, h.1.mono_right h.2⟩\n  · cases ne_of_mem_of_not_mem hb ha hba\n\n"}
{"name":"UV.disjoint_of_mem_compression_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v a : α\ninst✝ : DecidableEq α\nh : Membership.mem (UV.compression u v s) a\nha : Not (Membership.mem s a)\n⊢ Disjoint v a","decl":"theorem disjoint_of_mem_compression_of_not_mem (h : a ∈ 𝓒 u v s) (ha : a ∉ s) : Disjoint v a := by\n  rw [mem_compression] at h\n  obtain h | ⟨-, b, hb, hba⟩ := h\n  · cases ha h.1\n  unfold compress at hba\n  split_ifs at hba\n  · rw [← hba]\n    exact disjoint_sdiff_self_right\n  · cases ne_of_mem_of_not_mem hb ha hba\n\n"}
{"name":"UV.sup_sdiff_mem_of_mem_compression_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v a : α\ninst✝ : DecidableEq α\nh : Membership.mem (UV.compression u v s) a\nha : Not (Membership.mem s a)\n⊢ Membership.mem s (SDiff.sdiff (Max.max a v) u)","decl":"theorem sup_sdiff_mem_of_mem_compression_of_not_mem (h : a ∈ 𝓒 u v s) (ha : a ∉ s) :\n    (a ⊔ v) \\ u ∈ s := by\n  rw [mem_compression] at h\n  obtain h | ⟨-, b, hb, hba⟩ := h\n  · cases ha h.1\n  unfold compress at hba\n  split_ifs at hba with h\n  · rwa [← hba, sdiff_sup_cancel (le_sup_of_le_left h.2), sup_sdiff_right_self,\n      h.1.symm.sdiff_eq_left]\n  · cases ne_of_mem_of_not_mem hb ha hba\n\n"}
{"name":"UV.sup_sdiff_mem_of_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v a : α\ninst✝ : DecidableEq α\nha : Membership.mem (UV.compression u v s) a\nhva : LE.le v a\nhua : Disjoint u a\n⊢ Membership.mem s (SDiff.sdiff (Max.max a u) v)","decl":"/-- If `a` is in the family compression and can be compressed, then its compression is in the\noriginal family. -/\ntheorem sup_sdiff_mem_of_mem_compression (ha : a ∈ 𝓒 u v s) (hva : v ≤ a) (hua : Disjoint u a) :\n    (a ⊔ u) \\ v ∈ s := by\n  rw [mem_compression, compress_of_disjoint_of_le hua hva] at ha\n  obtain ⟨_, ha⟩ | ⟨_, b, hb, rfl⟩ := ha\n  · exact ha\n  have hu : u = ⊥ := by\n    suffices Disjoint u (u \\ v) by rwa [(hua.mono_right hva).sdiff_eq_left, disjoint_self] at this\n    refine hua.mono_right ?_\n    rw [← compress_idem, compress_of_disjoint_of_le hua hva]\n    exact sdiff_le_sdiff_right le_sup_right\n  have hv : v = ⊥ := by\n    rw [← disjoint_self]\n    apply Disjoint.mono_right hva\n    rw [← compress_idem, compress_of_disjoint_of_le hua hva]\n    exact disjoint_sdiff_self_right\n  rwa [hu, hv, compress_self, sup_bot_eq, sdiff_bot]\n\n"}
{"name":"UV.mem_of_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝³ : GeneralizedBooleanAlgebra α\ninst✝² : DecidableRel Disjoint\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\nu v a : α\ninst✝ : DecidableEq α\nha : Membership.mem (UV.compression u v s) a\nhva : LE.le v a\nhvu : Eq v Bot.bot → Eq u Bot.bot\n⊢ Membership.mem s a","decl":"/-- If `a` is in the `u, v`-compression but `v ≤ a`, then `a` must have been in the original\nfamily. -/\ntheorem mem_of_mem_compression (ha : a ∈ 𝓒 u v s) (hva : v ≤ a) (hvu : v = ⊥ → u = ⊥) :\n    a ∈ s := by\n  rw [mem_compression] at ha\n  obtain ha | ⟨_, b, hb, h⟩ := ha\n  · exact ha.1\n  unfold compress at h\n  split_ifs at h\n  · rw [← h, le_sdiff_iff] at hva\n    rwa [← h, hvu hva, hva, sup_bot_eq, sdiff_bot]\n  · rwa [← h]\n\n"}
{"name":"UV.card_compress","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nu v : Finset α\nhuv : Eq u.card v.card\na : Finset α\n⊢ Eq (UV.compress u v a).card a.card","decl":"/-- Compressing a finset doesn't change its size. -/\ntheorem card_compress (huv : #u = #v) (a : Finset α) : #(compress u v a) = #a := by\n  unfold compress\n  split_ifs with h\n  · rw [card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_union_of_disjoint h.1.symm, huv,\n      add_tsub_cancel_right]\n  · rfl\n\n"}
{"name":"Set.Sized.uvCompression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nu v : Finset α\nr : Nat\nhuv : Eq u.card v.card\nh𝒜 : Set.Sized r ↑𝒜\n⊢ Set.Sized r ↑(UV.compression u v 𝒜)","decl":"lemma _root_.Set.Sized.uvCompression (huv : #u = #v) (h𝒜 : (𝒜 : Set (Finset α)).Sized r) :\n    (𝓒 u v 𝒜 : Set (Finset α)).Sized r := by\n  simp_rw [Set.Sized, mem_coe, mem_compression]\n  rintro s (hs | ⟨huvt, t, ht, rfl⟩)\n  · exact h𝒜 hs.1\n  · rw [card_compress huv, h𝒜 ht]\n\n"}
{"name":"UV.shadow_compression_subset_compression_shadow","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nu v : Finset α\nhuv : ∀ (x : α), Membership.mem u x → Exists fun y => And (Membership.mem v y) (UV.IsCompressed (u.erase x) (v.erase y) 𝒜)\n⊢ HasSubset.Subset (UV.compression u v 𝒜).shadow (UV.compression u v 𝒜.shadow)","decl":"/-- UV-compression reduces the size of the shadow of `𝒜` if, for all `x ∈ u` there is `y ∈ v` such\nthat `𝒜` is `(u.erase x, v.erase y)`-compressed. This is the key fact about compression for\nKruskal-Katona. -/\ntheorem shadow_compression_subset_compression_shadow (u v : Finset α)\n    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :\n    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) := by\n  set 𝒜' := 𝓒 u v 𝒜\n  suffices H : ∀ s ∈ ∂ 𝒜',\n      s ∉ ∂ 𝒜 → u ⊆ s ∧ Disjoint v s ∧ (s ∪ v) \\ u ∈ ∂ 𝒜 ∧ (s ∪ v) \\ u ∉ ∂ 𝒜' by\n    rintro s hs'\n    rw [mem_compression]\n    by_cases hs : s ∈ 𝒜.shadow\n    swap\n    · obtain ⟨hus, hvs, h, _⟩ := H _ hs' hs\n      exact Or.inr ⟨hs, _, h, compress_of_disjoint_of_le' hvs hus⟩\n    refine Or.inl ⟨hs, ?_⟩\n    rw [compress]\n    split_ifs with huvs\n    swap\n    · exact hs\n    rw [mem_shadow_iff] at hs'\n    obtain ⟨t, Ht, a, hat, rfl⟩ := hs'\n    have hav : a ∉ v := not_mem_mono huvs.2 (not_mem_erase a t)\n    have hvt : v ≤ t := huvs.2.trans (erase_subset _ t)\n    have ht : t ∈ 𝒜 := mem_of_mem_compression Ht hvt (aux huv)\n    by_cases hau : a ∈ u\n    · obtain ⟨b, hbv, Hcomp⟩ := huv a hau\n      refine mem_shadow_iff_insert_mem.2 ⟨b, not_mem_sdiff_of_mem_right hbv, ?_⟩\n      rw [← Hcomp.eq] at ht\n      have hsb :=\n        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)\n          (disjoint_erase_comm.2 huvs.1)\n      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ←\n        erase_union_of_mem hau] at hsb\n    · refine mem_shadow_iff.2\n        ⟨(t ⊔ u) \\ v,\n          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_⟩\n      · rw [sup_eq_union, mem_sdiff, mem_union]\n        exact ⟨Or.inl hat, hav⟩\n      · rw [← erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]\n  intro s hs𝒜' hs𝒜\n  -- This is going to be useful a couple of times so let's name it.\n  have m : ∀ y, y ∉ s → insert y s ∉ 𝒜 := fun y h a => hs𝒜 (mem_shadow_iff_insert_mem.2 ⟨y, h, a⟩)\n  obtain ⟨x, _, _⟩ := mem_shadow_iff_insert_mem.1 hs𝒜'\n  have hus : u ⊆ insert x s := le_of_mem_compression_of_not_mem ‹_ ∈ 𝒜'› (m _ ‹x ∉ s›)\n  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)\n  have : (insert x s ∪ v) \\ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)\n  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)\n  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs\n  have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)\n  have : v \\ u = v := ‹Disjoint v u›.sdiff_eq_left\n  -- The first key part is that `x ∉ u`\n  have : x ∉ u := by\n    intro hxu\n    obtain ⟨y, hyv, hxy⟩ := huv x hxu\n    -- If `x ∈ u`, we can get `y ∈ v` so that `𝒜` is `(u.erase x, v.erase y)`-compressed\n    apply m y (disjoint_right.1 hsv hyv)\n    -- and we will use this `y` to contradict `m`, so we would like to show `insert y s ∈ 𝒜`.\n    -- We do this by showing the below\n    have : ((insert x s ∪ v) \\ u ∪ erase u x) \\ erase v y ∈ 𝒜 := by\n      refine\n        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_\n          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)\n      rw [union_sdiff_distrib, ‹v \\ u = v›]\n      exact (erase_subset _ _).trans subset_union_right\n    -- and then arguing that it's the same\n    convert this using 1\n    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‹x ∈ u›, erase_union_distrib,\n      erase_insert ‹x ∉ s›, erase_eq_of_not_mem ‹x ∉ v›, sdiff_erase (mem_union_right _ hyv),\n      union_sdiff_cancel_right hsv]\n  -- Now that this is done, it's immediate that `u ⊆ s`\n  have hus : u ⊆ s := by rwa [← erase_eq_of_not_mem ‹x ∉ u›, ← subset_insert_iff]\n  -- and we already had that `v` and `s` are disjoint,\n  -- so it only remains to get `(s ∪ v) \\ u ∈ ∂ 𝒜 \\ ∂ 𝒜'`\n  simp_rw [mem_shadow_iff_insert_mem]\n  refine ⟨hus, hsv.symm, ⟨x, ?_, ?_⟩, ?_⟩\n  -- `(s ∪ v) \\ u ∈ ∂ 𝒜` is pretty direct:\n  · exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ⟨‹x ∉ s›, ‹x ∉ v›⟩)\n  · rwa [← insert_sdiff_of_not_mem _ ‹x ∉ u›, ← insert_union]\n  -- For (s ∪ v) \\ u ∉ ∂ 𝒜', we split up based on w ∈ u\n  rintro ⟨w, hwB, hw𝒜'⟩\n  have : v ⊆ insert w ((s ∪ v) \\ u) :=\n    (subset_sdiff.2 ⟨subset_union_right, hvu⟩).trans (subset_insert _ _)\n  by_cases hwu : w ∈ u\n  -- If `w ∈ u`, we find `z ∈ v`, and contradict `m` again\n  · obtain ⟨z, hz, hxy⟩ := huv w hwu\n    apply m z (disjoint_right.1 hsv hz)\n    have : insert w ((s ∪ v) \\ u) ∈ 𝒜 := mem_of_mem_compression hw𝒜' ‹_› (aux huv)\n    have : (insert w ((s ∪ v) \\ u) ∪ erase u w) \\ erase v z ∈ 𝒜 := by\n      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‹_›) ?_\n      rw [← sdiff_erase (mem_union_left _ <| hus hwu)]\n      exact disjoint_sdiff\n    convert this using 1\n    rw [insert_union_comm, insert_erase ‹w ∈ u›,\n      sdiff_union_of_subset (hus.trans subset_union_left),\n      sdiff_erase (mem_union_right _ ‹z ∈ v›), union_sdiff_cancel_right hsv]\n  -- If `w ∉ u`, we contradict `m` again\n  rw [mem_sdiff, ← Classical.not_imp, Classical.not_not] at hwB\n  apply m w (hwu ∘ hwB ∘ mem_union_left _)\n  have : (insert w ((s ∪ v) \\ u) ∪ u) \\ v ∈ 𝒜 :=\n    sup_sdiff_mem_of_mem_compression ‹insert w ((s ∪ v) \\ u) ∈ 𝒜'› ‹_›\n      (disjoint_insert_right.2 ⟨‹_›, disjoint_sdiff⟩)\n  convert this using 1\n  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),\n    insert_sdiff_of_not_mem _ (hwu ∘ hwB ∘ mem_union_right _), union_sdiff_cancel_right hsv]\n\n"}
{"name":"UV.card_shadow_compression_le","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nu v : Finset α\nhuv : ∀ (x : α), Membership.mem u x → Exists fun y => And (Membership.mem v y) (UV.IsCompressed (u.erase x) (v.erase y) 𝒜)\n⊢ LE.le (UV.compression u v 𝒜).shadow.card 𝒜.shadow.card","decl":"/-- UV-compression reduces the size of the shadow of `𝒜` if, for all `x ∈ u` there is `y ∈ v`\nsuch that `𝒜` is `(u.erase x, v.erase y)`-compressed. This is the key UV-compression fact needed for\nKruskal-Katona. -/\ntheorem card_shadow_compression_le (u v : Finset α)\n    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :\n    #(∂ (𝓒 u v 𝒜)) ≤ #(∂ 𝒜) :=\n  (card_le_card <| shadow_compression_subset_compression_shadow _ _ huv).trans\n    (card_compression _ _ _).le\n\n"}
