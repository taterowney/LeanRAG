{"name":"sup_sdiff_injOn","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœ : GeneralizedBooleanAlgebra Î±\nu v : Î±\nâŠ¢ Set.InjOn (fun x => SDiff.sdiff (Max.max x u) v) (setOf fun x => And (Disjoint u x) (LE.le v x))","decl":"/-- UV-compression is injective on the elements it moves. See `UV.compress`. -/\ntheorem sup_sdiff_injOn [GeneralizedBooleanAlgebra Î±] (u v : Î±) :\n    { x | Disjoint u x âˆ§ v â‰¤ x }.InjOn fun x => (x âŠ” u) \\ v := by\n  rintro a ha b hb hab\n  have h : ((a âŠ” u) \\ v) \\ u âŠ” v = ((b âŠ” u) \\ v) \\ u âŠ” v := by\n    dsimp at hab\n    rw [hab]\n  rwa [sdiff_sdiff_comm, ha.1.symm.sup_sdiff_cancel_right, sdiff_sdiff_comm,\n    hb.1.symm.sup_sdiff_cancel_right, sdiff_sup_cancel ha.2, sdiff_sup_cancel hb.2] at h\n\n-- The namespace is here to distinguish from other compressions.\n"}
{"name":"UV.compress_of_disjoint_of_le","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ² : GeneralizedBooleanAlgebra Î±\ninstâœÂ¹ : DecidableRel Disjoint\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nu v a : Î±\nhua : Disjoint u a\nhva : LE.le v a\nâŠ¢ Eq (UV.compress u v a) (SDiff.sdiff (Max.max a u) v)","decl":"theorem compress_of_disjoint_of_le (hua : Disjoint u a) (hva : v â‰¤ a) :\n    compress u v a = (a âŠ” u) \\ v :=\n  if_pos âŸ¨hua, hvaâŸ©\n\n"}
{"name":"UV.compress_of_disjoint_of_le'","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ² : GeneralizedBooleanAlgebra Î±\ninstâœÂ¹ : DecidableRel Disjoint\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nu v a : Î±\nhva : Disjoint v a\nhua : LE.le u a\nâŠ¢ Eq (UV.compress u v (SDiff.sdiff (Max.max a v) u)) a","decl":"theorem compress_of_disjoint_of_le' (hva : Disjoint v a) (hua : u â‰¤ a) :\n    compress u v ((a âŠ” v) \\ u) = a := by\n  rw [compress_of_disjoint_of_le disjoint_sdiff_self_right\n      (le_sdiff.2 âŸ¨(le_sup_right : v â‰¤ a âŠ” v), hva.mono_right huaâŸ©),\n    sdiff_sup_cancel (le_sup_of_le_left hua), hva.symm.sup_sdiff_cancel_right]\n\n"}
{"name":"UV.compress_self","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ² : GeneralizedBooleanAlgebra Î±\ninstâœÂ¹ : DecidableRel Disjoint\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nu a : Î±\nâŠ¢ Eq (UV.compress u u a) a","decl":"@[simp]\ntheorem compress_self (u a : Î±) : compress u u a = a := by\n  unfold compress\n  split_ifs with h\n  Â· exact h.1.symm.sup_sdiff_cancel_right\n  Â· rfl\n\n"}
{"name":"UV.compress_sdiff_sdiff","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ² : GeneralizedBooleanAlgebra Î±\ninstâœÂ¹ : DecidableRel Disjoint\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : Î±\nâŠ¢ Eq (UV.compress (SDiff.sdiff a b) (SDiff.sdiff b a) b) a","decl":"/-- An element can be compressed to any other element by removing/adding the differences. -/\n@[simp]\ntheorem compress_sdiff_sdiff (a b : Î±) : compress (a \\ b) (b \\ a) b = a := by\n  refine (compress_of_disjoint_of_le disjoint_sdiff_self_left sdiff_le).trans ?_\n  rw [sup_sdiff_self_right, sup_sdiff, disjoint_sdiff_self_right.sdiff_eq_left, sup_eq_right]\n  exact sdiff_sdiff_le\n\n"}
{"name":"UV.compress_idem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ² : GeneralizedBooleanAlgebra Î±\ninstâœÂ¹ : DecidableRel Disjoint\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\nu v a : Î±\nâŠ¢ Eq (UV.compress u v (UV.compress u v a)) (UV.compress u v a)","decl":"/-- Compressing an element is idempotent. -/\n@[simp]\ntheorem compress_idem (u v a : Î±) : compress u v (compress u v a) = compress u v a := by\n  unfold compress\n  split_ifs with h h'\n  Â· rw [le_sdiff_iff.1 h'.2, sdiff_bot, sdiff_bot, sup_assoc, sup_idem]\n  Â· rfl\n  Â· rfl\n\n"}
{"name":"UV.compress_injOn","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v : Î±\ninstâœ : DecidableEq Î±\nâŠ¢ Set.InjOn (UV.compress u v) â†‘(Finset.filter (fun a => Not (Membership.mem s (UV.compress u v a))) s)","decl":"/-- UV-compression is injective on the sets that are not UV-compressed. -/\ntheorem compress_injOn : Set.InjOn (compress u v) â†‘{a âˆˆ s | compress u v a âˆ‰ s} := by\n  intro a ha b hb hab\n  rw [mem_coe, mem_filter] at ha hb\n  rw [compress] at ha hab\n  split_ifs at ha hab with has\n  Â· rw [compress] at hb hab\n    split_ifs at hb hab with hbs\n    Â· exact sup_sdiff_injOn u v has hbs hab\n    Â· exact (hb.2 hb.1).elim\n  Â· exact (ha.2 ha.1).elim\n\n"}
{"name":"UV.mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v a : Î±\ninstâœ : DecidableEq Î±\nâŠ¢ Iff (Membership.mem (UV.compression u v s) a) (Or (And (Membership.mem s a) (Membership.mem s (UV.compress u v a))) (And (Not (Membership.mem s a)) (Exists fun b => And (Membership.mem s b) (Eq (UV.compress u v b) a))))","decl":"/-- `a` is in the UV-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. -/\ntheorem mem_compression :\n    a âˆˆ ğ“’ u v s â†” a âˆˆ s âˆ§ compress u v a âˆˆ s âˆ¨ a âˆ‰ s âˆ§ âˆƒ b âˆˆ s, compress u v b = a := by\n  simp_rw [compression, mem_union, mem_filter, mem_image, and_comm]\n\n"}
{"name":"UV.IsCompressed.eq","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v : Î±\ninstâœ : DecidableEq Î±\nh : UV.IsCompressed u v s\nâŠ¢ Eq (UV.compression u v s) s","decl":"protected theorem IsCompressed.eq (h : IsCompressed u v s) : ğ“’ u v s = s := h\n\n"}
{"name":"UV.compression_self","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : DecidableEq Î±\nu : Î±\ns : Finset Î±\nâŠ¢ Eq (UV.compression u u s) s","decl":"@[simp]\ntheorem compression_self (u : Î±) (s : Finset Î±) : ğ“’ u u s = s := by\n  unfold compression\n  convert union_empty s\n  Â· ext a\n    rw [mem_filter, compress_self, and_self_iff]\n  Â· refine eq_empty_of_forall_not_mem fun a ha â†¦ ?_\n    simp_rw [mem_filter, mem_image, compress_self] at ha\n    obtain âŸ¨âŸ¨b, hb, rflâŸ©, hb'âŸ© := ha\n    exact hb' hb\n\n"}
{"name":"UV.isCompressed_self","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : DecidableEq Î±\nu : Î±\ns : Finset Î±\nâŠ¢ UV.IsCompressed u u s","decl":"/-- Any family is compressed along two identical elements. -/\ntheorem isCompressed_self (u : Î±) (s : Finset Î±) : IsCompressed u u s := compression_self u s\n\n"}
{"name":"UV.compress_disjoint","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v : Î±\ninstâœ : DecidableEq Î±\nâŠ¢ Disjoint (Finset.filter (fun a => Membership.mem s (UV.compress u v a)) s) (Finset.filter (fun a => Not (Membership.mem s a)) (Finset.image (UV.compress u v) s))","decl":"theorem compress_disjoint :\n    Disjoint {a âˆˆ s | compress u v a âˆˆ s} {a âˆˆ s.image <| compress u v | a âˆ‰ s} :=\n  disjoint_left.2 fun _a haâ‚ haâ‚‚ â†¦ (mem_filter.1 haâ‚‚).2 (mem_filter.1 haâ‚).1\n\n"}
{"name":"UV.compress_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v a : Î±\ninstâœ : DecidableEq Î±\nha : Membership.mem s a\nâŠ¢ Membership.mem (UV.compression u v s) (UV.compress u v a)","decl":"theorem compress_mem_compression (ha : a âˆˆ s) : compress u v a âˆˆ ğ“’ u v s := by\n  rw [mem_compression]\n  by_cases h : compress u v a âˆˆ s\n  Â· rw [compress_idem]\n    exact Or.inl âŸ¨h, hâŸ©\n  Â· exact Or.inr âŸ¨h, a, ha, rflâŸ©\n\n-- This is a special case of `compress_mem_compression` once we have `compression_idem`.\n"}
{"name":"UV.compress_mem_compression_of_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v a : Î±\ninstâœ : DecidableEq Î±\nha : Membership.mem (UV.compression u v s) a\nâŠ¢ Membership.mem (UV.compression u v s) (UV.compress u v a)","decl":"theorem compress_mem_compression_of_mem_compression (ha : a âˆˆ ğ“’ u v s) :\n    compress u v a âˆˆ ğ“’ u v s := by\n  rw [mem_compression] at ha âŠ¢\n  simp only [compress_idem, exists_prop]\n  obtain âŸ¨_, haâŸ© | âŸ¨_, b, hb, rflâŸ© := ha\n  Â· exact Or.inl âŸ¨ha, haâŸ©\n  Â· exact Or.inr âŸ¨by rwa [compress_idem], b, hb, (compress_idem _ _ _).symmâŸ©\n\n"}
{"name":"UV.compression_idem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : DecidableEq Î±\nu v : Î±\ns : Finset Î±\nâŠ¢ Eq (UV.compression u v (UV.compression u v s)) (UV.compression u v s)","decl":"/-- Compressing a family is idempotent. -/\n@[simp]\ntheorem compression_idem (u v : Î±) (s : Finset Î±) : ğ“’ u v (ğ“’ u v s) = ğ“’ u v s := by\n  have h : {a âˆˆ ğ“’ u v s | compress u v a âˆ‰ ğ“’ u v s} = âˆ… :=\n    filter_false_of_mem fun a ha h â†¦ h <| compress_mem_compression_of_mem_compression ha\n  rw [compression, filter_image, h, image_empty, â† h]\n  exact filter_union_filter_neg_eq _ (compression u v s)\n\n"}
{"name":"UV.card_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : DecidableEq Î±\nu v : Î±\ns : Finset Î±\nâŠ¢ Eq (UV.compression u v s).card s.card","decl":"/-- Compressing a family doesn't change its size. -/\n@[simp]\ntheorem card_compression (u v : Î±) (s : Finset Î±) : #(ğ“’ u v s) = #s := by\n  rw [compression, card_union_of_disjoint compress_disjoint, filter_image,\n    card_image_of_injOn compress_injOn, â† card_union_of_disjoint (disjoint_filter_filter_neg s _ _),\n    filter_union_filter_neg_eq]\n\n"}
{"name":"UV.le_of_mem_compression_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v a : Î±\ninstâœ : DecidableEq Î±\nh : Membership.mem (UV.compression u v s) a\nha : Not (Membership.mem s a)\nâŠ¢ LE.le u a","decl":"theorem le_of_mem_compression_of_not_mem (h : a âˆˆ ğ“’ u v s) (ha : a âˆ‰ s) : u â‰¤ a := by\n  rw [mem_compression] at h\n  obtain h | âŸ¨-, b, hb, hbaâŸ© := h\n  Â· cases ha h.1\n  unfold compress at hba\n  split_ifs at hba with h\n  Â· rw [â† hba, le_sdiff]\n    exact âŸ¨le_sup_right, h.1.mono_right h.2âŸ©\n  Â· cases ne_of_mem_of_not_mem hb ha hba\n\n"}
{"name":"UV.disjoint_of_mem_compression_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v a : Î±\ninstâœ : DecidableEq Î±\nh : Membership.mem (UV.compression u v s) a\nha : Not (Membership.mem s a)\nâŠ¢ Disjoint v a","decl":"theorem disjoint_of_mem_compression_of_not_mem (h : a âˆˆ ğ“’ u v s) (ha : a âˆ‰ s) : Disjoint v a := by\n  rw [mem_compression] at h\n  obtain h | âŸ¨-, b, hb, hbaâŸ© := h\n  Â· cases ha h.1\n  unfold compress at hba\n  split_ifs at hba\n  Â· rw [â† hba]\n    exact disjoint_sdiff_self_right\n  Â· cases ne_of_mem_of_not_mem hb ha hba\n\n"}
{"name":"UV.sup_sdiff_mem_of_mem_compression_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v a : Î±\ninstâœ : DecidableEq Î±\nh : Membership.mem (UV.compression u v s) a\nha : Not (Membership.mem s a)\nâŠ¢ Membership.mem s (SDiff.sdiff (Max.max a v) u)","decl":"theorem sup_sdiff_mem_of_mem_compression_of_not_mem (h : a âˆˆ ğ“’ u v s) (ha : a âˆ‰ s) :\n    (a âŠ” v) \\ u âˆˆ s := by\n  rw [mem_compression] at h\n  obtain h | âŸ¨-, b, hb, hbaâŸ© := h\n  Â· cases ha h.1\n  unfold compress at hba\n  split_ifs at hba with h\n  Â· rwa [â† hba, sdiff_sup_cancel (le_sup_of_le_left h.2), sup_sdiff_right_self,\n      h.1.symm.sdiff_eq_left]\n  Â· cases ne_of_mem_of_not_mem hb ha hba\n\n"}
{"name":"UV.sup_sdiff_mem_of_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v a : Î±\ninstâœ : DecidableEq Î±\nha : Membership.mem (UV.compression u v s) a\nhva : LE.le v a\nhua : Disjoint u a\nâŠ¢ Membership.mem s (SDiff.sdiff (Max.max a u) v)","decl":"/-- If `a` is in the family compression and can be compressed, then its compression is in the\noriginal family. -/\ntheorem sup_sdiff_mem_of_mem_compression (ha : a âˆˆ ğ“’ u v s) (hva : v â‰¤ a) (hua : Disjoint u a) :\n    (a âŠ” u) \\ v âˆˆ s := by\n  rw [mem_compression, compress_of_disjoint_of_le hua hva] at ha\n  obtain âŸ¨_, haâŸ© | âŸ¨_, b, hb, rflâŸ© := ha\n  Â· exact ha\n  have hu : u = âŠ¥ := by\n    suffices Disjoint u (u \\ v) by rwa [(hua.mono_right hva).sdiff_eq_left, disjoint_self] at this\n    refine hua.mono_right ?_\n    rw [â† compress_idem, compress_of_disjoint_of_le hua hva]\n    exact sdiff_le_sdiff_right le_sup_right\n  have hv : v = âŠ¥ := by\n    rw [â† disjoint_self]\n    apply Disjoint.mono_right hva\n    rw [â† compress_idem, compress_of_disjoint_of_le hua hva]\n    exact disjoint_sdiff_self_right\n  rwa [hu, hv, compress_self, sup_bot_eq, sdiff_bot]\n\n"}
{"name":"UV.mem_of_mem_compression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœÂ³ : GeneralizedBooleanAlgebra Î±\ninstâœÂ² : DecidableRel Disjoint\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\nu v a : Î±\ninstâœ : DecidableEq Î±\nha : Membership.mem (UV.compression u v s) a\nhva : LE.le v a\nhvu : Eq v Bot.bot â†’ Eq u Bot.bot\nâŠ¢ Membership.mem s a","decl":"/-- If `a` is in the `u, v`-compression but `v â‰¤ a`, then `a` must have been in the original\nfamily. -/\ntheorem mem_of_mem_compression (ha : a âˆˆ ğ“’ u v s) (hva : v â‰¤ a) (hvu : v = âŠ¥ â†’ u = âŠ¥) :\n    a âˆˆ s := by\n  rw [mem_compression] at ha\n  obtain ha | âŸ¨_, b, hb, hâŸ© := ha\n  Â· exact ha.1\n  unfold compress at h\n  split_ifs at h\n  Â· rw [â† h, le_sdiff_iff] at hva\n    rwa [â† h, hvu hva, hva, sup_bot_eq, sdiff_bot]\n  Â· rwa [â† h]\n\n"}
{"name":"UV.card_compress","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nu v : Finset Î±\nhuv : Eq u.card v.card\na : Finset Î±\nâŠ¢ Eq (UV.compress u v a).card a.card","decl":"/-- Compressing a finset doesn't change its size. -/\ntheorem card_compress (huv : #u = #v) (a : Finset Î±) : #(compress u v a) = #a := by\n  unfold compress\n  split_ifs with h\n  Â· rw [card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_union_of_disjoint h.1.symm, huv,\n      add_tsub_cancel_right]\n  Â· rfl\n\n"}
{"name":"Set.Sized.uvCompression","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nu v : Finset Î±\nr : Nat\nhuv : Eq u.card v.card\nhğ’œ : Set.Sized r â†‘ğ’œ\nâŠ¢ Set.Sized r â†‘(UV.compression u v ğ’œ)","decl":"lemma _root_.Set.Sized.uvCompression (huv : #u = #v) (hğ’œ : (ğ’œ : Set (Finset Î±)).Sized r) :\n    (ğ“’ u v ğ’œ : Set (Finset Î±)).Sized r := by\n  simp_rw [Set.Sized, mem_coe, mem_compression]\n  rintro s (hs | âŸ¨huvt, t, ht, rflâŸ©)\n  Â· exact hğ’œ hs.1\n  Â· rw [card_compress huv, hğ’œ ht]\n\n"}
{"name":"UV.shadow_compression_subset_compression_shadow","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nu v : Finset Î±\nhuv : âˆ€ (x : Î±), Membership.mem u x â†’ Exists fun y => And (Membership.mem v y) (UV.IsCompressed (u.erase x) (v.erase y) ğ’œ)\nâŠ¢ HasSubset.Subset (UV.compression u v ğ’œ).shadow (UV.compression u v ğ’œ.shadow)","decl":"/-- UV-compression reduces the size of the shadow of `ğ’œ` if, for all `x âˆˆ u` there is `y âˆˆ v` such\nthat `ğ’œ` is `(u.erase x, v.erase y)`-compressed. This is the key fact about compression for\nKruskal-Katona. -/\ntheorem shadow_compression_subset_compression_shadow (u v : Finset Î±)\n    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :\n    âˆ‚ (ğ“’ u v ğ’œ) âŠ† ğ“’ u v (âˆ‚ ğ’œ) := by\n  set ğ’œ' := ğ“’ u v ğ’œ\n  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',\n      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \\ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \\ u âˆ‰ âˆ‚ ğ’œ' by\n    rintro s hs'\n    rw [mem_compression]\n    by_cases hs : s âˆˆ ğ’œ.shadow\n    swap\n    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs\n      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©\n    refine Or.inl âŸ¨hs, ?_âŸ©\n    rw [compress]\n    split_ifs with huvs\n    swap\n    Â· exact hs\n    rw [mem_shadow_iff] at hs'\n    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'\n    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)\n    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)\n    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)\n    by_cases hau : a âˆˆ u\n    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau\n      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©\n      rw [â† Hcomp.eq] at ht\n      have hsb :=\n        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)\n          (disjoint_erase_comm.2 huvs.1)\n      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†\n        erase_union_of_mem hau] at hsb\n    Â· refine mem_shadow_iff.2\n        âŸ¨(t âŠ” u) \\ v,\n          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©\n      Â· rw [sup_eq_union, mem_sdiff, mem_union]\n        exact âŸ¨Or.inl hat, havâŸ©\n      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]\n  intro s hsğ’œ' hsğ’œ\n  -- This is going to be useful a couple of times so let's name it.\n  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)\n  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'\n  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)\n  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)\n  have : (insert x s âˆª v) \\ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)\n  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)\n  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs\n  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)\n  have : v \\ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left\n  -- The first key part is that `x âˆ‰ u`\n  have : x âˆ‰ u := by\n    intro hxu\n    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu\n    -- If `x âˆˆ u`, we can get `y âˆˆ v` so that `ğ’œ` is `(u.erase x, v.erase y)`-compressed\n    apply m y (disjoint_right.1 hsv hyv)\n    -- and we will use this `y` to contradict `m`, so we would like to show `insert y s âˆˆ ğ’œ`.\n    -- We do this by showing the below\n    have : ((insert x s âˆª v) \\ u âˆª erase u x) \\ erase v y âˆˆ ğ’œ := by\n      refine\n        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_\n          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)\n      rw [union_sdiff_distrib, â€¹v \\ u = vâ€º]\n      exact (erase_subset _ _).trans subset_union_right\n    -- and then arguing that it's the same\n    convert this using 1\n    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) â€¹x âˆˆ uâ€º, erase_union_distrib,\n      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),\n      union_sdiff_cancel_right hsv]\n  -- Now that this is done, it's immediate that `u âŠ† s`\n  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]\n  -- and we already had that `v` and `s` are disjoint,\n  -- so it only remains to get `(s âˆª v) \\ u âˆˆ âˆ‚ ğ’œ \\ âˆ‚ ğ’œ'`\n  simp_rw [mem_shadow_iff_insert_mem]\n  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©\n  -- `(s âˆª v) \\ u âˆˆ âˆ‚ ğ’œ` is pretty direct:\n  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)\n  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]\n  -- For (s âˆª v) \\ u âˆ‰ âˆ‚ ğ’œ', we split up based on w âˆˆ u\n  rintro âŸ¨w, hwB, hwğ’œ'âŸ©\n  have : v âŠ† insert w ((s âˆª v) \\ u) :=\n    (subset_sdiff.2 âŸ¨subset_union_right, hvuâŸ©).trans (subset_insert _ _)\n  by_cases hwu : w âˆˆ u\n  -- If `w âˆˆ u`, we find `z âˆˆ v`, and contradict `m` again\n  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu\n    apply m z (disjoint_right.1 hsv hz)\n    have : insert w ((s âˆª v) \\ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)\n    have : (insert w ((s âˆª v) \\ u) âˆª erase u w) \\ erase v z âˆˆ ğ’œ := by\n      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_\n      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]\n      exact disjoint_sdiff\n    convert this using 1\n    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,\n      sdiff_union_of_subset (hus.trans subset_union_left),\n      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]\n  -- If `w âˆ‰ u`, we contradict `m` again\n  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB\n  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)\n  have : (insert w ((s âˆª v) \\ u) âˆª u) \\ v âˆˆ ğ’œ :=\n    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \\ u) âˆˆ ğ’œ'â€º â€¹_â€º\n      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)\n  convert this using 1\n  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),\n    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]\n\n"}
{"name":"UV.card_shadow_compression_le","module":"Mathlib.Combinatorics.SetFamily.Compression.UV","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nu v : Finset Î±\nhuv : âˆ€ (x : Î±), Membership.mem u x â†’ Exists fun y => And (Membership.mem v y) (UV.IsCompressed (u.erase x) (v.erase y) ğ’œ)\nâŠ¢ LE.le (UV.compression u v ğ’œ).shadow.card ğ’œ.shadow.card","decl":"/-- UV-compression reduces the size of the shadow of `ğ’œ` if, for all `x âˆˆ u` there is `y âˆˆ v`\nsuch that `ğ’œ` is `(u.erase x, v.erase y)`-compressed. This is the key UV-compression fact needed for\nKruskal-Katona. -/\ntheorem card_shadow_compression_le (u v : Finset Î±)\n    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :\n    #(âˆ‚ (ğ“’ u v ğ’œ)) â‰¤ #(âˆ‚ ğ’œ) :=\n  (card_le_card <| shadow_compression_subset_compression_shadow _ _ huv).trans\n    (card_compression _ _ _).le\n\n"}
