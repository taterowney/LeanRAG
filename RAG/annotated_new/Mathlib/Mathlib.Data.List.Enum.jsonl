{"name":"List.get?_enumFrom","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nn : Nat\nl : List α\nm : Nat\n⊢ Eq ((List.enumFrom n l).get? m) (Option.map (fun a => { fst := HAdd.hAdd n m, snd := a }) (l.get? m))","decl":"@[deprecated getElem?_enumFrom (since := \"2024-08-15\")]\ntheorem get?_enumFrom (n) (l : List α) (m) :\n    get? (enumFrom n l) m = (get? l m).map fun a => (n + m, a) := by\n  simp\n\n"}
{"name":"List.get?_enum","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nl : List α\nn : Nat\n⊢ Eq (l.enum.get? n) (Option.map (fun a => { fst := n, snd := a }) (l.get? n))","decl":"@[deprecated getElem?_enum (since := \"2024-08-15\")]\ntheorem get?_enum (l : List α) (n) : get? (enum l) n = (get? l n).map fun a => (n, a) := by\n  simp\n\n"}
{"name":"List.get_enumFrom","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nl : List α\nn : Nat\ni : Fin (List.enumFrom n l).length\n⊢ Eq ((List.enumFrom n l).get i) { fst := HAdd.hAdd n ↑i, snd := l.get (Fin.cast ⋯ i) }","decl":"@[deprecated getElem_enumFrom (since := \"2024-08-15\")]\ntheorem get_enumFrom (l : List α) (n) (i : Fin (l.enumFrom n).length) :\n    (l.enumFrom n).get i = (n + i, l.get (i.cast enumFrom_length)) := by\n  simp\n\n"}
{"name":"List.get_enum","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nl : List α\ni : Fin l.enum.length\n⊢ Eq (l.enum.get i) { fst := ↑i, snd := l.get (Fin.cast ⋯ i) }","decl":"@[deprecated getElem_enum (since := \"2024-08-15\")]\ntheorem get_enum (l : List α) (i : Fin l.enum.length) :\n    l.enum.get i = (i.1, l.get (i.cast enum_length)) := by\n  simp\n\n"}
{"name":"List.mk_add_mem_enumFrom_iff_get?","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nn i : Nat\nx : α\nl : List α\n⊢ Iff (Membership.mem (List.enumFrom n l) { fst := HAdd.hAdd n i, snd := x }) (Eq (l.get? i) (Option.some x))","decl":"@[deprecated mk_add_mem_enumFrom_iff_getElem? (since := \"2024-08-12\")]\ntheorem mk_add_mem_enumFrom_iff_get? {n i : ℕ} {x : α} {l : List α} :\n    (n + i, x) ∈ enumFrom n l ↔ l.get? i = x := by\n  simp [mem_iff_get?]\n\n"}
{"name":"List.mk_mem_enumFrom_iff_le_and_get?_sub","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nn i : Nat\nx : α\nl : List α\n⊢ Iff (Membership.mem (List.enumFrom n l) { fst := i, snd := x }) (And (LE.le n i) (Eq (l.get? (HSub.hSub i n)) (Option.some x)))","decl":"@[deprecated mk_mem_enumFrom_iff_le_and_getElem?_sub (since := \"2024-08-12\")]\ntheorem mk_mem_enumFrom_iff_le_and_get?_sub {n i : ℕ} {x : α} {l : List α} :\n    (i, x) ∈ enumFrom n l ↔ n ≤ i ∧ l.get? (i - n) = x := by\n  simp [mk_mem_enumFrom_iff_le_and_getElem?_sub]\n\n"}
{"name":"List.mk_mem_enum_iff_get?","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\ni : Nat\nx : α\nl : List α\n⊢ Iff (Membership.mem l.enum { fst := i, snd := x }) (Eq (l.get? i) (Option.some x))","decl":"@[deprecated mk_mem_enum_iff_getElem? (since := \"2024-08-15\")]\ntheorem mk_mem_enum_iff_get? {i : ℕ} {x : α} {l : List α} : (i, x) ∈ enum l ↔ l.get? i = x := by\n  simp [enum, mk_mem_enumFrom_iff_le_and_getElem?_sub]\n\n"}
{"name":"List.mem_enum_iff_get?","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nx : Prod Nat α\nl : List α\n⊢ Iff (Membership.mem l.enum x) (Eq (l.get? x.fst) (Option.some x.snd))","decl":"set_option linter.deprecated false in\n@[deprecated mem_enum_iff_getElem? (since := \"2024-08-15\")]\ntheorem mem_enum_iff_get? {x : ℕ × α} {l : List α} : x ∈ enum l ↔ l.get? x.1 = x.2 :=\n  mk_mem_enum_iff_get?\n\n"}
{"name":"List.forall_mem_enumFrom","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nl : List α\nn : Nat\np : Prod Nat α → Prop\n⊢ Iff (∀ (x : Prod Nat α), Membership.mem (List.enumFrom n l) x → p x) (∀ (i : Nat), LT.lt i l.length → p { fst := HAdd.hAdd n i, snd := GetElem.getElem l i ⋯ })","decl":"theorem forall_mem_enumFrom {l : List α} {n : ℕ} {p : ℕ × α → Prop} :\n    (∀ x ∈ l.enumFrom n, p x) ↔ ∀ (i : ℕ) (_ : i < length l), p (n + i, l[i]) := by\n  simp only [forall_mem_iff_getElem, getElem_enumFrom, enumFrom_length]\n\n"}
{"name":"List.forall_mem_enum","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nl : List α\np : Prod Nat α → Prop\n⊢ Iff (∀ (x : Prod Nat α), Membership.mem l.enum x → p x) (∀ (i : Nat), LT.lt i l.length → p { fst := i, snd := GetElem.getElem l i ⋯ })","decl":"theorem forall_mem_enum {l : List α} {p : ℕ × α → Prop} :\n    (∀ x ∈ l.enum, p x) ↔ ∀ (i : ℕ) (_ : i < length l), p (i, l[i]) :=\n  forall_mem_enumFrom.trans <| by simp\n\n"}
{"name":"List.exists_mem_enumFrom","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nl : List α\nn : Nat\np : Prod Nat α → Prop\n⊢ Iff (Exists fun x => And (Membership.mem (List.enumFrom n l) x) (p x)) (Exists fun i => Exists fun x => p { fst := HAdd.hAdd n i, snd := GetElem.getElem l i ⋯ })","decl":"theorem exists_mem_enumFrom {l : List α} {n : ℕ} {p : ℕ × α → Prop} :\n    (∃ x ∈ l.enumFrom n, p x) ↔ ∃ (i : ℕ) (_ : i < length l), p (n + i, l[i]) := by\n  simp only [exists_mem_iff_getElem, getElem_enumFrom, enumFrom_length]\n\n"}
{"name":"List.exists_mem_enum","module":"Mathlib.Data.List.Enum","initialProofState":"α : Type u_1\nl : List α\np : Prod Nat α → Prop\n⊢ Iff (Exists fun x => And (Membership.mem l.enum x) (p x)) (Exists fun i => Exists fun x => p { fst := i, snd := GetElem.getElem l i ⋯ })","decl":"theorem exists_mem_enum {l : List α} {p : ℕ × α → Prop} :\n    (∃ x ∈ l.enum, p x) ↔ ∃ (i : ℕ) (_ : i < length l), p (i, l[i]) :=\n  exists_mem_enumFrom.trans <| by simp\n\n"}
