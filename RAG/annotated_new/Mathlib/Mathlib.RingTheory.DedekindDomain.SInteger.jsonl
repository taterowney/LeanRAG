{"name":"Set.coe_integer","module":"Mathlib.RingTheory.DedekindDomain.SInteger","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nS : Set (IsDedekindDomain.HeightOneSpectrum R)\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (↑(S.integer K)) (setOf fun x => ∀ (v : IsDedekindDomain.HeightOneSpectrum R), Not (Membership.mem S v) → LE.le (v.valuation x) 1)","decl":"/-- The `R`-subalgebra of `S`-integers of `K`. -/\n@[simps!]\ndef integer : Subalgebra R K :=\n  {\n    (⨅ (v) (_ : v ∉ S), (v : HeightOneSpectrum R).valuation.valuationSubring.toSubring).copy\n        {x : K | ∀ (v) (_ : v ∉ S), (v : HeightOneSpectrum R).valuation x ≤ 1} <|\n      Set.ext fun _ => by simp [SetLike.mem_coe, Subring.mem_iInf] with\n    algebraMap_mem' := fun x v _ => v.valuation_le_one x }\n\n"}
{"name":"Set.integer_eq","module":"Mathlib.RingTheory.DedekindDomain.SInteger","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nS : Set (IsDedekindDomain.HeightOneSpectrum R)\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (S.integer K).toSubring (iInf fun v => iInf fun x => v.valuation.valuationSubring.toSubring)","decl":"theorem integer_eq :\n    (S.integer K).toSubring =\n      ⨅ (v) (_ : v ∉ S), (v : HeightOneSpectrum R).valuation.valuationSubring.toSubring :=\n  SetLike.ext' <| by ext; simp\n\n"}
{"name":"Set.integer_valuation_le_one","module":"Mathlib.RingTheory.DedekindDomain.SInteger","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nS : Set (IsDedekindDomain.HeightOneSpectrum R)\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : Subtype fun x => Membership.mem (S.integer K) x\nv : IsDedekindDomain.HeightOneSpectrum R\nhv : Not (Membership.mem S v)\n⊢ LE.le (v.valuation ↑x) 1","decl":"theorem integer_valuation_le_one (x : S.integer K) {v : HeightOneSpectrum R} (hv : v ∉ S) :\n    v.valuation (x : K) ≤ 1 :=\n  x.property v hv\n\n"}
{"name":"Set.coe_unit","module":"Mathlib.RingTheory.DedekindDomain.SInteger","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nS : Set (IsDedekindDomain.HeightOneSpectrum R)\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (↑(S.unit K)) (setOf fun x => ∀ (v : IsDedekindDomain.HeightOneSpectrum R), Not (Membership.mem S v) → Eq (v.valuation ↑x) 1)","decl":"/-- The subgroup of `S`-units of `Kˣ`. -/\n@[simps!]\ndef unit : Subgroup Kˣ :=\n  (⨅ (v) (_ : v ∉ S), (v : HeightOneSpectrum R).valuation.valuationSubring.unitGroup).copy\n      {x : Kˣ | ∀ (v) (_ : v ∉ S), (v : HeightOneSpectrum R).valuation (x : K) = 1} <|\n    Set.ext fun _ => by\n      -- Porting note: was\n      -- simpa only [SetLike.mem_coe, Subgroup.mem_iInf, Valuation.mem_unitGroup_iff]\n      simp only [mem_setOf, SetLike.mem_coe, Subgroup.mem_iInf, Valuation.mem_unitGroup_iff]\n\n"}
{"name":"Set.unit_eq","module":"Mathlib.RingTheory.DedekindDomain.SInteger","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nS : Set (IsDedekindDomain.HeightOneSpectrum R)\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (S.unit K) (iInf fun v => iInf fun x => v.valuation.valuationSubring.unitGroup)","decl":"theorem unit_eq :\n    S.unit K = ⨅ (v) (_ : v ∉ S), (v : HeightOneSpectrum R).valuation.valuationSubring.unitGroup :=\n  Subgroup.copy_eq _ _ _\n\n"}
{"name":"Set.unit_valuation_eq_one","module":"Mathlib.RingTheory.DedekindDomain.SInteger","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nS : Set (IsDedekindDomain.HeightOneSpectrum R)\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : Subtype fun x => Membership.mem (S.unit K) x\nv : IsDedekindDomain.HeightOneSpectrum R\nhv : Not (Membership.mem S v)\n⊢ Eq (v.valuation ↑↑x) 1","decl":"theorem unit_valuation_eq_one (x : S.unit K) {v : HeightOneSpectrum R} (hv : v ∉ S) :\n    v.valuation ((x : Kˣ) : K) = 1 :=\n  x.property v hv\n\n"}
{"name":"Set.unitEquivUnitsInteger_symm_apply_coe","module":"Mathlib.RingTheory.DedekindDomain.SInteger","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nS : Set (IsDedekindDomain.HeightOneSpectrum R)\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : Units (Subtype fun x => Membership.mem (S.integer K) x)\n⊢ Eq (↑((S.unitEquivUnitsInteger K).symm x)) (Units.mk0 ↑↑x ⋯)","decl":"/-- The group of `S`-units is the group of units of the ring of `S`-integers. -/\n@[simps apply_val_coe symm_apply_coe]\ndef unitEquivUnitsInteger : S.unit K ≃* (S.integer K)ˣ where\n  toFun x :=\n    ⟨⟨((x : Kˣ) : K), fun v hv => (x.property v hv).le⟩,\n      ⟨((x⁻¹ : Kˣ) : K), fun v hv => (x⁻¹.property v hv).le⟩,\n      Subtype.ext x.val.val_inv, Subtype.ext x.val.inv_val⟩\n  invFun x :=\n    ⟨Units.mk0 x fun hx => x.ne_zero (ZeroMemClass.coe_eq_zero.mp hx),\n    fun v hv =>\n      eq_one_of_one_le_mul_left (x.val.property v hv) (x.inv.property v hv) <|\n        Eq.ge <| by\n          -- Porting note: was\n          -- rw [← map_mul]; convert v.valuation.map_one; exact subtype.mk_eq_mk.mp x.val_inv⟩\n          rw [Units.val_mk0, ← map_mul, Subtype.mk_eq_mk.mp x.val_inv, v.valuation.map_one]⟩\n  left_inv _ := by ext; rfl\n  right_inv _ := by ext; rfl\n  map_mul' _ _ := by ext; rfl\n\n"}
{"name":"Set.val_unitEquivUnitsInteger_apply_coe","module":"Mathlib.RingTheory.DedekindDomain.SInteger","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\ninst✝³ : IsDedekindDomain R\nS : Set (IsDedekindDomain.HeightOneSpectrum R)\nK : Type v\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nx : Subtype fun x => Membership.mem (S.unit K) x\n⊢ Eq ↑↑((S.unitEquivUnitsInteger K) x) ↑↑x","decl":"/-- The group of `S`-units is the group of units of the ring of `S`-integers. -/\n@[simps apply_val_coe symm_apply_coe]\ndef unitEquivUnitsInteger : S.unit K ≃* (S.integer K)ˣ where\n  toFun x :=\n    ⟨⟨((x : Kˣ) : K), fun v hv => (x.property v hv).le⟩,\n      ⟨((x⁻¹ : Kˣ) : K), fun v hv => (x⁻¹.property v hv).le⟩,\n      Subtype.ext x.val.val_inv, Subtype.ext x.val.inv_val⟩\n  invFun x :=\n    ⟨Units.mk0 x fun hx => x.ne_zero (ZeroMemClass.coe_eq_zero.mp hx),\n    fun v hv =>\n      eq_one_of_one_le_mul_left (x.val.property v hv) (x.inv.property v hv) <|\n        Eq.ge <| by\n          -- Porting note: was\n          -- rw [← map_mul]; convert v.valuation.map_one; exact subtype.mk_eq_mk.mp x.val_inv⟩\n          rw [Units.val_mk0, ← map_mul, Subtype.mk_eq_mk.mp x.val_inv, v.valuation.map_one]⟩\n  left_inv _ := by ext; rfl\n  right_inv _ := by ext; rfl\n  map_mul' _ _ := by ext; rfl\n\n"}
