{"name":"RingHom.finite_stableUnderComposition","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"⊢ RingHom.StableUnderComposition @RingHom.Finite","decl":"theorem finite_stableUnderComposition : StableUnderComposition @Finite := by\n  introv R hf hg\n  exact hg.comp hf\n\n"}
{"name":"RingHom.finite_respectsIso","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"⊢ RingHom.RespectsIso @RingHom.Finite","decl":"theorem finite_respectsIso : RespectsIso @Finite := by\n  apply finite_stableUnderComposition.respectsIso\n  intros\n  exact Finite.of_surjective _ (RingEquiv.toEquiv _).surjective\n\n"}
{"name":"RingHom.finite_containsIdentities","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"⊢ RingHom.ContainsIdentities @RingHom.Finite","decl":"lemma finite_containsIdentities : ContainsIdentities @Finite := Finite.id\n\n"}
{"name":"RingHom.finite_isStableUnderBaseChange","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"⊢ RingHom.IsStableUnderBaseChange @RingHom.Finite","decl":"theorem finite_isStableUnderBaseChange : IsStableUnderBaseChange @Finite := by\n  refine IsStableUnderBaseChange.mk _ finite_respectsIso ?_\n  classical\n  introv h\n  replace h : Module.Finite R T := by\n    rw [RingHom.Finite] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl\n  suffices Module.Finite S (S ⊗[R] T) by\n    rw [RingHom.Finite]; convert this; congr; ext; simp_rw [Algebra.smul_def]; rfl\n  exact inferInstance\n\n"}
{"name":"Module.Finite_of_isLocalization","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"R : Type u_1\nS : Type u_2\nRₚ : Type u_3\nSₚ : Type u_4\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : CommRing Rₚ\ninst✝⁹ : CommRing Sₚ\ninst✝⁸ : Algebra R S\ninst✝⁷ : Algebra R Rₚ\ninst✝⁶ : Algebra R Sₚ\ninst✝⁵ : Algebra S Sₚ\ninst✝⁴ : Algebra Rₚ Sₚ\ninst✝³ : IsScalarTower R S Sₚ\ninst✝² : IsScalarTower R Rₚ Sₚ\nM : Submonoid R\ninst✝¹ : IsLocalization M Rₚ\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₚ\nhRS : Module.Finite R S\n⊢ Module.Finite Rₚ Sₚ","decl":"lemma Module.Finite_of_isLocalization (R S Rₚ Sₚ) [CommSemiring R] [CommRing S] [CommRing Rₚ]\n    [CommRing Sₚ] [Algebra R S] [Algebra R Rₚ] [Algebra R Sₚ] [Algebra S Sₚ] [Algebra Rₚ Sₚ]\n    [IsScalarTower R S Sₚ] [IsScalarTower R Rₚ Sₚ] (M : Submonoid R) [IsLocalization M Rₚ]\n    [IsLocalization (Algebra.algebraMapSubmonoid S M) Sₚ] [hRS : Module.Finite R S] :\n    Module.Finite Rₚ Sₚ := by\n  classical\n  have : algebraMap Rₚ Sₚ = IsLocalization.map (T := Algebra.algebraMapSubmonoid S M) Sₚ\n      (algebraMap R S) (Submonoid.le_comap_map M) := by\n    apply IsLocalization.ringHom_ext M\n    simp only [IsLocalization.map_comp, ← IsScalarTower.algebraMap_eq]\n  -- We claim that if `S` is generated by `T` as an `R`-module,\n  -- then `S'` is generated by `T` as an `R'`-module.\n  obtain ⟨T, hT⟩ := hRS\n  use T.image (algebraMap S Sₚ)\n  rw [eq_top_iff]\n  rintro x -\n  -- By the hypotheses, for each `x : S'`, we have `x = y / (f r)` for some `y : S` and `r : M`.\n  -- Since `S` is generated by `T`, the image of `y` should fall in the span of the image of `T`.\n  obtain ⟨y, ⟨_, ⟨r, hr, rfl⟩⟩, rfl⟩ :=\n    IsLocalization.mk'_surjective (Algebra.algebraMapSubmonoid S M) x\n  rw [IsLocalization.mk'_eq_mul_mk'_one, mul_comm, Finset.coe_image]\n  have hy : y ∈ Submodule.span R ↑T := by rw [hT]; trivial\n  replace hy : algebraMap S Sₚ y ∈ Submodule.map (IsScalarTower.toAlgHom R S Sₚ).toLinearMap\n    (Submodule.span R (T : Set S)) := Submodule.mem_map_of_mem\n--     -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specify the value of `f` below\n      (f := (IsScalarTower.toAlgHom R S Sₚ).toLinearMap) hy\n  rw [Submodule.map_span (IsScalarTower.toAlgHom R S Sₚ).toLinearMap T] at hy\n  have H : Submodule.span R (algebraMap S Sₚ '' T) ≤\n      (Submodule.span Rₚ (algebraMap S Sₚ '' T)).restrictScalars R := by\n    rw [Submodule.span_le]; exact Submodule.subset_span\n  -- Now, since `y ∈ span T`, and `(f r)⁻¹ ∈ R'`, `x / (f r)` is in `span T` as well.\n  convert (Submodule.span Rₚ (algebraMap S Sₚ '' T)).smul_mem\n    (IsLocalization.mk' Rₚ (1 : R) ⟨r, hr⟩) (H hy) using 1\n  rw [Algebra.smul_def, this, IsLocalization.map_mk', map_one]\n\n"}
{"name":"RingHom.finite_localizationPreserves","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"⊢ RingHom.LocalizationPreserves @RingHom.Finite","decl":"/-- If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. -/\ntheorem RingHom.finite_localizationPreserves : RingHom.LocalizationPreserves @RingHom.Finite := by\n  introv R hf\n  letI := f.toAlgebra\n  letI := ((algebraMap S S').comp f).toAlgebra\n  let f' : R' →+* S' := IsLocalization.map S' f (Submonoid.le_comap_map M)\n  letI := f'.toAlgebra\n  have : IsScalarTower R R' S' := IsScalarTower.of_algebraMap_eq'\n    (IsLocalization.map_comp M.le_comap_map).symm\n  have : IsScalarTower R S S' := IsScalarTower.of_algebraMap_eq' rfl\n  have : IsLocalization (Algebra.algebraMapSubmonoid S M) S' := by\n    rwa [Algebra.algebraMapSubmonoid, RingHom.algebraMap_toAlgebra]\n  have : Module.Finite R S := hf\n  apply Module.Finite_of_isLocalization R S R' S' M\n\n"}
{"name":"RingHom.localization_away_map_finite","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"R S : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\nf : RingHom R S\nR' S' : Type u\ninst✝⁵ : CommRing R'\ninst✝⁴ : CommRing S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\nr : R\ninst✝¹ : IsLocalization.Away r R'\ninst✝ : IsLocalization.Away (f r) S'\nhf : f.Finite\n⊢ (IsLocalization.Away.map R' S' f r).Finite","decl":"theorem RingHom.localization_away_map_finite (r : R) [IsLocalization.Away r R']\n    [IsLocalization.Away (f r) S'] (hf : f.Finite) : (IsLocalization.Away.map R' S' f r).Finite :=\n  finite_localizationPreserves.away f r _ _ hf\n\n"}
{"name":"IsLocalization.smul_mem_finsetIntegerMultiple_span","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"R S : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\nM : Submonoid R\nS' : Type u\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra S S'\ninst✝³ : Algebra R S\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R S S'\ninst✝ : IsLocalization (Submonoid.map (algebraMap R S) M) S'\nx : S\ns : Finset S'\nhx : Membership.mem (Submodule.span R ↑s) ((algebraMap S S') x)\n⊢ Exists fun m => Membership.mem (Submodule.span R ↑(IsLocalization.finsetIntegerMultiple (Submonoid.map (algebraMap R S) M) s)) (HSMul.hSMul m x)","decl":"open scoped Classical in\n/-- Let `S` be an `R`-algebra, `M` a submonoid of `R`, and `S' = M⁻¹S`.\nIf the image of some `x : S` falls in the span of some finite `s ⊆ S'` over `R`,\nthen there exists some `m : M` such that `m • x` falls in the\nspan of `IsLocalization.finsetIntegerMultiple _ s` over `R`.\n-/\ntheorem IsLocalization.smul_mem_finsetIntegerMultiple_span [Algebra R S] [Algebra R S']\n    [IsScalarTower R S S'] [IsLocalization (M.map (algebraMap R S)) S'] (x : S) (s : Finset S')\n    (hx : algebraMap S S' x ∈ Submodule.span R (s : Set S')) :\n    ∃ m : M, m • x ∈\n      Submodule.span R\n        (IsLocalization.finsetIntegerMultiple (M.map (algebraMap R S)) s : Set S) := by\n  let g : S →ₐ[R] S' :=\n    AlgHom.mk' (algebraMap S S') fun c x => by simp [Algebra.algebraMap_eq_smul_one]\n  -- We first obtain the `y' ∈ M` such that `s' = y' • s` is falls in the image of `S` in `S'`.\n  let y := IsLocalization.commonDenomOfFinset (M.map (algebraMap R S)) s\n  have hx₁ : (y : S) • (s : Set S') = g '' _ :=\n    (IsLocalization.finsetIntegerMultiple_image _ s).symm\n  obtain ⟨y', hy', e : algebraMap R S y' = y⟩ := y.prop\n  have : algebraMap R S y' • (s : Set S') = y' • (s : Set S') := by\n    simp_rw [Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]\n  rw [← e, this] at hx₁\n  replace hx₁ := congr_arg (Submodule.span R) hx₁\n  rw [Submodule.span_smul] at hx₁\n  replace hx : _ ∈ y' • Submodule.span R (s : Set S') := Set.smul_mem_smul_set hx\n  rw [hx₁] at hx\n  erw [← _root_.map_smul g, ← Submodule.map_span (g : S →ₗ[R] S')] at hx\n  -- Since `x` falls in the span of `s` in `S'`, `y' • x : S` falls in the span of `s'` in `S'`.\n  -- That is, there exists some `x' : S` in the span of `s'` in `S` and `x' = y' • x` in `S'`.\n  -- Thus `a • (y' • x) = a • x' ∈ span s'` in `S` for some `a ∈ M`.\n  obtain ⟨x', hx', hx'' : algebraMap _ _ _ = _⟩ := hx\n  obtain ⟨⟨_, a, ha₁, rfl⟩, ha₂⟩ :=\n    (IsLocalization.eq_iff_exists (M.map (algebraMap R S)) S').mp hx''\n  use (⟨a, ha₁⟩ : M) * (⟨y', hy'⟩ : M)\n  convert (Submodule.span R\n    (IsLocalization.finsetIntegerMultiple (Submonoid.map (algebraMap R S) M) s : Set S)).smul_mem\n      a hx' using 1\n  convert ha₂.symm using 1\n  · rw [Subtype.coe_mk, Submonoid.smul_def, Submonoid.coe_mul, ← smul_smul]\n    exact Algebra.smul_def _ _\n  · exact Algebra.smul_def _ _\n\n"}
{"name":"multiple_mem_span_of_mem_localization_span","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"R : Type u\ninst✝⁷ : CommRing R\nM : Submonoid R\nR' : Type u\ninst✝⁶ : CommRing R'\ninst✝⁵ : Algebra R R'\nN : Type u_1\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : Module R' N\ninst✝¹ : IsScalarTower R R' N\ninst✝ : IsLocalization M R'\ns : Set N\nx : N\nhx : Membership.mem (Submodule.span R' s) x\n⊢ Exists fun t => Membership.mem (Submodule.span R s) (HSMul.hSMul t x)","decl":"/-- If `M` is an `R' = S⁻¹R` module, and `x ∈ span R' s`,\nthen `t • x ∈ span R s` for some `t : S`. -/\ntheorem multiple_mem_span_of_mem_localization_span\n    {N : Type*} [AddCommMonoid N] [Module R N] [Module R' N]\n    [IsScalarTower R R' N] [IsLocalization M R'] (s : Set N) (x : N)\n    (hx : x ∈ Submodule.span R' s) : ∃ (t : M), t • x ∈ Submodule.span R s := by\n  classical\n  obtain ⟨s', hss', hs'⟩ := Submodule.mem_span_finite_of_mem_span hx\n  rsuffices ⟨t, ht⟩ : ∃ t : M, t • x ∈ Submodule.span R (s' : Set N)\n  · exact ⟨t, Submodule.span_mono hss' ht⟩\n  clear hx hss' s\n  induction s' using Finset.induction_on generalizing x\n  · use 1; simpa using hs'\n  rename_i a s _ hs\n  simp only [Finset.coe_insert, Finset.image_insert, Finset.coe_image, Subtype.coe_mk,\n    Submodule.mem_span_insert] at hs' ⊢\n  rcases hs' with ⟨y, z, hz, rfl⟩\n  rcases IsLocalization.surj M y with ⟨⟨y', s'⟩, e⟩\n  apply congrArg (fun x ↦ x • a) at e\n  simp only [algebraMap_smul] at e\n  rcases hs _ hz with ⟨t, ht⟩\n  refine ⟨t * s', t * y', _, (Submodule.span R (s : Set N)).smul_mem s' ht, ?_⟩\n  rw [smul_add, ← smul_smul, mul_comm, ← smul_smul, ← smul_smul, ← e, mul_comm, ← Algebra.smul_def]\n  simp\n  rfl\n\n"}
{"name":"multiple_mem_adjoin_of_mem_localization_adjoin","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"R S : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\nM : Submonoid R\nR' : Type u\ninst✝⁵ : CommRing R'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra R' S\ninst✝² : Algebra R S\ninst✝¹ : IsScalarTower R R' S\ninst✝ : IsLocalization M R'\ns : Set S\nx : S\nhx : Membership.mem (Algebra.adjoin R' s) x\n⊢ Exists fun t => Membership.mem (Algebra.adjoin R s) (HSMul.hSMul t x)","decl":"/-- If `S` is an `R' = M⁻¹R` algebra, and `x ∈ adjoin R' s`,\nthen `t • x ∈ adjoin R s` for some `t : M`. -/\ntheorem multiple_mem_adjoin_of_mem_localization_adjoin [Algebra R' S] [Algebra R S]\n    [IsScalarTower R R' S] [IsLocalization M R'] (s : Set S) (x : S)\n    (hx : x ∈ Algebra.adjoin R' s) : ∃ t : M, t • x ∈ Algebra.adjoin R s := by\n  change ∃ t : M, t • x ∈ Subalgebra.toSubmodule (Algebra.adjoin R s)\n  change x ∈ Subalgebra.toSubmodule (Algebra.adjoin R' s) at hx\n  simp_rw [Algebra.adjoin_eq_span] at hx ⊢\n  exact multiple_mem_span_of_mem_localization_span M R' _ _ hx\n\n"}
{"name":"RingHom.finite_ofLocalizationSpan","module":"Mathlib.RingTheory.RingHom.Finite","initialProofState":"⊢ RingHom.OfLocalizationSpan @RingHom.Finite","decl":"/-- `S` is a finite `R`-algebra if there exists a set `{ r }` that\n  spans `R` such that `Sᵣ` is a finite `Rᵣ`-algebra. -/\ntheorem RingHom.finite_ofLocalizationSpan : RingHom.OfLocalizationSpan @RingHom.Finite := by\n  classical\n  rw [RingHom.ofLocalizationSpan_iff_finite]\n  introv R hs H\n  -- We first setup the instances\n  letI := f.toAlgebra\n  letI := fun r : s => (Localization.awayMap f r).toAlgebra\n  have : ∀ r : s,\n      IsLocalization ((Submonoid.powers (r : R)).map (algebraMap R S)) (Localization.Away (f r)) :=\n    by intro r; rw [Submonoid.map_powers]; exact Localization.isLocalization\n  haveI : ∀ r : s, IsScalarTower R (Localization.Away (r : R)) (Localization.Away (f r)) :=\n    fun r => IsScalarTower.of_algebraMap_eq'\n      (IsLocalization.map_comp (Submonoid.powers (r : R)).le_comap_map).symm\n  -- By the hypothesis, we may find a finite generating set for each `Sᵣ`. This set can then be\n  -- lifted into `R` by multiplying a sufficiently large power of `r`. I claim that the union of\n  -- these generates `S`.\n  constructor\n  replace H := fun r => (H r).1\n  choose s₁ s₂ using H\n  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (f x)) (s₁ x)\n  use s.attach.biUnion sf\n  rw [Submodule.span_attach_biUnion, eq_top_iff]\n  -- It suffices to show that `r ^ n • x ∈ span T` for each `r : s`, since `{ r ^ n }` spans `R`.\n  -- This then follows from the fact that each `x : R` is a linear combination of the generating set\n  -- of `Sᵣ`. By multiplying a sufficiently large power of `r`, we can cancel out the `r`s in the\n  -- denominators of both the generating set and the coefficients.\n  rintro x -\n  apply Submodule.mem_of_span_eq_top_of_smul_pow_mem _ (s : Set R) hs _ _\n  intro r\n  obtain ⟨⟨_, n₁, rfl⟩, hn₁⟩ :=\n    multiple_mem_span_of_mem_localization_span (Submonoid.powers (r : R))\n      (Localization.Away (r : R)) (s₁ r : Set (Localization.Away (f r))) (algebraMap S _ x)\n      (by rw [s₂ r]; trivial)\n  dsimp only at hn₁\n  rw [Submonoid.smul_def, Algebra.smul_def, IsScalarTower.algebraMap_apply R S, ← map_mul] at hn₁\n  obtain ⟨⟨_, n₂, rfl⟩, hn₂⟩ :=\n    IsLocalization.smul_mem_finsetIntegerMultiple_span (Submonoid.powers (r : R))\n      (Localization.Away (f r)) _ (s₁ r) hn₁\n  rw [Submonoid.smul_def, ← Algebra.smul_def, smul_smul, ← pow_add] at hn₂\n  simp_rw [Submonoid.map_powers] at hn₂\n  use n₂ + n₁\n  exact le_iSup (fun x : s => Submodule.span R (sf x : Set S)) r hn₂\n"}
