{"name":"Ideal.Quotient.isScalarTower_right","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nI : Ideal R\nα : Type u_1\ninst✝¹ : SMul α R\ninst✝ : IsScalarTower α R R\n⊢ IsScalarTower α (HasQuotient.Quotient R I) (HasQuotient.Quotient R I)","decl":"instance (priority := 100) isScalarTower_right {α} [SMul α R] [IsScalarTower α R R] :\n    IsScalarTower α (R ⧸ I) (R ⧸ I) :=\n  (Quotient.ringCon I).isScalarTower_right\n\n"}
{"name":"Ideal.Quotient.smulCommClass","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nI : Ideal R\nα : Type u_1\ninst✝² : SMul α R\ninst✝¹ : IsScalarTower α R R\ninst✝ : SMulCommClass α R R\n⊢ SMulCommClass α (HasQuotient.Quotient R I) (HasQuotient.Quotient R I)","decl":"instance smulCommClass {α} [SMul α R] [IsScalarTower α R R] [SMulCommClass α R R] :\n    SMulCommClass α (R ⧸ I) (R ⧸ I) :=\n  (Quotient.ringCon I).smulCommClass\n\n"}
{"name":"Ideal.Quotient.smulCommClass'","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nI : Ideal R\nα : Type u_1\ninst✝² : SMul α R\ninst✝¹ : IsScalarTower α R R\ninst✝ : SMulCommClass R α R\n⊢ SMulCommClass (HasQuotient.Quotient R I) α (HasQuotient.Quotient R I)","decl":"instance smulCommClass' {α} [SMul α R] [IsScalarTower α R R] [SMulCommClass R α R] :\n    SMulCommClass (R ⧸ I) α (R ⧸ I) :=\n  (Quotient.ringCon I).smulCommClass'\n\n"}
{"name":"Ideal.Quotient.eq_zero_iff_dvd","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\n⊢ Iff (Eq ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton x))) y) 0) (Dvd.dvd x y)","decl":"theorem eq_zero_iff_dvd (x y : R) : Ideal.Quotient.mk (Ideal.span ({x} : Set R)) y = 0 ↔ x ∣ y := by\n  rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton]\n\n"}
{"name":"Ideal.Quotient.mk_singleton_self","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx : R\n⊢ Eq ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton x))) x) 0","decl":"@[simp]\nlemma mk_singleton_self (x : R) : mk (Ideal.span {x}) x = 0 := by\n  rw [eq_zero_iff_dvd]\n\n"}
{"name":"Ideal.Quotient.zero_eq_one_iff","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff (Eq 0 1) (Eq I Top.top)","decl":"theorem zero_eq_one_iff {I : Ideal R} : (0 : R ⧸ I) = 1 ↔ I = ⊤ :=\n  eq_comm.trans <| eq_zero_iff_mem.trans (eq_top_iff_one _).symm\n\n"}
{"name":"Ideal.Quotient.zero_ne_one_iff","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff (Ne 0 1) (Ne I Top.top)","decl":"theorem zero_ne_one_iff {I : Ideal R} : (0 : R ⧸ I) ≠ 1 ↔ I ≠ ⊤ :=\n  not_congr zero_eq_one_iff\n\n"}
{"name":"Ideal.Quotient.nontrivial","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nhI : Ne I Top.top\n⊢ Nontrivial (HasQuotient.Quotient R I)","decl":"protected theorem nontrivial {I : Ideal R} (hI : I ≠ ⊤) : Nontrivial (R ⧸ I) :=\n  ⟨⟨0, 1, zero_ne_one_iff.2 hI⟩⟩\n\n"}
{"name":"Ideal.Quotient.subsingleton_iff","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff (Subsingleton (HasQuotient.Quotient R I)) (Eq I Top.top)","decl":"theorem subsingleton_iff {I : Ideal R} : Subsingleton (R ⧸ I) ↔ I = ⊤ := by\n  rw [eq_top_iff_one, ← subsingleton_iff_zero_eq_one, eq_comm, ← (mk I).map_one,\n    Quotient.eq_zero_iff_mem]\n\n"}
{"name":"Ideal.Quotient.noZeroDivisors","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nhI : I.IsPrime\n⊢ NoZeroDivisors (HasQuotient.Quotient R I)","decl":"instance noZeroDivisors (I : Ideal R) [hI : I.IsPrime] : NoZeroDivisors (R ⧸ I) where\n    eq_zero_or_eq_zero_of_mul_eq_zero {a b} := Quotient.inductionOn₂' a b fun {_ _} hab =>\n      (hI.mem_or_mem (eq_zero_iff_mem.1 hab)).elim (Or.inl ∘ eq_zero_iff_mem.2)\n        (Or.inr ∘ eq_zero_iff_mem.2)\n\n"}
{"name":"Ideal.Quotient.isDomain","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nhI : I.IsPrime\n⊢ IsDomain (HasQuotient.Quotient R I)","decl":"instance isDomain (I : Ideal R) [hI : I.IsPrime] : IsDomain (R ⧸ I) :=\n  let _ := Quotient.nontrivial hI.1\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"Ideal.Quotient.isDomain_iff_prime","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff (IsDomain (HasQuotient.Quotient R I)) I.IsPrime","decl":"theorem isDomain_iff_prime (I : Ideal R) : IsDomain (R ⧸ I) ↔ I.IsPrime := by\n  refine ⟨fun H => ⟨zero_ne_one_iff.1 ?_, fun {x y} h => ?_⟩, fun h => inferInstance⟩\n  · haveI : Nontrivial (R ⧸ I) := ⟨H.2.1⟩\n    exact zero_ne_one\n  · simp only [← eq_zero_iff_mem, (mk I).map_mul] at h ⊢\n    haveI := @IsDomain.to_noZeroDivisors (R ⧸ I) _ H\n    exact eq_zero_or_eq_zero_of_mul_eq_zero h\n\n"}
{"name":"Ideal.Quotient.exists_inv","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nhI : I.IsMaximal\na : HasQuotient.Quotient R I\na✝ : Ne a 0\n⊢ Exists fun b => Eq (HMul.hMul a b) 1","decl":"theorem exists_inv {I : Ideal R} [hI : I.IsMaximal] :\n    ∀ {a : R ⧸ I}, a ≠ 0 → ∃ b : R ⧸ I, a * b = 1 := by\n  rintro ⟨a⟩ h\n  rcases hI.exists_inv (mt eq_zero_iff_mem.2 h) with ⟨b, c, hc, abc⟩\n  rw [mul_comm] at abc\n  refine ⟨mk _ b, Quot.sound ?_⟩\n  simp only [Submodule.quotientRel_def]\n  rw [← eq_sub_iff_add_eq'] at abc\n  rwa [abc, ← neg_mem_iff (G := R) (H := I), neg_sub] at hc\n\n"}
{"name":"Ideal.Quotient.maximal_of_isField","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nhqf : IsField (HasQuotient.Quotient R I)\n⊢ I.IsMaximal","decl":"/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem maximal_of_isField (I : Ideal R) (hqf : IsField (R ⧸ I)) : I.IsMaximal := by\n  apply Ideal.isMaximal_iff.2\n  constructor\n  · intro h\n    rcases hqf.exists_pair_ne with ⟨⟨x⟩, ⟨y⟩, hxy⟩\n    exact hxy (Ideal.Quotient.eq.2 (mul_one (x - y) ▸ I.mul_mem_left _ h))\n  · intro J x hIJ hxnI hxJ\n    rcases hqf.mul_inv_cancel (mt Ideal.Quotient.eq_zero_iff_mem.1 hxnI) with ⟨⟨y⟩, hy⟩\n    rw [← zero_add (1 : R), ← sub_self (x * y), sub_add]\n    exact J.sub_mem (J.mul_mem_right _ hxJ) (hIJ (Ideal.Quotient.eq.1 hy))\n\n"}
{"name":"Ideal.Quotient.maximal_ideal_iff_isField_quotient","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff I.IsMaximal (IsField (HasQuotient.Quotient R I))","decl":"/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem maximal_ideal_iff_isField_quotient (I : Ideal R) : I.IsMaximal ↔ IsField (R ⧸ I) :=\n  ⟨fun h =>\n    let _i := @Quotient.field _ _ I h\n    Field.toIsField _,\n    maximal_of_isField _⟩\n\n"}
{"name":"Ideal.map_pi","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nI : Ideal R\nι : Type u_1\ninst✝ : Finite ι\nι' : Type w\nx : ι → R\nhi : ∀ (i : ι), Membership.mem I (x i)\nf : LinearMap (RingHom.id R) (ι → R) (ι' → R)\ni : ι'\n⊢ Membership.mem I (f x i)","decl":"/-- If `f : R^n → R^m` is an `R`-linear map and `I ⊆ R` is an ideal, then the image of `I^n` is\n    contained in `I^m`. -/\ntheorem map_pi {ι : Type*} [Finite ι] {ι' : Type w} (x : ι → R) (hi : ∀ i, x i ∈ I)\n    (f : (ι → R) →ₗ[R] ι' → R) (i : ι') : f x i ∈ I := by\n  classical\n    cases nonempty_fintype ι\n    rw [pi_eq_sum_univ x]\n    simp only [Finset.sum_apply, smul_eq_mul, map_sum, Pi.smul_apply, map_smul]\n    exact I.sum_mem fun j _ => I.mul_mem_right _ (hi j)\n\n"}
{"name":"Ideal.univ_eq_iUnion_image_add","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : Ideal R\n⊢ Eq Set.univ (Set.iUnion fun x => HVAdd.hVAdd (Quotient.out x) ↑I)","decl":"open scoped Pointwise in\n/-- A ring is made up of a disjoint union of cosets of an ideal. -/\nlemma univ_eq_iUnion_image_add {R : Type*} [Ring R] (I : Ideal R) :\n    (Set.univ (α := R)) = ⋃ x : R ⧸ I, x.out +ᵥ (I : Set R) :=\n  QuotientAddGroup.univ_eq_iUnion_vadd I.toAddSubgroup\n\n"}
{"name":"Finite.of_finite_quot_finite_ideal","module":"Mathlib.RingTheory.Ideal.Quotient.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nI : Ideal R\nhI : Finite (Subtype fun x => Membership.mem I x)\nh : Finite (HasQuotient.Quotient R I)\n⊢ Finite R","decl":"lemma _root_.Finite.of_finite_quot_finite_ideal {R : Type*} [Ring R] {I : Ideal R}\n    [hI : Finite I] [h : Finite (R ⧸ I)] : Finite R :=\n  @Finite.of_finite_quot_finite_addSubgroup _ _ _ hI h\n\n"}
