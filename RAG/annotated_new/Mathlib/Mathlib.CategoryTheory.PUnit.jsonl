{"name":"CategoryTheory.Functor.star_map_down_down","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : C\nx✝ : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/-- The constant functor sending everything to `PUnit.star`. -/\n@[simps!]\ndef star : C ⥤ Discrete PUnit.{w + 1} :=\n  (Functor.const _).obj ⟨⟨⟩⟩\n"}
{"name":"CategoryTheory.Functor.star_obj_as","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nx✝ : C\n⊢ Eq ((CategoryTheory.Functor.star C).obj x✝).as PUnit.unit","decl":"/-- The constant functor sending everything to `PUnit.star`. -/\n@[simps!]\ndef star : C ⥤ Discrete PUnit.{w + 1} :=\n  (Functor.const _).obj ⟨⟨⟩⟩\n"}
{"name":"CategoryTheory.Functor.punitExt_inv_app_down_down","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{w + 1})\nX : C\n⊢ Eq ⋯ ⋯","decl":"/-- Any two functors to `Discrete PUnit` are isomorphic. -/\n@[simps!]\ndef punitExt (F G : C ⥤ Discrete PUnit.{w + 1}) : F ≅ G :=\n  NatIso.ofComponents fun X => eqToIso (by simp only [eq_iff_true_of_subsingleton])\n-- Porting note: simp does indeed fire for these despite the linter warning\n"}
{"name":"CategoryTheory.Functor.punitExt_hom_app_down_down","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{w + 1})\nX : C\n⊢ Eq ⋯ ⋯","decl":"/-- Any two functors to `Discrete PUnit` are isomorphic. -/\n@[simps!]\ndef punitExt (F G : C ⥤ Discrete PUnit.{w + 1}) : F ≅ G :=\n  NatIso.ofComponents fun X => eqToIso (by simp only [eq_iff_true_of_subsingleton])\n-- Porting note: simp does indeed fire for these despite the linter warning\n"}
{"name":"CategoryTheory.Functor.punit_ext'","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{w + 1})\n⊢ Eq F G","decl":"/-- Any two functors to `Discrete PUnit` are *equal*.\nYou probably want to use `punitExt` instead of this. -/\ntheorem punit_ext' (F G : C ⥤ Discrete PUnit.{w + 1}) : F = G :=\n  Functor.ext fun X => by simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Functor.equiv_unitIso","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Functor.equiv.unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Discrete.natIso fun x_1 => CategoryTheory.Iso.refl (((CategoryTheory.Functor.id (CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{w + 1}) C)).obj x).obj x_1)) ⋯)","decl":"/-- Functors from `Discrete PUnit` are equivalent to the category itself. -/\n@[simps]\ndef equiv : Discrete PUnit.{w + 1} ⥤ C ≌ C where\n  functor :=\n    { obj := fun F => F.obj ⟨⟨⟩⟩\n      map := fun θ => θ.app ⟨⟨⟩⟩ }\n  inverse := Functor.const _\n  unitIso := NatIso.ofComponents fun _ => Discrete.natIso fun _ => Iso.refl _\n  counitIso := NatIso.ofComponents Iso.refl\n\n"}
{"name":"CategoryTheory.Functor.equiv_functor_obj","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{w + 1}) C\n⊢ Eq (CategoryTheory.Functor.equiv.functor.obj F) (F.obj { as := PUnit.unit })","decl":"/-- Functors from `Discrete PUnit` are equivalent to the category itself. -/\n@[simps]\ndef equiv : Discrete PUnit.{w + 1} ⥤ C ≌ C where\n  functor :=\n    { obj := fun F => F.obj ⟨⟨⟩⟩\n      map := fun θ => θ.app ⟨⟨⟩⟩ }\n  inverse := Functor.const _\n  unitIso := NatIso.ofComponents fun _ => Discrete.natIso fun _ => Iso.refl _\n  counitIso := NatIso.ofComponents Iso.refl\n\n"}
{"name":"CategoryTheory.Functor.equiv_functor_map","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{w + 1}) C\nθ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Functor.equiv.functor.map θ) (θ.app { as := PUnit.unit })","decl":"/-- Functors from `Discrete PUnit` are equivalent to the category itself. -/\n@[simps]\ndef equiv : Discrete PUnit.{w + 1} ⥤ C ≌ C where\n  functor :=\n    { obj := fun F => F.obj ⟨⟨⟩⟩\n      map := fun θ => θ.app ⟨⟨⟩⟩ }\n  inverse := Functor.const _\n  unitIso := NatIso.ofComponents fun _ => Discrete.natIso fun _ => Iso.refl _\n  counitIso := NatIso.ofComponents Iso.refl\n\n"}
{"name":"CategoryTheory.Functor.equiv_counitIso","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Functor.equiv.counitIso (CategoryTheory.NatIso.ofComponents CategoryTheory.Iso.refl ⋯)","decl":"/-- Functors from `Discrete PUnit` are equivalent to the category itself. -/\n@[simps]\ndef equiv : Discrete PUnit.{w + 1} ⥤ C ≌ C where\n  functor :=\n    { obj := fun F => F.obj ⟨⟨⟩⟩\n      map := fun θ => θ.app ⟨⟨⟩⟩ }\n  inverse := Functor.const _\n  unitIso := NatIso.ofComponents fun _ => Discrete.natIso fun _ => Iso.refl _\n  counitIso := NatIso.ofComponents Iso.refl\n\n"}
{"name":"CategoryTheory.Functor.equiv_inverse","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq CategoryTheory.Functor.equiv.inverse (CategoryTheory.Functor.const (CategoryTheory.Discrete PUnit.{w + 1}))","decl":"/-- Functors from `Discrete PUnit` are equivalent to the category itself. -/\n@[simps]\ndef equiv : Discrete PUnit.{w + 1} ⥤ C ≌ C where\n  functor :=\n    { obj := fun F => F.obj ⟨⟨⟩⟩\n      map := fun θ => θ.app ⟨⟨⟩⟩ }\n  inverse := Functor.const _\n  unitIso := NatIso.ofComponents fun _ => Discrete.natIso fun _ => Iso.refl _\n  counitIso := NatIso.ofComponents Iso.refl\n\n"}
{"name":"CategoryTheory.equiv_punit_iff_unique","module":"Mathlib.CategoryTheory.PUnit","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Iff (Nonempty (CategoryTheory.Equivalence C (CategoryTheory.Discrete PUnit.{w + 1}))) (And (Nonempty C) (∀ (x y : C), Nonempty (Unique (Quiver.Hom x y))))","decl":"/-- A category being equivalent to `PUnit` is equivalent to it having a unique morphism between\n  any two objects. (In fact, such a category is also a groupoid;\n  see `CategoryTheory.Groupoid.ofHomUnique`) -/\ntheorem equiv_punit_iff_unique :\n    Nonempty (C ≌ Discrete PUnit.{w + 1}) ↔ Nonempty C ∧ ∀ x y : C, Nonempty <| Unique (x ⟶ y) := by\n  constructor\n  · rintro ⟨h⟩\n    refine ⟨⟨h.inverse.obj ⟨⟨⟩⟩⟩, fun x y => Nonempty.intro ?_⟩\n    let f : x ⟶ y := by\n      have hx : x ⟶ h.inverse.obj ⟨⟨⟩⟩ := by convert h.unit.app x\n      have hy : h.inverse.obj ⟨⟨⟩⟩ ⟶ y := by convert h.unitInv.app y\n      exact hx ≫ hy\n    suffices sub : Subsingleton (x ⟶ y) from uniqueOfSubsingleton f\n    have : ∀ z, z = h.unit.app x ≫ (h.functor ⋙ h.inverse).map z ≫ h.unitInv.app y := by\n      intro z\n      simp [congrArg (· ≫ h.unitInv.app y) (h.unit.naturality z)]\n    apply Subsingleton.intro\n    intro a b\n    rw [this a, this b]\n    simp only [Functor.comp_map]\n    congr 3\n    apply ULift.ext\n    simp [eq_iff_true_of_subsingleton]\n  · rintro ⟨⟨p⟩, h⟩\n    haveI := fun x y => (h x y).some\n    refine\n      Nonempty.intro\n        (CategoryTheory.Equivalence.mk ((Functor.const _).obj ⟨⟨⟩⟩)\n          ((@Functor.const <| Discrete PUnit).obj p) ?_ (by apply Functor.punitExt))\n    exact\n      NatIso.ofComponents fun _ =>\n        { hom := default\n          inv := default }\n\n"}
