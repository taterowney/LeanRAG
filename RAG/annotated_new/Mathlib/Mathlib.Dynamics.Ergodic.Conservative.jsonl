{"name":"MeasureTheory.Conservative.toQuasiMeasurePreserving","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.Conservative f μ\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving f μ μ","decl":"/-- We say that a non-singular (`MeasureTheory.QuasiMeasurePreserving`) self-map is\n*conservative* if for any measurable set `s` of positive measure there exists `x ∈ s` such that `x`\nreturns back to `s` under some iteration of `f`. -/\nstructure Conservative (f : α → α) (μ : Measure α) extends QuasiMeasurePreserving f μ μ : Prop where\n  /-- If `f` is a conservative self-map and `s` is a measurable set of nonzero measure,\n  then there exists a point `x ∈ s` that returns to `s` under a non-zero iteration of `f`. -/\n  exists_mem_iterate_mem' : ∀ ⦃s⦄, MeasurableSet s → μ s ≠ 0 → ∃ x ∈ s, ∃ m ≠ 0, f^[m] x ∈ s\n\n"}
{"name":"MeasureTheory.Conservative.exists_mem_iterate_mem'","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\nμ : MeasureTheory.Measure α\nself : MeasureTheory.Conservative f μ\ns : Set α\na✝¹ : MeasurableSet s\na✝ : Ne (μ s) 0\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun m => And (Ne m 0) (Membership.mem s (Nat.iterate f m x)))","decl":"/-- We say that a non-singular (`MeasureTheory.QuasiMeasurePreserving`) self-map is\n*conservative* if for any measurable set `s` of positive measure there exists `x ∈ s` such that `x`\nreturns back to `s` under some iteration of `f`. -/\nstructure Conservative (f : α → α) (μ : Measure α) extends QuasiMeasurePreserving f μ μ : Prop where\n  /-- If `f` is a conservative self-map and `s` is a measurable set of nonzero measure,\n  then there exists a point `x ∈ s` that returns to `s` under a non-zero iteration of `f`. -/\n  exists_mem_iterate_mem' : ∀ ⦃s⦄, MeasurableSet s → μ s ≠ 0 → ∃ x ∈ s, ∃ m ≠ 0, f^[m] x ∈ s\n\n"}
{"name":"MeasureTheory.MeasurePreserving.conservative","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nf : α → α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : MeasureTheory.MeasurePreserving f μ μ\n⊢ MeasureTheory.Conservative f μ","decl":"/-- A self-map preserving a finite measure is conservative. -/\nprotected theorem MeasurePreserving.conservative [IsFiniteMeasure μ] (h : MeasurePreserving f μ μ) :\n    Conservative f μ :=\n  ⟨h.quasiMeasurePreserving, fun _ hsm h0 => h.exists_mem_iterate_mem hsm.nullMeasurableSet h0⟩\n\n"}
{"name":"MeasureTheory.Conservative.id","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.Conservative id μ","decl":"/-- The identity map is conservative w.r.t. any measure. -/\nprotected theorem id (μ : Measure α) : Conservative id μ :=\n  { toQuasiMeasurePreserving := QuasiMeasurePreserving.id μ\n    exists_mem_iterate_mem' := fun _ _ h0 => by\n      simpa [exists_ne] using nonempty_of_measure_ne_zero h0 }\n\n"}
{"name":"MeasureTheory.Conservative.of_absolutelyContinuous","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\nμ ν : MeasureTheory.Measure α\nh : MeasureTheory.Conservative f μ\nhν : ν.AbsolutelyContinuous μ\nh' : MeasureTheory.Measure.QuasiMeasurePreserving f ν ν\n⊢ MeasureTheory.Conservative f ν","decl":"theorem of_absolutelyContinuous {ν : Measure α} (h : Conservative f μ) (hν : ν ≪ μ)\n    (h' : QuasiMeasurePreserving f ν ν) : Conservative f ν :=\n  ⟨h', fun _ hsm h0 ↦ h.exists_mem_iterate_mem' hsm (mt (@hν _) h0)⟩\n\n"}
{"name":"MeasureTheory.Conservative.measureRestrict","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.Conservative f μ\nhs : Set.MapsTo f s s\n⊢ MeasureTheory.Conservative f (μ.restrict s)","decl":"/-- Restriction of a conservative system to an invariant set is a conservative system,\nformulated in terms of the restriction of the measure. -/\ntheorem measureRestrict (h : Conservative f μ) (hs : MapsTo f s s) :\n    Conservative f (μ.restrict s) :=\n  .of_absolutelyContinuous h (absolutelyContinuous_of_le restrict_le_self) <|\n    h.toQuasiMeasurePreserving.restrict hs\n\n"}
{"name":"MeasureTheory.Conservative.exists_mem_iterate_mem","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nhsm : MeasureTheory.NullMeasurableSet s μ\nhs₀ : Ne (μ s) 0\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun m => And (Ne m 0) (Membership.mem s (Nat.iterate f m x)))","decl":"/-- If `f` is a conservative self-map and `s` is a null measurable set of nonzero measure,\nthen there exists a point `x ∈ s` that returns to `s` under a non-zero iteration of `f`. -/\ntheorem exists_mem_iterate_mem (hf : Conservative f μ)\n    (hsm : NullMeasurableSet s μ) (hs₀ : μ s ≠ 0) :\n    ∃ x ∈ s, ∃ m ≠ 0, f^[m] x ∈ s := by\n  rcases hsm.exists_measurable_subset_ae_eq with ⟨t, hsub, htm, hts⟩\n  rcases hf.exists_mem_iterate_mem' htm (by rwa [measure_congr hts]) with ⟨x, hxt, m, hm₀, hmt⟩\n  exact ⟨x, hsub hxt, m, hm₀, hsub hmt⟩\n\n"}
{"name":"MeasureTheory.Conservative.frequently_measure_inter_ne_zero","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nhs : MeasureTheory.NullMeasurableSet s μ\nh0 : Ne (μ s) 0\n⊢ Filter.Frequently (fun m => Ne (μ (Inter.inter s (Set.preimage (Nat.iterate f m) s))) 0) Filter.atTop","decl":"/-- If `f` is a conservative map and `s` is a measurable set of nonzero measure, then\nfor infinitely many values of `m` a positive measure of points `x ∈ s` returns back to `s`\nafter `m` iterations of `f`. -/\ntheorem frequently_measure_inter_ne_zero (hf : Conservative f μ) (hs : NullMeasurableSet s μ)\n    (h0 : μ s ≠ 0) : ∃ᶠ m in atTop, μ (s ∩ f^[m] ⁻¹' s) ≠ 0 := by\n  set t : ℕ → Set α := fun n ↦ s ∩ f^[n] ⁻¹' s\n  -- Assume that `μ (t n) ≠ 0`, where `t n = s ∩ f^[n] ⁻¹' s`, only for finitely many `n`.\n  by_contra H\n  -- Let `N` be the maximal `n` such that `μ (t n) ≠ 0`.\n  obtain ⟨N, hN, hmax⟩ : ∃ N, μ (t N) ≠ 0 ∧ ∀ n > N, μ (t n) = 0 := by\n    rw [Nat.frequently_atTop_iff_infinite, not_infinite] at H\n    convert exists_max_image _ (·) H ⟨0, by simpa⟩ using 4\n    rw [gt_iff_lt, ← not_le, not_imp_comm, mem_setOf]\n  have htm {n : ℕ} : NullMeasurableSet (t n) μ :=\n    hs.inter <| hs.preimage <| hf.toQuasiMeasurePreserving.iterate n\n  -- Then all `t n`, `n > N`, are null sets, hence `T = t N \\ ⋃ n > N, t n` has positive measure.\n  set T := t N \\ ⋃ n > N, t n with hT\n  have hμT : μ T ≠ 0 := by\n    rwa [hT, measure_diff_null]\n    exact (measure_biUnion_null_iff {n | N < n}.to_countable).2 hmax\n  have hTm : NullMeasurableSet T μ := htm.diff <| .biUnion {n | N < n}.to_countable fun _ _ ↦ htm\n  -- Take `x ∈ T` and `m ≠ 0` such that `f^[m] x ∈ T`.\n  rcases hf.exists_mem_iterate_mem hTm hμT with ⟨x, hxt, m, hm₀, hmt⟩\n  -- Then `N + m > N`, `x ∈ s`, and `f^[N + m] x = f^[N] (f^[m] x) ∈ s`.\n  -- This contradicts `x ∈ T ⊆ (⋃ n > N, t n)ᶜ`.\n  refine hxt.2 <| mem_iUnion₂.2 ⟨N + m, ?_, hxt.1.1, ?_⟩\n  · simpa [pos_iff_ne_zero]\n  · simpa only [iterate_add] using hmt.1.2\n\n"}
{"name":"MeasureTheory.Conservative.exists_gt_measure_inter_ne_zero","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nhs : MeasureTheory.NullMeasurableSet s μ\nh0 : Ne (μ s) 0\nN : Nat\n⊢ Exists fun m => And (GT.gt m N) (Ne (μ (Inter.inter s (Set.preimage (Nat.iterate f m) s))) 0)","decl":"/-- If `f` is a conservative map and `s` is a measurable set of nonzero measure, then\nfor an arbitrarily large `m` a positive measure of points `x ∈ s` returns back to `s`\nafter `m` iterations of `f`. -/\ntheorem exists_gt_measure_inter_ne_zero (hf : Conservative f μ) (hs : NullMeasurableSet s μ)\n    (h0 : μ s ≠ 0) (N : ℕ) : ∃ m > N, μ (s ∩ f^[m] ⁻¹' s) ≠ 0 :=\n  let ⟨m, hm, hmN⟩ :=\n    ((hf.frequently_measure_inter_ne_zero hs h0).and_eventually (eventually_gt_atTop N)).exists\n  ⟨m, hmN, hm⟩\n\n"}
{"name":"MeasureTheory.Conservative.measure_mem_forall_ge_image_not_mem_eq_zero","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nhs : MeasureTheory.NullMeasurableSet s μ\nn : Nat\n⊢ Eq (μ (setOf fun x => And (Membership.mem s x) (∀ (m : Nat), GE.ge m n → Not (Membership.mem s (Nat.iterate f m x))))) 0","decl":"/-- Poincaré recurrence theorem: given a conservative map `f` and a measurable set `s`, the set\nof points `x ∈ s` such that `x` does not return to `s` after `≥ n` iterations has measure zero. -/\ntheorem measure_mem_forall_ge_image_not_mem_eq_zero (hf : Conservative f μ)\n    (hs : NullMeasurableSet s μ) (n : ℕ) :\n    μ ({ x ∈ s | ∀ m ≥ n, f^[m] x ∉ s }) = 0 := by\n  by_contra H\n  have : NullMeasurableSet (s ∩ { x | ∀ m ≥ n, f^[m] x ∉ s }) μ := by\n    simp only [setOf_forall, ← compl_setOf]\n    exact hs.inter <| .biInter (to_countable _) fun m _ ↦\n      (hs.preimage <| hf.toQuasiMeasurePreserving.iterate m).compl\n  rcases (hf.exists_gt_measure_inter_ne_zero this H) n with ⟨m, hmn, hm⟩\n  rcases nonempty_of_measure_ne_zero hm with ⟨x, ⟨_, hxn⟩, hxm, -⟩\n  exact hxn m hmn.lt.le hxm\n\n"}
{"name":"MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Filter.Eventually (fun x => Membership.mem s x → Filter.Frequently (fun n => Membership.mem s (Nat.iterate f n x)) Filter.atTop) (MeasureTheory.ae μ)","decl":"/-- Poincaré recurrence theorem: given a conservative map `f` and a measurable set `s`,\nalmost every point `x ∈ s` returns back to `s` infinitely many times. -/\ntheorem ae_mem_imp_frequently_image_mem (hf : Conservative f μ) (hs : NullMeasurableSet s μ) :\n    ∀ᵐ x ∂μ, x ∈ s → ∃ᶠ n in atTop, f^[n] x ∈ s := by\n  simp only [frequently_atTop, @forall_swap (_ ∈ s), ae_all_iff]\n  intro n\n  filter_upwards [measure_zero_iff_ae_nmem.1 (hf.measure_mem_forall_ge_image_not_mem_eq_zero hs n)]\n  simp\n\n"}
{"name":"MeasureTheory.Conservative.inter_frequently_image_mem_ae_eq","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (Inter.inter s (setOf fun x => Filter.Frequently (fun n => Membership.mem s (Nat.iterate f n x)) Filter.atTop)) s","decl":"theorem inter_frequently_image_mem_ae_eq (hf : Conservative f μ) (hs : NullMeasurableSet s μ) :\n    (s ∩ { x | ∃ᶠ n in atTop, f^[n] x ∈ s } : Set α) =ᵐ[μ] s :=\n  inter_eventuallyEq_left.2 <| hf.ae_mem_imp_frequently_image_mem hs\n\n"}
{"name":"MeasureTheory.Conservative.measure_inter_frequently_image_mem_eq","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Eq (μ (Inter.inter s (setOf fun x => Filter.Frequently (fun n => Membership.mem s (Nat.iterate f n x)) Filter.atTop))) (μ s)","decl":"theorem measure_inter_frequently_image_mem_eq (hf : Conservative f μ) (hs : NullMeasurableSet s μ) :\n    μ (s ∩ { x | ∃ᶠ n in atTop, f^[n] x ∈ s }) = μ s :=\n  measure_congr (hf.inter_frequently_image_mem_ae_eq hs)\n\n"}
{"name":"MeasureTheory.Conservative.ae_forall_image_mem_imp_frequently_image_mem","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Filter.Eventually (fun x => ∀ (k : Nat), Membership.mem s (Nat.iterate f k x) → Filter.Frequently (fun n => Membership.mem s (Nat.iterate f n x)) Filter.atTop) (MeasureTheory.ae μ)","decl":"/-- Poincaré recurrence theorem: if `f` is a conservative dynamical system and `s` is a measurable\nset, then for `μ`-a.e. `x`, if the orbit of `x` visits `s` at least once, then it visits `s`\ninfinitely many times. -/\ntheorem ae_forall_image_mem_imp_frequently_image_mem (hf : Conservative f μ)\n    (hs : NullMeasurableSet s μ) : ∀ᵐ x ∂μ, ∀ k, f^[k] x ∈ s → ∃ᶠ n in atTop, f^[n] x ∈ s := by\n  refine ae_all_iff.2 fun k => ?_\n  refine (hf.ae_mem_imp_frequently_image_mem\n    (hs.preimage <| hf.toQuasiMeasurePreserving.iterate k)).mono fun x hx hk => ?_\n  rw [← map_add_atTop_eq_nat k, frequently_map]\n  refine (hx hk).mono fun n hn => ?_\n  rwa [add_comm, iterate_add_apply]\n\n"}
{"name":"MeasureTheory.Conservative.frequently_ae_mem_and_frequently_image_mem","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\ns : Set α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nhs : MeasureTheory.NullMeasurableSet s μ\nh0 : Ne (μ s) 0\n⊢ Filter.Frequently (fun x => And (Membership.mem s x) (Filter.Frequently (fun n => Membership.mem s (Nat.iterate f n x)) Filter.atTop)) (MeasureTheory.ae μ)","decl":"/-- If `f` is a conservative self-map and `s` is a measurable set of positive measure, then\n`ae μ`-frequently we have `x ∈ s` and `s` returns to `s` under infinitely many iterations of `f`. -/\ntheorem frequently_ae_mem_and_frequently_image_mem (hf : Conservative f μ)\n    (hs : NullMeasurableSet s μ) (h0 : μ s ≠ 0) : ∃ᵐ x ∂μ, x ∈ s ∧ ∃ᶠ n in atTop, f^[n] x ∈ s :=\n  ((frequently_ae_mem_iff.2 h0).and_eventually (hf.ae_mem_imp_frequently_image_mem hs)).mono\n    fun _ hx => ⟨hx.1, hx.2 hx.1⟩\n\n"}
{"name":"MeasureTheory.Conservative.ae_frequently_mem_of_mem_nhds","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝³ : MeasurableSpace α\ninst✝² : TopologicalSpace α\ninst✝¹ : SecondCountableTopology α\ninst✝ : OpensMeasurableSpace α\nf : α → α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.Conservative f μ\n⊢ Filter.Eventually (fun x => ∀ (s : Set α), Membership.mem (nhds x) s → Filter.Frequently (fun n => Membership.mem s (Nat.iterate f n x)) Filter.atTop) (MeasureTheory.ae μ)","decl":"/-- Poincaré recurrence theorem. Let `f : α → α` be a conservative dynamical system on a topological\nspace with second countable topology and measurable open sets. Then almost every point `x : α`\nis recurrent: it visits every neighborhood `s ∈ 𝓝 x` infinitely many times. -/\ntheorem ae_frequently_mem_of_mem_nhds [TopologicalSpace α] [SecondCountableTopology α]\n    [OpensMeasurableSpace α] {f : α → α} {μ : Measure α} (h : Conservative f μ) :\n    ∀ᵐ x ∂μ, ∀ s ∈ 𝓝 x, ∃ᶠ n in atTop, f^[n] x ∈ s := by\n  have : ∀ s ∈ countableBasis α, ∀ᵐ x ∂μ, x ∈ s → ∃ᶠ n in atTop, f^[n] x ∈ s := fun s hs =>\n    h.ae_mem_imp_frequently_image_mem (isOpen_of_mem_countableBasis hs).nullMeasurableSet\n  refine ((ae_ball_iff <| countable_countableBasis α).2 this).mono fun x hx s hs => ?_\n  rcases (isBasis_countableBasis α).mem_nhds_iff.1 hs with ⟨o, hoS, hxo, hos⟩\n  exact (hx o hoS hxo).mono fun n hn => hos hn\n\n"}
{"name":"MeasureTheory.Conservative.iterate","module":"Mathlib.Dynamics.Ergodic.Conservative","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.Conservative f μ\nn : Nat\n⊢ MeasureTheory.Conservative (Nat.iterate f n) μ","decl":"/-- Iteration of a conservative system is a conservative system. -/\nprotected theorem iterate (hf : Conservative f μ) (n : ℕ) : Conservative f^[n] μ := by\n  -- Discharge the trivial case `n = 0`\n  cases' n with n\n  · exact Conservative.id μ\n  refine ⟨hf.1.iterate _, fun s hs hs0 => ?_⟩\n  rcases (hf.frequently_ae_mem_and_frequently_image_mem hs.nullMeasurableSet hs0).exists\n    with ⟨x, _, hx⟩\n  /- We take a point `x ∈ s` such that `f^[k] x ∈ s` for infinitely many values of `k`,\n    then we choose two of these values `k < l` such that `k ≡ l [MOD (n + 1)]`.\n    Then `f^[k] x ∈ s` and `f^[n + 1]^[(l - k) / (n + 1)] (f^[k] x) = f^[l] x ∈ s`. -/\n  rw [Nat.frequently_atTop_iff_infinite] at hx\n  rcases Nat.exists_lt_modEq_of_infinite hx n.succ_pos with ⟨k, hk, l, hl, hkl, hn⟩\n  set m := (l - k) / (n + 1)\n  have : (n + 1) * m = l - k := by\n    apply Nat.mul_div_cancel'\n    exact (Nat.modEq_iff_dvd' hkl.le).1 hn\n  refine ⟨f^[k] x, hk, m, ?_, ?_⟩\n  · intro hm\n    rw [hm, mul_zero, eq_comm, tsub_eq_zero_iff_le] at this\n    exact this.not_lt hkl\n  · rwa [← iterate_mul, this, ← iterate_add_apply, tsub_add_cancel_of_le]\n    exact hkl.le\n\n"}
