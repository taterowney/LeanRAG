{"name":"DivisibleBy.div_zero","module":"Mathlib.GroupTheory.Divisible","initialProofState":"A : Type u_1\nα : Type u_2\ninst✝² : AddMonoid A\ninst✝¹ : SMul α A\ninst✝ : Zero α\nself : DivisibleBy A α\na : A\n⊢ Eq (DivisibleBy.div a 0) 0","decl":"/--\nAn `AddMonoid A` is `α`-divisible iff `n • x = a` has a solution for all `n ≠ 0 ∈ α` and `a ∈ A`.\nHere we adopt a constructive approach where we ask an explicit `div : A → α → A` function such that\n* `div a 0 = 0` for all `a ∈ A`\n* `n • div a n = a` for all `n ≠ 0 ∈ α` and `a ∈ A`.\n-/\nclass DivisibleBy where\n  div : A → α → A\n  div_zero : ∀ a, div a 0 = 0\n  div_cancel : ∀ {n : α} (a : A), n ≠ 0 → n • div a n = a\n\n"}
{"name":"DivisibleBy.div_cancel","module":"Mathlib.GroupTheory.Divisible","initialProofState":"A : Type u_1\nα : Type u_2\ninst✝² : AddMonoid A\ninst✝¹ : SMul α A\ninst✝ : Zero α\nself : DivisibleBy A α\nn : α\na : A\na✝ : Ne n 0\n⊢ Eq (HSMul.hSMul n (DivisibleBy.div a n)) a","decl":"/--\nAn `AddMonoid A` is `α`-divisible iff `n • x = a` has a solution for all `n ≠ 0 ∈ α` and `a ∈ A`.\nHere we adopt a constructive approach where we ask an explicit `div : A → α → A` function such that\n* `div a 0 = 0` for all `a ∈ A`\n* `n • div a n = a` for all `n ≠ 0 ∈ α` and `a ∈ A`.\n-/\nclass DivisibleBy where\n  div : A → α → A\n  div_zero : ∀ a, div a 0 = 0\n  div_cancel : ∀ {n : α} (a : A), n ≠ 0 → n • div a n = a\n\n"}
{"name":"RootableBy.root_cancel","module":"Mathlib.GroupTheory.Divisible","initialProofState":"A : Type u_1\nα : Type u_2\ninst✝² : Monoid A\ninst✝¹ : Pow A α\ninst✝ : Zero α\nself : RootableBy A α\nn : α\na : A\na✝ : Ne n 0\n⊢ Eq (HPow.hPow (RootableBy.root a n) n) a","decl":"/-- A `Monoid A` is `α`-rootable iff `xⁿ = a` has a solution for all `n ≠ 0 ∈ α` and `a ∈ A`.\nHere we adopt a constructive approach where we ask an explicit `root : A → α → A` function such that\n* `root a 0 = 1` for all `a ∈ A`\n* `(root a n)ⁿ = a` for all `n ≠ 0 ∈ α` and `a ∈ A`.\n-/\n@[to_additive]\nclass RootableBy where\n  root : A → α → A\n  root_zero : ∀ a, root a 0 = 1\n  root_cancel : ∀ {n : α} (a : A), n ≠ 0 → root a n ^ n = a\n\n"}
{"name":"RootableBy.root_zero","module":"Mathlib.GroupTheory.Divisible","initialProofState":"A : Type u_1\nα : Type u_2\ninst✝² : Monoid A\ninst✝¹ : Pow A α\ninst✝ : Zero α\nself : RootableBy A α\na : A\n⊢ Eq (RootableBy.root a 0) 1","decl":"/-- A `Monoid A` is `α`-rootable iff `xⁿ = a` has a solution for all `n ≠ 0 ∈ α` and `a ∈ A`.\nHere we adopt a constructive approach where we ask an explicit `root : A → α → A` function such that\n* `root a 0 = 1` for all `a ∈ A`\n* `(root a n)ⁿ = a` for all `n ≠ 0 ∈ α` and `a ∈ A`.\n-/\n@[to_additive]\nclass RootableBy where\n  root : A → α → A\n  root_zero : ∀ a, root a 0 = 1\n  root_cancel : ∀ {n : α} (a : A), n ≠ 0 → root a n ^ n = a\n\n"}
{"name":"smul_right_surj_of_divisibleBy","module":"Mathlib.GroupTheory.Divisible","initialProofState":"A : Type u_1\nα : Type u_2\ninst✝³ : AddMonoid A\ninst✝² : SMul α A\ninst✝¹ : Zero α\ninst✝ : DivisibleBy A α\nn : α\nhn : Ne n 0\n⊢ Function.Surjective fun a => HSMul.hSMul n a","decl":"@[to_additive smul_right_surj_of_divisibleBy]\ntheorem pow_left_surj_of_rootableBy [RootableBy A α] {n : α} (hn : n ≠ 0) :\n    Function.Surjective (fun a => a ^ n : A → A) := fun x =>\n  ⟨RootableBy.root x n, RootableBy.root_cancel _ hn⟩\n\n"}
{"name":"pow_left_surj_of_rootableBy","module":"Mathlib.GroupTheory.Divisible","initialProofState":"A : Type u_1\nα : Type u_2\ninst✝³ : Monoid A\ninst✝² : Pow A α\ninst✝¹ : Zero α\ninst✝ : RootableBy A α\nn : α\nhn : Ne n 0\n⊢ Function.Surjective fun a => HPow.hPow a n","decl":"@[to_additive smul_right_surj_of_divisibleBy]\ntheorem pow_left_surj_of_rootableBy [RootableBy A α] {n : α} (hn : n ≠ 0) :\n    Function.Surjective (fun a => a ^ n : A → A) := fun x =>\n  ⟨RootableBy.root x n, RootableBy.root_cancel _ hn⟩\n\n"}
{"name":"AddCommGroup.smul_top_eq_top_of_divisibleBy_int","module":"Mathlib.GroupTheory.Divisible","initialProofState":"A : Type u_1\ninst✝¹ : AddCommGroup A\ninst✝ : DivisibleBy A Int\nn : Int\nhn : Ne n 0\n⊢ Eq (HSMul.hSMul n Top.top) Top.top","decl":"theorem smul_top_eq_top_of_divisibleBy_int [DivisibleBy A ℤ] {n : ℤ} (hn : n ≠ 0) :\n    n • (⊤ : AddSubgroup A) = ⊤ :=\n  AddSubgroup.map_top_of_surjective _ fun a => ⟨DivisibleBy.div a n, DivisibleBy.div_cancel _ hn⟩\n\n"}
{"name":"DivisibleBy.surjective_smul","module":"Mathlib.GroupTheory.Divisible","initialProofState":"A : Type u_4\nα : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : SMul α A\ninst✝¹ : Zero α\ninst✝ : DivisibleBy A α\nn : α\nhn : Ne n 0\n⊢ Function.Surjective fun a => HSMul.hSMul n a","decl":"@[to_additive DivisibleBy.surjective_smul]\ntheorem RootableBy.surjective_pow (A α : Type*) [Monoid A] [Pow A α] [Zero α] [RootableBy A α]\n    {n : α} (hn : n ≠ 0) : Function.Surjective fun a : A => a ^ n := fun a =>\n  ⟨RootableBy.root a n, RootableBy.root_cancel a hn⟩\n\n"}
{"name":"RootableBy.surjective_pow","module":"Mathlib.GroupTheory.Divisible","initialProofState":"A : Type u_4\nα : Type u_5\ninst✝³ : Monoid A\ninst✝² : Pow A α\ninst✝¹ : Zero α\ninst✝ : RootableBy A α\nn : α\nhn : Ne n 0\n⊢ Function.Surjective fun a => HPow.hPow a n","decl":"@[to_additive DivisibleBy.surjective_smul]\ntheorem RootableBy.surjective_pow (A α : Type*) [Monoid A] [Pow A α] [Zero α] [RootableBy A α]\n    {n : α} (hn : n ≠ 0) : Function.Surjective fun a : A => a ^ n := fun a =>\n  ⟨RootableBy.root a n, RootableBy.root_cancel a hn⟩\n\n"}
