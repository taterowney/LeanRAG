{"name":"MvFunctor.of_mem_supp","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nF : TypeVec.{u} n → Type v\ninst✝ : MvFunctor F\nα : TypeVec.{u} n\nx : F α\nP : ⦃i : Fin2 n⦄ → α i → Prop\nh : MvFunctor.LiftP P x\ni : Fin2 n\ny : α i\na✝ : Membership.mem (MvFunctor.supp x i) y\n⊢ P y","decl":"theorem of_mem_supp {α : TypeVec n} {x : F α} {P : ∀ ⦃i⦄, α i → Prop} (h : LiftP P x) (i : Fin2 n) :\n    ∀ y ∈ supp x i, P y := fun _y hy => hy h\n\n"}
{"name":"LawfulMvFunctor.id_map","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nF : TypeVec.{u_2} n → Type u_1\ninst✝ : MvFunctor F\nself : LawfulMvFunctor F\nα : TypeVec.{u_2} n\nx : F α\n⊢ Eq (MvFunctor.map TypeVec.id x) x","decl":"/-- laws for `MvFunctor` -/\nclass LawfulMvFunctor {n : ℕ} (F : TypeVec n → Type*) [MvFunctor F] : Prop where\n  /-- `map` preserved identities, i.e., maps identity on `α` to identity on `F α` -/\n  id_map : ∀ {α : TypeVec n} (x : F α), TypeVec.id <$$> x = x\n  /-- `map` preserves compositions -/\n  comp_map :\n    ∀ {α β γ : TypeVec n} (g : α ⟹ β) (h : β ⟹ γ) (x : F α), (h ⊚ g) <$$> x = h <$$> g <$$> x\n\n"}
{"name":"LawfulMvFunctor.comp_map","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nF : TypeVec.{u_2} n → Type u_1\ninst✝ : MvFunctor F\nself : LawfulMvFunctor F\nα β γ : TypeVec.{u_2} n\ng : α.Arrow β\nh : β.Arrow γ\nx : F α\n⊢ Eq (MvFunctor.map (TypeVec.comp h g) x) (MvFunctor.map h (MvFunctor.map g x))","decl":"/-- laws for `MvFunctor` -/\nclass LawfulMvFunctor {n : ℕ} (F : TypeVec n → Type*) [MvFunctor F] : Prop where\n  /-- `map` preserved identities, i.e., maps identity on `α` to identity on `F α` -/\n  id_map : ∀ {α : TypeVec n} (x : F α), TypeVec.id <$$> x = x\n  /-- `map` preserves compositions -/\n  comp_map :\n    ∀ {α β γ : TypeVec n} (g : α ⟹ β) (h : β ⟹ γ) (x : F α), (h ⊚ g) <$$> x = h <$$> g <$$> x\n\n"}
{"name":"MvFunctor.id_map","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nα : TypeVec.{u} n\nF : TypeVec.{u} n → Type v\ninst✝¹ : MvFunctor F\ninst✝ : LawfulMvFunctor F\nx : F α\n⊢ Eq (MvFunctor.map TypeVec.id x) x","decl":"@[simp]\ntheorem id_map (x : F α) : TypeVec.id <$$> x = x :=\n  LawfulMvFunctor.id_map x\n\n"}
{"name":"MvFunctor.id_map'","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nα : TypeVec.{u} n\nF : TypeVec.{u} n → Type v\ninst✝¹ : MvFunctor F\ninst✝ : LawfulMvFunctor F\nx : F α\n⊢ Eq (MvFunctor.map (fun _i a => a) x) x","decl":"@[simp]\ntheorem id_map' (x : F α) : (fun _i a => a) <$$> x = x :=\n  id_map x\n\n"}
{"name":"MvFunctor.map_map","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nα β γ : TypeVec.{u} n\nF : TypeVec.{u} n → Type v\ninst✝¹ : MvFunctor F\ninst✝ : LawfulMvFunctor F\ng : α.Arrow β\nh : β.Arrow γ\nx : F α\n⊢ Eq (MvFunctor.map h (MvFunctor.map g x)) (MvFunctor.map (TypeVec.comp h g) x)","decl":"theorem map_map (g : α ⟹ β) (h : β ⟹ γ) (x : F α) : h <$$> g <$$> x = (h ⊚ g) <$$> x :=\n  Eq.symm <| comp_map _ _ _\n\n"}
{"name":"MvFunctor.exists_iff_exists_of_mono","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nα β : TypeVec.{u} n\nF : TypeVec.{u} n → Type v\ninst✝¹ : MvFunctor F\ninst✝ : LawfulMvFunctor F\nP : F α → Prop\nq : F β → Prop\nf : α.Arrow β\ng : β.Arrow α\nh₀ : Eq (TypeVec.comp f g) TypeVec.id\nh₁ : ∀ (u : F α), Iff (P u) (q (MvFunctor.map f u))\n⊢ Iff (Exists fun u => P u) (Exists fun u => q u)","decl":"theorem exists_iff_exists_of_mono {P : F α → Prop} {q : F β → Prop}\n    (f : α ⟹ β) (g : β ⟹ α)\n    (h₀ : f ⊚ g = TypeVec.id)\n    (h₁ : ∀ u : F α, P u ↔ q (f <$$> u)) :\n    (∃ u : F α, P u) ↔ ∃ u : F β, q u := by\n  constructor <;> rintro ⟨u, h₂⟩\n  · refine ⟨f <$$> u, ?_⟩\n    apply (h₁ u).mp h₂\n  · refine ⟨g <$$> u, ?_⟩\n    rw [h₁]\n    simp only [MvFunctor.map_map, h₀, LawfulMvFunctor.id_map, h₂]\n\n"}
{"name":"MvFunctor.LiftP_def","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nα : TypeVec.{u} n\nF : TypeVec.{u} n → Type v\ninst✝¹ : MvFunctor F\nP : α.Arrow (TypeVec.repeat n Prop)\ninst✝ : LawfulMvFunctor F\nx : F α\n⊢ Iff (MvFunctor.LiftP' P x) (Exists fun u => Eq (MvFunctor.map (TypeVec.subtypeVal P) u) x)","decl":"theorem LiftP_def (x : F α) : LiftP' P x ↔ ∃ u : F (Subtype_ P), subtypeVal P <$$> u = x :=\n  exists_iff_exists_of_mono F _ _ (toSubtype_of_subtype P) (by simp [MvFunctor.map_map])\n\n"}
{"name":"MvFunctor.LiftR_def","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nα : TypeVec.{u} n\nF : TypeVec.{u} n → Type v\ninst✝¹ : MvFunctor F\nR : (α.prod α).Arrow (TypeVec.repeat n Prop)\ninst✝ : LawfulMvFunctor F\nx y : F α\n⊢ Iff (MvFunctor.LiftR' R x y) (Exists fun u => And (Eq (MvFunctor.map (TypeVec.comp TypeVec.prod.fst (TypeVec.subtypeVal R)) u) x) (Eq (MvFunctor.map (TypeVec.comp TypeVec.prod.snd (TypeVec.subtypeVal R)) u) y))","decl":"theorem LiftR_def (x y : F α) :\n    LiftR' R x y ↔\n      ∃ u : F (Subtype_ R),\n        (TypeVec.prod.fst ⊚ subtypeVal R) <$$> u = x ∧\n          (TypeVec.prod.snd ⊚ subtypeVal R) <$$> u = y :=\n  exists_iff_exists_of_mono _ _ _ (toSubtype'_of_subtype' R) (by\n    simp only [map_map, comp_assoc, subtypeVal_toSubtype']\n    simp (config := { unfoldPartialApp := true }) [comp])\n\n"}
{"name":"MvFunctor.LiftP_PredLast_iff","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u_1\ninst✝¹ : MvFunctor F\ninst✝ : LawfulMvFunctor F\nα : TypeVec.{u} n\nβ : Type u\nP : β → Prop\nx : F (α.append1 β)\n⊢ Iff (MvFunctor.LiftP' (α.PredLast' P) x) (MvFunctor.LiftP (α.PredLast P) x)","decl":"theorem LiftP_PredLast_iff {β} (P : β → Prop) (x : F (α ::: β)) :\n    LiftP' (PredLast' _ P) x ↔ LiftP (PredLast _ P) x := by\n  dsimp only [LiftP, LiftP']\n  apply exists_iff_exists_of_mono F (f _ n α) (g _ n α)\n  · ext i ⟨x, _⟩\n    cases i <;> rfl\n  · intros\n    rw [MvFunctor.map_map]\n    dsimp (config := { unfoldPartialApp := true }) [(· ⊚ ·)]\n    suffices (fun i => Subtype.val) = (fun i x => (MvFunctor.f P n α i x).val) by rw [this]\n    ext i ⟨x, _⟩\n    cases i <;> rfl\n\n"}
{"name":"MvFunctor.LiftR_RelLast_iff","module":"Mathlib.Control.Functor.Multivariate","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u_1\ninst✝¹ : MvFunctor F\ninst✝ : LawfulMvFunctor F\nα : TypeVec.{u} n\nβ : Type u\nrr : β → β → Prop\nx y : F (α.append1 β)\n⊢ Iff (MvFunctor.LiftR' (α.RelLast' rr) x y) (MvFunctor.LiftR (fun {i} => α.RelLast rr) x y)","decl":"theorem LiftR_RelLast_iff (x y : F (α ::: β)) :\n    LiftR' (RelLast' _ rr) x y ↔ LiftR (RelLast (i := _) _ rr) x y := by\n  dsimp only [LiftR, LiftR']\n  apply exists_iff_exists_of_mono F (f' rr _ _) (g' rr _ _)\n  · ext i ⟨x, _⟩ : 2\n    cases i <;> rfl\n  · intros\n    simp (config := { unfoldPartialApp := true }) only [map_map, TypeVec.comp]\n    -- Porting note: proof was\n    -- rw [MvFunctor.map_map, MvFunctor.map_map, (· ⊚ ·), (· ⊚ ·)]\n    -- congr <;> ext i ⟨x, _⟩ <;> cases i <;> rfl\n    suffices (fun i t => t.val.fst) = ((fun i x => (MvFunctor.f' rr n α i x).val.fst))\n            ∧ (fun i t => t.val.snd) = ((fun i x => (MvFunctor.f' rr n α i x).val.snd)) by\n      rw [this.1, this.2]\n    constructor <;> ext i ⟨x, _⟩ <;> cases i <;> rfl\n\n"}
