{"name":"List.list_reverse_induction","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\np : List α → Prop\nbase : p List.nil\nind : ∀ (l : List α) (e : α), p l → p (HAppend.hAppend l (List.cons e List.nil))\nl : List α\n⊢ p l","decl":"@[deprecated reverseRecOn (since := \"2025-01-28\")]\ntheorem list_reverse_induction (p : List α → Prop) (base : p [])\n    (ind : ∀ (l : List α) (e : α), p l → p (l ++ [e])) : (∀ (l : List α), p l) :=\n  fun l => l.reverseRecOn base ind\n\n"}
{"name":"List.mapIdxGo_length","module":"Mathlib.Data.List.Indexes","initialProofState":"β : Type u_1\nα✝ : Type u_2\nf : Nat → α✝ → β\nl : List α✝\narr : Array β\n⊢ Eq (List.mapIdx.go f l arr).length (HAdd.hAdd l.length arr.size)","decl":"@[deprecated (since := \"2024-10-15\")] alias mapIdxGo_length := mapIdx_go_length\n\n"}
{"name":"List.mapIdx_append_one","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β\nl : List α\ne : α\n⊢ Eq (List.mapIdx f (HAppend.hAppend l (List.cons e List.nil))) (HAppend.hAppend (List.mapIdx f l) (List.cons (f l.length e) List.nil))","decl":"theorem mapIdx_append_one : ∀ {f : ℕ → α → β} {l : List α} {e : α},\n    mapIdx f (l ++ [e]) = mapIdx f l ++ [f l.length e] :=\n  mapIdx_concat\n\n"}
{"name":"List.map_enumFrom_eq_zipWith","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nl : List α\nn : Nat\nf : Nat → α → β\n⊢ Eq (List.map (Function.uncurry f) (List.enumFrom n l)) (List.zipWith (fun i => f (HAdd.hAdd i n)) (List.range l.length) l)","decl":"@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\"), local simp]\ntheorem map_enumFrom_eq_zipWith : ∀ (l : List α) (n : ℕ) (f : ℕ → α → β),\n    map (uncurry f) (enumFrom n l) = zipWith (fun i ↦ f (i + n)) (range (length l)) l := by\n  intro l\n  generalize e : l.length = len\n  revert l\n  induction' len with len ih <;> intros l e n f\n  · have : l = [] := by\n      cases l\n      · rfl\n      · contradiction\n    rw [this]; rfl\n  · cases' l with head tail\n    · contradiction\n    · simp only [enumFrom_cons, map_cons, range_succ_eq_map, zipWith_cons_cons,\n        Nat.zero_add, zipWith_map_left, true_and]\n      rw [ih]\n      · suffices (fun i ↦ f (i + (n + 1))) = ((fun i ↦ f (i + n)) ∘ Nat.succ) by\n          rw [this]\n          rfl\n        funext n' a\n        simp only [comp, Nat.add_assoc, Nat.add_comm, Nat.add_succ]\n      simp only [length_cons, Nat.succ.injEq] at e; exact e\n\n"}
{"name":"List.mapIdx_eq_nil","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u_1\nα✝ : Type u_2\nf : Nat → α → α✝\nl : List α\n⊢ Iff (Eq (List.mapIdx f l) List.nil) (Eq l List.nil)","decl":"@[deprecated (since := \"2024-10-15\")] alias mapIdx_eq_nil := mapIdx_eq_nil_iff\n\n"}
{"name":"List.get_mapIdx","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf : Nat → α → β\ni : Nat\nh : LT.lt i l.length\nh' : optParam (LT.lt i (List.mapIdx f l).length) ⋯\n⊢ Eq ((List.mapIdx f l).get ⟨i, h'⟩) (f i (l.get ⟨i, h⟩))","decl":"@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem get_mapIdx (l : List α) (f : ℕ → α → β) (i : ℕ) (h : i < l.length)\n    (h' : i < (l.mapIdx f).length := h.trans_le length_mapIdx.ge) :\n    (l.mapIdx f).get ⟨i, h'⟩ = f i (l.get ⟨i, h⟩) := by\n  simp [mapIdx_eq_enum_map, enum_eq_zip_range]\n\n"}
{"name":"List.nthLe_mapIdx","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf : Nat → α → β\ni : Nat\nh : LT.lt i l.length\nh' : optParam (LT.lt i (List.mapIdx f l).length) ⋯\n⊢ Eq ((List.mapIdx f l).get ⟨i, h'⟩) (f i (l.get ⟨i, h⟩))","decl":"@[deprecated (since := \"2024-08-19\")] alias nthLe_mapIdx := get_mapIdx\n\n"}
{"name":"List.mapIdx_eq_ofFn","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf : Nat → α → β\n⊢ Eq (List.mapIdx f l) (List.ofFn fun i => f (↑i) (l.get i))","decl":"theorem mapIdx_eq_ofFn (l : List α) (f : ℕ → α → β) :\n    l.mapIdx f = ofFn fun i : Fin l.length ↦ f (i : ℕ) (l.get i) := by\n  induction l generalizing f with\n  | nil => simp\n  | cons _ _ IH => simp [IH]\n\n"}
{"name":"List.oldMapIdxCore_eq","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nl : List α\nf : Nat → α → β\nn : Nat\n⊢ Eq (List.oldMapIdxCore f n l) (List.oldMapIdx (fun i a => f (HAdd.hAdd i n) a) l)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-08-15\")]\nprotected theorem oldMapIdxCore_eq (l : List α) (f : ℕ → α → β) (n : ℕ) :\n    l.oldMapIdxCore f n = l.oldMapIdx fun i a ↦ f (i + n) a := by\n  induction' l with hd tl hl generalizing f n\n  · rfl\n  · rw [List.oldMapIdx]\n    simp only [List.oldMapIdxCore, hl, Nat.add_left_comm, Nat.add_comm, Nat.add_zero]\n\n"}
{"name":"List.oldMapIdxCore_append","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β\nn : Nat\nl₁ l₂ : List α\n⊢ Eq (List.oldMapIdxCore f n (HAppend.hAppend l₁ l₂)) (HAppend.hAppend (List.oldMapIdxCore f n l₁) (List.oldMapIdxCore f (HAdd.hAdd n l₁.length) l₂))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-08-15\")]\nprotected theorem oldMapIdxCore_append : ∀ (f : ℕ → α → β) (n : ℕ) (l₁ l₂ : List α),\n    List.oldMapIdxCore f n (l₁ ++ l₂) =\n    List.oldMapIdxCore f n l₁ ++ List.oldMapIdxCore f (n + l₁.length) l₂ := by\n  intros f n l₁ l₂\n  generalize e : (l₁ ++ l₂).length = len\n  revert n l₁ l₂\n  induction' len with len ih <;> intros n l₁ l₂ h\n  · have l₁_nil : l₁ = [] := by\n      cases l₁\n      · rfl\n      · contradiction\n    have l₂_nil : l₂ = [] := by\n      cases l₂\n      · rfl\n      · rw [List.length_append] at h; contradiction\n    simp only [l₁_nil, l₂_nil]; rfl\n  · cases' l₁ with head tail\n    · rfl\n    · simp only [List.oldMapIdxCore, List.append_eq, length_cons, cons_append,cons.injEq, true_and]\n      suffices n + Nat.succ (length tail) = n + 1 + tail.length by\n        rw [this]\n        apply ih (n + 1) _ _ _\n        simp only [cons_append, length_cons, length_append, Nat.succ.injEq] at h\n        simp only [length_append, h]\n      rw [Nat.add_assoc]; simp only [Nat.add_comm]\n\n"}
{"name":"List.oldMapIdx_append","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β\nl : List α\ne : α\n⊢ Eq (List.oldMapIdx f (HAppend.hAppend l (List.cons e List.nil))) (HAppend.hAppend (List.oldMapIdx f l) (List.cons (f l.length e) List.nil))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-08-15\")]\nprotected theorem oldMapIdx_append : ∀ (f : ℕ → α → β) (l : List α) (e : α),\n    List.oldMapIdx f (l ++ [e]) = List.oldMapIdx f l ++ [f l.length e] := by\n  intros f l e\n  unfold List.oldMapIdx\n  rw [List.oldMapIdxCore_append f 0 l [e]]\n  simp only [Nat.zero_add]; rfl\n\n"}
{"name":"List.new_def_eq_old_def","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β\nl : List α\n⊢ Eq (List.mapIdx f l) (List.oldMapIdx f l)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-08-15\")]\nprotected theorem new_def_eq_old_def :\n    ∀ (f : ℕ → α → β) (l : List α), l.mapIdx f = List.oldMapIdx f l := by\n  intro f\n  apply list_reverse_induction\n  · rfl\n  · intro l e h\n    rw [List.oldMapIdx_append, mapIdx_append_one, h]\n\n"}
{"name":"List.foldrIdxSpec_cons","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β → β\nb : β\na : α\nas : List α\nstart : Nat\n⊢ Eq (List.foldrIdxSpec f b (List.cons a as) start) (f start a (List.foldrIdxSpec f b as (HAdd.hAdd start 1)))","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem foldrIdxSpec_cons (f : ℕ → α → β → β) (b a as start) :\n    foldrIdxSpec f b (a :: as) start = f start a (foldrIdxSpec f b as (start + 1)) :=\n  rfl\n\n"}
{"name":"List.foldrIdx_eq_foldrIdxSpec","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β → β\nb : β\nas : List α\nstart : Nat\n⊢ Eq (List.foldrIdx f b as start) (List.foldrIdxSpec f b as start)","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem foldrIdx_eq_foldrIdxSpec (f : ℕ → α → β → β) (b as start) :\n    foldrIdx f b as start = foldrIdxSpec f b as start := by\n  induction as generalizing start\n  · rfl\n  · simp only [foldrIdx, foldrIdxSpec_cons, *]\n\n"}
{"name":"List.foldrIdx_eq_foldr_enum","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β → β\nb : β\nas : List α\n⊢ Eq (List.foldrIdx f b as) (List.foldr (Function.uncurry f) b as.enum)","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem foldrIdx_eq_foldr_enum (f : ℕ → α → β → β) (b : β) (as : List α) :\n    foldrIdx f b as = foldr (uncurry f) b (enum as) := by\n  simp only [foldrIdx, foldrIdxSpec, foldrIdx_eq_foldrIdxSpec, enum]\n\n"}
{"name":"List.indexesValues_eq_filter_enum","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nas : List α\n⊢ Eq (List.indexesValues (fun b => Decidable.decide (p b)) as) (List.filter (Function.comp (fun b => Decidable.decide (p b)) Prod.snd) as.enum)","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem indexesValues_eq_filter_enum (p : α → Prop) [DecidablePred p] (as : List α) :\n    indexesValues p as = filter (p ∘ Prod.snd) (enum as) := by\n  simp (config := { unfoldPartialApp := true }) [indexesValues, foldrIdx_eq_foldr_enum, uncurry,\n    filter_eq_foldr, cond_eq_if]\n\n"}
{"name":"List.findIdxs_eq_map_indexesValues","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nas : List α\n⊢ Eq (List.findIdxs (fun b => Decidable.decide (p b)) as) (List.map Prod.fst (List.indexesValues (fun b => Decidable.decide (p b)) as))","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem findIdxs_eq_map_indexesValues (p : α → Prop) [DecidablePred p] (as : List α) :\n    findIdxs p as = map Prod.fst (indexesValues p as) := by\n  simp (config := { unfoldPartialApp := true }) only [indexesValues_eq_filter_enum,\n    map_filter_eq_foldr, findIdxs, uncurry, foldrIdx_eq_foldr_enum, decide_eq_true_eq, comp_apply,\n    Bool.cond_decide]\n\n"}
{"name":"List.foldlIdxSpec_cons","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β → α\na : α\nb : β\nbs : List β\nstart : Nat\n⊢ Eq (List.foldlIdxSpec f a (List.cons b bs) start) (List.foldlIdxSpec f (f start a b) bs (HAdd.hAdd start 1))","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem foldlIdxSpec_cons (f : ℕ → α → β → α) (a b bs start) :\n    foldlIdxSpec f a (b :: bs) start = foldlIdxSpec f (f start a b) bs (start + 1) :=\n  rfl\n\n"}
{"name":"List.foldlIdx_eq_foldlIdxSpec","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β → α\na : α\nbs : List β\nstart : Nat\n⊢ Eq (List.foldlIdx f a bs start) (List.foldlIdxSpec f a bs start)","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem foldlIdx_eq_foldlIdxSpec (f : ℕ → α → β → α) (a bs start) :\n    foldlIdx f a bs start = foldlIdxSpec f a bs start := by\n  induction bs generalizing start a\n  · rfl\n  · simp [foldlIdxSpec, *]\n\n"}
{"name":"List.foldlIdx_eq_foldl_enum","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nβ : Type v\nf : Nat → α → β → α\na : α\nbs : List β\n⊢ Eq (List.foldlIdx f a bs) (List.foldl (fun a p => f p.fst a p.snd) a bs.enum)","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem foldlIdx_eq_foldl_enum (f : ℕ → α → β → α) (a : α) (bs : List β) :\n    foldlIdx f a bs = foldl (fun a p ↦ f p.fst a p.snd) a (enum bs) := by\n  simp only [foldlIdx, foldlIdxSpec, foldlIdx_eq_foldlIdxSpec, enum]\n\n"}
{"name":"List.foldrIdxM_eq_foldrM_enum","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nm : Type u → Type v\ninst✝¹ : Monad m\nβ : Type u\nf : Nat → α → β → m β\nb : β\nas : List α\ninst✝ : LawfulMonad m\n⊢ Eq (List.foldrIdxM f b as) (List.foldrM (Function.uncurry f) b as.enum)","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem foldrIdxM_eq_foldrM_enum {β} (f : ℕ → α → β → m β) (b : β) (as : List α) [LawfulMonad m] :\n    foldrIdxM f b as = foldrM (uncurry f) b (enum as) := by\n  simp (config := { unfoldPartialApp := true }) only [foldrIdxM, foldrM_eq_foldr,\n    foldrIdx_eq_foldr_enum, uncurry]\n\n"}
{"name":"List.foldlIdxM_eq_foldlM_enum","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nm : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nβ : Type u\nf : Nat → β → α → m β\nb : β\nas : List α\n⊢ Eq (List.foldlIdxM f b as) (List.foldlM (fun b p => f p.fst b p.snd) b as.enum)","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem foldlIdxM_eq_foldlM_enum [LawfulMonad m] {β} (f : ℕ → β → α → m β) (b : β) (as : List α) :\n    foldlIdxM f b as = List.foldlM (fun b p ↦ f p.fst b p.snd) b (enum as) := by\n  rw [foldlIdxM, foldlM_eq_foldl, foldlIdx_eq_foldl_enum]\n\n"}
{"name":"List.mapIdxMAuxSpec_cons","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nm : Type u → Type v\ninst✝ : Monad m\nβ : Type u\nf : Nat → α → m β\nstart : Nat\na : α\nas : List α\n⊢ Eq (List.mapIdxMAuxSpec f start (List.cons a as)) (Seq.seq (Functor.map List.cons (f start a)) fun x => List.mapIdxMAuxSpec f (HAdd.hAdd start 1) as)","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem mapIdxMAuxSpec_cons {β} (f : ℕ → α → m β) (start : ℕ) (a : α) (as : List α) :\n    mapIdxMAuxSpec f start (a :: as) = cons <$> f start a <*> mapIdxMAuxSpec f (start + 1) as :=\n  rfl\n\n"}
{"name":"List.mapIdxMGo_eq_mapIdxMAuxSpec","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nm : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nβ : Type u\nf : Nat → α → m β\narr : Array β\nas : List α\n⊢ Eq (List.mapIdxM.go f as arr) (Functor.map (fun x => HAppend.hAppend arr.toList x) (List.mapIdxMAuxSpec f arr.size as))","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem mapIdxMGo_eq_mapIdxMAuxSpec\n    [LawfulMonad m] {β} (f : ℕ → α → m β) (arr : Array β) (as : List α) :\n    mapIdxM.go f as arr = (arr.toList ++ ·) <$> mapIdxMAuxSpec f arr.size as := by\n  generalize e : as.length = len\n  revert as arr\n  induction' len with len ih <;> intro arr as h\n  · have : as = [] := by\n      cases as\n      · rfl\n      · contradiction\n    simp only [this, mapIdxM.go, mapIdxMAuxSpec, enumFrom_nil, List.traverse, map_pure, append_nil]\n  · match as with\n    | nil => contradiction\n    | cons head tail =>\n      simp only [length_cons, Nat.succ.injEq] at h\n      simp only [mapIdxM.go, mapIdxMAuxSpec_cons, map_eq_pure_bind, seq_eq_bind_map,\n        LawfulMonad.bind_assoc, pure_bind]\n      congr\n      conv => { lhs; intro x; rw [ih _ _ h]; }\n      funext x\n      simp only [Array.push_toList, append_assoc, singleton_append, Array.size_push,\n        map_eq_pure_bind]\n\n"}
{"name":"List.mapIdxM_eq_mmap_enum","module":"Mathlib.Data.List.Indexes","initialProofState":"α : Type u\nm : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nβ : Type u\nf : Nat → α → m β\nas : List α\n⊢ Eq (as.mapIdxM f) (List.traverse (Function.uncurry f) as.enum)","decl":"set_option linter.deprecated false in\n@[deprecated \"Deprecated without replacement.\" (since := \"2025-01-29\")]\ntheorem mapIdxM_eq_mmap_enum [LawfulMonad m] {β} (f : ℕ → α → m β) (as : List α) :\n    as.mapIdxM f = List.traverse (uncurry f) (enum as) := by\n  simp only [mapIdxM, mapIdxMGo_eq_mapIdxMAuxSpec, Array.toList_toArray,\n    nil_append, mapIdxMAuxSpec, Array.size_toArray, length_nil, id_map', enum]\n\n"}
{"name":"List.mapIdxMAux'_eq_mapIdxMGo","module":"Mathlib.Data.List.Indexes","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u_1\nf : Nat → α → m PUnit.{u + 1}\nas : List α\narr : Array PUnit.{u + 1}\n⊢ Eq (List.mapIdxMAux' f arr.size as) (SeqRight.seqRight (List.mapIdxM.go f as arr) fun x => Pure.pure PUnit.unit)","decl":"theorem mapIdxMAux'_eq_mapIdxMGo {α} (f : ℕ → α → m PUnit) (as : List α) (arr : Array PUnit) :\n    mapIdxMAux' f arr.size as = mapIdxM.go f as arr *> pure PUnit.unit := by\n  revert arr\n  induction' as with head tail ih <;> intro arr\n  · simp only [mapIdxMAux', mapIdxM.go, seqRight_eq, map_pure, seq_pure]\n  · simp only [mapIdxMAux', seqRight_eq, map_eq_pure_bind, seq_eq_bind, bind_pure_unit,\n      LawfulMonad.bind_assoc, pure_bind, mapIdxM.go, seq_pure]\n    generalize (f (Array.size arr) head) = head\n    have : (arr.push ⟨⟩).size = arr.size + 1 := Array.size_push arr ⟨⟩\n    rw [← this, ih]\n    simp only [seqRight_eq, map_eq_pure_bind, seq_pure, LawfulMonad.bind_assoc, pure_bind]\n\n"}
{"name":"List.mapIdxM'_eq_mapIdxM","module":"Mathlib.Data.List.Indexes","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u_1\nf : Nat → α → m PUnit.{u + 1}\nas : List α\n⊢ Eq (List.mapIdxM' f as) (SeqRight.seqRight (as.mapIdxM f) fun x => Pure.pure PUnit.unit)","decl":"theorem mapIdxM'_eq_mapIdxM {α} (f : ℕ → α → m PUnit) (as : List α) :\n    mapIdxM' f as = mapIdxM as f *> pure PUnit.unit :=\n  mapIdxMAux'_eq_mapIdxMGo f as #[]\n\n"}
