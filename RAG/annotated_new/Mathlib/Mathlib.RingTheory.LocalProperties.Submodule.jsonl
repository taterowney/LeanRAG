{"name":"Submodule.mem_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝¹ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nm : M\nN : Submodule R M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Membership.mem (Submodule.localized₀ P.primeCompl (f P) N) ((f P) m)\n⊢ Membership.mem N m","decl":"theorem Submodule.mem_of_localization_maximal (m : M) (N : Submodule R M)\n    (h : ∀ (P : Ideal R) [P.IsMaximal], f P m ∈ N.localized₀ P.primeCompl (f P)) :\n    m ∈ N := by\n  let I : Ideal R := N.comap (LinearMap.toSpanSingleton R M m)\n  suffices I = ⊤ by simpa [I] using I.eq_top_iff_one.mp this\n  refine Not.imp_symm I.exists_le_maximal fun ⟨P, hP, le⟩ ↦ ?_\n  obtain ⟨a, ha, s, e⟩ := h P\n  rw [← IsLocalizedModule.mk'_one P.primeCompl, IsLocalizedModule.mk'_eq_mk'_iff] at e\n  obtain ⟨t, ht⟩ := e\n  simp_rw [smul_smul] at ht\n  exact (t * s).2 (le <| by apply ht ▸ smul_mem _ _ ha)\n\n"}
{"name":"Submodule.le_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝¹ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nN₁ N₂ : Submodule R M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], LE.le (Submodule.localized₀ P.primeCompl (f P) N₁) (Submodule.localized₀ P.primeCompl (f P) N₂)\n⊢ LE.le N₁ N₂","decl":"/-- Let `N₁ N₂ : Submodule R M`. If the localization of `N₁` at each maximal ideal `P` is\nincluded in the localization of `N₂` at `P`, then `N₁ ≤ N₂`. -/\ntheorem Submodule.le_of_localization_maximal {N₁ N₂ : Submodule R M}\n    (h : ∀ (P : Ideal R) [P.IsMaximal],\n      N₁.localized₀ P.primeCompl (f P) ≤ N₂.localized₀ P.primeCompl (f P)) :\n    N₁ ≤ N₂ :=\n  fun m hm ↦ mem_of_localization_maximal _ f _ _ fun P hP ↦ h P ⟨m, hm, 1, by simp⟩\n\n"}
{"name":"Submodule.eq_of_localization₀_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝¹ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nN₁ N₂ : Submodule R M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Eq (Submodule.localized₀ P.primeCompl (f P) N₁) (Submodule.localized₀ P.primeCompl (f P) N₂)\n⊢ Eq N₁ N₂","decl":"/-- Let `N₁ N₂ : Submodule R M`. If the localization of `N₁` at each maximal ideal `P` is equal to\nthe localization of `N₂` at `P`, then `N₁ = N₂`. -/\ntheorem Submodule.eq_of_localization₀_maximal {N₁ N₂ : Submodule R M}\n    (h : ∀ (P : Ideal R) [P.IsMaximal],\n      N₁.localized₀ P.primeCompl (f P) = N₂.localized₀ P.primeCompl (f P)) :\n    N₁ = N₂ :=\n  le_antisymm (Submodule.le_of_localization_maximal Mₚ f fun P _ ↦ (h P).le)\n    (Submodule.le_of_localization_maximal Mₚ f fun P _ ↦ (h P).ge)\n\n"}
{"name":"Submodule.eq_bot_of_localization₀_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝¹ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nN : Submodule R M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Eq (Submodule.localized₀ P.primeCompl (f P) N) Bot.bot\n⊢ Eq N Bot.bot","decl":"/-- A submodule is trivial if its localization at every maximal ideal is trivial. -/\ntheorem Submodule.eq_bot_of_localization₀_maximal (N : Submodule R M)\n    (h : ∀ (P : Ideal R) [P.IsMaximal], N.localized₀ P.primeCompl (f P) = ⊥) :\n    N = ⊥ :=\n  Submodule.eq_of_localization₀_maximal Mₚ f fun P hP ↦ by simpa using h P\n\n"}
{"name":"Submodule.eq_top_of_localization₀_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝¹ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nN : Submodule R M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Eq (Submodule.localized₀ P.primeCompl (f P) N) Top.top\n⊢ Eq N Top.top","decl":"theorem Submodule.eq_top_of_localization₀_maximal (N : Submodule R M)\n    (h : ∀ (P : Ideal R) [P.IsMaximal], N.localized₀ P.primeCompl (f P) = ⊤) :\n    N = ⊤ :=\n  Submodule.eq_of_localization₀_maximal Mₚ f fun P hP ↦ by simpa using h P\n\n"}
{"name":"Module.eq_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝¹ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nm m' : M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Eq ((f P) m) ((f P) m')\n⊢ Eq m m'","decl":"theorem Module.eq_of_localization_maximal (m m' : M)\n    (h : ∀ (P : Ideal R) [P.IsMaximal], f P m = f P m') :\n    m = m' := by\n  rw [← one_smul R m, ← one_smul R m']\n  by_contra ne\n  have ⟨P, mP, le⟩ := (eqIdeal R m m').exists_le_maximal ((Ideal.ne_top_iff_one _).mpr ne)\n  have ⟨s, hs⟩ := (IsLocalizedModule.eq_iff_exists P.primeCompl _).mp (h P)\n  exact s.2 (le hs)\n\n"}
{"name":"Module.eq_zero_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝¹ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nm : M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Eq ((f P) m) 0\n⊢ Eq m 0","decl":"theorem Module.eq_zero_of_localization_maximal (m : M)\n    (h : ∀ (P : Ideal R) [P.IsMaximal], f P m = 0) :\n    m = 0 :=\n  eq_of_localization_maximal _ f _ _ fun P _ ↦ by rw [h, map_zero]\n\n"}
{"name":"LinearMap.eq_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\nM₁ : Type u_3\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R M₁\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝⁵ : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝⁴ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝³ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nM₁ₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_6\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (M₁ₚ P)\ninst✝¹ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (M₁ₚ P)\nf₁ : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M₁ (M₁ₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f₁ P)\ng g' : LinearMap (RingHom.id R) M M₁\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Eq ((IsLocalizedModule.map P.primeCompl (f P) (f₁ P)) g) ((IsLocalizedModule.map P.primeCompl (f P) (f₁ P)) g')\n⊢ Eq g g'","decl":"theorem LinearMap.eq_of_localization_maximal (g g' : M →ₗ[R] M₁)\n    (h : ∀ (P : Ideal R) [P.IsMaximal],\n      IsLocalizedModule.map P.primeCompl (f P) (f₁ P) g =\n      IsLocalizedModule.map P.primeCompl (f P) (f₁ P) g') :\n    g = g' :=\n  ext fun x ↦ Module.eq_of_localization_maximal _ f₁ _ _ fun P _ ↦ by\n    simpa only [IsLocalizedModule.map_apply] using DFunLike.congr_fun (h P) (f P x)\n\n"}
{"name":"Module.subsingleton_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝¹ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Subsingleton (Mₚ P)\n⊢ Subsingleton M","decl":"include f in\ntheorem Module.subsingleton_of_localization_maximal\n    (h : ∀ (P : Ideal R) [P.IsMaximal], Subsingleton (Mₚ P)) :\n    Subsingleton M := by\n  rw [subsingleton_iff_forall_eq 0]\n  intro x\n  exact Module.eq_of_localization_maximal Mₚ f x 0 fun _ _ ↦ Subsingleton.elim _ _\n\n"}
{"name":"Submodule.eq_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\nRₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_4\ninst✝⁷ : (P : Ideal R) → [inst : P.IsMaximal] → CommSemiring (Rₚ P)\ninst✝⁶ : (P : Ideal R) → [inst : P.IsMaximal] → Algebra R (Rₚ P)\ninst✝⁵ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalization.AtPrime (Rₚ P) P\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝⁴ : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝³ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → Module (Rₚ P) (Mₚ P)\ninst✝¹ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsScalarTower R (Rₚ P) (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nN₁ N₂ : Submodule R M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Eq (Submodule.localized' (Rₚ P) P.primeCompl (f P) N₁) (Submodule.localized' (Rₚ P) P.primeCompl (f P) N₂)\n⊢ Eq N₁ N₂","decl":"theorem Submodule.eq_of_localization_maximal {N₁ N₂ : Submodule R M}\n    (h : ∀ (P : Ideal R) [P.IsMaximal],\n      N₁.localized' (Rₚ P) P.primeCompl (f P) = N₂.localized' (Rₚ P) P.primeCompl (f P)) :\n    N₁ = N₂ :=\n  eq_of_localization₀_maximal Mₚ f fun P _ ↦ congr(restrictScalars _ $(h P))\n\n"}
{"name":"Submodule.eq_bot_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\nRₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_4\ninst✝⁷ : (P : Ideal R) → [inst : P.IsMaximal] → CommSemiring (Rₚ P)\ninst✝⁶ : (P : Ideal R) → [inst : P.IsMaximal] → Algebra R (Rₚ P)\ninst✝⁵ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalization.AtPrime (Rₚ P) P\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝⁴ : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝³ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → Module (Rₚ P) (Mₚ P)\ninst✝¹ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsScalarTower R (Rₚ P) (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nN : Submodule R M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Eq (Submodule.localized' (Rₚ P) P.primeCompl (f P) N) Bot.bot\n⊢ Eq N Bot.bot","decl":"theorem Submodule.eq_bot_of_localization_maximal (N : Submodule R M)\n    (h : ∀ (P : Ideal R) [P.IsMaximal], N.localized' (Rₚ P) P.primeCompl (f P) = ⊥) :\n    N = ⊥ :=\n  Submodule.eq_of_localization_maximal Rₚ Mₚ f fun P hP ↦ by simpa using h P\n\n"}
{"name":"Submodule.eq_top_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\nRₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_4\ninst✝⁷ : (P : Ideal R) → [inst : P.IsMaximal] → CommSemiring (Rₚ P)\ninst✝⁶ : (P : Ideal R) → [inst : P.IsMaximal] → Algebra R (Rₚ P)\ninst✝⁵ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalization.AtPrime (Rₚ P) P\nMₚ : (P : Ideal R) → [inst : P.IsMaximal] → Type u_5\ninst✝⁴ : (P : Ideal R) → [inst : P.IsMaximal] → AddCommMonoid (Mₚ P)\ninst✝³ : (P : Ideal R) → [inst : P.IsMaximal] → Module R (Mₚ P)\ninst✝² : (P : Ideal R) → [inst : P.IsMaximal] → Module (Rₚ P) (Mₚ P)\ninst✝¹ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsScalarTower R (Rₚ P) (Mₚ P)\nf : (P : Ideal R) → [inst : P.IsMaximal] → LinearMap (RingHom.id R) M (Mₚ P)\ninst✝ : ∀ (P : Ideal R) [inst : P.IsMaximal], IsLocalizedModule P.primeCompl (f P)\nN : Submodule R M\nh : ∀ (P : Ideal R) [inst : P.IsMaximal], Eq (Submodule.localized' (Rₚ P) P.primeCompl (f P) N) Top.top\n⊢ Eq N Top.top","decl":"theorem Submodule.eq_top_of_localization_maximal (N : Submodule R M)\n    (h : ∀ (P : Ideal R) [P.IsMaximal], N.localized' (Rₚ P) P.primeCompl (f P) = ⊤) :\n    N = ⊤ :=\n  Submodule.eq_of_localization_maximal Rₚ Mₚ f fun P hP ↦ by simpa using h P\n\n"}
{"name":"Module.eq_of_isLocalized_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nMₚ : ↑s → Type u_5\ninst✝² : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝¹ : (r : ↑s) → Module R (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nx y : M\nh : ∀ (r : ↑s), Eq ((f r) x) ((f r) y)\n⊢ Eq x y","decl":"theorem Module.eq_of_isLocalized_span (x y : M) (h : ∀ r : s, f r x = f r y) : x = y := by\n  suffices Module.eqIdeal R x y = ⊤ by simpa [Module.eqIdeal] using (eq_top_iff_one _).mp this\n  by_contra ne\n  have ⟨r, hrs, disj⟩ := exists_disjoint_powers_of_span_eq_top s span_eq _ ne\n  let r : s := ⟨r, hrs⟩\n  have ⟨⟨_, n, rfl⟩, eq⟩ := (IsLocalizedModule.eq_iff_exists (.powers r.1) _).mp (h r)\n  exact Set.disjoint_left.mp disj eq ⟨n, rfl⟩\n\n"}
{"name":"Module.eq_zero_of_isLocalized_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nMₚ : ↑s → Type u_5\ninst✝² : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝¹ : (r : ↑s) → Module R (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nx : M\nh : ∀ (r : ↑s), Eq ((f r) x) 0\n⊢ Eq x 0","decl":"theorem Module.eq_zero_of_isLocalized_span (x : M) (h : ∀ r : s, f r x = 0) : x = 0 :=\n  eq_of_isLocalized_span s span_eq _ f x 0 <| by simpa only [map_zero] using h\n\n"}
{"name":"Submodule.mem_of_isLocalized_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nMₚ : ↑s → Type u_5\ninst✝² : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝¹ : (r : ↑s) → Module R (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nm : M\nN : Submodule R M\nh : ∀ (r : ↑s), Membership.mem (Submodule.localized₀ (Submonoid.powers ↑r) (f r) N) ((f r) m)\n⊢ Membership.mem N m","decl":"theorem Submodule.mem_of_isLocalized_span {m : M} {N : Submodule R M}\n    (h : ∀ r : s, f r m ∈ N.localized₀ (.powers r.1) (f r)) : m ∈ N := by\n  let I : Ideal R := N.comap (LinearMap.toSpanSingleton R M m)\n  suffices I = ⊤ by simpa [I] using I.eq_top_iff_one.mp this\n  by_contra! ne\n  have ⟨r, hrs, disj⟩ := exists_disjoint_powers_of_span_eq_top s span_eq _ ne\n  let r : s := ⟨r, hrs⟩\n  obtain ⟨a, ha, t, e⟩ := h r\n  rw [← IsLocalizedModule.mk'_one (.powers r.1), IsLocalizedModule.mk'_eq_mk'_iff] at e\n  have ⟨u, hu⟩ := e\n  simp_rw [smul_smul] at hu\n  exact Set.disjoint_right.mp disj (u * t).2 (by apply hu ▸ smul_mem _ _ ha)\n\n"}
{"name":"Submodule.le_of_isLocalized_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nMₚ : ↑s → Type u_5\ninst✝² : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝¹ : (r : ↑s) → Module R (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nN P : Submodule R M\nh : ∀ (r : ↑s), LE.le (Submodule.localized₀ (Submonoid.powers ↑r) (f r) N) (Submodule.localized₀ (Submonoid.powers ↑r) (f r) P)\n⊢ LE.le N P","decl":"theorem Submodule.le_of_isLocalized_span {N P : Submodule R M}\n    (h : ∀ r : s, N.localized₀ (.powers r.1) (f r) ≤ P.localized₀ (.powers r.1) (f r)) : N ≤ P :=\n  fun m hm ↦ mem_of_isLocalized_span s span_eq _ f fun r ↦ h r ⟨m, hm, 1, by simp⟩\n\n"}
{"name":"Submodule.eq_of_isLocalized₀_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nMₚ : ↑s → Type u_5\ninst✝² : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝¹ : (r : ↑s) → Module R (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nN P : Submodule R M\nh : ∀ (r : ↑s), Eq (Submodule.localized₀ (Submonoid.powers ↑r) (f r) N) (Submodule.localized₀ (Submonoid.powers ↑r) (f r) P)\n⊢ Eq N P","decl":"theorem Submodule.eq_of_isLocalized₀_span {N P : Submodule R M}\n    (h : ∀ r : s, N.localized₀ (.powers r.1) (f r) = P.localized₀ (.powers r.1) (f r)) : N = P :=\n  le_antisymm (le_of_isLocalized_span s span_eq _ _ fun r ↦ (h r).le)\n    (le_of_isLocalized_span s span_eq _ _ fun r ↦ (h r).ge)\n\n"}
{"name":"Submodule.eq_bot_of_isLocalized₀_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nMₚ : ↑s → Type u_5\ninst✝² : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝¹ : (r : ↑s) → Module R (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nN : Submodule R M\nh : ∀ (r : ↑s), Eq (Submodule.localized₀ (Submonoid.powers ↑r) (f r) N) Bot.bot\n⊢ Eq N Bot.bot","decl":"theorem Submodule.eq_bot_of_isLocalized₀_span {N : Submodule R M}\n    (h : ∀ r : s, N.localized₀ (.powers r.1) (f r) = ⊥) : N = ⊥ :=\n  eq_of_isLocalized₀_span s span_eq Mₚ f fun _ ↦ by simp only [h, Submodule.localized₀_bot]\n\n"}
{"name":"Submodule.eq_top_of_isLocalized₀_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nMₚ : ↑s → Type u_5\ninst✝² : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝¹ : (r : ↑s) → Module R (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nN : Submodule R M\nh : ∀ (r : ↑s), Eq (Submodule.localized₀ (Submonoid.powers ↑r) (f r) N) Top.top\n⊢ Eq N Top.top","decl":"theorem Submodule.eq_top_of_isLocalized₀_span {N : Submodule R M}\n    (h : ∀ r : s, N.localized₀ (.powers r.1) (f r) = ⊤) : N = ⊤ :=\n  eq_of_isLocalized₀_span s span_eq Mₚ f fun _ ↦ by simp only [h, Submodule.localized₀_top]\n\n"}
{"name":"Submodule.eq_of_isLocalized'_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nRₚ : ↑s → Type u_4\ninst✝⁷ : (r : ↑s) → CommSemiring (Rₚ r)\ninst✝⁶ : (r : ↑s) → Algebra R (Rₚ r)\ninst✝⁵ : ∀ (r : ↑s), IsLocalization.Away (↑r) (Rₚ r)\nMₚ : ↑s → Type u_5\ninst✝⁴ : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝³ : (r : ↑s) → Module R (Mₚ r)\ninst✝² : (r : ↑s) → Module (Rₚ r) (Mₚ r)\ninst✝¹ : ∀ (r : ↑s), IsScalarTower R (Rₚ r) (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nN P : Submodule R M\nh : ∀ (r : ↑s), Eq (Submodule.localized' (Rₚ r) (Submonoid.powers ↑r) (f r) N) (Submodule.localized' (Rₚ r) (Submonoid.powers ↑r) (f r) P)\n⊢ Eq N P","decl":"theorem Submodule.eq_of_isLocalized'_span {N P : Submodule R M}\n    (h : ∀ r, N.localized' (Rₚ r) (.powers r.1) (f r) = P.localized' (Rₚ r) (.powers r.1) (f r)) :\n    N = P :=\n  eq_of_isLocalized₀_span s span_eq _ f fun r ↦ congr(restrictScalars _ $(h r))\n\n"}
{"name":"Submodule.eq_bot_of_isLocalized'_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nRₚ : ↑s → Type u_4\ninst✝⁷ : (r : ↑s) → CommSemiring (Rₚ r)\ninst✝⁶ : (r : ↑s) → Algebra R (Rₚ r)\ninst✝⁵ : ∀ (r : ↑s), IsLocalization.Away (↑r) (Rₚ r)\nMₚ : ↑s → Type u_5\ninst✝⁴ : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝³ : (r : ↑s) → Module R (Mₚ r)\ninst✝² : (r : ↑s) → Module (Rₚ r) (Mₚ r)\ninst✝¹ : ∀ (r : ↑s), IsScalarTower R (Rₚ r) (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nN : Submodule R M\nh : ∀ (r : ↑s), Eq (Submodule.localized' (Rₚ r) (Submonoid.powers ↑r) (f r) N) Bot.bot\n⊢ Eq N Bot.bot","decl":"theorem Submodule.eq_bot_of_isLocalized'_span {N : Submodule R M}\n    (h : ∀ r : s, N.localized' (Rₚ r) (.powers r.1) (f r) = ⊥) : N = ⊥ :=\n  eq_of_isLocalized'_span s span_eq Rₚ Mₚ f fun _ ↦ by simp only [h, Submodule.localized'_bot]\n\n"}
{"name":"Submodule.eq_top_of_isLocalized'_span","module":"Mathlib.RingTheory.LocalProperties.Submodule","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ns : Set R\nspan_eq : Eq (Ideal.span s) Top.top\nRₚ : ↑s → Type u_4\ninst✝⁷ : (r : ↑s) → CommSemiring (Rₚ r)\ninst✝⁶ : (r : ↑s) → Algebra R (Rₚ r)\ninst✝⁵ : ∀ (r : ↑s), IsLocalization.Away (↑r) (Rₚ r)\nMₚ : ↑s → Type u_5\ninst✝⁴ : (r : ↑s) → AddCommMonoid (Mₚ r)\ninst✝³ : (r : ↑s) → Module R (Mₚ r)\ninst✝² : (r : ↑s) → Module (Rₚ r) (Mₚ r)\ninst✝¹ : ∀ (r : ↑s), IsScalarTower R (Rₚ r) (Mₚ r)\nf : (r : ↑s) → LinearMap (RingHom.id R) M (Mₚ r)\ninst✝ : ∀ (r : ↑s), IsLocalizedModule (Submonoid.powers ↑r) (f r)\nN : Submodule R M\nh : ∀ (r : ↑s), Eq (Submodule.localized' (Rₚ r) (Submonoid.powers ↑r) (f r) N) Top.top\n⊢ Eq N Top.top","decl":"theorem Submodule.eq_top_of_isLocalized'_span {N : Submodule R M}\n    (h : ∀ r : s, N.localized' (Rₚ r) (.powers r.1) (f r) = ⊤) : N = ⊤ :=\n  eq_of_isLocalized'_span s span_eq Rₚ Mₚ f fun _ ↦ by simp only [h, Submodule.localized'_top]\n\n"}
