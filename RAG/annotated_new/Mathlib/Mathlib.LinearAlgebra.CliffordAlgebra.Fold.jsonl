{"name":"CliffordAlgebra.foldr_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\nm : M\n⊢ Eq (((CliffordAlgebra.foldr Q f hf) n) ((CliffordAlgebra.ι Q) m)) ((f m) n)","decl":"@[simp]\ntheorem foldr_ι (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) (m : M) : foldr Q f hf n (ι Q m) = f m n :=\n  LinearMap.congr_fun (lift_ι_apply _ _ _) n\n\n"}
{"name":"CliffordAlgebra.foldr_algebraMap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\nr : R\n⊢ Eq (((CliffordAlgebra.foldr Q f hf) n) ((algebraMap R (CliffordAlgebra Q)) r)) (HSMul.hSMul r n)","decl":"@[simp]\ntheorem foldr_algebraMap (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) (r : R) :\n    foldr Q f hf n (algebraMap R _ r) = r • n :=\n  LinearMap.congr_fun (AlgHom.commutes _ r) n\n\n"}
{"name":"CliffordAlgebra.foldr_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\n⊢ Eq (((CliffordAlgebra.foldr Q f hf) n) 1) n","decl":"@[simp]\ntheorem foldr_one (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) : foldr Q f hf n 1 = n :=\n  LinearMap.congr_fun (map_one (lift Q _)) n\n\n"}
{"name":"CliffordAlgebra.foldr_mul","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\na b : CliffordAlgebra Q\n⊢ Eq (((CliffordAlgebra.foldr Q f hf) n) (HMul.hMul a b)) (((CliffordAlgebra.foldr Q f hf) (((CliffordAlgebra.foldr Q f hf) n) b)) a)","decl":"@[simp]\ntheorem foldr_mul (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) (a b : CliffordAlgebra Q) :\n    foldr Q f hf n (a * b) = foldr Q f hf (foldr Q f hf n b) a :=\n  LinearMap.congr_fun (map_mul (lift Q _) _ _) n\n\n"}
{"name":"CliffordAlgebra.foldr_prod_map_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nl : List M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\n⊢ Eq (((CliffordAlgebra.foldr Q f hf) n) (List.map (⇑(CliffordAlgebra.ι Q)) l).prod) (List.foldr (fun m n => (f m) n) n l)","decl":"/-- This lemma demonstrates the origin of the `foldr` name. -/\ntheorem foldr_prod_map_ι (l : List M) (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) :\n    foldr Q f hf n (l.map <| ι Q).prod = List.foldr (fun m n => f m n) n l := by\n  induction' l with hd tl ih\n  · rw [List.map_nil, List.prod_nil, List.foldr_nil, foldr_one]\n  · rw [List.map_cons, List.prod_cons, List.foldr_cons, foldr_mul, foldr_ι, ih]\n\n"}
{"name":"CliffordAlgebra.foldl_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\nx : CliffordAlgebra Q\n⊢ Eq (((CliffordAlgebra.foldl Q f hf) n) (CliffordAlgebra.reverse x)) (((CliffordAlgebra.foldr Q f hf) n) x)","decl":"@[simp]\ntheorem foldl_reverse (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) (x : CliffordAlgebra Q) :\n    foldl Q f hf n (reverse x) = foldr Q f hf n x :=\n  DFunLike.congr_arg (foldr Q f hf n) <| reverse_reverse _\n\n"}
{"name":"CliffordAlgebra.foldr_reverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\nx : CliffordAlgebra Q\n⊢ Eq (((CliffordAlgebra.foldr Q f hf) n) (CliffordAlgebra.reverse x)) (((CliffordAlgebra.foldl Q f hf) n) x)","decl":"@[simp]\ntheorem foldr_reverse (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) (x : CliffordAlgebra Q) :\n    foldr Q f hf n (reverse x) = foldl Q f hf n x :=\n  rfl\n\n"}
{"name":"CliffordAlgebra.foldl_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\nm : M\n⊢ Eq (((CliffordAlgebra.foldl Q f hf) n) ((CliffordAlgebra.ι Q) m)) ((f m) n)","decl":"@[simp]\ntheorem foldl_ι (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) (m : M) : foldl Q f hf n (ι Q m) = f m n := by\n  rw [← foldr_reverse, reverse_ι, foldr_ι]\n\n"}
{"name":"CliffordAlgebra.foldl_algebraMap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\nr : R\n⊢ Eq (((CliffordAlgebra.foldl Q f hf) n) ((algebraMap R (CliffordAlgebra Q)) r)) (HSMul.hSMul r n)","decl":"@[simp]\ntheorem foldl_algebraMap (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) (r : R) :\n    foldl Q f hf n (algebraMap R _ r) = r • n := by\n  rw [← foldr_reverse, reverse.commutes, foldr_algebraMap]\n\n"}
{"name":"CliffordAlgebra.foldl_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\n⊢ Eq (((CliffordAlgebra.foldl Q f hf) n) 1) n","decl":"@[simp]\ntheorem foldl_one (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) : foldl Q f hf n 1 = n := by\n  rw [← foldr_reverse, reverse.map_one, foldr_one]\n\n"}
{"name":"CliffordAlgebra.foldl_mul","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\na b : CliffordAlgebra Q\n⊢ Eq (((CliffordAlgebra.foldl Q f hf) n) (HMul.hMul a b)) (((CliffordAlgebra.foldl Q f hf) (((CliffordAlgebra.foldl Q f hf) n) a)) b)","decl":"@[simp]\ntheorem foldl_mul (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) (a b : CliffordAlgebra Q) :\n    foldl Q f hf n (a * b) = foldl Q f hf (foldl Q f hf n a) b := by\n  rw [← foldr_reverse, ← foldr_reverse, ← foldr_reverse, reverse.map_mul, foldr_mul]\n\n"}
{"name":"CliffordAlgebra.foldl_prod_map_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nl : List M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N N)\nhf : ∀ (m : M) (x : N), Eq ((f m) ((f m) x)) (HSMul.hSMul (Q m) x)\nn : N\n⊢ Eq (((CliffordAlgebra.foldl Q f hf) n) (List.map (⇑(CliffordAlgebra.ι Q)) l).prod) (List.foldl (fun m n => (f n) m) n l)","decl":"/-- This lemma demonstrates the origin of the `foldl` name. -/\ntheorem foldl_prod_map_ι (l : List M) (f : M →ₗ[R] N →ₗ[R] N) (hf) (n : N) :\n    foldl Q f hf n (l.map <| ι Q).prod = List.foldl (fun m n => f n m) n l := by\n  rw [← foldr_reverse, reverse_prod_map_ι, ← List.map_reverse, foldr_prod_map_ι, List.foldr_reverse]\n\n"}
{"name":"CliffordAlgebra.right_induction","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nP : CliffordAlgebra Q → Prop\nalgebraMap : ∀ (r : R), P ((_root_.algebraMap R (CliffordAlgebra Q)) r)\nadd : ∀ (x y : CliffordAlgebra Q), P x → P y → P (HAdd.hAdd x y)\nmul_ι : ∀ (m : M) (x : CliffordAlgebra Q), P x → P (HMul.hMul x ((CliffordAlgebra.ι Q) m))\nx : CliffordAlgebra Q\n⊢ P x","decl":"@[elab_as_elim]\ntheorem right_induction {P : CliffordAlgebra Q → Prop} (algebraMap : ∀ r : R, P (algebraMap _ _ r))\n    (add : ∀ x y, P x → P y → P (x + y)) (mul_ι : ∀ m x, P x → P (x * ι Q m)) : ∀ x, P x := by\n  /- It would be neat if we could prove this via `foldr` like how we prove\n    `CliffordAlgebra.induction`, but going via the grading seems easier. -/\n  intro x\n  have : x ∈ ⊤ := Submodule.mem_top (R := R)\n  rw [← iSup_ι_range_eq_top] at this\n  induction this using Submodule.iSup_induction' with\n  | mem i x hx =>\n    induction hx using Submodule.pow_induction_on_right' with\n    | algebraMap r => exact algebraMap r\n    | add _x _y _i _ _ ihx ihy => exact add _ _ ihx ihy\n    | mul_mem _i x _hx px m hm =>\n      obtain ⟨m, rfl⟩ := hm\n      exact mul_ι _ _ px\n  | zero => simpa only [map_zero] using algebraMap 0\n  | add _x _y _ _ ihx ihy =>\n    exact add _ _ ihx ihy\n\n"}
{"name":"CliffordAlgebra.left_induction","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nP : CliffordAlgebra Q → Prop\nalgebraMap : ∀ (r : R), P ((_root_.algebraMap R (CliffordAlgebra Q)) r)\nadd : ∀ (x y : CliffordAlgebra Q), P x → P y → P (HAdd.hAdd x y)\nι_mul : ∀ (x : CliffordAlgebra Q) (m : M), P x → P (HMul.hMul ((CliffordAlgebra.ι Q) m) x)\nx : CliffordAlgebra Q\n⊢ P x","decl":"@[elab_as_elim]\ntheorem left_induction {P : CliffordAlgebra Q → Prop} (algebraMap : ∀ r : R, P (algebraMap _ _ r))\n    (add : ∀ x y, P x → P y → P (x + y)) (ι_mul : ∀ x m, P x → P (ι Q m * x)) : ∀ x, P x := by\n  refine reverse_involutive.surjective.forall.2 ?_\n  intro x\n  induction' x using CliffordAlgebra.right_induction with r x y hx hy m x hx\n  · simpa only [reverse.commutes] using algebraMap r\n  · simpa only [map_add] using add _ _ hx hy\n  · simpa only [reverse.map_mul, reverse_ι] using ι_mul _ _ hx\n\n"}
{"name":"CliffordAlgebra.foldr'Aux_apply_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) (Prod (CliffordAlgebra Q) N) N)\nm : M\nx_fx : Prod (CliffordAlgebra Q) N\n⊢ Eq (((CliffordAlgebra.foldr'Aux Q f) m) x_fx) { fst := HMul.hMul ((CliffordAlgebra.ι Q) m) x_fx.1, snd := (f m) x_fx }","decl":"theorem foldr'Aux_apply_apply (f : M →ₗ[R] CliffordAlgebra Q × N →ₗ[R] N) (m : M) (x_fx) :\n    foldr'Aux Q f m x_fx = (ι Q m * x_fx.1, f m x_fx) :=\n  rfl\n\n"}
{"name":"CliffordAlgebra.foldr'Aux_foldr'Aux","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) (Prod (CliffordAlgebra Q) N) N)\nhf : ∀ (m : M) (x : CliffordAlgebra Q) (fx : N), Eq ((f m) { fst := HMul.hMul ((CliffordAlgebra.ι Q) m) x, snd := (f m) { fst := x, snd := fx } }) (HSMul.hSMul (Q m) fx)\nv : M\nx_fx : Prod (CliffordAlgebra Q) N\n⊢ Eq (((CliffordAlgebra.foldr'Aux Q f) v) (((CliffordAlgebra.foldr'Aux Q f) v) x_fx)) (HSMul.hSMul (Q v) x_fx)","decl":"theorem foldr'Aux_foldr'Aux (f : M →ₗ[R] CliffordAlgebra Q × N →ₗ[R] N)\n    (hf : ∀ m x fx, f m (ι Q m * x, f m (x, fx)) = Q m • fx) (v : M) (x_fx) :\n    foldr'Aux Q f v (foldr'Aux Q f v x_fx) = Q v • x_fx := by\n  cases' x_fx with x fx\n  simp only [foldr'Aux_apply_apply]\n  rw [← mul_assoc, ι_sq_scalar, ← Algebra.smul_def, hf, Prod.smul_mk]\n\n"}
{"name":"CliffordAlgebra.foldr'_algebraMap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) (Prod (CliffordAlgebra Q) N) N)\nhf : ∀ (m : M) (x : CliffordAlgebra Q) (fx : N), Eq ((f m) { fst := HMul.hMul ((CliffordAlgebra.ι Q) m) x, snd := (f m) { fst := x, snd := fx } }) (HSMul.hSMul (Q m) fx)\nn : N\nr : R\n⊢ Eq ((CliffordAlgebra.foldr' Q f hf n) ((algebraMap R (CliffordAlgebra Q)) r)) (HSMul.hSMul r n)","decl":"theorem foldr'_algebraMap (f : M →ₗ[R] CliffordAlgebra Q × N →ₗ[R] N)\n    (hf : ∀ m x fx, f m (ι Q m * x, f m (x, fx)) = Q m • fx) (n r) :\n    foldr' Q f hf n (algebraMap R _ r) = r • n :=\n  congr_arg Prod.snd (foldr_algebraMap _ _ _ _ _)\n\n"}
{"name":"CliffordAlgebra.foldr'_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) (Prod (CliffordAlgebra Q) N) N)\nhf : ∀ (m : M) (x : CliffordAlgebra Q) (fx : N), Eq ((f m) { fst := HMul.hMul ((CliffordAlgebra.ι Q) m) x, snd := (f m) { fst := x, snd := fx } }) (HSMul.hSMul (Q m) fx)\nn : N\nm : M\n⊢ Eq ((CliffordAlgebra.foldr' Q f hf n) ((CliffordAlgebra.ι Q) m)) ((f m) { fst := 1, snd := n })","decl":"theorem foldr'_ι (f : M →ₗ[R] CliffordAlgebra Q × N →ₗ[R] N)\n    (hf : ∀ m x fx, f m (ι Q m * x, f m (x, fx)) = Q m • fx) (n m) :\n    foldr' Q f hf n (ι Q m) = f m (1, n) :=\n  congr_arg Prod.snd (foldr_ι _ _ _ _ _)\n\n"}
{"name":"CliffordAlgebra.foldr'_ι_mul","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Fold","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nQ : QuadraticForm R M\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) (Prod (CliffordAlgebra Q) N) N)\nhf : ∀ (m : M) (x : CliffordAlgebra Q) (fx : N), Eq ((f m) { fst := HMul.hMul ((CliffordAlgebra.ι Q) m) x, snd := (f m) { fst := x, snd := fx } }) (HSMul.hSMul (Q m) fx)\nn : N\nm : M\nx : CliffordAlgebra Q\n⊢ Eq ((CliffordAlgebra.foldr' Q f hf n) (HMul.hMul ((CliffordAlgebra.ι Q) m) x)) ((f m) { fst := x, snd := (CliffordAlgebra.foldr' Q f hf n) x })","decl":"theorem foldr'_ι_mul (f : M →ₗ[R] CliffordAlgebra Q × N →ₗ[R] N)\n    (hf : ∀ m x fx, f m (ι Q m * x, f m (x, fx)) = Q m • fx) (n m) (x) :\n    foldr' Q f hf n (ι Q m * x) = f m (x, foldr' Q f hf n x) := by\n  dsimp [foldr']\n  rw [foldr_mul, foldr_ι, foldr'Aux_apply_apply]\n  refine congr_arg (f m) (Prod.mk.eta.symm.trans ?_)\n  congr 1\n  induction x using CliffordAlgebra.left_induction with\n  | algebraMap r => simp_rw [foldr_algebraMap, Prod.smul_mk, Algebra.algebraMap_eq_smul_one]\n  | add x y hx hy => rw [map_add, Prod.fst_add, hx, hy]\n  | ι_mul m x hx => rw [foldr_mul, foldr_ι, foldr'Aux_apply_apply, hx]\n\n"}
