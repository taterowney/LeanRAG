{"name":"IsSquare.nonneg","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : LinearOrder R\ninst✝⁴ : IsRightCancelAdd R\ninst✝³ : ZeroLEOneClass R\ninst✝² : ExistsAddOfLE R\ninst✝¹ : PosMulMono R\ninst✝ : AddLeftStrictMono R\nx : R\nh : IsSquare x\n⊢ LE.le 0 x","decl":"theorem IsSquare.nonneg [Semiring R] [LinearOrder R] [IsRightCancelAdd R]\n    [ZeroLEOneClass R] [ExistsAddOfLE R] [PosMulMono R] [AddLeftStrictMono R]\n    {x : R} (h : IsSquare x) : 0 ≤ x := by\n  rcases h with ⟨y, rfl⟩\n  exact mul_self_nonneg y\n\n"}
{"name":"MonoidHom.map_neg_one","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M : Type u_2\nR : Type u_3\ninst✝³ : Ring R\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftMono M\nf : MonoidHom R M\n⊢ Eq (f (-1)) 1","decl":"theorem map_neg_one : f (-1) = 1 :=\n  (pow_eq_one_iff (Nat.succ_ne_zero 1)).1 <| by rw [← map_pow, neg_one_sq, map_one]\n\n"}
{"name":"MonoidHom.map_neg","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M : Type u_2\nR : Type u_3\ninst✝³ : Ring R\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftMono M\nf : MonoidHom R M\nx : R\n⊢ Eq (f (Neg.neg x)) (f x)","decl":"@[simp]\ntheorem map_neg (x : R) : f (-x) = f x := by rw [← neg_one_mul, map_mul, map_neg_one, one_mul]\n\n"}
{"name":"MonoidHom.map_sub_swap","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M : Type u_2\nR : Type u_3\ninst✝³ : Ring R\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftMono M\nf : MonoidHom R M\nx y : R\n⊢ Eq (f (HSub.hSub x y)) (f (HSub.hSub y x))","decl":"theorem map_sub_swap (x y : R) : f (x - y) = f (y - x) := by rw [← map_neg, neg_sub]\n\n"}
{"name":"pow_add_pow_le","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : OrderedSemiring R\nx y : R\nn : Nat\nhx : LE.le 0 x\nhy : LE.le 0 y\nhn : Ne n 0\n⊢ LE.le (HAdd.hAdd (HPow.hPow x n) (HPow.hPow y n)) (HPow.hPow (HAdd.hAdd x y) n)","decl":"theorem pow_add_pow_le (hx : 0 ≤ x) (hy : 0 ≤ y) (hn : n ≠ 0) : x ^ n + y ^ n ≤ (x + y) ^ n := by\n  rcases Nat.exists_eq_add_one_of_ne_zero hn with ⟨k, rfl⟩\n  induction k with\n  | zero => simp only [zero_add, pow_one, le_refl]\n  | succ k ih =>\n    let n := k.succ\n    have h1 := add_nonneg (mul_nonneg hx (pow_nonneg hy n)) (mul_nonneg hy (pow_nonneg hx n))\n    have h2 := add_nonneg hx hy\n    calc\n      x ^ (n + 1) + y ^ (n + 1) ≤ x * x ^ n + y * y ^ n + (x * y ^ n + y * x ^ n) := by\n        rw [pow_succ' _ n, pow_succ' _ n]\n        exact le_add_of_nonneg_right h1\n      _ = (x + y) * (x ^ n + y ^ n) := by\n        rw [add_mul, mul_add, mul_add, add_comm (y * x ^ n), ← add_assoc, ← add_assoc,\n          add_assoc (x * x ^ n) (x * y ^ n), add_comm (x * y ^ n) (y * y ^ n), ← add_assoc]\n      _ ≤ (x + y) ^ (n + 1) := by\n        rw [pow_succ' _ n]\n        exact mul_le_mul_of_nonneg_left (ih (Nat.succ_ne_zero k)) h2\n\n"}
{"name":"mul_le_one","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M₀ : Type u_1\ninst✝⁴ : MonoidWithZero M₀\ninst✝³ : Preorder M₀\na b : M₀\ninst✝² : ZeroLEOneClass M₀\ninst✝¹ : PosMulMono M₀\ninst✝ : MulPosMono M₀\nha : LE.le a 1\nhb₀ : LE.le 0 b\nhb : LE.le b 1\n⊢ LE.le (HMul.hMul a b) 1","decl":"@[deprecated (since := \"2024-09-28\")] alias mul_le_one := mul_le_one₀\n"}
{"name":"pow_le_one","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M₀ : Type u_1\ninst✝⁴ : MonoidWithZero M₀\ninst✝³ : Preorder M₀\na : M₀\ninst✝² : ZeroLEOneClass M₀\ninst✝¹ : PosMulMono M₀\ninst✝ : MulPosMono M₀\nn : Nat\na✝¹ : LE.le 0 a\na✝ : LE.le a 1\n⊢ LE.le (HPow.hPow a n) 1","decl":"@[deprecated (since := \"2024-09-28\")] alias pow_le_one := pow_le_one₀\n"}
{"name":"pow_lt_one","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M₀ : Type u_1\ninst✝⁴ : MonoidWithZero M₀\ninst✝³ : Preorder M₀\na : M₀\ninst✝² : ZeroLEOneClass M₀\ninst✝¹ : PosMulMono M₀\ninst✝ : MulPosMono M₀\nh₀ : LE.le 0 a\nh₁ : LT.lt a 1\nn : Nat\na✝ : Ne n 0\n⊢ LT.lt (HPow.hPow a n) 1","decl":"@[deprecated (since := \"2024-09-28\")] alias pow_lt_one := pow_lt_one₀\n"}
{"name":"one_le_pow_of_one_le","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M₀ : Type u_1\ninst✝⁴ : MonoidWithZero M₀\ninst✝³ : Preorder M₀\na : M₀\ninst✝² : ZeroLEOneClass M₀\ninst✝¹ : PosMulMono M₀\ninst✝ : MulPosMono M₀\nha : LE.le 1 a\nn : Nat\n⊢ LE.le 1 (HPow.hPow a n)","decl":"@[deprecated (since := \"2024-09-28\")] alias one_le_pow_of_one_le := one_le_pow₀\n"}
{"name":"one_lt_pow","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M₀ : Type u_1\ninst✝⁴ : MonoidWithZero M₀\ninst✝³ : Preorder M₀\na : M₀\ninst✝² : ZeroLEOneClass M₀\ninst✝¹ : PosMulMono M₀\ninst✝ : MulPosMono M₀\nha : LT.lt 1 a\nn : Nat\na✝ : Ne n 0\n⊢ LT.lt 1 (HPow.hPow a n)","decl":"@[deprecated (since := \"2024-09-28\")] alias one_lt_pow := one_lt_pow₀\n"}
{"name":"pow_right_mono","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M₀ : Type u_1\ninst✝⁴ : MonoidWithZero M₀\ninst✝³ : Preorder M₀\na : M₀\ninst✝² : ZeroLEOneClass M₀\ninst✝¹ : PosMulMono M₀\ninst✝ : MulPosMono M₀\nh : LE.le 1 a\n⊢ Monotone fun x => HPow.hPow a x","decl":"@[deprecated (since := \"2024-10-04\")] alias pow_right_mono := pow_right_mono₀\n"}
{"name":"pow_le_pow_right","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"M₀ : Type u_1\ninst✝⁴ : MonoidWithZero M₀\ninst✝³ : Preorder M₀\na : M₀\nm n : Nat\ninst✝² : ZeroLEOneClass M₀\ninst✝¹ : PosMulMono M₀\ninst✝ : MulPosMono M₀\nha : LE.le 1 a\nhmn : LE.le m n\n⊢ LE.le (HPow.hPow a m) (HPow.hPow a n)","decl":"@[deprecated (since := \"2024-10-04\")] alias pow_le_pow_right := pow_le_pow_right₀\n\n"}
{"name":"pow_le_pow_left","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : OrderedSemiring R\na b : R\nha : LE.le 0 a\nhab : LE.le a b\nn : Nat\n⊢ LE.le (HPow.hPow a n) (HPow.hPow b n)","decl":"@[deprecated pow_le_pow_left₀ (since := \"2024-11-13\")]\ntheorem pow_le_pow_left {a b : R} (ha : 0 ≤ a) (hab : a ≤ b) : ∀ n, a ^ n ≤ b ^ n :=\n  pow_le_pow_left₀ ha hab\n\n"}
{"name":"pow_add_pow_le'","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : OrderedSemiring R\na b : R\nn : Nat\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ LE.le (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)) (HMul.hMul 2 (HPow.hPow (HAdd.hAdd a b) n))","decl":"lemma pow_add_pow_le' (ha : 0 ≤ a) (hb : 0 ≤ b) : a ^ n + b ^ n ≤ 2 * (a + b) ^ n := by\n  rw [two_mul]\n  exact add_le_add (pow_le_pow_left₀ ha (le_add_of_nonneg_right hb) _)\n    (pow_le_pow_left₀ hb (le_add_of_nonneg_left ha) _)\n\n"}
{"name":"pow_lt_pow_left","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\nx y : R\nh : LT.lt x y\nhx : LE.le 0 x\nn : Nat\na✝ : Ne n 0\n⊢ LT.lt (HPow.hPow x n) (HPow.hPow y n)","decl":"@[deprecated pow_lt_pow_left₀ (since := \"2024-11-13\")]\ntheorem pow_lt_pow_left (h : x < y) (hx : 0 ≤ x) : ∀ {n : ℕ}, n ≠ 0 → x ^ n < y ^ n :=\n  pow_lt_pow_left₀ h hx\n\n"}
{"name":"pow_left_strictMonoOn","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\nn : Nat\nhn : Ne n 0\n⊢ StrictMonoOn (fun x => HPow.hPow x n) (setOf fun a => LE.le 0 a)","decl":"@[deprecated pow_left_strictMonoOn₀ (since := \"2024-11-13\")]\nlemma pow_left_strictMonoOn (hn : n ≠ 0) : StrictMonoOn (· ^ n : R → R) {a | 0 ≤ a} :=\n  pow_left_strictMonoOn₀ hn\n\n"}
{"name":"pow_right_strictMono","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\na : R\nh : LT.lt 1 a\n⊢ StrictMono fun x => HPow.hPow a x","decl":"@[deprecated pow_right_strictMono₀ (since := \"2024-11-13\")]\nlemma pow_right_strictMono (h : 1 < a) : StrictMono (a ^ ·) :=\n  pow_right_strictMono₀ h\n\n"}
{"name":"pow_lt_pow_right","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\na : R\nn m : Nat\nh : LT.lt 1 a\nhmn : LT.lt m n\n⊢ LT.lt (HPow.hPow a m) (HPow.hPow a n)","decl":"@[deprecated pow_lt_pow_right₀ (since := \"2024-11-13\")]\ntheorem pow_lt_pow_right (h : 1 < a) (hmn : m < n) : a ^ m < a ^ n :=\n  pow_lt_pow_right₀ h hmn\n\n"}
{"name":"pow_lt_pow_iff_right","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\na : R\nn m : Nat\nh : LT.lt 1 a\n⊢ Iff (LT.lt (HPow.hPow a n) (HPow.hPow a m)) (LT.lt n m)","decl":"@[deprecated pow_lt_pow_iff_right₀ (since := \"2024-11-13\")]\nlemma pow_lt_pow_iff_right (h : 1 < a) : a ^ n < a ^ m ↔ n < m := pow_lt_pow_iff_right₀ h\n\n"}
{"name":"pow_le_pow_iff_right","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\na : R\nn m : Nat\nh : LT.lt 1 a\n⊢ Iff (LE.le (HPow.hPow a n) (HPow.hPow a m)) (LE.le n m)","decl":"@[deprecated pow_le_pow_iff_right₀ (since := \"2024-11-13\")]\nlemma pow_le_pow_iff_right (h : 1 < a) : a ^ n ≤ a ^ m ↔ n ≤ m := pow_le_pow_iff_right₀ h\n\n"}
{"name":"lt_self_pow","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\na : R\nm : Nat\nh : LT.lt 1 a\nhm : LT.lt 1 m\n⊢ LT.lt a (HPow.hPow a m)","decl":"@[deprecated lt_self_pow₀ (since := \"2024-11-13\")]\ntheorem lt_self_pow (h : 1 < a) (hm : 1 < m) : a < a ^ m := lt_self_pow₀ h hm\n\n"}
{"name":"pow_right_strictAnti","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\na : R\nh₀ : LT.lt 0 a\nh₁ : LT.lt a 1\n⊢ StrictAnti fun x => HPow.hPow a x","decl":"@[deprecated pow_right_strictAnti₀ (since := \"2024-11-13\")]\ntheorem pow_right_strictAnti (h₀ : 0 < a) (h₁ : a < 1) : StrictAnti (a ^ ·) :=\n  pow_right_strictAnti₀ h₀ h₁\n\n"}
{"name":"pow_lt_pow_iff_right_of_lt_one","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\na : R\nn m : Nat\nh₀ : LT.lt 0 a\nh₁ : LT.lt a 1\n⊢ Iff (LT.lt (HPow.hPow a m) (HPow.hPow a n)) (LT.lt n m)","decl":"@[deprecated pow_lt_pow_iff_right_of_lt_one₀ (since := \"2024-11-13\")]\ntheorem pow_lt_pow_iff_right_of_lt_one (h₀ : 0 < a) (h₁ : a < 1) : a ^ m < a ^ n ↔ n < m :=\n  pow_lt_pow_iff_right_of_lt_one₀ h₀ h₁\n\n"}
{"name":"pow_lt_pow_right_of_lt_one","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\na : R\nn m : Nat\nh₀ : LT.lt 0 a\nh₁ : LT.lt a 1\nhmn : LT.lt m n\n⊢ LT.lt (HPow.hPow a n) (HPow.hPow a m)","decl":"@[deprecated pow_lt_pow_right_of_lt_one₀ (since := \"2024-11-13\")]\ntheorem pow_lt_pow_right_of_lt_one (h₀ : 0 < a) (h₁ : a < 1) (hmn : m < n) : a ^ n < a ^ m :=\n  pow_lt_pow_right_of_lt_one₀ h₀ h₁ hmn\n\n"}
{"name":"pow_lt_self_of_lt_one","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedSemiring R\na : R\nn : Nat\nh₀ : LT.lt 0 a\nh₁ : LT.lt a 1\nhn : LT.lt 1 n\n⊢ LT.lt (HPow.hPow a n) a","decl":"@[deprecated pow_lt_self_of_lt_one₀ (since := \"2024-11-13\")]\ntheorem pow_lt_self_of_lt_one (h₀ : 0 < a) (h₁ : a < 1) (hn : 1 < n) : a ^ n < a :=\n  pow_lt_self_of_lt_one₀ h₀ h₁ hn\n\n"}
{"name":"sq_pos_of_neg","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : StrictOrderedRing R\na : R\nha : LT.lt a 0\n⊢ LT.lt 0 (HPow.hPow a 2)","decl":"lemma sq_pos_of_neg (ha : a < 0) : 0 < a ^ 2 := by rw [sq]; exact mul_pos_of_neg_of_neg ha ha\n\n"}
{"name":"pow_le_pow_iff_left","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na b : R\nn : Nat\nha : LE.le 0 a\nhb : LE.le 0 b\nhn : Ne n 0\n⊢ Iff (LE.le (HPow.hPow a n) (HPow.hPow b n)) (LE.le a b)","decl":"@[deprecated pow_le_pow_iff_left₀ (since := \"2024-11-12\")]\nlemma pow_le_pow_iff_left (ha : 0 ≤ a) (hb : 0 ≤ b) (hn : n ≠ 0) : a ^ n ≤ b ^ n ↔ a ≤ b :=\n  pow_le_pow_iff_left₀ ha hb hn\n\n"}
{"name":"pow_lt_pow_iff_left","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na b : R\nn : Nat\nha : LE.le 0 a\nhb : LE.le 0 b\nhn : Ne n 0\n⊢ Iff (LT.lt (HPow.hPow a n) (HPow.hPow b n)) (LT.lt a b)","decl":"@[deprecated pow_lt_pow_iff_left₀ (since := \"2024-11-12\")]\nlemma pow_lt_pow_iff_left (ha : 0 ≤ a) (hb : 0 ≤ b) (hn : n ≠ 0) : a ^ n < b ^ n ↔ a < b :=\n  pow_lt_pow_iff_left₀ ha hb hn\n\n"}
{"name":"pow_left_inj","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na b : R\nn : Nat\nha : LE.le 0 a\nhb : LE.le 0 b\nhn : Ne n 0\n⊢ Iff (Eq (HPow.hPow a n) (HPow.hPow b n)) (Eq a b)","decl":"@[deprecated pow_left_inj₀ (since := \"2024-11-12\")]\nlemma pow_left_inj (ha : 0 ≤ a) (hb : 0 ≤ b) (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b :=\n  pow_left_inj₀ ha hb hn\n\n"}
{"name":"pow_right_injective","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na : R\nha₀ : LT.lt 0 a\nha₁ : Ne a 1\n⊢ Function.Injective fun x => HPow.hPow a x","decl":"@[deprecated pow_right_injective₀ (since := \"2024-11-12\")]\nlemma pow_right_injective (ha₀ : 0 < a) (ha₁ : a ≠ 1) : Injective (a ^ ·) :=\n  pow_right_injective₀ ha₀ ha₁\n\n"}
{"name":"pow_right_inj","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na : R\nm n : Nat\nha₀ : LT.lt 0 a\nha₁ : Ne a 1\n⊢ Iff (Eq (HPow.hPow a m) (HPow.hPow a n)) (Eq m n)","decl":"@[deprecated pow_right_inj₀ (since := \"2024-11-12\")]\nlemma pow_right_inj (ha₀ : 0 < a) (ha₁ : a ≠ 1) : a ^ m = a ^ n ↔ m = n := pow_right_inj₀ ha₀ ha₁\n\n"}
{"name":"sq_le_one_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na : R\nha : LE.le 0 a\n⊢ Iff (LE.le (HPow.hPow a 2) 1) (LE.le a 1)","decl":"@[deprecated sq_le_one_iff₀ (since := \"2024-11-12\")]\ntheorem sq_le_one_iff {a : R} (ha : 0 ≤ a) : a ^ 2 ≤ 1 ↔ a ≤ 1 := sq_le_one_iff₀ ha\n\n"}
{"name":"sq_lt_one_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na : R\nha : LE.le 0 a\n⊢ Iff (LT.lt (HPow.hPow a 2) 1) (LT.lt a 1)","decl":"@[deprecated sq_lt_one_iff₀ (since := \"2024-11-12\")]\ntheorem sq_lt_one_iff {a : R} (ha : 0 ≤ a) : a ^ 2 < 1 ↔ a < 1 := sq_lt_one_iff₀ ha\n\n"}
{"name":"one_le_sq_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na : R\nha : LE.le 0 a\n⊢ Iff (LE.le 1 (HPow.hPow a 2)) (LE.le 1 a)","decl":"@[deprecated one_le_sq_iff₀ (since := \"2024-11-12\")]\ntheorem one_le_sq_iff {a : R} (ha : 0 ≤ a) : 1 ≤ a ^ 2 ↔ 1 ≤ a := one_le_sq_iff₀ ha\n\n"}
{"name":"one_lt_sq_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na : R\nha : LE.le 0 a\n⊢ Iff (LT.lt 1 (HPow.hPow a 2)) (LT.lt 1 a)","decl":"@[deprecated one_lt_sq_iff₀ (since := \"2024-11-12\")]\ntheorem one_lt_sq_iff {a : R} (ha : 0 ≤ a) : 1 < a ^ 2 ↔ 1 < a := one_lt_sq_iff₀ ha\n\n"}
{"name":"lt_of_pow_lt_pow_left","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na b : R\nn : Nat\nhb : LE.le 0 b\nh : LT.lt (HPow.hPow a n) (HPow.hPow b n)\n⊢ LT.lt a b","decl":"@[deprecated lt_of_pow_lt_pow_left₀ (since := \"2024-11-12\")]\ntheorem lt_of_pow_lt_pow_left (n : ℕ) (hb : 0 ≤ b) (h : a ^ n < b ^ n) : a < b :=\n  lt_of_pow_lt_pow_left₀ n hb h\n\n"}
{"name":"le_of_pow_le_pow_left","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na b : R\nn : Nat\nhn : Ne n 0\nhb : LE.le 0 b\nh : LE.le (HPow.hPow a n) (HPow.hPow b n)\n⊢ LE.le a b","decl":"@[deprecated le_of_pow_le_pow_left₀ (since := \"2024-11-12\")]\ntheorem le_of_pow_le_pow_left (hn : n ≠ 0) (hb : 0 ≤ b) (h : a ^ n ≤ b ^ n) : a ≤ b :=\n  le_of_pow_le_pow_left₀ hn hb h\n\n"}
{"name":"sq_eq_sq","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na b : R\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ Iff (Eq (HPow.hPow a 2) (HPow.hPow b 2)) (Eq a b)","decl":"@[deprecated sq_eq_sq₀ (since := \"2024-11-12\")]\ntheorem sq_eq_sq {a b : R} (ha : 0 ≤ a) (hb : 0 ≤ b) : a ^ 2 = b ^ 2 ↔ a = b := sq_eq_sq₀ ha hb\n\n"}
{"name":"lt_of_mul_self_lt_mul_self","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝ : LinearOrderedSemiring R\na b : R\nhb : LE.le 0 b\na✝ : LT.lt (HMul.hMul a a) (HMul.hMul b b)\n⊢ LT.lt a b","decl":"@[deprecated lt_of_mul_self_lt_mul_self₀ (since := \"2024-11-12\")]\ntheorem lt_of_mul_self_lt_mul_self (hb : 0 ≤ b) : a * a < b * b → a < b :=\n  lt_of_mul_self_lt_mul_self₀ hb\n\n"}
{"name":"add_sq_le","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na b : R\ninst✝ : ExistsAddOfLE R\n⊢ LE.le (HPow.hPow (HAdd.hAdd a b) 2) (HMul.hMul 2 (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)))","decl":"lemma add_sq_le : (a + b) ^ 2 ≤ 2 * (a ^ 2 + b ^ 2) := by\n  calc\n    (a + b) ^ 2 = a ^ 2 + b ^ 2 + (a * b + b * a) := by\n        simp_rw [pow_succ', pow_zero, mul_one, add_mul, mul_add, add_comm (b * a), add_add_add_comm]\n    _ ≤ a ^ 2 + b ^ 2 + (a * a + b * b) := add_le_add_left ?_ _\n    _ = _ := by simp_rw [pow_succ', pow_zero, mul_one, two_mul]\n  cases le_total a b\n  · exact mul_add_mul_le_mul_add_mul ‹_› ‹_›\n  · exact mul_add_mul_le_mul_add_mul' ‹_› ‹_›\n\n-- TODO: Use `gcongr`, `positivity`, `ring` once those tactics are made available here\n"}
{"name":"add_pow_le","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na b : R\ninst✝ : ExistsAddOfLE R\nha : LE.le 0 a\nhb : LE.le 0 b\nn : Nat\n⊢ LE.le (HPow.hPow (HAdd.hAdd a b) n) (HMul.hMul (HPow.hPow 2 (HSub.hSub n 1)) (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)))","decl":"lemma add_pow_le (ha : 0 ≤ a) (hb : 0 ≤ b) : ∀ n, (a + b) ^ n ≤ 2 ^ (n - 1) * (a ^ n + b ^ n)\n  | 0 => by simp\n  | 1 => by simp\n  | n + 2 => by\n    rw [pow_succ]\n    calc\n      _ ≤ 2 ^ n * (a ^ (n + 1) + b ^ (n + 1)) * (a + b) :=\n          mul_le_mul_of_nonneg_right (add_pow_le ha hb (n + 1)) <| add_nonneg ha hb\n      _ = 2 ^ n * (a ^ (n + 2) + b ^ (n + 2) + (a ^ (n + 1) * b + b ^ (n + 1) * a)) := by\n          rw [mul_assoc, mul_add, add_mul, add_mul, ← pow_succ, ← pow_succ, add_comm _ (b ^ _),\n            add_add_add_comm, add_comm (_ * a)]\n      _ ≤ 2 ^ n * (a ^ (n + 2) + b ^ (n + 2) + (a ^ (n + 1) * a + b ^ (n + 1) * b)) :=\n          mul_le_mul_of_nonneg_left (add_le_add_left ?_ _) <| pow_nonneg (zero_le_two (α := R)) _\n      _ = _ := by simp only [← pow_succ, ← two_mul, ← mul_assoc]; rfl\n    · obtain hab | hba := le_total a b\n      · exact mul_add_mul_le_mul_add_mul (pow_le_pow_left₀ ha hab _) hab\n      · exact mul_add_mul_le_mul_add_mul' (pow_le_pow_left₀ hb hba _) hba\n\n"}
{"name":"Even.add_pow_le","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na b : R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Even n\n⊢ LE.le (HPow.hPow (HAdd.hAdd a b) n) (HMul.hMul (HPow.hPow 2 (HSub.hSub n 1)) (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)))","decl":"protected lemma Even.add_pow_le (hn : Even n) :\n    (a + b) ^ n ≤ 2 ^ (n - 1) * (a ^ n + b ^ n) := by\n  obtain ⟨n, rfl⟩ := hn\n  rw [← two_mul, pow_mul]\n  calc\n    _ ≤ (2 * (a ^ 2 + b ^ 2)) ^ n := pow_le_pow_left₀ (sq_nonneg _) add_sq_le _\n    _ = 2 ^ n * (a ^ 2 + b ^ 2) ^ n := by -- TODO: Should be `Nat.cast_commute`\n        rw [Commute.mul_pow]; simp [Commute, SemiconjBy, two_mul, mul_two]\n    _ ≤ 2 ^ n * (2 ^ (n - 1) * ((a ^ 2) ^ n + (b ^ 2) ^ n)) := mul_le_mul_of_nonneg_left\n          (add_pow_le (sq_nonneg _) (sq_nonneg _) _) <| pow_nonneg (zero_le_two (α := R)) _\n    _ = _ := by\n      simp only [← mul_assoc, ← pow_add, ← pow_mul]\n      cases n\n      · rfl\n      · simp [Nat.two_mul]\n\n"}
{"name":"Even.pow_nonneg","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Even n\na : R\n⊢ LE.le 0 (HPow.hPow a n)","decl":"lemma Even.pow_nonneg (hn : Even n) (a : R) : 0 ≤ a ^ n := by\n  obtain ⟨k, rfl⟩ := hn; rw [pow_add]; exact mul_self_nonneg _\n\n"}
{"name":"Even.pow_pos","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na : R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Even n\nha : Ne a 0\n⊢ LT.lt 0 (HPow.hPow a n)","decl":"lemma Even.pow_pos (hn : Even n) (ha : a ≠ 0) : 0 < a ^ n :=\n  (hn.pow_nonneg _).lt_of_ne' (pow_ne_zero _ ha)\n\n"}
{"name":"Even.pow_pos_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na : R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Even n\nh₀ : Ne n 0\n⊢ Iff (LT.lt 0 (HPow.hPow a n)) (Ne a 0)","decl":"lemma Even.pow_pos_iff (hn : Even n) (h₀ : n ≠ 0) : 0 < a ^ n ↔ a ≠ 0 := by\n  obtain ⟨k, rfl⟩ := hn; rw [pow_add, mul_self_pos (α := R), pow_ne_zero_iff (by simpa using h₀)]\n\n"}
{"name":"Odd.pow_neg_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na : R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Odd n\n⊢ Iff (LT.lt (HPow.hPow a n) 0) (LT.lt a 0)","decl":"lemma Odd.pow_neg_iff (hn : Odd n) : a ^ n < 0 ↔ a < 0 := by\n  refine ⟨lt_imp_lt_of_le_imp_le (pow_nonneg · _), fun ha ↦ ?_⟩\n  obtain ⟨k, rfl⟩ := hn\n  rw [pow_succ]\n  exact mul_neg_of_pos_of_neg ((even_two_mul _).pow_pos ha.ne) ha\n\n"}
{"name":"Odd.pow_nonneg_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na : R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Odd n\n⊢ Iff (LE.le 0 (HPow.hPow a n)) (LE.le 0 a)","decl":"lemma Odd.pow_nonneg_iff (hn : Odd n) : 0 ≤ a ^ n ↔ 0 ≤ a :=\n  le_iff_le_iff_lt_iff_lt.2 hn.pow_neg_iff\n\n"}
{"name":"Odd.pow_nonpos_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na : R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Odd n\n⊢ Iff (LE.le (HPow.hPow a n) 0) (LE.le a 0)","decl":"lemma Odd.pow_nonpos_iff (hn : Odd n) : a ^ n ≤ 0 ↔ a ≤ 0 := by\n  rw [le_iff_lt_or_eq, le_iff_lt_or_eq, hn.pow_neg_iff, pow_eq_zero_iff]\n  rintro rfl; simp [Odd, eq_comm (a := 0)] at hn\n\n"}
{"name":"Odd.pow_pos_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na : R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Odd n\n⊢ Iff (LT.lt 0 (HPow.hPow a n)) (LT.lt 0 a)","decl":"lemma Odd.pow_pos_iff (hn : Odd n) : 0 < a ^ n ↔ 0 < a := lt_iff_lt_of_le_iff_le hn.pow_nonpos_iff\n\n"}
{"name":"Odd.pow_nonpos","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na : R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Odd n\na✝ : LE.le a 0\n⊢ LE.le (HPow.hPow a n) 0","decl":"alias ⟨_, Odd.pow_nonpos⟩ := Odd.pow_nonpos_iff\n"}
{"name":"Odd.pow_neg","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na : R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Odd n\na✝ : LT.lt a 0\n⊢ LT.lt (HPow.hPow a n) 0","decl":"alias ⟨_, Odd.pow_neg⟩ := Odd.pow_neg_iff\n\n"}
{"name":"Odd.strictMono_pow","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\nn : Nat\ninst✝ : ExistsAddOfLE R\nhn : Odd n\n⊢ StrictMono fun a => HPow.hPow a n","decl":"lemma Odd.strictMono_pow (hn : Odd n) : StrictMono fun a : R => a ^ n := by\n  have hn₀ : n ≠ 0 := by rintro rfl; simp [Odd, eq_comm (a := 0)] at hn\n  intro a b hab\n  obtain ha | ha := le_total 0 a\n  · exact pow_lt_pow_left₀ hab ha hn₀\n  obtain hb | hb := lt_or_le 0 b\n  · exact (hn.pow_nonpos ha).trans_lt (pow_pos hb _)\n  obtain ⟨c, hac⟩ := exists_add_of_le ha\n  obtain ⟨d, hbd⟩ := exists_add_of_le hb\n  have hd := nonneg_of_le_add_right (hb.trans_eq hbd)\n  refine lt_of_add_lt_add_right (a := c ^ n + d ^ n) ?_\n  dsimp\n  calc\n    a ^ n + (c ^ n + d ^ n) = d ^ n := by\n      rw [← add_assoc, hn.pow_add_pow_eq_zero hac.symm, zero_add]\n    _ < c ^ n := pow_lt_pow_left₀ ?_ hd hn₀\n    _ = b ^ n + (c ^ n + d ^ n) := by rw [add_left_comm, hn.pow_add_pow_eq_zero hbd.symm, add_zero]\n  refine lt_of_add_lt_add_right (a := a + b) ?_\n  rwa [add_rotate', ← hbd, add_zero, add_left_comm, ← add_assoc, ← hac, zero_add]\n\n"}
{"name":"sq_pos_iff","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\ninst✝ : ExistsAddOfLE R\na : R\n⊢ Iff (LT.lt 0 (HPow.hPow a 2)) (Ne a 0)","decl":"lemma sq_pos_iff {a : R} : 0 < a ^ 2 ↔ a ≠ 0 := even_two.pow_pos_iff two_ne_zero\n\n"}
{"name":"sq_pos_of_ne_zero","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\ninst✝ : ExistsAddOfLE R\na : R\na✝ : Ne a 0\n⊢ LT.lt 0 (HPow.hPow a 2)","decl":"alias ⟨_, sq_pos_of_ne_zero⟩ := sq_pos_iff\n"}
{"name":"pow_two_pos_of_ne_zero","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\ninst✝ : ExistsAddOfLE R\na : R\na✝ : Ne a 0\n⊢ LT.lt 0 (HPow.hPow a 2)","decl":"alias pow_two_pos_of_ne_zero := sq_pos_of_ne_zero\n\n"}
{"name":"pow_four_le_pow_two_of_pow_two_le","module":"Mathlib.Algebra.Order.Ring.Basic","initialProofState":"R : Type u_3\ninst✝¹ : LinearOrderedSemiring R\na b : R\ninst✝ : ExistsAddOfLE R\nh : LE.le (HPow.hPow a 2) b\n⊢ LE.le (HPow.hPow a 4) (HPow.hPow b 2)","decl":"lemma pow_four_le_pow_two_of_pow_two_le (h : a ^ 2 ≤ b) : a ^ 4 ≤ b ^ 2 :=\n  (pow_mul a 2 2).symm ▸ pow_le_pow_left₀ (sq_nonneg a) h 2\n\n"}
