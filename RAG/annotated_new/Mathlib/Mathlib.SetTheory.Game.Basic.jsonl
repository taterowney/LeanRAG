{"name":"SetTheory.Game.zero_def","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ Eq 0 (Quotient.mk SetTheory.PGame.setoid 0)","decl":"theorem zero_def : (0 : Game) = ⟦0⟧ :=\n  rfl\n\n"}
{"name":"SetTheory.Game.not_le","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.Game\n⊢ Iff (Not (LE.le x y)) (y.LF x)","decl":"/-- On `Game`, simp-normal inequalities should use as few negations as possible. -/\n@[simp]\ntheorem not_le : ∀ {x y : Game}, ¬x ≤ y ↔ Game.LF y x := by\n  rintro ⟨x⟩ ⟨y⟩\n  exact PGame.not_le\n\n"}
{"name":"SetTheory.Game.not_lf","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.Game\n⊢ Iff (Not (x.LF y)) (LE.le y x)","decl":"/-- On `Game`, simp-normal inequalities should use as few negations as possible. -/\n@[simp]\ntheorem not_lf : ∀ {x y : Game}, ¬Game.LF x y ↔ y ≤ x := by\n  rintro ⟨x⟩ ⟨y⟩\n  exact PGame.not_lf\n\n"}
{"name":"SetTheory.Game.instIsTrichotomousLF","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ IsTrichotomous SetTheory.Game SetTheory.Game.LF","decl":"instance : IsTrichotomous Game LF :=\n  ⟨by\n    rintro ⟨x⟩ ⟨y⟩\n    change _ ∨ ⟦x⟧ = ⟦y⟧ ∨ _\n    rw [Quotient.eq]\n    apply lf_or_equiv_or_gf⟩\n\n"}
{"name":"SetTheory.PGame.le_iff_game_le","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LE.le x y) (LE.le (Quotient.mk SetTheory.PGame.setoid x) (Quotient.mk SetTheory.PGame.setoid y))","decl":"theorem le_iff_game_le {x y : PGame} : x ≤ y ↔ (⟦x⟧ : Game) ≤ ⟦y⟧ :=\n  Iff.rfl\n\n"}
{"name":"SetTheory.PGame.lf_iff_game_lf","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.LF y) (SetTheory.Game.LF (Quotient.mk SetTheory.PGame.setoid x) (Quotient.mk SetTheory.PGame.setoid y))","decl":"theorem lf_iff_game_lf {x y : PGame} : x ⧏ y ↔ Game.LF ⟦x⟧ ⟦y⟧ :=\n  Iff.rfl\n\n"}
{"name":"SetTheory.PGame.lt_iff_game_lt","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LT.lt x y) (LT.lt (Quotient.mk SetTheory.PGame.setoid x) (Quotient.mk SetTheory.PGame.setoid y))","decl":"theorem lt_iff_game_lt {x y : PGame} : x < y ↔ (⟦x⟧ : Game) < ⟦y⟧ :=\n  Iff.rfl\n\n"}
{"name":"SetTheory.PGame.equiv_iff_game_eq","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv x y) (Eq (Quotient.mk SetTheory.PGame.setoid x) (Quotient.mk SetTheory.PGame.setoid y))","decl":"theorem equiv_iff_game_eq {x y : PGame} : x ≈ y ↔ (⟦x⟧ : Game) = ⟦y⟧ :=\n  (@Quotient.eq' _ _ x y).symm\n\n"}
{"name":"SetTheory.PGame.game_eq","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\na✝ : HasEquiv.Equiv x y\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid x) (Quotient.mk SetTheory.PGame.setoid y)","decl":"alias ⟨game_eq, _⟩ := equiv_iff_game_eq\n\n"}
{"name":"SetTheory.PGame.fuzzy_iff_game_fuzzy","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.Fuzzy y) (SetTheory.Game.Fuzzy (Quotient.mk SetTheory.PGame.setoid x) (Quotient.mk SetTheory.PGame.setoid y))","decl":"theorem fuzzy_iff_game_fuzzy {x y : PGame} : x ‖ y ↔ Game.Fuzzy ⟦x⟧ ⟦y⟧ :=\n  Iff.rfl\n\n"}
{"name":"SetTheory.Game.addLeftMono","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ AddLeftMono SetTheory.Game","decl":"instance addLeftMono : AddLeftMono Game :=\n  ⟨by\n    rintro ⟨a⟩ ⟨b⟩ ⟨c⟩ h\n    exact @add_le_add_left _ _ _ _ b c h a⟩\n\n"}
{"name":"SetTheory.Game.addRightMono","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ AddRightMono SetTheory.Game","decl":"instance addRightMono : AddRightMono Game :=\n  ⟨by\n    rintro ⟨a⟩ ⟨b⟩ ⟨c⟩ h\n    exact @add_le_add_right _ _ _ _ b c h a⟩\n\n"}
{"name":"SetTheory.Game.addLeftStrictMono","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ AddLeftStrictMono SetTheory.Game","decl":"instance addLeftStrictMono : AddLeftStrictMono Game :=\n  ⟨by\n    rintro ⟨a⟩ ⟨b⟩ ⟨c⟩ h\n    exact @add_lt_add_left _ _ _ _ b c h a⟩\n\n"}
{"name":"SetTheory.Game.addRightStrictMono","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ AddRightStrictMono SetTheory.Game","decl":"instance addRightStrictMono : AddRightStrictMono Game :=\n  ⟨by\n    rintro ⟨a⟩ ⟨b⟩ ⟨c⟩ h\n    exact @add_lt_add_right _ _ _ _ b c h a⟩\n\n"}
{"name":"SetTheory.Game.add_lf_add_right","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"b c : SetTheory.Game\nx✝ : b.LF c\na : SetTheory.Game\n⊢ (HAdd.hAdd b a).LF (HAdd.hAdd c a)","decl":"theorem add_lf_add_right : ∀ {b c : Game} (_ : b ⧏ c) (a), (b + a : Game) ⧏ c + a := by\n  rintro ⟨b⟩ ⟨c⟩ h ⟨a⟩\n  apply PGame.add_lf_add_right h\n\n"}
{"name":"SetTheory.Game.add_lf_add_left","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"b c : SetTheory.Game\nx✝ : b.LF c\na : SetTheory.Game\n⊢ (HAdd.hAdd a b).LF (HAdd.hAdd a c)","decl":"theorem add_lf_add_left : ∀ {b c : Game} (_ : b ⧏ c) (a), (a + b : Game) ⧏ a + c := by\n  rintro ⟨b⟩ ⟨c⟩ h ⟨a⟩\n  apply PGame.add_lf_add_left h\n\n"}
{"name":"SetTheory.Game.bddAbove_range_of_small","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → SetTheory.Game\n⊢ BddAbove (Set.range f)","decl":"/-- A small family of games is bounded above. -/\nlemma bddAbove_range_of_small {ι : Type*} [Small.{u} ι] (f : ι → Game.{u}) :\n    BddAbove (Set.range f) := by\n  obtain ⟨x, hx⟩ := PGame.bddAbove_range_of_small (Quotient.out ∘ f)\n  refine ⟨⟦x⟧, Set.forall_mem_range.2 fun i ↦ ?_⟩\n  simpa [PGame.le_iff_game_le] using hx <| Set.mem_range_self i\n\n"}
{"name":"SetTheory.Game.bddAbove_of_small","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"s : Set SetTheory.Game\ninst✝ : Small.{u, u + 1} ↑s\n⊢ BddAbove s","decl":"/-- A small set of games is bounded above. -/\nlemma bddAbove_of_small (s : Set Game.{u}) [Small.{u} s] : BddAbove s := by\n  simpa using bddAbove_range_of_small (Subtype.val : s → Game.{u})\n\n"}
{"name":"SetTheory.Game.bddBelow_range_of_small","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → SetTheory.Game\n⊢ BddBelow (Set.range f)","decl":"/-- A small family of games is bounded below. -/\nlemma bddBelow_range_of_small {ι : Type*} [Small.{u} ι] (f : ι → Game.{u}) :\n    BddBelow (Set.range f) := by\n  obtain ⟨x, hx⟩ := PGame.bddBelow_range_of_small (Quotient.out ∘ f)\n  refine ⟨⟦x⟧, Set.forall_mem_range.2 fun i ↦ ?_⟩\n  simpa [PGame.le_iff_game_le] using hx <| Set.mem_range_self i\n\n"}
{"name":"SetTheory.Game.bddBelow_of_small","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"s : Set SetTheory.Game\ninst✝ : Small.{u, u + 1} ↑s\n⊢ BddBelow s","decl":"/-- A small set of games is bounded below. -/\nlemma bddBelow_of_small (s : Set Game.{u}) [Small.{u} s] : BddBelow s := by\n  simpa using bddBelow_range_of_small (Subtype.val : s → Game.{u})\n\n"}
{"name":"SetTheory.PGame.quot_zero","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ Eq (Quotient.mk SetTheory.PGame.setoid 0) 0","decl":"@[simp] theorem quot_zero : (⟦0⟧ : Game) = 0 := rfl\n"}
{"name":"SetTheory.PGame.quot_one","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ Eq (Quotient.mk SetTheory.PGame.setoid 1) 1","decl":"@[simp] theorem quot_one : (⟦1⟧ : Game) = 1 := rfl\n"}
{"name":"SetTheory.PGame.quot_neg","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"a : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (Neg.neg a)) (Neg.neg (Quotient.mk SetTheory.PGame.setoid a))","decl":"@[simp] theorem quot_neg (a : PGame) : (⟦-a⟧ : Game) = -⟦a⟧ := rfl\n"}
{"name":"SetTheory.PGame.quot_add","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"a b : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HAdd.hAdd a b)) (HAdd.hAdd (Quotient.mk SetTheory.PGame.setoid a) (Quotient.mk SetTheory.PGame.setoid b))","decl":"@[simp] theorem quot_add (a b : PGame) : ⟦a + b⟧ = (⟦a⟧ : Game) + ⟦b⟧ := rfl\n"}
{"name":"SetTheory.PGame.quot_sub","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"a b : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HSub.hSub a b)) (HSub.hSub (Quotient.mk SetTheory.PGame.setoid a) (Quotient.mk SetTheory.PGame.setoid b))","decl":"@[simp] theorem quot_sub (a b : PGame) : ⟦a - b⟧ = (⟦a⟧ : Game) - ⟦b⟧ := rfl\n\n"}
{"name":"SetTheory.PGame.quot_natCast","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"n : Nat\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid ↑n) ↑n","decl":"@[simp]\ntheorem quot_natCast : ∀ n : ℕ, ⟦(n : PGame)⟧ = (n : Game)\n  | 0 => rfl\n  | n + 1 => by\n    rw [PGame.nat_succ, quot_add, Nat.cast_add, Nat.cast_one, quot_natCast]\n    rfl\n\n"}
{"name":"SetTheory.PGame.quot_eq_of_mk'_quot_eq","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\nL : Equiv x.LeftMoves y.LeftMoves\nR : Equiv x.RightMoves y.RightMoves\nhl : ∀ (i : x.LeftMoves), Eq (Quotient.mk SetTheory.PGame.setoid (x.moveLeft i)) (Quotient.mk SetTheory.PGame.setoid (y.moveLeft (L i)))\nhr : ∀ (j : x.RightMoves), Eq (Quotient.mk SetTheory.PGame.setoid (x.moveRight j)) (Quotient.mk SetTheory.PGame.setoid (y.moveRight (R j)))\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid x) (Quotient.mk SetTheory.PGame.setoid y)","decl":"theorem quot_eq_of_mk'_quot_eq {x y : PGame} (L : x.LeftMoves ≃ y.LeftMoves)\n    (R : x.RightMoves ≃ y.RightMoves) (hl : ∀ i, (⟦x.moveLeft i⟧ : Game) = ⟦y.moveLeft (L i)⟧)\n    (hr : ∀ j, (⟦x.moveRight j⟧ : Game) = ⟦y.moveRight (R j)⟧) : (⟦x⟧ : Game) = ⟦y⟧ :=\n  game_eq (.of_equiv L R (fun _ => equiv_iff_game_eq.2 (hl _))\n    (fun _ => equiv_iff_game_eq.2 (hr _)))\n\n"}
{"name":"SetTheory.PGame.leftMoves_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (HMul.hMul x y).LeftMoves (Sum (Prod x.LeftMoves y.LeftMoves) (Prod x.RightMoves y.RightMoves))","decl":"theorem leftMoves_mul :\n    ∀ x y : PGame.{u},\n      (x * y).LeftMoves = (x.LeftMoves × y.LeftMoves ⊕ x.RightMoves × y.RightMoves)\n  | ⟨_, _, _, _⟩, ⟨_, _, _, _⟩ => rfl\n\n"}
{"name":"SetTheory.PGame.rightMoves_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (HMul.hMul x y).RightMoves (Sum (Prod x.LeftMoves y.RightMoves) (Prod x.RightMoves y.LeftMoves))","decl":"theorem rightMoves_mul :\n    ∀ x y : PGame.{u},\n      (x * y).RightMoves = (x.LeftMoves × y.RightMoves ⊕ x.RightMoves × y.LeftMoves)\n  | ⟨_, _, _, _⟩, ⟨_, _, _, _⟩ => rfl\n\n"}
{"name":"SetTheory.PGame.mk_mul_moveLeft_inl","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xl\nj : yl\n⊢ Eq ((HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveLeft (Sum.inl { fst := i, snd := j })) (HSub.hSub (HAdd.hAdd (HMul.hMul (xL i) (SetTheory.PGame.mk yl yr yL yR)) (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (yL j))) (HMul.hMul (xL i) (yL j)))","decl":"@[simp]\ntheorem mk_mul_moveLeft_inl {xl xr yl yr} {xL xR yL yR} {i j} :\n    (mk xl xr xL xR * mk yl yr yL yR).moveLeft (Sum.inl (i, j)) =\n      xL i * mk yl yr yL yR + mk xl xr xL xR * yL j - xL i * yL j :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.mul_moveLeft_inl","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\ni : x.LeftMoves\nj : y.LeftMoves\n⊢ Eq ((HMul.hMul x y).moveLeft (SetTheory.PGame.toLeftMovesMul (Sum.inl { fst := i, snd := j }))) (HSub.hSub (HAdd.hAdd (HMul.hMul (x.moveLeft i) y) (HMul.hMul x (y.moveLeft j))) (HMul.hMul (x.moveLeft i) (y.moveLeft j)))","decl":"@[simp]\ntheorem mul_moveLeft_inl {x y : PGame} {i j} :\n    (x * y).moveLeft (toLeftMovesMul (Sum.inl (i, j))) =\n      x.moveLeft i * y + x * y.moveLeft j - x.moveLeft i * y.moveLeft j := by\n  cases x\n  cases y\n  rfl\n\n"}
{"name":"SetTheory.PGame.mk_mul_moveLeft_inr","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xr\nj : yr\n⊢ Eq ((HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveLeft (Sum.inr { fst := i, snd := j })) (HSub.hSub (HAdd.hAdd (HMul.hMul (xR i) (SetTheory.PGame.mk yl yr yL yR)) (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (yR j))) (HMul.hMul (xR i) (yR j)))","decl":"@[simp]\ntheorem mk_mul_moveLeft_inr {xl xr yl yr} {xL xR yL yR} {i j} :\n    (mk xl xr xL xR * mk yl yr yL yR).moveLeft (Sum.inr (i, j)) =\n      xR i * mk yl yr yL yR + mk xl xr xL xR * yR j - xR i * yR j :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.mul_moveLeft_inr","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\ni : x.RightMoves\nj : y.RightMoves\n⊢ Eq ((HMul.hMul x y).moveLeft (SetTheory.PGame.toLeftMovesMul (Sum.inr { fst := i, snd := j }))) (HSub.hSub (HAdd.hAdd (HMul.hMul (x.moveRight i) y) (HMul.hMul x (y.moveRight j))) (HMul.hMul (x.moveRight i) (y.moveRight j)))","decl":"@[simp]\ntheorem mul_moveLeft_inr {x y : PGame} {i j} :\n    (x * y).moveLeft (toLeftMovesMul (Sum.inr (i, j))) =\n      x.moveRight i * y + x * y.moveRight j - x.moveRight i * y.moveRight j := by\n  cases x\n  cases y\n  rfl\n\n"}
{"name":"SetTheory.PGame.mk_mul_moveRight_inl","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xl\nj : yr\n⊢ Eq ((HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveRight (Sum.inl { fst := i, snd := j })) (HSub.hSub (HAdd.hAdd (HMul.hMul (xL i) (SetTheory.PGame.mk yl yr yL yR)) (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (yR j))) (HMul.hMul (xL i) (yR j)))","decl":"@[simp]\ntheorem mk_mul_moveRight_inl {xl xr yl yr} {xL xR yL yR} {i j} :\n    (mk xl xr xL xR * mk yl yr yL yR).moveRight (Sum.inl (i, j)) =\n      xL i * mk yl yr yL yR + mk xl xr xL xR * yR j - xL i * yR j :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.mul_moveRight_inl","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\ni : x.LeftMoves\nj : y.RightMoves\n⊢ Eq ((HMul.hMul x y).moveRight (SetTheory.PGame.toRightMovesMul (Sum.inl { fst := i, snd := j }))) (HSub.hSub (HAdd.hAdd (HMul.hMul (x.moveLeft i) y) (HMul.hMul x (y.moveRight j))) (HMul.hMul (x.moveLeft i) (y.moveRight j)))","decl":"@[simp]\ntheorem mul_moveRight_inl {x y : PGame} {i j} :\n    (x * y).moveRight (toRightMovesMul (Sum.inl (i, j))) =\n      x.moveLeft i * y + x * y.moveRight j - x.moveLeft i * y.moveRight j := by\n  cases x\n  cases y\n  rfl\n\n"}
{"name":"SetTheory.PGame.mk_mul_moveRight_inr","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xr\nj : yl\n⊢ Eq ((HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveRight (Sum.inr { fst := i, snd := j })) (HSub.hSub (HAdd.hAdd (HMul.hMul (xR i) (SetTheory.PGame.mk yl yr yL yR)) (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (yL j))) (HMul.hMul (xR i) (yL j)))","decl":"@[simp]\ntheorem mk_mul_moveRight_inr {xl xr yl yr} {xL xR yL yR} {i j} :\n    (mk xl xr xL xR * mk yl yr yL yR).moveRight (Sum.inr (i, j)) =\n      xR i * mk yl yr yL yR + mk xl xr xL xR * yL j - xR i * yL j :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.mul_moveRight_inr","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\ni : x.RightMoves\nj : y.LeftMoves\n⊢ Eq ((HMul.hMul x y).moveRight (SetTheory.PGame.toRightMovesMul (Sum.inr { fst := i, snd := j }))) (HSub.hSub (HAdd.hAdd (HMul.hMul (x.moveRight i) y) (HMul.hMul x (y.moveLeft j))) (HMul.hMul (x.moveRight i) (y.moveLeft j)))","decl":"@[simp]\ntheorem mul_moveRight_inr {x y : PGame} {i j} :\n    (x * y).moveRight (toRightMovesMul (Sum.inr (i, j))) =\n      x.moveRight i * y + x * y.moveLeft j - x.moveRight i * y.moveLeft j := by\n  cases x\n  cases y\n  rfl\n\n"}
{"name":"SetTheory.PGame.neg_mk_mul_moveLeft_inl","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xl\nj : yr\n⊢ Eq ((Neg.neg (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR))).moveLeft (Sum.inl { fst := i, snd := j })) (Neg.neg (HSub.hSub (HAdd.hAdd (HMul.hMul (xL i) (SetTheory.PGame.mk yl yr yL yR)) (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (yR j))) (HMul.hMul (xL i) (yR j))))","decl":"@[simp]\ntheorem neg_mk_mul_moveLeft_inl {xl xr yl yr} {xL xR yL yR} {i j} :\n    (-(mk xl xr xL xR * mk yl yr yL yR)).moveLeft (Sum.inl (i, j)) =\n      -(xL i * mk yl yr yL yR + mk xl xr xL xR * yR j - xL i * yR j) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.neg_mk_mul_moveLeft_inr","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xr\nj : yl\n⊢ Eq ((Neg.neg (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR))).moveLeft (Sum.inr { fst := i, snd := j })) (Neg.neg (HSub.hSub (HAdd.hAdd (HMul.hMul (xR i) (SetTheory.PGame.mk yl yr yL yR)) (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (yL j))) (HMul.hMul (xR i) (yL j))))","decl":"@[simp]\ntheorem neg_mk_mul_moveLeft_inr {xl xr yl yr} {xL xR yL yR} {i j} :\n    (-(mk xl xr xL xR * mk yl yr yL yR)).moveLeft (Sum.inr (i, j)) =\n      -(xR i * mk yl yr yL yR + mk xl xr xL xR * yL j - xR i * yL j) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.neg_mk_mul_moveRight_inl","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xl\nj : yl\n⊢ Eq ((Neg.neg (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR))).moveRight (Sum.inl { fst := i, snd := j })) (Neg.neg (HSub.hSub (HAdd.hAdd (HMul.hMul (xL i) (SetTheory.PGame.mk yl yr yL yR)) (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (yL j))) (HMul.hMul (xL i) (yL j))))","decl":"@[simp]\ntheorem neg_mk_mul_moveRight_inl {xl xr yl yr} {xL xR yL yR} {i j} :\n    (-(mk xl xr xL xR * mk yl yr yL yR)).moveRight (Sum.inl (i, j)) =\n      -(xL i * mk yl yr yL yR + mk xl xr xL xR * yL j - xL i * yL j) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.neg_mk_mul_moveRight_inr","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xr\nj : yr\n⊢ Eq ((Neg.neg (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR))).moveRight (Sum.inr { fst := i, snd := j })) (Neg.neg (HSub.hSub (HAdd.hAdd (HMul.hMul (xR i) (SetTheory.PGame.mk yl yr yL yR)) (HMul.hMul (SetTheory.PGame.mk xl xr xL xR) (yR j))) (HMul.hMul (xR i) (yR j))))","decl":"@[simp]\ntheorem neg_mk_mul_moveRight_inr {xl xr yl yr} {xL xR yL yR} {i j} :\n    (-(mk xl xr xL xR * mk yl yr yL yR)).moveRight (Sum.inr (i, j)) =\n      -(xR i * mk yl yr yL yR + mk xl xr xL xR * yR j - xR i * yR j) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.leftMoves_mul_cases","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\nk : (HMul.hMul x y).LeftMoves\nP : (HMul.hMul x y).LeftMoves → Prop\nhl : ∀ (ix : x.LeftMoves) (iy : y.LeftMoves), P (SetTheory.PGame.toLeftMovesMul (Sum.inl { fst := ix, snd := iy }))\nhr : ∀ (jx : x.RightMoves) (jy : y.RightMoves), P (SetTheory.PGame.toLeftMovesMul (Sum.inr { fst := jx, snd := jy }))\n⊢ P k","decl":"theorem leftMoves_mul_cases {x y : PGame} (k) {P : (x * y).LeftMoves → Prop}\n    (hl : ∀ ix iy, P <| toLeftMovesMul (Sum.inl ⟨ix, iy⟩))\n    (hr : ∀ jx jy, P <| toLeftMovesMul (Sum.inr ⟨jx, jy⟩)) : P k := by\n  rw [← toLeftMovesMul.apply_symm_apply k]\n  rcases toLeftMovesMul.symm k with (⟨ix, iy⟩ | ⟨jx, jy⟩)\n  · apply hl\n  · apply hr\n\n"}
{"name":"SetTheory.PGame.rightMoves_mul_cases","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\nk : (HMul.hMul x y).RightMoves\nP : (HMul.hMul x y).RightMoves → Prop\nhl : ∀ (ix : x.LeftMoves) (jy : y.RightMoves), P (SetTheory.PGame.toRightMovesMul (Sum.inl { fst := ix, snd := jy }))\nhr : ∀ (jx : x.RightMoves) (iy : y.LeftMoves), P (SetTheory.PGame.toRightMovesMul (Sum.inr { fst := jx, snd := iy }))\n⊢ P k","decl":"theorem rightMoves_mul_cases {x y : PGame} (k) {P : (x * y).RightMoves → Prop}\n    (hl : ∀ ix jy, P <| toRightMovesMul (Sum.inl ⟨ix, jy⟩))\n    (hr : ∀ jx iy, P <| toRightMovesMul (Sum.inr ⟨jx, iy⟩)) : P k := by\n  rw [← toRightMovesMul.apply_symm_apply k]\n  rcases toRightMovesMul.symm k with (⟨ix, iy⟩ | ⟨jx, jy⟩)\n  · apply hl\n  · apply hr\n\n"}
{"name":"SetTheory.PGame.mul_comm","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ (HMul.hMul x y).Identical (HMul.hMul y x)","decl":"/-- `x * y` and `y * x` have the same moves. -/\nprotected lemma mul_comm (x y : PGame) : x * y ≡ y * x :=\n  match x, y with\n  | ⟨xl, xr, xL, xR⟩, ⟨yl, yr, yL, yR⟩ => by\n    refine Identical.of_equiv ((Equiv.prodComm _ _).sumCongr (Equiv.prodComm _ _))\n      ((Equiv.sumComm _ _).trans ((Equiv.prodComm _ _).sumCongr (Equiv.prodComm _ _))) ?_ ?_ <;>\n    · rintro (⟨_, _⟩ | ⟨_, _⟩) <;>\n      exact ((((PGame.mul_comm _ (mk _ _ _ _)).add (PGame.mul_comm (mk _ _ _ _) _)).trans\n        (PGame.add_comm _ _)).sub (PGame.mul_comm _ _))\n  termination_by (x, y)\n\n"}
{"name":"SetTheory.PGame.quot_mul_comm","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x y)) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul y x))","decl":"theorem quot_mul_comm (x y : PGame.{u}) : (⟦x * y⟧ : Game) = ⟦y * x⟧ :=\n  game_eq (mulCommRelabelling x y).equiv\n\n"}
{"name":"SetTheory.PGame.mul_comm_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ HasEquiv.Equiv (HMul.hMul x y) (HMul.hMul y x)","decl":"/-- `x * y` is equivalent to `y * x`. -/\ntheorem mul_comm_equiv (x y : PGame) : x * y ≈ y * x :=\n  Quotient.exact <| quot_mul_comm _ _\n\n"}
{"name":"SetTheory.PGame.isEmpty_leftMoves_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\ninst✝ : IsEmpty (Sum (Prod x.LeftMoves y.LeftMoves) (Prod x.RightMoves y.RightMoves))\n⊢ IsEmpty (HMul.hMul x y).LeftMoves","decl":"instance isEmpty_leftMoves_mul (x y : PGame.{u})\n    [IsEmpty (x.LeftMoves × y.LeftMoves ⊕ x.RightMoves × y.RightMoves)] :\n    IsEmpty (x * y).LeftMoves := by\n  cases x\n  cases y\n  assumption\n\n"}
{"name":"SetTheory.PGame.isEmpty_rightMoves_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\ninst✝ : IsEmpty (Sum (Prod x.LeftMoves y.RightMoves) (Prod x.RightMoves y.LeftMoves))\n⊢ IsEmpty (HMul.hMul x y).RightMoves","decl":"instance isEmpty_rightMoves_mul (x y : PGame.{u})\n    [IsEmpty (x.LeftMoves × y.RightMoves ⊕ x.RightMoves × y.LeftMoves)] :\n    IsEmpty (x * y).RightMoves := by\n  cases x\n  cases y\n  assumption\n\n"}
{"name":"SetTheory.PGame.mul_zero","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ (HMul.hMul x 0).Identical 0","decl":"/-- `x * 0` has exactly the same moves as `0`. -/\nprotected lemma mul_zero (x : PGame) : x * 0 ≡ 0 := identical_zero _\n\n"}
{"name":"SetTheory.PGame.mul_zero_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv (HMul.hMul x 0) 0","decl":"/-- `x * 0` is equivalent to `0`. -/\ntheorem mul_zero_equiv (x : PGame) : x * 0 ≈ 0 :=\n  (mulZeroRelabelling x).equiv\n\n"}
{"name":"SetTheory.PGame.quot_mul_zero","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x 0)) 0","decl":"@[simp]\ntheorem quot_mul_zero (x : PGame) : (⟦x * 0⟧ : Game) = 0 :=\n  game_eq x.mul_zero_equiv\n\n"}
{"name":"SetTheory.PGame.zero_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ (HMul.hMul 0 x).Identical 0","decl":"/-- `0 * x` has exactly the same moves as `0`. -/\nprotected lemma zero_mul (x : PGame) : 0 * x ≡ 0 := identical_zero _\n\n"}
{"name":"SetTheory.PGame.zero_mul_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv (HMul.hMul 0 x) 0","decl":"/-- `0 * x` is equivalent to `0`. -/\ntheorem zero_mul_equiv (x : PGame) : 0 * x ≈ 0 :=\n  (zeroMulRelabelling x).equiv\n\n"}
{"name":"SetTheory.PGame.quot_zero_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul 0 x)) 0","decl":"@[simp]\ntheorem quot_zero_mul (x : PGame) : (⟦0 * x⟧ : Game) = 0 :=\n  game_eq x.zero_mul_equiv\n\n"}
{"name":"SetTheory.PGame.mul_neg","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (HMul.hMul x (Neg.neg y)) (Neg.neg (HMul.hMul x y))","decl":"/-- `x * -y` and `-(x * y)` have the same moves. -/\n@[simp]\nlemma mul_neg (x y : PGame) : x * -y = -(x * y) :=\n  match x, y with\n  | mk xl xr xL xR, mk yl yr yL yR => by\n    refine ext rfl rfl ?_ ?_ <;> rintro (⟨i, j⟩ | ⟨i, j⟩) _ ⟨rfl⟩\n    all_goals\n      dsimp\n      rw [PGame.neg_sub', PGame.neg_add]\n      congr\n      exacts [mul_neg _ (mk ..), mul_neg .., mul_neg ..]\ntermination_by (x, y)\n\n"}
{"name":"SetTheory.PGame.neg_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ (HMul.hMul (Neg.neg x) y).Identical (Neg.neg (HMul.hMul x y))","decl":"/-- `-x * y` and `-(x * y)` have the same moves. -/\nlemma neg_mul (x y : PGame) : -x * y ≡ -(x * y) :=\n  ((PGame.mul_comm _ _).trans (of_eq (mul_neg _ _))).trans (PGame.mul_comm _ _).neg\n\n"}
{"name":"SetTheory.PGame.quot_neg_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul (Neg.neg x) y)) (Neg.neg (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x y)))","decl":"@[simp]\ntheorem quot_neg_mul (x y : PGame) : (⟦-x * y⟧ : Game) = -⟦x * y⟧ :=\n  game_eq (negMulRelabelling x y).equiv\n\n"}
{"name":"SetTheory.PGame.quot_mul_neg","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x (Neg.neg y))) (Neg.neg (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x y)))","decl":"theorem quot_mul_neg (x y : PGame) : ⟦x * -y⟧ = (-⟦x * y⟧ : Game) :=\n  game_eq (mulNegRelabelling x y).equiv\n\n"}
{"name":"SetTheory.PGame.quot_neg_mul_neg","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul (Neg.neg x) (Neg.neg y))) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x y))","decl":"theorem quot_neg_mul_neg (x y : PGame) : ⟦-x * -y⟧ = (⟦x * y⟧ : Game) := by simp\n\n"}
{"name":"SetTheory.PGame.quot_left_distrib","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y z : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x (HAdd.hAdd y z))) (HAdd.hAdd (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x y)) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x z)))","decl":"@[simp]\ntheorem quot_left_distrib (x y z : PGame) : (⟦x * (y + z)⟧ : Game) = ⟦x * y⟧ + ⟦x * z⟧ :=\n  match x, y, z with\n  | mk xl xr xL xR, mk yl yr yL yR, mk zl zr zL zR => by\n    let x := mk xl xr xL xR\n    let y := mk yl yr yL yR\n    let z := mk zl zr zL zR\n    refine quot_eq_of_mk'_quot_eq ?_ ?_ ?_ ?_\n    · fconstructor\n      · rintro (⟨_, _ | _⟩ | ⟨_, _ | _⟩) <;>\n          -- Porting note: we've increased `maxDepth` here from `5` to `6`.\n          -- Likely this sort of off-by-one error is just a change in the implementation\n          -- of `solve_by_elim`.\n          solve_by_elim (config := { maxDepth := 6 }) [Sum.inl, Sum.inr, Prod.mk]\n      · rintro (⟨⟨_, _⟩ | ⟨_, _⟩⟩ | ⟨_, _⟩ | ⟨_, _⟩) <;>\n          solve_by_elim (config := { maxDepth := 6 }) [Sum.inl, Sum.inr, Prod.mk]\n      · rintro (⟨_, _ | _⟩ | ⟨_, _ | _⟩) <;> rfl\n      · rintro (⟨⟨_, _⟩ | ⟨_, _⟩⟩ | ⟨_, _⟩ | ⟨_, _⟩) <;> rfl\n    · fconstructor\n      · rintro (⟨_, _ | _⟩ | ⟨_, _ | _⟩) <;>\n          solve_by_elim (config := { maxDepth := 6 }) [Sum.inl, Sum.inr, Prod.mk]\n      · rintro (⟨⟨_, _⟩ | ⟨_, _⟩⟩ | ⟨_, _⟩ | ⟨_, _⟩) <;>\n          solve_by_elim (config := { maxDepth := 6 }) [Sum.inl, Sum.inr, Prod.mk]\n      · rintro (⟨_, _ | _⟩ | ⟨_, _ | _⟩) <;> rfl\n      · rintro (⟨⟨_, _⟩ | ⟨_, _⟩⟩ | ⟨_, _⟩ | ⟨_, _⟩) <;> rfl\n    -- Porting note: explicitly wrote out arguments to each recursive\n    -- quot_left_distrib reference below, because otherwise the decreasing_by block\n    -- failed. Previously, each branch ended with: `simp [quot_left_distrib]; abel`\n    -- See https://github.com/leanprover/lean4/issues/2288\n    · rintro (⟨i, j | k⟩ | ⟨i, j | k⟩)\n      · change\n          ⟦xL i * (y + z) + x * (yL j + z) - xL i * (yL j + z)⟧ =\n            ⟦xL i * y + x * yL j - xL i * yL j + x * z⟧\n        simp only [quot_sub, quot_add]\n        rw [quot_left_distrib (xL i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_left_distrib (mk xl xr xL xR) (yL j) (mk zl zr zL zR)]\n        rw [quot_left_distrib (xL i) (yL j) (mk zl zr zL zR)]\n        abel\n      · change\n          ⟦xL i * (y + z) + x * (y + zL k) - xL i * (y + zL k)⟧ =\n            ⟦x * y + (xL i * z + x * zL k - xL i * zL k)⟧\n        simp only [quot_sub, quot_add]\n        rw [quot_left_distrib (xL i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_left_distrib (mk xl xr xL xR) (mk yl yr yL yR) (zL k)]\n        rw [quot_left_distrib (xL i) (mk yl yr yL yR) (zL k)]\n        abel\n      · change\n          ⟦xR i * (y + z) + x * (yR j + z) - xR i * (yR j + z)⟧ =\n            ⟦xR i * y + x * yR j - xR i * yR j + x * z⟧\n        simp only [quot_sub, quot_add]\n        rw [quot_left_distrib (xR i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_left_distrib (mk xl xr xL xR) (yR j) (mk zl zr zL zR)]\n        rw [quot_left_distrib (xR i) (yR j) (mk zl zr zL zR)]\n        abel\n      · change\n          ⟦xR i * (y + z) + x * (y + zR k) - xR i * (y + zR k)⟧ =\n            ⟦x * y + (xR i * z + x * zR k - xR i * zR k)⟧\n        simp only [quot_sub, quot_add]\n        rw [quot_left_distrib (xR i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_left_distrib (mk xl xr xL xR) (mk yl yr yL yR) (zR k)]\n        rw [quot_left_distrib (xR i) (mk yl yr yL yR) (zR k)]\n        abel\n    · rintro (⟨i, j | k⟩ | ⟨i, j | k⟩)\n      · change\n          ⟦xL i * (y + z) + x * (yR j + z) - xL i * (yR j + z)⟧ =\n            ⟦xL i * y + x * yR j - xL i * yR j + x * z⟧\n        simp only [quot_sub, quot_add]\n        rw [quot_left_distrib (xL i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_left_distrib (mk xl xr xL xR) (yR j) (mk zl zr zL zR)]\n        rw [quot_left_distrib (xL i) (yR j) (mk zl zr zL zR)]\n        abel\n      · change\n          ⟦xL i * (y + z) + x * (y + zR k) - xL i * (y + zR k)⟧ =\n            ⟦x * y + (xL i * z + x * zR k - xL i * zR k)⟧\n        simp only [quot_sub, quot_add]\n        rw [quot_left_distrib (xL i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_left_distrib (mk xl xr xL xR) (mk yl yr yL yR) (zR k)]\n        rw [quot_left_distrib (xL i) (mk yl yr yL yR) (zR k)]\n        abel\n      · change\n          ⟦xR i * (y + z) + x * (yL j + z) - xR i * (yL j + z)⟧ =\n            ⟦xR i * y + x * yL j - xR i * yL j + x * z⟧\n        simp only [quot_sub, quot_add]\n        rw [quot_left_distrib (xR i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_left_distrib (mk xl xr xL xR) (yL j) (mk zl zr zL zR)]\n        rw [quot_left_distrib (xR i) (yL j) (mk zl zr zL zR)]\n        abel\n      · change\n          ⟦xR i * (y + z) + x * (y + zL k) - xR i * (y + zL k)⟧ =\n            ⟦x * y + (xR i * z + x * zL k - xR i * zL k)⟧\n        simp only [quot_sub, quot_add]\n        rw [quot_left_distrib (xR i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_left_distrib (mk xl xr xL xR) (mk yl yr yL yR) (zL k)]\n        rw [quot_left_distrib (xR i) (mk yl yr yL yR) (zL k)]\n        abel\n  termination_by (x, y, z)\n\n"}
{"name":"SetTheory.PGame.left_distrib_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y z : SetTheory.PGame\n⊢ HasEquiv.Equiv (HMul.hMul x (HAdd.hAdd y z)) (HAdd.hAdd (HMul.hMul x y) (HMul.hMul x z))","decl":"/-- `x * (y + z)` is equivalent to `x * y + x * z.`-/\ntheorem left_distrib_equiv (x y z : PGame) : x * (y + z) ≈ x * y + x * z :=\n  Quotient.exact <| quot_left_distrib _ _ _\n\n"}
{"name":"SetTheory.PGame.quot_left_distrib_sub","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y z : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x (HSub.hSub y z))) (HSub.hSub (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x y)) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x z)))","decl":"@[simp]\ntheorem quot_left_distrib_sub (x y z : PGame) : (⟦x * (y - z)⟧ : Game) = ⟦x * y⟧ - ⟦x * z⟧ := by\n  change (⟦x * (y + -z)⟧ : Game) = ⟦x * y⟧ + -⟦x * z⟧\n  rw [quot_left_distrib, quot_mul_neg]\n\n"}
{"name":"SetTheory.PGame.quot_right_distrib","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y z : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul (HAdd.hAdd x y) z)) (HAdd.hAdd (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x z)) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul y z)))","decl":"@[simp]\ntheorem quot_right_distrib (x y z : PGame) : (⟦(x + y) * z⟧ : Game) = ⟦x * z⟧ + ⟦y * z⟧ := by\n  simp only [quot_mul_comm, quot_left_distrib]\n\n"}
{"name":"SetTheory.PGame.right_distrib_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y z : SetTheory.PGame\n⊢ HasEquiv.Equiv (HMul.hMul (HAdd.hAdd x y) z) (HAdd.hAdd (HMul.hMul x z) (HMul.hMul y z))","decl":"/-- `(x + y) * z` is equivalent to `x * z + y * z.`-/\ntheorem right_distrib_equiv (x y z : PGame) : (x + y) * z ≈ x * z + y * z :=\n  Quotient.exact <| quot_right_distrib _ _ _\n\n"}
{"name":"SetTheory.PGame.quot_right_distrib_sub","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y z : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul (HSub.hSub y z) x)) (HSub.hSub (Quotient.mk SetTheory.PGame.setoid (HMul.hMul y x)) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul z x)))","decl":"@[simp]\ntheorem quot_right_distrib_sub (x y z : PGame) : (⟦(y - z) * x⟧ : Game) = ⟦y * x⟧ - ⟦z * x⟧ := by\n  change (⟦(y + -z) * x⟧ : Game) = ⟦y * x⟧ + -⟦z * x⟧\n  rw [quot_right_distrib, quot_neg_mul]\n\n"}
{"name":"SetTheory.PGame.one_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ (HMul.hMul 1 x).Identical x","decl":"/-- `1 * x` has the same moves as `x`. -/\nprotected lemma one_mul : ∀ (x : PGame), 1 * x ≡ x\n  | ⟨xl, xr, xL, xR⟩ => by\n    refine Identical.of_equiv ((Equiv.sumEmpty _ _).trans (Equiv.punitProd _))\n      ((Equiv.sumEmpty _ _).trans (Equiv.punitProd _)) ?_ ?_ <;>\n    · rintro (⟨⟨⟩, _⟩ | ⟨⟨⟩, _⟩)\n      exact ((((PGame.zero_mul (mk _ _ _ _)).add (PGame.one_mul _)).trans (PGame.zero_add _)).sub\n        (PGame.zero_mul _)).trans (PGame.sub_zero _)\n\n"}
{"name":"SetTheory.PGame.mul_one","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ (HMul.hMul x 1).Identical x","decl":"/-- `x * 1` has the same moves as `x`. -/\nprotected lemma mul_one (x : PGame) : x * 1 ≡ x := (x.mul_comm _).trans x.one_mul\n\n"}
{"name":"SetTheory.PGame.quot_mul_one","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x 1)) (Quotient.mk SetTheory.PGame.setoid x)","decl":"@[simp]\ntheorem quot_mul_one (x : PGame) : (⟦x * 1⟧ : Game) = ⟦x⟧ :=\n  game_eq <| PGame.Relabelling.equiv <| mulOneRelabelling x\n\n"}
{"name":"SetTheory.PGame.mul_one_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv (HMul.hMul x 1) x","decl":"/-- `x * 1` is equivalent to `x`. -/\ntheorem mul_one_equiv (x : PGame) : x * 1 ≈ x :=\n  Quotient.exact <| quot_mul_one x\n\n"}
{"name":"SetTheory.PGame.quot_one_mul","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul 1 x)) (Quotient.mk SetTheory.PGame.setoid x)","decl":"@[simp]\ntheorem quot_one_mul (x : PGame) : (⟦1 * x⟧ : Game) = ⟦x⟧ :=\n  game_eq <| PGame.Relabelling.equiv <| oneMulRelabelling x\n\n"}
{"name":"SetTheory.PGame.one_mul_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv (HMul.hMul 1 x) x","decl":"/-- `1 * x` is equivalent to `x`. -/\ntheorem one_mul_equiv (x : PGame) : 1 * x ≈ x :=\n  Quotient.exact <| quot_one_mul x\n\n"}
{"name":"SetTheory.PGame.quot_mul_assoc","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y z : SetTheory.PGame\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (HMul.hMul (HMul.hMul x y) z)) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x (HMul.hMul y z)))","decl":"theorem quot_mul_assoc (x y z : PGame) : (⟦x * y * z⟧ : Game) = ⟦x * (y * z)⟧ :=\n  match x, y, z with\n  | mk xl xr xL xR, mk yl yr yL yR, mk zl zr zL zR => by\n    let x := mk xl xr xL xR\n    let y := mk yl yr yL yR\n    let z := mk zl zr zL zR\n    refine quot_eq_of_mk'_quot_eq ?_ ?_ ?_ ?_\n    · fconstructor\n      · rintro (⟨⟨_, _⟩ | ⟨_, _⟩, _⟩ | ⟨⟨_, _⟩ | ⟨_, _⟩, _⟩) <;>\n          -- Porting note: as above, increased the `maxDepth` here by 1.\n          solve_by_elim (config := { maxDepth := 8 }) [Sum.inl, Sum.inr, Prod.mk]\n      · rintro (⟨_, ⟨_, _⟩ | ⟨_, _⟩⟩ | ⟨_, ⟨_, _⟩ | ⟨_, _⟩⟩) <;>\n          solve_by_elim (config := { maxDepth := 8 }) [Sum.inl, Sum.inr, Prod.mk]\n      · rintro (⟨⟨_, _⟩ | ⟨_, _⟩, _⟩ | ⟨⟨_, _⟩ | ⟨_, _⟩, _⟩) <;> rfl\n      · rintro (⟨_, ⟨_, _⟩ | ⟨_, _⟩⟩ | ⟨_, ⟨_, _⟩ | ⟨_, _⟩⟩) <;> rfl\n    · fconstructor\n      · rintro (⟨⟨_, _⟩ | ⟨_, _⟩, _⟩ | ⟨⟨_, _⟩ | ⟨_, _⟩, _⟩) <;>\n          solve_by_elim (config := { maxDepth := 8 }) [Sum.inl, Sum.inr, Prod.mk]\n      · rintro (⟨_, ⟨_, _⟩ | ⟨_, _⟩⟩ | ⟨_, ⟨_, _⟩ | ⟨_, _⟩⟩) <;>\n          solve_by_elim (config := { maxDepth := 8 }) [Sum.inl, Sum.inr, Prod.mk]\n      · rintro (⟨⟨_, _⟩ | ⟨_, _⟩, _⟩ | ⟨⟨_, _⟩ | ⟨_, _⟩, _⟩) <;> rfl\n      · rintro (⟨_, ⟨_, _⟩ | ⟨_, _⟩⟩ | ⟨_, ⟨_, _⟩ | ⟨_, _⟩⟩) <;> rfl\n    -- Porting note: explicitly wrote out arguments to each recursive\n    -- quot_mul_assoc reference below, because otherwise the decreasing_by block\n    -- failed. Each branch previously ended with: `simp [quot_mul_assoc]; abel`\n    -- See https://github.com/leanprover/lean4/issues/2288\n    · rintro (⟨⟨i, j⟩ | ⟨i, j⟩, k⟩ | ⟨⟨i, j⟩ | ⟨i, j⟩, k⟩)\n      · change\n          ⟦(xL i * y + x * yL j - xL i * yL j) * z + x * y * zL k -\n                (xL i * y + x * yL j - xL i * yL j) * zL k⟧ =\n            ⟦xL i * (y * z) + x * (yL j * z + y * zL k - yL j * zL k) -\n                xL i * (yL j * z + y * zL k - yL j * zL k)⟧\n        simp only [quot_sub, quot_add, quot_right_distrib_sub, quot_right_distrib,\n                   quot_left_distrib_sub, quot_left_distrib]\n        rw [quot_mul_assoc (xL i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yL j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (xL i) (yL j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (mk yl yr yL yR) (zL k)]\n        rw [quot_mul_assoc (xL i) (mk yl yr yL yR) (zL k)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yL j) (zL k)]\n        rw [quot_mul_assoc (xL i) (yL j) (zL k)]\n        abel\n      · change\n          ⟦(xR i * y + x * yR j - xR i * yR j) * z + x * y * zL k -\n                (xR i * y + x * yR j - xR i * yR j) * zL k⟧ =\n            ⟦xR i * (y * z) + x * (yR j * z + y * zL k - yR j * zL k) -\n                xR i * (yR j * z + y * zL k - yR j * zL k)⟧\n        simp only [quot_sub, quot_add, quot_right_distrib_sub, quot_right_distrib,\n                   quot_left_distrib_sub, quot_left_distrib]\n        rw [quot_mul_assoc (xR i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yR j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (xR i) (yR j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (mk yl yr yL yR) (zL k)]\n        rw [quot_mul_assoc (xR i) (mk yl yr yL yR) (zL k)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yR j) (zL k)]\n        rw [quot_mul_assoc (xR i) (yR j) (zL k)]\n        abel\n      · change\n          ⟦(xL i * y + x * yR j - xL i * yR j) * z + x * y * zR k -\n                (xL i * y + x * yR j - xL i * yR j) * zR k⟧ =\n            ⟦xL i * (y * z) + x * (yR j * z + y * zR k - yR j * zR k) -\n                xL i * (yR j * z + y * zR k - yR j * zR k)⟧\n        simp only [quot_sub, quot_add, quot_right_distrib_sub, quot_right_distrib,\n                   quot_left_distrib_sub, quot_left_distrib]\n        rw [quot_mul_assoc (xL i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yR j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (xL i) (yR j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (mk yl yr yL yR) (zR k)]\n        rw [quot_mul_assoc (xL i) (mk yl yr yL yR) (zR k)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yR j) (zR k)]\n        rw [quot_mul_assoc (xL i) (yR j) (zR k)]\n        abel\n      · change\n          ⟦(xR i * y + x * yL j - xR i * yL j) * z + x * y * zR k -\n                (xR i * y + x * yL j - xR i * yL j) * zR k⟧ =\n            ⟦xR i * (y * z) + x * (yL j * z + y * zR k - yL j * zR k) -\n                xR i * (yL j * z + y * zR k - yL j * zR k)⟧\n        simp only [quot_sub, quot_add, quot_right_distrib_sub, quot_right_distrib,\n                   quot_left_distrib_sub, quot_left_distrib]\n        rw [quot_mul_assoc (xR i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yL j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (xR i) (yL j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (mk yl yr yL yR) (zR k)]\n        rw [quot_mul_assoc (xR i) (mk yl yr yL yR) (zR k)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yL j) (zR k)]\n        rw [quot_mul_assoc (xR i) (yL j) (zR k)]\n        abel\n    · rintro (⟨⟨i, j⟩ | ⟨i, j⟩, k⟩ | ⟨⟨i, j⟩ | ⟨i, j⟩, k⟩)\n      · change\n          ⟦(xL i * y + x * yL j - xL i * yL j) * z + x * y * zR k -\n                (xL i * y + x * yL j - xL i * yL j) * zR k⟧ =\n            ⟦xL i * (y * z) + x * (yL j * z + y * zR k - yL j * zR k) -\n                xL i * (yL j * z + y * zR k - yL j * zR k)⟧\n        simp only [quot_sub, quot_add, quot_right_distrib_sub, quot_right_distrib,\n                   quot_left_distrib_sub, quot_left_distrib]\n        rw [quot_mul_assoc (xL i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yL j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (xL i) (yL j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (mk yl yr yL yR) (zR k)]\n        rw [quot_mul_assoc (xL i) (mk yl yr yL yR) (zR k)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yL j) (zR k)]\n        rw [quot_mul_assoc (xL i) (yL j) (zR k)]\n        abel\n      · change\n          ⟦(xR i * y + x * yR j - xR i * yR j) * z + x * y * zR k -\n                (xR i * y + x * yR j - xR i * yR j) * zR k⟧ =\n            ⟦xR i * (y * z) + x * (yR j * z + y * zR k - yR j * zR k) -\n                xR i * (yR j * z + y * zR k - yR j * zR k)⟧\n        simp only [quot_sub, quot_add, quot_right_distrib_sub, quot_right_distrib,\n                   quot_left_distrib_sub, quot_left_distrib]\n        rw [quot_mul_assoc (xR i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yR j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (xR i) (yR j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (mk yl yr yL yR) (zR k)]\n        rw [quot_mul_assoc (xR i) (mk yl yr yL yR) (zR k)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yR j) (zR k)]\n        rw [quot_mul_assoc (xR i) (yR j) (zR k)]\n        abel\n      · change\n          ⟦(xL i * y + x * yR j - xL i * yR j) * z + x * y * zL k -\n                (xL i * y + x * yR j - xL i * yR j) * zL k⟧ =\n            ⟦xL i * (y * z) + x * (yR j * z + y * zL k - yR j * zL k) -\n                xL i * (yR j * z + y * zL k - yR j * zL k)⟧\n        simp only [quot_sub, quot_add, quot_right_distrib_sub, quot_right_distrib,\n                   quot_left_distrib_sub, quot_left_distrib]\n        rw [quot_mul_assoc (xL i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yR j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (xL i) (yR j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (mk yl yr yL yR) (zL k)]\n        rw [quot_mul_assoc (xL i) (mk yl yr yL yR) (zL k)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yR j) (zL k)]\n        rw [quot_mul_assoc (xL i) (yR j) (zL k)]\n        abel\n      · change\n          ⟦(xR i * y + x * yL j - xR i * yL j) * z + x * y * zL k -\n                (xR i * y + x * yL j - xR i * yL j) * zL k⟧ =\n            ⟦xR i * (y * z) + x * (yL j * z + y * zL k - yL j * zL k) -\n                xR i * (yL j * z + y * zL k - yL j * zL k)⟧\n        simp only [quot_sub, quot_add, quot_right_distrib_sub, quot_right_distrib,\n                   quot_left_distrib_sub, quot_left_distrib]\n        rw [quot_mul_assoc (xR i) (mk yl yr yL yR) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yL j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (xR i) (yL j) (mk zl zr zL zR)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (mk yl yr yL yR) (zL k)]\n        rw [quot_mul_assoc (xR i) (mk yl yr yL yR) (zL k)]\n        rw [quot_mul_assoc (mk xl xr xL xR) (yL j) (zL k)]\n        rw [quot_mul_assoc (xR i) (yL j) (zL k)]\n        abel\n  termination_by (x, y, z)\n\n"}
{"name":"SetTheory.PGame.mul_assoc_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y z : SetTheory.PGame\n⊢ HasEquiv.Equiv (HMul.hMul (HMul.hMul x y) z) (HMul.hMul x (HMul.hMul y z))","decl":"/-- `x * y * z` is equivalent to `x * (y * z).`-/\ntheorem mul_assoc_equiv (x y z : PGame) : x * y * z ≈ x * (y * z) :=\n  Quotient.exact <| quot_mul_assoc _ _ _\n\n"}
{"name":"SetTheory.PGame.mulOption_neg_neg","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\ni : x.LeftMoves\nj : y.LeftMoves\n⊢ Eq (x.mulOption y i j) (x.mulOption (Neg.neg (Neg.neg y)) i (SetTheory.PGame.toLeftMovesNeg (SetTheory.PGame.toRightMovesNeg j)))","decl":"/-- Any left option of `x * y` of the first kind is also a left option of `x * -(-y)` of\n  the first kind. -/\nlemma mulOption_neg_neg {x} (y) {i j} :\n    mulOption x y i j = mulOption x (-(-y)) i (toLeftMovesNeg <| toRightMovesNeg j) := by\n  simp [mulOption]\n\n"}
{"name":"SetTheory.PGame.mulOption_symm","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\ni : x.LeftMoves\nj : y.LeftMoves\n⊢ Eq (Quotient.mk SetTheory.PGame.setoid (x.mulOption y i j)) (Quotient.mk SetTheory.PGame.setoid (y.mulOption x j i))","decl":"/-- The left options of `x * y` agree with that of `y * x` up to equivalence. -/\nlemma mulOption_symm (x y) {i j} : ⟦mulOption x y i j⟧ = (⟦mulOption y x j i⟧ : Game) := by\n  dsimp only [mulOption, quot_sub, quot_add]\n  rw [add_comm]\n  congr 1\n  on_goal 1 => congr 1\n  all_goals rw [quot_mul_comm]\n\n"}
{"name":"SetTheory.PGame.leftMoves_mul_iff","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\nP : SetTheory.Game → Prop\n⊢ Iff (∀ (k : (HMul.hMul x y).LeftMoves), P (Quotient.mk SetTheory.PGame.setoid ((HMul.hMul x y).moveLeft k))) (And (∀ (i : x.LeftMoves) (j : y.LeftMoves), P (Quotient.mk SetTheory.PGame.setoid (x.mulOption y i j))) (∀ (i : (Neg.neg x).LeftMoves) (j : (Neg.neg y).LeftMoves), P (Quotient.mk SetTheory.PGame.setoid ((Neg.neg x).mulOption (Neg.neg y) i j))))","decl":"/-- The left options of `x * y` of the second kind are the left options of `(-x) * (-y)` of the\n  first kind, up to equivalence. -/\nlemma leftMoves_mul_iff {x y : PGame} (P : Game → Prop) :\n    (∀ k, P ⟦(x * y).moveLeft k⟧) ↔\n    (∀ i j, P ⟦mulOption x y i j⟧) ∧ (∀ i j, P ⟦mulOption (-x) (-y) i j⟧) := by\n  cases x; cases y\n  constructor <;> intro h\n  on_goal 1 =>\n    constructor <;> intros i j\n    · exact h (Sum.inl (i, j))\n    convert h (Sum.inr (i, j)) using 1\n  on_goal 2 =>\n    rintro (⟨i, j⟩ | ⟨i, j⟩)\n    · exact h.1 i j\n    convert h.2 i j using 1\n  all_goals\n    dsimp only [mk_mul_moveLeft_inr, quot_sub, quot_add, neg_def, mulOption, moveLeft_mk]\n    rw [← neg_def, ← neg_def]\n    congr 1\n    on_goal 1 => congr 1\n    all_goals rw [quot_neg_mul_neg]\n\n"}
{"name":"SetTheory.PGame.rightMoves_mul_iff","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x y : SetTheory.PGame\nP : SetTheory.Game → Prop\n⊢ Iff (∀ (k : (HMul.hMul x y).RightMoves), P (Quotient.mk SetTheory.PGame.setoid ((HMul.hMul x y).moveRight k))) (And (∀ (i : x.LeftMoves) (j : (Neg.neg y).LeftMoves), P (Neg.neg (Quotient.mk SetTheory.PGame.setoid (x.mulOption (Neg.neg y) i j)))) (∀ (i : (Neg.neg x).LeftMoves) (j : y.LeftMoves), P (Neg.neg (Quotient.mk SetTheory.PGame.setoid ((Neg.neg x).mulOption y i j)))))","decl":"/-- The right options of `x * y` are the left options of `x * (-y)` and of `(-x) * y` of the first\n  kind, up to equivalence. -/\nlemma rightMoves_mul_iff {x y : PGame} (P : Game → Prop) :\n    (∀ k, P ⟦(x * y).moveRight k⟧) ↔\n    (∀ i j, P (-⟦mulOption x (-y) i j⟧)) ∧ (∀ i j, P (-⟦mulOption (-x) y i j⟧)) := by\n  cases x; cases y\n  constructor <;> intro h\n  on_goal 1 =>\n    constructor <;> intros i j\n    on_goal 1 => convert h (Sum.inl (i, j))\n  on_goal 2 => convert h (Sum.inr (i, j))\n  on_goal 3 =>\n    rintro (⟨i, j⟩ | ⟨i, j⟩)\n    on_goal 1 => convert h.1 i j using 1\n    on_goal 2 => convert h.2 i j using 1\n  all_goals\n    dsimp [mulOption]\n    rw [neg_sub', neg_add, ← neg_def]\n    congr 1\n    on_goal 1 => congr 1\n  any_goals rw [quot_neg_mul, neg_neg]\n  iterate 6 rw [quot_mul_neg, neg_neg]\n\n"}
{"name":"SetTheory.PGame.InvTy.zero.sizeOf_spec","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\ninst✝¹ : SizeOf l\ninst✝ : SizeOf r\n⊢ Eq (SizeOf.sizeOf SetTheory.PGame.InvTy.zero) 1","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.right₁.injEq","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\na✝³ : l\na✝² : SetTheory.PGame.InvTy l r Bool.false\na✝¹ : l\na✝ : SetTheory.PGame.InvTy l r Bool.false\n⊢ Eq (Eq (SetTheory.PGame.InvTy.right₁ a✝³ a✝²) (SetTheory.PGame.InvTy.right₁ a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.right₂.sizeOf_spec","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\ninst✝¹ : SizeOf l\ninst✝ : SizeOf r\na✝¹ : r\na✝ : SetTheory.PGame.InvTy l r Bool.true\n⊢ Eq (SizeOf.sizeOf (SetTheory.PGame.InvTy.right₂ a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.left₂.injEq","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\na✝³ : l\na✝² : SetTheory.PGame.InvTy l r Bool.true\na✝¹ : l\na✝ : SetTheory.PGame.InvTy l r Bool.true\n⊢ Eq (Eq (SetTheory.PGame.InvTy.left₂ a✝³ a✝²) (SetTheory.PGame.InvTy.left₂ a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.left₂.inj","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\na✝³ : l\na✝² : SetTheory.PGame.InvTy l r Bool.true\na✝¹ : l\na✝ : SetTheory.PGame.InvTy l r Bool.true\nx✝ : Eq (SetTheory.PGame.InvTy.left₂ a✝³ a✝²) (SetTheory.PGame.InvTy.left₂ a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.left₂.sizeOf_spec","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\ninst✝¹ : SizeOf l\ninst✝ : SizeOf r\na✝¹ : l\na✝ : SetTheory.PGame.InvTy l r Bool.true\n⊢ Eq (SizeOf.sizeOf (SetTheory.PGame.InvTy.left₂ a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.right₂.injEq","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\na✝³ : r\na✝² : SetTheory.PGame.InvTy l r Bool.true\na✝¹ : r\na✝ : SetTheory.PGame.InvTy l r Bool.true\n⊢ Eq (Eq (SetTheory.PGame.InvTy.right₂ a✝³ a✝²) (SetTheory.PGame.InvTy.right₂ a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.left₁.injEq","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\na✝³ : r\na✝² : SetTheory.PGame.InvTy l r Bool.false\na✝¹ : r\na✝ : SetTheory.PGame.InvTy l r Bool.false\n⊢ Eq (Eq (SetTheory.PGame.InvTy.left₁ a✝³ a✝²) (SetTheory.PGame.InvTy.left₁ a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.left₁.sizeOf_spec","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\ninst✝¹ : SizeOf l\ninst✝ : SizeOf r\na✝¹ : r\na✝ : SetTheory.PGame.InvTy l r Bool.false\n⊢ Eq (SizeOf.sizeOf (SetTheory.PGame.InvTy.left₁ a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.right₁.sizeOf_spec","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\ninst✝¹ : SizeOf l\ninst✝ : SizeOf r\na✝¹ : l\na✝ : SetTheory.PGame.InvTy l r Bool.false\n⊢ Eq (SizeOf.sizeOf (SetTheory.PGame.InvTy.right₁ a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.right₂.inj","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\na✝³ : r\na✝² : SetTheory.PGame.InvTy l r Bool.true\na✝¹ : r\na✝ : SetTheory.PGame.InvTy l r Bool.true\nx✝ : Eq (SetTheory.PGame.InvTy.right₂ a✝³ a✝²) (SetTheory.PGame.InvTy.right₂ a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.left₁.inj","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\na✝³ : r\na✝² : SetTheory.PGame.InvTy l r Bool.false\na✝¹ : r\na✝ : SetTheory.PGame.InvTy l r Bool.false\nx✝ : Eq (SetTheory.PGame.InvTy.left₁ a✝³ a✝²) (SetTheory.PGame.InvTy.left₁ a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.InvTy.right₁.inj","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\na✝³ : l\na✝² : SetTheory.PGame.InvTy l r Bool.false\na✝¹ : l\na✝ : SetTheory.PGame.InvTy l r Bool.false\nx✝ : Eq (SetTheory.PGame.InvTy.right₁ a✝³ a✝²) (SetTheory.PGame.InvTy.right₁ a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Because the two halves of the definition of `inv` produce more elements\non each side, we have to define the two families inductively.\nThis is the indexing set for the function, and `invVal` is the function part. -/\ninductive InvTy (l r : Type u) : Bool → Type u\n  | zero : InvTy l r false\n  | left₁ : r → InvTy l r false → InvTy l r false\n  | left₂ : l → InvTy l r true → InvTy l r false\n  | right₁ : l → InvTy l r false → InvTy l r true\n  | right₂ : r → InvTy l r true → InvTy l r true\n\n"}
{"name":"SetTheory.PGame.instIsEmptyInvTyTrue","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\ninst✝¹ : IsEmpty l\ninst✝ : IsEmpty r\n⊢ IsEmpty (SetTheory.PGame.InvTy l r Bool.true)","decl":"instance (l r : Type u) [IsEmpty l] [IsEmpty r] : IsEmpty (InvTy l r true) :=\n  ⟨by rintro (_ | _ | _ | a | a) <;> exact isEmptyElim a⟩\n\n"}
{"name":"SetTheory.PGame.invVal_isEmpty","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"l r : Type u\nb : Bool\nL : l → SetTheory.PGame\nR : r → SetTheory.PGame\nIHl : l → SetTheory.PGame\nIHr : r → SetTheory.PGame\ni : SetTheory.PGame.InvTy l r b\nx : SetTheory.PGame\ninst✝¹ : IsEmpty l\ninst✝ : IsEmpty r\n⊢ Eq (SetTheory.PGame.invVal L R IHl IHr x i) 0","decl":"@[simp]\ntheorem invVal_isEmpty {l r : Type u} {b} (L R IHl IHr) (i : InvTy l r b) (x) [IsEmpty l]\n    [IsEmpty r] : invVal L R IHl IHr x i = 0 := by\n  cases' i with a _ a _ a _ a\n  · rfl\n  all_goals exact isEmptyElim a\n\n"}
{"name":"SetTheory.PGame.zero_lf_inv'","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\n⊢ SetTheory.PGame.LF 0 x.inv'","decl":"theorem zero_lf_inv' : ∀ x : PGame, 0 ⧏ inv' x\n  | ⟨xl, xr, xL, xR⟩ => by\n    convert lf_mk _ _ InvTy.zero\n    rfl\n\n"}
{"name":"SetTheory.PGame.inv'_zero_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ HasEquiv.Equiv (SetTheory.PGame.inv' 0) 1","decl":"theorem inv'_zero_equiv : inv' 0 ≈ 1 :=\n  inv'Zero.equiv\n\n"}
{"name":"SetTheory.PGame.inv'_one","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ (SetTheory.PGame.inv' 1).Identical 1","decl":"/-- `inv' 1` has exactly the same moves as `1`. -/\nlemma inv'_one : inv' 1 ≡ 1 := by\n  rw [Identical.ext_iff]\n  constructor\n  · simp [memₗ_def, inv', isEmpty_subtype]\n  · simp [memᵣ_def, inv', isEmpty_subtype]\n\n"}
{"name":"SetTheory.PGame.inv'_one_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ HasEquiv.Equiv (SetTheory.PGame.inv' 1) 1","decl":"theorem inv'_one_equiv : inv' 1 ≈ 1 :=\n  inv'One.equiv\n\n"}
{"name":"SetTheory.PGame.inv_eq_of_equiv_zero","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\nh : HasEquiv.Equiv x 0\n⊢ Eq (Inv.inv x) 0","decl":"theorem inv_eq_of_equiv_zero {x : PGame} (h : x ≈ 0) : x⁻¹ = 0 := by classical exact if_pos h\n\n"}
{"name":"SetTheory.PGame.inv_zero","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ Eq (Inv.inv 0) 0","decl":"@[simp]\ntheorem inv_zero : (0 : PGame)⁻¹ = 0 :=\n  inv_eq_of_equiv_zero (equiv_refl _)\n\n"}
{"name":"SetTheory.PGame.inv_eq_of_pos","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\nh : LT.lt 0 x\n⊢ Eq (Inv.inv x) x.inv'","decl":"theorem inv_eq_of_pos {x : PGame} (h : 0 < x) : x⁻¹ = inv' x := by\n  classical exact (if_neg h.lf.not_equiv').trans (if_pos h)\n\n"}
{"name":"SetTheory.PGame.inv_eq_of_lf_zero","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"x : SetTheory.PGame\nh : x.LF 0\n⊢ Eq (Inv.inv x) (Neg.neg (Neg.neg x).inv')","decl":"theorem inv_eq_of_lf_zero {x : PGame} (h : x ⧏ 0) : x⁻¹ = -inv' (-x) := by\n  classical exact (if_neg h.not_equiv).trans (if_neg h.not_gt)\n\n"}
{"name":"SetTheory.PGame.inv_one","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ (Inv.inv 1).Identical 1","decl":"/-- `1⁻¹` has exactly the same moves as `1`. -/\nlemma inv_one : 1⁻¹ ≡ 1 := by\n  rw [inv_eq_of_pos PGame.zero_lt_one]\n  exact inv'_one\n\n"}
{"name":"SetTheory.PGame.inv_one_equiv","module":"Mathlib.SetTheory.Game.Basic","initialProofState":"⊢ HasEquiv.Equiv (Inv.inv 1) 1","decl":"theorem inv_one_equiv : (1⁻¹ : PGame) ≈ 1 :=\n  invOne.equiv\n\n"}
