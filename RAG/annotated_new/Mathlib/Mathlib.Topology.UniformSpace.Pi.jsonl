{"name":"Pi.uniformSpace_eq","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\n⊢ Eq (Pi.uniformSpace α) (iInf fun i => UniformSpace.comap (Function.eval i) (U i))","decl":"lemma Pi.uniformSpace_eq :\n    Pi.uniformSpace α = ⨅ i, UniformSpace.comap (eval i) (U i) := by\n  ext : 1; rfl\n\n"}
{"name":"Pi.uniformity","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\n⊢ Eq (uniformity ((i : ι) → α i)) (iInf fun i => Filter.comap (fun a => { fst := a.1 i, snd := a.2 i }) (uniformity (α i)))","decl":"theorem Pi.uniformity :\n    𝓤 (∀ i, α i) = ⨅ i : ι, (Filter.comap fun a => (a.1 i, a.2 i)) (𝓤 (α i)) :=\n  iInf_uniformity\n\n"}
{"name":"instIsCountablyGeneratedProdForallUniformityOfCountable","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\ninst✝¹ : Countable ι\ninst✝ : ∀ (i : ι), (uniformity (α i)).IsCountablyGenerated\n⊢ (uniformity ((i : ι) → α i)).IsCountablyGenerated","decl":"instance [Countable ι] [∀ i, IsCountablyGenerated (𝓤 (α i))] :\n    IsCountablyGenerated (𝓤 (∀ i, α i)) := by\n  rw [Pi.uniformity]\n  infer_instance\n\n"}
{"name":"uniformContinuous_pi","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\nβ : Type u_4\ninst✝ : UniformSpace β\nf : β → (i : ι) → α i\n⊢ Iff (UniformContinuous f) (∀ (i : ι), UniformContinuous fun x => f x i)","decl":"theorem uniformContinuous_pi {β : Type*} [UniformSpace β] {f : β → ∀ i, α i} :\n    UniformContinuous f ↔ ∀ i, UniformContinuous fun x => f x i := by\n  -- Porting note: required `Function.comp` to close\n  simp only [UniformContinuous, Pi.uniformity, tendsto_iInf, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Pi.uniformContinuous_proj","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\ni : ι\n⊢ UniformContinuous fun a => a i","decl":"theorem Pi.uniformContinuous_proj (i : ι) : UniformContinuous fun a : ∀ i : ι, α i => a i :=\n  uniformContinuous_pi.1 uniformContinuous_id i\n\n"}
{"name":"Pi.uniformContinuous_precomp'","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\nφ : ι' → ι\n⊢ UniformContinuous fun f j => f (φ j)","decl":"theorem Pi.uniformContinuous_precomp' (φ : ι' → ι) :\n    UniformContinuous (fun (f : (∀ i, α i)) (j : ι') ↦ f (φ j)) :=\n  uniformContinuous_pi.mpr fun j ↦ uniformContinuous_proj α (φ j)\n\n"}
{"name":"Pi.uniformContinuous_precomp","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\nβ : Type u_3\ninst✝ : UniformSpace β\nφ : ι' → ι\n⊢ UniformContinuous fun x => Function.comp x φ","decl":"theorem Pi.uniformContinuous_precomp (φ : ι' → ι) :\n    UniformContinuous (· ∘ φ : (ι → β) → (ι' → β)) :=\n  Pi.uniformContinuous_precomp' _ φ\n\n"}
{"name":"Pi.uniformContinuous_postcomp'","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\nβ : ι → Type u_4\ninst✝ : (i : ι) → UniformSpace (β i)\ng : (i : ι) → α i → β i\nhg : ∀ (i : ι), UniformContinuous (g i)\n⊢ UniformContinuous fun f i => g i (f i)","decl":"theorem Pi.uniformContinuous_postcomp' {β : ι → Type*} [∀ i, UniformSpace (β i)]\n    {g : ∀ i, α i → β i} (hg : ∀ i, UniformContinuous (g i)) :\n    UniformContinuous (fun (f : (∀ i, α i)) (i : ι) ↦ g i (f i)) :=\n  uniformContinuous_pi.mpr fun i ↦ (hg i).comp <| uniformContinuous_proj α i\n\n"}
{"name":"Pi.uniformContinuous_postcomp","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nβ : Type u_3\ninst✝¹ : UniformSpace β\nα : Type u_4\ninst✝ : UniformSpace α\ng : α → β\nhg : UniformContinuous g\n⊢ UniformContinuous fun x => Function.comp g x","decl":"theorem Pi.uniformContinuous_postcomp {α : Type*} [UniformSpace α] {g : α → β}\n    (hg : UniformContinuous g) : UniformContinuous (g ∘ · : (ι → α) → (ι → β)) :=\n  Pi.uniformContinuous_postcomp' _ fun _ ↦ hg\n\n"}
{"name":"Pi.uniformSpace_comap_precomp'","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\nφ : ι' → ι\n⊢ Eq (UniformSpace.comap (fun g i' => g (φ i')) (Pi.uniformSpace fun i' => α (φ i'))) (iInf fun i' => UniformSpace.comap (Function.eval (φ i')) (U (φ i')))","decl":"lemma Pi.uniformSpace_comap_precomp' (φ : ι' → ι) :\n    UniformSpace.comap (fun g i' ↦ g (φ i')) (Pi.uniformSpace (fun i' ↦ α (φ i'))) =\n    ⨅ i', UniformSpace.comap (eval (φ i')) (U (φ i')) := by\n  simp [Pi.uniformSpace_eq, UniformSpace.comap_iInf, ← UniformSpace.comap_comap, comp_def]\n\n"}
{"name":"Pi.uniformSpace_comap_precomp","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\nβ : Type u_3\ninst✝ : UniformSpace β\nφ : ι' → ι\n⊢ Eq (UniformSpace.comap (fun x => Function.comp x φ) (Pi.uniformSpace fun x => β)) (iInf fun i' => UniformSpace.comap (Function.eval (φ i')) inst✝)","decl":"lemma Pi.uniformSpace_comap_precomp (φ : ι' → ι) :\n    UniformSpace.comap (· ∘ φ) (Pi.uniformSpace (fun _ ↦ β)) =\n    ⨅ i', UniformSpace.comap (eval (φ i')) ‹UniformSpace β› :=\n  uniformSpace_comap_precomp' (fun _ ↦ β) φ\n\n"}
{"name":"Pi.uniformContinuous_restrict","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\nS : Set ι\n⊢ UniformContinuous S.restrict","decl":"lemma Pi.uniformContinuous_restrict (S : Set ι) :\n    UniformContinuous (S.restrict : (∀ i : ι, α i) → (∀ i : S, α i)) :=\n  Pi.uniformContinuous_precomp' _ ((↑) : S → ι)\n\n"}
{"name":"Pi.uniformSpace_comap_restrict","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\nS : Set ι\n⊢ Eq (UniformSpace.comap S.restrict (Pi.uniformSpace fun i => α ↑i)) (iInf fun i => iInf fun h => UniformSpace.comap (Function.eval i) (U i))","decl":"lemma Pi.uniformSpace_comap_restrict (S : Set ι) :\n    UniformSpace.comap (S.restrict) (Pi.uniformSpace (fun i : S ↦ α i)) =\n    ⨅ i ∈ S, UniformSpace.comap (eval i) (U i) := by\n  simp (config := { unfoldPartialApp := true })\n    [← iInf_subtype'', ← uniformSpace_comap_precomp' _ ((↑) : S → ι), Set.restrict]\n\n"}
{"name":"cauchy_pi_iff","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\ninst✝ : Nonempty ι\nl : Filter ((i : ι) → α i)\n⊢ Iff (Cauchy l) (∀ (i : ι), Cauchy (Filter.map (Function.eval i) l))","decl":"lemma cauchy_pi_iff [Nonempty ι] {l : Filter (∀ i, α i)} :\n    Cauchy l ↔ ∀ i, Cauchy (map (eval i) l) := by\n  simp_rw [Pi.uniformSpace_eq, cauchy_iInf_uniformSpace, cauchy_comap_uniformSpace]\n\n"}
{"name":"cauchy_pi_iff'","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\nl : Filter ((i : ι) → α i)\ninst✝ : l.NeBot\n⊢ Iff (Cauchy l) (∀ (i : ι), Cauchy (Filter.map (Function.eval i) l))","decl":"lemma cauchy_pi_iff' {l : Filter (∀ i, α i)} [l.NeBot] :\n    Cauchy l ↔ ∀ i, Cauchy (map (eval i) l) := by\n  simp_rw [Pi.uniformSpace_eq, cauchy_iInf_uniformSpace', cauchy_comap_uniformSpace]\n\n"}
{"name":"Cauchy.pi","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\ninst✝ : Nonempty ι\nl : (i : ι) → Filter (α i)\nhl : ∀ (i : ι), Cauchy (l i)\n⊢ Cauchy (Filter.pi l)","decl":"lemma Cauchy.pi [Nonempty ι] {l : ∀ i, Filter (α i)} (hl : ∀ i, Cauchy (l i)) :\n    Cauchy (Filter.pi l) := by\n  have := fun i ↦ (hl i).1\n  simpa [cauchy_pi_iff]\n\n"}
{"name":"Pi.complete","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\ninst✝ : ∀ (i : ι), CompleteSpace (α i)\n⊢ CompleteSpace ((i : ι) → α i)","decl":"instance Pi.complete [∀ i, CompleteSpace (α i)] : CompleteSpace (∀ i, α i) where\n  complete {f} hf := by\n    have := hf.1\n    simp_rw [cauchy_pi_iff', cauchy_iff_exists_le_nhds] at hf\n    choose x hx using hf\n    use x\n    rwa [nhds_pi, le_pi]\n\n"}
{"name":"Pi.uniformSpace_comap_restrict_sUnion","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u\nU : (i : ι) → UniformSpace (α i)\n𝔖 : Set (Set ι)\n⊢ Eq (UniformSpace.comap 𝔖.sUnion.restrict (Pi.uniformSpace fun i => α ↑i)) (iInf fun S => iInf fun h => UniformSpace.comap S.restrict (Pi.uniformSpace fun i => α ↑i))","decl":"lemma Pi.uniformSpace_comap_restrict_sUnion (𝔖 : Set (Set ι)) :\n    UniformSpace.comap (⋃₀ 𝔖).restrict (Pi.uniformSpace (fun i : (⋃₀ 𝔖) ↦ α i)) =\n    ⨅ S ∈ 𝔖, UniformSpace.comap S.restrict (Pi.uniformSpace (fun i : S ↦ α i)) := by\n  simp_rw [Pi.uniformSpace_comap_restrict α, iInf_sUnion]\n\n/- An infimum of complete uniformities is complete,\nas long as the whole family is bounded by some common T2 topology. -/\n"}
{"name":"CompleteSpace.iInf","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"ι : Type u_4\nX : Type u_5\nu : ι → UniformSpace X\nhu : ∀ (i : ι), CompleteSpace X\nht : Exists fun t => And (T2Space X) (∀ (i : ι), LE.le UniformSpace.toTopologicalSpace t)\n⊢ CompleteSpace X","decl":"protected theorem CompleteSpace.iInf {ι X : Type*} {u : ι → UniformSpace X}\n    (hu : ∀ i, @CompleteSpace X (u i))\n    (ht : ∃ t, @T2Space X t ∧ ∀ i, (u i).toTopologicalSpace ≤ t) :\n    @CompleteSpace X (⨅ i, u i) := by\n  -- We can assume `X` is nonempty.\n  nontriviality X\n  rcases ht with ⟨t, ht, hut⟩\n  -- The diagonal map `(X, ⨅ i, u i) → ∀ i, (X, u i)` is a uniform embedding.\n  have : @IsUniformInducing X (ι → X) (⨅ i, u i) (Pi.uniformSpace (U := u)) (const ι) := by\n    simp_rw [isUniformInducing_iff, iInf_uniformity, Pi.uniformity, Filter.comap_iInf,\n      Filter.comap_comap, comp_def, const, Prod.eta, comap_id']\n  -- Hence, it suffices to show that its range, the diagonal, is closed in `Π i, (X, u i)`.\n  simp_rw [@completeSpace_iff_isComplete_range _ _ (_) (_) _ this, range_const_eq_diagonal,\n    setOf_forall]\n  -- The separation of `t` ensures that this is the case in `Π i, (X, t)`, hence the result\n  -- since the topology associated to each `u i` is finer than `t`.\n  have : Pi.topologicalSpace (t₂ := fun i ↦ (u i).toTopologicalSpace) ≤\n         Pi.topologicalSpace (t₂ := fun _ ↦ t) :=\n    iInf_mono fun i ↦ induced_mono <| hut i\n  refine IsClosed.isComplete <| .mono ?_ this\n  exact isClosed_iInter fun i ↦ isClosed_iInter fun j ↦\n    isClosed_eq (continuous_apply _) (continuous_apply _)\n"}
