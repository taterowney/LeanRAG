{"name":"Pi.uniformSpace_eq","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nâŠ¢ Eq (Pi.uniformSpace Î±) (iInf fun i => UniformSpace.comap (Function.eval i) (U i))","decl":"lemma Pi.uniformSpace_eq :\n    Pi.uniformSpace Î± = â¨… i, UniformSpace.comap (eval i) (U i) := by\n  ext : 1; rfl\n\n"}
{"name":"Pi.uniformity","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nâŠ¢ Eq (uniformity ((i : Î¹) â†’ Î± i)) (iInf fun i => Filter.comap (fun a => { fst := a.1 i, snd := a.2 i }) (uniformity (Î± i)))","decl":"theorem Pi.uniformity :\n    ð“¤ (âˆ€ i, Î± i) = â¨… i : Î¹, (Filter.comap fun a => (a.1 i, a.2 i)) (ð“¤ (Î± i)) :=\n  iInf_uniformity\n\n"}
{"name":"instIsCountablyGeneratedProdForallUniformityOfCountable","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\ninstâœÂ¹ : Countable Î¹\ninstâœ : âˆ€ (i : Î¹), (uniformity (Î± i)).IsCountablyGenerated\nâŠ¢ (uniformity ((i : Î¹) â†’ Î± i)).IsCountablyGenerated","decl":"instance [Countable Î¹] [âˆ€ i, IsCountablyGenerated (ð“¤ (Î± i))] :\n    IsCountablyGenerated (ð“¤ (âˆ€ i, Î± i)) := by\n  rw [Pi.uniformity]\n  infer_instance\n\n"}
{"name":"uniformContinuous_pi","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nÎ² : Type u_4\ninstâœ : UniformSpace Î²\nf : Î² â†’ (i : Î¹) â†’ Î± i\nâŠ¢ Iff (UniformContinuous f) (âˆ€ (i : Î¹), UniformContinuous fun x => f x i)","decl":"theorem uniformContinuous_pi {Î² : Type*} [UniformSpace Î²] {f : Î² â†’ âˆ€ i, Î± i} :\n    UniformContinuous f â†” âˆ€ i, UniformContinuous fun x => f x i := by\n  -- Porting note: required `Function.comp` to close\n  simp only [UniformContinuous, Pi.uniformity, tendsto_iInf, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Pi.uniformContinuous_proj","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\ni : Î¹\nâŠ¢ UniformContinuous fun a => a i","decl":"theorem Pi.uniformContinuous_proj (i : Î¹) : UniformContinuous fun a : âˆ€ i : Î¹, Î± i => a i :=\n  uniformContinuous_pi.1 uniformContinuous_id i\n\n"}
{"name":"Pi.uniformContinuous_precomp'","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nÏ† : Î¹' â†’ Î¹\nâŠ¢ UniformContinuous fun f j => f (Ï† j)","decl":"theorem Pi.uniformContinuous_precomp' (Ï† : Î¹' â†’ Î¹) :\n    UniformContinuous (fun (f : (âˆ€ i, Î± i)) (j : Î¹') â†¦ f (Ï† j)) :=\n  uniformContinuous_pi.mpr fun j â†¦ uniformContinuous_proj Î± (Ï† j)\n\n"}
{"name":"Pi.uniformContinuous_precomp","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nÎ² : Type u_3\ninstâœ : UniformSpace Î²\nÏ† : Î¹' â†’ Î¹\nâŠ¢ UniformContinuous fun x => Function.comp x Ï†","decl":"theorem Pi.uniformContinuous_precomp (Ï† : Î¹' â†’ Î¹) :\n    UniformContinuous (Â· âˆ˜ Ï† : (Î¹ â†’ Î²) â†’ (Î¹' â†’ Î²)) :=\n  Pi.uniformContinuous_precomp' _ Ï†\n\n"}
{"name":"Pi.uniformContinuous_postcomp'","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nÎ² : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ UniformSpace (Î² i)\ng : (i : Î¹) â†’ Î± i â†’ Î² i\nhg : âˆ€ (i : Î¹), UniformContinuous (g i)\nâŠ¢ UniformContinuous fun f i => g i (f i)","decl":"theorem Pi.uniformContinuous_postcomp' {Î² : Î¹ â†’ Type*} [âˆ€ i, UniformSpace (Î² i)]\n    {g : âˆ€ i, Î± i â†’ Î² i} (hg : âˆ€ i, UniformContinuous (g i)) :\n    UniformContinuous (fun (f : (âˆ€ i, Î± i)) (i : Î¹) â†¦ g i (f i)) :=\n  uniformContinuous_pi.mpr fun i â†¦ (hg i).comp <| uniformContinuous_proj Î± i\n\n"}
{"name":"Pi.uniformContinuous_postcomp","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ² : Type u_3\ninstâœÂ¹ : UniformSpace Î²\nÎ± : Type u_4\ninstâœ : UniformSpace Î±\ng : Î± â†’ Î²\nhg : UniformContinuous g\nâŠ¢ UniformContinuous fun x => Function.comp g x","decl":"theorem Pi.uniformContinuous_postcomp {Î± : Type*} [UniformSpace Î±] {g : Î± â†’ Î²}\n    (hg : UniformContinuous g) : UniformContinuous (g âˆ˜ Â· : (Î¹ â†’ Î±) â†’ (Î¹ â†’ Î²)) :=\n  Pi.uniformContinuous_postcomp' _ fun _ â†¦ hg\n\n"}
{"name":"Pi.uniformSpace_comap_precomp'","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nÏ† : Î¹' â†’ Î¹\nâŠ¢ Eq (UniformSpace.comap (fun g i' => g (Ï† i')) (Pi.uniformSpace fun i' => Î± (Ï† i'))) (iInf fun i' => UniformSpace.comap (Function.eval (Ï† i')) (U (Ï† i')))","decl":"lemma Pi.uniformSpace_comap_precomp' (Ï† : Î¹' â†’ Î¹) :\n    UniformSpace.comap (fun g i' â†¦ g (Ï† i')) (Pi.uniformSpace (fun i' â†¦ Î± (Ï† i'))) =\n    â¨… i', UniformSpace.comap (eval (Ï† i')) (U (Ï† i')) := by\n  simp [Pi.uniformSpace_eq, UniformSpace.comap_iInf, â† UniformSpace.comap_comap, comp_def]\n\n"}
{"name":"Pi.uniformSpace_comap_precomp","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nÎ² : Type u_3\ninstâœ : UniformSpace Î²\nÏ† : Î¹' â†’ Î¹\nâŠ¢ Eq (UniformSpace.comap (fun x => Function.comp x Ï†) (Pi.uniformSpace fun x => Î²)) (iInf fun i' => UniformSpace.comap (Function.eval (Ï† i')) instâœ)","decl":"lemma Pi.uniformSpace_comap_precomp (Ï† : Î¹' â†’ Î¹) :\n    UniformSpace.comap (Â· âˆ˜ Ï†) (Pi.uniformSpace (fun _ â†¦ Î²)) =\n    â¨… i', UniformSpace.comap (eval (Ï† i')) â€¹UniformSpace Î²â€º :=\n  uniformSpace_comap_precomp' (fun _ â†¦ Î²) Ï†\n\n"}
{"name":"Pi.uniformContinuous_restrict","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nS : Set Î¹\nâŠ¢ UniformContinuous S.restrict","decl":"lemma Pi.uniformContinuous_restrict (S : Set Î¹) :\n    UniformContinuous (S.restrict : (âˆ€ i : Î¹, Î± i) â†’ (âˆ€ i : S, Î± i)) :=\n  Pi.uniformContinuous_precomp' _ ((â†‘) : S â†’ Î¹)\n\n"}
{"name":"Pi.uniformSpace_comap_restrict","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nS : Set Î¹\nâŠ¢ Eq (UniformSpace.comap S.restrict (Pi.uniformSpace fun i => Î± â†‘i)) (iInf fun i => iInf fun h => UniformSpace.comap (Function.eval i) (U i))","decl":"lemma Pi.uniformSpace_comap_restrict (S : Set Î¹) :\n    UniformSpace.comap (S.restrict) (Pi.uniformSpace (fun i : S â†¦ Î± i)) =\n    â¨… i âˆˆ S, UniformSpace.comap (eval i) (U i) := by\n  simp (config := { unfoldPartialApp := true })\n    [â† iInf_subtype'', â† uniformSpace_comap_precomp' _ ((â†‘) : S â†’ Î¹), Set.restrict]\n\n"}
{"name":"cauchy_pi_iff","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\ninstâœ : Nonempty Î¹\nl : Filter ((i : Î¹) â†’ Î± i)\nâŠ¢ Iff (Cauchy l) (âˆ€ (i : Î¹), Cauchy (Filter.map (Function.eval i) l))","decl":"lemma cauchy_pi_iff [Nonempty Î¹] {l : Filter (âˆ€ i, Î± i)} :\n    Cauchy l â†” âˆ€ i, Cauchy (map (eval i) l) := by\n  simp_rw [Pi.uniformSpace_eq, cauchy_iInf_uniformSpace, cauchy_comap_uniformSpace]\n\n"}
{"name":"cauchy_pi_iff'","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nl : Filter ((i : Î¹) â†’ Î± i)\ninstâœ : l.NeBot\nâŠ¢ Iff (Cauchy l) (âˆ€ (i : Î¹), Cauchy (Filter.map (Function.eval i) l))","decl":"lemma cauchy_pi_iff' {l : Filter (âˆ€ i, Î± i)} [l.NeBot] :\n    Cauchy l â†” âˆ€ i, Cauchy (map (eval i) l) := by\n  simp_rw [Pi.uniformSpace_eq, cauchy_iInf_uniformSpace', cauchy_comap_uniformSpace]\n\n"}
{"name":"Cauchy.pi","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\ninstâœ : Nonempty Î¹\nl : (i : Î¹) â†’ Filter (Î± i)\nhl : âˆ€ (i : Î¹), Cauchy (l i)\nâŠ¢ Cauchy (Filter.pi l)","decl":"lemma Cauchy.pi [Nonempty Î¹] {l : âˆ€ i, Filter (Î± i)} (hl : âˆ€ i, Cauchy (l i)) :\n    Cauchy (Filter.pi l) := by\n  have := fun i â†¦ (hl i).1\n  simpa [cauchy_pi_iff]\n\n"}
{"name":"Pi.complete","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\ninstâœ : âˆ€ (i : Î¹), CompleteSpace (Î± i)\nâŠ¢ CompleteSpace ((i : Î¹) â†’ Î± i)","decl":"instance Pi.complete [âˆ€ i, CompleteSpace (Î± i)] : CompleteSpace (âˆ€ i, Î± i) where\n  complete {f} hf := by\n    have := hf.1\n    simp_rw [cauchy_pi_iff', cauchy_iff_exists_le_nhds] at hf\n    choose x hx using hf\n    use x\n    rwa [nhds_pi, le_pi]\n\n"}
{"name":"Pi.uniformSpace_comap_restrict_sUnion","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_1\nÎ± : Î¹ â†’ Type u\nU : (i : Î¹) â†’ UniformSpace (Î± i)\nð”– : Set (Set Î¹)\nâŠ¢ Eq (UniformSpace.comap ð”–.sUnion.restrict (Pi.uniformSpace fun i => Î± â†‘i)) (iInf fun S => iInf fun h => UniformSpace.comap S.restrict (Pi.uniformSpace fun i => Î± â†‘i))","decl":"lemma Pi.uniformSpace_comap_restrict_sUnion (ð”– : Set (Set Î¹)) :\n    UniformSpace.comap (â‹ƒâ‚€ ð”–).restrict (Pi.uniformSpace (fun i : (â‹ƒâ‚€ ð”–) â†¦ Î± i)) =\n    â¨… S âˆˆ ð”–, UniformSpace.comap S.restrict (Pi.uniformSpace (fun i : S â†¦ Î± i)) := by\n  simp_rw [Pi.uniformSpace_comap_restrict Î±, iInf_sUnion]\n\n/- An infimum of complete uniformities is complete,\nas long as the whole family is bounded by some common T2 topology. -/\n"}
{"name":"CompleteSpace.iInf","module":"Mathlib.Topology.UniformSpace.Pi","initialProofState":"Î¹ : Type u_4\nX : Type u_5\nu : Î¹ â†’ UniformSpace X\nhu : âˆ€ (i : Î¹), CompleteSpace X\nht : Exists fun t => And (T2Space X) (âˆ€ (i : Î¹), LE.le UniformSpace.toTopologicalSpace t)\nâŠ¢ CompleteSpace X","decl":"protected theorem CompleteSpace.iInf {Î¹ X : Type*} {u : Î¹ â†’ UniformSpace X}\n    (hu : âˆ€ i, @CompleteSpace X (u i))\n    (ht : âˆƒ t, @T2Space X t âˆ§ âˆ€ i, (u i).toTopologicalSpace â‰¤ t) :\n    @CompleteSpace X (â¨… i, u i) := by\n  -- We can assume `X` is nonempty.\n  nontriviality X\n  rcases ht with âŸ¨t, ht, hutâŸ©\n  -- The diagonal map `(X, â¨… i, u i) â†’ âˆ€ i, (X, u i)` is a uniform embedding.\n  have : @IsUniformInducing X (Î¹ â†’ X) (â¨… i, u i) (Pi.uniformSpace (U := u)) (const Î¹) := by\n    simp_rw [isUniformInducing_iff, iInf_uniformity, Pi.uniformity, Filter.comap_iInf,\n      Filter.comap_comap, comp_def, const, Prod.eta, comap_id']\n  -- Hence, it suffices to show that its range, the diagonal, is closed in `Î  i, (X, u i)`.\n  simp_rw [@completeSpace_iff_isComplete_range _ _ (_) (_) _ this, range_const_eq_diagonal,\n    setOf_forall]\n  -- The separation of `t` ensures that this is the case in `Î  i, (X, t)`, hence the result\n  -- since the topology associated to each `u i` is finer than `t`.\n  have : Pi.topologicalSpace (tâ‚‚ := fun i â†¦ (u i).toTopologicalSpace) â‰¤\n         Pi.topologicalSpace (tâ‚‚ := fun _ â†¦ t) :=\n    iInf_mono fun i â†¦ induced_mono <| hut i\n  refine IsClosed.isComplete <| .mono ?_ this\n  exact isClosed_iInter fun i â†¦ isClosed_iInter fun j â†¦\n    isClosed_eq (continuous_apply _) (continuous_apply _)\n"}
