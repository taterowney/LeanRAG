{"name":"Set.dual_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\n⊢ Eq (Set.uIcc (OrderDual.toDual a) (OrderDual.toDual b)) (Set.preimage (⇑OrderDual.ofDual) (Set.uIcc a b))","decl":"@[simp] lemma dual_uIcc (a b : α) : [[toDual a, toDual b]] = ofDual ⁻¹' [[a, b]] :=\n  -- Note: needed to hint `(α := α)` after https://github.com/leanprover-community/mathlib4/pull/8386 (elaboration order?)\n  dual_Icc (α := α)\n\n"}
{"name":"Set.uIcc_of_le","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\nh : LE.le a b\n⊢ Eq (Set.uIcc a b) (Set.Icc a b)","decl":"@[simp]\nlemma uIcc_of_le (h : a ≤ b) : [[a, b]] = Icc a b := by rw [uIcc, inf_eq_left.2 h, sup_eq_right.2 h]\n\n"}
{"name":"Set.uIcc_of_ge","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\nh : LE.le b a\n⊢ Eq (Set.uIcc a b) (Set.Icc b a)","decl":"@[simp]\nlemma uIcc_of_ge (h : b ≤ a) : [[a, b]] = Icc b a := by rw [uIcc, inf_eq_right.2 h, sup_eq_left.2 h]\n\n"}
{"name":"Set.uIcc_comm","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\n⊢ Eq (Set.uIcc a b) (Set.uIcc b a)","decl":"lemma uIcc_comm (a b : α) : [[a, b]] = [[b, a]] := by simp_rw [uIcc, inf_comm, sup_comm]\n\n"}
{"name":"Set.uIcc_of_lt","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\nh : LT.lt a b\n⊢ Eq (Set.uIcc a b) (Set.Icc a b)","decl":"lemma uIcc_of_lt (h : a < b) : [[a, b]] = Icc a b := uIcc_of_le h.le\n"}
{"name":"Set.uIcc_of_gt","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\nh : LT.lt b a\n⊢ Eq (Set.uIcc a b) (Set.Icc b a)","decl":"lemma uIcc_of_gt (h : b < a) : [[a, b]] = Icc b a := uIcc_of_ge h.le\n\n"}
{"name":"Set.uIcc_self","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na : α\n⊢ Eq (Set.uIcc a a) (Singleton.singleton a)","decl":"lemma uIcc_self : [[a, a]] = {a} := by simp [uIcc]\n\n"}
{"name":"Set.nonempty_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\n⊢ (Set.uIcc a b).Nonempty","decl":"@[simp] lemma nonempty_uIcc : [[a, b]].Nonempty := nonempty_Icc.2 inf_le_sup\n\n"}
{"name":"Set.Icc_subset_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\n⊢ HasSubset.Subset (Set.Icc a b) (Set.uIcc a b)","decl":"lemma Icc_subset_uIcc : Icc a b ⊆ [[a, b]] := Icc_subset_Icc inf_le_left le_sup_right\n"}
{"name":"Set.Icc_subset_uIcc'","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\n⊢ HasSubset.Subset (Set.Icc b a) (Set.uIcc a b)","decl":"lemma Icc_subset_uIcc' : Icc b a ⊆ [[a, b]] := Icc_subset_Icc inf_le_right le_sup_left\n\n"}
{"name":"Set.left_mem_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\n⊢ Membership.mem (Set.uIcc a b) a","decl":"@[simp] lemma left_mem_uIcc : a ∈ [[a, b]] := ⟨inf_le_left, le_sup_left⟩\n"}
{"name":"Set.right_mem_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\n⊢ Membership.mem (Set.uIcc a b) b","decl":"@[simp] lemma right_mem_uIcc : b ∈ [[a, b]] := ⟨inf_le_right, le_sup_right⟩\n\n"}
{"name":"Set.mem_uIcc_of_le","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b x : α\nha : LE.le a x\nhb : LE.le x b\n⊢ Membership.mem (Set.uIcc a b) x","decl":"lemma mem_uIcc_of_le (ha : a ≤ x) (hb : x ≤ b) : x ∈ [[a, b]] := Icc_subset_uIcc ⟨ha, hb⟩\n"}
{"name":"Set.mem_uIcc_of_ge","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b x : α\nhb : LE.le b x\nha : LE.le x a\n⊢ Membership.mem (Set.uIcc a b) x","decl":"lemma mem_uIcc_of_ge (hb : b ≤ x) (ha : x ≤ a) : x ∈ [[a, b]] := Icc_subset_uIcc' ⟨hb, ha⟩\n\n"}
{"name":"Set.uIcc_subset_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na₁ a₂ b₁ b₂ : α\nh₁ : Membership.mem (Set.uIcc a₂ b₂) a₁\nh₂ : Membership.mem (Set.uIcc a₂ b₂) b₁\n⊢ HasSubset.Subset (Set.uIcc a₁ b₁) (Set.uIcc a₂ b₂)","decl":"lemma uIcc_subset_uIcc (h₁ : a₁ ∈ [[a₂, b₂]]) (h₂ : b₁ ∈ [[a₂, b₂]]) :\n    [[a₁, b₁]] ⊆ [[a₂, b₂]] :=\n  Icc_subset_Icc (le_inf h₁.1 h₂.1) (sup_le h₁.2 h₂.2)\n\n"}
{"name":"Set.uIcc_subset_Icc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na₁ a₂ b₁ b₂ : α\nha : Membership.mem (Set.Icc a₂ b₂) a₁\nhb : Membership.mem (Set.Icc a₂ b₂) b₁\n⊢ HasSubset.Subset (Set.uIcc a₁ b₁) (Set.Icc a₂ b₂)","decl":"lemma uIcc_subset_Icc (ha : a₁ ∈ Icc a₂ b₂) (hb : b₁ ∈ Icc a₂ b₂) :\n    [[a₁, b₁]] ⊆ Icc a₂ b₂ :=\n  Icc_subset_Icc (le_inf ha.1 hb.1) (sup_le ha.2 hb.2)\n\n"}
{"name":"Set.uIcc_subset_uIcc_iff_mem","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na₁ a₂ b₁ b₂ : α\n⊢ Iff (HasSubset.Subset (Set.uIcc a₁ b₁) (Set.uIcc a₂ b₂)) (And (Membership.mem (Set.uIcc a₂ b₂) a₁) (Membership.mem (Set.uIcc a₂ b₂) b₁))","decl":"lemma uIcc_subset_uIcc_iff_mem :\n    [[a₁, b₁]] ⊆ [[a₂, b₂]] ↔ a₁ ∈ [[a₂, b₂]] ∧ b₁ ∈ [[a₂, b₂]] :=\n  Iff.intro (fun h => ⟨h left_mem_uIcc, h right_mem_uIcc⟩) fun h =>\n    uIcc_subset_uIcc h.1 h.2\n\n"}
{"name":"Set.uIcc_subset_uIcc_iff_le'","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na₁ a₂ b₁ b₂ : α\n⊢ Iff (HasSubset.Subset (Set.uIcc a₁ b₁) (Set.uIcc a₂ b₂)) (And (LE.le (Min.min a₂ b₂) (Min.min a₁ b₁)) (LE.le (Max.max a₁ b₁) (Max.max a₂ b₂)))","decl":"lemma uIcc_subset_uIcc_iff_le' :\n    [[a₁, b₁]] ⊆ [[a₂, b₂]] ↔ a₂ ⊓ b₂ ≤ a₁ ⊓ b₁ ∧ a₁ ⊔ b₁ ≤ a₂ ⊔ b₂ :=\n  Icc_subset_Icc_iff inf_le_sup\n\n"}
{"name":"Set.uIcc_subset_uIcc_right","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b x : α\nh : Membership.mem (Set.uIcc a b) x\n⊢ HasSubset.Subset (Set.uIcc x b) (Set.uIcc a b)","decl":"lemma uIcc_subset_uIcc_right (h : x ∈ [[a, b]]) : [[x, b]] ⊆ [[a, b]] :=\n  uIcc_subset_uIcc h right_mem_uIcc\n\n"}
{"name":"Set.uIcc_subset_uIcc_left","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b x : α\nh : Membership.mem (Set.uIcc a b) x\n⊢ HasSubset.Subset (Set.uIcc a x) (Set.uIcc a b)","decl":"lemma uIcc_subset_uIcc_left (h : x ∈ [[a, b]]) : [[a, x]] ⊆ [[a, b]] :=\n  uIcc_subset_uIcc left_mem_uIcc h\n\n"}
{"name":"Set.bdd_below_bdd_above_iff_subset_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : Lattice α\ns : Set α\n⊢ Iff (And (BddBelow s) (BddAbove s)) (Exists fun a => Exists fun b => HasSubset.Subset s (Set.uIcc a b))","decl":"lemma bdd_below_bdd_above_iff_subset_uIcc (s : Set α) :\n    BddBelow s ∧ BddAbove s ↔ ∃ a b, s ⊆ [[a, b]] :=\n  bddBelow_bddAbove_iff_subset_Icc.trans\n    ⟨fun ⟨a, b, h⟩ => ⟨a, b, fun _ hx => Icc_subset_uIcc (h hx)⟩, fun ⟨_, _, h⟩ => ⟨_, _, h⟩⟩\n\n"}
{"name":"Set.uIcc_prod_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Lattice α\ninst✝ : Lattice β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Eq (SProd.sprod (Set.uIcc a₁ a₂) (Set.uIcc b₁ b₂)) (Set.uIcc { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ })","decl":"@[simp]\ntheorem uIcc_prod_uIcc (a₁ a₂ : α) (b₁ b₂ : β) :\n    [[a₁, a₂]] ×ˢ [[b₁, b₂]] = [[(a₁, b₁), (a₂, b₂)]] :=\n  Icc_prod_Icc _ _ _ _\n\n"}
{"name":"Set.uIcc_prod_eq","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Lattice α\ninst✝ : Lattice β\na b : Prod α β\n⊢ Eq (Set.uIcc a b) (SProd.sprod (Set.uIcc a.1 b.1) (Set.uIcc a.2 b.2))","decl":"theorem uIcc_prod_eq (a b : α × β) : [[a, b]] = [[a.1, b.1]] ×ˢ [[a.2, b.2]] := by simp\n\n"}
{"name":"Set.eq_of_mem_uIcc_of_mem_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : DistribLattice α\na b c : α\nha : Membership.mem (Set.uIcc b c) a\nhb : Membership.mem (Set.uIcc a c) b\n⊢ Eq a b","decl":"lemma eq_of_mem_uIcc_of_mem_uIcc (ha : a ∈ [[b, c]]) (hb : b ∈ [[a, c]]) : a = b :=\n  eq_of_inf_eq_sup_eq (inf_congr_right ha.1 hb.1) <| sup_congr_right ha.2 hb.2\n\n"}
{"name":"Set.eq_of_mem_uIcc_of_mem_uIcc'","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : DistribLattice α\na b c : α\na✝¹ : Membership.mem (Set.uIcc a c) b\na✝ : Membership.mem (Set.uIcc a b) c\n⊢ Eq b c","decl":"lemma eq_of_mem_uIcc_of_mem_uIcc' : b ∈ [[a, c]] → c ∈ [[a, b]] → b = c := by\n  simpa only [uIcc_comm a] using eq_of_mem_uIcc_of_mem_uIcc\n\n"}
{"name":"Set.uIcc_injective_right","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : DistribLattice α\na : α\n⊢ Function.Injective fun b => Set.uIcc b a","decl":"lemma uIcc_injective_right (a : α) : Injective fun b => uIcc b a := fun b c h => by\n  rw [Set.ext_iff] at h\n  exact eq_of_mem_uIcc_of_mem_uIcc ((h _).1 left_mem_uIcc) ((h _).2 left_mem_uIcc)\n\n"}
{"name":"Set.uIcc_injective_left","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : DistribLattice α\na : α\n⊢ Function.Injective (Set.uIcc a)","decl":"lemma uIcc_injective_left (a : α) : Injective (uIcc a) := by\n  simpa only [uIcc_comm] using uIcc_injective_right a\n\n"}
{"name":"MonotoneOn.mapsTo_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Lattice β\nf : α → β\na b : α\nhf : MonotoneOn f (Set.uIcc a b)\n⊢ Set.MapsTo f (Set.uIcc a b) (Set.uIcc (f a) (f b))","decl":"lemma _root_.MonotoneOn.mapsTo_uIcc (hf : MonotoneOn f (uIcc a b)) :\n    MapsTo f (uIcc a b) (uIcc (f a) (f b)) := by\n  rw [uIcc, uIcc, ← hf.map_sup, ← hf.map_inf] <;>\n    apply_rules [left_mem_uIcc, right_mem_uIcc, hf.mapsTo_Icc]\n\n"}
{"name":"AntitoneOn.mapsTo_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Lattice β\nf : α → β\na b : α\nhf : AntitoneOn f (Set.uIcc a b)\n⊢ Set.MapsTo f (Set.uIcc a b) (Set.uIcc (f a) (f b))","decl":"lemma _root_.AntitoneOn.mapsTo_uIcc (hf : AntitoneOn f (uIcc a b)) :\n    MapsTo f (uIcc a b) (uIcc (f a) (f b)) := by\n  rw [uIcc, uIcc, ← hf.map_sup, ← hf.map_inf] <;>\n    apply_rules [left_mem_uIcc, right_mem_uIcc, hf.mapsTo_Icc]\n\n"}
{"name":"Monotone.mapsTo_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Lattice β\nf : α → β\na b : α\nhf : Monotone f\n⊢ Set.MapsTo f (Set.uIcc a b) (Set.uIcc (f a) (f b))","decl":"lemma _root_.Monotone.mapsTo_uIcc (hf : Monotone f) : MapsTo f (uIcc a b) (uIcc (f a) (f b)) :=\n  (hf.monotoneOn _).mapsTo_uIcc\n\n"}
{"name":"Antitone.mapsTo_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Lattice β\nf : α → β\na b : α\nhf : Antitone f\n⊢ Set.MapsTo f (Set.uIcc a b) (Set.uIcc (f a) (f b))","decl":"lemma _root_.Antitone.mapsTo_uIcc (hf : Antitone f) : MapsTo f (uIcc a b) (uIcc (f a) (f b)) :=\n  (hf.antitoneOn _).mapsTo_uIcc\n\n"}
{"name":"MonotoneOn.image_uIcc_subset","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Lattice β\nf : α → β\na b : α\nhf : MonotoneOn f (Set.uIcc a b)\n⊢ HasSubset.Subset (Set.image f (Set.uIcc a b)) (Set.uIcc (f a) (f b))","decl":"lemma _root_.MonotoneOn.image_uIcc_subset (hf : MonotoneOn f (uIcc a b)) :\n    f '' uIcc a b ⊆ uIcc (f a) (f b) := hf.mapsTo_uIcc.image_subset\n\n"}
{"name":"AntitoneOn.image_uIcc_subset","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Lattice β\nf : α → β\na b : α\nhf : AntitoneOn f (Set.uIcc a b)\n⊢ HasSubset.Subset (Set.image f (Set.uIcc a b)) (Set.uIcc (f a) (f b))","decl":"lemma _root_.AntitoneOn.image_uIcc_subset (hf : AntitoneOn f (uIcc a b)) :\n    f '' uIcc a b ⊆ uIcc (f a) (f b) := hf.mapsTo_uIcc.image_subset\n\n"}
{"name":"Monotone.image_uIcc_subset","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Lattice β\nf : α → β\na b : α\nhf : Monotone f\n⊢ HasSubset.Subset (Set.image f (Set.uIcc a b)) (Set.uIcc (f a) (f b))","decl":"lemma _root_.Monotone.image_uIcc_subset (hf : Monotone f) : f '' uIcc a b ⊆ uIcc (f a) (f b) :=\n  (hf.monotoneOn _).image_uIcc_subset\n\n"}
{"name":"Antitone.image_uIcc_subset","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Lattice β\nf : α → β\na b : α\nhf : Antitone f\n⊢ HasSubset.Subset (Set.image f (Set.uIcc a b)) (Set.uIcc (f a) (f b))","decl":"lemma _root_.Antitone.image_uIcc_subset (hf : Antitone f) : f '' uIcc a b ⊆ uIcc (f a) (f b) :=\n  (hf.antitoneOn _).image_uIcc_subset\n\n"}
{"name":"Set.Icc_min_max","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Set.Icc (Min.min a b) (Max.max a b)) (Set.uIcc a b)","decl":"theorem Icc_min_max : Icc (min a b) (max a b) = [[a, b]] :=\n  rfl\n\n"}
{"name":"Set.uIcc_of_not_le","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : Not (LE.le a b)\n⊢ Eq (Set.uIcc a b) (Set.Icc b a)","decl":"lemma uIcc_of_not_le (h : ¬a ≤ b) : [[a, b]] = Icc b a := uIcc_of_gt <| lt_of_not_ge h\n"}
{"name":"Set.uIcc_of_not_ge","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : Not (LE.le b a)\n⊢ Eq (Set.uIcc a b) (Set.Icc a b)","decl":"lemma uIcc_of_not_ge (h : ¬b ≤ a) : [[a, b]] = Icc a b := uIcc_of_lt <| lt_of_not_ge h\n\n"}
{"name":"Set.uIcc_eq_union","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Set.uIcc a b) (Union.union (Set.Icc a b) (Set.Icc b a))","decl":"lemma uIcc_eq_union : [[a, b]] = Icc a b ∪ Icc b a := by rw [Icc_union_Icc', max_comm] <;> rfl\n\n"}
{"name":"Set.mem_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (Membership.mem (Set.uIcc b c) a) (Or (And (LE.le b a) (LE.le a c)) (And (LE.le c a) (LE.le a b)))","decl":"lemma mem_uIcc : a ∈ [[b, c]] ↔ b ≤ a ∧ a ≤ c ∨ c ≤ a ∧ a ≤ b := by simp [uIcc_eq_union]\n\n"}
{"name":"Set.not_mem_uIcc_of_lt","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nha : LT.lt c a\nhb : LT.lt c b\n⊢ Not (Membership.mem (Set.uIcc a b) c)","decl":"lemma not_mem_uIcc_of_lt (ha : c < a) (hb : c < b) : c ∉ [[a, b]] :=\n  not_mem_Icc_of_lt <| lt_min_iff.mpr ⟨ha, hb⟩\n\n"}
{"name":"Set.not_mem_uIcc_of_gt","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nha : LT.lt a c\nhb : LT.lt b c\n⊢ Not (Membership.mem (Set.uIcc a b) c)","decl":"lemma not_mem_uIcc_of_gt (ha : a < c) (hb : b < c) : c ∉ [[a, b]] :=\n  not_mem_Icc_of_gt <| max_lt_iff.mpr ⟨ha, hb⟩\n\n"}
{"name":"Set.uIcc_subset_uIcc_iff_le","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\n⊢ Iff (HasSubset.Subset (Set.uIcc a₁ b₁) (Set.uIcc a₂ b₂)) (And (LE.le (Min.min a₂ b₂) (Min.min a₁ b₁)) (LE.le (Max.max a₁ b₁) (Max.max a₂ b₂)))","decl":"lemma uIcc_subset_uIcc_iff_le :\n    [[a₁, b₁]] ⊆ [[a₂, b₂]] ↔ min a₂ b₂ ≤ min a₁ b₁ ∧ max a₁ b₁ ≤ max a₂ b₂ :=\n  uIcc_subset_uIcc_iff_le'\n\n"}
{"name":"Set.uIcc_subset_uIcc_union_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.uIcc a c) (Union.union (Set.uIcc a b) (Set.uIcc b c))","decl":"/-- A sort of triangle inequality. -/\nlemma uIcc_subset_uIcc_union_uIcc : [[a, c]] ⊆ [[a, b]] ∪ [[b, c]] := fun x => by\n  simp only [mem_uIcc, mem_union]\n  rcases le_total x b with h2 | h2 <;> tauto\n\n"}
{"name":"Set.monotone_or_antitone_iff_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\n⊢ Iff (Or (Monotone f) (Antitone f)) (∀ (a b c : α), Membership.mem (Set.uIcc a b) c → Membership.mem (Set.uIcc (f a) (f b)) (f c))","decl":"lemma monotone_or_antitone_iff_uIcc :\n    Monotone f ∨ Antitone f ↔ ∀ a b c, c ∈ [[a, b]] → f c ∈ [[f a, f b]] := by\n  constructor\n  · rintro (hf | hf) a b c <;> simp_rw [← Icc_min_max, ← hf.map_min, ← hf.map_max]\n    exacts [fun hc => ⟨hf hc.1, hf hc.2⟩, fun hc => ⟨hf hc.2, hf hc.1⟩]\n  contrapose!\n  rw [not_monotone_not_antitone_iff_exists_le_le]\n  rintro ⟨a, b, c, hab, hbc, ⟨hfab, hfcb⟩ | ⟨hfba, hfbc⟩⟩\n  · exact ⟨a, c, b, Icc_subset_uIcc ⟨hab, hbc⟩, fun h => h.2.not_lt <| max_lt hfab hfcb⟩\n  · exact ⟨a, c, b, Icc_subset_uIcc ⟨hab, hbc⟩, fun h => h.1.not_lt <| lt_min hfba hfbc⟩\n\n-- Porting note: mathport expands the syntactic sugar `∀ a b c ∈ s` differently than Lean3\n"}
{"name":"Set.monotoneOn_or_antitoneOn_iff_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : α → β\ns : Set α\n⊢ Iff (Or (MonotoneOn f s) (AntitoneOn f s)) (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → ∀ (c : α), Membership.mem s c → Membership.mem (Set.uIcc a b) c → Membership.mem (Set.uIcc (f a) (f b)) (f c))","decl":"lemma monotoneOn_or_antitoneOn_iff_uIcc :\n    MonotoneOn f s ∨ AntitoneOn f s ↔\n      ∀ᵉ (a ∈ s) (b ∈ s) (c ∈ s), c ∈ [[a, b]] → f c ∈ [[f a, f b]] := by\n  simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, monotone_or_antitone_iff_uIcc,\n    mem_uIcc]\n\n-- Porting note: what should the naming scheme be here? This is a term, so should be `uIoc`,\n-- but we also want to match the `Ioc` convention.\n"}
{"name":"Set.uIoc_of_le","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Set.uIoc a b) (Set.Ioc a b)","decl":"@[simp] lemma uIoc_of_le (h : a ≤ b) : Ι a b = Ioc a b := by simp [uIoc, h]\n"}
{"name":"Set.uIoc_of_ge","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le b a\n⊢ Eq (Set.uIoc a b) (Set.Ioc b a)","decl":"@[simp] lemma uIoc_of_ge (h : b ≤ a) : Ι a b = Ioc b a := by simp [uIoc, h]\n\n"}
{"name":"Set.uIoc_eq_union","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Set.uIoc a b) (Union.union (Set.Ioc a b) (Set.Ioc b a))","decl":"lemma uIoc_eq_union : Ι a b = Ioc a b ∪ Ioc b a := by\n  cases le_total a b <;> simp [uIoc, *]\n\n"}
{"name":"Set.mem_uIoc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (Membership.mem (Set.uIoc b c) a) (Or (And (LT.lt b a) (LE.le a c)) (And (LT.lt c a) (LE.le a b)))","decl":"lemma mem_uIoc : a ∈ Ι b c ↔ b < a ∧ a ≤ c ∨ c < a ∧ a ≤ b := by\n  rw [uIoc_eq_union, mem_union, mem_Ioc, mem_Ioc]\n\n"}
{"name":"Set.not_mem_uIoc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (Not (Membership.mem (Set.uIoc b c) a)) (Or (And (LE.le a b) (LE.le a c)) (And (LT.lt c a) (LT.lt b a)))","decl":"lemma not_mem_uIoc : a ∉ Ι b c ↔ a ≤ b ∧ a ≤ c ∨ c < a ∧ b < a := by\n  simp only [uIoc_eq_union, mem_union, mem_Ioc, not_lt, ← not_le]\n  tauto\n\n"}
{"name":"Set.left_mem_uIoc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Membership.mem (Set.uIoc a b) a) (LT.lt b a)","decl":"@[simp] lemma left_mem_uIoc : a ∈ Ι a b ↔ b < a := by simp [mem_uIoc]\n"}
{"name":"Set.right_mem_uIoc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Membership.mem (Set.uIoc a b) b) (LT.lt a b)","decl":"@[simp] lemma right_mem_uIoc : b ∈ Ι a b ↔ a < b := by simp [mem_uIoc]\n\n"}
{"name":"Set.forall_uIoc_iff","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nP : α → Prop\n⊢ Iff (∀ (x : α), Membership.mem (Set.uIoc a b) x → P x) (And (∀ (x : α), Membership.mem (Set.Ioc a b) x → P x) (∀ (x : α), Membership.mem (Set.Ioc b a) x → P x))","decl":"lemma forall_uIoc_iff {P : α → Prop} :\n    (∀ x ∈ Ι a b, P x) ↔ (∀ x ∈ Ioc a b, P x) ∧ ∀ x ∈ Ioc b a, P x := by\n  simp only [uIoc_eq_union, mem_union, or_imp, forall_and]\n\n"}
{"name":"Set.uIoc_subset_uIoc_of_uIcc_subset_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c d : α\nh : HasSubset.Subset (Set.uIcc a b) (Set.uIcc c d)\n⊢ HasSubset.Subset (Set.uIoc a b) (Set.uIoc c d)","decl":"lemma uIoc_subset_uIoc_of_uIcc_subset_uIcc {a b c d : α}\n    (h : [[a, b]] ⊆ [[c, d]]) : Ι a b ⊆ Ι c d :=\n  Ioc_subset_Ioc (uIcc_subset_uIcc_iff_le.1 h).1 (uIcc_subset_uIcc_iff_le.1 h).2\n\n"}
{"name":"Set.uIoc_comm","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Set.uIoc a b) (Set.uIoc b a)","decl":"lemma uIoc_comm (a b : α) : Ι a b = Ι b a := by simp only [uIoc, min_comm a b, max_comm a b]\n\n"}
{"name":"Set.Ioc_subset_uIoc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ioc a b) (Set.uIoc a b)","decl":"lemma Ioc_subset_uIoc : Ioc a b ⊆ Ι a b := Ioc_subset_Ioc (min_le_left _ _) (le_max_right _ _)\n"}
{"name":"Set.Ioc_subset_uIoc'","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ioc a b) (Set.uIoc b a)","decl":"lemma Ioc_subset_uIoc' : Ioc a b ⊆ Ι b a := Ioc_subset_Ioc (min_le_right _ _) (le_max_left _ _)\n\n"}
{"name":"Set.uIoc_subset_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.uIoc a b) (Set.uIcc a b)","decl":"lemma uIoc_subset_uIcc : Ι a b ⊆ uIcc a b := Ioc_subset_Icc_self\n\n"}
{"name":"Set.eq_of_mem_uIoc_of_mem_uIoc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\na✝¹ : Membership.mem (Set.uIoc b c) a\na✝ : Membership.mem (Set.uIoc a c) b\n⊢ Eq a b","decl":"lemma eq_of_mem_uIoc_of_mem_uIoc : a ∈ Ι b c → b ∈ Ι a c → a = b := by\n  simp_rw [mem_uIoc]; rintro (⟨_, _⟩ | ⟨_, _⟩) (⟨_, _⟩ | ⟨_, _⟩) <;> apply le_antisymm <;>\n    first |assumption|exact le_of_lt ‹_›|exact le_trans ‹_› (le_of_lt ‹_›)\n\n"}
{"name":"Set.eq_of_mem_uIoc_of_mem_uIoc'","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\na✝¹ : Membership.mem (Set.uIoc a c) b\na✝ : Membership.mem (Set.uIoc a b) c\n⊢ Eq b c","decl":"lemma eq_of_mem_uIoc_of_mem_uIoc' : b ∈ Ι a c → c ∈ Ι a b → b = c := by\n  simpa only [uIoc_comm a] using eq_of_mem_uIoc_of_mem_uIoc\n\n"}
{"name":"Set.eq_of_not_mem_uIoc_of_not_mem_uIoc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nha : LE.le a c\nhb : LE.le b c\na✝¹ : Not (Membership.mem (Set.uIoc b c) a)\na✝ : Not (Membership.mem (Set.uIoc a c) b)\n⊢ Eq a b","decl":"lemma eq_of_not_mem_uIoc_of_not_mem_uIoc (ha : a ≤ c) (hb : b ≤ c) :\n    a ∉ Ι b c → b ∉ Ι a c → a = b := by\n  simp_rw [not_mem_uIoc]\n  rintro (⟨_, _⟩ | ⟨_, _⟩) (⟨_, _⟩ | ⟨_, _⟩) <;>\n      apply le_antisymm <;>\n    first |assumption|exact le_of_lt ‹_›|\n    exact absurd hb (not_le_of_lt ‹c < b›)|exact absurd ha (not_le_of_lt ‹c < a›)\n\n"}
{"name":"Set.uIoc_injective_right","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Function.Injective fun b => Set.uIoc b a","decl":"lemma uIoc_injective_right (a : α) : Injective fun b => Ι b a := by\n  rintro b c h\n  rw [Set.ext_iff] at h\n  obtain ha | ha := le_or_lt b a\n  · have hb := (h b).not\n    simp only [ha, left_mem_uIoc, not_lt, true_iff, not_mem_uIoc, ← not_le,\n      and_true, not_true, false_and, not_false_iff, or_false] at hb\n    refine hb.eq_of_not_lt fun hc => ?_\n    simpa [ha, and_iff_right hc, ← @not_le _ _ _ a, iff_not_self, -not_le] using h c\n  · refine\n      eq_of_mem_uIoc_of_mem_uIoc ((h _).1 <| left_mem_uIoc.2 ha)\n        ((h _).2 <| left_mem_uIoc.2 <| ha.trans_le ?_)\n    simpa [ha, ha.not_le, mem_uIoc] using h b\n\n"}
{"name":"Set.uIoc_injective_left","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Function.Injective (Set.uIoc a)","decl":"lemma uIoc_injective_left (a : α) : Injective (Ι a) := by\n  simpa only [uIoc_comm] using uIoc_injective_right a\n\n"}
{"name":"Set.dual_uIoo","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Set.uIoo (OrderDual.toDual a) (OrderDual.toDual b)) (Set.preimage (⇑OrderDual.ofDual) (Set.uIoo a b))","decl":"@[simp] lemma dual_uIoo (a b : α) : uIoo (toDual a) (toDual b) = ofDual ⁻¹' uIoo a b :=\n  dual_Ioo (α := α)\n\n"}
{"name":"Set.uIoo_of_le","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Set.uIoo a b) (Set.Ioo a b)","decl":"@[simp] lemma uIoo_of_le (h : a ≤ b) : uIoo a b = Ioo a b := by\n  rw [uIoo, inf_eq_left.2 h, sup_eq_right.2 h]\n\n"}
{"name":"Set.uIoo_of_ge","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le b a\n⊢ Eq (Set.uIoo a b) (Set.Ioo b a)","decl":"@[simp] lemma uIoo_of_ge (h : b ≤ a) : uIoo a b = Ioo b a := by\n  rw [uIoo, inf_eq_right.2 h, sup_eq_left.2 h]\n\n"}
{"name":"Set.uIoo_comm","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Set.uIoo a b) (Set.uIoo b a)","decl":"lemma uIoo_comm (a b : α) : uIoo a b = uIoo b a := by simp_rw [uIoo, inf_comm, sup_comm]\n\n"}
{"name":"Set.uIoo_of_lt","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Set.uIoo a b) (Set.Ioo a b)","decl":"lemma uIoo_of_lt (h : a < b) : uIoo a b = Ioo a b := uIoo_of_le h.le\n\n"}
{"name":"Set.uIoo_of_gt","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt b a\n⊢ Eq (Set.uIoo a b) (Set.Ioo b a)","decl":"lemma uIoo_of_gt (h : b < a) : uIoo a b = Ioo b a := uIoo_of_ge h.le\n\n"}
{"name":"Set.uIoo_self","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Set.uIoo a a) EmptyCollection.emptyCollection","decl":"lemma uIoo_self : uIoo a a = ∅ := by simp [uIoo]\n\n"}
{"name":"Set.Ioo_subset_uIoo","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ioo a b) (Set.uIoo a b)","decl":"lemma Ioo_subset_uIoo : Ioo a b ⊆ uIoo a b := Ioo_subset_Ioo inf_le_left le_sup_right\n\n"}
{"name":"Set.Ioo_subset_uIoo'","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ioo b a) (Set.uIoo a b)","decl":"/-- Same as `Ioo_subset_uIoo` but with `Ioo a b` replaced by `Ioo b a`. -/\nlemma Ioo_subset_uIoo' : Ioo b a ⊆ uIoo a b := Ioo_subset_Ioo inf_le_right le_sup_left\n\n"}
{"name":"Set.mem_uIoo_of_lt","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b x : α\nha : LT.lt a x\nhb : LT.lt x b\n⊢ Membership.mem (Set.uIoo a b) x","decl":"lemma mem_uIoo_of_lt (ha : a < x) (hb : x < b) : x ∈ uIoo a b := Ioo_subset_uIoo ⟨ha, hb⟩\n\n"}
{"name":"Set.mem_uIoo_of_gt","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b x : α\nhb : LT.lt b x\nha : LT.lt x a\n⊢ Membership.mem (Set.uIoo a b) x","decl":"lemma mem_uIoo_of_gt (hb : b < x) (ha : x < a) : x ∈ uIoo a b := Ioo_subset_uIoo' ⟨hb, ha⟩\n\n"}
{"name":"Set.Ioo_min_max","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Set.Ioo (Min.min a b) (Max.max a b)) (Set.uIoo a b)","decl":"theorem Ioo_min_max : Ioo (min a b) (max a b) = uIoo a b := rfl\n\n"}
{"name":"Set.uIoo_of_not_le","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : Not (LE.le a b)\n⊢ Eq (Set.uIoo a b) (Set.Ioo b a)","decl":"lemma uIoo_of_not_le (h : ¬a ≤ b) : uIoo a b = Ioo b a := uIoo_of_gt <| lt_of_not_ge h\n\n"}
{"name":"Set.uIoo_of_not_ge","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : Not (LE.le b a)\n⊢ Eq (Set.uIoo a b) (Set.Ioo a b)","decl":"lemma uIoo_of_not_ge (h : ¬b ≤ a) : uIoo a b = Ioo a b := uIoo_of_lt <| lt_of_not_ge h\n\n"}
{"name":"Set.uIoo_subset_uIcc","module":"Mathlib.Order.Interval.Set.UnorderedInterval","initialProofState":"α : Type u_3\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.uIoo a b) (Set.uIcc a b)","decl":"theorem uIoo_subset_uIcc {α : Type*} [LinearOrder α] (a : α) (b : α) : uIoo a b ⊆ uIcc a b := by\n  simp [uIoo, uIcc, Ioo_subset_Icc_self]\n\n"}
