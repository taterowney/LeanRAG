{"name":"RingHom.ker_isRadical_iff_reduced_of_surjective","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\nS : Type u_3\nF : Type u_4\ninst✝³ : CommSemiring R\ninst✝² : CommRing S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\nhf : Function.Surjective ⇑f\n⊢ Iff (RingHom.ker f).IsRadical (IsReduced S)","decl":"theorem RingHom.ker_isRadical_iff_reduced_of_surjective {S F} [CommSemiring R] [CommRing S]\n    [FunLike F R S] [RingHomClass F R S] {f : F} (hf : Function.Surjective f) :\n    (RingHom.ker f).IsRadical ↔ IsReduced S := by\n  simp_rw [isReduced_iff, hf.forall, IsNilpotent, ← map_pow, ← RingHom.mem_ker]\n  rfl\n\n"}
{"name":"isRadical_iff_span_singleton","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\ny : R\ninst✝ : CommSemiring R\n⊢ Iff (IsRadical y) (Ideal.span (Singleton.singleton y)).IsRadical","decl":"theorem isRadical_iff_span_singleton [CommSemiring R] :\n    IsRadical y ↔ (Ideal.span ({y} : Set R)).IsRadical := by\n  simp_rw [IsRadical, ← Ideal.mem_span_singleton]\n  exact forall_swap.trans (forall_congr' fun r => exists_imp.symm)\n\n"}
{"name":"mem_nilradical","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\n⊢ Iff (Membership.mem (nilradical R) x) (IsNilpotent x)","decl":"theorem mem_nilradical : x ∈ nilradical R ↔ IsNilpotent x :=\n  Iff.rfl\n\n"}
{"name":"nilradical_eq_sInf","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq (nilradical R) (InfSet.sInf (setOf fun J => J.IsPrime))","decl":"theorem nilradical_eq_sInf (R : Type*) [CommSemiring R] :\n    nilradical R = sInf { J : Ideal R | J.IsPrime } :=\n  (Ideal.radical_eq_sInf ⊥).trans <| by simp_rw [and_iff_right bot_le]\n\n"}
{"name":"nilpotent_iff_mem_prime","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\n⊢ Iff (IsNilpotent x) (∀ (J : Ideal R), J.IsPrime → Membership.mem J x)","decl":"theorem nilpotent_iff_mem_prime : IsNilpotent x ↔ ∀ J : Ideal R, J.IsPrime → x ∈ J := by\n  rw [← mem_nilradical, nilradical_eq_sInf, Submodule.mem_sInf]\n  rfl\n\n"}
{"name":"nilradical_le_prime","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nJ : Ideal R\nH : J.IsPrime\n⊢ LE.le (nilradical R) J","decl":"theorem nilradical_le_prime (J : Ideal R) [H : J.IsPrime] : nilradical R ≤ J :=\n  (nilradical_eq_sInf R).symm ▸ sInf_le H\n\n"}
{"name":"nilradical_eq_zero","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : IsReduced R\n⊢ Eq (nilradical R) 0","decl":"@[simp]\ntheorem nilradical_eq_zero (R : Type*) [CommSemiring R] [IsReduced R] : nilradical R = 0 :=\n  Ideal.ext fun _ => isNilpotent_iff_eq_zero\n\n"}
{"name":"LinearMap.isNilpotent_mulLeft_iff","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : A\n⊢ Iff (IsNilpotent (LinearMap.mulLeft R a)) (IsNilpotent a)","decl":"@[simp]\ntheorem isNilpotent_mulLeft_iff (a : A) : IsNilpotent (mulLeft R a) ↔ IsNilpotent a := by\n  constructor <;> rintro ⟨n, hn⟩ <;> use n <;>\n      simp only [mulLeft_eq_zero_iff, pow_mulLeft] at hn ⊢ <;>\n    exact hn\n\n"}
{"name":"LinearMap.isNilpotent_mulRight_iff","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\nA : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : A\n⊢ Iff (IsNilpotent (LinearMap.mulRight R a)) (IsNilpotent a)","decl":"@[simp]\ntheorem isNilpotent_mulRight_iff (a : A) : IsNilpotent (mulRight R a) ↔ IsNilpotent a := by\n  constructor <;> rintro ⟨n, hn⟩ <;> use n <;>\n      simp only [mulRight_eq_zero_iff, pow_mulRight] at hn ⊢ <;>\n    exact hn\n\n"}
{"name":"LinearMap.isNilpotent_toMatrix_iff","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nι : Type u_3\nM : Type u_4\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nf : LinearMap (RingHom.id R) M M\n⊢ Iff (IsNilpotent ((LinearMap.toMatrix b b) f)) (IsNilpotent f)","decl":"@[simp]\nlemma isNilpotent_toMatrix_iff (b : Basis ι R M) (f : M →ₗ[R] M) :\n    IsNilpotent (toMatrix b b f) ↔ IsNilpotent f := by\n  refine exists_congr fun k ↦ ?_\n  rw [toMatrix_pow]\n  exact (toMatrix b b).map_eq_zero_iff\n\n"}
{"name":"Module.End.isNilpotent_restrict_of_le","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np q : Submodule R M\nhp : Set.MapsTo ⇑f ↑p ↑p\nhq : Set.MapsTo ⇑f ↑q ↑q\nh : LE.le p q\nhf : IsNilpotent (LinearMap.restrict f hq)\n⊢ IsNilpotent (LinearMap.restrict f hp)","decl":"lemma isNilpotent_restrict_of_le {f : End R M} {p q : Submodule R M}\n    {hp : MapsTo f p p} {hq : MapsTo f q q} (h : p ≤ q) (hf : IsNilpotent (f.restrict hq)) :\n    IsNilpotent (f.restrict hp) := by\n  obtain ⟨n, hn⟩ := hf\n  use n\n  ext ⟨x, hx⟩\n  replace hn := DFunLike.congr_fun hn ⟨x, h hx⟩\n  simp_rw [LinearMap.zero_apply, ZeroMemClass.coe_zero, ZeroMemClass.coe_eq_zero] at hn ⊢\n  rw [LinearMap.pow_restrict, LinearMap.restrict_apply] at hn ⊢\n  ext\n  exact (congr_arg Subtype.val hn :)\n\n"}
{"name":"Module.End.isNilpotent.restrict","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M M\np : Submodule R M\nhf : Set.MapsTo ⇑f ↑p ↑p\nhnil : IsNilpotent f\n⊢ IsNilpotent (f.restrict hf)","decl":"lemma isNilpotent.restrict\n    {f : M →ₗ[R] M} {p : Submodule R M} (hf : MapsTo f p p) (hnil : IsNilpotent f) :\n    IsNilpotent (f.restrict hf) := by\n  obtain ⟨n, hn⟩ := hnil\n  exact ⟨n, LinearMap.ext fun m ↦ by simp only [LinearMap.pow_restrict n, hn,\n    LinearMap.restrict_apply, LinearMap.zero_apply]; rfl⟩\n\n"}
{"name":"Module.End.IsNilpotent.mapQ","module":"Mathlib.RingTheory.Nilpotent.Lemmas","initialProofState":"R : Type u_1\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nhp : LE.le p (Submodule.comap f p)\nhnp : IsNilpotent f\n⊢ IsNilpotent (p.mapQ p f hp)","decl":"theorem IsNilpotent.mapQ (hnp : IsNilpotent f) : IsNilpotent (p.mapQ p f hp) := by\n  obtain ⟨k, hk⟩ := hnp\n  use k\n  simp [← p.mapQ_pow, hk]\n\n"}
