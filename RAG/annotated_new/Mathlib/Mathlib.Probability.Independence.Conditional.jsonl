{"name":"ProbabilityTheory.iCondIndepSets_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nπ : ι → Set (Set Ω)\nhπ : ∀ (i : ι) (s : Set Ω), Membership.mem (π i) s → MeasurableSet s\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.iCondIndepSets m' hm' π μ) (∀ (s : Finset ι) {f : ι → Set Ω}, (∀ (i : ι), Membership.mem s i → Membership.mem (π i) (f i)) → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Set.iInter fun i => Set.iInter fun h => f i).indicator fun ω => 1)) (s.prod fun i => MeasureTheory.condExp m' μ ((f i).indicator fun ω => 1)))","decl":"lemma iCondIndepSets_iff (π : ι → Set (Set Ω)) (hπ : ∀ i s (_hs : s ∈ π i), MeasurableSet s)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    iCondIndepSets m' hm' π μ ↔ ∀ (s : Finset ι) {f : ι → Set Ω} (_H : ∀ i, i ∈ s → f i ∈ π i),\n      μ⟦⋂ i ∈ s, f i | m'⟧ =ᵐ[μ] ∏ i ∈ s, (μ⟦f i | m'⟧) := by\n  simp only [iCondIndepSets, Kernel.iIndepSets]\n  have h_eq' : ∀ (s : Finset ι) (f : ι → Set Ω) (_H : ∀ i, i ∈ s → f i ∈ π i) i (_hi : i ∈ s),\n      (fun ω ↦ ENNReal.toReal (condExpKernel μ m' ω (f i))) =ᵐ[μ] μ⟦f i | m'⟧ :=\n    fun s f H i hi ↦ condExpKernel_ae_eq_condExp hm' (hπ i (f i) (H i hi))\n  have h_eq : ∀ (s : Finset ι) (f : ι → Set Ω) (_H : ∀ i, i ∈ s → f i ∈ π i), ∀ᵐ ω ∂μ,\n      ∀ i ∈ s, ENNReal.toReal (condExpKernel μ m' ω (f i)) = (μ⟦f i | m'⟧) ω := by\n    intros s f H\n    simp_rw [← Finset.mem_coe]\n    rw [ae_ball_iff (Finset.countable_toSet s)]\n    exact h_eq' s f H\n  have h_inter_eq : ∀ (s : Finset ι) (f : ι → Set Ω) (_H : ∀ i, i ∈ s → f i ∈ π i),\n      (fun ω ↦ ENNReal.toReal (condExpKernel μ m' ω (⋂ i ∈ s, f i)))\n        =ᵐ[μ] μ⟦⋂ i ∈ s, f i | m'⟧ := by\n    refine fun s f H ↦ condExpKernel_ae_eq_condExp hm' ?_\n    exact MeasurableSet.biInter (Finset.countable_toSet _) (fun i hi ↦ hπ i _ (H i hi))\n  refine ⟨fun h s f hf ↦ ?_, fun h s f hf ↦ ?_⟩ <;> specialize h s hf\n  · have h' := ae_eq_of_ae_eq_trim h\n    filter_upwards [h_eq s f hf, h_inter_eq s f hf, h'] with ω h_eq h_inter_eq h'\n    rw [← h_inter_eq, h', ENNReal.toReal_prod, Finset.prod_apply]\n    exact Finset.prod_congr rfl h_eq\n  · refine ((stronglyMeasurable_condExpKernel ?_).ae_eq_trim_iff hm' ?_).mpr ?_\n    · exact .biInter (Finset.countable_toSet _) (fun i hi ↦ hπ i _ (hf i hi))\n    · refine Measurable.stronglyMeasurable ?_\n      exact Finset.measurable_prod s (fun i hi ↦ measurable_condExpKernel (hπ i _ (hf i hi)))\n    filter_upwards [h_eq s f hf, h_inter_eq s f hf, h] with ω h_eq h_inter_eq h\n    have h_ne_top : condExpKernel μ m' ω (⋂ i ∈ s, f i) ≠ ∞ :=\n      (measure_ne_top (condExpKernel μ m' ω) _)\n    have : (∏ i ∈ s, condExpKernel μ m' ω (f i)) ≠ ∞ :=\n      ENNReal.prod_ne_top fun _ _ ↦ measure_ne_top (condExpKernel μ m' ω) _\n    rw [← ENNReal.ofReal_toReal h_ne_top, h_inter_eq, h, Finset.prod_apply,\n      ← ENNReal.ofReal_toReal this, ENNReal.toReal_prod]\n    congr 1\n    exact Finset.prod_congr rfl (fun i hi ↦ (h_eq i hi).symm)\n\n"}
{"name":"ProbabilityTheory.condIndepSets_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\ns1 s2 : Set (Set Ω)\nhs1 : ∀ (s : Set Ω), Membership.mem s1 s → MeasurableSet s\nhs2 : ∀ (s : Set Ω), Membership.mem s2 s → MeasurableSet s\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.CondIndepSets m' hm' s1 s2 μ) (∀ (t1 t2 : Set Ω), Membership.mem s1 t1 → Membership.mem s2 t2 → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Inter.inter t1 t2).indicator fun ω => 1)) (HMul.hMul (MeasureTheory.condExp m' μ (t1.indicator fun ω => 1)) (MeasureTheory.condExp m' μ (t2.indicator fun ω => 1))))","decl":"lemma condIndepSets_iff (s1 s2 : Set (Set Ω)) (hs1 : ∀ s ∈ s1, MeasurableSet s)\n    (hs2 : ∀ s ∈ s2, MeasurableSet s) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    CondIndepSets m' hm' s1 s2 μ ↔ ∀ (t1 t2 : Set Ω) (_ : t1 ∈ s1) (_ : t2 ∈ s2),\n      (μ⟦t1 ∩ t2 | m'⟧) =ᵐ[μ] (μ⟦t1 | m'⟧) * (μ⟦t2 | m'⟧) := by\n  simp only [CondIndepSets, Kernel.IndepSets]\n  have hs1_eq : ∀ s ∈ s1, (fun ω ↦ ENNReal.toReal (condExpKernel μ m' ω s)) =ᵐ[μ] μ⟦s | m'⟧ :=\n    fun s hs ↦ condExpKernel_ae_eq_condExp hm' (hs1 s hs)\n  have hs2_eq : ∀ s ∈ s2, (fun ω ↦ ENNReal.toReal (condExpKernel μ m' ω s)) =ᵐ[μ] μ⟦s | m'⟧ :=\n    fun s hs ↦ condExpKernel_ae_eq_condExp hm' (hs2 s hs)\n  have hs12_eq : ∀ s ∈ s1, ∀ t ∈ s2, (fun ω ↦ ENNReal.toReal (condExpKernel μ m' ω (s ∩ t)))\n      =ᵐ[μ] μ⟦s ∩ t | m'⟧ :=\n    fun s hs t ht ↦ condExpKernel_ae_eq_condExp hm' ((hs1 s hs).inter ((hs2 t ht)))\n  refine ⟨fun h s t hs ht ↦ ?_, fun h s t hs ht ↦ ?_⟩ <;> specialize h s t hs ht\n  · have h' := ae_eq_of_ae_eq_trim h\n    filter_upwards [hs1_eq s hs, hs2_eq t ht, hs12_eq s hs t ht, h'] with ω hs_eq ht_eq hst_eq h'\n    rw [← hst_eq, Pi.mul_apply, ← hs_eq, ← ht_eq, h', ENNReal.toReal_mul]\n  · refine ((stronglyMeasurable_condExpKernel ((hs1 s hs).inter (hs2 t ht))).ae_eq_trim_iff hm'\n      ((measurable_condExpKernel (hs1 s hs)).mul\n        (measurable_condExpKernel (hs2 t ht))).stronglyMeasurable).mpr ?_\n    filter_upwards [hs1_eq s hs, hs2_eq t ht, hs12_eq s hs t ht, h] with ω hs_eq ht_eq hst_eq h\n    have h_ne_top : condExpKernel μ m' ω (s ∩ t) ≠ ∞ := measure_ne_top (condExpKernel μ m' ω) _\n    rw [← ENNReal.ofReal_toReal h_ne_top, hst_eq, h, Pi.mul_apply, ← hs_eq, ← ht_eq,\n      ← ENNReal.toReal_mul, ENNReal.ofReal_toReal]\n    exact ENNReal.mul_ne_top (measure_ne_top (condExpKernel μ m' ω) s)\n      (measure_ne_top (condExpKernel μ m' ω) t)\n\n"}
{"name":"ProbabilityTheory.iCondIndepSets_singleton_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\ns : ι → Set Ω\nhπ : ∀ (i : ι), MeasurableSet (s i)\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.iCondIndepSets m' hm' (fun i => Singleton.singleton (s i)) μ) (∀ (S : Finset ι), (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Set.iInter fun i => Set.iInter fun h => s i).indicator fun ω => 1)) (S.prod fun i => MeasureTheory.condExp m' μ ((s i).indicator fun ω => 1)))","decl":"lemma iCondIndepSets_singleton_iff (s : ι → Set Ω) (hπ : ∀ i, MeasurableSet (s i))\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    iCondIndepSets m' hm' (fun i ↦ {s i}) μ ↔ ∀ S : Finset ι,\n      μ⟦⋂ i ∈ S, s i | m'⟧ =ᵐ[μ] ∏ i ∈ S, (μ⟦s i | m'⟧) := by\n  rw [iCondIndepSets_iff]\n  · simp only [Set.mem_singleton_iff]\n    refine ⟨fun h S ↦ h S (fun i _ ↦ rfl), fun h S f hf ↦ ?_⟩\n    filter_upwards [h S] with a ha\n    refine Eq.trans ?_ (ha.trans ?_)\n    · congr\n      apply congr_arg₂\n      · exact Set.iInter₂_congr hf\n      · rfl\n    · simp_rw [Finset.prod_apply]\n      refine Finset.prod_congr rfl (fun i hi ↦ ?_)\n      rw [hf i hi]\n  · simpa only [Set.mem_singleton_iff, forall_eq]\n\n"}
{"name":"ProbabilityTheory.condIndepSets_singleton_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns t : Set Ω\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ Iff (ProbabilityTheory.CondIndepSets m' hm' (Singleton.singleton s) (Singleton.singleton t) μ) ((MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Inter.inter s t).indicator fun ω => 1)) (HMul.hMul (MeasureTheory.condExp m' μ (s.indicator fun ω => 1)) (MeasureTheory.condExp m' μ (t.indicator fun ω => 1))))","decl":"theorem condIndepSets_singleton_iff {μ : Measure Ω} [IsFiniteMeasure μ]\n    {s t : Set Ω} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    CondIndepSets m' hm' {s} {t} μ ↔ (μ⟦s ∩ t | m'⟧) =ᵐ[μ] (μ⟦s | m'⟧) * (μ⟦t | m'⟧) := by\n  rw [condIndepSets_iff _ _ _ _ ?_ ?_]\n  · simp only [Set.mem_singleton_iff, forall_eq_apply_imp_iff, forall_eq]\n  · intros s' hs'\n    rw [Set.mem_singleton_iff] at hs'\n    rwa [hs']\n  · intros s' hs'\n    rw [Set.mem_singleton_iff] at hs'\n    rwa [hs']\n\n"}
{"name":"ProbabilityTheory.iCondIndep_iff_iCondIndepSets","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nm : ι → MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.iCondIndep m' hm' m μ) (ProbabilityTheory.iCondIndepSets m' hm' (fun x => setOf fun s => MeasurableSet s) μ)","decl":"lemma iCondIndep_iff_iCondIndepSets (m : ι → MeasurableSpace Ω)\n    (μ : @Measure Ω mΩ) [IsFiniteMeasure μ] :\n    iCondIndep m' hm' m μ ↔ iCondIndepSets m' hm' (fun x ↦ {s | MeasurableSet[m x] s}) μ := by\n  simp only [iCondIndep, iCondIndepSets, Kernel.iIndep]\n\n"}
{"name":"ProbabilityTheory.iCondIndep_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nm : ι → MeasurableSpace Ω\nhm : ∀ (i : ι), LE.le (m i) mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.iCondIndep m' hm' m μ) (∀ (s : Finset ι) {f : ι → Set Ω}, (∀ (i : ι), Membership.mem s i → MeasurableSet (f i)) → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Set.iInter fun i => Set.iInter fun h => f i).indicator fun ω => 1)) (s.prod fun i => MeasureTheory.condExp m' μ ((f i).indicator fun ω => 1)))","decl":"lemma iCondIndep_iff (m : ι → MeasurableSpace Ω) (hm : ∀ i, m i ≤ mΩ)\n    (μ : @Measure Ω mΩ) [IsFiniteMeasure μ] :\n    iCondIndep m' hm' m μ\n      ↔ ∀ (s : Finset ι) {f : ι → Set Ω} (_H : ∀ i, i ∈ s → MeasurableSet[m i] (f i)),\n      μ⟦⋂ i ∈ s, f i | m'⟧ =ᵐ[μ] ∏ i ∈ s, (μ⟦f i | m'⟧) := by\n  rw [iCondIndep_iff_iCondIndepSets, iCondIndepSets_iff]\n  · rfl\n  · exact hm\n\n"}
{"name":"ProbabilityTheory.condIndep_iff_condIndepSets","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' m₁ m₂ mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.CondIndep m' m₁ m₂ hm' μ) (ProbabilityTheory.CondIndepSets m' hm' (setOf fun s => MeasurableSet s) (setOf fun s => MeasurableSet s) μ)","decl":"lemma condIndep_iff_condIndepSets (m' m₁ m₂ : MeasurableSpace Ω) {mΩ : MeasurableSpace Ω}\n    [StandardBorelSpace Ω] (hm' : m' ≤ mΩ) (μ : Measure Ω ) [IsFiniteMeasure μ] :\n    CondIndep m' m₁ m₂ hm' μ\n      ↔ CondIndepSets m' hm' {s | MeasurableSet[m₁] s} {s | MeasurableSet[m₂] s} μ := by\n  simp only [CondIndep, CondIndepSets, Kernel.Indep]\n\n"}
{"name":"ProbabilityTheory.condIndep_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' m₁ m₂ mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nhm₁ : LE.le m₁ mΩ\nhm₂ : LE.le m₂ mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.CondIndep m' m₁ m₂ hm' μ) (∀ (t1 t2 : Set Ω), MeasurableSet t1 → MeasurableSet t2 → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Inter.inter t1 t2).indicator fun ω => 1)) (HMul.hMul (MeasureTheory.condExp m' μ (t1.indicator fun ω => 1)) (MeasureTheory.condExp m' μ (t2.indicator fun ω => 1))))","decl":"lemma condIndep_iff (m' m₁ m₂ : MeasurableSpace Ω)\n    {mΩ : MeasurableSpace Ω} [StandardBorelSpace Ω]\n    (hm' : m' ≤ mΩ) (hm₁ : m₁ ≤ mΩ) (hm₂ : m₂ ≤ mΩ) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    CondIndep m' m₁ m₂ hm' μ\n      ↔ ∀ t1 t2, MeasurableSet[m₁] t1 → MeasurableSet[m₂] t2\n        → (μ⟦t1 ∩ t2 | m'⟧) =ᵐ[μ] (μ⟦t1 | m'⟧) * (μ⟦t2 | m'⟧) := by\n  rw [condIndep_iff_condIndepSets, condIndepSets_iff]\n  · rfl\n  · exact hm₁\n  · exact hm₂\n\n"}
{"name":"ProbabilityTheory.iCondIndepSet_iff_iCondIndep","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\ns : ι → Set Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.iCondIndepSet m' hm' s μ) (ProbabilityTheory.iCondIndep m' hm' (fun i => MeasurableSpace.generateFrom (Singleton.singleton (s i))) μ)","decl":"lemma iCondIndepSet_iff_iCondIndep (s : ι → Set Ω) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    iCondIndepSet m' hm' s μ ↔ iCondIndep m' hm' (fun i ↦ generateFrom {s i}) μ := by\n  simp only [iCondIndepSet, iCondIndep, Kernel.iIndepSet]\n\n"}
{"name":"ProbabilityTheory.iCondIndepSet_iff_iCondIndepSets_singleton","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\ns : ι → Set Ω\nhs : ∀ (i : ι), MeasurableSet (s i)\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.iCondIndepSet m' hm' s μ) (ProbabilityTheory.iCondIndepSets m' hm' (fun i => Singleton.singleton (s i)) μ)","decl":"theorem iCondIndepSet_iff_iCondIndepSets_singleton (s : ι → Set Ω) (hs : ∀ i, MeasurableSet (s i))\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    iCondIndepSet m' hm' s μ ↔ iCondIndepSets m' hm' (fun i ↦ {s i}) μ :=\n  Kernel.iIndepSet_iff_iIndepSets_singleton hs\n\n"}
{"name":"ProbabilityTheory.iCondIndepSet_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\ns : ι → Set Ω\nhs : ∀ (i : ι), MeasurableSet (s i)\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.iCondIndepSet m' hm' s μ) (∀ (S : Finset ι), (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Set.iInter fun i => Set.iInter fun h => s i).indicator fun ω => 1)) (S.prod fun i => MeasureTheory.condExp m' μ ((s i).indicator fun ω => 1)))","decl":"lemma iCondIndepSet_iff (s : ι → Set Ω) (hs : ∀ i, MeasurableSet (s i))\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    iCondIndepSet m' hm' s μ ↔\n      ∀ S : Finset ι, μ⟦⋂ i ∈ S, s i | m'⟧ =ᵐ[μ] ∏ i ∈ S, μ⟦s i | m'⟧ := by\n  rw [iCondIndepSet_iff_iCondIndepSets_singleton _ _ _ hs, iCondIndepSets_singleton_iff _ _ _ hs]\n\n"}
{"name":"ProbabilityTheory.condIndepSet_iff_condIndep","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\ns t : Set Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.CondIndepSet m' hm' s t μ) (ProbabilityTheory.CondIndep m' (MeasurableSpace.generateFrom (Singleton.singleton s)) (MeasurableSpace.generateFrom (Singleton.singleton t)) hm' μ)","decl":"lemma condIndepSet_iff_condIndep (s t : Set Ω) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    CondIndepSet m' hm' s t μ ↔ CondIndep m' (generateFrom {s}) (generateFrom {t}) hm' μ := by\n  simp only [CondIndepSet, CondIndep, Kernel.IndepSet]\n\n"}
{"name":"ProbabilityTheory.condIndepSet_iff_condIndepSets_singleton","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\ns t : Set Ω\nhs_meas : MeasurableSet s\nht_meas : MeasurableSet t\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.CondIndepSet m' hm' s t μ) (ProbabilityTheory.CondIndepSets m' hm' (Singleton.singleton s) (Singleton.singleton t) μ)","decl":"theorem condIndepSet_iff_condIndepSets_singleton {s t : Set Ω} (hs_meas : MeasurableSet s)\n    (ht_meas : MeasurableSet t) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    CondIndepSet m' hm' s t μ ↔ CondIndepSets m' hm' {s} {t} μ :=\n  Kernel.indepSet_iff_indepSets_singleton hs_meas ht_meas _ _\n\n"}
{"name":"ProbabilityTheory.condIndepSet_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\ns t : Set Ω\nhs : MeasurableSet s\nht : MeasurableSet t\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.CondIndepSet m' hm' s t μ) ((MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Inter.inter s t).indicator fun ω => 1)) (HMul.hMul (MeasureTheory.condExp m' μ (s.indicator fun ω => 1)) (MeasureTheory.condExp m' μ (t.indicator fun ω => 1))))","decl":"lemma condIndepSet_iff (s t : Set Ω) (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    CondIndepSet m' hm' s t μ ↔ (μ⟦s ∩ t | m'⟧) =ᵐ[μ] (μ⟦s | m'⟧) * (μ⟦t | m'⟧) := by\n  rw [condIndepSet_iff_condIndepSets_singleton _ _ hs ht μ, condIndepSets_singleton_iff _ _ hs ht]\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun_iff_iCondIndep","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nβ : ι → Type u_3\nm : (x : ι) → MeasurableSpace (β x)\nf : (x : ι) → Ω → β x\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.iCondIndepFun m' hm' m f μ) (ProbabilityTheory.iCondIndep m' hm' (fun x => MeasurableSpace.comap (f x) (m x)) μ)","decl":"lemma iCondIndepFun_iff_iCondIndep {β : ι → Type*}\n    (m : ∀ x : ι, MeasurableSpace (β x)) (f : ∀ x : ι, Ω → β x)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    iCondIndepFun m' hm' m f μ\n      ↔ iCondIndep m' hm' (fun x ↦ MeasurableSpace.comap (f x) (m x)) μ := by\n  simp only [iCondIndepFun, iCondIndep, Kernel.iIndepFun]\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nβ : ι → Type u_3\nm : (x : ι) → MeasurableSpace (β x)\nf : (x : ι) → Ω → β x\nhf : ∀ (i : ι), Measurable (f i)\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.iCondIndepFun m' hm' m f μ) (∀ (s : Finset ι) {g : ι → Set Ω}, (∀ (i : ι), Membership.mem s i → MeasurableSet (g i)) → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Set.iInter fun i => Set.iInter fun h => g i).indicator fun ω => 1)) (s.prod fun i => MeasureTheory.condExp m' μ ((g i).indicator fun ω => 1)))","decl":"lemma iCondIndepFun_iff {β : ι → Type*}\n    (m : ∀ x : ι, MeasurableSpace (β x)) (f : ∀ x : ι, Ω → β x) (hf : ∀ i, Measurable (f i))\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    iCondIndepFun m' hm' m f μ\n      ↔ ∀ (s : Finset ι) {g : ι → Set Ω} (_H : ∀ i, i ∈ s → MeasurableSet[(m i).comap (f i)] (g i)),\n      μ⟦⋂ i ∈ s, g i | m'⟧ =ᵐ[μ] ∏ i ∈ s, (μ⟦g i | m'⟧) := by\n  simp only [iCondIndepFun_iff_iCondIndep]\n  rw [iCondIndep_iff]\n  exact fun i ↦ (hf i).comap_le\n\n"}
{"name":"ProbabilityTheory.condIndepFun_iff_condIndep","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nβ : Type u_3\nγ : Type u_4\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : Ω → β\ng : Ω → γ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.CondIndepFun m' hm' f g μ) (ProbabilityTheory.CondIndep m' (MeasurableSpace.comap f mβ) (MeasurableSpace.comap g mγ) hm' μ)","decl":"lemma condIndepFun_iff_condIndep {β γ : Type*} [mβ : MeasurableSpace β]\n    [mγ : MeasurableSpace γ] (f : Ω → β) (g : Ω → γ) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    CondIndepFun m' hm' f g μ\n      ↔ CondIndep m' (MeasurableSpace.comap f mβ) (MeasurableSpace.comap g mγ) hm' μ := by\n  simp only [CondIndepFun, CondIndep, Kernel.IndepFun]\n\n"}
{"name":"ProbabilityTheory.condIndepFun_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nβ : Type u_3\nγ : Type u_4\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : Ω → β\ng : Ω → γ\nhf : Measurable f\nhg : Measurable g\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.CondIndepFun m' hm' f g μ) (∀ (t1 t2 : Set Ω), MeasurableSet t1 → MeasurableSet t2 → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Inter.inter t1 t2).indicator fun ω => 1)) (HMul.hMul (MeasureTheory.condExp m' μ (t1.indicator fun ω => 1)) (MeasureTheory.condExp m' μ (t2.indicator fun ω => 1))))","decl":"lemma condIndepFun_iff {β γ : Type*} [mβ : MeasurableSpace β] [mγ : MeasurableSpace γ]\n    (f : Ω → β) (g : Ω → γ) (hf : Measurable f) (hg : Measurable g)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    CondIndepFun m' hm' f g μ ↔ ∀ t1 t2, MeasurableSet[MeasurableSpace.comap f mβ] t1\n      → MeasurableSet[MeasurableSpace.comap g mγ] t2\n        → (μ⟦t1 ∩ t2 | m'⟧) =ᵐ[μ] (μ⟦t1 | m'⟧) * (μ⟦t2 | m'⟧) := by\n  rw [condIndepFun_iff_condIndep, condIndep_iff _ _ _ _ hf.comap_le hg.comap_le]\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.symm","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns₁ s₂ : Set (Set Ω)\nh : ProbabilityTheory.CondIndepSets m' hm' s₁ s₂ μ\n⊢ ProbabilityTheory.CondIndepSets m' hm' s₂ s₁ μ","decl":"@[symm]\ntheorem CondIndepSets.symm {s₁ s₂ : Set (Set Ω)}\n    (h : CondIndepSets m' hm' s₁ s₂ μ) : CondIndepSets m' hm' s₂ s₁ μ :=\n  Kernel.IndepSets.symm h\n\n"}
{"name":"ProbabilityTheory.condIndepSets_of_condIndepSets_of_le_left","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns₁ s₂ s₃ : Set (Set Ω)\nh_indep : ProbabilityTheory.CondIndepSets m' hm' s₁ s₂ μ\nh31 : HasSubset.Subset s₃ s₁\n⊢ ProbabilityTheory.CondIndepSets m' hm' s₃ s₂ μ","decl":"theorem condIndepSets_of_condIndepSets_of_le_left {s₁ s₂ s₃ : Set (Set Ω)}\n    (h_indep : CondIndepSets m' hm' s₁ s₂ μ) (h31 : s₃ ⊆ s₁) :\n    CondIndepSets m' hm' s₃ s₂ μ :=\n  Kernel.indepSets_of_indepSets_of_le_left h_indep h31\n\n"}
{"name":"ProbabilityTheory.condIndepSets_of_condIndepSets_of_le_right","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns₁ s₂ s₃ : Set (Set Ω)\nh_indep : ProbabilityTheory.CondIndepSets m' hm' s₁ s₂ μ\nh32 : HasSubset.Subset s₃ s₂\n⊢ ProbabilityTheory.CondIndepSets m' hm' s₁ s₃ μ","decl":"theorem condIndepSets_of_condIndepSets_of_le_right {s₁ s₂ s₃ : Set (Set Ω)}\n    (h_indep : CondIndepSets m' hm' s₁ s₂ μ) (h32 : s₃ ⊆ s₂) :\n    CondIndepSets m' hm' s₁ s₃ μ :=\n  Kernel.indepSets_of_indepSets_of_le_right h_indep h32\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.union","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns₁ s₂ s' : Set (Set Ω)\nh₁ : ProbabilityTheory.CondIndepSets m' hm' s₁ s' μ\nh₂ : ProbabilityTheory.CondIndepSets m' hm' s₂ s' μ\n⊢ ProbabilityTheory.CondIndepSets m' hm' (Union.union s₁ s₂) s' μ","decl":"theorem CondIndepSets.union {s₁ s₂ s' : Set (Set Ω)}\n    (h₁ : CondIndepSets m' hm' s₁ s' μ) (h₂ : CondIndepSets m' hm' s₂ s' μ) :\n    CondIndepSets m' hm' (s₁ ∪ s₂) s' μ :=\n  Kernel.IndepSets.union h₁ h₂\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.union_iff","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns₁ s₂ s' : Set (Set Ω)\n⊢ Iff (ProbabilityTheory.CondIndepSets m' hm' (Union.union s₁ s₂) s' μ) (And (ProbabilityTheory.CondIndepSets m' hm' s₁ s' μ) (ProbabilityTheory.CondIndepSets m' hm' s₂ s' μ))","decl":"@[simp]\ntheorem CondIndepSets.union_iff {s₁ s₂ s' : Set (Set Ω)}  :\n    CondIndepSets m' hm' (s₁ ∪ s₂) s' μ\n      ↔ CondIndepSets m' hm' s₁ s' μ ∧ CondIndepSets m' hm' s₂ s' μ :=\n  Kernel.IndepSets.union_iff\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.iUnion","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : ι → Set (Set Ω)\ns' : Set (Set Ω)\nhyp : ∀ (n : ι), ProbabilityTheory.CondIndepSets m' hm' (s n) s' μ\n⊢ ProbabilityTheory.CondIndepSets m' hm' (Set.iUnion fun n => s n) s' μ","decl":"theorem CondIndepSets.iUnion {s : ι → Set (Set Ω)} {s' : Set (Set Ω)}\n    (hyp : ∀ n, CondIndepSets m' hm' (s n) s' μ) :\n    CondIndepSets m' hm' (⋃ n, s n) s' μ :=\n  Kernel.IndepSets.iUnion hyp\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.bUnion","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : ι → Set (Set Ω)\ns' : Set (Set Ω)\nu : Set ι\nhyp : ∀ (n : ι), Membership.mem u n → ProbabilityTheory.CondIndepSets m' hm' (s n) s' μ\n⊢ ProbabilityTheory.CondIndepSets m' hm' (Set.iUnion fun n => Set.iUnion fun h => s n) s' μ","decl":"theorem CondIndepSets.bUnion {s : ι → Set (Set Ω)} {s' : Set (Set Ω)}\n    {u : Set ι} (hyp : ∀ n ∈ u, CondIndepSets m' hm' (s n) s' μ) :\n    CondIndepSets m' hm' (⋃ n ∈ u, s n) s' μ :=\n  Kernel.IndepSets.bUnion hyp\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.inter","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns₁ s' s₂ : Set (Set Ω)\nh₁ : ProbabilityTheory.CondIndepSets m' hm' s₁ s' μ\n⊢ ProbabilityTheory.CondIndepSets m' hm' (Inter.inter s₁ s₂) s' μ","decl":"theorem CondIndepSets.inter {s₁ s' : Set (Set Ω)} (s₂ : Set (Set Ω))\n    (h₁ : CondIndepSets m' hm' s₁ s' μ) :\n    CondIndepSets m' hm' (s₁ ∩ s₂) s' μ :=\n  Kernel.IndepSets.inter s₂ h₁\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.iInter","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : ι → Set (Set Ω)\ns' : Set (Set Ω)\nh : Exists fun n => ProbabilityTheory.CondIndepSets m' hm' (s n) s' μ\n⊢ ProbabilityTheory.CondIndepSets m' hm' (Set.iInter fun n => s n) s' μ","decl":"theorem CondIndepSets.iInter {s : ι → Set (Set Ω)} {s' : Set (Set Ω)}\n    (h : ∃ n, CondIndepSets m' hm' (s n) s' μ) :\n    CondIndepSets m' hm' (⋂ n, s n) s' μ :=\n  Kernel.IndepSets.iInter h\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.bInter","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : ι → Set (Set Ω)\ns' : Set (Set Ω)\nu : Set ι\nh : Exists fun n => And (Membership.mem u n) (ProbabilityTheory.CondIndepSets m' hm' (s n) s' μ)\n⊢ ProbabilityTheory.CondIndepSets m' hm' (Set.iInter fun n => Set.iInter fun h => s n) s' μ","decl":"theorem CondIndepSets.bInter {s : ι → Set (Set Ω)} {s' : Set (Set Ω)}\n    {u : Set ι} (h : ∃ n ∈ u, CondIndepSets m' hm' (s n) s' μ) :\n    CondIndepSets m' hm' (⋂ n ∈ u, s n) s' μ :=\n  Kernel.IndepSets.bInter h\n\n"}
{"name":"ProbabilityTheory.condIndepSet_empty_right","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\n⊢ ProbabilityTheory.CondIndepSet m' hm' s EmptyCollection.emptyCollection μ","decl":"theorem condIndepSet_empty_right (s : Set Ω) : CondIndepSet m' hm' s ∅ μ :=\n  Kernel.indepSet_empty_right s\n\n"}
{"name":"ProbabilityTheory.condIndepSet_empty_left","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set Ω\n⊢ ProbabilityTheory.CondIndepSet m' hm' EmptyCollection.emptyCollection s μ","decl":"theorem condIndepSet_empty_left (s : Set Ω) : CondIndepSet m' hm' ∅ s μ :=\n  Kernel.indepSet_empty_left s\n\n"}
{"name":"ProbabilityTheory.CondIndep.symm","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' m₁ m₂ mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : ProbabilityTheory.CondIndep m' m₁ m₂ hm' μ\n⊢ ProbabilityTheory.CondIndep m' m₂ m₁ hm' μ","decl":"@[symm]\ntheorem CondIndep.symm {m' m₁ m₂ : MeasurableSpace Ω} {mΩ : MeasurableSpace Ω}\n    [StandardBorelSpace Ω] {hm' : m' ≤ mΩ} {μ : Measure Ω} [IsFiniteMeasure μ]\n    (h : CondIndep m' m₁ m₂ hm' μ) :\n    CondIndep m' m₂ m₁ hm' μ :=\n  CondIndepSets.symm h\n\n"}
{"name":"ProbabilityTheory.condIndep_bot_right","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm₁ m' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ ProbabilityTheory.CondIndep m' m₁ Bot.bot hm' μ","decl":"theorem condIndep_bot_right (m₁ : MeasurableSpace Ω) {m' : MeasurableSpace Ω}\n    {mΩ : MeasurableSpace Ω} [StandardBorelSpace Ω]\n    {hm' : m' ≤ mΩ} {μ : Measure Ω} [IsFiniteMeasure μ] :\n    CondIndep m' m₁ ⊥ hm' μ :=\n  Kernel.indep_bot_right m₁\n\n"}
{"name":"ProbabilityTheory.condIndep_bot_left","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm₁ m' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ ProbabilityTheory.CondIndep m' Bot.bot m₁ hm' μ","decl":"theorem condIndep_bot_left (m₁ : MeasurableSpace Ω) {m' : MeasurableSpace Ω}\n    {mΩ : MeasurableSpace Ω} [StandardBorelSpace Ω]\n    {hm' : m' ≤ mΩ} {μ : Measure Ω} [IsFiniteMeasure μ] :\n    CondIndep m' ⊥ m₁ hm' μ :=\n  (Kernel.indep_bot_right m₁).symm\n\n"}
{"name":"ProbabilityTheory.condIndep_of_condIndep_of_le_left","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' m₁ m₂ m₃ mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh_indep : ProbabilityTheory.CondIndep m' m₁ m₂ hm' μ\nh31 : LE.le m₃ m₁\n⊢ ProbabilityTheory.CondIndep m' m₃ m₂ hm' μ","decl":"theorem condIndep_of_condIndep_of_le_left {m' m₁ m₂ m₃ : MeasurableSpace Ω}\n    {mΩ : MeasurableSpace Ω} [StandardBorelSpace Ω]\n    {hm' : m' ≤ mΩ} {μ : Measure Ω} [IsFiniteMeasure μ]\n    (h_indep : CondIndep m' m₁ m₂ hm' μ) (h31 : m₃ ≤ m₁) :\n    CondIndep m' m₃ m₂ hm' μ :=\n  Kernel.indep_of_indep_of_le_left h_indep h31\n\n"}
{"name":"ProbabilityTheory.condIndep_of_condIndep_of_le_right","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' m₁ m₂ m₃ mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh_indep : ProbabilityTheory.CondIndep m' m₁ m₂ hm' μ\nh32 : LE.le m₃ m₂\n⊢ ProbabilityTheory.CondIndep m' m₁ m₃ hm' μ","decl":"theorem condIndep_of_condIndep_of_le_right {m' m₁ m₂ m₃ : MeasurableSpace Ω}\n    {mΩ : MeasurableSpace Ω} [StandardBorelSpace Ω]\n    {hm' : m' ≤ mΩ} {μ : Measure Ω} [IsFiniteMeasure μ]\n    (h_indep : CondIndep m' m₁ m₂ hm' μ) (h32 : m₃ ≤ m₂) :\n    CondIndep m' m₁ m₃ hm' μ :=\n  Kernel.indep_of_indep_of_le_right h_indep h32\n\n"}
{"name":"ProbabilityTheory.iCondIndepSets.condIndepSets","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : ι → Set (Set Ω)\nh_indep : ProbabilityTheory.iCondIndepSets m' hm' s μ\ni j : ι\nhij : Ne i j\n⊢ ProbabilityTheory.CondIndepSets m' hm' (s i) (s j) μ","decl":"theorem iCondIndepSets.condIndepSets {s : ι → Set (Set Ω)}\n    (h_indep : iCondIndepSets m' hm' s μ) {i j : ι} (hij : i ≠ j) :\n    CondIndepSets m' hm' (s i) (s j) μ :=\n  Kernel.iIndepSets.indepSets h_indep hij\n\n"}
{"name":"ProbabilityTheory.iCondIndep.condIndep","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nm : ι → MeasurableSpace Ω\nh_indep : ProbabilityTheory.iCondIndep m' hm' m μ\ni j : ι\nhij : Ne i j\n⊢ ProbabilityTheory.CondIndep m' (m i) (m j) hm' μ","decl":"theorem iCondIndep.condIndep {m : ι → MeasurableSpace Ω}\n    (h_indep : iCondIndep m' hm' m μ) {i j : ι} (hij : i ≠ j) :\n      CondIndep m' (m i) (m j) hm' μ :=\n  Kernel.iIndep.indep h_indep hij\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.condIndepFun","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nβ : ι → Type u_3\nm : (x : ι) → MeasurableSpace (β x)\nf : (i : ι) → Ω → β i\nhf_Indep : ProbabilityTheory.iCondIndepFun m' hm' m f μ\ni j : ι\nhij : Ne i j\n⊢ ProbabilityTheory.CondIndepFun m' hm' (f i) (f j) μ","decl":"theorem iCondIndepFun.condIndepFun {β : ι → Type*}\n    {m : ∀ x, MeasurableSpace (β x)} {f : ∀ i, Ω → β i}\n    (hf_Indep : iCondIndepFun m' hm' m f μ) {i j : ι} (hij : i ≠ j) :\n    CondIndepFun m' hm' (f i) (f j) μ :=\n  Kernel.iIndepFun.indepFun hf_Indep hij\n\n"}
{"name":"ProbabilityTheory.iCondIndep.iCondIndepSets","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nm : ι → MeasurableSpace Ω\ns : ι → Set (Set Ω)\nhms : ∀ (n : ι), Eq (m n) (MeasurableSpace.generateFrom (s n))\nh_indep : ProbabilityTheory.iCondIndep m' hm' m μ\n⊢ ProbabilityTheory.iCondIndepSets m' hm' s μ","decl":"theorem iCondIndep.iCondIndepSets {m : ι → MeasurableSpace Ω}\n    {s : ι → Set (Set Ω)} (hms : ∀ n, m n = generateFrom (s n))\n    (h_indep : iCondIndep m' hm' m μ) :\n    iCondIndepSets m' hm' s μ :=\n  Kernel.iIndep.iIndepSets hms h_indep\n\n"}
{"name":"ProbabilityTheory.CondIndep.condIndepSets","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns1 s2 : Set (Set Ω)\nh_indep : ProbabilityTheory.CondIndep m' (MeasurableSpace.generateFrom s1) (MeasurableSpace.generateFrom s2) hm' μ\n⊢ ProbabilityTheory.CondIndepSets m' hm' s1 s2 μ","decl":"theorem CondIndep.condIndepSets {s1 s2 : Set (Set Ω)}\n    (h_indep : CondIndep m' (generateFrom s1) (generateFrom s2) hm' μ) :\n    CondIndepSets m' hm' s1 s2 μ :=\n  Kernel.Indep.indepSets h_indep\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.condIndep","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' m₁ m₂ mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\np1 p2 : Set (Set Ω)\nh1 : LE.le m₁ mΩ\nh2 : LE.le m₂ mΩ\nhp1 : IsPiSystem p1\nhp2 : IsPiSystem p2\nhpm1 : Eq m₁ (MeasurableSpace.generateFrom p1)\nhpm2 : Eq m₂ (MeasurableSpace.generateFrom p2)\nhyp : ProbabilityTheory.CondIndepSets m' hm' p1 p2 μ\n⊢ ProbabilityTheory.CondIndep m' m₁ m₂ hm' μ","decl":"theorem CondIndepSets.condIndep\n    {p1 p2 : Set (Set Ω)} (h1 : m₁ ≤ mΩ) (h2 : m₂ ≤ mΩ)\n    (hp1 : IsPiSystem p1) (hp2 : IsPiSystem p2)\n    (hpm1 : m₁ = generateFrom p1) (hpm2 : m₂ = generateFrom p2)\n    (hyp : CondIndepSets m' hm' p1 p2 μ) :\n    CondIndep m' m₁ m₂ hm' μ :=\n  Kernel.IndepSets.indep h1 h2 hp1 hp2 hpm1 hpm2 hyp\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.condIndep'","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\np1 p2 : Set (Set Ω)\nhp1m : ∀ (s : Set Ω), Membership.mem p1 s → MeasurableSet s\nhp2m : ∀ (s : Set Ω), Membership.mem p2 s → MeasurableSet s\nhp1 : IsPiSystem p1\nhp2 : IsPiSystem p2\nhyp : ProbabilityTheory.CondIndepSets m' hm' p1 p2 μ\n⊢ ProbabilityTheory.CondIndep m' (MeasurableSpace.generateFrom p1) (MeasurableSpace.generateFrom p2) hm' μ","decl":"theorem CondIndepSets.condIndep'\n    {p1 p2 : Set (Set Ω)} (hp1m : ∀ s ∈ p1, MeasurableSet s) (hp2m : ∀ s ∈ p2, MeasurableSet s)\n    (hp1 : IsPiSystem p1) (hp2 : IsPiSystem p2) (hyp : CondIndepSets m' hm' p1 p2 μ) :\n    CondIndep m' (generateFrom p1) (generateFrom p2) hm' μ :=\n  Kernel.IndepSets.indep' hp1m hp2m hp1 hp2 hyp\n\n"}
{"name":"ProbabilityTheory.condIndepSets_piiUnionInter_of_disjoint","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : ι → Set (Set Ω)\nS T : Set ι\nh_indep : ProbabilityTheory.iCondIndepSets m' hm' s μ\nhST : Disjoint S T\n⊢ ProbabilityTheory.CondIndepSets m' hm' (piiUnionInter s S) (piiUnionInter s T) μ","decl":"theorem condIndepSets_piiUnionInter_of_disjoint {s : ι → Set (Set Ω)}\n    {S T : Set ι} (h_indep : iCondIndepSets m' hm' s μ) (hST : Disjoint S T) :\n    CondIndepSets m' hm' (piiUnionInter s S) (piiUnionInter s T) μ :=\n  Kernel.indepSets_piiUnionInter_of_disjoint h_indep hST\n\n"}
{"name":"ProbabilityTheory.iCondIndepSet.condIndep_generateFrom_of_disjoint","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : ι → Set Ω\nhsm : ∀ (n : ι), MeasurableSet (s n)\nhs : ProbabilityTheory.iCondIndepSet m' hm' s μ\nS T : Set ι\nhST : Disjoint S T\n⊢ ProbabilityTheory.CondIndep m' (MeasurableSpace.generateFrom (setOf fun t => Exists fun n => And (Membership.mem S n) (Eq (s n) t))) (MeasurableSpace.generateFrom (setOf fun t => Exists fun k => And (Membership.mem T k) (Eq (s k) t))) hm' μ","decl":"theorem iCondIndepSet.condIndep_generateFrom_of_disjoint {s : ι → Set Ω}\n    (hsm : ∀ n, MeasurableSet (s n)) (hs : iCondIndepSet m' hm' s μ) (S T : Set ι)\n    (hST : Disjoint S T) :\n    CondIndep m' (generateFrom { t | ∃ n ∈ S, s n = t })\n      (generateFrom { t | ∃ k ∈ T, s k = t }) hm' μ :=\n  Kernel.iIndepSet.indep_generateFrom_of_disjoint hsm hs S T hST\n\n"}
{"name":"ProbabilityTheory.condIndep_iSup_of_disjoint","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nm : ι → MeasurableSpace Ω\nh_le : ∀ (i : ι), LE.le (m i) mΩ\nh_indep : ProbabilityTheory.iCondIndep m' hm' m μ\nS T : Set ι\nhST : Disjoint S T\n⊢ ProbabilityTheory.CondIndep m' (iSup fun i => iSup fun h => m i) (iSup fun i => iSup fun h => m i) hm' μ","decl":"theorem condIndep_iSup_of_disjoint {m : ι → MeasurableSpace Ω}\n    (h_le : ∀ i, m i ≤ mΩ) (h_indep : iCondIndep m' hm' m μ) {S T : Set ι} (hST : Disjoint S T) :\n    CondIndep m' (⨆ i ∈ S, m i) (⨆ i ∈ T, m i) hm' μ :=\n  Kernel.indep_iSup_of_disjoint h_le h_indep hST\n\n"}
{"name":"ProbabilityTheory.condIndep_iSup_of_directed_le","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' m₁ mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nm : ι → MeasurableSpace Ω\nh_indep : ∀ (i : ι), ProbabilityTheory.CondIndep m' (m i) m₁ hm' μ\nh_le : ∀ (i : ι), LE.le (m i) mΩ\nh_le' : LE.le m₁ mΩ\nhm : Directed (fun x1 x2 => LE.le x1 x2) m\n⊢ ProbabilityTheory.CondIndep m' (iSup fun i => m i) m₁ hm' μ","decl":"theorem condIndep_iSup_of_directed_le {m : ι → MeasurableSpace Ω}\n    (h_indep : ∀ i, CondIndep m' (m i) m₁ hm' μ)\n    (h_le : ∀ i, m i ≤ mΩ) (h_le' : m₁ ≤ mΩ) (hm : Directed (· ≤ ·) m) :\n    CondIndep m' (⨆ i, m i) m₁ hm' μ :=\n  Kernel.indep_iSup_of_directed_le h_indep h_le h_le' hm\n\n"}
{"name":"ProbabilityTheory.iCondIndepSet.condIndep_generateFrom_lt","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : Preorder ι\ns : ι → Set Ω\nhsm : ∀ (n : ι), MeasurableSet (s n)\nhs : ProbabilityTheory.iCondIndepSet m' hm' s μ\ni : ι\n⊢ ProbabilityTheory.CondIndep m' (MeasurableSpace.generateFrom (Singleton.singleton (s i))) (MeasurableSpace.generateFrom (setOf fun t => Exists fun j => And (LT.lt j i) (Eq (s j) t))) hm' μ","decl":"theorem iCondIndepSet.condIndep_generateFrom_lt [Preorder ι] {s : ι → Set Ω}\n    (hsm : ∀ n, MeasurableSet (s n)) (hs : iCondIndepSet m' hm' s μ) (i : ι) :\n    CondIndep m' (generateFrom {s i}) (generateFrom { t | ∃ j < i, s j = t }) hm' μ :=\n  Kernel.iIndepSet.indep_generateFrom_lt hsm hs i\n\n"}
{"name":"ProbabilityTheory.iCondIndepSet.condIndep_generateFrom_le","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : LinearOrder ι\ns : ι → Set Ω\nhsm : ∀ (n : ι), MeasurableSet (s n)\nhs : ProbabilityTheory.iCondIndepSet m' hm' s μ\ni k : ι\nhk : LT.lt i k\n⊢ ProbabilityTheory.CondIndep m' (MeasurableSpace.generateFrom (Singleton.singleton (s k))) (MeasurableSpace.generateFrom (setOf fun t => Exists fun j => And (LE.le j i) (Eq (s j) t))) hm' μ","decl":"theorem iCondIndepSet.condIndep_generateFrom_le [LinearOrder ι] {s : ι → Set Ω}\n    (hsm : ∀ n, MeasurableSet (s n)) (hs : iCondIndepSet m' hm' s μ) (i : ι) {k : ι} (hk : i < k) :\n    CondIndep m' (generateFrom {s k}) (generateFrom { t | ∃ j ≤ i, s j = t }) hm' μ :=\n  Kernel.iIndepSet.indep_generateFrom_le hsm hs i hk\n\n"}
{"name":"ProbabilityTheory.iCondIndepSet.condIndep_generateFrom_le_nat","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Nat → Set Ω\nhsm : ∀ (n : Nat), MeasurableSet (s n)\nhs : ProbabilityTheory.iCondIndepSet m' hm' s μ\nn : Nat\n⊢ ProbabilityTheory.CondIndep m' (MeasurableSpace.generateFrom (Singleton.singleton (s (HAdd.hAdd n 1)))) (MeasurableSpace.generateFrom (setOf fun t => Exists fun k => And (LE.le k n) (Eq (s k) t))) hm' μ","decl":"theorem iCondIndepSet.condIndep_generateFrom_le_nat {s : ℕ → Set Ω}\n    (hsm : ∀ n, MeasurableSet (s n)) (hs : iCondIndepSet m' hm' s μ) (n : ℕ) :\n    CondIndep m' (generateFrom {s (n + 1)}) (generateFrom { t | ∃ k ≤ n, s k = t }) hm' μ :=\n  Kernel.iIndepSet.indep_generateFrom_le_nat hsm hs n\n\n"}
{"name":"ProbabilityTheory.condIndep_iSup_of_monotone","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' m₁ mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : SemilatticeSup ι\nm : ι → MeasurableSpace Ω\nh_indep : ∀ (i : ι), ProbabilityTheory.CondIndep m' (m i) m₁ hm' μ\nh_le : ∀ (i : ι), LE.le (m i) mΩ\nh_le' : LE.le m₁ mΩ\nhm : Monotone m\n⊢ ProbabilityTheory.CondIndep m' (iSup fun i => m i) m₁ hm' μ","decl":"theorem condIndep_iSup_of_monotone [SemilatticeSup ι] {m : ι → MeasurableSpace Ω}\n    (h_indep : ∀ i, CondIndep m' (m i) m₁ hm' μ) (h_le : ∀ i, m i ≤ mΩ) (h_le' : m₁ ≤ mΩ)\n    (hm : Monotone m) :\n    CondIndep m' (⨆ i, m i) m₁ hm' μ :=\n  Kernel.indep_iSup_of_monotone h_indep h_le h_le' hm\n\n"}
{"name":"ProbabilityTheory.condIndep_iSup_of_antitone","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' m₁ mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : SemilatticeInf ι\nm : ι → MeasurableSpace Ω\nh_indep : ∀ (i : ι), ProbabilityTheory.CondIndep m' (m i) m₁ hm' μ\nh_le : ∀ (i : ι), LE.le (m i) mΩ\nh_le' : LE.le m₁ mΩ\nhm : Antitone m\n⊢ ProbabilityTheory.CondIndep m' (iSup fun i => m i) m₁ hm' μ","decl":"theorem condIndep_iSup_of_antitone [SemilatticeInf ι] {m : ι → MeasurableSpace Ω}\n    (h_indep : ∀ i, CondIndep m' (m i) m₁ hm' μ) (h_le : ∀ i, m i ≤ mΩ) (h_le' : m₁ ≤ mΩ)\n    (hm : Antitone m) :\n    CondIndep m' (⨆ i, m i) m₁ hm' μ :=\n  Kernel.indep_iSup_of_antitone h_indep h_le h_le' hm\n\n"}
{"name":"ProbabilityTheory.iCondIndepSets.piiUnionInter_of_not_mem","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nπ : ι → Set (Set Ω)\na : ι\nS : Finset ι\nhp_ind : ProbabilityTheory.iCondIndepSets m' hm' π μ\nhaS : Not (Membership.mem S a)\n⊢ ProbabilityTheory.CondIndepSets m' hm' (piiUnionInter π ↑S) (π a) μ","decl":"theorem iCondIndepSets.piiUnionInter_of_not_mem {π : ι → Set (Set Ω)} {a : ι} {S : Finset ι}\n    (hp_ind : iCondIndepSets m' hm' π μ) (haS : a ∉ S) :\n    CondIndepSets m' hm' (piiUnionInter π S) (π a) μ :=\n  Kernel.iIndepSets.piiUnionInter_of_not_mem hp_ind haS\n\n"}
{"name":"ProbabilityTheory.iCondIndepSets.iCondIndep","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nm : ι → MeasurableSpace Ω\nh_le : ∀ (i : ι), LE.le (m i) mΩ\nπ : ι → Set (Set Ω)\nh_pi : ∀ (n : ι), IsPiSystem (π n)\nh_generate : ∀ (i : ι), Eq (m i) (MeasurableSpace.generateFrom (π i))\nh_ind : ProbabilityTheory.iCondIndepSets m' hm' π μ\n⊢ ProbabilityTheory.iCondIndep m' hm' m μ","decl":"/-- The σ-algebras generated by conditionally independent pi-systems are conditionally independent.\n-/\ntheorem iCondIndepSets.iCondIndep (m : ι → MeasurableSpace Ω)\n    (h_le : ∀ i, m i ≤ mΩ) (π : ι → Set (Set Ω)) (h_pi : ∀ n, IsPiSystem (π n))\n    (h_generate : ∀ i, m i = generateFrom (π i)) (h_ind : iCondIndepSets m' hm' π μ) :\n    iCondIndep m' hm' m μ :=\n  Kernel.iIndepSets.iIndep m h_le π h_pi h_generate h_ind\n\n"}
{"name":"ProbabilityTheory.CondIndepSets.condIndepSet_of_mem","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\ns t : Set Ω\nS T : Set (Set Ω)\nhs : Membership.mem S s\nht : Membership.mem T t\nhs_meas : MeasurableSet s\nht_meas : MeasurableSet t\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh_indep : ProbabilityTheory.CondIndepSets m' hm' S T μ\n⊢ ProbabilityTheory.CondIndepSet m' hm' s t μ","decl":"theorem CondIndepSets.condIndepSet_of_mem (hs : s ∈ S) (ht : t ∈ T)\n    (hs_meas : MeasurableSet s) (ht_meas : MeasurableSet t) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (h_indep : CondIndepSets m' hm' S T μ) :\n    CondIndepSet m' hm' s t μ :=\n  Kernel.IndepSets.indepSet_of_mem _ _ hs ht hs_meas ht_meas _ _ h_indep\n\n"}
{"name":"ProbabilityTheory.CondIndep.condIndepSet_of_measurableSet","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' m₁ m₂ mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh_indep : ProbabilityTheory.CondIndep m' m₁ m₂ hm' μ\ns t : Set Ω\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ ProbabilityTheory.CondIndepSet m' hm' s t μ","decl":"theorem CondIndep.condIndepSet_of_measurableSet {μ : Measure Ω} [IsFiniteMeasure μ]\n    (h_indep : CondIndep m' m₁ m₂ hm' μ) {s t : Set Ω} (hs : MeasurableSet[m₁] s)\n    (ht : MeasurableSet[m₂] t) :\n    CondIndepSet m' hm' s t μ :=\n  Kernel.Indep.indepSet_of_measurableSet h_indep hs ht\n\n"}
{"name":"ProbabilityTheory.condIndep_iff_forall_condIndepSet","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nm' m₁ m₂ mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Iff (ProbabilityTheory.CondIndep m' m₁ m₂ hm' μ) (∀ (s t : Set Ω), MeasurableSet s → MeasurableSet t → ProbabilityTheory.CondIndepSet m' hm' s t μ)","decl":"theorem condIndep_iff_forall_condIndepSet (μ : Measure Ω) [IsFiniteMeasure μ] :\n    CondIndep m' m₁ m₂ hm' μ ↔ ∀ s t, MeasurableSet[m₁] s → MeasurableSet[m₂] t\n      → CondIndepSet m' hm' s t μ :=\n  Kernel.indep_iff_forall_indepSet m₁ m₂ _ _\n\n"}
{"name":"ProbabilityTheory.condIndepFun_iff_condExp_inter_preimage_eq_mul","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nβ : Type u_3\nβ' : Type u_4\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : Ω → β\ng : Ω → β'\nmβ : MeasurableSpace β\nmβ' : MeasurableSpace β'\nhf : Measurable f\nhg : Measurable g\n⊢ Iff (ProbabilityTheory.CondIndepFun m' hm' f g μ) (∀ (s : Set β) (t : Set β'), MeasurableSet s → MeasurableSet t → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Inter.inter (Set.preimage f s) (Set.preimage g t)).indicator fun ω => 1)) fun ω => HMul.hMul (MeasureTheory.condExp m' μ ((Set.preimage f s).indicator fun ω => 1) ω) (MeasureTheory.condExp m' μ ((Set.preimage g t).indicator fun ω => 1) ω))","decl":"theorem condIndepFun_iff_condExp_inter_preimage_eq_mul {mβ : MeasurableSpace β}\n    {mβ' : MeasurableSpace β'} (hf : Measurable f) (hg : Measurable g) :\n    CondIndepFun m' hm' f g μ ↔\n      ∀ s t, MeasurableSet s → MeasurableSet t\n        → (μ⟦f ⁻¹' s ∩ g ⁻¹' t | m'⟧) =ᵐ[μ] fun ω ↦ (μ⟦f ⁻¹' s | m'⟧) ω * (μ⟦g ⁻¹' t | m'⟧) ω := by\n  rw [condIndepFun_iff _ _ _ _ hf hg]\n  refine ⟨fun h s t hs ht ↦ ?_, fun h s t ↦ ?_⟩\n  · exact h (f ⁻¹' s) (g ⁻¹' t) ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  · rintro ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n    exact h s t hs ht\n\n"}
{"name":"ProbabilityTheory.condIndepFun_iff_condexp_inter_preimage_eq_mul","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nβ : Type u_3\nβ' : Type u_4\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : Ω → β\ng : Ω → β'\nmβ : MeasurableSpace β\nmβ' : MeasurableSpace β'\nhf : Measurable f\nhg : Measurable g\n⊢ Iff (ProbabilityTheory.CondIndepFun m' hm' f g μ) (∀ (s : Set β) (t : Set β'), MeasurableSet s → MeasurableSet t → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Inter.inter (Set.preimage f s) (Set.preimage g t)).indicator fun ω => 1)) fun ω => HMul.hMul (MeasureTheory.condExp m' μ ((Set.preimage f s).indicator fun ω => 1) ω) (MeasureTheory.condExp m' μ ((Set.preimage g t).indicator fun ω => 1) ω))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condIndepFun_iff_condexp_inter_preimage_eq_mul :=\n  condIndepFun_iff_condExp_inter_preimage_eq_mul\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun_iff_condExp_inter_preimage_eq_mul","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nβ : ι → Type u_5\nm : (x : ι) → MeasurableSpace (β x)\nf : (i : ι) → Ω → β i\nhf : ∀ (i : ι), Measurable (f i)\n⊢ Iff (ProbabilityTheory.iCondIndepFun m' hm' m f μ) (∀ (S : Finset ι) {sets : (i : ι) → Set (β i)}, (∀ (i : ι), Membership.mem S i → MeasurableSet (sets i)) → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Set.iInter fun i => Set.iInter fun h => Set.preimage (f i) (sets i)).indicator fun ω => 1)) (S.prod fun i => MeasureTheory.condExp m' μ ((Set.preimage (f i) (sets i)).indicator fun ω => 1)))","decl":"theorem iCondIndepFun_iff_condExp_inter_preimage_eq_mul {β : ι → Type*}\n    (m : ∀ x, MeasurableSpace (β x)) (f : ∀ i, Ω → β i) (hf : ∀ i, Measurable (f i)) :\n    iCondIndepFun m' hm' m f μ ↔\n      ∀ (S : Finset ι) {sets : ∀ i : ι, Set (β i)} (_H : ∀ i, i ∈ S → MeasurableSet[m i] (sets i)),\n        (μ⟦⋂ i ∈ S, f i ⁻¹' sets i| m'⟧) =ᵐ[μ] ∏ i ∈ S, (μ⟦f i ⁻¹' sets i | m'⟧) := by\n  rw [iCondIndepFun_iff]\n  swap\n  · exact hf\n  refine ⟨fun h s sets h_sets ↦ ?_, fun h s sets h_sets ↦ ?_⟩\n  · refine h s (g := fun i ↦ f i ⁻¹' (sets i)) (fun i hi ↦ ?_)\n    exact ⟨sets i, h_sets i hi, rfl⟩\n  · classical\n    let g := fun i ↦ if hi : i ∈ s then (h_sets i hi).choose else Set.univ\n    specialize h s (sets := g) (fun i hi ↦ ?_)\n    · simp only [g, dif_pos hi]\n      exact (h_sets i hi).choose_spec.1\n    · have hg : ∀ i ∈ s, sets i = f i ⁻¹' g i := by\n        intro i hi\n        rw [(h_sets i hi).choose_spec.2.symm]\n        simp only [g, dif_pos hi]\n      convert h with i hi i hi <;> exact hg i hi\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun_iff_condexp_inter_preimage_eq_mul","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nβ : ι → Type u_5\nm : (x : ι) → MeasurableSpace (β x)\nf : (i : ι) → Ω → β i\nhf : ∀ (i : ι), Measurable (f i)\n⊢ Iff (ProbabilityTheory.iCondIndepFun m' hm' m f μ) (∀ (S : Finset ι) {sets : (i : ι) → Set (β i)}, (∀ (i : ι), Membership.mem S i → MeasurableSet (sets i)) → (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m' μ ((Set.iInter fun i => Set.iInter fun h => Set.preimage (f i) (sets i)).indicator fun ω => 1)) (S.prod fun i => MeasureTheory.condExp m' μ ((Set.preimage (f i) (sets i)).indicator fun ω => 1)))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias iCondIndepFun_iff_condexp_inter_preimage_eq_mul :=\n  iCondIndepFun_iff_condExp_inter_preimage_eq_mul\n\n"}
{"name":"ProbabilityTheory.condIndepFun_iff_condIndepSet_preimage","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nβ : Type u_3\nβ' : Type u_4\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : Ω → β\ng : Ω → β'\nmβ : MeasurableSpace β\nmβ' : MeasurableSpace β'\nhf : Measurable f\nhg : Measurable g\n⊢ Iff (ProbabilityTheory.CondIndepFun m' hm' f g μ) (∀ (s : Set β) (t : Set β'), MeasurableSet s → MeasurableSet t → ProbabilityTheory.CondIndepSet m' hm' (Set.preimage f s) (Set.preimage g t) μ)","decl":"theorem condIndepFun_iff_condIndepSet_preimage {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    (hf : Measurable f) (hg : Measurable g) :\n    CondIndepFun m' hm' f g μ ↔\n      ∀ s t, MeasurableSet s → MeasurableSet t → CondIndepSet m' hm' (f ⁻¹' s) (g ⁻¹' t) μ := by\n  simp only [CondIndepFun, CondIndepSet, Kernel.indepFun_iff_indepSet_preimage hf hg]\n\n"}
{"name":"ProbabilityTheory.CondIndepFun.symm","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nx✝ : MeasurableSpace β\nf g : Ω → β\nhfg : ProbabilityTheory.CondIndepFun m' hm' f g μ\n⊢ ProbabilityTheory.CondIndepFun m' hm' g f μ","decl":"@[symm]\nnonrec theorem CondIndepFun.symm {_ : MeasurableSpace β} {f g : Ω → β}\n    (hfg : CondIndepFun m' hm' f g μ) :\n    CondIndepFun m' hm' g f μ :=\n  hfg.symm\n\n"}
{"name":"ProbabilityTheory.CondIndepFun.comp","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nβ : Type u_3\nβ' : Type u_4\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : Ω → β\ng : Ω → β'\nγ : Type u_5\nγ' : Type u_6\n_mβ : MeasurableSpace β\n_mβ' : MeasurableSpace β'\n_mγ : MeasurableSpace γ\n_mγ' : MeasurableSpace γ'\nφ : β → γ\nψ : β' → γ'\nhfg : ProbabilityTheory.CondIndepFun m' hm' f g μ\nhφ : Measurable φ\nhψ : Measurable ψ\n⊢ ProbabilityTheory.CondIndepFun m' hm' (Function.comp φ f) (Function.comp ψ g) μ","decl":"theorem CondIndepFun.comp {γ γ' : Type*} {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'}\n    {_mγ : MeasurableSpace γ} {_mγ' : MeasurableSpace γ'} {φ : β → γ} {ψ : β' → γ'}\n    (hfg : CondIndepFun m' hm' f g μ) (hφ : Measurable φ) (hψ : Measurable ψ) :\n    CondIndepFun m' hm' (φ ∘ f) (ψ ∘ g) μ :=\n  Kernel.IndepFun.comp hfg hφ hψ\n\n"}
{"name":"ProbabilityTheory.CondIndepFun.neg_right","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nβ : Type u_3\nβ' : Type u_4\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nf : Ω → β\ng : Ω → β'\n_mβ : MeasurableSpace β\n_mβ' : MeasurableSpace β'\ninst✝¹ : Neg β'\ninst✝ : MeasurableNeg β'\nhfg : ProbabilityTheory.CondIndepFun m' hm' f g μ\n⊢ ProbabilityTheory.CondIndepFun m' hm' f (Neg.neg g) μ","decl":"theorem CondIndepFun.neg_right {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β']\n    [MeasurableNeg β'] (hfg : CondIndepFun m' hm' f g μ)  :\n    CondIndepFun m' hm' f (-g) μ := hfg.comp measurable_id measurable_neg\n\n"}
{"name":"ProbabilityTheory.CondIndepFun.neg_left","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nβ : Type u_3\nβ' : Type u_4\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nf : Ω → β\ng : Ω → β'\n_mβ : MeasurableSpace β\n_mβ' : MeasurableSpace β'\ninst✝¹ : Neg β\ninst✝ : MeasurableNeg β\nhfg : ProbabilityTheory.CondIndepFun m' hm' f g μ\n⊢ ProbabilityTheory.CondIndepFun m' hm' (Neg.neg f) g μ","decl":"theorem CondIndepFun.neg_left {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β]\n    [MeasurableNeg β] (hfg : CondIndepFun m' hm' f g μ) :\n    CondIndepFun m' hm' (-f) g μ := hfg.comp measurable_neg measurable_id\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.of_subsingleton","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nβ : ι → Type u_5\nm : (i : ι) → MeasurableSpace (β i)\nf : (i : ι) → Ω → β i\ninst✝ : Subsingleton ι\n⊢ ProbabilityTheory.iCondIndepFun m' hm' m f μ","decl":"@[nontriviality]\nlemma iCondIndepFun.of_subsingleton [Subsingleton ι] : iCondIndepFun m' hm' m f μ :=\n  Kernel.iIndepFun.of_subsingleton\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.condIndepFun_finset","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nβ : ι → Type u_6\nm : (i : ι) → MeasurableSpace (β i)\nf : (i : ι) → Ω → β i\nS T : Finset ι\nhST : Disjoint S T\nhf_Indep : ProbabilityTheory.iCondIndepFun m' hm' m f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\n⊢ ProbabilityTheory.CondIndepFun m' hm' (fun a i => f (↑i) a) (fun a i => f (↑i) a) μ","decl":"/-- If `f` is a family of mutually conditionally independent random variables\n(`iCondIndepFun m' hm' m f μ`) and `S, T` are two disjoint finite index sets, then the tuple formed\nby `f i` for `i ∈ S` is conditionally independent of the tuple `(f i)_i` for `i ∈ T`. -/\ntheorem iCondIndepFun.condIndepFun_finset {β : ι → Type*}\n    {m : ∀ i, MeasurableSpace (β i)} {f : ∀ i, Ω → β i} (S T : Finset ι) (hST : Disjoint S T)\n    (hf_Indep : iCondIndepFun m' hm' m f μ) (hf_meas : ∀ i, Measurable (f i)) :\n    CondIndepFun m' hm' (fun a (i : S) => f i a) (fun a (i : T) => f i a) μ :=\n  Kernel.iIndepFun.indepFun_finset S T hST hf_Indep hf_meas\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.condIndepFun_prod_mk","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nβ : ι → Type u_6\nm : (i : ι) → MeasurableSpace (β i)\nf : (i : ι) → Ω → β i\nhf_Indep : ProbabilityTheory.iCondIndepFun m' hm' m f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.CondIndepFun m' hm' (fun a => { fst := f i a, snd := f j a }) (f k) μ","decl":"theorem iCondIndepFun.condIndepFun_prod_mk {β : ι → Type*}\n    {m : ∀ i, MeasurableSpace (β i)} {f : ∀ i, Ω → β i} (hf_Indep : iCondIndepFun m' hm' m f μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    CondIndepFun m' hm' (fun a => (f i a, f j a)) (f k) μ :=\n  Kernel.iIndepFun.indepFun_prod_mk hf_Indep hf_meas i j k hik hjk\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.condIndepFun_prod_mk_prod_mk","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nm' mΩ : MeasurableSpace Ω\ninst✝¹ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nβ : ι → Type u_5\nm : (i : ι) → MeasurableSpace (β i)\nf : (i : ι) → Ω → β i\nh_indep : ProbabilityTheory.iCondIndepFun m' hm' m f μ\nhf : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.CondIndepFun m' hm' (fun a => { fst := f i a, snd := f j a }) (fun a => { fst := f k a, snd := f l a }) μ","decl":"open Finset in\nlemma iCondIndepFun.condIndepFun_prod_mk_prod_mk (h_indep : iCondIndepFun m' hm' m f μ)\n    (hf : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    CondIndepFun m' hm' (fun a ↦ (f i a, f j a)) (fun a ↦ (f k a, f l a)) μ := by\n  classical\n  let g (i j : ι) (v : Π x : ({i, j} : Finset ι), β x) : β i × β j :=\n    ⟨v ⟨i, mem_insert_self _ _⟩, v ⟨j, mem_insert_of_mem <| mem_singleton_self _⟩⟩\n  have hg (i j : ι) : Measurable (g i j) := by fun_prop\n  exact (h_indep.indepFun_finset {i, j} {k, l} (by aesop) hf).comp (hg i j) (hg k l)\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_mul_left","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Mul β\ninst✝ : MeasurableMul₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.CondIndepFun m' hm' (HMul.hMul (f i) (f j)) (f k) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_mul_left (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    CondIndepFun m' hm' (f i * f j) (f k) μ :=\n  Kernel.iIndepFun.indepFun_mul_left hf_indep hf_meas i j k hik hjk\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_add_left","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Add β\ninst✝ : MeasurableAdd₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.CondIndepFun m' hm' (HAdd.hAdd (f i) (f j)) (f k) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_mul_left (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    CondIndepFun m' hm' (f i * f j) (f k) μ :=\n  Kernel.iIndepFun.indepFun_mul_left hf_indep hf_meas i j k hik hjk\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_add_right","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Add β\ninst✝ : MeasurableAdd₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhij : Ne i j\nhik : Ne i k\n⊢ ProbabilityTheory.CondIndepFun m' hm' (f i) (HAdd.hAdd (f j) (f k)) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_mul_right (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hij : i ≠ j) (hik : i ≠ k) :\n    CondIndepFun m' hm' (f i) (f j * f k) μ :=\n  Kernel.iIndepFun.indepFun_mul_right hf_indep hf_meas i j k hij hik\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_mul_right","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Mul β\ninst✝ : MeasurableMul₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhij : Ne i j\nhik : Ne i k\n⊢ ProbabilityTheory.CondIndepFun m' hm' (f i) (HMul.hMul (f j) (f k)) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_mul_right (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hij : i ≠ j) (hik : i ≠ k) :\n    CondIndepFun m' hm' (f i) (f j * f k) μ :=\n  Kernel.iIndepFun.indepFun_mul_right hf_indep hf_meas i j k hij hik\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_mul_mul","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Mul β\ninst✝ : MeasurableMul₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.CondIndepFun m' hm' (HMul.hMul (f i) (f j)) (HMul.hMul (f k) (f l)) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_mul_mul (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    CondIndepFun m' hm' (f i * f j) (f k * f l) μ :=\n  Kernel.iIndepFun.indepFun_mul_mul hf_indep hf_meas i j k l hik hil hjk hjl\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_add_add","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Add β\ninst✝ : MeasurableAdd₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.CondIndepFun m' hm' (HAdd.hAdd (f i) (f j)) (HAdd.hAdd (f k) (f l)) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_mul_mul (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    CondIndepFun m' hm' (f i * f j) (f k * f l) μ :=\n  Kernel.iIndepFun.indepFun_mul_mul hf_indep hf_meas i j k l hik hil hjk hjl\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_sub_left","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Sub β\ninst✝ : MeasurableSub₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.CondIndepFun m' hm' (HSub.hSub (f i) (f j)) (f k) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_div_left (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    CondIndepFun m' hm' (f i / f j) (f k) μ :=\n  Kernel.iIndepFun.indepFun_div_left hf_indep hf_meas i j k hik hjk\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_div_left","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Div β\ninst✝ : MeasurableDiv₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.CondIndepFun m' hm' (HDiv.hDiv (f i) (f j)) (f k) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_div_left (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    CondIndepFun m' hm' (f i / f j) (f k) μ :=\n  Kernel.iIndepFun.indepFun_div_left hf_indep hf_meas i j k hik hjk\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_div_right","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Div β\ninst✝ : MeasurableDiv₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhij : Ne i j\nhik : Ne i k\n⊢ ProbabilityTheory.CondIndepFun m' hm' (f i) (HDiv.hDiv (f j) (f k)) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_div_right (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hij : i ≠ j) (hik : i ≠ k) :\n    CondIndepFun m' hm' (f i) (f j / f k) μ :=\n  Kernel.iIndepFun.indepFun_div_right hf_indep hf_meas i j k hij hik\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_sub_right","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Sub β\ninst✝ : MeasurableSub₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhij : Ne i j\nhik : Ne i k\n⊢ ProbabilityTheory.CondIndepFun m' hm' (f i) (HSub.hSub (f j) (f k)) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_div_right (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hij : i ≠ j) (hik : i ≠ k) :\n    CondIndepFun m' hm' (f i) (f j / f k) μ :=\n  Kernel.iIndepFun.indepFun_div_right hf_indep hf_meas i j k hij hik\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_div_div","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Div β\ninst✝ : MeasurableDiv₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.CondIndepFun m' hm' (HDiv.hDiv (f i) (f j)) (HDiv.hDiv (f k) (f l)) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_div_div (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    CondIndepFun m' hm' (f i / f j) (f k / f l) μ :=\n  Kernel.iIndepFun.indepFun_div_div hf_indep hf_meas i j k l hik hil hjk hjl\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.indepFun_sub_sub","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : Sub β\ninst✝ : MeasurableSub₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.CondIndepFun m' hm' (HSub.hSub (f i) (f j)) (HSub.hSub (f k) (f l)) μ","decl":"@[to_additive]\nlemma iCondIndepFun.indepFun_div_div (hf_indep : iCondIndepFun m' hm' (fun _ ↦ m) f μ)\n    (hf_meas : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    CondIndepFun m' hm' (f i / f j) (f k / f l) μ :=\n  Kernel.iIndepFun.indepFun_div_div hf_indep hf_meas i j k l hik hil hjk hjl\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.condIndepFun_finset_prod_of_not_mem","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : CommMonoid β\ninst✝ : MeasurableMul₂ β\nf : ι → Ω → β\nhf_Indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ns : Finset ι\ni : ι\nhi : Not (Membership.mem s i)\n⊢ ProbabilityTheory.CondIndepFun m' hm' (s.prod fun j => f j) (f i) μ","decl":"@[to_additive]\ntheorem iCondIndepFun.condIndepFun_finset_prod_of_not_mem\n    (hf_Indep : iCondIndepFun m' hm' (fun _ => m) f μ) (hf_meas : ∀ i, Measurable (f i))\n    {s : Finset ι} {i : ι} (hi : i ∉ s) :\n    CondIndepFun m' hm' (∏ j ∈ s, f j) (f i) μ :=\n  Kernel.iIndepFun.indepFun_finset_prod_of_not_mem hf_Indep hf_meas hi\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.condIndepFun_finset_sum_of_not_mem","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : AddCommMonoid β\ninst✝ : MeasurableAdd₂ β\nf : ι → Ω → β\nhf_Indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ns : Finset ι\ni : ι\nhi : Not (Membership.mem s i)\n⊢ ProbabilityTheory.CondIndepFun m' hm' (s.sum fun j => f j) (f i) μ","decl":"@[to_additive]\ntheorem iCondIndepFun.condIndepFun_finset_prod_of_not_mem\n    (hf_Indep : iCondIndepFun m' hm' (fun _ => m) f μ) (hf_meas : ∀ i, Measurable (f i))\n    {s : Finset ι} {i : ι} (hi : i ∉ s) :\n    CondIndepFun m' hm' (∏ j ∈ s, f j) (f i) μ :=\n  Kernel.iIndepFun.indepFun_finset_prod_of_not_mem hf_Indep hf_meas hi\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.condIndepFun_prod_range_succ","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : CommMonoid β\ninst✝ : MeasurableMul₂ β\nf : Nat → Ω → β\nhf_Indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : Nat), Measurable (f i)\nn : Nat\n⊢ ProbabilityTheory.CondIndepFun m' hm' ((Finset.range n).prod fun j => f j) (f n) μ","decl":"@[to_additive]\ntheorem iCondIndepFun.condIndepFun_prod_range_succ {f : ℕ → Ω → β}\n    (hf_Indep : iCondIndepFun m' hm' (fun _ => m) f μ) (hf_meas : ∀ i, Measurable (f i)) (n : ℕ) :\n    CondIndepFun m' hm' (∏ j ∈ Finset.range n, f j) (f n) μ :=\n  Kernel.iIndepFun.indepFun_prod_range_succ hf_Indep hf_meas n\n\n"}
{"name":"ProbabilityTheory.iCondIndepFun.condIndepFun_sum_range_succ","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nm : MeasurableSpace β\ninst✝¹ : AddCommMonoid β\ninst✝ : MeasurableAdd₂ β\nf : Nat → Ω → β\nhf_Indep : ProbabilityTheory.iCondIndepFun m' hm' (fun x => m) f μ\nhf_meas : ∀ (i : Nat), Measurable (f i)\nn : Nat\n⊢ ProbabilityTheory.CondIndepFun m' hm' ((Finset.range n).sum fun j => f j) (f n) μ","decl":"@[to_additive]\ntheorem iCondIndepFun.condIndepFun_prod_range_succ {f : ℕ → Ω → β}\n    (hf_Indep : iCondIndepFun m' hm' (fun _ => m) f μ) (hf_meas : ∀ i, Measurable (f i)) (n : ℕ) :\n    CondIndepFun m' hm' (∏ j ∈ Finset.range n, f j) (f n) μ :=\n  Kernel.iIndepFun.indepFun_prod_range_succ hf_Indep hf_meas n\n\n"}
{"name":"ProbabilityTheory.iCondIndepSet.iCondIndepFun_indicator","module":"Mathlib.Probability.Independence.Conditional","initialProofState":"Ω : Type u_1\nι : Type u_2\nβ : Type u_3\nm' mΩ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\nhm' : LE.le m' mΩ\nμ : MeasureTheory.Measure Ω\ninst✝² : MeasureTheory.IsFiniteMeasure μ\ninst✝¹ : Zero β\ninst✝ : One β\nm : MeasurableSpace β\ns : ι → Set Ω\nhs : ProbabilityTheory.iCondIndepSet m' hm' s μ\n⊢ ProbabilityTheory.iCondIndepFun m' hm' (fun _n => m) (fun n => (s n).indicator fun _ω => 1) μ","decl":"theorem iCondIndepSet.iCondIndepFun_indicator [Zero β] [One β] {m : MeasurableSpace β}\n    {s : ι → Set Ω} (hs : iCondIndepSet m' hm' s μ) :\n    iCondIndepFun m' hm' (fun _n => m) (fun n => (s n).indicator fun _ω => 1) μ :=\n  Kernel.iIndepSet.iIndepFun_indicator hs\n\n"}
