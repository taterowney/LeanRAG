{"name":"Algebra.trace_apply","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\n⊢ Eq ((Algebra.trace R S) x) ((LinearMap.trace R S) ((Algebra.lmul R S) x))","decl":"theorem trace_apply (x) : trace R S x = LinearMap.trace R S (lmul R S x) :=\n  rfl\n\n"}
{"name":"Algebra.trace_eq_zero_of_not_exists_basis","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : Not (Exists fun s => Nonempty (Basis (Subtype fun x => Membership.mem s x) R S))\n⊢ Eq (Algebra.trace R S) 0","decl":"theorem trace_eq_zero_of_not_exists_basis (h : ¬∃ s : Finset S, Nonempty (Basis s R S)) :\n    trace R S = 0 := by ext s; simp [trace_apply, LinearMap.trace, h]\n\n"}
{"name":"Algebra.trace_eq_matrix_trace","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nι : Type w\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R S\ns : S\n⊢ Eq ((Algebra.trace R S) s) ((Algebra.leftMulMatrix b) s).trace","decl":"theorem trace_eq_matrix_trace [DecidableEq ι] (b : Basis ι R S) (s : S) :\n    trace R S s = Matrix.trace (Algebra.leftMulMatrix b s) := by\n  rw [trace_apply, LinearMap.trace_eq_matrix_trace _ b, ← toMatrix_lmul_eq]; rfl\n\n"}
{"name":"Algebra.trace_algebraMap_of_basis","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nι : Type w\ninst✝ : Fintype ι\nb : Basis ι R S\nx : R\n⊢ Eq ((Algebra.trace R S) ((algebraMap R S) x)) (HSMul.hSMul (Fintype.card ι) x)","decl":"/-- If `x` is in the base field `K`, then the trace is `[L : K] * x`. -/\ntheorem trace_algebraMap_of_basis (b : Basis ι R S) (x : R) :\n    trace R S (algebraMap R S x) = Fintype.card ι • x := by\n  haveI := Classical.decEq ι\n  rw [trace_apply, LinearMap.trace_eq_matrix_trace R b, Matrix.trace]\n  convert Finset.sum_const x\n  simp [-coe_lmul_eq_mul]\n\n\n"}
{"name":"Algebra.trace_self","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Algebra.trace R R) LinearMap.id","decl":"/-- The trace map from `R` to itself is the identity map. -/\n@[simp] theorem trace_self : trace R R = LinearMap.id := by\n  ext; simpa using trace_algebraMap_of_basis (.singleton (Fin 1) R) 1\n\n"}
{"name":"Algebra.trace_self_apply","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na : R\n⊢ Eq ((Algebra.trace R R) a) a","decl":"theorem trace_self_apply (a) : trace R R a = a := by simp\n\n"}
{"name":"Algebra.trace_algebraMap","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Free R S\nx : R\n⊢ Eq ((Algebra.trace R S) ((algebraMap R S) x)) (HSMul.hSMul (Module.finrank R S) x)","decl":"/-- If `x` is in the base field `K`, then the trace is `[L : K] * x`.\n\n(If `L` is not finite-dimensional over `K`, then `trace` and `finrank` return `0`.)\n-/\n@[simp]\ntheorem trace_algebraMap [StrongRankCondition R] [Module.Free R S] (x : R) :\n    trace R S (algebraMap R S x) = finrank R S • x := by\n  by_cases H : ∃ s : Finset S, Nonempty (Basis s R S)\n  · rw [trace_algebraMap_of_basis H.choose_spec.some, finrank_eq_card_basis H.choose_spec.some]\n  · simp [trace_eq_zero_of_not_exists_basis R H, finrank_eq_zero_of_not_exists_basis_finset H]\n\n"}
{"name":"Algebra.trace_trace_of_basis","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : CommRing T\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\nι : Type u_4\nκ : Type u_5\ninst✝¹ : Finite ι\ninst✝ : Finite κ\nb : Basis ι R S\nc : Basis κ S T\nx : T\n⊢ Eq ((Algebra.trace R S) ((Algebra.trace S T) x)) ((Algebra.trace R T) x)","decl":"theorem trace_trace_of_basis [Algebra S T] [IsScalarTower R S T] {ι κ : Type*} [Finite ι]\n    [Finite κ] (b : Basis ι R S) (c : Basis κ S T) (x : T) :\n    trace R S (trace S T x) = trace R T x := by\n  haveI := Classical.decEq ι\n  haveI := Classical.decEq κ\n  cases nonempty_fintype ι\n  cases nonempty_fintype κ\n  rw [trace_eq_matrix_trace (b.smulTower c), trace_eq_matrix_trace b, trace_eq_matrix_trace c,\n    Matrix.trace, Matrix.trace, Matrix.trace, ← Finset.univ_product_univ, Finset.sum_product]\n  refine Finset.sum_congr rfl fun i _ ↦ ?_\n  simp only [map_sum, smulTower_leftMulMatrix, Finset.sum_apply, Matrix.diag,\n    Finset.sum_apply i (Finset.univ : Finset κ) fun y => leftMulMatrix b (leftMulMatrix c x y y)]\n\n"}
{"name":"Algebra.trace_comp_trace_of_basis","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : CommRing T\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\nι : Type u_4\nκ : Type u_5\ninst✝¹ : Finite ι\ninst✝ : Finite κ\nb : Basis ι R S\nc : Basis κ S T\n⊢ Eq ((Algebra.trace R S).comp (↑R (Algebra.trace S T))) (Algebra.trace R T)","decl":"theorem trace_comp_trace_of_basis [Algebra S T] [IsScalarTower R S T] {ι κ : Type*} [Finite ι]\n    [Finite κ] (b : Basis ι R S) (c : Basis κ S T) :\n    (trace R S).comp ((trace S T).restrictScalars R) = trace R T := by\n  ext\n  rw [LinearMap.comp_apply, LinearMap.restrictScalars_apply, trace_trace_of_basis b c]\n\n"}
{"name":"Algebra.trace_trace","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : CommRing T\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra R T\ninst✝⁵ : Algebra S T\ninst✝⁴ : IsScalarTower R S T\ninst✝³ : Module.Free R S\ninst✝² : Module.Finite R S\ninst✝¹ : Module.Free S T\ninst✝ : Module.Finite S T\nx : T\n⊢ Eq ((Algebra.trace R S) ((Algebra.trace S T) x)) ((Algebra.trace R T) x)","decl":"@[simp]\ntheorem trace_trace [Algebra S T] [IsScalarTower R S T]\n    [Module.Free R S] [Module.Finite R S] [Module.Free S T] [Module.Finite S T] (x : T) :\n    trace R S (trace S T x) = trace R T x :=\n  trace_trace_of_basis (Module.Free.chooseBasis R S) (Module.Free.chooseBasis S T) x\n\n"}
{"name":"Algebra.trace_comp_trace","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : CommRing T\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra R T\ninst✝⁵ : Algebra S T\ninst✝⁴ : IsScalarTower R S T\ninst✝³ : Module.Free R S\ninst✝² : Module.Finite R S\ninst✝¹ : Module.Free S T\ninst✝ : Module.Finite S T\n⊢ Eq ((Algebra.trace R S).comp (↑R (Algebra.trace S T))) (Algebra.trace R T)","decl":"/-- Let `T / S / R` be a tower of finite extensions of fields. Then\n$\\text{Trace}_{T/R} = \\text{Trace}_{S/R} \\circ \\text{Trace}_{T/S}$.-/\n@[simp, stacks 0BIJ \"Trace\"]\ntheorem trace_comp_trace [Algebra S T] [IsScalarTower R S T]\n    [Module.Free R S] [Module.Finite R S] [Module.Free S T] [Module.Finite S T] :\n    (trace R S).comp ((trace S T).restrictScalars R) = trace R T :=\n  LinearMap.ext trace_trace\n\n"}
{"name":"Algebra.trace_prod_apply","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : CommRing T\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R T\ninst✝³ : Module.Free R S\ninst✝² : Module.Free R T\ninst✝¹ : Module.Finite R S\ninst✝ : Module.Finite R T\nx : Prod S T\n⊢ Eq ((Algebra.trace R (Prod S T)) x) (HAdd.hAdd ((Algebra.trace R S) x.1) ((Algebra.trace R T) x.2))","decl":"@[simp]\ntheorem trace_prod_apply [Module.Free R S] [Module.Free R T] [Module.Finite R S] [Module.Finite R T]\n    (x : S × T) : trace R (S × T) x = trace R S x.fst + trace R T x.snd := by\n  nontriviality R\n  let f := (lmul R S).toLinearMap.prodMap (lmul R T).toLinearMap\n  have : (lmul R (S × T)).toLinearMap = (prodMapLinear R S T S T R).comp f :=\n    LinearMap.ext₂ Prod.mul_def\n  simp_rw [trace, this]\n  exact trace_prodMap' _ _\n\n"}
{"name":"Algebra.trace_prod","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : CommRing T\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R T\ninst✝³ : Module.Free R S\ninst✝² : Module.Free R T\ninst✝¹ : Module.Finite R S\ninst✝ : Module.Finite R T\n⊢ Eq (Algebra.trace R (Prod S T)) ((Algebra.trace R S).coprod (Algebra.trace R T))","decl":"theorem trace_prod [Module.Free R S] [Module.Free R T] [Module.Finite R S] [Module.Finite R T] :\n    trace R (S × T) = (trace R S).coprod (trace R T) :=\n  LinearMap.ext fun p => by rw [coprod_apply, trace_prod_apply]\n\n"}
{"name":"Algebra.traceForm_apply","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx y : S\n⊢ Eq (((Algebra.traceForm R S) x) y) ((Algebra.trace R S) (HMul.hMul x y))","decl":"@[simp]\ntheorem traceForm_apply (x y : S) : traceForm R S x y = trace R S (x * y) :=\n  rfl\n\n"}
{"name":"Algebra.traceForm_isSymm","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ (Algebra.traceForm R S).IsSymm","decl":"theorem traceForm_isSymm : (traceForm R S).IsSymm := fun _ _ => congr_arg (trace R S) (mul_comm _ _)\n\n"}
{"name":"Algebra.traceForm_toMatrix","module":"Mathlib.RingTheory.Trace.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nι : Type w\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R S\ni j : ι\n⊢ Eq ((BilinForm.toMatrix b) (Algebra.traceForm R S) i j) ((Algebra.trace R S) (HMul.hMul (b i) (b j)))","decl":"theorem traceForm_toMatrix [DecidableEq ι] (b : Basis ι R S) (i j) :\n    BilinForm.toMatrix b (traceForm R S) i j = trace R S (b i * b j) := by\n  rw [BilinForm.toMatrix_apply, traceForm_apply]\n\n"}
