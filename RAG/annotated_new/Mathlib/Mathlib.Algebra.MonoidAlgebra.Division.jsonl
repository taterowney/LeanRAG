{"name":"AddMonoidAlgebra.divOf_apply","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\ng : G\nx : AddMonoidAlgebra k G\ng' : G\n⊢ Eq ((x.divOf g) g') (x (HAdd.hAdd g g'))","decl":"@[simp]\ntheorem divOf_apply (g : G) (x : k[G]) (g' : G) : (x /ᵒᶠ g) g' = x (g + g') :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.support_divOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\ng : G\nx : AddMonoidAlgebra k G\n⊢ Eq (x.divOf g).support (x.support.preimage (fun x => HAdd.hAdd g x) ⋯)","decl":"@[simp]\ntheorem support_divOf (g : G) (x : k[G]) :\n    (x /ᵒᶠ g).support =\n      x.support.preimage (g + ·) (Function.Injective.injOn (add_right_injective g)) :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.zero_divOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\ng : G\n⊢ Eq (AddMonoidAlgebra.divOf 0 g) 0","decl":"@[simp]\ntheorem zero_divOf (g : G) : (0 : k[G]) /ᵒᶠ g = 0 :=\n  map_zero (Finsupp.comapDomain.addMonoidHom _)\n\n"}
{"name":"AddMonoidAlgebra.divOf_zero","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\n⊢ Eq (x.divOf 0) x","decl":"@[simp]\ntheorem divOf_zero (x : k[G]) : x /ᵒᶠ 0 = x := by\n  refine Finsupp.ext fun _ => ?_  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` doesn't work\n  simp only [AddMonoidAlgebra.divOf_apply, zero_add]\n\n"}
{"name":"AddMonoidAlgebra.add_divOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx y : AddMonoidAlgebra k G\ng : G\n⊢ Eq ((HAdd.hAdd x y).divOf g) (HAdd.hAdd (x.divOf g) (y.divOf g))","decl":"theorem add_divOf (x y : k[G]) (g : G) : (x + y) /ᵒᶠ g = x /ᵒᶠ g + y /ᵒᶠ g :=\n  map_add (Finsupp.comapDomain.addMonoidHom _) _ _\n\n"}
{"name":"AddMonoidAlgebra.divOf_add","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\na b : G\n⊢ Eq (x.divOf (HAdd.hAdd a b)) ((x.divOf a).divOf b)","decl":"theorem divOf_add (x : k[G]) (a b : G) : x /ᵒᶠ (a + b) = x /ᵒᶠ a /ᵒᶠ b := by\n  refine Finsupp.ext fun _ => ?_  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` doesn't work\n  simp only [AddMonoidAlgebra.divOf_apply, add_assoc]\n\n"}
{"name":"AddMonoidAlgebra.divOfHom_apply_apply","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\ng : Multiplicative G\nx : AddMonoidAlgebra k G\n⊢ Eq ((AddMonoidAlgebra.divOfHom g) x) (x.divOf (Multiplicative.toAdd g))","decl":"/-- A bundled version of `AddMonoidAlgebra.divOf`. -/\n@[simps]\nnoncomputable def divOfHom : Multiplicative G →* AddMonoid.End k[G] where\n  toFun g :=\n    { toFun := fun x => divOf x g.toAdd\n      map_zero' := zero_divOf _\n      map_add' := fun x y => add_divOf x y g.toAdd }\n  map_one' := AddMonoidHom.ext divOf_zero\n  map_mul' g₁ g₂ :=\n    AddMonoidHom.ext fun _x =>\n      (congr_arg _ (add_comm g₁.toAdd g₂.toAdd)).trans\n        (divOf_add _ _ _)\n\n"}
{"name":"AddMonoidAlgebra.of'_mul_divOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\na : G\nx : AddMonoidAlgebra k G\n⊢ Eq ((HMul.hMul (AddMonoidAlgebra.of' k G a) x).divOf a) x","decl":"theorem of'_mul_divOf (a : G) (x : k[G]) : of' k G a * x /ᵒᶠ a = x := by\n  refine Finsupp.ext fun _ => ?_  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` doesn't work\n  rw [AddMonoidAlgebra.divOf_apply, of'_apply, single_mul_apply_aux, one_mul]\n  intro c hc\n  exact add_right_inj _\n\n"}
{"name":"AddMonoidAlgebra.mul_of'_divOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\na : G\n⊢ Eq ((HMul.hMul x (AddMonoidAlgebra.of' k G a)).divOf a) x","decl":"theorem mul_of'_divOf (x : k[G]) (a : G) : x * of' k G a /ᵒᶠ a = x := by\n  refine Finsupp.ext fun _ => ?_  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` doesn't work\n  rw [AddMonoidAlgebra.divOf_apply, of'_apply, mul_single_apply_aux, mul_one]\n  intro c hc\n  rw [add_comm]\n  exact add_right_inj _\n\n"}
{"name":"AddMonoidAlgebra.of'_divOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\na : G\n⊢ Eq ((AddMonoidAlgebra.of' k G a).divOf a) 1","decl":"theorem of'_divOf (a : G) : of' k G a /ᵒᶠ a = 1 := by\n  simpa only [one_mul] using mul_of'_divOf (1 : k[G]) a\n\n"}
{"name":"AddMonoidAlgebra.modOf_apply_of_not_exists_add","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\ng g' : G\nh : Not (Exists fun d => Eq g' (HAdd.hAdd g d))\n⊢ Eq ((x.modOf g) g') (x g')","decl":"@[simp]\ntheorem modOf_apply_of_not_exists_add (x : k[G]) (g : G) (g' : G)\n    (h : ¬∃ d, g' = g + d) : (x %ᵒᶠ g) g' = x g' := by\n  classical exact Finsupp.filter_apply_pos _ _ h\n\n"}
{"name":"AddMonoidAlgebra.modOf_apply_of_exists_add","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\ng g' : G\nh : Exists fun d => Eq g' (HAdd.hAdd g d)\n⊢ Eq ((x.modOf g) g') 0","decl":"@[simp]\ntheorem modOf_apply_of_exists_add (x : k[G]) (g : G) (g' : G)\n    (h : ∃ d, g' = g + d) : (x %ᵒᶠ g) g' = 0 := by\n  classical exact Finsupp.filter_apply_neg _ _ <| by rwa [Classical.not_not]\n\n"}
{"name":"AddMonoidAlgebra.modOf_apply_add_self","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\ng d : G\n⊢ Eq ((x.modOf g) (HAdd.hAdd d g)) 0","decl":"@[simp]\ntheorem modOf_apply_add_self (x : k[G]) (g : G) (d : G) : (x %ᵒᶠ g) (d + g) = 0 :=\n  modOf_apply_of_exists_add _ _ _ ⟨_, add_comm _ _⟩\n\n"}
{"name":"AddMonoidAlgebra.modOf_apply_self_add","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\ng d : G\n⊢ Eq ((x.modOf g) (HAdd.hAdd g d)) 0","decl":"theorem modOf_apply_self_add (x : k[G]) (g : G) (d : G) : (x %ᵒᶠ g) (g + d) = 0 :=\n  modOf_apply_of_exists_add _ _ _ ⟨_, rfl⟩\n\n"}
{"name":"AddMonoidAlgebra.of'_mul_modOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\ng : G\nx : AddMonoidAlgebra k G\n⊢ Eq ((HMul.hMul (AddMonoidAlgebra.of' k G g) x).modOf g) 0","decl":"theorem of'_mul_modOf (g : G) (x : k[G]) : of' k G g * x %ᵒᶠ g = 0 := by\n  refine Finsupp.ext fun g' => ?_  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext g'` doesn't work\n  rw [Finsupp.zero_apply]\n  obtain ⟨d, rfl⟩ | h := em (∃ d, g' = g + d)\n  · rw [modOf_apply_self_add]\n  · rw [modOf_apply_of_not_exists_add _ _ _ h, of'_apply, single_mul_apply_of_not_exists_add _ _ h]\n\n"}
{"name":"AddMonoidAlgebra.mul_of'_modOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\ng : G\n⊢ Eq ((HMul.hMul x (AddMonoidAlgebra.of' k G g)).modOf g) 0","decl":"theorem mul_of'_modOf (x : k[G]) (g : G) : x * of' k G g %ᵒᶠ g = 0 := by\n  refine Finsupp.ext fun g' => ?_  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext g'` doesn't work\n  rw [Finsupp.zero_apply]\n  obtain ⟨d, rfl⟩ | h := em (∃ d, g' = g + d)\n  · rw [modOf_apply_self_add]\n  · rw [modOf_apply_of_not_exists_add _ _ _ h, of'_apply, mul_single_apply_of_not_exists_add]\n    simpa only [add_comm] using h\n\n"}
{"name":"AddMonoidAlgebra.of'_modOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\ng : G\n⊢ Eq ((AddMonoidAlgebra.of' k G g).modOf g) 0","decl":"theorem of'_modOf (g : G) : of' k G g %ᵒᶠ g = 0 := by\n  simpa only [one_mul] using mul_of'_modOf (1 : k[G]) g\n\n"}
{"name":"AddMonoidAlgebra.divOf_add_modOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\ng : G\n⊢ Eq (HAdd.hAdd (HMul.hMul (AddMonoidAlgebra.of' k G g) (x.divOf g)) (x.modOf g)) x","decl":"theorem divOf_add_modOf (x : k[G]) (g : G) :\n    of' k G g * (x /ᵒᶠ g) + x %ᵒᶠ g = x := by\n  refine Finsupp.ext fun g' => ?_  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` doesn't work\n  rw [Finsupp.add_apply] -- Porting note: changed from `simp_rw` which can't see through the type\n  obtain ⟨d, rfl⟩ | h := em (∃ d, g' = g + d)\n  swap\n  · rw [modOf_apply_of_not_exists_add x _ _ h, of'_apply, single_mul_apply_of_not_exists_add _ _ h,\n      zero_add]\n  · rw [modOf_apply_self_add, add_zero]\n    rw [of'_apply, single_mul_apply_aux _ _ _, one_mul, divOf_apply]\n    intro a ha\n    exact add_right_inj _\n\n"}
{"name":"AddMonoidAlgebra.modOf_add_divOf","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\ng : G\n⊢ Eq (HAdd.hAdd (x.modOf g) (HMul.hMul (AddMonoidAlgebra.of' k G g) (x.divOf g))) x","decl":"theorem modOf_add_divOf (x : k[G]) (g : G) : x %ᵒᶠ g + of' k G g * (x /ᵒᶠ g) = x := by\n  rw [add_comm, divOf_add_modOf]\n\n"}
{"name":"AddMonoidAlgebra.of'_dvd_iff_modOf_eq_zero","module":"Mathlib.Algebra.MonoidAlgebra.Division","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝¹ : Semiring k\ninst✝ : AddCancelCommMonoid G\nx : AddMonoidAlgebra k G\ng : G\n⊢ Iff (Dvd.dvd (AddMonoidAlgebra.of' k G g) x) (Eq (x.modOf g) 0)","decl":"theorem of'_dvd_iff_modOf_eq_zero {x : k[G]} {g : G} :\n    of' k G g ∣ x ↔ x %ᵒᶠ g = 0 := by\n  constructor\n  · rintro ⟨x, rfl⟩\n    rw [of'_mul_modOf]\n  · intro h\n    rw [← divOf_add_modOf x g, h, add_zero]\n    exact dvd_mul_right _ _\n\n"}
