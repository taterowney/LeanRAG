{"name":"FirstOrder.Field.FieldAxiom.negAddCancel.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Field.FieldAxiom.negAddCancel) 1","decl":"/-- An indexing type to name each of the field axioms. The theory\nof fields is defined as the range of a function `FieldAxiom ->\nLanguage.ring.Sentence` -/\ninductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | negAddCancel : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNE : FieldAxiom\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.existsPairNE.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Field.FieldAxiom.existsPairNE) 1","decl":"/-- An indexing type to name each of the field axioms. The theory\nof fields is defined as the range of a function `FieldAxiom ->\nLanguage.ring.Sentence` -/\ninductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | negAddCancel : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNE : FieldAxiom\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.addAssoc.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Field.FieldAxiom.addAssoc) 1","decl":"/-- An indexing type to name each of the field axioms. The theory\nof fields is defined as the range of a function `FieldAxiom ->\nLanguage.ring.Sentence` -/\ninductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | negAddCancel : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNE : FieldAxiom\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.existsInv.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Field.FieldAxiom.existsInv) 1","decl":"/-- An indexing type to name each of the field axioms. The theory\nof fields is defined as the range of a function `FieldAxiom ->\nLanguage.ring.Sentence` -/\ninductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | negAddCancel : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNE : FieldAxiom\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.mulComm.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Field.FieldAxiom.mulComm) 1","decl":"/-- An indexing type to name each of the field axioms. The theory\nof fields is defined as the range of a function `FieldAxiom ->\nLanguage.ring.Sentence` -/\ninductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | negAddCancel : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNE : FieldAxiom\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.oneMul.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Field.FieldAxiom.oneMul) 1","decl":"/-- An indexing type to name each of the field axioms. The theory\nof fields is defined as the range of a function `FieldAxiom ->\nLanguage.ring.Sentence` -/\ninductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | negAddCancel : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNE : FieldAxiom\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.mulAssoc.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Field.FieldAxiom.mulAssoc) 1","decl":"/-- An indexing type to name each of the field axioms. The theory\nof fields is defined as the range of a function `FieldAxiom ->\nLanguage.ring.Sentence` -/\ninductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | negAddCancel : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNE : FieldAxiom\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.leftDistrib.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Field.FieldAxiom.leftDistrib) 1","decl":"/-- An indexing type to name each of the field axioms. The theory\nof fields is defined as the range of a function `FieldAxiom ->\nLanguage.ring.Sentence` -/\ninductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | negAddCancel : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNE : FieldAxiom\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.zeroAdd.sizeOf_spec","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Field.FieldAxiom.zeroAdd) 1","decl":"/-- An indexing type to name each of the field axioms. The theory\nof fields is defined as the range of a function `FieldAxiom ->\nLanguage.ring.Sentence` -/\ninductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | negAddCancel : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNE : FieldAxiom\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.realize_toSentence_iff_toProp","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"K : Type u_2\ninst✝⁵ : Add K\ninst✝⁴ : Mul K\ninst✝³ : Neg K\ninst✝² : Zero K\ninst✝¹ : One K\ninst✝ : FirstOrder.Ring.CompatibleRing K\nax : FirstOrder.Field.FieldAxiom\n⊢ Iff (FirstOrder.Language.Sentence.Realize K ax.toSentence) (FirstOrder.Field.FieldAxiom.toProp K ax)","decl":"theorem FieldAxiom.realize_toSentence_iff_toProp {K : Type*}\n    [Add K] [Mul K] [Neg K] [Zero K] [One K] [CompatibleRing K]\n    (ax : FieldAxiom) :\n    (K ⊨ (ax.toSentence : Sentence Language.ring)) ↔ ax.toProp K := by\n  cases ax <;>\n  simp [Sentence.Realize, Formula.Realize, Fin.snoc]\n\n"}
{"name":"FirstOrder.Field.FieldAxiom.toProp_of_model","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"K : Type u_2\ninst✝⁶ : Add K\ninst✝⁵ : Mul K\ninst✝⁴ : Neg K\ninst✝³ : Zero K\ninst✝² : One K\ninst✝¹ : FirstOrder.Ring.CompatibleRing K\ninst✝ : FirstOrder.Language.Theory.Model K FirstOrder.Language.Theory.field\nax : FirstOrder.Field.FieldAxiom\n⊢ FirstOrder.Field.FieldAxiom.toProp K ax","decl":"theorem FieldAxiom.toProp_of_model {K : Type*}\n    [Add K] [Mul K] [Neg K] [Zero K] [One K] [CompatibleRing K]\n    [Theory.field.Model K] (ax : FieldAxiom) : ax.toProp K :=\n  (FieldAxiom.realize_toSentence_iff_toProp ax).1\n    (Theory.realize_sentence_of_mem Theory.field\n      (Set.mem_range_self ax))\n\n"}
{"name":"FirstOrder.Field.instModelField","module":"Mathlib.ModelTheory.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : FirstOrder.Ring.CompatibleRing K\n⊢ FirstOrder.Language.Theory.Model K FirstOrder.Language.Theory.field","decl":"instance [Field K] [CompatibleRing K] : Theory.field.Model K :=\n  { realize_of_mem := by\n      simp only [Theory.field, Set.mem_range, exists_imp]\n      rintro φ a rfl\n      rw [a.realize_toSentence_iff_toProp (K := K)]\n      cases a with\n      | existsPairNE => exact exists_pair_ne K\n      | existsInv => exact fun x hx0 => ⟨x⁻¹, mul_inv_cancel₀ hx0⟩\n      | addAssoc => exact add_assoc\n      | zeroAdd => exact zero_add\n      | negAddCancel => exact neg_add_cancel\n      | mulAssoc => exact mul_assoc\n      | mulComm => exact mul_comm\n      | oneMul => exact one_mul\n      | leftDistrib => exact mul_add }\n\n"}
