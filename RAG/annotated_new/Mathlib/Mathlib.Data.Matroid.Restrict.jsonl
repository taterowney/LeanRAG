{"name":"Matroid.restrictIndepMatroid_Indep","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR I : Set α\n⊢ Eq ((M.restrictIndepMatroid R).Indep I) (And (M.Indep I) (HasSubset.Subset I R))","decl":"/-- The `IndepMatroid` whose independent sets are the independent subsets of `R`. -/\n@[simps] def restrictIndepMatroid (M : Matroid α) (R : Set α) : IndepMatroid α where\n  E := R\n  Indep I := M.Indep I ∧ I ⊆ R\n  indep_empty := ⟨M.empty_indep, empty_subset _⟩\n  indep_subset := fun _ _ h hIJ ↦ ⟨h.1.subset hIJ, hIJ.trans h.2⟩\n  indep_aug := by\n    rintro I I' ⟨hI, hIY⟩ (hIn : ¬ M.Basis' I R) (hI' : M.Basis' I' R)\n    rw [basis'_iff_basis_inter_ground] at hIn hI'\n    obtain ⟨B', hB', rfl⟩ := hI'.exists_base\n    obtain ⟨B, hB, hIB, hBIB'⟩ := hI.exists_base_subset_union_base hB'\n    rw [hB'.inter_basis_iff_compl_inter_basis_dual, diff_inter_diff] at hI'\n\n    have hss : M.E \\ (B' ∪ (R ∩ M.E)) ⊆ M.E \\ (B ∪ (R ∩ M.E)) := by\n      apply diff_subset_diff_right\n      rw [union_subset_iff, and_iff_left subset_union_right, union_comm]\n      exact hBIB'.trans (union_subset_union_left _ (subset_inter hIY hI.subset_ground))\n\n    have hi : M✶.Indep (M.E \\ (B ∪ (R ∩ M.E))) := by\n      rw [dual_indep_iff_exists]\n      exact ⟨B, hB, disjoint_of_subset_right subset_union_left disjoint_sdiff_left⟩\n\n    have h_eq := hI'.eq_of_subset_indep hi hss\n      (diff_subset_diff_right subset_union_right)\n    rw [h_eq, ← diff_inter_diff, ← hB.inter_basis_iff_compl_inter_basis_dual] at hI'\n\n    obtain ⟨J, hJ, hIJ⟩ := hI.subset_basis_of_subset\n      (subset_inter hIB (subset_inter hIY hI.subset_ground))\n    obtain rfl := hI'.indep.eq_of_basis hJ\n\n    have hIJ' : I ⊂ B ∩ (R ∩ M.E) := hIJ.ssubset_of_ne (fun he ↦ hIn (by rwa [he]))\n    obtain ⟨e, he⟩ := exists_of_ssubset hIJ'\n    exact ⟨e, ⟨⟨(hBIB' he.1.1).elim (fun h ↦ (he.2 h).elim) id,he.1.2⟩, he.2⟩,\n      hI'.indep.subset (insert_subset he.1 hIJ), insert_subset he.1.2.1 hIY⟩\n  indep_maximal := by\n    rintro A hAR I ⟨hI, _⟩ hIA\n    obtain ⟨J, hJ, hIJ⟩ := hI.subset_basis'_of_subset hIA\n    use J\n    simp only [hIJ, and_assoc, maximal_subset_iff, hJ.indep, hJ.subset, and_imp, true_and,\n      hJ.subset.trans hAR]\n    exact fun K hK _ hKA hJK ↦ hJ.eq_of_subset_indep hK hJK hKA\n  subset_ground _ := And.right\n\n"}
{"name":"Matroid.restrictIndepMatroid_E","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR : Set α\n⊢ Eq (M.restrictIndepMatroid R).E R","decl":"/-- The `IndepMatroid` whose independent sets are the independent subsets of `R`. -/\n@[simps] def restrictIndepMatroid (M : Matroid α) (R : Set α) : IndepMatroid α where\n  E := R\n  Indep I := M.Indep I ∧ I ⊆ R\n  indep_empty := ⟨M.empty_indep, empty_subset _⟩\n  indep_subset := fun _ _ h hIJ ↦ ⟨h.1.subset hIJ, hIJ.trans h.2⟩\n  indep_aug := by\n    rintro I I' ⟨hI, hIY⟩ (hIn : ¬ M.Basis' I R) (hI' : M.Basis' I' R)\n    rw [basis'_iff_basis_inter_ground] at hIn hI'\n    obtain ⟨B', hB', rfl⟩ := hI'.exists_base\n    obtain ⟨B, hB, hIB, hBIB'⟩ := hI.exists_base_subset_union_base hB'\n    rw [hB'.inter_basis_iff_compl_inter_basis_dual, diff_inter_diff] at hI'\n\n    have hss : M.E \\ (B' ∪ (R ∩ M.E)) ⊆ M.E \\ (B ∪ (R ∩ M.E)) := by\n      apply diff_subset_diff_right\n      rw [union_subset_iff, and_iff_left subset_union_right, union_comm]\n      exact hBIB'.trans (union_subset_union_left _ (subset_inter hIY hI.subset_ground))\n\n    have hi : M✶.Indep (M.E \\ (B ∪ (R ∩ M.E))) := by\n      rw [dual_indep_iff_exists]\n      exact ⟨B, hB, disjoint_of_subset_right subset_union_left disjoint_sdiff_left⟩\n\n    have h_eq := hI'.eq_of_subset_indep hi hss\n      (diff_subset_diff_right subset_union_right)\n    rw [h_eq, ← diff_inter_diff, ← hB.inter_basis_iff_compl_inter_basis_dual] at hI'\n\n    obtain ⟨J, hJ, hIJ⟩ := hI.subset_basis_of_subset\n      (subset_inter hIB (subset_inter hIY hI.subset_ground))\n    obtain rfl := hI'.indep.eq_of_basis hJ\n\n    have hIJ' : I ⊂ B ∩ (R ∩ M.E) := hIJ.ssubset_of_ne (fun he ↦ hIn (by rwa [he]))\n    obtain ⟨e, he⟩ := exists_of_ssubset hIJ'\n    exact ⟨e, ⟨⟨(hBIB' he.1.1).elim (fun h ↦ (he.2 h).elim) id,he.1.2⟩, he.2⟩,\n      hI'.indep.subset (insert_subset he.1 hIJ), insert_subset he.1.2.1 hIY⟩\n  indep_maximal := by\n    rintro A hAR I ⟨hI, _⟩ hIA\n    obtain ⟨J, hJ, hIJ⟩ := hI.subset_basis'_of_subset hIA\n    use J\n    simp only [hIJ, and_assoc, maximal_subset_iff, hJ.indep, hJ.subset, and_imp, true_and,\n      hJ.subset.trans hAR]\n    exact fun K hK _ hKA hJK ↦ hJ.eq_of_subset_indep hK hJK hKA\n  subset_ground _ := And.right\n\n"}
{"name":"Matroid.restrict_indep_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR I : Set α\n⊢ Iff ((M.restrict R).Indep I) (And (M.Indep I) (HasSubset.Subset I R))","decl":"@[simp] theorem restrict_indep_iff : (M ↾ R).Indep I ↔ M.Indep I ∧ I ⊆ R := Iff.rfl\n\n"}
{"name":"Matroid.Indep.indep_restrict_of_subset","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR I : Set α\nh : M.Indep I\nhIR : HasSubset.Subset I R\n⊢ (M.restrict R).Indep I","decl":"theorem Indep.indep_restrict_of_subset (h : M.Indep I) (hIR : I ⊆ R) : (M ↾ R).Indep I :=\n  restrict_indep_iff.mpr ⟨h,hIR⟩\n\n"}
{"name":"Matroid.Indep.of_restrict","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR I : Set α\nhI : (M.restrict R).Indep I\n⊢ M.Indep I","decl":"theorem Indep.of_restrict (hI : (M ↾ R).Indep I) : M.Indep I :=\n  (restrict_indep_iff.1 hI).1\n\n"}
{"name":"Matroid.restrict_ground_eq","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR : Set α\n⊢ Eq (M.restrict R).E R","decl":"@[simp] theorem restrict_ground_eq : (M ↾ R).E = R := rfl\n\n"}
{"name":"Matroid.restrict_finite","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR : Set α\nhR : R.Finite\n⊢ (M.restrict R).Finite","decl":"theorem restrict_finite {R : Set α} (hR : R.Finite) : (M ↾ R).Finite :=\n  ⟨hR⟩\n\n"}
{"name":"Matroid.restrict_dep_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR X : Set α\n⊢ Iff ((M.restrict R).Dep X) (And (Not (M.Indep X)) (HasSubset.Subset X R))","decl":"@[simp] theorem restrict_dep_iff : (M ↾ R).Dep X ↔ ¬ M.Indep X ∧ X ⊆ R := by\n  rw [Dep, restrict_indep_iff, restrict_ground_eq]; tauto\n\n"}
{"name":"Matroid.restrict_ground_eq_self","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq (M.restrict M.E) M","decl":"@[simp] theorem restrict_ground_eq_self (M : Matroid α) : (M ↾ M.E) = M := by\n  refine ext_indep rfl ?_; aesop\n\n"}
{"name":"Matroid.restrict_restrict_eq","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nR₁ R₂ : Set α\nM : Matroid α\nhR : HasSubset.Subset R₂ R₁\n⊢ Eq ((M.restrict R₁).restrict R₂) (M.restrict R₂)","decl":"theorem restrict_restrict_eq {R₁ R₂ : Set α} (M : Matroid α) (hR : R₂ ⊆ R₁) :\n    (M ↾ R₁) ↾ R₂ = M ↾ R₂ := by\n  refine ext_indep rfl ?_\n  simp only [restrict_ground_eq, restrict_indep_iff, and_congr_left_iff, and_iff_left_iff_imp]\n  exact fun _ h _ _ ↦ h.trans hR\n\n"}
{"name":"Matroid.restrict_idem","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR : Set α\n⊢ Eq ((M.restrict R).restrict R) (M.restrict R)","decl":"@[simp] theorem restrict_idem (M : Matroid α) (R : Set α) : M ↾ R ↾ R = M ↾ R := by\n  rw [M.restrict_restrict_eq Subset.rfl]\n\n"}
{"name":"Matroid.base_restrict_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff ((M.restrict X).Base I) (M.Basis I X)","decl":"@[simp] theorem base_restrict_iff (hX : X ⊆ M.E := by aesop_mat) :\n    (M ↾ X).Base I ↔ M.Basis I X := by\n  simp_rw [base_iff_maximal_indep, Basis, and_iff_left hX, maximal_iff, restrict_indep_iff]\n\n"}
{"name":"Matroid.base_restrict_iff'","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\n⊢ Iff ((M.restrict X).Base I) (M.Basis' I X)","decl":"theorem base_restrict_iff' : (M ↾ X).Base I ↔ M.Basis' I X := by\n  simp_rw [base_iff_maximal_indep, Basis', maximal_iff, restrict_indep_iff]\n\n"}
{"name":"Matroid.Basis.restrict_base","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nh : M.Basis I X\n⊢ (M.restrict X).Base I","decl":"theorem Basis.restrict_base (h : M.Basis I X) : (M ↾ X).Base I :=\n  (base_restrict_iff h.subset_ground).2 h\n\n"}
{"name":"Matroid.restrict_finiteRk","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.FiniteRk\nR : Set α\n⊢ (M.restrict R).FiniteRk","decl":"instance restrict_finiteRk [M.FiniteRk] (R : Set α) : (M ↾ R).FiniteRk :=\n  let ⟨_, hB⟩ := (M ↾ R).exists_base\n  hB.finiteRk_of_finite (hB.indep.of_restrict.finite)\n\n"}
{"name":"Matroid.restrict_finitary","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Finitary\nR : Set α\n⊢ (M.restrict R).Finitary","decl":"instance restrict_finitary [Finitary M] (R : Set α) : Finitary (M ↾ R) := by\n  refine ⟨fun I hI ↦ ?_⟩\n  simp only [restrict_indep_iff] at *\n  rw [indep_iff_forall_finite_subset_indep]\n  exact ⟨fun J hJ hJfin ↦ (hI J hJ hJfin).1,\n    fun e heI ↦ singleton_subset_iff.1 (hI _ (by simpa) (toFinite _)).2⟩\n\n"}
{"name":"Matroid.Basis.base_restrict","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nh : M.Basis I X\n⊢ (M.restrict X).Base I","decl":"@[simp] theorem Basis.base_restrict (h : M.Basis I X) : (M ↾ X).Base I :=\n  (base_restrict_iff h.subset_ground).mpr h\n\n"}
{"name":"Matroid.Basis.basis_restrict_of_subset","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X Y : Set α\nhI : M.Basis I X\nhXY : HasSubset.Subset X Y\n⊢ (M.restrict Y).Basis I X","decl":"theorem Basis.basis_restrict_of_subset (hI : M.Basis I X) (hXY : X ⊆ Y) : (M ↾ Y).Basis I X := by\n  rwa [← base_restrict_iff, M.restrict_restrict_eq hXY, base_restrict_iff]\n\n"}
{"name":"Matroid.basis'_restrict_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR I X : Set α\n⊢ Iff ((M.restrict R).Basis' I X) (And (M.Basis' I (Inter.inter X R)) (HasSubset.Subset I R))","decl":"theorem basis'_restrict_iff : (M ↾ R).Basis' I X ↔ M.Basis' I (X ∩ R) ∧ I ⊆ R := by\n  simp_rw [Basis', maximal_iff, restrict_indep_iff, subset_inter_iff, and_imp]\n  tauto\n\n"}
{"name":"Matroid.basis_restrict_iff'","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR I X : Set α\n⊢ Iff ((M.restrict R).Basis I X) (And (M.Basis I (Inter.inter X M.E)) (HasSubset.Subset X R))","decl":"theorem basis_restrict_iff' : (M ↾ R).Basis I X ↔ M.Basis I (X ∩ M.E) ∧ X ⊆ R := by\n  rw [basis_iff_basis'_subset_ground, basis'_restrict_iff, restrict_ground_eq, and_congr_left_iff,\n    ← basis'_iff_basis_inter_ground]\n  intro hXR\n  rw [inter_eq_self_of_subset_left hXR, and_iff_left_iff_imp]\n  exact fun h ↦ h.subset.trans hXR\n\n"}
{"name":"Matroid.basis_restrict_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR I X : Set α\nhR : autoParam (HasSubset.Subset R M.E) _auto✝\n⊢ Iff ((M.restrict R).Basis I X) (And (M.Basis I X) (HasSubset.Subset X R))","decl":"theorem basis_restrict_iff (hR : R ⊆ M.E := by aesop_mat) :\n    (M ↾ R).Basis I X ↔ M.Basis I X ∧ X ⊆ R := by\n  rw [basis_restrict_iff', and_congr_left_iff]\n  intro hXR\n  rw [← basis'_iff_basis_inter_ground, basis'_iff_basis]\n\n"}
{"name":"Matroid.basis'_iff_basis_restrict_univ","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\n⊢ Iff (M.Basis' I X) ((M.restrict Set.univ).Basis I X)","decl":"lemma basis'_iff_basis_restrict_univ : M.Basis' I X ↔ (M ↾ univ).Basis I X := by\n  rw [basis_restrict_iff', basis'_iff_basis_inter_ground, and_iff_left (subset_univ _)]\n\n"}
{"name":"Matroid.restrict_eq_restrict_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM M' : Matroid α\nX : Set α\n⊢ Iff (Eq (M.restrict X) (M'.restrict X)) (∀ (I : Set α), HasSubset.Subset I X → Iff (M.Indep I) (M'.Indep I))","decl":"theorem restrict_eq_restrict_iff (M M' : Matroid α) (X : Set α) :\n    M ↾ X = M' ↾ X ↔ ∀ I, I ⊆ X → (M.Indep I ↔ M'.Indep I) := by\n  refine ⟨fun h I hIX ↦ ?_, fun h ↦ ext_indep rfl fun I (hI : I ⊆ X) ↦ ?_⟩\n  · rw [← and_iff_left (a := (M.Indep I)) hIX, ← and_iff_left (a := (M'.Indep I)) hIX,\n      ← restrict_indep_iff, h, restrict_indep_iff]\n  rw [restrict_indep_iff, and_iff_left hI, restrict_indep_iff, and_iff_left hI, h _ hI]\n\n"}
{"name":"Matroid.restrict_eq_self_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR : Set α\n⊢ Iff (Eq (M.restrict R) M) (Eq R M.E)","decl":"@[simp] theorem restrict_eq_self_iff : M ↾ R = M ↔ R = M.E :=\n  ⟨fun h ↦ by rw [← h]; rfl, fun h ↦ by simp [h]⟩\n\n"}
{"name":"Matroid.Matroidᵣ.ext_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_2\nx y : Matroid.Matroidᵣ α\n⊢ Iff (Eq x y) (Eq x.toMatroid y.toMatroid)","decl":"/-- A type synonym for matroids with the restriction order.\n  (The `PartialOrder` on `Matroid α` is reserved for the minor order)  -/\n@[ext] structure Matroidᵣ (α : Type*) where ofMatroid ::\n  /-- The underlying `Matroid`.-/\n  toMatroid : Matroid α\n\n"}
{"name":"Matroid.Matroidᵣ.ofMatroid.sizeOf_spec","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_2\ninst✝ : SizeOf α\ntoMatroid : Matroid α\n⊢ Eq (SizeOf.sizeOf { toMatroid := toMatroid }) (HAdd.hAdd 1 (SizeOf.sizeOf toMatroid))","decl":"/-- A type synonym for matroids with the restriction order.\n  (The `PartialOrder` on `Matroid α` is reserved for the minor order)  -/\n@[ext] structure Matroidᵣ (α : Type*) where ofMatroid ::\n  /-- The underlying `Matroid`.-/\n  toMatroid : Matroid α\n\n"}
{"name":"Matroid.Matroidᵣ.ofMatroid.inj","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_2\ntoMatroid✝ toMatroid : Matroid α\nx✝ : Eq { toMatroid := toMatroid✝ } { toMatroid := toMatroid }\n⊢ Eq toMatroid✝ toMatroid","decl":"/-- A type synonym for matroids with the restriction order.\n  (The `PartialOrder` on `Matroid α` is reserved for the minor order)  -/\n@[ext] structure Matroidᵣ (α : Type*) where ofMatroid ::\n  /-- The underlying `Matroid`.-/\n  toMatroid : Matroid α\n\n"}
{"name":"Matroid.Matroidᵣ.ofMatroid.injEq","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_2\ntoMatroid✝ toMatroid : Matroid α\n⊢ Eq (Eq { toMatroid := toMatroid✝ } { toMatroid := toMatroid }) (Eq toMatroid✝ toMatroid)","decl":"/-- A type synonym for matroids with the restriction order.\n  (The `PartialOrder` on `Matroid α` is reserved for the minor order)  -/\n@[ext] structure Matroidᵣ (α : Type*) where ofMatroid ::\n  /-- The underlying `Matroid`.-/\n  toMatroid : Matroid α\n\n"}
{"name":"Matroid.Matroidᵣ.ext","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_2\nx y : Matroid.Matroidᵣ α\ntoMatroid : Eq x.toMatroid y.toMatroid\n⊢ Eq x y","decl":"/-- A type synonym for matroids with the restriction order.\n  (The `PartialOrder` on `Matroid α` is reserved for the minor order)  -/\n@[ext] structure Matroidᵣ (α : Type*) where ofMatroid ::\n  /-- The underlying `Matroid`.-/\n  toMatroid : Matroid α\n\n"}
{"name":"Matroid.Matroidᵣ.coe_inj","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid.Matroidᵣ α\n⊢ Iff (Eq M₁.toMatroid M₂.toMatroid) (Eq M₁ M₂)","decl":"@[simp] theorem Matroidᵣ.coe_inj {M₁ M₂ : Matroidᵣ α} :\n    (M₁ : Matroid α) = (M₂ : Matroid α) ↔ M₁ = M₂ := by\n  cases M₁; cases M₂; simp\n\n"}
{"name":"Matroid.Matroidᵣ.le_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM M' : Matroid.Matroidᵣ α\n⊢ Iff (LE.le M M') (M.toMatroid.Restriction M'.toMatroid)","decl":"@[simp] protected theorem Matroidᵣ.le_iff {M M' : Matroidᵣ α} :\n    M ≤ M' ↔ (M : Matroid α) ≤r (M' : Matroid α) := Iff.rfl\n\n"}
{"name":"Matroid.Matroidᵣ.lt_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM M' : Matroid.Matroidᵣ α\n⊢ Iff (LT.lt M M') (M.toMatroid.StrictRestriction M'.toMatroid)","decl":"@[simp] protected theorem Matroidᵣ.lt_iff {M M' : Matroidᵣ α} :\n    M < M' ↔ (M : Matroid α) <r (M' : Matroid α) := Iff.rfl\n\n"}
{"name":"Matroid.ofMatroid_le_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM M' : Matroid α\n⊢ Iff (LE.le { toMatroid := M } { toMatroid := M' }) (M.Restriction M')","decl":"theorem ofMatroid_le_iff {M M' : Matroid α} :\n    Matroidᵣ.ofMatroid M ≤ Matroidᵣ.ofMatroid M' ↔ M ≤r M' := by\n  simp\n\n"}
{"name":"Matroid.ofMatroid_lt_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM M' : Matroid α\n⊢ Iff (LT.lt { toMatroid := M } { toMatroid := M' }) (M.StrictRestriction M')","decl":"theorem ofMatroid_lt_iff {M M' : Matroid α} :\n    Matroidᵣ.ofMatroid M < Matroidᵣ.ofMatroid M' ↔ M <r M' := by\n  simp\n\n"}
{"name":"Matroid.Restriction.refl","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ M.Restriction M","decl":"theorem Restriction.refl : M ≤r M :=\n  le_refl (Matroidᵣ.ofMatroid M)\n\n"}
{"name":"Matroid.Restriction.antisymm","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM M' : Matroid α\nh : M.Restriction M'\nh' : M'.Restriction M\n⊢ Eq M M'","decl":"theorem Restriction.antisymm {M' : Matroid α} (h : M ≤r M') (h' : M' ≤r M) : M = M' := by\n  simpa using (ofMatroid_le_iff.2 h).antisymm (ofMatroid_le_iff.2 h')\n\n"}
{"name":"Matroid.Restriction.trans","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM₁ M₂ M₃ : Matroid α\nh : M₁.Restriction M₂\nh' : M₂.Restriction M₃\n⊢ M₁.Restriction M₃","decl":"theorem Restriction.trans {M₁ M₂ M₃ : Matroid α} (h : M₁ ≤r M₂) (h' : M₂ ≤r M₃) : M₁ ≤r M₃ :=\n  le_trans (α := Matroidᵣ α) h h'\n\n"}
{"name":"Matroid.restrict_restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nR : Set α\nhR : autoParam (HasSubset.Subset R M.E) _auto✝\n⊢ (M.restrict R).Restriction M","decl":"theorem restrict_restriction (M : Matroid α) (R : Set α) (hR : R ⊆ M.E := by aesop_mat) :\n    M ↾ R ≤r M :=\n  ⟨R, hR, rfl⟩\n\n"}
{"name":"Matroid.Restriction.eq_restrict","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.Restriction M\n⊢ Eq (M.restrict N.E) N","decl":"theorem Restriction.eq_restrict (h : N ≤r M) : M ↾ N.E = N := by\n  obtain ⟨R, -, rfl⟩ := h; rw [restrict_ground_eq]\n\n"}
{"name":"Matroid.Restriction.subset","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.Restriction M\n⊢ HasSubset.Subset N.E M.E","decl":"theorem Restriction.subset (h : N ≤r M) : N.E ⊆ M.E := by\n  obtain ⟨R, hR, rfl⟩ := h; exact hR\n\n"}
{"name":"Matroid.Restriction.exists_eq_restrict","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.Restriction M\n⊢ Exists fun R => And (HasSubset.Subset R M.E) (Eq N (M.restrict R))","decl":"theorem Restriction.exists_eq_restrict (h : N ≤r M) : ∃ R ⊆ M.E, N = M ↾ R :=\n  h\n\n"}
{"name":"Matroid.Restriction.of_subset","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nR R' : Set α\nM : Matroid α\nh : HasSubset.Subset R R'\n⊢ (M.restrict R).Restriction (M.restrict R')","decl":"theorem Restriction.of_subset {R' : Set α} (M : Matroid α) (h : R ⊆ R') : (M ↾ R) ≤r (M ↾ R') := by\n  rw [← restrict_restrict_eq M h]; exact restrict_restriction _ _ h\n\n"}
{"name":"Matroid.restriction_iff_exists","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\n⊢ Iff (N.Restriction M) (Exists fun R => And (HasSubset.Subset R M.E) (Eq N (M.restrict R)))","decl":"theorem restriction_iff_exists : (N ≤r M) ↔ ∃ R, R ⊆ M.E ∧ N = M ↾ R := by\n  use Restriction.exists_eq_restrict; rintro ⟨R, hR, rfl⟩; exact restrict_restriction M R hR\n\n"}
{"name":"Matroid.StrictRestriction.restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.StrictRestriction M\n⊢ N.Restriction M","decl":"theorem StrictRestriction.restriction (h : N <r M) : N ≤r M :=\n  h.1\n\n"}
{"name":"Matroid.StrictRestriction.ne","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.StrictRestriction M\n⊢ Ne N M","decl":"theorem StrictRestriction.ne (h : N <r M) : N ≠ M := by\n  rintro rfl; rw [← ofMatroid_lt_iff] at h; simp at h\n\n"}
{"name":"Matroid.StrictRestriction.irrefl","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Not (M.StrictRestriction M)","decl":"theorem StrictRestriction.irrefl (M : Matroid α) : ¬ (M <r M) :=\n  fun h ↦ h.ne rfl\n\n"}
{"name":"Matroid.StrictRestriction.ssubset","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.StrictRestriction M\n⊢ HasSSubset.SSubset N.E M.E","decl":"theorem StrictRestriction.ssubset (h : N <r M) : N.E ⊂ M.E := by\n  obtain ⟨R, -, rfl⟩ := h.1\n  refine h.restriction.subset.ssubset_of_ne (fun h' ↦ h.2 ⟨R, Subset.rfl, ?_⟩)\n  rw [show R = M.E from h', restrict_idem, restrict_ground_eq_self]\n\n"}
{"name":"Matroid.StrictRestriction.eq_restrict","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.StrictRestriction M\n⊢ Eq (M.restrict N.E) N","decl":"theorem StrictRestriction.eq_restrict (h : N <r M) : M ↾ N.E = N :=\n  h.restriction.eq_restrict\n\n"}
{"name":"Matroid.StrictRestriction.exists_eq_restrict","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.StrictRestriction M\n⊢ Exists fun R => And (HasSSubset.SSubset R M.E) (Eq N (M.restrict R))","decl":"theorem StrictRestriction.exists_eq_restrict (h : N <r M) : ∃ R, R ⊂ M.E ∧ N = M ↾ R :=\n  ⟨N.E, h.ssubset, by rw [h.eq_restrict]⟩\n\n"}
{"name":"Matroid.Restriction.strictRestriction_of_ne","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.Restriction M\nhne : Ne N M\n⊢ N.StrictRestriction M","decl":"theorem Restriction.strictRestriction_of_ne (h : N ≤r M) (hne : N ≠ M) : N <r M :=\n  ⟨h, fun h' ↦ hne <| h.antisymm h'⟩\n\n"}
{"name":"Matroid.Restriction.eq_or_strictRestriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.Restriction M\n⊢ Or (Eq N M) (N.StrictRestriction M)","decl":"theorem Restriction.eq_or_strictRestriction (h : N ≤r M) : N = M ∨ N <r M := by\n  simpa using eq_or_lt_of_le (ofMatroid_le_iff.2 h)\n\n"}
{"name":"Matroid.restrict_strictRestriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nR : Set α\nM : Matroid α\nhR : HasSSubset.SSubset R M.E\n⊢ (M.restrict R).StrictRestriction M","decl":"theorem restrict_strictRestriction {M : Matroid α} (hR : R ⊂ M.E) : M ↾ R <r M := by\n  refine (M.restrict_restriction R hR.subset).strictRestriction_of_ne (fun h ↦ ?_)\n  rw [← h, restrict_ground_eq] at hR\n  exact hR.ne rfl\n\n"}
{"name":"Matroid.Restriction.strictRestriction_of_ground_ne","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nh : N.Restriction M\nhne : Ne N.E M.E\n⊢ N.StrictRestriction M","decl":"theorem Restriction.strictRestriction_of_ground_ne (h : N ≤r M) (hne : N.E ≠ M.E) : N <r M := by\n  rw [← h.eq_restrict]\n  exact restrict_strictRestriction (h.subset.ssubset_of_ne hne)\n\n"}
{"name":"Matroid.StrictRestriction.of_ssubset","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nR R' : Set α\nM : Matroid α\nh : HasSSubset.SSubset R R'\n⊢ (M.restrict R).StrictRestriction (M.restrict R')","decl":"theorem StrictRestriction.of_ssubset {R' : Set α} (M : Matroid α) (h : R ⊂ R') :\n    (M ↾ R) <r (M ↾ R') :=\n  (Restriction.of_subset M h.subset).strictRestriction_of_ground_ne h.ne\n\n"}
{"name":"Matroid.Restriction.finite","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nN M : Matroid α\ninst✝ : M.Finite\nh : N.Restriction M\n⊢ N.Finite","decl":"theorem Restriction.finite {M : Matroid α} [M.Finite] (h : N ≤r M) : N.Finite := by\n  obtain ⟨R, hR, rfl⟩ := h\n  exact restrict_finite <| M.ground_finite.subset hR\n\n"}
{"name":"Matroid.Restriction.finiteRk","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nN M : Matroid α\ninst✝ : M.FiniteRk\nh : N.Restriction M\n⊢ N.FiniteRk","decl":"theorem Restriction.finiteRk {M : Matroid α} [FiniteRk M] (h : N ≤r M) : N.FiniteRk := by\n  obtain ⟨R, -, rfl⟩ := h\n  infer_instance\n\n"}
{"name":"Matroid.Restriction.finitary","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nN M : Matroid α\ninst✝ : M.Finitary\nh : N.Restriction M\n⊢ N.Finitary","decl":"theorem Restriction.finitary {M : Matroid α} [Finitary M] (h : N ≤r M) : N.Finitary := by\n  obtain ⟨R, -, rfl⟩ := h\n  infer_instance\n\n"}
{"name":"Matroid.finite_setOf_restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Finite\n⊢ (setOf fun N => N.Restriction M).Finite","decl":"theorem finite_setOf_restriction (M : Matroid α) [M.Finite] : {N | N ≤r M}.Finite :=\n  (M.ground_finite.finite_subsets.image (fun R ↦ M ↾ R)).subset <|\n    by rintro _ ⟨R, hR, rfl⟩; exact ⟨_, hR, rfl⟩\n\n"}
{"name":"Matroid.Indep.of_restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nN : Matroid α\nhI : N.Indep I\nhNM : N.Restriction M\n⊢ M.Indep I","decl":"theorem Indep.of_restriction (hI : N.Indep I) (hNM : N ≤r M) : M.Indep I := by\n  obtain ⟨R, -, rfl⟩ := hNM; exact hI.of_restrict\n\n"}
{"name":"Matroid.Indep.indep_restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nN : Matroid α\nhI : M.Indep I\nhNM : N.Restriction M\nhIN : HasSubset.Subset I N.E\n⊢ N.Indep I","decl":"theorem Indep.indep_restriction (hI : M.Indep I) (hNM : N ≤r M) (hIN : I ⊆ N.E) : N.Indep I := by\n  obtain ⟨R, -, rfl⟩ := hNM; simpa [hI]\n\n"}
{"name":"Matroid.Restriction.indep_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nN : Matroid α\nhMN : N.Restriction M\n⊢ Iff (N.Indep I) (And (M.Indep I) (HasSubset.Subset I N.E))","decl":"theorem Restriction.indep_iff (hMN : N ≤r M) : N.Indep I ↔ M.Indep I ∧ I ⊆ N.E :=\n  ⟨fun h ↦ ⟨h.of_restriction hMN, h.subset_ground⟩, fun h ↦ h.1.indep_restriction hMN h.2⟩\n\n"}
{"name":"Matroid.Basis.basis_restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nN : Matroid α\nhI : M.Basis I X\nhNM : N.Restriction M\nhX : HasSubset.Subset X N.E\n⊢ N.Basis I X","decl":"theorem Basis.basis_restriction (hI : M.Basis I X) (hNM : N ≤r M) (hX : X ⊆ N.E) : N.Basis I X := by\n  obtain ⟨R, hR, rfl⟩ := hNM; rwa [basis_restrict_iff, and_iff_left (show X ⊆ R from hX)]\n\n"}
{"name":"Matroid.Basis.of_restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nN : Matroid α\nhI : N.Basis I X\nhNM : N.Restriction M\n⊢ M.Basis I X","decl":"theorem Basis.of_restriction (hI : N.Basis I X) (hNM : N ≤r M) : M.Basis I X := by\n  obtain ⟨R, hR, rfl⟩ := hNM; exact ((basis_restrict_iff hR).1 hI).1\n\n"}
{"name":"Matroid.Base.basis_of_restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nN : Matroid α\nhI : N.Base I\nhNM : N.Restriction M\n⊢ M.Basis I N.E","decl":"theorem Base.basis_of_restriction (hI : N.Base I) (hNM : N ≤r M) : M.Basis I N.E := by\n  obtain ⟨R, hR, rfl⟩ := hNM; rwa [base_restrict_iff] at hI\n\n"}
{"name":"Matroid.Restriction.base_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM N : Matroid α\nhMN : N.Restriction M\nB : Set α\n⊢ Iff (N.Base B) (M.Basis B N.E)","decl":"theorem Restriction.base_iff (hMN : N ≤r M) {B : Set α} : N.Base B ↔ M.Basis B N.E :=\n  ⟨fun h ↦ Base.basis_of_restriction h hMN,\n    fun h ↦ by simpa [hMN.eq_restrict] using h.restrict_base⟩\n\n"}
{"name":"Matroid.Restriction.basis_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nN : Matroid α\nhMN : N.Restriction M\n⊢ Iff (N.Basis I X) (And (M.Basis I X) (HasSubset.Subset X N.E))","decl":"theorem Restriction.basis_iff (hMN : N ≤r M) : N.Basis I X ↔ M.Basis I X ∧ X ⊆ N.E :=\n  ⟨fun h ↦ ⟨h.of_restriction hMN, h.subset_ground⟩, fun h ↦ h.1.basis_restriction hMN h.2⟩\n\n"}
{"name":"Matroid.Dep.of_restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nN : Matroid α\nhX : N.Dep X\nhNM : N.Restriction M\n⊢ M.Dep X","decl":"theorem Dep.of_restriction (hX : N.Dep X) (hNM : N ≤r M) : M.Dep X := by\n  obtain ⟨R, hR, rfl⟩ := hNM\n  rw [restrict_dep_iff] at hX\n  exact ⟨hX.1, hX.2.trans hR⟩\n\n"}
{"name":"Matroid.Dep.dep_restriction","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nN : Matroid α\nhX : M.Dep X\nhNM : N.Restriction M\nhXE : autoParam (HasSubset.Subset X N.E) _auto✝\n⊢ N.Dep X","decl":"theorem Dep.dep_restriction (hX : M.Dep X) (hNM : N ≤r M) (hXE : X ⊆ N.E := by aesop_mat) :\n    N.Dep X := by\n  obtain ⟨R, -, rfl⟩ := hNM; simpa [hX.not_indep]\n\n"}
{"name":"Matroid.Restriction.dep_iff","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nN : Matroid α\nhMN : N.Restriction M\n⊢ Iff (N.Dep X) (And (M.Dep X) (HasSubset.Subset X N.E))","decl":"theorem Restriction.dep_iff (hMN : N ≤r M) : N.Dep X ↔ M.Dep X ∧ X ⊆ N.E :=\n  ⟨fun h ↦ ⟨h.of_restriction hMN, h.subset_ground⟩, fun h ↦ h.1.dep_restriction hMN h.2⟩\n\n"}
{"name":"Matroid.Basis.transfer","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X Y J : Set α\nhIX : M.Basis I X\nhJX : M.Basis J X\nhXY : HasSubset.Subset X Y\nhJY : M.Basis J Y\n⊢ M.Basis I Y","decl":"theorem Basis.transfer (hIX : M.Basis I X) (hJX : M.Basis J X) (hXY : X ⊆ Y) (hJY : M.Basis J Y) :\n    M.Basis I Y := by\n  rw [← base_restrict_iff]; rw [← base_restrict_iff] at hJY\n  exact hJY.base_of_basis_superset hJX.subset (hIX.basis_restrict_of_subset hXY)\n\n"}
{"name":"Matroid.Basis.basis_of_basis_of_subset_of_subset","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X Y J : Set α\nhI : M.Basis I X\nhJ : M.Basis J Y\nhJX : HasSubset.Subset J X\nhIY : HasSubset.Subset I Y\n⊢ M.Basis I Y","decl":"theorem Basis.basis_of_basis_of_subset_of_subset (hI : M.Basis I X) (hJ : M.Basis J Y) (hJX : J ⊆ X)\n    (hIY : I ⊆ Y) : M.Basis I Y := by\n  have hI' := hI.basis_subset (subset_inter hI.subset hIY) inter_subset_left\n  have hJ' := hJ.basis_subset (subset_inter hJX hJ.subset) inter_subset_right\n  exact hI'.transfer hJ' inter_subset_right hJ\n\n"}
{"name":"Matroid.Indep.exists_basis_subset_union_basis","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X J : Set α\nhI : M.Indep I\nhIX : HasSubset.Subset I X\nhJ : M.Basis J X\n⊢ Exists fun I' => And (M.Basis I' X) (And (HasSubset.Subset I I') (HasSubset.Subset I' (Union.union I J)))","decl":"theorem Indep.exists_basis_subset_union_basis (hI : M.Indep I) (hIX : I ⊆ X) (hJ : M.Basis J X) :\n    ∃ I', M.Basis I' X ∧ I ⊆ I' ∧ I' ⊆ I ∪ J := by\n  obtain ⟨I', hI', hII', hI'IJ⟩ :=\n    (hI.indep_restrict_of_subset hIX).exists_base_subset_union_base (Basis.base_restrict hJ)\n  rw [base_restrict_iff] at hI'\n  exact ⟨I', hI', hII', hI'IJ⟩\n\n"}
{"name":"Matroid.Indep.exists_insert_of_not_basis","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X J : Set α\nhI : M.Indep I\nhIX : HasSubset.Subset I X\nhI' : Not (M.Basis I X)\nhJ : M.Basis J X\n⊢ Exists fun e => And (Membership.mem (SDiff.sdiff J I) e) (M.Indep (Insert.insert e I))","decl":"theorem Indep.exists_insert_of_not_basis (hI : M.Indep I) (hIX : I ⊆ X) (hI' : ¬M.Basis I X)\n    (hJ : M.Basis J X) : ∃ e ∈ J \\ I, M.Indep (insert e I) := by\n  rw [← base_restrict_iff] at hI'; rw [← base_restrict_iff] at hJ\n  obtain ⟨e, he, hi⟩ := (hI.indep_restrict_of_subset hIX).exists_insert_of_not_base hI' hJ\n  exact ⟨e, he, (restrict_indep_iff.mp hi).1⟩\n\n"}
{"name":"Matroid.Basis.base_of_base_subset","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X B : Set α\nhIX : M.Basis I X\nhB : M.Base B\nhBX : HasSubset.Subset B X\n⊢ M.Base I","decl":"theorem Basis.base_of_base_subset (hIX : M.Basis I X) (hB : M.Base B) (hBX : B ⊆ X) : M.Base I :=\n  hB.base_of_basis_superset hBX hIX\n\n"}
{"name":"Matroid.Basis.exchange","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X J : Set α\ne : α\nhIX : M.Basis I X\nhJX : M.Basis J X\nhe : Membership.mem (SDiff.sdiff I J) e\n⊢ Exists fun f => And (Membership.mem (SDiff.sdiff J I) f) (M.Basis (Insert.insert f (SDiff.sdiff I (Singleton.singleton e))) X)","decl":"theorem Basis.exchange (hIX : M.Basis I X) (hJX : M.Basis J X) (he : e ∈ I \\ J) :\n    ∃ f ∈ J \\ I, M.Basis (insert f (I \\ {e})) X := by\n  obtain ⟨y,hy, h⟩ := hIX.restrict_base.exchange hJX.restrict_base he\n  exact ⟨y, hy, by rwa [base_restrict_iff] at h⟩\n\n"}
{"name":"Matroid.Basis.eq_exchange_of_diff_eq_singleton","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X J : Set α\ne : α\nhI : M.Basis I X\nhJ : M.Basis J X\nhIJ : Eq (SDiff.sdiff I J) (Singleton.singleton e)\n⊢ Exists fun f => And (Membership.mem (SDiff.sdiff J I) f) (Eq J (SDiff.sdiff (Insert.insert f I) (Singleton.singleton e)))","decl":"theorem Basis.eq_exchange_of_diff_eq_singleton (hI : M.Basis I X) (hJ : M.Basis J X)\n    (hIJ : I \\ J = {e}) : ∃ f ∈ J \\ I, J = insert f I \\ {e} := by\n  rw [← base_restrict_iff] at hI hJ; exact hI.eq_exchange_of_diff_eq_singleton hJ hIJ\n\n"}
{"name":"Matroid.Basis'.encard_eq_encard","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X J : Set α\nhI : M.Basis' I X\nhJ : M.Basis' J X\n⊢ Eq I.encard J.encard","decl":"theorem Basis'.encard_eq_encard (hI : M.Basis' I X) (hJ : M.Basis' J X) : I.encard = J.encard := by\n  rw [← base_restrict_iff'] at hI hJ; exact hI.card_eq_card_of_base hJ\n\n"}
{"name":"Matroid.Basis.encard_eq_encard","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI X J : Set α\nhI : M.Basis I X\nhJ : M.Basis J X\n⊢ Eq I.encard J.encard","decl":"theorem Basis.encard_eq_encard (hI : M.Basis I X) (hJ : M.Basis J X) : I.encard = J.encard :=\n  hI.basis'.encard_eq_encard hJ.basis'\n\n"}
{"name":"Matroid.Indep.augment","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI J : Set α\nhI : M.Indep I\nhJ : M.Indep J\nhIJ : LT.lt I.encard J.encard\n⊢ Exists fun e => And (Membership.mem (SDiff.sdiff J I) e) (M.Indep (Insert.insert e I))","decl":"/-- Any independent set can be extended into a larger independent set. -/\ntheorem Indep.augment (hI : M.Indep I) (hJ : M.Indep J) (hIJ : I.encard < J.encard) :\n    ∃ e ∈ J \\ I, M.Indep (insert e I) := by\n  by_contra! he\n  have hb : M.Basis I (I ∪ J) := by\n    simp_rw [hI.basis_iff_forall_insert_dep subset_union_left, union_diff_left, mem_diff,\n      and_imp, dep_iff, insert_subset_iff, and_iff_left hI.subset_ground]\n    exact fun e heJ heI ↦ ⟨he e ⟨heJ, heI⟩, hJ.subset_ground heJ⟩\n  obtain ⟨J', hJ', hJJ'⟩ := hJ.subset_basis_of_subset I.subset_union_right\n  rw [← hJ'.encard_eq_encard hb] at hIJ\n  exact hIJ.not_le (encard_mono hJJ')\n\n"}
{"name":"Matroid.Indep.augment_finset","module":"Mathlib.Data.Matroid.Restrict","initialProofState":"α : Type u_1\nM : Matroid α\nI J : Finset α\nhI : M.Indep ↑I\nhJ : M.Indep ↑J\nhIJ : LT.lt I.card J.card\n⊢ Exists fun e => And (Membership.mem J e) (And (Not (Membership.mem I e)) (M.Indep (Insert.insert e ↑I)))","decl":"lemma Indep.augment_finset {I J : Finset α} (hI : M.Indep I) (hJ : M.Indep J)\n    (hIJ : I.card < J.card) : ∃ e ∈ J, e ∉ I ∧ M.Indep (insert e I) := by\n  obtain ⟨x, hx, hxI⟩ := hI.augment hJ (by simpa [encard_eq_coe_toFinset_card] )\n  simp only [mem_diff, Finset.mem_coe] at hx\n  exact ⟨x, hx.1, hx.2, hxI⟩\n\n"}
