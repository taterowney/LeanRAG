{"name":"Nat.ModEq.refl","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a : Nat\n⊢ n.ModEq a a","decl":"@[refl]\nprotected theorem refl (a : ℕ) : a ≡ a [MOD n] := rfl\n\n"}
{"name":"Nat.ModEq.rfl","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a : Nat\n⊢ n.ModEq a a","decl":"protected theorem rfl : a ≡ a [MOD n] :=\n  ModEq.refl _\n\n"}
{"name":"Nat.ModEq.instIsRefl","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n : Nat\n⊢ IsRefl Nat n.ModEq","decl":"instance : IsRefl _ (ModEq n) :=\n  ⟨ModEq.refl⟩\n\n"}
{"name":"Nat.ModEq.symm","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b : Nat\na✝ : n.ModEq a b\n⊢ n.ModEq b a","decl":"@[symm]\nprotected theorem symm : a ≡ b [MOD n] → b ≡ a [MOD n] :=\n  Eq.symm\n\n"}
{"name":"Nat.ModEq.trans","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c : Nat\na✝¹ : n.ModEq a b\na✝ : n.ModEq b c\n⊢ n.ModEq a c","decl":"@[trans]\nprotected theorem trans : a ≡ b [MOD n] → b ≡ c [MOD n] → a ≡ c [MOD n] :=\n  Eq.trans\n\n"}
{"name":"Nat.ModEq.comm","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b : Nat\n⊢ Iff (n.ModEq a b) (n.ModEq b a)","decl":"protected theorem comm : a ≡ b [MOD n] ↔ b ≡ a [MOD n] :=\n  ⟨ModEq.symm, ModEq.symm⟩\n\n"}
{"name":"Nat.modEq_zero_iff_dvd","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a : Nat\n⊢ Iff (n.ModEq a 0) (Dvd.dvd n a)","decl":"theorem modEq_zero_iff_dvd : a ≡ 0 [MOD n] ↔ n ∣ a := by rw [ModEq, zero_mod, dvd_iff_mod_eq_zero]\n\n"}
{"name":"Dvd.dvd.modEq_zero_nat","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a : Nat\nh : Dvd.dvd n a\n⊢ n.ModEq a 0","decl":"theorem _root_.Dvd.dvd.modEq_zero_nat (h : n ∣ a) : a ≡ 0 [MOD n] :=\n  modEq_zero_iff_dvd.2 h\n\n"}
{"name":"Dvd.dvd.zero_modEq_nat","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a : Nat\nh : Dvd.dvd n a\n⊢ n.ModEq 0 a","decl":"theorem _root_.Dvd.dvd.zero_modEq_nat (h : n ∣ a) : 0 ≡ a [MOD n] :=\n  h.modEq_zero_nat.symm\n\n"}
{"name":"Nat.modEq_iff_dvd","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b : Nat\n⊢ Iff (n.ModEq a b) (Dvd.dvd (↑n) (HSub.hSub ↑b ↑a))","decl":"theorem modEq_iff_dvd : a ≡ b [MOD n] ↔ (n : ℤ) ∣ b - a := by\n  rw [ModEq, eq_comm, ← Int.natCast_inj, Int.natCast_mod, Int.natCast_mod,\n    Int.emod_eq_emod_iff_emod_sub_eq_zero, Int.dvd_iff_emod_eq_zero]\n\n"}
{"name":"Nat.ModEq.dvd","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b : Nat\na✝ : n.ModEq a b\n⊢ Dvd.dvd (↑n) (HSub.hSub ↑b ↑a)","decl":"alias ⟨ModEq.dvd, modEq_of_dvd⟩ := modEq_iff_dvd\n\n"}
{"name":"Nat.modEq_of_dvd","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b : Nat\na✝ : Dvd.dvd (↑n) (HSub.hSub ↑b ↑a)\n⊢ n.ModEq a b","decl":"alias ⟨ModEq.dvd, modEq_of_dvd⟩ := modEq_iff_dvd\n\n"}
{"name":"Nat.modEq_iff_dvd'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b : Nat\nh : LE.le a b\n⊢ Iff (n.ModEq a b) (Dvd.dvd n (HSub.hSub b a))","decl":"/-- A variant of `modEq_iff_dvd` with `Nat` divisibility -/\ntheorem modEq_iff_dvd' (h : a ≤ b) : a ≡ b [MOD n] ↔ n ∣ b - a := by\n  rw [modEq_iff_dvd, ← Int.natCast_dvd_natCast, Int.ofNat_sub h]\n\n"}
{"name":"Nat.mod_modEq","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a n : Nat\n⊢ n.ModEq (HMod.hMod a n) a","decl":"theorem mod_modEq (a n) : a % n ≡ a [MOD n] :=\n  mod_mod _ _\n\n"}
{"name":"Nat.ModEq.of_dvd","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m n a b : Nat\nd : Dvd.dvd m n\nh : n.ModEq a b\n⊢ m.ModEq a b","decl":"lemma of_dvd (d : m ∣ n) (h : a ≡ b [MOD n]) : a ≡ b [MOD m] :=\n  modEq_of_dvd <| Int.ofNat_dvd.mpr d |>.trans h.dvd\n\n"}
{"name":"Nat.ModEq.mul_left'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c : Nat\nh : n.ModEq a b\n⊢ (HMul.hMul c n).ModEq (HMul.hMul c a) (HMul.hMul c b)","decl":"protected theorem mul_left' (c : ℕ) (h : a ≡ b [MOD n]) : c * a ≡ c * b [MOD c * n] := by\n  unfold ModEq at *; rw [mul_mod_mul_left, mul_mod_mul_left, h]\n\n"}
{"name":"Nat.ModEq.mul_left","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c : Nat\nh : n.ModEq a b\n⊢ n.ModEq (HMul.hMul c a) (HMul.hMul c b)","decl":"@[gcongr]\nprotected theorem mul_left (c : ℕ) (h : a ≡ b [MOD n]) : c * a ≡ c * b [MOD n] :=\n  (h.mul_left' _).of_dvd (dvd_mul_left _ _)\n\n"}
{"name":"Nat.ModEq.mul_right'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c : Nat\nh : n.ModEq a b\n⊢ (HMul.hMul n c).ModEq (HMul.hMul a c) (HMul.hMul b c)","decl":"protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by\n  rw [mul_comm a, mul_comm b, mul_comm n]; exact h.mul_left' c\n\n"}
{"name":"Nat.ModEq.mul_right","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c : Nat\nh : n.ModEq a b\n⊢ n.ModEq (HMul.hMul a c) (HMul.hMul b c)","decl":"@[gcongr]\nprotected theorem mul_right (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n] := by\n  rw [mul_comm a, mul_comm b]; exact h.mul_left c\n\n"}
{"name":"Nat.ModEq.mul","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c d : Nat\nh₁ : n.ModEq a b\nh₂ : n.ModEq c d\n⊢ n.ModEq (HMul.hMul a c) (HMul.hMul b d)","decl":"@[gcongr]\nprotected theorem mul (h₁ : a ≡ b [MOD n]) (h₂ : c ≡ d [MOD n]) : a * c ≡ b * d [MOD n] :=\n  (h₂.mul_left _).trans (h₁.mul_right _)\n\n"}
{"name":"Nat.ModEq.pow","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b m : Nat\nh : n.ModEq a b\n⊢ n.ModEq (HPow.hPow a m) (HPow.hPow b m)","decl":"@[gcongr]\nprotected theorem pow (m : ℕ) (h : a ≡ b [MOD n]) : a ^ m ≡ b ^ m [MOD n] := by\n  induction m with\n  | zero => rfl\n  | succ d hd =>\n    rw [Nat.pow_succ, Nat.pow_succ]\n    exact hd.mul h\n\n"}
{"name":"Nat.ModEq.add","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c d : Nat\nh₁ : n.ModEq a b\nh₂ : n.ModEq c d\n⊢ n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[gcongr]\nprotected theorem add (h₁ : a ≡ b [MOD n]) (h₂ : c ≡ d [MOD n]) : a + c ≡ b + d [MOD n] := by\n  rw [modEq_iff_dvd, Int.ofNat_add, Int.ofNat_add, add_sub_add_comm]\n  exact Int.dvd_add h₁.dvd h₂.dvd\n\n"}
{"name":"Nat.ModEq.add_left","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c : Nat\nh : n.ModEq a b\n⊢ n.ModEq (HAdd.hAdd c a) (HAdd.hAdd c b)","decl":"@[gcongr]\nprotected theorem add_left (c : ℕ) (h : a ≡ b [MOD n]) : c + a ≡ c + b [MOD n] :=\n  ModEq.rfl.add h\n\n"}
{"name":"Nat.ModEq.add_right","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c : Nat\nh : n.ModEq a b\n⊢ n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b c)","decl":"@[gcongr]\nprotected theorem add_right (c : ℕ) (h : a ≡ b [MOD n]) : a + c ≡ b + c [MOD n] :=\n  h.add ModEq.rfl\n\n"}
{"name":"Nat.ModEq.add_left_cancel","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c d : Nat\nh₁ : n.ModEq a b\nh₂ : n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b d)\n⊢ n.ModEq c d","decl":"protected theorem add_left_cancel (h₁ : a ≡ b [MOD n]) (h₂ : a + c ≡ b + d [MOD n]) :\n    c ≡ d [MOD n] := by\n  simp only [modEq_iff_dvd, Int.ofNat_add] at *\n  rw [add_sub_add_comm] at h₂\n  convert Int.dvd_sub h₂ h₁ using 1\n  rw [add_sub_cancel_left]\n\n"}
{"name":"Nat.ModEq.add_left_cancel'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c : Nat\nh : n.ModEq (HAdd.hAdd c a) (HAdd.hAdd c b)\n⊢ n.ModEq a b","decl":"protected theorem add_left_cancel' (c : ℕ) (h : c + a ≡ c + b [MOD n]) : a ≡ b [MOD n] :=\n  ModEq.rfl.add_left_cancel h\n\n"}
{"name":"Nat.ModEq.add_right_cancel","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c d : Nat\nh₁ : n.ModEq c d\nh₂ : n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b d)\n⊢ n.ModEq a b","decl":"protected theorem add_right_cancel (h₁ : c ≡ d [MOD n]) (h₂ : a + c ≡ b + d [MOD n]) :\n    a ≡ b [MOD n] := by\n  rw [add_comm a, add_comm b] at h₂\n  exact h₁.add_left_cancel h₂\n\n"}
{"name":"Nat.ModEq.add_right_cancel'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b c : Nat\nh : n.ModEq (HAdd.hAdd a c) (HAdd.hAdd b c)\n⊢ n.ModEq a b","decl":"protected theorem add_right_cancel' (c : ℕ) (h : a + c ≡ b + c [MOD n]) : a ≡ b [MOD n] :=\n  ModEq.rfl.add_right_cancel h\n\n"}
{"name":"Nat.ModEq.mul_left_cancel'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c m : Nat\nhc : Ne c 0\na✝ : (HMul.hMul c m).ModEq (HMul.hMul c a) (HMul.hMul c b)\n⊢ m.ModEq a b","decl":"/-- Cancel left multiplication on both sides of the `≡` and in the modulus.\n\nFor cancelling left multiplication in the modulus, see `Nat.ModEq.of_mul_left`. -/\nprotected theorem mul_left_cancel' {a b c m : ℕ} (hc : c ≠ 0) :\n    c * a ≡ c * b [MOD c * m] → a ≡ b [MOD m] := by\n  simp only [modEq_iff_dvd, Int.natCast_mul, ← Int.mul_sub]\n  exact fun h => (Int.dvd_of_mul_dvd_mul_left (Int.ofNat_ne_zero.mpr hc) h)\n\n"}
{"name":"Nat.ModEq.mul_left_cancel_iff'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c m : Nat\nhc : Ne c 0\n⊢ Iff ((HMul.hMul c m).ModEq (HMul.hMul c a) (HMul.hMul c b)) (m.ModEq a b)","decl":"protected theorem mul_left_cancel_iff' {a b c m : ℕ} (hc : c ≠ 0) :\n    c * a ≡ c * b [MOD c * m] ↔ a ≡ b [MOD m] :=\n  ⟨ModEq.mul_left_cancel' hc, ModEq.mul_left' _⟩\n\n"}
{"name":"Nat.ModEq.mul_right_cancel'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c m : Nat\nhc : Ne c 0\na✝ : (HMul.hMul m c).ModEq (HMul.hMul a c) (HMul.hMul b c)\n⊢ m.ModEq a b","decl":"/-- Cancel right multiplication on both sides of the `≡` and in the modulus.\n\nFor cancelling right multiplication in the modulus, see `Nat.ModEq.of_mul_right`. -/\nprotected theorem mul_right_cancel' {a b c m : ℕ} (hc : c ≠ 0) :\n    a * c ≡ b * c [MOD m * c] → a ≡ b [MOD m] := by\n  simp only [modEq_iff_dvd, Int.natCast_mul, ← Int.sub_mul]\n  exact fun h => (Int.dvd_of_mul_dvd_mul_right (Int.ofNat_ne_zero.mpr hc) h)\n\n"}
{"name":"Nat.ModEq.mul_right_cancel_iff'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c m : Nat\nhc : Ne c 0\n⊢ Iff ((HMul.hMul m c).ModEq (HMul.hMul a c) (HMul.hMul b c)) (m.ModEq a b)","decl":"protected theorem mul_right_cancel_iff' {a b c m : ℕ} (hc : c ≠ 0) :\n    a * c ≡ b * c [MOD m * c] ↔ a ≡ b [MOD m] :=\n  ⟨ModEq.mul_right_cancel' hc, ModEq.mul_right' _⟩\n\n"}
{"name":"Nat.ModEq.of_mul_left","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b m : Nat\nh : (HMul.hMul m n).ModEq a b\n⊢ n.ModEq a b","decl":"/-- Cancel left multiplication in the modulus.\n\nFor cancelling left multiplication on both sides of the `≡`, see `nat.modeq.mul_left_cancel'`. -/\nlemma of_mul_left (m : ℕ) (h : a ≡ b [MOD m * n]) : a ≡ b [MOD n] := by\n  rw [modEq_iff_dvd] at *\n  exact (dvd_mul_left (n : ℤ) (m : ℤ)).trans h\n\n"}
{"name":"Nat.ModEq.of_mul_right","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a b m : Nat\na✝ : (HMul.hMul n m).ModEq a b\n⊢ n.ModEq a b","decl":"/-- Cancel right multiplication in the modulus.\n\nFor cancelling right multiplication on both sides of the `≡`, see `nat.modeq.mul_right_cancel'`. -/\nlemma of_mul_right (m : ℕ) : a ≡ b [MOD n * m] → a ≡ b [MOD n] := mul_comm m n ▸ of_mul_left _\n\n"}
{"name":"Nat.ModEq.of_div","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b c : Nat\nh : (HDiv.hDiv m c).ModEq (HDiv.hDiv a c) (HDiv.hDiv b c)\nha✝¹ : Dvd.dvd c a\nha✝ : Dvd.dvd c b\nha : Dvd.dvd c m\n⊢ m.ModEq a b","decl":"theorem of_div (h : a / c ≡ b / c [MOD m / c]) (ha : c ∣ a) (ha : c ∣ b) (ha : c ∣ m) :\n    a ≡ b [MOD m] := by convert h.mul_left' c <;> rwa [Nat.mul_div_cancel']\n\n"}
{"name":"Nat.modEq_sub","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b : Nat\nh : LE.le b a\n⊢ (HSub.hSub a b).ModEq a b","decl":"lemma modEq_sub (h : b ≤ a) : a ≡ b [MOD a - b] := (modEq_of_dvd <| by rw [Int.ofNat_sub h]).symm\n\n"}
{"name":"Nat.modEq_one","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b : Nat\n⊢ Nat.ModEq 1 a b","decl":"lemma modEq_one : a ≡ b [MOD 1] := modEq_of_dvd <| one_dvd _\n\n"}
{"name":"Nat.modEq_zero_iff","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b : Nat\n⊢ Iff (Nat.ModEq 0 a b) (Eq a b)","decl":"@[simp] lemma modEq_zero_iff : a ≡ b [MOD 0] ↔ a = b := by rw [ModEq, mod_zero, mod_zero]\n\n"}
{"name":"Nat.add_modEq_left","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a : Nat\n⊢ n.ModEq (HAdd.hAdd n a) a","decl":"@[simp] lemma add_modEq_left : n + a ≡ a [MOD n] := by rw [ModEq, add_mod_left]\n\n"}
{"name":"Nat.add_modEq_right","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n a : Nat\n⊢ n.ModEq (HAdd.hAdd a n) a","decl":"@[simp] lemma add_modEq_right : a + n ≡ a [MOD n] := by rw [ModEq, add_mod_right]\n\n"}
{"name":"Nat.ModEq.le_of_lt_add","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b : Nat\nh1 : m.ModEq a b\nh2 : LT.lt a (HAdd.hAdd b m)\n⊢ LE.le a b","decl":"theorem le_of_lt_add (h1 : a ≡ b [MOD m]) (h2 : a < b + m) : a ≤ b :=\n  (le_total a b).elim id fun h3 =>\n    Nat.le_of_sub_eq_zero\n      (eq_zero_of_dvd_of_lt ((modEq_iff_dvd' h3).mp h1.symm) (by omega))\n\n"}
{"name":"Nat.ModEq.add_le_of_lt","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b : Nat\nh1 : m.ModEq a b\nh2 : LT.lt a b\n⊢ LE.le (HAdd.hAdd a m) b","decl":"theorem add_le_of_lt (h1 : a ≡ b [MOD m]) (h2 : a < b) : a + m ≤ b :=\n  le_of_lt_add (add_modEq_right.trans h1) (by omega)\n\n"}
{"name":"Nat.ModEq.dvd_iff","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b d : Nat\nh : m.ModEq a b\nhdm : Dvd.dvd d m\n⊢ Iff (Dvd.dvd d a) (Dvd.dvd d b)","decl":"theorem dvd_iff (h : a ≡ b [MOD m]) (hdm : d ∣ m) : d ∣ a ↔ d ∣ b := by\n  simp only [← modEq_zero_iff_dvd]\n  replace h := h.of_dvd hdm\n  exact ⟨h.symm.trans, h.trans⟩\n\n"}
{"name":"Nat.ModEq.gcd_eq","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b : Nat\nh : m.ModEq a b\n⊢ Eq (a.gcd m) (b.gcd m)","decl":"theorem gcd_eq (h : a ≡ b [MOD m]) : gcd a m = gcd b m := by\n  have h1 := gcd_dvd_right a m\n  have h2 := gcd_dvd_right b m\n  exact\n    dvd_antisymm (dvd_gcd ((h.dvd_iff h1).mp (gcd_dvd_left a m)) h1)\n      (dvd_gcd ((h.dvd_iff h2).mpr (gcd_dvd_left b m)) h2)\n\n"}
{"name":"Nat.ModEq.eq_of_abs_lt","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b : Nat\nh : m.ModEq a b\nh2 : LT.lt (abs (HSub.hSub ↑b ↑a)) ↑m\n⊢ Eq a b","decl":"lemma eq_of_abs_lt (h : a ≡ b [MOD m]) (h2 : |(b : ℤ) - a| < m) : a = b := by\n  apply Int.ofNat.inj\n  rw [eq_comm, ← sub_eq_zero]\n  exact Int.eq_zero_of_abs_lt_dvd h.dvd h2\n\n"}
{"name":"Nat.ModEq.eq_of_lt_of_lt","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b : Nat\nh : m.ModEq a b\nha : LT.lt a m\nhb : LT.lt b m\n⊢ Eq a b","decl":"lemma eq_of_lt_of_lt (h : a ≡ b [MOD m]) (ha : a < m) (hb : b < m) : a = b :=\n  h.eq_of_abs_lt <| Int.abs_sub_lt_of_lt_lt ha hb\n\n"}
{"name":"Nat.ModEq.cancel_left_div_gcd","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b c : Nat\nhm : LT.lt 0 m\nh : m.ModEq (HMul.hMul c a) (HMul.hMul c b)\n⊢ (HDiv.hDiv m (m.gcd c)).ModEq a b","decl":"/-- To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c` -/\nlemma cancel_left_div_gcd (hm : 0 < m) (h : c * a ≡ c * b [MOD m]) :  a ≡ b [MOD m / gcd m c] := by\n  let d := gcd m c\n  have hmd := gcd_dvd_left m c\n  have hcd := gcd_dvd_right m c\n  rw [modEq_iff_dvd]\n  refine @Int.dvd_of_dvd_mul_right_of_gcd_one (m / d) (c / d) (b - a) ?_ ?_\n  · show (m / d : ℤ) ∣ c / d * (b - a)\n    rw [mul_comm, ← Int.mul_ediv_assoc (b - a) (Int.natCast_dvd_natCast.mpr hcd), mul_comm]\n    apply Int.ediv_dvd_ediv (Int.natCast_dvd_natCast.mpr hmd)\n    rw [Int.mul_sub]\n    exact modEq_iff_dvd.mp h\n  · show Int.gcd (m / d) (c / d) = 1\n    simp only [d, ← Int.natCast_div, Int.gcd_natCast_natCast (m / d) (c / d),\n      gcd_div hmd hcd, Nat.div_self (gcd_pos_of_pos_left c hm)]\n\n"}
{"name":"Nat.ModEq.cancel_right_div_gcd","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b c : Nat\nhm : LT.lt 0 m\nh : m.ModEq (HMul.hMul a c) (HMul.hMul b c)\n⊢ (HDiv.hDiv m (m.gcd c)).ModEq a b","decl":"/-- To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c` -/\nlemma cancel_right_div_gcd (hm : 0 < m) (h : a * c ≡ b * c [MOD m]) : a ≡ b [MOD m / gcd m c] := by\n  apply cancel_left_div_gcd hm\n  simpa [mul_comm] using h\n\n"}
{"name":"Nat.ModEq.cancel_left_div_gcd'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b c d : Nat\nhm : LT.lt 0 m\nhcd : m.ModEq c d\nh : m.ModEq (HMul.hMul c a) (HMul.hMul d b)\n⊢ (HDiv.hDiv m (m.gcd c)).ModEq a b","decl":"lemma cancel_left_div_gcd' (hm : 0 < m) (hcd : c ≡ d [MOD m]) (h : c * a ≡ d * b [MOD m]) :\n    a ≡ b [MOD m / gcd m c] :=\n  (h.trans <| hcd.symm.mul_right b).cancel_left_div_gcd hm\n\n"}
{"name":"Nat.ModEq.cancel_right_div_gcd'","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b c d : Nat\nhm : LT.lt 0 m\nhcd : m.ModEq c d\nh : m.ModEq (HMul.hMul a c) (HMul.hMul b d)\n⊢ (HDiv.hDiv m (m.gcd c)).ModEq a b","decl":"lemma cancel_right_div_gcd' (hm : 0 < m) (hcd : c ≡ d [MOD m]) (h : a * c ≡ b * d [MOD m]) :\n    a ≡ b [MOD m / gcd m c] :=\n  (h.trans <| hcd.symm.mul_left b).cancel_right_div_gcd hm\n\n"}
{"name":"Nat.ModEq.cancel_left_of_coprime","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b c : Nat\nhmc : Eq (m.gcd c) 1\nh : m.ModEq (HMul.hMul c a) (HMul.hMul c b)\n⊢ m.ModEq a b","decl":"/-- A common factor that's coprime with the modulus can be cancelled from a `ModEq` -/\nlemma cancel_left_of_coprime (hmc : gcd m c = 1) (h : c * a ≡ c * b [MOD m]) : a ≡ b [MOD m] := by\n  rcases m.eq_zero_or_pos with (rfl | hm)\n  · simp only [gcd_zero_left] at hmc\n    simp only [gcd_zero_left, hmc, one_mul, modEq_zero_iff] at h\n    subst h\n    rfl\n  simpa [hmc] using h.cancel_left_div_gcd hm\n\n"}
{"name":"Nat.ModEq.cancel_right_of_coprime","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m a b c : Nat\nhmc : Eq (m.gcd c) 1\nh : m.ModEq (HMul.hMul a c) (HMul.hMul b c)\n⊢ m.ModEq a b","decl":"/-- A common factor that's coprime with the modulus can be cancelled from a `ModEq` -/\nlemma cancel_right_of_coprime (hmc : gcd m c = 1) (h : a * c ≡ b * c [MOD m]) : a ≡ b [MOD m] :=\n  cancel_left_of_coprime hmc <| by simpa [mul_comm] using h\n\n"}
{"name":"Nat.chineseRemainder'_lt_lcm","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m n a b : Nat\nh : (n.gcd m).ModEq a b\nhn : Ne n 0\nhm : Ne m 0\n⊢ LT.lt (↑(Nat.chineseRemainder' h)) (n.lcm m)","decl":"theorem chineseRemainder'_lt_lcm (h : a ≡ b [MOD gcd n m]) (hn : n ≠ 0) (hm : m ≠ 0) :\n    ↑(chineseRemainder' h) < lcm n m := by\n  dsimp only [chineseRemainder']\n  rw [dif_neg hn, dif_neg hm, Subtype.coe_mk, xgcd_val, ← Int.toNat_natCast (lcm n m)]\n  have lcm_pos := Int.natCast_pos.mpr (Nat.pos_of_ne_zero (lcm_ne_zero hn hm))\n  exact (Int.toNat_lt_toNat lcm_pos).mpr (Int.emod_lt_of_pos _ lcm_pos)\n\n"}
{"name":"Nat.chineseRemainder_lt_mul","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m n : Nat\nco : n.Coprime m\na b : Nat\nhn : Ne n 0\nhm : Ne m 0\n⊢ LT.lt (↑(Nat.chineseRemainder co a b)) (HMul.hMul n m)","decl":"theorem chineseRemainder_lt_mul (co : n.Coprime m) (a b : ℕ) (hn : n ≠ 0) (hm : m ≠ 0) :\n    ↑(chineseRemainder co a b) < n * m :=\n  lt_of_lt_of_le (chineseRemainder'_lt_lcm _ hn hm) (le_of_eq co.lcm_eq_mul)\n\n"}
{"name":"Nat.mod_lcm","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m n a b : Nat\nhn : n.ModEq a b\nhm : m.ModEq a b\n⊢ (n.lcm m).ModEq a b","decl":"theorem mod_lcm (hn : a ≡ b [MOD n]) (hm : a ≡ b [MOD m]) : a ≡ b [MOD lcm n m] :=\n  Nat.modEq_iff_dvd.mpr <| Int.lcm_dvd (Nat.modEq_iff_dvd.mp hn) (Nat.modEq_iff_dvd.mp hm)\n\n"}
{"name":"Nat.chineseRemainder_modEq_unique","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m n : Nat\nco : n.Coprime m\na b z : Nat\nhzan : n.ModEq z a\nhzbm : m.ModEq z b\n⊢ (HMul.hMul n m).ModEq z ↑(Nat.chineseRemainder co a b)","decl":"theorem chineseRemainder_modEq_unique (co : n.Coprime m) {a b z}\n    (hzan : z ≡ a [MOD n]) (hzbm : z ≡ b [MOD m]) : z ≡ chineseRemainder co a b [MOD n*m] := by\n  simpa [Nat.Coprime.lcm_eq_mul co] using\n    mod_lcm (hzan.trans ((chineseRemainder co a b).prop.1).symm)\n      (hzbm.trans ((chineseRemainder co a b).prop.2).symm)\n\n"}
{"name":"Nat.modEq_and_modEq_iff_modEq_mul","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b m n : Nat\nhmn : m.Coprime n\n⊢ Iff (And (m.ModEq a b) (n.ModEq a b)) ((HMul.hMul m n).ModEq a b)","decl":"theorem modEq_and_modEq_iff_modEq_mul {a b m n : ℕ} (hmn : m.Coprime n) :\n    a ≡ b [MOD m] ∧ a ≡ b [MOD n] ↔ a ≡ b [MOD m * n] :=\n  ⟨fun h => by\n    rw [Nat.modEq_iff_dvd, Nat.modEq_iff_dvd, ← Int.dvd_natAbs, Int.natCast_dvd_natCast,\n      ← Int.dvd_natAbs, Int.natCast_dvd_natCast] at h\n    rw [Nat.modEq_iff_dvd, ← Int.dvd_natAbs, Int.natCast_dvd_natCast]\n    exact hmn.mul_dvd_of_dvd_of_dvd h.1 h.2,\n   fun h => ⟨h.of_mul_right _, h.of_mul_left _⟩⟩\n\n"}
{"name":"Nat.coprime_of_mul_modEq_one","module":"Mathlib.Data.Nat.ModEq","initialProofState":"b a n : Nat\nh : n.ModEq (HMul.hMul a b) 1\n⊢ a.Coprime n","decl":"theorem coprime_of_mul_modEq_one (b : ℕ) {a n : ℕ} (h : a * b ≡ 1 [MOD n]) : a.Coprime n := by\n  obtain ⟨g, hh⟩ := Nat.gcd_dvd_right a n\n  rw [Nat.coprime_iff_gcd_eq_one, ← Nat.dvd_one, ← Nat.modEq_zero_iff_dvd]\n  calc\n    1 ≡ a * b [MOD a.gcd n] := (hh ▸ h).symm.of_mul_right g\n    _ ≡ 0 * b [MOD a.gcd n] := (Nat.modEq_zero_iff_dvd.mpr (Nat.gcd_dvd_left _ _)).mul_right b\n    _ = 0 := by rw [zero_mul]\n\n"}
{"name":"Nat.add_mod_add_ite","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\n⊢ Eq (HAdd.hAdd (HMod.hMod (HAdd.hAdd a b) c) (ite (LE.le c (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c))) c 0)) (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c))","decl":"theorem add_mod_add_ite (a b c : ℕ) :\n    ((a + b) % c + if c ≤ a % c + b % c then c else 0) = a % c + b % c :=\n  have : (a + b) % c = (a % c + b % c) % c := ((mod_modEq _ _).add <| mod_modEq _ _).symm\n  if hc0 : c = 0 then by simp [hc0, Nat.mod_zero]\n  else by\n    rw [this]\n    split_ifs with h\n    · have h2 : (a % c + b % c) / c < 2 :=\n        Nat.div_lt_of_lt_mul\n          (by\n            rw [mul_two]\n            exact\n              add_lt_add (Nat.mod_lt _ (Nat.pos_of_ne_zero hc0))\n                (Nat.mod_lt _ (Nat.pos_of_ne_zero hc0)))\n      have h0 : 0 < (a % c + b % c) / c := Nat.div_pos h (Nat.pos_of_ne_zero hc0)\n      rw [← @add_right_cancel_iff _ _ _ (c * ((a % c + b % c) / c)), add_comm _ c, add_assoc,\n        mod_add_div, le_antisymm (le_of_lt_succ h2) h0, mul_one, add_comm]\n    · rw [Nat.mod_eq_of_lt (lt_of_not_ge h), add_zero]\n\n"}
{"name":"Nat.add_mod_of_add_mod_lt","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\nhc : LT.lt (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c)) c\n⊢ Eq (HMod.hMod (HAdd.hAdd a b) c) (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c))","decl":"theorem add_mod_of_add_mod_lt {a b c : ℕ} (hc : a % c + b % c < c) :\n    (a + b) % c = a % c + b % c := by rw [← add_mod_add_ite, if_neg (not_le_of_lt hc), add_zero]\n\n"}
{"name":"Nat.add_mod_add_of_le_add_mod","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\nhc : LE.le c (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c))\n⊢ Eq (HAdd.hAdd (HMod.hMod (HAdd.hAdd a b) c) c) (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c))","decl":"theorem add_mod_add_of_le_add_mod {a b c : ℕ} (hc : c ≤ a % c + b % c) :\n    (a + b) % c + c = a % c + b % c := by rw [← add_mod_add_ite, if_pos hc]\n\n"}
{"name":"Nat.add_div","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\nhc0 : LT.lt 0 c\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) c) (HAdd.hAdd (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c)) (ite (LE.le c (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c))) 1 0))","decl":"theorem add_div {a b c : ℕ} (hc0 : 0 < c) :\n    (a + b) / c = a / c + b / c + if c ≤ a % c + b % c then 1 else 0 := by\n  rw [← mul_right_inj' hc0.ne', ← @add_left_cancel_iff _ _ _ ((a + b) % c + a % c + b % c)]\n  suffices\n    (a + b) % c + c * ((a + b) / c) + a % c + b % c =\n      (a % c + c * (a / c) + (b % c + c * (b / c)) + c * if c ≤ a % c + b % c then 1 else 0) +\n        (a + b) % c\n    by simpa only [mul_add, add_comm, add_left_comm, add_assoc]\n  rw [mod_add_div, mod_add_div, mod_add_div, mul_ite, add_assoc, add_assoc]\n  conv_lhs => rw [← add_mod_add_ite]\n  simp only [mul_one, mul_zero]\n  ac_rfl\n\n"}
{"name":"Nat.add_div_eq_of_add_mod_lt","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\nhc : LT.lt (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c)) c\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) c) (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"theorem add_div_eq_of_add_mod_lt {a b c : ℕ} (hc : a % c + b % c < c) :\n    (a + b) / c = a / c + b / c :=\n  if hc0 : c = 0 then by simp [hc0]\n  else by rw [add_div (Nat.pos_of_ne_zero hc0), if_neg (not_le_of_lt hc), add_zero]\n\n"}
{"name":"Nat.add_div_of_dvd_right","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\nhca : Dvd.dvd c a\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) c) (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"protected theorem add_div_of_dvd_right {a b c : ℕ} (hca : c ∣ a) : (a + b) / c = a / c + b / c :=\n  if h : c = 0 then by simp [h]\n  else\n    add_div_eq_of_add_mod_lt\n      (by\n        rw [Nat.mod_eq_zero_of_dvd hca, zero_add]\n        exact Nat.mod_lt _ (zero_lt_of_ne_zero h))\n\n"}
{"name":"Nat.add_div_of_dvd_left","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\nhca : Dvd.dvd c b\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) c) (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"protected theorem add_div_of_dvd_left {a b c : ℕ} (hca : c ∣ b) : (a + b) / c = a / c + b / c := by\n  rwa [add_comm, Nat.add_div_of_dvd_right, add_comm]\n\n"}
{"name":"Nat.add_div_eq_of_le_mod_add_mod","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\nhc : LE.le c (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c))\nhc0 : LT.lt 0 c\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) c) (HAdd.hAdd (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c)) 1)","decl":"theorem add_div_eq_of_le_mod_add_mod {a b c : ℕ} (hc : c ≤ a % c + b % c) (hc0 : 0 < c) :\n    (a + b) / c = a / c + b / c + 1 := by rw [add_div hc0, if_pos hc]\n\n"}
{"name":"Nat.add_div_le_add_div","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\n⊢ LE.le (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c)) (HDiv.hDiv (HAdd.hAdd a b) c)","decl":"theorem add_div_le_add_div (a b c : ℕ) : a / c + b / c ≤ (a + b) / c :=\n  if hc0 : c = 0 then by simp [hc0]\n  else by rw [Nat.add_div (Nat.pos_of_ne_zero hc0)]; exact Nat.le_add_right _ _\n\n"}
{"name":"Nat.le_mod_add_mod_of_dvd_add_of_not_dvd","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b c : Nat\nh : Dvd.dvd c (HAdd.hAdd a b)\nha : Not (Dvd.dvd c a)\n⊢ LE.le c (HAdd.hAdd (HMod.hMod a c) (HMod.hMod b c))","decl":"theorem le_mod_add_mod_of_dvd_add_of_not_dvd {a b c : ℕ} (h : c ∣ a + b) (ha : ¬c ∣ a) :\n    c ≤ a % c + b % c :=\n  by_contradiction fun hc => by\n    have : (a + b) % c = a % c + b % c := add_mod_of_add_mod_lt (lt_of_not_ge hc)\n    simp_all [dvd_iff_mod_eq_zero]\n\n"}
{"name":"Nat.odd_mul_odd","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n m : Nat\na✝¹ : Eq (HMod.hMod n 2) 1\na✝ : Eq (HMod.hMod m 2) 1\n⊢ Eq (HMod.hMod (HMul.hMul n m) 2) 1","decl":"theorem odd_mul_odd {n m : ℕ} : n % 2 = 1 → m % 2 = 1 → n * m % 2 = 1 := by\n  simpa [Nat.ModEq] using @ModEq.mul 2 n 1 m 1\n\n"}
{"name":"Nat.odd_mul_odd_div_two","module":"Mathlib.Data.Nat.ModEq","initialProofState":"m n : Nat\nhm1 : Eq (HMod.hMod m 2) 1\nhn1 : Eq (HMod.hMod n 2) 1\n⊢ Eq (HDiv.hDiv (HMul.hMul m n) 2) (HAdd.hAdd (HMul.hMul m (HDiv.hDiv n 2)) (HDiv.hDiv m 2))","decl":"theorem odd_mul_odd_div_two {m n : ℕ} (hm1 : m % 2 = 1) (hn1 : n % 2 = 1) :\n    m * n / 2 = m * (n / 2) + m / 2 :=\n  have hn0 : 0 < n := Nat.pos_of_ne_zero fun h => by simp_all\n  mul_right_injective₀ two_ne_zero <| by\n    dsimp\n    rw [mul_add, two_mul_odd_div_two hm1, mul_left_comm, two_mul_odd_div_two hn1,\n      two_mul_odd_div_two (Nat.odd_mul_odd hm1 hn1), Nat.mul_sub, mul_one, ←\n      Nat.add_sub_assoc (by omega), Nat.sub_add_cancel (Nat.le_mul_of_pos_right m hn0)]\n\n"}
{"name":"Nat.odd_of_mod_four_eq_one","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n : Nat\na✝ : Eq (HMod.hMod n 4) 1\n⊢ Eq (HMod.hMod n 2) 1","decl":"theorem odd_of_mod_four_eq_one {n : ℕ} : n % 4 = 1 → n % 2 = 1 := by\n  simpa [ModEq] using @ModEq.of_mul_left 2 n 1 2\n\n"}
{"name":"Nat.odd_of_mod_four_eq_three","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n : Nat\na✝ : Eq (HMod.hMod n 4) 3\n⊢ Eq (HMod.hMod n 2) 1","decl":"theorem odd_of_mod_four_eq_three {n : ℕ} : n % 4 = 3 → n % 2 = 1 := by\n  simpa [ModEq] using @ModEq.of_mul_left 2 n 3 2\n\n"}
{"name":"Nat.odd_mod_four_iff","module":"Mathlib.Data.Nat.ModEq","initialProofState":"n : Nat\n⊢ Iff (Eq (HMod.hMod n 2) 1) (Or (Eq (HMod.hMod n 4) 1) (Eq (HMod.hMod n 4) 3))","decl":"/-- A natural number is odd iff it has residue `1` or `3` mod `4`-/\ntheorem odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n  have help : ∀ m : ℕ, m < 4 → m % 2 = 1 → m = 1 ∨ m = 3 := by decide\n  ⟨fun hn =>\n    help (n % 4) (mod_lt n (by omega)) <| (mod_mod_of_dvd n (by decide : 2 ∣ 4)).trans hn,\n    fun h => Or.elim h odd_of_mod_four_eq_one odd_of_mod_four_eq_three⟩\n\n"}
{"name":"Nat.mod_eq_of_modEq","module":"Mathlib.Data.Nat.ModEq","initialProofState":"a b n : Nat\nh : n.ModEq a b\nhb : LT.lt b n\n⊢ Eq (HMod.hMod a n) b","decl":"lemma mod_eq_of_modEq {a b n} (h : a ≡ b [MOD n]) (hb : b < n) : a % n = b :=\n  Eq.trans h (mod_eq_of_lt hb)\n\n"}
