{"name":"LieAlgebra.lieCharacter_apply_lie","module":"Mathlib.Algebra.Lie.Character","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nχ : LieAlgebra.LieCharacter R L\nx y : L\n⊢ Eq (χ (Bracket.bracket x y)) 0","decl":"theorem lieCharacter_apply_lie (χ : LieCharacter R L) (x y : L) : χ ⁅x, y⁆ = 0 := by\n  rw [LieHom.map_lie, LieRing.of_associative_ring_bracket, mul_comm, sub_self]\n\n"}
{"name":"LieAlgebra.lieCharacter_apply_lie'","module":"Mathlib.Algebra.Lie.Character","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nχ : LieAlgebra.LieCharacter R L\nx y : L\n⊢ Eq (Bracket.bracket (χ x) (χ y)) 0","decl":"@[simp]\ntheorem lieCharacter_apply_lie' (χ : LieCharacter R L) (x y : L) : ⁅χ x, χ y⁆ = 0 := by\n  rw [LieRing.of_associative_ring_bracket, mul_comm, sub_self]\n\n"}
{"name":"LieAlgebra.lieCharacter_apply_of_mem_derived","module":"Mathlib.Algebra.Lie.Character","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nχ : LieAlgebra.LieCharacter R L\nx : L\nh : Membership.mem (LieAlgebra.derivedSeries R L 1) x\n⊢ Eq (χ x) 0","decl":"theorem lieCharacter_apply_of_mem_derived (χ : LieCharacter R L) {x : L}\n    (h : x ∈ derivedSeries R L 1) : χ x = 0 := by\n  rw [derivedSeries_def, derivedSeriesOfIdeal_succ, derivedSeriesOfIdeal_zero, ←\n    LieSubmodule.mem_toSubmodule, LieSubmodule.lieIdeal_oper_eq_linear_span] at h\n  refine Submodule.span_induction ?_ ?_ ?_ ?_ h\n  · rintro y ⟨⟨z, hz⟩, ⟨⟨w, hw⟩, rfl⟩⟩; apply lieCharacter_apply_lie\n  · exact χ.map_zero\n  · intro y z _ _ hy hz; rw [LieHom.map_add, hy, hz, add_zero]\n  · intro t y _ hy; rw [LieHom.map_smul, hy, smul_zero]\n\n"}
{"name":"LieAlgebra.lieCharacterEquivLinearDual_apply","module":"Mathlib.Algebra.Lie.Character","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsLieAbelian L\nχ : LieAlgebra.LieCharacter R L\n⊢ Eq (LieAlgebra.lieCharacterEquivLinearDual χ) ↑χ","decl":"/-- For an Abelian Lie algebra, characters are just linear forms. -/\n@[simps! apply symm_apply]\ndef lieCharacterEquivLinearDual [IsLieAbelian L] : LieCharacter R L ≃ Module.Dual R L where\n  toFun χ := (χ : L →ₗ[R] R)\n  invFun ψ :=\n    { ψ with\n      map_lie' := fun {x y} => by\n        rw [LieModule.IsTrivial.trivial, LieRing.of_associative_ring_bracket, mul_comm, sub_self,\n          LinearMap.toFun_eq_coe, LinearMap.map_zero] }\n  left_inv χ := by ext; rfl\n  right_inv ψ := by ext; rfl\n\n"}
{"name":"LieAlgebra.lieCharacterEquivLinearDual_symm_apply","module":"Mathlib.Algebra.Lie.Character","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsLieAbelian L\nψ : Module.Dual R L\n⊢ Eq (LieAlgebra.lieCharacterEquivLinearDual.symm ψ) { toLinearMap := ψ, map_lie' := ⋯ }","decl":"/-- For an Abelian Lie algebra, characters are just linear forms. -/\n@[simps! apply symm_apply]\ndef lieCharacterEquivLinearDual [IsLieAbelian L] : LieCharacter R L ≃ Module.Dual R L where\n  toFun χ := (χ : L →ₗ[R] R)\n  invFun ψ :=\n    { ψ with\n      map_lie' := fun {x y} => by\n        rw [LieModule.IsTrivial.trivial, LieRing.of_associative_ring_bracket, mul_comm, sub_self,\n          LinearMap.toFun_eq_coe, LinearMap.map_zero] }\n  left_inv χ := by ext; rfl\n  right_inv ψ := by ext; rfl\n\n"}
