{"name":"List.support_sum_subset","module":"Mathlib.Data.Finsupp.BigOperators","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : AddMonoid M\nl : List (Finsupp ι M)\n⊢ HasSubset.Subset l.sum.support (List.foldr (fun x1 x2 => Max.max x1.support x2) EmptyCollection.emptyCollection l)","decl":"theorem List.support_sum_subset [AddMonoid M] (l : List (ι →₀ M)) :\n    l.sum.support ⊆ l.foldr (Finsupp.support · ⊔ ·) ∅ := by\n  induction' l with hd tl IH\n  · simp\n  · simp only [List.sum_cons, Finset.union_comm]\n    refine Finsupp.support_add.trans (Finset.union_subset_union ?_ IH)\n    rfl\n\n"}
{"name":"Multiset.support_sum_subset","module":"Mathlib.Data.Finsupp.BigOperators","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommMonoid M\ns : Multiset (Finsupp ι M)\n⊢ HasSubset.Subset s.sum.support (Multiset.map Finsupp.support s).sup","decl":"theorem Multiset.support_sum_subset [AddCommMonoid M] (s : Multiset (ι →₀ M)) :\n    s.sum.support ⊆ (s.map Finsupp.support).sup := by\n  induction s using Quot.inductionOn\n  simpa only [Multiset.quot_mk_to_coe'', Multiset.sum_coe, Multiset.map_coe, Multiset.sup_coe,\n    List.foldr_map] using List.support_sum_subset _\n\n"}
{"name":"Finset.support_sum_subset","module":"Mathlib.Data.Finsupp.BigOperators","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommMonoid M\ns : Finset (Finsupp ι M)\n⊢ HasSubset.Subset (s.sum id).support (s.sup Finsupp.support)","decl":"theorem Finset.support_sum_subset [AddCommMonoid M] (s : Finset (ι →₀ M)) :\n    (s.sum id).support ⊆ Finset.sup s Finsupp.support := by\n  classical convert Multiset.support_sum_subset s.1; simp\n\n"}
{"name":"List.mem_foldr_sup_support_iff","module":"Mathlib.Data.Finsupp.BigOperators","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : Zero M\nl : List (Finsupp ι M)\nx : ι\n⊢ Iff (Membership.mem (List.foldr (fun x1 x2 => Max.max x1.support x2) EmptyCollection.emptyCollection l) x) (Exists fun f => And (Membership.mem l f) (Membership.mem f.support x))","decl":"theorem List.mem_foldr_sup_support_iff [Zero M] {l : List (ι →₀ M)} {x : ι} :\n    x ∈ l.foldr (Finsupp.support · ⊔ ·) ∅ ↔ ∃ f ∈ l, x ∈ f.support := by\n  simp only [Finset.sup_eq_union, List.foldr_map, Finsupp.mem_support_iff, exists_prop]\n  induction' l with hd tl IH\n  · simp\n  · simp only [foldr, Function.comp_apply, Finset.mem_union, Finsupp.mem_support_iff, ne_eq, IH,\n      find?, mem_cons, exists_eq_or_imp]\n\n"}
{"name":"Multiset.mem_sup_map_support_iff","module":"Mathlib.Data.Finsupp.BigOperators","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : Zero M\ns : Multiset (Finsupp ι M)\nx : ι\n⊢ Iff (Membership.mem (Multiset.map Finsupp.support s).sup x) (Exists fun f => And (Membership.mem s f) (Membership.mem f.support x))","decl":"theorem Multiset.mem_sup_map_support_iff [Zero M] {s : Multiset (ι →₀ M)} {x : ι} :\n    x ∈ (s.map Finsupp.support).sup ↔ ∃ f ∈ s, x ∈ f.support :=\n  Quot.inductionOn s fun _ ↦ by\n    simpa only [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.sup_coe, List.foldr_map]\n    using List.mem_foldr_sup_support_iff\n\n"}
{"name":"Finset.mem_sup_support_iff","module":"Mathlib.Data.Finsupp.BigOperators","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : Zero M\ns : Finset (Finsupp ι M)\nx : ι\n⊢ Iff (Membership.mem (s.sup Finsupp.support) x) (Exists fun f => And (Membership.mem s f) (Membership.mem f.support x))","decl":"theorem Finset.mem_sup_support_iff [Zero M] {s : Finset (ι →₀ M)} {x : ι} :\n    x ∈ s.sup Finsupp.support ↔ ∃ f ∈ s, x ∈ f.support :=\n  Multiset.mem_sup_map_support_iff\n\n"}
{"name":"List.support_sum_eq","module":"Mathlib.Data.Finsupp.BigOperators","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : AddMonoid M\nl : List (Finsupp ι M)\nhl : List.Pairwise (Function.onFun Disjoint Finsupp.support) l\n⊢ Eq l.sum.support (List.foldr (fun x1 x2 => Max.max x1.support x2) EmptyCollection.emptyCollection l)","decl":"theorem List.support_sum_eq [AddMonoid M] (l : List (ι →₀ M))\n    (hl : l.Pairwise (_root_.Disjoint on Finsupp.support)) :\n    l.sum.support = l.foldr (Finsupp.support · ⊔ ·) ∅ := by\n  induction' l with hd tl IH\n  · simp\n  · simp only [List.pairwise_cons] at hl\n    simp only [List.sum_cons, List.foldr_cons, Function.comp_apply]\n    rw [Finsupp.support_add_eq, IH hl.right, Finset.sup_eq_union]\n    suffices _root_.Disjoint hd.support (tl.foldr (fun x y ↦ (Finsupp.support x ⊔ y)) ∅) by\n      exact Finset.disjoint_of_subset_right (List.support_sum_subset _) this\n    rw [← List.foldr_map, ← Finset.bot_eq_empty, List.foldr_sup_eq_sup_toFinset,\n      Finset.disjoint_sup_right]\n    intro f hf\n    simp only [List.mem_toFinset, List.mem_map] at hf\n    obtain ⟨f, hf, rfl⟩ := hf\n    exact hl.left _ hf\n\n"}
{"name":"Multiset.support_sum_eq","module":"Mathlib.Data.Finsupp.BigOperators","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommMonoid M\ns : Multiset (Finsupp ι M)\nhs : Multiset.Pairwise (Function.onFun Disjoint Finsupp.support) s\n⊢ Eq s.sum.support (Multiset.map Finsupp.support s).sup","decl":"theorem Multiset.support_sum_eq [AddCommMonoid M] (s : Multiset (ι →₀ M))\n    (hs : s.Pairwise (_root_.Disjoint on Finsupp.support)) :\n    s.sum.support = (s.map Finsupp.support).sup := by\n  induction' s using Quot.inductionOn with a\n  obtain ⟨l, hl, hd⟩ := hs\n  suffices a.Pairwise (_root_.Disjoint on Finsupp.support) by\n    convert List.support_sum_eq a this\n    dsimp only [Function.comp_def]\n    simp only [quot_mk_to_coe'', map_coe, sup_coe, Finset.le_eq_subset,\n      Finset.sup_eq_union, Finset.bot_eq_empty, List.foldr_map]\n  simp only [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.coe_eq_coe] at hl\n  exact hl.symm.pairwise hd fun h ↦ _root_.Disjoint.symm h\n\n"}
{"name":"Finset.support_sum_eq","module":"Mathlib.Data.Finsupp.BigOperators","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : DecidableEq ι\ninst✝ : AddCommMonoid M\ns : Finset (Finsupp ι M)\nhs : (↑s).PairwiseDisjoint Finsupp.support\n⊢ Eq (s.sum id).support (s.sup Finsupp.support)","decl":"theorem Finset.support_sum_eq [AddCommMonoid M] (s : Finset (ι →₀ M))\n    (hs : (s : Set (ι →₀ M)).PairwiseDisjoint Finsupp.support) :\n    (s.sum id).support = Finset.sup s Finsupp.support := by\n  classical\n  suffices s.1.Pairwise (_root_.Disjoint on Finsupp.support) by\n    convert Multiset.support_sum_eq s.1 this\n    exact (Finset.sum_val _).symm\n  obtain ⟨l, hl, hn⟩ : ∃ l : List (ι →₀ M), l.toFinset = s ∧ l.Nodup := by\n    refine ⟨s.toList, ?_, Finset.nodup_toList _⟩\n    simp\n  subst hl\n  rwa [List.toFinset_val, List.dedup_eq_self.mpr hn, Multiset.pairwise_coe_iff_pairwise, ←\n    List.pairwiseDisjoint_iff_coe_toFinset_pairwise_disjoint hn]\n  intro x y hxy\n  exact symmetric_disjoint hxy\n"}
