{"name":"MeasurableSpace.isPiSystem_measurableSet","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\ninst✝ : MeasurableSpace α\n⊢ IsPiSystem (setOf fun s => MeasurableSet s)","decl":"theorem isPiSystem_measurableSet {α : Type*} [MeasurableSpace α] :\n    IsPiSystem { s : Set α | MeasurableSet s } := fun _ hs _ ht _ => hs.inter ht\n\n"}
{"name":"IsPiSystem.singleton","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nS : Set α\n⊢ IsPiSystem (Singleton.singleton S)","decl":"theorem IsPiSystem.singleton (S : Set α) : IsPiSystem ({S} : Set (Set α)) := by\n  intro s h_s t h_t _\n  rw [Set.mem_singleton_iff.1 h_s, Set.mem_singleton_iff.1 h_t, Set.inter_self,\n    Set.mem_singleton_iff]\n\n"}
{"name":"IsPiSystem.insert_empty","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nS : Set (Set α)\nh_pi : IsPiSystem S\n⊢ IsPiSystem (Insert.insert EmptyCollection.emptyCollection S)","decl":"theorem IsPiSystem.insert_empty {S : Set (Set α)} (h_pi : IsPiSystem S) :\n    IsPiSystem (insert ∅ S) := by\n  intro s hs t ht hst\n  cases' hs with hs hs\n  · simp [hs]\n  · cases' ht with ht ht\n    · simp [ht]\n    · exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)\n\n"}
{"name":"IsPiSystem.insert_univ","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nS : Set (Set α)\nh_pi : IsPiSystem S\n⊢ IsPiSystem (Insert.insert Set.univ S)","decl":"theorem IsPiSystem.insert_univ {S : Set (Set α)} (h_pi : IsPiSystem S) :\n    IsPiSystem (insert Set.univ S) := by\n  intro s hs t ht hst\n  cases' hs with hs hs\n  · cases' ht with ht ht <;> simp [hs, ht]\n  · cases' ht with ht ht\n    · simp [hs, ht]\n    · exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)\n\n"}
{"name":"IsPiSystem.comap","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nβ : Type u_4\nS : Set (Set β)\nh_pi : IsPiSystem S\nf : α → β\n⊢ IsPiSystem (setOf fun s => Exists fun t => And (Membership.mem S t) (Eq (Set.preimage f t) s))","decl":"theorem IsPiSystem.comap {α β} {S : Set (Set β)} (h_pi : IsPiSystem S) (f : α → β) :\n    IsPiSystem { s : Set α | ∃ t ∈ S, f ⁻¹' t = s } := by\n  rintro _ ⟨s, hs_mem, rfl⟩ _ ⟨t, ht_mem, rfl⟩ hst\n  rw [← Set.preimage_inter] at hst ⊢\n  exact ⟨s ∩ t, h_pi s hs_mem t ht_mem (nonempty_of_nonempty_preimage hst), rfl⟩\n\n"}
{"name":"isPiSystem_iUnion_of_directed_le","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Sort u_4\np : ι → Set (Set α)\nhp_pi : ∀ (n : ι), IsPiSystem (p n)\nhp_directed : Directed (fun x1 x2 => LE.le x1 x2) p\n⊢ IsPiSystem (Set.iUnion fun n => p n)","decl":"theorem isPiSystem_iUnion_of_directed_le {α ι} (p : ι → Set (Set α))\n    (hp_pi : ∀ n, IsPiSystem (p n)) (hp_directed : Directed (· ≤ ·) p) :\n    IsPiSystem (⋃ n, p n) := by\n  intro t1 ht1 t2 ht2 h\n  rw [Set.mem_iUnion] at ht1 ht2 ⊢\n  cases' ht1 with n ht1\n  cases' ht2 with m ht2\n  obtain ⟨k, hpnk, hpmk⟩ : ∃ k, p n ≤ p k ∧ p m ≤ p k := hp_directed n m\n  exact ⟨k, hp_pi k t1 (hpnk ht1) t2 (hpmk ht2) h⟩\n\n"}
{"name":"isPiSystem_iUnion_of_monotone","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\ninst✝ : SemilatticeSup ι\np : ι → Set (Set α)\nhp_pi : ∀ (n : ι), IsPiSystem (p n)\nhp_mono : Monotone p\n⊢ IsPiSystem (Set.iUnion fun n => p n)","decl":"theorem isPiSystem_iUnion_of_monotone {α ι} [SemilatticeSup ι] (p : ι → Set (Set α))\n    (hp_pi : ∀ n, IsPiSystem (p n)) (hp_mono : Monotone p) : IsPiSystem (⋃ n, p n) :=\n  isPiSystem_iUnion_of_directed_le p hp_pi (Monotone.directed_le hp_mono)\n\n"}
{"name":"IsPiSystem.prod","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nβ : Type u_2\nC : Set (Set α)\nD : Set (Set β)\nhC : IsPiSystem C\nhD : IsPiSystem D\n⊢ IsPiSystem (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) C D)","decl":"/-- Rectangles formed by π-systems form a π-system. -/\nlemma IsPiSystem.prod {C : Set (Set α)} {D : Set (Set β)} (hC : IsPiSystem C) (hD : IsPiSystem D) :\n    IsPiSystem (image2 (· ×ˢ ·) C D) := by\n  rintro _ ⟨s₁, hs₁, t₁, ht₁, rfl⟩ _ ⟨s₂, hs₂, t₂, ht₂, rfl⟩ hst\n  rw [prod_inter_prod] at hst ⊢; rw [prod_nonempty_iff] at hst\n  exact mem_image2_of_mem (hC _ hs₁ _ hs₂ hst.1) (hD _ ht₁ _ ht₂ hst.2)\n\n"}
{"name":"isPiSystem_image_Iio","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ IsPiSystem (Set.image Set.Iio s)","decl":"theorem isPiSystem_image_Iio (s : Set α) : IsPiSystem (Iio '' s) := by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ -\n  exact ⟨a ⊓ b, inf_ind a b ha hb, Iio_inter_Iio.symm⟩\n\n"}
{"name":"isPiSystem_Iio","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ IsPiSystem (Set.range Set.Iio)","decl":"theorem isPiSystem_Iio : IsPiSystem (range Iio : Set (Set α)) :=\n  @image_univ α _ Iio ▸ isPiSystem_image_Iio univ\n\n"}
{"name":"isPiSystem_image_Ioi","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ IsPiSystem (Set.image Set.Ioi s)","decl":"theorem isPiSystem_image_Ioi (s : Set α) : IsPiSystem (Ioi '' s) :=\n  @isPiSystem_image_Iio αᵒᵈ _ s\n\n"}
{"name":"isPiSystem_Ioi","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ IsPiSystem (Set.range Set.Ioi)","decl":"theorem isPiSystem_Ioi : IsPiSystem (range Ioi : Set (Set α)) :=\n  @image_univ α _ Ioi ▸ isPiSystem_image_Ioi univ\n\n"}
{"name":"isPiSystem_image_Iic","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ IsPiSystem (Set.image Set.Iic s)","decl":"theorem isPiSystem_image_Iic (s : Set α) : IsPiSystem (Iic '' s) := by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ -\n  exact ⟨a ⊓ b, inf_ind a b ha hb, Iic_inter_Iic.symm⟩\n\n"}
{"name":"isPiSystem_Iic","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ IsPiSystem (Set.range Set.Iic)","decl":"theorem isPiSystem_Iic : IsPiSystem (range Iic : Set (Set α)) :=\n  @image_univ α _ Iic ▸ isPiSystem_image_Iic univ\n\n"}
{"name":"isPiSystem_image_Ici","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ IsPiSystem (Set.image Set.Ici s)","decl":"theorem isPiSystem_image_Ici (s : Set α) : IsPiSystem (Ici '' s) :=\n  @isPiSystem_image_Iic αᵒᵈ _ s\n\n"}
{"name":"isPiSystem_Ici","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ IsPiSystem (Set.range Set.Ici)","decl":"theorem isPiSystem_Ici : IsPiSystem (range Ici : Set (Set α)) :=\n  @image_univ α _ Ici ▸ isPiSystem_image_Ici univ\n\n"}
{"name":"isPiSystem_Ixx_mem","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nIxx : α → α → Set α\np : α → α → Prop\nHne : ∀ {a b : α}, (Ixx a b).Nonempty → p a b\nHi : ∀ {a₁ b₁ a₂ b₂ : α}, Eq (Inter.inter (Ixx a₁ b₁) (Ixx a₂ b₂)) (Ixx (Max.max a₁ a₂) (Min.min b₁ b₂))\ns t : Set α\n⊢ IsPiSystem (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem t u) (And (p l u) (Eq (Ixx l u) S))))","decl":"theorem isPiSystem_Ixx_mem {Ixx : α → α → Set α} {p : α → α → Prop}\n    (Hne : ∀ {a b}, (Ixx a b).Nonempty → p a b)\n    (Hi : ∀ {a₁ b₁ a₂ b₂}, Ixx a₁ b₁ ∩ Ixx a₂ b₂ = Ixx (max a₁ a₂) (min b₁ b₂)) (s t : Set α) :\n    IsPiSystem { S | ∃ᵉ (l ∈ s) (u ∈ t), p l u ∧ Ixx l u = S } := by\n  rintro _ ⟨l₁, hls₁, u₁, hut₁, _, rfl⟩ _ ⟨l₂, hls₂, u₂, hut₂, _, rfl⟩\n  simp only [Hi]\n  exact fun H => ⟨l₁ ⊔ l₂, sup_ind l₁ l₂ hls₁ hls₂, u₁ ⊓ u₂, inf_ind u₁ u₂ hut₁ hut₂, Hne H, rfl⟩\n\n"}
{"name":"isPiSystem_Ixx","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nι : Sort u_3\nι' : Sort u_4\ninst✝ : LinearOrder α\nIxx : α → α → Set α\np : α → α → Prop\nHne : ∀ {a b : α}, (Ixx a b).Nonempty → p a b\nHi : ∀ {a₁ b₁ a₂ b₂ : α}, Eq (Inter.inter (Ixx a₁ b₁) (Ixx a₂ b₂)) (Ixx (Max.max a₁ a₂) (Min.min b₁ b₂))\nf : ι → α\ng : ι' → α\n⊢ IsPiSystem (setOf fun S => Exists fun i => Exists fun j => And (p (f i) (g j)) (Eq (Ixx (f i) (g j)) S))","decl":"theorem isPiSystem_Ixx {Ixx : α → α → Set α} {p : α → α → Prop}\n    (Hne : ∀ {a b}, (Ixx a b).Nonempty → p a b)\n    (Hi : ∀ {a₁ b₁ a₂ b₂}, Ixx a₁ b₁ ∩ Ixx a₂ b₂ = Ixx (max a₁ a₂) (min b₁ b₂)) (f : ι → α)\n    (g : ι' → α) : @IsPiSystem α { S | ∃ i j, p (f i) (g j) ∧ Ixx (f i) (g j) = S } := by\n  simpa only [exists_range_iff] using isPiSystem_Ixx_mem (@Hne) (@Hi) (range f) (range g)\n\n"}
{"name":"isPiSystem_Ioo_mem","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\n⊢ IsPiSystem (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem t u) (And (LT.lt l u) (Eq (Set.Ioo l u) S))))","decl":"theorem isPiSystem_Ioo_mem (s t : Set α) :\n    IsPiSystem { S | ∃ᵉ (l ∈ s) (u ∈ t), l < u ∧ Ioo l u = S } :=\n  isPiSystem_Ixx_mem (Ixx := Ioo) (fun ⟨_, hax, hxb⟩ => hax.trans hxb) Ioo_inter_Ioo s t\n\n"}
{"name":"isPiSystem_Ioo","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nι : Sort u_3\nι' : Sort u_4\ninst✝ : LinearOrder α\nf : ι → α\ng : ι' → α\n⊢ IsPiSystem (setOf fun S => Exists fun l => Exists fun u => And (LT.lt (f l) (g u)) (Eq (Set.Ioo (f l) (g u)) S))","decl":"theorem isPiSystem_Ioo (f : ι → α) (g : ι' → α) :\n    @IsPiSystem α { S | ∃ l u, f l < g u ∧ Ioo (f l) (g u) = S } :=\n  isPiSystem_Ixx (Ixx := Ioo) (fun ⟨_, hax, hxb⟩ => hax.trans hxb) Ioo_inter_Ioo f g\n\n"}
{"name":"isPiSystem_Ioc_mem","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\n⊢ IsPiSystem (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem t u) (And (LT.lt l u) (Eq (Set.Ioc l u) S))))","decl":"theorem isPiSystem_Ioc_mem (s t : Set α) :\n    IsPiSystem { S | ∃ᵉ (l ∈ s) (u ∈ t), l < u ∧ Ioc l u = S } :=\n  isPiSystem_Ixx_mem (Ixx := Ioc) (fun ⟨_, hax, hxb⟩ => hax.trans_le hxb) Ioc_inter_Ioc s t\n\n"}
{"name":"isPiSystem_Ioc","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nι : Sort u_3\nι' : Sort u_4\ninst✝ : LinearOrder α\nf : ι → α\ng : ι' → α\n⊢ IsPiSystem (setOf fun S => Exists fun i => Exists fun j => And (LT.lt (f i) (g j)) (Eq (Set.Ioc (f i) (g j)) S))","decl":"theorem isPiSystem_Ioc (f : ι → α) (g : ι' → α) :\n    @IsPiSystem α { S | ∃ i j, f i < g j ∧ Ioc (f i) (g j) = S } :=\n  isPiSystem_Ixx (Ixx := Ioc) (fun ⟨_, hax, hxb⟩ => hax.trans_le hxb) Ioc_inter_Ioc f g\n\n"}
{"name":"isPiSystem_Ico_mem","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\n⊢ IsPiSystem (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem t u) (And (LT.lt l u) (Eq (Set.Ico l u) S))))","decl":"theorem isPiSystem_Ico_mem (s t : Set α) :\n    IsPiSystem { S | ∃ᵉ (l ∈ s) (u ∈ t), l < u ∧ Ico l u = S } :=\n  isPiSystem_Ixx_mem (Ixx := Ico) (fun ⟨_, hax, hxb⟩ => hax.trans_lt hxb) Ico_inter_Ico s t\n\n"}
{"name":"isPiSystem_Ico","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nι : Sort u_3\nι' : Sort u_4\ninst✝ : LinearOrder α\nf : ι → α\ng : ι' → α\n⊢ IsPiSystem (setOf fun S => Exists fun i => Exists fun j => And (LT.lt (f i) (g j)) (Eq (Set.Ico (f i) (g j)) S))","decl":"theorem isPiSystem_Ico (f : ι → α) (g : ι' → α) :\n    @IsPiSystem α { S | ∃ i j, f i < g j ∧ Ico (f i) (g j) = S } :=\n  isPiSystem_Ixx (Ixx := Ico) (fun ⟨_, hax, hxb⟩ => hax.trans_lt hxb) Ico_inter_Ico f g\n\n"}
{"name":"isPiSystem_Icc_mem","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\n⊢ IsPiSystem (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem t u) (And (LE.le l u) (Eq (Set.Icc l u) S))))","decl":"theorem isPiSystem_Icc_mem (s t : Set α) :\n    IsPiSystem { S | ∃ᵉ (l ∈ s) (u ∈ t), l ≤ u ∧ Icc l u = S } :=\n  isPiSystem_Ixx_mem (Ixx := Icc) nonempty_Icc.1 (by exact Icc_inter_Icc) s t\n\n"}
{"name":"isPiSystem_Icc","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nι : Sort u_3\nι' : Sort u_4\ninst✝ : LinearOrder α\nf : ι → α\ng : ι' → α\n⊢ IsPiSystem (setOf fun S => Exists fun i => Exists fun j => And (LE.le (f i) (g j)) (Eq (Set.Icc (f i) (g j)) S))","decl":"theorem isPiSystem_Icc (f : ι → α) (g : ι' → α) :\n    @IsPiSystem α { S | ∃ i j, f i ≤ g j ∧ Icc (f i) (g j) = S } :=\n  isPiSystem_Ixx (Ixx := Icc) nonempty_Icc.1 (by exact Icc_inter_Icc) f g\n\n"}
{"name":"generatePiSystem.brecOn","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nS : Set (Set α)\nmotive✝ : (a : Set α) → generatePiSystem S a → Prop\na✝ : Set α\nx✝ : generatePiSystem S a✝\nih✝ : ∀ (a : Set α) (x : generatePiSystem S a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- Given a collection `S` of subsets of `α`, then `generatePiSystem S` is the smallest\nπ-system containing `S`. -/\ninductive generatePiSystem (S : Set (Set α)) : Set (Set α)\n  | base {s : Set α} (h_s : s ∈ S) : generatePiSystem S s\n  | inter {s t : Set α} (h_s : generatePiSystem S s) (h_t : generatePiSystem S t)\n    (h_nonempty : (s ∩ t).Nonempty) : generatePiSystem S (s ∩ t)\n\n"}
{"name":"isPiSystem_generatePiSystem","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ IsPiSystem (generatePiSystem S)","decl":"theorem isPiSystem_generatePiSystem (S : Set (Set α)) : IsPiSystem (generatePiSystem S) :=\n  fun _ h_s _ h_t h_nonempty => generatePiSystem.inter h_s h_t h_nonempty\n\n"}
{"name":"subset_generatePiSystem_self","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ HasSubset.Subset S (generatePiSystem S)","decl":"theorem subset_generatePiSystem_self (S : Set (Set α)) : S ⊆ generatePiSystem S := fun _ =>\n  generatePiSystem.base\n\n"}
{"name":"generatePiSystem_subset_self","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nS : Set (Set α)\nh_S : IsPiSystem S\n⊢ HasSubset.Subset (generatePiSystem S) S","decl":"theorem generatePiSystem_subset_self {S : Set (Set α)} (h_S : IsPiSystem S) :\n    generatePiSystem S ⊆ S := fun x h => by\n  induction h with\n  | base h_s => exact h_s\n  | inter _ _ h_nonempty h_s h_u => exact h_S _ h_s _ h_u h_nonempty\n\n"}
{"name":"generatePiSystem_eq","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nS : Set (Set α)\nh_pi : IsPiSystem S\n⊢ Eq (generatePiSystem S) S","decl":"theorem generatePiSystem_eq {S : Set (Set α)} (h_pi : IsPiSystem S) : generatePiSystem S = S :=\n  Set.Subset.antisymm (generatePiSystem_subset_self h_pi) (subset_generatePiSystem_self S)\n\n"}
{"name":"generatePiSystem_mono","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nS T : Set (Set α)\nhST : HasSubset.Subset S T\n⊢ HasSubset.Subset (generatePiSystem S) (generatePiSystem T)","decl":"theorem generatePiSystem_mono {S T : Set (Set α)} (hST : S ⊆ T) :\n    generatePiSystem S ⊆ generatePiSystem T := fun t ht => by\n  induction ht with\n  | base h_s => exact generatePiSystem.base (Set.mem_of_subset_of_mem hST h_s)\n  | inter _ _ h_nonempty h_s h_u => exact isPiSystem_generatePiSystem T _ h_s _ h_u h_nonempty\n\n"}
{"name":"generatePiSystem_measurableSet","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\nM : MeasurableSpace α\nS : Set (Set α)\nh_meas_S : ∀ (s : Set α), Membership.mem S s → MeasurableSet s\nt : Set α\nh_in_pi : Membership.mem (generatePiSystem S) t\n⊢ MeasurableSet t","decl":"theorem generatePiSystem_measurableSet [M : MeasurableSpace α] {S : Set (Set α)}\n    (h_meas_S : ∀ s ∈ S, MeasurableSet s) (t : Set α) (h_in_pi : t ∈ generatePiSystem S) :\n    MeasurableSet t := by\n  induction h_in_pi with\n  | base h_s => apply h_meas_S _ h_s\n  | inter _ _ _ h_s h_u => apply MeasurableSet.inter h_s h_u\n\n"}
{"name":"generateFrom_measurableSet_of_generatePiSystem","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ng : Set (Set α)\nt : Set α\nht : Membership.mem (generatePiSystem g) t\n⊢ MeasurableSet t","decl":"theorem generateFrom_measurableSet_of_generatePiSystem {g : Set (Set α)} (t : Set α)\n    (ht : t ∈ generatePiSystem g) : MeasurableSet[generateFrom g] t :=\n  @generatePiSystem_measurableSet α (generateFrom g) g\n    (fun _ h_s_in_g => measurableSet_generateFrom h_s_in_g) t ht\n\n"}
{"name":"generateFrom_generatePiSystem_eq","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_1\ng : Set (Set α)\n⊢ Eq (MeasurableSpace.generateFrom (generatePiSystem g)) (MeasurableSpace.generateFrom g)","decl":"theorem generateFrom_generatePiSystem_eq {g : Set (Set α)} :\n    generateFrom (generatePiSystem g) = generateFrom g := by\n  apply le_antisymm <;> apply generateFrom_le\n  · exact fun t h_t => generateFrom_measurableSet_of_generatePiSystem t h_t\n  · exact fun t h_t => measurableSet_generateFrom (generatePiSystem.base h_t)\n\n"}
{"name":"mem_generatePiSystem_iUnion_elim","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nβ : Type u_4\ng : β → Set (Set α)\nh_pi : ∀ (b : β), IsPiSystem (g b)\nt : Set α\nh_t : Membership.mem (generatePiSystem (Set.iUnion fun b => g b)) t\n⊢ Exists fun T => Exists fun f => And (Eq t (Set.iInter fun b => Set.iInter fun h => f b)) (∀ (b : β), Membership.mem T b → Membership.mem (g b) (f b))","decl":"/-- Every element of the π-system generated by the union of a family of π-systems\nis a finite intersection of elements from the π-systems.\nFor an indexed union version, see `mem_generatePiSystem_iUnion_elim'`. -/\ntheorem mem_generatePiSystem_iUnion_elim {α β} {g : β → Set (Set α)} (h_pi : ∀ b, IsPiSystem (g b))\n    (t : Set α) (h_t : t ∈ generatePiSystem (⋃ b, g b)) :\n    ∃ (T : Finset β) (f : β → Set α), (t = ⋂ b ∈ T, f b) ∧ ∀ b ∈ T, f b ∈ g b := by\n  classical\n  induction' h_t with s h_s s t' h_gen_s h_gen_t' h_nonempty h_s h_t'\n  · rcases h_s with ⟨t', ⟨⟨b, rfl⟩, h_s_in_t'⟩⟩\n    refine ⟨{b}, fun _ => s, ?_⟩\n    simpa using h_s_in_t'\n  · rcases h_t' with ⟨T_t', ⟨f_t', ⟨rfl, h_t'⟩⟩⟩\n    rcases h_s with ⟨T_s, ⟨f_s, ⟨rfl, h_s⟩⟩⟩\n    use T_s ∪ T_t', fun b : β =>\n      if b ∈ T_s then if b ∈ T_t' then f_s b ∩ f_t' b else f_s b\n      else if b ∈ T_t' then f_t' b else (∅ : Set α)\n    constructor\n    · ext a\n      simp_rw [Set.mem_inter_iff, Set.mem_iInter, Finset.mem_union, or_imp]\n      rw [← forall_and]\n      constructor <;> intro h1 b <;> by_cases hbs : b ∈ T_s <;> by_cases hbt : b ∈ T_t' <;>\n          specialize h1 b <;>\n        simp only [hbs, hbt, if_true, if_false, true_imp_iff, and_self_iff, false_imp_iff] at h1 ⊢\n      all_goals exact h1\n    intro b h_b\n    split_ifs with hbs hbt hbt\n    · refine h_pi b (f_s b) (h_s b hbs) (f_t' b) (h_t' b hbt) (Set.Nonempty.mono ?_ h_nonempty)\n      exact Set.inter_subset_inter (Set.biInter_subset_of_mem hbs) (Set.biInter_subset_of_mem hbt)\n    · exact h_s b hbs\n    · exact h_t' b hbt\n    · rw [Finset.mem_union] at h_b\n      apply False.elim (h_b.elim hbs hbt)\n\n"}
{"name":"mem_generatePiSystem_iUnion_elim'","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nβ : Type u_4\ng : β → Set (Set α)\ns : Set β\nh_pi : ∀ (b : β), Membership.mem s b → IsPiSystem (g b)\nt : Set α\nh_t : Membership.mem (generatePiSystem (Set.iUnion fun b => Set.iUnion fun h => g b)) t\n⊢ Exists fun T => Exists fun f => And (HasSubset.Subset (↑T) s) (And (Eq t (Set.iInter fun b => Set.iInter fun h => f b)) (∀ (b : β), Membership.mem T b → Membership.mem (g b) (f b)))","decl":"/-- Every element of the π-system generated by an indexed union of a family of π-systems\nis a finite intersection of elements from the π-systems.\nFor a total union version, see `mem_generatePiSystem_iUnion_elim`. -/\ntheorem mem_generatePiSystem_iUnion_elim' {α β} {g : β → Set (Set α)} {s : Set β}\n    (h_pi : ∀ b ∈ s, IsPiSystem (g b)) (t : Set α) (h_t : t ∈ generatePiSystem (⋃ b ∈ s, g b)) :\n    ∃ (T : Finset β) (f : β → Set α), ↑T ⊆ s ∧ (t = ⋂ b ∈ T, f b) ∧ ∀ b ∈ T, f b ∈ g b := by\n  classical\n  have : t ∈ generatePiSystem (⋃ b : Subtype s, (g ∘ Subtype.val) b) := by\n    suffices h1 : ⋃ b : Subtype s, (g ∘ Subtype.val) b = ⋃ b ∈ s, g b by rwa [h1]\n    ext x\n    simp only [exists_prop, Set.mem_iUnion, Function.comp_apply, Subtype.exists, Subtype.coe_mk]\n    rfl\n  rcases @mem_generatePiSystem_iUnion_elim α (Subtype s) (g ∘ Subtype.val)\n      (fun b => h_pi b.val b.property) t this with\n    ⟨T, ⟨f, ⟨rfl, h_t'⟩⟩⟩\n  refine\n    ⟨T.image (fun x : s => (x : β)),\n      Function.extend (fun x : s => (x : β)) f fun _ : β => (∅ : Set α), by simp, ?_, ?_⟩\n  · ext a\n    constructor <;>\n      · simp (config := { proj := false }) only\n          [Set.mem_iInter, Subtype.forall, Finset.set_biInter_finset_image]\n        intro h1 b h_b h_b_in_T\n        have h2 := h1 b h_b h_b_in_T\n        revert h2\n        rw [Subtype.val_injective.extend_apply]\n        apply id\n  · intros b h_b\n    simp_rw [Finset.mem_image, Subtype.exists, exists_and_right, exists_eq_right]\n      at h_b\n    cases' h_b with h_b_w h_b_h\n    have h_b_alt : b = (Subtype.mk b h_b_w).val := rfl\n    rw [h_b_alt, Subtype.val_injective.extend_apply]\n    apply h_t'\n    apply h_b_h\n\n"}
{"name":"piiUnionInter_singleton","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nπ : ι → Set (Set α)\ni : ι\n⊢ Eq (piiUnionInter π (Singleton.singleton i)) (Union.union (π i) (Singleton.singleton Set.univ))","decl":"theorem piiUnionInter_singleton (π : ι → Set (Set α)) (i : ι) :\n    piiUnionInter π {i} = π i ∪ {univ} := by\n  ext1 s\n  simp only [piiUnionInter, exists_prop, mem_union]\n  refine ⟨?_, fun h => ?_⟩\n  · rintro ⟨t, hti, f, hfπ, rfl⟩\n    simp only [subset_singleton_iff, Finset.mem_coe] at hti\n    by_cases hi : i ∈ t\n    · have ht_eq_i : t = {i} := by\n        ext1 x\n        rw [Finset.mem_singleton]\n        exact ⟨fun h => hti x h, fun h => h.symm ▸ hi⟩\n      simp only [ht_eq_i, Finset.mem_singleton, iInter_iInter_eq_left]\n      exact Or.inl (hfπ i hi)\n    · have ht_empty : t = ∅ := by\n        ext1 x\n        simp only [Finset.not_mem_empty, iff_false]\n        exact fun hx => hi (hti x hx ▸ hx)\n      -- Porting note: `Finset.not_mem_empty` required\n      simp [ht_empty, Finset.not_mem_empty, iInter_false, iInter_univ, Set.mem_singleton univ]\n  · cases' h with hs hs\n    · refine ⟨{i}, ?_, fun _ => s, ⟨fun x hx => ?_, ?_⟩⟩\n      · rw [Finset.coe_singleton]\n      · rw [Finset.mem_singleton] at hx\n        rwa [hx]\n      · simp only [Finset.mem_singleton, iInter_iInter_eq_left]\n    · refine ⟨∅, ?_⟩\n      simpa only [Finset.coe_empty, subset_singleton_iff, mem_empty_iff_false, IsEmpty.forall_iff,\n        imp_true_iff, Finset.not_mem_empty, iInter_false, iInter_univ, true_and,\n        exists_const] using hs\n\n"}
{"name":"piiUnionInter_singleton_left","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\ns : ι → Set α\nS : Set ι\n⊢ Eq (piiUnionInter (fun i => Singleton.singleton (s i)) S) (setOf fun s' => Exists fun t => Exists fun x => Eq s' (Set.iInter fun i => Set.iInter fun h => s i))","decl":"theorem piiUnionInter_singleton_left (s : ι → Set α) (S : Set ι) :\n    piiUnionInter (fun i => ({s i} : Set (Set α))) S =\n      { s' : Set α | ∃ (t : Finset ι) (_ : ↑t ⊆ S), s' = ⋂ i ∈ t, s i } := by\n  ext1 s'\n  simp_rw [piiUnionInter, Set.mem_singleton_iff, exists_prop, Set.mem_setOf_eq]\n  refine ⟨fun h => ?_, fun ⟨t, htS, h_eq⟩ => ⟨t, htS, s, fun _ _ => rfl, h_eq⟩⟩\n  obtain ⟨t, htS, f, hft_eq, rfl⟩ := h\n  refine ⟨t, htS, ?_⟩\n  congr! 3\n  apply hft_eq\n  assumption\n\n"}
{"name":"generateFrom_piiUnionInter_singleton_left","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\ns : ι → Set α\nS : Set ι\n⊢ Eq (MeasurableSpace.generateFrom (piiUnionInter (fun k => Singleton.singleton (s k)) S)) (MeasurableSpace.generateFrom (setOf fun t => Exists fun k => And (Membership.mem S k) (Eq (s k) t)))","decl":"theorem generateFrom_piiUnionInter_singleton_left (s : ι → Set α) (S : Set ι) :\n    generateFrom (piiUnionInter (fun k => {s k}) S) = generateFrom { t | ∃ k ∈ S, s k = t } := by\n  refine le_antisymm (generateFrom_le ?_) (generateFrom_mono ?_)\n  · rintro _ ⟨I, hI, f, hf, rfl⟩\n    refine Finset.measurableSet_biInter _ fun m hm => measurableSet_generateFrom ?_\n    exact ⟨m, hI hm, (hf m hm).symm⟩\n  · rintro _ ⟨k, hk, rfl⟩\n    refine ⟨{k}, fun m hm => ?_, s, fun i _ => ?_, ?_⟩\n    · rw [Finset.mem_coe, Finset.mem_singleton] at hm\n      rwa [hm]\n    · exact Set.mem_singleton _\n    · simp only [Finset.mem_singleton, Set.iInter_iInter_eq_left]\n\n"}
{"name":"isPiSystem_piiUnionInter","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nπ : ι → Set (Set α)\nhpi : ∀ (x : ι), IsPiSystem (π x)\nS : Set ι\n⊢ IsPiSystem (piiUnionInter π S)","decl":"/-- If `π` is a family of π-systems, then `piiUnionInter π S` is a π-system. -/\ntheorem isPiSystem_piiUnionInter (π : ι → Set (Set α)) (hpi : ∀ x, IsPiSystem (π x)) (S : Set ι) :\n    IsPiSystem (piiUnionInter π S) := by\n  classical\n  rintro t1 ⟨p1, hp1S, f1, hf1m, ht1_eq⟩ t2 ⟨p2, hp2S, f2, hf2m, ht2_eq⟩ h_nonempty\n  simp_rw [piiUnionInter, Set.mem_setOf_eq]\n  let g n := ite (n ∈ p1) (f1 n) Set.univ ∩ ite (n ∈ p2) (f2 n) Set.univ\n  have hp_union_ss : ↑(p1 ∪ p2) ⊆ S := by\n    simp only [hp1S, hp2S, Finset.coe_union, union_subset_iff, and_self_iff]\n  use p1 ∪ p2, hp_union_ss, g\n  have h_inter_eq : t1 ∩ t2 = ⋂ i ∈ p1 ∪ p2, g i := by\n    rw [ht1_eq, ht2_eq]\n    simp_rw [← Set.inf_eq_inter]\n    ext1 x\n    simp only [g, inf_eq_inter, mem_inter_iff, mem_iInter, Finset.mem_union]\n    refine ⟨fun h i _ => ?_, fun h => ⟨fun i hi1 => ?_, fun i hi2 => ?_⟩⟩\n    · split_ifs with h_1 h_2 h_2\n      exacts [⟨h.1 i h_1, h.2 i h_2⟩, ⟨h.1 i h_1, Set.mem_univ _⟩, ⟨Set.mem_univ _, h.2 i h_2⟩,\n        ⟨Set.mem_univ _, Set.mem_univ _⟩]\n    · specialize h i (Or.inl hi1)\n      rw [if_pos hi1] at h\n      exact h.1\n    · specialize h i (Or.inr hi2)\n      rw [if_pos hi2] at h\n      exact h.2\n  refine ⟨fun n hn => ?_, h_inter_eq⟩\n  simp only [g]\n  split_ifs with hn1 hn2 h\n  · refine hpi n (f1 n) (hf1m n hn1) (f2 n) (hf2m n hn2) (Set.nonempty_iff_ne_empty.2 fun h => ?_)\n    rw [h_inter_eq] at h_nonempty\n    suffices h_empty : ⋂ i ∈ p1 ∪ p2, g i = ∅ from\n      (Set.not_nonempty_iff_eq_empty.mpr h_empty) h_nonempty\n    refine le_antisymm (Set.iInter_subset_of_subset n ?_) (Set.empty_subset _)\n    refine Set.iInter_subset_of_subset hn ?_\n    simp_rw [g, if_pos hn1, if_pos hn2]\n    exact h.subset\n  · simp [hf1m n hn1]\n  · simp [hf2m n h]\n  · exact absurd hn (by simp [hn1, h])\n\n"}
{"name":"piiUnionInter_mono_left","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nπ π' : ι → Set (Set α)\nh_le : ∀ (i : ι), HasSubset.Subset (π i) (π' i)\nS : Set ι\n⊢ HasSubset.Subset (piiUnionInter π S) (piiUnionInter π' S)","decl":"theorem piiUnionInter_mono_left {π π' : ι → Set (Set α)} (h_le : ∀ i, π i ⊆ π' i) (S : Set ι) :\n    piiUnionInter π S ⊆ piiUnionInter π' S := fun _ ⟨t, ht_mem, ft, hft_mem_pi, h_eq⟩ =>\n  ⟨t, ht_mem, ft, fun x hxt => h_le x (hft_mem_pi x hxt), h_eq⟩\n\n"}
{"name":"piiUnionInter_mono_right","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nπ : ι → Set (Set α)\nS T : Set ι\nhST : HasSubset.Subset S T\n⊢ HasSubset.Subset (piiUnionInter π S) (piiUnionInter π T)","decl":"theorem piiUnionInter_mono_right {π : ι → Set (Set α)} {S T : Set ι} (hST : S ⊆ T) :\n    piiUnionInter π S ⊆ piiUnionInter π T := fun _ ⟨t, ht_mem, ft, hft_mem_pi, h_eq⟩ =>\n  ⟨t, ht_mem.trans hST, ft, hft_mem_pi, h_eq⟩\n\n"}
{"name":"generateFrom_piiUnionInter_le","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nm : MeasurableSpace α\nπ : ι → Set (Set α)\nh : ∀ (n : ι), LE.le (MeasurableSpace.generateFrom (π n)) m\nS : Set ι\n⊢ LE.le (MeasurableSpace.generateFrom (piiUnionInter π S)) m","decl":"theorem generateFrom_piiUnionInter_le {m : MeasurableSpace α} (π : ι → Set (Set α))\n    (h : ∀ n, generateFrom (π n) ≤ m) (S : Set ι) : generateFrom (piiUnionInter π S) ≤ m := by\n  refine generateFrom_le ?_\n  rintro t ⟨ht_p, _, ft, hft_mem_pi, rfl⟩\n  refine Finset.measurableSet_biInter _ fun x hx_mem => (h x) _ ?_\n  exact measurableSet_generateFrom (hft_mem_pi x hx_mem)\n\n"}
{"name":"subset_piiUnionInter","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nπ : ι → Set (Set α)\nS : Set ι\ni : ι\nhis : Membership.mem S i\n⊢ HasSubset.Subset (π i) (piiUnionInter π S)","decl":"theorem subset_piiUnionInter {π : ι → Set (Set α)} {S : Set ι} {i : ι} (his : i ∈ S) :\n    π i ⊆ piiUnionInter π S := by\n  have h_ss : {i} ⊆ S := by\n    intro j hj\n    rw [mem_singleton_iff] at hj\n    rwa [hj]\n  refine Subset.trans ?_ (piiUnionInter_mono_right h_ss)\n  rw [piiUnionInter_singleton]\n  exact subset_union_left\n\n"}
{"name":"mem_piiUnionInter_of_measurableSet","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nm : ι → MeasurableSpace α\nS : Set ι\ni : ι\nhiS : Membership.mem S i\ns : Set α\nhs : MeasurableSet s\n⊢ Membership.mem (piiUnionInter (fun n => setOf fun s => MeasurableSet s) S) s","decl":"theorem mem_piiUnionInter_of_measurableSet (m : ι → MeasurableSpace α) {S : Set ι} {i : ι}\n    (hiS : i ∈ S) (s : Set α) (hs : MeasurableSet[m i] s) :\n    s ∈ piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S :=\n  subset_piiUnionInter hiS hs\n\n"}
{"name":"le_generateFrom_piiUnionInter","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nπ : ι → Set (Set α)\nS : Set ι\nx : ι\nhxS : Membership.mem S x\n⊢ LE.le (MeasurableSpace.generateFrom (π x)) (MeasurableSpace.generateFrom (piiUnionInter π S))","decl":"theorem le_generateFrom_piiUnionInter {π : ι → Set (Set α)} (S : Set ι) {x : ι} (hxS : x ∈ S) :\n    generateFrom (π x) ≤ generateFrom (piiUnionInter π S) :=\n  generateFrom_mono (subset_piiUnionInter hxS)\n\n"}
{"name":"measurableSet_iSup_of_mem_piiUnionInter","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nm : ι → MeasurableSpace α\nS : Set ι\nt : Set α\nht : Membership.mem (piiUnionInter (fun n => setOf fun s => MeasurableSet s) S) t\n⊢ MeasurableSet t","decl":"theorem measurableSet_iSup_of_mem_piiUnionInter (m : ι → MeasurableSpace α) (S : Set ι) (t : Set α)\n    (ht : t ∈ piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S) :\n    MeasurableSet[⨆ i ∈ S, m i] t := by\n  rcases ht with ⟨pt, hpt, ft, ht_m, rfl⟩\n  refine pt.measurableSet_biInter fun i hi => ?_\n  suffices h_le : m i ≤ ⨆ i ∈ S, m i from h_le (ft i) (ht_m i hi)\n  have hi' : i ∈ S := hpt hi\n  exact le_iSup₂ (f := fun i (_ : i ∈ S) => m i) i hi'\n\n"}
{"name":"generateFrom_piiUnionInter_measurableSet","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nι : Type u_4\nm : ι → MeasurableSpace α\nS : Set ι\n⊢ Eq (MeasurableSpace.generateFrom (piiUnionInter (fun n => setOf fun s => MeasurableSet s) S)) (iSup fun i => iSup fun h => m i)","decl":"theorem generateFrom_piiUnionInter_measurableSet (m : ι → MeasurableSpace α) (S : Set ι) :\n    generateFrom (piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S) = ⨆ i ∈ S, m i := by\n  refine le_antisymm ?_ ?_\n  · rw [← @generateFrom_measurableSet α (⨆ i ∈ S, m i)]\n    exact generateFrom_mono (measurableSet_iSup_of_mem_piiUnionInter m S)\n  · refine iSup₂_le fun i hi => ?_\n    rw [← @generateFrom_measurableSet α (m i)]\n    exact generateFrom_mono (mem_piiUnionInter_of_measurableSet m hi)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_4\ninst✝ : SizeOf α\nHas : Set α → Prop\nhas_empty : Has EmptyCollection.emptyCollection\nhas_compl : ∀ {a : Set α}, Has a → Has (HasCompl.compl a)\nhas_iUnion_nat : ∀ {f : Nat → Set α}, Pairwise (Function.onFun Disjoint f) → (∀ (i : Nat), Has (f i)) → Has (Set.iUnion fun i => f i)\n⊢ Eq (SizeOf.sizeOf { Has := Has, has_empty := has_empty, has_compl := has_compl, has_iUnion_nat := has_iUnion_nat }) (HAdd.hAdd 1 (SizeOf.sizeOf has_empty))","decl":"/-- A Dynkin system is a collection of subsets of a type `α` that contains the empty set,\n  is closed under complementation and under countable union of pairwise disjoint sets.\n  The disjointness condition is the only difference with `σ`-algebras.\n\n  The main purpose of Dynkin systems is to provide a powerful induction rule for σ-algebras\n  generated by a collection of sets which is stable under intersection.\n\n  A Dynkin system is also known as a \"λ-system\" or a \"d-system\".\n-/\nstructure DynkinSystem (α : Type*) where\n  /-- Predicate saying that a given set is contained in the Dynkin system. -/\n  Has : Set α → Prop\n  /-- A Dynkin system contains the empty set. -/\n  has_empty : Has ∅\n  /-- A Dynkin system is closed under complementation. -/\n  has_compl : ∀ {a}, Has a → Has aᶜ\n  /-- A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general\n  `MeasurableSpace.DynkinSystem.has_iUnion` instead. -/\n  has_iUnion_nat : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, Has (f i)) → Has (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.has_iUnion_nat","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_4\nself : MeasurableSpace.DynkinSystem α\nf : Nat → Set α\na✝¹ : Pairwise (Function.onFun Disjoint f)\na✝ : ∀ (i : Nat), self.Has (f i)\n⊢ self.Has (Set.iUnion fun i => f i)","decl":"/-- A Dynkin system is a collection of subsets of a type `α` that contains the empty set,\n  is closed under complementation and under countable union of pairwise disjoint sets.\n  The disjointness condition is the only difference with `σ`-algebras.\n\n  The main purpose of Dynkin systems is to provide a powerful induction rule for σ-algebras\n  generated by a collection of sets which is stable under intersection.\n\n  A Dynkin system is also known as a \"λ-system\" or a \"d-system\".\n-/\nstructure DynkinSystem (α : Type*) where\n  /-- Predicate saying that a given set is contained in the Dynkin system. -/\n  Has : Set α → Prop\n  /-- A Dynkin system contains the empty set. -/\n  has_empty : Has ∅\n  /-- A Dynkin system is closed under complementation. -/\n  has_compl : ∀ {a}, Has a → Has aᶜ\n  /-- A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general\n  `MeasurableSpace.DynkinSystem.has_iUnion` instead. -/\n  has_iUnion_nat : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, Has (f i)) → Has (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.has_compl","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_4\nself : MeasurableSpace.DynkinSystem α\na : Set α\na✝ : self.Has a\n⊢ self.Has (HasCompl.compl a)","decl":"/-- A Dynkin system is a collection of subsets of a type `α` that contains the empty set,\n  is closed under complementation and under countable union of pairwise disjoint sets.\n  The disjointness condition is the only difference with `σ`-algebras.\n\n  The main purpose of Dynkin systems is to provide a powerful induction rule for σ-algebras\n  generated by a collection of sets which is stable under intersection.\n\n  A Dynkin system is also known as a \"λ-system\" or a \"d-system\".\n-/\nstructure DynkinSystem (α : Type*) where\n  /-- Predicate saying that a given set is contained in the Dynkin system. -/\n  Has : Set α → Prop\n  /-- A Dynkin system contains the empty set. -/\n  has_empty : Has ∅\n  /-- A Dynkin system is closed under complementation. -/\n  has_compl : ∀ {a}, Has a → Has aᶜ\n  /-- A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general\n  `MeasurableSpace.DynkinSystem.has_iUnion` instead. -/\n  has_iUnion_nat : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, Has (f i)) → Has (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.has_empty","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_4\nself : MeasurableSpace.DynkinSystem α\n⊢ self.Has EmptyCollection.emptyCollection","decl":"/-- A Dynkin system is a collection of subsets of a type `α` that contains the empty set,\n  is closed under complementation and under countable union of pairwise disjoint sets.\n  The disjointness condition is the only difference with `σ`-algebras.\n\n  The main purpose of Dynkin systems is to provide a powerful induction rule for σ-algebras\n  generated by a collection of sets which is stable under intersection.\n\n  A Dynkin system is also known as a \"λ-system\" or a \"d-system\".\n-/\nstructure DynkinSystem (α : Type*) where\n  /-- Predicate saying that a given set is contained in the Dynkin system. -/\n  Has : Set α → Prop\n  /-- A Dynkin system contains the empty set. -/\n  has_empty : Has ∅\n  /-- A Dynkin system is closed under complementation. -/\n  has_compl : ∀ {a}, Has a → Has aᶜ\n  /-- A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general\n  `MeasurableSpace.DynkinSystem.has_iUnion` instead. -/\n  has_iUnion_nat : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, Has (f i)) → Has (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.mk.injEq","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_4\nHas✝ : Set α → Prop\nhas_empty✝ : Has✝ EmptyCollection.emptyCollection\nhas_compl✝ : ∀ {a : Set α}, Has✝ a → Has✝ (HasCompl.compl a)\nhas_iUnion_nat✝ : ∀ {f : Nat → Set α}, Pairwise (Function.onFun Disjoint f) → (∀ (i : Nat), Has✝ (f i)) → Has✝ (Set.iUnion fun i => f i)\nHas : Set α → Prop\nhas_empty : Has EmptyCollection.emptyCollection\nhas_compl : ∀ {a : Set α}, Has a → Has (HasCompl.compl a)\nhas_iUnion_nat : ∀ {f : Nat → Set α}, Pairwise (Function.onFun Disjoint f) → (∀ (i : Nat), Has (f i)) → Has (Set.iUnion fun i => f i)\n⊢ Eq (Eq { Has := Has✝, has_empty := has_empty✝, has_compl := has_compl✝, has_iUnion_nat := has_iUnion_nat✝ } { Has := Has, has_empty := has_empty, has_compl := has_compl, has_iUnion_nat := has_iUnion_nat }) (Eq Has✝ Has)","decl":"/-- A Dynkin system is a collection of subsets of a type `α` that contains the empty set,\n  is closed under complementation and under countable union of pairwise disjoint sets.\n  The disjointness condition is the only difference with `σ`-algebras.\n\n  The main purpose of Dynkin systems is to provide a powerful induction rule for σ-algebras\n  generated by a collection of sets which is stable under intersection.\n\n  A Dynkin system is also known as a \"λ-system\" or a \"d-system\".\n-/\nstructure DynkinSystem (α : Type*) where\n  /-- Predicate saying that a given set is contained in the Dynkin system. -/\n  Has : Set α → Prop\n  /-- A Dynkin system contains the empty set. -/\n  has_empty : Has ∅\n  /-- A Dynkin system is closed under complementation. -/\n  has_compl : ∀ {a}, Has a → Has aᶜ\n  /-- A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general\n  `MeasurableSpace.DynkinSystem.has_iUnion` instead. -/\n  has_iUnion_nat : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, Has (f i)) → Has (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.mk.inj","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_4\nHas✝ : Set α → Prop\nhas_empty✝ : Has✝ EmptyCollection.emptyCollection\nhas_compl✝ : ∀ {a : Set α}, Has✝ a → Has✝ (HasCompl.compl a)\nhas_iUnion_nat✝ : ∀ {f : Nat → Set α}, Pairwise (Function.onFun Disjoint f) → (∀ (i : Nat), Has✝ (f i)) → Has✝ (Set.iUnion fun i => f i)\nHas : Set α → Prop\nhas_empty : Has EmptyCollection.emptyCollection\nhas_compl : ∀ {a : Set α}, Has a → Has (HasCompl.compl a)\nhas_iUnion_nat : ∀ {f : Nat → Set α}, Pairwise (Function.onFun Disjoint f) → (∀ (i : Nat), Has (f i)) → Has (Set.iUnion fun i => f i)\nx✝ : Eq { Has := Has✝, has_empty := has_empty✝, has_compl := has_compl✝, has_iUnion_nat := has_iUnion_nat✝ } { Has := Has, has_empty := has_empty, has_compl := has_compl, has_iUnion_nat := has_iUnion_nat }\n⊢ Eq Has✝ Has","decl":"/-- A Dynkin system is a collection of subsets of a type `α` that contains the empty set,\n  is closed under complementation and under countable union of pairwise disjoint sets.\n  The disjointness condition is the only difference with `σ`-algebras.\n\n  The main purpose of Dynkin systems is to provide a powerful induction rule for σ-algebras\n  generated by a collection of sets which is stable under intersection.\n\n  A Dynkin system is also known as a \"λ-system\" or a \"d-system\".\n-/\nstructure DynkinSystem (α : Type*) where\n  /-- Predicate saying that a given set is contained in the Dynkin system. -/\n  Has : Set α → Prop\n  /-- A Dynkin system contains the empty set. -/\n  has_empty : Has ∅\n  /-- A Dynkin system is closed under complementation. -/\n  has_compl : ∀ {a}, Has a → Has aᶜ\n  /-- A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general\n  `MeasurableSpace.DynkinSystem.has_iUnion` instead. -/\n  has_iUnion_nat : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, Has (f i)) → Has (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.ext","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nd₁ d₂ : MeasurableSpace.DynkinSystem α\na✝ : ∀ (s : Set α), Iff (d₁.Has s) (d₂.Has s)\n⊢ Eq d₁ d₂","decl":"@[ext]\ntheorem ext : ∀ {d₁ d₂ : DynkinSystem α}, (∀ s : Set α, d₁.Has s ↔ d₂.Has s) → d₁ = d₂\n  | ⟨s₁, _, _, _⟩, ⟨s₂, _, _, _⟩, h => by\n    have : s₁ = s₂ := funext fun x => propext <| h x\n    subst this\n    rfl\n\n"}
{"name":"MeasurableSpace.DynkinSystem.ext_iff","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nd₁ d₂ : MeasurableSpace.DynkinSystem α\n⊢ Iff (Eq d₁ d₂) (∀ (s : Set α), Iff (d₁.Has s) (d₂.Has s))","decl":"@[ext]\ntheorem ext : ∀ {d₁ d₂ : DynkinSystem α}, (∀ s : Set α, d₁.Has s ↔ d₂.Has s) → d₁ = d₂\n  | ⟨s₁, _, _, _⟩, ⟨s₂, _, _, _⟩, h => by\n    have : s₁ = s₂ := funext fun x => propext <| h x\n    subst this\n    rfl\n\n"}
{"name":"MeasurableSpace.DynkinSystem.has_compl_iff","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nd : MeasurableSpace.DynkinSystem α\na : Set α\n⊢ Iff (d.Has (HasCompl.compl a)) (d.Has a)","decl":"theorem has_compl_iff {a} : d.Has aᶜ ↔ d.Has a :=\n  ⟨fun h => by simpa using d.has_compl h, fun h => d.has_compl h⟩\n\n"}
{"name":"MeasurableSpace.DynkinSystem.has_univ","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nd : MeasurableSpace.DynkinSystem α\n⊢ d.Has Set.univ","decl":"theorem has_univ : d.Has univ := by simpa using d.has_compl d.has_empty\n\n"}
{"name":"MeasurableSpace.DynkinSystem.has_iUnion","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nd : MeasurableSpace.DynkinSystem α\nβ : Type u_4\ninst✝ : Countable β\nf : β → Set α\nhd : Pairwise (Function.onFun Disjoint f)\nh : ∀ (i : β), d.Has (f i)\n⊢ d.Has (Set.iUnion fun i => f i)","decl":"theorem has_iUnion {β} [Countable β] {f : β → Set α} (hd : Pairwise (Disjoint on f))\n    (h : ∀ i, d.Has (f i)) : d.Has (⋃ i, f i) := by\n  cases nonempty_encodable β\n  rw [← Encodable.iUnion_decode₂]\n  exact\n    d.has_iUnion_nat (Encodable.iUnion_decode₂_disjoint_on hd) fun n =>\n      Encodable.iUnion_decode₂_cases d.has_empty h\n\n"}
{"name":"MeasurableSpace.DynkinSystem.has_union","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nd : MeasurableSpace.DynkinSystem α\ns₁ s₂ : Set α\nh₁ : d.Has s₁\nh₂ : d.Has s₂\nh : Disjoint s₁ s₂\n⊢ d.Has (Union.union s₁ s₂)","decl":"theorem has_union {s₁ s₂ : Set α} (h₁ : d.Has s₁) (h₂ : d.Has s₂) (h : Disjoint s₁ s₂) :\n    d.Has (s₁ ∪ s₂) := by\n  rw [union_eq_iUnion]\n  exact d.has_iUnion (pairwise_disjoint_on_bool.2 h) (Bool.forall_bool.2 ⟨h₂, h₁⟩)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.has_diff","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nd : MeasurableSpace.DynkinSystem α\ns₁ s₂ : Set α\nh₁ : d.Has s₁\nh₂ : d.Has s₂\nh : HasSubset.Subset s₂ s₁\n⊢ d.Has (SDiff.sdiff s₁ s₂)","decl":"theorem has_diff {s₁ s₂ : Set α} (h₁ : d.Has s₁) (h₂ : d.Has s₂) (h : s₂ ⊆ s₁) :\n    d.Has (s₁ \\ s₂) := by\n  apply d.has_compl_iff.1\n  simp only [diff_eq, compl_inter, compl_compl]\n  exact d.has_union (d.has_compl h₁) h₂ (disjoint_compl_left.mono_right h)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.le_def","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\na b : MeasurableSpace.DynkinSystem α\n⊢ Iff (LE.le a b) (LE.le a.Has b.Has)","decl":"theorem le_def {a b : DynkinSystem α} : a ≤ b ↔ a.Has ≤ b.Has :=\n  Iff.rfl\n\n"}
{"name":"MeasurableSpace.DynkinSystem.ofMeasurableSpace_le_ofMeasurableSpace_iff","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nm₁ m₂ : MeasurableSpace α\n⊢ Iff (LE.le (MeasurableSpace.DynkinSystem.ofMeasurableSpace m₁) (MeasurableSpace.DynkinSystem.ofMeasurableSpace m₂)) (LE.le m₁ m₂)","decl":"theorem ofMeasurableSpace_le_ofMeasurableSpace_iff {m₁ m₂ : MeasurableSpace α} :\n    ofMeasurableSpace m₁ ≤ ofMeasurableSpace m₂ ↔ m₁ ≤ m₂ :=\n  Iff.rfl\n\n"}
{"name":"MeasurableSpace.DynkinSystem.GenerateHas.brecOn","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\ns : Set (Set α)\nmotive✝ : (a : Set α) → MeasurableSpace.DynkinSystem.GenerateHas s a → Prop\na✝ : Set α\nx✝ : MeasurableSpace.DynkinSystem.GenerateHas s a✝\nih✝ : ∀ (a : Set α) (x : MeasurableSpace.DynkinSystem.GenerateHas s a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- The least Dynkin system containing a collection of basic sets.\n  This inductive type gives the underlying collection of sets. -/\ninductive GenerateHas (s : Set (Set α)) : Set α → Prop\n  | basic : ∀ t ∈ s, GenerateHas s t\n  | empty : GenerateHas s ∅\n  | compl : ∀ {a}, GenerateHas s a → GenerateHas s aᶜ\n  | iUnion : ∀ {f : ℕ → Set α},\n    Pairwise (Disjoint on f) → (∀ i, GenerateHas s (f i)) → GenerateHas s (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.DynkinSystem.generateHas_compl","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nC : Set (Set α)\ns : Set α\n⊢ Iff (MeasurableSpace.DynkinSystem.GenerateHas C (HasCompl.compl s)) (MeasurableSpace.DynkinSystem.GenerateHas C s)","decl":"theorem generateHas_compl {C : Set (Set α)} {s : Set α} : GenerateHas C sᶜ ↔ GenerateHas C s := by\n  refine ⟨?_, GenerateHas.compl⟩\n  intro h\n  convert GenerateHas.compl h\n  simp\n\n"}
{"name":"MeasurableSpace.DynkinSystem.generateHas_def","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nC : Set (Set α)\n⊢ Eq (MeasurableSpace.DynkinSystem.generate C).Has (MeasurableSpace.DynkinSystem.GenerateHas C)","decl":"theorem generateHas_def {C : Set (Set α)} : (generate C).Has = GenerateHas C :=\n  rfl\n\n"}
{"name":"MeasurableSpace.DynkinSystem.ofMeasurableSpace_toMeasurableSpace","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nd : MeasurableSpace.DynkinSystem α\nh_inter : ∀ (s₁ s₂ : Set α), d.Has s₁ → d.Has s₂ → d.Has (Inter.inter s₁ s₂)\n⊢ Eq (MeasurableSpace.DynkinSystem.ofMeasurableSpace (d.toMeasurableSpace h_inter)) d","decl":"theorem ofMeasurableSpace_toMeasurableSpace\n    (h_inter : ∀ s₁ s₂, d.Has s₁ → d.Has s₂ → d.Has (s₁ ∩ s₂)) :\n    ofMeasurableSpace (d.toMeasurableSpace h_inter) = d :=\n  ext fun _ => Iff.rfl\n\n"}
{"name":"MeasurableSpace.DynkinSystem.generate_le","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nd : MeasurableSpace.DynkinSystem α\ns : Set (Set α)\nh : ∀ (t : Set α), Membership.mem s t → d.Has t\n⊢ LE.le (MeasurableSpace.DynkinSystem.generate s) d","decl":"theorem generate_le {s : Set (Set α)} (h : ∀ t ∈ s, d.Has t) : generate s ≤ d := fun _ ht =>\n  ht.recOn h d.has_empty (fun {_} _ h => d.has_compl h) fun {_} hd _ hf => d.has_iUnion hd hf\n\n"}
{"name":"MeasurableSpace.DynkinSystem.generate_has_subset_generate_measurable","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nC : Set (Set α)\ns : Set α\nhs : (MeasurableSpace.DynkinSystem.generate C).Has s\n⊢ MeasurableSet s","decl":"theorem generate_has_subset_generate_measurable {C : Set (Set α)} {s : Set α}\n    (hs : (generate C).Has s) : MeasurableSet[generateFrom C] s :=\n  generate_le (ofMeasurableSpace (generateFrom C)) (fun _ => measurableSet_generateFrom) s hs\n\n"}
{"name":"MeasurableSpace.DynkinSystem.generate_inter","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\ns : Set (Set α)\nhs : IsPiSystem s\nt₁ t₂ : Set α\nht₁ : (MeasurableSpace.DynkinSystem.generate s).Has t₁\nht₂ : (MeasurableSpace.DynkinSystem.generate s).Has t₂\n⊢ (MeasurableSpace.DynkinSystem.generate s).Has (Inter.inter t₁ t₂)","decl":"theorem generate_inter {s : Set (Set α)} (hs : IsPiSystem s) {t₁ t₂ : Set α}\n    (ht₁ : (generate s).Has t₁) (ht₂ : (generate s).Has t₂) : (generate s).Has (t₁ ∩ t₂) :=\n  have : generate s ≤ (generate s).restrictOn ht₂ :=\n    generate_le _ fun s₁ hs₁ =>\n      have : (generate s).Has s₁ := GenerateHas.basic s₁ hs₁\n      have : generate s ≤ (generate s).restrictOn this :=\n        generate_le _ fun s₂ hs₂ =>\n          show (generate s).Has (s₂ ∩ s₁) from\n            (s₂ ∩ s₁).eq_empty_or_nonempty.elim (fun h => h.symm ▸ GenerateHas.empty) fun h =>\n              GenerateHas.basic _ <| hs _ hs₂ _ hs₁ h\n      have : (generate s).Has (t₂ ∩ s₁) := this _ ht₂\n      show (generate s).Has (s₁ ∩ t₂) by rwa [inter_comm]\n  this _ ht₁\n\n"}
{"name":"MeasurableSpace.DynkinSystem.generateFrom_eq","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\ns : Set (Set α)\nhs : IsPiSystem s\n⊢ Eq (MeasurableSpace.generateFrom s) ((MeasurableSpace.DynkinSystem.generate s).toMeasurableSpace ⋯)","decl":"/-- **Dynkin's π-λ theorem**:\n  Given a collection of sets closed under binary intersections, then the Dynkin system it\n  generates is equal to the σ-algebra it generates.\n  This result is known as the π-λ theorem.\n  A collection of sets closed under binary intersection is called a π-system (often requiring\n  additionally that it is non-empty, but we drop this condition in the formalization).\n-/\ntheorem generateFrom_eq {s : Set (Set α)} (hs : IsPiSystem s) :\n    generateFrom s = (generate s).toMeasurableSpace fun _ _ => generate_inter hs :=\n  le_antisymm (generateFrom_le fun t ht => GenerateHas.basic t ht)\n    (ofMeasurableSpace_le_ofMeasurableSpace_iff.mp <| by\n      rw [ofMeasurableSpace_toMeasurableSpace]\n      exact generate_le _ fun t ht => measurableSet_generateFrom ht)\n\n"}
{"name":"MeasurableSpace.induction_on_inter","module":"Mathlib.MeasureTheory.PiSystem","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nC : (s : Set α) → MeasurableSet s → Prop\ns : Set (Set α)\nh_eq : Eq m (MeasurableSpace.generateFrom s)\nh_inter : IsPiSystem s\nempty : C EmptyCollection.emptyCollection ⋯\nbasic : ∀ (t : Set α) (ht : Membership.mem s t), C t ⋯\ncompl : ∀ (t : Set α) (htm : MeasurableSet t), C t htm → C (HasCompl.compl t) ⋯\niUnion : ∀ (f : Nat → Set α), Pairwise (Function.onFun Disjoint f) → ∀ (hfm : ∀ (i : Nat), MeasurableSet (f i)), (∀ (i : Nat), C (f i) ⋯) → C (Set.iUnion fun i => f i) ⋯\nt : Set α\nht : MeasurableSet t\n⊢ C t ht","decl":"/-- Induction principle for measurable sets.\nIf `s` is a π-system that generates the product `σ`-algebra on `α`\nand a predicate `C` defined on measurable sets is true\n\n- on the empty set;\n- on each set `t ∈ s`;\n- on the complement of a measurable set that satisfies `C`;\n- on the union of a sequence of pairwise disjoint measurable sets that satisfy `C`,\n\nthen it is true on all measurable sets in `α`. -/\n@[elab_as_elim]\ntheorem induction_on_inter {m : MeasurableSpace α} {C : ∀ s : Set α, MeasurableSet s → Prop}\n    {s : Set (Set α)} (h_eq : m = generateFrom s) (h_inter : IsPiSystem s)\n    (empty : C ∅ .empty) (basic : ∀ t (ht : t ∈ s), C t <| h_eq ▸ .basic t ht)\n    (compl : ∀ t (htm : MeasurableSet t), C t htm → C tᶜ htm.compl)\n    (iUnion : ∀ (f : ℕ → Set α), Pairwise (Disjoint on f) → ∀ (hfm : ∀ i, MeasurableSet (f i)),\n      (∀ i, C (f i) (hfm i)) → C (⋃ i, f i) (.iUnion hfm)) :\n    ∀ t (ht : MeasurableSet t), C t ht := by\n  have eq : MeasurableSet = DynkinSystem.GenerateHas s := by\n    rw [h_eq, DynkinSystem.generateFrom_eq h_inter]\n    rfl\n  suffices ∀ t (ht : DynkinSystem.GenerateHas s t), C t (eq ▸ ht) from\n    fun t ht ↦ this t (eq ▸ ht)\n  intro t ht\n  induction ht with\n  | basic u hu => exact basic u hu\n  | empty => exact empty\n  | @compl u hu ihu => exact compl _ (eq ▸ hu) ihu\n  | @iUnion f hfd hf ihf => exact iUnion f hfd (eq ▸ hf) ihf\n\n"}
