{"name":"HasFTaylorSeriesUpToOn.fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\ns : Set E\nself : HasFTaylorSeriesUpToOn n f p s\nm : Nat\naâœÂ¹ : LT.lt (â†‘m) n\nx : E\naâœ : Membership.mem s x\nâŠ¢ HasFDerivWithinAt (fun x => p x m) (p x m.succ).curryLeft s x","decl":"/-- `HasFTaylorSeriesUpToOn n f p s` registers the fact that `p 0 = f` and `p (m+1)` is a\nderivative of `p m` for `m < n`, and is continuous for `m â‰¤ n`. This is a predicate analogous to\n`HasFDerivWithinAt` but for higher order derivatives.\n\nNotice that `p` does not sum up to `f` on the diagonal (`FormalMultilinearSeries.sum`), even if\n`f` is analytic and `n = âˆ`: an additional `1/m!` factor on the `m`th term is necessary for that. -/\nstructure HasFTaylorSeriesUpToOn\n  (n : WithTop â„•âˆ) (f : E â†’ F) (p : E â†’ FormalMultilinearSeries ğ•œ E F) (s : Set E) : Prop where\n  zero_eq : âˆ€ x âˆˆ s, (p x 0).curry0 = f x\n  protected fderivWithin : âˆ€ m : â„•, m < n â†’ âˆ€ x âˆˆ s,\n    HasFDerivWithinAt (p Â· m) (p x m.succ).curryLeft s x\n  cont : âˆ€ m : â„•, m â‰¤ n â†’ ContinuousOn (p Â· m) s\n\n"}
{"name":"HasFTaylorSeriesUpToOn.zero_eq","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\ns : Set E\nself : HasFTaylorSeriesUpToOn n f p s\nx : E\naâœ : Membership.mem s x\nâŠ¢ Eq (p x 0).curry0 (f x)","decl":"/-- `HasFTaylorSeriesUpToOn n f p s` registers the fact that `p 0 = f` and `p (m+1)` is a\nderivative of `p m` for `m < n`, and is continuous for `m â‰¤ n`. This is a predicate analogous to\n`HasFDerivWithinAt` but for higher order derivatives.\n\nNotice that `p` does not sum up to `f` on the diagonal (`FormalMultilinearSeries.sum`), even if\n`f` is analytic and `n = âˆ`: an additional `1/m!` factor on the `m`th term is necessary for that. -/\nstructure HasFTaylorSeriesUpToOn\n  (n : WithTop â„•âˆ) (f : E â†’ F) (p : E â†’ FormalMultilinearSeries ğ•œ E F) (s : Set E) : Prop where\n  zero_eq : âˆ€ x âˆˆ s, (p x 0).curry0 = f x\n  protected fderivWithin : âˆ€ m : â„•, m < n â†’ âˆ€ x âˆˆ s,\n    HasFDerivWithinAt (p Â· m) (p x m.succ).curryLeft s x\n  cont : âˆ€ m : â„•, m â‰¤ n â†’ ContinuousOn (p Â· m) s\n\n"}
{"name":"HasFTaylorSeriesUpToOn.cont","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\ns : Set E\nself : HasFTaylorSeriesUpToOn n f p s\nm : Nat\naâœ : LE.le (â†‘m) n\nâŠ¢ ContinuousOn (fun x => p x m) s","decl":"/-- `HasFTaylorSeriesUpToOn n f p s` registers the fact that `p 0 = f` and `p (m+1)` is a\nderivative of `p m` for `m < n`, and is continuous for `m â‰¤ n`. This is a predicate analogous to\n`HasFDerivWithinAt` but for higher order derivatives.\n\nNotice that `p` does not sum up to `f` on the diagonal (`FormalMultilinearSeries.sum`), even if\n`f` is analytic and `n = âˆ`: an additional `1/m!` factor on the `m`th term is necessary for that. -/\nstructure HasFTaylorSeriesUpToOn\n  (n : WithTop â„•âˆ) (f : E â†’ F) (p : E â†’ FormalMultilinearSeries ğ•œ E F) (s : Set E) : Prop where\n  zero_eq : âˆ€ x âˆˆ s, (p x 0).curry0 = f x\n  protected fderivWithin : âˆ€ m : â„•, m < n â†’ âˆ€ x âˆˆ s,\n    HasFDerivWithinAt (p Â· m) (p x m.succ).curryLeft s x\n  cont : âˆ€ m : â„•, m â‰¤ n â†’ ContinuousOn (p Â· m) s\n\n"}
{"name":"HasFTaylorSeriesUpToOn.zero_eq'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nx : E\nhx : Membership.mem s x\nâŠ¢ Eq (p x 0) ((continuousMultilinearCurryFin0 ğ•œ E F).symm (f x))","decl":"theorem HasFTaylorSeriesUpToOn.zero_eq' (h : HasFTaylorSeriesUpToOn n f p s) {x : E} (hx : x âˆˆ s) :\n    p x 0 = (continuousMultilinearCurryFin0 ğ•œ E F).symm (f x) := by\n  rw [â† h.zero_eq x hx]\n  exact (p x 0).uncurry0_curry0.symm\n\n"}
{"name":"HasFTaylorSeriesUpToOn.congr","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nhâ‚ : âˆ€ (x : E), Membership.mem s x â†’ Eq (fâ‚ x) (f x)\nâŠ¢ HasFTaylorSeriesUpToOn n fâ‚ p s","decl":"/-- If two functions coincide on a set `s`, then a Taylor series for the first one is as well a\nTaylor series for the second one. -/\ntheorem HasFTaylorSeriesUpToOn.congr (h : HasFTaylorSeriesUpToOn n f p s)\n    (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) : HasFTaylorSeriesUpToOn n fâ‚ p s := by\n  refine âŸ¨fun x hx => ?_, h.fderivWithin, h.contâŸ©\n  rw [hâ‚ x hx]\n  exact h.zero_eq x hx\n\n"}
{"name":"HasFTaylorSeriesUpToOn.congr_series","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\np q : E â†’ FormalMultilinearSeries ğ•œ E F\nhp : HasFTaylorSeriesUpToOn n f p s\nhpq : âˆ€ (m : Nat), LE.le (â†‘m) n â†’ Set.EqOn (fun x => p x m) (fun x => q x m) s\nâŠ¢ HasFTaylorSeriesUpToOn n f q s","decl":"theorem HasFTaylorSeriesUpToOn.congr_series {q} (hp : HasFTaylorSeriesUpToOn n f p s)\n    (hpq : âˆ€ m : â„•, m â‰¤ n â†’ EqOn (p Â· m) (q Â· m) s) :\n    HasFTaylorSeriesUpToOn n f q s where\n  zero_eq x hx := by simp only [â† (hpq 0 (zero_le n) hx), hp.zero_eq x hx]\n  fderivWithin m hm x hx := by\n    refine ((hp.fderivWithin m hm x hx).congr' (hpq m hm.le).symm hx).congr_fderiv ?_\n    refine congrArg _ (hpq (m + 1) ?_ hx)\n    exact ENat.add_one_natCast_le_withTop_of_lt hm\n  cont m hm := (hp.cont m hm).congr (hpq m hm).symm\n\n"}
{"name":"HasFTaylorSeriesUpToOn.mono","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nt : Set E\nhst : HasSubset.Subset t s\nâŠ¢ HasFTaylorSeriesUpToOn n f p t","decl":"theorem HasFTaylorSeriesUpToOn.mono (h : HasFTaylorSeriesUpToOn n f p s) {t : Set E} (hst : t âŠ† s) :\n    HasFTaylorSeriesUpToOn n f p t :=\n  âŸ¨fun x hx => h.zero_eq x (hst hx), fun m hm x hx => (h.fderivWithin m hm x (hst hx)).mono hst,\n    fun m hm => (h.cont m hm).mono hstâŸ©\n\n"}
{"name":"HasFTaylorSeriesUpToOn.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nm n : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nhmn : LE.le m n\nâŠ¢ HasFTaylorSeriesUpToOn m f p s","decl":"theorem HasFTaylorSeriesUpToOn.of_le (h : HasFTaylorSeriesUpToOn n f p s) (hmn : m â‰¤ n) :\n    HasFTaylorSeriesUpToOn m f p s :=\n  âŸ¨h.zero_eq, fun k hk x hx => h.fderivWithin k (lt_of_lt_of_le hk hmn) x hx, fun k hk =>\n    h.cont k (le_trans hk hmn)âŸ©\n\n"}
{"name":"HasFTaylorSeriesUpToOn.continuousOn","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nâŠ¢ ContinuousOn f s","decl":"theorem HasFTaylorSeriesUpToOn.continuousOn (h : HasFTaylorSeriesUpToOn n f p s) :\n    ContinuousOn f s := by\n  have := (h.cont 0 bot_le).congr fun x hx => (h.zero_eq' hx).symm\n  rwa [â† (continuousMultilinearCurryFin0 ğ•œ E F).symm.comp_continuousOn_iff]\n\n"}
{"name":"hasFTaylorSeriesUpToOn_zero_iff","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nâŠ¢ Iff (HasFTaylorSeriesUpToOn 0 f p s) (And (ContinuousOn f s) (âˆ€ (x : E), Membership.mem s x â†’ Eq (p x 0).curry0 (f x)))","decl":"theorem hasFTaylorSeriesUpToOn_zero_iff :\n    HasFTaylorSeriesUpToOn 0 f p s â†” ContinuousOn f s âˆ§ âˆ€ x âˆˆ s, (p x 0).curry0 = f x := by\n  refine âŸ¨fun H => âŸ¨H.continuousOn, H.zero_eqâŸ©, fun H =>\n      âŸ¨H.2, fun m hm => False.elim (not_le.2 hm bot_le), fun m hm â†¦ ?_âŸ©âŸ©\n  obtain rfl : m = 0 := mod_cast hm.antisymm (zero_le _)\n  have : EqOn (p Â· 0) ((continuousMultilinearCurryFin0 ğ•œ E F).symm âˆ˜ f) s := fun x hx â†¦\n    (continuousMultilinearCurryFin0 ğ•œ E F).eq_symm_apply.2 (H.2 x hx)\n  rw [continuousOn_congr this, LinearIsometryEquiv.comp_continuousOn_iff]\n  exact H.1\n\n"}
{"name":"hasFTaylorSeriesUpToOn_top_iff_add","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nN : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nhN : LE.le (â†‘Top.top) N\nk : Nat\nâŠ¢ Iff (HasFTaylorSeriesUpToOn N f p s) (âˆ€ (n : Nat), HasFTaylorSeriesUpToOn (â†‘(HAdd.hAdd n k)) f p s)","decl":"theorem hasFTaylorSeriesUpToOn_top_iff_add (hN : âˆ â‰¤ N) (k : â„•) :\n    HasFTaylorSeriesUpToOn N f p s â†” âˆ€ n : â„•, HasFTaylorSeriesUpToOn (n + k : â„•) f p s := by\n  constructor\n  Â· intro H n\n    apply H.of_le (natCast_le_of_coe_top_le_withTop hN _)\n  Â· intro H\n    constructor\n    Â· exact (H 0).zero_eq\n    Â· intro m _\n      apply (H m.succ).fderivWithin m (by norm_cast; omega)\n    Â· intro m _\n      apply (H m).cont m (by simp)\n\n"}
{"name":"hasFTaylorSeriesUpToOn_top_iff","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nN : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nhN : LE.le (â†‘Top.top) N\nâŠ¢ Iff (HasFTaylorSeriesUpToOn N f p s) (âˆ€ (n : Nat), HasFTaylorSeriesUpToOn (â†‘n) f p s)","decl":"theorem hasFTaylorSeriesUpToOn_top_iff (hN : âˆ â‰¤ N) :\n    HasFTaylorSeriesUpToOn N f p s â†” âˆ€ n : â„•, HasFTaylorSeriesUpToOn n f p s := by\n  simpa using hasFTaylorSeriesUpToOn_top_iff_add hN 0\n\n"}
{"name":"hasFTaylorSeriesUpToOn_top_iff'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nN : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nhN : LE.le (â†‘Top.top) N\nâŠ¢ Iff (HasFTaylorSeriesUpToOn N f p s) (And (âˆ€ (x : E), Membership.mem s x â†’ Eq (p x 0).curry0 (f x)) (âˆ€ (m : Nat) (x : E), Membership.mem s x â†’ HasFDerivWithinAt (fun y => p y m) (p x m.succ).curryLeft s x))","decl":"/-- In the case that `n = âˆ` we don't need the continuity assumption in\n`HasFTaylorSeriesUpToOn`. -/\ntheorem hasFTaylorSeriesUpToOn_top_iff' (hN : âˆ â‰¤ N) :\n    HasFTaylorSeriesUpToOn N f p s â†”\n      (âˆ€ x âˆˆ s, (p x 0).curry0 = f x) âˆ§\n        âˆ€ m : â„•, âˆ€ x âˆˆ s, HasFDerivWithinAt (fun y => p y m) (p x m.succ).curryLeft s x := by\n  -- Everything except for the continuity is trivial:\n  refine âŸ¨fun h => âŸ¨h.1, fun m => h.2 m (natCast_lt_of_coe_top_le_withTop hN _)âŸ©, fun h =>\n    âŸ¨h.1, fun m _ => h.2 m, fun m _ x hx =>\n      -- The continuity follows from the existence of a derivative:\n      (h.2 m x hx).continuousWithinAtâŸ©âŸ©\n\n"}
{"name":"HasFTaylorSeriesUpToOn.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nhn : LE.le 1 n\nhx : Membership.mem s x\nâŠ¢ HasFDerivWithinAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p x 1)) s x","decl":"/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem HasFTaylorSeriesUpToOn.hasFDerivWithinAt (h : HasFTaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n)\n    (hx : x âˆˆ s) : HasFDerivWithinAt f (continuousMultilinearCurryFin1 ğ•œ E F (p x 1)) s x := by\n  have A : âˆ€ y âˆˆ s, f y = (continuousMultilinearCurryFin0 ğ•œ E F) (p y 0) := fun y hy â†¦\n    (h.zero_eq y hy).symm\n  suffices H : HasFDerivWithinAt (continuousMultilinearCurryFin0 ğ•œ E F âˆ˜ (p Â· 0))\n    (continuousMultilinearCurryFin1 ğ•œ E F (p x 1)) s x from H.congr A (A x hx)\n  rw [LinearIsometryEquiv.comp_hasFDerivWithinAt_iff']\n  have : ((0 : â„•) : â„•âˆ) < n := zero_lt_one.trans_le hn\n  convert h.fderivWithin _ this x hx\n  ext y v\n  change (p x 1) (snoc 0 y) = (p x 1) (cons y v)\n  congr with i\n  rw [Unique.eq_default (Î± := Fin 1) i]\n  rfl\n\n"}
{"name":"HasFTaylorSeriesUpToOn.differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nhn : LE.le 1 n\nâŠ¢ DifferentiableOn ğ•œ f s","decl":"theorem HasFTaylorSeriesUpToOn.differentiableOn (h : HasFTaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n) :\n    DifferentiableOn ğ•œ f s := fun _x hx => (h.hasFDerivWithinAt hn hx).differentiableWithinAt\n\n"}
{"name":"HasFTaylorSeriesUpToOn.hasFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nhn : LE.le 1 n\nhx : Membership.mem (nhds x) s\nâŠ¢ HasFDerivAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p x 1)) x","decl":"/-- If a function has a Taylor series at order at least `1` on a neighborhood of `x`, then the term\nof order `1` of this series is a derivative of `f` at `x`. -/\ntheorem HasFTaylorSeriesUpToOn.hasFDerivAt (h : HasFTaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n)\n    (hx : s âˆˆ ğ“ x) : HasFDerivAt f (continuousMultilinearCurryFin1 ğ•œ E F (p x 1)) x :=\n  (h.hasFDerivWithinAt hn (mem_of_mem_nhds hx)).hasFDerivAt hx\n\n"}
{"name":"HasFTaylorSeriesUpToOn.eventually_hasFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nhn : LE.le 1 n\nhx : Membership.mem (nhds x) s\nâŠ¢ Filter.Eventually (fun y => HasFDerivAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p y 1)) y) (nhds x)","decl":"/-- If a function has a Taylor series at order at least `1` on a neighborhood of `x`, then\nin a neighborhood of `x`, the term of order `1` of this series is a derivative of `f`. -/\ntheorem HasFTaylorSeriesUpToOn.eventually_hasFDerivAt (h : HasFTaylorSeriesUpToOn n f p s)\n    (hn : 1 â‰¤ n) (hx : s âˆˆ ğ“ x) :\n    âˆ€á¶  y in ğ“ x, HasFDerivAt f (continuousMultilinearCurryFin1 ğ•œ E F (p y 1)) y :=\n  (eventually_eventually_nhds.2 hx).mono fun _y hy => h.hasFDerivAt hn hy\n\n"}
{"name":"HasFTaylorSeriesUpToOn.differentiableAt","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nhn : LE.le 1 n\nhx : Membership.mem (nhds x) s\nâŠ¢ DifferentiableAt ğ•œ f x","decl":"/-- If a function has a Taylor series at order at least `1` on a neighborhood of `x`, then\nit is differentiable at `x`. -/\ntheorem HasFTaylorSeriesUpToOn.differentiableAt (h : HasFTaylorSeriesUpToOn n f p s) (hn : 1 â‰¤ n)\n    (hx : s âˆˆ ğ“ x) : DifferentiableAt ğ•œ f x :=\n  (h.hasFDerivAt hn hx).differentiableAt\n\n"}
{"name":"hasFTaylorSeriesUpToOn_succ_iff_left","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nn : Nat\nâŠ¢ Iff (HasFTaylorSeriesUpToOn (HAdd.hAdd (â†‘n) 1) f p s) (And (HasFTaylorSeriesUpToOn (â†‘n) f p s) (And (âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt (fun y => p y n) (p x n.succ).curryLeft s x) (ContinuousOn (fun x => p x (HAdd.hAdd n 1)) s)))","decl":"/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p` is a Taylor series up to `n`, and\n`p (n + 1)` is a derivative of `p n`. -/\ntheorem hasFTaylorSeriesUpToOn_succ_iff_left {n : â„•} :\n    HasFTaylorSeriesUpToOn (n + 1) f p s â†”\n      HasFTaylorSeriesUpToOn n f p s âˆ§\n        (âˆ€ x âˆˆ s, HasFDerivWithinAt (fun y => p y n) (p x n.succ).curryLeft s x) âˆ§\n          ContinuousOn (fun x => p x (n + 1)) s := by\n  constructor\n  Â· exact fun h â†¦ âŸ¨h.of_le (mod_cast Nat.le_succ n),\n      h.fderivWithin _ (mod_cast lt_add_one n), h.cont (n + 1) le_rflâŸ©\n  Â· intro h\n    constructor\n    Â· exact h.1.zero_eq\n    Â· intro m hm\n      by_cases h' : m < n\n      Â· exact h.1.fderivWithin m (mod_cast h')\n      Â· have : m = n := Nat.eq_of_lt_succ_of_not_lt (mod_cast hm) h'\n        rw [this]\n        exact h.2.1\n    Â· intro m hm\n      by_cases h' : m â‰¤ n\n      Â· apply h.1.cont m (mod_cast h')\n      Â· have : m = n + 1 := le_antisymm (mod_cast hm) (not_le.1 h')\n        rw [this]\n        exact h.2.2\n\n"}
{"name":"HasFTaylorSeriesUpToOn.shift_of_succ","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nn : Nat\nH : HasFTaylorSeriesUpToOn (â†‘(HAdd.hAdd n 1)) f p s\nâŠ¢ HasFTaylorSeriesUpToOn (â†‘n) (fun x => (continuousMultilinearCurryFin1 ğ•œ E F) (p x 1)) (fun x => (p x).shift) s","decl":"set_option maxSynthPendingDepth 2 in\n-- Porting note: this was split out from `hasFTaylorSeriesUpToOn_succ_iff_right` to avoid a timeout.\ntheorem HasFTaylorSeriesUpToOn.shift_of_succ\n    {n : â„•} (H : HasFTaylorSeriesUpToOn (n + 1 : â„•) f p s) :\n    (HasFTaylorSeriesUpToOn n (fun x => continuousMultilinearCurryFin1 ğ•œ E F (p x 1))\n      (fun x => (p x).shift)) s := by\n  constructor\n  Â· intro x _\n    rfl\n  Â· intro m (hm : (m : WithTop â„•âˆ) < n) x (hx : x âˆˆ s)\n    have A : (m.succ : WithTop â„•âˆ) < n.succ := by\n      rw [Nat.cast_lt] at hm âŠ¢\n      exact Nat.succ_lt_succ hm\n    change HasFDerivWithinAt (continuousMultilinearCurryRightEquiv' ğ•œ m E F âˆ˜ (p Â· m.succ))\n      (p x m.succ.succ).curryRight.curryLeft s x\n    rw [(continuousMultilinearCurryRightEquiv' ğ•œ m E F).comp_hasFDerivWithinAt_iff']\n    convert H.fderivWithin _ A x hx\n    ext y v\n    change p x (m + 2) (snoc (cons y (init v)) (v (last _))) = p x (m + 2) (cons y v)\n    rw [â† cons_snoc_eq_snoc_cons, snoc_init_self]\n  Â· intro m (hm : (m : WithTop â„•âˆ) â‰¤ n)\n    suffices A : ContinuousOn (p Â· (m + 1)) s from\n      (continuousMultilinearCurryRightEquiv' ğ•œ m E F).continuous.comp_continuousOn A\n    refine H.cont _ ?_\n    rw [Nat.cast_le] at hm âŠ¢\n    exact Nat.succ_le_succ hm\n\n"}
{"name":"hasFTaylorSeriesUpToOn_succ_nat_iff_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nn : Nat\nâŠ¢ Iff (HasFTaylorSeriesUpToOn (â†‘(HAdd.hAdd n 1)) f p s) (And (âˆ€ (x : E), Membership.mem s x â†’ Eq (p x 0).curry0 (f x)) (And (âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt (fun y => p y 0) (p x 1).curryLeft s x) (HasFTaylorSeriesUpToOn (â†‘n) (fun x => (continuousMultilinearCurryFin1 ğ•œ E F) (p x 1)) (fun x => (p x).shift) s)))","decl":"/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. Version for `n : â„•`. -/\ntheorem hasFTaylorSeriesUpToOn_succ_nat_iff_right {n : â„•} :\n    HasFTaylorSeriesUpToOn (n + 1 : â„•) f p s â†”\n      (âˆ€ x âˆˆ s, (p x 0).curry0 = f x) âˆ§\n        (âˆ€ x âˆˆ s, HasFDerivWithinAt (fun y => p y 0) (p x 1).curryLeft s x) âˆ§\n          HasFTaylorSeriesUpToOn n (fun x => continuousMultilinearCurryFin1 ğ•œ E F (p x 1))\n            (fun x => (p x).shift) s := by\n  constructor\n  Â· intro H\n    refine âŸ¨H.zero_eq, H.fderivWithin 0 (Nat.cast_lt.2 (Nat.succ_pos n)), ?_âŸ©\n    exact H.shift_of_succ\n  Â· rintro âŸ¨Hzero_eq, Hfderiv_zero, HtaylorâŸ©\n    constructor\n    Â· exact Hzero_eq\n    Â· intro m (hm : (m : WithTop â„•âˆ) < n.succ) x (hx : x âˆˆ s)\n      cases' m with m\n      Â· exact Hfderiv_zero x hx\n      Â· have A : (m : WithTop â„•âˆ) < n := by\n          rw [Nat.cast_lt] at hm âŠ¢\n          exact Nat.lt_of_succ_lt_succ hm\n        have :\n          HasFDerivWithinAt (ğ•œ := ğ•œ) (continuousMultilinearCurryRightEquiv' ğ•œ m E F âˆ˜ (p Â· m.succ))\n            ((p x).shift m.succ).curryLeft s x := Htaylor.fderivWithin _ A x hx\n        rw [LinearIsometryEquiv.comp_hasFDerivWithinAt_iff'\n            (f' := ((p x).shift m.succ).curryLeft)] at this\n        convert this\n        ext y v\n        change\n          (p x (Nat.succ (Nat.succ m))) (cons y v) =\n            (p x m.succ.succ) (snoc (cons y (init v)) (v (last _)))\n        rw [â† cons_snoc_eq_snoc_cons, snoc_init_self]\n    Â· intro m (hm : (m : WithTop â„•âˆ) â‰¤ n.succ)\n      cases' m with m\n      Â· have : DifferentiableOn ğ•œ (fun x => p x 0) s := fun x hx =>\n          (Hfderiv_zero x hx).differentiableWithinAt\n        exact this.continuousOn\n      Â· refine (continuousMultilinearCurryRightEquiv' ğ•œ m E F).comp_continuousOn_iff.mp ?_\n        refine Htaylor.cont _ ?_\n        rw [Nat.cast_le] at hm âŠ¢\n        exact Nat.lt_succ_iff.mp hm\n\n"}
{"name":"hasFTaylorSeriesUpToOn_top_iff_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nN : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nhN : LE.le (â†‘Top.top) N\nâŠ¢ Iff (HasFTaylorSeriesUpToOn N f p s) (And (âˆ€ (x : E), Membership.mem s x â†’ Eq (p x 0).curry0 (f x)) (And (âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt (fun y => p y 0) (p x 1).curryLeft s x) (HasFTaylorSeriesUpToOn N (fun x => (continuousMultilinearCurryFin1 ğ•œ E F) (p x 1)) (fun x => (p x).shift) s)))","decl":"/-- `p` is a Taylor series of `f` up to `âŠ¤` if and only if `p.shift` is a Taylor series up to `âŠ¤`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem hasFTaylorSeriesUpToOn_top_iff_right (hN : âˆ â‰¤ N) :\n    HasFTaylorSeriesUpToOn N f p s â†”\n      (âˆ€ x âˆˆ s, (p x 0).curry0 = f x) âˆ§\n        (âˆ€ x âˆˆ s, HasFDerivWithinAt (fun y => p y 0) (p x 1).curryLeft s x) âˆ§\n          HasFTaylorSeriesUpToOn N (fun x => continuousMultilinearCurryFin1 ğ•œ E F (p x 1))\n            (fun x => (p x).shift) s := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©\n  Â· rw [hasFTaylorSeriesUpToOn_top_iff_add hN 1] at h\n    rw [hasFTaylorSeriesUpToOn_top_iff hN]\n    exact âŸ¨(hasFTaylorSeriesUpToOn_succ_nat_iff_right.1 (h 1)).1,\n      (hasFTaylorSeriesUpToOn_succ_nat_iff_right.1 (h 1)).2.1,\n      fun n â†¦ (hasFTaylorSeriesUpToOn_succ_nat_iff_right.1 (h n)).2.2âŸ©\n  Â· apply (hasFTaylorSeriesUpToOn_top_iff_add hN 1).2 (fun n â†¦ ?_)\n    rw [hasFTaylorSeriesUpToOn_succ_nat_iff_right]\n    exact âŸ¨h.1, h.2.1, (h.2.2).of_le (m := n) (natCast_le_of_coe_top_le_withTop hN n)âŸ©\n\n"}
{"name":"hasFTaylorSeriesUpToOn_succ_iff_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nâŠ¢ Iff (HasFTaylorSeriesUpToOn (HAdd.hAdd n 1) f p s) (And (âˆ€ (x : E), Membership.mem s x â†’ Eq (p x 0).curry0 (f x)) (And (âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt (fun y => p y 0) (p x 1).curryLeft s x) (HasFTaylorSeriesUpToOn n (fun x => (continuousMultilinearCurryFin1 ğ•œ E F) (p x 1)) (fun x => (p x).shift) s)))","decl":"/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. Version for `n : WithTop â„•âˆ`. -/\ntheorem hasFTaylorSeriesUpToOn_succ_iff_right :\n    HasFTaylorSeriesUpToOn (n + 1) f p s â†”\n      (âˆ€ x âˆˆ s, (p x 0).curry0 = f x) âˆ§\n        (âˆ€ x âˆˆ s, HasFDerivWithinAt (fun y => p y 0) (p x 1).curryLeft s x) âˆ§\n          HasFTaylorSeriesUpToOn n (fun x => continuousMultilinearCurryFin1 ğ•œ E F (p x 1))\n            (fun x => (p x).shift) s := by\n  match n with\n  | âŠ¤ => exact hasFTaylorSeriesUpToOn_top_iff_right (by simp)\n  | (âŠ¤ : â„•âˆ) => exact hasFTaylorSeriesUpToOn_top_iff_right (by simp)\n  | (n : â„•) => exact hasFTaylorSeriesUpToOn_succ_nat_iff_right\n\n"}
{"name":"iteratedFDerivWithin_zero_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nm : Fin 0 â†’ E\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ 0 f s x) m) (f x)","decl":"@[simp]\ntheorem iteratedFDerivWithin_zero_apply (m : Fin 0 â†’ E) :\n    (iteratedFDerivWithin ğ•œ 0 f s x : (Fin 0 â†’ E) â†’ F) m = f x :=\n  rfl\n\n"}
{"name":"iteratedFDerivWithin_zero_eq_comp","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ 0 f s) (Function.comp (â‡‘(continuousMultilinearCurryFin0 ğ•œ E F).symm) f)","decl":"theorem iteratedFDerivWithin_zero_eq_comp :\n    iteratedFDerivWithin ğ•œ 0 f s = (continuousMultilinearCurryFin0 ğ•œ E F).symm âˆ˜ f :=\n  rfl\n\n"}
{"name":"dist_iteratedFDerivWithin_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\ng : E â†’ F\nt : Set E\ny : E\nâŠ¢ Eq (Dist.dist (iteratedFDerivWithin ğ•œ 0 f s x) (iteratedFDerivWithin ğ•œ 0 g t y)) (Dist.dist (f x) (g y))","decl":"@[simp]\ntheorem dist_iteratedFDerivWithin_zero (f : E â†’ F) (s : Set E) (x : E)\n    (g : E â†’ F) (t : Set E) (y : E) :\n    dist (iteratedFDerivWithin ğ•œ 0 f s x) (iteratedFDerivWithin ğ•œ 0 g t y) = dist (f x) (g y) := by\n  simp only [iteratedFDerivWithin_zero_eq_comp, comp_apply, LinearIsometryEquiv.dist_map]\n\n"}
{"name":"norm_iteratedFDerivWithin_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nâŠ¢ Eq (Norm.norm (iteratedFDerivWithin ğ•œ 0 f s x)) (Norm.norm (f x))","decl":"@[simp]\ntheorem norm_iteratedFDerivWithin_zero : â€–iteratedFDerivWithin ğ•œ 0 f s xâ€– = â€–f xâ€– := by\n  rw [iteratedFDerivWithin_zero_eq_comp, comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"iteratedFDerivWithin_succ_apply_left","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : Nat\nm : Fin (HAdd.hAdd n 1) â†’ E\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ (HAdd.hAdd n 1) f s x) m) (((fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n f s) s x) (m 0)) (Fin.tail m))","decl":"theorem iteratedFDerivWithin_succ_apply_left {n : â„•} (m : Fin (n + 1) â†’ E) :\n    (iteratedFDerivWithin ğ•œ (n + 1) f s x : (Fin (n + 1) â†’ E) â†’ F) m =\n      (fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n f s) s x : E â†’ E[Ã—n]â†’L[ğ•œ] F) (m 0) (tail m) :=\n  rfl\n\n"}
{"name":"iteratedFDerivWithin_succ_eq_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : Nat\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ (HAdd.hAdd n 1) f s) (Function.comp (â‡‘(continuousMultilinearCurryLeftEquiv ğ•œ (fun x => E) F).symm) (fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n f s) s))","decl":"/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iteratedFDerivWithin_succ_eq_comp_left {n : â„•} :\n    iteratedFDerivWithin ğ•œ (n + 1) f s =\n      (continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (n + 1) => E) F).symm âˆ˜\n        fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n f s) s :=\n  rfl\n\n"}
{"name":"fderivWithin_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nn : Nat\nâŠ¢ Eq (fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n f s) s) (Function.comp (â‡‘(continuousMultilinearCurryLeftEquiv ğ•œ (fun x => E) F)) (iteratedFDerivWithin ğ•œ (HAdd.hAdd n 1) f s))","decl":"theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : â„•} :\n    fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n f s) s =\n      (continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (n + 1) => E) F) âˆ˜\n        iteratedFDerivWithin ğ•œ (n + 1) f s :=\n  rfl\n\n"}
{"name":"norm_fderivWithin_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : Nat\nâŠ¢ Eq (Norm.norm (fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n f s) s x)) (Norm.norm (iteratedFDerivWithin ğ•œ (HAdd.hAdd n 1) f s x))","decl":"theorem norm_fderivWithin_iteratedFDerivWithin {n : â„•} :\n    â€–fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n f s) s xâ€– =\n      â€–iteratedFDerivWithin ğ•œ (n + 1) f s xâ€– := by\n  -- Porting note: added `comp_apply`.\n  rw [iteratedFDerivWithin_succ_eq_comp_left, comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"dist_iteratedFDerivWithin_one","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nx : E\nf g : E â†’ F\ny : E\nhsx : UniqueDiffWithinAt ğ•œ s x\nhyt : UniqueDiffWithinAt ğ•œ t y\nâŠ¢ Eq (Dist.dist (iteratedFDerivWithin ğ•œ 1 f s x) (iteratedFDerivWithin ğ•œ 1 g t y)) (Dist.dist (fderivWithin ğ•œ f s x) (fderivWithin ğ•œ g t y))","decl":"@[simp]\ntheorem dist_iteratedFDerivWithin_one (f g : E â†’ F) {y}\n    (hsx : UniqueDiffWithinAt ğ•œ s x) (hyt : UniqueDiffWithinAt ğ•œ t y) :\n    dist (iteratedFDerivWithin ğ•œ 1 f s x) (iteratedFDerivWithin ğ•œ 1 g t y)\n      = dist (fderivWithin ğ•œ f s x) (fderivWithin ğ•œ g t y) := by\n  simp only [iteratedFDerivWithin_succ_eq_comp_left, comp_apply,\n    LinearIsometryEquiv.dist_map, iteratedFDerivWithin_zero_eq_comp,\n    LinearIsometryEquiv.comp_fderivWithin, hsx, hyt]\n  apply (continuousMultilinearCurryFin0 ğ•œ E F).symm.toLinearIsometry.postcomp.dist_map\n\n"}
{"name":"norm_iteratedFDerivWithin_one","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nx : E\nf : E â†’ F\nh : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (Norm.norm (iteratedFDerivWithin ğ•œ 1 f s x)) (Norm.norm (fderivWithin ğ•œ f s x))","decl":"@[simp]\ntheorem norm_iteratedFDerivWithin_one (f : E â†’ F) (h : UniqueDiffWithinAt ğ•œ s x) :\n    â€–iteratedFDerivWithin ğ•œ 1 f s xâ€– = â€–fderivWithin ğ•œ f s xâ€– := by\n  simp only [â† norm_fderivWithin_iteratedFDerivWithin,\n    iteratedFDerivWithin_zero_eq_comp, LinearIsometryEquiv.comp_fderivWithin _ h]\n  apply (continuousMultilinearCurryFin0 ğ•œ E F).symm.toLinearIsometry.norm_toContinuousLinearMap_comp\n\n"}
{"name":"iteratedFDerivWithin_succ_apply_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : Nat\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nm : Fin (HAdd.hAdd n 1) â†’ E\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ (HAdd.hAdd n 1) f s x) m) (((iteratedFDerivWithin ğ•œ n (fun y => fderivWithin ğ•œ f s y) s x) (Fin.init m)) (m (Fin.last n)))","decl":"theorem iteratedFDerivWithin_succ_apply_right {n : â„•} (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s)\n    (m : Fin (n + 1) â†’ E) :\n    (iteratedFDerivWithin ğ•œ (n + 1) f s x : (Fin (n + 1) â†’ E) â†’ F) m =\n      iteratedFDerivWithin ğ•œ n (fun y => fderivWithin ğ•œ f s y) s x (init m) (m (last n)) := by\n  induction' n with n IH generalizing x\n  Â· rw [iteratedFDerivWithin_succ_eq_comp_left, iteratedFDerivWithin_zero_eq_comp,\n      iteratedFDerivWithin_zero_apply, Function.comp_apply,\n      LinearIsometryEquiv.comp_fderivWithin _ (hs x hx)]\n    rfl\n  Â· let I := (continuousMultilinearCurryRightEquiv' ğ•œ n E F).symm\n    have A : âˆ€ y âˆˆ s, iteratedFDerivWithin ğ•œ n.succ f s y =\n        (I âˆ˜ iteratedFDerivWithin ğ•œ n (fun y => fderivWithin ğ•œ f s y) s) y := fun y hy â†¦ by\n      ext m\n      rw [@IH y hy m]\n      rfl\n    calc\n      (iteratedFDerivWithin ğ•œ (n + 2) f s x : (Fin (n + 2) â†’ E) â†’ F) m =\n          (fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n.succ f s) s x : E â†’ E[Ã—n + 1]â†’L[ğ•œ] F) (m 0)\n            (tail m) :=\n        rfl\n      _ = (fderivWithin ğ•œ (I âˆ˜ iteratedFDerivWithin ğ•œ n (fderivWithin ğ•œ f s) s) s x :\n              E â†’ E[Ã—n + 1]â†’L[ğ•œ] F) (m 0) (tail m) := by\n        rw [fderivWithin_congr A (A x hx)]\n      _ = (I âˆ˜ fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n (fderivWithin ğ•œ f s) s) s x :\n              E â†’ E[Ã—n + 1]â†’L[ğ•œ] F) (m 0) (tail m) := by\n        #adaptation_note /-- https://github.com/leanprover/lean4/pull/4119\n        we need to either use\n        `set_option maxSynthPendingDepth 2 in`\n        or fill in an explicit argument as\n        ```\n        simp only [LinearIsometryEquiv.comp_fderivWithin _\n          (f := iteratedFDerivWithin ğ•œ n (fderivWithin ğ•œ f s) s) (hs x hx)]\n        ```\n        -/\n        set_option maxSynthPendingDepth 2 in\n          simp only [LinearIsometryEquiv.comp_fderivWithin _ (hs x hx)]\n        rfl\n      _ = (fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ n (fun y => fderivWithin ğ•œ f s y) s) s x :\n              E â†’ E[Ã—n]â†’L[ğ•œ] E â†’L[ğ•œ] F) (m 0) (init (tail m)) ((tail m) (last n)) := rfl\n      _ = iteratedFDerivWithin ğ•œ (Nat.succ n) (fun y => fderivWithin ğ•œ f s y) s x (init m)\n            (m (last (n + 1))) := by\n        rw [iteratedFDerivWithin_succ_apply_left, tail_init_eq_init_tail]\n        rfl\n\n"}
{"name":"iteratedFDerivWithin_succ_eq_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : Nat\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ (HAdd.hAdd n 1) f s x) (Function.comp (â‡‘(continuousMultilinearCurryRightEquiv' ğ•œ n E F).symm) (iteratedFDerivWithin ğ•œ n (fun y => fderivWithin ğ•œ f s y) s) x)","decl":"/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iteratedFDerivWithin_succ_eq_comp_right {n : â„•} (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    iteratedFDerivWithin ğ•œ (n + 1) f s x =\n      ((continuousMultilinearCurryRightEquiv' ğ•œ n E F).symm âˆ˜\n          iteratedFDerivWithin ğ•œ n (fun y => fderivWithin ğ•œ f s y) s)\n        x := by\n  ext m; rw [iteratedFDerivWithin_succ_apply_right hs hx]; rfl\n\n"}
{"name":"norm_iteratedFDerivWithin_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : Nat\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ Eq (Norm.norm (iteratedFDerivWithin ğ•œ n (fderivWithin ğ•œ f s) s x)) (Norm.norm (iteratedFDerivWithin ğ•œ (HAdd.hAdd n 1) f s x))","decl":"theorem norm_iteratedFDerivWithin_fderivWithin {n : â„•} (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    â€–iteratedFDerivWithin ğ•œ n (fderivWithin ğ•œ f s) s xâ€– =\n      â€–iteratedFDerivWithin ğ•œ (n + 1) f s xâ€– := by\n  -- Porting note: added `comp_apply`.\n  rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"iteratedFDerivWithin_one_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nh : UniqueDiffWithinAt ğ•œ s x\nm : Fin 1 â†’ E\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ 1 f s x) m) ((fderivWithin ğ•œ f s x) (m 0))","decl":"@[simp]\ntheorem iteratedFDerivWithin_one_apply (h : UniqueDiffWithinAt ğ•œ s x) (m : Fin 1 â†’ E) :\n    iteratedFDerivWithin ğ•œ 1 f s x m = fderivWithin ğ•œ f s x (m 0) := by\n  simp only [iteratedFDerivWithin_succ_apply_left, iteratedFDerivWithin_zero_eq_comp,\n    (continuousMultilinearCurryFin0 ğ•œ E F).symm.comp_fderivWithin h]\n  rfl\n\n"}
{"name":"iteratedFDerivWithin_two_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nz : E\nhs : UniqueDiffOn ğ•œ s\nhz : Membership.mem s z\nm : Fin 2 â†’ E\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ 2 f s z) m) (((fderivWithin ğ•œ (fderivWithin ğ•œ f s) s z) (m 0)) (m 1))","decl":"/-- On a set of unique differentiability, the second derivative is obtained by taking the\nderivative of the derivative. -/\nlemma iteratedFDerivWithin_two_apply (f : E â†’ F) {z : E} (hs : UniqueDiffOn ğ•œ s) (hz : z âˆˆ s)\n    (m : Fin 2 â†’ E) :\n    iteratedFDerivWithin ğ•œ 2 f s z m = fderivWithin ğ•œ (fderivWithin ğ•œ f s) s z (m 0) (m 1) := by\n  simp only [iteratedFDerivWithin_succ_apply_right hs hz]\n  rfl\n\n"}
{"name":"iteratedFDerivWithin_two_apply'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nz : E\nhs : UniqueDiffOn ğ•œ s\nhz : Membership.mem s z\nv w : E\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ 2 f s z) (Matrix.vecCons v (Matrix.vecCons w Matrix.vecEmpty))) (((fderivWithin ğ•œ (fderivWithin ğ•œ f s) s z) v) w)","decl":"/-- On a set of unique differentiability, the second derivative is obtained by taking the\nderivative of the derivative. -/\nlemma iteratedFDerivWithin_two_apply' (f : E â†’ F) {z : E} (hs : UniqueDiffOn ğ•œ s) (hz : z âˆˆ s)\n    (v w : E) :\n    iteratedFDerivWithin ğ•œ 2 f s z ![v, w] = fderivWithin ğ•œ (fderivWithin ğ•œ f s) s z v w :=\n  iteratedFDerivWithin_two_apply f hs hz _\n\n"}
{"name":"Filter.EventuallyEq.iteratedFDerivWithin'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf fâ‚ : E â†’ F\nx : E\nh : (nhdsWithin x s).EventuallyEq fâ‚ f\nht : HasSubset.Subset t s\nn : Nat\nâŠ¢ (nhdsWithin x s).EventuallyEq (iteratedFDerivWithin ğ•œ n fâ‚ t) (iteratedFDerivWithin ğ•œ n f t)","decl":"theorem Filter.EventuallyEq.iteratedFDerivWithin' (h : fâ‚ =á¶ [ğ“[s] x] f) (ht : t âŠ† s) (n : â„•) :\n    iteratedFDerivWithin ğ•œ n fâ‚ t =á¶ [ğ“[s] x] iteratedFDerivWithin ğ•œ n f t := by\n  induction n with\n  | zero => exact h.mono fun y hy => DFunLike.ext _ _ fun _ => hy\n  | succ n ihn =>\n    have : fderivWithin ğ•œ _ t =á¶ [ğ“[s] x] fderivWithin ğ•œ _ t := ihn.fderivWithin' ht\n    refine this.mono fun y hy => ?_\n    simp only [iteratedFDerivWithin_succ_eq_comp_left, hy, (Â· âˆ˜ Â·)]\n\n"}
{"name":"Filter.EventuallyEq.iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nh : (nhdsWithin x s).EventuallyEq fâ‚ f\nn : Nat\nâŠ¢ (nhdsWithin x s).EventuallyEq (iteratedFDerivWithin ğ•œ n fâ‚ s) (iteratedFDerivWithin ğ•œ n f s)","decl":"protected theorem Filter.EventuallyEq.iteratedFDerivWithin (h : fâ‚ =á¶ [ğ“[s] x] f) (n : â„•) :\n    iteratedFDerivWithin ğ•œ n fâ‚ s =á¶ [ğ“[s] x] iteratedFDerivWithin ğ•œ n f s :=\n  h.iteratedFDerivWithin' Subset.rfl n\n\n"}
{"name":"Filter.EventuallyEq.iteratedFDerivWithin_eq","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nh : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Eq (fâ‚ x) (f x)\nn : Nat\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n fâ‚ s x) (iteratedFDerivWithin ğ•œ n f s x)","decl":"/-- If two functions coincide in a neighborhood of `x` within a set `s` and at `x`, then their\niterated differentials within this set at `x` coincide. -/\ntheorem Filter.EventuallyEq.iteratedFDerivWithin_eq (h : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x)\n    (n : â„•) : iteratedFDerivWithin ğ•œ n fâ‚ s x = iteratedFDerivWithin ğ•œ n f s x :=\n  have : fâ‚ =á¶ [ğ“[insert x s] x] f := by simpa [EventuallyEq, hx]\n  (this.iteratedFDerivWithin' (subset_insert _ _) n).self_of_nhdsWithin (mem_insert _ _)\n\n"}
{"name":"iteratedFDerivWithin_congr","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nhs : Set.EqOn fâ‚ f s\nhx : Membership.mem s x\nn : Nat\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n fâ‚ s x) (iteratedFDerivWithin ğ•œ n f s x)","decl":"/-- If two functions coincide on a set `s`, then their iterated differentials within this set\ncoincide. See also `Filter.EventuallyEq.iteratedFDerivWithin_eq` and\n`Filter.EventuallyEq.iteratedFDerivWithin`. -/\ntheorem iteratedFDerivWithin_congr (hs : EqOn fâ‚ f s) (hx : x âˆˆ s) (n : â„•) :\n    iteratedFDerivWithin ğ•œ n fâ‚ s x = iteratedFDerivWithin ğ•œ n f s x :=\n  (hs.eventuallyEq.filter_mono inf_le_right).iteratedFDerivWithin_eq (hs hx) _\n\n"}
{"name":"Set.EqOn.iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nhs : Set.EqOn fâ‚ f s\nn : Nat\nâŠ¢ Set.EqOn (iteratedFDerivWithin ğ•œ n fâ‚ s) (iteratedFDerivWithin ğ•œ n f s) s","decl":"/-- If two functions coincide on a set `s`, then their iterated differentials within this set\ncoincide. See also `Filter.EventuallyEq.iteratedFDerivWithin_eq` and\n`Filter.EventuallyEq.iteratedFDerivWithin`. -/\nprotected theorem Set.EqOn.iteratedFDerivWithin (hs : EqOn fâ‚ f s) (n : â„•) :\n    EqOn (iteratedFDerivWithin ğ•œ n fâ‚ s) (iteratedFDerivWithin ğ•œ n f s) s := fun _x hx =>\n  iteratedFDerivWithin_congr hs hx n\n\n"}
{"name":"iteratedFDerivWithin_eventually_congr_set'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx y : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\nn : Nat\nâŠ¢ (nhds x).EventuallyEq (iteratedFDerivWithin ğ•œ n f s) (iteratedFDerivWithin ğ•œ n f t)","decl":"theorem iteratedFDerivWithin_eventually_congr_set' (y : E) (h : s =á¶ [ğ“[{y}á¶œ] x] t) (n : â„•) :\n    iteratedFDerivWithin ğ•œ n f s =á¶ [ğ“ x] iteratedFDerivWithin ğ•œ n f t := by\n  induction n generalizing x with\n  | zero => rfl\n  | succ n ihn =>\n    refine (eventually_nhds_nhdsWithin.2 h).mono fun y hy => ?_\n    simp only [iteratedFDerivWithin_succ_eq_comp_left, (Â· âˆ˜ Â·)]\n    rw [(ihn hy).fderivWithin_eq_nhds, fderivWithin_congr_set' _ hy]\n\n"}
{"name":"iteratedFDerivWithin_eventually_congr_set","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nh : (nhds x).EventuallyEq s t\nn : Nat\nâŠ¢ (nhds x).EventuallyEq (iteratedFDerivWithin ğ•œ n f s) (iteratedFDerivWithin ğ•œ n f t)","decl":"theorem iteratedFDerivWithin_eventually_congr_set (h : s =á¶ [ğ“ x] t) (n : â„•) :\n    iteratedFDerivWithin ğ•œ n f s =á¶ [ğ“ x] iteratedFDerivWithin ğ•œ n f t :=\n  iteratedFDerivWithin_eventually_congr_set' x (h.filter_mono inf_le_left) n\n\n"}
{"name":"iteratedFDerivWithin_congr_set'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx y : E\nh : (nhdsWithin x (HasCompl.compl (Singleton.singleton y))).EventuallyEq s t\nn : Nat\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f s x) (iteratedFDerivWithin ğ•œ n f t x)","decl":"/-- If two sets coincide in a punctured neighborhood of `x`,\nthen the corresponding iterated derivatives are equal.\n\nNote that we also allow to puncture the neighborhood of `x` at `y`.\nIf `y â‰  x`, then this is a no-op. -/\ntheorem iteratedFDerivWithin_congr_set' {y} (h : s =á¶ [ğ“[{y}á¶œ] x] t) (n : â„•) :\n    iteratedFDerivWithin ğ•œ n f s x = iteratedFDerivWithin ğ•œ n f t x :=\n  (iteratedFDerivWithin_eventually_congr_set' y h n).self_of_nhds\n\n"}
{"name":"iteratedFDerivWithin_insert","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : Nat\ny : E\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f (Insert.insert x s) y) (iteratedFDerivWithin ğ•œ n f s y)","decl":"@[simp]\ntheorem iteratedFDerivWithin_insert {n y} :\n    iteratedFDerivWithin ğ•œ n f (insert x s) y = iteratedFDerivWithin ğ•œ n f s y :=\n  iteratedFDerivWithin_congr_set' (y := x)\n    (eventually_mem_nhdsWithin.mono <| by intros; simp_all).set_eq _\n\n"}
{"name":"iteratedFDerivWithin_congr_set","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nh : (nhds x).EventuallyEq s t\nn : Nat\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f s x) (iteratedFDerivWithin ğ•œ n f t x)","decl":"theorem iteratedFDerivWithin_congr_set (h : s =á¶ [ğ“ x] t) (n : â„•) :\n    iteratedFDerivWithin ğ•œ n f s x = iteratedFDerivWithin ğ•œ n f t x :=\n  (iteratedFDerivWithin_eventually_congr_set h n).self_of_nhds\n\n"}
{"name":"ftaylorSeriesWithin_insert","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nâŠ¢ Eq (ftaylorSeriesWithin ğ•œ f (Insert.insert x s)) (ftaylorSeriesWithin ğ•œ f s)","decl":"@[simp]\ntheorem ftaylorSeriesWithin_insert :\n    ftaylorSeriesWithin ğ•œ f (insert x s) = ftaylorSeriesWithin ğ•œ f s := by\n  ext y n : 2\n  apply iteratedFDerivWithin_insert\n\n"}
{"name":"iteratedFDerivWithin_inter'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns u : Set E\nf : E â†’ F\nx : E\nn : Nat\nhu : Membership.mem (nhdsWithin x s) u\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f (Inter.inter s u) x) (iteratedFDerivWithin ğ•œ n f s x)","decl":"/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x` within `s`. -/\ntheorem iteratedFDerivWithin_inter' {n : â„•} (hu : u âˆˆ ğ“[s] x) :\n    iteratedFDerivWithin ğ•œ n f (s âˆ© u) x = iteratedFDerivWithin ğ•œ n f s x :=\n  iteratedFDerivWithin_congr_set (nhdsWithin_eq_iff_eventuallyEq.1 <| nhdsWithin_inter_of_mem' hu) _\n\n"}
{"name":"iteratedFDerivWithin_inter","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns u : Set E\nf : E â†’ F\nx : E\nn : Nat\nhu : Membership.mem (nhds x) u\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f (Inter.inter s u) x) (iteratedFDerivWithin ğ•œ n f s x)","decl":"/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with a neighborhood of `x`. -/\ntheorem iteratedFDerivWithin_inter {n : â„•} (hu : u âˆˆ ğ“ x) :\n    iteratedFDerivWithin ğ•œ n f (s âˆ© u) x = iteratedFDerivWithin ğ•œ n f s x :=\n  iteratedFDerivWithin_inter' (mem_nhdsWithin_of_mem_nhds hu)\n\n"}
{"name":"iteratedFDerivWithin_inter_open","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns u : Set E\nf : E â†’ F\nx : E\nn : Nat\nhu : IsOpen u\nhx : Membership.mem u x\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f (Inter.inter s u) x) (iteratedFDerivWithin ğ•œ n f s x)","decl":"/-- The iterated differential within a set `s` at a point `x` is not modified if one intersects\n`s` with an open set containing `x`. -/\ntheorem iteratedFDerivWithin_inter_open {n : â„•} (hu : IsOpen u) (hx : x âˆˆ u) :\n    iteratedFDerivWithin ğ•œ n f (s âˆ© u) x = iteratedFDerivWithin ğ•œ n f s x :=\n  iteratedFDerivWithin_inter (hu.mem_nhds hx)\n\n"}
{"name":"HasFTaylorSeriesUpToOn.eq_iteratedFDerivWithin_of_uniqueDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpToOn n f p s\nm : Nat\nhmn : LE.le (â†‘m) n\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ Eq (p x m) (iteratedFDerivWithin ğ•œ m f s x)","decl":"/-- On a set with unique differentiability, any choice of iterated differential has to coincide\nwith the one we have chosen in `iteratedFDerivWithin ğ•œ m f s`. -/\ntheorem HasFTaylorSeriesUpToOn.eq_iteratedFDerivWithin_of_uniqueDiffOn\n    (h : HasFTaylorSeriesUpToOn n f p s) {m : â„•} (hmn : m â‰¤ n) (hs : UniqueDiffOn ğ•œ s)\n    (hx : x âˆˆ s) : p x m = iteratedFDerivWithin ğ•œ m f s x := by\n  induction' m with m IH generalizing x\n  Â· rw [h.zero_eq' hx, iteratedFDerivWithin_zero_eq_comp]; rfl\n  Â· have A : m < n := lt_of_lt_of_le (mod_cast lt_add_one m) hmn\n    have :\n      HasFDerivWithinAt (fun y : E => iteratedFDerivWithin ğ•œ m f s y)\n        (ContinuousMultilinearMap.curryLeft (p x (Nat.succ m))) s x :=\n      (h.fderivWithin m A x hx).congr (fun y hy => (IH (le_of_lt A) hy).symm)\n        (IH (le_of_lt A) hx).symm\n    rw [iteratedFDerivWithin_succ_eq_comp_left, Function.comp_apply, this.fderivWithin (hs x hx)]\n    exact (ContinuousMultilinearMap.uncurry_curryLeft _).symm\n\n"}
{"name":"iteratedFDerivWithin_comp_add_left'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : Nat\na : E\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n (fun z => f (HAdd.hAdd a z)) s) fun x => iteratedFDerivWithin ğ•œ n f (HVAdd.hVAdd a s) (HAdd.hAdd a x)","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedFDerivWithin_comp_add_left' (n : â„•) (a : E) :\n    iteratedFDerivWithin ğ•œ n (fun z â†¦ f (a + z)) s =\n      fun x â†¦ iteratedFDerivWithin ğ•œ n f (a +áµ¥ s) (a + x) := by\n  induction n with\n  | zero => simp [iteratedFDerivWithin]\n  | succ n IH =>\n    ext v\n    rw [iteratedFDerivWithin_succ_eq_comp_left, iteratedFDerivWithin_succ_eq_comp_left]\n    simp only [Nat.succ_eq_add_one, IH, comp_apply, continuousMultilinearCurryLeftEquiv_symm_apply]\n    congr 2\n    rw [fderivWithin_comp_add_left]\n\n"}
{"name":"iteratedFDerivWithin_comp_add_left","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : Nat\na x : E\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n (fun z => f (HAdd.hAdd a z)) s x) (iteratedFDerivWithin ğ•œ n f (HVAdd.hVAdd a s) (HAdd.hAdd a x))","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedFDerivWithin_comp_add_left (n : â„•) (a : E) (x : E) :\n    iteratedFDerivWithin ğ•œ n (fun z â†¦ f (a + z)) s x =\n      iteratedFDerivWithin ğ•œ n f (a +áµ¥ s) (a + x) := by\n  simp [iteratedFDerivWithin_comp_add_left']\n\n"}
{"name":"iteratedFDerivWithin_comp_add_right'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : Nat\na : E\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n (fun z => f (HAdd.hAdd z a)) s) fun x => iteratedFDerivWithin ğ•œ n f (HVAdd.hVAdd a s) (HAdd.hAdd x a)","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedFDerivWithin_comp_add_right' (n : â„•) (a : E) :\n    iteratedFDerivWithin ğ•œ n (fun z â†¦ f (z + a)) s =\n      fun x â†¦ iteratedFDerivWithin ğ•œ n f (a +áµ¥ s) (x + a) := by\n  simpa [add_comm a] using iteratedFDerivWithin_comp_add_left' n a\n\n"}
{"name":"iteratedFDerivWithin_comp_add_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : Nat\na x : E\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n (fun z => f (HAdd.hAdd z a)) s x) (iteratedFDerivWithin ğ•œ n f (HVAdd.hVAdd a s) (HAdd.hAdd x a))","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedFDerivWithin_comp_add_right (n : â„•) (a : E) (x : E) :\n    iteratedFDerivWithin ğ•œ n (fun z â†¦ f (z + a)) s x =\n      iteratedFDerivWithin ğ•œ n f (a +áµ¥ s) (x + a) := by\n  simp [iteratedFDerivWithin_comp_add_right']\n\n"}
{"name":"iteratedFDerivWithin_comp_sub'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : Nat\na : E\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n (fun z => f (HSub.hSub z a)) s) fun x => iteratedFDerivWithin ğ•œ n f (HVAdd.hVAdd (Neg.neg a) s) (HSub.hSub x a)","decl":"/-- The iterated derivative commutes with subtracting a constant. -/\nlemma iteratedFDerivWithin_comp_sub' (n : â„•) (a : E) :\n    iteratedFDerivWithin ğ•œ n (fun z â†¦ f (z - a)) s =\n      fun x â†¦ iteratedFDerivWithin ğ•œ n f (-a +áµ¥ s) (x - a) := by\n  simpa [sub_eq_add_neg] using iteratedFDerivWithin_comp_add_right' n (-a)\n\n"}
{"name":"iteratedFDerivWithin_comp_sub","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : Nat\na : E\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n (fun z => f (HSub.hSub z a)) s x) (iteratedFDerivWithin ğ•œ n f (HVAdd.hVAdd (Neg.neg a) s) (HSub.hSub x a))","decl":"/-- The iterated derivative commutes with subtracting a constant. -/\nlemma iteratedFDerivWithin_comp_sub (n : â„•) (a : E) :\n    iteratedFDerivWithin ğ•œ n (fun z â†¦ f (z - a)) s x =\n      iteratedFDerivWithin ğ•œ n f (-a +áµ¥ s) (x - a) := by\n  simp [iteratedFDerivWithin_comp_sub']\n\n"}
{"name":"HasFTaylorSeriesUpTo.cont","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nself : HasFTaylorSeriesUpTo n f p\nm : Nat\naâœ : LE.le (â†‘m) n\nâŠ¢ Continuous fun x => p x m","decl":"/-- `HasFTaylorSeriesUpTo n f p` registers the fact that `p 0 = f` and `p (m+1)` is a\nderivative of `p m` for `m < n`, and is continuous for `m â‰¤ n`. This is a predicate analogous to\n`HasFDerivAt` but for higher order derivatives.\n\nNotice that `p` does not sum up to `f` on the diagonal (`FormalMultilinearSeries.sum`), even if\n`f` is analytic and `n = âˆ`: an addition `1/m!` factor on the `m`th term is necessary for that. -/\nstructure HasFTaylorSeriesUpTo\n  (n : WithTop â„•âˆ) (f : E â†’ F) (p : E â†’ FormalMultilinearSeries ğ•œ E F) : Prop where\n  zero_eq : âˆ€ x, (p x 0).curry0 = f x\n  fderiv : âˆ€ m : â„•, m < n â†’ âˆ€ x, HasFDerivAt (fun y => p y m) (p x m.succ).curryLeft x\n  cont : âˆ€ m : â„•, m â‰¤ n â†’ Continuous fun x => p x m\n\n"}
{"name":"HasFTaylorSeriesUpTo.zero_eq","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nself : HasFTaylorSeriesUpTo n f p\nx : E\nâŠ¢ Eq (p x 0).curry0 (f x)","decl":"/-- `HasFTaylorSeriesUpTo n f p` registers the fact that `p 0 = f` and `p (m+1)` is a\nderivative of `p m` for `m < n`, and is continuous for `m â‰¤ n`. This is a predicate analogous to\n`HasFDerivAt` but for higher order derivatives.\n\nNotice that `p` does not sum up to `f` on the diagonal (`FormalMultilinearSeries.sum`), even if\n`f` is analytic and `n = âˆ`: an addition `1/m!` factor on the `m`th term is necessary for that. -/\nstructure HasFTaylorSeriesUpTo\n  (n : WithTop â„•âˆ) (f : E â†’ F) (p : E â†’ FormalMultilinearSeries ğ•œ E F) : Prop where\n  zero_eq : âˆ€ x, (p x 0).curry0 = f x\n  fderiv : âˆ€ m : â„•, m < n â†’ âˆ€ x, HasFDerivAt (fun y => p y m) (p x m.succ).curryLeft x\n  cont : âˆ€ m : â„•, m â‰¤ n â†’ Continuous fun x => p x m\n\n"}
{"name":"HasFTaylorSeriesUpTo.fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nself : HasFTaylorSeriesUpTo n f p\nm : Nat\naâœ : LT.lt (â†‘m) n\nx : E\nâŠ¢ HasFDerivAt (fun y => p y m) (p x m.succ).curryLeft x","decl":"/-- `HasFTaylorSeriesUpTo n f p` registers the fact that `p 0 = f` and `p (m+1)` is a\nderivative of `p m` for `m < n`, and is continuous for `m â‰¤ n`. This is a predicate analogous to\n`HasFDerivAt` but for higher order derivatives.\n\nNotice that `p` does not sum up to `f` on the diagonal (`FormalMultilinearSeries.sum`), even if\n`f` is analytic and `n = âˆ`: an addition `1/m!` factor on the `m`th term is necessary for that. -/\nstructure HasFTaylorSeriesUpTo\n  (n : WithTop â„•âˆ) (f : E â†’ F) (p : E â†’ FormalMultilinearSeries ğ•œ E F) : Prop where\n  zero_eq : âˆ€ x, (p x 0).curry0 = f x\n  fderiv : âˆ€ m : â„•, m < n â†’ âˆ€ x, HasFDerivAt (fun y => p y m) (p x m.succ).curryLeft x\n  cont : âˆ€ m : â„•, m â‰¤ n â†’ Continuous fun x => p x m\n\n"}
{"name":"HasFTaylorSeriesUpTo.zero_eq'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpTo n f p\nx : E\nâŠ¢ Eq (p x 0) ((continuousMultilinearCurryFin0 ğ•œ E F).symm (f x))","decl":"theorem HasFTaylorSeriesUpTo.zero_eq' (h : HasFTaylorSeriesUpTo n f p) (x : E) :\n    p x 0 = (continuousMultilinearCurryFin0 ğ•œ E F).symm (f x) := by\n  rw [â† h.zero_eq x]\n  exact (p x 0).uncurry0_curry0.symm\n\n"}
{"name":"hasFTaylorSeriesUpToOn_univ_iff","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nâŠ¢ Iff (HasFTaylorSeriesUpToOn n f p Set.univ) (HasFTaylorSeriesUpTo n f p)","decl":"theorem hasFTaylorSeriesUpToOn_univ_iff :\n    HasFTaylorSeriesUpToOn n f p univ â†” HasFTaylorSeriesUpTo n f p := by\n  constructor\n  Â· intro H\n    constructor\n    Â· exact fun x => H.zero_eq x (mem_univ x)\n    Â· intro m hm x\n      rw [â† hasFDerivWithinAt_univ]\n      exact H.fderivWithin m hm x (mem_univ x)\n    Â· intro m hm\n      rw [continuous_iff_continuousOn_univ]\n      exact H.cont m hm\n  Â· intro H\n    constructor\n    Â· exact fun x _ => H.zero_eq x\n    Â· intro m hm x _\n      rw [hasFDerivWithinAt_univ]\n      exact H.fderiv m hm x\n    Â· intro m hm\n      rw [â† continuous_iff_continuousOn_univ]\n      exact H.cont m hm\n\n"}
{"name":"HasFTaylorSeriesUpTo.hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpTo n f p\ns : Set E\nâŠ¢ HasFTaylorSeriesUpToOn n f p s","decl":"theorem HasFTaylorSeriesUpTo.hasFTaylorSeriesUpToOn (h : HasFTaylorSeriesUpTo n f p) (s : Set E) :\n    HasFTaylorSeriesUpToOn n f p s :=\n  (hasFTaylorSeriesUpToOn_univ_iff.2 h).mono (subset_univ _)\n\n"}
{"name":"HasFTaylorSeriesUpTo.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nm n : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpTo n f p\nhmn : LE.le m n\nâŠ¢ HasFTaylorSeriesUpTo m f p","decl":"theorem HasFTaylorSeriesUpTo.of_le (h : HasFTaylorSeriesUpTo n f p) (hmn : m â‰¤ n) :\n    HasFTaylorSeriesUpTo m f p := by\n  rw [â† hasFTaylorSeriesUpToOn_univ_iff] at h âŠ¢; exact h.of_le hmn\n\n"}
{"name":"HasFTaylorSeriesUpTo.ofLe","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nm n : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpTo n f p\nhmn : LE.le m n\nâŠ¢ HasFTaylorSeriesUpTo m f p","decl":"@[deprecated (since := \"2024-11-07\")]\nalias HasFTaylorSeriesUpTo.ofLe := HasFTaylorSeriesUpTo.of_le\n\n"}
{"name":"HasFTaylorSeriesUpTo.continuous","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpTo n f p\nâŠ¢ Continuous f","decl":"theorem HasFTaylorSeriesUpTo.continuous (h : HasFTaylorSeriesUpTo n f p) : Continuous f := by\n  rw [â† hasFTaylorSeriesUpToOn_univ_iff] at h\n  rw [continuous_iff_continuousOn_univ]\n  exact h.continuousOn\n\n"}
{"name":"hasFTaylorSeriesUpTo_zero_iff","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nâŠ¢ Iff (HasFTaylorSeriesUpTo 0 f p) (And (Continuous f) (âˆ€ (x : E), Eq (p x 0).curry0 (f x)))","decl":"theorem hasFTaylorSeriesUpTo_zero_iff :\n    HasFTaylorSeriesUpTo 0 f p â†” Continuous f âˆ§ âˆ€ x, (p x 0).curry0 = f x := by\n  simp [hasFTaylorSeriesUpToOn_univ_iff.symm, continuous_iff_continuousOn_univ,\n    hasFTaylorSeriesUpToOn_zero_iff]\n\n"}
{"name":"hasFTaylorSeriesUpTo_top_iff","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nN : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nhN : LE.le (â†‘Top.top) N\nâŠ¢ Iff (HasFTaylorSeriesUpTo N f p) (âˆ€ (n : Nat), HasFTaylorSeriesUpTo (â†‘n) f p)","decl":"theorem hasFTaylorSeriesUpTo_top_iff (hN : âˆ â‰¤ N) :\n    HasFTaylorSeriesUpTo N f p â†” âˆ€ n : â„•, HasFTaylorSeriesUpTo n f p := by\n  simp only [â† hasFTaylorSeriesUpToOn_univ_iff, hasFTaylorSeriesUpToOn_top_iff hN]\n\n"}
{"name":"hasFTaylorSeriesUpTo_top_iff'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nN : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nhN : LE.le (â†‘Top.top) N\nâŠ¢ Iff (HasFTaylorSeriesUpTo N f p) (And (âˆ€ (x : E), Eq (p x 0).curry0 (f x)) (âˆ€ (m : Nat) (x : E), HasFDerivAt (fun y => p y m) (p x m.succ).curryLeft x))","decl":"/-- In the case that `n = âˆ` we don't need the continuity assumption in\n`HasFTaylorSeriesUpTo`. -/\ntheorem hasFTaylorSeriesUpTo_top_iff' (hN : âˆ â‰¤ N) :\n    HasFTaylorSeriesUpTo N f p â†”\n      (âˆ€ x, (p x 0).curry0 = f x) âˆ§\n        âˆ€ (m : â„•) (x), HasFDerivAt (fun y => p y m) (p x m.succ).curryLeft x := by\n  simp only [â† hasFTaylorSeriesUpToOn_univ_iff, hasFTaylorSeriesUpToOn_top_iff' hN, mem_univ,\n    forall_true_left, hasFDerivWithinAt_univ]\n\n"}
{"name":"HasFTaylorSeriesUpTo.hasFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpTo n f p\nhn : LE.le 1 n\nx : E\nâŠ¢ HasFDerivAt f ((continuousMultilinearCurryFin1 ğ•œ E F) (p x 1)) x","decl":"/-- If a function has a Taylor series at order at least `1`, then the term of order `1` of this\nseries is a derivative of `f`. -/\ntheorem HasFTaylorSeriesUpTo.hasFDerivAt (h : HasFTaylorSeriesUpTo n f p) (hn : 1 â‰¤ n) (x : E) :\n    HasFDerivAt f (continuousMultilinearCurryFin1 ğ•œ E F (p x 1)) x := by\n  rw [â† hasFDerivWithinAt_univ]\n  exact (hasFTaylorSeriesUpToOn_univ_iff.2 h).hasFDerivWithinAt hn (mem_univ _)\n\n"}
{"name":"HasFTaylorSeriesUpTo.differentiable","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpTo n f p\nhn : LE.le 1 n\nâŠ¢ Differentiable ğ•œ f","decl":"theorem HasFTaylorSeriesUpTo.differentiable (h : HasFTaylorSeriesUpTo n f p) (hn : 1 â‰¤ n) :\n    Differentiable ğ•œ f := fun x => (h.hasFDerivAt hn x).differentiableAt\n\n"}
{"name":"hasFTaylorSeriesUpTo_succ_nat_iff_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nn : Nat\nâŠ¢ Iff (HasFTaylorSeriesUpTo (â†‘(HAdd.hAdd n 1)) f p) (And (âˆ€ (x : E), Eq (p x 0).curry0 (f x)) (And (âˆ€ (x : E), HasFDerivAt (fun y => p y 0) (p x 1).curryLeft x) (HasFTaylorSeriesUpTo (â†‘n) (fun x => (continuousMultilinearCurryFin1 ğ•œ E F) (p x 1)) fun x => (p x).shift)))","decl":"/-- `p` is a Taylor series of `f` up to `n+1` if and only if `p.shift` is a Taylor series up to `n`\nfor `p 1`, which is a derivative of `f`. -/\ntheorem hasFTaylorSeriesUpTo_succ_nat_iff_right {n : â„•} :\n    HasFTaylorSeriesUpTo (n + 1 : â„•) f p â†”\n      (âˆ€ x, (p x 0).curry0 = f x) âˆ§\n        (âˆ€ x, HasFDerivAt (fun y => p y 0) (p x 1).curryLeft x) âˆ§\n          HasFTaylorSeriesUpTo n (fun x => continuousMultilinearCurryFin1 ğ•œ E F (p x 1)) fun x =>\n            (p x).shift := by\n  simp only [hasFTaylorSeriesUpToOn_succ_nat_iff_right, â† hasFTaylorSeriesUpToOn_univ_iff, mem_univ,\n    forall_true_left, hasFDerivWithinAt_univ]\n\n"}
{"name":"hasFTaylorSeriesUpTo_succ_iff_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nn : Nat\nâŠ¢ Iff (HasFTaylorSeriesUpTo (â†‘(HAdd.hAdd n 1)) f p) (And (âˆ€ (x : E), Eq (p x 0).curry0 (f x)) (And (âˆ€ (x : E), HasFDerivAt (fun y => p y 0) (p x 1).curryLeft x) (HasFTaylorSeriesUpTo (â†‘n) (fun x => (continuousMultilinearCurryFin1 ğ•œ E F) (p x 1)) fun x => (p x).shift)))","decl":"@[deprecated (since := \"2024-11-07\")]\nalias hasFTaylorSeriesUpTo_succ_iff_right := hasFTaylorSeriesUpTo_succ_nat_iff_right\n\n"}
{"name":"iteratedFDeriv_zero_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nm : Fin 0 â†’ E\nâŠ¢ Eq ((iteratedFDeriv ğ•œ 0 f x) m) (f x)","decl":"@[simp]\ntheorem iteratedFDeriv_zero_apply (m : Fin 0 â†’ E) :\n    (iteratedFDeriv ğ•œ 0 f x : (Fin 0 â†’ E) â†’ F) m = f x :=\n  rfl\n\n"}
{"name":"iteratedFDeriv_zero_eq_comp","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Eq (iteratedFDeriv ğ•œ 0 f) (Function.comp (â‡‘(continuousMultilinearCurryFin0 ğ•œ E F).symm) f)","decl":"theorem iteratedFDeriv_zero_eq_comp :\n    iteratedFDeriv ğ•œ 0 f = (continuousMultilinearCurryFin0 ğ•œ E F).symm âˆ˜ f :=\n  rfl\n\n"}
{"name":"norm_iteratedFDeriv_zero","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ Eq (Norm.norm (iteratedFDeriv ğ•œ 0 f x)) (Norm.norm (f x))","decl":"@[simp]\ntheorem norm_iteratedFDeriv_zero : â€–iteratedFDeriv ğ•œ 0 f xâ€– = â€–f xâ€– := by\n  -- Porting note: added `comp_apply`.\n  rw [iteratedFDeriv_zero_eq_comp, comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"iteratedFDerivWithin_zero_eq","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ 0 f s) (iteratedFDeriv ğ•œ 0 f)","decl":"theorem iteratedFDerivWithin_zero_eq : iteratedFDerivWithin ğ•œ 0 f s = iteratedFDeriv ğ•œ 0 f := rfl\n\n"}
{"name":"iteratedFDeriv_succ_apply_left","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : Nat\nm : Fin (HAdd.hAdd n 1) â†’ E\nâŠ¢ Eq ((iteratedFDeriv ğ•œ (HAdd.hAdd n 1) f x) m) (((fderiv ğ•œ (iteratedFDeriv ğ•œ n f) x) (m 0)) (Fin.tail m))","decl":"theorem iteratedFDeriv_succ_apply_left {n : â„•} (m : Fin (n + 1) â†’ E) :\n    (iteratedFDeriv ğ•œ (n + 1) f x : (Fin (n + 1) â†’ E) â†’ F) m =\n      (fderiv ğ•œ (iteratedFDeriv ğ•œ n f) x : E â†’ E[Ã—n]â†’L[ğ•œ] F) (m 0) (tail m) :=\n  rfl\n\n"}
{"name":"iteratedFDeriv_succ_eq_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\nâŠ¢ Eq (iteratedFDeriv ğ•œ (HAdd.hAdd n 1) f) (Function.comp (â‡‘(continuousMultilinearCurryLeftEquiv ğ•œ (fun x => E) F).symm) (fderiv ğ•œ (iteratedFDeriv ğ•œ n f)))","decl":"/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the derivative of the `n`-th derivative. -/\ntheorem iteratedFDeriv_succ_eq_comp_left {n : â„•} :\n    iteratedFDeriv ğ•œ (n + 1) f =\n      (continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (n + 1) => E) F).symm âˆ˜\n        fderiv ğ•œ (iteratedFDeriv ğ•œ n f) :=\n  rfl\n\n"}
{"name":"fderiv_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\nâŠ¢ Eq (fderiv ğ•œ (iteratedFDeriv ğ•œ n f)) (Function.comp (â‡‘(continuousMultilinearCurryLeftEquiv ğ•œ (fun x => E) F)) (iteratedFDeriv ğ•œ (HAdd.hAdd n 1) f))","decl":"/-- Writing explicitly the derivative of the `n`-th derivative as the composition of a currying\nlinear equiv, and the `n + 1`-th derivative. -/\ntheorem fderiv_iteratedFDeriv {n : â„•} :\n    fderiv ğ•œ (iteratedFDeriv ğ•œ n f) =\n      continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (n + 1) => E) F âˆ˜\n        iteratedFDeriv ğ•œ (n + 1) f :=\n  rfl\n\n"}
{"name":"tsupport_iteratedFDeriv_subset","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\nâŠ¢ HasSubset.Subset (tsupport (iteratedFDeriv ğ•œ n f)) (tsupport f)","decl":"theorem tsupport_iteratedFDeriv_subset (n : â„•) : tsupport (iteratedFDeriv ğ•œ n f) âŠ† tsupport f := by\n  induction n with\n  | zero =>\n    rw [iteratedFDeriv_zero_eq_comp]\n    exact closure_minimal ((support_comp_subset (LinearIsometryEquiv.map_zero _) _).trans\n      subset_closure) isClosed_closure\n  | succ n IH =>\n    rw [iteratedFDeriv_succ_eq_comp_left]\n    exact closure_minimal ((support_comp_subset (LinearIsometryEquiv.map_zero _) _).trans\n      ((support_fderiv_subset ğ•œ).trans IH)) isClosed_closure\n\n"}
{"name":"support_iteratedFDeriv_subset","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\nâŠ¢ HasSubset.Subset (Function.support (iteratedFDeriv ğ•œ n f)) (tsupport f)","decl":"theorem support_iteratedFDeriv_subset (n : â„•) : support (iteratedFDeriv ğ•œ n f) âŠ† tsupport f :=\n  subset_closure.trans (tsupport_iteratedFDeriv_subset n)\n\n"}
{"name":"HasCompactSupport.iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nhf : HasCompactSupport f\nn : Nat\nâŠ¢ HasCompactSupport (iteratedFDeriv ğ•œ n f)","decl":"theorem HasCompactSupport.iteratedFDeriv (hf : HasCompactSupport f) (n : â„•) :\n    HasCompactSupport (iteratedFDeriv ğ•œ n f) :=\n  hf.of_isClosed_subset isClosed_closure (tsupport_iteratedFDeriv_subset n)\n\n"}
{"name":"norm_fderiv_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : Nat\nâŠ¢ Eq (Norm.norm (fderiv ğ•œ (iteratedFDeriv ğ•œ n f) x)) (Norm.norm (iteratedFDeriv ğ•œ (HAdd.hAdd n 1) f x))","decl":"theorem norm_fderiv_iteratedFDeriv {n : â„•} :\n    â€–fderiv ğ•œ (iteratedFDeriv ğ•œ n f) xâ€– = â€–iteratedFDeriv ğ•œ (n + 1) f xâ€– := by\n  -- Porting note: added `comp_apply`.\n  rw [iteratedFDeriv_succ_eq_comp_left, comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"iteratedFDerivWithin_univ","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f Set.univ) (iteratedFDeriv ğ•œ n f)","decl":"theorem iteratedFDerivWithin_univ {n : â„•} :\n    iteratedFDerivWithin ğ•œ n f univ = iteratedFDeriv ğ•œ n f := by\n  induction n with\n  | zero => ext x; simp\n  | succ n IH =>\n    ext x m\n    rw [iteratedFDeriv_succ_apply_left, iteratedFDerivWithin_succ_apply_left, IH, fderivWithin_univ]\n\n"}
{"name":"HasFTaylorSeriesUpTo.eq_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nh : HasFTaylorSeriesUpTo n f p\nm : Nat\nhmn : LE.le (â†‘m) n\nx : E\nâŠ¢ Eq (p x m) (iteratedFDeriv ğ•œ m f x)","decl":"theorem HasFTaylorSeriesUpTo.eq_iteratedFDeriv\n    (h : HasFTaylorSeriesUpTo n f p) {m : â„•} (hmn : m â‰¤ n) (x : E) :\n    p x m = iteratedFDeriv ğ•œ m f x := by\n  rw [â† iteratedFDerivWithin_univ]\n  rw [â† hasFTaylorSeriesUpToOn_univ_iff] at h\n  exact h.eq_iteratedFDerivWithin_of_uniqueDiffOn hmn uniqueDiffOn_univ (mem_univ _)\n\n"}
{"name":"iteratedFDerivWithin_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : Nat\nhs : IsOpen s\nâŠ¢ Set.EqOn (iteratedFDerivWithin ğ•œ n f s) (iteratedFDeriv ğ•œ n f) s","decl":"/-- In an open set, the iterated derivative within this set coincides with the global iterated\nderivative. -/\ntheorem iteratedFDerivWithin_of_isOpen (n : â„•) (hs : IsOpen s) :\n    EqOn (iteratedFDerivWithin ğ•œ n f s) (iteratedFDeriv ğ•œ n f) s := by\n  induction n with\n  | zero =>\n    intro x _\n    ext1\n    simp only [iteratedFDerivWithin_zero_apply, iteratedFDeriv_zero_apply]\n  | succ n IH =>\n    intro x hx\n    rw [iteratedFDeriv_succ_eq_comp_left, iteratedFDerivWithin_succ_eq_comp_left]\n    dsimp\n    congr 1\n    rw [fderivWithin_of_isOpen hs hx]\n    apply Filter.EventuallyEq.fderiv_eq\n    filter_upwards [hs.mem_nhds hx]\n    exact IH\n\n"}
{"name":"ftaylorSeriesWithin_univ","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Eq (ftaylorSeriesWithin ğ•œ f Set.univ) (ftaylorSeries ğ•œ f)","decl":"theorem ftaylorSeriesWithin_univ : ftaylorSeriesWithin ğ•œ f univ = ftaylorSeries ğ•œ f := by\n  ext1 x; ext1 n\n  change iteratedFDerivWithin ğ•œ n f univ x = iteratedFDeriv ğ•œ n f x\n  rw [iteratedFDerivWithin_univ]\n\n"}
{"name":"iteratedFDeriv_succ_apply_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : Nat\nm : Fin (HAdd.hAdd n 1) â†’ E\nâŠ¢ Eq ((iteratedFDeriv ğ•œ (HAdd.hAdd n 1) f x) m) (((iteratedFDeriv ğ•œ n (fun y => fderiv ğ•œ f y) x) (Fin.init m)) (m (Fin.last n)))","decl":"theorem iteratedFDeriv_succ_apply_right {n : â„•} (m : Fin (n + 1) â†’ E) :\n    (iteratedFDeriv ğ•œ (n + 1) f x : (Fin (n + 1) â†’ E) â†’ F) m =\n      iteratedFDeriv ğ•œ n (fun y => fderiv ğ•œ f y) x (init m) (m (last n)) := by\n  rw [â† iteratedFDerivWithin_univ, â† iteratedFDerivWithin_univ, â† fderivWithin_univ]\n  exact iteratedFDerivWithin_succ_apply_right uniqueDiffOn_univ (mem_univ _) _\n\n"}
{"name":"iteratedFDeriv_succ_eq_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : Nat\nâŠ¢ Eq (iteratedFDeriv ğ•œ (HAdd.hAdd n 1) f x) (Function.comp (â‡‘(continuousMultilinearCurryRightEquiv' ğ•œ n E F).symm) (iteratedFDeriv ğ•œ n fun y => fderiv ğ•œ f y) x)","decl":"/-- Writing explicitly the `n+1`-th derivative as the composition of a currying linear equiv,\nand the `n`-th derivative of the derivative. -/\ntheorem iteratedFDeriv_succ_eq_comp_right {n : â„•} :\n    iteratedFDeriv ğ•œ (n + 1) f x =\n      ((continuousMultilinearCurryRightEquiv' ğ•œ n E F).symm âˆ˜\n          iteratedFDeriv ğ•œ n fun y => fderiv ğ•œ f y) x := by\n  ext m; rw [iteratedFDeriv_succ_apply_right]; rfl\n\n"}
{"name":"norm_iteratedFDeriv_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : Nat\nâŠ¢ Eq (Norm.norm (iteratedFDeriv ğ•œ n (fderiv ğ•œ f) x)) (Norm.norm (iteratedFDeriv ğ•œ (HAdd.hAdd n 1) f x))","decl":"theorem norm_iteratedFDeriv_fderiv {n : â„•} :\n    â€–iteratedFDeriv ğ•œ n (fderiv ğ•œ f) xâ€– = â€–iteratedFDeriv ğ•œ (n + 1) f xâ€– := by\n  -- Porting note: added `comp_apply`.\n  rw [iteratedFDeriv_succ_eq_comp_right, comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"iteratedFDeriv_one_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nm : Fin 1 â†’ E\nâŠ¢ Eq ((iteratedFDeriv ğ•œ 1 f x) m) ((fderiv ğ•œ f x) (m 0))","decl":"@[simp]\ntheorem iteratedFDeriv_one_apply (m : Fin 1 â†’ E) :\n    iteratedFDeriv ğ•œ 1 f x m = fderiv ğ•œ f x (m 0) := by\n  rw [iteratedFDeriv_succ_apply_right, iteratedFDeriv_zero_apply]; rfl\n\n"}
{"name":"iteratedFDeriv_two_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nz : E\nm : Fin 2 â†’ E\nâŠ¢ Eq ((iteratedFDeriv ğ•œ 2 f z) m) (((fderiv ğ•œ (fderiv ğ•œ f) z) (m 0)) (m 1))","decl":"lemma iteratedFDeriv_two_apply (f : E â†’ F) (z : E) (m : Fin 2 â†’ E) :\n    iteratedFDeriv ğ•œ 2 f z m = fderiv ğ•œ (fderiv ğ•œ f) z (m 0) (m 1) := by\n  simp only [iteratedFDeriv_succ_apply_right]\n  rfl\n\n"}
{"name":"iteratedFDeriv_comp_add_left'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\na : E\nâŠ¢ Eq (iteratedFDeriv ğ•œ n fun z => f (HAdd.hAdd a z)) fun x => iteratedFDeriv ğ•œ n f (HAdd.hAdd a x)","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedFDeriv_comp_add_left' (n : â„•) (a : E) :\n    iteratedFDeriv ğ•œ n (fun z â†¦ f (a + z)) = fun x â†¦ iteratedFDeriv ğ•œ n f (a + x) := by\n  simpa [â† iteratedFDerivWithin_univ] using iteratedFDerivWithin_comp_add_left' n a (s := univ)\n\n"}
{"name":"iteratedFDeriv_comp_add_left","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\na x : E\nâŠ¢ Eq (iteratedFDeriv ğ•œ n (fun z => f (HAdd.hAdd a z)) x) (iteratedFDeriv ğ•œ n f (HAdd.hAdd a x))","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedFDeriv_comp_add_left (n : â„•) (a : E) (x : E) :\n    iteratedFDeriv ğ•œ n (fun z â†¦ f (a + z)) x = iteratedFDeriv ğ•œ n f (a + x) := by\n  simp [iteratedFDeriv_comp_add_left']\n\n"}
{"name":"iteratedFDeriv_comp_add_right'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\na : E\nâŠ¢ Eq (iteratedFDeriv ğ•œ n fun z => f (HAdd.hAdd z a)) fun x => iteratedFDeriv ğ•œ n f (HAdd.hAdd x a)","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedFDeriv_comp_add_right' (n : â„•) (a : E) :\n    iteratedFDeriv ğ•œ n (fun z â†¦ f (z + a)) = fun x â†¦ iteratedFDeriv ğ•œ n f (x + a) := by\n  simpa [add_comm a] using iteratedFDeriv_comp_add_left' n a\n\n"}
{"name":"iteratedFDeriv_comp_add_right","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\na x : E\nâŠ¢ Eq (iteratedFDeriv ğ•œ n (fun z => f (HAdd.hAdd z a)) x) (iteratedFDeriv ğ•œ n f (HAdd.hAdd x a))","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedFDeriv_comp_add_right (n : â„•) (a : E) (x : E) :\n    iteratedFDeriv ğ•œ n (fun z â†¦ f (z + a)) x = iteratedFDeriv ğ•œ n f (x + a) := by\n  simp [iteratedFDeriv_comp_add_right']\n\n"}
{"name":"iteratedFDeriv_comp_sub'","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\na : E\nâŠ¢ Eq (iteratedFDeriv ğ•œ n fun z => f (HSub.hSub z a)) fun x => iteratedFDeriv ğ•œ n f (HSub.hSub x a)","decl":"/-- The iterated derivative commutes with subtracting a constant. -/\nlemma iteratedFDeriv_comp_sub' (n : â„•) (a : E) :\n    iteratedFDeriv ğ•œ n (fun z â†¦ f (z - a)) = fun x â†¦ iteratedFDeriv ğ•œ n f (x - a) := by\n  simpa [sub_eq_add_neg] using iteratedFDeriv_comp_add_right' n (-a)\n\n"}
{"name":"iteratedFDeriv_comp_sub","module":"Mathlib.Analysis.Calculus.ContDiff.FTaylorSeries","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\na x : E\nâŠ¢ Eq (iteratedFDeriv ğ•œ n (fun z => f (HSub.hSub z a)) x) (iteratedFDeriv ğ•œ n f (HSub.hSub x a))","decl":"/-- The iterated derivative commutes with subtracting a constant. -/\nlemma iteratedFDeriv_comp_sub (n : â„•) (a : E) (x : E) :\n    iteratedFDeriv ğ•œ n (fun z â†¦ f (z - a)) x = iteratedFDeriv ğ•œ n f (x - a) := by\n  simp [iteratedFDeriv_comp_sub']\n"}
