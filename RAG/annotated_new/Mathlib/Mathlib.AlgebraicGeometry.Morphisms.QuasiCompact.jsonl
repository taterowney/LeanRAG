{"name":"AlgebraicGeometry.QuasiCompact.isCompact_preimage","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.QuasiCompact f\nU : Set ↑↑Y.toPresheafedSpace\na✝¹ : IsOpen U\na✝ : IsCompact U\n⊢ IsCompact (Set.preimage (⇑f.base) U)","decl":"/--\nA morphism is \"quasi-compact\" if the underlying map of topological spaces is, i.e. if the preimages\nof quasi-compact open sets are quasi-compact.\n-/\n@[mk_iff]\nclass QuasiCompact (f : X ⟶ Y) : Prop where\n  /-- Preimage of compact open set under a quasi-compact morphism between schemes is compact. -/\n  isCompact_preimage : ∀ U : Set Y, IsOpen U → IsCompact U → IsCompact (f.base ⁻¹' U)\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.QuasiCompact f) (∀ (U : Set ↑↑Y.toPresheafedSpace), IsOpen U → IsCompact U → IsCompact (Set.preimage (⇑f.base) U))","decl":"/--\nA morphism is \"quasi-compact\" if the underlying map of topological spaces is, i.e. if the preimages\nof quasi-compact open sets are quasi-compact.\n-/\n@[mk_iff]\nclass QuasiCompact (f : X ⟶ Y) : Prop where\n  /-- Preimage of compact open set under a quasi-compact morphism between schemes is compact. -/\n  isCompact_preimage : ∀ U : Set Y, IsOpen U → IsCompact U → IsCompact (f.base ⁻¹' U)\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_iff_spectral","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.QuasiCompact f) (IsSpectralMap ⇑f.base)","decl":"theorem quasiCompact_iff_spectral : QuasiCompact f ↔ IsSpectralMap f.base :=\n  ⟨fun ⟨h⟩ => ⟨by fun_prop, h⟩, fun h => ⟨h.2⟩⟩\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_of_isIso","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ AlgebraicGeometry.QuasiCompact f","decl":"instance (priority := 900) quasiCompact_of_isIso {X Y : Scheme} (f : X ⟶ Y) [IsIso f] :\n    QuasiCompact f := by\n  constructor\n  intro U _ hU'\n  convert hU'.image (inv f.base).continuous_toFun using 1\n  rw [Set.image_eq_preimage_of_inverse]\n  · delta Function.LeftInverse\n    exact IsIso.inv_hom_id_apply f.base\n  · exact IsIso.hom_inv_id_apply f.base\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.QuasiCompact f\ninst✝ : AlgebraicGeometry.QuasiCompact g\n⊢ AlgebraicGeometry.QuasiCompact (CategoryTheory.CategoryStruct.comp f g)","decl":"instance quasiCompact_comp {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) [QuasiCompact f]\n    [QuasiCompact g] : QuasiCompact (f ≫ g) := by\n  constructor\n  intro U hU hU'\n  rw [Scheme.comp_base, TopCat.coe_comp, Set.preimage_comp]\n  apply QuasiCompact.isCompact_preimage\n  · exact Continuous.isOpen_preimage (by fun_prop) _ hU\n  apply QuasiCompact.isCompact_preimage <;> assumption\n\n"}
{"name":"AlgebraicGeometry.isCompactOpen_iff_eq_finset_affine_union","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : Set ↑↑X.toPresheafedSpace\n⊢ Iff (And (IsCompact U) (IsOpen U)) (Exists fun s => And s.Finite (Eq U (Set.iUnion fun i => Set.iUnion fun h => ↑↑i)))","decl":"theorem isCompactOpen_iff_eq_finset_affine_union {X : Scheme} (U : Set X) :\n    IsCompact U ∧ IsOpen U ↔ ∃ s : Set X.affineOpens, s.Finite ∧ U = ⋃ i ∈ s, i := by\n  apply Opens.IsBasis.isCompact_open_iff_eq_finite_iUnion\n    (fun (U : X.affineOpens) => (U : X.Opens))\n  · rw [Subtype.range_coe]; exact isBasis_affine_open X\n  · exact fun i => i.2.isCompact\n\n"}
{"name":"AlgebraicGeometry.isCompactOpen_iff_eq_basicOpen_union","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝ : AlgebraicGeometry.IsAffine X\nU : Set ↑↑X.toPresheafedSpace\n⊢ Iff (And (IsCompact U) (IsOpen U)) (Exists fun s => And s.Finite (Eq U (Set.iUnion fun i => Set.iUnion fun h => ↑(X.basicOpen i))))","decl":"theorem isCompactOpen_iff_eq_basicOpen_union {X : Scheme} [IsAffine X] (U : Set X) :\n    IsCompact U ∧ IsOpen U ↔\n      ∃ s : Set Γ(X, ⊤), s.Finite ∧ U = ⋃ i ∈ s, X.basicOpen i :=\n  (isBasis_basicOpen X).isCompact_open_iff_eq_finite_iUnion _\n    (fun _ => ((isAffineOpen_top _).basicOpen _).isCompact) _\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_iff_forall_affine","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.QuasiCompact f) (∀ (U : Y.Opens), AlgebraicGeometry.IsAffineOpen U → IsCompact ↑((TopologicalSpace.Opens.map f.base).obj U))","decl":"theorem quasiCompact_iff_forall_affine :\n    QuasiCompact f ↔\n      ∀ U : Y.Opens, IsAffineOpen U → IsCompact (f ⁻¹ᵁ U : Set X) := by\n  rw [quasiCompact_iff]\n  refine ⟨fun H U hU => H U U.isOpen hU.isCompact, ?_⟩\n  intro H U hU hU'\n  obtain ⟨S, hS, rfl⟩ := (isCompactOpen_iff_eq_finset_affine_union U).mp ⟨hU', hU⟩\n  simp only [Set.preimage_iUnion]\n  exact Set.Finite.isCompact_biUnion hS (fun i _ => H i i.prop)\n\n"}
{"name":"AlgebraicGeometry.isCompact_basicOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact ↑U\nf : ↑(X.presheaf.obj { unop := U })\n⊢ IsCompact ↑(X.basicOpen f)","decl":"theorem isCompact_basicOpen (X : Scheme) {U : X.Opens} (hU : IsCompact (U : Set X))\n    (f : Γ(X, U)) : IsCompact (X.basicOpen f : Set X) := by\n  classical\n  refine ((isCompactOpen_iff_eq_finset_affine_union _).mpr ?_).1\n  obtain ⟨s, hs, e⟩ := (isCompactOpen_iff_eq_finset_affine_union _).mp ⟨hU, U.isOpen⟩\n  let g : s → X.affineOpens := by\n    intro V\n    use V.1 ⊓ X.basicOpen f\n    have : V.1.1 ⟶ U := by\n      apply homOfLE; change _ ⊆ (U : Set X); rw [e]\n      convert Set.subset_iUnion₂ (s := fun (U : X.affineOpens) (_ : U ∈ s) => (U : Set X))\n        V V.prop using 1\n    erw [← X.toLocallyRingedSpace.toRingedSpace.basicOpen_res this.op]\n    exact IsAffineOpen.basicOpen V.1.prop _\n  haveI : Finite s := hs.to_subtype\n  refine ⟨Set.range g, Set.finite_range g, ?_⟩\n  refine (Set.inter_eq_right.mpr\n            (SetLike.coe_subset_coe.2 <| RingedSpace.basicOpen_le _ _)).symm.trans ?_\n  rw [e, Set.iUnion₂_inter]\n  apply le_antisymm <;> apply Set.iUnion₂_subset\n  · intro i hi\n    -- Porting note: had to make explicit the first given parameter to `Set.subset_iUnion₂`\n    exact Set.Subset.trans (Set.Subset.rfl : _ ≤ g ⟨i, hi⟩)\n      (@Set.subset_iUnion₂ _ _ _\n        (fun (i : X.affineOpens) (_ : i ∈ Set.range g) => (i : Set X.toPresheafedSpace)) _\n        (Set.mem_range_self ⟨i, hi⟩))\n  · rintro ⟨i, hi⟩ ⟨⟨j, hj⟩, hj'⟩\n    rw [← hj']\n    refine Set.Subset.trans ?_ (Set.subset_iUnion₂ j hj)\n    exact Set.Subset.rfl\n\n"}
{"name":"AlgebraicGeometry.instHasAffinePropertyQuasiCompactCompactSpaceαTopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"⊢ AlgebraicGeometry.HasAffineProperty @AlgebraicGeometry.QuasiCompact fun X x x_1 x => CompactSpace ↑↑X.toPresheafedSpace","decl":"instance : HasAffineProperty @QuasiCompact (fun X _ _ _ ↦ CompactSpace X) where\n  eq_targetAffineLocally' := by\n    ext X Y f\n    simp only [quasiCompact_iff_forall_affine, isCompact_iff_compactSpace, targetAffineLocally,\n      Subtype.forall]\n    rfl\n  isLocal_affineProperty := by\n    constructor\n    · apply AffineTargetMorphismProperty.respectsIso_mk <;> rintro X Y Z e _ _ H\n      exacts [@Homeomorph.compactSpace _ _ _ _ H (TopCat.homeoOfIso (asIso e.inv.base)), H]\n    · introv _ H\n      change CompactSpace ((Opens.map f.base).obj (Y.basicOpen r))\n      rw [Scheme.preimage_basicOpen f r]\n      erw [← isCompact_iff_compactSpace]\n      rw [← isCompact_univ_iff] at H\n      apply isCompact_basicOpen\n      exact H\n    · rintro X Y H f S hS hS'\n      rw [← IsAffineOpen.basicOpen_union_eq_self_iff] at hS\n      · rw [← isCompact_univ_iff]\n        change IsCompact ((Opens.map f.base).obj ⊤).1\n        rw [← hS]\n        dsimp [Opens.map]\n        simp only [Opens.iSup_mk, Opens.coe_mk, Set.preimage_iUnion]\n        exact isCompact_iUnion fun i => isCompact_iff_compactSpace.mpr (hS' i)\n      · exact isAffineOpen_top _\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_over_affine_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsAffine Y\n⊢ Iff (AlgebraicGeometry.QuasiCompact f) (CompactSpace ↑↑X.toPresheafedSpace)","decl":"theorem quasiCompact_over_affine_iff {X Y : Scheme} (f : X ⟶ Y) [IsAffine Y] :\n    QuasiCompact f ↔ CompactSpace X := by\n  rw [HasAffineProperty.iff_of_isAffine (P := @QuasiCompact)]\n\n"}
{"name":"AlgebraicGeometry.compactSpace_iff_quasiCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Iff (CompactSpace ↑↑X.toPresheafedSpace) (AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.terminal.from X))","decl":"theorem compactSpace_iff_quasiCompact (X : Scheme) :\n    CompactSpace X ↔ QuasiCompact (terminal.from X) := by\n  rw [HasAffineProperty.iff_of_isAffine (P := @QuasiCompact)]\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_isStableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderComposition @AlgebraicGeometry.QuasiCompact","decl":"instance quasiCompact_isStableUnderComposition :\n    MorphismProperty.IsStableUnderComposition @QuasiCompact where\n  comp_mem _ _ _ _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.QuasiCompact","decl":"instance quasiCompact_isStableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @QuasiCompact := by\n  letI := HasAffineProperty.isLocal_affineProperty @QuasiCompact\n  apply HasAffineProperty.isStableUnderBaseChange\n  apply AffineTargetMorphismProperty.IsStableUnderBaseChange.mk\n  intro X Y S _ _ f g h\n  let 𝒰 := Scheme.Pullback.openCoverOfRight Y.affineCover.finiteSubcover f g\n  have : Finite 𝒰.J := by dsimp [𝒰]; infer_instance\n  have : ∀ i, CompactSpace (𝒰.obj i) := by intro i; dsimp [𝒰]; infer_instance\n  exact 𝒰.compactSpace\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactFstScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : AlgebraicGeometry.QuasiCompact g\n⊢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.pullback.fst f g)","decl":"instance (f : X ⟶ Z) (g : Y ⟶ Z) [QuasiCompact g] : QuasiCompact (pullback.fst f g) :=\n  MorphismProperty.pullback_fst f g inferInstance\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactSndScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : AlgebraicGeometry.QuasiCompact f\n⊢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.pullback.snd f g)","decl":"instance (f : X ⟶ Z) (g : Y ⟶ Z) [QuasiCompact f] : QuasiCompact (pullback.snd f g) :=\n  MorphismProperty.pullback_snd f g inferInstance\n\n"}
{"name":"AlgebraicGeometry.compactSpace_iff_exists","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Iff (CompactSpace ↑↑X.toPresheafedSpace) (Exists fun R => Exists fun f => Function.Surjective ⇑f.base)","decl":"lemma compactSpace_iff_exists :\n    CompactSpace X ↔ ∃ R, ∃ f : Spec R ⟶ X, Function.Surjective f.base := by\n  refine ⟨fun h ↦ ?_, fun ⟨R, f, hf⟩ ↦ ⟨hf.range_eq ▸ isCompact_range f.continuous⟩⟩\n  let 𝒰 : X.OpenCover := X.affineCover.finiteSubcover\n  have (x : 𝒰.J) : IsAffine (𝒰.obj x) := X.isAffine_affineCover _\n  refine ⟨Γ(∐ 𝒰.obj, ⊤), (∐ 𝒰.obj).isoSpec.inv ≫ Sigma.desc 𝒰.map, ?_⟩\n  refine Function.Surjective.comp (g := (Sigma.desc 𝒰.map).base)\n    (fun x ↦ ?_) (∐ 𝒰.obj).isoSpec.inv.surjective\n  obtain ⟨y, hy⟩ := 𝒰.covers x\n  exact ⟨(Sigma.ι 𝒰.obj (𝒰.f x)).base y, by rw [← Scheme.comp_base_apply, Sigma.ι_desc, hy]⟩\n\n"}
{"name":"AlgebraicGeometry.isCompact_iff_exists","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Iff (IsCompact ↑U) (Exists fun R => Exists fun f => Eq (Set.range ⇑f.base) ↑U)","decl":"lemma isCompact_iff_exists {U : X.Opens} :\n    IsCompact (U : Set X) ↔ ∃ R, ∃ f : Spec R ⟶ X, Set.range f.base = U := by\n  refine isCompact_iff_compactSpace.trans ((compactSpace_iff_exists (X := U)).trans ?_)\n  refine ⟨fun ⟨R, f, hf⟩ ↦ ⟨R, f ≫ U.ι, by simp [hf.range_comp]⟩, fun ⟨R, f, hf⟩ ↦ ?_⟩\n  refine ⟨R, IsOpenImmersion.lift U.ι f (by simp [hf]), ?_⟩\n  rw [← Set.range_eq_univ]\n  apply show Function.Injective (U.ι.base '' ·) from Set.image_val_injective\n  simp only [Set.image_univ, Scheme.Opens.range_ι]\n  rwa [← Set.range_comp, ← TopCat.coe_comp, ← Scheme.comp_base, IsOpenImmersion.lift_fac]\n\n"}
{"name":"AlgebraicGeometry.isClosedMap_iff_specializingMap","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.QuasiCompact f\n⊢ Iff (IsClosedMap ⇑f.base) (SpecializingMap ⇑f.base)","decl":"@[stacks 01K9]\nlemma isClosedMap_iff_specializingMap (f : X ⟶ Y) [QuasiCompact f] :\n    IsClosedMap f.base ↔ SpecializingMap f.base := by\n  refine ⟨fun h ↦ h.specializingMap, fun H ↦ ?_⟩\n  wlog hY : ∃ R, Y = Spec R\n  · show topologically @IsClosedMap f\n    rw [IsLocalAtTarget.iff_of_openCover (P := topologically @IsClosedMap) Y.affineCover]\n    intro i\n    haveI hqc : QuasiCompact (Y.affineCover.pullbackHom f i) :=\n        IsLocalAtTarget.of_isPullback (.of_hasPullback _ _) inferInstance\n    refine this (Y.affineCover.pullbackHom f i) ?_ ⟨_, rfl⟩\n    exact IsLocalAtTarget.of_isPullback\n      (P := topologically @SpecializingMap) (.of_hasPullback _ _) H\n  obtain ⟨S, rfl⟩ := hY\n  clear * - H\n  intros Z hZ\n  replace H := hZ.stableUnderSpecialization.image H\n  wlog hX : ∃ R, X = Spec R\n  · obtain ⟨R, g, hg⟩ :=\n      compactSpace_iff_exists.mp ((quasiCompact_over_affine_iff f).mp inferInstance)\n    have inst : QuasiCompact (g ≫ f) := HasAffineProperty.iff_of_isAffine.mpr (by infer_instance)\n    have := this _ (g ≫ f) (g.base ⁻¹' Z) (hZ.preimage g.continuous)\n    simp_rw [Scheme.comp_base, TopCat.comp_app, ← Set.image_image,\n      Set.image_preimage_eq _ hg] at this\n    exact this H ⟨_, rfl⟩\n  obtain ⟨R, rfl⟩ := hX\n  obtain ⟨φ, rfl⟩ := Spec.homEquiv.symm.surjective f\n  exact PrimeSpectrum.isClosed_image_of_stableUnderSpecialization φ.hom Z hZ H\n\n"}
{"name":"AlgebraicGeometry.compact_open_induction_on","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nP : X.Opens → Prop\nS : X.Opens\nhS : IsCompact S.carrier\nh₁ : P Bot.bot\nh₂ : ∀ (S : X.Opens), IsCompact S.carrier → ∀ (U : ↑X.affineOpens), P S → P (Max.max S ↑U)\n⊢ P S","decl":"@[elab_as_elim]\ntheorem compact_open_induction_on {P : X.Opens → Prop} (S : X.Opens)\n    (hS : IsCompact S.1) (h₁ : P ⊥)\n    (h₂ : ∀ (S : X.Opens) (_ : IsCompact S.1) (U : X.affineOpens), P S → P (S ⊔ U)) :\n    P S := by\n  classical\n  obtain ⟨s, hs, hs'⟩ := (isCompactOpen_iff_eq_finset_affine_union S.1).mp ⟨hS, S.2⟩\n  replace hs' : S = iSup fun i : s => (i : X.Opens) := by ext1; simpa using hs'\n  subst hs'\n  apply @Set.Finite.induction_on _ _ _ hs\n  · convert h₁; rw [iSup_eq_bot]; rintro ⟨_, h⟩; exact h.elim\n  · intro x s _ hs h₄\n    have : IsCompact (⨆ i : s, (i : X.Opens)).1 := by\n      refine ((isCompactOpen_iff_eq_finset_affine_union _).mpr ?_).1; exact ⟨s, hs, by simp⟩\n    convert h₂ _ this x h₄\n    rw [iSup_subtype, sup_comm]\n    conv_rhs => rw [iSup_subtype]\n    exact iSup_insert\n\n"}
{"name":"AlgebraicGeometry.exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx f : ↑(X.presheaf.obj { unop := U })\nH : Eq (TopCat.Presheaf.restrictOpen x (X.basicOpen f) ⋯) 0\n⊢ Exists fun n => Eq (HMul.hMul (HPow.hPow f n) x) 0","decl":"theorem exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen (X : Scheme)\n    {U : X.Opens} (hU : IsAffineOpen U) (x f : Γ(X, U))\n    (H : x |_ (X.basicOpen f) = 0) :\n    ∃ n : ℕ, f ^ n * x = 0 := by\n  rw [← map_zero (X.presheaf.map (homOfLE <| X.basicOpen_le f : X.basicOpen f ⟶ U).op).hom] at H\n  #adaptation_note /-- nightly-2024-09-29\n  we could use dot notation here:\n  `(hU.isLocalization_basicOpen f).exists_of_eq H`\n  This is no longer possible;\n  likely changing the signature of `IsLocalization.Away.exists_of_eq` is in order.\n  -/\n  obtain ⟨n, e⟩ :=\n    @IsLocalization.Away.exists_of_eq _ _ _ _ _ _ (hU.isLocalization_basicOpen f) _ _ H\n  exact ⟨n, by simpa [mul_comm x] using e⟩\n\n"}
{"name":"AlgebraicGeometry.exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact U.carrier\nx f : ↑(X.presheaf.obj { unop := U })\nH : Eq (TopCat.Presheaf.restrictOpen x (X.basicOpen f) ⋯) 0\n⊢ Exists fun n => Eq (HMul.hMul (HPow.hPow f n) x) 0","decl":"/-- If `x : Γ(X, U)` is zero on `D(f)` for some `f : Γ(X, U)`, and `U` is quasi-compact, then\n`f ^ n * x = 0` for some `n`. -/\ntheorem exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact (X : Scheme.{u})\n    {U : X.Opens} (hU : IsCompact U.1) (x f : Γ(X, U))\n    (H : x |_ (X.basicOpen f) = 0) :\n    ∃ n : ℕ, f ^ n * x = 0 := by\n  obtain ⟨s, hs, e⟩ := (isCompactOpen_iff_eq_finset_affine_union U.1).mp ⟨hU, U.2⟩\n  replace e : U = iSup fun i : s => (i : X.Opens) := by\n    ext1; simpa using e\n  have h₁ : ∀ i : s, i.1.1 ≤ U := by\n    intro i\n    change (i : X.Opens) ≤ U\n    rw [e]\n    -- Porting note: `exact le_iSup _ _` no longer works\n    exact le_iSup (fun (i : s) => (i : Opens (X.toPresheafedSpace))) _\n  have H' := fun i : s =>\n    exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen X i.1.2\n      (X.presheaf.map (homOfLE (h₁ i)).op x) (X.presheaf.map (homOfLE (h₁ i)).op f) ?_\n  swap\n  · show (X.presheaf.map (homOfLE _).op) ((X.presheaf.map (homOfLE _).op).hom x) = 0\n    have H : (X.presheaf.map (homOfLE _).op) x = 0 := H\n    convert congr_arg (X.presheaf.map (homOfLE _).op).hom H\n    · simp only [← CommRingCat.comp_apply, ← Functor.map_comp]\n      · rfl\n    · rw [map_zero]\n    · simp only [Scheme.basicOpen_res, inf_le_right]\n  choose n hn using H'\n  haveI := hs.to_subtype\n  cases nonempty_fintype s\n  use Finset.univ.sup n\n  suffices ∀ i : s, X.presheaf.map (homOfLE (h₁ i)).op (f ^ Finset.univ.sup n * x) = 0 by\n    subst e\n    apply TopCat.Sheaf.eq_of_locally_eq X.sheaf fun i : s => (i : X.Opens)\n    intro i\n    show _ = (X.sheaf.val.map _) 0\n    rw [map_zero]\n    apply this\n  intro i\n  replace hn :=\n    congr_arg (fun x => X.presheaf.map (homOfLE (h₁ i)).op (f ^ (Finset.univ.sup n - n i)) * x)\n      (hn i)\n  dsimp at hn\n  simp only [← map_mul, ← map_pow] at hn\n  rwa [mul_zero, ← mul_assoc, ← pow_add, tsub_add_cancel_of_le] at hn\n  apply Finset.le_sup (Finset.mem_univ i)\n\n"}
{"name":"AlgebraicGeometry.Scheme.isNilpotent_iff_basicOpen_eq_bot_of_isCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact ↑U\nf : ↑(X.presheaf.obj { unop := U })\n⊢ Iff (IsNilpotent f) (Eq (X.basicOpen f) Bot.bot)","decl":"/-- A section over a compact open of a scheme is nilpotent if and only if its associated\nbasic open is empty. -/\nlemma Scheme.isNilpotent_iff_basicOpen_eq_bot_of_isCompact {X : Scheme.{u}}\n    {U : X.Opens} (hU : IsCompact (U : Set X)) (f : Γ(X, U)) :\n    IsNilpotent f ↔ X.basicOpen f = ⊥ := by\n  refine ⟨X.basicOpen_eq_bot_of_isNilpotent U f, fun hf ↦ ?_⟩\n  have h : (1 : Γ(X, U)) |_ (X.basicOpen f) = 0 := by\n    have e : X.basicOpen f ≤ ⊥ := by rw [hf]\n    rw [← TopCat.Presheaf.restrict_restrict e bot_le]\n    have : Subsingleton Γ(X, ⊥) :=\n      CommRingCat.subsingleton_of_isTerminal X.sheaf.isTerminalOfEmpty\n    rw [Subsingleton.eq_zero (1 |_ ⊥)]\n    show X.presheaf.map _ 0 = 0\n    rw [map_zero]\n  obtain ⟨n, hn⟩ := exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact X hU 1 f h\n  rw [mul_one] at hn\n  use n\n\n"}
{"name":"AlgebraicGeometry.Scheme.isNilpotent_iff_basicOpen_eq_bot","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝ : CompactSpace ↑↑X.toPresheafedSpace\nf : ↑(X.presheaf.obj { unop := Top.top })\n⊢ Iff (IsNilpotent f) (Eq (X.basicOpen f) Bot.bot)","decl":"/-- A global section of a quasi-compact scheme is nilpotent if and only if its associated\nbasic open is empty. -/\nlemma Scheme.isNilpotent_iff_basicOpen_eq_bot {X : Scheme.{u}}\n    [CompactSpace X] (f : Γ(X, ⊤)) :\n    IsNilpotent f ↔ X.basicOpen f = ⊥ :=\n  isNilpotent_iff_basicOpen_eq_bot_of_isCompact (U := ⊤) (CompactSpace.isCompact_univ) f\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_eq_top_iff_subset_nilradical_of_isCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact ↑U\ns : Set ↑(X.presheaf.obj { unop := U })\n⊢ Iff (Eq (X.zeroLocus s) Top.top) (HasSubset.Subset s ↑(nilradical ↑(X.presheaf.obj { unop := U })))","decl":"/-- The zero locus of a set of sections over a compact open of a scheme is `X` if and only if\n`s` is contained in the nilradical of `Γ(X, U)`. -/\nlemma Scheme.zeroLocus_eq_top_iff_subset_nilradical_of_isCompact {X : Scheme.{u}} {U : X.Opens}\n    (hU : IsCompact (U : Set X)) (s : Set Γ(X, U)) :\n    X.zeroLocus s = ⊤ ↔ s ⊆ nilradical Γ(X, U) := by\n  simp [Scheme.zeroLocus_def, ← Scheme.isNilpotent_iff_basicOpen_eq_bot_of_isCompact hU,\n    ← mem_nilradical, Set.subset_def]\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_eq_top_iff_subset_nilradical","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\ninst✝ : CompactSpace ↑↑X.toPresheafedSpace\ns : Set ↑(X.presheaf.obj { unop := Top.top })\n⊢ Iff (Eq (X.zeroLocus s) Top.top) (HasSubset.Subset s ↑(nilradical ↑(X.presheaf.obj { unop := Top.top })))","decl":"/-- The zero locus of a set of sections over a compact open of a scheme is `X` if and only if\n`s` is contained in the nilradical of `Γ(X, U)`. -/\nlemma Scheme.zeroLocus_eq_top_iff_subset_nilradical {X : Scheme.{u}}\n    [CompactSpace X] (s : Set Γ(X, ⊤)) :\n    X.zeroLocus s = ⊤ ↔ s ⊆ nilradical Γ(X, ⊤) :=\n  zeroLocus_eq_top_iff_subset_nilradical_of_isCompact (U := ⊤) (CompactSpace.isCompact_univ) s\n\n"}
