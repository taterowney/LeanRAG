{"name":"AlgebraicGeometry.QuasiCompact.isCompact_preimage","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.QuasiCompact f\nU : Set ‚Üë‚ÜëY.toPresheafedSpace\na‚úù¬π : IsOpen U\na‚úù : IsCompact U\n‚ä¢ IsCompact (Set.preimage (‚áëf.base) U)","decl":"/--\nA morphism is \"quasi-compact\" if the underlying map of topological spaces is, i.e. if the preimages\nof quasi-compact open sets are quasi-compact.\n-/\n@[mk_iff]\nclass QuasiCompact (f : X ‚ü∂ Y) : Prop where\n  /-- Preimage of compact open set under a quasi-compact morphism between schemes is compact. -/\n  isCompact_preimage : ‚àÄ U : Set Y, IsOpen U ‚Üí IsCompact U ‚Üí IsCompact (f.base ‚Åª¬π' U)\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.QuasiCompact f) (‚àÄ (U : Set ‚Üë‚ÜëY.toPresheafedSpace), IsOpen U ‚Üí IsCompact U ‚Üí IsCompact (Set.preimage (‚áëf.base) U))","decl":"/--\nA morphism is \"quasi-compact\" if the underlying map of topological spaces is, i.e. if the preimages\nof quasi-compact open sets are quasi-compact.\n-/\n@[mk_iff]\nclass QuasiCompact (f : X ‚ü∂ Y) : Prop where\n  /-- Preimage of compact open set under a quasi-compact morphism between schemes is compact. -/\n  isCompact_preimage : ‚àÄ U : Set Y, IsOpen U ‚Üí IsCompact U ‚Üí IsCompact (f.base ‚Åª¬π' U)\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_iff_spectral","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.QuasiCompact f) (IsSpectralMap ‚áëf.base)","decl":"theorem quasiCompact_iff_spectral : QuasiCompact f ‚Üî IsSpectralMap f.base :=\n  ‚ü®fun ‚ü®h‚ü© => ‚ü®by fun_prop, h‚ü©, fun h => ‚ü®h.2‚ü©‚ü©\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_of_isIso","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ AlgebraicGeometry.QuasiCompact f","decl":"instance (priority := 900) quasiCompact_of_isIso {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] :\n    QuasiCompact f := by\n  constructor\n  intro U _ hU'\n  convert hU'.image (inv f.base).continuous_toFun using 1\n  rw [Set.image_eq_preimage_of_inverse]\n  ¬∑ delta Function.LeftInverse\n    exact IsIso.inv_hom_id_apply f.base\n  ¬∑ exact IsIso.hom_inv_id_apply f.base\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : AlgebraicGeometry.QuasiCompact f\ninst‚úù : AlgebraicGeometry.QuasiCompact g\n‚ä¢ AlgebraicGeometry.QuasiCompact (CategoryTheory.CategoryStruct.comp f g)","decl":"instance quasiCompact_comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [QuasiCompact f]\n    [QuasiCompact g] : QuasiCompact (f ‚â´ g) := by\n  constructor\n  intro U hU hU'\n  rw [Scheme.comp_base, TopCat.coe_comp, Set.preimage_comp]\n  apply QuasiCompact.isCompact_preimage\n  ¬∑ exact Continuous.isOpen_preimage (by fun_prop) _ hU\n  apply QuasiCompact.isCompact_preimage <;> assumption\n\n"}
{"name":"AlgebraicGeometry.isCompactOpen_iff_eq_finset_affine_union","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : Set ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Iff (And (IsCompact U) (IsOpen U)) (Exists fun s => And s.Finite (Eq U (Set.iUnion fun i => Set.iUnion fun h => ‚Üë‚Üëi)))","decl":"theorem isCompactOpen_iff_eq_finset_affine_union {X : Scheme} (U : Set X) :\n    IsCompact U ‚àß IsOpen U ‚Üî ‚àÉ s : Set X.affineOpens, s.Finite ‚àß U = ‚ãÉ i ‚àà s, i := by\n  apply Opens.IsBasis.isCompact_open_iff_eq_finite_iUnion\n    (fun (U : X.affineOpens) => (U : X.Opens))\n  ¬∑ rw [Subtype.range_coe]; exact isBasis_affine_open X\n  ¬∑ exact fun i => i.2.isCompact\n\n"}
{"name":"AlgebraicGeometry.isCompactOpen_iff_eq_basicOpen_union","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine X\nU : Set ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Iff (And (IsCompact U) (IsOpen U)) (Exists fun s => And s.Finite (Eq U (Set.iUnion fun i => Set.iUnion fun h => ‚Üë(X.basicOpen i))))","decl":"theorem isCompactOpen_iff_eq_basicOpen_union {X : Scheme} [IsAffine X] (U : Set X) :\n    IsCompact U ‚àß IsOpen U ‚Üî\n      ‚àÉ s : Set Œì(X, ‚ä§), s.Finite ‚àß U = ‚ãÉ i ‚àà s, X.basicOpen i :=\n  (isBasis_basicOpen X).isCompact_open_iff_eq_finite_iUnion _\n    (fun _ => ((isAffineOpen_top _).basicOpen _).isCompact) _\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_iff_forall_affine","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.QuasiCompact f) (‚àÄ (U : Y.Opens), AlgebraicGeometry.IsAffineOpen U ‚Üí IsCompact ‚Üë((TopologicalSpace.Opens.map f.base).obj U))","decl":"theorem quasiCompact_iff_forall_affine :\n    QuasiCompact f ‚Üî\n      ‚àÄ U : Y.Opens, IsAffineOpen U ‚Üí IsCompact (f ‚Åª¬π·µÅ U : Set X) := by\n  rw [quasiCompact_iff]\n  refine ‚ü®fun H U hU => H U U.isOpen hU.isCompact, ?_‚ü©\n  intro H U hU hU'\n  obtain ‚ü®S, hS, rfl‚ü© := (isCompactOpen_iff_eq_finset_affine_union U).mp ‚ü®hU', hU‚ü©\n  simp only [Set.preimage_iUnion]\n  exact Set.Finite.isCompact_biUnion hS (fun i _ => H i i.prop)\n\n"}
{"name":"AlgebraicGeometry.isCompact_basicOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact ‚ÜëU\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ IsCompact ‚Üë(X.basicOpen f)","decl":"theorem isCompact_basicOpen (X : Scheme) {U : X.Opens} (hU : IsCompact (U : Set X))\n    (f : Œì(X, U)) : IsCompact (X.basicOpen f : Set X) := by\n  classical\n  refine ((isCompactOpen_iff_eq_finset_affine_union _).mpr ?_).1\n  obtain ‚ü®s, hs, e‚ü© := (isCompactOpen_iff_eq_finset_affine_union _).mp ‚ü®hU, U.isOpen‚ü©\n  let g : s ‚Üí X.affineOpens := by\n    intro V\n    use V.1 ‚äì X.basicOpen f\n    have : V.1.1 ‚ü∂ U := by\n      apply homOfLE; change _ ‚äÜ (U : Set X); rw [e]\n      convert Set.subset_iUnion‚ÇÇ (s := fun (U : X.affineOpens) (_ : U ‚àà s) => (U : Set X))\n        V V.prop using 1\n    erw [‚Üê X.toLocallyRingedSpace.toRingedSpace.basicOpen_res this.op]\n    exact IsAffineOpen.basicOpen V.1.prop _\n  haveI : Finite s := hs.to_subtype\n  refine ‚ü®Set.range g, Set.finite_range g, ?_‚ü©\n  refine (Set.inter_eq_right.mpr\n            (SetLike.coe_subset_coe.2 <| RingedSpace.basicOpen_le _ _)).symm.trans ?_\n  rw [e, Set.iUnion‚ÇÇ_inter]\n  apply le_antisymm <;> apply Set.iUnion‚ÇÇ_subset\n  ¬∑ intro i hi\n    -- Porting note: had to make explicit the first given parameter to `Set.subset_iUnion‚ÇÇ`\n    exact Set.Subset.trans (Set.Subset.rfl : _ ‚â§ g ‚ü®i, hi‚ü©)\n      (@Set.subset_iUnion‚ÇÇ _ _ _\n        (fun (i : X.affineOpens) (_ : i ‚àà Set.range g) => (i : Set X.toPresheafedSpace)) _\n        (Set.mem_range_self ‚ü®i, hi‚ü©))\n  ¬∑ rintro ‚ü®i, hi‚ü© ‚ü®‚ü®j, hj‚ü©, hj'‚ü©\n    rw [‚Üê hj']\n    refine Set.Subset.trans ?_ (Set.subset_iUnion‚ÇÇ j hj)\n    exact Set.Subset.rfl\n\n"}
{"name":"AlgebraicGeometry.instHasAffinePropertyQuasiCompactCompactSpaceŒ±TopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"‚ä¢ AlgebraicGeometry.HasAffineProperty @AlgebraicGeometry.QuasiCompact fun X x x_1 x => CompactSpace ‚Üë‚ÜëX.toPresheafedSpace","decl":"instance : HasAffineProperty @QuasiCompact (fun X _ _ _ ‚Ü¶ CompactSpace X) where\n  eq_targetAffineLocally' := by\n    ext X Y f\n    simp only [quasiCompact_iff_forall_affine, isCompact_iff_compactSpace, targetAffineLocally,\n      Subtype.forall]\n    rfl\n  isLocal_affineProperty := by\n    constructor\n    ¬∑ apply AffineTargetMorphismProperty.respectsIso_mk <;> rintro X Y Z e _ _ H\n      exacts [@Homeomorph.compactSpace _ _ _ _ H (TopCat.homeoOfIso (asIso e.inv.base)), H]\n    ¬∑ introv _ H\n      change CompactSpace ((Opens.map f.base).obj (Y.basicOpen r))\n      rw [Scheme.preimage_basicOpen f r]\n      erw [‚Üê isCompact_iff_compactSpace]\n      rw [‚Üê isCompact_univ_iff] at H\n      apply isCompact_basicOpen\n      exact H\n    ¬∑ rintro X Y H f S hS hS'\n      rw [‚Üê IsAffineOpen.basicOpen_union_eq_self_iff] at hS\n      ¬∑ rw [‚Üê isCompact_univ_iff]\n        change IsCompact ((Opens.map f.base).obj ‚ä§).1\n        rw [‚Üê hS]\n        dsimp [Opens.map]\n        simp only [Opens.iSup_mk, Opens.coe_mk, Set.preimage_iUnion]\n        exact isCompact_iUnion fun i => isCompact_iff_compactSpace.mpr (hS' i)\n      ¬∑ exact isAffineOpen_top _\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_over_affine_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsAffine Y\n‚ä¢ Iff (AlgebraicGeometry.QuasiCompact f) (CompactSpace ‚Üë‚ÜëX.toPresheafedSpace)","decl":"theorem quasiCompact_over_affine_iff {X Y : Scheme} (f : X ‚ü∂ Y) [IsAffine Y] :\n    QuasiCompact f ‚Üî CompactSpace X := by\n  rw [HasAffineProperty.iff_of_isAffine (P := @QuasiCompact)]\n\n"}
{"name":"AlgebraicGeometry.compactSpace_iff_quasiCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Iff (CompactSpace ‚Üë‚ÜëX.toPresheafedSpace) (AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.terminal.from X))","decl":"theorem compactSpace_iff_quasiCompact (X : Scheme) :\n    CompactSpace X ‚Üî QuasiCompact (terminal.from X) := by\n  rw [HasAffineProperty.iff_of_isAffine (P := @QuasiCompact)]\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_isStableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsStableUnderComposition @AlgebraicGeometry.QuasiCompact","decl":"instance quasiCompact_isStableUnderComposition :\n    MorphismProperty.IsStableUnderComposition @QuasiCompact where\n  comp_mem _ _ _ _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.quasiCompact_isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"‚ä¢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.QuasiCompact","decl":"instance quasiCompact_isStableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @QuasiCompact := by\n  letI := HasAffineProperty.isLocal_affineProperty @QuasiCompact\n  apply HasAffineProperty.isStableUnderBaseChange\n  apply AffineTargetMorphismProperty.IsStableUnderBaseChange.mk\n  intro X Y S _ _ f g h\n  let ùí∞ := Scheme.Pullback.openCoverOfRight Y.affineCover.finiteSubcover f g\n  have : Finite ùí∞.J := by dsimp [ùí∞]; infer_instance\n  have : ‚àÄ i, CompactSpace (ùí∞.obj i) := by intro i; dsimp [ùí∞]; infer_instance\n  exact ùí∞.compactSpace\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactFstScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : AlgebraicGeometry.QuasiCompact g\n‚ä¢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.pullback.fst f g)","decl":"instance (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [QuasiCompact g] : QuasiCompact (pullback.fst f g) :=\n  MorphismProperty.pullback_fst f g inferInstance\n\n"}
{"name":"AlgebraicGeometry.instQuasiCompactSndScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : AlgebraicGeometry.QuasiCompact f\n‚ä¢ AlgebraicGeometry.QuasiCompact (CategoryTheory.Limits.pullback.snd f g)","decl":"instance (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [QuasiCompact f] : QuasiCompact (pullback.snd f g) :=\n  MorphismProperty.pullback_snd f g inferInstance\n\n"}
{"name":"AlgebraicGeometry.compactSpace_iff_exists","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Iff (CompactSpace ‚Üë‚ÜëX.toPresheafedSpace) (Exists fun R => Exists fun f => Function.Surjective ‚áëf.base)","decl":"lemma compactSpace_iff_exists :\n    CompactSpace X ‚Üî ‚àÉ R, ‚àÉ f : Spec R ‚ü∂ X, Function.Surjective f.base := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®R, f, hf‚ü© ‚Ü¶ ‚ü®hf.range_eq ‚ñ∏ isCompact_range f.continuous‚ü©‚ü©\n  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover\n  have (x : ùí∞.J) : IsAffine (ùí∞.obj x) := X.isAffine_affineCover _\n  refine ‚ü®Œì(‚àê ùí∞.obj, ‚ä§), (‚àê ùí∞.obj).isoSpec.inv ‚â´ Sigma.desc ùí∞.map, ?_‚ü©\n  refine Function.Surjective.comp (g := (Sigma.desc ùí∞.map).base)\n    (fun x ‚Ü¶ ?_) (‚àê ùí∞.obj).isoSpec.inv.surjective\n  obtain ‚ü®y, hy‚ü© := ùí∞.covers x\n  exact ‚ü®(Sigma.Œπ ùí∞.obj (ùí∞.f x)).base y, by rw [‚Üê Scheme.comp_base_apply, Sigma.Œπ_desc, hy]‚ü©\n\n"}
{"name":"AlgebraicGeometry.isCompact_iff_exists","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n‚ä¢ Iff (IsCompact ‚ÜëU) (Exists fun R => Exists fun f => Eq (Set.range ‚áëf.base) ‚ÜëU)","decl":"lemma isCompact_iff_exists {U : X.Opens} :\n    IsCompact (U : Set X) ‚Üî ‚àÉ R, ‚àÉ f : Spec R ‚ü∂ X, Set.range f.base = U := by\n  refine isCompact_iff_compactSpace.trans ((compactSpace_iff_exists (X := U)).trans ?_)\n  refine ‚ü®fun ‚ü®R, f, hf‚ü© ‚Ü¶ ‚ü®R, f ‚â´ U.Œπ, by simp [hf.range_comp]‚ü©, fun ‚ü®R, f, hf‚ü© ‚Ü¶ ?_‚ü©\n  refine ‚ü®R, IsOpenImmersion.lift U.Œπ f (by simp [hf]), ?_‚ü©\n  rw [‚Üê Set.range_eq_univ]\n  apply show Function.Injective (U.Œπ.base '' ¬∑) from Set.image_val_injective\n  simp only [Set.image_univ, Scheme.Opens.range_Œπ]\n  rwa [‚Üê Set.range_comp, ‚Üê TopCat.coe_comp, ‚Üê Scheme.comp_base, IsOpenImmersion.lift_fac]\n\n"}
{"name":"AlgebraicGeometry.isClosedMap_iff_specializingMap","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.QuasiCompact f\n‚ä¢ Iff (IsClosedMap ‚áëf.base) (SpecializingMap ‚áëf.base)","decl":"@[stacks 01K9]\nlemma isClosedMap_iff_specializingMap (f : X ‚ü∂ Y) [QuasiCompact f] :\n    IsClosedMap f.base ‚Üî SpecializingMap f.base := by\n  refine ‚ü®fun h ‚Ü¶ h.specializingMap, fun H ‚Ü¶ ?_‚ü©\n  wlog hY : ‚àÉ R, Y = Spec R\n  ¬∑ show topologically @IsClosedMap f\n    rw [IsLocalAtTarget.iff_of_openCover (P := topologically @IsClosedMap) Y.affineCover]\n    intro i\n    haveI hqc : QuasiCompact (Y.affineCover.pullbackHom f i) :=\n        IsLocalAtTarget.of_isPullback (.of_hasPullback _ _) inferInstance\n    refine this (Y.affineCover.pullbackHom f i) ?_ ‚ü®_, rfl‚ü©\n    exact IsLocalAtTarget.of_isPullback\n      (P := topologically @SpecializingMap) (.of_hasPullback _ _) H\n  obtain ‚ü®S, rfl‚ü© := hY\n  clear * - H\n  intros Z hZ\n  replace H := hZ.stableUnderSpecialization.image H\n  wlog hX : ‚àÉ R, X = Spec R\n  ¬∑ obtain ‚ü®R, g, hg‚ü© :=\n      compactSpace_iff_exists.mp ((quasiCompact_over_affine_iff f).mp inferInstance)\n    have inst : QuasiCompact (g ‚â´ f) := HasAffineProperty.iff_of_isAffine.mpr (by infer_instance)\n    have := this _ (g ‚â´ f) (g.base ‚Åª¬π' Z) (hZ.preimage g.continuous)\n    simp_rw [Scheme.comp_base, TopCat.comp_app, ‚Üê Set.image_image,\n      Set.image_preimage_eq _ hg] at this\n    exact this H ‚ü®_, rfl‚ü©\n  obtain ‚ü®R, rfl‚ü© := hX\n  obtain ‚ü®œÜ, rfl‚ü© := Spec.homEquiv.symm.surjective f\n  exact PrimeSpectrum.isClosed_image_of_stableUnderSpecialization œÜ.hom Z hZ H\n\n"}
{"name":"AlgebraicGeometry.compact_open_induction_on","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nP : X.Opens ‚Üí Prop\nS : X.Opens\nhS : IsCompact S.carrier\nh‚ÇÅ : P Bot.bot\nh‚ÇÇ : ‚àÄ (S : X.Opens), IsCompact S.carrier ‚Üí ‚àÄ (U : ‚ÜëX.affineOpens), P S ‚Üí P (Max.max S ‚ÜëU)\n‚ä¢ P S","decl":"@[elab_as_elim]\ntheorem compact_open_induction_on {P : X.Opens ‚Üí Prop} (S : X.Opens)\n    (hS : IsCompact S.1) (h‚ÇÅ : P ‚ä•)\n    (h‚ÇÇ : ‚àÄ (S : X.Opens) (_ : IsCompact S.1) (U : X.affineOpens), P S ‚Üí P (S ‚äî U)) :\n    P S := by\n  classical\n  obtain ‚ü®s, hs, hs'‚ü© := (isCompactOpen_iff_eq_finset_affine_union S.1).mp ‚ü®hS, S.2‚ü©\n  replace hs' : S = iSup fun i : s => (i : X.Opens) := by ext1; simpa using hs'\n  subst hs'\n  apply @Set.Finite.induction_on _ _ _ hs\n  ¬∑ convert h‚ÇÅ; rw [iSup_eq_bot]; rintro ‚ü®_, h‚ü©; exact h.elim\n  ¬∑ intro x s _ hs h‚ÇÑ\n    have : IsCompact (‚®Ü i : s, (i : X.Opens)).1 := by\n      refine ((isCompactOpen_iff_eq_finset_affine_union _).mpr ?_).1; exact ‚ü®s, hs, by simp‚ü©\n    convert h‚ÇÇ _ this x h‚ÇÑ\n    rw [iSup_subtype, sup_comm]\n    conv_rhs => rw [iSup_subtype]\n    exact iSup_insert\n\n"}
{"name":"AlgebraicGeometry.exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx f : ‚Üë(X.presheaf.obj { unop := U })\nH : Eq (TopCat.Presheaf.restrictOpen x (X.basicOpen f) ‚ãØ) 0\n‚ä¢ Exists fun n => Eq (HMul.hMul (HPow.hPow f n) x) 0","decl":"theorem exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen (X : Scheme)\n    {U : X.Opens} (hU : IsAffineOpen U) (x f : Œì(X, U))\n    (H : x |_ (X.basicOpen f) = 0) :\n    ‚àÉ n : ‚Ñï, f ^ n * x = 0 := by\n  rw [‚Üê map_zero (X.presheaf.map (homOfLE <| X.basicOpen_le f : X.basicOpen f ‚ü∂ U).op).hom] at H\n  #adaptation_note /-- nightly-2024-09-29\n  we could use dot notation here:\n  `(hU.isLocalization_basicOpen f).exists_of_eq H`\n  This is no longer possible;\n  likely changing the signature of `IsLocalization.Away.exists_of_eq` is in order.\n  -/\n  obtain ‚ü®n, e‚ü© :=\n    @IsLocalization.Away.exists_of_eq _ _ _ _ _ _ (hU.isLocalization_basicOpen f) _ _ H\n  exact ‚ü®n, by simpa [mul_comm x] using e‚ü©\n\n"}
{"name":"AlgebraicGeometry.exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact U.carrier\nx f : ‚Üë(X.presheaf.obj { unop := U })\nH : Eq (TopCat.Presheaf.restrictOpen x (X.basicOpen f) ‚ãØ) 0\n‚ä¢ Exists fun n => Eq (HMul.hMul (HPow.hPow f n) x) 0","decl":"/-- If `x : Œì(X, U)` is zero on `D(f)` for some `f : Œì(X, U)`, and `U` is quasi-compact, then\n`f ^ n * x = 0` for some `n`. -/\ntheorem exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact (X : Scheme.{u})\n    {U : X.Opens} (hU : IsCompact U.1) (x f : Œì(X, U))\n    (H : x |_ (X.basicOpen f) = 0) :\n    ‚àÉ n : ‚Ñï, f ^ n * x = 0 := by\n  obtain ‚ü®s, hs, e‚ü© := (isCompactOpen_iff_eq_finset_affine_union U.1).mp ‚ü®hU, U.2‚ü©\n  replace e : U = iSup fun i : s => (i : X.Opens) := by\n    ext1; simpa using e\n  have h‚ÇÅ : ‚àÄ i : s, i.1.1 ‚â§ U := by\n    intro i\n    change (i : X.Opens) ‚â§ U\n    rw [e]\n    -- Porting note: `exact le_iSup _ _` no longer works\n    exact le_iSup (fun (i : s) => (i : Opens (X.toPresheafedSpace))) _\n  have H' := fun i : s =>\n    exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen X i.1.2\n      (X.presheaf.map (homOfLE (h‚ÇÅ i)).op x) (X.presheaf.map (homOfLE (h‚ÇÅ i)).op f) ?_\n  swap\n  ¬∑ show (X.presheaf.map (homOfLE _).op) ((X.presheaf.map (homOfLE _).op).hom x) = 0\n    have H : (X.presheaf.map (homOfLE _).op) x = 0 := H\n    convert congr_arg (X.presheaf.map (homOfLE _).op).hom H\n    ¬∑ simp only [‚Üê CommRingCat.comp_apply, ‚Üê Functor.map_comp]\n      ¬∑ rfl\n    ¬∑ rw [map_zero]\n    ¬∑ simp only [Scheme.basicOpen_res, inf_le_right]\n  choose n hn using H'\n  haveI := hs.to_subtype\n  cases nonempty_fintype s\n  use Finset.univ.sup n\n  suffices ‚àÄ i : s, X.presheaf.map (homOfLE (h‚ÇÅ i)).op (f ^ Finset.univ.sup n * x) = 0 by\n    subst e\n    apply TopCat.Sheaf.eq_of_locally_eq X.sheaf fun i : s => (i : X.Opens)\n    intro i\n    show _ = (X.sheaf.val.map _) 0\n    rw [map_zero]\n    apply this\n  intro i\n  replace hn :=\n    congr_arg (fun x => X.presheaf.map (homOfLE (h‚ÇÅ i)).op (f ^ (Finset.univ.sup n - n i)) * x)\n      (hn i)\n  dsimp at hn\n  simp only [‚Üê map_mul, ‚Üê map_pow] at hn\n  rwa [mul_zero, ‚Üê mul_assoc, ‚Üê pow_add, tsub_add_cancel_of_le] at hn\n  apply Finset.le_sup (Finset.mem_univ i)\n\n"}
{"name":"AlgebraicGeometry.Scheme.isNilpotent_iff_basicOpen_eq_bot_of_isCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact ‚ÜëU\nf : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Iff (IsNilpotent f) (Eq (X.basicOpen f) Bot.bot)","decl":"/-- A section over a compact open of a scheme is nilpotent if and only if its associated\nbasic open is empty. -/\nlemma Scheme.isNilpotent_iff_basicOpen_eq_bot_of_isCompact {X : Scheme.{u}}\n    {U : X.Opens} (hU : IsCompact (U : Set X)) (f : Œì(X, U)) :\n    IsNilpotent f ‚Üî X.basicOpen f = ‚ä• := by\n  refine ‚ü®X.basicOpen_eq_bot_of_isNilpotent U f, fun hf ‚Ü¶ ?_‚ü©\n  have h : (1 : Œì(X, U)) |_ (X.basicOpen f) = 0 := by\n    have e : X.basicOpen f ‚â§ ‚ä• := by rw [hf]\n    rw [‚Üê TopCat.Presheaf.restrict_restrict e bot_le]\n    have : Subsingleton Œì(X, ‚ä•) :=\n      CommRingCat.subsingleton_of_isTerminal X.sheaf.isTerminalOfEmpty\n    rw [Subsingleton.eq_zero (1 |_ ‚ä•)]\n    show X.presheaf.map _ 0 = 0\n    rw [map_zero]\n  obtain ‚ü®n, hn‚ü© := exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact X hU 1 f h\n  rw [mul_one] at hn\n  use n\n\n"}
{"name":"AlgebraicGeometry.Scheme.isNilpotent_iff_basicOpen_eq_bot","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : CompactSpace ‚Üë‚ÜëX.toPresheafedSpace\nf : ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Iff (IsNilpotent f) (Eq (X.basicOpen f) Bot.bot)","decl":"/-- A global section of a quasi-compact scheme is nilpotent if and only if its associated\nbasic open is empty. -/\nlemma Scheme.isNilpotent_iff_basicOpen_eq_bot {X : Scheme.{u}}\n    [CompactSpace X] (f : Œì(X, ‚ä§)) :\n    IsNilpotent f ‚Üî X.basicOpen f = ‚ä• :=\n  isNilpotent_iff_basicOpen_eq_bot_of_isCompact (U := ‚ä§) (CompactSpace.isCompact_univ) f\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_eq_top_iff_subset_nilradical_of_isCompact","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : IsCompact ‚ÜëU\ns : Set ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Iff (Eq (X.zeroLocus s) Top.top) (HasSubset.Subset s ‚Üë(nilradical ‚Üë(X.presheaf.obj { unop := U })))","decl":"/-- The zero locus of a set of sections over a compact open of a scheme is `X` if and only if\n`s` is contained in the nilradical of `Œì(X, U)`. -/\nlemma Scheme.zeroLocus_eq_top_iff_subset_nilradical_of_isCompact {X : Scheme.{u}} {U : X.Opens}\n    (hU : IsCompact (U : Set X)) (s : Set Œì(X, U)) :\n    X.zeroLocus s = ‚ä§ ‚Üî s ‚äÜ nilradical Œì(X, U) := by\n  simp [Scheme.zeroLocus_def, ‚Üê Scheme.isNilpotent_iff_basicOpen_eq_bot_of_isCompact hU,\n    ‚Üê mem_nilradical, Set.subset_def]\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_eq_top_iff_subset_nilradical","module":"Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : CompactSpace ‚Üë‚ÜëX.toPresheafedSpace\ns : Set ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ Iff (Eq (X.zeroLocus s) Top.top) (HasSubset.Subset s ‚Üë(nilradical ‚Üë(X.presheaf.obj { unop := Top.top })))","decl":"/-- The zero locus of a set of sections over a compact open of a scheme is `X` if and only if\n`s` is contained in the nilradical of `Œì(X, U)`. -/\nlemma Scheme.zeroLocus_eq_top_iff_subset_nilradical {X : Scheme.{u}}\n    [CompactSpace X] (s : Set Œì(X, ‚ä§)) :\n    X.zeroLocus s = ‚ä§ ‚Üî s ‚äÜ nilradical Œì(X, ‚ä§) :=\n  zeroLocus_eq_top_iff_subset_nilradical_of_isCompact (U := ‚ä§) (CompactSpace.isCompact_univ) s\n\n"}
