{"name":"SimpleGraph.IsUniform.mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nε' : 𝕜\nh : LE.le ε ε'\nhε : G.IsUniform ε s t\n⊢ G.IsUniform ε' s t","decl":"theorem IsUniform.mono {ε' : 𝕜} (h : ε ≤ ε') (hε : IsUniform G ε s t) : IsUniform G ε' s t :=\n  fun s' hs' t' ht' hs ht => by\n  refine (hε hs' ht' (le_trans ?_ hs) (le_trans ?_ ht)).trans_le h <;> gcongr\n\n"}
{"name":"SimpleGraph.IsUniform.symm","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\n⊢ Symmetric (G.IsUniform ε)","decl":"theorem IsUniform.symm : Symmetric (IsUniform G ε) := fun s t h t' ht' s' hs' ht hs => by\n  rw [edgeDensity_comm _ t', edgeDensity_comm _ t]\n  exact h hs' ht' hs ht\n\n"}
{"name":"SimpleGraph.isUniform_comm","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\n⊢ Iff (G.IsUniform ε s t) (G.IsUniform ε t s)","decl":"theorem isUniform_comm : IsUniform G ε s t ↔ IsUniform G ε t s :=\n  ⟨fun h => h.symm, fun h => h.symm⟩\n\n"}
{"name":"SimpleGraph.isUniform_one","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\ns t : Finset α\n⊢ G.IsUniform 1 s t","decl":"lemma isUniform_one : G.IsUniform (1 : 𝕜) s t := by\n  intro s' hs' t' ht' hs ht\n  rw [mul_one] at hs ht\n  rw [eq_of_subset_of_card_le hs' (Nat.cast_le.1 hs),\n    eq_of_subset_of_card_le ht' (Nat.cast_le.1 ht), sub_self, abs_zero]\n  exact zero_lt_one\n\n"}
{"name":"SimpleGraph.IsUniform.pos","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nhG : G.IsUniform ε s t\n⊢ LT.lt 0 ε","decl":"lemma IsUniform.pos (hG : G.IsUniform ε s t) : 0 < ε :=\n  not_le.1 fun hε ↦ (hε.trans <| abs_nonneg _).not_lt <| hG (empty_subset _) (empty_subset _)\n    (by simpa using mul_nonpos_of_nonneg_of_nonpos (Nat.cast_nonneg _) hε)\n    (by simpa using mul_nonpos_of_nonneg_of_nonpos (Nat.cast_nonneg _) hε)\n\n"}
{"name":"SimpleGraph.isUniform_singleton","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\na b : α\n⊢ Iff (G.IsUniform ε (Singleton.singleton a) (Singleton.singleton b)) (LT.lt 0 ε)","decl":"@[simp] lemma isUniform_singleton : G.IsUniform ε {a} {b} ↔ 0 < ε := by\n  refine ⟨IsUniform.pos, fun hε s' hs' t' ht' hs ht ↦ ?_⟩\n  rw [card_singleton, Nat.cast_one, one_mul] at hs ht\n  obtain rfl | rfl := Finset.subset_singleton_iff.1 hs'\n  · replace hs : ε ≤ 0 := by simpa using hs\n    exact (hε.not_le hs).elim\n  obtain rfl | rfl := Finset.subset_singleton_iff.1 ht'\n  · replace ht : ε ≤ 0 := by simpa using ht\n    exact (hε.not_le ht).elim\n  · rwa [sub_self, abs_zero]\n\n"}
{"name":"SimpleGraph.not_isUniform_zero","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\ns t : Finset α\n⊢ Not (G.IsUniform 0 s t)","decl":"theorem not_isUniform_zero : ¬G.IsUniform (0 : 𝕜) s t := fun h =>\n  (abs_nonneg _).not_lt <| h (empty_subset _) (empty_subset _) (by simp) (by simp)\n\n"}
{"name":"SimpleGraph.not_isUniform_iff","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\n⊢ Iff (Not (G.IsUniform ε s t)) (Exists fun s' => And (HasSubset.Subset s' s) (Exists fun t' => And (HasSubset.Subset t' t) (And (LE.le (HMul.hMul (↑s.card) ε) ↑s'.card) (And (LE.le (HMul.hMul (↑t.card) ε) ↑t'.card) (LE.le ε ↑(abs (HSub.hSub (G.edgeDensity s' t') (G.edgeDensity s t))))))))","decl":"theorem not_isUniform_iff :\n    ¬G.IsUniform ε s t ↔ ∃ s', s' ⊆ s ∧ ∃ t', t' ⊆ t ∧ #s * ε ≤ #s' ∧\n      #t * ε ≤ #t' ∧ ε ≤ |G.edgeDensity s' t' - G.edgeDensity s t| := by\n  unfold IsUniform\n  simp only [not_forall, not_lt, exists_prop, exists_and_left, Rat.cast_abs, Rat.cast_sub]\n\n"}
{"name":"SimpleGraph.left_nonuniformWitnesses_subset","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nh : Not (G.IsUniform ε s t)\n⊢ HasSubset.Subset (G.nonuniformWitnesses ε s t).1 s","decl":"theorem left_nonuniformWitnesses_subset (h : ¬G.IsUniform ε s t) :\n    (G.nonuniformWitnesses ε s t).1 ⊆ s := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.1\n\n"}
{"name":"SimpleGraph.left_nonuniformWitnesses_card","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nh : Not (G.IsUniform ε s t)\n⊢ LE.le (HMul.hMul (↑s.card) ε) ↑(G.nonuniformWitnesses ε s t).1.card","decl":"theorem left_nonuniformWitnesses_card (h : ¬G.IsUniform ε s t) :\n    #s * ε ≤ #(G.nonuniformWitnesses ε s t).1 := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.2.choose_spec.2.1\n\n"}
{"name":"SimpleGraph.right_nonuniformWitnesses_subset","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nh : Not (G.IsUniform ε s t)\n⊢ HasSubset.Subset (G.nonuniformWitnesses ε s t).2 t","decl":"theorem right_nonuniformWitnesses_subset (h : ¬G.IsUniform ε s t) :\n    (G.nonuniformWitnesses ε s t).2 ⊆ t := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.2.choose_spec.1\n\n"}
{"name":"SimpleGraph.right_nonuniformWitnesses_card","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nh : Not (G.IsUniform ε s t)\n⊢ LE.le (HMul.hMul (↑t.card) ε) ↑(G.nonuniformWitnesses ε s t).2.card","decl":"theorem right_nonuniformWitnesses_card (h : ¬G.IsUniform ε s t) :\n    #t * ε ≤ #(G.nonuniformWitnesses ε s t).2 := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.2.choose_spec.2.2.1\n\n"}
{"name":"SimpleGraph.nonuniformWitnesses_spec","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nh : Not (G.IsUniform ε s t)\n⊢ LE.le ε ↑(abs (HSub.hSub (G.edgeDensity (G.nonuniformWitnesses ε s t).1 (G.nonuniformWitnesses ε s t).2) (G.edgeDensity s t)))","decl":"theorem nonuniformWitnesses_spec (h : ¬G.IsUniform ε s t) :\n    ε ≤\n      |G.edgeDensity (G.nonuniformWitnesses ε s t).1 (G.nonuniformWitnesses ε s t).2 -\n          G.edgeDensity s t| := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.2.choose_spec.2.2.2\n\n"}
{"name":"SimpleGraph.nonuniformWitness_subset","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nh : Not (G.IsUniform ε s t)\n⊢ HasSubset.Subset (G.nonuniformWitness ε s t) s","decl":"theorem nonuniformWitness_subset (h : ¬G.IsUniform ε s t) : G.nonuniformWitness ε s t ⊆ s := by\n  unfold nonuniformWitness\n  split_ifs\n  · exact G.left_nonuniformWitnesses_subset h\n  · exact G.right_nonuniformWitnesses_subset fun i => h i.symm\n\n"}
{"name":"SimpleGraph.le_card_nonuniformWitness","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nh : Not (G.IsUniform ε s t)\n⊢ LE.le (HMul.hMul (↑s.card) ε) ↑(G.nonuniformWitness ε s t).card","decl":"theorem le_card_nonuniformWitness (h : ¬G.IsUniform ε s t) :\n    #s * ε ≤ #(G.nonuniformWitness ε s t) := by\n  unfold nonuniformWitness\n  split_ifs\n  · exact G.left_nonuniformWitnesses_card h\n  · exact G.right_nonuniformWitnesses_card fun i => h i.symm\n\n"}
{"name":"SimpleGraph.nonuniformWitness_spec","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nh₁ : Ne s t\nh₂ : Not (G.IsUniform ε s t)\n⊢ LE.le ε ↑(abs (HSub.hSub (G.edgeDensity (G.nonuniformWitness ε s t) (G.nonuniformWitness ε t s)) (G.edgeDensity s t)))","decl":"theorem nonuniformWitness_spec (h₁ : s ≠ t) (h₂ : ¬G.IsUniform ε s t) : ε ≤ |G.edgeDensity\n    (G.nonuniformWitness ε s t) (G.nonuniformWitness ε t s) - G.edgeDensity s t| := by\n  unfold nonuniformWitness\n  rcases trichotomous_of WellOrderingRel s t with (lt | rfl | gt)\n  · rw [if_pos lt, if_neg (asymm lt)]\n    exact G.nonuniformWitnesses_spec h₂\n  · cases h₁ rfl\n  · rw [if_neg (asymm gt), if_pos gt, edgeDensity_comm, edgeDensity_comm _ s]\n    apply G.nonuniformWitnesses_spec fun i => h₂ i.symm\n\n"}
{"name":"Finpartition.mk_mem_sparsePairs","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nu v : Finset α\nε : 𝕜\n⊢ Iff (Membership.mem (P.sparsePairs G ε) { fst := u, snd := v }) (And (Membership.mem P.parts u) (And (Membership.mem P.parts v) (And (Ne u v) (LT.lt (↑(G.edgeDensity u v)) ε))))","decl":"@[simp]\nlemma mk_mem_sparsePairs (u v : Finset α) (ε : 𝕜) :\n    (u, v) ∈ P.sparsePairs G ε ↔ u ∈ P.parts ∧ v ∈ P.parts ∧ u ≠ v ∧ G.edgeDensity u v < ε := by\n  rw [sparsePairs, mem_filter, mem_offDiag, and_assoc, and_assoc]\n\n"}
{"name":"Finpartition.sparsePairs_mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε ε' : 𝕜\nh : LE.le ε ε'\n⊢ HasSubset.Subset (P.sparsePairs G ε) (P.sparsePairs G ε')","decl":"lemma sparsePairs_mono {ε ε' : 𝕜} (h : ε ≤ ε') : P.sparsePairs G ε ⊆ P.sparsePairs G ε' :=\n  monotone_filter_right _ fun _ ↦ h.trans_lt'\n\n"}
{"name":"Finpartition.mk_mem_nonUniforms","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\nu v : Finset α\n⊢ Iff (Membership.mem (P.nonUniforms G ε) { fst := u, snd := v }) (And (Membership.mem P.parts u) (And (Membership.mem P.parts v) (And (Ne u v) (Not (G.IsUniform ε u v)))))","decl":"@[simp] lemma mk_mem_nonUniforms :\n    (u, v) ∈ P.nonUniforms G ε ↔ u ∈ P.parts ∧ v ∈ P.parts ∧ u ≠ v ∧ ¬G.IsUniform ε u v := by\n  rw [nonUniforms, mem_filter, mem_offDiag, and_assoc, and_assoc]\n\n"}
{"name":"Finpartition.nonUniforms_mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε ε' : 𝕜\nh : LE.le ε ε'\n⊢ HasSubset.Subset (P.nonUniforms G ε') (P.nonUniforms G ε)","decl":"theorem nonUniforms_mono {ε ε' : 𝕜} (h : ε ≤ ε') : P.nonUniforms G ε' ⊆ P.nonUniforms G ε :=\n  monotone_filter_right _ fun _ => mt <| SimpleGraph.IsUniform.mono h\n\n"}
{"name":"Finpartition.nonUniforms_bot","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\nhε : LT.lt 0 ε\n⊢ Eq (Bot.bot.nonUniforms G ε) EmptyCollection.emptyCollection","decl":"theorem nonUniforms_bot (hε : 0 < ε) : (⊥ : Finpartition A).nonUniforms G ε = ∅ := by\n  rw [eq_empty_iff_forall_not_mem]\n  rintro ⟨u, v⟩\n  simp only [mk_mem_nonUniforms, parts_bot, mem_map, not_and,\n    Classical.not_not, exists_imp]; dsimp\n  rintro x ⟨_, rfl⟩ y ⟨_,rfl⟩ _\n  rwa [SimpleGraph.isUniform_singleton]\n\n"}
{"name":"Finpartition.bot_isUniform","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\nhε : LT.lt 0 ε\n⊢ Bot.bot.IsUniform G ε","decl":"lemma bot_isUniform (hε : 0 < ε) : (⊥ : Finpartition A).IsUniform G ε := by\n  rw [Finpartition.IsUniform, Finpartition.card_bot, nonUniforms_bot _ hε, Finset.card_empty,\n    Nat.cast_zero]\n  exact mul_nonneg (Nat.cast_nonneg _) hε.le\n\n"}
{"name":"Finpartition.isUniform_one","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\n⊢ P.IsUniform G 1","decl":"lemma isUniform_one : P.IsUniform G (1 : 𝕜) := by\n  rw [IsUniform, mul_one, Nat.cast_le]\n  refine (card_filter_le _\n    (fun uv => ¬SimpleGraph.IsUniform G 1 (Prod.fst uv) (Prod.snd uv))).trans ?_\n  rw [offDiag_card, Nat.mul_sub_left_distrib, mul_one]\n\n"}
{"name":"Finpartition.IsUniform.mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε ε' : 𝕜\nhP : P.IsUniform G ε\nh : LE.le ε ε'\n⊢ P.IsUniform G ε'","decl":"theorem IsUniform.mono {ε ε' : 𝕜} (hP : P.IsUniform G ε) (h : ε ≤ ε') : P.IsUniform G ε' :=\n  ((Nat.cast_le.2 <| card_le_card <| P.nonUniforms_mono G h).trans hP).trans <| by gcongr\n\n"}
{"name":"Finpartition.isUniformOfEmpty","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\nhP : Eq P.parts EmptyCollection.emptyCollection\n⊢ P.IsUniform G ε","decl":"theorem isUniformOfEmpty (hP : P.parts = ∅) : P.IsUniform G ε := by\n  simp [IsUniform, hP, nonUniforms]\n\n"}
{"name":"Finpartition.nonempty_of_not_uniform","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\nh : Not (P.IsUniform G ε)\n⊢ P.parts.Nonempty","decl":"theorem nonempty_of_not_uniform (h : ¬P.IsUniform G ε) : P.parts.Nonempty :=\n  nonempty_of_ne_empty fun h₁ => h <| isUniformOfEmpty h₁\n\n"}
{"name":"Finpartition.nonuniformWitness_mem_nonuniformWitnesses","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\ns t : Finset α\nh : Not (G.IsUniform ε s t)\nht : Membership.mem P.parts t\nhst : Ne s t\n⊢ Membership.mem (P.nonuniformWitnesses G ε s) (G.nonuniformWitness ε s t)","decl":"theorem nonuniformWitness_mem_nonuniformWitnesses (h : ¬G.IsUniform ε s t) (ht : t ∈ P.parts)\n    (hst : s ≠ t) : G.nonuniformWitness ε s t ∈ P.nonuniformWitnesses G ε s :=\n  mem_image_of_mem _ <| mem_filter.2 ⟨ht, hst, h⟩\n\n"}
{"name":"Finpartition.IsEquipartition.card_interedges_sparsePairs_le'","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\nhP : P.IsEquipartition\nhε : LE.le 0 ε\n⊢ LE.le (↑((P.sparsePairs G ε).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod α α)) x fun U V => G.interedges U V).card) (HMul.hMul ε (HPow.hPow (HAdd.hAdd ↑A.card ↑P.parts.card) 2))","decl":"open SimpleGraph in\nlemma IsEquipartition.card_interedges_sparsePairs_le' (hP : P.IsEquipartition)\n    (hε : 0 ≤ ε) :\n    #((P.sparsePairs G ε).biUnion fun (U, V) ↦ G.interedges U V) ≤ ε * (#A + #P.parts) ^ 2 := by\n  calc\n    _ ≤ ∑ UV ∈ P.sparsePairs G ε, (#(G.interedges UV.1 UV.2) : 𝕜) := mod_cast card_biUnion_le\n    _ ≤ ∑ UV ∈ P.sparsePairs G ε, ε * (#UV.1 * #UV.2) := ?_\n    _ ≤ _ := sum_le_sum_of_subset_of_nonneg (filter_subset _ _) fun i _ _ ↦ by positivity\n    _ = _ := (mul_sum _ _ _).symm\n    _ ≤ _ := mul_le_mul_of_nonneg_left ?_ hε\n  · gcongr with UV hUV\n    obtain ⟨U, V⟩ := UV\n    simp [mk_mem_sparsePairs, ← card_interedges_div_card] at hUV\n    refine ((div_lt_iff₀ ?_).1 hUV.2.2.2).le\n    exact mul_pos (Nat.cast_pos.2 (P.nonempty_of_mem_parts hUV.1).card_pos)\n      (Nat.cast_pos.2 (P.nonempty_of_mem_parts hUV.2.1).card_pos)\n  norm_cast\n  calc\n    (_ : ℕ) ≤ _ := sum_le_card_nsmul P.parts.offDiag (fun i ↦ #i.1 * #i.2)\n            ((#A / #P.parts + 1)^2 : ℕ) ?_\n    _ ≤ (#P.parts * (#A / #P.parts) + #P.parts) ^ 2 := ?_\n    _ ≤ _ := Nat.pow_le_pow_of_le_left (add_le_add_right (Nat.mul_div_le _ _) _) _\n  · simp only [Prod.forall, Finpartition.mk_mem_nonUniforms, and_imp, mem_offDiag, sq]\n    rintro U V hU hV -\n    exact_mod_cast Nat.mul_le_mul (hP.card_part_le_average_add_one hU)\n      (hP.card_part_le_average_add_one hV)\n  · rw [smul_eq_mul, offDiag_card, Nat.mul_sub_right_distrib, ← sq, ← mul_pow, mul_add_one (α := ℕ)]\n    exact Nat.sub_le _ _\n\n"}
{"name":"Finpartition.IsEquipartition.card_interedges_sparsePairs_le","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\nhP : P.IsEquipartition\nhε : LE.le 0 ε\n⊢ LE.le (↑((P.sparsePairs G ε).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod α α)) x fun U V => G.interedges U V).card) (HMul.hMul (HMul.hMul 4 ε) (HPow.hPow (↑A.card) 2))","decl":"lemma IsEquipartition.card_interedges_sparsePairs_le (hP : P.IsEquipartition) (hε : 0 ≤ ε) :\n    #((P.sparsePairs G ε).biUnion fun (U, V) ↦ G.interedges U V) ≤ 4 * ε * #A ^ 2 := by\n  calc\n    _ ≤ _ := hP.card_interedges_sparsePairs_le' hε\n    _ ≤ ε * (#A + #A)^2 := by gcongr; exact P.card_parts_le_card\n    _ = _ := by ring\n\n"}
{"name":"Finpartition.IsEquipartition.card_biUnion_offDiag_le'","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\ninst✝ : DecidableEq α\nA : Finset α\nP : Finpartition A\nhP : P.IsEquipartition\n⊢ LE.le (↑(P.parts.biUnion Finset.offDiag).card) (HDiv.hDiv (HMul.hMul (↑A.card) (HAdd.hAdd ↑A.card ↑P.parts.card)) ↑P.parts.card)","decl":"lemma IsEquipartition.card_biUnion_offDiag_le' (hP : P.IsEquipartition) :\n    (#(P.parts.biUnion offDiag) : 𝕜) ≤ #A * (#A + #P.parts) / #P.parts := by\n  obtain h | h := P.parts.eq_empty_or_nonempty\n  · simp [h]\n  calc\n    _ ≤ (#P.parts : 𝕜) * (↑(#A / #P.parts) * ↑(#A / #P.parts + 1)) :=\n        mod_cast card_biUnion_le_card_mul _ _ _ fun U hU ↦ ?_\n    _ = #P.parts * ↑(#A / #P.parts) * ↑(#A / #P.parts + 1) := by rw [mul_assoc]\n    _ ≤ #A * (#A / #P.parts + 1) :=\n        mul_le_mul (mod_cast Nat.mul_div_le _ _) ?_ (by positivity) (by positivity)\n    _ = _ := by rw [← div_add_same (mod_cast h.card_pos.ne'), mul_div_assoc]\n  · simpa using Nat.cast_div_le\n  suffices (#U - 1) * #U ≤ #A / #P.parts * (#A / #P.parts + 1) by\n    rwa [Nat.mul_sub_right_distrib, one_mul, ← offDiag_card] at this\n  have := hP.card_part_le_average_add_one hU\n  refine Nat.mul_le_mul ((Nat.sub_le_sub_right this 1).trans ?_) this\n  simp only [Nat.add_succ_sub_one, add_zero, card_univ, le_rfl]\n\n"}
{"name":"Finpartition.IsEquipartition.card_biUnion_offDiag_le","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝¹ : LinearOrderedField 𝕜\ninst✝ : DecidableEq α\nA : Finset α\nP : Finpartition A\nε : 𝕜\nhε : LT.lt 0 ε\nhP : P.IsEquipartition\nhP' : LE.le (HDiv.hDiv 4 ε) ↑P.parts.card\n⊢ LE.le (↑(P.parts.biUnion Finset.offDiag).card) (HMul.hMul (HDiv.hDiv ε 2) (HPow.hPow (↑A.card) 2))","decl":"lemma IsEquipartition.card_biUnion_offDiag_le (hε : 0 < ε) (hP : P.IsEquipartition)\n    (hP' : 4 / ε ≤ #P.parts) : #(P.parts.biUnion offDiag) ≤ ε / 2 * #A ^ 2 := by\n  obtain rfl | hA : A = ⊥ ∨ _ := A.eq_empty_or_nonempty\n  · simp [Subsingleton.elim P ⊥]\n  apply hP.card_biUnion_offDiag_le'.trans\n  rw [div_le_iff₀ (Nat.cast_pos.2 (P.parts_nonempty hA.ne_empty).card_pos)]\n  have : (#A : 𝕜) + #P.parts ≤ 2 * #A := by\n    rw [two_mul]; exact add_le_add_left (Nat.cast_le.2 P.card_parts_le_card) _\n  refine (mul_le_mul_of_nonneg_left this <| by positivity).trans ?_\n  suffices 1 ≤ ε/4 * #P.parts by\n    rw [mul_left_comm, ← sq]\n    convert mul_le_mul_of_nonneg_left this (mul_nonneg zero_le_two <| sq_nonneg (#A : 𝕜))\n      using 1 <;> ring\n  rwa [← div_le_iff₀', one_div_div]\n  positivity\n\n"}
{"name":"Finpartition.IsEquipartition.sum_nonUniforms_lt'","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\nhA : A.Nonempty\nhε : LT.lt 0 ε\nhP : P.IsEquipartition\nhG : P.IsUniform G ε\n⊢ LT.lt ((P.nonUniforms G ε).sum fun i => HMul.hMul ↑i.1.card ↑i.2.card) (HMul.hMul ε (HPow.hPow (HAdd.hAdd ↑A.card ↑P.parts.card) 2))","decl":"lemma IsEquipartition.sum_nonUniforms_lt' (hA : A.Nonempty) (hε : 0 < ε) (hP : P.IsEquipartition)\n    (hG : P.IsUniform G ε) :\n    ∑ i ∈ P.nonUniforms G ε, (#i.1 * #i.2 : 𝕜) < ε * (#A + #P.parts) ^ 2 := by\n  calc\n    _ ≤ #(P.nonUniforms G ε) • (↑(#A / #P.parts + 1) : 𝕜) ^ 2 :=\n      sum_le_card_nsmul _ _ _ ?_\n    _ = _ := nsmul_eq_mul _ _\n    _ ≤ _ := mul_le_mul_of_nonneg_right hG <| by positivity\n    _ < _ := ?_\n  · simp only [Prod.forall, Finpartition.mk_mem_nonUniforms, and_imp]\n    rintro U V hU hV - -\n    rw [sq, ← Nat.cast_mul, ← Nat.cast_mul, Nat.cast_le]\n    exact Nat.mul_le_mul (hP.card_part_le_average_add_one hU)\n      (hP.card_part_le_average_add_one hV)\n  · rw [mul_right_comm _ ε, mul_comm ε]\n    apply mul_lt_mul_of_pos_right _ hε\n    norm_cast\n    exact aux (P.parts_nonempty hA.ne_empty).card_pos\n\n"}
{"name":"Finpartition.IsEquipartition.sum_nonUniforms_lt","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\nhA : A.Nonempty\nhε : LT.lt 0 ε\nhP : P.IsEquipartition\nhG : P.IsUniform G ε\n⊢ LT.lt (↑((P.nonUniforms G ε).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod α α)) x fun U V => SProd.sprod U V).card) (HMul.hMul (HMul.hMul 4 ε) (HPow.hPow (↑A.card) 2))","decl":"lemma IsEquipartition.sum_nonUniforms_lt (hA : A.Nonempty) (hε : 0 < ε) (hP : P.IsEquipartition)\n    (hG : P.IsUniform G ε) :\n    #((P.nonUniforms G ε).biUnion fun (U, V) ↦ U ×ˢ V) < 4 * ε * #A ^ 2 := by\n  calc\n    _ ≤ ∑ i ∈ P.nonUniforms G ε, (#i.1 * #i.2 : 𝕜) := by\n        norm_cast; simp_rw [← card_product]; exact card_biUnion_le\n    _ < _ := hP.sum_nonUniforms_lt' hA hε hG\n    _ ≤ ε * (#A + #A) ^ 2 := by gcongr; exact P.card_parts_le_card\n    _ = _ := by ring\n\n"}
{"name":"SimpleGraph.regularityReduced_adj","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε δ : 𝕜\na b : α\n⊢ Eq ((SimpleGraph.regularityReduced P G ε δ).Adj a b) (And (G.Adj a b) (Exists fun U => And (Membership.mem P.parts U) (Exists fun V => And (Membership.mem P.parts V) (And (Membership.mem U a) (And (Membership.mem V b) (And (Ne U V) (And (G.IsUniform ε U V) (LE.le δ ↑(G.edgeDensity U V)))))))))","decl":"/-- The reduction of the graph `G` along partition `P` has edges between `ε`-uniform pairs of parts\nthat have edge density at least `δ`. -/\n@[simps] def regularityReduced (ε δ : 𝕜) : SimpleGraph α where\n  Adj a b := G.Adj a b ∧\n    ∃ U ∈ P.parts, ∃ V ∈ P.parts, a ∈ U ∧ b ∈ V ∧ U ≠ V ∧ G.IsUniform ε U V ∧ δ ≤ G.edgeDensity U V\n  symm a b := by\n    rintro ⟨ab, U, UP, V, VP, xU, yV, UV, GUV, εUV⟩\n    refine ⟨G.symm ab, V, VP, U, UP, yV, xU, UV.symm, GUV.symm, ?_⟩\n    rwa [edgeDensity_comm]\n  loopless a h := G.loopless a h.1\n\n"}
{"name":"SimpleGraph.regularityReduced_le","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε δ : 𝕜\n⊢ LE.le (SimpleGraph.regularityReduced P G ε δ) G","decl":"lemma regularityReduced_le : G.regularityReduced P ε δ ≤ G := fun _ _ ↦ And.left\n\n"}
{"name":"SimpleGraph.regularityReduced_mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nδ ε₁ ε₂ : 𝕜\nhε : LE.le ε₁ ε₂\n⊢ LE.le (SimpleGraph.regularityReduced P G ε₁ δ) (SimpleGraph.regularityReduced P G ε₂ δ)","decl":"lemma regularityReduced_mono {ε₁ ε₂ : 𝕜} (hε : ε₁ ≤ ε₂) :\n    G.regularityReduced P ε₁ δ ≤ G.regularityReduced P ε₂ δ :=\n  fun _a _b ⟨hab, U, hU, V, hV, ha, hb, hUV, hGε, hGδ⟩ ↦\n    ⟨hab, U, hU, V, hV, ha, hb, hUV, hGε.mono hε, hGδ⟩\n\n"}
{"name":"SimpleGraph.regularityReduced_anti","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε δ₁ δ₂ : 𝕜\nhδ : LE.le δ₁ δ₂\n⊢ LE.le (SimpleGraph.regularityReduced P G ε δ₂) (SimpleGraph.regularityReduced P G ε δ₁)","decl":"lemma regularityReduced_anti {δ₁ δ₂ : 𝕜} (hδ : δ₁ ≤ δ₂) :\n    G.regularityReduced P ε δ₂ ≤ G.regularityReduced P ε δ₁ :=\n  fun _a _b ⟨hab, U, hU, V, hV, ha, hb, hUV, hUVε, hUVδ⟩ ↦\n    ⟨hab, U, hU, V, hV, ha, hb, hUV, hUVε, hδ.trans hUVδ⟩\n\n"}
{"name":"SimpleGraph.unreduced_edges_subset","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : DecidableEq α\nA : Finset α\nP : Finpartition A\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : 𝕜\n⊢ HasSubset.Subset (Finset.filter (fun x => SimpleGraph.unreduced_edges_subset.match_1 (fun x => Prop) x fun x y => And (G.Adj x y) (Not ((SimpleGraph.regularityReduced P G (HDiv.hDiv ε 8) (HDiv.hDiv ε 4)).Adj x y))) (SProd.sprod A A)) (Union.union (Union.union ((P.nonUniforms G (HDiv.hDiv ε 8)).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod α α)) x fun U V => SProd.sprod U V) (P.parts.biUnion Finset.offDiag)) ((P.sparsePairs G (HDiv.hDiv ε 4)).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod α α)) x fun U V => G.interedges U V))","decl":"lemma unreduced_edges_subset :\n    (A ×ˢ A).filter (fun (x, y) ↦ G.Adj x y ∧ ¬ (G.regularityReduced P (ε/8) (ε/4)).Adj x y) ⊆\n      (P.nonUniforms G (ε/8)).biUnion (fun (U, V) ↦ U ×ˢ V) ∪ P.parts.biUnion offDiag ∪\n        (P.sparsePairs G (ε/4)).biUnion fun (U, V) ↦ G.interedges U V := by\n  rintro ⟨x, y⟩\n  simp only [mem_sdiff, mem_filter, mem_univ, true_and, regularityReduced_adj, not_and, not_exists,\n    not_le, mem_biUnion, mem_union, exists_prop, mem_product, Prod.exists, mem_offDiag, and_imp,\n    or_assoc, and_assoc, P.mk_mem_nonUniforms, Finpartition.mk_mem_sparsePairs, mem_interedges_iff]\n  intros hx hy h h'\n  replace h' := h' h\n  obtain ⟨U, hU, hx⟩ := P.exists_mem hx\n  obtain ⟨V, hV, hy⟩ := P.exists_mem hy\n  obtain rfl | hUV := eq_or_ne U V\n  · exact Or.inr (Or.inl ⟨U, hU, hx, hy, G.ne_of_adj h⟩)\n  by_cases h₂ : G.IsUniform (ε/8) U V\n  · exact Or.inr <| Or.inr ⟨U, V, hU, hV, hUV, h' _ hU _ hV hx hy hUV h₂, hx, hy, h⟩\n  · exact Or.inl ⟨U, V, hU, hV, hUV, h₂, hx, hy⟩\n\n"}
