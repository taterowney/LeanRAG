{"name":"SimpleGraph.IsUniform.mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nÎµ' : ğ•œ\nh : LE.le Îµ Îµ'\nhÎµ : G.IsUniform Îµ s t\nâŠ¢ G.IsUniform Îµ' s t","decl":"theorem IsUniform.mono {Îµ' : ğ•œ} (h : Îµ â‰¤ Îµ') (hÎµ : IsUniform G Îµ s t) : IsUniform G Îµ' s t :=\n  fun s' hs' t' ht' hs ht => by\n  refine (hÎµ hs' ht' (le_trans ?_ hs) (le_trans ?_ ht)).trans_le h <;> gcongr\n\n"}
{"name":"SimpleGraph.IsUniform.symm","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nâŠ¢ Symmetric (G.IsUniform Îµ)","decl":"theorem IsUniform.symm : Symmetric (IsUniform G Îµ) := fun s t h t' ht' s' hs' ht hs => by\n  rw [edgeDensity_comm _ t', edgeDensity_comm _ t]\n  exact h hs' ht' hs ht\n\n"}
{"name":"SimpleGraph.isUniform_comm","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nâŠ¢ Iff (G.IsUniform Îµ s t) (G.IsUniform Îµ t s)","decl":"theorem isUniform_comm : IsUniform G Îµ s t â†” IsUniform G Îµ t s :=\n  âŸ¨fun h => h.symm, fun h => h.symmâŸ©\n\n"}
{"name":"SimpleGraph.isUniform_one","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\ns t : Finset Î±\nâŠ¢ G.IsUniform 1 s t","decl":"lemma isUniform_one : G.IsUniform (1 : ğ•œ) s t := by\n  intro s' hs' t' ht' hs ht\n  rw [mul_one] at hs ht\n  rw [eq_of_subset_of_card_le hs' (Nat.cast_le.1 hs),\n    eq_of_subset_of_card_le ht' (Nat.cast_le.1 ht), sub_self, abs_zero]\n  exact zero_lt_one\n\n"}
{"name":"SimpleGraph.IsUniform.pos","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nhG : G.IsUniform Îµ s t\nâŠ¢ LT.lt 0 Îµ","decl":"lemma IsUniform.pos (hG : G.IsUniform Îµ s t) : 0 < Îµ :=\n  not_le.1 fun hÎµ â†¦ (hÎµ.trans <| abs_nonneg _).not_lt <| hG (empty_subset _) (empty_subset _)\n    (by simpa using mul_nonpos_of_nonneg_of_nonpos (Nat.cast_nonneg _) hÎµ)\n    (by simpa using mul_nonpos_of_nonneg_of_nonpos (Nat.cast_nonneg _) hÎµ)\n\n"}
{"name":"SimpleGraph.isUniform_singleton","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\na b : Î±\nâŠ¢ Iff (G.IsUniform Îµ (Singleton.singleton a) (Singleton.singleton b)) (LT.lt 0 Îµ)","decl":"@[simp] lemma isUniform_singleton : G.IsUniform Îµ {a} {b} â†” 0 < Îµ := by\n  refine âŸ¨IsUniform.pos, fun hÎµ s' hs' t' ht' hs ht â†¦ ?_âŸ©\n  rw [card_singleton, Nat.cast_one, one_mul] at hs ht\n  obtain rfl | rfl := Finset.subset_singleton_iff.1 hs'\n  Â· replace hs : Îµ â‰¤ 0 := by simpa using hs\n    exact (hÎµ.not_le hs).elim\n  obtain rfl | rfl := Finset.subset_singleton_iff.1 ht'\n  Â· replace ht : Îµ â‰¤ 0 := by simpa using ht\n    exact (hÎµ.not_le ht).elim\n  Â· rwa [sub_self, abs_zero]\n\n"}
{"name":"SimpleGraph.not_isUniform_zero","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\ns t : Finset Î±\nâŠ¢ Not (G.IsUniform 0 s t)","decl":"theorem not_isUniform_zero : Â¬G.IsUniform (0 : ğ•œ) s t := fun h =>\n  (abs_nonneg _).not_lt <| h (empty_subset _) (empty_subset _) (by simp) (by simp)\n\n"}
{"name":"SimpleGraph.not_isUniform_iff","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nâŠ¢ Iff (Not (G.IsUniform Îµ s t)) (Exists fun s' => And (HasSubset.Subset s' s) (Exists fun t' => And (HasSubset.Subset t' t) (And (LE.le (HMul.hMul (â†‘s.card) Îµ) â†‘s'.card) (And (LE.le (HMul.hMul (â†‘t.card) Îµ) â†‘t'.card) (LE.le Îµ â†‘(abs (HSub.hSub (G.edgeDensity s' t') (G.edgeDensity s t))))))))","decl":"theorem not_isUniform_iff :\n    Â¬G.IsUniform Îµ s t â†” âˆƒ s', s' âŠ† s âˆ§ âˆƒ t', t' âŠ† t âˆ§ #s * Îµ â‰¤ #s' âˆ§\n      #t * Îµ â‰¤ #t' âˆ§ Îµ â‰¤ |G.edgeDensity s' t' - G.edgeDensity s t| := by\n  unfold IsUniform\n  simp only [not_forall, not_lt, exists_prop, exists_and_left, Rat.cast_abs, Rat.cast_sub]\n\n"}
{"name":"SimpleGraph.left_nonuniformWitnesses_subset","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nh : Not (G.IsUniform Îµ s t)\nâŠ¢ HasSubset.Subset (G.nonuniformWitnesses Îµ s t).1 s","decl":"theorem left_nonuniformWitnesses_subset (h : Â¬G.IsUniform Îµ s t) :\n    (G.nonuniformWitnesses Îµ s t).1 âŠ† s := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.1\n\n"}
{"name":"SimpleGraph.left_nonuniformWitnesses_card","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nh : Not (G.IsUniform Îµ s t)\nâŠ¢ LE.le (HMul.hMul (â†‘s.card) Îµ) â†‘(G.nonuniformWitnesses Îµ s t).1.card","decl":"theorem left_nonuniformWitnesses_card (h : Â¬G.IsUniform Îµ s t) :\n    #s * Îµ â‰¤ #(G.nonuniformWitnesses Îµ s t).1 := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.2.choose_spec.2.1\n\n"}
{"name":"SimpleGraph.right_nonuniformWitnesses_subset","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nh : Not (G.IsUniform Îµ s t)\nâŠ¢ HasSubset.Subset (G.nonuniformWitnesses Îµ s t).2 t","decl":"theorem right_nonuniformWitnesses_subset (h : Â¬G.IsUniform Îµ s t) :\n    (G.nonuniformWitnesses Îµ s t).2 âŠ† t := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.2.choose_spec.1\n\n"}
{"name":"SimpleGraph.right_nonuniformWitnesses_card","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nh : Not (G.IsUniform Îµ s t)\nâŠ¢ LE.le (HMul.hMul (â†‘t.card) Îµ) â†‘(G.nonuniformWitnesses Îµ s t).2.card","decl":"theorem right_nonuniformWitnesses_card (h : Â¬G.IsUniform Îµ s t) :\n    #t * Îµ â‰¤ #(G.nonuniformWitnesses Îµ s t).2 := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.2.choose_spec.2.2.1\n\n"}
{"name":"SimpleGraph.nonuniformWitnesses_spec","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nh : Not (G.IsUniform Îµ s t)\nâŠ¢ LE.le Îµ â†‘(abs (HSub.hSub (G.edgeDensity (G.nonuniformWitnesses Îµ s t).1 (G.nonuniformWitnesses Îµ s t).2) (G.edgeDensity s t)))","decl":"theorem nonuniformWitnesses_spec (h : Â¬G.IsUniform Îµ s t) :\n    Îµ â‰¤\n      |G.edgeDensity (G.nonuniformWitnesses Îµ s t).1 (G.nonuniformWitnesses Îµ s t).2 -\n          G.edgeDensity s t| := by\n  rw [nonuniformWitnesses, dif_pos h]\n  exact (not_isUniform_iff.1 h).choose_spec.2.choose_spec.2.2.2\n\n"}
{"name":"SimpleGraph.nonuniformWitness_subset","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nh : Not (G.IsUniform Îµ s t)\nâŠ¢ HasSubset.Subset (G.nonuniformWitness Îµ s t) s","decl":"theorem nonuniformWitness_subset (h : Â¬G.IsUniform Îµ s t) : G.nonuniformWitness Îµ s t âŠ† s := by\n  unfold nonuniformWitness\n  split_ifs\n  Â· exact G.left_nonuniformWitnesses_subset h\n  Â· exact G.right_nonuniformWitnesses_subset fun i => h i.symm\n\n"}
{"name":"SimpleGraph.le_card_nonuniformWitness","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nh : Not (G.IsUniform Îµ s t)\nâŠ¢ LE.le (HMul.hMul (â†‘s.card) Îµ) â†‘(G.nonuniformWitness Îµ s t).card","decl":"theorem le_card_nonuniformWitness (h : Â¬G.IsUniform Îµ s t) :\n    #s * Îµ â‰¤ #(G.nonuniformWitness Îµ s t) := by\n  unfold nonuniformWitness\n  split_ifs\n  Â· exact G.left_nonuniformWitnesses_card h\n  Â· exact G.right_nonuniformWitnesses_card fun i => h i.symm\n\n"}
{"name":"SimpleGraph.nonuniformWitness_spec","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nhâ‚ : Ne s t\nhâ‚‚ : Not (G.IsUniform Îµ s t)\nâŠ¢ LE.le Îµ â†‘(abs (HSub.hSub (G.edgeDensity (G.nonuniformWitness Îµ s t) (G.nonuniformWitness Îµ t s)) (G.edgeDensity s t)))","decl":"theorem nonuniformWitness_spec (hâ‚ : s â‰  t) (hâ‚‚ : Â¬G.IsUniform Îµ s t) : Îµ â‰¤ |G.edgeDensity\n    (G.nonuniformWitness Îµ s t) (G.nonuniformWitness Îµ t s) - G.edgeDensity s t| := by\n  unfold nonuniformWitness\n  rcases trichotomous_of WellOrderingRel s t with (lt | rfl | gt)\n  Â· rw [if_pos lt, if_neg (asymm lt)]\n    exact G.nonuniformWitnesses_spec hâ‚‚\n  Â· cases hâ‚ rfl\n  Â· rw [if_neg (asymm gt), if_pos gt, edgeDensity_comm, edgeDensity_comm _ s]\n    apply G.nonuniformWitnesses_spec fun i => hâ‚‚ i.symm\n\n"}
{"name":"Finpartition.mk_mem_sparsePairs","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nu v : Finset Î±\nÎµ : ğ•œ\nâŠ¢ Iff (Membership.mem (P.sparsePairs G Îµ) { fst := u, snd := v }) (And (Membership.mem P.parts u) (And (Membership.mem P.parts v) (And (Ne u v) (LT.lt (â†‘(G.edgeDensity u v)) Îµ))))","decl":"@[simp]\nlemma mk_mem_sparsePairs (u v : Finset Î±) (Îµ : ğ•œ) :\n    (u, v) âˆˆ P.sparsePairs G Îµ â†” u âˆˆ P.parts âˆ§ v âˆˆ P.parts âˆ§ u â‰  v âˆ§ G.edgeDensity u v < Îµ := by\n  rw [sparsePairs, mem_filter, mem_offDiag, and_assoc, and_assoc]\n\n"}
{"name":"Finpartition.sparsePairs_mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ Îµ' : ğ•œ\nh : LE.le Îµ Îµ'\nâŠ¢ HasSubset.Subset (P.sparsePairs G Îµ) (P.sparsePairs G Îµ')","decl":"lemma sparsePairs_mono {Îµ Îµ' : ğ•œ} (h : Îµ â‰¤ Îµ') : P.sparsePairs G Îµ âŠ† P.sparsePairs G Îµ' :=\n  monotone_filter_right _ fun _ â†¦ h.trans_lt'\n\n"}
{"name":"Finpartition.mk_mem_nonUniforms","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nu v : Finset Î±\nâŠ¢ Iff (Membership.mem (P.nonUniforms G Îµ) { fst := u, snd := v }) (And (Membership.mem P.parts u) (And (Membership.mem P.parts v) (And (Ne u v) (Not (G.IsUniform Îµ u v)))))","decl":"@[simp] lemma mk_mem_nonUniforms :\n    (u, v) âˆˆ P.nonUniforms G Îµ â†” u âˆˆ P.parts âˆ§ v âˆˆ P.parts âˆ§ u â‰  v âˆ§ Â¬G.IsUniform Îµ u v := by\n  rw [nonUniforms, mem_filter, mem_offDiag, and_assoc, and_assoc]\n\n"}
{"name":"Finpartition.nonUniforms_mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ Îµ' : ğ•œ\nh : LE.le Îµ Îµ'\nâŠ¢ HasSubset.Subset (P.nonUniforms G Îµ') (P.nonUniforms G Îµ)","decl":"theorem nonUniforms_mono {Îµ Îµ' : ğ•œ} (h : Îµ â‰¤ Îµ') : P.nonUniforms G Îµ' âŠ† P.nonUniforms G Îµ :=\n  monotone_filter_right _ fun _ => mt <| SimpleGraph.IsUniform.mono h\n\n"}
{"name":"Finpartition.nonUniforms_bot","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nhÎµ : LT.lt 0 Îµ\nâŠ¢ Eq (Bot.bot.nonUniforms G Îµ) EmptyCollection.emptyCollection","decl":"theorem nonUniforms_bot (hÎµ : 0 < Îµ) : (âŠ¥ : Finpartition A).nonUniforms G Îµ = âˆ… := by\n  rw [eq_empty_iff_forall_not_mem]\n  rintro âŸ¨u, vâŸ©\n  simp only [mk_mem_nonUniforms, parts_bot, mem_map, not_and,\n    Classical.not_not, exists_imp]; dsimp\n  rintro x âŸ¨_, rflâŸ© y âŸ¨_,rflâŸ© _\n  rwa [SimpleGraph.isUniform_singleton]\n\n"}
{"name":"Finpartition.bot_isUniform","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nhÎµ : LT.lt 0 Îµ\nâŠ¢ Bot.bot.IsUniform G Îµ","decl":"lemma bot_isUniform (hÎµ : 0 < Îµ) : (âŠ¥ : Finpartition A).IsUniform G Îµ := by\n  rw [Finpartition.IsUniform, Finpartition.card_bot, nonUniforms_bot _ hÎµ, Finset.card_empty,\n    Nat.cast_zero]\n  exact mul_nonneg (Nat.cast_nonneg _) hÎµ.le\n\n"}
{"name":"Finpartition.isUniform_one","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nâŠ¢ P.IsUniform G 1","decl":"lemma isUniform_one : P.IsUniform G (1 : ğ•œ) := by\n  rw [IsUniform, mul_one, Nat.cast_le]\n  refine (card_filter_le _\n    (fun uv => Â¬SimpleGraph.IsUniform G 1 (Prod.fst uv) (Prod.snd uv))).trans ?_\n  rw [offDiag_card, Nat.mul_sub_left_distrib, mul_one]\n\n"}
{"name":"Finpartition.IsUniform.mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ Îµ' : ğ•œ\nhP : P.IsUniform G Îµ\nh : LE.le Îµ Îµ'\nâŠ¢ P.IsUniform G Îµ'","decl":"theorem IsUniform.mono {Îµ Îµ' : ğ•œ} (hP : P.IsUniform G Îµ) (h : Îµ â‰¤ Îµ') : P.IsUniform G Îµ' :=\n  ((Nat.cast_le.2 <| card_le_card <| P.nonUniforms_mono G h).trans hP).trans <| by gcongr\n\n"}
{"name":"Finpartition.isUniformOfEmpty","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nhP : Eq P.parts EmptyCollection.emptyCollection\nâŠ¢ P.IsUniform G Îµ","decl":"theorem isUniformOfEmpty (hP : P.parts = âˆ…) : P.IsUniform G Îµ := by\n  simp [IsUniform, hP, nonUniforms]\n\n"}
{"name":"Finpartition.nonempty_of_not_uniform","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nh : Not (P.IsUniform G Îµ)\nâŠ¢ P.parts.Nonempty","decl":"theorem nonempty_of_not_uniform (h : Â¬P.IsUniform G Îµ) : P.parts.Nonempty :=\n  nonempty_of_ne_empty fun hâ‚ => h <| isUniformOfEmpty hâ‚\n\n"}
{"name":"Finpartition.nonuniformWitness_mem_nonuniformWitnesses","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\ns t : Finset Î±\nh : Not (G.IsUniform Îµ s t)\nht : Membership.mem P.parts t\nhst : Ne s t\nâŠ¢ Membership.mem (P.nonuniformWitnesses G Îµ s) (G.nonuniformWitness Îµ s t)","decl":"theorem nonuniformWitness_mem_nonuniformWitnesses (h : Â¬G.IsUniform Îµ s t) (ht : t âˆˆ P.parts)\n    (hst : s â‰  t) : G.nonuniformWitness Îµ s t âˆˆ P.nonuniformWitnesses G Îµ s :=\n  mem_image_of_mem _ <| mem_filter.2 âŸ¨ht, hst, hâŸ©\n\n"}
{"name":"Finpartition.IsEquipartition.card_interedges_sparsePairs_le'","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nhP : P.IsEquipartition\nhÎµ : LE.le 0 Îµ\nâŠ¢ LE.le (â†‘((P.sparsePairs G Îµ).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod Î± Î±)) x fun U V => G.interedges U V).card) (HMul.hMul Îµ (HPow.hPow (HAdd.hAdd â†‘A.card â†‘P.parts.card) 2))","decl":"open SimpleGraph in\nlemma IsEquipartition.card_interedges_sparsePairs_le' (hP : P.IsEquipartition)\n    (hÎµ : 0 â‰¤ Îµ) :\n    #((P.sparsePairs G Îµ).biUnion fun (U, V) â†¦ G.interedges U V) â‰¤ Îµ * (#A + #P.parts) ^ 2 := by\n  calc\n    _ â‰¤ âˆ‘ UV âˆˆ P.sparsePairs G Îµ, (#(G.interedges UV.1 UV.2) : ğ•œ) := mod_cast card_biUnion_le\n    _ â‰¤ âˆ‘ UV âˆˆ P.sparsePairs G Îµ, Îµ * (#UV.1 * #UV.2) := ?_\n    _ â‰¤ _ := sum_le_sum_of_subset_of_nonneg (filter_subset _ _) fun i _ _ â†¦ by positivity\n    _ = _ := (mul_sum _ _ _).symm\n    _ â‰¤ _ := mul_le_mul_of_nonneg_left ?_ hÎµ\n  Â· gcongr with UV hUV\n    obtain âŸ¨U, VâŸ© := UV\n    simp [mk_mem_sparsePairs, â† card_interedges_div_card] at hUV\n    refine ((div_lt_iffâ‚€ ?_).1 hUV.2.2.2).le\n    exact mul_pos (Nat.cast_pos.2 (P.nonempty_of_mem_parts hUV.1).card_pos)\n      (Nat.cast_pos.2 (P.nonempty_of_mem_parts hUV.2.1).card_pos)\n  norm_cast\n  calc\n    (_ : â„•) â‰¤ _ := sum_le_card_nsmul P.parts.offDiag (fun i â†¦ #i.1 * #i.2)\n            ((#A / #P.parts + 1)^2 : â„•) ?_\n    _ â‰¤ (#P.parts * (#A / #P.parts) + #P.parts) ^ 2 := ?_\n    _ â‰¤ _ := Nat.pow_le_pow_of_le_left (add_le_add_right (Nat.mul_div_le _ _) _) _\n  Â· simp only [Prod.forall, Finpartition.mk_mem_nonUniforms, and_imp, mem_offDiag, sq]\n    rintro U V hU hV -\n    exact_mod_cast Nat.mul_le_mul (hP.card_part_le_average_add_one hU)\n      (hP.card_part_le_average_add_one hV)\n  Â· rw [smul_eq_mul, offDiag_card, Nat.mul_sub_right_distrib, â† sq, â† mul_pow, mul_add_one (Î± := â„•)]\n    exact Nat.sub_le _ _\n\n"}
{"name":"Finpartition.IsEquipartition.card_interedges_sparsePairs_le","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nhP : P.IsEquipartition\nhÎµ : LE.le 0 Îµ\nâŠ¢ LE.le (â†‘((P.sparsePairs G Îµ).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod Î± Î±)) x fun U V => G.interedges U V).card) (HMul.hMul (HMul.hMul 4 Îµ) (HPow.hPow (â†‘A.card) 2))","decl":"lemma IsEquipartition.card_interedges_sparsePairs_le (hP : P.IsEquipartition) (hÎµ : 0 â‰¤ Îµ) :\n    #((P.sparsePairs G Îµ).biUnion fun (U, V) â†¦ G.interedges U V) â‰¤ 4 * Îµ * #A ^ 2 := by\n  calc\n    _ â‰¤ _ := hP.card_interedges_sparsePairs_le' hÎµ\n    _ â‰¤ Îµ * (#A + #A)^2 := by gcongr; exact P.card_parts_le_card\n    _ = _ := by ring\n\n"}
{"name":"Finpartition.IsEquipartition.card_biUnion_offDiag_le'","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\ninstâœ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nhP : P.IsEquipartition\nâŠ¢ LE.le (â†‘(P.parts.biUnion Finset.offDiag).card) (HDiv.hDiv (HMul.hMul (â†‘A.card) (HAdd.hAdd â†‘A.card â†‘P.parts.card)) â†‘P.parts.card)","decl":"lemma IsEquipartition.card_biUnion_offDiag_le' (hP : P.IsEquipartition) :\n    (#(P.parts.biUnion offDiag) : ğ•œ) â‰¤ #A * (#A + #P.parts) / #P.parts := by\n  obtain h | h := P.parts.eq_empty_or_nonempty\n  Â· simp [h]\n  calc\n    _ â‰¤ (#P.parts : ğ•œ) * (â†‘(#A / #P.parts) * â†‘(#A / #P.parts + 1)) :=\n        mod_cast card_biUnion_le_card_mul _ _ _ fun U hU â†¦ ?_\n    _ = #P.parts * â†‘(#A / #P.parts) * â†‘(#A / #P.parts + 1) := by rw [mul_assoc]\n    _ â‰¤ #A * (#A / #P.parts + 1) :=\n        mul_le_mul (mod_cast Nat.mul_div_le _ _) ?_ (by positivity) (by positivity)\n    _ = _ := by rw [â† div_add_same (mod_cast h.card_pos.ne'), mul_div_assoc]\n  Â· simpa using Nat.cast_div_le\n  suffices (#U - 1) * #U â‰¤ #A / #P.parts * (#A / #P.parts + 1) by\n    rwa [Nat.mul_sub_right_distrib, one_mul, â† offDiag_card] at this\n  have := hP.card_part_le_average_add_one hU\n  refine Nat.mul_le_mul ((Nat.sub_le_sub_right this 1).trans ?_) this\n  simp only [Nat.add_succ_sub_one, add_zero, card_univ, le_rfl]\n\n"}
{"name":"Finpartition.IsEquipartition.card_biUnion_offDiag_le","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ¹ : LinearOrderedField ğ•œ\ninstâœ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nÎµ : ğ•œ\nhÎµ : LT.lt 0 Îµ\nhP : P.IsEquipartition\nhP' : LE.le (HDiv.hDiv 4 Îµ) â†‘P.parts.card\nâŠ¢ LE.le (â†‘(P.parts.biUnion Finset.offDiag).card) (HMul.hMul (HDiv.hDiv Îµ 2) (HPow.hPow (â†‘A.card) 2))","decl":"lemma IsEquipartition.card_biUnion_offDiag_le (hÎµ : 0 < Îµ) (hP : P.IsEquipartition)\n    (hP' : 4 / Îµ â‰¤ #P.parts) : #(P.parts.biUnion offDiag) â‰¤ Îµ / 2 * #A ^ 2 := by\n  obtain rfl | hA : A = âŠ¥ âˆ¨ _ := A.eq_empty_or_nonempty\n  Â· simp [Subsingleton.elim P âŠ¥]\n  apply hP.card_biUnion_offDiag_le'.trans\n  rw [div_le_iffâ‚€ (Nat.cast_pos.2 (P.parts_nonempty hA.ne_empty).card_pos)]\n  have : (#A : ğ•œ) + #P.parts â‰¤ 2 * #A := by\n    rw [two_mul]; exact add_le_add_left (Nat.cast_le.2 P.card_parts_le_card) _\n  refine (mul_le_mul_of_nonneg_left this <| by positivity).trans ?_\n  suffices 1 â‰¤ Îµ/4 * #P.parts by\n    rw [mul_left_comm, â† sq]\n    convert mul_le_mul_of_nonneg_left this (mul_nonneg zero_le_two <| sq_nonneg (#A : ğ•œ))\n      using 1 <;> ring\n  rwa [â† div_le_iffâ‚€', one_div_div]\n  positivity\n\n"}
{"name":"Finpartition.IsEquipartition.sum_nonUniforms_lt'","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nhA : A.Nonempty\nhÎµ : LT.lt 0 Îµ\nhP : P.IsEquipartition\nhG : P.IsUniform G Îµ\nâŠ¢ LT.lt ((P.nonUniforms G Îµ).sum fun i => HMul.hMul â†‘i.1.card â†‘i.2.card) (HMul.hMul Îµ (HPow.hPow (HAdd.hAdd â†‘A.card â†‘P.parts.card) 2))","decl":"lemma IsEquipartition.sum_nonUniforms_lt' (hA : A.Nonempty) (hÎµ : 0 < Îµ) (hP : P.IsEquipartition)\n    (hG : P.IsUniform G Îµ) :\n    âˆ‘ i âˆˆ P.nonUniforms G Îµ, (#i.1 * #i.2 : ğ•œ) < Îµ * (#A + #P.parts) ^ 2 := by\n  calc\n    _ â‰¤ #(P.nonUniforms G Îµ) â€¢ (â†‘(#A / #P.parts + 1) : ğ•œ) ^ 2 :=\n      sum_le_card_nsmul _ _ _ ?_\n    _ = _ := nsmul_eq_mul _ _\n    _ â‰¤ _ := mul_le_mul_of_nonneg_right hG <| by positivity\n    _ < _ := ?_\n  Â· simp only [Prod.forall, Finpartition.mk_mem_nonUniforms, and_imp]\n    rintro U V hU hV - -\n    rw [sq, â† Nat.cast_mul, â† Nat.cast_mul, Nat.cast_le]\n    exact Nat.mul_le_mul (hP.card_part_le_average_add_one hU)\n      (hP.card_part_le_average_add_one hV)\n  Â· rw [mul_right_comm _ Îµ, mul_comm Îµ]\n    apply mul_lt_mul_of_pos_right _ hÎµ\n    norm_cast\n    exact aux (P.parts_nonempty hA.ne_empty).card_pos\n\n"}
{"name":"Finpartition.IsEquipartition.sum_nonUniforms_lt","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nhA : A.Nonempty\nhÎµ : LT.lt 0 Îµ\nhP : P.IsEquipartition\nhG : P.IsUniform G Îµ\nâŠ¢ LT.lt (â†‘((P.nonUniforms G Îµ).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod Î± Î±)) x fun U V => SProd.sprod U V).card) (HMul.hMul (HMul.hMul 4 Îµ) (HPow.hPow (â†‘A.card) 2))","decl":"lemma IsEquipartition.sum_nonUniforms_lt (hA : A.Nonempty) (hÎµ : 0 < Îµ) (hP : P.IsEquipartition)\n    (hG : P.IsUniform G Îµ) :\n    #((P.nonUniforms G Îµ).biUnion fun (U, V) â†¦ U Ã—Ë¢ V) < 4 * Îµ * #A ^ 2 := by\n  calc\n    _ â‰¤ âˆ‘ i âˆˆ P.nonUniforms G Îµ, (#i.1 * #i.2 : ğ•œ) := by\n        norm_cast; simp_rw [â† card_product]; exact card_biUnion_le\n    _ < _ := hP.sum_nonUniforms_lt' hA hÎµ hG\n    _ â‰¤ Îµ * (#A + #A) ^ 2 := by gcongr; exact P.card_parts_le_card\n    _ = _ := by ring\n\n"}
{"name":"SimpleGraph.regularityReduced_adj","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ Î´ : ğ•œ\na b : Î±\nâŠ¢ Eq ((SimpleGraph.regularityReduced P G Îµ Î´).Adj a b) (And (G.Adj a b) (Exists fun U => And (Membership.mem P.parts U) (Exists fun V => And (Membership.mem P.parts V) (And (Membership.mem U a) (And (Membership.mem V b) (And (Ne U V) (And (G.IsUniform Îµ U V) (LE.le Î´ â†‘(G.edgeDensity U V)))))))))","decl":"/-- The reduction of the graph `G` along partition `P` has edges between `Îµ`-uniform pairs of parts\nthat have edge density at least `Î´`. -/\n@[simps] def regularityReduced (Îµ Î´ : ğ•œ) : SimpleGraph Î± where\n  Adj a b := G.Adj a b âˆ§\n    âˆƒ U âˆˆ P.parts, âˆƒ V âˆˆ P.parts, a âˆˆ U âˆ§ b âˆˆ V âˆ§ U â‰  V âˆ§ G.IsUniform Îµ U V âˆ§ Î´ â‰¤ G.edgeDensity U V\n  symm a b := by\n    rintro âŸ¨ab, U, UP, V, VP, xU, yV, UV, GUV, ÎµUVâŸ©\n    refine âŸ¨G.symm ab, V, VP, U, UP, yV, xU, UV.symm, GUV.symm, ?_âŸ©\n    rwa [edgeDensity_comm]\n  loopless a h := G.loopless a h.1\n\n"}
{"name":"SimpleGraph.regularityReduced_le","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ Î´ : ğ•œ\nâŠ¢ LE.le (SimpleGraph.regularityReduced P G Îµ Î´) G","decl":"lemma regularityReduced_le : G.regularityReduced P Îµ Î´ â‰¤ G := fun _ _ â†¦ And.left\n\n"}
{"name":"SimpleGraph.regularityReduced_mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎ´ Îµâ‚ Îµâ‚‚ : ğ•œ\nhÎµ : LE.le Îµâ‚ Îµâ‚‚\nâŠ¢ LE.le (SimpleGraph.regularityReduced P G Îµâ‚ Î´) (SimpleGraph.regularityReduced P G Îµâ‚‚ Î´)","decl":"lemma regularityReduced_mono {Îµâ‚ Îµâ‚‚ : ğ•œ} (hÎµ : Îµâ‚ â‰¤ Îµâ‚‚) :\n    G.regularityReduced P Îµâ‚ Î´ â‰¤ G.regularityReduced P Îµâ‚‚ Î´ :=\n  fun _a _b âŸ¨hab, U, hU, V, hV, ha, hb, hUV, hGÎµ, hGÎ´âŸ© â†¦\n    âŸ¨hab, U, hU, V, hV, ha, hb, hUV, hGÎµ.mono hÎµ, hGÎ´âŸ©\n\n"}
{"name":"SimpleGraph.regularityReduced_anti","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ Î´â‚ Î´â‚‚ : ğ•œ\nhÎ´ : LE.le Î´â‚ Î´â‚‚\nâŠ¢ LE.le (SimpleGraph.regularityReduced P G Îµ Î´â‚‚) (SimpleGraph.regularityReduced P G Îµ Î´â‚)","decl":"lemma regularityReduced_anti {Î´â‚ Î´â‚‚ : ğ•œ} (hÎ´ : Î´â‚ â‰¤ Î´â‚‚) :\n    G.regularityReduced P Îµ Î´â‚‚ â‰¤ G.regularityReduced P Îµ Î´â‚ :=\n  fun _a _b âŸ¨hab, U, hU, V, hV, ha, hb, hUV, hUVÎµ, hUVÎ´âŸ© â†¦\n    âŸ¨hab, U, hU, V, hV, ha, hb, hUV, hUVÎµ, hÎ´.trans hUVÎ´âŸ©\n\n"}
{"name":"SimpleGraph.unreduced_edges_subset","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Uniform","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : DecidableEq Î±\nA : Finset Î±\nP : Finpartition A\nG : SimpleGraph Î±\ninstâœ : DecidableRel G.Adj\nÎµ : ğ•œ\nâŠ¢ HasSubset.Subset (Finset.filter (fun x => SimpleGraph.unreduced_edges_subset.match_1 (fun x => Prop) x fun x y => And (G.Adj x y) (Not ((SimpleGraph.regularityReduced P G (HDiv.hDiv Îµ 8) (HDiv.hDiv Îµ 4)).Adj x y))) (SProd.sprod A A)) (Union.union (Union.union ((P.nonUniforms G (HDiv.hDiv Îµ 8)).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod Î± Î±)) x fun U V => SProd.sprod U V) (P.parts.biUnion Finset.offDiag)) ((P.sparsePairs G (HDiv.hDiv Îµ 4)).biUnion fun x => Finpartition.sparsePairs.match_1 (fun x => Finset (Prod Î± Î±)) x fun U V => G.interedges U V))","decl":"lemma unreduced_edges_subset :\n    (A Ã—Ë¢ A).filter (fun (x, y) â†¦ G.Adj x y âˆ§ Â¬ (G.regularityReduced P (Îµ/8) (Îµ/4)).Adj x y) âŠ†\n      (P.nonUniforms G (Îµ/8)).biUnion (fun (U, V) â†¦ U Ã—Ë¢ V) âˆª P.parts.biUnion offDiag âˆª\n        (P.sparsePairs G (Îµ/4)).biUnion fun (U, V) â†¦ G.interedges U V := by\n  rintro âŸ¨x, yâŸ©\n  simp only [mem_sdiff, mem_filter, mem_univ, true_and, regularityReduced_adj, not_and, not_exists,\n    not_le, mem_biUnion, mem_union, exists_prop, mem_product, Prod.exists, mem_offDiag, and_imp,\n    or_assoc, and_assoc, P.mk_mem_nonUniforms, Finpartition.mk_mem_sparsePairs, mem_interedges_iff]\n  intros hx hy h h'\n  replace h' := h' h\n  obtain âŸ¨U, hU, hxâŸ© := P.exists_mem hx\n  obtain âŸ¨V, hV, hyâŸ© := P.exists_mem hy\n  obtain rfl | hUV := eq_or_ne U V\n  Â· exact Or.inr (Or.inl âŸ¨U, hU, hx, hy, G.ne_of_adj hâŸ©)\n  by_cases hâ‚‚ : G.IsUniform (Îµ/8) U V\n  Â· exact Or.inr <| Or.inr âŸ¨U, V, hU, hV, hUV, h' _ hU _ hV hx hy hUV hâ‚‚, hx, hy, hâŸ©\n  Â· exact Or.inl âŸ¨U, V, hU, hV, hUV, hâ‚‚, hx, hyâŸ©\n\n"}
