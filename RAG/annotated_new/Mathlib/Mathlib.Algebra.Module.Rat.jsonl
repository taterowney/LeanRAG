{"name":"map_nnratCast_smul","module":"Mathlib.Algebra.Module.Rat","initialProofState":"M : Type u_1\nM₂ : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\nF : Type u_3\ninst✝⁵ : FunLike F M M₂\ninst✝⁴ : AddMonoidHomClass F M M₂\nf : F\nR : Type u_4\nS : Type u_5\ninst✝³ : DivisionSemiring R\ninst✝² : DivisionSemiring S\ninst✝¹ : Module R M\ninst✝ : Module S M₂\nc : NNRat\nx : M\n⊢ Eq (f (HSMul.hSMul (↑c) x)) (HSMul.hSMul (↑c) (f x))","decl":"theorem map_nnratCast_smul [AddCommMonoid M] [AddCommMonoid M₂] {F : Type*} [FunLike F M M₂]\n    [AddMonoidHomClass F M M₂] (f : F) (R S : Type*) [DivisionSemiring R] [DivisionSemiring S]\n    [Module R M] [Module S M₂] (c : ℚ≥0) (x : M) :\n    f ((c : R) • x) = (c : S) • f x := by\n  rw [NNRat.cast_def, NNRat.cast_def, div_eq_mul_inv, div_eq_mul_inv, mul_smul, mul_smul,\n    map_natCast_smul f R S, map_inv_natCast_smul f R S]\n\n"}
{"name":"map_ratCast_smul","module":"Mathlib.Algebra.Module.Rat","initialProofState":"M : Type u_1\nM₂ : Type u_2\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup M₂\nF : Type u_3\ninst✝⁵ : FunLike F M M₂\ninst✝⁴ : AddMonoidHomClass F M M₂\nf : F\nR : Type u_4\nS : Type u_5\ninst✝³ : DivisionRing R\ninst✝² : DivisionRing S\ninst✝¹ : Module R M\ninst✝ : Module S M₂\nc : Rat\nx : M\n⊢ Eq (f (HSMul.hSMul (↑c) x)) (HSMul.hSMul (↑c) (f x))","decl":"theorem map_ratCast_smul [AddCommGroup M] [AddCommGroup M₂] {F : Type*} [FunLike F M M₂]\n    [AddMonoidHomClass F M M₂] (f : F) (R S : Type*) [DivisionRing R] [DivisionRing S] [Module R M]\n    [Module S M₂] (c : ℚ) (x : M) :\n    f ((c : R) • x) = (c : S) • f x := by\n  rw [Rat.cast_def, Rat.cast_def, div_eq_mul_inv, div_eq_mul_inv, mul_smul, mul_smul,\n    map_intCast_smul f R S, map_inv_natCast_smul f R S]\n\n"}
{"name":"map_nnrat_smul","module":"Mathlib.Algebra.Module.Rat","initialProofState":"M : Type u_1\nM₂ : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\n_instM : Module NNRat M\n_instM₂ : Module NNRat M₂\nF : Type u_3\ninst✝¹ : FunLike F M M₂\ninst✝ : AddMonoidHomClass F M M₂\nf : F\nc : NNRat\nx : M\n⊢ Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))","decl":"theorem map_nnrat_smul [AddCommMonoid M] [AddCommMonoid M₂]\n    [_instM : Module ℚ≥0 M] [_instM₂ : Module ℚ≥0 M₂]\n    {F : Type*} [FunLike F M M₂] [AddMonoidHomClass F M M₂]\n    (f : F) (c : ℚ≥0) (x : M) : f (c • x) = c • f x :=\n  map_nnratCast_smul f ℚ≥0 ℚ≥0 c x\n\n"}
{"name":"map_rat_smul","module":"Mathlib.Algebra.Module.Rat","initialProofState":"M : Type u_1\nM₂ : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\n_instM : Module Rat M\n_instM₂ : Module Rat M₂\nF : Type u_3\ninst✝¹ : FunLike F M M₂\ninst✝ : AddMonoidHomClass F M M₂\nf : F\nc : Rat\nx : M\n⊢ Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))","decl":"theorem map_rat_smul [AddCommGroup M] [AddCommGroup M₂]\n    [_instM : Module ℚ M] [_instM₂ : Module ℚ M₂]\n    {F : Type*} [FunLike F M M₂] [AddMonoidHomClass F M M₂]\n    (f : F) (c : ℚ) (x : M) : f (c • x) = c • f x :=\n  map_ratCast_smul f ℚ ℚ c x\n\n"}
{"name":"subsingleton_nnrat_module","module":"Mathlib.Algebra.Module.Rat","initialProofState":"E : Type u_3\ninst✝ : AddCommMonoid E\n⊢ Subsingleton (Module NNRat E)","decl":"/-- There can be at most one `Module ℚ≥0 E` structure on an additive commutative monoid. -/\ninstance subsingleton_nnrat_module (E : Type*) [AddCommMonoid E] : Subsingleton (Module ℚ≥0 E) :=\n  ⟨fun P Q => (Module.ext' P Q) fun r x =>\n    map_nnrat_smul (_instM := P) (_instM₂ := Q) (AddMonoidHom.id E) r x⟩\n\n"}
{"name":"subsingleton_rat_module","module":"Mathlib.Algebra.Module.Rat","initialProofState":"E : Type u_3\ninst✝ : AddCommGroup E\n⊢ Subsingleton (Module Rat E)","decl":"/-- There can be at most one `Module ℚ E` structure on an additive commutative group. -/\ninstance subsingleton_rat_module (E : Type*) [AddCommGroup E] : Subsingleton (Module ℚ E) :=\n  ⟨fun P Q => (Module.ext' P Q) fun r x =>\n    map_rat_smul (_instM := P) (_instM₂ := Q) (AddMonoidHom.id E) r x⟩\n\n"}
{"name":"nnratCast_smul_eq","module":"Mathlib.Algebra.Module.Rat","initialProofState":"E : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝⁴ : AddCommMonoid E\ninst✝³ : DivisionSemiring R\ninst✝² : DivisionSemiring S\ninst✝¹ : Module R E\ninst✝ : Module S E\nr : NNRat\nx : E\n⊢ Eq (HSMul.hSMul (↑r) x) (HSMul.hSMul (↑r) x)","decl":"/-- If `E` is a vector space over two division semirings `R` and `S`, then scalar multiplications\nagree on non-negative rational numbers in `R` and `S`. -/\ntheorem nnratCast_smul_eq {E : Type*} (R S : Type*) [AddCommMonoid E] [DivisionSemiring R]\n    [DivisionSemiring S] [Module R E] [Module S E] (r : ℚ≥0) (x : E) : (r : R) • x = (r : S) • x :=\n  map_nnratCast_smul (AddMonoidHom.id E) R S r x\n\n"}
{"name":"ratCast_smul_eq","module":"Mathlib.Algebra.Module.Rat","initialProofState":"E : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝⁴ : AddCommGroup E\ninst✝³ : DivisionRing R\ninst✝² : DivisionRing S\ninst✝¹ : Module R E\ninst✝ : Module S E\nr : Rat\nx : E\n⊢ Eq (HSMul.hSMul (↑r) x) (HSMul.hSMul (↑r) x)","decl":"/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on rational numbers in `R` and `S`. -/\ntheorem ratCast_smul_eq {E : Type*} (R S : Type*) [AddCommGroup E] [DivisionRing R]\n    [DivisionRing S] [Module R E] [Module S E] (r : ℚ) (x : E) : (r : R) • x = (r : S) • x :=\n  map_ratCast_smul (AddMonoidHom.id E) R S r x\n\n"}
{"name":"IsScalarTower.nnrat","module":"Mathlib.Algebra.Module.Rat","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module NNRat R\ninst✝ : Module NNRat M\n⊢ IsScalarTower NNRat R M","decl":"instance IsScalarTower.nnrat {R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]\n    [Module ℚ≥0 R] [Module ℚ≥0 M] : IsScalarTower ℚ≥0 R M where\n  smul_assoc r x y := map_nnrat_smul ((smulAddHom R M).flip y) r x\n\n"}
{"name":"IsScalarTower.rat","module":"Mathlib.Algebra.Module.Rat","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module Rat R\ninst✝ : Module Rat M\n⊢ IsScalarTower Rat R M","decl":"instance IsScalarTower.rat {R : Type u} {M : Type v} [Ring R] [AddCommGroup M] [Module R M]\n    [Module ℚ R] [Module ℚ M] : IsScalarTower ℚ R M where\n  smul_assoc r x y := map_rat_smul ((smulAddHom R M).flip y) r x\n\n"}
{"name":"SMulCommClass.nnrat","module":"Mathlib.Algebra.Module.Rat","initialProofState":"α : Type u\nM : Type v\ninst✝³ : Monoid α\ninst✝² : AddCommMonoid M\ninst✝¹ : DistribMulAction α M\ninst✝ : Module NNRat M\n⊢ SMulCommClass NNRat α M","decl":"instance SMulCommClass.nnrat [Monoid α] [AddCommMonoid M] [DistribMulAction α M] [Module ℚ≥0 M] :\n    SMulCommClass ℚ≥0 α M where\n  smul_comm r x y := (map_nnrat_smul (DistribMulAction.toAddMonoidHom M x) r y).symm\n\n"}
{"name":"SMulCommClass.rat","module":"Mathlib.Algebra.Module.Rat","initialProofState":"α : Type u\nM : Type v\ninst✝³ : Monoid α\ninst✝² : AddCommGroup M\ninst✝¹ : DistribMulAction α M\ninst✝ : Module Rat M\n⊢ SMulCommClass Rat α M","decl":"instance SMulCommClass.rat [Monoid α] [AddCommGroup M] [DistribMulAction α M] [Module ℚ M] :\n    SMulCommClass ℚ α M where\n  smul_comm r x y := (map_rat_smul (DistribMulAction.toAddMonoidHom M x) r y).symm\n\n"}
{"name":"SMulCommClass.nnrat'","module":"Mathlib.Algebra.Module.Rat","initialProofState":"α : Type u\nM : Type v\ninst✝³ : Monoid α\ninst✝² : AddCommMonoid M\ninst✝¹ : DistribMulAction α M\ninst✝ : Module NNRat M\n⊢ SMulCommClass α NNRat M","decl":"instance SMulCommClass.nnrat' [Monoid α] [AddCommMonoid M] [DistribMulAction α M] [Module ℚ≥0 M] :\n    SMulCommClass α ℚ≥0 M :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"SMulCommClass.rat'","module":"Mathlib.Algebra.Module.Rat","initialProofState":"α : Type u\nM : Type v\ninst✝³ : Monoid α\ninst✝² : AddCommGroup M\ninst✝¹ : DistribMulAction α M\ninst✝ : Module Rat M\n⊢ SMulCommClass α Rat M","decl":"instance SMulCommClass.rat' [Monoid α] [AddCommGroup M] [DistribMulAction α M] [Module ℚ M] :\n    SMulCommClass α ℚ M :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"NNRatModule.noZeroSMulDivisors","module":"Mathlib.Algebra.Module.Rat","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\n⊢ NoZeroSMulDivisors Nat M","decl":"instance (priority := 100) NNRatModule.noZeroSMulDivisors [AddCommMonoid M] [Module ℚ≥0 M] :\n    NoZeroSMulDivisors ℕ M :=\n  ⟨fun {k} {x : M} h => by simpa [← Nat.cast_smul_eq_nsmul ℚ≥0 k x] using h⟩\n\n-- see note [lower instance priority]\n"}
{"name":"RatModule.noZeroSMulDivisors","module":"Mathlib.Algebra.Module.Rat","initialProofState":"M : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module Rat M\n⊢ NoZeroSMulDivisors Int M","decl":"instance (priority := 100) RatModule.noZeroSMulDivisors [AddCommGroup M] [Module ℚ M] :\n    NoZeroSMulDivisors ℤ M :=\n  ⟨fun {k} {x : M} h => by simpa [← Int.cast_smul_eq_zsmul ℚ k x] using h⟩\n"}
