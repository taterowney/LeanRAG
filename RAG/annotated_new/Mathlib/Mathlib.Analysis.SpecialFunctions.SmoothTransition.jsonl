{"name":"expNegInvGlue.zero_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\nhx : LE.le x 0\n‚ä¢ Eq (expNegInvGlue x) 0","decl":"/-- The function `expNegInvGlue` vanishes on `(-‚àû, 0]`. -/\ntheorem zero_of_nonpos {x : ‚Ñù} (hx : x ‚â§ 0) : expNegInvGlue x = 0 := by simp [expNegInvGlue, hx]\n\n"}
{"name":"expNegInvGlue.zero","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"‚ä¢ Eq (expNegInvGlue 0) 0","decl":"@[simp]\nprotected theorem zero : expNegInvGlue 0 = 0 := zero_of_nonpos le_rfl\n\n"}
{"name":"expNegInvGlue.pos_of_pos","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ LT.lt 0 (expNegInvGlue x)","decl":"/-- The function `expNegInvGlue` is positive on `(0, +‚àû)`. -/\ntheorem pos_of_pos {x : ‚Ñù} (hx : 0 < x) : 0 < expNegInvGlue x := by\n  simp [expNegInvGlue, not_le.2 hx, exp_pos]\n\n"}
{"name":"expNegInvGlue.nonneg","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\n‚ä¢ LE.le 0 (expNegInvGlue x)","decl":"/-- The function `expNegInvGlue` is nonnegative. -/\ntheorem nonneg (x : ‚Ñù) : 0 ‚â§ expNegInvGlue x := by\n  cases le_or_gt x 0 with\n  | inl h => exact ge_of_eq (zero_of_nonpos h)\n  | inr h => exact le_of_lt (pos_of_pos h)\n\n"}
{"name":"expNegInvGlue.zero_iff_nonpos","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\n‚ä¢ Iff (Eq (expNegInvGlue x) 0) (LE.le x 0)","decl":"@[simp] theorem zero_iff_nonpos {x : ‚Ñù} : expNegInvGlue x = 0 ‚Üî x ‚â§ 0 :=\n  ‚ü®fun h ‚Ü¶ not_lt.mp fun h' ‚Ü¶ (pos_of_pos h').ne' h, zero_of_nonpos‚ü©\n\n"}
{"name":"expNegInvGlue.tendsto_polynomial_inv_mul_zero","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"p : Polynomial Real\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul (Polynomial.eval (Inv.inv x) p) (expNegInvGlue x)) (nhds 0) (nhds 0)","decl":"/-- Our function tends to zero at zero faster than any $P(x^{-1})$, $P‚àà‚Ñù[X]$, tends to infinity. -/\ntheorem tendsto_polynomial_inv_mul_zero (p : ‚Ñù[X]) :\n    Tendsto (fun x ‚Ü¶ p.eval x‚Åª¬π * expNegInvGlue x) (ùìù 0) (ùìù 0) := by\n  simp only [expNegInvGlue, mul_ite, mul_zero]\n  refine tendsto_const_nhds.if ?_\n  simp only [not_le]\n  have : Tendsto (fun x ‚Ü¶ p.eval x‚Åª¬π / exp x‚Åª¬π) (ùìù[>] 0) (ùìù 0) :=\n    p.tendsto_div_exp_atTop.comp tendsto_inv_nhdsGT_zero\n  refine this.congr' <| mem_of_superset self_mem_nhdsWithin fun x hx ‚Ü¶ ?_\n  simp [expNegInvGlue, hx.out.not_le, exp_neg, div_eq_mul_inv]\n\n"}
{"name":"expNegInvGlue.hasDerivAt_polynomial_eval_inv_mul","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"p : Polynomial Real\nx : Real\n‚ä¢ HasDerivAt (fun x => HMul.hMul (Polynomial.eval (Inv.inv x) p) (expNegInvGlue x)) (HMul.hMul (Polynomial.eval (Inv.inv x) (HMul.hMul (HPow.hPow Polynomial.X 2) (HSub.hSub p (Polynomial.derivative p)))) (expNegInvGlue x)) x","decl":"theorem hasDerivAt_polynomial_eval_inv_mul (p : ‚Ñù[X]) (x : ‚Ñù) :\n    HasDerivAt (fun x ‚Ü¶ p.eval x‚Åª¬π * expNegInvGlue x)\n      ((X ^ 2 * (p - derivative (R := ‚Ñù) p)).eval x‚Åª¬π * expNegInvGlue x) x := by\n  rcases lt_trichotomy x 0 with hx | rfl | hx\n  ¬∑ rw [zero_of_nonpos hx.le, mul_zero]\n    refine (hasDerivAt_const _ 0).congr_of_eventuallyEq ?_\n    filter_upwards [gt_mem_nhds hx] with y hy\n    rw [zero_of_nonpos hy.le, mul_zero]\n  ¬∑ rw [expNegInvGlue.zero, mul_zero, hasDerivAt_iff_tendsto_slope]\n    refine ((tendsto_polynomial_inv_mul_zero (p * X)).mono_left inf_le_left).congr fun x ‚Ü¶ ?_\n    simp [slope_def_field, div_eq_mul_inv, mul_right_comm]\n  ¬∑ have := ((p.hasDerivAt x‚Åª¬π).mul (hasDerivAt_neg _).exp).comp x (hasDerivAt_inv hx.ne')\n    convert this.congr_of_eventuallyEq _ using 1\n    ¬∑ simp [expNegInvGlue, hx.not_le]\n      ring\n    ¬∑ filter_upwards [lt_mem_nhds hx] with y hy\n      simp [expNegInvGlue, hy.not_le]\n\n"}
{"name":"expNegInvGlue.differentiable_polynomial_eval_inv_mul","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"p : Polynomial Real\n‚ä¢ Differentiable Real fun x => HMul.hMul (Polynomial.eval (Inv.inv x) p) (expNegInvGlue x)","decl":"theorem differentiable_polynomial_eval_inv_mul (p : ‚Ñù[X]) :\n    Differentiable ‚Ñù (fun x ‚Ü¶ p.eval x‚Åª¬π * expNegInvGlue x) := fun x ‚Ü¶\n  (hasDerivAt_polynomial_eval_inv_mul p x).differentiableAt\n\n"}
{"name":"expNegInvGlue.continuous_polynomial_eval_inv_mul","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"p : Polynomial Real\n‚ä¢ Continuous fun x => HMul.hMul (Polynomial.eval (Inv.inv x) p) (expNegInvGlue x)","decl":"theorem continuous_polynomial_eval_inv_mul (p : ‚Ñù[X]) :\n    Continuous (fun x ‚Ü¶ p.eval x‚Åª¬π * expNegInvGlue x) :=\n  (differentiable_polynomial_eval_inv_mul p).continuous\n\n"}
{"name":"expNegInvGlue.contDiff_polynomial_eval_inv_mul","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"n : ENat\np : Polynomial Real\n‚ä¢ ContDiff Real ‚Üën fun x => HMul.hMul (Polynomial.eval (Inv.inv x) p) (expNegInvGlue x)","decl":"theorem contDiff_polynomial_eval_inv_mul {n : ‚Ñï‚àû} (p : ‚Ñù[X]) :\n    ContDiff ‚Ñù n (fun x ‚Ü¶ p.eval x‚Åª¬π * expNegInvGlue x) := by\n  apply contDiff_all_iff_nat.2 (fun m => ?_) n\n  induction m generalizing p with\n  | zero => exact contDiff_zero.2 <| continuous_polynomial_eval_inv_mul _\n  | succ m ihm =>\n    rw [show ((m + 1 : ‚Ñï) : WithTop ‚Ñï‚àû) = m + 1 from rfl]\n    refine contDiff_succ_iff_deriv.2 ‚ü®differentiable_polynomial_eval_inv_mul _, by simp, ?_‚ü©\n    convert ihm (X ^ 2 * (p - derivative (R := ‚Ñù) p)) using 2\n    exact (hasDerivAt_polynomial_eval_inv_mul p _).deriv\n\n"}
{"name":"expNegInvGlue.contDiff","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"n : ENat\n‚ä¢ ContDiff Real (‚Üën) expNegInvGlue","decl":"/-- The function `expNegInvGlue` is smooth. -/\nprotected theorem contDiff {n : ‚Ñï‚àû} : ContDiff ‚Ñù n expNegInvGlue := by\n  simpa using contDiff_polynomial_eval_inv_mul 1\n\n"}
{"name":"Real.smoothTransition.pos_denom","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\n‚ä¢ LT.lt 0 (HAdd.hAdd (expNegInvGlue x) (expNegInvGlue (HSub.hSub 1 x)))","decl":"theorem pos_denom (x) : 0 < expNegInvGlue x + expNegInvGlue (1 - x) :=\n  (zero_lt_one.lt_or_lt x).elim (fun hx => add_pos_of_pos_of_nonneg (pos_of_pos hx) (nonneg _))\n    fun hx => add_pos_of_nonneg_of_pos (nonneg _) (pos_of_pos <| sub_pos.2 hx)\n\n"}
{"name":"Real.smoothTransition.one_of_one_le","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\nh : LE.le 1 x\n‚ä¢ Eq x.smoothTransition 1","decl":"theorem one_of_one_le (h : 1 ‚â§ x) : smoothTransition x = 1 :=\n  (div_eq_one_iff_eq <| (pos_denom x).ne').2 <| by rw [zero_of_nonpos (sub_nonpos.2 h), add_zero]\n\n"}
{"name":"Real.smoothTransition.zero_iff_nonpos","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\n‚ä¢ Iff (Eq x.smoothTransition 0) (LE.le x 0)","decl":"@[simp]\nnonrec theorem zero_iff_nonpos : smoothTransition x = 0 ‚Üî x ‚â§ 0 := by\n  simp only [smoothTransition, _root_.div_eq_zero_iff, (pos_denom x).ne', zero_iff_nonpos, or_false]\n\n"}
{"name":"Real.smoothTransition.zero_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\nh : LE.le x 0\n‚ä¢ Eq x.smoothTransition 0","decl":"theorem zero_of_nonpos (h : x ‚â§ 0) : smoothTransition x = 0 := zero_iff_nonpos.2 h\n\n"}
{"name":"Real.smoothTransition.zero","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"‚ä¢ Eq (Real.smoothTransition 0) 0","decl":"@[simp]\nprotected theorem zero : smoothTransition 0 = 0 :=\n  zero_of_nonpos le_rfl\n\n"}
{"name":"Real.smoothTransition.one","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"‚ä¢ Eq (Real.smoothTransition 1) 1","decl":"@[simp]\nprotected theorem one : smoothTransition 1 = 1 :=\n  one_of_one_le le_rfl\n\n"}
{"name":"Real.smoothTransition.projIcc","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\n‚ä¢ Eq (‚Üë(Set.projIcc 0 1 ‚ãØ x)).smoothTransition x.smoothTransition","decl":"/-- Since `Real.smoothTransition` is constant on $(-‚àû, 0]$ and $[1, ‚àû)$, applying it to the\nprojection of `x : ‚Ñù` to $[0, 1]$ gives the same result as applying it to `x`. -/\n@[simp]\nprotected theorem projIcc :\n    smoothTransition (projIcc (0 : ‚Ñù) 1 zero_le_one x) = smoothTransition x := by\n  refine congr_fun\n    (IccExtend_eq_self zero_le_one smoothTransition (fun x hx => ?_) fun x hx => ?_) x\n  ¬∑ rw [smoothTransition.zero, zero_of_nonpos hx.le]\n  ¬∑ rw [smoothTransition.one, one_of_one_le hx.le]\n\n"}
{"name":"Real.smoothTransition.le_one","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\n‚ä¢ LE.le x.smoothTransition 1","decl":"theorem le_one (x : ‚Ñù) : smoothTransition x ‚â§ 1 :=\n  (div_le_one (pos_denom x)).2 <| le_add_of_nonneg_right (nonneg _)\n\n"}
{"name":"Real.smoothTransition.nonneg","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\n‚ä¢ LE.le 0 x.smoothTransition","decl":"theorem nonneg (x : ‚Ñù) : 0 ‚â§ smoothTransition x :=\n  div_nonneg (expNegInvGlue.nonneg _) (pos_denom x).le\n\n"}
{"name":"Real.smoothTransition.lt_one_of_lt_one","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\nh : LT.lt x 1\n‚ä¢ LT.lt x.smoothTransition 1","decl":"theorem lt_one_of_lt_one (h : x < 1) : smoothTransition x < 1 :=\n  (div_lt_one <| pos_denom x).2 <| lt_add_of_pos_right _ <| pos_of_pos <| sub_pos.2 h\n\n"}
{"name":"Real.smoothTransition.pos_of_pos","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\nh : LT.lt 0 x\n‚ä¢ LT.lt 0 x.smoothTransition","decl":"theorem pos_of_pos (h : 0 < x) : 0 < smoothTransition x :=\n  div_pos (expNegInvGlue.pos_of_pos h) (pos_denom x)\n\n"}
{"name":"Real.smoothTransition.contDiff","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"n : ENat\n‚ä¢ ContDiff Real (‚Üën) Real.smoothTransition","decl":"protected theorem contDiff {n : ‚Ñï‚àû} : ContDiff ‚Ñù n smoothTransition :=\n  expNegInvGlue.contDiff.div\n    (expNegInvGlue.contDiff.add <| expNegInvGlue.contDiff.comp <| contDiff_const.sub contDiff_id)\n    fun x => (pos_denom x).ne'\n\n"}
{"name":"Real.smoothTransition.contDiffAt","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\nn : ENat\n‚ä¢ ContDiffAt Real (‚Üën) Real.smoothTransition x","decl":"protected theorem contDiffAt {x : ‚Ñù} {n : ‚Ñï‚àû} : ContDiffAt ‚Ñù n smoothTransition x :=\n  smoothTransition.contDiff.contDiffAt\n\n"}
{"name":"Real.smoothTransition.continuous","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"‚ä¢ Continuous Real.smoothTransition","decl":"protected theorem continuous : Continuous smoothTransition :=\n  (@smoothTransition.contDiff 0).continuous\n\n"}
{"name":"Real.smoothTransition.continuousAt","module":"Mathlib.Analysis.SpecialFunctions.SmoothTransition","initialProofState":"x : Real\n‚ä¢ ContinuousAt Real.smoothTransition x","decl":"protected theorem continuousAt : ContinuousAt smoothTransition x :=\n  smoothTransition.continuous.continuousAt\n\n"}
