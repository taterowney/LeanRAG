{"name":"PowerSeries.instNontrivial","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Nontrivial R\n⊢ Nontrivial (PowerSeries R)","decl":"instance [Nontrivial R] : Nontrivial R⟦X⟧ := by\n  dsimp only [PowerSeries]\n  infer_instance\n\n"}
{"name":"PowerSeries.instIsScalarTower","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nS : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R A\ninst✝² : Module S A\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S A\n⊢ IsScalarTower R S (PowerSeries A)","decl":"instance {A S} [Semiring R] [Semiring S] [AddCommMonoid A] [Module R A] [Module S A] [SMul R S]\n    [IsScalarTower R S A] : IsScalarTower R S A⟦X⟧ :=\n  Pi.isScalarTower\n\n"}
{"name":"PowerSeries.coeff_def","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Finsupp Unit Nat\nn : Nat\nh : Eq (s Unit.unit) n\n⊢ Eq (PowerSeries.coeff R n) (MvPowerSeries.coeff R s)","decl":"theorem coeff_def {s : Unit →₀ ℕ} {n : ℕ} (h : s () = n) : coeff R n = MvPowerSeries.coeff R s := by\n  rw [coeff, ← h, ← Finsupp.unique_single s]\n\n"}
{"name":"PowerSeries.ext_iff","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ ψ : PowerSeries R\n⊢ Iff (Eq φ ψ) (∀ (n : Nat), Eq ((PowerSeries.coeff R n) φ) ((PowerSeries.coeff R n) ψ))","decl":"/-- Two formal power series are equal if all their coefficients are equal. -/\n@[ext]\ntheorem ext {φ ψ : R⟦X⟧} (h : ∀ n, coeff R n φ = coeff R n ψ) : φ = ψ :=\n  MvPowerSeries.ext fun n => by\n    rw [← coeff_def]\n    · apply h\n    rfl\n\n"}
{"name":"PowerSeries.ext","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ ψ : PowerSeries R\nh : ∀ (n : Nat), Eq ((PowerSeries.coeff R n) φ) ((PowerSeries.coeff R n) ψ)\n⊢ Eq φ ψ","decl":"/-- Two formal power series are equal if all their coefficients are equal. -/\n@[ext]\ntheorem ext {φ ψ : R⟦X⟧} (h : ∀ n, coeff R n φ = coeff R n ψ) : φ = ψ :=\n  MvPowerSeries.ext fun n => by\n    rw [← coeff_def]\n    · apply h\n    rfl\n\n"}
{"name":"PowerSeries.forall_coeff_eq_zero","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Iff (∀ (n : Nat), Eq ((PowerSeries.coeff R n) φ) 0) (Eq φ 0)","decl":"@[simp]\ntheorem forall_coeff_eq_zero (φ : R⟦X⟧) : (∀ n, coeff R n φ = 0) ↔ φ = 0 :=\n  ⟨fun h => ext h, fun h => by simp [h]⟩\n\n"}
{"name":"PowerSeries.instSubsingleton","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Subsingleton R\n⊢ Subsingleton (PowerSeries R)","decl":"instance [Subsingleton R] : Subsingleton R⟦X⟧ := by\n  simp only [subsingleton_iff, PowerSeries.ext_iff]\n  subsingleton\n\n"}
{"name":"PowerSeries.coeff_mk","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nf : Nat → R\n⊢ Eq ((PowerSeries.coeff R n) (PowerSeries.mk f)) (f n)","decl":"@[simp]\ntheorem coeff_mk (n : ℕ) (f : ℕ → R) : coeff R n (mk f) = f n :=\n  congr_arg f Finsupp.single_eq_same\n\n"}
{"name":"PowerSeries.coeff_monomial","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nm n : Nat\na : R\n⊢ Eq ((PowerSeries.coeff R m) ((PowerSeries.monomial R n) a)) (ite (Eq m n) a 0)","decl":"theorem coeff_monomial (m n : ℕ) (a : R) : coeff R m (monomial R n a) = if m = n then a else 0 :=\n  calc\n    coeff R m (monomial R n a) = _ := MvPowerSeries.coeff_monomial _ _ _\n    _ = if m = n then a else 0 := by simp only [Finsupp.unique_single_eq_iff]\n\n"}
{"name":"PowerSeries.monomial_eq_mk","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\na : R\n⊢ Eq ((PowerSeries.monomial R n) a) (PowerSeries.mk fun m => ite (Eq m n) a 0)","decl":"theorem monomial_eq_mk (n : ℕ) (a : R) : monomial R n a = mk fun m => if m = n then a else 0 :=\n  ext fun m => by rw [coeff_monomial, coeff_mk]\n\n"}
{"name":"PowerSeries.coeff_monomial_same","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\na : R\n⊢ Eq ((PowerSeries.coeff R n) ((PowerSeries.monomial R n) a)) a","decl":"@[simp]\ntheorem coeff_monomial_same (n : ℕ) (a : R) : coeff R n (monomial R n a) = a :=\n  MvPowerSeries.coeff_monomial_same _ _\n\n"}
{"name":"PowerSeries.coeff_comp_monomial","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n).comp (PowerSeries.monomial R n)) LinearMap.id","decl":"@[simp]\ntheorem coeff_comp_monomial (n : ℕ) : (coeff R n).comp (monomial R n) = LinearMap.id :=\n  LinearMap.ext <| coeff_monomial_same n\n\n"}
{"name":"PowerSeries.algebraMap_eq","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_2\ninst✝ : CommSemiring R\n⊢ Eq (algebraMap R (PowerSeries R)) (PowerSeries.C R)","decl":"@[simp] lemma algebraMap_eq {R : Type*} [CommSemiring R] : algebraMap R R⟦X⟧ = C R := rfl\n\n"}
{"name":"PowerSeries.commute_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Commute φ PowerSeries.X","decl":"theorem commute_X (φ : R⟦X⟧) : Commute φ X :=\n  MvPowerSeries.commute_X _ _\n\n"}
{"name":"PowerSeries.coeff_zero_eq_constantCoeff","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ⇑(PowerSeries.coeff R 0) ⇑(PowerSeries.constantCoeff R)","decl":"@[simp]\ntheorem coeff_zero_eq_constantCoeff : ⇑(coeff R 0) = constantCoeff R := by\n  rw [coeff, Finsupp.single_zero]\n  rfl\n\n"}
{"name":"PowerSeries.coeff_zero_eq_constantCoeff_apply","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R 0) φ) ((PowerSeries.constantCoeff R) φ)","decl":"theorem coeff_zero_eq_constantCoeff_apply (φ : R⟦X⟧) : coeff R 0 φ = constantCoeff R φ := by\n  rw [coeff_zero_eq_constantCoeff]\n\n"}
{"name":"PowerSeries.monomial_zero_eq_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ⇑(PowerSeries.monomial R 0) ⇑(PowerSeries.C R)","decl":"@[simp]\ntheorem monomial_zero_eq_C : ⇑(monomial R 0) = C R := by\n  -- This used to be `rw`, but we need `rw; rfl` after https://github.com/leanprover/lean4/pull/2644\n  rw [monomial, Finsupp.single_zero, MvPowerSeries.monomial_zero_eq_C]\n  rfl\n\n"}
{"name":"PowerSeries.monomial_zero_eq_C_apply","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\n⊢ Eq ((PowerSeries.monomial R 0) a) ((PowerSeries.C R) a)","decl":"theorem monomial_zero_eq_C_apply (a : R) : monomial R 0 a = C R a := by simp\n\n"}
{"name":"PowerSeries.coeff_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\na : R\n⊢ Eq ((PowerSeries.coeff R n) ((PowerSeries.C R) a)) (ite (Eq n 0) a 0)","decl":"theorem coeff_C (n : ℕ) (a : R) : coeff R n (C R a : R⟦X⟧) = if n = 0 then a else 0 := by\n  rw [← monomial_zero_eq_C_apply, coeff_monomial]\n\n"}
{"name":"PowerSeries.coeff_zero_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\n⊢ Eq ((PowerSeries.coeff R 0) ((PowerSeries.C R) a)) a","decl":"@[simp]\ntheorem coeff_zero_C (a : R) : coeff R 0 (C R a) = a := by\n  rw [coeff_C, if_pos rfl]\n\n"}
{"name":"PowerSeries.coeff_ne_zero_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\nn : Nat\nh : Ne n 0\n⊢ Eq ((PowerSeries.coeff R n) ((PowerSeries.C R) a)) 0","decl":"theorem coeff_ne_zero_C {a : R} {n : ℕ} (h : n ≠ 0) : coeff R n (C R a) = 0 := by\n  rw [coeff_C, if_neg h]\n\n"}
{"name":"PowerSeries.coeff_succ_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R (HAdd.hAdd n 1)) ((PowerSeries.C R) a)) 0","decl":"@[simp]\ntheorem coeff_succ_C {a : R} {n : ℕ} : coeff R (n + 1) (C R a) = 0 :=\n  coeff_ne_zero_C n.succ_ne_zero\n\n"}
{"name":"PowerSeries.C_injective","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Function.Injective ⇑(PowerSeries.C R)","decl":"theorem C_injective : Function.Injective (C R) := by\n  intro a b H\n  simp_rw [PowerSeries.ext_iff] at H\n  simpa only [coeff_zero_C] using H 0\n\n"}
{"name":"PowerSeries.subsingleton_iff","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Iff (Subsingleton (PowerSeries R)) (Subsingleton R)","decl":"protected theorem subsingleton_iff : Subsingleton R⟦X⟧ ↔ Subsingleton R := by\n  refine ⟨fun h ↦ ?_, fun _ ↦ inferInstance⟩\n  rw [subsingleton_iff] at h ⊢\n  exact fun a b ↦ C_injective (h (C R a) (C R b))\n\n"}
{"name":"PowerSeries.X_eq","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq PowerSeries.X ((PowerSeries.monomial R 1) 1)","decl":"theorem X_eq : (X : R⟦X⟧) = monomial R 1 1 :=\n  rfl\n\n"}
{"name":"PowerSeries.coeff_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) PowerSeries.X) (ite (Eq n 1) 1 0)","decl":"theorem coeff_X (n : ℕ) : coeff R n (X : R⟦X⟧) = if n = 1 then 1 else 0 := by\n  rw [X_eq, coeff_monomial]\n\n"}
{"name":"PowerSeries.coeff_zero_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((PowerSeries.coeff R 0) PowerSeries.X) 0","decl":"@[simp]\ntheorem coeff_zero_X : coeff R 0 (X : R⟦X⟧) = 0 := by\n  rw [coeff, Finsupp.single_zero, X, MvPowerSeries.coeff_zero_X]\n\n"}
{"name":"PowerSeries.coeff_one_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((PowerSeries.coeff R 1) PowerSeries.X) 1","decl":"@[simp]\ntheorem coeff_one_X : coeff R 1 (X : R⟦X⟧) = 1 := by rw [coeff_X, if_pos rfl]\n\n"}
{"name":"PowerSeries.X_ne_zero","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\n⊢ Ne PowerSeries.X 0","decl":"@[simp]\ntheorem X_ne_zero [Nontrivial R] : (X : R⟦X⟧) ≠ 0 := fun H => by\n  simpa only [coeff_one_X, one_ne_zero, map_zero] using congr_arg (coeff R 1) H\n\n"}
{"name":"PowerSeries.X_pow_eq","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (HPow.hPow PowerSeries.X n) ((PowerSeries.monomial R n) 1)","decl":"theorem X_pow_eq (n : ℕ) : (X : R⟦X⟧) ^ n = monomial R n 1 :=\n  MvPowerSeries.X_pow_eq _ n\n\n"}
{"name":"PowerSeries.coeff_X_pow","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nm n : Nat\n⊢ Eq ((PowerSeries.coeff R m) (HPow.hPow PowerSeries.X n)) (ite (Eq m n) 1 0)","decl":"theorem coeff_X_pow (m n : ℕ) : coeff R m ((X : R⟦X⟧) ^ n) = if m = n then 1 else 0 := by\n  rw [X_pow_eq, coeff_monomial]\n\n"}
{"name":"PowerSeries.coeff_X_pow_self","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) (HPow.hPow PowerSeries.X n)) 1","decl":"@[simp]\ntheorem coeff_X_pow_self (n : ℕ) : coeff R n ((X : R⟦X⟧) ^ n) = 1 := by\n  rw [coeff_X_pow, if_pos rfl]\n\n"}
{"name":"PowerSeries.coeff_one","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) 1) (ite (Eq n 0) 1 0)","decl":"@[simp]\ntheorem coeff_one (n : ℕ) : coeff R n (1 : R⟦X⟧) = if n = 0 then 1 else 0 :=\n  coeff_C n 1\n\n"}
{"name":"PowerSeries.coeff_zero_one","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((PowerSeries.coeff R 0) 1) 1","decl":"theorem coeff_zero_one : coeff R 0 (1 : R⟦X⟧) = 1 :=\n  coeff_zero_C 1\n\n"}
{"name":"PowerSeries.coeff_mul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nφ ψ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R n) (HMul.hMul φ ψ)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => HMul.hMul ((PowerSeries.coeff R p.1) φ) ((PowerSeries.coeff R p.2) ψ))","decl":"theorem coeff_mul (n : ℕ) (φ ψ : R⟦X⟧) :\n    coeff R n (φ * ψ) = ∑ p ∈ antidiagonal n, coeff R p.1 φ * coeff R p.2 ψ := by\n  -- `rw` can't see that `PowerSeries = MvPowerSeries Unit`, so use `.trans`\n  refine (MvPowerSeries.coeff_mul _ φ ψ).trans ?_\n  rw [Finsupp.antidiagonal_single, Finset.sum_map]\n  rfl\n\n"}
{"name":"PowerSeries.coeff_mul_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nφ : PowerSeries R\na : R\n⊢ Eq ((PowerSeries.coeff R n) (HMul.hMul φ ((PowerSeries.C R) a))) (HMul.hMul ((PowerSeries.coeff R n) φ) a)","decl":"@[simp]\ntheorem coeff_mul_C (n : ℕ) (φ : R⟦X⟧) (a : R) : coeff R n (φ * C R a) = coeff R n φ * a :=\n  MvPowerSeries.coeff_mul_C _ φ a\n\n"}
{"name":"PowerSeries.coeff_C_mul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nφ : PowerSeries R\na : R\n⊢ Eq ((PowerSeries.coeff R n) (HMul.hMul ((PowerSeries.C R) a) φ)) (HMul.hMul a ((PowerSeries.coeff R n) φ))","decl":"@[simp]\ntheorem coeff_C_mul (n : ℕ) (φ : R⟦X⟧) (a : R) : coeff R n (C R a * φ) = a * coeff R n φ :=\n  MvPowerSeries.coeff_C_mul _ φ a\n\n"}
{"name":"PowerSeries.coeff_smul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\ninst✝¹ : Semiring S\ninst✝ : Module R S\nn : Nat\nφ : PowerSeries S\na : R\n⊢ Eq ((PowerSeries.coeff S n) (HSMul.hSMul a φ)) (HSMul.hSMul a ((PowerSeries.coeff S n) φ))","decl":"@[simp]\ntheorem coeff_smul {S : Type*} [Semiring S] [Module R S] (n : ℕ) (φ : PowerSeries S) (a : R) :\n    coeff S n (a • φ) = a • coeff S n φ :=\n  rfl\n\n"}
{"name":"PowerSeries.constantCoeff_smul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\ninst✝¹ : Semiring S\ninst✝ : Module R S\nφ : PowerSeries S\na : R\n⊢ Eq ((PowerSeries.constantCoeff S) (HSMul.hSMul a φ)) (HSMul.hSMul a ((PowerSeries.constantCoeff S) φ))","decl":"@[simp]\ntheorem constantCoeff_smul {S : Type*} [Semiring S] [Module R S] (φ : PowerSeries S) (a : R) :\n    constantCoeff S (a • φ) = a • constantCoeff S φ :=\n  rfl\n\n"}
{"name":"PowerSeries.smul_eq_C_mul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : PowerSeries R\na : R\n⊢ Eq (HSMul.hSMul a f) (HMul.hMul ((PowerSeries.C R) a) f)","decl":"theorem smul_eq_C_mul (f : R⟦X⟧) (a : R) : a • f = C R a * f := by\n  ext\n  simp\n\n"}
{"name":"PowerSeries.coeff_succ_mul_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nφ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R (HAdd.hAdd n 1)) (HMul.hMul φ PowerSeries.X)) ((PowerSeries.coeff R n) φ)","decl":"@[simp]\ntheorem coeff_succ_mul_X (n : ℕ) (φ : R⟦X⟧) : coeff R (n + 1) (φ * X) = coeff R n φ := by\n  simp only [coeff, Finsupp.single_add]\n  convert φ.coeff_add_mul_monomial (single () n) (single () 1) _\n  rw [mul_one]\n\n"}
{"name":"PowerSeries.coeff_succ_X_mul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nφ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R (HAdd.hAdd n 1)) (HMul.hMul PowerSeries.X φ)) ((PowerSeries.coeff R n) φ)","decl":"@[simp]\ntheorem coeff_succ_X_mul (n : ℕ) (φ : R⟦X⟧) : coeff R (n + 1) (X * φ) = coeff R n φ := by\n  simp only [coeff, Finsupp.single_add, add_comm n 1]\n  convert φ.coeff_add_monomial_mul (single () 1) (single () n) _\n  rw [one_mul]\n\n"}
{"name":"PowerSeries.constantCoeff_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\n⊢ Eq ((PowerSeries.constantCoeff R) ((PowerSeries.C R) a)) a","decl":"@[simp]\ntheorem constantCoeff_C (a : R) : constantCoeff R (C R a) = a :=\n  rfl\n\n"}
{"name":"PowerSeries.constantCoeff_comp_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((PowerSeries.constantCoeff R).comp (PowerSeries.C R)) (RingHom.id R)","decl":"@[simp]\ntheorem constantCoeff_comp_C : (constantCoeff R).comp (C R) = RingHom.id R :=\n  rfl\n\n"}
{"name":"PowerSeries.constantCoeff_zero","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((PowerSeries.constantCoeff R) 0) 0","decl":"@[simp]\ntheorem constantCoeff_zero : constantCoeff R 0 = 0 :=\n  rfl\n\n"}
{"name":"PowerSeries.constantCoeff_one","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((PowerSeries.constantCoeff R) 1) 1","decl":"@[simp]\ntheorem constantCoeff_one : constantCoeff R 1 = 1 :=\n  rfl\n\n"}
{"name":"PowerSeries.constantCoeff_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((PowerSeries.constantCoeff R) PowerSeries.X) 0","decl":"@[simp]\ntheorem constantCoeff_X : constantCoeff R X = 0 :=\n  MvPowerSeries.coeff_zero_X _\n\n"}
{"name":"PowerSeries.constantCoeff_mk","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Nat → R\n⊢ Eq ((PowerSeries.constantCoeff R) (PowerSeries.mk f)) (f 0)","decl":"@[simp]\ntheorem constantCoeff_mk {f : ℕ → R} : constantCoeff R (mk f) = f 0 := rfl\n\n"}
{"name":"PowerSeries.coeff_zero_mul_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R 0) (HMul.hMul φ PowerSeries.X)) 0","decl":"theorem coeff_zero_mul_X (φ : R⟦X⟧) : coeff R 0 (φ * X) = 0 := by simp\n\n"}
{"name":"PowerSeries.coeff_zero_X_mul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R 0) (HMul.hMul PowerSeries.X φ)) 0","decl":"theorem coeff_zero_X_mul (φ : R⟦X⟧) : coeff R 0 (X * φ) = 0 := by simp\n\n"}
{"name":"PowerSeries.constantCoeff_surj","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Function.Surjective ⇑(PowerSeries.constantCoeff R)","decl":"theorem constantCoeff_surj : Function.Surjective (constantCoeff R) :=\n  fun r => ⟨(C R) r, constantCoeff_C r⟩\n\n-- The following section duplicates the API of `Data.Polynomial.Coeff` and should attempt to keep\n-- up to date with that\n"}
{"name":"PowerSeries.coeff_C_mul_X_pow","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : R\nk n : Nat\n⊢ Eq ((PowerSeries.coeff R n) (HMul.hMul ((PowerSeries.C R) x) (HPow.hPow PowerSeries.X k))) (ite (Eq n k) x 0)","decl":"theorem coeff_C_mul_X_pow (x : R) (k n : ℕ) :\n    coeff R n (C R x * X ^ k : R⟦X⟧) = if n = k then x else 0 := by\n  simp [X_pow_eq, coeff_monomial]\n\n"}
{"name":"PowerSeries.coeff_mul_X_pow","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : PowerSeries R\nn d : Nat\n⊢ Eq ((PowerSeries.coeff R (HAdd.hAdd d n)) (HMul.hMul p (HPow.hPow PowerSeries.X n))) ((PowerSeries.coeff R d) p)","decl":"@[simp]\ntheorem coeff_mul_X_pow (p : R⟦X⟧) (n d : ℕ) :\n    coeff R (d + n) (p * X ^ n) = coeff R d p := by\n  rw [coeff_mul, Finset.sum_eq_single (d, n), coeff_X_pow, if_pos rfl, mul_one]\n  · rintro ⟨i, j⟩ h1 h2\n    rw [coeff_X_pow, if_neg, mul_zero]\n    rintro rfl\n    apply h2\n    rw [mem_antidiagonal, add_right_cancel_iff] at h1\n    subst h1\n    rfl\n  · exact fun h1 => (h1 (mem_antidiagonal.2 rfl)).elim\n\n"}
{"name":"PowerSeries.coeff_X_pow_mul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : PowerSeries R\nn d : Nat\n⊢ Eq ((PowerSeries.coeff R (HAdd.hAdd d n)) (HMul.hMul (HPow.hPow PowerSeries.X n) p)) ((PowerSeries.coeff R d) p)","decl":"@[simp]\ntheorem coeff_X_pow_mul (p : R⟦X⟧) (n d : ℕ) :\n    coeff R (d + n) (X ^ n * p) = coeff R d p := by\n  rw [coeff_mul, Finset.sum_eq_single (n, d), coeff_X_pow, if_pos rfl, one_mul]\n  · rintro ⟨i, j⟩ h1 h2\n    rw [coeff_X_pow, if_neg, zero_mul]\n    rintro rfl\n    apply h2\n    rw [mem_antidiagonal, add_comm, add_right_cancel_iff] at h1\n    subst h1\n    rfl\n  · rw [add_comm]\n    exact fun h1 => (h1 (mem_antidiagonal.2 rfl)).elim\n\n"}
{"name":"PowerSeries.coeff_mul_X_pow'","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : PowerSeries R\nn d : Nat\n⊢ Eq ((PowerSeries.coeff R d) (HMul.hMul p (HPow.hPow PowerSeries.X n))) (ite (LE.le n d) ((PowerSeries.coeff R (HSub.hSub d n)) p) 0)","decl":"theorem coeff_mul_X_pow' (p : R⟦X⟧) (n d : ℕ) :\n    coeff R d (p * X ^ n) = ite (n ≤ d) (coeff R (d - n) p) 0 := by\n  split_ifs with h\n  · rw [← tsub_add_cancel_of_le h, coeff_mul_X_pow, add_tsub_cancel_right]\n  · refine (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => ?_)\n    rw [coeff_X_pow, if_neg, mul_zero]\n    exact ((le_of_add_le_right (mem_antidiagonal.mp hx).le).trans_lt <| not_le.mp h).ne\n\n"}
{"name":"PowerSeries.coeff_X_pow_mul'","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : PowerSeries R\nn d : Nat\n⊢ Eq ((PowerSeries.coeff R d) (HMul.hMul (HPow.hPow PowerSeries.X n) p)) (ite (LE.le n d) ((PowerSeries.coeff R (HSub.hSub d n)) p) 0)","decl":"theorem coeff_X_pow_mul' (p : R⟦X⟧) (n d : ℕ) :\n    coeff R d (X ^ n * p) = ite (n ≤ d) (coeff R (d - n) p) 0 := by\n  split_ifs with h\n  · rw [← tsub_add_cancel_of_le h, coeff_X_pow_mul]\n    simp\n  · refine (coeff_mul _ _ _).trans (Finset.sum_eq_zero fun x hx => ?_)\n    rw [coeff_X_pow, if_neg, zero_mul]\n    have := mem_antidiagonal.mp hx\n    rw [add_comm] at this\n    exact ((le_of_add_le_right this.le).trans_lt <| not_le.mp h).ne\n\n"}
{"name":"PowerSeries.isUnit_constantCoeff","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\nh : IsUnit φ\n⊢ IsUnit ((PowerSeries.constantCoeff R) φ)","decl":"/-- If a formal power series is invertible, then so is its constant coefficient. -/\ntheorem isUnit_constantCoeff (φ : R⟦X⟧) (h : IsUnit φ) : IsUnit (constantCoeff R φ) :=\n  MvPowerSeries.isUnit_constantCoeff φ h\n\n"}
{"name":"PowerSeries.eq_shift_mul_X_add_const","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Eq φ (HAdd.hAdd (HMul.hMul (PowerSeries.mk fun p => (PowerSeries.coeff R (HAdd.hAdd p 1)) φ) PowerSeries.X) ((PowerSeries.C R) ((PowerSeries.constantCoeff R) φ)))","decl":"/-- Split off the constant coefficient. -/\ntheorem eq_shift_mul_X_add_const (φ : R⟦X⟧) :\n    φ = (mk fun p => coeff R (p + 1) φ) * X + C R (constantCoeff R φ) := by\n  ext (_ | n)\n  · simp only [coeff_zero_eq_constantCoeff, map_add, map_mul, constantCoeff_X,\n      mul_zero, coeff_zero_C, zero_add]\n  · simp only [coeff_succ_mul_X, coeff_mk, LinearMap.map_add, coeff_C, n.succ_ne_zero, sub_zero,\n      if_false, add_zero]\n\n"}
{"name":"PowerSeries.eq_X_mul_shift_add_const","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Eq φ (HAdd.hAdd (HMul.hMul PowerSeries.X (PowerSeries.mk fun p => (PowerSeries.coeff R (HAdd.hAdd p 1)) φ)) ((PowerSeries.C R) ((PowerSeries.constantCoeff R) φ)))","decl":"/-- Split off the constant coefficient. -/\ntheorem eq_X_mul_shift_add_const (φ : R⟦X⟧) :\n    φ = (X * mk fun p => coeff R (p + 1) φ) + C R (constantCoeff R φ) := by\n  ext (_ | n)\n  · simp only [coeff_zero_eq_constantCoeff, map_add, map_mul, constantCoeff_X,\n      zero_mul, coeff_zero_C, zero_add]\n  · simp only [coeff_succ_X_mul, coeff_mk, LinearMap.map_add, coeff_C, n.succ_ne_zero, sub_zero,\n      if_false, add_zero]\n\n"}
{"name":"PowerSeries.map_id","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (⇑(PowerSeries.map (RingHom.id R))) id","decl":"@[simp]\ntheorem map_id : (map (RingHom.id R) : R⟦X⟧ → R⟦X⟧) = id :=\n  rfl\n\n"}
{"name":"PowerSeries.map_comp","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\nT : Type u_3\ninst✝¹ : Semiring S\ninst✝ : Semiring T\nf : RingHom R S\ng : RingHom S T\n⊢ Eq (PowerSeries.map (g.comp f)) ((PowerSeries.map g).comp (PowerSeries.map f))","decl":"theorem map_comp : map (g.comp f) = (map g).comp (map f) :=\n  rfl\n\n"}
{"name":"PowerSeries.coeff_map","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Type u_2\ninst✝ : Semiring S\nf : RingHom R S\nn : Nat\nφ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff S n) ((PowerSeries.map f) φ)) (f ((PowerSeries.coeff R n) φ))","decl":"@[simp]\ntheorem coeff_map (n : ℕ) (φ : R⟦X⟧) : coeff S n (map f φ) = f (coeff R n φ) :=\n  rfl\n\n"}
{"name":"PowerSeries.map_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Type u_2\ninst✝ : Semiring S\nf : RingHom R S\nr : R\n⊢ Eq ((PowerSeries.map f) ((PowerSeries.C R) r)) ((PowerSeries.C S) (f r))","decl":"@[simp]\ntheorem map_C (r : R) : map f (C _ r) = C _ (f r) := by\n  ext\n  simp [coeff_C, apply_ite f]\n\n"}
{"name":"PowerSeries.map_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Type u_2\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq ((PowerSeries.map f) PowerSeries.X) PowerSeries.X","decl":"@[simp]\ntheorem map_X : map f X = X := by\n  ext\n  simp [coeff_X, apply_ite f]\n\n"}
{"name":"PowerSeries.X_pow_dvd_iff","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nφ : PowerSeries R\n⊢ Iff (Dvd.dvd (HPow.hPow PowerSeries.X n) φ) (∀ (m : Nat), LT.lt m n → Eq ((PowerSeries.coeff R m) φ) 0)","decl":"theorem X_pow_dvd_iff {n : ℕ} {φ : R⟦X⟧} :\n    (X : R⟦X⟧) ^ n ∣ φ ↔ ∀ m, m < n → coeff R m φ = 0 := by\n  convert@MvPowerSeries.X_pow_dvd_iff Unit R _ () n φ\n  constructor <;> intro h m hm\n  · rw [Finsupp.unique_single m]\n    convert h _ hm\n  · apply h\n    simpa only [Finsupp.single_eq_same] using hm\n\n"}
{"name":"PowerSeries.X_dvd_iff","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Iff (Dvd.dvd PowerSeries.X φ) (Eq ((PowerSeries.constantCoeff R) φ) 0)","decl":"theorem X_dvd_iff {φ : R⟦X⟧} : (X : R⟦X⟧) ∣ φ ↔ constantCoeff R φ = 0 := by\n  rw [← pow_one (X : R⟦X⟧), X_pow_dvd_iff, ← coeff_zero_eq_constantCoeff_apply]\n  constructor <;> intro h\n  · exact h 0 zero_lt_one\n  · intro m hm\n    rwa [Nat.eq_zero_of_le_zero (Nat.le_of_succ_le_succ hm)]\n\n"}
{"name":"PowerSeries.coeff_rescale","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : PowerSeries R\na : R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) ((PowerSeries.rescale a) f)) (HMul.hMul (HPow.hPow a n) ((PowerSeries.coeff R n) f))","decl":"@[simp]\ntheorem coeff_rescale (f : R⟦X⟧) (a : R) (n : ℕ) :\n    coeff R n (rescale a f) = a ^ n * coeff R n f :=\n  coeff_mk n (fun n ↦ a ^ n * (coeff R n) f)\n\n"}
{"name":"PowerSeries.rescale_zero","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (PowerSeries.rescale 0) ((PowerSeries.C R).comp (PowerSeries.constantCoeff R))","decl":"@[simp]\ntheorem rescale_zero : rescale 0 = (C R).comp (constantCoeff R) := by\n  ext x n\n  simp only [Function.comp_apply, RingHom.coe_comp, rescale, RingHom.coe_mk,\n    PowerSeries.coeff_mk _ _, coeff_C]\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"PowerSeries.rescale_zero_apply","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq ((PowerSeries.rescale 0) PowerSeries.X) ((PowerSeries.C R) ((PowerSeries.constantCoeff R) PowerSeries.X))","decl":"theorem rescale_zero_apply : rescale 0 X = C R (constantCoeff R X) := by simp\n\n"}
{"name":"PowerSeries.rescale_one","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (PowerSeries.rescale 1) (RingHom.id (PowerSeries R))","decl":"@[simp]\ntheorem rescale_one : rescale 1 = RingHom.id R⟦X⟧ := by\n  ext\n  simp only [coeff_rescale, one_pow, one_mul, RingHom.id_apply]\n\n"}
{"name":"PowerSeries.rescale_mk","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : Nat → R\na : R\n⊢ Eq ((PowerSeries.rescale a) (PowerSeries.mk f)) (PowerSeries.mk fun n => HMul.hMul (HPow.hPow a n) (f n))","decl":"theorem rescale_mk (f : ℕ → R) (a : R) : rescale a (mk f) = mk fun n : ℕ => a ^ n * f n := by\n  ext\n  rw [coeff_rescale, coeff_mk, coeff_mk]\n\n"}
{"name":"PowerSeries.rescale_rescale","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nf : PowerSeries R\na b : R\n⊢ Eq ((PowerSeries.rescale b) ((PowerSeries.rescale a) f)) ((PowerSeries.rescale (HMul.hMul a b)) f)","decl":"theorem rescale_rescale (f : R⟦X⟧) (a b : R) :\n    rescale b (rescale a f) = rescale (a * b) f := by\n  ext n\n  simp_rw [coeff_rescale]\n  rw [mul_pow, mul_comm _ (b ^ n), mul_assoc]\n\n"}
{"name":"PowerSeries.rescale_mul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\na b : R\n⊢ Eq (PowerSeries.rescale (HMul.hMul a b)) ((PowerSeries.rescale b).comp (PowerSeries.rescale a))","decl":"theorem rescale_mul (a b : R) : rescale (a * b) = (rescale b).comp (rescale a) := by\n  ext\n  simp [← rescale_rescale]\n\n"}
{"name":"PowerSeries.coeff_prod","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_2\ninst✝¹ : CommSemiring R\nι : Type u_3\ninst✝ : DecidableEq ι\nf : ι → PowerSeries R\nd : Nat\ns : Finset ι\n⊢ Eq ((PowerSeries.coeff R d) (s.prod fun j => f j)) ((s.finsuppAntidiag d).sum fun l => s.prod fun i => (PowerSeries.coeff R (l i)) (f i))","decl":"/-- Coefficients of a product of power series -/\ntheorem coeff_prod (f : ι → PowerSeries R) (d : ℕ) (s : Finset ι) :\n    coeff R d (∏ j ∈ s, f j) = ∑ l ∈ finsuppAntidiag s d, ∏ i ∈ s, coeff R (l i) (f i) := by\n  simp only [coeff]\n  rw [MvPowerSeries.coeff_prod, ← AddEquiv.finsuppUnique_symm d, ← mapRange_finsuppAntidiag_eq,\n    sum_map, sum_congr rfl]\n  intro x _\n  apply prod_congr rfl\n  intro i _\n  congr 2\n  simp only [AddEquiv.toEquiv_eq_coe, Finsupp.mapRange.addEquiv_toEquiv, AddEquiv.toEquiv_symm,\n    Equiv.coe_toEmbedding, Finsupp.mapRange.equiv_apply, AddEquiv.coe_toEquiv_symm,\n    Finsupp.mapRange_apply, AddEquiv.finsuppUnique_symm]\n\n"}
{"name":"PowerSeries.coeff_pow","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_2\ninst✝ : CommSemiring R\nk n : Nat\nφ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R n) (HPow.hPow φ k)) (((Finset.range k).finsuppAntidiag n).sum fun l => (Finset.range k).prod fun i => (PowerSeries.coeff R (l i)) φ)","decl":"/-- The `n`-th coefficient of the `k`-th power of a power series. -/\nlemma coeff_pow (k n : ℕ) (φ : R⟦X⟧) :\n    coeff R n (φ ^ k) = ∑ l ∈ finsuppAntidiag (range k) n, ∏ i ∈ range k, coeff R (l i) φ := by\n  have h₁ (i : ℕ) : Function.const ℕ φ i = φ := rfl\n  have h₂ (i : ℕ) : ∏ j ∈ range i, Function.const ℕ φ j = φ ^ i := by\n    apply prod_range_induction (fun _ => φ) (fun i => φ ^ i) rfl (congrFun rfl) i\n  rw [← h₂, ← h₁ k]\n  apply coeff_prod (f := Function.const ℕ φ) (d := n) (s := range k)\n\n"}
{"name":"PowerSeries.coeff_one_mul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_2\ninst✝ : CommSemiring R\nφ ψ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R 1) (HMul.hMul φ ψ)) (HAdd.hAdd (HMul.hMul ((PowerSeries.coeff R 1) φ) ((PowerSeries.constantCoeff R) ψ)) (HMul.hMul ((PowerSeries.coeff R 1) ψ) ((PowerSeries.constantCoeff R) φ)))","decl":"/-- First coefficient of the product of two power series. -/\nlemma coeff_one_mul (φ ψ : R⟦X⟧) : coeff R 1 (φ * ψ) =\n    coeff R 1 φ * constantCoeff R ψ + coeff R 1 ψ * constantCoeff R φ := by\n  have : Finset.antidiagonal 1 = {(0, 1), (1, 0)} := by exact rfl\n  rw [coeff_mul, this, Finset.sum_insert, Finset.sum_singleton, coeff_zero_eq_constantCoeff,\n    mul_comm, add_comm]\n  norm_num\n\n"}
{"name":"PowerSeries.coeff_one_pow","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_2\ninst✝ : CommSemiring R\nn : Nat\nφ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R 1) (HPow.hPow φ n)) (HMul.hMul (HMul.hMul (↑n) ((PowerSeries.coeff R 1) φ)) (HPow.hPow ((PowerSeries.constantCoeff R) φ) (HSub.hSub n 1)))","decl":"/-- First coefficient of the `n`-th power of a power series. -/\nlemma coeff_one_pow (n : ℕ) (φ : R⟦X⟧) :\n    coeff R 1 (φ ^ n) = n * coeff R 1 φ * (constantCoeff R φ) ^ (n - 1) := by\n  rcases Nat.eq_zero_or_pos n with (rfl | hn)\n  · simp\n  induction n with\n  | zero => omega\n  | succ n' ih =>\n      have h₁ (m : ℕ) : φ ^ (m + 1) = φ ^ m * φ := by exact rfl\n      have h₂ : Finset.antidiagonal 1 = {(0, 1), (1, 0)} := by exact rfl\n      rw [h₁, coeff_mul, h₂, Finset.sum_insert, Finset.sum_singleton]\n      · simp only [coeff_zero_eq_constantCoeff, map_pow, Nat.cast_add, Nat.cast_one,\n          add_tsub_cancel_right]\n        have h₀ : n' = 0 ∨ 1 ≤ n' := by omega\n        rcases h₀ with h' | h'\n        · by_contra h''\n          rw [h'] at h''\n          simp only [pow_zero, one_mul, coeff_one, one_ne_zero, ↓reduceIte, zero_mul, add_zero,\n            CharP.cast_eq_zero, zero_add, mul_one, not_true_eq_false] at h''\n          norm_num at h''\n        · rw [ih]\n          · conv => lhs; arg 2; rw [mul_comm, ← mul_assoc]\n            move_mul [← (constantCoeff R) φ ^ (n' - 1)]\n            conv => enter [1, 2, 1, 1, 2]; rw [← pow_one (a := constantCoeff R φ)]\n            rw [← pow_add (a := constantCoeff R φ)]\n            conv => enter [1, 2, 1, 1]; rw [Nat.sub_add_cancel h']\n            conv => enter [1, 2, 1]; rw [mul_comm]\n            rw [mul_assoc, ← one_add_mul, add_comm, mul_assoc]\n            conv => enter [1, 2]; rw [mul_comm]\n          exact h'\n      · decide\n\n"}
{"name":"PowerSeries.not_isField","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"A : Type u_2\ninst✝ : CommRing A\n⊢ Not (IsField (PowerSeries A))","decl":"theorem not_isField : ¬IsField A⟦X⟧ := by\n  by_cases hA : Subsingleton A\n  · exact not_isField_of_subsingleton _\n  · nontriviality A\n    rw [Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top]\n    use Ideal.span {X}\n    constructor\n    · rw [bot_lt_iff_ne_bot, Ne, Ideal.span_singleton_eq_bot]\n      exact X_ne_zero\n    · rw [lt_top_iff_ne_top, Ne, Ideal.eq_top_iff_one, Ideal.mem_span_singleton,\n        X_dvd_iff, constantCoeff_one]\n      exact one_ne_zero\n\n"}
{"name":"PowerSeries.rescale_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"A : Type u_2\ninst✝ : CommRing A\na : A\n⊢ Eq ((PowerSeries.rescale a) PowerSeries.X) (HMul.hMul ((PowerSeries.C A) a) PowerSeries.X)","decl":"@[simp]\ntheorem rescale_X (a : A) : rescale a X = C A a * X := by\n  ext\n  simp only [coeff_rescale, coeff_C_mul, coeff_X]\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"PowerSeries.rescale_neg_one_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"A : Type u_2\ninst✝ : CommRing A\n⊢ Eq ((PowerSeries.rescale (-1)) PowerSeries.X) (Neg.neg PowerSeries.X)","decl":"theorem rescale_neg_one_X : rescale (-1 : A) X = -X := by\n  rw [rescale_X, map_neg, map_one, neg_one_mul]\n\n"}
{"name":"PowerSeries.evalNegHom_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"A : Type u_2\ninst✝ : CommRing A\n⊢ Eq (PowerSeries.evalNegHom PowerSeries.X) (Neg.neg PowerSeries.X)","decl":"@[simp]\ntheorem evalNegHom_X : evalNegHom (X : A⟦X⟧) = -X :=\n  rescale_neg_one_X\n\n"}
{"name":"PowerSeries.eq_zero_or_eq_zero_of_mul_eq_zero","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : NoZeroDivisors R\nφ ψ : PowerSeries R\nh : Eq (HMul.hMul φ ψ) 0\n⊢ Or (Eq φ 0) (Eq ψ 0)","decl":"theorem eq_zero_or_eq_zero_of_mul_eq_zero [NoZeroDivisors R] (φ ψ : R⟦X⟧) (h : φ * ψ = 0) :\n    φ = 0 ∨ ψ = 0 := by\n  classical\n  rw [or_iff_not_imp_left]\n  intro H\n  have ex : ∃ m, coeff R m φ ≠ 0 := by\n    contrapose! H\n    exact ext H\n  let m := Nat.find ex\n  have hm₁ : coeff R m φ ≠ 0 := Nat.find_spec ex\n  have hm₂ : ∀ k < m, ¬coeff R k φ ≠ 0 := fun k => Nat.find_min ex\n  ext n\n  rw [(coeff R n).map_zero]\n  induction' n using Nat.strong_induction_on with n ih\n  replace h := congr_arg (coeff R (m + n)) h\n  rw [LinearMap.map_zero, coeff_mul, Finset.sum_eq_single (m, n)] at h\n  · replace h := NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero h\n    rw [or_iff_not_imp_left] at h\n    exact h hm₁\n  · rintro ⟨i, j⟩ hij hne\n    by_cases hj : j < n\n    · rw [ih j hj, mul_zero]\n    by_cases hi : i < m\n    · specialize hm₂ _ hi\n      push_neg at hm₂\n      rw [hm₂, zero_mul]\n    rw [mem_antidiagonal] at hij\n    push_neg at hi hj\n    suffices m < i by\n      have : m + n < i + j := add_lt_add_of_lt_of_le this hj\n      exfalso\n      exact ne_of_lt this hij.symm\n    contrapose! hne\n    obtain rfl := le_antisymm hi hne\n    simpa [Ne, Prod.mk.inj_iff] using (add_right_inj m).mp hij\n  · contrapose!\n    intro\n    rw [mem_antidiagonal]\n\n"}
{"name":"PowerSeries.instNoZeroDivisors","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : NoZeroDivisors R\n⊢ NoZeroDivisors (PowerSeries R)","decl":"instance [NoZeroDivisors R] : NoZeroDivisors R⟦X⟧ where\n  eq_zero_or_eq_zero_of_mul_eq_zero := eq_zero_or_eq_zero_of_mul_eq_zero _ _\n\n"}
{"name":"PowerSeries.instIsDomain","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : IsDomain R\n⊢ IsDomain (PowerSeries R)","decl":"instance [IsDomain R] : IsDomain R⟦X⟧ :=\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"PowerSeries.span_X_isPrime","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ (Ideal.span (Singleton.singleton PowerSeries.X)).IsPrime","decl":"/-- The ideal spanned by the variable in the power series ring\n over an integral domain is a prime ideal. -/\ntheorem span_X_isPrime : (Ideal.span ({X} : Set R⟦X⟧)).IsPrime := by\n  suffices Ideal.span ({X} : Set R⟦X⟧) = RingHom.ker (constantCoeff R) by\n    rw [this]\n    exact RingHom.ker_isPrime _\n  apply Ideal.ext\n  intro φ\n  rw [RingHom.mem_ker, Ideal.mem_span_singleton, X_dvd_iff]\n\n"}
{"name":"PowerSeries.X_prime","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Prime PowerSeries.X","decl":"/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem X_prime : Prime (X : R⟦X⟧) := by\n  rw [← Ideal.span_singleton_prime]\n  · exact span_X_isPrime\n  · intro h\n    simpa [map_zero (coeff R 1)] using congr_arg (coeff R 1) h\n\n"}
{"name":"PowerSeries.X_irreducible","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Irreducible PowerSeries.X","decl":"/-- The variable of the power series ring over an integral domain is irreducible. -/\ntheorem X_irreducible : Irreducible (X : R⟦X⟧) := X_prime.irreducible\n\n"}
{"name":"PowerSeries.rescale_injective","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\na : R\nha : Ne a 0\n⊢ Function.Injective ⇑(PowerSeries.rescale a)","decl":"theorem rescale_injective {a : R} (ha : a ≠ 0) : Function.Injective (rescale a) := by\n  intro p q h\n  rw [PowerSeries.ext_iff] at *\n  intro n\n  specialize h n\n  rw [coeff_rescale, coeff_rescale, mul_eq_mul_left_iff] at h\n  apply h.resolve_right\n  intro h'\n  exact ha (pow_eq_zero h')\n\n"}
{"name":"PowerSeries.C_eq_algebraMap","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nr : R\n⊢ Eq ((PowerSeries.C R) r) ((algebraMap R (PowerSeries R)) r)","decl":"theorem C_eq_algebraMap {r : R} : C R r = (algebraMap R R⟦X⟧) r :=\n  rfl\n\n"}
{"name":"PowerSeries.algebraMap_apply","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Eq ((algebraMap R (PowerSeries A)) r) ((PowerSeries.C A) ((algebraMap R A) r))","decl":"theorem algebraMap_apply {r : R} : algebraMap R A⟦X⟧ r = C A (algebraMap R A r) :=\n  MvPowerSeries.algebraMap_apply\n\n"}
{"name":"PowerSeries.instNontrivialSubalgebra","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Nontrivial (Subalgebra R (PowerSeries R))","decl":"instance [Nontrivial R] : Nontrivial (Subalgebra R R⟦X⟧) :=\n  { inferInstanceAs <| Nontrivial <| Subalgebra R <| MvPowerSeries Unit R with }\n\n"}
{"name":"Polynomial.coe_def","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ : Polynomial R\n⊢ Eq (↑φ) (PowerSeries.mk φ.coeff)","decl":"theorem coe_def : (φ : PowerSeries R) = PowerSeries.mk (coeff φ) :=\n  rfl\n\n"}
{"name":"Polynomial.coeff_coe","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ : Polynomial R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) ↑φ) (φ.coeff n)","decl":"@[simp, norm_cast]\ntheorem coeff_coe (n) : PowerSeries.coeff R n φ = coeff φ n :=\n  congr_arg (coeff φ) Finsupp.single_eq_same\n\n"}
{"name":"Polynomial.coe_monomial","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nn : Nat\na : R\n⊢ Eq (↑((Polynomial.monomial n) a)) ((PowerSeries.monomial R n) a)","decl":"@[simp, norm_cast]\ntheorem coe_monomial (n : ℕ) (a : R) :\n    (monomial n a : PowerSeries R) = PowerSeries.monomial R n a := by\n  ext\n  simp [coeff_coe, PowerSeries.coeff_monomial, Polynomial.coeff_monomial, eq_comm]\n\n"}
{"name":"Polynomial.coe_zero","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : R[X]) : PowerSeries R) = 0 :=\n  rfl\n\n"}
{"name":"Polynomial.coe_one","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ((1 : R[X]) : PowerSeries R) = 1 := by\n  have := coe_monomial 0 (1 : R)\n  rwa [PowerSeries.monomial_zero_eq_C_apply] at this\n\n"}
{"name":"Polynomial.coe_add","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ ψ : Polynomial R\n⊢ Eq (↑(HAdd.hAdd φ ψ)) (HAdd.hAdd ↑φ ↑ψ)","decl":"@[simp, norm_cast]\ntheorem coe_add : ((φ + ψ : R[X]) : PowerSeries R) = φ + ψ := by\n  ext\n  simp\n\n"}
{"name":"Polynomial.coe_mul","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ ψ : Polynomial R\n⊢ Eq (↑(HMul.hMul φ ψ)) (HMul.hMul ↑φ ↑ψ)","decl":"@[simp, norm_cast]\ntheorem coe_mul : ((φ * ψ : R[X]) : PowerSeries R) = φ * ψ :=\n  PowerSeries.ext fun n => by simp only [coeff_coe, PowerSeries.coeff_mul, coeff_mul]\n\n"}
{"name":"Polynomial.coe_C","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\na : R\n⊢ Eq (↑(Polynomial.C a)) ((PowerSeries.C R) a)","decl":"@[simp, norm_cast]\ntheorem coe_C (a : R) : ((C a : R[X]) : PowerSeries R) = PowerSeries.C R a := by\n  have := coe_monomial 0 a\n  rwa [PowerSeries.monomial_zero_eq_C_apply] at this\n\n"}
{"name":"Polynomial.coe_X","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (↑Polynomial.X) PowerSeries.X","decl":"@[simp, norm_cast]\ntheorem coe_X : ((X : R[X]) : PowerSeries R) = PowerSeries.X :=\n  coe_monomial _ _\n\n"}
{"name":"Polynomial.constantCoeff_coe","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ : Polynomial R\n⊢ Eq ((PowerSeries.constantCoeff R) ↑φ) (φ.coeff 0)","decl":"@[simp]\ntheorem constantCoeff_coe : PowerSeries.constantCoeff R φ = φ.coeff 0 :=\n  rfl\n\n"}
{"name":"Polynomial.coe_injective","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Function.Injective Coe.coe","decl":"theorem coe_injective : Function.Injective (Coe.coe : R[X] → PowerSeries R) := fun x y h => by\n  ext\n  simp_rw [← coeff_coe]\n  congr\n\n"}
{"name":"Polynomial.coe_inj","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ ψ : Polynomial R\n⊢ Iff (Eq ↑φ ↑ψ) (Eq φ ψ)","decl":"@[simp, norm_cast]\ntheorem coe_inj : (φ : PowerSeries R) = ψ ↔ φ = ψ :=\n  (coe_injective R).eq_iff\n\n"}
{"name":"Polynomial.coe_eq_zero_iff","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ : Polynomial R\n⊢ Iff (Eq (↑φ) 0) (Eq φ 0)","decl":"@[simp]\ntheorem coe_eq_zero_iff : (φ : PowerSeries R) = 0 ↔ φ = 0 := by rw [← coe_zero, coe_inj]\n\n"}
{"name":"Polynomial.coe_eq_one_iff","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ : Polynomial R\n⊢ Iff (Eq (↑φ) 1) (Eq φ 1)","decl":"@[simp]\ntheorem coe_eq_one_iff : (φ : PowerSeries R) = 1 ↔ φ = 1 := by rw [← coe_one, coe_inj]\n\n"}
{"name":"Polynomial.coeToPowerSeries.ringHom_apply","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ : Polynomial R\n⊢ Eq (Polynomial.coeToPowerSeries.ringHom φ) ↑φ","decl":"@[simp]\ntheorem coeToPowerSeries.ringHom_apply : coeToPowerSeries.ringHom φ = φ :=\n  rfl\n\n"}
{"name":"Polynomial.coe_pow","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ : Polynomial R\nn : Nat\n⊢ Eq (↑(HPow.hPow φ n)) (HPow.hPow (↑φ) n)","decl":"@[simp, norm_cast]\ntheorem coe_pow (n : ℕ) : ((φ ^ n : R[X]) : PowerSeries R) = (φ : PowerSeries R) ^ n :=\n  coeToPowerSeries.ringHom.map_pow _ _\n\n"}
{"name":"Polynomial.eval₂_C_X_eq_coe","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ : Polynomial R\n⊢ Eq (Polynomial.eval₂ (PowerSeries.C R) PowerSeries.X φ) ↑φ","decl":"theorem eval₂_C_X_eq_coe : φ.eval₂ (PowerSeries.C R) PowerSeries.X = ↑φ := by\n  nth_rw 2 [← eval₂_C_X (p := φ)]\n  rw [← coeToPowerSeries.ringHom_apply, eval₂_eq_sum_range, eval₂_eq_sum_range, map_sum]\n  apply Finset.sum_congr rfl\n  intros\n  rw [map_mul, map_pow, coeToPowerSeries.ringHom_apply,\n    coeToPowerSeries.ringHom_apply, coe_C, coe_X]\n\n"}
{"name":"Polynomial.coeToPowerSeries.algHom_apply","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nφ : Polynomial R\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq ((Polynomial.coeToPowerSeries.algHom A) φ) ((PowerSeries.map (algebraMap R A)) ↑φ)","decl":"@[simp]\ntheorem coeToPowerSeries.algHom_apply :\n    coeToPowerSeries.algHom A φ = PowerSeries.map (algebraMap R A) ↑φ :=\n  rfl\n\n"}
{"name":"Polynomial.coe_neg","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np : Polynomial R\n⊢ Eq (↑(Neg.neg p)) (Neg.neg ↑p)","decl":"@[simp, norm_cast]\nlemma coe_neg (p : R[X]) : ((- p : R[X]) : PowerSeries R) = - p :=\n  coeToPowerSeries.ringHom.map_neg p\n\n"}
{"name":"Polynomial.coe_sub","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np q : Polynomial R\n⊢ Eq (↑(HSub.hSub p q)) (HSub.hSub ↑p ↑q)","decl":"@[simp, norm_cast]\nlemma coe_sub (p q : R[X]) : ((p - q : R[X]) : PowerSeries R) = p - q :=\n  coeToPowerSeries.ringHom.map_sub p q\n\n"}
{"name":"PowerSeries.algebraMap_apply'","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\np : Polynomial R\n⊢ Eq ((algebraMap (Polynomial R) (PowerSeries A)) p) ((PowerSeries.map (algebraMap R A)) ↑p)","decl":"theorem algebraMap_apply' (p : R[X]) : algebraMap R[X] A⟦X⟧ p = map (algebraMap R A) p :=\n  rfl\n\n"}
{"name":"PowerSeries.algebraMap_apply''","module":"Mathlib.RingTheory.PowerSeries.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nf : PowerSeries R\n⊢ Eq ((algebraMap (PowerSeries R) (PowerSeries A)) f) ((PowerSeries.map (algebraMap R A)) f)","decl":"theorem algebraMap_apply'' :\n    algebraMap R⟦X⟧ A⟦X⟧ f = map (algebraMap R A) f :=\n  rfl\n\n"}
