{"name":"SimpleGraph.le_egirth","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG : SimpleGraph α\nn : ENat\n⊢ Iff (LE.le n G.egirth) (∀ (a : α) (w : G.Walk a a), w.IsCycle → LE.le n ↑w.length)","decl":"@[simp]\nlemma le_egirth {n : ℕ∞} : n ≤ G.egirth ↔ ∀ a (w : G.Walk a a), w.IsCycle → n ≤ w.length := by\n  simp [egirth]\n\n"}
{"name":"SimpleGraph.egirth_eq_top","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ Iff (Eq G.egirth Top.top) G.IsAcyclic","decl":"@[simp]\nlemma egirth_eq_top : G.egirth = ⊤ ↔ G.IsAcyclic := by simp [egirth, IsAcyclic]\n\n"}
{"name":"SimpleGraph.IsAcyclic.egirth_eq_top","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG : SimpleGraph α\na✝ : G.IsAcyclic\n⊢ Eq G.egirth Top.top","decl":"protected alias ⟨_, IsAcyclic.egirth_eq_top⟩ := egirth_eq_top\n\n"}
{"name":"SimpleGraph.egirth_anti","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\n⊢ Antitone SimpleGraph.egirth","decl":"lemma egirth_anti : Antitone (egirth : SimpleGraph α → ℕ∞) :=\n  fun G H h ↦ iInf_mono fun a ↦ iInf₂_mono' fun w hw ↦ ⟨w.mapLe h, hw.mapLe _, by simp⟩\n\n"}
{"name":"SimpleGraph.exists_egirth_eq_length","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ Iff (Exists fun a => Exists fun w => And w.IsCycle (Eq G.egirth ↑w.length)) (Not G.IsAcyclic)","decl":"lemma exists_egirth_eq_length :\n    (∃ (a : α) (w : G.Walk a a), w.IsCycle ∧ G.egirth = w.length) ↔ ¬ G.IsAcyclic := by\n  refine ⟨?_, fun h ↦ ?_⟩\n  · rintro ⟨a, w, hw, _⟩ hG\n    exact hG _ hw\n  · simp_rw [← egirth_eq_top, ← Ne.eq_def, egirth, iInf_subtype', iInf_sigma', ENat.iInf_coe_ne_top,\n      ← exists_prop, Subtype.exists', Sigma.exists', eq_comm] at h ⊢\n    exact ciInf_mem _\n\n"}
{"name":"SimpleGraph.three_le_egirth","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ LE.le 3 G.egirth","decl":"lemma three_le_egirth : 3 ≤ G.egirth := by\n  by_cases h : G.IsAcyclic\n  · rw [← egirth_eq_top] at h\n    rw [h]\n    apply le_top\n  · rw [← exists_egirth_eq_length] at h\n    have ⟨_, _, _⟩ := h\n    simp_all only [Nat.cast_inj, Nat.ofNat_le_cast, Walk.IsCycle.three_le_length]\n\n"}
{"name":"SimpleGraph.egirth_bot","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\n⊢ Eq Bot.bot.egirth Top.top","decl":"@[simp] lemma egirth_bot : egirth (⊥ : SimpleGraph α) = ⊤ := by simp\n\n"}
{"name":"SimpleGraph.three_le_girth","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG : SimpleGraph α\nhG : Not G.IsAcyclic\n⊢ LE.le 3 G.girth","decl":"lemma three_le_girth (hG : ¬ G.IsAcyclic) : 3 ≤ G.girth :=\n  ENat.toNat_le_toNat three_le_egirth <| egirth_eq_top.not.mpr hG\n\n"}
{"name":"SimpleGraph.girth_eq_zero","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ Iff (Eq G.girth 0) G.IsAcyclic","decl":"lemma girth_eq_zero : G.girth = 0 ↔ G.IsAcyclic :=\n  ⟨fun h ↦ not_not.mp <| three_le_girth.mt <| by omega, fun h ↦ by simp [girth, h]⟩\n\n"}
{"name":"SimpleGraph.IsAcyclic.girth_eq_zero","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG : SimpleGraph α\na✝ : G.IsAcyclic\n⊢ Eq G.girth 0","decl":"protected alias ⟨_, IsAcyclic.girth_eq_zero⟩ := girth_eq_zero\n\n"}
{"name":"SimpleGraph.girth_anti","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG G' : SimpleGraph α\nhab : LE.le G G'\nh : Not G.IsAcyclic\n⊢ LE.le G'.girth G.girth","decl":"lemma girth_anti {G' : SimpleGraph α} (hab : G ≤ G') (h : ¬ G.IsAcyclic) : G'.girth ≤ G.girth :=\n  ENat.toNat_le_toNat (egirth_anti hab) <| egirth_eq_top.not.mpr h\n\n"}
{"name":"SimpleGraph.exists_girth_eq_length","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\nG : SimpleGraph α\n⊢ Iff (Exists fun a => Exists fun w => And w.IsCycle (Eq G.girth w.length)) (Not G.IsAcyclic)","decl":"lemma exists_girth_eq_length :\n    (∃ (a : α) (w : G.Walk a a), w.IsCycle ∧ G.girth = w.length) ↔ ¬ G.IsAcyclic := by\n  refine ⟨by tauto, fun h ↦ ?_⟩\n  obtain ⟨_, _, _⟩ := exists_egirth_eq_length.mpr h\n  simp_all only [girth, ENat.toNat_coe]\n  tauto\n\n"}
{"name":"SimpleGraph.girth_bot","module":"Mathlib.Combinatorics.SimpleGraph.Girth","initialProofState":"α : Type u_1\n⊢ Eq Bot.bot.girth 0","decl":"@[simp] lemma girth_bot : girth (⊥ : SimpleGraph α) = 0 := by\n  simp [girth]\n\n"}
