{"name":"logDeriv_apply","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : ğ•œ â†’ ğ•œ'\nx : ğ•œ\nâŠ¢ Eq (logDeriv f x) (HDiv.hDiv (deriv f x) (f x))","decl":"theorem logDeriv_apply (f : ğ•œ â†’ ğ•œ') (x : ğ•œ) : logDeriv f x = deriv f x / f x := rfl\n\n"}
{"name":"logDeriv_eq_zero_of_not_differentiableAt","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : ğ•œ â†’ ğ•œ'\nx : ğ•œ\nh : Not (DifferentiableAt ğ•œ f x)\nâŠ¢ Eq (logDeriv f x) 0","decl":"lemma logDeriv_eq_zero_of_not_differentiableAt (f : ğ•œ â†’ ğ•œ') (x : ğ•œ) (h : Â¬DifferentiableAt ğ•œ f x) :\n    logDeriv f x = 0 := by\n  simp only [logDeriv_apply, deriv_zero_of_not_differentiableAt h, zero_div]\n\n"}
{"name":"logDeriv_id","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nâŠ¢ Eq (logDeriv id x) (HDiv.hDiv 1 x)","decl":"@[simp]\ntheorem logDeriv_id (x : ğ•œ) : logDeriv id x = 1 / x := by\n  simp [logDeriv_apply]\n\n"}
{"name":"logDeriv_id'","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nâŠ¢ Eq (logDeriv (fun x => x) x) (HDiv.hDiv 1 x)","decl":"@[simp] theorem logDeriv_id' (x : ğ•œ) : logDeriv (Â·) x = 1 / x := logDeriv_id x\n\n"}
{"name":"logDeriv_const","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\na : ğ•œ'\nâŠ¢ Eq (logDeriv fun x => a) 0","decl":"@[simp]\ntheorem logDeriv_const (a : ğ•œ') : logDeriv (fun _ : ğ•œ â†¦ a) = 0 := by\n  ext\n  simp [logDeriv_apply]\n\n"}
{"name":"logDeriv_mul","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf g : ğ•œ â†’ ğ•œ'\nx : ğ•œ\nhf : Ne (f x) 0\nhg : Ne (g x) 0\nhdf : DifferentiableAt ğ•œ f x\nhdg : DifferentiableAt ğ•œ g x\nâŠ¢ Eq (logDeriv (fun z => HMul.hMul (f z) (g z)) x) (HAdd.hAdd (logDeriv f x) (logDeriv g x))","decl":"theorem logDeriv_mul {f g : ğ•œ â†’ ğ•œ'} (x : ğ•œ) (hf : f x â‰  0) (hg : g x â‰  0)\n    (hdf : DifferentiableAt ğ•œ f x) (hdg : DifferentiableAt ğ•œ g x) :\n      logDeriv (fun z => f z * g z) x = logDeriv f x + logDeriv g x := by\n  simp only [logDeriv_apply, deriv_mul hdf hdg]\n  field_simp [mul_comm]\n\n"}
{"name":"logDeriv_div","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf g : ğ•œ â†’ ğ•œ'\nx : ğ•œ\nhf : Ne (f x) 0\nhg : Ne (g x) 0\nhdf : DifferentiableAt ğ•œ f x\nhdg : DifferentiableAt ğ•œ g x\nâŠ¢ Eq (logDeriv (fun z => HDiv.hDiv (f z) (g z)) x) (HSub.hSub (logDeriv f x) (logDeriv g x))","decl":"theorem logDeriv_div {f g : ğ•œ â†’ ğ•œ'} (x : ğ•œ) (hf : f x â‰  0) (hg : g x â‰  0)\n    (hdf : DifferentiableAt ğ•œ f x) (hdg : DifferentiableAt ğ•œ g x) :\n    logDeriv (fun z => f z / g z) x = logDeriv f x - logDeriv g x := by\n  simp only [logDeriv_apply, deriv_div hdf hdg]\n  field_simp [mul_comm]\n  ring\n\n"}
{"name":"logDeriv_mul_const","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : ğ•œ â†’ ğ•œ'\nx : ğ•œ\na : ğ•œ'\nha : Ne a 0\nâŠ¢ Eq (logDeriv (fun z => HMul.hMul (f z) a) x) (logDeriv f x)","decl":"theorem logDeriv_mul_const {f : ğ•œ â†’ ğ•œ'} (x : ğ•œ) (a : ğ•œ') (ha : a â‰  0):\n    logDeriv (fun z => f z * a) x = logDeriv f x := by\n  simp only [logDeriv_apply, deriv_mul_const_field, mul_div_mul_right _ _ ha]\n\n"}
{"name":"logDeriv_const_mul","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : ğ•œ â†’ ğ•œ'\nx : ğ•œ\na : ğ•œ'\nha : Ne a 0\nâŠ¢ Eq (logDeriv (fun z => HMul.hMul a (f z)) x) (logDeriv f x)","decl":"theorem logDeriv_const_mul {f : ğ•œ â†’ ğ•œ'} (x : ğ•œ) (a : ğ•œ') (ha : a â‰  0):\n    logDeriv (fun z => a * f z) x = logDeriv f x := by\n  simp only [logDeriv_apply, deriv_const_mul_field, mul_div_mul_left _ _ ha]\n\n"}
{"name":"logDeriv_prod","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nÎ¹ : Type u_3\ns : Finset Î¹\nf : Î¹ â†’ ğ•œ â†’ ğ•œ'\nx : ğ•œ\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ Ne (f i x) 0\nhd : âˆ€ (i : Î¹), Membership.mem s i â†’ DifferentiableAt ğ•œ (f i) x\nâŠ¢ Eq (logDeriv (fun x => s.prod fun i => f i x) x) (s.sum fun i => logDeriv (f i) x)","decl":"/-- The logarithmic derivative of a finite product is the sum of the logarithmic derivatives. -/\ntheorem logDeriv_prod {Î¹ : Type*} (s : Finset Î¹) (f : Î¹ â†’ ğ•œ â†’ ğ•œ') (x : ğ•œ) (hf : âˆ€ i âˆˆ s, f i x â‰  0)\n    (hd : âˆ€ i âˆˆ s, DifferentiableAt ğ•œ (f i) x) :\n    logDeriv (âˆ i âˆˆ s, f i Â·) x = âˆ‘ i âˆˆ s, logDeriv (f i) x := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons a s ha ih =>\n    rw [Finset.forall_mem_cons] at hf hd\n    simp_rw [Finset.prod_cons, Finset.sum_cons]\n    rw [logDeriv_mul, ih hf.2 hd.2]\n    Â· exact hf.1\n    Â· simpa [Finset.prod_eq_zero_iff] using hf.2\n    Â· exact hd.1\n    Â· exact .finset_prod hd.2\n\n"}
{"name":"logDeriv_fun_zpow","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : ğ•œ â†’ ğ•œ'\nx : ğ•œ\nhdf : DifferentiableAt ğ•œ f x\nn : Int\nâŠ¢ Eq (logDeriv (fun x => HPow.hPow (f x) n) x) (HMul.hMul (â†‘n) (logDeriv f x))","decl":"lemma logDeriv_fun_zpow {f : ğ•œ â†’ ğ•œ'} {x : ğ•œ} (hdf : DifferentiableAt ğ•œ f x) (n : â„¤) :\n    logDeriv (f Â· ^ n) x = n * logDeriv f x := by\n  rcases eq_or_ne n 0 with rfl | hn; Â· simp\n  rcases eq_or_ne (f x) 0 with hf | hf\n  Â· simp [logDeriv_apply, zero_zpow, *]\n  Â· rw [logDeriv_apply, â† comp_def (Â·^n), deriv_comp _ (differentiableAt_zpow.2 <| .inl hf) hdf,\n      deriv_zpow, logDeriv_apply]\n    field_simp [zpow_ne_zero, zpow_sub_oneâ‚€ hf]\n    ring\n\n"}
{"name":"logDeriv_fun_pow","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : ğ•œ â†’ ğ•œ'\nx : ğ•œ\nhdf : DifferentiableAt ğ•œ f x\nn : Nat\nâŠ¢ Eq (logDeriv (fun x => HPow.hPow (f x) n) x) (HMul.hMul (â†‘n) (logDeriv f x))","decl":"lemma logDeriv_fun_pow {f : ğ•œ â†’ ğ•œ'} {x : ğ•œ} (hdf : DifferentiableAt ğ•œ f x) (n : â„•) :\n    logDeriv (f Â· ^ n) x = n * logDeriv f x :=\n  mod_cast logDeriv_fun_zpow hdf n\n\n"}
{"name":"logDeriv_zpow","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nn : Int\nâŠ¢ Eq (logDeriv (fun x => HPow.hPow x n) x) (HDiv.hDiv (â†‘n) x)","decl":"@[simp]\nlemma logDeriv_zpow (x : ğ•œ) (n : â„¤) : logDeriv (Â· ^ n) x = n / x := by\n  rw [logDeriv_fun_zpow (by fun_prop), logDeriv_id', mul_one_div]\n\n"}
{"name":"logDeriv_pow","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nn : Nat\nâŠ¢ Eq (logDeriv (fun x => HPow.hPow x n) x) (HDiv.hDiv (â†‘n) x)","decl":"@[simp]\nlemma logDeriv_pow (x : ğ•œ) (n : â„•) : logDeriv (Â· ^ n) x = n / x :=\n  mod_cast logDeriv_zpow x n\n\n"}
{"name":"logDeriv_inv","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nâŠ¢ Eq (logDeriv (fun x => Inv.inv x) x) (HDiv.hDiv (-1) x)","decl":"@[simp] lemma logDeriv_inv (x : ğ•œ) : logDeriv (Â·â»Â¹) x = -1 / x := by\n  simpa using logDeriv_zpow x (-1)\n\n"}
{"name":"logDeriv_comp","module":"Mathlib.Analysis.Calculus.LogDeriv","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NontriviallyNormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : ğ•œ' â†’ ğ•œ'\ng : ğ•œ â†’ ğ•œ'\nx : ğ•œ\nhf : DifferentiableAt ğ•œ' f (g x)\nhg : DifferentiableAt ğ•œ g x\nâŠ¢ Eq (logDeriv (Function.comp f g) x) (HMul.hMul (logDeriv f (g x)) (deriv g x))","decl":"theorem logDeriv_comp {f : ğ•œ' â†’ ğ•œ'} {g : ğ•œ â†’ ğ•œ'} {x : ğ•œ} (hf : DifferentiableAt ğ•œ' f (g x))\n    (hg : DifferentiableAt ğ•œ g x) : logDeriv (f âˆ˜ g) x = logDeriv f (g x) * deriv g x := by\n  simp only [logDeriv, Pi.div_apply, deriv_comp _ hf hg, comp_apply]\n  ring\n"}
