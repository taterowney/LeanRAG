{"name":"Submodule.Quotient.restrictScalarsEquiv_mk","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nS : Type u_3\ninst✝³ : Ring S\ninst✝² : SMul S R\ninst✝¹ : Module S M\ninst✝ : IsScalarTower S R M\nP : Submodule R M\nx : M\n⊢ Eq ((Submodule.Quotient.restrictScalarsEquiv S P) (Submodule.Quotient.mk x)) (Submodule.Quotient.mk x)","decl":"@[simp]\ntheorem restrictScalarsEquiv_mk [Ring S] [SMul S R] [Module S M] [IsScalarTower S R M]\n    (P : Submodule R M) (x : M) :\n    restrictScalarsEquiv S P (mk x) = mk x :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.restrictScalarsEquiv_symm_mk","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nS : Type u_3\ninst✝³ : Ring S\ninst✝² : SMul S R\ninst✝¹ : Module S M\ninst✝ : IsScalarTower S R M\nP : Submodule R M\nx : M\n⊢ Eq ((Submodule.Quotient.restrictScalarsEquiv S P).symm (Submodule.Quotient.mk x)) (Submodule.Quotient.mk x)","decl":"@[simp]\ntheorem restrictScalarsEquiv_symm_mk [Ring S] [SMul S R] [Module S M] [IsScalarTower S R M]\n    (P : Submodule R M) (x : M) :\n    (restrictScalarsEquiv S P).symm (mk x) = mk x :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.nontrivial_of_lt_top","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nh : LT.lt p Top.top\n⊢ Nontrivial (HasQuotient.Quotient M p)","decl":"theorem nontrivial_of_lt_top (h : p < ⊤) : Nontrivial (M ⧸ p) := by\n  obtain ⟨x, _, not_mem_s⟩ := SetLike.exists_of_lt h\n  refine ⟨⟨mk x, 0, ?_⟩⟩\n  simpa using not_mem_s\n\n"}
{"name":"Submodule.QuotientBot.infinite","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Infinite M\n⊢ Infinite (HasQuotient.Quotient M Bot.bot)","decl":"instance QuotientBot.infinite [Infinite M] : Infinite (M ⧸ (⊥ : Submodule R M)) :=\n  Infinite.of_injective Submodule.Quotient.mk fun _x _y h =>\n    sub_eq_zero.mp <| (Submodule.Quotient.eq ⊥).mp h\n\n"}
{"name":"Submodule.subsingleton_quotient_iff_eq_top","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Iff (Subsingleton (HasQuotient.Quotient M p)) (Eq p Top.top)","decl":"theorem subsingleton_quotient_iff_eq_top : Subsingleton (M ⧸ p) ↔ p = ⊤ := by\n  constructor\n  · rintro h\n    refine eq_top_iff.mpr fun x _ => ?_\n    have : x - 0 ∈ p := (Submodule.Quotient.eq p).mp (Subsingleton.elim _ _)\n    rwa [sub_zero] at this\n  · rintro rfl\n    infer_instance\n\n"}
{"name":"Submodule.unique_quotient_iff_eq_top","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Iff (Nonempty (Unique (HasQuotient.Quotient M p))) (Eq p Top.top)","decl":"theorem unique_quotient_iff_eq_top : Nonempty (Unique (M ⧸ p)) ↔ p = ⊤ :=\n  ⟨fun ⟨h⟩ => subsingleton_quotient_iff_eq_top.mp (@Unique.instSubsingleton _ h),\n    by rintro rfl; exact ⟨QuotientTop.unique⟩⟩\n\n"}
{"name":"Submodule.card_eq_card_quotient_mul_card","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS : Submodule R M\n⊢ Eq (Nat.card M) (HMul.hMul (Nat.card (Subtype fun x => Membership.mem S x)) (Nat.card (HasQuotient.Quotient M S)))","decl":"theorem card_eq_card_quotient_mul_card (S : Submodule R M) :\n    Nat.card M = Nat.card S * Nat.card (M ⧸ S) := by\n  rw [mul_comm, ← Nat.card_prod]\n  exact Nat.card_congr AddSubgroup.addGroupEquivQuotientProdAddSubgroup\n\n"}
{"name":"Submodule.strictMono_comap_prod_map","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ StrictMono fun m => { fst := Submodule.comap p.subtype m, snd := Submodule.map p.mkQ m }","decl":"theorem strictMono_comap_prod_map :\n    StrictMono fun m : Submodule R M ↦ (m.comap p.subtype, m.map p.mkQ) :=\n  fun m₁ m₂ ↦ QuotientAddGroup.strictMono_comap_prod_map\n    p.toAddSubgroup (a := m₁.toAddSubgroup) (b := m₂.toAddSubgroup)\n\n"}
{"name":"Submodule.liftQ_apply","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\nh : LE.le p (LinearMap.ker f)\nx : M\n⊢ Eq ((p.liftQ f h) (Submodule.Quotient.mk x)) (f x)","decl":"@[simp]\ntheorem liftQ_apply (f : M →ₛₗ[τ₁₂] M₂) {h} (x : M) : p.liftQ f h (Quotient.mk x) = f x :=\n  rfl\n\n"}
{"name":"Submodule.liftQ_mkQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\nh : LE.le p (LinearMap.ker f)\n⊢ Eq ((p.liftQ f h).comp p.mkQ) f","decl":"@[simp]\ntheorem liftQ_mkQ (f : M →ₛₗ[τ₁₂] M₂) (h) : (p.liftQ f h).comp p.mkQ = f := by ext; rfl\n\n"}
{"name":"Submodule.pi_liftQ_eq_liftQ_pi","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_5\nN : ι → Type u_6\ninst✝¹ : (i : ι) → AddCommGroup (N i)\ninst✝ : (i : ι) → Module R (N i)\nf : (i : ι) → LinearMap (RingHom.id R) M (N i)\np : Submodule R M\nh : ∀ (i : ι), LE.le p (LinearMap.ker (f i))\n⊢ Eq (LinearMap.pi fun i => p.liftQ (f i) ⋯) (p.liftQ (LinearMap.pi f) ⋯)","decl":"theorem pi_liftQ_eq_liftQ_pi {ι : Type*} {N : ι → Type*}\n    [∀ i, AddCommGroup (N i)] [∀ i, Module R (N i)]\n    (f : (i : ι) → M →ₗ[R] (N i)) {p : Submodule R M} (h : ∀ i, p ≤ ker (f i)) :\n    LinearMap.pi (fun i ↦ p.liftQ (f i) (h i)) =\n      p.liftQ (LinearMap.pi f) (LinearMap.ker_pi f ▸ le_iInf h) := by\n  ext x i\n  simp\n\n"}
{"name":"Submodule.liftQSpanSingleton_apply","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nx : M\nf : LinearMap τ₁₂ M M₂\nh : Eq (f x) 0\ny : M\n⊢ Eq ((Submodule.liftQSpanSingleton x f h) (Submodule.Quotient.mk y)) (f y)","decl":"@[simp]\ntheorem liftQSpanSingleton_apply (x : M) (f : M →ₛₗ[τ₁₂] M₂) (h : f x = 0) (y : M) :\n    liftQSpanSingleton x f h (Quotient.mk y) = f y :=\n  rfl\n\n"}
{"name":"Submodule.range_mkQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (LinearMap.range p.mkQ) Top.top","decl":"@[simp]\ntheorem range_mkQ : range p.mkQ = ⊤ :=\n  eq_top_iff'.2 <| by rintro ⟨x⟩; exact ⟨x, rfl⟩\n\n"}
{"name":"Submodule.ker_mkQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (LinearMap.ker p.mkQ) p","decl":"@[simp]\ntheorem ker_mkQ : ker p.mkQ = p := by ext; simp\n\n"}
{"name":"Submodule.le_comap_mkQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\np' : Submodule R (HasQuotient.Quotient M p)\n⊢ LE.le p (Submodule.comap p.mkQ p')","decl":"theorem le_comap_mkQ (p' : Submodule R (M ⧸ p)) : p ≤ comap p.mkQ p' := by\n  simpa using (comap_mono bot_le : ker p.mkQ ≤ comap p.mkQ p')\n\n"}
{"name":"Submodule.mkQ_map_self","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.map p.mkQ p) Bot.bot","decl":"@[simp]\ntheorem mkQ_map_self : map p.mkQ p = ⊥ := by\n  rw [eq_bot_iff, map_le_iff_le_comap, comap_bot, ker_mkQ]\n\n"}
{"name":"Submodule.comap_map_mkQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Eq (Submodule.comap p.mkQ (Submodule.map p.mkQ p')) (Max.max p p')","decl":"@[simp]\ntheorem comap_map_mkQ : comap p.mkQ (map p.mkQ p') = p ⊔ p' := by simp [comap_map_eq, sup_comm]\n\n"}
{"name":"Submodule.map_mkQ_eq_top","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Iff (Eq (Submodule.map p.mkQ p') Top.top) (Eq (Max.max p p') Top.top)","decl":"@[simp]\ntheorem map_mkQ_eq_top : map p.mkQ p' = ⊤ ↔ p ⊔ p' = ⊤ := by\n  -- Porting note: ambiguity of `map_eq_top_iff` is no longer automatically resolved by preferring\n  -- the current namespace\n  simp only [LinearMap.map_eq_top_iff p.range_mkQ, sup_comm, ker_mkQ]\n\n"}
{"name":"Submodule.mapQ_apply","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nq : Submodule R₂ M₂\nf : LinearMap τ₁₂ M M₂\nh : LE.le p (Submodule.comap f q)\nx : M\n⊢ Eq ((p.mapQ q f h) (Submodule.Quotient.mk x)) (Submodule.Quotient.mk (f x))","decl":"@[simp]\ntheorem mapQ_apply (f : M →ₛₗ[τ₁₂] M₂) {h} (x : M) :\n    mapQ p q f h (Quotient.mk x) = Quotient.mk (f x) :=\n  rfl\n\n"}
{"name":"Submodule.mapQ_mkQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nq : Submodule R₂ M₂\nf : LinearMap τ₁₂ M M₂\nh : LE.le p (Submodule.comap f q)\n⊢ Eq ((p.mapQ q f h).comp p.mkQ) (q.mkQ.comp f)","decl":"theorem mapQ_mkQ (f : M →ₛₗ[τ₁₂] M₂) {h} : (mapQ p q f h).comp p.mkQ = q.mkQ.comp f := by\n  ext x; rfl\n\n"}
{"name":"Submodule.mapQ_zero","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nq : Submodule R₂ M₂\nh : optParam (LE.le p (Submodule.comap 0 q)) ⋯\n⊢ Eq (p.mapQ q 0 h) 0","decl":"@[simp]\ntheorem mapQ_zero (h : p ≤ q.comap (0 : M →ₛₗ[τ₁₂] M₂) := (by simp)) :\n    p.mapQ q (0 : M →ₛₗ[τ₁₂] M₂) h = 0 := by\n  ext\n  simp\n\n"}
{"name":"Submodule.mapQ_comp","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁹ : Ring R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : Ring R₂\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nR₃ : Type u_5\nM₃ : Type u_6\ninst✝³ : Ring R₃\ninst✝² : AddCommGroup M₃\ninst✝¹ : Module R₃ M₃\np₂ : Submodule R₂ M₂\np₃ : Submodule R₃ M₃\nτ₂₃ : RingHom R₂ R₃\nτ₁₃ : RingHom R R₃\ninst✝ : RingHomCompTriple τ₁₂ τ₂₃ τ₁₃\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₃ M₂ M₃\nhf : LE.le p (Submodule.comap f p₂)\nhg : LE.le p₂ (Submodule.comap g p₃)\nh : optParam (LE.le p (Submodule.comap f (Submodule.comap g p₃))) ⋯\n⊢ Eq (p.mapQ p₃ (g.comp f) h) ((p₂.mapQ p₃ g hg).comp (p.mapQ p₂ f hf))","decl":"/-- Given submodules `p ⊆ M`, `p₂ ⊆ M₂`, `p₃ ⊆ M₃` and maps `f : M → M₂`, `g : M₂ → M₃` inducing\n`mapQ f : M ⧸ p → M₂ ⧸ p₂` and `mapQ g : M₂ ⧸ p₂ → M₃ ⧸ p₃` then\n`mapQ (g ∘ f) = (mapQ g) ∘ (mapQ f)`. -/\ntheorem mapQ_comp {R₃ M₃ : Type*} [Ring R₃] [AddCommGroup M₃] [Module R₃ M₃] (p₂ : Submodule R₂ M₂)\n    (p₃ : Submodule R₃ M₃) {τ₂₃ : R₂ →+* R₃} {τ₁₃ : R →+* R₃} [RingHomCompTriple τ₁₂ τ₂₃ τ₁₃]\n    (f : M →ₛₗ[τ₁₂] M₂) (g : M₂ →ₛₗ[τ₂₃] M₃) (hf : p ≤ p₂.comap f) (hg : p₂ ≤ p₃.comap g)\n    (h := hf.trans (comap_mono hg)) :\n    p.mapQ p₃ (g.comp f) h = (p₂.mapQ p₃ g hg).comp (p.mapQ p₂ f hf) := by\n  ext\n  simp\n\n"}
{"name":"Submodule.mapQ_id","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nh : optParam (LE.le p (Submodule.comap LinearMap.id p)) ⋯\n⊢ Eq (p.mapQ p LinearMap.id h) LinearMap.id","decl":"@[simp]\ntheorem mapQ_id (h : p ≤ p.comap LinearMap.id := (by rw [comap_id])) :\n    p.mapQ p LinearMap.id h = LinearMap.id := by\n  ext\n  simp\n\n"}
{"name":"Submodule.mapQ_pow","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nf : LinearMap (RingHom.id R) M M\nh : LE.le p (Submodule.comap f p)\nk : Nat\nh' : optParam (LE.le p (Submodule.comap (HPow.hPow f k) p)) ⋯\n⊢ Eq (p.mapQ p (HPow.hPow f k) h') (HPow.hPow (p.mapQ p f h) k)","decl":"theorem mapQ_pow {f : M →ₗ[R] M} (h : p ≤ p.comap f) (k : ℕ)\n    (h' : p ≤ p.comap (f ^ k) := p.le_comap_pow_of_le_comap h k) :\n    p.mapQ p (f ^ k) h' = p.mapQ p f h ^ k := by\n  induction' k with k ih\n  · simp [LinearMap.one_eq_id]\n  · simp only [LinearMap.iterate_succ]\n    -- Porting note: why does any of these `optParams` need to be applied? Why didn't `simp` handle\n    -- all of this for us?\n    convert mapQ_comp p p p f (f ^ k) h (p.le_comap_pow_of_le_comap h k)\n      (h.trans (comap_mono <| p.le_comap_pow_of_le_comap h k))\n    exact (ih _).symm\n\n"}
{"name":"Submodule.comap_liftQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nq : Submodule R₂ M₂\nf : LinearMap τ₁₂ M M₂\nh : LE.le p (LinearMap.ker f)\n⊢ Eq (Submodule.comap (p.liftQ f h) q) (Submodule.map p.mkQ (Submodule.comap f q))","decl":"theorem comap_liftQ (f : M →ₛₗ[τ₁₂] M₂) (h) : q.comap (p.liftQ f h) = (q.comap f).map (mkQ p) :=\n  le_antisymm (by rintro ⟨x⟩ hx; exact ⟨_, hx, rfl⟩)\n    (by rw [map_le_iff_le_comap, ← comap_comp, liftQ_mkQ])\n\n"}
{"name":"Submodule.map_liftQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝³ : Ring R₂\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\nh : LE.le p (LinearMap.ker f)\nq : Submodule R (HasQuotient.Quotient M p)\n⊢ Eq (Submodule.map (p.liftQ f h) q) (Submodule.map f (Submodule.comap p.mkQ q))","decl":"theorem map_liftQ [RingHomSurjective τ₁₂] (f : M →ₛₗ[τ₁₂] M₂) (h) (q : Submodule R (M ⧸ p)) :\n    q.map (p.liftQ f h) = (q.comap p.mkQ).map f :=\n  le_antisymm (by rintro _ ⟨⟨x⟩, hxq, rfl⟩; exact ⟨x, hxq, rfl⟩)\n    (by rintro _ ⟨x, hxq, rfl⟩; exact ⟨Quotient.mk x, hxq, rfl⟩)\n\n"}
{"name":"Submodule.ker_liftQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\nh : LE.le p (LinearMap.ker f)\n⊢ Eq (LinearMap.ker (p.liftQ f h)) (Submodule.map p.mkQ (LinearMap.ker f))","decl":"theorem ker_liftQ (f : M →ₛₗ[τ₁₂] M₂) (h) : ker (p.liftQ f h) = (ker f).map (mkQ p) :=\n  comap_liftQ _ _ _ _\n\n"}
{"name":"Submodule.range_liftQ","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝³ : Ring R₂\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\nh : LE.le p (LinearMap.ker f)\n⊢ Eq (LinearMap.range (p.liftQ f h)) (LinearMap.range f)","decl":"theorem range_liftQ [RingHomSurjective τ₁₂] (f : M →ₛₗ[τ₁₂] M₂) (h) :\n    range (p.liftQ f h) = range f := by simpa only [range_eq_map] using map_liftQ _ _ _ _\n\n"}
{"name":"Submodule.ker_liftQ_eq_bot","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\nh : LE.le p (LinearMap.ker f)\nh' : LE.le (LinearMap.ker f) p\n⊢ Eq (LinearMap.ker (p.liftQ f h)) Bot.bot","decl":"theorem ker_liftQ_eq_bot (f : M →ₛₗ[τ₁₂] M₂) (h) (h' : ker f ≤ p) : ker (p.liftQ f h) = ⊥ := by\n  rw [ker_liftQ, le_antisymm h h', mkQ_map_self]\n\n"}
{"name":"Submodule.ker_liftQ_eq_bot'","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\np : Submodule R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝² : Ring R₂\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nf : LinearMap τ₁₂ M M₂\nh : Eq p (LinearMap.ker f)\n⊢ Eq (LinearMap.ker (p.liftQ f ⋯)) Bot.bot","decl":"theorem ker_liftQ_eq_bot' (f : M →ₛₗ[τ₁₂] M₂) (h : p = ker f) :\n    ker (p.liftQ f (le_of_eq h)) = ⊥ :=\n  ker_liftQ_eq_bot p f h.le h.ge\n\n"}
{"name":"Submodule.comapMkQOrderEmbedding_eq","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\np' : Submodule R (HasQuotient.Quotient M p)\n⊢ Eq (p.comapMkQOrderEmbedding p') (Submodule.comap p.mkQ p')","decl":"@[simp]\ntheorem comapMkQOrderEmbedding_eq (p' : Submodule R (M ⧸ p)) :\n    comapMkQOrderEmbedding p p' = comap p.mkQ p' :=\n  rfl\n\n"}
{"name":"Submodule.span_preimage_eq","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝³ : Ring R₂\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\ns : Set M₂\nh₀ : s.Nonempty\nh₁ : HasSubset.Subset s ↑(LinearMap.range f)\n⊢ Eq (Submodule.span R (Set.preimage (⇑f) s)) (Submodule.comap f (Submodule.span R₂ s))","decl":"theorem span_preimage_eq [RingHomSurjective τ₁₂] {f : M →ₛₗ[τ₁₂] M₂} {s : Set M₂} (h₀ : s.Nonempty)\n    (h₁ : s ⊆ range f) : span R (f ⁻¹' s) = (span R₂ s).comap f := by\n  suffices (span R₂ s).comap f ≤ span R (f ⁻¹' s) by exact le_antisymm (span_preimage_le f s) this\n  have hk : ker f ≤ span R (f ⁻¹' s) := by\n    let y := Classical.choose h₀\n    have hy : y ∈ s := Classical.choose_spec h₀\n    rw [ker_le_iff]\n    use y, h₁ hy\n    rw [← Set.singleton_subset_iff] at hy\n    exact Set.Subset.trans subset_span (span_mono (Set.preimage_mono hy))\n  rw [← left_eq_sup] at hk\n  rw [range_coe f] at h₁\n  rw [hk, ← LinearMap.map_le_map_iff, map_span, map_comap_eq, Set.image_preimage_eq_of_subset h₁]\n  exact inf_le_right\n\n"}
{"name":"Submodule.Quotient.equiv_apply","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_5\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : Submodule R M\nQ : Submodule R N\nf : LinearEquiv (RingHom.id R) M N\nhf : Eq (Submodule.map f P) Q\na : HasQuotient.Quotient M P\n⊢ Eq ((Submodule.Quotient.equiv P Q f hf) a) ((P.mapQ Q ↑f ⋯) a)","decl":"/-- If `P` is a submodule of `M` and `Q` a submodule of `N`,\nand `f : M ≃ₗ N` maps `P` to `Q`, then `M ⧸ P` is equivalent to `N ⧸ Q`. -/\n@[simps]\ndef Quotient.equiv {N : Type*} [AddCommGroup N] [Module R N] (P : Submodule R M)\n    (Q : Submodule R N) (f : M ≃ₗ[R] N) (hf : P.map f = Q) : (M ⧸ P) ≃ₗ[R] N ⧸ Q :=\n  { P.mapQ Q (f : M →ₗ[R] N) fun _ hx => hf ▸ Submodule.mem_map_of_mem hx with\n    toFun := P.mapQ Q (f : M →ₗ[R] N) fun _ hx => hf ▸ Submodule.mem_map_of_mem hx\n    invFun :=\n      Q.mapQ P (f.symm : N →ₗ[R] M) fun x hx => by\n        rw [← hf, Submodule.mem_map] at hx\n        obtain ⟨y, hy, rfl⟩ := hx\n        simpa\n    left_inv := fun x => Submodule.Quotient.induction_on _ x (by simp)\n    right_inv := fun x => Submodule.Quotient.induction_on _ x (by simp) }\n\n"}
{"name":"Submodule.Quotient.equiv_symm_apply","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_5\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : Submodule R M\nQ : Submodule R N\nf : LinearEquiv (RingHom.id R) M N\nhf : Eq (Submodule.map f P) Q\na : HasQuotient.Quotient N Q\n⊢ Eq ((Submodule.Quotient.equiv P Q f hf).symm a) ((Q.mapQ P ↑f.symm ⋯) a)","decl":"/-- If `P` is a submodule of `M` and `Q` a submodule of `N`,\nand `f : M ≃ₗ N` maps `P` to `Q`, then `M ⧸ P` is equivalent to `N ⧸ Q`. -/\n@[simps]\ndef Quotient.equiv {N : Type*} [AddCommGroup N] [Module R N] (P : Submodule R M)\n    (Q : Submodule R N) (f : M ≃ₗ[R] N) (hf : P.map f = Q) : (M ⧸ P) ≃ₗ[R] N ⧸ Q :=\n  { P.mapQ Q (f : M →ₗ[R] N) fun _ hx => hf ▸ Submodule.mem_map_of_mem hx with\n    toFun := P.mapQ Q (f : M →ₗ[R] N) fun _ hx => hf ▸ Submodule.mem_map_of_mem hx\n    invFun :=\n      Q.mapQ P (f.symm : N →ₗ[R] M) fun x hx => by\n        rw [← hf, Submodule.mem_map] at hx\n        obtain ⟨y, hy, rfl⟩ := hx\n        simpa\n    left_inv := fun x => Submodule.Quotient.induction_on _ x (by simp)\n    right_inv := fun x => Submodule.Quotient.induction_on _ x (by simp) }\n\n"}
{"name":"Submodule.Quotient.equiv_symm","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_5\nM : Type u_6\nN : Type u_7\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nP : Submodule R M\nQ : Submodule R N\nf : LinearEquiv (RingHom.id R) M N\nhf : Eq (Submodule.map f P) Q\n⊢ Eq (Submodule.Quotient.equiv P Q f hf).symm (Submodule.Quotient.equiv Q P f.symm ⋯)","decl":"@[simp]\ntheorem Quotient.equiv_symm {R M N : Type*} [CommRing R] [AddCommGroup M] [Module R M]\n    [AddCommGroup N] [Module R N] (P : Submodule R M) (Q : Submodule R N) (f : M ≃ₗ[R] N)\n    (hf : P.map f = Q) :\n    (Quotient.equiv P Q f hf).symm =\n      Quotient.equiv Q P f.symm ((Submodule.map_symm_eq_iff f).mpr hf) :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.equiv_trans","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nN : Type u_5\nO : Type u_6\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : AddCommGroup O\ninst✝ : Module R O\nP : Submodule R M\nQ : Submodule R N\nS : Submodule R O\ne : LinearEquiv (RingHom.id R) M N\nf : LinearEquiv (RingHom.id R) N O\nhe : Eq (Submodule.map e P) Q\nhf : Eq (Submodule.map f Q) S\nhef : Eq (Submodule.map (e.trans f) P) S\n⊢ Eq (Submodule.Quotient.equiv P S (e.trans f) hef) ((Submodule.Quotient.equiv P Q e he).trans (Submodule.Quotient.equiv Q S f hf))","decl":"@[simp]\ntheorem Quotient.equiv_trans {N O : Type*} [AddCommGroup N] [Module R N] [AddCommGroup O]\n    [Module R O] (P : Submodule R M) (Q : Submodule R N) (S : Submodule R O) (e : M ≃ₗ[R] N)\n    (f : N ≃ₗ[R] O) (he : P.map e = Q) (hf : Q.map f = S) (hef : P.map (e.trans f) = S) :\n    Quotient.equiv P S (e.trans f) hef =\n      (Quotient.equiv P Q e he).trans (Quotient.equiv Q S f hf) := by\n  ext\n  -- `simp` can deal with `hef` depending on `e` and `f`\n  simp only [Quotient.equiv_apply, LinearEquiv.trans_apply, LinearEquiv.coe_trans]\n  -- `rw` can deal with `mapQ_comp` needing extra hypotheses coming from the RHS\n  rw [mapQ_comp, LinearMap.comp_apply]\n\n"}
{"name":"LinearMap.range_mkQ_comp","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : Ring R\ninst✝⁵ : Ring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\n⊢ Eq ((LinearMap.range f).mkQ.comp f) 0","decl":"theorem range_mkQ_comp (f : M →ₛₗ[τ₁₂] M₂) : f.range.mkQ.comp f = 0 :=\n  LinearMap.ext fun x => by simp\n\n"}
{"name":"LinearMap.ker_le_range_iff","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nR₂ : Type u_3\nM₂ : Type u_4\nR₃ : Type u_5\nM₃ : Type u_6\ninst✝⁹ : Ring R\ninst✝⁸ : Ring R₂\ninst✝⁷ : Ring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nτ₁₂ : RingHom R R₂\nτ₂₃ : RingHom R₂ R₃\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\ng : LinearMap τ₂₃ M₂ M₃\n⊢ Iff (LE.le (LinearMap.ker g) (LinearMap.range f)) (Eq ((LinearMap.range f).mkQ.comp (LinearMap.ker g).subtype) 0)","decl":"theorem ker_le_range_iff {f : M →ₛₗ[τ₁₂] M₂} {g : M₂ →ₛₗ[τ₂₃] M₃} :\n    ker g ≤ range f ↔ f.range.mkQ.comp g.ker.subtype = 0 := by\n  rw [← range_le_ker_iff, Submodule.ker_mkQ, Submodule.range_subtype]\n\n"}
{"name":"LinearMap.range_eq_top_of_cancel","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nR₂ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : Ring R\ninst✝⁵ : Ring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective τ₁₂\nf : LinearMap τ₁₂ M M₂\nh : ∀ (u v : LinearMap (RingHom.id R₂) M₂ (HasQuotient.Quotient M₂ (LinearMap.range f))), Eq (u.comp f) (v.comp f) → Eq u v\n⊢ Eq (LinearMap.range f) Top.top","decl":"/-- An epimorphism is surjective. -/\ntheorem range_eq_top_of_cancel {f : M →ₛₗ[τ₁₂] M₂}\n    (h : ∀ u v : M₂ →ₗ[R₂] M₂ ⧸ (range f), u.comp f = v.comp f → u = v) : range f = ⊤ := by\n  have h₁ : (0 : M₂ →ₗ[R₂] M₂ ⧸ (range f)).comp f = 0 := zero_comp _\n  rw [← Submodule.ker_mkQ (range f), ← h 0 f.range.mkQ (Eq.trans h₁ (range_mkQ_comp _).symm)]\n  exact ker_zero\n\n"}
{"name":"Submodule.quotEquivOfEqBot_apply_mk","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nhp : Eq p Bot.bot\nx : M\n⊢ Eq ((p.quotEquivOfEqBot hp) (Submodule.Quotient.mk x)) x","decl":"@[simp]\ntheorem quotEquivOfEqBot_apply_mk (hp : p = ⊥) (x : M) :\n    p.quotEquivOfEqBot hp (Quotient.mk x) = x :=\n  rfl\n\n"}
{"name":"Submodule.quotEquivOfEqBot_symm_apply","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nhp : Eq p Bot.bot\nx : M\n⊢ Eq ((p.quotEquivOfEqBot hp).symm x) (Submodule.Quotient.mk x)","decl":"@[simp]\ntheorem quotEquivOfEqBot_symm_apply (hp : p = ⊥) (x : M) :\n    (p.quotEquivOfEqBot hp).symm x = (Quotient.mk x) :=\n  rfl\n\n"}
{"name":"Submodule.coe_quotEquivOfEqBot_symm","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nhp : Eq p Bot.bot\n⊢ Eq (↑(p.quotEquivOfEqBot hp).symm) p.mkQ","decl":"@[simp]\ntheorem coe_quotEquivOfEqBot_symm (hp : p = ⊥) :\n    ((p.quotEquivOfEqBot hp).symm : M →ₗ[R] M ⧸ p) = p.mkQ :=\n  rfl\n\n"}
{"name":"Submodule.Quotient.equiv_refl","module":"Mathlib.LinearAlgebra.Quotient.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nP Q : Submodule R M\nhf : Eq (Submodule.map (↑(LinearEquiv.refl R M)) P) Q\n⊢ Eq (Submodule.Quotient.equiv P Q (LinearEquiv.refl R M) hf) (P.quotEquivOfEq Q ⋯)","decl":"@[simp]\ntheorem Quotient.equiv_refl (P : Submodule R M) (Q : Submodule R M)\n    (hf : P.map (LinearEquiv.refl R M : M →ₗ[R] M) = Q) :\n    Quotient.equiv P Q (LinearEquiv.refl R M) hf = quotEquivOfEq _ _ (by simpa using hf) :=\n  rfl\n\n"}
