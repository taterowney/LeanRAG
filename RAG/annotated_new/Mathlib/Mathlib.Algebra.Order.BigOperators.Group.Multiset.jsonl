{"name":"Multiset.one_le_prod_of_one_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\ns : Multiset α\na✝ : ∀ (x : α), Membership.mem s x → LE.le 1 x\n⊢ LE.le 1 s.prod","decl":"@[to_additive sum_nonneg]\nlemma one_le_prod_of_one_le : (∀ x ∈ s, (1 : α) ≤ x) → 1 ≤ s.prod :=\n  Quotient.inductionOn s fun l hl => by simpa using List.one_le_prod_of_one_le hl\n\n"}
{"name":"Multiset.sum_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns : Multiset α\na✝ : ∀ (x : α), Membership.mem s x → LE.le 0 x\n⊢ LE.le 0 s.sum","decl":"@[to_additive sum_nonneg]\nlemma one_le_prod_of_one_le : (∀ x ∈ s, (1 : α) ≤ x) → 1 ≤ s.prod :=\n  Quotient.inductionOn s fun l hl => by simpa using List.one_le_prod_of_one_le hl\n\n"}
{"name":"Multiset.single_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\ns : Multiset α\na✝¹ : ∀ (x : α), Membership.mem s x → LE.le 1 x\nx : α\na✝ : Membership.mem s x\n⊢ LE.le x s.prod","decl":"@[to_additive]\nlemma single_le_prod : (∀ x ∈ s, (1 : α) ≤ x) → ∀ x ∈ s, x ≤ s.prod :=\n  Quotient.inductionOn s fun l hl x hx => by simpa using List.single_le_prod hl x hx\n\n"}
{"name":"Multiset.single_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns : Multiset α\na✝¹ : ∀ (x : α), Membership.mem s x → LE.le 0 x\nx : α\na✝ : Membership.mem s x\n⊢ LE.le x s.sum","decl":"@[to_additive]\nlemma single_le_prod : (∀ x ∈ s, (1 : α) ≤ x) → ∀ x ∈ s, x ≤ s.prod :=\n  Quotient.inductionOn s fun l hl x hx => by simpa using List.single_le_prod hl x hx\n\n"}
{"name":"Multiset.sum_le_card_nsmul","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns : Multiset α\nn : α\nh : ∀ (x : α), Membership.mem s x → LE.le x n\n⊢ LE.le s.sum (HSMul.hSMul s.card n)","decl":"@[to_additive sum_le_card_nsmul]\nlemma prod_le_pow_card (s : Multiset α) (n : α) (h : ∀ x ∈ s, x ≤ n) : s.prod ≤ n ^ card s := by\n  induction s using Quotient.inductionOn\n  simpa using List.prod_le_pow_card _ _ h\n\n"}
{"name":"Multiset.prod_le_pow_card","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\ns : Multiset α\nn : α\nh : ∀ (x : α), Membership.mem s x → LE.le x n\n⊢ LE.le s.prod (HPow.hPow n s.card)","decl":"@[to_additive sum_le_card_nsmul]\nlemma prod_le_pow_card (s : Multiset α) (n : α) (h : ∀ x ∈ s, x ≤ n) : s.prod ≤ n ^ card s := by\n  induction s using Quotient.inductionOn\n  simpa using List.prod_le_pow_card _ _ h\n\n"}
{"name":"Multiset.all_one_of_le_one_le_of_prod_eq_one","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\ns : Multiset α\na✝² : ∀ (x : α), Membership.mem s x → LE.le 1 x\na✝¹ : Eq s.prod 1\nx : α\na✝ : Membership.mem s x\n⊢ Eq x 1","decl":"@[to_additive all_zero_of_le_zero_le_of_sum_eq_zero]\nlemma all_one_of_le_one_le_of_prod_eq_one :\n    (∀ x ∈ s, (1 : α) ≤ x) → s.prod = 1 → ∀ x ∈ s, x = (1 : α) :=\n  Quotient.inductionOn s (by\n    simp only [quot_mk_to_coe, prod_coe, mem_coe]\n    exact fun l => List.all_one_of_le_one_le_of_prod_eq_one)\n\n"}
{"name":"Multiset.all_zero_of_le_zero_le_of_sum_eq_zero","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns : Multiset α\na✝² : ∀ (x : α), Membership.mem s x → LE.le 0 x\na✝¹ : Eq s.sum 0\nx : α\na✝ : Membership.mem s x\n⊢ Eq x 0","decl":"@[to_additive all_zero_of_le_zero_le_of_sum_eq_zero]\nlemma all_one_of_le_one_le_of_prod_eq_one :\n    (∀ x ∈ s, (1 : α) ≤ x) → s.prod = 1 → ∀ x ∈ s, x = (1 : α) :=\n  Quotient.inductionOn s (by\n    simp only [quot_mk_to_coe, prod_coe, mem_coe]\n    exact fun l => List.all_one_of_le_one_le_of_prod_eq_one)\n\n"}
{"name":"Multiset.sum_le_sum_of_rel_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns t : Multiset α\nh : Multiset.Rel (fun x1 x2 => LE.le x1 x2) s t\n⊢ LE.le s.sum t.sum","decl":"@[to_additive]\nlemma prod_le_prod_of_rel_le (h : s.Rel (· ≤ ·) t) : s.prod ≤ t.prod := by\n  induction h with\n  | zero => rfl\n  | cons rh _ rt =>\n    rw [prod_cons, prod_cons]\n    exact mul_le_mul' rh rt\n\n"}
{"name":"Multiset.prod_le_prod_of_rel_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\ns t : Multiset α\nh : Multiset.Rel (fun x1 x2 => LE.le x1 x2) s t\n⊢ LE.le s.prod t.prod","decl":"@[to_additive]\nlemma prod_le_prod_of_rel_le (h : s.Rel (· ≤ ·) t) : s.prod ≤ t.prod := by\n  induction h with\n  | zero => rfl\n  | cons rh _ rt =>\n    rw [prod_cons, prod_cons]\n    exact mul_le_mul' rh rt\n\n"}
{"name":"Multiset.prod_map_le_prod_map","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : OrderedCommMonoid α\ns : Multiset ι\nf g : ι → α\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ LE.le (Multiset.map f s).prod (Multiset.map g s).prod","decl":"@[to_additive]\nlemma prod_map_le_prod_map {s : Multiset ι} (f : ι → α) (g : ι → α) (h : ∀ i, i ∈ s → f i ≤ g i) :\n    (s.map f).prod ≤ (s.map g).prod :=\n  prod_le_prod_of_rel_le <| rel_map.2 <| rel_refl_of_refl_on h\n\n"}
{"name":"Multiset.sum_map_le_sum_map","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns : Multiset ι\nf g : ι → α\nh : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ LE.le (Multiset.map f s).sum (Multiset.map g s).sum","decl":"@[to_additive]\nlemma prod_map_le_prod_map {s : Multiset ι} (f : ι → α) (g : ι → α) (h : ∀ i, i ∈ s → f i ≤ g i) :\n    (s.map f).prod ≤ (s.map g).prod :=\n  prod_le_prod_of_rel_le <| rel_map.2 <| rel_refl_of_refl_on h\n\n"}
{"name":"Multiset.sum_map_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns : Multiset α\nf : α → α\nh : ∀ (x : α), Membership.mem s x → LE.le (f x) x\n⊢ LE.le (Multiset.map f s).sum s.sum","decl":"@[to_additive]\nlemma prod_map_le_prod (f : α → α) (h : ∀ x, x ∈ s → f x ≤ x) : (s.map f).prod ≤ s.prod :=\n  prod_le_prod_of_rel_le <| rel_map_left.2 <| rel_refl_of_refl_on h\n\n"}
{"name":"Multiset.prod_map_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\ns : Multiset α\nf : α → α\nh : ∀ (x : α), Membership.mem s x → LE.le (f x) x\n⊢ LE.le (Multiset.map f s).prod s.prod","decl":"@[to_additive]\nlemma prod_map_le_prod (f : α → α) (h : ∀ x, x ∈ s → f x ≤ x) : (s.map f).prod ≤ s.prod :=\n  prod_le_prod_of_rel_le <| rel_map_left.2 <| rel_refl_of_refl_on h\n\n"}
{"name":"Multiset.prod_le_prod_map","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\ns : Multiset α\nf : α → α\nh : ∀ (x : α), Membership.mem s x → LE.le x (f x)\n⊢ LE.le s.prod (Multiset.map f s).prod","decl":"@[to_additive]\nlemma prod_le_prod_map (f : α → α) (h : ∀ x, x ∈ s → x ≤ f x) : s.prod ≤ (s.map f).prod :=\n  @prod_map_le_prod αᵒᵈ _ _ f h\n\n"}
{"name":"Multiset.sum_le_sum_map","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns : Multiset α\nf : α → α\nh : ∀ (x : α), Membership.mem s x → LE.le x (f x)\n⊢ LE.le s.sum (Multiset.map f s).sum","decl":"@[to_additive]\nlemma prod_le_prod_map (f : α → α) (h : ∀ x, x ∈ s → x ≤ f x) : s.prod ≤ (s.map f).prod :=\n  @prod_map_le_prod αᵒᵈ _ _ f h\n\n"}
{"name":"Multiset.pow_card_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\ns : Multiset α\na : α\nh : ∀ (x : α), Membership.mem s x → LE.le a x\n⊢ LE.le (HPow.hPow a s.card) s.prod","decl":"@[to_additive card_nsmul_le_sum]\nlemma pow_card_le_prod (h : ∀ x ∈ s, a ≤ x) : a ^ card s ≤ s.prod := by\n  rw [← Multiset.prod_replicate, ← Multiset.map_const]\n  exact prod_map_le_prod _ h\n\n"}
{"name":"Multiset.card_nsmul_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns : Multiset α\na : α\nh : ∀ (x : α), Membership.mem s x → LE.le a x\n⊢ LE.le (HSMul.hSMul s.card a) s.sum","decl":"@[to_additive card_nsmul_le_sum]\nlemma pow_card_le_prod (h : ∀ x ∈ s, a ≤ x) : a ^ card s ≤ s.prod := by\n  rw [← Multiset.prod_replicate, ← Multiset.map_const]\n  exact prod_map_le_prod _ h\n\n"}
{"name":"Multiset.le_prod_of_submultiplicative_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : OrderedCommMonoid β\nf : α → β\np : α → Prop\nh_one : Eq (f 1) 1\nhp_one : p 1\nh_mul : ∀ (a b : α), p a → p b → LE.le (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))\nhp_mul : ∀ (a b : α), p a → p b → p (HMul.hMul a b)\ns : Multiset α\nhps : ∀ (a : α), Membership.mem s a → p a\n⊢ LE.le (f s.prod) (Multiset.map f s).prod","decl":"@[to_additive le_sum_of_subadditive_on_pred]\nlemma le_prod_of_submultiplicative_on_pred (f : α → β)\n    (p : α → Prop) (h_one : f 1 = 1) (hp_one : p 1)\n    (h_mul : ∀ a b, p a → p b → f (a * b) ≤ f a * f b) (hp_mul : ∀ a b, p a → p b → p (a * b))\n    (s : Multiset α) (hps : ∀ a, a ∈ s → p a) : f s.prod ≤ (s.map f).prod := by\n  revert s\n  refine Multiset.induction ?_ ?_\n  · simp [le_of_eq h_one]\n  intro a s hs hpsa\n  have hps : ∀ x, x ∈ s → p x := fun x hx => hpsa x (mem_cons_of_mem hx)\n  have hp_prod : p s.prod := prod_induction p s hp_mul hp_one hps\n  rw [prod_cons, map_cons, prod_cons]\n  exact (h_mul a s.prod (hpsa a (mem_cons_self a s)) hp_prod).trans (mul_le_mul_left' (hs hps) _)\n\n"}
{"name":"Multiset.le_sum_of_subadditive_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : OrderedAddCommMonoid β\nf : α → β\np : α → Prop\nh_one : Eq (f 0) 0\nhp_one : p 0\nh_mul : ∀ (a b : α), p a → p b → LE.le (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))\nhp_mul : ∀ (a b : α), p a → p b → p (HAdd.hAdd a b)\ns : Multiset α\nhps : ∀ (a : α), Membership.mem s a → p a\n⊢ LE.le (f s.sum) (Multiset.map f s).sum","decl":"@[to_additive le_sum_of_subadditive_on_pred]\nlemma le_prod_of_submultiplicative_on_pred (f : α → β)\n    (p : α → Prop) (h_one : f 1 = 1) (hp_one : p 1)\n    (h_mul : ∀ a b, p a → p b → f (a * b) ≤ f a * f b) (hp_mul : ∀ a b, p a → p b → p (a * b))\n    (s : Multiset α) (hps : ∀ a, a ∈ s → p a) : f s.prod ≤ (s.map f).prod := by\n  revert s\n  refine Multiset.induction ?_ ?_\n  · simp [le_of_eq h_one]\n  intro a s hs hpsa\n  have hps : ∀ x, x ∈ s → p x := fun x hx => hpsa x (mem_cons_of_mem hx)\n  have hp_prod : p s.prod := prod_induction p s hp_mul hp_one hps\n  rw [prod_cons, map_cons, prod_cons]\n  exact (h_mul a s.prod (hpsa a (mem_cons_self a s)) hp_prod).trans (mul_le_mul_left' (hs hps) _)\n\n"}
{"name":"Multiset.le_prod_of_submultiplicative","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : OrderedCommMonoid β\nf : α → β\nh_one : Eq (f 1) 1\nh_mul : ∀ (a b : α), LE.le (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))\ns : Multiset α\n⊢ LE.le (f s.prod) (Multiset.map f s).prod","decl":"@[to_additive le_sum_of_subadditive]\nlemma le_prod_of_submultiplicative (f : α → β) (h_one : f 1 = 1)\n    (h_mul : ∀ a b, f (a * b) ≤ f a * f b) (s : Multiset α) : f s.prod ≤ (s.map f).prod :=\n  le_prod_of_submultiplicative_on_pred f (fun _ => True) h_one trivial (fun x y _ _ => h_mul x y)\n    (by simp) s (by simp)\n\n"}
{"name":"Multiset.le_sum_of_subadditive","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : OrderedAddCommMonoid β\nf : α → β\nh_one : Eq (f 0) 0\nh_mul : ∀ (a b : α), LE.le (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))\ns : Multiset α\n⊢ LE.le (f s.sum) (Multiset.map f s).sum","decl":"@[to_additive le_sum_of_subadditive]\nlemma le_prod_of_submultiplicative (f : α → β) (h_one : f 1 = 1)\n    (h_mul : ∀ a b, f (a * b) ≤ f a * f b) (s : Multiset α) : f s.prod ≤ (s.map f).prod :=\n  le_prod_of_submultiplicative_on_pred f (fun _ => True) h_one trivial (fun x y _ _ => h_mul x y)\n    (by simp) s (by simp)\n\n"}
{"name":"Multiset.le_prod_nonempty_of_submultiplicative_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : OrderedCommMonoid β\nf : α → β\np : α → Prop\nh_mul : ∀ (a b : α), p a → p b → LE.le (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))\nhp_mul : ∀ (a b : α), p a → p b → p (HMul.hMul a b)\ns : Multiset α\nhs_nonempty : Ne s EmptyCollection.emptyCollection\nhs : ∀ (a : α), Membership.mem s a → p a\n⊢ LE.le (f s.prod) (Multiset.map f s).prod","decl":"@[to_additive le_sum_nonempty_of_subadditive_on_pred]\nlemma le_prod_nonempty_of_submultiplicative_on_pred (f : α → β) (p : α → Prop)\n    (h_mul : ∀ a b, p a → p b → f (a * b) ≤ f a * f b) (hp_mul : ∀ a b, p a → p b → p (a * b))\n    (s : Multiset α) (hs_nonempty : s ≠ ∅) (hs : ∀ a, a ∈ s → p a) : f s.prod ≤ (s.map f).prod := by\n  revert s\n  refine Multiset.induction ?_ ?_\n  · simp\n  rintro a s hs - hsa_prop\n  rw [prod_cons, map_cons, prod_cons]\n  by_cases hs_empty : s = ∅\n  · simp [hs_empty]\n  have hsa_restrict : ∀ x, x ∈ s → p x := fun x hx => hsa_prop x (mem_cons_of_mem hx)\n  have hp_sup : p s.prod := prod_induction_nonempty p hp_mul hs_empty hsa_restrict\n  have hp_a : p a := hsa_prop a (mem_cons_self a s)\n  exact (h_mul a _ hp_a hp_sup).trans (mul_le_mul_left' (hs hs_empty hsa_restrict) _)\n\n"}
{"name":"Multiset.le_sum_nonempty_of_subadditive_on_pred","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : OrderedAddCommMonoid β\nf : α → β\np : α → Prop\nh_mul : ∀ (a b : α), p a → p b → LE.le (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))\nhp_mul : ∀ (a b : α), p a → p b → p (HAdd.hAdd a b)\ns : Multiset α\nhs_nonempty : Ne s EmptyCollection.emptyCollection\nhs : ∀ (a : α), Membership.mem s a → p a\n⊢ LE.le (f s.sum) (Multiset.map f s).sum","decl":"@[to_additive le_sum_nonempty_of_subadditive_on_pred]\nlemma le_prod_nonempty_of_submultiplicative_on_pred (f : α → β) (p : α → Prop)\n    (h_mul : ∀ a b, p a → p b → f (a * b) ≤ f a * f b) (hp_mul : ∀ a b, p a → p b → p (a * b))\n    (s : Multiset α) (hs_nonempty : s ≠ ∅) (hs : ∀ a, a ∈ s → p a) : f s.prod ≤ (s.map f).prod := by\n  revert s\n  refine Multiset.induction ?_ ?_\n  · simp\n  rintro a s hs - hsa_prop\n  rw [prod_cons, map_cons, prod_cons]\n  by_cases hs_empty : s = ∅\n  · simp [hs_empty]\n  have hsa_restrict : ∀ x, x ∈ s → p x := fun x hx => hsa_prop x (mem_cons_of_mem hx)\n  have hp_sup : p s.prod := prod_induction_nonempty p hp_mul hs_empty hsa_restrict\n  have hp_a : p a := hsa_prop a (mem_cons_self a s)\n  exact (h_mul a _ hp_a hp_sup).trans (mul_le_mul_left' (hs hs_empty hsa_restrict) _)\n\n"}
{"name":"Multiset.le_sum_nonempty_of_subadditive","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : OrderedAddCommMonoid β\nf : α → β\nh_mul : ∀ (a b : α), LE.le (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))\ns : Multiset α\nhs_nonempty : Ne s EmptyCollection.emptyCollection\n⊢ LE.le (f s.sum) (Multiset.map f s).sum","decl":"@[to_additive le_sum_nonempty_of_subadditive]\nlemma le_prod_nonempty_of_submultiplicative (f : α → β) (h_mul : ∀ a b, f (a * b) ≤ f a * f b)\n    (s : Multiset α) (hs_nonempty : s ≠ ∅) : f s.prod ≤ (s.map f).prod :=\n  le_prod_nonempty_of_submultiplicative_on_pred f (fun _ => True) (by simp [h_mul]) (by simp) s\n    hs_nonempty (by simp)\n\n"}
{"name":"Multiset.le_prod_nonempty_of_submultiplicative","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : OrderedCommMonoid β\nf : α → β\nh_mul : ∀ (a b : α), LE.le (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))\ns : Multiset α\nhs_nonempty : Ne s EmptyCollection.emptyCollection\n⊢ LE.le (f s.prod) (Multiset.map f s).prod","decl":"@[to_additive le_sum_nonempty_of_subadditive]\nlemma le_prod_nonempty_of_submultiplicative (f : α → β) (h_mul : ∀ a b, f (a * b) ≤ f a * f b)\n    (s : Multiset α) (hs_nonempty : s ≠ ∅) : f s.prod ≤ (s.map f).prod :=\n  le_prod_nonempty_of_submultiplicative_on_pred f (fun _ => True) (by simp [h_mul]) (by simp) s\n    hs_nonempty (by simp)\n\n"}
{"name":"Multiset.prod_lt_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : OrderedCancelCommMonoid α\ns : Multiset ι\nf g : ι → α\nhle : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\nhlt : Exists fun i => And (Membership.mem s i) (LT.lt (f i) (g i))\n⊢ LT.lt (Multiset.map f s).prod (Multiset.map g s).prod","decl":"@[to_additive sum_lt_sum]\nlemma prod_lt_prod' (hle : ∀ i ∈ s, f i ≤ g i) (hlt : ∃ i ∈ s, f i < g i) :\n    (s.map f).prod < (s.map g).prod := by\n  obtain ⟨l⟩ := s\n  simp only [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.prod_coe]\n  exact List.prod_lt_prod' f g hle hlt\n\n"}
{"name":"Multiset.sum_lt_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : OrderedCancelAddCommMonoid α\ns : Multiset ι\nf g : ι → α\nhle : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\nhlt : Exists fun i => And (Membership.mem s i) (LT.lt (f i) (g i))\n⊢ LT.lt (Multiset.map f s).sum (Multiset.map g s).sum","decl":"@[to_additive sum_lt_sum]\nlemma prod_lt_prod' (hle : ∀ i ∈ s, f i ≤ g i) (hlt : ∃ i ∈ s, f i < g i) :\n    (s.map f).prod < (s.map g).prod := by\n  obtain ⟨l⟩ := s\n  simp only [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.prod_coe]\n  exact List.prod_lt_prod' f g hle hlt\n\n"}
{"name":"Multiset.sum_lt_sum_of_nonempty","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : OrderedCancelAddCommMonoid α\ns : Multiset ι\nf g : ι → α\nhs : Ne s EmptyCollection.emptyCollection\nhfg : ∀ (i : ι), Membership.mem s i → LT.lt (f i) (g i)\n⊢ LT.lt (Multiset.map f s).sum (Multiset.map g s).sum","decl":"@[to_additive sum_lt_sum_of_nonempty]\nlemma prod_lt_prod_of_nonempty' (hs : s ≠ ∅) (hfg : ∀ i ∈ s, f i < g i) :\n    (s.map f).prod < (s.map g).prod := by\n  obtain ⟨i, hi⟩ := exists_mem_of_ne_zero hs\n  exact prod_lt_prod' (fun i hi => le_of_lt (hfg i hi)) ⟨i, hi, hfg i hi⟩\n\n"}
{"name":"Multiset.prod_lt_prod_of_nonempty'","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : OrderedCancelCommMonoid α\ns : Multiset ι\nf g : ι → α\nhs : Ne s EmptyCollection.emptyCollection\nhfg : ∀ (i : ι), Membership.mem s i → LT.lt (f i) (g i)\n⊢ LT.lt (Multiset.map f s).prod (Multiset.map g s).prod","decl":"@[to_additive sum_lt_sum_of_nonempty]\nlemma prod_lt_prod_of_nonempty' (hs : s ≠ ∅) (hfg : ∀ i ∈ s, f i < g i) :\n    (s.map f).prod < (s.map g).prod := by\n  obtain ⟨i, hi⟩ := exists_mem_of_ne_zero hs\n  exact prod_lt_prod' (fun i hi => le_of_lt (hfg i hi)) ⟨i, hi, hfg i hi⟩\n\n"}
{"name":"Multiset.sum_eq_zero_iff","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝¹ : OrderedAddCommMonoid α\ninst✝ : CanonicallyOrderedAdd α\nm : Multiset α\n⊢ Iff (Eq m.sum 0) (∀ (x : α), Membership.mem m x → Eq x 0)","decl":"@[to_additive] lemma prod_eq_one_iff : m.prod = 1 ↔ ∀ x ∈ m, x = (1 : α) :=\n  Quotient.inductionOn m fun l ↦ by simpa using List.prod_eq_one_iff\n\n"}
{"name":"Multiset.prod_eq_one_iff","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝¹ : OrderedCommMonoid α\ninst✝ : CanonicallyOrderedMul α\nm : Multiset α\n⊢ Iff (Eq m.prod 1) (∀ (x : α), Membership.mem m x → Eq x 1)","decl":"@[to_additive] lemma prod_eq_one_iff : m.prod = 1 ↔ ∀ x ∈ m, x = (1 : α) :=\n  Quotient.inductionOn m fun l ↦ by simpa using List.prod_eq_one_iff\n\n"}
{"name":"Multiset.le_sum_of_mem","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝¹ : OrderedAddCommMonoid α\ninst✝ : CanonicallyOrderedAdd α\nm : Multiset α\na : α\nha : Membership.mem m a\n⊢ LE.le a m.sum","decl":"@[to_additive] lemma le_prod_of_mem (ha : a ∈ m) : a ≤ m.prod := by\n  obtain ⟨t, rfl⟩ := exists_cons_of_mem ha\n  rw [prod_cons]\n  exact _root_.le_mul_right (le_refl a)\n\n"}
{"name":"Multiset.le_prod_of_mem","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝¹ : OrderedCommMonoid α\ninst✝ : CanonicallyOrderedMul α\nm : Multiset α\na : α\nha : Membership.mem m a\n⊢ LE.le a m.prod","decl":"@[to_additive] lemma le_prod_of_mem (ha : a ∈ m) : a ≤ m.prod := by\n  obtain ⟨t, rfl⟩ := exists_cons_of_mem ha\n  rw [prod_cons]\n  exact _root_.le_mul_right (le_refl a)\n\n"}
{"name":"Multiset.max_le_of_forall_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\nl : Multiset α\nn : α\nh : ∀ (x : α), Membership.mem l x → LE.le x n\n⊢ LE.le (Multiset.fold Max.max Bot.bot l) n","decl":"lemma max_le_of_forall_le {α : Type*} [LinearOrder α] [OrderBot α] (l : Multiset α)\n    (n : α) (h : ∀ x ∈ l, x ≤ n) : l.fold max ⊥ ≤ n := by\n  induction l using Quotient.inductionOn\n  simpa using List.max_le_of_forall_le _ _ h\n\n"}
{"name":"Multiset.max_prod_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : LinearOrderedCommMonoid α\ns : Multiset ι\nf g : ι → α\n⊢ LE.le (Max.max (Multiset.map f s).prod (Multiset.map g s).prod) (Multiset.map (fun i => Max.max (f i) (g i)) s).prod","decl":"@[to_additive]\nlemma max_prod_le [LinearOrderedCommMonoid α] {s : Multiset ι} {f g : ι → α} :\n    max (s.map f).prod (s.map g).prod ≤ (s.map fun i ↦ max (f i) (g i)).prod := by\n  obtain ⟨l⟩ := s\n  simp_rw [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.prod_coe]\n  apply List.max_prod_le\n\n"}
{"name":"Multiset.max_sum_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : LinearOrderedAddCommMonoid α\ns : Multiset ι\nf g : ι → α\n⊢ LE.le (Max.max (Multiset.map f s).sum (Multiset.map g s).sum) (Multiset.map (fun i => Max.max (f i) (g i)) s).sum","decl":"@[to_additive]\nlemma max_prod_le [LinearOrderedCommMonoid α] {s : Multiset ι} {f g : ι → α} :\n    max (s.map f).prod (s.map g).prod ≤ (s.map fun i ↦ max (f i) (g i)).prod := by\n  obtain ⟨l⟩ := s\n  simp_rw [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.prod_coe]\n  apply List.max_prod_le\n\n"}
{"name":"Multiset.prod_min_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : LinearOrderedCommMonoid α\ns : Multiset ι\nf g : ι → α\n⊢ LE.le (Multiset.map (fun i => Min.min (f i) (g i)) s).prod (Min.min (Multiset.map f s).prod (Multiset.map g s).prod)","decl":"@[to_additive]\nlemma prod_min_le [LinearOrderedCommMonoid α] {s : Multiset ι} {f g : ι → α} :\n    (s.map fun i ↦ min (f i) (g i)).prod ≤ min (s.map f).prod (s.map g).prod := by\n  obtain ⟨l⟩ := s\n  simp_rw [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.prod_coe]\n  apply List.prod_min_le\n\n"}
{"name":"Multiset.sum_min_le","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : LinearOrderedAddCommMonoid α\ns : Multiset ι\nf g : ι → α\n⊢ LE.le (Multiset.map (fun i => Min.min (f i) (g i)) s).sum (Min.min (Multiset.map f s).sum (Multiset.map g s).sum)","decl":"@[to_additive]\nlemma prod_min_le [LinearOrderedCommMonoid α] {s : Multiset ι} {f g : ι → α} :\n    (s.map fun i ↦ min (f i) (g i)).prod ≤ min (s.map f).prod (s.map g).prod := by\n  obtain ⟨l⟩ := s\n  simp_rw [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.prod_coe]\n  apply List.prod_min_le\n\n"}
{"name":"Multiset.abs_sum_le_sum_abs","module":"Mathlib.Algebra.Order.BigOperators.Group.Multiset","initialProofState":"α : Type u_2\ninst✝ : LinearOrderedAddCommGroup α\ns : Multiset α\n⊢ LE.le (abs s.sum) (Multiset.map abs s).sum","decl":"lemma abs_sum_le_sum_abs [LinearOrderedAddCommGroup α] {s : Multiset α} :\n    |s.sum| ≤ (s.map abs).sum :=\n  le_sum_of_subadditive _ abs_zero abs_add s\n\n"}
