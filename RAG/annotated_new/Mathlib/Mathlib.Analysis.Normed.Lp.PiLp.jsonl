{"name":"PiLp.ext_iff","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nx y : PiLp p Î±\nâŠ¢ Iff (Eq x y) (âˆ€ (i : Î¹), Eq (x i) (y i))","decl":"@[ext]\nprotected theorem PiLp.ext {p : â„â‰¥0âˆ} {Î¹ : Type*} {Î± : Î¹ â†’ Type*} {x y : PiLp p Î±}\n    (h : âˆ€ i, x i = y i) : x = y := funext h\n\n"}
{"name":"PiLp.ext","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_1\nÎ± : Î¹ â†’ Type u_2\nx y : PiLp p Î±\nh : âˆ€ (i : Î¹), Eq (x i) (y i)\nâŠ¢ Eq x y","decl":"@[ext]\nprotected theorem PiLp.ext {p : â„â‰¥0âˆ} {Î¹ : Type*} {Î± : Î¹ â†’ Type*} {x y : PiLp p Î±}\n    (h : âˆ€ i, x i = y i) : x = y := funext h\n\n"}
{"name":"PiLp.zero_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ni : Î¹\nâŠ¢ Eq (0 i) 0","decl":"@[simp, nolint simpNF]\ntheorem zero_apply : (0 : PiLp p Î²) i = 0 :=\n  rfl\n\n"}
{"name":"PiLp.add_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx y : PiLp p Î²\ni : Î¹\nâŠ¢ Eq (HAdd.hAdd x y i) (HAdd.hAdd (x i) (y i))","decl":"@[simp]\ntheorem add_apply : (x + y) i = x i + y i :=\n  rfl\n\n"}
{"name":"PiLp.sub_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx y : PiLp p Î²\ni : Î¹\nâŠ¢ Eq (HSub.hSub x y i) (HSub.hSub (x i) (y i))","decl":"@[simp]\ntheorem sub_apply : (x - y) i = x i - y i :=\n  rfl\n\n"}
{"name":"PiLp.smul_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ² : Semiring ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Î² i)\nc : ğ•œ\nx : PiLp p Î²\ni : Î¹\nâŠ¢ Eq (HSMul.hSMul c x i) (HSMul.hSMul c (x i))","decl":"@[simp]\ntheorem smul_apply : (c â€¢ x) i = c â€¢ x i :=\n  rfl\n\n"}
{"name":"PiLp.neg_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx : PiLp p Î²\ni : Î¹\nâŠ¢ Eq (Neg.neg x i) (Neg.neg (x i))","decl":"@[simp]\ntheorem neg_apply : (-x) i = -x i :=\n  rfl\n\n"}
{"name":"PiLp.projâ‚—_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ² : Semiring ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Î² i)\ni : Î¹\naâœ : PiLp p Î²\nâŠ¢ Eq ((PiLp.projâ‚— p Î² i) aâœ) ((WithLp.equiv p ((i : Î¹) â†’ Î² i)) aâœ i)","decl":"variable (p) in\n/-- The projection on the `i`-th coordinate of `WithLp p (âˆ€ i, Î± i)`, as a linear map. -/\n@[simps!]\ndef projâ‚— (i : Î¹) : PiLp p Î² â†’â‚—[ğ•œ] Î² i :=\n  (LinearMap.proj i : (âˆ€ i, Î² i) â†’â‚—[ğ•œ] Î² i) âˆ˜â‚— (WithLp.linearEquiv p ğ•œ (âˆ€ i, Î² i)).toLinearMap\n\n"}
{"name":"WithLp.equiv_pi_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\nx : PiLp p Î±\ni : Î¹\nâŠ¢ Eq ((WithLp.equiv p ((i : Î¹) â†’ Î± i)) x i) (x i)","decl":"@[simp]\ntheorem _root_.WithLp.equiv_pi_apply (x : PiLp p Î±) (i : Î¹) : WithLp.equiv p _ x i = x i :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_pi_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\nx : (i : Î¹) â†’ Î± i\ni : Î¹\nâŠ¢ Eq ((WithLp.equiv p ((i : Î¹) â†’ Î± i)).symm x i) (x i)","decl":"@[simp]\ntheorem  _root_.WithLp.equiv_symm_pi_apply (x : âˆ€ i, Î± i) (i : Î¹) :\n    (WithLp.equiv p _).symm x i = x i :=\n  rfl\n\n"}
{"name":"PiLp.edist_eq_card","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ EDist (Î² i)\nf g : PiLp 0 Î²\nâŠ¢ Eq (EDist.edist f g) â†‘â‹¯.toFinset.card","decl":"theorem edist_eq_card (f g : PiLp 0 Î²) :\n    edist f g = {i | edist (f i) (g i) â‰  0}.toFinite.toFinset.card :=\n  if_pos rfl\n\n"}
{"name":"PiLp.edist_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ EDist (Î² i)\np : ENNReal\nhp : LT.lt 0 p.toReal\nf g : PiLp p Î²\nâŠ¢ Eq (EDist.edist f g) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (EDist.edist (f i) (g i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem edist_eq_sum {p : â„â‰¥0âˆ} (hp : 0 < p.toReal) (f g : PiLp p Î²) :\n    edist f g = (âˆ‘ i, edist (f i) (g i) ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"PiLp.edist_eq_iSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ EDist (Î² i)\nf g : PiLp Top.top Î²\nâŠ¢ Eq (EDist.edist f g) (iSup fun i => EDist.edist (f i) (g i))","decl":"theorem edist_eq_iSup (f g : PiLp âˆ Î²) : edist f g = â¨† i, edist (f i) (g i) := rfl\n\n"}
{"name":"PiLp.edist_self","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ PseudoEMetricSpace (Î² i)\nf : PiLp p Î²\nâŠ¢ Eq (EDist.edist f f) 0","decl":"/-- This holds independent of `p` and does not require `[Fact (1 â‰¤ p)]`. We keep it separate\nfrom `pi_Lp.pseudo_emetric_space` so it can be used also for `p < 1`. -/\nprotected theorem edist_self (f : PiLp p Î²) : edist f f = 0 := by\n  rcases p.trichotomy with (rfl | rfl | h)\n  Â· simp [edist_eq_card]\n  Â· simp [edist_eq_iSup]\n  Â· simp [edist_eq_sum h, ENNReal.zero_rpow_of_pos h, ENNReal.zero_rpow_of_pos (inv_pos.2 <| h)]\n\n"}
{"name":"PiLp.edist_comm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ PseudoEMetricSpace (Î² i)\nf g : PiLp p Î²\nâŠ¢ Eq (EDist.edist f g) (EDist.edist g f)","decl":"/-- This holds independent of `p` and does not require `[Fact (1 â‰¤ p)]`. We keep it separate\nfrom `pi_Lp.pseudo_emetric_space` so it can be used also for `p < 1`. -/\nprotected theorem edist_comm (f g : PiLp p Î²) : edist f g = edist g f := by\n  rcases p.trichotomy with (rfl | rfl | h)\n  Â· simp only [edist_eq_card, edist_comm]\n  Â· simp only [edist_eq_iSup, edist_comm]\n  Â· simp only [edist_eq_sum h, edist_comm]\n\n"}
{"name":"PiLp.dist_eq_card","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ Dist (Î± i)\nf g : PiLp 0 Î±\nâŠ¢ Eq (Dist.dist f g) â†‘â‹¯.toFinset.card","decl":"theorem dist_eq_card (f g : PiLp 0 Î±) :\n    dist f g = {i | dist (f i) (g i) â‰  0}.toFinite.toFinset.card :=\n  if_pos rfl\n\n"}
{"name":"PiLp.dist_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ Dist (Î± i)\np : ENNReal\nhp : LT.lt 0 p.toReal\nf g : PiLp p Î±\nâŠ¢ Eq (Dist.dist f g) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (Dist.dist (f i) (g i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem dist_eq_sum {p : â„â‰¥0âˆ} (hp : 0 < p.toReal) (f g : PiLp p Î±) :\n    dist f g = (âˆ‘ i, dist (f i) (g i) ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"PiLp.dist_eq_iSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ Dist (Î± i)\nf g : PiLp Top.top Î±\nâŠ¢ Eq (Dist.dist f g) (iSup fun i => Dist.dist (f i) (g i))","decl":"theorem dist_eq_iSup (f g : PiLp âˆ Î±) : dist f g = â¨† i, dist (f i) (g i) := rfl\n\n"}
{"name":"PiLp.norm_eq_card","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ Norm (Î² i)\nf : PiLp 0 Î²\nâŠ¢ Eq (Norm.norm f) â†‘â‹¯.toFinset.card","decl":"theorem norm_eq_card (f : PiLp 0 Î²) : â€–fâ€– = {i | â€–f iâ€– â‰  0}.toFinite.toFinset.card :=\n  if_pos rfl\n\n"}
{"name":"PiLp.norm_eq_ciSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ Norm (Î² i)\nf : PiLp Top.top Î²\nâŠ¢ Eq (Norm.norm f) (iSup fun i => Norm.norm (f i))","decl":"theorem norm_eq_ciSup (f : PiLp âˆ Î²) : â€–fâ€– = â¨† i, â€–f iâ€– := rfl\n\n"}
{"name":"PiLp.norm_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ Norm (Î² i)\nhp : LT.lt 0 p.toReal\nf : PiLp p Î²\nâŠ¢ Eq (Norm.norm f) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (Norm.norm (f i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem norm_eq_sum (hp : 0 < p.toReal) (f : PiLp p Î²) :\n    â€–fâ€– = (âˆ‘ i, â€–f iâ€– ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"PiLp.iSup_edist_ne_top_aux","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_5\ninstâœÂ¹ : Finite Î¹\nÎ± : Î¹ â†’ Type u_6\ninstâœ : (i : Î¹) â†’ PseudoMetricSpace (Î± i)\nf g : PiLp Top.top Î±\nâŠ¢ Ne (iSup fun i => EDist.edist (f i) (g i)) Top.top","decl":"/-- An auxiliary lemma used twice in the proof of `PiLp.pseudoMetricAux` below. Not intended for\nuse outside this file. -/\ntheorem iSup_edist_ne_top_aux {Î¹ : Type*} [Finite Î¹] {Î± : Î¹ â†’ Type*}\n    [âˆ€ i, PseudoMetricSpace (Î± i)] (f g : PiLp âˆ Î±) : (â¨† i, edist (f i) (g i)) â‰  âŠ¤ := by\n  cases nonempty_fintype Î¹\n  obtain âŸ¨M, hMâŸ© := Finite.exists_le fun i => (âŸ¨dist (f i) (g i), dist_nonnegâŸ© : â„â‰¥0)\n  refine ne_of_lt ((iSup_le fun i => ?_).trans_lt (@ENNReal.coe_lt_top M))\n  simp only [edist, PseudoMetricSpace.edist_dist, ENNReal.ofReal_eq_coe_nnreal dist_nonneg]\n  exact mod_cast hM i\n\n"}
{"name":"PiLp.lipschitzWith_equiv_aux","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ² : Fact (LE.le 1 p)\ninstâœÂ¹ : (i : Î¹) â†’ PseudoEMetricSpace (Î² i)\ninstâœ : Fintype Î¹\nâŠ¢ LipschitzWith 1 â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i))","decl":"theorem lipschitzWith_equiv_aux : LipschitzWith 1 (WithLp.equiv p (âˆ€ i, Î² i)) := by\n  intro x y\n  simp_rw [ENNReal.coe_one, one_mul, edist_pi_def, Finset.sup_le_iff, Finset.mem_univ,\n    forall_true_left, WithLp.equiv_pi_apply]\n  rcases p.dichotomy with (rfl | h)\n  Â· simpa only [edist_eq_iSup] using le_iSup fun i => edist (x i) (y i)\n  Â· have cancel : p.toReal * (1 / p.toReal) = 1 := mul_div_cancelâ‚€ 1 (zero_lt_one.trans_le h).ne'\n    rw [edist_eq_sum (zero_lt_one.trans_le h)]\n    intro i\n    calc\n      edist (x i) (y i) = (edist (x i) (y i) ^ p.toReal) ^ (1 / p.toReal) := by\n        simp [â† ENNReal.rpow_mul, cancel, -one_div]\n      _ â‰¤ (âˆ‘ i, edist (x i) (y i) ^ p.toReal) ^ (1 / p.toReal) := by\n        gcongr\n        exact Finset.single_le_sum (fun i _ => (bot_le : (0 : â„â‰¥0âˆ) â‰¤ _)) (Finset.mem_univ i)\n\n"}
{"name":"PiLp.antilipschitzWith_equiv_aux","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ² : Fact (LE.le 1 p)\ninstâœÂ¹ : (i : Î¹) â†’ PseudoEMetricSpace (Î² i)\ninstâœ : Fintype Î¹\nâŠ¢ AntilipschitzWith (HPow.hPow (â†‘(Fintype.card Î¹)) (HDiv.hDiv 1 p).toReal) â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i))","decl":"theorem antilipschitzWith_equiv_aux :\n    AntilipschitzWith ((Fintype.card Î¹ : â„â‰¥0) ^ (1 / p).toReal) (WithLp.equiv p (âˆ€ i, Î² i)) := by\n  intro x y\n  rcases p.dichotomy with (rfl | h)\n  Â· simp only [edist_eq_iSup, ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero,\n      ENNReal.coe_one, one_mul, iSup_le_iff]\n    -- Porting note: `Finset.le_sup` needed some help\n    exact fun i => Finset.le_sup (f := fun i => edist (x i) (y i)) (Finset.mem_univ i)\n  Â· have pos : 0 < p.toReal := zero_lt_one.trans_le h\n    have nonneg : 0 â‰¤ 1 / p.toReal := one_div_nonneg.2 (le_of_lt pos)\n    have cancel : p.toReal * (1 / p.toReal) = 1 := mul_div_cancelâ‚€ 1 (ne_of_gt pos)\n    rw [edist_eq_sum pos, ENNReal.toReal_div 1 p]\n    simp only [edist, â† one_div, ENNReal.one_toReal]\n    calc\n      (âˆ‘ i, edist (x i) (y i) ^ p.toReal) ^ (1 / p.toReal) â‰¤\n          (âˆ‘ _i, edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) ^ p.toReal) ^ (1 / p.toReal) := by\n        gcongr with i\n        exact Finset.le_sup (f := fun i => edist (x i) (y i)) (Finset.mem_univ i)\n      _ =\n          ((Fintype.card Î¹ : â„â‰¥0) ^ (1 / p.toReal) : â„â‰¥0) *\n            edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) := by\n        simp only [nsmul_eq_mul, Finset.card_univ, ENNReal.rpow_one, Finset.sum_const,\n          ENNReal.mul_rpow_of_nonneg _ _ nonneg, â† ENNReal.rpow_mul, cancel]\n        have : (Fintype.card Î¹ : â„â‰¥0âˆ) = (Fintype.card Î¹ : â„â‰¥0) :=\n          (ENNReal.coe_natCast (Fintype.card Î¹)).symm\n        rw [this, ENNReal.coe_rpow_of_nonneg _ nonneg]\n\n"}
{"name":"PiLp.aux_uniformity_eq","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ² : Fact (LE.le 1 p)\ninstâœÂ¹ : (i : Î¹) â†’ PseudoEMetricSpace (Î² i)\ninstâœ : Fintype Î¹\nâŠ¢ Eq (uniformity (PiLp p Î²)) (uniformity ((i : Î¹) â†’ Î² i))","decl":"theorem aux_uniformity_eq : ğ“¤ (PiLp p Î²) = ğ“¤[Pi.uniformSpace _] := by\n  have A : IsUniformInducing (WithLp.equiv p (âˆ€ i, Î² i)) :=\n    (antilipschitzWith_equiv_aux p Î²).isUniformInducing\n      (lipschitzWith_equiv_aux p Î²).uniformContinuous\n  have : (fun x : PiLp p Î² Ã— PiLp p Î² => (WithLp.equiv p _ x.fst, WithLp.equiv p _ x.snd)) = id :=\n    by ext i <;> rfl\n  rw [â† A.comap_uniformity, this, comap_id]\n\n"}
{"name":"PiLp.aux_cobounded_eq","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\ninstâœÂ² : Fact (LE.le 1 p)\ninstâœÂ¹ : (i : Î¹) â†’ PseudoMetricSpace (Î± i)\ninstâœ : Fintype Î¹\nâŠ¢ Eq (Bornology.cobounded (PiLp p Î±)) (Bornology.cobounded ((i : Î¹) â†’ Î± i))","decl":"theorem aux_cobounded_eq : cobounded (PiLp p Î±) = @cobounded _ Pi.instBornology :=\n  calc\n    cobounded (PiLp p Î±) = comap (WithLp.equiv p (âˆ€ i, Î± i)) (cobounded _) :=\n      le_antisymm (antilipschitzWith_equiv_aux p Î±).tendsto_cobounded.le_comap\n        (lipschitzWith_equiv_aux p Î±).comap_cobounded_le\n    _ = _ := comap_id\n\n"}
{"name":"PiLp.uniformContinuous_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ UniformSpace (Î² i)\nâŠ¢ UniformContinuous â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i))","decl":"theorem uniformContinuous_equiv [âˆ€ i, UniformSpace (Î² i)] :\n    UniformContinuous (WithLp.equiv p (âˆ€ i, Î² i)) :=\n  uniformContinuous_id\n\n"}
{"name":"PiLp.uniformContinuous_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ UniformSpace (Î² i)\nâŠ¢ UniformContinuous â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm","decl":"theorem uniformContinuous_equiv_symm [âˆ€ i, UniformSpace (Î² i)] :\n    UniformContinuous (WithLp.equiv p (âˆ€ i, Î² i)).symm :=\n  uniformContinuous_id\n\n"}
{"name":"PiLp.continuous_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ UniformSpace (Î² i)\nâŠ¢ Continuous â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i))","decl":"@[continuity]\ntheorem continuous_equiv [âˆ€ i, UniformSpace (Î² i)] : Continuous (WithLp.equiv p (âˆ€ i, Î² i)) :=\n  continuous_id\n\n"}
{"name":"PiLp.continuous_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœ : (i : Î¹) â†’ UniformSpace (Î² i)\nâŠ¢ Continuous â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm","decl":"@[continuity]\ntheorem continuous_equiv_symm [âˆ€ i, UniformSpace (Î² i)] :\n    Continuous (WithLp.equiv p (âˆ€ i, Î² i)).symm :=\n  continuous_id\n\n"}
{"name":"PiLp.nndist_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\ninstâœÂ² : Fintype Î¹\np : ENNReal\ninstâœÂ¹ : Fact (LE.le 1 p)\nÎ² : Î¹ â†’ Type u_5\ninstâœ : (i : Î¹) â†’ PseudoMetricSpace (Î² i)\nhp : Ne p Top.top\nx y : PiLp p Î²\nâŠ¢ Eq (NNDist.nndist x y) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (NNDist.nndist (x i) (y i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem nndist_eq_sum {p : â„â‰¥0âˆ} [Fact (1 â‰¤ p)] {Î² : Î¹ â†’ Type*} [âˆ€ i, PseudoMetricSpace (Î² i)]\n    (hp : p â‰  âˆ) (x y : PiLp p Î²) :\n    nndist x y = (âˆ‘ i : Î¹, nndist (x i) (y i) ^ p.toReal) ^ (1 / p.toReal) :=\n  -- Porting note: was `Subtype.ext`\n  NNReal.eq <| by\n    push_cast\n    exact dist_eq_sum (p.toReal_pos_iff_ne_top.mpr hp) _ _\n\n"}
{"name":"PiLp.nndist_eq_iSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\ninstâœÂ¹ : Fintype Î¹\nÎ² : Î¹ â†’ Type u_5\ninstâœ : (i : Î¹) â†’ PseudoMetricSpace (Î² i)\nx y : PiLp Top.top Î²\nâŠ¢ Eq (NNDist.nndist x y) (iSup fun i => NNDist.nndist (x i) (y i))","decl":"theorem nndist_eq_iSup {Î² : Î¹ â†’ Type*} [âˆ€ i, PseudoMetricSpace (Î² i)] (x y : PiLp âˆ Î²) :\n    nndist x y = â¨† i, nndist (x i) (y i) :=\n  -- Porting note: was `Subtype.ext`\n  NNReal.eq <| by\n    push_cast\n    exact dist_eq_iSup _ _\n\n"}
{"name":"PiLp.lipschitzWith_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ PseudoEMetricSpace (Î² i)\nâŠ¢ LipschitzWith 1 â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i))","decl":"theorem lipschitzWith_equiv [âˆ€ i, PseudoEMetricSpace (Î² i)] :\n    LipschitzWith 1 (WithLp.equiv p (âˆ€ i, Î² i)) :=\n  lipschitzWith_equiv_aux p Î²\n\n"}
{"name":"PiLp.antilipschitzWith_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ PseudoEMetricSpace (Î² i)\nâŠ¢ AntilipschitzWith (HPow.hPow (â†‘(Fintype.card Î¹)) (HDiv.hDiv 1 p).toReal) â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i))","decl":"theorem antilipschitzWith_equiv [âˆ€ i, PseudoEMetricSpace (Î² i)] :\n    AntilipschitzWith ((Fintype.card Î¹ : â„â‰¥0) ^ (1 / p).toReal) (WithLp.equiv p (âˆ€ i, Î² i)) :=\n  antilipschitzWith_equiv_aux p Î²\n\n"}
{"name":"PiLp.infty_equiv_isometry","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ PseudoEMetricSpace (Î² i)\nâŠ¢ Isometry â‡‘(WithLp.equiv Top.top ((i : Î¹) â†’ Î² i))","decl":"theorem infty_equiv_isometry [âˆ€ i, PseudoEMetricSpace (Î² i)] :\n    Isometry (WithLp.equiv âˆ (âˆ€ i, Î² i)) :=\n  fun x y =>\n  le_antisymm (by simpa only [ENNReal.coe_one, one_mul] using lipschitzWith_equiv âˆ Î² x y)\n    (by\n      simpa only [ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero, ENNReal.coe_one,\n        one_mul] using antilipschitzWith_equiv âˆ Î² x y)\n\n"}
{"name":"PiLp.nnnorm_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\ninstâœÂ² : Fintype Î¹\np : ENNReal\ninstâœÂ¹ : Fact (LE.le 1 p)\nÎ² : Î¹ â†’ Type u_5\nhp : Ne p Top.top\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nf : PiLp p Î²\nâŠ¢ Eq (NNNorm.nnnorm f) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (NNNorm.nnnorm (f i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem nnnorm_eq_sum {p : â„â‰¥0âˆ} [Fact (1 â‰¤ p)] {Î² : Î¹ â†’ Type*} (hp : p â‰  âˆ)\n    [âˆ€ i, SeminormedAddCommGroup (Î² i)] (f : PiLp p Î²) :\n    â€–fâ€–â‚Š = (âˆ‘ i, â€–f iâ€–â‚Š ^ p.toReal) ^ (1 / p.toReal) := by\n  ext\n  simp [NNReal.coe_sum, norm_eq_sum (p.toReal_pos_iff_ne_top.mpr hp)]\n\n"}
{"name":"PiLp.nnnorm_eq_ciSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nf : PiLp Top.top Î²\nâŠ¢ Eq (NNNorm.nnnorm f) (iSup fun i => NNNorm.nnnorm (f i))","decl":"theorem nnnorm_eq_ciSup (f : PiLp âˆ Î²) : â€–fâ€–â‚Š = â¨† i, â€–f iâ€–â‚Š := by\n  ext\n  simp [NNReal.coe_iSup, norm_eq_ciSup]\n\n"}
{"name":"PiLp.nnnorm_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nf : PiLp Top.top Î²\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv Top.top ((i : Î¹) â†’ Î² i)) f)) (NNNorm.nnnorm f)","decl":"@[simp] theorem nnnorm_equiv (f : PiLp âˆ Î²) : â€–WithLp.equiv âŠ¤ _ fâ€–â‚Š = â€–fâ€–â‚Š := by\n  rw [nnnorm_eq_ciSup, Pi.nnnorm_def, Finset.sup_univ_eq_ciSup]\n  dsimp only [WithLp.equiv_pi_apply]\n\n"}
{"name":"PiLp.nnnorm_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nf : (i : Î¹) â†’ Î² i\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv Top.top ((i : Î¹) â†’ Î² i)).symm f)) (NNNorm.nnnorm f)","decl":"@[simp] theorem nnnorm_equiv_symm (f : âˆ€ i, Î² i) : â€–(WithLp.equiv âŠ¤ _).symm fâ€–â‚Š = â€–fâ€–â‚Š :=\n  (nnnorm_equiv _).symm\n\n"}
{"name":"PiLp.norm_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nf : PiLp Top.top Î²\nâŠ¢ Eq (Norm.norm ((WithLp.equiv Top.top ((i : Î¹) â†’ Î² i)) f)) (Norm.norm f)","decl":"@[simp] theorem norm_equiv (f : PiLp âˆ Î²) : â€–WithLp.equiv âŠ¤ _ fâ€– = â€–fâ€– :=\n  congr_arg NNReal.toReal <| nnnorm_equiv f\n\n"}
{"name":"PiLp.norm_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nf : (i : Î¹) â†’ Î² i\nâŠ¢ Eq (Norm.norm ((WithLp.equiv Top.top ((i : Î¹) â†’ Î² i)).symm f)) (Norm.norm f)","decl":"@[simp] theorem norm_equiv_symm (f : âˆ€ i, Î² i) : â€–(WithLp.equiv âŠ¤ _).symm fâ€– = â€–fâ€– :=\n  (norm_equiv _).symm\n\n"}
{"name":"PiLp.norm_eq_of_nat","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\ninstâœÂ² : Fintype Î¹\np : ENNReal\ninstâœÂ¹ : Fact (LE.le 1 p)\nÎ² : Î¹ â†’ Type u_5\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nn : Nat\nh : Eq p â†‘n\nf : PiLp p Î²\nâŠ¢ Eq (Norm.norm f) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (Norm.norm (f i)) n) (HDiv.hDiv 1 â†‘n))","decl":"theorem norm_eq_of_nat {p : â„â‰¥0âˆ} [Fact (1 â‰¤ p)] {Î² : Î¹ â†’ Type*}\n    [âˆ€ i, SeminormedAddCommGroup (Î² i)] (n : â„•) (h : p = n) (f : PiLp p Î²) :\n    â€–fâ€– = (âˆ‘ i, â€–f iâ€– ^ n) ^ (1 / (n : â„)) := by\n  have := p.toReal_pos_iff_ne_top.mpr (ne_of_eq_of_ne h <| ENNReal.natCast_ne_top n)\n  simp only [one_div, h, Real.rpow_natCast, ENNReal.toReal_nat, eq_self_iff_true, Finset.sum_congr,\n    norm_eq_sum this]\n\n"}
{"name":"PiLp.norm_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx : PiLp 1 Î²\nâŠ¢ Eq (Norm.norm x) (Finset.univ.sum fun i => Norm.norm (x i))","decl":"theorem norm_eq_of_L1 (x : PiLp 1 Î²) : â€–xâ€– = âˆ‘ i : Î¹, â€–x iâ€– := by\n  simp [norm_eq_sum]\n\n"}
{"name":"PiLp.nnnorm_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx : PiLp 1 Î²\nâŠ¢ Eq (NNNorm.nnnorm x) (Finset.univ.sum fun i => NNNorm.nnnorm (x i))","decl":"theorem nnnorm_eq_of_L1 (x : PiLp 1 Î²) : â€–xâ€–â‚Š = âˆ‘ i : Î¹, â€–x iâ€–â‚Š :=\n  NNReal.eq <| by push_cast; exact norm_eq_of_L1 x\n\n"}
{"name":"PiLp.dist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx y : PiLp 1 Î²\nâŠ¢ Eq (Dist.dist x y) (Finset.univ.sum fun i => Dist.dist (x i) (y i))","decl":"theorem dist_eq_of_L1 (x y : PiLp 1 Î²) : dist x y = âˆ‘ i, dist (x i) (y i) := by\n  simp_rw [dist_eq_norm, norm_eq_of_L1, sub_apply]\n\n"}
{"name":"PiLp.nndist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx y : PiLp 1 Î²\nâŠ¢ Eq (NNDist.nndist x y) (Finset.univ.sum fun i => NNDist.nndist (x i) (y i))","decl":"theorem nndist_eq_of_L1 (x y : PiLp 1 Î²) : nndist x y = âˆ‘ i, nndist (x i) (y i) :=\n  NNReal.eq <| by push_cast; exact dist_eq_of_L1 _ _\n\n"}
{"name":"PiLp.edist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx y : PiLp 1 Î²\nâŠ¢ Eq (EDist.edist x y) (Finset.univ.sum fun i => EDist.edist (x i) (y i))","decl":"theorem edist_eq_of_L1 (x y : PiLp 1 Î²) : edist x y = âˆ‘ i, edist (x i) (y i) := by\n  simp [PiLp.edist_eq_sum]\n\n"}
{"name":"PiLp.norm_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx : PiLp 2 Î²\nâŠ¢ Eq (Norm.norm x) (Finset.univ.sum fun i => HPow.hPow (Norm.norm (x i)) 2).sqrt","decl":"theorem norm_eq_of_L2 (x : PiLp 2 Î²) :\n    â€–xâ€– = âˆš(âˆ‘ i : Î¹, â€–x iâ€– ^ 2) := by\n  rw [norm_eq_of_nat 2 (by norm_cast) _]\n  rw [Real.sqrt_eq_rpow]\n  norm_cast\n\n"}
{"name":"PiLp.nnnorm_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx : PiLp 2 Î²\nâŠ¢ Eq (NNNorm.nnnorm x) (NNReal.sqrt (Finset.univ.sum fun i => HPow.hPow (NNNorm.nnnorm (x i)) 2))","decl":"theorem nnnorm_eq_of_L2 (x : PiLp 2 Î²) :\n    â€–xâ€–â‚Š = NNReal.sqrt (âˆ‘ i : Î¹, â€–x iâ€–â‚Š ^ 2) :=\n  NNReal.eq <| by\n    push_cast\n    exact norm_eq_of_L2 x\n\n"}
{"name":"PiLp.norm_sq_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\ninstâœÂ¹ : Fintype Î¹\nÎ² : Î¹ â†’ Type u_5\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx : PiLp 2 Î²\nâŠ¢ Eq (HPow.hPow (Norm.norm x) 2) (Finset.univ.sum fun i => HPow.hPow (Norm.norm (x i)) 2)","decl":"theorem norm_sq_eq_of_L2 (Î² : Î¹ â†’ Type*) [âˆ€ i, SeminormedAddCommGroup (Î² i)] (x : PiLp 2 Î²) :\n    â€–xâ€– ^ 2 = âˆ‘ i : Î¹, â€–x iâ€– ^ 2 := by\n  suffices â€–xâ€–â‚Š ^ 2 = âˆ‘ i : Î¹, â€–x iâ€–â‚Š ^ 2 by\n    simpa only [NNReal.coe_sum] using congr_arg ((â†‘) : â„â‰¥0 â†’ â„) this\n  rw [nnnorm_eq_of_L2, NNReal.sq_sqrt]\n\n"}
{"name":"PiLp.dist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx y : PiLp 2 Î²\nâŠ¢ Eq (Dist.dist x y) (Finset.univ.sum fun i => HPow.hPow (Dist.dist (x i) (y i)) 2).sqrt","decl":"theorem dist_eq_of_L2 (x y : PiLp 2 Î²) :\n    dist x y = âˆš(âˆ‘ i, dist (x i) (y i) ^ 2) := by\n  simp_rw [dist_eq_norm, norm_eq_of_L2, sub_apply]\n\n"}
{"name":"PiLp.nndist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx y : PiLp 2 Î²\nâŠ¢ Eq (NNDist.nndist x y) (NNReal.sqrt (Finset.univ.sum fun i => HPow.hPow (NNDist.nndist (x i) (y i)) 2))","decl":"theorem nndist_eq_of_L2 (x y : PiLp 2 Î²) :\n    nndist x y = NNReal.sqrt (âˆ‘ i, nndist (x i) (y i) ^ 2) :=\n  NNReal.eq <| by\n    push_cast\n    exact dist_eq_of_L2 _ _\n\n"}
{"name":"PiLp.edist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Î¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\nx y : PiLp 2 Î²\nâŠ¢ Eq (EDist.edist x y) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (EDist.edist (x i) (y i)) 2) (1 / 2))","decl":"theorem edist_eq_of_L2 (x y : PiLp 2 Î²) :\n    edist x y = (âˆ‘ i, edist (x i) (y i) ^ 2) ^ (1 / 2 : â„) := by simp [PiLp.edist_eq_sum]\n\n"}
{"name":"PiLp.instBoundedSMul","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœâ´ : Fintype Î¹\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœÂ¹ : (i : Î¹) â†’ Module ğ•œ (Î² i)\ninstâœ : âˆ€ (i : Î¹), BoundedSMul ğ•œ (Î² i)\nâŠ¢ BoundedSMul ğ•œ (PiLp p Î²)","decl":"instance instBoundedSMul [SeminormedRing ğ•œ] [âˆ€ i, SeminormedAddCommGroup (Î² i)]\n    [âˆ€ i, Module ğ•œ (Î² i)] [âˆ€ i, BoundedSMul ğ•œ (Î² i)] :\n    BoundedSMul ğ•œ (PiLp p Î²) :=\n  .of_nnnorm_smul_le fun c f => by\n    rcases p.dichotomy with (rfl | hp)\n    Â· rw [â† nnnorm_equiv, â† nnnorm_equiv, WithLp.equiv_smul]\n      exact nnnorm_smul_le c (WithLp.equiv âˆ (âˆ€ i, Î² i) f)\n    Â· have hp0 : 0 < p.toReal := zero_lt_one.trans_le hp\n      have hpt : p â‰  âŠ¤ := p.toReal_pos_iff_ne_top.mp hp0\n      rw [nnnorm_eq_sum hpt, nnnorm_eq_sum hpt, one_div, NNReal.rpow_inv_le_iff hp0,\n        NNReal.mul_rpow, â† NNReal.rpow_mul, inv_mul_cancelâ‚€ hp0.ne', NNReal.rpow_one,\n        Finset.mul_sum]\n      simp_rw [â† NNReal.mul_rpow, smul_apply]\n      exact Finset.sum_le_sum fun i _ => NNReal.rpow_le_rpow (nnnorm_smul_le _ _) hp0.le\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrLeft_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nhp : Fact (LE.le 1 p)\ninstâœâ´ : Fintype Î¹\ninstâœÂ³ : Semiring ğ•œ\nÎ¹' : Type u_5\ninstâœÂ² : Fintype Î¹'\nE : Type u_6\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : Module ğ•œ E\ne : Equiv Î¹ Î¹'\nv : PiLp p fun x => E\nâŠ¢ Eq ((LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e) v) ((Equiv.piCongrLeft' (fun x => E) e) v)","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrLeft_apply (e : Î¹ â‰ƒ Î¹') (v : PiLp p fun _ : Î¹ => E) :\n    LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e v = Equiv.piCongrLeft' (fun _ : Î¹ => E) e v :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrLeft_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nhp : Fact (LE.le 1 p)\ninstâœâ´ : Fintype Î¹\ninstâœÂ³ : Semiring ğ•œ\nÎ¹' : Type u_5\ninstâœÂ² : Fintype Î¹'\nE : Type u_6\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : Module ğ•œ E\ne : Equiv Î¹ Î¹'\nâŠ¢ Eq (LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e).symm (LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e.symm)","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrLeft_symm (e : Î¹ â‰ƒ Î¹') :\n    (LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e).symm =\n      LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e.symm :=\n  LinearIsometryEquiv.ext fun z â†¦ -- Porting note: was `rfl`\n    congr_arg (Equiv.toFun Â· z) (Equiv.piCongrLeft'_symm _ _)\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrLeft_single","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nhp : Fact (LE.le 1 p)\ninstâœâ¶ : Fintype Î¹\ninstâœâµ : Semiring ğ•œ\nÎ¹' : Type u_5\ninstâœâ´ : Fintype Î¹'\nE : Type u_6\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : DecidableEq Î¹'\ne : Equiv Î¹ Î¹'\ni : Î¹\nv : E\nâŠ¢ Eq ((LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e) ((WithLp.equiv p (Î¹ â†’ E)).symm (Pi.single i v))) ((WithLp.equiv p (Î¹' â†’ E)).symm (Pi.single (e i) v))","decl":"@[simp high]\ntheorem _root_.LinearIsometryEquiv.piLpCongrLeft_single [DecidableEq Î¹] [DecidableEq Î¹']\n    (e : Î¹ â‰ƒ Î¹') (i : Î¹) (v : E) :\n    LinearIsometryEquiv.piLpCongrLeft p ğ•œ E e ((WithLp.equiv p (_ â†’ E)).symm <| Pi.single i v) =\n      (WithLp.equiv p (_ â†’ E)).symm (Pi.single (e i) v) := by\n  funext x\n  simp [LinearIsometryEquiv.piLpCongrLeft_apply, LinearEquiv.piCongrLeft', Equiv.piCongrLeft',\n    Pi.single, Function.update, Equiv.symm_apply_eq]\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrRight_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœâµ : Fintype Î¹\ninstâœâ´ : Semiring ğ•œ\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (Î± i)\ninstâœÂ² : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœÂ¹ : (i : Î¹) â†’ Module ğ•œ (Î± i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Î² i)\ne : (i : Î¹) â†’ LinearIsometryEquiv (RingHom.id ğ•œ) (Î± i) (Î² i)\nx : PiLp p Î±\nâŠ¢ Eq ((LinearIsometryEquiv.piLpCongrRight p e) x) ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm fun i => (e i) (x i))","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrRight_apply (e : âˆ€ i, Î± i â‰ƒâ‚—áµ¢[ğ•œ] Î² i) (x : PiLp p Î±) :\n    LinearIsometryEquiv.piLpCongrRight p e x =\n      (WithLp.equiv p _).symm (fun i => e i (x i)) :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrRight_refl","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : Semiring ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î± i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Î± i)\nâŠ¢ Eq (LinearIsometryEquiv.piLpCongrRight p fun i => LinearIsometryEquiv.refl ğ•œ (Î± i)) (LinearIsometryEquiv.refl ğ•œ (PiLp p Î±))","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrRight_refl :\n    LinearIsometryEquiv.piLpCongrRight p (fun i => .refl ğ•œ (Î± i)) = .refl _ _ :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrRight_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœâµ : Fintype Î¹\ninstâœâ´ : Semiring ğ•œ\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (Î± i)\ninstâœÂ² : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœÂ¹ : (i : Î¹) â†’ Module ğ•œ (Î± i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Î² i)\ne : (i : Î¹) â†’ LinearIsometryEquiv (RingHom.id ğ•œ) (Î± i) (Î² i)\nâŠ¢ Eq (LinearIsometryEquiv.piLpCongrRight p e).symm (LinearIsometryEquiv.piLpCongrRight p fun i => (e i).symm)","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrRight_symm (e : âˆ€ i, Î± i â‰ƒâ‚—áµ¢[ğ•œ] Î² i) :\n    (LinearIsometryEquiv.piLpCongrRight p e).symm =\n      LinearIsometryEquiv.piLpCongrRight p (fun i => (e i).symm) :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrRight_single","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ± : Î¹ â†’ Type u_3\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœâ¶ : Fintype Î¹\ninstâœâµ : Semiring ğ•œ\ninstâœâ´ : (i : Î¹) â†’ SeminormedAddCommGroup (Î± i)\ninstâœÂ³ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœÂ² : (i : Î¹) â†’ Module ğ•œ (Î± i)\ninstâœÂ¹ : (i : Î¹) â†’ Module ğ•œ (Î² i)\ne : (i : Î¹) â†’ LinearIsometryEquiv (RingHom.id ğ•œ) (Î± i) (Î² i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nv : Î± i\nâŠ¢ Eq ((LinearIsometryEquiv.piLpCongrRight p e) ((WithLp.equiv p ((i : Î¹) â†’ Î± i)).symm (Pi.single i v))) ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm (Pi.single i ((e i) v)))","decl":"@[simp high]\ntheorem _root_.LinearIsometryEquiv.piLpCongrRight_single (e : âˆ€ i, Î± i â‰ƒâ‚—áµ¢[ğ•œ] Î² i) [DecidableEq Î¹]\n    (i : Î¹) (v : Î± i) :\n    LinearIsometryEquiv.piLpCongrRight p e ((WithLp.equiv p (âˆ€ i, Î± i)).symm <| Pi.single i v) =\n      (WithLp.equiv p (âˆ€ i, Î² i)).symm (Pi.single i (e _ v)) :=\n  funext <| Pi.apply_single (e Â·) (fun _ => map_zero _) _ _\n\n"}
{"name":"LinearIsometryEquiv.piLpCurry_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : Semiring ğ•œ\nÎ¹ : Type u_5\nÎº : Î¹ â†’ Type u_6\np : ENNReal\ninstâœâ´ : Fact (LE.le 1 p)\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : (i : Î¹) â†’ Fintype (Îº i)\nÎ± : (i : Î¹) â†’ Îº i â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ (k : Îº i) â†’ SeminormedAddCommGroup (Î± i k)\ninstâœ : (i : Î¹) â†’ (k : Îº i) â†’ Module ğ•œ (Î± i k)\nf : PiLp p fun i => Î± i.fst i.snd\nâŠ¢ Eq ((LinearIsometryEquiv.piLpCurry ğ•œ p Î±) f) ((WithLp.equiv p ((i : Î¹) â†’ WithLp p ((y : Îº i) â†’ Î± i y))).symm fun i => (WithLp.equiv p ((y : Îº i) â†’ Î± i y)).symm (Sigma.curry ((WithLp.equiv p ((x : Sigma Îº) â†’ Î± x.fst x.snd)) f) i))","decl":"@[simp] theorem _root_.LinearIsometryEquiv.piLpCurry_apply\n    (f : PiLp p (fun i : Sigma Îº => Î± i.1 i.2)) :\n    _root_.LinearIsometryEquiv.piLpCurry ğ•œ p Î± f =\n      (WithLp.equiv _ _).symm (fun i => (WithLp.equiv _ _).symm <|\n        Sigma.curry (WithLp.equiv _ _ f) i) :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCurry_symm_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : Semiring ğ•œ\nÎ¹ : Type u_5\nÎº : Î¹ â†’ Type u_6\np : ENNReal\ninstâœâ´ : Fact (LE.le 1 p)\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : (i : Î¹) â†’ Fintype (Îº i)\nÎ± : (i : Î¹) â†’ Îº i â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ (k : Îº i) â†’ SeminormedAddCommGroup (Î± i k)\ninstâœ : (i : Î¹) â†’ (k : Îº i) â†’ Module ğ•œ (Î± i k)\nf : PiLp p fun i => PiLp p (Î± i)\nâŠ¢ Eq ((LinearIsometryEquiv.piLpCurry ğ•œ p Î±).symm f) ((WithLp.equiv p ((x : Sigma Îº) â†’ Î± x.fst x.snd)).symm (Sigma.uncurry fun i j => f i j))","decl":"@[simp] theorem _root_.LinearIsometryEquiv.piLpCurry_symm_apply\n    (f : PiLp p (fun i => PiLp p (Î± i))) :\n    (_root_.LinearIsometryEquiv.piLpCurry ğ•œ p Î±).symm f =\n      (WithLp.equiv _ _).symm (Sigma.uncurry fun i j => f i j) :=\n  rfl\n\n"}
{"name":"PiLp.nnnorm_equiv_symm_single","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nb : Î² i\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm (Pi.single i b))) (NNNorm.nnnorm b)","decl":"@[simp]\ntheorem nnnorm_equiv_symm_single (i : Î¹) (b : Î² i) :\n    â€–(WithLp.equiv p (âˆ€ i, Î² i)).symm (Pi.single i b)â€–â‚Š = â€–bâ€–â‚Š := by\n  haveI : Nonempty Î¹ := âŸ¨iâŸ©\n  induction p generalizing hp with\n  | top =>\n    simp_rw [nnnorm_eq_ciSup, WithLp.equiv_symm_pi_apply]\n    refine\n      ciSup_eq_of_forall_le_of_forall_lt_exists_gt (fun j => ?_) fun n hn => âŸ¨i, hn.trans_eq ?_âŸ©\n    Â· obtain rfl | hij := Decidable.eq_or_ne i j\n      Â· rw [Pi.single_eq_same]\n      Â· rw [Pi.single_eq_of_ne' hij, nnnorm_zero]\n        exact zero_le _\n    Â· rw [Pi.single_eq_same]\n  | coe p =>\n    have hp0 : (p : â„) â‰  0 :=\n      mod_cast (zero_lt_one.trans_le <| Fact.out (p := 1 â‰¤ (p : â„â‰¥0âˆ))).ne'\n    rw [nnnorm_eq_sum ENNReal.coe_ne_top, ENNReal.coe_toReal, Fintype.sum_eq_single i,\n      WithLp.equiv_symm_pi_apply, Pi.single_eq_same, â† NNReal.rpow_mul, one_div,\n      mul_inv_cancelâ‚€ hp0, NNReal.rpow_one]\n    intro j hij\n    rw [WithLp.equiv_symm_pi_apply, Pi.single_eq_of_ne hij, nnnorm_zero, NNReal.zero_rpow hp0]\n\n"}
{"name":"PiLp.norm_equiv_symm_single","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nb : Î² i\nâŠ¢ Eq (Norm.norm ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm (Pi.single i b))) (Norm.norm b)","decl":"@[simp]\ntheorem norm_equiv_symm_single (i : Î¹) (b : Î² i) :\n    â€–(WithLp.equiv p (âˆ€ i, Î² i)).symm (Pi.single i b)â€– = â€–bâ€– :=\n  congr_arg ((â†‘) : â„â‰¥0 â†’ â„) <| nnnorm_equiv_symm_single p Î² i b\n\n"}
{"name":"PiLp.nndist_equiv_symm_single_same","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nbâ‚ bâ‚‚ : Î² i\nâŠ¢ Eq (NNDist.nndist ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm (Pi.single i bâ‚)) ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm (Pi.single i bâ‚‚))) (NNDist.nndist bâ‚ bâ‚‚)","decl":"@[simp]\ntheorem nndist_equiv_symm_single_same (i : Î¹) (bâ‚ bâ‚‚ : Î² i) :\n    nndist\n        ((WithLp.equiv p (âˆ€ i, Î² i)).symm (Pi.single i bâ‚))\n        ((WithLp.equiv p (âˆ€ i, Î² i)).symm (Pi.single i bâ‚‚)) =\n      nndist bâ‚ bâ‚‚ := by\n  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, â† WithLp.equiv_symm_sub, â† Pi.single_sub,\n    nnnorm_equiv_symm_single]\n\n"}
{"name":"PiLp.dist_equiv_symm_single_same","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nbâ‚ bâ‚‚ : Î² i\nâŠ¢ Eq (Dist.dist ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm (Pi.single i bâ‚)) ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm (Pi.single i bâ‚‚))) (Dist.dist bâ‚ bâ‚‚)","decl":"@[simp]\ntheorem dist_equiv_symm_single_same (i : Î¹) (bâ‚ bâ‚‚ : Î² i) :\n    dist\n        ((WithLp.equiv p (âˆ€ i, Î² i)).symm (Pi.single i bâ‚))\n        ((WithLp.equiv p (âˆ€ i, Î² i)).symm (Pi.single i bâ‚‚)) =\n      dist bâ‚ bâ‚‚ :=\n  congr_arg ((â†‘) : â„â‰¥0 â†’ â„) <| nndist_equiv_symm_single_same p Î² i bâ‚ bâ‚‚\n\n"}
{"name":"PiLp.edist_equiv_symm_single_same","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\nhp : Fact (LE.le 1 p)\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nbâ‚ bâ‚‚ : Î² i\nâŠ¢ Eq (EDist.edist ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm (Pi.single i bâ‚)) ((WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm (Pi.single i bâ‚‚))) (EDist.edist bâ‚ bâ‚‚)","decl":"@[simp]\ntheorem edist_equiv_symm_single_same (i : Î¹) (bâ‚ bâ‚‚ : Î² i) :\n    edist\n        ((WithLp.equiv p (âˆ€ i, Î² i)).symm (Pi.single i bâ‚))\n        ((WithLp.equiv p (âˆ€ i, Î² i)).symm (Pi.single i bâ‚‚)) =\n      edist bâ‚ bâ‚‚ := by\n  simp only [edist_nndist, nndist_equiv_symm_single_same p Î² i bâ‚ bâ‚‚]\n\n"}
{"name":"PiLp.nnnorm_equiv_symm_const","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nhpâœ : Fact (LE.le 1 p)\ninstâœÂ¹ : Fintype Î¹\nÎ² : Type u_5\ninstâœ : SeminormedAddCommGroup Î²\nhp : Ne p Top.top\nb : Î²\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Î¹ â†’ Î²)).symm (Function.const Î¹ b))) (HMul.hMul (HPow.hPow (â†‘(Fintype.card Î¹)) (HDiv.hDiv 1 p).toReal) (NNNorm.nnnorm b))","decl":"/-- When `p = âˆ`, this lemma does not hold without the additional assumption `Nonempty Î¹` because\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `â€–bâ€–â‚Š`. See\n`PiLp.nnnorm_equiv_symm_const'` for a version which exchanges the hypothesis `p â‰  âˆ` for\n`Nonempty Î¹`. -/\ntheorem nnnorm_equiv_symm_const {Î²} [SeminormedAddCommGroup Î²] (hp : p â‰  âˆ) (b : Î²) :\n    â€–(WithLp.equiv p (Î¹ â†’ Î²)).symm (Function.const _ b)â€–â‚Š =\n      (Fintype.card Î¹ : â„â‰¥0) ^ (1 / p).toReal * â€–bâ€–â‚Š := by\n  rcases p.dichotomy with (h | h)\n  Â· exact False.elim (hp h)\n  Â· have ne_zero : p.toReal â‰  0 := (zero_lt_one.trans_le h).ne'\n    simp_rw [nnnorm_eq_sum hp, WithLp.equiv_symm_pi_apply, Function.const_apply, Finset.sum_const,\n      Finset.card_univ, nsmul_eq_mul, NNReal.mul_rpow, â† NNReal.rpow_mul,\n      mul_one_div_cancel ne_zero, NNReal.rpow_one, ENNReal.toReal_div, ENNReal.one_toReal]\n\n"}
{"name":"PiLp.nnnorm_equiv_symm_const'","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nhp : Fact (LE.le 1 p)\ninstâœÂ² : Fintype Î¹\nÎ² : Type u_5\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : Nonempty Î¹\nb : Î²\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Î¹ â†’ Î²)).symm (Function.const Î¹ b))) (HMul.hMul (HPow.hPow (â†‘(Fintype.card Î¹)) (HDiv.hDiv 1 p).toReal) (NNNorm.nnnorm b))","decl":"/-- When `IsEmpty Î¹`, this lemma does not hold without the additional assumption `p â‰  âˆ` because\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `â€–bâ€–â‚Š`. See\n`PiLp.nnnorm_equiv_symm_const` for a version which exchanges the hypothesis `Nonempty Î¹`.\nfor `p â‰  âˆ`. -/\ntheorem nnnorm_equiv_symm_const' {Î²} [SeminormedAddCommGroup Î²] [Nonempty Î¹] (b : Î²) :\n    â€–(WithLp.equiv p (Î¹ â†’ Î²)).symm (Function.const _ b)â€–â‚Š =\n      (Fintype.card Î¹ : â„â‰¥0) ^ (1 / p).toReal * â€–bâ€–â‚Š := by\n  rcases em <| p = âˆ with (rfl | hp)\n  Â· simp only [WithLp.equiv_symm_pi_apply, ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero,\n      one_mul, nnnorm_eq_ciSup, Function.const_apply, ciSup_const]\n  Â· exact nnnorm_equiv_symm_const hp b\n\n"}
{"name":"PiLp.norm_equiv_symm_const","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nhpâœ : Fact (LE.le 1 p)\ninstâœÂ¹ : Fintype Î¹\nÎ² : Type u_5\ninstâœ : SeminormedAddCommGroup Î²\nhp : Ne p Top.top\nb : Î²\nâŠ¢ Eq (Norm.norm ((WithLp.equiv p (Î¹ â†’ Î²)).symm (Function.const Î¹ b))) (HMul.hMul (HPow.hPow (â†‘â†‘(Fintype.card Î¹)) (HDiv.hDiv 1 p).toReal) (Norm.norm b))","decl":"/-- When `p = âˆ`, this lemma does not hold without the additional assumption `Nonempty Î¹` because\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `â€–bâ€–â‚Š`. See\n`PiLp.norm_equiv_symm_const'` for a version which exchanges the hypothesis `p â‰  âˆ` for\n`Nonempty Î¹`. -/\ntheorem norm_equiv_symm_const {Î²} [SeminormedAddCommGroup Î²] (hp : p â‰  âˆ) (b : Î²) :\n    â€–(WithLp.equiv p (Î¹ â†’ Î²)).symm (Function.const _ b)â€– =\n      (Fintype.card Î¹ : â„â‰¥0) ^ (1 / p).toReal * â€–bâ€– :=\n  (congr_arg ((â†‘) : â„â‰¥0 â†’ â„) <| nnnorm_equiv_symm_const hp b).trans <| by simp\n\n"}
{"name":"PiLp.norm_equiv_symm_const'","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nhp : Fact (LE.le 1 p)\ninstâœÂ² : Fintype Î¹\nÎ² : Type u_5\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : Nonempty Î¹\nb : Î²\nâŠ¢ Eq (Norm.norm ((WithLp.equiv p (Î¹ â†’ Î²)).symm (Function.const Î¹ b))) (HMul.hMul (HPow.hPow (â†‘â†‘(Fintype.card Î¹)) (HDiv.hDiv 1 p).toReal) (Norm.norm b))","decl":"/-- When `IsEmpty Î¹`, this lemma does not hold without the additional assumption `p â‰  âˆ` because\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `â€–bâ€–â‚Š`. See\n`PiLp.norm_equiv_symm_const` for a version which exchanges the hypothesis `Nonempty Î¹`.\nfor `p â‰  âˆ`. -/\ntheorem norm_equiv_symm_const' {Î²} [SeminormedAddCommGroup Î²] [Nonempty Î¹] (b : Î²) :\n    â€–(WithLp.equiv p (Î¹ â†’ Î²)).symm (Function.const _ b)â€– =\n      (Fintype.card Î¹ : â„â‰¥0) ^ (1 / p).toReal * â€–bâ€– :=\n  (congr_arg ((â†‘) : â„â‰¥0 â†’ â„) <| nnnorm_equiv_symm_const' b).trans <| by simp\n\n"}
{"name":"PiLp.nnnorm_equiv_symm_one","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nhpâœ : Fact (LE.le 1 p)\ninstâœÂ² : Fintype Î¹\nÎ² : Type u_5\ninstâœÂ¹ : SeminormedAddCommGroup Î²\nhp : Ne p Top.top\ninstâœ : One Î²\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Î¹ â†’ Î²)).symm 1)) (HMul.hMul (HPow.hPow (â†‘(Fintype.card Î¹)) (HDiv.hDiv 1 p).toReal) (NNNorm.nnnorm 1))","decl":"theorem nnnorm_equiv_symm_one {Î²} [SeminormedAddCommGroup Î²] (hp : p â‰  âˆ) [One Î²] :\n    â€–(WithLp.equiv p (Î¹ â†’ Î²)).symm 1â€–â‚Š =\n      (Fintype.card Î¹ : â„â‰¥0) ^ (1 / p).toReal * â€–(1 : Î²)â€–â‚Š :=\n  (nnnorm_equiv_symm_const hp (1 : Î²)).trans rfl\n\n"}
{"name":"PiLp.norm_equiv_symm_one","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\nhpâœ : Fact (LE.le 1 p)\ninstâœÂ² : Fintype Î¹\nÎ² : Type u_5\ninstâœÂ¹ : SeminormedAddCommGroup Î²\nhp : Ne p Top.top\ninstâœ : One Î²\nâŠ¢ Eq (Norm.norm ((WithLp.equiv p (Î¹ â†’ Î²)).symm 1)) (HMul.hMul (HPow.hPow (â†‘â†‘(Fintype.card Î¹)) (HDiv.hDiv 1 p).toReal) (Norm.norm 1))","decl":"theorem norm_equiv_symm_one {Î²} [SeminormedAddCommGroup Î²] (hp : p â‰  âˆ) [One Î²] :\n    â€–(WithLp.equiv p (Î¹ â†’ Î²)).symm 1â€– = (Fintype.card Î¹ : â„â‰¥0) ^ (1 / p).toReal * â€–(1 : Î²)â€– :=\n  (norm_equiv_symm_const hp (1 : Î²)).trans rfl\n\n"}
{"name":"PiLp.continuousLinearEquiv_symm_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ² : Semiring ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Î² i)\nâŠ¢ Eq â‡‘(PiLp.continuousLinearEquiv p ğ•œ Î²).symm â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i)).symm","decl":"/-- `WithLp.equiv` as a continuous linear equivalence. -/\n@[simps! (config := .asFn) apply symm_apply]\nprotected def continuousLinearEquiv : PiLp p Î² â‰ƒL[ğ•œ] âˆ€ i, Î² i where\n  toLinearEquiv := WithLp.linearEquiv _ _ _\n  continuous_toFun := continuous_equiv _ _\n  continuous_invFun := continuous_equiv_symm _ _\n\n"}
{"name":"PiLp.continuousLinearEquiv_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ² : Semiring ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Î² i)\nâŠ¢ Eq â‡‘(PiLp.continuousLinearEquiv p ğ•œ Î²) â‡‘(WithLp.equiv p ((i : Î¹) â†’ Î² i))","decl":"/-- `WithLp.equiv` as a continuous linear equivalence. -/\n@[simps! (config := .asFn) apply symm_apply]\nprotected def continuousLinearEquiv : PiLp p Î² â‰ƒL[ğ•œ] âˆ€ i, Î² i where\n  toLinearEquiv := WithLp.linearEquiv _ _ _\n  continuous_toFun := continuous_equiv _ _\n  continuous_invFun := continuous_equiv_symm _ _\n\n"}
{"name":"PiLp.proj_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\nÎ² : Î¹ â†’ Type u_4\ninstâœÂ² : Semiring ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (Î² i)\ninstâœ : (i : Î¹) â†’ Module ğ•œ (Î² i)\ni : Î¹\naâœ : PiLp p Î²\nâŠ¢ Eq ((PiLp.proj p Î² i) aâœ) (aâœ i)","decl":"variable {ğ•œ} in\n/-- The projection on the `i`-th coordinate of `PiLp p Î²`, as a continuous linear map. -/\n@[simps!]\ndef proj (i : Î¹) : PiLp p Î² â†’L[ğ•œ] Î² i where\n  __ := projâ‚— p Î² i\n  cont := continuous_apply i\n\n"}
{"name":"PiLp.basisFun_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : Finite Î¹\ninstâœÂ¹ : Ring ğ•œ\ninstâœ : DecidableEq Î¹\ni : Î¹\nâŠ¢ Eq ((PiLp.basisFun p ğ•œ Î¹) i) ((WithLp.equiv p (Î¹ â†’ ğ•œ)).symm (Pi.single i 1))","decl":"@[simp]\ntheorem basisFun_apply [DecidableEq Î¹] (i) :\n    basisFun p ğ•œ Î¹ i = (WithLp.equiv p _).symm (Pi.single i 1) := by\n  simp_rw [basisFun, Basis.coe_ofEquivFun, WithLp.linearEquiv_symm_apply]\n\n"}
{"name":"PiLp.basisFun_repr","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹ : Finite Î¹\ninstâœ : Ring ğ•œ\nx : PiLp p fun x => ğ•œ\ni : Î¹\nâŠ¢ Eq (((PiLp.basisFun p ğ•œ Î¹).repr x) i) (x i)","decl":"@[simp]\ntheorem basisFun_repr (x : PiLp p fun _ : Î¹ => ğ•œ) (i : Î¹) : (basisFun p ğ•œ Î¹).repr x i = x i :=\n  rfl\n\n"}
{"name":"PiLp.basisFun_equivFun","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹ : Finite Î¹\ninstâœ : Ring ğ•œ\nâŠ¢ Eq (PiLp.basisFun p ğ•œ Î¹).equivFun (WithLp.linearEquiv p ğ•œ (Î¹ â†’ ğ•œ))","decl":"@[simp]\ntheorem basisFun_equivFun : (basisFun p ğ•œ Î¹).equivFun = WithLp.linearEquiv p ğ•œ (Î¹ â†’ ğ•œ) :=\n  Basis.equivFun_ofEquivFun _\n\n"}
{"name":"PiLp.basisFun_eq_pi_basisFun","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹ : Finite Î¹\ninstâœ : Ring ğ•œ\nâŠ¢ Eq (PiLp.basisFun p ğ•œ Î¹) ((Pi.basisFun ğ•œ Î¹).map (WithLp.linearEquiv p ğ•œ (Î¹ â†’ ğ•œ)).symm)","decl":"theorem basisFun_eq_pi_basisFun :\n    basisFun p ğ•œ Î¹ = (Pi.basisFun ğ•œ Î¹).map (WithLp.linearEquiv p ğ•œ (Î¹ â†’ ğ•œ)).symm :=\n  rfl\n\n"}
{"name":"PiLp.basisFun_map","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹ : Finite Î¹\ninstâœ : Ring ğ•œ\nâŠ¢ Eq ((PiLp.basisFun p ğ•œ Î¹).map (WithLp.linearEquiv p ğ•œ (Î¹ â†’ ğ•œ))) (Pi.basisFun ğ•œ Î¹)","decl":"@[simp]\ntheorem basisFun_map :\n    (basisFun p ğ•œ Î¹).map (WithLp.linearEquiv p ğ•œ (Î¹ â†’ ğ•œ)) = Pi.basisFun ğ•œ Î¹ :=\n  rfl\n\n"}
{"name":"PiLp.basis_toMatrix_basisFun_mul","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nÎ¹ : Type u_2\ninstâœÂ¹ : Fintype Î¹\nğ•œ : Type u_5\ninstâœ : SeminormedCommRing ğ•œ\nb : Basis Î¹ ğ•œ (PiLp p fun x => ğ•œ)\nA : Matrix Î¹ Î¹ ğ•œ\nâŠ¢ Eq (HMul.hMul (b.toMatrix â‡‘(PiLp.basisFun p ğ•œ Î¹)) A) (Matrix.of fun i j => (b.repr ((WithLp.equiv p ((i : Î¹) â†’ (fun x => ğ•œ) i)).symm (A.transpose j))) i)","decl":"nonrec theorem basis_toMatrix_basisFun_mul [Fintype Î¹]\n    {ğ•œ} [SeminormedCommRing ğ•œ] (b : Basis Î¹ ğ•œ (PiLp p fun _ : Î¹ => ğ•œ))\n    (A : Matrix Î¹ Î¹ ğ•œ) :\n    b.toMatrix (PiLp.basisFun _ _ _) * A =\n      Matrix.of fun i j => b.repr ((WithLp.equiv _ _).symm (Aáµ€ j)) i := by\n  have := basis_toMatrix_basisFun_mul (b.map (WithLp.linearEquiv _ ğ•œ _)) A\n  simp_rw [â† PiLp.basisFun_map p, Basis.map_repr, LinearEquiv.trans_apply,\n    WithLp.linearEquiv_symm_apply, Basis.toMatrix_map, Function.comp_def, Basis.map_apply,\n    LinearEquiv.symm_apply_apply] at this\n  exact this\n\n"}
