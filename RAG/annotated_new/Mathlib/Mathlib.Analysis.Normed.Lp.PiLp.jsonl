{"name":"PiLp.ext_iff","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_1\nŒ± : Œπ ‚Üí Type u_2\nx y : PiLp p Œ±\n‚ä¢ Iff (Eq x y) (‚àÄ (i : Œπ), Eq (x i) (y i))","decl":"@[ext]\nprotected theorem PiLp.ext {p : ‚Ñù‚â•0‚àû} {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} {x y : PiLp p Œ±}\n    (h : ‚àÄ i, x i = y i) : x = y := funext h\n\n"}
{"name":"PiLp.ext","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_1\nŒ± : Œπ ‚Üí Type u_2\nx y : PiLp p Œ±\nh : ‚àÄ (i : Œπ), Eq (x i) (y i)\n‚ä¢ Eq x y","decl":"@[ext]\nprotected theorem PiLp.ext {p : ‚Ñù‚â•0‚àû} {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} {x y : PiLp p Œ±}\n    (h : ‚àÄ i, x i = y i) : x = y := funext h\n\n"}
{"name":"PiLp.zero_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ni : Œπ\n‚ä¢ Eq (0 i) 0","decl":"@[simp, nolint simpNF]\ntheorem zero_apply : (0 : PiLp p Œ≤) i = 0 :=\n  rfl\n\n"}
{"name":"PiLp.add_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx y : PiLp p Œ≤\ni : Œπ\n‚ä¢ Eq (HAdd.hAdd x y i) (HAdd.hAdd (x i) (y i))","decl":"@[simp]\ntheorem add_apply : (x + y) i = x i + y i :=\n  rfl\n\n"}
{"name":"PiLp.sub_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx y : PiLp p Œ≤\ni : Œπ\n‚ä¢ Eq (HSub.hSub x y i) (HSub.hSub (x i) (y i))","decl":"@[simp]\ntheorem sub_apply : (x - y) i = x i - y i :=\n  rfl\n\n"}
{"name":"PiLp.smul_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : Semiring ùïú\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : (i : Œπ) ‚Üí Module ùïú (Œ≤ i)\nc : ùïú\nx : PiLp p Œ≤\ni : Œπ\n‚ä¢ Eq (HSMul.hSMul c x i) (HSMul.hSMul c (x i))","decl":"@[simp]\ntheorem smul_apply : (c ‚Ä¢ x) i = c ‚Ä¢ x i :=\n  rfl\n\n"}
{"name":"PiLp.neg_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx : PiLp p Œ≤\ni : Œπ\n‚ä¢ Eq (Neg.neg x i) (Neg.neg (x i))","decl":"@[simp]\ntheorem neg_apply : (-x) i = -x i :=\n  rfl\n\n"}
{"name":"PiLp.proj‚Çó_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : Semiring ùïú\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : (i : Œπ) ‚Üí Module ùïú (Œ≤ i)\ni : Œπ\na‚úù : PiLp p Œ≤\n‚ä¢ Eq ((PiLp.proj‚Çó p Œ≤ i) a‚úù) ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)) a‚úù i)","decl":"variable (p) in\n/-- The projection on the `i`-th coordinate of `WithLp p (‚àÄ i, Œ± i)`, as a linear map. -/\n@[simps!]\ndef proj‚Çó (i : Œπ) : PiLp p Œ≤ ‚Üí‚Çó[ùïú] Œ≤ i :=\n  (LinearMap.proj i : (‚àÄ i, Œ≤ i) ‚Üí‚Çó[ùïú] Œ≤ i) ‚àò‚Çó (WithLp.linearEquiv p ùïú (‚àÄ i, Œ≤ i)).toLinearMap\n\n"}
{"name":"WithLp.equiv_pi_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\nx : PiLp p Œ±\ni : Œπ\n‚ä¢ Eq ((WithLp.equiv p ((i : Œπ) ‚Üí Œ± i)) x i) (x i)","decl":"@[simp]\ntheorem _root_.WithLp.equiv_pi_apply (x : PiLp p Œ±) (i : Œπ) : WithLp.equiv p _ x i = x i :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_pi_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\nx : (i : Œπ) ‚Üí Œ± i\ni : Œπ\n‚ä¢ Eq ((WithLp.equiv p ((i : Œπ) ‚Üí Œ± i)).symm x i) (x i)","decl":"@[simp]\ntheorem  _root_.WithLp.equiv_symm_pi_apply (x : ‚àÄ i, Œ± i) (i : Œπ) :\n    (WithLp.equiv p _).symm x i = x i :=\n  rfl\n\n"}
{"name":"PiLp.edist_eq_card","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí EDist (Œ≤ i)\nf g : PiLp 0 Œ≤\n‚ä¢ Eq (EDist.edist f g) ‚Üë‚ãØ.toFinset.card","decl":"theorem edist_eq_card (f g : PiLp 0 Œ≤) :\n    edist f g = {i | edist (f i) (g i) ‚â† 0}.toFinite.toFinset.card :=\n  if_pos rfl\n\n"}
{"name":"PiLp.edist_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí EDist (Œ≤ i)\np : ENNReal\nhp : LT.lt 0 p.toReal\nf g : PiLp p Œ≤\n‚ä¢ Eq (EDist.edist f g) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (EDist.edist (f i) (g i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem edist_eq_sum {p : ‚Ñù‚â•0‚àû} (hp : 0 < p.toReal) (f g : PiLp p Œ≤) :\n    edist f g = (‚àë i, edist (f i) (g i) ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"PiLp.edist_eq_iSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí EDist (Œ≤ i)\nf g : PiLp Top.top Œ≤\n‚ä¢ Eq (EDist.edist f g) (iSup fun i => EDist.edist (f i) (g i))","decl":"theorem edist_eq_iSup (f g : PiLp ‚àû Œ≤) : edist f g = ‚®Ü i, edist (f i) (g i) := rfl\n\n"}
{"name":"PiLp.edist_self","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí PseudoEMetricSpace (Œ≤ i)\nf : PiLp p Œ≤\n‚ä¢ Eq (EDist.edist f f) 0","decl":"/-- This holds independent of `p` and does not require `[Fact (1 ‚â§ p)]`. We keep it separate\nfrom `pi_Lp.pseudo_emetric_space` so it can be used also for `p < 1`. -/\nprotected theorem edist_self (f : PiLp p Œ≤) : edist f f = 0 := by\n  rcases p.trichotomy with (rfl | rfl | h)\n  ¬∑ simp [edist_eq_card]\n  ¬∑ simp [edist_eq_iSup]\n  ¬∑ simp [edist_eq_sum h, ENNReal.zero_rpow_of_pos h, ENNReal.zero_rpow_of_pos (inv_pos.2 <| h)]\n\n"}
{"name":"PiLp.edist_comm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí PseudoEMetricSpace (Œ≤ i)\nf g : PiLp p Œ≤\n‚ä¢ Eq (EDist.edist f g) (EDist.edist g f)","decl":"/-- This holds independent of `p` and does not require `[Fact (1 ‚â§ p)]`. We keep it separate\nfrom `pi_Lp.pseudo_emetric_space` so it can be used also for `p < 1`. -/\nprotected theorem edist_comm (f g : PiLp p Œ≤) : edist f g = edist g f := by\n  rcases p.trichotomy with (rfl | rfl | h)\n  ¬∑ simp only [edist_eq_card, edist_comm]\n  ¬∑ simp only [edist_eq_iSup, edist_comm]\n  ¬∑ simp only [edist_eq_sum h, edist_comm]\n\n"}
{"name":"PiLp.dist_eq_card","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí Dist (Œ± i)\nf g : PiLp 0 Œ±\n‚ä¢ Eq (Dist.dist f g) ‚Üë‚ãØ.toFinset.card","decl":"theorem dist_eq_card (f g : PiLp 0 Œ±) :\n    dist f g = {i | dist (f i) (g i) ‚â† 0}.toFinite.toFinset.card :=\n  if_pos rfl\n\n"}
{"name":"PiLp.dist_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí Dist (Œ± i)\np : ENNReal\nhp : LT.lt 0 p.toReal\nf g : PiLp p Œ±\n‚ä¢ Eq (Dist.dist f g) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (Dist.dist (f i) (g i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem dist_eq_sum {p : ‚Ñù‚â•0‚àû} (hp : 0 < p.toReal) (f g : PiLp p Œ±) :\n    dist f g = (‚àë i, dist (f i) (g i) ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"PiLp.dist_eq_iSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí Dist (Œ± i)\nf g : PiLp Top.top Œ±\n‚ä¢ Eq (Dist.dist f g) (iSup fun i => Dist.dist (f i) (g i))","decl":"theorem dist_eq_iSup (f g : PiLp ‚àû Œ±) : dist f g = ‚®Ü i, dist (f i) (g i) := rfl\n\n"}
{"name":"PiLp.norm_eq_card","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí Norm (Œ≤ i)\nf : PiLp 0 Œ≤\n‚ä¢ Eq (Norm.norm f) ‚Üë‚ãØ.toFinset.card","decl":"theorem norm_eq_card (f : PiLp 0 Œ≤) : ‚Äñf‚Äñ = {i | ‚Äñf i‚Äñ ‚â† 0}.toFinite.toFinset.card :=\n  if_pos rfl\n\n"}
{"name":"PiLp.norm_eq_ciSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí Norm (Œ≤ i)\nf : PiLp Top.top Œ≤\n‚ä¢ Eq (Norm.norm f) (iSup fun i => Norm.norm (f i))","decl":"theorem norm_eq_ciSup (f : PiLp ‚àû Œ≤) : ‚Äñf‚Äñ = ‚®Ü i, ‚Äñf i‚Äñ := rfl\n\n"}
{"name":"PiLp.norm_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí Norm (Œ≤ i)\nhp : LT.lt 0 p.toReal\nf : PiLp p Œ≤\n‚ä¢ Eq (Norm.norm f) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (Norm.norm (f i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem norm_eq_sum (hp : 0 < p.toReal) (f : PiLp p Œ≤) :\n    ‚Äñf‚Äñ = (‚àë i, ‚Äñf i‚Äñ ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"PiLp.iSup_edist_ne_top_aux","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_5\ninst‚úù¬π : Finite Œπ\nŒ± : Œπ ‚Üí Type u_6\ninst‚úù : (i : Œπ) ‚Üí PseudoMetricSpace (Œ± i)\nf g : PiLp Top.top Œ±\n‚ä¢ Ne (iSup fun i => EDist.edist (f i) (g i)) Top.top","decl":"/-- An auxiliary lemma used twice in the proof of `PiLp.pseudoMetricAux` below. Not intended for\nuse outside this file. -/\ntheorem iSup_edist_ne_top_aux {Œπ : Type*} [Finite Œπ] {Œ± : Œπ ‚Üí Type*}\n    [‚àÄ i, PseudoMetricSpace (Œ± i)] (f g : PiLp ‚àû Œ±) : (‚®Ü i, edist (f i) (g i)) ‚â† ‚ä§ := by\n  cases nonempty_fintype Œπ\n  obtain ‚ü®M, hM‚ü© := Finite.exists_le fun i => (‚ü®dist (f i) (g i), dist_nonneg‚ü© : ‚Ñù‚â•0)\n  refine ne_of_lt ((iSup_le fun i => ?_).trans_lt (@ENNReal.coe_lt_top M))\n  simp only [edist, PseudoMetricSpace.edist_dist, ENNReal.ofReal_eq_coe_nnreal dist_nonneg]\n  exact mod_cast hM i\n\n"}
{"name":"PiLp.lipschitzWith_equiv_aux","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : (i : Œπ) ‚Üí PseudoEMetricSpace (Œ≤ i)\ninst‚úù : Fintype Œπ\n‚ä¢ LipschitzWith 1 ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i))","decl":"theorem lipschitzWith_equiv_aux : LipschitzWith 1 (WithLp.equiv p (‚àÄ i, Œ≤ i)) := by\n  intro x y\n  simp_rw [ENNReal.coe_one, one_mul, edist_pi_def, Finset.sup_le_iff, Finset.mem_univ,\n    forall_true_left, WithLp.equiv_pi_apply]\n  rcases p.dichotomy with (rfl | h)\n  ¬∑ simpa only [edist_eq_iSup] using le_iSup fun i => edist (x i) (y i)\n  ¬∑ have cancel : p.toReal * (1 / p.toReal) = 1 := mul_div_cancel‚ÇÄ 1 (zero_lt_one.trans_le h).ne'\n    rw [edist_eq_sum (zero_lt_one.trans_le h)]\n    intro i\n    calc\n      edist (x i) (y i) = (edist (x i) (y i) ^ p.toReal) ^ (1 / p.toReal) := by\n        simp [‚Üê ENNReal.rpow_mul, cancel, -one_div]\n      _ ‚â§ (‚àë i, edist (x i) (y i) ^ p.toReal) ^ (1 / p.toReal) := by\n        gcongr\n        exact Finset.single_le_sum (fun i _ => (bot_le : (0 : ‚Ñù‚â•0‚àû) ‚â§ _)) (Finset.mem_univ i)\n\n"}
{"name":"PiLp.antilipschitzWith_equiv_aux","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : (i : Œπ) ‚Üí PseudoEMetricSpace (Œ≤ i)\ninst‚úù : Fintype Œπ\n‚ä¢ AntilipschitzWith (HPow.hPow (‚Üë(Fintype.card Œπ)) (HDiv.hDiv 1 p).toReal) ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i))","decl":"theorem antilipschitzWith_equiv_aux :\n    AntilipschitzWith ((Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal) (WithLp.equiv p (‚àÄ i, Œ≤ i)) := by\n  intro x y\n  rcases p.dichotomy with (rfl | h)\n  ¬∑ simp only [edist_eq_iSup, ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero,\n      ENNReal.coe_one, one_mul, iSup_le_iff]\n    -- Porting note: `Finset.le_sup` needed some help\n    exact fun i => Finset.le_sup (f := fun i => edist (x i) (y i)) (Finset.mem_univ i)\n  ¬∑ have pos : 0 < p.toReal := zero_lt_one.trans_le h\n    have nonneg : 0 ‚â§ 1 / p.toReal := one_div_nonneg.2 (le_of_lt pos)\n    have cancel : p.toReal * (1 / p.toReal) = 1 := mul_div_cancel‚ÇÄ 1 (ne_of_gt pos)\n    rw [edist_eq_sum pos, ENNReal.toReal_div 1 p]\n    simp only [edist, ‚Üê one_div, ENNReal.one_toReal]\n    calc\n      (‚àë i, edist (x i) (y i) ^ p.toReal) ^ (1 / p.toReal) ‚â§\n          (‚àë _i, edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) ^ p.toReal) ^ (1 / p.toReal) := by\n        gcongr with i\n        exact Finset.le_sup (f := fun i => edist (x i) (y i)) (Finset.mem_univ i)\n      _ =\n          ((Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p.toReal) : ‚Ñù‚â•0) *\n            edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) := by\n        simp only [nsmul_eq_mul, Finset.card_univ, ENNReal.rpow_one, Finset.sum_const,\n          ENNReal.mul_rpow_of_nonneg _ _ nonneg, ‚Üê ENNReal.rpow_mul, cancel]\n        have : (Fintype.card Œπ : ‚Ñù‚â•0‚àû) = (Fintype.card Œπ : ‚Ñù‚â•0) :=\n          (ENNReal.coe_natCast (Fintype.card Œπ)).symm\n        rw [this, ENNReal.coe_rpow_of_nonneg _ nonneg]\n\n"}
{"name":"PiLp.aux_uniformity_eq","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : (i : Œπ) ‚Üí PseudoEMetricSpace (Œ≤ i)\ninst‚úù : Fintype Œπ\n‚ä¢ Eq (uniformity (PiLp p Œ≤)) (uniformity ((i : Œπ) ‚Üí Œ≤ i))","decl":"theorem aux_uniformity_eq : ùì§ (PiLp p Œ≤) = ùì§[Pi.uniformSpace _] := by\n  have A : IsUniformInducing (WithLp.equiv p (‚àÄ i, Œ≤ i)) :=\n    (antilipschitzWith_equiv_aux p Œ≤).isUniformInducing\n      (lipschitzWith_equiv_aux p Œ≤).uniformContinuous\n  have : (fun x : PiLp p Œ≤ √ó PiLp p Œ≤ => (WithLp.equiv p _ x.fst, WithLp.equiv p _ x.snd)) = id :=\n    by ext i <;> rfl\n  rw [‚Üê A.comap_uniformity, this, comap_id]\n\n"}
{"name":"PiLp.aux_cobounded_eq","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\ninst‚úù¬≤ : Fact (LE.le 1 p)\ninst‚úù¬π : (i : Œπ) ‚Üí PseudoMetricSpace (Œ± i)\ninst‚úù : Fintype Œπ\n‚ä¢ Eq (Bornology.cobounded (PiLp p Œ±)) (Bornology.cobounded ((i : Œπ) ‚Üí Œ± i))","decl":"theorem aux_cobounded_eq : cobounded (PiLp p Œ±) = @cobounded _ Pi.instBornology :=\n  calc\n    cobounded (PiLp p Œ±) = comap (WithLp.equiv p (‚àÄ i, Œ± i)) (cobounded _) :=\n      le_antisymm (antilipschitzWith_equiv_aux p Œ±).tendsto_cobounded.le_comap\n        (lipschitzWith_equiv_aux p Œ±).comap_cobounded_le\n    _ = _ := comap_id\n\n"}
{"name":"PiLp.uniformContinuous_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí UniformSpace (Œ≤ i)\n‚ä¢ UniformContinuous ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i))","decl":"theorem uniformContinuous_equiv [‚àÄ i, UniformSpace (Œ≤ i)] :\n    UniformContinuous (WithLp.equiv p (‚àÄ i, Œ≤ i)) :=\n  uniformContinuous_id\n\n"}
{"name":"PiLp.uniformContinuous_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí UniformSpace (Œ≤ i)\n‚ä¢ UniformContinuous ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm","decl":"theorem uniformContinuous_equiv_symm [‚àÄ i, UniformSpace (Œ≤ i)] :\n    UniformContinuous (WithLp.equiv p (‚àÄ i, Œ≤ i)).symm :=\n  uniformContinuous_id\n\n"}
{"name":"PiLp.continuous_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí UniformSpace (Œ≤ i)\n‚ä¢ Continuous ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i))","decl":"@[continuity]\ntheorem continuous_equiv [‚àÄ i, UniformSpace (Œ≤ i)] : Continuous (WithLp.equiv p (‚àÄ i, Œ≤ i)) :=\n  continuous_id\n\n"}
{"name":"PiLp.continuous_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí UniformSpace (Œ≤ i)\n‚ä¢ Continuous ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm","decl":"@[continuity]\ntheorem continuous_equiv_symm [‚àÄ i, UniformSpace (Œ≤ i)] :\n    Continuous (WithLp.equiv p (‚àÄ i, Œ≤ i)).symm :=\n  continuous_id\n\n"}
{"name":"PiLp.nndist_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\ninst‚úù¬≤ : Fintype Œπ\np : ENNReal\ninst‚úù¬π : Fact (LE.le 1 p)\nŒ≤ : Œπ ‚Üí Type u_5\ninst‚úù : (i : Œπ) ‚Üí PseudoMetricSpace (Œ≤ i)\nhp : Ne p Top.top\nx y : PiLp p Œ≤\n‚ä¢ Eq (NNDist.nndist x y) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (NNDist.nndist (x i) (y i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem nndist_eq_sum {p : ‚Ñù‚â•0‚àû} [Fact (1 ‚â§ p)] {Œ≤ : Œπ ‚Üí Type*} [‚àÄ i, PseudoMetricSpace (Œ≤ i)]\n    (hp : p ‚â† ‚àû) (x y : PiLp p Œ≤) :\n    nndist x y = (‚àë i : Œπ, nndist (x i) (y i) ^ p.toReal) ^ (1 / p.toReal) :=\n  -- Porting note: was `Subtype.ext`\n  NNReal.eq <| by\n    push_cast\n    exact dist_eq_sum (p.toReal_pos_iff_ne_top.mpr hp) _ _\n\n"}
{"name":"PiLp.nndist_eq_iSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\ninst‚úù¬π : Fintype Œπ\nŒ≤ : Œπ ‚Üí Type u_5\ninst‚úù : (i : Œπ) ‚Üí PseudoMetricSpace (Œ≤ i)\nx y : PiLp Top.top Œ≤\n‚ä¢ Eq (NNDist.nndist x y) (iSup fun i => NNDist.nndist (x i) (y i))","decl":"theorem nndist_eq_iSup {Œ≤ : Œπ ‚Üí Type*} [‚àÄ i, PseudoMetricSpace (Œ≤ i)] (x y : PiLp ‚àû Œ≤) :\n    nndist x y = ‚®Ü i, nndist (x i) (y i) :=\n  -- Porting note: was `Subtype.ext`\n  NNReal.eq <| by\n    push_cast\n    exact dist_eq_iSup _ _\n\n"}
{"name":"PiLp.lipschitzWith_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí PseudoEMetricSpace (Œ≤ i)\n‚ä¢ LipschitzWith 1 ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i))","decl":"theorem lipschitzWith_equiv [‚àÄ i, PseudoEMetricSpace (Œ≤ i)] :\n    LipschitzWith 1 (WithLp.equiv p (‚àÄ i, Œ≤ i)) :=\n  lipschitzWith_equiv_aux p Œ≤\n\n"}
{"name":"PiLp.antilipschitzWith_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí PseudoEMetricSpace (Œ≤ i)\n‚ä¢ AntilipschitzWith (HPow.hPow (‚Üë(Fintype.card Œπ)) (HDiv.hDiv 1 p).toReal) ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i))","decl":"theorem antilipschitzWith_equiv [‚àÄ i, PseudoEMetricSpace (Œ≤ i)] :\n    AntilipschitzWith ((Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal) (WithLp.equiv p (‚àÄ i, Œ≤ i)) :=\n  antilipschitzWith_equiv_aux p Œ≤\n\n"}
{"name":"PiLp.infty_equiv_isometry","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí PseudoEMetricSpace (Œ≤ i)\n‚ä¢ Isometry ‚áë(WithLp.equiv Top.top ((i : Œπ) ‚Üí Œ≤ i))","decl":"theorem infty_equiv_isometry [‚àÄ i, PseudoEMetricSpace (Œ≤ i)] :\n    Isometry (WithLp.equiv ‚àû (‚àÄ i, Œ≤ i)) :=\n  fun x y =>\n  le_antisymm (by simpa only [ENNReal.coe_one, one_mul] using lipschitzWith_equiv ‚àû Œ≤ x y)\n    (by\n      simpa only [ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero, ENNReal.coe_one,\n        one_mul] using antilipschitzWith_equiv ‚àû Œ≤ x y)\n\n"}
{"name":"PiLp.nnnorm_eq_sum","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\ninst‚úù¬≤ : Fintype Œπ\np : ENNReal\ninst‚úù¬π : Fact (LE.le 1 p)\nŒ≤ : Œπ ‚Üí Type u_5\nhp : Ne p Top.top\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nf : PiLp p Œ≤\n‚ä¢ Eq (NNNorm.nnnorm f) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (NNNorm.nnnorm (f i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem nnnorm_eq_sum {p : ‚Ñù‚â•0‚àû} [Fact (1 ‚â§ p)] {Œ≤ : Œπ ‚Üí Type*} (hp : p ‚â† ‚àû)\n    [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (f : PiLp p Œ≤) :\n    ‚Äñf‚Äñ‚Çä = (‚àë i, ‚Äñf i‚Äñ‚Çä ^ p.toReal) ^ (1 / p.toReal) := by\n  ext\n  simp [NNReal.coe_sum, norm_eq_sum (p.toReal_pos_iff_ne_top.mpr hp)]\n\n"}
{"name":"PiLp.nnnorm_eq_ciSup","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nf : PiLp Top.top Œ≤\n‚ä¢ Eq (NNNorm.nnnorm f) (iSup fun i => NNNorm.nnnorm (f i))","decl":"theorem nnnorm_eq_ciSup (f : PiLp ‚àû Œ≤) : ‚Äñf‚Äñ‚Çä = ‚®Ü i, ‚Äñf i‚Äñ‚Çä := by\n  ext\n  simp [NNReal.coe_iSup, norm_eq_ciSup]\n\n"}
{"name":"PiLp.nnnorm_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nf : PiLp Top.top Œ≤\n‚ä¢ Eq (NNNorm.nnnorm ((WithLp.equiv Top.top ((i : Œπ) ‚Üí Œ≤ i)) f)) (NNNorm.nnnorm f)","decl":"@[simp] theorem nnnorm_equiv (f : PiLp ‚àû Œ≤) : ‚ÄñWithLp.equiv ‚ä§ _ f‚Äñ‚Çä = ‚Äñf‚Äñ‚Çä := by\n  rw [nnnorm_eq_ciSup, Pi.nnnorm_def, Finset.sup_univ_eq_ciSup]\n  dsimp only [WithLp.equiv_pi_apply]\n\n"}
{"name":"PiLp.nnnorm_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nf : (i : Œπ) ‚Üí Œ≤ i\n‚ä¢ Eq (NNNorm.nnnorm ((WithLp.equiv Top.top ((i : Œπ) ‚Üí Œ≤ i)).symm f)) (NNNorm.nnnorm f)","decl":"@[simp] theorem nnnorm_equiv_symm (f : ‚àÄ i, Œ≤ i) : ‚Äñ(WithLp.equiv ‚ä§ _).symm f‚Äñ‚Çä = ‚Äñf‚Äñ‚Çä :=\n  (nnnorm_equiv _).symm\n\n"}
{"name":"PiLp.norm_equiv","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nf : PiLp Top.top Œ≤\n‚ä¢ Eq (Norm.norm ((WithLp.equiv Top.top ((i : Œπ) ‚Üí Œ≤ i)) f)) (Norm.norm f)","decl":"@[simp] theorem norm_equiv (f : PiLp ‚àû Œ≤) : ‚ÄñWithLp.equiv ‚ä§ _ f‚Äñ = ‚Äñf‚Äñ :=\n  congr_arg NNReal.toReal <| nnnorm_equiv f\n\n"}
{"name":"PiLp.norm_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nf : (i : Œπ) ‚Üí Œ≤ i\n‚ä¢ Eq (Norm.norm ((WithLp.equiv Top.top ((i : Œπ) ‚Üí Œ≤ i)).symm f)) (Norm.norm f)","decl":"@[simp] theorem norm_equiv_symm (f : ‚àÄ i, Œ≤ i) : ‚Äñ(WithLp.equiv ‚ä§ _).symm f‚Äñ = ‚Äñf‚Äñ :=\n  (norm_equiv _).symm\n\n"}
{"name":"PiLp.norm_eq_of_nat","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\ninst‚úù¬≤ : Fintype Œπ\np : ENNReal\ninst‚úù¬π : Fact (LE.le 1 p)\nŒ≤ : Œπ ‚Üí Type u_5\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nn : Nat\nh : Eq p ‚Üën\nf : PiLp p Œ≤\n‚ä¢ Eq (Norm.norm f) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (Norm.norm (f i)) n) (HDiv.hDiv 1 ‚Üën))","decl":"theorem norm_eq_of_nat {p : ‚Ñù‚â•0‚àû} [Fact (1 ‚â§ p)] {Œ≤ : Œπ ‚Üí Type*}\n    [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (n : ‚Ñï) (h : p = n) (f : PiLp p Œ≤) :\n    ‚Äñf‚Äñ = (‚àë i, ‚Äñf i‚Äñ ^ n) ^ (1 / (n : ‚Ñù)) := by\n  have := p.toReal_pos_iff_ne_top.mpr (ne_of_eq_of_ne h <| ENNReal.natCast_ne_top n)\n  simp only [one_div, h, Real.rpow_natCast, ENNReal.toReal_nat, eq_self_iff_true, Finset.sum_congr,\n    norm_eq_sum this]\n\n"}
{"name":"PiLp.norm_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx : PiLp 1 Œ≤\n‚ä¢ Eq (Norm.norm x) (Finset.univ.sum fun i => Norm.norm (x i))","decl":"theorem norm_eq_of_L1 (x : PiLp 1 Œ≤) : ‚Äñx‚Äñ = ‚àë i : Œπ, ‚Äñx i‚Äñ := by\n  simp [norm_eq_sum]\n\n"}
{"name":"PiLp.nnnorm_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx : PiLp 1 Œ≤\n‚ä¢ Eq (NNNorm.nnnorm x) (Finset.univ.sum fun i => NNNorm.nnnorm (x i))","decl":"theorem nnnorm_eq_of_L1 (x : PiLp 1 Œ≤) : ‚Äñx‚Äñ‚Çä = ‚àë i : Œπ, ‚Äñx i‚Äñ‚Çä :=\n  NNReal.eq <| by push_cast; exact norm_eq_of_L1 x\n\n"}
{"name":"PiLp.dist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx y : PiLp 1 Œ≤\n‚ä¢ Eq (Dist.dist x y) (Finset.univ.sum fun i => Dist.dist (x i) (y i))","decl":"theorem dist_eq_of_L1 (x y : PiLp 1 Œ≤) : dist x y = ‚àë i, dist (x i) (y i) := by\n  simp_rw [dist_eq_norm, norm_eq_of_L1, sub_apply]\n\n"}
{"name":"PiLp.nndist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx y : PiLp 1 Œ≤\n‚ä¢ Eq (NNDist.nndist x y) (Finset.univ.sum fun i => NNDist.nndist (x i) (y i))","decl":"theorem nndist_eq_of_L1 (x y : PiLp 1 Œ≤) : nndist x y = ‚àë i, nndist (x i) (y i) :=\n  NNReal.eq <| by push_cast; exact dist_eq_of_L1 _ _\n\n"}
{"name":"PiLp.edist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx y : PiLp 1 Œ≤\n‚ä¢ Eq (EDist.edist x y) (Finset.univ.sum fun i => EDist.edist (x i) (y i))","decl":"theorem edist_eq_of_L1 (x y : PiLp 1 Œ≤) : edist x y = ‚àë i, edist (x i) (y i) := by\n  simp [PiLp.edist_eq_sum]\n\n"}
{"name":"PiLp.norm_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx : PiLp 2 Œ≤\n‚ä¢ Eq (Norm.norm x) (Finset.univ.sum fun i => HPow.hPow (Norm.norm (x i)) 2).sqrt","decl":"theorem norm_eq_of_L2 (x : PiLp 2 Œ≤) :\n    ‚Äñx‚Äñ = ‚àö(‚àë i : Œπ, ‚Äñx i‚Äñ ^ 2) := by\n  rw [norm_eq_of_nat 2 (by norm_cast) _]\n  rw [Real.sqrt_eq_rpow]\n  norm_cast\n\n"}
{"name":"PiLp.nnnorm_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx : PiLp 2 Œ≤\n‚ä¢ Eq (NNNorm.nnnorm x) (NNReal.sqrt (Finset.univ.sum fun i => HPow.hPow (NNNorm.nnnorm (x i)) 2))","decl":"theorem nnnorm_eq_of_L2 (x : PiLp 2 Œ≤) :\n    ‚Äñx‚Äñ‚Çä = NNReal.sqrt (‚àë i : Œπ, ‚Äñx i‚Äñ‚Çä ^ 2) :=\n  NNReal.eq <| by\n    push_cast\n    exact norm_eq_of_L2 x\n\n"}
{"name":"PiLp.norm_sq_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\ninst‚úù¬π : Fintype Œπ\nŒ≤ : Œπ ‚Üí Type u_5\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx : PiLp 2 Œ≤\n‚ä¢ Eq (HPow.hPow (Norm.norm x) 2) (Finset.univ.sum fun i => HPow.hPow (Norm.norm (x i)) 2)","decl":"theorem norm_sq_eq_of_L2 (Œ≤ : Œπ ‚Üí Type*) [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)] (x : PiLp 2 Œ≤) :\n    ‚Äñx‚Äñ ^ 2 = ‚àë i : Œπ, ‚Äñx i‚Äñ ^ 2 := by\n  suffices ‚Äñx‚Äñ‚Çä ^ 2 = ‚àë i : Œπ, ‚Äñx i‚Äñ‚Çä ^ 2 by\n    simpa only [NNReal.coe_sum] using congr_arg ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) this\n  rw [nnnorm_eq_of_L2, NNReal.sq_sqrt]\n\n"}
{"name":"PiLp.dist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx y : PiLp 2 Œ≤\n‚ä¢ Eq (Dist.dist x y) (Finset.univ.sum fun i => HPow.hPow (Dist.dist (x i) (y i)) 2).sqrt","decl":"theorem dist_eq_of_L2 (x y : PiLp 2 Œ≤) :\n    dist x y = ‚àö(‚àë i, dist (x i) (y i) ^ 2) := by\n  simp_rw [dist_eq_norm, norm_eq_of_L2, sub_apply]\n\n"}
{"name":"PiLp.nndist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx y : PiLp 2 Œ≤\n‚ä¢ Eq (NNDist.nndist x y) (NNReal.sqrt (Finset.univ.sum fun i => HPow.hPow (NNDist.nndist (x i) (y i)) 2))","decl":"theorem nndist_eq_of_L2 (x y : PiLp 2 Œ≤) :\n    nndist x y = NNReal.sqrt (‚àë i, nndist (x i) (y i) ^ 2) :=\n  NNReal.eq <| by\n    push_cast\n    exact dist_eq_of_L2 _ _\n\n"}
{"name":"PiLp.edist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"Œπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬π : Fintype Œπ\ninst‚úù : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\nx y : PiLp 2 Œ≤\n‚ä¢ Eq (EDist.edist x y) (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (EDist.edist (x i) (y i)) 2) (1 / 2))","decl":"theorem edist_eq_of_L2 (x y : PiLp 2 Œ≤) :\n    edist x y = (‚àë i, edist (x i) (y i) ^ 2) ^ (1 / 2 : ‚Ñù) := by simp [PiLp.edist_eq_sum]\n\n"}
{"name":"PiLp.instBoundedSMul","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù‚Å¥ : Fintype Œπ\ninst‚úù¬≥ : SeminormedRing ùïú\ninst‚úù¬≤ : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù¬π : (i : Œπ) ‚Üí Module ùïú (Œ≤ i)\ninst‚úù : ‚àÄ (i : Œπ), BoundedSMul ùïú (Œ≤ i)\n‚ä¢ BoundedSMul ùïú (PiLp p Œ≤)","decl":"instance instBoundedSMul [SeminormedRing ùïú] [‚àÄ i, SeminormedAddCommGroup (Œ≤ i)]\n    [‚àÄ i, Module ùïú (Œ≤ i)] [‚àÄ i, BoundedSMul ùïú (Œ≤ i)] :\n    BoundedSMul ùïú (PiLp p Œ≤) :=\n  .of_nnnorm_smul_le fun c f => by\n    rcases p.dichotomy with (rfl | hp)\n    ¬∑ rw [‚Üê nnnorm_equiv, ‚Üê nnnorm_equiv, WithLp.equiv_smul]\n      exact nnnorm_smul_le c (WithLp.equiv ‚àû (‚àÄ i, Œ≤ i) f)\n    ¬∑ have hp0 : 0 < p.toReal := zero_lt_one.trans_le hp\n      have hpt : p ‚â† ‚ä§ := p.toReal_pos_iff_ne_top.mp hp0\n      rw [nnnorm_eq_sum hpt, nnnorm_eq_sum hpt, one_div, NNReal.rpow_inv_le_iff hp0,\n        NNReal.mul_rpow, ‚Üê NNReal.rpow_mul, inv_mul_cancel‚ÇÄ hp0.ne', NNReal.rpow_one,\n        Finset.mul_sum]\n      simp_rw [‚Üê NNReal.mul_rpow, smul_apply]\n      exact Finset.sum_le_sum fun i _ => NNReal.rpow_le_rpow (nnnorm_smul_le _ _) hp0.le\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrLeft_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nhp : Fact (LE.le 1 p)\ninst‚úù‚Å¥ : Fintype Œπ\ninst‚úù¬≥ : Semiring ùïú\nŒπ' : Type u_5\ninst‚úù¬≤ : Fintype Œπ'\nE : Type u_6\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : Module ùïú E\ne : Equiv Œπ Œπ'\nv : PiLp p fun x => E\n‚ä¢ Eq ((LinearIsometryEquiv.piLpCongrLeft p ùïú E e) v) ((Equiv.piCongrLeft' (fun x => E) e) v)","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrLeft_apply (e : Œπ ‚âÉ Œπ') (v : PiLp p fun _ : Œπ => E) :\n    LinearIsometryEquiv.piLpCongrLeft p ùïú E e v = Equiv.piCongrLeft' (fun _ : Œπ => E) e v :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrLeft_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nhp : Fact (LE.le 1 p)\ninst‚úù‚Å¥ : Fintype Œπ\ninst‚úù¬≥ : Semiring ùïú\nŒπ' : Type u_5\ninst‚úù¬≤ : Fintype Œπ'\nE : Type u_6\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : Module ùïú E\ne : Equiv Œπ Œπ'\n‚ä¢ Eq (LinearIsometryEquiv.piLpCongrLeft p ùïú E e).symm (LinearIsometryEquiv.piLpCongrLeft p ùïú E e.symm)","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrLeft_symm (e : Œπ ‚âÉ Œπ') :\n    (LinearIsometryEquiv.piLpCongrLeft p ùïú E e).symm =\n      LinearIsometryEquiv.piLpCongrLeft p ùïú E e.symm :=\n  LinearIsometryEquiv.ext fun z ‚Ü¶ -- Porting note: was `rfl`\n    congr_arg (Equiv.toFun ¬∑ z) (Equiv.piCongrLeft'_symm _ _)\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrLeft_single","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nhp : Fact (LE.le 1 p)\ninst‚úù‚Å∂ : Fintype Œπ\ninst‚úù‚Åµ : Semiring ùïú\nŒπ' : Type u_5\ninst‚úù‚Å¥ : Fintype Œπ'\nE : Type u_6\ninst‚úù¬≥ : SeminormedAddCommGroup E\ninst‚úù¬≤ : Module ùïú E\ninst‚úù¬π : DecidableEq Œπ\ninst‚úù : DecidableEq Œπ'\ne : Equiv Œπ Œπ'\ni : Œπ\nv : E\n‚ä¢ Eq ((LinearIsometryEquiv.piLpCongrLeft p ùïú E e) ((WithLp.equiv p (Œπ ‚Üí E)).symm (Pi.single i v))) ((WithLp.equiv p (Œπ' ‚Üí E)).symm (Pi.single (e i) v))","decl":"@[simp high]\ntheorem _root_.LinearIsometryEquiv.piLpCongrLeft_single [DecidableEq Œπ] [DecidableEq Œπ']\n    (e : Œπ ‚âÉ Œπ') (i : Œπ) (v : E) :\n    LinearIsometryEquiv.piLpCongrLeft p ùïú E e ((WithLp.equiv p (_ ‚Üí E)).symm <| Pi.single i v) =\n      (WithLp.equiv p (_ ‚Üí E)).symm (Pi.single (e i) v) := by\n  funext x\n  simp [LinearIsometryEquiv.piLpCongrLeft_apply, LinearEquiv.piCongrLeft', Equiv.piCongrLeft',\n    Pi.single, Function.update, Equiv.symm_apply_eq]\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrRight_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù‚Åµ : Fintype Œπ\ninst‚úù‚Å¥ : Semiring ùïú\ninst‚úù¬≥ : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ± i)\ninst‚úù¬≤ : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù¬π : (i : Œπ) ‚Üí Module ùïú (Œ± i)\ninst‚úù : (i : Œπ) ‚Üí Module ùïú (Œ≤ i)\ne : (i : Œπ) ‚Üí LinearIsometryEquiv (RingHom.id ùïú) (Œ± i) (Œ≤ i)\nx : PiLp p Œ±\n‚ä¢ Eq ((LinearIsometryEquiv.piLpCongrRight p e) x) ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm fun i => (e i) (x i))","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrRight_apply (e : ‚àÄ i, Œ± i ‚âÉ‚Çó·µ¢[ùïú] Œ≤ i) (x : PiLp p Œ±) :\n    LinearIsometryEquiv.piLpCongrRight p e x =\n      (WithLp.equiv p _).symm (fun i => e i (x i)) :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrRight_refl","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\nhp : Fact (LE.le 1 p)\ninst‚úù¬≥ : Fintype Œπ\ninst‚úù¬≤ : Semiring ùïú\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ± i)\ninst‚úù : (i : Œπ) ‚Üí Module ùïú (Œ± i)\n‚ä¢ Eq (LinearIsometryEquiv.piLpCongrRight p fun i => LinearIsometryEquiv.refl ùïú (Œ± i)) (LinearIsometryEquiv.refl ùïú (PiLp p Œ±))","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrRight_refl :\n    LinearIsometryEquiv.piLpCongrRight p (fun i => .refl ùïú (Œ± i)) = .refl _ _ :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrRight_symm","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù‚Åµ : Fintype Œπ\ninst‚úù‚Å¥ : Semiring ùïú\ninst‚úù¬≥ : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ± i)\ninst‚úù¬≤ : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù¬π : (i : Œπ) ‚Üí Module ùïú (Œ± i)\ninst‚úù : (i : Œπ) ‚Üí Module ùïú (Œ≤ i)\ne : (i : Œπ) ‚Üí LinearIsometryEquiv (RingHom.id ùïú) (Œ± i) (Œ≤ i)\n‚ä¢ Eq (LinearIsometryEquiv.piLpCongrRight p e).symm (LinearIsometryEquiv.piLpCongrRight p fun i => (e i).symm)","decl":"@[simp]\ntheorem _root_.LinearIsometryEquiv.piLpCongrRight_symm (e : ‚àÄ i, Œ± i ‚âÉ‚Çó·µ¢[ùïú] Œ≤ i) :\n    (LinearIsometryEquiv.piLpCongrRight p e).symm =\n      LinearIsometryEquiv.piLpCongrRight p (fun i => (e i).symm) :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCongrRight_single","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ± : Œπ ‚Üí Type u_3\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù‚Å∂ : Fintype Œπ\ninst‚úù‚Åµ : Semiring ùïú\ninst‚úù‚Å¥ : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ± i)\ninst‚úù¬≥ : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù¬≤ : (i : Œπ) ‚Üí Module ùïú (Œ± i)\ninst‚úù¬π : (i : Œπ) ‚Üí Module ùïú (Œ≤ i)\ne : (i : Œπ) ‚Üí LinearIsometryEquiv (RingHom.id ùïú) (Œ± i) (Œ≤ i)\ninst‚úù : DecidableEq Œπ\ni : Œπ\nv : Œ± i\n‚ä¢ Eq ((LinearIsometryEquiv.piLpCongrRight p e) ((WithLp.equiv p ((i : Œπ) ‚Üí Œ± i)).symm (Pi.single i v))) ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i ((e i) v)))","decl":"@[simp high]\ntheorem _root_.LinearIsometryEquiv.piLpCongrRight_single (e : ‚àÄ i, Œ± i ‚âÉ‚Çó·µ¢[ùïú] Œ≤ i) [DecidableEq Œπ]\n    (i : Œπ) (v : Œ± i) :\n    LinearIsometryEquiv.piLpCongrRight p e ((WithLp.equiv p (‚àÄ i, Œ± i)).symm <| Pi.single i v) =\n      (WithLp.equiv p (‚àÄ i, Œ≤ i)).symm (Pi.single i (e _ v)) :=\n  funext <| Pi.apply_single (e ¬∑) (fun _ => map_zero _) _ _\n\n"}
{"name":"LinearIsometryEquiv.piLpCurry_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"ùïú : Type u_1\ninst‚úù‚Åµ : Semiring ùïú\nŒπ : Type u_5\nŒ∫ : Œπ ‚Üí Type u_6\np : ENNReal\ninst‚úù‚Å¥ : Fact (LE.le 1 p)\ninst‚úù¬≥ : Fintype Œπ\ninst‚úù¬≤ : (i : Œπ) ‚Üí Fintype (Œ∫ i)\nŒ± : (i : Œπ) ‚Üí Œ∫ i ‚Üí Type u_7\ninst‚úù¬π : (i : Œπ) ‚Üí (k : Œ∫ i) ‚Üí SeminormedAddCommGroup (Œ± i k)\ninst‚úù : (i : Œπ) ‚Üí (k : Œ∫ i) ‚Üí Module ùïú (Œ± i k)\nf : PiLp p fun i => Œ± i.fst i.snd\n‚ä¢ Eq ((LinearIsometryEquiv.piLpCurry ùïú p Œ±) f) ((WithLp.equiv p ((i : Œπ) ‚Üí WithLp p ((y : Œ∫ i) ‚Üí Œ± i y))).symm fun i => (WithLp.equiv p ((y : Œ∫ i) ‚Üí Œ± i y)).symm (Sigma.curry ((WithLp.equiv p ((x : Sigma Œ∫) ‚Üí Œ± x.fst x.snd)) f) i))","decl":"@[simp] theorem _root_.LinearIsometryEquiv.piLpCurry_apply\n    (f : PiLp p (fun i : Sigma Œ∫ => Œ± i.1 i.2)) :\n    _root_.LinearIsometryEquiv.piLpCurry ùïú p Œ± f =\n      (WithLp.equiv _ _).symm (fun i => (WithLp.equiv _ _).symm <|\n        Sigma.curry (WithLp.equiv _ _ f) i) :=\n  rfl\n\n"}
{"name":"LinearIsometryEquiv.piLpCurry_symm_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"ùïú : Type u_1\ninst‚úù‚Åµ : Semiring ùïú\nŒπ : Type u_5\nŒ∫ : Œπ ‚Üí Type u_6\np : ENNReal\ninst‚úù‚Å¥ : Fact (LE.le 1 p)\ninst‚úù¬≥ : Fintype Œπ\ninst‚úù¬≤ : (i : Œπ) ‚Üí Fintype (Œ∫ i)\nŒ± : (i : Œπ) ‚Üí Œ∫ i ‚Üí Type u_7\ninst‚úù¬π : (i : Œπ) ‚Üí (k : Œ∫ i) ‚Üí SeminormedAddCommGroup (Œ± i k)\ninst‚úù : (i : Œπ) ‚Üí (k : Œ∫ i) ‚Üí Module ùïú (Œ± i k)\nf : PiLp p fun i => PiLp p (Œ± i)\n‚ä¢ Eq ((LinearIsometryEquiv.piLpCurry ùïú p Œ±).symm f) ((WithLp.equiv p ((x : Sigma Œ∫) ‚Üí Œ± x.fst x.snd)).symm (Sigma.uncurry fun i j => f i j))","decl":"@[simp] theorem _root_.LinearIsometryEquiv.piLpCurry_symm_apply\n    (f : PiLp p (fun i => PiLp p (Œ± i))) :\n    (_root_.LinearIsometryEquiv.piLpCurry ùïú p Œ±).symm f =\n      (WithLp.equiv _ _).symm (Sigma.uncurry fun i j => f i j) :=\n  rfl\n\n"}
{"name":"PiLp.nnnorm_equiv_symm_single","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù¬≤ : Fintype Œπ\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : DecidableEq Œπ\ni : Œπ\nb : Œ≤ i\n‚ä¢ Eq (NNNorm.nnnorm ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i b))) (NNNorm.nnnorm b)","decl":"@[simp]\ntheorem nnnorm_equiv_symm_single (i : Œπ) (b : Œ≤ i) :\n    ‚Äñ(WithLp.equiv p (‚àÄ i, Œ≤ i)).symm (Pi.single i b)‚Äñ‚Çä = ‚Äñb‚Äñ‚Çä := by\n  haveI : Nonempty Œπ := ‚ü®i‚ü©\n  induction p generalizing hp with\n  | top =>\n    simp_rw [nnnorm_eq_ciSup, WithLp.equiv_symm_pi_apply]\n    refine\n      ciSup_eq_of_forall_le_of_forall_lt_exists_gt (fun j => ?_) fun n hn => ‚ü®i, hn.trans_eq ?_‚ü©\n    ¬∑ obtain rfl | hij := Decidable.eq_or_ne i j\n      ¬∑ rw [Pi.single_eq_same]\n      ¬∑ rw [Pi.single_eq_of_ne' hij, nnnorm_zero]\n        exact zero_le _\n    ¬∑ rw [Pi.single_eq_same]\n  | coe p =>\n    have hp0 : (p : ‚Ñù) ‚â† 0 :=\n      mod_cast (zero_lt_one.trans_le <| Fact.out (p := 1 ‚â§ (p : ‚Ñù‚â•0‚àû))).ne'\n    rw [nnnorm_eq_sum ENNReal.coe_ne_top, ENNReal.coe_toReal, Fintype.sum_eq_single i,\n      WithLp.equiv_symm_pi_apply, Pi.single_eq_same, ‚Üê NNReal.rpow_mul, one_div,\n      mul_inv_cancel‚ÇÄ hp0, NNReal.rpow_one]\n    intro j hij\n    rw [WithLp.equiv_symm_pi_apply, Pi.single_eq_of_ne hij, nnnorm_zero, NNReal.zero_rpow hp0]\n\n"}
{"name":"PiLp.norm_equiv_symm_single","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù¬≤ : Fintype Œπ\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : DecidableEq Œπ\ni : Œπ\nb : Œ≤ i\n‚ä¢ Eq (Norm.norm ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i b))) (Norm.norm b)","decl":"@[simp]\ntheorem norm_equiv_symm_single (i : Œπ) (b : Œ≤ i) :\n    ‚Äñ(WithLp.equiv p (‚àÄ i, Œ≤ i)).symm (Pi.single i b)‚Äñ = ‚Äñb‚Äñ :=\n  congr_arg ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) <| nnnorm_equiv_symm_single p Œ≤ i b\n\n"}
{"name":"PiLp.nndist_equiv_symm_single_same","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù¬≤ : Fintype Œπ\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : DecidableEq Œπ\ni : Œπ\nb‚ÇÅ b‚ÇÇ : Œ≤ i\n‚ä¢ Eq (NNDist.nndist ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i b‚ÇÅ)) ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i b‚ÇÇ))) (NNDist.nndist b‚ÇÅ b‚ÇÇ)","decl":"@[simp]\ntheorem nndist_equiv_symm_single_same (i : Œπ) (b‚ÇÅ b‚ÇÇ : Œ≤ i) :\n    nndist\n        ((WithLp.equiv p (‚àÄ i, Œ≤ i)).symm (Pi.single i b‚ÇÅ))\n        ((WithLp.equiv p (‚àÄ i, Œ≤ i)).symm (Pi.single i b‚ÇÇ)) =\n      nndist b‚ÇÅ b‚ÇÇ := by\n  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, ‚Üê WithLp.equiv_symm_sub, ‚Üê Pi.single_sub,\n    nnnorm_equiv_symm_single]\n\n"}
{"name":"PiLp.dist_equiv_symm_single_same","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù¬≤ : Fintype Œπ\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : DecidableEq Œπ\ni : Œπ\nb‚ÇÅ b‚ÇÇ : Œ≤ i\n‚ä¢ Eq (Dist.dist ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i b‚ÇÅ)) ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i b‚ÇÇ))) (Dist.dist b‚ÇÅ b‚ÇÇ)","decl":"@[simp]\ntheorem dist_equiv_symm_single_same (i : Œπ) (b‚ÇÅ b‚ÇÇ : Œ≤ i) :\n    dist\n        ((WithLp.equiv p (‚àÄ i, Œ≤ i)).symm (Pi.single i b‚ÇÅ))\n        ((WithLp.equiv p (‚àÄ i, Œ≤ i)).symm (Pi.single i b‚ÇÇ)) =\n      dist b‚ÇÅ b‚ÇÇ :=\n  congr_arg ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) <| nndist_equiv_symm_single_same p Œ≤ i b‚ÇÅ b‚ÇÇ\n\n"}
{"name":"PiLp.edist_equiv_symm_single_same","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\nhp : Fact (LE.le 1 p)\ninst‚úù¬≤ : Fintype Œπ\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : DecidableEq Œπ\ni : Œπ\nb‚ÇÅ b‚ÇÇ : Œ≤ i\n‚ä¢ Eq (EDist.edist ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i b‚ÇÅ)) ((WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm (Pi.single i b‚ÇÇ))) (EDist.edist b‚ÇÅ b‚ÇÇ)","decl":"@[simp]\ntheorem edist_equiv_symm_single_same (i : Œπ) (b‚ÇÅ b‚ÇÇ : Œ≤ i) :\n    edist\n        ((WithLp.equiv p (‚àÄ i, Œ≤ i)).symm (Pi.single i b‚ÇÅ))\n        ((WithLp.equiv p (‚àÄ i, Œ≤ i)).symm (Pi.single i b‚ÇÇ)) =\n      edist b‚ÇÅ b‚ÇÇ := by\n  simp only [edist_nndist, nndist_equiv_symm_single_same p Œ≤ i b‚ÇÅ b‚ÇÇ]\n\n"}
{"name":"PiLp.nnnorm_equiv_symm_const","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nhp‚úù : Fact (LE.le 1 p)\ninst‚úù¬π : Fintype Œπ\nŒ≤ : Type u_5\ninst‚úù : SeminormedAddCommGroup Œ≤\nhp : Ne p Top.top\nb : Œ≤\n‚ä¢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Œπ ‚Üí Œ≤)).symm (Function.const Œπ b))) (HMul.hMul (HPow.hPow (‚Üë(Fintype.card Œπ)) (HDiv.hDiv 1 p).toReal) (NNNorm.nnnorm b))","decl":"/-- When `p = ‚àû`, this lemma does not hold without the additional assumption `Nonempty Œπ` because\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `‚Äñb‚Äñ‚Çä`. See\n`PiLp.nnnorm_equiv_symm_const'` for a version which exchanges the hypothesis `p ‚â† ‚àû` for\n`Nonempty Œπ`. -/\ntheorem nnnorm_equiv_symm_const {Œ≤} [SeminormedAddCommGroup Œ≤] (hp : p ‚â† ‚àû) (b : Œ≤) :\n    ‚Äñ(WithLp.equiv p (Œπ ‚Üí Œ≤)).symm (Function.const _ b)‚Äñ‚Çä =\n      (Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal * ‚Äñb‚Äñ‚Çä := by\n  rcases p.dichotomy with (h | h)\n  ¬∑ exact False.elim (hp h)\n  ¬∑ have ne_zero : p.toReal ‚â† 0 := (zero_lt_one.trans_le h).ne'\n    simp_rw [nnnorm_eq_sum hp, WithLp.equiv_symm_pi_apply, Function.const_apply, Finset.sum_const,\n      Finset.card_univ, nsmul_eq_mul, NNReal.mul_rpow, ‚Üê NNReal.rpow_mul,\n      mul_one_div_cancel ne_zero, NNReal.rpow_one, ENNReal.toReal_div, ENNReal.one_toReal]\n\n"}
{"name":"PiLp.nnnorm_equiv_symm_const'","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nhp : Fact (LE.le 1 p)\ninst‚úù¬≤ : Fintype Œπ\nŒ≤ : Type u_5\ninst‚úù¬π : SeminormedAddCommGroup Œ≤\ninst‚úù : Nonempty Œπ\nb : Œ≤\n‚ä¢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Œπ ‚Üí Œ≤)).symm (Function.const Œπ b))) (HMul.hMul (HPow.hPow (‚Üë(Fintype.card Œπ)) (HDiv.hDiv 1 p).toReal) (NNNorm.nnnorm b))","decl":"/-- When `IsEmpty Œπ`, this lemma does not hold without the additional assumption `p ‚â† ‚àû` because\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `‚Äñb‚Äñ‚Çä`. See\n`PiLp.nnnorm_equiv_symm_const` for a version which exchanges the hypothesis `Nonempty Œπ`.\nfor `p ‚â† ‚àû`. -/\ntheorem nnnorm_equiv_symm_const' {Œ≤} [SeminormedAddCommGroup Œ≤] [Nonempty Œπ] (b : Œ≤) :\n    ‚Äñ(WithLp.equiv p (Œπ ‚Üí Œ≤)).symm (Function.const _ b)‚Äñ‚Çä =\n      (Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal * ‚Äñb‚Äñ‚Çä := by\n  rcases em <| p = ‚àû with (rfl | hp)\n  ¬∑ simp only [WithLp.equiv_symm_pi_apply, ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero,\n      one_mul, nnnorm_eq_ciSup, Function.const_apply, ciSup_const]\n  ¬∑ exact nnnorm_equiv_symm_const hp b\n\n"}
{"name":"PiLp.norm_equiv_symm_const","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nhp‚úù : Fact (LE.le 1 p)\ninst‚úù¬π : Fintype Œπ\nŒ≤ : Type u_5\ninst‚úù : SeminormedAddCommGroup Œ≤\nhp : Ne p Top.top\nb : Œ≤\n‚ä¢ Eq (Norm.norm ((WithLp.equiv p (Œπ ‚Üí Œ≤)).symm (Function.const Œπ b))) (HMul.hMul (HPow.hPow (‚Üë‚Üë(Fintype.card Œπ)) (HDiv.hDiv 1 p).toReal) (Norm.norm b))","decl":"/-- When `p = ‚àû`, this lemma does not hold without the additional assumption `Nonempty Œπ` because\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `‚Äñb‚Äñ‚Çä`. See\n`PiLp.norm_equiv_symm_const'` for a version which exchanges the hypothesis `p ‚â† ‚àû` for\n`Nonempty Œπ`. -/\ntheorem norm_equiv_symm_const {Œ≤} [SeminormedAddCommGroup Œ≤] (hp : p ‚â† ‚àû) (b : Œ≤) :\n    ‚Äñ(WithLp.equiv p (Œπ ‚Üí Œ≤)).symm (Function.const _ b)‚Äñ =\n      (Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal * ‚Äñb‚Äñ :=\n  (congr_arg ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) <| nnnorm_equiv_symm_const hp b).trans <| by simp\n\n"}
{"name":"PiLp.norm_equiv_symm_const'","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nhp : Fact (LE.le 1 p)\ninst‚úù¬≤ : Fintype Œπ\nŒ≤ : Type u_5\ninst‚úù¬π : SeminormedAddCommGroup Œ≤\ninst‚úù : Nonempty Œπ\nb : Œ≤\n‚ä¢ Eq (Norm.norm ((WithLp.equiv p (Œπ ‚Üí Œ≤)).symm (Function.const Œπ b))) (HMul.hMul (HPow.hPow (‚Üë‚Üë(Fintype.card Œπ)) (HDiv.hDiv 1 p).toReal) (Norm.norm b))","decl":"/-- When `IsEmpty Œπ`, this lemma does not hold without the additional assumption `p ‚â† ‚àû` because\nthe left-hand side simplifies to `0`, while the right-hand side simplifies to `‚Äñb‚Äñ‚Çä`. See\n`PiLp.norm_equiv_symm_const` for a version which exchanges the hypothesis `Nonempty Œπ`.\nfor `p ‚â† ‚àû`. -/\ntheorem norm_equiv_symm_const' {Œ≤} [SeminormedAddCommGroup Œ≤] [Nonempty Œπ] (b : Œ≤) :\n    ‚Äñ(WithLp.equiv p (Œπ ‚Üí Œ≤)).symm (Function.const _ b)‚Äñ =\n      (Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal * ‚Äñb‚Äñ :=\n  (congr_arg ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) <| nnnorm_equiv_symm_const' b).trans <| by simp\n\n"}
{"name":"PiLp.nnnorm_equiv_symm_one","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nhp‚úù : Fact (LE.le 1 p)\ninst‚úù¬≤ : Fintype Œπ\nŒ≤ : Type u_5\ninst‚úù¬π : SeminormedAddCommGroup Œ≤\nhp : Ne p Top.top\ninst‚úù : One Œ≤\n‚ä¢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Œπ ‚Üí Œ≤)).symm 1)) (HMul.hMul (HPow.hPow (‚Üë(Fintype.card Œπ)) (HDiv.hDiv 1 p).toReal) (NNNorm.nnnorm 1))","decl":"theorem nnnorm_equiv_symm_one {Œ≤} [SeminormedAddCommGroup Œ≤] (hp : p ‚â† ‚àû) [One Œ≤] :\n    ‚Äñ(WithLp.equiv p (Œπ ‚Üí Œ≤)).symm 1‚Äñ‚Çä =\n      (Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal * ‚Äñ(1 : Œ≤)‚Äñ‚Çä :=\n  (nnnorm_equiv_symm_const hp (1 : Œ≤)).trans rfl\n\n"}
{"name":"PiLp.norm_equiv_symm_one","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\nhp‚úù : Fact (LE.le 1 p)\ninst‚úù¬≤ : Fintype Œπ\nŒ≤ : Type u_5\ninst‚úù¬π : SeminormedAddCommGroup Œ≤\nhp : Ne p Top.top\ninst‚úù : One Œ≤\n‚ä¢ Eq (Norm.norm ((WithLp.equiv p (Œπ ‚Üí Œ≤)).symm 1)) (HMul.hMul (HPow.hPow (‚Üë‚Üë(Fintype.card Œπ)) (HDiv.hDiv 1 p).toReal) (Norm.norm 1))","decl":"theorem norm_equiv_symm_one {Œ≤} [SeminormedAddCommGroup Œ≤] (hp : p ‚â† ‚àû) [One Œ≤] :\n    ‚Äñ(WithLp.equiv p (Œπ ‚Üí Œ≤)).symm 1‚Äñ = (Fintype.card Œπ : ‚Ñù‚â•0) ^ (1 / p).toReal * ‚Äñ(1 : Œ≤)‚Äñ :=\n  (norm_equiv_symm_const hp (1 : Œ≤)).trans rfl\n\n"}
{"name":"PiLp.continuousLinearEquiv_symm_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : Semiring ùïú\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : (i : Œπ) ‚Üí Module ùïú (Œ≤ i)\n‚ä¢ Eq ‚áë(PiLp.continuousLinearEquiv p ùïú Œ≤).symm ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i)).symm","decl":"/-- `WithLp.equiv` as a continuous linear equivalence. -/\n@[simps! (config := .asFn) apply symm_apply]\nprotected def continuousLinearEquiv : PiLp p Œ≤ ‚âÉL[ùïú] ‚àÄ i, Œ≤ i where\n  toLinearEquiv := WithLp.linearEquiv _ _ _\n  continuous_toFun := continuous_equiv _ _\n  continuous_invFun := continuous_equiv_symm _ _\n\n"}
{"name":"PiLp.continuousLinearEquiv_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : Semiring ùïú\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : (i : Œπ) ‚Üí Module ùïú (Œ≤ i)\n‚ä¢ Eq ‚áë(PiLp.continuousLinearEquiv p ùïú Œ≤) ‚áë(WithLp.equiv p ((i : Œπ) ‚Üí Œ≤ i))","decl":"/-- `WithLp.equiv` as a continuous linear equivalence. -/\n@[simps! (config := .asFn) apply symm_apply]\nprotected def continuousLinearEquiv : PiLp p Œ≤ ‚âÉL[ùïú] ‚àÄ i, Œ≤ i where\n  toLinearEquiv := WithLp.linearEquiv _ _ _\n  continuous_toFun := continuous_equiv _ _\n  continuous_invFun := continuous_equiv_symm _ _\n\n"}
{"name":"PiLp.proj_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\nŒ≤ : Œπ ‚Üí Type u_4\ninst‚úù¬≤ : Semiring ùïú\ninst‚úù¬π : (i : Œπ) ‚Üí SeminormedAddCommGroup (Œ≤ i)\ninst‚úù : (i : Œπ) ‚Üí Module ùïú (Œ≤ i)\ni : Œπ\na‚úù : PiLp p Œ≤\n‚ä¢ Eq ((PiLp.proj p Œ≤ i) a‚úù) (a‚úù i)","decl":"variable {ùïú} in\n/-- The projection on the `i`-th coordinate of `PiLp p Œ≤`, as a continuous linear map. -/\n@[simps!]\ndef proj (i : Œπ) : PiLp p Œ≤ ‚ÜíL[ùïú] Œ≤ i where\n  __ := proj‚Çó p Œ≤ i\n  cont := continuous_apply i\n\n"}
{"name":"PiLp.basisFun_apply","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : Finite Œπ\ninst‚úù¬π : Ring ùïú\ninst‚úù : DecidableEq Œπ\ni : Œπ\n‚ä¢ Eq ((PiLp.basisFun p ùïú Œπ) i) ((WithLp.equiv p (Œπ ‚Üí ùïú)).symm (Pi.single i 1))","decl":"@[simp]\ntheorem basisFun_apply [DecidableEq Œπ] (i) :\n    basisFun p ùïú Œπ i = (WithLp.equiv p _).symm (Pi.single i 1) := by\n  simp_rw [basisFun, Basis.coe_ofEquivFun, WithLp.linearEquiv_symm_apply]\n\n"}
{"name":"PiLp.basisFun_repr","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : Finite Œπ\ninst‚úù : Ring ùïú\nx : PiLp p fun x => ùïú\ni : Œπ\n‚ä¢ Eq (((PiLp.basisFun p ùïú Œπ).repr x) i) (x i)","decl":"@[simp]\ntheorem basisFun_repr (x : PiLp p fun _ : Œπ => ùïú) (i : Œπ) : (basisFun p ùïú Œπ).repr x i = x i :=\n  rfl\n\n"}
{"name":"PiLp.basisFun_equivFun","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : Finite Œπ\ninst‚úù : Ring ùïú\n‚ä¢ Eq (PiLp.basisFun p ùïú Œπ).equivFun (WithLp.linearEquiv p ùïú (Œπ ‚Üí ùïú))","decl":"@[simp]\ntheorem basisFun_equivFun : (basisFun p ùïú Œπ).equivFun = WithLp.linearEquiv p ùïú (Œπ ‚Üí ùïú) :=\n  Basis.equivFun_ofEquivFun _\n\n"}
{"name":"PiLp.basisFun_eq_pi_basisFun","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : Finite Œπ\ninst‚úù : Ring ùïú\n‚ä¢ Eq (PiLp.basisFun p ùïú Œπ) ((Pi.basisFun ùïú Œπ).map (WithLp.linearEquiv p ùïú (Œπ ‚Üí ùïú)).symm)","decl":"theorem basisFun_eq_pi_basisFun :\n    basisFun p ùïú Œπ = (Pi.basisFun ùïú Œπ).map (WithLp.linearEquiv p ùïú (Œπ ‚Üí ùïú)).symm :=\n  rfl\n\n"}
{"name":"PiLp.basisFun_map","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nùïú : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : Finite Œπ\ninst‚úù : Ring ùïú\n‚ä¢ Eq ((PiLp.basisFun p ùïú Œπ).map (WithLp.linearEquiv p ùïú (Œπ ‚Üí ùïú))) (Pi.basisFun ùïú Œπ)","decl":"@[simp]\ntheorem basisFun_map :\n    (basisFun p ùïú Œπ).map (WithLp.linearEquiv p ùïú (Œπ ‚Üí ùïú)) = Pi.basisFun ùïú Œπ :=\n  rfl\n\n"}
{"name":"PiLp.basis_toMatrix_basisFun_mul","module":"Mathlib.Analysis.Normed.Lp.PiLp","initialProofState":"p : ENNReal\nŒπ : Type u_2\ninst‚úù¬π : Fintype Œπ\nùïú : Type u_5\ninst‚úù : SeminormedCommRing ùïú\nb : Basis Œπ ùïú (PiLp p fun x => ùïú)\nA : Matrix Œπ Œπ ùïú\n‚ä¢ Eq (HMul.hMul (b.toMatrix ‚áë(PiLp.basisFun p ùïú Œπ)) A) (Matrix.of fun i j => (b.repr ((WithLp.equiv p ((i : Œπ) ‚Üí (fun x => ùïú) i)).symm (A.transpose j))) i)","decl":"nonrec theorem basis_toMatrix_basisFun_mul [Fintype Œπ]\n    {ùïú} [SeminormedCommRing ùïú] (b : Basis Œπ ùïú (PiLp p fun _ : Œπ => ùïú))\n    (A : Matrix Œπ Œπ ùïú) :\n    b.toMatrix (PiLp.basisFun _ _ _) * A =\n      Matrix.of fun i j => b.repr ((WithLp.equiv _ _).symm (A·µÄ j)) i := by\n  have := basis_toMatrix_basisFun_mul (b.map (WithLp.linearEquiv _ ùïú _)) A\n  simp_rw [‚Üê PiLp.basisFun_map p, Basis.map_repr, LinearEquiv.trans_apply,\n    WithLp.linearEquiv_symm_apply, Basis.toMatrix_map, Function.comp_def, Basis.map_apply,\n    LinearEquiv.symm_apply_apply] at this\n  exact this\n\n"}
