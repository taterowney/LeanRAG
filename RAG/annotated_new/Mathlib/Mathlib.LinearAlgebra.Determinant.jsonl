{"name":"Matrix.det_comm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"A : Type u_5\ninstâœÂ² : CommRing A\nn : Type u_7\ninstâœÂ¹ : Fintype n\ninstâœ : DecidableEq n\nM N : Matrix n n A\nâŠ¢ Eq (HMul.hMul M N).det (HMul.hMul N M).det","decl":"theorem det_comm [DecidableEq n] (M N : Matrix n n A) : det (M * N) = det (N * M) := by\n  rw [det_mul, det_mul, mul_comm]\n\n"}
{"name":"Matrix.det_comm'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"A : Type u_5\ninstâœâ´ : CommRing A\nm : Type u_6\nn : Type u_7\ninstâœÂ³ : Fintype m\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq m\ninstâœ : DecidableEq n\nM : Matrix n m A\nN M' : Matrix m n A\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\nâŠ¢ Eq (HMul.hMul M N).det (HMul.hMul N M).det","decl":"/-- If there exists a two-sided inverse `M'` for `M` (indexed differently),\nthen `det (N * M) = det (M * N)`. -/\ntheorem det_comm' [DecidableEq m] [DecidableEq n] {M : Matrix n m A} {N : Matrix m n A}\n    {M' : Matrix m n A} (hMM' : M * M' = 1) (hM'M : M' * M = 1) : det (M * N) = det (N * M) := by\n  nontriviality A\n  -- Although `m` and `n` are different a priori, we will show they have the same cardinality.\n  -- This turns the problem into one for square matrices, which is easy.\n  let e := indexEquivOfInv hMM' hM'M\n  rw [â† det_submatrix_equiv_self e, â† submatrix_mul_equiv _ _ _ (Equiv.refl n) _, det_comm,\n    submatrix_mul_equiv, Equiv.coe_refl, submatrix_id_id]\n\n"}
{"name":"Matrix.det_conj_of_mul_eq_one","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"A : Type u_5\ninstâœâ´ : CommRing A\nm : Type u_6\nn : Type u_7\ninstâœÂ³ : Fintype m\ninstâœÂ² : Fintype n\ninstâœÂ¹ : DecidableEq m\ninstâœ : DecidableEq n\nM : Matrix m n A\nM' : Matrix n m A\nN : Matrix n n A\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\nâŠ¢ Eq (HMul.hMul (HMul.hMul M N) M').det N.det","decl":"/-- If `M'` is a two-sided inverse for `M` (indexed differently), `det (M * N * M') = det N`.\n\nSee `Matrix.det_conj` and `Matrix.det_conj'` for the case when `M' = Mâ»Â¹` or vice versa. -/\ntheorem det_conj_of_mul_eq_one [DecidableEq m] [DecidableEq n] {M : Matrix m n A}\n    {M' : Matrix n m A} {N : Matrix n n A} (hMM' : M * M' = 1) (hM'M : M' * M = 1) :\n    det (M * N * M') = det N := by\n  rw [â† det_comm' hM'M hMM', â† Matrix.mul_assoc, hM'M, Matrix.one_mul]\n\n"}
{"name":"LinearMap.det_toMatrix_eq_det_toMatrix","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ¶ : AddCommGroup M\nÎ¹ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : Fintype Î¹\nA : Type u_5\ninstâœÂ³ : CommRing A\ninstâœÂ² : Module A M\nÎº : Type u_6\ninstâœÂ¹ : Fintype Îº\ninstâœ : DecidableEq Îº\nb : Basis Î¹ A M\nc : Basis Îº A M\nf : LinearMap (RingHom.id A) M M\nâŠ¢ Eq ((LinearMap.toMatrix b b) f).det ((LinearMap.toMatrix c c) f).det","decl":"/-- The determinant of `LinearMap.toMatrix` does not depend on the choice of basis. -/\ntheorem det_toMatrix_eq_det_toMatrix [DecidableEq Îº] (b : Basis Î¹ A M) (c : Basis Îº A M)\n    (f : M â†’â‚—[A] M) : det (LinearMap.toMatrix b b f) = det (LinearMap.toMatrix c c f) := by\n  rw [â† linearMap_toMatrix_mul_basis_toMatrix c b c, â† basis_toMatrix_mul_linearMap_toMatrix b c b,\n      Matrix.det_conj_of_mul_eq_one] <;>\n    rw [Basis.toMatrix_mul_toMatrix, Basis.toMatrix_self]\n\n\n"}
{"name":"LinearMap.detAux_def","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_7\ninstâœâ´ : AddCommGroup M\nÎ¹ : Type u_8\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nA : Type u_9\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nâŠ¢ Eq LinearMap.detAux (Trunc.lift (fun b => Matrix.detMonoidHom.comp â†‘(LinearMap.toMatrixAlgEquiv b)) â‹¯)","decl":"/-- The determinant of an endomorphism given a basis.\n\nSee `LinearMap.det` for a version that populates the basis non-computably.\n\nAlthough the `Trunc (Basis Î¹ A M)` parameter makes it slightly more convenient to switch bases,\nthere is no good way to generalize over universe parameters, so we can't fully state in `detAux`'s\ntype that it does not depend on the choice of basis. Instead you can use the `detAux_def''` lemma,\nor avoid mentioning a basis at all using `LinearMap.det`.\n-/\nirreducible_def detAux : Trunc (Basis Î¹ A M) â†’ (M â†’â‚—[A] M) â†’* A :=\n  Trunc.lift\n    (fun b : Basis Î¹ A M => detMonoidHom.comp (toMatrixAlgEquiv b : (M â†’â‚—[A] M) â†’* Matrix Î¹ Î¹ A))\n    fun b c => MonoidHom.ext <| det_toMatrix_eq_det_toMatrix b c\n\n"}
{"name":"LinearMap.detAux_def'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ´ : AddCommGroup M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nb : Basis Î¹ A M\nf : LinearMap (RingHom.id A) M M\nâŠ¢ Eq ((LinearMap.detAux (Trunc.mk b)) f) ((LinearMap.toMatrix b b) f).det","decl":"/-- Unfold lemma for `detAux`.\n\nSee also `detAux_def''` which allows you to vary the basis.\n-/\ntheorem detAux_def' (b : Basis Î¹ A M) (f : M â†’â‚—[A] M) :\n    LinearMap.detAux (Trunc.mk b) f = Matrix.det (LinearMap.toMatrix b b f) := by\n  rw [detAux]\n  rfl\n\n"}
{"name":"LinearMap.detAux_def''","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ¶ : AddCommGroup M\nÎ¹ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : Fintype Î¹\nA : Type u_5\ninstâœÂ³ : CommRing A\ninstâœÂ² : Module A M\nÎ¹' : Type u_7\ninstâœÂ¹ : Fintype Î¹'\ninstâœ : DecidableEq Î¹'\ntb : Trunc (Basis Î¹ A M)\nb' : Basis Î¹' A M\nf : LinearMap (RingHom.id A) M M\nâŠ¢ Eq ((LinearMap.detAux tb) f) ((LinearMap.toMatrix b' b') f).det","decl":"theorem detAux_def'' {Î¹' : Type*} [Fintype Î¹'] [DecidableEq Î¹'] (tb : Trunc <| Basis Î¹ A M)\n    (b' : Basis Î¹' A M) (f : M â†’â‚—[A] M) :\n    LinearMap.detAux tb f = Matrix.det (LinearMap.toMatrix b' b' f) := by\n  induction tb using Trunc.induction_on with\n  | h b => rw [detAux_def', det_toMatrix_eq_det_toMatrix b b']\n\n"}
{"name":"LinearMap.detAux_id","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ´ : AddCommGroup M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nb : Trunc (Basis Î¹ A M)\nâŠ¢ Eq ((LinearMap.detAux b) LinearMap.id) 1","decl":"@[simp]\ntheorem detAux_id (b : Trunc <| Basis Î¹ A M) : LinearMap.detAux b LinearMap.id = 1 :=\n  (LinearMap.detAux b).map_one\n\n"}
{"name":"LinearMap.detAux_comp","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ´ : AddCommGroup M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nb : Trunc (Basis Î¹ A M)\nf g : LinearMap (RingHom.id A) M M\nâŠ¢ Eq ((LinearMap.detAux b) (f.comp g)) (HMul.hMul ((LinearMap.detAux b) f) ((LinearMap.detAux b) g))","decl":"@[simp]\ntheorem detAux_comp (b : Trunc <| Basis Î¹ A M) (f g : M â†’â‚—[A] M) :\n    LinearMap.detAux b (f.comp g) = LinearMap.detAux b f * LinearMap.detAux b g :=\n  (LinearMap.detAux b).map_mul f g\n\n"}
{"name":"LinearMap.det_def","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_7\ninstâœÂ² : AddCommGroup M\nA : Type u_8\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nâŠ¢ Eq LinearMap.det (dite (Exists fun s => Nonempty (Basis (Subtype fun x => Membership.mem s x) A M)) (fun H => LinearMap.detAux (Trunc.mk â‹¯.some)) fun H => 1)","decl":"open scoped Classical in\n-- Discourage the elaborator from unfolding `det` and producing a huge term by marking it\n-- as irreducible.\n/-- The determinant of an endomorphism independent of basis.\n\nIf there is no finite basis on `M`, the result is `1` instead.\n-/\nprotected irreducible_def det : (M â†’â‚—[A] M) â†’* A :=\n  if H : âˆƒ s : Finset M, Nonempty (Basis s A M) then LinearMap.detAux (Trunc.mk H.choose_spec.some)\n  else 1\n\n"}
{"name":"LinearMap.coe_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ³ : AddCommGroup M\nA : Type u_5\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Module A M\ninstâœ : DecidableEq M\nâŠ¢ Eq â‡‘LinearMap.det â‡‘(dite (Exists fun s => Nonempty (Basis (Subtype fun x => Membership.mem s x) A M)) (fun H => LinearMap.detAux (Trunc.mk â‹¯.some)) fun H => 1)","decl":"open scoped Classical in\ntheorem coe_det [DecidableEq M] :\n    â‡‘(LinearMap.det : (M â†’â‚—[A] M) â†’* A) =\n      if H : âˆƒ s : Finset M, Nonempty (Basis s A M) then\n        LinearMap.detAux (Trunc.mk H.choose_spec.some)\n      else 1 := by\n  ext\n  rw [LinearMap.det_def]\n  split_ifs\n  Â· congr -- use the correct `DecidableEq` instance\n  rfl\n\n"}
{"name":"LinearMap.det_eq_det_toMatrix_of_finset","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ³ : AddCommGroup M\nA : Type u_5\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Module A M\ninstâœ : DecidableEq M\ns : Finset M\nb : Basis (Subtype fun x => Membership.mem s x) A M\nf : LinearMap (RingHom.id A) M M\nâŠ¢ Eq (LinearMap.det f) ((LinearMap.toMatrix b b) f).det","decl":"theorem det_eq_det_toMatrix_of_finset [DecidableEq M] {s : Finset M} (b : Basis s A M)\n    (f : M â†’â‚—[A] M) : LinearMap.det f = Matrix.det (LinearMap.toMatrix b b f) := by\n  have : âˆƒ s : Finset M, Nonempty (Basis s A M) := âŸ¨s, âŸ¨bâŸ©âŸ©\n  rw [LinearMap.coe_det, dif_pos, detAux_def'' _ b] <;> assumption\n\n"}
{"name":"LinearMap.det_toMatrix","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ´ : AddCommGroup M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nb : Basis Î¹ A M\nf : LinearMap (RingHom.id A) M M\nâŠ¢ Eq ((LinearMap.toMatrix b b) f).det (LinearMap.det f)","decl":"@[simp]\ntheorem det_toMatrix (b : Basis Î¹ A M) (f : M â†’â‚—[A] M) :\n    Matrix.det (toMatrix b b f) = LinearMap.det f := by\n  haveI := Classical.decEq M\n  rw [det_eq_det_toMatrix_of_finset b.reindexFinsetRange]\n  -- Porting note: moved out of `rw` due to error\n  -- typeclass instance problem is stuck, it is often due to metavariables `DecidableEq ?m.628881`\n  apply det_toMatrix_eq_det_toMatrix b\n\n"}
{"name":"LinearMap.det_toMatrix'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"A : Type u_5\ninstâœÂ² : CommRing A\nÎ¹ : Type u_7\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\nf : LinearMap (RingHom.id A) (Î¹ â†’ A) (Î¹ â†’ A)\nâŠ¢ Eq (LinearMap.toMatrix' f).det (LinearMap.det f)","decl":"@[simp]\ntheorem det_toMatrix' {Î¹ : Type*} [Fintype Î¹] [DecidableEq Î¹] (f : (Î¹ â†’ A) â†’â‚—[A] Î¹ â†’ A) :\n    Matrix.det (LinearMap.toMatrix' f) = LinearMap.det f := by simp [â† toMatrix_eq_toMatrix']\n\n"}
{"name":"LinearMap.det_toLin","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nb : Basis Î¹ R M\nf : Matrix Î¹ Î¹ R\nâŠ¢ Eq (LinearMap.det ((Matrix.toLin b b) f)) f.det","decl":"@[simp]\ntheorem det_toLin (b : Basis Î¹ R M) (f : Matrix Î¹ Î¹ R) :\n    LinearMap.det (Matrix.toLin b b f) = f.det := by\n  rw [â† LinearMap.det_toMatrix b, LinearMap.toMatrix_toLin]\n\n"}
{"name":"LinearMap.det_toLin'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nf : Matrix Î¹ Î¹ R\nâŠ¢ Eq (LinearMap.det (Matrix.toLin' f)) f.det","decl":"@[simp]\ntheorem det_toLin' (f : Matrix Î¹ Î¹ R) : LinearMap.det (Matrix.toLin' f) = Matrix.det f := by\n  simp only [â† toLin_eq_toLin', det_toLin]\n\n"}
{"name":"LinearMap.det_cases","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ³ : AddCommGroup M\nA : Type u_5\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Module A M\ninstâœ : DecidableEq M\nP : A â†’ Prop\nf : LinearMap (RingHom.id A) M M\nhb : âˆ€ (s : Finset M) (b : Basis (Subtype fun x => Membership.mem s x) A M), P ((LinearMap.toMatrix b b) f).det\nh1 : P 1\nâŠ¢ P (LinearMap.det f)","decl":"/-- To show `P (LinearMap.det f)` it suffices to consider `P (Matrix.det (toMatrix _ _ f))` and\n`P 1`. -/\n@[elab_as_elim]\ntheorem det_cases [DecidableEq M] {P : A â†’ Prop} (f : M â†’â‚—[A] M)\n    (hb : âˆ€ (s : Finset M) (b : Basis s A M), P (Matrix.det (toMatrix b b f))) (h1 : P 1) :\n    P (LinearMap.det f) := by\n  rw [LinearMap.det_def]\n  split_ifs with h\n  Â· convert hb _ h.choose_spec.some\n    -- Porting note: was `apply det_aux_def'`\n    convert detAux_def'' (Trunc.mk h.choose_spec.some) h.choose_spec.some f\n  Â· exact h1\n\n"}
{"name":"LinearMap.det_comp","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nf g : LinearMap (RingHom.id A) M M\nâŠ¢ Eq (LinearMap.det (f.comp g)) (HMul.hMul (LinearMap.det f) (LinearMap.det g))","decl":"@[simp]\ntheorem det_comp (f g : M â†’â‚—[A] M) :\n    LinearMap.det (f.comp g) = LinearMap.det f * LinearMap.det g :=\n  LinearMap.det.map_mul f g\n\n"}
{"name":"LinearMap.det_id","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nâŠ¢ Eq (LinearMap.det LinearMap.id) 1","decl":"@[simp]\ntheorem det_id : LinearMap.det (LinearMap.id : M â†’â‚—[A] M) = 1 :=\n  LinearMap.det.map_one\n\n"}
{"name":"LinearMap.det_smul","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ³ : AddCommGroup M\nA : Type u_5\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Module A M\ninstâœ : Module.Free A M\nc : A\nf : LinearMap (RingHom.id A) M M\nâŠ¢ Eq (LinearMap.det (HSMul.hSMul c f)) (HMul.hMul (HPow.hPow c (Module.finrank A M)) (LinearMap.det f))","decl":"/-- Multiplying a map by a scalar `c` multiplies its determinant by `c ^ dim M`. -/\n@[simp]\ntheorem det_smul [Module.Free A M] (c : A) (f : M â†’â‚—[A] M) :\n    LinearMap.det (c â€¢ f) = c ^ Module.finrank A M * LinearMap.det f := by\n  nontriviality A\n  by_cases H : âˆƒ s : Finset M, Nonempty (Basis s A M)\n  Â· have : Module.Finite A M := by\n      rcases H with âŸ¨s, âŸ¨hsâŸ©âŸ©\n      exact Module.Finite.of_basis hs\n    simp only [â† det_toMatrix (Module.finBasis A M), LinearEquiv.map_smul,\n      Fintype.card_fin, Matrix.det_smul]\n  Â· classical\n      have : Module.finrank A M = 0 := finrank_eq_zero_of_not_exists_basis H\n      simp [coe_det, H, this]\n\n"}
{"name":"LinearMap.det_zero'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ´ : AddCommGroup M\nA : Type u_5\ninstâœÂ³ : CommRing A\ninstâœÂ² : Module A M\nÎ¹ : Type u_7\ninstâœÂ¹ : Finite Î¹\ninstâœ : Nonempty Î¹\nb : Basis Î¹ A M\nâŠ¢ Eq (LinearMap.det 0) 0","decl":"theorem det_zero' {Î¹ : Type*} [Finite Î¹] [Nonempty Î¹] (b : Basis Î¹ A M) :\n    LinearMap.det (0 : M â†’â‚—[A] M) = 0 := by\n  haveI := Classical.decEq Î¹\n  cases nonempty_fintype Î¹\n  rwa [â† det_toMatrix b, LinearEquiv.map_zero, det_zero]\n\n"}
{"name":"LinearMap.det_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ³ : AddCommGroup M\nA : Type u_5\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Module A M\ninstâœ : Module.Free A M\nâŠ¢ Eq (LinearMap.det 0) (HPow.hPow 0 (Module.finrank A M))","decl":"/-- In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`,\nand `0` otherwise. We give a formula that also works in infinite dimension, where we define\nthe determinant to be `1`. -/\n@[simp]\ntheorem det_zero [Module.Free A M] :\n    LinearMap.det (0 : M â†’â‚—[A] M) = (0 : A) ^ Module.finrank A M := by\n  simp only [â† zero_smul A (1 : M â†’â‚—[A] M), det_smul, mul_one, MonoidHom.map_one]\n\n"}
{"name":"LinearMap.det_eq_one_of_not_module_finite","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nh : Not (Module.Finite R M)\nf : LinearMap (RingHom.id R) M M\nâŠ¢ Eq (LinearMap.det f) 1","decl":"theorem det_eq_one_of_not_module_finite (h : Â¬Module.Finite R M) (f : M â†’â‚—[R] M) : f.det = 1 := by\n  rw [LinearMap.det, dif_neg, MonoidHom.one_apply]\n  exact fun âŸ¨_, âŸ¨bâŸ©âŸ© â†¦ h (Module.Finite.of_basis b)\n\n"}
{"name":"LinearMap.det_eq_one_of_subsingleton","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nM : Type u_2\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : Subsingleton M\nf : LinearMap (RingHom.id R) M M\nâŠ¢ Eq (LinearMap.det f) 1","decl":"theorem det_eq_one_of_subsingleton [Subsingleton M] (f : M â†’â‚—[R] M) :\n    LinearMap.det (f : M â†’â‚—[R] M) = 1 := by\n  have b : Basis (Fin 0) R M := Basis.empty M\n  rw [â† f.det_toMatrix b]\n  exact Matrix.det_isEmpty\n\n"}
{"name":"LinearMap.det_eq_one_of_finrank_eq_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"ğ•œ : Type u_7\ninstâœÂ² : Field ğ•œ\nM : Type u_8\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module ğ•œ M\nh : Eq (Module.finrank ğ•œ M) 0\nf : LinearMap (RingHom.id ğ•œ) M M\nâŠ¢ Eq (LinearMap.det f) 1","decl":"theorem det_eq_one_of_finrank_eq_zero {ğ•œ : Type*} [Field ğ•œ] {M : Type*} [AddCommGroup M]\n    [Module ğ•œ M] (h : Module.finrank ğ•œ M = 0) (f : M â†’â‚—[ğ•œ] M) :\n    LinearMap.det (f : M â†’â‚—[ğ•œ] M) = 1 := by\n  classical\n    refine @LinearMap.det_cases M _ ğ•œ _ _ _ (fun t => t = 1) f ?_ rfl\n    intro s b\n    have : IsEmpty s := by\n      rw [â† Fintype.card_eq_zero_iff]\n      exact (Module.finrank_eq_card_basis b).symm.trans h\n    exact Matrix.det_isEmpty\n\n"}
{"name":"LinearMap.det_conj","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ´ : AddCommGroup M\nA : Type u_5\ninstâœÂ³ : CommRing A\ninstâœÂ² : Module A M\nN : Type u_7\ninstâœÂ¹ : AddCommGroup N\ninstâœ : Module A N\nf : LinearMap (RingHom.id A) M M\ne : LinearEquiv (RingHom.id A) M N\nâŠ¢ Eq (LinearMap.det ((â†‘e).comp (f.comp â†‘e.symm))) (LinearMap.det f)","decl":"/-- Conjugating a linear map by a linear equiv does not change its determinant. -/\n@[simp]\ntheorem det_conj {N : Type*} [AddCommGroup N] [Module A N] (f : M â†’â‚—[A] M) (e : M â‰ƒâ‚—[A] N) :\n    LinearMap.det ((e : M â†’â‚—[A] N) âˆ˜â‚— f âˆ˜â‚— (e.symm : N â†’â‚—[A] M)) = LinearMap.det f := by\n  classical\n    by_cases H : âˆƒ s : Finset M, Nonempty (Basis s A M)\n    Â· rcases H with âŸ¨s, âŸ¨bâŸ©âŸ©\n      rw [â† det_toMatrix b f, â† det_toMatrix (b.map e), toMatrix_comp (b.map e) b (b.map e),\n        toMatrix_comp (b.map e) b b, â† Matrix.mul_assoc, Matrix.det_conj_of_mul_eq_one]\n      Â· rw [â† toMatrix_comp, LinearEquiv.comp_coe, e.symm_trans_self, LinearEquiv.refl_toLinearMap,\n          toMatrix_id]\n      Â· rw [â† toMatrix_comp, LinearEquiv.comp_coe, e.self_trans_symm, LinearEquiv.refl_toLinearMap,\n          toMatrix_id]\n    Â· have H' : Â¬âˆƒ t : Finset N, Nonempty (Basis t A N) := by\n        contrapose! H\n        rcases H with âŸ¨s, âŸ¨bâŸ©âŸ©\n        exact âŸ¨_, âŸ¨(b.map e.symm).reindexFinsetRangeâŸ©âŸ©\n      simp only [coe_det, H, H', MonoidHom.one_apply, dif_neg, not_false_eq_true]\n\n"}
{"name":"LinearMap.isUnit_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nA : Type u_7\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nf : LinearMap (RingHom.id A) M M\nhf : IsUnit f\nâŠ¢ IsUnit (LinearMap.det f)","decl":"/-- If a linear map is invertible, so is its determinant. -/\ntheorem isUnit_det {A : Type*} [CommRing A] [Module A M] (f : M â†’â‚—[A] M) (hf : IsUnit f) :\n    IsUnit (LinearMap.det f) := by\n  obtain âŸ¨g, hgâŸ© : âˆƒ g, f.comp g = 1 := hf.exists_right_inv\n  have : LinearMap.det f * LinearMap.det g = 1 := by\n    simp only [â† LinearMap.det_comp, hg, MonoidHom.map_one]\n  exact isUnit_of_mul_eq_one _ _ this\n\n"}
{"name":"LinearMap.finiteDimensional_of_det_ne_one","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nğ•œ : Type u_7\ninstâœÂ¹ : Field ğ•œ\ninstâœ : Module ğ•œ M\nf : LinearMap (RingHom.id ğ•œ) M M\nhf : Ne (LinearMap.det f) 1\nâŠ¢ FiniteDimensional ğ•œ M","decl":"/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem finiteDimensional_of_det_ne_one {ğ•œ : Type*} [Field ğ•œ] [Module ğ•œ M] (f : M â†’â‚—[ğ•œ] M)\n    (hf : LinearMap.det f â‰  1) : FiniteDimensional ğ•œ M := by\n  by_cases H : âˆƒ s : Finset M, Nonempty (Basis s ğ•œ M)\n  Â· rcases H with âŸ¨s, âŸ¨hsâŸ©âŸ©\n    exact FiniteDimensional.of_fintype_basis hs\n  Â· classical simp [LinearMap.coe_det, H] at hf\n\n"}
{"name":"LinearMap.range_lt_top_of_det_eq_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nğ•œ : Type u_7\ninstâœÂ¹ : Field ğ•œ\ninstâœ : Module ğ•œ M\nf : LinearMap (RingHom.id ğ•œ) M M\nhf : Eq (LinearMap.det f) 0\nâŠ¢ LT.lt (LinearMap.range f) Top.top","decl":"/-- If the determinant of a map vanishes, then the map is not onto. -/\ntheorem range_lt_top_of_det_eq_zero {ğ•œ : Type*} [Field ğ•œ] [Module ğ•œ M] {f : M â†’â‚—[ğ•œ] M}\n    (hf : LinearMap.det f = 0) : LinearMap.range f < âŠ¤ := by\n  have : FiniteDimensional ğ•œ M := by simp [f.finiteDimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [lt_top_iff_ne_top, Classical.not_not, â† isUnit_iff_range_eq_top] at hf\n  exact isUnit_iff_ne_zero.1 (f.isUnit_det hf)\n\n"}
{"name":"LinearMap.bot_lt_ker_of_det_eq_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nğ•œ : Type u_7\ninstâœÂ¹ : Field ğ•œ\ninstâœ : Module ğ•œ M\nf : LinearMap (RingHom.id ğ•œ) M M\nhf : Eq (LinearMap.det f) 0\nâŠ¢ LT.lt Bot.bot (LinearMap.ker f)","decl":"/-- If the determinant of a map vanishes, then the map is not injective. -/\ntheorem bot_lt_ker_of_det_eq_zero {ğ•œ : Type*} [Field ğ•œ] [Module ğ•œ M] {f : M â†’â‚—[ğ•œ] M}\n    (hf : LinearMap.det f = 0) : âŠ¥ < LinearMap.ker f := by\n  have : FiniteDimensional ğ•œ M := by simp [f.finiteDimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [bot_lt_iff_ne_bot, Classical.not_not, â† isUnit_iff_ker_eq_bot] at hf\n  exact isUnit_iff_ne_zero.1 (f.isUnit_det hf)\n\n"}
{"name":"LinearMap.det_ring","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nf : LinearMap (RingHom.id R) R R\nâŠ¢ Eq (LinearMap.det f) (f 1)","decl":"/-- When the function is over the base ring, the determinant is the evaluation at `1`. -/\n@[simp] lemma det_ring (f : R â†’â‚—[R] R) : f.det = f 1 := by\n  simp [â† det_toMatrix (Basis.singleton Unit R)]\n\n"}
{"name":"LinearMap.det_mulLeft","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœ : CommRing R\na : R\nâŠ¢ Eq (LinearMap.det (LinearMap.mulLeft R a)) a","decl":"lemma det_mulLeft (a : R) : (mulLeft R a).det = a := by simp\n"}
{"name":"LinearMap.det_mulRight","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœ : CommRing R\na : R\nâŠ¢ Eq (LinearMap.det (LinearMap.mulRight R a)) a","decl":"lemma det_mulRight (a : R) : (mulRight R a).det = a := by simp\n\n"}
{"name":"LinearMap.det_pi","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâµ : CommRing R\nM : Type u_2\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\nÎ¹ : Type u_4\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : Module.Free R M\ninstâœ : Module.Finite R M\nf : Î¹ â†’ LinearMap (RingHom.id R) M M\nâŠ¢ Eq (LinearMap.det (LinearMap.pi fun i => (f i).comp (LinearMap.proj i))) (Finset.univ.prod fun i => LinearMap.det (f i))","decl":"omit [DecidableEq Î¹] in\ntheorem det_pi [Module.Free R M] [Module.Finite R M] (f : Î¹ â†’ M â†’â‚—[R] M) :\n    (LinearMap.pi (fun i â†¦ (f i).comp (LinearMap.proj i))).det = âˆ i, (f i).det := by\n  classical\n  let b := Module.Free.chooseBasis R M\n  let B := (Pi.basis (fun _ : Î¹ â†¦ b)).reindex <|\n    (Equiv.sigmaEquivProd _ _).trans (Equiv.prodComm _ _)\n  simp_rw [â† LinearMap.det_toMatrix B, â† LinearMap.det_toMatrix b]\n  have : ((LinearMap.toMatrix B B) (LinearMap.pi fun i â†¦ f i âˆ˜â‚— LinearMap.proj i)) =\n      Matrix.blockDiagonal (fun i â†¦ LinearMap.toMatrix b b (f i)) := by\n    ext âŸ¨iâ‚, iâ‚‚âŸ© âŸ¨jâ‚, jâ‚‚âŸ©\n    unfold B\n    simp_rw [LinearMap.toMatrix_apply', Matrix.blockDiagonal_apply, Basis.coe_reindex,\n      Function.comp_apply, Basis.repr_reindex_apply, Equiv.symm_trans_apply, Equiv.prodComm_symm,\n      Equiv.prodComm_apply, Equiv.sigmaEquivProd_symm_apply, Prod.swap_prod_mk, Pi.basis_apply,\n      Pi.basis_repr, LinearMap.pi_apply, LinearMap.coe_comp, Function.comp_apply,\n      LinearMap.toMatrix_apply', LinearMap.coe_proj, Function.eval, Pi.single_apply]\n    split_ifs with h\n    Â· rw [h]\n    Â· simp only [map_zero, Finsupp.coe_zero, Pi.zero_apply]\n  rw [this, Matrix.det_blockDiagonal]\n\n"}
{"name":"LinearEquiv.coe_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nf : LinearEquiv (RingHom.id R) M M\nâŠ¢ Eq (â†‘(LinearEquiv.det f)) (LinearMap.det â†‘f)","decl":"@[simp]\ntheorem coe_det (f : M â‰ƒâ‚—[R] M) : â†‘(LinearEquiv.det f) = LinearMap.det (f : M â†’â‚—[R] M) :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_inv_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nf : LinearEquiv (RingHom.id R) M M\nâŠ¢ Eq (â†‘(Inv.inv (LinearEquiv.det f))) (LinearMap.det â†‘f.symm)","decl":"@[simp]\ntheorem coe_inv_det (f : M â‰ƒâ‚—[R] M) : â†‘(LinearEquiv.det f)â»Â¹ = LinearMap.det (f.symm : M â†’â‚—[R] M) :=\n  rfl\n\n"}
{"name":"LinearEquiv.det_refl","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ Eq (LinearEquiv.det (LinearEquiv.refl R M)) 1","decl":"@[simp]\ntheorem det_refl : LinearEquiv.det (LinearEquiv.refl R M) = 1 :=\n  Units.ext <| LinearMap.det_id\n\n"}
{"name":"LinearEquiv.det_trans","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nf g : LinearEquiv (RingHom.id R) M M\nâŠ¢ Eq (LinearEquiv.det (f.trans g)) (HMul.hMul (LinearEquiv.det g) (LinearEquiv.det f))","decl":"@[simp]\ntheorem det_trans (f g : M â‰ƒâ‚—[R] M) :\n    LinearEquiv.det (f.trans g) = LinearEquiv.det g * LinearEquiv.det f :=\n  map_mul _ g f\n\n"}
{"name":"LinearEquiv.det_symm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nf : LinearEquiv (RingHom.id R) M M\nâŠ¢ Eq (LinearEquiv.det f.symm) (LinearEquiv.det (Inv.inv f))","decl":"@[simp]\ntheorem det_symm (f : M â‰ƒâ‚—[R] M) : LinearEquiv.det f.symm = LinearEquiv.det fâ»Â¹ :=\n  map_inv _ f\n\n"}
{"name":"LinearEquiv.det_conj","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nM' : Type u_3\ninstâœÂ¹ : AddCommGroup M'\ninstâœ : Module R M'\nf : LinearEquiv (RingHom.id R) M M\ne : LinearEquiv (RingHom.id R) M M'\nâŠ¢ Eq (LinearEquiv.det ((e.symm.trans f).trans e)) (LinearEquiv.det f)","decl":"/-- Conjugating a linear equiv by a linear equiv does not change its determinant. -/\n@[simp]\ntheorem det_conj (f : M â‰ƒâ‚—[R] M) (e : M â‰ƒâ‚—[R] M') :\n    LinearEquiv.det ((e.symm.trans f).trans e) = LinearEquiv.det f := by\n  rw [â† Units.eq_iff, coe_det, coe_det, â† comp_coe, â† comp_coe, LinearMap.det_conj]\n\n"}
{"name":"LinearEquiv.det_mul_det_symm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nf : LinearEquiv (RingHom.id A) M M\nâŠ¢ Eq (HMul.hMul (LinearMap.det â†‘f) (LinearMap.det â†‘f.symm)) 1","decl":"/-- The determinants of a `LinearEquiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem LinearEquiv.det_mul_det_symm {A : Type*} [CommRing A] [Module A M] (f : M â‰ƒâ‚—[A] M) :\n    LinearMap.det (f : M â†’â‚—[A] M) * LinearMap.det (f.symm : M â†’â‚—[A] M) = 1 := by\n  simp [â† LinearMap.det_comp]\n\n"}
{"name":"LinearEquiv.det_symm_mul_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nf : LinearEquiv (RingHom.id A) M M\nâŠ¢ Eq (HMul.hMul (LinearMap.det â†‘f.symm) (LinearMap.det â†‘f)) 1","decl":"/-- The determinants of a `LinearEquiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem LinearEquiv.det_symm_mul_det {A : Type*} [CommRing A] [Module A M] (f : M â‰ƒâ‚—[A] M) :\n    LinearMap.det (f.symm : M â†’â‚—[A] M) * LinearMap.det (f : M â†’â‚—[A] M) = 1 := by\n  simp [â† LinearMap.det_comp]\n\n-- Cannot be stated using `LinearMap.det` because `f` is not an endomorphism.\n"}
{"name":"LinearEquiv.isUnit_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nM' : Type u_3\ninstâœÂ³ : AddCommGroup M'\ninstâœÂ² : Module R M'\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nf : LinearEquiv (RingHom.id R) M M'\nv : Basis Î¹ R M\nv' : Basis Î¹ R M'\nâŠ¢ IsUnit ((LinearMap.toMatrix v v') â†‘f).det","decl":"theorem LinearEquiv.isUnit_det (f : M â‰ƒâ‚—[R] M') (v : Basis Î¹ R M) (v' : Basis Î¹ R M') :\n    IsUnit (LinearMap.toMatrix v v' f).det := by\n  apply isUnit_det_of_left_inverse\n  simpa using (LinearMap.toMatrix_comp v v' v f.symm f).symm\n\n"}
{"name":"LinearEquiv.isUnit_det'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nf : LinearEquiv (RingHom.id A) M M\nâŠ¢ IsUnit (LinearMap.det â†‘f)","decl":"/-- Specialization of `LinearEquiv.isUnit_det` -/\ntheorem LinearEquiv.isUnit_det' {A : Type*} [CommRing A] [Module A M] (f : M â‰ƒâ‚—[A] M) :\n    IsUnit (LinearMap.det (f : M â†’â‚—[A] M)) :=\n  isUnit_of_mul_eq_one _ _ f.det_mul_det_symm\n\n"}
{"name":"LinearEquiv.det_coe_symm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœÂ² : AddCommGroup M\nğ•œ : Type u_5\ninstâœÂ¹ : Field ğ•œ\ninstâœ : Module ğ•œ M\nf : LinearEquiv (RingHom.id ğ•œ) M M\nâŠ¢ Eq (LinearMap.det â†‘f.symm) (Inv.inv (LinearMap.det â†‘f))","decl":"/-- The determinant of `f.symm` is the inverse of that of `f` when `f` is a linear equiv. -/\ntheorem LinearEquiv.det_coe_symm {ğ•œ : Type*} [Field ğ•œ] [Module ğ•œ M] (f : M â‰ƒâ‚—[ğ•œ] M) :\n    LinearMap.det (f.symm : M â†’â‚—[ğ•œ] M) = (LinearMap.det (f : M â†’â‚—[ğ•œ] M))â»Â¹ := by\n  field_simp [IsUnit.ne_zero f.isUnit_det']\n\n"}
{"name":"LinearEquiv.ofIsUnitDet_apply","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nM' : Type u_3\ninstâœÂ³ : AddCommGroup M'\ninstâœÂ² : Module R M'\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nf : LinearMap (RingHom.id R) M M'\nv : Basis Î¹ R M\nv' : Basis Î¹ R M'\nh : IsUnit ((LinearMap.toMatrix v v') f).det\na : M\nâŠ¢ Eq ((LinearEquiv.ofIsUnitDet h) a) (f a)","decl":"/-- Builds a linear equivalence from a linear map whose determinant in some bases is a unit. -/\n@[simps]\ndef LinearEquiv.ofIsUnitDet {f : M â†’â‚—[R] M'} {v : Basis Î¹ R M} {v' : Basis Î¹ R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) : M â‰ƒâ‚—[R] M' where\n  toFun := f\n  map_add' := f.map_add\n  map_smul' := f.map_smul\n  invFun := toLin v' v (toMatrix v v' f)â»Â¹\n  left_inv x :=\n    calc toLin v' v (toMatrix v v' f)â»Â¹ (f x)\n      _ = toLin v v ((toMatrix v v' f)â»Â¹ * toMatrix v v' f) x := by\n        rw [toLin_mul v v' v, toLin_toMatrix, LinearMap.comp_apply]\n      _ = x := by simp [h]\n  right_inv x :=\n    calc f (toLin v' v (toMatrix v v' f)â»Â¹ x)\n      _ = toLin v' v' (toMatrix v v' f * (toMatrix v v' f)â»Â¹) x := by\n        rw [toLin_mul v' v v', LinearMap.comp_apply, toLin_toMatrix v v']\n      _ = x := by simp [h]\n\n"}
{"name":"LinearEquiv.ofIsUnitDet_symm_apply","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nM' : Type u_3\ninstâœÂ³ : AddCommGroup M'\ninstâœÂ² : Module R M'\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nf : LinearMap (RingHom.id R) M M'\nv : Basis Î¹ R M\nv' : Basis Î¹ R M'\nh : IsUnit ((LinearMap.toMatrix v v') f).det\na : M'\nâŠ¢ Eq ((LinearEquiv.ofIsUnitDet h).symm a) (((Matrix.toLin v' v) (Inv.inv ((LinearMap.toMatrix v v') f))) a)","decl":"/-- Builds a linear equivalence from a linear map whose determinant in some bases is a unit. -/\n@[simps]\ndef LinearEquiv.ofIsUnitDet {f : M â†’â‚—[R] M'} {v : Basis Î¹ R M} {v' : Basis Î¹ R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) : M â‰ƒâ‚—[R] M' where\n  toFun := f\n  map_add' := f.map_add\n  map_smul' := f.map_smul\n  invFun := toLin v' v (toMatrix v v' f)â»Â¹\n  left_inv x :=\n    calc toLin v' v (toMatrix v v' f)â»Â¹ (f x)\n      _ = toLin v v ((toMatrix v v' f)â»Â¹ * toMatrix v v' f) x := by\n        rw [toLin_mul v v' v, toLin_toMatrix, LinearMap.comp_apply]\n      _ = x := by simp [h]\n  right_inv x :=\n    calc f (toLin v' v (toMatrix v v' f)â»Â¹ x)\n      _ = toLin v' v' (toMatrix v v' f * (toMatrix v v' f)â»Â¹) x := by\n        rw [toLin_mul v' v v', LinearMap.comp_apply, toLin_toMatrix v v']\n      _ = x := by simp [h]\n\n"}
{"name":"LinearEquiv.coe_ofIsUnitDet","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nM' : Type u_3\ninstâœÂ³ : AddCommGroup M'\ninstâœÂ² : Module R M'\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nf : LinearMap (RingHom.id R) M M'\nv : Basis Î¹ R M\nv' : Basis Î¹ R M'\nh : IsUnit ((LinearMap.toMatrix v v') f).det\nâŠ¢ Eq (â†‘(LinearEquiv.ofIsUnitDet h)) f","decl":"@[simp]\ntheorem LinearEquiv.coe_ofIsUnitDet {f : M â†’â‚—[R] M'} {v : Basis Î¹ R M} {v' : Basis Î¹ R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) :\n    (LinearEquiv.ofIsUnitDet h : M â†’â‚—[R] M') = f := by\n  ext x\n  rfl\n\n"}
{"name":"LinearMap.associated_det_of_eq_comp","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\ne : LinearEquiv (RingHom.id R) M M\nf f' : LinearMap (RingHom.id R) M M\nh : âˆ€ (x : M), Eq (f x) (f' (e x))\nâŠ¢ Associated (LinearMap.det f) (LinearMap.det f')","decl":"theorem LinearMap.associated_det_of_eq_comp (e : M â‰ƒâ‚—[R] M) (f f' : M â†’â‚—[R] M)\n    (h : âˆ€ x, f x = f' (e x)) : Associated (LinearMap.det f) (LinearMap.det f') := by\n  suffices Associated (LinearMap.det (f' âˆ˜â‚— â†‘e)) (LinearMap.det f') by\n    convert this using 2\n    ext x\n    exact h x\n  rw [â† mul_one (LinearMap.det f'), LinearMap.det_comp]\n  exact Associated.mul_left _ (associated_one_iff_isUnit.mpr e.isUnit_det')\n\n"}
{"name":"LinearMap.associated_det_comp_equiv","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nN : Type u_5\ninstâœÂ¹ : AddCommGroup N\ninstâœ : Module R N\nf : LinearMap (RingHom.id R) N M\ne e' : LinearEquiv (RingHom.id R) M N\nâŠ¢ Associated (LinearMap.det (f.comp â†‘e)) (LinearMap.det (f.comp â†‘e'))","decl":"theorem LinearMap.associated_det_comp_equiv {N : Type*} [AddCommGroup N] [Module R N]\n    (f : N â†’â‚—[R] M) (e e' : M â‰ƒâ‚—[R] N) :\n    Associated (LinearMap.det (f âˆ˜â‚— â†‘e)) (LinearMap.det (f âˆ˜â‚— â†‘e')) := by\n  refine LinearMap.associated_det_of_eq_comp (e.trans e'.symm) _ _ ?_\n  intro x\n  simp only [LinearMap.comp_apply, LinearEquiv.coe_coe, LinearEquiv.trans_apply,\n    LinearEquiv.apply_symm_apply]\n\n"}
{"name":"Basis.det_apply","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ne : Basis Î¹ R M\nv : Î¹ â†’ M\nâŠ¢ Eq (e.det v) (e.toMatrix v).det","decl":"theorem Basis.det_apply (v : Î¹ â†’ M) : e.det v = Matrix.det (e.toMatrix v) :=\n  rfl\n\n"}
{"name":"Basis.det_self","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ne : Basis Î¹ R M\nâŠ¢ Eq (e.det â‡‘e) 1","decl":"theorem Basis.det_self : e.det e = 1 := by simp [e.det_apply]\n\n"}
{"name":"Basis.det_isEmpty","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâµ : CommRing R\nM : Type u_2\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\nÎ¹ : Type u_4\ninstâœÂ² : DecidableEq Î¹\ninstâœÂ¹ : Fintype Î¹\ne : Basis Î¹ R M\ninstâœ : IsEmpty Î¹\nâŠ¢ Eq e.det (AlternatingMap.constOfIsEmpty R M Î¹ 1)","decl":"@[simp]\ntheorem Basis.det_isEmpty [IsEmpty Î¹] : e.det = AlternatingMap.constOfIsEmpty R M Î¹ 1 := by\n  ext v\n  exact Matrix.det_isEmpty\n\n"}
{"name":"Basis.det_ne_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâµ : CommRing R\nM : Type u_2\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\nÎ¹ : Type u_4\ninstâœÂ² : DecidableEq Î¹\ninstâœÂ¹ : Fintype Î¹\ne : Basis Î¹ R M\ninstâœ : Nontrivial R\nâŠ¢ Ne e.det 0","decl":"/-- `Basis.det` is not the zero map. -/\ntheorem Basis.det_ne_zero [Nontrivial R] : e.det â‰  0 := fun h => by simpa [h] using e.det_self\n\n"}
{"name":"Basis.smul_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ· : CommRing R\nM : Type u_2\ninstâœâ¶ : AddCommGroup M\ninstâœâµ : Module R M\nÎ¹ : Type u_4\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : Fintype Î¹\ne : Basis Î¹ R M\nG : Type u_5\ninstâœÂ² : Group G\ninstâœÂ¹ : DistribMulAction G M\ninstâœ : SMulCommClass G R M\ng : G\nv : Î¹ â†’ M\nâŠ¢ Eq ((HSMul.hSMul g e).det v) (e.det (HSMul.hSMul (Inv.inv g) v))","decl":"theorem Basis.smul_det {G} [Group G] [DistribMulAction G M] [SMulCommClass G R M]\n    (g : G) (v : Î¹ â†’ M) :\n    (g â€¢ e).det v = e.det (gâ»Â¹ â€¢ v) := by\n  simp_rw [det_apply, toMatrix_smul_left]\n\n"}
{"name":"is_basis_iff_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ne : Basis Î¹ R M\nv : Î¹ â†’ M\nâŠ¢ Iff (And (LinearIndependent R v) (Eq (Submodule.span R (Set.range v)) Top.top)) (IsUnit (e.det v))","decl":"theorem is_basis_iff_det {v : Î¹ â†’ M} :\n    LinearIndependent R v âˆ§ span R (Set.range v) = âŠ¤ â†” IsUnit (e.det v) := by\n  constructor\n  Â· rintro âŸ¨hli, hspanâŸ©\n    set v' := Basis.mk hli hspan.ge\n    rw [e.det_apply]\n    convert LinearEquiv.isUnit_det (LinearEquiv.refl R M) v' e using 2\n    ext i j\n    simp [v']\n  Â· intro h\n    rw [Basis.det_apply, Basis.toMatrix_eq_toMatrix_constr] at h\n    set v' := Basis.map e (LinearEquiv.ofIsUnitDet h) with v'_def\n    have : â‡‘v' = v := by\n      ext i\n      rw [v'_def, Basis.map_apply, LinearEquiv.ofIsUnitDet_apply, e.constr_basis]\n    rw [â† this]\n    exact âŸ¨v'.linearIndependent, v'.span_eqâŸ©\n\n"}
{"name":"Basis.isUnit_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ne e' : Basis Î¹ R M\nâŠ¢ IsUnit (e.det â‡‘e')","decl":"theorem Basis.isUnit_det (e' : Basis Î¹ R M) : IsUnit (e.det e') :=\n  (is_basis_iff_det e).mp âŸ¨e'.linearIndependent, e'.span_eqâŸ©\n\n"}
{"name":"AlternatingMap.eq_smul_basis_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ne : Basis Î¹ R M\nf : AlternatingMap R M R Î¹\nâŠ¢ Eq f (HSMul.hSMul (f â‡‘e) e.det)","decl":"/-- Any alternating map to `R` where `Î¹` has the cardinality of a basis equals the determinant\nmap with respect to that basis, multiplied by the value of that alternating map on that basis. -/\ntheorem AlternatingMap.eq_smul_basis_det (f : M [â‹€^Î¹]â†’â‚—[R] R) : f = f e â€¢ e.det := by\n  refine Basis.ext_alternating e fun i h => ?_\n  let Ïƒ : Equiv.Perm Î¹ := Equiv.ofBijective i (Finite.injective_iff_bijective.1 h)\n  change f (e âˆ˜ Ïƒ) = (f e â€¢ e.det) (e âˆ˜ Ïƒ)\n  simp [AlternatingMap.map_perm, Basis.det_self]\n\n"}
{"name":"AlternatingMap.map_basis_eq_zero_iff","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nM : Type u_2\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\nÎ¹ : Type u_5\ninstâœ : Finite Î¹\ne : Basis Î¹ R M\nf : AlternatingMap R M R Î¹\nâŠ¢ Iff (Eq (f â‡‘e) 0) (Eq f 0)","decl":"@[simp]\ntheorem AlternatingMap.map_basis_eq_zero_iff {Î¹ : Type*} [Finite Î¹] (e : Basis Î¹ R M)\n    (f : M [â‹€^Î¹]â†’â‚—[R] R) : f e = 0 â†” f = 0 :=\n  âŸ¨fun h => by\n    cases nonempty_fintype Î¹\n    letI := Classical.decEq Î¹\n    simpa [h] using f.eq_smul_basis_det e,\n   fun h => h.symm â–¸ AlternatingMap.zero_apply _âŸ©\n\n"}
{"name":"AlternatingMap.map_basis_ne_zero_iff","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nM : Type u_2\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\nÎ¹ : Type u_5\ninstâœ : Finite Î¹\ne : Basis Î¹ R M\nf : AlternatingMap R M R Î¹\nâŠ¢ Iff (Ne (f â‡‘e) 0) (Ne f 0)","decl":"theorem AlternatingMap.map_basis_ne_zero_iff {Î¹ : Type*} [Finite Î¹] (e : Basis Î¹ R M)\n    (f : M [â‹€^Î¹]â†’â‚—[R] R) : f e â‰  0 â†” f â‰  0 :=\n  not_congr <| f.map_basis_eq_zero_iff e\n\n"}
{"name":"Basis.det_comp","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ´ : AddCommGroup M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\ne : Basis Î¹ A M\nf : LinearMap (RingHom.id A) M M\nv : Î¹ â†’ M\nâŠ¢ Eq (e.det (Function.comp (â‡‘f) v)) (HMul.hMul (LinearMap.det f) (e.det v))","decl":"@[simp]\ntheorem Basis.det_comp (e : Basis Î¹ A M) (f : M â†’â‚—[A] M) (v : Î¹ â†’ M) :\n    e.det (f âˆ˜ v) = (LinearMap.det f) * e.det v := by\n  rw [Basis.det_apply, Basis.det_apply, â† f.det_toMatrix e, â† Matrix.det_mul,\n    e.toMatrix_eq_toMatrix_constr (f âˆ˜ v), e.toMatrix_eq_toMatrix_constr v, â† toMatrix_comp,\n    e.constr_comp]\n\n"}
{"name":"Basis.det_comp_basis","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ¶ : AddCommGroup M\nM' : Type u_3\ninstâœâµ : AddCommGroup M'\nÎ¹ : Type u_4\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : Fintype Î¹\nA : Type u_5\ninstâœÂ² : CommRing A\ninstâœÂ¹ : Module A M\ninstâœ : Module A M'\nb : Basis Î¹ A M\nb' : Basis Î¹ A M'\nf : LinearMap (RingHom.id A) M M'\nâŠ¢ Eq (b'.det (Function.comp â‡‘f â‡‘b)) (LinearMap.det (f.comp â†‘(b'.equiv b (Equiv.refl Î¹))))","decl":"@[simp]\ntheorem Basis.det_comp_basis [Module A M'] (b : Basis Î¹ A M) (b' : Basis Î¹ A M') (f : M â†’â‚—[A] M') :\n    b'.det (f âˆ˜ b) = LinearMap.det (f âˆ˜â‚— (b'.equiv b (Equiv.refl Î¹) : M' â†’â‚—[A] M)) := by\n  rw [Basis.det_apply, â† LinearMap.det_toMatrix b', LinearMap.toMatrix_comp _ b, Matrix.det_mul,\n    LinearMap.toMatrix_basis_equiv, Matrix.det_one, mul_one]\n  congr 1; ext i j\n  rw [Basis.toMatrix_apply, LinearMap.toMatrix_apply, Function.comp_apply]\n\n"}
{"name":"Basis.det_basis","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ´ : AddCommGroup M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nb b' : Basis Î¹ A M\nâŠ¢ Eq (LinearMap.det â†‘(b'.equiv b (Equiv.refl Î¹))) (b'.det â‡‘b)","decl":"@[simp]\ntheorem Basis.det_basis (b : Basis Î¹ A M) (b' : Basis Î¹ A M) :\n    LinearMap.det (b'.equiv b (Equiv.refl Î¹)).toLinearMap = b'.det b :=\n  (b.det_comp_basis b' (LinearMap.id)).symm\n\n"}
{"name":"Basis.det_inv","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninstâœâ´ : AddCommGroup M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nA : Type u_5\ninstâœÂ¹ : CommRing A\ninstâœ : Module A M\nb b' : Basis Î¹ A M\nâŠ¢ Eq (â†‘(Inv.inv â‹¯.unit)) (b'.det â‡‘b)","decl":"theorem Basis.det_inv (b : Basis Î¹ A M) (b' : Basis Î¹ A M) :\n    (b.isUnit_det b').unitâ»Â¹ = b'.det b := by\n  rw [â† Units.mul_eq_one_iff_inv_eq, IsUnit.unit_spec, â† Basis.det_basis, â† Basis.det_basis]\n  exact LinearEquiv.det_mul_det_symm _\n\n"}
{"name":"Basis.det_reindex","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nÎ¹' : Type u_6\ninstâœÂ¹ : Fintype Î¹'\ninstâœ : DecidableEq Î¹'\nb : Basis Î¹ R M\nv : Î¹' â†’ M\ne : Equiv Î¹ Î¹'\nâŠ¢ Eq ((b.reindex e).det v) (b.det (Function.comp v â‡‘e))","decl":"theorem Basis.det_reindex {Î¹' : Type*} [Fintype Î¹'] [DecidableEq Î¹'] (b : Basis Î¹ R M) (v : Î¹' â†’ M)\n    (e : Î¹ â‰ƒ Î¹') : (b.reindex e).det v = b.det (v âˆ˜ e) := by\n  rw [Basis.det_apply, Basis.toMatrix_reindex', det_reindexAlgEquiv, Basis.det_apply]\n\n"}
{"name":"Basis.det_reindex'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nÎ¹' : Type u_6\ninstâœÂ¹ : Fintype Î¹'\ninstâœ : DecidableEq Î¹'\nb : Basis Î¹ R M\ne : Equiv Î¹ Î¹'\nâŠ¢ Eq (b.reindex e).det (AlternatingMap.domDomCongr e b.det)","decl":"theorem Basis.det_reindex' {Î¹' : Type*} [Fintype Î¹'] [DecidableEq Î¹'] (b : Basis Î¹ R M)\n    (e : Î¹ â‰ƒ Î¹') : (b.reindex e).det = b.det.domDomCongr e :=\n  AlternatingMap.ext fun _ => Basis.det_reindex _ _ _\n\n"}
{"name":"Basis.det_reindex_symm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nÎ¹ : Type u_4\ninstâœÂ³ : DecidableEq Î¹\ninstâœÂ² : Fintype Î¹\nÎ¹' : Type u_6\ninstâœÂ¹ : Fintype Î¹'\ninstâœ : DecidableEq Î¹'\nb : Basis Î¹ R M\nv : Î¹ â†’ M\ne : Equiv Î¹' Î¹\nâŠ¢ Eq ((b.reindex e.symm).det (Function.comp v â‡‘e)) (b.det v)","decl":"theorem Basis.det_reindex_symm {Î¹' : Type*} [Fintype Î¹'] [DecidableEq Î¹'] (b : Basis Î¹ R M)\n    (v : Î¹ â†’ M) (e : Î¹' â‰ƒ Î¹) : (b.reindex e.symm).det (v âˆ˜ e) = b.det v := by\n  rw [Basis.det_reindex, Function.comp_assoc, e.self_comp_symm, Function.comp_id]\n\n"}
{"name":"Basis.det_map","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nM' : Type u_3\ninstâœÂ³ : AddCommGroup M'\ninstâœÂ² : Module R M'\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nb : Basis Î¹ R M\nf : LinearEquiv (RingHom.id R) M M'\nv : Î¹ â†’ M'\nâŠ¢ Eq ((b.map f).det v) (b.det (Function.comp (â‡‘f.symm) v))","decl":"@[simp]\ntheorem Basis.det_map (b : Basis Î¹ R M) (f : M â‰ƒâ‚—[R] M') (v : Î¹ â†’ M') :\n    (b.map f).det v = b.det (f.symm âˆ˜ v) := by\n  rw [Basis.det_apply, Basis.toMatrix_map, Basis.det_apply]\n\n"}
{"name":"Basis.det_map'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ¶ : CommRing R\nM : Type u_2\ninstâœâµ : AddCommGroup M\ninstâœâ´ : Module R M\nM' : Type u_3\ninstâœÂ³ : AddCommGroup M'\ninstâœÂ² : Module R M'\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nb : Basis Î¹ R M\nf : LinearEquiv (RingHom.id R) M M'\nâŠ¢ Eq (b.map f).det (b.det.compLinearMap â†‘f.symm)","decl":"theorem Basis.det_map' (b : Basis Î¹ R M) (f : M â‰ƒâ‚—[R] M') :\n    (b.map f).det = b.det.compLinearMap f.symm :=\n  AlternatingMap.ext <| b.det_map f\n\n"}
{"name":"Pi.basisFun_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nâŠ¢ Eq (Pi.basisFun R Î¹).det Matrix.detRowAlternating","decl":"@[simp]\ntheorem Pi.basisFun_det : (Pi.basisFun R Î¹).det = Matrix.detRowAlternating := by\n  ext M\n  rw [Basis.det_apply, Basis.coePiBasisFun.toMatrix_eq_transpose, det_transpose]\n\n"}
{"name":"Pi.basisFun_det_apply","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\nv : Î¹ â†’ Î¹ â†’ R\nâŠ¢ Eq ((Pi.basisFun R Î¹).det v) (Matrix.of v).det","decl":"theorem Pi.basisFun_det_apply (v : Î¹ â†’ Î¹ â†’ R) :\n    (Pi.basisFun R Î¹).det v = (Matrix.of v).det := by\n  rw [Pi.basisFun_det]\n  rfl\n\n"}
{"name":"Basis.det_smul_mk_coord_eq_det_update","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ne : Basis Î¹ R M\nv : Î¹ â†’ M\nhli : LinearIndependent R v\nhsp : LE.le Top.top (Submodule.span R (Set.range v))\ni : Î¹\nâŠ¢ Eq (HSMul.hSMul (e.det v) ((Basis.mk hli hsp).coord i)) ((â†‘e.det).toLinearMap v i)","decl":"/-- If we fix a background basis `e`, then for any other basis `v`, we can characterise the\ncoordinates provided by `v` in terms of determinants relative to `e`. -/\ntheorem Basis.det_smul_mk_coord_eq_det_update {v : Î¹ â†’ M} (hli : LinearIndependent R v)\n    (hsp : âŠ¤ â‰¤ span R (range v)) (i : Î¹) :\n    e.det v â€¢ (Basis.mk hli hsp).coord i = e.det.toMultilinearMap.toLinearMap v i := by\n  apply (Basis.mk hli hsp).ext\n  intro k\n  rcases eq_or_ne k i with (rfl | hik) <;>\n    simp only [Algebra.id.smul_eq_mul, Basis.coe_mk, LinearMap.smul_apply, LinearMap.coe_mk,\n      MultilinearMap.toLinearMap_apply]\n  Â· rw [Basis.mk_coord_apply_eq, mul_one, update_eq_self]\n    congr\n  Â· rw [Basis.mk_coord_apply_ne hik, mul_zero, eq_comm]\n    exact e.det.map_eq_zero_of_eq _ (by simp [hik, Function.update_apply]) hik\n\n"}
{"name":"Basis.det_unitsSMul","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ne : Basis Î¹ R M\nw : Î¹ â†’ Units R\nâŠ¢ Eq (e.unitsSMul w).det (HSMul.hSMul (â†‘(Inv.inv (Finset.univ.prod fun i => w i))) e.det)","decl":"/-- If a basis is multiplied columnwise by scalars `w : Î¹ â†’ RË£`, then the determinant with respect\nto this basis is multiplied by the product of the inverse of these scalars. -/\ntheorem Basis.det_unitsSMul (e : Basis Î¹ R M) (w : Î¹ â†’ RË£) :\n    (e.unitsSMul w).det = (â†‘(âˆ i, w i)â»Â¹ : R) â€¢ e.det := by\n  ext f\n  change\n    (Matrix.det fun i j => (e.unitsSMul w).repr (f j) i) =\n      (â†‘(âˆ i, w i)â»Â¹ : R) â€¢ Matrix.det fun i j => e.repr (f j) i\n  simp only [e.repr_unitsSMul]\n  convert Matrix.det_mul_column (fun i => (â†‘(w i)â»Â¹ : R)) fun i j => e.repr (f j) i\n  simp [â† Finset.prod_inv_distrib]\n\n"}
{"name":"Basis.det_unitsSMul_self","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ne : Basis Î¹ R M\nw : Î¹ â†’ Units R\nâŠ¢ Eq (e.det â‡‘(e.unitsSMul w)) (Finset.univ.prod fun i => â†‘(w i))","decl":"/-- The determinant of a basis constructed by `unitsSMul` is the product of the given units. -/\n@[simp]\ntheorem Basis.det_unitsSMul_self (w : Î¹ â†’ RË£) : e.det (e.unitsSMul w) = âˆ i, (w i : R) := by\n  simp [Basis.det_apply]\n\n"}
{"name":"Basis.det_isUnitSMul","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\nÎ¹ : Type u_4\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : Fintype Î¹\ne : Basis Î¹ R M\nw : Î¹ â†’ R\nhw : âˆ€ (i : Î¹), IsUnit (w i)\nâŠ¢ Eq (e.det â‡‘(e.isUnitSMul hw)) (Finset.univ.prod fun i => w i)","decl":"/-- The determinant of a basis constructed by `isUnitSMul` is the product of the given units. -/\n@[simp]\ntheorem Basis.det_isUnitSMul {w : Î¹ â†’ R} (hw : âˆ€ i, IsUnit (w i)) :\n    e.det (e.isUnitSMul hw) = âˆ i, w i :=\n  e.det_unitsSMul_self _\n"}
