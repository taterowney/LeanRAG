{"name":"Matrix.det_comm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"A : Type u_5\ninst✝² : CommRing A\nn : Type u_7\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM N : Matrix n n A\n⊢ Eq (HMul.hMul M N).det (HMul.hMul N M).det","decl":"theorem det_comm [DecidableEq n] (M N : Matrix n n A) : det (M * N) = det (N * M) := by\n  rw [det_mul, det_mul, mul_comm]\n\n"}
{"name":"Matrix.det_comm'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"A : Type u_5\ninst✝⁴ : CommRing A\nm : Type u_6\nn : Type u_7\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nM : Matrix n m A\nN M' : Matrix m n A\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\n⊢ Eq (HMul.hMul M N).det (HMul.hMul N M).det","decl":"/-- If there exists a two-sided inverse `M'` for `M` (indexed differently),\nthen `det (N * M) = det (M * N)`. -/\ntheorem det_comm' [DecidableEq m] [DecidableEq n] {M : Matrix n m A} {N : Matrix m n A}\n    {M' : Matrix m n A} (hMM' : M * M' = 1) (hM'M : M' * M = 1) : det (M * N) = det (N * M) := by\n  nontriviality A\n  -- Although `m` and `n` are different a priori, we will show they have the same cardinality.\n  -- This turns the problem into one for square matrices, which is easy.\n  let e := indexEquivOfInv hMM' hM'M\n  rw [← det_submatrix_equiv_self e, ← submatrix_mul_equiv _ _ _ (Equiv.refl n) _, det_comm,\n    submatrix_mul_equiv, Equiv.coe_refl, submatrix_id_id]\n\n"}
{"name":"Matrix.det_conj_of_mul_eq_one","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"A : Type u_5\ninst✝⁴ : CommRing A\nm : Type u_6\nn : Type u_7\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nM : Matrix m n A\nM' : Matrix n m A\nN : Matrix n n A\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\n⊢ Eq (HMul.hMul (HMul.hMul M N) M').det N.det","decl":"/-- If `M'` is a two-sided inverse for `M` (indexed differently), `det (M * N * M') = det N`.\n\nSee `Matrix.det_conj` and `Matrix.det_conj'` for the case when `M' = M⁻¹` or vice versa. -/\ntheorem det_conj_of_mul_eq_one [DecidableEq m] [DecidableEq n] {M : Matrix m n A}\n    {M' : Matrix n m A} {N : Matrix n n A} (hMM' : M * M' = 1) (hM'M : M' * M = 1) :\n    det (M * N * M') = det N := by\n  rw [← det_comm' hM'M hMM', ← Matrix.mul_assoc, hM'M, Matrix.one_mul]\n\n"}
{"name":"LinearMap.det_toMatrix_eq_det_toMatrix","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁶ : AddCommGroup M\nι : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Fintype ι\nA : Type u_5\ninst✝³ : CommRing A\ninst✝² : Module A M\nκ : Type u_6\ninst✝¹ : Fintype κ\ninst✝ : DecidableEq κ\nb : Basis ι A M\nc : Basis κ A M\nf : LinearMap (RingHom.id A) M M\n⊢ Eq ((LinearMap.toMatrix b b) f).det ((LinearMap.toMatrix c c) f).det","decl":"/-- The determinant of `LinearMap.toMatrix` does not depend on the choice of basis. -/\ntheorem det_toMatrix_eq_det_toMatrix [DecidableEq κ] (b : Basis ι A M) (c : Basis κ A M)\n    (f : M →ₗ[A] M) : det (LinearMap.toMatrix b b f) = det (LinearMap.toMatrix c c f) := by\n  rw [← linearMap_toMatrix_mul_basis_toMatrix c b c, ← basis_toMatrix_mul_linearMap_toMatrix b c b,\n      Matrix.det_conj_of_mul_eq_one] <;>\n    rw [Basis.toMatrix_mul_toMatrix, Basis.toMatrix_self]\n\n\n"}
{"name":"LinearMap.detAux_def","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_7\ninst✝⁴ : AddCommGroup M\nι : Type u_8\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nA : Type u_9\ninst✝¹ : CommRing A\ninst✝ : Module A M\n⊢ Eq LinearMap.detAux (Trunc.lift (fun b => Matrix.detMonoidHom.comp ↑(LinearMap.toMatrixAlgEquiv b)) ⋯)","decl":"/-- The determinant of an endomorphism given a basis.\n\nSee `LinearMap.det` for a version that populates the basis non-computably.\n\nAlthough the `Trunc (Basis ι A M)` parameter makes it slightly more convenient to switch bases,\nthere is no good way to generalize over universe parameters, so we can't fully state in `detAux`'s\ntype that it does not depend on the choice of basis. Instead you can use the `detAux_def''` lemma,\nor avoid mentioning a basis at all using `LinearMap.det`.\n-/\nirreducible_def detAux : Trunc (Basis ι A M) → (M →ₗ[A] M) →* A :=\n  Trunc.lift\n    (fun b : Basis ι A M => detMonoidHom.comp (toMatrixAlgEquiv b : (M →ₗ[A] M) →* Matrix ι ι A))\n    fun b c => MonoidHom.ext <| det_toMatrix_eq_det_toMatrix b c\n\n"}
{"name":"LinearMap.detAux_def'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nb : Basis ι A M\nf : LinearMap (RingHom.id A) M M\n⊢ Eq ((LinearMap.detAux (Trunc.mk b)) f) ((LinearMap.toMatrix b b) f).det","decl":"/-- Unfold lemma for `detAux`.\n\nSee also `detAux_def''` which allows you to vary the basis.\n-/\ntheorem detAux_def' (b : Basis ι A M) (f : M →ₗ[A] M) :\n    LinearMap.detAux (Trunc.mk b) f = Matrix.det (LinearMap.toMatrix b b f) := by\n  rw [detAux]\n  rfl\n\n"}
{"name":"LinearMap.detAux_def''","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁶ : AddCommGroup M\nι : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Fintype ι\nA : Type u_5\ninst✝³ : CommRing A\ninst✝² : Module A M\nι' : Type u_7\ninst✝¹ : Fintype ι'\ninst✝ : DecidableEq ι'\ntb : Trunc (Basis ι A M)\nb' : Basis ι' A M\nf : LinearMap (RingHom.id A) M M\n⊢ Eq ((LinearMap.detAux tb) f) ((LinearMap.toMatrix b' b') f).det","decl":"theorem detAux_def'' {ι' : Type*} [Fintype ι'] [DecidableEq ι'] (tb : Trunc <| Basis ι A M)\n    (b' : Basis ι' A M) (f : M →ₗ[A] M) :\n    LinearMap.detAux tb f = Matrix.det (LinearMap.toMatrix b' b' f) := by\n  induction tb using Trunc.induction_on with\n  | h b => rw [detAux_def', det_toMatrix_eq_det_toMatrix b b']\n\n"}
{"name":"LinearMap.detAux_id","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nb : Trunc (Basis ι A M)\n⊢ Eq ((LinearMap.detAux b) LinearMap.id) 1","decl":"@[simp]\ntheorem detAux_id (b : Trunc <| Basis ι A M) : LinearMap.detAux b LinearMap.id = 1 :=\n  (LinearMap.detAux b).map_one\n\n"}
{"name":"LinearMap.detAux_comp","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nb : Trunc (Basis ι A M)\nf g : LinearMap (RingHom.id A) M M\n⊢ Eq ((LinearMap.detAux b) (f.comp g)) (HMul.hMul ((LinearMap.detAux b) f) ((LinearMap.detAux b) g))","decl":"@[simp]\ntheorem detAux_comp (b : Trunc <| Basis ι A M) (f g : M →ₗ[A] M) :\n    LinearMap.detAux b (f.comp g) = LinearMap.detAux b f * LinearMap.detAux b g :=\n  (LinearMap.detAux b).map_mul f g\n\n"}
{"name":"LinearMap.det_def","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_7\ninst✝² : AddCommGroup M\nA : Type u_8\ninst✝¹ : CommRing A\ninst✝ : Module A M\n⊢ Eq LinearMap.det (dite (Exists fun s => Nonempty (Basis (Subtype fun x => Membership.mem s x) A M)) (fun H => LinearMap.detAux (Trunc.mk ⋯.some)) fun H => 1)","decl":"open scoped Classical in\n-- Discourage the elaborator from unfolding `det` and producing a huge term by marking it\n-- as irreducible.\n/-- The determinant of an endomorphism independent of basis.\n\nIf there is no finite basis on `M`, the result is `1` instead.\n-/\nprotected irreducible_def det : (M →ₗ[A] M) →* A :=\n  if H : ∃ s : Finset M, Nonempty (Basis s A M) then LinearMap.detAux (Trunc.mk H.choose_spec.some)\n  else 1\n\n"}
{"name":"LinearMap.coe_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nA : Type u_5\ninst✝² : CommRing A\ninst✝¹ : Module A M\ninst✝ : DecidableEq M\n⊢ Eq ⇑LinearMap.det ⇑(dite (Exists fun s => Nonempty (Basis (Subtype fun x => Membership.mem s x) A M)) (fun H => LinearMap.detAux (Trunc.mk ⋯.some)) fun H => 1)","decl":"open scoped Classical in\ntheorem coe_det [DecidableEq M] :\n    ⇑(LinearMap.det : (M →ₗ[A] M) →* A) =\n      if H : ∃ s : Finset M, Nonempty (Basis s A M) then\n        LinearMap.detAux (Trunc.mk H.choose_spec.some)\n      else 1 := by\n  ext\n  rw [LinearMap.det_def]\n  split_ifs\n  · congr -- use the correct `DecidableEq` instance\n  rfl\n\n"}
{"name":"LinearMap.det_eq_det_toMatrix_of_finset","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nA : Type u_5\ninst✝² : CommRing A\ninst✝¹ : Module A M\ninst✝ : DecidableEq M\ns : Finset M\nb : Basis (Subtype fun x => Membership.mem s x) A M\nf : LinearMap (RingHom.id A) M M\n⊢ Eq (LinearMap.det f) ((LinearMap.toMatrix b b) f).det","decl":"theorem det_eq_det_toMatrix_of_finset [DecidableEq M] {s : Finset M} (b : Basis s A M)\n    (f : M →ₗ[A] M) : LinearMap.det f = Matrix.det (LinearMap.toMatrix b b f) := by\n  have : ∃ s : Finset M, Nonempty (Basis s A M) := ⟨s, ⟨b⟩⟩\n  rw [LinearMap.coe_det, dif_pos, detAux_def'' _ b] <;> assumption\n\n"}
{"name":"LinearMap.det_toMatrix","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nb : Basis ι A M\nf : LinearMap (RingHom.id A) M M\n⊢ Eq ((LinearMap.toMatrix b b) f).det (LinearMap.det f)","decl":"@[simp]\ntheorem det_toMatrix (b : Basis ι A M) (f : M →ₗ[A] M) :\n    Matrix.det (toMatrix b b f) = LinearMap.det f := by\n  haveI := Classical.decEq M\n  rw [det_eq_det_toMatrix_of_finset b.reindexFinsetRange]\n  -- Porting note: moved out of `rw` due to error\n  -- typeclass instance problem is stuck, it is often due to metavariables `DecidableEq ?m.628881`\n  apply det_toMatrix_eq_det_toMatrix b\n\n"}
{"name":"LinearMap.det_toMatrix'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"A : Type u_5\ninst✝² : CommRing A\nι : Type u_7\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nf : LinearMap (RingHom.id A) (ι → A) (ι → A)\n⊢ Eq (LinearMap.toMatrix' f).det (LinearMap.det f)","decl":"@[simp]\ntheorem det_toMatrix' {ι : Type*} [Fintype ι] [DecidableEq ι] (f : (ι → A) →ₗ[A] ι → A) :\n    Matrix.det (LinearMap.toMatrix' f) = LinearMap.det f := by simp [← toMatrix_eq_toMatrix']\n\n"}
{"name":"LinearMap.det_toLin","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\nf : Matrix ι ι R\n⊢ Eq (LinearMap.det ((Matrix.toLin b b) f)) f.det","decl":"@[simp]\ntheorem det_toLin (b : Basis ι R M) (f : Matrix ι ι R) :\n    LinearMap.det (Matrix.toLin b b f) = f.det := by\n  rw [← LinearMap.det_toMatrix b, LinearMap.toMatrix_toLin]\n\n"}
{"name":"LinearMap.det_toLin'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nf : Matrix ι ι R\n⊢ Eq (LinearMap.det (Matrix.toLin' f)) f.det","decl":"@[simp]\ntheorem det_toLin' (f : Matrix ι ι R) : LinearMap.det (Matrix.toLin' f) = Matrix.det f := by\n  simp only [← toLin_eq_toLin', det_toLin]\n\n"}
{"name":"LinearMap.det_cases","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nA : Type u_5\ninst✝² : CommRing A\ninst✝¹ : Module A M\ninst✝ : DecidableEq M\nP : A → Prop\nf : LinearMap (RingHom.id A) M M\nhb : ∀ (s : Finset M) (b : Basis (Subtype fun x => Membership.mem s x) A M), P ((LinearMap.toMatrix b b) f).det\nh1 : P 1\n⊢ P (LinearMap.det f)","decl":"/-- To show `P (LinearMap.det f)` it suffices to consider `P (Matrix.det (toMatrix _ _ f))` and\n`P 1`. -/\n@[elab_as_elim]\ntheorem det_cases [DecidableEq M] {P : A → Prop} (f : M →ₗ[A] M)\n    (hb : ∀ (s : Finset M) (b : Basis s A M), P (Matrix.det (toMatrix b b f))) (h1 : P 1) :\n    P (LinearMap.det f) := by\n  rw [LinearMap.det_def]\n  split_ifs with h\n  · convert hb _ h.choose_spec.some\n    -- Porting note: was `apply det_aux_def'`\n    convert detAux_def'' (Trunc.mk h.choose_spec.some) h.choose_spec.some f\n  · exact h1\n\n"}
{"name":"LinearMap.det_comp","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nf g : LinearMap (RingHom.id A) M M\n⊢ Eq (LinearMap.det (f.comp g)) (HMul.hMul (LinearMap.det f) (LinearMap.det g))","decl":"@[simp]\ntheorem det_comp (f g : M →ₗ[A] M) :\n    LinearMap.det (f.comp g) = LinearMap.det f * LinearMap.det g :=\n  LinearMap.det.map_mul f g\n\n"}
{"name":"LinearMap.det_id","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\n⊢ Eq (LinearMap.det LinearMap.id) 1","decl":"@[simp]\ntheorem det_id : LinearMap.det (LinearMap.id : M →ₗ[A] M) = 1 :=\n  LinearMap.det.map_one\n\n"}
{"name":"LinearMap.det_smul","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nA : Type u_5\ninst✝² : CommRing A\ninst✝¹ : Module A M\ninst✝ : Module.Free A M\nc : A\nf : LinearMap (RingHom.id A) M M\n⊢ Eq (LinearMap.det (HSMul.hSMul c f)) (HMul.hMul (HPow.hPow c (Module.finrank A M)) (LinearMap.det f))","decl":"/-- Multiplying a map by a scalar `c` multiplies its determinant by `c ^ dim M`. -/\n@[simp]\ntheorem det_smul [Module.Free A M] (c : A) (f : M →ₗ[A] M) :\n    LinearMap.det (c • f) = c ^ Module.finrank A M * LinearMap.det f := by\n  nontriviality A\n  by_cases H : ∃ s : Finset M, Nonempty (Basis s A M)\n  · have : Module.Finite A M := by\n      rcases H with ⟨s, ⟨hs⟩⟩\n      exact Module.Finite.of_basis hs\n    simp only [← det_toMatrix (Module.finBasis A M), LinearEquiv.map_smul,\n      Fintype.card_fin, Matrix.det_smul]\n  · classical\n      have : Module.finrank A M = 0 := finrank_eq_zero_of_not_exists_basis H\n      simp [coe_det, H, this]\n\n"}
{"name":"LinearMap.det_zero'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nA : Type u_5\ninst✝³ : CommRing A\ninst✝² : Module A M\nι : Type u_7\ninst✝¹ : Finite ι\ninst✝ : Nonempty ι\nb : Basis ι A M\n⊢ Eq (LinearMap.det 0) 0","decl":"theorem det_zero' {ι : Type*} [Finite ι] [Nonempty ι] (b : Basis ι A M) :\n    LinearMap.det (0 : M →ₗ[A] M) = 0 := by\n  haveI := Classical.decEq ι\n  cases nonempty_fintype ι\n  rwa [← det_toMatrix b, LinearEquiv.map_zero, det_zero]\n\n"}
{"name":"LinearMap.det_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nA : Type u_5\ninst✝² : CommRing A\ninst✝¹ : Module A M\ninst✝ : Module.Free A M\n⊢ Eq (LinearMap.det 0) (HPow.hPow 0 (Module.finrank A M))","decl":"/-- In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`,\nand `0` otherwise. We give a formula that also works in infinite dimension, where we define\nthe determinant to be `1`. -/\n@[simp]\ntheorem det_zero [Module.Free A M] :\n    LinearMap.det (0 : M →ₗ[A] M) = (0 : A) ^ Module.finrank A M := by\n  simp only [← zero_smul A (1 : M →ₗ[A] M), det_smul, mul_one, MonoidHom.map_one]\n\n"}
{"name":"LinearMap.det_eq_one_of_not_module_finite","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : Not (Module.Finite R M)\nf : LinearMap (RingHom.id R) M M\n⊢ Eq (LinearMap.det f) 1","decl":"theorem det_eq_one_of_not_module_finite (h : ¬Module.Finite R M) (f : M →ₗ[R] M) : f.det = 1 := by\n  rw [LinearMap.det, dif_neg, MonoidHom.one_apply]\n  exact fun ⟨_, ⟨b⟩⟩ ↦ h (Module.Finite.of_basis b)\n\n"}
{"name":"LinearMap.det_eq_one_of_subsingleton","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Subsingleton M\nf : LinearMap (RingHom.id R) M M\n⊢ Eq (LinearMap.det f) 1","decl":"theorem det_eq_one_of_subsingleton [Subsingleton M] (f : M →ₗ[R] M) :\n    LinearMap.det (f : M →ₗ[R] M) = 1 := by\n  have b : Basis (Fin 0) R M := Basis.empty M\n  rw [← f.det_toMatrix b]\n  exact Matrix.det_isEmpty\n\n"}
{"name":"LinearMap.det_eq_one_of_finrank_eq_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"𝕜 : Type u_7\ninst✝² : Field 𝕜\nM : Type u_8\ninst✝¹ : AddCommGroup M\ninst✝ : Module 𝕜 M\nh : Eq (Module.finrank 𝕜 M) 0\nf : LinearMap (RingHom.id 𝕜) M M\n⊢ Eq (LinearMap.det f) 1","decl":"theorem det_eq_one_of_finrank_eq_zero {𝕜 : Type*} [Field 𝕜] {M : Type*} [AddCommGroup M]\n    [Module 𝕜 M] (h : Module.finrank 𝕜 M = 0) (f : M →ₗ[𝕜] M) :\n    LinearMap.det (f : M →ₗ[𝕜] M) = 1 := by\n  classical\n    refine @LinearMap.det_cases M _ 𝕜 _ _ _ (fun t => t = 1) f ?_ rfl\n    intro s b\n    have : IsEmpty s := by\n      rw [← Fintype.card_eq_zero_iff]\n      exact (Module.finrank_eq_card_basis b).symm.trans h\n    exact Matrix.det_isEmpty\n\n"}
{"name":"LinearMap.det_conj","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nA : Type u_5\ninst✝³ : CommRing A\ninst✝² : Module A M\nN : Type u_7\ninst✝¹ : AddCommGroup N\ninst✝ : Module A N\nf : LinearMap (RingHom.id A) M M\ne : LinearEquiv (RingHom.id A) M N\n⊢ Eq (LinearMap.det ((↑e).comp (f.comp ↑e.symm))) (LinearMap.det f)","decl":"/-- Conjugating a linear map by a linear equiv does not change its determinant. -/\n@[simp]\ntheorem det_conj {N : Type*} [AddCommGroup N] [Module A N] (f : M →ₗ[A] M) (e : M ≃ₗ[A] N) :\n    LinearMap.det ((e : M →ₗ[A] N) ∘ₗ f ∘ₗ (e.symm : N →ₗ[A] M)) = LinearMap.det f := by\n  classical\n    by_cases H : ∃ s : Finset M, Nonempty (Basis s A M)\n    · rcases H with ⟨s, ⟨b⟩⟩\n      rw [← det_toMatrix b f, ← det_toMatrix (b.map e), toMatrix_comp (b.map e) b (b.map e),\n        toMatrix_comp (b.map e) b b, ← Matrix.mul_assoc, Matrix.det_conj_of_mul_eq_one]\n      · rw [← toMatrix_comp, LinearEquiv.comp_coe, e.symm_trans_self, LinearEquiv.refl_toLinearMap,\n          toMatrix_id]\n      · rw [← toMatrix_comp, LinearEquiv.comp_coe, e.self_trans_symm, LinearEquiv.refl_toLinearMap,\n          toMatrix_id]\n    · have H' : ¬∃ t : Finset N, Nonempty (Basis t A N) := by\n        contrapose! H\n        rcases H with ⟨s, ⟨b⟩⟩\n        exact ⟨_, ⟨(b.map e.symm).reindexFinsetRange⟩⟩\n      simp only [coe_det, H, H', MonoidHom.one_apply, dif_neg, not_false_eq_true]\n\n"}
{"name":"LinearMap.isUnit_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\nA : Type u_7\ninst✝¹ : CommRing A\ninst✝ : Module A M\nf : LinearMap (RingHom.id A) M M\nhf : IsUnit f\n⊢ IsUnit (LinearMap.det f)","decl":"/-- If a linear map is invertible, so is its determinant. -/\ntheorem isUnit_det {A : Type*} [CommRing A] [Module A M] (f : M →ₗ[A] M) (hf : IsUnit f) :\n    IsUnit (LinearMap.det f) := by\n  obtain ⟨g, hg⟩ : ∃ g, f.comp g = 1 := hf.exists_right_inv\n  have : LinearMap.det f * LinearMap.det g = 1 := by\n    simp only [← LinearMap.det_comp, hg, MonoidHom.map_one]\n  exact isUnit_of_mul_eq_one _ _ this\n\n"}
{"name":"LinearMap.finiteDimensional_of_det_ne_one","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\n𝕜 : Type u_7\ninst✝¹ : Field 𝕜\ninst✝ : Module 𝕜 M\nf : LinearMap (RingHom.id 𝕜) M M\nhf : Ne (LinearMap.det f) 1\n⊢ FiniteDimensional 𝕜 M","decl":"/-- If a linear map has determinant different from `1`, then the space is finite-dimensional. -/\ntheorem finiteDimensional_of_det_ne_one {𝕜 : Type*} [Field 𝕜] [Module 𝕜 M] (f : M →ₗ[𝕜] M)\n    (hf : LinearMap.det f ≠ 1) : FiniteDimensional 𝕜 M := by\n  by_cases H : ∃ s : Finset M, Nonempty (Basis s 𝕜 M)\n  · rcases H with ⟨s, ⟨hs⟩⟩\n    exact FiniteDimensional.of_fintype_basis hs\n  · classical simp [LinearMap.coe_det, H] at hf\n\n"}
{"name":"LinearMap.range_lt_top_of_det_eq_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\n𝕜 : Type u_7\ninst✝¹ : Field 𝕜\ninst✝ : Module 𝕜 M\nf : LinearMap (RingHom.id 𝕜) M M\nhf : Eq (LinearMap.det f) 0\n⊢ LT.lt (LinearMap.range f) Top.top","decl":"/-- If the determinant of a map vanishes, then the map is not onto. -/\ntheorem range_lt_top_of_det_eq_zero {𝕜 : Type*} [Field 𝕜] [Module 𝕜 M] {f : M →ₗ[𝕜] M}\n    (hf : LinearMap.det f = 0) : LinearMap.range f < ⊤ := by\n  have : FiniteDimensional 𝕜 M := by simp [f.finiteDimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [lt_top_iff_ne_top, Classical.not_not, ← isUnit_iff_range_eq_top] at hf\n  exact isUnit_iff_ne_zero.1 (f.isUnit_det hf)\n\n"}
{"name":"LinearMap.bot_lt_ker_of_det_eq_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\n𝕜 : Type u_7\ninst✝¹ : Field 𝕜\ninst✝ : Module 𝕜 M\nf : LinearMap (RingHom.id 𝕜) M M\nhf : Eq (LinearMap.det f) 0\n⊢ LT.lt Bot.bot (LinearMap.ker f)","decl":"/-- If the determinant of a map vanishes, then the map is not injective. -/\ntheorem bot_lt_ker_of_det_eq_zero {𝕜 : Type*} [Field 𝕜] [Module 𝕜 M] {f : M →ₗ[𝕜] M}\n    (hf : LinearMap.det f = 0) : ⊥ < LinearMap.ker f := by\n  have : FiniteDimensional 𝕜 M := by simp [f.finiteDimensional_of_det_ne_one, hf]\n  contrapose hf\n  simp only [bot_lt_iff_ne_bot, Classical.not_not, ← isUnit_iff_ker_eq_bot] at hf\n  exact isUnit_iff_ne_zero.1 (f.isUnit_det hf)\n\n"}
{"name":"LinearMap.det_ring","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : LinearMap (RingHom.id R) R R\n⊢ Eq (LinearMap.det f) (f 1)","decl":"/-- When the function is over the base ring, the determinant is the evaluation at `1`. -/\n@[simp] lemma det_ring (f : R →ₗ[R] R) : f.det = f 1 := by\n  simp [← det_toMatrix (Basis.singleton Unit R)]\n\n"}
{"name":"LinearMap.det_mulLeft","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na : R\n⊢ Eq (LinearMap.det (LinearMap.mulLeft R a)) a","decl":"lemma det_mulLeft (a : R) : (mulLeft R a).det = a := by simp\n"}
{"name":"LinearMap.det_mulRight","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na : R\n⊢ Eq (LinearMap.det (LinearMap.mulRight R a)) a","decl":"lemma det_mulRight (a : R) : (mulRight R a).det = a := by simp\n\n"}
{"name":"LinearMap.det_pi","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nι : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nf : ι → LinearMap (RingHom.id R) M M\n⊢ Eq (LinearMap.det (LinearMap.pi fun i => (f i).comp (LinearMap.proj i))) (Finset.univ.prod fun i => LinearMap.det (f i))","decl":"omit [DecidableEq ι] in\ntheorem det_pi [Module.Free R M] [Module.Finite R M] (f : ι → M →ₗ[R] M) :\n    (LinearMap.pi (fun i ↦ (f i).comp (LinearMap.proj i))).det = ∏ i, (f i).det := by\n  classical\n  let b := Module.Free.chooseBasis R M\n  let B := (Pi.basis (fun _ : ι ↦ b)).reindex <|\n    (Equiv.sigmaEquivProd _ _).trans (Equiv.prodComm _ _)\n  simp_rw [← LinearMap.det_toMatrix B, ← LinearMap.det_toMatrix b]\n  have : ((LinearMap.toMatrix B B) (LinearMap.pi fun i ↦ f i ∘ₗ LinearMap.proj i)) =\n      Matrix.blockDiagonal (fun i ↦ LinearMap.toMatrix b b (f i)) := by\n    ext ⟨i₁, i₂⟩ ⟨j₁, j₂⟩\n    unfold B\n    simp_rw [LinearMap.toMatrix_apply', Matrix.blockDiagonal_apply, Basis.coe_reindex,\n      Function.comp_apply, Basis.repr_reindex_apply, Equiv.symm_trans_apply, Equiv.prodComm_symm,\n      Equiv.prodComm_apply, Equiv.sigmaEquivProd_symm_apply, Prod.swap_prod_mk, Pi.basis_apply,\n      Pi.basis_repr, LinearMap.pi_apply, LinearMap.coe_comp, Function.comp_apply,\n      LinearMap.toMatrix_apply', LinearMap.coe_proj, Function.eval, Pi.single_apply]\n    split_ifs with h\n    · rw [h]\n    · simp only [map_zero, Finsupp.coe_zero, Pi.zero_apply]\n  rw [this, Matrix.det_blockDiagonal]\n\n"}
{"name":"LinearEquiv.coe_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearEquiv (RingHom.id R) M M\n⊢ Eq (↑(LinearEquiv.det f)) (LinearMap.det ↑f)","decl":"@[simp]\ntheorem coe_det (f : M ≃ₗ[R] M) : ↑(LinearEquiv.det f) = LinearMap.det (f : M →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_inv_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearEquiv (RingHom.id R) M M\n⊢ Eq (↑(Inv.inv (LinearEquiv.det f))) (LinearMap.det ↑f.symm)","decl":"@[simp]\ntheorem coe_inv_det (f : M ≃ₗ[R] M) : ↑(LinearEquiv.det f)⁻¹ = LinearMap.det (f.symm : M →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"LinearEquiv.det_refl","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (LinearEquiv.det (LinearEquiv.refl R M)) 1","decl":"@[simp]\ntheorem det_refl : LinearEquiv.det (LinearEquiv.refl R M) = 1 :=\n  Units.ext <| LinearMap.det_id\n\n"}
{"name":"LinearEquiv.det_trans","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf g : LinearEquiv (RingHom.id R) M M\n⊢ Eq (LinearEquiv.det (f.trans g)) (HMul.hMul (LinearEquiv.det g) (LinearEquiv.det f))","decl":"@[simp]\ntheorem det_trans (f g : M ≃ₗ[R] M) :\n    LinearEquiv.det (f.trans g) = LinearEquiv.det g * LinearEquiv.det f :=\n  map_mul _ g f\n\n"}
{"name":"LinearEquiv.det_symm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : LinearEquiv (RingHom.id R) M M\n⊢ Eq (LinearEquiv.det f.symm) (LinearEquiv.det (Inv.inv f))","decl":"@[simp]\ntheorem det_symm (f : M ≃ₗ[R] M) : LinearEquiv.det f.symm = LinearEquiv.det f⁻¹ :=\n  map_inv _ f\n\n"}
{"name":"LinearEquiv.det_conj","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nM' : Type u_3\ninst✝¹ : AddCommGroup M'\ninst✝ : Module R M'\nf : LinearEquiv (RingHom.id R) M M\ne : LinearEquiv (RingHom.id R) M M'\n⊢ Eq (LinearEquiv.det ((e.symm.trans f).trans e)) (LinearEquiv.det f)","decl":"/-- Conjugating a linear equiv by a linear equiv does not change its determinant. -/\n@[simp]\ntheorem det_conj (f : M ≃ₗ[R] M) (e : M ≃ₗ[R] M') :\n    LinearEquiv.det ((e.symm.trans f).trans e) = LinearEquiv.det f := by\n  rw [← Units.eq_iff, coe_det, coe_det, ← comp_coe, ← comp_coe, LinearMap.det_conj]\n\n"}
{"name":"LinearEquiv.det_mul_det_symm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nf : LinearEquiv (RingHom.id A) M M\n⊢ Eq (HMul.hMul (LinearMap.det ↑f) (LinearMap.det ↑f.symm)) 1","decl":"/-- The determinants of a `LinearEquiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem LinearEquiv.det_mul_det_symm {A : Type*} [CommRing A] [Module A M] (f : M ≃ₗ[A] M) :\n    LinearMap.det (f : M →ₗ[A] M) * LinearMap.det (f.symm : M →ₗ[A] M) = 1 := by\n  simp [← LinearMap.det_comp]\n\n"}
{"name":"LinearEquiv.det_symm_mul_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nf : LinearEquiv (RingHom.id A) M M\n⊢ Eq (HMul.hMul (LinearMap.det ↑f.symm) (LinearMap.det ↑f)) 1","decl":"/-- The determinants of a `LinearEquiv` and its inverse multiply to 1. -/\n@[simp]\ntheorem LinearEquiv.det_symm_mul_det {A : Type*} [CommRing A] [Module A M] (f : M ≃ₗ[A] M) :\n    LinearMap.det (f.symm : M →ₗ[A] M) * LinearMap.det (f : M →ₗ[A] M) = 1 := by\n  simp [← LinearMap.det_comp]\n\n-- Cannot be stated using `LinearMap.det` because `f` is not an endomorphism.\n"}
{"name":"LinearEquiv.isUnit_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nM' : Type u_3\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nf : LinearEquiv (RingHom.id R) M M'\nv : Basis ι R M\nv' : Basis ι R M'\n⊢ IsUnit ((LinearMap.toMatrix v v') ↑f).det","decl":"theorem LinearEquiv.isUnit_det (f : M ≃ₗ[R] M') (v : Basis ι R M) (v' : Basis ι R M') :\n    IsUnit (LinearMap.toMatrix v v' f).det := by\n  apply isUnit_det_of_left_inverse\n  simpa using (LinearMap.toMatrix_comp v v' v f.symm f).symm\n\n"}
{"name":"LinearEquiv.isUnit_det'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nf : LinearEquiv (RingHom.id A) M M\n⊢ IsUnit (LinearMap.det ↑f)","decl":"/-- Specialization of `LinearEquiv.isUnit_det` -/\ntheorem LinearEquiv.isUnit_det' {A : Type*} [CommRing A] [Module A M] (f : M ≃ₗ[A] M) :\n    IsUnit (LinearMap.det (f : M →ₗ[A] M)) :=\n  isUnit_of_mul_eq_one _ _ f.det_mul_det_symm\n\n"}
{"name":"LinearEquiv.det_coe_symm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\n𝕜 : Type u_5\ninst✝¹ : Field 𝕜\ninst✝ : Module 𝕜 M\nf : LinearEquiv (RingHom.id 𝕜) M M\n⊢ Eq (LinearMap.det ↑f.symm) (Inv.inv (LinearMap.det ↑f))","decl":"/-- The determinant of `f.symm` is the inverse of that of `f` when `f` is a linear equiv. -/\ntheorem LinearEquiv.det_coe_symm {𝕜 : Type*} [Field 𝕜] [Module 𝕜 M] (f : M ≃ₗ[𝕜] M) :\n    LinearMap.det (f.symm : M →ₗ[𝕜] M) = (LinearMap.det (f : M →ₗ[𝕜] M))⁻¹ := by\n  field_simp [IsUnit.ne_zero f.isUnit_det']\n\n"}
{"name":"LinearEquiv.ofIsUnitDet_apply","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nM' : Type u_3\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nf : LinearMap (RingHom.id R) M M'\nv : Basis ι R M\nv' : Basis ι R M'\nh : IsUnit ((LinearMap.toMatrix v v') f).det\na : M\n⊢ Eq ((LinearEquiv.ofIsUnitDet h) a) (f a)","decl":"/-- Builds a linear equivalence from a linear map whose determinant in some bases is a unit. -/\n@[simps]\ndef LinearEquiv.ofIsUnitDet {f : M →ₗ[R] M'} {v : Basis ι R M} {v' : Basis ι R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) : M ≃ₗ[R] M' where\n  toFun := f\n  map_add' := f.map_add\n  map_smul' := f.map_smul\n  invFun := toLin v' v (toMatrix v v' f)⁻¹\n  left_inv x :=\n    calc toLin v' v (toMatrix v v' f)⁻¹ (f x)\n      _ = toLin v v ((toMatrix v v' f)⁻¹ * toMatrix v v' f) x := by\n        rw [toLin_mul v v' v, toLin_toMatrix, LinearMap.comp_apply]\n      _ = x := by simp [h]\n  right_inv x :=\n    calc f (toLin v' v (toMatrix v v' f)⁻¹ x)\n      _ = toLin v' v' (toMatrix v v' f * (toMatrix v v' f)⁻¹) x := by\n        rw [toLin_mul v' v v', LinearMap.comp_apply, toLin_toMatrix v v']\n      _ = x := by simp [h]\n\n"}
{"name":"LinearEquiv.ofIsUnitDet_symm_apply","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nM' : Type u_3\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nf : LinearMap (RingHom.id R) M M'\nv : Basis ι R M\nv' : Basis ι R M'\nh : IsUnit ((LinearMap.toMatrix v v') f).det\na : M'\n⊢ Eq ((LinearEquiv.ofIsUnitDet h).symm a) (((Matrix.toLin v' v) (Inv.inv ((LinearMap.toMatrix v v') f))) a)","decl":"/-- Builds a linear equivalence from a linear map whose determinant in some bases is a unit. -/\n@[simps]\ndef LinearEquiv.ofIsUnitDet {f : M →ₗ[R] M'} {v : Basis ι R M} {v' : Basis ι R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) : M ≃ₗ[R] M' where\n  toFun := f\n  map_add' := f.map_add\n  map_smul' := f.map_smul\n  invFun := toLin v' v (toMatrix v v' f)⁻¹\n  left_inv x :=\n    calc toLin v' v (toMatrix v v' f)⁻¹ (f x)\n      _ = toLin v v ((toMatrix v v' f)⁻¹ * toMatrix v v' f) x := by\n        rw [toLin_mul v v' v, toLin_toMatrix, LinearMap.comp_apply]\n      _ = x := by simp [h]\n  right_inv x :=\n    calc f (toLin v' v (toMatrix v v' f)⁻¹ x)\n      _ = toLin v' v' (toMatrix v v' f * (toMatrix v v' f)⁻¹) x := by\n        rw [toLin_mul v' v v', LinearMap.comp_apply, toLin_toMatrix v v']\n      _ = x := by simp [h]\n\n"}
{"name":"LinearEquiv.coe_ofIsUnitDet","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nM' : Type u_3\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nf : LinearMap (RingHom.id R) M M'\nv : Basis ι R M\nv' : Basis ι R M'\nh : IsUnit ((LinearMap.toMatrix v v') f).det\n⊢ Eq (↑(LinearEquiv.ofIsUnitDet h)) f","decl":"@[simp]\ntheorem LinearEquiv.coe_ofIsUnitDet {f : M →ₗ[R] M'} {v : Basis ι R M} {v' : Basis ι R M'}\n    (h : IsUnit (LinearMap.toMatrix v v' f).det) :\n    (LinearEquiv.ofIsUnitDet h : M →ₗ[R] M') = f := by\n  ext x\n  rfl\n\n"}
{"name":"LinearMap.associated_det_of_eq_comp","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : LinearEquiv (RingHom.id R) M M\nf f' : LinearMap (RingHom.id R) M M\nh : ∀ (x : M), Eq (f x) (f' (e x))\n⊢ Associated (LinearMap.det f) (LinearMap.det f')","decl":"theorem LinearMap.associated_det_of_eq_comp (e : M ≃ₗ[R] M) (f f' : M →ₗ[R] M)\n    (h : ∀ x, f x = f' (e x)) : Associated (LinearMap.det f) (LinearMap.det f') := by\n  suffices Associated (LinearMap.det (f' ∘ₗ ↑e)) (LinearMap.det f') by\n    convert this using 2\n    ext x\n    exact h x\n  rw [← mul_one (LinearMap.det f'), LinearMap.det_comp]\n  exact Associated.mul_left _ (associated_one_iff_isUnit.mpr e.isUnit_det')\n\n"}
{"name":"LinearMap.associated_det_comp_equiv","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nN : Type u_5\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) N M\ne e' : LinearEquiv (RingHom.id R) M N\n⊢ Associated (LinearMap.det (f.comp ↑e)) (LinearMap.det (f.comp ↑e'))","decl":"theorem LinearMap.associated_det_comp_equiv {N : Type*} [AddCommGroup N] [Module R N]\n    (f : N →ₗ[R] M) (e e' : M ≃ₗ[R] N) :\n    Associated (LinearMap.det (f ∘ₗ ↑e)) (LinearMap.det (f ∘ₗ ↑e')) := by\n  refine LinearMap.associated_det_of_eq_comp (e.trans e'.symm) _ _ ?_\n  intro x\n  simp only [LinearMap.comp_apply, LinearEquiv.coe_coe, LinearEquiv.trans_apply,\n    LinearEquiv.apply_symm_apply]\n\n"}
{"name":"Basis.det_apply","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ne : Basis ι R M\nv : ι → M\n⊢ Eq (e.det v) (e.toMatrix v).det","decl":"theorem Basis.det_apply (v : ι → M) : e.det v = Matrix.det (e.toMatrix v) :=\n  rfl\n\n"}
{"name":"Basis.det_self","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ne : Basis ι R M\n⊢ Eq (e.det ⇑e) 1","decl":"theorem Basis.det_self : e.det e = 1 := by simp [e.det_apply]\n\n"}
{"name":"Basis.det_isEmpty","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nι : Type u_4\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ne : Basis ι R M\ninst✝ : IsEmpty ι\n⊢ Eq e.det (AlternatingMap.constOfIsEmpty R M ι 1)","decl":"@[simp]\ntheorem Basis.det_isEmpty [IsEmpty ι] : e.det = AlternatingMap.constOfIsEmpty R M ι 1 := by\n  ext v\n  exact Matrix.det_isEmpty\n\n"}
{"name":"Basis.det_ne_zero","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nι : Type u_4\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ne : Basis ι R M\ninst✝ : Nontrivial R\n⊢ Ne e.det 0","decl":"/-- `Basis.det` is not the zero map. -/\ntheorem Basis.det_ne_zero [Nontrivial R] : e.det ≠ 0 := fun h => by simpa [h] using e.det_self\n\n"}
{"name":"Basis.smul_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁷ : CommRing R\nM : Type u_2\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nι : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : Fintype ι\ne : Basis ι R M\nG : Type u_5\ninst✝² : Group G\ninst✝¹ : DistribMulAction G M\ninst✝ : SMulCommClass G R M\ng : G\nv : ι → M\n⊢ Eq ((HSMul.hSMul g e).det v) (e.det (HSMul.hSMul (Inv.inv g) v))","decl":"theorem Basis.smul_det {G} [Group G] [DistribMulAction G M] [SMulCommClass G R M]\n    (g : G) (v : ι → M) :\n    (g • e).det v = e.det (g⁻¹ • v) := by\n  simp_rw [det_apply, toMatrix_smul_left]\n\n"}
{"name":"is_basis_iff_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ne : Basis ι R M\nv : ι → M\n⊢ Iff (And (LinearIndependent R v) (Eq (Submodule.span R (Set.range v)) Top.top)) (IsUnit (e.det v))","decl":"theorem is_basis_iff_det {v : ι → M} :\n    LinearIndependent R v ∧ span R (Set.range v) = ⊤ ↔ IsUnit (e.det v) := by\n  constructor\n  · rintro ⟨hli, hspan⟩\n    set v' := Basis.mk hli hspan.ge\n    rw [e.det_apply]\n    convert LinearEquiv.isUnit_det (LinearEquiv.refl R M) v' e using 2\n    ext i j\n    simp [v']\n  · intro h\n    rw [Basis.det_apply, Basis.toMatrix_eq_toMatrix_constr] at h\n    set v' := Basis.map e (LinearEquiv.ofIsUnitDet h) with v'_def\n    have : ⇑v' = v := by\n      ext i\n      rw [v'_def, Basis.map_apply, LinearEquiv.ofIsUnitDet_apply, e.constr_basis]\n    rw [← this]\n    exact ⟨v'.linearIndependent, v'.span_eq⟩\n\n"}
{"name":"Basis.isUnit_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ne e' : Basis ι R M\n⊢ IsUnit (e.det ⇑e')","decl":"theorem Basis.isUnit_det (e' : Basis ι R M) : IsUnit (e.det e') :=\n  (is_basis_iff_det e).mp ⟨e'.linearIndependent, e'.span_eq⟩\n\n"}
{"name":"AlternatingMap.eq_smul_basis_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ne : Basis ι R M\nf : AlternatingMap R M R ι\n⊢ Eq f (HSMul.hSMul (f ⇑e) e.det)","decl":"/-- Any alternating map to `R` where `ι` has the cardinality of a basis equals the determinant\nmap with respect to that basis, multiplied by the value of that alternating map on that basis. -/\ntheorem AlternatingMap.eq_smul_basis_det (f : M [⋀^ι]→ₗ[R] R) : f = f e • e.det := by\n  refine Basis.ext_alternating e fun i h => ?_\n  let σ : Equiv.Perm ι := Equiv.ofBijective i (Finite.injective_iff_bijective.1 h)\n  change f (e ∘ σ) = (f e • e.det) (e ∘ σ)\n  simp [AlternatingMap.map_perm, Basis.det_self]\n\n"}
{"name":"AlternatingMap.map_basis_eq_zero_iff","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_5\ninst✝ : Finite ι\ne : Basis ι R M\nf : AlternatingMap R M R ι\n⊢ Iff (Eq (f ⇑e) 0) (Eq f 0)","decl":"@[simp]\ntheorem AlternatingMap.map_basis_eq_zero_iff {ι : Type*} [Finite ι] (e : Basis ι R M)\n    (f : M [⋀^ι]→ₗ[R] R) : f e = 0 ↔ f = 0 :=\n  ⟨fun h => by\n    cases nonempty_fintype ι\n    letI := Classical.decEq ι\n    simpa [h] using f.eq_smul_basis_det e,\n   fun h => h.symm ▸ AlternatingMap.zero_apply _⟩\n\n"}
{"name":"AlternatingMap.map_basis_ne_zero_iff","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_5\ninst✝ : Finite ι\ne : Basis ι R M\nf : AlternatingMap R M R ι\n⊢ Iff (Ne (f ⇑e) 0) (Ne f 0)","decl":"theorem AlternatingMap.map_basis_ne_zero_iff {ι : Type*} [Finite ι] (e : Basis ι R M)\n    (f : M [⋀^ι]→ₗ[R] R) : f e ≠ 0 ↔ f ≠ 0 :=\n  not_congr <| f.map_basis_eq_zero_iff e\n\n"}
{"name":"Basis.det_comp","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\ne : Basis ι A M\nf : LinearMap (RingHom.id A) M M\nv : ι → M\n⊢ Eq (e.det (Function.comp (⇑f) v)) (HMul.hMul (LinearMap.det f) (e.det v))","decl":"@[simp]\ntheorem Basis.det_comp (e : Basis ι A M) (f : M →ₗ[A] M) (v : ι → M) :\n    e.det (f ∘ v) = (LinearMap.det f) * e.det v := by\n  rw [Basis.det_apply, Basis.det_apply, ← f.det_toMatrix e, ← Matrix.det_mul,\n    e.toMatrix_eq_toMatrix_constr (f ∘ v), e.toMatrix_eq_toMatrix_constr v, ← toMatrix_comp,\n    e.constr_comp]\n\n"}
{"name":"Basis.det_comp_basis","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁶ : AddCommGroup M\nM' : Type u_3\ninst✝⁵ : AddCommGroup M'\nι : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : Fintype ι\nA : Type u_5\ninst✝² : CommRing A\ninst✝¹ : Module A M\ninst✝ : Module A M'\nb : Basis ι A M\nb' : Basis ι A M'\nf : LinearMap (RingHom.id A) M M'\n⊢ Eq (b'.det (Function.comp ⇑f ⇑b)) (LinearMap.det (f.comp ↑(b'.equiv b (Equiv.refl ι))))","decl":"@[simp]\ntheorem Basis.det_comp_basis [Module A M'] (b : Basis ι A M) (b' : Basis ι A M') (f : M →ₗ[A] M') :\n    b'.det (f ∘ b) = LinearMap.det (f ∘ₗ (b'.equiv b (Equiv.refl ι) : M' →ₗ[A] M)) := by\n  rw [Basis.det_apply, ← LinearMap.det_toMatrix b', LinearMap.toMatrix_comp _ b, Matrix.det_mul,\n    LinearMap.toMatrix_basis_equiv, Matrix.det_one, mul_one]\n  congr 1; ext i j\n  rw [Basis.toMatrix_apply, LinearMap.toMatrix_apply, Function.comp_apply]\n\n"}
{"name":"Basis.det_basis","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nb b' : Basis ι A M\n⊢ Eq (LinearMap.det ↑(b'.equiv b (Equiv.refl ι))) (b'.det ⇑b)","decl":"@[simp]\ntheorem Basis.det_basis (b : Basis ι A M) (b' : Basis ι A M) :\n    LinearMap.det (b'.equiv b (Equiv.refl ι)).toLinearMap = b'.det b :=\n  (b.det_comp_basis b' (LinearMap.id)).symm\n\n"}
{"name":"Basis.det_inv","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nA : Type u_5\ninst✝¹ : CommRing A\ninst✝ : Module A M\nb b' : Basis ι A M\n⊢ Eq (↑(Inv.inv ⋯.unit)) (b'.det ⇑b)","decl":"theorem Basis.det_inv (b : Basis ι A M) (b' : Basis ι A M) :\n    (b.isUnit_det b').unit⁻¹ = b'.det b := by\n  rw [← Units.mul_eq_one_iff_inv_eq, IsUnit.unit_spec, ← Basis.det_basis, ← Basis.det_basis]\n  exact LinearEquiv.det_mul_det_symm _\n\n"}
{"name":"Basis.det_reindex","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nι' : Type u_6\ninst✝¹ : Fintype ι'\ninst✝ : DecidableEq ι'\nb : Basis ι R M\nv : ι' → M\ne : Equiv ι ι'\n⊢ Eq ((b.reindex e).det v) (b.det (Function.comp v ⇑e))","decl":"theorem Basis.det_reindex {ι' : Type*} [Fintype ι'] [DecidableEq ι'] (b : Basis ι R M) (v : ι' → M)\n    (e : ι ≃ ι') : (b.reindex e).det v = b.det (v ∘ e) := by\n  rw [Basis.det_apply, Basis.toMatrix_reindex', det_reindexAlgEquiv, Basis.det_apply]\n\n"}
{"name":"Basis.det_reindex'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nι' : Type u_6\ninst✝¹ : Fintype ι'\ninst✝ : DecidableEq ι'\nb : Basis ι R M\ne : Equiv ι ι'\n⊢ Eq (b.reindex e).det (AlternatingMap.domDomCongr e b.det)","decl":"theorem Basis.det_reindex' {ι' : Type*} [Fintype ι'] [DecidableEq ι'] (b : Basis ι R M)\n    (e : ι ≃ ι') : (b.reindex e).det = b.det.domDomCongr e :=\n  AlternatingMap.ext fun _ => Basis.det_reindex _ _ _\n\n"}
{"name":"Basis.det_reindex_symm","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nι : Type u_4\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nι' : Type u_6\ninst✝¹ : Fintype ι'\ninst✝ : DecidableEq ι'\nb : Basis ι R M\nv : ι → M\ne : Equiv ι' ι\n⊢ Eq ((b.reindex e.symm).det (Function.comp v ⇑e)) (b.det v)","decl":"theorem Basis.det_reindex_symm {ι' : Type*} [Fintype ι'] [DecidableEq ι'] (b : Basis ι R M)\n    (v : ι → M) (e : ι' ≃ ι) : (b.reindex e.symm).det (v ∘ e) = b.det v := by\n  rw [Basis.det_reindex, Function.comp_assoc, e.self_comp_symm, Function.comp_id]\n\n"}
{"name":"Basis.det_map","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nM' : Type u_3\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\nf : LinearEquiv (RingHom.id R) M M'\nv : ι → M'\n⊢ Eq ((b.map f).det v) (b.det (Function.comp (⇑f.symm) v))","decl":"@[simp]\ntheorem Basis.det_map (b : Basis ι R M) (f : M ≃ₗ[R] M') (v : ι → M') :\n    (b.map f).det v = b.det (f.symm ∘ v) := by\n  rw [Basis.det_apply, Basis.toMatrix_map, Basis.det_apply]\n\n"}
{"name":"Basis.det_map'","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM : Type u_2\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nM' : Type u_3\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\nf : LinearEquiv (RingHom.id R) M M'\n⊢ Eq (b.map f).det (b.det.compLinearMap ↑f.symm)","decl":"theorem Basis.det_map' (b : Basis ι R M) (f : M ≃ₗ[R] M') :\n    (b.map f).det = b.det.compLinearMap f.symm :=\n  AlternatingMap.ext <| b.det_map f\n\n"}
{"name":"Pi.basisFun_det","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\n⊢ Eq (Pi.basisFun R ι).det Matrix.detRowAlternating","decl":"@[simp]\ntheorem Pi.basisFun_det : (Pi.basisFun R ι).det = Matrix.detRowAlternating := by\n  ext M\n  rw [Basis.det_apply, Basis.coePiBasisFun.toMatrix_eq_transpose, det_transpose]\n\n"}
{"name":"Pi.basisFun_det_apply","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nv : ι → ι → R\n⊢ Eq ((Pi.basisFun R ι).det v) (Matrix.of v).det","decl":"theorem Pi.basisFun_det_apply (v : ι → ι → R) :\n    (Pi.basisFun R ι).det v = (Matrix.of v).det := by\n  rw [Pi.basisFun_det]\n  rfl\n\n"}
{"name":"Basis.det_smul_mk_coord_eq_det_update","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ne : Basis ι R M\nv : ι → M\nhli : LinearIndependent R v\nhsp : LE.le Top.top (Submodule.span R (Set.range v))\ni : ι\n⊢ Eq (HSMul.hSMul (e.det v) ((Basis.mk hli hsp).coord i)) ((↑e.det).toLinearMap v i)","decl":"/-- If we fix a background basis `e`, then for any other basis `v`, we can characterise the\ncoordinates provided by `v` in terms of determinants relative to `e`. -/\ntheorem Basis.det_smul_mk_coord_eq_det_update {v : ι → M} (hli : LinearIndependent R v)\n    (hsp : ⊤ ≤ span R (range v)) (i : ι) :\n    e.det v • (Basis.mk hli hsp).coord i = e.det.toMultilinearMap.toLinearMap v i := by\n  apply (Basis.mk hli hsp).ext\n  intro k\n  rcases eq_or_ne k i with (rfl | hik) <;>\n    simp only [Algebra.id.smul_eq_mul, Basis.coe_mk, LinearMap.smul_apply, LinearMap.coe_mk,\n      MultilinearMap.toLinearMap_apply]\n  · rw [Basis.mk_coord_apply_eq, mul_one, update_eq_self]\n    congr\n  · rw [Basis.mk_coord_apply_ne hik, mul_zero, eq_comm]\n    exact e.det.map_eq_zero_of_eq _ (by simp [hik, Function.update_apply]) hik\n\n"}
{"name":"Basis.det_unitsSMul","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ne : Basis ι R M\nw : ι → Units R\n⊢ Eq (e.unitsSMul w).det (HSMul.hSMul (↑(Inv.inv (Finset.univ.prod fun i => w i))) e.det)","decl":"/-- If a basis is multiplied columnwise by scalars `w : ι → Rˣ`, then the determinant with respect\nto this basis is multiplied by the product of the inverse of these scalars. -/\ntheorem Basis.det_unitsSMul (e : Basis ι R M) (w : ι → Rˣ) :\n    (e.unitsSMul w).det = (↑(∏ i, w i)⁻¹ : R) • e.det := by\n  ext f\n  change\n    (Matrix.det fun i j => (e.unitsSMul w).repr (f j) i) =\n      (↑(∏ i, w i)⁻¹ : R) • Matrix.det fun i j => e.repr (f j) i\n  simp only [e.repr_unitsSMul]\n  convert Matrix.det_mul_column (fun i => (↑(w i)⁻¹ : R)) fun i j => e.repr (f j) i\n  simp [← Finset.prod_inv_distrib]\n\n"}
{"name":"Basis.det_unitsSMul_self","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ne : Basis ι R M\nw : ι → Units R\n⊢ Eq (e.det ⇑(e.unitsSMul w)) (Finset.univ.prod fun i => ↑(w i))","decl":"/-- The determinant of a basis constructed by `unitsSMul` is the product of the given units. -/\n@[simp]\ntheorem Basis.det_unitsSMul_self (w : ι → Rˣ) : e.det (e.unitsSMul w) = ∏ i, (w i : R) := by\n  simp [Basis.det_apply]\n\n"}
{"name":"Basis.det_isUnitSMul","module":"Mathlib.LinearAlgebra.Determinant","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ne : Basis ι R M\nw : ι → R\nhw : ∀ (i : ι), IsUnit (w i)\n⊢ Eq (e.det ⇑(e.isUnitSMul hw)) (Finset.univ.prod fun i => w i)","decl":"/-- The determinant of a basis constructed by `isUnitSMul` is the product of the given units. -/\n@[simp]\ntheorem Basis.det_isUnitSMul {w : ι → R} (hw : ∀ i, IsUnit (w i)) :\n    e.det (e.isUnitSMul hw) = ∏ i, w i :=\n  e.det_unitsSMul_self _\n"}
