{"name":"SimpleGraph.Walk.isTrail_def","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Iff p.IsTrail p.edges.Nodup","decl":"/-- A *trail* is a walk with no repeating edges. -/\n@[mk_iff isTrail_def]\nstructure IsTrail {u v : V} (p : G.Walk u v) : Prop where\n  edges_nodup : p.edges.Nodup\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.edges_nodup","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nself : p.IsTrail\n⊢ p.edges.Nodup","decl":"/-- A *trail* is a walk with no repeating edges. -/\n@[mk_iff isTrail_def]\nstructure IsTrail {u v : V} (p : G.Walk u v) : Prop where\n  edges_nodup : p.edges.Nodup\n\n"}
{"name":"SimpleGraph.Walk.IsPath.support_nodup","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nself : p.IsPath\n⊢ p.support.Nodup","decl":"/-- A *path* is a walk with no repeating vertices.\nUse `SimpleGraph.Walk.IsPath.mk'` for a simpler constructor. -/\nstructure IsPath {u v : V} (p : G.Walk u v) extends IsTrail p : Prop where\n  support_nodup : p.support.Nodup\n\n-- Porting note: used to use `extends to_trail : is_trail p` in structure\n"}
{"name":"SimpleGraph.Walk.IsPath.toIsTrail","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nself : p.IsPath\n⊢ p.IsTrail","decl":"/-- A *path* is a walk with no repeating vertices.\nUse `SimpleGraph.Walk.IsPath.mk'` for a simpler constructor. -/\nstructure IsPath {u v : V} (p : G.Walk u v) extends IsTrail p : Prop where\n  support_nodup : p.support.Nodup\n\n-- Porting note: used to use `extends to_trail : is_trail p` in structure\n"}
{"name":"SimpleGraph.Walk.IsPath.isTrail","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : p.IsPath\n⊢ p.IsTrail","decl":"protected lemma IsPath.isTrail {p : Walk G u v} (h : IsPath p) : IsTrail p := h.toIsTrail\n\n"}
{"name":"SimpleGraph.Walk.IsCircuit.ne_nil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nself : p.IsCircuit\n⊢ Ne p SimpleGraph.Walk.nil","decl":"/-- A *circuit* at `u : V` is a nonempty trail beginning and ending at `u`. -/\n@[mk_iff isCircuit_def]\nstructure IsCircuit {u : V} (p : G.Walk u u) extends IsTrail p : Prop where\n  ne_nil : p ≠ nil\n\n-- Porting note: used to use `extends to_trail : is_trail p` in structure\n"}
{"name":"SimpleGraph.Walk.IsCircuit.toIsTrail","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nself : p.IsCircuit\n⊢ p.IsTrail","decl":"/-- A *circuit* at `u : V` is a nonempty trail beginning and ending at `u`. -/\n@[mk_iff isCircuit_def]\nstructure IsCircuit {u : V} (p : G.Walk u u) extends IsTrail p : Prop where\n  ne_nil : p ≠ nil\n\n-- Porting note: used to use `extends to_trail : is_trail p` in structure\n"}
{"name":"SimpleGraph.Walk.isCircuit_def","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\n⊢ Iff p.IsCircuit (And p.IsTrail (Ne p SimpleGraph.Walk.nil))","decl":"/-- A *circuit* at `u : V` is a nonempty trail beginning and ending at `u`. -/\n@[mk_iff isCircuit_def]\nstructure IsCircuit {u : V} (p : G.Walk u u) extends IsTrail p : Prop where\n  ne_nil : p ≠ nil\n\n-- Porting note: used to use `extends to_trail : is_trail p` in structure\n"}
{"name":"SimpleGraph.Walk.IsCircuit.isTrail","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nh : p.IsCircuit\n⊢ p.IsTrail","decl":"protected lemma IsCircuit.isTrail {p : Walk G u u} (h : IsCircuit p) : IsTrail p := h.toIsTrail\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.support_nodup","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nself : p.IsCycle\n⊢ p.support.tail.Nodup","decl":"/-- A *cycle* at `u : V` is a circuit at `u` whose only repeating vertex\nis `u` (which appears exactly twice). -/\nstructure IsCycle {u : V} (p : G.Walk u u) extends IsCircuit p : Prop where\n  support_nodup : p.support.tail.Nodup\n\n-- Porting note: used to use `extends to_circuit : is_circuit p` in structure\n"}
{"name":"SimpleGraph.Walk.IsCycle.toIsCircuit","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nself : p.IsCycle\n⊢ p.IsCircuit","decl":"/-- A *cycle* at `u : V` is a circuit at `u` whose only repeating vertex\nis `u` (which appears exactly twice). -/\nstructure IsCycle {u : V} (p : G.Walk u u) extends IsCircuit p : Prop where\n  support_nodup : p.support.tail.Nodup\n\n-- Porting note: used to use `extends to_circuit : is_circuit p` in structure\n"}
{"name":"SimpleGraph.Walk.IsCycle.isCircuit","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nh : p.IsCycle\n⊢ p.IsCircuit","decl":"protected lemma IsCycle.isCircuit {p : Walk G u u} (h : IsCycle p) : IsCircuit p := h.toIsCircuit\n\n"}
{"name":"SimpleGraph.Walk.isTrail_copy","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\n⊢ Iff (p.copy hu hv).IsTrail p.IsTrail","decl":"@[simp]\ntheorem isTrail_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).IsTrail ↔ p.IsTrail := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.IsPath.mk'","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : p.support.Nodup\n⊢ p.IsPath","decl":"theorem IsPath.mk' {u v : V} {p : G.Walk u v} (h : p.support.Nodup) : p.IsPath :=\n  ⟨⟨edges_nodup_of_support_nodup h⟩, h⟩\n\n"}
{"name":"SimpleGraph.Walk.isPath_def","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Iff p.IsPath p.support.Nodup","decl":"theorem isPath_def {u v : V} (p : G.Walk u v) : p.IsPath ↔ p.support.Nodup :=\n  ⟨IsPath.support_nodup, IsPath.mk'⟩\n\n"}
{"name":"SimpleGraph.Walk.isPath_copy","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v u' v' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\n⊢ Iff (p.copy hu hv).IsPath p.IsPath","decl":"@[simp]\ntheorem isPath_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).IsPath ↔ p.IsPath := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.isCircuit_copy","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu u' : V\np : G.Walk u u\nhu : Eq u u'\n⊢ Iff (p.copy hu hu).IsCircuit p.IsCircuit","decl":"@[simp]\ntheorem isCircuit_copy {u u'} (p : G.Walk u u) (hu : u = u') :\n    (p.copy hu hu).IsCircuit ↔ p.IsCircuit := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.IsCircuit.not_nil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\np : G.Walk v v\nhp : p.IsCircuit\n⊢ Not p.Nil","decl":"lemma IsCircuit.not_nil {p : G.Walk v v} (hp : IsCircuit p) : ¬ p.Nil := (hp.ne_nil ·.eq_nil)\n\n"}
{"name":"SimpleGraph.Walk.isCycle_def","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\n⊢ Iff p.IsCycle (And p.IsTrail (And (Ne p SimpleGraph.Walk.nil) p.support.tail.Nodup))","decl":"theorem isCycle_def {u : V} (p : G.Walk u u) :\n    p.IsCycle ↔ p.IsTrail ∧ p ≠ nil ∧ p.support.tail.Nodup :=\n  Iff.intro (fun h => ⟨h.1.1, h.1.2, h.2⟩) fun h => ⟨⟨h.1, h.2.1⟩, h.2.2⟩\n\n"}
{"name":"SimpleGraph.Walk.isCycle_copy","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu u' : V\np : G.Walk u u\nhu : Eq u u'\n⊢ Iff (p.copy hu hu).IsCycle p.IsCycle","decl":"@[simp]\ntheorem isCycle_copy {u u'} (p : G.Walk u u) (hu : u = u') :\n    (p.copy hu hu).IsCycle ↔ p.IsCycle := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.not_nil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\np : G.Walk v v\nhp : p.IsCycle\n⊢ Not p.Nil","decl":"lemma IsCycle.not_nil {p : G.Walk v v} (hp : IsCycle p) : ¬ p.Nil := (hp.ne_nil ·.eq_nil)\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.nil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ SimpleGraph.Walk.nil.IsTrail","decl":"@[simp]\ntheorem IsTrail.nil {u : V} : (nil : G.Walk u u).IsTrail :=\n  ⟨by simp [edges]⟩\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.of_cons","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\na✝ : (SimpleGraph.Walk.cons h p).IsTrail\n⊢ p.IsTrail","decl":"theorem IsTrail.of_cons {u v w : V} {h : G.Adj u v} {p : G.Walk v w} :\n    (cons h p).IsTrail → p.IsTrail := by simp [isTrail_def]\n\n"}
{"name":"SimpleGraph.Walk.cons_isTrail_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Iff (SimpleGraph.Walk.cons h p).IsTrail (And p.IsTrail (Not (Membership.mem p.edges (Sym2.mk { fst := u, snd := v }))))","decl":"@[simp]\ntheorem cons_isTrail_iff {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).IsTrail ↔ p.IsTrail ∧ s(u, v) ∉ p.edges := by simp [isTrail_def, and_comm]\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.reverse","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : p.IsTrail\n⊢ p.reverse.IsTrail","decl":"theorem IsTrail.reverse {u v : V} (p : G.Walk u v) (h : p.IsTrail) : p.reverse.IsTrail := by\n  simpa [isTrail_def] using h\n\n"}
{"name":"SimpleGraph.Walk.reverse_isTrail_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Iff p.reverse.IsTrail p.IsTrail","decl":"@[simp]\ntheorem reverse_isTrail_iff {u v : V} (p : G.Walk u v) : p.reverse.IsTrail ↔ p.IsTrail := by\n  constructor <;>\n    · intro h\n      convert h.reverse _\n      try rw [reverse_reverse]\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.of_append_left","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\nh : (p.append q).IsTrail\n⊢ p.IsTrail","decl":"theorem IsTrail.of_append_left {u v w : V} {p : G.Walk u v} {q : G.Walk v w}\n    (h : (p.append q).IsTrail) : p.IsTrail := by\n  rw [isTrail_def, edges_append, List.nodup_append] at h\n  exact ⟨h.1⟩\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.of_append_right","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\nh : (p.append q).IsTrail\n⊢ q.IsTrail","decl":"theorem IsTrail.of_append_right {u v w : V} {p : G.Walk u v} {q : G.Walk v w}\n    (h : (p.append q).IsTrail) : q.IsTrail := by\n  rw [isTrail_def, edges_append, List.nodup_append] at h\n  exact ⟨h.2.1⟩\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.count_edges_le_one","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\nh : p.IsTrail\ne : Sym2 V\n⊢ LE.le (List.count e p.edges) 1","decl":"theorem IsTrail.count_edges_le_one [DecidableEq V] {u v : V} {p : G.Walk u v} (h : p.IsTrail)\n    (e : Sym2 V) : p.edges.count e ≤ 1 :=\n  List.nodup_iff_count_le_one.mp h.edges_nodup e\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.count_edges_eq_one","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\nh : p.IsTrail\ne : Sym2 V\nhe : Membership.mem p.edges e\n⊢ Eq (List.count e p.edges) 1","decl":"theorem IsTrail.count_edges_eq_one [DecidableEq V] {u v : V} {p : G.Walk u v} (h : p.IsTrail)\n    {e : Sym2 V} (he : e ∈ p.edges) : p.edges.count e = 1 :=\n  List.count_eq_one_of_mem h.edges_nodup he\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.length_le_card_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Fintype ↑G.edgeSet\nu v : V\nw : G.Walk u v\nh : w.IsTrail\n⊢ LE.le w.length G.edgeFinset.card","decl":"theorem IsTrail.length_le_card_edgeFinset [Fintype G.edgeSet] {u v : V}\n    {w : G.Walk u v} (h : w.IsTrail) : w.length ≤ G.edgeFinset.card := by\n  classical\n  let edges := w.edges.toFinset\n  have : edges.card = w.length := length_edges _ ▸ List.toFinset_card_of_nodup h.edges_nodup\n  rw [← this]\n  have : edges ⊆ G.edgeFinset := by\n    intro e h\n    refine mem_edgeFinset.mpr ?_\n    apply w.edges_subset_edgeSet\n    simpa [edges] using h\n  exact Finset.card_le_card this\n\n"}
{"name":"SimpleGraph.Walk.IsPath.nil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ SimpleGraph.Walk.nil.IsPath","decl":"theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath := by constructor <;> simp\n\n"}
{"name":"SimpleGraph.Walk.IsPath.of_cons","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\na✝ : (SimpleGraph.Walk.cons h p).IsPath\n⊢ p.IsPath","decl":"theorem IsPath.of_cons {u v w : V} {h : G.Adj u v} {p : G.Walk v w} :\n    (cons h p).IsPath → p.IsPath := by simp [isPath_def]\n\n"}
{"name":"SimpleGraph.Walk.cons_isPath_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nh : G.Adj u v\np : G.Walk v w\n⊢ Iff (SimpleGraph.Walk.cons h p).IsPath (And p.IsPath (Not (Membership.mem p.support u)))","decl":"@[simp]\ntheorem cons_isPath_iff {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).IsPath ↔ p.IsPath ∧ u ∉ p.support := by\n  constructor <;> simp +contextual [isPath_def]\n\n"}
{"name":"SimpleGraph.Walk.IsPath.cons","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk v w\nhp : p.IsPath\nhu : Not (Membership.mem p.support u)\nh : G.Adj u v\n⊢ (SimpleGraph.Walk.cons h p).IsPath","decl":"protected lemma IsPath.cons {p : Walk G v w} (hp : p.IsPath) (hu : u ∉ p.support) {h : G.Adj u v} :\n    (cons h p).IsPath :=\n  (cons_isPath_iff _ _).2 ⟨hp, hu⟩\n\n"}
{"name":"SimpleGraph.Walk.isPath_iff_eq_nil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\n⊢ Iff p.IsPath (Eq p SimpleGraph.Walk.nil)","decl":"@[simp]\ntheorem isPath_iff_eq_nil {u : V} (p : G.Walk u u) : p.IsPath ↔ p = nil := by\n  cases p <;> simp [IsPath.nil]\n\n"}
{"name":"SimpleGraph.Walk.IsPath.reverse","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : p.IsPath\n⊢ p.reverse.IsPath","decl":"theorem IsPath.reverse {u v : V} {p : G.Walk u v} (h : p.IsPath) : p.reverse.IsPath := by\n  simpa [isPath_def] using h\n\n"}
{"name":"SimpleGraph.Walk.isPath_reverse_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Iff p.reverse.IsPath p.IsPath","decl":"@[simp]\ntheorem isPath_reverse_iff {u v : V} (p : G.Walk u v) : p.reverse.IsPath ↔ p.IsPath := by\n  constructor <;> intro h <;> convert h.reverse; simp\n\n"}
{"name":"SimpleGraph.Walk.IsPath.of_append_left","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\na✝ : (p.append q).IsPath\n⊢ p.IsPath","decl":"theorem IsPath.of_append_left {u v w : V} {p : G.Walk u v} {q : G.Walk v w} :\n    (p.append q).IsPath → p.IsPath := by\n  simp only [isPath_def, support_append]\n  exact List.Nodup.of_append_left\n\n"}
{"name":"SimpleGraph.Walk.IsPath.of_append_right","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\nh : (p.append q).IsPath\n⊢ q.IsPath","decl":"theorem IsPath.of_append_right {u v w : V} {p : G.Walk u v} {q : G.Walk v w}\n    (h : (p.append q).IsPath) : q.IsPath := by\n  rw [← isPath_reverse_iff] at h ⊢\n  rw [reverse_append] at h\n  apply h.of_append_left\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.not_of_nil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ Not SimpleGraph.Walk.nil.IsCycle","decl":"@[simp]\ntheorem IsCycle.not_of_nil {u : V} : ¬(nil : G.Walk u u).IsCycle := fun h => h.ne_nil rfl\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.ne_bot","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\na✝ : p.IsCycle\n⊢ Ne G Bot.bot","decl":"lemma IsCycle.ne_bot : ∀ {p : G.Walk u u}, p.IsCycle → G ≠ ⊥\n  | nil, hp => by cases hp.ne_nil rfl\n  | cons h _, hp => by rintro rfl; exact h\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.three_le_length","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\np : G.Walk v v\nhp : p.IsCycle\n⊢ LE.le 3 p.length","decl":"lemma IsCycle.three_le_length {v : V} {p : G.Walk v v} (hp : p.IsCycle) : 3 ≤ p.length := by\n  have ⟨⟨hp, hp'⟩, _⟩ := hp\n  match p with\n  | .nil => simp at hp'\n  | .cons h .nil => simp at h\n  | .cons _ (.cons _ .nil) => simp at hp\n  | .cons _ (.cons _ (.cons _ _)) => simp_rw [SimpleGraph.Walk.length_cons]; omega\n\n"}
{"name":"SimpleGraph.Walk.not_nil_of_isCycle_cons","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nh : G.Adj v u\nhc : (SimpleGraph.Walk.cons h p).IsCycle\n⊢ Not p.Nil","decl":"lemma not_nil_of_isCycle_cons {p : G.Walk u v} {h : G.Adj v u} (hc : (Walk.cons h p).IsCycle) :\n    ¬ p.Nil := by\n  have := Walk.length_cons _ _ ▸ Walk.IsCycle.three_le_length hc\n  rw [Walk.not_nil_iff_lt_length]\n  omega\n\n"}
{"name":"SimpleGraph.Walk.cons_isCycle_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk v u\nh : G.Adj u v\n⊢ Iff (SimpleGraph.Walk.cons h p).IsCycle (And p.IsPath (Not (Membership.mem p.edges (Sym2.mk { fst := u, snd := v }))))","decl":"theorem cons_isCycle_iff {u v : V} (p : G.Walk v u) (h : G.Adj u v) :\n    (Walk.cons h p).IsCycle ↔ p.IsPath ∧ ¬s(u, v) ∈ p.edges := by\n  simp only [Walk.isCycle_def, Walk.isPath_def, Walk.isTrail_def, edges_cons, List.nodup_cons,\n    support_cons, List.tail_cons]\n  have : p.support.Nodup → p.edges.Nodup := edges_nodup_of_support_nodup\n  tauto\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.reverse","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nh : p.IsCycle\n⊢ p.reverse.IsCycle","decl":"protected lemma IsCycle.reverse {p : G.Walk u u} (h : p.IsCycle) : p.reverse.IsCycle := by\n  simp only [Walk.isCycle_def, nodup_tail_support_reverse] at h ⊢\n  exact ⟨h.1.reverse, fun h' ↦ h.2.1 (by simp_all [← Walk.length_eq_zero_iff]), h.2.2⟩\n\n"}
{"name":"SimpleGraph.Walk.isCycle_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\n⊢ Iff p.reverse.IsCycle p.IsCycle","decl":"@[simp]\nlemma isCycle_reverse {p : G.Walk u u} : p.reverse.IsCycle ↔ p.IsCycle where\n  mp h := by simpa using h.reverse\n  mpr := .reverse\n\n"}
{"name":"SimpleGraph.Walk.IsPath.tail","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nhp : p.IsPath\n⊢ p.tail.IsPath","decl":"lemma IsPath.tail {p : G.Walk u v} (hp : p.IsPath) : p.tail.IsPath := by\n  cases p with\n  | nil => simp\n  | cons hadj p =>\n    simp_all [Walk.isPath_def]\n\n"}
{"name":"SimpleGraph.Walk.IsPath.length_lt","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Fintype V\nu v : V\np : G.Walk u v\nhp : p.IsPath\n⊢ LT.lt p.length (Fintype.card V)","decl":"theorem IsPath.length_lt [Fintype V] {u v : V} {p : G.Walk u v} (hp : p.IsPath) :\n    p.length < Fintype.card V := by\n  rw [Nat.lt_iff_add_one_le, ← length_support]\n  exact hp.support_nodup.length_le_card\n\n"}
{"name":"SimpleGraph.Walk.IsPath.getVert_injOn","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nhp : p.IsPath\n⊢ Set.InjOn p.getVert (setOf fun i => LE.le i p.length)","decl":"lemma IsPath.getVert_injOn {p : G.Walk u v} (hp : p.IsPath) :\n    Set.InjOn p.getVert {i | i ≤ p.length} := by\n  intro n hn m hm hnm\n  induction p generalizing n m with\n  | nil => aesop\n  | @cons v w u h p ihp =>\n    simp only [length_cons, Set.mem_setOf_eq] at hn hm hnm\n    by_cases hn0 : n = 0 <;> by_cases hm0 : m = 0\n    · aesop\n    · simp only [hn0, getVert_zero, Walk.getVert_cons p h hm0] at hnm\n      have hvp : v ∉ p.support := by aesop\n      exact (hvp (Walk.mem_support_iff_exists_getVert.mpr ⟨(m - 1), ⟨hnm.symm, by omega⟩⟩)).elim\n    · simp only [hm0, Walk.getVert_cons p h hn0] at hnm\n      have hvp : v ∉ p.support := by aesop\n      exact (hvp (Walk.mem_support_iff_exists_getVert.mpr ⟨(n - 1), ⟨hnm, by omega⟩⟩)).elim\n    · simp only [Walk.getVert_cons _ _ hn0, Walk.getVert_cons _ _ hm0] at hnm\n      have := ihp hp.of_cons (by omega : (n - 1) ≤ p.length)\n        (by omega : (m - 1) ≤ p.length) hnm\n      omega\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.getVert_injOn","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\n⊢ Set.InjOn p.getVert (setOf fun i => And (LE.le 1 i) (LE.le i p.length))","decl":"lemma IsCycle.getVert_injOn {p : G.Walk u u} (hpc : p.IsCycle) :\n    Set.InjOn p.getVert {i | 1 ≤ i ∧ i ≤ p.length} := by\n  rw [← p.cons_tail_eq hpc.not_nil] at hpc\n  intro n hn m hm hnm\n  rw [← SimpleGraph.Walk.length_tail_add_one\n    (p.not_nil_of_tail_not_nil (not_nil_of_isCycle_cons hpc)), Set.mem_setOf] at hn hm\n  have := ((Walk.cons_isCycle_iff _ _).mp hpc).1.getVert_injOn\n      (by omega : n - 1 ≤ p.tail.length) (by omega : m - 1 ≤ p.tail.length)\n      (by simp_all [SimpleGraph.Walk.getVert_tail, show n - 1 + 1 = n from by omega,\n          show m - 1 + 1 = m from by omega])\n  omega\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.getVert_injOn'","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\n⊢ Set.InjOn p.getVert (setOf fun i => LE.le i (HSub.hSub p.length 1))","decl":"lemma IsCycle.getVert_injOn' {p : G.Walk u u} (hpc : p.IsCycle) :\n    Set.InjOn p.getVert {i |  i ≤ p.length - 1} := by\n  intro n hn m hm hnm\n  simp only [Walk.length_reverse, Set.mem_setOf_eq, Nat.sub_le, and_true] at *\n  have := hpc.three_le_length\n  have : p.length - n = p.length - m := Walk.length_reverse _ ▸ hpc.reverse.getVert_injOn\n    (by simp only [Walk.length_reverse, Set.mem_setOf_eq]; omega)\n    (by simp only [Walk.length_reverse, Set.mem_setOf_eq]; omega)\n    (by simp [Walk.getVert_reverse, show p.length - (p.length - n) = n from by omega, hnm,\n      show p.length - (p.length - m) = m from by omega])\n  omega\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.snd_ne_penultimate","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhp : p.IsCycle\n⊢ Ne p.snd p.penultimate","decl":"lemma IsCycle.snd_ne_penultimate {p : G.Walk u u} (hp : p.IsCycle) : p.snd ≠ p.penultimate := by\n  intro h\n  have := hp.three_le_length\n  apply hp.getVert_injOn (by simp; omega) (by simp; omega) at h\n  omega\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.getVert_endpoint_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\ni : Nat\np : G.Walk u u\nhpc : p.IsCycle\nhl : LE.le i p.length\n⊢ Iff (Eq (p.getVert i) u) (Or (Eq i 0) (Eq i p.length))","decl":"lemma IsCycle.getVert_endpoint_iff {i : ℕ} {p : G.Walk u u} (hpc : p.IsCycle) (hl : i ≤ p.length) :\n    p.getVert i = u ↔ i = 0 ∨ i = p.length := by\n  refine ⟨?_, by aesop⟩\n  intro h\n  by_cases hi : i = 0\n  · left; exact hi\n  · right\n    exact hpc.getVert_injOn (by simp only [Set.mem_setOf_eq]; omega)\n      (by simp only [Set.mem_setOf_eq]; omega) (h.symm ▸ (Walk.getVert_length p).symm)\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.getVert_sub_one_neq_getVert_add_one","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\ni : Nat\np : G.Walk u u\nhpc : p.IsCycle\nh : LE.le i p.length\n⊢ Ne (p.getVert (HSub.hSub i 1)) (p.getVert (HAdd.hAdd i 1))","decl":"lemma IsCycle.getVert_sub_one_neq_getVert_add_one {i : ℕ} {p : G.Walk u u} (hpc : p.IsCycle)\n    (h : i ≤ p.length) : p.getVert (i - 1) ≠ p.getVert (i + 1) := by\n  have hl := hpc.three_le_length\n  by_cases hi' : i ≥ p.length - 1\n  · intro h'\n    rw [p.getVert_of_length_le (by omega : p.length ≤ i + 1),\n      hpc.getVert_endpoint_iff (by omega)] at h'\n    omega\n  intro h'\n  have := hpc.getVert_injOn' (by simp only [Set.mem_setOf_eq, Nat.sub_le_iff_le_add]; omega)\n    (by simp only [Set.mem_setOf_eq]; omega) h'\n  omega\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.takeUntil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nhc : p.IsTrail\nh : Membership.mem p.support u\n⊢ (p.takeUntil u h).IsTrail","decl":"protected theorem IsTrail.takeUntil {u v w : V} {p : G.Walk v w} (hc : p.IsTrail)\n    (h : u ∈ p.support) : (p.takeUntil u h).IsTrail :=\n  IsTrail.of_append_left (q := p.dropUntil u h) (by rwa [← take_spec _ h] at hc)\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.dropUntil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nhc : p.IsTrail\nh : Membership.mem p.support u\n⊢ (p.dropUntil u h).IsTrail","decl":"protected theorem IsTrail.dropUntil {u v w : V} {p : G.Walk v w} (hc : p.IsTrail)\n    (h : u ∈ p.support) : (p.dropUntil u h).IsTrail :=\n  IsTrail.of_append_right (p := p.takeUntil u h) (q := p.dropUntil u h)\n    (by rwa [← take_spec _ h] at hc)\n\n"}
{"name":"SimpleGraph.Walk.IsPath.takeUntil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nhc : p.IsPath\nh : Membership.mem p.support u\n⊢ (p.takeUntil u h).IsPath","decl":"protected theorem IsPath.takeUntil {u v w : V} {p : G.Walk v w} (hc : p.IsPath)\n    (h : u ∈ p.support) : (p.takeUntil u h).IsPath :=\n  IsPath.of_append_left (q := p.dropUntil u h) (by rwa [← take_spec _ h] at hc)\n\n"}
{"name":"SimpleGraph.Walk.IsPath.dropUntil","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Walk v w\nhc : p.IsPath\nh : Membership.mem p.support u\n⊢ (p.dropUntil u h).IsPath","decl":"protected theorem IsPath.dropUntil {u v w : V} {p : G.Walk v w} (hc : p.IsPath)\n    (h : u ∈ p.support) : (p.dropUntil u h).IsPath :=\n  IsPath.of_append_right (p := p.takeUntil u h) (q := p.dropUntil u h)\n    (by rwa [← take_spec _ h] at hc)\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.rotate","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\nc : G.Walk v v\nhc : c.IsTrail\nh : Membership.mem c.support u\n⊢ (c.rotate h).IsTrail","decl":"protected theorem IsTrail.rotate {u v : V} {c : G.Walk v v} (hc : c.IsTrail) (h : u ∈ c.support) :\n    (c.rotate h).IsTrail := by\n  rw [isTrail_def, (c.rotate_edges h).perm.nodup_iff]\n  exact hc.edges_nodup\n\n"}
{"name":"SimpleGraph.Walk.IsCircuit.rotate","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\nc : G.Walk v v\nhc : c.IsCircuit\nh : Membership.mem c.support u\n⊢ (c.rotate h).IsCircuit","decl":"protected theorem IsCircuit.rotate {u v : V} {c : G.Walk v v} (hc : c.IsCircuit)\n    (h : u ∈ c.support) : (c.rotate h).IsCircuit := by\n  refine ⟨hc.isTrail.rotate _, ?_⟩\n  cases c\n  · exact (hc.ne_nil rfl).elim\n  · intro hn\n    have hn' := congr_arg length hn\n    rw [rotate, length_append, add_comm, ← length_append, take_spec] at hn'\n    simp at hn'\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.rotate","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\nc : G.Walk v v\nhc : c.IsCycle\nh : Membership.mem c.support u\n⊢ (c.rotate h).IsCycle","decl":"protected theorem IsCycle.rotate {u v : V} {c : G.Walk v v} (hc : c.IsCycle) (h : u ∈ c.support) :\n    (c.rotate h).IsCycle := by\n  refine ⟨hc.isCircuit.rotate _, ?_⟩\n  rw [List.IsRotated.nodup_iff (support_rotate _ _)]\n  exact hc.support_nodup\n\n"}
{"name":"SimpleGraph.Path.isPath","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Path u v\n⊢ (↑p).IsPath","decl":"@[simp]\nprotected theorem isPath {u v : V} (p : G.Path u v) : (p : G.Walk u v).IsPath := p.property\n\n"}
{"name":"SimpleGraph.Path.isTrail","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Path u v\n⊢ (↑p).IsTrail","decl":"@[simp]\nprotected theorem isTrail {u v : V} (p : G.Path u v) : (p : G.Walk u v).IsTrail :=\n  p.property.isTrail\n\n"}
{"name":"SimpleGraph.Path.nil_coe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ Eq (↑SimpleGraph.Path.nil) SimpleGraph.Walk.nil","decl":"/-- The length-0 path at a vertex. -/\n@[refl, simps]\nprotected def nil {u : V} : G.Path u u :=\n  ⟨Walk.nil, Walk.IsPath.nil⟩\n\n"}
{"name":"SimpleGraph.Path.singleton_coe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ Eq (↑(SimpleGraph.Path.singleton h)) (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil)","decl":"/-- The length-1 path between a pair of adjacent vertices. -/\n@[simps]\ndef singleton {u v : V} (h : G.Adj u v) : G.Path u v :=\n  ⟨Walk.cons h Walk.nil, by simp [h.ne]⟩\n\n"}
{"name":"SimpleGraph.Path.mk'_mem_edges_singleton","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ Membership.mem (↑(SimpleGraph.Path.singleton h)).edges (Sym2.mk { fst := u, snd := v })","decl":"theorem mk'_mem_edges_singleton {u v : V} (h : G.Adj u v) :\n    s(u, v) ∈ (singleton h : G.Walk u v).edges := by simp [singleton]\n\n"}
{"name":"SimpleGraph.Path.reverse_coe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Path u v\n⊢ Eq (↑p.reverse) (↑p).reverse","decl":"/-- The reverse of a path is another path.  See also `SimpleGraph.Walk.reverse`. -/\n@[symm, simps]\ndef reverse {u v : V} (p : G.Path u v) : G.Path v u :=\n  ⟨Walk.reverse p, p.property.reverse⟩\n\n"}
{"name":"SimpleGraph.Path.count_support_eq_one","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\np : G.Path u v\nhw : Membership.mem (↑p).support w\n⊢ Eq (List.count w (↑p).support) 1","decl":"theorem count_support_eq_one [DecidableEq V] {u v w : V} {p : G.Path u v}\n    (hw : w ∈ (p : G.Walk u v).support) : (p : G.Walk u v).support.count w = 1 :=\n  List.count_eq_one_of_mem p.property.support_nodup hw\n\n"}
{"name":"SimpleGraph.Path.count_edges_eq_one","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Path u v\ne : Sym2 V\nhw : Membership.mem (↑p).edges e\n⊢ Eq (List.count e (↑p).edges) 1","decl":"theorem count_edges_eq_one [DecidableEq V] {u v : V} {p : G.Path u v} (e : Sym2 V)\n    (hw : e ∈ (p : G.Walk u v).edges) : (p : G.Walk u v).edges.count e = 1 :=\n  List.count_eq_one_of_mem p.property.isTrail.edges_nodup hw\n\n"}
{"name":"SimpleGraph.Path.nodup_support","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Path u v\n⊢ (↑p).support.Nodup","decl":"@[simp]\ntheorem nodup_support {u v : V} (p : G.Path u v) : (p : G.Walk u v).support.Nodup :=\n  (Walk.isPath_def _).mp p.property\n\n"}
{"name":"SimpleGraph.Path.loop_eq","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\np : G.Path v v\n⊢ Eq p SimpleGraph.Path.nil","decl":"theorem loop_eq {v : V} (p : G.Path v v) : p = Path.nil := by\n  obtain ⟨_ | _, h⟩ := p\n  · rfl\n  · simp at h\n\n"}
{"name":"SimpleGraph.Path.not_mem_edges_of_loop","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\ne : Sym2 V\np : G.Path v v\n⊢ Not (Membership.mem (↑p).edges e)","decl":"theorem not_mem_edges_of_loop {v : V} {e : Sym2 V} {p : G.Path v v} :\n    ¬e ∈ (p : G.Walk v v).edges := by simp [p.loop_eq]\n\n"}
{"name":"SimpleGraph.Path.cons_isCycle","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Path v u\nh : G.Adj u v\nhe : Not (Membership.mem (↑p).edges (Sym2.mk { fst := u, snd := v }))\n⊢ (SimpleGraph.Walk.cons h ↑p).IsCycle","decl":"theorem cons_isCycle {u v : V} (p : G.Path v u) (h : G.Adj u v)\n    (he : ¬s(u, v) ∈ (p : G.Walk v u).edges) : (Walk.cons h ↑p).IsCycle := by\n  simp [Walk.isCycle_def, Walk.cons_isTrail_iff, he]\n\n"}
{"name":"SimpleGraph.Walk.bypass_copy","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v u' v' : V\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\n⊢ Eq (p.copy hu hv).bypass (p.bypass.copy hu hv)","decl":"@[simp]\ntheorem bypass_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).bypass = p.bypass.copy hu hv := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Walk.bypass_isPath","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\n⊢ p.bypass.IsPath","decl":"theorem bypass_isPath {u v : V} (p : G.Walk u v) : p.bypass.IsPath := by\n  induction p with\n  | nil => simp!\n  | cons _ p' ih =>\n    simp only [bypass]\n    split_ifs with hs\n    · exact ih.dropUntil hs\n    · simp [*, cons_isPath_iff]\n\n"}
{"name":"SimpleGraph.Walk.length_bypass_le","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\n⊢ LE.le p.bypass.length p.length","decl":"theorem length_bypass_le {u v : V} (p : G.Walk u v) : p.bypass.length ≤ p.length := by\n  induction p with\n  | nil => rfl\n  | cons _ _ ih =>\n    simp only [bypass]\n    split_ifs\n    · trans\n      · apply length_dropUntil_le\n      rw [length_cons]\n      omega\n    · rw [length_cons, length_cons]\n      exact Nat.add_le_add_right ih 1\n\n"}
{"name":"SimpleGraph.Walk.bypass_eq_self_of_length_le","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\nh : LE.le p.length p.bypass.length\n⊢ Eq p.bypass p","decl":"lemma bypass_eq_self_of_length_le {u v : V} (p : G.Walk u v) (h : p.length ≤ p.bypass.length) :\n    p.bypass = p := by\n  induction p with\n  | nil => rfl\n  | cons h p ih =>\n    simp only [Walk.bypass]\n    split_ifs with hb\n    · exfalso\n      simp only [hb, Walk.bypass, Walk.length_cons, dif_pos] at h\n      apply Nat.not_succ_le_self p.length\n      calc p.length + 1\n        _ ≤ (p.bypass.dropUntil _ _).length := h\n        _ ≤ p.bypass.length := Walk.length_dropUntil_le p.bypass hb\n        _ ≤ p.length := Walk.length_bypass_le _\n    · simp only [hb, Walk.bypass, Walk.length_cons, not_false_iff, dif_neg,\n        Nat.add_le_add_iff_right] at h\n      rw [ih h]\n\n"}
{"name":"SimpleGraph.Walk.support_bypass_subset","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\n⊢ HasSubset.Subset p.bypass.support p.support","decl":"theorem support_bypass_subset {u v : V} (p : G.Walk u v) : p.bypass.support ⊆ p.support := by\n  induction p with\n  | nil => simp!\n  | cons _ _ ih =>\n    simp! only\n    split_ifs\n    · apply List.Subset.trans (support_dropUntil_subset _ _)\n      apply List.subset_cons_of_subset\n      assumption\n    · rw [support_cons]\n      apply List.cons_subset_cons\n      assumption\n\n"}
{"name":"SimpleGraph.Walk.support_toPath_subset","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\n⊢ HasSubset.Subset (↑p.toPath).support p.support","decl":"theorem support_toPath_subset {u v : V} (p : G.Walk u v) :\n    (p.toPath : G.Walk u v).support ⊆ p.support :=\n  support_bypass_subset _\n\n"}
{"name":"SimpleGraph.Walk.darts_bypass_subset","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\n⊢ HasSubset.Subset p.bypass.darts p.darts","decl":"theorem darts_bypass_subset {u v : V} (p : G.Walk u v) : p.bypass.darts ⊆ p.darts := by\n  induction p with\n  | nil => simp!\n  | cons _ _ ih =>\n    simp! only\n    split_ifs\n    · apply List.Subset.trans (darts_dropUntil_subset _ _)\n      apply List.subset_cons_of_subset _ ih\n    · rw [darts_cons]\n      exact List.cons_subset_cons _ ih\n\n"}
{"name":"SimpleGraph.Walk.edges_bypass_subset","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\n⊢ HasSubset.Subset p.bypass.edges p.edges","decl":"theorem edges_bypass_subset {u v : V} (p : G.Walk u v) : p.bypass.edges ⊆ p.edges :=\n  List.map_subset _ p.darts_bypass_subset\n\n"}
{"name":"SimpleGraph.Walk.darts_toPath_subset","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\n⊢ HasSubset.Subset (↑p.toPath).darts p.darts","decl":"theorem darts_toPath_subset {u v : V} (p : G.Walk u v) : (p.toPath : G.Walk u v).darts ⊆ p.darts :=\n  darts_bypass_subset _\n\n"}
{"name":"SimpleGraph.Walk.edges_toPath_subset","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v : V\np : G.Walk u v\n⊢ HasSubset.Subset (↑p.toPath).edges p.edges","decl":"theorem edges_toPath_subset {u v : V} (p : G.Walk u v) : (p.toPath : G.Walk u v).edges ⊆ p.edges :=\n  edges_bypass_subset _\n\n"}
{"name":"SimpleGraph.Walk.map_isPath_of_injective","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\nhinj : Function.Injective ⇑f\nhp : p.IsPath\n⊢ (SimpleGraph.Walk.map f p).IsPath","decl":"theorem map_isPath_of_injective (hinj : Function.Injective f) (hp : p.IsPath) :\n    (p.map f).IsPath := by\n  induction p with\n  | nil => simp\n  | cons _ _ ih =>\n    rw [Walk.cons_isPath_iff] at hp\n    simp only [map_cons, cons_isPath_iff, ih hp.1, support_map, List.mem_map, not_exists, not_and,\n      true_and]\n    intro x hx hf\n    cases hinj hf\n    exact hp.2 hx\n\n"}
{"name":"SimpleGraph.Walk.IsPath.of_map","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nu v : V\np : G.Walk u v\nf : G.Hom G'\nhp : (SimpleGraph.Walk.map f p).IsPath\n⊢ p.IsPath","decl":"protected theorem IsPath.of_map {f : G →g G'} (hp : (p.map f).IsPath) : p.IsPath := by\n  induction p with\n  | nil => simp\n  | cons _ _ ih =>\n    rw [map_cons, Walk.cons_isPath_iff, support_map] at hp\n    rw [Walk.cons_isPath_iff]\n    cases' hp with hp1 hp2\n    refine ⟨ih hp1, ?_⟩\n    contrapose! hp2\n    exact List.mem_map_of_mem f hp2\n\n"}
{"name":"SimpleGraph.Walk.map_isPath_iff_of_injective","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\nhinj : Function.Injective ⇑f\n⊢ Iff (SimpleGraph.Walk.map f p).IsPath p.IsPath","decl":"theorem map_isPath_iff_of_injective (hinj : Function.Injective f) : (p.map f).IsPath ↔ p.IsPath :=\n  ⟨IsPath.of_map, map_isPath_of_injective hinj⟩\n\n"}
{"name":"SimpleGraph.Walk.map_isTrail_iff_of_injective","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\nhinj : Function.Injective ⇑f\n⊢ Iff (SimpleGraph.Walk.map f p).IsTrail p.IsTrail","decl":"theorem map_isTrail_iff_of_injective (hinj : Function.Injective f) :\n    (p.map f).IsTrail ↔ p.IsTrail := by\n  induction p with\n  | nil => simp\n  | cons _ _ ih =>\n    rw [map_cons, cons_isTrail_iff, ih, cons_isTrail_iff]\n    apply and_congr_right'\n    rw [← Sym2.map_pair_eq, edges_map, ← List.mem_map_of_injective (Sym2.map.injective hinj)]\n\n"}
{"name":"SimpleGraph.Walk.map_isTrail_of_injective","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu v : V\np : G.Walk u v\nhinj : Function.Injective ⇑f\na✝ : p.IsTrail\n⊢ (SimpleGraph.Walk.map f p).IsTrail","decl":"alias ⟨_, map_isTrail_of_injective⟩ := map_isTrail_iff_of_injective\n\n"}
{"name":"SimpleGraph.Walk.map_isCycle_iff_of_injective","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu : V\np : G.Walk u u\nhinj : Function.Injective ⇑f\n⊢ Iff (SimpleGraph.Walk.map f p).IsCycle p.IsCycle","decl":"theorem map_isCycle_iff_of_injective {p : G.Walk u u} (hinj : Function.Injective f) :\n    (p.map f).IsCycle ↔ p.IsCycle := by\n  rw [isCycle_def, isCycle_def, map_isTrail_iff_of_injective hinj, Ne, map_eq_nil_iff,\n    support_map, ← List.map_tail, List.nodup_map_iff hinj]\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.map","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nu : V\np : G.Walk u u\nhinj : Function.Injective ⇑f\na✝ : p.IsCycle\n⊢ (SimpleGraph.Walk.map f p).IsCycle","decl":"alias ⟨_, IsCycle.map⟩ := map_isCycle_iff_of_injective\n\n"}
{"name":"SimpleGraph.Walk.mapLe_isTrail","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nu v : V\np : G.Walk u v\n⊢ Iff (SimpleGraph.Walk.mapLe h p).IsTrail p.IsTrail","decl":"@[simp]\ntheorem mapLe_isTrail {G G' : SimpleGraph V} (h : G ≤ G') {u v : V} {p : G.Walk u v} :\n    (p.mapLe h).IsTrail ↔ p.IsTrail :=\n  map_isTrail_iff_of_injective Function.injective_id\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.of_mapLe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nu v : V\np : G.Walk u v\na✝ : (SimpleGraph.Walk.mapLe h p).IsTrail\n⊢ p.IsTrail","decl":"alias ⟨IsTrail.of_mapLe, IsTrail.mapLe⟩ := mapLe_isTrail\n\n"}
{"name":"SimpleGraph.Walk.IsTrail.mapLe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nu v : V\np : G.Walk u v\na✝ : p.IsTrail\n⊢ (SimpleGraph.Walk.mapLe h p).IsTrail","decl":"alias ⟨IsTrail.of_mapLe, IsTrail.mapLe⟩ := mapLe_isTrail\n\n"}
{"name":"SimpleGraph.Walk.mapLe_isPath","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nu v : V\np : G.Walk u v\n⊢ Iff (SimpleGraph.Walk.mapLe h p).IsPath p.IsPath","decl":"@[simp]\ntheorem mapLe_isPath {G G' : SimpleGraph V} (h : G ≤ G') {u v : V} {p : G.Walk u v} :\n    (p.mapLe h).IsPath ↔ p.IsPath :=\n  map_isPath_iff_of_injective Function.injective_id\n\n"}
{"name":"SimpleGraph.Walk.IsPath.mapLe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nu v : V\np : G.Walk u v\na✝ : p.IsPath\n⊢ (SimpleGraph.Walk.mapLe h p).IsPath","decl":"alias ⟨IsPath.of_mapLe, IsPath.mapLe⟩ := mapLe_isPath\n\n"}
{"name":"SimpleGraph.Walk.IsPath.of_mapLe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nu v : V\np : G.Walk u v\na✝ : (SimpleGraph.Walk.mapLe h p).IsPath\n⊢ p.IsPath","decl":"alias ⟨IsPath.of_mapLe, IsPath.mapLe⟩ := mapLe_isPath\n\n"}
{"name":"SimpleGraph.Walk.mapLe_isCycle","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nu : V\np : G.Walk u u\n⊢ Iff (SimpleGraph.Walk.mapLe h p).IsCycle p.IsCycle","decl":"@[simp]\ntheorem mapLe_isCycle {G G' : SimpleGraph V} (h : G ≤ G') {u : V} {p : G.Walk u u} :\n    (p.mapLe h).IsCycle ↔ p.IsCycle :=\n  map_isCycle_iff_of_injective Function.injective_id\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.of_mapLe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nu : V\np : G.Walk u u\na✝ : (SimpleGraph.Walk.mapLe h p).IsCycle\n⊢ p.IsCycle","decl":"alias ⟨IsCycle.of_mapLe, IsCycle.mapLe⟩ := mapLe_isCycle\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.mapLe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nu : V\np : G.Walk u u\na✝ : p.IsCycle\n⊢ (SimpleGraph.Walk.mapLe h p).IsCycle","decl":"alias ⟨IsCycle.of_mapLe, IsCycle.mapLe⟩ := mapLe_isCycle\n\n"}
{"name":"SimpleGraph.Path.map_coe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nhinj : Function.Injective ⇑f\nu v : V\np : G.Path u v\n⊢ Eq (↑(SimpleGraph.Path.map f hinj p)) (SimpleGraph.Walk.map f ↑p)","decl":"/-- Given an injective graph homomorphism, map paths to paths. -/\n@[simps]\nprotected def map (f : G →g G') (hinj : Function.Injective f) {u v : V} (p : G.Path u v) :\n    G'.Path (f u) (f v) :=\n  ⟨Walk.map f p, Walk.map_isPath_of_injective hinj p.2⟩\n\n"}
{"name":"SimpleGraph.Path.map_injective","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nhinj : Function.Injective ⇑f\nu v : V\n⊢ Function.Injective (SimpleGraph.Path.map f hinj)","decl":"theorem map_injective {f : G →g G'} (hinj : Function.Injective f) (u v : V) :\n    Function.Injective (Path.map f hinj : G.Path u v → G'.Path (f u) (f v)) := by\n  rintro ⟨p, hp⟩ ⟨p', hp'⟩ h\n  simp only [Path.map, Subtype.coe_mk, Subtype.mk.injEq] at h\n  simp [Walk.map_injective_of_injective hinj u v h]\n\n"}
{"name":"SimpleGraph.Path.mapEmbedding_coe","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Embedding G'\nu v : V\np : G.Path u v\n⊢ Eq (↑(SimpleGraph.Path.mapEmbedding f p)) (SimpleGraph.Walk.map f.toHom ↑p)","decl":"/-- Given a graph embedding, map paths to paths. -/\n@[simps!]\nprotected def mapEmbedding (f : G ↪g G') {u v : V} (p : G.Path u v) : G'.Path (f u) (f v) :=\n  Path.map f.toHom f.injective p\n\n"}
{"name":"SimpleGraph.Path.mapEmbedding_injective","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Embedding G'\nu v : V\n⊢ Function.Injective (SimpleGraph.Path.mapEmbedding f)","decl":"theorem mapEmbedding_injective (f : G ↪g G') (u v : V) :\n    Function.Injective (Path.mapEmbedding f : G.Path u v → G'.Path (f u) (f v)) :=\n  map_injective f.injective u v\n\n"}
{"name":"SimpleGraph.Walk.IsPath.transfer","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nH : SimpleGraph V\np : G.Walk u v\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Membership.mem H.edgeSet e\npp : p.IsPath\n⊢ (p.transfer H hp).IsPath","decl":"protected theorem IsPath.transfer (hp) (pp : p.IsPath) :\n    (p.transfer H hp).IsPath := by\n  induction p with\n  | nil => simp\n  | cons _ _ ih =>\n    simp only [Walk.transfer, cons_isPath_iff, support_transfer _ ] at pp ⊢\n    exact ⟨ih _ pp.1, pp.2⟩\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.transfer","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\nH : SimpleGraph V\nq : G.Walk u u\nqc : q.IsCycle\nhq : ∀ (e : Sym2 V), Membership.mem q.edges e → Membership.mem H.edgeSet e\n⊢ (q.transfer H hq).IsCycle","decl":"protected theorem IsCycle.transfer {q : G.Walk u u} (qc : q.IsCycle) (hq) :\n    (q.transfer H hq).IsCycle := by\n  cases q with\n  | nil => simp at qc\n  | cons _ q =>\n    simp only [edges_cons, List.find?, List.mem_cons, forall_eq_or_imp, mem_edgeSet] at hq\n    simp only [Walk.transfer, cons_isCycle_iff, edges_transfer q hq.2] at qc ⊢\n    exact ⟨qc.1.transfer hq.2, qc.2⟩\n\n"}
{"name":"SimpleGraph.Walk.IsPath.toDeleteEdges","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\ns : Set (Sym2 V)\np : G.Walk v w\nh : p.IsPath\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Not (Membership.mem s e)\n⊢ (SimpleGraph.Walk.toDeleteEdges s p hp).IsPath","decl":"protected theorem IsPath.toDeleteEdges (s : Set (Sym2 V))\n    {p : G.Walk v w} (h : p.IsPath) (hp) : (p.toDeleteEdges s hp).IsPath :=\n  h.transfer _\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.toDeleteEdges","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\ns : Set (Sym2 V)\np : G.Walk v v\nh : p.IsCycle\nhp : ∀ (e : Sym2 V), Membership.mem p.edges e → Not (Membership.mem s e)\n⊢ (SimpleGraph.Walk.toDeleteEdges s p hp).IsCycle","decl":"protected theorem IsCycle.toDeleteEdges (s : Set (Sym2 V))\n    {p : G.Walk v v} (h : p.IsCycle) (hp) : (p.toDeleteEdges s hp).IsCycle :=\n  h.transfer _\n\n"}
{"name":"SimpleGraph.Walk.toDeleteEdges_copy","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv u u' v' : V\ns : Set (Sym2 V)\np : G.Walk u v\nhu : Eq u u'\nhv : Eq v v'\nh : ∀ (e : Sym2 V), Membership.mem (p.copy hu hv).edges e → Not (Membership.mem s e)\n⊢ Eq (SimpleGraph.Walk.toDeleteEdges s (p.copy hu hv) h) ((SimpleGraph.Walk.toDeleteEdges s p ⋯).copy hu hv)","decl":"@[simp]\ntheorem toDeleteEdges_copy {v u u' v' : V} (s : Set (Sym2 V))\n    (p : G.Walk u v) (hu : u = u') (hv : v = v') (h) :\n    (p.copy hu hv).toDeleteEdges s h =\n      (p.toDeleteEdges s (by subst_vars; exact h)).copy hu hv := by\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.reachable_iff_nonempty_univ","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Iff (G.Reachable u v) Set.univ.Nonempty","decl":"theorem reachable_iff_nonempty_univ {u v : V} :\n    G.Reachable u v ↔ (Set.univ : Set (G.Walk u v)).Nonempty :=\n  Set.nonempty_iff_univ_nonempty\n\n"}
{"name":"SimpleGraph.not_reachable_iff_isEmpty_walk","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Iff (Not (G.Reachable u v)) (IsEmpty (G.Walk u v))","decl":"lemma not_reachable_iff_isEmpty_walk {u v : V} : ¬G.Reachable u v ↔ IsEmpty (G.Walk u v) :=\n  not_nonempty_iff\n\n"}
{"name":"SimpleGraph.Reachable.elim","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\np : Prop\nu v : V\nh : G.Reachable u v\nhp : G.Walk u v → p\n⊢ p","decl":"protected theorem Reachable.elim {p : Prop} {u v : V} (h : G.Reachable u v)\n    (hp : G.Walk u v → p) : p :=\n  Nonempty.elim h hp\n\n"}
{"name":"SimpleGraph.Reachable.elim_path","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\np : Prop\nu v : V\nh : G.Reachable u v\nhp : G.Path u v → p\n⊢ p","decl":"protected theorem Reachable.elim_path {p : Prop} {u v : V} (h : G.Reachable u v)\n    (hp : G.Path u v → p) : p := by classical exact h.elim fun q => hp q.toPath\n\n"}
{"name":"SimpleGraph.Walk.reachable","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ G.Reachable u v","decl":"protected theorem Walk.reachable {G : SimpleGraph V} {u v : V} (p : G.Walk u v) : G.Reachable u v :=\n  ⟨p⟩\n\n"}
{"name":"SimpleGraph.Adj.reachable","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ G.Reachable u v","decl":"protected theorem Adj.reachable {u v : V} (h : G.Adj u v) : G.Reachable u v :=\n  h.toWalk.reachable\n\n"}
{"name":"SimpleGraph.Reachable.refl","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ G.Reachable u u","decl":"@[refl]\nprotected theorem Reachable.refl (u : V) : G.Reachable u u := ⟨Walk.nil⟩\n\n"}
{"name":"SimpleGraph.Reachable.rfl","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\n⊢ G.Reachable u u","decl":"protected theorem Reachable.rfl {u : V} : G.Reachable u u := Reachable.refl _\n\n"}
{"name":"SimpleGraph.Reachable.symm","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nhuv : G.Reachable u v\n⊢ G.Reachable v u","decl":"@[symm]\nprotected theorem Reachable.symm {u v : V} (huv : G.Reachable u v) : G.Reachable v u :=\n  huv.elim fun p => ⟨p.reverse⟩\n\n"}
{"name":"SimpleGraph.reachable_comm","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Iff (G.Reachable u v) (G.Reachable v u)","decl":"theorem reachable_comm {u v : V} : G.Reachable u v ↔ G.Reachable v u :=\n  ⟨Reachable.symm, Reachable.symm⟩\n\n"}
{"name":"SimpleGraph.Reachable.trans","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\nhuv : G.Reachable u v\nhvw : G.Reachable v w\n⊢ G.Reachable u w","decl":"@[trans]\nprotected theorem Reachable.trans {u v w : V} (huv : G.Reachable u v) (hvw : G.Reachable v w) :\n    G.Reachable u w :=\n  huv.elim fun puv => hvw.elim fun pvw => ⟨puv.append pvw⟩\n\n"}
{"name":"SimpleGraph.reachable_iff_reflTransGen","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Iff (G.Reachable u v) (Relation.ReflTransGen G.Adj u v)","decl":"theorem reachable_iff_reflTransGen (u v : V) :\n    G.Reachable u v ↔ Relation.ReflTransGen G.Adj u v := by\n  constructor\n  · rintro ⟨h⟩\n    induction h with\n    | nil => rfl\n    | cons h' _ ih => exact (Relation.ReflTransGen.single h').trans ih\n  · intro h\n    induction h with\n    | refl => rfl\n    | tail _ ha hr => exact Reachable.trans hr ⟨Walk.cons ha Walk.nil⟩\n\n"}
{"name":"SimpleGraph.Reachable.map","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nu v : V\nG : SimpleGraph V\nG' : SimpleGraph V'\nf : G.Hom G'\nh : G.Reachable u v\n⊢ G'.Reachable (f u) (f v)","decl":"protected theorem Reachable.map {u v : V} {G : SimpleGraph V} {G' : SimpleGraph V'} (f : G →g G')\n    (h : G.Reachable u v) : G'.Reachable (f u) (f v) :=\n  h.elim fun p => ⟨p.map f⟩\n\n"}
{"name":"SimpleGraph.Reachable.mono","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nu v : V\nG G' : SimpleGraph V\nh : LE.le G G'\nGuv : G.Reachable u v\n⊢ G'.Reachable u v","decl":"@[mono]\nprotected lemma Reachable.mono {u v : V} {G G' : SimpleGraph V}\n    (h : G ≤ G') (Guv : G.Reachable u v) : G'.Reachable u v :=\n  Guv.map (SimpleGraph.Hom.mapSpanningSubgraphs h)\n\n"}
{"name":"SimpleGraph.Iso.reachable_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nφ : G.Iso G'\nu v : V\n⊢ Iff (G'.Reachable (φ u) (φ v)) (G.Reachable u v)","decl":"theorem Iso.reachable_iff {G : SimpleGraph V} {G' : SimpleGraph V'} {φ : G ≃g G'} {u v : V} :\n    G'.Reachable (φ u) (φ v) ↔ G.Reachable u v :=\n  ⟨fun r => φ.left_inv u ▸ φ.left_inv v ▸ r.map φ.symm.toHom, Reachable.map φ.toHom⟩\n\n"}
{"name":"SimpleGraph.Iso.symm_apply_reachable","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nφ : G.Iso G'\nu : V\nv : V'\n⊢ Iff (G.Reachable (φ.symm v) u) (G'.Reachable v (φ u))","decl":"theorem Iso.symm_apply_reachable {G : SimpleGraph V} {G' : SimpleGraph V'} {φ : G ≃g G'} {u : V}\n    {v : V'} : G.Reachable (φ.symm v) u ↔ G'.Reachable v (φ u) := by\n  rw [← Iso.reachable_iff, RelIso.apply_symm_apply]\n\n"}
{"name":"SimpleGraph.reachable_is_equivalence","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Equivalence G.Reachable","decl":"theorem reachable_is_equivalence : Equivalence G.Reachable :=\n  Equivalence.mk (@Reachable.refl _ G) (@Reachable.symm _ G) (@Reachable.trans _ G)\n\n"}
{"name":"SimpleGraph.reachable_bot","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nu v : V\n⊢ Iff (Bot.bot.Reachable u v) (Eq u v)","decl":"/-- Distinct vertices are not reachable in the empty graph. -/\n@[simp]\nlemma reachable_bot {u v : V} : (⊥ : SimpleGraph V).Reachable u v ↔ u = v :=\n  ⟨fun h ↦ h.elim fun p ↦ match p with | .nil => rfl, fun h ↦ h ▸ .rfl⟩\n\n"}
{"name":"SimpleGraph.Preconnected.map","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nH : SimpleGraph V'\nf : G.Hom H\nhf : Function.Surjective ⇑f\nhG : G.Preconnected\n⊢ H.Preconnected","decl":"theorem Preconnected.map {G : SimpleGraph V} {H : SimpleGraph V'} (f : G →g H) (hf : Surjective f)\n    (hG : G.Preconnected) : H.Preconnected :=\n  hf.forall₂.2 fun _ _ => Nonempty.map (Walk.map _) <| hG _ _\n\n"}
{"name":"SimpleGraph.Preconnected.mono","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nhG : G.Preconnected\n⊢ G'.Preconnected","decl":"@[mono]\nprotected lemma Preconnected.mono  {G G' : SimpleGraph V} (h : G ≤ G') (hG : G.Preconnected) :\n    G'.Preconnected := fun u v => (hG u v).mono h\n\n"}
{"name":"SimpleGraph.bot_preconnected_iff_subsingleton","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\n⊢ Iff Bot.bot.Preconnected (Subsingleton V)","decl":"lemma bot_preconnected_iff_subsingleton : (⊥ : SimpleGraph V).Preconnected ↔ Subsingleton V := by\n  refine ⟨fun h ↦ ?_, fun h ↦ by simpa [subsingleton_iff, ← reachable_bot] using h⟩\n  contrapose h\n  simp [nontrivial_iff.mp <| not_subsingleton_iff_nontrivial.mp h, Preconnected, reachable_bot, h]\n\n"}
{"name":"SimpleGraph.bot_preconnected","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\ninst✝ : Subsingleton V\n⊢ Bot.bot.Preconnected","decl":"lemma bot_preconnected [Subsingleton V] : (⊥ : SimpleGraph V).Preconnected :=\n  bot_preconnected_iff_subsingleton.mpr ‹_›\n\n"}
{"name":"SimpleGraph.bot_not_preconnected","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\ninst✝ : Nontrivial V\n⊢ Not Bot.bot.Preconnected","decl":"lemma bot_not_preconnected [Nontrivial V] : ¬(⊥ : SimpleGraph V).Preconnected :=\n  bot_preconnected_iff_subsingleton.not.mpr <| not_subsingleton_iff_nontrivial.mpr ‹_›\n\n"}
{"name":"SimpleGraph.top_preconnected","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\n⊢ Top.top.Preconnected","decl":"lemma top_preconnected : (⊤ : SimpleGraph V).Preconnected := fun x y => by\n  if h : x = y then rw [h] else exact Adj.reachable h\n\n"}
{"name":"SimpleGraph.Iso.preconnected_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nH : SimpleGraph V'\ne : G.Iso H\n⊢ Iff G.Preconnected H.Preconnected","decl":"theorem Iso.preconnected_iff {G : SimpleGraph V} {H : SimpleGraph V'} (e : G ≃g H) :\n    G.Preconnected ↔ H.Preconnected :=\n  ⟨Preconnected.map e.toHom e.toEquiv.surjective,\n    Preconnected.map e.symm.toHom e.symm.toEquiv.surjective⟩\n\n"}
{"name":"SimpleGraph.connected_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Iff G.Connected (And G.Preconnected (Nonempty V))","decl":"/-- A graph is connected if it's preconnected and contains at least one vertex.\nThis follows the convention observed by mathlib that something is connected iff it has\nexactly one connected component.\n\nThere is a `CoeFun` instance so that `h u v` can be used instead of `h.Preconnected u v`. -/\n@[mk_iff]\nstructure Connected : Prop where\n  protected preconnected : G.Preconnected\n  protected [nonempty : Nonempty V]\n\n"}
{"name":"SimpleGraph.Connected.preconnected","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nself : G.Connected\n⊢ G.Preconnected","decl":"/-- A graph is connected if it's preconnected and contains at least one vertex.\nThis follows the convention observed by mathlib that something is connected iff it has\nexactly one connected component.\n\nThere is a `CoeFun` instance so that `h u v` can be used instead of `h.Preconnected u v`. -/\n@[mk_iff]\nstructure Connected : Prop where\n  protected preconnected : G.Preconnected\n  protected [nonempty : Nonempty V]\n\n"}
{"name":"SimpleGraph.Connected.nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nself : G.Connected\n⊢ Nonempty V","decl":"/-- A graph is connected if it's preconnected and contains at least one vertex.\nThis follows the convention observed by mathlib that something is connected iff it has\nexactly one connected component.\n\nThere is a `CoeFun` instance so that `h u v` can be used instead of `h.Preconnected u v`. -/\n@[mk_iff]\nstructure Connected : Prop where\n  protected preconnected : G.Preconnected\n  protected [nonempty : Nonempty V]\n\n"}
{"name":"SimpleGraph.connected_iff_exists_forall_reachable","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Iff G.Connected (Exists fun v => ∀ (w : V), G.Reachable v w)","decl":"lemma connected_iff_exists_forall_reachable : G.Connected ↔ ∃ v, ∀ w, G.Reachable v w := by\n  rw [connected_iff]\n  constructor\n  · rintro ⟨hp, ⟨v⟩⟩\n    exact ⟨v, fun w => hp v w⟩\n  · rintro ⟨v, h⟩\n    exact ⟨fun u w => (h u).symm.trans (h w), ⟨v⟩⟩\n\n"}
{"name":"SimpleGraph.Connected.map","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nH : SimpleGraph V'\nf : G.Hom H\nhf : Function.Surjective ⇑f\nhG : G.Connected\n⊢ H.Connected","decl":"theorem Connected.map {G : SimpleGraph V} {H : SimpleGraph V'} (f : G →g H) (hf : Surjective f)\n    (hG : G.Connected) : H.Connected :=\n  haveI := hG.nonempty.map f\n  ⟨hG.preconnected.map f hf⟩\n\n"}
{"name":"SimpleGraph.Connected.mono","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nhG : G.Connected\n⊢ G'.Connected","decl":"@[mono]\nprotected lemma Connected.mono {G G' : SimpleGraph V} (h : G ≤ G')\n    (hG : G.Connected) : G'.Connected where\n  preconnected := hG.preconnected.mono h\n  nonempty := hG.nonempty\n\n"}
{"name":"SimpleGraph.bot_not_connected","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\ninst✝ : Nontrivial V\n⊢ Not Bot.bot.Connected","decl":"lemma bot_not_connected [Nontrivial V] : ¬(⊥ : SimpleGraph V).Connected := by\n  simp [bot_not_preconnected, connected_iff, ‹_›]\n\n"}
{"name":"SimpleGraph.top_connected","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\ninst✝ : Nonempty V\n⊢ Top.top.Connected","decl":"lemma top_connected [Nonempty V] : (⊤ : SimpleGraph V).Connected where\n  preconnected := top_preconnected\n\n"}
{"name":"SimpleGraph.Iso.connected_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nH : SimpleGraph V'\ne : G.Iso H\n⊢ Iff G.Connected H.Connected","decl":"theorem Iso.connected_iff {G : SimpleGraph V} {H : SimpleGraph V'} (e : G ≃g H) :\n    G.Connected ↔ H.Connected :=\n  ⟨Connected.map e.toHom e.toEquiv.surjective, Connected.map e.symm.toHom e.symm.toEquiv.surjective⟩\n\n"}
{"name":"SimpleGraph.ConnectedComponent.inhabited_default","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Inhabited V\n⊢ Eq Inhabited.default (G.connectedComponentMk Inhabited.default)","decl":"@[simps]\ninstance inhabited [Inhabited V] : Inhabited G.ConnectedComponent :=\n  ⟨G.connectedComponentMk default⟩\n\n"}
{"name":"SimpleGraph.ConnectedComponent.isEmpty","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : IsEmpty V\n⊢ IsEmpty G.ConnectedComponent","decl":"instance isEmpty [IsEmpty V] : IsEmpty (ConnectedComponent G) := by\n  by_contra! hc\n  rw [@not_isEmpty_iff] at hc\n  obtain ⟨v, _⟩ := (Classical.inhabited_of_nonempty hc).default.exists_rep\n  exact IsEmpty.false v\n\n"}
{"name":"SimpleGraph.ConnectedComponent.ind","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nβ : G.ConnectedComponent → Prop\nh : ∀ (v : V), β (G.connectedComponentMk v)\nc : G.ConnectedComponent\n⊢ β c","decl":"@[elab_as_elim]\nprotected theorem ind {β : G.ConnectedComponent → Prop}\n    (h : ∀ v : V, β (G.connectedComponentMk v)) (c : G.ConnectedComponent) : β c :=\n  Quot.ind h c\n\n"}
{"name":"SimpleGraph.ConnectedComponent.ind₂","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nβ : G.ConnectedComponent → G.ConnectedComponent → Prop\nh : ∀ (v w : V), β (G.connectedComponentMk v) (G.connectedComponentMk w)\nc d : G.ConnectedComponent\n⊢ β c d","decl":"@[elab_as_elim]\nprotected theorem ind₂ {β : G.ConnectedComponent → G.ConnectedComponent → Prop}\n    (h : ∀ v w : V, β (G.connectedComponentMk v) (G.connectedComponentMk w))\n    (c d : G.ConnectedComponent) : β c d :=\n  Quot.induction_on₂ c d h\n\n"}
{"name":"SimpleGraph.ConnectedComponent.sound","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\na✝ : G.Reachable v w\n⊢ Eq (G.connectedComponentMk v) (G.connectedComponentMk w)","decl":"protected theorem sound {v w : V} :\n    G.Reachable v w → G.connectedComponentMk v = G.connectedComponentMk w :=\n  Quot.sound\n\n"}
{"name":"SimpleGraph.ConnectedComponent.exact","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\na✝ : Eq (G.connectedComponentMk v) (G.connectedComponentMk w)\n⊢ G.Reachable v w","decl":"protected theorem exact {v w : V} :\n    G.connectedComponentMk v = G.connectedComponentMk w → G.Reachable v w :=\n  @Quotient.exact _ G.reachableSetoid _ _\n\n"}
{"name":"SimpleGraph.ConnectedComponent.eq","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff (Eq (G.connectedComponentMk v) (G.connectedComponentMk w)) (G.Reachable v w)","decl":"@[simp]\nprotected theorem eq {v w : V} :\n    G.connectedComponentMk v = G.connectedComponentMk w ↔ G.Reachable v w :=\n  @Quotient.eq' _ G.reachableSetoid _ _\n\n"}
{"name":"SimpleGraph.ConnectedComponent.connectedComponentMk_eq_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\na : G.Adj v w\n⊢ Eq (G.connectedComponentMk v) (G.connectedComponentMk w)","decl":"theorem connectedComponentMk_eq_of_adj {v w : V} (a : G.Adj v w) :\n    G.connectedComponentMk v = G.connectedComponentMk w :=\n  ConnectedComponent.sound a.reachable\n\n"}
{"name":"SimpleGraph.ConnectedComponent.lift_mk","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nβ : Sort u_1\nf : V → β\nh : ∀ (v w : V) (p : G.Walk v w), p.IsPath → Eq (f v) (f w)\nv : V\n⊢ Eq (SimpleGraph.ConnectedComponent.lift f h (G.connectedComponentMk v)) (f v)","decl":"@[simp]\nprotected theorem lift_mk {β : Sort*} {f : V → β}\n    {h : ∀ (v w : V) (p : G.Walk v w), p.IsPath → f v = f w} {v : V} :\n    ConnectedComponent.lift f h (G.connectedComponentMk v) = f v :=\n  rfl\n\n"}
{"name":"SimpleGraph.ConnectedComponent.exists","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\np : G.ConnectedComponent → Prop\n⊢ Iff (Exists fun c => p c) (Exists fun v => p (G.connectedComponentMk v))","decl":"protected theorem «exists» {p : G.ConnectedComponent → Prop} :\n    (∃ c : G.ConnectedComponent, p c) ↔ ∃ v, p (G.connectedComponentMk v) :=\n  Quot.mk_surjective.exists\n\n"}
{"name":"SimpleGraph.ConnectedComponent.forall","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\np : G.ConnectedComponent → Prop\n⊢ Iff (∀ (c : G.ConnectedComponent), p c) (∀ (v : V), p (G.connectedComponentMk v))","decl":"protected theorem «forall» {p : G.ConnectedComponent → Prop} :\n    (∀ c : G.ConnectedComponent, p c) ↔ ∀ v, p (G.connectedComponentMk v) :=\n  Quot.mk_surjective.forall\n\n"}
{"name":"SimpleGraph.Preconnected.subsingleton_connectedComponent","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nh : G.Preconnected\n⊢ Subsingleton G.ConnectedComponent","decl":"theorem _root_.SimpleGraph.Preconnected.subsingleton_connectedComponent (h : G.Preconnected) :\n    Subsingleton G.ConnectedComponent :=\n  ⟨ConnectedComponent.ind₂ fun v w => ConnectedComponent.sound (h v w)⟩\n\n"}
{"name":"SimpleGraph.ConnectedComponent.map_mk","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nφ : G.Hom G'\nv : V\n⊢ Eq (SimpleGraph.ConnectedComponent.map φ (G.connectedComponentMk v)) (G'.connectedComponentMk (φ v))","decl":"@[simp]\ntheorem map_mk (φ : G →g G') (v : V) :\n    (G.connectedComponentMk v).map φ = G'.connectedComponentMk (φ v) :=\n  rfl\n\n"}
{"name":"SimpleGraph.ConnectedComponent.map_id","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nC : G.ConnectedComponent\n⊢ Eq (SimpleGraph.ConnectedComponent.map SimpleGraph.Hom.id C) C","decl":"@[simp]\ntheorem map_id (C : ConnectedComponent G) : C.map Hom.id = C := by\n  refine C.ind ?_\n  exact fun _ => rfl\n\n"}
{"name":"SimpleGraph.ConnectedComponent.map_comp","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nC : G.ConnectedComponent\nφ : G.Hom G'\nψ : G'.Hom G''\n⊢ Eq (SimpleGraph.ConnectedComponent.map ψ (SimpleGraph.ConnectedComponent.map φ C)) (SimpleGraph.ConnectedComponent.map (ψ.comp φ) C)","decl":"@[simp]\ntheorem map_comp (C : G.ConnectedComponent) (φ : G →g G') (ψ : G' →g G'') :\n    (C.map φ).map ψ = C.map (ψ.comp φ) := by\n  refine C.ind ?_\n  exact fun _ => rfl\n\n"}
{"name":"SimpleGraph.ConnectedComponent.iso_image_comp_eq_map_iff_eq_comp","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nφ : G.Iso G'\nv : V\nC : G.ConnectedComponent\n⊢ Iff (Eq (G'.connectedComponentMk (φ v)) (SimpleGraph.ConnectedComponent.map (RelIso.toRelEmbedding φ).toRelHom C)) (Eq (G.connectedComponentMk v) C)","decl":"@[simp]\ntheorem iso_image_comp_eq_map_iff_eq_comp {C : G.ConnectedComponent} :\n    G'.connectedComponentMk (φ v) = C.map ↑(↑φ : G ↪g G') ↔ G.connectedComponentMk v = C := by\n  refine C.ind fun u => ?_\n  simp only [Iso.reachable_iff, ConnectedComponent.map_mk, RelEmbedding.coe_toRelHom,\n    RelIso.coe_toRelEmbedding, ConnectedComponent.eq]\n\n"}
{"name":"SimpleGraph.ConnectedComponent.iso_inv_image_comp_eq_iff_eq_map","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nφ : G.Iso G'\nv' : V'\nC : G.ConnectedComponent\n⊢ Iff (Eq (G.connectedComponentMk (φ.symm v')) C) (Eq (G'.connectedComponentMk v') (SimpleGraph.ConnectedComponent.map (RelIso.toRelEmbedding φ).toRelHom C))","decl":"@[simp]\ntheorem iso_inv_image_comp_eq_iff_eq_map {C : G.ConnectedComponent} :\n    G.connectedComponentMk (φ.symm v') = C ↔ G'.connectedComponentMk v' = C.map φ := by\n  refine C.ind fun u => ?_\n  simp only [Iso.symm_apply_reachable, ConnectedComponent.eq, ConnectedComponent.map_mk,\n    RelEmbedding.coe_toRelHom, RelIso.coe_toRelEmbedding]\n\n"}
{"name":"SimpleGraph.Iso.connectedComponentEquiv_symm_apply","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nφ : G.Iso G'\nC : G'.ConnectedComponent\n⊢ Eq (φ.connectedComponentEquiv.symm C) (SimpleGraph.ConnectedComponent.map (RelIso.toRelEmbedding φ.symm).toRelHom C)","decl":"/-- An isomorphism of graphs induces a bijection of connected components. -/\n@[simps]\ndef connectedComponentEquiv (φ : G ≃g G') : G.ConnectedComponent ≃ G'.ConnectedComponent where\n  toFun := ConnectedComponent.map φ\n  invFun := ConnectedComponent.map φ.symm\n  left_inv C := ConnectedComponent.ind\n    (fun v => congr_arg G.connectedComponentMk (Equiv.left_inv φ.toEquiv v)) C\n  right_inv C := ConnectedComponent.ind\n    (fun v => congr_arg G'.connectedComponentMk (Equiv.right_inv φ.toEquiv v)) C\n\n"}
{"name":"SimpleGraph.Iso.connectedComponentEquiv_apply","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nφ : G.Iso G'\nC : G.ConnectedComponent\n⊢ Eq (φ.connectedComponentEquiv C) (SimpleGraph.ConnectedComponent.map (RelIso.toRelEmbedding φ).toRelHom C)","decl":"/-- An isomorphism of graphs induces a bijection of connected components. -/\n@[simps]\ndef connectedComponentEquiv (φ : G ≃g G') : G.ConnectedComponent ≃ G'.ConnectedComponent where\n  toFun := ConnectedComponent.map φ\n  invFun := ConnectedComponent.map φ.symm\n  left_inv C := ConnectedComponent.ind\n    (fun v => congr_arg G.connectedComponentMk (Equiv.left_inv φ.toEquiv v)) C\n  right_inv C := ConnectedComponent.ind\n    (fun v => congr_arg G'.connectedComponentMk (Equiv.right_inv φ.toEquiv v)) C\n\n"}
{"name":"SimpleGraph.Iso.connectedComponentEquiv_refl","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq SimpleGraph.Iso.refl.connectedComponentEquiv (Equiv.refl G.ConnectedComponent)","decl":"@[simp]\ntheorem connectedComponentEquiv_refl :\n    (Iso.refl : G ≃g G).connectedComponentEquiv = Equiv.refl _ := by\n  ext ⟨v⟩\n  rfl\n\n"}
{"name":"SimpleGraph.Iso.connectedComponentEquiv_symm","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nφ : G.Iso G'\n⊢ Eq φ.symm.connectedComponentEquiv φ.connectedComponentEquiv.symm","decl":"@[simp]\ntheorem connectedComponentEquiv_symm (φ : G ≃g G') :\n    φ.symm.connectedComponentEquiv = φ.connectedComponentEquiv.symm := by\n  ext ⟨_⟩\n  rfl\n\n"}
{"name":"SimpleGraph.Iso.connectedComponentEquiv_trans","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nφ : G.Iso G'\nφ' : G'.Iso G''\n⊢ Eq (SimpleGraph.Iso.connectedComponentEquiv (RelIso.trans φ φ')) (φ.connectedComponentEquiv.trans φ'.connectedComponentEquiv)","decl":"@[simp]\ntheorem connectedComponentEquiv_trans (φ : G ≃g G') (φ' : G' ≃g G'') :\n    connectedComponentEquiv (φ.trans φ') =\n    φ.connectedComponentEquiv.trans φ'.connectedComponentEquiv := by\n  ext ⟨_⟩\n  rfl\n\n"}
{"name":"SimpleGraph.ConnectedComponent.supp_injective","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Function.Injective SimpleGraph.ConnectedComponent.supp","decl":"@[ext]\ntheorem supp_injective :\n    Function.Injective (ConnectedComponent.supp : G.ConnectedComponent → Set V) := by\n  refine ConnectedComponent.ind₂ ?_\n  intro v w\n  simp only [ConnectedComponent.supp, Set.ext_iff, ConnectedComponent.eq, Set.mem_setOf_eq]\n  intro h\n  rw [reachable_comm, h]\n\n"}
{"name":"SimpleGraph.ConnectedComponent.supp_injective_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\na₁ a₂ : G.ConnectedComponent\n⊢ Iff (Eq a₁ a₂) (Eq a₁.supp a₂.supp)","decl":"@[ext]\ntheorem supp_injective :\n    Function.Injective (ConnectedComponent.supp : G.ConnectedComponent → Set V) := by\n  refine ConnectedComponent.ind₂ ?_\n  intro v w\n  simp only [ConnectedComponent.supp, Set.ext_iff, ConnectedComponent.eq, Set.mem_setOf_eq]\n  intro h\n  rw [reachable_comm, h]\n\n"}
{"name":"SimpleGraph.ConnectedComponent.supp_inj","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nC D : G.ConnectedComponent\n⊢ Iff (Eq C.supp D.supp) (Eq C D)","decl":"@[simp]\ntheorem supp_inj {C D : G.ConnectedComponent} : C.supp = D.supp ↔ C = D :=\n  ConnectedComponent.supp_injective.eq_iff\n\n"}
{"name":"SimpleGraph.ConnectedComponent.mem_supp_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nC : G.ConnectedComponent\nv : V\n⊢ Iff (Membership.mem C.supp v) (Eq (G.connectedComponentMk v) C)","decl":"@[simp]\ntheorem mem_supp_iff (C : G.ConnectedComponent) (v : V) :\n    v ∈ C.supp ↔ G.connectedComponentMk v = C :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.ConnectedComponent.mem_supp_congr_adj","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nc : G.ConnectedComponent\nhadj : G.Adj v w\n⊢ Iff (Membership.mem c.supp v) (Membership.mem c.supp w)","decl":"lemma mem_supp_congr_adj {v w : V} (c : G.ConnectedComponent) (hadj : G.Adj v w) :\n    v ∈ c.supp ↔ w ∈ c.supp := by\n  simp only [ConnectedComponent.mem_supp_iff] at *\n  constructor <;> intro h <;> simp only [← h] <;> apply connectedComponentMk_eq_of_adj\n  · exact hadj.symm\n  · exact hadj\n\n"}
{"name":"SimpleGraph.ConnectedComponent.adj_spanningCoe_induce_supp","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nc : G.ConnectedComponent\n⊢ Iff ((SimpleGraph.induce c.supp G).spanningCoe.Adj v w) (And (Membership.mem c.supp v) (G.Adj v w))","decl":"lemma adj_spanningCoe_induce_supp {v w : V} (c : G.ConnectedComponent) :\n    (G.induce c.supp).spanningCoe.Adj v w ↔ v ∈ c.supp ∧ G.Adj v w := by\n  by_cases h : v ∈ c.supp\n  · refine ⟨by aesop, ?_⟩\n    intro h'\n    have : w ∈ c.supp := by rwa [c.mem_supp_congr_adj h'.2] at h\n    aesop\n  · aesop\n\n"}
{"name":"SimpleGraph.ConnectedComponent.connectedComponentMk_mem","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Membership.mem (G.connectedComponentMk v) v","decl":"theorem connectedComponentMk_mem {v : V} : v ∈ G.connectedComponentMk v :=\n  rfl\n\n"}
{"name":"SimpleGraph.ConnectedComponent.mem_coe_supp_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nH : G.Subgraph\nc : H.coe.ConnectedComponent\nhv : Membership.mem (Set.image Subtype.val ↑c) v\nhw : Membership.mem H.verts w\nhadj : H.Adj v w\n⊢ Membership.mem (Set.image Subtype.val ↑c) w","decl":"lemma mem_coe_supp_of_adj {v w : V} {H : Subgraph G} {c : ConnectedComponent H.coe}\n    (hv : v ∈ (↑) '' (c : Set H.verts)) (hw : w ∈ H.verts)\n    (hadj : H.Adj v w) : w ∈ (↑) '' (c : Set H.verts):= by\n  obtain ⟨_, h⟩ := hv\n  use ⟨w, hw⟩\n  rw [← (mem_supp_iff _ _).mp h.1]\n  exact ⟨connectedComponentMk_eq_of_adj <| Subgraph.Adj.coe <| h.2 ▸ hadj.symm, rfl⟩\n\n"}
{"name":"SimpleGraph.ConnectedComponent.connectedComponentMk_supp_subset_supp","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nv : V\nh : LE.le G G'\nc' : G'.ConnectedComponent\nhc' : Membership.mem c'.supp v\n⊢ HasSubset.Subset (G.connectedComponentMk v).supp c'.supp","decl":"lemma connectedComponentMk_supp_subset_supp {G'} {v : V} (h : G ≤ G') (c' : G'.ConnectedComponent)\n    (hc' : v ∈ c'.supp) : (G.connectedComponentMk v).supp ⊆ c'.supp := by\n  intro v' hv'\n  simp only [mem_supp_iff, ConnectedComponent.eq] at hv' ⊢\n  rw [ConnectedComponent.sound (hv'.mono h)]\n  exact hc'\n\n"}
{"name":"SimpleGraph.ConnectedComponent.biUnion_supp_eq_supp","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\nc' : G'.ConnectedComponent\n⊢ Eq (Set.iUnion fun c => Set.iUnion fun x => c.supp) c'.supp","decl":"lemma biUnion_supp_eq_supp {G G' : SimpleGraph V} (h : G ≤ G') (c' : ConnectedComponent G') :\n    ⋃ (c : ConnectedComponent G) (_ : c.supp ⊆ c'.supp), c.supp = c'.supp := by\n  ext v\n  simp_rw [Set.mem_iUnion]\n  refine ⟨fun ⟨_, ⟨hi, hi'⟩⟩ ↦ hi hi', ?_⟩\n  intro hv\n  use G.connectedComponentMk v\n  use c'.connectedComponentMk_supp_subset_supp h hv\n  simp only [mem_supp_iff]\n\n"}
{"name":"SimpleGraph.ConnectedComponent.top_supp_eq_univ","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nc : Top.top.ConnectedComponent\n⊢ Eq c.supp Set.univ","decl":"lemma top_supp_eq_univ (c : ConnectedComponent (⊤ : SimpleGraph V)) :\n    c.supp = (Set.univ : Set V) := by\n  have ⟨w, hw⟩ := c.exists_rep\n  ext v\n  simp only [Set.mem_univ, iff_true, mem_supp_iff, ← hw]\n  apply SimpleGraph.ConnectedComponent.sound\n  exact (@SimpleGraph.top_connected V (Nonempty.intro v)).preconnected v w\n\n"}
{"name":"SimpleGraph.pairwise_disjoint_supp_connectedComponent","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Pairwise fun c c' => Disjoint c.supp c'.supp","decl":"lemma pairwise_disjoint_supp_connectedComponent (G : SimpleGraph V) :\n    Pairwise fun c c' : ConnectedComponent G ↦ Disjoint c.supp c'.supp := by\n  simp_rw [Set.disjoint_left]\n  intro _ _ h a hsx hsy\n  rw [ConnectedComponent.mem_supp_iff] at hsx hsy\n  rw [hsx] at hsy\n  exact h hsy\n\n-- TODO: Extract as lemma about general equivalence relation\n"}
{"name":"SimpleGraph.iUnion_connectedComponentSupp","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq (Set.iUnion fun c => c.supp) Set.univ","decl":"lemma iUnion_connectedComponentSupp (G : SimpleGraph V) :\n    ⋃ c : G.ConnectedComponent, c.supp = Set.univ := by\n  refine Set.eq_univ_of_forall fun v ↦ ⟨G.connectedComponentMk v, ?_⟩\n  simp only [Set.mem_range, SetLike.mem_coe]\n  exact ⟨by use G.connectedComponentMk v; exact rfl, rfl⟩\n\n"}
{"name":"SimpleGraph.Preconnected.set_univ_walk_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nhconn : G.Preconnected\nu v : V\n⊢ Set.univ.Nonempty","decl":"theorem Preconnected.set_univ_walk_nonempty (hconn : G.Preconnected) (u v : V) :\n    (Set.univ : Set (G.Walk u v)).Nonempty := by\n  rw [← Set.nonempty_iff_univ_nonempty]\n  exact hconn u v\n\n"}
{"name":"SimpleGraph.Connected.set_univ_walk_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nhconn : G.Connected\nu v : V\n⊢ Set.univ.Nonempty","decl":"theorem Connected.set_univ_walk_nonempty (hconn : G.Connected) (u v : V) :\n    (Set.univ : Set (G.Walk u v)).Nonempty :=\n  hconn.preconnected.set_univ_walk_nonempty u v\n\n"}
{"name":"SimpleGraph.isBridge_iff","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Iff (G.IsBridge (Sym2.mk { fst := u, snd := v })) (And (G.Adj u v) (Not ((SDiff.sdiff G (SimpleGraph.fromEdgeSet (Singleton.singleton (Sym2.mk { fst := u, snd := v })))).Reachable u v)))","decl":"theorem isBridge_iff {u v : V} :\n    G.IsBridge s(u, v) ↔ G.Adj u v ∧ ¬(G \\ fromEdgeSet {s(u, v)}).Reachable u v := Iff.rfl\n\n"}
{"name":"SimpleGraph.reachable_delete_edges_iff_exists_walk","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff ((SDiff.sdiff G (SimpleGraph.fromEdgeSet (Singleton.singleton (Sym2.mk { fst := v, snd := w })))).Reachable v w) (Exists fun p => Not (Membership.mem p.edges (Sym2.mk { fst := v, snd := w })))","decl":"theorem reachable_delete_edges_iff_exists_walk {v w : V} :\n    (G \\ fromEdgeSet {s(v, w)}).Reachable v w ↔ ∃ p : G.Walk v w, ¬s(v, w) ∈ p.edges := by\n  constructor\n  · rintro ⟨p⟩\n    use p.map (Hom.mapSpanningSubgraphs (by simp))\n    simp_rw [Walk.edges_map, List.mem_map, Hom.mapSpanningSubgraphs_apply, Sym2.map_id', id]\n    rintro ⟨e, h, rfl⟩\n    simpa using p.edges_subset_edgeSet h\n  · rintro ⟨p, h⟩\n    refine ⟨p.transfer _ fun e ep => ?_⟩\n    simp only [edgeSet_sdiff, edgeSet_fromEdgeSet, edgeSet_sdiff_sdiff_isDiag, Set.mem_diff,\n      Set.mem_singleton_iff]\n    exact ⟨p.edges_subset_edgeSet ep, fun h' => h (h' ▸ ep)⟩\n\n"}
{"name":"SimpleGraph.isBridge_iff_adj_and_forall_walk_mem_edges","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff (G.IsBridge (Sym2.mk { fst := v, snd := w })) (And (G.Adj v w) (∀ (p : G.Walk v w), Membership.mem p.edges (Sym2.mk { fst := v, snd := w })))","decl":"theorem isBridge_iff_adj_and_forall_walk_mem_edges {v w : V} :\n    G.IsBridge s(v, w) ↔ G.Adj v w ∧ ∀ p : G.Walk v w, s(v, w) ∈ p.edges := by\n  rw [isBridge_iff, and_congr_right']\n  rw [reachable_delete_edges_iff_exists_walk, not_exists_not]\n\n"}
{"name":"SimpleGraph.reachable_deleteEdges_iff_exists_cycle.aux","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nu v w : V\nhb : ∀ (p : G.Walk v w), Membership.mem p.edges (Sym2.mk { fst := v, snd := w })\nc : G.Walk u u\nhc : c.IsTrail\nhe : Membership.mem c.edges (Sym2.mk { fst := v, snd := w })\nhw : Membership.mem (c.takeUntil v ⋯).support w\n⊢ False","decl":"theorem reachable_deleteEdges_iff_exists_cycle.aux [DecidableEq V] {u v w : V}\n    (hb : ∀ p : G.Walk v w, s(v, w) ∈ p.edges) (c : G.Walk u u) (hc : c.IsTrail)\n    (he : s(v, w) ∈ c.edges)\n    (hw : w ∈ (c.takeUntil v (c.fst_mem_support_of_mem_edges he)).support) : False := by\n  have hv := c.fst_mem_support_of_mem_edges he\n  -- decompose c into\n  --      puw     pwv     pvu\n  --   u ----> w ----> v ----> u\n  let puw := (c.takeUntil v hv).takeUntil w hw\n  let pwv := (c.takeUntil v hv).dropUntil w hw\n  let pvu := c.dropUntil v hv\n  have : c = (puw.append pwv).append pvu := by simp [puw, pwv, pvu]\n  -- We have two walks from v to w\n  --      pvu     puw\n  --   v ----> u ----> w\n  --   |               ^\n  --    `-------------'\n  --      pwv.reverse\n  -- so they both contain the edge s(v, w), but that's a contradiction since c is a trail.\n  have hbq := hb (pvu.append puw)\n  have hpq' := hb pwv.reverse\n  rw [Walk.edges_reverse, List.mem_reverse] at hpq'\n  rw [Walk.isTrail_def, this, Walk.edges_append, Walk.edges_append, List.nodup_append_comm,\n    ← List.append_assoc, ← Walk.edges_append] at hc\n  exact List.disjoint_of_nodup_append hc hbq hpq'\n\n"}
{"name":"SimpleGraph.adj_and_reachable_delete_edges_iff_exists_cycle","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff (And (G.Adj v w) ((SDiff.sdiff G (SimpleGraph.fromEdgeSet (Singleton.singleton (Sym2.mk { fst := v, snd := w })))).Reachable v w)) (Exists fun u => Exists fun p => And p.IsCycle (Membership.mem p.edges (Sym2.mk { fst := v, snd := w })))","decl":"theorem adj_and_reachable_delete_edges_iff_exists_cycle {v w : V} :\n    G.Adj v w ∧ (G \\ fromEdgeSet {s(v, w)}).Reachable v w ↔\n      ∃ (u : V) (p : G.Walk u u), p.IsCycle ∧ s(v, w) ∈ p.edges := by\n  classical\n  rw [reachable_delete_edges_iff_exists_walk]\n  constructor\n  · rintro ⟨h, p, hp⟩\n    refine ⟨w, Walk.cons h.symm p.toPath, ?_, ?_⟩\n    · apply Path.cons_isCycle\n      rw [Sym2.eq_swap]\n      intro h\n      cases hp (Walk.edges_toPath_subset p h)\n    · simp only [Sym2.eq_swap, Walk.edges_cons, List.mem_cons, eq_self_iff_true, true_or]\n  · rintro ⟨u, c, hc, he⟩\n    refine ⟨c.adj_of_mem_edges he, ?_⟩\n    by_contra! hb\n    have hb' : ∀ p : G.Walk w v, s(w, v) ∈ p.edges := by\n      intro p\n      simpa [Sym2.eq_swap] using hb p.reverse\n    have hvc : v ∈ c.support := Walk.fst_mem_support_of_mem_edges c he\n    refine reachable_deleteEdges_iff_exists_cycle.aux hb' (c.rotate hvc) (hc.isTrail.rotate hvc)\n      ?_ (Walk.start_mem_support _)\n    rwa [(Walk.rotate_edges c hvc).mem_iff, Sym2.eq_swap]\n\n"}
{"name":"SimpleGraph.isBridge_iff_adj_and_forall_cycle_not_mem","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff (G.IsBridge (Sym2.mk { fst := v, snd := w })) (And (G.Adj v w) (∀ ⦃u : V⦄ (p : G.Walk u u), p.IsCycle → Not (Membership.mem p.edges (Sym2.mk { fst := v, snd := w }))))","decl":"theorem isBridge_iff_adj_and_forall_cycle_not_mem {v w : V} : G.IsBridge s(v, w) ↔\n    G.Adj v w ∧ ∀ ⦃u : V⦄ (p : G.Walk u u), p.IsCycle → s(v, w) ∉ p.edges := by\n  rw [isBridge_iff, and_congr_right_iff]\n  intro h\n  rw [← not_iff_not]\n  push_neg\n  rw [← adj_and_reachable_delete_edges_iff_exists_cycle]\n  simp only [h, true_and]\n\n"}
{"name":"SimpleGraph.isBridge_iff_mem_and_forall_cycle_not_mem","module":"Mathlib.Combinatorics.SimpleGraph.Path","initialProofState":"V : Type u\nG : SimpleGraph V\ne : Sym2 V\n⊢ Iff (G.IsBridge e) (And (Membership.mem G.edgeSet e) (∀ ⦃u : V⦄ (p : G.Walk u u), p.IsCycle → Not (Membership.mem p.edges e)))","decl":"theorem isBridge_iff_mem_and_forall_cycle_not_mem {e : Sym2 V} :\n    G.IsBridge e ↔ e ∈ G.edgeSet ∧ ∀ ⦃u : V⦄ (p : G.Walk u u), p.IsCycle → e ∉ p.edges :=\n  Sym2.ind (fun _ _ => isBridge_iff_adj_and_forall_cycle_not_mem) e\n\n"}
