{"name":"tsum_eq_tsum_primes_of_support_subset_prime_powers","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"α : Type u_1\ninst✝⁴ : AddCommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformAddGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nf : Nat → α\nhfm : Summable f\nhf : HasSubset.Subset (Function.support f) (setOf fun n => IsPrimePow n)\n⊢ Eq (tsum fun n => f n) (tsum fun p => tsum fun k => f (HPow.hPow (↑p) (HAdd.hAdd k 1)))","decl":"open Nat.Primes in\n@[to_additive tsum_eq_tsum_primes_of_support_subset_prime_powers]\nlemma tprod_eq_tprod_primes_of_mulSupport_subset_prime_powers {f : ℕ → α}\n    (hfm : Multipliable f) (hf : Function.mulSupport f ⊆ {n | IsPrimePow n}) :\n    ∏' n : ℕ, f n = ∏' (p : Nat.Primes) (k : ℕ), f (p ^ (k + 1)) := by\n  have hfm' : Multipliable fun pk : Nat.Primes × ℕ ↦ f (pk.fst ^ (pk.snd + 1)) :=\n    prodNatEquiv.symm.multipliable_iff.mp <| by\n      simpa only [← coe_prodNatEquiv_apply, Prod.eta, Function.comp_def, Equiv.apply_symm_apply]\n        using hfm.subtype _\n  simp only [← tprod_subtype_eq_of_mulSupport_subset hf, Set.coe_setOf, ← prodNatEquiv.tprod_eq,\n    ← tprod_prod hfm']\n  refine tprod_congr fun (p, k) ↦ congrArg f <| coe_prodNatEquiv_apply ..\n\n"}
{"name":"tprod_eq_tprod_primes_of_mulSupport_subset_prime_powers","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"α : Type u_1\ninst✝⁴ : CommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nf : Nat → α\nhfm : Multipliable f\nhf : HasSubset.Subset (Function.mulSupport f) (setOf fun n => IsPrimePow n)\n⊢ Eq (tprod fun n => f n) (tprod fun p => tprod fun k => f (HPow.hPow (↑p) (HAdd.hAdd k 1)))","decl":"open Nat.Primes in\n@[to_additive tsum_eq_tsum_primes_of_support_subset_prime_powers]\nlemma tprod_eq_tprod_primes_of_mulSupport_subset_prime_powers {f : ℕ → α}\n    (hfm : Multipliable f) (hf : Function.mulSupport f ⊆ {n | IsPrimePow n}) :\n    ∏' n : ℕ, f n = ∏' (p : Nat.Primes) (k : ℕ), f (p ^ (k + 1)) := by\n  have hfm' : Multipliable fun pk : Nat.Primes × ℕ ↦ f (pk.fst ^ (pk.snd + 1)) :=\n    prodNatEquiv.symm.multipliable_iff.mp <| by\n      simpa only [← coe_prodNatEquiv_apply, Prod.eta, Function.comp_def, Equiv.apply_symm_apply]\n        using hfm.subtype _\n  simp only [← tprod_subtype_eq_of_mulSupport_subset hf, Set.coe_setOf, ← prodNatEquiv.tprod_eq,\n    ← tprod_prod hfm']\n  refine tprod_congr fun (p, k) ↦ congrArg f <| coe_prodNatEquiv_apply ..\n\n"}
{"name":"tsum_eq_tsum_primes_add_tsum_primes_of_support_subset_prime_powers","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"α : Type u_1\ninst✝⁴ : AddCommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformAddGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nf : Nat → α\nhfm : Summable f\nhf : HasSubset.Subset (Function.support f) (setOf fun n => IsPrimePow n)\n⊢ Eq (tsum fun n => f n) (HAdd.hAdd (tsum fun p => f ↑p) (tsum fun p => tsum fun k => f (HPow.hPow (↑p) (HAdd.hAdd k 2))))","decl":"@[to_additive tsum_eq_tsum_primes_add_tsum_primes_of_support_subset_prime_powers]\nlemma tprod_eq_tprod_primes_mul_tprod_primes_of_mulSupport_subset_prime_powers {f : ℕ → α}\n    (hfm : Multipliable f) (hf : Function.mulSupport f ⊆ {n | IsPrimePow n}) :\n    ∏' n : ℕ, f n = (∏' p : Nat.Primes, f p) *  ∏' (p : Nat.Primes) (k : ℕ), f (p ^ (k + 2)) := by\n  rw [tprod_eq_tprod_primes_of_mulSupport_subset_prime_powers hfm hf]\n  have hfs' (p : Nat.Primes) : Multipliable fun k : ℕ ↦ f (p ^ (k + 1)) :=\n    hfm.comp_injective <| (strictMono_nat_of_lt_succ\n      fun k ↦ pow_lt_pow_right₀ p.prop.one_lt <| lt_add_one (k + 1)).injective\n  conv_lhs =>\n    enter [1, p]; rw [tprod_eq_zero_mul (hfs' p), zero_add, pow_one]\n    enter [2, 1, k]; rw [add_assoc, one_add_one_eq_two]\n  exact tprod_mul (Multipliable.subtype hfm _) <|\n    Multipliable.prod (f := fun (pk : Nat.Primes × ℕ) ↦ f (pk.1 ^ (pk.2 + 2))) <|\n    hfm.comp_injective <| Subtype.val_injective |>.comp\n    Nat.Primes.prodNatEquiv.injective |>.comp <|\n    Function.Injective.prodMap (fun ⦃_ _⦄ a ↦ a) <| add_left_injective 1\n\n"}
{"name":"tprod_eq_tprod_primes_mul_tprod_primes_of_mulSupport_subset_prime_powers","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"α : Type u_1\ninst✝⁴ : CommGroup α\ninst✝³ : UniformSpace α\ninst✝² : UniformGroup α\ninst✝¹ : CompleteSpace α\ninst✝ : T0Space α\nf : Nat → α\nhfm : Multipliable f\nhf : HasSubset.Subset (Function.mulSupport f) (setOf fun n => IsPrimePow n)\n⊢ Eq (tprod fun n => f n) (HMul.hMul (tprod fun p => f ↑p) (tprod fun p => tprod fun k => f (HPow.hPow (↑p) (HAdd.hAdd k 2))))","decl":"@[to_additive tsum_eq_tsum_primes_add_tsum_primes_of_support_subset_prime_powers]\nlemma tprod_eq_tprod_primes_mul_tprod_primes_of_mulSupport_subset_prime_powers {f : ℕ → α}\n    (hfm : Multipliable f) (hf : Function.mulSupport f ⊆ {n | IsPrimePow n}) :\n    ∏' n : ℕ, f n = (∏' p : Nat.Primes, f p) *  ∏' (p : Nat.Primes) (k : ℕ), f (p ^ (k + 2)) := by\n  rw [tprod_eq_tprod_primes_of_mulSupport_subset_prime_powers hfm hf]\n  have hfs' (p : Nat.Primes) : Multipliable fun k : ℕ ↦ f (p ^ (k + 1)) :=\n    hfm.comp_injective <| (strictMono_nat_of_lt_succ\n      fun k ↦ pow_lt_pow_right₀ p.prop.one_lt <| lt_add_one (k + 1)).injective\n  conv_lhs =>\n    enter [1, p]; rw [tprod_eq_zero_mul (hfs' p), zero_add, pow_one]\n    enter [2, 1, k]; rw [add_assoc, one_add_one_eq_two]\n  exact tprod_mul (Multipliable.subtype hfm _) <|\n    Multipliable.prod (f := fun (pk : Nat.Primes × ℕ) ↦ f (pk.1 ^ (pk.2 + 2))) <|\n    hfm.comp_injective <| Subtype.val_injective |>.comp\n    Nat.Primes.prodNatEquiv.injective |>.comp <|\n    Function.Injective.prodMap (fun ⦃_ _⦄ a ↦ a) <| add_left_injective 1\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.residueClass_nonneg","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\nn : Nat\n⊢ LE.le 0 (ArithmeticFunction.vonMangoldt.residueClass a n)","decl":"lemma residueClass_nonneg (n : ℕ) : 0 ≤ residueClass a n :=\n  Set.indicator_apply_nonneg fun _ ↦ vonMangoldt_nonneg\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.residueClass_le","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\nn : Nat\n⊢ LE.le (ArithmeticFunction.vonMangoldt.residueClass a n) (ArithmeticFunction.vonMangoldt n)","decl":"lemma residueClass_le (n : ℕ) : residueClass a n ≤ vonMangoldt n :=\n  Set.indicator_apply_le' (fun _ ↦ le_rfl) (fun _ ↦ vonMangoldt_nonneg)\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.residueClass_apply_zero","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\n⊢ Eq (ArithmeticFunction.vonMangoldt.residueClass a 0) 0","decl":"@[simp]\nlemma residueClass_apply_zero : residueClass a 0 = 0 := by\n  simp only [Set.indicator_apply_eq_zero, Set.mem_setOf_eq, Nat.cast_zero, map_zero, ofReal_zero,\n    implies_true]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.abscissaOfAbsConv_residueClass_le_one","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\n⊢ LE.le (LSeries.abscissaOfAbsConv fun n => ↑(ArithmeticFunction.vonMangoldt.residueClass a n)) 1","decl":"lemma abscissaOfAbsConv_residueClass_le_one :\n    abscissaOfAbsConv ↗(residueClass a) ≤ 1 := by\n  refine abscissaOfAbsConv_le_of_forall_lt_LSeriesSummable fun y hy ↦ ?_\n  unfold LSeriesSummable\n  have := LSeriesSummable_vonMangoldt <| show 1 < (y : ℂ).re by simp only [ofReal_re, hy]\n  convert this.indicator {n : ℕ | (n : ZMod q) = a}\n  ext1 n\n  by_cases hn : (n : ZMod q) = a\n  · simp +contextual only [term, Set.indicator, Set.mem_setOf_eq, hn, ↓reduceIte, apply_ite,\n      ite_self]\n  · simp +contextual only [term, Set.mem_setOf_eq, hn, not_false_eq_true, Set.indicator_of_not_mem,\n      ofReal_zero, zero_div, ite_self]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.support_residueClass_prime_div","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\n⊢ Eq (Function.support fun n => HDiv.hDiv (ite (Nat.Prime n) (ArithmeticFunction.vonMangoldt.residueClass a n) 0) ↑n) (setOf fun p => And (Nat.Prime p) (Eq (↑p) a))","decl":"/-- The set we are interested in (prime numbers in the residue class `a`) is the same as the support\nof `ArithmeticFunction.vonMangoldt.residueClass` restricted to primes (and divided by `n`;\nthis is how this result is used later). -/\nlemma support_residueClass_prime_div :\n    Function.support (fun n : ℕ ↦ (if n.Prime then residueClass a n else 0) / n) =\n      {p : ℕ | p.Prime ∧ (p : ZMod q) = a} := by\n  simp only [Function.support, ne_eq, div_eq_zero_iff, ite_eq_right_iff,\n    Set.indicator_apply_eq_zero, Set.mem_setOf_eq, Nat.cast_eq_zero, not_or, Classical.not_imp]\n  ext1 p\n  simp only [Set.mem_setOf_eq]\n  exact ⟨fun H ↦ ⟨H.1.1, H.1.2.1⟩,\n    fun H ↦ ⟨⟨H.1, H.2, vonMangoldt_ne_zero_iff.mpr H.1.isPrimePow⟩, H.1.ne_zero⟩⟩\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.summable_residueClass_non_primes_div","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\n⊢ Summable fun n => HDiv.hDiv (ite (Nat.Prime n) 0 (ArithmeticFunction.vonMangoldt.residueClass a n)) ↑n","decl":"/-- The function `n ↦ Λ n / n`, restricted to non-primes in a residue class, is summable.\nThis is used to convert results on `ArithmeticFunction.vonMangoldt.residueClass` to results\non primes in an arithmetic progression. -/\nlemma summable_residueClass_non_primes_div :\n    Summable fun n : ℕ ↦ (if n.Prime then 0 else residueClass a n) / n := by\n  have h₀ (n : ℕ) : 0 ≤ (if n.Prime then 0 else residueClass a n) / n := by\n    have := residueClass_nonneg a n\n    positivity\n  have hleF₀ (n : ℕ) : (if n.Prime then 0 else residueClass a n) / n ≤ F₀ n := by\n    refine div_le_div_of_nonneg_right ?_ n.cast_nonneg\n    split_ifs; exacts [le_rfl, residueClass_le a n]\n  refine Summable.of_nonneg_of_le h₀ hleF₀ ?_\n  have hF₀ (p : Nat.Primes) : F₀ p.val = 0 := by\n    simp only [p.prop, ↓reduceIte, zero_div, F₀]\n  refine (summable_subtype_iff_indicator (s := {n | IsPrimePow n}).mp ?_).congr\n      fun n ↦ Set.indicator_apply_eq_self.mpr fun (hn : ¬ IsPrimePow n) ↦ ?_\n  swap\n  · simp +contextual only [div_eq_zero_iff, ite_eq_left_iff, vonMangoldt_eq_zero_iff, hn,\n      not_false_eq_true, implies_true, Nat.cast_eq_zero, true_or, F₀]\n  have hFF' :\n      F₀ ∘ Subtype.val (p := fun n ↦ n ∈ {n | IsPrimePow n}) = F' ∘ ⇑prodNatEquiv.symm := by\n    refine (Equiv.eq_comp_symm prodNatEquiv (F₀ ∘ Subtype.val) F').mpr ?_\n    ext1 n\n    simp only [Function.comp_apply, F']\n    congr\n  rw [hFF']\n  refine (Nat.Primes.prodNatEquiv.symm.summable_iff (f := F')).mpr ?_\n  have hF'₀ (p : Nat.Primes) : F' (p, 0) = 0 := by simp only [zero_add, pow_one, hF₀, F']\n  have hF'₁ : F'' = F' ∘ (Prod.map _root_.id (· + 1)) := by\n    ext1\n    simp only [Function.comp_apply, Prod.map_fst, id_eq, Prod.map_snd, F'', F']\n  refine (Function.Injective.summable_iff ?_ fun u hu ↦ ?_).mp <| hF'₁ ▸ summable_F''\n  · exact Function.Injective.prodMap (fun ⦃a₁ a₂⦄ a ↦ a) <| add_left_injective 1\n  · simp only [Set.range_prod_map, Set.range_id, Set.mem_prod, Set.mem_univ, Set.mem_range,\n      Nat.exists_add_one_eq, true_and, not_lt, nonpos_iff_eq_zero] at hu\n    rw [← hF'₀ u.1, ← hu]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.residueClass_apply","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\ninst✝ : NeZero q\nha : IsUnit a\nn : Nat\n⊢ Eq (↑(ArithmeticFunction.vonMangoldt.residueClass a n)) (HMul.hMul (Inv.inv ↑q.totient) (Finset.univ.sum fun χ => HMul.hMul (HMul.hMul (χ (Inv.inv a)) (χ ↑n)) ↑(ArithmeticFunction.vonMangoldt n)))","decl":"/-- We can express `ArithmeticFunction.vonMangoldt.residueClass` as a linear combination\nof twists of the von Mangoldt function by Dirichlet characters. -/\nlemma residueClass_apply (ha : IsUnit a) (n : ℕ) :\n    residueClass a n =\n      (q.totient : ℂ)⁻¹ * ∑ χ : DirichletCharacter ℂ q, χ a⁻¹ * χ n * vonMangoldt n := by\n  rw [eq_inv_mul_iff_mul_eq₀ <| mod_cast (Nat.totient_pos.mpr q.pos_of_neZero).ne']\n  simp +contextual only [residueClass, Set.indicator_apply, Set.mem_setOf_eq, apply_ite,\n    ofReal_zero, mul_zero, ← Finset.sum_mul, sum_char_inv_mul_char_eq ℂ ha n, eq_comm (a := a),\n    ite_mul, zero_mul, ↓reduceIte, ite_self]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.residueClass_eq","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\ninst✝ : NeZero q\nha : IsUnit a\n⊢ Eq (fun n => ↑(ArithmeticFunction.vonMangoldt.residueClass a n)) (HSMul.hSMul (Inv.inv ↑q.totient) (Finset.univ.sum fun χ => HSMul.hSMul (χ (Inv.inv a)) fun n => HMul.hMul (χ ↑n) ↑(ArithmeticFunction.vonMangoldt n)))","decl":"/-- We can express `ArithmeticFunction.vonMangoldt.residueClass` as a linear combination\nof twists of the von Mangoldt function by Dirichlet characters. -/\nlemma residueClass_eq (ha : IsUnit a) :\n    ↗(residueClass a) = (q.totient : ℂ)⁻¹ •\n      ∑ χ : DirichletCharacter ℂ q, χ a⁻¹ • (fun n : ℕ ↦ χ n * vonMangoldt n) := by\n  ext1 n\n  simpa only [Pi.smul_apply, Finset.sum_apply, smul_eq_mul, ← mul_assoc]\n    using residueClass_apply ha n\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.LSeries_residueClass_eq","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\ninst✝ : NeZero q\nha : IsUnit a\ns : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (LSeries (fun n => ↑(ArithmeticFunction.vonMangoldt.residueClass a n)) s) (HMul.hMul (Neg.neg (Inv.inv ↑q.totient)) (Finset.univ.sum fun χ => HMul.hMul (χ (Inv.inv a)) (HDiv.hDiv (deriv (DirichletCharacter.LFunction χ) s) (DirichletCharacter.LFunction χ s))))","decl":"/-- The L-series of the von Mangoldt function restricted to the residue class `a` mod `q`\nwith `a` invertible in `ZMod q` is a linear combination of logarithmic derivatives of\nL-functions of the Dirichlet characters mod `q` (on `re s > 1`). -/\nlemma LSeries_residueClass_eq (ha : IsUnit a) {s : ℂ} (hs : 1 < s.re) :\n    LSeries ↗(residueClass a) s =\n      -(q.totient : ℂ)⁻¹ * ∑ χ : DirichletCharacter ℂ q, χ a⁻¹ *\n        (deriv (LFunction χ) s / LFunction χ s) := by\n  simp only [deriv_LFunction_eq_deriv_LSeries _ hs, LFunction_eq_LSeries _ hs, neg_mul, ← mul_neg,\n    ← Finset.sum_neg_distrib, ← neg_div, ← LSeries_twist_vonMangoldt_eq _ hs]\n  rw [eq_inv_mul_iff_mul_eq₀ <| mod_cast (Nat.totient_pos.mpr q.pos_of_neZero).ne']\n  simp_rw [← LSeries_smul,\n    ← LSeries_sum <| fun χ _ ↦ (LSeriesSummable_twist_vonMangoldt χ hs).smul _]\n  refine LSeries_congr s fun {n} _ ↦ ?_\n  simp only [Pi.smul_apply, residueClass_apply ha, smul_eq_mul, ← mul_assoc,\n    mul_inv_cancel_of_invertible, one_mul, Finset.sum_apply, Pi.mul_apply]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.continuousOn_LFunctionResidueClassAux'","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\ninst✝ : NeZero q\n⊢ ContinuousOn (ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux a) (setOf fun s => Or (Eq s 1) (∀ (χ : DirichletCharacter Complex q), Ne (DirichletCharacter.LFunction χ s) 0))","decl":"/-- The auxiliary function is continuous away from the zeros of the L-functions of the Dirichlet\ncharacters mod `q` (including at `s = 1`). -/\nlemma continuousOn_LFunctionResidueClassAux' :\n    ContinuousOn (LFunctionResidueClassAux a)\n      {s | s = 1 ∨ ∀ χ : DirichletCharacter ℂ q, LFunction χ s ≠ 0} := by\n  rw [show LFunctionResidueClassAux a = fun s ↦ _ from rfl]\n  simp only [LFunctionResidueClassAux, sub_eq_add_neg]\n  refine continuousOn_const.mul <| ContinuousOn.add ?_ ?_\n  · refine (continuousOn_neg_logDeriv_LFunctionTrivChar₁ q).mono fun s hs ↦ ?_\n    have := LFunction_ne_zero_of_one_le_re (1 : DirichletCharacter ℂ q) (s := s)\n    simp only [ne_eq, Set.mem_setOf_eq] at hs\n    tauto\n  · simp only [← Finset.sum_neg_distrib, mul_div_assoc, ← mul_neg, ← neg_div]\n    refine continuousOn_finset_sum _ fun χ hχ ↦ continuousOn_const.mul ?_\n    replace hχ : χ ≠ 1 := by simpa only [ne_eq, Finset.mem_compl, Finset.mem_singleton] using hχ\n    refine (continuousOn_neg_logDeriv_LFunction_of_nontriv hχ).mono fun s hs ↦ ?_\n    simp only [ne_eq, Set.mem_setOf_eq] at hs\n    rcases hs with rfl | hs\n    · simp only [ne_eq, Set.mem_setOf_eq, one_re, le_refl,\n        LFunction_ne_zero_of_one_le_re χ (.inl hχ), not_false_eq_true]\n    · exact hs χ\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.continuousOn_LFunctionResidueClassAux","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\ninst✝ : NeZero q\n⊢ ContinuousOn (ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux a) (setOf fun s => LE.le 1 s.re)","decl":"/-- The L-series of the von Mangoldt function restricted to the prime residue class `a` mod `q`\nis continuous on `re s ≥ 1` except for a simple pole at `s = 1` with residue `(q.totient)⁻¹`.\nThe statement as given here in terms of `ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux`\nis equivalent. -/\nlemma continuousOn_LFunctionResidueClassAux :\n    ContinuousOn (LFunctionResidueClassAux a) {s | 1 ≤ s.re} := by\n  refine (continuousOn_LFunctionResidueClassAux' a).mono fun s hs ↦ ?_\n  rcases eq_or_ne s 1 with rfl | hs₁\n  · simp only [ne_eq, Set.mem_setOf_eq, true_or]\n  · simp only [ne_eq, Set.mem_setOf_eq, hs₁, false_or]\n    exact fun χ ↦ LFunction_ne_zero_of_one_le_re χ (.inr hs₁) <| Set.mem_setOf.mp hs\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.eqOn_LFunctionResidueClassAux","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\ninst✝ : NeZero q\nha : IsUnit a\n⊢ Set.EqOn (ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux a) (fun s => HSub.hSub (LSeries (fun n => ↑(ArithmeticFunction.vonMangoldt.residueClass a n)) s) (HDiv.hDiv (Inv.inv ↑q.totient) (HSub.hSub s 1))) (setOf fun s => LT.lt 1 s.re)","decl":"/-- The auxiliary function agrees on `re s > 1` with the L-series of the von Mangoldt function\nrestricted to the residue class `a : ZMod q` minus the principal part `(q.totient)⁻¹/(s-1)`\nof its pole at `s = 1`. -/\nlemma eqOn_LFunctionResidueClassAux (ha : IsUnit a) :\n    Set.EqOn (LFunctionResidueClassAux a)\n      (fun s ↦ L ↗(residueClass a) s - (q.totient : ℂ)⁻¹ / (s - 1))\n      {s | 1 < s.re} := by\n  intro s hs\n  replace hs := Set.mem_setOf.mp hs\n  simp only [LSeries_residueClass_eq ha hs, LFunctionResidueClassAux]\n  rw [neg_div, ← neg_add', mul_neg, ← neg_mul, div_eq_mul_one_div (q.totient : ℂ)⁻¹,\n    sub_eq_add_neg, ← neg_mul, ← mul_add]\n  congrm (_ * ?_)\n  -- this should be easier, but `IsUnit.inv ha` does not work here\n  have ha' : IsUnit a⁻¹ := isUnit_of_dvd_one ⟨a, (ZMod.inv_mul_of_unit a ha).symm⟩\n  classical -- for `Fintype.sum_eq_add_sum_compl`\n  rw [Fintype.sum_eq_add_sum_compl 1, MulChar.one_apply ha', one_mul, add_right_comm]\n  simp only [mul_div_assoc]\n  congrm (?_ + _)\n  have hs₁ : s ≠ 1 := fun h ↦ ((h ▸ hs).trans_eq one_re).false\n  rw [deriv_LFunctionTrivChar₁_apply_of_ne_one _ hs₁, LFunctionTrivChar₁,\n    Function.update_of_ne hs₁, LFunctionTrivChar, add_div,\n    mul_div_mul_left _ _ (sub_ne_zero_of_ne hs₁)]\n  conv_lhs => enter [2, 1]; rw [← mul_one (LFunction ..)]\n  rw [mul_comm _ 1, mul_div_mul_right _ _ <| LFunction_ne_zero_of_one_le_re 1 (.inr hs₁) hs.le]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux_real","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\na : ZMod q\ninst✝ : NeZero q\nha : IsUnit a\nx : Real\nhx : LT.lt 1 x\n⊢ Eq (ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux a ↑x) ↑(ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux a ↑x).re","decl":"/-- The auxiliary function takes real values for real arguments `x > 1`. -/\nlemma LFunctionResidueClassAux_real (ha : IsUnit a) {x : ℝ} (hx : 1 < x) :\n    LFunctionResidueClassAux a x = (LFunctionResidueClassAux a x).re := by\n  rw [eqOn_LFunctionResidueClassAux ha hx]\n  simp only [sub_re, ofReal_sub]\n  congr 1\n  · rw [LSeries, re_tsum <| LSeriesSummable_of_abscissaOfAbsConv_lt_re <|\n      (abscissaOfAbsConv_residueClass_le_one a).trans_lt <| by norm_cast]\n    push_cast\n    refine tsum_congr fun n ↦ ?_\n    rcases eq_or_ne n 0 with rfl | hn\n    · simp only [term_zero, zero_re, ofReal_zero]\n    · simp only [term_of_ne_zero hn, ← ofReal_natCast n, ← ofReal_cpow n.cast_nonneg, ← ofReal_div,\n        ofReal_re]\n  · rw [show (q.totient : ℂ) = (q.totient : ℝ) from rfl, ← ofReal_one, ← ofReal_sub, ← ofReal_inv,\n      ← ofReal_div, ofReal_re]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.LSeries_residueClass_lower_bound","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\ninst✝ : NeZero q\na : ZMod q\nha : IsUnit a\n⊢ Exists fun C => ∀ {x : Real}, Membership.mem (Set.Ioc 1 2) x → LE.le (HSub.hSub (HDiv.hDiv (Inv.inv ↑q.totient) (HSub.hSub x 1)) C) (tsum fun n => HDiv.hDiv (ArithmeticFunction.vonMangoldt.residueClass a n) (HPow.hPow (↑n) x))","decl":"/-- As `x` approaches `1` from the right along the real axis, the L-series of\n`ArithmeticFunction.vonMangoldt.residueClass` is bounded below by `(q.totient)⁻¹/(x-1) - C`. -/\nlemma LSeries_residueClass_lower_bound (ha : IsUnit a) :\n    ∃ C : ℝ, ∀ {x : ℝ} (_ : x ∈ Set.Ioc 1 2),\n      (q.totient : ℝ)⁻¹ / (x - 1) - C ≤ ∑' n, residueClass a n / (n : ℝ) ^ x := by\n  have H {x : ℝ} (hx : 1 < x) :\n      ∑' n, residueClass a n / (n : ℝ) ^ x =\n        (LFunctionResidueClassAux a x).re + (q.totient : ℝ)⁻¹ / (x - 1) := by\n    refine ofReal_injective ?_\n    simp only [ofReal_tsum, ofReal_div, ofReal_cpow (Nat.cast_nonneg _), ofReal_natCast,\n      ofReal_add, ofReal_inv, ofReal_sub, ofReal_one]\n    simp_rw [← LFunctionResidueClassAux_real ha hx,\n      eqOn_LFunctionResidueClassAux ha <| Set.mem_setOf.mpr (ofReal_re x ▸ hx), sub_add_cancel,\n      LSeries, term]\n    refine tsum_congr fun n ↦ ?_\n    split_ifs with hn\n    · simp only [hn, residueClass_apply_zero, ofReal_zero, zero_div]\n    · rfl\n  have : ContinuousOn (fun x : ℝ ↦ (LFunctionResidueClassAux a x).re) (Set.Icc 1 2) :=\n    continuous_re.continuousOn.comp (t := Set.univ) (continuousOn_LFunctionResidueClassAux a)\n      (fun ⦃x⦄ a ↦ trivial) |>.comp continuous_ofReal.continuousOn fun x hx ↦ by\n        simpa only [Set.mem_setOf_eq, ofReal_re] using hx.1\n  obtain ⟨C, hC⟩ := bddBelow_def.mp <| IsCompact.bddBelow_image isCompact_Icc this\n  replace hC {x : ℝ} (hx : x ∈ Set.Icc 1 2) : C ≤ (LFunctionResidueClassAux a x).re :=\n    hC (LFunctionResidueClassAux a x).re <|\n      Set.mem_image_of_mem (fun x : ℝ ↦ (LFunctionResidueClassAux a x).re) hx\n  refine ⟨-C, fun {x} hx ↦ ?_⟩\n  rw [H hx.1, add_comm, sub_neg_eq_add, add_le_add_iff_left]\n  exact hC <| Set.mem_Icc_of_Ioc hx\n\n"}
{"name":"ArithmeticFunction.vonMangoldt.not_summable_residueClass_prime_div","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\ninst✝ : NeZero q\na : ZMod q\nha : IsUnit a\n⊢ Not (Summable fun n => HDiv.hDiv (ite (Nat.Prime n) (ArithmeticFunction.vonMangoldt.residueClass a n) 0) ↑n)","decl":"open vonMangoldt Filter Topology in\n/-- The function `n ↦ Λ n / n` restricted to primes in an invertible residue class\nis not summable. This then implies that there must be infinitely many such primes. -/\nlemma not_summable_residueClass_prime_div (ha : IsUnit a) :\n    ¬ Summable fun n : ℕ ↦ (if n.Prime then residueClass a n else 0) / n := by\n  intro H\n  have key : Summable fun n : ℕ ↦ residueClass a n / n := by\n    convert (summable_residueClass_non_primes_div a).add H using 2 with n\n    simp only [← add_div, ite_add_ite, zero_add, add_zero, ite_self]\n  let C := ∑' n, residueClass a n / n\n  have H₁ {x : ℝ} (hx : 1 < x) : ∑' n, residueClass a n / (n : ℝ) ^ x ≤ C := by\n    refine tsum_le_tsum (fun n ↦ ?_) ?_ key\n    · rcases n.eq_zero_or_pos with rfl | hn\n      · simp only [Nat.cast_zero, Real.zero_rpow (zero_lt_one.trans hx).ne', div_zero, le_refl]\n      · refine div_le_div_of_nonneg_left (residueClass_nonneg a _) (mod_cast hn) ?_\n        conv_lhs => rw [← Real.rpow_one n]\n        exact Real.rpow_le_rpow_of_exponent_le (by norm_cast) hx.le\n    · exact summable_real_of_abscissaOfAbsConv_lt <|\n        (abscissaOfAbsConv_residueClass_le_one a).trans_lt <| mod_cast hx\n  obtain ⟨C', hC'⟩ := LSeries_residueClass_lower_bound ha\n  have H₁ {x} (hx : x ∈ Set.Ioc 1 2) : (q.totient : ℝ)⁻¹ ≤ (C + C') * (x - 1) :=\n    (div_le_iff₀ <| sub_pos.mpr hx.1).mp <|\n      sub_le_iff_le_add.mp <| (hC' hx).trans (H₁ hx.1)\n  have hq : 0 < (q.totient : ℝ)⁻¹ := inv_pos.mpr (mod_cast q.totient.pos_of_neZero)\n  rcases le_or_lt (C + C') 0 with h₀ | h₀\n  · have := hq.trans_le (H₁ (Set.right_mem_Ioc.mpr one_lt_two))\n    rw [show (2 : ℝ) - 1 = 1 by norm_num, mul_one] at this\n    exact (this.trans_le h₀).false\n  · obtain ⟨ξ, hξ₁, hξ₂⟩ : ∃ ξ ∈ Set.Ioc 1 2, (C + C') * (ξ - 1) < (q.totient : ℝ)⁻¹ := by\n      refine ⟨min (1 + (q.totient : ℝ)⁻¹ / (C + C') / 2) 2, ⟨?_, min_le_right ..⟩, ?_⟩\n      · simpa only [lt_inf_iff, lt_add_iff_pos_right, Nat.ofNat_pos, div_pos_iff_of_pos_right,\n          Nat.one_lt_ofNat, and_true] using div_pos hq h₀\n      · rw [← min_sub_sub_right, add_sub_cancel_left, ← lt_div_iff₀' h₀]\n        exact (min_le_left ..).trans_lt <| div_lt_self (div_pos hq h₀) one_lt_two\n    exact ((H₁ hξ₁).trans_lt hξ₂).false\n\n"}
{"name":"Nat.setOf_prime_and_eq_mod_infinite","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\ninst✝ : NeZero q\na : ZMod q\nha : IsUnit a\n⊢ (setOf fun p => And (Nat.Prime p) (Eq (↑p) a)).Infinite","decl":"/-- **Dirichlet's Theorem** on primes in arithmetic progression: if `q` is a positive\ninteger and `a : ZMod q` is a unit, then there are infintely many prime numbers `p`\nsuch that `(p : ZMod q) = a`. -/\ntheorem setOf_prime_and_eq_mod_infinite (ha : IsUnit a) :\n    {p : ℕ | p.Prime ∧ (p : ZMod q) = a}.Infinite := by\n  by_contra H\n  rw [Set.not_infinite] at H\n  exact not_summable_residueClass_prime_div ha <|\n    summable_of_finite_support <| support_residueClass_prime_div a ▸ H\n\n"}
{"name":"Nat.forall_exists_prime_gt_and_eq_mod","module":"Mathlib.NumberTheory.LSeries.PrimesInAP","initialProofState":"q : Nat\ninst✝ : NeZero q\na : ZMod q\nha : IsUnit a\nn : Nat\n⊢ Exists fun p => And (GT.gt p n) (And (Nat.Prime p) (Eq (↑p) a))","decl":"/-- **Dirichlet's Theorem** on primes in arithmetic progression: if `q` is a positive\ninteger and `a : ZMod q` is a unit, then there are infintely many prime numbers `p`\nsuch that `(p : ZMod q) = a`. -/\ntheorem forall_exists_prime_gt_and_eq_mod (ha : IsUnit a) (n : ℕ) :\n    ∃ p > n, p.Prime ∧ (p : ZMod q) = a := by\n  obtain ⟨p, hp₁, hp₂⟩ := Set.infinite_iff_exists_gt.mp (setOf_prime_and_eq_mod_infinite ha) n\n  exact ⟨p, hp₂.gt, Set.mem_setOf.mp hp₁⟩\n\n"}
