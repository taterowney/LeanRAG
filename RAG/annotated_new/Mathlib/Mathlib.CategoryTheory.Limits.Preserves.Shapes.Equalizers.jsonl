{"name":"CategoryTheory.Limits.PreservesEqualizer.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasEqualizer f g\ninst✝ : CategoryTheory.Limits.HasEqualizer (G.map f) (G.map g)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.equalizerComparison f g G)\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) G","decl":"/-- If the equalizer comparison map for `G` at `(f,g)` is an isomorphism, then `G` preserves the\nequalizer of `(f,g)`.\n-/\nlemma PreservesEqualizer.of_iso_comparison [i : IsIso (equalizerComparison f g G)] :\n    PreservesLimit (parallelPair f g) G := by\n  apply preservesLimit_of_preserves_limit_cone (equalizerIsEqualizer f g)\n  apply (isLimitMapConeForkEquiv _ _).symm _\n  exact @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (parallelPair (G.map f) (G.map g))) i\n\n"}
{"name":"CategoryTheory.Limits.PreservesEqualizer.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasEqualizer f g\ninst✝¹ : CategoryTheory.Limits.HasEqualizer (G.map f) (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) G\n⊢ Eq (CategoryTheory.Limits.PreservesEqualizer.iso G f g).hom (CategoryTheory.Limits.equalizerComparison f g G)","decl":"@[simp]\ntheorem PreservesEqualizer.iso_hom :\n    (PreservesEqualizer.iso G f g).hom = equalizerComparison f g G :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.PreservesEqualizer.iso_inv_ι","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasEqualizer f g\ninst✝¹ : CategoryTheory.Limits.HasEqualizer (G.map f) (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesEqualizer.iso G f g).inv (G.map (CategoryTheory.Limits.equalizer.ι f g))) (CategoryTheory.Limits.equalizer.ι (G.map f) (G.map g))","decl":"@[simp]\ntheorem PreservesEqualizer.iso_inv_ι :\n    (PreservesEqualizer.iso G f g).inv ≫ G.map (equalizer.ι f g) =\n      equalizer.ι (G.map f) (G.map g) := by\n  rw [← Iso.cancel_iso_hom_left (PreservesEqualizer.iso G f g), ← Category.assoc, Iso.hom_inv_id]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoEqualizerComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasEqualizer f g\ninst✝ : CategoryTheory.Limits.HasEqualizer (G.map f) (G.map g)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.equalizerComparison f g G)","decl":"instance : IsIso (equalizerComparison f g G) := by\n  rw [← PreservesEqualizer.iso_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasCoequalizer f g\ninst✝ : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.coequalizerComparison f g G)\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"/-- If the coequalizer comparison map for `G` at `(f,g)` is an isomorphism, then `G` preserves the\ncoequalizer of `(f,g)`.\n-/\nlemma of_iso_comparison [i : IsIso (coequalizerComparison f g G)] :\n    PreservesColimit (parallelPair f g) G := by\n  apply preservesColimit_of_preserves_colimit_cocone (coequalizerIsCoequalizer f g)\n  apply (isColimitMapCoconeCoforkEquiv _ _).symm _\n  exact\n    @IsColimit.ofPointIso _ _ _ _ _ _ _ (colimit.isColimit (parallelPair (G.map f) (G.map g))) i\n\n"}
{"name":"CategoryTheory.Limits.PreservesCoequalizer.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasCoequalizer f g\ninst✝¹ : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G\n⊢ Eq (CategoryTheory.Limits.PreservesCoequalizer.iso G f g).hom (CategoryTheory.Limits.coequalizerComparison f g G)","decl":"@[simp]\ntheorem PreservesCoequalizer.iso_hom :\n    (PreservesCoequalizer.iso G f g).hom = coequalizerComparison f g G :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoCoequalizerComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasCoequalizer f g\ninst✝ : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.coequalizerComparison f g G)","decl":"instance : IsIso (coequalizerComparison f g G) := by\n  rw [← PreservesCoequalizer.iso_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.map_π_epi","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasCoequalizer f g\n⊢ CategoryTheory.Epi (G.map (CategoryTheory.Limits.coequalizer.π f g))","decl":"instance map_π_epi : Epi (G.map (coequalizer.π f g)) :=\n  ⟨fun {W} h k => by\n    rw [← ι_comp_coequalizerComparison]\n    haveI : Epi (coequalizer.π (G.map f) (G.map g) ≫ coequalizerComparison f g G) := by\n      apply epi_comp\n    apply (cancel_epi _).1⟩\n\n"}
{"name":"CategoryTheory.Limits.map_π_preserves_coequalizer_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasCoequalizer f g\ninst✝¹ : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.Limits.PreservesCoequalizer.iso G f g).inv) (CategoryTheory.Limits.coequalizer.π (G.map f) (G.map g))","decl":"@[reassoc]\ntheorem map_π_preserves_coequalizer_inv :\n    G.map (coequalizer.π f g) ≫ (PreservesCoequalizer.iso G f g).inv =\n      coequalizer.π (G.map f) (G.map g) := by\n  rw [← ι_comp_coequalizerComparison_assoc, ← PreservesCoequalizer.iso_hom, Iso.hom_inv_id,\n    comp_id]\n\n"}
{"name":"CategoryTheory.Limits.map_π_preserves_coequalizer_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasCoequalizer f g\ninst✝¹ : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.coequalizer (G.map f) (G.map g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso G f g).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.π (G.map f) (G.map g)) h)","decl":"@[reassoc]\ntheorem map_π_preserves_coequalizer_inv :\n    G.map (coequalizer.π f g) ≫ (PreservesCoequalizer.iso G f g).inv =\n      coequalizer.π (G.map f) (G.map g) := by\n  rw [← ι_comp_coequalizerComparison_assoc, ← PreservesCoequalizer.iso_hom, Iso.hom_inv_id,\n    comp_id]\n\n"}
{"name":"CategoryTheory.Limits.map_π_preserves_coequalizer_inv_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasCoequalizer f g\ninst✝¹ : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G\nW : D\nk : Quiver.Hom (G.obj Y) W\nwk : Eq (CategoryTheory.CategoryStruct.comp (G.map f) k) (CategoryTheory.CategoryStruct.comp (G.map g) k)\nZ : D\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso G f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.desc k wk) h))) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc]\ntheorem map_π_preserves_coequalizer_inv_desc {W : D} (k : G.obj Y ⟶ W)\n    (wk : G.map f ≫ k = G.map g ≫ k) : G.map (coequalizer.π f g) ≫\n      (PreservesCoequalizer.iso G f g).inv ≫ coequalizer.desc k wk = k := by\n  rw [← Category.assoc, map_π_preserves_coequalizer_inv, coequalizer.π_desc]\n\n"}
{"name":"CategoryTheory.Limits.map_π_preserves_coequalizer_inv_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasCoequalizer f g\ninst✝¹ : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G\nW : D\nk : Quiver.Hom (G.obj Y) W\nwk : Eq (CategoryTheory.CategoryStruct.comp (G.map f) k) (CategoryTheory.CategoryStruct.comp (G.map g) k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso G f g).inv (CategoryTheory.Limits.coequalizer.desc k wk))) k","decl":"@[reassoc]\ntheorem map_π_preserves_coequalizer_inv_desc {W : D} (k : G.obj Y ⟶ W)\n    (wk : G.map f ≫ k = G.map g ≫ k) : G.map (coequalizer.π f g) ≫\n      (PreservesCoequalizer.iso G f g).inv ≫ coequalizer.desc k wk = k := by\n  rw [← Category.assoc, map_π_preserves_coequalizer_inv, coequalizer.π_desc]\n\n"}
{"name":"CategoryTheory.Limits.map_π_preserves_coequalizer_inv_colimMap","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝³ : CategoryTheory.Limits.HasCoequalizer f g\ninst✝² : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ninst✝¹ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G\nX' Y' : D\nf' g' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasCoequalizer f' g'\np : Quiver.Hom (G.obj X) X'\nq : Quiver.Hom (G.obj Y) Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp (G.map f) q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp (G.map g) q) (CategoryTheory.CategoryStruct.comp p g')\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso G f g).inv (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (G.map f) (G.map g) f' g' p q wf wg)))) (CategoryTheory.CategoryStruct.comp q (CategoryTheory.Limits.coequalizer.π f' g'))","decl":"@[reassoc]\ntheorem map_π_preserves_coequalizer_inv_colimMap {X' Y' : D} (f' g' : X' ⟶ Y')\n    [HasCoequalizer f' g'] (p : G.obj X ⟶ X') (q : G.obj Y ⟶ Y') (wf : G.map f ≫ q = p ≫ f')\n    (wg : G.map g ≫ q = p ≫ g') :\n    G.map (coequalizer.π f g) ≫\n        (PreservesCoequalizer.iso G f g).inv ≫\n          colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg) =\n      q ≫ coequalizer.π f' g' := by\n  rw [← Category.assoc, map_π_preserves_coequalizer_inv, ι_colimMap, parallelPairHom_app_one]\n\n"}
{"name":"CategoryTheory.Limits.map_π_preserves_coequalizer_inv_colimMap_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝³ : CategoryTheory.Limits.HasCoequalizer f g\ninst✝² : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ninst✝¹ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G\nX' Y' : D\nf' g' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasCoequalizer f' g'\np : Quiver.Hom (G.obj X) X'\nq : Quiver.Hom (G.obj Y) Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp (G.map f) q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp (G.map g) q) (CategoryTheory.CategoryStruct.comp p g')\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.colimit (CategoryTheory.Limits.parallelPair f' g')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso G f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (G.map f) (G.map g) f' g' p q wf wg)) h))) (CategoryTheory.CategoryStruct.comp q (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.π f' g') h))","decl":"@[reassoc]\ntheorem map_π_preserves_coequalizer_inv_colimMap {X' Y' : D} (f' g' : X' ⟶ Y')\n    [HasCoequalizer f' g'] (p : G.obj X ⟶ X') (q : G.obj Y ⟶ Y') (wf : G.map f ≫ q = p ≫ f')\n    (wg : G.map g ≫ q = p ≫ g') :\n    G.map (coequalizer.π f g) ≫\n        (PreservesCoequalizer.iso G f g).inv ≫\n          colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg) =\n      q ≫ coequalizer.π f' g' := by\n  rw [← Category.assoc, map_π_preserves_coequalizer_inv, ι_colimMap, parallelPairHom_app_one]\n\n"}
{"name":"CategoryTheory.Limits.map_π_preserves_coequalizer_inv_colimMap_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝³ : CategoryTheory.Limits.HasCoequalizer f g\ninst✝² : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ninst✝¹ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G\nX' Y' : D\nf' g' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasCoequalizer f' g'\np : Quiver.Hom (G.obj X) X'\nq : Quiver.Hom (G.obj Y) Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp (G.map f) q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp (G.map g) q) (CategoryTheory.CategoryStruct.comp p g')\nZ' : D\nh : Quiver.Hom Y' Z'\nwh : Eq (CategoryTheory.CategoryStruct.comp f' h) (CategoryTheory.CategoryStruct.comp g' h)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso G f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (G.map f) (G.map g) f' g' p q wf wg)) (CategoryTheory.Limits.coequalizer.desc h wh)))) (CategoryTheory.CategoryStruct.comp q h)","decl":"@[reassoc]\ntheorem map_π_preserves_coequalizer_inv_colimMap_desc {X' Y' : D} (f' g' : X' ⟶ Y')\n    [HasCoequalizer f' g'] (p : G.obj X ⟶ X') (q : G.obj Y ⟶ Y') (wf : G.map f ≫ q = p ≫ f')\n    (wg : G.map g ≫ q = p ≫ g') {Z' : D} (h : Y' ⟶ Z') (wh : f' ≫ h = g' ≫ h) :\n    G.map (coequalizer.π f g) ≫\n        (PreservesCoequalizer.iso G f g).inv ≫\n          colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg) ≫ coequalizer.desc h wh =\n      q ≫ h := by\n  slice_lhs 1 3 => rw [map_π_preserves_coequalizer_inv_colimMap]\n  slice_lhs 2 3 => rw [coequalizer.π_desc]\n\n"}
{"name":"CategoryTheory.Limits.map_π_preserves_coequalizer_inv_colimMap_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝³ : CategoryTheory.Limits.HasCoequalizer f g\ninst✝² : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\ninst✝¹ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G\nX' Y' : D\nf' g' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.Limits.HasCoequalizer f' g'\np : Quiver.Hom (G.obj X) X'\nq : Quiver.Hom (G.obj Y) Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp (G.map f) q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp (G.map g) q) (CategoryTheory.CategoryStruct.comp p g')\nZ' : D\nh✝ : Quiver.Hom Y' Z'\nwh : Eq (CategoryTheory.CategoryStruct.comp f' h✝) (CategoryTheory.CategoryStruct.comp g' h✝)\nZ : D\nh : Quiver.Hom Z' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso G f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (G.map f) (G.map g) f' g' p q wf wg)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.desc h✝ wh) h)))) (CategoryTheory.CategoryStruct.comp q (CategoryTheory.CategoryStruct.comp h✝ h))","decl":"@[reassoc]\ntheorem map_π_preserves_coequalizer_inv_colimMap_desc {X' Y' : D} (f' g' : X' ⟶ Y')\n    [HasCoequalizer f' g'] (p : G.obj X ⟶ X') (q : G.obj Y ⟶ Y') (wf : G.map f ≫ q = p ≫ f')\n    (wg : G.map g ≫ q = p ≫ g') {Z' : D} (h : Y' ⟶ Z') (wh : f' ≫ h = g' ≫ h) :\n    G.map (coequalizer.π f g) ≫\n        (PreservesCoequalizer.iso G f g).inv ≫\n          colimMap (parallelPairHom (G.map f) (G.map g) f' g' p q wf wg) ≫ coequalizer.desc h wh =\n      q ≫ h := by\n  slice_lhs 1 3 => rw [map_π_preserves_coequalizer_inv_colimMap]\n  slice_lhs 2 3 => rw [coequalizer.π_desc]\n\n"}
{"name":"CategoryTheory.Limits.preservesSplitCoequalizers","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.HasSplitCoequalizer f g\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"/-- Any functor preserves coequalizers of split pairs. -/\ninstance (priority := 1) preservesSplitCoequalizers (f g : X ⟶ Y) [HasSplitCoequalizer f g] :\n    PreservesColimit (parallelPair f g) G := by\n  apply\n    preservesColimit_of_preserves_colimit_cocone\n      (HasSplitCoequalizer.isSplitCoequalizer f g).isCoequalizer\n  apply\n    (isColimitMapCoconeCoforkEquiv G _).symm\n      ((HasSplitCoequalizer.isSplitCoequalizer f g).map G).isCoequalizer\n\n"}
{"name":"CategoryTheory.Limits.preservesSplitEqualizers","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Equalizers","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y : C\nf g : Quiver.Hom X Y\ninst✝ : CategoryTheory.HasSplitEqualizer f g\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) G","decl":"instance (priority := 1) preservesSplitEqualizers (f g : X ⟶ Y) [HasSplitEqualizer f g] :\n    PreservesLimit (parallelPair f g) G := by\n  apply\n    preservesLimit_of_preserves_limit_cone\n      (HasSplitEqualizer.isSplitEqualizer f g).isEqualizer\n  apply\n    (isLimitMapConeForkEquiv G _).symm\n      ((HasSplitEqualizer.isSplitEqualizer f g).map G).isEqualizer\n\n"}
