{"name":"ContinuousLinearMap.measurable_apply₂","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : MeasurableSpace E\ninst✝³ : OpensMeasurableSpace E\ninst✝² : SecondCountableTopologyEither (ContinuousLinearMap (RingHom.id 𝕜) E F) E\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\n⊢ Measurable fun p => p.1 p.2","decl":"theorem measurable_apply₂ [MeasurableSpace E] [OpensMeasurableSpace E]\n    [SecondCountableTopologyEither (E →L[𝕜] F) E]\n    [MeasurableSpace F] [BorelSpace F] : Measurable fun p : (E →L[𝕜] F) × E => p.1 p.2 :=\n  isBoundedBilinearMap_apply.continuous.measurable\n\n"}
{"name":"FDerivMeasurableAux.isOpen_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nr ε : Real\n⊢ IsOpen (FDerivMeasurableAux.A f L r ε)","decl":"theorem isOpen_A (L : E →L[𝕜] F) (r ε : ℝ) : IsOpen (A f L r ε) := by\n  rw [Metric.isOpen_iff]\n  rintro x ⟨r', r'_mem, hr'⟩\n  obtain ⟨s, s_gt, s_lt⟩ : ∃ s : ℝ, r / 2 < s ∧ s < r' := exists_between r'_mem.1\n  have : s ∈ Ioc (r / 2) r := ⟨s_gt, le_of_lt (s_lt.trans_le r'_mem.2)⟩\n  refine ⟨r' - s, by linarith, fun x' hx' => ⟨s, this, ?_⟩⟩\n  have B : ball x' s ⊆ ball x r' := ball_subset (le_of_lt hx')\n  intro y hy z hz\n  exact hr' y (B hy) z (B hz)\n\n"}
{"name":"FDerivMeasurableAux.isOpen_B","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nK : Set (ContinuousLinearMap (RingHom.id 𝕜) E F)\nr s ε : Real\n⊢ IsOpen (FDerivMeasurableAux.B f K r s ε)","decl":"theorem isOpen_B {K : Set (E →L[𝕜] F)} {r s ε : ℝ} : IsOpen (B f K r s ε) := by\n  simp [B, isOpen_biUnion, IsOpen.inter, isOpen_A]\n\n"}
{"name":"FDerivMeasurableAux.A_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nr ε δ : Real\nh : LE.le ε δ\n⊢ HasSubset.Subset (FDerivMeasurableAux.A f L r ε) (FDerivMeasurableAux.A f L r δ)","decl":"theorem A_mono (L : E →L[𝕜] F) (r : ℝ) {ε δ : ℝ} (h : ε ≤ δ) : A f L r ε ⊆ A f L r δ := by\n  rintro x ⟨r', r'r, hr'⟩\n  refine ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).trans_le (mul_le_mul_of_nonneg_right h ?_)⟩\n  linarith [mem_ball.1 hy, r'r.2, @dist_nonneg _ _ y x]\n\n"}
{"name":"FDerivMeasurableAux.le_of_mem_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nr ε : Real\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nhx : Membership.mem (FDerivMeasurableAux.A f L r ε) x\ny z : E\nhy : Membership.mem (Metric.closedBall x (HDiv.hDiv r 2)) y\nhz : Membership.mem (Metric.closedBall x (HDiv.hDiv r 2)) z\n⊢ LE.le (Norm.norm (HSub.hSub (HSub.hSub (f z) (f y)) (L (HSub.hSub z y)))) (HMul.hMul ε r)","decl":"theorem le_of_mem_A {r ε : ℝ} {L : E →L[𝕜] F} {x : E} (hx : x ∈ A f L r ε) {y z : E}\n    (hy : y ∈ closedBall x (r / 2)) (hz : z ∈ closedBall x (r / 2)) :\n    ‖f z - f y - L (z - y)‖ ≤ ε * r := by\n  rcases hx with ⟨r', r'mem, hr'⟩\n  apply le_of_lt\n  exact hr' _ ((mem_closedBall.1 hy).trans_lt r'mem.1) _ ((mem_closedBall.1 hz).trans_lt r'mem.1)\n\n"}
{"name":"FDerivMeasurableAux.mem_A_of_differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nε : Real\nhε : LT.lt 0 ε\nx : E\nhx : DifferentiableAt 𝕜 f x\n⊢ Exists fun R => And (GT.gt R 0) (∀ (r : Real), Membership.mem (Set.Ioo 0 R) r → Membership.mem (FDerivMeasurableAux.A f (fderiv 𝕜 f x) r ε) x)","decl":"theorem mem_A_of_differentiable {ε : ℝ} (hε : 0 < ε) {x : E} (hx : DifferentiableAt 𝕜 f x) :\n    ∃ R > 0, ∀ r ∈ Ioo (0 : ℝ) R, x ∈ A f (fderiv 𝕜 f x) r ε := by\n  let δ := (ε / 2) / 2\n  obtain ⟨R, R_pos, hR⟩ :\n      ∃ R > 0, ∀ y ∈ ball x R, ‖f y - f x - fderiv 𝕜 f x (y - x)‖ ≤ δ * ‖y - x‖ :=\n    eventually_nhds_iff_ball.1 <| hx.hasFDerivAt.isLittleO.bound <| by positivity\n  refine ⟨R, R_pos, fun r hr => ?_⟩\n  have : r ∈ Ioc (r / 2) r := right_mem_Ioc.2 <| half_lt_self hr.1\n  refine ⟨r, this, fun y hy z hz => ?_⟩\n  calc\n    ‖f z - f y - (fderiv 𝕜 f x) (z - y)‖ =\n        ‖f z - f x - (fderiv 𝕜 f x) (z - x) - (f y - f x - (fderiv 𝕜 f x) (y - x))‖ := by\n      simp only [map_sub]; abel_nf\n    _ ≤ ‖f z - f x - (fderiv 𝕜 f x) (z - x)‖ + ‖f y - f x - (fderiv 𝕜 f x) (y - x)‖ :=\n      norm_sub_le _ _\n    _ ≤ δ * ‖z - x‖ + δ * ‖y - x‖ :=\n      add_le_add (hR _ (ball_subset_ball hr.2.le hz)) (hR _ (ball_subset_ball hr.2.le hy))\n    _ ≤ δ * r + δ * r := by rw [mem_ball_iff_norm] at hz hy; gcongr\n    _ = (ε / 2) * r := by ring\n    _ < ε * r := by gcongr; exacts [hr.1, half_lt_self hε]\n\n"}
{"name":"FDerivMeasurableAux.norm_sub_le_of_mem_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nr ε : Real\nhε : LT.lt 0 ε\nhr : LT.lt 0 r\nx : E\nL₁ L₂ : ContinuousLinearMap (RingHom.id 𝕜) E F\nh₁ : Membership.mem (FDerivMeasurableAux.A f L₁ r ε) x\nh₂ : Membership.mem (FDerivMeasurableAux.A f L₂ r ε) x\n⊢ LE.le (Norm.norm (HSub.hSub L₁ L₂)) (HMul.hMul (HMul.hMul 4 (Norm.norm c)) ε)","decl":"theorem norm_sub_le_of_mem_A {c : 𝕜} (hc : 1 < ‖c‖) {r ε : ℝ} (hε : 0 < ε) (hr : 0 < r) {x : E}\n    {L₁ L₂ : E →L[𝕜] F} (h₁ : x ∈ A f L₁ r ε) (h₂ : x ∈ A f L₂ r ε) : ‖L₁ - L₂‖ ≤ 4 * ‖c‖ * ε := by\n  refine opNorm_le_of_shell (half_pos hr) (by positivity) hc ?_\n  intro y ley ylt\n  rw [div_div, div_le_iff₀' (mul_pos (by norm_num : (0 : ℝ) < 2) (zero_lt_one.trans hc))] at ley\n  calc\n    ‖(L₁ - L₂) y‖ = ‖f (x + y) - f x - L₂ (x + y - x) - (f (x + y) - f x - L₁ (x + y - x))‖ := by\n      simp\n    _ ≤ ‖f (x + y) - f x - L₂ (x + y - x)‖ + ‖f (x + y) - f x - L₁ (x + y - x)‖ := norm_sub_le _ _\n    _ ≤ ε * r + ε * r := by\n      apply add_le_add\n      · apply le_of_mem_A h₂\n        · simp only [le_of_lt (half_pos hr), mem_closedBall, dist_self]\n        · simp only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, ylt.le]\n      · apply le_of_mem_A h₁\n        · simp only [le_of_lt (half_pos hr), mem_closedBall, dist_self]\n        · simp only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, ylt.le]\n    _ = 2 * ε * r := by ring\n    _ ≤ 2 * ε * (2 * ‖c‖ * ‖y‖) := by gcongr\n    _ = 4 * ‖c‖ * ε * ‖y‖ := by ring\n\n"}
{"name":"FDerivMeasurableAux.differentiable_set_subset_D","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nK : Set (ContinuousLinearMap (RingHom.id 𝕜) E F)\n⊢ HasSubset.Subset (setOf fun x => And (DifferentiableAt 𝕜 f x) (Membership.mem K (fderiv 𝕜 f x))) (FDerivMeasurableAux.D f K)","decl":"/-- Easy inclusion: a differentiability point with derivative in `K` belongs to `D f K`. -/\ntheorem differentiable_set_subset_D :\n    { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } ⊆ D f K := by\n  intro x hx\n  rw [D, mem_iInter]\n  intro e\n  have : (0 : ℝ) < (1 / 2) ^ e := by positivity\n  rcases mem_A_of_differentiable this hx.1 with ⟨R, R_pos, hR⟩\n  obtain ⟨n, hn⟩ : ∃ n : ℕ, (1 / 2) ^ n < R :=\n    exists_pow_lt_of_lt_one R_pos (by norm_num : (1 : ℝ) / 2 < 1)\n  simp only [mem_iUnion, mem_iInter, B, mem_inter_iff]\n  refine ⟨n, fun p hp q hq => ⟨fderiv 𝕜 f x, hx.2, ⟨?_, ?_⟩⟩⟩ <;>\n    · refine hR _ ⟨pow_pos (by norm_num) _, lt_of_le_of_lt ?_ hn⟩\n      exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption)\n\n"}
{"name":"FDerivMeasurableAux.D_subset_differentiable_set","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nK : Set (ContinuousLinearMap (RingHom.id 𝕜) E F)\nhK : IsComplete K\n⊢ HasSubset.Subset (FDerivMeasurableAux.D f K) (setOf fun x => And (DifferentiableAt 𝕜 f x) (Membership.mem K (fderiv 𝕜 f x)))","decl":"/-- Harder inclusion: at a point in `D f K`, the function `f` has a derivative, in `K`. -/\ntheorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :\n    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } := by\n  have P : ∀ {n : ℕ}, (0 : ℝ) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n\n  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩\n  intro x hx\n  have :\n    ∀ e : ℕ, ∃ n : ℕ, ∀ p q, n ≤ p → n ≤ q →\n      ∃ L ∈ K, x ∈ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) ∩ A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by\n    intro e\n    have := mem_iInter.1 hx e\n    rcases mem_iUnion.1 this with ⟨n, hn⟩\n    refine ⟨n, fun p q hp hq => ?_⟩\n    simp only [mem_iInter] at hn\n    rcases mem_iUnion.1 (hn p hp q hq) with ⟨L, hL⟩\n    exact ⟨L, exists_prop.mp <| mem_iUnion.1 hL⟩\n  /- Recast the assumptions: for each `e`, there exist `n e` and linear maps `L e p q` in `K`\n    such that, for `p, q ≥ n e`, then `f` is well approximated by `L e p q` at scale `2 ^ (-p)` and\n    `2 ^ (-q)`, with an error `2 ^ (-e)`. -/\n  choose! n L hn using this\n  /- All the operators `L e p q` that show up are close to each other. To prove this, we argue\n      that `L e p q` is close to `L e p r` (where `r` is large enough), as both approximate `f` at\n      scale `2 ^(- p)`. And `L e p r` is close to `L e' p' r` as both approximate `f` at scale\n      `2 ^ (- r)`. And `L e' p' r` is close to `L e' p' q'` as both approximate `f` at scale\n      `2 ^ (- p')`. -/\n  have M :\n    ∀ e p q e' p' q',\n      n e ≤ p →\n        n e ≤ q →\n          n e' ≤ p' → n e' ≤ q' → e ≤ e' → ‖L e p q - L e' p' q'‖ ≤ 12 * ‖c‖ * (1 / 2) ^ e := by\n    intro e p q e' p' q' hp hq hp' hq' he'\n    let r := max (n e) (n e')\n    have I : ((1 : ℝ) / 2) ^ e' ≤ (1 / 2) ^ e :=\n      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'\n    have J1 : ‖L e p q - L e p r‖ ≤ 4 * ‖c‖ * (1 / 2) ^ e := by\n      have I1 : x ∈ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1\n      have I2 : x ∈ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1\n      exact norm_sub_le_of_mem_A hc P P I1 I2\n    have J2 : ‖L e p r - L e' p' r‖ ≤ 4 * ‖c‖ * (1 / 2) ^ e := by\n      have I1 : x ∈ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2\n      have I2 : x ∈ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=\n        (hn e' p' r hp' (le_max_right _ _)).2.2\n      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)\n    have J3 : ‖L e' p' r - L e' p' q'‖ ≤ 4 * ‖c‖ * (1 / 2) ^ e := by\n      have I1 : x ∈ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=\n        (hn e' p' r hp' (le_max_right _ _)).2.1\n      have I2 : x ∈ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1\n      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)\n    calc\n      ‖L e p q - L e' p' q'‖ =\n          ‖L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')‖ := by\n        congr 1; abel\n      _ ≤ ‖L e p q - L e p r‖ + ‖L e p r - L e' p' r‖ + ‖L e' p' r - L e' p' q'‖ :=\n        norm_add₃_le\n      _ ≤ 4 * ‖c‖ * (1 / 2) ^ e + 4 * ‖c‖ * (1 / 2) ^ e + 4 * ‖c‖ * (1 / 2) ^ e := by gcongr\n      _ = 12 * ‖c‖ * (1 / 2) ^ e := by ring\n  /- For definiteness, use `L0 e = L e (n e) (n e)`, to have a single sequence. We claim that this\n    is a Cauchy sequence. -/\n  let L0 : ℕ → E →L[𝕜] F := fun e => L e (n e) (n e)\n  have : CauchySeq L0 := by\n    rw [Metric.cauchySeq_iff']\n    intro ε εpos\n    obtain ⟨e, he⟩ : ∃ e : ℕ, (1 / 2) ^ e < ε / (12 * ‖c‖) :=\n      exists_pow_lt_of_lt_one (by positivity) (by norm_num)\n    refine ⟨e, fun e' he' => ?_⟩\n    rw [dist_comm, dist_eq_norm]\n    calc\n      ‖L0 e - L0 e'‖ ≤ 12 * ‖c‖ * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'\n      _ < 12 * ‖c‖ * (ε / (12 * ‖c‖)) := by gcongr\n      _ = ε := by field_simp\n  -- As it is Cauchy, the sequence `L0` converges, to a limit `f'` in `K`.\n  obtain ⟨f', f'K, hf'⟩ : ∃ f' ∈ K, Tendsto L0 atTop (𝓝 f') :=\n    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this\n  have Lf' : ∀ e p, n e ≤ p → ‖L e (n e) p - f'‖ ≤ 12 * ‖c‖ * (1 / 2) ^ e := by\n    intro e p hp\n    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm\n    rw [eventually_atTop]\n    exact ⟨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'⟩\n  -- Let us show that `f` has derivative `f'` at `x`.\n  have : HasFDerivAt f f' x := by\n    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]\n    /- to get an approximation with a precision `ε`, we will replace `f` with `L e (n e) m` for\n      some large enough `e` (yielding a small error by uniform approximation). As one can vary `m`,\n      this makes it possible to cover all scales, and thus to obtain a good linear approximation in\n      the whole ball of radius `(1/2)^(n e)`. -/\n    intro ε εpos\n    have pos : 0 < 4 + 12 * ‖c‖ := by positivity\n    obtain ⟨e, he⟩ : ∃ e : ℕ, (1 / 2) ^ e < ε / (4 + 12 * ‖c‖) :=\n      exists_pow_lt_of_lt_one (div_pos εpos pos) (by norm_num)\n    rw [eventually_nhds_iff_ball]\n    refine ⟨(1 / 2) ^ (n e + 1), P, fun y hy => ?_⟩\n    -- We need to show that `f (x + y) - f x - f' y` is small. For this, we will work at scale\n    -- `k` where `k` is chosen with `‖y‖ ∼ 2 ^ (-k)`.\n    by_cases y_pos : y = 0\n    · simp [y_pos]\n    have yzero : 0 < ‖y‖ := norm_pos_iff.mpr y_pos\n    have y_lt : ‖y‖ < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy\n    have yone : ‖y‖ ≤ 1 := le_trans y_lt.le (pow_le_one₀ (by norm_num) (by norm_num))\n    -- define the scale `k`.\n    obtain ⟨k, hk, h'k⟩ : ∃ k : ℕ, (1 / 2) ^ (k + 1) < ‖y‖ ∧ ‖y‖ ≤ (1 / 2) ^ k :=\n      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : ℝ) < 1 / 2)\n        (by norm_num : (1 : ℝ) / 2 < 1)\n    -- the scale is large enough (as `y` is small enough)\n    have k_gt : n e < k := by\n      have : ((1 : ℝ) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt\n      rw [pow_lt_pow_iff_right_of_lt_one₀ (by norm_num : (0 : ℝ) < 1 / 2) (by norm_num)] at this\n      omega\n    set m := k - 1\n    have m_ge : n e ≤ m := Nat.le_sub_one_of_lt k_gt\n    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm\n    rw [km] at hk h'k\n    -- `f` is well approximated by `L e (n e) k` at the relevant scale\n    -- (in fact, we use `m = k - 1` instead of `k` because of the precise definition of `A`).\n    have J1 : ‖f (x + y) - f x - L e (n e) m (x + y - x)‖ ≤ (1 / 2) ^ e * (1 / 2) ^ m := by\n      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2\n      · simp only [mem_closedBall, dist_self]\n        positivity\n      · simpa only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, pow_succ, mul_one_div] using\n          h'k\n    have J2 : ‖f (x + y) - f x - L e (n e) m y‖ ≤ 4 * (1 / 2) ^ e * ‖y‖ :=\n      calc\n        ‖f (x + y) - f x - L e (n e) m y‖ ≤ (1 / 2) ^ e * (1 / 2) ^ m := by\n          simpa only [add_sub_cancel_left] using J1\n        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring\n        _ ≤ 4 * (1 / 2) ^ e * ‖y‖ := by gcongr\n    -- use the previous estimates to see that `f (x + y) - f x - f' y` is small.\n    calc\n      ‖f (x + y) - f x - f' y‖ = ‖f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') y‖ :=\n        congr_arg _ (by simp)\n      _ ≤ 4 * (1 / 2) ^ e * ‖y‖ + 12 * ‖c‖ * (1 / 2) ^ e * ‖y‖ :=\n        norm_add_le_of_le J2 <| (le_opNorm _ _).trans <| by gcongr; exact Lf' _ _ m_ge\n      _ = (4 + 12 * ‖c‖) * ‖y‖ * (1 / 2) ^ e := by ring\n      _ ≤ (4 + 12 * ‖c‖) * ‖y‖ * (ε / (4 + 12 * ‖c‖)) := by gcongr\n      _ = ε * ‖y‖ := by field_simp [ne_of_gt pos]; ring\n  rw [← this.fderiv] at f'K\n  exact ⟨this.differentiableAt, f'K⟩\n\n"}
{"name":"FDerivMeasurableAux.differentiable_set_eq_D","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nK : Set (ContinuousLinearMap (RingHom.id 𝕜) E F)\nhK : IsComplete K\n⊢ Eq (setOf fun x => And (DifferentiableAt 𝕜 f x) (Membership.mem K (fderiv 𝕜 f x))) (FDerivMeasurableAux.D f K)","decl":"theorem differentiable_set_eq_D (hK : IsComplete K) :\n    { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } = D f K :=\n  Subset.antisymm (differentiable_set_subset_D _) (D_subset_differentiable_set hK)\n\n"}
{"name":"measurableSet_of_differentiableAt_of_isComplete","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nf : E → F\ninst✝¹ : MeasurableSpace E\ninst✝ : OpensMeasurableSpace E\nK : Set (ContinuousLinearMap (RingHom.id 𝕜) E F)\nhK : IsComplete K\n⊢ MeasurableSet (setOf fun x => And (DifferentiableAt 𝕜 f x) (Membership.mem K (fderiv 𝕜 f x)))","decl":"/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem measurableSet_of_differentiableAt_of_isComplete {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :\n    MeasurableSet { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } := by\n  -- Porting note: was\n  -- simp [differentiable_set_eq_D K hK, D, isOpen_B.measurableSet, MeasurableSet.iInter,\n  --   MeasurableSet.iUnion]\n  simp only [D, differentiable_set_eq_D K hK]\n  repeat apply_rules [MeasurableSet.iUnion, MeasurableSet.iInter] <;> intro\n  exact isOpen_B.measurableSet\n\n"}
{"name":"measurableSet_of_differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nf : E → F\ninst✝² : MeasurableSpace E\ninst✝¹ : OpensMeasurableSpace E\ninst✝ : CompleteSpace F\n⊢ MeasurableSet (setOf fun x => DifferentiableAt 𝕜 f x)","decl":"/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem measurableSet_of_differentiableAt : MeasurableSet { x | DifferentiableAt 𝕜 f x } := by\n  have : IsComplete (univ : Set (E →L[𝕜] F)) := complete_univ\n  convert measurableSet_of_differentiableAt_of_isComplete 𝕜 f this\n  simp\n\n"}
{"name":"measurable_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nf : E → F\ninst✝² : MeasurableSpace E\ninst✝¹ : OpensMeasurableSpace E\ninst✝ : CompleteSpace F\n⊢ Measurable (fderiv 𝕜 f)","decl":"@[measurability, fun_prop]\ntheorem measurable_fderiv : Measurable (fderiv 𝕜 f) := by\n  refine measurable_of_isClosed fun s hs => ?_\n  have :\n    fderiv 𝕜 f ⁻¹' s =\n      { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ s } ∪\n        { x | ¬DifferentiableAt 𝕜 f x } ∩ { _x | (0 : E →L[𝕜] F) ∈ s } :=\n    Set.ext fun x => mem_preimage.trans fderiv_mem_iff\n  rw [this]\n  exact\n    (measurableSet_of_differentiableAt_of_isComplete _ _ hs.isComplete).union\n      ((measurableSet_of_differentiableAt _ _).compl.inter (MeasurableSet.const _))\n\n"}
{"name":"measurable_fderiv_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\nf : E → F\ninst✝⁴ : MeasurableSpace E\ninst✝³ : OpensMeasurableSpace E\ninst✝² : CompleteSpace F\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\ny : E\n⊢ Measurable fun x => (fderiv 𝕜 f x) y","decl":"@[measurability, fun_prop]\ntheorem measurable_fderiv_apply_const [MeasurableSpace F] [BorelSpace F] (y : E) :\n    Measurable fun x => fderiv 𝕜 f x y :=\n  (ContinuousLinearMap.measurable_apply y).comp (measurable_fderiv 𝕜 f)\n\n"}
{"name":"measurable_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : CompleteSpace F\ninst✝³ : MeasurableSpace 𝕜\ninst✝² : OpensMeasurableSpace 𝕜\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\nf : 𝕜 → F\n⊢ Measurable (deriv f)","decl":"@[measurability, fun_prop]\ntheorem measurable_deriv [MeasurableSpace 𝕜] [OpensMeasurableSpace 𝕜] [MeasurableSpace F]\n    [BorelSpace F] (f : 𝕜 → F) : Measurable (deriv f) := by\n  simpa only [fderiv_deriv] using measurable_fderiv_apply_const 𝕜 f 1\n\n"}
{"name":"stronglyMeasurable_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\ninst✝² : CompleteSpace F\ninst✝¹ : MeasurableSpace 𝕜\ninst✝ : OpensMeasurableSpace 𝕜\nh : SecondCountableTopologyEither 𝕜 F\nf : 𝕜 → F\n⊢ MeasureTheory.StronglyMeasurable (deriv f)","decl":"theorem stronglyMeasurable_deriv [MeasurableSpace 𝕜] [OpensMeasurableSpace 𝕜]\n    [h : SecondCountableTopologyEither 𝕜 F] (f : 𝕜 → F) : StronglyMeasurable (deriv f) := by\n  borelize F\n  rcases h.out with h𝕜|hF\n  · exact stronglyMeasurable_iff_measurable_separable.2\n      ⟨measurable_deriv f, isSeparable_range_deriv _⟩\n  · exact (measurable_deriv f).stronglyMeasurable\n\n"}
{"name":"aemeasurable_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁷ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\ninst✝⁴ : CompleteSpace F\ninst✝³ : MeasurableSpace 𝕜\ninst✝² : OpensMeasurableSpace 𝕜\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\nf : 𝕜 → F\nμ : MeasureTheory.Measure 𝕜\n⊢ AEMeasurable (deriv f) μ","decl":"theorem aemeasurable_deriv [MeasurableSpace 𝕜] [OpensMeasurableSpace 𝕜] [MeasurableSpace F]\n    [BorelSpace F] (f : 𝕜 → F) (μ : Measure 𝕜) : AEMeasurable (deriv f) μ :=\n  (measurable_deriv f).aemeasurable\n\n"}
{"name":"aestronglyMeasurable_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\ninst✝² : MeasurableSpace 𝕜\ninst✝¹ : OpensMeasurableSpace 𝕜\ninst✝ : SecondCountableTopologyEither 𝕜 F\nf : 𝕜 → F\nμ : MeasureTheory.Measure 𝕜\n⊢ MeasureTheory.AEStronglyMeasurable (deriv f) μ","decl":"theorem aestronglyMeasurable_deriv [MeasurableSpace 𝕜] [OpensMeasurableSpace 𝕜]\n    [SecondCountableTopologyEither 𝕜 F] (f : 𝕜 → F) (μ : Measure 𝕜) :\n    AEStronglyMeasurable (deriv f) μ :=\n  (stronglyMeasurable_deriv f).aestronglyMeasurable\n\n"}
{"name":"RightDerivMeasurableAux.A_mem_nhdsGT","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nL : F\nr ε x : Real\nhx : Membership.mem (RightDerivMeasurableAux.A f L r ε) x\n⊢ Membership.mem (nhdsWithin x (Set.Ioi x)) (RightDerivMeasurableAux.A f L r ε)","decl":"theorem A_mem_nhdsGT {L : F} {r ε x : ℝ} (hx : x ∈ A f L r ε) : A f L r ε ∈ 𝓝[>] x := by\n  rcases hx with ⟨r', rr', hr'⟩\n  obtain ⟨s, s_gt, s_lt⟩ : ∃ s : ℝ, r / 2 < s ∧ s < r' := exists_between rr'.1\n  have : s ∈ Ioc (r / 2) r := ⟨s_gt, le_of_lt (s_lt.trans_le rr'.2)⟩\n  filter_upwards [Ioo_mem_nhdsGT <| show x < x + r' - s by linarith] with x' hx'\n  use s, this\n  have A : Icc x' (x' + s) ⊆ Icc x (x + r') := by\n    apply Icc_subset_Icc hx'.1.le\n    linarith [hx'.2]\n  intro y hy z hz\n  exact hr' y (A hy) z (A hz)\n\n"}
{"name":"RightDerivMeasurableAux.B_mem_nhdsGT","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nK : Set F\nr s ε x : Real\nhx : Membership.mem (RightDerivMeasurableAux.B f K r s ε) x\n⊢ Membership.mem (nhdsWithin x (Set.Ioi x)) (RightDerivMeasurableAux.B f K r s ε)","decl":"theorem B_mem_nhdsGT {K : Set F} {r s ε x : ℝ} (hx : x ∈ B f K r s ε) :\n    B f K r s ε ∈ 𝓝[>] x := by\n  obtain ⟨L, LK, hL₁, hL₂⟩ : ∃ L : F, L ∈ K ∧ x ∈ A f L r ε ∧ x ∈ A f L s ε := by\n    simpa only [B, mem_iUnion, mem_inter_iff, exists_prop] using hx\n  filter_upwards [A_mem_nhdsGT hL₁, A_mem_nhdsGT hL₂] with y hy₁ hy₂\n  simp only [B, mem_iUnion, mem_inter_iff, exists_prop]\n  exact ⟨L, LK, hy₁, hy₂⟩\n\n"}
{"name":"RightDerivMeasurableAux.measurableSet_B","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nK : Set F\nr s ε : Real\n⊢ MeasurableSet (RightDerivMeasurableAux.B f K r s ε)","decl":"theorem measurableSet_B {K : Set F} {r s ε : ℝ} : MeasurableSet (B f K r s ε) :=\n  .of_mem_nhdsGT fun _ hx => B_mem_nhdsGT hx\n\n"}
{"name":"RightDerivMeasurableAux.A_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nL : F\nr ε δ : Real\nh : LE.le ε δ\n⊢ HasSubset.Subset (RightDerivMeasurableAux.A f L r ε) (RightDerivMeasurableAux.A f L r δ)","decl":"theorem A_mono (L : F) (r : ℝ) {ε δ : ℝ} (h : ε ≤ δ) : A f L r ε ⊆ A f L r δ := by\n  rintro x ⟨r', r'r, hr'⟩\n  refine ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).trans (mul_le_mul_of_nonneg_right h ?_)⟩\n  linarith [hy.1, hy.2, r'r.2]\n\n"}
{"name":"RightDerivMeasurableAux.le_of_mem_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nr ε : Real\nL : F\nx : Real\nhx : Membership.mem (RightDerivMeasurableAux.A f L r ε) x\ny z : Real\nhy : Membership.mem (Set.Icc x (HAdd.hAdd x (HDiv.hDiv r 2))) y\nhz : Membership.mem (Set.Icc x (HAdd.hAdd x (HDiv.hDiv r 2))) z\n⊢ LE.le (Norm.norm (HSub.hSub (HSub.hSub (f z) (f y)) (HSMul.hSMul (HSub.hSub z y) L))) (HMul.hMul ε r)","decl":"theorem le_of_mem_A {r ε : ℝ} {L : F} {x : ℝ} (hx : x ∈ A f L r ε) {y z : ℝ}\n    (hy : y ∈ Icc x (x + r / 2)) (hz : z ∈ Icc x (x + r / 2)) :\n  ‖f z - f y - (z - y) • L‖ ≤ ε * r := by\n  rcases hx with ⟨r', r'mem, hr'⟩\n  have A : x + r / 2 ≤ x + r' := by linarith [r'mem.1]\n  exact hr' _ ((Icc_subset_Icc le_rfl A) hy) _ ((Icc_subset_Icc le_rfl A) hz)\n\n"}
{"name":"RightDerivMeasurableAux.mem_A_of_differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nε : Real\nhε : LT.lt 0 ε\nx : Real\nhx : DifferentiableWithinAt Real f (Set.Ici x) x\n⊢ Exists fun R => And (GT.gt R 0) (∀ (r : Real), Membership.mem (Set.Ioo 0 R) r → Membership.mem (RightDerivMeasurableAux.A f (derivWithin f (Set.Ici x) x) r ε) x)","decl":"theorem mem_A_of_differentiable {ε : ℝ} (hε : 0 < ε) {x : ℝ}\n    (hx : DifferentiableWithinAt ℝ f (Ici x) x) :\n    ∃ R > 0, ∀ r ∈ Ioo (0 : ℝ) R, x ∈ A f (derivWithin f (Ici x) x) r ε := by\n  have := hx.hasDerivWithinAt\n  simp_rw [hasDerivWithinAt_iff_isLittleO, isLittleO_iff] at this\n  rcases mem_nhdsGE_iff_exists_Ico_subset.1 (this (half_pos hε)) with ⟨m, xm, hm⟩\n  refine ⟨m - x, by linarith [show x < m from xm], fun r hr => ?_⟩\n  have : r ∈ Ioc (r / 2) r := ⟨half_lt_self hr.1, le_rfl⟩\n  refine ⟨r, this, fun y hy z hz => ?_⟩\n  calc\n    ‖f z - f y - (z - y) • derivWithin f (Ici x) x‖ =\n        ‖f z - f x - (z - x) • derivWithin f (Ici x) x -\n            (f y - f x - (y - x) • derivWithin f (Ici x) x)‖ := by\n      congr 1; simp only [sub_smul]; abel\n    _ ≤\n        ‖f z - f x - (z - x) • derivWithin f (Ici x) x‖ +\n          ‖f y - f x - (y - x) • derivWithin f (Ici x) x‖ :=\n      (norm_sub_le _ _)\n    _ ≤ ε / 2 * ‖z - x‖ + ε / 2 * ‖y - x‖ :=\n      (add_le_add (hm ⟨hz.1, hz.2.trans_lt (by linarith [hr.2])⟩)\n        (hm ⟨hy.1, hy.2.trans_lt (by linarith [hr.2])⟩))\n    _ ≤ ε / 2 * r + ε / 2 * r := by\n      gcongr\n      · rw [Real.norm_of_nonneg] <;> linarith [hz.1, hz.2]\n      · rw [Real.norm_of_nonneg] <;> linarith [hy.1, hy.2]\n    _ = ε * r := by ring\n\n"}
{"name":"RightDerivMeasurableAux.norm_sub_le_of_mem_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nr x : Real\nhr : LT.lt 0 r\nε : Real\nL₁ L₂ : F\nh₁ : Membership.mem (RightDerivMeasurableAux.A f L₁ r ε) x\nh₂ : Membership.mem (RightDerivMeasurableAux.A f L₂ r ε) x\n⊢ LE.le (Norm.norm (HSub.hSub L₁ L₂)) (HMul.hMul 4 ε)","decl":"theorem norm_sub_le_of_mem_A {r x : ℝ} (hr : 0 < r) (ε : ℝ) {L₁ L₂ : F} (h₁ : x ∈ A f L₁ r ε)\n    (h₂ : x ∈ A f L₂ r ε) : ‖L₁ - L₂‖ ≤ 4 * ε := by\n  suffices H : ‖(r / 2) • (L₁ - L₂)‖ ≤ r / 2 * (4 * ε) by\n    rwa [norm_smul, Real.norm_of_nonneg (half_pos hr).le, mul_le_mul_left (half_pos hr)] at H\n  calc\n    ‖(r / 2) • (L₁ - L₂)‖ =\n        ‖f (x + r / 2) - f x - (x + r / 2 - x) • L₂ -\n            (f (x + r / 2) - f x - (x + r / 2 - x) • L₁)‖ := by\n      simp [smul_sub]\n    _ ≤ ‖f (x + r / 2) - f x - (x + r / 2 - x) • L₂‖ +\n          ‖f (x + r / 2) - f x - (x + r / 2 - x) • L₁‖ :=\n      norm_sub_le _ _\n    _ ≤ ε * r + ε * r := by\n      apply add_le_add\n      · apply le_of_mem_A h₂ <;> simp [(half_pos hr).le]\n      · apply le_of_mem_A h₁ <;> simp [(half_pos hr).le]\n    _ = r / 2 * (4 * ε) := by ring\n\n"}
{"name":"RightDerivMeasurableAux.differentiable_set_subset_D","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nK : Set F\n⊢ HasSubset.Subset (setOf fun x => And (DifferentiableWithinAt Real f (Set.Ici x) x) (Membership.mem K (derivWithin f (Set.Ici x) x))) (RightDerivMeasurableAux.D f K)","decl":"/-- Easy inclusion: a differentiability point with derivative in `K` belongs to `D f K`. -/\ntheorem differentiable_set_subset_D :\n    { x | DifferentiableWithinAt ℝ f (Ici x) x ∧ derivWithin f (Ici x) x ∈ K } ⊆ D f K := by\n  intro x hx\n  rw [D, mem_iInter]\n  intro e\n  have : (0 : ℝ) < (1 / 2) ^ e := pow_pos (by norm_num) _\n  rcases mem_A_of_differentiable this hx.1 with ⟨R, R_pos, hR⟩\n  obtain ⟨n, hn⟩ : ∃ n : ℕ, (1 / 2) ^ n < R :=\n    exists_pow_lt_of_lt_one R_pos (by norm_num : (1 : ℝ) / 2 < 1)\n  simp only [mem_iUnion, mem_iInter, B, mem_inter_iff]\n  refine ⟨n, fun p hp q hq => ⟨derivWithin f (Ici x) x, hx.2, ⟨?_, ?_⟩⟩⟩ <;>\n    · refine hR _ ⟨pow_pos (by norm_num) _, lt_of_le_of_lt ?_ hn⟩\n      exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption)\n\n"}
{"name":"RightDerivMeasurableAux.D_subset_differentiable_set","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nK : Set F\nhK : IsComplete K\n⊢ HasSubset.Subset (RightDerivMeasurableAux.D f K) (setOf fun x => And (DifferentiableWithinAt Real f (Set.Ici x) x) (Membership.mem K (derivWithin f (Set.Ici x) x)))","decl":"/-- Harder inclusion: at a point in `D f K`, the function `f` has a derivative, in `K`. -/\ntheorem D_subset_differentiable_set {K : Set F} (hK : IsComplete K) :\n    D f K ⊆ { x | DifferentiableWithinAt ℝ f (Ici x) x ∧ derivWithin f (Ici x) x ∈ K } := by\n  have P : ∀ {n : ℕ}, (0 : ℝ) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n\n  intro x hx\n  have :\n    ∀ e : ℕ, ∃ n : ℕ, ∀ p q, n ≤ p → n ≤ q →\n      ∃ L ∈ K, x ∈ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) ∩ A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by\n    intro e\n    have := mem_iInter.1 hx e\n    rcases mem_iUnion.1 this with ⟨n, hn⟩\n    refine ⟨n, fun p q hp hq => ?_⟩\n    simp only [mem_iInter] at hn\n    rcases mem_iUnion.1 (hn p hp q hq) with ⟨L, hL⟩\n    exact ⟨L, exists_prop.mp <| mem_iUnion.1 hL⟩\n  /- Recast the assumptions: for each `e`, there exist `n e` and linear maps `L e p q` in `K`\n    such that, for `p, q ≥ n e`, then `f` is well approximated by `L e p q` at scale `2 ^ (-p)` and\n    `2 ^ (-q)`, with an error `2 ^ (-e)`. -/\n  choose! n L hn using this\n  /- All the operators `L e p q` that show up are close to each other. To prove this, we argue\n      that `L e p q` is close to `L e p r` (where `r` is large enough), as both approximate `f` at\n      scale `2 ^(- p)`. And `L e p r` is close to `L e' p' r` as both approximate `f` at scale\n      `2 ^ (- r)`. And `L e' p' r` is close to `L e' p' q'` as both approximate `f` at scale\n      `2 ^ (- p')`. -/\n  have M :\n    ∀ e p q e' p' q',\n      n e ≤ p →\n        n e ≤ q → n e' ≤ p' → n e' ≤ q' → e ≤ e' → ‖L e p q - L e' p' q'‖ ≤ 12 * (1 / 2) ^ e := by\n    intro e p q e' p' q' hp hq hp' hq' he'\n    let r := max (n e) (n e')\n    have I : ((1 : ℝ) / 2) ^ e' ≤ (1 / 2) ^ e :=\n      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'\n    have J1 : ‖L e p q - L e p r‖ ≤ 4 * (1 / 2) ^ e := by\n      have I1 : x ∈ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1\n      have I2 : x ∈ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1\n      exact norm_sub_le_of_mem_A P _ I1 I2\n    have J2 : ‖L e p r - L e' p' r‖ ≤ 4 * (1 / 2) ^ e := by\n      have I1 : x ∈ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2\n      have I2 : x ∈ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=\n        (hn e' p' r hp' (le_max_right _ _)).2.2\n      exact norm_sub_le_of_mem_A P _ I1 (A_mono _ _ I I2)\n    have J3 : ‖L e' p' r - L e' p' q'‖ ≤ 4 * (1 / 2) ^ e := by\n      have I1 : x ∈ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=\n        (hn e' p' r hp' (le_max_right _ _)).2.1\n      have I2 : x ∈ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1\n      exact norm_sub_le_of_mem_A P _ (A_mono _ _ I I1) (A_mono _ _ I I2)\n    calc\n      ‖L e p q - L e' p' q'‖ =\n          ‖L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')‖ := by\n        congr 1; abel\n      _ ≤ ‖L e p q - L e p r‖ + ‖L e p r - L e' p' r‖ + ‖L e' p' r - L e' p' q'‖ :=\n        (le_trans (norm_add_le _ _) (add_le_add_right (norm_add_le _ _) _))\n      _ ≤ 4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e := by gcongr\n      _ = 12 * (1 / 2) ^ e := by ring\n\n  /- For definiteness, use `L0 e = L e (n e) (n e)`, to have a single sequence. We claim that this\n    is a Cauchy sequence. -/\n  let L0 : ℕ → F := fun e => L e (n e) (n e)\n  have : CauchySeq L0 := by\n    rw [Metric.cauchySeq_iff']\n    intro ε εpos\n    obtain ⟨e, he⟩ : ∃ e : ℕ, (1 / 2) ^ e < ε / 12 :=\n      exists_pow_lt_of_lt_one (div_pos εpos (by norm_num)) (by norm_num)\n    refine ⟨e, fun e' he' => ?_⟩\n    rw [dist_comm, dist_eq_norm]\n    calc\n      ‖L0 e - L0 e'‖ ≤ 12 * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'\n      _ < 12 * (ε / 12) := mul_lt_mul' le_rfl he (le_of_lt P) (by norm_num)\n      _ = ε := by field_simp [(by norm_num : (12 : ℝ) ≠ 0)]\n\n  -- As it is Cauchy, the sequence `L0` converges, to a limit `f'` in `K`.\n  obtain ⟨f', f'K, hf'⟩ : ∃ f' ∈ K, Tendsto L0 atTop (𝓝 f') :=\n    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this\n  have Lf' : ∀ e p, n e ≤ p → ‖L e (n e) p - f'‖ ≤ 12 * (1 / 2) ^ e := by\n    intro e p hp\n    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm\n    rw [eventually_atTop]\n    exact ⟨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'⟩\n  -- Let us show that `f` has right derivative `f'` at `x`.\n  have : HasDerivWithinAt f f' (Ici x) x := by\n    simp only [hasDerivWithinAt_iff_isLittleO, isLittleO_iff]\n    /- to get an approximation with a precision `ε`, we will replace `f` with `L e (n e) m` for\n      some large enough `e` (yielding a small error by uniform approximation). As one can vary `m`,\n      this makes it possible to cover all scales, and thus to obtain a good linear approximation in\n      the whole interval of length `(1/2)^(n e)`. -/\n    intro ε εpos\n    obtain ⟨e, he⟩ : ∃ e : ℕ, (1 / 2) ^ e < ε / 16 :=\n      exists_pow_lt_of_lt_one (div_pos εpos (by norm_num)) (by norm_num)\n    filter_upwards [Icc_mem_nhdsGE <| show x < x + (1 / 2) ^ (n e + 1) by simp] with y hy\n    -- We need to show that `f y - f x - f' (y - x)` is small. For this, we will work at scale\n    -- `k` where `k` is chosen with `‖y - x‖ ∼ 2 ^ (-k)`.\n    rcases eq_or_lt_of_le hy.1 with (rfl | xy)\n    · simp only [sub_self, zero_smul, norm_zero, mul_zero, le_rfl]\n    have yzero : 0 < y - x := sub_pos.2 xy\n    have y_le : y - x ≤ (1 / 2) ^ (n e + 1) := by linarith [hy.2]\n    have yone : y - x ≤ 1 := le_trans y_le (pow_le_one₀ (by norm_num) (by norm_num))\n    -- define the scale `k`.\n    obtain ⟨k, hk, h'k⟩ : ∃ k : ℕ, (1 / 2) ^ (k + 1) < y - x ∧ y - x ≤ (1 / 2) ^ k :=\n      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : ℝ) < 1 / 2)\n        (by norm_num : (1 : ℝ) / 2 < 1)\n    -- the scale is large enough (as `y - x` is small enough)\n    have k_gt : n e < k := by\n      have : ((1 : ℝ) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_of_lt_of_le hk y_le\n      rw [pow_lt_pow_iff_right_of_lt_one₀ (by norm_num : (0 : ℝ) < 1 / 2) (by norm_num)] at this\n      omega\n    set m := k - 1\n    have m_ge : n e ≤ m := Nat.le_sub_one_of_lt k_gt\n    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm\n    rw [km] at hk h'k\n    -- `f` is well approximated by `L e (n e) k` at the relevant scale\n    -- (in fact, we use `m = k - 1` instead of `k` because of the precise definition of `A`).\n    have J : ‖f y - f x - (y - x) • L e (n e) m‖ ≤ 4 * (1 / 2) ^ e * ‖y - x‖ :=\n      calc\n        ‖f y - f x - (y - x) • L e (n e) m‖ ≤ (1 / 2) ^ e * (1 / 2) ^ m := by\n          apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2\n          · simp only [one_div, inv_pow, left_mem_Icc, le_add_iff_nonneg_right]\n            positivity\n          · simp only [pow_add, tsub_le_iff_left] at h'k\n            simpa only [hy.1, mem_Icc, true_and, one_div, pow_one] using h'k\n        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring\n        _ ≤ 4 * (1 / 2) ^ e * (y - x) := by gcongr\n        _ = 4 * (1 / 2) ^ e * ‖y - x‖ := by rw [Real.norm_of_nonneg yzero.le]\n    calc\n      ‖f y - f x - (y - x) • f'‖ =\n          ‖f y - f x - (y - x) • L e (n e) m + (y - x) • (L e (n e) m - f')‖ := by\n        simp only [smul_sub, sub_add_sub_cancel]\n      _ ≤ 4 * (1 / 2) ^ e * ‖y - x‖ + ‖y - x‖ * (12 * (1 / 2) ^ e) :=\n        norm_add_le_of_le J <| by rw [norm_smul]; gcongr; exact Lf' _ _ m_ge\n      _ = 16 * ‖y - x‖ * (1 / 2) ^ e := by ring\n      _ ≤ 16 * ‖y - x‖ * (ε / 16) := by gcongr\n      _ = ε * ‖y - x‖ := by ring\n\n  rw [← this.derivWithin (uniqueDiffOn_Ici x x Set.left_mem_Ici)] at f'K\n  exact ⟨this.differentiableWithinAt, f'K⟩\n\n"}
{"name":"RightDerivMeasurableAux.differentiable_set_eq_D","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nK : Set F\nhK : IsComplete K\n⊢ Eq (setOf fun x => And (DifferentiableWithinAt Real f (Set.Ici x) x) (Membership.mem K (derivWithin f (Set.Ici x) x))) (RightDerivMeasurableAux.D f K)","decl":"theorem differentiable_set_eq_D (hK : IsComplete K) :\n    { x | DifferentiableWithinAt ℝ f (Ici x) x ∧ derivWithin f (Ici x) x ∈ K } = D f K :=\n  Subset.antisymm (differentiable_set_subset_D _) (D_subset_differentiable_set hK)\n\n"}
{"name":"measurableSet_of_differentiableWithinAt_Ici_of_isComplete","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nK : Set F\nhK : IsComplete K\n⊢ MeasurableSet (setOf fun x => And (DifferentiableWithinAt Real f (Set.Ici x) x) (Membership.mem K (derivWithin f (Set.Ici x) x)))","decl":"/-- The set of right differentiability points of a function, with derivative in a given complete\nset, is Borel-measurable. -/\ntheorem measurableSet_of_differentiableWithinAt_Ici_of_isComplete {K : Set F} (hK : IsComplete K) :\n    MeasurableSet { x | DifferentiableWithinAt ℝ f (Ici x) x ∧ derivWithin f (Ici x) x ∈ K } := by\n  -- simp [differentiable_set_eq_d K hK, D, measurableSet_b, MeasurableSet.iInter,\n  --   MeasurableSet.iUnion]\n  simp only [differentiable_set_eq_D K hK, D]\n  repeat apply_rules [MeasurableSet.iUnion, MeasurableSet.iInter] <;> intro\n  exact measurableSet_B\n\n"}
{"name":"measurableSet_of_differentiableWithinAt_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nf : Real → F\ninst✝ : CompleteSpace F\n⊢ MeasurableSet (setOf fun x => DifferentiableWithinAt Real f (Set.Ici x) x)","decl":"/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem measurableSet_of_differentiableWithinAt_Ici :\n    MeasurableSet { x | DifferentiableWithinAt ℝ f (Ici x) x } := by\n  have : IsComplete (univ : Set F) := complete_univ\n  convert measurableSet_of_differentiableWithinAt_Ici_of_isComplete f this\n  simp\n\n"}
{"name":"measurable_derivWithin_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\nf : Real → F\ninst✝² : CompleteSpace F\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\n⊢ Measurable fun x => derivWithin f (Set.Ici x) x","decl":"@[measurability, fun_prop]\ntheorem measurable_derivWithin_Ici [MeasurableSpace F] [BorelSpace F] :\n    Measurable fun x => derivWithin f (Ici x) x := by\n  refine measurable_of_isClosed fun s hs => ?_\n  have :\n    (fun x => derivWithin f (Ici x) x) ⁻¹' s =\n      { x | DifferentiableWithinAt ℝ f (Ici x) x ∧ derivWithin f (Ici x) x ∈ s } ∪\n        { x | ¬DifferentiableWithinAt ℝ f (Ici x) x } ∩ { _x | (0 : F) ∈ s } :=\n    Set.ext fun x => mem_preimage.trans derivWithin_mem_iff\n  rw [this]\n  exact\n    (measurableSet_of_differentiableWithinAt_Ici_of_isComplete _ hs.isComplete).union\n      ((measurableSet_of_differentiableWithinAt_Ici _).compl.inter (MeasurableSet.const _))\n\n"}
{"name":"stronglyMeasurable_derivWithin_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nf : Real → F\ninst✝ : CompleteSpace F\n⊢ MeasureTheory.StronglyMeasurable fun x => derivWithin f (Set.Ici x) x","decl":"theorem stronglyMeasurable_derivWithin_Ici :\n    StronglyMeasurable (fun x ↦ derivWithin f (Ici x) x) := by\n  borelize F\n  apply stronglyMeasurable_iff_measurable_separable.2 ⟨measurable_derivWithin_Ici f, ?_⟩\n  obtain ⟨t, t_count, ht⟩ : ∃ t : Set ℝ, t.Countable ∧ Dense t := exists_countable_dense ℝ\n  suffices H : range (fun x ↦ derivWithin f (Ici x) x) ⊆ closure (Submodule.span ℝ (f '' t)) from\n    IsSeparable.mono (t_count.image f).isSeparable.span.closure H\n  rintro - ⟨x, rfl⟩\n  suffices H' : range (fun y ↦ derivWithin f (Ici x) y) ⊆ closure (Submodule.span ℝ (f '' t)) from\n    H' (mem_range_self _)\n  apply range_derivWithin_subset_closure_span_image\n  calc Ici x\n    = closure (Ioi x ∩ closure t) := by simp [dense_iff_closure_eq.1 ht]\n  _ ⊆ closure (closure (Ioi x ∩ t)) := by\n      apply closure_mono\n      simpa [inter_comm] using (isOpen_Ioi (a := x)).closure_inter (s := t)\n  _ ⊆ closure (Ici x ∩ t) := by\n      rw [closure_closure]\n      exact closure_mono (inter_subset_inter_left _ Ioi_subset_Ici_self)\n\n"}
{"name":"aemeasurable_derivWithin_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\nf : Real → F\ninst✝² : CompleteSpace F\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\nμ : MeasureTheory.Measure Real\n⊢ AEMeasurable (fun x => derivWithin f (Set.Ici x) x) μ","decl":"theorem aemeasurable_derivWithin_Ici [MeasurableSpace F] [BorelSpace F] (μ : Measure ℝ) :\n    AEMeasurable (fun x => derivWithin f (Ici x) x) μ :=\n  (measurable_derivWithin_Ici f).aemeasurable\n\n"}
{"name":"aestronglyMeasurable_derivWithin_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nf : Real → F\ninst✝ : CompleteSpace F\nμ : MeasureTheory.Measure Real\n⊢ MeasureTheory.AEStronglyMeasurable (fun x => derivWithin f (Set.Ici x) x) μ","decl":"theorem aestronglyMeasurable_derivWithin_Ici (μ : Measure ℝ) :\n    AEStronglyMeasurable (fun x => derivWithin f (Ici x) x) μ :=\n  (stronglyMeasurable_derivWithin_Ici f).aestronglyMeasurable\n\n"}
{"name":"measurableSet_of_differentiableWithinAt_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nf : Real → F\ninst✝ : CompleteSpace F\n⊢ MeasurableSet (setOf fun x => DifferentiableWithinAt Real f (Set.Ioi x) x)","decl":"/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem measurableSet_of_differentiableWithinAt_Ioi :\n    MeasurableSet { x | DifferentiableWithinAt ℝ f (Ioi x) x } := by\n  simpa [differentiableWithinAt_Ioi_iff_Ici] using measurableSet_of_differentiableWithinAt_Ici f\n\n"}
{"name":"measurable_derivWithin_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\nf : Real → F\ninst✝² : CompleteSpace F\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\n⊢ Measurable fun x => derivWithin f (Set.Ioi x) x","decl":"@[measurability, fun_prop]\ntheorem measurable_derivWithin_Ioi [MeasurableSpace F] [BorelSpace F] :\n    Measurable fun x => derivWithin f (Ioi x) x := by\n  simpa [derivWithin_Ioi_eq_Ici] using measurable_derivWithin_Ici f\n\n"}
{"name":"stronglyMeasurable_derivWithin_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nf : Real → F\ninst✝ : CompleteSpace F\n⊢ MeasureTheory.StronglyMeasurable fun x => derivWithin f (Set.Ioi x) x","decl":"theorem stronglyMeasurable_derivWithin_Ioi :\n    StronglyMeasurable (fun x ↦ derivWithin f (Ioi x) x) := by\n  simpa [derivWithin_Ioi_eq_Ici] using stronglyMeasurable_derivWithin_Ici f\n\n"}
{"name":"aemeasurable_derivWithin_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\nf : Real → F\ninst✝² : CompleteSpace F\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\nμ : MeasureTheory.Measure Real\n⊢ AEMeasurable (fun x => derivWithin f (Set.Ioi x) x) μ","decl":"theorem aemeasurable_derivWithin_Ioi [MeasurableSpace F] [BorelSpace F] (μ : Measure ℝ) :\n    AEMeasurable (fun x => derivWithin f (Ioi x) x) μ :=\n  (measurable_derivWithin_Ioi f).aemeasurable\n\n"}
{"name":"aestronglyMeasurable_derivWithin_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nf : Real → F\ninst✝ : CompleteSpace F\nμ : MeasureTheory.Measure Real\n⊢ MeasureTheory.AEStronglyMeasurable (fun x => derivWithin f (Set.Ioi x) x) μ","decl":"theorem aestronglyMeasurable_derivWithin_Ioi (μ : Measure ℝ) :\n    AEStronglyMeasurable (fun x => derivWithin f (Ioi x) x) μ :=\n  (stronglyMeasurable_derivWithin_Ioi f).aestronglyMeasurable\n\n"}
{"name":"FDerivMeasurableAux.isOpen_A_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : LocallyCompactSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝ : TopologicalSpace α\nf : α → E → F\nr s : Real\nhf : Continuous (Function.uncurry f)\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ IsOpen (setOf fun p => Membership.mem (FDerivMeasurableAux.A (f p.1) L r s) p.2)","decl":"lemma isOpen_A_with_param {r s : ℝ} (hf : Continuous f.uncurry) (L : E →L[𝕜] F) :\n    IsOpen {p : α × E | p.2 ∈ A (f p.1) L r s} := by\n  have : ProperSpace E := .of_locallyCompactSpace 𝕜\n  simp only [A, half_lt_self_iff, not_lt, mem_Ioc, mem_ball, map_sub, mem_setOf_eq]\n  apply isOpen_iff_mem_nhds.2\n  rintro ⟨a, x⟩ ⟨r', ⟨Irr', Ir'r⟩, hr⟩\n  have ha : Continuous (f a) := hf.uncurry_left a\n  rcases exists_between Irr' with ⟨t, hrt, htr'⟩\n  rcases exists_between hrt with ⟨t', hrt', ht't⟩\n  obtain ⟨b, b_lt, hb⟩ : ∃ b, b < s * r ∧ ∀ y ∈ closedBall x t, ∀ z ∈ closedBall x t,\n      ‖f a z - f a y - (L z - L y)‖ ≤ b := by\n    have B : Continuous (fun (p : E × E) ↦ ‖f a p.2 - f a p.1 - (L p.2 - L p.1)‖) := by fun_prop\n    have C : (closedBall x t ×ˢ closedBall x t).Nonempty := by simp; linarith\n    rcases ((isCompact_closedBall x t).prod (isCompact_closedBall x t)).exists_isMaxOn\n      C B.continuousOn with ⟨p, pt, hp⟩\n    simp only [mem_prod, mem_closedBall] at pt\n    refine ⟨‖f a p.2 - f a p.1 - (L p.2 - L p.1)‖,\n      hr p.1 (pt.1.trans_lt htr') p.2 (pt.2.trans_lt htr'), fun y hy z hz ↦ ?_⟩\n    have D : (y, z) ∈ closedBall x t ×ˢ closedBall x t := mem_prod.2 ⟨hy, hz⟩\n    exact hp D\n  obtain ⟨ε, εpos, hε⟩ : ∃ ε, 0 < ε ∧ b + 2 * ε < s * r :=\n    ⟨(s * r - b) / 3, by linarith, by linarith⟩\n  obtain ⟨u, u_open, au, hu⟩ : ∃ u, IsOpen u ∧ a ∈ u ∧ ∀ (p : α × E),\n      p.1 ∈ u → p.2 ∈ closedBall x t → dist (f.uncurry p) (f.uncurry (a, p.2)) < ε := by\n    have C : Continuous (fun (p : α × E) ↦ f a p.2) := by fun_prop\n    have D : ({a} ×ˢ closedBall x t).EqOn f.uncurry (fun p ↦ f a p.2) := by\n      rintro ⟨b, y⟩ ⟨hb, -⟩\n      simp only [mem_singleton_iff] at hb\n      simp [hb]\n    obtain ⟨v, v_open, sub_v, hv⟩ : ∃ v, IsOpen v ∧ {a} ×ˢ closedBall x t ⊆ v ∧\n        ∀ p ∈ v, dist (Function.uncurry f p) (f a p.2) < ε :=\n      Uniform.exists_is_open_mem_uniformity_of_forall_mem_eq (s := {a} ×ˢ closedBall x t)\n        (fun p _ ↦ hf.continuousAt) (fun p _ ↦ C.continuousAt) D (dist_mem_uniformity εpos)\n    obtain ⟨w, w', w_open, -, sub_w, sub_w', hww'⟩ : ∃ (w : Set α) (w' : Set E),\n        IsOpen w ∧ IsOpen w' ∧ {a} ⊆ w ∧ closedBall x t ⊆ w' ∧ w ×ˢ w' ⊆ v :=\n      generalized_tube_lemma isCompact_singleton (isCompact_closedBall x t) v_open sub_v\n    refine ⟨w, w_open, sub_w rfl, ?_⟩\n    rintro ⟨b, y⟩ h hby\n    exact hv _ (hww' ⟨h, sub_w' hby⟩)\n  have : u ×ˢ ball x (t - t') ∈ 𝓝 (a, x) :=\n    prod_mem_nhds (u_open.mem_nhds au) (ball_mem_nhds _ (sub_pos.2 ht't))\n  filter_upwards [this]\n  rintro ⟨a', x'⟩ ha'x'\n  simp only [mem_prod, mem_ball] at ha'x'\n  refine ⟨t', ⟨hrt', ht't.le.trans (htr'.le.trans Ir'r)⟩, fun y hy z hz ↦ ?_⟩\n  have dyx : dist y x ≤ t := by linarith [dist_triangle y x' x]\n  have dzx : dist z x ≤ t := by linarith [dist_triangle z x' x]\n  calc\n  ‖f a' z - f a' y - (L z - L y)‖ =\n    ‖(f a' z - f a z) + (f a y - f a' y) + (f a z - f a y - (L z - L y))‖ := by congr; abel\n  _ ≤ ‖f a' z - f a z‖ + ‖f a y - f a' y‖ + ‖f a z - f a y - (L z - L y)‖ := norm_add₃_le\n  _ ≤ ε + ε + b := by\n      gcongr\n      · rw [← dist_eq_norm]\n        change dist (f.uncurry (a', z)) (f.uncurry (a, z)) ≤ ε\n        apply (hu _ _ _).le\n        · exact ha'x'.1\n        · simp [dzx]\n      · rw [← dist_eq_norm']\n        change dist (f.uncurry (a', y)) (f.uncurry (a, y)) ≤ ε\n        apply (hu _ _ _).le\n        · exact ha'x'.1\n        · simp [dyx]\n      · simp [hb, dyx, dzx]\n  _ < s * r := by linarith\n\n"}
{"name":"FDerivMeasurableAux.isOpen_B_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : LocallyCompactSpace E\nF : Type u_3\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝ : TopologicalSpace α\nf : α → E → F\nr s t : Real\nhf : Continuous (Function.uncurry f)\nK : Set (ContinuousLinearMap (RingHom.id 𝕜) E F)\n⊢ IsOpen (setOf fun p => Membership.mem (FDerivMeasurableAux.B (f p.1) K r s t) p.2)","decl":"lemma isOpen_B_with_param {r s t : ℝ} (hf : Continuous f.uncurry) (K : Set (E →L[𝕜] F)) :\n    IsOpen {p : α × E | p.2 ∈ B (f p.1) K r s t} := by\n  suffices H : IsOpen (⋃ L ∈ K,\n      {p : α × E | p.2 ∈ A (f p.1) L r t ∧ p.2 ∈ A (f p.1) L s t}) by\n    convert H; ext p; simp [B]\n  refine isOpen_biUnion (fun L _ ↦ ?_)\n  exact (isOpen_A_with_param hf L).inter (isOpen_A_with_param hf L)\n\n"}
{"name":"measurableSet_of_differentiableAt_of_isComplete_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : LocallyCompactSpace E\nF : Type u_3\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝⁴ : TopologicalSpace α\nf : α → E → F\ninst✝³ : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : MeasurableSpace E\ninst✝ : OpensMeasurableSpace E\nhf : Continuous (Function.uncurry f)\nK : Set (ContinuousLinearMap (RingHom.id 𝕜) E F)\nhK : IsComplete K\n⊢ MeasurableSet (setOf fun p => And (DifferentiableAt 𝕜 (f p.1) p.2) (Membership.mem K (fderiv 𝕜 (f p.1) p.2)))","decl":"theorem measurableSet_of_differentiableAt_of_isComplete_with_param\n    (hf : Continuous f.uncurry) {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :\n    MeasurableSet {p : α × E | DifferentiableAt 𝕜 (f p.1) p.2 ∧ fderiv 𝕜 (f p.1) p.2 ∈ K} := by\n  have : {p : α × E | DifferentiableAt 𝕜 (f p.1) p.2 ∧ fderiv 𝕜 (f p.1) p.2 ∈ K}\n          = {p : α × E | p.2 ∈ D (f p.1) K} := by simp [← differentiable_set_eq_D K hK]\n  rw [this]\n  simp only [D, mem_iInter, mem_iUnion]\n  simp only [setOf_forall, setOf_exists]\n  refine MeasurableSet.iInter (fun _ ↦ ?_)\n  refine MeasurableSet.iUnion (fun _ ↦ ?_)\n  refine MeasurableSet.iInter (fun _ ↦ ?_)\n  refine MeasurableSet.iInter (fun _ ↦ ?_)\n  refine MeasurableSet.iInter (fun _ ↦ ?_)\n  refine MeasurableSet.iInter (fun _ ↦ ?_)\n  have : ProperSpace E := .of_locallyCompactSpace 𝕜\n  exact (isOpen_B_with_param hf K).measurableSet\n\n"}
{"name":"measurableSet_of_differentiableAt_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝¹¹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : LocallyCompactSpace E\nF : Type u_3\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝⁵ : TopologicalSpace α\nf : α → E → F\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : MeasurableSpace E\ninst✝¹ : OpensMeasurableSpace E\ninst✝ : CompleteSpace F\nhf : Continuous (Function.uncurry f)\n⊢ MeasurableSet (setOf fun p => DifferentiableAt 𝕜 (f p.1) p.2)","decl":"/-- The set of differentiability points of a continuous function depending on a parameter taking\nvalues in a complete space is Borel-measurable. -/\ntheorem measurableSet_of_differentiableAt_with_param (hf : Continuous f.uncurry) :\n    MeasurableSet {p : α × E | DifferentiableAt 𝕜 (f p.1) p.2} := by\n  have : IsComplete (univ : Set (E →L[𝕜] F)) := complete_univ\n  convert measurableSet_of_differentiableAt_of_isComplete_with_param hf this\n  simp\n\n"}
{"name":"measurable_fderiv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝¹¹ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : LocallyCompactSpace E\nF : Type u_3\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝⁵ : TopologicalSpace α\nf : α → E → F\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : MeasurableSpace E\ninst✝¹ : OpensMeasurableSpace E\ninst✝ : CompleteSpace F\nhf : Continuous (Function.uncurry f)\n⊢ Measurable fun p => fderiv 𝕜 (f p.1) p.2","decl":"theorem measurable_fderiv_with_param (hf : Continuous f.uncurry) :\n    Measurable (fun (p : α × E) ↦ fderiv 𝕜 (f p.1) p.2) := by\n  refine measurable_of_isClosed (fun s hs ↦ ?_)\n  have :\n    (fun (p : α × E) ↦ fderiv 𝕜 (f p.1) p.2) ⁻¹' s =\n      {p | DifferentiableAt 𝕜 (f p.1) p.2 ∧ fderiv 𝕜 (f p.1) p.2 ∈ s } ∪\n        { p | ¬DifferentiableAt 𝕜 (f p.1) p.2} ∩ { _p | (0 : E →L[𝕜] F) ∈ s} :=\n    Set.ext (fun x ↦ mem_preimage.trans fderiv_mem_iff)\n  rw [this]\n  exact\n    (measurableSet_of_differentiableAt_of_isComplete_with_param hf hs.isComplete).union\n      ((measurableSet_of_differentiableAt_with_param _ hf).compl.inter (MeasurableSet.const _))\n\n"}
{"name":"measurable_fderiv_apply_const_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝¹³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedSpace 𝕜 E\ninst✝¹⁰ : LocallyCompactSpace E\nF : Type u_3\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝⁷ : TopologicalSpace α\nf : α → E → F\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : OpensMeasurableSpace α\ninst✝⁴ : MeasurableSpace E\ninst✝³ : OpensMeasurableSpace E\ninst✝² : CompleteSpace F\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\nhf : Continuous (Function.uncurry f)\ny : E\n⊢ Measurable fun p => (fderiv 𝕜 (f p.1) p.2) y","decl":"theorem measurable_fderiv_apply_const_with_param [MeasurableSpace F] [BorelSpace F]\n    (hf : Continuous f.uncurry) (y : E) :\n    Measurable (fun (p : α × E) ↦ fderiv 𝕜 (f p.1) p.2 y) :=\n  (ContinuousLinearMap.measurable_apply y).comp (measurable_fderiv_with_param 𝕜 hf)\n\n"}
{"name":"measurable_deriv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝¹¹ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝¹⁰ : NormedAddCommGroup F\ninst✝⁹ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : MeasurableSpace α\ninst✝⁶ : OpensMeasurableSpace α\ninst✝⁵ : CompleteSpace F\ninst✝⁴ : LocallyCompactSpace 𝕜\ninst✝³ : MeasurableSpace 𝕜\ninst✝² : OpensMeasurableSpace 𝕜\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\nf : α → 𝕜 → F\nhf : Continuous (Function.uncurry f)\n⊢ Measurable fun p => deriv (f p.1) p.2","decl":"theorem measurable_deriv_with_param [LocallyCompactSpace 𝕜] [MeasurableSpace 𝕜]\n    [OpensMeasurableSpace 𝕜] [MeasurableSpace F]\n    [BorelSpace F] {f : α → 𝕜 → F} (hf : Continuous f.uncurry) :\n    Measurable (fun (p : α × 𝕜) ↦ deriv (f p.1) p.2) := by\n  simpa only [fderiv_deriv] using measurable_fderiv_apply_const_with_param 𝕜 hf 1\n\n"}
{"name":"stronglyMeasurable_deriv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝⁹ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : OpensMeasurableSpace α\ninst✝³ : CompleteSpace F\ninst✝² : LocallyCompactSpace 𝕜\ninst✝¹ : MeasurableSpace 𝕜\ninst✝ : OpensMeasurableSpace 𝕜\nh : SecondCountableTopologyEither α F\nf : α → 𝕜 → F\nhf : Continuous (Function.uncurry f)\n⊢ MeasureTheory.StronglyMeasurable fun p => deriv (f p.1) p.2","decl":"theorem stronglyMeasurable_deriv_with_param [LocallyCompactSpace 𝕜] [MeasurableSpace 𝕜]\n    [OpensMeasurableSpace 𝕜] [h : SecondCountableTopologyEither α F]\n    {f : α → 𝕜 → F} (hf : Continuous f.uncurry) :\n    StronglyMeasurable (fun (p : α × 𝕜) ↦ deriv (f p.1) p.2) := by\n  borelize F\n  rcases h.out with hα|hF\n  · have : ProperSpace 𝕜 := .of_locallyCompactSpace 𝕜\n    apply stronglyMeasurable_iff_measurable_separable.2 ⟨measurable_deriv_with_param hf, ?_⟩\n    have : range (fun (p : α × 𝕜) ↦ deriv (f p.1) p.2)\n        ⊆ closure (Submodule.span 𝕜 (range f.uncurry)) := by\n      rintro - ⟨p, rfl⟩\n      have A : deriv (f p.1) p.2 ∈ closure (Submodule.span 𝕜 (range (f p.1))) := by\n        rw [← image_univ]\n        apply range_deriv_subset_closure_span_image _ dense_univ (mem_range_self _)\n      have B : range (f p.1) ⊆ range (f.uncurry) := by\n        rintro - ⟨x, rfl⟩\n        exact mem_range_self (p.1, x)\n      exact closure_mono (Submodule.span_mono B) A\n    exact (isSeparable_range hf).span.closure.mono this\n  · exact (measurable_deriv_with_param hf).stronglyMeasurable\n\n"}
{"name":"aemeasurable_deriv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝¹¹ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝¹⁰ : NormedAddCommGroup F\ninst✝⁹ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : MeasurableSpace α\ninst✝⁶ : OpensMeasurableSpace α\ninst✝⁵ : CompleteSpace F\ninst✝⁴ : LocallyCompactSpace 𝕜\ninst✝³ : MeasurableSpace 𝕜\ninst✝² : OpensMeasurableSpace 𝕜\ninst✝¹ : MeasurableSpace F\ninst✝ : BorelSpace F\nf : α → 𝕜 → F\nhf : Continuous (Function.uncurry f)\nμ : MeasureTheory.Measure (Prod α 𝕜)\n⊢ AEMeasurable (fun p => deriv (f p.1) p.2) μ","decl":"theorem aemeasurable_deriv_with_param [LocallyCompactSpace 𝕜] [MeasurableSpace 𝕜]\n    [OpensMeasurableSpace 𝕜] [MeasurableSpace F]\n    [BorelSpace F] {f : α → 𝕜 → F} (hf : Continuous f.uncurry) (μ : Measure (α × 𝕜)) :\n    AEMeasurable (fun (p : α × 𝕜) ↦ deriv (f p.1) p.2) μ :=\n  (measurable_deriv_with_param hf).aemeasurable\n\n"}
{"name":"aestronglyMeasurable_deriv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nF : Type u_3\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\nα : Type u_4\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : OpensMeasurableSpace α\ninst✝⁴ : CompleteSpace F\ninst✝³ : LocallyCompactSpace 𝕜\ninst✝² : MeasurableSpace 𝕜\ninst✝¹ : OpensMeasurableSpace 𝕜\ninst✝ : SecondCountableTopologyEither α F\nf : α → 𝕜 → F\nhf : Continuous (Function.uncurry f)\nμ : MeasureTheory.Measure (Prod α 𝕜)\n⊢ MeasureTheory.AEStronglyMeasurable (fun p => deriv (f p.1) p.2) μ","decl":"theorem aestronglyMeasurable_deriv_with_param [LocallyCompactSpace 𝕜] [MeasurableSpace 𝕜]\n    [OpensMeasurableSpace 𝕜] [SecondCountableTopologyEither α F]\n    {f : α → 𝕜 → F} (hf : Continuous f.uncurry) (μ : Measure (α × 𝕜)) :\n    AEStronglyMeasurable (fun (p : α × 𝕜) ↦ deriv (f p.1) p.2) μ :=\n  (stronglyMeasurable_deriv_with_param hf).aestronglyMeasurable\n\n"}
