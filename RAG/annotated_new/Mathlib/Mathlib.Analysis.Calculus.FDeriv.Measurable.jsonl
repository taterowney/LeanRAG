{"name":"ContinuousLinearMap.measurable_applyâ‚‚","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : MeasurableSpace E\ninstâœÂ³ : OpensMeasurableSpace E\ninstâœÂ² : SecondCountableTopologyEither (ContinuousLinearMap (RingHom.id ğ•œ) E F) E\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nâŠ¢ Measurable fun p => p.1 p.2","decl":"theorem measurable_applyâ‚‚ [MeasurableSpace E] [OpensMeasurableSpace E]\n    [SecondCountableTopologyEither (E â†’L[ğ•œ] F) E]\n    [MeasurableSpace F] [BorelSpace F] : Measurable fun p : (E â†’L[ğ•œ] F) Ã— E => p.1 p.2 :=\n  isBoundedBilinearMap_apply.continuous.measurable\n\n"}
{"name":"FDerivMeasurableAux.isOpen_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nr Îµ : Real\nâŠ¢ IsOpen (FDerivMeasurableAux.A f L r Îµ)","decl":"theorem isOpen_A (L : E â†’L[ğ•œ] F) (r Îµ : â„) : IsOpen (A f L r Îµ) := by\n  rw [Metric.isOpen_iff]\n  rintro x âŸ¨r', r'_mem, hr'âŸ©\n  obtain âŸ¨s, s_gt, s_ltâŸ© : âˆƒ s : â„, r / 2 < s âˆ§ s < r' := exists_between r'_mem.1\n  have : s âˆˆ Ioc (r / 2) r := âŸ¨s_gt, le_of_lt (s_lt.trans_le r'_mem.2)âŸ©\n  refine âŸ¨r' - s, by linarith, fun x' hx' => âŸ¨s, this, ?_âŸ©âŸ©\n  have B : ball x' s âŠ† ball x r' := ball_subset (le_of_lt hx')\n  intro y hy z hz\n  exact hr' y (B hy) z (B hz)\n\n"}
{"name":"FDerivMeasurableAux.isOpen_B","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nK : Set (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nr s Îµ : Real\nâŠ¢ IsOpen (FDerivMeasurableAux.B f K r s Îµ)","decl":"theorem isOpen_B {K : Set (E â†’L[ğ•œ] F)} {r s Îµ : â„} : IsOpen (B f K r s Îµ) := by\n  simp [B, isOpen_biUnion, IsOpen.inter, isOpen_A]\n\n"}
{"name":"FDerivMeasurableAux.A_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nr Îµ Î´ : Real\nh : LE.le Îµ Î´\nâŠ¢ HasSubset.Subset (FDerivMeasurableAux.A f L r Îµ) (FDerivMeasurableAux.A f L r Î´)","decl":"theorem A_mono (L : E â†’L[ğ•œ] F) (r : â„) {Îµ Î´ : â„} (h : Îµ â‰¤ Î´) : A f L r Îµ âŠ† A f L r Î´ := by\n  rintro x âŸ¨r', r'r, hr'âŸ©\n  refine âŸ¨r', r'r, fun y hy z hz => (hr' y hy z hz).trans_le (mul_le_mul_of_nonneg_right h ?_)âŸ©\n  linarith [mem_ball.1 hy, r'r.2, @dist_nonneg _ _ y x]\n\n"}
{"name":"FDerivMeasurableAux.le_of_mem_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nr Îµ : Real\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nhx : Membership.mem (FDerivMeasurableAux.A f L r Îµ) x\ny z : E\nhy : Membership.mem (Metric.closedBall x (HDiv.hDiv r 2)) y\nhz : Membership.mem (Metric.closedBall x (HDiv.hDiv r 2)) z\nâŠ¢ LE.le (Norm.norm (HSub.hSub (HSub.hSub (f z) (f y)) (L (HSub.hSub z y)))) (HMul.hMul Îµ r)","decl":"theorem le_of_mem_A {r Îµ : â„} {L : E â†’L[ğ•œ] F} {x : E} (hx : x âˆˆ A f L r Îµ) {y z : E}\n    (hy : y âˆˆ closedBall x (r / 2)) (hz : z âˆˆ closedBall x (r / 2)) :\n    â€–f z - f y - L (z - y)â€– â‰¤ Îµ * r := by\n  rcases hx with âŸ¨r', r'mem, hr'âŸ©\n  apply le_of_lt\n  exact hr' _ ((mem_closedBall.1 hy).trans_lt r'mem.1) _ ((mem_closedBall.1 hz).trans_lt r'mem.1)\n\n"}
{"name":"FDerivMeasurableAux.mem_A_of_differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nÎµ : Real\nhÎµ : LT.lt 0 Îµ\nx : E\nhx : DifferentiableAt ğ•œ f x\nâŠ¢ Exists fun R => And (GT.gt R 0) (âˆ€ (r : Real), Membership.mem (Set.Ioo 0 R) r â†’ Membership.mem (FDerivMeasurableAux.A f (fderiv ğ•œ f x) r Îµ) x)","decl":"theorem mem_A_of_differentiable {Îµ : â„} (hÎµ : 0 < Îµ) {x : E} (hx : DifferentiableAt ğ•œ f x) :\n    âˆƒ R > 0, âˆ€ r âˆˆ Ioo (0 : â„) R, x âˆˆ A f (fderiv ğ•œ f x) r Îµ := by\n  let Î´ := (Îµ / 2) / 2\n  obtain âŸ¨R, R_pos, hRâŸ© :\n      âˆƒ R > 0, âˆ€ y âˆˆ ball x R, â€–f y - f x - fderiv ğ•œ f x (y - x)â€– â‰¤ Î´ * â€–y - xâ€– :=\n    eventually_nhds_iff_ball.1 <| hx.hasFDerivAt.isLittleO.bound <| by positivity\n  refine âŸ¨R, R_pos, fun r hr => ?_âŸ©\n  have : r âˆˆ Ioc (r / 2) r := right_mem_Ioc.2 <| half_lt_self hr.1\n  refine âŸ¨r, this, fun y hy z hz => ?_âŸ©\n  calc\n    â€–f z - f y - (fderiv ğ•œ f x) (z - y)â€– =\n        â€–f z - f x - (fderiv ğ•œ f x) (z - x) - (f y - f x - (fderiv ğ•œ f x) (y - x))â€– := by\n      simp only [map_sub]; abel_nf\n    _ â‰¤ â€–f z - f x - (fderiv ğ•œ f x) (z - x)â€– + â€–f y - f x - (fderiv ğ•œ f x) (y - x)â€– :=\n      norm_sub_le _ _\n    _ â‰¤ Î´ * â€–z - xâ€– + Î´ * â€–y - xâ€– :=\n      add_le_add (hR _ (ball_subset_ball hr.2.le hz)) (hR _ (ball_subset_ball hr.2.le hy))\n    _ â‰¤ Î´ * r + Î´ * r := by rw [mem_ball_iff_norm] at hz hy; gcongr\n    _ = (Îµ / 2) * r := by ring\n    _ < Îµ * r := by gcongr; exacts [hr.1, half_lt_self hÎµ]\n\n"}
{"name":"FDerivMeasurableAux.norm_sub_le_of_mem_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nr Îµ : Real\nhÎµ : LT.lt 0 Îµ\nhr : LT.lt 0 r\nx : E\nLâ‚ Lâ‚‚ : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhâ‚ : Membership.mem (FDerivMeasurableAux.A f Lâ‚ r Îµ) x\nhâ‚‚ : Membership.mem (FDerivMeasurableAux.A f Lâ‚‚ r Îµ) x\nâŠ¢ LE.le (Norm.norm (HSub.hSub Lâ‚ Lâ‚‚)) (HMul.hMul (HMul.hMul 4 (Norm.norm c)) Îµ)","decl":"theorem norm_sub_le_of_mem_A {c : ğ•œ} (hc : 1 < â€–câ€–) {r Îµ : â„} (hÎµ : 0 < Îµ) (hr : 0 < r) {x : E}\n    {Lâ‚ Lâ‚‚ : E â†’L[ğ•œ] F} (hâ‚ : x âˆˆ A f Lâ‚ r Îµ) (hâ‚‚ : x âˆˆ A f Lâ‚‚ r Îµ) : â€–Lâ‚ - Lâ‚‚â€– â‰¤ 4 * â€–câ€– * Îµ := by\n  refine opNorm_le_of_shell (half_pos hr) (by positivity) hc ?_\n  intro y ley ylt\n  rw [div_div, div_le_iffâ‚€' (mul_pos (by norm_num : (0 : â„) < 2) (zero_lt_one.trans hc))] at ley\n  calc\n    â€–(Lâ‚ - Lâ‚‚) yâ€– = â€–f (x + y) - f x - Lâ‚‚ (x + y - x) - (f (x + y) - f x - Lâ‚ (x + y - x))â€– := by\n      simp\n    _ â‰¤ â€–f (x + y) - f x - Lâ‚‚ (x + y - x)â€– + â€–f (x + y) - f x - Lâ‚ (x + y - x)â€– := norm_sub_le _ _\n    _ â‰¤ Îµ * r + Îµ * r := by\n      apply add_le_add\n      Â· apply le_of_mem_A hâ‚‚\n        Â· simp only [le_of_lt (half_pos hr), mem_closedBall, dist_self]\n        Â· simp only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, ylt.le]\n      Â· apply le_of_mem_A hâ‚\n        Â· simp only [le_of_lt (half_pos hr), mem_closedBall, dist_self]\n        Â· simp only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, ylt.le]\n    _ = 2 * Îµ * r := by ring\n    _ â‰¤ 2 * Îµ * (2 * â€–câ€– * â€–yâ€–) := by gcongr\n    _ = 4 * â€–câ€– * Îµ * â€–yâ€– := by ring\n\n"}
{"name":"FDerivMeasurableAux.differentiable_set_subset_D","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nK : Set (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nâŠ¢ HasSubset.Subset (setOf fun x => And (DifferentiableAt ğ•œ f x) (Membership.mem K (fderiv ğ•œ f x))) (FDerivMeasurableAux.D f K)","decl":"/-- Easy inclusion: a differentiability point with derivative in `K` belongs to `D f K`. -/\ntheorem differentiable_set_subset_D :\n    { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } âŠ† D f K := by\n  intro x hx\n  rw [D, mem_iInter]\n  intro e\n  have : (0 : â„) < (1 / 2) ^ e := by positivity\n  rcases mem_A_of_differentiable this hx.1 with âŸ¨R, R_pos, hRâŸ©\n  obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, (1 / 2) ^ n < R :=\n    exists_pow_lt_of_lt_one R_pos (by norm_num : (1 : â„) / 2 < 1)\n  simp only [mem_iUnion, mem_iInter, B, mem_inter_iff]\n  refine âŸ¨n, fun p hp q hq => âŸ¨fderiv ğ•œ f x, hx.2, âŸ¨?_, ?_âŸ©âŸ©âŸ© <;>\n    Â· refine hR _ âŸ¨pow_pos (by norm_num) _, lt_of_le_of_lt ?_ hnâŸ©\n      exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption)\n\n"}
{"name":"FDerivMeasurableAux.D_subset_differentiable_set","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nK : Set (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nhK : IsComplete K\nâŠ¢ HasSubset.Subset (FDerivMeasurableAux.D f K) (setOf fun x => And (DifferentiableAt ğ•œ f x) (Membership.mem K (fderiv ğ•œ f x)))","decl":"/-- Harder inclusion: at a point in `D f K`, the function `f` has a derivative, in `K`. -/\ntheorem D_subset_differentiable_set {K : Set (E â†’L[ğ•œ] F)} (hK : IsComplete K) :\n    D f K âŠ† { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } := by\n  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n\n  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©\n  intro x hx\n  have :\n    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’\n      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by\n    intro e\n    have := mem_iInter.1 hx e\n    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©\n    refine âŸ¨n, fun p q hp hq => ?_âŸ©\n    simp only [mem_iInter] at hn\n    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©\n    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©\n  /- Recast the assumptions: for each `e`, there exist `n e` and linear maps `L e p q` in `K`\n    such that, for `p, q â‰¥ n e`, then `f` is well approximated by `L e p q` at scale `2 ^ (-p)` and\n    `2 ^ (-q)`, with an error `2 ^ (-e)`. -/\n  choose! n L hn using this\n  /- All the operators `L e p q` that show up are close to each other. To prove this, we argue\n      that `L e p q` is close to `L e p r` (where `r` is large enough), as both approximate `f` at\n      scale `2 ^(- p)`. And `L e p r` is close to `L e' p' r` as both approximate `f` at scale\n      `2 ^ (- r)`. And `L e' p' r` is close to `L e' p' q'` as both approximate `f` at scale\n      `2 ^ (- p')`. -/\n  have M :\n    âˆ€ e p q e' p' q',\n      n e â‰¤ p â†’\n        n e â‰¤ q â†’\n          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by\n    intro e p q e' p' q' hp hq hp' hq' he'\n    let r := max (n e) (n e')\n    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=\n      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'\n    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by\n      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1\n      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1\n      exact norm_sub_le_of_mem_A hc P P I1 I2\n    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by\n      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2\n      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=\n        (hn e' p' r hp' (le_max_right _ _)).2.2\n      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)\n    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by\n      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=\n        (hn e' p' r hp' (le_max_right _ _)).2.1\n      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1\n      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)\n    calc\n      â€–L e p q - L e' p' q'â€– =\n          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– := by\n        congr 1; abel\n      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=\n        norm_addâ‚ƒ_le\n      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr\n      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring\n  /- For definiteness, use `L0 e = L e (n e) (n e)`, to have a single sequence. We claim that this\n    is a Cauchy sequence. -/\n  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)\n  have : CauchySeq L0 := by\n    rw [Metric.cauchySeq_iff']\n    intro Îµ Îµpos\n    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=\n      exists_pow_lt_of_lt_one (by positivity) (by norm_num)\n    refine âŸ¨e, fun e' he' => ?_âŸ©\n    rw [dist_comm, dist_eq_norm]\n    calc\n      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'\n      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr\n      _ = Îµ := by field_simp\n  -- As it is Cauchy, the sequence `L0` converges, to a limit `f'` in `K`.\n  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=\n    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this\n  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by\n    intro e p hp\n    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm\n    rw [eventually_atTop]\n    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©\n  -- Let us show that `f` has derivative `f'` at `x`.\n  have : HasFDerivAt f f' x := by\n    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]\n    /- to get an approximation with a precision `Îµ`, we will replace `f` with `L e (n e) m` for\n      some large enough `e` (yielding a small error by uniform approximation). As one can vary `m`,\n      this makes it possible to cover all scales, and thus to obtain a good linear approximation in\n      the whole ball of radius `(1/2)^(n e)`. -/\n    intro Îµ Îµpos\n    have pos : 0 < 4 + 12 * â€–câ€– := by positivity\n    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=\n      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)\n    rw [eventually_nhds_iff_ball]\n    refine âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => ?_âŸ©\n    -- We need to show that `f (x + y) - f x - f' y` is small. For this, we will work at scale\n    -- `k` where `k` is chosen with `â€–yâ€– âˆ¼ 2 ^ (-k)`.\n    by_cases y_pos : y = 0\n    Â· simp [y_pos]\n    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos\n    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy\n    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_oneâ‚€ (by norm_num) (by norm_num))\n    -- define the scale `k`.\n    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=\n      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)\n        (by norm_num : (1 : â„) / 2 < 1)\n    -- the scale is large enough (as `y` is small enough)\n    have k_gt : n e < k := by\n      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt\n      rw [pow_lt_pow_iff_right_of_lt_oneâ‚€ (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this\n      omega\n    set m := k - 1\n    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt\n    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm\n    rw [km] at hk h'k\n    -- `f` is well approximated by `L e (n e) k` at the relevant scale\n    -- (in fact, we use `m = k - 1` instead of `k` because of the precise definition of `A`).\n    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by\n      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2\n      Â· simp only [mem_closedBall, dist_self]\n        positivity\n      Â· simpa only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, pow_succ, mul_one_div] using\n          h'k\n    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=\n      calc\n        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by\n          simpa only [add_sub_cancel_left] using J1\n        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring\n        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– := by gcongr\n    -- use the previous estimates to see that `f (x + y) - f x - f' y` is small.\n    calc\n      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=\n        congr_arg _ (by simp)\n      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=\n        norm_add_le_of_le J2 <| (le_opNorm _ _).trans <| by gcongr; exact Lf' _ _ m_ge\n      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring\n      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr\n      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring\n  rw [â† this.fderiv] at f'K\n  exact âŸ¨this.differentiableAt, f'KâŸ©\n\n"}
{"name":"FDerivMeasurableAux.differentiable_set_eq_D","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nK : Set (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nhK : IsComplete K\nâŠ¢ Eq (setOf fun x => And (DifferentiableAt ğ•œ f x) (Membership.mem K (fderiv ğ•œ f x))) (FDerivMeasurableAux.D f K)","decl":"theorem differentiable_set_eq_D (hK : IsComplete K) :\n    { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } = D f K :=\n  Subset.antisymm (differentiable_set_subset_D _) (D_subset_differentiable_set hK)\n\n"}
{"name":"measurableSet_of_differentiableAt_of_isComplete","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : OpensMeasurableSpace E\nK : Set (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nhK : IsComplete K\nâŠ¢ MeasurableSet (setOf fun x => And (DifferentiableAt ğ•œ f x) (Membership.mem K (fderiv ğ•œ f x)))","decl":"/-- The set of differentiability points of a function, with derivative in a given complete set,\nis Borel-measurable. -/\ntheorem measurableSet_of_differentiableAt_of_isComplete {K : Set (E â†’L[ğ•œ] F)} (hK : IsComplete K) :\n    MeasurableSet { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } := by\n  -- Porting note: was\n  -- simp [differentiable_set_eq_D K hK, D, isOpen_B.measurableSet, MeasurableSet.iInter,\n  --   MeasurableSet.iUnion]\n  simp only [D, differentiable_set_eq_D K hK]\n  repeat apply_rules [MeasurableSet.iUnion, MeasurableSet.iInter] <;> intro\n  exact isOpen_B.measurableSet\n\n"}
{"name":"measurableSet_of_differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : OpensMeasurableSpace E\ninstâœ : CompleteSpace F\nâŠ¢ MeasurableSet (setOf fun x => DifferentiableAt ğ•œ f x)","decl":"/-- The set of differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem measurableSet_of_differentiableAt : MeasurableSet { x | DifferentiableAt ğ•œ f x } := by\n  have : IsComplete (univ : Set (E â†’L[ğ•œ] F)) := complete_univ\n  convert measurableSet_of_differentiableAt_of_isComplete ğ•œ f this\n  simp\n\n"}
{"name":"measurable_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : OpensMeasurableSpace E\ninstâœ : CompleteSpace F\nâŠ¢ Measurable (fderiv ğ•œ f)","decl":"@[measurability, fun_prop]\ntheorem measurable_fderiv : Measurable (fderiv ğ•œ f) := by\n  refine measurable_of_isClosed fun s hs => ?_\n  have :\n    fderiv ğ•œ f â»Â¹' s =\n      { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ s } âˆª\n        { x | Â¬DifferentiableAt ğ•œ f x } âˆ© { _x | (0 : E â†’L[ğ•œ] F) âˆˆ s } :=\n    Set.ext fun x => mem_preimage.trans fderiv_mem_iff\n  rw [this]\n  exact\n    (measurableSet_of_differentiableAt_of_isComplete _ _ hs.isComplete).union\n      ((measurableSet_of_differentiableAt _ _).compl.inter (MeasurableSet.const _))\n\n"}
{"name":"measurable_fderiv_apply_const","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\nf : E â†’ F\ninstâœâ´ : MeasurableSpace E\ninstâœÂ³ : OpensMeasurableSpace E\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\ny : E\nâŠ¢ Measurable fun x => (fderiv ğ•œ f x) y","decl":"@[measurability, fun_prop]\ntheorem measurable_fderiv_apply_const [MeasurableSpace F] [BorelSpace F] (y : E) :\n    Measurable fun x => fderiv ğ•œ f x y :=\n  (ContinuousLinearMap.measurable_apply y).comp (measurable_fderiv ğ•œ f)\n\n"}
{"name":"measurable_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : CompleteSpace F\ninstâœÂ³ : MeasurableSpace ğ•œ\ninstâœÂ² : OpensMeasurableSpace ğ•œ\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nf : ğ•œ â†’ F\nâŠ¢ Measurable (deriv f)","decl":"@[measurability, fun_prop]\ntheorem measurable_deriv [MeasurableSpace ğ•œ] [OpensMeasurableSpace ğ•œ] [MeasurableSpace F]\n    [BorelSpace F] (f : ğ•œ â†’ F) : Measurable (deriv f) := by\n  simpa only [fderiv_deriv] using measurable_fderiv_apply_const ğ•œ f 1\n\n"}
{"name":"stronglyMeasurable_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace ğ•œ\ninstâœ : OpensMeasurableSpace ğ•œ\nh : SecondCountableTopologyEither ğ•œ F\nf : ğ•œ â†’ F\nâŠ¢ MeasureTheory.StronglyMeasurable (deriv f)","decl":"theorem stronglyMeasurable_deriv [MeasurableSpace ğ•œ] [OpensMeasurableSpace ğ•œ]\n    [h : SecondCountableTopologyEither ğ•œ F] (f : ğ•œ â†’ F) : StronglyMeasurable (deriv f) := by\n  borelize F\n  rcases h.out with hğ•œ|hF\n  Â· exact stronglyMeasurable_iff_measurable_separable.2\n      âŸ¨measurable_deriv f, isSeparable_range_deriv _âŸ©\n  Â· exact (measurable_deriv f).stronglyMeasurable\n\n"}
{"name":"aemeasurable_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : CompleteSpace F\ninstâœÂ³ : MeasurableSpace ğ•œ\ninstâœÂ² : OpensMeasurableSpace ğ•œ\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nf : ğ•œ â†’ F\nÎ¼ : MeasureTheory.Measure ğ•œ\nâŠ¢ AEMeasurable (deriv f) Î¼","decl":"theorem aemeasurable_deriv [MeasurableSpace ğ•œ] [OpensMeasurableSpace ğ•œ] [MeasurableSpace F]\n    [BorelSpace F] (f : ğ•œ â†’ F) (Î¼ : Measure ğ•œ) : AEMeasurable (deriv f) Î¼ :=\n  (measurable_deriv f).aemeasurable\n\n"}
{"name":"aestronglyMeasurable_deriv","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\ninstâœÂ² : MeasurableSpace ğ•œ\ninstâœÂ¹ : OpensMeasurableSpace ğ•œ\ninstâœ : SecondCountableTopologyEither ğ•œ F\nf : ğ•œ â†’ F\nÎ¼ : MeasureTheory.Measure ğ•œ\nâŠ¢ MeasureTheory.AEStronglyMeasurable (deriv f) Î¼","decl":"theorem aestronglyMeasurable_deriv [MeasurableSpace ğ•œ] [OpensMeasurableSpace ğ•œ]\n    [SecondCountableTopologyEither ğ•œ F] (f : ğ•œ â†’ F) (Î¼ : Measure ğ•œ) :\n    AEStronglyMeasurable (deriv f) Î¼ :=\n  (stronglyMeasurable_deriv f).aestronglyMeasurable\n\n"}
{"name":"RightDerivMeasurableAux.A_mem_nhdsGT","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nL : F\nr Îµ x : Real\nhx : Membership.mem (RightDerivMeasurableAux.A f L r Îµ) x\nâŠ¢ Membership.mem (nhdsWithin x (Set.Ioi x)) (RightDerivMeasurableAux.A f L r Îµ)","decl":"theorem A_mem_nhdsGT {L : F} {r Îµ x : â„} (hx : x âˆˆ A f L r Îµ) : A f L r Îµ âˆˆ ğ“[>] x := by\n  rcases hx with âŸ¨r', rr', hr'âŸ©\n  obtain âŸ¨s, s_gt, s_ltâŸ© : âˆƒ s : â„, r / 2 < s âˆ§ s < r' := exists_between rr'.1\n  have : s âˆˆ Ioc (r / 2) r := âŸ¨s_gt, le_of_lt (s_lt.trans_le rr'.2)âŸ©\n  filter_upwards [Ioo_mem_nhdsGT <| show x < x + r' - s by linarith] with x' hx'\n  use s, this\n  have A : Icc x' (x' + s) âŠ† Icc x (x + r') := by\n    apply Icc_subset_Icc hx'.1.le\n    linarith [hx'.2]\n  intro y hy z hz\n  exact hr' y (A hy) z (A hz)\n\n"}
{"name":"RightDerivMeasurableAux.B_mem_nhdsGT","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nK : Set F\nr s Îµ x : Real\nhx : Membership.mem (RightDerivMeasurableAux.B f K r s Îµ) x\nâŠ¢ Membership.mem (nhdsWithin x (Set.Ioi x)) (RightDerivMeasurableAux.B f K r s Îµ)","decl":"theorem B_mem_nhdsGT {K : Set F} {r s Îµ x : â„} (hx : x âˆˆ B f K r s Îµ) :\n    B f K r s Îµ âˆˆ ğ“[>] x := by\n  obtain âŸ¨L, LK, hLâ‚, hLâ‚‚âŸ© : âˆƒ L : F, L âˆˆ K âˆ§ x âˆˆ A f L r Îµ âˆ§ x âˆˆ A f L s Îµ := by\n    simpa only [B, mem_iUnion, mem_inter_iff, exists_prop] using hx\n  filter_upwards [A_mem_nhdsGT hLâ‚, A_mem_nhdsGT hLâ‚‚] with y hyâ‚ hyâ‚‚\n  simp only [B, mem_iUnion, mem_inter_iff, exists_prop]\n  exact âŸ¨L, LK, hyâ‚, hyâ‚‚âŸ©\n\n"}
{"name":"RightDerivMeasurableAux.measurableSet_B","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nK : Set F\nr s Îµ : Real\nâŠ¢ MeasurableSet (RightDerivMeasurableAux.B f K r s Îµ)","decl":"theorem measurableSet_B {K : Set F} {r s Îµ : â„} : MeasurableSet (B f K r s Îµ) :=\n  .of_mem_nhdsGT fun _ hx => B_mem_nhdsGT hx\n\n"}
{"name":"RightDerivMeasurableAux.A_mono","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nL : F\nr Îµ Î´ : Real\nh : LE.le Îµ Î´\nâŠ¢ HasSubset.Subset (RightDerivMeasurableAux.A f L r Îµ) (RightDerivMeasurableAux.A f L r Î´)","decl":"theorem A_mono (L : F) (r : â„) {Îµ Î´ : â„} (h : Îµ â‰¤ Î´) : A f L r Îµ âŠ† A f L r Î´ := by\n  rintro x âŸ¨r', r'r, hr'âŸ©\n  refine âŸ¨r', r'r, fun y hy z hz => (hr' y hy z hz).trans (mul_le_mul_of_nonneg_right h ?_)âŸ©\n  linarith [hy.1, hy.2, r'r.2]\n\n"}
{"name":"RightDerivMeasurableAux.le_of_mem_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nr Îµ : Real\nL : F\nx : Real\nhx : Membership.mem (RightDerivMeasurableAux.A f L r Îµ) x\ny z : Real\nhy : Membership.mem (Set.Icc x (HAdd.hAdd x (HDiv.hDiv r 2))) y\nhz : Membership.mem (Set.Icc x (HAdd.hAdd x (HDiv.hDiv r 2))) z\nâŠ¢ LE.le (Norm.norm (HSub.hSub (HSub.hSub (f z) (f y)) (HSMul.hSMul (HSub.hSub z y) L))) (HMul.hMul Îµ r)","decl":"theorem le_of_mem_A {r Îµ : â„} {L : F} {x : â„} (hx : x âˆˆ A f L r Îµ) {y z : â„}\n    (hy : y âˆˆ Icc x (x + r / 2)) (hz : z âˆˆ Icc x (x + r / 2)) :\n  â€–f z - f y - (z - y) â€¢ Lâ€– â‰¤ Îµ * r := by\n  rcases hx with âŸ¨r', r'mem, hr'âŸ©\n  have A : x + r / 2 â‰¤ x + r' := by linarith [r'mem.1]\n  exact hr' _ ((Icc_subset_Icc le_rfl A) hy) _ ((Icc_subset_Icc le_rfl A) hz)\n\n"}
{"name":"RightDerivMeasurableAux.mem_A_of_differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nÎµ : Real\nhÎµ : LT.lt 0 Îµ\nx : Real\nhx : DifferentiableWithinAt Real f (Set.Ici x) x\nâŠ¢ Exists fun R => And (GT.gt R 0) (âˆ€ (r : Real), Membership.mem (Set.Ioo 0 R) r â†’ Membership.mem (RightDerivMeasurableAux.A f (derivWithin f (Set.Ici x) x) r Îµ) x)","decl":"theorem mem_A_of_differentiable {Îµ : â„} (hÎµ : 0 < Îµ) {x : â„}\n    (hx : DifferentiableWithinAt â„ f (Ici x) x) :\n    âˆƒ R > 0, âˆ€ r âˆˆ Ioo (0 : â„) R, x âˆˆ A f (derivWithin f (Ici x) x) r Îµ := by\n  have := hx.hasDerivWithinAt\n  simp_rw [hasDerivWithinAt_iff_isLittleO, isLittleO_iff] at this\n  rcases mem_nhdsGE_iff_exists_Ico_subset.1 (this (half_pos hÎµ)) with âŸ¨m, xm, hmâŸ©\n  refine âŸ¨m - x, by linarith [show x < m from xm], fun r hr => ?_âŸ©\n  have : r âˆˆ Ioc (r / 2) r := âŸ¨half_lt_self hr.1, le_rflâŸ©\n  refine âŸ¨r, this, fun y hy z hz => ?_âŸ©\n  calc\n    â€–f z - f y - (z - y) â€¢ derivWithin f (Ici x) xâ€– =\n        â€–f z - f x - (z - x) â€¢ derivWithin f (Ici x) x -\n            (f y - f x - (y - x) â€¢ derivWithin f (Ici x) x)â€– := by\n      congr 1; simp only [sub_smul]; abel\n    _ â‰¤\n        â€–f z - f x - (z - x) â€¢ derivWithin f (Ici x) xâ€– +\n          â€–f y - f x - (y - x) â€¢ derivWithin f (Ici x) xâ€– :=\n      (norm_sub_le _ _)\n    _ â‰¤ Îµ / 2 * â€–z - xâ€– + Îµ / 2 * â€–y - xâ€– :=\n      (add_le_add (hm âŸ¨hz.1, hz.2.trans_lt (by linarith [hr.2])âŸ©)\n        (hm âŸ¨hy.1, hy.2.trans_lt (by linarith [hr.2])âŸ©))\n    _ â‰¤ Îµ / 2 * r + Îµ / 2 * r := by\n      gcongr\n      Â· rw [Real.norm_of_nonneg] <;> linarith [hz.1, hz.2]\n      Â· rw [Real.norm_of_nonneg] <;> linarith [hy.1, hy.2]\n    _ = Îµ * r := by ring\n\n"}
{"name":"RightDerivMeasurableAux.norm_sub_le_of_mem_A","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nr x : Real\nhr : LT.lt 0 r\nÎµ : Real\nLâ‚ Lâ‚‚ : F\nhâ‚ : Membership.mem (RightDerivMeasurableAux.A f Lâ‚ r Îµ) x\nhâ‚‚ : Membership.mem (RightDerivMeasurableAux.A f Lâ‚‚ r Îµ) x\nâŠ¢ LE.le (Norm.norm (HSub.hSub Lâ‚ Lâ‚‚)) (HMul.hMul 4 Îµ)","decl":"theorem norm_sub_le_of_mem_A {r x : â„} (hr : 0 < r) (Îµ : â„) {Lâ‚ Lâ‚‚ : F} (hâ‚ : x âˆˆ A f Lâ‚ r Îµ)\n    (hâ‚‚ : x âˆˆ A f Lâ‚‚ r Îµ) : â€–Lâ‚ - Lâ‚‚â€– â‰¤ 4 * Îµ := by\n  suffices H : â€–(r / 2) â€¢ (Lâ‚ - Lâ‚‚)â€– â‰¤ r / 2 * (4 * Îµ) by\n    rwa [norm_smul, Real.norm_of_nonneg (half_pos hr).le, mul_le_mul_left (half_pos hr)] at H\n  calc\n    â€–(r / 2) â€¢ (Lâ‚ - Lâ‚‚)â€– =\n        â€–f (x + r / 2) - f x - (x + r / 2 - x) â€¢ Lâ‚‚ -\n            (f (x + r / 2) - f x - (x + r / 2 - x) â€¢ Lâ‚)â€– := by\n      simp [smul_sub]\n    _ â‰¤ â€–f (x + r / 2) - f x - (x + r / 2 - x) â€¢ Lâ‚‚â€– +\n          â€–f (x + r / 2) - f x - (x + r / 2 - x) â€¢ Lâ‚â€– :=\n      norm_sub_le _ _\n    _ â‰¤ Îµ * r + Îµ * r := by\n      apply add_le_add\n      Â· apply le_of_mem_A hâ‚‚ <;> simp [(half_pos hr).le]\n      Â· apply le_of_mem_A hâ‚ <;> simp [(half_pos hr).le]\n    _ = r / 2 * (4 * Îµ) := by ring\n\n"}
{"name":"RightDerivMeasurableAux.differentiable_set_subset_D","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nK : Set F\nâŠ¢ HasSubset.Subset (setOf fun x => And (DifferentiableWithinAt Real f (Set.Ici x) x) (Membership.mem K (derivWithin f (Set.Ici x) x))) (RightDerivMeasurableAux.D f K)","decl":"/-- Easy inclusion: a differentiability point with derivative in `K` belongs to `D f K`. -/\ntheorem differentiable_set_subset_D :\n    { x | DifferentiableWithinAt â„ f (Ici x) x âˆ§ derivWithin f (Ici x) x âˆˆ K } âŠ† D f K := by\n  intro x hx\n  rw [D, mem_iInter]\n  intro e\n  have : (0 : â„) < (1 / 2) ^ e := pow_pos (by norm_num) _\n  rcases mem_A_of_differentiable this hx.1 with âŸ¨R, R_pos, hRâŸ©\n  obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, (1 / 2) ^ n < R :=\n    exists_pow_lt_of_lt_one R_pos (by norm_num : (1 : â„) / 2 < 1)\n  simp only [mem_iUnion, mem_iInter, B, mem_inter_iff]\n  refine âŸ¨n, fun p hp q hq => âŸ¨derivWithin f (Ici x) x, hx.2, âŸ¨?_, ?_âŸ©âŸ©âŸ© <;>\n    Â· refine hR _ âŸ¨pow_pos (by norm_num) _, lt_of_le_of_lt ?_ hnâŸ©\n      exact pow_le_pow_of_le_one (by norm_num) (by norm_num) (by assumption)\n\n"}
{"name":"RightDerivMeasurableAux.D_subset_differentiable_set","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nK : Set F\nhK : IsComplete K\nâŠ¢ HasSubset.Subset (RightDerivMeasurableAux.D f K) (setOf fun x => And (DifferentiableWithinAt Real f (Set.Ici x) x) (Membership.mem K (derivWithin f (Set.Ici x) x)))","decl":"/-- Harder inclusion: at a point in `D f K`, the function `f` has a derivative, in `K`. -/\ntheorem D_subset_differentiable_set {K : Set F} (hK : IsComplete K) :\n    D f K âŠ† { x | DifferentiableWithinAt â„ f (Ici x) x âˆ§ derivWithin f (Ici x) x âˆˆ K } := by\n  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n\n  intro x hx\n  have :\n    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’\n      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by\n    intro e\n    have := mem_iInter.1 hx e\n    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©\n    refine âŸ¨n, fun p q hp hq => ?_âŸ©\n    simp only [mem_iInter] at hn\n    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©\n    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©\n  /- Recast the assumptions: for each `e`, there exist `n e` and linear maps `L e p q` in `K`\n    such that, for `p, q â‰¥ n e`, then `f` is well approximated by `L e p q` at scale `2 ^ (-p)` and\n    `2 ^ (-q)`, with an error `2 ^ (-e)`. -/\n  choose! n L hn using this\n  /- All the operators `L e p q` that show up are close to each other. To prove this, we argue\n      that `L e p q` is close to `L e p r` (where `r` is large enough), as both approximate `f` at\n      scale `2 ^(- p)`. And `L e p r` is close to `L e' p' r` as both approximate `f` at scale\n      `2 ^ (- r)`. And `L e' p' r` is close to `L e' p' q'` as both approximate `f` at scale\n      `2 ^ (- p')`. -/\n  have M :\n    âˆ€ e p q e' p' q',\n      n e â‰¤ p â†’\n        n e â‰¤ q â†’ n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * (1 / 2) ^ e := by\n    intro e p q e' p' q' hp hq hp' hq' he'\n    let r := max (n e) (n e')\n    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=\n      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'\n    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * (1 / 2) ^ e := by\n      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1\n      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1\n      exact norm_sub_le_of_mem_A P _ I1 I2\n    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * (1 / 2) ^ e := by\n      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2\n      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=\n        (hn e' p' r hp' (le_max_right _ _)).2.2\n      exact norm_sub_le_of_mem_A P _ I1 (A_mono _ _ I I2)\n    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * (1 / 2) ^ e := by\n      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=\n        (hn e' p' r hp' (le_max_right _ _)).2.1\n      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1\n      exact norm_sub_le_of_mem_A P _ (A_mono _ _ I I1) (A_mono _ _ I I2)\n    calc\n      â€–L e p q - L e' p' q'â€– =\n          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– := by\n        congr 1; abel\n      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=\n        (le_trans (norm_add_le _ _) (add_le_add_right (norm_add_le _ _) _))\n      _ â‰¤ 4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e + 4 * (1 / 2) ^ e := by gcongr\n      _ = 12 * (1 / 2) ^ e := by ring\n\n  /- For definiteness, use `L0 e = L e (n e) (n e)`, to have a single sequence. We claim that this\n    is a Cauchy sequence. -/\n  let L0 : â„• â†’ F := fun e => L e (n e) (n e)\n  have : CauchySeq L0 := by\n    rw [Metric.cauchySeq_iff']\n    intro Îµ Îµpos\n    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / 12 :=\n      exists_pow_lt_of_lt_one (div_pos Îµpos (by norm_num)) (by norm_num)\n    refine âŸ¨e, fun e' he' => ?_âŸ©\n    rw [dist_comm, dist_eq_norm]\n    calc\n      â€–L0 e - L0 e'â€– â‰¤ 12 * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'\n      _ < 12 * (Îµ / 12) := mul_lt_mul' le_rfl he (le_of_lt P) (by norm_num)\n      _ = Îµ := by field_simp [(by norm_num : (12 : â„) â‰  0)]\n\n  -- As it is Cauchy, the sequence `L0` converges, to a limit `f'` in `K`.\n  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=\n    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this\n  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * (1 / 2) ^ e := by\n    intro e p hp\n    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm\n    rw [eventually_atTop]\n    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©\n  -- Let us show that `f` has right derivative `f'` at `x`.\n  have : HasDerivWithinAt f f' (Ici x) x := by\n    simp only [hasDerivWithinAt_iff_isLittleO, isLittleO_iff]\n    /- to get an approximation with a precision `Îµ`, we will replace `f` with `L e (n e) m` for\n      some large enough `e` (yielding a small error by uniform approximation). As one can vary `m`,\n      this makes it possible to cover all scales, and thus to obtain a good linear approximation in\n      the whole interval of length `(1/2)^(n e)`. -/\n    intro Îµ Îµpos\n    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / 16 :=\n      exists_pow_lt_of_lt_one (div_pos Îµpos (by norm_num)) (by norm_num)\n    filter_upwards [Icc_mem_nhdsGE <| show x < x + (1 / 2) ^ (n e + 1) by simp] with y hy\n    -- We need to show that `f y - f x - f' (y - x)` is small. For this, we will work at scale\n    -- `k` where `k` is chosen with `â€–y - xâ€– âˆ¼ 2 ^ (-k)`.\n    rcases eq_or_lt_of_le hy.1 with (rfl | xy)\n    Â· simp only [sub_self, zero_smul, norm_zero, mul_zero, le_rfl]\n    have yzero : 0 < y - x := sub_pos.2 xy\n    have y_le : y - x â‰¤ (1 / 2) ^ (n e + 1) := by linarith [hy.2]\n    have yone : y - x â‰¤ 1 := le_trans y_le (pow_le_oneâ‚€ (by norm_num) (by norm_num))\n    -- define the scale `k`.\n    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < y - x âˆ§ y - x â‰¤ (1 / 2) ^ k :=\n      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)\n        (by norm_num : (1 : â„) / 2 < 1)\n    -- the scale is large enough (as `y - x` is small enough)\n    have k_gt : n e < k := by\n      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_of_lt_of_le hk y_le\n      rw [pow_lt_pow_iff_right_of_lt_oneâ‚€ (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this\n      omega\n    set m := k - 1\n    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt\n    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm\n    rw [km] at hk h'k\n    -- `f` is well approximated by `L e (n e) k` at the relevant scale\n    -- (in fact, we use `m = k - 1` instead of `k` because of the precise definition of `A`).\n    have J : â€–f y - f x - (y - x) â€¢ L e (n e) mâ€– â‰¤ 4 * (1 / 2) ^ e * â€–y - xâ€– :=\n      calc\n        â€–f y - f x - (y - x) â€¢ L e (n e) mâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by\n          apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2\n          Â· simp only [one_div, inv_pow, left_mem_Icc, le_add_iff_nonneg_right]\n            positivity\n          Â· simp only [pow_add, tsub_le_iff_left] at h'k\n            simpa only [hy.1, mem_Icc, true_and, one_div, pow_one] using h'k\n        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring\n        _ â‰¤ 4 * (1 / 2) ^ e * (y - x) := by gcongr\n        _ = 4 * (1 / 2) ^ e * â€–y - xâ€– := by rw [Real.norm_of_nonneg yzero.le]\n    calc\n      â€–f y - f x - (y - x) â€¢ f'â€– =\n          â€–f y - f x - (y - x) â€¢ L e (n e) m + (y - x) â€¢ (L e (n e) m - f')â€– := by\n        simp only [smul_sub, sub_add_sub_cancel]\n      _ â‰¤ 4 * (1 / 2) ^ e * â€–y - xâ€– + â€–y - xâ€– * (12 * (1 / 2) ^ e) :=\n        norm_add_le_of_le J <| by rw [norm_smul]; gcongr; exact Lf' _ _ m_ge\n      _ = 16 * â€–y - xâ€– * (1 / 2) ^ e := by ring\n      _ â‰¤ 16 * â€–y - xâ€– * (Îµ / 16) := by gcongr\n      _ = Îµ * â€–y - xâ€– := by ring\n\n  rw [â† this.derivWithin (uniqueDiffOn_Ici x x Set.left_mem_Ici)] at f'K\n  exact âŸ¨this.differentiableWithinAt, f'KâŸ©\n\n"}
{"name":"RightDerivMeasurableAux.differentiable_set_eq_D","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nK : Set F\nhK : IsComplete K\nâŠ¢ Eq (setOf fun x => And (DifferentiableWithinAt Real f (Set.Ici x) x) (Membership.mem K (derivWithin f (Set.Ici x) x))) (RightDerivMeasurableAux.D f K)","decl":"theorem differentiable_set_eq_D (hK : IsComplete K) :\n    { x | DifferentiableWithinAt â„ f (Ici x) x âˆ§ derivWithin f (Ici x) x âˆˆ K } = D f K :=\n  Subset.antisymm (differentiable_set_subset_D _) (D_subset_differentiable_set hK)\n\n"}
{"name":"measurableSet_of_differentiableWithinAt_Ici_of_isComplete","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nK : Set F\nhK : IsComplete K\nâŠ¢ MeasurableSet (setOf fun x => And (DifferentiableWithinAt Real f (Set.Ici x) x) (Membership.mem K (derivWithin f (Set.Ici x) x)))","decl":"/-- The set of right differentiability points of a function, with derivative in a given complete\nset, is Borel-measurable. -/\ntheorem measurableSet_of_differentiableWithinAt_Ici_of_isComplete {K : Set F} (hK : IsComplete K) :\n    MeasurableSet { x | DifferentiableWithinAt â„ f (Ici x) x âˆ§ derivWithin f (Ici x) x âˆˆ K } := by\n  -- simp [differentiable_set_eq_d K hK, D, measurableSet_b, MeasurableSet.iInter,\n  --   MeasurableSet.iUnion]\n  simp only [differentiable_set_eq_D K hK, D]\n  repeat apply_rules [MeasurableSet.iUnion, MeasurableSet.iInter] <;> intro\n  exact measurableSet_B\n\n"}
{"name":"measurableSet_of_differentiableWithinAt_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nf : Real â†’ F\ninstâœ : CompleteSpace F\nâŠ¢ MeasurableSet (setOf fun x => DifferentiableWithinAt Real f (Set.Ici x) x)","decl":"/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem measurableSet_of_differentiableWithinAt_Ici :\n    MeasurableSet { x | DifferentiableWithinAt â„ f (Ici x) x } := by\n  have : IsComplete (univ : Set F) := complete_univ\n  convert measurableSet_of_differentiableWithinAt_Ici_of_isComplete f this\n  simp\n\n"}
{"name":"measurable_derivWithin_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nf : Real â†’ F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nâŠ¢ Measurable fun x => derivWithin f (Set.Ici x) x","decl":"@[measurability, fun_prop]\ntheorem measurable_derivWithin_Ici [MeasurableSpace F] [BorelSpace F] :\n    Measurable fun x => derivWithin f (Ici x) x := by\n  refine measurable_of_isClosed fun s hs => ?_\n  have :\n    (fun x => derivWithin f (Ici x) x) â»Â¹' s =\n      { x | DifferentiableWithinAt â„ f (Ici x) x âˆ§ derivWithin f (Ici x) x âˆˆ s } âˆª\n        { x | Â¬DifferentiableWithinAt â„ f (Ici x) x } âˆ© { _x | (0 : F) âˆˆ s } :=\n    Set.ext fun x => mem_preimage.trans derivWithin_mem_iff\n  rw [this]\n  exact\n    (measurableSet_of_differentiableWithinAt_Ici_of_isComplete _ hs.isComplete).union\n      ((measurableSet_of_differentiableWithinAt_Ici _).compl.inter (MeasurableSet.const _))\n\n"}
{"name":"stronglyMeasurable_derivWithin_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nf : Real â†’ F\ninstâœ : CompleteSpace F\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => derivWithin f (Set.Ici x) x","decl":"theorem stronglyMeasurable_derivWithin_Ici :\n    StronglyMeasurable (fun x â†¦ derivWithin f (Ici x) x) := by\n  borelize F\n  apply stronglyMeasurable_iff_measurable_separable.2 âŸ¨measurable_derivWithin_Ici f, ?_âŸ©\n  obtain âŸ¨t, t_count, htâŸ© : âˆƒ t : Set â„, t.Countable âˆ§ Dense t := exists_countable_dense â„\n  suffices H : range (fun x â†¦ derivWithin f (Ici x) x) âŠ† closure (Submodule.span â„ (f '' t)) from\n    IsSeparable.mono (t_count.image f).isSeparable.span.closure H\n  rintro - âŸ¨x, rflâŸ©\n  suffices H' : range (fun y â†¦ derivWithin f (Ici x) y) âŠ† closure (Submodule.span â„ (f '' t)) from\n    H' (mem_range_self _)\n  apply range_derivWithin_subset_closure_span_image\n  calc Ici x\n    = closure (Ioi x âˆ© closure t) := by simp [dense_iff_closure_eq.1 ht]\n  _ âŠ† closure (closure (Ioi x âˆ© t)) := by\n      apply closure_mono\n      simpa [inter_comm] using (isOpen_Ioi (a := x)).closure_inter (s := t)\n  _ âŠ† closure (Ici x âˆ© t) := by\n      rw [closure_closure]\n      exact closure_mono (inter_subset_inter_left _ Ioi_subset_Ici_self)\n\n"}
{"name":"aemeasurable_derivWithin_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nf : Real â†’ F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ AEMeasurable (fun x => derivWithin f (Set.Ici x) x) Î¼","decl":"theorem aemeasurable_derivWithin_Ici [MeasurableSpace F] [BorelSpace F] (Î¼ : Measure â„) :\n    AEMeasurable (fun x => derivWithin f (Ici x) x) Î¼ :=\n  (measurable_derivWithin_Ici f).aemeasurable\n\n"}
{"name":"aestronglyMeasurable_derivWithin_Ici","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nf : Real â†’ F\ninstâœ : CompleteSpace F\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun x => derivWithin f (Set.Ici x) x) Î¼","decl":"theorem aestronglyMeasurable_derivWithin_Ici (Î¼ : Measure â„) :\n    AEStronglyMeasurable (fun x => derivWithin f (Ici x) x) Î¼ :=\n  (stronglyMeasurable_derivWithin_Ici f).aestronglyMeasurable\n\n"}
{"name":"measurableSet_of_differentiableWithinAt_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nf : Real â†’ F\ninstâœ : CompleteSpace F\nâŠ¢ MeasurableSet (setOf fun x => DifferentiableWithinAt Real f (Set.Ioi x) x)","decl":"/-- The set of right differentiability points of a function taking values in a complete space is\nBorel-measurable. -/\ntheorem measurableSet_of_differentiableWithinAt_Ioi :\n    MeasurableSet { x | DifferentiableWithinAt â„ f (Ioi x) x } := by\n  simpa [differentiableWithinAt_Ioi_iff_Ici] using measurableSet_of_differentiableWithinAt_Ici f\n\n"}
{"name":"measurable_derivWithin_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nf : Real â†’ F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nâŠ¢ Measurable fun x => derivWithin f (Set.Ioi x) x","decl":"@[measurability, fun_prop]\ntheorem measurable_derivWithin_Ioi [MeasurableSpace F] [BorelSpace F] :\n    Measurable fun x => derivWithin f (Ioi x) x := by\n  simpa [derivWithin_Ioi_eq_Ici] using measurable_derivWithin_Ici f\n\n"}
{"name":"stronglyMeasurable_derivWithin_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nf : Real â†’ F\ninstâœ : CompleteSpace F\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => derivWithin f (Set.Ioi x) x","decl":"theorem stronglyMeasurable_derivWithin_Ioi :\n    StronglyMeasurable (fun x â†¦ derivWithin f (Ioi x) x) := by\n  simpa [derivWithin_Ioi_eq_Ici] using stronglyMeasurable_derivWithin_Ici f\n\n"}
{"name":"aemeasurable_derivWithin_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nf : Real â†’ F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ AEMeasurable (fun x => derivWithin f (Set.Ioi x) x) Î¼","decl":"theorem aemeasurable_derivWithin_Ioi [MeasurableSpace F] [BorelSpace F] (Î¼ : Measure â„) :\n    AEMeasurable (fun x => derivWithin f (Ioi x) x) Î¼ :=\n  (measurable_derivWithin_Ioi f).aemeasurable\n\n"}
{"name":"aestronglyMeasurable_derivWithin_Ioi","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"F : Type u_1\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nf : Real â†’ F\ninstâœ : CompleteSpace F\nÎ¼ : MeasureTheory.Measure Real\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun x => derivWithin f (Set.Ioi x) x) Î¼","decl":"theorem aestronglyMeasurable_derivWithin_Ioi (Î¼ : Measure â„) :\n    AEStronglyMeasurable (fun x => derivWithin f (Ioi x) x) Î¼ :=\n  (stronglyMeasurable_derivWithin_Ioi f).aestronglyMeasurable\n\n"}
{"name":"FDerivMeasurableAux.isOpen_A_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : LocallyCompactSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ E â†’ F\nr s : Real\nhf : Continuous (Function.uncurry f)\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ IsOpen (setOf fun p => Membership.mem (FDerivMeasurableAux.A (f p.1) L r s) p.2)","decl":"lemma isOpen_A_with_param {r s : â„} (hf : Continuous f.uncurry) (L : E â†’L[ğ•œ] F) :\n    IsOpen {p : Î± Ã— E | p.2 âˆˆ A (f p.1) L r s} := by\n  have : ProperSpace E := .of_locallyCompactSpace ğ•œ\n  simp only [A, half_lt_self_iff, not_lt, mem_Ioc, mem_ball, map_sub, mem_setOf_eq]\n  apply isOpen_iff_mem_nhds.2\n  rintro âŸ¨a, xâŸ© âŸ¨r', âŸ¨Irr', Ir'râŸ©, hrâŸ©\n  have ha : Continuous (f a) := hf.uncurry_left a\n  rcases exists_between Irr' with âŸ¨t, hrt, htr'âŸ©\n  rcases exists_between hrt with âŸ¨t', hrt', ht'tâŸ©\n  obtain âŸ¨b, b_lt, hbâŸ© : âˆƒ b, b < s * r âˆ§ âˆ€ y âˆˆ closedBall x t, âˆ€ z âˆˆ closedBall x t,\n      â€–f a z - f a y - (L z - L y)â€– â‰¤ b := by\n    have B : Continuous (fun (p : E Ã— E) â†¦ â€–f a p.2 - f a p.1 - (L p.2 - L p.1)â€–) := by fun_prop\n    have C : (closedBall x t Ã—Ë¢ closedBall x t).Nonempty := by simp; linarith\n    rcases ((isCompact_closedBall x t).prod (isCompact_closedBall x t)).exists_isMaxOn\n      C B.continuousOn with âŸ¨p, pt, hpâŸ©\n    simp only [mem_prod, mem_closedBall] at pt\n    refine âŸ¨â€–f a p.2 - f a p.1 - (L p.2 - L p.1)â€–,\n      hr p.1 (pt.1.trans_lt htr') p.2 (pt.2.trans_lt htr'), fun y hy z hz â†¦ ?_âŸ©\n    have D : (y, z) âˆˆ closedBall x t Ã—Ë¢ closedBall x t := mem_prod.2 âŸ¨hy, hzâŸ©\n    exact hp D\n  obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ Îµ, 0 < Îµ âˆ§ b + 2 * Îµ < s * r :=\n    âŸ¨(s * r - b) / 3, by linarith, by linarithâŸ©\n  obtain âŸ¨u, u_open, au, huâŸ© : âˆƒ u, IsOpen u âˆ§ a âˆˆ u âˆ§ âˆ€ (p : Î± Ã— E),\n      p.1 âˆˆ u â†’ p.2 âˆˆ closedBall x t â†’ dist (f.uncurry p) (f.uncurry (a, p.2)) < Îµ := by\n    have C : Continuous (fun (p : Î± Ã— E) â†¦ f a p.2) := by fun_prop\n    have D : ({a} Ã—Ë¢ closedBall x t).EqOn f.uncurry (fun p â†¦ f a p.2) := by\n      rintro âŸ¨b, yâŸ© âŸ¨hb, -âŸ©\n      simp only [mem_singleton_iff] at hb\n      simp [hb]\n    obtain âŸ¨v, v_open, sub_v, hvâŸ© : âˆƒ v, IsOpen v âˆ§ {a} Ã—Ë¢ closedBall x t âŠ† v âˆ§\n        âˆ€ p âˆˆ v, dist (Function.uncurry f p) (f a p.2) < Îµ :=\n      Uniform.exists_is_open_mem_uniformity_of_forall_mem_eq (s := {a} Ã—Ë¢ closedBall x t)\n        (fun p _ â†¦ hf.continuousAt) (fun p _ â†¦ C.continuousAt) D (dist_mem_uniformity Îµpos)\n    obtain âŸ¨w, w', w_open, -, sub_w, sub_w', hww'âŸ© : âˆƒ (w : Set Î±) (w' : Set E),\n        IsOpen w âˆ§ IsOpen w' âˆ§ {a} âŠ† w âˆ§ closedBall x t âŠ† w' âˆ§ w Ã—Ë¢ w' âŠ† v :=\n      generalized_tube_lemma isCompact_singleton (isCompact_closedBall x t) v_open sub_v\n    refine âŸ¨w, w_open, sub_w rfl, ?_âŸ©\n    rintro âŸ¨b, yâŸ© h hby\n    exact hv _ (hww' âŸ¨h, sub_w' hbyâŸ©)\n  have : u Ã—Ë¢ ball x (t - t') âˆˆ ğ“ (a, x) :=\n    prod_mem_nhds (u_open.mem_nhds au) (ball_mem_nhds _ (sub_pos.2 ht't))\n  filter_upwards [this]\n  rintro âŸ¨a', x'âŸ© ha'x'\n  simp only [mem_prod, mem_ball] at ha'x'\n  refine âŸ¨t', âŸ¨hrt', ht't.le.trans (htr'.le.trans Ir'r)âŸ©, fun y hy z hz â†¦ ?_âŸ©\n  have dyx : dist y x â‰¤ t := by linarith [dist_triangle y x' x]\n  have dzx : dist z x â‰¤ t := by linarith [dist_triangle z x' x]\n  calc\n  â€–f a' z - f a' y - (L z - L y)â€– =\n    â€–(f a' z - f a z) + (f a y - f a' y) + (f a z - f a y - (L z - L y))â€– := by congr; abel\n  _ â‰¤ â€–f a' z - f a zâ€– + â€–f a y - f a' yâ€– + â€–f a z - f a y - (L z - L y)â€– := norm_addâ‚ƒ_le\n  _ â‰¤ Îµ + Îµ + b := by\n      gcongr\n      Â· rw [â† dist_eq_norm]\n        change dist (f.uncurry (a', z)) (f.uncurry (a, z)) â‰¤ Îµ\n        apply (hu _ _ _).le\n        Â· exact ha'x'.1\n        Â· simp [dzx]\n      Â· rw [â† dist_eq_norm']\n        change dist (f.uncurry (a', y)) (f.uncurry (a, y)) â‰¤ Îµ\n        apply (hu _ _ _).le\n        Â· exact ha'x'.1\n        Â· simp [dyx]\n      Â· simp [hb, dyx, dzx]\n  _ < s * r := by linarith\n\n"}
{"name":"FDerivMeasurableAux.isOpen_B_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : LocallyCompactSpace E\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ E â†’ F\nr s t : Real\nhf : Continuous (Function.uncurry f)\nK : Set (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nâŠ¢ IsOpen (setOf fun p => Membership.mem (FDerivMeasurableAux.B (f p.1) K r s t) p.2)","decl":"lemma isOpen_B_with_param {r s t : â„} (hf : Continuous f.uncurry) (K : Set (E â†’L[ğ•œ] F)) :\n    IsOpen {p : Î± Ã— E | p.2 âˆˆ B (f p.1) K r s t} := by\n  suffices H : IsOpen (â‹ƒ L âˆˆ K,\n      {p : Î± Ã— E | p.2 âˆˆ A (f p.1) L r t âˆ§ p.2 âˆˆ A (f p.1) L s t}) by\n    convert H; ext p; simp [B]\n  refine isOpen_biUnion (fun L _ â†¦ ?_)\n  exact (isOpen_A_with_param hf L).inter (isOpen_A_with_param hf L)\n\n"}
{"name":"measurableSet_of_differentiableAt_of_isComplete_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : LocallyCompactSpace E\nF : Type u_3\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nf : Î± â†’ E â†’ F\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : OpensMeasurableSpace E\nhf : Continuous (Function.uncurry f)\nK : Set (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nhK : IsComplete K\nâŠ¢ MeasurableSet (setOf fun p => And (DifferentiableAt ğ•œ (f p.1) p.2) (Membership.mem K (fderiv ğ•œ (f p.1) p.2)))","decl":"theorem measurableSet_of_differentiableAt_of_isComplete_with_param\n    (hf : Continuous f.uncurry) {K : Set (E â†’L[ğ•œ] F)} (hK : IsComplete K) :\n    MeasurableSet {p : Î± Ã— E | DifferentiableAt ğ•œ (f p.1) p.2 âˆ§ fderiv ğ•œ (f p.1) p.2 âˆˆ K} := by\n  have : {p : Î± Ã— E | DifferentiableAt ğ•œ (f p.1) p.2 âˆ§ fderiv ğ•œ (f p.1) p.2 âˆˆ K}\n          = {p : Î± Ã— E | p.2 âˆˆ D (f p.1) K} := by simp [â† differentiable_set_eq_D K hK]\n  rw [this]\n  simp only [D, mem_iInter, mem_iUnion]\n  simp only [setOf_forall, setOf_exists]\n  refine MeasurableSet.iInter (fun _ â†¦ ?_)\n  refine MeasurableSet.iUnion (fun _ â†¦ ?_)\n  refine MeasurableSet.iInter (fun _ â†¦ ?_)\n  refine MeasurableSet.iInter (fun _ â†¦ ?_)\n  refine MeasurableSet.iInter (fun _ â†¦ ?_)\n  refine MeasurableSet.iInter (fun _ â†¦ ?_)\n  have : ProperSpace E := .of_locallyCompactSpace ğ•œ\n  exact (isOpen_B_with_param hf K).measurableSet\n\n"}
{"name":"measurableSet_of_differentiableAt_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : LocallyCompactSpace E\nF : Type u_3\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœâµ : TopologicalSpace Î±\nf : Î± â†’ E â†’ F\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : OpensMeasurableSpace E\ninstâœ : CompleteSpace F\nhf : Continuous (Function.uncurry f)\nâŠ¢ MeasurableSet (setOf fun p => DifferentiableAt ğ•œ (f p.1) p.2)","decl":"/-- The set of differentiability points of a continuous function depending on a parameter taking\nvalues in a complete space is Borel-measurable. -/\ntheorem measurableSet_of_differentiableAt_with_param (hf : Continuous f.uncurry) :\n    MeasurableSet {p : Î± Ã— E | DifferentiableAt ğ•œ (f p.1) p.2} := by\n  have : IsComplete (univ : Set (E â†’L[ğ•œ] F)) := complete_univ\n  convert measurableSet_of_differentiableAt_of_isComplete_with_param hf this\n  simp\n\n"}
{"name":"measurable_fderiv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : LocallyCompactSpace E\nF : Type u_3\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœâµ : TopologicalSpace Î±\nf : Î± â†’ E â†’ F\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : OpensMeasurableSpace E\ninstâœ : CompleteSpace F\nhf : Continuous (Function.uncurry f)\nâŠ¢ Measurable fun p => fderiv ğ•œ (f p.1) p.2","decl":"theorem measurable_fderiv_with_param (hf : Continuous f.uncurry) :\n    Measurable (fun (p : Î± Ã— E) â†¦ fderiv ğ•œ (f p.1) p.2) := by\n  refine measurable_of_isClosed (fun s hs â†¦ ?_)\n  have :\n    (fun (p : Î± Ã— E) â†¦ fderiv ğ•œ (f p.1) p.2) â»Â¹' s =\n      {p | DifferentiableAt ğ•œ (f p.1) p.2 âˆ§ fderiv ğ•œ (f p.1) p.2 âˆˆ s } âˆª\n        { p | Â¬DifferentiableAt ğ•œ (f p.1) p.2} âˆ© { _p | (0 : E â†’L[ğ•œ] F) âˆˆ s} :=\n    Set.ext (fun x â†¦ mem_preimage.trans fderiv_mem_iff)\n  rw [this]\n  exact\n    (measurableSet_of_differentiableAt_of_isComplete_with_param hf hs.isComplete).union\n      ((measurableSet_of_differentiableAt_with_param _ hf).compl.inter (MeasurableSet.const _))\n\n"}
{"name":"measurable_fderiv_apply_const_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedSpace ğ•œ E\ninstâœÂ¹â° : LocallyCompactSpace E\nF : Type u_3\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœâ· : TopologicalSpace Î±\nf : Î± â†’ E â†’ F\ninstâœâ¶ : MeasurableSpace Î±\ninstâœâµ : OpensMeasurableSpace Î±\ninstâœâ´ : MeasurableSpace E\ninstâœÂ³ : OpensMeasurableSpace E\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nhf : Continuous (Function.uncurry f)\ny : E\nâŠ¢ Measurable fun p => (fderiv ğ•œ (f p.1) p.2) y","decl":"theorem measurable_fderiv_apply_const_with_param [MeasurableSpace F] [BorelSpace F]\n    (hf : Continuous f.uncurry) (y : E) :\n    Measurable (fun (p : Î± Ã— E) â†¦ fderiv ğ•œ (f p.1) p.2 y) :=\n  (ContinuousLinearMap.measurable_apply y).comp (measurable_fderiv_with_param ğ•œ hf)\n\n"}
{"name":"measurable_deriv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœÂ¹â° : NormedAddCommGroup F\ninstâœâ¹ : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœâ¸ : TopologicalSpace Î±\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : OpensMeasurableSpace Î±\ninstâœâµ : CompleteSpace F\ninstâœâ´ : LocallyCompactSpace ğ•œ\ninstâœÂ³ : MeasurableSpace ğ•œ\ninstâœÂ² : OpensMeasurableSpace ğ•œ\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nf : Î± â†’ ğ•œ â†’ F\nhf : Continuous (Function.uncurry f)\nâŠ¢ Measurable fun p => deriv (f p.1) p.2","decl":"theorem measurable_deriv_with_param [LocallyCompactSpace ğ•œ] [MeasurableSpace ğ•œ]\n    [OpensMeasurableSpace ğ•œ] [MeasurableSpace F]\n    [BorelSpace F] {f : Î± â†’ ğ•œ â†’ F} (hf : Continuous f.uncurry) :\n    Measurable (fun (p : Î± Ã— ğ•œ) â†¦ deriv (f p.1) p.2) := by\n  simpa only [fderiv_deriv] using measurable_fderiv_apply_const_with_param ğ•œ hf 1\n\n"}
{"name":"stronglyMeasurable_deriv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœâ¹ : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : OpensMeasurableSpace Î±\ninstâœÂ³ : CompleteSpace F\ninstâœÂ² : LocallyCompactSpace ğ•œ\ninstâœÂ¹ : MeasurableSpace ğ•œ\ninstâœ : OpensMeasurableSpace ğ•œ\nh : SecondCountableTopologyEither Î± F\nf : Î± â†’ ğ•œ â†’ F\nhf : Continuous (Function.uncurry f)\nâŠ¢ MeasureTheory.StronglyMeasurable fun p => deriv (f p.1) p.2","decl":"theorem stronglyMeasurable_deriv_with_param [LocallyCompactSpace ğ•œ] [MeasurableSpace ğ•œ]\n    [OpensMeasurableSpace ğ•œ] [h : SecondCountableTopologyEither Î± F]\n    {f : Î± â†’ ğ•œ â†’ F} (hf : Continuous f.uncurry) :\n    StronglyMeasurable (fun (p : Î± Ã— ğ•œ) â†¦ deriv (f p.1) p.2) := by\n  borelize F\n  rcases h.out with hÎ±|hF\n  Â· have : ProperSpace ğ•œ := .of_locallyCompactSpace ğ•œ\n    apply stronglyMeasurable_iff_measurable_separable.2 âŸ¨measurable_deriv_with_param hf, ?_âŸ©\n    have : range (fun (p : Î± Ã— ğ•œ) â†¦ deriv (f p.1) p.2)\n        âŠ† closure (Submodule.span ğ•œ (range f.uncurry)) := by\n      rintro - âŸ¨p, rflâŸ©\n      have A : deriv (f p.1) p.2 âˆˆ closure (Submodule.span ğ•œ (range (f p.1))) := by\n        rw [â† image_univ]\n        apply range_deriv_subset_closure_span_image _ dense_univ (mem_range_self _)\n      have B : range (f p.1) âŠ† range (f.uncurry) := by\n        rintro - âŸ¨x, rflâŸ©\n        exact mem_range_self (p.1, x)\n      exact closure_mono (Submodule.span_mono B) A\n    exact (isSeparable_range hf).span.closure.mono this\n  Â· exact (measurable_deriv_with_param hf).stronglyMeasurable\n\n"}
{"name":"aemeasurable_deriv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœÂ¹â° : NormedAddCommGroup F\ninstâœâ¹ : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœâ¸ : TopologicalSpace Î±\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : OpensMeasurableSpace Î±\ninstâœâµ : CompleteSpace F\ninstâœâ´ : LocallyCompactSpace ğ•œ\ninstâœÂ³ : MeasurableSpace ğ•œ\ninstâœÂ² : OpensMeasurableSpace ğ•œ\ninstâœÂ¹ : MeasurableSpace F\ninstâœ : BorelSpace F\nf : Î± â†’ ğ•œ â†’ F\nhf : Continuous (Function.uncurry f)\nÎ¼ : MeasureTheory.Measure (Prod Î± ğ•œ)\nâŠ¢ AEMeasurable (fun p => deriv (f p.1) p.2) Î¼","decl":"theorem aemeasurable_deriv_with_param [LocallyCompactSpace ğ•œ] [MeasurableSpace ğ•œ]\n    [OpensMeasurableSpace ğ•œ] [MeasurableSpace F]\n    [BorelSpace F] {f : Î± â†’ ğ•œ â†’ F} (hf : Continuous f.uncurry) (Î¼ : Measure (Î± Ã— ğ•œ)) :\n    AEMeasurable (fun (p : Î± Ã— ğ•œ) â†¦ deriv (f p.1) p.2) Î¼ :=\n  (measurable_deriv_with_param hf).aemeasurable\n\n"}
{"name":"aestronglyMeasurable_deriv_with_param","module":"Mathlib.Analysis.Calculus.FDeriv.Measurable","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nF : Type u_3\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\nÎ± : Type u_4\ninstâœâ· : TopologicalSpace Î±\ninstâœâ¶ : MeasurableSpace Î±\ninstâœâµ : OpensMeasurableSpace Î±\ninstâœâ´ : CompleteSpace F\ninstâœÂ³ : LocallyCompactSpace ğ•œ\ninstâœÂ² : MeasurableSpace ğ•œ\ninstâœÂ¹ : OpensMeasurableSpace ğ•œ\ninstâœ : SecondCountableTopologyEither Î± F\nf : Î± â†’ ğ•œ â†’ F\nhf : Continuous (Function.uncurry f)\nÎ¼ : MeasureTheory.Measure (Prod Î± ğ•œ)\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun p => deriv (f p.1) p.2) Î¼","decl":"theorem aestronglyMeasurable_deriv_with_param [LocallyCompactSpace ğ•œ] [MeasurableSpace ğ•œ]\n    [OpensMeasurableSpace ğ•œ] [SecondCountableTopologyEither Î± F]\n    {f : Î± â†’ ğ•œ â†’ F} (hf : Continuous f.uncurry) (Î¼ : Measure (Î± Ã— ğ•œ)) :\n    AEStronglyMeasurable (fun (p : Î± Ã— ğ•œ) â†¦ deriv (f p.1) p.2) Î¼ :=\n  (stronglyMeasurable_deriv_with_param hf).aestronglyMeasurable\n\n"}
