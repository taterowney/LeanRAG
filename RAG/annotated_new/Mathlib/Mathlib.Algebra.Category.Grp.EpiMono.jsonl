{"name":"AddMonoidHom.ker_eq_bot_of_cancel","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A : Type u\nB : Type v\ninst✝¹ : AddGroup A\ninst✝ : AddGroup B\nf : AddMonoidHom A B\nh : ∀ (u v : AddMonoidHom (Subtype fun x => Membership.mem f.ker x) A), Eq (f.comp u) (f.comp v) → Eq u v\n⊢ Eq f.ker Bot.bot","decl":"@[to_additive]\ntheorem ker_eq_bot_of_cancel {f : A →* B} (h : ∀ u v : f.ker →* A, f.comp u = f.comp v → u = v) :\n    f.ker = ⊥ := by simpa using congr_arg range (h f.ker.subtype 1 (by aesop_cat))\n\n"}
{"name":"MonoidHom.ker_eq_bot_of_cancel","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A : Type u\nB : Type v\ninst✝¹ : Group A\ninst✝ : Group B\nf : MonoidHom A B\nh : ∀ (u v : MonoidHom (Subtype fun x => Membership.mem f.ker x) A), Eq (f.comp u) (f.comp v) → Eq u v\n⊢ Eq f.ker Bot.bot","decl":"@[to_additive]\ntheorem ker_eq_bot_of_cancel {f : A →* B} (h : ∀ u v : f.ker →* A, f.comp u = f.comp v → u = v) :\n    f.ker = ⊥ := by simpa using congr_arg range (h f.ker.subtype 1 (by aesop_cat))\n\n"}
{"name":"AddMonoidHom.range_eq_top_of_cancel","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A : Type u\nB : Type v\ninst✝¹ : AddCommGroup A\ninst✝ : AddCommGroup B\nf : AddMonoidHom A B\nh : ∀ (u v : AddMonoidHom B (HasQuotient.Quotient B f.range)), Eq (u.comp f) (v.comp f) → Eq u v\n⊢ Eq f.range Top.top","decl":"@[to_additive]\ntheorem range_eq_top_of_cancel {f : A →* B}\n    (h : ∀ u v : B →* B ⧸ f.range, u.comp f = v.comp f → u = v) : f.range = ⊤ := by\n  specialize h 1 (QuotientGroup.mk' _) _\n  · ext1 x\n    simp only [one_apply, coe_comp, coe_mk', Function.comp_apply]\n    rw [show (1 : B ⧸ f.range) = (1 : B) from QuotientGroup.mk_one _, QuotientGroup.eq, inv_one,\n      one_mul]\n    exact ⟨x, rfl⟩\n  replace h : (QuotientGroup.mk' f.range).ker = (1 : B →* B ⧸ f.range).ker := by rw [h]\n  rwa [ker_one, QuotientGroup.ker_mk'] at h\n\n"}
{"name":"MonoidHom.range_eq_top_of_cancel","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A : Type u\nB : Type v\ninst✝¹ : CommGroup A\ninst✝ : CommGroup B\nf : MonoidHom A B\nh : ∀ (u v : MonoidHom B (HasQuotient.Quotient B f.range)), Eq (u.comp f) (v.comp f) → Eq u v\n⊢ Eq f.range Top.top","decl":"@[to_additive]\ntheorem range_eq_top_of_cancel {f : A →* B}\n    (h : ∀ u v : B →* B ⧸ f.range, u.comp f = v.comp f → u = v) : f.range = ⊤ := by\n  specialize h 1 (QuotientGroup.mk' _) _\n  · ext1 x\n    simp only [one_apply, coe_comp, coe_mk', Function.comp_apply]\n    rw [show (1 : B ⧸ f.range) = (1 : B) from QuotientGroup.mk_one _, QuotientGroup.eq, inv_one,\n      one_mul]\n    exact ⟨x, rfl⟩\n  replace h : (QuotientGroup.mk' f.range).ker = (1 : B →* B ⧸ f.range).ker := by rw [h]\n  rwa [ker_one, QuotientGroup.ker_mk'] at h\n\n"}
{"name":"AddGrp.ker_eq_bot_of_mono","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddGrp\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (AddGrp.Hom.hom f).ker Bot.bot","decl":"@[to_additive]\ntheorem ker_eq_bot_of_mono [Mono f] : f.hom.ker = ⊥ :=\n  MonoidHom.ker_eq_bot_of_cancel fun u v h => ConcreteCategory.ext_iff.mp <|\n    (@cancel_mono _ _ _ _ _ f _ (ofHom u) (ofHom v)).1 <| ConcreteCategory.ext h\n\n"}
{"name":"Grp.ker_eq_bot_of_mono","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (Grp.Hom.hom f).ker Bot.bot","decl":"@[to_additive]\ntheorem ker_eq_bot_of_mono [Mono f] : f.hom.ker = ⊥ :=\n  MonoidHom.ker_eq_bot_of_cancel fun u v h => ConcreteCategory.ext_iff.mp <|\n    (@cancel_mono _ _ _ _ _ f _ (ofHom u) (ofHom v)).1 <| ConcreteCategory.ext h\n\n"}
{"name":"Grp.mono_iff_ker_eq_bot","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Mono f) (Eq (Grp.Hom.hom f).ker Bot.bot)","decl":"@[to_additive]\ntheorem mono_iff_ker_eq_bot : Mono f ↔ f.hom.ker = ⊥ :=\n  ⟨fun _ => ker_eq_bot_of_mono f, fun h =>\n    ConcreteCategory.mono_of_injective _ <| (MonoidHom.ker_eq_bot_iff f.hom).1 h⟩\n\n"}
{"name":"AddGrp.mono_iff_ker_eq_bot","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Mono f) (Eq (AddGrp.Hom.hom f).ker Bot.bot)","decl":"@[to_additive]\ntheorem mono_iff_ker_eq_bot : Mono f ↔ f.hom.ker = ⊥ :=\n  ⟨fun _ => ker_eq_bot_of_mono f, fun h =>\n    ConcreteCategory.mono_of_injective _ <| (MonoidHom.ker_eq_bot_iff f.hom).1 h⟩\n\n"}
{"name":"Grp.mono_iff_injective","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Mono f) (Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive]\ntheorem mono_iff_injective : Mono f ↔ Function.Injective f :=\n  Iff.trans (mono_iff_ker_eq_bot f) <| MonoidHom.ker_eq_bot_iff f.hom\n\n"}
{"name":"AddGrp.mono_iff_injective","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Mono f) (Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive]\ntheorem mono_iff_injective : Mono f ↔ Function.Injective f :=\n  Iff.trans (mono_iff_ker_eq_bot f) <| MonoidHom.ker_eq_bot_iff f.hom\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.injEq","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\na✝¹ a✝ : ↑(Set.range fun x => HSMul.hSMul x ↑(Grp.Hom.hom f).range)\n⊢ Eq (Eq (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset a✝¹) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset a✝)) (Eq a✝¹ a✝)","decl":"/-- Define `X'` to be the set of all left cosets with an extra point at \"infinity\".\n-/\ninductive XWithInfinity\n  | fromCoset : X → XWithInfinity\n  | infinity : XWithInfinity\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.sizeOf_spec","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\na✝ : ↑(Set.range fun x => HSMul.hSMul x ↑(Grp.Hom.hom f).range)\n⊢ Eq (SizeOf.sizeOf (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Define `X'` to be the set of all left cosets with an extra point at \"infinity\".\n-/\ninductive XWithInfinity\n  | fromCoset : X → XWithInfinity\n  | infinity : XWithInfinity\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity.sizeOf_spec","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Eq (SizeOf.sizeOf Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity) 1","decl":"/-- Define `X'` to be the set of all left cosets with an extra point at \"infinity\".\n-/\ninductive XWithInfinity\n  | fromCoset : X → XWithInfinity\n  | infinity : XWithInfinity\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset.inj","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\na✝¹ a✝ : ↑(Set.range fun x => HSMul.hSMul x ↑(Grp.Hom.hom f).range)\nx✝ : Eq (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset a✝¹) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- Define `X'` to be the set of all left cosets with an extra point at \"infinity\".\n-/\ninductive XWithInfinity\n  | fromCoset : X → XWithInfinity\n  | infinity : XWithInfinity\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.mul_smul","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nb b' : ↑B\nx : Grp.SurjectiveOfEpiAuxs.XWithInfinity f\n⊢ Eq (HSMul.hSMul (HMul.hMul b b') x) (HSMul.hSMul b (HSMul.hSMul b' x))","decl":"theorem mul_smul (b b' : B) (x : X') : (b * b') • x = b • b' • x :=\n  match x with\n  | fromCoset y => by\n    change fromCoset _ = fromCoset _\n    simp only [leftCoset_assoc]\n  | ∞ => rfl\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.one_smul","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nx : Grp.SurjectiveOfEpiAuxs.XWithInfinity f\n⊢ Eq (HSMul.hSMul 1 x) x","decl":"theorem one_smul (x : X') : (1 : B) • x = x :=\n  match x with\n  | fromCoset y => by\n    change fromCoset _ = fromCoset _\n    simp only [one_leftCoset, Subtype.ext_iff_val]\n  | ∞ => rfl\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.fromCoset_eq_of_mem_range","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nb : ↑B\nhb : Membership.mem (Grp.Hom.hom f).range b\n⊢ Eq (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨HSMul.hSMul b ↑(Grp.Hom.hom f).range, ⋯⟩) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨↑(Grp.Hom.hom f).range, ⋯⟩)","decl":"theorem fromCoset_eq_of_mem_range {b : B} (hb : b ∈ f.hom.range) :\n    fromCoset ⟨b • ↑f.hom.range, b, rfl⟩ = fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩ := by\n  congr\n  nth_rw 2 [show (f.hom.range : Set B) = (1 : B) • f.hom.range from (one_leftCoset _).symm]\n  rw [leftCoset_eq_iff, mul_one]\n  exact Subgroup.inv_mem _ hb\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.fromCoset_ne_of_nin_range","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nb : ↑B\nhb : Not (Membership.mem (Grp.Hom.hom f).range b)\n⊢ Ne (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨HSMul.hSMul b ↑(Grp.Hom.hom f).range, ⋯⟩) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨↑(Grp.Hom.hom f).range, ⋯⟩)","decl":"theorem fromCoset_ne_of_nin_range {b : B} (hb : b ∉ f.hom.range) :\n    fromCoset ⟨b • ↑f.hom.range, b, rfl⟩ ≠ fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩ := by\n  intro r\n  simp only [fromCoset.injEq, Subtype.mk.injEq] at r\n  nth_rw 2 [show (f.hom.range : Set B) = (1 : B) • f.hom.range from (one_leftCoset _).symm] at r\n  rw [leftCoset_eq_iff, mul_one] at r\n  exact hb (inv_inv b ▸ Subgroup.inv_mem _ r)\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.τ_apply_infinity","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Eq ((Grp.SurjectiveOfEpiAuxs.tau f) Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨↑(Grp.Hom.hom f).range, ⋯⟩)","decl":"theorem τ_apply_infinity : τ ∞ = fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩ :=\n  Equiv.swap_apply_right _ _\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.τ_apply_fromCoset","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Eq ((Grp.SurjectiveOfEpiAuxs.tau f) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨↑(Grp.Hom.hom f).range, ⋯⟩)) Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity","decl":"theorem τ_apply_fromCoset : τ (fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩) = ∞ :=\n  Equiv.swap_apply_left _ _\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.τ_apply_fromCoset'","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nx : ↑B\nhx : Membership.mem (Grp.Hom.hom f).range x\n⊢ Eq ((Grp.SurjectiveOfEpiAuxs.tau f) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨HSMul.hSMul x ↑(Grp.Hom.hom f).range, ⋯⟩)) Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity","decl":"theorem τ_apply_fromCoset' (x : B) (hx : x ∈ f.hom.range) :\n    τ (fromCoset ⟨x • ↑f.hom.range, ⟨x, rfl⟩⟩) = ∞ :=\n  (fromCoset_eq_of_mem_range _ hx).symm ▸ τ_apply_fromCoset _\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.τ_symm_apply_fromCoset","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Eq ((Equiv.symm (Grp.SurjectiveOfEpiAuxs.tau f)) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨↑(Grp.Hom.hom f).range, ⋯⟩)) Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity","decl":"theorem τ_symm_apply_fromCoset :\n    Equiv.symm τ (fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩) = ∞ := by\n  rw [tau, Equiv.symm_swap, Equiv.swap_apply_left]\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.τ_symm_apply_infinity","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Eq ((Equiv.symm (Grp.SurjectiveOfEpiAuxs.tau f)) Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨↑(Grp.Hom.hom f).range, ⋯⟩)","decl":"theorem τ_symm_apply_infinity :\n    Equiv.symm τ ∞ = fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩ := by\n  rw [tau, Equiv.symm_swap, Equiv.swap_apply_right]\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.g_apply_fromCoset","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nx : ↑B\ny : ↑(Set.range fun x => HSMul.hSMul x ↑(Grp.Hom.hom f).range)\n⊢ Eq (((Grp.SurjectiveOfEpiAuxs.g f) x) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset y)) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨HSMul.hSMul x ↑y, ⋯⟩)","decl":"theorem g_apply_fromCoset (x : B) (y : X) :\n    g x (fromCoset y) = fromCoset ⟨x • ↑y,\n      by obtain ⟨z, hz⟩ := y.2; exact ⟨x * z, by simp [← hz, smul_smul]⟩⟩ := rfl\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.g_apply_infinity","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nx : ↑B\n⊢ Eq (((Grp.SurjectiveOfEpiAuxs.g f) x) Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity) Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity","decl":"theorem g_apply_infinity (x : B) : (g x) ∞ = ∞ := rfl\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.h_apply_infinity","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nx : ↑B\nhx : Membership.mem (Grp.Hom.hom f).range x\n⊢ Eq (((Grp.SurjectiveOfEpiAuxs.h f) x) Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity) Grp.SurjectiveOfEpiAuxs.XWithInfinity.infinity","decl":"theorem h_apply_infinity (x : B) (hx : x ∈ f.hom.range) : (h x) ∞ = ∞ := by\n  change ((τ).symm.trans (g x)).trans τ _ = _\n  simp only [MonoidHom.coe_mk, Equiv.toFun_as_coe, Equiv.coe_trans, Function.comp_apply]\n  rw [τ_symm_apply_infinity, g_apply_fromCoset]\n  simpa only using τ_apply_fromCoset' f x hx\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.h_apply_fromCoset","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nx : ↑B\n⊢ Eq (((Grp.SurjectiveOfEpiAuxs.h f) x) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨↑(Grp.Hom.hom f).range, ⋯⟩)) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨↑(Grp.Hom.hom f).range, ⋯⟩)","decl":"theorem h_apply_fromCoset (x : B) :\n    (h x) (fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩) =\n      fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩ := by\n    change ((τ).symm.trans (g x)).trans τ _ = _\n    simp [-MonoidHom.coe_range, τ_symm_apply_fromCoset, g_apply_infinity, τ_apply_infinity]\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.h_apply_fromCoset'","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nx b : ↑B\nhb : Membership.mem (Grp.Hom.hom f).range b\n⊢ Eq (((Grp.SurjectiveOfEpiAuxs.h f) x) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨HSMul.hSMul b ↑(Grp.Hom.hom f).range, ⋯⟩)) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨HSMul.hSMul b ↑(Grp.Hom.hom f).range, ⋯⟩)","decl":"theorem h_apply_fromCoset' (x : B) (b : B) (hb : b ∈ f.hom.range) :\n    h x (fromCoset ⟨b • f.hom.range, b, rfl⟩) = fromCoset ⟨b • ↑f.hom.range, b, rfl⟩ :=\n  (fromCoset_eq_of_mem_range _ hb).symm ▸ h_apply_fromCoset f x\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.h_apply_fromCoset_nin_range","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nx : ↑B\nhx : Membership.mem (Grp.Hom.hom f).range x\nb : ↑B\nhb : Not (Membership.mem (Grp.Hom.hom f).range b)\n⊢ Eq (((Grp.SurjectiveOfEpiAuxs.h f) x) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨HSMul.hSMul b ↑(Grp.Hom.hom f).range, ⋯⟩)) (Grp.SurjectiveOfEpiAuxs.XWithInfinity.fromCoset ⟨HSMul.hSMul (HMul.hMul x b) ↑(Grp.Hom.hom f).range, ⋯⟩)","decl":"theorem h_apply_fromCoset_nin_range (x : B) (hx : x ∈ f.hom.range) (b : B) (hb : b ∉ f.hom.range) :\n    h x (fromCoset ⟨b • f.hom.range, b, rfl⟩) = fromCoset ⟨(x * b) • ↑f.hom.range, x * b, rfl⟩ := by\n  change ((τ).symm.trans (g x)).trans τ _ = _\n  simp only [tau, MonoidHom.coe_mk, Equiv.toFun_as_coe, Equiv.coe_trans, Function.comp_apply]\n  rw [Equiv.symm_swap,\n    @Equiv.swap_apply_of_ne_of_ne X' _ (fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩) ∞\n      (fromCoset ⟨b • ↑f.hom.range, b, rfl⟩) (fromCoset_ne_of_nin_range _ hb) (by simp)]\n  simp only [g_apply_fromCoset, leftCoset_assoc]\n  refine Equiv.swap_apply_of_ne_of_ne (fromCoset_ne_of_nin_range _ fun r => hb ?_) (by simp)\n  convert Subgroup.mul_mem _ (Subgroup.inv_mem _ hx) r\n  rw [← mul_assoc, inv_mul_cancel, one_mul]\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.agree","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Eq (↑(Grp.Hom.hom f).range) (setOf fun x => Eq ((Grp.SurjectiveOfEpiAuxs.h f) x) ((Grp.SurjectiveOfEpiAuxs.g f) x))","decl":"theorem agree : f.hom.range = { x | h x = g x } := by\n  refine Set.ext fun b => ⟨?_, fun hb : h b = g b => by_contradiction fun r => ?_⟩\n  · rintro ⟨a, rfl⟩\n    change h (f a) = g (f a)\n    ext ⟨⟨_, ⟨y, rfl⟩⟩⟩\n    · rw [g_apply_fromCoset]\n      by_cases m : y ∈ f.hom.range\n      · rw [h_apply_fromCoset' _ _ _ m, fromCoset_eq_of_mem_range _ m]\n        change fromCoset _ = fromCoset ⟨f a • (y • _), _⟩\n        simp only [← fromCoset_eq_of_mem_range _ (Subgroup.mul_mem _ ⟨a, rfl⟩ m), smul_smul]\n      · rw [h_apply_fromCoset_nin_range f (f a) ⟨_, rfl⟩ _ m]\n        simp only [leftCoset_assoc]\n    · rw [g_apply_infinity, h_apply_infinity f (f a) ⟨_, rfl⟩]\n  · have eq1 : (h b) (fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩) =\n        fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩ := by\n      change ((τ).symm.trans (g b)).trans τ _ = _\n      dsimp [tau]\n      simp [g_apply_infinity f]\n    have eq2 :\n        g b (fromCoset ⟨f.hom.range, 1, one_leftCoset _⟩) = fromCoset ⟨b • ↑f.hom.range, b, rfl⟩ :=\n      rfl\n    exact (fromCoset_ne_of_nin_range _ r).symm (by rw [← eq1, ← eq2, DFunLike.congr_fun hb])\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.comp_eq","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (Grp.ofHom (Grp.SurjectiveOfEpiAuxs.g f))) (CategoryTheory.CategoryStruct.comp f (Grp.ofHom (Grp.SurjectiveOfEpiAuxs.h f)))","decl":"theorem comp_eq : (f ≫ ofHom g) = f ≫ ofHom h := by\n  ext a\n  simp only [hom_comp, hom_ofHom, MonoidHom.coe_comp, Function.comp_apply]\n  have : f a ∈ { b | h b = g b } := by\n    rw [← agree]\n    use a\n  rw [this]\n\n"}
{"name":"Grp.SurjectiveOfEpiAuxs.g_ne_h","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\nx : ↑B\nhx : Not (Membership.mem (Grp.Hom.hom f).range x)\n⊢ Ne (Grp.SurjectiveOfEpiAuxs.g f) (Grp.SurjectiveOfEpiAuxs.h f)","decl":"theorem g_ne_h (x : B) (hx : x ∉ f.hom.range) : g ≠ h := by\n  intro r\n  replace r :=\n    DFunLike.congr_fun (DFunLike.congr_fun r x) (fromCoset ⟨f.hom.range, ⟨1, one_leftCoset _⟩⟩)\n  change _ = ((τ).symm.trans (g x)).trans τ _ at r\n  rw [g_apply_fromCoset] at r\n  simp only [MonoidHom.coe_range, Subtype.coe_mk, Equiv.symm_swap, Equiv.toFun_as_coe,\n    Equiv.coe_trans, Function.comp_apply] at r\n  erw [Equiv.swap_apply_left, g_apply_infinity, Equiv.swap_apply_right] at r\n  exact fromCoset_ne_of_nin_range _ hx r\n\n"}
{"name":"Grp.surjective_of_epi","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Epi f\n⊢ Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom f)","decl":"theorem surjective_of_epi [Epi f] : Function.Surjective f := by\n  by_contra r\n  dsimp [Function.Surjective] at r\n  push_neg at r\n  rcases r with ⟨b, hb⟩\n  exact\n    SurjectiveOfEpiAuxs.g_ne_h f b (fun ⟨c, hc⟩ => hb _ hc)\n      (congr_arg Grp.Hom.hom ((cancel_epi f).1 (SurjectiveOfEpiAuxs.comp_eq f)))\n\n"}
{"name":"Grp.epi_iff_surjective","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom f))","decl":"theorem epi_iff_surjective : Epi f ↔ Function.Surjective f :=\n  ⟨fun _ => surjective_of_epi f, ConcreteCategory.epi_of_surjective f⟩\n\n"}
{"name":"Grp.epi_iff_range_eq_top","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : Grp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Epi f) (Eq (Grp.Hom.hom f).range Top.top)","decl":"theorem epi_iff_range_eq_top : Epi f ↔ f.hom.range = ⊤ :=\n  Iff.trans (epi_iff_surjective _) (Subgroup.eq_top_iff' f.hom.range).symm\n\n"}
{"name":"AddGrp.epi_iff_surjective","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom f))","decl":"theorem epi_iff_surjective : Epi f ↔ Function.Surjective f := by\n  have i1 : Epi f ↔ Epi (groupAddGroupEquivalence.inverse.map f) := by\n    refine ⟨?_, groupAddGroupEquivalence.inverse.epi_of_epi_map⟩\n    intro e'\n    apply groupAddGroupEquivalence.inverse.map_epi\n  rwa [Grp.epi_iff_surjective] at i1\n\n"}
{"name":"AddGrp.epi_iff_range_eq_top","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Epi f) (Eq (AddGrp.Hom.hom f).range Top.top)","decl":"theorem epi_iff_range_eq_top : Epi f ↔ f.hom.range = ⊤ :=\n  Iff.trans (epi_iff_surjective _) (AddSubgroup.eq_top_iff' f.hom.range).symm\n\n"}
{"name":"Grp.forget_grp_preserves_mono","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"⊢ (CategoryTheory.forget Grp).PreservesMonomorphisms","decl":"@[to_additive AddGrp.forget_grp_preserves_mono]\ninstance forget_grp_preserves_mono : (forget Grp).PreservesMonomorphisms where\n  preserves f e := by rwa [mono_iff_injective, ← CategoryTheory.mono_iff_injective] at e\n\n"}
{"name":"AddGrp.forget_grp_preserves_mono","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"⊢ (CategoryTheory.forget AddGrp).PreservesMonomorphisms","decl":"@[to_additive AddGrp.forget_grp_preserves_mono]\ninstance forget_grp_preserves_mono : (forget Grp).PreservesMonomorphisms where\n  preserves f e := by rwa [mono_iff_injective, ← CategoryTheory.mono_iff_injective] at e\n\n"}
{"name":"Grp.forget_grp_preserves_epi","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"⊢ (CategoryTheory.forget Grp).PreservesEpimorphisms","decl":"@[to_additive AddGrp.forget_grp_preserves_epi]\ninstance forget_grp_preserves_epi : (forget Grp).PreservesEpimorphisms where\n  preserves f e := by rwa [epi_iff_surjective, ← CategoryTheory.epi_iff_surjective] at e\n\n"}
{"name":"AddGrp.forget_grp_preserves_epi","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"⊢ (CategoryTheory.forget AddGrp).PreservesEpimorphisms","decl":"@[to_additive AddGrp.forget_grp_preserves_epi]\ninstance forget_grp_preserves_epi : (forget Grp).PreservesEpimorphisms where\n  preserves f e := by rwa [epi_iff_surjective, ← CategoryTheory.epi_iff_surjective] at e\n\n"}
{"name":"CommGrp.ker_eq_bot_of_mono","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : CommGrp\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CommGrp.Hom.hom f).ker Bot.bot","decl":"@[to_additive]\ntheorem ker_eq_bot_of_mono [Mono f] : f.hom.ker = ⊥ :=\n  MonoidHom.ker_eq_bot_of_cancel fun u v h => ConcreteCategory.ext_iff.mp <|\n    (@cancel_mono _ _ _ _ _ f _ (ofHom u) (ofHom v)).1 <| ConcreteCategory.ext h\n\n"}
{"name":"AddCommGrp.ker_eq_bot_of_mono","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddCommGrp\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (AddCommGrp.Hom.hom f).ker Bot.bot","decl":"@[to_additive]\ntheorem ker_eq_bot_of_mono [Mono f] : f.hom.ker = ⊥ :=\n  MonoidHom.ker_eq_bot_of_cancel fun u v h => ConcreteCategory.ext_iff.mp <|\n    (@cancel_mono _ _ _ _ _ f _ (ofHom u) (ofHom v)).1 <| ConcreteCategory.ext h\n\n"}
{"name":"AddCommGrp.mono_iff_ker_eq_bot","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddCommGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Mono f) (Eq (AddCommGrp.Hom.hom f).ker Bot.bot)","decl":"@[to_additive]\ntheorem mono_iff_ker_eq_bot : Mono f ↔ f.hom.ker = ⊥ :=\n  ⟨fun _ => ker_eq_bot_of_mono f, fun h =>\n    ConcreteCategory.mono_of_injective _ <| (MonoidHom.ker_eq_bot_iff f.hom).1 h⟩\n\n"}
{"name":"CommGrp.mono_iff_ker_eq_bot","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : CommGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Mono f) (Eq (CommGrp.Hom.hom f).ker Bot.bot)","decl":"@[to_additive]\ntheorem mono_iff_ker_eq_bot : Mono f ↔ f.hom.ker = ⊥ :=\n  ⟨fun _ => ker_eq_bot_of_mono f, fun h =>\n    ConcreteCategory.mono_of_injective _ <| (MonoidHom.ker_eq_bot_iff f.hom).1 h⟩\n\n"}
{"name":"CommGrp.mono_iff_injective","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : CommGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Mono f) (Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive]\ntheorem mono_iff_injective : Mono f ↔ Function.Injective f :=\n  Iff.trans (mono_iff_ker_eq_bot f) <| MonoidHom.ker_eq_bot_iff f.hom\n\n"}
{"name":"AddCommGrp.mono_iff_injective","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddCommGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Mono f) (Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive]\ntheorem mono_iff_injective : Mono f ↔ Function.Injective f :=\n  Iff.trans (mono_iff_ker_eq_bot f) <| MonoidHom.ker_eq_bot_iff f.hom\n\n"}
{"name":"AddCommGrp.range_eq_top_of_epi","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddCommGrp\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Epi f\n⊢ Eq (AddCommGrp.Hom.hom f).range Top.top","decl":"@[to_additive]\ntheorem range_eq_top_of_epi [Epi f] : f.hom.range = ⊤ :=\n  MonoidHom.range_eq_top_of_cancel fun u v h => ConcreteCategory.ext_iff.mp <|\n    (@cancel_epi _ _ _ _ _ f _ (ofHom u) (ofHom v)).1 (ConcreteCategory.ext h)\n\n"}
{"name":"CommGrp.range_eq_top_of_epi","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : CommGrp\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.Epi f\n⊢ Eq (CommGrp.Hom.hom f).range Top.top","decl":"@[to_additive]\ntheorem range_eq_top_of_epi [Epi f] : f.hom.range = ⊤ :=\n  MonoidHom.range_eq_top_of_cancel fun u v h => ConcreteCategory.ext_iff.mp <|\n    (@cancel_epi _ _ _ _ _ f _ (ofHom u) (ofHom v)).1 (ConcreteCategory.ext h)\n\n"}
{"name":"AddCommGrp.epi_iff_range_eq_top","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddCommGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Epi f) (Eq (AddCommGrp.Hom.hom f).range Top.top)","decl":"@[to_additive]\ntheorem epi_iff_range_eq_top : Epi f ↔ f.hom.range = ⊤ :=\n  ⟨fun _ => range_eq_top_of_epi _, fun hf =>\n    ConcreteCategory.epi_of_surjective _ <| show Function.Surjective f.hom from\n      MonoidHom.range_eq_top.mp hf⟩\n\n"}
{"name":"CommGrp.epi_iff_range_eq_top","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : CommGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Epi f) (Eq (CommGrp.Hom.hom f).range Top.top)","decl":"@[to_additive]\ntheorem epi_iff_range_eq_top : Epi f ↔ f.hom.range = ⊤ :=\n  ⟨fun _ => range_eq_top_of_epi _, fun hf =>\n    ConcreteCategory.epi_of_surjective _ <| show Function.Surjective f.hom from\n      MonoidHom.range_eq_top.mp hf⟩\n\n"}
{"name":"AddCommGrp.epi_iff_surjective","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : AddCommGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive]\ntheorem epi_iff_surjective : Epi f ↔ Function.Surjective f := by\n  rw [epi_iff_range_eq_top, MonoidHom.range_eq_top]\n\n"}
{"name":"CommGrp.epi_iff_surjective","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"A B : CommGrp\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom f))","decl":"@[to_additive]\ntheorem epi_iff_surjective : Epi f ↔ Function.Surjective f := by\n  rw [epi_iff_range_eq_top, MonoidHom.range_eq_top]\n\n"}
{"name":"CommGrp.forget_commGrp_preserves_mono","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"⊢ (CategoryTheory.forget CommGrp).PreservesMonomorphisms","decl":"@[to_additive AddCommGrp.forget_commGrp_preserves_mono]\ninstance forget_commGrp_preserves_mono : (forget CommGrp).PreservesMonomorphisms where\n  preserves f e := by rwa [mono_iff_injective, ← CategoryTheory.mono_iff_injective] at e\n\n"}
{"name":"AddCommGrp.forget_commGrp_preserves_mono","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"⊢ (CategoryTheory.forget AddCommGrp).PreservesMonomorphisms","decl":"@[to_additive AddCommGrp.forget_commGrp_preserves_mono]\ninstance forget_commGrp_preserves_mono : (forget CommGrp).PreservesMonomorphisms where\n  preserves f e := by rwa [mono_iff_injective, ← CategoryTheory.mono_iff_injective] at e\n\n"}
{"name":"AddCommGrp.forget_commGrp_preserves_epi","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"⊢ (CategoryTheory.forget AddCommGrp).PreservesEpimorphisms","decl":"@[to_additive AddCommGrp.forget_commGrp_preserves_epi]\ninstance forget_commGrp_preserves_epi : (forget CommGrp).PreservesEpimorphisms where\n  preserves f e := by rwa [epi_iff_surjective, ← CategoryTheory.epi_iff_surjective] at e\n\n"}
{"name":"CommGrp.forget_commGrp_preserves_epi","module":"Mathlib.Algebra.Category.Grp.EpiMono","initialProofState":"⊢ (CategoryTheory.forget CommGrp).PreservesEpimorphisms","decl":"@[to_additive AddCommGrp.forget_commGrp_preserves_epi]\ninstance forget_commGrp_preserves_epi : (forget CommGrp).PreservesEpimorphisms where\n  preserves f e := by rwa [epi_iff_surjective, ← CategoryTheory.epi_iff_surjective] at e\n\n"}
