{"name":"MeasureTheory.Measure.haar.addIndex_empty","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nV : Set G\n⊢ Eq (MeasureTheory.Measure.haar.addIndex EmptyCollection.emptyCollection V) 0","decl":"@[to_additive addIndex_empty]\ntheorem index_empty {V : Set G} : index ∅ V = 0 := by\n  simp only [index, Nat.sInf_eq_zero]; left; use ∅\n  simp only [Finset.card_empty, empty_subset, mem_setOf_eq, eq_self_iff_true, and_self_iff]\n\n"}
{"name":"MeasureTheory.Measure.haar.index_empty","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nV : Set G\n⊢ Eq (MeasureTheory.Measure.haar.index EmptyCollection.emptyCollection V) 0","decl":"@[to_additive addIndex_empty]\ntheorem index_empty {V : Set G} : index ∅ V = 0 := by\n  simp only [index, Nat.sInf_eq_zero]; left; use ∅\n  simp only [Finset.card_empty, empty_subset, mem_setOf_eq, eq_self_iff_true, and_self_iff]\n\n"}
{"name":"MeasureTheory.Measure.haar.prehaar_empty","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : TopologicalSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\n⊢ Eq (MeasureTheory.Measure.haar.prehaar (↑K₀) U Bot.bot) 0","decl":"@[to_additive]\ntheorem prehaar_empty (K₀ : PositiveCompacts G) {U : Set G} : prehaar (K₀ : Set G) U ⊥ = 0 := by\n  rw [prehaar, Compacts.coe_bot, index_empty, Nat.cast_zero, zero_div]\n\n"}
{"name":"MeasureTheory.Measure.haar.addPrehaar_empty","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : TopologicalSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\n⊢ Eq (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U Bot.bot) 0","decl":"@[to_additive]\ntheorem prehaar_empty (K₀ : PositiveCompacts G) {U : Set G} : prehaar (K₀ : Set G) U ⊥ = 0 := by\n  rw [prehaar, Compacts.coe_bot, index_empty, Nat.cast_zero, zero_div]\n\n"}
{"name":"MeasureTheory.Measure.haar.prehaar_nonneg","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : TopologicalSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nK : TopologicalSpace.Compacts G\n⊢ LE.le 0 (MeasureTheory.Measure.haar.prehaar (↑K₀) U K)","decl":"@[to_additive]\ntheorem prehaar_nonneg (K₀ : PositiveCompacts G) {U : Set G} (K : Compacts G) :\n    0 ≤ prehaar (K₀ : Set G) U K := by apply div_nonneg <;> norm_cast <;> apply zero_le\n\n"}
{"name":"MeasureTheory.Measure.haar.addPrehaar_nonneg","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : TopologicalSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nK : TopologicalSpace.Compacts G\n⊢ LE.le 0 (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K)","decl":"@[to_additive]\ntheorem prehaar_nonneg (K₀ : PositiveCompacts G) {U : Set G} (K : Compacts G) :\n    0 ≤ prehaar (K₀ : Set G) U K := by apply div_nonneg <;> norm_cast <;> apply zero_le\n\n"}
{"name":"MeasureTheory.Measure.haar.mem_addPrehaar_empty","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : TopologicalSpace G\nK₀ : Set G\nf : TopologicalSpace.Compacts G → Real\n⊢ Iff (Membership.mem (MeasureTheory.Measure.haar.addHaarProduct K₀) f) (∀ (K : TopologicalSpace.Compacts G), Membership.mem (Set.Icc 0 ↑(MeasureTheory.Measure.haar.addIndex (↑K) K₀)) (f K))","decl":"@[to_additive (attr := simp)]\ntheorem mem_prehaar_empty {K₀ : Set G} {f : Compacts G → ℝ} :\n    f ∈ haarProduct K₀ ↔ ∀ K : Compacts G, f K ∈ Icc (0 : ℝ) (index (K : Set G) K₀) := by\n  simp only [haarProduct, Set.pi, forall_prop_of_true, mem_univ, mem_setOf_eq]\n\n"}
{"name":"MeasureTheory.Measure.haar.mem_prehaar_empty","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : TopologicalSpace G\nK₀ : Set G\nf : TopologicalSpace.Compacts G → Real\n⊢ Iff (Membership.mem (MeasureTheory.Measure.haar.haarProduct K₀) f) (∀ (K : TopologicalSpace.Compacts G), Membership.mem (Set.Icc 0 ↑(MeasureTheory.Measure.haar.index (↑K) K₀)) (f K))","decl":"@[to_additive (attr := simp)]\ntheorem mem_prehaar_empty {K₀ : Set G} {f : Compacts G → ℝ} :\n    f ∈ haarProduct K₀ ↔ ∀ K : Compacts G, f K ∈ Icc (0 : ℝ) (index (K : Set G) K₀) := by\n  simp only [haarProduct, Set.pi, forall_prop_of_true, mem_univ, mem_setOf_eq]\n\n"}
{"name":"MeasureTheory.Measure.haar.index_defined","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK V : Set G\nhK : IsCompact K\nhV : (interior V).Nonempty\n⊢ Exists fun n => Membership.mem (Set.image Finset.card (setOf fun t => HasSubset.Subset K (Set.iUnion fun g => Set.iUnion fun h => Set.preimage (fun h => HMul.hMul g h) V))) n","decl":"/-- If `K` is compact and `V` has nonempty interior, then the index `(K : V)` is well-defined,\n  there is a finite set `t` satisfying the desired properties. -/\n@[to_additive addIndex_defined\n\"If `K` is compact and `V` has nonempty interior, then the index `(K : V)` is well-defined, there is\na finite set `t` satisfying the desired properties.\"]\ntheorem index_defined {K V : Set G} (hK : IsCompact K) (hV : (interior V).Nonempty) :\n    ∃ n : ℕ, n ∈ Finset.card '' { t : Finset G | K ⊆ ⋃ g ∈ t, (fun h => g * h) ⁻¹' V } := by\n  rcases compact_covered_by_mul_left_translates hK hV with ⟨t, ht⟩; exact ⟨t.card, t, ht, rfl⟩\n\n"}
{"name":"MeasureTheory.Measure.haar.addIndex_defined","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK V : Set G\nhK : IsCompact K\nhV : (interior V).Nonempty\n⊢ Exists fun n => Membership.mem (Set.image Finset.card (setOf fun t => HasSubset.Subset K (Set.iUnion fun g => Set.iUnion fun h => Set.preimage (fun h => HAdd.hAdd g h) V))) n","decl":"/-- If `K` is compact and `V` has nonempty interior, then the index `(K : V)` is well-defined,\n  there is a finite set `t` satisfying the desired properties. -/\n@[to_additive addIndex_defined\n\"If `K` is compact and `V` has nonempty interior, then the index `(K : V)` is well-defined, there is\na finite set `t` satisfying the desired properties.\"]\ntheorem index_defined {K V : Set G} (hK : IsCompact K) (hV : (interior V).Nonempty) :\n    ∃ n : ℕ, n ∈ Finset.card '' { t : Finset G | K ⊆ ⋃ g ∈ t, (fun h => g * h) ⁻¹' V } := by\n  rcases compact_covered_by_mul_left_translates hK hV with ⟨t, ht⟩; exact ⟨t.card, t, ht, rfl⟩\n\n"}
{"name":"MeasureTheory.Measure.haar.index_elim","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK V : Set G\nhK : IsCompact K\nhV : (interior V).Nonempty\n⊢ Exists fun t => And (HasSubset.Subset K (Set.iUnion fun g => Set.iUnion fun h => Set.preimage (fun h => HMul.hMul g h) V)) (Eq t.card (MeasureTheory.Measure.haar.index K V))","decl":"@[to_additive addIndex_elim]\ntheorem index_elim {K V : Set G} (hK : IsCompact K) (hV : (interior V).Nonempty) :\n    ∃ t : Finset G, (K ⊆ ⋃ g ∈ t, (fun h => g * h) ⁻¹' V) ∧ Finset.card t = index K V := by\n  have := Nat.sInf_mem (index_defined hK hV); rwa [mem_image] at this\n\n"}
{"name":"MeasureTheory.Measure.haar.addIndex_elim","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK V : Set G\nhK : IsCompact K\nhV : (interior V).Nonempty\n⊢ Exists fun t => And (HasSubset.Subset K (Set.iUnion fun g => Set.iUnion fun h => Set.preimage (fun h => HAdd.hAdd g h) V)) (Eq t.card (MeasureTheory.Measure.haar.addIndex K V))","decl":"@[to_additive addIndex_elim]\ntheorem index_elim {K V : Set G} (hK : IsCompact K) (hV : (interior V).Nonempty) :\n    ∃ t : Finset G, (K ⊆ ⋃ g ∈ t, (fun h => g * h) ⁻¹' V) ∧ Finset.card t = index K V := by\n  have := Nat.sInf_mem (index_defined hK hV); rwa [mem_image] at this\n\n"}
{"name":"MeasureTheory.Measure.haar.le_index_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK : TopologicalSpace.Compacts G\nV : Set G\nhV : (interior V).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.index (↑K) V) (HMul.hMul (MeasureTheory.Measure.haar.index ↑K ↑K₀) (MeasureTheory.Measure.haar.index (↑K₀) V))","decl":"@[to_additive le_addIndex_mul]\ntheorem le_index_mul (K₀ : PositiveCompacts G) (K : Compacts G) {V : Set G}\n    (hV : (interior V).Nonempty) :\n    index (K : Set G) V ≤ index (K : Set G) K₀ * index (K₀ : Set G) V := by\n  classical\n  obtain ⟨s, h1s, h2s⟩ := index_elim K.isCompact K₀.interior_nonempty\n  obtain ⟨t, h1t, h2t⟩ := index_elim K₀.isCompact hV\n  rw [← h2s, ← h2t, mul_comm]\n  refine le_trans ?_ Finset.card_mul_le\n  apply Nat.sInf_le; refine ⟨_, ?_, rfl⟩; rw [mem_setOf_eq]; refine Subset.trans h1s ?_\n  apply iUnion₂_subset; intro g₁ hg₁; rw [preimage_subset_iff]; intro g₂ hg₂\n  have := h1t hg₂\n  rcases this with ⟨_, ⟨g₃, rfl⟩, A, ⟨hg₃, rfl⟩, h2V⟩; rw [mem_preimage, ← mul_assoc] at h2V\n  exact mem_biUnion (Finset.mul_mem_mul hg₃ hg₁) h2V\n\n"}
{"name":"MeasureTheory.Measure.haar.le_addIndex_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK : TopologicalSpace.Compacts G\nV : Set G\nhV : (interior V).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.addIndex (↑K) V) (HMul.hMul (MeasureTheory.Measure.haar.addIndex ↑K ↑K₀) (MeasureTheory.Measure.haar.addIndex (↑K₀) V))","decl":"@[to_additive le_addIndex_mul]\ntheorem le_index_mul (K₀ : PositiveCompacts G) (K : Compacts G) {V : Set G}\n    (hV : (interior V).Nonempty) :\n    index (K : Set G) V ≤ index (K : Set G) K₀ * index (K₀ : Set G) V := by\n  classical\n  obtain ⟨s, h1s, h2s⟩ := index_elim K.isCompact K₀.interior_nonempty\n  obtain ⟨t, h1t, h2t⟩ := index_elim K₀.isCompact hV\n  rw [← h2s, ← h2t, mul_comm]\n  refine le_trans ?_ Finset.card_mul_le\n  apply Nat.sInf_le; refine ⟨_, ?_, rfl⟩; rw [mem_setOf_eq]; refine Subset.trans h1s ?_\n  apply iUnion₂_subset; intro g₁ hg₁; rw [preimage_subset_iff]; intro g₂ hg₂\n  have := h1t hg₂\n  rcases this with ⟨_, ⟨g₃, rfl⟩, A, ⟨hg₃, rfl⟩, h2V⟩; rw [mem_preimage, ← mul_assoc] at h2V\n  exact mem_biUnion (Finset.mul_mem_mul hg₃ hg₁) h2V\n\n"}
{"name":"MeasureTheory.Measure.haar.addIndex_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK : TopologicalSpace.PositiveCompacts G\nV : Set G\nhV : (interior V).Nonempty\n⊢ LT.lt 0 (MeasureTheory.Measure.haar.addIndex (↑K) V)","decl":"@[to_additive addIndex_pos]\ntheorem index_pos (K : PositiveCompacts G) {V : Set G} (hV : (interior V).Nonempty) :\n    0 < index (K : Set G) V := by\n  classical\n  rw [index, Nat.sInf_def, Nat.find_pos, mem_image]\n  · rintro ⟨t, h1t, h2t⟩; rw [Finset.card_eq_zero] at h2t; subst h2t\n    obtain ⟨g, hg⟩ := K.interior_nonempty\n    show g ∈ (∅ : Set G)\n    convert h1t (interior_subset hg); symm\n    simp only [Finset.not_mem_empty, iUnion_of_empty, iUnion_empty]\n  · exact index_defined K.isCompact hV\n\n"}
{"name":"MeasureTheory.Measure.haar.index_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK : TopologicalSpace.PositiveCompacts G\nV : Set G\nhV : (interior V).Nonempty\n⊢ LT.lt 0 (MeasureTheory.Measure.haar.index (↑K) V)","decl":"@[to_additive addIndex_pos]\ntheorem index_pos (K : PositiveCompacts G) {V : Set G} (hV : (interior V).Nonempty) :\n    0 < index (K : Set G) V := by\n  classical\n  rw [index, Nat.sInf_def, Nat.find_pos, mem_image]\n  · rintro ⟨t, h1t, h2t⟩; rw [Finset.card_eq_zero] at h2t; subst h2t\n    obtain ⟨g, hg⟩ := K.interior_nonempty\n    show g ∈ (∅ : Set G)\n    convert h1t (interior_subset hg); symm\n    simp only [Finset.not_mem_empty, iUnion_of_empty, iUnion_empty]\n  · exact index_defined K.isCompact hV\n\n"}
{"name":"MeasureTheory.Measure.haar.index_mono","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK K' V : Set G\nhK' : IsCompact K'\nh : HasSubset.Subset K K'\nhV : (interior V).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.index K V) (MeasureTheory.Measure.haar.index K' V)","decl":"@[to_additive addIndex_mono]\ntheorem index_mono {K K' V : Set G} (hK' : IsCompact K') (h : K ⊆ K') (hV : (interior V).Nonempty) :\n    index K V ≤ index K' V := by\n  rcases index_elim hK' hV with ⟨s, h1s, h2s⟩\n  apply Nat.sInf_le; rw [mem_image]; exact ⟨s, Subset.trans h h1s, h2s⟩\n\n"}
{"name":"MeasureTheory.Measure.haar.addIndex_mono","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK K' V : Set G\nhK' : IsCompact K'\nh : HasSubset.Subset K K'\nhV : (interior V).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.addIndex K V) (MeasureTheory.Measure.haar.addIndex K' V)","decl":"@[to_additive addIndex_mono]\ntheorem index_mono {K K' V : Set G} (hK' : IsCompact K') (h : K ⊆ K') (hV : (interior V).Nonempty) :\n    index K V ≤ index K' V := by\n  rcases index_elim hK' hV with ⟨s, h1s, h2s⟩\n  apply Nat.sInf_le; rw [mem_image]; exact ⟨s, Subset.trans h h1s, h2s⟩\n\n"}
{"name":"MeasureTheory.Measure.haar.addIndex_union_le","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₁ K₂ : TopologicalSpace.Compacts G\nV : Set G\nhV : (interior V).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.addIndex (Union.union K₁.carrier K₂.carrier) V) (HAdd.hAdd (MeasureTheory.Measure.haar.addIndex K₁.carrier V) (MeasureTheory.Measure.haar.addIndex K₂.carrier V))","decl":"@[to_additive addIndex_union_le]\ntheorem index_union_le (K₁ K₂ : Compacts G) {V : Set G} (hV : (interior V).Nonempty) :\n    index (K₁.1 ∪ K₂.1) V ≤ index K₁.1 V + index K₂.1 V := by\n  classical\n  rcases index_elim K₁.2 hV with ⟨s, h1s, h2s⟩\n  rcases index_elim K₂.2 hV with ⟨t, h1t, h2t⟩\n  rw [← h2s, ← h2t]\n  refine le_trans ?_ (Finset.card_union_le _ _)\n  apply Nat.sInf_le; refine ⟨_, ?_, rfl⟩; rw [mem_setOf_eq]\n  apply union_subset <;> refine Subset.trans (by assumption) ?_ <;>\n    apply biUnion_subset_biUnion_left <;> intro g hg <;> simp only [mem_def] at hg <;>\n    simp only [mem_def, Multiset.mem_union, Finset.union_val, hg, or_true, true_or]\n\n"}
{"name":"MeasureTheory.Measure.haar.index_union_le","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₁ K₂ : TopologicalSpace.Compacts G\nV : Set G\nhV : (interior V).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.index (Union.union K₁.carrier K₂.carrier) V) (HAdd.hAdd (MeasureTheory.Measure.haar.index K₁.carrier V) (MeasureTheory.Measure.haar.index K₂.carrier V))","decl":"@[to_additive addIndex_union_le]\ntheorem index_union_le (K₁ K₂ : Compacts G) {V : Set G} (hV : (interior V).Nonempty) :\n    index (K₁.1 ∪ K₂.1) V ≤ index K₁.1 V + index K₂.1 V := by\n  classical\n  rcases index_elim K₁.2 hV with ⟨s, h1s, h2s⟩\n  rcases index_elim K₂.2 hV with ⟨t, h1t, h2t⟩\n  rw [← h2s, ← h2t]\n  refine le_trans ?_ (Finset.card_union_le _ _)\n  apply Nat.sInf_le; refine ⟨_, ?_, rfl⟩; rw [mem_setOf_eq]\n  apply union_subset <;> refine Subset.trans (by assumption) ?_ <;>\n    apply biUnion_subset_biUnion_left <;> intro g hg <;> simp only [mem_def] at hg <;>\n    simp only [mem_def, Multiset.mem_union, Finset.union_val, hg, or_true, true_or]\n\n"}
{"name":"MeasureTheory.Measure.haar.index_union_eq","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₁ K₂ : TopologicalSpace.Compacts G\nV : Set G\nhV : (interior V).Nonempty\nh : Disjoint (HMul.hMul K₁.carrier (Inv.inv V)) (HMul.hMul K₂.carrier (Inv.inv V))\n⊢ Eq (MeasureTheory.Measure.haar.index (Union.union K₁.carrier K₂.carrier) V) (HAdd.hAdd (MeasureTheory.Measure.haar.index K₁.carrier V) (MeasureTheory.Measure.haar.index K₂.carrier V))","decl":"@[to_additive addIndex_union_eq]\ntheorem index_union_eq (K₁ K₂ : Compacts G) {V : Set G} (hV : (interior V).Nonempty)\n    (h : Disjoint (K₁.1 * V⁻¹) (K₂.1 * V⁻¹)) :\n    index (K₁.1 ∪ K₂.1) V = index K₁.1 V + index K₂.1 V := by\n  classical\n  apply le_antisymm (index_union_le K₁ K₂ hV)\n  rcases index_elim (K₁.2.union K₂.2) hV with ⟨s, h1s, h2s⟩; rw [← h2s]\n  have :\n    ∀ K : Set G,\n      (K ⊆ ⋃ g ∈ s, (fun h => g * h) ⁻¹' V) →\n        index K V ≤ (s.filter fun g => ((fun h : G => g * h) ⁻¹' V ∩ K).Nonempty).card := by\n    intro K hK; apply Nat.sInf_le; refine ⟨_, ?_, rfl⟩; rw [mem_setOf_eq]\n    intro g hg; rcases hK hg with ⟨_, ⟨g₀, rfl⟩, _, ⟨h1g₀, rfl⟩, h2g₀⟩\n    simp only [mem_preimage] at h2g₀\n    simp only [mem_iUnion]; use g₀; constructor; swap\n    · simp only [Finset.mem_filter, h1g₀, true_and]; use g\n      simp only [hg, h2g₀, mem_inter_iff, mem_preimage, and_self_iff]\n    exact h2g₀\n  refine\n    le_trans\n      (add_le_add (this K₁.1 <| Subset.trans subset_union_left h1s)\n        (this K₂.1 <| Subset.trans subset_union_right h1s)) ?_\n  rw [← Finset.card_union_of_disjoint, Finset.filter_union_right]\n  · exact s.card_filter_le _\n  apply Finset.disjoint_filter.mpr\n  rintro g₁ _ ⟨g₂, h1g₂, h2g₂⟩ ⟨g₃, h1g₃, h2g₃⟩\n  simp only [mem_preimage] at h1g₃ h1g₂\n  refine h.le_bot (?_ : g₁⁻¹ ∈ _)\n  constructor <;> simp only [Set.mem_inv, Set.mem_mul, exists_exists_and_eq_and, exists_and_left]\n  · refine ⟨_, h2g₂, (g₁ * g₂)⁻¹, ?_, ?_⟩\n    · simp only [inv_inv, h1g₂]\n    · simp only [mul_inv_rev, mul_inv_cancel_left]\n  · refine ⟨_, h2g₃, (g₁ * g₃)⁻¹, ?_, ?_⟩\n    · simp only [inv_inv, h1g₃]\n    · simp only [mul_inv_rev, mul_inv_cancel_left]\n\n"}
{"name":"MeasureTheory.Measure.haar.addIndex_union_eq","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₁ K₂ : TopologicalSpace.Compacts G\nV : Set G\nhV : (interior V).Nonempty\nh : Disjoint (HAdd.hAdd K₁.carrier (Neg.neg V)) (HAdd.hAdd K₂.carrier (Neg.neg V))\n⊢ Eq (MeasureTheory.Measure.haar.addIndex (Union.union K₁.carrier K₂.carrier) V) (HAdd.hAdd (MeasureTheory.Measure.haar.addIndex K₁.carrier V) (MeasureTheory.Measure.haar.addIndex K₂.carrier V))","decl":"@[to_additive addIndex_union_eq]\ntheorem index_union_eq (K₁ K₂ : Compacts G) {V : Set G} (hV : (interior V).Nonempty)\n    (h : Disjoint (K₁.1 * V⁻¹) (K₂.1 * V⁻¹)) :\n    index (K₁.1 ∪ K₂.1) V = index K₁.1 V + index K₂.1 V := by\n  classical\n  apply le_antisymm (index_union_le K₁ K₂ hV)\n  rcases index_elim (K₁.2.union K₂.2) hV with ⟨s, h1s, h2s⟩; rw [← h2s]\n  have :\n    ∀ K : Set G,\n      (K ⊆ ⋃ g ∈ s, (fun h => g * h) ⁻¹' V) →\n        index K V ≤ (s.filter fun g => ((fun h : G => g * h) ⁻¹' V ∩ K).Nonempty).card := by\n    intro K hK; apply Nat.sInf_le; refine ⟨_, ?_, rfl⟩; rw [mem_setOf_eq]\n    intro g hg; rcases hK hg with ⟨_, ⟨g₀, rfl⟩, _, ⟨h1g₀, rfl⟩, h2g₀⟩\n    simp only [mem_preimage] at h2g₀\n    simp only [mem_iUnion]; use g₀; constructor; swap\n    · simp only [Finset.mem_filter, h1g₀, true_and]; use g\n      simp only [hg, h2g₀, mem_inter_iff, mem_preimage, and_self_iff]\n    exact h2g₀\n  refine\n    le_trans\n      (add_le_add (this K₁.1 <| Subset.trans subset_union_left h1s)\n        (this K₂.1 <| Subset.trans subset_union_right h1s)) ?_\n  rw [← Finset.card_union_of_disjoint, Finset.filter_union_right]\n  · exact s.card_filter_le _\n  apply Finset.disjoint_filter.mpr\n  rintro g₁ _ ⟨g₂, h1g₂, h2g₂⟩ ⟨g₃, h1g₃, h2g₃⟩\n  simp only [mem_preimage] at h1g₃ h1g₂\n  refine h.le_bot (?_ : g₁⁻¹ ∈ _)\n  constructor <;> simp only [Set.mem_inv, Set.mem_mul, exists_exists_and_eq_and, exists_and_left]\n  · refine ⟨_, h2g₂, (g₁ * g₂)⁻¹, ?_, ?_⟩\n    · simp only [inv_inv, h1g₂]\n    · simp only [mul_inv_rev, mul_inv_cancel_left]\n  · refine ⟨_, h2g₃, (g₁ * g₃)⁻¹, ?_, ?_⟩\n    · simp only [inv_inv, h1g₃]\n    · simp only [mul_inv_rev, mul_inv_cancel_left]\n\n"}
{"name":"MeasureTheory.Measure.haar.mul_left_index_le","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK : Set G\nhK : IsCompact K\nV : Set G\nhV : (interior V).Nonempty\ng : G\n⊢ LE.le (MeasureTheory.Measure.haar.index (Set.image (fun h => HMul.hMul g h) K) V) (MeasureTheory.Measure.haar.index K V)","decl":"@[to_additive add_left_addIndex_le]\ntheorem mul_left_index_le {K : Set G} (hK : IsCompact K) {V : Set G} (hV : (interior V).Nonempty)\n    (g : G) : index ((fun h => g * h) '' K) V ≤ index K V := by\n  rcases index_elim hK hV with ⟨s, h1s, h2s⟩; rw [← h2s]\n  apply Nat.sInf_le; rw [mem_image]\n  refine ⟨s.map (Equiv.mulRight g⁻¹).toEmbedding, ?_, Finset.card_map _⟩\n  simp only [mem_setOf_eq]; refine Subset.trans (image_subset _ h1s) ?_\n  rintro _ ⟨g₁, ⟨_, ⟨g₂, rfl⟩, ⟨_, ⟨hg₂, rfl⟩, hg₁⟩⟩, rfl⟩\n  simp only [mem_preimage] at hg₁\n  simp only [exists_prop, mem_iUnion, Finset.mem_map, Equiv.coe_mulRight,\n    exists_exists_and_eq_and, mem_preimage, Equiv.toEmbedding_apply]\n  refine ⟨_, hg₂, ?_⟩; simp only [mul_assoc, hg₁, inv_mul_cancel_left]\n\n"}
{"name":"MeasureTheory.Measure.haar.add_left_addIndex_le","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK : Set G\nhK : IsCompact K\nV : Set G\nhV : (interior V).Nonempty\ng : G\n⊢ LE.le (MeasureTheory.Measure.haar.addIndex (Set.image (fun h => HAdd.hAdd g h) K) V) (MeasureTheory.Measure.haar.addIndex K V)","decl":"@[to_additive add_left_addIndex_le]\ntheorem mul_left_index_le {K : Set G} (hK : IsCompact K) {V : Set G} (hV : (interior V).Nonempty)\n    (g : G) : index ((fun h => g * h) '' K) V ≤ index K V := by\n  rcases index_elim hK hV with ⟨s, h1s, h2s⟩; rw [← h2s]\n  apply Nat.sInf_le; rw [mem_image]\n  refine ⟨s.map (Equiv.mulRight g⁻¹).toEmbedding, ?_, Finset.card_map _⟩\n  simp only [mem_setOf_eq]; refine Subset.trans (image_subset _ h1s) ?_\n  rintro _ ⟨g₁, ⟨_, ⟨g₂, rfl⟩, ⟨_, ⟨hg₂, rfl⟩, hg₁⟩⟩, rfl⟩\n  simp only [mem_preimage] at hg₁\n  simp only [exists_prop, mem_iUnion, Finset.mem_map, Equiv.coe_mulRight,\n    exists_exists_and_eq_and, mem_preimage, Equiv.toEmbedding_apply]\n  refine ⟨_, hg₂, ?_⟩; simp only [mul_assoc, hg₁, inv_mul_cancel_left]\n\n"}
{"name":"MeasureTheory.Measure.haar.is_left_invariant_addIndex","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK : Set G\nhK : IsCompact K\ng : G\nV : Set G\nhV : (interior V).Nonempty\n⊢ Eq (MeasureTheory.Measure.haar.addIndex (Set.image (fun h => HAdd.hAdd g h) K) V) (MeasureTheory.Measure.haar.addIndex K V)","decl":"@[to_additive is_left_invariant_addIndex]\ntheorem is_left_invariant_index {K : Set G} (hK : IsCompact K) (g : G) {V : Set G}\n    (hV : (interior V).Nonempty) : index ((fun h => g * h) '' K) V = index K V := by\n  refine le_antisymm (mul_left_index_le hK hV g) ?_\n  convert mul_left_index_le (hK.image <| continuous_mul_left g) hV g⁻¹\n  rw [image_image]; symm; convert image_id' _ with h; apply inv_mul_cancel_left\n\n"}
{"name":"MeasureTheory.Measure.haar.is_left_invariant_index","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK : Set G\nhK : IsCompact K\ng : G\nV : Set G\nhV : (interior V).Nonempty\n⊢ Eq (MeasureTheory.Measure.haar.index (Set.image (fun h => HMul.hMul g h) K) V) (MeasureTheory.Measure.haar.index K V)","decl":"@[to_additive is_left_invariant_addIndex]\ntheorem is_left_invariant_index {K : Set G} (hK : IsCompact K) (g : G) {V : Set G}\n    (hV : (interior V).Nonempty) : index ((fun h => g * h) '' K) V = index K V := by\n  refine le_antisymm (mul_left_index_le hK hV g) ?_\n  convert mul_left_index_le (hK.image <| continuous_mul_left g) hV g⁻¹\n  rw [image_image]; symm; convert image_id' _ with h; apply inv_mul_cancel_left\n\n"}
{"name":"MeasureTheory.Measure.haar.add_prehaar_le_addIndex","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nK : TopologicalSpace.Compacts G\nhU : (interior U).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K) ↑(MeasureTheory.Measure.haar.addIndex ↑K ↑K₀)","decl":"@[to_additive add_prehaar_le_addIndex]\ntheorem prehaar_le_index (K₀ : PositiveCompacts G) {U : Set G} (K : Compacts G)\n    (hU : (interior U).Nonempty) : prehaar (K₀ : Set G) U K ≤ index (K : Set G) K₀ := by\n  unfold prehaar; rw [div_le_iff₀] <;> norm_cast\n  · apply le_index_mul K₀ K hU\n  · exact index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.prehaar_le_index","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nK : TopologicalSpace.Compacts G\nhU : (interior U).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.prehaar (↑K₀) U K) ↑(MeasureTheory.Measure.haar.index ↑K ↑K₀)","decl":"@[to_additive add_prehaar_le_addIndex]\ntheorem prehaar_le_index (K₀ : PositiveCompacts G) {U : Set G} (K : Compacts G)\n    (hU : (interior U).Nonempty) : prehaar (K₀ : Set G) U K ≤ index (K : Set G) K₀ := by\n  unfold prehaar; rw [div_le_iff₀] <;> norm_cast\n  · apply le_index_mul K₀ K hU\n  · exact index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.prehaar_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\nK : Set G\nh1K : IsCompact K\nh2K : (interior K).Nonempty\n⊢ LT.lt 0 (MeasureTheory.Measure.haar.prehaar (↑K₀) U { carrier := K, isCompact' := h1K })","decl":"@[to_additive]\ntheorem prehaar_pos (K₀ : PositiveCompacts G) {U : Set G} (hU : (interior U).Nonempty) {K : Set G}\n    (h1K : IsCompact K) (h2K : (interior K).Nonempty) : 0 < prehaar (K₀ : Set G) U ⟨K, h1K⟩ := by\n  apply div_pos <;> norm_cast\n  · apply index_pos ⟨⟨K, h1K⟩, h2K⟩ hU\n  · exact index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.addPrehaar_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\nK : Set G\nh1K : IsCompact K\nh2K : (interior K).Nonempty\n⊢ LT.lt 0 (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U { carrier := K, isCompact' := h1K })","decl":"@[to_additive]\ntheorem prehaar_pos (K₀ : PositiveCompacts G) {U : Set G} (hU : (interior U).Nonempty) {K : Set G}\n    (h1K : IsCompact K) (h2K : (interior K).Nonempty) : 0 < prehaar (K₀ : Set G) U ⟨K, h1K⟩ := by\n  apply div_pos <;> norm_cast\n  · apply index_pos ⟨⟨K, h1K⟩, h2K⟩ hU\n  · exact index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.addPrehaar_mono","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\nK₁ K₂ : TopologicalSpace.Compacts G\nh : HasSubset.Subset (↑K₁) K₂.carrier\n⊢ LE.le (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K₁) (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K₂)","decl":"@[to_additive]\ntheorem prehaar_mono {K₀ : PositiveCompacts G} {U : Set G} (hU : (interior U).Nonempty)\n    {K₁ K₂ : Compacts G} (h : (K₁ : Set G) ⊆ K₂.1) :\n    prehaar (K₀ : Set G) U K₁ ≤ prehaar (K₀ : Set G) U K₂ := by\n  simp only [prehaar]; rw [div_le_div_iff_of_pos_right]\n  · exact mod_cast index_mono K₂.2 h hU\n  · exact mod_cast index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.prehaar_mono","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\nK₁ K₂ : TopologicalSpace.Compacts G\nh : HasSubset.Subset (↑K₁) K₂.carrier\n⊢ LE.le (MeasureTheory.Measure.haar.prehaar (↑K₀) U K₁) (MeasureTheory.Measure.haar.prehaar (↑K₀) U K₂)","decl":"@[to_additive]\ntheorem prehaar_mono {K₀ : PositiveCompacts G} {U : Set G} (hU : (interior U).Nonempty)\n    {K₁ K₂ : Compacts G} (h : (K₁ : Set G) ⊆ K₂.1) :\n    prehaar (K₀ : Set G) U K₁ ≤ prehaar (K₀ : Set G) U K₂ := by\n  simp only [prehaar]; rw [div_le_div_iff_of_pos_right]\n  · exact mod_cast index_mono K₂.2 h hU\n  · exact mod_cast index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.addPrehaar_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\n⊢ Eq (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K₀.toCompacts) 1","decl":"@[to_additive]\ntheorem prehaar_self {K₀ : PositiveCompacts G} {U : Set G} (hU : (interior U).Nonempty) :\n    prehaar (K₀ : Set G) U K₀.toCompacts = 1 :=\n  div_self <| ne_of_gt <| mod_cast index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.prehaar_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\n⊢ Eq (MeasureTheory.Measure.haar.prehaar (↑K₀) U K₀.toCompacts) 1","decl":"@[to_additive]\ntheorem prehaar_self {K₀ : PositiveCompacts G} {U : Set G} (hU : (interior U).Nonempty) :\n    prehaar (K₀ : Set G) U K₀.toCompacts = 1 :=\n  div_self <| ne_of_gt <| mod_cast index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.addPrehaar_sup_le","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nK₁ K₂ : TopologicalSpace.Compacts G\nhU : (interior U).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U (Max.max K₁ K₂)) (HAdd.hAdd (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K₁) (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K₂))","decl":"@[to_additive]\ntheorem prehaar_sup_le {K₀ : PositiveCompacts G} {U : Set G} (K₁ K₂ : Compacts G)\n    (hU : (interior U).Nonempty) :\n    prehaar (K₀ : Set G) U (K₁ ⊔ K₂) ≤ prehaar (K₀ : Set G) U K₁ + prehaar (K₀ : Set G) U K₂ := by\n  simp only [prehaar]; rw [div_add_div_same, div_le_div_iff_of_pos_right]\n  · exact mod_cast index_union_le K₁ K₂ hU\n  · exact mod_cast index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.prehaar_sup_le","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nK₁ K₂ : TopologicalSpace.Compacts G\nhU : (interior U).Nonempty\n⊢ LE.le (MeasureTheory.Measure.haar.prehaar (↑K₀) U (Max.max K₁ K₂)) (HAdd.hAdd (MeasureTheory.Measure.haar.prehaar (↑K₀) U K₁) (MeasureTheory.Measure.haar.prehaar (↑K₀) U K₂))","decl":"@[to_additive]\ntheorem prehaar_sup_le {K₀ : PositiveCompacts G} {U : Set G} (K₁ K₂ : Compacts G)\n    (hU : (interior U).Nonempty) :\n    prehaar (K₀ : Set G) U (K₁ ⊔ K₂) ≤ prehaar (K₀ : Set G) U K₁ + prehaar (K₀ : Set G) U K₂ := by\n  simp only [prehaar]; rw [div_add_div_same, div_le_div_iff_of_pos_right]\n  · exact mod_cast index_union_le K₁ K₂ hU\n  · exact mod_cast index_pos K₀ hU\n\n"}
{"name":"MeasureTheory.Measure.haar.addPrehaar_sup_eq","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nK₁ K₂ : TopologicalSpace.Compacts G\nhU : (interior U).Nonempty\nh : Disjoint (HAdd.hAdd K₁.carrier (Neg.neg U)) (HAdd.hAdd K₂.carrier (Neg.neg U))\n⊢ Eq (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U (Max.max K₁ K₂)) (HAdd.hAdd (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K₁) (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K₂))","decl":"@[to_additive]\ntheorem prehaar_sup_eq {K₀ : PositiveCompacts G} {U : Set G} {K₁ K₂ : Compacts G}\n    (hU : (interior U).Nonempty) (h : Disjoint (K₁.1 * U⁻¹) (K₂.1 * U⁻¹)) :\n    prehaar (K₀ : Set G) U (K₁ ⊔ K₂) = prehaar (K₀ : Set G) U K₁ + prehaar (K₀ : Set G) U K₂ := by\n  simp only [prehaar]; rw [div_add_div_same]\n  -- Porting note: Here was `congr`, but `to_additive` failed to generate a theorem.\n  refine congr_arg (fun x : ℝ => x / index K₀ U) ?_\n  exact mod_cast index_union_eq K₁ K₂ hU h\n\n"}
{"name":"MeasureTheory.Measure.haar.prehaar_sup_eq","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nK₁ K₂ : TopologicalSpace.Compacts G\nhU : (interior U).Nonempty\nh : Disjoint (HMul.hMul K₁.carrier (Inv.inv U)) (HMul.hMul K₂.carrier (Inv.inv U))\n⊢ Eq (MeasureTheory.Measure.haar.prehaar (↑K₀) U (Max.max K₁ K₂)) (HAdd.hAdd (MeasureTheory.Measure.haar.prehaar (↑K₀) U K₁) (MeasureTheory.Measure.haar.prehaar (↑K₀) U K₂))","decl":"@[to_additive]\ntheorem prehaar_sup_eq {K₀ : PositiveCompacts G} {U : Set G} {K₁ K₂ : Compacts G}\n    (hU : (interior U).Nonempty) (h : Disjoint (K₁.1 * U⁻¹) (K₂.1 * U⁻¹)) :\n    prehaar (K₀ : Set G) U (K₁ ⊔ K₂) = prehaar (K₀ : Set G) U K₁ + prehaar (K₀ : Set G) U K₂ := by\n  simp only [prehaar]; rw [div_add_div_same]\n  -- Porting note: Here was `congr`, but `to_additive` failed to generate a theorem.\n  refine congr_arg (fun x : ℝ => x / index K₀ U) ?_\n  exact mod_cast index_union_eq K₁ K₂ hU h\n\n"}
{"name":"MeasureTheory.Measure.haar.is_left_invariant_addPrehaar","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\ng : G\nK : TopologicalSpace.Compacts G\n⊢ Eq (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U (TopologicalSpace.Compacts.map (fun b => HAdd.hAdd g b) ⋯ K)) (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U K)","decl":"@[to_additive]\ntheorem is_left_invariant_prehaar {K₀ : PositiveCompacts G} {U : Set G} (hU : (interior U).Nonempty)\n    (g : G) (K : Compacts G) :\n    prehaar (K₀ : Set G) U (K.map _ <| continuous_mul_left g) = prehaar (K₀ : Set G) U K := by\n  simp only [prehaar, Compacts.coe_map, is_left_invariant_index K.isCompact _ hU]\n\n"}
{"name":"MeasureTheory.Measure.haar.is_left_invariant_prehaar","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\ng : G\nK : TopologicalSpace.Compacts G\n⊢ Eq (MeasureTheory.Measure.haar.prehaar (↑K₀) U (TopologicalSpace.Compacts.map (fun b => HMul.hMul g b) ⋯ K)) (MeasureTheory.Measure.haar.prehaar (↑K₀) U K)","decl":"@[to_additive]\ntheorem is_left_invariant_prehaar {K₀ : PositiveCompacts G} {U : Set G} (hU : (interior U).Nonempty)\n    (g : G) (K : Compacts G) :\n    prehaar (K₀ : Set G) U (K.map _ <| continuous_mul_left g) = prehaar (K₀ : Set G) U K := by\n  simp only [prehaar, Compacts.coe_map, is_left_invariant_index K.isCompact _ hU]\n\n"}
{"name":"MeasureTheory.Measure.haar.prehaar_mem_haarProduct","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\n⊢ Membership.mem (MeasureTheory.Measure.haar.haarProduct ↑K₀) (MeasureTheory.Measure.haar.prehaar (↑K₀) U)","decl":"@[to_additive]\ntheorem prehaar_mem_haarProduct (K₀ : PositiveCompacts G) {U : Set G} (hU : (interior U).Nonempty) :\n    prehaar (K₀ : Set G) U ∈ haarProduct (K₀ : Set G) := by\n    rintro ⟨K, hK⟩ _; rw [mem_Icc]; exact ⟨prehaar_nonneg K₀ _, prehaar_le_index K₀ _ hU⟩\n\n"}
{"name":"MeasureTheory.Measure.haar.addPrehaar_mem_addHaarProduct","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nU : Set G\nhU : (interior U).Nonempty\n⊢ Membership.mem (MeasureTheory.Measure.haar.addHaarProduct ↑K₀) (MeasureTheory.Measure.haar.addPrehaar (↑K₀) U)","decl":"@[to_additive]\ntheorem prehaar_mem_haarProduct (K₀ : PositiveCompacts G) {U : Set G} (hU : (interior U).Nonempty) :\n    prehaar (K₀ : Set G) U ∈ haarProduct (K₀ : Set G) := by\n    rintro ⟨K, hK⟩ _; rw [mem_Icc]; exact ⟨prehaar_nonneg K₀ _, prehaar_le_index K₀ _ hU⟩\n\n"}
{"name":"MeasureTheory.Measure.haar.nonempty_iInter_clAddPrehaar","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ (Inter.inter (MeasureTheory.Measure.haar.addHaarProduct ↑K₀) (Set.iInter fun V => MeasureTheory.Measure.haar.clAddPrehaar (↑K₀) V)).Nonempty","decl":"@[to_additive]\ntheorem nonempty_iInter_clPrehaar (K₀ : PositiveCompacts G) :\n    (haarProduct (K₀ : Set G) ∩ ⋂ V : OpenNhdsOf (1 : G), clPrehaar K₀ V).Nonempty := by\n  have : IsCompact (haarProduct (K₀ : Set G)) := by\n    apply isCompact_univ_pi; intro K; apply isCompact_Icc\n  refine this.inter_iInter_nonempty (clPrehaar K₀) (fun s => isClosed_closure) fun t => ?_\n  let V₀ := ⋂ V ∈ t, (V : OpenNhdsOf (1 : G)).carrier\n  have h1V₀ : IsOpen V₀ := isOpen_biInter_finset <| by rintro ⟨⟨V, hV₁⟩, hV₂⟩ _; exact hV₁\n  have h2V₀ : (1 : G) ∈ V₀ := by simp only [V₀, mem_iInter]; rintro ⟨⟨V, hV₁⟩, hV₂⟩ _; exact hV₂\n  refine ⟨prehaar K₀ V₀, ?_⟩\n  constructor\n  · apply prehaar_mem_haarProduct K₀; use 1; rwa [h1V₀.interior_eq]\n  · simp only [mem_iInter]; rintro ⟨V, hV⟩ h2V; apply subset_closure\n    apply mem_image_of_mem; rw [mem_setOf_eq]\n    exact ⟨Subset.trans (iInter_subset _ ⟨V, hV⟩) (iInter_subset _ h2V), h1V₀, h2V₀⟩\n\n"}
{"name":"MeasureTheory.Measure.haar.nonempty_iInter_clPrehaar","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ (Inter.inter (MeasureTheory.Measure.haar.haarProduct ↑K₀) (Set.iInter fun V => MeasureTheory.Measure.haar.clPrehaar (↑K₀) V)).Nonempty","decl":"@[to_additive]\ntheorem nonempty_iInter_clPrehaar (K₀ : PositiveCompacts G) :\n    (haarProduct (K₀ : Set G) ∩ ⋂ V : OpenNhdsOf (1 : G), clPrehaar K₀ V).Nonempty := by\n  have : IsCompact (haarProduct (K₀ : Set G)) := by\n    apply isCompact_univ_pi; intro K; apply isCompact_Icc\n  refine this.inter_iInter_nonempty (clPrehaar K₀) (fun s => isClosed_closure) fun t => ?_\n  let V₀ := ⋂ V ∈ t, (V : OpenNhdsOf (1 : G)).carrier\n  have h1V₀ : IsOpen V₀ := isOpen_biInter_finset <| by rintro ⟨⟨V, hV₁⟩, hV₂⟩ _; exact hV₁\n  have h2V₀ : (1 : G) ∈ V₀ := by simp only [V₀, mem_iInter]; rintro ⟨⟨V, hV₁⟩, hV₂⟩ _; exact hV₂\n  refine ⟨prehaar K₀ V₀, ?_⟩\n  constructor\n  · apply prehaar_mem_haarProduct K₀; use 1; rwa [h1V₀.interior_eq]\n  · simp only [mem_iInter]; rintro ⟨V, hV⟩ h2V; apply subset_closure\n    apply mem_image_of_mem; rw [mem_setOf_eq]\n    exact ⟨Subset.trans (iInter_subset _ ⟨V, hV⟩) (iInter_subset _ h2V), h1V₀, h2V₀⟩\n\n"}
{"name":"MeasureTheory.Measure.haar.addCHaar_mem_addHaarProduct","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Membership.mem (MeasureTheory.Measure.haar.addHaarProduct ↑K₀) (MeasureTheory.Measure.haar.addCHaar K₀)","decl":"@[to_additive addCHaar_mem_addHaarProduct]\ntheorem chaar_mem_haarProduct (K₀ : PositiveCompacts G) : chaar K₀ ∈ haarProduct (K₀ : Set G) :=\n  (Classical.choose_spec (nonempty_iInter_clPrehaar K₀)).1\n\n"}
{"name":"MeasureTheory.Measure.haar.chaar_mem_haarProduct","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Membership.mem (MeasureTheory.Measure.haar.haarProduct ↑K₀) (MeasureTheory.Measure.haar.chaar K₀)","decl":"@[to_additive addCHaar_mem_addHaarProduct]\ntheorem chaar_mem_haarProduct (K₀ : PositiveCompacts G) : chaar K₀ ∈ haarProduct (K₀ : Set G) :=\n  (Classical.choose_spec (nonempty_iInter_clPrehaar K₀)).1\n\n"}
{"name":"MeasureTheory.Measure.haar.chaar_mem_clPrehaar","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nV : TopologicalSpace.OpenNhdsOf 1\n⊢ Membership.mem (MeasureTheory.Measure.haar.clPrehaar (↑K₀) V) (MeasureTheory.Measure.haar.chaar K₀)","decl":"@[to_additive addCHaar_mem_clAddPrehaar]\ntheorem chaar_mem_clPrehaar (K₀ : PositiveCompacts G) (V : OpenNhdsOf (1 : G)) :\n    chaar K₀ ∈ clPrehaar (K₀ : Set G) V := by\n  have := (Classical.choose_spec (nonempty_iInter_clPrehaar K₀)).2; rw [mem_iInter] at this\n  exact this V\n\n"}
{"name":"MeasureTheory.Measure.haar.addCHaar_mem_clAddPrehaar","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nV : TopologicalSpace.OpenNhdsOf 0\n⊢ Membership.mem (MeasureTheory.Measure.haar.clAddPrehaar (↑K₀) V) (MeasureTheory.Measure.haar.addCHaar K₀)","decl":"@[to_additive addCHaar_mem_clAddPrehaar]\ntheorem chaar_mem_clPrehaar (K₀ : PositiveCompacts G) (V : OpenNhdsOf (1 : G)) :\n    chaar K₀ ∈ clPrehaar (K₀ : Set G) V := by\n  have := (Classical.choose_spec (nonempty_iInter_clPrehaar K₀)).2; rw [mem_iInter] at this\n  exact this V\n\n"}
{"name":"MeasureTheory.Measure.haar.addCHaar_nonneg","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK : TopologicalSpace.Compacts G\n⊢ LE.le 0 (MeasureTheory.Measure.haar.addCHaar K₀ K)","decl":"@[to_additive addCHaar_nonneg]\ntheorem chaar_nonneg (K₀ : PositiveCompacts G) (K : Compacts G) : 0 ≤ chaar K₀ K := by\n  have := chaar_mem_haarProduct K₀ K (mem_univ _); rw [mem_Icc] at this; exact this.1\n\n"}
{"name":"MeasureTheory.Measure.haar.chaar_nonneg","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK : TopologicalSpace.Compacts G\n⊢ LE.le 0 (MeasureTheory.Measure.haar.chaar K₀ K)","decl":"@[to_additive addCHaar_nonneg]\ntheorem chaar_nonneg (K₀ : PositiveCompacts G) (K : Compacts G) : 0 ≤ chaar K₀ K := by\n  have := chaar_mem_haarProduct K₀ K (mem_univ _); rw [mem_Icc] at this; exact this.1\n\n"}
{"name":"MeasureTheory.Measure.haar.addCHaar_empty","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq (MeasureTheory.Measure.haar.addCHaar K₀ Bot.bot) 0","decl":"@[to_additive addCHaar_empty]\ntheorem chaar_empty (K₀ : PositiveCompacts G) : chaar K₀ ⊥ = 0 := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f ⊥\n  have : Continuous eval := continuous_apply ⊥\n  show chaar K₀ ∈ eval ⁻¹' {(0 : ℝ)}\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, _, rfl⟩; apply prehaar_empty\n  · apply continuous_iff_isClosed.mp this; exact isClosed_singleton\n\n"}
{"name":"MeasureTheory.Measure.haar.chaar_empty","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq (MeasureTheory.Measure.haar.chaar K₀ Bot.bot) 0","decl":"@[to_additive addCHaar_empty]\ntheorem chaar_empty (K₀ : PositiveCompacts G) : chaar K₀ ⊥ = 0 := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f ⊥\n  have : Continuous eval := continuous_apply ⊥\n  show chaar K₀ ∈ eval ⁻¹' {(0 : ℝ)}\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, _, rfl⟩; apply prehaar_empty\n  · apply continuous_iff_isClosed.mp this; exact isClosed_singleton\n\n"}
{"name":"MeasureTheory.Measure.haar.chaar_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq (MeasureTheory.Measure.haar.chaar K₀ K₀.toCompacts) 1","decl":"@[to_additive addCHaar_self]\ntheorem chaar_self (K₀ : PositiveCompacts G) : chaar K₀ K₀.toCompacts = 1 := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f K₀.toCompacts\n  have : Continuous eval := continuous_apply _\n  show chaar K₀ ∈ eval ⁻¹' {(1 : ℝ)}\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨_, h2U, h3U⟩, rfl⟩; apply prehaar_self\n    rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n  · apply continuous_iff_isClosed.mp this; exact isClosed_singleton\n\n"}
{"name":"MeasureTheory.Measure.haar.addCHaar_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq (MeasureTheory.Measure.haar.addCHaar K₀ K₀.toCompacts) 1","decl":"@[to_additive addCHaar_self]\ntheorem chaar_self (K₀ : PositiveCompacts G) : chaar K₀ K₀.toCompacts = 1 := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f K₀.toCompacts\n  have : Continuous eval := continuous_apply _\n  show chaar K₀ ∈ eval ⁻¹' {(1 : ℝ)}\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨_, h2U, h3U⟩, rfl⟩; apply prehaar_self\n    rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n  · apply continuous_iff_isClosed.mp this; exact isClosed_singleton\n\n"}
{"name":"MeasureTheory.Measure.haar.chaar_mono","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK₁ K₂ : TopologicalSpace.Compacts G\nh : HasSubset.Subset ↑K₁ ↑K₂\n⊢ LE.le (MeasureTheory.Measure.haar.chaar K₀ K₁) (MeasureTheory.Measure.haar.chaar K₀ K₂)","decl":"@[to_additive addCHaar_mono]\ntheorem chaar_mono {K₀ : PositiveCompacts G} {K₁ K₂ : Compacts G} (h : (K₁ : Set G) ⊆ K₂) :\n    chaar K₀ K₁ ≤ chaar K₀ K₂ := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f K₂ - f K₁\n  have : Continuous eval := (continuous_apply K₂).sub (continuous_apply K₁)\n  rw [← sub_nonneg]; show chaar K₀ ∈ eval ⁻¹' Ici (0 : ℝ)\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨_, h2U, h3U⟩, rfl⟩; simp only [eval, mem_preimage, mem_Ici, sub_nonneg]\n    apply prehaar_mono _ h; rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n  · apply continuous_iff_isClosed.mp this; exact isClosed_Ici\n\n"}
{"name":"MeasureTheory.Measure.haar.addCHaar_mono","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK₁ K₂ : TopologicalSpace.Compacts G\nh : HasSubset.Subset ↑K₁ ↑K₂\n⊢ LE.le (MeasureTheory.Measure.haar.addCHaar K₀ K₁) (MeasureTheory.Measure.haar.addCHaar K₀ K₂)","decl":"@[to_additive addCHaar_mono]\ntheorem chaar_mono {K₀ : PositiveCompacts G} {K₁ K₂ : Compacts G} (h : (K₁ : Set G) ⊆ K₂) :\n    chaar K₀ K₁ ≤ chaar K₀ K₂ := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f K₂ - f K₁\n  have : Continuous eval := (continuous_apply K₂).sub (continuous_apply K₁)\n  rw [← sub_nonneg]; show chaar K₀ ∈ eval ⁻¹' Ici (0 : ℝ)\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨_, h2U, h3U⟩, rfl⟩; simp only [eval, mem_preimage, mem_Ici, sub_nonneg]\n    apply prehaar_mono _ h; rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n  · apply continuous_iff_isClosed.mp this; exact isClosed_Ici\n\n"}
{"name":"MeasureTheory.Measure.haar.chaar_sup_le","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK₁ K₂ : TopologicalSpace.Compacts G\n⊢ LE.le (MeasureTheory.Measure.haar.chaar K₀ (Max.max K₁ K₂)) (HAdd.hAdd (MeasureTheory.Measure.haar.chaar K₀ K₁) (MeasureTheory.Measure.haar.chaar K₀ K₂))","decl":"@[to_additive addCHaar_sup_le]\ntheorem chaar_sup_le {K₀ : PositiveCompacts G} (K₁ K₂ : Compacts G) :\n    chaar K₀ (K₁ ⊔ K₂) ≤ chaar K₀ K₁ + chaar K₀ K₂ := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f K₁ + f K₂ - f (K₁ ⊔ K₂)\n  have : Continuous eval := by\n    exact ((continuous_apply K₁).add (continuous_apply K₂)).sub (continuous_apply (K₁ ⊔ K₂))\n  rw [← sub_nonneg]; show chaar K₀ ∈ eval ⁻¹' Ici (0 : ℝ)\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨_, h2U, h3U⟩, rfl⟩; simp only [eval, mem_preimage, mem_Ici, sub_nonneg]\n    apply prehaar_sup_le; rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n  · apply continuous_iff_isClosed.mp this; exact isClosed_Ici\n\n"}
{"name":"MeasureTheory.Measure.haar.addCHaar_sup_le","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK₁ K₂ : TopologicalSpace.Compacts G\n⊢ LE.le (MeasureTheory.Measure.haar.addCHaar K₀ (Max.max K₁ K₂)) (HAdd.hAdd (MeasureTheory.Measure.haar.addCHaar K₀ K₁) (MeasureTheory.Measure.haar.addCHaar K₀ K₂))","decl":"@[to_additive addCHaar_sup_le]\ntheorem chaar_sup_le {K₀ : PositiveCompacts G} (K₁ K₂ : Compacts G) :\n    chaar K₀ (K₁ ⊔ K₂) ≤ chaar K₀ K₁ + chaar K₀ K₂ := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f K₁ + f K₂ - f (K₁ ⊔ K₂)\n  have : Continuous eval := by\n    exact ((continuous_apply K₁).add (continuous_apply K₂)).sub (continuous_apply (K₁ ⊔ K₂))\n  rw [← sub_nonneg]; show chaar K₀ ∈ eval ⁻¹' Ici (0 : ℝ)\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨_, h2U, h3U⟩, rfl⟩; simp only [eval, mem_preimage, mem_Ici, sub_nonneg]\n    apply prehaar_sup_le; rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n  · apply continuous_iff_isClosed.mp this; exact isClosed_Ici\n\n"}
{"name":"MeasureTheory.Measure.haar.chaar_sup_eq","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK₁ K₂ : TopologicalSpace.Compacts G\nh : Disjoint K₁.carrier K₂.carrier\nh₂ : IsClosed K₂.carrier\n⊢ Eq (MeasureTheory.Measure.haar.chaar K₀ (Max.max K₁ K₂)) (HAdd.hAdd (MeasureTheory.Measure.haar.chaar K₀ K₁) (MeasureTheory.Measure.haar.chaar K₀ K₂))","decl":"@[to_additive addCHaar_sup_eq]\ntheorem chaar_sup_eq {K₀ : PositiveCompacts G}\n    {K₁ K₂ : Compacts G} (h : Disjoint K₁.1 K₂.1) (h₂ : IsClosed K₂.1) :\n    chaar K₀ (K₁ ⊔ K₂) = chaar K₀ K₁ + chaar K₀ K₂ := by\n  rcases SeparatedNhds.of_isCompact_isCompact_isClosed K₁.2 K₂.2 h₂ h\n    with ⟨U₁, U₂, h1U₁, h1U₂, h2U₁, h2U₂, hU⟩\n  rcases compact_open_separated_mul_right K₁.2 h1U₁ h2U₁ with ⟨L₁, h1L₁, h2L₁⟩\n  rcases mem_nhds_iff.mp h1L₁ with ⟨V₁, h1V₁, h2V₁, h3V₁⟩\n  replace h2L₁ := Subset.trans (mul_subset_mul_left h1V₁) h2L₁\n  rcases compact_open_separated_mul_right K₂.2 h1U₂ h2U₂ with ⟨L₂, h1L₂, h2L₂⟩\n  rcases mem_nhds_iff.mp h1L₂ with ⟨V₂, h1V₂, h2V₂, h3V₂⟩\n  replace h2L₂ := Subset.trans (mul_subset_mul_left h1V₂) h2L₂\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f K₁ + f K₂ - f (K₁ ⊔ K₂)\n  have : Continuous eval :=\n    ((continuous_apply K₁).add (continuous_apply K₂)).sub (continuous_apply (K₁ ⊔ K₂))\n  rw [eq_comm, ← sub_eq_zero]; show chaar K₀ ∈ eval ⁻¹' {(0 : ℝ)}\n  let V := V₁ ∩ V₂\n  apply\n    mem_of_subset_of_mem _\n      (chaar_mem_clPrehaar K₀\n        ⟨⟨V⁻¹, (h2V₁.inter h2V₂).preimage continuous_inv⟩, by\n          simp only [V, mem_inv, inv_one, h3V₁, h3V₂, mem_inter_iff, true_and]⟩)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩\n    simp only [eval, mem_preimage, sub_eq_zero, mem_singleton_iff]; rw [eq_comm]\n    apply prehaar_sup_eq\n    · rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n    · refine disjoint_of_subset ?_ ?_ hU\n      · refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2L₁\n        exact Subset.trans (inv_subset.mpr h1U) inter_subset_left\n      · refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2L₂\n        exact Subset.trans (inv_subset.mpr h1U) inter_subset_right\n  · apply continuous_iff_isClosed.mp this; exact isClosed_singleton\n\n"}
{"name":"MeasureTheory.Measure.haar.addCHaar_sup_eq","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK₁ K₂ : TopologicalSpace.Compacts G\nh : Disjoint K₁.carrier K₂.carrier\nh₂ : IsClosed K₂.carrier\n⊢ Eq (MeasureTheory.Measure.haar.addCHaar K₀ (Max.max K₁ K₂)) (HAdd.hAdd (MeasureTheory.Measure.haar.addCHaar K₀ K₁) (MeasureTheory.Measure.haar.addCHaar K₀ K₂))","decl":"@[to_additive addCHaar_sup_eq]\ntheorem chaar_sup_eq {K₀ : PositiveCompacts G}\n    {K₁ K₂ : Compacts G} (h : Disjoint K₁.1 K₂.1) (h₂ : IsClosed K₂.1) :\n    chaar K₀ (K₁ ⊔ K₂) = chaar K₀ K₁ + chaar K₀ K₂ := by\n  rcases SeparatedNhds.of_isCompact_isCompact_isClosed K₁.2 K₂.2 h₂ h\n    with ⟨U₁, U₂, h1U₁, h1U₂, h2U₁, h2U₂, hU⟩\n  rcases compact_open_separated_mul_right K₁.2 h1U₁ h2U₁ with ⟨L₁, h1L₁, h2L₁⟩\n  rcases mem_nhds_iff.mp h1L₁ with ⟨V₁, h1V₁, h2V₁, h3V₁⟩\n  replace h2L₁ := Subset.trans (mul_subset_mul_left h1V₁) h2L₁\n  rcases compact_open_separated_mul_right K₂.2 h1U₂ h2U₂ with ⟨L₂, h1L₂, h2L₂⟩\n  rcases mem_nhds_iff.mp h1L₂ with ⟨V₂, h1V₂, h2V₂, h3V₂⟩\n  replace h2L₂ := Subset.trans (mul_subset_mul_left h1V₂) h2L₂\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f K₁ + f K₂ - f (K₁ ⊔ K₂)\n  have : Continuous eval :=\n    ((continuous_apply K₁).add (continuous_apply K₂)).sub (continuous_apply (K₁ ⊔ K₂))\n  rw [eq_comm, ← sub_eq_zero]; show chaar K₀ ∈ eval ⁻¹' {(0 : ℝ)}\n  let V := V₁ ∩ V₂\n  apply\n    mem_of_subset_of_mem _\n      (chaar_mem_clPrehaar K₀\n        ⟨⟨V⁻¹, (h2V₁.inter h2V₂).preimage continuous_inv⟩, by\n          simp only [V, mem_inv, inv_one, h3V₁, h3V₂, mem_inter_iff, true_and]⟩)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨h1U, h2U, h3U⟩, rfl⟩\n    simp only [eval, mem_preimage, sub_eq_zero, mem_singleton_iff]; rw [eq_comm]\n    apply prehaar_sup_eq\n    · rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n    · refine disjoint_of_subset ?_ ?_ hU\n      · refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2L₁\n        exact Subset.trans (inv_subset.mpr h1U) inter_subset_left\n      · refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2L₂\n        exact Subset.trans (inv_subset.mpr h1U) inter_subset_right\n  · apply continuous_iff_isClosed.mp this; exact isClosed_singleton\n\n"}
{"name":"MeasureTheory.Measure.haar.is_left_invariant_chaar","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\ng : G\nK : TopologicalSpace.Compacts G\n⊢ Eq (MeasureTheory.Measure.haar.chaar K₀ (TopologicalSpace.Compacts.map (fun b => HMul.hMul g b) ⋯ K)) (MeasureTheory.Measure.haar.chaar K₀ K)","decl":"@[to_additive is_left_invariant_addCHaar]\ntheorem is_left_invariant_chaar {K₀ : PositiveCompacts G} (g : G) (K : Compacts G) :\n    chaar K₀ (K.map _ <| continuous_mul_left g) = chaar K₀ K := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f (K.map _ <| continuous_mul_left g) - f K\n  have : Continuous eval := (continuous_apply (K.map _ _)).sub (continuous_apply K)\n  rw [← sub_eq_zero]; show chaar K₀ ∈ eval ⁻¹' {(0 : ℝ)}\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨_, h2U, h3U⟩, rfl⟩\n    simp only [eval, mem_singleton_iff, mem_preimage, sub_eq_zero]\n    apply is_left_invariant_prehaar; rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n  · apply continuous_iff_isClosed.mp this; exact isClosed_singleton\n\n"}
{"name":"MeasureTheory.Measure.haar.is_left_invariant_addCHaar","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\ng : G\nK : TopologicalSpace.Compacts G\n⊢ Eq (MeasureTheory.Measure.haar.addCHaar K₀ (TopologicalSpace.Compacts.map (fun b => HAdd.hAdd g b) ⋯ K)) (MeasureTheory.Measure.haar.addCHaar K₀ K)","decl":"@[to_additive is_left_invariant_addCHaar]\ntheorem is_left_invariant_chaar {K₀ : PositiveCompacts G} (g : G) (K : Compacts G) :\n    chaar K₀ (K.map _ <| continuous_mul_left g) = chaar K₀ K := by\n  let eval : (Compacts G → ℝ) → ℝ := fun f => f (K.map _ <| continuous_mul_left g) - f K\n  have : Continuous eval := (continuous_apply (K.map _ _)).sub (continuous_apply K)\n  rw [← sub_eq_zero]; show chaar K₀ ∈ eval ⁻¹' {(0 : ℝ)}\n  apply mem_of_subset_of_mem _ (chaar_mem_clPrehaar K₀ ⊤)\n  unfold clPrehaar; rw [IsClosed.closure_subset_iff]\n  · rintro _ ⟨U, ⟨_, h2U, h3U⟩, rfl⟩\n    simp only [eval, mem_singleton_iff, mem_preimage, sub_eq_zero]\n    apply is_left_invariant_prehaar; rw [h2U.interior_eq]; exact ⟨1, h3U⟩\n  · apply continuous_iff_isClosed.mp this; exact isClosed_singleton\n\n"}
{"name":"MeasureTheory.Measure.haar.haarContent_apply","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK : TopologicalSpace.Compacts G\n⊢ Eq ((fun s => ↑((MeasureTheory.Measure.haar.haarContent K₀).toFun s)) K) ↑(letFun ⟨MeasureTheory.Measure.haar.chaar K₀ K, ⋯⟩ fun this => this)","decl":"@[to_additive]\ntheorem haarContent_apply (K₀ : PositiveCompacts G) (K : Compacts G) :\n    haarContent K₀ K = show NNReal from ⟨chaar K₀ K, chaar_nonneg _ _⟩ :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.haar.addHaarContent_apply","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\nK : TopologicalSpace.Compacts G\n⊢ Eq ((fun s => ↑((MeasureTheory.Measure.haar.addHaarContent K₀).toFun s)) K) ↑(letFun ⟨MeasureTheory.Measure.haar.addCHaar K₀ K, ⋯⟩ fun this => this)","decl":"@[to_additive]\ntheorem haarContent_apply (K₀ : PositiveCompacts G) (K : Compacts G) :\n    haarContent K₀ K = show NNReal from ⟨chaar K₀ K, chaar_nonneg _ _⟩ :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.haar.haarContent_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq ((fun s => ↑((MeasureTheory.Measure.haar.haarContent K₀).toFun s)) K₀.toCompacts) 1","decl":"/-- The variant of `chaar_self` for `haarContent` -/\n@[to_additive \"The variant of `addCHaar_self` for `addHaarContent`.\"]\ntheorem haarContent_self {K₀ : PositiveCompacts G} : haarContent K₀ K₀.toCompacts = 1 := by\n  simp_rw [← ENNReal.coe_one, haarContent_apply, ENNReal.coe_inj, chaar_self]; rfl\n\n"}
{"name":"MeasureTheory.Measure.haar.addHaarContent_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq ((fun s => ↑((MeasureTheory.Measure.haar.addHaarContent K₀).toFun s)) K₀.toCompacts) 1","decl":"/-- The variant of `chaar_self` for `haarContent` -/\n@[to_additive \"The variant of `addCHaar_self` for `addHaarContent`.\"]\ntheorem haarContent_self {K₀ : PositiveCompacts G} : haarContent K₀ K₀.toCompacts = 1 := by\n  simp_rw [← ENNReal.coe_one, haarContent_apply, ENNReal.coe_inj, chaar_self]; rfl\n\n"}
{"name":"MeasureTheory.Measure.haar.is_left_invariant_addHaarContent","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\ng : G\nK : TopologicalSpace.Compacts G\n⊢ Eq ((fun s => ↑((MeasureTheory.Measure.haar.addHaarContent K₀).toFun s)) (TopologicalSpace.Compacts.map (fun b => HAdd.hAdd g b) ⋯ K)) ((fun s => ↑((MeasureTheory.Measure.haar.addHaarContent K₀).toFun s)) K)","decl":"/-- The variant of `is_left_invariant_chaar` for `haarContent` -/\n@[to_additive \"The variant of `is_left_invariant_addCHaar` for `addHaarContent`\"]\ntheorem is_left_invariant_haarContent {K₀ : PositiveCompacts G} (g : G) (K : Compacts G) :\n    haarContent K₀ (K.map _ <| continuous_mul_left g) = haarContent K₀ K := by\n  simpa only [ENNReal.coe_inj, ← NNReal.coe_inj, haarContent_apply] using\n    is_left_invariant_chaar g K\n\n"}
{"name":"MeasureTheory.Measure.haar.is_left_invariant_haarContent","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\ng : G\nK : TopologicalSpace.Compacts G\n⊢ Eq ((fun s => ↑((MeasureTheory.Measure.haar.haarContent K₀).toFun s)) (TopologicalSpace.Compacts.map (fun b => HMul.hMul g b) ⋯ K)) ((fun s => ↑((MeasureTheory.Measure.haar.haarContent K₀).toFun s)) K)","decl":"/-- The variant of `is_left_invariant_chaar` for `haarContent` -/\n@[to_additive \"The variant of `is_left_invariant_addCHaar` for `addHaarContent`\"]\ntheorem is_left_invariant_haarContent {K₀ : PositiveCompacts G} (g : G) (K : Compacts G) :\n    haarContent K₀ (K.map _ <| continuous_mul_left g) = haarContent K₀ K := by\n  simpa only [ENNReal.coe_inj, ← NNReal.coe_inj, haarContent_apply] using\n    is_left_invariant_chaar g K\n\n"}
{"name":"MeasureTheory.Measure.haar.haarContent_outerMeasure_self_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ LT.lt 0 ((MeasureTheory.Measure.haar.haarContent K₀).outerMeasure ↑K₀)","decl":"@[to_additive]\ntheorem haarContent_outerMeasure_self_pos (K₀ : PositiveCompacts G) :\n    0 < (haarContent K₀).outerMeasure K₀ := by\n  refine zero_lt_one.trans_le ?_\n  rw [Content.outerMeasure_eq_iInf]\n  refine le_iInf₂ fun U hU => le_iInf fun hK₀ => le_trans ?_ <| le_iSup₂ K₀.toCompacts hK₀\n  exact haarContent_self.ge\n\n"}
{"name":"MeasureTheory.Measure.haar.addHaarContent_outerMeasure_self_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ LT.lt 0 ((MeasureTheory.Measure.haar.addHaarContent K₀).outerMeasure ↑K₀)","decl":"@[to_additive]\ntheorem haarContent_outerMeasure_self_pos (K₀ : PositiveCompacts G) :\n    0 < (haarContent K₀).outerMeasure K₀ := by\n  refine zero_lt_one.trans_le ?_\n  rw [Content.outerMeasure_eq_iInf]\n  refine le_iInf₂ fun U hU => le_iInf fun hK₀ => le_trans ?_ <| le_iSup₂ K₀.toCompacts hK₀\n  exact haarContent_self.ge\n\n"}
{"name":"MeasureTheory.Measure.haar.addHaarContent_outerMeasure_closure_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ LT.lt 0 ((MeasureTheory.Measure.haar.addHaarContent K₀).outerMeasure (closure ↑K₀))","decl":"@[to_additive]\ntheorem haarContent_outerMeasure_closure_pos (K₀ : PositiveCompacts G) :\n    0 < (haarContent K₀).outerMeasure (closure K₀) :=\n  (haarContent_outerMeasure_self_pos K₀).trans_le (OuterMeasure.mono _ subset_closure)\n\n"}
{"name":"MeasureTheory.Measure.haar.haarContent_outerMeasure_closure_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ LT.lt 0 ((MeasureTheory.Measure.haar.haarContent K₀).outerMeasure (closure ↑K₀))","decl":"@[to_additive]\ntheorem haarContent_outerMeasure_closure_pos (K₀ : PositiveCompacts G) :\n    0 < (haarContent K₀).outerMeasure (closure K₀) :=\n  (haarContent_outerMeasure_self_pos K₀).trans_le (OuterMeasure.mono _ subset_closure)\n\n"}
{"name":"MeasureTheory.Measure.haarMeasure_apply","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\ns : Set G\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.haarMeasure K₀) s) (HDiv.hDiv ((MeasureTheory.Measure.haar.haarContent K₀).outerMeasure s) ((MeasureTheory.Measure.haar.haarContent K₀).measure ↑K₀))","decl":"@[to_additive]\ntheorem haarMeasure_apply {K₀ : PositiveCompacts G} {s : Set G} (hs : MeasurableSet s) :\n    haarMeasure K₀ s = (haarContent K₀).outerMeasure s / (haarContent K₀).measure K₀ := by\n  change ((haarContent K₀).measure K₀)⁻¹ * (haarContent K₀).measure s = _\n  simp only [hs, div_eq_mul_inv, mul_comm, Content.measure_apply]\n\n"}
{"name":"MeasureTheory.Measure.addHaarMeasure_apply","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\ns : Set G\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.addHaarMeasure K₀) s) (HDiv.hDiv ((MeasureTheory.Measure.haar.addHaarContent K₀).outerMeasure s) ((MeasureTheory.Measure.haar.addHaarContent K₀).measure ↑K₀))","decl":"@[to_additive]\ntheorem haarMeasure_apply {K₀ : PositiveCompacts G} {s : Set G} (hs : MeasurableSet s) :\n    haarMeasure K₀ s = (haarContent K₀).outerMeasure s / (haarContent K₀).measure K₀ := by\n  change ((haarContent K₀).measure K₀)⁻¹ * (haarContent K₀).measure s = _\n  simp only [hs, div_eq_mul_inv, mul_comm, Content.measure_apply]\n\n"}
{"name":"MeasureTheory.Measure.isAddLeftInvariant_addHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ (MeasureTheory.Measure.addHaarMeasure K₀).IsAddLeftInvariant","decl":"@[to_additive]\ninstance isMulLeftInvariant_haarMeasure (K₀ : PositiveCompacts G) :\n    IsMulLeftInvariant (haarMeasure K₀) := by\n  rw [← forall_measure_preimage_mul_iff]\n  intro g A hA\n  rw [haarMeasure_apply hA, haarMeasure_apply (measurable_const_mul g hA)]\n  -- Porting note: Here was `congr 1`, but `to_additive` failed to generate a theorem.\n  refine congr_arg (fun x : ℝ≥0∞ => x / (haarContent K₀).measure K₀) ?_\n  apply Content.is_mul_left_invariant_outerMeasure\n  apply is_left_invariant_haarContent\n\n"}
{"name":"MeasureTheory.Measure.isMulLeftInvariant_haarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ (MeasureTheory.Measure.haarMeasure K₀).IsMulLeftInvariant","decl":"@[to_additive]\ninstance isMulLeftInvariant_haarMeasure (K₀ : PositiveCompacts G) :\n    IsMulLeftInvariant (haarMeasure K₀) := by\n  rw [← forall_measure_preimage_mul_iff]\n  intro g A hA\n  rw [haarMeasure_apply hA, haarMeasure_apply (measurable_const_mul g hA)]\n  -- Porting note: Here was `congr 1`, but `to_additive` failed to generate a theorem.\n  refine congr_arg (fun x : ℝ≥0∞ => x / (haarContent K₀).measure K₀) ?_\n  apply Content.is_mul_left_invariant_outerMeasure\n  apply is_left_invariant_haarContent\n\n"}
{"name":"MeasureTheory.Measure.haarMeasure_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq ((MeasureTheory.Measure.haarMeasure K₀) ↑K₀) 1","decl":"@[to_additive]\ntheorem haarMeasure_self {K₀ : PositiveCompacts G} : haarMeasure K₀ K₀ = 1 := by\n  haveI : LocallyCompactSpace G := K₀.locallyCompactSpace_of_group\n  simp only [haarMeasure, coe_smul, Pi.smul_apply, smul_eq_mul]\n  rw [← K₀.isCompact.measure_closure,\n    Content.measure_apply _ isClosed_closure.measurableSet, ENNReal.inv_mul_cancel]\n  · exact (haarContent_outerMeasure_closure_pos K₀).ne'\n  · exact (Content.outerMeasure_lt_top_of_isCompact _ K₀.isCompact.closure).ne\n\n"}
{"name":"MeasureTheory.Measure.addHaarMeasure_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq ((MeasureTheory.Measure.addHaarMeasure K₀) ↑K₀) 1","decl":"@[to_additive]\ntheorem haarMeasure_self {K₀ : PositiveCompacts G} : haarMeasure K₀ K₀ = 1 := by\n  haveI : LocallyCompactSpace G := K₀.locallyCompactSpace_of_group\n  simp only [haarMeasure, coe_smul, Pi.smul_apply, smul_eq_mul]\n  rw [← K₀.isCompact.measure_closure,\n    Content.measure_apply _ isClosed_closure.measurableSet, ENNReal.inv_mul_cancel]\n  · exact (haarContent_outerMeasure_closure_pos K₀).ne'\n  · exact (Content.outerMeasure_lt_top_of_isCompact _ K₀.isCompact.closure).ne\n\n"}
{"name":"MeasureTheory.Measure.regular_addHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ (MeasureTheory.Measure.addHaarMeasure K₀).Regular","decl":"/-- The Haar measure is regular. -/\n@[to_additive \"The additive Haar measure is regular.\"]\ninstance regular_haarMeasure {K₀ : PositiveCompacts G} : (haarMeasure K₀).Regular := by\n  haveI : LocallyCompactSpace G := K₀.locallyCompactSpace_of_group\n  apply Regular.smul\n  rw [← K₀.isCompact.measure_closure,\n    Content.measure_apply _ isClosed_closure.measurableSet, ENNReal.inv_ne_top]\n  exact (haarContent_outerMeasure_closure_pos K₀).ne'\n\n"}
{"name":"MeasureTheory.Measure.regular_haarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ (MeasureTheory.Measure.haarMeasure K₀).Regular","decl":"/-- The Haar measure is regular. -/\n@[to_additive \"The additive Haar measure is regular.\"]\ninstance regular_haarMeasure {K₀ : PositiveCompacts G} : (haarMeasure K₀).Regular := by\n  haveI : LocallyCompactSpace G := K₀.locallyCompactSpace_of_group\n  apply Regular.smul\n  rw [← K₀.isCompact.measure_closure,\n    Content.measure_apply _ isClosed_closure.measurableSet, ENNReal.inv_ne_top]\n  exact (haarContent_outerMeasure_closure_pos K₀).ne'\n\n"}
{"name":"MeasureTheory.Measure.addHaarMeasure_closure_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq ((MeasureTheory.Measure.addHaarMeasure K₀) (closure ↑K₀)) 1","decl":"@[to_additive]\ntheorem haarMeasure_closure_self {K₀ : PositiveCompacts G} : haarMeasure K₀ (closure K₀) = 1 := by\n  rw [K₀.isCompact.measure_closure, haarMeasure_self]\n\n"}
{"name":"MeasureTheory.Measure.haarMeasure_closure_self","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq ((MeasureTheory.Measure.haarMeasure K₀) (closure ↑K₀)) 1","decl":"@[to_additive]\ntheorem haarMeasure_closure_self {K₀ : PositiveCompacts G} : haarMeasure K₀ (closure K₀) = 1 := by\n  rw [K₀.isCompact.measure_closure, haarMeasure_self]\n\n"}
{"name":"MeasureTheory.Measure.sigmaFinite_haarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁵ : Group G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : TopologicalGroup G\ninst✝² : MeasurableSpace G\ninst✝¹ : BorelSpace G\ninst✝ : SecondCountableTopology G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.haarMeasure K₀)","decl":"/-- The Haar measure is sigma-finite in a second countable group. -/\n@[to_additive \"The additive Haar measure is sigma-finite in a second countable group.\"]\ninstance sigmaFinite_haarMeasure [SecondCountableTopology G] {K₀ : PositiveCompacts G} :\n    SigmaFinite (haarMeasure K₀) := by\n  haveI : LocallyCompactSpace G := K₀.locallyCompactSpace_of_group; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.sigmaFinite_addHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁵ : AddGroup G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : TopologicalAddGroup G\ninst✝² : MeasurableSpace G\ninst✝¹ : BorelSpace G\ninst✝ : SecondCountableTopology G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.addHaarMeasure K₀)","decl":"/-- The Haar measure is sigma-finite in a second countable group. -/\n@[to_additive \"The additive Haar measure is sigma-finite in a second countable group.\"]\ninstance sigmaFinite_haarMeasure [SecondCountableTopology G] {K₀ : PositiveCompacts G} :\n    SigmaFinite (haarMeasure K₀) := by\n  haveI : LocallyCompactSpace G := K₀.locallyCompactSpace_of_group; infer_instance\n\n"}
{"name":"MeasureTheory.Measure.isHaarMeasure_haarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ (MeasureTheory.Measure.haarMeasure K₀).IsHaarMeasure","decl":"/-- The Haar measure is a Haar measure, i.e., it is invariant and gives finite mass to compact\nsets and positive mass to nonempty open sets. -/\n@[to_additive\n\"The additive Haar measure is an additive Haar measure, i.e., it is invariant and gives finite mass\nto compact sets and positive mass to nonempty open sets.\"]\ninstance isHaarMeasure_haarMeasure (K₀ : PositiveCompacts G) : IsHaarMeasure (haarMeasure K₀) := by\n  apply\n    isHaarMeasure_of_isCompact_nonempty_interior (haarMeasure K₀) K₀ K₀.isCompact\n      K₀.interior_nonempty\n  · simp only [haarMeasure_self]; exact one_ne_zero\n  · simp only [haarMeasure_self, ne_eq, ENNReal.one_ne_top, not_false_eq_true]\n\n"}
{"name":"MeasureTheory.Measure.isAddHaarMeasure_addHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : MeasurableSpace G\ninst✝ : BorelSpace G\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ (MeasureTheory.Measure.addHaarMeasure K₀).IsAddHaarMeasure","decl":"/-- The Haar measure is a Haar measure, i.e., it is invariant and gives finite mass to compact\nsets and positive mass to nonempty open sets. -/\n@[to_additive\n\"The additive Haar measure is an additive Haar measure, i.e., it is invariant and gives finite mass\nto compact sets and positive mass to nonempty open sets.\"]\ninstance isHaarMeasure_haarMeasure (K₀ : PositiveCompacts G) : IsHaarMeasure (haarMeasure K₀) := by\n  apply\n    isHaarMeasure_of_isCompact_nonempty_interior (haarMeasure K₀) K₀ K₀.isCompact\n      K₀.interior_nonempty\n  · simp only [haarMeasure_self]; exact one_ne_zero\n  · simp only [haarMeasure_self, ne_eq, ENNReal.one_ne_top, not_false_eq_true]\n\n"}
{"name":"MeasureTheory.Measure.sub_mem_nhds_zero_of_addHaar_pos_ne_top","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : LocallyCompactSpace G\ninst✝ : μ.InnerRegularCompactLTTop\nE : Set G\nhE : MeasurableSet E\nhEpos : LT.lt 0 (μ E)\nhEfin : Ne (μ E) Top.top\n⊢ Membership.mem (nhds 0) (HSub.hSub E E)","decl":"/-- **Steinhaus Theorem** for finite mass sets.\n\nIn any locally compact group `G` with an Haar measure `μ` that's inner regular on finite measure\nsets, for any measurable set `E` of finite positive measure, the set `E / E` is a neighbourhood of\n`1`. -/\n@[to_additive\n\"**Steinhaus Theorem** for finite mass sets.\n\nIn any locally compact group `G` with an Haar measure `μ` that's inner regular on finite measure\nsets, for any measurable set `E` of finite positive measure, the set `E - E` is a neighbourhood of\n`0`. \"]\ntheorem div_mem_nhds_one_of_haar_pos_ne_top (μ : Measure G) [IsHaarMeasure μ]\n    [LocallyCompactSpace G] [μ.InnerRegularCompactLTTop] (E : Set G) (hE : MeasurableSet E)\n    (hEpos : 0 < μ E) (hEfin : μ E ≠ ∞) : E / E ∈ 𝓝 (1 : G) :=\n  steinhaus_mul_aux μ E hE <| hE.exists_lt_isCompact_of_ne_top hEfin hEpos\n\n"}
{"name":"MeasureTheory.Measure.div_mem_nhds_one_of_haar_pos_ne_top","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : LocallyCompactSpace G\ninst✝ : μ.InnerRegularCompactLTTop\nE : Set G\nhE : MeasurableSet E\nhEpos : LT.lt 0 (μ E)\nhEfin : Ne (μ E) Top.top\n⊢ Membership.mem (nhds 1) (HDiv.hDiv E E)","decl":"/-- **Steinhaus Theorem** for finite mass sets.\n\nIn any locally compact group `G` with an Haar measure `μ` that's inner regular on finite measure\nsets, for any measurable set `E` of finite positive measure, the set `E / E` is a neighbourhood of\n`1`. -/\n@[to_additive\n\"**Steinhaus Theorem** for finite mass sets.\n\nIn any locally compact group `G` with an Haar measure `μ` that's inner regular on finite measure\nsets, for any measurable set `E` of finite positive measure, the set `E - E` is a neighbourhood of\n`0`. \"]\ntheorem div_mem_nhds_one_of_haar_pos_ne_top (μ : Measure G) [IsHaarMeasure μ]\n    [LocallyCompactSpace G] [μ.InnerRegularCompactLTTop] (E : Set G) (hE : MeasurableSet E)\n    (hEpos : 0 < μ E) (hEfin : μ E ≠ ∞) : E / E ∈ 𝓝 (1 : G) :=\n  steinhaus_mul_aux μ E hE <| hE.exists_lt_isCompact_of_ne_top hEfin hEpos\n\n"}
{"name":"MeasureTheory.Measure.div_mem_nhds_one_of_haar_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsHaarMeasure\ninst✝¹ : LocallyCompactSpace G\ninst✝ : μ.InnerRegular\nE : Set G\nhE : MeasurableSet E\nhEpos : LT.lt 0 (μ E)\n⊢ Membership.mem (nhds 1) (HDiv.hDiv E E)","decl":"/-- **Steinhaus Theorem**.\n\nIn any locally compact group `G` with an inner regular Haar measure `μ`,\nfor any measurable set `E` of positive measure, the set `E / E` is a neighbourhood of `1`. -/\n@[to_additive\n\"**Steinhaus Theorem**.\n\nIn any locally compact group `G` with an inner regular Haar measure `μ`,\nfor any measurable set `E` of positive measure, the set `E - E` is a neighbourhood of `0`.\"]\ntheorem div_mem_nhds_one_of_haar_pos (μ : Measure G) [IsHaarMeasure μ] [LocallyCompactSpace G]\n    [InnerRegular μ] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < μ E) :\n    E / E ∈ 𝓝 (1 : G) := steinhaus_mul_aux μ E hE <| hE.exists_lt_isCompact hEpos\n\n"}
{"name":"MeasureTheory.Measure.sub_mem_nhds_zero_of_addHaar_pos","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\nμ : MeasureTheory.Measure G\ninst✝² : μ.IsAddHaarMeasure\ninst✝¹ : LocallyCompactSpace G\ninst✝ : μ.InnerRegular\nE : Set G\nhE : MeasurableSet E\nhEpos : LT.lt 0 (μ E)\n⊢ Membership.mem (nhds 0) (HSub.hSub E E)","decl":"/-- **Steinhaus Theorem**.\n\nIn any locally compact group `G` with an inner regular Haar measure `μ`,\nfor any measurable set `E` of positive measure, the set `E / E` is a neighbourhood of `1`. -/\n@[to_additive\n\"**Steinhaus Theorem**.\n\nIn any locally compact group `G` with an inner regular Haar measure `μ`,\nfor any measurable set `E` of positive measure, the set `E - E` is a neighbourhood of `0`.\"]\ntheorem div_mem_nhds_one_of_haar_pos (μ : Measure G) [IsHaarMeasure μ] [LocallyCompactSpace G]\n    [InnerRegular μ] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < μ E) :\n    E / E ∈ 𝓝 (1 : G) := steinhaus_mul_aux μ E hE <| hE.exists_lt_isCompact hEpos\n\n"}
{"name":"MeasureTheory.Measure.addHaarMeasure_unique","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : SecondCountableTopology G\nμ : MeasureTheory.Measure G\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : μ.IsAddLeftInvariant\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq μ (HSMul.hSMul (μ ↑K₀) (MeasureTheory.Measure.addHaarMeasure K₀))","decl":"/-- **Uniqueness of left-invariant measures**: In a second-countable locally compact group, any\n  σ-finite left-invariant measure is a scalar multiple of the Haar measure.\n  This is slightly weaker than assuming that `μ` is a Haar measure (in particular we don't require\n  `μ ≠ 0`).\n  See also `isMulLeftInvariant_eq_smul_of_regular`\n  for a statement not assuming second-countability. -/\n@[to_additive\n\"**Uniqueness of left-invariant measures**: In a second-countable locally compact additive group,\n  any σ-finite left-invariant measure is a scalar multiple of the additive Haar measure.\n  This is slightly weaker than assuming that `μ` is a additive Haar measure (in particular we don't\n  require `μ ≠ 0`).\n  See also `isAddLeftInvariant_eq_smul_of_regular`\n  for a statement not assuming second-countability.\"]\ntheorem haarMeasure_unique (μ : Measure G) [SigmaFinite μ] [IsMulLeftInvariant μ]\n    (K₀ : PositiveCompacts G) : μ = μ K₀ • haarMeasure K₀ := by\n  have A : Set.Nonempty (interior (closure (K₀ : Set G))) :=\n    K₀.interior_nonempty.mono (interior_mono subset_closure)\n  have := measure_eq_div_smul μ (haarMeasure K₀)\n    (measure_pos_of_nonempty_interior _ A).ne' K₀.isCompact.closure.measure_ne_top\n  rwa [haarMeasure_closure_self, div_one, K₀.isCompact.measure_closure] at this\n\n"}
{"name":"MeasureTheory.Measure.haarMeasure_unique","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : SecondCountableTopology G\nμ : MeasureTheory.Measure G\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : μ.IsMulLeftInvariant\nK₀ : TopologicalSpace.PositiveCompacts G\n⊢ Eq μ (HSMul.hSMul (μ ↑K₀) (MeasureTheory.Measure.haarMeasure K₀))","decl":"/-- **Uniqueness of left-invariant measures**: In a second-countable locally compact group, any\n  σ-finite left-invariant measure is a scalar multiple of the Haar measure.\n  This is slightly weaker than assuming that `μ` is a Haar measure (in particular we don't require\n  `μ ≠ 0`).\n  See also `isMulLeftInvariant_eq_smul_of_regular`\n  for a statement not assuming second-countability. -/\n@[to_additive\n\"**Uniqueness of left-invariant measures**: In a second-countable locally compact additive group,\n  any σ-finite left-invariant measure is a scalar multiple of the additive Haar measure.\n  This is slightly weaker than assuming that `μ` is a additive Haar measure (in particular we don't\n  require `μ ≠ 0`).\n  See also `isAddLeftInvariant_eq_smul_of_regular`\n  for a statement not assuming second-countability.\"]\ntheorem haarMeasure_unique (μ : Measure G) [SigmaFinite μ] [IsMulLeftInvariant μ]\n    (K₀ : PositiveCompacts G) : μ = μ K₀ • haarMeasure K₀ := by\n  have A : Set.Nonempty (interior (closure (K₀ : Set G))) :=\n    K₀.interior_nonempty.mono (interior_mono subset_closure)\n  have := measure_eq_div_smul μ (haarMeasure K₀)\n    (measure_pos_of_nonempty_interior _ A).ne' K₀.isCompact.closure.measure_ne_top\n  rwa [haarMeasure_closure_self, div_one, K₀.isCompact.measure_closure] at this\n\n"}
{"name":"MeasureTheory.Measure.addHaarMeasure_eq_iff","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : SecondCountableTopology G\nK₀ : TopologicalSpace.PositiveCompacts G\nμ : MeasureTheory.Measure G\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : μ.IsAddLeftInvariant\n⊢ Iff (Eq (MeasureTheory.Measure.addHaarMeasure K₀) μ) (Eq (μ ↑K₀) 1)","decl":"/-- Let `μ` be a σ-finite left invariant measure on `G`. Then `μ` is equal to the Haar measure\ndefined by `K₀` iff `μ K₀ = 1`. -/\n@[to_additive]\ntheorem haarMeasure_eq_iff (K₀ : PositiveCompacts G) (μ : Measure G) [SigmaFinite μ]\n    [IsMulLeftInvariant μ] :\n    haarMeasure K₀ = μ ↔ μ K₀ = 1 :=\n  ⟨fun h => h.symm ▸ haarMeasure_self, fun h => by rw [haarMeasure_unique μ K₀, h, one_smul]⟩\n\n"}
{"name":"MeasureTheory.Measure.haarMeasure_eq_iff","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : SecondCountableTopology G\nK₀ : TopologicalSpace.PositiveCompacts G\nμ : MeasureTheory.Measure G\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : μ.IsMulLeftInvariant\n⊢ Iff (Eq (MeasureTheory.Measure.haarMeasure K₀) μ) (Eq (μ ↑K₀) 1)","decl":"/-- Let `μ` be a σ-finite left invariant measure on `G`. Then `μ` is equal to the Haar measure\ndefined by `K₀` iff `μ K₀ = 1`. -/\n@[to_additive]\ntheorem haarMeasure_eq_iff (K₀ : PositiveCompacts G) (μ : Measure G) [SigmaFinite μ]\n    [IsMulLeftInvariant μ] :\n    haarMeasure K₀ = μ ↔ μ K₀ = 1 :=\n  ⟨fun h => h.symm ▸ haarMeasure_self, fun h => by rw [haarMeasure_unique μ K₀, h, one_smul]⟩\n\n"}
{"name":"MeasureTheory.Measure.regular_of_isMulLeftInvariant","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : SecondCountableTopology G\nμ : MeasureTheory.Measure G\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : μ.IsMulLeftInvariant\nK : Set G\nhK : IsCompact K\nh2K : (interior K).Nonempty\nhμK : Ne (μ K) Top.top\n⊢ μ.Regular","decl":"/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\n  on some compact set with non-empty interior. -/\n@[to_additive\n\"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior.\"]\ntheorem regular_of_isMulLeftInvariant {μ : Measure G} [SigmaFinite μ] [IsMulLeftInvariant μ]\n    {K : Set G} (hK : IsCompact K) (h2K : (interior K).Nonempty) (hμK : μ K ≠ ∞) : Regular μ := by\n  rw [haarMeasure_unique μ ⟨⟨K, hK⟩, h2K⟩]; exact Regular.smul hμK\n\n"}
{"name":"MeasureTheory.Measure.regular_of_isAddLeftInvariant","module":"Mathlib.MeasureTheory.Measure.Haar.Basic","initialProofState":"G : Type u_1\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : BorelSpace G\ninst✝² : SecondCountableTopology G\nμ : MeasureTheory.Measure G\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : μ.IsAddLeftInvariant\nK : Set G\nhK : IsCompact K\nh2K : (interior K).Nonempty\nhμK : Ne (μ K) Top.top\n⊢ μ.Regular","decl":"/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\n  on some compact set with non-empty interior. -/\n@[to_additive\n\"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior.\"]\ntheorem regular_of_isMulLeftInvariant {μ : Measure G} [SigmaFinite μ] [IsMulLeftInvariant μ]\n    {K : Set G} (hK : IsCompact K) (h2K : (interior K).Nonempty) (hμK : μ K ≠ ∞) : Regular μ := by\n  rw [haarMeasure_unique μ ⟨⟨K, hK⟩, h2K⟩]; exact Regular.smul hμK\n\n"}
