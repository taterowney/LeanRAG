{"name":"Module.End.mem_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : ENat\nx : M\n⊢ Iff (Membership.mem ((f.genEigenspace μ) k) x) (Exists fun l => And (LE.le (↑l) k) (Membership.mem (LinearMap.ker (HPow.hPow (HSub.hSub f (HSMul.hSMul μ 1)) l)) x))","decl":"lemma mem_genEigenspace {f : End R M} {μ : R} {k : ℕ∞} {x : M} :\n    x ∈ f.genEigenspace μ k ↔ ∃ l : ℕ, l ≤ k ∧ x ∈ LinearMap.ker ((f - μ • 1) ^ l) := by\n  have : Nonempty {l : ℕ // l ≤ k} := ⟨⟨0, zero_le _⟩⟩\n  have : Directed (ι := { i : ℕ // i ≤ k }) (· ≤ ·) fun i ↦ LinearMap.ker ((f - μ • 1) ^ (i : ℕ)) :=\n    Monotone.directed_le fun m n h ↦ by simpa using (f - μ • 1).iterateKer.monotone h\n  simp_rw [genEigenspace, OrderHom.coe_mk, LinearMap.mem_ker, iSup_subtype',\n    Submodule.mem_iSup_of_directed _ this, LinearMap.mem_ker, Subtype.exists, exists_prop]\n\n"}
{"name":"Module.End.genEigenspace_directed","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : ENat\n⊢ Directed (fun x1 x2 => LE.le x1 x2) fun l => (f.genEigenspace μ) ↑↑l","decl":"lemma genEigenspace_directed {f : End R M} {μ : R} {k : ℕ∞} :\n    Directed (· ≤ ·) (fun l : {l : ℕ // l ≤ k} ↦ f.genEigenspace μ l) := by\n  have aux : Monotone ((↑) : {l : ℕ // l ≤ k} → ℕ∞) := fun x y h ↦ by simpa using h\n  exact ((genEigenspace f μ).monotone.comp aux).directed_le\n\n"}
{"name":"Module.End.mem_genEigenspace_nat","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nx : M\n⊢ Iff (Membership.mem ((f.genEigenspace μ) ↑k) x) (Membership.mem (LinearMap.ker (HPow.hPow (HSub.hSub f (HSMul.hSMul μ 1)) k)) x)","decl":"lemma mem_genEigenspace_nat {f : End R M} {μ : R} {k : ℕ} {x : M} :\n    x ∈ f.genEigenspace μ k ↔ x ∈ LinearMap.ker ((f - μ • 1) ^ k) := by\n  rw [mem_genEigenspace]\n  constructor\n  · rintro ⟨l, hl, hx⟩\n    simp only [Nat.cast_le] at hl\n    exact (f - μ • 1).iterateKer.monotone hl hx\n  · intro hx\n    exact ⟨k, le_rfl, hx⟩\n\n"}
{"name":"Module.End.mem_genEigenspace_top","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nx : M\n⊢ Iff (Membership.mem ((f.genEigenspace μ) Top.top) x) (Exists fun k => Membership.mem (LinearMap.ker (HPow.hPow (HSub.hSub f (HSMul.hSMul μ 1)) k)) x)","decl":"lemma mem_genEigenspace_top {f : End R M} {μ : R} {x : M} :\n    x ∈ f.genEigenspace μ ⊤ ↔ ∃ k : ℕ, x ∈ LinearMap.ker ((f - μ • 1) ^ k) := by\n  simp [mem_genEigenspace]\n\n"}
{"name":"Module.End.genEigenspace_nat","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\n⊢ Eq ((f.genEigenspace μ) ↑k) (LinearMap.ker (HPow.hPow (HSub.hSub f (HSMul.hSMul μ 1)) k))","decl":"lemma genEigenspace_nat {f : End R M} {μ : R} {k : ℕ} :\n    f.genEigenspace μ k = LinearMap.ker ((f - μ • 1) ^ k) := by\n  ext; simp [mem_genEigenspace_nat]\n\n"}
{"name":"Module.End.genEigenspace_eq_iSup_genEigenspace_nat","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : ENat\n⊢ Eq ((f.genEigenspace μ) k) (iSup fun l => (f.genEigenspace μ) ↑↑l)","decl":"lemma genEigenspace_eq_iSup_genEigenspace_nat (f : End R M) (μ : R) (k : ℕ∞) :\n    f.genEigenspace μ k = ⨆ l : {l : ℕ // l ≤ k}, f.genEigenspace μ l := by\n  simp_rw [genEigenspace_nat, genEigenspace, OrderHom.coe_mk, iSup_subtype]\n\n"}
{"name":"Module.End.genEigenspace_top","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\n⊢ Eq ((f.genEigenspace μ) Top.top) (iSup fun k => (f.genEigenspace μ) ↑k)","decl":"lemma genEigenspace_top (f : End R M) (μ : R) :\n    f.genEigenspace μ ⊤ = ⨆ k : ℕ, f.genEigenspace μ k := by\n  rw [genEigenspace_eq_iSup_genEigenspace_nat, iSup_subtype]\n  simp only [le_top, iSup_pos, OrderHom.coe_mk]\n\n"}
{"name":"Module.End.genEigenspace_one","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\n⊢ Eq ((f.genEigenspace μ) 1) (LinearMap.ker (HSub.hSub f (HSMul.hSMul μ 1)))","decl":"lemma genEigenspace_one {f : End R M} {μ : R} :\n    f.genEigenspace μ 1 = LinearMap.ker (f - μ • 1) := by\n  rw [← Nat.cast_one, genEigenspace_nat, pow_one]\n\n"}
{"name":"Module.End.mem_genEigenspace_one","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nx : M\n⊢ Iff (Membership.mem ((f.genEigenspace μ) 1) x) (Eq (f x) (HSMul.hSMul μ x))","decl":"@[simp]\nlemma mem_genEigenspace_one {f : End R M} {μ : R} {x : M} :\n    x ∈ f.genEigenspace μ 1 ↔ f x = μ • x := by\n  rw [genEigenspace_one, LinearMap.mem_ker, LinearMap.sub_apply,\n    sub_eq_zero, LinearMap.smul_apply, LinearMap.one_apply]\n\n-- `simp` can prove this using `genEigenspace_zero`\n"}
{"name":"Module.End.mem_genEigenspace_zero","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nx : M\n⊢ Iff (Membership.mem ((f.genEigenspace μ) 0) x) (Eq x 0)","decl":"lemma mem_genEigenspace_zero {f : End R M} {μ : R} {x : M} :\n    x ∈ f.genEigenspace μ 0 ↔ x = 0 := by\n  rw [← Nat.cast_zero, mem_genEigenspace_nat, pow_zero, LinearMap.mem_ker, LinearMap.one_apply]\n\n"}
{"name":"Module.End.genEigenspace_zero","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\n⊢ Eq ((f.genEigenspace μ) 0) Bot.bot","decl":"@[simp]\nlemma genEigenspace_zero {f : End R M} {μ : R} :\n    f.genEigenspace μ 0 = ⊥ := by\n  ext; apply mem_genEigenspace_zero\n\n"}
{"name":"Module.End.genEigenspace_zero_nat","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nk : Nat\n⊢ Eq ((f.genEigenspace 0) ↑k) (LinearMap.ker (HPow.hPow f k))","decl":"@[simp]\nlemma genEigenspace_zero_nat (f : End R M) (k : ℕ) :\n    f.genEigenspace 0 k = LinearMap.ker (f ^ k) := by\n  ext; simp [mem_genEigenspace_nat]\n\n"}
{"name":"Module.End.HasUnifEigenvector.hasUnifEigenvalue","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : ENat\nx : M\nh : f.HasUnifEigenvector μ k x\n⊢ f.HasUnifEigenvalue μ k","decl":"lemma HasUnifEigenvector.hasUnifEigenvalue {f : End R M} {μ : R} {k : ℕ∞} {x : M}\n    (h : f.HasUnifEigenvector μ k x) : f.HasUnifEigenvalue μ k := by\n  rw [HasUnifEigenvalue, Submodule.ne_bot_iff]\n  use x; exact h\n\n"}
{"name":"Module.End.HasUnifEigenvector.apply_eq_smul","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nx : M\nhx : f.HasUnifEigenvector μ 1 x\n⊢ Eq (f x) (HSMul.hSMul μ x)","decl":"lemma HasUnifEigenvector.apply_eq_smul {f : End R M} {μ : R} {x : M}\n    (hx : f.HasUnifEigenvector μ 1 x) : f x = μ • x :=\n  mem_genEigenspace_one.mp hx.1\n\n"}
{"name":"Module.End.HasUnifEigenvector.pow_apply","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nv : M\nhv : f.HasUnifEigenvector μ 1 v\nn : Nat\n⊢ Eq ((HPow.hPow f n) v) (HSMul.hSMul (HPow.hPow μ n) v)","decl":"lemma HasUnifEigenvector.pow_apply {f : End R M} {μ : R} {v : M} (hv : f.HasUnifEigenvector μ 1 v)\n    (n : ℕ) : (f ^ n) v = μ ^ n • v := by\n  induction n <;> simp [*, pow_succ f, hv.apply_eq_smul, smul_smul, pow_succ' μ]\n\n"}
{"name":"Module.End.HasUnifEigenvalue.exists_hasUnifEigenvector","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : ENat\nhμ : f.HasUnifEigenvalue μ k\n⊢ Exists fun v => f.HasUnifEigenvector μ k v","decl":"theorem HasUnifEigenvalue.exists_hasUnifEigenvector\n    {f : End R M} {μ : R} {k : ℕ∞} (hμ : f.HasUnifEigenvalue μ k) :\n    ∃ v, f.HasUnifEigenvector μ k v :=\n  Submodule.exists_mem_ne_zero_of_ne_bot hμ\n\n"}
{"name":"Module.End.HasUnifEigenvalue.pow","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nh : f.HasUnifEigenvalue μ 1\nn : Nat\n⊢ (HPow.hPow f n).HasUnifEigenvalue (HPow.hPow μ n) 1","decl":"lemma HasUnifEigenvalue.pow {f : End R M} {μ : R} (h : f.HasUnifEigenvalue μ 1) (n : ℕ) :\n    (f ^ n).HasUnifEigenvalue (μ ^ n) 1 := by\n  rw [HasUnifEigenvalue, Submodule.ne_bot_iff]\n  obtain ⟨m : M, hm⟩ := h.exists_hasUnifEigenvector\n  exact ⟨m, by simpa [mem_genEigenspace_one] using hm.pow_apply n, hm.2⟩\n\n"}
{"name":"Module.End.HasUnifEigenvalue.isNilpotent_of_isNilpotent","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\nhfn : IsNilpotent f\nμ : R\nhf : f.HasUnifEigenvalue μ 1\n⊢ IsNilpotent μ","decl":"/-- A nilpotent endomorphism has nilpotent eigenvalues.\n\nSee also `LinearMap.isNilpotent_trace_of_isNilpotent`. -/\nlemma HasUnifEigenvalue.isNilpotent_of_isNilpotent [NoZeroSMulDivisors R M] {f : End R M}\n    (hfn : IsNilpotent f) {μ : R} (hf : f.HasUnifEigenvalue μ 1) :\n    IsNilpotent μ := by\n  obtain ⟨m : M, hm⟩ := hf.exists_hasUnifEigenvector\n  obtain ⟨n : ℕ, hn : f ^ n = 0⟩ := hfn\n  exact ⟨n, by simpa [hn, hm.2, eq_comm (a := (0 : M))] using hm.pow_apply n⟩\n\n"}
{"name":"Module.End.HasUnifEigenvalue.mem_spectrum","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nhμ : f.HasUnifEigenvalue μ 1\n⊢ Membership.mem (spectrum R f) μ","decl":"lemma HasUnifEigenvalue.mem_spectrum {f : End R M} {μ : R} (hμ : HasUnifEigenvalue f μ 1) :\n    μ ∈ spectrum R f := by\n  refine spectrum.mem_iff.mpr fun h_unit ↦ ?_\n  set f' := LinearMap.GeneralLinearGroup.toLinearEquiv h_unit.unit\n  rcases hμ.exists_hasUnifEigenvector with ⟨v, hv⟩\n  refine hv.2 ((LinearMap.ker_eq_bot'.mp f'.ker) v (?_ : μ • v - f v = 0))\n  rw [hv.apply_eq_smul, sub_self]\n\n"}
{"name":"Module.End.hasUnifEigenvalue_iff_mem_spectrum","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\n⊢ Iff (f.HasUnifEigenvalue μ 1) (Membership.mem (spectrum K f) μ)","decl":"lemma hasUnifEigenvalue_iff_mem_spectrum [FiniteDimensional K V] {f : End K V} {μ : K} :\n    f.HasUnifEigenvalue μ 1 ↔ μ ∈ spectrum K f := by\n  rw [spectrum.mem_iff, IsUnit.sub_iff, LinearMap.isUnit_iff_ker_eq_bot,\n    HasUnifEigenvalue, genEigenspace_one, ne_eq, not_iff_not]\n  simp [Submodule.ext_iff, LinearMap.mem_ker]\n\n"}
{"name":"Module.End.HasUnifEigenvalue.of_mem_spectrum","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\na✝ : Membership.mem (spectrum K f) μ\n⊢ f.HasUnifEigenvalue μ 1","decl":"alias ⟨_, HasUnifEigenvalue.of_mem_spectrum⟩ := hasUnifEigenvalue_iff_mem_spectrum\n\n"}
{"name":"Module.End.genEigenspace_div","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Module.End K V\na b : K\nhb : Ne b 0\n⊢ Eq ((f.genEigenspace (HDiv.hDiv a b)) 1) (LinearMap.ker (HSub.hSub (HSMul.hSMul b f) (HSMul.hSMul a 1)))","decl":"lemma genEigenspace_div (f : End K V) (a b : K) (hb : b ≠ 0) :\n    genEigenspace f (a / b) 1 = LinearMap.ker (b • f - a • 1) :=\n  calc\n    genEigenspace f (a / b) 1 = genEigenspace f (b⁻¹ * a) 1 := by rw [div_eq_mul_inv, mul_comm]\n    _ = LinearMap.ker (f - (b⁻¹ * a) • 1)     := by rw [genEigenspace_one]\n    _ = LinearMap.ker (f - b⁻¹ • a • 1)       := by rw [smul_smul]\n    _ = LinearMap.ker (b • (f - b⁻¹ • a • 1)) := by rw [LinearMap.ker_smul _ b hb]\n    _ = LinearMap.ker (b • f - a • 1)         := by rw [smul_sub, smul_inv_smul₀ hb]\n\n"}
{"name":"Module.End.genEigenrange_nat","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\n⊢ Eq (f.genEigenrange μ ↑k) (LinearMap.range (HPow.hPow (HSub.hSub f (HSMul.hSMul μ 1)) k))","decl":"lemma genEigenrange_nat {f : End R M} {μ : R} {k : ℕ} :\n    f.genEigenrange μ k = LinearMap.range ((f - μ • 1) ^ k) := by\n  ext x\n  simp only [genEigenrange, Nat.cast_le, Submodule.mem_iInf, LinearMap.mem_range]\n  constructor\n  · intro h\n    exact h _ le_rfl\n  · rintro ⟨x, rfl⟩ i hi\n    have : k = i + (k - i) := by omega\n    rw [this, pow_add]\n    exact ⟨_, rfl⟩\n\n"}
{"name":"Module.End.HasUnifEigenvalue.exp_ne_zero","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nh : f.HasUnifEigenvalue μ ↑k\n⊢ Ne k 0","decl":"/-- The exponent of a generalized eigenvalue is never 0. -/\nlemma HasUnifEigenvalue.exp_ne_zero {f : End R M} {μ : R} {k : ℕ}\n    (h : f.HasUnifEigenvalue μ k) : k ≠ 0 := by\n  rintro rfl\n  simp [HasUnifEigenvalue, Nat.cast_zero, genEigenspace_zero] at h\n\n"}
{"name":"Module.End.genEigenspace_top_eq_maxUnifEigenspaceIndex","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : IsNoetherian R M\nf : Module.End R M\nμ : R\n⊢ Eq ((f.genEigenspace μ) Top.top) ((f.genEigenspace μ) ↑(f.maxUnifEigenspaceIndex μ))","decl":"/-- For an endomorphism of a Noetherian module, the maximal eigenspace is always of the form kernel\n`(f - μ • id) ^ k` for some `k`. -/\nlemma genEigenspace_top_eq_maxUnifEigenspaceIndex [h : IsNoetherian R M] (f : End R M) (μ : R) :\n    genEigenspace f μ ⊤ = f.genEigenspace μ (maxUnifEigenspaceIndex f μ) := by\n  rw [isNoetherian_iff] at h\n  have := WellFounded.iSup_eq_monotonicSequenceLimit h <|\n    (f.genEigenspace μ).comp <| WithTop.coeOrderHom.toOrderHom\n  convert this using 1\n  simp only [genEigenspace, OrderHom.coe_mk, le_top, iSup_pos, OrderHom.comp_coe,\n    Function.comp_def]\n  rw [iSup_prod', iSup_subtype', ← sSup_range, ← sSup_range]\n  congr\n  aesop\n\n"}
{"name":"Module.End.genEigenspace_le_genEigenspace_maxUnifEigenspaceIndex","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : Module.End R M\nμ : R\nk : ENat\n⊢ LE.le ((f.genEigenspace μ) k) ((f.genEigenspace μ) ↑(f.maxUnifEigenspaceIndex μ))","decl":"lemma genEigenspace_le_genEigenspace_maxUnifEigenspaceIndex [IsNoetherian R M] (f : End R M)\n    (μ : R) (k : ℕ∞) :\n    f.genEigenspace μ k ≤ f.genEigenspace μ (maxUnifEigenspaceIndex f μ) := by\n  rw [← genEigenspace_top_eq_maxUnifEigenspaceIndex]\n  exact (f.genEigenspace μ).monotone le_top\n\n"}
{"name":"Module.End.genEigenspace_eq_genEigenspace_maxUnifEigenspaceIndex_of_le","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : Module.End R M\nμ : R\nk : Nat\nhk : LE.le (f.maxUnifEigenspaceIndex μ) k\n⊢ Eq ((f.genEigenspace μ) ↑k) ((f.genEigenspace μ) ↑(f.maxUnifEigenspaceIndex μ))","decl":"/-- Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. -/\ntheorem genEigenspace_eq_genEigenspace_maxUnifEigenspaceIndex_of_le [IsNoetherian R M]\n    (f : End R M) (μ : R) {k : ℕ} (hk : maxUnifEigenspaceIndex f μ ≤ k) :\n    f.genEigenspace μ k = f.genEigenspace μ (maxUnifEigenspaceIndex f μ) :=\n  le_antisymm\n    (genEigenspace_le_genEigenspace_maxUnifEigenspaceIndex _ _ _)\n    ((f.genEigenspace μ).monotone <| by simpa using hk)\n\n"}
{"name":"Module.End.HasUnifEigenvalue.le","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk m : ENat\nhm : LE.le k m\nhk : f.HasUnifEigenvalue μ k\n⊢ f.HasUnifEigenvalue μ m","decl":"/-- A generalized eigenvalue for some exponent `k` is also\n    a generalized eigenvalue for exponents larger than `k`. -/\nlemma HasUnifEigenvalue.le {f : End R M} {μ : R} {k m : ℕ∞}\n    (hm : k ≤ m) (hk : f.HasUnifEigenvalue μ k) :\n    f.HasUnifEigenvalue μ m := by\n  unfold HasUnifEigenvalue at *\n  contrapose! hk\n  rw [← le_bot_iff, ← hk]\n  exact (f.genEigenspace _).monotone hm\n\n"}
{"name":"Module.End.HasUnifEigenvalue.lt","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk m : ENat\nhm : LT.lt 0 m\nhk : f.HasUnifEigenvalue μ k\n⊢ f.HasUnifEigenvalue μ m","decl":"/-- A generalized eigenvalue for some exponent `k` is also\n    a generalized eigenvalue for positive exponents. -/\nlemma HasUnifEigenvalue.lt {f : End R M} {μ : R} {k m : ℕ∞}\n    (hm : 0 < m) (hk : f.HasUnifEigenvalue μ k) :\n    f.HasUnifEigenvalue μ m := by\n  apply HasUnifEigenvalue.le (k := 1) (Order.one_le_iff_pos.mpr hm)\n  intro contra; apply hk\n  rw [genEigenspace_one, LinearMap.ker_eq_bot] at contra\n  rw [eq_bot_iff]\n  intro x hx\n  rw [mem_genEigenspace] at hx\n  rcases hx with ⟨l, -, hx⟩\n  rwa [LinearMap.ker_eq_bot.mpr] at hx\n  rw [LinearMap.coe_pow (f - μ • 1) l]\n  exact Function.Injective.iterate contra l\n\n"}
{"name":"Module.End.hasUnifEigenvalue_iff_hasUnifEigenvalue_one","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : ENat\nhk : LT.lt 0 k\n⊢ Iff (f.HasUnifEigenvalue μ k) (f.HasUnifEigenvalue μ 1)","decl":"/-- Generalized eigenvalues are actually just eigenvalues. -/\n@[simp]\nlemma hasUnifEigenvalue_iff_hasUnifEigenvalue_one {f : End R M} {μ : R} {k : ℕ∞} (hk : 0 < k) :\n    f.HasUnifEigenvalue μ k ↔ f.HasUnifEigenvalue μ 1 :=\n  ⟨HasUnifEigenvalue.lt zero_lt_one, HasUnifEigenvalue.lt hk⟩\n\n"}
{"name":"Module.End.maxUnifEigenspaceIndex_le_finrank","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\n⊢ LE.le (f.maxUnifEigenspaceIndex μ) (Module.finrank K V)","decl":"lemma maxUnifEigenspaceIndex_le_finrank [FiniteDimensional K V] (f : End K V) (μ : K) :\n    maxUnifEigenspaceIndex f μ ≤ finrank K V := by\n  apply Nat.sInf_le\n  intro n hn\n  apply le_antisymm\n  · exact (f.genEigenspace μ).monotone <| WithTop.coeOrderHom.monotone hn\n  · show (f.genEigenspace μ) n ≤ (f.genEigenspace μ) (finrank K V)\n    rw [genEigenspace_nat, genEigenspace_nat]\n    apply ker_pow_le_ker_pow_finrank\n\n"}
{"name":"Module.End.genEigenspace_le_genEigenspace_finrank","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\nk : ENat\n⊢ LE.le ((f.genEigenspace μ) k) ((f.genEigenspace μ) ↑(Module.finrank K V))","decl":"/-- Every generalized eigenvector is a generalized eigenvector for exponent `finrank K V`.\n    (Lemma 8.11 of [axler2015]) -/\nlemma genEigenspace_le_genEigenspace_finrank [FiniteDimensional K V] (f : End K V)\n    (μ : K) (k : ℕ∞) : f.genEigenspace μ k ≤ f.genEigenspace μ (finrank K V) := by\n  calc f.genEigenspace μ k\n      ≤ f.genEigenspace μ ⊤ := (f.genEigenspace _).monotone le_top\n    _ ≤ f.genEigenspace μ (finrank K V) := by\n      rw [genEigenspace_top_eq_maxUnifEigenspaceIndex]\n      exact (f.genEigenspace _).monotone <| by simpa using maxUnifEigenspaceIndex_le_finrank f μ\n\n"}
{"name":"Module.End.genEigenspace_eq_genEigenspace_finrank_of_le","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\nk : Nat\nhk : LE.le (Module.finrank K V) k\n⊢ Eq ((f.genEigenspace μ) ↑k) ((f.genEigenspace μ) ↑(Module.finrank K V))","decl":"/-- Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. -/\ntheorem genEigenspace_eq_genEigenspace_finrank_of_le [FiniteDimensional K V]\n    (f : End K V) (μ : K) {k : ℕ} (hk : finrank K V ≤ k) :\n    f.genEigenspace μ k = f.genEigenspace μ (finrank K V) :=\n  le_antisymm\n    (genEigenspace_le_genEigenspace_finrank _ _ _)\n    ((f.genEigenspace μ).monotone <| by simpa using hk)\n\n"}
{"name":"Module.End.mapsTo_genEigenspace_of_comm","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf g : Module.End R M\nh : Commute f g\nμ : R\nk : ENat\n⊢ Set.MapsTo ⇑g ↑((f.genEigenspace μ) k) ↑((f.genEigenspace μ) k)","decl":"lemma mapsTo_genEigenspace_of_comm {f g : End R M} (h : Commute f g) (μ : R) (k : ℕ∞) :\n    MapsTo g (f.genEigenspace μ k) (f.genEigenspace μ k) := by\n  intro x hx\n  simp only [SetLike.mem_coe, mem_genEigenspace, LinearMap.mem_ker] at hx ⊢\n  rcases hx with ⟨l, hl, hx⟩\n  replace h : Commute ((f - μ • (1 : End R M)) ^ l) g :=\n    (h.sub_left <| Algebra.commute_algebraMap_left μ g).pow_left l\n  use l, hl\n  rw [← LinearMap.comp_apply, ← LinearMap.mul_eq_comp, h.eq, LinearMap.mul_eq_comp,\n    LinearMap.comp_apply, hx, map_zero]\n\n"}
{"name":"Module.End.isNilpotent_restrict_genEigenspace_nat","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nh : optParam (Set.MapsTo ⇑(HSub.hSub f (HSMul.hSMul μ 1)) ↑((f.genEigenspace μ) ↑k) ↑((f.genEigenspace μ) ↑k)) ⋯\n⊢ IsNilpotent (LinearMap.restrict (HSub.hSub f (HSMul.hSMul μ 1)) h)","decl":"/-- The restriction of `f - μ • 1` to the `k`-fold generalized `μ`-eigenspace is nilpotent. -/\nlemma isNilpotent_restrict_genEigenspace_nat (f : End R M) (μ : R) (k : ℕ)\n    (h : MapsTo (f - μ • (1 : End R M))\n      (f.genEigenspace μ k) (f.genEigenspace μ k) :=\n      mapsTo_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f μ) μ k) :\n    IsNilpotent ((f - μ • 1).restrict h) := by\n  use k\n  ext ⟨x, hx⟩\n  rw [mem_genEigenspace_nat] at hx\n  rw [LinearMap.zero_apply, ZeroMemClass.coe_zero, ZeroMemClass.coe_eq_zero,\n    LinearMap.pow_restrict, LinearMap.restrict_apply]\n  ext\n  simpa\n\n"}
{"name":"Module.End.isNilpotent_restrict_genEigenspace_top","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : Module.End R M\nμ : R\nh : optParam (Set.MapsTo ⇑(HSub.hSub f (HSMul.hSMul μ 1)) ↑((f.genEigenspace μ) Top.top) ↑((f.genEigenspace μ) Top.top)) ⋯\n⊢ IsNilpotent (LinearMap.restrict (HSub.hSub f (HSMul.hSMul μ 1)) h)","decl":"/-- The restriction of `f - μ • 1` to the generalized `μ`-eigenspace is nilpotent. -/\nlemma isNilpotent_restrict_genEigenspace_top [IsNoetherian R M] (f : End R M) (μ : R)\n    (h : MapsTo (f - μ • (1 : End R M))\n      (f.genEigenspace μ ⊤) (f.genEigenspace μ ⊤) :=\n      mapsTo_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f μ) μ _) :\n    IsNilpotent ((f - μ • 1).restrict h) := by\n  apply isNilpotent_restrict_of_le\n  on_goal 2 => apply isNilpotent_restrict_genEigenspace_nat f μ (maxUnifEigenspaceIndex f μ)\n  rw [genEigenspace_top_eq_maxUnifEigenspaceIndex]\n\n"}
{"name":"Module.End.eigenspace_def","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\n⊢ Eq (f.eigenspace μ) (LinearMap.ker (HSub.hSub f (HSMul.hSMul μ 1)))","decl":"lemma eigenspace_def {f : End R M} {μ : R} :\n    f.eigenspace μ = LinearMap.ker (f - μ • 1) := by\n  rw [eigenspace, genEigenspace_one]\n\n"}
{"name":"Module.End.eigenspace_zero","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\n⊢ Eq (f.eigenspace 0) (LinearMap.ker f)","decl":"@[simp]\ntheorem eigenspace_zero (f : End R M) : f.eigenspace 0 = LinearMap.ker f := by\n  simp only [eigenspace, ← Nat.cast_one (R := ℕ∞), genEigenspace_zero_nat, pow_one]\n\n"}
{"name":"Module.End.hasEigenvector_iff","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nx : M\n⊢ Iff (f.HasEigenvector μ x) (And (Membership.mem (f.eigenspace μ) x) (Ne x 0))","decl":"lemma hasEigenvector_iff {f : End R M} {μ : R} {x : M} :\n    f.HasEigenvector μ x ↔ x ∈ f.eigenspace μ ∧ x ≠ 0 := Iff.rfl\n\n"}
{"name":"Module.End.hasEigenvalue_iff","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\n⊢ Iff (f.HasEigenvalue μ) (Ne (f.eigenspace μ) Bot.bot)","decl":"lemma hasEigenvalue_iff {f : End R M} {μ : R} :\n    f.HasEigenvalue μ ↔ f.eigenspace μ ≠ ⊥ := Iff.rfl\n\n"}
{"name":"Module.End.hasEigenvalue_of_hasEigenvector","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nx : M\nh : f.HasEigenvector μ x\n⊢ f.HasEigenvalue μ","decl":"theorem hasEigenvalue_of_hasEigenvector {f : End R M} {μ : R} {x : M} (h : HasEigenvector f μ x) :\n    HasEigenvalue f μ :=\n  h.hasUnifEigenvalue\n\n"}
{"name":"Module.End.mem_eigenspace_iff","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nx : M\n⊢ Iff (Membership.mem (f.eigenspace μ) x) (Eq (f x) (HSMul.hSMul μ x))","decl":"theorem mem_eigenspace_iff {f : End R M} {μ : R} {x : M} : x ∈ eigenspace f μ ↔ f x = μ • x :=\n  mem_genEigenspace_one\n\n"}
{"name":"Module.End.HasEigenvector.apply_eq_smul","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nx : M\nhx : f.HasEigenvector μ x\n⊢ Eq (f x) (HSMul.hSMul μ x)","decl":"nonrec\ntheorem HasEigenvector.apply_eq_smul {f : End R M} {μ : R} {x : M} (hx : f.HasEigenvector μ x) :\n    f x = μ • x :=\n  hx.apply_eq_smul\n\n"}
{"name":"Module.End.HasEigenvector.pow_apply","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nv : M\nhv : f.HasEigenvector μ v\nn : Nat\n⊢ Eq ((HPow.hPow f n) v) (HSMul.hSMul (HPow.hPow μ n) v)","decl":"nonrec\ntheorem HasEigenvector.pow_apply {f : End R M} {μ : R} {v : M} (hv : f.HasEigenvector μ v) (n : ℕ) :\n    (f ^ n) v = μ ^ n • v :=\n  hv.pow_apply n\n\n"}
{"name":"Module.End.HasEigenvalue.exists_hasEigenvector","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nhμ : f.HasEigenvalue μ\n⊢ Exists fun v => f.HasEigenvector μ v","decl":"theorem HasEigenvalue.exists_hasEigenvector {f : End R M} {μ : R} (hμ : f.HasEigenvalue μ) :\n    ∃ v, f.HasEigenvector μ v :=\n  Submodule.exists_mem_ne_zero_of_ne_bot hμ\n\n"}
{"name":"Module.End.HasEigenvalue.pow","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nh : f.HasEigenvalue μ\nn : Nat\n⊢ (HPow.hPow f n).HasEigenvalue (HPow.hPow μ n)","decl":"nonrec\nlemma HasEigenvalue.pow {f : End R M} {μ : R} (h : f.HasEigenvalue μ) (n : ℕ) :\n    (f ^ n).HasEigenvalue (μ ^ n) :=\n  h.pow n\n\n"}
{"name":"Module.End.HasEigenvalue.isNilpotent_of_isNilpotent","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\nhfn : IsNilpotent f\nμ : R\nhf : f.HasEigenvalue μ\n⊢ IsNilpotent μ","decl":"/-- A nilpotent endomorphism has nilpotent eigenvalues.\n\nSee also `LinearMap.isNilpotent_trace_of_isNilpotent`. -/\nnonrec\nlemma HasEigenvalue.isNilpotent_of_isNilpotent [NoZeroSMulDivisors R M] {f : End R M}\n    (hfn : IsNilpotent f) {μ : R} (hf : f.HasEigenvalue μ) :\n    IsNilpotent μ :=\n  hf.isNilpotent_of_isNilpotent hfn\n\n"}
{"name":"Module.End.HasEigenvalue.mem_spectrum","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nhμ : f.HasEigenvalue μ\n⊢ Membership.mem (spectrum R f) μ","decl":"nonrec\ntheorem HasEigenvalue.mem_spectrum {f : End R M} {μ : R} (hμ : HasEigenvalue f μ) :\n    μ ∈ spectrum R f :=\n  hμ.mem_spectrum\n\n"}
{"name":"Module.End.hasEigenvalue_iff_mem_spectrum","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\n⊢ Iff (f.HasEigenvalue μ) (Membership.mem (spectrum K f) μ)","decl":"theorem hasEigenvalue_iff_mem_spectrum [FiniteDimensional K V] {f : End K V} {μ : K} :\n    f.HasEigenvalue μ ↔ μ ∈ spectrum K f :=\n  hasUnifEigenvalue_iff_mem_spectrum\n\n"}
{"name":"Module.End.HasEigenvalue.of_mem_spectrum","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\na✝ : Membership.mem (spectrum K f) μ\n⊢ f.HasEigenvalue μ","decl":"alias ⟨_, HasEigenvalue.of_mem_spectrum⟩ := hasEigenvalue_iff_mem_spectrum\n\n"}
{"name":"Module.End.eigenspace_div","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Module.End K V\na b : K\nhb : Ne b 0\n⊢ Eq (f.eigenspace (HDiv.hDiv a b)) (LinearMap.ker (HSub.hSub (HSMul.hSMul b f) ((algebraMap K (Module.End K V)) a)))","decl":"theorem eigenspace_div (f : End K V) (a b : K) (hb : b ≠ 0) :\n    eigenspace f (a / b) = LinearMap.ker (b • f - algebraMap K (End K V) a) :=\n  genEigenspace_div f a b hb\n\n"}
{"name":"Module.End.genEigenspace_def","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\n⊢ Eq ((f.genEigenspace μ) ↑k) (LinearMap.ker (HPow.hPow (HSub.hSub f (HSMul.hSMul μ 1)) k))","decl":"@[deprecated genEigenspace_nat (since := \"2024-10-28\")]\nlemma genEigenspace_def (f : End R M) (μ : R) (k : ℕ) :\n    f.genEigenspace μ k = LinearMap.ker ((f - μ • 1) ^ k) :=\n  genEigenspace_nat\n\n"}
{"name":"Module.End.hasGenEigenvector_iff","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nx : M\n⊢ Iff (f.HasGenEigenvector μ k x) (And (Membership.mem ((f.genEigenspace μ) ↑k) x) (Ne x 0))","decl":"lemma hasGenEigenvector_iff {f : End R M} {μ : R} {k : ℕ} {x : M} :\n    f.HasGenEigenvector μ k x ↔ x ∈ f.genEigenspace μ k ∧ x ≠ 0 := Iff.rfl\n\n"}
{"name":"Module.End.hasGenEigenvalue_iff","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\n⊢ Iff (f.HasGenEigenvalue μ k) (Ne ((f.genEigenspace μ) ↑k) Bot.bot)","decl":"lemma hasGenEigenvalue_iff {f : End R M} {μ : R} {k : ℕ} :\n    f.HasGenEigenvalue μ k ↔ f.genEigenspace μ k ≠ ⊥ := Iff.rfl\n\n"}
{"name":"Module.End.genEigenrange_def","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\n⊢ Eq (f.genEigenrange μ ↑k) (LinearMap.range (HPow.hPow (HSub.hSub f (HSMul.hSMul μ 1)) k))","decl":"@[deprecated genEigenrange_nat (since := \"2024-10-28\")]\nlemma genEigenrange_def {f : End R M} {μ : R} {k : ℕ} :\n    f.genEigenrange μ k = LinearMap.range ((f - μ • 1) ^ k) :=\n  genEigenrange_nat\n\n"}
{"name":"Module.End.exp_ne_zero_of_hasGenEigenvalue","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nh : f.HasGenEigenvalue μ k\n⊢ Ne k 0","decl":"/-- The exponent of a generalized eigenvalue is never 0. -/\ntheorem exp_ne_zero_of_hasGenEigenvalue {f : End R M} {μ : R} {k : ℕ}\n    (h : f.HasGenEigenvalue μ k) : k ≠ 0 :=\n  HasUnifEigenvalue.exp_ne_zero h\n\n"}
{"name":"Module.End.iSup_genEigenspace_eq","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\n⊢ Eq (iSup fun k => (f.genEigenspace μ) ↑k) (f.maxGenEigenspace μ)","decl":"lemma iSup_genEigenspace_eq (f : End R M) (μ : R) :\n    ⨆ k : ℕ, (f.genEigenspace μ) k = f.maxGenEigenspace μ := by\n  simp_rw [maxGenEigenspace, genEigenspace_top]\n\n"}
{"name":"Module.End.maxGenEigenspace_def","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\n⊢ Eq (f.maxGenEigenspace μ) (iSup fun k => (f.genEigenspace μ) ↑k)","decl":"@[deprecated iSup_genEigenspace_eq (since := \"2024-10-23\")]\nlemma maxGenEigenspace_def (f : End R M) (μ : R) :\n    f.maxGenEigenspace μ = ⨆ k : ℕ, f.genEigenspace μ k :=\n  (iSup_genEigenspace_eq f μ).symm\n\n"}
{"name":"Module.End.genEigenspace_le_maximal","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\n⊢ LE.le ((f.genEigenspace μ) ↑k) (f.maxGenEigenspace μ)","decl":"theorem genEigenspace_le_maximal (f : End R M) (μ : R) (k : ℕ) :\n    f.genEigenspace μ k ≤ f.maxGenEigenspace μ :=\n  (f.genEigenspace μ).monotone le_top\n\n"}
{"name":"Module.End.mem_maxGenEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nm : M\n⊢ Iff (Membership.mem (f.maxGenEigenspace μ) m) (Exists fun k => Eq ((HPow.hPow (HSub.hSub f (HSMul.hSMul μ 1)) k) m) 0)","decl":"@[simp]\ntheorem mem_maxGenEigenspace (f : End R M) (μ : R) (m : M) :\n    m ∈ f.maxGenEigenspace μ ↔ ∃ k : ℕ, ((f - μ • (1 : End R M)) ^ k) m = 0 :=\n  mem_genEigenspace_top\n\n"}
{"name":"Module.End.maxGenEigenspace_eq","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : Module.End R M\nμ : R\n⊢ Eq (f.maxGenEigenspace μ) ((f.genEigenspace μ) ↑(f.maxGenEigenspaceIndex μ))","decl":"/-- For an endomorphism of a Noetherian module, the maximal eigenspace is always of the form kernel\n`(f - μ • id) ^ k` for some `k`. -/\ntheorem maxGenEigenspace_eq [IsNoetherian R M] (f : End R M) (μ : R) :\n    maxGenEigenspace f μ = f.genEigenspace μ (maxGenEigenspaceIndex f μ) :=\n  genEigenspace_top_eq_maxUnifEigenspaceIndex _ _\n\n"}
{"name":"Module.End.hasGenEigenvalue_of_hasGenEigenvalue_of_le","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk m : Nat\nhm : LE.le k m\nhk : f.HasGenEigenvalue μ k\n⊢ f.HasGenEigenvalue μ m","decl":"/-- A generalized eigenvalue for some exponent `k` is also\n    a generalized eigenvalue for exponents larger than `k`. -/\ntheorem hasGenEigenvalue_of_hasGenEigenvalue_of_le {f : End R M} {μ : R} {k : ℕ}\n    {m : ℕ} (hm : k ≤ m) (hk : f.HasGenEigenvalue μ k) :\n    f.HasGenEigenvalue μ m :=\n  hk.le <| by simpa using hm\n\n"}
{"name":"Module.End.eigenspace_le_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nhk : LT.lt 0 k\n⊢ LE.le (f.eigenspace μ) ((f.genEigenspace μ) ↑k)","decl":"/-- The eigenspace is a subspace of the generalized eigenspace. -/\ntheorem eigenspace_le_genEigenspace {f : End R M} {μ : R} {k : ℕ} (hk : 0 < k) :\n    f.eigenspace μ ≤ f.genEigenspace μ k :=\n  (f.genEigenspace _).monotone <| by simpa using Nat.succ_le_of_lt hk\n\n"}
{"name":"Module.End.hasGenEigenvalue_of_hasEigenvalue","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nhk : LT.lt 0 k\nhμ : f.HasEigenvalue μ\n⊢ f.HasGenEigenvalue μ k","decl":"/-- All eigenvalues are generalized eigenvalues. -/\ntheorem hasGenEigenvalue_of_hasEigenvalue {f : End R M} {μ : R} {k : ℕ} (hk : 0 < k)\n    (hμ : f.HasEigenvalue μ) : f.HasGenEigenvalue μ k :=\n  hμ.lt <| by simpa using hk\n\n"}
{"name":"Module.End.hasEigenvalue_of_hasGenEigenvalue","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nhμ : f.HasGenEigenvalue μ k\n⊢ f.HasEigenvalue μ","decl":"/-- All generalized eigenvalues are eigenvalues. -/\ntheorem hasEigenvalue_of_hasGenEigenvalue {f : End R M} {μ : R} {k : ℕ}\n    (hμ : f.HasGenEigenvalue μ k) : f.HasEigenvalue μ :=\n  hμ.lt zero_lt_one\n\n"}
{"name":"Module.End.hasGenEigenvalue_iff_hasEigenvalue","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nhk : LT.lt 0 k\n⊢ Iff (f.HasGenEigenvalue μ k) (f.HasEigenvalue μ)","decl":"/-- Generalized eigenvalues are actually just eigenvalues. -/\n@[simp]\ntheorem hasGenEigenvalue_iff_hasEigenvalue {f : End R M} {μ : R} {k : ℕ} (hk : 0 < k) :\n    f.HasGenEigenvalue μ k ↔ f.HasEigenvalue μ :=\n  hasUnifEigenvalue_iff_hasUnifEigenvalue_one <| by simpa using hk\n\n"}
{"name":"Module.End.maxGenEigenspace_eq_genEigenspace_finrank","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\n⊢ Eq (f.maxGenEigenspace μ) ((f.genEigenspace μ) ↑(Module.finrank K V))","decl":"theorem maxGenEigenspace_eq_genEigenspace_finrank\n    [FiniteDimensional K V] (f : End K V) (μ : K) :\n    f.maxGenEigenspace μ = f.genEigenspace μ (finrank K V) := by\n  apply le_antisymm _ <| (f.genEigenspace μ).monotone le_top\n  rw [genEigenspace_top_eq_maxUnifEigenspaceIndex]\n  apply genEigenspace_le_genEigenspace_finrank f μ\n\n"}
{"name":"Module.End.mapsTo_maxGenEigenspace_of_comm","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf g : Module.End R M\nh : Commute f g\nμ : R\n⊢ Set.MapsTo ⇑g ↑(f.maxGenEigenspace μ) ↑(f.maxGenEigenspace μ)","decl":"lemma mapsTo_maxGenEigenspace_of_comm {f g : End R M} (h : Commute f g) (μ : R) :\n    MapsTo g ↑(f.maxGenEigenspace μ) ↑(f.maxGenEigenspace μ) :=\n  mapsTo_genEigenspace_of_comm h μ ⊤\n\n"}
{"name":"Module.End.mapsTo_iSup_genEigenspace_of_comm","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf g : Module.End R M\nh : Commute f g\nμ : R\n⊢ Set.MapsTo ⇑g ↑(iSup fun k => (f.genEigenspace μ) ↑k) ↑(iSup fun k => (f.genEigenspace μ) ↑k)","decl":"@[deprecated mapsTo_iSup_genEigenspace_of_comm (since := \"2024-10-23\")]\nlemma mapsTo_iSup_genEigenspace_of_comm {f g : End R M} (h : Commute f g) (μ : R) :\n    MapsTo g ↑(⨆ k : ℕ, f.genEigenspace μ k) ↑(⨆ k : ℕ, f.genEigenspace μ k) := by\n  rw [iSup_genEigenspace_eq]\n  apply mapsTo_maxGenEigenspace_of_comm h\n\n"}
{"name":"Module.End.isNilpotent_restrict_sub_algebraMap","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\nk : Nat\nh : optParam (Set.MapsTo ⇑(HSub.hSub f ((algebraMap R (Module.End R M)) μ)) ↑((f.genEigenspace μ) ↑k) ↑((f.genEigenspace μ) ↑k)) ⋯\n⊢ IsNilpotent (LinearMap.restrict (HSub.hSub f ((algebraMap R (Module.End R M)) μ)) h)","decl":"/-- The restriction of `f - μ • 1` to the `k`-fold generalized `μ`-eigenspace is nilpotent. -/\nlemma isNilpotent_restrict_sub_algebraMap (f : End R M) (μ : R) (k : ℕ)\n    (h : MapsTo (f - algebraMap R (End R M) μ)\n      (f.genEigenspace μ k) (f.genEigenspace μ k) :=\n      mapsTo_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f μ) μ k) :\n    IsNilpotent ((f - algebraMap R (End R M) μ).restrict h) :=\n  isNilpotent_restrict_genEigenspace_nat _ _ _\n\n"}
{"name":"Module.End.isNilpotent_restrict_maxGenEigenspace_sub_algebraMap","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : Module.End R M\nμ : R\nh : optParam (Set.MapsTo ⇑(HSub.hSub f ((algebraMap R (Module.End R M)) μ)) ↑(f.maxGenEigenspace μ) ↑(f.maxGenEigenspace μ)) ⋯\n⊢ IsNilpotent (LinearMap.restrict (HSub.hSub f ((algebraMap R (Module.End R M)) μ)) h)","decl":"/-- The restriction of `f - μ • 1` to the generalized `μ`-eigenspace is nilpotent. -/\nlemma isNilpotent_restrict_maxGenEigenspace_sub_algebraMap [IsNoetherian R M] (f : End R M) (μ : R)\n    (h : MapsTo (f - algebraMap R (End R M) μ)\n      ↑(f.maxGenEigenspace μ) ↑(f.maxGenEigenspace μ) :=\n      mapsTo_maxGenEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f μ) μ) :\n    IsNilpotent ((f - algebraMap R (End R M) μ).restrict h) := by\n  apply isNilpotent_restrict_of_le (q := f.genEigenspace μ (maxUnifEigenspaceIndex f μ))\n    _ (isNilpotent_restrict_genEigenspace_nat f μ (maxUnifEigenspaceIndex f μ))\n  rw [maxGenEigenspace_eq]\n\n"}
{"name":"Module.End.isNilpotent_restrict_iSup_sub_algebraMap","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : Module.End R M\nμ : R\nh : optParam (Set.MapsTo ⇑(HSub.hSub f ((algebraMap R (Module.End R M)) μ)) ↑(iSup fun k => (f.genEigenspace μ) ↑k) ↑(iSup fun k => (f.genEigenspace μ) ↑k)) ⋯\n⊢ IsNilpotent (LinearMap.restrict (HSub.hSub f ((algebraMap R (Module.End R M)) μ)) h)","decl":"set_option linter.deprecated false in\n/-- The restriction of `f - μ • 1` to the generalized `μ`-eigenspace is nilpotent. -/\n@[deprecated isNilpotent_restrict_maxGenEigenspace_sub_algebraMap (since := \"2024-10-23\")]\nlemma isNilpotent_restrict_iSup_sub_algebraMap [IsNoetherian R M] (f : End R M) (μ : R)\n    (h : MapsTo (f - algebraMap R (End R M) μ)\n      ↑(⨆ k : ℕ, f.genEigenspace μ k) ↑(⨆ k : ℕ, f.genEigenspace μ k) :=\n      mapsTo_iSup_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f μ) μ) :\n    IsNilpotent ((f - algebraMap R (End R M) μ).restrict h) := by\n  apply isNilpotent_restrict_of_le (q := f.genEigenspace μ (maxUnifEigenspaceIndex f μ))\n    _ (isNilpotent_restrict_genEigenspace_nat f μ (maxUnifEigenspaceIndex f μ))\n  apply iSup_le\n  intro k\n  apply genEigenspace_le_genEigenspace_maxUnifEigenspaceIndex\n\n"}
{"name":"Module.End.disjoint_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\nμ₁ μ₂ : R\nhμ : Ne μ₁ μ₂\nk l : ENat\n⊢ Disjoint ((f.genEigenspace μ₁) k) ((f.genEigenspace μ₂) l)","decl":"lemma disjoint_genEigenspace [NoZeroSMulDivisors R M]\n    (f : End R M) {μ₁ μ₂ : R} (hμ : μ₁ ≠ μ₂) (k l : ℕ∞) :\n    Disjoint (f.genEigenspace μ₁ k) (f.genEigenspace μ₂ l) := by\n  rw [genEigenspace_eq_iSup_genEigenspace_nat, genEigenspace_eq_iSup_genEigenspace_nat]\n  simp_rw [genEigenspace_directed.disjoint_iSup_left, genEigenspace_directed.disjoint_iSup_right]\n  rintro ⟨k, -⟩ ⟨l, -⟩\n  nontriviality M\n  have := NoZeroSMulDivisors.isReduced R M\n  rw [disjoint_iff]\n  set p := f.genEigenspace μ₁ k ⊓ f.genEigenspace μ₂ l\n  by_contra hp\n  replace hp : Nontrivial p := Submodule.nontrivial_iff_ne_bot.mpr hp\n  let f₁ : End R p := (f - algebraMap R (End R M) μ₁).restrict <| MapsTo.inter_inter\n    (mapsTo_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f μ₁) μ₁ k)\n    (mapsTo_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f μ₁) μ₂ l)\n  let f₂ : End R p := (f - algebraMap R (End R M) μ₂).restrict <| MapsTo.inter_inter\n    (mapsTo_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f μ₂) μ₁ k)\n    (mapsTo_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f μ₂) μ₂ l)\n  have : IsNilpotent (f₂ - f₁) := by\n    apply Commute.isNilpotent_sub (x := f₂) (y := f₁) _\n      (isNilpotent_restrict_of_le inf_le_right _)\n      (isNilpotent_restrict_of_le inf_le_left _)\n    · ext; simp [f₁, f₂, smul_sub, sub_sub, smul_comm μ₁, add_sub_left_comm]\n    apply mapsTo_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f _)\n    apply isNilpotent_restrict_genEigenspace_nat\n    apply mapsTo_genEigenspace_of_comm (Algebra.mul_sub_algebraMap_commutes f _)\n    apply isNilpotent_restrict_genEigenspace_nat\n  have hf₁₂ : f₂ - f₁ = algebraMap R (End R p) (μ₁ - μ₂) := by ext; simp [f₁, f₂, sub_smul]\n  rw [hf₁₂, IsNilpotent.map_iff (NoZeroSMulDivisors.algebraMap_injective R (End R p)),\n    isNilpotent_iff_eq_zero, sub_eq_zero] at this\n  contradiction\n\n"}
{"name":"Module.End.injOn_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\nk : ENat\n⊢ Set.InjOn (fun x => (f.genEigenspace x) k) (setOf fun μ => Ne ((f.genEigenspace μ) k) Bot.bot)","decl":"lemma injOn_genEigenspace [NoZeroSMulDivisors R M] (f : End R M) (k : ℕ∞) :\n    InjOn (f.genEigenspace · k) {μ | f.genEigenspace μ k ≠ ⊥} := by\n  rintro μ₁ _ μ₂ hμ₂ hμ₁₂\n  by_contra contra\n  apply hμ₂\n  simpa only [hμ₁₂, disjoint_self] using f.disjoint_genEigenspace contra k k\n\n"}
{"name":"Module.End.disjoint_iSup_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\nμ₁ μ₂ : R\nhμ : Ne μ₁ μ₂\n⊢ Disjoint (iSup fun k => (f.genEigenspace μ₁) ↑k) (iSup fun k => (f.genEigenspace μ₂) ↑k)","decl":"@[deprecated disjoint_genEigenspace (since := \"2024-10-23\")]\nlemma disjoint_iSup_genEigenspace [NoZeroSMulDivisors R M]\n    (f : End R M) {μ₁ μ₂ : R} (hμ : μ₁ ≠ μ₂) :\n    Disjoint (⨆ k : ℕ, f.genEigenspace μ₁ k) (⨆ k : ℕ, f.genEigenspace μ₂ k) := by\n  simpa only [iSup_genEigenspace_eq] using disjoint_genEigenspace f hμ ⊤ ⊤\n\n"}
{"name":"Module.End.injOn_maxGenEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\n⊢ Set.InjOn (fun x => f.maxGenEigenspace x) (setOf fun μ => Ne (f.maxGenEigenspace μ) Bot.bot)","decl":"lemma injOn_maxGenEigenspace [NoZeroSMulDivisors R M] (f : End R M) :\n    InjOn (f.maxGenEigenspace ·) {μ | f.maxGenEigenspace μ ≠ ⊥} :=\n  injOn_genEigenspace f ⊤\n\n"}
{"name":"Module.End.injOn_iSup_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\n⊢ Set.InjOn (fun x => iSup fun k => (f.genEigenspace x) ↑k) (setOf fun μ => Ne (iSup fun k => (f.genEigenspace μ) ↑k) Bot.bot)","decl":"@[deprecated injOn_genEigenspace (since := \"2024-10-23\")]\nlemma injOn_iSup_genEigenspace [NoZeroSMulDivisors R M] (f : End R M) :\n    InjOn (⨆ k : ℕ, f.genEigenspace · k) {μ | ⨆ k : ℕ, f.genEigenspace μ k ≠ ⊥} := by\n  simp_rw [iSup_genEigenspace_eq]\n  apply injOn_maxGenEigenspace\n\n"}
{"name":"Module.End.independent_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\nk : ENat\n⊢ iSupIndep fun x => (f.genEigenspace x) k","decl":"theorem independent_genEigenspace [NoZeroSMulDivisors R M] (f : End R M) (k : ℕ∞) :\n    iSupIndep (f.genEigenspace · k) := by\n  classical\n  suffices ∀ μ₁ (s : Finset R), μ₁ ∉ s → Disjoint (f.genEigenspace μ₁ k)\n    (s.sup fun μ ↦ f.genEigenspace μ k) by\n    simp_rw [iSupIndep_iff_supIndep_of_injOn (injOn_genEigenspace f k),\n      Finset.supIndep_iff_disjoint_erase]\n    exact fun s μ _ ↦ this _ _ (s.not_mem_erase μ)\n  intro μ₁ s\n  induction' s using Finset.induction_on with μ₂ s _ ih\n  · simp\n  intro hμ₁₂\n  obtain ⟨hμ₁₂ : μ₁ ≠ μ₂, hμ₁ : μ₁ ∉ s⟩ := by rwa [Finset.mem_insert, not_or] at hμ₁₂\n  specialize ih hμ₁\n  rw [Finset.sup_insert, disjoint_iff, Submodule.eq_bot_iff]\n  rintro x ⟨hx, hx'⟩\n  simp only [SetLike.mem_coe] at hx hx'\n  suffices x ∈ genEigenspace f μ₂ k by\n    rw [← Submodule.mem_bot (R := R), ← (f.disjoint_genEigenspace hμ₁₂ k k).eq_bot]\n    exact ⟨hx, this⟩\n  obtain ⟨y, hy, z, hz, rfl⟩ := Submodule.mem_sup.mp hx'; clear hx'\n  let g := f - μ₂ • 1\n  simp_rw [mem_genEigenspace, ← exists_prop] at hy ⊢\n  peel hy with l hlk hl\n  simp only [mem_genEigenspace_nat, LinearMap.mem_ker] at hl\n  have hyz : (g ^ l) (y + z) ∈\n      (f.genEigenspace μ₁ k) ⊓ s.sup fun μ ↦ f.genEigenspace μ k := by\n    refine ⟨f.mapsTo_genEigenspace_of_comm (g := g ^ l) ?_ μ₁ k hx, ?_⟩\n    · exact Algebra.mul_sub_algebraMap_pow_commutes f μ₂ l\n    · rw [SetLike.mem_coe, map_add, hl, zero_add]\n      suffices (s.sup fun μ ↦ f.genEigenspace μ k).map (g ^ l) ≤\n          s.sup fun μ ↦ f.genEigenspace μ k by exact this (Submodule.mem_map_of_mem hz)\n      simp_rw [Finset.sup_eq_iSup, Submodule.map_iSup (ι := R), Submodule.map_iSup (ι := _ ∈ s)]\n      refine iSup₂_mono fun μ _ ↦ ?_\n      rintro - ⟨u, hu, rfl⟩\n      refine f.mapsTo_genEigenspace_of_comm ?_ μ k hu\n      exact Algebra.mul_sub_algebraMap_pow_commutes f μ₂ l\n  rwa [ih.eq_bot, Submodule.mem_bot] at hyz\n\n"}
{"name":"Module.End.independent_maxGenEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\n⊢ iSupIndep f.maxGenEigenspace","decl":"theorem independent_maxGenEigenspace [NoZeroSMulDivisors R M] (f : End R M) :\n    iSupIndep f.maxGenEigenspace := by\n  apply independent_genEigenspace\n\n"}
{"name":"Module.End.independent_iSup_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\n⊢ iSupIndep fun μ => iSup fun k => (f.genEigenspace μ) ↑k","decl":"@[deprecated independent_genEigenspace (since := \"2024-10-23\")]\ntheorem independent_iSup_genEigenspace [NoZeroSMulDivisors R M] (f : End R M) :\n    iSupIndep (fun μ ↦ ⨆ k : ℕ, f.genEigenspace μ k) := by\n  simp_rw [iSup_genEigenspace_eq]\n  apply independent_maxGenEigenspace\n\n"}
{"name":"Module.End.eigenspaces_iSupIndep","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\n⊢ iSupIndep f.eigenspace","decl":"/-- The eigenspaces of a linear operator form an independent family of subspaces of `M`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem eigenspaces_iSupIndep [NoZeroSMulDivisors R M] (f : End R M) :\n    iSupIndep f.eigenspace :=\n  (f.independent_genEigenspace 1).mono fun _ ↦ le_rfl\n\n"}
{"name":"Module.End.eigenspaces_independent","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\n⊢ iSupIndep f.eigenspace","decl":"@[deprecated (since := \"2024-11-24\")] alias eigenspaces_independent := eigenspaces_iSupIndep\n\n"}
{"name":"Module.End.eigenvectors_linearIndependent'","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_1\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\nμ : ι → R\nhμ : Function.Injective μ\nv : ι → M\nh_eigenvec : ∀ (i : ι), f.HasEigenvector (μ i) (v i)\n⊢ LinearIndependent R v","decl":"/-- Eigenvectors corresponding to distinct eigenvalues of a linear operator are linearly\n    independent. -/\ntheorem eigenvectors_linearIndependent' {ι : Type*} [NoZeroSMulDivisors R M]\n    (f : End R M) (μ : ι → R) (hμ : Function.Injective μ) (v : ι → M)\n    (h_eigenvec : ∀ i, f.HasEigenvector (μ i) (v i)) : LinearIndependent R v :=\n  f.eigenspaces_iSupIndep.comp hμ |>.linearIndependent _\n    (fun i ↦ h_eigenvec i |>.left) (fun i ↦ h_eigenvec i |>.right)\n\n"}
{"name":"Module.End.eigenvectors_linearIndependent","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nf : Module.End R M\nμs : Set R\nxs : ↑μs → M\nh_eigenvec : ∀ (μ : ↑μs), f.HasEigenvector (↑μ) (xs μ)\n⊢ LinearIndependent R xs","decl":"/-- Eigenvectors corresponding to distinct eigenvalues of a linear operator are linearly\n    independent. (Lemma 5.10 of [axler2015])\n\n    We use the eigenvalues as indexing set to ensure that there is only one eigenvector for each\n    eigenvalue in the image of `xs`.\n    See `Module.End.eigenvectors_linearIndependent'` for an indexed variant. -/\ntheorem eigenvectors_linearIndependent [NoZeroSMulDivisors R M]\n    (f : End R M) (μs : Set R) (xs : μs → M)\n    (h_eigenvec : ∀ μ : μs, f.HasEigenvector μ (xs μ)) : LinearIndependent R xs :=\n  f.eigenvectors_linearIndependent' (fun μ : μs ↦ μ) Subtype.coe_injective _ h_eigenvec\n\n"}
{"name":"Module.End.genEigenspace_restrict","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nk : ENat\nμ : R\nhfp : ∀ (x : M), Membership.mem p x → Membership.mem p (f x)\n⊢ Eq ((Module.End.genEigenspace (LinearMap.restrict f hfp) μ) k) (Submodule.comap p.subtype ((f.genEigenspace μ) k))","decl":"/-- If `f` maps a subspace `p` into itself, then the generalized eigenspace of the restriction\n    of `f` to `p` is the part of the generalized eigenspace of `f` that lies in `p`. -/\ntheorem genEigenspace_restrict (f : End R M) (p : Submodule R M) (k : ℕ∞) (μ : R)\n    (hfp : ∀ x : M, x ∈ p → f x ∈ p) :\n    genEigenspace (LinearMap.restrict f hfp) μ k =\n      Submodule.comap p.subtype (f.genEigenspace μ k) := by\n  ext x\n  suffices ∀ l : ℕ, genEigenspace (LinearMap.restrict f hfp) μ l =\n      Submodule.comap p.subtype (f.genEigenspace μ l) by\n    simp_rw [mem_genEigenspace, ← mem_genEigenspace_nat, this,\n      Submodule.mem_comap, mem_genEigenspace (k := k), mem_genEigenspace_nat]\n  intro l\n  simp only [genEigenspace_nat, OrderHom.coe_mk, ← LinearMap.ker_comp]\n  induction' l with l ih\n  · rw [pow_zero, pow_zero, LinearMap.one_eq_id]\n    apply (Submodule.ker_subtype _).symm\n  · erw [pow_succ, pow_succ, LinearMap.ker_comp, LinearMap.ker_comp, ih, ← LinearMap.ker_comp,\n      LinearMap.comp_assoc]\n\n"}
{"name":"Submodule.inf_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nk : ENat\nμ : R\nhfp : ∀ (x : M), Membership.mem p x → Membership.mem p (f x)\n⊢ Eq (Min.min p ((f.genEigenspace μ) k)) (Submodule.map p.subtype ((Module.End.genEigenspace (LinearMap.restrict f hfp) μ) k))","decl":"lemma _root_.Submodule.inf_genEigenspace (f : End R M) (p : Submodule R M) {k : ℕ∞} {μ : R}\n    (hfp : ∀ x : M, x ∈ p → f x ∈ p) :\n    p ⊓ f.genEigenspace μ k =\n      (genEigenspace (LinearMap.restrict f hfp) μ k).map p.subtype := by\n  rw [f.genEigenspace_restrict _ _ _ hfp, Submodule.map_comap_eq, Submodule.range_subtype]\n\n"}
{"name":"Module.End.mapsTo_restrict_maxGenEigenspace_restrict_of_mapsTo","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : Submodule R M\nf g : Module.End R M\nhf : Set.MapsTo ⇑f ↑p ↑p\nhg : Set.MapsTo ⇑g ↑p ↑p\nμ₁ μ₂ : R\nh : Set.MapsTo ⇑f ↑(g.maxGenEigenspace μ₁) ↑(g.maxGenEigenspace μ₂)\n⊢ Set.MapsTo ⇑(LinearMap.restrict f hf) ↑(Module.End.maxGenEigenspace (LinearMap.restrict g hg) μ₁) ↑(Module.End.maxGenEigenspace (LinearMap.restrict g hg) μ₂)","decl":"lemma mapsTo_restrict_maxGenEigenspace_restrict_of_mapsTo\n    {p : Submodule R M} (f g : End R M) (hf : MapsTo f p p) (hg : MapsTo g p p) {μ₁ μ₂ : R}\n    (h : MapsTo f (g.maxGenEigenspace μ₁) (g.maxGenEigenspace μ₂)) :\n    MapsTo (f.restrict hf)\n      (maxGenEigenspace (g.restrict hg) μ₁)\n      (maxGenEigenspace (g.restrict hg) μ₂) := by\n  intro x hx\n  simp_rw [SetLike.mem_coe, mem_maxGenEigenspace, ← LinearMap.restrict_smul_one _,\n    LinearMap.restrict_sub _, LinearMap.pow_restrict _, LinearMap.restrict_apply,\n    Submodule.mk_eq_zero, ← mem_maxGenEigenspace] at hx ⊢\n  exact h hx\n\n"}
{"name":"Module.End.eigenspace_restrict_le_eigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nhfp : ∀ (x : M), Membership.mem p x → Membership.mem p (f x)\nμ : R\n⊢ LE.le (Submodule.map p.subtype (Module.End.eigenspace (LinearMap.restrict f hfp) μ)) (f.eigenspace μ)","decl":"/-- If `p` is an invariant submodule of an endomorphism `f`, then the `μ`-eigenspace of the\nrestriction of `f` to `p` is a submodule of the `μ`-eigenspace of `f`. -/\ntheorem eigenspace_restrict_le_eigenspace (f : End R M) {p : Submodule R M} (hfp : ∀ x ∈ p, f x ∈ p)\n    (μ : R) : (eigenspace (f.restrict hfp) μ).map p.subtype ≤ f.eigenspace μ := by\n  rintro a ⟨x, hx, rfl⟩\n  simp only [SetLike.mem_coe, mem_eigenspace_iff, LinearMap.restrict_apply] at hx ⊢\n  exact congr_arg Subtype.val hx\n\n"}
{"name":"Module.End.generalized_eigenvec_disjoint_range_ker","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\n⊢ Disjoint (f.genEigenrange μ ↑(Module.finrank K V)) ((f.genEigenspace μ) ↑(Module.finrank K V))","decl":"/-- Generalized eigenrange and generalized eigenspace for exponent `finrank K V` are disjoint. -/\ntheorem generalized_eigenvec_disjoint_range_ker [FiniteDimensional K V] (f : End K V) (μ : K) :\n    Disjoint (f.genEigenrange μ (finrank K V))\n      (f.genEigenspace μ (finrank K V)) := by\n  have h :=\n    calc\n      Submodule.comap ((f - μ • 1) ^ finrank K V)\n        (f.genEigenspace μ (finrank K V)) =\n          LinearMap.ker ((f - algebraMap _ _ μ) ^ finrank K V *\n            (f - algebraMap K (End K V) μ) ^ finrank K V) := by\n              rw [genEigenspace_nat, ← LinearMap.ker_comp]; rfl\n      _ = f.genEigenspace μ (finrank K V + finrank K V : ℕ) := by\n              simp_rw [← pow_add, genEigenspace_nat]; rfl\n      _ = f.genEigenspace μ (finrank K V) := by\n              rw [genEigenspace_eq_genEigenspace_finrank_of_le]; omega\n  rw [disjoint_iff_inf_le, genEigenrange_nat, LinearMap.range_eq_map,\n    Submodule.map_inf_eq_map_inf_comap, top_inf_eq, h, genEigenspace_nat]\n  apply Submodule.map_comap_le\n\n"}
{"name":"Module.End.eigenspace_restrict_eq_bot","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nhfp : ∀ (x : M), Membership.mem p x → Membership.mem p (f x)\nμ : R\nhμp : Disjoint (f.eigenspace μ) p\n⊢ Eq (Module.End.eigenspace (LinearMap.restrict f hfp) μ) Bot.bot","decl":"/-- If an invariant subspace `p` of an endomorphism `f` is disjoint from the `μ`-eigenspace of `f`,\nthen the restriction of `f` to `p` has trivial `μ`-eigenspace. -/\ntheorem eigenspace_restrict_eq_bot {f : End R M} {p : Submodule R M} (hfp : ∀ x ∈ p, f x ∈ p)\n    {μ : R} (hμp : Disjoint (f.eigenspace μ) p) : eigenspace (f.restrict hfp) μ = ⊥ := by\n  rw [eq_bot_iff]\n  intro x hx\n  simpa using hμp.le_bot ⟨eigenspace_restrict_le_eigenspace f hfp μ ⟨x, hx, rfl⟩, x.prop⟩\n\n"}
{"name":"Module.End.pos_finrank_genEigenspace_of_hasEigenvalue","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nk : Nat\nμ : K\nhx : f.HasEigenvalue μ\nhk : LT.lt 0 k\n⊢ LT.lt 0 (Module.finrank K (Subtype fun x => Membership.mem ((f.genEigenspace μ) ↑k) x))","decl":"/-- The generalized eigenspace of an eigenvalue has positive dimension for positive exponents. -/\ntheorem pos_finrank_genEigenspace_of_hasEigenvalue [FiniteDimensional K V] {f : End K V}\n    {k : ℕ} {μ : K} (hx : f.HasEigenvalue μ) (hk : 0 < k) :\n    0 < finrank K (f.genEigenspace μ k) :=\n  calc\n    0 = finrank K (⊥ : Submodule K V) := by rw [finrank_bot]\n    _ < finrank K (f.eigenspace μ) := Submodule.finrank_lt_finrank_of_lt (bot_lt_iff_ne_bot.2 hx)\n    _ ≤ finrank K (f.genEigenspace μ k) :=\n      Submodule.finrank_mono ((f.genEigenspace μ).monotone (by simpa using Nat.succ_le_of_lt hk))\n\n"}
{"name":"Module.End.map_genEigenrange_le","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"K : Type v\nV : Type w\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Module.End K V\nμ : K\nn : Nat\n⊢ LE.le (Submodule.map f (f.genEigenrange μ ↑n)) (f.genEigenrange μ ↑n)","decl":"/-- A linear map maps a generalized eigenrange into itself. -/\ntheorem map_genEigenrange_le {f : End K V} {μ : K} {n : ℕ} :\n    Submodule.map f (f.genEigenrange μ n) ≤ f.genEigenrange μ n :=\n  calc\n    Submodule.map f (f.genEigenrange μ n) =\n      LinearMap.range (f * (f - algebraMap _ _ μ) ^ n) := by\n        rw [genEigenrange_nat]; exact (LinearMap.range_comp _ _).symm\n    _ = LinearMap.range ((f - algebraMap _ _ μ) ^ n * f) := by\n        rw [Algebra.mul_sub_algebraMap_pow_commutes]\n    _ = Submodule.map ((f - algebraMap _ _ μ) ^ n) (LinearMap.range f) := LinearMap.range_comp _ _\n    _ ≤ f.genEigenrange μ n := by rw [genEigenrange_nat]; apply LinearMap.map_le_range\n\n"}
{"name":"Module.End.genEigenspace_le_smul","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ t : R\nk : ENat\n⊢ LE.le ((f.genEigenspace μ) k) (((HSMul.hSMul t f).genEigenspace (HMul.hMul t μ)) k)","decl":"lemma genEigenspace_le_smul (f : Module.End R M) (μ t : R) (k : ℕ∞) :\n    (f.genEigenspace μ k) ≤ (t • f).genEigenspace (t * μ) k := by\n  intro m hm\n  simp_rw [mem_genEigenspace, ← exists_prop, LinearMap.mem_ker] at hm ⊢\n  peel hm with l hlk hl\n  rw [mul_smul, ← smul_sub, smul_pow, LinearMap.smul_apply, hl, smul_zero]\n\n"}
{"name":"Module.End.iSup_genEigenspace_le_smul","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ t : R\n⊢ LE.le (iSup fun k => (f.genEigenspace μ) ↑k) (iSup fun k => ((HSMul.hSMul t f).genEigenspace (HMul.hMul t μ)) ↑k)","decl":"@[deprecated genEigenspace_le_smul (since := \"2024-10-23\")]\nlemma iSup_genEigenspace_le_smul (f : Module.End R M) (μ t : R) :\n    (⨆ k : ℕ, f.genEigenspace μ k) ≤ ⨆ k : ℕ, (t • f).genEigenspace (t * μ) k := by\n  rw [iSup_genEigenspace_eq, iSup_genEigenspace_eq]\n  apply genEigenspace_le_smul\n\n"}
{"name":"Module.End.genEigenspace_inf_le_add","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf₁ f₂ : Module.End R M\nμ₁ μ₂ : R\nk₁ k₂ : ENat\nh : Commute f₁ f₂\n⊢ LE.le (Min.min ((f₁.genEigenspace μ₁) k₁) ((f₂.genEigenspace μ₂) k₂)) (((HAdd.hAdd f₁ f₂).genEigenspace (HAdd.hAdd μ₁ μ₂)) (HAdd.hAdd k₁ k₂))","decl":"lemma genEigenspace_inf_le_add\n    (f₁ f₂ : End R M) (μ₁ μ₂ : R) (k₁ k₂ : ℕ∞) (h : Commute f₁ f₂) :\n    (f₁.genEigenspace μ₁ k₁) ⊓ (f₂.genEigenspace μ₂ k₂) ≤\n    (f₁ + f₂).genEigenspace (μ₁ + μ₂) (k₁ + k₂) := by\n  intro m hm\n  simp only [Submodule.mem_inf, mem_genEigenspace, LinearMap.mem_ker] at hm ⊢\n  obtain ⟨⟨l₁, hlk₁, hl₁⟩, ⟨l₂, hlk₂, hl₂⟩⟩ := hm\n  use l₁ + l₂\n  have : f₁ + f₂ - (μ₁ + μ₂) • 1 = (f₁ - μ₁ • 1) + (f₂ - μ₂ • 1) := by\n    rw [add_smul]; exact add_sub_add_comm f₁ f₂ (μ₁ • 1) (μ₂ • 1)\n  replace h : Commute (f₁ - μ₁ • 1) (f₂ - μ₂ • 1) :=\n    (h.sub_right <| Algebra.commute_algebraMap_right μ₂ f₁).sub_left\n      (Algebra.commute_algebraMap_left μ₁ _)\n  rw [this, h.add_pow', LinearMap.coeFn_sum, Finset.sum_apply]\n  constructor\n  · simpa only [Nat.cast_add] using add_le_add hlk₁ hlk₂\n  refine Finset.sum_eq_zero fun ⟨i, j⟩ hij ↦ ?_\n  suffices (((f₁ - μ₁ • 1) ^ i) * ((f₂ - μ₂ • 1) ^ j)) m = 0 by\n    rw [LinearMap.smul_apply, this, smul_zero]\n  rw [Finset.mem_antidiagonal] at hij\n  obtain hi|hj : l₁ ≤ i ∨ l₂ ≤ j := by omega\n  · rw [(h.pow_pow i j).eq, LinearMap.mul_apply, LinearMap.pow_map_zero_of_le hi hl₁,\n      LinearMap.map_zero]\n  · rw [LinearMap.mul_apply, LinearMap.pow_map_zero_of_le hj hl₂, LinearMap.map_zero]\n\n"}
{"name":"Module.End.iSup_genEigenspace_inf_le_add","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf₁ f₂ : Module.End R M\nμ₁ μ₂ : R\nh : Commute f₁ f₂\n⊢ LE.le (Min.min (iSup fun k => (f₁.genEigenspace μ₁) ↑k) (iSup fun k => (f₂.genEigenspace μ₂) ↑k)) (iSup fun k => ((HAdd.hAdd f₁ f₂).genEigenspace (HAdd.hAdd μ₁ μ₂)) ↑k)","decl":"@[deprecated genEigenspace_inf_le_add (since := \"2024-10-23\")]\nlemma iSup_genEigenspace_inf_le_add\n    (f₁ f₂ : End R M) (μ₁ μ₂ : R) (h : Commute f₁ f₂) :\n    (⨆ k : ℕ, f₁.genEigenspace μ₁ k) ⊓ (⨆ k : ℕ, f₂.genEigenspace μ₂ k) ≤\n    ⨆ k : ℕ, (f₁ + f₂).genEigenspace (μ₁ + μ₂) k := by\n  simp_rw [iSup_genEigenspace_eq]\n  apply genEigenspace_inf_le_add\n  assumption\n\n"}
{"name":"Module.End.map_smul_of_iInf_genEigenspace_ne_bot","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : NoZeroSMulDivisors R M\nL : Type u_1\nF : Type u_2\ninst✝² : SMul R L\ninst✝¹ : FunLike F L (Module.End R M)\ninst✝ : MulActionHomClass F R L (Module.End R M)\nf : F\nμ : L → R\nk : ENat\nh_ne : Ne (iInf fun x => ((f x).genEigenspace (μ x)) k) Bot.bot\nt : R\nx : L\n⊢ Eq (μ (HSMul.hSMul t x)) (HSMul.hSMul t (μ x))","decl":"lemma map_smul_of_iInf_genEigenspace_ne_bot [NoZeroSMulDivisors R M]\n    {L F : Type*} [SMul R L] [FunLike F L (End R M)] [MulActionHomClass F R L (End R M)] (f : F)\n    (μ : L → R) (k : ℕ∞) (h_ne : ⨅ x, (f x).genEigenspace (μ x) k ≠ ⊥)\n    (t : R) (x : L) :\n    μ (t • x) = t • μ x := by\n  by_contra contra\n  let g : L → Submodule R M := fun x ↦ (f x).genEigenspace (μ x) k\n  have : ⨅ x, g x ≤ g x ⊓ g (t • x) := le_inf_iff.mpr ⟨iInf_le g x, iInf_le g (t • x)⟩\n  refine h_ne <| eq_bot_iff.mpr (le_trans this (disjoint_iff_inf_le.mp ?_))\n  apply Disjoint.mono_left (genEigenspace_le_smul (f x) (μ x) t k)\n  simp only [g, map_smul]\n  exact disjoint_genEigenspace (t • f x) (Ne.symm contra) k k\n\n"}
{"name":"Module.End.map_smul_of_iInf_iSup_genEigenspace_ne_bot","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : NoZeroSMulDivisors R M\nL : Type u_1\nF : Type u_2\ninst✝² : SMul R L\ninst✝¹ : FunLike F L (Module.End R M)\ninst✝ : MulActionHomClass F R L (Module.End R M)\nf : F\nμ : L → R\nh_ne : Ne (iInf fun x => iSup fun k => ((f x).genEigenspace (μ x)) ↑k) Bot.bot\nt : R\nx : L\n⊢ Eq (μ (HSMul.hSMul t x)) (HSMul.hSMul t (μ x))","decl":"@[deprecated map_smul_of_iInf_genEigenspace_ne_bot (since := \"2024-10-23\")]\nlemma map_smul_of_iInf_iSup_genEigenspace_ne_bot [NoZeroSMulDivisors R M]\n    {L F : Type*} [SMul R L] [FunLike F L (End R M)] [MulActionHomClass F R L (End R M)] (f : F)\n    (μ : L → R) (h_ne : ⨅ x, ⨆ k : ℕ, (f x).genEigenspace (μ x) k ≠ ⊥)\n    (t : R) (x : L) :\n    μ (t • x) = t • μ x := by\n  simp_rw [iSup_genEigenspace_eq] at h_ne\n  apply map_smul_of_iInf_genEigenspace_ne_bot f μ ⊤ h_ne t x\n\n"}
{"name":"Module.End.map_add_of_iInf_genEigenspace_ne_bot_of_commute","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : NoZeroSMulDivisors R M\nL : Type u_1\nF : Type u_2\ninst✝² : Add L\ninst✝¹ : FunLike F L (Module.End R M)\ninst✝ : AddHomClass F L (Module.End R M)\nf : F\nμ : L → R\nk : ENat\nh_ne : Ne (iInf fun x => ((f x).genEigenspace (μ x)) k) Bot.bot\nh : ∀ (x y : L), Commute (f x) (f y)\nx y : L\n⊢ Eq (μ (HAdd.hAdd x y)) (HAdd.hAdd (μ x) (μ y))","decl":"lemma map_add_of_iInf_genEigenspace_ne_bot_of_commute [NoZeroSMulDivisors R M]\n    {L F : Type*} [Add L] [FunLike F L (End R M)] [AddHomClass F L (End R M)] (f : F)\n    (μ : L → R) (k : ℕ∞) (h_ne : ⨅ x, (f x).genEigenspace (μ x) k ≠ ⊥)\n    (h : ∀ x y, Commute (f x) (f y)) (x y : L) :\n    μ (x + y) = μ x + μ y := by\n  by_contra contra\n  let g : L → Submodule R M := fun x ↦ (f x).genEigenspace (μ x) k\n  have : ⨅ x, g x ≤ (g x ⊓ g y) ⊓ g (x + y) :=\n    le_inf_iff.mpr ⟨le_inf_iff.mpr ⟨iInf_le g x, iInf_le g y⟩, iInf_le g (x + y)⟩\n  refine h_ne <| eq_bot_iff.mpr (le_trans this (disjoint_iff_inf_le.mp ?_))\n  apply Disjoint.mono_left (genEigenspace_inf_le_add (f x) (f y) (μ x) (μ y) k k (h x y))\n  simp only [g, map_add]\n  exact disjoint_genEigenspace (f x + f y) (Ne.symm contra) _ k\n\n"}
{"name":"Module.End.map_add_of_iInf_iSup_genEigenspace_ne_bot_of_commute","module":"Mathlib.LinearAlgebra.Eigenspace.Basic","initialProofState":"R : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : NoZeroSMulDivisors R M\nL : Type u_1\nF : Type u_2\ninst✝² : Add L\ninst✝¹ : FunLike F L (Module.End R M)\ninst✝ : AddHomClass F L (Module.End R M)\nf : F\nμ : L → R\nh_ne : Ne (iInf fun x => iSup fun k => ((f x).genEigenspace (μ x)) ↑k) Bot.bot\nh : ∀ (x y : L), Commute (f x) (f y)\nx y : L\n⊢ Eq (μ (HAdd.hAdd x y)) (HAdd.hAdd (μ x) (μ y))","decl":"@[deprecated map_add_of_iInf_genEigenspace_ne_bot_of_commute (since := \"2024-10-23\")]\nlemma map_add_of_iInf_iSup_genEigenspace_ne_bot_of_commute [NoZeroSMulDivisors R M]\n    {L F : Type*} [Add L] [FunLike F L (End R M)] [AddHomClass F L (End R M)] (f : F)\n    (μ : L → R) (h_ne : ⨅ x, ⨆ k : ℕ, (f x).genEigenspace (μ x) k ≠ ⊥)\n    (h : ∀ x y, Commute (f x) (f y)) (x y : L) :\n    μ (x + y) = μ x + μ y := by\n  simp_rw [iSup_genEigenspace_eq] at h_ne\n  apply map_add_of_iInf_genEigenspace_ne_bot_of_commute f μ ⊤ h_ne h x y\n\n"}
