{"name":"FractionalIdeal.isFractional","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ IsFractional S ↑I","decl":"protected theorem isFractional (I : FractionalIdeal S P) : IsFractional S (I : Submodule R P) :=\n  I.prop\n\n"}
{"name":"FractionalIdeal.den_mul_self_eq_num","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Eq (HSMul.hSMul I.den ↑I) (Submodule.map (Algebra.linearMap R P) I.num)","decl":"theorem den_mul_self_eq_num (I : FractionalIdeal S P) :\n    I.den • (I : Submodule R P) = Submodule.map (Algebra.linearMap R P) I.num := by\n  rw [den, num, Submodule.map_comap_eq]\n  refine (inf_of_le_right ?_).symm\n  rintro _ ⟨a, ha, rfl⟩\n  exact I.2.choose_spec.2 a ha\n\n"}
{"name":"FractionalIdeal.mem_coe","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\nx : P\n⊢ Iff (Membership.mem (↑I) x) (Membership.mem I x)","decl":"@[simp]\ntheorem mem_coe {I : FractionalIdeal S P} {x : P} : x ∈ (I : Submodule R P) ↔ x ∈ I :=\n  Iff.rfl\n\n"}
{"name":"FractionalIdeal.ext_iff","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Iff (Eq I J) (∀ (x : P), Iff (Membership.mem I x) (Membership.mem J x))","decl":"@[ext]\ntheorem ext {I J : FractionalIdeal S P} : (∀ x, x ∈ I ↔ x ∈ J) → I = J :=\n  SetLike.ext\n\n"}
{"name":"FractionalIdeal.ext","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\na✝ : ∀ (x : P), Iff (Membership.mem I x) (Membership.mem J x)\n⊢ Eq I J","decl":"@[ext]\ntheorem ext {I J : FractionalIdeal S P} : (∀ x, x ∈ I ↔ x ∈ J) → I = J :=\n  SetLike.ext\n\n"}
{"name":"FractionalIdeal.equivNum_apply","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝³ : CommRing P\ninst✝² : Algebra R P\ninst✝¹ : Nontrivial P\ninst✝ : NoZeroSMulDivisors R P\nI : FractionalIdeal S P\nh_nz : Ne (↑I.den) 0\nx : Subtype fun x => Membership.mem I x\n⊢ Eq ((algebraMap R P) ↑((FractionalIdeal.equivNum h_nz) x)) (HSMul.hSMul I.den ↑x)","decl":"@[simp]\n theorem equivNum_apply [Nontrivial P] [NoZeroSMulDivisors R P] {I : FractionalIdeal S P}\n    (h_nz : (I.den : R) ≠ 0) (x : I) :\n    algebraMap R P (equivNum h_nz x) = I.den • x := by\n  change Algebra.linearMap R P _ = _\n  rw [equivNum, LinearEquiv.trans_apply, LinearEquiv.ofBijective_apply, LinearMap.restrict_apply,\n    Submodule.map_equivMapOfInjective_symm_apply, Subtype.coe_mk,\n    DistribMulAction.toLinearMap_apply]\n\n"}
{"name":"FractionalIdeal.coe_copy","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\np : FractionalIdeal S P\ns : Set P\nhs : Eq s ↑p\n⊢ Eq (↑(p.copy s hs)) s","decl":"@[simp]\ntheorem coe_copy (p : FractionalIdeal S P) (s : Set P) (hs : s = ↑p) : ↑(p.copy s hs) = s :=\n  rfl\n\n"}
{"name":"FractionalIdeal.coe_eq","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\np : FractionalIdeal S P\ns : Set P\nhs : Eq s ↑p\n⊢ Eq (p.copy s hs) p","decl":"theorem coe_eq (p : FractionalIdeal S P) (s : Set P) (hs : s = ↑p) : p.copy s hs = p :=\n  SetLike.coe_injective hs\n\n"}
{"name":"FractionalIdeal.zero_mem","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Membership.mem I 0","decl":"lemma zero_mem (I : FractionalIdeal S P) : 0 ∈ I := I.coeToSubmodule.zero_mem\n\n-- Porting note: this seems to be needed a lot more than in Lean 3\n"}
{"name":"FractionalIdeal.val_eq_coe","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Eq ↑I ↑I","decl":"@[simp]\ntheorem val_eq_coe (I : FractionalIdeal S P) : I.val = I :=\n  rfl\n\n-- Porting note: had to rephrase this to make it clear to `simp` what was going on.\n"}
{"name":"FractionalIdeal.coe_mk","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Submodule R P\nhI : IsFractional S I\n⊢ Eq (↑⟨I, hI⟩) I","decl":"@[simp, norm_cast]\ntheorem coe_mk (I : Submodule R P) (hI : IsFractional S I) :\n    coeToSubmodule ⟨I, hI⟩ = I :=\n  rfl\n\n"}
{"name":"FractionalIdeal.coeToSet_coeToSubmodule","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Eq ↑↑I ↑I","decl":"theorem coeToSet_coeToSubmodule (I : FractionalIdeal S P) :\n    ((I : Submodule R P) : Set P) = I :=\n  rfl\n\n"}
{"name":"FractionalIdeal.coeToSubmodule_injective","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\n⊢ Function.Injective fun I => ↑I","decl":"theorem coeToSubmodule_injective :\n    Function.Injective (fun (I : FractionalIdeal S P) ↦ (I : Submodule R P)) :=\n  Subtype.coe_injective\n\n"}
{"name":"FractionalIdeal.coeToSubmodule_inj","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Iff (Eq ↑I ↑J) (Eq I J)","decl":"theorem coeToSubmodule_inj {I J : FractionalIdeal S P} : (I : Submodule R P) = J ↔ I = J :=\n  coeToSubmodule_injective.eq_iff\n\n"}
{"name":"FractionalIdeal.isFractional_of_le_one","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Submodule R P\nh : LE.le I 1\n⊢ IsFractional S I","decl":"theorem isFractional_of_le_one (I : Submodule R P) (h : I ≤ 1) : IsFractional S I := by\n  use 1, S.one_mem\n  intro b hb\n  rw [one_smul]\n  obtain ⟨b', b'_mem, rfl⟩ := mem_one.mp (h hb)\n  exact Set.mem_range_self b'\n\n"}
{"name":"FractionalIdeal.isFractional_of_le","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Submodule R P\nJ : FractionalIdeal S P\nhIJ : LE.le I ↑J\n⊢ IsFractional S I","decl":"theorem isFractional_of_le {I : Submodule R P} {J : FractionalIdeal S P} (hIJ : I ≤ J) :\n    IsFractional S I := by\n  obtain ⟨a, a_mem, ha⟩ := J.isFractional\n  use a, a_mem\n  intro b b_mem\n  exact ha b (hIJ b_mem)\n\n"}
{"name":"FractionalIdeal.coe_coeIdeal","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Ideal R\n⊢ Eq (↑↑I) (IsLocalization.coeSubmodule P I)","decl":"@[simp, norm_cast]\ntheorem coe_coeIdeal (I : Ideal R) :\n    ((I : FractionalIdeal S P) : Submodule R P) = coeSubmodule P I :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mem_coeIdeal","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nx : P\nI : Ideal R\n⊢ Iff (Membership.mem (↑I) x) (Exists fun x' => And (Membership.mem I x') (Eq ((algebraMap R P) x') x))","decl":"@[simp]\ntheorem mem_coeIdeal {x : P} {I : Ideal R} :\n    x ∈ (I : FractionalIdeal S P) ↔ ∃ x', x' ∈ I ∧ algebraMap R P x' = x :=\n  mem_coeSubmodule _ _\n\n"}
{"name":"FractionalIdeal.mem_coeIdeal_of_mem","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nx : R\nI : Ideal R\nhx : Membership.mem I x\n⊢ Membership.mem (↑I) ((algebraMap R P) x)","decl":"theorem mem_coeIdeal_of_mem {x : R} {I : Ideal R} (hx : x ∈ I) :\n    algebraMap R P x ∈ (I : FractionalIdeal S P) :=\n  (mem_coeIdeal S).mpr ⟨x, hx, rfl⟩\n\n"}
{"name":"FractionalIdeal.coeIdeal_le_coeIdeal'","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nh : LE.le S (nonZeroDivisors R)\nI J : Ideal R\n⊢ Iff (LE.le ↑I ↑J) (LE.le I J)","decl":"theorem coeIdeal_le_coeIdeal' [IsLocalization S P] (h : S ≤ nonZeroDivisors R) {I J : Ideal R} :\n    (I : FractionalIdeal S P) ≤ J ↔ I ≤ J :=\n  coeSubmodule_le_coeSubmodule h\n\n"}
{"name":"FractionalIdeal.coeIdeal_le_coeIdeal","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI J : Ideal R\n⊢ Iff (LE.le ↑I ↑J) (LE.le I J)","decl":"@[simp]\ntheorem coeIdeal_le_coeIdeal (K : Type*) [CommRing K] [Algebra R K] [IsFractionRing R K]\n    {I J : Ideal R} : (I : FractionalIdeal R⁰ K) ≤ J ↔ I ≤ J :=\n  IsFractionRing.coeSubmodule_le_coeSubmodule\n\n"}
{"name":"FractionalIdeal.mem_zero_iff","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nx : P\n⊢ Iff (Membership.mem 0 x) (Eq x 0)","decl":"@[simp]\ntheorem mem_zero_iff {x : P} : x ∈ (0 : FractionalIdeal S P) ↔ x = 0 :=\n  ⟨fun ⟨x', x'_mem_zero, x'_eq_x⟩ => by\n    have x'_eq_zero : x' = 0 := x'_mem_zero\n    simp [x'_eq_x.symm, x'_eq_zero], fun hx => ⟨0, rfl, by simp [hx]⟩⟩\n\n"}
{"name":"FractionalIdeal.coe_zero","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\n⊢ Eq (↑0) Bot.bot","decl":"@[simp, norm_cast]\ntheorem coe_zero : ↑(0 : FractionalIdeal S P) = (⊥ : Submodule R P) :=\n  Submodule.ext fun _ => mem_zero_iff S\n\n"}
{"name":"FractionalIdeal.coeIdeal_bot","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\n⊢ Eq (↑Bot.bot) 0","decl":"@[simp, norm_cast]\ntheorem coeIdeal_bot : ((⊥ : Ideal R) : FractionalIdeal S P) = 0 :=\n  rfl\n\n"}
{"name":"FractionalIdeal.exists_mem_algebraMap_eq","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nloc : IsLocalization S P\nx : R\nI : Ideal R\nh : LE.le S (nonZeroDivisors R)\n⊢ Iff (Exists fun x' => And (Membership.mem I x') (Eq ((algebraMap R P) x') ((algebraMap R P) x))) (Membership.mem I x)","decl":"variable (P) in\n@[simp]\ntheorem exists_mem_algebraMap_eq {x : R} {I : Ideal R} (h : S ≤ nonZeroDivisors R) :\n    (∃ x', x' ∈ I ∧ algebraMap R P x' = algebraMap R P x) ↔ x ∈ I :=\n  ⟨fun ⟨_, hx', Eq⟩ => IsLocalization.injective _ h Eq ▸ hx', fun h => ⟨x, h, rfl⟩⟩\n\n"}
{"name":"FractionalIdeal.coeIdeal_injective'","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nloc : IsLocalization S P\nh : LE.le S (nonZeroDivisors R)\n⊢ Function.Injective fun I => ↑I","decl":"theorem coeIdeal_injective' (h : S ≤ nonZeroDivisors R) :\n    Function.Injective (fun (I : Ideal R) ↦ (I : FractionalIdeal S P)) := fun _ _ h' =>\n  ((coeIdeal_le_coeIdeal' S h).mp h'.le).antisymm ((coeIdeal_le_coeIdeal' S h).mp\n    h'.ge)\n\n"}
{"name":"FractionalIdeal.coeIdeal_inj'","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nloc : IsLocalization S P\nh : LE.le S (nonZeroDivisors R)\nI J : Ideal R\n⊢ Iff (Eq ↑I ↑J) (Eq I J)","decl":"theorem coeIdeal_inj' (h : S ≤ nonZeroDivisors R) {I J : Ideal R} :\n    (I : FractionalIdeal S P) = J ↔ I = J :=\n  (coeIdeal_injective' h).eq_iff\n\n-- Porting note: doesn't need to be @[simp] because it can be proved by coeIdeal_eq_zero\n"}
{"name":"FractionalIdeal.coeIdeal_eq_zero'","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nloc : IsLocalization S P\nI : Ideal R\nh : LE.le S (nonZeroDivisors R)\n⊢ Iff (Eq (↑I) 0) (Eq I Bot.bot)","decl":"theorem coeIdeal_eq_zero' {I : Ideal R} (h : S ≤ nonZeroDivisors R) :\n    (I : FractionalIdeal S P) = 0 ↔ I = (⊥ : Ideal R) :=\n  coeIdeal_inj' h\n\n"}
{"name":"FractionalIdeal.coeIdeal_ne_zero'","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nloc : IsLocalization S P\nI : Ideal R\nh : LE.le S (nonZeroDivisors R)\n⊢ Iff (Ne (↑I) 0) (Ne I Bot.bot)","decl":"theorem coeIdeal_ne_zero' {I : Ideal R} (h : S ≤ nonZeroDivisors R) :\n    (I : FractionalIdeal S P) ≠ 0 ↔ I ≠ (⊥ : Ideal R) :=\n  not_iff_not.mpr <| coeIdeal_eq_zero' h\n\n"}
{"name":"FractionalIdeal.coeToSubmodule_eq_bot","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Iff (Eq (↑I) Bot.bot) (Eq I 0)","decl":"theorem coeToSubmodule_eq_bot {I : FractionalIdeal S P} : (I : Submodule R P) = ⊥ ↔ I = 0 :=\n  ⟨fun h => coeToSubmodule_injective (by simp [h]), fun h => by simp [h]⟩\n\n"}
{"name":"FractionalIdeal.coeToSubmodule_ne_bot","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Iff (Ne (↑I) Bot.bot) (Ne I 0)","decl":"theorem coeToSubmodule_ne_bot {I : FractionalIdeal S P} : ↑I ≠ (⊥ : Submodule R P) ↔ I ≠ 0 :=\n  not_iff_not.mpr coeToSubmodule_eq_bot\n\n"}
{"name":"FractionalIdeal.zero_of_num_eq_bot","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : NoZeroSMulDivisors R P\nhS : Not (Membership.mem S 0)\nI : FractionalIdeal S P\nhI : Eq I.num Bot.bot\n⊢ Eq I 0","decl":"theorem zero_of_num_eq_bot [NoZeroSMulDivisors R P] (hS : 0 ∉ S) {I : FractionalIdeal S P}\n    (hI : I.num = ⊥) : I = 0 := by\n  rw [← coeToSubmodule_eq_bot, eq_bot_iff]\n  intro x hx\n  suffices (den I : R) • x = 0 from\n    (smul_eq_zero.mp this).resolve_left (ne_of_mem_of_not_mem (SetLike.coe_mem _) hS)\n  have h_eq : I.den • (I : Submodule R P) = ⊥ := by rw [den_mul_self_eq_num, hI, Submodule.map_bot]\n  exact (Submodule.eq_bot_iff _).mp h_eq (den I • x) ⟨x, hx, rfl⟩\n\n"}
{"name":"FractionalIdeal.num_zero_eq","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nh_inj : Function.Injective ⇑(algebraMap R P)\n⊢ Eq (FractionalIdeal.num 0) 0","decl":"theorem num_zero_eq (h_inj : Function.Injective (algebraMap R P)) :\n    num (0 : FractionalIdeal S P) = 0 := by\n  simpa [num, LinearMap.ker_eq_bot] using h_inj\n\n"}
{"name":"FractionalIdeal.coeIdeal_top","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\n⊢ Eq (↑Top.top) 1","decl":"@[simp, norm_cast]\ntheorem coeIdeal_top : ((⊤ : Ideal R) : FractionalIdeal S P) = 1 :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mem_one_iff","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nx : P\n⊢ Iff (Membership.mem 1 x) (Exists fun x' => Eq ((algebraMap R P) x') x)","decl":"theorem mem_one_iff {x : P} : x ∈ (1 : FractionalIdeal S P) ↔ ∃ x' : R, algebraMap R P x' = x :=\n  Iff.intro (fun ⟨x', _, h⟩ => ⟨x', h⟩) fun ⟨x', h⟩ => ⟨x', ⟨⟩, h⟩\n\n"}
{"name":"FractionalIdeal.coe_mem_one","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nx : R\n⊢ Membership.mem 1 ((algebraMap R P) x)","decl":"theorem coe_mem_one (x : R) : algebraMap R P x ∈ (1 : FractionalIdeal S P) :=\n  (mem_one_iff S).mpr ⟨x, rfl⟩\n\n"}
{"name":"FractionalIdeal.one_mem_one","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\n⊢ Membership.mem 1 1","decl":"theorem one_mem_one : (1 : P) ∈ (1 : FractionalIdeal S P) :=\n  (mem_one_iff S).mpr ⟨1, RingHom.map_one _⟩\n\n"}
{"name":"FractionalIdeal.coe_one_eq_coeSubmodule_top","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\n⊢ Eq (↑1) (IsLocalization.coeSubmodule P Top.top)","decl":"/-- `(1 : FractionalIdeal S P)` is defined as the R-submodule `f(R) ≤ P`.\n\nHowever, this is not definitionally equal to `1 : Submodule R P`,\nwhich is proved in the actual `simp` lemma `coe_one`. -/\ntheorem coe_one_eq_coeSubmodule_top : ↑(1 : FractionalIdeal S P) = coeSubmodule P (⊤ : Ideal R) :=\n  rfl\n\n"}
{"name":"FractionalIdeal.coe_one","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : (↑(1 : FractionalIdeal S P) : Submodule R P) = 1 := by\n  rw [coe_one_eq_coeSubmodule_top, coeSubmodule_top]\n\n"}
{"name":"FractionalIdeal.coe_le_coe","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Iff (LE.le ↑I ↑J) (LE.le I J)","decl":"@[simp]\ntheorem coe_le_coe {I J : FractionalIdeal S P} :\n    (I : Submodule R P) ≤ (J : Submodule R P) ↔ I ≤ J :=\n  Iff.rfl\n\n"}
{"name":"FractionalIdeal.zero_le","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ LE.le 0 I","decl":"theorem zero_le (I : FractionalIdeal S P) : 0 ≤ I := by\n  intro x hx\n  -- Porting note: changed the proof from convert; simp into rw; exact\n  rw [(mem_zero_iff _).mp hx]\n  exact zero_mem I\n\n"}
{"name":"FractionalIdeal.bot_eq_zero","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\n⊢ Eq Bot.bot 0","decl":"@[simp]\ntheorem bot_eq_zero : (⊥ : FractionalIdeal S P) = 0 :=\n  rfl\n\n"}
{"name":"FractionalIdeal.le_zero_iff","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Iff (LE.le I 0) (Eq I 0)","decl":"@[simp]\ntheorem le_zero_iff {I : FractionalIdeal S P} : I ≤ 0 ↔ I = 0 :=\n  le_bot_iff\n\n"}
{"name":"FractionalIdeal.eq_zero_iff","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Iff (Eq I 0) (∀ (x : P), Membership.mem I x → Eq x 0)","decl":"theorem eq_zero_iff {I : FractionalIdeal S P} : I = 0 ↔ ∀ x ∈ I, x = (0 : P) :=\n  ⟨fun h x hx => by simpa [h, mem_zero_iff] using hx, fun h =>\n    le_bot_iff.mp fun x hx => (mem_zero_iff S).mpr (h x hx)⟩\n\n"}
{"name":"IsFractional.sup","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : Submodule R P\na✝¹ : IsFractional S I\na✝ : IsFractional S J\n⊢ IsFractional S (Max.max I J)","decl":"theorem _root_.IsFractional.sup {I J : Submodule R P} :\n    IsFractional S I → IsFractional S J → IsFractional S (I ⊔ J)\n  | ⟨aI, haI, hI⟩, ⟨aJ, haJ, hJ⟩ =>\n    ⟨aI * aJ, S.mul_mem haI haJ, fun b hb => by\n      rcases mem_sup.mp hb with ⟨bI, hbI, bJ, hbJ, rfl⟩\n      rw [smul_add]\n      apply isInteger_add\n      · rw [mul_smul, smul_comm]\n        exact isInteger_smul (hI bI hbI)\n      · rw [mul_smul]\n        exact isInteger_smul (hJ bJ hbJ)⟩\n\n"}
{"name":"IsFractional.inf_right","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Submodule R P\na✝ : IsFractional S I\nJ : Submodule R P\n⊢ IsFractional S (Min.min I J)","decl":"theorem _root_.IsFractional.inf_right {I : Submodule R P} :\n    IsFractional S I → ∀ J, IsFractional S (I ⊓ J)\n  | ⟨aI, haI, hI⟩, J =>\n    ⟨aI, haI, fun b hb => by\n      rcases mem_inf.mp hb with ⟨hbI, _⟩\n      exact hI b hbI⟩\n\n"}
{"name":"FractionalIdeal.coe_inf","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Eq (↑(Min.min I J)) (Min.min ↑I ↑J)","decl":"@[simp, norm_cast]\ntheorem coe_inf (I J : FractionalIdeal S P) : ↑(I ⊓ J) = (I ⊓ J : Submodule R P) :=\n  rfl\n\n"}
{"name":"FractionalIdeal.coe_sup","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Eq (↑(Max.max I J)) (Max.max ↑I ↑J)","decl":"@[norm_cast]\ntheorem coe_sup (I J : FractionalIdeal S P) : ↑(I ⊔ J) = (I ⊔ J : Submodule R P) :=\n  rfl\n\n"}
{"name":"FractionalIdeal.sup_eq_add","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Eq (Max.max I J) (HAdd.hAdd I J)","decl":"@[simp]\ntheorem sup_eq_add (I J : FractionalIdeal S P) : I ⊔ J = I + J :=\n  rfl\n\n"}
{"name":"FractionalIdeal.coe_add","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Eq (↑(HAdd.hAdd I J)) (HAdd.hAdd ↑I ↑J)","decl":"@[simp, norm_cast]\ntheorem coe_add (I J : FractionalIdeal S P) : (↑(I + J) : Submodule R P) = I + J :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mem_add","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\nx : P\n⊢ Iff (Membership.mem (HAdd.hAdd I J) x) (Exists fun i => And (Membership.mem I i) (Exists fun j => And (Membership.mem J j) (Eq (HAdd.hAdd i j) x)))","decl":"theorem mem_add (I J : FractionalIdeal S P) (x : P) :\n    x ∈ I + J ↔ ∃ i ∈ I, ∃ j ∈ J, i + j = x := by\n  rw [← mem_coe, coe_add, Submodule.add_eq_sup]; exact Submodule.mem_sup\n\n"}
{"name":"FractionalIdeal.coeIdeal_sup","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : Ideal R\n⊢ Eq (↑(Max.max I J)) (HAdd.hAdd ↑I ↑J)","decl":"@[simp, norm_cast]\ntheorem coeIdeal_sup (I J : Ideal R) : ↑(I ⊔ J) = (I + J : FractionalIdeal S P) :=\n  coeToSubmodule_injective <| coeSubmodule_sup _ _ _\n\n"}
{"name":"IsFractional.nsmul","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Submodule R P\nn : Nat\na✝ : IsFractional S I\n⊢ IsFractional S (HSMul.hSMul n I)","decl":"theorem _root_.IsFractional.nsmul {I : Submodule R P} :\n    ∀ n : ℕ, IsFractional S I → IsFractional S (n • I : Submodule R P)\n  | 0, _ => by\n    rw [zero_smul]\n    convert ((0 : Ideal R) : FractionalIdeal S P).isFractional\n    simp\n  | n + 1, h => by\n    rw [succ_nsmul]\n    exact (IsFractional.nsmul n h).sup h\n\n"}
{"name":"FractionalIdeal.coe_nsmul","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nn : Nat\nI : FractionalIdeal S P\n⊢ Eq (↑(HSMul.hSMul n I)) (HSMul.hSMul n ↑I)","decl":"@[norm_cast]\ntheorem coe_nsmul (n : ℕ) (I : FractionalIdeal S P) :\n    (↑(n • I) : Submodule R P) = n • (I : Submodule R P) :=\n  rfl\n\n"}
{"name":"IsFractional.mul","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : Submodule R P\na✝¹ : IsFractional S I\na✝ : IsFractional S J\n⊢ IsFractional S (HMul.hMul I J)","decl":"theorem _root_.IsFractional.mul {I J : Submodule R P} :\n    IsFractional S I → IsFractional S J → IsFractional S (I * J : Submodule R P)\n  | ⟨aI, haI, hI⟩, ⟨aJ, haJ, hJ⟩ =>\n    ⟨aI * aJ, S.mul_mem haI haJ, fun b hb => by\n      refine Submodule.mul_induction_on hb ?_ ?_\n      · intro m hm n hn\n        obtain ⟨n', hn'⟩ := hJ n hn\n        rw [mul_smul, mul_comm m, ← smul_mul_assoc, ← hn', ← Algebra.smul_def]\n        apply hI\n        exact Submodule.smul_mem _ _ hm\n      · intro x y hx hy\n        rw [smul_add]\n        apply isInteger_add hx hy⟩\n\n"}
{"name":"IsFractional.pow","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Submodule R P\nh : IsFractional S I\nn : Nat\n⊢ IsFractional S (HPow.hPow I n)","decl":"theorem _root_.IsFractional.pow {I : Submodule R P} (h : IsFractional S I) :\n    ∀ n : ℕ, IsFractional S (I ^ n : Submodule R P)\n  | 0 => isFractional_of_le_one _ (pow_zero _).le\n  | n + 1 => (pow_succ I n).symm ▸ (IsFractional.pow h n).mul h\n\n"}
{"name":"FractionalIdeal.mul_def'","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_3\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_4\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Eq (I.mul J) ⟨HMul.hMul ↑I ↑J, ⋯⟩","decl":"/-- `FractionalIdeal.mul` is the product of two fractional ideals,\nused to define the `Mul` instance.\n\nThis is only an auxiliary definition: the preferred way of writing `I.mul J` is `I * J`.\n\nElaborated terms involving `FractionalIdeal` tend to grow quite large,\nso by making definitions irreducible, we hope to avoid deep unfolds.\n-/\nirreducible_def mul (lemma := mul_def') (I J : FractionalIdeal S P) : FractionalIdeal S P :=\n  ⟨I * J, I.isFractional.mul J.isFractional⟩\n\n-- local attribute [semireducible] mul\n"}
{"name":"FractionalIdeal.mul_eq_mul","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Eq (I.mul J) (HMul.hMul I J)","decl":"@[simp]\ntheorem mul_eq_mul (I J : FractionalIdeal S P) : mul I J = I * J :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mul_def","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Eq (HMul.hMul I J) ⟨HMul.hMul ↑I ↑J, ⋯⟩","decl":"theorem mul_def (I J : FractionalIdeal S P) :\n    I * J = ⟨I * J, I.isFractional.mul J.isFractional⟩ := by simp only [← mul_eq_mul, mul_def']\n\n"}
{"name":"FractionalIdeal.coe_mul","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\n⊢ Eq (↑(HMul.hMul I J)) (HMul.hMul ↑I ↑J)","decl":"@[simp, norm_cast]\ntheorem coe_mul (I J : FractionalIdeal S P) : (↑(I * J) : Submodule R P) = I * J := by\n  simp only [mul_def, coe_mk]\n\n"}
{"name":"FractionalIdeal.coeIdeal_mul","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : Ideal R\n⊢ Eq (↑(HMul.hMul I J)) (HMul.hMul ↑I ↑J)","decl":"@[simp, norm_cast]\ntheorem coeIdeal_mul (I J : Ideal R) : (↑(I * J) : FractionalIdeal S P) = I * J := by\n  simp only [mul_def]\n  exact coeToSubmodule_injective (coeSubmodule_mul _ _ _)\n\n"}
{"name":"FractionalIdeal.mul_left_mono","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Monotone fun x => HMul.hMul I x","decl":"theorem mul_left_mono (I : FractionalIdeal S P) : Monotone (I * ·) := by\n  intro J J' h\n  simp only [mul_def]\n  exact mul_le.mpr fun x hx y hy => mul_mem_mul hx (h hy)\n\n"}
{"name":"FractionalIdeal.mul_right_mono","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Monotone fun J => HMul.hMul J I","decl":"theorem mul_right_mono (I : FractionalIdeal S P) : Monotone fun J => J * I := by\n  intro J J' h\n  simp only [mul_def]\n  exact mul_le.mpr fun x hx y hy => mul_mem_mul (h hx) hy\n\n"}
{"name":"FractionalIdeal.mul_mem_mul","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\ni j : P\nhi : Membership.mem I i\nhj : Membership.mem J j\n⊢ Membership.mem (HMul.hMul I J) (HMul.hMul i j)","decl":"theorem mul_mem_mul {I J : FractionalIdeal S P} {i j : P} (hi : i ∈ I) (hj : j ∈ J) :\n    i * j ∈ I * J := by\n  simp only [mul_def]\n  exact Submodule.mul_mem_mul hi hj\n\n"}
{"name":"FractionalIdeal.mul_le","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J K : FractionalIdeal S P\n⊢ Iff (LE.le (HMul.hMul I J) K) (∀ (i : P), Membership.mem I i → ∀ (j : P), Membership.mem J j → Membership.mem K (HMul.hMul i j))","decl":"theorem mul_le {I J K : FractionalIdeal S P} : I * J ≤ K ↔ ∀ i ∈ I, ∀ j ∈ J, i * j ∈ K := by\n  simp only [mul_def]\n  exact Submodule.mul_le\n\n"}
{"name":"FractionalIdeal.coe_pow","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\nn : Nat\n⊢ Eq (↑(HPow.hPow I n)) (HPow.hPow (↑I) n)","decl":"@[simp, norm_cast]\ntheorem coe_pow (I : FractionalIdeal S P) (n : ℕ) : ↑(I ^ n) = (I : Submodule R P) ^ n :=\n  rfl\n\n"}
{"name":"FractionalIdeal.mul_induction_on","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\nC : P → Prop\nr : P\nhr : Membership.mem (HMul.hMul I J) r\nhm : ∀ (i : P), Membership.mem I i → ∀ (j : P), Membership.mem J j → C (HMul.hMul i j)\nha : ∀ (x y : P), C x → C y → C (HAdd.hAdd x y)\n⊢ C r","decl":"@[elab_as_elim]\nprotected theorem mul_induction_on {I J : FractionalIdeal S P} {C : P → Prop} {r : P}\n    (hr : r ∈ I * J) (hm : ∀ i ∈ I, ∀ j ∈ J, C (i * j)) (ha : ∀ x y, C x → C y → C (x + y)) :\n    C r := by\n  simp only [mul_def] at hr\n  exact Submodule.mul_induction_on hr hm ha\n\n"}
{"name":"FractionalIdeal.coe_natCast","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"theorem coe_natCast (n : ℕ) : ((n : FractionalIdeal S P) : Submodule R P) = n :=\n  show ((n.unaryCast : FractionalIdeal S P) : Submodule R P) = n\n  by induction n <;> simp [*, Nat.unaryCast]\n\n"}
{"name":"FractionalIdeal.coeSubmoduleHom_apply","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Eq ((FractionalIdeal.coeSubmoduleHom S P) I) ↑I","decl":"/-- `FractionalIdeal.coeToSubmodule` as a bundled `RingHom`. -/\n@[simps]\ndef coeSubmoduleHom : FractionalIdeal S P →+* Submodule R P where\n  toFun := coeToSubmodule\n  map_one' := coe_one\n  map_mul' := coe_mul\n  map_zero' := coe_zero (S := S)\n  map_add' := coe_add\n\n"}
{"name":"FractionalIdeal.add_le_add_left","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\nhIJ : LE.le I J\nJ' : FractionalIdeal S P\n⊢ LE.le (HAdd.hAdd J' I) (HAdd.hAdd J' J)","decl":"theorem add_le_add_left {I J : FractionalIdeal S P} (hIJ : I ≤ J) (J' : FractionalIdeal S P) :\n    J' + I ≤ J' + J :=\n  sup_le_sup_left hIJ J'\n\n"}
{"name":"FractionalIdeal.mul_le_mul_left","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI J : FractionalIdeal S P\nhIJ : LE.le I J\nJ' : FractionalIdeal S P\n⊢ LE.le (HMul.hMul J' I) (HMul.hMul J' J)","decl":"theorem mul_le_mul_left {I J : FractionalIdeal S P} (hIJ : I ≤ J) (J' : FractionalIdeal S P) :\n    J' * I ≤ J' * J :=\n  mul_le.mpr fun _ hk _ hj => mul_mem_mul hk (hIJ hj)\n\n"}
{"name":"FractionalIdeal.le_self_mul_self","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\nhI : LE.le 1 I\n⊢ LE.le I (HMul.hMul I I)","decl":"theorem le_self_mul_self {I : FractionalIdeal S P} (hI : 1 ≤ I) : I ≤ I * I := by\n  convert mul_left_mono I hI\n  exact (mul_one I).symm\n\n"}
{"name":"FractionalIdeal.mul_self_le_self","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\nhI : LE.le I 1\n⊢ LE.le (HMul.hMul I I) I","decl":"theorem mul_self_le_self {I : FractionalIdeal S P} (hI : I ≤ 1) : I * I ≤ I := by\n  convert mul_left_mono I hI\n  exact (mul_one I).symm\n\n"}
{"name":"FractionalIdeal.coeIdeal_le_one","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Ideal R\n⊢ LE.le (↑I) 1","decl":"theorem coeIdeal_le_one {I : Ideal R} : (I : FractionalIdeal S P) ≤ 1 := fun _ hx =>\n  let ⟨y, _, hy⟩ := (mem_coeIdeal S).mp hx\n  (mem_one_iff S).mpr ⟨y, hy⟩\n\n"}
{"name":"FractionalIdeal.le_one_iff_exists_coeIdeal","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nJ : FractionalIdeal S P\n⊢ Iff (LE.le J 1) (Exists fun I => Eq (↑I) J)","decl":"theorem le_one_iff_exists_coeIdeal {J : FractionalIdeal S P} :\n    J ≤ (1 : FractionalIdeal S P) ↔ ∃ I : Ideal R, ↑I = J := by\n  constructor\n  · intro hJ\n    refine ⟨⟨⟨⟨{ x : R | algebraMap R P x ∈ J }, ?_⟩, ?_⟩, ?_⟩, ?_⟩\n    · intro a b ha hb\n      rw [mem_setOf, RingHom.map_add]\n      exact J.val.add_mem ha hb\n    · rw [mem_setOf, RingHom.map_zero]\n      exact J.zero_mem\n    · intro c x hx\n      rw [smul_eq_mul, mem_setOf, RingHom.map_mul, ← Algebra.smul_def]\n      exact J.val.smul_mem c hx\n    · ext x\n      constructor\n      · rintro ⟨y, hy, eq_y⟩\n        rwa [← eq_y]\n      · intro hx\n        obtain ⟨y, rfl⟩ := (mem_one_iff S).mp (hJ hx)\n        exact mem_setOf.mpr ⟨y, hx, rfl⟩\n  · rintro ⟨I, hI⟩\n    rw [← hI]\n    apply coeIdeal_le_one\n\n"}
{"name":"FractionalIdeal.one_le","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : FractionalIdeal S P\n⊢ Iff (LE.le 1 I) (Membership.mem I 1)","decl":"@[simp]\ntheorem one_le {I : FractionalIdeal S P} : 1 ≤ I ↔ (1 : P) ∈ I := by\n  rw [← coe_le_coe, coe_one, Submodule.one_le, mem_coe]\n\n"}
{"name":"FractionalIdeal.coeIdealHom_apply","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Ideal R\n⊢ Eq ((FractionalIdeal.coeIdealHom S P) I) ↑I","decl":"/-- `coeIdealHom (S : Submonoid R) P` is `(↑) : Ideal R → FractionalIdeal S P` as a ring hom -/\n@[simps]\ndef coeIdealHom : Ideal R →+* FractionalIdeal S P where\n  toFun := coeIdeal\n  map_add' := coeIdeal_sup\n  map_mul' := coeIdeal_mul\n  map_one' := by rw [Ideal.one_eq_top, coeIdeal_top]\n  map_zero' := coeIdeal_bot\n\n"}
{"name":"FractionalIdeal.coeIdeal_pow","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nI : Ideal R\nn : Nat\n⊢ Eq (↑(HPow.hPow I n)) (HPow.hPow (↑I) n)","decl":"theorem coeIdeal_pow (I : Ideal R) (n : ℕ) : ↑(I ^ n) = (I : FractionalIdeal S P) ^ n :=\n  (coeIdealHom S P).map_pow _ n\n\n"}
{"name":"FractionalIdeal.coeIdeal_finprod","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Submonoid R\nP : Type u_2\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization S P\nα : Sort u_3\nf : α → Ideal R\nhS : LE.le S (nonZeroDivisors R)\n⊢ Eq (↑(finprod fun a => f a)) (finprod fun a => ↑(f a))","decl":"theorem coeIdeal_finprod [IsLocalization S P] {α : Sort*} {f : α → Ideal R}\n    (hS : S ≤ nonZeroDivisors R) :\n    ((∏ᶠ a : α, f a : Ideal R) : FractionalIdeal S P) = ∏ᶠ a : α, (f a : FractionalIdeal S P) :=\n  MonoidHom.map_finprod_of_injective (coeIdealHom S P).toMonoidHom (coeIdeal_injective' hS) f\n\n"}
{"name":"FractionalIdeal.fg_of_isNoetherianRing","module":"Mathlib.RingTheory.FractionalIdeal.Basic","initialProofState":"R : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : Nontrivial R\nS : Submonoid R\nP : Type u_4\ninst✝³ : Nontrivial P\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : NoZeroSMulDivisors R P\nhR : IsNoetherianRing R\nhS : LE.le S (nonZeroDivisors R)\nI : FractionalIdeal S P\n⊢ (↑I).FG","decl":"/-- The fractional ideals of a Noetherian ring are finitely generated. -/\nlemma fg_of_isNoetherianRing [hR : IsNoetherianRing R] (hS : S ≤ R⁰) (I : FractionalIdeal S P) :\n    FG I.coeToSubmodule := by\n  have := hR.noetherian I.num\n  rw [← fg_top] at this ⊢\n  exact fg_of_linearEquiv (I.equivNum <| coe_ne_zero ⟨(I.den : R), hS (SetLike.coe_mem I.den)⟩) this\n\n"}
