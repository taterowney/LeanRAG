{"name":"MeasurableSpace.CountablyGenerated.isCountablyGenerated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nself : MeasurableSpace.CountablyGenerated α\n⊢ Exists fun b => And b.Countable (Eq m (MeasurableSpace.generateFrom b))","decl":"/-- We say a measurable space is countably generated\nif it can be generated by a countable set of sets. -/\nclass CountablyGenerated (α : Type*) [m : MeasurableSpace α] : Prop where\n  isCountablyGenerated : ∃ b : Set (Set α), b.Countable ∧ m = generateFrom b\n\n"}
{"name":"MeasurableSpace.countable_countableGeneratingSet","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\n⊢ (MeasurableSpace.countableGeneratingSet α).Countable","decl":"lemma countable_countableGeneratingSet [MeasurableSpace α] [h : CountablyGenerated α] :\n    Set.Countable (countableGeneratingSet α) :=\n  Countable.insert _ h.isCountablyGenerated.choose_spec.1\n\n"}
{"name":"MeasurableSpace.generateFrom_countableGeneratingSet","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\n⊢ Eq (MeasurableSpace.generateFrom (MeasurableSpace.countableGeneratingSet α)) m","decl":"lemma generateFrom_countableGeneratingSet [m : MeasurableSpace α] [h : CountablyGenerated α] :\n    generateFrom (countableGeneratingSet α) = m :=\n  (generateFrom_insert_empty _).trans <| h.isCountablyGenerated.choose_spec.2.symm\n\n"}
{"name":"MeasurableSpace.empty_mem_countableGeneratingSet","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\n⊢ Membership.mem (MeasurableSpace.countableGeneratingSet α) EmptyCollection.emptyCollection","decl":"lemma empty_mem_countableGeneratingSet [MeasurableSpace α] [CountablyGenerated α] :\n    ∅ ∈ countableGeneratingSet α := mem_insert _ _\n\n"}
{"name":"MeasurableSpace.nonempty_countableGeneratingSet","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\n⊢ (MeasurableSpace.countableGeneratingSet α).Nonempty","decl":"lemma nonempty_countableGeneratingSet [MeasurableSpace α] [CountablyGenerated α] :\n    Set.Nonempty (countableGeneratingSet α) :=\n  ⟨∅, mem_insert _ _⟩\n\n"}
{"name":"MeasurableSpace.measurableSet_countableGeneratingSet","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\ns : Set α\nhs : Membership.mem (MeasurableSpace.countableGeneratingSet α) s\n⊢ MeasurableSet s","decl":"lemma measurableSet_countableGeneratingSet [MeasurableSpace α] [CountablyGenerated α]\n    {s : Set α} (hs : s ∈ countableGeneratingSet α) :\n    MeasurableSet s := by\n  rw [← generateFrom_countableGeneratingSet (α := α)]\n  exact measurableSet_generateFrom hs\n\n"}
{"name":"MeasurableSpace.generateFrom_natGeneratingSequence","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\nm : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\n⊢ Eq (MeasurableSpace.generateFrom (Set.range (MeasurableSpace.natGeneratingSequence α))) m","decl":"lemma generateFrom_natGeneratingSequence (α : Type*) [m : MeasurableSpace α]\n    [CountablyGenerated α] : generateFrom (range (natGeneratingSequence _)) = m := by\n  rw [natGeneratingSequence, range_enumerateCountable_of_mem _ empty_mem_countableGeneratingSet,\n    generateFrom_countableGeneratingSet]\n\n"}
{"name":"MeasurableSpace.measurableSet_natGeneratingSequence","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\nn : Nat\n⊢ MeasurableSet (MeasurableSpace.natGeneratingSequence α n)","decl":"lemma measurableSet_natGeneratingSequence [MeasurableSpace α] [CountablyGenerated α] (n : ℕ) :\n    MeasurableSet (natGeneratingSequence α n) :=\n  measurableSet_countableGeneratingSet <| Set.enumerateCountable_mem _\n    empty_mem_countableGeneratingSet n\n\n"}
{"name":"MeasurableSpace.CountablyGenerated.comap","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace β\nh : MeasurableSpace.CountablyGenerated β\nf : α → β\n⊢ MeasurableSpace.CountablyGenerated α","decl":"theorem CountablyGenerated.comap [m : MeasurableSpace β] [h : CountablyGenerated β] (f : α → β) :\n    @CountablyGenerated α (.comap f m) := by\n  rcases h with ⟨⟨b, hbc, rfl⟩⟩\n  rw [comap_generateFrom]\n  letI := generateFrom (preimage f '' b)\n  exact ⟨_, hbc.image _, rfl⟩\n\n"}
{"name":"MeasurableSpace.CountablyGenerated.sup","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"β : Type u_2\nm₁ m₂ : MeasurableSpace β\nh₁ : MeasurableSpace.CountablyGenerated β\nh₂ : MeasurableSpace.CountablyGenerated β\n⊢ MeasurableSpace.CountablyGenerated β","decl":"theorem CountablyGenerated.sup {m₁ m₂ : MeasurableSpace β} (h₁ : @CountablyGenerated β m₁)\n    (h₂ : @CountablyGenerated β m₂) : @CountablyGenerated β (m₁ ⊔ m₂) := by\n  rcases h₁ with ⟨⟨b₁, hb₁c, rfl⟩⟩\n  rcases h₂ with ⟨⟨b₂, hb₂c, rfl⟩⟩\n  exact @mk _ (_ ⊔ _) ⟨_, hb₁c.union hb₂c, generateFrom_sup_generateFrom⟩\n\n"}
{"name":"MeasurableSpace.instCountablyGeneratedOfCountable","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : Countable α\n⊢ MeasurableSpace.CountablyGenerated α","decl":"/-- Any measurable space structure on a countable space is countably generated. -/\ninstance (priority := 100) [MeasurableSpace α] [Countable α] : CountablyGenerated α where\n  isCountablyGenerated := by\n    refine ⟨⋃ y, {measurableAtom y}, countable_iUnion (fun i ↦ countable_singleton _), ?_⟩\n    refine le_antisymm ?_ (generateFrom_le (by simp [MeasurableSet.measurableAtom_of_countable]))\n    intro s hs\n    have : s = ⋃ y ∈ s, measurableAtom y := by\n      apply Subset.antisymm\n      · intro x hx\n        simpa using ⟨x, hx, by simp⟩\n      · simp only [iUnion_subset_iff]\n        intro x hx\n        exact measurableAtom_subset hs hx\n    rw [this]\n    apply MeasurableSet.biUnion (to_countable s) (fun x _hx ↦ ?_)\n    apply measurableSet_generateFrom\n    simp\n\n"}
{"name":"MeasurableSpace.instCountablyGeneratedSubtype","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\np : α → Prop\n⊢ MeasurableSpace.CountablyGenerated (Subtype fun x => p x)","decl":"instance [MeasurableSpace α] [CountablyGenerated α] {p : α → Prop} :\n    CountablyGenerated { x // p x } := .comap _\n\n"}
{"name":"MeasurableSpace.instCountablyGeneratedProd","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace.CountablyGenerated α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace.CountablyGenerated β\n⊢ MeasurableSpace.CountablyGenerated (Prod α β)","decl":"instance [MeasurableSpace α] [CountablyGenerated α] [MeasurableSpace β] [CountablyGenerated β] :\n    CountablyGenerated (α × β) :=\n  .sup (.comap Prod.fst) (.comap Prod.snd)\n\n"}
{"name":"MeasurableSpace.SeparatesPoints.separates","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\nm : MeasurableSpace α\nself : MeasurableSpace.SeparatesPoints α\nx y : α\na✝ : ∀ (s : Set α), MeasurableSet s → Membership.mem s x → Membership.mem s y\n⊢ Eq x y","decl":"/-- We say that a measurable space separates points if for any two distinct points,\nthere is a measurable set containing one but not the other. -/\nclass SeparatesPoints (α : Type*) [m : MeasurableSpace α] : Prop where\n  separates : ∀ x y : α, (∀ s, MeasurableSet s → (x ∈ s → y ∈ s)) → x = y\n\n"}
{"name":"MeasurableSpace.separatesPoints_def","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nhs : MeasurableSpace.SeparatesPoints α\nx y : α\nh : ∀ (s : Set α), MeasurableSet s → Membership.mem s x → Membership.mem s y\n⊢ Eq x y","decl":"theorem separatesPoints_def [MeasurableSpace α] [hs : SeparatesPoints α] {x y : α}\n    (h : ∀ s, MeasurableSet s → (x ∈ s → y ∈ s)) : x = y := hs.separates _ _ h\n\n"}
{"name":"MeasurableSpace.exists_measurableSet_of_ne","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.SeparatesPoints α\nx y : α\nh : Ne x y\n⊢ Exists fun s => And (MeasurableSet s) (And (Membership.mem s x) (Not (Membership.mem s y)))","decl":"theorem exists_measurableSet_of_ne [MeasurableSpace α] [SeparatesPoints α] {x y : α}\n    (h : x ≠ y) : ∃ s, MeasurableSet s ∧ x ∈ s ∧ y ∉ s := by\n  contrapose! h\n  exact separatesPoints_def h\n\n"}
{"name":"MeasurableSpace.separatesPoints_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Iff (MeasurableSpace.SeparatesPoints α) (∀ (x y : α), (∀ (s : Set α), MeasurableSet s → Iff (Membership.mem s x) (Membership.mem s y)) → Eq x y)","decl":"theorem separatesPoints_iff [MeasurableSpace α] : SeparatesPoints α ↔\n    ∀ x y : α, (∀ s, MeasurableSet s → (x ∈ s ↔ y ∈ s)) → x = y :=\n  ⟨fun h ↦ fun _ _ hxy ↦ h.separates _ _ fun _ hs xs ↦ (hxy _ hs).mp xs,\n    fun h ↦ ⟨fun _ _ hxy ↦ h _ _ fun _ hs ↦\n    ⟨fun xs ↦ hxy _ hs xs, not_imp_not.mp fun xs ↦ hxy _ hs.compl xs⟩⟩⟩\n\n"}
{"name":"MeasurableSpace.separating_of_generateFrom","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nS : Set (Set α)\nh : MeasurableSpace.SeparatesPoints α\nx y : α\na✝ : ∀ (s : Set α), Membership.mem S s → Iff (Membership.mem s x) (Membership.mem s y)\n⊢ Eq x y","decl":"/-- If the measurable space generated by `S` separates points,\nthen this is witnessed by sets in `S`. -/\ntheorem separating_of_generateFrom (S : Set (Set α))\n    [h : @SeparatesPoints α (generateFrom S)] :\n    ∀ x y : α, (∀ s ∈ S, x ∈ s ↔ y ∈ s) → x = y := by\n  letI := generateFrom S\n  intros x y hxy\n  rw [← forall_generateFrom_mem_iff_mem_iff] at hxy\n  exact separatesPoints_def <| fun _ hs ↦ (hxy _ hs).mp\n\n"}
{"name":"MeasurableSpace.SeparatesPoints.mono","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm m' : MeasurableSpace α\nhsep : MeasurableSpace.SeparatesPoints α\nh : LE.le m m'\n⊢ MeasurableSpace.SeparatesPoints α","decl":"theorem SeparatesPoints.mono {m m' : MeasurableSpace α} [hsep : @SeparatesPoints _ m] (h : m ≤ m') :\n    @SeparatesPoints _ m' := @SeparatesPoints.mk _ m' fun _ _ hxy ↦\n    @SeparatesPoints.separates _ m hsep _ _ fun _ hs ↦ hxy _ (h _ hs)\n\n"}
{"name":"MeasurableSpace.CountablySeparated.countably_separated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\ninst✝ : MeasurableSpace α\nself : MeasurableSpace.CountablySeparated α\n⊢ HasCountableSeparatingOn α MeasurableSet Set.univ","decl":"/-- We say that a measurable space is countably separated if there is a\ncountable sequence of measurable sets separating points. -/\nclass CountablySeparated (α : Type*) [MeasurableSpace α] : Prop where\n  countably_separated : HasCountableSeparatingOn α MeasurableSet univ\n\n"}
{"name":"MeasurableSpace.countablySeparated_of_hasCountableSeparatingOn","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nh : HasCountableSeparatingOn α MeasurableSet Set.univ\n⊢ MeasurableSpace.CountablySeparated α","decl":"instance countablySeparated_of_hasCountableSeparatingOn [MeasurableSpace α]\n    [h : HasCountableSeparatingOn α MeasurableSet univ] : CountablySeparated α := ⟨h⟩\n\n"}
{"name":"MeasurableSpace.hasCountableSeparatingOn_of_countablySeparated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nh : MeasurableSpace.CountablySeparated α\n⊢ HasCountableSeparatingOn α MeasurableSet Set.univ","decl":"instance hasCountableSeparatingOn_of_countablySeparated [MeasurableSpace α]\n    [h : CountablySeparated α] : HasCountableSeparatingOn α MeasurableSet univ :=\n  h.countably_separated\n\n"}
{"name":"MeasurableSpace.countablySeparated_def","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Iff (MeasurableSpace.CountablySeparated α) (HasCountableSeparatingOn α MeasurableSet Set.univ)","decl":"theorem countablySeparated_def [MeasurableSpace α] :\n    CountablySeparated α ↔ HasCountableSeparatingOn α MeasurableSet univ :=\n  ⟨fun h ↦ h.countably_separated, fun h ↦ ⟨h⟩⟩\n\n"}
{"name":"MeasurableSpace.CountablySeparated.mono","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm m' : MeasurableSpace α\nhsep : MeasurableSpace.CountablySeparated α\nh : LE.le m m'\n⊢ MeasurableSpace.CountablySeparated α","decl":"theorem CountablySeparated.mono {m m' : MeasurableSpace α} [hsep : @CountablySeparated _ m]\n    (h : m ≤ m') : @CountablySeparated _ m' := by\n  simp_rw [countablySeparated_def] at *\n  rcases hsep with ⟨S, Sct, Smeas, hS⟩\n  use S, Sct, (fun s hs ↦ h _ <| Smeas _ hs), hS\n\n"}
{"name":"MeasurableSpace.CountablySeparated.subtype_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\n⊢ Iff (MeasurableSpace.CountablySeparated ↑s) (HasCountableSeparatingOn α MeasurableSet s)","decl":"theorem CountablySeparated.subtype_iff [MeasurableSpace α] {s : Set α} :\n    CountablySeparated s ↔ HasCountableSeparatingOn α MeasurableSet s := by\n  rw [countablySeparated_def]\n  exact HasCountableSeparatingOn.subtype_iff\n\n"}
{"name":"MeasurableSpace.Subtype.separatesPoints","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nh : MeasurableSpace.SeparatesPoints α\ns : Set α\n⊢ MeasurableSpace.SeparatesPoints ↑s","decl":"instance (priority := 100) Subtype.separatesPoints [MeasurableSpace α] [h : SeparatesPoints α]\n    {s : Set α} : SeparatesPoints s :=\n  ⟨fun _ _ hxy ↦ Subtype.val_injective <| h.1 _ _ fun _ ht ↦ hxy _ <| measurable_subtype_coe ht⟩\n\n"}
{"name":"MeasurableSpace.Subtype.countablySeparated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nh : MeasurableSpace.CountablySeparated α\ns : Set α\n⊢ MeasurableSpace.CountablySeparated ↑s","decl":"instance (priority := 100) Subtype.countablySeparated [MeasurableSpace α]\n    [h : CountablySeparated α] {s : Set α} : CountablySeparated s := by\n  rw [CountablySeparated.subtype_iff]\n  exact h.countably_separated.mono (fun s ↦ id) <| subset_univ _\n\n"}
{"name":"MeasurableSpace.separatesPoints_of_measurableSingletonClass","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\n⊢ MeasurableSpace.SeparatesPoints α","decl":"instance (priority := 100) separatesPoints_of_measurableSingletonClass [MeasurableSpace α]\n    [MeasurableSingletonClass α] : SeparatesPoints α := by\n  refine ⟨fun x y h ↦ ?_⟩\n  specialize h _ (MeasurableSet.singleton x)\n  simp_rw [mem_singleton_iff, forall_true_left] at h\n  exact h.symm\n\n"}
{"name":"MeasurableSpace.MeasurableSingletonClass.of_separatesPoints","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : Countable α\ninst✝ : MeasurableSpace.SeparatesPoints α\n⊢ MeasurableSingletonClass α","decl":"instance (priority := 50) MeasurableSingletonClass.of_separatesPoints [MeasurableSpace α]\n    [Countable α] [SeparatesPoints α] : MeasurableSingletonClass α where\n  measurableSet_singleton x := by\n    choose s hsm hxs hys using fun y (h : x ≠ y) ↦ exists_measurableSet_of_ne h\n    convert MeasurableSet.iInter fun y ↦ .iInter fun h ↦ hsm y h\n    ext y\n    rcases eq_or_ne x y with rfl | h\n    · simpa\n    · simp only [mem_singleton_iff, h.symm, false_iff, mem_iInter, not_forall]\n      exact ⟨y, h, hys y h⟩\n\n"}
{"name":"MeasurableSpace.hasCountableSeparatingOn_of_countablySeparated_subtype","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\nh : MeasurableSpace.CountablySeparated ↑s\n⊢ HasCountableSeparatingOn α MeasurableSet s","decl":"instance hasCountableSeparatingOn_of_countablySeparated_subtype\n    [MeasurableSpace α] {s : Set α} [h : CountablySeparated s] :\n    HasCountableSeparatingOn _ MeasurableSet s := CountablySeparated.subtype_iff.mp h\n\n"}
{"name":"MeasurableSpace.countablySeparated_subtype_of_hasCountableSeparatingOn","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\nh : HasCountableSeparatingOn α MeasurableSet s\n⊢ MeasurableSpace.CountablySeparated ↑s","decl":"instance countablySeparated_subtype_of_hasCountableSeparatingOn\n    [MeasurableSpace α] {s : Set α} [h : HasCountableSeparatingOn _ MeasurableSet s] :\n    CountablySeparated s := CountablySeparated.subtype_iff.mpr h\n\n"}
{"name":"MeasurableSpace.countablySeparated_of_separatesPoints","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\ninst✝ : MeasurableSpace.SeparatesPoints α\n⊢ MeasurableSpace.CountablySeparated α","decl":"instance countablySeparated_of_separatesPoints [MeasurableSpace α]\n    [h : CountablyGenerated α] [SeparatesPoints α] : CountablySeparated α := by\n  rcases h with ⟨b, hbc, hb⟩\n  refine ⟨⟨b, hbc, fun t ht ↦ hb.symm ▸ .basic t ht, ?_⟩⟩\n  rw [hb] at ‹SeparatesPoints _›\n  convert separating_of_generateFrom b\n  simp\n\n"}
{"name":"MeasurableSpace.exists_countablyGenerated_le_of_countablySeparated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablySeparated α\n⊢ Exists fun m' => And (MeasurableSpace.CountablyGenerated α) (And (MeasurableSpace.SeparatesPoints α) (LE.le m' m))","decl":"/-- If a measurable space admits a countable separating family of measurable sets,\nthere is a countably generated coarser space which still separates points. -/\ntheorem exists_countablyGenerated_le_of_countablySeparated [m : MeasurableSpace α]\n    [h : CountablySeparated α] :\n    ∃ m' : MeasurableSpace α, @CountablyGenerated _ m' ∧ @SeparatesPoints _ m' ∧ m' ≤ m := by\n  rcases h with ⟨b, bct, hbm, hb⟩\n  refine ⟨generateFrom b, ?_, ?_, generateFrom_le hbm⟩\n  · use b\n  rw [@separatesPoints_iff]\n  exact fun x y hxy ↦ hb _ trivial _ trivial fun _ hs ↦ hxy _ <| measurableSet_generateFrom hs\n\n"}
{"name":"MeasurableSpace.measurable_mapNatBool","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\n⊢ Measurable (MeasurableSpace.mapNatBool α)","decl":"theorem measurable_mapNatBool [MeasurableSpace α] [CountablyGenerated α] :\n    Measurable (mapNatBool α) := by\n  rw [measurable_pi_iff]\n  refine fun n ↦ measurable_to_bool ?_\n  simp only [preimage, mem_singleton_iff, mapNatBool,\n    Bool.decide_iff, setOf_mem_eq]\n  apply measurableSet_natGeneratingSequence\n\n"}
{"name":"MeasurableSpace.injective_mapNatBool","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace.CountablyGenerated α\ninst✝ : MeasurableSpace.SeparatesPoints α\n⊢ Function.Injective (MeasurableSpace.mapNatBool α)","decl":"theorem injective_mapNatBool [MeasurableSpace α] [CountablyGenerated α]\n    [SeparatesPoints α] : Injective (mapNatBool α) := by\n  intro x y hxy\n  rw [← generateFrom_natGeneratingSequence α] at *\n  apply separating_of_generateFrom (range (natGeneratingSequence _))\n  rintro - ⟨n, rfl⟩\n  rw [← decide_eq_decide]\n  exact congr_fun hxy n\n\n"}
{"name":"MeasurableSpace.measurableEquiv_nat_bool_of_countablyGenerated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace.CountablyGenerated α\ninst✝ : MeasurableSpace.SeparatesPoints α\n⊢ Exists fun s => Nonempty (MeasurableEquiv α ↑s)","decl":"/-- If a measurable space is countably generated and separates points, it is measure equivalent\nto some subset of the Cantor space `ℕ → Bool` (equipped with the product sigma algebra).\nNote: `s` need not be measurable, so this map need not be a `MeasurableEmbedding` to\nthe Cantor Space. -/\ntheorem measurableEquiv_nat_bool_of_countablyGenerated [MeasurableSpace α]\n    [CountablyGenerated α] [SeparatesPoints α] :\n    ∃ s : Set (ℕ → Bool), Nonempty (α ≃ᵐ s) := by\n  use range (mapNatBool α), Equiv.ofInjective _ <|\n    injective_mapNatBool _,\n    Measurable.subtype_mk <| measurable_mapNatBool _\n  simp_rw [← generateFrom_natGeneratingSequence α]\n  apply measurable_generateFrom\n  rintro _ ⟨n, rfl⟩\n  rw [← Equiv.image_eq_preimage _ _]\n  refine ⟨{y | y n}, by measurability, ?_⟩\n  rw [← Equiv.preimage_eq_iff_eq_image]\n  simp [mapNatBool]\n\n"}
{"name":"MeasurableSpace.measurable_injection_nat_bool_of_countablySeparated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablySeparated α\n⊢ Exists fun f => And (Measurable f) (Function.Injective f)","decl":"/-- If a measurable space admits a countable sequence of measurable sets separating points,\nit admits a measurable injection into the Cantor space `ℕ → Bool`\n(equipped with the product sigma algebra). -/\ntheorem measurable_injection_nat_bool_of_countablySeparated [MeasurableSpace α]\n    [CountablySeparated α] : ∃ f : α → ℕ → Bool, Measurable f ∧ Injective f := by\n  rcases exists_countablyGenerated_le_of_countablySeparated α with ⟨m', _, _, m'le⟩\n  refine ⟨mapNatBool α, ?_, injective_mapNatBool _⟩\n  exact (measurable_mapNatBool _).mono m'le le_rfl\n\n"}
{"name":"MeasurableSpace.measurableSingletonClass_of_countablySeparated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablySeparated α\n⊢ MeasurableSingletonClass α","decl":"theorem measurableSingletonClass_of_countablySeparated\n    [MeasurableSpace α] [CountablySeparated α] :\n    MeasurableSingletonClass α := by\n  rcases measurable_injection_nat_bool_of_countablySeparated α with ⟨f, fmeas, finj⟩\n  refine ⟨fun x ↦ ?_⟩\n  rw [← finj.preimage_image {x}, image_singleton]\n  exact fmeas <| MeasurableSet.singleton _\n\n"}
{"name":"MeasurableSpace.measurableSet_succ_memPartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nt : Nat → Set α\nn : Nat\ns : Set α\nhs : Membership.mem (memPartition t n) s\n⊢ MeasurableSet s","decl":"lemma measurableSet_succ_memPartition (t : ℕ → Set α) (n : ℕ) {s : Set α}\n    (hs : s ∈ memPartition t n) :\n    MeasurableSet[generateFrom (memPartition t (n + 1))] s := by\n  rw [← diff_union_inter s (t n)]\n  refine MeasurableSet.union ?_ ?_ <;>\n    · refine measurableSet_generateFrom ?_\n      rw [memPartition_succ]\n      exact ⟨s, hs, by simp⟩\n\n"}
{"name":"MeasurableSpace.generateFrom_memPartition_le_succ","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nt : Nat → Set α\nn : Nat\n⊢ LE.le (MeasurableSpace.generateFrom (memPartition t n)) (MeasurableSpace.generateFrom (memPartition t (HAdd.hAdd n 1)))","decl":"lemma generateFrom_memPartition_le_succ (t : ℕ → Set α) (n : ℕ) :\n    generateFrom (memPartition t n) ≤ generateFrom (memPartition t (n + 1)) :=\n  generateFrom_le (fun _ hs ↦ measurableSet_succ_memPartition t n hs)\n\n"}
{"name":"MeasurableSpace.measurableSet_generateFrom_memPartition_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nt : Nat → Set α\nn : Nat\ns : Set α\n⊢ Iff (MeasurableSet s) (Exists fun S => And (HasSubset.Subset (↑S) (memPartition t n)) (Eq s (↑S).sUnion))","decl":"lemma measurableSet_generateFrom_memPartition_iff (t : ℕ → Set α) (n : ℕ) (s : Set α) :\n    MeasurableSet[generateFrom (memPartition t n)] s\n      ↔ ∃ S : Finset (Set α), ↑S ⊆ memPartition t n ∧ s = ⋃₀ S := by\n  refine ⟨fun h ↦ ?_, fun ⟨S, hS_subset, hS_eq⟩ ↦ ?_⟩\n  · induction s, h using generateFrom_induction with\n    | hC u hu _ => exact ⟨{u}, by simp [hu], by simp⟩\n    | empty => exact ⟨∅, by simp, by simp⟩\n    | compl u _ hu =>\n      obtain ⟨S, hS_subset, rfl⟩ := hu\n      classical\n      refine ⟨(memPartition t n).toFinset \\ S, ?_, ?_⟩\n      · simp only [Finset.coe_sdiff, coe_toFinset]\n        exact diff_subset\n      · simp only [Finset.coe_sdiff, coe_toFinset]\n        refine (IsCompl.eq_compl ⟨?_, ?_⟩).symm\n        · refine Set.disjoint_sUnion_right.mpr fun u huS => ?_\n          refine Set.disjoint_sUnion_left.mpr fun v huV => ?_\n          refine disjoint_memPartition t n (mem_of_mem_diff huV) (hS_subset huS) ?_\n          exact ne_of_mem_of_not_mem huS (not_mem_of_mem_diff huV) |>.symm\n        · rw [codisjoint_iff]\n          simp only [sup_eq_union, top_eq_univ]\n          rw [← sUnion_memPartition t n, union_comm, ← sUnion_union, union_diff_cancel hS_subset]\n    | iUnion f _ h =>\n      choose S hS_subset hS_eq using h\n      have : Fintype (⋃ n, (S n : Set (Set α))) := by\n        refine (Finite.subset (finite_memPartition t n) ?_).fintype\n        simp only [iUnion_subset_iff]\n        exact hS_subset\n      refine ⟨(⋃ n, (S n : Set (Set α))).toFinset, ?_, ?_⟩\n      · simp only [coe_toFinset, iUnion_subset_iff]\n        exact hS_subset\n      · simp only [coe_toFinset, sUnion_iUnion, hS_eq]\n  · rw [hS_eq, sUnion_eq_biUnion]\n    refine MeasurableSet.biUnion ?_ (fun t ht ↦ ?_)\n    · exact S.countable_toSet\n    · exact measurableSet_generateFrom (hS_subset ht)\n\n"}
{"name":"MeasurableSpace.measurableSet_generateFrom_memPartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nt : Nat → Set α\nn : Nat\n⊢ MeasurableSet (t n)","decl":"lemma measurableSet_generateFrom_memPartition (t : ℕ → Set α) (n : ℕ) :\n    MeasurableSet[generateFrom (memPartition t (n + 1))] (t n) := by\n  have : t n = ⋃ u ∈ memPartition t n, u ∩ t n := by\n    simp_rw [← iUnion_inter, ← sUnion_eq_biUnion, sUnion_memPartition, univ_inter]\n  rw [this]\n  refine MeasurableSet.biUnion (finite_memPartition _ _).countable (fun v hv ↦ ?_)\n  refine measurableSet_generateFrom ?_\n  rw [memPartition_succ]\n  exact ⟨v, hv, Or.inl rfl⟩\n\n"}
{"name":"MeasurableSpace.generateFrom_iUnion_memPartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nt : Nat → Set α\n⊢ Eq (MeasurableSpace.generateFrom (Set.iUnion fun n => memPartition t n)) (MeasurableSpace.generateFrom (Set.range t))","decl":"lemma generateFrom_iUnion_memPartition (t : ℕ → Set α) :\n    generateFrom (⋃ n, memPartition t n) = generateFrom (range t) := by\n  refine le_antisymm (generateFrom_le fun u hu ↦ ?_) (generateFrom_le fun u hu ↦ ?_)\n  · simp only [mem_iUnion] at hu\n    obtain ⟨n, hun⟩ := hu\n    induction n generalizing u with\n    | zero =>\n      simp only [memPartition_zero, mem_insert_iff, mem_singleton_iff] at hun\n      rw [hun]\n      exact MeasurableSet.univ\n    | succ n ih =>\n      simp only [memPartition_succ, mem_setOf_eq] at hun\n      obtain ⟨v, hv, huv⟩ := hun\n      rcases huv with rfl | rfl\n      · exact (ih v hv).inter (measurableSet_generateFrom ⟨n, rfl⟩)\n      · exact (ih v hv).diff (measurableSet_generateFrom ⟨n, rfl⟩)\n  · simp only [iUnion_singleton_eq_range, mem_range] at hu\n    obtain ⟨n, rfl⟩ := hu\n    exact generateFrom_mono (subset_iUnion _ _) _ (measurableSet_generateFrom_memPartition t n)\n\n"}
{"name":"MeasurableSpace.generateFrom_memPartition_le_range","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nt : Nat → Set α\nn : Nat\n⊢ LE.le (MeasurableSpace.generateFrom (memPartition t n)) (MeasurableSpace.generateFrom (Set.range t))","decl":"lemma generateFrom_memPartition_le_range (t : ℕ → Set α) (n : ℕ) :\n    generateFrom (memPartition t n) ≤ generateFrom (range t) := by\n  conv_rhs => rw [← generateFrom_iUnion_memPartition t]\n  exact generateFrom_mono (subset_iUnion _ _)\n\n"}
{"name":"MeasurableSpace.generateFrom_iUnion_memPartition_le","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nt : Nat → Set α\nht : ∀ (n : Nat), MeasurableSet (t n)\n⊢ LE.le (MeasurableSpace.generateFrom (Set.iUnion fun n => memPartition t n)) m","decl":"lemma generateFrom_iUnion_memPartition_le [m : MeasurableSpace α] {t : ℕ → Set α}\n    (ht : ∀ n, MeasurableSet (t n)) :\n    generateFrom (⋃ n, memPartition t n) ≤ m := by\n  refine (generateFrom_iUnion_memPartition t).trans_le (generateFrom_le ?_)\n  rintro s ⟨i, rfl⟩\n  exact ht i\n\n"}
{"name":"MeasurableSpace.generateFrom_memPartition_le","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nt : Nat → Set α\nht : ∀ (n : Nat), MeasurableSet (t n)\nn : Nat\n⊢ LE.le (MeasurableSpace.generateFrom (memPartition t n)) m","decl":"lemma generateFrom_memPartition_le [m : MeasurableSpace α] {t : ℕ → Set α}\n    (ht : ∀ n, MeasurableSet (t n)) (n : ℕ) :\n    generateFrom (memPartition t n) ≤ m :=\n  (generateFrom_mono (subset_iUnion _ _)).trans (generateFrom_iUnion_memPartition_le ht)\n\n"}
{"name":"MeasurableSpace.measurableSet_memPartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nt : Nat → Set α\nht : ∀ (n : Nat), MeasurableSet (t n)\nn : Nat\ns : Set α\nhs : Membership.mem (memPartition t n) s\n⊢ MeasurableSet s","decl":"lemma measurableSet_memPartition [MeasurableSpace α] {t : ℕ → Set α}\n    (ht : ∀ n, MeasurableSet (t n)) (n : ℕ) {s : Set α} (hs : s ∈ memPartition t n) :\n    MeasurableSet s :=\n  generateFrom_memPartition_le ht n _ (measurableSet_generateFrom hs)\n\n"}
{"name":"MeasurableSpace.measurableSet_memPartitionSet","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nt : Nat → Set α\nht : ∀ (n : Nat), MeasurableSet (t n)\nn : Nat\na : α\n⊢ MeasurableSet (memPartitionSet t n a)","decl":"lemma measurableSet_memPartitionSet [MeasurableSpace α] {t : ℕ → Set α}\n    (ht : ∀ n, MeasurableSet (t n)) (n : ℕ) (a : α) :\n    MeasurableSet (memPartitionSet t n a) :=\n  measurableSet_memPartition ht n (memPartitionSet_mem t n a)\n\n"}
{"name":"MeasurableSpace.measurableSet_enumerateCountable_countableGeneratingSet","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\nn : Nat\n⊢ MeasurableSet (Set.enumerateCountable ⋯ EmptyCollection.emptyCollection n)","decl":"lemma measurableSet_enumerateCountable_countableGeneratingSet\n    (α : Type*) [MeasurableSpace α] [CountablyGenerated α] (n : ℕ) :\n    MeasurableSet (enumerateCountable (countable_countableGeneratingSet (α := α)) ∅ n) :=\n  measurableSet_countableGeneratingSet\n    (enumerateCountable_mem _ (empty_mem_countableGeneratingSet) n)\n\n"}
{"name":"MeasurableSpace.finite_countablePartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\nn : Nat\n⊢ (MeasurableSpace.countablePartition α n).Finite","decl":"lemma finite_countablePartition (α : Type*) [MeasurableSpace α] [CountablyGenerated α] (n : ℕ) :\n    Set.Finite (countablePartition α n) :=\n  finite_memPartition _ n\n\n"}
{"name":"MeasurableSpace.instFinite_countablePartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\n⊢ Finite ↑(MeasurableSpace.countablePartition α n)","decl":"instance instFinite_countablePartition (n : ℕ) : Finite (countablePartition α n) :=\n  Set.finite_coe_iff.mp (finite_countablePartition _ _)\n\n"}
{"name":"MeasurableSpace.disjoint_countablePartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\ns t : Set α\nhs : Membership.mem (MeasurableSpace.countablePartition α n) s\nht : Membership.mem (MeasurableSpace.countablePartition α n) t\nhst : Ne s t\n⊢ Disjoint s t","decl":"lemma disjoint_countablePartition {n : ℕ} {s t : Set α}\n    (hs : s ∈ countablePartition α n) (ht : t ∈ countablePartition α n) (hst : s ≠ t) :\n    Disjoint s t :=\n  disjoint_memPartition _ n hs ht hst\n\n"}
{"name":"MeasurableSpace.sUnion_countablePartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\nn : Nat\n⊢ Eq (MeasurableSpace.countablePartition α n).sUnion Set.univ","decl":"lemma sUnion_countablePartition (α : Type*) [MeasurableSpace α] [CountablyGenerated α] (n : ℕ) :\n    ⋃₀ countablePartition α n = univ :=\n  sUnion_memPartition _ n\n\n"}
{"name":"MeasurableSpace.measurableSet_generateFrom_countablePartition_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\ns : Set α\n⊢ Iff (MeasurableSet s) (Exists fun S => And (HasSubset.Subset (↑S) (MeasurableSpace.countablePartition α n)) (Eq s (↑S).sUnion))","decl":"lemma measurableSet_generateFrom_countablePartition_iff (n : ℕ) (s : Set α) :\n    MeasurableSet[generateFrom (countablePartition α n)] s\n      ↔ ∃ S : Finset (Set α), ↑S ⊆ countablePartition α n ∧ s = ⋃₀ S :=\n  measurableSet_generateFrom_memPartition_iff _ n s\n\n"}
{"name":"MeasurableSpace.measurableSet_succ_countablePartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\ns : Set α\nhs : Membership.mem (MeasurableSpace.countablePartition α n) s\n⊢ MeasurableSet s","decl":"lemma measurableSet_succ_countablePartition (n : ℕ) {s : Set α} (hs : s ∈ countablePartition α n) :\n    MeasurableSet[generateFrom (countablePartition α (n + 1))] s :=\n  measurableSet_succ_memPartition _ _ hs\n\n"}
{"name":"MeasurableSpace.generateFrom_countablePartition_le_succ","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\nn : Nat\n⊢ LE.le (MeasurableSpace.generateFrom (MeasurableSpace.countablePartition α n)) (MeasurableSpace.generateFrom (MeasurableSpace.countablePartition α (HAdd.hAdd n 1)))","decl":"lemma generateFrom_countablePartition_le_succ (α : Type*) [MeasurableSpace α] [CountablyGenerated α]\n    (n : ℕ) :\n    generateFrom (countablePartition α n) ≤ generateFrom (countablePartition α (n + 1)) :=\n  generateFrom_memPartition_le_succ _ _\n\n"}
{"name":"MeasurableSpace.generateFrom_iUnion_countablePartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\nm : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\n⊢ Eq (MeasurableSpace.generateFrom (Set.iUnion fun n => MeasurableSpace.countablePartition α n)) m","decl":"lemma generateFrom_iUnion_countablePartition (α : Type*) [m : MeasurableSpace α]\n    [CountablyGenerated α] :\n    generateFrom (⋃ n, countablePartition α n) = m := by\n  rw [countablePartition, generateFrom_iUnion_memPartition,\n    range_enumerateCountable_of_mem _ empty_mem_countableGeneratingSet,\n    generateFrom_countableGeneratingSet]\n\n"}
{"name":"MeasurableSpace.generateFrom_countablePartition_le","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_3\nm : MeasurableSpace α\ninst✝ : MeasurableSpace.CountablyGenerated α\nn : Nat\n⊢ LE.le (MeasurableSpace.generateFrom (MeasurableSpace.countablePartition α n)) m","decl":"lemma generateFrom_countablePartition_le (α : Type*) [m : MeasurableSpace α] [CountablyGenerated α]\n    (n : ℕ) :\n    generateFrom (countablePartition α n) ≤ m :=\n  generateFrom_memPartition_le (measurableSet_enumerateCountable_countableGeneratingSet α) n\n\n"}
{"name":"MeasurableSpace.measurableSet_countablePartition","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\ns : Set α\nhs : Membership.mem (MeasurableSpace.countablePartition α n) s\n⊢ MeasurableSet s","decl":"lemma measurableSet_countablePartition (n : ℕ) {s : Set α} (hs : s ∈ countablePartition α n) :\n    MeasurableSet s :=\n  generateFrom_countablePartition_le α n _ (measurableSet_generateFrom hs)\n\n"}
{"name":"MeasurableSpace.countablePartitionSet_mem","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\na : α\n⊢ Membership.mem (MeasurableSpace.countablePartition α n) (MeasurableSpace.countablePartitionSet n a)","decl":"lemma countablePartitionSet_mem (n : ℕ) (a : α) :\n    countablePartitionSet n a ∈ countablePartition α n :=\n  memPartitionSet_mem _ _ _\n\n"}
{"name":"MeasurableSpace.mem_countablePartitionSet","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\na : α\n⊢ Membership.mem (MeasurableSpace.countablePartitionSet n a) a","decl":"lemma mem_countablePartitionSet (n : ℕ) (a : α) : a ∈ countablePartitionSet n a :=\n  mem_memPartitionSet _ _ _\n\n"}
{"name":"MeasurableSpace.countablePartitionSet_eq_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\na : α\ns : Set α\nhs : Membership.mem (MeasurableSpace.countablePartition α n) s\n⊢ Iff (Eq (MeasurableSpace.countablePartitionSet n a) s) (Membership.mem s a)","decl":"lemma countablePartitionSet_eq_iff {n : ℕ} (a : α) {s : Set α} (hs : s ∈ countablePartition α n) :\n    countablePartitionSet n a = s ↔ a ∈ s :=\n  memPartitionSet_eq_iff _ hs\n\n"}
{"name":"MeasurableSpace.countablePartitionSet_of_mem","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\na : α\ns : Set α\nhs : Membership.mem (MeasurableSpace.countablePartition α n) s\nha : Membership.mem s a\n⊢ Eq (MeasurableSpace.countablePartitionSet n a) s","decl":"lemma countablePartitionSet_of_mem {n : ℕ} {a : α} {s : Set α} (hs : s ∈ countablePartition α n)\n    (ha : a ∈ s) :\n    countablePartitionSet n a = s :=\n  memPartitionSet_of_mem hs ha\n\n"}
{"name":"MeasurableSpace.measurableSet_countablePartitionSet","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nh : MeasurableSpace.CountablyGenerated α\nn : Nat\na : α\n⊢ MeasurableSet (MeasurableSpace.countablePartitionSet n a)","decl":"@[measurability]\nlemma measurableSet_countablePartitionSet (n : ℕ) (a : α) :\n    MeasurableSet (countablePartitionSet n a) :=\n  measurableSet_countablePartition n (countablePartitionSet_mem n a)\n\n"}
{"name":"MeasurableSpace.CountableOrCountablyGenerated.countableOrCountablyGenerated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nself : MeasurableSpace.CountableOrCountablyGenerated α β\n⊢ Or (Countable α) (MeasurableSpace.CountablyGenerated β)","decl":"/-- A class registering that either `α` is countable or `β` is a countably generated\nmeasurable space. -/\nclass CountableOrCountablyGenerated (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] :\n    Prop where\n  countableOrCountablyGenerated : Countable α ∨ MeasurableSpace.CountablyGenerated β\n\n"}
{"name":"MeasurableSpace.instCountableOrCountablyGeneratedOfCountable","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"β : Type u_2\nα : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nh1 : Countable α\n⊢ MeasurableSpace.CountableOrCountablyGenerated α β","decl":"instance instCountableOrCountablyGeneratedOfCountable [h1 : Countable α] :\n    CountableOrCountablyGenerated α β := ⟨Or.inl h1⟩\n\n"}
{"name":"MeasurableSpace.instCountableOrCountablyGeneratedOfCountablyGenerated","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"β : Type u_2\nα : Type u_3\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nh : MeasurableSpace.CountablyGenerated β\n⊢ MeasurableSpace.CountableOrCountablyGenerated α β","decl":"instance instCountableOrCountablyGeneratedOfCountablyGenerated [h : CountablyGenerated β] :\n    CountableOrCountablyGenerated α β := ⟨Or.inr h⟩\n\n"}
{"name":"MeasurableSpace.instCountableOrCountablyGeneratedProd","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"β : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nhα : MeasurableSpace.CountableOrCountablyGenerated α γ\nhβ : MeasurableSpace.CountableOrCountablyGenerated β γ\n⊢ MeasurableSpace.CountableOrCountablyGenerated (Prod α β) γ","decl":"instance [hα : CountableOrCountablyGenerated α γ] [hβ : CountableOrCountablyGenerated β γ] :\n    CountableOrCountablyGenerated (α × β) γ := by\n  rcases hα with (hα | hα) <;> rcases hβ with (hβ | hβ) <;> infer_instance\n\n"}
{"name":"MeasurableSpace.countableOrCountablyGenerated_left_of_prod_left_of_nonempty","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"β : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : MeasurableSpace γ\ninst✝ : Nonempty β\nh : MeasurableSpace.CountableOrCountablyGenerated (Prod α β) γ\n⊢ MeasurableSpace.CountableOrCountablyGenerated α γ","decl":"lemma countableOrCountablyGenerated_left_of_prod_left_of_nonempty [Nonempty β]\n    [h : CountableOrCountablyGenerated (α × β) γ] :\n    CountableOrCountablyGenerated α γ := by\n  rcases h.countableOrCountablyGenerated with (h | h)\n  · have := countable_left_of_prod_of_nonempty h\n    infer_instance\n  · infer_instance\n\n"}
{"name":"MeasurableSpace.countableOrCountablyGenerated_right_of_prod_left_of_nonempty","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"β : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : MeasurableSpace γ\ninst✝ : Nonempty α\nh : MeasurableSpace.CountableOrCountablyGenerated (Prod α β) γ\n⊢ MeasurableSpace.CountableOrCountablyGenerated β γ","decl":"lemma countableOrCountablyGenerated_right_of_prod_left_of_nonempty [Nonempty α]\n    [h : CountableOrCountablyGenerated (α × β) γ] :\n    CountableOrCountablyGenerated β γ := by\n  rcases h.countableOrCountablyGenerated with (h | h)\n  · have := countable_right_of_prod_of_nonempty h\n    infer_instance\n  · infer_instance\n\n"}
{"name":"MeasurableSpace.countableOrCountablyGenerated_prod_left_swap","module":"Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated","initialProofState":"β : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nh : MeasurableSpace.CountableOrCountablyGenerated (Prod α β) γ\n⊢ MeasurableSpace.CountableOrCountablyGenerated (Prod β α) γ","decl":"lemma countableOrCountablyGenerated_prod_left_swap [h : CountableOrCountablyGenerated (α × β) γ] :\n    CountableOrCountablyGenerated (β × α) γ := by\n  rcases h with (h | h)\n  · refine ⟨Or.inl countable_prod_swap⟩\n  · exact ⟨Or.inr h⟩\n\n"}
