{"name":"Encodable.iSup_decode₂","module":"Mathlib.Logic.Encodable.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Encodable β\ninst✝ : CompleteLattice α\nf : β → α\n⊢ Eq (iSup fun i => iSup fun b => iSup fun h => f b) (iSup fun b => f b)","decl":"theorem iSup_decode₂ [CompleteLattice α] (f : β → α) :\n    ⨆ (i : ℕ) (b ∈ decode₂ β i), f b = (⨆ b, f b) := by\n  rw [iSup_comm]\n  simp only [mem_decode₂, iSup_iSup_eq_right]\n\n"}
{"name":"Encodable.iUnion_decode₂","module":"Mathlib.Logic.Encodable.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Encodable β\nf : β → Set α\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun b => Set.iUnion fun h => f b) (Set.iUnion fun b => f b)","decl":"theorem iUnion_decode₂ (f : β → Set α) : ⋃ (i : ℕ) (b ∈ decode₂ β i), f b = ⋃ b, f b :=\n  iSup_decode₂ f\n\n"}
{"name":"Encodable.iUnion_decode₂_cases","module":"Mathlib.Logic.Encodable.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Encodable β\nf : β → Set α\nC : Set α → Prop\nH0 : C EmptyCollection.emptyCollection\nH1 : ∀ (b : β), C (f b)\nn : Nat\n⊢ C (Set.iUnion fun b => Set.iUnion fun h => f b)","decl":"@[elab_as_elim]\ntheorem iUnion_decode₂_cases {f : β → Set α} {C : Set α → Prop} (H0 : C ∅) (H1 : ∀ b, C (f b)) {n} :\n    C (⋃ b ∈ decode₂ β n, f b) :=\n  match decode₂ β n with\n  | none => by\n    simp only [Option.mem_def, iUnion_of_empty, iUnion_empty, reduceCtorEq]\n    apply H0\n  | some b => by\n    convert H1 b\n    simp [Set.ext_iff]\n\n"}
{"name":"Encodable.iUnion_decode₂_disjoint_on","module":"Mathlib.Logic.Encodable.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Encodable β\nf : β → Set α\nhd : Pairwise (Function.onFun Disjoint f)\n⊢ Pairwise (Function.onFun Disjoint fun i => Set.iUnion fun b => Set.iUnion fun h => f b)","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem iUnion_decode₂_disjoint_on {f : β → Set α} (hd : Pairwise (Disjoint on f)) :\n    Pairwise (Disjoint on fun i => ⋃ b ∈ decode₂ β i, f b) := by\n  rintro i j ij\n  refine disjoint_left.mpr fun x => ?_\n  suffices ∀ a, encode a = i → x ∈ f a → ∀ b, encode b = j → x ∉ f b by simpa [decode₂_eq_some]\n  rintro a rfl ha b rfl hb\n  exact (hd (mt (congr_arg encode) ij)).le_bot ⟨ha, hb⟩\n\n"}
