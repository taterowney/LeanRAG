{"name":"Matrix.circulant_apply","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : Sub n\nv : n → α\ni j : n\n⊢ Eq (Matrix.circulant v i j) (v (HSub.hSub i j))","decl":"@[simp]\ntheorem circulant_apply [Sub n] (v : n → α) (i j) : circulant v i j = v (i - j) := rfl\n\n"}
{"name":"Matrix.circulant_col_zero_eq","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : AddGroup n\nv : n → α\ni : n\n⊢ Eq (Matrix.circulant v i 0) (v i)","decl":"theorem circulant_col_zero_eq [AddGroup n] (v : n → α) (i : n) : circulant v i 0 = v i :=\n  congr_arg v (sub_zero _)\n\n"}
{"name":"Matrix.circulant_injective","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : AddGroup n\n⊢ Function.Injective Matrix.circulant","decl":"theorem circulant_injective [AddGroup n] : Injective (circulant : (n → α) → Matrix n n α) := by\n  intro v w h\n  ext k\n  rw [← circulant_col_zero_eq v, ← circulant_col_zero_eq w, h]\n\n"}
{"name":"Matrix.Fin.circulant_injective","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Nat\n⊢ Function.Injective fun v => Matrix.circulant v","decl":"theorem Fin.circulant_injective : ∀ n, Injective fun v : Fin n → α => circulant v\n  | 0 => by simp [Injective]\n  | _ + 1 => Matrix.circulant_injective\n\n"}
{"name":"Matrix.circulant_inj","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : AddGroup n\nv w : n → α\n⊢ Iff (Eq (Matrix.circulant v) (Matrix.circulant w)) (Eq v w)","decl":"@[simp]\ntheorem circulant_inj [AddGroup n] {v w : n → α} : circulant v = circulant w ↔ v = w :=\n  circulant_injective.eq_iff\n\n"}
{"name":"Matrix.Fin.circulant_inj","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Nat\nv w : Fin n → α\n⊢ Iff (Eq (Matrix.circulant v) (Matrix.circulant w)) (Eq v w)","decl":"@[simp]\ntheorem Fin.circulant_inj {n} {v w : Fin n → α} : circulant v = circulant w ↔ v = w :=\n  (Fin.circulant_injective n).eq_iff\n\n"}
{"name":"Matrix.transpose_circulant","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : AddGroup n\nv : n → α\n⊢ Eq (Matrix.circulant v).transpose (Matrix.circulant fun i => v (Neg.neg i))","decl":"theorem transpose_circulant [AddGroup n] (v : n → α) :\n    (circulant v)ᵀ = circulant fun i => v (-i) := by ext; simp\n\n"}
{"name":"Matrix.conjTranspose_circulant","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : Star α\ninst✝ : AddGroup n\nv : n → α\n⊢ Eq (Matrix.circulant v).conjTranspose (Matrix.circulant (Star.star fun i => v (Neg.neg i)))","decl":"theorem conjTranspose_circulant [Star α] [AddGroup n] (v : n → α) :\n    (circulant v)ᴴ = circulant (star fun i => v (-i)) := by ext; simp\n\n"}
{"name":"Matrix.Fin.transpose_circulant","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Nat\nv : Fin n → α\n⊢ Eq (Matrix.circulant v).transpose (Matrix.circulant fun i => v (Neg.neg i))","decl":"theorem Fin.transpose_circulant : ∀ {n} (v : Fin n → α), (circulant v)ᵀ = circulant fun i => v (-i)\n  | 0 => by simp [Injective, eq_iff_true_of_subsingleton]\n  | _ + 1 => Matrix.transpose_circulant\n\n"}
{"name":"Matrix.Fin.conjTranspose_circulant","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\ninst✝ : Star α\nn : Nat\nv : Fin n → α\n⊢ Eq (Matrix.circulant v).conjTranspose (Matrix.circulant (Star.star fun i => v (Neg.neg i)))","decl":"theorem Fin.conjTranspose_circulant [Star α] :\n    ∀ {n} (v : Fin n → α), (circulant v)ᴴ = circulant (star fun i => v (-i))\n  | 0 => by simp [Injective, eq_iff_true_of_subsingleton]\n  | _ + 1 => Matrix.conjTranspose_circulant\n\n"}
{"name":"Matrix.map_circulant","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Type u_3\ninst✝ : Sub n\nv : n → α\nf : α → β\n⊢ Eq ((Matrix.circulant v).map f) (Matrix.circulant fun i => f (v i))","decl":"theorem map_circulant [Sub n] (v : n → α) (f : α → β) :\n    (circulant v).map f = circulant fun i => f (v i) :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.circulant_neg","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : Neg α\ninst✝ : Sub n\nv : n → α\n⊢ Eq (Matrix.circulant (Neg.neg v)) (Neg.neg (Matrix.circulant v))","decl":"theorem circulant_neg [Neg α] [Sub n] (v : n → α) : circulant (-v) = -circulant v :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.circulant_zero","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_5\nn : Type u_6\ninst✝¹ : Zero α\ninst✝ : Sub n\n⊢ Eq (Matrix.circulant 0) 0","decl":"@[simp]\ntheorem circulant_zero (α n) [Zero α] [Sub n] : circulant 0 = (0 : Matrix n n α) :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.circulant_add","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : Add α\ninst✝ : Sub n\nv w : n → α\n⊢ Eq (Matrix.circulant (HAdd.hAdd v w)) (HAdd.hAdd (Matrix.circulant v) (Matrix.circulant w))","decl":"theorem circulant_add [Add α] [Sub n] (v w : n → α) :\n    circulant (v + w) = circulant v + circulant w :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.circulant_sub","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : Sub α\ninst✝ : Sub n\nv w : n → α\n⊢ Eq (Matrix.circulant (HSub.hSub v w)) (HSub.hSub (Matrix.circulant v) (Matrix.circulant w))","decl":"theorem circulant_sub [Sub α] [Sub n] (v w : n → α) :\n    circulant (v - w) = circulant v - circulant w :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.circulant_mul","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝² : Semiring α\ninst✝¹ : Fintype n\ninst✝ : AddGroup n\nv w : n → α\n⊢ Eq (HMul.hMul (Matrix.circulant v) (Matrix.circulant w)) (Matrix.circulant ((Matrix.circulant v).mulVec w))","decl":"/-- The product of two circulant matrices `circulant v` and `circulant w` is\n    the circulant matrix generated by `circulant v *ᵥ w`. -/\ntheorem circulant_mul [Semiring α] [Fintype n] [AddGroup n] (v w : n → α) :\n    circulant v * circulant w = circulant (circulant v *ᵥ w) := by\n  ext i j\n  simp only [mul_apply, mulVec, circulant_apply, dotProduct]\n  refine Fintype.sum_equiv (Equiv.subRight j) _ _ ?_\n  intro x\n  simp only [Equiv.subRight_apply, sub_sub_sub_cancel_right]\n\n"}
{"name":"Matrix.Fin.circulant_mul","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nn : Nat\nv w : Fin n → α\n⊢ Eq (HMul.hMul (Matrix.circulant v) (Matrix.circulant w)) (Matrix.circulant ((Matrix.circulant v).mulVec w))","decl":"theorem Fin.circulant_mul [Semiring α] :\n    ∀ {n} (v w : Fin n → α), circulant v * circulant w = circulant (circulant v *ᵥ w)\n  | 0 => by simp [Injective, eq_iff_true_of_subsingleton]\n  | _ + 1 => Matrix.circulant_mul\n\n"}
{"name":"Matrix.circulant_mul_comm","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝³ : CommSemigroup α\ninst✝² : AddCommMonoid α\ninst✝¹ : Fintype n\ninst✝ : AddCommGroup n\nv w : n → α\n⊢ Eq (HMul.hMul (Matrix.circulant v) (Matrix.circulant w)) (HMul.hMul (Matrix.circulant w) (Matrix.circulant v))","decl":"/-- Multiplication of circulant matrices commutes when the elements do. -/\ntheorem circulant_mul_comm [CommSemigroup α] [AddCommMonoid α] [Fintype n] [AddCommGroup n]\n    (v w : n → α) : circulant v * circulant w = circulant w * circulant v := by\n  ext i j\n  simp only [mul_apply, circulant_apply, mul_comm]\n  refine Fintype.sum_equiv ((Equiv.subLeft i).trans (Equiv.addRight j)) _ _ ?_\n  intro x\n  simp only [Equiv.trans_apply, Equiv.subLeft_apply, Equiv.coe_addRight, add_sub_cancel_right,\n    mul_comm]\n  congr 2\n  abel\n\n"}
{"name":"Matrix.Fin.circulant_mul_comm","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\ninst✝¹ : CommSemigroup α\ninst✝ : AddCommMonoid α\nn : Nat\nv w : Fin n → α\n⊢ Eq (HMul.hMul (Matrix.circulant v) (Matrix.circulant w)) (HMul.hMul (Matrix.circulant w) (Matrix.circulant v))","decl":"theorem Fin.circulant_mul_comm [CommSemigroup α] [AddCommMonoid α] :\n    ∀ {n} (v w : Fin n → α), circulant v * circulant w = circulant w * circulant v\n  | 0 => by simp [Injective]\n  | _ + 1 => Matrix.circulant_mul_comm\n\n"}
{"name":"Matrix.circulant_smul","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\nR : Type u_4\ninst✝¹ : Sub n\ninst✝ : SMul R α\nk : R\nv : n → α\n⊢ Eq (Matrix.circulant (HSMul.hSMul k v)) (HSMul.hSMul k (Matrix.circulant v))","decl":"/-- `k • circulant v` is another circulant matrix `circulant (k • v)`. -/\ntheorem circulant_smul [Sub n] [SMul R α] (k : R) (v : n → α) :\n    circulant (k • v) = k • circulant v := rfl\n\n"}
{"name":"Matrix.circulant_single_one","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_5\nn : Type u_6\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : DecidableEq n\ninst✝ : AddGroup n\n⊢ Eq (Matrix.circulant (Pi.single 0 1)) 1","decl":"@[simp]\ntheorem circulant_single_one (α n) [Zero α] [One α] [DecidableEq n] [AddGroup n] :\n    circulant (Pi.single 0 1 : n → α) = (1 : Matrix n n α) := by\n  ext i j\n  simp [one_apply, Pi.single_apply, sub_eq_zero]\n\n"}
{"name":"Matrix.circulant_single","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_5\ninst✝³ : Semiring α\ninst✝² : DecidableEq n\ninst✝¹ : AddGroup n\ninst✝ : Fintype n\na : α\n⊢ Eq (Matrix.circulant (Pi.single 0 a)) ((Matrix.scalar n) a)","decl":"@[simp]\ntheorem circulant_single (n) [Semiring α] [DecidableEq n] [AddGroup n] [Fintype n] (a : α) :\n    circulant (Pi.single 0 a : n → α) = scalar n a := by\n  ext i j\n  simp [Pi.single_apply, diagonal_apply, sub_eq_zero]\n\n"}
{"name":"Matrix.Fin.circulant_ite","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_5\ninst✝¹ : Zero α\ninst✝ : One α\nn : Nat\n⊢ Eq (Matrix.circulant fun i => ite (Eq (↑i) 0) 1 0) 1","decl":"/-- Note we use `↑i = 0` instead of `i = 0` as `Fin 0` has no `0`.\nThis means that we cannot state this with `Pi.single` as we did with `Matrix.circulant_single`. -/\ntheorem Fin.circulant_ite (α) [Zero α] [One α] :\n    ∀ n, circulant (fun i => ite (i.1 = 0) 1 0 : Fin n → α) = 1\n  | 0 => by simp [Injective, eq_iff_true_of_subsingleton]\n  | n + 1 => by\n    rw [← circulant_single_one]\n    congr with j\n    simp [Pi.single_apply, Fin.ext_iff]\n\n"}
{"name":"Matrix.circulant_isSymm_iff","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : AddGroup n\nv : n → α\n⊢ Iff (Matrix.circulant v).IsSymm (∀ (i : n), Eq (v (Neg.neg i)) (v i))","decl":"/-- A circulant of `v` is symmetric iff `v` equals its reverse. -/\ntheorem circulant_isSymm_iff [AddGroup n] {v : n → α} :\n    (circulant v).IsSymm ↔ ∀ i, v (-i) = v i := by\n  rw [IsSymm, transpose_circulant, circulant_inj, funext_iff]\n\n"}
{"name":"Matrix.Fin.circulant_isSymm_iff","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Nat\nv : Fin n → α\n⊢ Iff (Matrix.circulant v).IsSymm (∀ (i : Fin n), Eq (v (Neg.neg i)) (v i))","decl":"theorem Fin.circulant_isSymm_iff : ∀ {n} {v : Fin n → α}, (circulant v).IsSymm ↔ ∀ i, v (-i) = v i\n  | 0 => by simp [IsSymm.ext_iff, IsEmpty.forall_iff]\n  | _ + 1 => Matrix.circulant_isSymm_iff\n\n"}
{"name":"Matrix.circulant_isSymm_apply","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝ : AddGroup n\nv : n → α\nh : (Matrix.circulant v).IsSymm\ni : n\n⊢ Eq (v (Neg.neg i)) (v i)","decl":"/-- If `circulant v` is symmetric, `∀ i j : I, v (- i) = v i`. -/\ntheorem circulant_isSymm_apply [AddGroup n] {v : n → α} (h : (circulant v).IsSymm) (i : n) :\n    v (-i) = v i :=\n  circulant_isSymm_iff.1 h i\n\n"}
{"name":"Matrix.Fin.circulant_isSymm_apply","module":"Mathlib.LinearAlgebra.Matrix.Circulant","initialProofState":"α : Type u_1\nn : Nat\nv : Fin n → α\nh : (Matrix.circulant v).IsSymm\ni : Fin n\n⊢ Eq (v (Neg.neg i)) (v i)","decl":"theorem Fin.circulant_isSymm_apply {n} {v : Fin n → α} (h : (circulant v).IsSymm) (i : Fin n) :\n    v (-i) = v i :=\n  Fin.circulant_isSymm_iff.1 h i\n\n"}
