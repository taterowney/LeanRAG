{"name":"TopologicalSpace.IsTopologicalBasis.exists_subset_inter","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set (Set Œ±)\nself : TopologicalSpace.IsTopologicalBasis s\nt‚ÇÅ : Set Œ±\na‚úù¬≤ : Membership.mem s t‚ÇÅ\nt‚ÇÇ : Set Œ±\na‚úù¬π : Membership.mem s t‚ÇÇ\nx : Œ±\na‚úù : Membership.mem (Inter.inter t‚ÇÅ t‚ÇÇ) x\n‚ä¢ Exists fun t‚ÇÉ => And (Membership.mem s t‚ÇÉ) (And (Membership.mem t‚ÇÉ x) (HasSubset.Subset t‚ÇÉ (Inter.inter t‚ÇÅ t‚ÇÇ)))","decl":"/-- A topological basis is one that satisfies the necessary conditions so that\n  it suffices to take unions of the basis sets to get a topology (without taking\n  finite intersections as well). -/\nstructure IsTopologicalBasis (s : Set (Set Œ±)) : Prop where\n  /-- For every point `x`, the set of `t ‚àà s` such that `x ‚àà t` is directed downwards. -/\n  exists_subset_inter : ‚àÄ t‚ÇÅ ‚àà s, ‚àÄ t‚ÇÇ ‚àà s, ‚àÄ x ‚àà t‚ÇÅ ‚à© t‚ÇÇ, ‚àÉ t‚ÇÉ ‚àà s, x ‚àà t‚ÇÉ ‚àß t‚ÇÉ ‚äÜ t‚ÇÅ ‚à© t‚ÇÇ\n  /-- The sets from `s` cover the whole space. -/\n  sUnion_eq : ‚ãÉ‚ÇÄ s = univ\n  /-- The topology is generated by sets from `s`. -/\n  eq_generateFrom : t = generateFrom s\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.eq_generateFrom","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set (Set Œ±)\nself : TopologicalSpace.IsTopologicalBasis s\n‚ä¢ Eq t (TopologicalSpace.generateFrom s)","decl":"/-- A topological basis is one that satisfies the necessary conditions so that\n  it suffices to take unions of the basis sets to get a topology (without taking\n  finite intersections as well). -/\nstructure IsTopologicalBasis (s : Set (Set Œ±)) : Prop where\n  /-- For every point `x`, the set of `t ‚àà s` such that `x ‚àà t` is directed downwards. -/\n  exists_subset_inter : ‚àÄ t‚ÇÅ ‚àà s, ‚àÄ t‚ÇÇ ‚àà s, ‚àÄ x ‚àà t‚ÇÅ ‚à© t‚ÇÇ, ‚àÉ t‚ÇÉ ‚àà s, x ‚àà t‚ÇÉ ‚àß t‚ÇÉ ‚äÜ t‚ÇÅ ‚à© t‚ÇÇ\n  /-- The sets from `s` cover the whole space. -/\n  sUnion_eq : ‚ãÉ‚ÇÄ s = univ\n  /-- The topology is generated by sets from `s`. -/\n  eq_generateFrom : t = generateFrom s\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.sUnion_eq","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set (Set Œ±)\nself : TopologicalSpace.IsTopologicalBasis s\n‚ä¢ Eq s.sUnion Set.univ","decl":"/-- A topological basis is one that satisfies the necessary conditions so that\n  it suffices to take unions of the basis sets to get a topology (without taking\n  finite intersections as well). -/\nstructure IsTopologicalBasis (s : Set (Set Œ±)) : Prop where\n  /-- For every point `x`, the set of `t ‚àà s` such that `x ‚àà t` is directed downwards. -/\n  exists_subset_inter : ‚àÄ t‚ÇÅ ‚àà s, ‚àÄ t‚ÇÇ ‚àà s, ‚àÄ x ‚àà t‚ÇÅ ‚à© t‚ÇÇ, ‚àÉ t‚ÇÉ ‚àà s, x ‚àà t‚ÇÉ ‚àß t‚ÇÉ ‚äÜ t‚ÇÅ ‚à© t‚ÇÇ\n  /-- The sets from `s` cover the whole space. -/\n  sUnion_eq : ‚ãÉ‚ÇÄ s = univ\n  /-- The topology is generated by sets from `s`. -/\n  eq_generateFrom : t = generateFrom s\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.insert_empty","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set (Set Œ±)\nh : TopologicalSpace.IsTopologicalBasis s\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Insert.insert EmptyCollection.emptyCollection s)","decl":"theorem IsTopologicalBasis.insert_empty {s : Set (Set Œ±)} (h : IsTopologicalBasis s) :\n    IsTopologicalBasis (insert ‚àÖ s) := by\n  refine ‚ü®?_, by rw [sUnion_insert, empty_union, h.sUnion_eq], ?_‚ü©\n  ¬∑ rintro t‚ÇÅ (rfl | h‚ÇÅ) t‚ÇÇ (rfl | h‚ÇÇ) x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©\n    ¬∑ cases hx‚ÇÅ\n    ¬∑ cases hx‚ÇÅ\n    ¬∑ cases hx‚ÇÇ\n    ¬∑ obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©\n      exact ‚ü®t‚ÇÉ, .inr h‚ÇÉ, hs‚ü©\n  ¬∑ rw [h.eq_generateFrom]\n    refine le_antisymm (le_generateFrom fun t => ?_) (generateFrom_anti <| subset_insert ‚àÖ s)\n    rintro (rfl | ht)\n    ¬∑ exact @isOpen_empty _ (generateFrom s)\n    ¬∑ exact .basic t ht\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.diff_empty","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set (Set Œ±)\nh : TopologicalSpace.IsTopologicalBasis s\n‚ä¢ TopologicalSpace.IsTopologicalBasis (SDiff.sdiff s (Singleton.singleton EmptyCollection.emptyCollection))","decl":"theorem IsTopologicalBasis.diff_empty {s : Set (Set Œ±)} (h : IsTopologicalBasis s) :\n    IsTopologicalBasis (s \\ {‚àÖ}) := by\n  refine ‚ü®?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_‚ü©\n  ¬∑ rintro t‚ÇÅ ‚ü®h‚ÇÅ, -‚ü© t‚ÇÇ ‚ü®h‚ÇÇ, -‚ü© x hx\n    obtain ‚ü®t‚ÇÉ, h‚ÇÉ, hs‚ü© := h.exists_subset_inter _ h‚ÇÅ _ h‚ÇÇ x hx\n    exact ‚ü®t‚ÇÉ, ‚ü®h‚ÇÉ, Nonempty.ne_empty ‚ü®x, hs.1‚ü©‚ü©, hs‚ü©\n  ¬∑ rw [h.eq_generateFrom]\n    refine le_antisymm (generateFrom_anti diff_subset) (le_generateFrom fun t ht => ?_)\n    obtain rfl | he := eq_or_ne t ‚àÖ\n    ¬∑ exact @isOpen_empty _ (generateFrom _)\n    ¬∑ exact .basic t ‚ü®ht, he‚ü©\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_subbasis","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set (Set Œ±)\nhs : Eq t (TopologicalSpace.generateFrom s)\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image (fun f => f.sInter) (setOf fun f => And f.Finite (HasSubset.Subset f s)))","decl":"/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem isTopologicalBasis_of_subbasis {s : Set (Set Œ±)} (hs : t = generateFrom s) :\n    IsTopologicalBasis ((fun f => ‚ãÇ‚ÇÄ f) '' { f : Set (Set Œ±) | f.Finite ‚àß f ‚äÜ s }) := by\n  subst t; letI := generateFrom s\n  refine ‚ü®?_, ?_, le_antisymm (le_generateFrom ?_) <| generateFrom_anti fun t ht => ?_‚ü©\n  ¬∑ rintro _ ‚ü®t‚ÇÅ, ‚ü®hft‚ÇÅ, ht‚ÇÅb‚ü©, rfl‚ü© _ ‚ü®t‚ÇÇ, ‚ü®hft‚ÇÇ, ht‚ÇÇb‚ü©, rfl‚ü© x h\n    exact ‚ü®_, ‚ü®_, ‚ü®hft‚ÇÅ.union hft‚ÇÇ, union_subset ht‚ÇÅb ht‚ÇÇb‚ü©, sInter_union t‚ÇÅ t‚ÇÇ‚ü©, h, Subset.rfl‚ü©\n  ¬∑ rw [sUnion_image, iUnion‚ÇÇ_eq_univ_iff]\n    exact fun x => ‚ü®‚àÖ, ‚ü®finite_empty, empty_subset _‚ü©, sInter_empty.substr <| mem_univ x‚ü©\n  ¬∑ rintro _ ‚ü®t, ‚ü®hft, htb‚ü©, rfl‚ü©\n    exact hft.isOpen_sInter fun s hs ‚Ü¶ GenerateOpen.basic _ <| htb hs\n  ¬∑ rw [‚Üê sInter_singleton t]\n    exact ‚ü®{t}, ‚ü®finite_singleton t, singleton_subset_iff.2 ht‚ü©, rfl‚ü©\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_subbasis_of_finiteInter","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set (Set Œ±)\nhsg : Eq t (TopologicalSpace.generateFrom s)\nhsi : FiniteInter s\n‚ä¢ TopologicalSpace.IsTopologicalBasis s","decl":"theorem isTopologicalBasis_of_subbasis_of_finiteInter {s : Set (Set Œ±)} (hsg : t = generateFrom s)\n    (hsi : FiniteInter s) : IsTopologicalBasis s := by\n  convert isTopologicalBasis_of_subbasis hsg\n  refine le_antisymm (fun t ht ‚Ü¶ ‚ü®{t}, by simpa using ht‚ü©) ?_\n  rintro _ ‚ü®g, ‚ü®hg, hgs‚ü©, rfl‚ü©\n  lift g to Finset (Set Œ±) using hg\n  exact hsi.finiteInter_mem g hgs\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_subbasis_of_inter","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nr : Set (Set Œ±)\nhsg : Eq t (TopologicalSpace.generateFrom r)\nhsi : ‚àÄ ‚¶És : Set Œ±‚¶Ñ, Membership.mem r s ‚Üí ‚àÄ ‚¶Ét : Set Œ±‚¶Ñ, Membership.mem r t ‚Üí Membership.mem r (Inter.inter s t)\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Insert.insert Set.univ r)","decl":"theorem isTopologicalBasis_of_subbasis_of_inter {r : Set (Set Œ±)} (hsg : t = generateFrom r)\n    (hsi : ‚àÄ ‚¶És‚¶Ñ, s ‚àà r ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà r ‚Üí s ‚à© t ‚àà r) : IsTopologicalBasis (insert univ r) :=\n  isTopologicalBasis_of_subbasis_of_finiteInter (by simpa using hsg) (FiniteInter.mk‚ÇÇ hsi)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.of_hasBasis_nhds","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set (Set Œ±)\nh_nhds : ‚àÄ (a : Œ±), (nhds a).HasBasis (fun t => And (Membership.mem s t) (Membership.mem t a)) id\n‚ä¢ TopologicalSpace.IsTopologicalBasis s","decl":"theorem IsTopologicalBasis.of_hasBasis_nhds {s : Set (Set Œ±)}\n    (h_nhds : ‚àÄ a, (ùìù a).HasBasis (fun t ‚Ü¶ t ‚àà s ‚àß a ‚àà t) id) : IsTopologicalBasis s where\n  exists_subset_inter t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ x hx := by\n    simpa only [and_assoc, (h_nhds x).mem_iff]\n      using (inter_mem ((h_nhds _).mem_of_mem ‚ü®ht‚ÇÅ, hx.1‚ü©) ((h_nhds _).mem_of_mem ‚ü®ht‚ÇÇ, hx.2‚ü©))\n  sUnion_eq := sUnion_eq_univ_iff.2 fun x ‚Ü¶ (h_nhds x).ex_mem\n  eq_generateFrom := ext_nhds fun x ‚Ü¶ by\n    simpa only [nhds_generateFrom, and_comm] using (h_nhds x).eq_biInf\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set (Set Œ±)\nh_open : ‚àÄ (u : Set Œ±), Membership.mem s u ‚Üí IsOpen u\nh_nhds : ‚àÄ (a : Œ±) (u : Set Œ±), Membership.mem u a ‚Üí IsOpen u ‚Üí Exists fun v => And (Membership.mem s v) (And (Membership.mem v a) (HasSubset.Subset v u))\n‚ä¢ TopologicalSpace.IsTopologicalBasis s","decl":"/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem isTopologicalBasis_of_isOpen_of_nhds {s : Set (Set Œ±)} (h_open : ‚àÄ u ‚àà s, IsOpen u)\n    (h_nhds : ‚àÄ (a : Œ±) (u : Set Œ±), a ‚àà u ‚Üí IsOpen u ‚Üí ‚àÉ v ‚àà s, a ‚àà v ‚àß v ‚äÜ u) :\n    IsTopologicalBasis s :=\n  .of_hasBasis_nhds <| fun a ‚Ü¶\n    (nhds_basis_opens a).to_hasBasis' (by simpa [and_assoc] using h_nhds a)\n      fun _ ‚ü®hts, hat‚ü© ‚Ü¶ (h_open _ hts).mem_nhds hat\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.mem_nhds_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\na : Œ±\ns : Set Œ±\nb : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis b\n‚ä¢ Iff (Membership.mem (nhds a) s) (Exists fun t => And (Membership.mem b t) (And (Membership.mem t a) (HasSubset.Subset t s)))","decl":"/-- A set `s` is in the neighbourhood of `a` iff there is some basis set `t`, which\ncontains `a` and is itself contained in `s`. -/\ntheorem IsTopologicalBasis.mem_nhds_iff {a : Œ±} {s : Set Œ±} {b : Set (Set Œ±)}\n    (hb : IsTopologicalBasis b) : s ‚àà ùìù a ‚Üî ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s := by\n  change s ‚àà (ùìù a).sets ‚Üî ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s\n  rw [hb.eq_generateFrom, nhds_generateFrom, biInf_sets_eq]\n  ¬∑ simp [and_assoc, and_left_comm]\n  ¬∑ rintro s ‚ü®hs‚ÇÅ, hs‚ÇÇ‚ü© t ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü©\n    let ‚ü®u, hu‚ÇÅ, hu‚ÇÇ, hu‚ÇÉ‚ü© := hb.1 _ hs‚ÇÇ _ ht‚ÇÇ _ ‚ü®hs‚ÇÅ, ht‚ÇÅ‚ü©\n    exact ‚ü®u, ‚ü®hu‚ÇÇ, hu‚ÇÅ‚ü©, le_principal_iff.2 (hu‚ÇÉ.trans inter_subset_left),\n      le_principal_iff.2 (hu‚ÇÉ.trans inter_subset_right)‚ü©\n  ¬∑ rcases eq_univ_iff_forall.1 hb.sUnion_eq a with ‚ü®i, h1, h2‚ü©\n    exact ‚ü®i, h2, h1‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isOpen_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\nb : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis b\n‚ä¢ Iff (IsOpen s) (‚àÄ (a : Œ±), Membership.mem s a ‚Üí Exists fun t => And (Membership.mem b t) (And (Membership.mem t a) (HasSubset.Subset t s)))","decl":"theorem IsTopologicalBasis.isOpen_iff {s : Set Œ±} {b : Set (Set Œ±)} (hb : IsTopologicalBasis b) :\n    IsOpen s ‚Üî ‚àÄ a ‚àà s, ‚àÉ t ‚àà b, a ‚àà t ‚àß t ‚äÜ s := by simp [isOpen_iff_mem_nhds, hb.mem_nhds_iff]\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.nhds_hasBasis","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nb : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis b\na : Œ±\n‚ä¢ (nhds a).HasBasis (fun t => And (Membership.mem b t) (Membership.mem t a)) fun t => t","decl":"theorem IsTopologicalBasis.nhds_hasBasis {b : Set (Set Œ±)} (hb : IsTopologicalBasis b) {a : Œ±} :\n    (ùìù a).HasBasis (fun t : Set Œ± => t ‚àà b ‚àß a ‚àà t) fun t => t :=\n  ‚ü®fun s => hb.mem_nhds_iff.trans <| by simp only [and_assoc]‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isOpen","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\nb : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis b\nhs : Membership.mem b s\n‚ä¢ IsOpen s","decl":"protected theorem IsTopologicalBasis.isOpen {s : Set Œ±} {b : Set (Set Œ±)}\n    (hb : IsTopologicalBasis b) (hs : s ‚àà b) : IsOpen s := by\n  rw [hb.eq_generateFrom]\n  exact .basic s hs\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.mem_nhds","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\na : Œ±\ns : Set Œ±\nb : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis b\nhs : Membership.mem b s\nha : Membership.mem s a\n‚ä¢ Membership.mem (nhds a) s","decl":"protected theorem IsTopologicalBasis.mem_nhds {a : Œ±} {s : Set Œ±} {b : Set (Set Œ±)}\n    (hb : IsTopologicalBasis b) (hs : s ‚àà b) (ha : a ‚àà s) : s ‚àà ùìù a :=\n  (hb.isOpen hs).mem_nhds ha\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.exists_subset_of_mem_open","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nb : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis b\na : Œ±\nu : Set Œ±\nau : Membership.mem u a\nou : IsOpen u\n‚ä¢ Exists fun v => And (Membership.mem b v) (And (Membership.mem v a) (HasSubset.Subset v u))","decl":"theorem IsTopologicalBasis.exists_subset_of_mem_open {b : Set (Set Œ±)} (hb : IsTopologicalBasis b)\n    {a : Œ±} {u : Set Œ±} (au : a ‚àà u) (ou : IsOpen u) : ‚àÉ v ‚àà b, a ‚àà v ‚àß v ‚äÜ u :=\n  hb.mem_nhds_iff.1 <| IsOpen.mem_nhds ou au\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.open_eq_sUnion'","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nB : Set (Set Œ±)\nhB : TopologicalSpace.IsTopologicalBasis B\nu : Set Œ±\nou : IsOpen u\n‚ä¢ Eq u (setOf fun s => And (Membership.mem B s) (HasSubset.Subset s u)).sUnion","decl":"/-- Any open set is the union of the basis sets contained in it. -/\ntheorem IsTopologicalBasis.open_eq_sUnion' {B : Set (Set Œ±)} (hB : IsTopologicalBasis B) {u : Set Œ±}\n    (ou : IsOpen u) : u = ‚ãÉ‚ÇÄ { s ‚àà B | s ‚äÜ u } :=\n  ext fun _a =>\n    ‚ü®fun ha =>\n      let ‚ü®b, hb, ab, bu‚ü© := hB.exists_subset_of_mem_open ha ou\n      ‚ü®b, ‚ü®hb, bu‚ü©, ab‚ü©,\n      fun ‚ü®_b, ‚ü®_, bu‚ü©, ab‚ü© => bu ab‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.open_eq_sUnion","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nB : Set (Set Œ±)\nhB : TopologicalSpace.IsTopologicalBasis B\nu : Set Œ±\nou : IsOpen u\n‚ä¢ Exists fun S => And (HasSubset.Subset S B) (Eq u S.sUnion)","decl":"theorem IsTopologicalBasis.open_eq_sUnion {B : Set (Set Œ±)} (hB : IsTopologicalBasis B) {u : Set Œ±}\n    (ou : IsOpen u) : ‚àÉ S ‚äÜ B, u = ‚ãÉ‚ÇÄ S :=\n  ‚ü®{ s ‚àà B | s ‚äÜ u }, fun _ h => h.1, hB.open_eq_sUnion' ou‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.open_iff_eq_sUnion","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nB : Set (Set Œ±)\nhB : TopologicalSpace.IsTopologicalBasis B\nu : Set Œ±\n‚ä¢ Iff (IsOpen u) (Exists fun S => And (HasSubset.Subset S B) (Eq u S.sUnion))","decl":"theorem IsTopologicalBasis.open_iff_eq_sUnion {B : Set (Set Œ±)} (hB : IsTopologicalBasis B)\n    {u : Set Œ±} : IsOpen u ‚Üî ‚àÉ S ‚äÜ B, u = ‚ãÉ‚ÇÄ S :=\n  ‚ü®hB.open_eq_sUnion, fun ‚ü®_S, hSB, hu‚ü© => hu.symm ‚ñ∏ isOpen_sUnion fun _s hs => hB.isOpen (hSB hs)‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.open_eq_iUnion","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nB : Set (Set Œ±)\nhB : TopologicalSpace.IsTopologicalBasis B\nu : Set Œ±\nou : IsOpen u\n‚ä¢ Exists fun Œ≤ => Exists fun f => And (Eq u (Set.iUnion fun i => f i)) (‚àÄ (i : Œ≤), Membership.mem B (f i))","decl":"theorem IsTopologicalBasis.open_eq_iUnion {B : Set (Set Œ±)} (hB : IsTopologicalBasis B) {u : Set Œ±}\n    (ou : IsOpen u) : ‚àÉ (Œ≤ : Type u) (f : Œ≤ ‚Üí Set Œ±), (u = ‚ãÉ i, f i) ‚àß ‚àÄ i, f i ‚àà B :=\n  ‚ü®‚Ü•({ s ‚àà B | s ‚äÜ u }), (‚Üë), by\n    rw [‚Üê sUnion_eq_iUnion]\n    apply hB.open_eq_sUnion' ou, fun s => And.left s.2‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.subset_of_forall_subset","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt‚úù : TopologicalSpace Œ±\nB : Set (Set Œ±)\ns t : Set Œ±\nhB : TopologicalSpace.IsTopologicalBasis B\nhs : IsOpen s\nh : ‚àÄ (U : Set Œ±), Membership.mem B U ‚Üí HasSubset.Subset U s ‚Üí HasSubset.Subset U t\n‚ä¢ HasSubset.Subset s t","decl":"lemma IsTopologicalBasis.subset_of_forall_subset {t : Set Œ±} (hB : IsTopologicalBasis B)\n    (hs : IsOpen s) (h : ‚àÄ U ‚àà B, U ‚äÜ s ‚Üí U ‚äÜ t) : s ‚äÜ t := by\n  rw [hB.open_eq_sUnion' hs]; simpa [sUnion_subset_iff]\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.eq_of_forall_subset_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt‚úù : TopologicalSpace Œ±\nB : Set (Set Œ±)\ns t : Set Œ±\nhB : TopologicalSpace.IsTopologicalBasis B\nhs : IsOpen s\nht : IsOpen t\nh : ‚àÄ (U : Set Œ±), Membership.mem B U ‚Üí Iff (HasSubset.Subset U s) (HasSubset.Subset U t)\n‚ä¢ Eq s t","decl":"lemma IsTopologicalBasis.eq_of_forall_subset_iff {t : Set Œ±} (hB : IsTopologicalBasis B)\n    (hs : IsOpen s) (ht : IsOpen t) (h : ‚àÄ U ‚àà B, U ‚äÜ s ‚Üî U ‚äÜ t) : s = t := by\n  rw [hB.open_eq_sUnion' hs, hB.open_eq_sUnion' ht]\n  exact congr_arg _ (Set.ext fun U ‚Ü¶ and_congr_right <| h _)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.mem_closure_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nb : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis b\ns : Set Œ±\na : Œ±\n‚ä¢ Iff (Membership.mem (closure s) a) (‚àÄ (o : Set Œ±), Membership.mem b o ‚Üí Membership.mem o a ‚Üí (Inter.inter o s).Nonempty)","decl":"/-- A point `a` is in the closure of `s` iff all basis sets containing `a` intersect `s`. -/\ntheorem IsTopologicalBasis.mem_closure_iff {b : Set (Set Œ±)} (hb : IsTopologicalBasis b) {s : Set Œ±}\n    {a : Œ±} : a ‚àà closure s ‚Üî ‚àÄ o ‚àà b, a ‚àà o ‚Üí (o ‚à© s).Nonempty :=\n  (mem_closure_iff_nhds_basis' hb.nhds_hasBasis).trans <| by simp only [and_imp]\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.dense_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nb : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis b\ns : Set Œ±\n‚ä¢ Iff (Dense s) (‚àÄ (o : Set Œ±), Membership.mem b o ‚Üí o.Nonempty ‚Üí (Inter.inter o s).Nonempty)","decl":"/-- A set is dense iff it has non-trivial intersection with all basis sets. -/\ntheorem IsTopologicalBasis.dense_iff {b : Set (Set Œ±)} (hb : IsTopologicalBasis b) {s : Set Œ±} :\n    Dense s ‚Üî ‚àÄ o ‚àà b, Set.Nonempty o ‚Üí (o ‚à© s).Nonempty := by\n  simp only [Dense, hb.mem_closure_iff]\n  exact ‚ü®fun h o hb ‚ü®a, ha‚ü© => h a o hb ha, fun h a o hb ha => h o hb ‚ü®a, ha‚ü©‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isOpenMap_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ≤\nB : Set (Set Œ±)\nhB : TopologicalSpace.IsTopologicalBasis B\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (IsOpenMap f) (‚àÄ (s : Set Œ±), Membership.mem B s ‚Üí IsOpen (Set.image f s))","decl":"theorem IsTopologicalBasis.isOpenMap_iff {Œ≤} [TopologicalSpace Œ≤] {B : Set (Set Œ±)}\n    (hB : IsTopologicalBasis B) {f : Œ± ‚Üí Œ≤} : IsOpenMap f ‚Üî ‚àÄ s ‚àà B, IsOpen (f '' s) := by\n  refine ‚ü®fun H o ho => H _ (hB.isOpen ho), fun hf o ho => ?_‚ü©\n  rw [hB.open_eq_sUnion' ho, sUnion_eq_iUnion, image_iUnion]\n  exact isOpen_iUnion fun s => hf s s.2.1\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.exists_nonempty_subset","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nB : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis B\nu : Set Œ±\nhu : u.Nonempty\nou : IsOpen u\n‚ä¢ Exists fun v => And (Membership.mem B v) (And v.Nonempty (HasSubset.Subset v u))","decl":"theorem IsTopologicalBasis.exists_nonempty_subset {B : Set (Set Œ±)} (hb : IsTopologicalBasis B)\n    {u : Set Œ±} (hu : u.Nonempty) (ou : IsOpen u) : ‚àÉ v ‚àà B, Set.Nonempty v ‚àß v ‚äÜ u :=\n  let ‚ü®x, hx‚ü© := hu\n  let ‚ü®v, vB, xv, vu‚ü© := hb.exists_subset_of_mem_open hx ou\n  ‚ü®v, vB, ‚ü®x, xv‚ü©, vu‚ü©\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_opens","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\n‚ä¢ TopologicalSpace.IsTopologicalBasis (setOf fun U => IsOpen U)","decl":"theorem isTopologicalBasis_opens : IsTopologicalBasis { U : Set Œ± | IsOpen U } :=\n  isTopologicalBasis_of_isOpen_of_nhds (by tauto) (by tauto)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isInducing","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nT : Set (Set Œ≤)\nhf : Topology.IsInducing f\nh : TopologicalSpace.IsTopologicalBasis T\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.preimage f) T)","decl":"protected lemma IsTopologicalBasis.isInducing {Œ≤} [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {T : Set (Set Œ≤)}\n    (hf : IsInducing f) (h : IsTopologicalBasis T) : IsTopologicalBasis ((preimage f) '' T) :=\n  .of_hasBasis_nhds fun a ‚Ü¶ by\n    convert (hf.basis_nhds (h.nhds_hasBasis (a := f a))).to_image_id with s\n    aesop\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.inducing","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nT : Set (Set Œ≤)\nhf : Topology.IsInducing f\nh : TopologicalSpace.IsTopologicalBasis T\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.preimage f) T)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias IsTopologicalBasis.inducing := IsTopologicalBasis.isInducing\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.induced","module":"Mathlib.Topology.Bases","initialProofState":"Œ≤ : Type u_1\nŒ± : Type u_2\ns : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nT : Set (Set Œ≤)\nh : TopologicalSpace.IsTopologicalBasis T\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.preimage f) T)","decl":"protected theorem IsTopologicalBasis.induced {Œ±} [s : TopologicalSpace Œ≤] (f : Œ± ‚Üí Œ≤)\n    {T : Set (Set Œ≤)} (h : IsTopologicalBasis T) :\n    IsTopologicalBasis (t := induced f s) ((preimage f) '' T) :=\n  h.isInducing (t := induced f s) (.induced f)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.inf","module":"Mathlib.Topology.Bases","initialProofState":"Œ≤ : Type u_1\nt‚ÇÅ t‚ÇÇ : TopologicalSpace Œ≤\nB‚ÇÅ B‚ÇÇ : Set (Set Œ≤)\nh‚ÇÅ : TopologicalSpace.IsTopologicalBasis B‚ÇÅ\nh‚ÇÇ : TopologicalSpace.IsTopologicalBasis B‚ÇÇ\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image2 (fun x1 x2 => Inter.inter x1 x2) B‚ÇÅ B‚ÇÇ)","decl":"protected theorem IsTopologicalBasis.inf {t‚ÇÅ t‚ÇÇ : TopologicalSpace Œ≤} {B‚ÇÅ B‚ÇÇ : Set (Set Œ≤)}\n    (h‚ÇÅ : IsTopologicalBasis (t := t‚ÇÅ) B‚ÇÅ) (h‚ÇÇ : IsTopologicalBasis (t := t‚ÇÇ) B‚ÇÇ) :\n    IsTopologicalBasis (t := t‚ÇÅ ‚äì t‚ÇÇ) (image2 (¬∑ ‚à© ¬∑) B‚ÇÅ B‚ÇÇ) := by\n  refine .of_hasBasis_nhds (t := ?_) fun a ‚Ü¶ ?_\n  rw [nhds_inf (t‚ÇÅ := t‚ÇÅ)]\n  convert ((h‚ÇÅ.nhds_hasBasis (t := t‚ÇÅ)).inf (h‚ÇÇ.nhds_hasBasis (t := t‚ÇÇ))).to_image_id\n  aesop\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.inf_induced","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nŒ≤ : Type u_1\nt : TopologicalSpace Œ±\nŒ≥ : Type u_2\ns : TopologicalSpace Œ≤\nB‚ÇÅ : Set (Set Œ±)\nB‚ÇÇ : Set (Set Œ≤)\nh‚ÇÅ : TopologicalSpace.IsTopologicalBasis B‚ÇÅ\nh‚ÇÇ : TopologicalSpace.IsTopologicalBasis B‚ÇÇ\nf‚ÇÅ : Œ≥ ‚Üí Œ±\nf‚ÇÇ : Œ≥ ‚Üí Œ≤\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image2 (fun x1 x2 => Inter.inter (Set.preimage f‚ÇÅ x1) (Set.preimage f‚ÇÇ x2)) B‚ÇÅ B‚ÇÇ)","decl":"theorem IsTopologicalBasis.inf_induced {Œ≥} [s : TopologicalSpace Œ≤] {B‚ÇÅ : Set (Set Œ±)}\n    {B‚ÇÇ : Set (Set Œ≤)} (h‚ÇÅ : IsTopologicalBasis B‚ÇÅ) (h‚ÇÇ : IsTopologicalBasis B‚ÇÇ) (f‚ÇÅ : Œ≥ ‚Üí Œ±)\n    (f‚ÇÇ : Œ≥ ‚Üí Œ≤) :\n    IsTopologicalBasis (t := induced f‚ÇÅ t ‚äì induced f‚ÇÇ s) (image2 (f‚ÇÅ ‚Åª¬π' ¬∑ ‚à© f‚ÇÇ ‚Åª¬π' ¬∑) B‚ÇÅ B‚ÇÇ) := by\n  simpa only [image2_image_left, image2_image_right] using (h‚ÇÅ.induced f‚ÇÅ).inf (h‚ÇÇ.induced f‚ÇÇ)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.prod","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ≤\nB‚ÇÅ : Set (Set Œ±)\nB‚ÇÇ : Set (Set Œ≤)\nh‚ÇÅ : TopologicalSpace.IsTopologicalBasis B‚ÇÅ\nh‚ÇÇ : TopologicalSpace.IsTopologicalBasis B‚ÇÇ\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) B‚ÇÅ B‚ÇÇ)","decl":"protected theorem IsTopologicalBasis.prod {Œ≤} [TopologicalSpace Œ≤] {B‚ÇÅ : Set (Set Œ±)}\n    {B‚ÇÇ : Set (Set Œ≤)} (h‚ÇÅ : IsTopologicalBasis B‚ÇÅ) (h‚ÇÇ : IsTopologicalBasis B‚ÇÇ) :\n    IsTopologicalBasis (image2 (¬∑ √óÀ¢ ¬∑) B‚ÇÅ B‚ÇÇ) :=\n  h‚ÇÅ.inf_induced h‚ÇÇ Prod.fst Prod.snd\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_cover","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒπ : Sort u_2\nU : Œπ ‚Üí Set Œ±\nUo : ‚àÄ (i : Œπ), IsOpen (U i)\nUc : Eq (Set.iUnion fun i => U i) Set.univ\nb : (i : Œπ) ‚Üí Set (Set ‚Üë(U i))\nhb : ‚àÄ (i : Œπ), TopologicalSpace.IsTopologicalBasis (b i)\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.iUnion fun i => Set.image (Set.image Subtype.val) (b i))","decl":"theorem isTopologicalBasis_of_cover {Œπ} {U : Œπ ‚Üí Set Œ±} (Uo : ‚àÄ i, IsOpen (U i))\n    (Uc : ‚ãÉ i, U i = univ) {b : ‚àÄ i, Set (Set (U i))} (hb : ‚àÄ i, IsTopologicalBasis (b i)) :\n    IsTopologicalBasis (‚ãÉ i : Œπ, image ((‚Üë) : U i ‚Üí Œ±) '' b i) := by\n  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => ?_) ?_\n  ¬∑ simp only [mem_iUnion, mem_image] at hu\n    rcases hu with ‚ü®i, s, sb, rfl‚ü©\n    exact (Uo i).isOpenMap_subtype_val _ ((hb i).isOpen sb)\n  ¬∑ intro a u ha uo\n    rcases iUnion_eq_univ_iff.1 Uc a with ‚ü®i, hi‚ü©\n    lift a to ‚Ü•(U i) using hi\n    rcases (hb i).exists_subset_of_mem_open ha (uo.preimage continuous_subtype_val) with\n      ‚ü®v, hvb, hav, hvu‚ü©\n    exact ‚ü®(‚Üë) '' v, mem_iUnion.2 ‚ü®i, mem_image_of_mem _ hvb‚ü©, mem_image_of_mem _ hav,\n      image_subset_iff.2 hvu‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.continuous_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ≤\nB : Set (Set Œ≤)\nhB : TopologicalSpace.IsTopologicalBasis B\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (Continuous f) (‚àÄ (s : Set Œ≤), Membership.mem B s ‚Üí IsOpen (Set.preimage f s))","decl":"protected theorem IsTopologicalBasis.continuous_iff {Œ≤ : Type*} [TopologicalSpace Œ≤]\n    {B : Set (Set Œ≤)} (hB : IsTopologicalBasis B) {f : Œ± ‚Üí Œ≤} :\n    Continuous f ‚Üî ‚àÄ s ‚àà B, IsOpen (f ‚Åª¬π' s) := by\n  rw [hB.eq_generateFrom, continuous_generateFrom_iff]\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_empty","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\n‚ä¢ Iff (TopologicalSpace.IsTopologicalBasis EmptyCollection.emptyCollection) (IsEmpty Œ±)","decl":"@[simp] lemma isTopologicalBasis_empty : IsTopologicalBasis (‚àÖ : Set (Set Œ±)) ‚Üî IsEmpty Œ± where\n  mp h := by simpa using h.sUnion_eq.symm\n  mpr h := ‚ü®by simp, by simp [Set.univ_eq_empty_iff.2], Subsingleton.elim ..‚ü©\n\n"}
{"name":"TopologicalSpace.separableSpace_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\n‚ä¢ Iff (TopologicalSpace.SeparableSpace Œ±) (Exists fun s => And s.Countable (Dense s))","decl":"/-- A separable space is one with a countable dense subset, available through\n`TopologicalSpace.exists_countable_dense`. If `Œ±` is also known to be nonempty, then\n`TopologicalSpace.denseSeq` provides a sequence `‚Ñï ‚Üí Œ±` with dense range, see\n`TopologicalSpace.denseRange_denseSeq`.\n\nIf `Œ±` is a uniform space with countably generated uniformity filter (e.g., an `EMetricSpace`), then\nthis condition is equivalent to `SecondCountableTopology Œ±`. In this case the\nlatter should be used as a typeclass argument in theorems because Lean can automatically deduce\n`TopologicalSpace.SeparableSpace` from `SecondCountableTopology` but it can't\ndeduce `SecondCountableTopology` from `TopologicalSpace.SeparableSpace`.\n\nPorting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: the previous paragraph describes the state of the art in Lean 3.\nWe can have instance cycles in Lean 4 but we might want to\npostpone adding them till after the port. -/\n@[mk_iff] class SeparableSpace : Prop where\n  /-- There exists a countable dense set. -/\n  exists_countable_dense : ‚àÉ s : Set Œ±, s.Countable ‚àß Dense s\n\n"}
{"name":"TopologicalSpace.SeparableSpace.exists_countable_dense","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nself : TopologicalSpace.SeparableSpace Œ±\n‚ä¢ Exists fun s => And s.Countable (Dense s)","decl":"/-- A separable space is one with a countable dense subset, available through\n`TopologicalSpace.exists_countable_dense`. If `Œ±` is also known to be nonempty, then\n`TopologicalSpace.denseSeq` provides a sequence `‚Ñï ‚Üí Œ±` with dense range, see\n`TopologicalSpace.denseRange_denseSeq`.\n\nIf `Œ±` is a uniform space with countably generated uniformity filter (e.g., an `EMetricSpace`), then\nthis condition is equivalent to `SecondCountableTopology Œ±`. In this case the\nlatter should be used as a typeclass argument in theorems because Lean can automatically deduce\n`TopologicalSpace.SeparableSpace` from `SecondCountableTopology` but it can't\ndeduce `SecondCountableTopology` from `TopologicalSpace.SeparableSpace`.\n\nPorting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: the previous paragraph describes the state of the art in Lean 3.\nWe can have instance cycles in Lean 4 but we might want to\npostpone adding them till after the port. -/\n@[mk_iff] class SeparableSpace : Prop where\n  /-- There exists a countable dense set. -/\n  exists_countable_dense : ‚àÉ s : Set Œ±, s.Countable ‚àß Dense s\n\n"}
{"name":"TopologicalSpace.exists_countable_dense","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace.SeparableSpace Œ±\n‚ä¢ Exists fun s => And s.Countable (Dense s)","decl":"theorem exists_countable_dense [SeparableSpace Œ±] : ‚àÉ s : Set Œ±, s.Countable ‚àß Dense s :=\n  SeparableSpace.exists_countable_dense\n\n"}
{"name":"TopologicalSpace.exists_dense_seq","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace.SeparableSpace Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ Exists fun u => DenseRange u","decl":"/-- A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the\nconclusion of this lemma, you might want to use `TopologicalSpace.denseSeq` and\n`TopologicalSpace.denseRange_denseSeq`.\n\nIf `Œ±` might be empty, then `TopologicalSpace.exists_countable_dense` is the main way to use\nseparability of `Œ±`. -/\ntheorem exists_dense_seq [SeparableSpace Œ±] [Nonempty Œ±] : ‚àÉ u : ‚Ñï ‚Üí Œ±, DenseRange u := by\n  obtain ‚ü®s : Set Œ±, hs, s_dense‚ü© := exists_countable_dense Œ±\n  cases' Set.countable_iff_exists_subset_range.mp hs with u hu\n  exact ‚ü®u, s_dense.mono hu‚ü©\n\n"}
{"name":"TopologicalSpace.denseRange_denseSeq","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace.SeparableSpace Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ DenseRange (TopologicalSpace.denseSeq Œ±)","decl":"/-- The sequence `TopologicalSpace.denseSeq Œ±` has dense range. -/\n@[simp]\ntheorem denseRange_denseSeq [SeparableSpace Œ±] [Nonempty Œ±] : DenseRange (denseSeq Œ±) :=\n  Classical.choose_spec (exists_dense_seq Œ±)\n\n"}
{"name":"TopologicalSpace.Countable.to_separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : Countable Œ±\n‚ä¢ TopologicalSpace.SeparableSpace Œ±","decl":"instance (priority := 100) Countable.to_separableSpace [Countable Œ±] : SeparableSpace Œ± where\n  exists_countable_dense := ‚ü®Set.univ, Set.countable_univ, dense_univ‚ü©\n\n"}
{"name":"TopologicalSpace.SeparableSpace.of_denseRange","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒπ : Type u_2\ninst‚úù : Countable Œπ\nu : Œπ ‚Üí Œ±\nhu : DenseRange u\n‚ä¢ TopologicalSpace.SeparableSpace Œ±","decl":"/-- If `f` has a dense range and its domain is countable, then its codomain is a separable space.\nSee also `DenseRange.separableSpace`. -/\ntheorem SeparableSpace.of_denseRange {Œπ : Sort _} [Countable Œπ] (u : Œπ ‚Üí Œ±) (hu : DenseRange u) :\n    SeparableSpace Œ± :=\n  ‚ü®‚ü®range u, countable_range u, hu‚ü©‚ü©\n\n"}
{"name":"DenseRange.separableSpace'","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒπ : Type u_2\ninst‚úù : Countable Œπ\nu : Œπ ‚Üí Œ±\nhu : DenseRange u\n‚ä¢ TopologicalSpace.SeparableSpace Œ±","decl":"alias _root_.DenseRange.separableSpace' := SeparableSpace.of_denseRange\n\n"}
{"name":"DenseRange.separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nŒ≤ : Type u_1\nt : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace.SeparableSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : DenseRange f\nh' : Continuous f\n‚ä¢ TopologicalSpace.SeparableSpace Œ≤","decl":"/-- If `Œ±` is a separable space and `f : Œ± ‚Üí Œ≤` is a continuous map with dense range, then `Œ≤` is\na separable space as well. E.g., the completion of a separable uniform space is separable. -/\nprotected theorem _root_.DenseRange.separableSpace [SeparableSpace Œ±] [TopologicalSpace Œ≤]\n    {f : Œ± ‚Üí Œ≤} (h : DenseRange f) (h' : Continuous f) : SeparableSpace Œ≤ :=\n  let ‚ü®s, s_cnt, s_dense‚ü© := exists_countable_dense Œ±\n  ‚ü®‚ü®f '' s, Countable.image s_cnt f, h.dense_image h' s_dense‚ü©‚ü©\n\n"}
{"name":"Topology.IsQuotientMap.separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nŒ≤ : Type u_1\nt : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace.SeparableSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Topology.IsQuotientMap f\n‚ä¢ TopologicalSpace.SeparableSpace Œ≤","decl":"theorem _root_.Topology.IsQuotientMap.separableSpace [SeparableSpace Œ±] [TopologicalSpace Œ≤]\n    {f : Œ± ‚Üí Œ≤} (hf : IsQuotientMap f) : SeparableSpace Œ≤ :=\n  hf.surjective.denseRange.separableSpace hf.continuous\n\n"}
{"name":"QuotientMap.separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nŒ≤ : Type u_1\nt : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace.SeparableSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Topology.IsQuotientMap f\n‚ä¢ TopologicalSpace.SeparableSpace Œ≤","decl":"@[deprecated (since := \"2024-10-22\")]\nalias _root_.QuotientMap.separableSpace := Topology.IsQuotientMap.separableSpace\n\n"}
{"name":"TopologicalSpace.instSeparableSpaceProd","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nŒ≤ : Type u_1\nt : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : TopologicalSpace.SeparableSpace Œ±\ninst‚úù : TopologicalSpace.SeparableSpace Œ≤\n‚ä¢ TopologicalSpace.SeparableSpace (Prod Œ± Œ≤)","decl":"/-- The product of two separable spaces is a separable space. -/\ninstance [TopologicalSpace Œ≤] [SeparableSpace Œ±] [SeparableSpace Œ≤] : SeparableSpace (Œ± √ó Œ≤) := by\n  rcases exists_countable_dense Œ± with ‚ü®s, hsc, hsd‚ü©\n  rcases exists_countable_dense Œ≤ with ‚ü®t, htc, htd‚ü©\n  exact ‚ü®‚ü®s √óÀ¢ t, hsc.prod htc, hsd.prod htd‚ü©‚ü©\n\n"}
{"name":"TopologicalSpace.instSeparableSpaceForallOfCountable","module":"Mathlib.Topology.Bases","initialProofState":"Œπ : Type u_2\nX : Œπ ‚Üí Type u_3\ninst‚úù¬≤ : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù¬π : ‚àÄ (i : Œπ), TopologicalSpace.SeparableSpace (X i)\ninst‚úù : Countable Œπ\n‚ä¢ TopologicalSpace.SeparableSpace ((i : Œπ) ‚Üí X i)","decl":"/-- The product of a countable family of separable spaces is a separable space. -/\ninstance {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, SeparableSpace (X i)]\n    [Countable Œπ] : SeparableSpace (‚àÄ i, X i) := by\n  choose t htc htd using (exists_countable_dense <| X ¬∑)\n  haveI := fun i ‚Ü¶ (htc i).to_subtype\n  nontriviality ‚àÄ i, X i; inhabit ‚àÄ i, X i\n  classical\n    set f : (Œ£ I : Finset Œπ, ‚àÄ i : I, t i) ‚Üí ‚àÄ i, X i := fun ‚ü®I, g‚ü© i ‚Ü¶\n      if hi : i ‚àà I then g ‚ü®i, hi‚ü© else (default : ‚àÄ i, X i) i\n    refine ‚ü®‚ü®range f, countable_range f, dense_iff_inter_open.2 fun U hU ‚ü®g, hg‚ü© ‚Ü¶ ?_‚ü©‚ü©\n    rcases isOpen_pi_iff.1 hU g hg with ‚ü®I, u, huo, huU‚ü©\n    have : ‚àÄ i : I, ‚àÉ y ‚àà t i, y ‚àà u i := fun i ‚Ü¶\n      (htd i).exists_mem_open (huo i i.2).1 ‚ü®_, (huo i i.2).2‚ü©\n    choose y hyt hyu using this\n    lift y to ‚àÄ i : I, t i using hyt\n    refine ‚ü®f ‚ü®I, y‚ü©, huU fun i (hi : i ‚àà I) ‚Ü¶ ?_, mem_range_self (f := f) ‚ü®I, y‚ü©‚ü©\n    simp only [f, dif_pos hi]\n    exact hyu ‚ü®i, _‚ü©\n\n"}
{"name":"TopologicalSpace.instSeparableSpaceQuot","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace.SeparableSpace Œ±\nr : Œ± ‚Üí Œ± ‚Üí Prop\n‚ä¢ TopologicalSpace.SeparableSpace (Quot r)","decl":"instance [SeparableSpace Œ±] {r : Œ± ‚Üí Œ± ‚Üí Prop} : SeparableSpace (Quot r) :=\n  isQuotientMap_quot_mk.separableSpace\n\n"}
{"name":"TopologicalSpace.instSeparableSpaceQuotient","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace.SeparableSpace Œ±\ns : Setoid Œ±\n‚ä¢ TopologicalSpace.SeparableSpace (Quotient s)","decl":"instance [SeparableSpace Œ±] {s : Setoid Œ±} : SeparableSpace (Quotient s) :=\n  isQuotientMap_quot_mk.separableSpace\n\n"}
{"name":"TopologicalSpace.separableSpace_iff_countable","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\n‚ä¢ Iff (TopologicalSpace.SeparableSpace Œ±) (Countable Œ±)","decl":"/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem separableSpace_iff_countable [DiscreteTopology Œ±] : SeparableSpace Œ± ‚Üî Countable Œ± := by\n  simp [separableSpace_iff, countable_univ_iff]\n\n"}
{"name":"Pairwise.countable_of_isOpen_disjoint","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace.SeparableSpace Œ±\nŒπ : Type u_2\ns : Œπ ‚Üí Set Œ±\nhd : Pairwise (Function.onFun Disjoint s)\nho : ‚àÄ (i : Œπ), IsOpen (s i)\nhne : ‚àÄ (i : Œπ), (s i).Nonempty\n‚ä¢ Countable Œπ","decl":"/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem _root_.Pairwise.countable_of_isOpen_disjoint [SeparableSpace Œ±] {Œπ : Type*}\n    {s : Œπ ‚Üí Set Œ±} (hd : Pairwise (Disjoint on s)) (ho : ‚àÄ i, IsOpen (s i))\n    (hne : ‚àÄ i, (s i).Nonempty) : Countable Œπ := by\n  rcases exists_countable_dense Œ± with ‚ü®u, u_countable, u_dense‚ü©\n  choose f hfu hfs using fun i ‚Ü¶ u_dense.exists_mem_open (ho i) (hne i)\n  have f_inj : Injective f := fun i j hij ‚Ü¶\n    hd.eq <| not_disjoint_iff.2 ‚ü®f i, hfs i, hij.symm ‚ñ∏ hfs j‚ü©\n  have := u_countable.to_subtype\n  exact (f_inj.codRestrict hfu).countable\n\n"}
{"name":"Set.PairwiseDisjoint.countable_of_isOpen","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace.SeparableSpace Œ±\nŒπ : Type u_2\ns : Œπ ‚Üí Set Œ±\na : Set Œπ\nh : a.PairwiseDisjoint s\nho : ‚àÄ (i : Œπ), Membership.mem a i ‚Üí IsOpen (s i)\nhne : ‚àÄ (i : Œπ), Membership.mem a i ‚Üí (s i).Nonempty\n‚ä¢ a.Countable","decl":"/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem _root_.Set.PairwiseDisjoint.countable_of_isOpen [SeparableSpace Œ±] {Œπ : Type*}\n    {s : Œπ ‚Üí Set Œ±} {a : Set Œπ} (h : a.PairwiseDisjoint s) (ho : ‚àÄ i ‚àà a, IsOpen (s i))\n    (hne : ‚àÄ i ‚àà a, (s i).Nonempty) : a.Countable :=\n  (h.subtype _ _).countable_of_isOpen_disjoint (Subtype.forall.2 ho) (Subtype.forall.2 hne)\n\n"}
{"name":"Set.PairwiseDisjoint.countable_of_nonempty_interior","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace.SeparableSpace Œ±\nŒπ : Type u_2\ns : Œπ ‚Üí Set Œ±\na : Set Œπ\nh : a.PairwiseDisjoint s\nha : ‚àÄ (i : Œπ), Membership.mem a i ‚Üí (interior (s i)).Nonempty\n‚ä¢ a.Countable","decl":"/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem _root_.Set.PairwiseDisjoint.countable_of_nonempty_interior [SeparableSpace Œ±] {Œπ : Type*}\n    {s : Œπ ‚Üí Set Œ±} {a : Set Œπ} (h : a.PairwiseDisjoint s)\n    (ha : ‚àÄ i ‚àà a, (interior (s i)).Nonempty) : a.Countable :=\n  (h.mono fun _ => interior_subset).countable_of_isOpen (fun _ _ => isOpen_interior) ha\n\n"}
{"name":"TopologicalSpace.IsSeparable.mono","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns u : Set Œ±\nhs : TopologicalSpace.IsSeparable s\nhu : HasSubset.Subset u s\n‚ä¢ TopologicalSpace.IsSeparable u","decl":"theorem IsSeparable.mono {s u : Set Œ±} (hs : IsSeparable s) (hu : u ‚äÜ s) : IsSeparable u := by\n  rcases hs with ‚ü®c, c_count, hs‚ü©\n  exact ‚ü®c, c_count, hu.trans hs‚ü©\n\n"}
{"name":"TopologicalSpace.IsSeparable.iUnion","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒπ : Sort u_2\ninst‚úù : Countable Œπ\ns : Œπ ‚Üí Set Œ±\nhs : ‚àÄ (i : Œπ), TopologicalSpace.IsSeparable (s i)\n‚ä¢ TopologicalSpace.IsSeparable (Set.iUnion fun i => s i)","decl":"theorem IsSeparable.iUnion {Œπ : Sort*} [Countable Œπ] {s : Œπ ‚Üí Set Œ±}\n    (hs : ‚àÄ i, IsSeparable (s i)) : IsSeparable (‚ãÉ i, s i) := by\n  choose c hc h'c using hs\n  refine ‚ü®‚ãÉ i, c i, countable_iUnion hc, iUnion_subset_iff.2 fun i => ?_‚ü©\n  exact (h'c i).trans (closure_mono (subset_iUnion _ i))\n\n"}
{"name":"TopologicalSpace.isSeparable_iUnion","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒπ : Sort u_2\ninst‚úù : Countable Œπ\ns : Œπ ‚Üí Set Œ±\n‚ä¢ Iff (TopologicalSpace.IsSeparable (Set.iUnion fun i => s i)) (‚àÄ (i : Œπ), TopologicalSpace.IsSeparable (s i))","decl":"@[simp]\ntheorem isSeparable_iUnion {Œπ : Sort*} [Countable Œπ] {s : Œπ ‚Üí Set Œ±} :\n    IsSeparable (‚ãÉ i, s i) ‚Üî ‚àÄ i, IsSeparable (s i) :=\n  ‚ü®fun h i ‚Ü¶ h.mono <| subset_iUnion s i, .iUnion‚ü©\n\n"}
{"name":"TopologicalSpace.isSeparable_union","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt‚úù : TopologicalSpace Œ±\ns t : Set Œ±\n‚ä¢ Iff (TopologicalSpace.IsSeparable (Union.union s t)) (And (TopologicalSpace.IsSeparable s) (TopologicalSpace.IsSeparable t))","decl":"@[simp]\ntheorem isSeparable_union {s t : Set Œ±} : IsSeparable (s ‚à™ t) ‚Üî IsSeparable s ‚àß IsSeparable t := by\n  simp [union_eq_iUnion, and_comm]\n\n"}
{"name":"TopologicalSpace.IsSeparable.union","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns u : Set Œ±\nhs : TopologicalSpace.IsSeparable s\nhu : TopologicalSpace.IsSeparable u\n‚ä¢ TopologicalSpace.IsSeparable (Union.union s u)","decl":"theorem IsSeparable.union {s u : Set Œ±} (hs : IsSeparable s) (hu : IsSeparable u) :\n    IsSeparable (s ‚à™ u) :=\n  isSeparable_union.2 ‚ü®hs, hu‚ü©\n\n"}
{"name":"TopologicalSpace.isSeparable_closure","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (TopologicalSpace.IsSeparable (closure s)) (TopologicalSpace.IsSeparable s)","decl":"@[simp]\ntheorem isSeparable_closure : IsSeparable (closure s) ‚Üî IsSeparable s := by\n  simp only [IsSeparable, isClosed_closure.closure_subset_iff]\n\n"}
{"name":"TopologicalSpace.IsSeparable.closure","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\na‚úù : TopologicalSpace.IsSeparable s\n‚ä¢ TopologicalSpace.IsSeparable (closure s)","decl":"protected alias ‚ü®_, IsSeparable.closure‚ü© := isSeparable_closure\n\n"}
{"name":"Set.Countable.isSeparable","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\nhs : s.Countable\n‚ä¢ TopologicalSpace.IsSeparable s","decl":"theorem _root_.Set.Countable.isSeparable {s : Set Œ±} (hs : s.Countable) : IsSeparable s :=\n  ‚ü®s, hs, subset_closure‚ü©\n\n"}
{"name":"Set.Finite.isSeparable","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\nhs : s.Finite\n‚ä¢ TopologicalSpace.IsSeparable s","decl":"theorem _root_.Set.Finite.isSeparable {s : Set Œ±} (hs : s.Finite) : IsSeparable s :=\n  hs.countable.isSeparable\n\n"}
{"name":"TopologicalSpace.IsSeparable.univ_pi","module":"Mathlib.Topology.Bases","initialProofState":"Œπ : Type u_2\ninst‚úù¬π : Countable Œπ\nX : Œπ ‚Üí Type u_3\ns : (i : Œπ) ‚Üí Set (X i)\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (X i)\nh : ‚àÄ (i : Œπ), TopologicalSpace.IsSeparable (s i)\n‚ä¢ TopologicalSpace.IsSeparable (Set.univ.pi s)","decl":"theorem IsSeparable.univ_pi {Œπ : Type*} [Countable Œπ] {X : Œπ ‚Üí Type*} {s : ‚àÄ i, Set (X i)}\n    [‚àÄ i, TopologicalSpace (X i)] (h : ‚àÄ i, IsSeparable (s i)) :\n    IsSeparable (univ.pi s) := by\n  classical\n  rcases eq_empty_or_nonempty (univ.pi s) with he | ‚ü®f‚ÇÄ, -‚ü©\n  ¬∑ rw [he]\n    exact countable_empty.isSeparable\n  ¬∑ choose c c_count hc using h\n    haveI := fun i ‚Ü¶ (c_count i).to_subtype\n    set g : (I : Finset Œπ) √ó ((i : I) ‚Üí c i) ‚Üí (i : Œπ) ‚Üí X i := fun ‚ü®I, f‚ü© i ‚Ü¶\n      if hi : i ‚àà I then f ‚ü®i, hi‚ü© else f‚ÇÄ i\n    refine ‚ü®range g, countable_range g, fun f hf ‚Ü¶ mem_closure_iff.2 fun o ho hfo ‚Ü¶ ?_‚ü©\n    rcases isOpen_pi_iff.1 ho f hfo with ‚ü®I, u, huo, hI‚ü©\n    rsuffices ‚ü®f, hf‚ü© : ‚àÉ f : (i : I) ‚Üí c i, g ‚ü®I, f‚ü© ‚àà Set.pi I u\n    ¬∑ exact ‚ü®g ‚ü®I, f‚ü©, hI hf, mem_range_self (f := g) ‚ü®I, f‚ü©‚ü©\n    suffices H : ‚àÄ i ‚àà I, (u i ‚à© c i).Nonempty by\n      choose f hfu hfc using H\n      refine ‚ü®fun i ‚Ü¶ ‚ü®f i i.2, hfc i i.2‚ü©, fun i (hi : i ‚àà I) ‚Ü¶ ?_‚ü©\n      simpa only [g, dif_pos hi] using hfu i hi\n    intro i hi\n    exact mem_closure_iff.1 (hc i <| hf _ trivial) _ (huo i hi).1 (huo i hi).2\n\n"}
{"name":"TopologicalSpace.isSeparable_pi","module":"Mathlib.Topology.Bases","initialProofState":"Œπ : Type u_2\ninst‚úù¬π : Countable Œπ\nŒ± : Œπ ‚Üí Type u_3\ns : (i : Œπ) ‚Üí Set (Œ± i)\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (Œ± i)\nh : ‚àÄ (i : Œπ), TopologicalSpace.IsSeparable (s i)\n‚ä¢ TopologicalSpace.IsSeparable (setOf fun f => ‚àÄ (i : Œπ), Membership.mem (s i) (f i))","decl":"lemma isSeparable_pi {Œπ : Type*} [Countable Œπ] {Œ± : Œπ ‚Üí Type*} {s : ‚àÄ i, Set (Œ± i)}\n    [‚àÄ i, TopologicalSpace (Œ± i)] (h : ‚àÄ i, IsSeparable (s i)) :\n    IsSeparable {f : ‚àÄ i, Œ± i | ‚àÄ i, f i ‚àà s i} := by\n  simpa only [‚Üê mem_univ_pi] using IsSeparable.univ_pi h\n\n"}
{"name":"TopologicalSpace.IsSeparable.prod","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt‚úù : TopologicalSpace Œ±\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ≤\ns : Set Œ±\nt : Set Œ≤\nhs : TopologicalSpace.IsSeparable s\nht : TopologicalSpace.IsSeparable t\n‚ä¢ TopologicalSpace.IsSeparable (SProd.sprod s t)","decl":"lemma IsSeparable.prod {Œ≤ : Type*} [TopologicalSpace Œ≤]\n    {s : Set Œ±} {t : Set Œ≤} (hs : IsSeparable s) (ht : IsSeparable t) :\n    IsSeparable (s √óÀ¢ t) := by\n  rcases hs with ‚ü®cs, cs_count, hcs‚ü©\n  rcases ht with ‚ü®ct, ct_count, hct‚ü©\n  refine ‚ü®cs √óÀ¢ ct, cs_count.prod ct_count, ?_‚ü©\n  rw [closure_prod_eq]\n  gcongr\n\n"}
{"name":"TopologicalSpace.IsSeparable.image","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_2\ninst‚úù : TopologicalSpace Œ≤\ns : Set Œ±\nhs : TopologicalSpace.IsSeparable s\nf : Œ± ‚Üí Œ≤\nhf : Continuous f\n‚ä¢ TopologicalSpace.IsSeparable (Set.image f s)","decl":"theorem IsSeparable.image {Œ≤ : Type*} [TopologicalSpace Œ≤] {s : Set Œ±} (hs : IsSeparable s)\n    {f : Œ± ‚Üí Œ≤} (hf : Continuous f) : IsSeparable (f '' s) := by\n  rcases hs with ‚ü®c, c_count, hc‚ü©\n  refine ‚ü®f '' c, c_count.image _, ?_‚ü©\n  rw [image_subset_iff]\n  exact hc.trans (closure_subset_preimage_closure_image hf)\n\n"}
{"name":"Dense.isSeparable_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\nhs : Dense s\n‚ä¢ Iff (TopologicalSpace.IsSeparable s) (TopologicalSpace.SeparableSpace Œ±)","decl":"theorem _root_.Dense.isSeparable_iff (hs : Dense s) :\n    IsSeparable s ‚Üî SeparableSpace Œ± := by\n  simp_rw [IsSeparable, separableSpace_iff, dense_iff_closure_eq, ‚Üê univ_subset_iff,\n    ‚Üê hs.closure_eq, isClosed_closure.closure_subset_iff]\n\n"}
{"name":"TopologicalSpace.isSeparable_univ_iff","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\n‚ä¢ Iff (TopologicalSpace.IsSeparable Set.univ) (TopologicalSpace.SeparableSpace Œ±)","decl":"theorem isSeparable_univ_iff : IsSeparable (univ : Set Œ±) ‚Üî SeparableSpace Œ± :=\n  dense_univ.isSeparable_iff\n\n"}
{"name":"TopologicalSpace.isSeparable_range","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nŒ≤ : Type u_1\nt : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : TopologicalSpace.SeparableSpace Œ±\nf : Œ± ‚Üí Œ≤\nhf : Continuous f\n‚ä¢ TopologicalSpace.IsSeparable (Set.range f)","decl":"theorem isSeparable_range [TopologicalSpace Œ≤] [SeparableSpace Œ±] {f : Œ± ‚Üí Œ≤} (hf : Continuous f) :\n    IsSeparable (range f) :=\n  image_univ (f := f) ‚ñ∏ (isSeparable_univ_iff.2 ‚Äπ_‚Ä∫).image hf\n\n"}
{"name":"TopologicalSpace.IsSeparable.of_subtype","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\n‚ä¢ TopologicalSpace.IsSeparable s","decl":"theorem IsSeparable.of_subtype (s : Set Œ±) [SeparableSpace s] : IsSeparable s := by\n  simpa using isSeparable_range (continuous_subtype_val (p := (¬∑ ‚àà s)))\n\n"}
{"name":"TopologicalSpace.IsSeparable.of_separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nh : TopologicalSpace.SeparableSpace Œ±\ns : Set Œ±\n‚ä¢ TopologicalSpace.IsSeparable s","decl":"theorem IsSeparable.of_separableSpace [h : SeparableSpace Œ±] (s : Set Œ±) : IsSeparable s :=\n  IsSeparable.mono (isSeparable_univ_iff.2 h) (subset_univ _)\n\n"}
{"name":"IsTopologicalBasis.iInf","module":"Mathlib.Topology.Bases","initialProofState":"Œ≤ : Type u_1\nŒπ : Type u_2\nt : Œπ ‚Üí TopologicalSpace Œ≤\nT : Œπ ‚Üí Set (Set Œ≤)\nh_basis : ‚àÄ (i : Œπ), TopologicalSpace.IsTopologicalBasis (T i)\n‚ä¢ TopologicalSpace.IsTopologicalBasis (setOf fun S => Exists fun U => Exists fun F => And (‚àÄ (i : Œπ), Membership.mem F i ‚Üí Membership.mem (T i) (U i)) (Eq S (Set.iInter fun i => Set.iInter fun h => U i)))","decl":"protected theorem IsTopologicalBasis.iInf {Œ≤ : Type*} {Œπ : Type*} {t : Œπ ‚Üí TopologicalSpace Œ≤}\n    {T : Œπ ‚Üí Set (Set Œ≤)} (h_basis : ‚àÄ i, IsTopologicalBasis (t := t i) (T i)) :\n    IsTopologicalBasis (t := ‚®Ö i, t i)\n      { S | ‚àÉ (U : Œπ ‚Üí Set Œ≤) (F : Finset Œπ), (‚àÄ i, i ‚àà F ‚Üí U i ‚àà T i) ‚àß S = ‚ãÇ i ‚àà F, U i } := by\n  let _ := ‚®Ö i, t i\n  refine isTopologicalBasis_of_isOpen_of_nhds ?_ ?_\n  ¬∑ rintro - ‚ü®U, F, hU, rfl‚ü©\n    refine isOpen_biInter_finset fun i hi ‚Ü¶\n      (h_basis i).isOpen (t := t i) (hU i hi) |>.mono (iInf_le _ _)\n  ¬∑ intro a u ha hu\n    rcases (nhds_iInf (t := t) (a := a)).symm ‚ñ∏ hasBasis_iInf'\n      (fun i ‚Ü¶ (h_basis i).nhds_hasBasis (t := t i)) |>.mem_iff.1 (hu.mem_nhds ha)\n      with ‚ü®‚ü®F, U‚ü©, ‚ü®hF, hU‚ü©, hUu‚ü©\n    refine ‚ü®_, ‚ü®U, hF.toFinset, ?_, rfl‚ü©, ?_, ?_‚ü© <;> simp only [Finite.mem_toFinset, mem_iInter]\n    ¬∑ exact fun i hi ‚Ü¶ (hU i hi).1\n    ¬∑ exact fun i hi ‚Ü¶ (hU i hi).2\n    ¬∑ exact hUu\n\n"}
{"name":"IsTopologicalBasis.iInf_induced","module":"Mathlib.Topology.Bases","initialProofState":"Œ≤ : Type u_1\nŒπ : Type u_2\nX : Œπ ‚Üí Type u_3\nt : (i : Œπ) ‚Üí TopologicalSpace (X i)\nT : (i : Œπ) ‚Üí Set (Set (X i))\ncond : ‚àÄ (i : Œπ), TopologicalSpace.IsTopologicalBasis (T i)\nf : (i : Œπ) ‚Üí Œ≤ ‚Üí X i\n‚ä¢ TopologicalSpace.IsTopologicalBasis (setOf fun S => Exists fun U => Exists fun F => And (‚àÄ (i : Œπ), Membership.mem F i ‚Üí Membership.mem (T i) (U i)) (Eq S (Set.iInter fun i => Set.iInter fun x => Set.preimage (f i) (U i))))","decl":"theorem IsTopologicalBasis.iInf_induced {Œ≤ : Type*} {Œπ : Type*} {X : Œπ ‚Üí Type*}\n    [t : Œ† i, TopologicalSpace (X i)] {T : Œ† i, Set (Set (X i))}\n    (cond : ‚àÄ i, IsTopologicalBasis (T i)) (f : Œ† i, Œ≤ ‚Üí X i) :\n    IsTopologicalBasis (t := ‚®Ö i, induced (f i) (t i))\n      { S | ‚àÉ (U : ‚àÄ i, Set (X i)) (F : Finset Œπ),\n        (‚àÄ i, i ‚àà F ‚Üí U i ‚àà T i) ‚àß S = ‚ãÇ (i) (_ : i ‚àà F), f i ‚Åª¬π' U i } := by\n  convert IsTopologicalBasis.iInf (fun i ‚Ü¶ (cond i).induced (f i)) with S\n  constructor <;> rintro ‚ü®U, F, hUT, hSU‚ü©\n  ¬∑ exact ‚ü®fun i ‚Ü¶ (f i) ‚Åª¬π' (U i), F, fun i hi ‚Ü¶ mem_image_of_mem _ (hUT i hi), hSU‚ü©\n  ¬∑ choose! U' hU' hUU' using hUT\n    exact ‚ü®U', F, hU', hSU ‚ñ∏ (.symm <| iInter‚ÇÇ_congr hUU')‚ü©\n\n"}
{"name":"isTopologicalBasis_pi","module":"Mathlib.Topology.Bases","initialProofState":"Œπ : Type u_1\nX : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (X i)\nT : (i : Œπ) ‚Üí Set (Set (X i))\ncond : ‚àÄ (i : Œπ), TopologicalSpace.IsTopologicalBasis (T i)\n‚ä¢ TopologicalSpace.IsTopologicalBasis (setOf fun S => Exists fun U => Exists fun F => And (‚àÄ (i : Œπ), Membership.mem F i ‚Üí Membership.mem (T i) (U i)) (Eq S ((‚ÜëF).pi U)))","decl":"theorem isTopologicalBasis_pi {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)]\n    {T : ‚àÄ i, Set (Set (X i))} (cond : ‚àÄ i, IsTopologicalBasis (T i)) :\n    IsTopologicalBasis { S | ‚àÉ (U : ‚àÄ i, Set (X i)) (F : Finset Œπ),\n      (‚àÄ i, i ‚àà F ‚Üí U i ‚àà T i) ‚àß S = (F : Set Œπ).pi U } := by\n  simpa only [Set.pi_def] using IsTopologicalBasis.iInf_induced cond eval\n\n"}
{"name":"isTopologicalBasis_singletons","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\n‚ä¢ TopologicalSpace.IsTopologicalBasis (setOf fun s => Exists fun x => Eq s (Singleton.singleton x))","decl":"theorem isTopologicalBasis_singletons (Œ± : Type*) [TopologicalSpace Œ±] [DiscreteTopology Œ±] :\n    IsTopologicalBasis { s | ‚àÉ x : Œ±, (s : Set Œ±) = {x} } :=\n  isTopologicalBasis_of_isOpen_of_nhds (fun _ _ => isOpen_discrete _) fun x _ hx _ =>\n    ‚ü®{x}, ‚ü®x, rfl‚ü©, mem_singleton x, singleton_subset_iff.2 hx‚ü©\n\n"}
{"name":"isTopologicalBasis_subtype","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nB : Set (Set Œ±)\nh : TopologicalSpace.IsTopologicalBasis B\np : Œ± ‚Üí Prop\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.preimage Subtype.val) B)","decl":"theorem isTopologicalBasis_subtype\n    {Œ± : Type*} [TopologicalSpace Œ±] {B : Set (Set Œ±)}\n    (h : TopologicalSpace.IsTopologicalBasis B) (p : Œ± ‚Üí Prop) :\n    IsTopologicalBasis (Set.preimage (Subtype.val (p := p)) '' B) :=\n  h.isInducing ‚ü®rfl‚ü©\n\n"}
{"name":"isOpenMap_eval","module":"Mathlib.Topology.Bases","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ni : Œπ\n‚ä¢ IsOpenMap (Function.eval i)","decl":"lemma isOpenMap_eval (i : Œπ) : IsOpenMap (Function.eval i : (‚àÄ i, œÄ i) ‚Üí œÄ i) := by\n  classical\n  refine (isTopologicalBasis_pi fun _ ‚Ü¶ isTopologicalBasis_opens).isOpenMap_iff.2 ?_\n  rintro _ ‚ü®U, s, hU, rfl‚ü©\n  obtain h | h := ((s : Set Œπ).pi U).eq_empty_or_nonempty\n  ¬∑ simp [h]\n  by_cases hi : i ‚àà s\n  ¬∑ rw [eval_image_pi (mod_cast hi) h]\n    exact hU _ hi\n  ¬∑ rw [eval_image_pi_of_not_mem (mod_cast hi), if_pos h]\n    exact isOpen_univ\n\n"}
{"name":"Dense.exists_countable_dense_subset","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ns : Set Œ±\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nhs : Dense s\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (Dense t))","decl":"theorem Dense.exists_countable_dense_subset {Œ± : Type*} [TopologicalSpace Œ±] {s : Set Œ±}\n    [SeparableSpace s] (hs : Dense s) : ‚àÉ t ‚äÜ s, t.Countable ‚àß Dense t :=\n  let ‚ü®t, htc, htd‚ü© := exists_countable_dense s\n  ‚ü®(‚Üë) '' t, Subtype.coe_image_subset s t, htc.image Subtype.val,\n    hs.denseRange_val.dense_image continuous_subtype_val htd‚ü©\n\n"}
{"name":"Dense.exists_countable_dense_subset_bot_top","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PartialOrder Œ±\ns : Set Œ±\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nhs : Dense s\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (And (Dense t) (And (‚àÄ (x : Œ±), IsBot x ‚Üí Membership.mem s x ‚Üí Membership.mem t x) (‚àÄ (x : Œ±), IsTop x ‚Üí Membership.mem s x ‚Üí Membership.mem t x))))","decl":"/-- Let `s` be a dense set in a topological space `Œ±` with partial order structure. If `s` is a\nseparable space (e.g., if `Œ±` has a second countable topology), then there exists a countable\ndense subset `t ‚äÜ s` such that `t` contains bottom/top element of `Œ±` when they exist and belong\nto `s`. For a dense subset containing neither bot nor top elements, see\n`Dense.exists_countable_dense_subset_no_bot_top`. -/\ntheorem Dense.exists_countable_dense_subset_bot_top {Œ± : Type*} [TopologicalSpace Œ±]\n    [PartialOrder Œ±] {s : Set Œ±} [SeparableSpace s] (hs : Dense s) :\n    ‚àÉ t ‚äÜ s, t.Countable ‚àß Dense t ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àà s ‚Üí x ‚àà t) ‚àß\n      ‚àÄ x, IsTop x ‚Üí x ‚àà s ‚Üí x ‚àà t := by\n  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©\n  refine ‚ü®(t ‚à™ ({ x | IsBot x } ‚à™ { x | IsTop x })) ‚à© s, ?_, ?_, ?_, ?_, ?_‚ü©\n  exacts [inter_subset_right,\n    (htc.union ((countable_isBot Œ±).union (countable_isTop Œ±))).mono inter_subset_left,\n    htd.mono (subset_inter subset_union_left hts), fun x hx hxs => ‚ü®Or.inr <| Or.inl hx, hxs‚ü©,\n    fun x hx hxs => ‚ü®Or.inr <| Or.inr hx, hxs‚ü©]\n\n"}
{"name":"separableSpace_univ","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace.SeparableSpace Œ±\n‚ä¢ TopologicalSpace.SeparableSpace ‚ÜëSet.univ","decl":"instance separableSpace_univ {Œ± : Type*} [TopologicalSpace Œ±] [SeparableSpace Œ±] :\n    SeparableSpace (univ : Set Œ±) :=\n  (Equiv.Set.univ Œ±).symm.surjective.denseRange.separableSpace (continuous_id.subtype_mk _)\n\n"}
{"name":"exists_countable_dense_bot_top","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace.SeparableSpace Œ±\ninst‚úù : PartialOrder Œ±\n‚ä¢ Exists fun s => And s.Countable (And (Dense s) (And (‚àÄ (x : Œ±), IsBot x ‚Üí Membership.mem s x) (‚àÄ (x : Œ±), IsTop x ‚Üí Membership.mem s x)))","decl":"/-- If `Œ±` is a separable topological space with a partial order, then there exists a countable\ndense set `s : Set Œ±` that contains those of both bottom and top elements of `Œ±` that actually\nexist. For a dense set containing neither bot nor top elements, see\n`exists_countable_dense_no_bot_top`. -/\ntheorem exists_countable_dense_bot_top (Œ± : Type*) [TopologicalSpace Œ±] [SeparableSpace Œ±]\n    [PartialOrder Œ±] :\n    ‚àÉ s : Set Œ±, s.Countable ‚àß Dense s ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àà s) ‚àß ‚àÄ x, IsTop x ‚Üí x ‚àà s := by\n  simpa using dense_univ.exists_countable_dense_subset_bot_top\n\n"}
{"name":"FirstCountableTopology.nhds_generated_countable","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nself : FirstCountableTopology Œ±\na : Œ±\n‚ä¢ (nhds a).IsCountablyGenerated","decl":"/-- A first-countable space is one in which every point has a\n  countable neighborhood basis. -/\nclass _root_.FirstCountableTopology : Prop where\n  /-- The filter `ùìù a` is countably generated for all points `a`. -/\n  nhds_generated_countable : ‚àÄ a : Œ±, (ùìù a).IsCountablyGenerated\n\n"}
{"name":"TopologicalSpace.firstCountableTopology_induced","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\ninst‚úù : FirstCountableTopology Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ FirstCountableTopology Œ±","decl":"/-- If `Œ≤` is a first-countable space, then its induced topology via `f` on `Œ±` is also\nfirst-countable. -/\ntheorem firstCountableTopology_induced (Œ± Œ≤ : Type*) [t : TopologicalSpace Œ≤]\n    [FirstCountableTopology Œ≤] (f : Œ± ‚Üí Œ≤) : @FirstCountableTopology Œ± (t.induced f) :=\n  let _ := t.induced f\n  ‚ü®fun x ‚Ü¶ nhds_induced f x ‚ñ∏ inferInstance‚ü©\n\n"}
{"name":"TopologicalSpace.Subtype.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\ninst‚úù : FirstCountableTopology Œ±\n‚ä¢ FirstCountableTopology ‚Üës","decl":"instance Subtype.firstCountableTopology (s : Set Œ±) [FirstCountableTopology Œ±] :\n    FirstCountableTopology s :=\n  firstCountableTopology_induced s Œ± (‚Üë)\n\n"}
{"name":"Topology.IsInducing.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_1\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : FirstCountableTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Topology.IsInducing f\n‚ä¢ FirstCountableTopology Œ±","decl":"protected theorem _root_.Topology.IsInducing.firstCountableTopology {Œ≤ : Type*}\n    [TopologicalSpace Œ≤] [FirstCountableTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : IsInducing f) :\n    FirstCountableTopology Œ± := by\n  rw [hf.1]\n  exact firstCountableTopology_induced Œ± Œ≤ f\n\n"}
{"name":"Inducing.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_1\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : FirstCountableTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Topology.IsInducing f\n‚ä¢ FirstCountableTopology Œ±","decl":"@[deprecated (since := \"2024-10-28\")]\nalias _root_.Inducing.firstCountableTopology := IsInducing.firstCountableTopology\n\n"}
{"name":"Topology.IsEmbedding.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_1\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : FirstCountableTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Topology.IsEmbedding f\n‚ä¢ FirstCountableTopology Œ±","decl":"protected theorem _root_.Topology.IsEmbedding.firstCountableTopology {Œ≤ : Type*}\n    [TopologicalSpace Œ≤] [FirstCountableTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : IsEmbedding f) :\n    FirstCountableTopology Œ± :=\n  hf.1.firstCountableTopology\n\n"}
{"name":"Embedding.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_1\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : FirstCountableTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Topology.IsEmbedding f\n‚ä¢ FirstCountableTopology Œ±","decl":"@[deprecated (since := \"2024-10-26\")]\nalias _root_.Embedding.firstCountableTopology := IsEmbedding.firstCountableTopology\n\n"}
{"name":"TopologicalSpace.FirstCountableTopology.tendsto_subseq","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : FirstCountableTopology Œ±\nu : Nat ‚Üí Œ±\nx : Œ±\nhx : MapClusterPt x Filter.atTop u\n‚ä¢ Exists fun œà => And (StrictMono œà) (Filter.Tendsto (Function.comp u œà) Filter.atTop (nhds x))","decl":"/-- In a first-countable space, a cluster point `x` of a sequence\nis the limit of some subsequence. -/\ntheorem tendsto_subseq [FirstCountableTopology Œ±] {u : ‚Ñï ‚Üí Œ±} {x : Œ±}\n    (hx : MapClusterPt x atTop u) : ‚àÉ œà : ‚Ñï ‚Üí ‚Ñï, StrictMono œà ‚àß Tendsto (u ‚àò œà) atTop (ùìù x) :=\n  subseq_tendsto_of_neBot hx\n\n"}
{"name":"TopologicalSpace.instFirstCountableTopologyProd","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : FirstCountableTopology Œ±\ninst‚úù : FirstCountableTopology Œ≤\n‚ä¢ FirstCountableTopology (Prod Œ± Œ≤)","decl":"instance {Œ≤} [TopologicalSpace Œ≤] [FirstCountableTopology Œ±] [FirstCountableTopology Œ≤] :\n    FirstCountableTopology (Œ± √ó Œ≤) :=\n  ‚ü®fun ‚ü®x, y‚ü© => by rw [nhds_prod_eq]; infer_instance‚ü©\n\n"}
{"name":"TopologicalSpace.instFirstCountableTopologyForallOfCountable","module":"Mathlib.Topology.Bases","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù¬≤ : Countable Œπ\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ninst‚úù : ‚àÄ (i : Œπ), FirstCountableTopology (œÄ i)\n‚ä¢ FirstCountableTopology ((i : Œπ) ‚Üí œÄ i)","decl":"instance {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Countable Œπ] [‚àÄ i, TopologicalSpace (œÄ i)]\n    [‚àÄ i, FirstCountableTopology (œÄ i)] : FirstCountableTopology (‚àÄ i, œÄ i) :=\n  ‚ü®fun f => by rw [nhds_pi]; infer_instance‚ü©\n\n"}
{"name":"TopologicalSpace.isCountablyGenerated_nhdsWithin","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nx : Œ±\ninst‚úù : (nhds x).IsCountablyGenerated\ns : Set Œ±\n‚ä¢ (nhdsWithin x s).IsCountablyGenerated","decl":"instance isCountablyGenerated_nhdsWithin (x : Œ±) [IsCountablyGenerated (ùìù x)] (s : Set Œ±) :\n    IsCountablyGenerated (ùìù[s] x) :=\n  Inf.isCountablyGenerated _ _\n\n"}
{"name":"SecondCountableTopology.is_open_generated_countable","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nself : SecondCountableTopology Œ±\n‚ä¢ Exists fun b => And b.Countable (Eq t (TopologicalSpace.generateFrom b))","decl":"/-- A second-countable space is one with a countable basis. -/\nclass _root_.SecondCountableTopology : Prop where\n  /-- There exists a countable set of sets that generates the topology. -/\n  is_open_generated_countable : ‚àÉ b : Set (Set Œ±), b.Countable ‚àß t = TopologicalSpace.generateFrom b\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nb : Set (Set Œ±)\nhb : TopologicalSpace.IsTopologicalBasis b\nhc : b.Countable\n‚ä¢ SecondCountableTopology Œ±","decl":"protected theorem IsTopologicalBasis.secondCountableTopology {b : Set (Set Œ±)}\n    (hb : IsTopologicalBasis b) (hc : b.Countable) : SecondCountableTopology Œ± :=\n  ‚ü®‚ü®b, hc, hb.eq_generateFrom‚ü©‚ü©\n\n"}
{"name":"TopologicalSpace.SecondCountableTopology.mk'","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\nb : Set (Set Œ±)\nhc : b.Countable\n‚ä¢ SecondCountableTopology Œ±","decl":"lemma SecondCountableTopology.mk' {Œ±} {b : Set (Set Œ±)} (hc : b.Countable) :\n    @SecondCountableTopology Œ± (generateFrom b) :=\n  @SecondCountableTopology.mk Œ± (generateFrom b) ‚ü®b, hc, rfl‚ü©\n\n"}
{"name":"Finite.toSecondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : Finite Œ±\n‚ä¢ SecondCountableTopology Œ±","decl":"instance _root_.Finite.toSecondCountableTopology [Finite Œ±] : SecondCountableTopology Œ± where\n  is_open_generated_countable :=\n    ‚ü®_, {U | IsOpen U}.to_countable, TopologicalSpace.isTopologicalBasis_opens.eq_generateFrom‚ü©\n\n"}
{"name":"TopologicalSpace.exists_countable_basis","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ Exists fun b => And b.Countable (And (Not (Membership.mem b EmptyCollection.emptyCollection)) (TopologicalSpace.IsTopologicalBasis b))","decl":"theorem exists_countable_basis [SecondCountableTopology Œ±] :\n    ‚àÉ b : Set (Set Œ±), b.Countable ‚àß ‚àÖ ‚àâ b ‚àß IsTopologicalBasis b := by\n  obtain ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := @SecondCountableTopology.is_open_generated_countable Œ± _ _\n  refine ‚ü®_, ?_, not_mem_diff_of_mem ?_, (isTopologicalBasis_of_subbasis hb‚ÇÇ).diff_empty‚ü©\n  exacts [((countable_setOf_finite_subset hb‚ÇÅ).image _).mono diff_subset, rfl]\n\n"}
{"name":"TopologicalSpace.countable_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (TopologicalSpace.countableBasis Œ±).Countable","decl":"theorem countable_countableBasis [SecondCountableTopology Œ±] : (countableBasis Œ±).Countable :=\n  (exists_countable_basis Œ±).choose_spec.1\n\n"}
{"name":"TopologicalSpace.empty_nmem_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ Not (Membership.mem (TopologicalSpace.countableBasis Œ±) EmptyCollection.emptyCollection)","decl":"theorem empty_nmem_countableBasis [SecondCountableTopology Œ±] : ‚àÖ ‚àâ countableBasis Œ± :=\n  (exists_countable_basis Œ±).choose_spec.2.1\n\n"}
{"name":"TopologicalSpace.isBasis_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ TopologicalSpace.IsTopologicalBasis (TopologicalSpace.countableBasis Œ±)","decl":"theorem isBasis_countableBasis [SecondCountableTopology Œ±] :\n    IsTopologicalBasis (countableBasis Œ±) :=\n  (exists_countable_basis Œ±).choose_spec.2.2\n\n"}
{"name":"TopologicalSpace.eq_generateFrom_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ Eq t (TopologicalSpace.generateFrom (TopologicalSpace.countableBasis Œ±))","decl":"theorem eq_generateFrom_countableBasis [SecondCountableTopology Œ±] :\n    ‚ÄπTopologicalSpace Œ±‚Ä∫ = generateFrom (countableBasis Œ±) :=\n  (isBasis_countableBasis Œ±).eq_generateFrom\n\n"}
{"name":"TopologicalSpace.isOpen_of_mem_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\ns : Set Œ±\nhs : Membership.mem (TopologicalSpace.countableBasis Œ±) s\n‚ä¢ IsOpen s","decl":"theorem isOpen_of_mem_countableBasis [SecondCountableTopology Œ±] {s : Set Œ±}\n    (hs : s ‚àà countableBasis Œ±) : IsOpen s :=\n  (isBasis_countableBasis Œ±).isOpen hs\n\n"}
{"name":"TopologicalSpace.nonempty_of_mem_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\ns : Set Œ±\nhs : Membership.mem (TopologicalSpace.countableBasis Œ±) s\n‚ä¢ s.Nonempty","decl":"theorem nonempty_of_mem_countableBasis [SecondCountableTopology Œ±] {s : Set Œ±}\n    (hs : s ‚àà countableBasis Œ±) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 <| ne_of_mem_of_not_mem hs <| empty_nmem_countableBasis Œ±\n\n"}
{"name":"TopologicalSpace.SecondCountableTopology.to_firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ FirstCountableTopology Œ±","decl":"instance (priority := 100) SecondCountableTopology.to_firstCountableTopology\n    [SecondCountableTopology Œ±] : FirstCountableTopology Œ± :=\n  ‚ü®fun _ => HasCountableBasis.isCountablyGenerated <|\n      ‚ü®(isBasis_countableBasis Œ±).nhds_hasBasis,\n        (countable_countableBasis Œ±).mono inter_subset_left‚ü©‚ü©\n\n"}
{"name":"TopologicalSpace.secondCountableTopology_induced","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\ninst‚úù : SecondCountableTopology Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ SecondCountableTopology Œ±","decl":"/-- If `Œ≤` is a second-countable space, then its induced topology via\n`f` on `Œ±` is also second-countable. -/\ntheorem secondCountableTopology_induced (Œ± Œ≤) [t : TopologicalSpace Œ≤] [SecondCountableTopology Œ≤]\n    (f : Œ± ‚Üí Œ≤) : @SecondCountableTopology Œ± (t.induced f) := by\n  rcases @SecondCountableTopology.is_open_generated_countable Œ≤ _ _ with ‚ü®b, hb, eq‚ü©\n  letI := t.induced f\n  refine { is_open_generated_countable := ‚ü®preimage f '' b, hb.image _, ?_‚ü© }\n  rw [eq, induced_generateFrom_eq]\n\n"}
{"name":"TopologicalSpace.Subtype.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ns : Set Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ SecondCountableTopology ‚Üës","decl":"instance Subtype.secondCountableTopology (s : Set Œ±) [SecondCountableTopology Œ±] :\n    SecondCountableTopology s :=\n  secondCountableTopology_induced s Œ± (‚Üë)\n\n"}
{"name":"TopologicalSpace.secondCountableTopology_iInf","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\nŒπ : Sort u_2\ninst‚úù : Countable Œπ\nt : Œπ ‚Üí TopologicalSpace Œ±\nht : ‚àÄ (i : Œπ), SecondCountableTopology Œ±\n‚ä¢ SecondCountableTopology Œ±","decl":"lemma secondCountableTopology_iInf {Œ± Œπ} [Countable Œπ] {t : Œπ ‚Üí TopologicalSpace Œ±}\n    (ht : ‚àÄ i, @SecondCountableTopology Œ± (t i)) : @SecondCountableTopology Œ± (‚®Ö i, t i) := by\n  rw [funext fun i => @eq_generateFrom_countableBasis Œ± (t i) (ht i), ‚Üê generateFrom_iUnion]\n  exact SecondCountableTopology.mk' <|\n    countable_iUnion fun i => @countable_countableBasis _ (t i) (ht i)\n\n-- TODO: more fine grained instances for `FirstCountableTopology`, `SeparableSpace`, `T2Space`, ...\n"}
{"name":"TopologicalSpace.instSecondCountableTopologyProd","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : SecondCountableTopology Œ±\ninst‚úù : SecondCountableTopology Œ≤\n‚ä¢ SecondCountableTopology (Prod Œ± Œ≤)","decl":"instance {Œ≤ : Type*} [TopologicalSpace Œ≤] [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] :\n    SecondCountableTopology (Œ± √ó Œ≤) :=\n  ((isBasis_countableBasis Œ±).prod (isBasis_countableBasis Œ≤)).secondCountableTopology <|\n    (countable_countableBasis Œ±).image2 (countable_countableBasis Œ≤) _\n\n"}
{"name":"TopologicalSpace.instSecondCountableTopologyForallOfCountable","module":"Mathlib.Topology.Bases","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù¬≤ : Countable Œπ\ninst‚úù¬π : (a : Œπ) ‚Üí TopologicalSpace (œÄ a)\ninst‚úù : ‚àÄ (a : Œπ), SecondCountableTopology (œÄ a)\n‚ä¢ SecondCountableTopology ((a : Œπ) ‚Üí œÄ a)","decl":"instance {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Countable Œπ] [‚àÄ a, TopologicalSpace (œÄ a)]\n    [‚àÄ a, SecondCountableTopology (œÄ a)] : SecondCountableTopology (‚àÄ a, œÄ a) :=\n  secondCountableTopology_iInf fun _ => secondCountableTopology_induced _ _ _\n\n-- see Note [lower instance priority]\n"}
{"name":"TopologicalSpace.SecondCountableTopology.to_separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ TopologicalSpace.SeparableSpace Œ±","decl":"instance (priority := 100) SecondCountableTopology.to_separableSpace [SecondCountableTopology Œ±] :\n    SeparableSpace Œ± := by\n  choose p hp using fun s : countableBasis Œ± => nonempty_of_mem_countableBasis s.2\n  exact ‚ü®‚ü®range p, countable_range _, (isBasis_countableBasis Œ±).dense_iff.2 fun o ho _ =>\n          ‚ü®p ‚ü®o, ho‚ü©, hp ‚ü®o, _‚ü©, mem_range_self _‚ü©‚ü©‚ü©\n\n"}
{"name":"TopologicalSpace.secondCountableTopology_of_countable_cover","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒπ : Sort u_1\ninst‚úù¬π : Countable Œπ\nU : Œπ ‚Üí Set Œ±\ninst‚úù : ‚àÄ (i : Œπ), SecondCountableTopology ‚Üë(U i)\nUo : ‚àÄ (i : Œπ), IsOpen (U i)\nhc : Eq (Set.iUnion fun i => U i) Set.univ\n‚ä¢ SecondCountableTopology Œ±","decl":"/-- A countable open cover induces a second-countable topology if all open covers\nare themselves second countable. -/\ntheorem secondCountableTopology_of_countable_cover {Œπ} [Countable Œπ] {U : Œπ ‚Üí Set Œ±}\n    [‚àÄ i, SecondCountableTopology (U i)] (Uo : ‚àÄ i, IsOpen (U i)) (hc : ‚ãÉ i, U i = univ) :\n    SecondCountableTopology Œ± :=\n  haveI : IsTopologicalBasis (‚ãÉ i, image ((‚Üë) : U i ‚Üí Œ±) '' countableBasis (U i)) :=\n    isTopologicalBasis_of_cover Uo hc fun i => isBasis_countableBasis (U i)\n  this.secondCountableTopology (countable_iUnion fun _ => (countable_countableBasis _).image _)\n\n"}
{"name":"TopologicalSpace.isOpen_iUnion_countable","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\nŒπ : Type u_1\ns : Œπ ‚Üí Set Œ±\nH : ‚àÄ (i : Œπ), IsOpen (s i)\n‚ä¢ Exists fun T => And T.Countable (Eq (Set.iUnion fun i => Set.iUnion fun h => s i) (Set.iUnion fun i => s i))","decl":"/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets.\nIn particular, any open covering of `Œ±` has a countable subcover: Œ± is a Lindel√∂f space. -/\ntheorem isOpen_iUnion_countable [SecondCountableTopology Œ±] {Œπ} (s : Œπ ‚Üí Set Œ±)\n    (H : ‚àÄ i, IsOpen (s i)) : ‚àÉ T : Set Œπ, T.Countable ‚àß ‚ãÉ i ‚àà T, s i = ‚ãÉ i, s i := by\n  let B := { b ‚àà countableBasis Œ± | ‚àÉ i, b ‚äÜ s i }\n  choose f hf using fun b : B => b.2.2\n  haveI : Countable B := ((countable_countableBasis Œ±).mono (sep_subset _ _)).to_subtype\n  refine ‚ü®_, countable_range f, (iUnion‚ÇÇ_subset_iUnion _ _).antisymm (sUnion_subset ?_)‚ü©\n  rintro _ ‚ü®i, rfl‚ü© x xs\n  rcases (isBasis_countableBasis Œ±).exists_subset_of_mem_open xs (H _) with ‚ü®b, hb, xb, bs‚ü©\n  exact ‚ü®_, ‚ü®_, rfl‚ü©, _, ‚ü®‚ü®‚ü®_, hb, _, bs‚ü©, rfl‚ü©, rfl‚ü©, hf _ xb‚ü©\n\n"}
{"name":"TopologicalSpace.isOpen_biUnion_countable","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\nŒπ : Type u_1\nI : Set Œπ\ns : Œπ ‚Üí Set Œ±\nH : ‚àÄ (i : Œπ), Membership.mem I i ‚Üí IsOpen (s i)\n‚ä¢ Exists fun T => And (HasSubset.Subset T I) (And T.Countable (Eq (Set.iUnion fun i => Set.iUnion fun h => s i) (Set.iUnion fun i => Set.iUnion fun h => s i)))","decl":"theorem isOpen_biUnion_countable [SecondCountableTopology Œ±] {Œπ : Type*} (I : Set Œπ) (s : Œπ ‚Üí Set Œ±)\n    (H : ‚àÄ i ‚àà I, IsOpen (s i)) : ‚àÉ T ‚äÜ I, T.Countable ‚àß ‚ãÉ i ‚àà T, s i = ‚ãÉ i ‚àà I, s i := by\n  simp_rw [‚Üê Subtype.exists_set_subtype, biUnion_image]\n  rcases isOpen_iUnion_countable (fun i : I ‚Ü¶ s i) fun i ‚Ü¶ H i i.2 with ‚ü®T, hTc, hU‚ü©\n  exact ‚ü®T, hTc.image _, hU.trans <| iUnion_subtype ..‚ü©\n\n"}
{"name":"TopologicalSpace.isOpen_sUnion_countable","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\nS : Set (Set Œ±)\nH : ‚àÄ (s : Set Œ±), Membership.mem S s ‚Üí IsOpen s\n‚ä¢ Exists fun T => And T.Countable (And (HasSubset.Subset T S) (Eq T.sUnion S.sUnion))","decl":"theorem isOpen_sUnion_countable [SecondCountableTopology Œ±] (S : Set (Set Œ±))\n    (H : ‚àÄ s ‚àà S, IsOpen s) : ‚àÉ T : Set (Set Œ±), T.Countable ‚àß T ‚äÜ S ‚àß ‚ãÉ‚ÇÄ T = ‚ãÉ‚ÇÄ S := by\n  simpa only [and_left_comm, sUnion_eq_biUnion] using isOpen_biUnion_countable S id H\n\n"}
{"name":"TopologicalSpace.countable_cover_nhds","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\nf : Œ± ‚Üí Set Œ±\nhf : ‚àÄ (x : Œ±), Membership.mem (nhds x) (f x)\n‚ä¢ Exists fun s => And s.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => f x) Set.univ)","decl":"/-- In a topological space with second countable topology, if `f` is a function that sends each\npoint `x` to a neighborhood of `x`, then for some countable set `s`, the neighborhoods `f x`,\n`x ‚àà s`, cover the whole space. -/\ntheorem countable_cover_nhds [SecondCountableTopology Œ±] {f : Œ± ‚Üí Set Œ±} (hf : ‚àÄ x, f x ‚àà ùìù x) :\n    ‚àÉ s : Set Œ±, s.Countable ‚àß ‚ãÉ x ‚àà s, f x = univ := by\n  rcases isOpen_iUnion_countable (fun x => interior (f x)) fun x => isOpen_interior with\n    ‚ü®s, hsc, hsU‚ü©\n  suffices ‚ãÉ x ‚àà s, interior (f x) = univ from\n    ‚ü®s, hsc, flip eq_univ_of_subset this <| iUnion‚ÇÇ_mono fun _ _ => interior_subset‚ü©\n  simp only [hsU, eq_univ_iff_forall, mem_iUnion]\n  exact fun x => ‚ü®x, mem_interior_iff_mem_nhds.2 (hf x)‚ü©\n\n"}
{"name":"TopologicalSpace.countable_cover_nhdsWithin","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\ninst‚úù : SecondCountableTopology Œ±\nf : Œ± ‚Üí Set Œ±\ns : Set Œ±\nhf : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Membership.mem (nhdsWithin x s) (f x)\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => f x)))","decl":"theorem countable_cover_nhdsWithin [SecondCountableTopology Œ±] {f : Œ± ‚Üí Set Œ±} {s : Set Œ±}\n    (hf : ‚àÄ x ‚àà s, f x ‚àà ùìù[s] x) : ‚àÉ t ‚äÜ s, t.Countable ‚àß s ‚äÜ ‚ãÉ x ‚àà t, f x := by\n  have : ‚àÄ x : s, (‚Üë) ‚Åª¬π' f x ‚àà ùìù x := fun x => preimage_coe_mem_nhds_subtype.2 (hf x x.2)\n  rcases countable_cover_nhds this with ‚ü®t, htc, htU‚ü©\n  refine ‚ü®(‚Üë) '' t, Subtype.coe_image_subset _ _, htc.image _, fun x hx => ?_‚ü©\n  simp only [biUnion_image, eq_univ_iff_forall, ‚Üê preimage_iUnion, mem_preimage] at htU ‚ä¢\n  exact htU ‚ü®x, hx‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.sigma","module":"Mathlib.Topology.Bases","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (E i)\ns : (i : Œπ) ‚Üí Set (Set (E i))\nhs : ‚àÄ (i : Œπ), TopologicalSpace.IsTopologicalBasis (s i)\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.iUnion fun i => Set.image (fun u => Set.image (Sigma.mk i) u) (s i))","decl":"/-- In a disjoint union space `Œ£ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem IsTopologicalBasis.sigma {s : ‚àÄ i : Œπ, Set (Set (E i))}\n    (hs : ‚àÄ i, IsTopologicalBasis (s i)) :\n    IsTopologicalBasis (‚ãÉ i : Œπ, (fun u => (Sigma.mk i '' u : Set (Œ£i, E i))) '' s i) := by\n  refine .of_hasBasis_nhds fun a ‚Ü¶ ?_\n  rw [Sigma.nhds_eq]\n  convert (((hs a.1).nhds_hasBasis).map _).to_image_id\n  aesop\n\n"}
{"name":"TopologicalSpace.instSecondCountableTopologySigmaOfCountable","module":"Mathlib.Topology.Bases","initialProofState":"Œπ : Type u_1\nE : Œπ ‚Üí Type u_2\ninst‚úù¬≤ : (i : Œπ) ‚Üí TopologicalSpace (E i)\ninst‚úù¬π : Countable Œπ\ninst‚úù : ‚àÄ (i : Œπ), SecondCountableTopology (E i)\n‚ä¢ SecondCountableTopology (Sigma fun i => E i)","decl":"/-- A countable disjoint union of second countable spaces is second countable. -/\ninstance [Countable Œπ] [‚àÄ i, SecondCountableTopology (E i)] :\n    SecondCountableTopology (Œ£i, E i) := by\n  let b := ‚ãÉ i : Œπ, (fun u => (Sigma.mk i '' u : Set (Œ£i, E i))) '' countableBasis (E i)\n  have A : IsTopologicalBasis b := IsTopologicalBasis.sigma fun i => isBasis_countableBasis _\n  have B : b.Countable := countable_iUnion fun i => (countable_countableBasis _).image _\n  exact A.secondCountableTopology B\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.sum","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt‚úù : TopologicalSpace Œ±\nŒ≤ : Type u_1\ninst‚úù : TopologicalSpace Œ≤\ns : Set (Set Œ±)\nhs : TopologicalSpace.IsTopologicalBasis s\nt : Set (Set Œ≤)\nht : TopologicalSpace.IsTopologicalBasis t\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Union.union (Set.image (fun u => Set.image Sum.inl u) s) (Set.image (fun u => Set.image Sum.inr u) t))","decl":"/-- In a sum space `Œ± ‚äï Œ≤`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem IsTopologicalBasis.sum {s : Set (Set Œ±)} (hs : IsTopologicalBasis s) {t : Set (Set Œ≤)}\n    (ht : IsTopologicalBasis t) :\n    IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ‚à™ (fun u => Sum.inr '' u) '' t) := by\n  apply isTopologicalBasis_of_isOpen_of_nhds\n  ¬∑ rintro u (‚ü®w, hw, rfl‚ü© | ‚ü®w, hw, rfl‚ü©)\n    ¬∑ exact IsOpenEmbedding.inl.isOpenMap w (hs.isOpen hw)\n    ¬∑ exact IsOpenEmbedding.inr.isOpenMap w (ht.isOpen hw)\n  ¬∑ rintro (x | x) u hxu u_open\n    ¬∑ obtain ‚ü®v, vs, xv, vu‚ü© : ‚àÉ v ‚àà s, x ‚àà v ‚àß v ‚äÜ Sum.inl ‚Åª¬π' u :=\n        hs.exists_subset_of_mem_open hxu (isOpen_sum_iff.1 u_open).1\n      exact ‚ü®Sum.inl '' v, mem_union_left _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv,\n        image_subset_iff.2 vu‚ü©\n    ¬∑ obtain ‚ü®v, vs, xv, vu‚ü© : ‚àÉ v ‚àà t, x ‚àà v ‚àß v ‚äÜ Sum.inr ‚Åª¬π' u :=\n        ht.exists_subset_of_mem_open hxu (isOpen_sum_iff.1 u_open).2\n      exact ‚ü®Sum.inr '' v, mem_union_right _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv,\n        image_subset_iff.2 vu‚ü©\n\n"}
{"name":"TopologicalSpace.instSecondCountableTopologySum","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u\nt : TopologicalSpace Œ±\nŒ≤ : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : SecondCountableTopology Œ±\ninst‚úù : SecondCountableTopology Œ≤\n‚ä¢ SecondCountableTopology (Sum Œ± Œ≤)","decl":"/-- A sum type of two second countable spaces is second countable. -/\ninstance [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] :\n    SecondCountableTopology (Œ± ‚äï Œ≤) := by\n  let b :=\n    (fun u => Sum.inl '' u) '' countableBasis Œ± ‚à™ (fun u => Sum.inr '' u) '' countableBasis Œ≤\n  have A : IsTopologicalBasis b := (isBasis_countableBasis Œ±).sum (isBasis_countableBasis Œ≤)\n  have B : b.Countable :=\n    (Countable.image (countable_countableBasis _) _).union\n      (Countable.image (countable_countableBasis _) _)\n  exact A.secondCountableTopology B\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isQuotientMap","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nY : Type u_2\ninst‚úù : TopologicalSpace Y\nœÄ : X ‚Üí Y\nV : Set (Set X)\nhV : TopologicalSpace.IsTopologicalBasis V\nh' : Topology.IsQuotientMap œÄ\nh : IsOpenMap œÄ\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.image œÄ) V)","decl":"/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem IsTopologicalBasis.isQuotientMap {V : Set (Set X)} (hV : IsTopologicalBasis V)\n    (h' : IsQuotientMap œÄ) (h : IsOpenMap œÄ) : IsTopologicalBasis (Set.image œÄ '' V) := by\n  apply isTopologicalBasis_of_isOpen_of_nhds\n  ¬∑ rintro - ‚ü®U, U_in_V, rfl‚ü©\n    apply h U (hV.isOpen U_in_V)\n  ¬∑ intro y U y_in_U U_open\n    obtain ‚ü®x, rfl‚ü© := h'.surjective y\n    let W := œÄ ‚Åª¬π' U\n    have x_in_W : x ‚àà W := y_in_U\n    have W_open : IsOpen W := U_open.preimage h'.continuous\n    obtain ‚ü®Z, Z_in_V, x_in_Z, Z_in_W‚ü© := hV.exists_subset_of_mem_open x_in_W W_open\n    have œÄZ_in_U : œÄ '' Z ‚äÜ U := (Set.image_subset _ Z_in_W).trans (image_preimage_subset œÄ U)\n    exact ‚ü®œÄ '' Z, ‚ü®Z, Z_in_V, rfl‚ü©, ‚ü®x, x_in_Z, rfl‚ü©, œÄZ_in_U‚ü©\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.quotientMap","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nY : Type u_2\ninst‚úù : TopologicalSpace Y\nœÄ : X ‚Üí Y\nV : Set (Set X)\nhV : TopologicalSpace.IsTopologicalBasis V\nh' : Topology.IsQuotientMap œÄ\nh : IsOpenMap œÄ\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.image œÄ) V)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias IsTopologicalBasis.quotientMap := IsTopologicalBasis.isQuotientMap\n\n"}
{"name":"Topology.IsQuotientMap.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\nY : Type u_2\ninst‚úù¬π : TopologicalSpace Y\nœÄ : X ‚Üí Y\ninst‚úù : SecondCountableTopology X\nh' : Topology.IsQuotientMap œÄ\nh : IsOpenMap œÄ\n‚ä¢ SecondCountableTopology Y","decl":"/-- A second countable space is mapped by an open quotient map to a second countable space. -/\ntheorem _root_.Topology.IsQuotientMap.secondCountableTopology [SecondCountableTopology X]\n    (h' : IsQuotientMap œÄ) (h : IsOpenMap œÄ) : SecondCountableTopology Y where\n  is_open_generated_countable := by\n    obtain ‚ü®V, V_countable, -, V_generates‚ü© := exists_countable_basis X\n    exact ‚ü®Set.image œÄ '' V, V_countable.image (Set.image œÄ),\n      (V_generates.isQuotientMap h' h).eq_generateFrom‚ü©\n\n"}
{"name":"QuotientMap.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\nY : Type u_2\ninst‚úù¬π : TopologicalSpace Y\nœÄ : X ‚Üí Y\ninst‚úù : SecondCountableTopology X\nh' : Topology.IsQuotientMap œÄ\nh : IsOpenMap œÄ\n‚ä¢ SecondCountableTopology Y","decl":"@[deprecated (since := \"2024-10-22\")]\nalias _root_.QuotientMap.secondCountableTopology := IsQuotientMap.secondCountableTopology\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.quotient","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nS : Setoid X\nV : Set (Set X)\nhV : TopologicalSpace.IsTopologicalBasis V\nh : IsOpenMap Quotient.mk'\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.image Quotient.mk') V)","decl":"/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem IsTopologicalBasis.quotient {V : Set (Set X)} (hV : IsTopologicalBasis V)\n    (h : IsOpenMap (Quotient.mk' : X ‚Üí Quotient S)) :\n    IsTopologicalBasis (Set.image (Quotient.mk' : X ‚Üí Quotient S) '' V) :=\n  hV.isQuotientMap isQuotientMap_quotient_mk' h\n\n"}
{"name":"TopologicalSpace.Quotient.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nS : Setoid X\ninst‚úù : SecondCountableTopology X\nh : IsOpenMap Quotient.mk'\n‚ä¢ SecondCountableTopology (Quotient S)","decl":"/-- An open quotient of a second countable space is second countable. -/\ntheorem Quotient.secondCountableTopology [SecondCountableTopology X]\n    (h : IsOpenMap (Quotient.mk' : X ‚Üí Quotient S)) : SecondCountableTopology (Quotient S) :=\n  isQuotientMap_quotient_mk'.secondCountableTopology h\n\n"}
{"name":"Topology.IsInducing.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\nf : Œ± ‚Üí Œ≤\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : SecondCountableTopology Œ≤\nhf : Topology.IsInducing f\n‚ä¢ SecondCountableTopology Œ±","decl":"protected theorem Topology.IsInducing.secondCountableTopology [TopologicalSpace Œ≤]\n    [SecondCountableTopology Œ≤] (hf : IsInducing f) : SecondCountableTopology Œ± := by\n  rw [hf.1]\n  exact secondCountableTopology_induced Œ± Œ≤ f\n\n"}
{"name":"Inducing.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\nf : Œ± ‚Üí Œ≤\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : SecondCountableTopology Œ≤\nhf : Topology.IsInducing f\n‚ä¢ SecondCountableTopology Œ±","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.secondCountableTopology := IsInducing.secondCountableTopology\n\n"}
{"name":"Topology.IsEmbedding.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\nf : Œ± ‚Üí Œ≤\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : SecondCountableTopology Œ≤\nhf : Topology.IsEmbedding f\n‚ä¢ SecondCountableTopology Œ±","decl":"protected theorem Topology.IsEmbedding.secondCountableTopology\n    [TopologicalSpace Œ≤] [SecondCountableTopology Œ≤]\n    (hf : IsEmbedding f) : SecondCountableTopology Œ± :=\n  hf.1.secondCountableTopology\n\n"}
{"name":"Topology.IsEmbedding.separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : SecondCountableTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Topology.IsEmbedding f\n‚ä¢ TopologicalSpace.SeparableSpace Œ±","decl":"protected theorem Topology.IsEmbedding.separableSpace\n    [TopologicalSpace Œ≤] [SecondCountableTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : IsEmbedding f) :\n    TopologicalSpace.SeparableSpace Œ± := by\n  have := hf.secondCountableTopology\n  exact SecondCountableTopology.to_separableSpace\n"}
