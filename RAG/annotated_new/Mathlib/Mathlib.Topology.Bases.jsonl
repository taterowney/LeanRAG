{"name":"TopologicalSpace.IsTopologicalBasis.exists_subset_inter","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set (Set α)\nself : TopologicalSpace.IsTopologicalBasis s\nt₁ : Set α\na✝² : Membership.mem s t₁\nt₂ : Set α\na✝¹ : Membership.mem s t₂\nx : α\na✝ : Membership.mem (Inter.inter t₁ t₂) x\n⊢ Exists fun t₃ => And (Membership.mem s t₃) (And (Membership.mem t₃ x) (HasSubset.Subset t₃ (Inter.inter t₁ t₂)))","decl":"/-- A topological basis is one that satisfies the necessary conditions so that\n  it suffices to take unions of the basis sets to get a topology (without taking\n  finite intersections as well). -/\nstructure IsTopologicalBasis (s : Set (Set α)) : Prop where\n  /-- For every point `x`, the set of `t ∈ s` such that `x ∈ t` is directed downwards. -/\n  exists_subset_inter : ∀ t₁ ∈ s, ∀ t₂ ∈ s, ∀ x ∈ t₁ ∩ t₂, ∃ t₃ ∈ s, x ∈ t₃ ∧ t₃ ⊆ t₁ ∩ t₂\n  /-- The sets from `s` cover the whole space. -/\n  sUnion_eq : ⋃₀ s = univ\n  /-- The topology is generated by sets from `s`. -/\n  eq_generateFrom : t = generateFrom s\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.eq_generateFrom","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set (Set α)\nself : TopologicalSpace.IsTopologicalBasis s\n⊢ Eq t (TopologicalSpace.generateFrom s)","decl":"/-- A topological basis is one that satisfies the necessary conditions so that\n  it suffices to take unions of the basis sets to get a topology (without taking\n  finite intersections as well). -/\nstructure IsTopologicalBasis (s : Set (Set α)) : Prop where\n  /-- For every point `x`, the set of `t ∈ s` such that `x ∈ t` is directed downwards. -/\n  exists_subset_inter : ∀ t₁ ∈ s, ∀ t₂ ∈ s, ∀ x ∈ t₁ ∩ t₂, ∃ t₃ ∈ s, x ∈ t₃ ∧ t₃ ⊆ t₁ ∩ t₂\n  /-- The sets from `s` cover the whole space. -/\n  sUnion_eq : ⋃₀ s = univ\n  /-- The topology is generated by sets from `s`. -/\n  eq_generateFrom : t = generateFrom s\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.sUnion_eq","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set (Set α)\nself : TopologicalSpace.IsTopologicalBasis s\n⊢ Eq s.sUnion Set.univ","decl":"/-- A topological basis is one that satisfies the necessary conditions so that\n  it suffices to take unions of the basis sets to get a topology (without taking\n  finite intersections as well). -/\nstructure IsTopologicalBasis (s : Set (Set α)) : Prop where\n  /-- For every point `x`, the set of `t ∈ s` such that `x ∈ t` is directed downwards. -/\n  exists_subset_inter : ∀ t₁ ∈ s, ∀ t₂ ∈ s, ∀ x ∈ t₁ ∩ t₂, ∃ t₃ ∈ s, x ∈ t₃ ∧ t₃ ⊆ t₁ ∩ t₂\n  /-- The sets from `s` cover the whole space. -/\n  sUnion_eq : ⋃₀ s = univ\n  /-- The topology is generated by sets from `s`. -/\n  eq_generateFrom : t = generateFrom s\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.insert_empty","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set (Set α)\nh : TopologicalSpace.IsTopologicalBasis s\n⊢ TopologicalSpace.IsTopologicalBasis (Insert.insert EmptyCollection.emptyCollection s)","decl":"theorem IsTopologicalBasis.insert_empty {s : Set (Set α)} (h : IsTopologicalBasis s) :\n    IsTopologicalBasis (insert ∅ s) := by\n  refine ⟨?_, by rw [sUnion_insert, empty_union, h.sUnion_eq], ?_⟩\n  · rintro t₁ (rfl | h₁) t₂ (rfl | h₂) x ⟨hx₁, hx₂⟩\n    · cases hx₁\n    · cases hx₁\n    · cases hx₂\n    · obtain ⟨t₃, h₃, hs⟩ := h.exists_subset_inter _ h₁ _ h₂ x ⟨hx₁, hx₂⟩\n      exact ⟨t₃, .inr h₃, hs⟩\n  · rw [h.eq_generateFrom]\n    refine le_antisymm (le_generateFrom fun t => ?_) (generateFrom_anti <| subset_insert ∅ s)\n    rintro (rfl | ht)\n    · exact @isOpen_empty _ (generateFrom s)\n    · exact .basic t ht\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.diff_empty","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set (Set α)\nh : TopologicalSpace.IsTopologicalBasis s\n⊢ TopologicalSpace.IsTopologicalBasis (SDiff.sdiff s (Singleton.singleton EmptyCollection.emptyCollection))","decl":"theorem IsTopologicalBasis.diff_empty {s : Set (Set α)} (h : IsTopologicalBasis s) :\n    IsTopologicalBasis (s \\ {∅}) := by\n  refine ⟨?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_⟩\n  · rintro t₁ ⟨h₁, -⟩ t₂ ⟨h₂, -⟩ x hx\n    obtain ⟨t₃, h₃, hs⟩ := h.exists_subset_inter _ h₁ _ h₂ x hx\n    exact ⟨t₃, ⟨h₃, Nonempty.ne_empty ⟨x, hs.1⟩⟩, hs⟩\n  · rw [h.eq_generateFrom]\n    refine le_antisymm (generateFrom_anti diff_subset) (le_generateFrom fun t ht => ?_)\n    obtain rfl | he := eq_or_ne t ∅\n    · exact @isOpen_empty _ (generateFrom _)\n    · exact .basic t ⟨ht, he⟩\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_subbasis","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set (Set α)\nhs : Eq t (TopologicalSpace.generateFrom s)\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image (fun f => f.sInter) (setOf fun f => And f.Finite (HasSubset.Subset f s)))","decl":"/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem isTopologicalBasis_of_subbasis {s : Set (Set α)} (hs : t = generateFrom s) :\n    IsTopologicalBasis ((fun f => ⋂₀ f) '' { f : Set (Set α) | f.Finite ∧ f ⊆ s }) := by\n  subst t; letI := generateFrom s\n  refine ⟨?_, ?_, le_antisymm (le_generateFrom ?_) <| generateFrom_anti fun t ht => ?_⟩\n  · rintro _ ⟨t₁, ⟨hft₁, ht₁b⟩, rfl⟩ _ ⟨t₂, ⟨hft₂, ht₂b⟩, rfl⟩ x h\n    exact ⟨_, ⟨_, ⟨hft₁.union hft₂, union_subset ht₁b ht₂b⟩, sInter_union t₁ t₂⟩, h, Subset.rfl⟩\n  · rw [sUnion_image, iUnion₂_eq_univ_iff]\n    exact fun x => ⟨∅, ⟨finite_empty, empty_subset _⟩, sInter_empty.substr <| mem_univ x⟩\n  · rintro _ ⟨t, ⟨hft, htb⟩, rfl⟩\n    exact hft.isOpen_sInter fun s hs ↦ GenerateOpen.basic _ <| htb hs\n  · rw [← sInter_singleton t]\n    exact ⟨{t}, ⟨finite_singleton t, singleton_subset_iff.2 ht⟩, rfl⟩\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_subbasis_of_finiteInter","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set (Set α)\nhsg : Eq t (TopologicalSpace.generateFrom s)\nhsi : FiniteInter s\n⊢ TopologicalSpace.IsTopologicalBasis s","decl":"theorem isTopologicalBasis_of_subbasis_of_finiteInter {s : Set (Set α)} (hsg : t = generateFrom s)\n    (hsi : FiniteInter s) : IsTopologicalBasis s := by\n  convert isTopologicalBasis_of_subbasis hsg\n  refine le_antisymm (fun t ht ↦ ⟨{t}, by simpa using ht⟩) ?_\n  rintro _ ⟨g, ⟨hg, hgs⟩, rfl⟩\n  lift g to Finset (Set α) using hg\n  exact hsi.finiteInter_mem g hgs\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_subbasis_of_inter","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nr : Set (Set α)\nhsg : Eq t (TopologicalSpace.generateFrom r)\nhsi : ∀ ⦃s : Set α⦄, Membership.mem r s → ∀ ⦃t : Set α⦄, Membership.mem r t → Membership.mem r (Inter.inter s t)\n⊢ TopologicalSpace.IsTopologicalBasis (Insert.insert Set.univ r)","decl":"theorem isTopologicalBasis_of_subbasis_of_inter {r : Set (Set α)} (hsg : t = generateFrom r)\n    (hsi : ∀ ⦃s⦄, s ∈ r → ∀ ⦃t⦄, t ∈ r → s ∩ t ∈ r) : IsTopologicalBasis (insert univ r) :=\n  isTopologicalBasis_of_subbasis_of_finiteInter (by simpa using hsg) (FiniteInter.mk₂ hsi)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.of_hasBasis_nhds","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set (Set α)\nh_nhds : ∀ (a : α), (nhds a).HasBasis (fun t => And (Membership.mem s t) (Membership.mem t a)) id\n⊢ TopologicalSpace.IsTopologicalBasis s","decl":"theorem IsTopologicalBasis.of_hasBasis_nhds {s : Set (Set α)}\n    (h_nhds : ∀ a, (𝓝 a).HasBasis (fun t ↦ t ∈ s ∧ a ∈ t) id) : IsTopologicalBasis s where\n  exists_subset_inter t₁ ht₁ t₂ ht₂ x hx := by\n    simpa only [and_assoc, (h_nhds x).mem_iff]\n      using (inter_mem ((h_nhds _).mem_of_mem ⟨ht₁, hx.1⟩) ((h_nhds _).mem_of_mem ⟨ht₂, hx.2⟩))\n  sUnion_eq := sUnion_eq_univ_iff.2 fun x ↦ (h_nhds x).ex_mem\n  eq_generateFrom := ext_nhds fun x ↦ by\n    simpa only [nhds_generateFrom, and_comm] using (h_nhds x).eq_biInf\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set (Set α)\nh_open : ∀ (u : Set α), Membership.mem s u → IsOpen u\nh_nhds : ∀ (a : α) (u : Set α), Membership.mem u a → IsOpen u → Exists fun v => And (Membership.mem s v) (And (Membership.mem v a) (HasSubset.Subset v u))\n⊢ TopologicalSpace.IsTopologicalBasis s","decl":"/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem isTopologicalBasis_of_isOpen_of_nhds {s : Set (Set α)} (h_open : ∀ u ∈ s, IsOpen u)\n    (h_nhds : ∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v ∈ s, a ∈ v ∧ v ⊆ u) :\n    IsTopologicalBasis s :=\n  .of_hasBasis_nhds <| fun a ↦\n    (nhds_basis_opens a).to_hasBasis' (by simpa [and_assoc] using h_nhds a)\n      fun _ ⟨hts, hat⟩ ↦ (h_open _ hts).mem_nhds hat\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.mem_nhds_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\na : α\ns : Set α\nb : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis b\n⊢ Iff (Membership.mem (nhds a) s) (Exists fun t => And (Membership.mem b t) (And (Membership.mem t a) (HasSubset.Subset t s)))","decl":"/-- A set `s` is in the neighbourhood of `a` iff there is some basis set `t`, which\ncontains `a` and is itself contained in `s`. -/\ntheorem IsTopologicalBasis.mem_nhds_iff {a : α} {s : Set α} {b : Set (Set α)}\n    (hb : IsTopologicalBasis b) : s ∈ 𝓝 a ↔ ∃ t ∈ b, a ∈ t ∧ t ⊆ s := by\n  change s ∈ (𝓝 a).sets ↔ ∃ t ∈ b, a ∈ t ∧ t ⊆ s\n  rw [hb.eq_generateFrom, nhds_generateFrom, biInf_sets_eq]\n  · simp [and_assoc, and_left_comm]\n  · rintro s ⟨hs₁, hs₂⟩ t ⟨ht₁, ht₂⟩\n    let ⟨u, hu₁, hu₂, hu₃⟩ := hb.1 _ hs₂ _ ht₂ _ ⟨hs₁, ht₁⟩\n    exact ⟨u, ⟨hu₂, hu₁⟩, le_principal_iff.2 (hu₃.trans inter_subset_left),\n      le_principal_iff.2 (hu₃.trans inter_subset_right)⟩\n  · rcases eq_univ_iff_forall.1 hb.sUnion_eq a with ⟨i, h1, h2⟩\n    exact ⟨i, h2, h1⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isOpen_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\nb : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis b\n⊢ Iff (IsOpen s) (∀ (a : α), Membership.mem s a → Exists fun t => And (Membership.mem b t) (And (Membership.mem t a) (HasSubset.Subset t s)))","decl":"theorem IsTopologicalBasis.isOpen_iff {s : Set α} {b : Set (Set α)} (hb : IsTopologicalBasis b) :\n    IsOpen s ↔ ∀ a ∈ s, ∃ t ∈ b, a ∈ t ∧ t ⊆ s := by simp [isOpen_iff_mem_nhds, hb.mem_nhds_iff]\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.nhds_hasBasis","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nb : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis b\na : α\n⊢ (nhds a).HasBasis (fun t => And (Membership.mem b t) (Membership.mem t a)) fun t => t","decl":"theorem IsTopologicalBasis.nhds_hasBasis {b : Set (Set α)} (hb : IsTopologicalBasis b) {a : α} :\n    (𝓝 a).HasBasis (fun t : Set α => t ∈ b ∧ a ∈ t) fun t => t :=\n  ⟨fun s => hb.mem_nhds_iff.trans <| by simp only [and_assoc]⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isOpen","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\nb : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis b\nhs : Membership.mem b s\n⊢ IsOpen s","decl":"protected theorem IsTopologicalBasis.isOpen {s : Set α} {b : Set (Set α)}\n    (hb : IsTopologicalBasis b) (hs : s ∈ b) : IsOpen s := by\n  rw [hb.eq_generateFrom]\n  exact .basic s hs\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.mem_nhds","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\na : α\ns : Set α\nb : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis b\nhs : Membership.mem b s\nha : Membership.mem s a\n⊢ Membership.mem (nhds a) s","decl":"protected theorem IsTopologicalBasis.mem_nhds {a : α} {s : Set α} {b : Set (Set α)}\n    (hb : IsTopologicalBasis b) (hs : s ∈ b) (ha : a ∈ s) : s ∈ 𝓝 a :=\n  (hb.isOpen hs).mem_nhds ha\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.exists_subset_of_mem_open","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nb : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis b\na : α\nu : Set α\nau : Membership.mem u a\nou : IsOpen u\n⊢ Exists fun v => And (Membership.mem b v) (And (Membership.mem v a) (HasSubset.Subset v u))","decl":"theorem IsTopologicalBasis.exists_subset_of_mem_open {b : Set (Set α)} (hb : IsTopologicalBasis b)\n    {a : α} {u : Set α} (au : a ∈ u) (ou : IsOpen u) : ∃ v ∈ b, a ∈ v ∧ v ⊆ u :=\n  hb.mem_nhds_iff.1 <| IsOpen.mem_nhds ou au\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.open_eq_sUnion'","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nB : Set (Set α)\nhB : TopologicalSpace.IsTopologicalBasis B\nu : Set α\nou : IsOpen u\n⊢ Eq u (setOf fun s => And (Membership.mem B s) (HasSubset.Subset s u)).sUnion","decl":"/-- Any open set is the union of the basis sets contained in it. -/\ntheorem IsTopologicalBasis.open_eq_sUnion' {B : Set (Set α)} (hB : IsTopologicalBasis B) {u : Set α}\n    (ou : IsOpen u) : u = ⋃₀ { s ∈ B | s ⊆ u } :=\n  ext fun _a =>\n    ⟨fun ha =>\n      let ⟨b, hb, ab, bu⟩ := hB.exists_subset_of_mem_open ha ou\n      ⟨b, ⟨hb, bu⟩, ab⟩,\n      fun ⟨_b, ⟨_, bu⟩, ab⟩ => bu ab⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.open_eq_sUnion","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nB : Set (Set α)\nhB : TopologicalSpace.IsTopologicalBasis B\nu : Set α\nou : IsOpen u\n⊢ Exists fun S => And (HasSubset.Subset S B) (Eq u S.sUnion)","decl":"theorem IsTopologicalBasis.open_eq_sUnion {B : Set (Set α)} (hB : IsTopologicalBasis B) {u : Set α}\n    (ou : IsOpen u) : ∃ S ⊆ B, u = ⋃₀ S :=\n  ⟨{ s ∈ B | s ⊆ u }, fun _ h => h.1, hB.open_eq_sUnion' ou⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.open_iff_eq_sUnion","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nB : Set (Set α)\nhB : TopologicalSpace.IsTopologicalBasis B\nu : Set α\n⊢ Iff (IsOpen u) (Exists fun S => And (HasSubset.Subset S B) (Eq u S.sUnion))","decl":"theorem IsTopologicalBasis.open_iff_eq_sUnion {B : Set (Set α)} (hB : IsTopologicalBasis B)\n    {u : Set α} : IsOpen u ↔ ∃ S ⊆ B, u = ⋃₀ S :=\n  ⟨hB.open_eq_sUnion, fun ⟨_S, hSB, hu⟩ => hu.symm ▸ isOpen_sUnion fun _s hs => hB.isOpen (hSB hs)⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.open_eq_iUnion","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nB : Set (Set α)\nhB : TopologicalSpace.IsTopologicalBasis B\nu : Set α\nou : IsOpen u\n⊢ Exists fun β => Exists fun f => And (Eq u (Set.iUnion fun i => f i)) (∀ (i : β), Membership.mem B (f i))","decl":"theorem IsTopologicalBasis.open_eq_iUnion {B : Set (Set α)} (hB : IsTopologicalBasis B) {u : Set α}\n    (ou : IsOpen u) : ∃ (β : Type u) (f : β → Set α), (u = ⋃ i, f i) ∧ ∀ i, f i ∈ B :=\n  ⟨↥({ s ∈ B | s ⊆ u }), (↑), by\n    rw [← sUnion_eq_iUnion]\n    apply hB.open_eq_sUnion' ou, fun s => And.left s.2⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.subset_of_forall_subset","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt✝ : TopologicalSpace α\nB : Set (Set α)\ns t : Set α\nhB : TopologicalSpace.IsTopologicalBasis B\nhs : IsOpen s\nh : ∀ (U : Set α), Membership.mem B U → HasSubset.Subset U s → HasSubset.Subset U t\n⊢ HasSubset.Subset s t","decl":"lemma IsTopologicalBasis.subset_of_forall_subset {t : Set α} (hB : IsTopologicalBasis B)\n    (hs : IsOpen s) (h : ∀ U ∈ B, U ⊆ s → U ⊆ t) : s ⊆ t := by\n  rw [hB.open_eq_sUnion' hs]; simpa [sUnion_subset_iff]\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.eq_of_forall_subset_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt✝ : TopologicalSpace α\nB : Set (Set α)\ns t : Set α\nhB : TopologicalSpace.IsTopologicalBasis B\nhs : IsOpen s\nht : IsOpen t\nh : ∀ (U : Set α), Membership.mem B U → Iff (HasSubset.Subset U s) (HasSubset.Subset U t)\n⊢ Eq s t","decl":"lemma IsTopologicalBasis.eq_of_forall_subset_iff {t : Set α} (hB : IsTopologicalBasis B)\n    (hs : IsOpen s) (ht : IsOpen t) (h : ∀ U ∈ B, U ⊆ s ↔ U ⊆ t) : s = t := by\n  rw [hB.open_eq_sUnion' hs, hB.open_eq_sUnion' ht]\n  exact congr_arg _ (Set.ext fun U ↦ and_congr_right <| h _)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.mem_closure_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nb : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis b\ns : Set α\na : α\n⊢ Iff (Membership.mem (closure s) a) (∀ (o : Set α), Membership.mem b o → Membership.mem o a → (Inter.inter o s).Nonempty)","decl":"/-- A point `a` is in the closure of `s` iff all basis sets containing `a` intersect `s`. -/\ntheorem IsTopologicalBasis.mem_closure_iff {b : Set (Set α)} (hb : IsTopologicalBasis b) {s : Set α}\n    {a : α} : a ∈ closure s ↔ ∀ o ∈ b, a ∈ o → (o ∩ s).Nonempty :=\n  (mem_closure_iff_nhds_basis' hb.nhds_hasBasis).trans <| by simp only [and_imp]\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.dense_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nb : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis b\ns : Set α\n⊢ Iff (Dense s) (∀ (o : Set α), Membership.mem b o → o.Nonempty → (Inter.inter o s).Nonempty)","decl":"/-- A set is dense iff it has non-trivial intersection with all basis sets. -/\ntheorem IsTopologicalBasis.dense_iff {b : Set (Set α)} (hb : IsTopologicalBasis b) {s : Set α} :\n    Dense s ↔ ∀ o ∈ b, Set.Nonempty o → (o ∩ s).Nonempty := by\n  simp only [Dense, hb.mem_closure_iff]\n  exact ⟨fun h o hb ⟨a, ha⟩ => h a o hb ha, fun h a o hb ha => h o hb ⟨a, ha⟩⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isOpenMap_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_2\ninst✝ : TopologicalSpace β\nB : Set (Set α)\nhB : TopologicalSpace.IsTopologicalBasis B\nf : α → β\n⊢ Iff (IsOpenMap f) (∀ (s : Set α), Membership.mem B s → IsOpen (Set.image f s))","decl":"theorem IsTopologicalBasis.isOpenMap_iff {β} [TopologicalSpace β] {B : Set (Set α)}\n    (hB : IsTopologicalBasis B) {f : α → β} : IsOpenMap f ↔ ∀ s ∈ B, IsOpen (f '' s) := by\n  refine ⟨fun H o ho => H _ (hB.isOpen ho), fun hf o ho => ?_⟩\n  rw [hB.open_eq_sUnion' ho, sUnion_eq_iUnion, image_iUnion]\n  exact isOpen_iUnion fun s => hf s s.2.1\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.exists_nonempty_subset","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nB : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis B\nu : Set α\nhu : u.Nonempty\nou : IsOpen u\n⊢ Exists fun v => And (Membership.mem B v) (And v.Nonempty (HasSubset.Subset v u))","decl":"theorem IsTopologicalBasis.exists_nonempty_subset {B : Set (Set α)} (hb : IsTopologicalBasis B)\n    {u : Set α} (hu : u.Nonempty) (ou : IsOpen u) : ∃ v ∈ B, Set.Nonempty v ∧ v ⊆ u :=\n  let ⟨x, hx⟩ := hu\n  let ⟨v, vB, xv, vu⟩ := hb.exists_subset_of_mem_open hx ou\n  ⟨v, vB, ⟨x, xv⟩, vu⟩\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_opens","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\n⊢ TopologicalSpace.IsTopologicalBasis (setOf fun U => IsOpen U)","decl":"theorem isTopologicalBasis_opens : IsTopologicalBasis { U : Set α | IsOpen U } :=\n  isTopologicalBasis_of_isOpen_of_nhds (by tauto) (by tauto)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isInducing","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_2\ninst✝ : TopologicalSpace β\nf : α → β\nT : Set (Set β)\nhf : Topology.IsInducing f\nh : TopologicalSpace.IsTopologicalBasis T\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.preimage f) T)","decl":"protected lemma IsTopologicalBasis.isInducing {β} [TopologicalSpace β] {f : α → β} {T : Set (Set β)}\n    (hf : IsInducing f) (h : IsTopologicalBasis T) : IsTopologicalBasis ((preimage f) '' T) :=\n  .of_hasBasis_nhds fun a ↦ by\n    convert (hf.basis_nhds (h.nhds_hasBasis (a := f a))).to_image_id with s\n    aesop\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.inducing","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_2\ninst✝ : TopologicalSpace β\nf : α → β\nT : Set (Set β)\nhf : Topology.IsInducing f\nh : TopologicalSpace.IsTopologicalBasis T\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.preimage f) T)","decl":"@[deprecated (since := \"2024-10-28\")]\nalias IsTopologicalBasis.inducing := IsTopologicalBasis.isInducing\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.induced","module":"Mathlib.Topology.Bases","initialProofState":"β : Type u_1\nα : Type u_2\ns : TopologicalSpace β\nf : α → β\nT : Set (Set β)\nh : TopologicalSpace.IsTopologicalBasis T\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.preimage f) T)","decl":"protected theorem IsTopologicalBasis.induced {α} [s : TopologicalSpace β] (f : α → β)\n    {T : Set (Set β)} (h : IsTopologicalBasis T) :\n    IsTopologicalBasis (t := induced f s) ((preimage f) '' T) :=\n  h.isInducing (t := induced f s) (.induced f)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.inf","module":"Mathlib.Topology.Bases","initialProofState":"β : Type u_1\nt₁ t₂ : TopologicalSpace β\nB₁ B₂ : Set (Set β)\nh₁ : TopologicalSpace.IsTopologicalBasis B₁\nh₂ : TopologicalSpace.IsTopologicalBasis B₂\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image2 (fun x1 x2 => Inter.inter x1 x2) B₁ B₂)","decl":"protected theorem IsTopologicalBasis.inf {t₁ t₂ : TopologicalSpace β} {B₁ B₂ : Set (Set β)}\n    (h₁ : IsTopologicalBasis (t := t₁) B₁) (h₂ : IsTopologicalBasis (t := t₂) B₂) :\n    IsTopologicalBasis (t := t₁ ⊓ t₂) (image2 (· ∩ ·) B₁ B₂) := by\n  refine .of_hasBasis_nhds (t := ?_) fun a ↦ ?_\n  rw [nhds_inf (t₁ := t₁)]\n  convert ((h₁.nhds_hasBasis (t := t₁)).inf (h₂.nhds_hasBasis (t := t₂))).to_image_id\n  aesop\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.inf_induced","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nβ : Type u_1\nt : TopologicalSpace α\nγ : Type u_2\ns : TopologicalSpace β\nB₁ : Set (Set α)\nB₂ : Set (Set β)\nh₁ : TopologicalSpace.IsTopologicalBasis B₁\nh₂ : TopologicalSpace.IsTopologicalBasis B₂\nf₁ : γ → α\nf₂ : γ → β\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image2 (fun x1 x2 => Inter.inter (Set.preimage f₁ x1) (Set.preimage f₂ x2)) B₁ B₂)","decl":"theorem IsTopologicalBasis.inf_induced {γ} [s : TopologicalSpace β] {B₁ : Set (Set α)}\n    {B₂ : Set (Set β)} (h₁ : IsTopologicalBasis B₁) (h₂ : IsTopologicalBasis B₂) (f₁ : γ → α)\n    (f₂ : γ → β) :\n    IsTopologicalBasis (t := induced f₁ t ⊓ induced f₂ s) (image2 (f₁ ⁻¹' · ∩ f₂ ⁻¹' ·) B₁ B₂) := by\n  simpa only [image2_image_left, image2_image_right] using (h₁.induced f₁).inf (h₂.induced f₂)\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.prod","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_2\ninst✝ : TopologicalSpace β\nB₁ : Set (Set α)\nB₂ : Set (Set β)\nh₁ : TopologicalSpace.IsTopologicalBasis B₁\nh₂ : TopologicalSpace.IsTopologicalBasis B₂\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) B₁ B₂)","decl":"protected theorem IsTopologicalBasis.prod {β} [TopologicalSpace β] {B₁ : Set (Set α)}\n    {B₂ : Set (Set β)} (h₁ : IsTopologicalBasis B₁) (h₂ : IsTopologicalBasis B₂) :\n    IsTopologicalBasis (image2 (· ×ˢ ·) B₁ B₂) :=\n  h₁.inf_induced h₂ Prod.fst Prod.snd\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_of_cover","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nι : Sort u_2\nU : ι → Set α\nUo : ∀ (i : ι), IsOpen (U i)\nUc : Eq (Set.iUnion fun i => U i) Set.univ\nb : (i : ι) → Set (Set ↑(U i))\nhb : ∀ (i : ι), TopologicalSpace.IsTopologicalBasis (b i)\n⊢ TopologicalSpace.IsTopologicalBasis (Set.iUnion fun i => Set.image (Set.image Subtype.val) (b i))","decl":"theorem isTopologicalBasis_of_cover {ι} {U : ι → Set α} (Uo : ∀ i, IsOpen (U i))\n    (Uc : ⋃ i, U i = univ) {b : ∀ i, Set (Set (U i))} (hb : ∀ i, IsTopologicalBasis (b i)) :\n    IsTopologicalBasis (⋃ i : ι, image ((↑) : U i → α) '' b i) := by\n  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => ?_) ?_\n  · simp only [mem_iUnion, mem_image] at hu\n    rcases hu with ⟨i, s, sb, rfl⟩\n    exact (Uo i).isOpenMap_subtype_val _ ((hb i).isOpen sb)\n  · intro a u ha uo\n    rcases iUnion_eq_univ_iff.1 Uc a with ⟨i, hi⟩\n    lift a to ↥(U i) using hi\n    rcases (hb i).exists_subset_of_mem_open ha (uo.preimage continuous_subtype_val) with\n      ⟨v, hvb, hav, hvu⟩\n    exact ⟨(↑) '' v, mem_iUnion.2 ⟨i, mem_image_of_mem _ hvb⟩, mem_image_of_mem _ hav,\n      image_subset_iff.2 hvu⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.continuous_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_2\ninst✝ : TopologicalSpace β\nB : Set (Set β)\nhB : TopologicalSpace.IsTopologicalBasis B\nf : α → β\n⊢ Iff (Continuous f) (∀ (s : Set β), Membership.mem B s → IsOpen (Set.preimage f s))","decl":"protected theorem IsTopologicalBasis.continuous_iff {β : Type*} [TopologicalSpace β]\n    {B : Set (Set β)} (hB : IsTopologicalBasis B) {f : α → β} :\n    Continuous f ↔ ∀ s ∈ B, IsOpen (f ⁻¹' s) := by\n  rw [hB.eq_generateFrom, continuous_generateFrom_iff]\n\n"}
{"name":"TopologicalSpace.isTopologicalBasis_empty","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\n⊢ Iff (TopologicalSpace.IsTopologicalBasis EmptyCollection.emptyCollection) (IsEmpty α)","decl":"@[simp] lemma isTopologicalBasis_empty : IsTopologicalBasis (∅ : Set (Set α)) ↔ IsEmpty α where\n  mp h := by simpa using h.sUnion_eq.symm\n  mpr h := ⟨by simp, by simp [Set.univ_eq_empty_iff.2], Subsingleton.elim ..⟩\n\n"}
{"name":"TopologicalSpace.separableSpace_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\n⊢ Iff (TopologicalSpace.SeparableSpace α) (Exists fun s => And s.Countable (Dense s))","decl":"/-- A separable space is one with a countable dense subset, available through\n`TopologicalSpace.exists_countable_dense`. If `α` is also known to be nonempty, then\n`TopologicalSpace.denseSeq` provides a sequence `ℕ → α` with dense range, see\n`TopologicalSpace.denseRange_denseSeq`.\n\nIf `α` is a uniform space with countably generated uniformity filter (e.g., an `EMetricSpace`), then\nthis condition is equivalent to `SecondCountableTopology α`. In this case the\nlatter should be used as a typeclass argument in theorems because Lean can automatically deduce\n`TopologicalSpace.SeparableSpace` from `SecondCountableTopology` but it can't\ndeduce `SecondCountableTopology` from `TopologicalSpace.SeparableSpace`.\n\nPorting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: the previous paragraph describes the state of the art in Lean 3.\nWe can have instance cycles in Lean 4 but we might want to\npostpone adding them till after the port. -/\n@[mk_iff] class SeparableSpace : Prop where\n  /-- There exists a countable dense set. -/\n  exists_countable_dense : ∃ s : Set α, s.Countable ∧ Dense s\n\n"}
{"name":"TopologicalSpace.SeparableSpace.exists_countable_dense","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nself : TopologicalSpace.SeparableSpace α\n⊢ Exists fun s => And s.Countable (Dense s)","decl":"/-- A separable space is one with a countable dense subset, available through\n`TopologicalSpace.exists_countable_dense`. If `α` is also known to be nonempty, then\n`TopologicalSpace.denseSeq` provides a sequence `ℕ → α` with dense range, see\n`TopologicalSpace.denseRange_denseSeq`.\n\nIf `α` is a uniform space with countably generated uniformity filter (e.g., an `EMetricSpace`), then\nthis condition is equivalent to `SecondCountableTopology α`. In this case the\nlatter should be used as a typeclass argument in theorems because Lean can automatically deduce\n`TopologicalSpace.SeparableSpace` from `SecondCountableTopology` but it can't\ndeduce `SecondCountableTopology` from `TopologicalSpace.SeparableSpace`.\n\nPorting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: the previous paragraph describes the state of the art in Lean 3.\nWe can have instance cycles in Lean 4 but we might want to\npostpone adding them till after the port. -/\n@[mk_iff] class SeparableSpace : Prop where\n  /-- There exists a countable dense set. -/\n  exists_countable_dense : ∃ s : Set α, s.Countable ∧ Dense s\n\n"}
{"name":"TopologicalSpace.exists_countable_dense","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : TopologicalSpace.SeparableSpace α\n⊢ Exists fun s => And s.Countable (Dense s)","decl":"theorem exists_countable_dense [SeparableSpace α] : ∃ s : Set α, s.Countable ∧ Dense s :=\n  SeparableSpace.exists_countable_dense\n\n"}
{"name":"TopologicalSpace.exists_dense_seq","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝¹ : TopologicalSpace.SeparableSpace α\ninst✝ : Nonempty α\n⊢ Exists fun u => DenseRange u","decl":"/-- A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the\nconclusion of this lemma, you might want to use `TopologicalSpace.denseSeq` and\n`TopologicalSpace.denseRange_denseSeq`.\n\nIf `α` might be empty, then `TopologicalSpace.exists_countable_dense` is the main way to use\nseparability of `α`. -/\ntheorem exists_dense_seq [SeparableSpace α] [Nonempty α] : ∃ u : ℕ → α, DenseRange u := by\n  obtain ⟨s : Set α, hs, s_dense⟩ := exists_countable_dense α\n  cases' Set.countable_iff_exists_subset_range.mp hs with u hu\n  exact ⟨u, s_dense.mono hu⟩\n\n"}
{"name":"TopologicalSpace.denseRange_denseSeq","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝¹ : TopologicalSpace.SeparableSpace α\ninst✝ : Nonempty α\n⊢ DenseRange (TopologicalSpace.denseSeq α)","decl":"/-- The sequence `TopologicalSpace.denseSeq α` has dense range. -/\n@[simp]\ntheorem denseRange_denseSeq [SeparableSpace α] [Nonempty α] : DenseRange (denseSeq α) :=\n  Classical.choose_spec (exists_dense_seq α)\n\n"}
{"name":"TopologicalSpace.Countable.to_separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : Countable α\n⊢ TopologicalSpace.SeparableSpace α","decl":"instance (priority := 100) Countable.to_separableSpace [Countable α] : SeparableSpace α where\n  exists_countable_dense := ⟨Set.univ, Set.countable_univ, dense_univ⟩\n\n"}
{"name":"TopologicalSpace.SeparableSpace.of_denseRange","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nι : Type u_2\ninst✝ : Countable ι\nu : ι → α\nhu : DenseRange u\n⊢ TopologicalSpace.SeparableSpace α","decl":"/-- If `f` has a dense range and its domain is countable, then its codomain is a separable space.\nSee also `DenseRange.separableSpace`. -/\ntheorem SeparableSpace.of_denseRange {ι : Sort _} [Countable ι] (u : ι → α) (hu : DenseRange u) :\n    SeparableSpace α :=\n  ⟨⟨range u, countable_range u, hu⟩⟩\n\n"}
{"name":"DenseRange.separableSpace'","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nι : Type u_2\ninst✝ : Countable ι\nu : ι → α\nhu : DenseRange u\n⊢ TopologicalSpace.SeparableSpace α","decl":"alias _root_.DenseRange.separableSpace' := SeparableSpace.of_denseRange\n\n"}
{"name":"DenseRange.separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nβ : Type u_1\nt : TopologicalSpace α\ninst✝¹ : TopologicalSpace.SeparableSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nh : DenseRange f\nh' : Continuous f\n⊢ TopologicalSpace.SeparableSpace β","decl":"/-- If `α` is a separable space and `f : α → β` is a continuous map with dense range, then `β` is\na separable space as well. E.g., the completion of a separable uniform space is separable. -/\nprotected theorem _root_.DenseRange.separableSpace [SeparableSpace α] [TopologicalSpace β]\n    {f : α → β} (h : DenseRange f) (h' : Continuous f) : SeparableSpace β :=\n  let ⟨s, s_cnt, s_dense⟩ := exists_countable_dense α\n  ⟨⟨f '' s, Countable.image s_cnt f, h.dense_image h' s_dense⟩⟩\n\n"}
{"name":"Topology.IsQuotientMap.separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nβ : Type u_1\nt : TopologicalSpace α\ninst✝¹ : TopologicalSpace.SeparableSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Topology.IsQuotientMap f\n⊢ TopologicalSpace.SeparableSpace β","decl":"theorem _root_.Topology.IsQuotientMap.separableSpace [SeparableSpace α] [TopologicalSpace β]\n    {f : α → β} (hf : IsQuotientMap f) : SeparableSpace β :=\n  hf.surjective.denseRange.separableSpace hf.continuous\n\n"}
{"name":"QuotientMap.separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nβ : Type u_1\nt : TopologicalSpace α\ninst✝¹ : TopologicalSpace.SeparableSpace α\ninst✝ : TopologicalSpace β\nf : α → β\nhf : Topology.IsQuotientMap f\n⊢ TopologicalSpace.SeparableSpace β","decl":"@[deprecated (since := \"2024-10-22\")]\nalias _root_.QuotientMap.separableSpace := Topology.IsQuotientMap.separableSpace\n\n"}
{"name":"TopologicalSpace.instSeparableSpaceProd","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nβ : Type u_1\nt : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : TopologicalSpace.SeparableSpace α\ninst✝ : TopologicalSpace.SeparableSpace β\n⊢ TopologicalSpace.SeparableSpace (Prod α β)","decl":"/-- The product of two separable spaces is a separable space. -/\ninstance [TopologicalSpace β] [SeparableSpace α] [SeparableSpace β] : SeparableSpace (α × β) := by\n  rcases exists_countable_dense α with ⟨s, hsc, hsd⟩\n  rcases exists_countable_dense β with ⟨t, htc, htd⟩\n  exact ⟨⟨s ×ˢ t, hsc.prod htc, hsd.prod htd⟩⟩\n\n"}
{"name":"TopologicalSpace.instSeparableSpaceForallOfCountable","module":"Mathlib.Topology.Bases","initialProofState":"ι : Type u_2\nX : ι → Type u_3\ninst✝² : (i : ι) → TopologicalSpace (X i)\ninst✝¹ : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)\ninst✝ : Countable ι\n⊢ TopologicalSpace.SeparableSpace ((i : ι) → X i)","decl":"/-- The product of a countable family of separable spaces is a separable space. -/\ninstance {ι : Type*} {X : ι → Type*} [∀ i, TopologicalSpace (X i)] [∀ i, SeparableSpace (X i)]\n    [Countable ι] : SeparableSpace (∀ i, X i) := by\n  choose t htc htd using (exists_countable_dense <| X ·)\n  haveI := fun i ↦ (htc i).to_subtype\n  nontriviality ∀ i, X i; inhabit ∀ i, X i\n  classical\n    set f : (Σ I : Finset ι, ∀ i : I, t i) → ∀ i, X i := fun ⟨I, g⟩ i ↦\n      if hi : i ∈ I then g ⟨i, hi⟩ else (default : ∀ i, X i) i\n    refine ⟨⟨range f, countable_range f, dense_iff_inter_open.2 fun U hU ⟨g, hg⟩ ↦ ?_⟩⟩\n    rcases isOpen_pi_iff.1 hU g hg with ⟨I, u, huo, huU⟩\n    have : ∀ i : I, ∃ y ∈ t i, y ∈ u i := fun i ↦\n      (htd i).exists_mem_open (huo i i.2).1 ⟨_, (huo i i.2).2⟩\n    choose y hyt hyu using this\n    lift y to ∀ i : I, t i using hyt\n    refine ⟨f ⟨I, y⟩, huU fun i (hi : i ∈ I) ↦ ?_, mem_range_self (f := f) ⟨I, y⟩⟩\n    simp only [f, dif_pos hi]\n    exact hyu ⟨i, _⟩\n\n"}
{"name":"TopologicalSpace.instSeparableSpaceQuot","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : TopologicalSpace.SeparableSpace α\nr : α → α → Prop\n⊢ TopologicalSpace.SeparableSpace (Quot r)","decl":"instance [SeparableSpace α] {r : α → α → Prop} : SeparableSpace (Quot r) :=\n  isQuotientMap_quot_mk.separableSpace\n\n"}
{"name":"TopologicalSpace.instSeparableSpaceQuotient","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : TopologicalSpace.SeparableSpace α\ns : Setoid α\n⊢ TopologicalSpace.SeparableSpace (Quotient s)","decl":"instance [SeparableSpace α] {s : Setoid α} : SeparableSpace (Quotient s) :=\n  isQuotientMap_quot_mk.separableSpace\n\n"}
{"name":"TopologicalSpace.separableSpace_iff_countable","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : DiscreteTopology α\n⊢ Iff (TopologicalSpace.SeparableSpace α) (Countable α)","decl":"/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem separableSpace_iff_countable [DiscreteTopology α] : SeparableSpace α ↔ Countable α := by\n  simp [separableSpace_iff, countable_univ_iff]\n\n"}
{"name":"Pairwise.countable_of_isOpen_disjoint","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : TopologicalSpace.SeparableSpace α\nι : Type u_2\ns : ι → Set α\nhd : Pairwise (Function.onFun Disjoint s)\nho : ∀ (i : ι), IsOpen (s i)\nhne : ∀ (i : ι), (s i).Nonempty\n⊢ Countable ι","decl":"/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem _root_.Pairwise.countable_of_isOpen_disjoint [SeparableSpace α] {ι : Type*}\n    {s : ι → Set α} (hd : Pairwise (Disjoint on s)) (ho : ∀ i, IsOpen (s i))\n    (hne : ∀ i, (s i).Nonempty) : Countable ι := by\n  rcases exists_countable_dense α with ⟨u, u_countable, u_dense⟩\n  choose f hfu hfs using fun i ↦ u_dense.exists_mem_open (ho i) (hne i)\n  have f_inj : Injective f := fun i j hij ↦\n    hd.eq <| not_disjoint_iff.2 ⟨f i, hfs i, hij.symm ▸ hfs j⟩\n  have := u_countable.to_subtype\n  exact (f_inj.codRestrict hfu).countable\n\n"}
{"name":"Set.PairwiseDisjoint.countable_of_isOpen","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : TopologicalSpace.SeparableSpace α\nι : Type u_2\ns : ι → Set α\na : Set ι\nh : a.PairwiseDisjoint s\nho : ∀ (i : ι), Membership.mem a i → IsOpen (s i)\nhne : ∀ (i : ι), Membership.mem a i → (s i).Nonempty\n⊢ a.Countable","decl":"/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem _root_.Set.PairwiseDisjoint.countable_of_isOpen [SeparableSpace α] {ι : Type*}\n    {s : ι → Set α} {a : Set ι} (h : a.PairwiseDisjoint s) (ho : ∀ i ∈ a, IsOpen (s i))\n    (hne : ∀ i ∈ a, (s i).Nonempty) : a.Countable :=\n  (h.subtype _ _).countable_of_isOpen_disjoint (Subtype.forall.2 ho) (Subtype.forall.2 hne)\n\n"}
{"name":"Set.PairwiseDisjoint.countable_of_nonempty_interior","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : TopologicalSpace.SeparableSpace α\nι : Type u_2\ns : ι → Set α\na : Set ι\nh : a.PairwiseDisjoint s\nha : ∀ (i : ι), Membership.mem a i → (interior (s i)).Nonempty\n⊢ a.Countable","decl":"/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem _root_.Set.PairwiseDisjoint.countable_of_nonempty_interior [SeparableSpace α] {ι : Type*}\n    {s : ι → Set α} {a : Set ι} (h : a.PairwiseDisjoint s)\n    (ha : ∀ i ∈ a, (interior (s i)).Nonempty) : a.Countable :=\n  (h.mono fun _ => interior_subset).countable_of_isOpen (fun _ _ => isOpen_interior) ha\n\n"}
{"name":"TopologicalSpace.IsSeparable.mono","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns u : Set α\nhs : TopologicalSpace.IsSeparable s\nhu : HasSubset.Subset u s\n⊢ TopologicalSpace.IsSeparable u","decl":"theorem IsSeparable.mono {s u : Set α} (hs : IsSeparable s) (hu : u ⊆ s) : IsSeparable u := by\n  rcases hs with ⟨c, c_count, hs⟩\n  exact ⟨c, c_count, hu.trans hs⟩\n\n"}
{"name":"TopologicalSpace.IsSeparable.iUnion","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nι : Sort u_2\ninst✝ : Countable ι\ns : ι → Set α\nhs : ∀ (i : ι), TopologicalSpace.IsSeparable (s i)\n⊢ TopologicalSpace.IsSeparable (Set.iUnion fun i => s i)","decl":"theorem IsSeparable.iUnion {ι : Sort*} [Countable ι] {s : ι → Set α}\n    (hs : ∀ i, IsSeparable (s i)) : IsSeparable (⋃ i, s i) := by\n  choose c hc h'c using hs\n  refine ⟨⋃ i, c i, countable_iUnion hc, iUnion_subset_iff.2 fun i => ?_⟩\n  exact (h'c i).trans (closure_mono (subset_iUnion _ i))\n\n"}
{"name":"TopologicalSpace.isSeparable_iUnion","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nι : Sort u_2\ninst✝ : Countable ι\ns : ι → Set α\n⊢ Iff (TopologicalSpace.IsSeparable (Set.iUnion fun i => s i)) (∀ (i : ι), TopologicalSpace.IsSeparable (s i))","decl":"@[simp]\ntheorem isSeparable_iUnion {ι : Sort*} [Countable ι] {s : ι → Set α} :\n    IsSeparable (⋃ i, s i) ↔ ∀ i, IsSeparable (s i) :=\n  ⟨fun h i ↦ h.mono <| subset_iUnion s i, .iUnion⟩\n\n"}
{"name":"TopologicalSpace.isSeparable_union","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt✝ : TopologicalSpace α\ns t : Set α\n⊢ Iff (TopologicalSpace.IsSeparable (Union.union s t)) (And (TopologicalSpace.IsSeparable s) (TopologicalSpace.IsSeparable t))","decl":"@[simp]\ntheorem isSeparable_union {s t : Set α} : IsSeparable (s ∪ t) ↔ IsSeparable s ∧ IsSeparable t := by\n  simp [union_eq_iUnion, and_comm]\n\n"}
{"name":"TopologicalSpace.IsSeparable.union","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns u : Set α\nhs : TopologicalSpace.IsSeparable s\nhu : TopologicalSpace.IsSeparable u\n⊢ TopologicalSpace.IsSeparable (Union.union s u)","decl":"theorem IsSeparable.union {s u : Set α} (hs : IsSeparable s) (hu : IsSeparable u) :\n    IsSeparable (s ∪ u) :=\n  isSeparable_union.2 ⟨hs, hu⟩\n\n"}
{"name":"TopologicalSpace.isSeparable_closure","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\n⊢ Iff (TopologicalSpace.IsSeparable (closure s)) (TopologicalSpace.IsSeparable s)","decl":"@[simp]\ntheorem isSeparable_closure : IsSeparable (closure s) ↔ IsSeparable s := by\n  simp only [IsSeparable, isClosed_closure.closure_subset_iff]\n\n"}
{"name":"TopologicalSpace.IsSeparable.closure","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\na✝ : TopologicalSpace.IsSeparable s\n⊢ TopologicalSpace.IsSeparable (closure s)","decl":"protected alias ⟨_, IsSeparable.closure⟩ := isSeparable_closure\n\n"}
{"name":"Set.Countable.isSeparable","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\nhs : s.Countable\n⊢ TopologicalSpace.IsSeparable s","decl":"theorem _root_.Set.Countable.isSeparable {s : Set α} (hs : s.Countable) : IsSeparable s :=\n  ⟨s, hs, subset_closure⟩\n\n"}
{"name":"Set.Finite.isSeparable","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\nhs : s.Finite\n⊢ TopologicalSpace.IsSeparable s","decl":"theorem _root_.Set.Finite.isSeparable {s : Set α} (hs : s.Finite) : IsSeparable s :=\n  hs.countable.isSeparable\n\n"}
{"name":"TopologicalSpace.IsSeparable.univ_pi","module":"Mathlib.Topology.Bases","initialProofState":"ι : Type u_2\ninst✝¹ : Countable ι\nX : ι → Type u_3\ns : (i : ι) → Set (X i)\ninst✝ : (i : ι) → TopologicalSpace (X i)\nh : ∀ (i : ι), TopologicalSpace.IsSeparable (s i)\n⊢ TopologicalSpace.IsSeparable (Set.univ.pi s)","decl":"theorem IsSeparable.univ_pi {ι : Type*} [Countable ι] {X : ι → Type*} {s : ∀ i, Set (X i)}\n    [∀ i, TopologicalSpace (X i)] (h : ∀ i, IsSeparable (s i)) :\n    IsSeparable (univ.pi s) := by\n  classical\n  rcases eq_empty_or_nonempty (univ.pi s) with he | ⟨f₀, -⟩\n  · rw [he]\n    exact countable_empty.isSeparable\n  · choose c c_count hc using h\n    haveI := fun i ↦ (c_count i).to_subtype\n    set g : (I : Finset ι) × ((i : I) → c i) → (i : ι) → X i := fun ⟨I, f⟩ i ↦\n      if hi : i ∈ I then f ⟨i, hi⟩ else f₀ i\n    refine ⟨range g, countable_range g, fun f hf ↦ mem_closure_iff.2 fun o ho hfo ↦ ?_⟩\n    rcases isOpen_pi_iff.1 ho f hfo with ⟨I, u, huo, hI⟩\n    rsuffices ⟨f, hf⟩ : ∃ f : (i : I) → c i, g ⟨I, f⟩ ∈ Set.pi I u\n    · exact ⟨g ⟨I, f⟩, hI hf, mem_range_self (f := g) ⟨I, f⟩⟩\n    suffices H : ∀ i ∈ I, (u i ∩ c i).Nonempty by\n      choose f hfu hfc using H\n      refine ⟨fun i ↦ ⟨f i i.2, hfc i i.2⟩, fun i (hi : i ∈ I) ↦ ?_⟩\n      simpa only [g, dif_pos hi] using hfu i hi\n    intro i hi\n    exact mem_closure_iff.1 (hc i <| hf _ trivial) _ (huo i hi).1 (huo i hi).2\n\n"}
{"name":"TopologicalSpace.isSeparable_pi","module":"Mathlib.Topology.Bases","initialProofState":"ι : Type u_2\ninst✝¹ : Countable ι\nα : ι → Type u_3\ns : (i : ι) → Set (α i)\ninst✝ : (i : ι) → TopologicalSpace (α i)\nh : ∀ (i : ι), TopologicalSpace.IsSeparable (s i)\n⊢ TopologicalSpace.IsSeparable (setOf fun f => ∀ (i : ι), Membership.mem (s i) (f i))","decl":"lemma isSeparable_pi {ι : Type*} [Countable ι] {α : ι → Type*} {s : ∀ i, Set (α i)}\n    [∀ i, TopologicalSpace (α i)] (h : ∀ i, IsSeparable (s i)) :\n    IsSeparable {f : ∀ i, α i | ∀ i, f i ∈ s i} := by\n  simpa only [← mem_univ_pi] using IsSeparable.univ_pi h\n\n"}
{"name":"TopologicalSpace.IsSeparable.prod","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt✝ : TopologicalSpace α\nβ : Type u_2\ninst✝ : TopologicalSpace β\ns : Set α\nt : Set β\nhs : TopologicalSpace.IsSeparable s\nht : TopologicalSpace.IsSeparable t\n⊢ TopologicalSpace.IsSeparable (SProd.sprod s t)","decl":"lemma IsSeparable.prod {β : Type*} [TopologicalSpace β]\n    {s : Set α} {t : Set β} (hs : IsSeparable s) (ht : IsSeparable t) :\n    IsSeparable (s ×ˢ t) := by\n  rcases hs with ⟨cs, cs_count, hcs⟩\n  rcases ht with ⟨ct, ct_count, hct⟩\n  refine ⟨cs ×ˢ ct, cs_count.prod ct_count, ?_⟩\n  rw [closure_prod_eq]\n  gcongr\n\n"}
{"name":"TopologicalSpace.IsSeparable.image","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_2\ninst✝ : TopologicalSpace β\ns : Set α\nhs : TopologicalSpace.IsSeparable s\nf : α → β\nhf : Continuous f\n⊢ TopologicalSpace.IsSeparable (Set.image f s)","decl":"theorem IsSeparable.image {β : Type*} [TopologicalSpace β] {s : Set α} (hs : IsSeparable s)\n    {f : α → β} (hf : Continuous f) : IsSeparable (f '' s) := by\n  rcases hs with ⟨c, c_count, hc⟩\n  refine ⟨f '' c, c_count.image _, ?_⟩\n  rw [image_subset_iff]\n  exact hc.trans (closure_subset_preimage_closure_image hf)\n\n"}
{"name":"Dense.isSeparable_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\nhs : Dense s\n⊢ Iff (TopologicalSpace.IsSeparable s) (TopologicalSpace.SeparableSpace α)","decl":"theorem _root_.Dense.isSeparable_iff (hs : Dense s) :\n    IsSeparable s ↔ SeparableSpace α := by\n  simp_rw [IsSeparable, separableSpace_iff, dense_iff_closure_eq, ← univ_subset_iff,\n    ← hs.closure_eq, isClosed_closure.closure_subset_iff]\n\n"}
{"name":"TopologicalSpace.isSeparable_univ_iff","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\n⊢ Iff (TopologicalSpace.IsSeparable Set.univ) (TopologicalSpace.SeparableSpace α)","decl":"theorem isSeparable_univ_iff : IsSeparable (univ : Set α) ↔ SeparableSpace α :=\n  dense_univ.isSeparable_iff\n\n"}
{"name":"TopologicalSpace.isSeparable_range","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nβ : Type u_1\nt : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.SeparableSpace α\nf : α → β\nhf : Continuous f\n⊢ TopologicalSpace.IsSeparable (Set.range f)","decl":"theorem isSeparable_range [TopologicalSpace β] [SeparableSpace α] {f : α → β} (hf : Continuous f) :\n    IsSeparable (range f) :=\n  image_univ (f := f) ▸ (isSeparable_univ_iff.2 ‹_›).image hf\n\n"}
{"name":"TopologicalSpace.IsSeparable.of_subtype","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\ninst✝ : TopologicalSpace.SeparableSpace ↑s\n⊢ TopologicalSpace.IsSeparable s","decl":"theorem IsSeparable.of_subtype (s : Set α) [SeparableSpace s] : IsSeparable s := by\n  simpa using isSeparable_range (continuous_subtype_val (p := (· ∈ s)))\n\n"}
{"name":"TopologicalSpace.IsSeparable.of_separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nh : TopologicalSpace.SeparableSpace α\ns : Set α\n⊢ TopologicalSpace.IsSeparable s","decl":"theorem IsSeparable.of_separableSpace [h : SeparableSpace α] (s : Set α) : IsSeparable s :=\n  IsSeparable.mono (isSeparable_univ_iff.2 h) (subset_univ _)\n\n"}
{"name":"IsTopologicalBasis.iInf","module":"Mathlib.Topology.Bases","initialProofState":"β : Type u_1\nι : Type u_2\nt : ι → TopologicalSpace β\nT : ι → Set (Set β)\nh_basis : ∀ (i : ι), TopologicalSpace.IsTopologicalBasis (T i)\n⊢ TopologicalSpace.IsTopologicalBasis (setOf fun S => Exists fun U => Exists fun F => And (∀ (i : ι), Membership.mem F i → Membership.mem (T i) (U i)) (Eq S (Set.iInter fun i => Set.iInter fun h => U i)))","decl":"protected theorem IsTopologicalBasis.iInf {β : Type*} {ι : Type*} {t : ι → TopologicalSpace β}\n    {T : ι → Set (Set β)} (h_basis : ∀ i, IsTopologicalBasis (t := t i) (T i)) :\n    IsTopologicalBasis (t := ⨅ i, t i)\n      { S | ∃ (U : ι → Set β) (F : Finset ι), (∀ i, i ∈ F → U i ∈ T i) ∧ S = ⋂ i ∈ F, U i } := by\n  let _ := ⨅ i, t i\n  refine isTopologicalBasis_of_isOpen_of_nhds ?_ ?_\n  · rintro - ⟨U, F, hU, rfl⟩\n    refine isOpen_biInter_finset fun i hi ↦\n      (h_basis i).isOpen (t := t i) (hU i hi) |>.mono (iInf_le _ _)\n  · intro a u ha hu\n    rcases (nhds_iInf (t := t) (a := a)).symm ▸ hasBasis_iInf'\n      (fun i ↦ (h_basis i).nhds_hasBasis (t := t i)) |>.mem_iff.1 (hu.mem_nhds ha)\n      with ⟨⟨F, U⟩, ⟨hF, hU⟩, hUu⟩\n    refine ⟨_, ⟨U, hF.toFinset, ?_, rfl⟩, ?_, ?_⟩ <;> simp only [Finite.mem_toFinset, mem_iInter]\n    · exact fun i hi ↦ (hU i hi).1\n    · exact fun i hi ↦ (hU i hi).2\n    · exact hUu\n\n"}
{"name":"IsTopologicalBasis.iInf_induced","module":"Mathlib.Topology.Bases","initialProofState":"β : Type u_1\nι : Type u_2\nX : ι → Type u_3\nt : (i : ι) → TopologicalSpace (X i)\nT : (i : ι) → Set (Set (X i))\ncond : ∀ (i : ι), TopologicalSpace.IsTopologicalBasis (T i)\nf : (i : ι) → β → X i\n⊢ TopologicalSpace.IsTopologicalBasis (setOf fun S => Exists fun U => Exists fun F => And (∀ (i : ι), Membership.mem F i → Membership.mem (T i) (U i)) (Eq S (Set.iInter fun i => Set.iInter fun x => Set.preimage (f i) (U i))))","decl":"theorem IsTopologicalBasis.iInf_induced {β : Type*} {ι : Type*} {X : ι → Type*}\n    [t : Π i, TopologicalSpace (X i)] {T : Π i, Set (Set (X i))}\n    (cond : ∀ i, IsTopologicalBasis (T i)) (f : Π i, β → X i) :\n    IsTopologicalBasis (t := ⨅ i, induced (f i) (t i))\n      { S | ∃ (U : ∀ i, Set (X i)) (F : Finset ι),\n        (∀ i, i ∈ F → U i ∈ T i) ∧ S = ⋂ (i) (_ : i ∈ F), f i ⁻¹' U i } := by\n  convert IsTopologicalBasis.iInf (fun i ↦ (cond i).induced (f i)) with S\n  constructor <;> rintro ⟨U, F, hUT, hSU⟩\n  · exact ⟨fun i ↦ (f i) ⁻¹' (U i), F, fun i hi ↦ mem_image_of_mem _ (hUT i hi), hSU⟩\n  · choose! U' hU' hUU' using hUT\n    exact ⟨U', F, hU', hSU ▸ (.symm <| iInter₂_congr hUU')⟩\n\n"}
{"name":"isTopologicalBasis_pi","module":"Mathlib.Topology.Bases","initialProofState":"ι : Type u_1\nX : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (X i)\nT : (i : ι) → Set (Set (X i))\ncond : ∀ (i : ι), TopologicalSpace.IsTopologicalBasis (T i)\n⊢ TopologicalSpace.IsTopologicalBasis (setOf fun S => Exists fun U => Exists fun F => And (∀ (i : ι), Membership.mem F i → Membership.mem (T i) (U i)) (Eq S ((↑F).pi U)))","decl":"theorem isTopologicalBasis_pi {ι : Type*} {X : ι → Type*} [∀ i, TopologicalSpace (X i)]\n    {T : ∀ i, Set (Set (X i))} (cond : ∀ i, IsTopologicalBasis (T i)) :\n    IsTopologicalBasis { S | ∃ (U : ∀ i, Set (X i)) (F : Finset ι),\n      (∀ i, i ∈ F → U i ∈ T i) ∧ S = (F : Set ι).pi U } := by\n  simpa only [Set.pi_def] using IsTopologicalBasis.iInf_induced cond eval\n\n"}
{"name":"isTopologicalBasis_singletons","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : DiscreteTopology α\n⊢ TopologicalSpace.IsTopologicalBasis (setOf fun s => Exists fun x => Eq s (Singleton.singleton x))","decl":"theorem isTopologicalBasis_singletons (α : Type*) [TopologicalSpace α] [DiscreteTopology α] :\n    IsTopologicalBasis { s | ∃ x : α, (s : Set α) = {x} } :=\n  isTopologicalBasis_of_isOpen_of_nhds (fun _ _ => isOpen_discrete _) fun x _ hx _ =>\n    ⟨{x}, ⟨x, rfl⟩, mem_singleton x, singleton_subset_iff.2 hx⟩\n\n"}
{"name":"isTopologicalBasis_subtype","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nB : Set (Set α)\nh : TopologicalSpace.IsTopologicalBasis B\np : α → Prop\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.preimage Subtype.val) B)","decl":"theorem isTopologicalBasis_subtype\n    {α : Type*} [TopologicalSpace α] {B : Set (Set α)}\n    (h : TopologicalSpace.IsTopologicalBasis B) (p : α → Prop) :\n    IsTopologicalBasis (Set.preimage (Subtype.val (p := p)) '' B) :=\n  h.isInducing ⟨rfl⟩\n\n"}
{"name":"isOpenMap_eval","module":"Mathlib.Topology.Bases","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (π i)\ni : ι\n⊢ IsOpenMap (Function.eval i)","decl":"lemma isOpenMap_eval (i : ι) : IsOpenMap (Function.eval i : (∀ i, π i) → π i) := by\n  classical\n  refine (isTopologicalBasis_pi fun _ ↦ isTopologicalBasis_opens).isOpenMap_iff.2 ?_\n  rintro _ ⟨U, s, hU, rfl⟩\n  obtain h | h := ((s : Set ι).pi U).eq_empty_or_nonempty\n  · simp [h]\n  by_cases hi : i ∈ s\n  · rw [eval_image_pi (mod_cast hi) h]\n    exact hU _ hi\n  · rw [eval_image_pi_of_not_mem (mod_cast hi), if_pos h]\n    exact isOpen_univ\n\n"}
{"name":"Dense.exists_countable_dense_subset","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nhs : Dense s\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (Dense t))","decl":"theorem Dense.exists_countable_dense_subset {α : Type*} [TopologicalSpace α] {s : Set α}\n    [SeparableSpace s] (hs : Dense s) : ∃ t ⊆ s, t.Countable ∧ Dense t :=\n  let ⟨t, htc, htd⟩ := exists_countable_dense s\n  ⟨(↑) '' t, Subtype.coe_image_subset s t, htc.image Subtype.val,\n    hs.denseRange_val.dense_image continuous_subtype_val htd⟩\n\n"}
{"name":"Dense.exists_countable_dense_subset_bot_top","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : PartialOrder α\ns : Set α\ninst✝ : TopologicalSpace.SeparableSpace ↑s\nhs : Dense s\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (And (Dense t) (And (∀ (x : α), IsBot x → Membership.mem s x → Membership.mem t x) (∀ (x : α), IsTop x → Membership.mem s x → Membership.mem t x))))","decl":"/-- Let `s` be a dense set in a topological space `α` with partial order structure. If `s` is a\nseparable space (e.g., if `α` has a second countable topology), then there exists a countable\ndense subset `t ⊆ s` such that `t` contains bottom/top element of `α` when they exist and belong\nto `s`. For a dense subset containing neither bot nor top elements, see\n`Dense.exists_countable_dense_subset_no_bot_top`. -/\ntheorem Dense.exists_countable_dense_subset_bot_top {α : Type*} [TopologicalSpace α]\n    [PartialOrder α] {s : Set α} [SeparableSpace s] (hs : Dense s) :\n    ∃ t ⊆ s, t.Countable ∧ Dense t ∧ (∀ x, IsBot x → x ∈ s → x ∈ t) ∧\n      ∀ x, IsTop x → x ∈ s → x ∈ t := by\n  rcases hs.exists_countable_dense_subset with ⟨t, hts, htc, htd⟩\n  refine ⟨(t ∪ ({ x | IsBot x } ∪ { x | IsTop x })) ∩ s, ?_, ?_, ?_, ?_, ?_⟩\n  exacts [inter_subset_right,\n    (htc.union ((countable_isBot α).union (countable_isTop α))).mono inter_subset_left,\n    htd.mono (subset_inter subset_union_left hts), fun x hx hxs => ⟨Or.inr <| Or.inl hx, hxs⟩,\n    fun x hx hxs => ⟨Or.inr <| Or.inr hx, hxs⟩]\n\n"}
{"name":"separableSpace_univ","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.SeparableSpace α\n⊢ TopologicalSpace.SeparableSpace ↑Set.univ","decl":"instance separableSpace_univ {α : Type*} [TopologicalSpace α] [SeparableSpace α] :\n    SeparableSpace (univ : Set α) :=\n  (Equiv.Set.univ α).symm.surjective.denseRange.separableSpace (continuous_id.subtype_mk _)\n\n"}
{"name":"exists_countable_dense_bot_top","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace.SeparableSpace α\ninst✝ : PartialOrder α\n⊢ Exists fun s => And s.Countable (And (Dense s) (And (∀ (x : α), IsBot x → Membership.mem s x) (∀ (x : α), IsTop x → Membership.mem s x)))","decl":"/-- If `α` is a separable topological space with a partial order, then there exists a countable\ndense set `s : Set α` that contains those of both bottom and top elements of `α` that actually\nexist. For a dense set containing neither bot nor top elements, see\n`exists_countable_dense_no_bot_top`. -/\ntheorem exists_countable_dense_bot_top (α : Type*) [TopologicalSpace α] [SeparableSpace α]\n    [PartialOrder α] :\n    ∃ s : Set α, s.Countable ∧ Dense s ∧ (∀ x, IsBot x → x ∈ s) ∧ ∀ x, IsTop x → x ∈ s := by\n  simpa using dense_univ.exists_countable_dense_subset_bot_top\n\n"}
{"name":"FirstCountableTopology.nhds_generated_countable","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nself : FirstCountableTopology α\na : α\n⊢ (nhds a).IsCountablyGenerated","decl":"/-- A first-countable space is one in which every point has a\n  countable neighborhood basis. -/\nclass _root_.FirstCountableTopology : Prop where\n  /-- The filter `𝓝 a` is countably generated for all points `a`. -/\n  nhds_generated_countable : ∀ a : α, (𝓝 a).IsCountablyGenerated\n\n"}
{"name":"TopologicalSpace.firstCountableTopology_induced","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nt : TopologicalSpace β\ninst✝ : FirstCountableTopology β\nf : α → β\n⊢ FirstCountableTopology α","decl":"/-- If `β` is a first-countable space, then its induced topology via `f` on `α` is also\nfirst-countable. -/\ntheorem firstCountableTopology_induced (α β : Type*) [t : TopologicalSpace β]\n    [FirstCountableTopology β] (f : α → β) : @FirstCountableTopology α (t.induced f) :=\n  let _ := t.induced f\n  ⟨fun x ↦ nhds_induced f x ▸ inferInstance⟩\n\n"}
{"name":"TopologicalSpace.Subtype.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\ninst✝ : FirstCountableTopology α\n⊢ FirstCountableTopology ↑s","decl":"instance Subtype.firstCountableTopology (s : Set α) [FirstCountableTopology α] :\n    FirstCountableTopology s :=\n  firstCountableTopology_induced s α (↑)\n\n"}
{"name":"Topology.IsInducing.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_1\ninst✝¹ : TopologicalSpace β\ninst✝ : FirstCountableTopology β\nf : α → β\nhf : Topology.IsInducing f\n⊢ FirstCountableTopology α","decl":"protected theorem _root_.Topology.IsInducing.firstCountableTopology {β : Type*}\n    [TopologicalSpace β] [FirstCountableTopology β] {f : α → β} (hf : IsInducing f) :\n    FirstCountableTopology α := by\n  rw [hf.1]\n  exact firstCountableTopology_induced α β f\n\n"}
{"name":"Inducing.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_1\ninst✝¹ : TopologicalSpace β\ninst✝ : FirstCountableTopology β\nf : α → β\nhf : Topology.IsInducing f\n⊢ FirstCountableTopology α","decl":"@[deprecated (since := \"2024-10-28\")]\nalias _root_.Inducing.firstCountableTopology := IsInducing.firstCountableTopology\n\n"}
{"name":"Topology.IsEmbedding.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_1\ninst✝¹ : TopologicalSpace β\ninst✝ : FirstCountableTopology β\nf : α → β\nhf : Topology.IsEmbedding f\n⊢ FirstCountableTopology α","decl":"protected theorem _root_.Topology.IsEmbedding.firstCountableTopology {β : Type*}\n    [TopologicalSpace β] [FirstCountableTopology β] {f : α → β} (hf : IsEmbedding f) :\n    FirstCountableTopology α :=\n  hf.1.firstCountableTopology\n\n"}
{"name":"Embedding.firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_1\ninst✝¹ : TopologicalSpace β\ninst✝ : FirstCountableTopology β\nf : α → β\nhf : Topology.IsEmbedding f\n⊢ FirstCountableTopology α","decl":"@[deprecated (since := \"2024-10-26\")]\nalias _root_.Embedding.firstCountableTopology := IsEmbedding.firstCountableTopology\n\n"}
{"name":"TopologicalSpace.FirstCountableTopology.tendsto_subseq","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : FirstCountableTopology α\nu : Nat → α\nx : α\nhx : MapClusterPt x Filter.atTop u\n⊢ Exists fun ψ => And (StrictMono ψ) (Filter.Tendsto (Function.comp u ψ) Filter.atTop (nhds x))","decl":"/-- In a first-countable space, a cluster point `x` of a sequence\nis the limit of some subsequence. -/\ntheorem tendsto_subseq [FirstCountableTopology α] {u : ℕ → α} {x : α}\n    (hx : MapClusterPt x atTop u) : ∃ ψ : ℕ → ℕ, StrictMono ψ ∧ Tendsto (u ∘ ψ) atTop (𝓝 x) :=\n  subseq_tendsto_of_neBot hx\n\n"}
{"name":"TopologicalSpace.instFirstCountableTopologyProd","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_1\ninst✝² : TopologicalSpace β\ninst✝¹ : FirstCountableTopology α\ninst✝ : FirstCountableTopology β\n⊢ FirstCountableTopology (Prod α β)","decl":"instance {β} [TopologicalSpace β] [FirstCountableTopology α] [FirstCountableTopology β] :\n    FirstCountableTopology (α × β) :=\n  ⟨fun ⟨x, y⟩ => by rw [nhds_prod_eq]; infer_instance⟩\n\n"}
{"name":"TopologicalSpace.instFirstCountableTopologyForallOfCountable","module":"Mathlib.Topology.Bases","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝² : Countable ι\ninst✝¹ : (i : ι) → TopologicalSpace (π i)\ninst✝ : ∀ (i : ι), FirstCountableTopology (π i)\n⊢ FirstCountableTopology ((i : ι) → π i)","decl":"instance {ι : Type*} {π : ι → Type*} [Countable ι] [∀ i, TopologicalSpace (π i)]\n    [∀ i, FirstCountableTopology (π i)] : FirstCountableTopology (∀ i, π i) :=\n  ⟨fun f => by rw [nhds_pi]; infer_instance⟩\n\n"}
{"name":"TopologicalSpace.isCountablyGenerated_nhdsWithin","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nx : α\ninst✝ : (nhds x).IsCountablyGenerated\ns : Set α\n⊢ (nhdsWithin x s).IsCountablyGenerated","decl":"instance isCountablyGenerated_nhdsWithin (x : α) [IsCountablyGenerated (𝓝 x)] (s : Set α) :\n    IsCountablyGenerated (𝓝[s] x) :=\n  Inf.isCountablyGenerated _ _\n\n"}
{"name":"SecondCountableTopology.is_open_generated_countable","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nself : SecondCountableTopology α\n⊢ Exists fun b => And b.Countable (Eq t (TopologicalSpace.generateFrom b))","decl":"/-- A second-countable space is one with a countable basis. -/\nclass _root_.SecondCountableTopology : Prop where\n  /-- There exists a countable set of sets that generates the topology. -/\n  is_open_generated_countable : ∃ b : Set (Set α), b.Countable ∧ t = TopologicalSpace.generateFrom b\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nb : Set (Set α)\nhb : TopologicalSpace.IsTopologicalBasis b\nhc : b.Countable\n⊢ SecondCountableTopology α","decl":"protected theorem IsTopologicalBasis.secondCountableTopology {b : Set (Set α)}\n    (hb : IsTopologicalBasis b) (hc : b.Countable) : SecondCountableTopology α :=\n  ⟨⟨b, hc, hb.eq_generateFrom⟩⟩\n\n"}
{"name":"TopologicalSpace.SecondCountableTopology.mk'","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\nb : Set (Set α)\nhc : b.Countable\n⊢ SecondCountableTopology α","decl":"lemma SecondCountableTopology.mk' {α} {b : Set (Set α)} (hc : b.Countable) :\n    @SecondCountableTopology α (generateFrom b) :=\n  @SecondCountableTopology.mk α (generateFrom b) ⟨b, hc, rfl⟩\n\n"}
{"name":"Finite.toSecondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : Finite α\n⊢ SecondCountableTopology α","decl":"instance _root_.Finite.toSecondCountableTopology [Finite α] : SecondCountableTopology α where\n  is_open_generated_countable :=\n    ⟨_, {U | IsOpen U}.to_countable, TopologicalSpace.isTopologicalBasis_opens.eq_generateFrom⟩\n\n"}
{"name":"TopologicalSpace.exists_countable_basis","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\n⊢ Exists fun b => And b.Countable (And (Not (Membership.mem b EmptyCollection.emptyCollection)) (TopologicalSpace.IsTopologicalBasis b))","decl":"theorem exists_countable_basis [SecondCountableTopology α] :\n    ∃ b : Set (Set α), b.Countable ∧ ∅ ∉ b ∧ IsTopologicalBasis b := by\n  obtain ⟨b, hb₁, hb₂⟩ := @SecondCountableTopology.is_open_generated_countable α _ _\n  refine ⟨_, ?_, not_mem_diff_of_mem ?_, (isTopologicalBasis_of_subbasis hb₂).diff_empty⟩\n  exacts [((countable_setOf_finite_subset hb₁).image _).mono diff_subset, rfl]\n\n"}
{"name":"TopologicalSpace.countable_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\n⊢ (TopologicalSpace.countableBasis α).Countable","decl":"theorem countable_countableBasis [SecondCountableTopology α] : (countableBasis α).Countable :=\n  (exists_countable_basis α).choose_spec.1\n\n"}
{"name":"TopologicalSpace.empty_nmem_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\n⊢ Not (Membership.mem (TopologicalSpace.countableBasis α) EmptyCollection.emptyCollection)","decl":"theorem empty_nmem_countableBasis [SecondCountableTopology α] : ∅ ∉ countableBasis α :=\n  (exists_countable_basis α).choose_spec.2.1\n\n"}
{"name":"TopologicalSpace.isBasis_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\n⊢ TopologicalSpace.IsTopologicalBasis (TopologicalSpace.countableBasis α)","decl":"theorem isBasis_countableBasis [SecondCountableTopology α] :\n    IsTopologicalBasis (countableBasis α) :=\n  (exists_countable_basis α).choose_spec.2.2\n\n"}
{"name":"TopologicalSpace.eq_generateFrom_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\n⊢ Eq t (TopologicalSpace.generateFrom (TopologicalSpace.countableBasis α))","decl":"theorem eq_generateFrom_countableBasis [SecondCountableTopology α] :\n    ‹TopologicalSpace α› = generateFrom (countableBasis α) :=\n  (isBasis_countableBasis α).eq_generateFrom\n\n"}
{"name":"TopologicalSpace.isOpen_of_mem_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\ns : Set α\nhs : Membership.mem (TopologicalSpace.countableBasis α) s\n⊢ IsOpen s","decl":"theorem isOpen_of_mem_countableBasis [SecondCountableTopology α] {s : Set α}\n    (hs : s ∈ countableBasis α) : IsOpen s :=\n  (isBasis_countableBasis α).isOpen hs\n\n"}
{"name":"TopologicalSpace.nonempty_of_mem_countableBasis","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\ns : Set α\nhs : Membership.mem (TopologicalSpace.countableBasis α) s\n⊢ s.Nonempty","decl":"theorem nonempty_of_mem_countableBasis [SecondCountableTopology α] {s : Set α}\n    (hs : s ∈ countableBasis α) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 <| ne_of_mem_of_not_mem hs <| empty_nmem_countableBasis α\n\n"}
{"name":"TopologicalSpace.SecondCountableTopology.to_firstCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\n⊢ FirstCountableTopology α","decl":"instance (priority := 100) SecondCountableTopology.to_firstCountableTopology\n    [SecondCountableTopology α] : FirstCountableTopology α :=\n  ⟨fun _ => HasCountableBasis.isCountablyGenerated <|\n      ⟨(isBasis_countableBasis α).nhds_hasBasis,\n        (countable_countableBasis α).mono inter_subset_left⟩⟩\n\n"}
{"name":"TopologicalSpace.secondCountableTopology_induced","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\nt : TopologicalSpace β\ninst✝ : SecondCountableTopology β\nf : α → β\n⊢ SecondCountableTopology α","decl":"/-- If `β` is a second-countable space, then its induced topology via\n`f` on `α` is also second-countable. -/\ntheorem secondCountableTopology_induced (α β) [t : TopologicalSpace β] [SecondCountableTopology β]\n    (f : α → β) : @SecondCountableTopology α (t.induced f) := by\n  rcases @SecondCountableTopology.is_open_generated_countable β _ _ with ⟨b, hb, eq⟩\n  letI := t.induced f\n  refine { is_open_generated_countable := ⟨preimage f '' b, hb.image _, ?_⟩ }\n  rw [eq, induced_generateFrom_eq]\n\n"}
{"name":"TopologicalSpace.Subtype.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ns : Set α\ninst✝ : SecondCountableTopology α\n⊢ SecondCountableTopology ↑s","decl":"instance Subtype.secondCountableTopology (s : Set α) [SecondCountableTopology α] :\n    SecondCountableTopology s :=\n  secondCountableTopology_induced s α (↑)\n\n"}
{"name":"TopologicalSpace.secondCountableTopology_iInf","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝ : Countable ι\nt : ι → TopologicalSpace α\nht : ∀ (i : ι), SecondCountableTopology α\n⊢ SecondCountableTopology α","decl":"lemma secondCountableTopology_iInf {α ι} [Countable ι] {t : ι → TopologicalSpace α}\n    (ht : ∀ i, @SecondCountableTopology α (t i)) : @SecondCountableTopology α (⨅ i, t i) := by\n  rw [funext fun i => @eq_generateFrom_countableBasis α (t i) (ht i), ← generateFrom_iUnion]\n  exact SecondCountableTopology.mk' <|\n    countable_iUnion fun i => @countable_countableBasis _ (t i) (ht i)\n\n-- TODO: more fine grained instances for `FirstCountableTopology`, `SeparableSpace`, `T2Space`, ...\n"}
{"name":"TopologicalSpace.instSecondCountableTopologyProd","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_1\ninst✝² : TopologicalSpace β\ninst✝¹ : SecondCountableTopology α\ninst✝ : SecondCountableTopology β\n⊢ SecondCountableTopology (Prod α β)","decl":"instance {β : Type*} [TopologicalSpace β] [SecondCountableTopology α] [SecondCountableTopology β] :\n    SecondCountableTopology (α × β) :=\n  ((isBasis_countableBasis α).prod (isBasis_countableBasis β)).secondCountableTopology <|\n    (countable_countableBasis α).image2 (countable_countableBasis β) _\n\n"}
{"name":"TopologicalSpace.instSecondCountableTopologyForallOfCountable","module":"Mathlib.Topology.Bases","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝² : Countable ι\ninst✝¹ : (a : ι) → TopologicalSpace (π a)\ninst✝ : ∀ (a : ι), SecondCountableTopology (π a)\n⊢ SecondCountableTopology ((a : ι) → π a)","decl":"instance {ι : Type*} {π : ι → Type*} [Countable ι] [∀ a, TopologicalSpace (π a)]\n    [∀ a, SecondCountableTopology (π a)] : SecondCountableTopology (∀ a, π a) :=\n  secondCountableTopology_iInf fun _ => secondCountableTopology_induced _ _ _\n\n-- see Note [lower instance priority]\n"}
{"name":"TopologicalSpace.SecondCountableTopology.to_separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\n⊢ TopologicalSpace.SeparableSpace α","decl":"instance (priority := 100) SecondCountableTopology.to_separableSpace [SecondCountableTopology α] :\n    SeparableSpace α := by\n  choose p hp using fun s : countableBasis α => nonempty_of_mem_countableBasis s.2\n  exact ⟨⟨range p, countable_range _, (isBasis_countableBasis α).dense_iff.2 fun o ho _ =>\n          ⟨p ⟨o, ho⟩, hp ⟨o, _⟩, mem_range_self _⟩⟩⟩\n\n"}
{"name":"TopologicalSpace.secondCountableTopology_of_countable_cover","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nι : Sort u_1\ninst✝¹ : Countable ι\nU : ι → Set α\ninst✝ : ∀ (i : ι), SecondCountableTopology ↑(U i)\nUo : ∀ (i : ι), IsOpen (U i)\nhc : Eq (Set.iUnion fun i => U i) Set.univ\n⊢ SecondCountableTopology α","decl":"/-- A countable open cover induces a second-countable topology if all open covers\nare themselves second countable. -/\ntheorem secondCountableTopology_of_countable_cover {ι} [Countable ι] {U : ι → Set α}\n    [∀ i, SecondCountableTopology (U i)] (Uo : ∀ i, IsOpen (U i)) (hc : ⋃ i, U i = univ) :\n    SecondCountableTopology α :=\n  haveI : IsTopologicalBasis (⋃ i, image ((↑) : U i → α) '' countableBasis (U i)) :=\n    isTopologicalBasis_of_cover Uo hc fun i => isBasis_countableBasis (U i)\n  this.secondCountableTopology (countable_iUnion fun _ => (countable_countableBasis _).image _)\n\n"}
{"name":"TopologicalSpace.isOpen_iUnion_countable","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\nι : Type u_1\ns : ι → Set α\nH : ∀ (i : ι), IsOpen (s i)\n⊢ Exists fun T => And T.Countable (Eq (Set.iUnion fun i => Set.iUnion fun h => s i) (Set.iUnion fun i => s i))","decl":"/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets.\nIn particular, any open covering of `α` has a countable subcover: α is a Lindelöf space. -/\ntheorem isOpen_iUnion_countable [SecondCountableTopology α] {ι} (s : ι → Set α)\n    (H : ∀ i, IsOpen (s i)) : ∃ T : Set ι, T.Countable ∧ ⋃ i ∈ T, s i = ⋃ i, s i := by\n  let B := { b ∈ countableBasis α | ∃ i, b ⊆ s i }\n  choose f hf using fun b : B => b.2.2\n  haveI : Countable B := ((countable_countableBasis α).mono (sep_subset _ _)).to_subtype\n  refine ⟨_, countable_range f, (iUnion₂_subset_iUnion _ _).antisymm (sUnion_subset ?_)⟩\n  rintro _ ⟨i, rfl⟩ x xs\n  rcases (isBasis_countableBasis α).exists_subset_of_mem_open xs (H _) with ⟨b, hb, xb, bs⟩\n  exact ⟨_, ⟨_, rfl⟩, _, ⟨⟨⟨_, hb, _, bs⟩, rfl⟩, rfl⟩, hf _ xb⟩\n\n"}
{"name":"TopologicalSpace.isOpen_biUnion_countable","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\nι : Type u_1\nI : Set ι\ns : ι → Set α\nH : ∀ (i : ι), Membership.mem I i → IsOpen (s i)\n⊢ Exists fun T => And (HasSubset.Subset T I) (And T.Countable (Eq (Set.iUnion fun i => Set.iUnion fun h => s i) (Set.iUnion fun i => Set.iUnion fun h => s i)))","decl":"theorem isOpen_biUnion_countable [SecondCountableTopology α] {ι : Type*} (I : Set ι) (s : ι → Set α)\n    (H : ∀ i ∈ I, IsOpen (s i)) : ∃ T ⊆ I, T.Countable ∧ ⋃ i ∈ T, s i = ⋃ i ∈ I, s i := by\n  simp_rw [← Subtype.exists_set_subtype, biUnion_image]\n  rcases isOpen_iUnion_countable (fun i : I ↦ s i) fun i ↦ H i i.2 with ⟨T, hTc, hU⟩\n  exact ⟨T, hTc.image _, hU.trans <| iUnion_subtype ..⟩\n\n"}
{"name":"TopologicalSpace.isOpen_sUnion_countable","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\nS : Set (Set α)\nH : ∀ (s : Set α), Membership.mem S s → IsOpen s\n⊢ Exists fun T => And T.Countable (And (HasSubset.Subset T S) (Eq T.sUnion S.sUnion))","decl":"theorem isOpen_sUnion_countable [SecondCountableTopology α] (S : Set (Set α))\n    (H : ∀ s ∈ S, IsOpen s) : ∃ T : Set (Set α), T.Countable ∧ T ⊆ S ∧ ⋃₀ T = ⋃₀ S := by\n  simpa only [and_left_comm, sUnion_eq_biUnion] using isOpen_biUnion_countable S id H\n\n"}
{"name":"TopologicalSpace.countable_cover_nhds","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\nf : α → Set α\nhf : ∀ (x : α), Membership.mem (nhds x) (f x)\n⊢ Exists fun s => And s.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => f x) Set.univ)","decl":"/-- In a topological space with second countable topology, if `f` is a function that sends each\npoint `x` to a neighborhood of `x`, then for some countable set `s`, the neighborhoods `f x`,\n`x ∈ s`, cover the whole space. -/\ntheorem countable_cover_nhds [SecondCountableTopology α] {f : α → Set α} (hf : ∀ x, f x ∈ 𝓝 x) :\n    ∃ s : Set α, s.Countable ∧ ⋃ x ∈ s, f x = univ := by\n  rcases isOpen_iUnion_countable (fun x => interior (f x)) fun x => isOpen_interior with\n    ⟨s, hsc, hsU⟩\n  suffices ⋃ x ∈ s, interior (f x) = univ from\n    ⟨s, hsc, flip eq_univ_of_subset this <| iUnion₂_mono fun _ _ => interior_subset⟩\n  simp only [hsU, eq_univ_iff_forall, mem_iUnion]\n  exact fun x => ⟨x, mem_interior_iff_mem_nhds.2 (hf x)⟩\n\n"}
{"name":"TopologicalSpace.countable_cover_nhdsWithin","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\ninst✝ : SecondCountableTopology α\nf : α → Set α\ns : Set α\nhf : ∀ (x : α), Membership.mem s x → Membership.mem (nhdsWithin x s) (f x)\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => f x)))","decl":"theorem countable_cover_nhdsWithin [SecondCountableTopology α] {f : α → Set α} {s : Set α}\n    (hf : ∀ x ∈ s, f x ∈ 𝓝[s] x) : ∃ t ⊆ s, t.Countable ∧ s ⊆ ⋃ x ∈ t, f x := by\n  have : ∀ x : s, (↑) ⁻¹' f x ∈ 𝓝 x := fun x => preimage_coe_mem_nhds_subtype.2 (hf x x.2)\n  rcases countable_cover_nhds this with ⟨t, htc, htU⟩\n  refine ⟨(↑) '' t, Subtype.coe_image_subset _ _, htc.image _, fun x hx => ?_⟩\n  simp only [biUnion_image, eq_univ_iff_forall, ← preimage_iUnion, mem_preimage] at htU ⊢\n  exact htU ⟨x, hx⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.sigma","module":"Mathlib.Topology.Bases","initialProofState":"ι : Type u_1\nE : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (E i)\ns : (i : ι) → Set (Set (E i))\nhs : ∀ (i : ι), TopologicalSpace.IsTopologicalBasis (s i)\n⊢ TopologicalSpace.IsTopologicalBasis (Set.iUnion fun i => Set.image (fun u => Set.image (Sigma.mk i) u) (s i))","decl":"/-- In a disjoint union space `Σ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem IsTopologicalBasis.sigma {s : ∀ i : ι, Set (Set (E i))}\n    (hs : ∀ i, IsTopologicalBasis (s i)) :\n    IsTopologicalBasis (⋃ i : ι, (fun u => (Sigma.mk i '' u : Set (Σi, E i))) '' s i) := by\n  refine .of_hasBasis_nhds fun a ↦ ?_\n  rw [Sigma.nhds_eq]\n  convert (((hs a.1).nhds_hasBasis).map _).to_image_id\n  aesop\n\n"}
{"name":"TopologicalSpace.instSecondCountableTopologySigmaOfCountable","module":"Mathlib.Topology.Bases","initialProofState":"ι : Type u_1\nE : ι → Type u_2\ninst✝² : (i : ι) → TopologicalSpace (E i)\ninst✝¹ : Countable ι\ninst✝ : ∀ (i : ι), SecondCountableTopology (E i)\n⊢ SecondCountableTopology (Sigma fun i => E i)","decl":"/-- A countable disjoint union of second countable spaces is second countable. -/\ninstance [Countable ι] [∀ i, SecondCountableTopology (E i)] :\n    SecondCountableTopology (Σi, E i) := by\n  let b := ⋃ i : ι, (fun u => (Sigma.mk i '' u : Set (Σi, E i))) '' countableBasis (E i)\n  have A : IsTopologicalBasis b := IsTopologicalBasis.sigma fun i => isBasis_countableBasis _\n  have B : b.Countable := countable_iUnion fun i => (countable_countableBasis _).image _\n  exact A.secondCountableTopology B\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.sum","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt✝ : TopologicalSpace α\nβ : Type u_1\ninst✝ : TopologicalSpace β\ns : Set (Set α)\nhs : TopologicalSpace.IsTopologicalBasis s\nt : Set (Set β)\nht : TopologicalSpace.IsTopologicalBasis t\n⊢ TopologicalSpace.IsTopologicalBasis (Union.union (Set.image (fun u => Set.image Sum.inl u) s) (Set.image (fun u => Set.image Sum.inr u) t))","decl":"/-- In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem IsTopologicalBasis.sum {s : Set (Set α)} (hs : IsTopologicalBasis s) {t : Set (Set β)}\n    (ht : IsTopologicalBasis t) :\n    IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ∪ (fun u => Sum.inr '' u) '' t) := by\n  apply isTopologicalBasis_of_isOpen_of_nhds\n  · rintro u (⟨w, hw, rfl⟩ | ⟨w, hw, rfl⟩)\n    · exact IsOpenEmbedding.inl.isOpenMap w (hs.isOpen hw)\n    · exact IsOpenEmbedding.inr.isOpenMap w (ht.isOpen hw)\n  · rintro (x | x) u hxu u_open\n    · obtain ⟨v, vs, xv, vu⟩ : ∃ v ∈ s, x ∈ v ∧ v ⊆ Sum.inl ⁻¹' u :=\n        hs.exists_subset_of_mem_open hxu (isOpen_sum_iff.1 u_open).1\n      exact ⟨Sum.inl '' v, mem_union_left _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv,\n        image_subset_iff.2 vu⟩\n    · obtain ⟨v, vs, xv, vu⟩ : ∃ v ∈ t, x ∈ v ∧ v ⊆ Sum.inr ⁻¹' u :=\n        ht.exists_subset_of_mem_open hxu (isOpen_sum_iff.1 u_open).2\n      exact ⟨Sum.inr '' v, mem_union_right _ (mem_image_of_mem _ vs), mem_image_of_mem _ xv,\n        image_subset_iff.2 vu⟩\n\n"}
{"name":"TopologicalSpace.instSecondCountableTopologySum","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u\nt : TopologicalSpace α\nβ : Type u_1\ninst✝² : TopologicalSpace β\ninst✝¹ : SecondCountableTopology α\ninst✝ : SecondCountableTopology β\n⊢ SecondCountableTopology (Sum α β)","decl":"/-- A sum type of two second countable spaces is second countable. -/\ninstance [SecondCountableTopology α] [SecondCountableTopology β] :\n    SecondCountableTopology (α ⊕ β) := by\n  let b :=\n    (fun u => Sum.inl '' u) '' countableBasis α ∪ (fun u => Sum.inr '' u) '' countableBasis β\n  have A : IsTopologicalBasis b := (isBasis_countableBasis α).sum (isBasis_countableBasis β)\n  have B : b.Countable :=\n    (Countable.image (countable_countableBasis _) _).union\n      (Countable.image (countable_countableBasis _) _)\n  exact A.secondCountableTopology B\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.isQuotientMap","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nY : Type u_2\ninst✝ : TopologicalSpace Y\nπ : X → Y\nV : Set (Set X)\nhV : TopologicalSpace.IsTopologicalBasis V\nh' : Topology.IsQuotientMap π\nh : IsOpenMap π\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.image π) V)","decl":"/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem IsTopologicalBasis.isQuotientMap {V : Set (Set X)} (hV : IsTopologicalBasis V)\n    (h' : IsQuotientMap π) (h : IsOpenMap π) : IsTopologicalBasis (Set.image π '' V) := by\n  apply isTopologicalBasis_of_isOpen_of_nhds\n  · rintro - ⟨U, U_in_V, rfl⟩\n    apply h U (hV.isOpen U_in_V)\n  · intro y U y_in_U U_open\n    obtain ⟨x, rfl⟩ := h'.surjective y\n    let W := π ⁻¹' U\n    have x_in_W : x ∈ W := y_in_U\n    have W_open : IsOpen W := U_open.preimage h'.continuous\n    obtain ⟨Z, Z_in_V, x_in_Z, Z_in_W⟩ := hV.exists_subset_of_mem_open x_in_W W_open\n    have πZ_in_U : π '' Z ⊆ U := (Set.image_subset _ Z_in_W).trans (image_preimage_subset π U)\n    exact ⟨π '' Z, ⟨Z, Z_in_V, rfl⟩, ⟨x, x_in_Z, rfl⟩, πZ_in_U⟩\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.quotientMap","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nY : Type u_2\ninst✝ : TopologicalSpace Y\nπ : X → Y\nV : Set (Set X)\nhV : TopologicalSpace.IsTopologicalBasis V\nh' : Topology.IsQuotientMap π\nh : IsOpenMap π\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.image π) V)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias IsTopologicalBasis.quotientMap := IsTopologicalBasis.isQuotientMap\n\n"}
{"name":"Topology.IsQuotientMap.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\nY : Type u_2\ninst✝¹ : TopologicalSpace Y\nπ : X → Y\ninst✝ : SecondCountableTopology X\nh' : Topology.IsQuotientMap π\nh : IsOpenMap π\n⊢ SecondCountableTopology Y","decl":"/-- A second countable space is mapped by an open quotient map to a second countable space. -/\ntheorem _root_.Topology.IsQuotientMap.secondCountableTopology [SecondCountableTopology X]\n    (h' : IsQuotientMap π) (h : IsOpenMap π) : SecondCountableTopology Y where\n  is_open_generated_countable := by\n    obtain ⟨V, V_countable, -, V_generates⟩ := exists_countable_basis X\n    exact ⟨Set.image π '' V, V_countable.image (Set.image π),\n      (V_generates.isQuotientMap h' h).eq_generateFrom⟩\n\n"}
{"name":"QuotientMap.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\nY : Type u_2\ninst✝¹ : TopologicalSpace Y\nπ : X → Y\ninst✝ : SecondCountableTopology X\nh' : Topology.IsQuotientMap π\nh : IsOpenMap π\n⊢ SecondCountableTopology Y","decl":"@[deprecated (since := \"2024-10-22\")]\nalias _root_.QuotientMap.secondCountableTopology := IsQuotientMap.secondCountableTopology\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.quotient","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Setoid X\nV : Set (Set X)\nhV : TopologicalSpace.IsTopologicalBasis V\nh : IsOpenMap Quotient.mk'\n⊢ TopologicalSpace.IsTopologicalBasis (Set.image (Set.image Quotient.mk') V)","decl":"/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem IsTopologicalBasis.quotient {V : Set (Set X)} (hV : IsTopologicalBasis V)\n    (h : IsOpenMap (Quotient.mk' : X → Quotient S)) :\n    IsTopologicalBasis (Set.image (Quotient.mk' : X → Quotient S) '' V) :=\n  hV.isQuotientMap isQuotientMap_quotient_mk' h\n\n"}
{"name":"TopologicalSpace.Quotient.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nS : Setoid X\ninst✝ : SecondCountableTopology X\nh : IsOpenMap Quotient.mk'\n⊢ SecondCountableTopology (Quotient S)","decl":"/-- An open quotient of a second countable space is second countable. -/\ntheorem Quotient.secondCountableTopology [SecondCountableTopology X]\n    (h : IsOpenMap (Quotient.mk' : X → Quotient S)) : SecondCountableTopology (Quotient S) :=\n  isQuotientMap_quotient_mk'.secondCountableTopology h\n\n"}
{"name":"Topology.IsInducing.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\nf : α → β\ninst✝¹ : TopologicalSpace β\ninst✝ : SecondCountableTopology β\nhf : Topology.IsInducing f\n⊢ SecondCountableTopology α","decl":"protected theorem Topology.IsInducing.secondCountableTopology [TopologicalSpace β]\n    [SecondCountableTopology β] (hf : IsInducing f) : SecondCountableTopology α := by\n  rw [hf.1]\n  exact secondCountableTopology_induced α β f\n\n"}
{"name":"Inducing.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\nf : α → β\ninst✝¹ : TopologicalSpace β\ninst✝ : SecondCountableTopology β\nhf : Topology.IsInducing f\n⊢ SecondCountableTopology α","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.secondCountableTopology := IsInducing.secondCountableTopology\n\n"}
{"name":"Topology.IsEmbedding.secondCountableTopology","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\nf : α → β\ninst✝¹ : TopologicalSpace β\ninst✝ : SecondCountableTopology β\nhf : Topology.IsEmbedding f\n⊢ SecondCountableTopology α","decl":"protected theorem Topology.IsEmbedding.secondCountableTopology\n    [TopologicalSpace β] [SecondCountableTopology β]\n    (hf : IsEmbedding f) : SecondCountableTopology α :=\n  hf.1.secondCountableTopology\n\n"}
{"name":"Topology.IsEmbedding.separableSpace","module":"Mathlib.Topology.Bases","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : SecondCountableTopology β\nf : α → β\nhf : Topology.IsEmbedding f\n⊢ TopologicalSpace.SeparableSpace α","decl":"protected theorem Topology.IsEmbedding.separableSpace\n    [TopologicalSpace β] [SecondCountableTopology β] {f : α → β} (hf : IsEmbedding f) :\n    TopologicalSpace.SeparableSpace α := by\n  have := hf.secondCountableTopology\n  exact SecondCountableTopology.to_separableSpace\n"}
