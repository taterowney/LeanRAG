{"name":"LieSubalgebra.engel_carrier","module":"Mathlib.Algebra.Lie.EngelSubalgebra","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx : L\n⊢ Eq (↑(LieSubalgebra.engel R x)) (Set.iInter fun s => Set.iInter fun x => ↑s)","decl":"/-- The Engel subalgebra `Engel R x` consists of\nall `y : L` such that `(ad R L x)^n` kills `y` for some `n`.\n\nEngel subalgebras are self-normalizing (`LieSubalgebra.normalizer_engel`),\nand minimal ones are nilpotent, hence Cartan subalgebras. -/\n@[simps!]\ndef engel (x : L) : LieSubalgebra R L :=\n  { (ad R L x).maxGenEigenspace 0 with\n    lie_mem' := by\n      simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n        Submodule.mem_toAddSubmonoid, Module.End.mem_maxGenEigenspace, zero_smul,\n        sub_zero, forall_exists_index]\n      intro y z m hm n hn\n      refine ⟨m + n, ?_⟩\n      rw [ad_pow_lie]\n      apply Finset.sum_eq_zero\n      intro ij hij\n      obtain (h|h) : m ≤ ij.1 ∨ n ≤ ij.2 := by rw [Finset.mem_antidiagonal] at hij; omega\n      all_goals simp [LinearMap.pow_map_zero_of_le h, hm, hn] }\n\n"}
{"name":"LieSubalgebra.mem_engel_iff","module":"Mathlib.Algebra.Lie.EngelSubalgebra","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx y : L\n⊢ Iff (Membership.mem (LieSubalgebra.engel R x) y) (Exists fun n => Eq ((HPow.hPow ((LieAlgebra.ad R L) x) n) y) 0)","decl":"lemma mem_engel_iff (x y : L) :\n    y ∈ engel R x ↔ ∃ n : ℕ, ((ad R L x) ^ n) y = 0 :=\n  (Module.End.mem_maxGenEigenspace _ _ _).trans <| by simp only [zero_smul, sub_zero]\n\n"}
{"name":"LieSubalgebra.self_mem_engel","module":"Mathlib.Algebra.Lie.EngelSubalgebra","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx : L\n⊢ Membership.mem (LieSubalgebra.engel R x) x","decl":"lemma self_mem_engel (x : L) : x ∈ engel R x := by\n  simp only [mem_engel_iff]\n  exact ⟨1, by simp⟩\n\n"}
{"name":"LieSubalgebra.engel_zero","module":"Mathlib.Algebra.Lie.EngelSubalgebra","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (LieSubalgebra.engel R 0) Top.top","decl":"@[simp]\nlemma engel_zero : engel R (0 : L) = ⊤ := by\n  rw [eq_top_iff]\n  rintro x -\n  rw [mem_engel_iff, LieHom.map_zero]\n  use 1\n  simp only [pow_one, LinearMap.zero_apply]\n\n"}
{"name":"LieSubalgebra.normalizer_engel","module":"Mathlib.Algebra.Lie.EngelSubalgebra","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx : L\n⊢ Eq (LieSubalgebra.engel R x).normalizer (LieSubalgebra.engel R x)","decl":"/-- Engel subalgebras are self-normalizing.\nSee `LieSubalgebra.normalizer_eq_self_of_engel_le` for a proof that Lie-subalgebras\ncontaining an Engel subalgebra are also self-normalizing,\nprovided that the ambient Lie algebra is artinina. -/\n@[simp]\nlemma normalizer_engel (x : L) : normalizer (engel R x) = engel R x := by\n  apply le_antisymm _ (le_normalizer _)\n  intro y hy\n  rw [mem_normalizer_iff] at hy\n  specialize hy x (self_mem_engel R x)\n  rw [← lie_skew, neg_mem_iff (G := L), mem_engel_iff] at hy\n  rcases hy with ⟨n, hn⟩\n  rw [mem_engel_iff]\n  use n+1\n  rw [pow_succ, LinearMap.mul_apply]\n  exact hn\n\n"}
{"name":"LieSubalgebra.normalizer_eq_self_of_engel_le","module":"Mathlib.Algebra.Lie.EngelSubalgebra","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsArtinian R L\nH : LieSubalgebra R L\nx : L\nh : LE.le (LieSubalgebra.engel R x) H\n⊢ Eq H.normalizer H","decl":"open Filter in\n/-- A Lie-subalgebra of an Artinian Lie algebra is self-normalizing\nif it contains an Engel subalgebra.\nSee `LieSubalgebra.normalizer_engel` for a proof that Engel subalgebras are self-normalizing,\navoiding the Artinian condition. -/\nlemma normalizer_eq_self_of_engel_le [IsArtinian R L]\n    (H : LieSubalgebra R L) (x : L) (h : engel R x ≤ H) :\n    normalizer H = H := by\n  set N := normalizer H\n  apply le_antisymm _ (le_normalizer H)\n  calc N.toSubmodule ≤ (engel R x).toSubmodule ⊔ H.toSubmodule := ?_\n       _ = H := by rwa [sup_eq_right]\n  have aux₁ : ∀ n ∈ N, ⁅x, n⁆ ∈ H := by\n    intro n hn\n    rw [mem_normalizer_iff] at hn\n    specialize hn x (h (self_mem_engel R x))\n    rwa [← lie_skew, neg_mem_iff (G := L)]\n  have aux₂ : ∀ n ∈ N, ⁅x, n⁆ ∈ N := fun n hn ↦ le_normalizer H (aux₁ _ hn)\n  let dx : N →ₗ[R] N := (ad R L x).restrict aux₂\n  obtain ⟨k, hk⟩ : ∃ a, ∀ b ≥ a, Codisjoint (LinearMap.ker (dx ^ b)) (LinearMap.range (dx ^ b)) :=\n    eventually_atTop.mp <| dx.eventually_codisjoint_ker_pow_range_pow\n  specialize hk (k+1) (Nat.le_add_right k 1)\n  rw [← Submodule.map_subtype_top N.toSubmodule, Submodule.map_le_iff_le_comap]\n  apply hk\n  · rw [← Submodule.map_le_iff_le_comap]\n    apply le_sup_of_le_left\n    rw [Submodule.map_le_iff_le_comap]\n    intro y hy\n    simp only [Submodule.mem_comap, mem_engel_iff, mem_toSubmodule]\n    use k+1\n    clear hk; revert hy\n    generalize k+1 = k\n    induction k generalizing y with\n    | zero =>\n      cases y; intro hy; simp only [pow_zero, LinearMap.one_apply]\n      exact (AddSubmonoid.mk_eq_zero N.toAddSubmonoid).mp hy\n    | succ k ih => simp only [pow_succ, LinearMap.mem_ker, LinearMap.mul_apply] at ih ⊢; apply ih\n  · rw [← Submodule.map_le_iff_le_comap]\n    apply le_sup_of_le_right\n    rw [Submodule.map_le_iff_le_comap]\n    rintro _ ⟨y, rfl⟩\n    simp only [pow_succ', LinearMap.mul_apply, Submodule.mem_comap, mem_toSubmodule]\n    apply aux₁\n    simp only [Submodule.coe_subtype, SetLike.coe_mem]\n\n"}
{"name":"LieSubalgebra.isNilpotent_of_forall_le_engel","module":"Mathlib.Algebra.Lie.EngelSubalgebra","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsNoetherian R L\nH : LieSubalgebra R L\nh : ∀ (x : L), Membership.mem H x → LE.le H (LieSubalgebra.engel R x)\n⊢ LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)","decl":"/-- A Lie subalgebra of a Noetherian Lie algebra is nilpotent\nif it is contained in the Engel subalgebra of all its elements. -/\nlemma isNilpotent_of_forall_le_engel [IsNoetherian R L]\n    (H : LieSubalgebra R L) (h : ∀ x ∈ H, H ≤ engel R x) :\n    LieRing.IsNilpotent H := by\n  rw [LieAlgebra.isNilpotent_iff_forall (R := R)]\n  intro x\n  let K : ℕ →o Submodule R H :=\n    ⟨fun n ↦ LinearMap.ker ((ad R H x) ^ n), fun m n hmn ↦ ?mono⟩\n  case mono =>\n    intro y hy\n    rw [LinearMap.mem_ker] at hy ⊢\n    exact LinearMap.pow_map_zero_of_le hmn hy\n  obtain ⟨n, hn⟩ := monotone_stabilizes_iff_noetherian.mpr inferInstance K\n  use n\n  ext y\n  rw [coe_ad_pow]\n  specialize h x x.2 y.2\n  rw [mem_engel_iff] at h\n  obtain ⟨m, hm⟩ := h\n  obtain (hmn|hmn) : m ≤ n ∨ n ≤ m := le_total m n\n  · exact LinearMap.pow_map_zero_of_le hmn hm\n  · have : ∀ k : ℕ, ((ad R L) x ^ k) y = 0 ↔ y ∈ K k := by simp [K, Subtype.ext_iff, coe_ad_pow]\n    rwa [this, ← hn m hmn, ← this] at hm\n\n"}
