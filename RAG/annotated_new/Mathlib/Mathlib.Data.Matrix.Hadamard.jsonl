{"name":"Matrix.hadamard_apply","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝ : Mul α\nA B : Matrix m n α\ni : m\nj : n\n⊢ Eq (A.hadamard B i j) (HMul.hMul (A i j) (B i j))","decl":"@[simp]\ntheorem hadamard_apply [Mul α] (A : Matrix m n α) (B : Matrix m n α) (i j) :\n    hadamard A B i j = A i j * B i j :=\n  rfl\n\n"}
{"name":"Matrix.hadamard_comm","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nA B : Matrix m n α\ninst✝ : CommSemigroup α\n⊢ Eq (A.hadamard B) (B.hadamard A)","decl":"theorem hadamard_comm [CommSemigroup α] : A ⊙ B = B ⊙ A :=\n  ext fun _ _ => mul_comm _ _\n\n-- associativity\n"}
{"name":"Matrix.hadamard_assoc","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nA B C : Matrix m n α\ninst✝ : Semigroup α\n⊢ Eq ((A.hadamard B).hadamard C) (A.hadamard (B.hadamard C))","decl":"theorem hadamard_assoc [Semigroup α] : A ⊙ B ⊙ C = A ⊙ (B ⊙ C) :=\n  ext fun _ _ => mul_assoc _ _ _\n\n-- distributivity\n"}
{"name":"Matrix.hadamard_add","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nA B C : Matrix m n α\ninst✝ : Distrib α\n⊢ Eq (A.hadamard (HAdd.hAdd B C)) (HAdd.hAdd (A.hadamard B) (A.hadamard C))","decl":"theorem hadamard_add [Distrib α] : A ⊙ (B + C) = A ⊙ B + A ⊙ C :=\n  ext fun _ _ => left_distrib _ _ _\n\n"}
{"name":"Matrix.add_hadamard","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nA B C : Matrix m n α\ninst✝ : Distrib α\n⊢ Eq ((HAdd.hAdd B C).hadamard A) (HAdd.hAdd (B.hadamard A) (C.hadamard A))","decl":"theorem add_hadamard [Distrib α] : (B + C) ⊙ A = B ⊙ A + C ⊙ A :=\n  ext fun _ _ => right_distrib _ _ _\n\n-- scalar multiplication\n"}
{"name":"Matrix.smul_hadamard","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\nA B : Matrix m n α\ninst✝² : Mul α\ninst✝¹ : SMul R α\ninst✝ : IsScalarTower R α α\nk : R\n⊢ Eq ((HSMul.hSMul k A).hadamard B) (HSMul.hSMul k (A.hadamard B))","decl":"@[simp]\ntheorem smul_hadamard [Mul α] [SMul R α] [IsScalarTower R α α] (k : R) : (k • A) ⊙ B = k • A ⊙ B :=\n  ext fun _ _ => smul_mul_assoc _ _ _\n\n"}
{"name":"Matrix.hadamard_smul","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\nA B : Matrix m n α\ninst✝² : Mul α\ninst✝¹ : SMul R α\ninst✝ : SMulCommClass R α α\nk : R\n⊢ Eq (A.hadamard (HSMul.hSMul k B)) (HSMul.hSMul k (A.hadamard B))","decl":"@[simp]\ntheorem hadamard_smul [Mul α] [SMul R α] [SMulCommClass R α α] (k : R) : A ⊙ (k • B) = k • A ⊙ B :=\n  ext fun _ _ => mul_smul_comm _ _ _\n\n"}
{"name":"Matrix.hadamard_zero","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nA : Matrix m n α\ninst✝ : MulZeroClass α\n⊢ Eq (A.hadamard 0) 0","decl":"@[simp]\ntheorem hadamard_zero : A ⊙ (0 : Matrix m n α) = 0 :=\n  ext fun _ _ => mul_zero _\n\n"}
{"name":"Matrix.zero_hadamard","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nA : Matrix m n α\ninst✝ : MulZeroClass α\n⊢ Eq (Matrix.hadamard 0 A) 0","decl":"@[simp]\ntheorem zero_hadamard : (0 : Matrix m n α) ⊙ A = 0 :=\n  ext fun _ _ => zero_mul _\n\n"}
{"name":"Matrix.hadamard_one","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : DecidableEq n\ninst✝ : MulZeroOneClass α\nM : Matrix n n α\n⊢ Eq (M.hadamard 1) (Matrix.diagonal fun i => M i i)","decl":"theorem hadamard_one : M ⊙ (1 : Matrix n n α) = diagonal fun i => M i i := by\n  ext i j\n  by_cases h : i = j <;> simp [h]\n\n"}
{"name":"Matrix.one_hadamard","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : DecidableEq n\ninst✝ : MulZeroOneClass α\nM : Matrix n n α\n⊢ Eq (Matrix.hadamard 1 M) (Matrix.diagonal fun i => M i i)","decl":"theorem one_hadamard : (1 : Matrix n n α) ⊙ M = diagonal fun i => M i i := by\n  ext i j\n  by_cases h : i = j <;> simp [h]\n\n"}
{"name":"Matrix.stdBasisMatrix_hadamard_stdBasisMatrix_eq","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : MulZeroClass α\ni : m\nj : n\na b : α\n⊢ Eq ((Matrix.stdBasisMatrix i j a).hadamard (Matrix.stdBasisMatrix i j b)) (Matrix.stdBasisMatrix i j (HMul.hMul a b))","decl":"theorem stdBasisMatrix_hadamard_stdBasisMatrix_eq (i : m) (j : n) (a b : α) :\n    stdBasisMatrix i j a ⊙ stdBasisMatrix i j b = stdBasisMatrix i j (a * b) :=\n  ext fun _ _ => (apply_ite₂ _ _ _ _ _ _).trans (congr_arg _ <| zero_mul 0)\n\n"}
{"name":"Matrix.stdBasisMatrix_hadamard_stdBasisMatrix_of_ne","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : MulZeroClass α\nia : m\nja : n\nib : m\njb : n\nh : Not (And (Eq ia ib) (Eq ja jb))\na b : α\n⊢ Eq ((Matrix.stdBasisMatrix ia ja a).hadamard (Matrix.stdBasisMatrix ib jb b)) 0","decl":"theorem stdBasisMatrix_hadamard_stdBasisMatrix_of_ne\n    {ia : m} {ja : n} {ib : m} {jb : n} (h : ¬(ia = ib ∧ ja = jb)) (a b : α) :\n    stdBasisMatrix ia ja a ⊙ stdBasisMatrix ib jb b = 0 := by\n  rw [not_and_or] at h\n  cases h <;> (simp only [stdBasisMatrix]; aesop)\n\n"}
{"name":"Matrix.diagonal_hadamard_diagonal","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nn : Type u_3\ninst✝¹ : DecidableEq n\ninst✝ : MulZeroClass α\nv w : n → α\n⊢ Eq ((Matrix.diagonal v).hadamard (Matrix.diagonal w)) (Matrix.diagonal (HMul.hMul v w))","decl":"theorem diagonal_hadamard_diagonal (v : n → α) (w : n → α) :\n    diagonal v ⊙ diagonal w = diagonal (v * w) :=\n  ext fun _ _ => (apply_ite₂ _ _ _ _ _ _).trans (congr_arg _ <| zero_mul 0)\n\n"}
{"name":"Matrix.sum_hadamard_eq","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nA B : Matrix m n α\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : Semiring α\n⊢ Eq (Finset.univ.sum fun i => Finset.univ.sum fun j => A.hadamard B i j) (HMul.hMul A B.transpose).trace","decl":"theorem sum_hadamard_eq : (∑ i : m, ∑ j : n, (A ⊙ B) i j) = trace (A * Bᵀ) :=\n  rfl\n\n"}
{"name":"Matrix.dotProduct_vecMul_hadamard","module":"Mathlib.Data.Matrix.Hadamard","initialProofState":"α : Type u_1\nm : Type u_2\nn : Type u_3\nA B : Matrix m n α\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : Semiring α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nv : m → α\nw : n → α\n⊢ Eq (dotProduct (Matrix.vecMul v (A.hadamard B)) w) (HMul.hMul (HMul.hMul (Matrix.diagonal v) A) (HMul.hMul B (Matrix.diagonal w)).transpose).trace","decl":"theorem dotProduct_vecMul_hadamard [DecidableEq m] [DecidableEq n] (v : m → α) (w : n → α) :\n    dotProduct (v ᵥ* (A ⊙ B)) w = trace (diagonal v * A * (B * diagonal w)ᵀ) := by\n  rw [← sum_hadamard_eq, Finset.sum_comm]\n  simp [dotProduct, vecMul, Finset.sum_mul, mul_assoc]\n\n"}
