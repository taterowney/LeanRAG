{"name":"ENormedSpace.mk.sizeOf_spec","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝⁴ : NormedField 𝕜\ninst✝³ : AddCommGroup V\ninst✝² : Module 𝕜 V\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf V\ntoFun : V → ENNReal\neq_zero' : ∀ (x : V), Eq (toFun x) 0 → Eq x 0\nmap_add_le' : ∀ (x y : V), LE.le (toFun (HAdd.hAdd x y)) (HAdd.hAdd (toFun x) (toFun y))\nmap_smul_le' : ∀ (c : 𝕜) (x : V), LE.le (toFun (HSMul.hSMul c x)) (HMul.hMul (↑(NNNorm.nnnorm c)) (toFun x))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, eq_zero' := eq_zero', map_add_le' := map_add_le', map_smul_le' := map_smul_le' }) 1","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`‖c • x‖ ≤ ‖c‖ * ‖x‖` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (𝕜 : Type*) (V : Type*) [NormedField 𝕜] [AddCommGroup V] [Module 𝕜 V] where\n  /-- the norm of an ENormedSpace, taking values into `ℝ≥0∞` -/\n  toFun : V → ℝ≥0∞\n  eq_zero' : ∀ x, toFun x = 0 → x = 0\n  map_add_le' : ∀ x y : V, toFun (x + y) ≤ toFun x + toFun y\n  map_smul_le' : ∀ (c : 𝕜) (x : V), toFun (c • x) ≤ ‖c‖₊ * toFun x\n\n"}
{"name":"ENormedSpace.eq_zero'","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\nself : ENormedSpace 𝕜 V\nx : V\na✝ : Eq (self.toFun x) 0\n⊢ Eq x 0","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`‖c • x‖ ≤ ‖c‖ * ‖x‖` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (𝕜 : Type*) (V : Type*) [NormedField 𝕜] [AddCommGroup V] [Module 𝕜 V] where\n  /-- the norm of an ENormedSpace, taking values into `ℝ≥0∞` -/\n  toFun : V → ℝ≥0∞\n  eq_zero' : ∀ x, toFun x = 0 → x = 0\n  map_add_le' : ∀ x y : V, toFun (x + y) ≤ toFun x + toFun y\n  map_smul_le' : ∀ (c : 𝕜) (x : V), toFun (c • x) ≤ ‖c‖₊ * toFun x\n\n"}
{"name":"ENormedSpace.mk.injEq","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ntoFun✝ : V → ENNReal\neq_zero'✝ : ∀ (x : V), Eq (toFun✝ x) 0 → Eq x 0\nmap_add_le'✝ : ∀ (x y : V), LE.le (toFun✝ (HAdd.hAdd x y)) (HAdd.hAdd (toFun✝ x) (toFun✝ y))\nmap_smul_le'✝ : ∀ (c : 𝕜) (x : V), LE.le (toFun✝ (HSMul.hSMul c x)) (HMul.hMul (↑(NNNorm.nnnorm c)) (toFun✝ x))\ntoFun : V → ENNReal\neq_zero' : ∀ (x : V), Eq (toFun x) 0 → Eq x 0\nmap_add_le' : ∀ (x y : V), LE.le (toFun (HAdd.hAdd x y)) (HAdd.hAdd (toFun x) (toFun y))\nmap_smul_le' : ∀ (c : 𝕜) (x : V), LE.le (toFun (HSMul.hSMul c x)) (HMul.hMul (↑(NNNorm.nnnorm c)) (toFun x))\n⊢ Eq (Eq { toFun := toFun✝, eq_zero' := eq_zero'✝, map_add_le' := map_add_le'✝, map_smul_le' := map_smul_le'✝ } { toFun := toFun, eq_zero' := eq_zero', map_add_le' := map_add_le', map_smul_le' := map_smul_le' }) (Eq toFun✝ toFun)","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`‖c • x‖ ≤ ‖c‖ * ‖x‖` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (𝕜 : Type*) (V : Type*) [NormedField 𝕜] [AddCommGroup V] [Module 𝕜 V] where\n  /-- the norm of an ENormedSpace, taking values into `ℝ≥0∞` -/\n  toFun : V → ℝ≥0∞\n  eq_zero' : ∀ x, toFun x = 0 → x = 0\n  map_add_le' : ∀ x y : V, toFun (x + y) ≤ toFun x + toFun y\n  map_smul_le' : ∀ (c : 𝕜) (x : V), toFun (c • x) ≤ ‖c‖₊ * toFun x\n\n"}
{"name":"ENormedSpace.mk.inj","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ntoFun✝ : V → ENNReal\neq_zero'✝ : ∀ (x : V), Eq (toFun✝ x) 0 → Eq x 0\nmap_add_le'✝ : ∀ (x y : V), LE.le (toFun✝ (HAdd.hAdd x y)) (HAdd.hAdd (toFun✝ x) (toFun✝ y))\nmap_smul_le'✝ : ∀ (c : 𝕜) (x : V), LE.le (toFun✝ (HSMul.hSMul c x)) (HMul.hMul (↑(NNNorm.nnnorm c)) (toFun✝ x))\ntoFun : V → ENNReal\neq_zero' : ∀ (x : V), Eq (toFun x) 0 → Eq x 0\nmap_add_le' : ∀ (x y : V), LE.le (toFun (HAdd.hAdd x y)) (HAdd.hAdd (toFun x) (toFun y))\nmap_smul_le' : ∀ (c : 𝕜) (x : V), LE.le (toFun (HSMul.hSMul c x)) (HMul.hMul (↑(NNNorm.nnnorm c)) (toFun x))\nx✝ : Eq { toFun := toFun✝, eq_zero' := eq_zero'✝, map_add_le' := map_add_le'✝, map_smul_le' := map_smul_le'✝ } { toFun := toFun, eq_zero' := eq_zero', map_add_le' := map_add_le', map_smul_le' := map_smul_le' }\n⊢ Eq toFun✝ toFun","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`‖c • x‖ ≤ ‖c‖ * ‖x‖` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (𝕜 : Type*) (V : Type*) [NormedField 𝕜] [AddCommGroup V] [Module 𝕜 V] where\n  /-- the norm of an ENormedSpace, taking values into `ℝ≥0∞` -/\n  toFun : V → ℝ≥0∞\n  eq_zero' : ∀ x, toFun x = 0 → x = 0\n  map_add_le' : ∀ x y : V, toFun (x + y) ≤ toFun x + toFun y\n  map_smul_le' : ∀ (c : 𝕜) (x : V), toFun (c • x) ≤ ‖c‖₊ * toFun x\n\n"}
{"name":"ENormedSpace.map_add_le'","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\nself : ENormedSpace 𝕜 V\nx y : V\n⊢ LE.le (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`‖c • x‖ ≤ ‖c‖ * ‖x‖` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (𝕜 : Type*) (V : Type*) [NormedField 𝕜] [AddCommGroup V] [Module 𝕜 V] where\n  /-- the norm of an ENormedSpace, taking values into `ℝ≥0∞` -/\n  toFun : V → ℝ≥0∞\n  eq_zero' : ∀ x, toFun x = 0 → x = 0\n  map_add_le' : ∀ x y : V, toFun (x + y) ≤ toFun x + toFun y\n  map_smul_le' : ∀ (c : 𝕜) (x : V), toFun (c • x) ≤ ‖c‖₊ * toFun x\n\n"}
{"name":"ENormedSpace.map_smul_le'","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\nself : ENormedSpace 𝕜 V\nc : 𝕜\nx : V\n⊢ LE.le (self.toFun (HSMul.hSMul c x)) (HMul.hMul (↑(NNNorm.nnnorm c)) (self.toFun x))","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`‖c • x‖ ≤ ‖c‖ * ‖x‖` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (𝕜 : Type*) (V : Type*) [NormedField 𝕜] [AddCommGroup V] [Module 𝕜 V] where\n  /-- the norm of an ENormedSpace, taking values into `ℝ≥0∞` -/\n  toFun : V → ℝ≥0∞\n  eq_zero' : ∀ x, toFun x = 0 → x = 0\n  map_add_le' : ∀ x y : V, toFun (x + y) ≤ toFun x + toFun y\n  map_smul_le' : ∀ (c : 𝕜) (x : V), toFun (c • x) ≤ ‖c‖₊ * toFun x\n\n"}
{"name":"ENormedSpace.coeFn_injective","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\n⊢ Function.Injective ENormedSpace.toFun","decl":"theorem coeFn_injective : Function.Injective ((↑) : ENormedSpace 𝕜 V → V → ℝ≥0∞) := by\n  intro e₁ e₂ h\n  cases e₁\n  cases e₂\n  congr\n\n"}
{"name":"ENormedSpace.ext_iff","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne₁ e₂ : ENormedSpace 𝕜 V\n⊢ Iff (Eq e₁ e₂) (∀ (x : V), Eq (↑e₁ x) (↑e₂ x))","decl":"@[ext]\ntheorem ext {e₁ e₂ : ENormedSpace 𝕜 V} (h : ∀ x, e₁ x = e₂ x) : e₁ = e₂ :=\n  coeFn_injective <| funext h\n\n"}
{"name":"ENormedSpace.ext","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne₁ e₂ : ENormedSpace 𝕜 V\nh : ∀ (x : V), Eq (↑e₁ x) (↑e₂ x)\n⊢ Eq e₁ e₂","decl":"@[ext]\ntheorem ext {e₁ e₂ : ENormedSpace 𝕜 V} (h : ∀ x, e₁ x = e₂ x) : e₁ = e₂ :=\n  coeFn_injective <| funext h\n\n"}
{"name":"ENormedSpace.coe_inj","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne₁ e₂ : ENormedSpace 𝕜 V\n⊢ Iff (Eq ↑e₁ ↑e₂) (Eq e₁ e₂)","decl":"@[simp, norm_cast]\ntheorem coe_inj {e₁ e₂ : ENormedSpace 𝕜 V} : (e₁ : V → ℝ≥0∞) = e₂ ↔ e₁ = e₂ :=\n  coeFn_injective.eq_iff\n\n"}
{"name":"ENormedSpace.map_smul","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\nc : 𝕜\nx : V\n⊢ Eq (↑e (HSMul.hSMul c x)) (HMul.hMul (↑(NNNorm.nnnorm c)) (↑e x))","decl":"@[simp]\ntheorem map_smul (c : 𝕜) (x : V) : e (c • x) = ‖c‖₊ * e x := by\n  apply le_antisymm (e.map_smul_le' c x)\n  by_cases hc : c = 0\n  · simp [hc]\n  calc\n    (‖c‖₊ : ℝ≥0∞) * e x = ‖c‖₊ * e (c⁻¹ • c • x) := by rw [inv_smul_smul₀ hc]\n    _ ≤ ‖c‖₊ * (‖c⁻¹‖₊ * e (c • x)) := mul_le_mul_left' (e.map_smul_le' _ _) _\n    _ = e (c • x) := by\n      rw [← mul_assoc, nnnorm_inv, ENNReal.coe_inv, ENNReal.mul_inv_cancel _ ENNReal.coe_ne_top,\n        one_mul]\n        <;> simp [hc]\n\n"}
{"name":"ENormedSpace.map_zero","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\n⊢ Eq (↑e 0) 0","decl":"@[simp]\ntheorem map_zero : e 0 = 0 := by\n  rw [← zero_smul 𝕜 (0 : V), e.map_smul]\n  norm_num\n\n"}
{"name":"ENormedSpace.eq_zero_iff","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\nx : V\n⊢ Iff (Eq (↑e x) 0) (Eq x 0)","decl":"@[simp]\ntheorem eq_zero_iff {x : V} : e x = 0 ↔ x = 0 :=\n  ⟨e.eq_zero' x, fun h => h.symm ▸ e.map_zero⟩\n\n"}
{"name":"ENormedSpace.map_neg","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\nx : V\n⊢ Eq (↑e (Neg.neg x)) (↑e x)","decl":"@[simp]\ntheorem map_neg (x : V) : e (-x) = e x :=\n  calc\n    e (-x) = ‖(-1 : 𝕜)‖₊ * e x := by rw [← map_smul, neg_one_smul]\n    _ = e x := by simp\n\n"}
{"name":"ENormedSpace.map_sub_rev","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\nx y : V\n⊢ Eq (↑e (HSub.hSub x y)) (↑e (HSub.hSub y x))","decl":"theorem map_sub_rev (x y : V) : e (x - y) = e (y - x) := by rw [← neg_sub, e.map_neg]\n\n"}
{"name":"ENormedSpace.map_add_le","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\nx y : V\n⊢ LE.le (↑e (HAdd.hAdd x y)) (HAdd.hAdd (↑e x) (↑e y))","decl":"theorem map_add_le (x y : V) : e (x + y) ≤ e x + e y :=\n  e.map_add_le' x y\n\n"}
{"name":"ENormedSpace.map_sub_le","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\nx y : V\n⊢ LE.le (↑e (HSub.hSub x y)) (HAdd.hAdd (↑e x) (↑e y))","decl":"theorem map_sub_le (x y : V) : e (x - y) ≤ e x + e y :=\n  calc\n    e (x - y) = e (x + -y) := by rw [sub_eq_add_neg]\n    _ ≤ e x + e (-y) := e.map_add_le x (-y)\n    _ = e x + e y := by rw [e.map_neg]\n\n"}
{"name":"ENormedSpace.top_map","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\nx : V\nhx : Ne x 0\n⊢ Eq (↑Top.top x) Top.top","decl":"theorem top_map {x : V} (hx : x ≠ 0) : (⊤ : ENormedSpace 𝕜 V) x = ⊤ :=\n  if_neg hx\n\n"}
{"name":"ENormedSpace.coe_max","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne₁ e₂ : ENormedSpace 𝕜 V\n⊢ Eq ↑(Max.max e₁ e₂) fun x => Max.max (↑e₁ x) (↑e₂ x)","decl":"@[simp, norm_cast]\ntheorem coe_max (e₁ e₂ : ENormedSpace 𝕜 V) : ⇑(e₁ ⊔ e₂) = fun x => max (e₁ x) (e₂ x) :=\n  rfl\n\n"}
{"name":"ENormedSpace.max_map","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne₁ e₂ : ENormedSpace 𝕜 V\nx : V\n⊢ Eq (↑(Max.max e₁ e₂) x) (Max.max (↑e₁ x) (↑e₂ x))","decl":"@[norm_cast]\ntheorem max_map (e₁ e₂ : ENormedSpace 𝕜 V) (x : V) : (e₁ ⊔ e₂) x = max (e₁ x) (e₂ x) :=\n  rfl\n\n"}
{"name":"ENormedSpace.finite_dist_eq","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\nx y : Subtype fun x => Membership.mem e.finiteSubspace x\n⊢ Eq (Dist.dist x y) (↑e (HSub.hSub ↑x ↑y)).toReal","decl":"theorem finite_dist_eq (x y : e.finiteSubspace) : dist x y = (e (x - y)).toReal :=\n  rfl\n\n"}
{"name":"ENormedSpace.finite_edist_eq","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\nx y : Subtype fun x => Membership.mem e.finiteSubspace x\n⊢ Eq (EDist.edist x y) (↑e (HSub.hSub ↑x ↑y))","decl":"theorem finite_edist_eq (x y : e.finiteSubspace) : edist x y = e (x - y) :=\n  rfl\n\n"}
{"name":"ENormedSpace.finite_norm_eq","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"𝕜 : Type u_1\nV : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup V\ninst✝ : Module 𝕜 V\ne : ENormedSpace 𝕜 V\nx : Subtype fun x => Membership.mem e.finiteSubspace x\n⊢ Eq (Norm.norm x) (↑e ↑x).toReal","decl":"theorem finite_norm_eq (x : e.finiteSubspace) : ‖x‖ = (e x).toReal :=\n  rfl\n\n"}
