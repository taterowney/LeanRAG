{"name":"ENormedSpace.mk.sizeOf_spec","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : AddCommGroup V\ninstâœÂ² : Module ğ•œ V\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf V\ntoFun : V â†’ ENNReal\neq_zero' : âˆ€ (x : V), Eq (toFun x) 0 â†’ Eq x 0\nmap_add_le' : âˆ€ (x y : V), LE.le (toFun (HAdd.hAdd x y)) (HAdd.hAdd (toFun x) (toFun y))\nmap_smul_le' : âˆ€ (c : ğ•œ) (x : V), LE.le (toFun (HSMul.hSMul c x)) (HMul.hMul (â†‘(NNNorm.nnnorm c)) (toFun x))\nâŠ¢ Eq (SizeOf.sizeOf { toFun := toFun, eq_zero' := eq_zero', map_add_le' := map_add_le', map_smul_le' := map_smul_le' }) 1","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`â€–c â€¢ xâ€– â‰¤ â€–câ€– * â€–xâ€–` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (ğ•œ : Type*) (V : Type*) [NormedField ğ•œ] [AddCommGroup V] [Module ğ•œ V] where\n  /-- the norm of an ENormedSpace, taking values into `â„â‰¥0âˆ` -/\n  toFun : V â†’ â„â‰¥0âˆ\n  eq_zero' : âˆ€ x, toFun x = 0 â†’ x = 0\n  map_add_le' : âˆ€ x y : V, toFun (x + y) â‰¤ toFun x + toFun y\n  map_smul_le' : âˆ€ (c : ğ•œ) (x : V), toFun (c â€¢ x) â‰¤ â€–câ€–â‚Š * toFun x\n\n"}
{"name":"ENormedSpace.eq_zero'","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\nself : ENormedSpace ğ•œ V\nx : V\naâœ : Eq (self.toFun x) 0\nâŠ¢ Eq x 0","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`â€–c â€¢ xâ€– â‰¤ â€–câ€– * â€–xâ€–` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (ğ•œ : Type*) (V : Type*) [NormedField ğ•œ] [AddCommGroup V] [Module ğ•œ V] where\n  /-- the norm of an ENormedSpace, taking values into `â„â‰¥0âˆ` -/\n  toFun : V â†’ â„â‰¥0âˆ\n  eq_zero' : âˆ€ x, toFun x = 0 â†’ x = 0\n  map_add_le' : âˆ€ x y : V, toFun (x + y) â‰¤ toFun x + toFun y\n  map_smul_le' : âˆ€ (c : ğ•œ) (x : V), toFun (c â€¢ x) â‰¤ â€–câ€–â‚Š * toFun x\n\n"}
{"name":"ENormedSpace.mk.injEq","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ntoFunâœ : V â†’ ENNReal\neq_zero'âœ : âˆ€ (x : V), Eq (toFunâœ x) 0 â†’ Eq x 0\nmap_add_le'âœ : âˆ€ (x y : V), LE.le (toFunâœ (HAdd.hAdd x y)) (HAdd.hAdd (toFunâœ x) (toFunâœ y))\nmap_smul_le'âœ : âˆ€ (c : ğ•œ) (x : V), LE.le (toFunâœ (HSMul.hSMul c x)) (HMul.hMul (â†‘(NNNorm.nnnorm c)) (toFunâœ x))\ntoFun : V â†’ ENNReal\neq_zero' : âˆ€ (x : V), Eq (toFun x) 0 â†’ Eq x 0\nmap_add_le' : âˆ€ (x y : V), LE.le (toFun (HAdd.hAdd x y)) (HAdd.hAdd (toFun x) (toFun y))\nmap_smul_le' : âˆ€ (c : ğ•œ) (x : V), LE.le (toFun (HSMul.hSMul c x)) (HMul.hMul (â†‘(NNNorm.nnnorm c)) (toFun x))\nâŠ¢ Eq (Eq { toFun := toFunâœ, eq_zero' := eq_zero'âœ, map_add_le' := map_add_le'âœ, map_smul_le' := map_smul_le'âœ } { toFun := toFun, eq_zero' := eq_zero', map_add_le' := map_add_le', map_smul_le' := map_smul_le' }) (Eq toFunâœ toFun)","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`â€–c â€¢ xâ€– â‰¤ â€–câ€– * â€–xâ€–` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (ğ•œ : Type*) (V : Type*) [NormedField ğ•œ] [AddCommGroup V] [Module ğ•œ V] where\n  /-- the norm of an ENormedSpace, taking values into `â„â‰¥0âˆ` -/\n  toFun : V â†’ â„â‰¥0âˆ\n  eq_zero' : âˆ€ x, toFun x = 0 â†’ x = 0\n  map_add_le' : âˆ€ x y : V, toFun (x + y) â‰¤ toFun x + toFun y\n  map_smul_le' : âˆ€ (c : ğ•œ) (x : V), toFun (c â€¢ x) â‰¤ â€–câ€–â‚Š * toFun x\n\n"}
{"name":"ENormedSpace.mk.inj","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ntoFunâœ : V â†’ ENNReal\neq_zero'âœ : âˆ€ (x : V), Eq (toFunâœ x) 0 â†’ Eq x 0\nmap_add_le'âœ : âˆ€ (x y : V), LE.le (toFunâœ (HAdd.hAdd x y)) (HAdd.hAdd (toFunâœ x) (toFunâœ y))\nmap_smul_le'âœ : âˆ€ (c : ğ•œ) (x : V), LE.le (toFunâœ (HSMul.hSMul c x)) (HMul.hMul (â†‘(NNNorm.nnnorm c)) (toFunâœ x))\ntoFun : V â†’ ENNReal\neq_zero' : âˆ€ (x : V), Eq (toFun x) 0 â†’ Eq x 0\nmap_add_le' : âˆ€ (x y : V), LE.le (toFun (HAdd.hAdd x y)) (HAdd.hAdd (toFun x) (toFun y))\nmap_smul_le' : âˆ€ (c : ğ•œ) (x : V), LE.le (toFun (HSMul.hSMul c x)) (HMul.hMul (â†‘(NNNorm.nnnorm c)) (toFun x))\nxâœ : Eq { toFun := toFunâœ, eq_zero' := eq_zero'âœ, map_add_le' := map_add_le'âœ, map_smul_le' := map_smul_le'âœ } { toFun := toFun, eq_zero' := eq_zero', map_add_le' := map_add_le', map_smul_le' := map_smul_le' }\nâŠ¢ Eq toFunâœ toFun","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`â€–c â€¢ xâ€– â‰¤ â€–câ€– * â€–xâ€–` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (ğ•œ : Type*) (V : Type*) [NormedField ğ•œ] [AddCommGroup V] [Module ğ•œ V] where\n  /-- the norm of an ENormedSpace, taking values into `â„â‰¥0âˆ` -/\n  toFun : V â†’ â„â‰¥0âˆ\n  eq_zero' : âˆ€ x, toFun x = 0 â†’ x = 0\n  map_add_le' : âˆ€ x y : V, toFun (x + y) â‰¤ toFun x + toFun y\n  map_smul_le' : âˆ€ (c : ğ•œ) (x : V), toFun (c â€¢ x) â‰¤ â€–câ€–â‚Š * toFun x\n\n"}
{"name":"ENormedSpace.map_add_le'","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\nself : ENormedSpace ğ•œ V\nx y : V\nâŠ¢ LE.le (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`â€–c â€¢ xâ€– â‰¤ â€–câ€– * â€–xâ€–` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (ğ•œ : Type*) (V : Type*) [NormedField ğ•œ] [AddCommGroup V] [Module ğ•œ V] where\n  /-- the norm of an ENormedSpace, taking values into `â„â‰¥0âˆ` -/\n  toFun : V â†’ â„â‰¥0âˆ\n  eq_zero' : âˆ€ x, toFun x = 0 â†’ x = 0\n  map_add_le' : âˆ€ x y : V, toFun (x + y) â‰¤ toFun x + toFun y\n  map_smul_le' : âˆ€ (c : ğ•œ) (x : V), toFun (c â€¢ x) â‰¤ â€–câ€–â‚Š * toFun x\n\n"}
{"name":"ENormedSpace.map_smul_le'","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\nself : ENormedSpace ğ•œ V\nc : ğ•œ\nx : V\nâŠ¢ LE.le (self.toFun (HSMul.hSMul c x)) (HMul.hMul (â†‘(NNNorm.nnnorm c)) (self.toFun x))","decl":"/-- Extended norm on a vector space. As in the case of normed spaces, we require only\n`â€–c â€¢ xâ€– â‰¤ â€–câ€– * â€–xâ€–` in the definition, then prove an equality in `map_smul`. -/\nstructure ENormedSpace (ğ•œ : Type*) (V : Type*) [NormedField ğ•œ] [AddCommGroup V] [Module ğ•œ V] where\n  /-- the norm of an ENormedSpace, taking values into `â„â‰¥0âˆ` -/\n  toFun : V â†’ â„â‰¥0âˆ\n  eq_zero' : âˆ€ x, toFun x = 0 â†’ x = 0\n  map_add_le' : âˆ€ x y : V, toFun (x + y) â‰¤ toFun x + toFun y\n  map_smul_le' : âˆ€ (c : ğ•œ) (x : V), toFun (c â€¢ x) â‰¤ â€–câ€–â‚Š * toFun x\n\n"}
{"name":"ENormedSpace.coeFn_injective","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\nâŠ¢ Function.Injective ENormedSpace.toFun","decl":"theorem coeFn_injective : Function.Injective ((â†‘) : ENormedSpace ğ•œ V â†’ V â†’ â„â‰¥0âˆ) := by\n  intro eâ‚ eâ‚‚ h\n  cases eâ‚\n  cases eâ‚‚\n  congr\n\n"}
{"name":"ENormedSpace.ext_iff","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\neâ‚ eâ‚‚ : ENormedSpace ğ•œ V\nâŠ¢ Iff (Eq eâ‚ eâ‚‚) (âˆ€ (x : V), Eq (â†‘eâ‚ x) (â†‘eâ‚‚ x))","decl":"@[ext]\ntheorem ext {eâ‚ eâ‚‚ : ENormedSpace ğ•œ V} (h : âˆ€ x, eâ‚ x = eâ‚‚ x) : eâ‚ = eâ‚‚ :=\n  coeFn_injective <| funext h\n\n"}
{"name":"ENormedSpace.ext","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\neâ‚ eâ‚‚ : ENormedSpace ğ•œ V\nh : âˆ€ (x : V), Eq (â†‘eâ‚ x) (â†‘eâ‚‚ x)\nâŠ¢ Eq eâ‚ eâ‚‚","decl":"@[ext]\ntheorem ext {eâ‚ eâ‚‚ : ENormedSpace ğ•œ V} (h : âˆ€ x, eâ‚ x = eâ‚‚ x) : eâ‚ = eâ‚‚ :=\n  coeFn_injective <| funext h\n\n"}
{"name":"ENormedSpace.coe_inj","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\neâ‚ eâ‚‚ : ENormedSpace ğ•œ V\nâŠ¢ Iff (Eq â†‘eâ‚ â†‘eâ‚‚) (Eq eâ‚ eâ‚‚)","decl":"@[simp, norm_cast]\ntheorem coe_inj {eâ‚ eâ‚‚ : ENormedSpace ğ•œ V} : (eâ‚ : V â†’ â„â‰¥0âˆ) = eâ‚‚ â†” eâ‚ = eâ‚‚ :=\n  coeFn_injective.eq_iff\n\n"}
{"name":"ENormedSpace.map_smul","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nc : ğ•œ\nx : V\nâŠ¢ Eq (â†‘e (HSMul.hSMul c x)) (HMul.hMul (â†‘(NNNorm.nnnorm c)) (â†‘e x))","decl":"@[simp]\ntheorem map_smul (c : ğ•œ) (x : V) : e (c â€¢ x) = â€–câ€–â‚Š * e x := by\n  apply le_antisymm (e.map_smul_le' c x)\n  by_cases hc : c = 0\n  Â· simp [hc]\n  calc\n    (â€–câ€–â‚Š : â„â‰¥0âˆ) * e x = â€–câ€–â‚Š * e (câ»Â¹ â€¢ c â€¢ x) := by rw [inv_smul_smulâ‚€ hc]\n    _ â‰¤ â€–câ€–â‚Š * (â€–câ»Â¹â€–â‚Š * e (c â€¢ x)) := mul_le_mul_left' (e.map_smul_le' _ _) _\n    _ = e (c â€¢ x) := by\n      rw [â† mul_assoc, nnnorm_inv, ENNReal.coe_inv, ENNReal.mul_inv_cancel _ ENNReal.coe_ne_top,\n        one_mul]\n        <;> simp [hc]\n\n"}
{"name":"ENormedSpace.map_zero","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nâŠ¢ Eq (â†‘e 0) 0","decl":"@[simp]\ntheorem map_zero : e 0 = 0 := by\n  rw [â† zero_smul ğ•œ (0 : V), e.map_smul]\n  norm_num\n\n"}
{"name":"ENormedSpace.eq_zero_iff","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nx : V\nâŠ¢ Iff (Eq (â†‘e x) 0) (Eq x 0)","decl":"@[simp]\ntheorem eq_zero_iff {x : V} : e x = 0 â†” x = 0 :=\n  âŸ¨e.eq_zero' x, fun h => h.symm â–¸ e.map_zeroâŸ©\n\n"}
{"name":"ENormedSpace.map_neg","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nx : V\nâŠ¢ Eq (â†‘e (Neg.neg x)) (â†‘e x)","decl":"@[simp]\ntheorem map_neg (x : V) : e (-x) = e x :=\n  calc\n    e (-x) = â€–(-1 : ğ•œ)â€–â‚Š * e x := by rw [â† map_smul, neg_one_smul]\n    _ = e x := by simp\n\n"}
{"name":"ENormedSpace.map_sub_rev","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nx y : V\nâŠ¢ Eq (â†‘e (HSub.hSub x y)) (â†‘e (HSub.hSub y x))","decl":"theorem map_sub_rev (x y : V) : e (x - y) = e (y - x) := by rw [â† neg_sub, e.map_neg]\n\n"}
{"name":"ENormedSpace.map_add_le","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nx y : V\nâŠ¢ LE.le (â†‘e (HAdd.hAdd x y)) (HAdd.hAdd (â†‘e x) (â†‘e y))","decl":"theorem map_add_le (x y : V) : e (x + y) â‰¤ e x + e y :=\n  e.map_add_le' x y\n\n"}
{"name":"ENormedSpace.map_sub_le","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nx y : V\nâŠ¢ LE.le (â†‘e (HSub.hSub x y)) (HAdd.hAdd (â†‘e x) (â†‘e y))","decl":"theorem map_sub_le (x y : V) : e (x - y) â‰¤ e x + e y :=\n  calc\n    e (x - y) = e (x + -y) := by rw [sub_eq_add_neg]\n    _ â‰¤ e x + e (-y) := e.map_add_le x (-y)\n    _ = e x + e y := by rw [e.map_neg]\n\n"}
{"name":"ENormedSpace.top_map","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\nx : V\nhx : Ne x 0\nâŠ¢ Eq (â†‘Top.top x) Top.top","decl":"theorem top_map {x : V} (hx : x â‰  0) : (âŠ¤ : ENormedSpace ğ•œ V) x = âŠ¤ :=\n  if_neg hx\n\n"}
{"name":"ENormedSpace.coe_max","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\neâ‚ eâ‚‚ : ENormedSpace ğ•œ V\nâŠ¢ Eq â†‘(Max.max eâ‚ eâ‚‚) fun x => Max.max (â†‘eâ‚ x) (â†‘eâ‚‚ x)","decl":"@[simp, norm_cast]\ntheorem coe_max (eâ‚ eâ‚‚ : ENormedSpace ğ•œ V) : â‡‘(eâ‚ âŠ” eâ‚‚) = fun x => max (eâ‚ x) (eâ‚‚ x) :=\n  rfl\n\n"}
{"name":"ENormedSpace.max_map","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\neâ‚ eâ‚‚ : ENormedSpace ğ•œ V\nx : V\nâŠ¢ Eq (â†‘(Max.max eâ‚ eâ‚‚) x) (Max.max (â†‘eâ‚ x) (â†‘eâ‚‚ x))","decl":"@[norm_cast]\ntheorem max_map (eâ‚ eâ‚‚ : ENormedSpace ğ•œ V) (x : V) : (eâ‚ âŠ” eâ‚‚) x = max (eâ‚ x) (eâ‚‚ x) :=\n  rfl\n\n"}
{"name":"ENormedSpace.finite_dist_eq","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nx y : Subtype fun x => Membership.mem e.finiteSubspace x\nâŠ¢ Eq (Dist.dist x y) (â†‘e (HSub.hSub â†‘x â†‘y)).toReal","decl":"theorem finite_dist_eq (x y : e.finiteSubspace) : dist x y = (e (x - y)).toReal :=\n  rfl\n\n"}
{"name":"ENormedSpace.finite_edist_eq","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nx y : Subtype fun x => Membership.mem e.finiteSubspace x\nâŠ¢ Eq (EDist.edist x y) (â†‘e (HSub.hSub â†‘x â†‘y))","decl":"theorem finite_edist_eq (x y : e.finiteSubspace) : edist x y = e (x - y) :=\n  rfl\n\n"}
{"name":"ENormedSpace.finite_norm_eq","module":"Mathlib.Analysis.NormedSpace.ENormedSpace","initialProofState":"ğ•œ : Type u_1\nV : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup V\ninstâœ : Module ğ•œ V\ne : ENormedSpace ğ•œ V\nx : Subtype fun x => Membership.mem e.finiteSubspace x\nâŠ¢ Eq (Norm.norm x) (â†‘e â†‘x).toReal","decl":"theorem finite_norm_eq (x : e.finiteSubspace) : â€–xâ€– = (e x).toReal :=\n  rfl\n\n"}
