{"name":"IntermediateField.Lifts.mk.sizeOf_spec","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F E\ninst✝³ : Algebra F K\ninst✝² : SizeOf F\ninst✝¹ : SizeOf E\ninst✝ : SizeOf K\ncarrier : IntermediateField F E\nemb : AlgHom F (Subtype fun x => Membership.mem carrier x) K\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, emb := emb }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf carrier)) (SizeOf.sizeOf emb))","decl":"/-- Lifts `L → K` of `F → K` -/\nstructure Lifts where\n  /-- The domain of a lift. -/\n  carrier : IntermediateField F E\n  /-- The lifted RingHom, expressed as an AlgHom. -/\n  emb : carrier →ₐ[F] K\n\n"}
{"name":"IntermediateField.Lifts.mk.injEq","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\ncarrier✝ : IntermediateField F E\nemb✝ : AlgHom F (Subtype fun x => Membership.mem carrier✝ x) K\ncarrier : IntermediateField F E\nemb : AlgHom F (Subtype fun x => Membership.mem carrier x) K\n⊢ Eq (Eq { carrier := carrier✝, emb := emb✝ } { carrier := carrier, emb := emb }) (And (Eq carrier✝ carrier) (HEq emb✝ emb))","decl":"/-- Lifts `L → K` of `F → K` -/\nstructure Lifts where\n  /-- The domain of a lift. -/\n  carrier : IntermediateField F E\n  /-- The lifted RingHom, expressed as an AlgHom. -/\n  emb : carrier →ₐ[F] K\n\n"}
{"name":"IntermediateField.Lifts.mk.inj","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\ncarrier✝ : IntermediateField F E\nemb✝ : AlgHom F (Subtype fun x => Membership.mem carrier✝ x) K\ncarrier : IntermediateField F E\nemb : AlgHom F (Subtype fun x => Membership.mem carrier x) K\nx✝ : Eq { carrier := carrier✝, emb := emb✝ } { carrier := carrier, emb := emb }\n⊢ And (Eq carrier✝ carrier) (HEq emb✝ emb)","decl":"/-- Lifts `L → K` of `F → K` -/\nstructure Lifts where\n  /-- The domain of a lift. -/\n  carrier : IntermediateField F E\n  /-- The lifted RingHom, expressed as an AlgHom. -/\n  emb : carrier →ₐ[F] K\n\n"}
{"name":"IntermediateField.Lifts.le_iff","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nL₁ L₂ : IntermediateField.Lifts F E K\n⊢ Iff (LE.le L₁ L₂) (Exists fun h => Eq (L₂.emb.comp (IntermediateField.inclusion h)) L₁.emb)","decl":"theorem le_iff : L₁ ≤ L₂ ↔\n    ∃ h : L₁.carrier ≤ L₂.carrier, L₂.emb.comp (inclusion h) = L₁.emb := by\n  simp_rw [AlgHom.ext_iff]; rfl\n\n"}
{"name":"IntermediateField.Lifts.eq_iff_le_carrier_eq","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nL₁ L₂ : IntermediateField.Lifts F E K\n⊢ Iff (Eq L₁ L₂) (And (LE.le L₁ L₂) (Eq L₁.carrier L₂.carrier))","decl":"theorem eq_iff_le_carrier_eq : L₁ = L₂ ↔ L₁ ≤ L₂ ∧ L₁.carrier = L₂.carrier :=\n  ⟨fun eq ↦ ⟨eq.le, congr_arg _ eq⟩, fun ⟨le, eq⟩ ↦ le.antisymm ⟨eq.ge, fun x ↦ (le.2 ⟨x, _⟩).symm⟩⟩\n\n"}
{"name":"IntermediateField.Lifts.eq_iff","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nL₁ L₂ : IntermediateField.Lifts F E K\n⊢ Iff (Eq L₁ L₂) (Exists fun h => Eq (L₂.emb.comp (IntermediateField.inclusion ⋯)) L₁.emb)","decl":"theorem eq_iff : L₁ = L₂ ↔\n    ∃ h : L₁.carrier = L₂.carrier, L₂.emb.comp (inclusion h.le) = L₁.emb := by\n  rw [eq_iff_le_carrier_eq, le_iff]\n  exact ⟨fun h ↦ ⟨h.2, h.1.2⟩, fun h ↦ ⟨⟨h.1.le, h.2⟩, h.1⟩⟩\n\n"}
{"name":"IntermediateField.Lifts.lt_iff_le_carrier_ne","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nL₁ L₂ : IntermediateField.Lifts F E K\n⊢ Iff (LT.lt L₁ L₂) (And (LE.le L₁ L₂) (Ne L₁.carrier L₂.carrier))","decl":"theorem lt_iff_le_carrier_ne : L₁ < L₂ ↔ L₁ ≤ L₂ ∧ L₁.carrier ≠ L₂.carrier := by\n  rw [lt_iff_le_and_ne, and_congr_right]; intro h; simp_rw [Ne, eq_iff_le_carrier_eq, h, true_and]\n\n"}
{"name":"IntermediateField.Lifts.lt_iff","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nL₁ L₂ : IntermediateField.Lifts F E K\n⊢ Iff (LT.lt L₁ L₂) (Exists fun h => Eq (L₂.emb.comp (IntermediateField.inclusion ⋯)) L₁.emb)","decl":"theorem lt_iff : L₁ < L₂ ↔\n    ∃ h : L₁.carrier < L₂.carrier, L₂.emb.comp (inclusion h.le) = L₁.emb := by\n  rw [lt_iff_le_carrier_ne, le_iff]\n  exact ⟨fun h ↦ ⟨h.1.1.lt_of_ne h.2, h.1.2⟩, fun h ↦ ⟨⟨h.1.le, h.2⟩, h.1.ne⟩⟩\n\n"}
{"name":"IntermediateField.Lifts.le_of_carrier_le_iSup","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nι : Sort u_4\nρ : ι → IntermediateField.Lifts F E K\nσ τ : IntermediateField.Lifts F E K\nhσ : ∀ (i : ι), LE.le (ρ i) σ\nhτ : ∀ (i : ι), LE.le (ρ i) τ\ncarrier_le : LE.le σ.carrier (iSup fun i => (ρ i).carrier)\n⊢ LE.le σ τ","decl":"theorem le_of_carrier_le_iSup {ι} {ρ : ι → Lifts F E K} {σ τ : Lifts F E K}\n    (hσ : ∀ i, ρ i ≤ σ) (hτ : ∀ i, ρ i ≤ τ) (carrier_le : σ.carrier ≤ ⨆ i, (ρ i).carrier) :\n    σ ≤ τ :=\n  le_iff.mpr ⟨carrier_le.trans (iSup_le fun i ↦ (hτ i).1), algHom_ext_of_eq_adjoin _\n      (carrier_le.antisymm (iSup_le fun i ↦ (hσ i).1)|>.trans <| iSup_eq_adjoin _ _) fun x hx ↦\n    have ⟨i, hx⟩ := Set.mem_iUnion.mp hx\n    ((hτ i).2 ⟨x, hx⟩).trans ((hσ i).2 ⟨x, hx⟩).symm⟩\n\n"}
{"name":"IntermediateField.Lifts.le_union","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nc : Set (IntermediateField.Lifts F E K)\nhc : IsChain (fun x1 x2 => LE.le x1 x2) c\nσ : IntermediateField.Lifts F E K\nhσ : Membership.mem c σ\n⊢ LE.le σ (IntermediateField.Lifts.union c hc)","decl":"theorem le_union ⦃σ : Lifts F E K⦄ (hσ : σ ∈ c) : σ ≤ union c hc :=\n  have hσ := Set.mem_insert_of_mem ⊥ hσ\n  let t (i : ↑(insert ⊥ c)) := i.val.carrier\n  ⟨le_iSup t ⟨σ, hσ⟩, fun x ↦ by\n    dsimp only [union, AlgHom.comp_apply]\n    exact Subalgebra.iSupLift_inclusion (K := (toSubalgebra <| t ·))\n      (i := ⟨σ, hσ⟩) x (le_iSup (toSubalgebra <| t ·) ⟨σ, hσ⟩)⟩\n\n"}
{"name":"IntermediateField.Lifts.carrier_union","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nc : Set (IntermediateField.Lifts F E K)\nhc : IsChain (fun x1 x2 => LE.le x1 x2) c\n⊢ Eq (IntermediateField.Lifts.union c hc).carrier (iSup fun i => (↑i).carrier)","decl":"theorem carrier_union : (union c hc).carrier = ⨆ i : c, i.1.carrier :=\n  le_antisymm (iSup_le <| by rintro ⟨i, rfl|hi⟩; exacts [bot_le, le_iSup_of_le ⟨i, hi⟩ le_rfl]) <|\n    iSup_le fun i ↦ le_iSup_of_le ⟨i, .inr i.2⟩ le_rfl\n\n"}
{"name":"IntermediateField.Lifts.exists_upper_bound","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nc : Set (IntermediateField.Lifts F E K)\nhc : IsChain (fun x1 x2 => LE.le x1 x2) c\n⊢ Exists fun ub => ∀ (a : IntermediateField.Lifts F E K), Membership.mem c a → LE.le a ub","decl":"/-- A chain of lifts has an upper bound. -/\ntheorem exists_upper_bound (c : Set (Lifts F E K)) (hc : IsChain (· ≤ ·) c) :\n    ∃ ub, ∀ a ∈ c, a ≤ ub := ⟨_, le_union c hc⟩\n\n"}
{"name":"IntermediateField.Lifts.union_isExtendible","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field E\ninst✝³ : Field K\ninst✝² : Algebra F E\ninst✝¹ : Algebra F K\nc : Set (IntermediateField.Lifts F E K)\nhc : IsChain (fun x1 x2 => LE.le x1 x2) c\nalg : Algebra.IsAlgebraic F E\ninst✝ : Nonempty ↑c\nhext : ∀ (σ : IntermediateField.Lifts F E K), Membership.mem c σ → σ.IsExtendible\n⊢ (IntermediateField.Lifts.union c hc).IsExtendible","decl":"theorem union_isExtendible [alg : Algebra.IsAlgebraic F E]\n    [Nonempty c] (hext : ∀ σ ∈ c, σ.IsExtendible) :\n    (union c hc).IsExtendible := fun S ↦ by\n  let Ω := adjoin F (S : Set E) →ₐ[F] K\n  have ⟨ω, hω⟩ : ∃ ω : Ω, ∀ π : c, ∃ θ ≥ π.1, ⟨_, ω⟩ ≤ θ ∧ θ.carrier = π.1.1 ⊔ adjoin F S := by\n    by_contra!; choose π hπ using this\n    have := finiteDimensional_adjoin (S := (S : Set E)) fun _ _ ↦ (alg.isIntegral).1 _\n    have ⟨π₀, hπ₀⟩ := hc.directed.finite_le π\n    have ⟨θ, hθπ, hθ⟩ := hext _ π₀.2 S\n    rw [← adjoin_le_iff] at hθ\n    let θ₀ := θ.emb.comp (inclusion hθ)\n    have := (hπ₀ θ₀).trans hθπ\n    exact hπ θ₀ ⟨_, θ.emb.comp <| inclusion <| sup_le this.1 hθ⟩\n      ⟨le_sup_left, this.2⟩ ⟨le_sup_right, fun _ ↦ rfl⟩ rfl\n  choose θ ge hθ eq using hω\n  have : IsChain (· ≤ ·) (Set.range θ) := by\n    simp_rw [← restrictScalars_adjoin_eq_sup, restrictScalars_adjoin] at eq\n    rintro _ ⟨π₁, rfl⟩ _ ⟨π₂, rfl⟩ -\n    wlog h : π₁ ≤ π₂ generalizing π₁ π₂\n    · exact (this _ _ <| (hc.total π₁.2 π₂.2).resolve_left h).symm\n    refine .inl (le_iff.mpr ⟨?_, algHom_ext_of_eq_adjoin _ (eq _) ?_⟩)\n    · rw [eq, eq]; exact adjoin.mono _ _ _ (Set.union_subset_union_left _ h.1)\n    rintro x (hx|hx)\n    · change (θ π₂).emb (inclusion (ge π₂).1 <| inclusion h.1 ⟨x, hx⟩) =\n        (θ π₁).emb (inclusion (ge π₁).1 ⟨x, hx⟩)\n      rw [(ge π₁).2, (ge π₂).2, h.2]\n    · change (θ π₂).emb (inclusion (hθ π₂).1 ⟨x, subset_adjoin _ _ hx⟩) =\n        (θ π₁).emb (inclusion (hθ π₁).1 ⟨x, subset_adjoin _ _ hx⟩)\n      rw [(hθ π₁).2, (hθ π₂).2]\n  refine ⟨union _ this, le_of_carrier_le_iSup (fun π ↦ le_union c hc π.2)\n    (fun π ↦ (ge π).trans <| le_union _ _ ⟨_, rfl⟩) (carrier_union _ _).le, ?_⟩\n  simp_rw [carrier_union, iSup_range', eq]\n  exact (subset_adjoin _ _).trans (SetLike.coe_subset_coe.mpr <|\n    le_sup_right.trans <| le_iSup_of_le (Classical.arbitrary _) le_rfl)\n\n"}
{"name":"IntermediateField.Lifts.nonempty_algHom_of_exist_lifts_finset","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nalg : Algebra.IsAlgebraic F E\nh : ∀ (S : Finset E), Exists fun σ => HasSubset.Subset ↑S ↑σ.carrier\n⊢ Nonempty (AlgHom F E K)","decl":"theorem nonempty_algHom_of_exist_lifts_finset [alg : Algebra.IsAlgebraic F E]\n    (h : ∀ S : Finset E, ∃ σ : Lifts F E K, (S : Set E) ⊆ σ.carrier) :\n    Nonempty (E →ₐ[F] K) := by\n  have : (⊥ : Lifts F E K).IsExtendible := fun S ↦ have ⟨σ, hσ⟩ := h S; ⟨σ, bot_le, hσ⟩\n  have ⟨ϕ, hϕ⟩ := zorn_le₀ {ϕ : Lifts F E K | ϕ.IsExtendible}\n    fun c hext hc ↦ (isEmpty_or_nonempty c).elim\n      (fun _ ↦ ⟨⊥, this, fun ϕ hϕ ↦ isEmptyElim (⟨ϕ, hϕ⟩ : c)⟩)\n      fun _ ↦ ⟨_, union_isExtendible c hc hext, le_union c hc⟩\n  suffices ϕ.carrier = ⊤ from ⟨ϕ.emb.comp <| ((equivOfEq this).trans topEquiv).symm⟩\n  by_contra!\n  obtain ⟨α, -, hα⟩ := SetLike.exists_of_lt this.lt_top\n  let _ : Algebra ϕ.carrier K := ϕ.emb.toAlgebra\n  let Λ := ϕ.carrier⟮α⟯ →ₐ[ϕ.carrier] K\n  have := finiteDimensional_adjoin (S := {α}) fun _ _ ↦ ((alg.tower_top ϕ.carrier).isIntegral).1 _\n  let L (σ : Λ) : Lifts F E K := ⟨ϕ.carrier⟮α⟯.restrictScalars F, σ.restrictScalars F⟩\n  have hL (σ : Λ) : ϕ < L σ := lt_iff.mpr\n    ⟨by simpa only [L, restrictScalars_adjoin_eq_sup, left_lt_sup, adjoin_simple_le_iff],\n      AlgHom.coe_ringHom_injective σ.comp_algebraMap⟩\n  have ⟨(ϕ_ext : ϕ.IsExtendible), ϕ_max⟩ := maximal_iff_forall_gt.mp hϕ\n  simp_rw [Set.mem_setOf, IsExtendible] at ϕ_max; push_neg at ϕ_max\n  choose S hS using fun σ : Λ ↦ ϕ_max (hL σ)\n  classical\n  have ⟨θ, hθϕ, hθ⟩ := ϕ_ext ({α} ∪ Finset.univ.biUnion S)\n  simp_rw [Finset.coe_union, Set.union_subset_iff, Finset.coe_singleton, Set.singleton_subset_iff,\n    Finset.coe_biUnion, Finset.coe_univ, Set.mem_univ, Set.iUnion_true, Set.iUnion_subset_iff] at hθ\n  have : ϕ.carrier⟮α⟯.restrictScalars F ≤ θ.carrier := by\n    rw [restrictScalars_adjoin_eq_sup, sup_le_iff, adjoin_simple_le_iff]; exact ⟨hθϕ.1, hθ.1⟩\n  exact hS ⟨(θ.emb.comp <| inclusion this).toRingHom, hθϕ.2⟩ θ ⟨this, fun _ ↦ rfl⟩ (hθ.2 _)\n\n"}
{"name":"IntermediateField.Lifts.exists_lift_of_splits'","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nx : IntermediateField.Lifts F E K\ns : E\nh1 : IsIntegral (Subtype fun x_1 => Membership.mem x.carrier x_1) s\nh2 : Polynomial.Splits x.emb.toRingHom (minpoly (Subtype fun x_1 => Membership.mem x.carrier x_1) s)\n⊢ Exists fun y => And (LE.le x y) (Membership.mem y.carrier s)","decl":"/-- Given a lift `x` and an integral element `s : E` over `x.carrier` whose conjugates over\n`x.carrier` are all in `K`, we can extend the lift to a lift whose carrier contains `s`. -/\ntheorem exists_lift_of_splits' (x : Lifts F E K) {s : E} (h1 : IsIntegral x.carrier s)\n    (h2 : (minpoly x.carrier s).Splits x.emb.toRingHom) : ∃ y, x ≤ y ∧ s ∈ y.carrier :=\n  have I2 := (minpoly.degree_pos h1).ne'\n  letI : Algebra x.carrier K := x.emb.toRingHom.toAlgebra\n  let carrier := x.carrier⟮s⟯.restrictScalars F\n  letI : Algebra x.carrier carrier := x.carrier⟮s⟯.toSubalgebra.algebra\n  let φ : carrier →ₐ[x.carrier] K := ((algHomAdjoinIntegralEquiv x.carrier h1).symm\n    ⟨rootOfSplits x.emb.toRingHom h2 I2, by\n      rw [mem_aroots, and_iff_right (minpoly.ne_zero h1)]\n      exact map_rootOfSplits x.emb.toRingHom h2 I2⟩)\n  ⟨⟨carrier, (@algHomEquivSigma F x.carrier carrier K _ _ _ _ _ _ _ _\n      (IsScalarTower.of_algebraMap_eq fun _ ↦ rfl)).symm ⟨x.emb, φ⟩⟩,\n    ⟨fun z hz ↦ algebraMap_mem x.carrier⟮s⟯ ⟨z, hz⟩, φ.commutes⟩,\n    mem_adjoin_simple_self x.carrier s⟩\n\n"}
{"name":"IntermediateField.Lifts.exists_lift_of_splits","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nx : IntermediateField.Lifts F E K\ns : E\nh1 : IsIntegral F s\nh2 : Polynomial.Splits (algebraMap F K) (minpoly F s)\n⊢ Exists fun y => And (LE.le x y) (Membership.mem y.carrier s)","decl":"/-- Given an integral element `s : E` over `F` whose `F`-conjugates are all in `K`,\nany lift can be extended to one whose carrier contains `s`. -/\ntheorem exists_lift_of_splits (x : Lifts F E K) {s : E} (h1 : IsIntegral F s)\n    (h2 : (minpoly F s).Splits (algebraMap F K)) : ∃ y, x ≤ y ∧ s ∈ y.carrier :=\n  exists_lift_of_splits' x h1.tower_top <| h1.minpoly_splits_tower_top' <| by\n    rwa [← x.emb.comp_algebraMap] at h2\n\n"}
{"name":"IntermediateField.exists_algHom_adjoin_of_splits'","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁸ : Field F\ninst✝⁷ : Field E\ninst✝⁶ : Field K\ninst✝⁵ : Algebra F E\ninst✝⁴ : Algebra F K\nS : Set E\nL : Type u_4\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nf : AlgHom F L K\nhK : ∀ (s : E), Membership.mem S s → And (IsIntegral L s) (Polynomial.Splits f.toRingHom (minpoly L s))\n⊢ Exists fun φ => Eq (AlgHom.restrictDomain L φ) f","decl":"include hK in\ntheorem exists_algHom_adjoin_of_splits' :\n    ∃ φ : adjoin L S →ₐ[F] K, φ.restrictDomain L = f := by\n  let L' := (IsScalarTower.toAlgHom F L E).fieldRange\n  let f' : L' →ₐ[F] K := f.comp (AlgEquiv.ofInjectiveField _).symm.toAlgHom\n  have := exists_algHom_adjoin_of_splits'' f' (S := S) fun s hs ↦ ?_\n  · obtain ⟨φ, hφ⟩ := this; refine ⟨φ.comp <|\n      inclusion (?_ : (adjoin L S).restrictScalars F ≤ (adjoin L' S).restrictScalars F), ?_⟩\n    · simp_rw [← SetLike.coe_subset_coe, coe_restrictScalars, adjoin_subset_adjoin_iff]\n      exact ⟨subset_adjoin_of_subset_left S (F := L'.toSubfield) le_rfl, subset_adjoin _ _⟩\n    · ext x\n      exact congr($hφ _).trans (congr_arg f <| AlgEquiv.symm_apply_apply _ _)\n  letI : Algebra L L' := (AlgEquiv.ofInjectiveField _).toRingHom.toAlgebra\n  have : IsScalarTower L L' E := IsScalarTower.of_algebraMap_eq' rfl\n  refine ⟨(hK s hs).1.tower_top, (hK s hs).1.minpoly_splits_tower_top' ?_⟩\n  convert (hK s hs).2; ext; exact congr_arg f (AlgEquiv.symm_apply_apply _ _)\n\n"}
{"name":"IntermediateField.exists_algHom_of_adjoin_splits'","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁸ : Field F\ninst✝⁷ : Field E\ninst✝⁶ : Field K\ninst✝⁵ : Algebra F E\ninst✝⁴ : Algebra F K\nS : Set E\nL : Type u_4\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nf : AlgHom F L K\nhK : ∀ (s : E), Membership.mem S s → And (IsIntegral L s) (Polynomial.Splits f.toRingHom (minpoly L s))\nhS : Eq (IntermediateField.adjoin L S) Top.top\n⊢ Exists fun φ => Eq (AlgHom.restrictDomain L φ) f","decl":"include hK in\ntheorem exists_algHom_of_adjoin_splits' (hS : adjoin L S = ⊤) :\n    ∃ φ : E →ₐ[F] K, φ.restrictDomain L = f :=\n  have ⟨φ, hφ⟩ := exists_algHom_adjoin_of_splits' f hK\n  ⟨φ.comp (((equivOfEq hS).trans topEquiv).symm.toAlgHom.restrictScalars F), hφ⟩\n\n"}
{"name":"IntermediateField.exists_algHom_of_splits'","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁸ : Field F\ninst✝⁷ : Field E\ninst✝⁶ : Field K\ninst✝⁵ : Algebra F E\ninst✝⁴ : Algebra F K\nL : Type u_4\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nf : AlgHom F L K\nhK : ∀ (s : E), And (IsIntegral L s) (Polynomial.Splits f.toRingHom (minpoly L s))\n⊢ Exists fun φ => Eq (AlgHom.restrictDomain L φ) f","decl":"theorem exists_algHom_of_splits' (hK : ∀ s : E, IsIntegral L s ∧ (minpoly L s).Splits f.toRingHom) :\n    ∃ φ : E →ₐ[F] K, φ.restrictDomain L = f :=\n  exists_algHom_of_adjoin_splits' f (fun x _ ↦ hK x) (adjoin_univ L E)\n\n"}
{"name":"IntermediateField.exists_algHom_adjoin_of_splits","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nS : Set E\nhK : ∀ (s : E), Membership.mem S s → And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\nL : IntermediateField F E\nf : AlgHom F (Subtype fun x => Membership.mem L x) K\nhL : LE.le L (IntermediateField.adjoin F S)\n⊢ Exists fun φ => Eq (φ.comp (IntermediateField.inclusion hL)) f","decl":"theorem exists_algHom_adjoin_of_splits : ∃ φ : adjoin F S →ₐ[F] K, φ.comp (inclusion hL) = f := by\n  obtain ⟨φ, hfφ, hφ⟩ := zorn_le_nonempty_Ici₀ _\n    (fun c _ hc _ _ ↦ Lifts.exists_upper_bound c hc) ⟨L, f⟩ le_rfl\n  refine ⟨φ.emb.comp (inclusion <| adjoin_le_iff.mpr fun s hs ↦ ?_), ?_⟩\n  · rcases φ.exists_lift_of_splits (hK s hs).1 (hK s hs).2 with ⟨y, h1, h2⟩\n    exact (hφ h1).1 h2\n  · ext; apply hfφ.2\n\n"}
{"name":"IntermediateField.nonempty_algHom_adjoin_of_splits","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nS : Set E\nhK : ∀ (s : E), Membership.mem S s → And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\n⊢ Nonempty (AlgHom F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x) K)","decl":"theorem nonempty_algHom_adjoin_of_splits : Nonempty (adjoin F S →ₐ[F] K) :=\n  have ⟨φ, _⟩ := exists_algHom_adjoin_of_splits hK (⊥ : Lifts F E K).emb bot_le; ⟨φ⟩\n\n"}
{"name":"IntermediateField.exists_algHom_of_adjoin_splits","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nS : Set E\nhK : ∀ (s : E), Membership.mem S s → And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\nL : IntermediateField F E\nf : AlgHom F (Subtype fun x => Membership.mem L x) K\nhS : Eq (IntermediateField.adjoin F S) Top.top\n⊢ Exists fun φ => Eq (φ.comp L.val) f","decl":"include hS in\ntheorem exists_algHom_of_adjoin_splits : ∃ φ : E →ₐ[F] K, φ.comp L.val = f :=\n  have ⟨φ, hφ⟩ := exists_algHom_adjoin_of_splits hK f (hS.symm ▸ le_top)\n  ⟨φ.comp ((equivOfEq hS).trans topEquiv).symm.toAlgHom, hφ⟩\n\n"}
{"name":"IntermediateField.nonempty_algHom_of_adjoin_splits","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nS : Set E\nhK : ∀ (s : E), Membership.mem S s → And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\nhS : Eq (IntermediateField.adjoin F S) Top.top\n⊢ Nonempty (AlgHom F E K)","decl":"include hS in\ntheorem nonempty_algHom_of_adjoin_splits : Nonempty (E →ₐ[F] K) :=\n  have ⟨φ, _⟩ := exists_algHom_of_adjoin_splits hK (⊥ : Lifts F E K).emb hS; ⟨φ⟩\n\n"}
{"name":"IntermediateField.exists_algHom_adjoin_of_splits_of_aeval","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nS : Set E\nhK : ∀ (s : E), Membership.mem S s → And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\nx : E\ny : K\nhx : Membership.mem (IntermediateField.adjoin F S) x\nhy : Eq ((Polynomial.aeval y) (minpoly F x)) 0\n⊢ Exists fun φ => Eq (φ ⟨x, hx⟩) y","decl":"theorem exists_algHom_adjoin_of_splits_of_aeval : ∃ φ : adjoin F S →ₐ[F] K, φ ⟨x, hx⟩ = y := by\n  have := isAlgebraic_adjoin (fun s hs ↦ (hK s hs).1)\n  have ix : IsAlgebraic F _ := Algebra.IsAlgebraic.isAlgebraic (⟨x, hx⟩ : adjoin F S)\n  rw [isAlgebraic_iff_isIntegral, isIntegral_iff] at ix\n  obtain ⟨φ, hφ⟩ := exists_algHom_adjoin_of_splits hK ((algHomAdjoinIntegralEquiv F ix).symm\n    ⟨y, mem_aroots.mpr ⟨minpoly.ne_zero ix, hy⟩⟩) (adjoin_simple_le_iff.mpr hx)\n  exact ⟨φ, (DFunLike.congr_fun hφ <| AdjoinSimple.gen F x).trans <|\n    algHomAdjoinIntegralEquiv_symm_apply_gen F ix _⟩\n\n"}
{"name":"IntermediateField.exists_algHom_of_adjoin_splits_of_aeval","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nS : Set E\nhK : ∀ (s : E), Membership.mem S s → And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\nx : E\ny : K\nhS : Eq (IntermediateField.adjoin F S) Top.top\nhy : Eq ((Polynomial.aeval y) (minpoly F x)) 0\n⊢ Exists fun φ => Eq (φ x) y","decl":"include hS in\ntheorem exists_algHom_of_adjoin_splits_of_aeval : ∃ φ : E →ₐ[F] K, φ x = y :=\n  have ⟨φ, hφ⟩ := exists_algHom_adjoin_of_splits_of_aeval hK (hS ▸ mem_top) hy\n  ⟨φ.comp ((equivOfEq hS).trans topEquiv).symm.toAlgHom, hφ⟩\n\n\n"}
{"name":"IntermediateField.exists_algHom_of_splits","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nhK' : ∀ (s : E), And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\nL : IntermediateField F E\nf : AlgHom F (Subtype fun x => Membership.mem L x) K\n⊢ Exists fun φ => Eq (φ.comp L.val) f","decl":"theorem exists_algHom_of_splits : ∃ φ : E →ₐ[F] K, φ.comp L.val = f :=\n  exists_algHom_of_adjoin_splits (fun x _ ↦ hK' x) f (adjoin_univ F E)\n\n"}
{"name":"IntermediateField.nonempty_algHom_of_splits","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nhK' : ∀ (s : E), And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\n⊢ Nonempty (AlgHom F E K)","decl":"theorem nonempty_algHom_of_splits : Nonempty (E →ₐ[F] K) :=\n  nonempty_algHom_of_adjoin_splits (fun x _ ↦ hK' x) (adjoin_univ F E)\n\n"}
{"name":"IntermediateField.exists_algHom_of_splits_of_aeval","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nhK' : ∀ (s : E), And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\nx : E\ny : K\nhy : Eq ((Polynomial.aeval y) (minpoly F x)) 0\n⊢ Exists fun φ => Eq (φ x) y","decl":"theorem exists_algHom_of_splits_of_aeval (hy : aeval y (minpoly F x) = 0) :\n    ∃ φ : E →ₐ[F] K, φ x = y :=\n  exists_algHom_of_adjoin_splits_of_aeval (fun x _ ↦ hK' x) (adjoin_univ F E) hy\n\n"}
{"name":"Algebra.IsAlgebraic.range_eval_eq_rootSet_minpoly_of_splits","module":"Mathlib.FieldTheory.Extension","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra F K\nhA : ∀ (x : K), Polynomial.Splits (algebraMap F L) (minpoly F x)\ninst✝ : Algebra.IsAlgebraic F K\nx : K\n⊢ Eq (Set.range fun ψ => ψ x) ((minpoly F x).rootSet L)","decl":"/-- Let `K/F` be an algebraic extension of fields and `L` a field in which all the minimal\npolynomial over `F` of elements of `K` splits. Then, for `x ∈ K`, the images of `x` by the\n`F`-algebra morphisms from `K` to `L` are exactly the roots in `L` of the minimal polynomial\nof `x` over `F`. -/\ntheorem Algebra.IsAlgebraic.range_eval_eq_rootSet_minpoly_of_splits {F K : Type*} (L : Type*)\n    [Field F] [Field K] [Field L] [Algebra F L] [Algebra F K]\n    (hA : ∀ x : K, (minpoly F x).Splits (algebraMap F L))\n    [Algebra.IsAlgebraic F K] (x : K) :\n    (Set.range fun (ψ : K →ₐ[F] L) => ψ x) = (minpoly F x).rootSet L := by\n  ext a\n  rw [mem_rootSet_of_ne (minpoly.ne_zero (Algebra.IsIntegral.isIntegral x))]\n  refine ⟨fun ⟨ψ, hψ⟩ ↦ ?_, fun ha ↦ IntermediateField.exists_algHom_of_splits_of_aeval\n    (fun x ↦ ⟨Algebra.IsIntegral.isIntegral x, hA x⟩) ha⟩\n  rw [← hψ, Polynomial.aeval_algHom_apply ψ x, minpoly.aeval, map_zero]\n\n"}
