{"name":"threeAPFree_frontier","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : AddCommMonoid E\ninstâœ : Module ğ•œ E\ns : Set E\nhsâ‚€ : IsClosed s\nhsâ‚ : StrictConvex ğ•œ s\nâŠ¢ ThreeAPFree (frontier s)","decl":"/-- The frontier of a closed strictly convex set only contains trivial arithmetic progressions.\nThe idea is that an arithmetic progression is contained on a line and the frontier of a strictly\nconvex set does not contain lines. -/\nlemma threeAPFree_frontier {ğ•œ E : Type*} [LinearOrderedField ğ•œ] [TopologicalSpace E]\n    [AddCommMonoid E] [Module ğ•œ E] {s : Set E} (hsâ‚€ : IsClosed s) (hsâ‚ : StrictConvex ğ•œ s) :\n    ThreeAPFree (frontier s) := by\n  intro a ha b hb c hc habc\n  obtain rfl : (1 / 2 : ğ•œ) â€¢ a + (1 / 2 : ğ•œ) â€¢ c = b := by\n    rwa [â† smul_add, one_div, inv_smul_eq_iffâ‚€ (show (2 : ğ•œ) â‰  0 by norm_num), two_smul]\n  have :=\n    hsâ‚.eq (hsâ‚€.frontier_subset ha) (hsâ‚€.frontier_subset hc) one_half_pos one_half_pos\n      (add_halves _) hb.2\n  simp [this, â† add_smul]\n  ring_nf\n  simp\n\n"}
{"name":"threeAPFree_sphere","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : StrictConvexSpace Real E\nx : E\nr : Real\nâŠ¢ ThreeAPFree (Metric.sphere x r)","decl":"lemma threeAPFree_sphere {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [StrictConvexSpace â„ E] (x : E) (r : â„) : ThreeAPFree (sphere x r) := by\n  obtain rfl | hr := eq_or_ne r 0\n  Â· rw [sphere_zero]\n    exact threeAPFree_singleton _\n  Â· convert threeAPFree_frontier isClosed_ball (strictConvex_closedBall â„ x r)\n    exact (frontier_closedBall _ hr).symm\n\n"}
{"name":"Behrend.mem_box","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nx : Fin n â†’ Nat\nâŠ¢ Iff (Membership.mem (Behrend.box n d) x) (âˆ€ (i : Fin n), LT.lt (x i) d)","decl":"theorem mem_box : x âˆˆ box n d â†” âˆ€ i, x i < d := by simp only [box, Fintype.mem_piFinset, mem_range]\n\n"}
{"name":"Behrend.card_box","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nâŠ¢ Eq (Behrend.box n d).card (HPow.hPow d n)","decl":"@[simp]\ntheorem card_box : #(box n d) = d ^ n := by simp [box]\n\n"}
{"name":"Behrend.box_zero","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n : Nat\nâŠ¢ Eq (Behrend.box (HAdd.hAdd n 1) 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem box_zero : box (n + 1) 0 = âˆ… := by simp [box]\n\n"}
{"name":"Behrend.sphere_zero_subset","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nâŠ¢ HasSubset.Subset (Behrend.sphere n d 0) 0","decl":"theorem sphere_zero_subset : sphere n d 0 âŠ† 0 := fun x => by simp [sphere, funext_iff]\n\n"}
{"name":"Behrend.sphere_zero_right","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n k : Nat\nâŠ¢ Eq (Behrend.sphere (HAdd.hAdd n 1) 0 k) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sphere_zero_right (n k : â„•) : sphere (n + 1) 0 k = âˆ… := by simp [sphere]\n\n"}
{"name":"Behrend.sphere_subset_box","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d k : Nat\nâŠ¢ HasSubset.Subset (Behrend.sphere n d k) (Behrend.box n d)","decl":"theorem sphere_subset_box : sphere n d k âŠ† box n d :=\n  filter_subset _ _\n\n"}
{"name":"Behrend.norm_of_mem_sphere","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d k : Nat\nx : Fin n â†’ Nat\nhx : Membership.mem (Behrend.sphere n d k) x\nâŠ¢ Eq (Norm.norm ((WithLp.equiv 2 (Fin n â†’ Real)).symm (Function.comp Nat.cast x))) (â†‘k).sqrt","decl":"theorem norm_of_mem_sphere {x : Fin n â†’ â„•} (hx : x âˆˆ sphere n d k) :\n    â€–(WithLp.equiv 2 _).symm ((â†‘) âˆ˜ x : Fin n â†’ â„)â€– = âˆšâ†‘k := by\n  rw [EuclideanSpace.norm_eq]\n  dsimp\n  simp_rw [abs_cast, â† cast_pow, â† cast_sum, (mem_filter.1 hx).2]\n\n"}
{"name":"Behrend.sphere_subset_preimage_metric_sphere","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d k : Nat\nâŠ¢ HasSubset.Subset (â†‘(Behrend.sphere n d k)) (Set.preimage (fun x => (WithLp.equiv 2 (Fin n â†’ Real)).symm (Function.comp Nat.cast x)) (Metric.sphere 0 (â†‘k).sqrt))","decl":"theorem sphere_subset_preimage_metric_sphere : (sphere n d k : Set (Fin n â†’ â„•)) âŠ†\n    (fun x : Fin n â†’ â„• => (WithLp.equiv 2 _).symm ((â†‘) âˆ˜ x : Fin n â†’ â„)) â»Â¹'\n      Metric.sphere (0 : PiLp 2 fun _ : Fin n => â„) (âˆšâ†‘k) :=\n  fun x hx => by rw [Set.mem_preimage, mem_sphere_zero_iff_norm, norm_of_mem_sphere hx]\n\n"}
{"name":"Behrend.map_apply","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\na : Fin n â†’ Nat\nâŠ¢ Eq ((Behrend.map d) a) (Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow d â†‘i))","decl":"/-- The map that appears in Behrend's bound on Roth numbers. -/\n@[simps]\ndef map (d : â„•) : (Fin n â†’ â„•) â†’+ â„• where\n  toFun a := âˆ‘ i, a i * d ^ (i : â„•)\n  map_zero' := by simp_rw [Pi.zero_apply, zero_mul, sum_const_zero]\n  map_add' a b := by simp_rw [Pi.add_apply, add_mul, sum_add_distrib]\n\n"}
{"name":"Behrend.map_zero","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"d : Nat\na : Fin 0 â†’ Nat\nâŠ¢ Eq ((Behrend.map d) a) 0","decl":"theorem map_zero (d : â„•) (a : Fin 0 â†’ â„•) : map d a = 0 := by simp [map]\n\n"}
{"name":"Behrend.map_succ","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\na : Fin (HAdd.hAdd n 1) â†’ Nat\nâŠ¢ Eq ((Behrend.map d) a) (HAdd.hAdd (a 0) (HMul.hMul (Finset.univ.sum fun x => HMul.hMul (a x.succ) (HPow.hPow d â†‘x)) d))","decl":"theorem map_succ (a : Fin (n + 1) â†’ â„•) :\n    map d a = a 0 + (âˆ‘ x : Fin n, a x.succ * d ^ (x : â„•)) * d := by\n  simp [map, Fin.sum_univ_succ, _root_.pow_succ, â† mul_assoc, â† sum_mul]\n\n"}
{"name":"Behrend.map_succ'","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\na : Fin (HAdd.hAdd n 1) â†’ Nat\nâŠ¢ Eq ((Behrend.map d) a) (HAdd.hAdd (a 0) (HMul.hMul ((Behrend.map d) (Function.comp a Fin.succ)) d))","decl":"theorem map_succ' (a : Fin (n + 1) â†’ â„•) : map d a = a 0 + map d (a âˆ˜ Fin.succ) * d :=\n  map_succ _\n\n"}
{"name":"Behrend.map_monotone","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nâŠ¢ Monotone â‡‘(Behrend.map d)","decl":"theorem map_monotone (d : â„•) : Monotone (map d : (Fin n â†’ â„•) â†’ â„•) := fun x y h => by\n  dsimp; exact sum_le_sum fun i _ => Nat.mul_le_mul_right _ <| h i\n\n"}
{"name":"Behrend.map_mod","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\na : Fin n.succ â†’ Nat\nâŠ¢ Eq (HMod.hMod ((Behrend.map d) a) d) (HMod.hMod (a 0) d)","decl":"theorem map_mod (a : Fin n.succ â†’ â„•) : map d a % d = a 0 % d := by\n  rw [map_succ, Nat.add_mul_mod_self_right]\n\n"}
{"name":"Behrend.map_eq_iff","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nxâ‚ xâ‚‚ : Fin n.succ â†’ Nat\nhxâ‚ : âˆ€ (i : Fin n.succ), LT.lt (xâ‚ i) d\nhxâ‚‚ : âˆ€ (i : Fin n.succ), LT.lt (xâ‚‚ i) d\nâŠ¢ Iff (Eq ((Behrend.map d) xâ‚) ((Behrend.map d) xâ‚‚)) (And (Eq (xâ‚ 0) (xâ‚‚ 0)) (Eq ((Behrend.map d) (Function.comp xâ‚ Fin.succ)) ((Behrend.map d) (Function.comp xâ‚‚ Fin.succ))))","decl":"theorem map_eq_iff {xâ‚ xâ‚‚ : Fin n.succ â†’ â„•} (hxâ‚ : âˆ€ i, xâ‚ i < d) (hxâ‚‚ : âˆ€ i, xâ‚‚ i < d) :\n    map d xâ‚ = map d xâ‚‚ â†” xâ‚ 0 = xâ‚‚ 0 âˆ§ map d (xâ‚ âˆ˜ Fin.succ) = map d (xâ‚‚ âˆ˜ Fin.succ) := by\n  refine âŸ¨fun h => ?_, fun h => by rw [map_succ', map_succ', h.1, h.2]âŸ©\n  have : xâ‚ 0 = xâ‚‚ 0 := by\n    rw [â† mod_eq_of_lt (hxâ‚ _), â† map_mod, â† mod_eq_of_lt (hxâ‚‚ _), â† map_mod, h]\n  rw [map_succ, map_succ, this, add_right_inj, mul_eq_mul_right_iff] at h\n  exact âŸ¨this, h.resolve_right (pos_of_gt (hxâ‚ 0)).ne'âŸ©\n\n"}
{"name":"Behrend.map_injOn","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nâŠ¢ Set.InjOn (â‡‘(Behrend.map d)) (setOf fun x => âˆ€ (i : Fin n), LT.lt (x i) d)","decl":"theorem map_injOn : {x : Fin n â†’ â„• | âˆ€ i, x i < d}.InjOn (map d) := by\n  intro xâ‚ hxâ‚ xâ‚‚ hxâ‚‚ h\n  induction' n with n ih\n  Â· simp [eq_iff_true_of_subsingleton]\n  ext i\n  have x := (map_eq_iff hxâ‚ hxâ‚‚).1 h\n  refine Fin.cases x.1 (congr_fun <| ih (fun _ => ?_) (fun _ => ?_) x.2) i\n  Â· exact hxâ‚ _\n  Â· exact hxâ‚‚ _\n\n"}
{"name":"Behrend.map_le_of_mem_box","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nx : Fin n â†’ Nat\nhx : Membership.mem (Behrend.box n d) x\nâŠ¢ LE.le ((Behrend.map (HSub.hSub (HMul.hMul 2 d) 1)) x) (Finset.univ.sum fun i => HMul.hMul (HSub.hSub d 1) (HPow.hPow (HSub.hSub (HMul.hMul 2 d) 1) â†‘i))","decl":"theorem map_le_of_mem_box (hx : x âˆˆ box n d) :\n    map (2 * d - 1) x â‰¤ âˆ‘ i : Fin n, (d - 1) * (2 * d - 1) ^ (i : â„•) :=\n  map_monotone (2 * d - 1) fun _ => Nat.le_sub_one_of_lt <| mem_box.1 hx _\n\n"}
{"name":"Behrend.threeAPFree_sphere","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d k : Nat\nâŠ¢ ThreeAPFree â†‘(Behrend.sphere n d k)","decl":"nonrec theorem threeAPFree_sphere : ThreeAPFree (sphere n d k : Set (Fin n â†’ â„•)) := by\n  set f : (Fin n â†’ â„•) â†’+ EuclideanSpace â„ (Fin n) :=\n    { toFun := fun f => ((â†‘) : â„• â†’ â„) âˆ˜ f\n      map_zero' := funext fun _ => cast_zero\n      map_add' := fun _ _ => funext fun _ => cast_add _ _ }\n  refine ThreeAPFree.of_image (AddMonoidHomClass.isAddFreimanHom f (Set.mapsTo_image _ _))\n    cast_injective.comp_left.injOn (Set.subset_univ _) ?_\n  refine (threeAPFree_sphere 0 (âˆšâ†‘k)).mono (Set.image_subset_iff.2 fun x => ?_)\n  rw [Set.mem_preimage, mem_sphere_zero_iff_norm]\n  exact norm_of_mem_sphere\n\n"}
{"name":"Behrend.threeAPFree_image_sphere","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d k : Nat\nâŠ¢ ThreeAPFree â†‘(Finset.image (â‡‘(Behrend.map (HSub.hSub (HMul.hMul 2 d) 1))) (Behrend.sphere n d k))","decl":"theorem threeAPFree_image_sphere :\n    ThreeAPFree ((sphere n d k).image (map (2 * d - 1)) : Set â„•) := by\n  rw [coe_image]\n  apply ThreeAPFree.image' (Î± := Fin n â†’ â„•) (Î² := â„•) (s := sphere n d k) (map (2 * d - 1))\n    (map_injOn.mono _) threeAPFree_sphere\n  rw [Set.add_subset_iff]\n  rintro a ha b hb i\n  have hai := mem_box.1 (sphere_subset_box ha) i\n  have hbi := mem_box.1 (sphere_subset_box hb) i\n  rw [lt_tsub_iff_right, â† succ_le_iff, two_mul]\n  exact (add_add_add_comm _ _ 1 1).trans_le (_root_.add_le_add hai hbi)\n\n"}
{"name":"Behrend.sum_sq_le_of_mem_box","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nx : Fin n â†’ Nat\nhx : Membership.mem (Behrend.box n d) x\nâŠ¢ LE.le (Finset.univ.sum fun i => HPow.hPow (x i) 2) (HMul.hMul n (HPow.hPow (HSub.hSub d 1) 2))","decl":"theorem sum_sq_le_of_mem_box (hx : x âˆˆ box n d) : âˆ‘ i : Fin n, x i ^ 2 â‰¤ n * (d - 1) ^ 2 := by\n  rw [mem_box] at hx\n  have : âˆ€ i, x i ^ 2 â‰¤ (d - 1) ^ 2 := fun i =>\n    Nat.pow_le_pow_left (Nat.le_sub_one_of_lt (hx i)) _\n  exact (sum_le_card_nsmul univ _ _ fun i _ => this i).trans (by rw [card_fin, smul_eq_mul])\n\n"}
{"name":"Behrend.sum_eq","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nâŠ¢ Eq (Finset.univ.sum fun i => HMul.hMul d (HPow.hPow (HAdd.hAdd (HMul.hMul 2 d) 1) â†‘i)) (HDiv.hDiv (HSub.hSub (HPow.hPow (HAdd.hAdd (HMul.hMul 2 d) 1) n) 1) 2)","decl":"theorem sum_eq : (âˆ‘ i : Fin n, d * (2 * d + 1) ^ (i : â„•)) = ((2 * d + 1) ^ n - 1) / 2 := by\n  refine (Nat.div_eq_of_eq_mul_left zero_lt_two ?_).symm\n  rw [â† sum_range fun i => d * (2 * d + 1) ^ (i : â„•), â† mul_sum, mul_right_comm, mul_comm d, â†\n    geom_sum_mul_add, add_tsub_cancel_right, mul_comm]\n\n"}
{"name":"Behrend.sum_lt","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nâŠ¢ LT.lt (Finset.univ.sum fun i => HMul.hMul d (HPow.hPow (HAdd.hAdd (HMul.hMul 2 d) 1) â†‘i)) (HPow.hPow (HAdd.hAdd (HMul.hMul 2 d) 1) n)","decl":"theorem sum_lt : (âˆ‘ i : Fin n, d * (2 * d + 1) ^ (i : â„•)) < (2 * d + 1) ^ n :=\n  sum_eq.trans_lt <| (Nat.div_le_self _ 2).trans_lt <| pred_lt (pow_pos (succ_pos _) _).ne'\n\n"}
{"name":"Behrend.card_sphere_le_rothNumberNat","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d k : Nat\nâŠ¢ LE.le (Behrend.sphere n d k).card (rothNumberNat (HPow.hPow (HSub.hSub (HMul.hMul 2 d) 1) n))","decl":"theorem card_sphere_le_rothNumberNat (n d k : â„•) :\n    #(sphere n d k) â‰¤ rothNumberNat ((2 * d - 1) ^ n) := by\n  cases n\n  Â· dsimp; refine (card_le_univ _).trans_eq ?_; rfl\n  cases d\n  Â· simp\n  apply threeAPFree_image_sphere.le_rothNumberNat _ _ (card_image_of_injOn _)\n  Â· simp only [subset_iff, mem_image, and_imp, forall_exists_index, mem_range,\n      forall_apply_eq_imp_iffâ‚‚, sphere, mem_filter]\n    rintro _ x hx _ rfl\n    exact (map_le_of_mem_box hx).trans_lt sum_lt\n  apply map_injOn.mono fun x => ?_\n  simp only [mem_coe, sphere, mem_filter, mem_box, and_imp, two_mul]\n  exact fun h _ i => (h i).trans_le le_self_add\n\n"}
{"name":"Behrend.exists_large_sphere_aux","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nâŠ¢ Exists fun k => And (Membership.mem (Finset.range (HAdd.hAdd (HMul.hMul n (HPow.hPow (HSub.hSub d 1) 2)) 1)) k) (LE.le (HDiv.hDiv (â†‘(HPow.hPow d n)) (HAdd.hAdd (â†‘(HMul.hMul n (HPow.hPow (HSub.hSub d 1) 2))) 1)) â†‘(Behrend.sphere n d k).card)","decl":"theorem exists_large_sphere_aux (n d : â„•) : âˆƒ k âˆˆ range (n * (d - 1) ^ 2 + 1),\n    (â†‘(d ^ n) / ((n * (d - 1) ^ 2 :) + 1) : â„) â‰¤ #(sphere n d k) := by\n  refine exists_le_card_fiber_of_nsmul_le_card_of_maps_to (fun x hx => ?_) nonempty_range_succ ?_\n  Â· rw [mem_range, Nat.lt_succ_iff]\n    exact sum_sq_le_of_mem_box hx\n  Â· rw [card_range, _root_.nsmul_eq_mul, mul_div_assoc', cast_add_one, mul_div_cancel_leftâ‚€,\n      card_box]\n    exact (cast_add_one_pos _).ne'\n\n"}
{"name":"Behrend.exists_large_sphere","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nâŠ¢ Exists fun k => LE.le (HDiv.hDiv â†‘(HPow.hPow d n) â†‘(HMul.hMul n (HPow.hPow d 2))) â†‘(Behrend.sphere n d k).card","decl":"theorem exists_large_sphere (n d : â„•) :\n    âˆƒ k, ((d ^ n :) / (n * d ^ 2 :) : â„) â‰¤ #(sphere n d k) := by\n  obtain âŸ¨k, -, hkâŸ© := exists_large_sphere_aux n d\n  refine âŸ¨k, ?_âŸ©\n  obtain rfl | hn := n.eq_zero_or_pos\n  Â· simp\n  obtain rfl | hd := d.eq_zero_or_pos\n  Â· simp\n  refine (div_le_div_of_nonneg_left ?_ ?_ ?_).trans hk\n  Â· exact cast_nonneg _\n  Â· exact cast_add_one_pos _\n  simp only [â† le_sub_iff_add_le', cast_mul, â† mul_sub, cast_pow, cast_sub hd, sub_sq, one_pow,\n    cast_one, mul_one, sub_add, sub_sub_self]\n  apply one_le_mul_of_one_le_of_one_le\n  Â· rwa [one_le_cast]\n  rw [_root_.le_sub_iff_add_le]\n  norm_num\n  exact one_le_cast.2 hd\n\n"}
{"name":"Behrend.bound_aux'","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nâŠ¢ LE.le (HDiv.hDiv â†‘(HPow.hPow d n) â†‘(HMul.hMul n (HPow.hPow d 2))) â†‘(rothNumberNat (HPow.hPow (HSub.hSub (HMul.hMul 2 d) 1) n))","decl":"theorem bound_aux' (n d : â„•) : ((d ^ n :) / (n * d ^ 2 :) : â„) â‰¤ rothNumberNat ((2 * d - 1) ^ n) :=\n  let âŸ¨_, hâŸ© := exists_large_sphere n d\n  h.trans <| cast_le.2 <| card_sphere_le_rothNumberNat _ _ _\n\n"}
{"name":"Behrend.bound_aux","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"n d : Nat\nhd : Ne d 0\nhn : LE.le 2 n\nâŠ¢ LE.le (HDiv.hDiv (HPow.hPow (â†‘d) (HSub.hSub n 2)) â†‘n) â†‘(rothNumberNat (HPow.hPow (HSub.hSub (HMul.hMul 2 d) 1) n))","decl":"theorem bound_aux (hd : d â‰  0) (hn : 2 â‰¤ n) :\n    (d ^ (n - 2 :) / n : â„) â‰¤ rothNumberNat ((2 * d - 1) ^ n) := by\n  convert bound_aux' n d using 1\n  rw [cast_mul, cast_pow, mul_comm, â† div_div, pow_subâ‚€ _ _ hn, â† div_eq_mul_inv, cast_pow]\n  rwa [cast_ne_zero]\n\n"}
{"name":"Behrend.log_two_mul_two_le_sqrt_log_eight","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"âŠ¢ LE.le (HMul.hMul (Real.log 2) 2) (Real.log 8).sqrt","decl":"theorem log_two_mul_two_le_sqrt_log_eight : log 2 * 2 â‰¤ âˆš(log 8) := by\n  have : (8 : â„) = 2 ^ ((3 : â„•) : â„) := by rw [rpow_natCast]; norm_num\n  rw [this, log_rpow zero_lt_two (3 : â„•)]\n  apply le_sqrt_of_sq_le\n  rw [mul_pow, sq (log 2), mul_assoc, mul_comm]\n  refine mul_le_mul_of_nonneg_right ?_ (log_nonneg one_le_two)\n  rw [â† le_div_iffâ‚€]\n  on_goal 1 => apply log_two_lt_d9.le.trans\n  all_goals norm_num1\n\n"}
{"name":"Behrend.two_div_one_sub_two_div_e_le_eight","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"âŠ¢ LE.le (HDiv.hDiv 2 (HSub.hSub 1 (HDiv.hDiv 2 (Real.exp 1)))) 8","decl":"theorem two_div_one_sub_two_div_e_le_eight : 2 / (1 - 2 / exp 1) â‰¤ 8 := by\n  rw [div_le_iffâ‚€, mul_sub, mul_one, mul_div_assoc', le_sub_comm, div_le_iffâ‚€ (exp_pos _)]\n  Â· linarith [exp_one_gt_d9]\n  rw [sub_pos, div_lt_one] <;> exact exp_one_gt_d9.trans' (by norm_num)\n\n"}
{"name":"Behrend.le_sqrt_log","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nhN : LE.le 4096 N\nâŠ¢ LE.le (HMul.hMul (Real.log (HDiv.hDiv 2 (HSub.hSub 1 (HDiv.hDiv 2 (Real.exp 1))))) (69 / 50)) (Real.log â†‘N).sqrt","decl":"theorem le_sqrt_log (hN : 4096 â‰¤ N) : log (2 / (1 - 2 / exp 1)) * (69 / 50) â‰¤ âˆš(log â†‘N) := by\n  have : (12 : â„•) * log 2 â‰¤ log N := by\n    rw [â† log_rpow zero_lt_two, rpow_natCast]\n    exact log_le_log (by positivity) (mod_cast hN)\n  refine (mul_le_mul_of_nonneg_right (log_le_log ?_ two_div_one_sub_two_div_e_le_eight) <| by\n    norm_num1).trans ?_\n  Â· refine div_pos zero_lt_two ?_\n    rw [sub_pos, div_lt_one (exp_pos _)]\n    exact exp_one_gt_d9.trans_le' (by norm_num1)\n  have l8 : log 8 = (3 : â„•) * log 2 := by\n    rw [â† log_rpow zero_lt_two, rpow_natCast]\n    norm_num\n  rw [l8]\n  apply le_sqrt_of_sq_le (le_trans _ this)\n  rw [mul_right_comm, mul_pow, sq (log 2), â† mul_assoc]\n  apply mul_le_mul_of_nonneg_right _ (log_nonneg one_le_two)\n  rw [â† le_div_iffâ‚€']\n  Â· exact log_two_lt_d9.le.trans (by norm_num1)\n  exact sq_pos_of_ne_zero (by norm_num1)\n\n"}
{"name":"Behrend.exp_neg_two_mul_le","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"x : Real\nhx : LT.lt 0 x\nâŠ¢ LT.lt (Real.exp (HMul.hMul (-2) x)) (HDiv.hDiv (Real.exp (HSub.hSub 2 â†‘(Nat.ceil x))) â†‘(Nat.ceil x))","decl":"theorem exp_neg_two_mul_le {x : â„} (hx : 0 < x) : exp (-2 * x) < exp (2 - âŒˆxâŒ‰â‚Š) / âŒˆxâŒ‰â‚Š := by\n  have hâ‚ := ceil_lt_add_one hx.le\n  have hâ‚‚ : 1 - x â‰¤ 2 - âŒˆxâŒ‰â‚Š := by linarith\n  calc\n    _ â‰¤ exp (1 - x) / (x + 1) := ?_\n    _ â‰¤ exp (2 - âŒˆxâŒ‰â‚Š) / (x + 1) := by gcongr\n    _ < _ := by gcongr\n  rw [le_div_iffâ‚€  (add_pos hx zero_lt_one), â† le_div_iffâ‚€' (exp_pos _), â† exp_sub, neg_mul,\n    sub_neg_eq_add, two_mul, sub_add_add_cancel, add_comm _ x]\n  exact le_trans (le_add_of_nonneg_right zero_le_one) (add_one_le_exp _)\n\n"}
{"name":"Behrend.div_lt_floor","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"x : Real\nhx : LE.le (HDiv.hDiv 2 (HSub.hSub 1 (HDiv.hDiv 2 (Real.exp 1)))) x\nâŠ¢ LT.lt (HDiv.hDiv x (Real.exp 1)) â†‘(Nat.floor (HDiv.hDiv x 2))","decl":"theorem div_lt_floor {x : â„} (hx : 2 / (1 - 2 / exp 1) â‰¤ x) : x / exp 1 < (âŒŠx / 2âŒ‹â‚Š : â„) := by\n  apply lt_of_le_of_lt _ (sub_one_lt_floor _)\n  have : 0 < 1 - 2 / exp 1 := by\n    rw [sub_pos, div_lt_one (exp_pos _)]\n    exact lt_of_le_of_lt (by norm_num) exp_one_gt_d9\n  rwa [le_sub_comm, div_eq_mul_one_div x, div_eq_mul_one_div x, â† mul_sub, div_sub', â†\n    div_eq_mul_one_div, mul_div_assoc', one_le_div, â† div_le_iffâ‚€ this]\n  Â· exact zero_lt_two\n  Â· exact two_ne_zero\n\n"}
{"name":"Behrend.ceil_lt_mul","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"x : Real\nhx : LE.le (50 / 19) x\nâŠ¢ LT.lt (â†‘(Nat.ceil x)) (HMul.hMul 1.38 x)","decl":"theorem ceil_lt_mul {x : â„} (hx : 50 / 19 â‰¤ x) : (âŒˆxâŒ‰â‚Š : â„) < 1.38 * x := by\n  refine (ceil_lt_add_one <| hx.trans' <| by norm_num).trans_le ?_\n  rw [â† le_sub_iff_add_le', â† sub_one_mul]\n  have : (1.38 : â„) = 69 / 50 := by norm_num\n  rwa [this, show (69 / 50 - 1 : â„) = (50 / 19)â»Â¹ by norm_num1, â†\n    div_eq_inv_mul, one_le_div]\n  norm_num1\n\n"}
{"name":"Behrend.nValue_pos","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nhN : LE.le 2 N\nâŠ¢ LT.lt 0 (Behrend.nValue N)","decl":"theorem nValue_pos (hN : 2 â‰¤ N) : 0 < nValue N :=\n  ceil_pos.2 <| Real.sqrt_pos.2 <| log_pos <| one_lt_cast.2 <| hN\n\n"}
{"name":"Behrend.three_le_nValue","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nhN : LE.le 64 N\nâŠ¢ LE.le 3 (Behrend.nValue N)","decl":"theorem three_le_nValue (hN : 64 â‰¤ N) : 3 â‰¤ nValue N := by\n  rw [nValue, â† lt_iff_add_one_le, lt_ceil, cast_two]\n  apply lt_sqrt_of_sq_lt\n  have : (2 : â„) ^ ((6 : â„•) : â„) â‰¤ N := by\n    rw [rpow_natCast]\n    exact (cast_le.2 hN).trans' (by norm_num1)\n  apply lt_of_lt_of_le _ (log_le_log (rpow_pos_of_pos zero_lt_two _) this)\n  rw [log_rpow zero_lt_two, â† div_lt_iffâ‚€']\n  Â· exact log_two_gt_d9.trans_le' (by norm_num1)\n  Â· norm_num1\n\n"}
{"name":"Behrend.dValue_pos","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nhNâ‚ƒ : LE.le 8 N\nâŠ¢ LT.lt 0 (Behrend.dValue N)","decl":"theorem dValue_pos (hNâ‚ƒ : 8 â‰¤ N) : 0 < dValue N := by\n  have hNâ‚€ : 0 < (N : â„) := cast_pos.2 (succ_pos'.trans_le hNâ‚ƒ)\n  rw [dValue, floor_pos, â† log_le_log_iff zero_lt_one, log_one, log_div _ two_ne_zero, log_rpow hNâ‚€,\n    inv_mul_eq_div, sub_nonneg, le_div_iffâ‚€]\n  Â· have : (nValue N : â„) â‰¤ 2 * âˆš(log N) := by\n      apply (ceil_lt_add_one <| sqrt_nonneg _).le.trans\n      rw [two_mul, add_le_add_iff_left]\n      apply le_sqrt_of_sq_le\n      rw [one_pow, le_log_iff_exp_le hNâ‚€]\n      exact (exp_one_lt_d9.le.trans <| by norm_num).trans (cast_le.2 hNâ‚ƒ)\n    apply (mul_le_mul_of_nonneg_left this <| log_nonneg one_le_two).trans _\n    rw [â† mul_assoc, â† le_div_iffâ‚€ (Real.sqrt_pos.2 <| log_pos <| one_lt_cast.2 _), div_sqrt]\n    Â· apply log_two_mul_two_le_sqrt_log_eight.trans\n      apply Real.sqrt_le_sqrt\n      exact log_le_log (by norm_num) (mod_cast hNâ‚ƒ)\n    exact hNâ‚ƒ.trans_lt' (by norm_num)\n  Â· exact cast_pos.2 (nValue_pos <| hNâ‚ƒ.trans' <| by norm_num)\n  Â· exact (rpow_pos_of_pos hNâ‚€ _).ne'\n  Â· exact div_pos (rpow_pos_of_pos hNâ‚€ _) zero_lt_two\n\n"}
{"name":"Behrend.le_N","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nhN : LE.le 2 N\nâŠ¢ LE.le (HPow.hPow (HSub.hSub (HMul.hMul 2 (Behrend.dValue N)) 1) (Behrend.nValue N)) N","decl":"theorem le_N (hN : 2 â‰¤ N) : (2 * dValue N - 1) ^ nValue N â‰¤ N := by\n  have : (2 * dValue N - 1) ^ nValue N â‰¤ (2 * dValue N) ^ nValue N :=\n    Nat.pow_le_pow_left (Nat.sub_le _ _) _\n  apply this.trans\n  suffices ((2 * dValue N) ^ nValue N : â„) â‰¤ N from mod_cast this\n  suffices i : (2 * dValue N : â„) â‰¤ (N : â„) ^ (nValue N : â„)â»Â¹ by\n    rw [â† rpow_natCast]\n    apply (rpow_le_rpow (mul_nonneg zero_le_two (cast_nonneg _)) i (cast_nonneg _)).trans\n    rw [â† rpow_mul (cast_nonneg _), inv_mul_cancelâ‚€, rpow_one]\n    rw [cast_ne_zero]\n    apply (nValue_pos hN).ne'\n  rw [â† le_div_iffâ‚€']\n  Â· exact floor_le (div_nonneg (rpow_nonneg (cast_nonneg _) _) zero_le_two)\n  apply zero_lt_two\n\n"}
{"name":"Behrend.bound","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nhN : LE.le 4096 N\nâŠ¢ LT.lt (HDiv.hDiv (HPow.hPow (â†‘N) (Inv.inv â†‘(Behrend.nValue N))) (Real.exp 1)) â†‘(Behrend.dValue N)","decl":"theorem bound (hN : 4096 â‰¤ N) : (N : â„) ^ (nValue N : â„)â»Â¹ / exp 1 < dValue N := by\n  apply div_lt_floor _\n  rw [â† log_le_log_iff, log_rpow, mul_comm, â† div_eq_mul_inv]\n  Â· apply le_trans _ (div_le_div_of_nonneg_left _ _ (ceil_lt_mul _).le)\n    Â· rw [mul_comm, â† div_div, div_sqrt, le_div_iffâ‚€]\n      Â· norm_num; exact le_sqrt_log hN\n      Â· norm_num1\n    Â· apply log_nonneg\n      rw [one_le_cast]\n      exact hN.trans' (by norm_num1)\n    Â· rw [cast_pos, lt_ceil, cast_zero, Real.sqrt_pos]\n      refine log_pos ?_\n      rw [one_lt_cast]\n      exact hN.trans_lt' (by norm_num1)\n    apply le_sqrt_of_sq_le\n    have : (12 : â„•) * log 2 â‰¤ log N := by\n      rw [â† log_rpow zero_lt_two, rpow_natCast]\n      exact log_le_log (by positivity) (mod_cast hN)\n    refine le_trans ?_ this\n    rw [â† div_le_iffâ‚€']\n    Â· exact log_two_gt_d9.le.trans' (by norm_num1)\n    Â· norm_num1\n  Â· rw [cast_pos]\n    exact hN.trans_lt' (by norm_num1)\n  Â· refine div_pos zero_lt_two ?_\n    rw [sub_pos, div_lt_one (exp_pos _)]\n    exact lt_of_le_of_lt (by norm_num1) exp_one_gt_d9\n  positivity\n\n"}
{"name":"Behrend.roth_lower_bound_explicit","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nhN : LE.le 4096 N\nâŠ¢ LT.lt (HMul.hMul (â†‘N) (Real.exp (HMul.hMul (-4) (Real.log â†‘N).sqrt))) â†‘(rothNumberNat N)","decl":"theorem roth_lower_bound_explicit (hN : 4096 â‰¤ N) :\n    (N : â„) * exp (-4 * âˆš(log N)) < rothNumberNat N := by\n  let n := nValue N\n  have hn : 0 < (n : â„) := cast_pos.2 (nValue_pos <| hN.trans' <| by norm_num1)\n  have hd : 0 < dValue N := dValue_pos (hN.trans' <| by norm_num1)\n  have hNâ‚€ : 0 < (N : â„) := cast_pos.2 (hN.trans' <| by norm_num1)\n  have hnâ‚‚ : 2 < n := three_le_nValue <| hN.trans' <| by norm_num1\n  have : (2 * dValue N - 1) ^ n â‰¤ N := le_N (hN.trans' <| by norm_num1)\n  calc\n    _ â‰¤ (N ^ (nValue N : â„)â»Â¹ / rexp 1 : â„) ^ (n - 2) / n := ?_\n    _ < _ := by gcongr; exacts [(tsub_pos_of_lt hnâ‚‚).ne', bound hN]\n    _ â‰¤ rothNumberNat ((2 * dValue N - 1) ^ n) := bound_aux hd.ne' hnâ‚‚.le\n    _ â‰¤ rothNumberNat N := mod_cast rothNumberNat.mono this\n  rw [â† rpow_natCast, div_rpow (rpow_nonneg hNâ‚€.le _) (exp_pos _).le, â† rpow_mul hNâ‚€.le,\n    inv_mul_eq_div, cast_sub hnâ‚‚.le, cast_two, same_sub_div hn.ne', exp_one_rpow,\n    div_div, rpow_sub hNâ‚€, rpow_one, div_div, div_eq_mul_inv]\n  refine mul_le_mul_of_nonneg_left ?_ (cast_nonneg _)\n  rw [mul_inv, mul_inv, â† exp_neg, â† rpow_neg (cast_nonneg _), neg_sub, â† div_eq_mul_inv]\n  have : exp (-4 * âˆš(log N)) = exp (-2 * âˆš(log N)) * exp (-2 * âˆš(log N)) := by\n    rw [â† exp_add, â† add_mul]\n    norm_num\n  rw [this]\n  refine mul_le_mul ?_ (exp_neg_two_mul_le <| Real.sqrt_pos.2 <| log_pos ?_).le (exp_pos _).le <|\n      rpow_nonneg (cast_nonneg _) _\n  Â· rw [â† le_log_iff_exp_le (rpow_pos_of_pos hNâ‚€ _), log_rpow hNâ‚€, â† le_div_iffâ‚€, mul_div_assoc,\n      div_sqrt, neg_mul, neg_le_neg_iff, div_mul_eq_mul_div, div_le_iffâ‚€ hn]\n    Â· exact mul_le_mul_of_nonneg_left (le_ceil _) zero_le_two\n    refine Real.sqrt_pos.2 (log_pos ?_)\n    rw [one_lt_cast]\n    exact hN.trans_lt' (by norm_num1)\n  Â· rw [one_lt_cast]\n    exact hN.trans_lt' (by norm_num1)\n\n"}
{"name":"Behrend.exp_four_lt","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"âŠ¢ LT.lt (Real.exp 4) 64","decl":"theorem exp_four_lt : exp 4 < 64 := by\n  rw [show (64 : â„) = 2 ^ ((6 : â„•) : â„) by rw [rpow_natCast]; norm_num1,\n    â† lt_log_iff_exp_lt (rpow_pos_of_pos zero_lt_two _), log_rpow zero_lt_two, â† div_lt_iffâ‚€']\n  Â· exact log_two_gt_d9.trans_le' (by norm_num1)\n  Â· norm_num\n\n"}
{"name":"Behrend.four_zero_nine_six_lt_exp_sixteen","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"âŠ¢ LT.lt 4096 (Real.exp 16)","decl":"theorem four_zero_nine_six_lt_exp_sixteen : 4096 < exp 16 := by\n  rw [â† log_lt_iff_lt_exp (show (0 : â„) < 4096 by norm_num), show (4096 : â„) = 2 ^ 12 by norm_cast,\n    â† rpow_natCast, log_rpow zero_lt_two, cast_ofNat]\n  linarith [log_two_lt_d9]\n\n"}
{"name":"Behrend.lower_bound_le_one'","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nhN : LE.le 2 N\nhN' : LE.le N 4096\nâŠ¢ LE.le (HMul.hMul (â†‘N) (Real.exp (HMul.hMul (-4) (Real.log â†‘N).sqrt))) 1","decl":"theorem lower_bound_le_one' (hN : 2 â‰¤ N) (hN' : N â‰¤ 4096) :\n    (N : â„) * exp (-4 * âˆš(log N)) â‰¤ 1 := by\n  rw [â† log_le_log_iff (mul_pos (cast_pos.2 (zero_lt_two.trans_le hN)) (exp_pos _)) zero_lt_one,\n    log_one, log_mul (cast_pos.2 (zero_lt_two.trans_le hN)).ne' (exp_pos _).ne', log_exp, neg_mul, â†\n    sub_eq_add_neg, sub_nonpos, â†\n    div_le_iffâ‚€ (Real.sqrt_pos.2 <| log_pos <| one_lt_cast.2 <| one_lt_two.trans_le hN), div_sqrt,\n    sqrt_le_left zero_le_four, log_le_iff_le_exp (cast_pos.2 (zero_lt_two.trans_le hN))]\n  norm_num1\n  apply le_trans _ four_zero_nine_six_lt_exp_sixteen.le\n  exact mod_cast hN'\n\n"}
{"name":"Behrend.lower_bound_le_one","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nhN : LE.le 1 N\nhN' : LE.le N 4096\nâŠ¢ LE.le (HMul.hMul (â†‘N) (Real.exp (HMul.hMul (-4) (Real.log â†‘N).sqrt))) 1","decl":"theorem lower_bound_le_one (hN : 1 â‰¤ N) (hN' : N â‰¤ 4096) :\n    (N : â„) * exp (-4 * âˆš(log N)) â‰¤ 1 := by\n  obtain rfl | hN := hN.eq_or_lt\n  Â· norm_num\n  Â· exact lower_bound_le_one' hN hN'\n\n"}
{"name":"Behrend.roth_lower_bound","module":"Mathlib.Combinatorics.Additive.AP.Three.Behrend","initialProofState":"N : Nat\nâŠ¢ LE.le (HMul.hMul (â†‘N) (Real.exp (HMul.hMul (-4) (Real.log â†‘N).sqrt))) â†‘(rothNumberNat N)","decl":"theorem roth_lower_bound : (N : â„) * exp (-4 * âˆš(log N)) â‰¤ rothNumberNat N := by\n  obtain rfl | hN := Nat.eq_zero_or_pos N\n  Â· norm_num\n  obtain hâ‚ | hâ‚ := le_or_lt 4096 N\n  Â· exact (roth_lower_bound_explicit hâ‚).le\n  Â· apply (lower_bound_le_one hN hâ‚.le).trans\n    simpa using rothNumberNat.monotone hN\n\n"}
