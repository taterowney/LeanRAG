{"name":"rootsOfUnity.integer_power_of_ringEquiv","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\ng : RingEquiv L L\n⊢ Exists fun m => ∀ (t : Subtype fun x => Membership.mem (rootsOfUnity n L) x), Eq (g ↑↑t) ↑(HPow.hPow (↑t) m)","decl":"theorem rootsOfUnity.integer_power_of_ringEquiv (g : L ≃+* L) :\n    ∃ m : ℤ, ∀ t : rootsOfUnity n L, g (t : Lˣ) = (t ^ m : Lˣ) := by\n  obtain ⟨m, hm⟩ := MonoidHom.map_cyclic ((g : L ≃* L).restrictRootsOfUnity n).toMonoidHom\n  exact ⟨m, fun t ↦ Units.ext_iff.1 <| SetCoe.ext_iff.2 <| hm t⟩\n\n"}
{"name":"rootsOfUnity.integer_power_of_ringEquiv'","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\ng : RingEquiv L L\n⊢ Exists fun m => ∀ (t : Units L), Membership.mem (rootsOfUnity n L) t → Eq (g ↑t) ↑(HPow.hPow t m)","decl":"theorem rootsOfUnity.integer_power_of_ringEquiv' (g : L ≃+* L) :\n    ∃ m : ℤ, ∀ t ∈ rootsOfUnity n L, g (t : Lˣ) = (t ^ m : Lˣ) := by\n  simpa using rootsOfUnity.integer_power_of_ringEquiv n g\n\n"}
{"name":"ModularCyclotomicCharacter_aux_spec","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\ng : RingEquiv L L\nn : Nat\ninst✝ : NeZero n\nt : Subtype fun x => Membership.mem (rootsOfUnity n L) x\n⊢ Eq (g ↑↑t) ↑(HPow.hPow (↑t) (ModularCyclotomicCharacter_aux g n))","decl":"theorem ModularCyclotomicCharacter_aux_spec (g : L ≃+* L) (n : ℕ) [NeZero n] :\n    ∀ t : rootsOfUnity n L, g (t : Lˣ) = (t ^ (ModularCyclotomicCharacter_aux g n) : Lˣ) :=\n  (rootsOfUnity.integer_power_of_ringEquiv n g).choose_spec\n\n"}
{"name":"ModularCyclotomicCharacter.toFun_spec","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\ng : RingEquiv L L\nn : Nat\ninst✝ : NeZero n\nt : Subtype fun x => Membership.mem (rootsOfUnity n L) x\n⊢ Eq (g ↑↑t) ↑(HPow.hPow (↑t) (ModularCyclotomicCharacter.toFun n g).val)","decl":"/-- The formula which characterises the output of `ModularCyclotomicCharacter g n`. -/\ntheorem toFun_spec (g : L ≃+* L) {n : ℕ} [NeZero n] (t : rootsOfUnity n L) :\n    g (t : Lˣ) = (t ^ (χ₀ n g).val : Lˣ) := by\n  rw [ModularCyclotomicCharacter_aux_spec g n t, ← zpow_natCast, ModularCyclotomicCharacter.toFun,\n    ZMod.val_intCast, ← Subgroup.coe_zpow]\n  exact Units.ext_iff.1 <| SetCoe.ext_iff.2 <|\n    zpow_eq_zpow_emod _ pow_card_eq_one (G := rootsOfUnity n L)\n\n"}
{"name":"ModularCyclotomicCharacter.toFun_spec'","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\ng : RingEquiv L L\nn : Nat\ninst✝ : NeZero n\nt : Units L\nht : Membership.mem (rootsOfUnity n L) t\n⊢ Eq (g ↑t) (HPow.hPow (↑t) (ModularCyclotomicCharacter.toFun n g).val)","decl":"theorem toFun_spec' (g : L ≃+* L) {n : ℕ} [NeZero n] {t : Lˣ} (ht : t ∈ rootsOfUnity n L) :\n    g t = t ^ (χ₀ n g).val :=\n  toFun_spec g ⟨t, ht⟩\n\n"}
{"name":"ModularCyclotomicCharacter.toFun_spec''","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\ng : RingEquiv L L\nn : Nat\ninst✝ : NeZero n\nt : L\nht : IsPrimitiveRoot t n\n⊢ Eq (g t) (HPow.hPow t (ModularCyclotomicCharacter.toFun n g).val)","decl":"theorem toFun_spec'' (g : L ≃+* L) {n : ℕ} [NeZero n] {t : L} (ht : IsPrimitiveRoot t n) :\n    g t = t ^ (χ₀ n g).val :=\n  toFun_spec' g (SetLike.coe_mem ht.toRootsOfUnity)\n\n"}
{"name":"ModularCyclotomicCharacter.toFun_unique","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\ng : RingEquiv L L\nc : ZMod (Fintype.card (Subtype fun x => Membership.mem (rootsOfUnity n L) x))\nhc : ∀ (t : Subtype fun x => Membership.mem (rootsOfUnity n L) x), Eq (g ↑↑t) ↑(HPow.hPow (↑t) c.val)\n⊢ Eq c (ModularCyclotomicCharacter.toFun n g)","decl":"/-- If g(t)=t^c for all roots of unity, then c=χ(g). -/\ntheorem toFun_unique (g : L ≃+* L) (c : ZMod (Fintype.card (rootsOfUnity n L)))\n    (hc : ∀ t : rootsOfUnity n L, g (t : Lˣ) = (t ^ c.val : Lˣ)) : c = χ₀ n g := by\n  apply IsCyclic.ext Nat.card_eq_fintype_card (fun ζ ↦ ?_)\n  specialize hc ζ\n  suffices ((ζ ^ c.val : Lˣ) : L) = (ζ ^ (χ₀ n g).val : Lˣ) by exact_mod_cast this\n  rw [← toFun_spec g ζ, hc]\n\n"}
{"name":"ModularCyclotomicCharacter.toFun_unique'","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\ng : RingEquiv L L\nc : ZMod (Fintype.card (Subtype fun x => Membership.mem (rootsOfUnity n L) x))\nhc : ∀ (t : Units L), Membership.mem (rootsOfUnity n L) t → Eq (g ↑t) (HPow.hPow (↑t) c.val)\n⊢ Eq c (ModularCyclotomicCharacter.toFun n g)","decl":"theorem toFun_unique' (g : L ≃+* L) (c : ZMod (Fintype.card (rootsOfUnity n L)))\n    (hc : ∀ t ∈ rootsOfUnity n L, g t = t ^ c.val) : c = χ₀ n g :=\n  toFun_unique n g c (fun ⟨_, ht⟩ ↦ hc _ ht)\n\n"}
{"name":"ModularCyclotomicCharacter.id","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\n⊢ Eq (ModularCyclotomicCharacter.toFun n (RingEquiv.refl L)) 1","decl":"lemma id : χ₀ n (RingEquiv.refl L) = 1 := by\n  refine (toFun_unique n (RingEquiv.refl L) 1 <| fun t ↦ ?_).symm\n  have : 1 ≤ Fintype.card { x // x ∈ rootsOfUnity n L } := Fin.size_positive'\n  obtain (h | h) := this.lt_or_eq\n  · have := Fact.mk h\n    simp [ZMod.val_one]\n  · have := Fintype.card_le_one_iff_subsingleton.mp h.ge\n    obtain rfl : t = 1 := Subsingleton.elim t 1\n    simp\n\n"}
{"name":"ModularCyclotomicCharacter.comp","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\ng h : RingEquiv L L\n⊢ Eq (ModularCyclotomicCharacter.toFun n (HMul.hMul g h)) (HMul.hMul (ModularCyclotomicCharacter.toFun n g) (ModularCyclotomicCharacter.toFun n h))","decl":"lemma comp (g h : L ≃+* L) : χ₀ n (g * h) =\n    χ₀ n g * χ₀ n h := by\n  refine (toFun_unique n (g * h) _ <| fun ζ ↦ ?_).symm\n  change g (h (ζ : Lˣ)) = _\n  rw [toFun_spec, ← Subgroup.coe_pow, toFun_spec, mul_comm, Subgroup.coe_pow, ← pow_mul,\n    ← Subgroup.coe_pow]\n  congr 2\n  norm_cast\n  simp only [pow_eq_pow_iff_modEq, ← ZMod.natCast_eq_natCast_iff, SubmonoidClass.coe_pow,\n    ZMod.natCast_val, Nat.cast_mul, ZMod.cast_mul (m := orderOf ζ) orderOf_dvd_card]\n\n"}
{"name":"spec'","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\ng : RingEquiv L L\nt : Units L\nht : Membership.mem (rootsOfUnity n L) t\n⊢ Eq (g ↑t) (HPow.hPow (↑t) (↑((ModularCyclotomicCharacter' L n) g)).val)","decl":"lemma spec' (g : L ≃+* L) {t : Lˣ} (ht : t ∈ rootsOfUnity n L) :\n    g t = t ^ ((ModularCyclotomicCharacter' L n g) : ZMod\n      (Fintype.card { x // x ∈ rootsOfUnity n L })).val :=\n  ModularCyclotomicCharacter.toFun_spec' g ht\n\n"}
{"name":"unique'","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\ng : RingEquiv L L\nc : ZMod (Fintype.card (Subtype fun x => Membership.mem (rootsOfUnity n L) x))\nhc : ∀ (t : Units L), Membership.mem (rootsOfUnity n L) t → Eq (g ↑t) (HPow.hPow (↑t) c.val)\n⊢ Eq c ↑((ModularCyclotomicCharacter' L n) g)","decl":"lemma unique' (g : L ≃+* L) {c : ZMod (Fintype.card { x // x ∈ rootsOfUnity n L })}\n    (hc : ∀ t ∈ rootsOfUnity n L, g t = t ^ c.val) :\n    c = ModularCyclotomicCharacter' L n g :=\n  ModularCyclotomicCharacter.toFun_unique' _ _ _ hc\n\n"}
{"name":"ModularCyclotomicCharacter.spec","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\nhn : Eq (Fintype.card (Subtype fun x => Membership.mem (rootsOfUnity n L) x)) n\ng : RingEquiv L L\nt : Units L\nht : Membership.mem (rootsOfUnity n L) t\n⊢ Eq (g ↑t) (HPow.hPow (↑t) (↑((ModularCyclotomicCharacter L hn) g)).val)","decl":"lemma spec (g : L ≃+* L) {t : Lˣ} (ht : t ∈ rootsOfUnity n L) :\n    g t = t ^ ((ModularCyclotomicCharacter L hn g) : ZMod n).val := by\n  rw [toFun_spec' g ht]\n  congr 1\n  exact (ZMod.ringEquivCongr_val _ _).symm\n\n"}
{"name":"ModularCyclotomicCharacter.unique","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝² : CommRing L\ninst✝¹ : IsDomain L\nn : Nat\ninst✝ : NeZero n\nhn : Eq (Fintype.card (Subtype fun x => Membership.mem (rootsOfUnity n L) x)) n\ng : RingEquiv L L\nc : ZMod n\nhc : ∀ (t : Units L), Membership.mem (rootsOfUnity n L) t → Eq (g ↑t) (HPow.hPow (↑t) c.val)\n⊢ Eq c ↑((ModularCyclotomicCharacter L hn) g)","decl":"lemma unique (g : L ≃+* L) {c : ZMod n} (hc : ∀ t ∈ rootsOfUnity n L, g t = t ^ c.val) :\n    c = ModularCyclotomicCharacter L hn g := by\n  change c = (ZMod.ringEquivCongr hn) (toFun n g)\n  rw [← toFun_unique' n g (ZMod.ringEquivCongr hn.symm c)\n    (fun t ht ↦ by rw [hc t ht, ZMod.ringEquivCongr_val]), ← ZMod.ringEquivCongr_symm hn,\n    RingEquiv.apply_symm_apply]\n\n"}
{"name":"IsPrimitiveRoot.autToPow_eq_ModularCyclotomicCharacter","module":"Mathlib.NumberTheory.Cyclotomic.CyclotomicCharacter","initialProofState":"L : Type u\ninst✝⁴ : CommRing L\ninst✝³ : IsDomain L\nn : Nat\ninst✝² : NeZero n\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Algebra R L\nμ : L\nhμ : IsPrimitiveRoot μ n\ng : AlgEquiv R L L\n⊢ Eq ((IsPrimitiveRoot.autToPow R hμ) g) ((ModularCyclotomicCharacter L ⋯) ↑g)","decl":"/-- The relationship between `IsPrimitiveRoot.autToPow` and\n`ModularCyclotomicCharacter`. Note that `IsPrimitiveRoot.autToPow`\nneeds an explicit root of unity, and also an auxiliary \"base ring\" `R`. -/\nlemma IsPrimitiveRoot.autToPow_eq_ModularCyclotomicCharacter (n : ℕ) [NeZero n]\n    (R : Type*) [CommRing R] [Algebra R L] {μ : L} (hμ : IsPrimitiveRoot μ n) (g : L ≃ₐ[R] L) :\n    hμ.autToPow R g = ModularCyclotomicCharacter L hμ.card_rootsOfUnity g := by\n  ext\n  apply ZMod.val_injective\n  apply hμ.pow_inj (ZMod.val_lt _) (ZMod.val_lt _)\n  simpa only [autToPow_spec R hμ g, ModularCyclotomicCharacter, RingEquiv.toMulEquiv_eq_coe,\n    MulEquiv.toMonoidHom_eq_coe, ModularCyclotomicCharacter', MonoidHom.coe_comp, MonoidHom.coe_coe,\n    Function.comp_apply, Units.coe_mapEquiv, MonoidHom.coe_toHomUnits, MonoidHom.coe_mk,\n    OneHom.coe_mk, RingEquiv.coe_toMulEquiv, ZMod.ringEquivCongr_val, AlgEquiv.coe_ringEquiv]\n    using ModularCyclotomicCharacter.toFun_spec'' g hμ\n"}
