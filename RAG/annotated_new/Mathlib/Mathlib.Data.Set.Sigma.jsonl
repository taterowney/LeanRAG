{"name":"Set.range_sigmaMk","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ni : ι\n⊢ Eq (Set.range (Sigma.mk i)) (Set.preimage Sigma.fst (Singleton.singleton i))","decl":"@[simp]\ntheorem range_sigmaMk (i : ι) : range (Sigma.mk i : α i → Sigma α) = Sigma.fst ⁻¹' {i} := by\n  apply Subset.antisymm\n  · rintro _ ⟨b, rfl⟩\n    simp\n  · rintro ⟨x, y⟩ (rfl | _)\n    exact mem_range_self y\n\n"}
{"name":"Set.preimage_image_sigmaMk_of_ne","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ni j : ι\nh : Ne i j\ns : Set (α j)\n⊢ Eq (Set.preimage (Sigma.mk i) (Set.image (Sigma.mk j) s)) EmptyCollection.emptyCollection","decl":"theorem preimage_image_sigmaMk_of_ne (h : i ≠ j) (s : Set (α j)) :\n    Sigma.mk i ⁻¹' (Sigma.mk j '' s) = ∅ := by\n  ext x\n  simp [h.symm]\n\n"}
{"name":"Set.image_sigmaMk_preimage_sigmaMap_subset","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\nβ : ι' → Type u_4\nf : ι → ι'\ng : (i : ι) → α i → β (f i)\ni : ι\ns : Set (β (f i))\n⊢ HasSubset.Subset (Set.image (Sigma.mk i) (Set.preimage (g i) s)) (Set.preimage (Sigma.map f g) (Set.image (Sigma.mk (f i)) s))","decl":"theorem image_sigmaMk_preimage_sigmaMap_subset {β : ι' → Type*} (f : ι → ι')\n    (g : ∀ i, α i → β (f i)) (i : ι) (s : Set (β (f i))) :\n    Sigma.mk i '' (g i ⁻¹' s) ⊆ Sigma.map f g ⁻¹' (Sigma.mk (f i) '' s) :=\n  image_subset_iff.2 fun x hx ↦ ⟨g i x, hx, rfl⟩\n\n"}
{"name":"Set.image_sigmaMk_preimage_sigmaMap","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\nβ : ι' → Type u_4\nf : ι → ι'\nhf : Function.Injective f\ng : (i : ι) → α i → β (f i)\ni : ι\ns : Set (β (f i))\n⊢ Eq (Set.image (Sigma.mk i) (Set.preimage (g i) s)) (Set.preimage (Sigma.map f g) (Set.image (Sigma.mk (f i)) s))","decl":"theorem image_sigmaMk_preimage_sigmaMap {β : ι' → Type*} {f : ι → ι'} (hf : Function.Injective f)\n    (g : ∀ i, α i → β (f i)) (i : ι) (s : Set (β (f i))) :\n    Sigma.mk i '' (g i ⁻¹' s) = Sigma.map f g ⁻¹' (Sigma.mk (f i) '' s) := by\n  refine (image_sigmaMk_preimage_sigmaMap_subset f g i s).antisymm ?_\n  rintro ⟨j, x⟩ ⟨y, hys, hxy⟩\n  simp only [hf.eq_iff, Sigma.map, Sigma.ext_iff] at hxy\n  rcases hxy with ⟨rfl, hxy⟩; rw [heq_iff_eq] at hxy; subst y\n  exact ⟨x, hys, rfl⟩\n\n"}
{"name":"Set.mem_sigma_iff","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\nx : Sigma fun i => α i\n⊢ Iff (Membership.mem (s.sigma t) x) (And (Membership.mem s x.fst) (Membership.mem (t x.fst) x.snd))","decl":"@[simp] theorem mem_sigma_iff : x ∈ s.sigma t ↔ x.1 ∈ s ∧ x.2 ∈ t x.1 := Iff.rfl\n\n"}
{"name":"Set.mk_sigma_iff","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\na : α i\n⊢ Iff (Membership.mem (s.sigma t) ⟨i, a⟩) (And (Membership.mem s i) (Membership.mem (t i) a))","decl":"theorem mk_sigma_iff : (⟨i, a⟩ : Σ i, α i) ∈ s.sigma t ↔ i ∈ s ∧ a ∈ t i := Iff.rfl\n\n"}
{"name":"Set.mk_mem_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\na : α i\nhi : Membership.mem s i\nha : Membership.mem (t i) a\n⊢ Membership.mem (s.sigma t) ⟨i, a⟩","decl":"theorem mk_mem_sigma (hi : i ∈ s) (ha : a ∈ t i) : (⟨i, a⟩ : Σ i, α i) ∈ s.sigma t := ⟨hi, ha⟩\n\n"}
{"name":"Set.sigma_mono","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns₁ s₂ : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\nhs : HasSubset.Subset s₁ s₂\nht : ∀ (i : ι), HasSubset.Subset (t₁ i) (t₂ i)\n⊢ HasSubset.Subset (s₁.sigma t₁) (s₂.sigma t₂)","decl":"theorem sigma_mono (hs : s₁ ⊆ s₂) (ht : ∀ i, t₁ i ⊆ t₂ i) : s₁.sigma t₁ ⊆ s₂.sigma t₂ := fun _ hx ↦\n  ⟨hs hx.1, ht _ hx.2⟩\n\n"}
{"name":"Set.sigma_subset_iff","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\nu : Set (Sigma fun i => α i)\n⊢ Iff (HasSubset.Subset (s.sigma t) u) (∀ ⦃i : ι⦄, Membership.mem s i → ∀ ⦃a : α i⦄, Membership.mem (t i) a → Membership.mem u ⟨i, a⟩)","decl":"theorem sigma_subset_iff :\n    s.sigma t ⊆ u ↔ ∀ ⦃i⦄, i ∈ s → ∀ ⦃a⦄, a ∈ t i → (⟨i, a⟩ : Σ i, α i) ∈ u :=\n  ⟨fun h _ hi _ ha ↦ h <| mk_mem_sigma hi ha, fun h _ ha ↦ h ha.1 ha.2⟩\n\n"}
{"name":"Set.forall_sigma_iff","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\np : (Sigma fun i => α i) → Prop\n⊢ Iff (∀ (x : Sigma fun i => α i), Membership.mem (s.sigma t) x → p x) (∀ ⦃i : ι⦄, Membership.mem s i → ∀ ⦃a : α i⦄, Membership.mem (t i) a → p ⟨i, a⟩)","decl":"theorem forall_sigma_iff {p : (Σ i, α i) → Prop} :\n    (∀ x ∈ s.sigma t, p x) ↔ ∀ ⦃i⦄, i ∈ s → ∀ ⦃a⦄, a ∈ t i → p ⟨i, a⟩ := sigma_subset_iff\n\n"}
{"name":"Set.exists_sigma_iff","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\np : (Sigma fun i => α i) → Prop\n⊢ Iff (Exists fun x => And (Membership.mem (s.sigma t) x) (p x)) (Exists fun i => And (Membership.mem s i) (Exists fun a => And (Membership.mem (t i) a) (p ⟨i, a⟩)))","decl":"theorem exists_sigma_iff {p : (Σi, α i) → Prop} :\n    (∃ x ∈ s.sigma t, p x) ↔ ∃ i ∈ s, ∃ a ∈ t i, p ⟨i, a⟩ :=\n  ⟨fun ⟨⟨i, a⟩, ha, h⟩ ↦ ⟨i, ha.1, a, ha.2, h⟩, fun ⟨i, hi, a, ha, h⟩ ↦ ⟨⟨i, a⟩, ⟨hi, ha⟩, h⟩⟩\n\n"}
{"name":"Set.sigma_empty","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\n⊢ Eq (s.sigma fun i => EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp] theorem sigma_empty : s.sigma (fun i ↦ (∅ : Set (α i))) = ∅ :=\n  ext fun _ ↦ iff_of_eq (and_false _)\n\n"}
{"name":"Set.empty_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nt : (i : ι) → Set (α i)\n⊢ Eq (EmptyCollection.emptyCollection.sigma t) EmptyCollection.emptyCollection","decl":"@[simp] theorem empty_sigma : (∅ : Set ι).sigma t = ∅ := ext fun _ ↦ iff_of_eq (false_and _)\n\n"}
{"name":"Set.univ_sigma_univ","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ni : ι\n⊢ Eq (Set.univ.sigma fun x => Set.univ) Set.univ","decl":"theorem univ_sigma_univ : (@univ ι).sigma (fun _ ↦ @univ (α i)) = univ :=\n  ext fun _ ↦ iff_of_eq (true_and _)\n\n"}
{"name":"Set.sigma_univ","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\n⊢ Eq (s.sigma fun x => Set.univ) (Set.preimage Sigma.fst s)","decl":"@[simp]\ntheorem sigma_univ : s.sigma (fun _ ↦ univ : ∀ i, Set (α i)) = Sigma.fst ⁻¹' s :=\n  ext fun _ ↦ iff_of_eq (and_true _)\n\n"}
{"name":"Set.univ_sigma_preimage_mk","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set (Sigma fun i => α i)\n⊢ Eq (Set.univ.sigma fun i => Set.preimage (Sigma.mk i) s) s","decl":"@[simp] theorem univ_sigma_preimage_mk (s : Set (Σ i, α i)) :\n    (univ : Set ι).sigma (fun i ↦ Sigma.mk i ⁻¹' s) = s :=\n  ext <| by simp\n\n"}
{"name":"Set.singleton_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nt : (i : ι) → Set (α i)\ni : ι\n⊢ Eq ((Singleton.singleton i).sigma t) (Set.image (Sigma.mk i) (t i))","decl":"@[simp]\ntheorem singleton_sigma : ({i} : Set ι).sigma t = Sigma.mk i '' t i :=\n  ext fun x ↦ by\n    constructor\n    · obtain ⟨j, a⟩ := x\n      rintro ⟨rfl : j = i, ha⟩\n      exact mem_image_of_mem _ ha\n    · rintro ⟨b, hb, rfl⟩\n      exact ⟨rfl, hb⟩\n\n"}
{"name":"Set.sigma_singleton","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\na : (i : ι) → α i\n⊢ Eq (s.sigma fun i => Singleton.singleton (a i)) (Set.image (fun i => ⟨i, a i⟩) s)","decl":"@[simp]\ntheorem sigma_singleton {a : ∀ i, α i} :\n    s.sigma (fun i ↦ ({a i} : Set (α i))) = (fun i ↦ Sigma.mk i <| a i) '' s := by\n  ext ⟨x, y⟩\n  simp [and_left_comm, eq_comm]\n\n"}
{"name":"Set.singleton_sigma_singleton","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ni : ι\na : (i : ι) → α i\n⊢ Eq ((Singleton.singleton i).sigma fun i => Singleton.singleton (a i)) (Singleton.singleton ⟨i, a i⟩)","decl":"theorem singleton_sigma_singleton {a : ∀ i, α i} :\n    (({i} : Set ι).sigma fun i ↦ ({a i} : Set (α i))) = {⟨i, a i⟩} := by\n  rw [sigma_singleton, image_singleton]\n\n"}
{"name":"Set.union_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns₁ s₂ : Set ι\nt : (i : ι) → Set (α i)\n⊢ Eq ((Union.union s₁ s₂).sigma t) (Union.union (s₁.sigma t) (s₂.sigma t))","decl":"@[simp]\ntheorem union_sigma : (s₁ ∪ s₂).sigma t = s₁.sigma t ∪ s₂.sigma t := ext fun _ ↦ or_and_right\n\n"}
{"name":"Set.sigma_union","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\n⊢ Eq (s.sigma fun i => Union.union (t₁ i) (t₂ i)) (Union.union (s.sigma t₁) (s.sigma t₂))","decl":"@[simp]\ntheorem sigma_union : s.sigma (fun i ↦ t₁ i ∪ t₂ i) = s.sigma t₁ ∪ s.sigma t₂ :=\n  ext fun _ ↦ and_or_left\n\n"}
{"name":"Set.sigma_inter_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns₁ s₂ : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\n⊢ Eq (Inter.inter (s₁.sigma t₁) (s₂.sigma t₂)) ((Inter.inter s₁ s₂).sigma fun i => Inter.inter (t₁ i) (t₂ i))","decl":"theorem sigma_inter_sigma : s₁.sigma t₁ ∩ s₂.sigma t₂ = (s₁ ∩ s₂).sigma fun i ↦ t₁ i ∩ t₂ i := by\n  ext ⟨x, y⟩\n  simp [and_assoc, and_left_comm]\n\n"}
{"name":"biSup_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nβ : Type u_4\ninst✝ : CompleteLattice β\ns : Set ι\nt : (i : ι) → Set (α i)\nf : Sigma α → β\n⊢ Eq (iSup fun ij => iSup fun h => f ij) (iSup fun i => iSup fun h => iSup fun j => iSup fun h => f ⟨i, j⟩)","decl":"theorem _root_.biSup_sigma (s : Set ι) (t : ∀ i, Set (α i)) (f : Sigma α → β) :\n    ⨆ ij ∈ s.sigma t, f ij = ⨆ (i ∈ s) (j ∈ t i), f ⟨i, j⟩ :=\n  eq_of_forall_ge_iff fun _ ↦ ⟨by simp_all, by simp_all⟩\n\n"}
{"name":"biSup_sigma'","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nβ : Type u_4\ninst✝ : CompleteLattice β\ns : Set ι\nt : (i : ι) → Set (α i)\nf : (i : ι) → α i → β\n⊢ Eq (iSup fun i => iSup fun h => iSup fun j => iSup fun h => f i j) (iSup fun ij => iSup fun h => f ij.fst ij.snd)","decl":"theorem _root_.biSup_sigma' (s : Set ι) (t : ∀ i, Set (α i)) (f : ∀ i, α i → β) :\n    ⨆ (i ∈ s) (j ∈ t i), f i j = ⨆ ij ∈ s.sigma t, f ij.fst ij.snd :=\n  Eq.symm (biSup_sigma _ _ _)\n\n"}
{"name":"biInf_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nβ : Type u_4\ninst✝ : CompleteLattice β\ns : Set ι\nt : (i : ι) → Set (α i)\nf : Sigma α → β\n⊢ Eq (iInf fun ij => iInf fun h => f ij) (iInf fun i => iInf fun h => iInf fun j => iInf fun h => f ⟨i, j⟩)","decl":"theorem _root_.biInf_sigma (s : Set ι) (t : ∀ i, Set (α i)) (f : Sigma α → β) :\n    ⨅ ij ∈ s.sigma t, f ij = ⨅ (i ∈ s) (j ∈ t i), f ⟨i, j⟩ :=\n  biSup_sigma (β := βᵒᵈ) _ _ _\n\n"}
{"name":"biInf_sigma'","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nβ : Type u_4\ninst✝ : CompleteLattice β\ns : Set ι\nt : (i : ι) → Set (α i)\nf : (i : ι) → α i → β\n⊢ Eq (iInf fun i => iInf fun h => iInf fun j => iInf fun h => f i j) (iInf fun ij => iInf fun h => f ij.fst ij.snd)","decl":"theorem _root_.biInf_sigma' (s : Set ι) (t : ∀ i, Set (α i)) (f : ∀ i, α i → β) :\n    ⨅ (i ∈ s) (j ∈ t i), f i j = ⨅ ij ∈ s.sigma t, f ij.fst ij.snd :=\n  Eq.symm (biInf_sigma _ _ _)\n\n"}
{"name":"Set.biUnion_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nβ : Type u_5\ns : Set ι\nt : (i : ι) → Set (α i)\nf : Sigma α → Set β\n⊢ Eq (Set.iUnion fun ij => Set.iUnion fun h => f ij) (Set.iUnion fun i => Set.iUnion fun h => Set.iUnion fun j => Set.iUnion fun h => f ⟨i, j⟩)","decl":"theorem biUnion_sigma (s : Set ι) (t : ∀ i, Set (α i)) (f : Sigma α → Set β) :\n    ⋃ ij ∈ s.sigma t, f ij = ⋃ i ∈ s, ⋃ j ∈ t i, f ⟨i, j⟩ :=\n  biSup_sigma _ _ _\n\n"}
{"name":"Set.biUnion_sigma'","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nβ : Type u_5\ns : Set ι\nt : (i : ι) → Set (α i)\nf : (i : ι) → α i → Set β\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun h => Set.iUnion fun j => Set.iUnion fun h => f i j) (Set.iUnion fun ij => Set.iUnion fun h => f ij.fst ij.snd)","decl":"theorem biUnion_sigma' (s : Set ι) (t : ∀ i, Set (α i)) (f : ∀ i, α i → Set β) :\n    ⋃ i ∈ s, ⋃ j ∈ t i, f i j = ⋃ ij ∈ s.sigma t, f ij.fst ij.snd :=\n  biSup_sigma' _ _ _\n\n"}
{"name":"Set.biInter_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nβ : Type u_5\ns : Set ι\nt : (i : ι) → Set (α i)\nf : Sigma α → Set β\n⊢ Eq (Set.iInter fun ij => Set.iInter fun h => f ij) (Set.iInter fun i => Set.iInter fun h => Set.iInter fun j => Set.iInter fun h => f ⟨i, j⟩)","decl":"theorem biInter_sigma (s : Set ι) (t : ∀ i, Set (α i)) (f : Sigma α → Set β) :\n    ⋂ ij ∈ s.sigma t, f ij = ⋂ i ∈ s, ⋂ j ∈ t i, f ⟨i, j⟩ :=\n  biInf_sigma _ _ _\n\n"}
{"name":"Set.biInter_sigma'","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nβ : Type u_5\ns : Set ι\nt : (i : ι) → Set (α i)\nf : (i : ι) → α i → Set β\n⊢ Eq (Set.iInter fun i => Set.iInter fun h => Set.iInter fun j => Set.iInter fun h => f i j) (Set.iInter fun ij => Set.iInter fun h => f ij.fst ij.snd)","decl":"theorem biInter_sigma' (s : Set ι) (t : ∀ i, Set (α i)) (f : ∀ i, α i → Set β) :\n    ⋂ i ∈ s, ⋂ j ∈ t i, f i j = ⋂ ij ∈ s.sigma t, f ij.fst ij.snd :=\n  biInf_sigma' _ _ _\n\n"}
{"name":"Set.insert_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\n⊢ Eq ((Insert.insert i s).sigma t) (Union.union (Set.image (Sigma.mk i) (t i)) (s.sigma t))","decl":"theorem insert_sigma : (insert i s).sigma t = Sigma.mk i '' t i ∪ s.sigma t := by\n  rw [insert_eq, union_sigma, singleton_sigma]\n\n"}
{"name":"Set.sigma_insert","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\na : (i : ι) → α i\n⊢ Eq (s.sigma fun i => Insert.insert (a i) (t i)) (Union.union (Set.image (fun i => ⟨i, a i⟩) s) (s.sigma t))","decl":"theorem sigma_insert {a : ∀ i, α i} :\n    s.sigma (fun i ↦ insert (a i) (t i)) = (fun i ↦ ⟨i, a i⟩) '' s ∪ s.sigma t := by\n  simp_rw [insert_eq, sigma_union, sigma_singleton]\n\n"}
{"name":"Set.sigma_preimage_eq","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\nβ : ι → Type u_6\nf : ι' → ι\ng : (i : ι) → β i → α i\n⊢ Eq ((Set.preimage f s).sigma fun i => Set.preimage (g (f i)) (t (f i))) (Set.preimage (fun p => ⟨f p.fst, g (f p.fst) p.snd⟩) (s.sigma t))","decl":"theorem sigma_preimage_eq {f : ι' → ι} {g : ∀ i, β i → α i} :\n    (f ⁻¹' s).sigma (fun i ↦ g (f i) ⁻¹' t (f i)) =\n      (fun p : Σ i, β (f i) ↦ Sigma.mk _ (g _ p.2)) ⁻¹' s.sigma t := rfl\n\n"}
{"name":"Set.sigma_preimage_left","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\nf : ι' → ι\n⊢ Eq ((Set.preimage f s).sigma fun i => t (f i)) (Set.preimage (fun p => ⟨f p.fst, p.snd⟩) (s.sigma t))","decl":"theorem sigma_preimage_left {f : ι' → ι} :\n    ((f ⁻¹' s).sigma fun i ↦ t (f i)) = (fun p : Σ i, α (f i) ↦ Sigma.mk _ p.2) ⁻¹' s.sigma t :=\n  rfl\n\n"}
{"name":"Set.sigma_preimage_right","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\nβ : ι → Type u_6\ng : (i : ι) → β i → α i\n⊢ Eq (s.sigma fun i => Set.preimage (g i) (t i)) (Set.preimage (fun p => ⟨p.fst, g p.fst p.snd⟩) (s.sigma t))","decl":"theorem sigma_preimage_right {g : ∀ i, β i → α i} :\n    (s.sigma fun i ↦ g i ⁻¹' t i) = (fun p : Σ i, β i ↦ Sigma.mk p.1 (g _ p.2)) ⁻¹' s.sigma t :=\n  rfl\n\n"}
{"name":"Set.preimage_sigmaMap_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\nα' : ι' → Type u_7\nf : ι → ι'\ng : (i : ι) → α i → α' (f i)\ns : Set ι'\nt : (i : ι') → Set (α' i)\n⊢ Eq (Set.preimage (Sigma.map f g) (s.sigma t)) ((Set.preimage f s).sigma fun i => Set.preimage (g i) (t (f i)))","decl":"theorem preimage_sigmaMap_sigma {α' : ι' → Type*} (f : ι → ι') (g : ∀ i, α i → α' (f i))\n    (s : Set ι') (t : ∀ i, Set (α' i)) :\n    Sigma.map f g ⁻¹' s.sigma t = (f ⁻¹' s).sigma fun i ↦ g i ⁻¹' t (f i) := rfl\n\n"}
{"name":"Set.mk_preimage_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\nhi : Membership.mem s i\n⊢ Eq (Set.preimage (Sigma.mk i) (s.sigma t)) (t i)","decl":"@[simp]\ntheorem mk_preimage_sigma (hi : i ∈ s) : Sigma.mk i ⁻¹' s.sigma t = t i :=\n  ext fun _ ↦ and_iff_right hi\n\n"}
{"name":"Set.mk_preimage_sigma_eq_empty","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\nhi : Not (Membership.mem s i)\n⊢ Eq (Set.preimage (Sigma.mk i) (s.sigma t)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem mk_preimage_sigma_eq_empty (hi : i ∉ s) : Sigma.mk i ⁻¹' s.sigma t = ∅ :=\n  ext fun _ ↦ iff_of_false (hi ∘ And.left) id\n\n"}
{"name":"Set.mk_preimage_sigma_eq_if","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (Set.preimage (Sigma.mk i) (s.sigma t)) (ite (Membership.mem s i) (t i) EmptyCollection.emptyCollection)","decl":"theorem mk_preimage_sigma_eq_if [DecidablePred (· ∈ s)] :\n    Sigma.mk i ⁻¹' s.sigma t = if i ∈ s then t i else ∅ := by split_ifs <;> simp [*]\n\n"}
{"name":"Set.mk_preimage_sigma_fn_eq_if","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\nβ : Type u_7\ninst✝ : DecidablePred fun x => Membership.mem s x\ng : β → α i\n⊢ Eq (Set.preimage (fun b => ⟨i, g b⟩) (s.sigma t)) (ite (Membership.mem s i) (Set.preimage g (t i)) EmptyCollection.emptyCollection)","decl":"theorem mk_preimage_sigma_fn_eq_if {β : Type*} [DecidablePred (· ∈ s)] (g : β → α i) :\n    (fun b ↦ Sigma.mk i (g b)) ⁻¹' s.sigma t = if i ∈ s then g ⁻¹' t i else ∅ :=\n  ext fun _ ↦ by split_ifs <;> simp [*]\n\n"}
{"name":"Set.sigma_univ_range_eq","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nβ : ι → Type u_6\nf : (i : ι) → α i → β i\n⊢ Eq (Set.univ.sigma fun i => Set.range (f i)) (Set.range fun x => ⟨x.fst, f x.fst x.snd⟩)","decl":"theorem sigma_univ_range_eq {f : ∀ i, α i → β i} :\n    (univ : Set ι).sigma (fun i ↦ range (f i)) = range fun x : Σ i, α i ↦ ⟨x.1, f _ x.2⟩ :=\n  ext <| by simp [range, Sigma.forall]\n\n"}
{"name":"Set.Nonempty.sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\na✝¹ : s.Nonempty\na✝ : ∀ (i : ι), (t i).Nonempty\n⊢ (s.sigma t).Nonempty","decl":"protected theorem Nonempty.sigma :\n    s.Nonempty → (∀ i, (t i).Nonempty) → (s.sigma t).Nonempty := fun ⟨i, hi⟩ h ↦\n  let ⟨a, ha⟩ := h i\n  ⟨⟨i, a⟩, hi, ha⟩\n\n"}
{"name":"Set.Nonempty.sigma_fst","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\na✝ : (s.sigma t).Nonempty\n⊢ s.Nonempty","decl":"theorem Nonempty.sigma_fst : (s.sigma t).Nonempty → s.Nonempty := fun ⟨x, hx⟩ ↦ ⟨x.1, hx.1⟩\n\n"}
{"name":"Set.Nonempty.sigma_snd","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\na✝ : (s.sigma t).Nonempty\n⊢ Exists fun i => And (Membership.mem s i) (t i).Nonempty","decl":"theorem Nonempty.sigma_snd : (s.sigma t).Nonempty → ∃ i ∈ s, (t i).Nonempty :=\n  fun ⟨x, hx⟩ ↦ ⟨x.1, hx.1, x.2, hx.2⟩\n\n"}
{"name":"Set.sigma_nonempty_iff","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\n⊢ Iff (s.sigma t).Nonempty (Exists fun i => And (Membership.mem s i) (t i).Nonempty)","decl":"theorem sigma_nonempty_iff : (s.sigma t).Nonempty ↔ ∃ i ∈ s, (t i).Nonempty :=\n  ⟨Nonempty.sigma_snd, fun ⟨i, hi, a, ha⟩ ↦ ⟨⟨i, a⟩, hi, ha⟩⟩\n\n"}
{"name":"Set.sigma_eq_empty_iff","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\n⊢ Iff (Eq (s.sigma t) EmptyCollection.emptyCollection) (∀ (i : ι), Membership.mem s i → Eq (t i) EmptyCollection.emptyCollection)","decl":"theorem sigma_eq_empty_iff : s.sigma t = ∅ ↔ ∀ i ∈ s, t i = ∅ :=\n  not_nonempty_iff_eq_empty.symm.trans <|\n    sigma_nonempty_iff.not.trans <| by\n      simp only [not_nonempty_iff_eq_empty, not_and, not_exists]\n\n"}
{"name":"Set.image_sigmaMk_subset_sigma_left","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\na : (i : ι) → α i\nha : ∀ (i : ι), Membership.mem (t i) (a i)\n⊢ HasSubset.Subset (Set.image (fun i => ⟨i, a i⟩) s) (s.sigma t)","decl":"theorem image_sigmaMk_subset_sigma_left {a : ∀ i, α i} (ha : ∀ i, a i ∈ t i) :\n    (fun i ↦ Sigma.mk i (a i)) '' s ⊆ s.sigma t :=\n  image_subset_iff.2 fun _ hi ↦ ⟨hi, ha _⟩\n\n"}
{"name":"Set.image_sigmaMk_subset_sigma_right","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\ni : ι\nhi : Membership.mem s i\n⊢ HasSubset.Subset (Set.image (Sigma.mk i) (t i)) (s.sigma t)","decl":"theorem image_sigmaMk_subset_sigma_right (hi : i ∈ s) : Sigma.mk i '' t i ⊆ s.sigma t :=\n  image_subset_iff.2 fun _ ↦ And.intro hi\n\n"}
{"name":"Set.sigma_subset_preimage_fst","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\n⊢ HasSubset.Subset (s.sigma t) (Set.preimage Sigma.fst s)","decl":"theorem sigma_subset_preimage_fst (s : Set ι) (t : ∀ i, Set (α i)) : s.sigma t ⊆ Sigma.fst ⁻¹' s :=\n  fun _ ↦ And.left\n\n"}
{"name":"Set.fst_image_sigma_subset","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns : Set ι\nt : (i : ι) → Set (α i)\n⊢ HasSubset.Subset (Set.image Sigma.fst (s.sigma t)) s","decl":"theorem fst_image_sigma_subset (s : Set ι) (t : ∀ i, Set (α i)) : Sigma.fst '' s.sigma t ⊆ s :=\n  image_subset_iff.2 fun _ ↦ And.left\n\n"}
{"name":"Set.fst_image_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\nt : (i : ι) → Set (α i)\ns : Set ι\nht : ∀ (i : ι), (t i).Nonempty\n⊢ Eq (Set.image Sigma.fst (s.sigma t)) s","decl":"theorem fst_image_sigma (s : Set ι) (ht : ∀ i, (t i).Nonempty) : Sigma.fst '' s.sigma t = s :=\n  (fst_image_sigma_subset _ _).antisymm fun i hi ↦\n    let ⟨a, ha⟩ := ht i\n    ⟨⟨i, a⟩, ⟨hi, ha⟩, rfl⟩\n\n"}
{"name":"Set.sigma_diff_sigma","module":"Mathlib.Data.Set.Sigma","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ns₁ s₂ : Set ι\nt₁ t₂ : (i : ι) → Set (α i)\n⊢ Eq (SDiff.sdiff (s₁.sigma t₁) (s₂.sigma t₂)) (Union.union (s₁.sigma (SDiff.sdiff t₁ t₂)) ((SDiff.sdiff s₁ s₂).sigma t₁))","decl":"theorem sigma_diff_sigma : s₁.sigma t₁ \\ s₂.sigma t₂ = s₁.sigma (t₁ \\ t₂) ∪ (s₁ \\ s₂).sigma t₁ :=\n  ext fun x ↦ by\n    by_cases h₁ : x.1 ∈ s₁ <;> by_cases h₂ : x.2 ∈ t₁ x.1 <;> simp [*, ← imp_iff_or_not]\n\n"}
