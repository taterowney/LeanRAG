{"name":"CharacterModule.instLinearMapClassIntAddCircleRatOfNat","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"A : Type uA\ninst✝ : AddCommGroup A\n⊢ LinearMapClass (CharacterModule A) Int A (AddCircle 1)","decl":"instance : LinearMapClass (CharacterModule A) ℤ A (AddCircle (1 : ℚ)) where\n  map_add _ _ _ := by rw [AddMonoidHom.map_add]\n  map_smulₛₗ _ _ _ := by rw [AddMonoidHom.map_zsmul, RingHom.id_apply]\n\n"}
{"name":"CharacterModule.ext_iff","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"A : Type uA\ninst✝ : AddCommGroup A\nc c' : CharacterModule A\n⊢ Iff (Eq c c') (∀ (x : A), Eq (c x) (c' x))","decl":"@[ext] theorem ext {c c' : CharacterModule A} (h : ∀ x, c x = c' x) : c = c' := DFunLike.ext _ _ h\n\n"}
{"name":"CharacterModule.ext","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"A : Type uA\ninst✝ : AddCommGroup A\nc c' : CharacterModule A\nh : ∀ (x : A), Eq (c x) (c' x)\n⊢ Eq c c'","decl":"@[ext] theorem ext {c c' : CharacterModule A} (h : ∀ x, c x = c' x) : c = c' := DFunLike.ext _ _ h\n\n"}
{"name":"CharacterModule.smul_apply","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝² : CommRing R\nA : Type uA\ninst✝¹ : AddCommGroup A\ninst✝ : Module R A\nc : CharacterModule A\nr : R\na : A\n⊢ Eq ((HSMul.hSMul r c) a) (c (HSMul.hSMul r a))","decl":"@[simp] lemma smul_apply (c : CharacterModule A) (r : R) (a : A) : (r • c) a = c (r • a) := rfl\n\n"}
{"name":"CharacterModule.dual_apply","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nB : Type uB\ninst✝² : AddCommGroup B\ninst✝¹ : Module R A\ninst✝ : Module R B\nf : LinearMap (RingHom.id R) A B\nL : CharacterModule B\n⊢ Eq ((CharacterModule.dual f) L) (AddMonoidHom.comp L f.toAddMonoidHom)","decl":"/--\nGiven an abelian group homomorphism `f : A → B`, `f⋆(L) := L ∘ f` defines a linear map\nfrom `B⋆` to `A⋆`.\n-/\n@[simps] def dual (f : A →ₗ[R] B) : CharacterModule B →ₗ[R] CharacterModule A where\n  toFun L := L.comp f.toAddMonoidHom\n  map_add' := by aesop\n  map_smul' r c := by ext x; exact congr(c $(f.map_smul r x)).symm\n\n"}
{"name":"CharacterModule.dual_zero","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nB : Type uB\ninst✝² : AddCommGroup B\ninst✝¹ : Module R A\ninst✝ : Module R B\n⊢ Eq (CharacterModule.dual 0) 0","decl":"@[simp]\nlemma dual_zero : dual (0 : A →ₗ[R] B) = 0 := by\n  ext f\n  exact map_zero f\n\n"}
{"name":"CharacterModule.dual_comp","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁶ : CommRing R\nA : Type uA\ninst✝⁵ : AddCommGroup A\nB : Type uB\ninst✝⁴ : AddCommGroup B\ninst✝³ : Module R A\ninst✝² : Module R B\nC : Type u_2\ninst✝¹ : AddCommGroup C\ninst✝ : Module R C\nf : LinearMap (RingHom.id R) A B\ng : LinearMap (RingHom.id R) B C\n⊢ Eq (CharacterModule.dual (g.comp f)) ((CharacterModule.dual f).comp (CharacterModule.dual g))","decl":"lemma dual_comp {C : Type*} [AddCommGroup C] [Module R C] (f : A →ₗ[R] B) (g : B →ₗ[R] C) :\n    dual (g.comp f) = (dual f).comp (dual g) := by\n  ext\n  rfl\n\n"}
{"name":"CharacterModule.dual_injective_of_surjective","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nB : Type uB\ninst✝² : AddCommGroup B\ninst✝¹ : Module R A\ninst✝ : Module R B\nf : LinearMap (RingHom.id R) A B\nhf : Function.Surjective ⇑f\n⊢ Function.Injective ⇑(CharacterModule.dual f)","decl":"lemma dual_injective_of_surjective (f : A →ₗ[R] B) (hf : Function.Surjective f) :\n    Function.Injective (dual f) := by\n  intro φ ψ eq\n  ext x\n  obtain ⟨y, rfl⟩ := hf x\n  change (dual f) φ _ = (dual f) ψ _\n  rw [eq]\n\n"}
{"name":"CharacterModule.dual_surjective_of_injective","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nB : Type uB\ninst✝² : AddCommGroup B\ninst✝¹ : Module R A\ninst✝ : Module R B\nf : LinearMap (RingHom.id R) A B\nhf : Function.Injective ⇑f\n⊢ Function.Surjective ⇑(CharacterModule.dual f)","decl":"lemma dual_surjective_of_injective (f : A →ₗ[R] B) (hf : Function.Injective f) :\n    Function.Surjective (dual f) :=\n  (Module.Baer.of_divisible _).extension_property_addMonoidHom _ hf\n\n"}
{"name":"CharacterModule.uncurry_apply","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nB : Type uB\ninst✝² : AddCommGroup B\ninst✝¹ : Module R A\ninst✝ : Module R B\nc : LinearMap (RingHom.id R) A (CharacterModule B)\n⊢ Eq (CharacterModule.uncurry c) (TensorProduct.liftAddHom c.toAddMonoidHom ⋯)","decl":"/--\nAny linear map `L : A → B⋆` induces a character in `(A ⊗ B)⋆` by `a ⊗ b ↦ L a b`.\n-/\n@[simps] noncomputable def uncurry :\n    (A →ₗ[R] CharacterModule B) →ₗ[R] CharacterModule (A ⊗[R] B) where\n  toFun c := TensorProduct.liftAddHom c.toAddMonoidHom fun r a b ↦ congr($(c.map_smul r a) b)\n  map_add' c c' := DFunLike.ext _ _ fun x ↦ by refine x.induction_on ?_ ?_ ?_ <;> aesop\n  map_smul' r c := DFunLike.ext _ _ fun x ↦ x.induction_on\n    (by simp_rw [map_zero]) (fun a b ↦ congr($(c.map_smul r a) b).symm) (by aesop)\n\n"}
{"name":"CharacterModule.curry_apply_apply","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nB : Type uB\ninst✝² : AddCommGroup B\ninst✝¹ : Module R A\ninst✝ : Module R B\nc : CharacterModule (TensorProduct R A B)\nx✝ : A\n⊢ Eq ((CharacterModule.curry c) x✝) (AddMonoidHom.comp c ↑((TensorProduct.mk R A B) x✝))","decl":"/--\nAny character `c` in `(A ⊗ B)⋆` induces a linear map `A → B⋆` by `a ↦ b ↦ c (a ⊗ b)`.\n-/\n@[simps] noncomputable def curry :\n    CharacterModule (A ⊗[R] B) →ₗ[R] (A →ₗ[R] CharacterModule B) where\n  toFun c :=\n  { toFun := (c.comp <| TensorProduct.mk R A B ·)\n    map_add' := fun _ _ ↦ DFunLike.ext _ _ fun b ↦\n      congr(c <| $(map_add (mk R A B) _ _) b).trans (c.map_add _ _)\n    map_smul' := fun r a ↦ by ext; exact congr(c $(TensorProduct.tmul_smul _ _ _)).symm }\n  map_add' _ _ := rfl\n  map_smul' r c := by ext; exact congr(c $(TensorProduct.tmul_smul _ _ _)).symm\n\n"}
{"name":"CharacterModule.homEquiv_symm_apply_apply_apply","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nB : Type uB\ninst✝² : AddCommGroup B\ninst✝¹ : Module R A\ninst✝ : Module R B\na : CharacterModule (TensorProduct R A B)\nx✝ : A\na✝ : B\n⊢ Eq (((CharacterModule.homEquiv.symm a) x✝) a✝) (a (TensorProduct.tmul R x✝ a✝))","decl":"/--\nLinear maps into a character module are exactly characters of the tensor product.\n-/\n@[simps!] noncomputable def homEquiv :\n    (A →ₗ[R] CharacterModule B) ≃ₗ[R] CharacterModule (A ⊗[R] B) :=\n  .ofLinear uncurry curry (by ext _ z; refine z.induction_on ?_ ?_ ?_ <;> aesop) (by aesop)\n\n"}
{"name":"CharacterModule.homEquiv_apply_apply","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nB : Type uB\ninst✝² : AddCommGroup B\ninst✝¹ : Module R A\ninst✝ : Module R B\nc : LinearMap (RingHom.id R) A (CharacterModule B)\nx : (addConGen (TensorProduct.Eqv R A B)).Quotient\n⊢ Eq ((CharacterModule.homEquiv c) x) (AddCon.liftOn x ⇑(FreeAddMonoid.lift fun mn => (c.toAddMonoidHom mn.1) mn.2) ⋯)","decl":"/--\nLinear maps into a character module are exactly characters of the tensor product.\n-/\n@[simps!] noncomputable def homEquiv :\n    (A →ₗ[R] CharacterModule B) ≃ₗ[R] CharacterModule (A ⊗[R] B) :=\n  .ofLinear uncurry curry (by ext _ z; refine z.induction_on ?_ ?_ ?_ <;> aesop) (by aesop)\n\n"}
{"name":"CharacterModule.dual_rTensor_conj_homEquiv","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁶ : CommRing R\nA : Type uA\ninst✝⁵ : AddCommGroup A\nA' : Type u_1\ninst✝⁴ : AddCommGroup A'\nB : Type uB\ninst✝³ : AddCommGroup B\ninst✝² : Module R A\ninst✝¹ : Module R A'\ninst✝ : Module R B\nf : LinearMap (RingHom.id R) A A'\n⊢ Eq ((↑CharacterModule.homEquiv.symm).comp ((CharacterModule.dual (LinearMap.rTensor B f)).comp ↑CharacterModule.homEquiv)) (LinearMap.lcomp R (CharacterModule B) f)","decl":"theorem dual_rTensor_conj_homEquiv (f : A →ₗ[R] A') :\n    homEquiv.symm.toLinearMap ∘ₗ dual (f.rTensor B) ∘ₗ homEquiv.toLinearMap = f.lcomp R _ := rfl\n\n"}
{"name":"CharacterModule.int.divByNat_self","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"n : Nat\n⊢ Eq ((CharacterModule.int.divByNat n) ↑n) 0","decl":"protected lemma int.divByNat_self (n : ℕ) :\n    int.divByNat n n = 0 := by\n  obtain rfl | h0 := eq_or_ne n 0\n  · apply map_zero\n  exact (AddCircle.coe_eq_zero_iff _).mpr\n    ⟨1, by simp [mul_inv_cancel₀ (Nat.cast_ne_zero (R := ℚ).mpr h0)]⟩\n\n"}
{"name":"CharacterModule.intSpanEquivQuotAddOrderOf_apply","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"A : Type uA\ninst✝ : AddCommGroup A\na : A\na✝ : Subtype fun x => Membership.mem (Submodule.span Int (Singleton.singleton a)) x\n⊢ Eq ((CharacterModule.intSpanEquivQuotAddOrderOf a) a✝) (((LinearMap.ker (LinearMap.toSpanSingleton Int A a)).quotEquivOfEq (Ideal.span (Singleton.singleton ↑(addOrderOf a))) ⋯) ((LinearMap.toSpanSingleton Int A a).quotKerEquivRange.symm ((LinearEquiv.ofEq (Submodule.span Int (Singleton.singleton a)) (LinearMap.range (LinearMap.toSpanSingleton Int A a)) ⋯) a✝)))","decl":"/-- The `ℤ`-submodule spanned by a single element `a` is isomorphic to the quotient of `ℤ`\nby the ideal generated by the order of `a`. -/\n@[simps!] noncomputable def intSpanEquivQuotAddOrderOf (a : A) :\n    (ℤ ∙ a) ≃ₗ[ℤ] ℤ ⧸ Ideal.span {(addOrderOf a : ℤ)} :=\n  LinearEquiv.ofEq _ _ (LinearMap.span_singleton_eq_range ℤ A a) ≪≫ₗ\n  (LinearMap.quotKerEquivRange <| LinearMap.toSpanSingleton ℤ A a).symm ≪≫ₗ\n  Submodule.quotEquivOfEq _ _ (by\n    ext1 x\n    rw [Ideal.mem_span_singleton, addOrderOf_dvd_iff_zsmul_eq_zero, LinearMap.mem_ker,\n      LinearMap.toSpanSingleton_apply])\n\n"}
{"name":"CharacterModule.intSpanEquivQuotAddOrderOf_symm_apply_coe","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"A : Type uA\ninst✝ : AddCommGroup A\na : A\na✝ : HasQuotient.Quotient Int (Ideal.span (Singleton.singleton ↑(addOrderOf a)))\n⊢ Eq ↑((CharacterModule.intSpanEquivQuotAddOrderOf a).symm a✝) ↑((LinearMap.toSpanSingleton Int A a).quotKerEquivRange (((LinearMap.ker (LinearMap.toSpanSingleton Int A a)).quotEquivOfEq (Ideal.span (Singleton.singleton ↑(addOrderOf a))) ⋯).symm a✝))","decl":"/-- The `ℤ`-submodule spanned by a single element `a` is isomorphic to the quotient of `ℤ`\nby the ideal generated by the order of `a`. -/\n@[simps!] noncomputable def intSpanEquivQuotAddOrderOf (a : A) :\n    (ℤ ∙ a) ≃ₗ[ℤ] ℤ ⧸ Ideal.span {(addOrderOf a : ℤ)} :=\n  LinearEquiv.ofEq _ _ (LinearMap.span_singleton_eq_range ℤ A a) ≪≫ₗ\n  (LinearMap.quotKerEquivRange <| LinearMap.toSpanSingleton ℤ A a).symm ≪≫ₗ\n  Submodule.quotEquivOfEq _ _ (by\n    ext1 x\n    rw [Ideal.mem_span_singleton, addOrderOf_dvd_iff_zsmul_eq_zero, LinearMap.mem_ker,\n      LinearMap.toSpanSingleton_apply])\n\n"}
{"name":"CharacterModule.intSpanEquivQuotAddOrderOf_apply_self","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"A : Type uA\ninst✝ : AddCommGroup A\na : A\n⊢ Eq ((CharacterModule.intSpanEquivQuotAddOrderOf a) ⟨a, ⋯⟩) (Submodule.Quotient.mk 1)","decl":"lemma intSpanEquivQuotAddOrderOf_apply_self (a : A) :\n    intSpanEquivQuotAddOrderOf a ⟨a, Submodule.mem_span_singleton_self a⟩ =\n    Submodule.Quotient.mk 1 :=\n  (LinearEquiv.eq_symm_apply _).mp <| Subtype.ext (one_zsmul _).symm\n\n"}
{"name":"CharacterModule.eq_zero_of_ofSpanSingleton_apply_self","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"A : Type uA\ninst✝ : AddCommGroup A\na : A\nh : Eq ((CharacterModule.ofSpanSingleton a) ⟨a, ⋯⟩) 0\n⊢ Eq a 0","decl":"lemma eq_zero_of_ofSpanSingleton_apply_self (a : A)\n    (h : ofSpanSingleton a ⟨a, Submodule.mem_span_singleton_self a⟩ = 0) : a = 0 := by\n  erw [ofSpanSingleton, LinearMap.toAddMonoidHom_coe, LinearMap.comp_apply,\n     intSpanEquivQuotAddOrderOf_apply_self, Submodule.liftQSpanSingleton_apply,\n    AddMonoidHom.coe_toIntLinearMap, int.divByNat, LinearMap.toSpanSingleton_one,\n    AddCircle.coe_eq_zero_iff] at h\n  rcases h with ⟨n, hn⟩\n  apply_fun Rat.den at hn\n  rw [zsmul_one, Rat.den_intCast, Rat.inv_natCast_den_of_pos] at hn\n  · split_ifs at hn\n    · cases hn\n    · rwa [eq_comm, AddMonoid.addOrderOf_eq_one_iff] at hn\n  · split_ifs with h\n    · norm_num\n    · exact Nat.pos_of_ne_zero h\n\n"}
{"name":"CharacterModule.exists_character_apply_ne_zero_of_ne_zero","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"A : Type uA\ninst✝ : AddCommGroup A\na : A\nne_zero : Ne a 0\n⊢ Exists fun c => Ne (c a) 0","decl":"lemma exists_character_apply_ne_zero_of_ne_zero {a : A} (ne_zero : a ≠ 0) :\n    ∃ (c : CharacterModule A), c a ≠ 0 :=\n  have ⟨c, hc⟩ := dual_surjective_of_injective _ (Submodule.injective_subtype _) (ofSpanSingleton a)\n  ⟨c, fun h ↦ ne_zero <| eq_zero_of_ofSpanSingleton_apply_self a <| by rwa [← hc]⟩\n\n"}
{"name":"CharacterModule.eq_zero_of_character_apply","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"A : Type uA\ninst✝ : AddCommGroup A\na : A\nh : ∀ (c : CharacterModule A), Eq (c a) 0\n⊢ Eq a 0","decl":"lemma eq_zero_of_character_apply {a : A} (h : ∀ c : CharacterModule A, c a = 0) : a = 0 := by\n  contrapose! h; exact exists_character_apply_ne_zero_of_ne_zero h\n\n"}
{"name":"CharacterModule.dual_surjective_iff_injective","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nA' : Type u_1\ninst✝² : AddCommGroup A'\ninst✝¹ : Module R A\ninst✝ : Module R A'\nf : LinearMap (RingHom.id R) A A'\n⊢ Iff (Function.Surjective ⇑(CharacterModule.dual f)) (Function.Injective ⇑f)","decl":"lemma dual_surjective_iff_injective {f : A →ₗ[R] A'} :\n    Function.Surjective (dual f) ↔ Function.Injective f :=\n  ⟨fun h ↦ (injective_iff_map_eq_zero _).2 fun a h0 ↦ eq_zero_of_character_apply fun c ↦ by\n    obtain ⟨c, rfl⟩ := h c; exact congr(c $h0).trans c.map_zero,\n  dual_surjective_of_injective f⟩\n\n"}
{"name":"rTensor_injective_iff_lcomp_surjective","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁶ : CommRing R\nA : Type uA\ninst✝⁵ : AddCommGroup A\nA' : Type u_1\ninst✝⁴ : AddCommGroup A'\nB : Type uB\ninst✝³ : AddCommGroup B\ninst✝² : Module R A\ninst✝¹ : Module R A'\ninst✝ : Module R B\nf : LinearMap (RingHom.id R) A A'\n⊢ Iff (Function.Injective ⇑(LinearMap.rTensor B f)) (Function.Surjective ⇑(LinearMap.lcomp R (CharacterModule B) f))","decl":"theorem _root_.rTensor_injective_iff_lcomp_surjective {f : A →ₗ[R] A'} :\n    Function.Injective (f.rTensor B) ↔ Function.Surjective (f.lcomp R <| CharacterModule B) := by\n  simp [← dual_rTensor_conj_homEquiv, dual_surjective_iff_injective]\n\n"}
{"name":"CharacterModule.surjective_of_dual_injective","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nA' : Type u_1\ninst✝² : AddCommGroup A'\ninst✝¹ : Module R A\ninst✝ : Module R A'\nf : LinearMap (RingHom.id R) A A'\nhf : Function.Injective ⇑(CharacterModule.dual f)\n⊢ Function.Surjective ⇑f","decl":"lemma surjective_of_dual_injective (f : A →ₗ[R] A') (hf : Function.Injective (dual f)) :\n    Function.Surjective f := by\n  rw [← LinearMap.range_eq_top, ← Submodule.unique_quotient_iff_eq_top]\n  refine ⟨Unique.mk inferInstance fun a ↦ eq_zero_of_character_apply fun c ↦ ?_⟩\n  obtain ⟨b, rfl⟩ := QuotientAddGroup.mk'_surjective _ a\n  suffices eq : dual (Submodule.mkQ _) c = 0 from congr($eq b)\n  refine hf ?_\n  rw [← LinearMap.comp_apply, ← dual_comp, LinearMap.range_mkQ_comp, dual_zero]\n  rfl\n\n"}
{"name":"CharacterModule.dual_injective_iff_surjective","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nA' : Type u_1\ninst✝² : AddCommGroup A'\ninst✝¹ : Module R A\ninst✝ : Module R A'\nf : LinearMap (RingHom.id R) A A'\n⊢ Iff (Function.Injective ⇑(CharacterModule.dual f)) (Function.Surjective ⇑f)","decl":"lemma dual_injective_iff_surjective {f : A →ₗ[R] A'} :\n    Function.Injective (dual f) ↔ Function.Surjective f :=\n  ⟨fun h ↦ surjective_of_dual_injective f h, fun h ↦ dual_injective_of_surjective f h⟩\n\n"}
{"name":"CharacterModule.dual_bijective_iff_bijective","module":"Mathlib.Algebra.Module.CharacterModule","initialProofState":"R : Type uR\ninst✝⁴ : CommRing R\nA : Type uA\ninst✝³ : AddCommGroup A\nA' : Type u_1\ninst✝² : AddCommGroup A'\ninst✝¹ : Module R A\ninst✝ : Module R A'\nf : LinearMap (RingHom.id R) A A'\n⊢ Iff (Function.Bijective ⇑(CharacterModule.dual f)) (Function.Bijective ⇑f)","decl":"lemma dual_bijective_iff_bijective {f : A →ₗ[R] A'} :\n    Function.Bijective (dual f) ↔ Function.Bijective f :=\n  ⟨fun h ↦ ⟨dual_surjective_iff_injective.mp h.2, dual_injective_iff_surjective.mp h.1⟩,\n  fun h ↦ ⟨dual_injective_iff_surjective.mpr h.2, dual_surjective_iff_injective.mpr h.1⟩⟩\n\n"}
