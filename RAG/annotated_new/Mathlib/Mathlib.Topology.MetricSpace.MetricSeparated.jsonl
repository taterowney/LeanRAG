{"name":"IsMetricSeparated.symm","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t : Set X\nh : IsMetricSeparated s t\n⊢ IsMetricSeparated t s","decl":"@[symm]\ntheorem symm (h : IsMetricSeparated s t) : IsMetricSeparated t s :=\n  let ⟨r, r0, hr⟩ := h\n  ⟨r, r0, fun y hy x hx => edist_comm x y ▸ hr x hx y hy⟩\n\n"}
{"name":"IsMetricSeparated.comm","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t : Set X\n⊢ Iff (IsMetricSeparated s t) (IsMetricSeparated t s)","decl":"theorem comm : IsMetricSeparated s t ↔ IsMetricSeparated t s :=\n  ⟨symm, symm⟩\n\n"}
{"name":"IsMetricSeparated.empty_left","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns : Set X\n⊢ IsMetricSeparated EmptyCollection.emptyCollection s","decl":"@[simp]\ntheorem empty_left (s : Set X) : IsMetricSeparated ∅ s :=\n  ⟨1, one_ne_zero, fun _x => False.elim⟩\n\n"}
{"name":"IsMetricSeparated.empty_right","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns : Set X\n⊢ IsMetricSeparated s EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem empty_right (s : Set X) : IsMetricSeparated s ∅ :=\n  (empty_left s).symm\n\n"}
{"name":"IsMetricSeparated.disjoint","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t : Set X\nh : IsMetricSeparated s t\n⊢ Disjoint s t","decl":"protected theorem disjoint (h : IsMetricSeparated s t) : Disjoint s t :=\n  let ⟨r, r0, hr⟩ := h\n  Set.disjoint_left.mpr fun x hx1 hx2 => r0 <| by simpa using hr x hx1 x hx2\n\n"}
{"name":"IsMetricSeparated.subset_compl_right","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t : Set X\nh : IsMetricSeparated s t\n⊢ HasSubset.Subset s (HasCompl.compl t)","decl":"theorem subset_compl_right (h : IsMetricSeparated s t) : s ⊆ tᶜ := fun _ hs ht =>\n  h.disjoint.le_bot ⟨hs, ht⟩\n\n"}
{"name":"IsMetricSeparated.mono","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t s' t' : Set X\nhs : HasSubset.Subset s s'\nht : HasSubset.Subset t t'\na✝ : IsMetricSeparated s' t'\n⊢ IsMetricSeparated s t","decl":"@[mono]\ntheorem mono {s' t'} (hs : s ⊆ s') (ht : t ⊆ t') :\n    IsMetricSeparated s' t' → IsMetricSeparated s t := fun ⟨r, r0, hr⟩ =>\n  ⟨r, r0, fun x hx y hy => hr x (hs hx) y (ht hy)⟩\n\n"}
{"name":"IsMetricSeparated.mono_left","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t s' : Set X\nh' : IsMetricSeparated s' t\nhs : HasSubset.Subset s s'\n⊢ IsMetricSeparated s t","decl":"theorem mono_left {s'} (h' : IsMetricSeparated s' t) (hs : s ⊆ s') : IsMetricSeparated s t :=\n  h'.mono hs Subset.rfl\n\n"}
{"name":"IsMetricSeparated.mono_right","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t t' : Set X\nh' : IsMetricSeparated s t'\nht : HasSubset.Subset t t'\n⊢ IsMetricSeparated s t","decl":"theorem mono_right {t'} (h' : IsMetricSeparated s t') (ht : t ⊆ t') : IsMetricSeparated s t :=\n  h'.mono Subset.rfl ht\n\n"}
{"name":"IsMetricSeparated.union_left","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t s' : Set X\nh : IsMetricSeparated s t\nh' : IsMetricSeparated s' t\n⊢ IsMetricSeparated (Union.union s s') t","decl":"theorem union_left {s'} (h : IsMetricSeparated s t) (h' : IsMetricSeparated s' t) :\n    IsMetricSeparated (s ∪ s') t := by\n  rcases h, h' with ⟨⟨r, r0, hr⟩, ⟨r', r0', hr'⟩⟩\n  refine ⟨min r r', ?_, fun x hx y hy => hx.elim ?_ ?_⟩\n  · rw [← pos_iff_ne_zero] at r0 r0' ⊢\n    exact lt_min r0 r0'\n  · exact fun hx => (min_le_left _ _).trans (hr _ hx _ hy)\n  · exact fun hx => (min_le_right _ _).trans (hr' _ hx _ hy)\n\n"}
{"name":"IsMetricSeparated.union_left_iff","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t s' : Set X\n⊢ Iff (IsMetricSeparated (Union.union s s') t) (And (IsMetricSeparated s t) (IsMetricSeparated s' t))","decl":"@[simp]\ntheorem union_left_iff {s'} :\n    IsMetricSeparated (s ∪ s') t ↔ IsMetricSeparated s t ∧ IsMetricSeparated s' t :=\n  ⟨fun h => ⟨h.mono_left subset_union_left, h.mono_left subset_union_right⟩, fun h =>\n    h.1.union_left h.2⟩\n\n"}
{"name":"IsMetricSeparated.union_right","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t t' : Set X\nh : IsMetricSeparated s t\nh' : IsMetricSeparated s t'\n⊢ IsMetricSeparated s (Union.union t t')","decl":"theorem union_right {t'} (h : IsMetricSeparated s t) (h' : IsMetricSeparated s t') :\n    IsMetricSeparated s (t ∪ t') :=\n  (h.symm.union_left h'.symm).symm\n\n"}
{"name":"IsMetricSeparated.union_right_iff","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\ns t t' : Set X\n⊢ Iff (IsMetricSeparated s (Union.union t t')) (And (IsMetricSeparated s t) (IsMetricSeparated s t'))","decl":"@[simp]\ntheorem union_right_iff {t'} :\n    IsMetricSeparated s (t ∪ t') ↔ IsMetricSeparated s t ∧ IsMetricSeparated s t' :=\n  comm.trans <| union_left_iff.trans <| and_congr comm comm\n\n"}
{"name":"IsMetricSeparated.finite_iUnion_left_iff","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\nι : Type u_2\nI : Set ι\nhI : I.Finite\ns : ι → Set X\nt : Set X\n⊢ Iff (IsMetricSeparated (Set.iUnion fun i => Set.iUnion fun h => s i) t) (∀ (i : ι), Membership.mem I i → IsMetricSeparated (s i) t)","decl":"theorem finite_iUnion_left_iff {ι : Type*} {I : Set ι} (hI : I.Finite) {s : ι → Set X}\n    {t : Set X} : IsMetricSeparated (⋃ i ∈ I, s i) t ↔ ∀ i ∈ I, IsMetricSeparated (s i) t := by\n  refine Finite.induction_on _ hI (by simp) @fun i I _ _ hI => ?_\n  rw [biUnion_insert, forall_mem_insert, union_left_iff, hI]\n\n"}
{"name":"IsMetricSeparated.finite_iUnion_left","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\nι : Type u_2\nI : Set ι\nhI : I.Finite\ns : ι → Set X\nt : Set X\na✝ : ∀ (i : ι), Membership.mem I i → IsMetricSeparated (s i) t\n⊢ IsMetricSeparated (Set.iUnion fun i => Set.iUnion fun h => s i) t","decl":"alias ⟨_, finite_iUnion_left⟩ := finite_iUnion_left_iff\n\n"}
{"name":"IsMetricSeparated.finite_iUnion_right_iff","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\nι : Type u_2\nI : Set ι\nhI : I.Finite\ns : Set X\nt : ι → Set X\n⊢ Iff (IsMetricSeparated s (Set.iUnion fun i => Set.iUnion fun h => t i)) (∀ (i : ι), Membership.mem I i → IsMetricSeparated s (t i))","decl":"theorem finite_iUnion_right_iff {ι : Type*} {I : Set ι} (hI : I.Finite) {s : Set X}\n    {t : ι → Set X} : IsMetricSeparated s (⋃ i ∈ I, t i) ↔ ∀ i ∈ I, IsMetricSeparated s (t i) := by\n  simpa only [@comm _ _ s] using finite_iUnion_left_iff hI\n\n"}
{"name":"IsMetricSeparated.finset_iUnion_left_iff","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\nι : Type u_2\nI : Finset ι\ns : ι → Set X\nt : Set X\n⊢ Iff (IsMetricSeparated (Set.iUnion fun i => Set.iUnion fun h => s i) t) (∀ (i : ι), Membership.mem I i → IsMetricSeparated (s i) t)","decl":"@[simp]\ntheorem finset_iUnion_left_iff {ι : Type*} {I : Finset ι} {s : ι → Set X} {t : Set X} :\n    IsMetricSeparated (⋃ i ∈ I, s i) t ↔ ∀ i ∈ I, IsMetricSeparated (s i) t :=\n  finite_iUnion_left_iff I.finite_toSet\n\n"}
{"name":"IsMetricSeparated.finset_iUnion_left","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\nι : Type u_2\nI : Finset ι\ns : ι → Set X\nt : Set X\na✝ : ∀ (i : ι), Membership.mem I i → IsMetricSeparated (s i) t\n⊢ IsMetricSeparated (Set.iUnion fun i => Set.iUnion fun h => s i) t","decl":"alias ⟨_, finset_iUnion_left⟩ := finset_iUnion_left_iff\n\n"}
{"name":"IsMetricSeparated.finset_iUnion_right_iff","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\nι : Type u_2\nI : Finset ι\ns : Set X\nt : ι → Set X\n⊢ Iff (IsMetricSeparated s (Set.iUnion fun i => Set.iUnion fun h => t i)) (∀ (i : ι), Membership.mem I i → IsMetricSeparated s (t i))","decl":"@[simp]\ntheorem finset_iUnion_right_iff {ι : Type*} {I : Finset ι} {s : Set X} {t : ι → Set X} :\n    IsMetricSeparated s (⋃ i ∈ I, t i) ↔ ∀ i ∈ I, IsMetricSeparated s (t i) :=\n  finite_iUnion_right_iff I.finite_toSet\n\n"}
{"name":"IsMetricSeparated.finset_iUnion_right","module":"Mathlib.Topology.MetricSpace.MetricSeparated","initialProofState":"X : Type u_1\ninst✝ : EMetricSpace X\nι : Type u_2\nI : Finset ι\ns : Set X\nt : ι → Set X\na✝ : ∀ (i : ι), Membership.mem I i → IsMetricSeparated s (t i)\n⊢ IsMetricSeparated s (Set.iUnion fun i => Set.iUnion fun h => t i)","decl":"alias ⟨_, finset_iUnion_right⟩ := finset_iUnion_right_iff\n\n"}
