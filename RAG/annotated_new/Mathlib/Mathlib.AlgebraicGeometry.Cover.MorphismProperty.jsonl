{"name":"AlgebraicGeometry.Scheme.Cover.covers","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.Cover P X\nx : ↑↑X.toPresheafedSpace\n⊢ Membership.mem (Set.range ⇑(self.map (self.f x)).base) x","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mk.inj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ✝ : Type v\nobj✝ : J✝ → AlgebraicGeometry.Scheme\nmap✝ : (j : J✝) → Quiver.Hom (obj✝ j) X\nf✝ : ↑↑X.toPresheafedSpace → J✝\ncovers✝ : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map✝ (f✝ x)).base) x\nmap_prop✝ : autoParam (∀ (j : J✝), P (map✝ j)) _auto✝\nJ : Type v\nobj : J → AlgebraicGeometry.Scheme\nmap : (j : J) → Quiver.Hom (obj j) X\nf : ↑↑X.toPresheafedSpace → J\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map (f x)).base) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\nx✝ : Eq { J := J✝, obj := obj✝, map := map✝, f := f✝, covers := covers✝, map_prop := map_prop✝ } { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }\n⊢ And (Eq J✝ J) (And (HEq obj✝ obj) (And (HEq map✝ map) (HEq f✝ f)))","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mk.injEq","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ✝ : Type v\nobj✝ : J✝ → AlgebraicGeometry.Scheme\nmap✝ : (j : J✝) → Quiver.Hom (obj✝ j) X\nf✝ : ↑↑X.toPresheafedSpace → J✝\ncovers✝ : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map✝ (f✝ x)).base) x\nmap_prop✝ : autoParam (∀ (j : J✝), P (map✝ j)) _auto✝\nJ : Type v\nobj : J → AlgebraicGeometry.Scheme\nmap : (j : J) → Quiver.Hom (obj j) X\nf : ↑↑X.toPresheafedSpace → J\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map (f x)).base) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\n⊢ Eq (Eq { J := J✝, obj := obj✝, map := map✝, f := f✝, covers := covers✝, map_prop := map_prop✝ } { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }) (And (Eq J✝ J) (And (HEq obj✝ obj) (And (HEq map✝ map) (HEq f✝ f))))","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.map_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.Cover P X\nj : self.J\n⊢ P (self.map j)","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\ninst✝ : ⦃X Y : AlgebraicGeometry.Scheme⦄ → (x : Quiver.Hom X Y) → SizeOf (P x)\nJ : Type v\nobj : J → AlgebraicGeometry.Scheme\nmap : (j : J) → Quiver.Hom (obj j) X\nf : ↑↑X.toPresheafedSpace → J\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map (f x)).base) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\n⊢ Eq (SizeOf.sizeOf { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.iUnion_range","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\n⊢ Eq (Set.iUnion fun i => Set.range ⇑(𝒰.map i).base) Set.univ","decl":"theorem Cover.iUnion_range {X : Scheme.{u}} (𝒰 : X.Cover P) :\n    ⋃ i, Set.range (𝒰.map i).base = Set.univ := by\n  rw [Set.eq_univ_iff_forall]\n  intro x\n  rw [Set.mem_iUnion]\n  exact ⟨𝒰.f x, 𝒰.covers x⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.exists_eq","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nx : ↑↑X.toPresheafedSpace\n⊢ Exists fun i => Exists fun y => Eq ((𝒰.map i).base y) x","decl":"lemma Cover.exists_eq (𝒰 : X.Cover P) (x : X) : ∃ i y, (𝒰.map i).base y = x :=\n  ⟨_, 𝒰.covers x⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mkOfCovers_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ : Type u_1\nobj : J → AlgebraicGeometry.Scheme\nmap : (j : J) → Quiver.Hom (obj j) X\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Exists fun j => Exists fun y => Eq ((map j).base y) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\na✝ : J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.mkOfCovers J obj map covers map_prop).obj a✝) (obj a✝)","decl":"/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly\ncover `X`, this an associated `P`-cover of `X`. -/\n@[simps]\ndef Cover.mkOfCovers (J : Type*) (obj : J → Scheme.{u}) (map : (j : J) → obj j ⟶ X)\n    (covers : ∀ x, ∃ j y, (map j).base y = x)\n    (map_prop : ∀ j, P (map j) := by infer_instance) : X.Cover P where\n  J := J\n  obj := obj\n  map := map\n  f x := (covers x).choose\n  covers x := (covers x).choose_spec\n  map_prop := map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mkOfCovers_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ : Type u_1\nobj : J → AlgebraicGeometry.Scheme\nmap : (j : J) → Quiver.Hom (obj j) X\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Exists fun j => Exists fun y => Eq ((map j).base y) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\nj : J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.mkOfCovers J obj map covers map_prop).map j) (map j)","decl":"/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly\ncover `X`, this an associated `P`-cover of `X`. -/\n@[simps]\ndef Cover.mkOfCovers (J : Type*) (obj : J → Scheme.{u}) (map : (j : J) → obj j ⟶ X)\n    (covers : ∀ x, ∃ j y, (map j).base y = x)\n    (map_prop : ∀ j, P (map j) := by infer_instance) : X.Cover P where\n  J := J\n  obj := obj\n  map := map\n  f x := (covers x).choose\n  covers x := (covers x).choose_spec\n  map_prop := map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mkOfCovers_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ : Type u_1\nobj : J → AlgebraicGeometry.Scheme\nmap : (j : J) → Quiver.Hom (obj j) X\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Exists fun j => Exists fun y => Eq ((map j).base y) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\nx : ↑↑X.toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.mkOfCovers J obj map covers map_prop).f x) ⋯.choose","decl":"/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly\ncover `X`, this an associated `P`-cover of `X`. -/\n@[simps]\ndef Cover.mkOfCovers (J : Type*) (obj : J → Scheme.{u}) (map : (j : J) → obj j ⟶ X)\n    (covers : ∀ x, ∃ j y, (map j).base y = x)\n    (map_prop : ∀ j, P (map j) := by infer_instance) : X.Cover P where\n  J := J\n  obj := obj\n  map := map\n  f x := (covers x).choose\n  covers x := (covers x).choose_spec\n  map_prop := map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mkOfCovers_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ : Type u_1\nobj : J → AlgebraicGeometry.Scheme\nmap : (j : J) → Quiver.Hom (obj j) X\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Exists fun j => Exists fun y => Eq ((map j).base y) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\n⊢ Eq (AlgebraicGeometry.Scheme.Cover.mkOfCovers J obj map covers map_prop).J J","decl":"/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly\ncover `X`, this an associated `P`-cover of `X`. -/\n@[simps]\ndef Cover.mkOfCovers (J : Type*) (obj : J → Scheme.{u}) (map : (j : J) → obj j ⟶ X)\n    (covers : ∀ x, ∃ j y, (map j).base y = x)\n    (map_prop : ∀ j, P (map j) := by infer_instance) : X.Cover P where\n  J := J\n  obj := obj\n  map := map\n  f x := (covers x).choose\n  covers x := (covers x).choose_spec\n  map_prop := map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.bind_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\ninst✝ : P.IsStableUnderComposition\nf : (x : 𝒰.J) → AlgebraicGeometry.Scheme.Cover P (𝒰.obj x)\nx : Sigma fun i => (f i).J\n⊢ Eq ((𝒰.bind f).map x) (CategoryTheory.CategoryStruct.comp ((f x.fst).map x.snd) (𝒰.map x.fst))","decl":"/-- Given a `P`-cover `{ Uᵢ }` of `X`, and for each `Uᵢ` a `P`-cover, we may combine these\ncovers to form a `P`-cover of `X`. -/\n@[simps! J obj map]\ndef Cover.bind [P.IsStableUnderComposition] (f : ∀ x : 𝒰.J, (𝒰.obj x).Cover P) : X.Cover P where\n  J := Σ i : 𝒰.J, (f i).J\n  obj x := (f x.1).obj x.2\n  map x := (f x.1).map x.2 ≫ 𝒰.map x.1\n  f x := ⟨_, (f _).f (𝒰.covers x).choose⟩\n  covers x := by\n    let y := (𝒰.covers x).choose\n    have hy : (𝒰.map (𝒰.f x)).base y = x := (𝒰.covers x).choose_spec\n    rcases (f (𝒰.f x)).covers y with ⟨z, hz⟩\n    change x ∈ Set.range ((f (𝒰.f x)).map ((f (𝒰.f x)).f y) ≫ 𝒰.map (𝒰.f x)).base\n    use z\n    erw [CategoryTheory.comp_apply]\n    rw [hz, hy]\n  map_prop _ := P.comp_mem _ _ ((f _).map_prop _) (𝒰.map_prop _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.bind_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\ninst✝ : P.IsStableUnderComposition\nf : (x : 𝒰.J) → AlgebraicGeometry.Scheme.Cover P (𝒰.obj x)\nx : Sigma fun i => (f i).J\n⊢ Eq ((𝒰.bind f).obj x) ((f x.fst).obj x.snd)","decl":"/-- Given a `P`-cover `{ Uᵢ }` of `X`, and for each `Uᵢ` a `P`-cover, we may combine these\ncovers to form a `P`-cover of `X`. -/\n@[simps! J obj map]\ndef Cover.bind [P.IsStableUnderComposition] (f : ∀ x : 𝒰.J, (𝒰.obj x).Cover P) : X.Cover P where\n  J := Σ i : 𝒰.J, (f i).J\n  obj x := (f x.1).obj x.2\n  map x := (f x.1).map x.2 ≫ 𝒰.map x.1\n  f x := ⟨_, (f _).f (𝒰.covers x).choose⟩\n  covers x := by\n    let y := (𝒰.covers x).choose\n    have hy : (𝒰.map (𝒰.f x)).base y = x := (𝒰.covers x).choose_spec\n    rcases (f (𝒰.f x)).covers y with ⟨z, hz⟩\n    change x ∈ Set.range ((f (𝒰.f x)).map ((f (𝒰.f x)).f y) ≫ 𝒰.map (𝒰.f x)).base\n    use z\n    erw [CategoryTheory.comp_apply]\n    rw [hz, hy]\n  map_prop _ := P.comp_mem _ _ ((f _).map_prop _) (𝒰.map_prop _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.bind_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\ninst✝ : P.IsStableUnderComposition\nf : (x : 𝒰.J) → AlgebraicGeometry.Scheme.Cover P (𝒰.obj x)\n⊢ Eq (𝒰.bind f).J (Sigma fun i => (f i).J)","decl":"/-- Given a `P`-cover `{ Uᵢ }` of `X`, and for each `Uᵢ` a `P`-cover, we may combine these\ncovers to form a `P`-cover of `X`. -/\n@[simps! J obj map]\ndef Cover.bind [P.IsStableUnderComposition] (f : ∀ x : 𝒰.J, (𝒰.obj x).Cover P) : X.Cover P where\n  J := Σ i : 𝒰.J, (f i).J\n  obj x := (f x.1).obj x.2\n  map x := (f x.1).map x.2 ≫ 𝒰.map x.1\n  f x := ⟨_, (f _).f (𝒰.covers x).choose⟩\n  covers x := by\n    let y := (𝒰.covers x).choose\n    have hy : (𝒰.map (𝒰.f x)).base y = x := (𝒰.covers x).choose_spec\n    rcases (f (𝒰.f x)).covers y with ⟨z, hz⟩\n    change x ∈ Set.range ((f (𝒰.f x)).map ((f (𝒰.f x)).f y) ≫ 𝒰.map (𝒰.f x)).base\n    use z\n    erw [CategoryTheory.comp_apply]\n    rw [hz, hy]\n  map_prop _ := P.comp_mem _ _ ((f _).map_prop _) (𝒰.map_prop _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.coverOfIsIso_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.ContainsIdentities\ninst✝¹ : P.RespectsIso\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (AlgebraicGeometry.Scheme.coverOfIsIso f).J PUnit.{v + 1}","decl":"/-- An isomorphism `X ⟶ Y` is a `P`-cover of `Y`. -/\n@[simps J obj map]\ndef coverOfIsIso [P.ContainsIdentities] [P.RespectsIso] {X Y : Scheme.{u}} (f : X ⟶ Y)\n    [IsIso f] : Cover.{v} P Y where\n  J := PUnit.{v + 1}\n  obj _ := X\n  map _ := f\n  f _ := PUnit.unit\n  covers x := by\n    rw [Set.range_eq_univ.mpr]\n    all_goals try trivial\n    rw [← TopCat.epi_iff_surjective]\n    infer_instance\n  map_prop _ := P.of_isIso _\n\n"}
{"name":"AlgebraicGeometry.Scheme.coverOfIsIso_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.ContainsIdentities\ninst✝¹ : P.RespectsIso\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nx✝ : PUnit.{v + 1}\n⊢ Eq ((AlgebraicGeometry.Scheme.coverOfIsIso f).obj x✝) X","decl":"/-- An isomorphism `X ⟶ Y` is a `P`-cover of `Y`. -/\n@[simps J obj map]\ndef coverOfIsIso [P.ContainsIdentities] [P.RespectsIso] {X Y : Scheme.{u}} (f : X ⟶ Y)\n    [IsIso f] : Cover.{v} P Y where\n  J := PUnit.{v + 1}\n  obj _ := X\n  map _ := f\n  f _ := PUnit.unit\n  covers x := by\n    rw [Set.range_eq_univ.mpr]\n    all_goals try trivial\n    rw [← TopCat.epi_iff_surjective]\n    infer_instance\n  map_prop _ := P.of_isIso _\n\n"}
{"name":"AlgebraicGeometry.Scheme.coverOfIsIso_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.ContainsIdentities\ninst✝¹ : P.RespectsIso\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nx✝ : PUnit.{v + 1}\n⊢ Eq ((AlgebraicGeometry.Scheme.coverOfIsIso f).map x✝) f","decl":"/-- An isomorphism `X ⟶ Y` is a `P`-cover of `Y`. -/\n@[simps J obj map]\ndef coverOfIsIso [P.ContainsIdentities] [P.RespectsIso] {X Y : Scheme.{u}} (f : X ⟶ Y)\n    [IsIso f] : Cover.{v} P Y where\n  J := PUnit.{v + 1}\n  obj _ := X\n  map _ := f\n  f _ := PUnit.unit\n  covers x := by\n    rw [Set.range_eq_univ.mpr]\n    all_goals try trivial\n    rw [← TopCat.epi_iff_surjective]\n    infer_instance\n  map_prop _ := P.of_isIso _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.copy_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝ : P.RespectsIso\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nJ : Type u_1\nobj : J → AlgebraicGeometry.Scheme\nmap : (i : J) → Quiver.Hom (obj i) X\ne₁ : Equiv J 𝒰.J\ne₂ : (i : J) → CategoryTheory.Iso (obj i) (𝒰.obj (e₁ i))\nh : ∀ (i : J), Eq (map i) (CategoryTheory.CategoryStruct.comp (e₂ i).hom (𝒰.map (e₁ i)))\na✝ : J\n⊢ Eq ((𝒰.copy J obj map e₁ e₂ h).obj a✝) (obj a✝)","decl":"/-- We construct a cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original cover. -/\n@[simps J obj map]\ndef Cover.copy [P.RespectsIso] {X : Scheme.{u}} (𝒰 : X.Cover P)\n    (J : Type*) (obj : J → Scheme)\n    (map : ∀ i, obj i ⟶ X) (e₁ : J ≃ 𝒰.J) (e₂ : ∀ i, obj i ≅ 𝒰.obj (e₁ i))\n    (h : ∀ i, map i = (e₂ i).hom ≫ 𝒰.map (e₁ i)) : X.Cover P :=\n  { J, obj, map\n    f := fun x ↦ e₁.symm (𝒰.f x)\n    covers := fun x ↦ by\n      rw [h, Scheme.comp_base, TopCat.coe_comp, Set.range_comp, Set.range_eq_univ.mpr,\n        Set.image_univ, e₁.rightInverse_symm]\n      · exact 𝒰.covers x\n      · rw [← TopCat.epi_iff_surjective]; infer_instance\n    map_prop := fun j ↦ by\n      rw [h, P.cancel_left_of_respectsIso]\n      exact 𝒰.map_prop (e₁ j) }\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.copy_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝ : P.RespectsIso\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nJ : Type u_1\nobj : J → AlgebraicGeometry.Scheme\nmap : (i : J) → Quiver.Hom (obj i) X\ne₁ : Equiv J 𝒰.J\ne₂ : (i : J) → CategoryTheory.Iso (obj i) (𝒰.obj (e₁ i))\nh : ∀ (i : J), Eq (map i) (CategoryTheory.CategoryStruct.comp (e₂ i).hom (𝒰.map (e₁ i)))\n⊢ Eq (𝒰.copy J obj map e₁ e₂ h).J J","decl":"/-- We construct a cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original cover. -/\n@[simps J obj map]\ndef Cover.copy [P.RespectsIso] {X : Scheme.{u}} (𝒰 : X.Cover P)\n    (J : Type*) (obj : J → Scheme)\n    (map : ∀ i, obj i ⟶ X) (e₁ : J ≃ 𝒰.J) (e₂ : ∀ i, obj i ≅ 𝒰.obj (e₁ i))\n    (h : ∀ i, map i = (e₂ i).hom ≫ 𝒰.map (e₁ i)) : X.Cover P :=\n  { J, obj, map\n    f := fun x ↦ e₁.symm (𝒰.f x)\n    covers := fun x ↦ by\n      rw [h, Scheme.comp_base, TopCat.coe_comp, Set.range_comp, Set.range_eq_univ.mpr,\n        Set.image_univ, e₁.rightInverse_symm]\n      · exact 𝒰.covers x\n      · rw [← TopCat.epi_iff_surjective]; infer_instance\n    map_prop := fun j ↦ by\n      rw [h, P.cancel_left_of_respectsIso]\n      exact 𝒰.map_prop (e₁ j) }\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.copy_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝ : P.RespectsIso\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nJ : Type u_1\nobj : J → AlgebraicGeometry.Scheme\nmap : (i : J) → Quiver.Hom (obj i) X\ne₁ : Equiv J 𝒰.J\ne₂ : (i : J) → CategoryTheory.Iso (obj i) (𝒰.obj (e₁ i))\nh : ∀ (i : J), Eq (map i) (CategoryTheory.CategoryStruct.comp (e₂ i).hom (𝒰.map (e₁ i)))\ni : J\n⊢ Eq ((𝒰.copy J obj map e₁ e₂ h).map i) (map i)","decl":"/-- We construct a cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original cover. -/\n@[simps J obj map]\ndef Cover.copy [P.RespectsIso] {X : Scheme.{u}} (𝒰 : X.Cover P)\n    (J : Type*) (obj : J → Scheme)\n    (map : ∀ i, obj i ⟶ X) (e₁ : J ≃ 𝒰.J) (e₂ : ∀ i, obj i ≅ 𝒰.obj (e₁ i))\n    (h : ∀ i, map i = (e₂ i).hom ≫ 𝒰.map (e₁ i)) : X.Cover P :=\n  { J, obj, map\n    f := fun x ↦ e₁.symm (𝒰.f x)\n    covers := fun x ↦ by\n      rw [h, Scheme.comp_base, TopCat.coe_comp, Set.range_comp, Set.range_eq_univ.mpr,\n        Set.image_univ, e₁.rightInverse_symm]\n      · exact 𝒰.covers x\n      · rw [← TopCat.epi_iff_surjective]; infer_instance\n    map_prop := fun j ↦ by\n      rw [h, P.cancel_left_of_respectsIso]\n      exact 𝒰.map_prop (e₁ j) }\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pushforwardIso_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝³ : P.RespectsIso\ninst✝² : P.ContainsIdentities\ninst✝¹ : P.IsStableUnderComposition\nX Y : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nx✝ : 𝒰.J\n⊢ Eq ((𝒰.pushforwardIso f).map x✝) (CategoryTheory.CategoryStruct.comp (𝒰.map x✝) f)","decl":"/-- The pushforward of a cover along an isomorphism. -/\n@[simps! J obj map]\ndef Cover.pushforwardIso [P.RespectsIso] [P.ContainsIdentities] [P.IsStableUnderComposition]\n    {X Y : Scheme.{u}} (𝒰 : Cover.{v} P X) (f : X ⟶ Y) [IsIso f] :\n    Cover.{v} P Y :=\n  ((coverOfIsIso.{v, u} f).bind fun _ => 𝒰).copy 𝒰.J _ _\n    ((Equiv.punitProd _).symm.trans (Equiv.sigmaEquivProd PUnit 𝒰.J).symm) (fun _ => Iso.refl _)\n    fun _ => (Category.id_comp _).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pushforwardIso_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝³ : P.RespectsIso\ninst✝² : P.ContainsIdentities\ninst✝¹ : P.IsStableUnderComposition\nX Y : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (𝒰.pushforwardIso f).J 𝒰.J","decl":"/-- The pushforward of a cover along an isomorphism. -/\n@[simps! J obj map]\ndef Cover.pushforwardIso [P.RespectsIso] [P.ContainsIdentities] [P.IsStableUnderComposition]\n    {X Y : Scheme.{u}} (𝒰 : Cover.{v} P X) (f : X ⟶ Y) [IsIso f] :\n    Cover.{v} P Y :=\n  ((coverOfIsIso.{v, u} f).bind fun _ => 𝒰).copy 𝒰.J _ _\n    ((Equiv.punitProd _).symm.trans (Equiv.sigmaEquivProd PUnit 𝒰.J).symm) (fun _ => Iso.refl _)\n    fun _ => (Category.id_comp _).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pushforwardIso_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝³ : P.RespectsIso\ninst✝² : P.ContainsIdentities\ninst✝¹ : P.IsStableUnderComposition\nX Y : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nx✝ : 𝒰.J\n⊢ Eq ((𝒰.pushforwardIso f).obj x✝) (𝒰.obj x✝)","decl":"/-- The pushforward of a cover along an isomorphism. -/\n@[simps! J obj map]\ndef Cover.pushforwardIso [P.RespectsIso] [P.ContainsIdentities] [P.IsStableUnderComposition]\n    {X Y : Scheme.{u}} (𝒰 : Cover.{v} P X) (f : X ⟶ Y) [IsIso f] :\n    Cover.{v} P Y :=\n  ((coverOfIsIso.{v, u} f).bind fun _ => 𝒰).copy 𝒰.J _ _\n    ((Equiv.punitProd _).symm.trans (Equiv.sigmaEquivProd PUnit 𝒰.J).symm) (fun _ => Iso.refl _)\n    fun _ => (Category.id_comp _).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.add_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX Y : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom Y X\nhf : autoParam (P f) _auto✝\n⊢ Eq (𝒰.add f hf).J (Option 𝒰.J)","decl":"/-- Adding map satisfying `P` into a cover gives another cover. -/\n@[simps]\ndef Cover.add {X Y : Scheme.{u}} (𝒰 : X.Cover P) (f : Y ⟶ X) (hf : P f := by infer_instance) :\n    X.Cover P where\n  J := Option 𝒰.J\n  obj i := Option.rec Y 𝒰.obj i\n  map i := Option.rec f 𝒰.map i\n  f x := some (𝒰.f x)\n  covers := 𝒰.covers\n  map_prop j := by\n    obtain ⟨_ | _⟩ := j\n    · exact hf\n    · exact 𝒰.map_prop _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.add_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX Y : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom Y X\nhf : autoParam (P f) _auto✝\ni : Option 𝒰.J\n⊢ Eq ((𝒰.add f hf).map i) (Option.rec f 𝒰.map i)","decl":"/-- Adding map satisfying `P` into a cover gives another cover. -/\n@[simps]\ndef Cover.add {X Y : Scheme.{u}} (𝒰 : X.Cover P) (f : Y ⟶ X) (hf : P f := by infer_instance) :\n    X.Cover P where\n  J := Option 𝒰.J\n  obj i := Option.rec Y 𝒰.obj i\n  map i := Option.rec f 𝒰.map i\n  f x := some (𝒰.f x)\n  covers := 𝒰.covers\n  map_prop j := by\n    obtain ⟨_ | _⟩ := j\n    · exact hf\n    · exact 𝒰.map_prop _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.add_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX Y : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom Y X\nhf : autoParam (P f) _auto✝\nx : ↑↑X.toPresheafedSpace\n⊢ Eq ((𝒰.add f hf).f x) (Option.some (𝒰.f x))","decl":"/-- Adding map satisfying `P` into a cover gives another cover. -/\n@[simps]\ndef Cover.add {X Y : Scheme.{u}} (𝒰 : X.Cover P) (f : Y ⟶ X) (hf : P f := by infer_instance) :\n    X.Cover P where\n  J := Option 𝒰.J\n  obj i := Option.rec Y 𝒰.obj i\n  map i := Option.rec f 𝒰.map i\n  f x := some (𝒰.f x)\n  covers := 𝒰.covers\n  map_prop j := by\n    obtain ⟨_ | _⟩ := j\n    · exact hf\n    · exact 𝒰.map_prop _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.add_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX Y : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom Y X\nhf : autoParam (P f) _auto✝\ni : Option 𝒰.J\n⊢ Eq ((𝒰.add f hf).obj i) (Option.rec Y 𝒰.obj i)","decl":"/-- Adding map satisfying `P` into a cover gives another cover. -/\n@[simps]\ndef Cover.add {X Y : Scheme.{u}} (𝒰 : X.Cover P) (f : Y ⟶ X) (hf : P f := by infer_instance) :\n    X.Cover P where\n  J := Option 𝒰.J\n  obj i := Option.rec Y 𝒰.obj i\n  map i := Option.rec f 𝒰.map i\n  f x := some (𝒰.f x)\n  covers := 𝒰.covers\n  map_prop j := by\n    obtain ⟨_ | _⟩ := j\n    · exact hf\n    · exact 𝒰.map_prop _\n\n"}
{"name":"AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst✝ : CategoryTheory.Limits.HasPullback f g\nhg : P g\nx : ↑↑X.toPresheafedSpace\ny : ↑↑Y.toPresheafedSpace\nh : Eq (f.base x) (g.base y)\n⊢ Exists fun a => Eq ((CategoryTheory.Limits.pullback.fst f g).base a) x","decl":"/-- A morphism property of schemes is said to preserve joint surjectivity, if\nfor any pair of morphisms `f : X ⟶ S` and `g : Y ⟶ S` where `g` satisfies `P`,\nany pair of points `x : X` and `y : Y` with `f x = g y` can be lifted to a point\nof `X ×[S] Y`.\n\nIn later files, this will be automatic, since this holds for any morphism `g`\n(see `AlgebraicGeometry.Scheme.isJointlySurjectivePreserving`). But at\nthis early stage in the import tree, we only know it for open immersions. -/\nclass IsJointlySurjectivePreserving (P : MorphismProperty Scheme.{u}) where\n  exists_preimage_fst_triplet_of_prop {X Y S : Scheme.{u}} {f : X ⟶ S} {g : Y ⟶ S} [HasPullback f g]\n    (hg : P g) (x : X) (y : Y) (h : f.base x = g.base y) :\n    ∃ a : ↑(pullback f g), (pullback.fst f g).base a = x\n\n"}
{"name":"AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninst✝ : CategoryTheory.Limits.HasPullback f g\nhf : P f\nx : ↑↑X.toPresheafedSpace\ny : ↑↑Y.toPresheafedSpace\nh : Eq (f.base x) (g.base y)\n⊢ Exists fun a => Eq ((CategoryTheory.Limits.pullback.snd f g).base a) y","decl":"lemma IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n    [IsJointlySurjectivePreserving P] {X Y S : Scheme.{u}} {f : X ⟶ S} {g : Y ⟶ S} [HasPullback f g]\n    (hf : P f) (x : X) (y : Y) (h : f.base x = g.base y) :\n    ∃ a : ↑(pullback f g), (pullback.snd f g).base a = y := by\n  let iso := pullbackSymmetry f g\n  haveI : HasPullback g f := hasPullback_symmetry f g\n  obtain ⟨a, ha⟩ := exists_preimage_fst_triplet_of_prop hf y x h.symm\n  use (pullbackSymmetry f g).inv.base a\n  rwa [← Scheme.comp_base_apply, pullbackSymmetry_inv_comp_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsJointlySurjectivePreservingIsOpenImmersion","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"⊢ AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving @AlgebraicGeometry.IsOpenImmersion","decl":"instance : IsJointlySurjectivePreserving @IsOpenImmersion where\n  exists_preimage_fst_triplet_of_prop {X Y S f g} _ hg x y h := by\n    rw [← show _ = (pullback.fst _ _ : pullback f g ⟶ _).base from\n        PreservesPullback.iso_hom_fst Scheme.forgetToTop f g]\n    have : x ∈ Set.range (pullback.fst f.base g.base) := by\n      rw [TopCat.pullback_fst_range f.base g.base]\n      use y\n    obtain ⟨a, ha⟩ := this\n    use (PreservesPullback.iso forgetToTop f g).inv a\n    rwa [← TopCat.comp_app, Iso.inv_hom_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback f (𝒰.map x)\nx : ↑↑W.toPresheafedSpace\n⊢ Eq ((𝒰.pullbackCover f).f x) (𝒰.f (f.base x))","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `W ⟶ X` to obtain\na cover of `W`.\n\nNote that this requires the (unnecessary) assumptions that the pullback exists and that `P`\npreserves joint surjectivity. This is needed, because we don't know these in general at this\nstage of the import tree, but this API is used in the case of `P = IsOpenImmersion` to\nobtain these results in the general case. -/\n@[simps]\ndef Cover.pullbackCover [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X) [∀ x, HasPullback f (𝒰.map x)] : W.Cover P where\n  J := 𝒰.J\n  obj x := pullback f (𝒰.map x)\n  map _ := pullback.fst _ _\n  f x := 𝒰.f (f.base x)\n  covers x := by\n    obtain ⟨y, hy⟩ := 𝒰.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n      (𝒰.map_prop _) x y hy.symm\n  map_prop j := P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback f (𝒰.map x)\n⊢ Eq (𝒰.pullbackCover f).J 𝒰.J","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `W ⟶ X` to obtain\na cover of `W`.\n\nNote that this requires the (unnecessary) assumptions that the pullback exists and that `P`\npreserves joint surjectivity. This is needed, because we don't know these in general at this\nstage of the import tree, but this API is used in the case of `P = IsOpenImmersion` to\nobtain these results in the general case. -/\n@[simps]\ndef Cover.pullbackCover [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X) [∀ x, HasPullback f (𝒰.map x)] : W.Cover P where\n  J := 𝒰.J\n  obj x := pullback f (𝒰.map x)\n  map _ := pullback.fst _ _\n  f x := 𝒰.f (f.base x)\n  covers x := by\n    obtain ⟨y, hy⟩ := 𝒰.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n      (𝒰.map_prop _) x y hy.symm\n  map_prop j := P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback f (𝒰.map x)\nx✝ : 𝒰.J\n⊢ Eq ((𝒰.pullbackCover f).map x✝) (CategoryTheory.Limits.pullback.fst f (𝒰.map x✝))","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `W ⟶ X` to obtain\na cover of `W`.\n\nNote that this requires the (unnecessary) assumptions that the pullback exists and that `P`\npreserves joint surjectivity. This is needed, because we don't know these in general at this\nstage of the import tree, but this API is used in the case of `P = IsOpenImmersion` to\nobtain these results in the general case. -/\n@[simps]\ndef Cover.pullbackCover [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X) [∀ x, HasPullback f (𝒰.map x)] : W.Cover P where\n  J := 𝒰.J\n  obj x := pullback f (𝒰.map x)\n  map _ := pullback.fst _ _\n  f x := 𝒰.f (f.base x)\n  covers x := by\n    obtain ⟨y, hy⟩ := 𝒰.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n      (𝒰.map_prop _) x y hy.symm\n  map_prop j := P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback f (𝒰.map x)\nx : 𝒰.J\n⊢ Eq ((𝒰.pullbackCover f).obj x) (CategoryTheory.Limits.pullback f (𝒰.map x))","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `W ⟶ X` to obtain\na cover of `W`.\n\nNote that this requires the (unnecessary) assumptions that the pullback exists and that `P`\npreserves joint surjectivity. This is needed, because we don't know these in general at this\nstage of the import tree, but this API is used in the case of `P = IsOpenImmersion` to\nobtain these results in the general case. -/\n@[simps]\ndef Cover.pullbackCover [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X) [∀ x, HasPullback f (𝒰.map x)] : W.Cover P where\n  J := 𝒰.J\n  obj x := pullback f (𝒰.map x)\n  map _ := pullback.fst _ _\n  f x := 𝒰.f (f.base x)\n  covers x := by\n    obtain ⟨y, hy⟩ := 𝒰.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n      (𝒰.map_prop _) x y hy.symm\n  map_prop j := P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackHom_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback f (𝒰.map x)\ni : 𝒰.1\n⊢ Eq (CategoryTheory.CategoryStruct.comp (𝒰.pullbackHom f i) (𝒰.map i)) (CategoryTheory.CategoryStruct.comp ((𝒰.pullbackCover f).map i) f)","decl":"@[reassoc (attr := simp)]\nlemma Cover.pullbackHom_map [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X) [∀ (x : 𝒰.J), HasPullback f (𝒰.map x)] (i) :\n    𝒰.pullbackHom f i ≫ 𝒰.map i = (𝒰.pullbackCover f).map i ≫ f := pullback.condition.symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackHom_map_assoc","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback f (𝒰.map x)\ni : 𝒰.1\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (𝒰.pullbackHom f i) (CategoryTheory.CategoryStruct.comp (𝒰.map i) h)) (CategoryTheory.CategoryStruct.comp ((𝒰.pullbackCover f).map i) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma Cover.pullbackHom_map [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X) [∀ (x : 𝒰.J), HasPullback f (𝒰.map x)] (i) :\n    𝒰.pullbackHom f i ≫ 𝒰.map i = (𝒰.pullbackCover f).map i ≫ f := pullback.condition.symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover'_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback (𝒰.map x) f\nx : ↑↑W.toPresheafedSpace\n⊢ Eq ((𝒰.pullbackCover' f).f x) (𝒰.f (f.base x))","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `f : W ⟶ X` to obtain\na cover of `W`. This is similar to `Scheme.Cover.pullbackCover`, but here we\ntake `pullback (𝒰.map x) f` instead of `pullback f (𝒰.map x)`. -/\n@[simps]\ndef Cover.pullbackCover' [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X)\n    [∀ x, HasPullback (𝒰.map x) f] :\n    W.Cover P where\n  J := 𝒰.J\n  obj x := pullback (𝒰.map x) f\n  map _ := pullback.snd _ _\n  f x := 𝒰.f (f.base x)\n  covers x := by\n    obtain ⟨y, hy⟩ := 𝒰.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n      (𝒰.map_prop _) y x hy\n  map_prop j := P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover'_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback (𝒰.map x) f\n⊢ Eq (𝒰.pullbackCover' f).J 𝒰.J","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `f : W ⟶ X` to obtain\na cover of `W`. This is similar to `Scheme.Cover.pullbackCover`, but here we\ntake `pullback (𝒰.map x) f` instead of `pullback f (𝒰.map x)`. -/\n@[simps]\ndef Cover.pullbackCover' [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X)\n    [∀ x, HasPullback (𝒰.map x) f] :\n    W.Cover P where\n  J := 𝒰.J\n  obj x := pullback (𝒰.map x) f\n  map _ := pullback.snd _ _\n  f x := 𝒰.f (f.base x)\n  covers x := by\n    obtain ⟨y, hy⟩ := 𝒰.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n      (𝒰.map_prop _) y x hy\n  map_prop j := P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover'_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback (𝒰.map x) f\nx✝ : 𝒰.J\n⊢ Eq ((𝒰.pullbackCover' f).map x✝) (CategoryTheory.Limits.pullback.snd (𝒰.map x✝) f)","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `f : W ⟶ X` to obtain\na cover of `W`. This is similar to `Scheme.Cover.pullbackCover`, but here we\ntake `pullback (𝒰.map x) f` instead of `pullback f (𝒰.map x)`. -/\n@[simps]\ndef Cover.pullbackCover' [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X)\n    [∀ x, HasPullback (𝒰.map x) f] :\n    W.Cover P where\n  J := 𝒰.J\n  obj x := pullback (𝒰.map x) f\n  map _ := pullback.snd _ _\n  f x := 𝒰.f (f.base x)\n  covers x := by\n    obtain ⟨y, hy⟩ := 𝒰.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n      (𝒰.map_prop _) y x hy\n  map_prop j := P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover'_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝ : ∀ (x : 𝒰.J), CategoryTheory.Limits.HasPullback (𝒰.map x) f\nx : 𝒰.J\n⊢ Eq ((𝒰.pullbackCover' f).obj x) (CategoryTheory.Limits.pullback (𝒰.map x) f)","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `f : W ⟶ X` to obtain\na cover of `W`. This is similar to `Scheme.Cover.pullbackCover`, but here we\ntake `pullback (𝒰.map x) f` instead of `pullback f (𝒰.map x)`. -/\n@[simps]\ndef Cover.pullbackCover' [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (𝒰 : X.Cover P) (f : W ⟶ X)\n    [∀ x, HasPullback (𝒰.map x) f] :\n    W.Cover P where\n  J := 𝒰.J\n  obj x := pullback (𝒰.map x) f\n  map _ := pullback.snd _ _\n  f x := 𝒰.f (f.base x)\n  covers x := by\n    obtain ⟨y, hy⟩ := 𝒰.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n      (𝒰.map_prop _) y x hy\n  map_prop j := P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\ninst✝ : ⦃X Y : AlgebraicGeometry.Scheme⦄ → (x : Quiver.Hom X Y) → SizeOf (P x)\nJ : Type v\nobj : J → CommRingCat\nmap : (j : J) → Quiver.Hom (AlgebraicGeometry.Spec (obj j)) X\nf : ↑↑X.toPresheafedSpace → J\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map (f x)).base) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\n⊢ Eq (SizeOf.sizeOf { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.covers","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.AffineCover P X\nx : ↑↑X.toPresheafedSpace\n⊢ Membership.mem (Set.range ⇑(self.map (self.f x)).base) x","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.map_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.AffineCover P X\nj : self.J\n⊢ P (self.map j)","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.mk.injEq","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ✝ : Type v\nobj✝ : J✝ → CommRingCat\nmap✝ : (j : J✝) → Quiver.Hom (AlgebraicGeometry.Spec (obj✝ j)) X\nf✝ : ↑↑X.toPresheafedSpace → J✝\ncovers✝ : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map✝ (f✝ x)).base) x\nmap_prop✝ : autoParam (∀ (j : J✝), P (map✝ j)) _auto✝\nJ : Type v\nobj : J → CommRingCat\nmap : (j : J) → Quiver.Hom (AlgebraicGeometry.Spec (obj j)) X\nf : ↑↑X.toPresheafedSpace → J\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map (f x)).base) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\n⊢ Eq (Eq { J := J✝, obj := obj✝, map := map✝, f := f✝, covers := covers✝, map_prop := map_prop✝ } { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }) (And (Eq J✝ J) (And (HEq obj✝ obj) (And (HEq map✝ map) (HEq f✝ f))))","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.mk.inj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ✝ : Type v\nobj✝ : J✝ → CommRingCat\nmap✝ : (j : J✝) → Quiver.Hom (AlgebraicGeometry.Spec (obj✝ j)) X\nf✝ : ↑↑X.toPresheafedSpace → J✝\ncovers✝ : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map✝ (f✝ x)).base) x\nmap_prop✝ : autoParam (∀ (j : J✝), P (map✝ j)) _auto✝\nJ : Type v\nobj : J → CommRingCat\nmap : (j : J) → Quiver.Hom (AlgebraicGeometry.Spec (obj j)) X\nf : ↑↑X.toPresheafedSpace → J\ncovers : ∀ (x : ↑↑X.toPresheafedSpace), Membership.mem (Set.range ⇑(map (f x)).base) x\nmap_prop : autoParam (∀ (j : J), P (map j)) _auto✝\nx✝ : Eq { J := J✝, obj := obj✝, map := map✝, f := f✝, covers := covers✝, map_prop := map_prop✝ } { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }\n⊢ And (Eq J✝ J) (And (HEq obj✝ obj) (And (HEq map✝ map) (HEq f✝ f)))","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) ⟶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x ∈ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.cover_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.AffineCover P X\n⊢ Eq 𝒰.cover.J 𝒰.J","decl":"/-- The cover associated to an affine cover. -/\n@[simps]\ndef AffineCover.cover {X : Scheme.{u}} (𝒰 : X.AffineCover P) : X.Cover P where\n  J := 𝒰.J\n  map := 𝒰.map\n  f := 𝒰.f\n  covers := 𝒰.covers\n  map_prop := 𝒰.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.cover_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.AffineCover P X\nj : 𝒰.J\n⊢ Eq (𝒰.cover.map j) (𝒰.map j)","decl":"/-- The cover associated to an affine cover. -/\n@[simps]\ndef AffineCover.cover {X : Scheme.{u}} (𝒰 : X.AffineCover P) : X.Cover P where\n  J := 𝒰.J\n  map := 𝒰.map\n  f := 𝒰.f\n  covers := 𝒰.covers\n  map_prop := 𝒰.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.cover_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.AffineCover P X\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (𝒰.cover.f x) (𝒰.f x)","decl":"/-- The cover associated to an affine cover. -/\n@[simps]\ndef AffineCover.cover {X : Scheme.{u}} (𝒰 : X.AffineCover P) : X.Cover P where\n  J := 𝒰.J\n  map := 𝒰.map\n  f := 𝒰.f\n  covers := 𝒰.covers\n  map_prop := 𝒰.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.cover_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.AffineCover P X\nj : 𝒰.J\n⊢ Eq (𝒰.cover.obj j) (AlgebraicGeometry.Spec (𝒰.obj j))","decl":"/-- The cover associated to an affine cover. -/\n@[simps]\ndef AffineCover.cover {X : Scheme.{u}} (𝒰 : X.AffineCover P) : X.Cover P where\n  J := 𝒰.J\n  map := 𝒰.map\n  f := 𝒰.f\n  covers := 𝒰.covers\n  map_prop := 𝒰.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.w","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 𝒱 : AlgebraicGeometry.Scheme.Cover P X\nself : 𝒰.Hom 𝒱\nj : 𝒰.J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.app j) (𝒱.map (self.idx j))) (𝒰.map j)","decl":"/--\nA morphism between covers `𝒰 ⟶ 𝒱` indicates that `𝒰` is a refinement of `𝒱`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (𝒰 𝒱 : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : 𝒰.J → 𝒱.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : 𝒰.J) : 𝒰.obj j ⟶ 𝒱.obj (idx j)\n  app_prop (j : 𝒰.J) : P (app j) := by infer_instance\n  w (j : 𝒰.J) : app j ≫ 𝒱.map _ = 𝒰.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.mk.inj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 𝒱 : AlgebraicGeometry.Scheme.Cover P X\nidx✝ : 𝒰.J → 𝒱.J\napp✝ : (j : 𝒰.J) → Quiver.Hom (𝒰.obj j) (𝒱.obj (idx✝ j))\napp_prop✝ : autoParam (∀ (j : 𝒰.J), P (app✝ j)) _auto✝\nw✝ : autoParam (∀ (j : 𝒰.J), Eq (CategoryTheory.CategoryStruct.comp (app✝ j) (𝒱.map (idx✝ j))) (𝒰.map j)) _auto✝\nidx : 𝒰.J → 𝒱.J\napp : (j : 𝒰.J) → Quiver.Hom (𝒰.obj j) (𝒱.obj (idx j))\napp_prop : autoParam (∀ (j : 𝒰.J), P (app j)) _auto✝\nw : autoParam (∀ (j : 𝒰.J), Eq (CategoryTheory.CategoryStruct.comp (app j) (𝒱.map (idx j))) (𝒰.map j)) _auto✝\nx✝ : Eq { idx := idx✝, app := app✝, app_prop := app_prop✝, w := w✝ } { idx := idx, app := app, app_prop := app_prop, w := w }\n⊢ And (Eq idx✝ idx) (HEq app✝ app)","decl":"/--\nA morphism between covers `𝒰 ⟶ 𝒱` indicates that `𝒰` is a refinement of `𝒱`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (𝒰 𝒱 : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : 𝒰.J → 𝒱.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : 𝒰.J) : 𝒰.obj j ⟶ 𝒱.obj (idx j)\n  app_prop (j : 𝒰.J) : P (app j) := by infer_instance\n  w (j : 𝒰.J) : app j ≫ 𝒱.map _ = 𝒰.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.app_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 𝒱 : AlgebraicGeometry.Scheme.Cover P X\nself : 𝒰.Hom 𝒱\nj : 𝒰.J\n⊢ P (self.app j)","decl":"/--\nA morphism between covers `𝒰 ⟶ 𝒱` indicates that `𝒰` is a refinement of `𝒱`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (𝒰 𝒱 : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : 𝒰.J → 𝒱.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : 𝒰.J) : 𝒰.obj j ⟶ 𝒱.obj (idx j)\n  app_prop (j : 𝒰.J) : P (app j) := by infer_instance\n  w (j : 𝒰.J) : app j ≫ 𝒱.map _ = 𝒰.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.mk.injEq","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 𝒱 : AlgebraicGeometry.Scheme.Cover P X\nidx✝ : 𝒰.J → 𝒱.J\napp✝ : (j : 𝒰.J) → Quiver.Hom (𝒰.obj j) (𝒱.obj (idx✝ j))\napp_prop✝ : autoParam (∀ (j : 𝒰.J), P (app✝ j)) _auto✝\nw✝ : autoParam (∀ (j : 𝒰.J), Eq (CategoryTheory.CategoryStruct.comp (app✝ j) (𝒱.map (idx✝ j))) (𝒰.map j)) _auto✝\nidx : 𝒰.J → 𝒱.J\napp : (j : 𝒰.J) → Quiver.Hom (𝒰.obj j) (𝒱.obj (idx j))\napp_prop : autoParam (∀ (j : 𝒰.J), P (app j)) _auto✝\nw : autoParam (∀ (j : 𝒰.J), Eq (CategoryTheory.CategoryStruct.comp (app j) (𝒱.map (idx j))) (𝒰.map j)) _auto✝\n⊢ Eq (Eq { idx := idx✝, app := app✝, app_prop := app_prop✝, w := w✝ } { idx := idx, app := app, app_prop := app_prop, w := w }) (And (Eq idx✝ idx) (HEq app✝ app))","decl":"/--\nA morphism between covers `𝒰 ⟶ 𝒱` indicates that `𝒰` is a refinement of `𝒱`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (𝒰 𝒱 : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : 𝒰.J → 𝒱.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : 𝒰.J) : 𝒰.obj j ⟶ 𝒱.obj (idx j)\n  app_prop (j : 𝒰.J) : P (app j) := by infer_instance\n  w (j : 𝒰.J) : app j ≫ 𝒱.map _ = 𝒰.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 𝒱 : AlgebraicGeometry.Scheme.Cover P X\ninst✝ : ⦃X Y : AlgebraicGeometry.Scheme⦄ → (x : Quiver.Hom X Y) → SizeOf (P x)\nidx : 𝒰.J → 𝒱.J\napp : (j : 𝒰.J) → Quiver.Hom (𝒰.obj j) (𝒱.obj (idx j))\napp_prop : autoParam (∀ (j : 𝒰.J), P (app j)) _auto✝\nw : autoParam (∀ (j : 𝒰.J), Eq (CategoryTheory.CategoryStruct.comp (app j) (𝒱.map (idx j))) (𝒰.map j)) _auto✝\n⊢ Eq (SizeOf.sizeOf { idx := idx, app := app, app_prop := app_prop, w := w }) 1","decl":"/--\nA morphism between covers `𝒰 ⟶ 𝒱` indicates that `𝒰` is a refinement of `𝒱`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (𝒰 𝒱 : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : 𝒰.J → 𝒱.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : 𝒰.J) : 𝒰.obj j ⟶ 𝒱.obj (idx j)\n  app_prop (j : 𝒰.J) : P (app j) := by infer_instance\n  w (j : 𝒰.J) : app j ≫ 𝒱.map _ = 𝒰.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.w_assoc","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\n𝒰 𝒱 : AlgebraicGeometry.Scheme.Cover P X\nself : 𝒰.Hom 𝒱\nj : 𝒰.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.app j) (CategoryTheory.CategoryStruct.comp (𝒱.map (self.idx j)) h)) (CategoryTheory.CategoryStruct.comp (𝒰.map j) h)","decl":"attribute [reassoc (attr := simp)] Cover.Hom.w\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.id_idx_apply","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝ : P.IsMultiplicative\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nj : 𝒰.J\n⊢ Eq ((CategoryTheory.CategoryStruct.id 𝒰).idx j) j","decl":"@[simp]\nlemma Cover.id_idx_apply {X : Scheme.{u}} (𝒰 : X.Cover P) (j : 𝒰.J) :\n    (𝟙 𝒰 : 𝒰 ⟶ 𝒰).idx j = j := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.id_app","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝ : P.IsMultiplicative\nX : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nj : 𝒰.J\n⊢ Eq ((CategoryTheory.CategoryStruct.id 𝒰).app j) (CategoryTheory.CategoryStruct.id (𝒰.obj j))","decl":"@[simp]\nlemma Cover.id_app {X : Scheme.{u}} (𝒰 : X.Cover P) (j : 𝒰.J) :\n    (𝟙 𝒰 : 𝒰 ⟶ 𝒰).app j = 𝟙 _ := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.comp_idx_apply","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝ : P.IsMultiplicative\nX : AlgebraicGeometry.Scheme\n𝒰 𝒱 𝒲 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom 𝒰 𝒱\ng : Quiver.Hom 𝒱 𝒲\nj : 𝒰.J\n⊢ Eq ((CategoryTheory.CategoryStruct.comp f g).idx j) (g.idx (f.idx j))","decl":"@[simp]\nlemma Cover.comp_idx_apply {X : Scheme.{u}} {𝒰 𝒱 𝒲 : X.Cover P}\n    (f : 𝒰 ⟶ 𝒱) (g : 𝒱 ⟶ 𝒲) (j : 𝒰.J) :\n    (f ≫ g).idx j = g.idx (f.idx j) := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.comp_app","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝ : P.IsMultiplicative\nX : AlgebraicGeometry.Scheme\n𝒰 𝒱 𝒲 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom 𝒰 𝒱\ng : Quiver.Hom 𝒱 𝒲\nj : 𝒰.J\n⊢ Eq ((CategoryTheory.CategoryStruct.comp f g).app j) (CategoryTheory.CategoryStruct.comp (f.app j) (g.app (f.idx j)))","decl":"@[simp]\nlemma Cover.comp_app {X : Scheme.{u}} {𝒰 𝒱 𝒲 : X.Cover P}\n    (f : 𝒰 ⟶ 𝒱) (g : 𝒱 ⟶ 𝒲) (j : 𝒰.J) :\n    (f ≫ g).app j = f.app j ≫ g.app _ := rfl\n\n"}
