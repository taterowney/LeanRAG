{"name":"AlgebraicGeometry.Scheme.Cover.covers","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.Cover P X\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Membership.mem (Set.range â‡‘(self.map (self.f x)).base) x","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mk.inj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJâœ : Type v\nobjâœ : Jâœ â†’ AlgebraicGeometry.Scheme\nmapâœ : (j : Jâœ) â†’ Quiver.Hom (objâœ j) X\nfâœ : â†‘â†‘X.toPresheafedSpace â†’ Jâœ\ncoversâœ : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(mapâœ (fâœ x)).base) x\nmap_propâœ : autoParam (âˆ€ (j : Jâœ), P (mapâœ j)) _autoâœ\nJ : Type v\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (j : J) â†’ Quiver.Hom (obj j) X\nf : â†‘â†‘X.toPresheafedSpace â†’ J\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(map (f x)).base) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\nxâœ : Eq { J := Jâœ, obj := objâœ, map := mapâœ, f := fâœ, covers := coversâœ, map_prop := map_propâœ } { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }\nâŠ¢ And (Eq Jâœ J) (And (HEq objâœ obj) (And (HEq mapâœ map) (HEq fâœ f)))","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mk.injEq","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJâœ : Type v\nobjâœ : Jâœ â†’ AlgebraicGeometry.Scheme\nmapâœ : (j : Jâœ) â†’ Quiver.Hom (objâœ j) X\nfâœ : â†‘â†‘X.toPresheafedSpace â†’ Jâœ\ncoversâœ : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(mapâœ (fâœ x)).base) x\nmap_propâœ : autoParam (âˆ€ (j : Jâœ), P (mapâœ j)) _autoâœ\nJ : Type v\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (j : J) â†’ Quiver.Hom (obj j) X\nf : â†‘â†‘X.toPresheafedSpace â†’ J\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(map (f x)).base) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\nâŠ¢ Eq (Eq { J := Jâœ, obj := objâœ, map := mapâœ, f := fâœ, covers := coversâœ, map_prop := map_propâœ } { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }) (And (Eq Jâœ J) (And (HEq objâœ obj) (And (HEq mapâœ map) (HEq fâœ f))))","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.map_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.Cover P X\nj : self.J\nâŠ¢ P (self.map j)","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\ninstâœ : â¦ƒX Y : AlgebraicGeometry.Schemeâ¦„ â†’ (x : Quiver.Hom X Y) â†’ SizeOf (P x)\nJ : Type v\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (j : J) â†’ Quiver.Hom (obj j) X\nf : â†‘â†‘X.toPresheafedSpace â†’ J\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(map (f x)).base) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/-- A cover of `X` consists of jointly surjective indexed family of scheme morphisms\nwith target `X` all satisfying `P`.\n\nThis is merely a coverage in the pretopology defined by `P`, and it would be optimal\nif we could reuse the existing API about pretopologies, However, the definitions of sieves and\ngrothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to\nobtain. Also, since such a coverage in the pretopology usually contains a proper class of\nimmersions, it is quite hard to glue them, reason about finite covers, etc.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure Cover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of a cover of a scheme `X` -/\n  J : Type v\n  /-- the components of a cover -/\n  obj (j : J) : Scheme\n  /-- the components map to `X` -/\n  map (j : J) : obj j âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.iUnion_range","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nâŠ¢ Eq (Set.iUnion fun i => Set.range â‡‘(ğ’°.map i).base) Set.univ","decl":"theorem Cover.iUnion_range {X : Scheme.{u}} (ğ’° : X.Cover P) :\n    â‹ƒ i, Set.range (ğ’°.map i).base = Set.univ := by\n  rw [Set.eq_univ_iff_forall]\n  intro x\n  rw [Set.mem_iUnion]\n  exact âŸ¨ğ’°.f x, ğ’°.covers xâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.exists_eq","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Exists fun i => Exists fun y => Eq ((ğ’°.map i).base y) x","decl":"lemma Cover.exists_eq (ğ’° : X.Cover P) (x : X) : âˆƒ i y, (ğ’°.map i).base y = x :=\n  âŸ¨_, ğ’°.covers xâŸ©\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mkOfCovers_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ : Type u_1\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (j : J) â†’ Quiver.Hom (obj j) X\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Exists fun j => Exists fun y => Eq ((map j).base y) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\naâœ : J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Cover.mkOfCovers J obj map covers map_prop).obj aâœ) (obj aâœ)","decl":"/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly\ncover `X`, this an associated `P`-cover of `X`. -/\n@[simps]\ndef Cover.mkOfCovers (J : Type*) (obj : J â†’ Scheme.{u}) (map : (j : J) â†’ obj j âŸ¶ X)\n    (covers : âˆ€ x, âˆƒ j y, (map j).base y = x)\n    (map_prop : âˆ€ j, P (map j) := by infer_instance) : X.Cover P where\n  J := J\n  obj := obj\n  map := map\n  f x := (covers x).choose\n  covers x := (covers x).choose_spec\n  map_prop := map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mkOfCovers_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ : Type u_1\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (j : J) â†’ Quiver.Hom (obj j) X\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Exists fun j => Exists fun y => Eq ((map j).base y) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\nj : J\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Cover.mkOfCovers J obj map covers map_prop).map j) (map j)","decl":"/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly\ncover `X`, this an associated `P`-cover of `X`. -/\n@[simps]\ndef Cover.mkOfCovers (J : Type*) (obj : J â†’ Scheme.{u}) (map : (j : J) â†’ obj j âŸ¶ X)\n    (covers : âˆ€ x, âˆƒ j y, (map j).base y = x)\n    (map_prop : âˆ€ j, P (map j) := by infer_instance) : X.Cover P where\n  J := J\n  obj := obj\n  map := map\n  f x := (covers x).choose\n  covers x := (covers x).choose_spec\n  map_prop := map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mkOfCovers_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ : Type u_1\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (j : J) â†’ Quiver.Hom (obj j) X\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Exists fun j => Exists fun y => Eq ((map j).base y) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.Cover.mkOfCovers J obj map covers map_prop).f x) â‹¯.choose","decl":"/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly\ncover `X`, this an associated `P`-cover of `X`. -/\n@[simps]\ndef Cover.mkOfCovers (J : Type*) (obj : J â†’ Scheme.{u}) (map : (j : J) â†’ obj j âŸ¶ X)\n    (covers : âˆ€ x, âˆƒ j y, (map j).base y = x)\n    (map_prop : âˆ€ j, P (map j) := by infer_instance) : X.Cover P where\n  J := J\n  obj := obj\n  map := map\n  f x := (covers x).choose\n  covers x := (covers x).choose_spec\n  map_prop := map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.mkOfCovers_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJ : Type u_1\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (j : J) â†’ Quiver.Hom (obj j) X\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Exists fun j => Exists fun y => Eq ((map j).base y) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\nâŠ¢ Eq (AlgebraicGeometry.Scheme.Cover.mkOfCovers J obj map covers map_prop).J J","decl":"/-- Given a family of schemes with morphisms to `X` satisfying `P` that jointly\ncover `X`, this an associated `P`-cover of `X`. -/\n@[simps]\ndef Cover.mkOfCovers (J : Type*) (obj : J â†’ Scheme.{u}) (map : (j : J) â†’ obj j âŸ¶ X)\n    (covers : âˆ€ x, âˆƒ j y, (map j).base y = x)\n    (map_prop : âˆ€ j, P (map j) := by infer_instance) : X.Cover P where\n  J := J\n  obj := obj\n  map := map\n  f x := (covers x).choose\n  covers x := (covers x).choose_spec\n  map_prop := map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.bind_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\ninstâœ : P.IsStableUnderComposition\nf : (x : ğ’°.J) â†’ AlgebraicGeometry.Scheme.Cover P (ğ’°.obj x)\nx : Sigma fun i => (f i).J\nâŠ¢ Eq ((ğ’°.bind f).map x) (CategoryTheory.CategoryStruct.comp ((f x.fst).map x.snd) (ğ’°.map x.fst))","decl":"/-- Given a `P`-cover `{ Uáµ¢ }` of `X`, and for each `Uáµ¢` a `P`-cover, we may combine these\ncovers to form a `P`-cover of `X`. -/\n@[simps! J obj map]\ndef Cover.bind [P.IsStableUnderComposition] (f : âˆ€ x : ğ’°.J, (ğ’°.obj x).Cover P) : X.Cover P where\n  J := Î£ i : ğ’°.J, (f i).J\n  obj x := (f x.1).obj x.2\n  map x := (f x.1).map x.2 â‰« ğ’°.map x.1\n  f x := âŸ¨_, (f _).f (ğ’°.covers x).chooseâŸ©\n  covers x := by\n    let y := (ğ’°.covers x).choose\n    have hy : (ğ’°.map (ğ’°.f x)).base y = x := (ğ’°.covers x).choose_spec\n    rcases (f (ğ’°.f x)).covers y with âŸ¨z, hzâŸ©\n    change x âˆˆ Set.range ((f (ğ’°.f x)).map ((f (ğ’°.f x)).f y) â‰« ğ’°.map (ğ’°.f x)).base\n    use z\n    erw [CategoryTheory.comp_apply]\n    rw [hz, hy]\n  map_prop _ := P.comp_mem _ _ ((f _).map_prop _) (ğ’°.map_prop _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.bind_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\ninstâœ : P.IsStableUnderComposition\nf : (x : ğ’°.J) â†’ AlgebraicGeometry.Scheme.Cover P (ğ’°.obj x)\nx : Sigma fun i => (f i).J\nâŠ¢ Eq ((ğ’°.bind f).obj x) ((f x.fst).obj x.snd)","decl":"/-- Given a `P`-cover `{ Uáµ¢ }` of `X`, and for each `Uáµ¢` a `P`-cover, we may combine these\ncovers to form a `P`-cover of `X`. -/\n@[simps! J obj map]\ndef Cover.bind [P.IsStableUnderComposition] (f : âˆ€ x : ğ’°.J, (ğ’°.obj x).Cover P) : X.Cover P where\n  J := Î£ i : ğ’°.J, (f i).J\n  obj x := (f x.1).obj x.2\n  map x := (f x.1).map x.2 â‰« ğ’°.map x.1\n  f x := âŸ¨_, (f _).f (ğ’°.covers x).chooseâŸ©\n  covers x := by\n    let y := (ğ’°.covers x).choose\n    have hy : (ğ’°.map (ğ’°.f x)).base y = x := (ğ’°.covers x).choose_spec\n    rcases (f (ğ’°.f x)).covers y with âŸ¨z, hzâŸ©\n    change x âˆˆ Set.range ((f (ğ’°.f x)).map ((f (ğ’°.f x)).f y) â‰« ğ’°.map (ğ’°.f x)).base\n    use z\n    erw [CategoryTheory.comp_apply]\n    rw [hz, hy]\n  map_prop _ := P.comp_mem _ _ ((f _).map_prop _) (ğ’°.map_prop _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.bind_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\ninstâœ : P.IsStableUnderComposition\nf : (x : ğ’°.J) â†’ AlgebraicGeometry.Scheme.Cover P (ğ’°.obj x)\nâŠ¢ Eq (ğ’°.bind f).J (Sigma fun i => (f i).J)","decl":"/-- Given a `P`-cover `{ Uáµ¢ }` of `X`, and for each `Uáµ¢` a `P`-cover, we may combine these\ncovers to form a `P`-cover of `X`. -/\n@[simps! J obj map]\ndef Cover.bind [P.IsStableUnderComposition] (f : âˆ€ x : ğ’°.J, (ğ’°.obj x).Cover P) : X.Cover P where\n  J := Î£ i : ğ’°.J, (f i).J\n  obj x := (f x.1).obj x.2\n  map x := (f x.1).map x.2 â‰« ğ’°.map x.1\n  f x := âŸ¨_, (f _).f (ğ’°.covers x).chooseâŸ©\n  covers x := by\n    let y := (ğ’°.covers x).choose\n    have hy : (ğ’°.map (ğ’°.f x)).base y = x := (ğ’°.covers x).choose_spec\n    rcases (f (ğ’°.f x)).covers y with âŸ¨z, hzâŸ©\n    change x âˆˆ Set.range ((f (ğ’°.f x)).map ((f (ğ’°.f x)).f y) â‰« ğ’°.map (ğ’°.f x)).base\n    use z\n    erw [CategoryTheory.comp_apply]\n    rw [hz, hy]\n  map_prop _ := P.comp_mem _ _ ((f _).map_prop _) (ğ’°.map_prop _)\n\n"}
{"name":"AlgebraicGeometry.Scheme.coverOfIsIso_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.ContainsIdentities\ninstâœÂ¹ : P.RespectsIso\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f\nâŠ¢ Eq (AlgebraicGeometry.Scheme.coverOfIsIso f).J PUnit.{v + 1}","decl":"/-- An isomorphism `X âŸ¶ Y` is a `P`-cover of `Y`. -/\n@[simps J obj map]\ndef coverOfIsIso [P.ContainsIdentities] [P.RespectsIso] {X Y : Scheme.{u}} (f : X âŸ¶ Y)\n    [IsIso f] : Cover.{v} P Y where\n  J := PUnit.{v + 1}\n  obj _ := X\n  map _ := f\n  f _ := PUnit.unit\n  covers x := by\n    rw [Set.range_eq_univ.mpr]\n    all_goals try trivial\n    rw [â† TopCat.epi_iff_surjective]\n    infer_instance\n  map_prop _ := P.of_isIso _\n\n"}
{"name":"AlgebraicGeometry.Scheme.coverOfIsIso_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.ContainsIdentities\ninstâœÂ¹ : P.RespectsIso\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f\nxâœ : PUnit.{v + 1}\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.coverOfIsIso f).obj xâœ) X","decl":"/-- An isomorphism `X âŸ¶ Y` is a `P`-cover of `Y`. -/\n@[simps J obj map]\ndef coverOfIsIso [P.ContainsIdentities] [P.RespectsIso] {X Y : Scheme.{u}} (f : X âŸ¶ Y)\n    [IsIso f] : Cover.{v} P Y where\n  J := PUnit.{v + 1}\n  obj _ := X\n  map _ := f\n  f _ := PUnit.unit\n  covers x := by\n    rw [Set.range_eq_univ.mpr]\n    all_goals try trivial\n    rw [â† TopCat.epi_iff_surjective]\n    infer_instance\n  map_prop _ := P.of_isIso _\n\n"}
{"name":"AlgebraicGeometry.Scheme.coverOfIsIso_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.ContainsIdentities\ninstâœÂ¹ : P.RespectsIso\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f\nxâœ : PUnit.{v + 1}\nâŠ¢ Eq ((AlgebraicGeometry.Scheme.coverOfIsIso f).map xâœ) f","decl":"/-- An isomorphism `X âŸ¶ Y` is a `P`-cover of `Y`. -/\n@[simps J obj map]\ndef coverOfIsIso [P.ContainsIdentities] [P.RespectsIso] {X Y : Scheme.{u}} (f : X âŸ¶ Y)\n    [IsIso f] : Cover.{v} P Y where\n  J := PUnit.{v + 1}\n  obj _ := X\n  map _ := f\n  f _ := PUnit.unit\n  covers x := by\n    rw [Set.range_eq_univ.mpr]\n    all_goals try trivial\n    rw [â† TopCat.epi_iff_surjective]\n    infer_instance\n  map_prop _ := P.of_isIso _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.copy_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.RespectsIso\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nJ : Type u_1\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (i : J) â†’ Quiver.Hom (obj i) X\neâ‚ : Equiv J ğ’°.J\neâ‚‚ : (i : J) â†’ CategoryTheory.Iso (obj i) (ğ’°.obj (eâ‚ i))\nh : âˆ€ (i : J), Eq (map i) (CategoryTheory.CategoryStruct.comp (eâ‚‚ i).hom (ğ’°.map (eâ‚ i)))\naâœ : J\nâŠ¢ Eq ((ğ’°.copy J obj map eâ‚ eâ‚‚ h).obj aâœ) (obj aâœ)","decl":"/-- We construct a cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original cover. -/\n@[simps J obj map]\ndef Cover.copy [P.RespectsIso] {X : Scheme.{u}} (ğ’° : X.Cover P)\n    (J : Type*) (obj : J â†’ Scheme)\n    (map : âˆ€ i, obj i âŸ¶ X) (eâ‚ : J â‰ƒ ğ’°.J) (eâ‚‚ : âˆ€ i, obj i â‰… ğ’°.obj (eâ‚ i))\n    (h : âˆ€ i, map i = (eâ‚‚ i).hom â‰« ğ’°.map (eâ‚ i)) : X.Cover P :=\n  { J, obj, map\n    f := fun x â†¦ eâ‚.symm (ğ’°.f x)\n    covers := fun x â†¦ by\n      rw [h, Scheme.comp_base, TopCat.coe_comp, Set.range_comp, Set.range_eq_univ.mpr,\n        Set.image_univ, eâ‚.rightInverse_symm]\n      Â· exact ğ’°.covers x\n      Â· rw [â† TopCat.epi_iff_surjective]; infer_instance\n    map_prop := fun j â†¦ by\n      rw [h, P.cancel_left_of_respectsIso]\n      exact ğ’°.map_prop (eâ‚ j) }\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.copy_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.RespectsIso\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nJ : Type u_1\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (i : J) â†’ Quiver.Hom (obj i) X\neâ‚ : Equiv J ğ’°.J\neâ‚‚ : (i : J) â†’ CategoryTheory.Iso (obj i) (ğ’°.obj (eâ‚ i))\nh : âˆ€ (i : J), Eq (map i) (CategoryTheory.CategoryStruct.comp (eâ‚‚ i).hom (ğ’°.map (eâ‚ i)))\nâŠ¢ Eq (ğ’°.copy J obj map eâ‚ eâ‚‚ h).J J","decl":"/-- We construct a cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original cover. -/\n@[simps J obj map]\ndef Cover.copy [P.RespectsIso] {X : Scheme.{u}} (ğ’° : X.Cover P)\n    (J : Type*) (obj : J â†’ Scheme)\n    (map : âˆ€ i, obj i âŸ¶ X) (eâ‚ : J â‰ƒ ğ’°.J) (eâ‚‚ : âˆ€ i, obj i â‰… ğ’°.obj (eâ‚ i))\n    (h : âˆ€ i, map i = (eâ‚‚ i).hom â‰« ğ’°.map (eâ‚ i)) : X.Cover P :=\n  { J, obj, map\n    f := fun x â†¦ eâ‚.symm (ğ’°.f x)\n    covers := fun x â†¦ by\n      rw [h, Scheme.comp_base, TopCat.coe_comp, Set.range_comp, Set.range_eq_univ.mpr,\n        Set.image_univ, eâ‚.rightInverse_symm]\n      Â· exact ğ’°.covers x\n      Â· rw [â† TopCat.epi_iff_surjective]; infer_instance\n    map_prop := fun j â†¦ by\n      rw [h, P.cancel_left_of_respectsIso]\n      exact ğ’°.map_prop (eâ‚ j) }\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.copy_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.RespectsIso\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nJ : Type u_1\nobj : J â†’ AlgebraicGeometry.Scheme\nmap : (i : J) â†’ Quiver.Hom (obj i) X\neâ‚ : Equiv J ğ’°.J\neâ‚‚ : (i : J) â†’ CategoryTheory.Iso (obj i) (ğ’°.obj (eâ‚ i))\nh : âˆ€ (i : J), Eq (map i) (CategoryTheory.CategoryStruct.comp (eâ‚‚ i).hom (ğ’°.map (eâ‚ i)))\ni : J\nâŠ¢ Eq ((ğ’°.copy J obj map eâ‚ eâ‚‚ h).map i) (map i)","decl":"/-- We construct a cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original cover. -/\n@[simps J obj map]\ndef Cover.copy [P.RespectsIso] {X : Scheme.{u}} (ğ’° : X.Cover P)\n    (J : Type*) (obj : J â†’ Scheme)\n    (map : âˆ€ i, obj i âŸ¶ X) (eâ‚ : J â‰ƒ ğ’°.J) (eâ‚‚ : âˆ€ i, obj i â‰… ğ’°.obj (eâ‚ i))\n    (h : âˆ€ i, map i = (eâ‚‚ i).hom â‰« ğ’°.map (eâ‚ i)) : X.Cover P :=\n  { J, obj, map\n    f := fun x â†¦ eâ‚.symm (ğ’°.f x)\n    covers := fun x â†¦ by\n      rw [h, Scheme.comp_base, TopCat.coe_comp, Set.range_comp, Set.range_eq_univ.mpr,\n        Set.image_univ, eâ‚.rightInverse_symm]\n      Â· exact ğ’°.covers x\n      Â· rw [â† TopCat.epi_iff_surjective]; infer_instance\n    map_prop := fun j â†¦ by\n      rw [h, P.cancel_left_of_respectsIso]\n      exact ğ’°.map_prop (eâ‚ j) }\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pushforwardIso_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ³ : P.RespectsIso\ninstâœÂ² : P.ContainsIdentities\ninstâœÂ¹ : P.IsStableUnderComposition\nX Y : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f\nxâœ : ğ’°.J\nâŠ¢ Eq ((ğ’°.pushforwardIso f).map xâœ) (CategoryTheory.CategoryStruct.comp (ğ’°.map xâœ) f)","decl":"/-- The pushforward of a cover along an isomorphism. -/\n@[simps! J obj map]\ndef Cover.pushforwardIso [P.RespectsIso] [P.ContainsIdentities] [P.IsStableUnderComposition]\n    {X Y : Scheme.{u}} (ğ’° : Cover.{v} P X) (f : X âŸ¶ Y) [IsIso f] :\n    Cover.{v} P Y :=\n  ((coverOfIsIso.{v, u} f).bind fun _ => ğ’°).copy ğ’°.J _ _\n    ((Equiv.punitProd _).symm.trans (Equiv.sigmaEquivProd PUnit ğ’°.J).symm) (fun _ => Iso.refl _)\n    fun _ => (Category.id_comp _).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pushforwardIso_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ³ : P.RespectsIso\ninstâœÂ² : P.ContainsIdentities\ninstâœÂ¹ : P.IsStableUnderComposition\nX Y : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f\nâŠ¢ Eq (ğ’°.pushforwardIso f).J ğ’°.J","decl":"/-- The pushforward of a cover along an isomorphism. -/\n@[simps! J obj map]\ndef Cover.pushforwardIso [P.RespectsIso] [P.ContainsIdentities] [P.IsStableUnderComposition]\n    {X Y : Scheme.{u}} (ğ’° : Cover.{v} P X) (f : X âŸ¶ Y) [IsIso f] :\n    Cover.{v} P Y :=\n  ((coverOfIsIso.{v, u} f).bind fun _ => ğ’°).copy ğ’°.J _ _\n    ((Equiv.punitProd _).symm.trans (Equiv.sigmaEquivProd PUnit ğ’°.J).symm) (fun _ => Iso.refl _)\n    fun _ => (Category.id_comp _).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pushforwardIso_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ³ : P.RespectsIso\ninstâœÂ² : P.ContainsIdentities\ninstâœÂ¹ : P.IsStableUnderComposition\nX Y : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f\nxâœ : ğ’°.J\nâŠ¢ Eq ((ğ’°.pushforwardIso f).obj xâœ) (ğ’°.obj xâœ)","decl":"/-- The pushforward of a cover along an isomorphism. -/\n@[simps! J obj map]\ndef Cover.pushforwardIso [P.RespectsIso] [P.ContainsIdentities] [P.IsStableUnderComposition]\n    {X Y : Scheme.{u}} (ğ’° : Cover.{v} P X) (f : X âŸ¶ Y) [IsIso f] :\n    Cover.{v} P Y :=\n  ((coverOfIsIso.{v, u} f).bind fun _ => ğ’°).copy ğ’°.J _ _\n    ((Equiv.punitProd _).symm.trans (Equiv.sigmaEquivProd PUnit ğ’°.J).symm) (fun _ => Iso.refl _)\n    fun _ => (Category.id_comp _).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.add_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX Y : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom Y X\nhf : autoParam (P f) _autoâœ\nâŠ¢ Eq (ğ’°.add f hf).J (Option ğ’°.J)","decl":"/-- Adding map satisfying `P` into a cover gives another cover. -/\n@[simps]\ndef Cover.add {X Y : Scheme.{u}} (ğ’° : X.Cover P) (f : Y âŸ¶ X) (hf : P f := by infer_instance) :\n    X.Cover P where\n  J := Option ğ’°.J\n  obj i := Option.rec Y ğ’°.obj i\n  map i := Option.rec f ğ’°.map i\n  f x := some (ğ’°.f x)\n  covers := ğ’°.covers\n  map_prop j := by\n    obtain âŸ¨_ | _âŸ© := j\n    Â· exact hf\n    Â· exact ğ’°.map_prop _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.add_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX Y : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom Y X\nhf : autoParam (P f) _autoâœ\ni : Option ğ’°.J\nâŠ¢ Eq ((ğ’°.add f hf).map i) (Option.rec f ğ’°.map i)","decl":"/-- Adding map satisfying `P` into a cover gives another cover. -/\n@[simps]\ndef Cover.add {X Y : Scheme.{u}} (ğ’° : X.Cover P) (f : Y âŸ¶ X) (hf : P f := by infer_instance) :\n    X.Cover P where\n  J := Option ğ’°.J\n  obj i := Option.rec Y ğ’°.obj i\n  map i := Option.rec f ğ’°.map i\n  f x := some (ğ’°.f x)\n  covers := ğ’°.covers\n  map_prop j := by\n    obtain âŸ¨_ | _âŸ© := j\n    Â· exact hf\n    Â· exact ğ’°.map_prop _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.add_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX Y : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom Y X\nhf : autoParam (P f) _autoâœ\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Eq ((ğ’°.add f hf).f x) (Option.some (ğ’°.f x))","decl":"/-- Adding map satisfying `P` into a cover gives another cover. -/\n@[simps]\ndef Cover.add {X Y : Scheme.{u}} (ğ’° : X.Cover P) (f : Y âŸ¶ X) (hf : P f := by infer_instance) :\n    X.Cover P where\n  J := Option ğ’°.J\n  obj i := Option.rec Y ğ’°.obj i\n  map i := Option.rec f ğ’°.map i\n  f x := some (ğ’°.f x)\n  covers := ğ’°.covers\n  map_prop j := by\n    obtain âŸ¨_ | _âŸ© := j\n    Â· exact hf\n    Â· exact ğ’°.map_prop _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.add_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX Y : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom Y X\nhf : autoParam (P f) _autoâœ\ni : Option ğ’°.J\nâŠ¢ Eq ((ğ’°.add f hf).obj i) (Option.rec Y ğ’°.obj i)","decl":"/-- Adding map satisfying `P` into a cover gives another cover. -/\n@[simps]\ndef Cover.add {X Y : Scheme.{u}} (ğ’° : X.Cover P) (f : Y âŸ¶ X) (hf : P f := by infer_instance) :\n    X.Cover P where\n  J := Option ğ’°.J\n  obj i := Option.rec Y ğ’°.obj i\n  map i := Option.rec f ğ’°.map i\n  f x := some (ğ’°.f x)\n  covers := ğ’°.covers\n  map_prop j := by\n    obtain âŸ¨_ | _âŸ© := j\n    Â· exact hf\n    Â· exact ğ’°.map_prop _\n\n"}
{"name":"AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninstâœ : CategoryTheory.Limits.HasPullback f g\nhg : P g\nx : â†‘â†‘X.toPresheafedSpace\ny : â†‘â†‘Y.toPresheafedSpace\nh : Eq (f.base x) (g.base y)\nâŠ¢ Exists fun a => Eq ((CategoryTheory.Limits.pullback.fst f g).base a) x","decl":"/-- A morphism property of schemes is said to preserve joint surjectivity, if\nfor any pair of morphisms `f : X âŸ¶ S` and `g : Y âŸ¶ S` where `g` satisfies `P`,\nany pair of points `x : X` and `y : Y` with `f x = g y` can be lifted to a point\nof `X Ã—[S] Y`.\n\nIn later files, this will be automatic, since this holds for any morphism `g`\n(see `AlgebraicGeometry.Scheme.isJointlySurjectivePreserving`). But at\nthis early stage in the import tree, we only know it for open immersions. -/\nclass IsJointlySurjectivePreserving (P : MorphismProperty Scheme.{u}) where\n  exists_preimage_fst_triplet_of_prop {X Y S : Scheme.{u}} {f : X âŸ¶ S} {g : Y âŸ¶ S} [HasPullback f g]\n    (hg : P g) (x : X) (y : Y) (h : f.base x = g.base y) :\n    âˆƒ a : â†‘(pullback f g), (pullback.fst f g).base a = x\n\n"}
{"name":"AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX Y S : AlgebraicGeometry.Scheme\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\ninstâœ : CategoryTheory.Limits.HasPullback f g\nhf : P f\nx : â†‘â†‘X.toPresheafedSpace\ny : â†‘â†‘Y.toPresheafedSpace\nh : Eq (f.base x) (g.base y)\nâŠ¢ Exists fun a => Eq ((CategoryTheory.Limits.pullback.snd f g).base a) y","decl":"lemma IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n    [IsJointlySurjectivePreserving P] {X Y S : Scheme.{u}} {f : X âŸ¶ S} {g : Y âŸ¶ S} [HasPullback f g]\n    (hf : P f) (x : X) (y : Y) (h : f.base x = g.base y) :\n    âˆƒ a : â†‘(pullback f g), (pullback.snd f g).base a = y := by\n  let iso := pullbackSymmetry f g\n  haveI : HasPullback g f := hasPullback_symmetry f g\n  obtain âŸ¨a, haâŸ© := exists_preimage_fst_triplet_of_prop hf y x h.symm\n  use (pullbackSymmetry f g).inv.base a\n  rwa [â† Scheme.comp_base_apply, pullbackSymmetry_inv_comp_snd]\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsJointlySurjectivePreservingIsOpenImmersion","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"âŠ¢ AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving @AlgebraicGeometry.IsOpenImmersion","decl":"instance : IsJointlySurjectivePreserving @IsOpenImmersion where\n  exists_preimage_fst_triplet_of_prop {X Y S f g} _ hg x y h := by\n    rw [â† show _ = (pullback.fst _ _ : pullback f g âŸ¶ _).base from\n        PreservesPullback.iso_hom_fst Scheme.forgetToTop f g]\n    have : x âˆˆ Set.range (pullback.fst f.base g.base) := by\n      rw [TopCat.pullback_fst_range f.base g.base]\n      use y\n    obtain âŸ¨a, haâŸ© := this\n    use (PreservesPullback.iso forgetToTop f g).inv a\n    rwa [â† TopCat.comp_app, Iso.inv_hom_id_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback f (ğ’°.map x)\nx : â†‘â†‘W.toPresheafedSpace\nâŠ¢ Eq ((ğ’°.pullbackCover f).f x) (ğ’°.f (f.base x))","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `W âŸ¶ X` to obtain\na cover of `W`.\n\nNote that this requires the (unnecessary) assumptions that the pullback exists and that `P`\npreserves joint surjectivity. This is needed, because we don't know these in general at this\nstage of the import tree, but this API is used in the case of `P = IsOpenImmersion` to\nobtain these results in the general case. -/\n@[simps]\ndef Cover.pullbackCover [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X) [âˆ€ x, HasPullback f (ğ’°.map x)] : W.Cover P where\n  J := ğ’°.J\n  obj x := pullback f (ğ’°.map x)\n  map _ := pullback.fst _ _\n  f x := ğ’°.f (f.base x)\n  covers x := by\n    obtain âŸ¨y, hyâŸ© := ğ’°.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n      (ğ’°.map_prop _) x y hy.symm\n  map_prop j := P.pullback_fst _ _ (ğ’°.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback f (ğ’°.map x)\nâŠ¢ Eq (ğ’°.pullbackCover f).J ğ’°.J","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `W âŸ¶ X` to obtain\na cover of `W`.\n\nNote that this requires the (unnecessary) assumptions that the pullback exists and that `P`\npreserves joint surjectivity. This is needed, because we don't know these in general at this\nstage of the import tree, but this API is used in the case of `P = IsOpenImmersion` to\nobtain these results in the general case. -/\n@[simps]\ndef Cover.pullbackCover [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X) [âˆ€ x, HasPullback f (ğ’°.map x)] : W.Cover P where\n  J := ğ’°.J\n  obj x := pullback f (ğ’°.map x)\n  map _ := pullback.fst _ _\n  f x := ğ’°.f (f.base x)\n  covers x := by\n    obtain âŸ¨y, hyâŸ© := ğ’°.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n      (ğ’°.map_prop _) x y hy.symm\n  map_prop j := P.pullback_fst _ _ (ğ’°.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback f (ğ’°.map x)\nxâœ : ğ’°.J\nâŠ¢ Eq ((ğ’°.pullbackCover f).map xâœ) (CategoryTheory.Limits.pullback.fst f (ğ’°.map xâœ))","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `W âŸ¶ X` to obtain\na cover of `W`.\n\nNote that this requires the (unnecessary) assumptions that the pullback exists and that `P`\npreserves joint surjectivity. This is needed, because we don't know these in general at this\nstage of the import tree, but this API is used in the case of `P = IsOpenImmersion` to\nobtain these results in the general case. -/\n@[simps]\ndef Cover.pullbackCover [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X) [âˆ€ x, HasPullback f (ğ’°.map x)] : W.Cover P where\n  J := ğ’°.J\n  obj x := pullback f (ğ’°.map x)\n  map _ := pullback.fst _ _\n  f x := ğ’°.f (f.base x)\n  covers x := by\n    obtain âŸ¨y, hyâŸ© := ğ’°.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n      (ğ’°.map_prop _) x y hy.symm\n  map_prop j := P.pullback_fst _ _ (ğ’°.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback f (ğ’°.map x)\nx : ğ’°.J\nâŠ¢ Eq ((ğ’°.pullbackCover f).obj x) (CategoryTheory.Limits.pullback f (ğ’°.map x))","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `W âŸ¶ X` to obtain\na cover of `W`.\n\nNote that this requires the (unnecessary) assumptions that the pullback exists and that `P`\npreserves joint surjectivity. This is needed, because we don't know these in general at this\nstage of the import tree, but this API is used in the case of `P = IsOpenImmersion` to\nobtain these results in the general case. -/\n@[simps]\ndef Cover.pullbackCover [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X) [âˆ€ x, HasPullback f (ğ’°.map x)] : W.Cover P where\n  J := ğ’°.J\n  obj x := pullback f (ğ’°.map x)\n  map _ := pullback.fst _ _\n  f x := ğ’°.f (f.base x)\n  covers x := by\n    obtain âŸ¨y, hyâŸ© := ğ’°.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_fst_triplet_of_prop\n      (ğ’°.map_prop _) x y hy.symm\n  map_prop j := P.pullback_fst _ _ (ğ’°.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackHom_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback f (ğ’°.map x)\ni : ğ’°.1\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (ğ’°.pullbackHom f i) (ğ’°.map i)) (CategoryTheory.CategoryStruct.comp ((ğ’°.pullbackCover f).map i) f)","decl":"@[reassoc (attr := simp)]\nlemma Cover.pullbackHom_map [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X) [âˆ€ (x : ğ’°.J), HasPullback f (ğ’°.map x)] (i) :\n    ğ’°.pullbackHom f i â‰« ğ’°.map i = (ğ’°.pullbackCover f).map i â‰« f := pullback.condition.symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackHom_map_assoc","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback f (ğ’°.map x)\ni : ğ’°.1\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (ğ’°.pullbackHom f i) (CategoryTheory.CategoryStruct.comp (ğ’°.map i) h)) (CategoryTheory.CategoryStruct.comp ((ğ’°.pullbackCover f).map i) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma Cover.pullbackHom_map [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X) [âˆ€ (x : ğ’°.J), HasPullback f (ğ’°.map x)] (i) :\n    ğ’°.pullbackHom f i â‰« ğ’°.map i = (ğ’°.pullbackCover f).map i â‰« f := pullback.condition.symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover'_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback (ğ’°.map x) f\nx : â†‘â†‘W.toPresheafedSpace\nâŠ¢ Eq ((ğ’°.pullbackCover' f).f x) (ğ’°.f (f.base x))","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `f : W âŸ¶ X` to obtain\na cover of `W`. This is similar to `Scheme.Cover.pullbackCover`, but here we\ntake `pullback (ğ’°.map x) f` instead of `pullback f (ğ’°.map x)`. -/\n@[simps]\ndef Cover.pullbackCover' [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X)\n    [âˆ€ x, HasPullback (ğ’°.map x) f] :\n    W.Cover P where\n  J := ğ’°.J\n  obj x := pullback (ğ’°.map x) f\n  map _ := pullback.snd _ _\n  f x := ğ’°.f (f.base x)\n  covers x := by\n    obtain âŸ¨y, hyâŸ© := ğ’°.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n      (ğ’°.map_prop _) y x hy\n  map_prop j := P.pullback_snd _ _ (ğ’°.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover'_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback (ğ’°.map x) f\nâŠ¢ Eq (ğ’°.pullbackCover' f).J ğ’°.J","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `f : W âŸ¶ X` to obtain\na cover of `W`. This is similar to `Scheme.Cover.pullbackCover`, but here we\ntake `pullback (ğ’°.map x) f` instead of `pullback f (ğ’°.map x)`. -/\n@[simps]\ndef Cover.pullbackCover' [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X)\n    [âˆ€ x, HasPullback (ğ’°.map x) f] :\n    W.Cover P where\n  J := ğ’°.J\n  obj x := pullback (ğ’°.map x) f\n  map _ := pullback.snd _ _\n  f x := ğ’°.f (f.base x)\n  covers x := by\n    obtain âŸ¨y, hyâŸ© := ğ’°.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n      (ğ’°.map_prop _) y x hy\n  map_prop j := P.pullback_snd _ _ (ğ’°.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover'_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback (ğ’°.map x) f\nxâœ : ğ’°.J\nâŠ¢ Eq ((ğ’°.pullbackCover' f).map xâœ) (CategoryTheory.Limits.pullback.snd (ğ’°.map xâœ) f)","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `f : W âŸ¶ X` to obtain\na cover of `W`. This is similar to `Scheme.Cover.pullbackCover`, but here we\ntake `pullback (ğ’°.map x) f` instead of `pullback f (ğ’°.map x)`. -/\n@[simps]\ndef Cover.pullbackCover' [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X)\n    [âˆ€ x, HasPullback (ğ’°.map x) f] :\n    W.Cover P where\n  J := ğ’°.J\n  obj x := pullback (ğ’°.map x) f\n  map _ := pullback.snd _ _\n  f x := ğ’°.f (f.base x)\n  covers x := by\n    obtain âŸ¨y, hyâŸ© := ğ’°.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n      (ğ’°.map_prop _) y x hy\n  map_prop j := P.pullback_snd _ _ (ğ’°.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCover'_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : P.IsStableUnderBaseChange\ninstâœÂ¹ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninstâœ : âˆ€ (x : ğ’°.J), CategoryTheory.Limits.HasPullback (ğ’°.map x) f\nx : ğ’°.J\nâŠ¢ Eq ((ğ’°.pullbackCover' f).obj x) (CategoryTheory.Limits.pullback (ğ’°.map x) f)","decl":"/-- Given a cover on `X`, we may pull them back along a morphism `f : W âŸ¶ X` to obtain\na cover of `W`. This is similar to `Scheme.Cover.pullbackCover`, but here we\ntake `pullback (ğ’°.map x) f` instead of `pullback f (ğ’°.map x)`. -/\n@[simps]\ndef Cover.pullbackCover' [P.IsStableUnderBaseChange] [IsJointlySurjectivePreserving P]\n    {X W : Scheme.{u}} (ğ’° : X.Cover P) (f : W âŸ¶ X)\n    [âˆ€ x, HasPullback (ğ’°.map x) f] :\n    W.Cover P where\n  J := ğ’°.J\n  obj x := pullback (ğ’°.map x) f\n  map _ := pullback.snd _ _\n  f x := ğ’°.f (f.base x)\n  covers x := by\n    obtain âŸ¨y, hyâŸ© := ğ’°.covers (f.base x)\n    exact IsJointlySurjectivePreserving.exists_preimage_snd_triplet_of_prop\n      (ğ’°.map_prop _) y x hy\n  map_prop j := P.pullback_snd _ _ (ğ’°.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\ninstâœ : â¦ƒX Y : AlgebraicGeometry.Schemeâ¦„ â†’ (x : Quiver.Hom X Y) â†’ SizeOf (P x)\nJ : Type v\nobj : J â†’ CommRingCat\nmap : (j : J) â†’ Quiver.Hom (AlgebraicGeometry.Spec (obj j)) X\nf : â†‘â†‘X.toPresheafedSpace â†’ J\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(map (f x)).base) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.covers","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.AffineCover P X\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Membership.mem (Set.range â‡‘(self.map (self.f x)).base) x","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.map_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.Scheme.AffineCover P X\nj : self.J\nâŠ¢ P (self.map j)","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.mk.injEq","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJâœ : Type v\nobjâœ : Jâœ â†’ CommRingCat\nmapâœ : (j : Jâœ) â†’ Quiver.Hom (AlgebraicGeometry.Spec (objâœ j)) X\nfâœ : â†‘â†‘X.toPresheafedSpace â†’ Jâœ\ncoversâœ : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(mapâœ (fâœ x)).base) x\nmap_propâœ : autoParam (âˆ€ (j : Jâœ), P (mapâœ j)) _autoâœ\nJ : Type v\nobj : J â†’ CommRingCat\nmap : (j : J) â†’ Quiver.Hom (AlgebraicGeometry.Spec (obj j)) X\nf : â†‘â†‘X.toPresheafedSpace â†’ J\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(map (f x)).base) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\nâŠ¢ Eq (Eq { J := Jâœ, obj := objâœ, map := mapâœ, f := fâœ, covers := coversâœ, map_prop := map_propâœ } { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }) (And (Eq Jâœ J) (And (HEq objâœ obj) (And (HEq mapâœ map) (HEq fâœ f))))","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.mk.inj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nJâœ : Type v\nobjâœ : Jâœ â†’ CommRingCat\nmapâœ : (j : Jâœ) â†’ Quiver.Hom (AlgebraicGeometry.Spec (objâœ j)) X\nfâœ : â†‘â†‘X.toPresheafedSpace â†’ Jâœ\ncoversâœ : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(mapâœ (fâœ x)).base) x\nmap_propâœ : autoParam (âˆ€ (j : Jâœ), P (mapâœ j)) _autoâœ\nJ : Type v\nobj : J â†’ CommRingCat\nmap : (j : J) â†’ Quiver.Hom (AlgebraicGeometry.Spec (obj j)) X\nf : â†‘â†‘X.toPresheafedSpace â†’ J\ncovers : âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Membership.mem (Set.range â‡‘(map (f x)).base) x\nmap_prop : autoParam (âˆ€ (j : J), P (map j)) _autoâœ\nxâœ : Eq { J := Jâœ, obj := objâœ, map := mapâœ, f := fâœ, covers := coversâœ, map_prop := map_propâœ } { J := J, obj := obj, map := map, f := f, covers := covers, map_prop := map_prop }\nâŠ¢ And (Eq Jâœ J) (And (HEq objâœ obj) (And (HEq mapâœ map) (HEq fâœ f)))","decl":"/--\nAn affine cover of `X` consists of a jointly surjective family of maps into `X` from\nspectra of rings.\n\nNote: The `map_prop` field is equipped with a default argument `by infer_instance`. In general\nthis causes worse error messages, but in practice `P` is mostly defined via `class`.\n-/\nstructure AffineCover (P : MorphismProperty Scheme.{u}) (X : Scheme.{u}) where\n  /-- index set of an affine cover of a scheme `X` -/\n  J : Type v\n  /-- the ring associated to a component of an affine cover -/\n  obj (j : J) : CommRingCat.{u}\n  /-- the components map to `X` -/\n  map (j : J) : Spec (obj j) âŸ¶ X\n  /-- given a point of `x : X`, `f x` is the index of the component which contains `x`  -/\n  f (x : X) : J\n  /-- the components cover `X` -/\n  covers (x : X) : x âˆˆ Set.range (map (f x)).base\n  /-- the component maps satisfy `P` -/\n  map_prop (j : J) : P (map j) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.cover_J","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.AffineCover P X\nâŠ¢ Eq ğ’°.cover.J ğ’°.J","decl":"/-- The cover associated to an affine cover. -/\n@[simps]\ndef AffineCover.cover {X : Scheme.{u}} (ğ’° : X.AffineCover P) : X.Cover P where\n  J := ğ’°.J\n  map := ğ’°.map\n  f := ğ’°.f\n  covers := ğ’°.covers\n  map_prop := ğ’°.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.cover_map","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.AffineCover P X\nj : ğ’°.J\nâŠ¢ Eq (ğ’°.cover.map j) (ğ’°.map j)","decl":"/-- The cover associated to an affine cover. -/\n@[simps]\ndef AffineCover.cover {X : Scheme.{u}} (ğ’° : X.AffineCover P) : X.Cover P where\n  J := ğ’°.J\n  map := ğ’°.map\n  f := ğ’°.f\n  covers := ğ’°.covers\n  map_prop := ğ’°.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.cover_f","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.AffineCover P X\nx : â†‘â†‘X.toPresheafedSpace\nâŠ¢ Eq (ğ’°.cover.f x) (ğ’°.f x)","decl":"/-- The cover associated to an affine cover. -/\n@[simps]\ndef AffineCover.cover {X : Scheme.{u}} (ğ’° : X.AffineCover P) : X.Cover P where\n  J := ğ’°.J\n  map := ğ’°.map\n  f := ğ’°.f\n  covers := ğ’°.covers\n  map_prop := ğ’°.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.AffineCover.cover_obj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.AffineCover P X\nj : ğ’°.J\nâŠ¢ Eq (ğ’°.cover.obj j) (AlgebraicGeometry.Spec (ğ’°.obj j))","decl":"/-- The cover associated to an affine cover. -/\n@[simps]\ndef AffineCover.cover {X : Scheme.{u}} (ğ’° : X.AffineCover P) : X.Cover P where\n  J := ğ’°.J\n  map := ğ’°.map\n  f := ğ’°.f\n  covers := ğ’°.covers\n  map_prop := ğ’°.map_prop\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.w","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° ğ’± : AlgebraicGeometry.Scheme.Cover P X\nself : ğ’°.Hom ğ’±\nj : ğ’°.J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.app j) (ğ’±.map (self.idx j))) (ğ’°.map j)","decl":"/--\nA morphism between covers `ğ’° âŸ¶ ğ’±` indicates that `ğ’°` is a refinement of `ğ’±`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (ğ’° ğ’± : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : ğ’°.J â†’ ğ’±.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : ğ’°.J) : ğ’°.obj j âŸ¶ ğ’±.obj (idx j)\n  app_prop (j : ğ’°.J) : P (app j) := by infer_instance\n  w (j : ğ’°.J) : app j â‰« ğ’±.map _ = ğ’°.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.mk.inj","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° ğ’± : AlgebraicGeometry.Scheme.Cover P X\nidxâœ : ğ’°.J â†’ ğ’±.J\nappâœ : (j : ğ’°.J) â†’ Quiver.Hom (ğ’°.obj j) (ğ’±.obj (idxâœ j))\napp_propâœ : autoParam (âˆ€ (j : ğ’°.J), P (appâœ j)) _autoâœ\nwâœ : autoParam (âˆ€ (j : ğ’°.J), Eq (CategoryTheory.CategoryStruct.comp (appâœ j) (ğ’±.map (idxâœ j))) (ğ’°.map j)) _autoâœ\nidx : ğ’°.J â†’ ğ’±.J\napp : (j : ğ’°.J) â†’ Quiver.Hom (ğ’°.obj j) (ğ’±.obj (idx j))\napp_prop : autoParam (âˆ€ (j : ğ’°.J), P (app j)) _autoâœ\nw : autoParam (âˆ€ (j : ğ’°.J), Eq (CategoryTheory.CategoryStruct.comp (app j) (ğ’±.map (idx j))) (ğ’°.map j)) _autoâœ\nxâœ : Eq { idx := idxâœ, app := appâœ, app_prop := app_propâœ, w := wâœ } { idx := idx, app := app, app_prop := app_prop, w := w }\nâŠ¢ And (Eq idxâœ idx) (HEq appâœ app)","decl":"/--\nA morphism between covers `ğ’° âŸ¶ ğ’±` indicates that `ğ’°` is a refinement of `ğ’±`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (ğ’° ğ’± : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : ğ’°.J â†’ ğ’±.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : ğ’°.J) : ğ’°.obj j âŸ¶ ğ’±.obj (idx j)\n  app_prop (j : ğ’°.J) : P (app j) := by infer_instance\n  w (j : ğ’°.J) : app j â‰« ğ’±.map _ = ğ’°.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.app_prop","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° ğ’± : AlgebraicGeometry.Scheme.Cover P X\nself : ğ’°.Hom ğ’±\nj : ğ’°.J\nâŠ¢ P (self.app j)","decl":"/--\nA morphism between covers `ğ’° âŸ¶ ğ’±` indicates that `ğ’°` is a refinement of `ğ’±`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (ğ’° ğ’± : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : ğ’°.J â†’ ğ’±.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : ğ’°.J) : ğ’°.obj j âŸ¶ ğ’±.obj (idx j)\n  app_prop (j : ğ’°.J) : P (app j) := by infer_instance\n  w (j : ğ’°.J) : app j â‰« ğ’±.map _ = ğ’°.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.mk.injEq","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° ğ’± : AlgebraicGeometry.Scheme.Cover P X\nidxâœ : ğ’°.J â†’ ğ’±.J\nappâœ : (j : ğ’°.J) â†’ Quiver.Hom (ğ’°.obj j) (ğ’±.obj (idxâœ j))\napp_propâœ : autoParam (âˆ€ (j : ğ’°.J), P (appâœ j)) _autoâœ\nwâœ : autoParam (âˆ€ (j : ğ’°.J), Eq (CategoryTheory.CategoryStruct.comp (appâœ j) (ğ’±.map (idxâœ j))) (ğ’°.map j)) _autoâœ\nidx : ğ’°.J â†’ ğ’±.J\napp : (j : ğ’°.J) â†’ Quiver.Hom (ğ’°.obj j) (ğ’±.obj (idx j))\napp_prop : autoParam (âˆ€ (j : ğ’°.J), P (app j)) _autoâœ\nw : autoParam (âˆ€ (j : ğ’°.J), Eq (CategoryTheory.CategoryStruct.comp (app j) (ğ’±.map (idx j))) (ğ’°.map j)) _autoâœ\nâŠ¢ Eq (Eq { idx := idxâœ, app := appâœ, app_prop := app_propâœ, w := wâœ } { idx := idx, app := app, app_prop := app_prop, w := w }) (And (Eq idxâœ idx) (HEq appâœ app))","decl":"/--\nA morphism between covers `ğ’° âŸ¶ ğ’±` indicates that `ğ’°` is a refinement of `ğ’±`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (ğ’° ğ’± : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : ğ’°.J â†’ ğ’±.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : ğ’°.J) : ğ’°.obj j âŸ¶ ğ’±.obj (idx j)\n  app_prop (j : ğ’°.J) : P (app j) := by infer_instance\n  w (j : ğ’°.J) : app j â‰« ğ’±.map _ = ğ’°.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° ğ’± : AlgebraicGeometry.Scheme.Cover P X\ninstâœ : â¦ƒX Y : AlgebraicGeometry.Schemeâ¦„ â†’ (x : Quiver.Hom X Y) â†’ SizeOf (P x)\nidx : ğ’°.J â†’ ğ’±.J\napp : (j : ğ’°.J) â†’ Quiver.Hom (ğ’°.obj j) (ğ’±.obj (idx j))\napp_prop : autoParam (âˆ€ (j : ğ’°.J), P (app j)) _autoâœ\nw : autoParam (âˆ€ (j : ğ’°.J), Eq (CategoryTheory.CategoryStruct.comp (app j) (ğ’±.map (idx j))) (ğ’°.map j)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { idx := idx, app := app, app_prop := app_prop, w := w }) 1","decl":"/--\nA morphism between covers `ğ’° âŸ¶ ğ’±` indicates that `ğ’°` is a refinement of `ğ’±`.\nSince covers of schemes are indexed, the definition also involves a map on the\nindexing types.\n-/\nstructure Cover.Hom {X : Scheme.{u}} (ğ’° ğ’± : Cover.{v} P X) where\n  /-- The map on indexing types associated to a morphism of covers. -/\n  idx : ğ’°.J â†’ ğ’±.J\n  /-- The morphism between open subsets associated to a morphism of covers. -/\n  app (j : ğ’°.J) : ğ’°.obj j âŸ¶ ğ’±.obj (idx j)\n  app_prop (j : ğ’°.J) : P (app j) := by infer_instance\n  w (j : ğ’°.J) : app j â‰« ğ’±.map _ = ğ’°.map _ := by aesop_cat\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.Hom.w_assoc","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\nğ’° ğ’± : AlgebraicGeometry.Scheme.Cover P X\nself : ğ’°.Hom ğ’±\nj : ğ’°.J\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.app j) (CategoryTheory.CategoryStruct.comp (ğ’±.map (self.idx j)) h)) (CategoryTheory.CategoryStruct.comp (ğ’°.map j) h)","decl":"attribute [reassoc (attr := simp)] Cover.Hom.w\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.id_idx_apply","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.IsMultiplicative\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nj : ğ’°.J\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.id ğ’°).idx j) j","decl":"@[simp]\nlemma Cover.id_idx_apply {X : Scheme.{u}} (ğ’° : X.Cover P) (j : ğ’°.J) :\n    (ğŸ™ ğ’° : ğ’° âŸ¶ ğ’°).idx j = j := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.id_app","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.IsMultiplicative\nX : AlgebraicGeometry.Scheme\nğ’° : AlgebraicGeometry.Scheme.Cover P X\nj : ğ’°.J\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.id ğ’°).app j) (CategoryTheory.CategoryStruct.id (ğ’°.obj j))","decl":"@[simp]\nlemma Cover.id_app {X : Scheme.{u}} (ğ’° : X.Cover P) (j : ğ’°.J) :\n    (ğŸ™ ğ’° : ğ’° âŸ¶ ğ’°).app j = ğŸ™ _ := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.comp_idx_apply","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.IsMultiplicative\nX : AlgebraicGeometry.Scheme\nğ’° ğ’± ğ’² : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom ğ’° ğ’±\ng : Quiver.Hom ğ’± ğ’²\nj : ğ’°.J\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.comp f g).idx j) (g.idx (f.idx j))","decl":"@[simp]\nlemma Cover.comp_idx_apply {X : Scheme.{u}} {ğ’° ğ’± ğ’² : X.Cover P}\n    (f : ğ’° âŸ¶ ğ’±) (g : ğ’± âŸ¶ ğ’²) (j : ğ’°.J) :\n    (f â‰« g).idx j = g.idx (f.idx j) := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.comp_app","module":"Mathlib.AlgebraicGeometry.Cover.MorphismProperty","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.IsMultiplicative\nX : AlgebraicGeometry.Scheme\nğ’° ğ’± ğ’² : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom ğ’° ğ’±\ng : Quiver.Hom ğ’± ğ’²\nj : ğ’°.J\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.comp f g).app j) (CategoryTheory.CategoryStruct.comp (f.app j) (g.app (f.idx j)))","decl":"@[simp]\nlemma Cover.comp_app {X : Scheme.{u}} {ğ’° ğ’± ğ’² : X.Cover P}\n    (f : ğ’° âŸ¶ ğ’±) (g : ğ’± âŸ¶ ğ’²) (j : ğ’°.J) :\n    (f â‰« g).app j = f.app j â‰« g.app _ := rfl\n\n"}
