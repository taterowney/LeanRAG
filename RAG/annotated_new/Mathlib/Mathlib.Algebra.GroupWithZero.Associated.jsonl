{"name":"Associated.refl","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : M\n⊢ Associated x x","decl":"@[refl]\nprotected theorem refl [Monoid M] (x : M) : x ~ᵤ x :=\n  ⟨1, by simp⟩\n\n"}
{"name":"Associated.rfl","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : M\n⊢ Associated x x","decl":"protected theorem rfl [Monoid M] {x : M} : x ~ᵤ x :=\n  .refl x\n\n"}
{"name":"Associated.instIsRefl","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ IsRefl M Associated","decl":"instance [Monoid M] : IsRefl M Associated :=\n  ⟨Associated.refl⟩\n\n"}
{"name":"Associated.symm","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx y : M\na✝ : Associated x y\n⊢ Associated y x","decl":"@[symm]\nprotected theorem symm [Monoid M] : ∀ {x y : M}, x ~ᵤ y → y ~ᵤ x\n  | x, _, ⟨u, rfl⟩ => ⟨u⁻¹, by rw [mul_assoc, Units.mul_inv, mul_one]⟩\n\n"}
{"name":"Associated.instIsSymm","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ IsSymm M Associated","decl":"instance [Monoid M] : IsSymm M Associated :=\n  ⟨fun _ _ => Associated.symm⟩\n\n"}
{"name":"Associated.comm","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx y : M\n⊢ Iff (Associated x y) (Associated y x)","decl":"protected theorem comm [Monoid M] {x y : M} : x ~ᵤ y ↔ y ~ᵤ x :=\n  ⟨Associated.symm, Associated.symm⟩\n\n"}
{"name":"Associated.trans","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx y z : M\na✝¹ : Associated x y\na✝ : Associated y z\n⊢ Associated x z","decl":"@[trans]\nprotected theorem trans [Monoid M] : ∀ {x y z : M}, x ~ᵤ y → y ~ᵤ z → x ~ᵤ z\n  | x, _, _, ⟨u, rfl⟩, ⟨v, rfl⟩ => ⟨u * v, by rw [Units.val_mul, mul_assoc]⟩\n\n"}
{"name":"Associated.instIsTrans","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ IsTrans M Associated","decl":"instance [Monoid M] : IsTrans M Associated :=\n  ⟨fun _ _ _ => Associated.trans⟩\n\n"}
{"name":"Associated.map","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝³ : Monoid M\ninst✝² : Monoid N\nF : Type u_4\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nf : F\nx y : M\nha : Associated x y\n⊢ Associated (f x) (f y)","decl":"theorem map {M N : Type*} [Monoid M] [Monoid N] {F : Type*} [FunLike F M N] [MonoidHomClass F M N]\n    (f : F) {x y : M} (ha : Associated x y) : Associated (f x) (f y) := by\n  obtain ⟨u, ha⟩ := ha\n  exact ⟨Units.map f u, by rw [← ha, map_mul, Units.coe_map, MonoidHom.coe_coe]⟩\n\n"}
{"name":"unit_associated_one","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nu : Units M\n⊢ Associated (↑u) 1","decl":"theorem unit_associated_one [Monoid M] {u : Mˣ} : (u : M) ~ᵤ 1 :=\n  ⟨u⁻¹, Units.mul_inv u⟩\n\n"}
{"name":"associated_one_iff_isUnit","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\n⊢ Iff (Associated a 1) (IsUnit a)","decl":"@[simp]\ntheorem associated_one_iff_isUnit [Monoid M] {a : M} : (a : M) ~ᵤ 1 ↔ IsUnit a :=\n  Iff.intro\n    (fun h =>\n      let ⟨c, h⟩ := h.symm\n      h ▸ ⟨c, (one_mul _).symm⟩)\n    fun ⟨c, h⟩ => Associated.symm ⟨c, by simp [h]⟩\n\n"}
{"name":"associated_zero_iff_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : MonoidWithZero M\na : M\n⊢ Iff (Associated a 0) (Eq a 0)","decl":"@[simp]\ntheorem associated_zero_iff_eq_zero [MonoidWithZero M] (a : M) : a ~ᵤ 0 ↔ a = 0 :=\n  Iff.intro\n    (fun h => by\n      let ⟨u, h⟩ := h.symm\n      simpa using h.symm)\n    fun h => h ▸ Associated.refl a\n\n"}
{"name":"associated_one_of_mul_eq_one","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\nhab : Eq (HMul.hMul a b) 1\n⊢ Associated a 1","decl":"theorem associated_one_of_mul_eq_one [CommMonoid M] {a : M} (b : M) (hab : a * b = 1) : a ~ᵤ 1 :=\n  show (Units.mkOfMulEqOne a b hab : M) ~ᵤ 1 from unit_associated_one\n\n"}
{"name":"associated_one_of_associated_mul_one","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\na✝ : Associated (HMul.hMul a b) 1\n⊢ Associated a 1","decl":"theorem associated_one_of_associated_mul_one [CommMonoid M] {a b : M} : a * b ~ᵤ 1 → a ~ᵤ 1\n  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h\n\n"}
{"name":"associated_mul_unit_left","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : Monoid N\na u : N\nhu : IsUnit u\n⊢ Associated (HMul.hMul a u) a","decl":"theorem associated_mul_unit_left {N : Type*} [Monoid N] (a u : N) (hu : IsUnit u) :\n    Associated (a * u) a :=\n  let ⟨u', hu⟩ := hu\n  ⟨u'⁻¹, hu ▸ Units.mul_inv_cancel_right _ _⟩\n\n"}
{"name":"associated_unit_mul_left","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : CommMonoid N\na u : N\nhu : IsUnit u\n⊢ Associated (HMul.hMul u a) a","decl":"theorem associated_unit_mul_left {N : Type*} [CommMonoid N] (a u : N) (hu : IsUnit u) :\n    Associated (u * a) a := by\n  rw [mul_comm]\n  exact associated_mul_unit_left _ _ hu\n\n"}
{"name":"associated_mul_unit_right","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : Monoid N\na u : N\nhu : IsUnit u\n⊢ Associated a (HMul.hMul a u)","decl":"theorem associated_mul_unit_right {N : Type*} [Monoid N] (a u : N) (hu : IsUnit u) :\n    Associated a (a * u) :=\n  (associated_mul_unit_left a u hu).symm\n\n"}
{"name":"associated_unit_mul_right","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : CommMonoid N\na u : N\nhu : IsUnit u\n⊢ Associated a (HMul.hMul u a)","decl":"theorem associated_unit_mul_right {N : Type*} [CommMonoid N] (a u : N) (hu : IsUnit u) :\n    Associated a (u * a) :=\n  (associated_unit_mul_left a u hu).symm\n\n"}
{"name":"associated_mul_isUnit_left_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : Monoid N\na u b : N\nhu : IsUnit u\n⊢ Iff (Associated (HMul.hMul a u) b) (Associated a b)","decl":"theorem associated_mul_isUnit_left_iff {N : Type*} [Monoid N] {a u b : N} (hu : IsUnit u) :\n    Associated (a * u) b ↔ Associated a b :=\n  ⟨(associated_mul_unit_right _ _ hu).trans, (associated_mul_unit_left _ _ hu).trans⟩\n\n"}
{"name":"associated_isUnit_mul_left_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : CommMonoid N\nu a b : N\nhu : IsUnit u\n⊢ Iff (Associated (HMul.hMul u a) b) (Associated a b)","decl":"theorem associated_isUnit_mul_left_iff {N : Type*} [CommMonoid N] {u a b : N} (hu : IsUnit u) :\n    Associated (u * a) b ↔ Associated a b := by\n  rw [mul_comm]\n  exact associated_mul_isUnit_left_iff hu\n\n"}
{"name":"associated_mul_isUnit_right_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : Monoid N\na b u : N\nhu : IsUnit u\n⊢ Iff (Associated a (HMul.hMul b u)) (Associated a b)","decl":"theorem associated_mul_isUnit_right_iff {N : Type*} [Monoid N] {a b u : N} (hu : IsUnit u) :\n    Associated a (b * u) ↔ Associated a b :=\n  Associated.comm.trans <| (associated_mul_isUnit_left_iff hu).trans Associated.comm\n\n"}
{"name":"associated_isUnit_mul_right_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : CommMonoid N\na u b : N\nhu : IsUnit u\n⊢ Iff (Associated a (HMul.hMul u b)) (Associated a b)","decl":"theorem associated_isUnit_mul_right_iff {N : Type*} [CommMonoid N] {a u b : N} (hu : IsUnit u) :\n    Associated a (u * b) ↔ Associated a b :=\n  Associated.comm.trans <| (associated_isUnit_mul_left_iff hu).trans Associated.comm\n\n"}
{"name":"associated_mul_unit_left_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : Monoid N\na b : N\nu : Units N\n⊢ Iff (Associated (HMul.hMul a ↑u) b) (Associated a b)","decl":"@[simp]\ntheorem associated_mul_unit_left_iff {N : Type*} [Monoid N] {a b : N} {u : Units N} :\n    Associated (a * u) b ↔ Associated a b :=\n  associated_mul_isUnit_left_iff u.isUnit\n\n"}
{"name":"associated_unit_mul_left_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : CommMonoid N\na b : N\nu : Units N\n⊢ Iff (Associated (HMul.hMul (↑u) a) b) (Associated a b)","decl":"@[simp]\ntheorem associated_unit_mul_left_iff {N : Type*} [CommMonoid N] {a b : N} {u : Units N} :\n    Associated (↑u * a) b ↔ Associated a b :=\n  associated_isUnit_mul_left_iff u.isUnit\n\n"}
{"name":"associated_mul_unit_right_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : Monoid N\na b : N\nu : Units N\n⊢ Iff (Associated a (HMul.hMul b ↑u)) (Associated a b)","decl":"@[simp]\ntheorem associated_mul_unit_right_iff {N : Type*} [Monoid N] {a b : N} {u : Units N} :\n    Associated a (b * u) ↔ Associated a b :=\n  associated_mul_isUnit_right_iff u.isUnit\n\n"}
{"name":"associated_unit_mul_right_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"N : Type u_2\ninst✝ : CommMonoid N\na b : N\nu : Units N\n⊢ Iff (Associated a (HMul.hMul (↑u) b)) (Associated a b)","decl":"@[simp]\ntheorem associated_unit_mul_right_iff {N : Type*} [CommMonoid N] {a b : N} {u : Units N} :\n    Associated a (↑u * b) ↔ Associated a b :=\n  associated_isUnit_mul_right_iff u.isUnit\n\n"}
{"name":"Associated.mul_left","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b c : M\nh : Associated b c\n⊢ Associated (HMul.hMul a b) (HMul.hMul a c)","decl":"theorem Associated.mul_left [Monoid M] (a : M) {b c : M} (h : b ~ᵤ c) : a * b ~ᵤ a * c := by\n  obtain ⟨d, rfl⟩ := h; exact ⟨d, mul_assoc _ _ _⟩\n\n"}
{"name":"Associated.mul_right","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\nh : Associated a b\nc : M\n⊢ Associated (HMul.hMul a c) (HMul.hMul b c)","decl":"theorem Associated.mul_right [CommMonoid M] {a b : M} (h : a ~ᵤ b) (c : M) : a * c ~ᵤ b * c := by\n  obtain ⟨d, rfl⟩ := h; exact ⟨d, mul_right_comm _ _ _⟩\n\n"}
{"name":"Associated.mul_mul","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na₁ a₂ b₁ b₂ : M\nh₁ : Associated a₁ b₁\nh₂ : Associated a₂ b₂\n⊢ Associated (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂)","decl":"theorem Associated.mul_mul [CommMonoid M] {a₁ a₂ b₁ b₂ : M}\n    (h₁ : a₁ ~ᵤ b₁) (h₂ : a₂ ~ᵤ b₂) : a₁ * a₂ ~ᵤ b₁ * b₂ := (h₁.mul_right _).trans (h₂.mul_left _)\n\n"}
{"name":"Associated.pow_pow","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\nn : Nat\nh : Associated a b\n⊢ Associated (HPow.hPow a n) (HPow.hPow b n)","decl":"theorem Associated.pow_pow [CommMonoid M] {a b : M} {n : ℕ} (h : a ~ᵤ b) : a ^ n ~ᵤ b ^ n := by\n  induction n with\n  | zero => simp [Associated.refl]\n  | succ n ih => convert h.mul_mul ih <;> rw [pow_succ']\n\n"}
{"name":"Associated.dvd","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\na✝ : Associated a b\n⊢ Dvd.dvd a b","decl":"protected theorem Associated.dvd [Monoid M] {a b : M} : a ~ᵤ b → a ∣ b := fun ⟨u, hu⟩ =>\n  ⟨u, hu.symm⟩\n\n"}
{"name":"Associated.dvd'","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\nh : Associated a b\n⊢ Dvd.dvd b a","decl":"protected theorem Associated.dvd' [Monoid M] {a b : M} (h : a ~ᵤ b) : b ∣ a :=\n  h.symm.dvd\n\n"}
{"name":"Associated.dvd_dvd","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\nh : Associated a b\n⊢ And (Dvd.dvd a b) (Dvd.dvd b a)","decl":"protected theorem Associated.dvd_dvd [Monoid M] {a b : M} (h : a ~ᵤ b) : a ∣ b ∧ b ∣ a :=\n  ⟨h.dvd, h.symm.dvd⟩\n\n"}
{"name":"associated_of_dvd_dvd","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelMonoidWithZero M\na b : M\nhab : Dvd.dvd a b\nhba : Dvd.dvd b a\n⊢ Associated a b","decl":"theorem associated_of_dvd_dvd [CancelMonoidWithZero M] {a b : M} (hab : a ∣ b) (hba : b ∣ a) :\n    a ~ᵤ b := by\n  rcases hab with ⟨c, rfl⟩\n  rcases hba with ⟨d, a_eq⟩\n  by_cases ha0 : a = 0\n  · simp_all\n  have hac0 : a * c ≠ 0 := by\n    intro con\n    rw [con, zero_mul] at a_eq\n    apply ha0 a_eq\n  have : a * (c * d) = a * 1 := by rw [← mul_assoc, ← a_eq, mul_one]\n  have hcd : c * d = 1 := mul_left_cancel₀ ha0 this\n  have : a * c * (d * c) = a * c * 1 := by rw [← mul_assoc, ← a_eq, mul_one]\n  have hdc : d * c = 1 := mul_left_cancel₀ hac0 this\n  exact ⟨⟨c, d, hcd, hdc⟩, rfl⟩\n\n"}
{"name":"dvd_dvd_iff_associated","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelMonoidWithZero M\na b : M\n⊢ Iff (And (Dvd.dvd a b) (Dvd.dvd b a)) (Associated a b)","decl":"theorem dvd_dvd_iff_associated [CancelMonoidWithZero M] {a b : M} : a ∣ b ∧ b ∣ a ↔ a ~ᵤ b :=\n  ⟨fun ⟨h1, h2⟩ => associated_of_dvd_dvd h1 h2, Associated.dvd_dvd⟩\n\n"}
{"name":"Associated.dvd_iff_dvd_left","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b c : M\nh : Associated a b\n⊢ Iff (Dvd.dvd a c) (Dvd.dvd b c)","decl":"theorem Associated.dvd_iff_dvd_left [Monoid M] {a b c : M} (h : a ~ᵤ b) : a ∣ c ↔ b ∣ c :=\n  let ⟨_, hu⟩ := h\n  hu ▸ Units.mul_right_dvd.symm\n\n"}
{"name":"Associated.dvd_iff_dvd_right","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b c : M\nh : Associated b c\n⊢ Iff (Dvd.dvd a b) (Dvd.dvd a c)","decl":"theorem Associated.dvd_iff_dvd_right [Monoid M] {a b c : M} (h : b ~ᵤ c) : a ∣ b ↔ a ∣ c :=\n  let ⟨_, hu⟩ := h\n  hu ▸ Units.dvd_mul_right.symm\n\n"}
{"name":"Associated.eq_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : MonoidWithZero M\na b : M\nh : Associated a b\n⊢ Iff (Eq a 0) (Eq b 0)","decl":"theorem Associated.eq_zero_iff [MonoidWithZero M] {a b : M} (h : a ~ᵤ b) : a = 0 ↔ b = 0 := by\n  obtain ⟨u, rfl⟩ := h\n  rw [← Units.eq_mul_inv_iff_mul_eq, zero_mul]\n\n"}
{"name":"Associated.ne_zero_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : MonoidWithZero M\na b : M\nh : Associated a b\n⊢ Iff (Ne a 0) (Ne b 0)","decl":"theorem Associated.ne_zero_iff [MonoidWithZero M] {a b : M} (h : a ~ᵤ b) : a ≠ 0 ↔ b ≠ 0 :=\n  not_congr h.eq_zero_iff\n\n"}
{"name":"Associated.prime","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\np q : M\nh : Associated p q\nhp : Prime p\n⊢ Prime q","decl":"protected theorem Associated.prime [CommMonoidWithZero M] {p q : M} (h : p ~ᵤ q) (hp : Prime p) :\n    Prime q :=\n  ⟨h.ne_zero_iff.1 hp.ne_zero,\n    let ⟨u, hu⟩ := h\n    ⟨fun ⟨v, hv⟩ => hp.not_unit ⟨v * u⁻¹, by simp [hv, hu.symm]⟩,\n      hu ▸ by\n        simp only [IsUnit.mul_iff, Units.isUnit, and_true, IsUnit.mul_right_dvd]\n        intro a b\n        exact hp.dvd_or_dvd⟩⟩\n\n"}
{"name":"prime_mul_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nx y : M\n⊢ Iff (Prime (HMul.hMul x y)) (Or (And (Prime x) (IsUnit y)) (And (IsUnit x) (Prime y)))","decl":"theorem prime_mul_iff [CancelCommMonoidWithZero M] {x y : M} :\n    Prime (x * y) ↔ (Prime x ∧ IsUnit y) ∨ (IsUnit x ∧ Prime y) := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · rcases of_irreducible_mul h.irreducible with hx | hy\n    · exact Or.inr ⟨hx, (associated_unit_mul_left y x hx).prime h⟩\n    · exact Or.inl ⟨(associated_mul_unit_left x y hy).prime h, hy⟩\n  · rintro (⟨hx, hy⟩ | ⟨hx, hy⟩)\n    · exact (associated_mul_unit_left x y hy).symm.prime hx\n    · exact (associated_unit_mul_right y x hx).prime hy\n\n"}
{"name":"prime_pow_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np : M\nn : Nat\n⊢ Iff (Prime (HPow.hPow p n)) (And (Prime p) (Eq n 1))","decl":"@[simp]\nlemma prime_pow_iff [CancelCommMonoidWithZero M] {p : M} {n : ℕ} :\n    Prime (p ^ n) ↔ Prime p ∧ n = 1 := by\n  refine ⟨fun hp ↦ ?_, fun ⟨hp, hn⟩ ↦ by simpa [hn]⟩\n  suffices n = 1 by aesop\n  rcases n with - | n\n  · simp at hp\n  · rw [Nat.succ.injEq]\n    rw [pow_succ', prime_mul_iff] at hp\n    rcases hp with ⟨hp, hpn⟩ | ⟨hp, hpn⟩\n    · by_contra contra\n      rw [isUnit_pow_iff contra] at hpn\n      exact hp.not_unit hpn\n    · exfalso\n      exact hpn.not_unit (hp.pow n)\n\n"}
{"name":"Irreducible.dvd_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx y : M\nhx : Irreducible x\n⊢ Iff (Dvd.dvd y x) (Or (IsUnit y) (Associated x y))","decl":"theorem Irreducible.dvd_iff [Monoid M] {x y : M} (hx : Irreducible x) :\n    y ∣ x ↔ IsUnit y ∨ Associated x y := by\n  constructor\n  · rintro ⟨z, hz⟩\n    obtain (h|h) := hx.isUnit_or_isUnit hz\n    · exact Or.inl h\n    · rw [hz]\n      exact Or.inr (associated_mul_unit_left _ _ h)\n  · rintro (hy|h)\n    · exact hy.dvd\n    · exact h.symm.dvd\n\n"}
{"name":"Irreducible.associated_of_dvd","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\np q : M\np_irr : Irreducible p\nq_irr : Irreducible q\ndvd : Dvd.dvd p q\n⊢ Associated p q","decl":"theorem Irreducible.associated_of_dvd [Monoid M] {p q : M} (p_irr : Irreducible p)\n    (q_irr : Irreducible q) (dvd : p ∣ q) : Associated p q :=\n  ((q_irr.dvd_iff.mp dvd).resolve_left p_irr.not_unit).symm\n\n"}
{"name":"Irreducible.dvd_irreducible_iff_associated","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\np q : M\npp : Irreducible p\nqp : Irreducible q\n⊢ Iff (Dvd.dvd p q) (Associated p q)","decl":"theorem Irreducible.dvd_irreducible_iff_associated [Monoid M] {p q : M}\n    (pp : Irreducible p) (qp : Irreducible q) : p ∣ q ↔ Associated p q :=\n  ⟨Irreducible.associated_of_dvd pp qp, Associated.dvd⟩\n\n"}
{"name":"Prime.associated_of_dvd","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np q : M\np_prime : Prime p\nq_prime : Prime q\ndvd : Dvd.dvd p q\n⊢ Associated p q","decl":"theorem Prime.associated_of_dvd [CancelCommMonoidWithZero M] {p q : M} (p_prime : Prime p)\n    (q_prime : Prime q) (dvd : p ∣ q) : Associated p q :=\n  p_prime.irreducible.associated_of_dvd q_prime.irreducible dvd\n\n"}
{"name":"Prime.dvd_prime_iff_associated","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np q : M\npp : Prime p\nqp : Prime q\n⊢ Iff (Dvd.dvd p q) (Associated p q)","decl":"theorem Prime.dvd_prime_iff_associated [CancelCommMonoidWithZero M] {p q : M} (pp : Prime p)\n    (qp : Prime q) : p ∣ q ↔ Associated p q :=\n  pp.irreducible.dvd_irreducible_iff_associated qp.irreducible\n\n"}
{"name":"Associated.prime_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\np q : M\nh : Associated p q\n⊢ Iff (Prime p) (Prime q)","decl":"theorem Associated.prime_iff [CommMonoidWithZero M] {p q : M} (h : p ~ᵤ q) : Prime p ↔ Prime q :=\n  ⟨h.prime, h.symm.prime⟩\n\n"}
{"name":"Associated.isUnit","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\nh : Associated a b\na✝ : IsUnit a\n⊢ IsUnit b","decl":"protected theorem Associated.isUnit [Monoid M] {a b : M} (h : a ~ᵤ b) : IsUnit a → IsUnit b :=\n  let ⟨u, hu⟩ := h\n  fun ⟨v, hv⟩ => ⟨v * u, by simp [hv, hu.symm]⟩\n\n"}
{"name":"Associated.isUnit_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\nh : Associated a b\n⊢ Iff (IsUnit a) (IsUnit b)","decl":"theorem Associated.isUnit_iff [Monoid M] {a b : M} (h : a ~ᵤ b) : IsUnit a ↔ IsUnit b :=\n  ⟨h.isUnit, h.symm.isUnit⟩\n\n"}
{"name":"Irreducible.isUnit_iff_not_associated_of_dvd","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx y : M\nhx : Irreducible x\nhy : Dvd.dvd y x\n⊢ Iff (IsUnit y) (Not (Associated x y))","decl":"theorem Irreducible.isUnit_iff_not_associated_of_dvd [Monoid M]\n    {x y : M} (hx : Irreducible x) (hy : y ∣ x) : IsUnit y ↔ ¬ Associated x y :=\n  ⟨fun hy hxy => hx.1 (hxy.symm.isUnit hy), (hx.dvd_iff.mp hy).resolve_right⟩\n\n"}
{"name":"Associated.irreducible","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\np q : M\nh : Associated p q\nhp : Irreducible p\n⊢ Irreducible q","decl":"protected theorem Associated.irreducible [Monoid M] {p q : M} (h : p ~ᵤ q) (hp : Irreducible p) :\n    Irreducible q :=\n  ⟨mt h.symm.isUnit hp.1,\n    let ⟨u, hu⟩ := h\n    fun a b hab =>\n    have hpab : p = a * (b * (u⁻¹ : Mˣ)) :=\n      calc\n        p = p * u * (u⁻¹ : Mˣ) := by simp\n        _ = _ := by rw [hu]; simp [hab, mul_assoc]\n\n    (hp.isUnit_or_isUnit hpab).elim Or.inl fun ⟨v, hv⟩ => Or.inr ⟨v * u, by simp [hv]⟩⟩\n\n"}
{"name":"Associated.irreducible_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\np q : M\nh : Associated p q\n⊢ Iff (Irreducible p) (Irreducible q)","decl":"protected theorem Associated.irreducible_iff [Monoid M] {p q : M} (h : p ~ᵤ q) :\n    Irreducible p ↔ Irreducible q :=\n  ⟨h.irreducible, h.symm.irreducible⟩\n\n"}
{"name":"Associated.of_mul_left","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\na b c d : M\nh : Associated (HMul.hMul a b) (HMul.hMul c d)\nh₁ : Associated a c\nha : Ne a 0\n⊢ Associated b d","decl":"theorem Associated.of_mul_left [CancelCommMonoidWithZero M] {a b c d : M} (h : a * b ~ᵤ c * d)\n    (h₁ : a ~ᵤ c) (ha : a ≠ 0) : b ~ᵤ d :=\n  let ⟨u, hu⟩ := h\n  let ⟨v, hv⟩ := Associated.symm h₁\n  ⟨u * (v : Mˣ),\n    mul_left_cancel₀ ha\n      (by\n        rw [← hv, mul_assoc c (v : M) d, mul_left_comm c, ← hu]\n        simp [hv.symm, mul_assoc, mul_comm, mul_left_comm])⟩\n\n"}
{"name":"Associated.of_mul_right","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\na b c d : M\na✝² : Associated (HMul.hMul a b) (HMul.hMul c d)\na✝¹ : Associated b d\na✝ : Ne b 0\n⊢ Associated a c","decl":"theorem Associated.of_mul_right [CancelCommMonoidWithZero M] {a b c d : M} :\n    a * b ~ᵤ c * d → b ~ᵤ d → b ≠ 0 → a ~ᵤ c := by\n  rw [mul_comm a, mul_comm c]; exact Associated.of_mul_left\n\n"}
{"name":"Associated.of_pow_associated_of_prime","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np₁ p₂ : M\nk₁ k₂ : Nat\nhp₁ : Prime p₁\nhp₂ : Prime p₂\nhk₁ : LT.lt 0 k₁\nh : Associated (HPow.hPow p₁ k₁) (HPow.hPow p₂ k₂)\n⊢ Associated p₁ p₂","decl":"theorem Associated.of_pow_associated_of_prime [CancelCommMonoidWithZero M] {p₁ p₂ : M} {k₁ k₂ : ℕ}\n    (hp₁ : Prime p₁) (hp₂ : Prime p₂) (hk₁ : 0 < k₁) (h : p₁ ^ k₁ ~ᵤ p₂ ^ k₂) : p₁ ~ᵤ p₂ := by\n  have : p₁ ∣ p₂ ^ k₂ := by\n    rw [← h.dvd_iff_dvd_right]\n    apply dvd_pow_self _ hk₁.ne'\n  rw [← hp₁.dvd_prime_iff_associated hp₂]\n  exact hp₁.dvd_of_dvd_pow this\n\n"}
{"name":"Associated.of_pow_associated_of_prime'","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np₁ p₂ : M\nk₁ k₂ : Nat\nhp₁ : Prime p₁\nhp₂ : Prime p₂\nhk₂ : LT.lt 0 k₂\nh : Associated (HPow.hPow p₁ k₁) (HPow.hPow p₂ k₂)\n⊢ Associated p₁ p₂","decl":"theorem Associated.of_pow_associated_of_prime' [CancelCommMonoidWithZero M] {p₁ p₂ : M} {k₁ k₂ : ℕ}\n    (hp₁ : Prime p₁) (hp₂ : Prime p₂) (hk₂ : 0 < k₂) (h : p₁ ^ k₁ ~ᵤ p₂ ^ k₂) : p₁ ~ᵤ p₂ :=\n  (h.symm.of_pow_associated_of_prime hp₂ hp₁ hk₂).symm\n\n"}
{"name":"Irreducible.isRelPrime_iff_not_dvd","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\np n : M\nhp : Irreducible p\n⊢ Iff (IsRelPrime p n) (Not (Dvd.dvd p n))","decl":"/-- See also `Irreducible.coprime_iff_not_dvd`. -/\nlemma Irreducible.isRelPrime_iff_not_dvd [Monoid M] {p n : M} (hp : Irreducible p) :\n    IsRelPrime p n ↔ ¬ p ∣ n := by\n  refine ⟨fun h contra ↦ hp.not_unit (h dvd_rfl contra), fun hpn d hdp hdn ↦ ?_⟩\n  contrapose! hpn\n  suffices Associated p d from this.dvd.trans hdn\n  exact (hp.dvd_iff.mp hdp).resolve_left hpn\n\n"}
{"name":"Irreducible.dvd_or_isRelPrime","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\np n : M\nhp : Irreducible p\n⊢ Or (Dvd.dvd p n) (IsRelPrime p n)","decl":"lemma Irreducible.dvd_or_isRelPrime [Monoid M] {p n : M} (hp : Irreducible p) :\n    p ∣ n ∨ IsRelPrime p n := Classical.or_iff_not_imp_left.mpr hp.isRelPrime_iff_not_dvd.2\n\n"}
{"name":"associated_iff_eq","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : Subsingleton (Units M)\nx y : M\n⊢ Iff (Associated x y) (Eq x y)","decl":"theorem associated_iff_eq {x y : M} : x ~ᵤ y ↔ x = y := by\n  constructor\n  · rintro ⟨c, rfl⟩\n    rw [units_eq_one c, Units.val_one, mul_one]\n  · rintro rfl\n    rfl\n\n"}
{"name":"associated_eq_eq","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : Subsingleton (Units M)\n⊢ Eq Associated Eq","decl":"theorem associated_eq_eq : (Associated : M → M → Prop) = Eq := by\n  ext\n  rw [associated_iff_eq]\n\n"}
{"name":"prime_dvd_prime_iff_eq","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_2\ninst✝¹ : CancelCommMonoidWithZero M\ninst✝ : Subsingleton (Units M)\np q : M\npp : Prime p\nqp : Prime q\n⊢ Iff (Dvd.dvd p q) (Eq p q)","decl":"theorem prime_dvd_prime_iff_eq {M : Type*} [CancelCommMonoidWithZero M] [Subsingleton Mˣ] {p q : M}\n    (pp : Prime p) (qp : Prime q) : p ∣ q ↔ p = q := by\n  rw [pp.dvd_prime_iff_associated qp, ← associated_eq_eq]\n\n"}
{"name":"eq_of_prime_pow_eq","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"R : Type u_2\ninst✝¹ : CancelCommMonoidWithZero R\ninst✝ : Subsingleton (Units R)\np₁ p₂ : R\nk₁ k₂ : Nat\nhp₁ : Prime p₁\nhp₂ : Prime p₂\nhk₁ : LT.lt 0 k₁\nh : Eq (HPow.hPow p₁ k₁) (HPow.hPow p₂ k₂)\n⊢ Eq p₁ p₂","decl":"theorem eq_of_prime_pow_eq (hp₁ : Prime p₁) (hp₂ : Prime p₂) (hk₁ : 0 < k₁)\n    (h : p₁ ^ k₁ = p₂ ^ k₂) : p₁ = p₂ := by\n  rw [← associated_iff_eq] at h ⊢\n  apply h.of_pow_associated_of_prime hp₁ hp₂ hk₁\n\n"}
{"name":"eq_of_prime_pow_eq'","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"R : Type u_2\ninst✝¹ : CancelCommMonoidWithZero R\ninst✝ : Subsingleton (Units R)\np₁ p₂ : R\nk₁ k₂ : Nat\nhp₁ : Prime p₁\nhp₂ : Prime p₂\nhk₁ : LT.lt 0 k₂\nh : Eq (HPow.hPow p₁ k₁) (HPow.hPow p₂ k₂)\n⊢ Eq p₁ p₂","decl":"theorem eq_of_prime_pow_eq' (hp₁ : Prime p₁) (hp₂ : Prime p₂) (hk₁ : 0 < k₂)\n    (h : p₁ ^ k₁ = p₂ ^ k₂) : p₁ = p₂ := by\n  rw [← associated_iff_eq] at h ⊢\n  apply h.of_pow_associated_of_prime' hp₁ hp₂ hk₁\n\n"}
{"name":"Associates.mk_eq_mk_iff_associated","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\n⊢ Iff (Eq (Associates.mk a) (Associates.mk b)) (Associated a b)","decl":"theorem mk_eq_mk_iff_associated [Monoid M] {a b : M} : Associates.mk a = Associates.mk b ↔ a ~ᵤ b :=\n  Iff.intro Quotient.exact Quot.sound\n\n"}
{"name":"Associates.quotient_mk_eq_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\n⊢ Eq (Quotient.mk (Associated.setoid M) a) (Associates.mk a)","decl":"theorem quotient_mk_eq_mk [Monoid M] (a : M) : ⟦a⟧ = Associates.mk a :=\n  rfl\n\n"}
{"name":"Associates.quot_mk_eq_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\n⊢ Eq (Quot.mk (⇑(Associated.setoid M)) a) (Associates.mk a)","decl":"theorem quot_mk_eq_mk [Monoid M] (a : M) : Quot.mk Setoid.r a = Associates.mk a :=\n  rfl\n\n"}
{"name":"Associates.quot_out","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : Associates M\n⊢ Eq (Associates.mk (Quot.out a)) a","decl":"@[simp]\ntheorem quot_out [Monoid M] (a : Associates M) : Associates.mk (Quot.out a) = a := by\n  rw [← quot_mk_eq_mk, Quot.out_eq]\n\n"}
{"name":"Associates.mk_quot_out","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\n⊢ Associated (Quot.out (Associates.mk a)) a","decl":"theorem mk_quot_out [Monoid M] (a : M) : Quot.out (Associates.mk a) ~ᵤ a := by\n  rw [← Associates.mk_eq_mk_iff_associated, Associates.quot_out]\n\n"}
{"name":"Associates.forall_associated","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\np : Associates M → Prop\n⊢ Iff (∀ (a : Associates M), p a) (∀ (a : M), p (Associates.mk a))","decl":"theorem forall_associated [Monoid M] {p : Associates M → Prop} :\n    (∀ a, p a) ↔ ∀ a, p (Associates.mk a) :=\n  Iff.intro (fun h _ => h _) fun h a => Quotient.inductionOn a h\n\n"}
{"name":"Associates.mk_surjective","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Function.Surjective Associates.mk","decl":"theorem mk_surjective [Monoid M] : Function.Surjective (@Associates.mk M _) :=\n  forall_associated.2 fun a => ⟨a, rfl⟩\n\n"}
{"name":"Associates.mk_one","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq (Associates.mk 1) 1","decl":"@[simp]\ntheorem mk_one [Monoid M] : Associates.mk (1 : M) = 1 :=\n  rfl\n\n"}
{"name":"Associates.one_eq_mk_one","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq 1 (Associates.mk 1)","decl":"theorem one_eq_mk_one [Monoid M] : (1 : Associates M) = Associates.mk 1 :=\n  rfl\n\n"}
{"name":"Associates.mk_eq_one","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\n⊢ Iff (Eq (Associates.mk a) 1) (IsUnit a)","decl":"@[simp]\ntheorem mk_eq_one [Monoid M] {a : M} : Associates.mk a = 1 ↔ IsUnit a := by\n  rw [← mk_one, mk_eq_mk_iff_associated, associated_one_iff_isUnit]\n\n"}
{"name":"Associates.bot_eq_one","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq Bot.bot 1","decl":"theorem bot_eq_one [Monoid M] : (⊥ : Associates M) = 1 :=\n  rfl\n\n"}
{"name":"Associates.exists_rep","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : Associates M\n⊢ Exists fun a0 => Eq (Associates.mk a0) a","decl":"theorem exists_rep [Monoid M] (a : Associates M) : ∃ a0 : M, Associates.mk a0 = a :=\n  Quot.exists_rep a\n\n"}
{"name":"Associates.mk_injective","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : Subsingleton (Units M)\n⊢ Function.Injective Associates.mk","decl":"theorem mk_injective [Monoid M] [Subsingleton Mˣ] : Function.Injective (@Associates.mk M _) :=\n  fun _ _ h => associated_iff_eq.mp (Associates.mk_eq_mk_iff_associated.mp h)\n\n"}
{"name":"Associates.mk_mul_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nx y : M\n⊢ Eq (HMul.hMul (Associates.mk x) (Associates.mk y)) (Associates.mk (HMul.hMul x y))","decl":"theorem mk_mul_mk {x y : M} : Associates.mk x * Associates.mk y = Associates.mk (x * y) :=\n  rfl\n\n"}
{"name":"Associates.mkMonoidHom_apply","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : M\n⊢ Eq (Associates.mkMonoidHom a) (Associates.mk a)","decl":"@[simp]\ntheorem mkMonoidHom_apply (a : M) : Associates.mkMonoidHom a = Associates.mk a :=\n  rfl\n\n"}
{"name":"Associates.associated_map_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nf : MonoidHom (Associates M) M\nhinv : Function.RightInverse (⇑f) Associates.mk\na : M\n⊢ Associated a (f (Associates.mk a))","decl":"theorem associated_map_mk {f : Associates M →* M} (hinv : Function.RightInverse f Associates.mk)\n    (a : M) : a ~ᵤ f (Associates.mk a) :=\n  Associates.mk_eq_mk_iff_associated.1 (hinv (Associates.mk a)).symm\n\n"}
{"name":"Associates.mk_pow","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : M\nn : Nat\n⊢ Eq (Associates.mk (HPow.hPow a n)) (HPow.hPow (Associates.mk a) n)","decl":"theorem mk_pow (a : M) (n : ℕ) : Associates.mk (a ^ n) = Associates.mk a ^ n := by\n  induction n <;> simp [*, pow_succ, Associates.mk_mul_mk.symm]\n\n"}
{"name":"Associates.dvd_eq_le","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\n⊢ Eq (fun x1 x2 => Dvd.dvd x1 x2) fun x1 x2 => LE.le x1 x2","decl":"theorem dvd_eq_le : ((· ∣ ·) : Associates M → Associates M → Prop) = (· ≤ ·) :=\n  rfl\n\n"}
{"name":"Associates.coe_unit_eq_one","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nu : Units (Associates M)\n⊢ Eq (↑u) 1","decl":"@[simp]\ntheorem coe_unit_eq_one (u : (Associates M)ˣ) : (u : Associates M) = 1 := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"Associates.isUnit_iff_eq_one","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : Associates M\n⊢ Iff (IsUnit a) (Eq a 1)","decl":"theorem isUnit_iff_eq_one (a : Associates M) : IsUnit a ↔ a = 1 :=\n  Iff.intro (fun ⟨_, h⟩ => h ▸ coe_unit_eq_one _) fun h => h.symm ▸ isUnit_one\n\n"}
{"name":"Associates.isUnit_iff_eq_bot","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : Associates M\n⊢ Iff (IsUnit a) (Eq a Bot.bot)","decl":"theorem isUnit_iff_eq_bot {a : Associates M} : IsUnit a ↔ a = ⊥ := by\n  rw [Associates.isUnit_iff_eq_one, bot_eq_one]\n\n"}
{"name":"Associates.isUnit_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : M\n⊢ Iff (IsUnit (Associates.mk a)) (IsUnit a)","decl":"theorem isUnit_mk {a : M} : IsUnit (Associates.mk a) ↔ IsUnit a :=\n  calc\n    IsUnit (Associates.mk a) ↔ a ~ᵤ 1 := by\n      rw [isUnit_iff_eq_one, one_eq_mk_one, mk_eq_mk_iff_associated]\n    _ ↔ IsUnit a := associated_one_iff_isUnit\n\n"}
{"name":"Associates.mul_mono","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b c d : Associates M\nh₁ : LE.le a b\nh₂ : LE.le c d\n⊢ LE.le (HMul.hMul a c) (HMul.hMul b d)","decl":"theorem mul_mono {a b c d : Associates M} (h₁ : a ≤ b) (h₂ : c ≤ d) : a * c ≤ b * d :=\n  let ⟨x, hx⟩ := h₁\n  let ⟨y, hy⟩ := h₂\n  ⟨x * y, by simp [hx, hy, mul_comm, mul_assoc, mul_left_comm]⟩\n\n"}
{"name":"Associates.one_le","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : Associates M\n⊢ LE.le 1 a","decl":"theorem one_le {a : Associates M} : 1 ≤ a :=\n  Dvd.intro _ (one_mul a)\n\n"}
{"name":"Associates.le_mul_right","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : Associates M\n⊢ LE.le a (HMul.hMul a b)","decl":"theorem le_mul_right {a b : Associates M} : a ≤ a * b :=\n  ⟨b, rfl⟩\n\n"}
{"name":"Associates.le_mul_left","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : Associates M\n⊢ LE.le a (HMul.hMul b a)","decl":"theorem le_mul_left {a b : Associates M} : a ≤ b * a := by rw [mul_comm]; exact le_mul_right\n\n"}
{"name":"Associates.mk_dvd_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\n⊢ Iff (Dvd.dvd (Associates.mk a) (Associates.mk b)) (Dvd.dvd a b)","decl":"@[simp]\ntheorem mk_dvd_mk {a b : M} : Associates.mk a ∣ Associates.mk b ↔ a ∣ b := by\n  simp only [dvd_def, mk_surjective.exists, mk_mul_mk, mk_eq_mk_iff_associated,\n    Associated.comm (x := b)]\n  constructor\n  · rintro ⟨x, u, rfl⟩\n    exact ⟨_, mul_assoc ..⟩\n  · rintro ⟨c, rfl⟩\n    use c\n\n"}
{"name":"Associates.dvd_of_mk_le_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\na✝ : LE.le (Associates.mk a) (Associates.mk b)\n⊢ Dvd.dvd a b","decl":"theorem dvd_of_mk_le_mk {a b : M} : Associates.mk a ≤ Associates.mk b → a ∣ b :=\n  mk_dvd_mk.mp\n\n"}
{"name":"Associates.mk_le_mk_of_dvd","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\na✝ : Dvd.dvd a b\n⊢ LE.le (Associates.mk a) (Associates.mk b)","decl":"theorem mk_le_mk_of_dvd {a b : M} : a ∣ b → Associates.mk a ≤ Associates.mk b :=\n  mk_dvd_mk.mpr\n\n"}
{"name":"Associates.mk_le_mk_iff_dvd","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\n⊢ Iff (LE.le (Associates.mk a) (Associates.mk b)) (Dvd.dvd a b)","decl":"theorem mk_le_mk_iff_dvd {a b : M} : Associates.mk a ≤ Associates.mk b ↔ a ∣ b := mk_dvd_mk\n\n\n"}
{"name":"Associates.isPrimal_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : M\n⊢ Iff (IsPrimal (Associates.mk a)) (IsPrimal a)","decl":"@[simp]\ntheorem isPrimal_mk {a : M} : IsPrimal (Associates.mk a) ↔ IsPrimal a := by\n  simp_rw [IsPrimal, forall_associated, mk_surjective.exists, mk_mul_mk, mk_dvd_mk]\n  constructor <;> intro h b c dvd <;> obtain ⟨a₁, a₂, h₁, h₂, eq⟩ := @h b c dvd\n  · obtain ⟨u, rfl⟩ := mk_eq_mk_iff_associated.mp eq.symm\n    exact ⟨a₁, a₂ * u, h₁, Units.mul_right_dvd.mpr h₂, mul_assoc _ _ _⟩\n  · exact ⟨a₁, a₂, h₁, h₂, congr_arg _ eq⟩\n\n\n"}
{"name":"Associates.decompositionMonoid_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\n⊢ Iff (DecompositionMonoid (Associates M)) (DecompositionMonoid M)","decl":"@[simp]\ntheorem decompositionMonoid_iff : DecompositionMonoid (Associates M) ↔ DecompositionMonoid M := by\n  simp_rw [_root_.decompositionMonoid_iff, forall_associated, isPrimal_mk]\n\n"}
{"name":"Associates.instDecompositionMonoid","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\ninst✝ : DecompositionMonoid M\n⊢ DecompositionMonoid (Associates M)","decl":"instance instDecompositionMonoid [DecompositionMonoid M] : DecompositionMonoid (Associates M) :=\n  decompositionMonoid_iff.mpr ‹_›\n\n"}
{"name":"Associates.mk_isRelPrime_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na b : M\n⊢ Iff (IsRelPrime (Associates.mk a) (Associates.mk b)) (IsRelPrime a b)","decl":"@[simp]\ntheorem mk_isRelPrime_iff {a b : M} :\n    IsRelPrime (Associates.mk a) (Associates.mk b) ↔ IsRelPrime a b := by\n  simp_rw [IsRelPrime, forall_associated, mk_dvd_mk, isUnit_mk]\n\n"}
{"name":"Associates.mk_zero","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝¹ : Zero M\ninst✝ : Monoid M\n⊢ Eq (Associates.mk 0) 0","decl":"@[simp] theorem mk_zero [Zero M] [Monoid M] : Associates.mk (0 : M) = 0 := rfl\n\n"}
{"name":"Associates.mk_eq_zero","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : MonoidWithZero M\na : M\n⊢ Iff (Eq (Associates.mk a) 0) (Eq a 0)","decl":"@[simp]\ntheorem mk_eq_zero {a : M} : Associates.mk a = 0 ↔ a = 0 :=\n  ⟨fun h => (associated_zero_iff_eq_zero a).1 <| Quotient.exact h, fun h => h.symm ▸ rfl⟩\n\n"}
{"name":"Associates.quot_out_zero","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : MonoidWithZero M\n⊢ Eq (Quot.out 0) 0","decl":"@[simp]\ntheorem quot_out_zero : Quot.out (0 : Associates M) = 0 := by rw [← mk_eq_zero, quot_out]\n\n"}
{"name":"Associates.mk_ne_zero","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : MonoidWithZero M\na : M\n⊢ Iff (Ne (Associates.mk a) 0) (Ne a 0)","decl":"theorem mk_ne_zero {a : M} : Associates.mk a ≠ 0 ↔ a ≠ 0 :=\n  not_congr mk_eq_zero\n\n"}
{"name":"Associates.instNontrivial","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝¹ : MonoidWithZero M\ninst✝ : Nontrivial M\n⊢ Nontrivial (Associates M)","decl":"instance [Nontrivial M] : Nontrivial (Associates M) :=\n  ⟨⟨1, 0, mk_ne_zero.2 one_ne_zero⟩⟩\n\n"}
{"name":"Associates.exists_non_zero_rep","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : MonoidWithZero M\na : Associates M\na✝ : Ne a 0\n⊢ Exists fun a0 => And (Ne a0 0) (Eq (Associates.mk a0) a)","decl":"theorem exists_non_zero_rep {a : Associates M} : a ≠ 0 → ∃ a0 : M, a0 ≠ 0 ∧ Associates.mk a0 = a :=\n  Quotient.inductionOn a fun b nz => ⟨b, mt (congr_arg Quotient.mk'') nz, rfl⟩\n\n"}
{"name":"Associates.le_zero","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\na : Associates M\n⊢ LE.le a 0","decl":"@[simp] protected theorem le_zero (a : Associates M) : a ≤ 0 := le_top\n\n"}
{"name":"Associates.Prime.le_or_le","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\np : Associates M\nhp : Prime p\na b : Associates M\nh : LE.le p (HMul.hMul a b)\n⊢ Or (LE.le p a) (LE.le p b)","decl":"theorem Prime.le_or_le {p : Associates M} (hp : Prime p) {a b : Associates M} (h : p ≤ a * b) :\n    p ≤ a ∨ p ≤ b :=\n  hp.2.2 a b h\n\n"}
{"name":"Associates.prime_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\np : M\n⊢ Iff (Prime (Associates.mk p)) (Prime p)","decl":"@[simp]\ntheorem prime_mk {p : M} : Prime (Associates.mk p) ↔ Prime p := by\n  rw [Prime, _root_.Prime, forall_associated]\n  simp only [forall_associated, mk_ne_zero, isUnit_mk, mk_mul_mk, mk_dvd_mk]\n\n"}
{"name":"Associates.irreducible_mk","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\na : M\n⊢ Iff (Irreducible (Associates.mk a)) (Irreducible a)","decl":"@[simp]\ntheorem irreducible_mk {a : M} : Irreducible (Associates.mk a) ↔ Irreducible a := by\n  simp only [irreducible_iff, isUnit_mk, forall_associated, isUnit_mk, mk_mul_mk,\n    mk_eq_mk_iff_associated, Associated.comm (x := a)]\n  apply Iff.rfl.and\n  constructor\n  · rintro h x y rfl\n    exact h _ _ <| .refl _\n  · rintro h x y ⟨u, rfl⟩\n    simpa using h x (y * u) (mul_assoc _ _ _)\n\n"}
{"name":"Associates.mk_dvdNotUnit_mk_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\na b : M\n⊢ Iff (DvdNotUnit (Associates.mk a) (Associates.mk b)) (DvdNotUnit a b)","decl":"@[simp]\ntheorem mk_dvdNotUnit_mk_iff {a b : M} :\n    DvdNotUnit (Associates.mk a) (Associates.mk b) ↔ DvdNotUnit a b := by\n  simp only [DvdNotUnit, mk_ne_zero, mk_surjective.exists, isUnit_mk, mk_mul_mk,\n    mk_eq_mk_iff_associated, Associated.comm (x := b)]\n  refine Iff.rfl.and ?_\n  constructor\n  · rintro ⟨x, hx, u, rfl⟩\n    refine ⟨x * u, ?_, mul_assoc ..⟩\n    simpa\n  · rintro ⟨x, ⟨hx, rfl⟩⟩\n    use x\n\n"}
{"name":"Associates.dvdNotUnit_of_lt","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\na b : Associates M\nhlt : LT.lt a b\n⊢ DvdNotUnit a b","decl":"theorem dvdNotUnit_of_lt {a b : Associates M} (hlt : a < b) : DvdNotUnit a b := by\n  constructor\n  · rintro rfl\n    apply not_lt_of_le _ hlt\n    apply dvd_zero\n  rcases hlt with ⟨⟨x, rfl⟩, ndvd⟩\n  refine ⟨x, ?_, rfl⟩\n  contrapose! ndvd\n  rcases ndvd with ⟨u, rfl⟩\n  simp\n\n"}
{"name":"Associates.irreducible_iff_prime_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\n⊢ Iff (∀ (a : M), Iff (Irreducible a) (Prime a)) (∀ (a : Associates M), Iff (Irreducible a) (Prime a))","decl":"theorem irreducible_iff_prime_iff :\n    (∀ a : M, Irreducible a ↔ Prime a) ↔ ∀ a : Associates M, Irreducible a ↔ Prime a := by\n  simp_rw [forall_associated, irreducible_mk, prime_mk]\n\n"}
{"name":"associates_irreducible_iff_prime","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝¹ : CancelCommMonoidWithZero M\ninst✝ : DecompositionMonoid M\np : Associates M\n⊢ Iff (Irreducible p) (Prime p)","decl":"theorem _root_.associates_irreducible_iff_prime [DecompositionMonoid M] {p : Associates M} :\n    Irreducible p ↔ Prime p := irreducible_iff_prime\n\n"}
{"name":"Associates.instNoZeroDivisors","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\n⊢ NoZeroDivisors (Associates M)","decl":"instance : NoZeroDivisors (Associates M) := by infer_instance\n\n"}
{"name":"Associates.le_of_mul_le_mul_left","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\na b c : Associates M\nha : Ne a 0\na✝ : LE.le (HMul.hMul a b) (HMul.hMul a c)\n⊢ LE.le b c","decl":"theorem le_of_mul_le_mul_left (a b c : Associates M) (ha : a ≠ 0) : a * b ≤ a * c → b ≤ c\n  | ⟨d, hd⟩ => ⟨d, mul_left_cancel₀ ha <| by rwa [← mul_assoc]⟩\n\n"}
{"name":"Associates.one_or_eq_of_le_of_prime","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np m : Associates M\nhp : Prime p\nhle : LE.le m p\n⊢ Or (Eq m 1) (Eq m p)","decl":"theorem one_or_eq_of_le_of_prime {p m : Associates M} (hp : Prime p) (hle : m ≤ p) :\n    m = 1 ∨ m = p := by\n  rcases mk_surjective p with ⟨p, rfl⟩\n  rcases mk_surjective m with ⟨m, rfl⟩\n  simpa [mk_eq_mk_iff_associated, Associated.comm, -Quotient.eq]\n    using (prime_mk.1 hp).irreducible.dvd_iff.mp (mk_le_mk_iff_dvd.1 hle)\n\n"}
{"name":"Associates.dvdNotUnit_iff_lt","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\na b : Associates M\n⊢ Iff (DvdNotUnit a b) (LT.lt a b)","decl":"theorem dvdNotUnit_iff_lt {a b : Associates M} : DvdNotUnit a b ↔ a < b :=\n  dvd_and_not_dvd_iff.symm\n\n"}
{"name":"Associates.le_one_iff","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np : Associates M\n⊢ Iff (LE.le p 1) (Eq p 1)","decl":"theorem le_one_iff {p : Associates M} : p ≤ 1 ↔ p = 1 := by rw [← Associates.bot_eq_one, le_bot_iff]\n\n"}
{"name":"dvdNotUnit_of_dvdNotUnit_associated","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoidWithZero M\ninst✝ : Nontrivial M\np q r : M\nh : DvdNotUnit p q\nh' : Associated q r\n⊢ DvdNotUnit p r","decl":"theorem dvdNotUnit_of_dvdNotUnit_associated [CommMonoidWithZero M] [Nontrivial M] {p q r : M}\n    (h : DvdNotUnit p q) (h' : Associated q r) : DvdNotUnit p r := by\n  obtain ⟨u, rfl⟩ := Associated.symm h'\n  obtain ⟨hp, x, hx⟩ := h\n  refine ⟨hp, x * ↑u⁻¹, DvdNotUnit.not_unit ⟨u⁻¹.ne_zero, x, hx.left, mul_comm _ _⟩, ?_⟩\n  rw [← mul_assoc, ← hx.right, mul_assoc, Units.mul_inv, mul_one]\n\n"}
{"name":"isUnit_of_associated_mul","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np b : M\nh : Associated (HMul.hMul p b) p\nhp : Ne p 0\n⊢ IsUnit b","decl":"theorem isUnit_of_associated_mul [CancelCommMonoidWithZero M] {p b : M} (h : Associated (p * b) p)\n    (hp : p ≠ 0) : IsUnit b := by\n  obtain ⟨a, ha⟩ := h\n  refine isUnit_of_mul_eq_one b a ((mul_right_inj' hp).mp ?_)\n  rwa [← mul_assoc, mul_one]\n\n"}
{"name":"DvdNotUnit.not_associated","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np q : M\nh : DvdNotUnit p q\n⊢ Not (Associated p q)","decl":"theorem DvdNotUnit.not_associated [CancelCommMonoidWithZero M] {p q : M} (h : DvdNotUnit p q) :\n    ¬Associated p q := by\n  rintro ⟨a, rfl⟩\n  obtain ⟨hp, x, hx, hx'⟩ := h\n  rcases (mul_right_inj' hp).mp hx' with rfl\n  exact hx a.isUnit\n\n"}
{"name":"dvd_prime_pow","module":"Mathlib.Algebra.GroupWithZero.Associated","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np q : M\nhp : Prime p\nn : Nat\n⊢ Iff (Dvd.dvd q (HPow.hPow p n)) (Exists fun i => And (LE.le i n) (Associated q (HPow.hPow p i)))","decl":"theorem dvd_prime_pow [CancelCommMonoidWithZero M] {p q : M} (hp : Prime p) (n : ℕ) :\n    q ∣ p ^ n ↔ ∃ i ≤ n, Associated q (p ^ i) := by\n  induction n generalizing q with\n  | zero =>\n    simp [← isUnit_iff_dvd_one, associated_one_iff_isUnit]\n  | succ n ih =>\n    refine ⟨fun h => ?_, fun ⟨i, hi, hq⟩ => hq.dvd.trans (pow_dvd_pow p hi)⟩\n    rw [pow_succ'] at h\n    rcases hp.left_dvd_or_dvd_right_of_dvd_mul h with (⟨q, rfl⟩ | hno)\n    · rw [mul_dvd_mul_iff_left hp.ne_zero, ih] at h\n      rcases h with ⟨i, hi, hq⟩\n      refine ⟨i + 1, Nat.succ_le_succ hi, (hq.mul_left p).trans ?_⟩\n      rw [pow_succ']\n    · obtain ⟨i, hi, hq⟩ := ih.mp hno\n      exact ⟨i, hi.trans n.le_succ, hq⟩\n\n"}
