{"name":"NonemptyInterval.fst_le_snd","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_6\ninst✝ : LE α\nself : NonemptyInterval α\n⊢ LE.le self.toProd.1 self.toProd.2","decl":"/-- The nonempty closed intervals in an order.\n\nWe define intervals by the pair of endpoints `fst`, `snd`. To convert intervals to the set of\nelements between these endpoints, use the coercion `NonemptyInterval α → Set α`. -/\n@[ext (flat := false)]\nstructure NonemptyInterval (α : Type*) [LE α] extends Prod α α where\n  /-- The starting point of an interval is smaller than the endpoint. -/\n  fst_le_snd : fst ≤ snd\n\n"}
{"name":"NonemptyInterval.mk.sizeOf_spec","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_6\ninst✝¹ : LE α\ninst✝ : SizeOf α\ntoProd : Prod α α\nfst_le_snd : LE.le toProd.1 toProd.2\n⊢ Eq (SizeOf.sizeOf { toProd := toProd, fst_le_snd := fst_le_snd }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toProd)) (SizeOf.sizeOf fst_le_snd))","decl":"/-- The nonempty closed intervals in an order.\n\nWe define intervals by the pair of endpoints `fst`, `snd`. To convert intervals to the set of\nelements between these endpoints, use the coercion `NonemptyInterval α → Set α`. -/\n@[ext (flat := false)]\nstructure NonemptyInterval (α : Type*) [LE α] extends Prod α α where\n  /-- The starting point of an interval is smaller than the endpoint. -/\n  fst_le_snd : fst ≤ snd\n\n"}
{"name":"NonemptyInterval.mk.inj","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_6\ninst✝ : LE α\ntoProd✝ : Prod α α\nfst_le_snd✝ : LE.le toProd✝.1 toProd✝.2\ntoProd : Prod α α\nfst_le_snd : LE.le toProd.1 toProd.2\nx✝ : Eq { toProd := toProd✝, fst_le_snd := fst_le_snd✝ } { toProd := toProd, fst_le_snd := fst_le_snd }\n⊢ Eq toProd✝ toProd","decl":"/-- The nonempty closed intervals in an order.\n\nWe define intervals by the pair of endpoints `fst`, `snd`. To convert intervals to the set of\nelements between these endpoints, use the coercion `NonemptyInterval α → Set α`. -/\n@[ext (flat := false)]\nstructure NonemptyInterval (α : Type*) [LE α] extends Prod α α where\n  /-- The starting point of an interval is smaller than the endpoint. -/\n  fst_le_snd : fst ≤ snd\n\n"}
{"name":"NonemptyInterval.ext_iff","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_6\ninst✝ : LE α\nx y : NonemptyInterval α\n⊢ Iff (Eq x y) (Eq x.toProd y.toProd)","decl":"/-- The nonempty closed intervals in an order.\n\nWe define intervals by the pair of endpoints `fst`, `snd`. To convert intervals to the set of\nelements between these endpoints, use the coercion `NonemptyInterval α → Set α`. -/\n@[ext (flat := false)]\nstructure NonemptyInterval (α : Type*) [LE α] extends Prod α α where\n  /-- The starting point of an interval is smaller than the endpoint. -/\n  fst_le_snd : fst ≤ snd\n\n"}
{"name":"NonemptyInterval.mk.injEq","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_6\ninst✝ : LE α\ntoProd✝ : Prod α α\nfst_le_snd✝ : LE.le toProd✝.1 toProd✝.2\ntoProd : Prod α α\nfst_le_snd : LE.le toProd.1 toProd.2\n⊢ Eq (Eq { toProd := toProd✝, fst_le_snd := fst_le_snd✝ } { toProd := toProd, fst_le_snd := fst_le_snd }) (Eq toProd✝ toProd)","decl":"/-- The nonempty closed intervals in an order.\n\nWe define intervals by the pair of endpoints `fst`, `snd`. To convert intervals to the set of\nelements between these endpoints, use the coercion `NonemptyInterval α → Set α`. -/\n@[ext (flat := false)]\nstructure NonemptyInterval (α : Type*) [LE α] extends Prod α α where\n  /-- The starting point of an interval is smaller than the endpoint. -/\n  fst_le_snd : fst ≤ snd\n\n"}
{"name":"NonemptyInterval.ext","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_6\ninst✝ : LE α\nx y : NonemptyInterval α\ntoProd : Eq x.toProd y.toProd\n⊢ Eq x y","decl":"/-- The nonempty closed intervals in an order.\n\nWe define intervals by the pair of endpoints `fst`, `snd`. To convert intervals to the set of\nelements between these endpoints, use the coercion `NonemptyInterval α → Set α`. -/\n@[ext (flat := false)]\nstructure NonemptyInterval (α : Type*) [LE α] extends Prod α α where\n  /-- The starting point of an interval is smaller than the endpoint. -/\n  fst_le_snd : fst ≤ snd\n\n"}
{"name":"NonemptyInterval.toProd_injective","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Function.Injective NonemptyInterval.toProd","decl":"theorem toProd_injective : Injective (toProd : NonemptyInterval α → α × α) :=\n  fun s t h => by cases s; cases t; congr\n\n"}
{"name":"NonemptyInterval.toDualProd_apply","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : NonemptyInterval α\n⊢ Eq s.toDualProd { fst := OrderDual.toDual s.toProd.1, snd := s.toProd.2 }","decl":"@[simp]\ntheorem toDualProd_apply (s : NonemptyInterval α) : s.toDualProd = (toDual s.fst, s.snd) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.toDualProd_injective","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Function.Injective NonemptyInterval.toDualProd","decl":"theorem toDualProd_injective : Injective (toDualProd : NonemptyInterval α → αᵒᵈ × α) :=\n  toProd_injective\n\n"}
{"name":"NonemptyInterval.instIsEmpty","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : IsEmpty α\n⊢ IsEmpty (NonemptyInterval α)","decl":"instance [IsEmpty α] : IsEmpty (NonemptyInterval α) :=\n  ⟨fun s => isEmptyElim s.fst⟩\n\n"}
{"name":"NonemptyInterval.instSubsingleton","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : Subsingleton α\n⊢ Subsingleton (NonemptyInterval α)","decl":"instance [Subsingleton α] : Subsingleton (NonemptyInterval α) :=\n  toDualProd_injective.subsingleton\n\n"}
{"name":"NonemptyInterval.le_def","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : NonemptyInterval α\n⊢ Iff (LE.le s t) (And (LE.le t.toProd.1 s.toProd.1) (LE.le s.toProd.2 t.toProd.2))","decl":"theorem le_def : s ≤ t ↔ t.fst ≤ s.fst ∧ s.snd ≤ t.snd :=\n  Iff.rfl\n\n"}
{"name":"NonemptyInterval.toDualProdHom_apply","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\na✝ : NonemptyInterval α\n⊢ Eq (NonemptyInterval.toDualProdHom a✝) a✝.toDualProd","decl":"/-- `toDualProd` as an order embedding. -/\n@[simps]\ndef toDualProdHom : NonemptyInterval α ↪o αᵒᵈ × α where\n  toFun := toDualProd\n  inj' := toDualProd_injective\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"NonemptyInterval.fst_dual","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : NonemptyInterval α\n⊢ Eq (NonemptyInterval.dual s).toProd.1 (OrderDual.toDual s.toProd.2)","decl":"@[simp]\ntheorem fst_dual (s : NonemptyInterval α) : s.dual.fst = toDual s.snd :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_dual","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : NonemptyInterval α\n⊢ Eq (NonemptyInterval.dual s).toProd.2 (OrderDual.toDual s.toProd.1)","decl":"@[simp]\ntheorem snd_dual (s : NonemptyInterval α) : s.dual.snd = toDual s.fst :=\n  rfl\n\n"}
{"name":"NonemptyInterval.mem_mk","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : Prod α α\na : α\nhx : LE.le x.1 x.2\n⊢ Iff (Membership.mem { toProd := x, fst_le_snd := hx } a) (And (LE.le x.1 a) (LE.le a x.2))","decl":"@[simp]\ntheorem mem_mk {hx : x.1 ≤ x.2} : a ∈ mk x hx ↔ x.1 ≤ a ∧ a ≤ x.2 :=\n  Iff.rfl\n\n"}
{"name":"NonemptyInterval.mem_def","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : NonemptyInterval α\na : α\n⊢ Iff (Membership.mem s a) (And (LE.le s.toProd.1 a) (LE.le a s.toProd.2))","decl":"theorem mem_def : a ∈ s ↔ s.fst ≤ a ∧ a ≤ s.snd :=\n  Iff.rfl\n\n"}
{"name":"NonemptyInterval.coe_nonempty","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : NonemptyInterval α\n⊢ (Set.Icc s.toProd.1 s.toProd.2).Nonempty","decl":"theorem coe_nonempty (s : NonemptyInterval α) : (s : Set α).Nonempty :=\n  nonempty_Icc.2 s.fst_le_snd\n\n"}
{"name":"NonemptyInterval.pure_snd","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (NonemptyInterval.pure a).toProd.2 a","decl":"/-- `{a}` as an interval. -/\n@[simps]\ndef pure (a : α) : NonemptyInterval α :=\n  ⟨⟨a, a⟩, le_rfl⟩\n\n"}
{"name":"NonemptyInterval.pure_fst","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (NonemptyInterval.pure a).toProd.1 a","decl":"/-- `{a}` as an interval. -/\n@[simps]\ndef pure (a : α) : NonemptyInterval α :=\n  ⟨⟨a, a⟩, le_rfl⟩\n\n"}
{"name":"NonemptyInterval.mem_pure_self","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Membership.mem (NonemptyInterval.pure a) a","decl":"theorem mem_pure_self (a : α) : a ∈ pure a :=\n  ⟨le_rfl, le_rfl⟩\n\n"}
{"name":"NonemptyInterval.pure_injective","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Function.Injective NonemptyInterval.pure","decl":"theorem pure_injective : Injective (pure : α → NonemptyInterval α) := fun _ _ =>\n  congr_arg <| Prod.fst ∘ toProd\n\n"}
{"name":"NonemptyInterval.dual_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (NonemptyInterval.dual (NonemptyInterval.pure a)) (NonemptyInterval.pure (OrderDual.toDual a))","decl":"@[simp]\ntheorem dual_pure (a : α) : dual (pure a) = pure (toDual a) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.instNonempty","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Nonempty (NonemptyInterval α)","decl":"instance [Nonempty α] : Nonempty (NonemptyInterval α) :=\n  Nonempty.map pure (by infer_instance)\n\n"}
{"name":"NonemptyInterval.instNontrivial","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nontrivial α\n⊢ Nontrivial (NonemptyInterval α)","decl":"instance [Nontrivial α] : Nontrivial (NonemptyInterval α) :=\n  pure_injective.nontrivial\n\n"}
{"name":"NonemptyInterval.map_fst","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\na : NonemptyInterval α\n⊢ Eq (NonemptyInterval.map f a).toProd.1 (f a.1.1)","decl":"/-- Pushforward of nonempty intervals. -/\n@[simps!]\ndef map (f : α →o β) (a : NonemptyInterval α) : NonemptyInterval β :=\n  ⟨a.toProd.map f f, f.mono a.fst_le_snd⟩\n\n"}
{"name":"NonemptyInterval.map_snd","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\na : NonemptyInterval α\n⊢ Eq (NonemptyInterval.map f a).toProd.2 (f a.1.2)","decl":"/-- Pushforward of nonempty intervals. -/\n@[simps!]\ndef map (f : α →o β) (a : NonemptyInterval α) : NonemptyInterval β :=\n  ⟨a.toProd.map f f, f.mono a.fst_le_snd⟩\n\n"}
{"name":"NonemptyInterval.map_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\na : α\n⊢ Eq (NonemptyInterval.map f (NonemptyInterval.pure a)) (NonemptyInterval.pure (f a))","decl":"@[simp]\ntheorem map_pure (f : α →o β) (a : α) : (pure a).map f = pure (f a) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.map_map","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : OrderHom β γ\nf : OrderHom α β\na : NonemptyInterval α\n⊢ Eq (NonemptyInterval.map g (NonemptyInterval.map f a)) (NonemptyInterval.map (g.comp f) a)","decl":"@[simp]\ntheorem map_map (g : β →o γ) (f : α →o β) (a : NonemptyInterval α) :\n    (a.map f).map g = a.map (g.comp f) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.dual_map","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\na : NonemptyInterval α\n⊢ Eq (NonemptyInterval.dual (NonemptyInterval.map f a)) (NonemptyInterval.map (OrderHom.dual f) (NonemptyInterval.dual a))","decl":"@[simp]\ntheorem dual_map (f : α →o β) (a : NonemptyInterval α) :\n    dual (a.map f) = a.dual.map f.dual :=\n  rfl\n\n"}
{"name":"NonemptyInterval.map₂_fst","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\nh₀ : ∀ (b : β), Monotone fun a => f a b\nh₁ : ∀ (a : α), Monotone (f a)\na✝¹ : NonemptyInterval α\na✝ : NonemptyInterval β\n⊢ Eq (NonemptyInterval.map₂ f h₀ h₁ a✝¹ a✝).toProd.1 (f a✝¹.toProd.1 a✝.toProd.1)","decl":"/-- Binary pushforward of nonempty intervals. -/\n@[simps]\ndef map₂ (f : α → β → γ) (h₀ : ∀ b, Monotone fun a => f a b) (h₁ : ∀ a, Monotone (f a)) :\n    NonemptyInterval α → NonemptyInterval β → NonemptyInterval γ := fun s t =>\n  ⟨(f s.fst t.fst, f s.snd t.snd), (h₀ _ s.fst_le_snd).trans <| h₁ _ t.fst_le_snd⟩\n\n"}
{"name":"NonemptyInterval.map₂_snd","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\nh₀ : ∀ (b : β), Monotone fun a => f a b\nh₁ : ∀ (a : α), Monotone (f a)\na✝¹ : NonemptyInterval α\na✝ : NonemptyInterval β\n⊢ Eq (NonemptyInterval.map₂ f h₀ h₁ a✝¹ a✝).toProd.2 (f a✝¹.toProd.2 a✝.toProd.2)","decl":"/-- Binary pushforward of nonempty intervals. -/\n@[simps]\ndef map₂ (f : α → β → γ) (h₀ : ∀ b, Monotone fun a => f a b) (h₁ : ∀ a, Monotone (f a)) :\n    NonemptyInterval α → NonemptyInterval β → NonemptyInterval γ := fun s t =>\n  ⟨(f s.fst t.fst, f s.snd t.snd), (h₀ _ s.fst_le_snd).trans <| h₁ _ t.fst_le_snd⟩\n\n"}
{"name":"NonemptyInterval.map₂_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\nh₀ : ∀ (b : β), Monotone fun a => f a b\nh₁ : ∀ (a : α), Monotone (f a)\na : α\nb : β\n⊢ Eq (NonemptyInterval.map₂ f h₀ h₁ (NonemptyInterval.pure a) (NonemptyInterval.pure b)) (NonemptyInterval.pure (f a b))","decl":"@[simp]\ntheorem map₂_pure (f : α → β → γ) (h₀ h₁) (a : α) (b : β) :\n    map₂ f h₀ h₁ (pure a) (pure b) = pure (f a b) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.dual_map₂","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\nh₀ : ∀ (b : β), Monotone fun a => f a b\nh₁ : ∀ (a : α), Monotone (f a)\ns : NonemptyInterval α\nt : NonemptyInterval β\n⊢ Eq (NonemptyInterval.dual (NonemptyInterval.map₂ f h₀ h₁ s t)) (NonemptyInterval.map₂ (fun a b => OrderDual.toDual (f (OrderDual.ofDual a) (OrderDual.ofDual b))) ⋯ ⋯ (NonemptyInterval.dual s) (NonemptyInterval.dual t))","decl":"@[simp]\ntheorem dual_map₂ (f : α → β → γ) (h₀ h₁ s t) :\n    dual (map₂ f h₀ h₁ s t) =\n      map₂ (fun a b => toDual <| f (ofDual a) <| ofDual b) (fun _ => (h₀ _).dual)\n        (fun _ => (h₁ _).dual) (dual s) (dual t) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.dual_top","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : BoundedOrder α\n⊢ Eq (NonemptyInterval.dual Top.top) Top.top","decl":"@[simp]\ntheorem dual_top : dual (⊤ : NonemptyInterval α) = ⊤ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_subset_coe","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : NonemptyInterval α\n⊢ Iff (HasSubset.Subset ↑s ↑t) (LE.le s t)","decl":"@[norm_cast]\ntheorem coe_subset_coe : (s : Set α) ⊆ t ↔ (s : NonemptyInterval α) ≤ t :=\n  (@coeHom α _).le_iff_le\n\n"}
{"name":"NonemptyInterval.coe_ssubset_coe","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : NonemptyInterval α\n⊢ Iff (HasSSubset.SSubset ↑s ↑t) (LT.lt s t)","decl":"@[norm_cast]\ntheorem coe_ssubset_coe : (s : Set α) ⊂ t ↔ s < t :=\n  (@coeHom α _).lt_iff_lt\n\n"}
{"name":"NonemptyInterval.coe_coeHom","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Eq (⇑NonemptyInterval.coeHom) SetLike.coe","decl":"@[simp]\ntheorem coe_coeHom : (coeHom : NonemptyInterval α → Set α) = ((↑) : NonemptyInterval α → Set α) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_def","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : NonemptyInterval α\n⊢ Eq (↑s) (Set.Icc s.toProd.1 s.toProd.2)","decl":"theorem coe_def (s : NonemptyInterval α) : (s : Set α) = Set.Icc s.toProd.1 s.toProd.2 := rfl\n\n"}
{"name":"NonemptyInterval.coe_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (↑(NonemptyInterval.pure a)) (Singleton.singleton a)","decl":"@[simp, norm_cast]\ntheorem coe_pure (a : α) : (pure a : Set α) = {a} :=\n  Icc_self _\n\n"}
{"name":"NonemptyInterval.mem_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Membership.mem (NonemptyInterval.pure a) b) (Eq b a)","decl":"@[simp]\ntheorem mem_pure : b ∈ pure a ↔ b = a := by\n  rw [← SetLike.mem_coe, coe_pure, mem_singleton_iff]\n\n"}
{"name":"NonemptyInterval.coe_top","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp, norm_cast]\ntheorem coe_top [BoundedOrder α] : ((⊤ : NonemptyInterval α) : Set α) = univ :=\n  Icc_bot_top\n\n"}
{"name":"NonemptyInterval.coe_dual","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : NonemptyInterval α\n⊢ Eq (↑(NonemptyInterval.dual s)) (Set.preimage ⇑OrderDual.ofDual ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_dual (s : NonemptyInterval α) : (dual s : Set αᵒᵈ) = ofDual ⁻¹' s :=\n  dual_Icc\n\n"}
{"name":"NonemptyInterval.subset_coe_map","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nf : OrderHom α β\ns : NonemptyInterval α\n⊢ HasSubset.Subset (Set.image ⇑f ↑s) ↑(NonemptyInterval.map f s)","decl":"theorem subset_coe_map (f : α →o β) (s : NonemptyInterval α) : f '' s ⊆ s.map f :=\n  image_subset_iff.2 fun _ ha => ⟨f.mono ha.1, f.mono ha.2⟩\n\n"}
{"name":"NonemptyInterval.fst_sup","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Lattice α\ns t : NonemptyInterval α\n⊢ Eq (Max.max s t).toProd.1 (Min.min s.toProd.1 t.toProd.1)","decl":"@[simp]\ntheorem fst_sup (s t : NonemptyInterval α) : (s ⊔ t).fst = s.fst ⊓ t.fst :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_sup","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Lattice α\ns t : NonemptyInterval α\n⊢ Eq (Max.max s t).toProd.2 (Max.max s.toProd.2 t.toProd.2)","decl":"@[simp]\ntheorem snd_sup (s t : NonemptyInterval α) : (s ⊔ t).snd = s.snd ⊔ t.snd :=\n  rfl\n\n"}
{"name":"Interval.canLift","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ CanLift (Interval α) (NonemptyInterval α) WithBot.some fun r => Ne r Bot.bot","decl":"instance canLift : CanLift (Interval α) (NonemptyInterval α) (↑) fun r => r ≠ ⊥ :=\n  WithBot.canLift\n\n"}
{"name":"Interval.coe_injective","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Function.Injective WithBot.some","decl":"theorem coe_injective : Injective ((↑) : NonemptyInterval α → Interval α) :=\n  WithBot.coe_injective\n\n"}
{"name":"Interval.coe_inj","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : NonemptyInterval α\n⊢ Iff (Eq ↑s ↑t) (Eq s t)","decl":"@[norm_cast]\ntheorem coe_inj {s t : NonemptyInterval α} : (s : Interval α) = t ↔ s = t :=\n  WithBot.coe_inj\n\n"}
{"name":"Interval.forall","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\np : Interval α → Prop\n⊢ Iff (∀ (s : Interval α), p s) (And (p Bot.bot) (∀ (s : NonemptyInterval α), p ↑s))","decl":"protected\ntheorem «forall» {p : Interval α → Prop} : (∀ s, p s) ↔ p ⊥ ∧ ∀ s : NonemptyInterval α, p s :=\n  Option.forall\n\n"}
{"name":"Interval.exists","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : LE α\np : Interval α → Prop\n⊢ Iff (Exists fun s => p s) (Or (p Bot.bot) (Exists fun s => p ↑s))","decl":"protected\ntheorem «exists» {p : Interval α → Prop} : (∃ s, p s) ↔ p ⊥ ∨ ∃ s : NonemptyInterval α, p s :=\n  Option.exists\n\n"}
{"name":"Interval.pure_injective","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Function.Injective Interval.pure","decl":"theorem pure_injective : Injective (pure : α → Interval α) :=\n  coe_injective.comp NonemptyInterval.pure_injective\n\n"}
{"name":"Interval.dual_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Interval.dual (Interval.pure a)) (Interval.pure (OrderDual.toDual a))","decl":"@[simp]\ntheorem dual_pure (a : α) : dual (pure a) = pure (toDual a) :=\n  rfl\n\n"}
{"name":"Interval.dual_bot","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (Interval.dual Bot.bot) Bot.bot","decl":"@[simp]\ntheorem dual_bot : dual (⊥ : Interval α) = ⊥ :=\n  rfl\n\n"}
{"name":"Interval.pure_ne_bot","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Ne (Interval.pure a) Bot.bot","decl":"@[simp]\ntheorem pure_ne_bot {a : α} : pure a ≠ ⊥ :=\n  WithBot.coe_ne_bot\n\n"}
{"name":"Interval.bot_ne_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Ne Bot.bot (Interval.pure a)","decl":"@[simp]\ntheorem bot_ne_pure {a : α} : ⊥ ≠ pure a :=\n  WithBot.bot_ne_coe\n\n"}
{"name":"Interval.instNontrivialOfNonempty","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Nontrivial (Interval α)","decl":"instance [Nonempty α] : Nontrivial (Interval α) :=\n  Option.nontrivial\n\n"}
{"name":"Interval.map_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\na : α\n⊢ Eq (Interval.map f (Interval.pure a)) (Interval.pure (f a))","decl":"@[simp]\ntheorem map_pure (f : α →o β) (a : α) : (pure a).map f = pure (f a) :=\n  rfl\n\n"}
{"name":"Interval.map_map","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : OrderHom β γ\nf : OrderHom α β\ns : Interval α\n⊢ Eq (Interval.map g (Interval.map f s)) (Interval.map (g.comp f) s)","decl":"@[simp]\ntheorem map_map (g : β →o γ) (f : α →o β) (s : Interval α) : (s.map f).map g = s.map (g.comp f) :=\n  Option.map_map _ _ _\n\n"}
{"name":"Interval.dual_map","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\ns : Interval α\n⊢ Eq (Interval.dual (Interval.map f s)) (Interval.map (OrderHom.dual f) (Interval.dual s))","decl":"@[simp]\ntheorem dual_map (f : α →o β) (s : Interval α) : dual (s.map f) = s.dual.map f.dual := by\n  cases s\n  · rfl\n  · exact WithBot.map_comm rfl _\n\n"}
{"name":"Interval.dual_top","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : BoundedOrder α\n⊢ Eq (Interval.dual Top.top) Top.top","decl":"@[simp]\ntheorem dual_top : dual (⊤ : Interval α) = ⊤ :=\n  rfl\n\n"}
{"name":"Interval.coe_subset_coe","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Interval α\n⊢ Iff (HasSubset.Subset ↑s ↑t) (LE.le s t)","decl":"@[norm_cast]\ntheorem coe_subset_coe : (s : Set α) ⊆ t ↔ s ≤ t :=\n  (@coeHom α _).le_iff_le\n\n"}
{"name":"Interval.coe_sSubset_coe","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns t : Interval α\n⊢ Iff (HasSSubset.SSubset ↑s ↑t) (LT.lt s t)","decl":"@[norm_cast]\ntheorem coe_sSubset_coe : (s : Set α) ⊂ t ↔ s < t :=\n  (@coeHom α _).lt_iff_lt\n\n"}
{"name":"Interval.coe_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (↑(Interval.pure a)) (Singleton.singleton a)","decl":"@[simp, norm_cast]\ntheorem coe_pure (a : α) : (pure a : Set α) = {a} :=\n  Icc_self _\n\n"}
{"name":"Interval.coe_coe","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : NonemptyInterval α\n⊢ Eq ↑↑s ↑s","decl":"@[simp, norm_cast]\ntheorem coe_coe (s : NonemptyInterval α) : ((s : Interval α) : Set α) = s :=\n  rfl\n\n"}
{"name":"Interval.coe_bot","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Eq (↑Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_bot : ((⊥ : Interval α) : Set α) = ∅ :=\n  rfl\n\n"}
{"name":"Interval.coe_top","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp, norm_cast]\ntheorem coe_top [BoundedOrder α] : ((⊤ : Interval α) : Set α) = univ :=\n  Icc_bot_top\n\n"}
{"name":"Interval.coe_dual","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Interval α\n⊢ Eq (↑(Interval.dual s)) (Set.preimage ⇑OrderDual.ofDual ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_dual (s : Interval α) : (dual s : Set αᵒᵈ) = ofDual ⁻¹' s := by\n  cases s with\n  | bot => rfl\n  | coe s₀ => exact NonemptyInterval.coe_dual s₀\n\n"}
{"name":"Interval.subset_coe_map","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nf : OrderHom α β\ns : Interval α\n⊢ HasSubset.Subset (Set.image ⇑f ↑s) ↑(Interval.map f s)","decl":"theorem subset_coe_map (f : α →o β) : ∀ s : Interval α, f '' s ⊆ s.map f\n  | ⊥ => by simp\n  | (s : NonemptyInterval α) => s.subset_coe_map _\n\n"}
{"name":"Interval.mem_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Membership.mem (Interval.pure a) b) (Eq b a)","decl":"@[simp]\ntheorem mem_pure : b ∈ pure a ↔ b = a := by rw [← SetLike.mem_coe, coe_pure, mem_singleton_iff]\n\n"}
{"name":"Interval.mem_pure_self","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Membership.mem (Interval.pure a) a","decl":"theorem mem_pure_self (a : α) : a ∈ pure a :=\n  mem_pure.2 rfl\n\n"}
{"name":"Interval.coe_inf","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ns t : Interval α\n⊢ Eq (↑(Min.min s t)) (Inter.inter ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_inf : ∀ s t : Interval α, (↑(s ⊓ t) : Set α) = ↑s ∩ ↑t\n  | ⊥, _ => by\n    rw [bot_inf_eq]\n    exact (empty_inter _).symm\n  | (s : NonemptyInterval α), ⊥ => by\n    rw [inf_bot_eq]\n    exact (inter_empty _).symm\n  | (s : NonemptyInterval α), (t : NonemptyInterval α) => by\n    simp only [Min.min, coe_coe, NonemptyInterval.coe_def, Icc_inter_Icc,\n      SemilatticeInf.inf, Lattice.inf]\n    split_ifs with h\n    · simp only [coe_coe, NonemptyInterval.coe_def]\n    · refine (Icc_eq_empty <| mt ?_ h).symm\n      exact fun h ↦ ⟨le_sup_left.trans <| h.trans inf_le_right,\n        le_sup_right.trans <| h.trans inf_le_left⟩\n\n"}
{"name":"Interval.disjoint_coe","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Lattice α\ns t : Interval α\n⊢ Iff (Disjoint ↑s ↑t) (Disjoint s t)","decl":"@[simp, norm_cast]\ntheorem disjoint_coe (s t : Interval α) : Disjoint (s : Set α) t ↔ Disjoint s t := by\n  classical\n    rw [disjoint_iff_inf_le, disjoint_iff_inf_le, ← coe_subset_coe, coe_inf]\n    rfl\n\n"}
{"name":"NonemptyInterval.coe_pure_interval","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (↑(NonemptyInterval.pure a)) (Interval.pure a)","decl":"@[simp, norm_cast]\ntheorem coe_pure_interval (a : α) : (pure a : Interval α) = Interval.pure a :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_eq_pure","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : NonemptyInterval α\na : α\n⊢ Iff (Eq (↑s) (Interval.pure a)) (Eq s (NonemptyInterval.pure a))","decl":"@[simp, norm_cast]\ntheorem coe_eq_pure : (s : Interval α) = Interval.pure a ↔ s = pure a := by\n  rw [← Interval.coe_inj, coe_pure_interval]\n\n"}
{"name":"NonemptyInterval.coe_top_interval","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : BoundedOrder α\n⊢ Eq (↑Top.top) Top.top","decl":"@[simp, norm_cast]\ntheorem coe_top_interval [BoundedOrder α] : ((⊤ : NonemptyInterval α) : Interval α) = ⊤ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.mem_coe_interval","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : NonemptyInterval α\nx : α\n⊢ Iff (Membership.mem (↑s) x) (Membership.mem s x)","decl":"@[simp, norm_cast]\ntheorem mem_coe_interval [PartialOrder α] {s : NonemptyInterval α} {x : α} :\n    x ∈ (s : Interval α) ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"NonemptyInterval.coe_sup_interval","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝ : Lattice α\ns t : NonemptyInterval α\n⊢ Eq (↑(Max.max s t)) (Max.max ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_sup_interval [Lattice α] (s t : NonemptyInterval α) :\n    (↑(s ⊔ t) : Interval α) = ↑s ⊔ ↑t :=\n  rfl\n\n"}
{"name":"Interval.coe_sInf","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nS : Set (Interval α)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sInf [DecidableRel (α := α) (· ≤ ·)] (S : Set (Interval α)) :\n    ↑(sInf S) = ⋂ s ∈ S, (s : Set α) := by\n  classical -- Porting note: added\n  -- Porting note: this `change` was\n  -- change ↑ (dite _ _ _) = _\n  change ((dite _ _ _ : Interval α) : Set α) = ⋂ (s : Interval α) (_ : s ∈ S), (s : Set α)\n  split_ifs with h\n  · ext\n    simp [Interval.forall, h.1, ← forall_and, ← NonemptyInterval.mem_def]\n  simp_rw [not_and_or, Classical.not_not] at h\n  rcases h with h | h\n  · refine (eq_empty_of_subset_empty ?_).symm\n    exact iInter₂_subset_of_subset _ h Subset.rfl\n  · refine (not_nonempty_iff_eq_empty.1 ?_).symm\n    rintro ⟨x, hx⟩\n    rw [mem_iInter₂] at hx\n    exact h fun s ha t hb => (hx _ ha).1.trans (hx _ hb).2\n\n"}
{"name":"Interval.coe_iInf","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝¹ : CompleteLattice α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nf : ι → Interval α\n⊢ Eq (↑(iInf fun i => f i)) (Set.iInter fun i => ↑(f i))","decl":"@[simp, norm_cast]\ntheorem coe_iInf [DecidableRel (α := α) (· ≤ ·)] (f : ι → Interval α) :\n    ↑(⨅ i, f i) = ⋂ i, (f i : Set α) := by simp [iInf]\n\n"}
{"name":"Interval.coe_iInf₂","module":"Mathlib.Order.Interval.Basic","initialProofState":"α : Type u_1\nι : Sort u_4\nκ : ι → Sort u_5\ninst✝¹ : CompleteLattice α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nf : (i : ι) → κ i → Interval α\n⊢ Eq (↑(iInf fun i => iInf fun j => f i j)) (Set.iInter fun i => Set.iInter fun j => ↑(f i j))","decl":"@[norm_cast]\ntheorem coe_iInf₂ [DecidableRel (α := α) (· ≤ ·)] (f : ∀ i, κ i → Interval α) :\n    ↑(⨅ (i) (j), f i j) = ⋂ (i) (j), (f i j : Set α) := by simp_rw [coe_iInf]\n\n"}
