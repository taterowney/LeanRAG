{"name":"MvPolynomial.mul_esymm_eq_sum","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.NewtonIdentities","initialProofState":"σ : Type u_1\ninst✝¹ : Fintype σ\nR : Type u_2\ninst✝ : CommRing R\nk : Nat\n⊢ Eq (HMul.hMul (↑k) (MvPolynomial.esymm σ R k)) (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd k 1)) ((Finset.filter (fun a => LT.lt a.1 k) (Finset.HasAntidiagonal.antidiagonal k)).sum fun a => HMul.hMul (HMul.hMul (HPow.hPow (-1) a.1) (MvPolynomial.esymm σ R a.1)) (MvPolynomial.psum σ R a.2)))","decl":"/-- **Newton's identities** give a recurrence relation for the kth elementary symmetric polynomial\nin terms of lower degree elementary symmetric polynomials and power sums. -/\ntheorem mul_esymm_eq_sum (k : ℕ) :\n    k * esymm σ R k = (-1) ^ (k + 1) *\n      ∑ a ∈ antidiagonal k with a.1 < k, (-1) ^ a.1 * esymm σ R a.1 * psum σ R a.2 := by\n  classical\n  rw [NewtonIdentities.esymm_to_weight σ R k, NewtonIdentities.esymm_mul_psum_to_weight σ R k,\n    eq_comm, ← sub_eq_zero, sub_eq_add_neg, neg_mul_eq_neg_mul,\n    neg_eq_neg_one_mul ((-1 : MvPolynomial σ R) ^ k)]\n  nth_rw 2 [← pow_one (-1 : MvPolynomial σ R)]\n  rw [← pow_add, add_comm 1 k, ← left_distrib,\n    ← sum_disjUnion (NewtonIdentities.disjoint_filter_pairs_lt_filter_pairs_eq σ k),\n    NewtonIdentities.disjUnion_filter_pairs_eq_pairs σ k, NewtonIdentities.weight_sum σ R k,\n    neg_one_pow_mul_eq_zero_iff.mpr rfl]\n\n"}
{"name":"MvPolynomial.sum_antidiagonal_card_esymm_psum_eq_zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.NewtonIdentities","initialProofState":"σ : Type u_1\ninst✝¹ : Fintype σ\nR : Type u_2\ninst✝ : CommRing R\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal (Fintype.card σ)).sum fun a => HMul.hMul (HMul.hMul (HPow.hPow (-1) a.1) (MvPolynomial.esymm σ R a.1)) (MvPolynomial.psum σ R a.2)) 0","decl":"theorem sum_antidiagonal_card_esymm_psum_eq_zero :\n    ∑ a ∈ antidiagonal (Fintype.card σ), (-1) ^ a.fst * esymm σ R a.fst * psum σ R a.snd = 0 := by\n  let k := Fintype.card σ\n  suffices (-1 : MvPolynomial σ R) ^ (k + 1) *\n      ∑ a ∈ antidiagonal k, (-1) ^ a.fst * esymm σ R a.fst * psum σ R a.snd = 0 by\n    simpa using this\n  simp [k, ← sum_filter_add_sum_filter_not (antidiagonal k) (fun a ↦ a.fst < k),\n    ← mul_esymm_eq_sum, mul_add, ← mul_assoc, ← pow_add, mul_comm ↑k (esymm σ R k)]\n\n"}
{"name":"MvPolynomial.psum_eq_mul_esymm_sub_sum","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.NewtonIdentities","initialProofState":"σ : Type u_1\ninst✝¹ : Fintype σ\nR : Type u_2\ninst✝ : CommRing R\nk : Nat\nh : LT.lt 0 k\n⊢ Eq (MvPolynomial.psum σ R k) (HSub.hSub (HMul.hMul (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd k 1)) ↑k) (MvPolynomial.esymm σ R k)) ((Finset.filter (fun a => Membership.mem (Set.Ioo 0 k) a.1) (Finset.HasAntidiagonal.antidiagonal k)).sum fun a => HMul.hMul (HMul.hMul (HPow.hPow (-1) a.1) (MvPolynomial.esymm σ R a.1)) (MvPolynomial.psum σ R a.2)))","decl":"/-- A version of Newton's identities which may be more useful in the case that we know the values of\nthe elementary symmetric polynomials and would like to calculate the values of the power sums. -/\ntheorem psum_eq_mul_esymm_sub_sum (k : ℕ) (h : 0 < k) :\n    psum σ R k = (-1) ^ (k + 1) * k * esymm σ R k -\n    ∑ a ∈ antidiagonal k with a.1 ∈ Set.Ioo 0 k, (-1) ^ a.fst * esymm σ R a.1 * psum σ R a.2 := by\n  simp only [Set.Ioo, Set.mem_setOf_eq, and_comm]\n  have hesymm := mul_esymm_eq_sum σ R k\n  rw [← (sum_filter_add_sum_filter_not {a ∈ antidiagonal k | a.fst < k}\n    (fun a ↦ 0 < a.fst) (fun a ↦ (-1) ^ a.fst * esymm σ R a.fst * psum σ R a.snd))] at hesymm\n  have sub_both_sides := congrArg (· - (-1 : MvPolynomial σ R) ^ (k + 1) *\n    ∑ a ∈ {a ∈ antidiagonal k | a.fst < k} with 0 < a.fst,\n    (-1) ^ a.fst * esymm σ R a.fst * psum σ R a.snd) hesymm\n  simp only [left_distrib, add_sub_cancel_left] at sub_both_sides\n  have sub_both_sides := congrArg ((-1 : MvPolynomial σ R) ^ (k + 1) * ·) sub_both_sides\n  simp only [mul_sub_left_distrib, ← mul_assoc, ← pow_add, Even.neg_one_pow ⟨k + 1, rfl⟩, one_mul,\n    not_le, lt_one_iff, filter_filter (fun a : ℕ × ℕ ↦ a.fst < k) (fun a ↦ ¬0 < a.fst)]\n    at sub_both_sides\n  have : {a ∈ antidiagonal k | a.fst < k ∧ ¬0 < a.fst} = {(0, k)} := by\n    ext a\n    rw [mem_filter, mem_antidiagonal, mem_singleton]\n    refine ⟨?_, by rintro rfl; omega⟩\n    rintro ⟨ha, ⟨_, ha0⟩⟩\n    rw [← ha, Nat.eq_zero_of_not_pos ha0, zero_add, ← Nat.eq_zero_of_not_pos ha0]\n  rw [this, sum_singleton] at sub_both_sides\n  simp only [_root_.pow_zero, esymm_zero, mul_one, one_mul, filter_filter] at sub_both_sides\n  exact sub_both_sides.symm\n\n"}
