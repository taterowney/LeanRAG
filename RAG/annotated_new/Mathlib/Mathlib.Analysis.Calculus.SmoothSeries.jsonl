{"name":"summable_of_summable_hasFDerivAt_of_isPreconnected","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nf' : Î± â†’ E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nxâ‚€ x : E\nhu : Summable u\nhs : IsOpen s\nh's : IsPreconnected s\nhf : âˆ€ (n : Î±) (x : E), Membership.mem s x â†’ HasFDerivAt (f n) (f' n x) x\nhf' : âˆ€ (n : Î±) (x : E), Membership.mem s x â†’ LE.le (Norm.norm (f' n x)) (u n)\nhxâ‚€ : Membership.mem s xâ‚€\nhf0 : Summable fun x => f x xâ‚€\nhx : Membership.mem s x\nâŠ¢ Summable fun n => f n x","decl":"/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem summable_of_summable_hasFDerivAt_of_isPreconnected (hu : Summable u) (hs : IsOpen s)\n    (h's : IsPreconnected s) (hf : âˆ€ n x, x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x)\n    (hf' : âˆ€ n x, x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) (hxâ‚€ : xâ‚€ âˆˆ s) (hf0 : Summable (f Â· xâ‚€))\n    (hx : x âˆˆ s) : Summable fun n => f n x := by\n  haveI := Classical.decEq Î±\n  rw [summable_iff_cauchySeq_finset] at hf0 âŠ¢\n  have A : UniformCauchySeqOn (fun t : Finset Î± => fun x => âˆ‘ i âˆˆ t, f' i x) atTop s :=\n    (tendstoUniformlyOn_tsum hu hf').uniformCauchySeqOn\n  -- Porting note: Lean 4 failed to find `f` by unification\n  refine cauchy_map_of_uniformCauchySeqOn_fderiv (f := fun t x â†¦ âˆ‘ i âˆˆ t, f i x)\n    hs h's A (fun t y hy => ?_) hxâ‚€ hx hf0\n  exact HasFDerivAt.sum fun i _ => hf i y hy\n\n"}
{"name":"summable_of_summable_hasDerivAt_of_isPreconnected","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nF : Type u_5\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : IsRCLikeNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\ng g' : Î± â†’ ğ•œ â†’ F\nt : Set ğ•œ\nyâ‚€ y : ğ•œ\nhu : Summable u\nht : IsOpen t\nh't : IsPreconnected t\nhg : âˆ€ (n : Î±) (y : ğ•œ), Membership.mem t y â†’ HasDerivAt (g n) (g' n y) y\nhg' : âˆ€ (n : Î±) (y : ğ•œ), Membership.mem t y â†’ LE.le (Norm.norm (g' n y)) (u n)\nhyâ‚€ : Membership.mem t yâ‚€\nhg0 : Summable fun x => g x yâ‚€\nhy : Membership.mem t y\nâŠ¢ Summable fun n => g n y","decl":"/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem summable_of_summable_hasDerivAt_of_isPreconnected (hu : Summable u) (ht : IsOpen t)\n    (h't : IsPreconnected t) (hg : âˆ€ n y, y âˆˆ t â†’ HasDerivAt (g n) (g' n y) y)\n    (hg' : âˆ€ n y, y âˆˆ t â†’ â€–g' n yâ€– â‰¤ u n) (hyâ‚€ : yâ‚€ âˆˆ t) (hg0 : Summable (g Â· yâ‚€))\n    (hy : y âˆˆ t) : Summable fun n => g n y := by\n  simp_rw [hasDerivAt_iff_hasFDerivAt] at hg\n  refine summable_of_summable_hasFDerivAt_of_isPreconnected hu ht h't hg ?_ hyâ‚€ hg0 hy\n  simpa? says simpa only [ContinuousLinearMap.norm_smulRight_apply, norm_one, one_mul]\n\n"}
{"name":"hasFDerivAt_tsum_of_isPreconnected","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nf' : Î± â†’ E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set E\nxâ‚€ x : E\nhu : Summable u\nhs : IsOpen s\nh's : IsPreconnected s\nhf : âˆ€ (n : Î±) (x : E), Membership.mem s x â†’ HasFDerivAt (f n) (f' n x) x\nhf' : âˆ€ (n : Î±) (x : E), Membership.mem s x â†’ LE.le (Norm.norm (f' n x)) (u n)\nhxâ‚€ : Membership.mem s xâ‚€\nhf0 : Summable fun n => f n xâ‚€\nhx : Membership.mem s x\nâŠ¢ HasFDerivAt (fun y => tsum fun n => f n y) (tsum fun n => f' n x) x","decl":"/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series is differentiable on the set and its derivative is the sum of the\nderivatives. -/\ntheorem hasFDerivAt_tsum_of_isPreconnected (hu : Summable u) (hs : IsOpen s)\n    (h's : IsPreconnected s) (hf : âˆ€ n x, x âˆˆ s â†’ HasFDerivAt (f n) (f' n x) x)\n    (hf' : âˆ€ n x, x âˆˆ s â†’ â€–f' n xâ€– â‰¤ u n) (hxâ‚€ : xâ‚€ âˆˆ s) (hf0 : Summable fun n => f n xâ‚€)\n    (hx : x âˆˆ s) : HasFDerivAt (fun y => âˆ‘' n, f n y) (âˆ‘' n, f' n x) x := by\n  classical\n    have A :\n      âˆ€ x : E, x âˆˆ s â†’ Tendsto (fun t : Finset Î± => âˆ‘ n âˆˆ t, f n x) atTop (ğ“ (âˆ‘' n, f n x)) := by\n      intro y hy\n      apply Summable.hasSum\n      exact summable_of_summable_hasFDerivAt_of_isPreconnected hu hs h's hf hf' hxâ‚€ hf0 hy\n    refine hasFDerivAt_of_tendstoUniformlyOn hs (tendstoUniformlyOn_tsum hu hf')\n      (fun t y hy => ?_) A hx\n    exact HasFDerivAt.sum fun n _ => hf n y hy\n\n"}
{"name":"hasDerivAt_tsum_of_isPreconnected","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nF : Type u_5\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : IsRCLikeNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\ng g' : Î± â†’ ğ•œ â†’ F\nt : Set ğ•œ\nyâ‚€ y : ğ•œ\nhu : Summable u\nht : IsOpen t\nh't : IsPreconnected t\nhg : âˆ€ (n : Î±) (y : ğ•œ), Membership.mem t y â†’ HasDerivAt (g n) (g' n y) y\nhg' : âˆ€ (n : Î±) (y : ğ•œ), Membership.mem t y â†’ LE.le (Norm.norm (g' n y)) (u n)\nhyâ‚€ : Membership.mem t yâ‚€\nhg0 : Summable fun n => g n yâ‚€\nhy : Membership.mem t y\nâŠ¢ HasDerivAt (fun z => tsum fun n => g n z) (tsum fun n => g' n y) y","decl":"/-- Consider a series of functions `âˆ‘' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series is differentiable on the set and its derivative is the sum of the\nderivatives. -/\ntheorem hasDerivAt_tsum_of_isPreconnected (hu : Summable u) (ht : IsOpen t)\n    (h't : IsPreconnected t) (hg : âˆ€ n y, y âˆˆ t â†’ HasDerivAt (g n) (g' n y) y)\n    (hg' : âˆ€ n y, y âˆˆ t â†’ â€–g' n yâ€– â‰¤ u n) (hyâ‚€ : yâ‚€ âˆˆ t) (hg0 : Summable fun n => g n yâ‚€)\n    (hy : y âˆˆ t) : HasDerivAt (fun z => âˆ‘' n, g n z) (âˆ‘' n, g' n y) y := by\n  simp_rw [hasDerivAt_iff_hasFDerivAt] at hg âŠ¢\n  convert hasFDerivAt_tsum_of_isPreconnected hu ht h't hg ?_ hyâ‚€ hg0 hy\n  Â· exact (ContinuousLinearMap.smulRightL ğ•œ ğ•œ F 1).map_tsum <|\n      .of_norm_bounded u hu fun n â†¦ hg' n y hy\n  Â· simpa? says simpa only [ContinuousLinearMap.norm_smulRight_apply, norm_one, one_mul]\n\n"}
{"name":"summable_of_summable_hasFDerivAt","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nf' : Î± â†’ E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nxâ‚€ : E\nhu : Summable u\nhf : âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x\nhf' : âˆ€ (n : Î±) (x : E), LE.le (Norm.norm (f' n x)) (u n)\nhf0 : Summable fun n => f n xâ‚€\nx : E\nâŠ¢ Summable fun n => f n x","decl":"/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem summable_of_summable_hasFDerivAt (hu : Summable u)\n    (hf : âˆ€ n x, HasFDerivAt (f n) (f' n x) x) (hf' : âˆ€ n x, â€–f' n xâ€– â‰¤ u n)\n    (hf0 : Summable fun n => f n xâ‚€) (x : E) : Summable fun n => f n x := by\n  letI : RCLike ğ•œ := IsRCLikeNormedField.rclike ğ•œ\n  let _ : NormedSpace â„ E := NormedSpace.restrictScalars â„ ğ•œ _\n  exact summable_of_summable_hasFDerivAt_of_isPreconnected hu isOpen_univ isPreconnected_univ\n    (fun n x _ => hf n x) (fun n x _ => hf' n x) (mem_univ _) hf0 (mem_univ _)\n\n"}
{"name":"summable_of_summable_hasDerivAt","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nF : Type u_5\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : IsRCLikeNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\ng g' : Î± â†’ ğ•œ â†’ F\nyâ‚€ : ğ•œ\nhu : Summable u\nhg : âˆ€ (n : Î±) (y : ğ•œ), HasDerivAt (g n) (g' n y) y\nhg' : âˆ€ (n : Î±) (y : ğ•œ), LE.le (Norm.norm (g' n y)) (u n)\nhg0 : Summable fun n => g n yâ‚€\ny : ğ•œ\nâŠ¢ Summable fun n => g n y","decl":"/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem summable_of_summable_hasDerivAt (hu : Summable u)\n    (hg : âˆ€ n y, HasDerivAt (g n) (g' n y) y) (hg' : âˆ€ n y, â€–g' n yâ€– â‰¤ u n)\n    (hg0 : Summable fun n => g n yâ‚€) (y : ğ•œ) : Summable fun n => g n y := by\n  exact summable_of_summable_hasDerivAt_of_isPreconnected hu isOpen_univ isPreconnected_univ\n    (fun n x _ => hg n x) (fun n x _ => hg' n x) (mem_univ _) hg0 (mem_univ _)\n\n"}
{"name":"hasFDerivAt_tsum","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nf' : Î± â†’ E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nxâ‚€ : E\nhu : Summable u\nhf : âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x\nhf' : âˆ€ (n : Î±) (x : E), LE.le (Norm.norm (f' n x)) (u n)\nhf0 : Summable fun n => f n xâ‚€\nx : E\nâŠ¢ HasFDerivAt (fun y => tsum fun n => f n y) (tsum fun n => f' n x) x","decl":"/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series is differentiable and its derivative is the sum of the derivatives. -/\ntheorem hasFDerivAt_tsum (hu : Summable u) (hf : âˆ€ n x, HasFDerivAt (f n) (f' n x) x)\n    (hf' : âˆ€ n x, â€–f' n xâ€– â‰¤ u n) (hf0 : Summable fun n => f n xâ‚€) (x : E) :\n    HasFDerivAt (fun y => âˆ‘' n, f n y) (âˆ‘' n, f' n x) x := by\n  letI : RCLike ğ•œ := IsRCLikeNormedField.rclike ğ•œ\n  let A : NormedSpace â„ E := NormedSpace.restrictScalars â„ ğ•œ _\n  exact hasFDerivAt_tsum_of_isPreconnected hu isOpen_univ isPreconnected_univ\n    (fun n x _ => hf n x) (fun n x _ => hf' n x) (mem_univ _) hf0 (mem_univ _)\n\n"}
{"name":"hasDerivAt_tsum","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nF : Type u_5\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : IsRCLikeNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\ng g' : Î± â†’ ğ•œ â†’ F\nyâ‚€ : ğ•œ\nhu : Summable u\nhg : âˆ€ (n : Î±) (y : ğ•œ), HasDerivAt (g n) (g' n y) y\nhg' : âˆ€ (n : Î±) (y : ğ•œ), LE.le (Norm.norm (g' n y)) (u n)\nhg0 : Summable fun n => g n yâ‚€\ny : ğ•œ\nâŠ¢ HasDerivAt (fun z => tsum fun n => g n z) (tsum fun n => g' n y) y","decl":"/-- Consider a series of functions `âˆ‘' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series is differentiable and its derivative is the sum of the derivatives. -/\ntheorem hasDerivAt_tsum (hu : Summable u) (hg : âˆ€ n y, HasDerivAt (g n) (g' n y) y)\n    (hg' : âˆ€ n y, â€–g' n yâ€– â‰¤ u n) (hg0 : Summable fun n => g n yâ‚€) (y : ğ•œ) :\n    HasDerivAt (fun z => âˆ‘' n, g n z) (âˆ‘' n, g' n y) y := by\n  exact hasDerivAt_tsum_of_isPreconnected hu isOpen_univ isPreconnected_univ\n    (fun n y _ => hg n y) (fun n y _ => hg' n y) (mem_univ _) hg0 (mem_univ _)\n\n"}
{"name":"differentiable_tsum","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nf' : Î± â†’ E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nhu : Summable u\nhf : âˆ€ (n : Î±) (x : E), HasFDerivAt (f n) (f' n x) x\nhf' : âˆ€ (n : Î±) (x : E), LE.le (Norm.norm (f' n x)) (u n)\nâŠ¢ Differentiable ğ•œ fun y => tsum fun n => f n y","decl":"/-- Consider a series of functions `âˆ‘' n, f n x`. If all functions in the series are differentiable\nwith a summable bound on the derivatives, then the series is differentiable.\nNote that our assumptions do not ensure the pointwise convergence, but if there is no pointwise\nconvergence then the series is zero everywhere so the result still holds. -/\ntheorem differentiable_tsum (hu : Summable u) (hf : âˆ€ n x, HasFDerivAt (f n) (f' n x) x)\n    (hf' : âˆ€ n x, â€–f' n xâ€– â‰¤ u n) : Differentiable ğ•œ fun y => âˆ‘' n, f n y := by\n  by_cases h : âˆƒ xâ‚€, Summable fun n => f n xâ‚€\n  Â· rcases h with âŸ¨xâ‚€, hf0âŸ©\n    intro x\n    exact (hasFDerivAt_tsum hu hf hf' hf0 x).differentiableAt\n  Â· push_neg at h\n    have : (fun x => âˆ‘' n, f n x) = 0 := by ext1 x; exact tsum_eq_zero_of_not_summable (h x)\n    rw [this]\n    exact differentiable_const 0\n\n"}
{"name":"differentiable_tsum'","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nF : Type u_5\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : IsRCLikeNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\ng g' : Î± â†’ ğ•œ â†’ F\nhu : Summable u\nhg : âˆ€ (n : Î±) (y : ğ•œ), HasDerivAt (g n) (g' n y) y\nhg' : âˆ€ (n : Î±) (y : ğ•œ), LE.le (Norm.norm (g' n y)) (u n)\nâŠ¢ Differentiable ğ•œ fun z => tsum fun n => g n z","decl":"/-- Consider a series of functions `âˆ‘' n, f n x`. If all functions in the series are differentiable\nwith a summable bound on the derivatives, then the series is differentiable.\nNote that our assumptions do not ensure the pointwise convergence, but if there is no pointwise\nconvergence then the series is zero everywhere so the result still holds. -/\ntheorem differentiable_tsum' (hu : Summable u) (hg : âˆ€ n y, HasDerivAt (g n) (g' n y) y)\n    (hg' : âˆ€ n y, â€–g' n yâ€– â‰¤ u n) : Differentiable ğ•œ fun z => âˆ‘' n, g n z := by\n  simp_rw [hasDerivAt_iff_hasFDerivAt] at hg\n  refine differentiable_tsum hu hg ?_\n  simpa? says simpa only [ContinuousLinearMap.norm_smulRight_apply, norm_one, one_mul]\n\n"}
{"name":"fderiv_tsum_apply","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nxâ‚€ : E\nhu : Summable u\nhf : âˆ€ (n : Î±), Differentiable ğ•œ (f n)\nhf' : âˆ€ (n : Î±) (x : E), LE.le (Norm.norm (fderiv ğ•œ (f n) x)) (u n)\nhf0 : Summable fun n => f n xâ‚€\nx : E\nâŠ¢ Eq (fderiv ğ•œ (fun y => tsum fun n => f n y) x) (tsum fun n => fderiv ğ•œ (f n) x)","decl":"theorem fderiv_tsum_apply (hu : Summable u) (hf : âˆ€ n, Differentiable ğ•œ (f n))\n    (hf' : âˆ€ n x, â€–fderiv ğ•œ (f n) xâ€– â‰¤ u n) (hf0 : Summable fun n => f n xâ‚€) (x : E) :\n    fderiv ğ•œ (fun y => âˆ‘' n, f n y) x = âˆ‘' n, fderiv ğ•œ (f n) x :=\n  (hasFDerivAt_tsum hu (fun n x => (hf n x).hasFDerivAt) hf' hf0 _).fderiv\n\n"}
{"name":"deriv_tsum_apply","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nF : Type u_5\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : IsRCLikeNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\ng : Î± â†’ ğ•œ â†’ F\nyâ‚€ : ğ•œ\nhu : Summable u\nhg : âˆ€ (n : Î±), Differentiable ğ•œ (g n)\nhg' : âˆ€ (n : Î±) (y : ğ•œ), LE.le (Norm.norm (deriv (g n) y)) (u n)\nhg0 : Summable fun n => g n yâ‚€\ny : ğ•œ\nâŠ¢ Eq (deriv (fun z => tsum fun n => g n z) y) (tsum fun n => deriv (g n) y)","decl":"theorem deriv_tsum_apply (hu : Summable u) (hg : âˆ€ n, Differentiable ğ•œ (g n))\n    (hg' : âˆ€ n y, â€–deriv (g n) yâ€– â‰¤ u n) (hg0 : Summable fun n => g n yâ‚€) (y : ğ•œ) :\n    deriv (fun z => âˆ‘' n, g n z) y = âˆ‘' n, deriv (g n) y :=\n  (hasDerivAt_tsum hu (fun n y => (hg n y).hasDerivAt) hg' hg0 _).deriv\n\n"}
{"name":"fderiv_tsum","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nxâ‚€ : E\nhu : Summable u\nhf : âˆ€ (n : Î±), Differentiable ğ•œ (f n)\nhf' : âˆ€ (n : Î±) (x : E), LE.le (Norm.norm (fderiv ğ•œ (f n) x)) (u n)\nhf0 : Summable fun n => f n xâ‚€\nâŠ¢ Eq (fderiv ğ•œ fun y => tsum fun n => f n y) fun x => tsum fun n => fderiv ğ•œ (f n) x","decl":"theorem fderiv_tsum (hu : Summable u) (hf : âˆ€ n, Differentiable ğ•œ (f n))\n    (hf' : âˆ€ n x, â€–fderiv ğ•œ (f n) xâ€– â‰¤ u n) (hf0 : Summable fun n => f n xâ‚€) :\n    (fderiv ğ•œ fun y => âˆ‘' n, f n y) = fun x => âˆ‘' n, fderiv ğ•œ (f n) x := by\n  ext1 x\n  exact fderiv_tsum_apply hu hf hf' hf0 x\n\n"}
{"name":"deriv_tsum","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nF : Type u_5\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : IsRCLikeNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\nu : Î± â†’ Real\ninstâœ : NormedSpace ğ•œ F\ng : Î± â†’ ğ•œ â†’ F\nyâ‚€ : ğ•œ\nhu : Summable u\nhg : âˆ€ (n : Î±), Differentiable ğ•œ (g n)\nhg' : âˆ€ (n : Î±) (y : ğ•œ), LE.le (Norm.norm (deriv (g n) y)) (u n)\nhg0 : Summable fun n => g n yâ‚€\nâŠ¢ Eq (deriv fun y => tsum fun n => g n y) fun y => tsum fun n => deriv (g n) y","decl":"theorem deriv_tsum (hu : Summable u) (hg : âˆ€ n, Differentiable ğ•œ (g n))\n    (hg' : âˆ€ n y, â€–deriv (g n) yâ€– â‰¤ u n) (hg0 : Summable fun n => g n yâ‚€) :\n    (deriv fun y => âˆ‘' n, g n y) = fun y => âˆ‘' n, deriv (g n) y := by\n  ext1 x\n  exact deriv_tsum_apply hu hg hg' hg0 x\n\n"}
{"name":"iteratedFDeriv_tsum","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nv : Nat â†’ Î± â†’ Real\nN : ENat\nhf : âˆ€ (i : Î±), ContDiff ğ•œ (â†‘N) (f i)\nhv : âˆ€ (k : Nat), LE.le (â†‘k) N â†’ Summable (v k)\nh'f : âˆ€ (k : Nat) (i : Î±) (x : E), LE.le (â†‘k) N â†’ LE.le (Norm.norm (iteratedFDeriv ğ•œ k (f i) x)) (v k i)\nk : Nat\nhk : LE.le (â†‘k) N\nâŠ¢ Eq (iteratedFDeriv ğ•œ k fun y => tsum fun n => f n y) fun x => tsum fun n => iteratedFDeriv ğ•œ k (f n) x","decl":"/-- Consider a series of `C^n` functions, with summable uniform bounds on the successive\nderivatives. Then the iterated derivative of the sum is the sum of the iterated derivative. -/\ntheorem iteratedFDeriv_tsum (hf : âˆ€ i, ContDiff ğ•œ N (f i))\n    (hv : âˆ€ k : â„•, (k : â„•âˆ) â‰¤ N â†’ Summable (v k))\n    (h'f : âˆ€ (k : â„•) (i : Î±) (x : E), (k : â„•âˆ) â‰¤ N â†’ â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i) {k : â„•}\n    (hk : (k : â„•âˆ) â‰¤ N) :\n    (iteratedFDeriv ğ•œ k fun y => âˆ‘' n, f n y) = fun x => âˆ‘' n, iteratedFDeriv ğ•œ k (f n) x := by\n  induction' k with k IH\n  Â· ext1 x\n    simp_rw [iteratedFDeriv_zero_eq_comp]\n    exact (continuousMultilinearCurryFin0 ğ•œ E F).symm.toContinuousLinearEquiv.map_tsum\n  Â· have h'k : (k : â„•âˆ) < N := lt_of_lt_of_le (WithTop.coe_lt_coe.2 (Nat.lt_succ_self _)) hk\n    have A : Summable fun n => iteratedFDeriv ğ•œ k (f n) 0 :=\n      .of_norm_bounded (v k) (hv k h'k.le) fun n => h'f k n 0 h'k.le\n    simp_rw [iteratedFDeriv_succ_eq_comp_left, IH h'k.le]\n    rw [fderiv_tsum (hv _ hk) (fun n => (hf n).differentiable_iteratedFDeriv\n        (mod_cast h'k)) _ A]\n    Â· ext1 x\n      exact (continuousMultilinearCurryLeftEquiv ğ•œ\n        (fun _ : Fin (k + 1) => E) F).symm.toContinuousLinearEquiv.map_tsum\n    Â· intro n x\n      simpa only [iteratedFDeriv_succ_eq_comp_left, LinearIsometryEquiv.norm_map, comp_apply]\n        using h'f k.succ n x hk\n\n"}
{"name":"iteratedFDeriv_tsum_apply","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nv : Nat â†’ Î± â†’ Real\nN : ENat\nhf : âˆ€ (i : Î±), ContDiff ğ•œ (â†‘N) (f i)\nhv : âˆ€ (k : Nat), LE.le (â†‘k) N â†’ Summable (v k)\nh'f : âˆ€ (k : Nat) (i : Î±) (x : E), LE.le (â†‘k) N â†’ LE.le (Norm.norm (iteratedFDeriv ğ•œ k (f i) x)) (v k i)\nk : Nat\nhk : LE.le (â†‘k) N\nx : E\nâŠ¢ Eq (iteratedFDeriv ğ•œ k (fun y => tsum fun n => f n y) x) (tsum fun n => iteratedFDeriv ğ•œ k (f n) x)","decl":"/-- Consider a series of smooth functions, with summable uniform bounds on the successive\nderivatives. Then the iterated derivative of the sum is the sum of the iterated derivative. -/\ntheorem iteratedFDeriv_tsum_apply (hf : âˆ€ i, ContDiff ğ•œ N (f i))\n    (hv : âˆ€ k : â„•, (k : â„•âˆ) â‰¤ N â†’ Summable (v k))\n    (h'f : âˆ€ (k : â„•) (i : Î±) (x : E), (k : â„•âˆ) â‰¤ N â†’ â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i) {k : â„•}\n    (hk : (k : â„•âˆ) â‰¤ N) (x : E) :\n    iteratedFDeriv ğ•œ k (fun y => âˆ‘' n, f n y) x = âˆ‘' n, iteratedFDeriv ğ•œ k (f n) x := by\n  rw [iteratedFDeriv_tsum hf hv h'f hk]\n\n"}
{"name":"contDiff_tsum","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nv : Nat â†’ Î± â†’ Real\nN : ENat\nhf : âˆ€ (i : Î±), ContDiff ğ•œ (â†‘N) (f i)\nhv : âˆ€ (k : Nat), LE.le (â†‘k) N â†’ Summable (v k)\nh'f : âˆ€ (k : Nat) (i : Î±) (x : E), LE.le (â†‘k) N â†’ LE.le (Norm.norm (iteratedFDeriv ğ•œ k (f i) x)) (v k i)\nâŠ¢ ContDiff ğ•œ â†‘N fun x => tsum fun i => f i x","decl":"/-- Consider a series of functions `âˆ‘' i, f i x`. Assume that each individual function `f i` is of\nclass `C^N`, and moreover there is a uniform summable upper bound on the `k`-th derivative\nfor each `k â‰¤ N`. Then the series is also `C^N`. -/\ntheorem contDiff_tsum (hf : âˆ€ i, ContDiff ğ•œ N (f i)) (hv : âˆ€ k : â„•, (k : â„•âˆ) â‰¤ N â†’ Summable (v k))\n    (h'f : âˆ€ (k : â„•) (i : Î±) (x : E), k â‰¤ N â†’ â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i) :\n    ContDiff ğ•œ N fun x => âˆ‘' i, f i x := by\n  rw [contDiff_iff_continuous_differentiable]\n  constructor\n  Â· intro m hm\n    rw [iteratedFDeriv_tsum hf hv h'f hm]\n    refine continuous_tsum ?_ (hv m hm) ?_\n    Â· intro i\n      exact ContDiff.continuous_iteratedFDeriv (mod_cast hm) (hf i)\n    Â· intro n x\n      exact h'f _ _ _ hm\n  Â· intro m hm\n    have h'm : ((m + 1 : â„•) : â„•âˆ) â‰¤ N := by\n      simpa only [ENat.coe_add, ENat.coe_one] using Order.add_one_le_of_lt hm\n    rw [iteratedFDeriv_tsum hf hv h'f hm.le]\n    have A n x : HasFDerivAt (iteratedFDeriv ğ•œ m (f n)) (fderiv ğ•œ (iteratedFDeriv ğ•œ m (f n)) x) x :=\n      (ContDiff.differentiable_iteratedFDeriv (mod_cast hm)\n        (hf n)).differentiableAt.hasFDerivAt\n    refine differentiable_tsum (hv _ h'm) A fun n x => ?_\n    rw [fderiv_iteratedFDeriv, comp_apply, LinearIsometryEquiv.norm_map]\n    exact h'f _ _ _ h'm\n\n"}
{"name":"contDiff_tsum_of_eventually","module":"Mathlib.Analysis.Calculus.SmoothSeries","initialProofState":"Î± : Type u_1\nğ•œ : Type u_3\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : IsRCLikeNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : CompleteSpace F\ninstâœ : NormedSpace ğ•œ F\nf : Î± â†’ E â†’ F\nv : Nat â†’ Î± â†’ Real\nN : ENat\nhf : âˆ€ (i : Î±), ContDiff ğ•œ (â†‘N) (f i)\nhv : âˆ€ (k : Nat), LE.le (â†‘k) N â†’ Summable (v k)\nh'f : âˆ€ (k : Nat), LE.le (â†‘k) N â†’ Filter.Eventually (fun i => âˆ€ (x : E), LE.le (Norm.norm (iteratedFDeriv ğ•œ k (f i) x)) (v k i)) Filter.cofinite\nâŠ¢ ContDiff ğ•œ â†‘N fun x => tsum fun i => f i x","decl":"/-- Consider a series of functions `âˆ‘' i, f i x`. Assume that each individual function `f i` is of\nclass `C^N`, and moreover there is a uniform summable upper bound on the `k`-th derivative\nfor each `k â‰¤ N` (except maybe for finitely many `i`s). Then the series is also `C^N`. -/\ntheorem contDiff_tsum_of_eventually (hf : âˆ€ i, ContDiff ğ•œ N (f i))\n    (hv : âˆ€ k : â„•, k â‰¤ N â†’ Summable (v k))\n    (h'f : âˆ€ k : â„•, k â‰¤ N â†’\n      âˆ€á¶  i in (Filter.cofinite : Filter Î±), âˆ€ x : E, â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i) :\n    ContDiff ğ•œ N fun x => âˆ‘' i, f i x := by\n  classical\n    refine contDiff_iff_forall_nat_le.2 fun m hm => ?_\n    let t : Set Î± :=\n      { i : Î± | Â¬âˆ€ k : â„•, k âˆˆ Finset.range (m + 1) â†’ âˆ€ x, â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i }\n    have ht : Set.Finite t :=\n      haveI A :\n        âˆ€á¶  i in (Filter.cofinite : Filter Î±),\n          âˆ€ k : â„•, k âˆˆ Finset.range (m + 1) â†’ âˆ€ x : E, â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i := by\n        rw [eventually_all_finset]\n        intro i hi\n        apply h'f\n        simp only [Finset.mem_range_succ_iff] at hi\n        exact (WithTop.coe_le_coe.2 hi).trans hm\n      eventually_cofinite.2 A\n    let T : Finset Î± := ht.toFinset\n    have : (fun x => âˆ‘' i, f i x) = (fun x => âˆ‘ i âˆˆ T, f i x) +\n        fun x => âˆ‘' i : { i // i âˆ‰ T }, f i x := by\n      ext1 x\n      refine (sum_add_tsum_subtype_compl ?_ T).symm\n      refine .of_norm_bounded_eventually _ (hv 0 (zero_le _)) ?_\n      filter_upwards [h'f 0 (zero_le _)] with i hi\n      simpa only [norm_iteratedFDeriv_zero] using hi x\n    rw [this]\n    apply (ContDiff.sum fun i _ => (hf i).of_le (mod_cast hm)).add\n    have h'u : âˆ€ k : â„•, (k : â„•âˆ) â‰¤ m â†’ Summable (v k âˆ˜ ((â†‘) : { i // i âˆ‰ T } â†’ Î±)) := fun k hk =>\n      (hv k (hk.trans hm)).subtype _\n    refine contDiff_tsum (fun i => (hf i).of_le (mod_cast hm)) h'u ?_\n    rintro k âŸ¨i, hiâŸ© x hk\n    simp only [t, T, Finite.mem_toFinset, mem_setOf_eq, Finset.mem_range, not_forall, not_le,\n      exists_prop, not_exists, not_and, not_lt] at hi\n    exact hi k (Nat.lt_succ_iff.2 (WithTop.coe_le_coe.1 hk)) x\n"}
