{"name":"PLift.map_up","module":"Mathlib.Control.ULift","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\na : α\n⊢ Eq (PLift.map f { down := a }) { down := f a }","decl":"@[simp]\ntheorem map_up (f : α → β) (a : α) : (PLift.up a).map f = PLift.up (f a) :=\n  rfl\n\n"}
{"name":"PLift.seq_up","module":"Mathlib.Control.ULift","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\nx : α\n⊢ Eq ({ down := f }.seq fun x_1 => { down := x }) { down := f x }","decl":"@[simp]\ntheorem seq_up (f : α → β) (x : α) : (PLift.up f).seq (fun _ => PLift.up x) = PLift.up (f x) :=\n  rfl\n\n"}
{"name":"PLift.bind_up","module":"Mathlib.Control.ULift","initialProofState":"α : Sort u\nβ : Sort v\na : α\nf : α → PLift β\n⊢ Eq ({ down := a }.bind f) (f a)","decl":"@[simp]\ntheorem bind_up (a : α) (f : α → PLift β) : (PLift.up a).bind f = f a :=\n  rfl\n\n"}
{"name":"PLift.instLawfulFunctor","module":"Mathlib.Control.ULift","initialProofState":"⊢ LawfulFunctor PLift","decl":"instance : LawfulFunctor PLift where\n  id_map := @fun _ ⟨_⟩ => rfl\n  comp_map := @fun _ _ _ _ _ ⟨_⟩ => rfl\n  map_const := @fun _ _ => rfl\n\n"}
{"name":"PLift.instLawfulApplicative","module":"Mathlib.Control.ULift","initialProofState":"⊢ LawfulApplicative PLift","decl":"instance : LawfulApplicative PLift where\n  seqLeft_eq := @fun _ _ _ _ => rfl\n  seqRight_eq := @fun _ _ _ _ => rfl\n  pure_seq := @fun _ _ _ ⟨_⟩ => rfl\n  map_pure := @fun _ _ _ _ => rfl\n  seq_pure := @fun _ _ ⟨_⟩ _ => rfl\n  seq_assoc := @fun _ _ _ ⟨_⟩ ⟨_⟩ ⟨_⟩ => rfl\n\n"}
{"name":"PLift.instLawfulMonad","module":"Mathlib.Control.ULift","initialProofState":"⊢ LawfulMonad PLift","decl":"instance : LawfulMonad PLift where\n  bind_pure_comp := @fun _ _ _ ⟨_⟩ => rfl\n  bind_map := @fun _ _ ⟨_⟩ ⟨_⟩ => rfl\n  pure_bind := @fun _ _ _ _ => rfl\n  bind_assoc := @fun _ _ _ ⟨_⟩ _ _ => rfl\n\n"}
{"name":"PLift.rec.constant","module":"Mathlib.Control.ULift","initialProofState":"α : Sort u\nβ : Type v\nb : β\n⊢ Eq (PLift.rec fun x => b) fun x => b","decl":"@[simp]\ntheorem rec.constant {α : Sort u} {β : Type v} (b : β) :\n    (@PLift.rec α (fun _ => β) fun _ => b) = fun _ => b := rfl\n\n"}
{"name":"ULift.map_up","module":"Mathlib.Control.ULift","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\n⊢ Eq (ULift.map f { down := a }) { down := f a }","decl":"@[simp]\ntheorem map_up (f : α → β) (a : α) : (ULift.up.{u'} a).map f = ULift.up.{v'} (f a) := rfl\n\n"}
{"name":"ULift.seq_up","module":"Mathlib.Control.ULift","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\n⊢ Eq ({ down := f }.seq fun x_1 => { down := x }) { down := f x }","decl":"@[simp]\ntheorem seq_up (f : α → β) (x : α) : (ULift.up f).seq (fun _ => ULift.up x) = ULift.up (f x) :=\n  rfl\n\n"}
{"name":"ULift.bind_up","module":"Mathlib.Control.ULift","initialProofState":"α : Type u\nβ : Type v\na : α\nf : α → ULift β\n⊢ Eq ({ down := a }.bind f) (f a)","decl":"@[simp]\ntheorem bind_up (a : α) (f : α → ULift β) : (ULift.up a).bind f = f a :=\n  rfl\n\n"}
{"name":"ULift.instLawfulFunctor","module":"Mathlib.Control.ULift","initialProofState":"⊢ LawfulFunctor ULift","decl":"instance : LawfulFunctor ULift where\n  id_map := @fun _ ⟨_⟩ => rfl\n  comp_map := @fun _ _ _ _ _ ⟨_⟩ => rfl\n  map_const := @fun _ _ => rfl\n\n"}
{"name":"ULift.instLawfulApplicative","module":"Mathlib.Control.ULift","initialProofState":"⊢ LawfulApplicative ULift","decl":"instance : LawfulApplicative ULift where\n  seqLeft_eq := @fun _ _ _ _ => rfl\n  seqRight_eq := @fun _ _ _ _ => rfl\n  pure_seq := @fun _ _ _ ⟨_⟩ => rfl\n  map_pure := @fun _ _ _ _ => rfl\n  seq_pure := @fun _ _ ⟨_⟩ _ => rfl\n  seq_assoc := @fun _ _ _ ⟨_⟩ ⟨_⟩ ⟨_⟩ => rfl\n\n"}
{"name":"ULift.instLawfulMonad","module":"Mathlib.Control.ULift","initialProofState":"⊢ LawfulMonad ULift","decl":"instance : LawfulMonad ULift where\n  bind_pure_comp := @fun _ _ _ ⟨_⟩ => rfl\n  bind_map := @fun _ _ ⟨_⟩ ⟨_⟩ => rfl\n  pure_bind := @fun _ _ _ _ => rfl\n  bind_assoc := @fun _ _ _ ⟨_⟩ _ _ => rfl\n\n"}
{"name":"ULift.rec.constant","module":"Mathlib.Control.ULift","initialProofState":"α : Type u\nβ : Sort v\nb : β\n⊢ Eq (ULift.rec fun x => b) fun x => b","decl":"@[simp]\ntheorem rec.constant {α : Type u} {β : Sort v} (b : β) :\n    (@ULift.rec α (fun _ => β) fun _ => b) = fun _ => b := rfl\n\n"}
