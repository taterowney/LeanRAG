{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_mor‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.rotate.mor‚ÇÇ T.mor‚ÇÉ","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f‚ü¶1‚üß'\n  Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ>  X‚ü¶1‚üß ‚îÄ‚îÄ‚îÄ> Y‚ü¶1‚üß\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor‚ÇÇ T.mor‚ÇÉ (-T.mor‚ÇÅ‚ü¶1‚üß')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_mor‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.rotate.mor‚ÇÅ T.mor‚ÇÇ","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f‚ü¶1‚üß'\n  Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ>  X‚ü¶1‚üß ‚îÄ‚îÄ‚îÄ> Y‚ü¶1‚üß\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor‚ÇÇ T.mor‚ÇÉ (-T.mor‚ÇÅ‚ü¶1‚üß')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_mor‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.rotate.mor‚ÇÉ (Neg.neg ((CategoryTheory.shiftFunctor C 1).map T.mor‚ÇÅ))","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f‚ü¶1‚üß'\n  Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ>  X‚ü¶1‚üß ‚îÄ‚îÄ‚îÄ> Y‚ü¶1‚üß\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor‚ÇÇ T.mor‚ÇÉ (-T.mor‚ÇÅ‚ü¶1‚üß')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_obj‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.rotate.obj‚ÇÇ T.obj‚ÇÉ","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f‚ü¶1‚üß'\n  Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ>  X‚ü¶1‚üß ‚îÄ‚îÄ‚îÄ> Y‚ü¶1‚üß\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor‚ÇÇ T.mor‚ÇÉ (-T.mor‚ÇÅ‚ü¶1‚üß')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_obj‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.rotate.obj‚ÇÅ T.obj‚ÇÇ","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f‚ü¶1‚üß'\n  Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ>  X‚ü¶1‚üß ‚îÄ‚îÄ‚îÄ> Y‚ü¶1‚üß\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor‚ÇÇ T.mor‚ÇÉ (-T.mor‚ÇÅ‚ü¶1‚üß')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_obj‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.rotate.obj‚ÇÉ ((CategoryTheory.shiftFunctor C 1).obj T.obj‚ÇÅ)","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f‚ü¶1‚üß'\n  Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ>  X‚ü¶1‚üß ‚îÄ‚îÄ‚îÄ> Y‚ü¶1‚üß\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor‚ÇÇ T.mor‚ÇÉ (-T.mor‚ÇÅ‚ü¶1‚üß')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_mor‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.invRotate.mor‚ÇÇ T.mor‚ÇÅ","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h‚ü¶-1‚üß'     f       g\n  Z‚ü¶-1‚üß  ‚îÄ‚îÄ‚îÄ>  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z‚ü¶-1‚üß‚ü¶1‚üß` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor‚ÇÉ‚ü¶(-1 : ‚Ñ§)‚üß' ‚â´ (shiftEquiv C (1 : ‚Ñ§)).unitIso.inv.app _) (T.mor‚ÇÅ)\n    (T.mor‚ÇÇ ‚â´ (shiftEquiv C (1 : ‚Ñ§)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_obj‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.invRotate.obj‚ÇÅ ((CategoryTheory.shiftFunctor C (-1)).obj T.obj‚ÇÉ)","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h‚ü¶-1‚üß'     f       g\n  Z‚ü¶-1‚üß  ‚îÄ‚îÄ‚îÄ>  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z‚ü¶-1‚üß‚ü¶1‚üß` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor‚ÇÉ‚ü¶(-1 : ‚Ñ§)‚üß' ‚â´ (shiftEquiv C (1 : ‚Ñ§)).unitIso.inv.app _) (T.mor‚ÇÅ)\n    (T.mor‚ÇÇ ‚â´ (shiftEquiv C (1 : ‚Ñ§)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_obj‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.invRotate.obj‚ÇÇ T.obj‚ÇÅ","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h‚ü¶-1‚üß'     f       g\n  Z‚ü¶-1‚üß  ‚îÄ‚îÄ‚îÄ>  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z‚ü¶-1‚üß‚ü¶1‚üß` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor‚ÇÉ‚ü¶(-1 : ‚Ñ§)‚üß' ‚â´ (shiftEquiv C (1 : ‚Ñ§)).unitIso.inv.app _) (T.mor‚ÇÅ)\n    (T.mor‚ÇÇ ‚â´ (shiftEquiv C (1 : ‚Ñ§)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_mor‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.invRotate.mor‚ÇÅ (Neg.neg (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C (-1)).map T.mor‚ÇÉ) ((CategoryTheory.shiftFunctorCompIsoId C 1 (-1) ‚ãØ).hom.app T.obj‚ÇÅ)))","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h‚ü¶-1‚üß'     f       g\n  Z‚ü¶-1‚üß  ‚îÄ‚îÄ‚îÄ>  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z‚ü¶-1‚üß‚ü¶1‚üß` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor‚ÇÉ‚ü¶(-1 : ‚Ñ§)‚üß' ‚â´ (shiftEquiv C (1 : ‚Ñ§)).unitIso.inv.app _) (T.mor‚ÇÅ)\n    (T.mor‚ÇÇ ‚â´ (shiftEquiv C (1 : ‚Ñ§)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_mor‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.invRotate.mor‚ÇÉ (CategoryTheory.CategoryStruct.comp T.mor‚ÇÇ ((CategoryTheory.shiftFunctorCompIsoId C (-1) 1 ‚ãØ).inv.app T.3))","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h‚ü¶-1‚üß'     f       g\n  Z‚ü¶-1‚üß  ‚îÄ‚îÄ‚îÄ>  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z‚ü¶-1‚üß‚ü¶1‚üß` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor‚ÇÉ‚ü¶(-1 : ‚Ñ§)‚üß' ‚â´ (shiftEquiv C (1 : ‚Ñ§)).unitIso.inv.app _) (T.mor‚ÇÅ)\n    (T.mor‚ÇÇ ‚â´ (shiftEquiv C (1 : ‚Ñ§)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_obj‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq T.invRotate.obj‚ÇÉ T.obj‚ÇÇ","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h‚ü¶-1‚üß'     f       g\n  Z‚ü¶-1‚üß  ‚îÄ‚îÄ‚îÄ>  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z‚ü¶-1‚üß‚ü¶1‚üß` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor‚ÇÉ‚ü¶(-1 : ‚Ñ§)‚üß' ‚â´ (shiftEquiv C (1 : ‚Ñ§)).unitIso.inv.app _) (T.mor‚ÇÅ)\n    (T.mor‚ÇÇ ‚â´ (shiftEquiv C (1 : ‚Ñ§)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_obj","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.rotate C).obj T) T.rotate","decl":"/-- Rotating triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef rotate : Triangle C ‚•§ Triangle C where\n  obj := Triangle.rotate\n  map f :=\n  { hom‚ÇÅ := f.hom‚ÇÇ\n    hom‚ÇÇ := f.hom‚ÇÉ\n    hom‚ÇÉ := f.hom‚ÇÅ‚ü¶1‚üß'\n    comm‚ÇÉ := by\n      dsimp\n      simp only [comp_neg, neg_comp, ‚Üê Functor.map_comp, f.comm‚ÇÅ] }\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_map_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX‚úù Y‚úù : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.rotate C).map f).hom‚ÇÇ f.hom‚ÇÉ","decl":"/-- Rotating triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef rotate : Triangle C ‚•§ Triangle C where\n  obj := Triangle.rotate\n  map f :=\n  { hom‚ÇÅ := f.hom‚ÇÇ\n    hom‚ÇÇ := f.hom‚ÇÉ\n    hom‚ÇÉ := f.hom‚ÇÅ‚ü¶1‚üß'\n    comm‚ÇÉ := by\n      dsimp\n      simp only [comp_neg, neg_comp, ‚Üê Functor.map_comp, f.comm‚ÇÅ] }\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_map_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX‚úù Y‚úù : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.rotate C).map f).hom‚ÇÅ f.hom‚ÇÇ","decl":"/-- Rotating triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef rotate : Triangle C ‚•§ Triangle C where\n  obj := Triangle.rotate\n  map f :=\n  { hom‚ÇÅ := f.hom‚ÇÇ\n    hom‚ÇÇ := f.hom‚ÇÉ\n    hom‚ÇÉ := f.hom‚ÇÅ‚ü¶1‚üß'\n    comm‚ÇÉ := by\n      dsimp\n      simp only [comp_neg, neg_comp, ‚Üê Functor.map_comp, f.comm‚ÇÅ] }\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_map_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX‚úù Y‚úù : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.rotate C).map f).hom‚ÇÉ ((CategoryTheory.shiftFunctor C 1).map f.hom‚ÇÅ)","decl":"/-- Rotating triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef rotate : Triangle C ‚•§ Triangle C where\n  obj := Triangle.rotate\n  map f :=\n  { hom‚ÇÅ := f.hom‚ÇÇ\n    hom‚ÇÇ := f.hom‚ÇÉ\n    hom‚ÇÉ := f.hom‚ÇÅ‚ü¶1‚üß'\n    comm‚ÇÉ := by\n      dsimp\n      simp only [comp_neg, neg_comp, ‚Üê Functor.map_comp, f.comm‚ÇÅ] }\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotate_map_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX‚úù Y‚úù : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.invRotate C).map f).hom‚ÇÅ ((CategoryTheory.shiftFunctor C (-1)).map f.hom‚ÇÉ)","decl":"/-- The inverse rotation of triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef invRotate : Triangle C ‚•§ Triangle C where\n  obj := Triangle.invRotate\n  map f :=\n  { hom‚ÇÅ := f.hom‚ÇÉ‚ü¶-1‚üß'\n    hom‚ÇÇ := f.hom‚ÇÅ\n    hom‚ÇÉ := f.hom‚ÇÇ\n    comm‚ÇÅ := by\n      dsimp\n      simp only [comp_neg, ‚Üê Functor.map_comp_assoc, ‚Üê f.comm‚ÇÉ]\n      rw [Functor.map_comp]\n      simp }\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotate_obj","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.invRotate C).obj T) T.invRotate","decl":"/-- The inverse rotation of triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef invRotate : Triangle C ‚•§ Triangle C where\n  obj := Triangle.invRotate\n  map f :=\n  { hom‚ÇÅ := f.hom‚ÇÉ‚ü¶-1‚üß'\n    hom‚ÇÇ := f.hom‚ÇÅ\n    hom‚ÇÉ := f.hom‚ÇÇ\n    comm‚ÇÅ := by\n      dsimp\n      simp only [comp_neg, ‚Üê Functor.map_comp_assoc, ‚Üê f.comm‚ÇÉ]\n      rw [Functor.map_comp]\n      simp }\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotate_map_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX‚úù Y‚úù : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.invRotate C).map f).hom‚ÇÇ f.hom‚ÇÅ","decl":"/-- The inverse rotation of triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef invRotate : Triangle C ‚•§ Triangle C where\n  obj := Triangle.invRotate\n  map f :=\n  { hom‚ÇÅ := f.hom‚ÇÉ‚ü¶-1‚üß'\n    hom‚ÇÇ := f.hom‚ÇÅ\n    hom‚ÇÉ := f.hom‚ÇÇ\n    comm‚ÇÅ := by\n      dsimp\n      simp only [comp_neg, ‚Üê Functor.map_comp_assoc, ‚Üê f.comm‚ÇÉ]\n      rw [Functor.map_comp]\n      simp }\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotate_map_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX‚úù Y‚úù : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.invRotate C).map f).hom‚ÇÉ f.hom‚ÇÇ","decl":"/-- The inverse rotation of triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef invRotate : Triangle C ‚•§ Triangle C where\n  obj := Triangle.invRotate\n  map f :=\n  { hom‚ÇÅ := f.hom‚ÇÉ‚ü¶-1‚üß'\n    hom‚ÇÇ := f.hom‚ÇÅ\n    hom‚ÇÉ := f.hom‚ÇÇ\n    comm‚ÇÅ := by\n      dsimp\n      simp only [comp_neg, ‚Üê Functor.map_comp_assoc, ‚Üê f.comm‚ÇÉ]\n      rw [Functor.map_comp]\n      simp }\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_inv_app_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.inv.app X).hom‚ÇÇ (CategoryTheory.CategoryStruct.id X.obj‚ÇÇ)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : ùü≠ (Triangle C) ‚âÖ rotate C ‚ãô invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ‚Ñ§)).unitIso.app T.obj‚ÇÅ) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_hom_app_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.hom.app X).hom‚ÇÉ (CategoryTheory.CategoryStruct.id X.obj‚ÇÉ)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : ùü≠ (Triangle C) ‚âÖ rotate C ‚ãô invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ‚Ñ§)).unitIso.app T.obj‚ÇÅ) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_hom_app_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.hom.app X).hom‚ÇÇ (CategoryTheory.CategoryStruct.id X.obj‚ÇÇ)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : ùü≠ (Triangle C) ‚âÖ rotate C ‚ãô invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ‚Ñ§)).unitIso.app T.obj‚ÇÅ) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_inv_app_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.inv.app X).hom‚ÇÅ ((CategoryTheory.shiftFunctorCompIsoId C 1 (-1) ‚ãØ).hom.app X.obj‚ÇÅ)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : ùü≠ (Triangle C) ‚âÖ rotate C ‚ãô invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ‚Ñ§)).unitIso.app T.obj‚ÇÅ) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_inv_app_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.inv.app X).hom‚ÇÉ (CategoryTheory.CategoryStruct.id X.obj‚ÇÉ)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : ùü≠ (Triangle C) ‚âÖ rotate C ‚ãô invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ‚Ñ§)).unitIso.app T.obj‚ÇÅ) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_hom_app_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.hom.app X).hom‚ÇÅ ((CategoryTheory.shiftFunctorCompIsoId C 1 (-1) ‚ãØ).inv.app X.obj‚ÇÅ)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : ùü≠ (Triangle C) ‚âÖ rotate C ‚ãô invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ‚Ñ§)).unitIso.app T.obj‚ÇÅ) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_inv_app_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.inv.app X).hom‚ÇÅ (CategoryTheory.CategoryStruct.id X.obj‚ÇÅ)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ‚ãô rotate C ‚âÖ ùü≠ (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ‚Ñ§)).counitIso.app T.obj‚ÇÉ)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_hom_app_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.hom.app X).hom‚ÇÅ (CategoryTheory.CategoryStruct.id X.obj‚ÇÅ)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ‚ãô rotate C ‚âÖ ùü≠ (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ‚Ñ§)).counitIso.app T.obj‚ÇÉ)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_inv_app_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.inv.app X).hom‚ÇÇ (CategoryTheory.CategoryStruct.id X.obj‚ÇÇ)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ‚ãô rotate C ‚âÖ ùü≠ (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ‚Ñ§)).counitIso.app T.obj‚ÇÉ)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_hom_app_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.hom.app X).hom‚ÇÇ (CategoryTheory.CategoryStruct.id X.obj‚ÇÇ)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ‚ãô rotate C ‚âÖ ùü≠ (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ‚Ñ§)).counitIso.app T.obj‚ÇÉ)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_hom_app_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.hom.app X).hom‚ÇÉ ((CategoryTheory.shiftFunctorCompIsoId C (-1) 1 ‚ãØ).hom.app X.obj‚ÇÉ)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ‚ãô rotate C ‚âÖ ùü≠ (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ‚Ñ§)).counitIso.app T.obj‚ÇÉ)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_inv_app_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.inv.app X).hom‚ÇÉ ((CategoryTheory.shiftFunctorCompIsoId C (-1) 1 ‚ãØ).inv.app X.obj‚ÇÉ)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ‚ãô rotate C ‚âÖ ùü≠ (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ‚Ñ§)).counitIso.app T.obj‚ÇÉ)\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleRotation_functor","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.triangleRotation C).functor (CategoryTheory.Pretriangulated.rotate C)","decl":"/-- Rotating triangles gives an auto-equivalence on the category of triangles in `C`.\n-/\n@[simps]\ndef triangleRotation : Equivalence (Triangle C) (Triangle C) where\n  functor := rotate C\n  inverse := invRotate C\n  unitIso := rotCompInvRot\n  counitIso := invRotCompRot\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleRotation_unitIso","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.triangleRotation C).unitIso CategoryTheory.Pretriangulated.rotCompInvRot","decl":"/-- Rotating triangles gives an auto-equivalence on the category of triangles in `C`.\n-/\n@[simps]\ndef triangleRotation : Equivalence (Triangle C) (Triangle C) where\n  functor := rotate C\n  inverse := invRotate C\n  unitIso := rotCompInvRot\n  counitIso := invRotCompRot\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleRotation_inverse","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.triangleRotation C).inverse (CategoryTheory.Pretriangulated.invRotate C)","decl":"/-- Rotating triangles gives an auto-equivalence on the category of triangles in `C`.\n-/\n@[simps]\ndef triangleRotation : Equivalence (Triangle C) (Triangle C) where\n  functor := rotate C\n  inverse := invRotate C\n  unitIso := rotCompInvRot\n  counitIso := invRotCompRot\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleRotation_counitIso","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.triangleRotation C).counitIso CategoryTheory.Pretriangulated.invRotCompRot","decl":"/-- Rotating triangles gives an auto-equivalence on the category of triangles in `C`.\n-/\n@[simps]\ndef triangleRotation : Equivalence (Triangle C) (Triangle C) where\n  functor := rotate C\n  inverse := invRotate C\n  unitIso := rotCompInvRot\n  counitIso := invRotCompRot\n\n"}
{"name":"CategoryTheory.Pretriangulated.instIsEquivalenceTriangleRotate","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ (CategoryTheory.Pretriangulated.rotate C).IsEquivalence","decl":"instance : (rotate C).IsEquivalence := by\n  change (triangleRotation C).functor.IsEquivalence\n  infer_instance\n\n"}
{"name":"CategoryTheory.Pretriangulated.instIsEquivalenceTriangleInvRotate","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ (CategoryTheory.Pretriangulated.invRotate C).IsEquivalence","decl":"instance : (invRotate C).IsEquivalence := by\n  change (triangleRotation C).inverse.IsEquivalence\n  infer_instance\n\n"}
