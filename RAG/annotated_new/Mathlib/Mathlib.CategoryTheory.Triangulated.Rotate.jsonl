{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_mor₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.rotate.mor₂ T.mor₃","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f⟦1⟧'\n  Y  ───> Z  ───>  X⟦1⟧ ───> Y⟦1⟧\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor₂ T.mor₃ (-T.mor₁⟦1⟧')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_mor₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.rotate.mor₁ T.mor₂","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f⟦1⟧'\n  Y  ───> Z  ───>  X⟦1⟧ ───> Y⟦1⟧\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor₂ T.mor₃ (-T.mor₁⟦1⟧')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_mor₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.rotate.mor₃ (Neg.neg ((CategoryTheory.shiftFunctor C 1).map T.mor₁))","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f⟦1⟧'\n  Y  ───> Z  ───>  X⟦1⟧ ───> Y⟦1⟧\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor₂ T.mor₃ (-T.mor₁⟦1⟧')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_obj₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.rotate.obj₂ T.obj₃","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f⟦1⟧'\n  Y  ───> Z  ───>  X⟦1⟧ ───> Y⟦1⟧\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor₂ T.mor₃ (-T.mor₁⟦1⟧')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_obj₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.rotate.obj₁ T.obj₂","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f⟦1⟧'\n  Y  ───> Z  ───>  X⟦1⟧ ───> Y⟦1⟧\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor₂ T.mor₃ (-T.mor₁⟦1⟧')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.rotate_obj₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.rotate.obj₃ ((CategoryTheory.shiftFunctor C 1).obj T.obj₁)","decl":"/-- If you rotate a triangle, you get another triangle.\nGiven a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `rotate` gives a triangle of the form:\n```\n      g       h        -f⟦1⟧'\n  Y  ───> Z  ───>  X⟦1⟧ ───> Y⟦1⟧\n```\n-/\n@[simps!]\ndef Triangle.rotate (T : Triangle C) : Triangle C :=\n  Triangle.mk T.mor₂ T.mor₃ (-T.mor₁⟦1⟧')\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_mor₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.invRotate.mor₂ T.mor₁","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h⟦-1⟧'     f       g\n  Z⟦-1⟧  ───>  X  ───> Y  ───> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z⟦-1⟧⟦1⟧` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor₃⟦(-1 : ℤ)⟧' ≫ (shiftEquiv C (1 : ℤ)).unitIso.inv.app _) (T.mor₁)\n    (T.mor₂ ≫ (shiftEquiv C (1 : ℤ)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_obj₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.invRotate.obj₁ ((CategoryTheory.shiftFunctor C (-1)).obj T.obj₃)","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h⟦-1⟧'     f       g\n  Z⟦-1⟧  ───>  X  ───> Y  ───> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z⟦-1⟧⟦1⟧` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor₃⟦(-1 : ℤ)⟧' ≫ (shiftEquiv C (1 : ℤ)).unitIso.inv.app _) (T.mor₁)\n    (T.mor₂ ≫ (shiftEquiv C (1 : ℤ)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_obj₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.invRotate.obj₂ T.obj₁","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h⟦-1⟧'     f       g\n  Z⟦-1⟧  ───>  X  ───> Y  ───> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z⟦-1⟧⟦1⟧` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor₃⟦(-1 : ℤ)⟧' ≫ (shiftEquiv C (1 : ℤ)).unitIso.inv.app _) (T.mor₁)\n    (T.mor₂ ≫ (shiftEquiv C (1 : ℤ)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_mor₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.invRotate.mor₁ (Neg.neg (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C (-1)).map T.mor₃) ((CategoryTheory.shiftFunctorCompIsoId C 1 (-1) ⋯).hom.app T.obj₁)))","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h⟦-1⟧'     f       g\n  Z⟦-1⟧  ───>  X  ───> Y  ───> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z⟦-1⟧⟦1⟧` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor₃⟦(-1 : ℤ)⟧' ≫ (shiftEquiv C (1 : ℤ)).unitIso.inv.app _) (T.mor₁)\n    (T.mor₂ ≫ (shiftEquiv C (1 : ℤ)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_mor₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.invRotate.mor₃ (CategoryTheory.CategoryStruct.comp T.mor₂ ((CategoryTheory.shiftFunctorCompIsoId C (-1) 1 ⋯).inv.app T.3))","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h⟦-1⟧'     f       g\n  Z⟦-1⟧  ───>  X  ───> Y  ───> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z⟦-1⟧⟦1⟧` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor₃⟦(-1 : ℤ)⟧' ≫ (shiftEquiv C (1 : ℤ)).unitIso.inv.app _) (T.mor₁)\n    (T.mor₂ ≫ (shiftEquiv C (1 : ℤ)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.Triangle.invRotate_obj₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq T.invRotate.obj₃ T.obj₂","decl":"/-- Given a triangle of the form:\n```\n      f       g       h\n  X  ───> Y  ───> Z  ───> X⟦1⟧\n```\napplying `invRotate` gives a triangle that can be thought of as:\n```\n        -h⟦-1⟧'     f       g\n  Z⟦-1⟧  ───>  X  ───> Y  ───> Z\n```\n(note that this diagram doesn't technically fit the definition of triangle, as `Z⟦-1⟧⟦1⟧` is\nnot necessarily equal to `Z`, but it is isomorphic, by the `counitIso` of `shiftEquiv C 1`)\n-/\n@[simps!]\ndef Triangle.invRotate (T : Triangle C) : Triangle C :=\n  Triangle.mk (-T.mor₃⟦(-1 : ℤ)⟧' ≫ (shiftEquiv C (1 : ℤ)).unitIso.inv.app _) (T.mor₁)\n    (T.mor₂ ≫ (shiftEquiv C (1 : ℤ)).counitIso.inv.app _ )\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_obj","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Pretriangulated.rotate C).obj T) T.rotate","decl":"/-- Rotating triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef rotate : Triangle C ⥤ Triangle C where\n  obj := Triangle.rotate\n  map f :=\n  { hom₁ := f.hom₂\n    hom₂ := f.hom₃\n    hom₃ := f.hom₁⟦1⟧'\n    comm₃ := by\n      dsimp\n      simp only [comp_neg, neg_comp, ← Functor.map_comp, f.comm₁] }\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_map_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX✝ Y✝ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Pretriangulated.rotate C).map f).hom₂ f.hom₃","decl":"/-- Rotating triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef rotate : Triangle C ⥤ Triangle C where\n  obj := Triangle.rotate\n  map f :=\n  { hom₁ := f.hom₂\n    hom₂ := f.hom₃\n    hom₃ := f.hom₁⟦1⟧'\n    comm₃ := by\n      dsimp\n      simp only [comp_neg, neg_comp, ← Functor.map_comp, f.comm₁] }\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_map_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX✝ Y✝ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Pretriangulated.rotate C).map f).hom₁ f.hom₂","decl":"/-- Rotating triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef rotate : Triangle C ⥤ Triangle C where\n  obj := Triangle.rotate\n  map f :=\n  { hom₁ := f.hom₂\n    hom₂ := f.hom₃\n    hom₃ := f.hom₁⟦1⟧'\n    comm₃ := by\n      dsimp\n      simp only [comp_neg, neg_comp, ← Functor.map_comp, f.comm₁] }\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotate_map_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX✝ Y✝ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Pretriangulated.rotate C).map f).hom₃ ((CategoryTheory.shiftFunctor C 1).map f.hom₁)","decl":"/-- Rotating triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef rotate : Triangle C ⥤ Triangle C where\n  obj := Triangle.rotate\n  map f :=\n  { hom₁ := f.hom₂\n    hom₂ := f.hom₃\n    hom₃ := f.hom₁⟦1⟧'\n    comm₃ := by\n      dsimp\n      simp only [comp_neg, neg_comp, ← Functor.map_comp, f.comm₁] }\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotate_map_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX✝ Y✝ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Pretriangulated.invRotate C).map f).hom₁ ((CategoryTheory.shiftFunctor C (-1)).map f.hom₃)","decl":"/-- The inverse rotation of triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef invRotate : Triangle C ⥤ Triangle C where\n  obj := Triangle.invRotate\n  map f :=\n  { hom₁ := f.hom₃⟦-1⟧'\n    hom₂ := f.hom₁\n    hom₃ := f.hom₂\n    comm₁ := by\n      dsimp\n      simp only [comp_neg, ← Functor.map_comp_assoc, ← f.comm₃]\n      rw [Functor.map_comp]\n      simp }\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotate_obj","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq ((CategoryTheory.Pretriangulated.invRotate C).obj T) T.invRotate","decl":"/-- The inverse rotation of triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef invRotate : Triangle C ⥤ Triangle C where\n  obj := Triangle.invRotate\n  map f :=\n  { hom₁ := f.hom₃⟦-1⟧'\n    hom₂ := f.hom₁\n    hom₃ := f.hom₂\n    comm₁ := by\n      dsimp\n      simp only [comp_neg, ← Functor.map_comp_assoc, ← f.comm₃]\n      rw [Functor.map_comp]\n      simp }\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotate_map_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX✝ Y✝ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Pretriangulated.invRotate C).map f).hom₂ f.hom₁","decl":"/-- The inverse rotation of triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef invRotate : Triangle C ⥤ Triangle C where\n  obj := Triangle.invRotate\n  map f :=\n  { hom₁ := f.hom₃⟦-1⟧'\n    hom₂ := f.hom₁\n    hom₃ := f.hom₂\n    comm₁ := by\n      dsimp\n      simp only [comp_neg, ← Functor.map_comp_assoc, ← f.comm₃]\n      rw [Functor.map_comp]\n      simp }\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotate_map_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX✝ Y✝ : CategoryTheory.Pretriangulated.Triangle C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Pretriangulated.invRotate C).map f).hom₃ f.hom₂","decl":"/-- The inverse rotation of triangles gives an endofunctor on the category of triangles in `C`.\n-/\n@[simps]\ndef invRotate : Triangle C ⥤ Triangle C where\n  obj := Triangle.invRotate\n  map f :=\n  { hom₁ := f.hom₃⟦-1⟧'\n    hom₂ := f.hom₁\n    hom₃ := f.hom₂\n    comm₁ := by\n      dsimp\n      simp only [comp_neg, ← Functor.map_comp_assoc, ← f.comm₃]\n      rw [Functor.map_comp]\n      simp }\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_inv_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.inv.app X).hom₂ (CategoryTheory.CategoryStruct.id X.obj₂)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : 𝟭 (Triangle C) ≅ rotate C ⋙ invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ℤ)).unitIso.app T.obj₁) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_hom_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.hom.app X).hom₃ (CategoryTheory.CategoryStruct.id X.obj₃)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : 𝟭 (Triangle C) ≅ rotate C ⋙ invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ℤ)).unitIso.app T.obj₁) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_hom_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.hom.app X).hom₂ (CategoryTheory.CategoryStruct.id X.obj₂)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : 𝟭 (Triangle C) ≅ rotate C ⋙ invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ℤ)).unitIso.app T.obj₁) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_inv_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.inv.app X).hom₁ ((CategoryTheory.shiftFunctorCompIsoId C 1 (-1) ⋯).hom.app X.obj₁)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : 𝟭 (Triangle C) ≅ rotate C ⋙ invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ℤ)).unitIso.app T.obj₁) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_inv_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.inv.app X).hom₃ (CategoryTheory.CategoryStruct.id X.obj₃)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : 𝟭 (Triangle C) ≅ rotate C ⋙ invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ℤ)).unitIso.app T.obj₁) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.rotCompInvRot_hom_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.rotCompInvRot.hom.app X).hom₁ ((CategoryTheory.shiftFunctorCompIsoId C 1 (-1) ⋯).inv.app X.obj₁)","decl":"/-- The unit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef rotCompInvRot : 𝟭 (Triangle C) ≅ rotate C ⋙ invRotate C :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _\n    ((shiftEquiv C (1 : ℤ)).unitIso.app T.obj₁) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_inv_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.inv.app X).hom₁ (CategoryTheory.CategoryStruct.id X.obj₁)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ⋙ rotate C ≅ 𝟭 (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ℤ)).counitIso.app T.obj₃)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_hom_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.hom.app X).hom₁ (CategoryTheory.CategoryStruct.id X.obj₁)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ⋙ rotate C ≅ 𝟭 (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ℤ)).counitIso.app T.obj₃)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_inv_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.inv.app X).hom₂ (CategoryTheory.CategoryStruct.id X.obj₂)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ⋙ rotate C ≅ 𝟭 (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ℤ)).counitIso.app T.obj₃)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_hom_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.hom.app X).hom₂ (CategoryTheory.CategoryStruct.id X.obj₂)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ⋙ rotate C ≅ 𝟭 (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ℤ)).counitIso.app T.obj₃)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_hom_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.hom.app X).hom₃ ((CategoryTheory.shiftFunctorCompIsoId C (-1) 1 ⋯).hom.app X.obj₃)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ⋙ rotate C ≅ 𝟭 (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ℤ)).counitIso.app T.obj₃)\n\n"}
{"name":"CategoryTheory.Pretriangulated.invRotCompRot_inv_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (CategoryTheory.Pretriangulated.invRotCompRot.inv.app X).hom₃ ((CategoryTheory.shiftFunctorCompIsoId C (-1) 1 ⋯).inv.app X.obj₃)","decl":"/-- The counit isomorphism of the auto-equivalence of categories `triangleRotation C` of\n`Triangle C` given by the rotation of triangles. -/\n@[simps!]\ndef invRotCompRot : invRotate C ⋙ rotate C ≅ 𝟭 (Triangle C) :=\n  NatIso.ofComponents fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    ((shiftEquiv C (1 : ℤ)).counitIso.app T.obj₃)\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleRotation_functor","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ Eq (CategoryTheory.Pretriangulated.triangleRotation C).functor (CategoryTheory.Pretriangulated.rotate C)","decl":"/-- Rotating triangles gives an auto-equivalence on the category of triangles in `C`.\n-/\n@[simps]\ndef triangleRotation : Equivalence (Triangle C) (Triangle C) where\n  functor := rotate C\n  inverse := invRotate C\n  unitIso := rotCompInvRot\n  counitIso := invRotCompRot\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleRotation_unitIso","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ Eq (CategoryTheory.Pretriangulated.triangleRotation C).unitIso CategoryTheory.Pretriangulated.rotCompInvRot","decl":"/-- Rotating triangles gives an auto-equivalence on the category of triangles in `C`.\n-/\n@[simps]\ndef triangleRotation : Equivalence (Triangle C) (Triangle C) where\n  functor := rotate C\n  inverse := invRotate C\n  unitIso := rotCompInvRot\n  counitIso := invRotCompRot\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleRotation_inverse","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ Eq (CategoryTheory.Pretriangulated.triangleRotation C).inverse (CategoryTheory.Pretriangulated.invRotate C)","decl":"/-- Rotating triangles gives an auto-equivalence on the category of triangles in `C`.\n-/\n@[simps]\ndef triangleRotation : Equivalence (Triangle C) (Triangle C) where\n  functor := rotate C\n  inverse := invRotate C\n  unitIso := rotCompInvRot\n  counitIso := invRotCompRot\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleRotation_counitIso","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ Eq (CategoryTheory.Pretriangulated.triangleRotation C).counitIso CategoryTheory.Pretriangulated.invRotCompRot","decl":"/-- Rotating triangles gives an auto-equivalence on the category of triangles in `C`.\n-/\n@[simps]\ndef triangleRotation : Equivalence (Triangle C) (Triangle C) where\n  functor := rotate C\n  inverse := invRotate C\n  unitIso := rotCompInvRot\n  counitIso := invRotCompRot\n\n"}
{"name":"CategoryTheory.Pretriangulated.instIsEquivalenceTriangleRotate","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ (CategoryTheory.Pretriangulated.rotate C).IsEquivalence","decl":"instance : (rotate C).IsEquivalence := by\n  change (triangleRotation C).functor.IsEquivalence\n  infer_instance\n\n"}
{"name":"CategoryTheory.Pretriangulated.instIsEquivalenceTriangleInvRotate","module":"Mathlib.CategoryTheory.Triangulated.Rotate","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ (CategoryTheory.Pretriangulated.invRotate C).IsEquivalence","decl":"instance : (invRotate C).IsEquivalence := by\n  change (triangleRotation C).inverse.IsEquivalence\n  infer_instance\n\n"}
