{"name":"mem_parallelepiped_iff","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\nv : ι → E\nx : E\n⊢ Iff (Membership.mem (parallelepiped v) x) (Exists fun t => And (Membership.mem (Set.Icc 0 1) t) (Eq x (Finset.univ.sum fun i => HSMul.hSMul (t i) (v i))))","decl":"theorem mem_parallelepiped_iff (v : ι → E) (x : E) :\n    x ∈ parallelepiped v ↔ ∃ t ∈ Icc (0 : ι → ℝ) 1, x = ∑ i, t i • v i := by\n  simp [parallelepiped, eq_comm]\n\n"}
{"name":"parallelepiped_basis_eq","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\nb : Basis ι Real E\n⊢ Eq (parallelepiped ⇑b) (setOf fun x => ∀ (i : ι), Membership.mem (Set.Icc 0 1) ((b.repr x) i))","decl":"theorem parallelepiped_basis_eq (b : Basis ι ℝ E) :\n    parallelepiped b = {x | ∀ i, b.repr x i ∈ Set.Icc 0 1} := by\n  classical\n  ext x\n  simp_rw [mem_parallelepiped_iff, mem_setOf_eq, b.ext_elem_iff, _root_.map_sum,\n    _root_.map_smul, Finset.sum_apply', Basis.repr_self, Finsupp.smul_single, smul_eq_mul,\n    mul_one, Finsupp.single_apply, Finset.sum_ite_eq', Finset.mem_univ, ite_true, mem_Icc,\n    Pi.le_def, Pi.zero_apply, Pi.one_apply, ← forall_and]\n  aesop\n\n"}
{"name":"image_parallelepiped","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁴ : Fintype ι\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ninst✝¹ : AddCommGroup F\ninst✝ : Module Real F\nf : LinearMap (RingHom.id Real) E F\nv : ι → E\n⊢ Eq (Set.image (⇑f) (parallelepiped v)) (parallelepiped (Function.comp (⇑f) v))","decl":"theorem image_parallelepiped (f : E →ₗ[ℝ] F) (v : ι → E) :\n    f '' parallelepiped v = parallelepiped (f ∘ v) := by\n  simp only [parallelepiped, ← image_comp]\n  congr 1 with t\n  simp only [Function.comp_apply, _root_.map_sum, LinearMap.map_smulₛₗ, RingHom.id_apply]\n\n"}
{"name":"parallelepiped_comp_equiv","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nι' : Type u_2\nE : Type u_3\ninst✝³ : Fintype ι\ninst✝² : Fintype ι'\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\nv : ι → E\ne : Equiv ι' ι\n⊢ Eq (parallelepiped (Function.comp v ⇑e)) (parallelepiped v)","decl":"/-- Reindexing a family of vectors does not change their parallelepiped. -/\n@[simp]\ntheorem parallelepiped_comp_equiv (v : ι → E) (e : ι' ≃ ι) :\n    parallelepiped (v ∘ e) = parallelepiped v := by\n  simp only [parallelepiped]\n  let K : (ι' → ℝ) ≃ (ι → ℝ) := Equiv.piCongrLeft' (fun _a : ι' => ℝ) e\n  have : Icc (0 : ι → ℝ) 1 = K '' Icc (0 : ι' → ℝ) 1 := by\n    rw [← Equiv.preimage_eq_iff_eq_image]\n    ext x\n    simp only [K, mem_preimage, mem_Icc, Pi.le_def, Pi.zero_apply, Equiv.piCongrLeft'_apply,\n      Pi.one_apply]\n    refine\n      ⟨fun h => ⟨fun i => ?_, fun i => ?_⟩, fun h =>\n        ⟨fun i => h.1 (e.symm i), fun i => h.2 (e.symm i)⟩⟩\n    · simpa only [Equiv.symm_apply_apply] using h.1 (e i)\n    · simpa only [Equiv.symm_apply_apply] using h.2 (e i)\n  rw [this, ← image_comp]\n  congr 1 with x\n  have := fun z : ι' → ℝ => e.symm.sum_comp fun i => z i • v (e i)\n  simp_rw [Equiv.apply_symm_apply] at this\n  simp_rw [Function.comp_apply, mem_image, mem_Icc, K, Equiv.piCongrLeft'_apply, this]\n\n-- The parallelepiped associated to an orthonormal basis of `ℝ` is either `[0, 1]` or `[-1, 0]`.\n"}
{"name":"parallelepiped_orthonormalBasis_one_dim","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nb : OrthonormalBasis ι Real Real\n⊢ Or (Eq (parallelepiped ⇑b) (Set.Icc 0 1)) (Eq (parallelepiped ⇑b) (Set.Icc (-1) 0))","decl":"theorem parallelepiped_orthonormalBasis_one_dim (b : OrthonormalBasis ι ℝ ℝ) :\n    parallelepiped b = Icc 0 1 ∨ parallelepiped b = Icc (-1) 0 := by\n  have e : ι ≃ Fin 1 := by\n    apply Fintype.equivFinOfCardEq\n    simp only [← finrank_eq_card_basis b.toBasis, finrank_self]\n  have B : parallelepiped (b.reindex e) = parallelepiped b := by\n    convert parallelepiped_comp_equiv b e.symm\n    ext i\n    simp only [OrthonormalBasis.coe_reindex]\n  rw [← B]\n  let F : ℝ → Fin 1 → ℝ := fun t => fun _i => t\n  have A : Icc (0 : Fin 1 → ℝ) 1 = F '' Icc (0 : ℝ) 1 := by\n    apply Subset.antisymm\n    · intro x hx\n      refine ⟨x 0, ⟨hx.1 0, hx.2 0⟩, ?_⟩\n      ext j\n      simp only [F, Subsingleton.elim j 0]\n    · rintro x ⟨y, hy, rfl⟩\n      exact ⟨fun _j => hy.1, fun _j => hy.2⟩\n  rcases orthonormalBasis_one_dim (b.reindex e) with (H | H)\n  · left\n    simp_rw [parallelepiped, H, A, Algebra.id.smul_eq_mul, mul_one]\n    simp only [F, Finset.univ_unique, Fin.default_eq_zero, Finset.sum_singleton,\n      ← image_comp, Function.comp_apply, image_id']\n  · right\n    simp_rw [H, parallelepiped, Algebra.id.smul_eq_mul, A]\n    simp only [F, Finset.univ_unique, Fin.default_eq_zero, mul_neg, mul_one, Finset.sum_neg_distrib,\n      Finset.sum_singleton, ← image_comp, Function.comp, image_neg_eq_neg, neg_Icc, neg_zero]\n\n"}
{"name":"parallelepiped_eq_sum_segment","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\nv : ι → E\n⊢ Eq (parallelepiped v) (Finset.univ.sum fun i => segment Real 0 (v i))","decl":"theorem parallelepiped_eq_sum_segment (v : ι → E) : parallelepiped v = ∑ i, segment ℝ 0 (v i) := by\n  ext\n  simp only [mem_parallelepiped_iff, Set.mem_finset_sum, Finset.mem_univ, forall_true_left,\n    segment_eq_image, smul_zero, zero_add, ← Set.pi_univ_Icc, Set.mem_univ_pi]\n  constructor\n  · rintro ⟨t, ht, rfl⟩\n    exact ⟨t • v, fun {i} => ⟨t i, ht _, by simp⟩, rfl⟩\n  rintro ⟨g, hg, rfl⟩\n  choose t ht hg using @hg\n  refine ⟨@t, @ht, ?_⟩\n  simp_rw [hg]\n\n"}
{"name":"convex_parallelepiped","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\nv : ι → E\n⊢ Convex Real (parallelepiped v)","decl":"theorem convex_parallelepiped (v : ι → E) : Convex ℝ (parallelepiped v) := by\n  rw [parallelepiped_eq_sum_segment]\n  exact convex_sum _ fun _i _hi => convex_segment _ _\n\n"}
{"name":"parallelepiped_eq_convexHull","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : AddCommGroup E\ninst✝ : Module Real E\nv : ι → E\n⊢ Eq (parallelepiped v) ((convexHull Real) (Finset.univ.sum fun i => Insert.insert 0 (Singleton.singleton (v i))))","decl":"/-- A `parallelepiped` is the convex hull of its vertices -/\ntheorem parallelepiped_eq_convexHull (v : ι → E) :\n    parallelepiped v = convexHull ℝ (∑ i, {(0 : E), v i}) := by\n  simp_rw [convexHull_sum, convexHull_pair, parallelepiped_eq_sum_segment]\n\n"}
{"name":"parallelepiped_single","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\na : ι → Real\n⊢ Eq (parallelepiped fun i => Pi.single i (a i)) (Set.uIcc 0 a)","decl":"/-- The axis aligned parallelepiped over `ι → ℝ` is a cuboid. -/\ntheorem parallelepiped_single [DecidableEq ι] (a : ι → ℝ) :\n    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a := by\n  ext x\n  simp_rw [Set.uIcc, mem_parallelepiped_iff, Set.mem_Icc, Pi.le_def, ← forall_and, Pi.inf_apply,\n    Pi.sup_apply, ← Pi.single_smul', Pi.one_apply, Pi.zero_apply, ← Pi.smul_apply',\n    Finset.univ_sum_single (_ : ι → ℝ)]\n  constructor\n  · rintro ⟨t, ht, rfl⟩ i\n    specialize ht i\n    simp_rw [smul_eq_mul, Pi.mul_apply]\n    rcases le_total (a i) 0 with hai | hai\n    · rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai]\n      exact ⟨le_mul_of_le_one_left hai ht.2, mul_nonpos_of_nonneg_of_nonpos ht.1 hai⟩\n    · rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai]\n      exact ⟨mul_nonneg ht.1 hai, mul_le_of_le_one_left hai ht.2⟩\n  · intro h\n    refine ⟨fun i => x i / a i, fun i => ?_, funext fun i => ?_⟩\n    · specialize h i\n      rcases le_total (a i) 0 with hai | hai\n      · rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai] at h\n        exact ⟨div_nonneg_of_nonpos h.2 hai, div_le_one_of_ge h.1 hai⟩\n      · rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai] at h\n        exact ⟨div_nonneg h.1 hai, div_le_one_of_le₀ h.2 hai⟩\n    · specialize h i\n      simp only [smul_eq_mul, Pi.mul_apply]\n      rcases eq_or_ne (a i) 0 with hai | hai\n      · rw [hai, inf_idem, sup_idem, ← le_antisymm_iff] at h\n        rw [hai, ← h, zero_div, zero_mul]\n      · rw [div_mul_cancel₀ _ hai]\n\n"}
{"name":"Basis.coe_parallelepiped","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝² : Fintype ι\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nb : Basis ι Real E\n⊢ Eq (↑b.parallelepiped) (parallelepiped ⇑b)","decl":"@[simp]\ntheorem Basis.coe_parallelepiped (b : Basis ι ℝ E) :\n    (b.parallelepiped : Set E) = _root_.parallelepiped b := rfl\n\n"}
{"name":"Basis.parallelepiped_reindex","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nι' : Type u_2\nE : Type u_3\ninst✝³ : Fintype ι\ninst✝² : Fintype ι'\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nb : Basis ι Real E\ne : Equiv ι ι'\n⊢ Eq (b.reindex e).parallelepiped b.parallelepiped","decl":"@[simp]\ntheorem Basis.parallelepiped_reindex (b : Basis ι ℝ E) (e : ι ≃ ι') :\n    (b.reindex e).parallelepiped = b.parallelepiped :=\n  PositiveCompacts.ext <|\n    (congr_arg _root_.parallelepiped (b.coe_reindex e)).trans (parallelepiped_comp_equiv b e.symm)\n\n"}
{"name":"Basis.parallelepiped_map","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁴ : Fintype ι\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real E\ninst✝ : NormedSpace Real F\nb : Basis ι Real E\ne : LinearEquiv (RingHom.id Real) E F\n⊢ Eq (b.map e).parallelepiped (TopologicalSpace.PositiveCompacts.map ⇑e ⋯ ⋯ b.parallelepiped)","decl":"theorem Basis.parallelepiped_map (b : Basis ι ℝ E) (e : E ≃ₗ[ℝ] F) :\n    (b.map e).parallelepiped = b.parallelepiped.map e\n    (have := FiniteDimensional.of_fintype_basis b\n    -- Porting note: Lean cannot infer the instance above\n    LinearMap.continuous_of_finiteDimensional e.toLinearMap)\n    (have := FiniteDimensional.of_fintype_basis (b.map e)\n    -- Porting note: Lean cannot infer the instance above\n    LinearMap.isOpenMap_of_finiteDimensional _ e.surjective) :=\n  PositiveCompacts.ext (image_parallelepiped e.toLinearMap _).symm\n\n"}
{"name":"Basis.prod_parallelepiped","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nι' : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ι'\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real E\ninst✝ : NormedSpace Real F\nv : Basis ι Real E\nw : Basis ι' Real F\n⊢ Eq (v.prod w).parallelepiped (v.parallelepiped.prod w.parallelepiped)","decl":"theorem Basis.prod_parallelepiped (v : Basis ι ℝ E) (w : Basis ι' ℝ F) :\n    (v.prod w).parallelepiped = v.parallelepiped.prod w.parallelepiped := by\n  ext x\n  simp only [Basis.coe_parallelepiped, TopologicalSpace.PositiveCompacts.coe_prod, Set.mem_prod,\n    mem_parallelepiped_iff]\n  constructor\n  · intro h\n    rcases h with ⟨t, ht1, ht2⟩\n    constructor\n    · use t ∘ Sum.inl\n      constructor\n      · exact ⟨(ht1.1 <| Sum.inl ·), (ht1.2 <| Sum.inl ·)⟩\n      simp [ht2, Prod.fst_sum, Prod.snd_sum]\n    · use t ∘ Sum.inr\n      constructor\n      · exact ⟨(ht1.1 <| Sum.inr ·), (ht1.2 <| Sum.inr ·)⟩\n      simp [ht2, Prod.fst_sum, Prod.snd_sum]\n  intro h\n  rcases h with ⟨⟨t, ht1, ht2⟩, ⟨s, hs1, hs2⟩⟩\n  use Sum.elim t s\n  constructor\n  · constructor\n    · change ∀ x : ι ⊕ ι', 0 ≤ Sum.elim t s x\n      aesop\n    · change ∀ x : ι ⊕ ι', Sum.elim t s x ≤ 1\n      aesop\n  ext\n  · simp [ht2, Prod.fst_sum]\n  · simp [hs2, Prod.snd_sum]\n\n"}
{"name":"Basis.addHaar_def","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_5\nE : Type u_6\ninst✝⁴ : Fintype ι\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nb : Basis ι Real E\n⊢ Eq b.addHaar (MeasureTheory.Measure.addHaarMeasure b.parallelepiped)","decl":"/-- The Lebesgue measure associated to a basis, giving measure `1` to the parallelepiped spanned\nby the basis. -/\nirreducible_def Basis.addHaar (b : Basis ι ℝ E) : Measure E :=\n  Measure.addHaarMeasure b.parallelepiped\n\n"}
{"name":"IsAddHaarMeasure_basis_addHaar","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nb : Basis ι Real E\n⊢ b.addHaar.IsAddHaarMeasure","decl":"instance IsAddHaarMeasure_basis_addHaar (b : Basis ι ℝ E) : IsAddHaarMeasure b.addHaar := by\n  rw [Basis.addHaar]; exact Measure.isAddHaarMeasure_addHaarMeasure _\n\n"}
{"name":"instSigmaFiniteAddHaar","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nb : Basis ι Real E\n⊢ MeasureTheory.SigmaFinite b.addHaar","decl":"instance (b : Basis ι ℝ E) : SigmaFinite b.addHaar := by\n  have : FiniteDimensional ℝ E := FiniteDimensional.of_fintype_basis b\n  rw [Basis.addHaar_def]; exact sigmaFinite_addHaarMeasure\n\n"}
{"name":"Basis.addHaar_eq_iff","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝⁷ : Fintype ι\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\ninst✝² : SecondCountableTopology E\nb : Basis ι Real E\nμ : MeasureTheory.Measure E\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : μ.IsAddLeftInvariant\n⊢ Iff (Eq b.addHaar μ) (Eq (μ ↑b.parallelepiped) 1)","decl":"/-- Let `μ` be a σ-finite left invariant measure on `E`. Then `μ` is equal to the Haar measure\ndefined by `b` iff the parallelepiped defined by `b` has measure `1` for `μ`. -/\ntheorem Basis.addHaar_eq_iff [SecondCountableTopology E] (b : Basis ι ℝ E) (μ : Measure E)\n    [SigmaFinite μ] [IsAddLeftInvariant μ] :\n    b.addHaar = μ ↔ μ b.parallelepiped = 1 := by\n  rw [Basis.addHaar_def]\n  exact addHaarMeasure_eq_iff b.parallelepiped μ\n\n"}
{"name":"Basis.addHaar_reindex","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nι' : Type u_2\nE : Type u_3\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype ι'\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nb : Basis ι Real E\ne : Equiv ι ι'\n⊢ Eq (b.reindex e).addHaar b.addHaar","decl":"@[simp]\ntheorem Basis.addHaar_reindex (b : Basis ι ℝ E) (e : ι ≃ ι') :\n    (b.reindex e).addHaar = b.addHaar := by\n  rw [Basis.addHaar, b.parallelepiped_reindex e, ← Basis.addHaar]\n\n"}
{"name":"Basis.addHaar_self","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nE : Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nb : Basis ι Real E\n⊢ Eq (b.addHaar (parallelepiped ⇑b)) 1","decl":"theorem Basis.addHaar_self (b : Basis ι ℝ E) : b.addHaar (_root_.parallelepiped b) = 1 := by\n  rw [Basis.addHaar]; exact addHaarMeasure_self\n\n"}
{"name":"Basis.prod_addHaar","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\nι' : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝¹⁰ : Fintype ι\ninst✝⁹ : Fintype ι'\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\ninst✝² : MeasurableSpace F\ninst✝¹ : BorelSpace F\ninst✝ : SecondCountableTopologyEither E F\nv : Basis ι Real E\nw : Basis ι' Real F\n⊢ Eq (v.prod w).addHaar (v.addHaar.prod w.addHaar)","decl":"theorem Basis.prod_addHaar (v : Basis ι ℝ E) (w : Basis ι' ℝ F) :\n    (v.prod w).addHaar = v.addHaar.prod w.addHaar := by\n  have : FiniteDimensional ℝ E := FiniteDimensional.of_fintype_basis v\n  have : FiniteDimensional ℝ F := FiniteDimensional.of_fintype_basis w\n  simp [(v.prod w).addHaar_eq_iff, Basis.prod_parallelepiped, Basis.addHaar_self]\n\n"}
{"name":"instIsAddHaarMeasureVolume","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"E : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\n⊢ MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure","decl":"instance [NormedAddCommGroup E] [InnerProductSpace ℝ E] [FiniteDimensional ℝ E]\n    [MeasurableSpace E] [BorelSpace E] : IsAddHaarMeasure (volume : Measure E) :=\n  IsAddHaarMeasure_basis_addHaar _\n\n/- This instance should not be necessary, but Lean has difficulties to find it in product\nsituations if we do not declare it explicitly. -/\n"}
{"name":"EuclideanSpace.instBorelSpaceRealOfFinite","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\n⊢ BorelSpace (EuclideanSpace Real ι)","decl":"instance [Finite ι] : BorelSpace (EuclideanSpace ℝ ι) := Pi.borelSpace\n\n"}
{"name":"EuclideanSpace.measurableEquiv_toEquiv","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\n⊢ Eq (EuclideanSpace.measurableEquiv ι).toEquiv (WithLp.equiv 2 ((i : ι) → (fun x => Real) i))","decl":"/-- `WithLp.equiv` as a `MeasurableEquiv`. -/\n@[simps toEquiv]\nprotected def measurableEquiv : EuclideanSpace ℝ ι ≃ᵐ (ι → ℝ) where\n  toEquiv := WithLp.equiv _ _\n  measurable_toFun := measurable_id\n  measurable_invFun := measurable_id\n\n"}
{"name":"EuclideanSpace.coe_measurableEquiv","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\n⊢ Eq ⇑(EuclideanSpace.measurableEquiv ι) ⇑(WithLp.equiv 2 ((i : ι) → (fun x => Real) i))","decl":"theorem coe_measurableEquiv : ⇑(EuclideanSpace.measurableEquiv ι) = WithLp.equiv 2 _ := rfl\n\n"}
{"name":"EuclideanSpace.coe_measurableEquiv_symm","module":"Mathlib.MeasureTheory.Measure.Haar.OfBasis","initialProofState":"ι : Type u_1\n⊢ Eq ⇑(EuclideanSpace.measurableEquiv ι).symm ⇑(WithLp.equiv 2 (ι → Real)).symm","decl":"theorem coe_measurableEquiv_symm :\n    ⇑(EuclideanSpace.measurableEquiv ι).symm = (WithLp.equiv 2 _).symm := rfl\n\n"}
