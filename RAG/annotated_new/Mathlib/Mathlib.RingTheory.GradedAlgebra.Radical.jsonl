{"name":"Ideal.IsHomogeneous.isPrime_of_homogeneous_mem_or_mem","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"Î¹ : Type u_1\nÏƒ : Type u_2\nA : Type u_3\ninstâœâ´ : CommRing A\ninstâœÂ³ : LinearOrderedCancelAddCommMonoid Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nI : Ideal A\nhI : Ideal.IsHomogeneous ğ’œ I\nI_ne_top : Ne I Top.top\nhomogeneous_mem_or_mem : âˆ€ {x y : A}, SetLike.Homogeneous ğ’œ x â†’ SetLike.Homogeneous ğ’œ y â†’ Membership.mem I (HMul.hMul x y) â†’ Or (Membership.mem I x) (Membership.mem I y)\nâŠ¢ I.IsPrime","decl":"theorem Ideal.IsHomogeneous.isPrime_of_homogeneous_mem_or_mem {I : Ideal A} (hI : I.IsHomogeneous ğ’œ)\n    (I_ne_top : I â‰  âŠ¤)\n    (homogeneous_mem_or_mem :\n      âˆ€ {x y : A}, Homogeneous ğ’œ x â†’ Homogeneous ğ’œ y â†’ x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I) :\n    Ideal.IsPrime I :=\n  âŸ¨I_ne_top, by\n    intro x y hxy\n    by_contra! rid\n    obtain âŸ¨ridâ‚, ridâ‚‚âŸ© := rid\n    classical\n      /-\n        The idea of the proof is the following :\n        since `x * y âˆˆ I` and `I` homogeneous, then `proj i (x * y) âˆˆ I` for any `i : Î¹`.\n        Then consider two sets `{i âˆˆ x.support | xáµ¢ âˆ‰ I}` and `{j âˆˆ y.support | yâ±¼ âˆ‰ J}`;\n        let `maxâ‚, maxâ‚‚` be the maximum of the two sets, then `proj (maxâ‚ + maxâ‚‚) (x * y) âˆˆ I`.\n        Then, `proj maxâ‚ x âˆ‰ I` and `proj maxâ‚‚ j âˆ‰ I`\n        but `proj i x âˆˆ I` for all `maxâ‚ < i` and `proj j y âˆˆ I` for all `maxâ‚‚ < j`.\n        `  proj (maxâ‚ + maxâ‚‚) (x * y)`\n        `= âˆ‘ {(i, j) âˆˆ supports | i + j = maxâ‚ + maxâ‚‚}, xáµ¢ * yâ±¼`\n        `= proj maxâ‚ x * proj maxâ‚‚ y`\n        `  + âˆ‘ {(i, j) âˆˆ supports \\ {(maxâ‚, maxâ‚‚)} | i + j = maxâ‚ + maxâ‚‚}, xáµ¢ * yâ±¼`.\n        This is a contradiction, because both `proj (maxâ‚ + maxâ‚‚) (x * y) âˆˆ I` and the sum on the\n        right hand side is in `I` however `proj maxâ‚ x * proj maxâ‚‚ y` is not in `I`.\n        -/\n      set setâ‚ := {i âˆˆ (decompose ğ’œ x).support | proj ğ’œ i x âˆ‰ I} with setâ‚_eq\n      set setâ‚‚ := {i âˆˆ (decompose ğ’œ y).support | proj ğ’œ i y âˆ‰ I} with setâ‚‚_eq\n      have nonempty :\n        âˆ€ x : A, x âˆ‰ I â†’ {i âˆˆ (decompose ğ’œ x).support | proj ğ’œ i x âˆ‰ I}.Nonempty := by\n        intro x hx\n        rw [filter_nonempty_iff]\n        contrapose! hx\n        simp_rw [proj_apply] at hx\n        rw [â† sum_support_decompose ğ’œ x]\n        exact Ideal.sum_mem _ hx\n      set maxâ‚ := setâ‚.max' (nonempty x ridâ‚)\n      set maxâ‚‚ := setâ‚‚.max' (nonempty y ridâ‚‚)\n      have mem_maxâ‚ : maxâ‚ âˆˆ setâ‚ := max'_mem setâ‚ (nonempty x ridâ‚)\n      have mem_maxâ‚‚ : maxâ‚‚ âˆˆ setâ‚‚ := max'_mem setâ‚‚ (nonempty y ridâ‚‚)\n      replace hxy : proj ğ’œ (maxâ‚ + maxâ‚‚) (x * y) âˆˆ I := hI _ hxy\n      have mem_I : proj ğ’œ maxâ‚ x * proj ğ’œ maxâ‚‚ y âˆˆ I := by\n        set antidiag :=\n          {z âˆˆ (decompose ğ’œ x).support Ã—Ë¢ (decompose ğ’œ y).support | z.1 + z.2 = maxâ‚ + maxâ‚‚}\n           with ha\n        have mem_antidiag : (maxâ‚, maxâ‚‚) âˆˆ antidiag := by\n          simp only [antidiag, add_sum_erase, mem_filter, mem_product]\n          exact âŸ¨âŸ¨mem_of_mem_filter _ mem_maxâ‚, mem_of_mem_filter _ mem_maxâ‚‚âŸ©, trivialâŸ©\n        have eq_add_sum :=\n          calc\n            proj ğ’œ (maxâ‚ + maxâ‚‚) (x * y) = âˆ‘ ij âˆˆ antidiag, proj ğ’œ ij.1 x * proj ğ’œ ij.2 y := by\n              simp_rw [ha, proj_apply, DirectSum.decompose_mul, DirectSum.coe_mul_apply ğ’œ]\n            _ =\n                proj ğ’œ maxâ‚ x * proj ğ’œ maxâ‚‚ y +\n                  âˆ‘ ij âˆˆ antidiag.erase (maxâ‚, maxâ‚‚), proj ğ’œ ij.1 x * proj ğ’œ ij.2 y :=\n              (add_sum_erase _ _ mem_antidiag).symm\n        rw [eq_sub_of_add_eq eq_add_sum.symm]\n        refine Ideal.sub_mem _ hxy (Ideal.sum_mem _ fun z H => ?_)\n        rcases z with âŸ¨i, jâŸ©\n        simp only [antidiag, mem_erase, Prod.mk.inj_iff, Ne, mem_filter, mem_product] at H\n        rcases H with âŸ¨Hâ‚, âŸ¨Hâ‚‚, Hâ‚ƒâŸ©, Hâ‚„âŸ©\n        have max_lt : maxâ‚ < i âˆ¨ maxâ‚‚ < j := by\n          rcases lt_trichotomy maxâ‚ i with (h | rfl | h)\n          Â· exact Or.inl h\n          Â· refine False.elim (Hâ‚ âŸ¨rfl, add_left_cancel Hâ‚„âŸ©)\n          Â· apply Or.inr\n            have := add_lt_add_right h j\n            rw [Hâ‚„] at this\n            exact lt_of_add_lt_add_left this\n        cases' max_lt with max_lt max_lt\n        Â· -- in this case `maxâ‚ < i`, then `xáµ¢ âˆˆ I`; for otherwise `i âˆˆ setâ‚` then `i â‰¤ maxâ‚`.\n          have not_mem : i âˆ‰ setâ‚ := fun h =>\n            lt_irrefl _ ((max'_lt_iff setâ‚ (nonempty x ridâ‚)).mp max_lt i h)\n          rw [setâ‚_eq] at not_mem\n          simp only [not_and, Classical.not_not, Ne, mem_filter] at not_mem\n          exact Ideal.mul_mem_right _ I (not_mem Hâ‚‚)\n        Â· -- in this case `maxâ‚‚ < j`, then `yâ±¼ âˆˆ I`; for otherwise `j âˆˆ setâ‚‚`, then `j â‰¤ maxâ‚‚`.\n          have not_mem : j âˆ‰ setâ‚‚ := fun h =>\n            lt_irrefl _ ((max'_lt_iff setâ‚‚ (nonempty y ridâ‚‚)).mp max_lt j h)\n          rw [setâ‚‚_eq] at not_mem\n          simp only [not_and, Classical.not_not, Ne, mem_filter] at not_mem\n          exact Ideal.mul_mem_left I _ (not_mem Hâ‚ƒ)\n      have not_mem_I : proj ğ’œ maxâ‚ x * proj ğ’œ maxâ‚‚ y âˆ‰ I := by\n        have neither_mem : proj ğ’œ maxâ‚ x âˆ‰ I âˆ§ proj ğ’œ maxâ‚‚ y âˆ‰ I := by\n          rw [mem_filter] at mem_maxâ‚ mem_maxâ‚‚\n          exact âŸ¨mem_maxâ‚.2, mem_maxâ‚‚.2âŸ©\n        intro _rid\n        cases' homogeneous_mem_or_mem âŸ¨maxâ‚, SetLike.coe_mem _âŸ© âŸ¨maxâ‚‚, SetLike.coe_mem _âŸ© mem_I\n          with h h\n        Â· apply neither_mem.1 h\n        Â· apply neither_mem.2 h\n      exact not_mem_I mem_IâŸ©\n\n"}
{"name":"Ideal.IsHomogeneous.isPrime_iff","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"Î¹ : Type u_1\nÏƒ : Type u_2\nA : Type u_3\ninstâœâ´ : CommRing A\ninstâœÂ³ : LinearOrderedCancelAddCommMonoid Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nI : Ideal A\nh : Ideal.IsHomogeneous ğ’œ I\nâŠ¢ Iff I.IsPrime (And (Ne I Top.top) (âˆ€ {x y : A}, SetLike.Homogeneous ğ’œ x â†’ SetLike.Homogeneous ğ’œ y â†’ Membership.mem I (HMul.hMul x y) â†’ Or (Membership.mem I x) (Membership.mem I y)))","decl":"theorem Ideal.IsHomogeneous.isPrime_iff {I : Ideal A} (h : I.IsHomogeneous ğ’œ) :\n    I.IsPrime â†”\n      I â‰  âŠ¤ âˆ§\n        âˆ€ {x y : A},\n          SetLike.Homogeneous ğ’œ x â†’ SetLike.Homogeneous ğ’œ y â†’ x * y âˆˆ I â†’ x âˆˆ I âˆ¨ y âˆˆ I :=\n  âŸ¨fun HI => âŸ¨HI.ne_top, fun _ _ hxy => Ideal.IsPrime.mem_or_mem HI hxyâŸ©,\n    fun âŸ¨I_ne_top, homogeneous_mem_or_memâŸ© =>\n    h.isPrime_of_homogeneous_mem_or_mem I_ne_top @homogeneous_mem_or_memâŸ©\n\n"}
{"name":"Ideal.IsPrime.homogeneousCore","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"Î¹ : Type u_1\nÏƒ : Type u_2\nA : Type u_3\ninstâœâ´ : CommRing A\ninstâœÂ³ : LinearOrderedCancelAddCommMonoid Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nI : Ideal A\nh : I.IsPrime\nâŠ¢ (Ideal.homogeneousCore ğ’œ I).toIdeal.IsPrime","decl":"theorem Ideal.IsPrime.homogeneousCore {I : Ideal A} (h : I.IsPrime) :\n    (I.homogeneousCore ğ’œ).toIdeal.IsPrime := by\n  apply (Ideal.homogeneousCore ğ’œ I).is_homogeneous'.isPrime_of_homogeneous_mem_or_mem\n  Â· exact ne_top_of_le_ne_top h.ne_top (Ideal.toIdeal_homogeneousCore_le ğ’œ I)\n  rintro x y hx hy hxy\n  have H := h.mem_or_mem (Ideal.toIdeal_homogeneousCore_le ğ’œ I hxy)\n  refine H.imp ?_ ?_\n  Â· exact Ideal.mem_homogeneousCore_of_homogeneous_of_mem hx\n  Â· exact Ideal.mem_homogeneousCore_of_homogeneous_of_mem hy\n\n"}
{"name":"Ideal.IsHomogeneous.radical_eq","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"Î¹ : Type u_1\nÏƒ : Type u_2\nA : Type u_3\ninstâœâ´ : CommRing A\ninstâœÂ³ : LinearOrderedCancelAddCommMonoid Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nI : Ideal A\nhI : Ideal.IsHomogeneous ğ’œ I\nâŠ¢ Eq I.radical (InfSet.sInf (setOf fun J => And (Ideal.IsHomogeneous ğ’œ J) (And (LE.le I J) J.IsPrime)))","decl":"theorem Ideal.IsHomogeneous.radical_eq {I : Ideal A} (hI : I.IsHomogeneous ğ’œ) :\n    I.radical = InfSet.sInf { J | Ideal.IsHomogeneous ğ’œ J âˆ§ I â‰¤ J âˆ§ J.IsPrime } := by\n  rw [Ideal.radical_eq_sInf]\n  apply le_antisymm\n  Â· exact sInf_le_sInf fun J => And.right\n  Â· refine sInf_le_sInf_of_forall_exists_le ?_\n    rintro J âŸ¨HJâ‚, HJâ‚‚âŸ©\n    refine âŸ¨(J.homogeneousCore ğ’œ).toIdeal, ?_, J.toIdeal_homogeneousCore_le _âŸ©\n    refine âŸ¨HomogeneousIdeal.isHomogeneous _, ?_, HJâ‚‚.homogeneousCoreâŸ©\n    exact hI.toIdeal_homogeneousCore_eq_self.symm.trans_le (Ideal.homogeneousCore_mono _ HJâ‚)\n\n"}
{"name":"Ideal.IsHomogeneous.radical","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"Î¹ : Type u_1\nÏƒ : Type u_2\nA : Type u_3\ninstâœâ´ : CommRing A\ninstâœÂ³ : LinearOrderedCancelAddCommMonoid Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nI : Ideal A\nh : Ideal.IsHomogeneous ğ’œ I\nâŠ¢ Ideal.IsHomogeneous ğ’œ I.radical","decl":"theorem Ideal.IsHomogeneous.radical {I : Ideal A} (h : I.IsHomogeneous ğ’œ) :\n    I.radical.IsHomogeneous ğ’œ := by\n  rw [h.radical_eq]\n  exact Ideal.IsHomogeneous.sInf fun _ => And.left\n\n"}
{"name":"HomogeneousIdeal.coe_radical","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"Î¹ : Type u_1\nÏƒ : Type u_2\nA : Type u_3\ninstâœâ´ : CommRing A\ninstâœÂ³ : LinearOrderedCancelAddCommMonoid Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nI : HomogeneousIdeal ğ’œ\nâŠ¢ Eq I.radical.toIdeal I.toIdeal.radical","decl":"@[simp]\ntheorem HomogeneousIdeal.coe_radical (I : HomogeneousIdeal ğ’œ) :\n    I.radical.toIdeal = I.toIdeal.radical := rfl\n"}
