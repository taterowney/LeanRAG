{"name":"Ideal.IsHomogeneous.isPrime_of_homogeneous_mem_or_mem","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"ι : Type u_1\nσ : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : LinearOrderedCancelAddCommMonoid ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\nI : Ideal A\nhI : Ideal.IsHomogeneous 𝒜 I\nI_ne_top : Ne I Top.top\nhomogeneous_mem_or_mem : ∀ {x y : A}, SetLike.Homogeneous 𝒜 x → SetLike.Homogeneous 𝒜 y → Membership.mem I (HMul.hMul x y) → Or (Membership.mem I x) (Membership.mem I y)\n⊢ I.IsPrime","decl":"theorem Ideal.IsHomogeneous.isPrime_of_homogeneous_mem_or_mem {I : Ideal A} (hI : I.IsHomogeneous 𝒜)\n    (I_ne_top : I ≠ ⊤)\n    (homogeneous_mem_or_mem :\n      ∀ {x y : A}, Homogeneous 𝒜 x → Homogeneous 𝒜 y → x * y ∈ I → x ∈ I ∨ y ∈ I) :\n    Ideal.IsPrime I :=\n  ⟨I_ne_top, by\n    intro x y hxy\n    by_contra! rid\n    obtain ⟨rid₁, rid₂⟩ := rid\n    classical\n      /-\n        The idea of the proof is the following :\n        since `x * y ∈ I` and `I` homogeneous, then `proj i (x * y) ∈ I` for any `i : ι`.\n        Then consider two sets `{i ∈ x.support | xᵢ ∉ I}` and `{j ∈ y.support | yⱼ ∉ J}`;\n        let `max₁, max₂` be the maximum of the two sets, then `proj (max₁ + max₂) (x * y) ∈ I`.\n        Then, `proj max₁ x ∉ I` and `proj max₂ j ∉ I`\n        but `proj i x ∈ I` for all `max₁ < i` and `proj j y ∈ I` for all `max₂ < j`.\n        `  proj (max₁ + max₂) (x * y)`\n        `= ∑ {(i, j) ∈ supports | i + j = max₁ + max₂}, xᵢ * yⱼ`\n        `= proj max₁ x * proj max₂ y`\n        `  + ∑ {(i, j) ∈ supports \\ {(max₁, max₂)} | i + j = max₁ + max₂}, xᵢ * yⱼ`.\n        This is a contradiction, because both `proj (max₁ + max₂) (x * y) ∈ I` and the sum on the\n        right hand side is in `I` however `proj max₁ x * proj max₂ y` is not in `I`.\n        -/\n      set set₁ := {i ∈ (decompose 𝒜 x).support | proj 𝒜 i x ∉ I} with set₁_eq\n      set set₂ := {i ∈ (decompose 𝒜 y).support | proj 𝒜 i y ∉ I} with set₂_eq\n      have nonempty :\n        ∀ x : A, x ∉ I → {i ∈ (decompose 𝒜 x).support | proj 𝒜 i x ∉ I}.Nonempty := by\n        intro x hx\n        rw [filter_nonempty_iff]\n        contrapose! hx\n        simp_rw [proj_apply] at hx\n        rw [← sum_support_decompose 𝒜 x]\n        exact Ideal.sum_mem _ hx\n      set max₁ := set₁.max' (nonempty x rid₁)\n      set max₂ := set₂.max' (nonempty y rid₂)\n      have mem_max₁ : max₁ ∈ set₁ := max'_mem set₁ (nonempty x rid₁)\n      have mem_max₂ : max₂ ∈ set₂ := max'_mem set₂ (nonempty y rid₂)\n      replace hxy : proj 𝒜 (max₁ + max₂) (x * y) ∈ I := hI _ hxy\n      have mem_I : proj 𝒜 max₁ x * proj 𝒜 max₂ y ∈ I := by\n        set antidiag :=\n          {z ∈ (decompose 𝒜 x).support ×ˢ (decompose 𝒜 y).support | z.1 + z.2 = max₁ + max₂}\n           with ha\n        have mem_antidiag : (max₁, max₂) ∈ antidiag := by\n          simp only [antidiag, add_sum_erase, mem_filter, mem_product]\n          exact ⟨⟨mem_of_mem_filter _ mem_max₁, mem_of_mem_filter _ mem_max₂⟩, trivial⟩\n        have eq_add_sum :=\n          calc\n            proj 𝒜 (max₁ + max₂) (x * y) = ∑ ij ∈ antidiag, proj 𝒜 ij.1 x * proj 𝒜 ij.2 y := by\n              simp_rw [ha, proj_apply, DirectSum.decompose_mul, DirectSum.coe_mul_apply 𝒜]\n            _ =\n                proj 𝒜 max₁ x * proj 𝒜 max₂ y +\n                  ∑ ij ∈ antidiag.erase (max₁, max₂), proj 𝒜 ij.1 x * proj 𝒜 ij.2 y :=\n              (add_sum_erase _ _ mem_antidiag).symm\n        rw [eq_sub_of_add_eq eq_add_sum.symm]\n        refine Ideal.sub_mem _ hxy (Ideal.sum_mem _ fun z H => ?_)\n        rcases z with ⟨i, j⟩\n        simp only [antidiag, mem_erase, Prod.mk.inj_iff, Ne, mem_filter, mem_product] at H\n        rcases H with ⟨H₁, ⟨H₂, H₃⟩, H₄⟩\n        have max_lt : max₁ < i ∨ max₂ < j := by\n          rcases lt_trichotomy max₁ i with (h | rfl | h)\n          · exact Or.inl h\n          · refine False.elim (H₁ ⟨rfl, add_left_cancel H₄⟩)\n          · apply Or.inr\n            have := add_lt_add_right h j\n            rw [H₄] at this\n            exact lt_of_add_lt_add_left this\n        cases' max_lt with max_lt max_lt\n        · -- in this case `max₁ < i`, then `xᵢ ∈ I`; for otherwise `i ∈ set₁` then `i ≤ max₁`.\n          have not_mem : i ∉ set₁ := fun h =>\n            lt_irrefl _ ((max'_lt_iff set₁ (nonempty x rid₁)).mp max_lt i h)\n          rw [set₁_eq] at not_mem\n          simp only [not_and, Classical.not_not, Ne, mem_filter] at not_mem\n          exact Ideal.mul_mem_right _ I (not_mem H₂)\n        · -- in this case `max₂ < j`, then `yⱼ ∈ I`; for otherwise `j ∈ set₂`, then `j ≤ max₂`.\n          have not_mem : j ∉ set₂ := fun h =>\n            lt_irrefl _ ((max'_lt_iff set₂ (nonempty y rid₂)).mp max_lt j h)\n          rw [set₂_eq] at not_mem\n          simp only [not_and, Classical.not_not, Ne, mem_filter] at not_mem\n          exact Ideal.mul_mem_left I _ (not_mem H₃)\n      have not_mem_I : proj 𝒜 max₁ x * proj 𝒜 max₂ y ∉ I := by\n        have neither_mem : proj 𝒜 max₁ x ∉ I ∧ proj 𝒜 max₂ y ∉ I := by\n          rw [mem_filter] at mem_max₁ mem_max₂\n          exact ⟨mem_max₁.2, mem_max₂.2⟩\n        intro _rid\n        cases' homogeneous_mem_or_mem ⟨max₁, SetLike.coe_mem _⟩ ⟨max₂, SetLike.coe_mem _⟩ mem_I\n          with h h\n        · apply neither_mem.1 h\n        · apply neither_mem.2 h\n      exact not_mem_I mem_I⟩\n\n"}
{"name":"Ideal.IsHomogeneous.isPrime_iff","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"ι : Type u_1\nσ : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : LinearOrderedCancelAddCommMonoid ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\nI : Ideal A\nh : Ideal.IsHomogeneous 𝒜 I\n⊢ Iff I.IsPrime (And (Ne I Top.top) (∀ {x y : A}, SetLike.Homogeneous 𝒜 x → SetLike.Homogeneous 𝒜 y → Membership.mem I (HMul.hMul x y) → Or (Membership.mem I x) (Membership.mem I y)))","decl":"theorem Ideal.IsHomogeneous.isPrime_iff {I : Ideal A} (h : I.IsHomogeneous 𝒜) :\n    I.IsPrime ↔\n      I ≠ ⊤ ∧\n        ∀ {x y : A},\n          SetLike.Homogeneous 𝒜 x → SetLike.Homogeneous 𝒜 y → x * y ∈ I → x ∈ I ∨ y ∈ I :=\n  ⟨fun HI => ⟨HI.ne_top, fun _ _ hxy => Ideal.IsPrime.mem_or_mem HI hxy⟩,\n    fun ⟨I_ne_top, homogeneous_mem_or_mem⟩ =>\n    h.isPrime_of_homogeneous_mem_or_mem I_ne_top @homogeneous_mem_or_mem⟩\n\n"}
{"name":"Ideal.IsPrime.homogeneousCore","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"ι : Type u_1\nσ : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : LinearOrderedCancelAddCommMonoid ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\nI : Ideal A\nh : I.IsPrime\n⊢ (Ideal.homogeneousCore 𝒜 I).toIdeal.IsPrime","decl":"theorem Ideal.IsPrime.homogeneousCore {I : Ideal A} (h : I.IsPrime) :\n    (I.homogeneousCore 𝒜).toIdeal.IsPrime := by\n  apply (Ideal.homogeneousCore 𝒜 I).is_homogeneous'.isPrime_of_homogeneous_mem_or_mem\n  · exact ne_top_of_le_ne_top h.ne_top (Ideal.toIdeal_homogeneousCore_le 𝒜 I)\n  rintro x y hx hy hxy\n  have H := h.mem_or_mem (Ideal.toIdeal_homogeneousCore_le 𝒜 I hxy)\n  refine H.imp ?_ ?_\n  · exact Ideal.mem_homogeneousCore_of_homogeneous_of_mem hx\n  · exact Ideal.mem_homogeneousCore_of_homogeneous_of_mem hy\n\n"}
{"name":"Ideal.IsHomogeneous.radical_eq","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"ι : Type u_1\nσ : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : LinearOrderedCancelAddCommMonoid ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\nI : Ideal A\nhI : Ideal.IsHomogeneous 𝒜 I\n⊢ Eq I.radical (InfSet.sInf (setOf fun J => And (Ideal.IsHomogeneous 𝒜 J) (And (LE.le I J) J.IsPrime)))","decl":"theorem Ideal.IsHomogeneous.radical_eq {I : Ideal A} (hI : I.IsHomogeneous 𝒜) :\n    I.radical = InfSet.sInf { J | Ideal.IsHomogeneous 𝒜 J ∧ I ≤ J ∧ J.IsPrime } := by\n  rw [Ideal.radical_eq_sInf]\n  apply le_antisymm\n  · exact sInf_le_sInf fun J => And.right\n  · refine sInf_le_sInf_of_forall_exists_le ?_\n    rintro J ⟨HJ₁, HJ₂⟩\n    refine ⟨(J.homogeneousCore 𝒜).toIdeal, ?_, J.toIdeal_homogeneousCore_le _⟩\n    refine ⟨HomogeneousIdeal.isHomogeneous _, ?_, HJ₂.homogeneousCore⟩\n    exact hI.toIdeal_homogeneousCore_eq_self.symm.trans_le (Ideal.homogeneousCore_mono _ HJ₁)\n\n"}
{"name":"Ideal.IsHomogeneous.radical","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"ι : Type u_1\nσ : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : LinearOrderedCancelAddCommMonoid ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\nI : Ideal A\nh : Ideal.IsHomogeneous 𝒜 I\n⊢ Ideal.IsHomogeneous 𝒜 I.radical","decl":"theorem Ideal.IsHomogeneous.radical {I : Ideal A} (h : I.IsHomogeneous 𝒜) :\n    I.radical.IsHomogeneous 𝒜 := by\n  rw [h.radical_eq]\n  exact Ideal.IsHomogeneous.sInf fun _ => And.left\n\n"}
{"name":"HomogeneousIdeal.coe_radical","module":"Mathlib.RingTheory.GradedAlgebra.Radical","initialProofState":"ι : Type u_1\nσ : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : LinearOrderedCancelAddCommMonoid ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\nI : HomogeneousIdeal 𝒜\n⊢ Eq I.radical.toIdeal I.toIdeal.radical","decl":"@[simp]\ntheorem HomogeneousIdeal.coe_radical (I : HomogeneousIdeal 𝒜) :\n    I.radical.toIdeal = I.toIdeal.radical := rfl\n"}
