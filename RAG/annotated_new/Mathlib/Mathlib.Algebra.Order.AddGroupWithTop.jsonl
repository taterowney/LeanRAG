{"name":"LinearOrderedAddCommMonoidWithTop.top_add'","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_2\nself : LinearOrderedAddCommMonoidWithTop α\nx : α\n⊢ Eq (HAdd.hAdd Top.top x) Top.top","decl":"/-- A linearly ordered commutative monoid with an additively absorbing `⊤` element.\n  Instances should include number systems with an infinite element adjoined. -/\nclass LinearOrderedAddCommMonoidWithTop (α : Type*) extends LinearOrderedAddCommMonoid α,\n    OrderTop α where\n  /-- In a `LinearOrderedAddCommMonoidWithTop`, the `⊤` element is invariant under addition. -/\n  protected top_add' : ∀ x : α, ⊤ + x = ⊤\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.add_neg_cancel","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_2\nself : LinearOrderedAddCommGroupWithTop α\na : α\na✝ : Ne a Top.top\n⊢ Eq (HAdd.hAdd a (Neg.neg a)) 0","decl":"/-- A linearly ordered commutative group with an additively absorbing `⊤` element.\n  Instances should include number systems with an infinite element adjoined. -/\nclass LinearOrderedAddCommGroupWithTop (α : Type*) extends LinearOrderedAddCommMonoidWithTop α,\n  SubNegMonoid α, Nontrivial α where\n  protected neg_top : -(⊤ : α) = ⊤\n  protected add_neg_cancel : ∀ a : α, a ≠ ⊤ → a + -a = 0\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.neg_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_2\nself : LinearOrderedAddCommGroupWithTop α\n⊢ Eq (Neg.neg Top.top) Top.top","decl":"/-- A linearly ordered commutative group with an additively absorbing `⊤` element.\n  Instances should include number systems with an infinite element adjoined. -/\nclass LinearOrderedAddCommGroupWithTop (α : Type*) extends LinearOrderedAddCommMonoidWithTop α,\n  SubNegMonoid α, Nontrivial α where\n  protected neg_top : -(⊤ : α) = ⊤\n  protected add_neg_cancel : ∀ a : α, a ≠ ⊤ → a + -a = 0\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.zsmul_zero'","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_2\nself : LinearOrderedAddCommGroupWithTop α\na : α\n⊢ Eq (LinearOrderedAddCommGroupWithTop.zsmul 0 a) 0","decl":"/-- A linearly ordered commutative group with an additively absorbing `⊤` element.\n  Instances should include number systems with an infinite element adjoined. -/\nclass LinearOrderedAddCommGroupWithTop (α : Type*) extends LinearOrderedAddCommMonoidWithTop α,\n  SubNegMonoid α, Nontrivial α where\n  protected neg_top : -(⊤ : α) = ⊤\n  protected add_neg_cancel : ∀ a : α, a ≠ ⊤ → a + -a = 0\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.zsmul_neg'","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_2\nself : LinearOrderedAddCommGroupWithTop α\nn : Nat\na : α\n⊢ Eq (LinearOrderedAddCommGroupWithTop.zsmul (Int.negSucc n) a) (Neg.neg (LinearOrderedAddCommGroupWithTop.zsmul (↑n.succ) a))","decl":"/-- A linearly ordered commutative group with an additively absorbing `⊤` element.\n  Instances should include number systems with an infinite element adjoined. -/\nclass LinearOrderedAddCommGroupWithTop (α : Type*) extends LinearOrderedAddCommMonoidWithTop α,\n  SubNegMonoid α, Nontrivial α where\n  protected neg_top : -(⊤ : α) = ⊤\n  protected add_neg_cancel : ∀ a : α, a ≠ ⊤ → a + -a = 0\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.sub_eq_add_neg","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_2\nself : LinearOrderedAddCommGroupWithTop α\na b : α\n⊢ Eq (HSub.hSub a b) (HAdd.hAdd a (Neg.neg b))","decl":"/-- A linearly ordered commutative group with an additively absorbing `⊤` element.\n  Instances should include number systems with an infinite element adjoined. -/\nclass LinearOrderedAddCommGroupWithTop (α : Type*) extends LinearOrderedAddCommMonoidWithTop α,\n  SubNegMonoid α, Nontrivial α where\n  protected neg_top : -(⊤ : α) = ⊤\n  protected add_neg_cancel : ∀ a : α, a ≠ ⊤ → a + -a = 0\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.toNontrivial","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_2\nself : LinearOrderedAddCommGroupWithTop α\n⊢ Nontrivial α","decl":"/-- A linearly ordered commutative group with an additively absorbing `⊤` element.\n  Instances should include number systems with an infinite element adjoined. -/\nclass LinearOrderedAddCommGroupWithTop (α : Type*) extends LinearOrderedAddCommMonoidWithTop α,\n  SubNegMonoid α, Nontrivial α where\n  protected neg_top : -(⊤ : α) = ⊤\n  protected add_neg_cancel : ∀ a : α, a ≠ ⊤ → a + -a = 0\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.zsmul_succ'","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_2\nself : LinearOrderedAddCommGroupWithTop α\nn : Nat\na : α\n⊢ Eq (LinearOrderedAddCommGroupWithTop.zsmul (↑n.succ) a) (HAdd.hAdd (LinearOrderedAddCommGroupWithTop.zsmul (↑n) a) a)","decl":"/-- A linearly ordered commutative group with an additively absorbing `⊤` element.\n  Instances should include number systems with an infinite element adjoined. -/\nclass LinearOrderedAddCommGroupWithTop (α : Type*) extends LinearOrderedAddCommMonoidWithTop α,\n  SubNegMonoid α, Nontrivial α where\n  protected neg_top : -(⊤ : α) = ⊤\n  protected add_neg_cancel : ∀ a : α, a ≠ ⊤ → a + -a = 0\n\n"}
{"name":"top_add","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommMonoidWithTop α\na : α\n⊢ Eq (HAdd.hAdd Top.top a) Top.top","decl":"@[simp]\ntheorem top_add (a : α) : ⊤ + a = ⊤ :=\n  LinearOrderedAddCommMonoidWithTop.top_add' a\n\n"}
{"name":"add_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommMonoidWithTop α\na : α\n⊢ Eq (HAdd.hAdd a Top.top) Top.top","decl":"@[simp]\ntheorem add_top (a : α) : a + ⊤ = ⊤ :=\n  Trans.trans (add_comm _ _) (top_add _)\n\n"}
{"name":"WithTop.LinearOrderedAddCommGroup.coe_neg","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\na : α\n⊢ Eq (↑(Neg.neg a)) (Neg.neg ↑a)","decl":"@[simp, norm_cast]\ntheorem coe_neg (a : α) : ((-a : α) : WithTop α) = -a :=\n  rfl\n\n"}
{"name":"WithTop.LinearOrderedAddCommGroup.neg_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\n⊢ Eq (Neg.neg Top.top) Top.top","decl":"@[simp]\ntheorem neg_top : -(⊤ : WithTop α) = ⊤ := rfl\n\n"}
{"name":"WithTop.LinearOrderedAddCommGroup.coe_sub","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\na b : α\n⊢ Eq (↑(HSub.hSub a b)) (HSub.hSub ↑a ↑b)","decl":"@[simp, norm_cast]\ntheorem coe_sub {a b : α} : (↑(a - b) : WithTop α) = ↑a - ↑b := rfl\n\n"}
{"name":"WithTop.LinearOrderedAddCommGroup.top_sub","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\na : WithTop α\n⊢ Eq (HSub.hSub Top.top a) Top.top","decl":"@[simp]\ntheorem top_sub {a : WithTop α} : (⊤ : WithTop α) - a = ⊤ := by\n  cases a <;> rfl\n\n"}
{"name":"WithTop.LinearOrderedAddCommGroup.sub_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\na : WithTop α\n⊢ Eq (HSub.hSub a Top.top) Top.top","decl":"@[simp]\ntheorem sub_top {a : WithTop α} : a - ⊤ = ⊤ := by cases a <;> rfl\n\n"}
{"name":"WithTop.LinearOrderedAddCommGroup.sub_eq_top_iff","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroup α\na b : WithTop α\n⊢ Iff (Eq (HSub.hSub a b) Top.top) (Or (Eq a Top.top) (Eq b Top.top))","decl":"@[simp]\nlemma sub_eq_top_iff {a b : WithTop α} : a - b = ⊤ ↔ (a = ⊤ ∨ b = ⊤) := by\n  cases a <;> cases b <;> simp [← coe_sub]\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.add_neg_cancel_of_ne_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_2\ninst✝ : LinearOrderedAddCommGroupWithTop α\na : α\nh : Ne a Top.top\n⊢ Eq (HAdd.hAdd a (Neg.neg a)) 0","decl":"lemma add_neg_cancel_of_ne_top {α : Type*} [LinearOrderedAddCommGroupWithTop α]\n    {a : α} (h : a ≠ ⊤) :\n    a + -a = 0 :=\n  LinearOrderedAddCommGroupWithTop.add_neg_cancel a h\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.add_eq_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroupWithTop α\na b : α\n⊢ Iff (Eq (HAdd.hAdd a b) Top.top) (Or (Eq a Top.top) (Eq b Top.top))","decl":"@[simp]\nlemma add_eq_top : a + b = ⊤ ↔ a = ⊤ ∨ b = ⊤ := by\n  constructor\n  · intro h\n    by_contra nh\n    rw [not_or] at nh\n    replace h := congrArg (-a + ·) h\n    dsimp only at h\n    rw [add_top, ← add_assoc, add_comm (-a), add_neg_cancel_of_ne_top,\n      zero_add] at h\n    · exact nh.2 h\n    · exact nh.1\n  · rintro (rfl | rfl)\n    · simp\n    · simp\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.top_ne_zero","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroupWithTop α\n⊢ Ne Top.top 0","decl":"@[simp]\nlemma top_ne_zero :\n    (⊤ : α) ≠ 0 := by\n  intro nh\n  have ⟨a, b, h⟩ := Nontrivial.exists_pair_ne (α := α)\n  have : a + 0 ≠ b + 0 := by simpa\n  rw [← nh] at this\n  simp at this\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.neg_eq_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroupWithTop α\na : α\n⊢ Iff (Eq (Neg.neg a) Top.top) (Eq a Top.top)","decl":"@[simp] lemma neg_eq_top {a : α} : -a = ⊤ ↔ a = ⊤ where\n  mp h := by\n    by_contra nh\n    replace nh := add_neg_cancel_of_ne_top nh\n    rw [h, add_top] at nh\n    exact top_ne_zero nh\n  mpr h := by simp [h]\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.injective_add_left_of_ne_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroupWithTop α\nb : α\nh : Ne b Top.top\n⊢ Function.Injective fun x => HAdd.hAdd x b","decl":"lemma injective_add_left_of_ne_top (b : α) (h : b ≠ ⊤) : Function.Injective (fun x ↦ x + b) := by\n  intro x y h2\n  replace h2 : x + (b + -b) = y + (b + -b) := by simp [← add_assoc, h2]\n  simpa only [LinearOrderedAddCommGroupWithTop.add_neg_cancel _ h, add_zero] using h2\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.injective_add_right_of_ne_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroupWithTop α\nb : α\nh : Ne b Top.top\n⊢ Function.Injective fun x => HAdd.hAdd b x","decl":"lemma injective_add_right_of_ne_top (b : α) (h : b ≠ ⊤) : Function.Injective (fun x ↦ b + x) := by\n  simpa [add_comm] using injective_add_left_of_ne_top b h\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.strictMono_add_left_of_ne_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroupWithTop α\nb : α\nh : Ne b Top.top\n⊢ StrictMono fun x => HAdd.hAdd x b","decl":"lemma strictMono_add_left_of_ne_top (b : α) (h : b ≠ ⊤) : StrictMono (fun x ↦ x + b) := by\n  apply Monotone.strictMono_of_injective\n  · apply Monotone.add_const monotone_id\n  · apply injective_add_left_of_ne_top _ h\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.strictMono_add_right_of_ne_top","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroupWithTop α\nb : α\nh : Ne b Top.top\n⊢ StrictMono fun x => HAdd.hAdd b x","decl":"lemma strictMono_add_right_of_ne_top (b : α) (h : b ≠ ⊤) : StrictMono (fun x ↦ b + x) := by\n  simpa [add_comm] using strictMono_add_left_of_ne_top b h\n\n"}
{"name":"LinearOrderedAddCommGroupWithTop.sub_pos","module":"Mathlib.Algebra.Order.AddGroupWithTop","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommGroupWithTop α\na b : α\n⊢ Iff (LT.lt 0 (HSub.hSub a b)) (Or (LT.lt b a) (Eq b Top.top))","decl":"lemma sub_pos (a b : α) : 0 < a - b ↔ b < a ∨ b = ⊤ where\n  mp h := by\n    refine or_iff_not_imp_right.mpr fun h2 ↦ ?_\n    replace h := strictMono_add_left_of_ne_top _ h2 h\n    simp only [zero_add] at h\n    rw [sub_eq_add_neg, add_assoc, add_comm (-b),\n      add_neg_cancel_of_ne_top h2, add_zero] at h\n    exact h\n  mpr h := by\n    rcases h with h | h\n    · convert strictMono_add_left_of_ne_top (-b) (by simp [h.ne_top]) h using 1\n      · simp [add_neg_cancel_of_ne_top h.ne_top]\n      · simp [sub_eq_add_neg]\n    · rw [h]\n      simp only [sub_eq_add_neg, LinearOrderedAddCommGroupWithTop.neg_top, add_top]\n      apply lt_of_le_of_ne le_top\n      exact Ne.symm top_ne_zero\n\n"}
