{"name":"Finset.expect_univ","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\nf : ι → M\ninst✝ : Fintype ι\n⊢ Eq (Finset.univ.expect fun i => f i) (HSMul.hSMul (Inv.inv ↑(Fintype.card ι)) (Finset.univ.sum fun i => f i))","decl":"lemma expect_univ [Fintype ι] : 𝔼 i, f i = (∑ i, f i) /ℚ Fintype.card ι := by\n  rw [expect, card_univ]\n\n"}
{"name":"Finset.expect_empty","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\nf : ι → M\n⊢ Eq (EmptyCollection.emptyCollection.expect fun i => f i) 0","decl":"@[simp] lemma expect_empty (f : ι → M) : 𝔼 i ∈ ∅, f i = 0 := by simp [expect]\n"}
{"name":"Finset.expect_singleton","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\nf : ι → M\ni : ι\n⊢ Eq ((Singleton.singleton i).expect fun j => f j) (f i)","decl":"@[simp] lemma expect_singleton (f : ι → M) (i : ι) : 𝔼 j ∈ {i}, f j = f i := by simp [expect]\n"}
{"name":"Finset.expect_const_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\n⊢ Eq (s.expect fun _i => 0) 0","decl":"@[simp] lemma expect_const_zero (s : Finset ι) : 𝔼 _i ∈ s, (0 : M) = 0 := by simp [expect]\n\n"}
{"name":"Finset.expect_congr","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf g : ι → M\nt : Finset ι\nhst : Eq s t\nh : ∀ (i : ι), Membership.mem t i → Eq (f i) (g i)\n⊢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"@[congr]\nlemma expect_congr {t : Finset ι} (hst : s = t) (h : ∀ i ∈ t, f i = g i) :\n    𝔼 i ∈ s, f i = 𝔼 i ∈ t, g i := by rw [expect, expect, sum_congr hst h, hst]\n\n"}
{"name":"Finset.expectWith_congr","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module NNRat M\ns t : Finset ι\nf g : ι → M\np q : ι → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\nhst : Eq s t\nhpq : ∀ (i : ι), Membership.mem t i → Iff (p i) (q i)\nh : ∀ (i : ι), Membership.mem t i → q i → Eq (f i) (g i)\n⊢ Eq ((Finset.filter (fun i => p i) s).expect fun i => f i) ((Finset.filter (fun i => q i) t).expect fun i => g i)","decl":"lemma expectWith_congr (hst : s = t) (hpq : ∀ i ∈ t, p i ↔ q i) (h : ∀ i ∈ t, q i → f i = g i) :\n    𝔼 i ∈ s with p i, f i = 𝔼 i ∈ t with q i, g i :=\n  expect_congr (by rw [hst, filter_inj'.2 hpq]) <| by simpa using h\n\n"}
{"name":"Finset.expect_sum_comm","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nt : Finset κ\nf : ι → κ → M\n⊢ Eq (s.expect fun i => t.sum fun j => f i j) (t.sum fun j => s.expect fun i => f i j)","decl":"lemma expect_sum_comm (s : Finset ι) (t : Finset κ) (f : ι → κ → M) :\n    𝔼 i ∈ s, ∑ j ∈ t, f i j = ∑ j ∈ t, 𝔼 i ∈ s, f i j := by\n  simpa only [expect, smul_sum] using sum_comm\n\n"}
{"name":"Finset.expect_comm","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nt : Finset κ\nf : ι → κ → M\n⊢ Eq (s.expect fun i => t.expect fun j => f i j) (t.expect fun j => s.expect fun i => f i j)","decl":"lemma expect_comm (s : Finset ι) (t : Finset κ) (f : ι → κ → M) :\n    𝔼 i ∈ s, 𝔼 j ∈ t, f i j = 𝔼 j ∈ t, 𝔼 i ∈ s, f i j := by\n  rw [expect, expect, ← expect_sum_comm, ← expect_sum_comm, expect, expect, smul_comm, sum_comm]\n\n"}
{"name":"Finset.expect_eq_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\nh : ∀ (i : ι), Membership.mem s i → Eq (f i) 0\n⊢ Eq (s.expect fun i => f i) 0","decl":"lemma expect_eq_zero (h : ∀ i ∈ s, f i = 0) : 𝔼 i ∈ s, f i = 0 :=\n  (expect_congr rfl h).trans s.expect_const_zero\n\n"}
{"name":"Finset.exists_ne_zero_of_expect_ne_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\nh : Ne (s.expect fun i => f i) 0\n⊢ Exists fun i => And (Membership.mem s i) (Ne (f i) 0)","decl":"lemma exists_ne_zero_of_expect_ne_zero (h : 𝔼 i ∈ s, f i ≠ 0) : ∃ i ∈ s, f i ≠ 0 := by\n  contrapose! h; exact expect_eq_zero h\n\n"}
{"name":"Finset.expect_add_distrib","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf g : ι → M\n⊢ Eq (s.expect fun i => HAdd.hAdd (f i) (g i)) (HAdd.hAdd (s.expect fun i => f i) (s.expect fun i => g i))","decl":"lemma expect_add_distrib (s : Finset ι) (f g : ι → M) :\n    𝔼 i ∈ s, (f i + g i) = 𝔼 i ∈ s, f i + 𝔼 i ∈ s, g i := by\n  simp [expect, sum_add_distrib]\n\n"}
{"name":"Finset.expect_add_expect_comm","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf₁ f₂ g₁ g₂ : ι → M\n⊢ Eq (HAdd.hAdd (s.expect fun i => HAdd.hAdd (f₁ i) (f₂ i)) (s.expect fun i => HAdd.hAdd (g₁ i) (g₂ i))) (HAdd.hAdd (s.expect fun i => HAdd.hAdd (f₁ i) (g₁ i)) (s.expect fun i => HAdd.hAdd (f₂ i) (g₂ i)))","decl":"lemma expect_add_expect_comm (f₁ f₂ g₁ g₂ : ι → M) :\n    𝔼 i ∈ s, (f₁ i + f₂ i) + 𝔼 i ∈ s, (g₁ i + g₂ i) =\n      𝔼 i ∈ s, (f₁ i + g₁ i) + 𝔼 i ∈ s, (f₂ i + g₂ i) := by\n  simp_rw [expect_add_distrib, add_add_add_comm]\n\n"}
{"name":"Finset.expect_eq_single_of_mem","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\ni : ι\nhi : Membership.mem s i\nh : ∀ (j : ι), Membership.mem s j → Ne j i → Eq (f j) 0\n⊢ Eq (s.expect fun i => f i) (HSMul.hSMul (Inv.inv ↑s.card) (f i))","decl":"lemma expect_eq_single_of_mem (i : ι) (hi : i ∈ s) (h : ∀ j ∈ s, j ≠ i → f j = 0) :\n    𝔼 i ∈ s, f i = f i /ℚ #s := by rw [expect, sum_eq_single_of_mem _ hi h]\n\n"}
{"name":"Finset.expect_ite_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ns : Finset ι\np : ι → Prop\ninst✝ : DecidablePred p\nh : ∀ (i : ι), Membership.mem s i → ∀ (j : ι), Membership.mem s j → p i → p j → Eq i j\na : M\n⊢ Eq (s.expect fun i => ite (p i) a 0) (ite (Exists fun i => And (Membership.mem s i) (p i)) (HSMul.hSMul (Inv.inv ↑s.card) a) 0)","decl":"lemma expect_ite_zero (s : Finset ι) (p : ι → Prop) [DecidablePred p]\n    (h : ∀ i ∈ s, ∀ j ∈ s, p i → p j → i = j) (a : M) :\n    𝔼 i ∈ s, ite (p i) a 0 = ite (∃ i ∈ s, p i) (a /ℚ #s) 0 := by\n  split_ifs <;> simp [expect, sum_ite_zero _ _ h, *]\n\n"}
{"name":"Finset.expect_ite_mem","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ninst✝ : DecidableEq ι\ns t : Finset ι\nf : ι → M\n⊢ Eq (s.expect fun i => ite (Membership.mem t i) (f i) 0) (HSMul.hSMul (HDiv.hDiv ↑(Inter.inter s t).card ↑s.card) ((Inter.inter s t).expect fun i => f i))","decl":"lemma expect_ite_mem (s t : Finset ι) (f : ι → M) :\n    𝔼 i ∈ s, (if i ∈ t then f i else 0) = (#(s ∩ t) / #s : ℚ≥0) • 𝔼 i ∈ s ∩ t, f i := by\n  obtain hst | hst := (s ∩ t).eq_empty_or_nonempty\n  · simp [expect, hst]\n  · simp [expect, smul_smul, ← inv_mul_eq_div, hst.card_ne_zero]\n\n"}
{"name":"Finset.expect_dite_eq","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ns : Finset ι\ninst✝ : DecidableEq ι\ni : ι\nf : (j : ι) → Eq i j → M\n⊢ Eq (s.expect fun j => dite (Eq i j) (fun h => f j h) fun h => 0) (ite (Membership.mem s i) (HSMul.hSMul (Inv.inv ↑s.card) (f i ⋯)) 0)","decl":"@[simp] lemma expect_dite_eq (i : ι) (f : ∀ j, i = j → M) :\n    𝔼 j ∈ s, (if h : i = j then f j h else 0) = if i ∈ s then f i rfl /ℚ #s else 0 := by\n  split_ifs <;> simp [expect, *]\n\n"}
{"name":"Finset.expect_dite_eq'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ns : Finset ι\ninst✝ : DecidableEq ι\ni : ι\nf : (j : ι) → Eq j i → M\n⊢ Eq (s.expect fun j => dite (Eq j i) (fun h => f j h) fun h => 0) (ite (Membership.mem s i) (HSMul.hSMul (Inv.inv ↑s.card) (f i ⋯)) 0)","decl":"@[simp] lemma expect_dite_eq' (i : ι) (f : ∀ j, j = i → M) :\n    𝔼 j ∈ s, (if h : j = i then f j h else 0) = if i ∈ s then f i rfl /ℚ #s else 0 := by\n  split_ifs <;> simp [expect, *]\n\n"}
{"name":"Finset.expect_ite_eq","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ns : Finset ι\ninst✝ : DecidableEq ι\ni : ι\nf : ι → M\n⊢ Eq (s.expect fun j => ite (Eq i j) (f j) 0) (ite (Membership.mem s i) (HSMul.hSMul (Inv.inv ↑s.card) (f i)) 0)","decl":"@[simp] lemma expect_ite_eq (i : ι) (f : ι → M) :\n    𝔼 j ∈ s, (if i = j then f j else 0) = if i ∈ s then f i /ℚ #s else 0 := by\n  split_ifs <;> simp [expect, *]\n\n"}
{"name":"Finset.expect_ite_eq'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ns : Finset ι\ninst✝ : DecidableEq ι\ni : ι\nf : ι → M\n⊢ Eq (s.expect fun j => ite (Eq j i) (f j) 0) (ite (Membership.mem s i) (HSMul.hSMul (Inv.inv ↑s.card) (f i)) 0)","decl":"@[simp] lemma expect_ite_eq' (i : ι) (f : ι → M) :\n    𝔼 j ∈ s, (if j = i then f j else 0) = if i ∈ s then f i /ℚ #s else 0 := by\n  split_ifs <;> simp [expect, *]\n\n"}
{"name":"Finset.expect_bij","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\nt : Finset κ\ng : κ → M\ni : (a : ι) → Membership.mem s a → κ\nhi : ∀ (a : ι) (ha : Membership.mem s a), Membership.mem t (i a ha)\nh : ∀ (a : ι) (ha : Membership.mem s a), Eq (f a) (g (i a ha))\ni_inj : ∀ (a₁ : ι) (ha₁ : Membership.mem s a₁) (a₂ : ι) (ha₂ : Membership.mem s a₂), Eq (i a₁ ha₁) (i a₂ ha₂) → Eq a₁ a₂\ni_surj : ∀ (b : κ), Membership.mem t b → Exists fun a => Exists fun ha => Eq (i a ha) b\n⊢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- Reorder an average.\n\nThe difference with `Finset.expect_bij'` is that the bijection is specified as a surjective\ninjection, rather than by an inverse function.\n\nThe difference with `Finset.expect_nbij` is that the bijection is allowed to use membership of the\ndomain of the average, rather than being a non-dependent function. -/\nlemma expect_bij (i : ∀ a ∈ s, κ) (hi : ∀ a ha, i a ha ∈ t) (h : ∀ a ha, f a = g (i a ha))\n    (i_inj : ∀ a₁ ha₁ a₂ ha₂, i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂)\n    (i_surj : ∀ b ∈ t, ∃ a ha, i a ha = b) : 𝔼 i ∈ s, f i = 𝔼 i ∈ t, g i := by\n  simp_rw [expect, card_bij i hi i_inj i_surj, sum_bij i hi i_inj i_surj h]\n\n"}
{"name":"Finset.expect_bij'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\nt : Finset κ\ng : κ → M\ni : (a : ι) → Membership.mem s a → κ\nj : (a : κ) → Membership.mem t a → ι\nhi : ∀ (a : ι) (ha : Membership.mem s a), Membership.mem t (i a ha)\nhj : ∀ (a : κ) (ha : Membership.mem t a), Membership.mem s (j a ha)\nleft_inv : ∀ (a : ι) (ha : Membership.mem s a), Eq (j (i a ha) ⋯) a\nright_inv : ∀ (a : κ) (ha : Membership.mem t a), Eq (i (j a ha) ⋯) a\nh : ∀ (a : ι) (ha : Membership.mem s a), Eq (f a) (g (i a ha))\n⊢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- Reorder an average.\n\nThe difference with `Finset.expect_bij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.expect_nbij'` is that the bijection and its inverse are allowed to use\nmembership of the domains of the averages, rather than being non-dependent functions. -/\nlemma expect_bij' (i : ∀ a ∈ s, κ) (j : ∀ a ∈ t, ι) (hi : ∀ a ha, i a ha ∈ t)\n    (hj : ∀ a ha, j a ha ∈ s) (left_inv : ∀ a ha, j (i a ha) (hi a ha) = a)\n    (right_inv : ∀ a ha, i (j a ha) (hj a ha) = a) (h : ∀ a ha, f a = g (i a ha)) :\n    𝔼 i ∈ s, f i = 𝔼 i ∈ t, g i := by\n  simp_rw [expect, card_bij' i j hi hj left_inv right_inv, sum_bij' i j hi hj left_inv right_inv h]\n\n"}
{"name":"Finset.expect_nbij","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\nt : Finset κ\ng : κ → M\ni : ι → κ\nhi : ∀ (a : ι), Membership.mem s a → Membership.mem t (i a)\nh : ∀ (a : ι), Membership.mem s a → Eq (f a) (g (i a))\ni_inj : Set.InjOn i ↑s\ni_surj : Set.SurjOn i ↑s ↑t\n⊢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- Reorder an average.\n\nThe difference with `Finset.expect_nbij'` is that the bijection is specified as a surjective\ninjection, rather than by an inverse function.\n\nThe difference with `Finset.expect_bij` is that the bijection is a non-dependent function, rather\nthan being allowed to use membership of the domain of the average. -/\nlemma expect_nbij (i : ι → κ) (hi : ∀ a ∈ s, i a ∈ t) (h : ∀ a ∈ s, f a = g (i a))\n    (i_inj : (s : Set ι).InjOn i) (i_surj : (s : Set ι).SurjOn i t) :\n    𝔼 i ∈ s, f i = 𝔼 i ∈ t, g i := by\n  simp_rw [expect, card_nbij i hi i_inj i_surj, sum_nbij i hi i_inj i_surj h]\n\n"}
{"name":"Finset.expect_nbij'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\nt : Finset κ\ng : κ → M\ni : ι → κ\nj : κ → ι\nhi : ∀ (a : ι), Membership.mem s a → Membership.mem t (i a)\nhj : ∀ (a : κ), Membership.mem t a → Membership.mem s (j a)\nleft_inv : ∀ (a : ι), Membership.mem s a → Eq (j (i a)) a\nright_inv : ∀ (a : κ), Membership.mem t a → Eq (i (j a)) a\nh : ∀ (a : ι), Membership.mem s a → Eq (f a) (g (i a))\n⊢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- Reorder an average.\n\nThe difference with `Finset.expect_nbij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.expect_bij'` is that the bijection and its inverse are non-dependent\nfunctions, rather than being allowed to use membership of the domains of the averages.\n\nThe difference with `Finset.expect_equiv` is that bijectivity is only required to hold on the\ndomains of the averages, rather than on the entire types. -/\nlemma expect_nbij' (i : ι → κ) (j : κ → ι) (hi : ∀ a ∈ s, i a ∈ t) (hj : ∀ a ∈ t, j a ∈ s)\n    (left_inv : ∀ a ∈ s, j (i a) = a) (right_inv : ∀ a ∈ t, i (j a) = a)\n    (h : ∀ a ∈ s, f a = g (i a)) : 𝔼 i ∈ s, f i = 𝔼 i ∈ t, g i := by\n  simp_rw [expect, card_nbij' i j hi hj left_inv right_inv,\n    sum_nbij' i j hi hj left_inv right_inv h]\n\n"}
{"name":"Finset.expect_equiv","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\nt : Finset κ\ng : κ → M\ne : Equiv ι κ\nhst : ∀ (i : ι), Iff (Membership.mem s i) (Membership.mem t (e i))\nhfg : ∀ (i : ι), Membership.mem s i → Eq (f i) (g (e i))\n⊢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- `Finset.expect_equiv` is a specialization of `Finset.expect_bij` that automatically fills in\nmost arguments. -/\nlemma expect_equiv (e : ι ≃ κ) (hst : ∀ i, i ∈ s ↔ e i ∈ t) (hfg : ∀ i ∈ s, f i = g (e i)) :\n    𝔼 i ∈ s, f i = 𝔼 i ∈ t, g i := by simp_rw [expect, card_equiv e hst, sum_equiv e hst hfg]\n\n"}
{"name":"Finset.expect_product","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nt : Finset κ\nf : Prod ι κ → M\n⊢ Eq ((SProd.sprod s t).expect fun x => f x) (s.expect fun i => t.expect fun j => f { fst := i, snd := j })","decl":"/-- Expectation over a product set equals the expectation of the fiberwise expectations.\n\nFor rewriting in the reverse direction, use `Finset.expect_product'`. -/\nlemma expect_product (s : Finset ι) (t : Finset κ) (f : ι × κ → M) :\n    𝔼 x ∈ s ×ˢ t, f x = 𝔼 i ∈ s, 𝔼 j ∈ t, f (i, j) := by\n  simp only [expect, card_product, sum_product, smul_sum, mul_inv, mul_smul, Nat.cast_mul]\n\n"}
{"name":"Finset.expect_product'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nt : Finset κ\nf : ι → κ → M\n⊢ Eq ((SProd.sprod s t).expect fun i => f i.1 i.2) (s.expect fun i => t.expect fun j => f i j)","decl":"/-- Expectation over a product set equals the expectation of the fiberwise expectations.\n\nFor rewriting in the reverse direction, use `Finset.expect_product`. -/\nlemma expect_product' (s : Finset ι) (t : Finset κ) (f : ι → κ → M) :\n    𝔼 i ∈ s ×ˢ t, f i.1 i.2 = 𝔼 i ∈ s, 𝔼 j ∈ t, f i j := by\n  simp only [expect, card_product, sum_product', smul_sum, mul_inv, mul_smul, Nat.cast_mul]\n\n"}
{"name":"Finset.expect_image","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\nf : ι → M\nt : Finset κ\ninst✝ : DecidableEq ι\nm : κ → ι\nhm : Set.InjOn m ↑t\n⊢ Eq ((Finset.image m t).expect fun i => f i) (t.expect fun i => f (m i))","decl":"@[simp]\nlemma expect_image [DecidableEq ι] {m : κ → ι} (hm : (t : Set κ).InjOn m) :\n    𝔼 i ∈ t.image m, f i = 𝔼 i ∈ t, f (m i) := by\n  simp_rw [expect, card_image_of_injOn hm, sum_image hm]\n\n"}
{"name":"Finset.expect_inv_index","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module NNRat M\ninst✝¹ : DecidableEq ι\ninst✝ : InvolutiveInv ι\ns : Finset ι\nf : ι → M\n⊢ Eq ((Inv.inv s).expect fun i => f i) (s.expect fun i => f (Inv.inv i))","decl":"@[simp] lemma expect_inv_index [DecidableEq ι] [InvolutiveInv ι] (s : Finset ι) (f : ι → M) :\n    𝔼 i ∈ s⁻¹, f i = 𝔼 i ∈ s, f i⁻¹ := expect_image inv_injective.injOn\n\n"}
{"name":"Finset.expect_neg_index","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module NNRat M\ninst✝¹ : DecidableEq ι\ninst✝ : InvolutiveNeg ι\ns : Finset ι\nf : ι → M\n⊢ Eq ((Neg.neg s).expect fun i => f i) (s.expect fun i => f (Neg.neg i))","decl":"@[simp] lemma expect_neg_index [DecidableEq ι] [InvolutiveNeg ι] (s : Finset ι) (f : ι → M) :\n    𝔼 i ∈ -s, f i = 𝔼 i ∈ s, f (-i) := expect_image neg_injective.injOn\n\n"}
{"name":"map_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module NNRat M\ninst✝³ : AddCommMonoid N\ninst✝² : Module NNRat N\nF : Type u_5\ninst✝¹ : FunLike F M N\ninst✝ : LinearMapClass F NNRat M N\ng : F\nf : ι → M\ns : Finset ι\n⊢ Eq (g (s.expect fun i => f i)) (s.expect fun i => g (f i))","decl":"lemma _root_.map_expect {F : Type*} [FunLike F M N] [LinearMapClass F ℚ≥0 M N]\n    (g : F) (f : ι → M) (s : Finset ι) :\n    g (𝔼 i ∈ s, f i) = 𝔼 i ∈ s, g (f i) := by simp only [expect, map_smul, map_natCast, map_sum]\n\n"}
{"name":"Finset.card_smul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\n⊢ Eq (HSMul.hSMul s.card (s.expect fun i => f i)) (s.sum fun i => f i)","decl":"@[simp]\nlemma card_smul_expect (s : Finset ι) (f : ι → M) : #s • 𝔼 i ∈ s, f i = ∑ i ∈ s, f i := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · simp\n  · rw [expect, ← Nat.cast_smul_eq_nsmul ℚ≥0, smul_inv_smul₀]\n    exact mod_cast hs.card_ne_zero\n\n"}
{"name":"Fintype.card_smul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ninst✝ : Fintype ι\nf : ι → M\n⊢ Eq (HSMul.hSMul (Fintype.card ι) (Finset.univ.expect fun i => f i)) (Finset.univ.sum fun i => f i)","decl":"@[simp] lemma _root_.Fintype.card_smul_expect [Fintype ι] (f : ι → M) :\n    Fintype.card ι • 𝔼 i, f i = ∑ i, f i := Finset.card_smul_expect _ _\n\n"}
{"name":"Finset.expect_const","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ns : Finset ι\nhs : s.Nonempty\na : M\n⊢ Eq (s.expect fun _i => a) a","decl":"@[simp] lemma expect_const (hs : s.Nonempty) (a : M) : 𝔼 _i ∈ s, a = a := by\n  rw [expect, sum_const, ← Nat.cast_smul_eq_nsmul ℚ≥0, inv_smul_smul₀]\n  exact mod_cast hs.card_ne_zero\n\n"}
{"name":"Finset.smul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module NNRat M\nG : Type u_5\ninst✝¹ : DistribSMul G M\ninst✝ : SMulCommClass G NNRat M\na : G\ns : Finset ι\nf : ι → M\n⊢ Eq (HSMul.hSMul a (s.expect fun i => f i)) (s.expect fun i => HSMul.hSMul a (f i))","decl":"lemma smul_expect {G : Type*} [DistribSMul G M] [SMulCommClass G ℚ≥0 M] (a : G)\n    (s : Finset ι) (f : ι → M) : a • 𝔼 i ∈ s, f i = 𝔼 i ∈ s, a • f i := by\n  simp only [expect, smul_sum, smul_comm]\n\n"}
{"name":"Finset.expect_sub_distrib","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module NNRat M\ns : Finset ι\nf g : ι → M\n⊢ Eq (s.expect fun i => HSub.hSub (f i) (g i)) (HSub.hSub (s.expect fun i => f i) (s.expect fun i => g i))","decl":"lemma expect_sub_distrib (s : Finset ι) (f g : ι → M) :\n    𝔼 i ∈ s, (f i - g i) = 𝔼 i ∈ s, f i - 𝔼 i ∈ s, g i := by\n  simp only [expect, sum_sub_distrib, smul_sub]\n\n"}
{"name":"Finset.expect_neg_distrib","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\n⊢ Eq (s.expect fun i => Neg.neg (f i)) (Neg.neg (s.expect fun i => f i))","decl":"@[simp]\nlemma expect_neg_distrib (s : Finset ι) (f : ι → M) : 𝔼 i ∈ s, -f i = -𝔼 i ∈ s, f i := by\n  simp [expect]\n\n"}
{"name":"Finset.card_mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : Semiring M\ninst✝ : Module NNRat M\ns : Finset ι\nf : ι → M\n⊢ Eq (HMul.hMul (↑s.card) (s.expect fun i => f i)) (s.sum fun i => f i)","decl":"@[simp] lemma card_mul_expect (s : Finset ι) (f : ι → M) :\n    #s * 𝔼 i ∈ s, f i = ∑ i ∈ s, f i := by rw [← nsmul_eq_mul, card_smul_expect]\n\n"}
{"name":"Fintype.card_mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : Semiring M\ninst✝¹ : Module NNRat M\ninst✝ : Fintype ι\nf : ι → M\n⊢ Eq (HMul.hMul (↑(Fintype.card ι)) (Finset.univ.expect fun i => f i)) (Finset.univ.sum fun i => f i)","decl":"@[simp] lemma _root_.Fintype.card_mul_expect [Fintype ι] (f : ι → M) :\n    Fintype.card ι * 𝔼 i, f i = ∑ i, f i := Finset.card_mul_expect _ _\n\n"}
{"name":"Finset.expect_mul","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : Semiring M\ninst✝¹ : Module NNRat M\ninst✝ : IsScalarTower NNRat M M\ns : Finset ι\nf : ι → M\na : M\n⊢ Eq (HMul.hMul (s.expect fun i => f i) a) (s.expect fun i => HMul.hMul (f i) a)","decl":"lemma expect_mul [IsScalarTower ℚ≥0 M M] (s : Finset ι) (f : ι → M) (a : M) :\n    (𝔼 i ∈ s, f i) * a = 𝔼 i ∈ s, f i * a := by rw [expect, expect, smul_mul_assoc, sum_mul]\n\n"}
{"name":"Finset.mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : Semiring M\ninst✝¹ : Module NNRat M\ninst✝ : SMulCommClass NNRat M M\ns : Finset ι\nf : ι → M\na : M\n⊢ Eq (HMul.hMul a (s.expect fun i => f i)) (s.expect fun i => HMul.hMul a (f i))","decl":"lemma mul_expect [SMulCommClass ℚ≥0 M M] (s : Finset ι) (f : ι → M) (a : M) :\n    a * 𝔼 i ∈ s, f i = 𝔼 i ∈ s, a * f i := by rw [expect, expect, mul_smul_comm, mul_sum]\n\n"}
{"name":"Finset.expect_mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝³ : Semiring M\ninst✝² : Module NNRat M\ninst✝¹ : IsScalarTower NNRat M M\ninst✝ : SMulCommClass NNRat M M\ns : Finset ι\nt : Finset κ\nf : ι → M\ng : κ → M\n⊢ Eq (HMul.hMul (s.expect fun i => f i) (t.expect fun j => g j)) (s.expect fun i => t.expect fun j => HMul.hMul (f i) (g j))","decl":"lemma expect_mul_expect [IsScalarTower ℚ≥0 M M] [SMulCommClass ℚ≥0 M M] (s : Finset ι)\n    (t : Finset κ) (f : ι → M) (g : κ → M) :\n    (𝔼 i ∈ s, f i) * 𝔼 j ∈ t, g j = 𝔼 i ∈ s, 𝔼 j ∈ t, f i * g j := by\n  simp_rw [expect_mul, mul_expect]\n\n"}
{"name":"Finset.expect_pow","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : CommSemiring M\ninst✝² : Module NNRat M\ninst✝¹ : IsScalarTower NNRat M M\ninst✝ : SMulCommClass NNRat M M\ns : Finset ι\nf : ι → M\nn : Nat\n⊢ Eq (HPow.hPow (s.expect fun i => f i) n) ((Fintype.piFinset fun x => s).expect fun p => Finset.univ.prod fun i => f (p i))","decl":"lemma expect_pow (s : Finset ι) (f : ι → M) (n : ℕ) :\n    (𝔼 i ∈ s, f i) ^ n = 𝔼 p ∈ Fintype.piFinset fun _ : Fin n ↦ s, ∏ i, f (p i) := by\n  classical\n  rw [expect, smul_pow, sum_pow', expect, Fintype.card_piFinset_const, inv_pow, Nat.cast_pow]\n\n"}
{"name":"Finset.expect_boole_mul","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁴ : Semifield M\ninst✝³ : CharZero M\ninst✝² : Fintype ι\ninst✝¹ : Nonempty ι\ninst✝ : DecidableEq ι\nf : ι → M\ni : ι\n⊢ Eq (Finset.univ.expect fun j => HMul.hMul (ite (Eq i j) (↑(Fintype.card ι)) 0) (f j)) (f i)","decl":"lemma expect_boole_mul [Fintype ι] [Nonempty ι] [DecidableEq ι] (f : ι → M) (i : ι) :\n    𝔼 j, ite (i = j) (Fintype.card ι : M) 0 * f j = f i := by\n  simp_rw [expect_univ, ite_mul, zero_mul, sum_ite_eq, if_pos (mem_univ _)]\n  rw [← @NNRat.cast_natCast M, ← NNRat.smul_def, inv_smul_smul₀]\n  simp [Fintype.card_ne_zero]\n\n"}
{"name":"Finset.expect_boole_mul'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁴ : Semifield M\ninst✝³ : CharZero M\ninst✝² : Fintype ι\ninst✝¹ : Nonempty ι\ninst✝ : DecidableEq ι\nf : ι → M\ni : ι\n⊢ Eq (Finset.univ.expect fun j => HMul.hMul (ite (Eq j i) (↑(Fintype.card ι)) 0) (f j)) (f i)","decl":"lemma expect_boole_mul' [Fintype ι] [Nonempty ι] [DecidableEq ι] (f : ι → M) (i : ι) :\n    𝔼 j, ite (j = i) (Fintype.card ι : M) 0 * f j = f i := by\n  simp_rw [@eq_comm _ _ i, expect_boole_mul]\n\n"}
{"name":"Finset.expect_eq_sum_div_card","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : Semifield M\ninst✝ : CharZero M\ns : Finset ι\nf : ι → M\n⊢ Eq (s.expect fun i => f i) (HDiv.hDiv (s.sum fun i => f i) ↑s.card)","decl":"lemma expect_eq_sum_div_card (s : Finset ι) (f : ι → M) :\n    𝔼 i ∈ s, f i = (∑ i ∈ s, f i) / #s := by\n  rw [expect, NNRat.smul_def, div_eq_inv_mul, NNRat.cast_inv, NNRat.cast_natCast]\n\n"}
{"name":"Fintype.expect_eq_sum_div_card","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : Semifield M\ninst✝¹ : CharZero M\ninst✝ : Fintype ι\nf : ι → M\n⊢ Eq (Finset.univ.expect fun i => f i) (HDiv.hDiv (Finset.univ.sum fun i => f i) ↑(Fintype.card ι))","decl":"lemma _root_.Fintype.expect_eq_sum_div_card [Fintype ι] (f : ι → M) :\n    𝔼 i, f i = (∑ i, f i) / Fintype.card ι := Finset.expect_eq_sum_div_card _ _\n\n"}
{"name":"Finset.expect_div","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝¹ : Semifield M\ninst✝ : CharZero M\ns : Finset ι\nf : ι → M\na : M\n⊢ Eq (HDiv.hDiv (s.expect fun i => f i) a) (s.expect fun i => HDiv.hDiv (f i) a)","decl":"lemma expect_div (s : Finset ι) (f : ι → M) (a : M) : (𝔼 i ∈ s, f i) / a = 𝔼 i ∈ s, f i / a := by\n  simp_rw [div_eq_mul_inv, expect_mul]\n\n"}
{"name":"Finset.expect_apply","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nα : Type u_5\nπ : α → Type u_6\ninst✝¹ : (a : α) → CommSemiring (π a)\ninst✝ : (a : α) → Module NNRat (π a)\ns : Finset ι\nf : ι → (a : α) → π a\na : α\n⊢ Eq (s.expect (fun i => f i) a) (s.expect fun i => f i a)","decl":"@[simp] lemma expect_apply {α : Type*} {π : α → Type*} [∀ a, CommSemiring (π a)]\n    [∀ a, Module ℚ≥0 (π a)] (s : Finset ι) (f : ι → ∀ a, π a) (a : α) :\n    (𝔼 i ∈ s, f i) a = 𝔼 i ∈ s, f i a := by simp [expect]\n\n"}
{"name":"algebraMap.coe_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁴ : Semifield M\ninst✝³ : CharZero M\ninst✝² : Semifield N\ninst✝¹ : CharZero N\ninst✝ : Algebra M N\ns : Finset ι\nf : ι → M\n⊢ Eq (↑(s.expect fun i => f i)) (s.expect fun i => ↑(f i))","decl":"@[simp, norm_cast]\nlemma coe_expect (s : Finset ι) (f : ι → M) : 𝔼 i ∈ s, f i = 𝔼 i ∈ s, (f i : N) :=\n  map_expect (algebraMap _ _) _ _\n\n"}
{"name":"Fintype.expect_bijective","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : Fintype κ\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ne : ι → κ\nhe : Function.Bijective e\nf : ι → M\ng : κ → M\nh : ∀ (i : ι), Eq (f i) (g (e i))\n⊢ Eq (Finset.univ.expect fun i => f i) (Finset.univ.expect fun i => g i)","decl":"/-- `Fintype.expect_bijective` is a variant of `Finset.expect_bij` that accepts\n`Function.Bijective`.\n\nSee `Function.Bijective.expect_comp` for a version without `h`. -/\nlemma expect_bijective (e : ι → κ) (he : Bijective e) (f : ι → M) (g : κ → M)\n    (h : ∀ i, f i = g (e i)) : 𝔼 i, f i = 𝔼 i, g i :=\n  expect_nbij e (fun _ _ ↦ mem_univ _) (fun i _ ↦ h i) he.injective.injOn <| by\n    simpa using he.surjective.surjOn _\n\n"}
{"name":"Fintype.expect_equiv","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : Fintype κ\ninst✝¹ : AddCommMonoid M\ninst✝ : Module NNRat M\ne : Equiv ι κ\nf : ι → M\ng : κ → M\nh : ∀ (i : ι), Eq (f i) (g (e i))\n⊢ Eq (Finset.univ.expect fun i => f i) (Finset.univ.expect fun i => g i)","decl":"/-- `Fintype.expect_equiv` is a specialization of `Finset.expect_bij` that automatically fills in\nmost arguments.\n\nSee `Equiv.expect_comp` for a version without `h`. -/\nlemma expect_equiv (e : ι ≃ κ) (f : ι → M) (g : κ → M) (h : ∀ i, f i = g (e i)) :\n    𝔼 i, f i = 𝔼 i, g i := expect_bijective _ e.bijective f g h\n\n"}
{"name":"Fintype.expect_const","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ninst✝ : Nonempty ι\na : M\n⊢ Eq (Finset.univ.expect fun _i => a) a","decl":"lemma expect_const [Nonempty ι] (a : M) : 𝔼 _i : ι, a = a := Finset.expect_const univ_nonempty _\n\n"}
{"name":"Fintype.expect_ite_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\np : ι → Prop\ninst✝ : DecidablePred p\nh : ∀ (i j : ι), p i → p j → Eq i j\na : M\n⊢ Eq (Finset.univ.expect fun i => ite (p i) a 0) (ite (Exists fun i => p i) (HSMul.hSMul (Inv.inv ↑(Fintype.card ι)) a) 0)","decl":"lemma expect_ite_zero (p : ι → Prop) [DecidablePred p] (h : ∀ i j, p i → p j → i = j) (a : M) :\n    𝔼 i, ite (p i) a 0 = ite (∃ i, p i) (a /ℚ Fintype.card ι) 0 := by\n  simp [univ.expect_ite_zero p (by simpa using h), card_univ]\n\n"}
{"name":"Fintype.expect_ite_mem","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ninst✝ : DecidableEq ι\ns : Finset ι\nf : ι → M\n⊢ Eq (Finset.univ.expect fun i => ite (Membership.mem s i) (f i) 0) (HSMul.hSMul s.dens (s.expect fun i => f i))","decl":"@[simp] lemma expect_ite_mem (s : Finset ι) (f : ι → M) :\n    𝔼 i, (if i ∈ s then f i else 0) = s.dens • 𝔼 i ∈ s, f i := by\n  simp [Finset.expect_ite_mem, dens]\n\n"}
{"name":"Fintype.expect_dite_eq","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ninst✝ : DecidableEq ι\ni : ι\nf : (j : ι) → Eq i j → M\n⊢ Eq (Finset.univ.expect fun j => dite (Eq i j) (fun h => f j h) fun h => 0) (HSMul.hSMul (Inv.inv ↑(Fintype.card ι)) (f i ⋯))","decl":"lemma expect_dite_eq (i : ι) (f : ∀ j, i = j → M) :\n    𝔼 j, (if h : i = j then f j h else 0) = f i rfl /ℚ card ι := by simp [card_univ]\n\n"}
{"name":"Fintype.expect_dite_eq'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ninst✝ : DecidableEq ι\ni : ι\nf : (j : ι) → Eq j i → M\n⊢ Eq (Finset.univ.expect fun j => dite (Eq j i) (fun h => f j h) fun h => 0) (HSMul.hSMul (Inv.inv ↑(Fintype.card ι)) (f i ⋯))","decl":"lemma expect_dite_eq' (i : ι) (f : ∀ j, j = i → M) :\n    𝔼 j, (if h : j = i then f j h else 0) = f i rfl /ℚ card ι := by simp [card_univ]\n\n"}
{"name":"Fintype.expect_ite_eq","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ninst✝ : DecidableEq ι\ni : ι\nf : ι → M\n⊢ Eq (Finset.univ.expect fun j => ite (Eq i j) (f j) 0) (HSMul.hSMul (Inv.inv ↑(Fintype.card ι)) (f i))","decl":"lemma expect_ite_eq (i : ι) (f : ι → M) :\n    𝔼 j, (if i = j then f j else 0) = f i /ℚ card ι := by simp [card_univ]\n\n"}
{"name":"Fintype.expect_ite_eq'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : AddCommMonoid M\ninst✝¹ : Module NNRat M\ninst✝ : DecidableEq ι\ni : ι\nf : ι → M\n⊢ Eq (Finset.univ.expect fun j => ite (Eq j i) (f j) 0) (HSMul.hSMul (Inv.inv ↑(Fintype.card ι)) (f i))","decl":"lemma expect_ite_eq' (i : ι) (f : ι → M) :\n    𝔼 j, (if j = i then f j else 0) = f i /ℚ card ι := by simp [card_univ]\n\n"}
{"name":"Fintype.expect_one","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Fintype ι\ninst✝² : Semiring M\ninst✝¹ : Module NNRat M\ninst✝ : Nonempty ι\n⊢ Eq (Finset.univ.expect fun _i => 1) 1","decl":"lemma expect_one [Nonempty ι] : 𝔼 _i : ι, (1 : M) = 1 := expect_const _\n\n"}
{"name":"Fintype.expect_mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝⁵ : Fintype ι\ninst✝⁴ : Fintype κ\ninst✝³ : Semiring M\ninst✝² : Module NNRat M\ninst✝¹ : IsScalarTower NNRat M M\ninst✝ : SMulCommClass NNRat M M\nf : ι → M\ng : κ → M\n⊢ Eq (HMul.hMul (Finset.univ.expect fun i => f i) (Finset.univ.expect fun j => g j)) (Finset.univ.expect fun i => Finset.univ.expect fun j => HMul.hMul (f i) (g j))","decl":"lemma expect_mul_expect [IsScalarTower ℚ≥0 M M] [SMulCommClass ℚ≥0 M M] (f : ι → M)\n    (g : κ → M) : (𝔼 i, f i) * 𝔼 j, g j = 𝔼 i, 𝔼 j, f i * g j :=\n  Finset.expect_mul_expect ..\n\n"}
