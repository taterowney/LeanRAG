{"name":"Finset.expect_univ","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\nf : Î¹ â†’ M\ninstâœ : Fintype Î¹\nâŠ¢ Eq (Finset.univ.expect fun i => f i) (HSMul.hSMul (Inv.inv â†‘(Fintype.card Î¹)) (Finset.univ.sum fun i => f i))","decl":"lemma expect_univ [Fintype Î¹] : ğ”¼ i, f i = (âˆ‘ i, f i) /â„š Fintype.card Î¹ := by\n  rw [expect, card_univ]\n\n"}
{"name":"Finset.expect_empty","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\nf : Î¹ â†’ M\nâŠ¢ Eq (EmptyCollection.emptyCollection.expect fun i => f i) 0","decl":"@[simp] lemma expect_empty (f : Î¹ â†’ M) : ğ”¼ i âˆˆ âˆ…, f i = 0 := by simp [expect]\n"}
{"name":"Finset.expect_singleton","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\nf : Î¹ â†’ M\ni : Î¹\nâŠ¢ Eq ((Singleton.singleton i).expect fun j => f j) (f i)","decl":"@[simp] lemma expect_singleton (f : Î¹ â†’ M) (i : Î¹) : ğ”¼ j âˆˆ {i}, f j = f i := by simp [expect]\n"}
{"name":"Finset.expect_const_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nâŠ¢ Eq (s.expect fun _i => 0) 0","decl":"@[simp] lemma expect_const_zero (s : Finset Î¹) : ğ”¼ _i âˆˆ s, (0 : M) = 0 := by simp [expect]\n\n"}
{"name":"Finset.expect_congr","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf g : Î¹ â†’ M\nt : Finset Î¹\nhst : Eq s t\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ Eq (f i) (g i)\nâŠ¢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"@[congr]\nlemma expect_congr {t : Finset Î¹} (hst : s = t) (h : âˆ€ i âˆˆ t, f i = g i) :\n    ğ”¼ i âˆˆ s, f i = ğ”¼ i âˆˆ t, g i := by rw [expect, expect, sum_congr hst h, hst]\n\n"}
{"name":"Finset.expectWith_congr","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module NNRat M\ns t : Finset Î¹\nf g : Î¹ â†’ M\np q : Î¹ â†’ Prop\ninstâœÂ¹ : DecidablePred p\ninstâœ : DecidablePred q\nhst : Eq s t\nhpq : âˆ€ (i : Î¹), Membership.mem t i â†’ Iff (p i) (q i)\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ q i â†’ Eq (f i) (g i)\nâŠ¢ Eq ((Finset.filter (fun i => p i) s).expect fun i => f i) ((Finset.filter (fun i => q i) t).expect fun i => g i)","decl":"lemma expectWith_congr (hst : s = t) (hpq : âˆ€ i âˆˆ t, p i â†” q i) (h : âˆ€ i âˆˆ t, q i â†’ f i = g i) :\n    ğ”¼ i âˆˆ s with p i, f i = ğ”¼ i âˆˆ t with q i, g i :=\n  expect_congr (by rw [hst, filter_inj'.2 hpq]) <| by simpa using h\n\n"}
{"name":"Finset.expect_sum_comm","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nt : Finset Îº\nf : Î¹ â†’ Îº â†’ M\nâŠ¢ Eq (s.expect fun i => t.sum fun j => f i j) (t.sum fun j => s.expect fun i => f i j)","decl":"lemma expect_sum_comm (s : Finset Î¹) (t : Finset Îº) (f : Î¹ â†’ Îº â†’ M) :\n    ğ”¼ i âˆˆ s, âˆ‘ j âˆˆ t, f i j = âˆ‘ j âˆˆ t, ğ”¼ i âˆˆ s, f i j := by\n  simpa only [expect, smul_sum] using sum_comm\n\n"}
{"name":"Finset.expect_comm","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nt : Finset Îº\nf : Î¹ â†’ Îº â†’ M\nâŠ¢ Eq (s.expect fun i => t.expect fun j => f i j) (t.expect fun j => s.expect fun i => f i j)","decl":"lemma expect_comm (s : Finset Î¹) (t : Finset Îº) (f : Î¹ â†’ Îº â†’ M) :\n    ğ”¼ i âˆˆ s, ğ”¼ j âˆˆ t, f i j = ğ”¼ j âˆˆ t, ğ”¼ i âˆˆ s, f i j := by\n  rw [expect, expect, â† expect_sum_comm, â† expect_sum_comm, expect, expect, smul_comm, sum_comm]\n\n"}
{"name":"Finset.expect_eq_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ Eq (f i) 0\nâŠ¢ Eq (s.expect fun i => f i) 0","decl":"lemma expect_eq_zero (h : âˆ€ i âˆˆ s, f i = 0) : ğ”¼ i âˆˆ s, f i = 0 :=\n  (expect_congr rfl h).trans s.expect_const_zero\n\n"}
{"name":"Finset.exists_ne_zero_of_expect_ne_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nh : Ne (s.expect fun i => f i) 0\nâŠ¢ Exists fun i => And (Membership.mem s i) (Ne (f i) 0)","decl":"lemma exists_ne_zero_of_expect_ne_zero (h : ğ”¼ i âˆˆ s, f i â‰  0) : âˆƒ i âˆˆ s, f i â‰  0 := by\n  contrapose! h; exact expect_eq_zero h\n\n"}
{"name":"Finset.expect_add_distrib","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf g : Î¹ â†’ M\nâŠ¢ Eq (s.expect fun i => HAdd.hAdd (f i) (g i)) (HAdd.hAdd (s.expect fun i => f i) (s.expect fun i => g i))","decl":"lemma expect_add_distrib (s : Finset Î¹) (f g : Î¹ â†’ M) :\n    ğ”¼ i âˆˆ s, (f i + g i) = ğ”¼ i âˆˆ s, f i + ğ”¼ i âˆˆ s, g i := by\n  simp [expect, sum_add_distrib]\n\n"}
{"name":"Finset.expect_add_expect_comm","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nfâ‚ fâ‚‚ gâ‚ gâ‚‚ : Î¹ â†’ M\nâŠ¢ Eq (HAdd.hAdd (s.expect fun i => HAdd.hAdd (fâ‚ i) (fâ‚‚ i)) (s.expect fun i => HAdd.hAdd (gâ‚ i) (gâ‚‚ i))) (HAdd.hAdd (s.expect fun i => HAdd.hAdd (fâ‚ i) (gâ‚ i)) (s.expect fun i => HAdd.hAdd (fâ‚‚ i) (gâ‚‚ i)))","decl":"lemma expect_add_expect_comm (fâ‚ fâ‚‚ gâ‚ gâ‚‚ : Î¹ â†’ M) :\n    ğ”¼ i âˆˆ s, (fâ‚ i + fâ‚‚ i) + ğ”¼ i âˆˆ s, (gâ‚ i + gâ‚‚ i) =\n      ğ”¼ i âˆˆ s, (fâ‚ i + gâ‚ i) + ğ”¼ i âˆˆ s, (fâ‚‚ i + gâ‚‚ i) := by\n  simp_rw [expect_add_distrib, add_add_add_comm]\n\n"}
{"name":"Finset.expect_eq_single_of_mem","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\ni : Î¹\nhi : Membership.mem s i\nh : âˆ€ (j : Î¹), Membership.mem s j â†’ Ne j i â†’ Eq (f j) 0\nâŠ¢ Eq (s.expect fun i => f i) (HSMul.hSMul (Inv.inv â†‘s.card) (f i))","decl":"lemma expect_eq_single_of_mem (i : Î¹) (hi : i âˆˆ s) (h : âˆ€ j âˆˆ s, j â‰  i â†’ f j = 0) :\n    ğ”¼ i âˆˆ s, f i = f i /â„š #s := by rw [expect, sum_eq_single_of_mem _ hi h]\n\n"}
{"name":"Finset.expect_ite_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ns : Finset Î¹\np : Î¹ â†’ Prop\ninstâœ : DecidablePred p\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ âˆ€ (j : Î¹), Membership.mem s j â†’ p i â†’ p j â†’ Eq i j\na : M\nâŠ¢ Eq (s.expect fun i => ite (p i) a 0) (ite (Exists fun i => And (Membership.mem s i) (p i)) (HSMul.hSMul (Inv.inv â†‘s.card) a) 0)","decl":"lemma expect_ite_zero (s : Finset Î¹) (p : Î¹ â†’ Prop) [DecidablePred p]\n    (h : âˆ€ i âˆˆ s, âˆ€ j âˆˆ s, p i â†’ p j â†’ i = j) (a : M) :\n    ğ”¼ i âˆˆ s, ite (p i) a 0 = ite (âˆƒ i âˆˆ s, p i) (a /â„š #s) 0 := by\n  split_ifs <;> simp [expect, sum_ite_zero _ _ h, *]\n\n"}
{"name":"Finset.expect_ite_mem","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ninstâœ : DecidableEq Î¹\ns t : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (s.expect fun i => ite (Membership.mem t i) (f i) 0) (HSMul.hSMul (HDiv.hDiv â†‘(Inter.inter s t).card â†‘s.card) ((Inter.inter s t).expect fun i => f i))","decl":"lemma expect_ite_mem (s t : Finset Î¹) (f : Î¹ â†’ M) :\n    ğ”¼ i âˆˆ s, (if i âˆˆ t then f i else 0) = (#(s âˆ© t) / #s : â„šâ‰¥0) â€¢ ğ”¼ i âˆˆ s âˆ© t, f i := by\n  obtain hst | hst := (s âˆ© t).eq_empty_or_nonempty\n  Â· simp [expect, hst]\n  Â· simp [expect, smul_smul, â† inv_mul_eq_div, hst.card_ne_zero]\n\n"}
{"name":"Finset.expect_dite_eq","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ns : Finset Î¹\ninstâœ : DecidableEq Î¹\ni : Î¹\nf : (j : Î¹) â†’ Eq i j â†’ M\nâŠ¢ Eq (s.expect fun j => dite (Eq i j) (fun h => f j h) fun h => 0) (ite (Membership.mem s i) (HSMul.hSMul (Inv.inv â†‘s.card) (f i â‹¯)) 0)","decl":"@[simp] lemma expect_dite_eq (i : Î¹) (f : âˆ€ j, i = j â†’ M) :\n    ğ”¼ j âˆˆ s, (if h : i = j then f j h else 0) = if i âˆˆ s then f i rfl /â„š #s else 0 := by\n  split_ifs <;> simp [expect, *]\n\n"}
{"name":"Finset.expect_dite_eq'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ns : Finset Î¹\ninstâœ : DecidableEq Î¹\ni : Î¹\nf : (j : Î¹) â†’ Eq j i â†’ M\nâŠ¢ Eq (s.expect fun j => dite (Eq j i) (fun h => f j h) fun h => 0) (ite (Membership.mem s i) (HSMul.hSMul (Inv.inv â†‘s.card) (f i â‹¯)) 0)","decl":"@[simp] lemma expect_dite_eq' (i : Î¹) (f : âˆ€ j, j = i â†’ M) :\n    ğ”¼ j âˆˆ s, (if h : j = i then f j h else 0) = if i âˆˆ s then f i rfl /â„š #s else 0 := by\n  split_ifs <;> simp [expect, *]\n\n"}
{"name":"Finset.expect_ite_eq","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ns : Finset Î¹\ninstâœ : DecidableEq Î¹\ni : Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (s.expect fun j => ite (Eq i j) (f j) 0) (ite (Membership.mem s i) (HSMul.hSMul (Inv.inv â†‘s.card) (f i)) 0)","decl":"@[simp] lemma expect_ite_eq (i : Î¹) (f : Î¹ â†’ M) :\n    ğ”¼ j âˆˆ s, (if i = j then f j else 0) = if i âˆˆ s then f i /â„š #s else 0 := by\n  split_ifs <;> simp [expect, *]\n\n"}
{"name":"Finset.expect_ite_eq'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ns : Finset Î¹\ninstâœ : DecidableEq Î¹\ni : Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (s.expect fun j => ite (Eq j i) (f j) 0) (ite (Membership.mem s i) (HSMul.hSMul (Inv.inv â†‘s.card) (f i)) 0)","decl":"@[simp] lemma expect_ite_eq' (i : Î¹) (f : Î¹ â†’ M) :\n    ğ”¼ j âˆˆ s, (if j = i then f j else 0) = if i âˆˆ s then f i /â„š #s else 0 := by\n  split_ifs <;> simp [expect, *]\n\n"}
{"name":"Finset.expect_bij","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nt : Finset Îº\ng : Îº â†’ M\ni : (a : Î¹) â†’ Membership.mem s a â†’ Îº\nhi : âˆ€ (a : Î¹) (ha : Membership.mem s a), Membership.mem t (i a ha)\nh : âˆ€ (a : Î¹) (ha : Membership.mem s a), Eq (f a) (g (i a ha))\ni_inj : âˆ€ (aâ‚ : Î¹) (haâ‚ : Membership.mem s aâ‚) (aâ‚‚ : Î¹) (haâ‚‚ : Membership.mem s aâ‚‚), Eq (i aâ‚ haâ‚) (i aâ‚‚ haâ‚‚) â†’ Eq aâ‚ aâ‚‚\ni_surj : âˆ€ (b : Îº), Membership.mem t b â†’ Exists fun a => Exists fun ha => Eq (i a ha) b\nâŠ¢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- Reorder an average.\n\nThe difference with `Finset.expect_bij'` is that the bijection is specified as a surjective\ninjection, rather than by an inverse function.\n\nThe difference with `Finset.expect_nbij` is that the bijection is allowed to use membership of the\ndomain of the average, rather than being a non-dependent function. -/\nlemma expect_bij (i : âˆ€ a âˆˆ s, Îº) (hi : âˆ€ a ha, i a ha âˆˆ t) (h : âˆ€ a ha, f a = g (i a ha))\n    (i_inj : âˆ€ aâ‚ haâ‚ aâ‚‚ haâ‚‚, i aâ‚ haâ‚ = i aâ‚‚ haâ‚‚ â†’ aâ‚ = aâ‚‚)\n    (i_surj : âˆ€ b âˆˆ t, âˆƒ a ha, i a ha = b) : ğ”¼ i âˆˆ s, f i = ğ”¼ i âˆˆ t, g i := by\n  simp_rw [expect, card_bij i hi i_inj i_surj, sum_bij i hi i_inj i_surj h]\n\n"}
{"name":"Finset.expect_bij'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nt : Finset Îº\ng : Îº â†’ M\ni : (a : Î¹) â†’ Membership.mem s a â†’ Îº\nj : (a : Îº) â†’ Membership.mem t a â†’ Î¹\nhi : âˆ€ (a : Î¹) (ha : Membership.mem s a), Membership.mem t (i a ha)\nhj : âˆ€ (a : Îº) (ha : Membership.mem t a), Membership.mem s (j a ha)\nleft_inv : âˆ€ (a : Î¹) (ha : Membership.mem s a), Eq (j (i a ha) â‹¯) a\nright_inv : âˆ€ (a : Îº) (ha : Membership.mem t a), Eq (i (j a ha) â‹¯) a\nh : âˆ€ (a : Î¹) (ha : Membership.mem s a), Eq (f a) (g (i a ha))\nâŠ¢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- Reorder an average.\n\nThe difference with `Finset.expect_bij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.expect_nbij'` is that the bijection and its inverse are allowed to use\nmembership of the domains of the averages, rather than being non-dependent functions. -/\nlemma expect_bij' (i : âˆ€ a âˆˆ s, Îº) (j : âˆ€ a âˆˆ t, Î¹) (hi : âˆ€ a ha, i a ha âˆˆ t)\n    (hj : âˆ€ a ha, j a ha âˆˆ s) (left_inv : âˆ€ a ha, j (i a ha) (hi a ha) = a)\n    (right_inv : âˆ€ a ha, i (j a ha) (hj a ha) = a) (h : âˆ€ a ha, f a = g (i a ha)) :\n    ğ”¼ i âˆˆ s, f i = ğ”¼ i âˆˆ t, g i := by\n  simp_rw [expect, card_bij' i j hi hj left_inv right_inv, sum_bij' i j hi hj left_inv right_inv h]\n\n"}
{"name":"Finset.expect_nbij","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nt : Finset Îº\ng : Îº â†’ M\ni : Î¹ â†’ Îº\nhi : âˆ€ (a : Î¹), Membership.mem s a â†’ Membership.mem t (i a)\nh : âˆ€ (a : Î¹), Membership.mem s a â†’ Eq (f a) (g (i a))\ni_inj : Set.InjOn i â†‘s\ni_surj : Set.SurjOn i â†‘s â†‘t\nâŠ¢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- Reorder an average.\n\nThe difference with `Finset.expect_nbij'` is that the bijection is specified as a surjective\ninjection, rather than by an inverse function.\n\nThe difference with `Finset.expect_bij` is that the bijection is a non-dependent function, rather\nthan being allowed to use membership of the domain of the average. -/\nlemma expect_nbij (i : Î¹ â†’ Îº) (hi : âˆ€ a âˆˆ s, i a âˆˆ t) (h : âˆ€ a âˆˆ s, f a = g (i a))\n    (i_inj : (s : Set Î¹).InjOn i) (i_surj : (s : Set Î¹).SurjOn i t) :\n    ğ”¼ i âˆˆ s, f i = ğ”¼ i âˆˆ t, g i := by\n  simp_rw [expect, card_nbij i hi i_inj i_surj, sum_nbij i hi i_inj i_surj h]\n\n"}
{"name":"Finset.expect_nbij'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nt : Finset Îº\ng : Îº â†’ M\ni : Î¹ â†’ Îº\nj : Îº â†’ Î¹\nhi : âˆ€ (a : Î¹), Membership.mem s a â†’ Membership.mem t (i a)\nhj : âˆ€ (a : Îº), Membership.mem t a â†’ Membership.mem s (j a)\nleft_inv : âˆ€ (a : Î¹), Membership.mem s a â†’ Eq (j (i a)) a\nright_inv : âˆ€ (a : Îº), Membership.mem t a â†’ Eq (i (j a)) a\nh : âˆ€ (a : Î¹), Membership.mem s a â†’ Eq (f a) (g (i a))\nâŠ¢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- Reorder an average.\n\nThe difference with `Finset.expect_nbij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.expect_bij'` is that the bijection and its inverse are non-dependent\nfunctions, rather than being allowed to use membership of the domains of the averages.\n\nThe difference with `Finset.expect_equiv` is that bijectivity is only required to hold on the\ndomains of the averages, rather than on the entire types. -/\nlemma expect_nbij' (i : Î¹ â†’ Îº) (j : Îº â†’ Î¹) (hi : âˆ€ a âˆˆ s, i a âˆˆ t) (hj : âˆ€ a âˆˆ t, j a âˆˆ s)\n    (left_inv : âˆ€ a âˆˆ s, j (i a) = a) (right_inv : âˆ€ a âˆˆ t, i (j a) = a)\n    (h : âˆ€ a âˆˆ s, f a = g (i a)) : ğ”¼ i âˆˆ s, f i = ğ”¼ i âˆˆ t, g i := by\n  simp_rw [expect, card_nbij' i j hi hj left_inv right_inv,\n    sum_nbij' i j hi hj left_inv right_inv h]\n\n"}
{"name":"Finset.expect_equiv","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nt : Finset Îº\ng : Îº â†’ M\ne : Equiv Î¹ Îº\nhst : âˆ€ (i : Î¹), Iff (Membership.mem s i) (Membership.mem t (e i))\nhfg : âˆ€ (i : Î¹), Membership.mem s i â†’ Eq (f i) (g (e i))\nâŠ¢ Eq (s.expect fun i => f i) (t.expect fun i => g i)","decl":"/-- `Finset.expect_equiv` is a specialization of `Finset.expect_bij` that automatically fills in\nmost arguments. -/\nlemma expect_equiv (e : Î¹ â‰ƒ Îº) (hst : âˆ€ i, i âˆˆ s â†” e i âˆˆ t) (hfg : âˆ€ i âˆˆ s, f i = g (e i)) :\n    ğ”¼ i âˆˆ s, f i = ğ”¼ i âˆˆ t, g i := by simp_rw [expect, card_equiv e hst, sum_equiv e hst hfg]\n\n"}
{"name":"Finset.expect_product","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nt : Finset Îº\nf : Prod Î¹ Îº â†’ M\nâŠ¢ Eq ((SProd.sprod s t).expect fun x => f x) (s.expect fun i => t.expect fun j => f { fst := i, snd := j })","decl":"/-- Expectation over a product set equals the expectation of the fiberwise expectations.\n\nFor rewriting in the reverse direction, use `Finset.expect_product'`. -/\nlemma expect_product (s : Finset Î¹) (t : Finset Îº) (f : Î¹ Ã— Îº â†’ M) :\n    ğ”¼ x âˆˆ s Ã—Ë¢ t, f x = ğ”¼ i âˆˆ s, ğ”¼ j âˆˆ t, f (i, j) := by\n  simp only [expect, card_product, sum_product, smul_sum, mul_inv, mul_smul, Nat.cast_mul]\n\n"}
{"name":"Finset.expect_product'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nt : Finset Îº\nf : Î¹ â†’ Îº â†’ M\nâŠ¢ Eq ((SProd.sprod s t).expect fun i => f i.1 i.2) (s.expect fun i => t.expect fun j => f i j)","decl":"/-- Expectation over a product set equals the expectation of the fiberwise expectations.\n\nFor rewriting in the reverse direction, use `Finset.expect_product`. -/\nlemma expect_product' (s : Finset Î¹) (t : Finset Îº) (f : Î¹ â†’ Îº â†’ M) :\n    ğ”¼ i âˆˆ s Ã—Ë¢ t, f i.1 i.2 = ğ”¼ i âˆˆ s, ğ”¼ j âˆˆ t, f i j := by\n  simp only [expect, card_product, sum_product', smul_sum, mul_inv, mul_smul, Nat.cast_mul]\n\n"}
{"name":"Finset.expect_image","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\nf : Î¹ â†’ M\nt : Finset Îº\ninstâœ : DecidableEq Î¹\nm : Îº â†’ Î¹\nhm : Set.InjOn m â†‘t\nâŠ¢ Eq ((Finset.image m t).expect fun i => f i) (t.expect fun i => f (m i))","decl":"@[simp]\nlemma expect_image [DecidableEq Î¹] {m : Îº â†’ Î¹} (hm : (t : Set Îº).InjOn m) :\n    ğ”¼ i âˆˆ t.image m, f i = ğ”¼ i âˆˆ t, f (m i) := by\n  simp_rw [expect, card_image_of_injOn hm, sum_image hm]\n\n"}
{"name":"Finset.expect_inv_index","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module NNRat M\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : InvolutiveInv Î¹\ns : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq ((Inv.inv s).expect fun i => f i) (s.expect fun i => f (Inv.inv i))","decl":"@[simp] lemma expect_inv_index [DecidableEq Î¹] [InvolutiveInv Î¹] (s : Finset Î¹) (f : Î¹ â†’ M) :\n    ğ”¼ i âˆˆ sâ»Â¹, f i = ğ”¼ i âˆˆ s, f iâ»Â¹ := expect_image inv_injective.injOn\n\n"}
{"name":"Finset.expect_neg_index","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module NNRat M\ninstâœÂ¹ : DecidableEq Î¹\ninstâœ : InvolutiveNeg Î¹\ns : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq ((Neg.neg s).expect fun i => f i) (s.expect fun i => f (Neg.neg i))","decl":"@[simp] lemma expect_neg_index [DecidableEq Î¹] [InvolutiveNeg Î¹] (s : Finset Î¹) (f : Î¹ â†’ M) :\n    ğ”¼ i âˆˆ -s, f i = ğ”¼ i âˆˆ s, f (-i) := expect_image neg_injective.injOn\n\n"}
{"name":"map_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nN : Type u_4\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : Module NNRat M\ninstâœÂ³ : AddCommMonoid N\ninstâœÂ² : Module NNRat N\nF : Type u_5\ninstâœÂ¹ : FunLike F M N\ninstâœ : LinearMapClass F NNRat M N\ng : F\nf : Î¹ â†’ M\ns : Finset Î¹\nâŠ¢ Eq (g (s.expect fun i => f i)) (s.expect fun i => g (f i))","decl":"lemma _root_.map_expect {F : Type*} [FunLike F M N] [LinearMapClass F â„šâ‰¥0 M N]\n    (g : F) (f : Î¹ â†’ M) (s : Finset Î¹) :\n    g (ğ”¼ i âˆˆ s, f i) = ğ”¼ i âˆˆ s, g (f i) := by simp only [expect, map_smul, map_natCast, map_sum]\n\n"}
{"name":"Finset.card_smul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (HSMul.hSMul s.card (s.expect fun i => f i)) (s.sum fun i => f i)","decl":"@[simp]\nlemma card_smul_expect (s : Finset Î¹) (f : Î¹ â†’ M) : #s â€¢ ğ”¼ i âˆˆ s, f i = âˆ‘ i âˆˆ s, f i := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  Â· simp\n  Â· rw [expect, â† Nat.cast_smul_eq_nsmul â„šâ‰¥0, smul_inv_smulâ‚€]\n    exact mod_cast hs.card_ne_zero\n\n"}
{"name":"Fintype.card_smul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ninstâœ : Fintype Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (HSMul.hSMul (Fintype.card Î¹) (Finset.univ.expect fun i => f i)) (Finset.univ.sum fun i => f i)","decl":"@[simp] lemma _root_.Fintype.card_smul_expect [Fintype Î¹] (f : Î¹ â†’ M) :\n    Fintype.card Î¹ â€¢ ğ”¼ i, f i = âˆ‘ i, f i := Finset.card_smul_expect _ _\n\n"}
{"name":"Finset.expect_const","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ns : Finset Î¹\nhs : s.Nonempty\na : M\nâŠ¢ Eq (s.expect fun _i => a) a","decl":"@[simp] lemma expect_const (hs : s.Nonempty) (a : M) : ğ”¼ _i âˆˆ s, a = a := by\n  rw [expect, sum_const, â† Nat.cast_smul_eq_nsmul â„šâ‰¥0, inv_smul_smulâ‚€]\n  exact mod_cast hs.card_ne_zero\n\n"}
{"name":"Finset.smul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module NNRat M\nG : Type u_5\ninstâœÂ¹ : DistribSMul G M\ninstâœ : SMulCommClass G NNRat M\na : G\ns : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (HSMul.hSMul a (s.expect fun i => f i)) (s.expect fun i => HSMul.hSMul a (f i))","decl":"lemma smul_expect {G : Type*} [DistribSMul G M] [SMulCommClass G â„šâ‰¥0 M] (a : G)\n    (s : Finset Î¹) (f : Î¹ â†’ M) : a â€¢ ğ”¼ i âˆˆ s, f i = ğ”¼ i âˆˆ s, a â€¢ f i := by\n  simp only [expect, smul_sum, smul_comm]\n\n"}
{"name":"Finset.expect_sub_distrib","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf g : Î¹ â†’ M\nâŠ¢ Eq (s.expect fun i => HSub.hSub (f i) (g i)) (HSub.hSub (s.expect fun i => f i) (s.expect fun i => g i))","decl":"lemma expect_sub_distrib (s : Finset Î¹) (f g : Î¹ â†’ M) :\n    ğ”¼ i âˆˆ s, (f i - g i) = ğ”¼ i âˆˆ s, f i - ğ”¼ i âˆˆ s, g i := by\n  simp only [expect, sum_sub_distrib, smul_sub]\n\n"}
{"name":"Finset.expect_neg_distrib","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (s.expect fun i => Neg.neg (f i)) (Neg.neg (s.expect fun i => f i))","decl":"@[simp]\nlemma expect_neg_distrib (s : Finset Î¹) (f : Î¹ â†’ M) : ğ”¼ i âˆˆ s, -f i = -ğ”¼ i âˆˆ s, f i := by\n  simp [expect]\n\n"}
{"name":"Finset.card_mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : Semiring M\ninstâœ : Module NNRat M\ns : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (HMul.hMul (â†‘s.card) (s.expect fun i => f i)) (s.sum fun i => f i)","decl":"@[simp] lemma card_mul_expect (s : Finset Î¹) (f : Î¹ â†’ M) :\n    #s * ğ”¼ i âˆˆ s, f i = âˆ‘ i âˆˆ s, f i := by rw [â† nsmul_eq_mul, card_smul_expect]\n\n"}
{"name":"Fintype.card_mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : Semiring M\ninstâœÂ¹ : Module NNRat M\ninstâœ : Fintype Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (HMul.hMul (â†‘(Fintype.card Î¹)) (Finset.univ.expect fun i => f i)) (Finset.univ.sum fun i => f i)","decl":"@[simp] lemma _root_.Fintype.card_mul_expect [Fintype Î¹] (f : Î¹ â†’ M) :\n    Fintype.card Î¹ * ğ”¼ i, f i = âˆ‘ i, f i := Finset.card_mul_expect _ _\n\n"}
{"name":"Finset.expect_mul","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : Semiring M\ninstâœÂ¹ : Module NNRat M\ninstâœ : IsScalarTower NNRat M M\ns : Finset Î¹\nf : Î¹ â†’ M\na : M\nâŠ¢ Eq (HMul.hMul (s.expect fun i => f i) a) (s.expect fun i => HMul.hMul (f i) a)","decl":"lemma expect_mul [IsScalarTower â„šâ‰¥0 M M] (s : Finset Î¹) (f : Î¹ â†’ M) (a : M) :\n    (ğ”¼ i âˆˆ s, f i) * a = ğ”¼ i âˆˆ s, f i * a := by rw [expect, expect, smul_mul_assoc, sum_mul]\n\n"}
{"name":"Finset.mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : Semiring M\ninstâœÂ¹ : Module NNRat M\ninstâœ : SMulCommClass NNRat M M\ns : Finset Î¹\nf : Î¹ â†’ M\na : M\nâŠ¢ Eq (HMul.hMul a (s.expect fun i => f i)) (s.expect fun i => HMul.hMul a (f i))","decl":"lemma mul_expect [SMulCommClass â„šâ‰¥0 M M] (s : Finset Î¹) (f : Î¹ â†’ M) (a : M) :\n    a * ğ”¼ i âˆˆ s, f i = ğ”¼ i âˆˆ s, a * f i := by rw [expect, expect, mul_smul_comm, mul_sum]\n\n"}
{"name":"Finset.expect_mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ³ : Semiring M\ninstâœÂ² : Module NNRat M\ninstâœÂ¹ : IsScalarTower NNRat M M\ninstâœ : SMulCommClass NNRat M M\ns : Finset Î¹\nt : Finset Îº\nf : Î¹ â†’ M\ng : Îº â†’ M\nâŠ¢ Eq (HMul.hMul (s.expect fun i => f i) (t.expect fun j => g j)) (s.expect fun i => t.expect fun j => HMul.hMul (f i) (g j))","decl":"lemma expect_mul_expect [IsScalarTower â„šâ‰¥0 M M] [SMulCommClass â„šâ‰¥0 M M] (s : Finset Î¹)\n    (t : Finset Îº) (f : Î¹ â†’ M) (g : Îº â†’ M) :\n    (ğ”¼ i âˆˆ s, f i) * ğ”¼ j âˆˆ t, g j = ğ”¼ i âˆˆ s, ğ”¼ j âˆˆ t, f i * g j := by\n  simp_rw [expect_mul, mul_expect]\n\n"}
{"name":"Finset.expect_pow","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : CommSemiring M\ninstâœÂ² : Module NNRat M\ninstâœÂ¹ : IsScalarTower NNRat M M\ninstâœ : SMulCommClass NNRat M M\ns : Finset Î¹\nf : Î¹ â†’ M\nn : Nat\nâŠ¢ Eq (HPow.hPow (s.expect fun i => f i) n) ((Fintype.piFinset fun x => s).expect fun p => Finset.univ.prod fun i => f (p i))","decl":"lemma expect_pow (s : Finset Î¹) (f : Î¹ â†’ M) (n : â„•) :\n    (ğ”¼ i âˆˆ s, f i) ^ n = ğ”¼ p âˆˆ Fintype.piFinset fun _ : Fin n â†¦ s, âˆ i, f (p i) := by\n  classical\n  rw [expect, smul_pow, sum_pow', expect, Fintype.card_piFinset_const, inv_pow, Nat.cast_pow]\n\n"}
{"name":"Finset.expect_boole_mul","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœâ´ : Semifield M\ninstâœÂ³ : CharZero M\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : DecidableEq Î¹\nf : Î¹ â†’ M\ni : Î¹\nâŠ¢ Eq (Finset.univ.expect fun j => HMul.hMul (ite (Eq i j) (â†‘(Fintype.card Î¹)) 0) (f j)) (f i)","decl":"lemma expect_boole_mul [Fintype Î¹] [Nonempty Î¹] [DecidableEq Î¹] (f : Î¹ â†’ M) (i : Î¹) :\n    ğ”¼ j, ite (i = j) (Fintype.card Î¹ : M) 0 * f j = f i := by\n  simp_rw [expect_univ, ite_mul, zero_mul, sum_ite_eq, if_pos (mem_univ _)]\n  rw [â† @NNRat.cast_natCast M, â† NNRat.smul_def, inv_smul_smulâ‚€]\n  simp [Fintype.card_ne_zero]\n\n"}
{"name":"Finset.expect_boole_mul'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœâ´ : Semifield M\ninstâœÂ³ : CharZero M\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : DecidableEq Î¹\nf : Î¹ â†’ M\ni : Î¹\nâŠ¢ Eq (Finset.univ.expect fun j => HMul.hMul (ite (Eq j i) (â†‘(Fintype.card Î¹)) 0) (f j)) (f i)","decl":"lemma expect_boole_mul' [Fintype Î¹] [Nonempty Î¹] [DecidableEq Î¹] (f : Î¹ â†’ M) (i : Î¹) :\n    ğ”¼ j, ite (j = i) (Fintype.card Î¹ : M) 0 * f j = f i := by\n  simp_rw [@eq_comm _ _ i, expect_boole_mul]\n\n"}
{"name":"Finset.expect_eq_sum_div_card","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : Semifield M\ninstâœ : CharZero M\ns : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (s.expect fun i => f i) (HDiv.hDiv (s.sum fun i => f i) â†‘s.card)","decl":"lemma expect_eq_sum_div_card (s : Finset Î¹) (f : Î¹ â†’ M) :\n    ğ”¼ i âˆˆ s, f i = (âˆ‘ i âˆˆ s, f i) / #s := by\n  rw [expect, NNRat.smul_def, div_eq_inv_mul, NNRat.cast_inv, NNRat.cast_natCast]\n\n"}
{"name":"Fintype.expect_eq_sum_div_card","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ² : Semifield M\ninstâœÂ¹ : CharZero M\ninstâœ : Fintype Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (Finset.univ.expect fun i => f i) (HDiv.hDiv (Finset.univ.sum fun i => f i) â†‘(Fintype.card Î¹))","decl":"lemma _root_.Fintype.expect_eq_sum_div_card [Fintype Î¹] (f : Î¹ â†’ M) :\n    ğ”¼ i, f i = (âˆ‘ i, f i) / Fintype.card Î¹ := Finset.expect_eq_sum_div_card _ _\n\n"}
{"name":"Finset.expect_div","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ¹ : Semifield M\ninstâœ : CharZero M\ns : Finset Î¹\nf : Î¹ â†’ M\na : M\nâŠ¢ Eq (HDiv.hDiv (s.expect fun i => f i) a) (s.expect fun i => HDiv.hDiv (f i) a)","decl":"lemma expect_div (s : Finset Î¹) (f : Î¹ â†’ M) (a : M) : (ğ”¼ i âˆˆ s, f i) / a = ğ”¼ i âˆˆ s, f i / a := by\n  simp_rw [div_eq_mul_inv, expect_mul]\n\n"}
{"name":"Finset.expect_apply","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_5\nÏ€ : Î± â†’ Type u_6\ninstâœÂ¹ : (a : Î±) â†’ CommSemiring (Ï€ a)\ninstâœ : (a : Î±) â†’ Module NNRat (Ï€ a)\ns : Finset Î¹\nf : Î¹ â†’ (a : Î±) â†’ Ï€ a\na : Î±\nâŠ¢ Eq (s.expect (fun i => f i) a) (s.expect fun i => f i a)","decl":"@[simp] lemma expect_apply {Î± : Type*} {Ï€ : Î± â†’ Type*} [âˆ€ a, CommSemiring (Ï€ a)]\n    [âˆ€ a, Module â„šâ‰¥0 (Ï€ a)] (s : Finset Î¹) (f : Î¹ â†’ âˆ€ a, Ï€ a) (a : Î±) :\n    (ğ”¼ i âˆˆ s, f i) a = ğ”¼ i âˆˆ s, f i a := by simp [expect]\n\n"}
{"name":"algebraMap.coe_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\nN : Type u_4\ninstâœâ´ : Semifield M\ninstâœÂ³ : CharZero M\ninstâœÂ² : Semifield N\ninstâœÂ¹ : CharZero N\ninstâœ : Algebra M N\ns : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (â†‘(s.expect fun i => f i)) (s.expect fun i => â†‘(f i))","decl":"@[simp, norm_cast]\nlemma coe_expect (s : Finset Î¹) (f : Î¹ â†’ M) : ğ”¼ i âˆˆ s, f i = ğ”¼ i âˆˆ s, (f i : N) :=\n  map_expect (algebraMap _ _) _ _\n\n"}
{"name":"Fintype.expect_bijective","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : Fintype Îº\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ne : Î¹ â†’ Îº\nhe : Function.Bijective e\nf : Î¹ â†’ M\ng : Îº â†’ M\nh : âˆ€ (i : Î¹), Eq (f i) (g (e i))\nâŠ¢ Eq (Finset.univ.expect fun i => f i) (Finset.univ.expect fun i => g i)","decl":"/-- `Fintype.expect_bijective` is a variant of `Finset.expect_bij` that accepts\n`Function.Bijective`.\n\nSee `Function.Bijective.expect_comp` for a version without `h`. -/\nlemma expect_bijective (e : Î¹ â†’ Îº) (he : Bijective e) (f : Î¹ â†’ M) (g : Îº â†’ M)\n    (h : âˆ€ i, f i = g (e i)) : ğ”¼ i, f i = ğ”¼ i, g i :=\n  expect_nbij e (fun _ _ â†¦ mem_univ _) (fun i _ â†¦ h i) he.injective.injOn <| by\n    simpa using he.surjective.surjOn _\n\n"}
{"name":"Fintype.expect_equiv","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : Fintype Îº\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module NNRat M\ne : Equiv Î¹ Îº\nf : Î¹ â†’ M\ng : Îº â†’ M\nh : âˆ€ (i : Î¹), Eq (f i) (g (e i))\nâŠ¢ Eq (Finset.univ.expect fun i => f i) (Finset.univ.expect fun i => g i)","decl":"/-- `Fintype.expect_equiv` is a specialization of `Finset.expect_bij` that automatically fills in\nmost arguments.\n\nSee `Equiv.expect_comp` for a version without `h`. -/\nlemma expect_equiv (e : Î¹ â‰ƒ Îº) (f : Î¹ â†’ M) (g : Îº â†’ M) (h : âˆ€ i, f i = g (e i)) :\n    ğ”¼ i, f i = ğ”¼ i, g i := expect_bijective _ e.bijective f g h\n\n"}
{"name":"Fintype.expect_const","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ninstâœ : Nonempty Î¹\na : M\nâŠ¢ Eq (Finset.univ.expect fun _i => a) a","decl":"lemma expect_const [Nonempty Î¹] (a : M) : ğ”¼ _i : Î¹, a = a := Finset.expect_const univ_nonempty _\n\n"}
{"name":"Fintype.expect_ite_zero","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\np : Î¹ â†’ Prop\ninstâœ : DecidablePred p\nh : âˆ€ (i j : Î¹), p i â†’ p j â†’ Eq i j\na : M\nâŠ¢ Eq (Finset.univ.expect fun i => ite (p i) a 0) (ite (Exists fun i => p i) (HSMul.hSMul (Inv.inv â†‘(Fintype.card Î¹)) a) 0)","decl":"lemma expect_ite_zero (p : Î¹ â†’ Prop) [DecidablePred p] (h : âˆ€ i j, p i â†’ p j â†’ i = j) (a : M) :\n    ğ”¼ i, ite (p i) a 0 = ite (âˆƒ i, p i) (a /â„š Fintype.card Î¹) 0 := by\n  simp [univ.expect_ite_zero p (by simpa using h), card_univ]\n\n"}
{"name":"Fintype.expect_ite_mem","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ninstâœ : DecidableEq Î¹\ns : Finset Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (Finset.univ.expect fun i => ite (Membership.mem s i) (f i) 0) (HSMul.hSMul s.dens (s.expect fun i => f i))","decl":"@[simp] lemma expect_ite_mem (s : Finset Î¹) (f : Î¹ â†’ M) :\n    ğ”¼ i, (if i âˆˆ s then f i else 0) = s.dens â€¢ ğ”¼ i âˆˆ s, f i := by\n  simp [Finset.expect_ite_mem, dens]\n\n"}
{"name":"Fintype.expect_dite_eq","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ninstâœ : DecidableEq Î¹\ni : Î¹\nf : (j : Î¹) â†’ Eq i j â†’ M\nâŠ¢ Eq (Finset.univ.expect fun j => dite (Eq i j) (fun h => f j h) fun h => 0) (HSMul.hSMul (Inv.inv â†‘(Fintype.card Î¹)) (f i â‹¯))","decl":"lemma expect_dite_eq (i : Î¹) (f : âˆ€ j, i = j â†’ M) :\n    ğ”¼ j, (if h : i = j then f j h else 0) = f i rfl /â„š card Î¹ := by simp [card_univ]\n\n"}
{"name":"Fintype.expect_dite_eq'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ninstâœ : DecidableEq Î¹\ni : Î¹\nf : (j : Î¹) â†’ Eq j i â†’ M\nâŠ¢ Eq (Finset.univ.expect fun j => dite (Eq j i) (fun h => f j h) fun h => 0) (HSMul.hSMul (Inv.inv â†‘(Fintype.card Î¹)) (f i â‹¯))","decl":"lemma expect_dite_eq' (i : Î¹) (f : âˆ€ j, j = i â†’ M) :\n    ğ”¼ j, (if h : j = i then f j h else 0) = f i rfl /â„š card Î¹ := by simp [card_univ]\n\n"}
{"name":"Fintype.expect_ite_eq","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ninstâœ : DecidableEq Î¹\ni : Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (Finset.univ.expect fun j => ite (Eq i j) (f j) 0) (HSMul.hSMul (Inv.inv â†‘(Fintype.card Î¹)) (f i))","decl":"lemma expect_ite_eq (i : Î¹) (f : Î¹ â†’ M) :\n    ğ”¼ j, (if i = j then f j else 0) = f i /â„š card Î¹ := by simp [card_univ]\n\n"}
{"name":"Fintype.expect_ite_eq'","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : Module NNRat M\ninstâœ : DecidableEq Î¹\ni : Î¹\nf : Î¹ â†’ M\nâŠ¢ Eq (Finset.univ.expect fun j => ite (Eq j i) (f j) 0) (HSMul.hSMul (Inv.inv â†‘(Fintype.card Î¹)) (f i))","decl":"lemma expect_ite_eq' (i : Î¹) (f : Î¹ â†’ M) :\n    ğ”¼ j, (if j = i then f j else 0) = f i /â„š card Î¹ := by simp [card_univ]\n\n"}
{"name":"Fintype.expect_one","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nM : Type u_3\ninstâœÂ³ : Fintype Î¹\ninstâœÂ² : Semiring M\ninstâœÂ¹ : Module NNRat M\ninstâœ : Nonempty Î¹\nâŠ¢ Eq (Finset.univ.expect fun _i => 1) 1","decl":"lemma expect_one [Nonempty Î¹] : ğ”¼ _i : Î¹, (1 : M) = 1 := expect_const _\n\n"}
{"name":"Fintype.expect_mul_expect","module":"Mathlib.Algebra.BigOperators.Expect","initialProofState":"Î¹ : Type u_1\nÎº : Type u_2\nM : Type u_3\ninstâœâµ : Fintype Î¹\ninstâœâ´ : Fintype Îº\ninstâœÂ³ : Semiring M\ninstâœÂ² : Module NNRat M\ninstâœÂ¹ : IsScalarTower NNRat M M\ninstâœ : SMulCommClass NNRat M M\nf : Î¹ â†’ M\ng : Îº â†’ M\nâŠ¢ Eq (HMul.hMul (Finset.univ.expect fun i => f i) (Finset.univ.expect fun j => g j)) (Finset.univ.expect fun i => Finset.univ.expect fun j => HMul.hMul (f i) (g j))","decl":"lemma expect_mul_expect [IsScalarTower â„šâ‰¥0 M M] [SMulCommClass â„šâ‰¥0 M M] (f : Î¹ â†’ M)\n    (g : Îº â†’ M) : (ğ”¼ i, f i) * ğ”¼ j, g j = ğ”¼ i, ğ”¼ j, f i * g j :=\n  Finset.expect_mul_expect ..\n\n"}
