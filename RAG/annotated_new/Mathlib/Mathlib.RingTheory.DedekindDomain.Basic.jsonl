{"name":"Ring.DimensionLEOne.maximalOfPrime","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nself : Ring.DimensionLEOne R\np : Ideal R\na✝¹ : Ne p Bot.bot\na✝ : p.IsPrime\n⊢ p.IsMaximal","decl":"/-- A ring `R` has Krull dimension at most one if all nonzero prime ideals are maximal. -/\nclass Ring.DimensionLEOne : Prop where\n  (maximalOfPrime : ∀ {p : Ideal R}, p ≠ ⊥ → p.IsPrime → p.IsMaximal)\n\n"}
{"name":"Ideal.IsPrime.isMaximal","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"R : Type u_4\ninst✝¹ : CommRing R\ninst✝ : Ring.DimensionLEOne R\np : Ideal R\nh : p.IsPrime\nhp : Ne p Bot.bot\n⊢ p.IsMaximal","decl":"theorem Ideal.IsPrime.isMaximal {R : Type*} [CommRing R] [DimensionLEOne R]\n    {p : Ideal R} (h : p.IsPrime) (hp : p ≠ ⊥) : p.IsMaximal :=\n  DimensionLEOne.maximalOfPrime hp h\n\n"}
{"name":"Ring.DimensionLEOne.principal_ideal_ring","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : IsPrincipalIdealRing A\n⊢ Ring.DimensionLEOne A","decl":"instance DimensionLEOne.principal_ideal_ring [IsDomain A] [IsPrincipalIdealRing A] :\n    DimensionLEOne A where\n  maximalOfPrime := fun nonzero _ =>\n    IsPrime.to_maximal_ideal nonzero\n\n"}
{"name":"Ring.DimensionLEOne.isIntegralClosure","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing A\nB : Type u_4\ninst✝⁸ : CommRing B\ninst✝⁷ : IsDomain B\ninst✝⁶ : Nontrivial R\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra B A\ninst✝² : IsScalarTower R B A\ninst✝¹ : IsIntegralClosure B R A\ninst✝ : Ring.DimensionLEOne R\n⊢ Ring.DimensionLEOne B","decl":"theorem DimensionLEOne.isIntegralClosure (B : Type*) [CommRing B] [IsDomain B] [Nontrivial R]\n    [Algebra R A] [Algebra R B] [Algebra B A] [IsScalarTower R B A] [IsIntegralClosure B R A]\n    [DimensionLEOne R] : DimensionLEOne B where\n  maximalOfPrime := fun {p} ne_bot _ =>\n    IsIntegralClosure.isMaximal_of_isMaximal_comap (R := R) A p\n      (Ideal.IsPrime.isMaximal inferInstance (IsIntegralClosure.comap_ne_bot A ne_bot))\n\n"}
{"name":"Ring.DimensionLEOne.integralClosure","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Nontrivial R\ninst✝² : IsDomain A\ninst✝¹ : Algebra R A\ninst✝ : Ring.DimensionLEOne R\n⊢ Ring.DimensionLEOne (Subtype fun x => Membership.mem (integralClosure R A) x)","decl":"nonrec instance DimensionLEOne.integralClosure [Nontrivial R] [IsDomain A] [Algebra R A]\n    [DimensionLEOne R] : DimensionLEOne (integralClosure R A) :=\n  DimensionLEOne.isIntegralClosure R A (integralClosure R A)\n\n"}
{"name":"Ring.DimensionLEOne.not_lt_lt","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Ring.DimensionLEOne R\np₀ p₁ p₂ : Ideal R\nhp₁ : p₁.IsPrime\nhp₂ : p₂.IsPrime\n⊢ Not (And (LT.lt p₀ p₁) (LT.lt p₁ p₂))","decl":"theorem DimensionLEOne.not_lt_lt [Ring.DimensionLEOne R] (p₀ p₁ p₂ : Ideal R) [hp₁ : p₁.IsPrime]\n    [hp₂ : p₂.IsPrime] : ¬(p₀ < p₁ ∧ p₁ < p₂)\n  | ⟨h01, h12⟩ => h12.ne ((hp₁.isMaximal (bot_le.trans_lt h01).ne').eq_of_le hp₂.ne_top h12.le)\n\n"}
{"name":"Ring.DimensionLEOne.eq_bot_of_lt","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : Ring.DimensionLEOne R\np P : Ideal R\ninst✝¹ : p.IsPrime\ninst✝ : P.IsPrime\nhpP : LT.lt p P\n⊢ Eq p Bot.bot","decl":"theorem DimensionLEOne.eq_bot_of_lt [Ring.DimensionLEOne R] (p P : Ideal R) [p.IsPrime]\n    [P.IsPrime] (hpP : p < P) : p = ⊥ :=\n  by_contra fun hp0 => not_lt_lt ⊥ p P ⟨Ne.bot_lt hp0, hpP⟩\n\n"}
{"name":"IsDedekindRing.toIsNoetherian","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝ : CommRing A\nself : IsDedekindRing A\n⊢ IsNoetherian A A","decl":"/-- A Dedekind ring is a commutative ring that is Noetherian, integrally closed, and\nhas Krull dimension at most one.\n\nThis is exactly `IsDedekindDomain` minus the `IsDomain` hypothesis.\n\nThe integral closure condition is independent of the choice of field of fractions:\nuse `isDedekindRing_iff` to prove `IsDedekindRing` for a given `fraction_map`.\n-/\nclass IsDedekindRing\n  extends IsNoetherian A A, DimensionLEOne A, IsIntegralClosure A A (FractionRing A) : Prop\n\n"}
{"name":"IsDedekindRing.toDimensionLEOne","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝ : CommRing A\nself : IsDedekindRing A\n⊢ Ring.DimensionLEOne A","decl":"/-- A Dedekind ring is a commutative ring that is Noetherian, integrally closed, and\nhas Krull dimension at most one.\n\nThis is exactly `IsDedekindDomain` minus the `IsDomain` hypothesis.\n\nThe integral closure condition is independent of the choice of field of fractions:\nuse `isDedekindRing_iff` to prove `IsDedekindRing` for a given `fraction_map`.\n-/\nclass IsDedekindRing\n  extends IsNoetherian A A, DimensionLEOne A, IsIntegralClosure A A (FractionRing A) : Prop\n\n"}
{"name":"IsDedekindRing.toIsIntegralClosure","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝ : CommRing A\nself : IsDedekindRing A\n⊢ IsIntegralClosure A A (FractionRing A)","decl":"/-- A Dedekind ring is a commutative ring that is Noetherian, integrally closed, and\nhas Krull dimension at most one.\n\nThis is exactly `IsDedekindDomain` minus the `IsDomain` hypothesis.\n\nThe integral closure condition is independent of the choice of field of fractions:\nuse `isDedekindRing_iff` to prove `IsDedekindRing` for a given `fraction_map`.\n-/\nclass IsDedekindRing\n  extends IsNoetherian A A, DimensionLEOne A, IsIntegralClosure A A (FractionRing A) : Prop\n\n"}
{"name":"isDedekindRing_iff","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝³ : CommRing A\nK : Type u_4\ninst✝² : CommRing K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ Iff (IsDedekindRing A) (And (IsNoetherianRing A) (And (Ring.DimensionLEOne A) (∀ {x : K}, IsIntegral A x → Exists fun y => Eq ((algebraMap A K) y) x)))","decl":"/-- An integral domain is a Dedekind domain if and only if it is\nNoetherian, has dimension ≤ 1, and is integrally closed in a given fraction field.\nIn particular, this definition does not depend on the choice of this fraction field. -/\ntheorem isDedekindRing_iff (K : Type*) [CommRing K] [Algebra A K] [IsFractionRing A K] :\n    IsDedekindRing A ↔\n      IsNoetherianRing A ∧ DimensionLEOne A ∧\n        ∀ {x : K}, IsIntegral A x → ∃ y, algebraMap A K y = x :=\n  ⟨fun _ => ⟨inferInstance, inferInstance,\n             fun {_} => (isIntegrallyClosed_iff K).mp inferInstance⟩,\n   fun ⟨hr, hd, hi⟩ => { hr, hd, (isIntegrallyClosed_iff K).mpr @hi with }⟩\n\n"}
{"name":"IsDedekindDomain.toIsDomain","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝ : CommRing A\nself : IsDedekindDomain A\n⊢ IsDomain A","decl":"/-- A Dedekind domain is an integral domain that is Noetherian, integrally closed, and\nhas Krull dimension at most one.\n\nThis is definition 3.2 of [Neukirch1992].\n\nThis is exactly `IsDedekindRing` plus the `IsDomain` hypothesis.\n\nThe integral closure condition is independent of the choice of field of fractions:\nuse `isDedekindDomain_iff` to prove `IsDedekindDomain` for a given `fraction_map`.\n\nThis is the default implementation, but there are equivalent definitions,\n`IsDedekindDomainDvr` and `IsDedekindDomainInv`.\n-/\nclass IsDedekindDomain\n  extends IsDomain A, IsDedekindRing A : Prop\n\n"}
{"name":"IsDedekindDomain.toIsDedekindRing","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝ : CommRing A\nself : IsDedekindDomain A\n⊢ IsDedekindRing A","decl":"/-- A Dedekind domain is an integral domain that is Noetherian, integrally closed, and\nhas Krull dimension at most one.\n\nThis is definition 3.2 of [Neukirch1992].\n\nThis is exactly `IsDedekindRing` plus the `IsDomain` hypothesis.\n\nThe integral closure condition is independent of the choice of field of fractions:\nuse `isDedekindDomain_iff` to prove `IsDedekindDomain` for a given `fraction_map`.\n\nThis is the default implementation, but there are equivalent definitions,\n`IsDedekindDomainDvr` and `IsDedekindDomainInv`.\n-/\nclass IsDedekindDomain\n  extends IsDomain A, IsDedekindRing A : Prop\n\n"}
{"name":"instIsDedekindDomainOfIsDomainOfIsDedekindRing","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : IsDedekindRing A\n⊢ IsDedekindDomain A","decl":"/-- Make a Dedekind domain from a Dedekind ring given that it is a domain.\n\n`IsDedekindRing` and `IsDedekindDomain` form a cycle in the typeclass hierarchy:\n`IsDedekindRing R + IsDomain R` imply `IsDedekindDomain R`, which implies `IsDedekindRing R`.\nThis should be safe since the start and end point is the literal same expression,\nwhich the tabled typeclass synthesis algorithm can deal with.\n-/\ninstance [IsDomain A] [IsDedekindRing A] : IsDedekindDomain A where\n\n"}
{"name":"isDedekindDomain_iff","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝³ : CommRing A\nK : Type u_4\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\n⊢ Iff (IsDedekindDomain A) (And (IsDomain A) (And (IsNoetherianRing A) (And (Ring.DimensionLEOne A) (∀ {x : K}, IsIntegral A x → Exists fun y => Eq ((algebraMap A K) y) x))))","decl":"/-- An integral domain is a Dedekind domain iff and only if it is\nNoetherian, has dimension ≤ 1, and is integrally closed in a given fraction field.\nIn particular, this definition does not depend on the choice of this fraction field. -/\ntheorem isDedekindDomain_iff (K : Type*) [Field K] [Algebra A K] [IsFractionRing A K] :\n    IsDedekindDomain A ↔\n      IsDomain A ∧ IsNoetherianRing A ∧ DimensionLEOne A ∧\n        ∀ {x : K}, IsIntegral A x → ∃ y, algebraMap A K y = x :=\n  ⟨fun _ => ⟨inferInstance, inferInstance, inferInstance,\n             fun {_} => (isIntegrallyClosed_iff K).mp inferInstance⟩,\n   fun ⟨hid, hr, hd, hi⟩ => { hid, hr, hd, (isIntegrallyClosed_iff K).mpr @hi with }⟩\n\n-- See library note [lower instance priority]\n"}
{"name":"IsPrincipalIdealRing.isDedekindDomain","module":"Mathlib.RingTheory.DedekindDomain.Basic","initialProofState":"A : Type u_2\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : IsPrincipalIdealRing A\n⊢ IsDedekindDomain A","decl":"instance (priority := 100) IsPrincipalIdealRing.isDedekindDomain\n    [IsDomain A] [IsPrincipalIdealRing A] :\n    IsDedekindDomain A :=\n  { PrincipalIdealRing.isNoetherianRing, Ring.DimensionLEOne.principal_ideal_ring A,\n    UniqueFactorizationMonoid.instIsIntegrallyClosed with }\n"}
