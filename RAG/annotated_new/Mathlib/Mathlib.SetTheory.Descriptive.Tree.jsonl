{"name":"Descriptive.mem_of_append","module":"Mathlib.SetTheory.Descriptive.Tree","initialProofState":"A : Type u_1\nT : Subtype fun x => Membership.mem (Descriptive.tree A) x\nx y : List A\nh : Membership.mem T (HAppend.hAppend x y)\n⊢ Membership.mem T x","decl":"lemma mem_of_append {x y : List A} (h : x ++ y ∈ T) : x ∈ T := by\n  induction' y with y ys ih generalizing x\n  · simpa using h\n  · exact T.prop (ih (by simpa))\n\n"}
{"name":"Descriptive.mem_of_prefix","module":"Mathlib.SetTheory.Descriptive.Tree","initialProofState":"A : Type u_1\nT : Subtype fun x => Membership.mem (Descriptive.tree A) x\nx y : List A\nh' : x.IsPrefix y\nh : Membership.mem T y\n⊢ Membership.mem T x","decl":"lemma mem_of_prefix {x y : List A} (h' : x <+: y) (h : y ∈ T) : x ∈ T := by\n  obtain ⟨_, rfl⟩ := h'; exact mem_of_append h\n\n"}
{"name":"Descriptive.tree_eq_bot","module":"Mathlib.SetTheory.Descriptive.Tree","initialProofState":"A : Type u_1\nT : Subtype fun x => Membership.mem (Descriptive.tree A) x\n⊢ Iff (Eq T Bot.bot) (Not (Membership.mem T List.nil))","decl":"@[simp] lemma tree_eq_bot : T = ⊥ ↔ [] ∉ T where\n  mp := by rintro rfl; simp\n  mpr h := by ext x; simpa using fun h' ↦ h <| mem_of_prefix x.nil_prefix h'\n\n"}
