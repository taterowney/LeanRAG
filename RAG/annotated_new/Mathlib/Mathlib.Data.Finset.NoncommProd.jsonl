{"name":"Multiset.noncommFoldr_coe","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β → β\nl : List α\ncomm : (setOf fun x => Membership.mem (↑l) x).Pairwise fun x y => ∀ (b : β), Eq (f x (f y b)) (f y (f x b))\nb : β\n⊢ Eq (Multiset.noncommFoldr f (↑l) comm b) (List.foldr f b l)","decl":"@[simp]\ntheorem noncommFoldr_coe (l : List α) (comm) (b : β) :\n    noncommFoldr f (l : Multiset α) comm b = l.foldr f b := by\n  simp only [noncommFoldr, coe_foldr, coe_attach, List.attach, List.attachWith, Function.comp_def]\n  rw [← List.foldr_map]\n  simp [List.map_pmap]\n\n"}
{"name":"Multiset.noncommFoldr_empty","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β → β\nh : (setOf fun x => Membership.mem 0 x).Pairwise fun x y => ∀ (b : β), Eq (f x (f y b)) (f y (f x b))\nb : β\n⊢ Eq (Multiset.noncommFoldr f 0 h b) b","decl":"@[simp]\ntheorem noncommFoldr_empty (h) (b : β) : noncommFoldr f (0 : Multiset α) h b = b :=\n  rfl\n\n"}
{"name":"Multiset.noncommFoldr_cons","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β → β\ns : Multiset α\na : α\nh : (setOf fun x => Membership.mem (Multiset.cons a s) x).Pairwise fun x y => ∀ (b : β), Eq (f x (f y b)) (f y (f x b))\nh' : (setOf fun x => Membership.mem s x).Pairwise fun x y => ∀ (b : β), Eq (f x (f y b)) (f y (f x b))\nb : β\n⊢ Eq (Multiset.noncommFoldr f (Multiset.cons a s) h b) (f a (Multiset.noncommFoldr f s h' b))","decl":"theorem noncommFoldr_cons (s : Multiset α) (a : α) (h h') (b : β) :\n    noncommFoldr f (a ::ₘ s) h b = f a (noncommFoldr f s h' b) := by\n  induction s using Quotient.inductionOn\n  simp\n\n"}
{"name":"Multiset.noncommFoldr_eq_foldr","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β → β\ns : Multiset α\nh : LeftCommutative f\nb : β\n⊢ Eq (Multiset.noncommFoldr f s ⋯ b) (Multiset.foldr f b s)","decl":"theorem noncommFoldr_eq_foldr (s : Multiset α) [h : LeftCommutative f] (b : β) :\n    noncommFoldr f s (fun x _ y _ _ => h.left_comm x y) b = foldr f b s := by\n  induction s using Quotient.inductionOn\n  simp\n\n"}
{"name":"Multiset.noncommFold_coe","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nop : α → α → α\nassoc : Std.Associative op\nl : List α\ncomm : (setOf fun x => Membership.mem (↑l) x).Pairwise fun x y => Eq (op x y) (op y x)\na : α\n⊢ Eq (Multiset.noncommFold op (↑l) comm a) (List.foldr op a l)","decl":"@[simp]\ntheorem noncommFold_coe (l : List α) (comm) (a : α) :\n    noncommFold op (l : Multiset α) comm a = l.foldr op a := by simp [noncommFold]\n\n"}
{"name":"Multiset.noncommFold_empty","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nop : α → α → α\nassoc : Std.Associative op\nh : (setOf fun x => Membership.mem 0 x).Pairwise fun x y => Eq (op x y) (op y x)\na : α\n⊢ Eq (Multiset.noncommFold op 0 h a) a","decl":"@[simp]\ntheorem noncommFold_empty (h) (a : α) : noncommFold op (0 : Multiset α) h a = a :=\n  rfl\n\n"}
{"name":"Multiset.noncommFold_cons","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nop : α → α → α\nassoc : Std.Associative op\ns : Multiset α\na : α\nh : (setOf fun x => Membership.mem (Multiset.cons a s) x).Pairwise fun x y => Eq (op x y) (op y x)\nh' : (setOf fun x => Membership.mem s x).Pairwise fun x y => Eq (op x y) (op y x)\nx : α\n⊢ Eq (Multiset.noncommFold op (Multiset.cons a s) h x) (op a (Multiset.noncommFold op s h' x))","decl":"theorem noncommFold_cons (s : Multiset α) (a : α) (h h') (x : α) :\n    noncommFold op (a ::ₘ s) h x = op a (noncommFold op s h' x) := by\n  induction s using Quotient.inductionOn\n  simp\n\n"}
{"name":"Multiset.noncommFold_eq_fold","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nop : α → α → α\nassoc : Std.Associative op\ns : Multiset α\ninst✝ : Std.Commutative op\na : α\n⊢ Eq (Multiset.noncommFold op s ⋯ a) (Multiset.fold op a s)","decl":"theorem noncommFold_eq_fold (s : Multiset α) [Std.Commutative op] (a : α) :\n    noncommFold op s (fun x _ y _ _ => Std.Commutative.comm x y) a = fold op a s := by\n  induction s using Quotient.inductionOn\n  simp\n\n"}
{"name":"Multiset.noncommProd_coe","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : Monoid α\nl : List α\ncomm : (setOf fun x => Membership.mem (↑l) x).Pairwise Commute\n⊢ Eq ((↑l).noncommProd comm) l.prod","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_coe (l : List α) (comm) : noncommProd (l : Multiset α) comm = l.prod := by\n  rw [noncommProd]\n  simp only [noncommFold_coe]\n  induction' l with hd tl hl\n  · simp\n  · rw [List.prod_cons, List.foldr, hl]\n    intro x hx y hy\n    exact comm (List.mem_cons_of_mem _ hx) (List.mem_cons_of_mem _ hy)\n\n"}
{"name":"Multiset.noncommSum_coe","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\nl : List α\ncomm : (setOf fun x => Membership.mem (↑l) x).Pairwise AddCommute\n⊢ Eq ((↑l).noncommSum comm) l.sum","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_coe (l : List α) (comm) : noncommProd (l : Multiset α) comm = l.prod := by\n  rw [noncommProd]\n  simp only [noncommFold_coe]\n  induction' l with hd tl hl\n  · simp\n  · rw [List.prod_cons, List.foldr, hl]\n    intro x hx y hy\n    exact comm (List.mem_cons_of_mem _ hx) (List.mem_cons_of_mem _ hy)\n\n"}
{"name":"Multiset.noncommProd_empty","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : Monoid α\nh : (setOf fun x => Membership.mem 0 x).Pairwise Commute\n⊢ Eq (Multiset.noncommProd 0 h) 1","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_empty (h) : noncommProd (0 : Multiset α) h = 1 :=\n  rfl\n\n"}
{"name":"Multiset.noncommSum_empty","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\nh : (setOf fun x => Membership.mem 0 x).Pairwise AddCommute\n⊢ Eq (Multiset.noncommSum 0 h) 0","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_empty (h) : noncommProd (0 : Multiset α) h = 1 :=\n  rfl\n\n"}
{"name":"Multiset.noncommSum_cons","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\ns : Multiset α\na : α\ncomm : (setOf fun x => Membership.mem (Multiset.cons a s) x).Pairwise AddCommute\n⊢ Eq ((Multiset.cons a s).noncommSum comm) (HAdd.hAdd a (s.noncommSum ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_cons (s : Multiset α) (a : α) (comm) :\n    noncommProd (a ::ₘ s) comm = a * noncommProd s (comm.mono fun _ => mem_cons_of_mem) := by\n  induction s using Quotient.inductionOn\n  simp\n\n"}
{"name":"Multiset.noncommProd_cons","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : Monoid α\ns : Multiset α\na : α\ncomm : (setOf fun x => Membership.mem (Multiset.cons a s) x).Pairwise Commute\n⊢ Eq ((Multiset.cons a s).noncommProd comm) (HMul.hMul a (s.noncommProd ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_cons (s : Multiset α) (a : α) (comm) :\n    noncommProd (a ::ₘ s) comm = a * noncommProd s (comm.mono fun _ => mem_cons_of_mem) := by\n  induction s using Quotient.inductionOn\n  simp\n\n"}
{"name":"Multiset.noncommSum_cons'","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\ns : Multiset α\na : α\ncomm : (setOf fun x => Membership.mem (Multiset.cons a s) x).Pairwise AddCommute\n⊢ Eq ((Multiset.cons a s).noncommSum comm) (HAdd.hAdd (s.noncommSum ⋯) a)","decl":"@[to_additive]\ntheorem noncommProd_cons' (s : Multiset α) (a : α) (comm) :\n    noncommProd (a ::ₘ s) comm = noncommProd s (comm.mono fun _ => mem_cons_of_mem) * a := by\n  induction' s using Quotient.inductionOn with s\n  simp only [quot_mk_to_coe, cons_coe, noncommProd_coe, List.prod_cons]\n  induction' s with hd tl IH\n  · simp\n  · rw [List.prod_cons, mul_assoc, ← IH, ← mul_assoc, ← mul_assoc]\n    · congr 1\n      apply comm.of_refl <;> simp\n    · intro x hx y hy\n      simp only [quot_mk_to_coe, List.mem_cons, mem_coe, cons_coe] at hx hy\n      apply comm\n      · cases hx <;> simp [*]\n      · cases hy <;> simp [*]\n\n"}
{"name":"Multiset.noncommProd_cons'","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : Monoid α\ns : Multiset α\na : α\ncomm : (setOf fun x => Membership.mem (Multiset.cons a s) x).Pairwise Commute\n⊢ Eq ((Multiset.cons a s).noncommProd comm) (HMul.hMul (s.noncommProd ⋯) a)","decl":"@[to_additive]\ntheorem noncommProd_cons' (s : Multiset α) (a : α) (comm) :\n    noncommProd (a ::ₘ s) comm = noncommProd s (comm.mono fun _ => mem_cons_of_mem) * a := by\n  induction' s using Quotient.inductionOn with s\n  simp only [quot_mk_to_coe, cons_coe, noncommProd_coe, List.prod_cons]\n  induction' s with hd tl IH\n  · simp\n  · rw [List.prod_cons, mul_assoc, ← IH, ← mul_assoc, ← mul_assoc]\n    · congr 1\n      apply comm.of_refl <;> simp\n    · intro x hx y hy\n      simp only [quot_mk_to_coe, List.mem_cons, mem_coe, cons_coe] at hx hy\n      apply comm\n      · cases hx <;> simp [*]\n      · cases hy <;> simp [*]\n\n"}
{"name":"Multiset.noncommProd_add","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : Monoid α\ns t : Multiset α\ncomm : (setOf fun x => Membership.mem (HAdd.hAdd s t) x).Pairwise Commute\n⊢ Eq ((HAdd.hAdd s t).noncommProd comm) (HMul.hMul (s.noncommProd ⋯) (t.noncommProd ⋯))","decl":"@[to_additive]\ntheorem noncommProd_add (s t : Multiset α) (comm) :\n    noncommProd (s + t) comm =\n      noncommProd s (comm.mono <| subset_of_le <| s.le_add_right t) *\n        noncommProd t (comm.mono <| subset_of_le <| t.le_add_left s) := by\n  rcases s with ⟨⟩\n  rcases t with ⟨⟩\n  simp\n\n"}
{"name":"Multiset.noncommSum_add","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\ns t : Multiset α\ncomm : (setOf fun x => Membership.mem (HAdd.hAdd s t) x).Pairwise AddCommute\n⊢ Eq ((HAdd.hAdd s t).noncommSum comm) (HAdd.hAdd (s.noncommSum ⋯) (t.noncommSum ⋯))","decl":"@[to_additive]\ntheorem noncommProd_add (s t : Multiset α) (comm) :\n    noncommProd (s + t) comm =\n      noncommProd s (comm.mono <| subset_of_le <| s.le_add_right t) *\n        noncommProd t (comm.mono <| subset_of_le <| t.le_add_left s) := by\n  rcases s with ⟨⟩\n  rcases t with ⟨⟩\n  simp\n\n"}
{"name":"Multiset.noncommProd_induction","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : Monoid α\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise Commute\np : α → Prop\nhom : ∀ (a b : α), p a → p b → p (HMul.hMul a b)\nunit : p 1\nbase : ∀ (x : α), Membership.mem s x → p x\n⊢ p (s.noncommProd comm)","decl":"@[to_additive]\nlemma noncommProd_induction (s : Multiset α) (comm)\n    (p : α → Prop) (hom : ∀ a b, p a → p b → p (a * b)) (unit : p 1) (base : ∀ x ∈ s, p x) :\n    p (s.noncommProd comm) := by\n  induction' s using Quotient.inductionOn with l\n  simp only [quot_mk_to_coe, noncommProd_coe, mem_coe] at base ⊢\n  exact l.prod_induction p hom unit base\n\n"}
{"name":"Multiset.noncommSum_induction","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise AddCommute\np : α → Prop\nhom : ∀ (a b : α), p a → p b → p (HAdd.hAdd a b)\nunit : p 0\nbase : ∀ (x : α), Membership.mem s x → p x\n⊢ p (s.noncommSum comm)","decl":"@[to_additive]\nlemma noncommProd_induction (s : Multiset α) (comm)\n    (p : α → Prop) (hom : ∀ a b, p a → p b → p (a * b)) (unit : p 1) (base : ∀ x ∈ s, p x) :\n    p (s.noncommProd comm) := by\n  induction' s using Quotient.inductionOn with l\n  simp only [quot_mk_to_coe, noncommProd_coe, mem_coe] at base ⊢\n  exact l.prod_induction p hom unit base\n\n"}
{"name":"Multiset.map_noncommSum_aux","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : AddMonoid α\ninst✝² : AddMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise AddCommute\nf : F\n⊢ (setOf fun x => Membership.mem (Multiset.map (⇑f) s) x).Pairwise AddCommute","decl":"@[to_additive]\nprotected theorem map_noncommProd_aux [MonoidHomClass F α β] (s : Multiset α)\n    (comm : { x | x ∈ s }.Pairwise Commute) (f : F) : { x | x ∈ s.map f }.Pairwise Commute := by\n  simp only [Multiset.mem_map]\n  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩ _\n  exact (comm.of_refl hx hy).map f\n\n"}
{"name":"Multiset.map_noncommProd_aux","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : Monoid α\ninst✝² : Monoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise Commute\nf : F\n⊢ (setOf fun x => Membership.mem (Multiset.map (⇑f) s) x).Pairwise Commute","decl":"@[to_additive]\nprotected theorem map_noncommProd_aux [MonoidHomClass F α β] (s : Multiset α)\n    (comm : { x | x ∈ s }.Pairwise Commute) (f : F) : { x | x ∈ s.map f }.Pairwise Commute := by\n  simp only [Multiset.mem_map]\n  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩ _\n  exact (comm.of_refl hx hy).map f\n\n"}
{"name":"Multiset.map_noncommSum","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : AddMonoid α\ninst✝² : AddMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise AddCommute\nf : F\n⊢ Eq (f (s.noncommSum comm)) ((Multiset.map (⇑f) s).noncommSum ⋯)","decl":"@[to_additive]\ntheorem map_noncommProd [MonoidHomClass F α β] (s : Multiset α) (comm) (f : F) :\n    f (s.noncommProd comm) = (s.map f).noncommProd (Multiset.map_noncommProd_aux s comm f) := by\n  induction s using Quotient.inductionOn\n  simpa using map_list_prod f _\n\n"}
{"name":"Multiset.map_noncommProd","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : Monoid α\ninst✝² : Monoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise Commute\nf : F\n⊢ Eq (f (s.noncommProd comm)) ((Multiset.map (⇑f) s).noncommProd ⋯)","decl":"@[to_additive]\ntheorem map_noncommProd [MonoidHomClass F α β] (s : Multiset α) (comm) (f : F) :\n    f (s.noncommProd comm) = (s.map f).noncommProd (Multiset.map_noncommProd_aux s comm f) := by\n  induction s using Quotient.inductionOn\n  simpa using map_list_prod f _\n\n"}
{"name":"Multiset.noncommProd_eq_pow_card","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : Monoid α\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise Commute\nm : α\nh : ∀ (x : α), Membership.mem s x → Eq x m\n⊢ Eq (s.noncommProd comm) (HPow.hPow m s.card)","decl":"@[to_additive noncommSum_eq_card_nsmul]\ntheorem noncommProd_eq_pow_card (s : Multiset α) (comm) (m : α) (h : ∀ x ∈ s, x = m) :\n    s.noncommProd comm = m ^ Multiset.card s := by\n  induction s using Quotient.inductionOn\n  simp only [quot_mk_to_coe, noncommProd_coe, coe_card, mem_coe] at *\n  exact List.prod_eq_pow_card _ m h\n\n"}
{"name":"Multiset.noncommSum_eq_card_nsmul","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise AddCommute\nm : α\nh : ∀ (x : α), Membership.mem s x → Eq x m\n⊢ Eq (s.noncommSum comm) (HSMul.hSMul s.card m)","decl":"@[to_additive noncommSum_eq_card_nsmul]\ntheorem noncommProd_eq_pow_card (s : Multiset α) (comm) (m : α) (h : ∀ x ∈ s, x = m) :\n    s.noncommProd comm = m ^ Multiset.card s := by\n  induction s using Quotient.inductionOn\n  simp only [quot_mk_to_coe, noncommProd_coe, coe_card, mem_coe] at *\n  exact List.prod_eq_pow_card _ m h\n\n"}
{"name":"Multiset.noncommProd_eq_prod","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_6\ninst✝ : CommMonoid α\ns : Multiset α\n⊢ Eq (s.noncommProd ⋯) s.prod","decl":"@[to_additive]\ntheorem noncommProd_eq_prod {α : Type*} [CommMonoid α] (s : Multiset α) :\n    (noncommProd s fun _ _ _ _ _ => Commute.all _ _) = prod s := by\n  induction s using Quotient.inductionOn\n  simp\n\n"}
{"name":"Multiset.noncommSum_eq_sum","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_6\ninst✝ : AddCommMonoid α\ns : Multiset α\n⊢ Eq (s.noncommSum ⋯) s.sum","decl":"@[to_additive]\ntheorem noncommProd_eq_prod {α : Type*} [CommMonoid α] (s : Multiset α) :\n    (noncommProd s fun _ _ _ _ _ => Commute.all _ _) = prod s := by\n  induction s using Quotient.inductionOn\n  simp\n\n"}
{"name":"Multiset.noncommProd_commute","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : Monoid α\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise Commute\ny : α\nh : ∀ (x : α), Membership.mem s x → Commute y x\n⊢ Commute y (s.noncommProd comm)","decl":"@[to_additive]\ntheorem noncommProd_commute (s : Multiset α) (comm) (y : α) (h : ∀ x ∈ s, Commute y x) :\n    Commute y (s.noncommProd comm) := by\n  induction s using Quotient.inductionOn\n  simp only [quot_mk_to_coe, noncommProd_coe]\n  exact Commute.list_prod_right _ _ h\n\n"}
{"name":"Multiset.noncommSum_addCommute","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\ns : Multiset α\ncomm : (setOf fun x => Membership.mem s x).Pairwise AddCommute\ny : α\nh : ∀ (x : α), Membership.mem s x → AddCommute y x\n⊢ AddCommute y (s.noncommSum comm)","decl":"@[to_additive]\ntheorem noncommProd_commute (s : Multiset α) (comm) (y : α) (h : ∀ x ∈ s, Commute y x) :\n    Commute y (s.noncommProd comm) := by\n  induction s using Quotient.inductionOn\n  simp only [quot_mk_to_coe, noncommProd_coe]\n  exact Commute.list_prod_right _ _ h\n\n"}
{"name":"Multiset.mul_noncommProd_erase","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝¹ : Monoid α\ninst✝ : DecidableEq α\ns : Multiset α\na : α\nh : Membership.mem s a\ncomm : (setOf fun x => Membership.mem s x).Pairwise Commute\ncomm' : optParam (∀ (x : α), Membership.mem (setOf fun x => Membership.mem (s.erase a) x) x → ∀ (x_1 : α), Membership.mem (setOf fun x => Membership.mem (s.erase a) x) x_1 → Ne x x_1 → Commute x x_1) ⋯\n⊢ Eq (HMul.hMul a ((s.erase a).noncommProd comm')) (s.noncommProd comm)","decl":"theorem mul_noncommProd_erase [DecidableEq α] (s : Multiset α) {a : α} (h : a ∈ s) (comm)\n    (comm' := fun _ hx _ hy hxy ↦ comm (s.mem_of_mem_erase hx) (s.mem_of_mem_erase hy) hxy) :\n    a * (s.erase a).noncommProd comm' = s.noncommProd comm := by\n  induction' s using Quotient.inductionOn with l\n  simp only [quot_mk_to_coe, mem_coe, coe_erase, noncommProd_coe] at comm h ⊢\n  suffices ∀ x ∈ l, ∀ y ∈ l, x * y = y * x by rw [List.prod_erase_of_comm h this]\n  intro x hx y hy\n  rcases eq_or_ne x y with rfl | hxy\n  · rfl\n  exact comm hx hy hxy\n\n"}
{"name":"Multiset.noncommProd_erase_mul","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\ninst✝¹ : Monoid α\ninst✝ : DecidableEq α\ns : Multiset α\na : α\nh : Membership.mem s a\ncomm : (setOf fun x => Membership.mem s x).Pairwise Commute\ncomm' : optParam (∀ (x : α), Membership.mem (setOf fun x => Membership.mem (s.erase a) x) x → ∀ (x_1 : α), Membership.mem (setOf fun x => Membership.mem (s.erase a) x) x_1 → Ne x x_1 → Commute x x_1) ⋯\n⊢ Eq (HMul.hMul ((s.erase a).noncommProd comm') a) (s.noncommProd comm)","decl":"theorem noncommProd_erase_mul [DecidableEq α] (s : Multiset α) {a : α} (h : a ∈ s) (comm)\n    (comm' := fun _ hx _ hy hxy ↦ comm (s.mem_of_mem_erase hx) (s.mem_of_mem_erase hy) hxy) :\n    (s.erase a).noncommProd comm' * a = s.noncommProd comm := by\n  suffices ∀ b ∈ erase s a, Commute a b by\n    rw [← (noncommProd_commute (s.erase a) comm' a this).eq, mul_noncommProd_erase s h comm comm']\n  intro b hb\n  rcases eq_or_ne a b with rfl | hab\n  · rfl\n  exact comm h (mem_of_mem_erase hb) hab\n\n"}
{"name":"Finset.noncommSum_lemma","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun AddCommute f)\n⊢ (setOf fun x => Membership.mem (Multiset.map f s.val) x).Pairwise AddCommute","decl":"/-- Proof used in definition of `Finset.noncommProd` -/\n@[to_additive]\ntheorem noncommProd_lemma (s : Finset α) (f : α → β)\n    (comm : (s : Set α).Pairwise (Commute on f)) :\n    Set.Pairwise { x | x ∈ Multiset.map f s.val } Commute := by\n  simp_rw [Multiset.mem_map]\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ _\n  exact comm.of_refl ha hb\n\n"}
{"name":"Finset.noncommProd_lemma","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun Commute f)\n⊢ (setOf fun x => Membership.mem (Multiset.map f s.val) x).Pairwise Commute","decl":"/-- Proof used in definition of `Finset.noncommProd` -/\n@[to_additive]\ntheorem noncommProd_lemma (s : Finset α) (f : α → β)\n    (comm : (s : Set α).Pairwise (Commute on f)) :\n    Set.Pairwise { x | x ∈ Multiset.map f s.val } Commute := by\n  simp_rw [Multiset.mem_map]\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ _\n  exact comm.of_refl ha hb\n\n"}
{"name":"Finset.noncommProd_induction","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun Commute f)\np : β → Prop\nhom : ∀ (a b : β), p a → p b → p (HMul.hMul a b)\nunit : p 1\nbase : ∀ (x : α), Membership.mem s x → p (f x)\n⊢ p (s.noncommProd f comm)","decl":"@[to_additive]\nlemma noncommProd_induction (s : Finset α) (f : α → β) (comm)\n    (p : β → Prop) (hom : ∀ a b, p a → p b → p (a * b)) (unit : p 1) (base : ∀ x ∈ s, p (f x)) :\n    p (s.noncommProd f comm) := by\n  refine Multiset.noncommProd_induction _ _ _ hom unit fun b hb ↦ ?_\n  obtain (⟨a, ha : a ∈ s, rfl : f a = b⟩) := by simpa using hb\n  exact base a ha\n\n"}
{"name":"Finset.noncommSum_induction","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun AddCommute f)\np : β → Prop\nhom : ∀ (a b : β), p a → p b → p (HAdd.hAdd a b)\nunit : p 0\nbase : ∀ (x : α), Membership.mem s x → p (f x)\n⊢ p (s.noncommSum f comm)","decl":"@[to_additive]\nlemma noncommProd_induction (s : Finset α) (f : α → β) (comm)\n    (p : β → Prop) (hom : ∀ a b, p a → p b → p (a * b)) (unit : p 1) (base : ∀ x ∈ s, p (f x)) :\n    p (s.noncommProd f comm) := by\n  refine Multiset.noncommProd_induction _ _ _ hom unit fun b hb ↦ ?_\n  obtain (⟨a, ha : a ∈ s, rfl : f a = b⟩) := by simpa using hb\n  exact base a ha\n\n"}
{"name":"Finset.noncommProd_congr","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\ns₁ s₂ : Finset α\nf g : α → β\nh₁ : Eq s₁ s₂\nh₂ : ∀ (x : α), Membership.mem s₂ x → Eq (f x) (g x)\ncomm : (↑s₁).Pairwise (Function.onFun Commute f)\n⊢ Eq (s₁.noncommProd f comm) (s₂.noncommProd g ⋯)","decl":"@[to_additive (attr := congr)]\ntheorem noncommProd_congr {s₁ s₂ : Finset α} {f g : α → β} (h₁ : s₁ = s₂)\n    (h₂ : ∀ x ∈ s₂, f x = g x) (comm) :\n    noncommProd s₁ f comm =\n      noncommProd s₂ g fun x hx y hy h => by\n        dsimp only [Function.onFun]\n        rw [← h₂ _ hx, ← h₂ _ hy]\n        subst h₁\n        exact comm hx hy h := by\n  simp_rw [noncommProd, Multiset.map_congr (congr_arg _ h₁) h₂]\n\n"}
{"name":"Finset.noncommSum_congr","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\ns₁ s₂ : Finset α\nf g : α → β\nh₁ : Eq s₁ s₂\nh₂ : ∀ (x : α), Membership.mem s₂ x → Eq (f x) (g x)\ncomm : (↑s₁).Pairwise (Function.onFun AddCommute f)\n⊢ Eq (s₁.noncommSum f comm) (s₂.noncommSum g ⋯)","decl":"@[to_additive (attr := congr)]\ntheorem noncommProd_congr {s₁ s₂ : Finset α} {f g : α → β} (h₁ : s₁ = s₂)\n    (h₂ : ∀ x ∈ s₂, f x = g x) (comm) :\n    noncommProd s₁ f comm =\n      noncommProd s₂ g fun x hx y hy h => by\n        dsimp only [Function.onFun]\n        rw [← h₂ _ hx, ← h₂ _ hy]\n        subst h₁\n        exact comm hx hy h := by\n  simp_rw [noncommProd, Multiset.map_congr (congr_arg _ h₁) h₂]\n\n"}
{"name":"Finset.noncommSum_toFinset","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddMonoid β\ninst✝ : DecidableEq α\nl : List α\nf : α → β\ncomm : (↑l.toFinset).Pairwise (Function.onFun AddCommute f)\nhl : l.Nodup\n⊢ Eq (l.toFinset.noncommSum f comm) (List.map f l).sum","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_toFinset [DecidableEq α] (l : List α) (f : α → β) (comm) (hl : l.Nodup) :\n    noncommProd l.toFinset f comm = (l.map f).prod := by\n  rw [← List.dedup_eq_self] at hl\n  simp [noncommProd, hl]\n\n"}
{"name":"Finset.noncommProd_toFinset","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Monoid β\ninst✝ : DecidableEq α\nl : List α\nf : α → β\ncomm : (↑l.toFinset).Pairwise (Function.onFun Commute f)\nhl : l.Nodup\n⊢ Eq (l.toFinset.noncommProd f comm) (List.map f l).prod","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_toFinset [DecidableEq α] (l : List α) (f : α → β) (comm) (hl : l.Nodup) :\n    noncommProd l.toFinset f comm = (l.map f).prod := by\n  rw [← List.dedup_eq_self] at hl\n  simp [noncommProd, hl]\n\n"}
{"name":"Finset.noncommProd_empty","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\nf : α → β\nh : (↑EmptyCollection.emptyCollection).Pairwise (Function.onFun Commute f)\n⊢ Eq (EmptyCollection.emptyCollection.noncommProd f h) 1","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_empty (f : α → β) (h) : noncommProd (∅ : Finset α) f h = 1 :=\n  rfl\n\n"}
{"name":"Finset.noncommSum_empty","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\nf : α → β\nh : (↑EmptyCollection.emptyCollection).Pairwise (Function.onFun AddCommute f)\n⊢ Eq (EmptyCollection.emptyCollection.noncommSum f h) 0","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_empty (f : α → β) (h) : noncommProd (∅ : Finset α) f h = 1 :=\n  rfl\n\n"}
{"name":"Finset.noncommSum_cons","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\ns : Finset α\na : α\nf : α → β\nha : Not (Membership.mem s a)\ncomm : (↑(Finset.cons a s ha)).Pairwise (Function.onFun AddCommute f)\n⊢ Eq ((Finset.cons a s ha).noncommSum f comm) (HAdd.hAdd (f a) (s.noncommSum f ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_cons (s : Finset α) (a : α) (f : α → β)\n    (ha : a ∉ s) (comm) :\n    noncommProd (cons a s ha) f comm =\n      f a * noncommProd s f (comm.mono fun _ => Finset.mem_cons.2 ∘ .inr) := by\n  simp_rw [noncommProd, Finset.cons_val, Multiset.map_cons, Multiset.noncommProd_cons]\n\n"}
{"name":"Finset.noncommProd_cons","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\ns : Finset α\na : α\nf : α → β\nha : Not (Membership.mem s a)\ncomm : (↑(Finset.cons a s ha)).Pairwise (Function.onFun Commute f)\n⊢ Eq ((Finset.cons a s ha).noncommProd f comm) (HMul.hMul (f a) (s.noncommProd f ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_cons (s : Finset α) (a : α) (f : α → β)\n    (ha : a ∉ s) (comm) :\n    noncommProd (cons a s ha) f comm =\n      f a * noncommProd s f (comm.mono fun _ => Finset.mem_cons.2 ∘ .inr) := by\n  simp_rw [noncommProd, Finset.cons_val, Multiset.map_cons, Multiset.noncommProd_cons]\n\n"}
{"name":"Finset.noncommSum_cons'","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\ns : Finset α\na : α\nf : α → β\nha : Not (Membership.mem s a)\ncomm : (↑(Finset.cons a s ha)).Pairwise (Function.onFun AddCommute f)\n⊢ Eq ((Finset.cons a s ha).noncommSum f comm) (HAdd.hAdd (s.noncommSum f ⋯) (f a))","decl":"@[to_additive]\ntheorem noncommProd_cons' (s : Finset α) (a : α) (f : α → β)\n    (ha : a ∉ s) (comm) :\n    noncommProd (cons a s ha) f comm =\n      noncommProd s f (comm.mono fun _ => Finset.mem_cons.2 ∘ .inr) * f a := by\n  simp_rw [noncommProd, Finset.cons_val, Multiset.map_cons, Multiset.noncommProd_cons']\n\n"}
{"name":"Finset.noncommProd_cons'","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\ns : Finset α\na : α\nf : α → β\nha : Not (Membership.mem s a)\ncomm : (↑(Finset.cons a s ha)).Pairwise (Function.onFun Commute f)\n⊢ Eq ((Finset.cons a s ha).noncommProd f comm) (HMul.hMul (s.noncommProd f ⋯) (f a))","decl":"@[to_additive]\ntheorem noncommProd_cons' (s : Finset α) (a : α) (f : α → β)\n    (ha : a ∉ s) (comm) :\n    noncommProd (cons a s ha) f comm =\n      noncommProd s f (comm.mono fun _ => Finset.mem_cons.2 ∘ .inr) * f a := by\n  simp_rw [noncommProd, Finset.cons_val, Multiset.map_cons, Multiset.noncommProd_cons']\n\n"}
{"name":"Finset.noncommProd_insert_of_not_mem","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Monoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nf : α → β\ncomm : (↑(Insert.insert a s)).Pairwise (Function.onFun Commute f)\nha : Not (Membership.mem s a)\n⊢ Eq ((Insert.insert a s).noncommProd f comm) (HMul.hMul (f a) (s.noncommProd f ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_insert_of_not_mem [DecidableEq α] (s : Finset α) (a : α) (f : α → β) (comm)\n    (ha : a ∉ s) :\n    noncommProd (insert a s) f comm =\n      f a * noncommProd s f (comm.mono fun _ => mem_insert_of_mem) := by\n  simp only [← cons_eq_insert _ _ ha, noncommProd_cons]\n\n"}
{"name":"Finset.noncommSum_insert_of_not_mem","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nf : α → β\ncomm : (↑(Insert.insert a s)).Pairwise (Function.onFun AddCommute f)\nha : Not (Membership.mem s a)\n⊢ Eq ((Insert.insert a s).noncommSum f comm) (HAdd.hAdd (f a) (s.noncommSum f ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_insert_of_not_mem [DecidableEq α] (s : Finset α) (a : α) (f : α → β) (comm)\n    (ha : a ∉ s) :\n    noncommProd (insert a s) f comm =\n      f a * noncommProd s f (comm.mono fun _ => mem_insert_of_mem) := by\n  simp only [← cons_eq_insert _ _ ha, noncommProd_cons]\n\n"}
{"name":"Finset.noncommSum_insert_of_not_mem'","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nf : α → β\ncomm : (↑(Insert.insert a s)).Pairwise (Function.onFun AddCommute f)\nha : Not (Membership.mem s a)\n⊢ Eq ((Insert.insert a s).noncommSum f comm) (HAdd.hAdd (s.noncommSum f ⋯) (f a))","decl":"@[to_additive]\ntheorem noncommProd_insert_of_not_mem' [DecidableEq α] (s : Finset α) (a : α) (f : α → β) (comm)\n    (ha : a ∉ s) :\n    noncommProd (insert a s) f comm =\n      noncommProd s f (comm.mono fun _ => mem_insert_of_mem) * f a := by\n  simp only [← cons_eq_insert _ _ ha, noncommProd_cons']\n\n"}
{"name":"Finset.noncommProd_insert_of_not_mem'","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Monoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nf : α → β\ncomm : (↑(Insert.insert a s)).Pairwise (Function.onFun Commute f)\nha : Not (Membership.mem s a)\n⊢ Eq ((Insert.insert a s).noncommProd f comm) (HMul.hMul (s.noncommProd f ⋯) (f a))","decl":"@[to_additive]\ntheorem noncommProd_insert_of_not_mem' [DecidableEq α] (s : Finset α) (a : α) (f : α → β) (comm)\n    (ha : a ∉ s) :\n    noncommProd (insert a s) f comm =\n      noncommProd s f (comm.mono fun _ => mem_insert_of_mem) * f a := by\n  simp only [← cons_eq_insert _ _ ha, noncommProd_cons']\n\n"}
{"name":"Finset.noncommSum_singleton","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\na : α\nf : α → β\n⊢ Eq ((Singleton.singleton a).noncommSum f ⋯) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_singleton (a : α) (f : α → β) :\n    noncommProd ({a} : Finset α) f\n        (by\n          norm_cast\n          exact Set.pairwise_singleton _ _) =\n      f a := mul_one _\n\n"}
{"name":"Finset.noncommProd_singleton","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\na : α\nf : α → β\n⊢ Eq ((Singleton.singleton a).noncommProd f ⋯) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem noncommProd_singleton (a : α) (f : α → β) :\n    noncommProd ({a} : Finset α) f\n        (by\n          norm_cast\n          exact Set.pairwise_singleton _ _) =\n      f a := mul_one _\n\n"}
{"name":"Finset.map_noncommSum","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝³ : AddMonoid β\ninst✝² : AddMonoid γ\ninst✝¹ : FunLike F β γ\ninst✝ : AddMonoidHomClass F β γ\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun AddCommute f)\ng : F\n⊢ Eq (g (s.noncommSum f comm)) (s.noncommSum (fun i => g (f i)) ⋯)","decl":"@[to_additive]\ntheorem map_noncommProd [MonoidHomClass F β γ] (s : Finset α) (f : α → β) (comm) (g : F) :\n    g (s.noncommProd f comm) =\n      s.noncommProd (fun i => g (f i)) fun _ hx _ hy _ => (comm.of_refl hx hy).map g := by\n  simp [noncommProd, Multiset.map_noncommProd]\n\n"}
{"name":"Finset.map_noncommProd","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝³ : Monoid β\ninst✝² : Monoid γ\ninst✝¹ : FunLike F β γ\ninst✝ : MonoidHomClass F β γ\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun Commute f)\ng : F\n⊢ Eq (g (s.noncommProd f comm)) (s.noncommProd (fun i => g (f i)) ⋯)","decl":"@[to_additive]\ntheorem map_noncommProd [MonoidHomClass F β γ] (s : Finset α) (f : α → β) (comm) (g : F) :\n    g (s.noncommProd f comm) =\n      s.noncommProd (fun i => g (f i)) fun _ hx _ hy _ => (comm.of_refl hx hy).map g := by\n  simp [noncommProd, Multiset.map_noncommProd]\n\n"}
{"name":"Finset.noncommProd_eq_pow_card","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun Commute f)\nm : β\nh : ∀ (x : α), Membership.mem s x → Eq (f x) m\n⊢ Eq (s.noncommProd f comm) (HPow.hPow m s.card)","decl":"@[to_additive noncommSum_eq_card_nsmul]\ntheorem noncommProd_eq_pow_card (s : Finset α) (f : α → β) (comm) (m : β) (h : ∀ x ∈ s, f x = m) :\n    s.noncommProd f comm = m ^ s.card := by\n  rw [noncommProd, Multiset.noncommProd_eq_pow_card _ _ m]\n  · simp only [Finset.card_def, Multiset.card_map]\n  · simpa using h\n\n"}
{"name":"Finset.noncommSum_eq_card_nsmul","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun AddCommute f)\nm : β\nh : ∀ (x : α), Membership.mem s x → Eq (f x) m\n⊢ Eq (s.noncommSum f comm) (HSMul.hSMul s.card m)","decl":"@[to_additive noncommSum_eq_card_nsmul]\ntheorem noncommProd_eq_pow_card (s : Finset α) (f : α → β) (comm) (m : β) (h : ∀ x ∈ s, f x = m) :\n    s.noncommProd f comm = m ^ s.card := by\n  rw [noncommProd, Multiset.noncommProd_eq_pow_card _ _ m]\n  · simp only [Finset.card_def, Multiset.card_map]\n  · simpa using h\n\n"}
{"name":"Finset.noncommProd_commute","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun Commute f)\ny : β\nh : ∀ (x : α), Membership.mem s x → Commute y (f x)\n⊢ Commute y (s.noncommProd f comm)","decl":"@[to_additive]\ntheorem noncommProd_commute (s : Finset α) (f : α → β) (comm) (y : β)\n    (h : ∀ x ∈ s, Commute y (f x)) : Commute y (s.noncommProd f comm) := by\n  apply Multiset.noncommProd_commute\n  intro y\n  rw [Multiset.mem_map]\n  rintro ⟨x, ⟨hx, rfl⟩⟩\n  exact h x hx\n\n"}
{"name":"Finset.noncommSum_addCommute","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\ns : Finset α\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun AddCommute f)\ny : β\nh : ∀ (x : α), Membership.mem s x → AddCommute y (f x)\n⊢ AddCommute y (s.noncommSum f comm)","decl":"@[to_additive]\ntheorem noncommProd_commute (s : Finset α) (f : α → β) (comm) (y : β)\n    (h : ∀ x ∈ s, Commute y (f x)) : Commute y (s.noncommProd f comm) := by\n  apply Multiset.noncommProd_commute\n  intro y\n  rw [Multiset.mem_map]\n  rintro ⟨x, ⟨hx, rfl⟩⟩\n  exact h x hx\n\n"}
{"name":"Finset.mul_noncommProd_erase","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Monoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nh : Membership.mem s a\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun Commute f)\ncomm' : optParam (∀ (x : α), Membership.mem (↑(s.erase a)) x → ∀ (x_1 : α), Membership.mem (↑(s.erase a)) x_1 → Ne x x_1 → Function.onFun Commute f x x_1) ⋯\n⊢ Eq (HMul.hMul (f a) ((s.erase a).noncommProd f comm')) (s.noncommProd f comm)","decl":"theorem mul_noncommProd_erase [DecidableEq α] (s : Finset α) {a : α} (h : a ∈ s) (f : α → β) (comm)\n    (comm' := fun _ hx _ hy hxy ↦ comm (s.mem_of_mem_erase hx) (s.mem_of_mem_erase hy) hxy) :\n    f a * (s.erase a).noncommProd f comm' = s.noncommProd f comm := by\n  classical\n  simpa only [← Multiset.map_erase_of_mem _ _ h] using\n    Multiset.mul_noncommProd_erase (s.1.map f) (Multiset.mem_map_of_mem f h) _\n\n"}
{"name":"Finset.noncommProd_erase_mul","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Monoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nh : Membership.mem s a\nf : α → β\ncomm : (↑s).Pairwise (Function.onFun Commute f)\ncomm' : optParam (∀ (x : α), Membership.mem (↑(s.erase a)) x → ∀ (x_1 : α), Membership.mem (↑(s.erase a)) x_1 → Ne x x_1 → Function.onFun Commute f x x_1) ⋯\n⊢ Eq (HMul.hMul ((s.erase a).noncommProd f comm') (f a)) (s.noncommProd f comm)","decl":"theorem noncommProd_erase_mul [DecidableEq α] (s : Finset α) {a : α} (h : a ∈ s) (f : α → β) (comm)\n    (comm' := fun _ hx _ hy hxy ↦ comm (s.mem_of_mem_erase hx) (s.mem_of_mem_erase hy) hxy) :\n    (s.erase a).noncommProd f comm' * f a = s.noncommProd f comm := by\n  classical\n  simpa only [← Multiset.map_erase_of_mem _ _ h] using\n    Multiset.noncommProd_erase_mul (s.1.map f) (Multiset.mem_map_of_mem f h) _\n\n"}
{"name":"Finset.noncommProd_eq_prod","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_6\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (s.noncommProd f ⋯) (s.prod f)","decl":"@[to_additive]\ntheorem noncommProd_eq_prod {β : Type*} [CommMonoid β] (s : Finset α) (f : α → β) :\n    (noncommProd s f fun _ _ _ _ _ => Commute.all _ _) = s.prod f := by\n  induction' s using Finset.cons_induction_on with a s ha IH\n  · simp\n  · simp [ha, IH]\n\n"}
{"name":"Finset.noncommSum_eq_sum","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_6\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (s.noncommSum f ⋯) (s.sum f)","decl":"@[to_additive]\ntheorem noncommProd_eq_prod {β : Type*} [CommMonoid β] (s : Finset α) (f : α → β) :\n    (noncommProd s f fun _ _ _ _ _ => Commute.all _ _) = s.prod f := by\n  induction' s using Finset.cons_induction_on with a s ha IH\n  · simp\n  · simp [ha, IH]\n\n"}
{"name":"Finset.noncommSum_union_of_disjoint","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddMonoid β\ninst✝ : DecidableEq α\ns t : Finset α\nh : Disjoint s t\nf : α → β\ncomm : (setOf fun x => Membership.mem (Union.union s t) x).Pairwise (Function.onFun AddCommute f)\n⊢ Eq ((Union.union s t).noncommSum f comm) (HAdd.hAdd (s.noncommSum f ⋯) (t.noncommSum f ⋯))","decl":"/-- The non-commutative version of `Finset.prod_union` -/\n@[to_additive \"The non-commutative version of `Finset.sum_union`\"]\ntheorem noncommProd_union_of_disjoint [DecidableEq α] {s t : Finset α} (h : Disjoint s t)\n    (f : α → β) (comm : { x | x ∈ s ∪ t }.Pairwise (Commute on f)) :\n    noncommProd (s ∪ t) f comm =\n      noncommProd s f (comm.mono <| coe_subset.2 subset_union_left) *\n        noncommProd t f (comm.mono <| coe_subset.2 subset_union_right) := by\n  obtain ⟨sl, sl', rfl⟩ := exists_list_nodup_eq s\n  obtain ⟨tl, tl', rfl⟩ := exists_list_nodup_eq t\n  rw [List.disjoint_toFinset_iff_disjoint] at h\n  calc noncommProd (List.toFinset sl ∪ List.toFinset tl) f comm\n     = noncommProd ⟨↑(sl ++ tl), Multiset.coe_nodup.2 (sl'.append tl' h)⟩ f\n         (by convert comm; simp [Set.ext_iff]) := noncommProd_congr (by ext; simp) (by simp) _\n   _ = noncommProd (List.toFinset sl) f (comm.mono <| coe_subset.2 subset_union_left) *\n         noncommProd (List.toFinset tl) f (comm.mono <| coe_subset.2 subset_union_right) := by\n    simp [noncommProd, List.dedup_eq_self.2 sl', List.dedup_eq_self.2 tl', h]\n\n"}
{"name":"Finset.noncommProd_union_of_disjoint","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Monoid β\ninst✝ : DecidableEq α\ns t : Finset α\nh : Disjoint s t\nf : α → β\ncomm : (setOf fun x => Membership.mem (Union.union s t) x).Pairwise (Function.onFun Commute f)\n⊢ Eq ((Union.union s t).noncommProd f comm) (HMul.hMul (s.noncommProd f ⋯) (t.noncommProd f ⋯))","decl":"/-- The non-commutative version of `Finset.prod_union` -/\n@[to_additive \"The non-commutative version of `Finset.sum_union`\"]\ntheorem noncommProd_union_of_disjoint [DecidableEq α] {s t : Finset α} (h : Disjoint s t)\n    (f : α → β) (comm : { x | x ∈ s ∪ t }.Pairwise (Commute on f)) :\n    noncommProd (s ∪ t) f comm =\n      noncommProd s f (comm.mono <| coe_subset.2 subset_union_left) *\n        noncommProd t f (comm.mono <| coe_subset.2 subset_union_right) := by\n  obtain ⟨sl, sl', rfl⟩ := exists_list_nodup_eq s\n  obtain ⟨tl, tl', rfl⟩ := exists_list_nodup_eq t\n  rw [List.disjoint_toFinset_iff_disjoint] at h\n  calc noncommProd (List.toFinset sl ∪ List.toFinset tl) f comm\n     = noncommProd ⟨↑(sl ++ tl), Multiset.coe_nodup.2 (sl'.append tl' h)⟩ f\n         (by convert comm; simp [Set.ext_iff]) := noncommProd_congr (by ext; simp) (by simp) _\n   _ = noncommProd (List.toFinset sl) f (comm.mono <| coe_subset.2 subset_union_left) *\n         noncommProd (List.toFinset tl) f (comm.mono <| coe_subset.2 subset_union_right) := by\n    simp [noncommProd, List.dedup_eq_self.2 sl', List.dedup_eq_self.2 tl', h]\n\n"}
{"name":"Finset.noncommSum_add_distrib_aux","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\ns : Finset α\nf g : α → β\ncomm_ff : (↑s).Pairwise (Function.onFun AddCommute f)\ncomm_gg : (↑s).Pairwise (Function.onFun AddCommute g)\ncomm_gf : (↑s).Pairwise fun x y => AddCommute (g x) (f y)\n⊢ (↑s).Pairwise fun x y => AddCommute (HAdd.hAdd f g x) (HAdd.hAdd f g y)","decl":"@[to_additive]\ntheorem noncommProd_mul_distrib_aux {s : Finset α} {f : α → β} {g : α → β}\n    (comm_ff : (s : Set α).Pairwise (Commute on f))\n    (comm_gg : (s : Set α).Pairwise (Commute on g))\n    (comm_gf : (s : Set α).Pairwise fun x y => Commute (g x) (f y)) :\n    (s : Set α).Pairwise fun x y => Commute ((f * g) x) ((f * g) y) := by\n  intro x hx y hy h\n  apply Commute.mul_left <;> apply Commute.mul_right\n  · exact comm_ff.of_refl hx hy\n  · exact (comm_gf hy hx h.symm).symm\n  · exact comm_gf hx hy h\n  · exact comm_gg.of_refl hx hy\n\n"}
{"name":"Finset.noncommProd_mul_distrib_aux","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\ns : Finset α\nf g : α → β\ncomm_ff : (↑s).Pairwise (Function.onFun Commute f)\ncomm_gg : (↑s).Pairwise (Function.onFun Commute g)\ncomm_gf : (↑s).Pairwise fun x y => Commute (g x) (f y)\n⊢ (↑s).Pairwise fun x y => Commute (HMul.hMul f g x) (HMul.hMul f g y)","decl":"@[to_additive]\ntheorem noncommProd_mul_distrib_aux {s : Finset α} {f : α → β} {g : α → β}\n    (comm_ff : (s : Set α).Pairwise (Commute on f))\n    (comm_gg : (s : Set α).Pairwise (Commute on g))\n    (comm_gf : (s : Set α).Pairwise fun x y => Commute (g x) (f y)) :\n    (s : Set α).Pairwise fun x y => Commute ((f * g) x) ((f * g) y) := by\n  intro x hx y hy h\n  apply Commute.mul_left <;> apply Commute.mul_right\n  · exact comm_ff.of_refl hx hy\n  · exact (comm_gf hy hx h.symm).symm\n  · exact comm_gf hx hy h\n  · exact comm_gg.of_refl hx hy\n\n"}
{"name":"Finset.noncommSum_add_distrib","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddMonoid β\ns : Finset α\nf g : α → β\ncomm_ff : (↑s).Pairwise (Function.onFun AddCommute f)\ncomm_gg : (↑s).Pairwise (Function.onFun AddCommute g)\ncomm_gf : (↑s).Pairwise fun x y => AddCommute (g x) (f y)\n⊢ Eq (s.noncommSum (HAdd.hAdd f g) ⋯) (HAdd.hAdd (s.noncommSum f comm_ff) (s.noncommSum g comm_gg))","decl":"/-- The non-commutative version of `Finset.prod_mul_distrib` -/\n@[to_additive \"The non-commutative version of `Finset.sum_add_distrib`\"]\ntheorem noncommProd_mul_distrib {s : Finset α} (f : α → β) (g : α → β) (comm_ff comm_gg comm_gf) :\n    noncommProd s (f * g) (noncommProd_mul_distrib_aux comm_ff comm_gg comm_gf) =\n      noncommProd s f comm_ff * noncommProd s g comm_gg := by\n  induction' s using Finset.cons_induction_on with x s hnmem ih\n  · simp\n  rw [Finset.noncommProd_cons, Finset.noncommProd_cons, Finset.noncommProd_cons, Pi.mul_apply,\n    ih (comm_ff.mono fun _ => mem_cons_of_mem) (comm_gg.mono fun _ => mem_cons_of_mem)\n      (comm_gf.mono fun _ => mem_cons_of_mem),\n    (noncommProd_commute _ _ _ _ fun y hy => ?_).mul_mul_mul_comm]\n  exact comm_gf (mem_cons_self x s) (mem_cons_of_mem hy) (ne_of_mem_of_not_mem hy hnmem).symm\n\n"}
{"name":"Finset.noncommProd_mul_distrib","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Monoid β\ns : Finset α\nf g : α → β\ncomm_ff : (↑s).Pairwise (Function.onFun Commute f)\ncomm_gg : (↑s).Pairwise (Function.onFun Commute g)\ncomm_gf : (↑s).Pairwise fun x y => Commute (g x) (f y)\n⊢ Eq (s.noncommProd (HMul.hMul f g) ⋯) (HMul.hMul (s.noncommProd f comm_ff) (s.noncommProd g comm_gg))","decl":"/-- The non-commutative version of `Finset.prod_mul_distrib` -/\n@[to_additive \"The non-commutative version of `Finset.sum_add_distrib`\"]\ntheorem noncommProd_mul_distrib {s : Finset α} (f : α → β) (g : α → β) (comm_ff comm_gg comm_gf) :\n    noncommProd s (f * g) (noncommProd_mul_distrib_aux comm_ff comm_gg comm_gf) =\n      noncommProd s f comm_ff * noncommProd s g comm_gg := by\n  induction' s using Finset.cons_induction_on with x s hnmem ih\n  · simp\n  rw [Finset.noncommProd_cons, Finset.noncommProd_cons, Finset.noncommProd_cons, Pi.mul_apply,\n    ih (comm_ff.mono fun _ => mem_cons_of_mem) (comm_gg.mono fun _ => mem_cons_of_mem)\n      (comm_gf.mono fun _ => mem_cons_of_mem),\n    (noncommProd_commute _ _ _ _ fun y hy => ?_).mul_mul_mul_comm]\n  exact comm_gf (mem_cons_self x s) (mem_cons_of_mem hy) (ne_of_mem_of_not_mem hy hnmem).symm\n\n"}
{"name":"Finset.noncommProd_mul_single","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"ι : Type u_2\nM : ι → Type u_6\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nx : (i : ι) → M i\n⊢ Eq (Finset.univ.noncommProd (fun i => Pi.mulSingle i (x i)) ⋯) x","decl":"@[to_additive]\ntheorem noncommProd_mul_single [Fintype ι] [DecidableEq ι] (x : ∀ i, M i) :\n    (univ.noncommProd (fun i => Pi.mulSingle i (x i)) fun i _ j _ _ =>\n        Pi.mulSingle_apply_commute x i j) = x := by\n  ext i\n  apply (univ.map_noncommProd (fun i ↦ MonoidHom.mulSingle M i (x i)) ?a\n    (Pi.evalMonoidHom M i)).trans\n  case a =>\n    intro i _ j _ _\n    exact Pi.mulSingle_apply_commute x i j\n  convert (noncommProd_congr (insert_erase (mem_univ i)).symm _ _).trans _\n  · intro j\n    exact Pi.mulSingle j (x j) i\n  · intro j _; dsimp\n  · rw [noncommProd_insert_of_not_mem _ _ _ _ (not_mem_erase _ _),\n      noncommProd_eq_pow_card (univ.erase i), one_pow, mul_one]\n    · simp only [MonoidHom.mulSingle_apply, ne_eq, Pi.mulSingle_eq_same]\n    · intro j hj\n      simp? at hj says simp only [mem_erase, ne_eq, mem_univ, and_true] at hj\n      simp only [MonoidHom.mulSingle_apply, Pi.mulSingle, Function.update, Eq.ndrec, Pi.one_apply,\n        ne_eq, dite_eq_right_iff]\n      intro h\n      simp [*] at *\n\n"}
{"name":"Finset.noncommSum_single","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"ι : Type u_2\nM : ι → Type u_6\ninst✝² : (i : ι) → AddMonoid (M i)\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nx : (i : ι) → M i\n⊢ Eq (Finset.univ.noncommSum (fun i => Pi.single i (x i)) ⋯) x","decl":"@[to_additive]\ntheorem noncommProd_mul_single [Fintype ι] [DecidableEq ι] (x : ∀ i, M i) :\n    (univ.noncommProd (fun i => Pi.mulSingle i (x i)) fun i _ j _ _ =>\n        Pi.mulSingle_apply_commute x i j) = x := by\n  ext i\n  apply (univ.map_noncommProd (fun i ↦ MonoidHom.mulSingle M i (x i)) ?a\n    (Pi.evalMonoidHom M i)).trans\n  case a =>\n    intro i _ j _ _\n    exact Pi.mulSingle_apply_commute x i j\n  convert (noncommProd_congr (insert_erase (mem_univ i)).symm _ _).trans _\n  · intro j\n    exact Pi.mulSingle j (x j) i\n  · intro j _; dsimp\n  · rw [noncommProd_insert_of_not_mem _ _ _ _ (not_mem_erase _ _),\n      noncommProd_eq_pow_card (univ.erase i), one_pow, mul_one]\n    · simp only [MonoidHom.mulSingle_apply, ne_eq, Pi.mulSingle_eq_same]\n    · intro j hj\n      simp? at hj says simp only [mem_erase, ne_eq, mem_univ, and_true] at hj\n      simp only [MonoidHom.mulSingle_apply, Pi.mulSingle, Function.update, Eq.ndrec, Pi.one_apply,\n        ne_eq, dite_eq_right_iff]\n      intro h\n      simp [*] at *\n\n"}
{"name":"MonoidHom.pi_ext","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"ι : Type u_2\nγ : Type u_5\ninst✝³ : Monoid γ\nM : ι → Type u_6\ninst✝² : (i : ι) → Monoid (M i)\ninst✝¹ : Finite ι\ninst✝ : DecidableEq ι\nf g : MonoidHom ((i : ι) → M i) γ\nh : ∀ (i : ι) (x : M i), Eq (f (Pi.mulSingle i x)) (g (Pi.mulSingle i x))\n⊢ Eq f g","decl":"@[to_additive]\ntheorem _root_.MonoidHom.pi_ext [Finite ι] [DecidableEq ι] {f g : (∀ i, M i) →* γ}\n    (h : ∀ i x, f (Pi.mulSingle i x) = g (Pi.mulSingle i x)) : f = g := by\n  cases nonempty_fintype ι\n  ext x\n  rw [← noncommProd_mul_single x, univ.map_noncommProd, univ.map_noncommProd]\n  congr 1 with i; exact h i (x i)\n\n"}
{"name":"AddMonoidHom.pi_ext","module":"Mathlib.Data.Finset.NoncommProd","initialProofState":"ι : Type u_2\nγ : Type u_5\ninst✝³ : AddMonoid γ\nM : ι → Type u_6\ninst✝² : (i : ι) → AddMonoid (M i)\ninst✝¹ : Finite ι\ninst✝ : DecidableEq ι\nf g : AddMonoidHom ((i : ι) → M i) γ\nh : ∀ (i : ι) (x : M i), Eq (f (Pi.single i x)) (g (Pi.single i x))\n⊢ Eq f g","decl":"@[to_additive]\ntheorem _root_.MonoidHom.pi_ext [Finite ι] [DecidableEq ι] {f g : (∀ i, M i) →* γ}\n    (h : ∀ i x, f (Pi.mulSingle i x) = g (Pi.mulSingle i x)) : f = g := by\n  cases nonempty_fintype ι\n  ext x\n  rw [← noncommProd_mul_single x, univ.map_noncommProd, univ.map_noncommProd]\n  congr 1 with i; exact h i (x i)\n\n"}
