{"name":"ContinuousLinearMap.ofMemClosureImageCoeBounded_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nE' : Type u_6\ninstâœÂ² : SeminormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ğ•œ E'\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : E' â†’ F\ns : Set (ContinuousLinearMap Ïƒâ‚â‚‚ E' F)\nhs : Bornology.IsBounded s\nhf : Membership.mem (closure (Set.image DFunLike.coe s)) f\nâŠ¢ Eq (â‡‘(ContinuousLinearMap.ofMemClosureImageCoeBounded f hs hf)) f","decl":"/-- Construct a bundled continuous (semi)linear map from a map `f : E â†’ F` and a proof of the fact\nthat it belongs to the closure of the image of a bounded set `s : Set (E â†’SL[Ïƒâ‚â‚‚] F)` under coercion\nto function. Coercion to function of the result is definitionally equal to `f`. -/\n@[simps! (config := .asFn) apply]\ndef ofMemClosureImageCoeBounded (f : E' â†’ F) {s : Set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hs : IsBounded s)\n    (hf : f âˆˆ closure (((â†‘) : (E' â†’SL[Ïƒâ‚â‚‚] F) â†’ E' â†’ F) '' s)) : E' â†’SL[Ïƒâ‚â‚‚] F := by\n  -- `f` is a linear map due to `linearMapOfMemClosureRangeCoe`\n  refine (linearMapOfMemClosureRangeCoe f ?_).mkContinuousOfExistsBound ?_\n  Â· refine closure_mono (image_subset_iff.2 fun g _ => ?_) hf\n    exact âŸ¨g, rflâŸ©\n  Â· -- We need to show that `f` has bounded norm. Choose `C` such that `â€–gâ€– â‰¤ C` for all `g âˆˆ s`.\n    rcases isBounded_iff_forall_norm_le.1 hs with âŸ¨C, hCâŸ©\n    -- Then `â€–g xâ€– â‰¤ C * â€–xâ€–` for all `g âˆˆ s`, `x : E`, hence `â€–f xâ€– â‰¤ C * â€–xâ€–` for all `x`.\n    have : âˆ€ x, IsClosed { g : E' â†’ F | â€–g xâ€– â‰¤ C * â€–xâ€– } := fun x =>\n      isClosed_Iic.preimage (@continuous_apply E' (fun _ => F) _ x).norm\n    refine âŸ¨C, fun x => (this x).closure_subset_iff.2 (image_subset_iff.2 fun g hg => ?_) hfâŸ©\n    exact g.le_of_opNorm_le (hC _ hg) _\n\n"}
{"name":"ContinuousLinearMap.ofTendstoOfBoundedRange_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nE' : Type u_6\ninstâœÂ³ : SeminormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\nÎ± : Type u_7\nl : Filter Î±\ninstâœ : l.NeBot\nf : E' â†’ F\ng : Î± â†’ ContinuousLinearMap Ïƒâ‚â‚‚ E' F\nhf : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\nhg : Bornology.IsBounded (Set.range g)\nâŠ¢ Eq (â‡‘(ContinuousLinearMap.ofTendstoOfBoundedRange f g hf hg)) f","decl":"/-- Let `f : E â†’ F` be a map, let `g : Î± â†’ E â†’SL[Ïƒâ‚â‚‚] F` be a family of continuous (semi)linear maps\nthat takes values in a bounded set and converges to `f` pointwise along a nontrivial filter. Then\n`f` is a continuous (semi)linear map. -/\n@[simps! (config := .asFn) apply]\ndef ofTendstoOfBoundedRange {Î± : Type*} {l : Filter Î±} [l.NeBot] (f : E' â†’ F)\n    (g : Î± â†’ E' â†’SL[Ïƒâ‚â‚‚] F) (hf : Tendsto (fun a x => g a x) l (ğ“ f))\n    (hg : IsBounded (Set.range g)) : E' â†’SL[Ïƒâ‚â‚‚] F :=\n  ofMemClosureImageCoeBounded f hg <| mem_closure_of_tendsto hf <|\n    Eventually.of_forall fun _ => mem_image_of_mem _ <| Set.mem_range_self _\n\n"}
{"name":"ContinuousLinearMap.tendsto_of_tendsto_pointwise_of_cauchySeq","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nE' : Type u_6\ninstâœÂ² : SeminormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ğ•œ E'\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : Nat â†’ ContinuousLinearMap Ïƒâ‚â‚‚ E' F\ng : ContinuousLinearMap Ïƒâ‚â‚‚ E' F\nhg : Filter.Tendsto (fun n x => (f n) x) Filter.atTop (nhds â‡‘g)\nhf : CauchySeq f\nâŠ¢ Filter.Tendsto f Filter.atTop (nhds g)","decl":"/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem tendsto_of_tendsto_pointwise_of_cauchySeq {f : â„• â†’ E' â†’SL[Ïƒâ‚â‚‚] F} {g : E' â†’SL[Ïƒâ‚â‚‚] F}\n    (hg : Tendsto (fun n x => f n x) atTop (ğ“ g)) (hf : CauchySeq f) : Tendsto f atTop (ğ“ g) := by\n  /- Since `f` is a Cauchy sequence, there exists `b â†’ 0` such that `â€–f n - f mâ€– â‰¤ b N` for any\n    `m, n â‰¥ N`. -/\n  rcases cauchySeq_iff_le_tendsto_0.1 hf with âŸ¨b, hbâ‚€, hfb, hb_limâŸ©\n  -- Since `b â†’ 0`, it suffices to show that `â€–f n x - g xâ€– â‰¤ b n * â€–xâ€–` for all `n` and `x`.\n  suffices âˆ€ n x, â€–f n x - g xâ€– â‰¤ b n * â€–xâ€– from\n    tendsto_iff_norm_sub_tendsto_zero.2\n    (squeeze_zero (fun n => norm_nonneg _) (fun n => opNorm_le_bound _ (hbâ‚€ n) (this n)) hb_lim)\n  intro n x\n  -- Note that `f m x â†’ g x`, hence `â€–f n x - f m xâ€– â†’ â€–f n x - g xâ€–` as `m â†’ âˆ`\n  have : Tendsto (fun m => â€–f n x - f m xâ€–) atTop (ğ“ â€–f n x - g xâ€–) :=\n    (tendsto_const_nhds.sub <| tendsto_pi_nhds.1 hg _).norm\n  -- Thus it suffices to verify `â€–f n x - f m xâ€– â‰¤ b n * â€–xâ€–` for `m â‰¥ n`.\n  refine le_of_tendsto this (eventually_atTop.2 âŸ¨n, fun m hm => ?_âŸ©)\n  -- This inequality follows from `â€–f n - f mâ€– â‰¤ b n`.\n  exact (f n - f m).le_of_opNorm_le (hfb _ _ _ le_rfl hm) _\n\n"}
{"name":"ContinuousLinearMap.instCompleteSpace_1","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nE' : Type u_6\ninstâœÂ² : SeminormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ğ•œ E'\ninstâœ : CompleteSpace F\nâŠ¢ CompleteSpace (ContinuousLinearMap Ïƒâ‚â‚‚ E' F)","decl":"/-- If the target space is complete, the space of continuous linear maps with its norm is also\ncomplete. This works also if the source space is seminormed. -/\ninstance [CompleteSpace F] : CompleteSpace (E' â†’SL[Ïƒâ‚â‚‚] F) := by\n  -- We show that every Cauchy sequence converges.\n  refine Metric.complete_of_cauchySeq_tendsto fun f hf => ?_\n  -- The evaluation at any point `v : E` is Cauchy.\n  have cau : âˆ€ v, CauchySeq fun n => f n v := fun v => hf.map (lipschitz_apply v).uniformContinuous\n  -- We assemble the limits points of those Cauchy sequences\n  -- (which exist as `F` is complete)\n  -- into a function which we call `G`.\n  choose G hG using fun v => cauchySeq_tendsto_of_complete (cau v)\n  -- Next, we show that this `G` is a continuous linear map.\n  -- This is done in `ContinuousLinearMap.ofTendstoOfBoundedRange`.\n  set Glin : E' â†’SL[Ïƒâ‚â‚‚] F :=\n    ofTendstoOfBoundedRange _ _ (tendsto_pi_nhds.mpr hG) hf.isBounded_range\n  -- Finally, `f n` converges to `Glin` in norm because of\n  -- `ContinuousLinearMap.tendsto_of_tendsto_pointwise_of_cauchySeq`\n  exact âŸ¨Glin, tendsto_of_tendsto_pointwise_of_cauchySeq (tendsto_pi_nhds.2 hG) hfâŸ©\n\n"}
{"name":"ContinuousLinearMap.isCompact_closure_image_coe_of_bounded","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nE' : Type u_6\ninstâœÂ³ : SeminormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : ProperSpace F\ns : Set (ContinuousLinearMap Ïƒâ‚â‚‚ E' F)\nhb : Bornology.IsBounded s\nâŠ¢ IsCompact (closure (Set.image DFunLike.coe s))","decl":"/-- Let `s` be a bounded set in the space of continuous (semi)linear maps `E â†’SL[Ïƒ] F` taking values\nin a proper space. Then `s` interpreted as a set in the space of maps `E â†’ F` with topology of\npointwise convergence is precompact: its closure is a compact set. -/\ntheorem isCompact_closure_image_coe_of_bounded [ProperSpace F] {s : Set (E' â†’SL[Ïƒâ‚â‚‚] F)}\n    (hb : IsBounded s) : IsCompact (closure (((â†‘) : (E' â†’SL[Ïƒâ‚â‚‚] F) â†’ E' â†’ F) '' s)) :=\n  have : âˆ€ x, IsCompact (closure (apply' F Ïƒâ‚â‚‚ x '' s)) := fun x =>\n    ((apply' F Ïƒâ‚â‚‚ x).lipschitz.isBounded_image hb).isCompact_closure\n  (isCompact_pi_infinite this).closure_of_subset\n    (image_subset_iff.2 fun _ hg _ => subset_closure <| mem_image_of_mem _ hg)\n\n"}
{"name":"ContinuousLinearMap.isCompact_image_coe_of_bounded_of_closed_image","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nE' : Type u_6\ninstâœÂ³ : SeminormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : ProperSpace F\ns : Set (ContinuousLinearMap Ïƒâ‚â‚‚ E' F)\nhb : Bornology.IsBounded s\nhc : IsClosed (Set.image DFunLike.coe s)\nâŠ¢ IsCompact (Set.image DFunLike.coe s)","decl":"/-- Let `s` be a bounded set in the space of continuous (semi)linear maps `E â†’SL[Ïƒ] F` taking values\nin a proper space. If `s` interpreted as a set in the space of maps `E â†’ F` with topology of\npointwise convergence is closed, then it is compact.\n\nTODO: reformulate this in terms of a type synonym with the right topology. -/\ntheorem isCompact_image_coe_of_bounded_of_closed_image [ProperSpace F] {s : Set (E' â†’SL[Ïƒâ‚â‚‚] F)}\n    (hb : IsBounded s) (hc : IsClosed (((â†‘) : (E' â†’SL[Ïƒâ‚â‚‚] F) â†’ E' â†’ F) '' s)) :\n    IsCompact (((â†‘) : (E' â†’SL[Ïƒâ‚â‚‚] F) â†’ E' â†’ F) '' s) :=\n  hc.closure_eq â–¸ isCompact_closure_image_coe_of_bounded hb\n\n"}
{"name":"ContinuousLinearMap.isClosed_image_coe_of_bounded_of_weak_closed","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nE' : Type u_6\ninstâœÂ² : SeminormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ğ•œ E'\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\ns : Set (ContinuousLinearMap Ïƒâ‚â‚‚ E' F)\nhb : Bornology.IsBounded s\nhc : âˆ€ (f : ContinuousLinearMap Ïƒâ‚â‚‚ E' F), Membership.mem (closure (Set.image DFunLike.coe s)) â‡‘f â†’ Membership.mem s f\nâŠ¢ IsClosed (Set.image DFunLike.coe s)","decl":"/-- If a set `s` of semilinear functions is bounded and is closed in the weak-* topology, then its\nimage under coercion to functions `E â†’ F` is a closed set. We don't have a name for `E â†’SL[Ïƒ] F`\nwith weak-* topology in `mathlib`, so we use an equivalent condition (see `isClosed_induced_iff'`).\n\nTODO: reformulate this in terms of a type synonym with the right topology. -/\ntheorem isClosed_image_coe_of_bounded_of_weak_closed {s : Set (E' â†’SL[Ïƒâ‚â‚‚] F)} (hb : IsBounded s)\n    (hc : âˆ€ f : E' â†’SL[Ïƒâ‚â‚‚] F,\n      (â‡‘f : E' â†’ F) âˆˆ closure (((â†‘) : (E' â†’SL[Ïƒâ‚â‚‚] F) â†’ E' â†’ F) '' s) â†’ f âˆˆ s) :\n    IsClosed (((â†‘) : (E' â†’SL[Ïƒâ‚â‚‚] F) â†’ E' â†’ F) '' s) :=\n  isClosed_of_closure_subset fun f hf =>\n    âŸ¨ofMemClosureImageCoeBounded f hb hf, hc (ofMemClosureImageCoeBounded f hb hf) hf, rflâŸ©\n\n"}
{"name":"ContinuousLinearMap.isCompact_image_coe_of_bounded_of_weak_closed","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nE' : Type u_6\ninstâœÂ³ : SeminormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : ProperSpace F\ns : Set (ContinuousLinearMap Ïƒâ‚â‚‚ E' F)\nhb : Bornology.IsBounded s\nhc : âˆ€ (f : ContinuousLinearMap Ïƒâ‚â‚‚ E' F), Membership.mem (closure (Set.image DFunLike.coe s)) â‡‘f â†’ Membership.mem s f\nâŠ¢ IsCompact (Set.image DFunLike.coe s)","decl":"/-- If a set `s` of semilinear functions is bounded and is closed in the weak-* topology, then its\nimage under coercion to functions `E â†’ F` is a compact set. We don't have a name for `E â†’SL[Ïƒ] F`\nwith weak-* topology in `mathlib`, so we use an equivalent condition (see `isClosed_induced_iff'`).\n-/\ntheorem isCompact_image_coe_of_bounded_of_weak_closed [ProperSpace F] {s : Set (E' â†’SL[Ïƒâ‚â‚‚] F)}\n    (hb : IsBounded s) (hc : âˆ€ f : E' â†’SL[Ïƒâ‚â‚‚] F,\n      (â‡‘f : E' â†’ F) âˆˆ closure (((â†‘) : (E' â†’SL[Ïƒâ‚â‚‚] F) â†’ E' â†’ F) '' s) â†’ f âˆˆ s) :\n    IsCompact (((â†‘) : (E' â†’SL[Ïƒâ‚â‚‚] F) â†’ E' â†’ F) '' s) :=\n  isCompact_image_coe_of_bounded_of_closed_image hb <|\n    isClosed_image_coe_of_bounded_of_weak_closed hb hc\n\n"}
{"name":"ContinuousLinearMap.is_weak_closed_closedBall","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nE' : Type u_6\ninstâœÂ² : SeminormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ğ•œ E'\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nfâ‚€ : ContinuousLinearMap Ïƒâ‚â‚‚ E' F\nr : Real\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E' F\nhf : Membership.mem (closure (Set.image DFunLike.coe (Metric.closedBall fâ‚€ r))) â‡‘f\nâŠ¢ Membership.mem (Metric.closedBall fâ‚€ r) f","decl":"/-- A closed ball is closed in the weak-* topology. We don't have a name for `E â†’SL[Ïƒ] F` with\nweak-* topology in `mathlib`, so we use an equivalent condition (see `isClosed_induced_iff'`). -/\ntheorem is_weak_closed_closedBall (fâ‚€ : E' â†’SL[Ïƒâ‚â‚‚] F) (r : â„) â¦ƒf : E' â†’SL[Ïƒâ‚â‚‚] Fâ¦„\n    (hf : â‡‘f âˆˆ closure (((â†‘) : (E' â†’SL[Ïƒâ‚â‚‚] F) â†’ E' â†’ F) '' closedBall fâ‚€ r)) :\n    f âˆˆ closedBall fâ‚€ r := by\n  have hr : 0 â‰¤ r := nonempty_closedBall.1 (closure_nonempty_iff.1 âŸ¨_, hfâŸ©).of_image\n  refine mem_closedBall_iff_norm.2 (opNorm_le_bound _ hr fun x => ?_)\n  have : IsClosed { g : E' â†’ F | â€–g x - fâ‚€ xâ€– â‰¤ r * â€–xâ€– } :=\n    isClosed_Iic.preimage ((@continuous_apply E' (fun _ => F) _ x).sub continuous_const).norm\n  refine this.closure_subset_iff.2 (image_subset_iff.2 fun g hg => ?_) hf\n  exact (g - fâ‚€).le_of_opNorm_le (mem_closedBall_iff_norm.1 hg) _\n\n"}
{"name":"ContinuousLinearMap.isClosed_image_coe_closedBall","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nfâ‚€ : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nr : Real\nâŠ¢ IsClosed (Set.image DFunLike.coe (Metric.closedBall fâ‚€ r))","decl":"/-- The set of functions `f : E â†’ F` that represent continuous linear maps `f : E â†’SL[Ïƒâ‚â‚‚] F`\nat distance `â‰¤ r` from `fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F` is closed in the topology of pointwise convergence.\nThis is one of the key steps in the proof of the **Banach-Alaoglu** theorem. -/\ntheorem isClosed_image_coe_closedBall (fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F) (r : â„) :\n    IsClosed (((â†‘) : (E â†’SL[Ïƒâ‚â‚‚] F) â†’ E â†’ F) '' closedBall fâ‚€ r) :=\n  isClosed_image_coe_of_bounded_of_weak_closed isBounded_closedBall (is_weak_closed_closedBall fâ‚€ r)\n\n"}
{"name":"ContinuousLinearMap.isCompact_image_coe_closedBall","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : ProperSpace F\nfâ‚€ : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nr : Real\nâŠ¢ IsCompact (Set.image DFunLike.coe (Metric.closedBall fâ‚€ r))","decl":"/-- **Banach-Alaoglu** theorem. The set of functions `f : E â†’ F` that represent continuous linear\nmaps `f : E â†’SL[Ïƒâ‚â‚‚] F` at distance `â‰¤ r` from `fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F` is compact in the topology of\npointwise convergence. Other versions of this theorem can be found in\n`Analysis.Normed.Module.WeakDual`. -/\ntheorem isCompact_image_coe_closedBall [ProperSpace F] (fâ‚€ : E â†’SL[Ïƒâ‚â‚‚] F) (r : â„) :\n    IsCompact (((â†‘) : (E â†’SL[Ïƒâ‚â‚‚] F) â†’ E â†’ F) '' closedBall fâ‚€ r) :=\n  isCompact_image_coe_of_bounded_of_weak_closed isBounded_closedBall <|\n    is_weak_closed_closedBall fâ‚€ r\n\n"}
{"name":"ContinuousLinearMap.extend_eq","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\nFâ‚— : Type u_5\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedAddCommGroup Fâ‚—\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\ninstâœ : CompleteSpace F\ne : ContinuousLinearMap (RingHom.id ğ•œ) E Fâ‚—\nh_dense : DenseRange â‡‘e\nh_e : IsUniformInducing â‡‘e\nx : E\nâŠ¢ Eq ((f.extend e h_dense h_e) (e x)) (f x)","decl":"@[simp]\ntheorem extend_eq (x : E) : extend f e h_dense h_e (e x) = f x :=\n  IsDenseInducing.extend_eq (h_e.isDenseInducing h_dense) f.cont _\n\n"}
{"name":"ContinuousLinearMap.extend_unique","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\nFâ‚— : Type u_5\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedAddCommGroup Fâ‚—\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\ninstâœ : CompleteSpace F\ne : ContinuousLinearMap (RingHom.id ğ•œ) E Fâ‚—\nh_dense : DenseRange â‡‘e\nh_e : IsUniformInducing â‡‘e\ng : ContinuousLinearMap Ïƒâ‚â‚‚ Fâ‚— F\nH : Eq (g.comp e) f\nâŠ¢ Eq (f.extend e h_dense h_e) g","decl":"theorem extend_unique (g : Fâ‚— â†’SL[Ïƒâ‚â‚‚] F) (H : g.comp e = f) : extend f e h_dense h_e = g :=\n  ContinuousLinearMap.coeFn_injective <|\n    uniformly_extend_unique h_e h_dense (ContinuousLinearMap.ext_iff.1 H) g.continuous\n\n"}
{"name":"ContinuousLinearMap.extend_zero","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\nFâ‚— : Type u_5\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedAddCommGroup Fâ‚—\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : CompleteSpace F\ne : ContinuousLinearMap (RingHom.id ğ•œ) E Fâ‚—\nh_dense : DenseRange â‡‘e\nh_e : IsUniformInducing â‡‘e\nâŠ¢ Eq (ContinuousLinearMap.extend 0 e h_dense h_e) 0","decl":"@[simp]\ntheorem extend_zero : extend (0 : E â†’SL[Ïƒâ‚â‚‚] F) e h_dense h_e = 0 :=\n  extend_unique _ _ _ _ _ (zero_comp _)\n\n"}
{"name":"ContinuousLinearMap.opNorm_extend_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\nFâ‚— : Type u_5\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : NormedAddCommGroup Fâ‚—\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œ Fâ‚—\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\ninstâœÂ¹ : CompleteSpace F\ne : ContinuousLinearMap (RingHom.id ğ•œ) E Fâ‚—\nh_dense : DenseRange â‡‘e\nN : NNReal\nh_e : âˆ€ (x : E), LE.le (Norm.norm x) (HMul.hMul (â†‘N) (Norm.norm (e x)))\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nâŠ¢ LE.le (Norm.norm (f.extend e h_dense â‹¯)) (HMul.hMul (â†‘N) (Norm.norm f))","decl":"/-- If a dense embedding `e : E â†’L[ğ•œ] G` expands the norm by a constant factor `Nâ»Â¹`, then the\nnorm of the extension of `f` along `e` is bounded by `N * â€–fâ€–`. -/\ntheorem opNorm_extend_le :\n    â€–f.extend e h_dense (isUniformEmbedding_of_bound _ h_e).isUniformInducingâ€– â‰¤ N * â€–fâ€– := by\n  -- Add `opNorm_le_of_dense`?\n  refine opNorm_le_bound _ ?_ (isClosed_property h_dense (isClosed_le ?_ ?_) fun x â†¦ ?_)\n  Â· cases le_total 0 N with\n    | inl hN => exact mul_nonneg hN (norm_nonneg _)\n    | inr hN =>\n      have : Unique E := âŸ¨âŸ¨0âŸ©, fun x â†¦ norm_le_zero_iff.mp <|\n        (h_e x).trans (mul_nonpos_of_nonpos_of_nonneg hN (norm_nonneg _))âŸ©\n      obtain rfl : f = 0 := Subsingleton.elim ..\n      simp\n  Â· exact (cont _).norm\n  Â· exact continuous_const.mul continuous_norm\n  Â· rw [extend_eq]\n    calc\n      â€–f xâ€– â‰¤ â€–fâ€– * â€–xâ€– := le_opNorm _ _\n      _ â‰¤ â€–fâ€– * (N * â€–e xâ€–) := mul_le_mul_of_nonneg_left (h_e x) (norm_nonneg _)\n      _ â‰¤ N * â€–fâ€– * â€–e xâ€– := by rw [mul_comm â†‘N â€–fâ€–, mul_assoc]\n\n\n"}
