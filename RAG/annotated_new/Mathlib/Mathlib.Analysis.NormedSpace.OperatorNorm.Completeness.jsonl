{"name":"ContinuousLinearMap.ofMemClosureImageCoeBounded_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nF : Type u_4\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nE' : Type u_6\ninst✝² : SeminormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\ninst✝ : RingHomIsometric σ₁₂\nf : E' → F\ns : Set (ContinuousLinearMap σ₁₂ E' F)\nhs : Bornology.IsBounded s\nhf : Membership.mem (closure (Set.image DFunLike.coe s)) f\n⊢ Eq (⇑(ContinuousLinearMap.ofMemClosureImageCoeBounded f hs hf)) f","decl":"/-- Construct a bundled continuous (semi)linear map from a map `f : E → F` and a proof of the fact\nthat it belongs to the closure of the image of a bounded set `s : Set (E →SL[σ₁₂] F)` under coercion\nto function. Coercion to function of the result is definitionally equal to `f`. -/\n@[simps! (config := .asFn) apply]\ndef ofMemClosureImageCoeBounded (f : E' → F) {s : Set (E' →SL[σ₁₂] F)} (hs : IsBounded s)\n    (hf : f ∈ closure (((↑) : (E' →SL[σ₁₂] F) → E' → F) '' s)) : E' →SL[σ₁₂] F := by\n  -- `f` is a linear map due to `linearMapOfMemClosureRangeCoe`\n  refine (linearMapOfMemClosureRangeCoe f ?_).mkContinuousOfExistsBound ?_\n  · refine closure_mono (image_subset_iff.2 fun g _ => ?_) hf\n    exact ⟨g, rfl⟩\n  · -- We need to show that `f` has bounded norm. Choose `C` such that `‖g‖ ≤ C` for all `g ∈ s`.\n    rcases isBounded_iff_forall_norm_le.1 hs with ⟨C, hC⟩\n    -- Then `‖g x‖ ≤ C * ‖x‖` for all `g ∈ s`, `x : E`, hence `‖f x‖ ≤ C * ‖x‖` for all `x`.\n    have : ∀ x, IsClosed { g : E' → F | ‖g x‖ ≤ C * ‖x‖ } := fun x =>\n      isClosed_Iic.preimage (@continuous_apply E' (fun _ => F) _ x).norm\n    refine ⟨C, fun x => (this x).closure_subset_iff.2 (image_subset_iff.2 fun g hg => ?_) hf⟩\n    exact g.le_of_opNorm_le (hC _ hg) _\n\n"}
{"name":"ContinuousLinearMap.ofTendstoOfBoundedRange_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nE' : Type u_6\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\ninst✝¹ : RingHomIsometric σ₁₂\nα : Type u_7\nl : Filter α\ninst✝ : l.NeBot\nf : E' → F\ng : α → ContinuousLinearMap σ₁₂ E' F\nhf : Filter.Tendsto (fun a x => (g a) x) l (nhds f)\nhg : Bornology.IsBounded (Set.range g)\n⊢ Eq (⇑(ContinuousLinearMap.ofTendstoOfBoundedRange f g hf hg)) f","decl":"/-- Let `f : E → F` be a map, let `g : α → E →SL[σ₁₂] F` be a family of continuous (semi)linear maps\nthat takes values in a bounded set and converges to `f` pointwise along a nontrivial filter. Then\n`f` is a continuous (semi)linear map. -/\n@[simps! (config := .asFn) apply]\ndef ofTendstoOfBoundedRange {α : Type*} {l : Filter α} [l.NeBot] (f : E' → F)\n    (g : α → E' →SL[σ₁₂] F) (hf : Tendsto (fun a x => g a x) l (𝓝 f))\n    (hg : IsBounded (Set.range g)) : E' →SL[σ₁₂] F :=\n  ofMemClosureImageCoeBounded f hg <| mem_closure_of_tendsto hf <|\n    Eventually.of_forall fun _ => mem_image_of_mem _ <| Set.mem_range_self _\n\n"}
{"name":"ContinuousLinearMap.tendsto_of_tendsto_pointwise_of_cauchySeq","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nF : Type u_4\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nE' : Type u_6\ninst✝² : SeminormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\ninst✝ : RingHomIsometric σ₁₂\nf : Nat → ContinuousLinearMap σ₁₂ E' F\ng : ContinuousLinearMap σ₁₂ E' F\nhg : Filter.Tendsto (fun n x => (f n) x) Filter.atTop (nhds ⇑g)\nhf : CauchySeq f\n⊢ Filter.Tendsto f Filter.atTop (nhds g)","decl":"/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem tendsto_of_tendsto_pointwise_of_cauchySeq {f : ℕ → E' →SL[σ₁₂] F} {g : E' →SL[σ₁₂] F}\n    (hg : Tendsto (fun n x => f n x) atTop (𝓝 g)) (hf : CauchySeq f) : Tendsto f atTop (𝓝 g) := by\n  /- Since `f` is a Cauchy sequence, there exists `b → 0` such that `‖f n - f m‖ ≤ b N` for any\n    `m, n ≥ N`. -/\n  rcases cauchySeq_iff_le_tendsto_0.1 hf with ⟨b, hb₀, hfb, hb_lim⟩\n  -- Since `b → 0`, it suffices to show that `‖f n x - g x‖ ≤ b n * ‖x‖` for all `n` and `x`.\n  suffices ∀ n x, ‖f n x - g x‖ ≤ b n * ‖x‖ from\n    tendsto_iff_norm_sub_tendsto_zero.2\n    (squeeze_zero (fun n => norm_nonneg _) (fun n => opNorm_le_bound _ (hb₀ n) (this n)) hb_lim)\n  intro n x\n  -- Note that `f m x → g x`, hence `‖f n x - f m x‖ → ‖f n x - g x‖` as `m → ∞`\n  have : Tendsto (fun m => ‖f n x - f m x‖) atTop (𝓝 ‖f n x - g x‖) :=\n    (tendsto_const_nhds.sub <| tendsto_pi_nhds.1 hg _).norm\n  -- Thus it suffices to verify `‖f n x - f m x‖ ≤ b n * ‖x‖` for `m ≥ n`.\n  refine le_of_tendsto this (eventually_atTop.2 ⟨n, fun m hm => ?_⟩)\n  -- This inequality follows from `‖f n - f m‖ ≤ b n`.\n  exact (f n - f m).le_of_opNorm_le (hfb _ _ _ le_rfl hm) _\n\n"}
{"name":"ContinuousLinearMap.instCompleteSpace_1","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nF : Type u_4\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nE' : Type u_6\ninst✝² : SeminormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\ninst✝ : CompleteSpace F\n⊢ CompleteSpace (ContinuousLinearMap σ₁₂ E' F)","decl":"/-- If the target space is complete, the space of continuous linear maps with its norm is also\ncomplete. This works also if the source space is seminormed. -/\ninstance [CompleteSpace F] : CompleteSpace (E' →SL[σ₁₂] F) := by\n  -- We show that every Cauchy sequence converges.\n  refine Metric.complete_of_cauchySeq_tendsto fun f hf => ?_\n  -- The evaluation at any point `v : E` is Cauchy.\n  have cau : ∀ v, CauchySeq fun n => f n v := fun v => hf.map (lipschitz_apply v).uniformContinuous\n  -- We assemble the limits points of those Cauchy sequences\n  -- (which exist as `F` is complete)\n  -- into a function which we call `G`.\n  choose G hG using fun v => cauchySeq_tendsto_of_complete (cau v)\n  -- Next, we show that this `G` is a continuous linear map.\n  -- This is done in `ContinuousLinearMap.ofTendstoOfBoundedRange`.\n  set Glin : E' →SL[σ₁₂] F :=\n    ofTendstoOfBoundedRange _ _ (tendsto_pi_nhds.mpr hG) hf.isBounded_range\n  -- Finally, `f n` converges to `Glin` in norm because of\n  -- `ContinuousLinearMap.tendsto_of_tendsto_pointwise_of_cauchySeq`\n  exact ⟨Glin, tendsto_of_tendsto_pointwise_of_cauchySeq (tendsto_pi_nhds.2 hG) hf⟩\n\n"}
{"name":"ContinuousLinearMap.isCompact_closure_image_coe_of_bounded","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nE' : Type u_6\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : ProperSpace F\ns : Set (ContinuousLinearMap σ₁₂ E' F)\nhb : Bornology.IsBounded s\n⊢ IsCompact (closure (Set.image DFunLike.coe s))","decl":"/-- Let `s` be a bounded set in the space of continuous (semi)linear maps `E →SL[σ] F` taking values\nin a proper space. Then `s` interpreted as a set in the space of maps `E → F` with topology of\npointwise convergence is precompact: its closure is a compact set. -/\ntheorem isCompact_closure_image_coe_of_bounded [ProperSpace F] {s : Set (E' →SL[σ₁₂] F)}\n    (hb : IsBounded s) : IsCompact (closure (((↑) : (E' →SL[σ₁₂] F) → E' → F) '' s)) :=\n  have : ∀ x, IsCompact (closure (apply' F σ₁₂ x '' s)) := fun x =>\n    ((apply' F σ₁₂ x).lipschitz.isBounded_image hb).isCompact_closure\n  (isCompact_pi_infinite this).closure_of_subset\n    (image_subset_iff.2 fun _ hg _ => subset_closure <| mem_image_of_mem _ hg)\n\n"}
{"name":"ContinuousLinearMap.isCompact_image_coe_of_bounded_of_closed_image","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nE' : Type u_6\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : ProperSpace F\ns : Set (ContinuousLinearMap σ₁₂ E' F)\nhb : Bornology.IsBounded s\nhc : IsClosed (Set.image DFunLike.coe s)\n⊢ IsCompact (Set.image DFunLike.coe s)","decl":"/-- Let `s` be a bounded set in the space of continuous (semi)linear maps `E →SL[σ] F` taking values\nin a proper space. If `s` interpreted as a set in the space of maps `E → F` with topology of\npointwise convergence is closed, then it is compact.\n\nTODO: reformulate this in terms of a type synonym with the right topology. -/\ntheorem isCompact_image_coe_of_bounded_of_closed_image [ProperSpace F] {s : Set (E' →SL[σ₁₂] F)}\n    (hb : IsBounded s) (hc : IsClosed (((↑) : (E' →SL[σ₁₂] F) → E' → F) '' s)) :\n    IsCompact (((↑) : (E' →SL[σ₁₂] F) → E' → F) '' s) :=\n  hc.closure_eq ▸ isCompact_closure_image_coe_of_bounded hb\n\n"}
{"name":"ContinuousLinearMap.isClosed_image_coe_of_bounded_of_weak_closed","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nF : Type u_4\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nE' : Type u_6\ninst✝² : SeminormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\ninst✝ : RingHomIsometric σ₁₂\ns : Set (ContinuousLinearMap σ₁₂ E' F)\nhb : Bornology.IsBounded s\nhc : ∀ (f : ContinuousLinearMap σ₁₂ E' F), Membership.mem (closure (Set.image DFunLike.coe s)) ⇑f → Membership.mem s f\n⊢ IsClosed (Set.image DFunLike.coe s)","decl":"/-- If a set `s` of semilinear functions is bounded and is closed in the weak-* topology, then its\nimage under coercion to functions `E → F` is a closed set. We don't have a name for `E →SL[σ] F`\nwith weak-* topology in `mathlib`, so we use an equivalent condition (see `isClosed_induced_iff'`).\n\nTODO: reformulate this in terms of a type synonym with the right topology. -/\ntheorem isClosed_image_coe_of_bounded_of_weak_closed {s : Set (E' →SL[σ₁₂] F)} (hb : IsBounded s)\n    (hc : ∀ f : E' →SL[σ₁₂] F,\n      (⇑f : E' → F) ∈ closure (((↑) : (E' →SL[σ₁₂] F) → E' → F) '' s) → f ∈ s) :\n    IsClosed (((↑) : (E' →SL[σ₁₂] F) → E' → F) '' s) :=\n  isClosed_of_closure_subset fun f hf =>\n    ⟨ofMemClosureImageCoeBounded f hb hf, hc (ofMemClosureImageCoeBounded f hb hf) hf, rfl⟩\n\n"}
{"name":"ContinuousLinearMap.isCompact_image_coe_of_bounded_of_weak_closed","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nE' : Type u_6\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : ProperSpace F\ns : Set (ContinuousLinearMap σ₁₂ E' F)\nhb : Bornology.IsBounded s\nhc : ∀ (f : ContinuousLinearMap σ₁₂ E' F), Membership.mem (closure (Set.image DFunLike.coe s)) ⇑f → Membership.mem s f\n⊢ IsCompact (Set.image DFunLike.coe s)","decl":"/-- If a set `s` of semilinear functions is bounded and is closed in the weak-* topology, then its\nimage under coercion to functions `E → F` is a compact set. We don't have a name for `E →SL[σ] F`\nwith weak-* topology in `mathlib`, so we use an equivalent condition (see `isClosed_induced_iff'`).\n-/\ntheorem isCompact_image_coe_of_bounded_of_weak_closed [ProperSpace F] {s : Set (E' →SL[σ₁₂] F)}\n    (hb : IsBounded s) (hc : ∀ f : E' →SL[σ₁₂] F,\n      (⇑f : E' → F) ∈ closure (((↑) : (E' →SL[σ₁₂] F) → E' → F) '' s) → f ∈ s) :\n    IsCompact (((↑) : (E' →SL[σ₁₂] F) → E' → F) '' s) :=\n  isCompact_image_coe_of_bounded_of_closed_image hb <|\n    isClosed_image_coe_of_bounded_of_weak_closed hb hc\n\n"}
{"name":"ContinuousLinearMap.is_weak_closed_closedBall","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nF : Type u_4\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nE' : Type u_6\ninst✝² : SeminormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\ninst✝ : RingHomIsometric σ₁₂\nf₀ : ContinuousLinearMap σ₁₂ E' F\nr : Real\nf : ContinuousLinearMap σ₁₂ E' F\nhf : Membership.mem (closure (Set.image DFunLike.coe (Metric.closedBall f₀ r))) ⇑f\n⊢ Membership.mem (Metric.closedBall f₀ r) f","decl":"/-- A closed ball is closed in the weak-* topology. We don't have a name for `E →SL[σ] F` with\nweak-* topology in `mathlib`, so we use an equivalent condition (see `isClosed_induced_iff'`). -/\ntheorem is_weak_closed_closedBall (f₀ : E' →SL[σ₁₂] F) (r : ℝ) ⦃f : E' →SL[σ₁₂] F⦄\n    (hf : ⇑f ∈ closure (((↑) : (E' →SL[σ₁₂] F) → E' → F) '' closedBall f₀ r)) :\n    f ∈ closedBall f₀ r := by\n  have hr : 0 ≤ r := nonempty_closedBall.1 (closure_nonempty_iff.1 ⟨_, hf⟩).of_image\n  refine mem_closedBall_iff_norm.2 (opNorm_le_bound _ hr fun x => ?_)\n  have : IsClosed { g : E' → F | ‖g x - f₀ x‖ ≤ r * ‖x‖ } :=\n    isClosed_Iic.preimage ((@continuous_apply E' (fun _ => F) _ x).sub continuous_const).norm\n  refine this.closure_subset_iff.2 (image_subset_iff.2 fun g hg => ?_) hf\n  exact (g - f₀).le_of_opNorm_le (mem_closedBall_iff_norm.1 hg) _\n\n"}
{"name":"ContinuousLinearMap.isClosed_image_coe_closedBall","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf₀ : ContinuousLinearMap σ₁₂ E F\nr : Real\n⊢ IsClosed (Set.image DFunLike.coe (Metric.closedBall f₀ r))","decl":"/-- The set of functions `f : E → F` that represent continuous linear maps `f : E →SL[σ₁₂] F`\nat distance `≤ r` from `f₀ : E →SL[σ₁₂] F` is closed in the topology of pointwise convergence.\nThis is one of the key steps in the proof of the **Banach-Alaoglu** theorem. -/\ntheorem isClosed_image_coe_closedBall (f₀ : E →SL[σ₁₂] F) (r : ℝ) :\n    IsClosed (((↑) : (E →SL[σ₁₂] F) → E → F) '' closedBall f₀ r) :=\n  isClosed_image_coe_of_bounded_of_weak_closed isBounded_closedBall (is_weak_closed_closedBall f₀ r)\n\n"}
{"name":"ContinuousLinearMap.isCompact_image_coe_closedBall","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : ProperSpace F\nf₀ : ContinuousLinearMap σ₁₂ E F\nr : Real\n⊢ IsCompact (Set.image DFunLike.coe (Metric.closedBall f₀ r))","decl":"/-- **Banach-Alaoglu** theorem. The set of functions `f : E → F` that represent continuous linear\nmaps `f : E →SL[σ₁₂] F` at distance `≤ r` from `f₀ : E →SL[σ₁₂] F` is compact in the topology of\npointwise convergence. Other versions of this theorem can be found in\n`Analysis.Normed.Module.WeakDual`. -/\ntheorem isCompact_image_coe_closedBall [ProperSpace F] (f₀ : E →SL[σ₁₂] F) (r : ℝ) :\n    IsCompact (((↑) : (E →SL[σ₁₂] F) → E → F) '' closedBall f₀ r) :=\n  isCompact_image_coe_of_bounded_of_weak_closed isBounded_closedBall <|\n    is_weak_closed_closedBall f₀ r\n\n"}
{"name":"ContinuousLinearMap.extend_eq","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\nFₗ : Type u_5\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedAddCommGroup Fₗ\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\ninst✝¹ : NormedSpace 𝕜 Fₗ\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\ninst✝ : CompleteSpace F\ne : ContinuousLinearMap (RingHom.id 𝕜) E Fₗ\nh_dense : DenseRange ⇑e\nh_e : IsUniformInducing ⇑e\nx : E\n⊢ Eq ((f.extend e h_dense h_e) (e x)) (f x)","decl":"@[simp]\ntheorem extend_eq (x : E) : extend f e h_dense h_e (e x) = f x :=\n  IsDenseInducing.extend_eq (h_e.isDenseInducing h_dense) f.cont _\n\n"}
{"name":"ContinuousLinearMap.extend_unique","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\nFₗ : Type u_5\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedAddCommGroup Fₗ\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\ninst✝¹ : NormedSpace 𝕜 Fₗ\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\ninst✝ : CompleteSpace F\ne : ContinuousLinearMap (RingHom.id 𝕜) E Fₗ\nh_dense : DenseRange ⇑e\nh_e : IsUniformInducing ⇑e\ng : ContinuousLinearMap σ₁₂ Fₗ F\nH : Eq (g.comp e) f\n⊢ Eq (f.extend e h_dense h_e) g","decl":"theorem extend_unique (g : Fₗ →SL[σ₁₂] F) (H : g.comp e = f) : extend f e h_dense h_e = g :=\n  ContinuousLinearMap.coeFn_injective <|\n    uniformly_extend_unique h_e h_dense (ContinuousLinearMap.ext_iff.1 H) g.continuous\n\n"}
{"name":"ContinuousLinearMap.extend_zero","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\nFₗ : Type u_5\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedAddCommGroup Fₗ\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\ninst✝¹ : NormedSpace 𝕜 Fₗ\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : CompleteSpace F\ne : ContinuousLinearMap (RingHom.id 𝕜) E Fₗ\nh_dense : DenseRange ⇑e\nh_e : IsUniformInducing ⇑e\n⊢ Eq (ContinuousLinearMap.extend 0 e h_dense h_e) 0","decl":"@[simp]\ntheorem extend_zero : extend (0 : E →SL[σ₁₂] F) e h_dense h_e = 0 :=\n  extend_unique _ _ _ _ _ (zero_comp _)\n\n"}
{"name":"ContinuousLinearMap.opNorm_extend_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Completeness","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\nFₗ : Type u_5\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : NormedAddCommGroup Fₗ\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜 Fₗ\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\ninst✝¹ : CompleteSpace F\ne : ContinuousLinearMap (RingHom.id 𝕜) E Fₗ\nh_dense : DenseRange ⇑e\nN : NNReal\nh_e : ∀ (x : E), LE.le (Norm.norm x) (HMul.hMul (↑N) (Norm.norm (e x)))\ninst✝ : RingHomIsometric σ₁₂\n⊢ LE.le (Norm.norm (f.extend e h_dense ⋯)) (HMul.hMul (↑N) (Norm.norm f))","decl":"/-- If a dense embedding `e : E →L[𝕜] G` expands the norm by a constant factor `N⁻¹`, then the\nnorm of the extension of `f` along `e` is bounded by `N * ‖f‖`. -/\ntheorem opNorm_extend_le :\n    ‖f.extend e h_dense (isUniformEmbedding_of_bound _ h_e).isUniformInducing‖ ≤ N * ‖f‖ := by\n  -- Add `opNorm_le_of_dense`?\n  refine opNorm_le_bound _ ?_ (isClosed_property h_dense (isClosed_le ?_ ?_) fun x ↦ ?_)\n  · cases le_total 0 N with\n    | inl hN => exact mul_nonneg hN (norm_nonneg _)\n    | inr hN =>\n      have : Unique E := ⟨⟨0⟩, fun x ↦ norm_le_zero_iff.mp <|\n        (h_e x).trans (mul_nonpos_of_nonpos_of_nonneg hN (norm_nonneg _))⟩\n      obtain rfl : f = 0 := Subsingleton.elim ..\n      simp\n  · exact (cont _).norm\n  · exact continuous_const.mul continuous_norm\n  · rw [extend_eq]\n    calc\n      ‖f x‖ ≤ ‖f‖ * ‖x‖ := le_opNorm _ _\n      _ ≤ ‖f‖ * (N * ‖e x‖) := mul_le_mul_of_nonneg_left (h_e x) (norm_nonneg _)\n      _ ≤ N * ‖f‖ * ‖e x‖ := by rw [mul_comm ↑N ‖f‖, mul_assoc]\n\n\n"}
