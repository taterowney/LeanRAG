{"name":"ENNReal.embedding_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Topology.IsEmbedding ENNReal.ofNNReal","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coe := isEmbedding_coe\n\n"}
{"name":"ENNReal.isOpen_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ IsOpen (setOf fun a => Ne a Top.top)","decl":"theorem isOpen_ne_top : IsOpen { a : ℝ≥0∞ | a ≠ ∞ } := isOpen_ne\n\n"}
{"name":"ENNReal.isOpen_Ico_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"b : ENNReal\n⊢ IsOpen (Set.Ico 0 b)","decl":"theorem isOpen_Ico_zero : IsOpen (Ico 0 b) := by\n  rw [ENNReal.Ico_eq_Iio]\n  exact isOpen_Iio\n\n"}
{"name":"ENNReal.openEmbedding_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Topology.IsOpenEmbedding ENNReal.ofNNReal","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_coe := isOpenEmbedding_coe\n\n"}
{"name":"ENNReal.coe_range_mem_nhds","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\n⊢ Membership.mem (nhds ↑r) (Set.range ENNReal.ofNNReal)","decl":"theorem coe_range_mem_nhds : range ((↑) : ℝ≥0 → ℝ≥0∞) ∈ 𝓝 (r : ℝ≥0∞) :=\n  IsOpen.mem_nhds isOpenEmbedding_coe.isOpen_range <| mem_range_self _\n\n"}
{"name":"ENNReal.continuous_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Continuous ENNReal.ofNNReal","decl":"@[fun_prop]\ntheorem continuous_coe : Continuous ((↑) : ℝ≥0 → ℝ≥0∞) :=\n  isEmbedding_coe.continuous\n\n"}
{"name":"ENNReal.continuous_coe_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\ninst✝ : TopologicalSpace α\nf : α → NNReal\n⊢ Iff (Continuous fun a => ↑(f a)) (Continuous f)","decl":"theorem continuous_coe_iff {α} [TopologicalSpace α] {f : α → ℝ≥0} :\n    (Continuous fun a => (f a : ℝ≥0∞)) ↔ Continuous f :=\n  isEmbedding_coe.continuous_iff.symm\n\n"}
{"name":"ENNReal.nhds_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\n⊢ Eq (nhds ↑r) (Filter.map ENNReal.ofNNReal (nhds r))","decl":"theorem nhds_coe {r : ℝ≥0} : 𝓝 (r : ℝ≥0∞) = (𝓝 r).map (↑) :=\n  (isOpenEmbedding_coe.map_nhds_eq r).symm\n\n"}
{"name":"ENNReal.tendsto_nhds_coe_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\nl : Filter α\nx : NNReal\nf : ENNReal → α\n⊢ Iff (Filter.Tendsto f (nhds ↑x) l) (Filter.Tendsto (Function.comp f ENNReal.ofNNReal) (nhds x) l)","decl":"theorem tendsto_nhds_coe_iff {α : Type*} {l : Filter α} {x : ℝ≥0} {f : ℝ≥0∞ → α} :\n    Tendsto f (𝓝 ↑x) l ↔ Tendsto (f ∘ (↑) : ℝ≥0 → α) (𝓝 x) l := by\n  rw [nhds_coe, tendsto_map'_iff]\n\n"}
{"name":"ENNReal.continuousAt_coe_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\ninst✝ : TopologicalSpace α\nx : NNReal\nf : ENNReal → α\n⊢ Iff (ContinuousAt f ↑x) (ContinuousAt (Function.comp f ENNReal.ofNNReal) x)","decl":"theorem continuousAt_coe_iff {α : Type*} [TopologicalSpace α] {x : ℝ≥0} {f : ℝ≥0∞ → α} :\n    ContinuousAt f ↑x ↔ ContinuousAt (f ∘ (↑) : ℝ≥0 → α) x :=\n  tendsto_nhds_coe_iff\n\n"}
{"name":"ENNReal.continuous_ofReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Continuous ENNReal.ofReal","decl":"theorem continuous_ofReal : Continuous ENNReal.ofReal :=\n  (continuous_coe_iff.2 continuous_id).comp continuous_real_toNNReal\n\n"}
{"name":"ENNReal.tendsto_ofReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nm : α → Real\na : Real\nh : Filter.Tendsto m f (nhds a)\n⊢ Filter.Tendsto (fun a => ENNReal.ofReal (m a)) f (nhds (ENNReal.ofReal a))","decl":"theorem tendsto_ofReal {f : Filter α} {m : α → ℝ} {a : ℝ} (h : Tendsto m f (𝓝 a)) :\n    Tendsto (fun a => ENNReal.ofReal (m a)) f (𝓝 (ENNReal.ofReal a)) :=\n  (continuous_ofReal.tendsto a).comp h\n\n"}
{"name":"ENNReal.tendsto_toNNReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nha : Ne a Top.top\n⊢ Filter.Tendsto ENNReal.toNNReal (nhds a) (nhds a.toNNReal)","decl":"theorem tendsto_toNNReal {a : ℝ≥0∞} (ha : a ≠ ∞) :\n    Tendsto ENNReal.toNNReal (𝓝 a) (𝓝 a.toNNReal) := by\n  lift a to ℝ≥0 using ha\n  rw [nhds_coe, tendsto_map'_iff]\n  exact tendsto_id\n\n"}
{"name":"ENNReal.eventuallyEq_of_toReal_eventuallyEq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nl : Filter α\nf g : α → ENNReal\nhfi : Filter.Eventually (fun x => Ne (f x) Top.top) l\nhgi : Filter.Eventually (fun x => Ne (g x) Top.top) l\nhfg : l.EventuallyEq (fun x => (f x).toReal) fun x => (g x).toReal\n⊢ l.EventuallyEq f g","decl":"theorem eventuallyEq_of_toReal_eventuallyEq {l : Filter α} {f g : α → ℝ≥0∞}\n    (hfi : ∀ᶠ x in l, f x ≠ ∞) (hgi : ∀ᶠ x in l, g x ≠ ∞)\n    (hfg : (fun x => (f x).toReal) =ᶠ[l] fun x => (g x).toReal) : f =ᶠ[l] g := by\n  filter_upwards [hfi, hgi, hfg] with _ hfx hgx _\n  rwa [← ENNReal.toReal_eq_toReal hfx hgx]\n\n"}
{"name":"ENNReal.continuousOn_toNNReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ ContinuousOn ENNReal.toNNReal (setOf fun a => Ne a Top.top)","decl":"theorem continuousOn_toNNReal : ContinuousOn ENNReal.toNNReal { a | a ≠ ∞ } := fun _a ha =>\n  ContinuousAt.continuousWithinAt (tendsto_toNNReal ha)\n\n"}
{"name":"ENNReal.tendsto_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nha : Ne a Top.top\n⊢ Filter.Tendsto ENNReal.toReal (nhds a) (nhds a.toReal)","decl":"theorem tendsto_toReal {a : ℝ≥0∞} (ha : a ≠ ∞) : Tendsto ENNReal.toReal (𝓝 a) (𝓝 a.toReal) :=\n  NNReal.tendsto_coe.2 <| tendsto_toNNReal ha\n\n"}
{"name":"ENNReal.continuousOn_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ ContinuousOn ENNReal.toReal (setOf fun a => Ne a Top.top)","decl":"lemma continuousOn_toReal : ContinuousOn ENNReal.toReal { a | a ≠ ∞ } :=\n  NNReal.continuous_coe.comp_continuousOn continuousOn_toNNReal\n\n"}
{"name":"ENNReal.continuousAt_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\nhx : Ne x Top.top\n⊢ ContinuousAt ENNReal.toReal x","decl":"lemma continuousAt_toReal (hx : x ≠ ∞) : ContinuousAt ENNReal.toReal x :=\n  continuousOn_toReal.continuousAt (isOpen_ne_top.mem_nhds_iff.mpr hx)\n\n"}
{"name":"ENNReal.nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Eq (nhds Top.top) (iInf fun a => iInf fun x => Filter.principal (Set.Ioi a))","decl":"theorem nhds_top : 𝓝 ∞ = ⨅ (a) (_ : a ≠ ∞), 𝓟 (Ioi a) :=\n  nhds_top_order.trans <| by simp [lt_top_iff_ne_top, Ioi]\n\n"}
{"name":"ENNReal.nhds_top'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Eq (nhds Top.top) (iInf fun r => Filter.principal (Set.Ioi ↑r))","decl":"theorem nhds_top' : 𝓝 ∞ = ⨅ r : ℝ≥0, 𝓟 (Ioi ↑r) :=\n  nhds_top.trans <| iInf_ne_top _\n\n"}
{"name":"ENNReal.nhds_top_basis","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ (nhds Top.top).HasBasis (fun a => LT.lt a Top.top) fun a => Set.Ioi a","decl":"theorem nhds_top_basis : (𝓝 ∞).HasBasis (fun a => a < ∞) fun a => Ioi a :=\n  _root_.nhds_top_basis\n\n"}
{"name":"ENNReal.tendsto_nhds_top_iff_nnreal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nm : α → ENNReal\nf : Filter α\n⊢ Iff (Filter.Tendsto m f (nhds Top.top)) (∀ (x : NNReal), Filter.Eventually (fun a => LT.lt (↑x) (m a)) f)","decl":"theorem tendsto_nhds_top_iff_nnreal {m : α → ℝ≥0∞} {f : Filter α} :\n    Tendsto m f (𝓝 ∞) ↔ ∀ x : ℝ≥0, ∀ᶠ a in f, ↑x < m a := by\n  simp only [nhds_top', tendsto_iInf, tendsto_principal, mem_Ioi]\n\n"}
{"name":"ENNReal.tendsto_nhds_top_iff_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nm : α → ENNReal\nf : Filter α\n⊢ Iff (Filter.Tendsto m f (nhds Top.top)) (∀ (n : Nat), Filter.Eventually (fun a => LT.lt (↑n) (m a)) f)","decl":"theorem tendsto_nhds_top_iff_nat {m : α → ℝ≥0∞} {f : Filter α} :\n    Tendsto m f (𝓝 ∞) ↔ ∀ n : ℕ, ∀ᶠ a in f, ↑n < m a :=\n  tendsto_nhds_top_iff_nnreal.trans\n    ⟨fun h n => by simpa only [ENNReal.coe_natCast] using h n, fun h x =>\n      let ⟨n, hn⟩ := exists_nat_gt x\n      (h n).mono fun _ => lt_trans <| by rwa [← ENNReal.coe_natCast, coe_lt_coe]⟩\n\n"}
{"name":"ENNReal.tendsto_nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nm : α → ENNReal\nf : Filter α\nh : ∀ (n : Nat), Filter.Eventually (fun a => LT.lt (↑n) (m a)) f\n⊢ Filter.Tendsto m f (nhds Top.top)","decl":"theorem tendsto_nhds_top {m : α → ℝ≥0∞} {f : Filter α} (h : ∀ n : ℕ, ∀ᶠ a in f, ↑n < m a) :\n    Tendsto m f (𝓝 ∞) :=\n  tendsto_nhds_top_iff_nat.2 h\n\n"}
{"name":"ENNReal.tendsto_nat_nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Filter.Tendsto (fun n => ↑n) Filter.atTop (nhds Top.top)","decl":"theorem tendsto_nat_nhds_top : Tendsto (fun n : ℕ => ↑n) atTop (𝓝 ∞) :=\n  tendsto_nhds_top fun n =>\n    mem_atTop_sets.2 ⟨n + 1, fun _m hm => mem_setOf.2 <| Nat.cast_lt.2 <| Nat.lt_of_succ_le hm⟩\n\n"}
{"name":"ENNReal.tendsto_coe_nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → NNReal\nl : Filter α\n⊢ Iff (Filter.Tendsto (fun x => ↑(f x)) l (nhds Top.top)) (Filter.Tendsto f l Filter.atTop)","decl":"@[simp, norm_cast]\ntheorem tendsto_coe_nhds_top {f : α → ℝ≥0} {l : Filter α} :\n    Tendsto (fun x => (f x : ℝ≥0∞)) l (𝓝 ∞) ↔ Tendsto f l atTop := by\n  rw [tendsto_nhds_top_iff_nnreal, atTop_basis_Ioi.tendsto_right_iff]; simp\n\n"}
{"name":"ENNReal.tendsto_ofReal_nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → Real\nl : Filter α\n⊢ Iff (Filter.Tendsto (fun x => ENNReal.ofReal (f x)) l (nhds Top.top)) (Filter.Tendsto f l Filter.atTop)","decl":"@[simp]\ntheorem tendsto_ofReal_nhds_top {f : α → ℝ} {l : Filter α} :\n    Tendsto (fun x ↦ ENNReal.ofReal (f x)) l (𝓝 ∞) ↔ Tendsto f l atTop :=\n  tendsto_coe_nhds_top.trans Real.tendsto_toNNReal_atTop_iff\n\n"}
{"name":"ENNReal.tendsto_ofReal_atTop","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Filter.Tendsto ENNReal.ofReal Filter.atTop (nhds Top.top)","decl":"theorem tendsto_ofReal_atTop : Tendsto ENNReal.ofReal atTop (𝓝 ∞) :=\n  tendsto_ofReal_nhds_top.2 tendsto_id\n\n"}
{"name":"ENNReal.nhds_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Eq (nhds 0) (iInf fun a => iInf fun x => Filter.principal (Set.Iio a))","decl":"theorem nhds_zero : 𝓝 (0 : ℝ≥0∞) = ⨅ (a) (_ : a ≠ 0), 𝓟 (Iio a) :=\n  nhds_bot_order.trans <| by simp [pos_iff_ne_zero, Iio]\n\n"}
{"name":"ENNReal.nhds_zero_basis","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ (nhds 0).HasBasis (fun a => LT.lt 0 a) fun a => Set.Iio a","decl":"theorem nhds_zero_basis : (𝓝 (0 : ℝ≥0∞)).HasBasis (fun a : ℝ≥0∞ => 0 < a) fun a => Iio a :=\n  nhds_bot_basis\n\n"}
{"name":"ENNReal.nhds_zero_basis_Iic","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ (nhds 0).HasBasis (fun a => LT.lt 0 a) Set.Iic","decl":"theorem nhds_zero_basis_Iic : (𝓝 (0 : ℝ≥0∞)).HasBasis (fun a : ℝ≥0∞ => 0 < a) Iic :=\n  nhds_bot_basis_Iic\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: add a TC for `≠ ∞`?\n"}
{"name":"ENNReal.nhdsGT_coe_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\n⊢ (nhdsWithin (↑r) (Set.Ioi ↑r)).NeBot","decl":"@[instance]\ntheorem nhdsGT_coe_neBot {r : ℝ≥0} : (𝓝[>] (r : ℝ≥0∞)).NeBot :=\n  nhdsGT_neBot_of_exists_gt ⟨∞, ENNReal.coe_lt_top⟩\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_coe_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\n⊢ (nhdsWithin (↑r) (Set.Ioi ↑r)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_coe_neBot := nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsGT_zero_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ (nhdsWithin 0 (Set.Ioi 0)).NeBot","decl":"@[instance] theorem nhdsGT_zero_neBot : (𝓝[>] (0 : ℝ≥0∞)).NeBot := nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_zero_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ (nhdsWithin 0 (Set.Ioi 0)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_zero_neBot := nhdsGT_zero_neBot\n\n"}
{"name":"ENNReal.nhdsGT_one_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ (nhdsWithin 1 (Set.Ioi 1)).NeBot","decl":"@[instance] theorem nhdsGT_one_neBot : (𝓝[>] (1 : ℝ≥0∞)).NeBot := nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_one_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ (nhdsWithin 1 (Set.Ioi 1)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_one_neBot := nhdsGT_one_neBot\n\n"}
{"name":"ENNReal.nhdsGT_nat_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\n⊢ (nhdsWithin (↑n) (Set.Ioi ↑n)).NeBot","decl":"@[instance] theorem nhdsGT_nat_neBot (n : ℕ) : (𝓝[>] (n : ℝ≥0∞)).NeBot := nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_nat_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\n⊢ (nhdsWithin (↑n) (Set.Ioi ↑n)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_nat_neBot := nhdsGT_nat_neBot\n\n"}
{"name":"ENNReal.nhdsGT_ofNat_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ (nhdsWithin (OfNat.ofNat n) (Set.Ioi (OfNat.ofNat n))).NeBot","decl":"@[instance]\ntheorem nhdsGT_ofNat_neBot (n : ℕ) [n.AtLeastTwo] : (𝓝[>] (OfNat.ofNat n : ℝ≥0∞)).NeBot :=\n  nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_ofNat_nebot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ (nhdsWithin (OfNat.ofNat n) (Set.Ioi (OfNat.ofNat n))).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_ofNat_nebot := nhdsGT_ofNat_neBot\n\n"}
{"name":"ENNReal.nhdsLT_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\ninst✝ : NeZero x\n⊢ (nhdsWithin x (Set.Iio x)).NeBot","decl":"@[instance]\ntheorem nhdsLT_neBot [NeZero x] : (𝓝[<] x).NeBot :=\n  nhdsWithin_Iio_self_neBot' ⟨0, NeZero.pos x⟩\n\n"}
{"name":"ENNReal.nhdsWithin_Iio_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\ninst✝ : NeZero x\n⊢ (nhdsWithin x (Set.Iio x)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Iio_neBot := nhdsLT_neBot\n\n"}
{"name":"ENNReal.hasBasis_nhds_of_ne_top'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\nxt : Ne x Top.top\n⊢ (nhds x).HasBasis (fun x => Ne x 0) fun ε => Set.Icc (HSub.hSub x ε) (HAdd.hAdd x ε)","decl":"/-- Closed intervals `Set.Icc (x - ε) (x + ε)`, `ε ≠ 0`, form a basis of neighborhoods of an\nextended nonnegative real number `x ≠ ∞`. We use `Set.Icc` instead of `Set.Ioo` because this way the\nstatement works for `x = 0`.\n-/\ntheorem hasBasis_nhds_of_ne_top' (xt : x ≠ ∞) :\n    (𝓝 x).HasBasis (· ≠ 0) (fun ε => Icc (x - ε) (x + ε)) := by\n  rcases (zero_le x).eq_or_gt with rfl | x0\n  · simp_rw [zero_tsub, zero_add, ← bot_eq_zero, Icc_bot, ← bot_lt_iff_ne_bot]\n    exact nhds_bot_basis_Iic\n  · refine (nhds_basis_Ioo' ⟨_, x0⟩ ⟨_, xt.lt_top⟩).to_hasBasis ?_ fun ε ε0 => ?_\n    · rintro ⟨a, b⟩ ⟨ha, hb⟩\n      rcases exists_between (tsub_pos_of_lt ha) with ⟨ε, ε0, hε⟩\n      rcases lt_iff_exists_add_pos_lt.1 hb with ⟨δ, δ0, hδ⟩\n      refine ⟨min ε δ, (lt_min ε0 (coe_pos.2 δ0)).ne', Icc_subset_Ioo ?_ ?_⟩\n      · exact lt_tsub_comm.2 ((min_le_left _ _).trans_lt hε)\n      · exact (add_le_add_left (min_le_right _ _) _).trans_lt hδ\n    · exact ⟨(x - ε, x + ε), ⟨ENNReal.sub_lt_self xt x0.ne' ε0,\n        lt_add_right xt ε0⟩, Ioo_subset_Icc_self⟩\n\n"}
{"name":"ENNReal.hasBasis_nhds_of_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\nxt : Ne x Top.top\n⊢ (nhds x).HasBasis (fun x => LT.lt 0 x) fun ε => Set.Icc (HSub.hSub x ε) (HAdd.hAdd x ε)","decl":"theorem hasBasis_nhds_of_ne_top (xt : x ≠ ∞) :\n    (𝓝 x).HasBasis (0 < ·) (fun ε => Icc (x - ε) (x + ε)) := by\n  simpa only [pos_iff_ne_zero] using hasBasis_nhds_of_ne_top' xt\n\n"}
{"name":"ENNReal.Icc_mem_nhds","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x ε : ENNReal\nxt : Ne x Top.top\nε0 : Ne ε 0\n⊢ Membership.mem (nhds x) (Set.Icc (HSub.hSub x ε) (HAdd.hAdd x ε))","decl":"theorem Icc_mem_nhds (xt : x ≠ ∞) (ε0 : ε ≠ 0) : Icc (x - ε) (x + ε) ∈ 𝓝 x :=\n  (hasBasis_nhds_of_ne_top' xt).mem_of_mem ε0\n\n"}
{"name":"ENNReal.nhds_of_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\nxt : Ne x Top.top\n⊢ Eq (nhds x) (iInf fun ε => iInf fun h => Filter.principal (Set.Icc (HSub.hSub x ε) (HAdd.hAdd x ε)))","decl":"theorem nhds_of_ne_top (xt : x ≠ ∞) : 𝓝 x = ⨅ ε > 0, 𝓟 (Icc (x - ε) (x + ε)) :=\n  (hasBasis_nhds_of_ne_top xt).eq_biInf\n\n"}
{"name":"ENNReal.biInf_le_nhds","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\n⊢ LE.le (iInf fun ε => iInf fun h => Filter.principal (Set.Icc (HSub.hSub x ε) (HAdd.hAdd x ε))) (nhds x)","decl":"theorem biInf_le_nhds : ∀ x : ℝ≥0∞, ⨅ ε > 0, 𝓟 (Icc (x - ε) (x + ε)) ≤ 𝓝 x\n  | ∞ => iInf₂_le_of_le 1 one_pos <| by\n    simpa only [← coe_one, top_sub_coe, top_add, Icc_self, principal_singleton] using pure_le_nhds _\n  | (x : ℝ≥0) => (nhds_of_ne_top coe_ne_top).ge\n\n"}
{"name":"ENNReal.tendsto_nhds_of_Icc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nu : α → ENNReal\na : ENNReal\nh : ∀ (ε : ENNReal), GT.gt ε 0 → Filter.Eventually (fun x => Membership.mem (Set.Icc (HSub.hSub a ε) (HAdd.hAdd a ε)) (u x)) f\n⊢ Filter.Tendsto u f (nhds a)","decl":"protected theorem tendsto_nhds_of_Icc {f : Filter α} {u : α → ℝ≥0∞} {a : ℝ≥0∞}\n    (h : ∀ ε > 0, ∀ᶠ x in f, u x ∈ Icc (a - ε) (a + ε)) : Tendsto u f (𝓝 a) := by\n  refine Tendsto.mono_right ?_ (biInf_le_nhds _)\n  simpa only [tendsto_iInf, tendsto_principal]\n\n"}
{"name":"ENNReal.tendsto_nhds","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nu : α → ENNReal\na : ENNReal\nha : Ne a Top.top\n⊢ Iff (Filter.Tendsto u f (nhds a)) (∀ (ε : ENNReal), GT.gt ε 0 → Filter.Eventually (fun x => Membership.mem (Set.Icc (HSub.hSub a ε) (HAdd.hAdd a ε)) (u x)) f)","decl":"/-- Characterization of neighborhoods for `ℝ≥0∞` numbers. See also `tendsto_order`\nfor a version with strict inequalities. -/\nprotected theorem tendsto_nhds {f : Filter α} {u : α → ℝ≥0∞} {a : ℝ≥0∞} (ha : a ≠ ∞) :\n    Tendsto u f (𝓝 a) ↔ ∀ ε > 0, ∀ᶠ x in f, u x ∈ Icc (a - ε) (a + ε) := by\n  simp only [nhds_of_ne_top ha, tendsto_iInf, tendsto_principal]\n\n"}
{"name":"ENNReal.tendsto_nhds_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nu : α → ENNReal\n⊢ Iff (Filter.Tendsto u f (nhds 0)) (∀ (ε : ENNReal), GT.gt ε 0 → Filter.Eventually (fun x => LE.le (u x) ε) f)","decl":"protected theorem tendsto_nhds_zero {f : Filter α} {u : α → ℝ≥0∞} :\n    Tendsto u f (𝓝 0) ↔ ∀ ε > 0, ∀ᶠ x in f, u x ≤ ε :=\n  nhds_zero_basis_Iic.tendsto_right_iff\n\n"}
{"name":"ENNReal.tendsto_const_sub_nhds_zero_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nl : Filter α\nf : α → ENNReal\na : ENNReal\nha : Ne a Top.top\nhfa : ∀ (n : α), LE.le (f n) a\n⊢ Iff (Filter.Tendsto (fun n => HSub.hSub a (f n)) l (nhds 0)) (Filter.Tendsto (fun n => f n) l (nhds a))","decl":"theorem tendsto_const_sub_nhds_zero_iff {l : Filter α} {f : α → ℝ≥0∞} {a : ℝ≥0∞} (ha : a ≠ ∞)\n    (hfa : ∀ n, f n ≤ a) :\n    Tendsto (fun n ↦ a - f n) l (𝓝 0) ↔ Tendsto (fun n ↦ f n) l (𝓝 a) := by\n  rw [ENNReal.tendsto_nhds_zero, ENNReal.tendsto_nhds ha]\n  refine ⟨fun h ε hε ↦ ?_, fun h ε hε ↦ ?_⟩\n  · filter_upwards [h ε hε] with n hn\n    refine ⟨?_, (hfa n).trans (le_add_right le_rfl)⟩\n    rw [tsub_le_iff_right] at hn ⊢\n    rwa [add_comm]\n  · filter_upwards [h ε hε] with n hn\n    have hN_left := hn.1\n    rw [tsub_le_iff_right] at hN_left ⊢\n    rwa [add_comm]\n\n"}
{"name":"ENNReal.tendsto_atTop","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nf : β → ENNReal\na : ENNReal\nha : Ne a Top.top\n⊢ Iff (Filter.Tendsto f Filter.atTop (nhds a)) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun N => ∀ (n : β), GE.ge n N → Membership.mem (Set.Icc (HSub.hSub a ε) (HAdd.hAdd a ε)) (f n))","decl":"protected theorem tendsto_atTop [Nonempty β] [SemilatticeSup β] {f : β → ℝ≥0∞} {a : ℝ≥0∞}\n    (ha : a ≠ ∞) : Tendsto f atTop (𝓝 a) ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, f n ∈ Icc (a - ε) (a + ε) :=\n  .trans (atTop_basis.tendsto_iff (hasBasis_nhds_of_ne_top ha)) (by simp only [true_and]; rfl)\n\n"}
{"name":"ENNReal.tendsto_atTop_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nf : β → ENNReal\n⊢ Iff (Filter.Tendsto f Filter.atTop (nhds 0)) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun N => ∀ (n : β), GE.ge n N → LE.le (f n) ε)","decl":"protected theorem tendsto_atTop_zero [Nonempty β] [SemilatticeSup β] {f : β → ℝ≥0∞} :\n    Tendsto f atTop (𝓝 0) ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, f n ≤ ε :=\n  .trans (atTop_basis.tendsto_iff nhds_zero_basis_Iic) (by simp only [true_and]; rfl)\n\n"}
{"name":"ENNReal.tendsto_atTop_zero_iff_le_of_antitone","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_4\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nf : β → ENNReal\nhf : Antitone f\n⊢ Iff (Filter.Tendsto f Filter.atTop (nhds 0)) (∀ (ε : ENNReal), LT.lt 0 ε → Exists fun n => LE.le (f n) ε)","decl":"theorem tendsto_atTop_zero_iff_le_of_antitone {β : Type*} [Nonempty β] [SemilatticeSup β]\n    {f : β → ℝ≥0∞} (hf : Antitone f) :\n    Filter.Tendsto f Filter.atTop (𝓝 0) ↔ ∀ ε, 0 < ε → ∃ n : β, f n ≤ ε := by\n  rw [ENNReal.tendsto_atTop_zero]\n  refine ⟨fun h ↦ fun ε hε ↦ ?_, fun h ↦ fun ε hε ↦ ?_⟩\n  · obtain ⟨n, hn⟩ := h ε hε\n    exact ⟨n, hn n le_rfl⟩\n  · obtain ⟨n, hn⟩ := h ε hε\n    exact ⟨n, fun m hm ↦ (hf hm).trans hn⟩\n\n"}
{"name":"ENNReal.tendsto_atTop_zero_iff_lt_of_antitone","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_4\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nf : β → ENNReal\nhf : Antitone f\n⊢ Iff (Filter.Tendsto f Filter.atTop (nhds 0)) (∀ (ε : ENNReal), LT.lt 0 ε → Exists fun n => LT.lt (f n) ε)","decl":"theorem tendsto_atTop_zero_iff_lt_of_antitone {β : Type*} [Nonempty β] [SemilatticeSup β]\n    {f : β → ℝ≥0∞} (hf : Antitone f) :\n    Filter.Tendsto f Filter.atTop (𝓝 0) ↔ ∀ ε, 0 < ε → ∃ n : β, f n < ε := by\n  rw [ENNReal.tendsto_atTop_zero_iff_le_of_antitone hf]\n  constructor <;> intro h ε hε\n  · obtain ⟨n, hn⟩ := h (min 1 (ε / 2))\n      (lt_min_iff.mpr ⟨zero_lt_one, (ENNReal.div_pos_iff.mpr ⟨ne_of_gt hε, ENNReal.ofNat_ne_top⟩)⟩)\n    · refine ⟨n, hn.trans_lt ?_⟩\n      by_cases hε_top : ε = ∞\n      · rw [hε_top]\n        exact (min_le_left _ _).trans_lt ENNReal.one_lt_top\n      refine (min_le_right _ _).trans_lt ?_\n      rw [ENNReal.div_lt_iff (Or.inr hε.ne') (Or.inr hε_top)]\n      conv_lhs => rw [← mul_one ε]\n      rw [ENNReal.mul_lt_mul_left hε.ne' hε_top]\n      norm_num\n  · obtain ⟨n, hn⟩ := h ε hε\n    exact ⟨n, hn.le⟩\n\n"}
{"name":"ENNReal.tendsto_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : ENNReal\na✝ : Or (Ne a Top.top) (Ne b Top.top)\n⊢ Filter.Tendsto (fun p => HSub.hSub p.1 p.2) (nhds { fst := a, snd := b }) (nhds (HSub.hSub a b))","decl":"theorem tendsto_sub : ∀ {a b : ℝ≥0∞}, (a ≠ ∞ ∨ b ≠ ∞) →\n    Tendsto (fun p : ℝ≥0∞ × ℝ≥0∞ => p.1 - p.2) (𝓝 (a, b)) (𝓝 (a - b))\n  | ∞, ∞, h => by simp only [ne_eq, not_true_eq_false, or_self] at h\n  | ∞, (b : ℝ≥0), _ => by\n    rw [top_sub_coe, tendsto_nhds_top_iff_nnreal]\n    refine fun x => ((lt_mem_nhds <| @coe_lt_top (b + 1 + x)).prod_nhds\n      (ge_mem_nhds <| coe_lt_coe.2 <| lt_add_one b)).mono fun y hy => ?_\n    rw [lt_tsub_iff_left]\n    calc y.2 + x ≤ ↑(b + 1) + x := add_le_add_right hy.2 _\n    _ < y.1 := hy.1\n  | (a : ℝ≥0), ∞, _ => by\n    rw [sub_top]\n    refine (tendsto_pure.2 ?_).mono_right (pure_le_nhds _)\n    exact ((gt_mem_nhds <| coe_lt_coe.2 <| lt_add_one a).prod_nhds\n      (lt_mem_nhds <| @coe_lt_top (a + 1))).mono fun x hx =>\n        tsub_eq_zero_iff_le.2 (hx.1.trans hx.2).le\n  | (a : ℝ≥0), (b : ℝ≥0), _ => by\n    simp only [nhds_coe_coe, tendsto_map'_iff, ← ENNReal.coe_sub, Function.comp_def, tendsto_coe]\n    exact continuous_sub.tendsto (a, b)\n\n"}
{"name":"ENNReal.Tendsto.sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nma mb : α → ENNReal\na b : ENNReal\nhma : Filter.Tendsto ma f (nhds a)\nhmb : Filter.Tendsto mb f (nhds b)\nh : Or (Ne a Top.top) (Ne b Top.top)\n⊢ Filter.Tendsto (fun a => HSub.hSub (ma a) (mb a)) f (nhds (HSub.hSub a b))","decl":"protected theorem Tendsto.sub {f : Filter α} {ma : α → ℝ≥0∞} {mb : α → ℝ≥0∞} {a b : ℝ≥0∞}\n    (hma : Tendsto ma f (𝓝 a)) (hmb : Tendsto mb f (𝓝 b)) (h : a ≠ ∞ ∨ b ≠ ∞) :\n    Tendsto (fun a => ma a - mb a) f (𝓝 (a - b)) :=\n  show Tendsto ((fun p : ℝ≥0∞ × ℝ≥0∞ => p.1 - p.2) ∘ fun a => (ma a, mb a)) f (𝓝 (a - b)) from\n    Tendsto.comp (ENNReal.tendsto_sub h) (hma.prod_mk_nhds hmb)\n\n"}
{"name":"ENNReal.tendsto_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : ENNReal\nha : Or (Ne a 0) (Ne b Top.top)\nhb : Or (Ne b 0) (Ne a Top.top)\n⊢ Filter.Tendsto (fun p => HMul.hMul p.1 p.2) (nhds { fst := a, snd := b }) (nhds (HMul.hMul a b))","decl":"protected theorem tendsto_mul (ha : a ≠ 0 ∨ b ≠ ∞) (hb : b ≠ 0 ∨ a ≠ ∞) :\n    Tendsto (fun p : ℝ≥0∞ × ℝ≥0∞ => p.1 * p.2) (𝓝 (a, b)) (𝓝 (a * b)) := by\n  have ht : ∀ b : ℝ≥0∞, b ≠ 0 →\n      Tendsto (fun p : ℝ≥0∞ × ℝ≥0∞ => p.1 * p.2) (𝓝 (∞, b)) (𝓝 ∞) := fun b hb => by\n    refine tendsto_nhds_top_iff_nnreal.2 fun n => ?_\n    rcases lt_iff_exists_nnreal_btwn.1 (pos_iff_ne_zero.2 hb) with ⟨ε, hε, hεb⟩\n    have : ∀ᶠ c : ℝ≥0∞ × ℝ≥0∞ in 𝓝 (∞, b), ↑n / ↑ε < c.1 ∧ ↑ε < c.2 :=\n      (lt_mem_nhds <| div_lt_top coe_ne_top hε.ne').prod_nhds (lt_mem_nhds hεb)\n    refine this.mono fun c hc => ?_\n    exact (ENNReal.div_mul_cancel hε.ne' coe_ne_top).symm.trans_lt (mul_lt_mul hc.1 hc.2)\n  induction a with\n  | top => simp only [ne_eq, or_false, not_true_eq_false] at hb; simp [ht b hb, top_mul hb]\n  | coe a =>\n    induction b with\n    | top =>\n      simp only [ne_eq, or_false, not_true_eq_false] at ha\n      simpa [Function.comp_def, mul_comm, mul_top ha]\n        using (ht a ha).comp (continuous_swap.tendsto (ofNNReal a, ∞))\n    | coe b =>\n      simp only [nhds_coe_coe, ← coe_mul, tendsto_coe, tendsto_map'_iff, Function.comp_def,\n        tendsto_mul]\n\n"}
{"name":"ENNReal.Tendsto.mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nma mb : α → ENNReal\na b : ENNReal\nhma : Filter.Tendsto ma f (nhds a)\nha : Or (Ne a 0) (Ne b Top.top)\nhmb : Filter.Tendsto mb f (nhds b)\nhb : Or (Ne b 0) (Ne a Top.top)\n⊢ Filter.Tendsto (fun a => HMul.hMul (ma a) (mb a)) f (nhds (HMul.hMul a b))","decl":"protected theorem Tendsto.mul {f : Filter α} {ma : α → ℝ≥0∞} {mb : α → ℝ≥0∞} {a b : ℝ≥0∞}\n    (hma : Tendsto ma f (𝓝 a)) (ha : a ≠ 0 ∨ b ≠ ∞) (hmb : Tendsto mb f (𝓝 b))\n    (hb : b ≠ 0 ∨ a ≠ ∞) : Tendsto (fun a => ma a * mb a) f (𝓝 (a * b)) :=\n  show Tendsto ((fun p : ℝ≥0∞ × ℝ≥0∞ => p.1 * p.2) ∘ fun a => (ma a, mb a)) f (𝓝 (a * b)) from\n    Tendsto.comp (ENNReal.tendsto_mul ha hb) (hma.prod_mk_nhds hmb)\n\n"}
{"name":"ContinuousOn.ennreal_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nf g : α → ENNReal\ns : Set α\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nh₁ : ∀ (x : α), Membership.mem s x → Or (Ne (f x) 0) (Ne (g x) Top.top)\nh₂ : ∀ (x : α), Membership.mem s x → Or (Ne (g x) 0) (Ne (f x) Top.top)\n⊢ ContinuousOn (fun x => HMul.hMul (f x) (g x)) s","decl":"theorem _root_.ContinuousOn.ennreal_mul [TopologicalSpace α] {f g : α → ℝ≥0∞} {s : Set α}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) (h₁ : ∀ x ∈ s, f x ≠ 0 ∨ g x ≠ ∞)\n    (h₂ : ∀ x ∈ s, g x ≠ 0 ∨ f x ≠ ∞) : ContinuousOn (fun x => f x * g x) s := fun x hx =>\n  ENNReal.Tendsto.mul (hf x hx) (h₁ x hx) (hg x hx) (h₂ x hx)\n\n"}
{"name":"Continuous.ennreal_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nf g : α → ENNReal\nhf : Continuous f\nhg : Continuous g\nh₁ : ∀ (x : α), Or (Ne (f x) 0) (Ne (g x) Top.top)\nh₂ : ∀ (x : α), Or (Ne (g x) 0) (Ne (f x) Top.top)\n⊢ Continuous fun x => HMul.hMul (f x) (g x)","decl":"theorem _root_.Continuous.ennreal_mul [TopologicalSpace α] {f g : α → ℝ≥0∞} (hf : Continuous f)\n    (hg : Continuous g) (h₁ : ∀ x, f x ≠ 0 ∨ g x ≠ ∞) (h₂ : ∀ x, g x ≠ 0 ∨ f x ≠ ∞) :\n    Continuous fun x => f x * g x :=\n  continuous_iff_continuousAt.2 fun x =>\n    ENNReal.Tendsto.mul hf.continuousAt (h₁ x) hg.continuousAt (h₂ x)\n\n"}
{"name":"ENNReal.Tendsto.const_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nm : α → ENNReal\na b : ENNReal\nhm : Filter.Tendsto m f (nhds b)\nhb : Or (Ne b 0) (Ne a Top.top)\n⊢ Filter.Tendsto (fun b => HMul.hMul a (m b)) f (nhds (HMul.hMul a b))","decl":"protected theorem Tendsto.const_mul {f : Filter α} {m : α → ℝ≥0∞} {a b : ℝ≥0∞}\n    (hm : Tendsto m f (𝓝 b)) (hb : b ≠ 0 ∨ a ≠ ∞) : Tendsto (fun b => a * m b) f (𝓝 (a * b)) :=\n  by_cases (fun (this : a = 0) => by simp [this, tendsto_const_nhds]) fun ha : a ≠ 0 =>\n    ENNReal.Tendsto.mul tendsto_const_nhds (Or.inl ha) hm hb\n\n"}
{"name":"ENNReal.Tendsto.mul_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nm : α → ENNReal\na b : ENNReal\nhm : Filter.Tendsto m f (nhds a)\nha : Or (Ne a 0) (Ne b Top.top)\n⊢ Filter.Tendsto (fun x => HMul.hMul (m x) b) f (nhds (HMul.hMul a b))","decl":"protected theorem Tendsto.mul_const {f : Filter α} {m : α → ℝ≥0∞} {a b : ℝ≥0∞}\n    (hm : Tendsto m f (𝓝 a)) (ha : a ≠ 0 ∨ b ≠ ∞) : Tendsto (fun x => m x * b) f (𝓝 (a * b)) := by\n  simpa only [mul_comm] using ENNReal.Tendsto.const_mul hm ha\n\n"}
{"name":"ENNReal.tendsto_finset_prod_of_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nι : Type u_4\nf : ι → α → ENNReal\nx : Filter α\na : ι → ENNReal\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → Filter.Tendsto (f i) x (nhds (a i))\nh' : ∀ (i : ι), Membership.mem s i → Ne (a i) Top.top\n⊢ Filter.Tendsto (fun b => s.prod fun c => f c b) x (nhds (s.prod fun c => a c))","decl":"theorem tendsto_finset_prod_of_ne_top {ι : Type*} {f : ι → α → ℝ≥0∞} {x : Filter α} {a : ι → ℝ≥0∞}\n    (s : Finset ι) (h : ∀ i ∈ s, Tendsto (f i) x (𝓝 (a i))) (h' : ∀ i ∈ s, a i ≠ ∞) :\n    Tendsto (fun b => ∏ c ∈ s, f c b) x (𝓝 (∏ c ∈ s, a c)) := by\n  classical\n  induction' s using Finset.induction with a s has IH\n  · simp [tendsto_const_nhds]\n  simp only [Finset.prod_insert has]\n  apply Tendsto.mul (h _ (Finset.mem_insert_self _ _))\n  · right\n    exact prod_ne_top fun i hi => h' _ (Finset.mem_insert_of_mem hi)\n  · exact IH (fun i hi => h _ (Finset.mem_insert_of_mem hi)) fun i hi =>\n      h' _ (Finset.mem_insert_of_mem hi)\n  · exact Or.inr (h' _ (Finset.mem_insert_self _ _))\n\n"}
{"name":"ENNReal.continuousAt_const_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : ENNReal\nh : Or (Ne a Top.top) (Ne b 0)\n⊢ ContinuousAt (fun x => HMul.hMul a x) b","decl":"protected theorem continuousAt_const_mul {a b : ℝ≥0∞} (h : a ≠ ∞ ∨ b ≠ 0) :\n    ContinuousAt (a * ·) b :=\n  Tendsto.const_mul tendsto_id h.symm\n\n"}
{"name":"ENNReal.continuousAt_mul_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : ENNReal\nh : Or (Ne a Top.top) (Ne b 0)\n⊢ ContinuousAt (fun x => HMul.hMul x a) b","decl":"protected theorem continuousAt_mul_const {a b : ℝ≥0∞} (h : a ≠ ∞ ∨ b ≠ 0) :\n    ContinuousAt (fun x => x * a) b :=\n  Tendsto.mul_const tendsto_id h.symm\n\n"}
{"name":"ENNReal.continuous_const_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nha : Ne a Top.top\n⊢ Continuous fun x => HMul.hMul a x","decl":"@[fun_prop]\nprotected theorem continuous_const_mul {a : ℝ≥0∞} (ha : a ≠ ∞) : Continuous (a * ·) :=\n  continuous_iff_continuousAt.2 fun _ => ENNReal.continuousAt_const_mul (Or.inl ha)\n\n"}
{"name":"ENNReal.continuous_mul_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nha : Ne a Top.top\n⊢ Continuous fun x => HMul.hMul x a","decl":"@[fun_prop]\nprotected theorem continuous_mul_const {a : ℝ≥0∞} (ha : a ≠ ∞) : Continuous fun x => x * a :=\n  continuous_iff_continuousAt.2 fun _ => ENNReal.continuousAt_mul_const (Or.inl ha)\n\n"}
{"name":"ENNReal.continuous_div_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"c : ENNReal\nc_ne_zero : Ne c 0\n⊢ Continuous fun x => HDiv.hDiv x c","decl":"@[fun_prop]\nprotected theorem continuous_div_const (c : ℝ≥0∞) (c_ne_zero : c ≠ 0) :\n    Continuous fun x : ℝ≥0∞ => x / c :=\n  ENNReal.continuous_mul_const <| ENNReal.inv_ne_top.2 c_ne_zero\n\n"}
{"name":"ENNReal.continuous_pow","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\n⊢ Continuous fun a => HPow.hPow a n","decl":"@[continuity, fun_prop]\nprotected theorem continuous_pow (n : ℕ) : Continuous fun a : ℝ≥0∞ => a ^ n := by\n  induction' n with n IH\n  · simp [continuous_const]\n  simp_rw [pow_add, pow_one, continuous_iff_continuousAt]\n  intro x\n  refine ENNReal.Tendsto.mul (IH.tendsto _) ?_ tendsto_id ?_ <;> by_cases H : x = 0\n  · simp only [H, zero_ne_top, Ne, or_true, not_false_iff]\n  · exact Or.inl fun h => H (pow_eq_zero h)\n  · simp only [H, pow_eq_top_iff, zero_ne_top, false_or, eq_self_iff_true, not_true, Ne,\n      not_false_iff, false_and]\n  · simp only [H, true_or, Ne, not_false_iff]\n\n"}
{"name":"ENNReal.continuousOn_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ ContinuousOn (fun p => HSub.hSub p.1 p.2) (setOf fun p => Ne p { fst := Top.top, snd := Top.top })","decl":"theorem continuousOn_sub :\n    ContinuousOn (fun p : ℝ≥0∞ × ℝ≥0∞ => p.fst - p.snd) { p : ℝ≥0∞ × ℝ≥0∞ | p ≠ ⟨∞, ∞⟩ } := by\n  rw [ContinuousOn]\n  rintro ⟨x, y⟩ hp\n  simp only [Ne, Set.mem_setOf_eq, Prod.mk.inj_iff] at hp\n  exact tendsto_nhdsWithin_of_tendsto_nhds (tendsto_sub (not_and_or.mp hp))\n\n"}
{"name":"ENNReal.continuous_sub_left","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\na_ne_top : Ne a Top.top\n⊢ Continuous fun x => HSub.hSub a x","decl":"theorem continuous_sub_left {a : ℝ≥0∞} (a_ne_top : a ≠ ∞) : Continuous (a - ·) := by\n  change Continuous (Function.uncurry Sub.sub ∘ (a, ·))\n  refine continuousOn_sub.comp_continuous (Continuous.Prod.mk a) fun x => ?_\n  simp only [a_ne_top, Ne, mem_setOf_eq, Prod.mk.inj_iff, false_and, not_false_iff]\n\n"}
{"name":"ENNReal.continuous_nnreal_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : NNReal\n⊢ Continuous fun x => HSub.hSub (↑a) x","decl":"theorem continuous_nnreal_sub {a : ℝ≥0} : Continuous fun x : ℝ≥0∞ => (a : ℝ≥0∞) - x :=\n  continuous_sub_left coe_ne_top\n\n"}
{"name":"ENNReal.continuousOn_sub_left","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\n⊢ ContinuousOn (fun x => HSub.hSub a x) (setOf fun x => Ne x Top.top)","decl":"theorem continuousOn_sub_left (a : ℝ≥0∞) : ContinuousOn (a - ·) { x : ℝ≥0∞ | x ≠ ∞ } := by\n  rw [show (fun x => a - x) = (fun p : ℝ≥0∞ × ℝ≥0∞ => p.fst - p.snd) ∘ fun x => ⟨a, x⟩ by rfl]\n  apply ContinuousOn.comp continuousOn_sub (Continuous.continuousOn (Continuous.Prod.mk a))\n  rintro _ h (_ | _)\n  exact h none_eq_top\n\n"}
{"name":"ENNReal.continuous_sub_right","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\n⊢ Continuous fun x => HSub.hSub x a","decl":"theorem continuous_sub_right (a : ℝ≥0∞) : Continuous fun x : ℝ≥0∞ => x - a := by\n  by_cases a_infty : a = ∞\n  · simp [a_infty, continuous_const, tsub_eq_zero_of_le]\n  · rw [show (fun x => x - a) = (fun p : ℝ≥0∞ × ℝ≥0∞ => p.fst - p.snd) ∘ fun x => ⟨x, a⟩ by rfl]\n    apply ContinuousOn.comp_continuous continuousOn_sub (continuous_id'.prod_mk continuous_const)\n    intro x\n    simp only [a_infty, Ne, mem_setOf_eq, Prod.mk.inj_iff, and_false, not_false_iff]\n\n"}
{"name":"ENNReal.Tendsto.pow","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nm : α → ENNReal\na : ENNReal\nn : Nat\nhm : Filter.Tendsto m f (nhds a)\n⊢ Filter.Tendsto (fun x => HPow.hPow (m x) n) f (nhds (HPow.hPow a n))","decl":"protected theorem Tendsto.pow {f : Filter α} {m : α → ℝ≥0∞} {a : ℝ≥0∞} {n : ℕ}\n    (hm : Tendsto m f (𝓝 a)) : Tendsto (fun x => m x ^ n) f (𝓝 (a ^ n)) :=\n  ((ENNReal.continuous_pow n).tendsto a).comp hm\n\n"}
{"name":"ENNReal.le_of_forall_lt_one_mul_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x y : ENNReal\nh : ∀ (a : ENNReal), LT.lt a 1 → LE.le (HMul.hMul a x) y\n⊢ LE.le x y","decl":"theorem le_of_forall_lt_one_mul_le {x y : ℝ≥0∞} (h : ∀ a < 1, a * x ≤ y) : x ≤ y := by\n  have : Tendsto (· * x) (𝓝[<] 1) (𝓝 (1 * x)) :=\n    (ENNReal.continuousAt_mul_const (Or.inr one_ne_zero)).mono_left inf_le_left\n  rw [one_mul] at this\n  exact le_of_tendsto this (eventually_nhdsWithin_iff.2 <| Eventually.of_forall h)\n\n"}
{"name":"ENNReal.iInf_mul_left'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Sort u_4\nf : ι → ENNReal\na : ENNReal\nh : Eq a Top.top → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\nh0 : Eq a 0 → Nonempty ι\n⊢ Eq (iInf fun i => HMul.hMul a (f i)) (HMul.hMul a (iInf fun i => f i))","decl":"@[deprecated mul_iInf' (since := \"2024-09-12\")]\ntheorem iInf_mul_left' {ι} {f : ι → ℝ≥0∞} {a : ℝ≥0∞} (h : a = ∞ → ⨅ i, f i = 0 → ∃ i, f i = 0)\n    (h0 : a = 0 → Nonempty ι) : ⨅ i, a * f i = a * ⨅ i, f i := .symm <| mul_iInf' h h0\n\n"}
{"name":"ENNReal.iInf_mul_left","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Sort u_4\ninst✝ : Nonempty ι\nf : ι → ENNReal\na : ENNReal\nh : Eq a Top.top → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\n⊢ Eq (iInf fun i => HMul.hMul a (f i)) (HMul.hMul a (iInf fun i => f i))","decl":"@[deprecated mul_iInf (since := \"2024-09-12\")]\ntheorem iInf_mul_left {ι} [Nonempty ι] {f : ι → ℝ≥0∞} {a : ℝ≥0∞}\n    (h : a = ∞ → ⨅ i, f i = 0 → ∃ i, f i = 0) : ⨅ i, a * f i = a * ⨅ i, f i :=\n  .symm <| mul_iInf h\n\n"}
{"name":"ENNReal.iInf_mul_right'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Sort u_4\nf : ι → ENNReal\na : ENNReal\nh : Eq a Top.top → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\nh0 : Eq a 0 → Nonempty ι\n⊢ Eq (iInf fun i => HMul.hMul (f i) a) (HMul.hMul (iInf fun i => f i) a)","decl":"@[deprecated iInf_mul' (since := \"2024-09-12\")]\ntheorem iInf_mul_right' {ι} {f : ι → ℝ≥0∞} {a : ℝ≥0∞} (h : a = ∞ → ⨅ i, f i = 0 → ∃ i, f i = 0)\n    (h0 : a = 0 → Nonempty ι) : ⨅ i, f i * a = (⨅ i, f i) * a := .symm <| iInf_mul' h h0\n\n"}
{"name":"ENNReal.iInf_mul_right","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Sort u_4\ninst✝ : Nonempty ι\nf : ι → ENNReal\na : ENNReal\nh : Eq a Top.top → Eq (iInf fun i => f i) 0 → Exists fun i => Eq (f i) 0\n⊢ Eq (iInf fun i => HMul.hMul (f i) a) (HMul.hMul (iInf fun i => f i) a)","decl":"@[deprecated iInf_mul (since := \"2024-09-12\")]\ntheorem iInf_mul_right {ι} [Nonempty ι] {f : ι → ℝ≥0∞} {a : ℝ≥0∞}\n    (h : a = ∞ → ⨅ i, f i = 0 → ∃ i, f i = 0) : ⨅ i, f i * a = (⨅ i, f i) * a := .symm <| iInf_mul h\n\n"}
{"name":"ENNReal.inv_map_iInf","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Sort u_4\nx : ι → ENNReal\n⊢ Eq (Inv.inv (iInf x)) (iSup fun i => Inv.inv (x i))","decl":"@[deprecated inv_iInf (since := \"2024-09-12\")]\ntheorem inv_map_iInf {ι : Sort*} {x : ι → ℝ≥0∞} : (iInf x)⁻¹ = ⨆ i, (x i)⁻¹ :=\n  OrderIso.invENNReal.map_iInf x\n\n"}
{"name":"ENNReal.inv_map_iSup","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Sort u_4\nx : ι → ENNReal\n⊢ Eq (Inv.inv (iSup x)) (iInf fun i => Inv.inv (x i))","decl":"@[deprecated inv_iSup (since := \"2024-09-12\")]\ntheorem inv_map_iSup {ι : Sort*} {x : ι → ℝ≥0∞} : (iSup x)⁻¹ = ⨅ i, (x i)⁻¹ :=\n  OrderIso.invENNReal.map_iSup x\n\n"}
{"name":"ENNReal.inv_limsup","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nx : ι → ENNReal\nl : Filter ι\n⊢ Eq (Inv.inv (Filter.limsup x l)) (Filter.liminf (fun i => Inv.inv (x i)) l)","decl":"theorem inv_limsup {ι : Sort _} {x : ι → ℝ≥0∞} {l : Filter ι} :\n    (limsup x l)⁻¹ = liminf (fun i => (x i)⁻¹) l :=\n  OrderIso.invENNReal.limsup_apply\n\n"}
{"name":"ENNReal.inv_liminf","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nx : ι → ENNReal\nl : Filter ι\n⊢ Eq (Inv.inv (Filter.liminf x l)) (Filter.limsup (fun i => Inv.inv (x i)) l)","decl":"theorem inv_liminf {ι : Sort _} {x : ι → ℝ≥0∞} {l : Filter ι} :\n    (liminf x l)⁻¹ = limsup (fun i => (x i)⁻¹) l :=\n  OrderIso.invENNReal.liminf_apply\n\n"}
{"name":"ENNReal.continuous_zpow","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Int\n⊢ Continuous fun x => HPow.hPow x n","decl":"@[fun_prop]\nprotected theorem continuous_zpow : ∀ n : ℤ, Continuous (· ^ n : ℝ≥0∞ → ℝ≥0∞)\n  | (n : ℕ) => mod_cast ENNReal.continuous_pow n\n  | .negSucc n => by simpa using (ENNReal.continuous_pow _).inv\n\n"}
{"name":"ENNReal.tendsto_inv_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nm : α → ENNReal\na : ENNReal\n⊢ Iff (Filter.Tendsto (fun x => Inv.inv (m x)) f (nhds (Inv.inv a))) (Filter.Tendsto m f (nhds a))","decl":"@[simp] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `[InvolutiveInv _] [ContinuousInv _]`\nprotected theorem tendsto_inv_iff {f : Filter α} {m : α → ℝ≥0∞} {a : ℝ≥0∞} :\n    Tendsto (fun x => (m x)⁻¹) f (𝓝 a⁻¹) ↔ Tendsto m f (𝓝 a) :=\n  ⟨fun h => by simpa only [inv_inv] using Tendsto.inv h, Tendsto.inv⟩\n\n"}
{"name":"ENNReal.Tendsto.div","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nma mb : α → ENNReal\na b : ENNReal\nhma : Filter.Tendsto ma f (nhds a)\nha : Or (Ne a 0) (Ne b 0)\nhmb : Filter.Tendsto mb f (nhds b)\nhb : Or (Ne b Top.top) (Ne a Top.top)\n⊢ Filter.Tendsto (fun a => HDiv.hDiv (ma a) (mb a)) f (nhds (HDiv.hDiv a b))","decl":"protected theorem Tendsto.div {f : Filter α} {ma : α → ℝ≥0∞} {mb : α → ℝ≥0∞} {a b : ℝ≥0∞}\n    (hma : Tendsto ma f (𝓝 a)) (ha : a ≠ 0 ∨ b ≠ 0) (hmb : Tendsto mb f (𝓝 b))\n    (hb : b ≠ ∞ ∨ a ≠ ∞) : Tendsto (fun a => ma a / mb a) f (𝓝 (a / b)) := by\n  apply Tendsto.mul hma _ (ENNReal.tendsto_inv_iff.2 hmb) _ <;> simp [ha, hb]\n\n"}
{"name":"ENNReal.Tendsto.const_div","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nm : α → ENNReal\na b : ENNReal\nhm : Filter.Tendsto m f (nhds b)\nhb : Or (Ne b Top.top) (Ne a Top.top)\n⊢ Filter.Tendsto (fun b => HDiv.hDiv a (m b)) f (nhds (HDiv.hDiv a b))","decl":"protected theorem Tendsto.const_div {f : Filter α} {m : α → ℝ≥0∞} {a b : ℝ≥0∞}\n    (hm : Tendsto m f (𝓝 b)) (hb : b ≠ ∞ ∨ a ≠ ∞) : Tendsto (fun b => a / m b) f (𝓝 (a / b)) := by\n  apply Tendsto.const_mul (ENNReal.tendsto_inv_iff.2 hm)\n  simp [hb]\n\n"}
{"name":"ENNReal.Tendsto.div_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : Filter α\nm : α → ENNReal\na b : ENNReal\nhm : Filter.Tendsto m f (nhds a)\nha : Or (Ne a 0) (Ne b 0)\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (m x) b) f (nhds (HDiv.hDiv a b))","decl":"protected theorem Tendsto.div_const {f : Filter α} {m : α → ℝ≥0∞} {a b : ℝ≥0∞}\n    (hm : Tendsto m f (𝓝 a)) (ha : a ≠ 0 ∨ b ≠ 0) : Tendsto (fun x => m x / b) f (𝓝 (a / b)) := by\n  apply Tendsto.mul_const hm\n  simp [ha]\n\n"}
{"name":"ENNReal.tendsto_inv_nat_nhds_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Filter.Tendsto (fun n => Inv.inv ↑n) Filter.atTop (nhds 0)","decl":"protected theorem tendsto_inv_nat_nhds_zero : Tendsto (fun n : ℕ => (n : ℝ≥0∞)⁻¹) atTop (𝓝 0) :=\n  ENNReal.inv_top ▸ ENNReal.tendsto_inv_iff.2 tendsto_nat_nhds_top\n\n"}
{"name":"ENNReal.tendsto_coe_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\nb : ENNReal\n⊢ Filter.Tendsto (fun b => HSub.hSub (↑r) b) (nhds b) (nhds (HSub.hSub (↑r) b))","decl":"protected theorem tendsto_coe_sub {b : ℝ≥0∞} :\n    Tendsto (fun b : ℝ≥0∞ => ↑r - b) (𝓝 b) (𝓝 (↑r - b)) :=\n  continuous_nnreal_sub.tendsto _\n\n"}
{"name":"ENNReal.exists_countable_dense_no_zero_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"⊢ Exists fun s => And s.Countable (And (Dense s) (And (Not (Membership.mem s 0)) (Not (Membership.mem s Top.top))))","decl":"theorem exists_countable_dense_no_zero_top :\n    ∃ s : Set ℝ≥0∞, s.Countable ∧ Dense s ∧ 0 ∉ s ∧ ∞ ∉ s := by\n  obtain ⟨s, s_count, s_dense, hs⟩ :\n    ∃ s : Set ℝ≥0∞, s.Countable ∧ Dense s ∧ (∀ x, IsBot x → x ∉ s) ∧ ∀ x, IsTop x → x ∉ s :=\n    exists_countable_dense_no_bot_top ℝ≥0∞\n  exact ⟨s, s_count, s_dense, fun h => hs.1 0 (by simp) h, fun h => hs.2 ∞ (by simp) h⟩\n\n"}
{"name":"ENNReal.ofReal_cinfi","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → Real\ninst✝ : Nonempty α\n⊢ Eq (ENNReal.ofReal (iInf fun i => f i)) (iInf fun i => ENNReal.ofReal (f i))","decl":"@[deprecated ofReal_iInf (since := \"2024-09-12\")]\ntheorem ofReal_cinfi (f : α → ℝ) [Nonempty α] :\n    ENNReal.ofReal (⨅ i, f i) = ⨅ i, ENNReal.ofReal (f i) := by\n  by_cases hf : BddBelow (range f)\n  · exact\n      Monotone.map_ciInf_of_continuousAt ENNReal.continuous_ofReal.continuousAt\n        (fun i j hij => ENNReal.ofReal_le_ofReal hij) hf\n  · symm\n    rw [Real.iInf_of_not_bddBelow hf, ENNReal.ofReal_zero, ← ENNReal.bot_eq_zero, iInf_eq_bot]\n    obtain ⟨y, hy_mem, hy_neg⟩ := not_bddBelow_iff.mp hf 0\n    obtain ⟨i, rfl⟩ := mem_range.mpr hy_mem\n    refine fun x hx => ⟨i, ?_⟩\n    rwa [ENNReal.ofReal_of_nonpos hy_neg.le]\n\n"}
{"name":"ENNReal.exists_frequently_lt_of_liminf_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nl : Filter ι\nx : ι → Real\nhx : Ne (Filter.liminf (fun n => ↑(Real.nnabs (x n))) l) Top.top\n⊢ Exists fun R => Filter.Frequently (fun n => LT.lt (x n) R) l","decl":"theorem exists_frequently_lt_of_liminf_ne_top {ι : Type*} {l : Filter ι} {x : ι → ℝ}\n    (hx : liminf (fun n => (Real.nnabs (x n) : ℝ≥0∞)) l ≠ ∞) : ∃ R, ∃ᶠ n in l, x n < R := by\n  by_contra h\n  simp_rw [not_exists, not_frequently, not_lt] at h\n  refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)\n  simp only [eventually_map, ENNReal.coe_le_coe]\n  filter_upwards [h r] with i hi using hi.trans (le_abs_self (x i))\n\n"}
{"name":"ENNReal.exists_frequently_lt_of_liminf_ne_top'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nl : Filter ι\nx : ι → Real\nhx : Ne (Filter.liminf (fun n => ↑(Real.nnabs (x n))) l) Top.top\n⊢ Exists fun R => Filter.Frequently (fun n => LT.lt R (x n)) l","decl":"theorem exists_frequently_lt_of_liminf_ne_top' {ι : Type*} {l : Filter ι} {x : ι → ℝ}\n    (hx : liminf (fun n => (Real.nnabs (x n) : ℝ≥0∞)) l ≠ ∞) : ∃ R, ∃ᶠ n in l, R < x n := by\n  by_contra h\n  simp_rw [not_exists, not_frequently, not_lt] at h\n  refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)\n  simp only [eventually_map, ENNReal.coe_le_coe]\n  filter_upwards [h (-r)] with i hi using(le_neg.1 hi).trans (neg_le_abs _)\n\n"}
{"name":"ENNReal.exists_upcrossings_of_not_bounded_under","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nl : Filter ι\nx : ι → Real\nhf : Ne (Filter.liminf (fun i => ↑(Real.nnabs (x i))) l) Top.top\nhbdd : Not (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun i => abs (x i))\n⊢ Exists fun a => Exists fun b => And (LT.lt a b) (And (Filter.Frequently (fun i => LT.lt (x i) ↑a) l) (Filter.Frequently (fun i => LT.lt (↑b) (x i)) l))","decl":"theorem exists_upcrossings_of_not_bounded_under {ι : Type*} {l : Filter ι} {x : ι → ℝ}\n    (hf : liminf (fun i => (Real.nnabs (x i) : ℝ≥0∞)) l ≠ ∞)\n    (hbdd : ¬IsBoundedUnder (· ≤ ·) l fun i => |x i|) :\n    ∃ a b : ℚ, a < b ∧ (∃ᶠ i in l, x i < a) ∧ ∃ᶠ i in l, ↑b < x i := by\n  rw [isBoundedUnder_le_abs, not_and_or] at hbdd\n  obtain hbdd | hbdd := hbdd\n  · obtain ⟨R, hR⟩ := exists_frequently_lt_of_liminf_ne_top hf\n    obtain ⟨q, hq⟩ := exists_rat_gt R\n    refine ⟨q, q + 1, (lt_add_iff_pos_right _).2 zero_lt_one, ?_, ?_⟩\n    · refine fun hcon => hR ?_\n      filter_upwards [hcon] with x hx using not_lt.2 (lt_of_lt_of_le hq (not_lt.1 hx)).le\n    · simp only [IsBoundedUnder, IsBounded, eventually_map, eventually_atTop, not_exists,\n        not_forall, not_le, exists_prop] at hbdd\n      refine fun hcon => hbdd ↑(q + 1) ?_\n      filter_upwards [hcon] with x hx using not_lt.1 hx\n  · obtain ⟨R, hR⟩ := exists_frequently_lt_of_liminf_ne_top' hf\n    obtain ⟨q, hq⟩ := exists_rat_lt R\n    refine ⟨q - 1, q, (sub_lt_self_iff _).2 zero_lt_one, ?_, ?_⟩\n    · simp only [IsBoundedUnder, IsBounded, eventually_map, eventually_atTop, not_exists,\n        not_forall, not_le, exists_prop] at hbdd\n      refine fun hcon => hbdd ↑(q - 1) ?_\n      filter_upwards [hcon] with x hx using not_lt.1 hx\n    · refine fun hcon => hR ?_\n      filter_upwards [hcon] with x hx using not_lt.2 ((not_lt.1 hx).trans hq.le)\n\n"}
{"name":"ENNReal.hasSum_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → NNReal\nr : NNReal\n⊢ Iff (HasSum (fun a => ↑(f a)) ↑r) (HasSum f r)","decl":"@[norm_cast]\nprotected theorem hasSum_coe {f : α → ℝ≥0} {r : ℝ≥0} :\n    HasSum (fun a => (f a : ℝ≥0∞)) ↑r ↔ HasSum f r := by\n  simp only [HasSum, ← coe_finset_sum, tendsto_coe]\n\n"}
{"name":"ENNReal.tsum_coe_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nr : NNReal\nf : α → NNReal\nh : HasSum f r\n⊢ Eq (tsum fun a => ↑(f a)) ↑r","decl":"protected theorem tsum_coe_eq {f : α → ℝ≥0} (h : HasSum f r) : (∑' a, (f a : ℝ≥0∞)) = r :=\n  (ENNReal.hasSum_coe.2 h).tsum_eq\n\n"}
{"name":"ENNReal.coe_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → NNReal\na✝ : Summable f\n⊢ Eq (↑(tsum f)) (tsum fun a => ↑(f a))","decl":"protected theorem coe_tsum {f : α → ℝ≥0} : Summable f → ↑(tsum f) = ∑' a, (f a : ℝ≥0∞)\n  | ⟨r, hr⟩ => by rw [hr.tsum_eq, ENNReal.tsum_coe_eq hr]\n\n"}
{"name":"ENNReal.hasSum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\n⊢ HasSum f (iSup fun s => s.sum fun a => f a)","decl":"protected theorem hasSum : HasSum f (⨆ s : Finset α, ∑ a ∈ s, f a) :=\n  tendsto_atTop_iSup fun _ _ => Finset.sum_le_sum_of_subset\n\n"}
{"name":"ENNReal.summable","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\n⊢ Summable f","decl":"@[simp]\nprotected theorem summable : Summable f :=\n  ⟨_, ENNReal.hasSum⟩\n\n"}
{"name":"ENNReal.tsum_coe_ne_top_iff_summable","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\nf : β → NNReal\n⊢ Iff (Ne (tsum fun b => ↑(f b)) Top.top) (Summable f)","decl":"theorem tsum_coe_ne_top_iff_summable {f : β → ℝ≥0} : (∑' b, (f b : ℝ≥0∞)) ≠ ∞ ↔ Summable f := by\n  refine ⟨fun h => ?_, fun h => ENNReal.coe_tsum h ▸ ENNReal.coe_ne_top⟩\n  lift ∑' b, (f b : ℝ≥0∞) to ℝ≥0 using h with a ha\n  refine ⟨a, ENNReal.hasSum_coe.1 ?_⟩\n  rw [ha]\n  exact ENNReal.summable.hasSum\n\n"}
{"name":"ENNReal.tsum_eq_iSup_sum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\n⊢ Eq (tsum fun a => f a) (iSup fun s => s.sum fun a => f a)","decl":"protected theorem tsum_eq_iSup_sum : ∑' a, f a = ⨆ s : Finset α, ∑ a ∈ s, f a :=\n  ENNReal.hasSum.tsum_eq\n\n"}
{"name":"ENNReal.tsum_eq_iSup_sum'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\nι : Type u_4\ns : ι → Finset α\nhs : ∀ (t : Finset α), Exists fun i => HasSubset.Subset t (s i)\n⊢ Eq (tsum fun a => f a) (iSup fun i => (s i).sum fun a => f a)","decl":"protected theorem tsum_eq_iSup_sum' {ι : Type*} (s : ι → Finset α) (hs : ∀ t, ∃ i, t ⊆ s i) :\n    ∑' a, f a = ⨆ i, ∑ a ∈ s i, f a := by\n  rw [ENNReal.tsum_eq_iSup_sum]\n  symm\n  change ⨆ i : ι, (fun t : Finset α => ∑ a ∈ t, f a) (s i) = ⨆ s : Finset α, ∑ a ∈ s, f a\n  exact (Finset.sum_mono_set f).iSup_comp_eq hs\n\n"}
{"name":"ENNReal.tsum_sigma","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : α → Type u_4\nf : (a : α) → β a → ENNReal\n⊢ Eq (tsum fun p => f p.fst p.snd) (tsum fun a => tsum fun b => f a b)","decl":"protected theorem tsum_sigma {β : α → Type*} (f : ∀ a, β a → ℝ≥0∞) :\n    ∑' p : Σa, β a, f p.1 p.2 = ∑' (a) (b), f a b :=\n  tsum_sigma' (fun _ => ENNReal.summable) ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_sigma'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : α → Type u_4\nf : (Sigma fun a => β a) → ENNReal\n⊢ Eq (tsum fun p => f p) (tsum fun a => tsum fun b => f ⟨a, b⟩)","decl":"protected theorem tsum_sigma' {β : α → Type*} (f : (Σa, β a) → ℝ≥0∞) :\n    ∑' p : Σa, β a, f p = ∑' (a) (b), f ⟨a, b⟩ :=\n  tsum_sigma' (fun _ => ENNReal.summable) ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_prod","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → ENNReal\n⊢ Eq (tsum fun p => f p.1 p.2) (tsum fun a => tsum fun b => f a b)","decl":"protected theorem tsum_prod {f : α → β → ℝ≥0∞} : ∑' p : α × β, f p.1 p.2 = ∑' (a) (b), f a b :=\n  tsum_prod' ENNReal.summable fun _ => ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_prod'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Prod α β → ENNReal\n⊢ Eq (tsum fun p => f p) (tsum fun a => tsum fun b => f { fst := a, snd := b })","decl":"protected theorem tsum_prod' {f : α × β → ℝ≥0∞} : ∑' p : α × β, f p = ∑' (a) (b), f (a, b) :=\n  tsum_prod' ENNReal.summable fun _ => ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_comm","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → ENNReal\n⊢ Eq (tsum fun a => tsum fun b => f a b) (tsum fun b => tsum fun a => f a b)","decl":"protected theorem tsum_comm {f : α → β → ℝ≥0∞} : ∑' a, ∑' b, f a b = ∑' b, ∑' a, f a b :=\n  tsum_comm' ENNReal.summable (fun _ => ENNReal.summable) fun _ => ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_add","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf g : α → ENNReal\n⊢ Eq (tsum fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (tsum fun a => f a) (tsum fun a => g a))","decl":"protected theorem tsum_add : ∑' a, (f a + g a) = ∑' a, f a + ∑' a, g a :=\n  tsum_add ENNReal.summable ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf g : α → ENNReal\nh : ∀ (a : α), LE.le (f a) (g a)\n⊢ LE.le (tsum fun a => f a) (tsum fun a => g a)","decl":"protected theorem tsum_le_tsum (h : ∀ a, f a ≤ g a) : ∑' a, f a ≤ ∑' a, g a :=\n  tsum_le_tsum h ENNReal.summable ENNReal.summable\n\n"}
{"name":"GCongr.ennreal_tsum_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf g : α → ENNReal\nh : ∀ (a : α), LE.le (f a) (g a)\n⊢ LE.le (tsum f) (tsum g)","decl":"@[gcongr]\nprotected theorem _root_.GCongr.ennreal_tsum_le_tsum (h : ∀ a, f a ≤ g a) : tsum f ≤ tsum g :=\n  ENNReal.tsum_le_tsum h\n\n"}
{"name":"ENNReal.sum_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\ns : Finset α\n⊢ LE.le (s.sum fun x => f x) (tsum fun x => f x)","decl":"protected theorem sum_le_tsum {f : α → ℝ≥0∞} (s : Finset α) : ∑ x ∈ s, f x ≤ ∑' x, f x :=\n  sum_le_tsum s (fun _ _ => zero_le _) ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_eq_iSup_nat'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\nN : Nat → Nat\nhN : Filter.Tendsto N Filter.atTop Filter.atTop\n⊢ Eq (tsum fun i => f i) (iSup fun i => (Finset.range (N i)).sum fun a => f a)","decl":"protected theorem tsum_eq_iSup_nat' {f : ℕ → ℝ≥0∞} {N : ℕ → ℕ} (hN : Tendsto N atTop atTop) :\n    ∑' i : ℕ, f i = ⨆ i : ℕ, ∑ a ∈ Finset.range (N i), f a :=\n  ENNReal.tsum_eq_iSup_sum' _ fun t =>\n    let ⟨n, hn⟩ := t.exists_nat_subset_range\n    let ⟨k, _, hk⟩ := exists_le_of_tendsto_atTop hN 0 n\n    ⟨k, Finset.Subset.trans hn (Finset.range_mono hk)⟩\n\n"}
{"name":"ENNReal.tsum_eq_iSup_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\n⊢ Eq (tsum fun i => f i) (iSup fun i => (Finset.range i).sum fun a => f a)","decl":"protected theorem tsum_eq_iSup_nat {f : ℕ → ℝ≥0∞} :\n    ∑' i : ℕ, f i = ⨆ i : ℕ, ∑ a ∈ Finset.range i, f a :=\n  ENNReal.tsum_eq_iSup_sum' _ Finset.exists_nat_subset_range\n\n"}
{"name":"ENNReal.tsum_eq_liminf_sum_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\n⊢ Eq (tsum fun i => f i) (Filter.liminf (fun n => (Finset.range n).sum fun i => f i) Filter.atTop)","decl":"protected theorem tsum_eq_liminf_sum_nat {f : ℕ → ℝ≥0∞} :\n    ∑' i, f i = liminf (fun n => ∑ i ∈ Finset.range n, f i) atTop :=\n  ENNReal.summable.hasSum.tendsto_sum_nat.liminf_eq.symm\n\n"}
{"name":"ENNReal.tsum_eq_limsup_sum_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\n⊢ Eq (tsum fun i => f i) (Filter.limsup (fun n => (Finset.range n).sum fun i => f i) Filter.atTop)","decl":"protected theorem tsum_eq_limsup_sum_nat {f : ℕ → ℝ≥0∞} :\n    ∑' i, f i = limsup (fun n => ∑ i ∈ Finset.range n, f i) atTop :=\n  ENNReal.summable.hasSum.tendsto_sum_nat.limsup_eq.symm\n\n"}
{"name":"ENNReal.le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\na : α\n⊢ LE.le (f a) (tsum fun a => f a)","decl":"protected theorem le_tsum (a : α) : f a ≤ ∑' a, f a :=\n  le_tsum' ENNReal.summable a\n\n"}
{"name":"ENNReal.tsum_eq_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\n⊢ Iff (Eq (tsum fun i => f i) 0) (∀ (i : α), Eq (f i) 0)","decl":"@[simp]\nprotected theorem tsum_eq_zero : ∑' i, f i = 0 ↔ ∀ i, f i = 0 :=\n  tsum_eq_zero_iff ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_eq_top_of_eq_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\na✝ : Exists fun a => Eq (f a) Top.top\n⊢ Eq (tsum fun a => f a) Top.top","decl":"protected theorem tsum_eq_top_of_eq_top : (∃ a, f a = ∞) → ∑' a, f a = ∞\n  | ⟨a, ha⟩ => top_unique <| ha ▸ ENNReal.le_tsum a\n\n"}
{"name":"ENNReal.lt_top_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\na : α → ENNReal\ntsum_ne_top : Ne (tsum fun i => a i) Top.top\nj : α\n⊢ LT.lt (a j) Top.top","decl":"protected theorem lt_top_of_tsum_ne_top {a : α → ℝ≥0∞} (tsum_ne_top : ∑' i, a i ≠ ∞) (j : α) :\n    a j < ∞ := by\n  contrapose! tsum_ne_top with h\n  exact ENNReal.tsum_eq_top_of_eq_top ⟨j, top_unique h⟩\n\n"}
{"name":"ENNReal.tsum_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Eq (tsum fun x => Top.top) Top.top","decl":"@[simp]\nprotected theorem tsum_top [Nonempty α] : ∑' _ : α, ∞ = ∞ :=\n  let ⟨a⟩ := ‹Nonempty α›\n  ENNReal.tsum_eq_top_of_eq_top ⟨a, rfl⟩\n\n"}
{"name":"ENNReal.tsum_const_eq_top_of_ne_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\ninst✝ : Infinite α\nc : ENNReal\nhc : Ne c 0\n⊢ Eq (tsum fun x => c) Top.top","decl":"theorem tsum_const_eq_top_of_ne_zero {α : Type*} [Infinite α] {c : ℝ≥0∞} (hc : c ≠ 0) :\n    ∑' _ : α, c = ∞ := by\n  have A : Tendsto (fun n : ℕ => (n : ℝ≥0∞) * c) atTop (𝓝 (∞ * c)) := by\n    apply ENNReal.Tendsto.mul_const tendsto_nat_nhds_top\n    simp only [true_or, top_ne_zero, Ne, not_false_iff]\n  have B : ∀ n : ℕ, (n : ℝ≥0∞) * c ≤ ∑' _ : α, c := fun n => by\n    rcases Infinite.exists_subset_card_eq α n with ⟨s, hs⟩\n    simpa [hs] using @ENNReal.sum_le_tsum α (fun _ => c) s\n  simpa [hc] using le_of_tendsto' A B\n\n"}
{"name":"ENNReal.ne_top_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\nh : Ne (tsum fun a => f a) Top.top\na : α\n⊢ Ne (f a) Top.top","decl":"protected theorem ne_top_of_tsum_ne_top (h : ∑' a, f a ≠ ∞) (a : α) : f a ≠ ∞ := fun ha =>\n  h <| ENNReal.tsum_eq_top_of_eq_top ⟨a, ha⟩\n\n"}
{"name":"ENNReal.tsum_mul_left","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\na : ENNReal\nf : α → ENNReal\n⊢ Eq (tsum fun i => HMul.hMul a (f i)) (HMul.hMul a (tsum fun i => f i))","decl":"protected theorem tsum_mul_left : ∑' i, a * f i = a * ∑' i, f i := by\n  by_cases hf : ∀ i, f i = 0\n  · simp [hf]\n  · rw [← ENNReal.tsum_eq_zero] at hf\n    have : Tendsto (fun s : Finset α => ∑ j ∈ s, a * f j) atTop (𝓝 (a * ∑' i, f i)) := by\n      simp only [← Finset.mul_sum]\n      exact ENNReal.Tendsto.const_mul ENNReal.summable.hasSum (Or.inl hf)\n    exact HasSum.tsum_eq this\n\n"}
{"name":"ENNReal.tsum_mul_right","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\na : ENNReal\nf : α → ENNReal\n⊢ Eq (tsum fun i => HMul.hMul (f i) a) (HMul.hMul (tsum fun i => f i) a)","decl":"protected theorem tsum_mul_right : ∑' i, f i * a = (∑' i, f i) * a := by\n  simp [mul_comm, ENNReal.tsum_mul_left]\n\n"}
{"name":"ENNReal.tsum_const_smul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\nR : Type u_4\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\na : R\n⊢ Eq (tsum fun i => HSMul.hSMul a (f i)) (HSMul.hSMul a (tsum fun i => f i))","decl":"protected theorem tsum_const_smul {R} [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞] (a : R) :\n    ∑' i, a • f i = a • ∑' i, f i := by\n  simpa only [smul_one_mul] using @ENNReal.tsum_mul_left _ (a • (1 : ℝ≥0∞)) _\n\n"}
{"name":"ENNReal.tsum_iSup_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\na : α\nf : α → ENNReal\n⊢ Eq (tsum fun b => iSup fun x => f b) (f a)","decl":"@[simp]\ntheorem tsum_iSup_eq {α : Type*} (a : α) {f : α → ℝ≥0∞} : (∑' b : α, ⨆ _ : a = b, f b) = f a :=\n  (tsum_eq_single a fun _ h => by simp [h.symm]).trans <| by simp\n\n"}
{"name":"ENNReal.hasSum_iff_tendsto_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\nr : ENNReal\n⊢ Iff (HasSum f r) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds r))","decl":"theorem hasSum_iff_tendsto_nat {f : ℕ → ℝ≥0∞} (r : ℝ≥0∞) :\n    HasSum f r ↔ Tendsto (fun n : ℕ => ∑ i ∈ Finset.range n, f i) atTop (𝓝 r) := by\n  refine ⟨HasSum.tendsto_sum_nat, fun h => ?_⟩\n  rw [← iSup_eq_of_tendsto _ h, ← ENNReal.tsum_eq_iSup_nat]\n  · exact ENNReal.summable.hasSum\n  · exact fun s t hst => Finset.sum_le_sum_of_subset (Finset.range_subset.2 hst)\n\n"}
{"name":"ENNReal.tendsto_nat_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\n⊢ Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds (tsum fun n => f n))","decl":"theorem tendsto_nat_tsum (f : ℕ → ℝ≥0∞) :\n    Tendsto (fun n : ℕ => ∑ i ∈ Finset.range n, f i) atTop (𝓝 (∑' n, f n)) := by\n  rw [← hasSum_iff_tendsto_nat]\n  exact ENNReal.summable.hasSum\n\n"}
{"name":"ENNReal.toNNReal_apply_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\nf : α → ENNReal\nhf : Ne (tsum fun i => f i) Top.top\nx : α\n⊢ Eq (↑(Function.comp ENNReal.toNNReal f x)) (f x)","decl":"theorem toNNReal_apply_of_tsum_ne_top {α : Type*} {f : α → ℝ≥0∞} (hf : ∑' i, f i ≠ ∞) (x : α) :\n    (((ENNReal.toNNReal ∘ f) x : ℝ≥0) : ℝ≥0∞) = f x :=\n  coe_toNNReal <| ENNReal.ne_top_of_tsum_ne_top hf _\n\n"}
{"name":"ENNReal.summable_toNNReal_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\nf : α → ENNReal\nhf : Ne (tsum fun i => f i) Top.top\n⊢ Summable (Function.comp ENNReal.toNNReal f)","decl":"theorem summable_toNNReal_of_tsum_ne_top {α : Type*} {f : α → ℝ≥0∞} (hf : ∑' i, f i ≠ ∞) :\n    Summable (ENNReal.toNNReal ∘ f) := by\n  simpa only [← tsum_coe_ne_top_iff_summable, toNNReal_apply_of_tsum_ne_top hf] using hf\n\n"}
{"name":"ENNReal.tendsto_cofinite_zero_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\nf : α → ENNReal\nhf : Ne (tsum fun x => f x) Top.top\n⊢ Filter.Tendsto f Filter.cofinite (nhds 0)","decl":"theorem tendsto_cofinite_zero_of_tsum_ne_top {α} {f : α → ℝ≥0∞} (hf : ∑' x, f x ≠ ∞) :\n    Tendsto f cofinite (𝓝 0) := by\n  have f_ne_top : ∀ n, f n ≠ ∞ := ENNReal.ne_top_of_tsum_ne_top hf\n  have h_f_coe : f = fun n => ((f n).toNNReal : ENNReal) :=\n    funext fun n => (coe_toNNReal (f_ne_top n)).symm\n  rw [h_f_coe, ← @coe_zero, tendsto_coe]\n  exact NNReal.tendsto_cofinite_zero_of_summable (summable_toNNReal_of_tsum_ne_top hf)\n\n"}
{"name":"ENNReal.tendsto_atTop_zero_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\nhf : Ne (tsum fun x => f x) Top.top\n⊢ Filter.Tendsto f Filter.atTop (nhds 0)","decl":"theorem tendsto_atTop_zero_of_tsum_ne_top {f : ℕ → ℝ≥0∞} (hf : ∑' x, f x ≠ ∞) :\n    Tendsto f atTop (𝓝 0) := by\n  rw [← Nat.cofinite_eq_atTop]\n  exact tendsto_cofinite_zero_of_tsum_ne_top hf\n\n"}
{"name":"ENNReal.tendsto_tsum_compl_atTop_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\nf : α → ENNReal\nhf : Ne (tsum fun x => f x) Top.top\n⊢ Filter.Tendsto (fun s => tsum fun b => f ↑b) Filter.atTop (nhds 0)","decl":"/-- The sum over the complement of a finset tends to `0` when the finset grows to cover the whole\nspace. This does not need a summability assumption, as otherwise all sums are zero. -/\ntheorem tendsto_tsum_compl_atTop_zero {α : Type*} {f : α → ℝ≥0∞} (hf : ∑' x, f x ≠ ∞) :\n    Tendsto (fun s : Finset α => ∑' b : { x // x ∉ s }, f b) atTop (𝓝 0) := by\n  lift f to α → ℝ≥0 using ENNReal.ne_top_of_tsum_ne_top hf\n  convert ENNReal.tendsto_coe.2 (NNReal.tendsto_tsum_compl_atTop_zero f)\n  rw [ENNReal.coe_tsum]\n  exact NNReal.summable_comp_injective (tsum_coe_ne_top_iff_summable.1 hf) Subtype.coe_injective\n\n"}
{"name":"ENNReal.tsum_apply","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nα : Type u_5\nf : ι → α → ENNReal\nx : α\n⊢ Eq (tsum (fun i => f i) x) (tsum fun i => f i x)","decl":"protected theorem tsum_apply {ι α : Type*} {f : ι → α → ℝ≥0∞} {x : α} :\n    (∑' i, f i) x = ∑' i, f i x :=\n  tsum_apply <| Pi.summable.mpr fun _ => ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f g : Nat → ENNReal\nh₁ : Ne (tsum fun i => g i) Top.top\nh₂ : LE.le g f\n⊢ Eq (tsum fun i => HSub.hSub (f i) (g i)) (HSub.hSub (tsum fun i => f i) (tsum fun i => g i))","decl":"theorem tsum_sub {f : ℕ → ℝ≥0∞} {g : ℕ → ℝ≥0∞} (h₁ : ∑' i, g i ≠ ∞) (h₂ : g ≤ f) :\n    ∑' i, (f i - g i) = ∑' i, f i - ∑' i, g i :=\n  have : ∀ i, f i - g i + g i = f i := fun i => tsub_add_cancel_of_le (h₂ i)\n  ENNReal.eq_sub_of_add_eq h₁ <| by simp only [← ENNReal.tsum_add, this]\n\n"}
{"name":"ENNReal.tsum_comp_le_tsum_of_injective","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ng : β → ENNReal\n⊢ LE.le (tsum fun x => g (f x)) (tsum fun y => g y)","decl":"theorem tsum_comp_le_tsum_of_injective {f : α → β} (hf : Injective f) (g : β → ℝ≥0∞) :\n    ∑' x, g (f x) ≤ ∑' y, g y :=\n  tsum_le_tsum_of_inj f hf (fun _ _ => zero_le _) (fun _ => le_rfl) ENNReal.summable\n    ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_le_tsum_comp_of_surjective","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\ng : β → ENNReal\n⊢ LE.le (tsum fun y => g y) (tsum fun x => g (f x))","decl":"theorem tsum_le_tsum_comp_of_surjective {f : α → β} (hf : Surjective f) (g : β → ℝ≥0∞) :\n    ∑' y, g y ≤ ∑' x, g (f x) :=\n  calc ∑' y, g y = ∑' y, g (f (surjInv hf y)) := by simp only [surjInv_eq hf]\n  _ ≤ ∑' x, g (f x) := tsum_comp_le_tsum_of_injective (injective_surjInv hf) _\n\n"}
{"name":"ENNReal.tsum_mono_subtype","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\ns t : Set α\nh : HasSubset.Subset s t\n⊢ LE.le (tsum fun x => f ↑x) (tsum fun x => f ↑x)","decl":"theorem tsum_mono_subtype (f : α → ℝ≥0∞) {s t : Set α} (h : s ⊆ t) :\n    ∑' x : s, f x ≤ ∑' x : t, f x :=\n  tsum_comp_le_tsum_of_injective (inclusion_injective h) _\n\n"}
{"name":"ENNReal.tsum_iUnion_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nι : Type u_4\nf : α → ENNReal\nt : ι → Set α\n⊢ LE.le (tsum fun x => f ↑x) (tsum fun i => tsum fun x => f ↑x)","decl":"theorem tsum_iUnion_le_tsum {ι : Type*} (f : α → ℝ≥0∞) (t : ι → Set α) :\n    ∑' x : ⋃ i, t i, f x ≤ ∑' i, ∑' x : t i, f x :=\n  calc ∑' x : ⋃ i, t i, f x ≤ ∑' x : Σ i, t i, f x.2 :=\n    tsum_le_tsum_comp_of_surjective (sigmaToiUnion_surjective t) _\n  _ = ∑' i, ∑' x : t i, f x := ENNReal.tsum_sigma' _\n\n"}
{"name":"ENNReal.tsum_biUnion_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nι : Type u_4\nf : α → ENNReal\ns : Set ι\nt : ι → Set α\n⊢ LE.le (tsum fun x => f ↑x) (tsum fun i => tsum fun x => f ↑x)","decl":"theorem tsum_biUnion_le_tsum {ι : Type*} (f : α → ℝ≥0∞) (s : Set ι) (t : ι → Set α) :\n    ∑' x : ⋃ i ∈ s , t i, f x ≤ ∑' i : s, ∑' x : t i, f x :=\n  calc ∑' x : ⋃ i ∈ s, t i, f x = ∑' x : ⋃ i : s, t i, f x := tsum_congr_set_coe _ <| by simp\n  _ ≤ ∑' i : s, ∑' x : t i, f x := tsum_iUnion_le_tsum _ _\n\n"}
{"name":"ENNReal.tsum_biUnion_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nι : Type u_4\nf : α → ENNReal\ns : Finset ι\nt : ι → Set α\n⊢ LE.le (tsum fun x => f ↑x) (s.sum fun i => tsum fun x => f ↑x)","decl":"theorem tsum_biUnion_le {ι : Type*} (f : α → ℝ≥0∞) (s : Finset ι) (t : ι → Set α) :\n    ∑' x : ⋃ i ∈ s, t i, f x ≤ ∑ i ∈ s, ∑' x : t i, f x :=\n  (tsum_biUnion_le_tsum f s.toSet t).trans_eq (Finset.tsum_subtype s fun i => ∑' x : t i, f x)\n\n"}
{"name":"ENNReal.tsum_iUnion_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : Fintype ι\nf : α → ENNReal\nt : ι → Set α\n⊢ LE.le (tsum fun x => f ↑x) (Finset.univ.sum fun i => tsum fun x => f ↑x)","decl":"theorem tsum_iUnion_le {ι : Type*} [Fintype ι] (f : α → ℝ≥0∞) (t : ι → Set α) :\n    ∑' x : ⋃ i, t i, f x ≤ ∑ i, ∑' x : t i, f x := by\n  rw [← tsum_fintype]\n  exact tsum_iUnion_le_tsum f t\n\n"}
{"name":"ENNReal.tsum_union_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\ns t : Set α\n⊢ LE.le (tsum fun x => f ↑x) (HAdd.hAdd (tsum fun x => f ↑x) (tsum fun x => f ↑x))","decl":"theorem tsum_union_le (f : α → ℝ≥0∞) (s t : Set α) :\n    ∑' x : ↑(s ∪ t), f x ≤ ∑' x : s, f x + ∑' x : t, f x :=\n  calc ∑' x : ↑(s ∪ t), f x = ∑' x : ⋃ b, cond b s t, f x := tsum_congr_set_coe _ union_eq_iUnion\n  _ ≤ _ := by simpa using tsum_iUnion_le f (cond · s t)\n\n"}
{"name":"ENNReal.tsum_eq_add_tsum_ite","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\nf : β → ENNReal\nb : β\n⊢ Eq (tsum fun x => f x) (HAdd.hAdd (f b) (tsum fun x => ite (Eq x b) 0 (f x)))","decl":"open Classical in\ntheorem tsum_eq_add_tsum_ite {f : β → ℝ≥0∞} (b : β) :\n    ∑' x, f x = f b + ∑' x, ite (x = b) 0 (f x) :=\n  tsum_eq_add_tsum_ite' b ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_add_one_eq_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\nhf : Eq (tsum fun n => f n) Top.top\nhf0 : Ne (f 0) Top.top\n⊢ Eq (tsum fun n => f (HAdd.hAdd n 1)) Top.top","decl":"theorem tsum_add_one_eq_top {f : ℕ → ℝ≥0∞} (hf : ∑' n, f n = ∞) (hf0 : f 0 ≠ ∞) :\n    ∑' n, f (n + 1) = ∞ := by\n  rw [tsum_eq_zero_add' ENNReal.summable, add_eq_top] at hf\n  exact hf.resolve_left hf0\n\n"}
{"name":"ENNReal.finite_const_le_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\na : ι → ENNReal\ntsum_ne_top : Ne (tsum fun i => a i) Top.top\nε : ENNReal\nε_ne_zero : Ne ε 0\n⊢ (setOf fun i => LE.le ε (a i)).Finite","decl":"/-- A sum of extended nonnegative reals which is finite can have only finitely many terms\nabove any positive threshold. -/\ntheorem finite_const_le_of_tsum_ne_top {ι : Type*} {a : ι → ℝ≥0∞} (tsum_ne_top : ∑' i, a i ≠ ∞)\n    {ε : ℝ≥0∞} (ε_ne_zero : ε ≠ 0) : { i : ι | ε ≤ a i }.Finite := by\n  by_contra h\n  have := Infinite.to_subtype h\n  refine tsum_ne_top (top_unique ?_)\n  calc ∞ = ∑' _ : { i | ε ≤ a i }, ε := (tsum_const_eq_top_of_ne_zero ε_ne_zero).symm\n  _ ≤ ∑' i, a i := tsum_le_tsum_of_inj (↑) Subtype.val_injective (fun _ _ => zero_le _)\n    (fun i => i.2) ENNReal.summable ENNReal.summable\n\n"}
{"name":"ENNReal.finset_card_const_le_le_of_tsum_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\na : ι → ENNReal\nc : ENNReal\nc_ne_top : Ne c Top.top\ntsum_le_c : LE.le (tsum fun i => a i) c\nε : ENNReal\nε_ne_zero : Ne ε 0\n⊢ Exists fun hf => LE.le (↑hf.toFinset.card) (HDiv.hDiv c ε)","decl":"/-- Markov's inequality for `Finset.card` and `tsum` in `ℝ≥0∞`. -/\ntheorem finset_card_const_le_le_of_tsum_le {ι : Type*} {a : ι → ℝ≥0∞} {c : ℝ≥0∞} (c_ne_top : c ≠ ∞)\n    (tsum_le_c : ∑' i, a i ≤ c) {ε : ℝ≥0∞} (ε_ne_zero : ε ≠ 0) :\n    ∃ hf : { i : ι | ε ≤ a i }.Finite, #hf.toFinset ≤ c / ε := by\n  have hf : { i : ι | ε ≤ a i }.Finite :=\n    finite_const_le_of_tsum_ne_top (ne_top_of_le_ne_top c_ne_top tsum_le_c) ε_ne_zero\n  refine ⟨hf, (ENNReal.le_div_iff_mul_le (.inl ε_ne_zero) (.inr c_ne_top)).2 ?_⟩\n  calc #hf.toFinset * ε = ∑ _i ∈ hf.toFinset, ε := by rw [Finset.sum_const, nsmul_eq_mul]\n    _ ≤ ∑ i ∈ hf.toFinset, a i := Finset.sum_le_sum fun i => hf.mem_toFinset.1\n    _ ≤ ∑' i, a i := ENNReal.sum_le_tsum _\n    _ ≤ c := tsum_le_c\n\n"}
{"name":"ENNReal.tsum_fiberwise","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\nγ : Type u_3\nf : β → ENNReal\ng : β → γ\n⊢ Eq (tsum fun x => tsum fun b => f ↑b) (tsum fun i => f i)","decl":"theorem tsum_fiberwise (f : β → ℝ≥0∞) (g : β → γ) :\n    ∑' x, ∑' b : g ⁻¹' {x}, f b = ∑' i, f i := by\n  apply HasSum.tsum_eq\n  let equiv := Equiv.sigmaFiberEquiv g\n  apply (equiv.hasSum_iff.mpr ENNReal.summable.hasSum).sigma\n  exact fun _ ↦ ENNReal.summable.hasSum_iff.mpr rfl\n\n"}
{"name":"ENNReal.tendsto_toReal_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nfi : Filter ι\nf : ι → ENNReal\nhf : ∀ (i : ι), Ne (f i) Top.top\nx : ENNReal\nhx : Ne x Top.top\n⊢ Iff (Filter.Tendsto (fun n => (f n).toReal) fi (nhds x.toReal)) (Filter.Tendsto f fi (nhds x))","decl":"theorem tendsto_toReal_iff {ι} {fi : Filter ι} {f : ι → ℝ≥0∞} (hf : ∀ i, f i ≠ ∞) {x : ℝ≥0∞}\n    (hx : x ≠ ∞) : Tendsto (fun n => (f n).toReal) fi (𝓝 x.toReal) ↔ Tendsto f fi (𝓝 x) := by\n  lift f to ι → ℝ≥0 using hf\n  lift x to ℝ≥0 using hx\n  simp [tendsto_coe]\n\n"}
{"name":"ENNReal.tsum_coe_ne_top_iff_summable_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → NNReal\n⊢ Iff (Ne (tsum fun a => ↑(f a)) Top.top) (Summable fun a => ↑(f a))","decl":"theorem tsum_coe_ne_top_iff_summable_coe {f : α → ℝ≥0} :\n    (∑' a, (f a : ℝ≥0∞)) ≠ ∞ ↔ Summable fun a => (f a : ℝ) := by\n  rw [NNReal.summable_coe]\n  exact tsum_coe_ne_top_iff_summable\n\n"}
{"name":"ENNReal.tsum_coe_eq_top_iff_not_summable_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → NNReal\n⊢ Iff (Eq (tsum fun a => ↑(f a)) Top.top) (Not (Summable fun a => ↑(f a)))","decl":"theorem tsum_coe_eq_top_iff_not_summable_coe {f : α → ℝ≥0} :\n    (∑' a, (f a : ℝ≥0∞)) = ∞ ↔ ¬Summable fun a => (f a : ℝ) :=\n  tsum_coe_ne_top_iff_summable_coe.not_right\n\n"}
{"name":"ENNReal.hasSum_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\nhsum : Ne (tsum fun x => f x) Top.top\n⊢ HasSum (fun x => (f x).toReal) (tsum fun x => (f x).toReal)","decl":"theorem hasSum_toReal {f : α → ℝ≥0∞} (hsum : ∑' x, f x ≠ ∞) :\n    HasSum (fun x => (f x).toReal) (∑' x, (f x).toReal) := by\n  lift f to α → ℝ≥0 using ENNReal.ne_top_of_tsum_ne_top hsum\n  simp only [coe_toReal, ← NNReal.coe_tsum, NNReal.hasSum_coe]\n  exact (tsum_coe_ne_top_iff_summable.1 hsum).hasSum\n\n"}
{"name":"ENNReal.summable_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\nhsum : Ne (tsum fun x => f x) Top.top\n⊢ Summable fun x => (f x).toReal","decl":"theorem summable_toReal {f : α → ℝ≥0∞} (hsum : ∑' x, f x ≠ ∞) : Summable fun x => (f x).toReal :=\n  (hasSum_toReal hsum).summable\n\n"}
{"name":"NNReal.tsum_eq_toNNReal_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\nf : β → NNReal\n⊢ Eq (tsum fun b => f b) (tsum fun b => ↑(f b)).toNNReal","decl":"theorem tsum_eq_toNNReal_tsum {f : β → ℝ≥0} : ∑' b, f b = (∑' b, (f b : ℝ≥0∞)).toNNReal := by\n  by_cases h : Summable f\n  · rw [← ENNReal.coe_tsum h, ENNReal.toNNReal_coe]\n  · have A := tsum_eq_zero_of_not_summable h\n    simp only [← ENNReal.tsum_coe_ne_top_iff_summable, Classical.not_not] at h\n    simp only [h, ENNReal.top_toNNReal, A]\n\n"}
{"name":"NNReal.exists_le_hasSum_of_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\nf g : β → NNReal\nr : NNReal\nhgf : ∀ (b : β), LE.le (g b) (f b)\nhfr : HasSum f r\n⊢ Exists fun p => And (LE.le p r) (HasSum g p)","decl":"/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem exists_le_hasSum_of_le {f g : β → ℝ≥0} {r : ℝ≥0} (hgf : ∀ b, g b ≤ f b) (hfr : HasSum f r) :\n    ∃ p ≤ r, HasSum g p :=\n  have : (∑' b, (g b : ℝ≥0∞)) ≤ r := by\n    refine hasSum_le (fun b => ?_) ENNReal.summable.hasSum (ENNReal.hasSum_coe.2 hfr)\n    exact ENNReal.coe_le_coe.2 (hgf _)\n  let ⟨p, Eq, hpr⟩ := ENNReal.le_coe_iff.1 this\n  ⟨p, hpr, ENNReal.hasSum_coe.1 <| Eq ▸ ENNReal.summable.hasSum⟩\n\n"}
{"name":"NNReal.summable_of_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\nf g : β → NNReal\nhgf : ∀ (b : β), LE.le (g b) (f b)\na✝ : Summable f\n⊢ Summable g","decl":"/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem summable_of_le {f g : β → ℝ≥0} (hgf : ∀ b, g b ≤ f b) : Summable f → Summable g\n  | ⟨_r, hfr⟩ =>\n    let ⟨_p, _, hp⟩ := exists_le_hasSum_of_le hgf hfr\n    hp.summable\n\n"}
{"name":"Summable.countable_support_nnreal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → NNReal\nh : Summable f\n⊢ (Function.support f).Countable","decl":"/-- Summable non-negative functions have countable support -/\ntheorem _root_.Summable.countable_support_nnreal (f : α → ℝ≥0) (h : Summable f) :\n    f.support.Countable := by\n  rw [← NNReal.summable_coe] at h\n  simpa [support] using h.countable_support\n\n"}
{"name":"NNReal.hasSum_iff_tendsto_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → NNReal\nr : NNReal\n⊢ Iff (HasSum f r) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds r))","decl":"/-- A series of non-negative real numbers converges to `r` in the sense of `HasSum` if and only if\nthe sequence of partial sum converges to `r`. -/\ntheorem hasSum_iff_tendsto_nat {f : ℕ → ℝ≥0} {r : ℝ≥0} :\n    HasSum f r ↔ Tendsto (fun n : ℕ => ∑ i ∈ Finset.range n, f i) atTop (𝓝 r) := by\n  rw [← ENNReal.hasSum_coe, ENNReal.hasSum_iff_tendsto_nat]\n  simp only [← ENNReal.coe_finset_sum]\n  exact ENNReal.tendsto_coe\n\n"}
{"name":"NNReal.not_summable_iff_tendsto_nat_atTop","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → NNReal\n⊢ Iff (Not (Summable f)) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop Filter.atTop)","decl":"theorem not_summable_iff_tendsto_nat_atTop {f : ℕ → ℝ≥0} :\n    ¬Summable f ↔ Tendsto (fun n : ℕ => ∑ i ∈ Finset.range n, f i) atTop atTop := by\n  constructor\n  · intro h\n    refine ((tendsto_of_monotone ?_).resolve_right h).comp ?_\n    exacts [Finset.sum_mono_set _, tendsto_finset_range]\n  · rintro hnat ⟨r, hr⟩\n    exact not_tendsto_nhds_of_tendsto_atTop hnat _ (hasSum_iff_tendsto_nat.1 hr)\n\n"}
{"name":"NNReal.summable_iff_not_tendsto_nat_atTop","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → NNReal\n⊢ Iff (Summable f) (Not (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop Filter.atTop))","decl":"theorem summable_iff_not_tendsto_nat_atTop {f : ℕ → ℝ≥0} :\n    Summable f ↔ ¬Tendsto (fun n : ℕ => ∑ i ∈ Finset.range n, f i) atTop atTop := by\n  rw [← not_iff_not, Classical.not_not, not_summable_iff_tendsto_nat_atTop]\n\n"}
{"name":"NNReal.summable_of_sum_range_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → NNReal\nc : NNReal\nh : ∀ (n : Nat), LE.le ((Finset.range n).sum fun i => f i) c\n⊢ Summable f","decl":"theorem summable_of_sum_range_le {f : ℕ → ℝ≥0} {c : ℝ≥0}\n    (h : ∀ n, ∑ i ∈ Finset.range n, f i ≤ c) : Summable f := by\n  refine summable_iff_not_tendsto_nat_atTop.2 fun H => ?_\n  rcases exists_lt_of_tendsto_atTop H 0 c with ⟨n, -, hn⟩\n  exact lt_irrefl _ (hn.trans_le (h n))\n\n"}
{"name":"NNReal.tsum_le_of_sum_range_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → NNReal\nc : NNReal\nh : ∀ (n : Nat), LE.le ((Finset.range n).sum fun i => f i) c\n⊢ LE.le (tsum fun n => f n) c","decl":"theorem tsum_le_of_sum_range_le {f : ℕ → ℝ≥0} {c : ℝ≥0}\n    (h : ∀ n, ∑ i ∈ Finset.range n, f i ≤ c) : ∑' n, f n ≤ c :=\n  _root_.tsum_le_of_sum_range_le (summable_of_sum_range_le h) h\n\n"}
{"name":"NNReal.tsum_comp_le_tsum_of_inj","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_4\nf : α → NNReal\nhf : Summable f\ni : β → α\nhi : Function.Injective i\n⊢ LE.le (tsum fun x => f (i x)) (tsum fun x => f x)","decl":"theorem tsum_comp_le_tsum_of_inj {β : Type*} {f : α → ℝ≥0} (hf : Summable f) {i : β → α}\n    (hi : Function.Injective i) : (∑' x, f (i x)) ≤ ∑' x, f x :=\n  tsum_le_tsum_of_inj i hi (fun _ _ => zero_le _) (fun _ => le_rfl) (summable_comp_injective hf hi)\n    hf\n\n"}
{"name":"NNReal.summable_sigma","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : α → Type u_4\nf : (Sigma fun x => β x) → NNReal\n⊢ Iff (Summable f) (And (∀ (x : α), Summable fun y => f ⟨x, y⟩) (Summable fun x => tsum fun y => f ⟨x, y⟩))","decl":"theorem summable_sigma {β : α → Type*} {f : (Σ x, β x) → ℝ≥0} :\n    Summable f ↔ (∀ x, Summable fun y => f ⟨x, y⟩) ∧ Summable fun x => ∑' y, f ⟨x, y⟩ := by\n  constructor\n  · simp only [← NNReal.summable_coe, NNReal.coe_tsum]\n    exact fun h => ⟨h.sigma_factor, h.sigma⟩\n  · rintro ⟨h₁, h₂⟩\n    simpa only [← ENNReal.tsum_coe_ne_top_iff_summable, ENNReal.tsum_sigma',\n      ENNReal.coe_tsum (h₁ _)] using h₂\n\n"}
{"name":"NNReal.indicator_summable","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → NNReal\nhf : Summable f\ns : Set α\n⊢ Summable (s.indicator f)","decl":"theorem indicator_summable {f : α → ℝ≥0} (hf : Summable f) (s : Set α) :\n    Summable (s.indicator f) := by\n  classical\n  refine NNReal.summable_of_le (fun a => le_trans (le_of_eq (s.indicator_apply f a)) ?_) hf\n  split_ifs\n  · exact le_refl (f a)\n  · exact zero_le_coe\n\n"}
{"name":"NNReal.tsum_indicator_ne_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → NNReal\nhf : Summable f\ns : Set α\nh : Exists fun a => And (Membership.mem s a) (Ne (f a) 0)\n⊢ Ne (tsum fun x => s.indicator f x) 0","decl":"theorem tsum_indicator_ne_zero {f : α → ℝ≥0} (hf : Summable f) {s : Set α} (h : ∃ a ∈ s, f a ≠ 0) :\n    (∑' x, (s.indicator f) x) ≠ 0 := fun h' =>\n  let ⟨a, ha, hap⟩ := h\n  hap ((Set.indicator_apply_eq_self.mpr (absurd ha)).symm.trans\n    ((tsum_eq_zero_iff (indicator_summable hf s)).1 h' a))\n\n"}
{"name":"NNReal.tendsto_sum_nat_add","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → NNReal\n⊢ Filter.Tendsto (fun i => tsum fun k => f (HAdd.hAdd k i)) Filter.atTop (nhds 0)","decl":"/-- For `f : ℕ → ℝ≥0`, then `∑' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. -/\ntheorem tendsto_sum_nat_add (f : ℕ → ℝ≥0) : Tendsto (fun i => ∑' k, f (k + i)) atTop (𝓝 0) := by\n  rw [← tendsto_coe]\n  convert _root_.tendsto_sum_nat_add fun i => (f i : ℝ)\n  norm_cast\n\n"}
{"name":"NNReal.hasSum_lt","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf g : α → NNReal\nsf sg : NNReal\ni : α\nh : ∀ (a : α), LE.le (f a) (g a)\nhi : LT.lt (f i) (g i)\nhf : HasSum f sf\nhg : HasSum g sg\n⊢ LT.lt sf sg","decl":"nonrec theorem hasSum_lt {f g : α → ℝ≥0} {sf sg : ℝ≥0} {i : α} (h : ∀ a : α, f a ≤ g a)\n    (hi : f i < g i) (hf : HasSum f sf) (hg : HasSum g sg) : sf < sg := by\n  have A : ∀ a : α, (f a : ℝ) ≤ g a := fun a => NNReal.coe_le_coe.2 (h a)\n  have : (sf : ℝ) < sg := hasSum_lt A (NNReal.coe_lt_coe.2 hi) (hasSum_coe.2 hf) (hasSum_coe.2 hg)\n  exact NNReal.coe_lt_coe.1 this\n\n"}
{"name":"NNReal.hasSum_strict_mono","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf g : α → NNReal\nsf sg : NNReal\nhf : HasSum f sf\nhg : HasSum g sg\nh : LT.lt f g\n⊢ LT.lt sf sg","decl":"@[mono]\ntheorem hasSum_strict_mono {f g : α → ℝ≥0} {sf sg : ℝ≥0} (hf : HasSum f sf) (hg : HasSum g sg)\n    (h : f < g) : sf < sg :=\n  let ⟨hle, _i, hi⟩ := Pi.lt_def.mp h\n  hasSum_lt hle hi hf hg\n\n"}
{"name":"NNReal.tsum_lt_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf g : α → NNReal\ni : α\nh : ∀ (a : α), LE.le (f a) (g a)\nhi : LT.lt (f i) (g i)\nhg : Summable g\n⊢ LT.lt (tsum fun n => f n) (tsum fun n => g n)","decl":"theorem tsum_lt_tsum {f g : α → ℝ≥0} {i : α} (h : ∀ a : α, f a ≤ g a) (hi : f i < g i)\n    (hg : Summable g) : ∑' n, f n < ∑' n, g n :=\n  hasSum_lt h hi (summable_of_le h hg).hasSum hg.hasSum\n\n"}
{"name":"NNReal.tsum_strict_mono","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf g : α → NNReal\nhg : Summable g\nh : LT.lt f g\n⊢ LT.lt (tsum fun n => f n) (tsum fun n => g n)","decl":"@[mono]\ntheorem tsum_strict_mono {f g : α → ℝ≥0} (hg : Summable g) (h : f < g) : ∑' n, f n < ∑' n, g n :=\n  let ⟨hle, _i, hi⟩ := Pi.lt_def.mp h\n  tsum_lt_tsum hle hi hg\n\n"}
{"name":"NNReal.tsum_pos","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ng : α → NNReal\nhg : Summable g\ni : α\nhi : LT.lt 0 (g i)\n⊢ LT.lt 0 (tsum fun b => g b)","decl":"theorem tsum_pos {g : α → ℝ≥0} (hg : Summable g) (i : α) (hi : 0 < g i) : 0 < ∑' b, g b := by\n  rw [← tsum_zero]\n  exact tsum_lt_tsum (fun a => zero_le _) hi hg\n\n"}
{"name":"NNReal.tsum_eq_add_tsum_ite","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → NNReal\nhf : Summable f\ni : α\n⊢ Eq (tsum fun x => f x) (HAdd.hAdd (f i) (tsum fun x => ite (Eq x i) 0 (f x)))","decl":"open Classical in\ntheorem tsum_eq_add_tsum_ite {f : α → ℝ≥0} (hf : Summable f) (i : α) :\n    ∑' x, f x = f i + ∑' x, ite (x = i) 0 (f x) := by\n  refine tsum_eq_add_tsum_ite' i (NNReal.summable_of_le (fun i' => ?_) hf)\n  rw [Function.update_apply]\n  split_ifs <;> simp only [zero_le', le_rfl]\n\n"}
{"name":"ENNReal.tsum_toNNReal_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\nhf : ∀ (a : α), Ne (f a) Top.top\n⊢ Eq (tsum fun a => f a).toNNReal (tsum fun a => (f a).toNNReal)","decl":"theorem tsum_toNNReal_eq {f : α → ℝ≥0∞} (hf : ∀ a, f a ≠ ∞) :\n    (∑' a, f a).toNNReal = ∑' a, (f a).toNNReal :=\n  (congr_arg ENNReal.toNNReal (tsum_congr fun x => (coe_toNNReal (hf x)).symm)).trans\n    NNReal.tsum_eq_toNNReal_tsum.symm\n\n"}
{"name":"ENNReal.tsum_toReal_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\nhf : ∀ (a : α), Ne (f a) Top.top\n⊢ Eq (tsum fun a => f a).toReal (tsum fun a => (f a).toReal)","decl":"theorem tsum_toReal_eq {f : α → ℝ≥0∞} (hf : ∀ a, f a ≠ ∞) :\n    (∑' a, f a).toReal = ∑' a, (f a).toReal := by\n  simp only [ENNReal.toReal, tsum_toNNReal_eq hf, NNReal.coe_tsum]\n\n"}
{"name":"ENNReal.tendsto_sum_nat_add","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\nhf : Ne (tsum fun i => f i) Top.top\n⊢ Filter.Tendsto (fun i => tsum fun k => f (HAdd.hAdd k i)) Filter.atTop (nhds 0)","decl":"theorem tendsto_sum_nat_add (f : ℕ → ℝ≥0∞) (hf : ∑' i, f i ≠ ∞) :\n    Tendsto (fun i => ∑' k, f (k + i)) atTop (𝓝 0) := by\n  lift f to ℕ → ℝ≥0 using ENNReal.ne_top_of_tsum_ne_top hf\n  replace hf : Summable f := tsum_coe_ne_top_iff_summable.1 hf\n  simp only [← ENNReal.coe_tsum, NNReal.summable_nat_add _ hf, ← ENNReal.coe_zero]\n  exact mod_cast NNReal.tendsto_sum_nat_add f\n\n"}
{"name":"ENNReal.tsum_le_of_sum_range_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → ENNReal\nc : ENNReal\nh : ∀ (n : Nat), LE.le ((Finset.range n).sum fun i => f i) c\n⊢ LE.le (tsum fun n => f n) c","decl":"theorem tsum_le_of_sum_range_le {f : ℕ → ℝ≥0∞} {c : ℝ≥0∞}\n    (h : ∀ n, ∑ i ∈ Finset.range n, f i ≤ c) : ∑' n, f n ≤ c :=\n  _root_.tsum_le_of_sum_range_le ENNReal.summable h\n\n"}
{"name":"ENNReal.hasSum_lt","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf g : α → ENNReal\nsf sg : ENNReal\ni : α\nh : ∀ (a : α), LE.le (f a) (g a)\nhi : LT.lt (f i) (g i)\nhsf : Ne sf Top.top\nhf : HasSum f sf\nhg : HasSum g sg\n⊢ LT.lt sf sg","decl":"theorem hasSum_lt {f g : α → ℝ≥0∞} {sf sg : ℝ≥0∞} {i : α} (h : ∀ a : α, f a ≤ g a) (hi : f i < g i)\n    (hsf : sf ≠ ∞) (hf : HasSum f sf) (hg : HasSum g sg) : sf < sg := by\n  by_cases hsg : sg = ∞\n  · exact hsg.symm ▸ lt_of_le_of_ne le_top hsf\n  · have hg' : ∀ x, g x ≠ ∞ := ENNReal.ne_top_of_tsum_ne_top (hg.tsum_eq.symm ▸ hsg)\n    lift f to α → ℝ≥0 using fun x =>\n      ne_of_lt (lt_of_le_of_lt (h x) <| lt_of_le_of_ne le_top (hg' x))\n    lift g to α → ℝ≥0 using hg'\n    lift sf to ℝ≥0 using hsf\n    lift sg to ℝ≥0 using hsg\n    simp only [coe_le_coe, coe_lt_coe] at h hi ⊢\n    exact NNReal.hasSum_lt h hi (ENNReal.hasSum_coe.1 hf) (ENNReal.hasSum_coe.1 hg)\n\n"}
{"name":"ENNReal.tsum_lt_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf g : α → ENNReal\ni : α\nhfi : Ne (tsum f) Top.top\nh : ∀ (a : α), LE.le (f a) (g a)\nhi : LT.lt (f i) (g i)\n⊢ LT.lt (tsum fun x => f x) (tsum fun x => g x)","decl":"theorem tsum_lt_tsum {f g : α → ℝ≥0∞} {i : α} (hfi : tsum f ≠ ∞) (h : ∀ a : α, f a ≤ g a)\n    (hi : f i < g i) : ∑' x, f x < ∑' x, g x :=\n  hasSum_lt h hi hfi ENNReal.summable.hasSum ENNReal.summable.hasSum\n\n"}
{"name":"tsum_comp_le_tsum_of_inj","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_4\nf : α → Real\nhf : Summable f\nhn : ∀ (a : α), LE.le 0 (f a)\ni : β → α\nhi : Function.Injective i\n⊢ LE.le (tsum (Function.comp f i)) (tsum f)","decl":"theorem tsum_comp_le_tsum_of_inj {β : Type*} {f : α → ℝ} (hf : Summable f) (hn : ∀ a, 0 ≤ f a)\n    {i : β → α} (hi : Function.Injective i) : tsum (f ∘ i) ≤ tsum f := by\n  lift f to α → ℝ≥0 using hn\n  rw [NNReal.summable_coe] at hf\n  simpa only [Function.comp_def, ← NNReal.coe_tsum] using NNReal.tsum_comp_le_tsum_of_inj hf hi\n\n"}
{"name":"Summable.of_nonneg_of_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\nf g : β → Real\nhg : ∀ (b : β), LE.le 0 (g b)\nhgf : ∀ (b : β), LE.le (g b) (f b)\nhf : Summable f\n⊢ Summable g","decl":"/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem Summable.of_nonneg_of_le {f g : β → ℝ} (hg : ∀ b, 0 ≤ g b) (hgf : ∀ b, g b ≤ f b)\n    (hf : Summable f) : Summable g := by\n  lift f to β → ℝ≥0 using fun b => (hg b).trans (hgf b)\n  lift g to β → ℝ≥0 using hg\n  rw [NNReal.summable_coe] at hf ⊢\n  exact NNReal.summable_of_le (fun b => NNReal.coe_le_coe.1 (hgf b)) hf\n\n"}
{"name":"Summable.toNNReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → Real\nhf : Summable f\n⊢ Summable fun n => (f n).toNNReal","decl":"theorem Summable.toNNReal {f : α → ℝ} (hf : Summable f) : Summable fun n => (f n).toNNReal := by\n  apply NNReal.summable_coe.1\n  refine .of_nonneg_of_le (fun n => NNReal.coe_nonneg _) (fun n => ?_) hf.abs\n  simp only [le_abs_self, Real.coe_toNNReal', max_le_iff, abs_nonneg, and_self_iff]\n\n"}
{"name":"Summable.countable_support_ennreal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → ENNReal\nh : Ne (tsum fun i => f i) Top.top\n⊢ (Function.support f).Countable","decl":"/-- Finitely summable non-negative functions have countable support -/\ntheorem _root_.Summable.countable_support_ennreal {f : α → ℝ≥0∞} (h : ∑' (i : α), f i ≠ ∞) :\n    f.support.Countable := by\n  lift f to α → ℝ≥0 using ENNReal.ne_top_of_tsum_ne_top h\n  simpa [support] using (ENNReal.tsum_coe_ne_top_iff_summable.1 h).countable_support_nnreal\n\n"}
{"name":"hasSum_iff_tendsto_nat_of_nonneg","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat → Real\nhf : ∀ (i : Nat), LE.le 0 (f i)\nr : Real\n⊢ Iff (HasSum f r) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds r))","decl":"/-- A series of non-negative real numbers converges to `r` in the sense of `HasSum` if and only if\nthe sequence of partial sum converges to `r`. -/\ntheorem hasSum_iff_tendsto_nat_of_nonneg {f : ℕ → ℝ} (hf : ∀ i, 0 ≤ f i) (r : ℝ) :\n    HasSum f r ↔ Tendsto (fun n : ℕ => ∑ i ∈ Finset.range n, f i) atTop (𝓝 r) := by\n  lift f to ℕ → ℝ≥0 using hf\n  simp only [HasSum, ← NNReal.coe_sum, NNReal.tendsto_coe']\n  exact exists_congr fun hr => NNReal.hasSum_iff_tendsto_nat\n\n"}
{"name":"ENNReal.ofReal_tsum_of_nonneg","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nf : α → Real\nhf_nonneg : ∀ (n : α), LE.le 0 (f n)\nhf : Summable f\n⊢ Eq (ENNReal.ofReal (tsum fun n => f n)) (tsum fun n => ENNReal.ofReal (f n))","decl":"theorem ENNReal.ofReal_tsum_of_nonneg {f : α → ℝ} (hf_nonneg : ∀ n, 0 ≤ f n) (hf : Summable f) :\n    ENNReal.ofReal (∑' n, f n) = ∑' n, ENNReal.ofReal (f n) := by\n  simp_rw [ENNReal.ofReal, ENNReal.tsum_coe_eq (NNReal.hasSum_real_toNNReal_of_nonneg hf_nonneg hf)]\n\n"}
{"name":"edist_ne_top_of_mem_ball","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\ninst✝ : EMetricSpace β\na : β\nr : ENNReal\nx y : ↑(EMetric.ball a r)\n⊢ Ne (EDist.edist ↑x ↑y) Top.top","decl":"/-- In an emetric ball, the distance between points is everywhere finite -/\ntheorem edist_ne_top_of_mem_ball {a : β} {r : ℝ≥0∞} (x y : ball a r) : edist x.1 y.1 ≠ ∞ :=\n  ne_of_lt <|\n    calc\n      edist x y ≤ edist a x + edist a y := edist_triangle_left x.1 y.1 a\n      _ < r + r := by rw [edist_comm a x, edist_comm a y]; exact ENNReal.add_lt_add x.2 y.2\n      _ ≤ ∞ := le_top\n\n"}
{"name":"nhds_eq_nhds_emetric_ball","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"β : Type u_2\ninst✝ : EMetricSpace β\na x : β\nr : ENNReal\nh : Membership.mem (EMetric.ball a r) x\n⊢ Eq (nhds x) (Filter.map Subtype.val (nhds ⟨x, h⟩))","decl":"theorem nhds_eq_nhds_emetric_ball (a x : β) (r : ℝ≥0∞) (h : x ∈ ball a r) :\n    𝓝 x = map ((↑) : ball a r → β) (𝓝 ⟨x, h⟩) :=\n  (map_nhds_subtype_coe_eq_nhds _ <| IsOpen.mem_nhds EMetric.isOpen_ball h).symm\n\n"}
{"name":"tendsto_iff_edist_tendsto_0","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : PseudoEMetricSpace α\nl : Filter β\nf : β → α\ny : α\n⊢ Iff (Filter.Tendsto f l (nhds y)) (Filter.Tendsto (fun x => EDist.edist (f x) y) l (nhds 0))","decl":"theorem tendsto_iff_edist_tendsto_0 {l : Filter β} {f : β → α} {y : α} :\n    Tendsto f l (𝓝 y) ↔ Tendsto (fun x => edist (f x) y) l (𝓝 0) := by\n  simp only [EMetric.nhds_basis_eball.tendsto_right_iff, EMetric.mem_ball,\n    @tendsto_order ℝ≥0∞ β _ _, forall_prop_of_false ENNReal.not_lt_zero, forall_const, true_and]\n\n"}
{"name":"EMetric.cauchySeq_iff_le_tendsto_0","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\ns : β → α\n⊢ Iff (CauchySeq s) (Exists fun b => And (∀ (n m N : β), LE.le N n → LE.le N m → LE.le (EDist.edist (s n) (s m)) (b N)) (Filter.Tendsto b Filter.atTop (nhds 0)))","decl":"/-- Yet another metric characterization of Cauchy sequences on integers. This one is often the\nmost efficient. -/\ntheorem EMetric.cauchySeq_iff_le_tendsto_0 [Nonempty β] [SemilatticeSup β] {s : β → α} :\n    CauchySeq s ↔ ∃ b : β → ℝ≥0∞, (∀ n m N : β, N ≤ n → N ≤ m → edist (s n) (s m) ≤ b N) ∧\n      Tendsto b atTop (𝓝 0) := EMetric.cauchySeq_iff.trans <| by\n  constructor\n  · intro hs\n    /- `s` is Cauchy sequence. Let `b n` be the diameter of the set `s '' Set.Ici n`. -/\n    refine ⟨fun N => EMetric.diam (s '' Ici N), fun n m N hn hm => ?_, ?_⟩\n    -- Prove that it bounds the distances of points in the Cauchy sequence\n    · exact EMetric.edist_le_diam_of_mem (mem_image_of_mem _ hn) (mem_image_of_mem _ hm)\n    -- Prove that it tends to `0`, by using the Cauchy property of `s`\n    · refine ENNReal.tendsto_nhds_zero.2 fun ε ε0 => ?_\n      rcases hs ε ε0 with ⟨N, hN⟩\n      refine (eventually_ge_atTop N).mono fun n hn => EMetric.diam_le ?_\n      rintro _ ⟨k, hk, rfl⟩ _ ⟨l, hl, rfl⟩\n      exact (hN _ (hn.trans hk) _ (hn.trans hl)).le\n  · rintro ⟨b, ⟨b_bound, b_lim⟩⟩ ε εpos\n    have : ∀ᶠ n in atTop, b n < ε := b_lim.eventually (gt_mem_nhds εpos)\n    rcases this.exists with ⟨N, hN⟩\n    refine ⟨N, fun m hm n hn => ?_⟩\n    calc edist (s m) (s n) ≤ b N := b_bound m n N hm hn\n    _ < ε := hN\n\n"}
{"name":"continuous_of_le_add_edist","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf : α → ENNReal\nC : ENNReal\nhC : Ne C Top.top\nh : ∀ (x y : α), LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul C (EDist.edist x y)))\n⊢ Continuous f","decl":"theorem continuous_of_le_add_edist {f : α → ℝ≥0∞} (C : ℝ≥0∞) (hC : C ≠ ∞)\n    (h : ∀ x y, f x ≤ f y + C * edist x y) : Continuous f := by\n  refine continuous_iff_continuousAt.2 fun x => ENNReal.tendsto_nhds_of_Icc fun ε ε0 => ?_\n  rcases ENNReal.exists_nnreal_pos_mul_lt hC ε0.ne' with ⟨δ, δ0, hδ⟩\n  rw [mul_comm] at hδ\n  filter_upwards [EMetric.closedBall_mem_nhds x (ENNReal.coe_pos.2 δ0)] with y hy\n  refine ⟨tsub_le_iff_right.2 <| (h x y).trans ?_, (h y x).trans ?_⟩ <;>\n    refine add_le_add_left (le_trans (mul_le_mul_left' ?_ _) hδ.le) _\n  exacts [EMetric.mem_closedBall'.1 hy, EMetric.mem_closedBall.1 hy]\n\n"}
{"name":"continuous_edist","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\n⊢ Continuous fun p => EDist.edist p.1 p.2","decl":"theorem continuous_edist : Continuous fun p : α × α => edist p.1 p.2 := by\n  apply continuous_of_le_add_edist 2 (by decide)\n  rintro ⟨x, y⟩ ⟨x', y'⟩\n  calc\n    edist x y ≤ edist x x' + edist x' y' + edist y' y := edist_triangle4 _ _ _ _\n    _ = edist x' y' + (edist x x' + edist y y') := by simp only [edist_comm]; ac_rfl\n    _ ≤ edist x' y' + (edist (x, y) (x', y') + edist (x, y) (x', y')) :=\n      (add_le_add_left (add_le_add (le_max_left _ _) (le_max_right _ _)) _)\n    _ = edist x' y' + 2 * edist (x, y) (x', y') := by rw [← mul_two, mul_comm]\n\n"}
{"name":"Continuous.edist","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : TopologicalSpace β\nf g : β → α\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun b => EDist.edist (f b) (g b)","decl":"@[continuity, fun_prop]\ntheorem Continuous.edist [TopologicalSpace β] {f g : β → α} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun b => edist (f b) (g b) :=\n  continuous_edist.comp (hf.prod_mk hg :)\n\n"}
{"name":"Filter.Tendsto.edist","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : PseudoEMetricSpace α\nf g : β → α\nx : Filter β\na b : α\nhf : Filter.Tendsto f x (nhds a)\nhg : Filter.Tendsto g x (nhds b)\n⊢ Filter.Tendsto (fun x => EDist.edist (f x) (g x)) x (nhds (EDist.edist a b))","decl":"theorem Filter.Tendsto.edist {f g : β → α} {x : Filter β} {a b : α} (hf : Tendsto f x (𝓝 a))\n    (hg : Tendsto g x (𝓝 b)) : Tendsto (fun x => edist (f x) (g x)) x (𝓝 (edist a b)) :=\n  (continuous_edist.tendsto (a, b)).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"cauchySeq_of_edist_le_of_summable","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf : Nat → α\nd : Nat → NNReal\nhf : ∀ (n : Nat), LE.le (EDist.edist (f n) (f n.succ)) ↑(d n)\nhd : Summable d\n⊢ CauchySeq f","decl":"/-- If the extended distance between consecutive points of a sequence is estimated\nby a summable series of `NNReal`s, then the original sequence is a Cauchy sequence. -/\ntheorem cauchySeq_of_edist_le_of_summable {f : ℕ → α} (d : ℕ → ℝ≥0)\n    (hf : ∀ n, edist (f n) (f n.succ) ≤ d n) (hd : Summable d) : CauchySeq f := by\n  refine EMetric.cauchySeq_iff_NNReal.2 fun ε εpos ↦ ?_\n  -- Actually we need partial sums of `d` to be a Cauchy sequence.\n  replace hd : CauchySeq fun n : ℕ ↦ ∑ x ∈ Finset.range n, d x :=\n    let ⟨_, H⟩ := hd\n    H.tendsto_sum_nat.cauchySeq\n  -- Now we take the same `N` as in one of the definitions of a Cauchy sequence.\n  refine (Metric.cauchySeq_iff'.1 hd ε (NNReal.coe_pos.2 εpos)).imp fun N hN n hn ↦ ?_\n  specialize hN n hn\n  -- We simplify the known inequality.\n  rw [dist_nndist, NNReal.nndist_eq, ← Finset.sum_range_add_sum_Ico _ hn, add_tsub_cancel_left,\n    NNReal.coe_lt_coe, max_lt_iff] at hN\n  rw [edist_comm]\n  -- Then use `hf` to simplify the goal to the same form.\n  refine lt_of_le_of_lt (edist_le_Ico_sum_of_edist_le hn fun _ _ ↦ hf _) ?_\n  exact mod_cast hN.1\n\n"}
{"name":"cauchySeq_of_edist_le_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf : Nat → α\nd : Nat → ENNReal\nhf : ∀ (n : Nat), LE.le (EDist.edist (f n) (f n.succ)) (d n)\nhd : Ne (tsum d) Top.top\n⊢ CauchySeq f","decl":"theorem cauchySeq_of_edist_le_of_tsum_ne_top {f : ℕ → α} (d : ℕ → ℝ≥0∞)\n    (hf : ∀ n, edist (f n) (f n.succ) ≤ d n) (hd : tsum d ≠ ∞) : CauchySeq f := by\n  lift d to ℕ → NNReal using fun i => ENNReal.ne_top_of_tsum_ne_top hd i\n  rw [ENNReal.tsum_coe_ne_top_iff_summable] at hd\n  exact cauchySeq_of_edist_le_of_summable d hf hd\n\n"}
{"name":"EMetric.isClosed_ball","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\na : α\nr : ENNReal\n⊢ IsClosed (EMetric.closedBall a r)","decl":"theorem EMetric.isClosed_ball {a : α} {r : ℝ≥0∞} : IsClosed (closedBall a r) :=\n  isClosed_le (continuous_id.edist continuous_const) continuous_const\n\n"}
{"name":"EMetric.diam_closure","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\ns : Set α\n⊢ Eq (EMetric.diam (closure s)) (EMetric.diam s)","decl":"@[simp]\ntheorem EMetric.diam_closure (s : Set α) : diam (closure s) = diam s := by\n  refine le_antisymm (diam_le fun x hx y hy => ?_) (diam_mono subset_closure)\n  have : edist x y ∈ closure (Iic (diam s)) :=\n    map_mem_closure₂ continuous_edist hx hy fun x hx y hy => edist_le_diam_of_mem hx hy\n  rwa [closure_Iic] at this\n\n"}
{"name":"Metric.diam_closure","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Eq (Metric.diam (closure s)) (Metric.diam s)","decl":"@[simp]\ntheorem Metric.diam_closure {α : Type*} [PseudoMetricSpace α] (s : Set α) :\n    Metric.diam (closure s) = diam s := by simp only [Metric.diam, EMetric.diam_closure]\n\n"}
{"name":"isClosed_setOf_lipschitzOnWith","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nK : NNReal\ns : Set α\n⊢ IsClosed (setOf fun f => LipschitzOnWith K f s)","decl":"theorem isClosed_setOf_lipschitzOnWith {α β} [PseudoEMetricSpace α] [PseudoEMetricSpace β] (K : ℝ≥0)\n    (s : Set α) : IsClosed { f : α → β | LipschitzOnWith K f s } := by\n  simp only [LipschitzOnWith, setOf_forall]\n  refine isClosed_biInter fun x _ => isClosed_biInter fun y _ => isClosed_le ?_ ?_\n  exacts [.edist (continuous_apply x) (continuous_apply y), continuous_const]\n\n"}
{"name":"isClosed_setOf_lipschitzWith","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nK : NNReal\n⊢ IsClosed (setOf fun f => LipschitzWith K f)","decl":"theorem isClosed_setOf_lipschitzWith {α β} [PseudoEMetricSpace α] [PseudoEMetricSpace β] (K : ℝ≥0) :\n    IsClosed { f : α → β | LipschitzWith K f } := by\n  simp only [← lipschitzOnWith_univ, isClosed_setOf_lipschitzOnWith]\n\n"}
{"name":"Real.ediam_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"s : Set Real\nh : Bornology.IsBounded s\n⊢ Eq (EMetric.diam s) (ENNReal.ofReal (HSub.hSub (SupSet.sSup s) (InfSet.sInf s)))","decl":"/-- For a bounded set `s : Set ℝ`, its `EMetric.diam` is equal to `sSup s - sInf s` reinterpreted as\n`ℝ≥0∞`. -/\ntheorem ediam_eq {s : Set ℝ} (h : Bornology.IsBounded s) :\n    EMetric.diam s = ENNReal.ofReal (sSup s - sInf s) := by\n  rcases eq_empty_or_nonempty s with (rfl | hne)\n  · simp\n  refine le_antisymm (Metric.ediam_le_of_forall_dist_le fun x hx y hy => ?_) ?_\n  · exact Real.dist_le_of_mem_Icc (h.subset_Icc_sInf_sSup hx) (h.subset_Icc_sInf_sSup hy)\n  · apply ENNReal.ofReal_le_of_le_toReal\n    rw [← Metric.diam, ← Metric.diam_closure]\n    calc sSup s - sInf s ≤ dist (sSup s) (sInf s) := le_abs_self _\n    _ ≤ Metric.diam (closure s) := dist_le_diam_of_mem h.closure (csSup_mem_closure hne h.bddAbove)\n        (csInf_mem_closure hne h.bddBelow)\n\n"}
{"name":"Real.diam_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"s : Set Real\nh : Bornology.IsBounded s\n⊢ Eq (Metric.diam s) (HSub.hSub (SupSet.sSup s) (InfSet.sInf s))","decl":"/-- For a bounded set `s : Set ℝ`, its `Metric.diam` is equal to `sSup s - sInf s`. -/\ntheorem diam_eq {s : Set ℝ} (h : Bornology.IsBounded s) : Metric.diam s = sSup s - sInf s := by\n  rw [Metric.diam, Real.ediam_eq h, ENNReal.toReal_ofReal]\n  exact sub_nonneg.2 (Real.sInf_le_sSup s h.bddBelow h.bddAbove)\n\n"}
{"name":"Real.ediam_Ioo","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\n⊢ Eq (EMetric.diam (Set.Ioo a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem ediam_Ioo (a b : ℝ) : EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a) := by\n  rcases le_or_lt b a with (h | h)\n  · simp [h]\n  · rw [Real.ediam_eq (isBounded_Ioo _ _), csSup_Ioo h, csInf_Ioo h]\n\n"}
{"name":"Real.ediam_Icc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\n⊢ Eq (EMetric.diam (Set.Icc a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem ediam_Icc (a b : ℝ) : EMetric.diam (Icc a b) = ENNReal.ofReal (b - a) := by\n  rcases le_or_lt a b with (h | h)\n  · rw [Real.ediam_eq (isBounded_Icc _ _), csSup_Icc h, csInf_Icc h]\n  · simp [h, h.le]\n\n"}
{"name":"Real.ediam_Ico","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\n⊢ Eq (EMetric.diam (Set.Ico a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem ediam_Ico (a b : ℝ) : EMetric.diam (Ico a b) = ENNReal.ofReal (b - a) :=\n  le_antisymm (ediam_Icc a b ▸ diam_mono Ico_subset_Icc_self)\n    (ediam_Ioo a b ▸ diam_mono Ioo_subset_Ico_self)\n\n"}
{"name":"Real.ediam_Ioc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\n⊢ Eq (EMetric.diam (Set.Ioc a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem ediam_Ioc (a b : ℝ) : EMetric.diam (Ioc a b) = ENNReal.ofReal (b - a) :=\n  le_antisymm (ediam_Icc a b ▸ diam_mono Ioc_subset_Icc_self)\n    (ediam_Ioo a b ▸ diam_mono Ioo_subset_Ioc_self)\n\n"}
{"name":"Real.diam_Icc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nh : LE.le a b\n⊢ Eq (Metric.diam (Set.Icc a b)) (HSub.hSub b a)","decl":"theorem diam_Icc {a b : ℝ} (h : a ≤ b) : Metric.diam (Icc a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n\n"}
{"name":"Real.diam_Ico","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nh : LE.le a b\n⊢ Eq (Metric.diam (Set.Ico a b)) (HSub.hSub b a)","decl":"theorem diam_Ico {a b : ℝ} (h : a ≤ b) : Metric.diam (Ico a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n\n"}
{"name":"Real.diam_Ioc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nh : LE.le a b\n⊢ Eq (Metric.diam (Set.Ioc a b)) (HSub.hSub b a)","decl":"theorem diam_Ioc {a b : ℝ} (h : a ≤ b) : Metric.diam (Ioc a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n\n"}
{"name":"Real.diam_Ioo","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nh : LE.le a b\n⊢ Eq (Metric.diam (Set.Ioo a b)) (HSub.hSub b a)","decl":"theorem diam_Ioo {a b : ℝ} (h : a ≤ b) : Metric.diam (Ioo a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n\n"}
{"name":"edist_le_tsum_of_edist_le_of_tendsto","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf : Nat → α\nd : Nat → ENNReal\nhf : ∀ (n : Nat), LE.le (EDist.edist (f n) (f n.succ)) (d n)\na : α\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\n⊢ LE.le (EDist.edist (f n) a) (tsum fun m => d (HAdd.hAdd n m))","decl":"/-- If `edist (f n) (f (n+1))` is bounded above by a function `d : ℕ → ℝ≥0∞`,\nthen the distance from `f n` to the limit is bounded by `∑'_{k=n}^∞ d k`. -/\ntheorem edist_le_tsum_of_edist_le_of_tendsto {f : ℕ → α} (d : ℕ → ℝ≥0∞)\n    (hf : ∀ n, edist (f n) (f n.succ) ≤ d n) {a : α} (ha : Tendsto f atTop (𝓝 a)) (n : ℕ) :\n    edist (f n) a ≤ ∑' m, d (n + m) := by\n  refine le_of_tendsto (tendsto_const_nhds.edist ha) (mem_atTop_sets.2 ⟨n, fun m hnm => ?_⟩)\n  change edist _ _ ≤ _\n  refine le_trans (edist_le_Ico_sum_of_edist_le hnm fun _ _ => hf _) ?_\n  rw [Finset.sum_Ico_eq_sum_range]\n  exact sum_le_tsum _ (fun _ _ => zero_le _) ENNReal.summable\n\n"}
{"name":"edist_le_tsum_of_edist_le_of_tendsto₀","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : PseudoEMetricSpace α\nf : Nat → α\nd : Nat → ENNReal\nhf : ∀ (n : Nat), LE.le (EDist.edist (f n) (f n.succ)) (d n)\na : α\nha : Filter.Tendsto f Filter.atTop (nhds a)\n⊢ LE.le (EDist.edist (f 0) a) (tsum fun m => d m)","decl":"/-- If `edist (f n) (f (n+1))` is bounded above by a function `d : ℕ → ℝ≥0∞`,\nthen the distance from `f 0` to the limit is bounded by `∑'_{k=0}^∞ d k`. -/\ntheorem edist_le_tsum_of_edist_le_of_tendsto₀ {f : ℕ → α} (d : ℕ → ℝ≥0∞)\n    (hf : ∀ n, edist (f n) (f n.succ) ≤ d n) {a : α} (ha : Tendsto f atTop (𝓝 a)) :\n    edist (f 0) a ≤ ∑' m, d m := by simpa using edist_le_tsum_of_edist_le_of_tendsto d hf ha 0\n\n"}
{"name":"ENNReal.truncateToReal_eq_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t x : ENNReal\nt_ne_top : Ne t Top.top\nx_le : LE.le x t\n⊢ Eq (t.truncateToReal x) x.toReal","decl":"lemma truncateToReal_eq_toReal {t x : ℝ≥0∞} (t_ne_top : t ≠ ∞) (x_le : x ≤ t) :\n    truncateToReal t x = x.toReal := by\n  have x_lt_top : x < ∞ := lt_of_le_of_lt x_le t_ne_top.lt_top\n  have obs : min t x ≠ ∞ := by\n    simp_all only [ne_eq, min_eq_top, false_and, not_false_eq_true]\n  exact (ENNReal.toReal_eq_toReal obs x_lt_top.ne).mpr (min_eq_right x_le)\n\n"}
{"name":"ENNReal.truncateToReal_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t : ENNReal\nt_ne_top : Ne t Top.top\nx : ENNReal\n⊢ LE.le (t.truncateToReal x) t.toReal","decl":"lemma truncateToReal_le {t : ℝ≥0∞} (t_ne_top : t ≠ ∞) {x : ℝ≥0∞} :\n    truncateToReal t x ≤ t.toReal := by\n  rw [truncateToReal]\n  gcongr\n  exacts [t_ne_top, min_le_left t x]\n\n"}
{"name":"ENNReal.truncateToReal_nonneg","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t x : ENNReal\n⊢ LE.le 0 (t.truncateToReal x)","decl":"lemma truncateToReal_nonneg {t x : ℝ≥0∞} : 0 ≤ truncateToReal t x := toReal_nonneg\n\n"}
{"name":"ENNReal.monotone_truncateToReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t : ENNReal\nt_ne_top : Ne t Top.top\n⊢ Monotone t.truncateToReal","decl":"/-- The truncated cast `ENNReal.truncateToReal t : ℝ≥0∞ → ℝ` is monotone when `t ≠ ∞`. -/\nlemma monotone_truncateToReal {t : ℝ≥0∞} (t_ne_top : t ≠ ∞) : Monotone (truncateToReal t) := by\n  intro x y x_le_y\n  simp only [truncateToReal]\n  gcongr\n  exact ne_top_of_le_ne_top t_ne_top (min_le_left _ _)\n\n"}
{"name":"ENNReal.continuous_truncateToReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t : ENNReal\nt_ne_top : Ne t Top.top\n⊢ Continuous t.truncateToReal","decl":"/-- The truncated cast `ENNReal.truncateToReal t : ℝ≥0∞ → ℝ` is continuous when `t ≠ ∞`. -/\nlemma continuous_truncateToReal {t : ℝ≥0∞} (t_ne_top : t ≠ ∞) : Continuous (truncateToReal t) := by\n  apply continuousOn_toReal.comp_continuous (continuous_min.comp (Continuous.Prod.mk t))\n  simp [t_ne_top]\n\n"}
{"name":"ENNReal.limsup_sub_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nF : Filter ι\nf : ι → ENNReal\nc : ENNReal\n⊢ Eq (Filter.limsup (fun i => HSub.hSub (f i) c) F) (HSub.hSub (Filter.limsup f F) c)","decl":"lemma limsup_sub_const (F : Filter ι) (f : ι → ℝ≥0∞) (c : ℝ≥0∞) :\n    Filter.limsup (fun i ↦ f i - c) F = Filter.limsup f F - c := by\n  rcases F.eq_or_neBot with rfl | _\n  · simp only [limsup_bot, bot_eq_zero', zero_le, tsub_eq_zero_of_le]\n  · exact (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : ℝ≥0∞) ↦ x - c)\n    (fun _ _ h ↦ tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt).symm\n\n"}
{"name":"ENNReal.liminf_sub_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nF : Filter ι\ninst✝ : F.NeBot\nf : ι → ENNReal\nc : ENNReal\n⊢ Eq (Filter.liminf (fun i => HSub.hSub (f i) c) F) (HSub.hSub (Filter.liminf f F) c)","decl":"lemma liminf_sub_const (F : Filter ι) [NeBot F] (f : ι → ℝ≥0∞) (c : ℝ≥0∞) :\n    Filter.liminf (fun i ↦ f i - c) F = Filter.liminf f F - c :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : ℝ≥0∞) ↦ x - c)\n    (fun _ _ h ↦ tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt).symm\n\n"}
{"name":"ENNReal.limsup_const_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nF : Filter ι\nf : ι → ENNReal\nc : ENNReal\nc_ne_top : Ne c Top.top\n⊢ Eq (Filter.limsup (fun i => HSub.hSub c (f i)) F) (HSub.hSub c (Filter.liminf f F))","decl":"lemma limsup_const_sub (F : Filter ι) (f : ι → ℝ≥0∞) {c : ℝ≥0∞} (c_ne_top : c ≠ ∞) :\n    Filter.limsup (fun i ↦ c - f i) F = c - Filter.liminf f F := by\n  rcases F.eq_or_neBot with rfl | _\n  · simp only [limsup_bot, bot_eq_zero', liminf_bot, le_top, tsub_eq_zero_of_le]\n  · exact (Antitone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : ℝ≥0∞) ↦ c - x)\n    (fun _ _ h ↦ tsub_le_tsub_left h c) (continuous_sub_left c_ne_top).continuousAt).symm\n\n"}
{"name":"ENNReal.liminf_const_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_4\nF : Filter ι\ninst✝ : F.NeBot\nf : ι → ENNReal\nc : ENNReal\nc_ne_top : Ne c Top.top\n⊢ Eq (Filter.liminf (fun i => HSub.hSub c (f i)) F) (HSub.hSub c (Filter.limsup f F))","decl":"lemma liminf_const_sub (F : Filter ι) [NeBot F] (f : ι → ℝ≥0∞) {c : ℝ≥0∞} (c_ne_top : c ≠ ∞) :\n    Filter.liminf (fun i ↦ c - f i) F = c - Filter.limsup f F :=\n  (Antitone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : ℝ≥0∞) ↦ c - x)\n    (fun _ _ h ↦ tsub_le_tsub_left h c) (continuous_sub_left c_ne_top).continuousAt).symm\n\n"}
{"name":"ENNReal.le_limsup_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_5\nf : Filter α\nu v : α → ENNReal\n⊢ LE.le (HMul.hMul (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HMul.hMul u v) f)","decl":"lemma le_limsup_mul {α : Type*} {f : Filter α} {u v : α → ℝ≥0∞} :\n    limsup u f * liminf v f ≤ limsup (u * v) f :=\n  mul_le_of_forall_lt fun a a_u b b_v ↦ (le_limsup_iff).2 fun c c_ab ↦\n    Frequently.mono (Frequently.and_eventually ((frequently_lt_of_lt_limsup) a_u)\n    ((eventually_lt_of_lt_liminf) b_v)) fun _ ab_x ↦ c_ab.trans (mul_lt_mul ab_x.1 ab_x.2)\n\n"}
{"name":"ENNReal.limsup_mul_le'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_5\nf : Filter α\nu v : α → ENNReal\nh : Or (Ne (Filter.limsup u f) 0) (Ne (Filter.limsup v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.limsup v f) 0)\n⊢ LE.le (Filter.limsup (HMul.hMul u v) f) (HMul.hMul (Filter.limsup u f) (Filter.limsup v f))","decl":"/-- See also `ENNReal.limsup_mul_le`.-/\nlemma limsup_mul_le' {α : Type*} {f : Filter α} {u v : α → ℝ≥0∞}\n    (h : limsup u f ≠ 0 ∨ limsup v f ≠ ∞) (h' : limsup u f ≠ ∞ ∨ limsup v f ≠ 0) :\n    limsup (u * v) f ≤ limsup u f * limsup v f := by\n  refine le_mul_of_forall_lt h h' fun a a_u b b_v ↦ (limsup_le_iff).2 fun c c_ab ↦ ?_\n  filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v] with x a_x b_x\n  exact (mul_lt_mul a_x b_x).trans c_ab\n\n"}
{"name":"ENNReal.le_liminf_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_5\nf : Filter α\nu v : α → ENNReal\n⊢ LE.le (HMul.hMul (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HMul.hMul u v) f)","decl":"lemma le_liminf_mul {α : Type*} {f : Filter α} {u v : α → ℝ≥0∞} :\n    liminf u f * liminf v f ≤ liminf (u * v) f := by\n  refine mul_le_of_forall_lt fun a a_u b b_v ↦ (le_liminf_iff).2 fun c c_ab ↦ ?_\n  filter_upwards [eventually_lt_of_lt_liminf a_u, eventually_lt_of_lt_liminf b_v] with x a_x b_x\n  exact c_ab.trans (mul_lt_mul a_x b_x)\n\n"}
{"name":"ENNReal.liminf_mul_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"α : Type u_5\nf : Filter α\nu v : α → ENNReal\nh : Or (Ne (Filter.limsup u f) 0) (Ne (Filter.liminf v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.liminf v f) 0)\n⊢ LE.le (Filter.liminf (HMul.hMul u v) f) (HMul.hMul (Filter.limsup u f) (Filter.liminf v f))","decl":"lemma liminf_mul_le {α : Type*} {f : Filter α} {u v : α → ℝ≥0∞}\n    (h : limsup u f ≠ 0 ∨ liminf v f ≠ ∞) (h' : limsup u f ≠ ∞ ∨ liminf v f ≠ 0) :\n    liminf (u * v) f ≤ limsup u f * liminf v f :=\n  le_mul_of_forall_lt h h' fun a a_u b b_v ↦ (liminf_le_iff).2 fun c c_ab ↦\n    Frequently.mono (((frequently_lt_of_liminf_lt) b_v).and_eventually\n    ((eventually_lt_of_limsup_lt) a_u)) fun _ ab_x ↦ (mul_lt_mul ab_x.2 ab_x.1).trans c_ab\n\n"}
{"name":"ENNReal.liminf_toReal_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_5\nF : Filter ι\ninst✝ : F.NeBot\nb : ENNReal\nb_ne_top : Ne b Top.top\nxs : ι → ENNReal\nle_b : Filter.Eventually (fun i => LE.le (xs i) b) F\n⊢ Eq (Filter.liminf (fun i => (xs i).toReal) F) (Filter.liminf xs F).toReal","decl":"/-- If `xs : ι → ℝ≥0∞` is bounded, then we have `liminf (toReal ∘ xs) = toReal (liminf xs)`. -/\nlemma liminf_toReal_eq {ι : Type*} {F : Filter ι} [NeBot F] {b : ℝ≥0∞} (b_ne_top : b ≠ ∞)\n    {xs : ι → ℝ≥0∞} (le_b : ∀ᶠ i in F, xs i ≤ b) :\n    F.liminf (fun i ↦ (xs i).toReal) = (F.liminf xs).toReal := by\n  have liminf_le : F.liminf xs ≤ b := by\n    apply liminf_le_of_le ⟨0, by simp⟩\n    intro y h\n    obtain ⟨i, hi⟩ := (Eventually.and h le_b).exists\n    exact hi.1.trans hi.2\n  have aux : ∀ᶠ i in F, (xs i).toReal = ENNReal.truncateToReal b (xs i) := by\n    filter_upwards [le_b] with i i_le_b\n    simp only [truncateToReal_eq_toReal b_ne_top i_le_b, implies_true]\n  have aux' : (F.liminf xs).toReal = ENNReal.truncateToReal b (F.liminf xs) := by\n    rw [truncateToReal_eq_toReal b_ne_top liminf_le]\n  simp_rw [liminf_congr aux, aux']\n  have key := Monotone.map_liminf_of_continuousAt (F := F) (monotone_truncateToReal b_ne_top) xs\n          (continuous_truncateToReal b_ne_top).continuousAt\n          (IsBoundedUnder.isCoboundedUnder_ge ⟨b, by simpa only [eventually_map] using le_b⟩)\n          ⟨0, Eventually.of_forall (by simp)⟩\n  rw [key]\n  rfl\n\n"}
{"name":"ENNReal.limsup_toReal_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"ι : Type u_5\nF : Filter ι\ninst✝ : F.NeBot\nb : ENNReal\nb_ne_top : Ne b Top.top\nxs : ι → ENNReal\nle_b : Filter.Eventually (fun i => LE.le (xs i) b) F\n⊢ Eq (Filter.limsup (fun i => (xs i).toReal) F) (Filter.limsup xs F).toReal","decl":"/-- If `xs : ι → ℝ≥0∞` is bounded, then we have `liminf (toReal ∘ xs) = toReal (liminf xs)`. -/\nlemma limsup_toReal_eq {ι : Type*} {F : Filter ι} [NeBot F] {b : ℝ≥0∞} (b_ne_top : b ≠ ∞)\n    {xs : ι → ℝ≥0∞} (le_b : ∀ᶠ i in F, xs i ≤ b) :\n    F.limsup (fun i ↦ (xs i).toReal) = (F.limsup xs).toReal := by\n  have aux : ∀ᶠ i in F, (xs i).toReal = ENNReal.truncateToReal b (xs i) := by\n    filter_upwards [le_b] with i i_le_b\n    simp only [truncateToReal_eq_toReal b_ne_top i_le_b, implies_true]\n  have aux' : (F.limsup xs).toReal = ENNReal.truncateToReal b (F.limsup xs) := by\n    rw [truncateToReal_eq_toReal b_ne_top (limsup_le_of_le ⟨0, by simp⟩ le_b)]\n  simp_rw [limsup_congr aux, aux']\n  have key := Monotone.map_limsup_of_continuousAt (F := F) (monotone_truncateToReal b_ne_top) xs\n          (continuous_truncateToReal b_ne_top).continuousAt\n          ⟨b, by simpa only [eventually_map] using le_b⟩\n          (IsBoundedUnder.isCoboundedUnder_le ⟨0, Eventually.of_forall (by simp)⟩)\n  rw [key]\n  rfl\n\n"}
