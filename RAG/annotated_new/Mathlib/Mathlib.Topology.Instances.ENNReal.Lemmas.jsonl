{"name":"ENNReal.embedding_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Topology.IsEmbedding ENNReal.ofNNReal","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coe := isEmbedding_coe\n\n"}
{"name":"ENNReal.isOpen_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ IsOpen (setOf fun a => Ne a Top.top)","decl":"theorem isOpen_ne_top : IsOpen { a : â„â‰¥0âˆ | a â‰  âˆ } := isOpen_ne\n\n"}
{"name":"ENNReal.isOpen_Ico_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"b : ENNReal\nâŠ¢ IsOpen (Set.Ico 0 b)","decl":"theorem isOpen_Ico_zero : IsOpen (Ico 0 b) := by\n  rw [ENNReal.Ico_eq_Iio]\n  exact isOpen_Iio\n\n"}
{"name":"ENNReal.openEmbedding_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Topology.IsOpenEmbedding ENNReal.ofNNReal","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_coe := isOpenEmbedding_coe\n\n"}
{"name":"ENNReal.coe_range_mem_nhds","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\nâŠ¢ Membership.mem (nhds â†‘r) (Set.range ENNReal.ofNNReal)","decl":"theorem coe_range_mem_nhds : range ((â†‘) : â„â‰¥0 â†’ â„â‰¥0âˆ) âˆˆ ğ“ (r : â„â‰¥0âˆ) :=\n  IsOpen.mem_nhds isOpenEmbedding_coe.isOpen_range <| mem_range_self _\n\n"}
{"name":"ENNReal.continuous_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Continuous ENNReal.ofNNReal","decl":"@[fun_prop]\ntheorem continuous_coe : Continuous ((â†‘) : â„â‰¥0 â†’ â„â‰¥0âˆ) :=\n  isEmbedding_coe.continuous\n\n"}
{"name":"ENNReal.continuous_coe_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\ninstâœ : TopologicalSpace Î±\nf : Î± â†’ NNReal\nâŠ¢ Iff (Continuous fun a => â†‘(f a)) (Continuous f)","decl":"theorem continuous_coe_iff {Î±} [TopologicalSpace Î±] {f : Î± â†’ â„â‰¥0} :\n    (Continuous fun a => (f a : â„â‰¥0âˆ)) â†” Continuous f :=\n  isEmbedding_coe.continuous_iff.symm\n\n"}
{"name":"ENNReal.nhds_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\nâŠ¢ Eq (nhds â†‘r) (Filter.map ENNReal.ofNNReal (nhds r))","decl":"theorem nhds_coe {r : â„â‰¥0} : ğ“ (r : â„â‰¥0âˆ) = (ğ“ r).map (â†‘) :=\n  (isOpenEmbedding_coe.map_nhds_eq r).symm\n\n"}
{"name":"ENNReal.tendsto_nhds_coe_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\nl : Filter Î±\nx : NNReal\nf : ENNReal â†’ Î±\nâŠ¢ Iff (Filter.Tendsto f (nhds â†‘x) l) (Filter.Tendsto (Function.comp f ENNReal.ofNNReal) (nhds x) l)","decl":"theorem tendsto_nhds_coe_iff {Î± : Type*} {l : Filter Î±} {x : â„â‰¥0} {f : â„â‰¥0âˆ â†’ Î±} :\n    Tendsto f (ğ“ â†‘x) l â†” Tendsto (f âˆ˜ (â†‘) : â„â‰¥0 â†’ Î±) (ğ“ x) l := by\n  rw [nhds_coe, tendsto_map'_iff]\n\n"}
{"name":"ENNReal.continuousAt_coe_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\ninstâœ : TopologicalSpace Î±\nx : NNReal\nf : ENNReal â†’ Î±\nâŠ¢ Iff (ContinuousAt f â†‘x) (ContinuousAt (Function.comp f ENNReal.ofNNReal) x)","decl":"theorem continuousAt_coe_iff {Î± : Type*} [TopologicalSpace Î±] {x : â„â‰¥0} {f : â„â‰¥0âˆ â†’ Î±} :\n    ContinuousAt f â†‘x â†” ContinuousAt (f âˆ˜ (â†‘) : â„â‰¥0 â†’ Î±) x :=\n  tendsto_nhds_coe_iff\n\n"}
{"name":"ENNReal.continuous_ofReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Continuous ENNReal.ofReal","decl":"theorem continuous_ofReal : Continuous ENNReal.ofReal :=\n  (continuous_coe_iff.2 continuous_id).comp continuous_real_toNNReal\n\n"}
{"name":"ENNReal.tendsto_ofReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nm : Î± â†’ Real\na : Real\nh : Filter.Tendsto m f (nhds a)\nâŠ¢ Filter.Tendsto (fun a => ENNReal.ofReal (m a)) f (nhds (ENNReal.ofReal a))","decl":"theorem tendsto_ofReal {f : Filter Î±} {m : Î± â†’ â„} {a : â„} (h : Tendsto m f (ğ“ a)) :\n    Tendsto (fun a => ENNReal.ofReal (m a)) f (ğ“ (ENNReal.ofReal a)) :=\n  (continuous_ofReal.tendsto a).comp h\n\n"}
{"name":"ENNReal.tendsto_toNNReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nha : Ne a Top.top\nâŠ¢ Filter.Tendsto ENNReal.toNNReal (nhds a) (nhds a.toNNReal)","decl":"theorem tendsto_toNNReal {a : â„â‰¥0âˆ} (ha : a â‰  âˆ) :\n    Tendsto ENNReal.toNNReal (ğ“ a) (ğ“ a.toNNReal) := by\n  lift a to â„â‰¥0 using ha\n  rw [nhds_coe, tendsto_map'_iff]\n  exact tendsto_id\n\n"}
{"name":"ENNReal.eventuallyEq_of_toReal_eventuallyEq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nl : Filter Î±\nf g : Î± â†’ ENNReal\nhfi : Filter.Eventually (fun x => Ne (f x) Top.top) l\nhgi : Filter.Eventually (fun x => Ne (g x) Top.top) l\nhfg : l.EventuallyEq (fun x => (f x).toReal) fun x => (g x).toReal\nâŠ¢ l.EventuallyEq f g","decl":"theorem eventuallyEq_of_toReal_eventuallyEq {l : Filter Î±} {f g : Î± â†’ â„â‰¥0âˆ}\n    (hfi : âˆ€á¶  x in l, f x â‰  âˆ) (hgi : âˆ€á¶  x in l, g x â‰  âˆ)\n    (hfg : (fun x => (f x).toReal) =á¶ [l] fun x => (g x).toReal) : f =á¶ [l] g := by\n  filter_upwards [hfi, hgi, hfg] with _ hfx hgx _\n  rwa [â† ENNReal.toReal_eq_toReal hfx hgx]\n\n"}
{"name":"ENNReal.continuousOn_toNNReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ ContinuousOn ENNReal.toNNReal (setOf fun a => Ne a Top.top)","decl":"theorem continuousOn_toNNReal : ContinuousOn ENNReal.toNNReal { a | a â‰  âˆ } := fun _a ha =>\n  ContinuousAt.continuousWithinAt (tendsto_toNNReal ha)\n\n"}
{"name":"ENNReal.tendsto_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nha : Ne a Top.top\nâŠ¢ Filter.Tendsto ENNReal.toReal (nhds a) (nhds a.toReal)","decl":"theorem tendsto_toReal {a : â„â‰¥0âˆ} (ha : a â‰  âˆ) : Tendsto ENNReal.toReal (ğ“ a) (ğ“ a.toReal) :=\n  NNReal.tendsto_coe.2 <| tendsto_toNNReal ha\n\n"}
{"name":"ENNReal.continuousOn_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ ContinuousOn ENNReal.toReal (setOf fun a => Ne a Top.top)","decl":"lemma continuousOn_toReal : ContinuousOn ENNReal.toReal { a | a â‰  âˆ } :=\n  NNReal.continuous_coe.comp_continuousOn continuousOn_toNNReal\n\n"}
{"name":"ENNReal.continuousAt_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\nhx : Ne x Top.top\nâŠ¢ ContinuousAt ENNReal.toReal x","decl":"lemma continuousAt_toReal (hx : x â‰  âˆ) : ContinuousAt ENNReal.toReal x :=\n  continuousOn_toReal.continuousAt (isOpen_ne_top.mem_nhds_iff.mpr hx)\n\n"}
{"name":"ENNReal.nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Eq (nhds Top.top) (iInf fun a => iInf fun x => Filter.principal (Set.Ioi a))","decl":"theorem nhds_top : ğ“ âˆ = â¨… (a) (_ : a â‰  âˆ), ğ“Ÿ (Ioi a) :=\n  nhds_top_order.trans <| by simp [lt_top_iff_ne_top, Ioi]\n\n"}
{"name":"ENNReal.nhds_top'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Eq (nhds Top.top) (iInf fun r => Filter.principal (Set.Ioi â†‘r))","decl":"theorem nhds_top' : ğ“ âˆ = â¨… r : â„â‰¥0, ğ“Ÿ (Ioi â†‘r) :=\n  nhds_top.trans <| iInf_ne_top _\n\n"}
{"name":"ENNReal.nhds_top_basis","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ (nhds Top.top).HasBasis (fun a => LT.lt a Top.top) fun a => Set.Ioi a","decl":"theorem nhds_top_basis : (ğ“ âˆ).HasBasis (fun a => a < âˆ) fun a => Ioi a :=\n  _root_.nhds_top_basis\n\n"}
{"name":"ENNReal.tendsto_nhds_top_iff_nnreal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nm : Î± â†’ ENNReal\nf : Filter Î±\nâŠ¢ Iff (Filter.Tendsto m f (nhds Top.top)) (âˆ€ (x : NNReal), Filter.Eventually (fun a => LT.lt (â†‘x) (m a)) f)","decl":"theorem tendsto_nhds_top_iff_nnreal {m : Î± â†’ â„â‰¥0âˆ} {f : Filter Î±} :\n    Tendsto m f (ğ“ âˆ) â†” âˆ€ x : â„â‰¥0, âˆ€á¶  a in f, â†‘x < m a := by\n  simp only [nhds_top', tendsto_iInf, tendsto_principal, mem_Ioi]\n\n"}
{"name":"ENNReal.tendsto_nhds_top_iff_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nm : Î± â†’ ENNReal\nf : Filter Î±\nâŠ¢ Iff (Filter.Tendsto m f (nhds Top.top)) (âˆ€ (n : Nat), Filter.Eventually (fun a => LT.lt (â†‘n) (m a)) f)","decl":"theorem tendsto_nhds_top_iff_nat {m : Î± â†’ â„â‰¥0âˆ} {f : Filter Î±} :\n    Tendsto m f (ğ“ âˆ) â†” âˆ€ n : â„•, âˆ€á¶  a in f, â†‘n < m a :=\n  tendsto_nhds_top_iff_nnreal.trans\n    âŸ¨fun h n => by simpa only [ENNReal.coe_natCast] using h n, fun h x =>\n      let âŸ¨n, hnâŸ© := exists_nat_gt x\n      (h n).mono fun _ => lt_trans <| by rwa [â† ENNReal.coe_natCast, coe_lt_coe]âŸ©\n\n"}
{"name":"ENNReal.tendsto_nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nm : Î± â†’ ENNReal\nf : Filter Î±\nh : âˆ€ (n : Nat), Filter.Eventually (fun a => LT.lt (â†‘n) (m a)) f\nâŠ¢ Filter.Tendsto m f (nhds Top.top)","decl":"theorem tendsto_nhds_top {m : Î± â†’ â„â‰¥0âˆ} {f : Filter Î±} (h : âˆ€ n : â„•, âˆ€á¶  a in f, â†‘n < m a) :\n    Tendsto m f (ğ“ âˆ) :=\n  tendsto_nhds_top_iff_nat.2 h\n\n"}
{"name":"ENNReal.tendsto_nat_nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Filter.Tendsto (fun n => â†‘n) Filter.atTop (nhds Top.top)","decl":"theorem tendsto_nat_nhds_top : Tendsto (fun n : â„• => â†‘n) atTop (ğ“ âˆ) :=\n  tendsto_nhds_top fun n =>\n    mem_atTop_sets.2 âŸ¨n + 1, fun _m hm => mem_setOf.2 <| Nat.cast_lt.2 <| Nat.lt_of_succ_le hmâŸ©\n\n"}
{"name":"ENNReal.tendsto_coe_nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ NNReal\nl : Filter Î±\nâŠ¢ Iff (Filter.Tendsto (fun x => â†‘(f x)) l (nhds Top.top)) (Filter.Tendsto f l Filter.atTop)","decl":"@[simp, norm_cast]\ntheorem tendsto_coe_nhds_top {f : Î± â†’ â„â‰¥0} {l : Filter Î±} :\n    Tendsto (fun x => (f x : â„â‰¥0âˆ)) l (ğ“ âˆ) â†” Tendsto f l atTop := by\n  rw [tendsto_nhds_top_iff_nnreal, atTop_basis_Ioi.tendsto_right_iff]; simp\n\n"}
{"name":"ENNReal.tendsto_ofReal_nhds_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\nl : Filter Î±\nâŠ¢ Iff (Filter.Tendsto (fun x => ENNReal.ofReal (f x)) l (nhds Top.top)) (Filter.Tendsto f l Filter.atTop)","decl":"@[simp]\ntheorem tendsto_ofReal_nhds_top {f : Î± â†’ â„} {l : Filter Î±} :\n    Tendsto (fun x â†¦ ENNReal.ofReal (f x)) l (ğ“ âˆ) â†” Tendsto f l atTop :=\n  tendsto_coe_nhds_top.trans Real.tendsto_toNNReal_atTop_iff\n\n"}
{"name":"ENNReal.tendsto_ofReal_atTop","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Filter.Tendsto ENNReal.ofReal Filter.atTop (nhds Top.top)","decl":"theorem tendsto_ofReal_atTop : Tendsto ENNReal.ofReal atTop (ğ“ âˆ) :=\n  tendsto_ofReal_nhds_top.2 tendsto_id\n\n"}
{"name":"ENNReal.nhds_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Eq (nhds 0) (iInf fun a => iInf fun x => Filter.principal (Set.Iio a))","decl":"theorem nhds_zero : ğ“ (0 : â„â‰¥0âˆ) = â¨… (a) (_ : a â‰  0), ğ“Ÿ (Iio a) :=\n  nhds_bot_order.trans <| by simp [pos_iff_ne_zero, Iio]\n\n"}
{"name":"ENNReal.nhds_zero_basis","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ (nhds 0).HasBasis (fun a => LT.lt 0 a) fun a => Set.Iio a","decl":"theorem nhds_zero_basis : (ğ“ (0 : â„â‰¥0âˆ)).HasBasis (fun a : â„â‰¥0âˆ => 0 < a) fun a => Iio a :=\n  nhds_bot_basis\n\n"}
{"name":"ENNReal.nhds_zero_basis_Iic","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ (nhds 0).HasBasis (fun a => LT.lt 0 a) Set.Iic","decl":"theorem nhds_zero_basis_Iic : (ğ“ (0 : â„â‰¥0âˆ)).HasBasis (fun a : â„â‰¥0âˆ => 0 < a) Iic :=\n  nhds_bot_basis_Iic\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: add a TC for `â‰  âˆ`?\n"}
{"name":"ENNReal.nhdsGT_coe_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\nâŠ¢ (nhdsWithin (â†‘r) (Set.Ioi â†‘r)).NeBot","decl":"@[instance]\ntheorem nhdsGT_coe_neBot {r : â„â‰¥0} : (ğ“[>] (r : â„â‰¥0âˆ)).NeBot :=\n  nhdsGT_neBot_of_exists_gt âŸ¨âˆ, ENNReal.coe_lt_topâŸ©\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_coe_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\nâŠ¢ (nhdsWithin (â†‘r) (Set.Ioi â†‘r)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_coe_neBot := nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsGT_zero_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ (nhdsWithin 0 (Set.Ioi 0)).NeBot","decl":"@[instance] theorem nhdsGT_zero_neBot : (ğ“[>] (0 : â„â‰¥0âˆ)).NeBot := nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_zero_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ (nhdsWithin 0 (Set.Ioi 0)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_zero_neBot := nhdsGT_zero_neBot\n\n"}
{"name":"ENNReal.nhdsGT_one_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ (nhdsWithin 1 (Set.Ioi 1)).NeBot","decl":"@[instance] theorem nhdsGT_one_neBot : (ğ“[>] (1 : â„â‰¥0âˆ)).NeBot := nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_one_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ (nhdsWithin 1 (Set.Ioi 1)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_one_neBot := nhdsGT_one_neBot\n\n"}
{"name":"ENNReal.nhdsGT_nat_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\nâŠ¢ (nhdsWithin (â†‘n) (Set.Ioi â†‘n)).NeBot","decl":"@[instance] theorem nhdsGT_nat_neBot (n : â„•) : (ğ“[>] (n : â„â‰¥0âˆ)).NeBot := nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_nat_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\nâŠ¢ (nhdsWithin (â†‘n) (Set.Ioi â†‘n)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_nat_neBot := nhdsGT_nat_neBot\n\n"}
{"name":"ENNReal.nhdsGT_ofNat_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\ninstâœ : n.AtLeastTwo\nâŠ¢ (nhdsWithin (OfNat.ofNat n) (Set.Ioi (OfNat.ofNat n))).NeBot","decl":"@[instance]\ntheorem nhdsGT_ofNat_neBot (n : â„•) [n.AtLeastTwo] : (ğ“[>] (OfNat.ofNat n : â„â‰¥0âˆ)).NeBot :=\n  nhdsGT_coe_neBot\n\n"}
{"name":"ENNReal.nhdsWithin_Ioi_ofNat_nebot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\ninstâœ : n.AtLeastTwo\nâŠ¢ (nhdsWithin (OfNat.ofNat n) (Set.Ioi (OfNat.ofNat n))).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ioi_ofNat_nebot := nhdsGT_ofNat_neBot\n\n"}
{"name":"ENNReal.nhdsLT_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\ninstâœ : NeZero x\nâŠ¢ (nhdsWithin x (Set.Iio x)).NeBot","decl":"@[instance]\ntheorem nhdsLT_neBot [NeZero x] : (ğ“[<] x).NeBot :=\n  nhdsWithin_Iio_self_neBot' âŸ¨0, NeZero.pos xâŸ©\n\n"}
{"name":"ENNReal.nhdsWithin_Iio_neBot","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\ninstâœ : NeZero x\nâŠ¢ (nhdsWithin x (Set.Iio x)).NeBot","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Iio_neBot := nhdsLT_neBot\n\n"}
{"name":"ENNReal.hasBasis_nhds_of_ne_top'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\nxt : Ne x Top.top\nâŠ¢ (nhds x).HasBasis (fun x => Ne x 0) fun Îµ => Set.Icc (HSub.hSub x Îµ) (HAdd.hAdd x Îµ)","decl":"/-- Closed intervals `Set.Icc (x - Îµ) (x + Îµ)`, `Îµ â‰  0`, form a basis of neighborhoods of an\nextended nonnegative real number `x â‰  âˆ`. We use `Set.Icc` instead of `Set.Ioo` because this way the\nstatement works for `x = 0`.\n-/\ntheorem hasBasis_nhds_of_ne_top' (xt : x â‰  âˆ) :\n    (ğ“ x).HasBasis (Â· â‰  0) (fun Îµ => Icc (x - Îµ) (x + Îµ)) := by\n  rcases (zero_le x).eq_or_gt with rfl | x0\n  Â· simp_rw [zero_tsub, zero_add, â† bot_eq_zero, Icc_bot, â† bot_lt_iff_ne_bot]\n    exact nhds_bot_basis_Iic\n  Â· refine (nhds_basis_Ioo' âŸ¨_, x0âŸ© âŸ¨_, xt.lt_topâŸ©).to_hasBasis ?_ fun Îµ Îµ0 => ?_\n    Â· rintro âŸ¨a, bâŸ© âŸ¨ha, hbâŸ©\n      rcases exists_between (tsub_pos_of_lt ha) with âŸ¨Îµ, Îµ0, hÎµâŸ©\n      rcases lt_iff_exists_add_pos_lt.1 hb with âŸ¨Î´, Î´0, hÎ´âŸ©\n      refine âŸ¨min Îµ Î´, (lt_min Îµ0 (coe_pos.2 Î´0)).ne', Icc_subset_Ioo ?_ ?_âŸ©\n      Â· exact lt_tsub_comm.2 ((min_le_left _ _).trans_lt hÎµ)\n      Â· exact (add_le_add_left (min_le_right _ _) _).trans_lt hÎ´\n    Â· exact âŸ¨(x - Îµ, x + Îµ), âŸ¨ENNReal.sub_lt_self xt x0.ne' Îµ0,\n        lt_add_right xt Îµ0âŸ©, Ioo_subset_Icc_selfâŸ©\n\n"}
{"name":"ENNReal.hasBasis_nhds_of_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\nxt : Ne x Top.top\nâŠ¢ (nhds x).HasBasis (fun x => LT.lt 0 x) fun Îµ => Set.Icc (HSub.hSub x Îµ) (HAdd.hAdd x Îµ)","decl":"theorem hasBasis_nhds_of_ne_top (xt : x â‰  âˆ) :\n    (ğ“ x).HasBasis (0 < Â·) (fun Îµ => Icc (x - Îµ) (x + Îµ)) := by\n  simpa only [pos_iff_ne_zero] using hasBasis_nhds_of_ne_top' xt\n\n"}
{"name":"ENNReal.Icc_mem_nhds","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x Îµ : ENNReal\nxt : Ne x Top.top\nÎµ0 : Ne Îµ 0\nâŠ¢ Membership.mem (nhds x) (Set.Icc (HSub.hSub x Îµ) (HAdd.hAdd x Îµ))","decl":"theorem Icc_mem_nhds (xt : x â‰  âˆ) (Îµ0 : Îµ â‰  0) : Icc (x - Îµ) (x + Îµ) âˆˆ ğ“ x :=\n  (hasBasis_nhds_of_ne_top' xt).mem_of_mem Îµ0\n\n"}
{"name":"ENNReal.nhds_of_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\nxt : Ne x Top.top\nâŠ¢ Eq (nhds x) (iInf fun Îµ => iInf fun h => Filter.principal (Set.Icc (HSub.hSub x Îµ) (HAdd.hAdd x Îµ)))","decl":"theorem nhds_of_ne_top (xt : x â‰  âˆ) : ğ“ x = â¨… Îµ > 0, ğ“Ÿ (Icc (x - Îµ) (x + Îµ)) :=\n  (hasBasis_nhds_of_ne_top xt).eq_biInf\n\n"}
{"name":"ENNReal.biInf_le_nhds","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x : ENNReal\nâŠ¢ LE.le (iInf fun Îµ => iInf fun h => Filter.principal (Set.Icc (HSub.hSub x Îµ) (HAdd.hAdd x Îµ))) (nhds x)","decl":"theorem biInf_le_nhds : âˆ€ x : â„â‰¥0âˆ, â¨… Îµ > 0, ğ“Ÿ (Icc (x - Îµ) (x + Îµ)) â‰¤ ğ“ x\n  | âˆ => iInfâ‚‚_le_of_le 1 one_pos <| by\n    simpa only [â† coe_one, top_sub_coe, top_add, Icc_self, principal_singleton] using pure_le_nhds _\n  | (x : â„â‰¥0) => (nhds_of_ne_top coe_ne_top).ge\n\n"}
{"name":"ENNReal.tendsto_nhds_of_Icc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nu : Î± â†’ ENNReal\na : ENNReal\nh : âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Filter.Eventually (fun x => Membership.mem (Set.Icc (HSub.hSub a Îµ) (HAdd.hAdd a Îµ)) (u x)) f\nâŠ¢ Filter.Tendsto u f (nhds a)","decl":"protected theorem tendsto_nhds_of_Icc {f : Filter Î±} {u : Î± â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ}\n    (h : âˆ€ Îµ > 0, âˆ€á¶  x in f, u x âˆˆ Icc (a - Îµ) (a + Îµ)) : Tendsto u f (ğ“ a) := by\n  refine Tendsto.mono_right ?_ (biInf_le_nhds _)\n  simpa only [tendsto_iInf, tendsto_principal]\n\n"}
{"name":"ENNReal.tendsto_nhds","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nu : Î± â†’ ENNReal\na : ENNReal\nha : Ne a Top.top\nâŠ¢ Iff (Filter.Tendsto u f (nhds a)) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Filter.Eventually (fun x => Membership.mem (Set.Icc (HSub.hSub a Îµ) (HAdd.hAdd a Îµ)) (u x)) f)","decl":"/-- Characterization of neighborhoods for `â„â‰¥0âˆ` numbers. See also `tendsto_order`\nfor a version with strict inequalities. -/\nprotected theorem tendsto_nhds {f : Filter Î±} {u : Î± â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ} (ha : a â‰  âˆ) :\n    Tendsto u f (ğ“ a) â†” âˆ€ Îµ > 0, âˆ€á¶  x in f, u x âˆˆ Icc (a - Îµ) (a + Îµ) := by\n  simp only [nhds_of_ne_top ha, tendsto_iInf, tendsto_principal]\n\n"}
{"name":"ENNReal.tendsto_nhds_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nu : Î± â†’ ENNReal\nâŠ¢ Iff (Filter.Tendsto u f (nhds 0)) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Filter.Eventually (fun x => LE.le (u x) Îµ) f)","decl":"protected theorem tendsto_nhds_zero {f : Filter Î±} {u : Î± â†’ â„â‰¥0âˆ} :\n    Tendsto u f (ğ“ 0) â†” âˆ€ Îµ > 0, âˆ€á¶  x in f, u x â‰¤ Îµ :=\n  nhds_zero_basis_Iic.tendsto_right_iff\n\n"}
{"name":"ENNReal.tendsto_const_sub_nhds_zero_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nl : Filter Î±\nf : Î± â†’ ENNReal\na : ENNReal\nha : Ne a Top.top\nhfa : âˆ€ (n : Î±), LE.le (f n) a\nâŠ¢ Iff (Filter.Tendsto (fun n => HSub.hSub a (f n)) l (nhds 0)) (Filter.Tendsto (fun n => f n) l (nhds a))","decl":"theorem tendsto_const_sub_nhds_zero_iff {l : Filter Î±} {f : Î± â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ} (ha : a â‰  âˆ)\n    (hfa : âˆ€ n, f n â‰¤ a) :\n    Tendsto (fun n â†¦ a - f n) l (ğ“ 0) â†” Tendsto (fun n â†¦ f n) l (ğ“ a) := by\n  rw [ENNReal.tendsto_nhds_zero, ENNReal.tendsto_nhds ha]\n  refine âŸ¨fun h Îµ hÎµ â†¦ ?_, fun h Îµ hÎµ â†¦ ?_âŸ©\n  Â· filter_upwards [h Îµ hÎµ] with n hn\n    refine âŸ¨?_, (hfa n).trans (le_add_right le_rfl)âŸ©\n    rw [tsub_le_iff_right] at hn âŠ¢\n    rwa [add_comm]\n  Â· filter_upwards [h Îµ hÎµ] with n hn\n    have hN_left := hn.1\n    rw [tsub_le_iff_right] at hN_left âŠ¢\n    rwa [add_comm]\n\n"}
{"name":"ENNReal.tendsto_atTop","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\ninstâœÂ¹ : Nonempty Î²\ninstâœ : SemilatticeSup Î²\nf : Î² â†’ ENNReal\na : ENNReal\nha : Ne a Top.top\nâŠ¢ Iff (Filter.Tendsto f Filter.atTop (nhds a)) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun N => âˆ€ (n : Î²), GE.ge n N â†’ Membership.mem (Set.Icc (HSub.hSub a Îµ) (HAdd.hAdd a Îµ)) (f n))","decl":"protected theorem tendsto_atTop [Nonempty Î²] [SemilatticeSup Î²] {f : Î² â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ}\n    (ha : a â‰  âˆ) : Tendsto f atTop (ğ“ a) â†” âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, f n âˆˆ Icc (a - Îµ) (a + Îµ) :=\n  .trans (atTop_basis.tendsto_iff (hasBasis_nhds_of_ne_top ha)) (by simp only [true_and]; rfl)\n\n"}
{"name":"ENNReal.tendsto_atTop_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\ninstâœÂ¹ : Nonempty Î²\ninstâœ : SemilatticeSup Î²\nf : Î² â†’ ENNReal\nâŠ¢ Iff (Filter.Tendsto f Filter.atTop (nhds 0)) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun N => âˆ€ (n : Î²), GE.ge n N â†’ LE.le (f n) Îµ)","decl":"protected theorem tendsto_atTop_zero [Nonempty Î²] [SemilatticeSup Î²] {f : Î² â†’ â„â‰¥0âˆ} :\n    Tendsto f atTop (ğ“ 0) â†” âˆ€ Îµ > 0, âˆƒ N, âˆ€ n â‰¥ N, f n â‰¤ Îµ :=\n  .trans (atTop_basis.tendsto_iff nhds_zero_basis_Iic) (by simp only [true_and]; rfl)\n\n"}
{"name":"ENNReal.tendsto_atTop_zero_iff_le_of_antitone","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_4\ninstâœÂ¹ : Nonempty Î²\ninstâœ : SemilatticeSup Î²\nf : Î² â†’ ENNReal\nhf : Antitone f\nâŠ¢ Iff (Filter.Tendsto f Filter.atTop (nhds 0)) (âˆ€ (Îµ : ENNReal), LT.lt 0 Îµ â†’ Exists fun n => LE.le (f n) Îµ)","decl":"theorem tendsto_atTop_zero_iff_le_of_antitone {Î² : Type*} [Nonempty Î²] [SemilatticeSup Î²]\n    {f : Î² â†’ â„â‰¥0âˆ} (hf : Antitone f) :\n    Filter.Tendsto f Filter.atTop (ğ“ 0) â†” âˆ€ Îµ, 0 < Îµ â†’ âˆƒ n : Î², f n â‰¤ Îµ := by\n  rw [ENNReal.tendsto_atTop_zero]\n  refine âŸ¨fun h â†¦ fun Îµ hÎµ â†¦ ?_, fun h â†¦ fun Îµ hÎµ â†¦ ?_âŸ©\n  Â· obtain âŸ¨n, hnâŸ© := h Îµ hÎµ\n    exact âŸ¨n, hn n le_rflâŸ©\n  Â· obtain âŸ¨n, hnâŸ© := h Îµ hÎµ\n    exact âŸ¨n, fun m hm â†¦ (hf hm).trans hnâŸ©\n\n"}
{"name":"ENNReal.tendsto_atTop_zero_iff_lt_of_antitone","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_4\ninstâœÂ¹ : Nonempty Î²\ninstâœ : SemilatticeSup Î²\nf : Î² â†’ ENNReal\nhf : Antitone f\nâŠ¢ Iff (Filter.Tendsto f Filter.atTop (nhds 0)) (âˆ€ (Îµ : ENNReal), LT.lt 0 Îµ â†’ Exists fun n => LT.lt (f n) Îµ)","decl":"theorem tendsto_atTop_zero_iff_lt_of_antitone {Î² : Type*} [Nonempty Î²] [SemilatticeSup Î²]\n    {f : Î² â†’ â„â‰¥0âˆ} (hf : Antitone f) :\n    Filter.Tendsto f Filter.atTop (ğ“ 0) â†” âˆ€ Îµ, 0 < Îµ â†’ âˆƒ n : Î², f n < Îµ := by\n  rw [ENNReal.tendsto_atTop_zero_iff_le_of_antitone hf]\n  constructor <;> intro h Îµ hÎµ\n  Â· obtain âŸ¨n, hnâŸ© := h (min 1 (Îµ / 2))\n      (lt_min_iff.mpr âŸ¨zero_lt_one, (ENNReal.div_pos_iff.mpr âŸ¨ne_of_gt hÎµ, ENNReal.ofNat_ne_topâŸ©)âŸ©)\n    Â· refine âŸ¨n, hn.trans_lt ?_âŸ©\n      by_cases hÎµ_top : Îµ = âˆ\n      Â· rw [hÎµ_top]\n        exact (min_le_left _ _).trans_lt ENNReal.one_lt_top\n      refine (min_le_right _ _).trans_lt ?_\n      rw [ENNReal.div_lt_iff (Or.inr hÎµ.ne') (Or.inr hÎµ_top)]\n      conv_lhs => rw [â† mul_one Îµ]\n      rw [ENNReal.mul_lt_mul_left hÎµ.ne' hÎµ_top]\n      norm_num\n  Â· obtain âŸ¨n, hnâŸ© := h Îµ hÎµ\n    exact âŸ¨n, hn.leâŸ©\n\n"}
{"name":"ENNReal.tendsto_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : ENNReal\naâœ : Or (Ne a Top.top) (Ne b Top.top)\nâŠ¢ Filter.Tendsto (fun p => HSub.hSub p.1 p.2) (nhds { fst := a, snd := b }) (nhds (HSub.hSub a b))","decl":"theorem tendsto_sub : âˆ€ {a b : â„â‰¥0âˆ}, (a â‰  âˆ âˆ¨ b â‰  âˆ) â†’\n    Tendsto (fun p : â„â‰¥0âˆ Ã— â„â‰¥0âˆ => p.1 - p.2) (ğ“ (a, b)) (ğ“ (a - b))\n  | âˆ, âˆ, h => by simp only [ne_eq, not_true_eq_false, or_self] at h\n  | âˆ, (b : â„â‰¥0), _ => by\n    rw [top_sub_coe, tendsto_nhds_top_iff_nnreal]\n    refine fun x => ((lt_mem_nhds <| @coe_lt_top (b + 1 + x)).prod_nhds\n      (ge_mem_nhds <| coe_lt_coe.2 <| lt_add_one b)).mono fun y hy => ?_\n    rw [lt_tsub_iff_left]\n    calc y.2 + x â‰¤ â†‘(b + 1) + x := add_le_add_right hy.2 _\n    _ < y.1 := hy.1\n  | (a : â„â‰¥0), âˆ, _ => by\n    rw [sub_top]\n    refine (tendsto_pure.2 ?_).mono_right (pure_le_nhds _)\n    exact ((gt_mem_nhds <| coe_lt_coe.2 <| lt_add_one a).prod_nhds\n      (lt_mem_nhds <| @coe_lt_top (a + 1))).mono fun x hx =>\n        tsub_eq_zero_iff_le.2 (hx.1.trans hx.2).le\n  | (a : â„â‰¥0), (b : â„â‰¥0), _ => by\n    simp only [nhds_coe_coe, tendsto_map'_iff, â† ENNReal.coe_sub, Function.comp_def, tendsto_coe]\n    exact continuous_sub.tendsto (a, b)\n\n"}
{"name":"ENNReal.Tendsto.sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nma mb : Î± â†’ ENNReal\na b : ENNReal\nhma : Filter.Tendsto ma f (nhds a)\nhmb : Filter.Tendsto mb f (nhds b)\nh : Or (Ne a Top.top) (Ne b Top.top)\nâŠ¢ Filter.Tendsto (fun a => HSub.hSub (ma a) (mb a)) f (nhds (HSub.hSub a b))","decl":"protected theorem Tendsto.sub {f : Filter Î±} {ma : Î± â†’ â„â‰¥0âˆ} {mb : Î± â†’ â„â‰¥0âˆ} {a b : â„â‰¥0âˆ}\n    (hma : Tendsto ma f (ğ“ a)) (hmb : Tendsto mb f (ğ“ b)) (h : a â‰  âˆ âˆ¨ b â‰  âˆ) :\n    Tendsto (fun a => ma a - mb a) f (ğ“ (a - b)) :=\n  show Tendsto ((fun p : â„â‰¥0âˆ Ã— â„â‰¥0âˆ => p.1 - p.2) âˆ˜ fun a => (ma a, mb a)) f (ğ“ (a - b)) from\n    Tendsto.comp (ENNReal.tendsto_sub h) (hma.prod_mk_nhds hmb)\n\n"}
{"name":"ENNReal.tendsto_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : ENNReal\nha : Or (Ne a 0) (Ne b Top.top)\nhb : Or (Ne b 0) (Ne a Top.top)\nâŠ¢ Filter.Tendsto (fun p => HMul.hMul p.1 p.2) (nhds { fst := a, snd := b }) (nhds (HMul.hMul a b))","decl":"protected theorem tendsto_mul (ha : a â‰  0 âˆ¨ b â‰  âˆ) (hb : b â‰  0 âˆ¨ a â‰  âˆ) :\n    Tendsto (fun p : â„â‰¥0âˆ Ã— â„â‰¥0âˆ => p.1 * p.2) (ğ“ (a, b)) (ğ“ (a * b)) := by\n  have ht : âˆ€ b : â„â‰¥0âˆ, b â‰  0 â†’\n      Tendsto (fun p : â„â‰¥0âˆ Ã— â„â‰¥0âˆ => p.1 * p.2) (ğ“ (âˆ, b)) (ğ“ âˆ) := fun b hb => by\n    refine tendsto_nhds_top_iff_nnreal.2 fun n => ?_\n    rcases lt_iff_exists_nnreal_btwn.1 (pos_iff_ne_zero.2 hb) with âŸ¨Îµ, hÎµ, hÎµbâŸ©\n    have : âˆ€á¶  c : â„â‰¥0âˆ Ã— â„â‰¥0âˆ in ğ“ (âˆ, b), â†‘n / â†‘Îµ < c.1 âˆ§ â†‘Îµ < c.2 :=\n      (lt_mem_nhds <| div_lt_top coe_ne_top hÎµ.ne').prod_nhds (lt_mem_nhds hÎµb)\n    refine this.mono fun c hc => ?_\n    exact (ENNReal.div_mul_cancel hÎµ.ne' coe_ne_top).symm.trans_lt (mul_lt_mul hc.1 hc.2)\n  induction a with\n  | top => simp only [ne_eq, or_false, not_true_eq_false] at hb; simp [ht b hb, top_mul hb]\n  | coe a =>\n    induction b with\n    | top =>\n      simp only [ne_eq, or_false, not_true_eq_false] at ha\n      simpa [Function.comp_def, mul_comm, mul_top ha]\n        using (ht a ha).comp (continuous_swap.tendsto (ofNNReal a, âˆ))\n    | coe b =>\n      simp only [nhds_coe_coe, â† coe_mul, tendsto_coe, tendsto_map'_iff, Function.comp_def,\n        tendsto_mul]\n\n"}
{"name":"ENNReal.Tendsto.mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nma mb : Î± â†’ ENNReal\na b : ENNReal\nhma : Filter.Tendsto ma f (nhds a)\nha : Or (Ne a 0) (Ne b Top.top)\nhmb : Filter.Tendsto mb f (nhds b)\nhb : Or (Ne b 0) (Ne a Top.top)\nâŠ¢ Filter.Tendsto (fun a => HMul.hMul (ma a) (mb a)) f (nhds (HMul.hMul a b))","decl":"protected theorem Tendsto.mul {f : Filter Î±} {ma : Î± â†’ â„â‰¥0âˆ} {mb : Î± â†’ â„â‰¥0âˆ} {a b : â„â‰¥0âˆ}\n    (hma : Tendsto ma f (ğ“ a)) (ha : a â‰  0 âˆ¨ b â‰  âˆ) (hmb : Tendsto mb f (ğ“ b))\n    (hb : b â‰  0 âˆ¨ a â‰  âˆ) : Tendsto (fun a => ma a * mb a) f (ğ“ (a * b)) :=\n  show Tendsto ((fun p : â„â‰¥0âˆ Ã— â„â‰¥0âˆ => p.1 * p.2) âˆ˜ fun a => (ma a, mb a)) f (ğ“ (a * b)) from\n    Tendsto.comp (ENNReal.tendsto_mul ha hb) (hma.prod_mk_nhds hmb)\n\n"}
{"name":"ContinuousOn.ennreal_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ ENNReal\ns : Set Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nhâ‚ : âˆ€ (x : Î±), Membership.mem s x â†’ Or (Ne (f x) 0) (Ne (g x) Top.top)\nhâ‚‚ : âˆ€ (x : Î±), Membership.mem s x â†’ Or (Ne (g x) 0) (Ne (f x) Top.top)\nâŠ¢ ContinuousOn (fun x => HMul.hMul (f x) (g x)) s","decl":"theorem _root_.ContinuousOn.ennreal_mul [TopologicalSpace Î±] {f g : Î± â†’ â„â‰¥0âˆ} {s : Set Î±}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) (hâ‚ : âˆ€ x âˆˆ s, f x â‰  0 âˆ¨ g x â‰  âˆ)\n    (hâ‚‚ : âˆ€ x âˆˆ s, g x â‰  0 âˆ¨ f x â‰  âˆ) : ContinuousOn (fun x => f x * g x) s := fun x hx =>\n  ENNReal.Tendsto.mul (hf x hx) (hâ‚ x hx) (hg x hx) (hâ‚‚ x hx)\n\n"}
{"name":"Continuous.ennreal_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ ENNReal\nhf : Continuous f\nhg : Continuous g\nhâ‚ : âˆ€ (x : Î±), Or (Ne (f x) 0) (Ne (g x) Top.top)\nhâ‚‚ : âˆ€ (x : Î±), Or (Ne (g x) 0) (Ne (f x) Top.top)\nâŠ¢ Continuous fun x => HMul.hMul (f x) (g x)","decl":"theorem _root_.Continuous.ennreal_mul [TopologicalSpace Î±] {f g : Î± â†’ â„â‰¥0âˆ} (hf : Continuous f)\n    (hg : Continuous g) (hâ‚ : âˆ€ x, f x â‰  0 âˆ¨ g x â‰  âˆ) (hâ‚‚ : âˆ€ x, g x â‰  0 âˆ¨ f x â‰  âˆ) :\n    Continuous fun x => f x * g x :=\n  continuous_iff_continuousAt.2 fun x =>\n    ENNReal.Tendsto.mul hf.continuousAt (hâ‚ x) hg.continuousAt (hâ‚‚ x)\n\n"}
{"name":"ENNReal.Tendsto.const_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nm : Î± â†’ ENNReal\na b : ENNReal\nhm : Filter.Tendsto m f (nhds b)\nhb : Or (Ne b 0) (Ne a Top.top)\nâŠ¢ Filter.Tendsto (fun b => HMul.hMul a (m b)) f (nhds (HMul.hMul a b))","decl":"protected theorem Tendsto.const_mul {f : Filter Î±} {m : Î± â†’ â„â‰¥0âˆ} {a b : â„â‰¥0âˆ}\n    (hm : Tendsto m f (ğ“ b)) (hb : b â‰  0 âˆ¨ a â‰  âˆ) : Tendsto (fun b => a * m b) f (ğ“ (a * b)) :=\n  by_cases (fun (this : a = 0) => by simp [this, tendsto_const_nhds]) fun ha : a â‰  0 =>\n    ENNReal.Tendsto.mul tendsto_const_nhds (Or.inl ha) hm hb\n\n"}
{"name":"ENNReal.Tendsto.mul_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nm : Î± â†’ ENNReal\na b : ENNReal\nhm : Filter.Tendsto m f (nhds a)\nha : Or (Ne a 0) (Ne b Top.top)\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul (m x) b) f (nhds (HMul.hMul a b))","decl":"protected theorem Tendsto.mul_const {f : Filter Î±} {m : Î± â†’ â„â‰¥0âˆ} {a b : â„â‰¥0âˆ}\n    (hm : Tendsto m f (ğ“ a)) (ha : a â‰  0 âˆ¨ b â‰  âˆ) : Tendsto (fun x => m x * b) f (ğ“ (a * b)) := by\n  simpa only [mul_comm] using ENNReal.Tendsto.const_mul hm ha\n\n"}
{"name":"ENNReal.tendsto_finset_prod_of_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nf : Î¹ â†’ Î± â†’ ENNReal\nx : Filter Î±\na : Î¹ â†’ ENNReal\ns : Finset Î¹\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ Filter.Tendsto (f i) x (nhds (a i))\nh' : âˆ€ (i : Î¹), Membership.mem s i â†’ Ne (a i) Top.top\nâŠ¢ Filter.Tendsto (fun b => s.prod fun c => f c b) x (nhds (s.prod fun c => a c))","decl":"theorem tendsto_finset_prod_of_ne_top {Î¹ : Type*} {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {x : Filter Î±} {a : Î¹ â†’ â„â‰¥0âˆ}\n    (s : Finset Î¹) (h : âˆ€ i âˆˆ s, Tendsto (f i) x (ğ“ (a i))) (h' : âˆ€ i âˆˆ s, a i â‰  âˆ) :\n    Tendsto (fun b => âˆ c âˆˆ s, f c b) x (ğ“ (âˆ c âˆˆ s, a c)) := by\n  classical\n  induction' s using Finset.induction with a s has IH\n  Â· simp [tendsto_const_nhds]\n  simp only [Finset.prod_insert has]\n  apply Tendsto.mul (h _ (Finset.mem_insert_self _ _))\n  Â· right\n    exact prod_ne_top fun i hi => h' _ (Finset.mem_insert_of_mem hi)\n  Â· exact IH (fun i hi => h _ (Finset.mem_insert_of_mem hi)) fun i hi =>\n      h' _ (Finset.mem_insert_of_mem hi)\n  Â· exact Or.inr (h' _ (Finset.mem_insert_self _ _))\n\n"}
{"name":"ENNReal.continuousAt_const_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : ENNReal\nh : Or (Ne a Top.top) (Ne b 0)\nâŠ¢ ContinuousAt (fun x => HMul.hMul a x) b","decl":"protected theorem continuousAt_const_mul {a b : â„â‰¥0âˆ} (h : a â‰  âˆ âˆ¨ b â‰  0) :\n    ContinuousAt (a * Â·) b :=\n  Tendsto.const_mul tendsto_id h.symm\n\n"}
{"name":"ENNReal.continuousAt_mul_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : ENNReal\nh : Or (Ne a Top.top) (Ne b 0)\nâŠ¢ ContinuousAt (fun x => HMul.hMul x a) b","decl":"protected theorem continuousAt_mul_const {a b : â„â‰¥0âˆ} (h : a â‰  âˆ âˆ¨ b â‰  0) :\n    ContinuousAt (fun x => x * a) b :=\n  Tendsto.mul_const tendsto_id h.symm\n\n"}
{"name":"ENNReal.continuous_const_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nha : Ne a Top.top\nâŠ¢ Continuous fun x => HMul.hMul a x","decl":"@[fun_prop]\nprotected theorem continuous_const_mul {a : â„â‰¥0âˆ} (ha : a â‰  âˆ) : Continuous (a * Â·) :=\n  continuous_iff_continuousAt.2 fun _ => ENNReal.continuousAt_const_mul (Or.inl ha)\n\n"}
{"name":"ENNReal.continuous_mul_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nha : Ne a Top.top\nâŠ¢ Continuous fun x => HMul.hMul x a","decl":"@[fun_prop]\nprotected theorem continuous_mul_const {a : â„â‰¥0âˆ} (ha : a â‰  âˆ) : Continuous fun x => x * a :=\n  continuous_iff_continuousAt.2 fun _ => ENNReal.continuousAt_mul_const (Or.inl ha)\n\n"}
{"name":"ENNReal.continuous_div_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"c : ENNReal\nc_ne_zero : Ne c 0\nâŠ¢ Continuous fun x => HDiv.hDiv x c","decl":"@[fun_prop]\nprotected theorem continuous_div_const (c : â„â‰¥0âˆ) (c_ne_zero : c â‰  0) :\n    Continuous fun x : â„â‰¥0âˆ => x / c :=\n  ENNReal.continuous_mul_const <| ENNReal.inv_ne_top.2 c_ne_zero\n\n"}
{"name":"ENNReal.continuous_pow","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Nat\nâŠ¢ Continuous fun a => HPow.hPow a n","decl":"@[continuity, fun_prop]\nprotected theorem continuous_pow (n : â„•) : Continuous fun a : â„â‰¥0âˆ => a ^ n := by\n  induction' n with n IH\n  Â· simp [continuous_const]\n  simp_rw [pow_add, pow_one, continuous_iff_continuousAt]\n  intro x\n  refine ENNReal.Tendsto.mul (IH.tendsto _) ?_ tendsto_id ?_ <;> by_cases H : x = 0\n  Â· simp only [H, zero_ne_top, Ne, or_true, not_false_iff]\n  Â· exact Or.inl fun h => H (pow_eq_zero h)\n  Â· simp only [H, pow_eq_top_iff, zero_ne_top, false_or, eq_self_iff_true, not_true, Ne,\n      not_false_iff, false_and]\n  Â· simp only [H, true_or, Ne, not_false_iff]\n\n"}
{"name":"ENNReal.continuousOn_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ ContinuousOn (fun p => HSub.hSub p.1 p.2) (setOf fun p => Ne p { fst := Top.top, snd := Top.top })","decl":"theorem continuousOn_sub :\n    ContinuousOn (fun p : â„â‰¥0âˆ Ã— â„â‰¥0âˆ => p.fst - p.snd) { p : â„â‰¥0âˆ Ã— â„â‰¥0âˆ | p â‰  âŸ¨âˆ, âˆâŸ© } := by\n  rw [ContinuousOn]\n  rintro âŸ¨x, yâŸ© hp\n  simp only [Ne, Set.mem_setOf_eq, Prod.mk.inj_iff] at hp\n  exact tendsto_nhdsWithin_of_tendsto_nhds (tendsto_sub (not_and_or.mp hp))\n\n"}
{"name":"ENNReal.continuous_sub_left","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\na_ne_top : Ne a Top.top\nâŠ¢ Continuous fun x => HSub.hSub a x","decl":"theorem continuous_sub_left {a : â„â‰¥0âˆ} (a_ne_top : a â‰  âˆ) : Continuous (a - Â·) := by\n  change Continuous (Function.uncurry Sub.sub âˆ˜ (a, Â·))\n  refine continuousOn_sub.comp_continuous (Continuous.Prod.mk a) fun x => ?_\n  simp only [a_ne_top, Ne, mem_setOf_eq, Prod.mk.inj_iff, false_and, not_false_iff]\n\n"}
{"name":"ENNReal.continuous_nnreal_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : NNReal\nâŠ¢ Continuous fun x => HSub.hSub (â†‘a) x","decl":"theorem continuous_nnreal_sub {a : â„â‰¥0} : Continuous fun x : â„â‰¥0âˆ => (a : â„â‰¥0âˆ) - x :=\n  continuous_sub_left coe_ne_top\n\n"}
{"name":"ENNReal.continuousOn_sub_left","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nâŠ¢ ContinuousOn (fun x => HSub.hSub a x) (setOf fun x => Ne x Top.top)","decl":"theorem continuousOn_sub_left (a : â„â‰¥0âˆ) : ContinuousOn (a - Â·) { x : â„â‰¥0âˆ | x â‰  âˆ } := by\n  rw [show (fun x => a - x) = (fun p : â„â‰¥0âˆ Ã— â„â‰¥0âˆ => p.fst - p.snd) âˆ˜ fun x => âŸ¨a, xâŸ© by rfl]\n  apply ContinuousOn.comp continuousOn_sub (Continuous.continuousOn (Continuous.Prod.mk a))\n  rintro _ h (_ | _)\n  exact h none_eq_top\n\n"}
{"name":"ENNReal.continuous_sub_right","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a : ENNReal\nâŠ¢ Continuous fun x => HSub.hSub x a","decl":"theorem continuous_sub_right (a : â„â‰¥0âˆ) : Continuous fun x : â„â‰¥0âˆ => x - a := by\n  by_cases a_infty : a = âˆ\n  Â· simp [a_infty, continuous_const, tsub_eq_zero_of_le]\n  Â· rw [show (fun x => x - a) = (fun p : â„â‰¥0âˆ Ã— â„â‰¥0âˆ => p.fst - p.snd) âˆ˜ fun x => âŸ¨x, aâŸ© by rfl]\n    apply ContinuousOn.comp_continuous continuousOn_sub (continuous_id'.prod_mk continuous_const)\n    intro x\n    simp only [a_infty, Ne, mem_setOf_eq, Prod.mk.inj_iff, and_false, not_false_iff]\n\n"}
{"name":"ENNReal.Tendsto.pow","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nm : Î± â†’ ENNReal\na : ENNReal\nn : Nat\nhm : Filter.Tendsto m f (nhds a)\nâŠ¢ Filter.Tendsto (fun x => HPow.hPow (m x) n) f (nhds (HPow.hPow a n))","decl":"protected theorem Tendsto.pow {f : Filter Î±} {m : Î± â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ} {n : â„•}\n    (hm : Tendsto m f (ğ“ a)) : Tendsto (fun x => m x ^ n) f (ğ“ (a ^ n)) :=\n  ((ENNReal.continuous_pow n).tendsto a).comp hm\n\n"}
{"name":"ENNReal.le_of_forall_lt_one_mul_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"x y : ENNReal\nh : âˆ€ (a : ENNReal), LT.lt a 1 â†’ LE.le (HMul.hMul a x) y\nâŠ¢ LE.le x y","decl":"theorem le_of_forall_lt_one_mul_le {x y : â„â‰¥0âˆ} (h : âˆ€ a < 1, a * x â‰¤ y) : x â‰¤ y := by\n  have : Tendsto (Â· * x) (ğ“[<] 1) (ğ“ (1 * x)) :=\n    (ENNReal.continuousAt_mul_const (Or.inr one_ne_zero)).mono_left inf_le_left\n  rw [one_mul] at this\n  exact le_of_tendsto this (eventually_nhdsWithin_iff.2 <| Eventually.of_forall h)\n\n"}
{"name":"ENNReal.iInf_mul_left'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Sort u_4\nf : Î¹ â†’ ENNReal\na : ENNReal\nh : Eq a Top.top â†’ Eq (iInf fun i => f i) 0 â†’ Exists fun i => Eq (f i) 0\nh0 : Eq a 0 â†’ Nonempty Î¹\nâŠ¢ Eq (iInf fun i => HMul.hMul a (f i)) (HMul.hMul a (iInf fun i => f i))","decl":"@[deprecated mul_iInf' (since := \"2024-09-12\")]\ntheorem iInf_mul_left' {Î¹} {f : Î¹ â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ} (h : a = âˆ â†’ â¨… i, f i = 0 â†’ âˆƒ i, f i = 0)\n    (h0 : a = 0 â†’ Nonempty Î¹) : â¨… i, a * f i = a * â¨… i, f i := .symm <| mul_iInf' h h0\n\n"}
{"name":"ENNReal.iInf_mul_left","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Sort u_4\ninstâœ : Nonempty Î¹\nf : Î¹ â†’ ENNReal\na : ENNReal\nh : Eq a Top.top â†’ Eq (iInf fun i => f i) 0 â†’ Exists fun i => Eq (f i) 0\nâŠ¢ Eq (iInf fun i => HMul.hMul a (f i)) (HMul.hMul a (iInf fun i => f i))","decl":"@[deprecated mul_iInf (since := \"2024-09-12\")]\ntheorem iInf_mul_left {Î¹} [Nonempty Î¹] {f : Î¹ â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ}\n    (h : a = âˆ â†’ â¨… i, f i = 0 â†’ âˆƒ i, f i = 0) : â¨… i, a * f i = a * â¨… i, f i :=\n  .symm <| mul_iInf h\n\n"}
{"name":"ENNReal.iInf_mul_right'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Sort u_4\nf : Î¹ â†’ ENNReal\na : ENNReal\nh : Eq a Top.top â†’ Eq (iInf fun i => f i) 0 â†’ Exists fun i => Eq (f i) 0\nh0 : Eq a 0 â†’ Nonempty Î¹\nâŠ¢ Eq (iInf fun i => HMul.hMul (f i) a) (HMul.hMul (iInf fun i => f i) a)","decl":"@[deprecated iInf_mul' (since := \"2024-09-12\")]\ntheorem iInf_mul_right' {Î¹} {f : Î¹ â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ} (h : a = âˆ â†’ â¨… i, f i = 0 â†’ âˆƒ i, f i = 0)\n    (h0 : a = 0 â†’ Nonempty Î¹) : â¨… i, f i * a = (â¨… i, f i) * a := .symm <| iInf_mul' h h0\n\n"}
{"name":"ENNReal.iInf_mul_right","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Sort u_4\ninstâœ : Nonempty Î¹\nf : Î¹ â†’ ENNReal\na : ENNReal\nh : Eq a Top.top â†’ Eq (iInf fun i => f i) 0 â†’ Exists fun i => Eq (f i) 0\nâŠ¢ Eq (iInf fun i => HMul.hMul (f i) a) (HMul.hMul (iInf fun i => f i) a)","decl":"@[deprecated iInf_mul (since := \"2024-09-12\")]\ntheorem iInf_mul_right {Î¹} [Nonempty Î¹] {f : Î¹ â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ}\n    (h : a = âˆ â†’ â¨… i, f i = 0 â†’ âˆƒ i, f i = 0) : â¨… i, f i * a = (â¨… i, f i) * a := .symm <| iInf_mul h\n\n"}
{"name":"ENNReal.inv_map_iInf","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Sort u_4\nx : Î¹ â†’ ENNReal\nâŠ¢ Eq (Inv.inv (iInf x)) (iSup fun i => Inv.inv (x i))","decl":"@[deprecated inv_iInf (since := \"2024-09-12\")]\ntheorem inv_map_iInf {Î¹ : Sort*} {x : Î¹ â†’ â„â‰¥0âˆ} : (iInf x)â»Â¹ = â¨† i, (x i)â»Â¹ :=\n  OrderIso.invENNReal.map_iInf x\n\n"}
{"name":"ENNReal.inv_map_iSup","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Sort u_4\nx : Î¹ â†’ ENNReal\nâŠ¢ Eq (Inv.inv (iSup x)) (iInf fun i => Inv.inv (x i))","decl":"@[deprecated inv_iSup (since := \"2024-09-12\")]\ntheorem inv_map_iSup {Î¹ : Sort*} {x : Î¹ â†’ â„â‰¥0âˆ} : (iSup x)â»Â¹ = â¨… i, (x i)â»Â¹ :=\n  OrderIso.invENNReal.map_iSup x\n\n"}
{"name":"ENNReal.inv_limsup","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nx : Î¹ â†’ ENNReal\nl : Filter Î¹\nâŠ¢ Eq (Inv.inv (Filter.limsup x l)) (Filter.liminf (fun i => Inv.inv (x i)) l)","decl":"theorem inv_limsup {Î¹ : Sort _} {x : Î¹ â†’ â„â‰¥0âˆ} {l : Filter Î¹} :\n    (limsup x l)â»Â¹ = liminf (fun i => (x i)â»Â¹) l :=\n  OrderIso.invENNReal.limsup_apply\n\n"}
{"name":"ENNReal.inv_liminf","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nx : Î¹ â†’ ENNReal\nl : Filter Î¹\nâŠ¢ Eq (Inv.inv (Filter.liminf x l)) (Filter.limsup (fun i => Inv.inv (x i)) l)","decl":"theorem inv_liminf {Î¹ : Sort _} {x : Î¹ â†’ â„â‰¥0âˆ} {l : Filter Î¹} :\n    (liminf x l)â»Â¹ = limsup (fun i => (x i)â»Â¹) l :=\n  OrderIso.invENNReal.liminf_apply\n\n"}
{"name":"ENNReal.continuous_zpow","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"n : Int\nâŠ¢ Continuous fun x => HPow.hPow x n","decl":"@[fun_prop]\nprotected theorem continuous_zpow : âˆ€ n : â„¤, Continuous (Â· ^ n : â„â‰¥0âˆ â†’ â„â‰¥0âˆ)\n  | (n : â„•) => mod_cast ENNReal.continuous_pow n\n  | .negSucc n => by simpa using (ENNReal.continuous_pow _).inv\n\n"}
{"name":"ENNReal.tendsto_inv_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nm : Î± â†’ ENNReal\na : ENNReal\nâŠ¢ Iff (Filter.Tendsto (fun x => Inv.inv (m x)) f (nhds (Inv.inv a))) (Filter.Tendsto m f (nhds a))","decl":"@[simp] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `[InvolutiveInv _] [ContinuousInv _]`\nprotected theorem tendsto_inv_iff {f : Filter Î±} {m : Î± â†’ â„â‰¥0âˆ} {a : â„â‰¥0âˆ} :\n    Tendsto (fun x => (m x)â»Â¹) f (ğ“ aâ»Â¹) â†” Tendsto m f (ğ“ a) :=\n  âŸ¨fun h => by simpa only [inv_inv] using Tendsto.inv h, Tendsto.invâŸ©\n\n"}
{"name":"ENNReal.Tendsto.div","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nma mb : Î± â†’ ENNReal\na b : ENNReal\nhma : Filter.Tendsto ma f (nhds a)\nha : Or (Ne a 0) (Ne b 0)\nhmb : Filter.Tendsto mb f (nhds b)\nhb : Or (Ne b Top.top) (Ne a Top.top)\nâŠ¢ Filter.Tendsto (fun a => HDiv.hDiv (ma a) (mb a)) f (nhds (HDiv.hDiv a b))","decl":"protected theorem Tendsto.div {f : Filter Î±} {ma : Î± â†’ â„â‰¥0âˆ} {mb : Î± â†’ â„â‰¥0âˆ} {a b : â„â‰¥0âˆ}\n    (hma : Tendsto ma f (ğ“ a)) (ha : a â‰  0 âˆ¨ b â‰  0) (hmb : Tendsto mb f (ğ“ b))\n    (hb : b â‰  âˆ âˆ¨ a â‰  âˆ) : Tendsto (fun a => ma a / mb a) f (ğ“ (a / b)) := by\n  apply Tendsto.mul hma _ (ENNReal.tendsto_inv_iff.2 hmb) _ <;> simp [ha, hb]\n\n"}
{"name":"ENNReal.Tendsto.const_div","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nm : Î± â†’ ENNReal\na b : ENNReal\nhm : Filter.Tendsto m f (nhds b)\nhb : Or (Ne b Top.top) (Ne a Top.top)\nâŠ¢ Filter.Tendsto (fun b => HDiv.hDiv a (m b)) f (nhds (HDiv.hDiv a b))","decl":"protected theorem Tendsto.const_div {f : Filter Î±} {m : Î± â†’ â„â‰¥0âˆ} {a b : â„â‰¥0âˆ}\n    (hm : Tendsto m f (ğ“ b)) (hb : b â‰  âˆ âˆ¨ a â‰  âˆ) : Tendsto (fun b => a / m b) f (ğ“ (a / b)) := by\n  apply Tendsto.const_mul (ENNReal.tendsto_inv_iff.2 hm)\n  simp [hb]\n\n"}
{"name":"ENNReal.Tendsto.div_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Filter Î±\nm : Î± â†’ ENNReal\na b : ENNReal\nhm : Filter.Tendsto m f (nhds a)\nha : Or (Ne a 0) (Ne b 0)\nâŠ¢ Filter.Tendsto (fun x => HDiv.hDiv (m x) b) f (nhds (HDiv.hDiv a b))","decl":"protected theorem Tendsto.div_const {f : Filter Î±} {m : Î± â†’ â„â‰¥0âˆ} {a b : â„â‰¥0âˆ}\n    (hm : Tendsto m f (ğ“ a)) (ha : a â‰  0 âˆ¨ b â‰  0) : Tendsto (fun x => m x / b) f (ğ“ (a / b)) := by\n  apply Tendsto.mul_const hm\n  simp [ha]\n\n"}
{"name":"ENNReal.tendsto_inv_nat_nhds_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Filter.Tendsto (fun n => Inv.inv â†‘n) Filter.atTop (nhds 0)","decl":"protected theorem tendsto_inv_nat_nhds_zero : Tendsto (fun n : â„• => (n : â„â‰¥0âˆ)â»Â¹) atTop (ğ“ 0) :=\n  ENNReal.inv_top â–¸ ENNReal.tendsto_inv_iff.2 tendsto_nat_nhds_top\n\n"}
{"name":"ENNReal.tendsto_coe_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"r : NNReal\nb : ENNReal\nâŠ¢ Filter.Tendsto (fun b => HSub.hSub (â†‘r) b) (nhds b) (nhds (HSub.hSub (â†‘r) b))","decl":"protected theorem tendsto_coe_sub {b : â„â‰¥0âˆ} :\n    Tendsto (fun b : â„â‰¥0âˆ => â†‘r - b) (ğ“ b) (ğ“ (â†‘r - b)) :=\n  continuous_nnreal_sub.tendsto _\n\n"}
{"name":"ENNReal.exists_countable_dense_no_zero_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"âŠ¢ Exists fun s => And s.Countable (And (Dense s) (And (Not (Membership.mem s 0)) (Not (Membership.mem s Top.top))))","decl":"theorem exists_countable_dense_no_zero_top :\n    âˆƒ s : Set â„â‰¥0âˆ, s.Countable âˆ§ Dense s âˆ§ 0 âˆ‰ s âˆ§ âˆ âˆ‰ s := by\n  obtain âŸ¨s, s_count, s_dense, hsâŸ© :\n    âˆƒ s : Set â„â‰¥0âˆ, s.Countable âˆ§ Dense s âˆ§ (âˆ€ x, IsBot x â†’ x âˆ‰ s) âˆ§ âˆ€ x, IsTop x â†’ x âˆ‰ s :=\n    exists_countable_dense_no_bot_top â„â‰¥0âˆ\n  exact âŸ¨s, s_count, s_dense, fun h => hs.1 0 (by simp) h, fun h => hs.2 âˆ (by simp) hâŸ©\n\n"}
{"name":"ENNReal.ofReal_cinfi","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\ninstâœ : Nonempty Î±\nâŠ¢ Eq (ENNReal.ofReal (iInf fun i => f i)) (iInf fun i => ENNReal.ofReal (f i))","decl":"@[deprecated ofReal_iInf (since := \"2024-09-12\")]\ntheorem ofReal_cinfi (f : Î± â†’ â„) [Nonempty Î±] :\n    ENNReal.ofReal (â¨… i, f i) = â¨… i, ENNReal.ofReal (f i) := by\n  by_cases hf : BddBelow (range f)\n  Â· exact\n      Monotone.map_ciInf_of_continuousAt ENNReal.continuous_ofReal.continuousAt\n        (fun i j hij => ENNReal.ofReal_le_ofReal hij) hf\n  Â· symm\n    rw [Real.iInf_of_not_bddBelow hf, ENNReal.ofReal_zero, â† ENNReal.bot_eq_zero, iInf_eq_bot]\n    obtain âŸ¨y, hy_mem, hy_negâŸ© := not_bddBelow_iff.mp hf 0\n    obtain âŸ¨i, rflâŸ© := mem_range.mpr hy_mem\n    refine fun x hx => âŸ¨i, ?_âŸ©\n    rwa [ENNReal.ofReal_of_nonpos hy_neg.le]\n\n"}
{"name":"ENNReal.exists_frequently_lt_of_liminf_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nl : Filter Î¹\nx : Î¹ â†’ Real\nhx : Ne (Filter.liminf (fun n => â†‘(Real.nnabs (x n))) l) Top.top\nâŠ¢ Exists fun R => Filter.Frequently (fun n => LT.lt (x n) R) l","decl":"theorem exists_frequently_lt_of_liminf_ne_top {Î¹ : Type*} {l : Filter Î¹} {x : Î¹ â†’ â„}\n    (hx : liminf (fun n => (Real.nnabs (x n) : â„â‰¥0âˆ)) l â‰  âˆ) : âˆƒ R, âˆƒá¶  n in l, x n < R := by\n  by_contra h\n  simp_rw [not_exists, not_frequently, not_lt] at h\n  refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)\n  simp only [eventually_map, ENNReal.coe_le_coe]\n  filter_upwards [h r] with i hi using hi.trans (le_abs_self (x i))\n\n"}
{"name":"ENNReal.exists_frequently_lt_of_liminf_ne_top'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nl : Filter Î¹\nx : Î¹ â†’ Real\nhx : Ne (Filter.liminf (fun n => â†‘(Real.nnabs (x n))) l) Top.top\nâŠ¢ Exists fun R => Filter.Frequently (fun n => LT.lt R (x n)) l","decl":"theorem exists_frequently_lt_of_liminf_ne_top' {Î¹ : Type*} {l : Filter Î¹} {x : Î¹ â†’ â„}\n    (hx : liminf (fun n => (Real.nnabs (x n) : â„â‰¥0âˆ)) l â‰  âˆ) : âˆƒ R, âˆƒá¶  n in l, R < x n := by\n  by_contra h\n  simp_rw [not_exists, not_frequently, not_lt] at h\n  refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)\n  simp only [eventually_map, ENNReal.coe_le_coe]\n  filter_upwards [h (-r)] with i hi using(le_neg.1 hi).trans (neg_le_abs _)\n\n"}
{"name":"ENNReal.exists_upcrossings_of_not_bounded_under","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nl : Filter Î¹\nx : Î¹ â†’ Real\nhf : Ne (Filter.liminf (fun i => â†‘(Real.nnabs (x i))) l) Top.top\nhbdd : Not (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun i => abs (x i))\nâŠ¢ Exists fun a => Exists fun b => And (LT.lt a b) (And (Filter.Frequently (fun i => LT.lt (x i) â†‘a) l) (Filter.Frequently (fun i => LT.lt (â†‘b) (x i)) l))","decl":"theorem exists_upcrossings_of_not_bounded_under {Î¹ : Type*} {l : Filter Î¹} {x : Î¹ â†’ â„}\n    (hf : liminf (fun i => (Real.nnabs (x i) : â„â‰¥0âˆ)) l â‰  âˆ)\n    (hbdd : Â¬IsBoundedUnder (Â· â‰¤ Â·) l fun i => |x i|) :\n    âˆƒ a b : â„š, a < b âˆ§ (âˆƒá¶  i in l, x i < a) âˆ§ âˆƒá¶  i in l, â†‘b < x i := by\n  rw [isBoundedUnder_le_abs, not_and_or] at hbdd\n  obtain hbdd | hbdd := hbdd\n  Â· obtain âŸ¨R, hRâŸ© := exists_frequently_lt_of_liminf_ne_top hf\n    obtain âŸ¨q, hqâŸ© := exists_rat_gt R\n    refine âŸ¨q, q + 1, (lt_add_iff_pos_right _).2 zero_lt_one, ?_, ?_âŸ©\n    Â· refine fun hcon => hR ?_\n      filter_upwards [hcon] with x hx using not_lt.2 (lt_of_lt_of_le hq (not_lt.1 hx)).le\n    Â· simp only [IsBoundedUnder, IsBounded, eventually_map, eventually_atTop, not_exists,\n        not_forall, not_le, exists_prop] at hbdd\n      refine fun hcon => hbdd â†‘(q + 1) ?_\n      filter_upwards [hcon] with x hx using not_lt.1 hx\n  Â· obtain âŸ¨R, hRâŸ© := exists_frequently_lt_of_liminf_ne_top' hf\n    obtain âŸ¨q, hqâŸ© := exists_rat_lt R\n    refine âŸ¨q - 1, q, (sub_lt_self_iff _).2 zero_lt_one, ?_, ?_âŸ©\n    Â· simp only [IsBoundedUnder, IsBounded, eventually_map, eventually_atTop, not_exists,\n        not_forall, not_le, exists_prop] at hbdd\n      refine fun hcon => hbdd â†‘(q - 1) ?_\n      filter_upwards [hcon] with x hx using not_lt.1 hx\n    Â· refine fun hcon => hR ?_\n      filter_upwards [hcon] with x hx using not_lt.2 ((not_lt.1 hx).trans hq.le)\n\n"}
{"name":"ENNReal.hasSum_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ NNReal\nr : NNReal\nâŠ¢ Iff (HasSum (fun a => â†‘(f a)) â†‘r) (HasSum f r)","decl":"@[norm_cast]\nprotected theorem hasSum_coe {f : Î± â†’ â„â‰¥0} {r : â„â‰¥0} :\n    HasSum (fun a => (f a : â„â‰¥0âˆ)) â†‘r â†” HasSum f r := by\n  simp only [HasSum, â† coe_finset_sum, tendsto_coe]\n\n"}
{"name":"ENNReal.tsum_coe_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nr : NNReal\nf : Î± â†’ NNReal\nh : HasSum f r\nâŠ¢ Eq (tsum fun a => â†‘(f a)) â†‘r","decl":"protected theorem tsum_coe_eq {f : Î± â†’ â„â‰¥0} (h : HasSum f r) : (âˆ‘' a, (f a : â„â‰¥0âˆ)) = r :=\n  (ENNReal.hasSum_coe.2 h).tsum_eq\n\n"}
{"name":"ENNReal.coe_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ NNReal\naâœ : Summable f\nâŠ¢ Eq (â†‘(tsum f)) (tsum fun a => â†‘(f a))","decl":"protected theorem coe_tsum {f : Î± â†’ â„â‰¥0} : Summable f â†’ â†‘(tsum f) = âˆ‘' a, (f a : â„â‰¥0âˆ)\n  | âŸ¨r, hrâŸ© => by rw [hr.tsum_eq, ENNReal.tsum_coe_eq hr]\n\n"}
{"name":"ENNReal.hasSum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nâŠ¢ HasSum f (iSup fun s => s.sum fun a => f a)","decl":"protected theorem hasSum : HasSum f (â¨† s : Finset Î±, âˆ‘ a âˆˆ s, f a) :=\n  tendsto_atTop_iSup fun _ _ => Finset.sum_le_sum_of_subset\n\n"}
{"name":"ENNReal.summable","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nâŠ¢ Summable f","decl":"@[simp]\nprotected theorem summable : Summable f :=\n  âŸ¨_, ENNReal.hasSumâŸ©\n\n"}
{"name":"ENNReal.tsum_coe_ne_top_iff_summable","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\nf : Î² â†’ NNReal\nâŠ¢ Iff (Ne (tsum fun b => â†‘(f b)) Top.top) (Summable f)","decl":"theorem tsum_coe_ne_top_iff_summable {f : Î² â†’ â„â‰¥0} : (âˆ‘' b, (f b : â„â‰¥0âˆ)) â‰  âˆ â†” Summable f := by\n  refine âŸ¨fun h => ?_, fun h => ENNReal.coe_tsum h â–¸ ENNReal.coe_ne_topâŸ©\n  lift âˆ‘' b, (f b : â„â‰¥0âˆ) to â„â‰¥0 using h with a ha\n  refine âŸ¨a, ENNReal.hasSum_coe.1 ?_âŸ©\n  rw [ha]\n  exact ENNReal.summable.hasSum\n\n"}
{"name":"ENNReal.tsum_eq_iSup_sum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nâŠ¢ Eq (tsum fun a => f a) (iSup fun s => s.sum fun a => f a)","decl":"protected theorem tsum_eq_iSup_sum : âˆ‘' a, f a = â¨† s : Finset Î±, âˆ‘ a âˆˆ s, f a :=\n  ENNReal.hasSum.tsum_eq\n\n"}
{"name":"ENNReal.tsum_eq_iSup_sum'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nÎ¹ : Type u_4\ns : Î¹ â†’ Finset Î±\nhs : âˆ€ (t : Finset Î±), Exists fun i => HasSubset.Subset t (s i)\nâŠ¢ Eq (tsum fun a => f a) (iSup fun i => (s i).sum fun a => f a)","decl":"protected theorem tsum_eq_iSup_sum' {Î¹ : Type*} (s : Î¹ â†’ Finset Î±) (hs : âˆ€ t, âˆƒ i, t âŠ† s i) :\n    âˆ‘' a, f a = â¨† i, âˆ‘ a âˆˆ s i, f a := by\n  rw [ENNReal.tsum_eq_iSup_sum]\n  symm\n  change â¨† i : Î¹, (fun t : Finset Î± => âˆ‘ a âˆˆ t, f a) (s i) = â¨† s : Finset Î±, âˆ‘ a âˆˆ s, f a\n  exact (Finset.sum_mono_set f).iSup_comp_eq hs\n\n"}
{"name":"ENNReal.tsum_sigma","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Î± â†’ Type u_4\nf : (a : Î±) â†’ Î² a â†’ ENNReal\nâŠ¢ Eq (tsum fun p => f p.fst p.snd) (tsum fun a => tsum fun b => f a b)","decl":"protected theorem tsum_sigma {Î² : Î± â†’ Type*} (f : âˆ€ a, Î² a â†’ â„â‰¥0âˆ) :\n    âˆ‘' p : Î£a, Î² a, f p.1 p.2 = âˆ‘' (a) (b), f a b :=\n  tsum_sigma' (fun _ => ENNReal.summable) ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_sigma'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Î± â†’ Type u_4\nf : (Sigma fun a => Î² a) â†’ ENNReal\nâŠ¢ Eq (tsum fun p => f p) (tsum fun a => tsum fun b => f âŸ¨a, bâŸ©)","decl":"protected theorem tsum_sigma' {Î² : Î± â†’ Type*} (f : (Î£a, Î² a) â†’ â„â‰¥0âˆ) :\n    âˆ‘' p : Î£a, Î² a, f p = âˆ‘' (a) (b), f âŸ¨a, bâŸ© :=\n  tsum_sigma' (fun _ => ENNReal.summable) ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_prod","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î² â†’ ENNReal\nâŠ¢ Eq (tsum fun p => f p.1 p.2) (tsum fun a => tsum fun b => f a b)","decl":"protected theorem tsum_prod {f : Î± â†’ Î² â†’ â„â‰¥0âˆ} : âˆ‘' p : Î± Ã— Î², f p.1 p.2 = âˆ‘' (a) (b), f a b :=\n  tsum_prod' ENNReal.summable fun _ => ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_prod'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Prod Î± Î² â†’ ENNReal\nâŠ¢ Eq (tsum fun p => f p) (tsum fun a => tsum fun b => f { fst := a, snd := b })","decl":"protected theorem tsum_prod' {f : Î± Ã— Î² â†’ â„â‰¥0âˆ} : âˆ‘' p : Î± Ã— Î², f p = âˆ‘' (a) (b), f (a, b) :=\n  tsum_prod' ENNReal.summable fun _ => ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_comm","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î² â†’ ENNReal\nâŠ¢ Eq (tsum fun a => tsum fun b => f a b) (tsum fun b => tsum fun a => f a b)","decl":"protected theorem tsum_comm {f : Î± â†’ Î² â†’ â„â‰¥0âˆ} : âˆ‘' a, âˆ‘' b, f a b = âˆ‘' b, âˆ‘' a, f a b :=\n  tsum_comm' ENNReal.summable (fun _ => ENNReal.summable) fun _ => ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_add","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf g : Î± â†’ ENNReal\nâŠ¢ Eq (tsum fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (tsum fun a => f a) (tsum fun a => g a))","decl":"protected theorem tsum_add : âˆ‘' a, (f a + g a) = âˆ‘' a, f a + âˆ‘' a, g a :=\n  tsum_add ENNReal.summable ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf g : Î± â†’ ENNReal\nh : âˆ€ (a : Î±), LE.le (f a) (g a)\nâŠ¢ LE.le (tsum fun a => f a) (tsum fun a => g a)","decl":"protected theorem tsum_le_tsum (h : âˆ€ a, f a â‰¤ g a) : âˆ‘' a, f a â‰¤ âˆ‘' a, g a :=\n  tsum_le_tsum h ENNReal.summable ENNReal.summable\n\n"}
{"name":"GCongr.ennreal_tsum_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf g : Î± â†’ ENNReal\nh : âˆ€ (a : Î±), LE.le (f a) (g a)\nâŠ¢ LE.le (tsum f) (tsum g)","decl":"@[gcongr]\nprotected theorem _root_.GCongr.ennreal_tsum_le_tsum (h : âˆ€ a, f a â‰¤ g a) : tsum f â‰¤ tsum g :=\n  ENNReal.tsum_le_tsum h\n\n"}
{"name":"ENNReal.sum_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\ns : Finset Î±\nâŠ¢ LE.le (s.sum fun x => f x) (tsum fun x => f x)","decl":"protected theorem sum_le_tsum {f : Î± â†’ â„â‰¥0âˆ} (s : Finset Î±) : âˆ‘ x âˆˆ s, f x â‰¤ âˆ‘' x, f x :=\n  sum_le_tsum s (fun _ _ => zero_le _) ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_eq_iSup_nat'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nN : Nat â†’ Nat\nhN : Filter.Tendsto N Filter.atTop Filter.atTop\nâŠ¢ Eq (tsum fun i => f i) (iSup fun i => (Finset.range (N i)).sum fun a => f a)","decl":"protected theorem tsum_eq_iSup_nat' {f : â„• â†’ â„â‰¥0âˆ} {N : â„• â†’ â„•} (hN : Tendsto N atTop atTop) :\n    âˆ‘' i : â„•, f i = â¨† i : â„•, âˆ‘ a âˆˆ Finset.range (N i), f a :=\n  ENNReal.tsum_eq_iSup_sum' _ fun t =>\n    let âŸ¨n, hnâŸ© := t.exists_nat_subset_range\n    let âŸ¨k, _, hkâŸ© := exists_le_of_tendsto_atTop hN 0 n\n    âŸ¨k, Finset.Subset.trans hn (Finset.range_mono hk)âŸ©\n\n"}
{"name":"ENNReal.tsum_eq_iSup_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nâŠ¢ Eq (tsum fun i => f i) (iSup fun i => (Finset.range i).sum fun a => f a)","decl":"protected theorem tsum_eq_iSup_nat {f : â„• â†’ â„â‰¥0âˆ} :\n    âˆ‘' i : â„•, f i = â¨† i : â„•, âˆ‘ a âˆˆ Finset.range i, f a :=\n  ENNReal.tsum_eq_iSup_sum' _ Finset.exists_nat_subset_range\n\n"}
{"name":"ENNReal.tsum_eq_liminf_sum_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nâŠ¢ Eq (tsum fun i => f i) (Filter.liminf (fun n => (Finset.range n).sum fun i => f i) Filter.atTop)","decl":"protected theorem tsum_eq_liminf_sum_nat {f : â„• â†’ â„â‰¥0âˆ} :\n    âˆ‘' i, f i = liminf (fun n => âˆ‘ i âˆˆ Finset.range n, f i) atTop :=\n  ENNReal.summable.hasSum.tendsto_sum_nat.liminf_eq.symm\n\n"}
{"name":"ENNReal.tsum_eq_limsup_sum_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nâŠ¢ Eq (tsum fun i => f i) (Filter.limsup (fun n => (Finset.range n).sum fun i => f i) Filter.atTop)","decl":"protected theorem tsum_eq_limsup_sum_nat {f : â„• â†’ â„â‰¥0âˆ} :\n    âˆ‘' i, f i = limsup (fun n => âˆ‘ i âˆˆ Finset.range n, f i) atTop :=\n  ENNReal.summable.hasSum.tendsto_sum_nat.limsup_eq.symm\n\n"}
{"name":"ENNReal.le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\na : Î±\nâŠ¢ LE.le (f a) (tsum fun a => f a)","decl":"protected theorem le_tsum (a : Î±) : f a â‰¤ âˆ‘' a, f a :=\n  le_tsum' ENNReal.summable a\n\n"}
{"name":"ENNReal.tsum_eq_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nâŠ¢ Iff (Eq (tsum fun i => f i) 0) (âˆ€ (i : Î±), Eq (f i) 0)","decl":"@[simp]\nprotected theorem tsum_eq_zero : âˆ‘' i, f i = 0 â†” âˆ€ i, f i = 0 :=\n  tsum_eq_zero_iff ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_eq_top_of_eq_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\naâœ : Exists fun a => Eq (f a) Top.top\nâŠ¢ Eq (tsum fun a => f a) Top.top","decl":"protected theorem tsum_eq_top_of_eq_top : (âˆƒ a, f a = âˆ) â†’ âˆ‘' a, f a = âˆ\n  | âŸ¨a, haâŸ© => top_unique <| ha â–¸ ENNReal.le_tsum a\n\n"}
{"name":"ENNReal.lt_top_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\na : Î± â†’ ENNReal\ntsum_ne_top : Ne (tsum fun i => a i) Top.top\nj : Î±\nâŠ¢ LT.lt (a j) Top.top","decl":"protected theorem lt_top_of_tsum_ne_top {a : Î± â†’ â„â‰¥0âˆ} (tsum_ne_top : âˆ‘' i, a i â‰  âˆ) (j : Î±) :\n    a j < âˆ := by\n  contrapose! tsum_ne_top with h\n  exact ENNReal.tsum_eq_top_of_eq_top âŸ¨j, top_unique hâŸ©\n\n"}
{"name":"ENNReal.tsum_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : Nonempty Î±\nâŠ¢ Eq (tsum fun x => Top.top) Top.top","decl":"@[simp]\nprotected theorem tsum_top [Nonempty Î±] : âˆ‘' _ : Î±, âˆ = âˆ :=\n  let âŸ¨aâŸ© := â€¹Nonempty Î±â€º\n  ENNReal.tsum_eq_top_of_eq_top âŸ¨a, rflâŸ©\n\n"}
{"name":"ENNReal.tsum_const_eq_top_of_ne_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\ninstâœ : Infinite Î±\nc : ENNReal\nhc : Ne c 0\nâŠ¢ Eq (tsum fun x => c) Top.top","decl":"theorem tsum_const_eq_top_of_ne_zero {Î± : Type*} [Infinite Î±] {c : â„â‰¥0âˆ} (hc : c â‰  0) :\n    âˆ‘' _ : Î±, c = âˆ := by\n  have A : Tendsto (fun n : â„• => (n : â„â‰¥0âˆ) * c) atTop (ğ“ (âˆ * c)) := by\n    apply ENNReal.Tendsto.mul_const tendsto_nat_nhds_top\n    simp only [true_or, top_ne_zero, Ne, not_false_iff]\n  have B : âˆ€ n : â„•, (n : â„â‰¥0âˆ) * c â‰¤ âˆ‘' _ : Î±, c := fun n => by\n    rcases Infinite.exists_subset_card_eq Î± n with âŸ¨s, hsâŸ©\n    simpa [hs] using @ENNReal.sum_le_tsum Î± (fun _ => c) s\n  simpa [hc] using le_of_tendsto' A B\n\n"}
{"name":"ENNReal.ne_top_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nh : Ne (tsum fun a => f a) Top.top\na : Î±\nâŠ¢ Ne (f a) Top.top","decl":"protected theorem ne_top_of_tsum_ne_top (h : âˆ‘' a, f a â‰  âˆ) (a : Î±) : f a â‰  âˆ := fun ha =>\n  h <| ENNReal.tsum_eq_top_of_eq_top âŸ¨a, haâŸ©\n\n"}
{"name":"ENNReal.tsum_mul_left","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\na : ENNReal\nf : Î± â†’ ENNReal\nâŠ¢ Eq (tsum fun i => HMul.hMul a (f i)) (HMul.hMul a (tsum fun i => f i))","decl":"protected theorem tsum_mul_left : âˆ‘' i, a * f i = a * âˆ‘' i, f i := by\n  by_cases hf : âˆ€ i, f i = 0\n  Â· simp [hf]\n  Â· rw [â† ENNReal.tsum_eq_zero] at hf\n    have : Tendsto (fun s : Finset Î± => âˆ‘ j âˆˆ s, a * f j) atTop (ğ“ (a * âˆ‘' i, f i)) := by\n      simp only [â† Finset.mul_sum]\n      exact ENNReal.Tendsto.const_mul ENNReal.summable.hasSum (Or.inl hf)\n    exact HasSum.tsum_eq this\n\n"}
{"name":"ENNReal.tsum_mul_right","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\na : ENNReal\nf : Î± â†’ ENNReal\nâŠ¢ Eq (tsum fun i => HMul.hMul (f i) a) (HMul.hMul (tsum fun i => f i) a)","decl":"protected theorem tsum_mul_right : âˆ‘' i, f i * a = (âˆ‘' i, f i) * a := by\n  simp [mul_comm, ENNReal.tsum_mul_left]\n\n"}
{"name":"ENNReal.tsum_const_smul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nR : Type u_4\ninstâœÂ¹ : SMul R ENNReal\ninstâœ : IsScalarTower R ENNReal ENNReal\na : R\nâŠ¢ Eq (tsum fun i => HSMul.hSMul a (f i)) (HSMul.hSMul a (tsum fun i => f i))","decl":"protected theorem tsum_const_smul {R} [SMul R â„â‰¥0âˆ] [IsScalarTower R â„â‰¥0âˆ â„â‰¥0âˆ] (a : R) :\n    âˆ‘' i, a â€¢ f i = a â€¢ âˆ‘' i, f i := by\n  simpa only [smul_one_mul] using @ENNReal.tsum_mul_left _ (a â€¢ (1 : â„â‰¥0âˆ)) _\n\n"}
{"name":"ENNReal.tsum_iSup_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\na : Î±\nf : Î± â†’ ENNReal\nâŠ¢ Eq (tsum fun b => iSup fun x => f b) (f a)","decl":"@[simp]\ntheorem tsum_iSup_eq {Î± : Type*} (a : Î±) {f : Î± â†’ â„â‰¥0âˆ} : (âˆ‘' b : Î±, â¨† _ : a = b, f b) = f a :=\n  (tsum_eq_single a fun _ h => by simp [h.symm]).trans <| by simp\n\n"}
{"name":"ENNReal.hasSum_iff_tendsto_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nr : ENNReal\nâŠ¢ Iff (HasSum f r) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds r))","decl":"theorem hasSum_iff_tendsto_nat {f : â„• â†’ â„â‰¥0âˆ} (r : â„â‰¥0âˆ) :\n    HasSum f r â†” Tendsto (fun n : â„• => âˆ‘ i âˆˆ Finset.range n, f i) atTop (ğ“ r) := by\n  refine âŸ¨HasSum.tendsto_sum_nat, fun h => ?_âŸ©\n  rw [â† iSup_eq_of_tendsto _ h, â† ENNReal.tsum_eq_iSup_nat]\n  Â· exact ENNReal.summable.hasSum\n  Â· exact fun s t hst => Finset.sum_le_sum_of_subset (Finset.range_subset.2 hst)\n\n"}
{"name":"ENNReal.tendsto_nat_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nâŠ¢ Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds (tsum fun n => f n))","decl":"theorem tendsto_nat_tsum (f : â„• â†’ â„â‰¥0âˆ) :\n    Tendsto (fun n : â„• => âˆ‘ i âˆˆ Finset.range n, f i) atTop (ğ“ (âˆ‘' n, f n)) := by\n  rw [â† hasSum_iff_tendsto_nat]\n  exact ENNReal.summable.hasSum\n\n"}
{"name":"ENNReal.toNNReal_apply_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\nf : Î± â†’ ENNReal\nhf : Ne (tsum fun i => f i) Top.top\nx : Î±\nâŠ¢ Eq (â†‘(Function.comp ENNReal.toNNReal f x)) (f x)","decl":"theorem toNNReal_apply_of_tsum_ne_top {Î± : Type*} {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ‘' i, f i â‰  âˆ) (x : Î±) :\n    (((ENNReal.toNNReal âˆ˜ f) x : â„â‰¥0) : â„â‰¥0âˆ) = f x :=\n  coe_toNNReal <| ENNReal.ne_top_of_tsum_ne_top hf _\n\n"}
{"name":"ENNReal.summable_toNNReal_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\nf : Î± â†’ ENNReal\nhf : Ne (tsum fun i => f i) Top.top\nâŠ¢ Summable (Function.comp ENNReal.toNNReal f)","decl":"theorem summable_toNNReal_of_tsum_ne_top {Î± : Type*} {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ‘' i, f i â‰  âˆ) :\n    Summable (ENNReal.toNNReal âˆ˜ f) := by\n  simpa only [â† tsum_coe_ne_top_iff_summable, toNNReal_apply_of_tsum_ne_top hf] using hf\n\n"}
{"name":"ENNReal.tendsto_cofinite_zero_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\nf : Î± â†’ ENNReal\nhf : Ne (tsum fun x => f x) Top.top\nâŠ¢ Filter.Tendsto f Filter.cofinite (nhds 0)","decl":"theorem tendsto_cofinite_zero_of_tsum_ne_top {Î±} {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ‘' x, f x â‰  âˆ) :\n    Tendsto f cofinite (ğ“ 0) := by\n  have f_ne_top : âˆ€ n, f n â‰  âˆ := ENNReal.ne_top_of_tsum_ne_top hf\n  have h_f_coe : f = fun n => ((f n).toNNReal : ENNReal) :=\n    funext fun n => (coe_toNNReal (f_ne_top n)).symm\n  rw [h_f_coe, â† @coe_zero, tendsto_coe]\n  exact NNReal.tendsto_cofinite_zero_of_summable (summable_toNNReal_of_tsum_ne_top hf)\n\n"}
{"name":"ENNReal.tendsto_atTop_zero_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nhf : Ne (tsum fun x => f x) Top.top\nâŠ¢ Filter.Tendsto f Filter.atTop (nhds 0)","decl":"theorem tendsto_atTop_zero_of_tsum_ne_top {f : â„• â†’ â„â‰¥0âˆ} (hf : âˆ‘' x, f x â‰  âˆ) :\n    Tendsto f atTop (ğ“ 0) := by\n  rw [â† Nat.cofinite_eq_atTop]\n  exact tendsto_cofinite_zero_of_tsum_ne_top hf\n\n"}
{"name":"ENNReal.tendsto_tsum_compl_atTop_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\nf : Î± â†’ ENNReal\nhf : Ne (tsum fun x => f x) Top.top\nâŠ¢ Filter.Tendsto (fun s => tsum fun b => f â†‘b) Filter.atTop (nhds 0)","decl":"/-- The sum over the complement of a finset tends to `0` when the finset grows to cover the whole\nspace. This does not need a summability assumption, as otherwise all sums are zero. -/\ntheorem tendsto_tsum_compl_atTop_zero {Î± : Type*} {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ‘' x, f x â‰  âˆ) :\n    Tendsto (fun s : Finset Î± => âˆ‘' b : { x // x âˆ‰ s }, f b) atTop (ğ“ 0) := by\n  lift f to Î± â†’ â„â‰¥0 using ENNReal.ne_top_of_tsum_ne_top hf\n  convert ENNReal.tendsto_coe.2 (NNReal.tendsto_tsum_compl_atTop_zero f)\n  rw [ENNReal.coe_tsum]\n  exact NNReal.summable_comp_injective (tsum_coe_ne_top_iff_summable.1 hf) Subtype.coe_injective\n\n"}
{"name":"ENNReal.tsum_apply","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nÎ± : Type u_5\nf : Î¹ â†’ Î± â†’ ENNReal\nx : Î±\nâŠ¢ Eq (tsum (fun i => f i) x) (tsum fun i => f i x)","decl":"protected theorem tsum_apply {Î¹ Î± : Type*} {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {x : Î±} :\n    (âˆ‘' i, f i) x = âˆ‘' i, f i x :=\n  tsum_apply <| Pi.summable.mpr fun _ => ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f g : Nat â†’ ENNReal\nhâ‚ : Ne (tsum fun i => g i) Top.top\nhâ‚‚ : LE.le g f\nâŠ¢ Eq (tsum fun i => HSub.hSub (f i) (g i)) (HSub.hSub (tsum fun i => f i) (tsum fun i => g i))","decl":"theorem tsum_sub {f : â„• â†’ â„â‰¥0âˆ} {g : â„• â†’ â„â‰¥0âˆ} (hâ‚ : âˆ‘' i, g i â‰  âˆ) (hâ‚‚ : g â‰¤ f) :\n    âˆ‘' i, (f i - g i) = âˆ‘' i, f i - âˆ‘' i, g i :=\n  have : âˆ€ i, f i - g i + g i = f i := fun i => tsub_add_cancel_of_le (hâ‚‚ i)\n  ENNReal.eq_sub_of_add_eq hâ‚ <| by simp only [â† ENNReal.tsum_add, this]\n\n"}
{"name":"ENNReal.tsum_comp_le_tsum_of_injective","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Injective f\ng : Î² â†’ ENNReal\nâŠ¢ LE.le (tsum fun x => g (f x)) (tsum fun y => g y)","decl":"theorem tsum_comp_le_tsum_of_injective {f : Î± â†’ Î²} (hf : Injective f) (g : Î² â†’ â„â‰¥0âˆ) :\n    âˆ‘' x, g (f x) â‰¤ âˆ‘' y, g y :=\n  tsum_le_tsum_of_inj f hf (fun _ _ => zero_le _) (fun _ => le_rfl) ENNReal.summable\n    ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_le_tsum_comp_of_surjective","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Î± â†’ Î²\nhf : Function.Surjective f\ng : Î² â†’ ENNReal\nâŠ¢ LE.le (tsum fun y => g y) (tsum fun x => g (f x))","decl":"theorem tsum_le_tsum_comp_of_surjective {f : Î± â†’ Î²} (hf : Surjective f) (g : Î² â†’ â„â‰¥0âˆ) :\n    âˆ‘' y, g y â‰¤ âˆ‘' x, g (f x) :=\n  calc âˆ‘' y, g y = âˆ‘' y, g (f (surjInv hf y)) := by simp only [surjInv_eq hf]\n  _ â‰¤ âˆ‘' x, g (f x) := tsum_comp_le_tsum_of_injective (injective_surjInv hf) _\n\n"}
{"name":"ENNReal.tsum_mono_subtype","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\ns t : Set Î±\nh : HasSubset.Subset s t\nâŠ¢ LE.le (tsum fun x => f â†‘x) (tsum fun x => f â†‘x)","decl":"theorem tsum_mono_subtype (f : Î± â†’ â„â‰¥0âˆ) {s t : Set Î±} (h : s âŠ† t) :\n    âˆ‘' x : s, f x â‰¤ âˆ‘' x : t, f x :=\n  tsum_comp_le_tsum_of_injective (inclusion_injective h) _\n\n"}
{"name":"ENNReal.tsum_iUnion_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nf : Î± â†’ ENNReal\nt : Î¹ â†’ Set Î±\nâŠ¢ LE.le (tsum fun x => f â†‘x) (tsum fun i => tsum fun x => f â†‘x)","decl":"theorem tsum_iUnion_le_tsum {Î¹ : Type*} (f : Î± â†’ â„â‰¥0âˆ) (t : Î¹ â†’ Set Î±) :\n    âˆ‘' x : â‹ƒ i, t i, f x â‰¤ âˆ‘' i, âˆ‘' x : t i, f x :=\n  calc âˆ‘' x : â‹ƒ i, t i, f x â‰¤ âˆ‘' x : Î£ i, t i, f x.2 :=\n    tsum_le_tsum_comp_of_surjective (sigmaToiUnion_surjective t) _\n  _ = âˆ‘' i, âˆ‘' x : t i, f x := ENNReal.tsum_sigma' _\n\n"}
{"name":"ENNReal.tsum_biUnion_le_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nf : Î± â†’ ENNReal\ns : Set Î¹\nt : Î¹ â†’ Set Î±\nâŠ¢ LE.le (tsum fun x => f â†‘x) (tsum fun i => tsum fun x => f â†‘x)","decl":"theorem tsum_biUnion_le_tsum {Î¹ : Type*} (f : Î± â†’ â„â‰¥0âˆ) (s : Set Î¹) (t : Î¹ â†’ Set Î±) :\n    âˆ‘' x : â‹ƒ i âˆˆ s , t i, f x â‰¤ âˆ‘' i : s, âˆ‘' x : t i, f x :=\n  calc âˆ‘' x : â‹ƒ i âˆˆ s, t i, f x = âˆ‘' x : â‹ƒ i : s, t i, f x := tsum_congr_set_coe _ <| by simp\n  _ â‰¤ âˆ‘' i : s, âˆ‘' x : t i, f x := tsum_iUnion_le_tsum _ _\n\n"}
{"name":"ENNReal.tsum_biUnion_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\nf : Î± â†’ ENNReal\ns : Finset Î¹\nt : Î¹ â†’ Set Î±\nâŠ¢ LE.le (tsum fun x => f â†‘x) (s.sum fun i => tsum fun x => f â†‘x)","decl":"theorem tsum_biUnion_le {Î¹ : Type*} (f : Î± â†’ â„â‰¥0âˆ) (s : Finset Î¹) (t : Î¹ â†’ Set Î±) :\n    âˆ‘' x : â‹ƒ i âˆˆ s, t i, f x â‰¤ âˆ‘ i âˆˆ s, âˆ‘' x : t i, f x :=\n  (tsum_biUnion_le_tsum f s.toSet t).trans_eq (Finset.tsum_subtype s fun i => âˆ‘' x : t i, f x)\n\n"}
{"name":"ENNReal.tsum_iUnion_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_4\ninstâœ : Fintype Î¹\nf : Î± â†’ ENNReal\nt : Î¹ â†’ Set Î±\nâŠ¢ LE.le (tsum fun x => f â†‘x) (Finset.univ.sum fun i => tsum fun x => f â†‘x)","decl":"theorem tsum_iUnion_le {Î¹ : Type*} [Fintype Î¹] (f : Î± â†’ â„â‰¥0âˆ) (t : Î¹ â†’ Set Î±) :\n    âˆ‘' x : â‹ƒ i, t i, f x â‰¤ âˆ‘ i, âˆ‘' x : t i, f x := by\n  rw [â† tsum_fintype]\n  exact tsum_iUnion_le_tsum f t\n\n"}
{"name":"ENNReal.tsum_union_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\ns t : Set Î±\nâŠ¢ LE.le (tsum fun x => f â†‘x) (HAdd.hAdd (tsum fun x => f â†‘x) (tsum fun x => f â†‘x))","decl":"theorem tsum_union_le (f : Î± â†’ â„â‰¥0âˆ) (s t : Set Î±) :\n    âˆ‘' x : â†‘(s âˆª t), f x â‰¤ âˆ‘' x : s, f x + âˆ‘' x : t, f x :=\n  calc âˆ‘' x : â†‘(s âˆª t), f x = âˆ‘' x : â‹ƒ b, cond b s t, f x := tsum_congr_set_coe _ union_eq_iUnion\n  _ â‰¤ _ := by simpa using tsum_iUnion_le f (cond Â· s t)\n\n"}
{"name":"ENNReal.tsum_eq_add_tsum_ite","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\nf : Î² â†’ ENNReal\nb : Î²\nâŠ¢ Eq (tsum fun x => f x) (HAdd.hAdd (f b) (tsum fun x => ite (Eq x b) 0 (f x)))","decl":"open Classical in\ntheorem tsum_eq_add_tsum_ite {f : Î² â†’ â„â‰¥0âˆ} (b : Î²) :\n    âˆ‘' x, f x = f b + âˆ‘' x, ite (x = b) 0 (f x) :=\n  tsum_eq_add_tsum_ite' b ENNReal.summable\n\n"}
{"name":"ENNReal.tsum_add_one_eq_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nhf : Eq (tsum fun n => f n) Top.top\nhf0 : Ne (f 0) Top.top\nâŠ¢ Eq (tsum fun n => f (HAdd.hAdd n 1)) Top.top","decl":"theorem tsum_add_one_eq_top {f : â„• â†’ â„â‰¥0âˆ} (hf : âˆ‘' n, f n = âˆ) (hf0 : f 0 â‰  âˆ) :\n    âˆ‘' n, f (n + 1) = âˆ := by\n  rw [tsum_eq_zero_add' ENNReal.summable, add_eq_top] at hf\n  exact hf.resolve_left hf0\n\n"}
{"name":"ENNReal.finite_const_le_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\na : Î¹ â†’ ENNReal\ntsum_ne_top : Ne (tsum fun i => a i) Top.top\nÎµ : ENNReal\nÎµ_ne_zero : Ne Îµ 0\nâŠ¢ (setOf fun i => LE.le Îµ (a i)).Finite","decl":"/-- A sum of extended nonnegative reals which is finite can have only finitely many terms\nabove any positive threshold. -/\ntheorem finite_const_le_of_tsum_ne_top {Î¹ : Type*} {a : Î¹ â†’ â„â‰¥0âˆ} (tsum_ne_top : âˆ‘' i, a i â‰  âˆ)\n    {Îµ : â„â‰¥0âˆ} (Îµ_ne_zero : Îµ â‰  0) : { i : Î¹ | Îµ â‰¤ a i }.Finite := by\n  by_contra h\n  have := Infinite.to_subtype h\n  refine tsum_ne_top (top_unique ?_)\n  calc âˆ = âˆ‘' _ : { i | Îµ â‰¤ a i }, Îµ := (tsum_const_eq_top_of_ne_zero Îµ_ne_zero).symm\n  _ â‰¤ âˆ‘' i, a i := tsum_le_tsum_of_inj (â†‘) Subtype.val_injective (fun _ _ => zero_le _)\n    (fun i => i.2) ENNReal.summable ENNReal.summable\n\n"}
{"name":"ENNReal.finset_card_const_le_le_of_tsum_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\na : Î¹ â†’ ENNReal\nc : ENNReal\nc_ne_top : Ne c Top.top\ntsum_le_c : LE.le (tsum fun i => a i) c\nÎµ : ENNReal\nÎµ_ne_zero : Ne Îµ 0\nâŠ¢ Exists fun hf => LE.le (â†‘hf.toFinset.card) (HDiv.hDiv c Îµ)","decl":"/-- Markov's inequality for `Finset.card` and `tsum` in `â„â‰¥0âˆ`. -/\ntheorem finset_card_const_le_le_of_tsum_le {Î¹ : Type*} {a : Î¹ â†’ â„â‰¥0âˆ} {c : â„â‰¥0âˆ} (c_ne_top : c â‰  âˆ)\n    (tsum_le_c : âˆ‘' i, a i â‰¤ c) {Îµ : â„â‰¥0âˆ} (Îµ_ne_zero : Îµ â‰  0) :\n    âˆƒ hf : { i : Î¹ | Îµ â‰¤ a i }.Finite, #hf.toFinset â‰¤ c / Îµ := by\n  have hf : { i : Î¹ | Îµ â‰¤ a i }.Finite :=\n    finite_const_le_of_tsum_ne_top (ne_top_of_le_ne_top c_ne_top tsum_le_c) Îµ_ne_zero\n  refine âŸ¨hf, (ENNReal.le_div_iff_mul_le (.inl Îµ_ne_zero) (.inr c_ne_top)).2 ?_âŸ©\n  calc #hf.toFinset * Îµ = âˆ‘ _i âˆˆ hf.toFinset, Îµ := by rw [Finset.sum_const, nsmul_eq_mul]\n    _ â‰¤ âˆ‘ i âˆˆ hf.toFinset, a i := Finset.sum_le_sum fun i => hf.mem_toFinset.1\n    _ â‰¤ âˆ‘' i, a i := ENNReal.sum_le_tsum _\n    _ â‰¤ c := tsum_le_c\n\n"}
{"name":"ENNReal.tsum_fiberwise","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\nÎ³ : Type u_3\nf : Î² â†’ ENNReal\ng : Î² â†’ Î³\nâŠ¢ Eq (tsum fun x => tsum fun b => f â†‘b) (tsum fun i => f i)","decl":"theorem tsum_fiberwise (f : Î² â†’ â„â‰¥0âˆ) (g : Î² â†’ Î³) :\n    âˆ‘' x, âˆ‘' b : g â»Â¹' {x}, f b = âˆ‘' i, f i := by\n  apply HasSum.tsum_eq\n  let equiv := Equiv.sigmaFiberEquiv g\n  apply (equiv.hasSum_iff.mpr ENNReal.summable.hasSum).sigma\n  exact fun _ â†¦ ENNReal.summable.hasSum_iff.mpr rfl\n\n"}
{"name":"ENNReal.tendsto_toReal_iff","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nfi : Filter Î¹\nf : Î¹ â†’ ENNReal\nhf : âˆ€ (i : Î¹), Ne (f i) Top.top\nx : ENNReal\nhx : Ne x Top.top\nâŠ¢ Iff (Filter.Tendsto (fun n => (f n).toReal) fi (nhds x.toReal)) (Filter.Tendsto f fi (nhds x))","decl":"theorem tendsto_toReal_iff {Î¹} {fi : Filter Î¹} {f : Î¹ â†’ â„â‰¥0âˆ} (hf : âˆ€ i, f i â‰  âˆ) {x : â„â‰¥0âˆ}\n    (hx : x â‰  âˆ) : Tendsto (fun n => (f n).toReal) fi (ğ“ x.toReal) â†” Tendsto f fi (ğ“ x) := by\n  lift f to Î¹ â†’ â„â‰¥0 using hf\n  lift x to â„â‰¥0 using hx\n  simp [tendsto_coe]\n\n"}
{"name":"ENNReal.tsum_coe_ne_top_iff_summable_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ NNReal\nâŠ¢ Iff (Ne (tsum fun a => â†‘(f a)) Top.top) (Summable fun a => â†‘(f a))","decl":"theorem tsum_coe_ne_top_iff_summable_coe {f : Î± â†’ â„â‰¥0} :\n    (âˆ‘' a, (f a : â„â‰¥0âˆ)) â‰  âˆ â†” Summable fun a => (f a : â„) := by\n  rw [NNReal.summable_coe]\n  exact tsum_coe_ne_top_iff_summable\n\n"}
{"name":"ENNReal.tsum_coe_eq_top_iff_not_summable_coe","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ NNReal\nâŠ¢ Iff (Eq (tsum fun a => â†‘(f a)) Top.top) (Not (Summable fun a => â†‘(f a)))","decl":"theorem tsum_coe_eq_top_iff_not_summable_coe {f : Î± â†’ â„â‰¥0} :\n    (âˆ‘' a, (f a : â„â‰¥0âˆ)) = âˆ â†” Â¬Summable fun a => (f a : â„) :=\n  tsum_coe_ne_top_iff_summable_coe.not_right\n\n"}
{"name":"ENNReal.hasSum_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nhsum : Ne (tsum fun x => f x) Top.top\nâŠ¢ HasSum (fun x => (f x).toReal) (tsum fun x => (f x).toReal)","decl":"theorem hasSum_toReal {f : Î± â†’ â„â‰¥0âˆ} (hsum : âˆ‘' x, f x â‰  âˆ) :\n    HasSum (fun x => (f x).toReal) (âˆ‘' x, (f x).toReal) := by\n  lift f to Î± â†’ â„â‰¥0 using ENNReal.ne_top_of_tsum_ne_top hsum\n  simp only [coe_toReal, â† NNReal.coe_tsum, NNReal.hasSum_coe]\n  exact (tsum_coe_ne_top_iff_summable.1 hsum).hasSum\n\n"}
{"name":"ENNReal.summable_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nhsum : Ne (tsum fun x => f x) Top.top\nâŠ¢ Summable fun x => (f x).toReal","decl":"theorem summable_toReal {f : Î± â†’ â„â‰¥0âˆ} (hsum : âˆ‘' x, f x â‰  âˆ) : Summable fun x => (f x).toReal :=\n  (hasSum_toReal hsum).summable\n\n"}
{"name":"NNReal.tsum_eq_toNNReal_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\nf : Î² â†’ NNReal\nâŠ¢ Eq (tsum fun b => f b) (tsum fun b => â†‘(f b)).toNNReal","decl":"theorem tsum_eq_toNNReal_tsum {f : Î² â†’ â„â‰¥0} : âˆ‘' b, f b = (âˆ‘' b, (f b : â„â‰¥0âˆ)).toNNReal := by\n  by_cases h : Summable f\n  Â· rw [â† ENNReal.coe_tsum h, ENNReal.toNNReal_coe]\n  Â· have A := tsum_eq_zero_of_not_summable h\n    simp only [â† ENNReal.tsum_coe_ne_top_iff_summable, Classical.not_not] at h\n    simp only [h, ENNReal.top_toNNReal, A]\n\n"}
{"name":"NNReal.exists_le_hasSum_of_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\nf g : Î² â†’ NNReal\nr : NNReal\nhgf : âˆ€ (b : Î²), LE.le (g b) (f b)\nhfr : HasSum f r\nâŠ¢ Exists fun p => And (LE.le p r) (HasSum g p)","decl":"/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem exists_le_hasSum_of_le {f g : Î² â†’ â„â‰¥0} {r : â„â‰¥0} (hgf : âˆ€ b, g b â‰¤ f b) (hfr : HasSum f r) :\n    âˆƒ p â‰¤ r, HasSum g p :=\n  have : (âˆ‘' b, (g b : â„â‰¥0âˆ)) â‰¤ r := by\n    refine hasSum_le (fun b => ?_) ENNReal.summable.hasSum (ENNReal.hasSum_coe.2 hfr)\n    exact ENNReal.coe_le_coe.2 (hgf _)\n  let âŸ¨p, Eq, hprâŸ© := ENNReal.le_coe_iff.1 this\n  âŸ¨p, hpr, ENNReal.hasSum_coe.1 <| Eq â–¸ ENNReal.summable.hasSumâŸ©\n\n"}
{"name":"NNReal.summable_of_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\nf g : Î² â†’ NNReal\nhgf : âˆ€ (b : Î²), LE.le (g b) (f b)\naâœ : Summable f\nâŠ¢ Summable g","decl":"/-- Comparison test of convergence of `â„â‰¥0`-valued series. -/\ntheorem summable_of_le {f g : Î² â†’ â„â‰¥0} (hgf : âˆ€ b, g b â‰¤ f b) : Summable f â†’ Summable g\n  | âŸ¨_r, hfrâŸ© =>\n    let âŸ¨_p, _, hpâŸ© := exists_le_hasSum_of_le hgf hfr\n    hp.summable\n\n"}
{"name":"Summable.countable_support_nnreal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ NNReal\nh : Summable f\nâŠ¢ (Function.support f).Countable","decl":"/-- Summable non-negative functions have countable support -/\ntheorem _root_.Summable.countable_support_nnreal (f : Î± â†’ â„â‰¥0) (h : Summable f) :\n    f.support.Countable := by\n  rw [â† NNReal.summable_coe] at h\n  simpa [support] using h.countable_support\n\n"}
{"name":"NNReal.hasSum_iff_tendsto_nat","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ NNReal\nr : NNReal\nâŠ¢ Iff (HasSum f r) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds r))","decl":"/-- A series of non-negative real numbers converges to `r` in the sense of `HasSum` if and only if\nthe sequence of partial sum converges to `r`. -/\ntheorem hasSum_iff_tendsto_nat {f : â„• â†’ â„â‰¥0} {r : â„â‰¥0} :\n    HasSum f r â†” Tendsto (fun n : â„• => âˆ‘ i âˆˆ Finset.range n, f i) atTop (ğ“ r) := by\n  rw [â† ENNReal.hasSum_coe, ENNReal.hasSum_iff_tendsto_nat]\n  simp only [â† ENNReal.coe_finset_sum]\n  exact ENNReal.tendsto_coe\n\n"}
{"name":"NNReal.not_summable_iff_tendsto_nat_atTop","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ NNReal\nâŠ¢ Iff (Not (Summable f)) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop Filter.atTop)","decl":"theorem not_summable_iff_tendsto_nat_atTop {f : â„• â†’ â„â‰¥0} :\n    Â¬Summable f â†” Tendsto (fun n : â„• => âˆ‘ i âˆˆ Finset.range n, f i) atTop atTop := by\n  constructor\n  Â· intro h\n    refine ((tendsto_of_monotone ?_).resolve_right h).comp ?_\n    exacts [Finset.sum_mono_set _, tendsto_finset_range]\n  Â· rintro hnat âŸ¨r, hrâŸ©\n    exact not_tendsto_nhds_of_tendsto_atTop hnat _ (hasSum_iff_tendsto_nat.1 hr)\n\n"}
{"name":"NNReal.summable_iff_not_tendsto_nat_atTop","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ NNReal\nâŠ¢ Iff (Summable f) (Not (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop Filter.atTop))","decl":"theorem summable_iff_not_tendsto_nat_atTop {f : â„• â†’ â„â‰¥0} :\n    Summable f â†” Â¬Tendsto (fun n : â„• => âˆ‘ i âˆˆ Finset.range n, f i) atTop atTop := by\n  rw [â† not_iff_not, Classical.not_not, not_summable_iff_tendsto_nat_atTop]\n\n"}
{"name":"NNReal.summable_of_sum_range_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ NNReal\nc : NNReal\nh : âˆ€ (n : Nat), LE.le ((Finset.range n).sum fun i => f i) c\nâŠ¢ Summable f","decl":"theorem summable_of_sum_range_le {f : â„• â†’ â„â‰¥0} {c : â„â‰¥0}\n    (h : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, f i â‰¤ c) : Summable f := by\n  refine summable_iff_not_tendsto_nat_atTop.2 fun H => ?_\n  rcases exists_lt_of_tendsto_atTop H 0 c with âŸ¨n, -, hnâŸ©\n  exact lt_irrefl _ (hn.trans_le (h n))\n\n"}
{"name":"NNReal.tsum_le_of_sum_range_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ NNReal\nc : NNReal\nh : âˆ€ (n : Nat), LE.le ((Finset.range n).sum fun i => f i) c\nâŠ¢ LE.le (tsum fun n => f n) c","decl":"theorem tsum_le_of_sum_range_le {f : â„• â†’ â„â‰¥0} {c : â„â‰¥0}\n    (h : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, f i â‰¤ c) : âˆ‘' n, f n â‰¤ c :=\n  _root_.tsum_le_of_sum_range_le (summable_of_sum_range_le h) h\n\n"}
{"name":"NNReal.tsum_comp_le_tsum_of_inj","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_4\nf : Î± â†’ NNReal\nhf : Summable f\ni : Î² â†’ Î±\nhi : Function.Injective i\nâŠ¢ LE.le (tsum fun x => f (i x)) (tsum fun x => f x)","decl":"theorem tsum_comp_le_tsum_of_inj {Î² : Type*} {f : Î± â†’ â„â‰¥0} (hf : Summable f) {i : Î² â†’ Î±}\n    (hi : Function.Injective i) : (âˆ‘' x, f (i x)) â‰¤ âˆ‘' x, f x :=\n  tsum_le_tsum_of_inj i hi (fun _ _ => zero_le _) (fun _ => le_rfl) (summable_comp_injective hf hi)\n    hf\n\n"}
{"name":"NNReal.summable_sigma","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Î± â†’ Type u_4\nf : (Sigma fun x => Î² x) â†’ NNReal\nâŠ¢ Iff (Summable f) (And (âˆ€ (x : Î±), Summable fun y => f âŸ¨x, yâŸ©) (Summable fun x => tsum fun y => f âŸ¨x, yâŸ©))","decl":"theorem summable_sigma {Î² : Î± â†’ Type*} {f : (Î£ x, Î² x) â†’ â„â‰¥0} :\n    Summable f â†” (âˆ€ x, Summable fun y => f âŸ¨x, yâŸ©) âˆ§ Summable fun x => âˆ‘' y, f âŸ¨x, yâŸ© := by\n  constructor\n  Â· simp only [â† NNReal.summable_coe, NNReal.coe_tsum]\n    exact fun h => âŸ¨h.sigma_factor, h.sigmaâŸ©\n  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n    simpa only [â† ENNReal.tsum_coe_ne_top_iff_summable, ENNReal.tsum_sigma',\n      ENNReal.coe_tsum (hâ‚ _)] using hâ‚‚\n\n"}
{"name":"NNReal.indicator_summable","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ NNReal\nhf : Summable f\ns : Set Î±\nâŠ¢ Summable (s.indicator f)","decl":"theorem indicator_summable {f : Î± â†’ â„â‰¥0} (hf : Summable f) (s : Set Î±) :\n    Summable (s.indicator f) := by\n  classical\n  refine NNReal.summable_of_le (fun a => le_trans (le_of_eq (s.indicator_apply f a)) ?_) hf\n  split_ifs\n  Â· exact le_refl (f a)\n  Â· exact zero_le_coe\n\n"}
{"name":"NNReal.tsum_indicator_ne_zero","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ NNReal\nhf : Summable f\ns : Set Î±\nh : Exists fun a => And (Membership.mem s a) (Ne (f a) 0)\nâŠ¢ Ne (tsum fun x => s.indicator f x) 0","decl":"theorem tsum_indicator_ne_zero {f : Î± â†’ â„â‰¥0} (hf : Summable f) {s : Set Î±} (h : âˆƒ a âˆˆ s, f a â‰  0) :\n    (âˆ‘' x, (s.indicator f) x) â‰  0 := fun h' =>\n  let âŸ¨a, ha, hapâŸ© := h\n  hap ((Set.indicator_apply_eq_self.mpr (absurd ha)).symm.trans\n    ((tsum_eq_zero_iff (indicator_summable hf s)).1 h' a))\n\n"}
{"name":"NNReal.tendsto_sum_nat_add","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ NNReal\nâŠ¢ Filter.Tendsto (fun i => tsum fun k => f (HAdd.hAdd k i)) Filter.atTop (nhds 0)","decl":"/-- For `f : â„• â†’ â„â‰¥0`, then `âˆ‘' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. -/\ntheorem tendsto_sum_nat_add (f : â„• â†’ â„â‰¥0) : Tendsto (fun i => âˆ‘' k, f (k + i)) atTop (ğ“ 0) := by\n  rw [â† tendsto_coe]\n  convert _root_.tendsto_sum_nat_add fun i => (f i : â„)\n  norm_cast\n\n"}
{"name":"NNReal.hasSum_lt","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf g : Î± â†’ NNReal\nsf sg : NNReal\ni : Î±\nh : âˆ€ (a : Î±), LE.le (f a) (g a)\nhi : LT.lt (f i) (g i)\nhf : HasSum f sf\nhg : HasSum g sg\nâŠ¢ LT.lt sf sg","decl":"nonrec theorem hasSum_lt {f g : Î± â†’ â„â‰¥0} {sf sg : â„â‰¥0} {i : Î±} (h : âˆ€ a : Î±, f a â‰¤ g a)\n    (hi : f i < g i) (hf : HasSum f sf) (hg : HasSum g sg) : sf < sg := by\n  have A : âˆ€ a : Î±, (f a : â„) â‰¤ g a := fun a => NNReal.coe_le_coe.2 (h a)\n  have : (sf : â„) < sg := hasSum_lt A (NNReal.coe_lt_coe.2 hi) (hasSum_coe.2 hf) (hasSum_coe.2 hg)\n  exact NNReal.coe_lt_coe.1 this\n\n"}
{"name":"NNReal.hasSum_strict_mono","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf g : Î± â†’ NNReal\nsf sg : NNReal\nhf : HasSum f sf\nhg : HasSum g sg\nh : LT.lt f g\nâŠ¢ LT.lt sf sg","decl":"@[mono]\ntheorem hasSum_strict_mono {f g : Î± â†’ â„â‰¥0} {sf sg : â„â‰¥0} (hf : HasSum f sf) (hg : HasSum g sg)\n    (h : f < g) : sf < sg :=\n  let âŸ¨hle, _i, hiâŸ© := Pi.lt_def.mp h\n  hasSum_lt hle hi hf hg\n\n"}
{"name":"NNReal.tsum_lt_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf g : Î± â†’ NNReal\ni : Î±\nh : âˆ€ (a : Î±), LE.le (f a) (g a)\nhi : LT.lt (f i) (g i)\nhg : Summable g\nâŠ¢ LT.lt (tsum fun n => f n) (tsum fun n => g n)","decl":"theorem tsum_lt_tsum {f g : Î± â†’ â„â‰¥0} {i : Î±} (h : âˆ€ a : Î±, f a â‰¤ g a) (hi : f i < g i)\n    (hg : Summable g) : âˆ‘' n, f n < âˆ‘' n, g n :=\n  hasSum_lt h hi (summable_of_le h hg).hasSum hg.hasSum\n\n"}
{"name":"NNReal.tsum_strict_mono","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf g : Î± â†’ NNReal\nhg : Summable g\nh : LT.lt f g\nâŠ¢ LT.lt (tsum fun n => f n) (tsum fun n => g n)","decl":"@[mono]\ntheorem tsum_strict_mono {f g : Î± â†’ â„â‰¥0} (hg : Summable g) (h : f < g) : âˆ‘' n, f n < âˆ‘' n, g n :=\n  let âŸ¨hle, _i, hiâŸ© := Pi.lt_def.mp h\n  tsum_lt_tsum hle hi hg\n\n"}
{"name":"NNReal.tsum_pos","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ng : Î± â†’ NNReal\nhg : Summable g\ni : Î±\nhi : LT.lt 0 (g i)\nâŠ¢ LT.lt 0 (tsum fun b => g b)","decl":"theorem tsum_pos {g : Î± â†’ â„â‰¥0} (hg : Summable g) (i : Î±) (hi : 0 < g i) : 0 < âˆ‘' b, g b := by\n  rw [â† tsum_zero]\n  exact tsum_lt_tsum (fun a => zero_le _) hi hg\n\n"}
{"name":"NNReal.tsum_eq_add_tsum_ite","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ NNReal\nhf : Summable f\ni : Î±\nâŠ¢ Eq (tsum fun x => f x) (HAdd.hAdd (f i) (tsum fun x => ite (Eq x i) 0 (f x)))","decl":"open Classical in\ntheorem tsum_eq_add_tsum_ite {f : Î± â†’ â„â‰¥0} (hf : Summable f) (i : Î±) :\n    âˆ‘' x, f x = f i + âˆ‘' x, ite (x = i) 0 (f x) := by\n  refine tsum_eq_add_tsum_ite' i (NNReal.summable_of_le (fun i' => ?_) hf)\n  rw [Function.update_apply]\n  split_ifs <;> simp only [zero_le', le_rfl]\n\n"}
{"name":"ENNReal.tsum_toNNReal_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nhf : âˆ€ (a : Î±), Ne (f a) Top.top\nâŠ¢ Eq (tsum fun a => f a).toNNReal (tsum fun a => (f a).toNNReal)","decl":"theorem tsum_toNNReal_eq {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ a, f a â‰  âˆ) :\n    (âˆ‘' a, f a).toNNReal = âˆ‘' a, (f a).toNNReal :=\n  (congr_arg ENNReal.toNNReal (tsum_congr fun x => (coe_toNNReal (hf x)).symm)).trans\n    NNReal.tsum_eq_toNNReal_tsum.symm\n\n"}
{"name":"ENNReal.tsum_toReal_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nhf : âˆ€ (a : Î±), Ne (f a) Top.top\nâŠ¢ Eq (tsum fun a => f a).toReal (tsum fun a => (f a).toReal)","decl":"theorem tsum_toReal_eq {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ a, f a â‰  âˆ) :\n    (âˆ‘' a, f a).toReal = âˆ‘' a, (f a).toReal := by\n  simp only [ENNReal.toReal, tsum_toNNReal_eq hf, NNReal.coe_tsum]\n\n"}
{"name":"ENNReal.tendsto_sum_nat_add","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nhf : Ne (tsum fun i => f i) Top.top\nâŠ¢ Filter.Tendsto (fun i => tsum fun k => f (HAdd.hAdd k i)) Filter.atTop (nhds 0)","decl":"theorem tendsto_sum_nat_add (f : â„• â†’ â„â‰¥0âˆ) (hf : âˆ‘' i, f i â‰  âˆ) :\n    Tendsto (fun i => âˆ‘' k, f (k + i)) atTop (ğ“ 0) := by\n  lift f to â„• â†’ â„â‰¥0 using ENNReal.ne_top_of_tsum_ne_top hf\n  replace hf : Summable f := tsum_coe_ne_top_iff_summable.1 hf\n  simp only [â† ENNReal.coe_tsum, NNReal.summable_nat_add _ hf, â† ENNReal.coe_zero]\n  exact mod_cast NNReal.tendsto_sum_nat_add f\n\n"}
{"name":"ENNReal.tsum_le_of_sum_range_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ ENNReal\nc : ENNReal\nh : âˆ€ (n : Nat), LE.le ((Finset.range n).sum fun i => f i) c\nâŠ¢ LE.le (tsum fun n => f n) c","decl":"theorem tsum_le_of_sum_range_le {f : â„• â†’ â„â‰¥0âˆ} {c : â„â‰¥0âˆ}\n    (h : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, f i â‰¤ c) : âˆ‘' n, f n â‰¤ c :=\n  _root_.tsum_le_of_sum_range_le ENNReal.summable h\n\n"}
{"name":"ENNReal.hasSum_lt","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf g : Î± â†’ ENNReal\nsf sg : ENNReal\ni : Î±\nh : âˆ€ (a : Î±), LE.le (f a) (g a)\nhi : LT.lt (f i) (g i)\nhsf : Ne sf Top.top\nhf : HasSum f sf\nhg : HasSum g sg\nâŠ¢ LT.lt sf sg","decl":"theorem hasSum_lt {f g : Î± â†’ â„â‰¥0âˆ} {sf sg : â„â‰¥0âˆ} {i : Î±} (h : âˆ€ a : Î±, f a â‰¤ g a) (hi : f i < g i)\n    (hsf : sf â‰  âˆ) (hf : HasSum f sf) (hg : HasSum g sg) : sf < sg := by\n  by_cases hsg : sg = âˆ\n  Â· exact hsg.symm â–¸ lt_of_le_of_ne le_top hsf\n  Â· have hg' : âˆ€ x, g x â‰  âˆ := ENNReal.ne_top_of_tsum_ne_top (hg.tsum_eq.symm â–¸ hsg)\n    lift f to Î± â†’ â„â‰¥0 using fun x =>\n      ne_of_lt (lt_of_le_of_lt (h x) <| lt_of_le_of_ne le_top (hg' x))\n    lift g to Î± â†’ â„â‰¥0 using hg'\n    lift sf to â„â‰¥0 using hsf\n    lift sg to â„â‰¥0 using hsg\n    simp only [coe_le_coe, coe_lt_coe] at h hi âŠ¢\n    exact NNReal.hasSum_lt h hi (ENNReal.hasSum_coe.1 hf) (ENNReal.hasSum_coe.1 hg)\n\n"}
{"name":"ENNReal.tsum_lt_tsum","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf g : Î± â†’ ENNReal\ni : Î±\nhfi : Ne (tsum f) Top.top\nh : âˆ€ (a : Î±), LE.le (f a) (g a)\nhi : LT.lt (f i) (g i)\nâŠ¢ LT.lt (tsum fun x => f x) (tsum fun x => g x)","decl":"theorem tsum_lt_tsum {f g : Î± â†’ â„â‰¥0âˆ} {i : Î±} (hfi : tsum f â‰  âˆ) (h : âˆ€ a : Î±, f a â‰¤ g a)\n    (hi : f i < g i) : âˆ‘' x, f x < âˆ‘' x, g x :=\n  hasSum_lt h hi hfi ENNReal.summable.hasSum ENNReal.summable.hasSum\n\n"}
{"name":"tsum_comp_le_tsum_of_inj","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_4\nf : Î± â†’ Real\nhf : Summable f\nhn : âˆ€ (a : Î±), LE.le 0 (f a)\ni : Î² â†’ Î±\nhi : Function.Injective i\nâŠ¢ LE.le (tsum (Function.comp f i)) (tsum f)","decl":"theorem tsum_comp_le_tsum_of_inj {Î² : Type*} {f : Î± â†’ â„} (hf : Summable f) (hn : âˆ€ a, 0 â‰¤ f a)\n    {i : Î² â†’ Î±} (hi : Function.Injective i) : tsum (f âˆ˜ i) â‰¤ tsum f := by\n  lift f to Î± â†’ â„â‰¥0 using hn\n  rw [NNReal.summable_coe] at hf\n  simpa only [Function.comp_def, â† NNReal.coe_tsum] using NNReal.tsum_comp_le_tsum_of_inj hf hi\n\n"}
{"name":"Summable.of_nonneg_of_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\nf g : Î² â†’ Real\nhg : âˆ€ (b : Î²), LE.le 0 (g b)\nhgf : âˆ€ (b : Î²), LE.le (g b) (f b)\nhf : Summable f\nâŠ¢ Summable g","decl":"/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem Summable.of_nonneg_of_le {f g : Î² â†’ â„} (hg : âˆ€ b, 0 â‰¤ g b) (hgf : âˆ€ b, g b â‰¤ f b)\n    (hf : Summable f) : Summable g := by\n  lift f to Î² â†’ â„â‰¥0 using fun b => (hg b).trans (hgf b)\n  lift g to Î² â†’ â„â‰¥0 using hg\n  rw [NNReal.summable_coe] at hf âŠ¢\n  exact NNReal.summable_of_le (fun b => NNReal.coe_le_coe.1 (hgf b)) hf\n\n"}
{"name":"Summable.toNNReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\nhf : Summable f\nâŠ¢ Summable fun n => (f n).toNNReal","decl":"theorem Summable.toNNReal {f : Î± â†’ â„} (hf : Summable f) : Summable fun n => (f n).toNNReal := by\n  apply NNReal.summable_coe.1\n  refine .of_nonneg_of_le (fun n => NNReal.coe_nonneg _) (fun n => ?_) hf.abs\n  simp only [le_abs_self, Real.coe_toNNReal', max_le_iff, abs_nonneg, and_self_iff]\n\n"}
{"name":"Summable.countable_support_ennreal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ ENNReal\nh : Ne (tsum fun i => f i) Top.top\nâŠ¢ (Function.support f).Countable","decl":"/-- Finitely summable non-negative functions have countable support -/\ntheorem _root_.Summable.countable_support_ennreal {f : Î± â†’ â„â‰¥0âˆ} (h : âˆ‘' (i : Î±), f i â‰  âˆ) :\n    f.support.Countable := by\n  lift f to Î± â†’ â„â‰¥0 using ENNReal.ne_top_of_tsum_ne_top h\n  simpa [support] using (ENNReal.tsum_coe_ne_top_iff_summable.1 h).countable_support_nnreal\n\n"}
{"name":"hasSum_iff_tendsto_nat_of_nonneg","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"f : Nat â†’ Real\nhf : âˆ€ (i : Nat), LE.le 0 (f i)\nr : Real\nâŠ¢ Iff (HasSum f r) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds r))","decl":"/-- A series of non-negative real numbers converges to `r` in the sense of `HasSum` if and only if\nthe sequence of partial sum converges to `r`. -/\ntheorem hasSum_iff_tendsto_nat_of_nonneg {f : â„• â†’ â„} (hf : âˆ€ i, 0 â‰¤ f i) (r : â„) :\n    HasSum f r â†” Tendsto (fun n : â„• => âˆ‘ i âˆˆ Finset.range n, f i) atTop (ğ“ r) := by\n  lift f to â„• â†’ â„â‰¥0 using hf\n  simp only [HasSum, â† NNReal.coe_sum, NNReal.tendsto_coe']\n  exact exists_congr fun hr => NNReal.hasSum_iff_tendsto_nat\n\n"}
{"name":"ENNReal.ofReal_tsum_of_nonneg","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nf : Î± â†’ Real\nhf_nonneg : âˆ€ (n : Î±), LE.le 0 (f n)\nhf : Summable f\nâŠ¢ Eq (ENNReal.ofReal (tsum fun n => f n)) (tsum fun n => ENNReal.ofReal (f n))","decl":"theorem ENNReal.ofReal_tsum_of_nonneg {f : Î± â†’ â„} (hf_nonneg : âˆ€ n, 0 â‰¤ f n) (hf : Summable f) :\n    ENNReal.ofReal (âˆ‘' n, f n) = âˆ‘' n, ENNReal.ofReal (f n) := by\n  simp_rw [ENNReal.ofReal, ENNReal.tsum_coe_eq (NNReal.hasSum_real_toNNReal_of_nonneg hf_nonneg hf)]\n\n"}
{"name":"edist_ne_top_of_mem_ball","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\ninstâœ : EMetricSpace Î²\na : Î²\nr : ENNReal\nx y : â†‘(EMetric.ball a r)\nâŠ¢ Ne (EDist.edist â†‘x â†‘y) Top.top","decl":"/-- In an emetric ball, the distance between points is everywhere finite -/\ntheorem edist_ne_top_of_mem_ball {a : Î²} {r : â„â‰¥0âˆ} (x y : ball a r) : edist x.1 y.1 â‰  âˆ :=\n  ne_of_lt <|\n    calc\n      edist x y â‰¤ edist a x + edist a y := edist_triangle_left x.1 y.1 a\n      _ < r + r := by rw [edist_comm a x, edist_comm a y]; exact ENNReal.add_lt_add x.2 y.2\n      _ â‰¤ âˆ := le_top\n\n"}
{"name":"nhds_eq_nhds_emetric_ball","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î² : Type u_2\ninstâœ : EMetricSpace Î²\na x : Î²\nr : ENNReal\nh : Membership.mem (EMetric.ball a r) x\nâŠ¢ Eq (nhds x) (Filter.map Subtype.val (nhds âŸ¨x, hâŸ©))","decl":"theorem nhds_eq_nhds_emetric_ball (a x : Î²) (r : â„â‰¥0âˆ) (h : x âˆˆ ball a r) :\n    ğ“ x = map ((â†‘) : ball a r â†’ Î²) (ğ“ âŸ¨x, hâŸ©) :=\n  (map_nhds_subtype_coe_eq_nhds _ <| IsOpen.mem_nhds EMetric.isOpen_ball h).symm\n\n"}
{"name":"tendsto_iff_edist_tendsto_0","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : PseudoEMetricSpace Î±\nl : Filter Î²\nf : Î² â†’ Î±\ny : Î±\nâŠ¢ Iff (Filter.Tendsto f l (nhds y)) (Filter.Tendsto (fun x => EDist.edist (f x) y) l (nhds 0))","decl":"theorem tendsto_iff_edist_tendsto_0 {l : Filter Î²} {f : Î² â†’ Î±} {y : Î±} :\n    Tendsto f l (ğ“ y) â†” Tendsto (fun x => edist (f x) y) l (ğ“ 0) := by\n  simp only [EMetric.nhds_basis_eball.tendsto_right_iff, EMetric.mem_ball,\n    @tendsto_order â„â‰¥0âˆ Î² _ _, forall_prop_of_false ENNReal.not_lt_zero, forall_const, true_and]\n\n"}
{"name":"EMetric.cauchySeq_iff_le_tendsto_0","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : Nonempty Î²\ninstâœ : SemilatticeSup Î²\ns : Î² â†’ Î±\nâŠ¢ Iff (CauchySeq s) (Exists fun b => And (âˆ€ (n m N : Î²), LE.le N n â†’ LE.le N m â†’ LE.le (EDist.edist (s n) (s m)) (b N)) (Filter.Tendsto b Filter.atTop (nhds 0)))","decl":"/-- Yet another metric characterization of Cauchy sequences on integers. This one is often the\nmost efficient. -/\ntheorem EMetric.cauchySeq_iff_le_tendsto_0 [Nonempty Î²] [SemilatticeSup Î²] {s : Î² â†’ Î±} :\n    CauchySeq s â†” âˆƒ b : Î² â†’ â„â‰¥0âˆ, (âˆ€ n m N : Î², N â‰¤ n â†’ N â‰¤ m â†’ edist (s n) (s m) â‰¤ b N) âˆ§\n      Tendsto b atTop (ğ“ 0) := EMetric.cauchySeq_iff.trans <| by\n  constructor\n  Â· intro hs\n    /- `s` is Cauchy sequence. Let `b n` be the diameter of the set `s '' Set.Ici n`. -/\n    refine âŸ¨fun N => EMetric.diam (s '' Ici N), fun n m N hn hm => ?_, ?_âŸ©\n    -- Prove that it bounds the distances of points in the Cauchy sequence\n    Â· exact EMetric.edist_le_diam_of_mem (mem_image_of_mem _ hn) (mem_image_of_mem _ hm)\n    -- Prove that it tends to `0`, by using the Cauchy property of `s`\n    Â· refine ENNReal.tendsto_nhds_zero.2 fun Îµ Îµ0 => ?_\n      rcases hs Îµ Îµ0 with âŸ¨N, hNâŸ©\n      refine (eventually_ge_atTop N).mono fun n hn => EMetric.diam_le ?_\n      rintro _ âŸ¨k, hk, rflâŸ© _ âŸ¨l, hl, rflâŸ©\n      exact (hN _ (hn.trans hk) _ (hn.trans hl)).le\n  Â· rintro âŸ¨b, âŸ¨b_bound, b_limâŸ©âŸ© Îµ Îµpos\n    have : âˆ€á¶  n in atTop, b n < Îµ := b_lim.eventually (gt_mem_nhds Îµpos)\n    rcases this.exists with âŸ¨N, hNâŸ©\n    refine âŸ¨N, fun m hm n hn => ?_âŸ©\n    calc edist (s m) (s n) â‰¤ b N := b_bound m n N hm hn\n    _ < Îµ := hN\n\n"}
{"name":"continuous_of_le_add_edist","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf : Î± â†’ ENNReal\nC : ENNReal\nhC : Ne C Top.top\nh : âˆ€ (x y : Î±), LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul C (EDist.edist x y)))\nâŠ¢ Continuous f","decl":"theorem continuous_of_le_add_edist {f : Î± â†’ â„â‰¥0âˆ} (C : â„â‰¥0âˆ) (hC : C â‰  âˆ)\n    (h : âˆ€ x y, f x â‰¤ f y + C * edist x y) : Continuous f := by\n  refine continuous_iff_continuousAt.2 fun x => ENNReal.tendsto_nhds_of_Icc fun Îµ Îµ0 => ?_\n  rcases ENNReal.exists_nnreal_pos_mul_lt hC Îµ0.ne' with âŸ¨Î´, Î´0, hÎ´âŸ©\n  rw [mul_comm] at hÎ´\n  filter_upwards [EMetric.closedBall_mem_nhds x (ENNReal.coe_pos.2 Î´0)] with y hy\n  refine âŸ¨tsub_le_iff_right.2 <| (h x y).trans ?_, (h y x).trans ?_âŸ© <;>\n    refine add_le_add_left (le_trans (mul_le_mul_left' ?_ _) hÎ´.le) _\n  exacts [EMetric.mem_closedBall'.1 hy, EMetric.mem_closedBall.1 hy]\n\n"}
{"name":"continuous_edist","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nâŠ¢ Continuous fun p => EDist.edist p.1 p.2","decl":"theorem continuous_edist : Continuous fun p : Î± Ã— Î± => edist p.1 p.2 := by\n  apply continuous_of_le_add_edist 2 (by decide)\n  rintro âŸ¨x, yâŸ© âŸ¨x', y'âŸ©\n  calc\n    edist x y â‰¤ edist x x' + edist x' y' + edist y' y := edist_triangle4 _ _ _ _\n    _ = edist x' y' + (edist x x' + edist y y') := by simp only [edist_comm]; ac_rfl\n    _ â‰¤ edist x' y' + (edist (x, y) (x', y') + edist (x, y) (x', y')) :=\n      (add_le_add_left (add_le_add (le_max_left _ _) (le_max_right _ _)) _)\n    _ = edist x' y' + 2 * edist (x, y) (x', y') := by rw [â† mul_two, mul_comm]\n\n"}
{"name":"Continuous.edist","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : TopologicalSpace Î²\nf g : Î² â†’ Î±\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun b => EDist.edist (f b) (g b)","decl":"@[continuity, fun_prop]\ntheorem Continuous.edist [TopologicalSpace Î²] {f g : Î² â†’ Î±} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun b => edist (f b) (g b) :=\n  continuous_edist.comp (hf.prod_mk hg :)\n\n"}
{"name":"Filter.Tendsto.edist","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : PseudoEMetricSpace Î±\nf g : Î² â†’ Î±\nx : Filter Î²\na b : Î±\nhf : Filter.Tendsto f x (nhds a)\nhg : Filter.Tendsto g x (nhds b)\nâŠ¢ Filter.Tendsto (fun x => EDist.edist (f x) (g x)) x (nhds (EDist.edist a b))","decl":"theorem Filter.Tendsto.edist {f g : Î² â†’ Î±} {x : Filter Î²} {a b : Î±} (hf : Tendsto f x (ğ“ a))\n    (hg : Tendsto g x (ğ“ b)) : Tendsto (fun x => edist (f x) (g x)) x (ğ“ (edist a b)) :=\n  (continuous_edist.tendsto (a, b)).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"cauchySeq_of_edist_le_of_summable","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf : Nat â†’ Î±\nd : Nat â†’ NNReal\nhf : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f n.succ)) â†‘(d n)\nhd : Summable d\nâŠ¢ CauchySeq f","decl":"/-- If the extended distance between consecutive points of a sequence is estimated\nby a summable series of `NNReal`s, then the original sequence is a Cauchy sequence. -/\ntheorem cauchySeq_of_edist_le_of_summable {f : â„• â†’ Î±} (d : â„• â†’ â„â‰¥0)\n    (hf : âˆ€ n, edist (f n) (f n.succ) â‰¤ d n) (hd : Summable d) : CauchySeq f := by\n  refine EMetric.cauchySeq_iff_NNReal.2 fun Îµ Îµpos â†¦ ?_\n  -- Actually we need partial sums of `d` to be a Cauchy sequence.\n  replace hd : CauchySeq fun n : â„• â†¦ âˆ‘ x âˆˆ Finset.range n, d x :=\n    let âŸ¨_, HâŸ© := hd\n    H.tendsto_sum_nat.cauchySeq\n  -- Now we take the same `N` as in one of the definitions of a Cauchy sequence.\n  refine (Metric.cauchySeq_iff'.1 hd Îµ (NNReal.coe_pos.2 Îµpos)).imp fun N hN n hn â†¦ ?_\n  specialize hN n hn\n  -- We simplify the known inequality.\n  rw [dist_nndist, NNReal.nndist_eq, â† Finset.sum_range_add_sum_Ico _ hn, add_tsub_cancel_left,\n    NNReal.coe_lt_coe, max_lt_iff] at hN\n  rw [edist_comm]\n  -- Then use `hf` to simplify the goal to the same form.\n  refine lt_of_le_of_lt (edist_le_Ico_sum_of_edist_le hn fun _ _ â†¦ hf _) ?_\n  exact mod_cast hN.1\n\n"}
{"name":"cauchySeq_of_edist_le_of_tsum_ne_top","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf : Nat â†’ Î±\nd : Nat â†’ ENNReal\nhf : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f n.succ)) (d n)\nhd : Ne (tsum d) Top.top\nâŠ¢ CauchySeq f","decl":"theorem cauchySeq_of_edist_le_of_tsum_ne_top {f : â„• â†’ Î±} (d : â„• â†’ â„â‰¥0âˆ)\n    (hf : âˆ€ n, edist (f n) (f n.succ) â‰¤ d n) (hd : tsum d â‰  âˆ) : CauchySeq f := by\n  lift d to â„• â†’ NNReal using fun i => ENNReal.ne_top_of_tsum_ne_top hd i\n  rw [ENNReal.tsum_coe_ne_top_iff_summable] at hd\n  exact cauchySeq_of_edist_le_of_summable d hf hd\n\n"}
{"name":"EMetric.isClosed_ball","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\na : Î±\nr : ENNReal\nâŠ¢ IsClosed (EMetric.closedBall a r)","decl":"theorem EMetric.isClosed_ball {a : Î±} {r : â„â‰¥0âˆ} : IsClosed (closedBall a r) :=\n  isClosed_le (continuous_id.edist continuous_const) continuous_const\n\n"}
{"name":"EMetric.diam_closure","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\ns : Set Î±\nâŠ¢ Eq (EMetric.diam (closure s)) (EMetric.diam s)","decl":"@[simp]\ntheorem EMetric.diam_closure (s : Set Î±) : diam (closure s) = diam s := by\n  refine le_antisymm (diam_le fun x hx y hy => ?_) (diam_mono subset_closure)\n  have : edist x y âˆˆ closure (Iic (diam s)) :=\n    map_mem_closureâ‚‚ continuous_edist hx hy fun x hx y hy => edist_le_diam_of_mem hx hy\n  rwa [closure_Iic] at this\n\n"}
{"name":"Metric.diam_closure","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\ninstâœ : PseudoMetricSpace Î±\ns : Set Î±\nâŠ¢ Eq (Metric.diam (closure s)) (Metric.diam s)","decl":"@[simp]\ntheorem Metric.diam_closure {Î± : Type*} [PseudoMetricSpace Î±] (s : Set Î±) :\n    Metric.diam (closure s) = diam s := by simp only [Metric.diam, EMetric.diam_closure]\n\n"}
{"name":"isClosed_setOf_lipschitzOnWith","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\nÎ² : Type u_5\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nK : NNReal\ns : Set Î±\nâŠ¢ IsClosed (setOf fun f => LipschitzOnWith K f s)","decl":"theorem isClosed_setOf_lipschitzOnWith {Î± Î²} [PseudoEMetricSpace Î±] [PseudoEMetricSpace Î²] (K : â„â‰¥0)\n    (s : Set Î±) : IsClosed { f : Î± â†’ Î² | LipschitzOnWith K f s } := by\n  simp only [LipschitzOnWith, setOf_forall]\n  refine isClosed_biInter fun x _ => isClosed_biInter fun y _ => isClosed_le ?_ ?_\n  exacts [.edist (continuous_apply x) (continuous_apply y), continuous_const]\n\n"}
{"name":"isClosed_setOf_lipschitzWith","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_4\nÎ² : Type u_5\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nK : NNReal\nâŠ¢ IsClosed (setOf fun f => LipschitzWith K f)","decl":"theorem isClosed_setOf_lipschitzWith {Î± Î²} [PseudoEMetricSpace Î±] [PseudoEMetricSpace Î²] (K : â„â‰¥0) :\n    IsClosed { f : Î± â†’ Î² | LipschitzWith K f } := by\n  simp only [â† lipschitzOnWith_univ, isClosed_setOf_lipschitzOnWith]\n\n"}
{"name":"Real.ediam_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"s : Set Real\nh : Bornology.IsBounded s\nâŠ¢ Eq (EMetric.diam s) (ENNReal.ofReal (HSub.hSub (SupSet.sSup s) (InfSet.sInf s)))","decl":"/-- For a bounded set `s : Set â„`, its `EMetric.diam` is equal to `sSup s - sInf s` reinterpreted as\n`â„â‰¥0âˆ`. -/\ntheorem ediam_eq {s : Set â„} (h : Bornology.IsBounded s) :\n    EMetric.diam s = ENNReal.ofReal (sSup s - sInf s) := by\n  rcases eq_empty_or_nonempty s with (rfl | hne)\n  Â· simp\n  refine le_antisymm (Metric.ediam_le_of_forall_dist_le fun x hx y hy => ?_) ?_\n  Â· exact Real.dist_le_of_mem_Icc (h.subset_Icc_sInf_sSup hx) (h.subset_Icc_sInf_sSup hy)\n  Â· apply ENNReal.ofReal_le_of_le_toReal\n    rw [â† Metric.diam, â† Metric.diam_closure]\n    calc sSup s - sInf s â‰¤ dist (sSup s) (sInf s) := le_abs_self _\n    _ â‰¤ Metric.diam (closure s) := dist_le_diam_of_mem h.closure (csSup_mem_closure hne h.bddAbove)\n        (csInf_mem_closure hne h.bddBelow)\n\n"}
{"name":"Real.diam_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"s : Set Real\nh : Bornology.IsBounded s\nâŠ¢ Eq (Metric.diam s) (HSub.hSub (SupSet.sSup s) (InfSet.sInf s))","decl":"/-- For a bounded set `s : Set â„`, its `Metric.diam` is equal to `sSup s - sInf s`. -/\ntheorem diam_eq {s : Set â„} (h : Bornology.IsBounded s) : Metric.diam s = sSup s - sInf s := by\n  rw [Metric.diam, Real.ediam_eq h, ENNReal.toReal_ofReal]\n  exact sub_nonneg.2 (Real.sInf_le_sSup s h.bddBelow h.bddAbove)\n\n"}
{"name":"Real.ediam_Ioo","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nâŠ¢ Eq (EMetric.diam (Set.Ioo a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem ediam_Ioo (a b : â„) : EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a) := by\n  rcases le_or_lt b a with (h | h)\n  Â· simp [h]\n  Â· rw [Real.ediam_eq (isBounded_Ioo _ _), csSup_Ioo h, csInf_Ioo h]\n\n"}
{"name":"Real.ediam_Icc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nâŠ¢ Eq (EMetric.diam (Set.Icc a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem ediam_Icc (a b : â„) : EMetric.diam (Icc a b) = ENNReal.ofReal (b - a) := by\n  rcases le_or_lt a b with (h | h)\n  Â· rw [Real.ediam_eq (isBounded_Icc _ _), csSup_Icc h, csInf_Icc h]\n  Â· simp [h, h.le]\n\n"}
{"name":"Real.ediam_Ico","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nâŠ¢ Eq (EMetric.diam (Set.Ico a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem ediam_Ico (a b : â„) : EMetric.diam (Ico a b) = ENNReal.ofReal (b - a) :=\n  le_antisymm (ediam_Icc a b â–¸ diam_mono Ico_subset_Icc_self)\n    (ediam_Ioo a b â–¸ diam_mono Ioo_subset_Ico_self)\n\n"}
{"name":"Real.ediam_Ioc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nâŠ¢ Eq (EMetric.diam (Set.Ioc a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem ediam_Ioc (a b : â„) : EMetric.diam (Ioc a b) = ENNReal.ofReal (b - a) :=\n  le_antisymm (ediam_Icc a b â–¸ diam_mono Ioc_subset_Icc_self)\n    (ediam_Ioo a b â–¸ diam_mono Ioo_subset_Ioc_self)\n\n"}
{"name":"Real.diam_Icc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nh : LE.le a b\nâŠ¢ Eq (Metric.diam (Set.Icc a b)) (HSub.hSub b a)","decl":"theorem diam_Icc {a b : â„} (h : a â‰¤ b) : Metric.diam (Icc a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n\n"}
{"name":"Real.diam_Ico","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nh : LE.le a b\nâŠ¢ Eq (Metric.diam (Set.Ico a b)) (HSub.hSub b a)","decl":"theorem diam_Ico {a b : â„} (h : a â‰¤ b) : Metric.diam (Ico a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n\n"}
{"name":"Real.diam_Ioc","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nh : LE.le a b\nâŠ¢ Eq (Metric.diam (Set.Ioc a b)) (HSub.hSub b a)","decl":"theorem diam_Ioc {a b : â„} (h : a â‰¤ b) : Metric.diam (Ioc a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n\n"}
{"name":"Real.diam_Ioo","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"a b : Real\nh : LE.le a b\nâŠ¢ Eq (Metric.diam (Set.Ioo a b)) (HSub.hSub b a)","decl":"theorem diam_Ioo {a b : â„} (h : a â‰¤ b) : Metric.diam (Ioo a b) = b - a := by\n  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]\n\n"}
{"name":"edist_le_tsum_of_edist_le_of_tendsto","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf : Nat â†’ Î±\nd : Nat â†’ ENNReal\nhf : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f n.succ)) (d n)\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nn : Nat\nâŠ¢ LE.le (EDist.edist (f n) a) (tsum fun m => d (HAdd.hAdd n m))","decl":"/-- If `edist (f n) (f (n+1))` is bounded above by a function `d : â„• â†’ â„â‰¥0âˆ`,\nthen the distance from `f n` to the limit is bounded by `âˆ‘'_{k=n}^âˆ d k`. -/\ntheorem edist_le_tsum_of_edist_le_of_tendsto {f : â„• â†’ Î±} (d : â„• â†’ â„â‰¥0âˆ)\n    (hf : âˆ€ n, edist (f n) (f n.succ) â‰¤ d n) {a : Î±} (ha : Tendsto f atTop (ğ“ a)) (n : â„•) :\n    edist (f n) a â‰¤ âˆ‘' m, d (n + m) := by\n  refine le_of_tendsto (tendsto_const_nhds.edist ha) (mem_atTop_sets.2 âŸ¨n, fun m hnm => ?_âŸ©)\n  change edist _ _ â‰¤ _\n  refine le_trans (edist_le_Ico_sum_of_edist_le hnm fun _ _ => hf _) ?_\n  rw [Finset.sum_Ico_eq_sum_range]\n  exact sum_le_tsum _ (fun _ _ => zero_le _) ENNReal.summable\n\n"}
{"name":"edist_le_tsum_of_edist_le_of_tendstoâ‚€","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_1\ninstâœ : PseudoEMetricSpace Î±\nf : Nat â†’ Î±\nd : Nat â†’ ENNReal\nhf : âˆ€ (n : Nat), LE.le (EDist.edist (f n) (f n.succ)) (d n)\na : Î±\nha : Filter.Tendsto f Filter.atTop (nhds a)\nâŠ¢ LE.le (EDist.edist (f 0) a) (tsum fun m => d m)","decl":"/-- If `edist (f n) (f (n+1))` is bounded above by a function `d : â„• â†’ â„â‰¥0âˆ`,\nthen the distance from `f 0` to the limit is bounded by `âˆ‘'_{k=0}^âˆ d k`. -/\ntheorem edist_le_tsum_of_edist_le_of_tendstoâ‚€ {f : â„• â†’ Î±} (d : â„• â†’ â„â‰¥0âˆ)\n    (hf : âˆ€ n, edist (f n) (f n.succ) â‰¤ d n) {a : Î±} (ha : Tendsto f atTop (ğ“ a)) :\n    edist (f 0) a â‰¤ âˆ‘' m, d m := by simpa using edist_le_tsum_of_edist_le_of_tendsto d hf ha 0\n\n"}
{"name":"ENNReal.truncateToReal_eq_toReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t x : ENNReal\nt_ne_top : Ne t Top.top\nx_le : LE.le x t\nâŠ¢ Eq (t.truncateToReal x) x.toReal","decl":"lemma truncateToReal_eq_toReal {t x : â„â‰¥0âˆ} (t_ne_top : t â‰  âˆ) (x_le : x â‰¤ t) :\n    truncateToReal t x = x.toReal := by\n  have x_lt_top : x < âˆ := lt_of_le_of_lt x_le t_ne_top.lt_top\n  have obs : min t x â‰  âˆ := by\n    simp_all only [ne_eq, min_eq_top, false_and, not_false_eq_true]\n  exact (ENNReal.toReal_eq_toReal obs x_lt_top.ne).mpr (min_eq_right x_le)\n\n"}
{"name":"ENNReal.truncateToReal_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t : ENNReal\nt_ne_top : Ne t Top.top\nx : ENNReal\nâŠ¢ LE.le (t.truncateToReal x) t.toReal","decl":"lemma truncateToReal_le {t : â„â‰¥0âˆ} (t_ne_top : t â‰  âˆ) {x : â„â‰¥0âˆ} :\n    truncateToReal t x â‰¤ t.toReal := by\n  rw [truncateToReal]\n  gcongr\n  exacts [t_ne_top, min_le_left t x]\n\n"}
{"name":"ENNReal.truncateToReal_nonneg","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t x : ENNReal\nâŠ¢ LE.le 0 (t.truncateToReal x)","decl":"lemma truncateToReal_nonneg {t x : â„â‰¥0âˆ} : 0 â‰¤ truncateToReal t x := toReal_nonneg\n\n"}
{"name":"ENNReal.monotone_truncateToReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t : ENNReal\nt_ne_top : Ne t Top.top\nâŠ¢ Monotone t.truncateToReal","decl":"/-- The truncated cast `ENNReal.truncateToReal t : â„â‰¥0âˆ â†’ â„` is monotone when `t â‰  âˆ`. -/\nlemma monotone_truncateToReal {t : â„â‰¥0âˆ} (t_ne_top : t â‰  âˆ) : Monotone (truncateToReal t) := by\n  intro x y x_le_y\n  simp only [truncateToReal]\n  gcongr\n  exact ne_top_of_le_ne_top t_ne_top (min_le_left _ _)\n\n"}
{"name":"ENNReal.continuous_truncateToReal","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"t : ENNReal\nt_ne_top : Ne t Top.top\nâŠ¢ Continuous t.truncateToReal","decl":"/-- The truncated cast `ENNReal.truncateToReal t : â„â‰¥0âˆ â†’ â„` is continuous when `t â‰  âˆ`. -/\nlemma continuous_truncateToReal {t : â„â‰¥0âˆ} (t_ne_top : t â‰  âˆ) : Continuous (truncateToReal t) := by\n  apply continuousOn_toReal.comp_continuous (continuous_min.comp (Continuous.Prod.mk t))\n  simp [t_ne_top]\n\n"}
{"name":"ENNReal.limsup_sub_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nF : Filter Î¹\nf : Î¹ â†’ ENNReal\nc : ENNReal\nâŠ¢ Eq (Filter.limsup (fun i => HSub.hSub (f i) c) F) (HSub.hSub (Filter.limsup f F) c)","decl":"lemma limsup_sub_const (F : Filter Î¹) (f : Î¹ â†’ â„â‰¥0âˆ) (c : â„â‰¥0âˆ) :\n    Filter.limsup (fun i â†¦ f i - c) F = Filter.limsup f F - c := by\n  rcases F.eq_or_neBot with rfl | _\n  Â· simp only [limsup_bot, bot_eq_zero', zero_le, tsub_eq_zero_of_le]\n  Â· exact (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : â„â‰¥0âˆ) â†¦ x - c)\n    (fun _ _ h â†¦ tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt).symm\n\n"}
{"name":"ENNReal.liminf_sub_const","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nF : Filter Î¹\ninstâœ : F.NeBot\nf : Î¹ â†’ ENNReal\nc : ENNReal\nâŠ¢ Eq (Filter.liminf (fun i => HSub.hSub (f i) c) F) (HSub.hSub (Filter.liminf f F) c)","decl":"lemma liminf_sub_const (F : Filter Î¹) [NeBot F] (f : Î¹ â†’ â„â‰¥0âˆ) (c : â„â‰¥0âˆ) :\n    Filter.liminf (fun i â†¦ f i - c) F = Filter.liminf f F - c :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : â„â‰¥0âˆ) â†¦ x - c)\n    (fun _ _ h â†¦ tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt).symm\n\n"}
{"name":"ENNReal.limsup_const_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nF : Filter Î¹\nf : Î¹ â†’ ENNReal\nc : ENNReal\nc_ne_top : Ne c Top.top\nâŠ¢ Eq (Filter.limsup (fun i => HSub.hSub c (f i)) F) (HSub.hSub c (Filter.liminf f F))","decl":"lemma limsup_const_sub (F : Filter Î¹) (f : Î¹ â†’ â„â‰¥0âˆ) {c : â„â‰¥0âˆ} (c_ne_top : c â‰  âˆ) :\n    Filter.limsup (fun i â†¦ c - f i) F = c - Filter.liminf f F := by\n  rcases F.eq_or_neBot with rfl | _\n  Â· simp only [limsup_bot, bot_eq_zero', liminf_bot, le_top, tsub_eq_zero_of_le]\n  Â· exact (Antitone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : â„â‰¥0âˆ) â†¦ c - x)\n    (fun _ _ h â†¦ tsub_le_tsub_left h c) (continuous_sub_left c_ne_top).continuousAt).symm\n\n"}
{"name":"ENNReal.liminf_const_sub","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_4\nF : Filter Î¹\ninstâœ : F.NeBot\nf : Î¹ â†’ ENNReal\nc : ENNReal\nc_ne_top : Ne c Top.top\nâŠ¢ Eq (Filter.liminf (fun i => HSub.hSub c (f i)) F) (HSub.hSub c (Filter.limsup f F))","decl":"lemma liminf_const_sub (F : Filter Î¹) [NeBot F] (f : Î¹ â†’ â„â‰¥0âˆ) {c : â„â‰¥0âˆ} (c_ne_top : c â‰  âˆ) :\n    Filter.liminf (fun i â†¦ c - f i) F = c - Filter.limsup f F :=\n  (Antitone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : â„â‰¥0âˆ) â†¦ c - x)\n    (fun _ _ h â†¦ tsub_le_tsub_left h c) (continuous_sub_left c_ne_top).continuousAt).symm\n\n"}
{"name":"ENNReal.le_limsup_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_5\nf : Filter Î±\nu v : Î± â†’ ENNReal\nâŠ¢ LE.le (HMul.hMul (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HMul.hMul u v) f)","decl":"lemma le_limsup_mul {Î± : Type*} {f : Filter Î±} {u v : Î± â†’ â„â‰¥0âˆ} :\n    limsup u f * liminf v f â‰¤ limsup (u * v) f :=\n  mul_le_of_forall_lt fun a a_u b b_v â†¦ (le_limsup_iff).2 fun c c_ab â†¦\n    Frequently.mono (Frequently.and_eventually ((frequently_lt_of_lt_limsup) a_u)\n    ((eventually_lt_of_lt_liminf) b_v)) fun _ ab_x â†¦ c_ab.trans (mul_lt_mul ab_x.1 ab_x.2)\n\n"}
{"name":"ENNReal.limsup_mul_le'","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_5\nf : Filter Î±\nu v : Î± â†’ ENNReal\nh : Or (Ne (Filter.limsup u f) 0) (Ne (Filter.limsup v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.limsup v f) 0)\nâŠ¢ LE.le (Filter.limsup (HMul.hMul u v) f) (HMul.hMul (Filter.limsup u f) (Filter.limsup v f))","decl":"/-- See also `ENNReal.limsup_mul_le`.-/\nlemma limsup_mul_le' {Î± : Type*} {f : Filter Î±} {u v : Î± â†’ â„â‰¥0âˆ}\n    (h : limsup u f â‰  0 âˆ¨ limsup v f â‰  âˆ) (h' : limsup u f â‰  âˆ âˆ¨ limsup v f â‰  0) :\n    limsup (u * v) f â‰¤ limsup u f * limsup v f := by\n  refine le_mul_of_forall_lt h h' fun a a_u b b_v â†¦ (limsup_le_iff).2 fun c c_ab â†¦ ?_\n  filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v] with x a_x b_x\n  exact (mul_lt_mul a_x b_x).trans c_ab\n\n"}
{"name":"ENNReal.le_liminf_mul","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_5\nf : Filter Î±\nu v : Î± â†’ ENNReal\nâŠ¢ LE.le (HMul.hMul (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HMul.hMul u v) f)","decl":"lemma le_liminf_mul {Î± : Type*} {f : Filter Î±} {u v : Î± â†’ â„â‰¥0âˆ} :\n    liminf u f * liminf v f â‰¤ liminf (u * v) f := by\n  refine mul_le_of_forall_lt fun a a_u b b_v â†¦ (le_liminf_iff).2 fun c c_ab â†¦ ?_\n  filter_upwards [eventually_lt_of_lt_liminf a_u, eventually_lt_of_lt_liminf b_v] with x a_x b_x\n  exact c_ab.trans (mul_lt_mul a_x b_x)\n\n"}
{"name":"ENNReal.liminf_mul_le","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î± : Type u_5\nf : Filter Î±\nu v : Î± â†’ ENNReal\nh : Or (Ne (Filter.limsup u f) 0) (Ne (Filter.liminf v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.liminf v f) 0)\nâŠ¢ LE.le (Filter.liminf (HMul.hMul u v) f) (HMul.hMul (Filter.limsup u f) (Filter.liminf v f))","decl":"lemma liminf_mul_le {Î± : Type*} {f : Filter Î±} {u v : Î± â†’ â„â‰¥0âˆ}\n    (h : limsup u f â‰  0 âˆ¨ liminf v f â‰  âˆ) (h' : limsup u f â‰  âˆ âˆ¨ liminf v f â‰  0) :\n    liminf (u * v) f â‰¤ limsup u f * liminf v f :=\n  le_mul_of_forall_lt h h' fun a a_u b b_v â†¦ (liminf_le_iff).2 fun c c_ab â†¦\n    Frequently.mono (((frequently_lt_of_liminf_lt) b_v).and_eventually\n    ((eventually_lt_of_limsup_lt) a_u)) fun _ ab_x â†¦ (mul_lt_mul ab_x.2 ab_x.1).trans c_ab\n\n"}
{"name":"ENNReal.liminf_toReal_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_5\nF : Filter Î¹\ninstâœ : F.NeBot\nb : ENNReal\nb_ne_top : Ne b Top.top\nxs : Î¹ â†’ ENNReal\nle_b : Filter.Eventually (fun i => LE.le (xs i) b) F\nâŠ¢ Eq (Filter.liminf (fun i => (xs i).toReal) F) (Filter.liminf xs F).toReal","decl":"/-- If `xs : Î¹ â†’ â„â‰¥0âˆ` is bounded, then we have `liminf (toReal âˆ˜ xs) = toReal (liminf xs)`. -/\nlemma liminf_toReal_eq {Î¹ : Type*} {F : Filter Î¹} [NeBot F] {b : â„â‰¥0âˆ} (b_ne_top : b â‰  âˆ)\n    {xs : Î¹ â†’ â„â‰¥0âˆ} (le_b : âˆ€á¶  i in F, xs i â‰¤ b) :\n    F.liminf (fun i â†¦ (xs i).toReal) = (F.liminf xs).toReal := by\n  have liminf_le : F.liminf xs â‰¤ b := by\n    apply liminf_le_of_le âŸ¨0, by simpâŸ©\n    intro y h\n    obtain âŸ¨i, hiâŸ© := (Eventually.and h le_b).exists\n    exact hi.1.trans hi.2\n  have aux : âˆ€á¶  i in F, (xs i).toReal = ENNReal.truncateToReal b (xs i) := by\n    filter_upwards [le_b] with i i_le_b\n    simp only [truncateToReal_eq_toReal b_ne_top i_le_b, implies_true]\n  have aux' : (F.liminf xs).toReal = ENNReal.truncateToReal b (F.liminf xs) := by\n    rw [truncateToReal_eq_toReal b_ne_top liminf_le]\n  simp_rw [liminf_congr aux, aux']\n  have key := Monotone.map_liminf_of_continuousAt (F := F) (monotone_truncateToReal b_ne_top) xs\n          (continuous_truncateToReal b_ne_top).continuousAt\n          (IsBoundedUnder.isCoboundedUnder_ge âŸ¨b, by simpa only [eventually_map] using le_bâŸ©)\n          âŸ¨0, Eventually.of_forall (by simp)âŸ©\n  rw [key]\n  rfl\n\n"}
{"name":"ENNReal.limsup_toReal_eq","module":"Mathlib.Topology.Instances.ENNReal.Lemmas","initialProofState":"Î¹ : Type u_5\nF : Filter Î¹\ninstâœ : F.NeBot\nb : ENNReal\nb_ne_top : Ne b Top.top\nxs : Î¹ â†’ ENNReal\nle_b : Filter.Eventually (fun i => LE.le (xs i) b) F\nâŠ¢ Eq (Filter.limsup (fun i => (xs i).toReal) F) (Filter.limsup xs F).toReal","decl":"/-- If `xs : Î¹ â†’ â„â‰¥0âˆ` is bounded, then we have `liminf (toReal âˆ˜ xs) = toReal (liminf xs)`. -/\nlemma limsup_toReal_eq {Î¹ : Type*} {F : Filter Î¹} [NeBot F] {b : â„â‰¥0âˆ} (b_ne_top : b â‰  âˆ)\n    {xs : Î¹ â†’ â„â‰¥0âˆ} (le_b : âˆ€á¶  i in F, xs i â‰¤ b) :\n    F.limsup (fun i â†¦ (xs i).toReal) = (F.limsup xs).toReal := by\n  have aux : âˆ€á¶  i in F, (xs i).toReal = ENNReal.truncateToReal b (xs i) := by\n    filter_upwards [le_b] with i i_le_b\n    simp only [truncateToReal_eq_toReal b_ne_top i_le_b, implies_true]\n  have aux' : (F.limsup xs).toReal = ENNReal.truncateToReal b (F.limsup xs) := by\n    rw [truncateToReal_eq_toReal b_ne_top (limsup_le_of_le âŸ¨0, by simpâŸ© le_b)]\n  simp_rw [limsup_congr aux, aux']\n  have key := Monotone.map_limsup_of_continuousAt (F := F) (monotone_truncateToReal b_ne_top) xs\n          (continuous_truncateToReal b_ne_top).continuousAt\n          âŸ¨b, by simpa only [eventually_map] using le_bâŸ©\n          (IsBoundedUnder.isCoboundedUnder_le âŸ¨0, Eventually.of_forall (by simp)âŸ©)\n  rw [key]\n  rfl\n\n"}
