{"name":"card_derangements_invariant","module":"Mathlib.Combinatorics.Derangements.Finite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Fintype α\ninst✝² : DecidableEq α\ninst✝¹ : Fintype β\ninst✝ : DecidableEq β\nh : Eq (Fintype.card α) (Fintype.card β)\n⊢ Eq (Fintype.card ↑(derangements α)) (Fintype.card ↑(derangements β))","decl":"theorem card_derangements_invariant {α β : Type*} [Fintype α] [DecidableEq α] [Fintype β]\n    [DecidableEq β] (h : card α = card β) : card (derangements α) = card (derangements β) :=\n  Fintype.card_congr (Equiv.derangementsCongr <| equivOfCardEq h)\n\n"}
{"name":"card_derangements_fin_add_two","module":"Mathlib.Combinatorics.Derangements.Finite","initialProofState":"n : Nat\n⊢ Eq (Fintype.card ↑(derangements (Fin (HAdd.hAdd n 2)))) (HAdd.hAdd (HMul.hMul (HAdd.hAdd n 1) (Fintype.card ↑(derangements (Fin n)))) (HMul.hMul (HAdd.hAdd n 1) (Fintype.card ↑(derangements (Fin (HAdd.hAdd n 1))))))","decl":"theorem card_derangements_fin_add_two (n : ℕ) :\n    card (derangements (Fin (n + 2))) =\n      (n + 1) * card (derangements (Fin n)) + (n + 1) * card (derangements (Fin (n + 1))) := by\n  -- get some basic results about the size of Fin (n+1) plus or minus an element\n  have h1 : ∀ a : Fin (n + 1), card ({a}ᶜ : Set (Fin (n + 1))) = card (Fin n) := by\n    intro a\n    simp only\n      [card_ofFinset (s := Finset.filter (fun x => x ∈ ({a}ᶜ : Set (Fin (n + 1)))) Finset.univ),\n      Set.mem_compl_singleton_iff, Finset.filter_ne' _ a,\n      Finset.card_erase_of_mem (Finset.mem_univ a), Finset.card_fin, add_tsub_cancel_right,\n      card_fin]\n  have h2 : card (Fin (n + 2)) = card (Option (Fin (n + 1))) := by simp only [card_fin, card_option]\n  -- rewrite the LHS and substitute in our fintype-level equivalence\n  simp only [card_derangements_invariant h2,\n    card_congr\n      (@derangementsRecursionEquiv (Fin (n + 1))\n        _),-- push the cardinality through the Σ and ⊕ so that we can use `card_n`\n    card_sigma,\n    card_sum, card_derangements_invariant (h1 _), Finset.sum_const, nsmul_eq_mul, Finset.card_fin,\n    mul_add, Nat.cast_id]\n\n"}
{"name":"numDerangements_zero","module":"Mathlib.Combinatorics.Derangements.Finite","initialProofState":"⊢ Eq (numDerangements 0) 1","decl":"@[simp]\ntheorem numDerangements_zero : numDerangements 0 = 1 :=\n  rfl\n\n"}
{"name":"numDerangements_one","module":"Mathlib.Combinatorics.Derangements.Finite","initialProofState":"⊢ Eq (numDerangements 1) 0","decl":"@[simp]\ntheorem numDerangements_one : numDerangements 1 = 0 :=\n  rfl\n\n"}
{"name":"numDerangements_add_two","module":"Mathlib.Combinatorics.Derangements.Finite","initialProofState":"n : Nat\n⊢ Eq (numDerangements (HAdd.hAdd n 2)) (HMul.hMul (HAdd.hAdd n 1) (HAdd.hAdd (numDerangements n) (numDerangements (HAdd.hAdd n 1))))","decl":"theorem numDerangements_add_two (n : ℕ) :\n    numDerangements (n + 2) = (n + 1) * (numDerangements n + numDerangements (n + 1)) :=\n  rfl\n\n"}
{"name":"numDerangements_succ","module":"Mathlib.Combinatorics.Derangements.Finite","initialProofState":"n : Nat\n⊢ Eq (↑(numDerangements (HAdd.hAdd n 1))) (HSub.hSub (HMul.hMul (HAdd.hAdd (↑n) 1) ↑(numDerangements n)) (HPow.hPow (-1) n))","decl":"theorem numDerangements_succ (n : ℕ) :\n    (numDerangements (n + 1) : ℤ) = (n + 1) * (numDerangements n : ℤ) - (-1) ^ n := by\n  induction n with\n  | zero => rfl\n  | succ n hn =>\n    simp only [numDerangements_add_two, hn, pow_succ, Int.ofNat_mul, Int.ofNat_add]\n    ring\n\n"}
{"name":"card_derangements_fin_eq_numDerangements","module":"Mathlib.Combinatorics.Derangements.Finite","initialProofState":"n : Nat\n⊢ Eq (Fintype.card ↑(derangements (Fin n))) (numDerangements n)","decl":"theorem card_derangements_fin_eq_numDerangements {n : ℕ} :\n    card (derangements (Fin n)) = numDerangements n := by\n  induction' n using Nat.strong_induction_on with n hyp\n  rcases n with _ | _ | n\n  -- knock out cases 0 and 1\n  · rfl\n  · rfl\n  -- now we have n ≥ 2. rewrite everything in terms of card_derangements, so that we can use\n  -- `card_derangements_fin_add_two`\n  rw [numDerangements_add_two, card_derangements_fin_add_two, mul_add, hyp, hyp] <;> omega\n\n"}
{"name":"card_derangements_eq_numDerangements","module":"Mathlib.Combinatorics.Derangements.Finite","initialProofState":"α : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ Eq (Fintype.card ↑(derangements α)) (numDerangements (Fintype.card α))","decl":"theorem card_derangements_eq_numDerangements (α : Type*) [Fintype α] [DecidableEq α] :\n    card (derangements α) = numDerangements (card α) := by\n  rw [← card_derangements_invariant (card_fin _)]\n  exact card_derangements_fin_eq_numDerangements\n\n"}
{"name":"numDerangements_sum","module":"Mathlib.Combinatorics.Derangements.Finite","initialProofState":"n : Nat\n⊢ Eq (↑(numDerangements n)) ((Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (HPow.hPow (-1) k) ↑((HAdd.hAdd k 1).ascFactorial (HSub.hSub n k)))","decl":"theorem numDerangements_sum (n : ℕ) :\n    (numDerangements n : ℤ) =\n      ∑ k ∈ Finset.range (n + 1), (-1 : ℤ) ^ k * Nat.ascFactorial (k + 1) (n - k) := by\n  induction' n with n hn; · rfl\n  rw [Finset.sum_range_succ, numDerangements_succ, hn, Finset.mul_sum, tsub_self,\n    Nat.ascFactorial_zero, Int.ofNat_one, mul_one, pow_succ', neg_one_mul, sub_eq_add_neg,\n    add_left_inj, Finset.sum_congr rfl]\n  -- show that (n + 1) * (-1)^x * asc_fac x (n - x) = (-1)^x * asc_fac x (n.succ - x)\n  intro x hx\n  have h_le : x ≤ n := Finset.mem_range_succ_iff.mp hx\n  rw [Nat.succ_sub h_le, Nat.ascFactorial_succ, add_right_comm, add_tsub_cancel_of_le h_le,\n    Int.ofNat_mul, Int.ofNat_add, mul_left_comm, Nat.cast_one]\n"}
