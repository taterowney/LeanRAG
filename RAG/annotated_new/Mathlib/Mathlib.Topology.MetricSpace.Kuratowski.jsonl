{"name":"KuratowskiEmbedding.embeddingOfSubset_coe","module":"Mathlib.Topology.MetricSpace.Kuratowski","initialProofState":"α : Type u\nn : Nat\ninst✝ : MetricSpace α\nx : Nat → α\na : α\n⊢ Eq (↑(KuratowskiEmbedding.embeddingOfSubset x a) n) (HSub.hSub (Dist.dist a (x n)) (Dist.dist (x 0) (x n)))","decl":"theorem embeddingOfSubset_coe : embeddingOfSubset x a n = dist a (x n) - dist (x 0) (x n) :=\n  rfl\n\n"}
{"name":"KuratowskiEmbedding.embeddingOfSubset_dist_le","module":"Mathlib.Topology.MetricSpace.Kuratowski","initialProofState":"α : Type u\ninst✝ : MetricSpace α\nx : Nat → α\na b : α\n⊢ LE.le (Dist.dist (KuratowskiEmbedding.embeddingOfSubset x a) (KuratowskiEmbedding.embeddingOfSubset x b)) (Dist.dist a b)","decl":"/-- The embedding map is always a semi-contraction. -/\ntheorem embeddingOfSubset_dist_le (a b : α) :\n    dist (embeddingOfSubset x a) (embeddingOfSubset x b) ≤ dist a b := by\n  refine lp.norm_le_of_forall_le dist_nonneg fun n => ?_\n  simp only [lp.coeFn_sub, Pi.sub_apply, embeddingOfSubset_coe, Real.dist_eq]\n  convert abs_dist_sub_le a b (x n) using 2\n  ring\n\n"}
{"name":"KuratowskiEmbedding.embeddingOfSubset_isometry","module":"Mathlib.Topology.MetricSpace.Kuratowski","initialProofState":"α : Type u\ninst✝ : MetricSpace α\nx : Nat → α\nH : DenseRange x\n⊢ Isometry (KuratowskiEmbedding.embeddingOfSubset x)","decl":"/-- When the reference set is dense, the embedding map is an isometry on its image. -/\ntheorem embeddingOfSubset_isometry (H : DenseRange x) : Isometry (embeddingOfSubset x) := by\n  refine Isometry.of_dist_eq fun a b => ?_\n  refine (embeddingOfSubset_dist_le x a b).antisymm (le_of_forall_pos_le_add fun e epos => ?_)\n  -- First step: find n with dist a (x n) < e\n  rcases Metric.mem_closure_range_iff.1 (H a) (e / 2) (half_pos epos) with ⟨n, hn⟩\n  -- Second step: use the norm control at index n to conclude\n  have C : dist b (x n) - dist a (x n) = embeddingOfSubset x b n - embeddingOfSubset x a n := by\n    simp only [embeddingOfSubset_coe, sub_sub_sub_cancel_right]\n  have :=\n    calc\n      dist a b ≤ dist a (x n) + dist (x n) b := dist_triangle _ _ _\n      _ = 2 * dist a (x n) + (dist b (x n) - dist a (x n)) := by simp [dist_comm]; ring\n      _ ≤ 2 * dist a (x n) + |dist b (x n) - dist a (x n)| := by\n        apply_rules [add_le_add_left, le_abs_self]\n      _ ≤ 2 * (e / 2) + |embeddingOfSubset x b n - embeddingOfSubset x a n| := by\n        rw [C]\n        gcongr\n      _ ≤ 2 * (e / 2) + dist (embeddingOfSubset x b) (embeddingOfSubset x a) := by\n        gcongr\n        simp only [dist_eq_norm]\n        exact lp.norm_apply_le_norm ENNReal.top_ne_zero\n          (embeddingOfSubset x b - embeddingOfSubset x a) n\n      _ = dist (embeddingOfSubset x b) (embeddingOfSubset x a) + e := by ring\n  simpa [dist_comm] using this\n\n"}
{"name":"KuratowskiEmbedding.exists_isometric_embedding","module":"Mathlib.Topology.MetricSpace.Kuratowski","initialProofState":"α : Type u\ninst✝¹ : MetricSpace α\ninst✝ : TopologicalSpace.SeparableSpace α\n⊢ Exists fun f => Isometry f","decl":"/-- Every separable metric space embeds isometrically in `ℓ^∞(ℕ)`. -/\ntheorem exists_isometric_embedding (α : Type u) [MetricSpace α] [SeparableSpace α] :\n    ∃ f : α → ℓ^∞(ℕ), Isometry f := by\n  rcases (univ : Set α).eq_empty_or_nonempty with h | h\n  · use fun _ => 0; intro x; exact absurd h (Nonempty.ne_empty ⟨x, mem_univ x⟩)\n  · -- We construct a map x : ℕ → α with dense image\n    rcases h with ⟨basepoint⟩\n    haveI : Inhabited α := ⟨basepoint⟩\n    have : ∃ s : Set α, s.Countable ∧ Dense s := exists_countable_dense α\n    rcases this with ⟨S, ⟨S_countable, S_dense⟩⟩\n    rcases Set.countable_iff_exists_subset_range.1 S_countable with ⟨x, x_range⟩\n    -- Use embeddingOfSubset to construct the desired isometry\n    exact ⟨embeddingOfSubset x, embeddingOfSubset_isometry x (S_dense.mono x_range)⟩\n\n"}
{"name":"kuratowskiEmbedding.isometry","module":"Mathlib.Topology.MetricSpace.Kuratowski","initialProofState":"α : Type u\ninst✝¹ : MetricSpace α\ninst✝ : TopologicalSpace.SeparableSpace α\n⊢ Isometry (kuratowskiEmbedding α)","decl":"/--\nThe Kuratowski embedding is an isometry.\nTheorem 2.1 of [Assaf Naor, *Metric Embeddings and Lipschitz Extensions*][Naor-2015]. -/\nprotected theorem kuratowskiEmbedding.isometry (α : Type u) [MetricSpace α] [SeparableSpace α] :\n    Isometry (kuratowskiEmbedding α) :=\n  Classical.choose_spec (exists_isometric_embedding α)\n\n"}
{"name":"LipschitzOnWith.extend_lp_infty","module":"Mathlib.Topology.MetricSpace.Kuratowski","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nι : Type u_1\nf : α → Subtype fun x => Membership.mem (lp (fun i => Real) Top.top) x\nK : NNReal\nhfl : LipschitzOnWith K f s\n⊢ Exists fun g => And (LipschitzWith K g) (Set.EqOn f g s)","decl":"/--\nA function `f : α → ℓ^∞(ι, ℝ)` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz\nextension to the whole space.\n\nTheorem 2.2 of [Assaf Naor, *Metric Embeddings and Lipschitz Extensions*][Naor-2015]\n\nThe same result for the case of a finite type `ι` is implemented in\n`LipschitzOnWith.extend_pi`.\n-/\ntheorem LipschitzOnWith.extend_lp_infty [PseudoMetricSpace α] {s : Set α} {ι : Type*}\n    {f : α → ℓ^∞(ι)} {K : ℝ≥0} (hfl : LipschitzOnWith K f s) :\n    ∃ g : α → ℓ^∞(ι), LipschitzWith K g ∧ EqOn f g s := by\n  -- Construct the coordinate-wise extensions\n  rw [LipschitzOnWith.coordinate] at hfl\n  have (i : ι) : ∃ g : α → ℝ, LipschitzWith K g ∧ EqOn (fun x => f x i) g s :=\n    LipschitzOnWith.extend_real (hfl i) -- use the nonlinear Hahn-Banach theorem here!\n  choose g hgl hgeq using this\n  rcases s.eq_empty_or_nonempty with rfl | ⟨a₀, ha₀_in_s⟩\n  · exact ⟨0, LipschitzWith.const' 0, by simp⟩\n  · -- Show that the extensions are uniformly bounded\n    have hf_extb : ∀ a : α, Memℓp (swap g a) ∞ := by\n      apply LipschitzWith.uniformly_bounded (swap g) hgl a₀\n      use ‖f a₀‖\n      rintro - ⟨i, rfl⟩\n      simp_rw [← hgeq i ha₀_in_s]\n      exact lp.norm_apply_le_norm top_ne_zero (f a₀) i\n    -- Construct witness by bundling the function with its certificate of membership in ℓ^∞\n    let f_ext' : α → ℓ^∞(ι) := fun i ↦ ⟨swap g i, hf_extb i⟩\n    refine ⟨f_ext', ?_, ?_⟩\n    · rw [LipschitzWith.coordinate]\n      exact hgl\n    · intro a hyp\n      ext i\n      exact (hgeq i) hyp\n"}
