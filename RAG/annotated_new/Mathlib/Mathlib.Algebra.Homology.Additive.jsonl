{"name":"HomologicalComplex.zero_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\ni : ι\n⊢ Eq (HomologicalComplex.Hom.f 0 i) 0","decl":"@[simp]\ntheorem zero_f_apply (i : ι) : (0 : C ⟶ D).f i = 0 :=\n  rfl\n\n"}
{"name":"HomologicalComplex.add_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\ni : ι\n⊢ Eq ((HAdd.hAdd f g).f i) (HAdd.hAdd (f.f i) (g.f i))","decl":"@[simp]\ntheorem add_f_apply (f g : C ⟶ D) (i : ι) : (f + g).f i = f.f i + g.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.neg_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : Quiver.Hom C D\ni : ι\n⊢ Eq ((Neg.neg f).f i) (Neg.neg (f.f i))","decl":"@[simp]\ntheorem neg_f_apply (f : C ⟶ D) (i : ι) : (-f).f i = -f.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.sub_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\ni : ι\n⊢ Eq ((HSub.hSub f g).f i) (HSub.hSub (f.f i) (g.f i))","decl":"@[simp]\ntheorem sub_f_apply (f g : C ⟶ D) (i : ι) : (f - g).f i = f.f i - g.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.nsmul_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nn : Nat\nf : Quiver.Hom C D\ni : ι\n⊢ Eq ((HSMul.hSMul n f).f i) (HSMul.hSMul n (f.f i))","decl":"@[simp]\ntheorem nsmul_f_apply (n : ℕ) (f : C ⟶ D) (i : ι) : (n • f).f i = n • f.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.zsmul_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nn : Int\nf : Quiver.Hom C D\ni : ι\n⊢ Eq ((HSMul.hSMul n f).f i) (HSMul.hSMul n (f.f i))","decl":"@[simp]\ntheorem zsmul_f_apply (n : ℤ) (f : C ⟶ D) (i : ι) : (n • f).f i = n • f.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.fAddMonoidHom_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\ni : ι\nf : Quiver.Hom C₁ C₂\n⊢ Eq ((HomologicalComplex.Hom.fAddMonoidHom i) f) (f.f i)","decl":"/-- The `i`-th component of a chain map, as an additive map from chain maps to morphisms. -/\n@[simps!]\ndef Hom.fAddMonoidHom {C₁ C₂ : HomologicalComplex V c} (i : ι) : (C₁ ⟶ C₂) →+ (C₁.X i ⟶ C₂.X i) :=\n  AddMonoidHom.mk' (fun f => Hom.f f i) fun _ _ => rfl\n\n"}
{"name":"HomologicalComplex.eval_additive","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\ni : ι\n⊢ (HomologicalComplex.eval V c i).Additive","decl":"instance eval_additive (i : ι) : (eval V c i).Additive where\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_map_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝³ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms W₂\nF : CategoryTheory.Functor W₁ W₂\ninst✝ : F.PreservesZeroMorphisms\nc : ComplexShape ι\nX✝ Y✝ : HomologicalComplex W₁ c\nf : Quiver.Hom X✝ Y✝\ni : ι\n⊢ Eq (((F.mapHomologicalComplex c).map f).f i) (F.map (f.f i))","decl":"/-- An additive functor induces a functor between homological complexes.\nThis is sometimes called the \"prolongation\".\n-/\n@[simps]\ndef Functor.mapHomologicalComplex (F : W₁ ⥤ W₂) [F.PreservesZeroMorphisms] (c : ComplexShape ι) :\n    HomologicalComplex W₁ c ⥤ HomologicalComplex W₂ c where\n  obj C :=\n    { X := fun i => F.obj (C.X i)\n      d := fun i j => F.map (C.d i j)\n      shape := fun i j w => by\n        dsimp only\n        rw [C.shape _ _ w, F.map_zero]\n      d_comp_d' := fun i j k _ _ => by rw [← F.map_comp, C.d_comp_d, F.map_zero] }\n  map f :=\n    { f := fun i => F.map (f.f i)\n      comm' := fun i j _ => by\n        dsimp\n        rw [← F.map_comp, ← F.map_comp, f.comm] }\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_obj_d","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝³ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms W₂\nF : CategoryTheory.Functor W₁ W₂\ninst✝ : F.PreservesZeroMorphisms\nc : ComplexShape ι\nC : HomologicalComplex W₁ c\ni j : ι\n⊢ Eq (((F.mapHomologicalComplex c).obj C).d i j) (F.map (C.d i j))","decl":"/-- An additive functor induces a functor between homological complexes.\nThis is sometimes called the \"prolongation\".\n-/\n@[simps]\ndef Functor.mapHomologicalComplex (F : W₁ ⥤ W₂) [F.PreservesZeroMorphisms] (c : ComplexShape ι) :\n    HomologicalComplex W₁ c ⥤ HomologicalComplex W₂ c where\n  obj C :=\n    { X := fun i => F.obj (C.X i)\n      d := fun i j => F.map (C.d i j)\n      shape := fun i j w => by\n        dsimp only\n        rw [C.shape _ _ w, F.map_zero]\n      d_comp_d' := fun i j k _ _ => by rw [← F.map_comp, C.d_comp_d, F.map_zero] }\n  map f :=\n    { f := fun i => F.map (f.f i)\n      comm' := fun i j _ => by\n        dsimp\n        rw [← F.map_comp, ← F.map_comp, f.comm] }\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_obj_X","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝³ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms W₂\nF : CategoryTheory.Functor W₁ W₂\ninst✝ : F.PreservesZeroMorphisms\nc : ComplexShape ι\nC : HomologicalComplex W₁ c\ni : ι\n⊢ Eq (((F.mapHomologicalComplex c).obj C).X i) (F.obj (C.X i))","decl":"/-- An additive functor induces a functor between homological complexes.\nThis is sometimes called the \"prolongation\".\n-/\n@[simps]\ndef Functor.mapHomologicalComplex (F : W₁ ⥤ W₂) [F.PreservesZeroMorphisms] (c : ComplexShape ι) :\n    HomologicalComplex W₁ c ⥤ HomologicalComplex W₂ c where\n  obj C :=\n    { X := fun i => F.obj (C.X i)\n      d := fun i j => F.map (C.d i j)\n      shape := fun i j w => by\n        dsimp only\n        rw [C.shape _ _ w, F.map_zero]\n      d_comp_d' := fun i j k _ _ => by rw [← F.map_comp, C.d_comp_d, F.map_zero] }\n  map f :=\n    { f := fun i => F.map (f.f i)\n      comm' := fun i j _ => by\n        dsimp\n        rw [← F.map_comp, ← F.map_comp, f.comm] }\n\n"}
{"name":"CategoryTheory.instPreservesZeroMorphismsHomologicalComplexMapHomologicalComplex","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝³ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms W₂\nF : CategoryTheory.Functor W₁ W₂\ninst✝ : F.PreservesZeroMorphisms\nc : ComplexShape ι\n⊢ (F.mapHomologicalComplex c).PreservesZeroMorphisms","decl":"instance (F : W₁ ⥤ W₂) [F.PreservesZeroMorphisms] (c : ComplexShape ι) :\n    (F.mapHomologicalComplex c).PreservesZeroMorphisms where\n\n"}
{"name":"CategoryTheory.Functor.map_homogical_complex_additive","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nV : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Preadditive V\nW : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} W\ninst✝¹ : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst✝ : F.Additive\nc : ComplexShape ι\n⊢ (F.mapHomologicalComplex c).Additive","decl":"instance Functor.map_homogical_complex_additive (F : V ⥤ W) [F.Additive] (c : ComplexShape ι) :\n    (F.mapHomologicalComplex c).Additive where\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplexIdIso_hom_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms W₁\nc : ComplexShape ι\nX : HomologicalComplex W₁ c\ni : ι\n⊢ Eq (((CategoryTheory.Functor.mapHomologicalComplexIdIso W₁ c).hom.app X).f i) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- The functor on homological complexes induced by the identity functor is\nisomorphic to the identity functor. -/\n@[simps!]\ndef Functor.mapHomologicalComplexIdIso (c : ComplexShape ι) :\n    (𝟭 W₁).mapHomologicalComplex c ≅ 𝟭 _ :=\n  NatIso.ofComponents fun K => Hom.isoOfComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplexIdIso_inv_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms W₁\nc : ComplexShape ι\nX : HomologicalComplex W₁ c\ni : ι\n⊢ Eq (((CategoryTheory.Functor.mapHomologicalComplexIdIso W₁ c).inv.app X).f i) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- The functor on homological complexes induced by the identity functor is\nisomorphic to the identity functor. -/\n@[simps!]\ndef Functor.mapHomologicalComplexIdIso (c : ComplexShape ι) :\n    (𝟭 W₁).mapHomologicalComplex c ≅ 𝟭 _ :=\n  NatIso.ofComponents fun K => Hom.isoOfComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_reflects_iso","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₂\nF : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : F.ReflectsIsomorphisms\nc : ComplexShape ι\n⊢ (F.mapHomologicalComplex c).ReflectsIsomorphisms","decl":"instance Functor.mapHomologicalComplex_reflects_iso (F : W₁ ⥤ W₂) [F.PreservesZeroMorphisms]\n    [ReflectsIsomorphisms F] (c : ComplexShape ι) :\n    ReflectsIsomorphisms (F.mapHomologicalComplex c) :=\n  ⟨fun f => by\n    intro\n    haveI : ∀ n : ι, IsIso (F.map (f.f n)) := fun n =>\n        ((HomologicalComplex.eval W₂ c n).mapIso\n          (asIso ((F.mapHomologicalComplex c).map f))).isIso_hom\n    haveI := fun n => isIso_of_reflects_iso (f.f n) F\n    exact HomologicalComplex.Hom.isIso_of_components f⟩\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₂\nF G : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : G.PreservesZeroMorphisms\nα : Quiver.Hom F G\nc : ComplexShape ι\nC : HomologicalComplex W₁ c\nx✝ : ι\n⊢ Eq (((CategoryTheory.NatTrans.mapHomologicalComplex α c).app C).f x✝) (α.app (C.X x✝))","decl":"/-- A natural transformation between functors induces a natural transformation\nbetween those functors applied to homological complexes.\n-/\n@[simps]\ndef NatTrans.mapHomologicalComplex {F G : W₁ ⥤ W₂}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms] (α : F ⟶ G)\n    (c : ComplexShape ι) : F.mapHomologicalComplex c ⟶ G.mapHomologicalComplex c where\n  app C := { f := fun _ => α.app _ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_id","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝³ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms W₂\nc : ComplexShape ι\nF : CategoryTheory.Functor W₁ W₂\ninst✝ : F.PreservesZeroMorphisms\n⊢ Eq (CategoryTheory.NatTrans.mapHomologicalComplex (CategoryTheory.CategoryStruct.id F) c) (CategoryTheory.CategoryStruct.id (F.mapHomologicalComplex c))","decl":"@[simp]\ntheorem NatTrans.mapHomologicalComplex_id\n    (c : ComplexShape ι) (F : W₁ ⥤ W₂) [F.PreservesZeroMorphisms] :\n    NatTrans.mapHomologicalComplex (𝟙 F) c = 𝟙 (F.mapHomologicalComplex c) := by aesop_cat\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_comp","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁶ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝⁵ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms W₂\nc : ComplexShape ι\nF G H : CategoryTheory.Functor W₁ W₂\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : G.PreservesZeroMorphisms\ninst✝ : H.PreservesZeroMorphisms\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\n⊢ Eq (CategoryTheory.NatTrans.mapHomologicalComplex (CategoryTheory.CategoryStruct.comp α β) c) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.mapHomologicalComplex α c) (CategoryTheory.NatTrans.mapHomologicalComplex β c))","decl":"@[simp]\ntheorem NatTrans.mapHomologicalComplex_comp (c : ComplexShape ι) {F G H : W₁ ⥤ W₂}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms] [H.PreservesZeroMorphisms]\n    (α : F ⟶ G) (β : G ⟶ H) :\n    NatTrans.mapHomologicalComplex (α ≫ β) c =\n      NatTrans.mapHomologicalComplex α c ≫ NatTrans.mapHomologicalComplex β c := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_naturality_assoc","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₂\nc : ComplexShape ι\nF G : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : G.PreservesZeroMorphisms\nα : Quiver.Hom F G\nC D : HomologicalComplex W₁ c\nf : Quiver.Hom C D\nZ : HomologicalComplex W₂ c\nh : Quiver.Hom ((G.mapHomologicalComplex c).obj D) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapHomologicalComplex c).map f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.NatTrans.mapHomologicalComplex α c).app D) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.NatTrans.mapHomologicalComplex α c).app C) (CategoryTheory.CategoryStruct.comp ((G.mapHomologicalComplex c).map f) h))","decl":"@[reassoc]\ntheorem NatTrans.mapHomologicalComplex_naturality {c : ComplexShape ι} {F G : W₁ ⥤ W₂}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms]\n    (α : F ⟶ G) {C D : HomologicalComplex W₁ c} (f : C ⟶ D) :\n    (F.mapHomologicalComplex c).map f ≫ (NatTrans.mapHomologicalComplex α c).app D =\n      (NatTrans.mapHomologicalComplex α c).app C ≫ (G.mapHomologicalComplex c).map f := by\n  simp\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_naturality","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₂\nc : ComplexShape ι\nF G : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : G.PreservesZeroMorphisms\nα : Quiver.Hom F G\nC D : HomologicalComplex W₁ c\nf : Quiver.Hom C D\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapHomologicalComplex c).map f) ((CategoryTheory.NatTrans.mapHomologicalComplex α c).app D)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.NatTrans.mapHomologicalComplex α c).app C) ((G.mapHomologicalComplex c).map f))","decl":"@[reassoc]\ntheorem NatTrans.mapHomologicalComplex_naturality {c : ComplexShape ι} {F G : W₁ ⥤ W₂}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms]\n    (α : F ⟶ G) {C D : HomologicalComplex W₁ c} (f : C ⟶ D) :\n    (F.mapHomologicalComplex c).map f ≫ (NatTrans.mapHomologicalComplex α c).app D =\n      (NatTrans.mapHomologicalComplex α c).app C ≫ (G.mapHomologicalComplex c).map f := by\n  simp\n\n"}
{"name":"CategoryTheory.NatIso.mapHomologicalComplex_inv_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₂\nF G : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : G.PreservesZeroMorphisms\nα : CategoryTheory.Iso F G\nc : ComplexShape ι\nC : HomologicalComplex W₁ c\nx✝ : ι\n⊢ Eq (((CategoryTheory.NatIso.mapHomologicalComplex α c).inv.app C).f x✝) (α.inv.app (C.X x✝))","decl":"/-- A natural isomorphism between functors induces a natural isomorphism\nbetween those functors applied to homological complexes.\n-/\n@[simps!]\ndef NatIso.mapHomologicalComplex {F G : W₁ ⥤ W₂} [F.PreservesZeroMorphisms]\n    [G.PreservesZeroMorphisms] (α : F ≅ G) (c : ComplexShape ι) :\n    F.mapHomologicalComplex c ≅ G.mapHomologicalComplex c where\n  hom := NatTrans.mapHomologicalComplex α.hom c\n  inv := NatTrans.mapHomologicalComplex α.inv c\n  hom_inv_id := by simp only [← NatTrans.mapHomologicalComplex_comp, α.hom_inv_id,\n    NatTrans.mapHomologicalComplex_id]\n  inv_hom_id := by simp only [← NatTrans.mapHomologicalComplex_comp, α.inv_hom_id,\n    NatTrans.mapHomologicalComplex_id]\n\n"}
{"name":"CategoryTheory.NatIso.mapHomologicalComplex_hom_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝⁴ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₂\nF G : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : G.PreservesZeroMorphisms\nα : CategoryTheory.Iso F G\nc : ComplexShape ι\nC : HomologicalComplex W₁ c\nx✝ : ι\n⊢ Eq (((CategoryTheory.NatIso.mapHomologicalComplex α c).hom.app C).f x✝) (α.hom.app (C.X x✝))","decl":"/-- A natural isomorphism between functors induces a natural isomorphism\nbetween those functors applied to homological complexes.\n-/\n@[simps!]\ndef NatIso.mapHomologicalComplex {F G : W₁ ⥤ W₂} [F.PreservesZeroMorphisms]\n    [G.PreservesZeroMorphisms] (α : F ≅ G) (c : ComplexShape ι) :\n    F.mapHomologicalComplex c ≅ G.mapHomologicalComplex c where\n  hom := NatTrans.mapHomologicalComplex α.hom c\n  inv := NatTrans.mapHomologicalComplex α.inv c\n  hom_inv_id := by simp only [← NatTrans.mapHomologicalComplex_comp, α.hom_inv_id,\n    NatTrans.mapHomologicalComplex_id]\n  inv_hom_id := by simp only [← NatTrans.mapHomologicalComplex_comp, α.inv_hom_id,\n    NatTrans.mapHomologicalComplex_id]\n\n"}
{"name":"CategoryTheory.Equivalence.mapHomologicalComplex_functor","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝³ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms W₂\ne : CategoryTheory.Equivalence W₁ W₂\ninst✝ : e.functor.PreservesZeroMorphisms\nc : ComplexShape ι\n⊢ Eq (e.mapHomologicalComplex c).functor (e.functor.mapHomologicalComplex c)","decl":"/-- An equivalence of categories induces an equivalences between the respective categories\nof homological complex.\n-/\n@[simps]\ndef Equivalence.mapHomologicalComplex (e : W₁ ≌ W₂) [e.functor.PreservesZeroMorphisms]\n    (c : ComplexShape ι) :\n    HomologicalComplex W₁ c ≌ HomologicalComplex W₂ c where\n  functor := e.functor.mapHomologicalComplex c\n  inverse := e.inverse.mapHomologicalComplex c\n  unitIso :=\n    (Functor.mapHomologicalComplexIdIso W₁ c).symm ≪≫ NatIso.mapHomologicalComplex e.unitIso c\n  counitIso := NatIso.mapHomologicalComplex e.counitIso c ≪≫\n  Functor.mapHomologicalComplexIdIso W₂ c\n\n"}
{"name":"CategoryTheory.Equivalence.mapHomologicalComplex_counitIso","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝³ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms W₂\ne : CategoryTheory.Equivalence W₁ W₂\ninst✝ : e.functor.PreservesZeroMorphisms\nc : ComplexShape ι\n⊢ Eq (e.mapHomologicalComplex c).counitIso ((CategoryTheory.NatIso.mapHomologicalComplex e.counitIso c).trans (CategoryTheory.Functor.mapHomologicalComplexIdIso W₂ c))","decl":"/-- An equivalence of categories induces an equivalences between the respective categories\nof homological complex.\n-/\n@[simps]\ndef Equivalence.mapHomologicalComplex (e : W₁ ≌ W₂) [e.functor.PreservesZeroMorphisms]\n    (c : ComplexShape ι) :\n    HomologicalComplex W₁ c ≌ HomologicalComplex W₂ c where\n  functor := e.functor.mapHomologicalComplex c\n  inverse := e.inverse.mapHomologicalComplex c\n  unitIso :=\n    (Functor.mapHomologicalComplexIdIso W₁ c).symm ≪≫ NatIso.mapHomologicalComplex e.unitIso c\n  counitIso := NatIso.mapHomologicalComplex e.counitIso c ≪≫\n  Functor.mapHomologicalComplexIdIso W₂ c\n\n"}
{"name":"CategoryTheory.Equivalence.mapHomologicalComplex_unitIso","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝³ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms W₂\ne : CategoryTheory.Equivalence W₁ W₂\ninst✝ : e.functor.PreservesZeroMorphisms\nc : ComplexShape ι\n⊢ Eq (e.mapHomologicalComplex c).unitIso ((CategoryTheory.Functor.mapHomologicalComplexIdIso W₁ c).symm.trans (CategoryTheory.NatIso.mapHomologicalComplex e.unitIso c))","decl":"/-- An equivalence of categories induces an equivalences between the respective categories\nof homological complex.\n-/\n@[simps]\ndef Equivalence.mapHomologicalComplex (e : W₁ ≌ W₂) [e.functor.PreservesZeroMorphisms]\n    (c : ComplexShape ι) :\n    HomologicalComplex W₁ c ≌ HomologicalComplex W₂ c where\n  functor := e.functor.mapHomologicalComplex c\n  inverse := e.inverse.mapHomologicalComplex c\n  unitIso :=\n    (Functor.mapHomologicalComplexIdIso W₁ c).symm ≪≫ NatIso.mapHomologicalComplex e.unitIso c\n  counitIso := NatIso.mapHomologicalComplex e.counitIso c ≪≫\n  Functor.mapHomologicalComplexIdIso W₂ c\n\n"}
{"name":"CategoryTheory.Equivalence.mapHomologicalComplex_inverse","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} W₁\ninst✝³ : CategoryTheory.Category.{u_6, u_4} W₂\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms W₂\ne : CategoryTheory.Equivalence W₁ W₂\ninst✝ : e.functor.PreservesZeroMorphisms\nc : ComplexShape ι\n⊢ Eq (e.mapHomologicalComplex c).inverse (e.inverse.mapHomologicalComplex c)","decl":"/-- An equivalence of categories induces an equivalences between the respective categories\nof homological complex.\n-/\n@[simps]\ndef Equivalence.mapHomologicalComplex (e : W₁ ≌ W₂) [e.functor.PreservesZeroMorphisms]\n    (c : ComplexShape ι) :\n    HomologicalComplex W₁ c ≌ HomologicalComplex W₂ c where\n  functor := e.functor.mapHomologicalComplex c\n  inverse := e.inverse.mapHomologicalComplex c\n  unitIso :=\n    (Functor.mapHomologicalComplexIdIso W₁ c).symm ≪≫ NatIso.mapHomologicalComplex e.unitIso c\n  counitIso := NatIso.mapHomologicalComplex e.counitIso c ≪≫\n  Functor.mapHomologicalComplexIdIso W₂ c\n\n"}
{"name":"ChainComplex.map_chain_complex_of","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"W₁ : Type u_3\nW₂ : Type u_4\ninst✝⁷ : CategoryTheory.Category.{u_6, u_3} W₁\ninst✝⁶ : CategoryTheory.Category.{u_7, u_4} W₂\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms W₂\nα : Type u_5\ninst✝³ : AddRightCancelSemigroup α\ninst✝² : One α\ninst✝¹ : DecidableEq α\nF : CategoryTheory.Functor W₁ W₂\ninst✝ : F.PreservesZeroMorphisms\nX : α → W₁\nd : (n : α) → Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d (HAdd.hAdd n 1)) (d n)) 0\n⊢ Eq ((F.mapHomologicalComplex (ComplexShape.down α)).obj (ChainComplex.of X d sq)) (ChainComplex.of (fun n => F.obj (X n)) (fun n => F.map (d n)) ⋯)","decl":"theorem map_chain_complex_of (F : W₁ ⥤ W₂) [F.PreservesZeroMorphisms] (X : α → W₁)\n    (d : ∀ n, X (n + 1) ⟶ X n) (sq : ∀ n, d (n + 1) ≫ d n = 0) :\n    (F.mapHomologicalComplex _).obj (ChainComplex.of X d sq) =\n      ChainComplex.of (fun n => F.obj (X n)) (fun n => F.map (d n)) fun n => by\n        rw [← F.map_comp, sq n, Functor.map_zero] := by\n  refine HomologicalComplex.ext rfl ?_\n  rintro i j (rfl : j + 1 = i)\n  simp only [CategoryTheory.Functor.mapHomologicalComplex_obj_d, of_d, eqToHom_refl, comp_id,\n    id_comp]\n\n"}
{"name":"HomologicalComplex.instAdditiveSingle","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nW : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_5} W\ninst✝² : CategoryTheory.Preadditive W\ninst✝¹ : CategoryTheory.Limits.HasZeroObject W\ninst✝ : DecidableEq ι\nj : ι\n⊢ (HomologicalComplex.single W c j).Additive","decl":"instance (W : Type*) [Category W] [Preadditive W] [HasZeroObject W] [DecidableEq ι] (j : ι) :\n    (single W c j).Additive where\n  map_add {_ _ f g} := by ext; simp [single]\n\n"}
{"name":"HomologicalComplex.singleMapHomologicalComplex_hom_app_self","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁷ : CategoryTheory.Category.{u_6, u_3} W₁\ninst✝⁶ : CategoryTheory.Category.{u_5, u_4} W₂\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms W₂\ninst✝³ : CategoryTheory.Limits.HasZeroObject W₁\ninst✝² : CategoryTheory.Limits.HasZeroObject W₂\nF : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\nc : ComplexShape ι\ninst✝ : DecidableEq ι\nj : ι\nX : W₁\n⊢ Eq (((HomologicalComplex.singleMapHomologicalComplex F c j).hom.app X).f j) (CategoryTheory.CategoryStruct.comp (F.map (HomologicalComplex.singleObjXSelf c j X).hom) (HomologicalComplex.singleObjXSelf c j (F.obj X)).inv)","decl":"@[simp]\ntheorem singleMapHomologicalComplex_hom_app_self (j : ι) (X : W₁) :\n    ((singleMapHomologicalComplex F c j).hom.app X).f j =\n      F.map (singleObjXSelf c j X).hom ≫ (singleObjXSelf c j (F.obj X)).inv := by\n  simp [singleMapHomologicalComplex, singleObjXSelf, singleObjXIsoOfEq, eqToHom_map]\n\n"}
{"name":"HomologicalComplex.singleMapHomologicalComplex_hom_app_ne","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁷ : CategoryTheory.Category.{u_6, u_3} W₁\ninst✝⁶ : CategoryTheory.Category.{u_5, u_4} W₂\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms W₂\ninst✝³ : CategoryTheory.Limits.HasZeroObject W₁\ninst✝² : CategoryTheory.Limits.HasZeroObject W₂\nF : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\nc : ComplexShape ι\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne i j\nX : W₁\n⊢ Eq (((HomologicalComplex.singleMapHomologicalComplex F c j).hom.app X).f i) 0","decl":"@[simp]\ntheorem singleMapHomologicalComplex_hom_app_ne {i j : ι} (h : i ≠ j) (X : W₁) :\n    ((singleMapHomologicalComplex F c j).hom.app X).f i = 0 := by\n  simp [singleMapHomologicalComplex, h]\n\n"}
{"name":"HomologicalComplex.singleMapHomologicalComplex_inv_app_self","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁷ : CategoryTheory.Category.{u_6, u_3} W₁\ninst✝⁶ : CategoryTheory.Category.{u_5, u_4} W₂\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms W₂\ninst✝³ : CategoryTheory.Limits.HasZeroObject W₁\ninst✝² : CategoryTheory.Limits.HasZeroObject W₂\nF : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\nc : ComplexShape ι\ninst✝ : DecidableEq ι\nj : ι\nX : W₁\n⊢ Eq (((HomologicalComplex.singleMapHomologicalComplex F c j).inv.app X).f j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.singleObjXSelf c j (F.obj X)).hom (F.map (HomologicalComplex.singleObjXSelf c j X).inv))","decl":"@[simp]\ntheorem singleMapHomologicalComplex_inv_app_self (j : ι) (X : W₁) :\n    ((singleMapHomologicalComplex F c j).inv.app X).f j =\n      (singleObjXSelf c j (F.obj X)).hom ≫ F.map (singleObjXSelf c j X).inv := by\n  simp [singleMapHomologicalComplex, singleObjXSelf, singleObjXIsoOfEq, eqToHom_map]\n\n"}
{"name":"HomologicalComplex.singleMapHomologicalComplex_inv_app_ne","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"ι : Type u_1\nW₁ : Type u_3\nW₂ : Type u_4\ninst✝⁷ : CategoryTheory.Category.{u_6, u_3} W₁\ninst✝⁶ : CategoryTheory.Category.{u_5, u_4} W₂\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms W₁\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms W₂\ninst✝³ : CategoryTheory.Limits.HasZeroObject W₁\ninst✝² : CategoryTheory.Limits.HasZeroObject W₂\nF : CategoryTheory.Functor W₁ W₂\ninst✝¹ : F.PreservesZeroMorphisms\nc : ComplexShape ι\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne i j\nX : W₁\n⊢ Eq (((HomologicalComplex.singleMapHomologicalComplex F c j).inv.app X).f i) 0","decl":"@[simp]\ntheorem singleMapHomologicalComplex_inv_app_ne {i j : ι} (h : i ≠ j) (X : W₁) :\n    ((singleMapHomologicalComplex F c j).inv.app X).f i = 0 := by\n  simp [singleMapHomologicalComplex, h]\n\n"}
