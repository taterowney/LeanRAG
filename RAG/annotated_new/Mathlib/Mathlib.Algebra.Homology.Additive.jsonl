{"name":"HomologicalComplex.zero_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\ni : Œπ\n‚ä¢ Eq (HomologicalComplex.Hom.f 0 i) 0","decl":"@[simp]\ntheorem zero_f_apply (i : Œπ) : (0 : C ‚ü∂ D).f i = 0 :=\n  rfl\n\n"}
{"name":"HomologicalComplex.add_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\ni : Œπ\n‚ä¢ Eq ((HAdd.hAdd f g).f i) (HAdd.hAdd (f.f i) (g.f i))","decl":"@[simp]\ntheorem add_f_apply (f g : C ‚ü∂ D) (i : Œπ) : (f + g).f i = f.f i + g.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.neg_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : Quiver.Hom C D\ni : Œπ\n‚ä¢ Eq ((Neg.neg f).f i) (Neg.neg (f.f i))","decl":"@[simp]\ntheorem neg_f_apply (f : C ‚ü∂ D) (i : Œπ) : (-f).f i = -f.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.sub_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\ni : Œπ\n‚ä¢ Eq ((HSub.hSub f g).f i) (HSub.hSub (f.f i) (g.f i))","decl":"@[simp]\ntheorem sub_f_apply (f g : C ‚ü∂ D) (i : Œπ) : (f - g).f i = f.f i - g.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.nsmul_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nn : Nat\nf : Quiver.Hom C D\ni : Œπ\n‚ä¢ Eq ((HSMul.hSMul n f).f i) (HSMul.hSMul n (f.f i))","decl":"@[simp]\ntheorem nsmul_f_apply (n : ‚Ñï) (f : C ‚ü∂ D) (i : Œπ) : (n ‚Ä¢ f).f i = n ‚Ä¢ f.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.zsmul_f_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nn : Int\nf : Quiver.Hom C D\ni : Œπ\n‚ä¢ Eq ((HSMul.hSMul n f).f i) (HSMul.hSMul n (f.f i))","decl":"@[simp]\ntheorem zsmul_f_apply (n : ‚Ñ§) (f : C ‚ü∂ D) (i : Œπ) : (n ‚Ä¢ f).f i = n ‚Ä¢ f.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.fAddMonoidHom_apply","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\ni : Œπ\nf : Quiver.Hom C‚ÇÅ C‚ÇÇ\n‚ä¢ Eq ((HomologicalComplex.Hom.fAddMonoidHom i) f) (f.f i)","decl":"/-- The `i`-th component of a chain map, as an additive map from chain maps to morphisms. -/\n@[simps!]\ndef Hom.fAddMonoidHom {C‚ÇÅ C‚ÇÇ : HomologicalComplex V c} (i : Œπ) : (C‚ÇÅ ‚ü∂ C‚ÇÇ) ‚Üí+ (C‚ÇÅ.X i ‚ü∂ C‚ÇÇ.X i) :=\n  AddMonoidHom.mk' (fun f => Hom.f f i) fun _ _ => rfl\n\n"}
{"name":"HomologicalComplex.eval_additive","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\ni : Œπ\n‚ä¢ (HomologicalComplex.eval V c i).Additive","decl":"instance eval_additive (i : Œπ) : (eval V c i).Additive where\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_map_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù : F.PreservesZeroMorphisms\nc : ComplexShape Œπ\nX‚úù Y‚úù : HomologicalComplex W‚ÇÅ c\nf : Quiver.Hom X‚úù Y‚úù\ni : Œπ\n‚ä¢ Eq (((F.mapHomologicalComplex c).map f).f i) (F.map (f.f i))","decl":"/-- An additive functor induces a functor between homological complexes.\nThis is sometimes called the \"prolongation\".\n-/\n@[simps]\ndef Functor.mapHomologicalComplex (F : W‚ÇÅ ‚•§ W‚ÇÇ) [F.PreservesZeroMorphisms] (c : ComplexShape Œπ) :\n    HomologicalComplex W‚ÇÅ c ‚•§ HomologicalComplex W‚ÇÇ c where\n  obj C :=\n    { X := fun i => F.obj (C.X i)\n      d := fun i j => F.map (C.d i j)\n      shape := fun i j w => by\n        dsimp only\n        rw [C.shape _ _ w, F.map_zero]\n      d_comp_d' := fun i j k _ _ => by rw [‚Üê F.map_comp, C.d_comp_d, F.map_zero] }\n  map f :=\n    { f := fun i => F.map (f.f i)\n      comm' := fun i j _ => by\n        dsimp\n        rw [‚Üê F.map_comp, ‚Üê F.map_comp, f.comm] }\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_obj_d","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù : F.PreservesZeroMorphisms\nc : ComplexShape Œπ\nC : HomologicalComplex W‚ÇÅ c\ni j : Œπ\n‚ä¢ Eq (((F.mapHomologicalComplex c).obj C).d i j) (F.map (C.d i j))","decl":"/-- An additive functor induces a functor between homological complexes.\nThis is sometimes called the \"prolongation\".\n-/\n@[simps]\ndef Functor.mapHomologicalComplex (F : W‚ÇÅ ‚•§ W‚ÇÇ) [F.PreservesZeroMorphisms] (c : ComplexShape Œπ) :\n    HomologicalComplex W‚ÇÅ c ‚•§ HomologicalComplex W‚ÇÇ c where\n  obj C :=\n    { X := fun i => F.obj (C.X i)\n      d := fun i j => F.map (C.d i j)\n      shape := fun i j w => by\n        dsimp only\n        rw [C.shape _ _ w, F.map_zero]\n      d_comp_d' := fun i j k _ _ => by rw [‚Üê F.map_comp, C.d_comp_d, F.map_zero] }\n  map f :=\n    { f := fun i => F.map (f.f i)\n      comm' := fun i j _ => by\n        dsimp\n        rw [‚Üê F.map_comp, ‚Üê F.map_comp, f.comm] }\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_obj_X","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù : F.PreservesZeroMorphisms\nc : ComplexShape Œπ\nC : HomologicalComplex W‚ÇÅ c\ni : Œπ\n‚ä¢ Eq (((F.mapHomologicalComplex c).obj C).X i) (F.obj (C.X i))","decl":"/-- An additive functor induces a functor between homological complexes.\nThis is sometimes called the \"prolongation\".\n-/\n@[simps]\ndef Functor.mapHomologicalComplex (F : W‚ÇÅ ‚•§ W‚ÇÇ) [F.PreservesZeroMorphisms] (c : ComplexShape Œπ) :\n    HomologicalComplex W‚ÇÅ c ‚•§ HomologicalComplex W‚ÇÇ c where\n  obj C :=\n    { X := fun i => F.obj (C.X i)\n      d := fun i j => F.map (C.d i j)\n      shape := fun i j w => by\n        dsimp only\n        rw [C.shape _ _ w, F.map_zero]\n      d_comp_d' := fun i j k _ _ => by rw [‚Üê F.map_comp, C.d_comp_d, F.map_zero] }\n  map f :=\n    { f := fun i => F.map (f.f i)\n      comm' := fun i j _ => by\n        dsimp\n        rw [‚Üê F.map_comp, ‚Üê F.map_comp, f.comm] }\n\n"}
{"name":"CategoryTheory.instPreservesZeroMorphismsHomologicalComplexMapHomologicalComplex","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù : F.PreservesZeroMorphisms\nc : ComplexShape Œπ\n‚ä¢ (F.mapHomologicalComplex c).PreservesZeroMorphisms","decl":"instance (F : W‚ÇÅ ‚•§ W‚ÇÇ) [F.PreservesZeroMorphisms] (c : ComplexShape Œπ) :\n    (F.mapHomologicalComplex c).PreservesZeroMorphisms where\n\n"}
{"name":"CategoryTheory.Functor.map_homogical_complex_additive","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nW : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst‚úù : F.Additive\nc : ComplexShape Œπ\n‚ä¢ (F.mapHomologicalComplex c).Additive","decl":"instance Functor.map_homogical_complex_additive (F : V ‚•§ W) [F.Additive] (c : ComplexShape Œπ) :\n    (F.mapHomologicalComplex c).Additive where\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplexIdIso_hom_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\nc : ComplexShape Œπ\nX : HomologicalComplex W‚ÇÅ c\ni : Œπ\n‚ä¢ Eq (((CategoryTheory.Functor.mapHomologicalComplexIdIso W‚ÇÅ c).hom.app X).f i) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- The functor on homological complexes induced by the identity functor is\nisomorphic to the identity functor. -/\n@[simps!]\ndef Functor.mapHomologicalComplexIdIso (c : ComplexShape Œπ) :\n    (ùü≠ W‚ÇÅ).mapHomologicalComplex c ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun K => Hom.isoOfComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplexIdIso_inv_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\nc : ComplexShape Œπ\nX : HomologicalComplex W‚ÇÅ c\ni : Œπ\n‚ä¢ Eq (((CategoryTheory.Functor.mapHomologicalComplexIdIso W‚ÇÅ c).inv.app X).f i) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- The functor on homological complexes induced by the identity functor is\nisomorphic to the identity functor. -/\n@[simps!]\ndef Functor.mapHomologicalComplexIdIso (c : ComplexShape Œπ) :\n    (ùü≠ W‚ÇÅ).mapHomologicalComplex c ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun K => Hom.isoOfComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_reflects_iso","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : F.ReflectsIsomorphisms\nc : ComplexShape Œπ\n‚ä¢ (F.mapHomologicalComplex c).ReflectsIsomorphisms","decl":"instance Functor.mapHomologicalComplex_reflects_iso (F : W‚ÇÅ ‚•§ W‚ÇÇ) [F.PreservesZeroMorphisms]\n    [ReflectsIsomorphisms F] (c : ComplexShape Œπ) :\n    ReflectsIsomorphisms (F.mapHomologicalComplex c) :=\n  ‚ü®fun f => by\n    intro\n    haveI : ‚àÄ n : Œπ, IsIso (F.map (f.f n)) := fun n =>\n        ((HomologicalComplex.eval W‚ÇÇ c n).mapIso\n          (asIso ((F.mapHomologicalComplex c).map f))).isIso_hom\n    haveI := fun n => isIso_of_reflects_iso (f.f n) F\n    exact HomologicalComplex.Hom.isIso_of_components f‚ü©\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nF G : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : G.PreservesZeroMorphisms\nŒ± : Quiver.Hom F G\nc : ComplexShape Œπ\nC : HomologicalComplex W‚ÇÅ c\nx‚úù : Œπ\n‚ä¢ Eq (((CategoryTheory.NatTrans.mapHomologicalComplex Œ± c).app C).f x‚úù) (Œ±.app (C.X x‚úù))","decl":"/-- A natural transformation between functors induces a natural transformation\nbetween those functors applied to homological complexes.\n-/\n@[simps]\ndef NatTrans.mapHomologicalComplex {F G : W‚ÇÅ ‚•§ W‚ÇÇ}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms] (Œ± : F ‚ü∂ G)\n    (c : ComplexShape Œπ) : F.mapHomologicalComplex c ‚ü∂ G.mapHomologicalComplex c where\n  app C := { f := fun _ => Œ±.app _ }\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_id","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nc : ComplexShape Œπ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù : F.PreservesZeroMorphisms\n‚ä¢ Eq (CategoryTheory.NatTrans.mapHomologicalComplex (CategoryTheory.CategoryStruct.id F) c) (CategoryTheory.CategoryStruct.id (F.mapHomologicalComplex c))","decl":"@[simp]\ntheorem NatTrans.mapHomologicalComplex_id\n    (c : ComplexShape Œπ) (F : W‚ÇÅ ‚•§ W‚ÇÇ) [F.PreservesZeroMorphisms] :\n    NatTrans.mapHomologicalComplex (ùüô F) c = ùüô (F.mapHomologicalComplex c) := by aesop_cat\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_comp","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nc : ComplexShape Œπ\nF G H : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬≤ : F.PreservesZeroMorphisms\ninst‚úù¬π : G.PreservesZeroMorphisms\ninst‚úù : H.PreservesZeroMorphisms\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\n‚ä¢ Eq (CategoryTheory.NatTrans.mapHomologicalComplex (CategoryTheory.CategoryStruct.comp Œ± Œ≤) c) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.mapHomologicalComplex Œ± c) (CategoryTheory.NatTrans.mapHomologicalComplex Œ≤ c))","decl":"@[simp]\ntheorem NatTrans.mapHomologicalComplex_comp (c : ComplexShape Œπ) {F G H : W‚ÇÅ ‚•§ W‚ÇÇ}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms] [H.PreservesZeroMorphisms]\n    (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :\n    NatTrans.mapHomologicalComplex (Œ± ‚â´ Œ≤) c =\n      NatTrans.mapHomologicalComplex Œ± c ‚â´ NatTrans.mapHomologicalComplex Œ≤ c := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_naturality_assoc","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nc : ComplexShape Œπ\nF G : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : G.PreservesZeroMorphisms\nŒ± : Quiver.Hom F G\nC D : HomologicalComplex W‚ÇÅ c\nf : Quiver.Hom C D\nZ : HomologicalComplex W‚ÇÇ c\nh : Quiver.Hom ((G.mapHomologicalComplex c).obj D) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapHomologicalComplex c).map f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.NatTrans.mapHomologicalComplex Œ± c).app D) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.NatTrans.mapHomologicalComplex Œ± c).app C) (CategoryTheory.CategoryStruct.comp ((G.mapHomologicalComplex c).map f) h))","decl":"@[reassoc]\ntheorem NatTrans.mapHomologicalComplex_naturality {c : ComplexShape Œπ} {F G : W‚ÇÅ ‚•§ W‚ÇÇ}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms]\n    (Œ± : F ‚ü∂ G) {C D : HomologicalComplex W‚ÇÅ c} (f : C ‚ü∂ D) :\n    (F.mapHomologicalComplex c).map f ‚â´ (NatTrans.mapHomologicalComplex Œ± c).app D =\n      (NatTrans.mapHomologicalComplex Œ± c).app C ‚â´ (G.mapHomologicalComplex c).map f := by\n  simp\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomologicalComplex_naturality","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nc : ComplexShape Œπ\nF G : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : G.PreservesZeroMorphisms\nŒ± : Quiver.Hom F G\nC D : HomologicalComplex W‚ÇÅ c\nf : Quiver.Hom C D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.mapHomologicalComplex c).map f) ((CategoryTheory.NatTrans.mapHomologicalComplex Œ± c).app D)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.NatTrans.mapHomologicalComplex Œ± c).app C) ((G.mapHomologicalComplex c).map f))","decl":"@[reassoc]\ntheorem NatTrans.mapHomologicalComplex_naturality {c : ComplexShape Œπ} {F G : W‚ÇÅ ‚•§ W‚ÇÇ}\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms]\n    (Œ± : F ‚ü∂ G) {C D : HomologicalComplex W‚ÇÅ c} (f : C ‚ü∂ D) :\n    (F.mapHomologicalComplex c).map f ‚â´ (NatTrans.mapHomologicalComplex Œ± c).app D =\n      (NatTrans.mapHomologicalComplex Œ± c).app C ‚â´ (G.mapHomologicalComplex c).map f := by\n  simp\n\n"}
{"name":"CategoryTheory.NatIso.mapHomologicalComplex_inv_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nF G : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : G.PreservesZeroMorphisms\nŒ± : CategoryTheory.Iso F G\nc : ComplexShape Œπ\nC : HomologicalComplex W‚ÇÅ c\nx‚úù : Œπ\n‚ä¢ Eq (((CategoryTheory.NatIso.mapHomologicalComplex Œ± c).inv.app C).f x‚úù) (Œ±.inv.app (C.X x‚úù))","decl":"/-- A natural isomorphism between functors induces a natural isomorphism\nbetween those functors applied to homological complexes.\n-/\n@[simps!]\ndef NatIso.mapHomologicalComplex {F G : W‚ÇÅ ‚•§ W‚ÇÇ} [F.PreservesZeroMorphisms]\n    [G.PreservesZeroMorphisms] (Œ± : F ‚âÖ G) (c : ComplexShape Œπ) :\n    F.mapHomologicalComplex c ‚âÖ G.mapHomologicalComplex c where\n  hom := NatTrans.mapHomologicalComplex Œ±.hom c\n  inv := NatTrans.mapHomologicalComplex Œ±.inv c\n  hom_inv_id := by simp only [‚Üê NatTrans.mapHomologicalComplex_comp, Œ±.hom_inv_id,\n    NatTrans.mapHomologicalComplex_id]\n  inv_hom_id := by simp only [‚Üê NatTrans.mapHomologicalComplex_comp, Œ±.inv_hom_id,\n    NatTrans.mapHomologicalComplex_id]\n\n"}
{"name":"CategoryTheory.NatIso.mapHomologicalComplex_hom_app_f","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nF G : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : G.PreservesZeroMorphisms\nŒ± : CategoryTheory.Iso F G\nc : ComplexShape Œπ\nC : HomologicalComplex W‚ÇÅ c\nx‚úù : Œπ\n‚ä¢ Eq (((CategoryTheory.NatIso.mapHomologicalComplex Œ± c).hom.app C).f x‚úù) (Œ±.hom.app (C.X x‚úù))","decl":"/-- A natural isomorphism between functors induces a natural isomorphism\nbetween those functors applied to homological complexes.\n-/\n@[simps!]\ndef NatIso.mapHomologicalComplex {F G : W‚ÇÅ ‚•§ W‚ÇÇ} [F.PreservesZeroMorphisms]\n    [G.PreservesZeroMorphisms] (Œ± : F ‚âÖ G) (c : ComplexShape Œπ) :\n    F.mapHomologicalComplex c ‚âÖ G.mapHomologicalComplex c where\n  hom := NatTrans.mapHomologicalComplex Œ±.hom c\n  inv := NatTrans.mapHomologicalComplex Œ±.inv c\n  hom_inv_id := by simp only [‚Üê NatTrans.mapHomologicalComplex_comp, Œ±.hom_inv_id,\n    NatTrans.mapHomologicalComplex_id]\n  inv_hom_id := by simp only [‚Üê NatTrans.mapHomologicalComplex_comp, Œ±.inv_hom_id,\n    NatTrans.mapHomologicalComplex_id]\n\n"}
{"name":"CategoryTheory.Equivalence.mapHomologicalComplex_functor","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\ne : CategoryTheory.Equivalence W‚ÇÅ W‚ÇÇ\ninst‚úù : e.functor.PreservesZeroMorphisms\nc : ComplexShape Œπ\n‚ä¢ Eq (e.mapHomologicalComplex c).functor (e.functor.mapHomologicalComplex c)","decl":"/-- An equivalence of categories induces an equivalences between the respective categories\nof homological complex.\n-/\n@[simps]\ndef Equivalence.mapHomologicalComplex (e : W‚ÇÅ ‚âå W‚ÇÇ) [e.functor.PreservesZeroMorphisms]\n    (c : ComplexShape Œπ) :\n    HomologicalComplex W‚ÇÅ c ‚âå HomologicalComplex W‚ÇÇ c where\n  functor := e.functor.mapHomologicalComplex c\n  inverse := e.inverse.mapHomologicalComplex c\n  unitIso :=\n    (Functor.mapHomologicalComplexIdIso W‚ÇÅ c).symm ‚â™‚â´ NatIso.mapHomologicalComplex e.unitIso c\n  counitIso := NatIso.mapHomologicalComplex e.counitIso c ‚â™‚â´\n  Functor.mapHomologicalComplexIdIso W‚ÇÇ c\n\n"}
{"name":"CategoryTheory.Equivalence.mapHomologicalComplex_counitIso","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\ne : CategoryTheory.Equivalence W‚ÇÅ W‚ÇÇ\ninst‚úù : e.functor.PreservesZeroMorphisms\nc : ComplexShape Œπ\n‚ä¢ Eq (e.mapHomologicalComplex c).counitIso ((CategoryTheory.NatIso.mapHomologicalComplex e.counitIso c).trans (CategoryTheory.Functor.mapHomologicalComplexIdIso W‚ÇÇ c))","decl":"/-- An equivalence of categories induces an equivalences between the respective categories\nof homological complex.\n-/\n@[simps]\ndef Equivalence.mapHomologicalComplex (e : W‚ÇÅ ‚âå W‚ÇÇ) [e.functor.PreservesZeroMorphisms]\n    (c : ComplexShape Œπ) :\n    HomologicalComplex W‚ÇÅ c ‚âå HomologicalComplex W‚ÇÇ c where\n  functor := e.functor.mapHomologicalComplex c\n  inverse := e.inverse.mapHomologicalComplex c\n  unitIso :=\n    (Functor.mapHomologicalComplexIdIso W‚ÇÅ c).symm ‚â™‚â´ NatIso.mapHomologicalComplex e.unitIso c\n  counitIso := NatIso.mapHomologicalComplex e.counitIso c ‚â™‚â´\n  Functor.mapHomologicalComplexIdIso W‚ÇÇ c\n\n"}
{"name":"CategoryTheory.Equivalence.mapHomologicalComplex_unitIso","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\ne : CategoryTheory.Equivalence W‚ÇÅ W‚ÇÇ\ninst‚úù : e.functor.PreservesZeroMorphisms\nc : ComplexShape Œπ\n‚ä¢ Eq (e.mapHomologicalComplex c).unitIso ((CategoryTheory.Functor.mapHomologicalComplexIdIso W‚ÇÅ c).symm.trans (CategoryTheory.NatIso.mapHomologicalComplex e.unitIso c))","decl":"/-- An equivalence of categories induces an equivalences between the respective categories\nof homological complex.\n-/\n@[simps]\ndef Equivalence.mapHomologicalComplex (e : W‚ÇÅ ‚âå W‚ÇÇ) [e.functor.PreservesZeroMorphisms]\n    (c : ComplexShape Œπ) :\n    HomologicalComplex W‚ÇÅ c ‚âå HomologicalComplex W‚ÇÇ c where\n  functor := e.functor.mapHomologicalComplex c\n  inverse := e.inverse.mapHomologicalComplex c\n  unitIso :=\n    (Functor.mapHomologicalComplexIdIso W‚ÇÅ c).symm ‚â™‚â´ NatIso.mapHomologicalComplex e.unitIso c\n  counitIso := NatIso.mapHomologicalComplex e.counitIso c ‚â™‚â´\n  Functor.mapHomologicalComplexIdIso W‚ÇÇ c\n\n"}
{"name":"CategoryTheory.Equivalence.mapHomologicalComplex_inverse","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_3} W‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} W‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\ne : CategoryTheory.Equivalence W‚ÇÅ W‚ÇÇ\ninst‚úù : e.functor.PreservesZeroMorphisms\nc : ComplexShape Œπ\n‚ä¢ Eq (e.mapHomologicalComplex c).inverse (e.inverse.mapHomologicalComplex c)","decl":"/-- An equivalence of categories induces an equivalences between the respective categories\nof homological complex.\n-/\n@[simps]\ndef Equivalence.mapHomologicalComplex (e : W‚ÇÅ ‚âå W‚ÇÇ) [e.functor.PreservesZeroMorphisms]\n    (c : ComplexShape Œπ) :\n    HomologicalComplex W‚ÇÅ c ‚âå HomologicalComplex W‚ÇÇ c where\n  functor := e.functor.mapHomologicalComplex c\n  inverse := e.inverse.mapHomologicalComplex c\n  unitIso :=\n    (Functor.mapHomologicalComplexIdIso W‚ÇÅ c).symm ‚â™‚â´ NatIso.mapHomologicalComplex e.unitIso c\n  counitIso := NatIso.mapHomologicalComplex e.counitIso c ‚â™‚â´\n  Functor.mapHomologicalComplexIdIso W‚ÇÇ c\n\n"}
{"name":"ChainComplex.map_chain_complex_of","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"W‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_3} W‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_7, u_4} W‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\nŒ± : Type u_5\ninst‚úù¬≥ : AddRightCancelSemigroup Œ±\ninst‚úù¬≤ : One Œ±\ninst‚úù¬π : DecidableEq Œ±\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù : F.PreservesZeroMorphisms\nX : Œ± ‚Üí W‚ÇÅ\nd : (n : Œ±) ‚Üí Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d (HAdd.hAdd n 1)) (d n)) 0\n‚ä¢ Eq ((F.mapHomologicalComplex (ComplexShape.down Œ±)).obj (ChainComplex.of X d sq)) (ChainComplex.of (fun n => F.obj (X n)) (fun n => F.map (d n)) ‚ãØ)","decl":"theorem map_chain_complex_of (F : W‚ÇÅ ‚•§ W‚ÇÇ) [F.PreservesZeroMorphisms] (X : Œ± ‚Üí W‚ÇÅ)\n    (d : ‚àÄ n, X (n + 1) ‚ü∂ X n) (sq : ‚àÄ n, d (n + 1) ‚â´ d n = 0) :\n    (F.mapHomologicalComplex _).obj (ChainComplex.of X d sq) =\n      ChainComplex.of (fun n => F.obj (X n)) (fun n => F.map (d n)) fun n => by\n        rw [‚Üê F.map_comp, sq n, Functor.map_zero] := by\n  refine HomologicalComplex.ext rfl ?_\n  rintro i j (rfl : j + 1 = i)\n  simp only [CategoryTheory.Functor.mapHomologicalComplex_obj_d, of_d, eqToHom_refl, comp_id,\n    id_comp]\n\n"}
{"name":"HomologicalComplex.instAdditiveSingle","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nc : ComplexShape Œπ\nW : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_5} W\ninst‚úù¬≤ : CategoryTheory.Preadditive W\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject W\ninst‚úù : DecidableEq Œπ\nj : Œπ\n‚ä¢ (HomologicalComplex.single W c j).Additive","decl":"instance (W : Type*) [Category W] [Preadditive W] [HasZeroObject W] [DecidableEq Œπ] (j : Œπ) :\n    (single W c j).Additive where\n  map_add {_ _ f g} := by ext; simp [single]\n\n"}
{"name":"HomologicalComplex.singleMapHomologicalComplex_hom_app_self","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_3} W‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_4} W‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject W‚ÇÇ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\nc : ComplexShape Œπ\ninst‚úù : DecidableEq Œπ\nj : Œπ\nX : W‚ÇÅ\n‚ä¢ Eq (((HomologicalComplex.singleMapHomologicalComplex F c j).hom.app X).f j) (CategoryTheory.CategoryStruct.comp (F.map (HomologicalComplex.singleObjXSelf c j X).hom) (HomologicalComplex.singleObjXSelf c j (F.obj X)).inv)","decl":"@[simp]\ntheorem singleMapHomologicalComplex_hom_app_self (j : Œπ) (X : W‚ÇÅ) :\n    ((singleMapHomologicalComplex F c j).hom.app X).f j =\n      F.map (singleObjXSelf c j X).hom ‚â´ (singleObjXSelf c j (F.obj X)).inv := by\n  simp [singleMapHomologicalComplex, singleObjXSelf, singleObjXIsoOfEq, eqToHom_map]\n\n"}
{"name":"HomologicalComplex.singleMapHomologicalComplex_hom_app_ne","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_3} W‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_4} W‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject W‚ÇÇ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\nc : ComplexShape Œπ\ninst‚úù : DecidableEq Œπ\ni j : Œπ\nh : Ne i j\nX : W‚ÇÅ\n‚ä¢ Eq (((HomologicalComplex.singleMapHomologicalComplex F c j).hom.app X).f i) 0","decl":"@[simp]\ntheorem singleMapHomologicalComplex_hom_app_ne {i j : Œπ} (h : i ‚â† j) (X : W‚ÇÅ) :\n    ((singleMapHomologicalComplex F c j).hom.app X).f i = 0 := by\n  simp [singleMapHomologicalComplex, h]\n\n"}
{"name":"HomologicalComplex.singleMapHomologicalComplex_inv_app_self","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_3} W‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_4} W‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject W‚ÇÇ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\nc : ComplexShape Œπ\ninst‚úù : DecidableEq Œπ\nj : Œπ\nX : W‚ÇÅ\n‚ä¢ Eq (((HomologicalComplex.singleMapHomologicalComplex F c j).inv.app X).f j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.singleObjXSelf c j (F.obj X)).hom (F.map (HomologicalComplex.singleObjXSelf c j X).inv))","decl":"@[simp]\ntheorem singleMapHomologicalComplex_inv_app_self (j : Œπ) (X : W‚ÇÅ) :\n    ((singleMapHomologicalComplex F c j).inv.app X).f j =\n      (singleObjXSelf c j (F.obj X)).hom ‚â´ F.map (singleObjXSelf c j X).inv := by\n  simp [singleMapHomologicalComplex, singleObjXSelf, singleObjXIsoOfEq, eqToHom_map]\n\n"}
{"name":"HomologicalComplex.singleMapHomologicalComplex_inv_app_ne","module":"Mathlib.Algebra.Homology.Additive","initialProofState":"Œπ : Type u_1\nW‚ÇÅ : Type u_3\nW‚ÇÇ : Type u_4\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_3} W‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_4} W‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms W‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject W‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject W‚ÇÇ\nF : CategoryTheory.Functor W‚ÇÅ W‚ÇÇ\ninst‚úù¬π : F.PreservesZeroMorphisms\nc : ComplexShape Œπ\ninst‚úù : DecidableEq Œπ\ni j : Œπ\nh : Ne i j\nX : W‚ÇÅ\n‚ä¢ Eq (((HomologicalComplex.singleMapHomologicalComplex F c j).inv.app X).f i) 0","decl":"@[simp]\ntheorem singleMapHomologicalComplex_inv_app_ne {i j : Œπ} (h : i ‚â† j) (X : W‚ÇÅ) :\n    ((singleMapHomologicalComplex F c j).inv.app X).f i = 0 := by\n  simp [singleMapHomologicalComplex, h]\n\n"}
