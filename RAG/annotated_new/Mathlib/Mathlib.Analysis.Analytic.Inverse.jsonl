{"name":"FormalMultilinearSeries.leftInv_coeff_zero","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (p.leftInv i x 0) (ContinuousMultilinearMap.uncurry0 𝕜 F x)","decl":"@[simp]\ntheorem leftInv_coeff_zero (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E) :\n    p.leftInv i x 0 = ContinuousMultilinearMap.uncurry0 𝕜 _ x := by rw [leftInv]\n\n"}
{"name":"FormalMultilinearSeries.leftInv_coeff_one","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (p.leftInv i x 1) ((continuousMultilinearCurryFin1 𝕜 F E).symm ↑i.symm)","decl":"@[simp]\ntheorem leftInv_coeff_one (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E) :\n    p.leftInv i x 1 = (continuousMultilinearCurryFin1 𝕜 F E).symm i.symm := by rw [leftInv]\n\n"}
{"name":"FormalMultilinearSeries.leftInv_removeZero","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (p.removeZero.leftInv i x) (p.leftInv i x)","decl":"/-- The left inverse does not depend on the zeroth coefficient of a formal multilinear\nseries. -/\ntheorem leftInv_removeZero (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E) :\n    p.removeZero.leftInv i x = p.leftInv i x := by\n  ext1 n\n  induction' n using Nat.strongRec' with n IH\n  match n with\n  | 0 => simp -- if one replaces `simp` with `refl`, the proof times out in the kernel.\n  | 1 => simp -- TODO: why?\n  | n + 2 =>\n    simp only [leftInv, neg_inj]\n    refine Finset.sum_congr rfl fun c cuniv => ?_\n    rcases c with ⟨c, hc⟩\n    ext v\n    dsimp\n    simp [IH _ hc]\n\n"}
{"name":"FormalMultilinearSeries.leftInv_comp","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\nh : Eq (p 1) ((continuousMultilinearCurryFin1 𝕜 E F).symm ↑i)\n⊢ Eq ((p.leftInv i x).comp p) (FormalMultilinearSeries.id 𝕜 E x)","decl":"/-- The left inverse to a formal multilinear series is indeed a left inverse, provided its linear\nterm is invertible. -/\ntheorem leftInv_comp (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E)\n    (h : p 1 = (continuousMultilinearCurryFin1 𝕜 E F).symm i) :\n    (leftInv p i x).comp p = id 𝕜 E x := by\n  ext n v\n  classical\n  match n with\n  | 0 =>\n    simp only [comp_coeff_zero', leftInv_coeff_zero, ContinuousMultilinearMap.uncurry0_apply,\n      id_apply_zero]\n  | 1 =>\n    simp only [leftInv_coeff_one, comp_coeff_one, h, id_apply_one, ContinuousLinearEquiv.coe_apply,\n      ContinuousLinearEquiv.symm_apply_apply, continuousMultilinearCurryFin1_symm_apply]\n  | n + 2 =>\n    have A :\n      (Finset.univ : Finset (Composition (n + 2))) =\n        {c | Composition.length c < n + 2}.toFinset ∪ {Composition.ones (n + 2)} := by\n      refine Subset.antisymm (fun c _ => ?_) (subset_univ _)\n      by_cases h : c.length < n + 2\n      · simp [h, Set.mem_toFinset (s := {c | Composition.length c < n + 2})]\n      · simp [Composition.eq_ones_iff_le_length.2 (not_lt.1 h)]\n    have B :\n      Disjoint ({c | Composition.length c < n + 2} : Set (Composition (n + 2))).toFinset\n        {Composition.ones (n + 2)} := by\n      simp [Set.mem_toFinset (s := {c | Composition.length c < n + 2})]\n    have C :\n      ((p.leftInv i x (Composition.ones (n + 2)).length)\n          fun j : Fin (Composition.ones n.succ.succ).length =>\n          p 1 fun _ => v ((Fin.castLE (Composition.length_le _)) j)) =\n        p.leftInv i x (n + 2) fun j : Fin (n + 2) => p 1 fun _ => v j := by\n      apply FormalMultilinearSeries.congr _ (Composition.ones_length _) fun j hj1 hj2 => ?_\n      exact FormalMultilinearSeries.congr _ rfl fun k _ _ => by congr\n    have D :\n      (p.leftInv i x (n + 2) fun j : Fin (n + 2) => p 1 fun _ => v j) =\n        -∑ c ∈ {c : Composition (n + 2) | c.length < n + 2}.toFinset,\n            (p.leftInv i x c.length) (p.applyComposition c v) := by\n      simp only [leftInv, ContinuousMultilinearMap.neg_apply, neg_inj,\n        ContinuousMultilinearMap.sum_apply]\n      convert\n        (sum_toFinset_eq_subtype\n          (fun c : Composition (n + 2) => c.length < n + 2)\n          (fun c : Composition (n + 2) =>\n          (ContinuousMultilinearMap.compAlongComposition\n            (p.compContinuousLinearMap (i.symm : F →L[𝕜] E)) c (p.leftInv i x c.length))\n            fun j : Fin (n + 2) => p 1 fun _ : Fin 1 => v j)).symm.trans\n          _\n      simp only [compContinuousLinearMap_applyComposition,\n        ContinuousMultilinearMap.compAlongComposition_apply]\n      congr\n      ext c\n      congr\n      ext k\n      simp [h, Function.comp_def]\n    simp [FormalMultilinearSeries.comp, show n + 2 ≠ 1 by omega, A, Finset.sum_union B,\n      applyComposition_ones, C, D, -Set.toFinset_setOf]\n\n"}
{"name":"FormalMultilinearSeries.rightInv_coeff_zero","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (p.rightInv i x 0) (ContinuousMultilinearMap.uncurry0 𝕜 F x)","decl":"@[simp]\ntheorem rightInv_coeff_zero (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E) :\n    p.rightInv i x 0 = ContinuousMultilinearMap.uncurry0 𝕜 _ x := by rw [rightInv]\n\n"}
{"name":"FormalMultilinearSeries.rightInv_coeff_one","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (p.rightInv i x 1) ((continuousMultilinearCurryFin1 𝕜 F E).symm ↑i.symm)","decl":"@[simp]\ntheorem rightInv_coeff_one (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E) :\n    p.rightInv i x 1 = (continuousMultilinearCurryFin1 𝕜 F E).symm i.symm := by rw [rightInv]\n\n"}
{"name":"FormalMultilinearSeries.rightInv_removeZero","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\n⊢ Eq (p.removeZero.rightInv i x) (p.rightInv i x)","decl":"/-- The right inverse does not depend on the zeroth coefficient of a formal multilinear\nseries. -/\ntheorem rightInv_removeZero (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E) :\n    p.removeZero.rightInv i x = p.rightInv i x := by\n  ext1 n\n  induction' n using Nat.strongRec' with n IH\n  match n with\n  | 0 => simp only [rightInv_coeff_zero]\n  | 1 => simp only [rightInv_coeff_one]\n  | n + 2 =>\n    simp only [rightInv, neg_inj]\n    rw [removeZero_comp_of_pos _ _ (add_pos_of_nonneg_of_pos n.zero_le zero_lt_two)]\n    congr (config := { closePost := false }) 2 with k\n    by_cases hk : k < n + 2 <;> simp [hk, IH]\n\n"}
{"name":"FormalMultilinearSeries.comp_rightInv_aux1","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nhn : LT.lt 0 n\np : FormalMultilinearSeries 𝕜 E F\nq : FormalMultilinearSeries 𝕜 F E\nv : Fin n → F\n⊢ Eq ((p.comp q n) v) (HAdd.hAdd ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => (p c.length) (q.applyComposition c v)) ((p 1) fun x => (q n) v))","decl":"theorem comp_rightInv_aux1 {n : ℕ} (hn : 0 < n) (p : FormalMultilinearSeries 𝕜 E F)\n    (q : FormalMultilinearSeries 𝕜 F E) (v : Fin n → F) :\n    p.comp q n v =\n      ∑ c ∈ {c : Composition n | 1 < c.length}.toFinset,\n          p c.length (q.applyComposition c v) + p 1 fun _ => q n v := by\n  classical\n  have A :\n    (Finset.univ : Finset (Composition n)) =\n      {c | 1 < Composition.length c}.toFinset ∪ {Composition.single n hn} := by\n    refine Subset.antisymm (fun c _ => ?_) (subset_univ _)\n    by_cases h : 1 < c.length\n    · simp [h, Set.mem_toFinset (s := {c | 1 < Composition.length c})]\n    · have : c.length = 1 := by\n        refine (eq_iff_le_not_lt.2 ⟨?_, h⟩).symm; exact c.length_pos_of_pos hn\n      rw [← Composition.eq_single_iff_length hn] at this\n      simp [this]\n  have B :\n    Disjoint ({c | 1 < Composition.length c} : Set (Composition n)).toFinset\n      {Composition.single n hn} := by\n    simp [Set.mem_toFinset (s := {c | 1 < Composition.length c})]\n  have C :\n    p (Composition.single n hn).length (q.applyComposition (Composition.single n hn) v) =\n      p 1 fun _ : Fin 1 => q n v := by\n    apply p.congr (Composition.single_length hn) fun j hj1 _ => ?_\n    simp [applyComposition_single]\n  simp [FormalMultilinearSeries.comp, A, Finset.sum_union B, C, -Set.toFinset_setOf,\n    -add_right_inj, -Composition.single_length]\n\n"}
{"name":"FormalMultilinearSeries.comp_rightInv_aux2","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\nn : Nat\nv : Fin (HAdd.hAdd n 2) → F\n⊢ Eq ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => (p c.length) (FormalMultilinearSeries.applyComposition (fun k => ite (LT.lt k (HAdd.hAdd n 2)) (p.rightInv i x k) 0) c v)) ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => (p c.length) ((p.rightInv i x).applyComposition c v))","decl":"theorem comp_rightInv_aux2 (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E) (n : ℕ)\n    (v : Fin (n + 2) → F) :\n    ∑ c ∈ {c : Composition (n + 2) | 1 < c.length}.toFinset,\n        p c.length (applyComposition (fun k : ℕ => ite (k < n + 2) (p.rightInv i x k) 0) c v) =\n      ∑ c ∈ {c : Composition (n + 2) | 1 < c.length}.toFinset,\n        p c.length ((p.rightInv i x).applyComposition c v) := by\n  have N : 0 < n + 2 := by norm_num\n  refine sum_congr rfl fun c hc => p.congr rfl fun j hj1 hj2 => ?_\n  have : ∀ k, c.blocksFun k < n + 2 := by\n    simp only [Set.mem_toFinset (s := {c : Composition (n + 2) | 1 < c.length}),\n      Set.mem_setOf_eq] at hc\n    simp [← Composition.ne_single_iff N, Composition.eq_single_iff_length, ne_of_gt hc]\n  simp [applyComposition, this]\n\n"}
{"name":"FormalMultilinearSeries.comp_rightInv","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\nh : Eq (p 1) ((continuousMultilinearCurryFin1 𝕜 E F).symm ↑i)\n⊢ Eq (p.comp (p.rightInv i x)) (FormalMultilinearSeries.id 𝕜 F ((p 0) 0))","decl":"/-- The right inverse to a formal multilinear series is indeed a right inverse, provided its linear\nterm is invertible and its constant term vanishes. -/\ntheorem comp_rightInv (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E)\n    (h : p 1 = (continuousMultilinearCurryFin1 𝕜 E F).symm i) :\n    p.comp (rightInv p i x) = id 𝕜 F (p 0 0) := by\n  ext (n v)\n  match n with\n  | 0 =>\n    simp only [comp_coeff_zero', Matrix.zero_empty, id_apply_zero]\n    congr\n    ext i\n    exact i.elim0\n  | 1 =>\n    simp only [comp_coeff_one, h, rightInv_coeff_one, ContinuousLinearEquiv.apply_symm_apply,\n      id_apply_one, ContinuousLinearEquiv.coe_apply, continuousMultilinearCurryFin1_symm_apply]\n  | n + 2 =>\n    have N : 0 < n + 2 := by norm_num\n    simp [comp_rightInv_aux1 N, h, rightInv, lt_irrefl n, show n + 2 ≠ 1 by omega,\n      ← sub_eq_add_neg, sub_eq_zero, comp_rightInv_aux2, -Set.toFinset_setOf]\n\n"}
{"name":"FormalMultilinearSeries.rightInv_coeff","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\nn : Nat\nhn : LE.le 2 n\n⊢ Eq (p.rightInv i x n) (Neg.neg ((↑i.symm).compContinuousMultilinearMap ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => p.compAlongComposition (p.rightInv i x) c)))","decl":"theorem rightInv_coeff (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E)\n    (n : ℕ) (hn : 2 ≤ n) :\n    p.rightInv i x n =\n      -(i.symm : F →L[𝕜] E).compContinuousMultilinearMap\n          (∑ c ∈ ({c | 1 < Composition.length c}.toFinset : Finset (Composition n)),\n            p.compAlongComposition (p.rightInv i x) c) := by\n  match n with\n  | 0 => exact False.elim (zero_lt_two.not_le hn)\n  | 1 => exact False.elim (one_lt_two.not_le hn)\n  | n + 2 =>\n    simp only [rightInv, neg_inj]\n    congr (config := { closePost := false }) 1\n    ext v\n    have N : 0 < n + 2 := by norm_num\n    have : ((p 1) fun _ : Fin 1 => 0) = 0 := ContinuousMultilinearMap.map_zero _\n    simp [comp_rightInv_aux1 N, lt_irrefl n, this, comp_rightInv_aux2, -Set.toFinset_setOf]\n\n"}
{"name":"FormalMultilinearSeries.leftInv_eq_rightInv","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\nh : Eq (p 1) ((continuousMultilinearCurryFin1 𝕜 E F).symm ↑i)\n⊢ Eq (p.leftInv i x) (p.rightInv i x)","decl":"theorem leftInv_eq_rightInv (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (x : E)\n    (h : p 1 = (continuousMultilinearCurryFin1 𝕜 E F).symm i) :\n    leftInv p i x = rightInv p i x :=\n  calc\n    leftInv p i x = (leftInv p i x).comp (id 𝕜 F (p 0 0)) := by simp\n    _ = (leftInv p i x).comp (p.comp (rightInv p i x)) := by rw [comp_rightInv p i _ h]\n    _ = ((leftInv p i x).comp p).comp (rightInv p i x) := by rw [comp_assoc]\n    _ = (id 𝕜 E x).comp (rightInv p i x) := by rw [leftInv_comp p i _ h]\n    _ = rightInv p i x := by simp [id_comp' _ _ 0]\n\n"}
{"name":"FormalMultilinearSeries.radius_right_inv_pos_of_radius_pos_aux1","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"n : Nat\np : Nat → Real\nhp : ∀ (k : Nat), LE.le 0 (p k)\nr a : Real\nhr : LE.le 0 r\nha : LE.le 0 a\n⊢ LE.le ((Finset.Ico 2 (HAdd.hAdd n 1)).sum fun k => HMul.hMul (HPow.hPow a k) ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => HMul.hMul (HPow.hPow r c.length) (Finset.univ.prod fun j => p (c.blocksFun j)))) ((Finset.Ico 2 (HAdd.hAdd n 1)).sum fun j => HMul.hMul (HPow.hPow r j) (HPow.hPow ((Finset.Ico 1 n).sum fun k => HMul.hMul (HPow.hPow a k) (p k)) j))","decl":"/-- First technical lemma to control the growth of coefficients of the inverse. Bound the explicit\nexpression for `∑_{k<n+1} aᵏ Qₖ` in terms of a sum of powers of the same sum one step before,\nin a general abstract setup. -/\ntheorem radius_right_inv_pos_of_radius_pos_aux1 (n : ℕ) (p : ℕ → ℝ) (hp : ∀ k, 0 ≤ p k) {r a : ℝ}\n    (hr : 0 ≤ r) (ha : 0 ≤ a) :\n    ∑ k ∈ Ico 2 (n + 1),\n        a ^ k *\n          ∑ c ∈ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n            r ^ c.length * ∏ j, p (c.blocksFun j) ≤\n      ∑ j ∈ Ico 2 (n + 1), r ^ j * (∑ k ∈ Ico 1 n, a ^ k * p k) ^ j :=\n  calc\n    ∑ k ∈ Ico 2 (n + 1),\n          a ^ k *\n            ∑ c ∈ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n              r ^ c.length * ∏ j, p (c.blocksFun j) =\n        ∑ k ∈ Ico 2 (n + 1),\n          ∑ c ∈ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n            ∏ j, r * (a ^ c.blocksFun j * p (c.blocksFun j)) := by\n      simp_rw [mul_sum]\n      congr! with k _ c\n      rw [prod_mul_distrib, prod_mul_distrib, prod_pow_eq_pow_sum, Composition.sum_blocksFun,\n        prod_const, card_fin]\n      ring\n    _ ≤\n        ∑ d ∈ compPartialSumTarget 2 (n + 1) n,\n          ∏ j : Fin d.2.length, r * (a ^ d.2.blocksFun j * p (d.2.blocksFun j)) := by\n      rw [sum_sigma']\n      refine\n        sum_le_sum_of_subset_of_nonneg ?_ fun x _ _ =>\n          prod_nonneg fun j _ => mul_nonneg hr (mul_nonneg (pow_nonneg ha _) (hp _))\n      rintro ⟨k, c⟩ hd\n      simp only [Set.mem_toFinset (s := {c | 1 < Composition.length c}), mem_Ico, mem_sigma,\n        Set.mem_setOf_eq] at hd\n      simp only [mem_compPartialSumTarget_iff]\n      refine ⟨hd.2, c.length_le.trans_lt hd.1.2, fun j => ?_⟩\n      have : c ≠ Composition.single k (zero_lt_two.trans_le hd.1.1) := by\n        simp [Composition.eq_single_iff_length, ne_of_gt hd.2]\n      rw [Composition.ne_single_iff] at this\n      exact (this j).trans_le (Nat.lt_succ_iff.mp hd.1.2)\n    _ = ∑ e ∈ compPartialSumSource 2 (n + 1) n, ∏ j : Fin e.1, r * (a ^ e.2 j * p (e.2 j)) := by\n      symm\n      apply compChangeOfVariables_sum\n      rintro ⟨k, blocksFun⟩ H\n      have K : (compChangeOfVariables 2 (n + 1) n ⟨k, blocksFun⟩ H).snd.length = k := by simp\n      congr 2 <;> try rw [K]\n      rw [Fin.heq_fun_iff K.symm]\n      intro j\n      rw [compChangeOfVariables_blocksFun]\n    _ = ∑ j ∈ Ico 2 (n + 1), r ^ j * (∑ k ∈ Ico 1 n, a ^ k * p k) ^ j := by\n      rw [compPartialSumSource,\n        ← sum_sigma' (Ico 2 (n + 1))\n          (fun k : ℕ => (Fintype.piFinset fun _ : Fin k => Ico 1 n : Finset (Fin k → ℕ)))\n          (fun n e => ∏ j : Fin n, r * (a ^ e j * p (e j)))]\n      congr! with j\n      simp only [← @MultilinearMap.mkPiAlgebra_apply ℝ (Fin j) _ ℝ]\n      simp only [←\n        MultilinearMap.map_sum_finset (MultilinearMap.mkPiAlgebra ℝ (Fin j) ℝ) fun _ (m : ℕ) =>\n          r * (a ^ m * p m)]\n      simp only [MultilinearMap.mkPiAlgebra_apply]\n      simp [prod_const, ← mul_sum, mul_pow]\n\n"}
{"name":"FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos_aux2","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : Nat\nhn : LE.le 2 (HAdd.hAdd n 1)\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nr a C : Real\nhr : LE.le 0 r\nha : LE.le 0 a\nhC : LE.le 0 C\nhp : ∀ (n : Nat), LE.le (Norm.norm (p n)) (HMul.hMul C (HPow.hPow r n))\n⊢ LE.le ((Finset.Ico 1 (HAdd.hAdd n 1)).sum fun k => HMul.hMul (HPow.hPow a k) (Norm.norm (p.rightInv i x k))) (HAdd.hAdd (HMul.hMul (Norm.norm ↑i.symm) a) (HMul.hMul (HMul.hMul (Norm.norm ↑i.symm) C) ((Finset.Ico 2 (HAdd.hAdd n 1)).sum fun k => HPow.hPow (HMul.hMul r ((Finset.Ico 1 n).sum fun j => HMul.hMul (HPow.hPow a j) (Norm.norm (p.rightInv i x j)))) k)))","decl":"/-- Second technical lemma to control the growth of coefficients of the inverse. Bound the explicit\nexpression for `∑_{k<n+1} aᵏ Qₖ` in terms of a sum of powers of the same sum one step before,\nin the specific setup we are interesting in, by reducing to the general bound in\n`radius_rightInv_pos_of_radius_pos_aux1`. -/\ntheorem radius_rightInv_pos_of_radius_pos_aux2 {x : E} {n : ℕ} (hn : 2 ≤ n + 1)\n    (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) {r a C : ℝ} (hr : 0 ≤ r) (ha : 0 ≤ a)\n    (hC : 0 ≤ C) (hp : ∀ n, ‖p n‖ ≤ C * r ^ n) :\n    ∑ k ∈ Ico 1 (n + 1), a ^ k * ‖p.rightInv i x k‖ ≤\n      ‖(i.symm : F →L[𝕜] E)‖ * a +\n        ‖(i.symm : F →L[𝕜] E)‖ * C *\n          ∑ k ∈ Ico 2 (n + 1), (r * ∑ j ∈ Ico 1 n, a ^ j * ‖p.rightInv i x j‖) ^ k :=\n  let I := ‖(i.symm : F →L[𝕜] E)‖\n  calc\n    ∑ k ∈ Ico 1 (n + 1), a ^ k * ‖p.rightInv i x k‖ =\n        a * I + ∑ k ∈ Ico 2 (n + 1), a ^ k * ‖p.rightInv i x k‖ := by\n      simp only [I, LinearIsometryEquiv.norm_map, pow_one, rightInv_coeff_one,\n        show Ico (1 : ℕ) 2 = {1} from Nat.Ico_succ_singleton 1,\n        sum_singleton, ← sum_Ico_consecutive _ one_le_two hn]\n    _ =\n        a * I +\n          ∑ k ∈ Ico 2 (n + 1),\n            a ^ k *\n              ‖(i.symm : F →L[𝕜] E).compContinuousMultilinearMap\n                  (∑ c ∈ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n                    p.compAlongComposition (p.rightInv i x) c)‖ := by\n      congr! 2 with j hj\n      rw [rightInv_coeff _ _ _ _ (mem_Ico.1 hj).1, norm_neg]\n    _ ≤\n        a * ‖(i.symm : F →L[𝕜] E)‖ +\n          ∑ k ∈ Ico 2 (n + 1),\n            a ^ k *\n              (I *\n                ∑ c ∈ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n                  C * r ^ c.length * ∏ j, ‖p.rightInv i x (c.blocksFun j)‖) := by\n      gcongr with j\n      apply (ContinuousLinearMap.norm_compContinuousMultilinearMap_le _ _).trans\n      gcongr\n      apply (norm_sum_le _ _).trans\n      gcongr\n      apply (compAlongComposition_norm _ _ _).trans\n      gcongr\n      apply hp\n    _ = I * a + I * C * ∑ k ∈ Ico 2 (n + 1), a ^ k *\n          ∑ c ∈ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n            r ^ c.length * ∏ j, ‖p.rightInv i x (c.blocksFun j)‖ := by\n      simp_rw [I, mul_assoc C, ← mul_sum, ← mul_assoc, mul_comm _ ‖(i.symm : F →L[𝕜] E)‖,\n        mul_assoc, ← mul_sum, ← mul_assoc, mul_comm _ C, mul_assoc, ← mul_sum]\n      ring\n    _ ≤ I * a + I * C *\n        ∑ k ∈ Ico 2 (n + 1), (r * ∑ j ∈ Ico 1 n, a ^ j * ‖p.rightInv i x j‖) ^ k := by\n      gcongr _ + _ * _ * ?_\n      simp_rw [mul_pow]\n      apply\n        radius_right_inv_pos_of_radius_pos_aux1 n (fun k => ‖p.rightInv i x k‖)\n          (fun k => norm_nonneg _) hr ha\n\n"}
{"name":"FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\nhp : LT.lt 0 p.radius\n⊢ LT.lt 0 (p.rightInv i x).radius","decl":"/-- If a a formal multilinear series has a positive radius of convergence, then its right inverse\nalso has a positive radius of convergence. -/\ntheorem radius_rightInv_pos_of_radius_pos\n    {p : FormalMultilinearSeries 𝕜 E F} {i : E ≃L[𝕜] F} {x : E}\n    (hp : 0 < p.radius) : 0 < (p.rightInv i x).radius := by\n  obtain ⟨C, r, Cpos, rpos, ple⟩ :\n    ∃ (C r : _) (_ : 0 < C) (_ : 0 < r), ∀ n : ℕ, ‖p n‖ ≤ C * r ^ n :=\n    le_mul_pow_of_radius_pos p hp\n  let I := ‖(i.symm : F →L[𝕜] E)‖\n  -- choose `a` small enough to make sure that `∑_{k ≤ n} aᵏ Qₖ` will be controllable by\n  -- induction\n  obtain ⟨a, apos, ha1, ha2⟩ :\n    ∃ (a : _) (apos : 0 < a),\n      2 * I * C * r ^ 2 * (I + 1) ^ 2 * a ≤ 1 ∧ r * (I + 1) * a ≤ 1 / 2 := by\n    have :\n      Tendsto (fun a => 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a) (𝓝 0)\n        (𝓝 (2 * I * C * r ^ 2 * (I + 1) ^ 2 * 0)) :=\n      tendsto_const_nhds.mul tendsto_id\n    have A : ∀ᶠ a in 𝓝 0, 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a < 1 := by\n      apply (tendsto_order.1 this).2; simp [zero_lt_one]\n    have : Tendsto (fun a => r * (I + 1) * a) (𝓝 0) (𝓝 (r * (I + 1) * 0)) :=\n      tendsto_const_nhds.mul tendsto_id\n    have B : ∀ᶠ a in 𝓝 0, r * (I + 1) * a < 1 / 2 := by\n      apply (tendsto_order.1 this).2; simp [zero_lt_one]\n    have C : ∀ᶠ a in 𝓝[>] (0 : ℝ), (0 : ℝ) < a := by\n      filter_upwards [self_mem_nhdsWithin] with _ ha using ha\n    rcases (C.and ((A.and B).filter_mono inf_le_left)).exists with ⟨a, ha⟩\n    exact ⟨a, ha.1, ha.2.1.le, ha.2.2.le⟩\n  -- check by induction that the partial sums are suitably bounded, using the choice of `a` and the\n  -- inductive control from Lemma `radius_rightInv_pos_of_radius_pos_aux2`.\n  let S n := ∑ k ∈ Ico 1 n, a ^ k * ‖p.rightInv i x k‖\n  have IRec : ∀ n, 1 ≤ n → S n ≤ (I + 1) * a := by\n    apply Nat.le_induction\n    · simp only [S]\n      rw [Ico_eq_empty_of_le (le_refl 1), sum_empty]\n      exact mul_nonneg (add_nonneg (norm_nonneg _) zero_le_one) apos.le\n    · intro n one_le_n hn\n      have In : 2 ≤ n + 1 := by omega\n      have rSn : r * S n ≤ 1 / 2 :=\n        calc\n          r * S n ≤ r * ((I + 1) * a) := by gcongr\n          _ ≤ 1 / 2 := by rwa [← mul_assoc]\n      calc\n        S (n + 1) ≤ I * a + I * C * ∑ k ∈ Ico 2 (n + 1), (r * S n) ^ k :=\n          radius_rightInv_pos_of_radius_pos_aux2 In p i rpos.le apos.le Cpos.le ple\n        _ = I * a + I * C * (((r * S n) ^ 2 - (r * S n) ^ (n + 1)) / (1 - r * S n)) := by\n          rw [geom_sum_Ico' _ In]; exact ne_of_lt (rSn.trans_lt (by norm_num))\n        _ ≤ I * a + I * C * ((r * S n) ^ 2 / (1 / 2)) := by\n          gcongr\n          · simp only [sub_le_self_iff]\n            positivity\n          · linarith only [rSn]\n        _ = I * a + 2 * I * C * (r * S n) ^ 2 := by ring\n        _ ≤ I * a + 2 * I * C * (r * ((I + 1) * a)) ^ 2 := by gcongr\n        _ = (I + 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a) * a := by ring\n        _ ≤ (I + 1) * a := by gcongr\n  -- conclude that all coefficients satisfy `aⁿ Qₙ ≤ (I + 1) a`.\n  let a' : NNReal := ⟨a, apos.le⟩\n  suffices H : (a' : ENNReal) ≤ (p.rightInv i x).radius by\n    apply lt_of_lt_of_le _ H\n    -- Prior to https://github.com/leanprover/lean4/pull/2734, this was `exact_mod_cast apos`.\n    simpa only [ENNReal.coe_pos]\n  apply le_radius_of_eventually_le _ ((I + 1) * a)\n  filter_upwards [Ici_mem_atTop 1] with n (hn : 1 ≤ n)\n  calc\n    ‖p.rightInv i x n‖ * (a' : ℝ) ^ n = a ^ n * ‖p.rightInv i x n‖ := mul_comm _ _\n    _ ≤ ∑ k ∈ Ico 1 (n + 1), a ^ k * ‖p.rightInv i x k‖ :=\n      (haveI : ∀ k ∈ Ico 1 (n + 1), 0 ≤ a ^ k * ‖p.rightInv i x k‖ := fun k _ => by positivity\n      single_le_sum this (by simp [hn]))\n    _ ≤ (I + 1) * a := IRec (n + 1) (by norm_num)\n\n"}
{"name":"FormalMultilinearSeries.radius_leftInv_pos_of_radius_pos","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nx : E\nhp : LT.lt 0 p.radius\nh : Eq (p 1) ((continuousMultilinearCurryFin1 𝕜 E F).symm ↑i)\n⊢ LT.lt 0 (p.leftInv i x).radius","decl":"/-- If a a formal multilinear series has a positive radius of convergence, then its left inverse\nalso has a positive radius of convergence. -/\ntheorem radius_leftInv_pos_of_radius_pos\n    {p : FormalMultilinearSeries 𝕜 E F} {i : E ≃L[𝕜] F} {x : E}\n    (hp : 0 < p.radius) (h : p 1 = (continuousMultilinearCurryFin1 𝕜 E F).symm i) :\n    0 < (p.leftInv i x).radius := by\n  rw [leftInv_eq_rightInv _ _ _ h]\n  exact radius_rightInv_pos_of_radius_pos hp\n\n"}
{"name":"HasFPowerSeriesAt.tendsto_partialSum_prod_of_comp","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f (q.comp p) x\nhq : LT.lt 0 q.radius\nhp : LT.lt 0 p.radius\n⊢ Filter.Eventually (fun y => Filter.Tendsto (fun a => q.partialSum a.1 (HSub.hSub (p.partialSum a.2 y) ((p 0) fun x => 0))) Filter.atTop (nhds (f (HAdd.hAdd x y)))) (nhds 0)","decl":"lemma HasFPowerSeriesAt.tendsto_partialSum_prod_of_comp\n    {f : E → G} {q : FormalMultilinearSeries 𝕜 F G}\n    {p : FormalMultilinearSeries 𝕜 E F} {x : E}\n    (hf : HasFPowerSeriesAt f (q.comp p) x) (hq : 0 < q.radius) (hp : 0 < p.radius) :\n    ∀ᶠ y in 𝓝 0, Tendsto (fun (a : ℕ × ℕ) ↦ q.partialSum a.1 (p.partialSum a.2 y\n      - p 0 (fun _ ↦ 0))) atTop (𝓝 (f (x + y))) := by\n  rcases hf with ⟨r0, h0⟩\n  rcases q.comp_summable_nnreal p hq hp with ⟨r1, r1_pos : 0 < r1, hr1⟩\n  let r : ℝ≥0∞ := min r0 r1\n  have : EMetric.ball (0 : E) r ∈ 𝓝 0 :=\n    EMetric.ball_mem_nhds 0 (lt_min h0.r_pos (by exact_mod_cast r1_pos))\n  filter_upwards [this] with y hy\n  have hy0 : y ∈ EMetric.ball 0 r0 := EMetric.ball_subset_ball (min_le_left _ _) hy\n  have A : HasSum (fun i : Σ n, Composition n => q.compAlongComposition p i.2 fun _j => y)\n      (f (x + y)) := by\n    have cau : CauchySeq fun s : Finset (Σ n, Composition n) =>\n        ∑ i ∈ s, q.compAlongComposition p i.2 fun _j => y := by\n      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr1) _\n      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]\n      rintro ⟨n, c⟩\n      calc\n        ‖(compAlongComposition q p c) fun _j : Fin n => y‖ ≤\n            ‖compAlongComposition q p c‖ * ∏ _j : Fin n, ‖y‖ := by\n          apply ContinuousMultilinearMap.le_opNorm\n        _ ≤ ‖compAlongComposition q p c‖ * (r1 : ℝ) ^ n := by\n          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n          rw [Finset.prod_const, Finset.card_fin]\n          gcongr\n          rw [EMetric.mem_ball, edist_zero_eq_enorm] at hy\n          have := le_trans (le_of_lt hy) (min_le_right _ _)\n          rwa [enorm_le_coe, ← NNReal.coe_le_coe, coe_nnnorm] at this\n    apply HasSum.of_sigma (fun b ↦ hasSum_fintype _) ?_ cau\n    simpa [FormalMultilinearSeries.comp] using h0.hasSum hy0\n  have B : Tendsto (fun (n : ℕ × ℕ) => ∑ i ∈ compPartialSumTarget 0 n.1 n.2,\n      q.compAlongComposition p i.2 fun _j => y) atTop (𝓝 (f (x + y))) := by\n    apply Tendsto.comp A compPartialSumTarget_tendsto_prod_atTop\n  have C : Tendsto (fun (n : ℕ × ℕ) => q.partialSum n.1 (∑ a ∈ Finset.Ico 1 n.2, p a fun _b ↦ y))\n      atTop (𝓝 (f (x + y))) := by simpa [comp_partialSum] using B\n  apply C.congr'\n  filter_upwards [Ici_mem_atTop (0, 1)]\n  rintro ⟨-, n⟩ ⟨-, (hn : 1 ≤ n)⟩\n  congr\n  rw [partialSum, eq_sub_iff_add_eq', Finset.range_eq_Ico,\n        Finset.sum_eq_sum_Ico_succ_bot hn]\n  congr with i\n  exact i.elim0\n\n"}
{"name":"HasFPowerSeriesAt.eventually_hasSum_of_comp","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ng : F → G\nq : FormalMultilinearSeries 𝕜 F G\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhgf : HasFPowerSeriesAt (Function.comp g f) (q.comp p) x\nhf : HasFPowerSeriesAt f p x\nhq : LT.lt 0 q.radius\n⊢ Filter.Eventually (fun y => HasSum (fun n => (q n) fun x_1 => HSub.hSub (f (HAdd.hAdd x y)) (f x)) (g (f (HAdd.hAdd x y)))) (nhds 0)","decl":"lemma HasFPowerSeriesAt.eventually_hasSum_of_comp  {f : E → F} {g : F → G}\n    {q : FormalMultilinearSeries 𝕜 F G} {p : FormalMultilinearSeries 𝕜 E F} {x : E}\n    (hgf : HasFPowerSeriesAt (g ∘ f) (q.comp p) x) (hf : HasFPowerSeriesAt f p x)\n    (hq : 0 < q.radius) :\n    ∀ᶠ y in 𝓝 0, HasSum (fun n : ℕ => q n fun _ : Fin n => (f (x + y) - f x)) (g (f (x + y))) := by\n  have : ∀ᶠ y in 𝓝 (0 : E), f (x + y) - f x ∈ EMetric.ball 0 q.radius := by\n    have A : ContinuousAt (fun y ↦ f (x + y) - f x) 0 := by\n      apply ContinuousAt.sub _ continuousAt_const\n      exact hf.continuousAt.comp_of_eq (continuous_add_left x).continuousAt (by simp)\n    have B : EMetric.ball 0 q.radius ∈ 𝓝 (f (x + 0) - f x) := by\n      simpa using EMetric.ball_mem_nhds _ hq\n    exact A.preimage_mem_nhds B\n  filter_upwards [hgf.tendsto_partialSum_prod_of_comp hq (hf.radius_pos),\n    hf.tendsto_partialSum, this] with y hy h'y h''y\n  have L : Tendsto (fun n ↦ q.partialSum n (f (x + y) - f x)) atTop (𝓝 (g (f (x + y)))) := by\n    apply (closed_nhds_basis (g (f (x + y)))).tendsto_right_iff.2\n    rintro u ⟨hu, u_closed⟩\n    simp only [id_eq, eventually_atTop, ge_iff_le]\n    rcases mem_nhds_iff.1 hu with ⟨v, vu, v_open, hv⟩\n    obtain ⟨a₀, b₀, hab⟩ : ∃ a₀ b₀, ∀ (a b : ℕ), a₀ ≤ a → b₀ ≤ b →\n        q.partialSum a (p.partialSum b y - (p 0) fun _ ↦ 0) ∈ v := by\n      simpa using hy (v_open.mem_nhds hv)\n    refine ⟨a₀, fun a ha ↦ ?_⟩\n    have : Tendsto (fun b ↦ q.partialSum a (p.partialSum b y - (p 0) fun _ ↦ 0)) atTop\n        (𝓝 (q.partialSum a (f (x + y) - f x))) := by\n      have : ContinuousAt (q.partialSum a) (f (x + y) - f x) :=\n        (partialSum_continuous q a).continuousAt\n      apply this.tendsto.comp\n      apply Tendsto.sub h'y\n      convert tendsto_const_nhds\n      exact (HasFPowerSeriesAt.coeff_zero hf fun _ ↦ 0).symm\n    apply u_closed.mem_of_tendsto this\n    filter_upwards [Ici_mem_atTop b₀] with b hb using vu (hab _ _ ha hb)\n  have C : CauchySeq (fun (s : Finset ℕ) ↦ ∑ n ∈ s, q n fun _ : Fin n => (f (x + y) - f x)) := by\n    have Z := q.summable_norm_apply (x := f (x + y) - f x) h''y\n    exact cauchySeq_finset_of_norm_bounded _ Z (fun i ↦ le_rfl)\n  exact tendsto_nhds_of_cauchySeq_of_subseq C tendsto_finset_range L\n\n"}
{"name":"PartialHomeomorph.hasFPowerSeriesAt_symm","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\na : E\ni : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nh0 : Membership.mem f.source a\np : FormalMultilinearSeries 𝕜 E F\nh : HasFPowerSeriesAt (↑f) p a\nhp : Eq (p 1) ((continuousMultilinearCurryFin1 𝕜 E F).symm ↑i)\n⊢ HasFPowerSeriesAt (↑f.symm) (p.leftInv i a) (↑f a)","decl":"/-- If a partial homeomorphism `f` is defined at `a` and has a power series expansion there with\ninvertible linear term, then `f.symm` has a power series expansion at `f a`, given by the inverse\nof the initial power series. -/\ntheorem PartialHomeomorph.hasFPowerSeriesAt_symm (f : PartialHomeomorph E F) {a : E}\n    {i : E ≃L[𝕜] F} (h0 : a ∈ f.source) {p : FormalMultilinearSeries 𝕜 E F}\n    (h : HasFPowerSeriesAt f p a) (hp : p 1 = (continuousMultilinearCurryFin1 𝕜 E F).symm i) :\n    HasFPowerSeriesAt f.symm (p.leftInv i a) (f a) := by\n  have A : HasFPowerSeriesAt (f.symm ∘ f) ((p.leftInv i a).comp p) a := by\n    have : HasFPowerSeriesAt (ContinuousLinearMap.id 𝕜 E) ((p.leftInv i a).comp p) a := by\n      rw [leftInv_comp _ _ _ hp]\n      exact (ContinuousLinearMap.id 𝕜 E).hasFPowerSeriesAt a\n    apply this.congr\n    filter_upwards [f.open_source.mem_nhds h0] with x hx using by simp [hx]\n  have B : ∀ᶠ (y : E) in 𝓝 0, HasSum (fun n ↦ (p.leftInv i a n) fun _ ↦ f (a + y) - f a)\n      (f.symm (f (a + y))) := by\n    simpa using A.eventually_hasSum_of_comp h (radius_leftInv_pos_of_radius_pos h.radius_pos hp)\n  have C : ∀ᶠ (y : E) in 𝓝 a, HasSum (fun n ↦ (p.leftInv i a n) fun _ ↦ f y - f a)\n      (f.symm (f y)) := by\n    rw [← sub_eq_zero_of_eq (a := a) rfl] at B\n    have : ContinuousAt (fun x ↦ x - a) a := by fun_prop\n    simpa using this.preimage_mem_nhds B\n  have D : ∀ᶠ (y : E) in 𝓝 (f.symm (f a)),\n      HasSum (fun n ↦ (p.leftInv i a n) fun _ ↦ f y - f a) y := by\n    simp only [h0, PartialHomeomorph.left_inv]\n    filter_upwards [C, f.open_source.mem_nhds h0] with x hx h'x\n    simpa [h'x] using hx\n  have E : ∀ᶠ z in 𝓝 (f a), HasSum (fun n ↦ (p.leftInv i a n) fun _ ↦ f (f.symm z) - f a)\n      (f.symm z) := by\n    have : ContinuousAt f.symm (f a) := f.continuousAt_symm (f.map_source h0)\n    exact this D\n  have F : ∀ᶠ z in 𝓝 (f a), HasSum (fun n ↦ (p.leftInv i a n) fun _ ↦ z - f a) (f.symm z) := by\n    filter_upwards [f.open_target.mem_nhds (f.map_source h0), E] with z hz h'z\n    simpa [hz] using h'z\n  rcases EMetric.mem_nhds_iff.1 F with ⟨r, r_pos, hr⟩\n  refine ⟨min r (p.leftInv i a).radius, min_le_right _ _,\n    lt_min r_pos (radius_leftInv_pos_of_radius_pos h.radius_pos hp), fun {y} hy ↦ ?_⟩\n  have : y + f a ∈ EMetric.ball (f a) r := by\n    simp only [EMetric.mem_ball, edist_eq_enorm_sub, sub_zero, lt_min_iff,\n      add_sub_cancel_right] at hy ⊢\n    exact hy.1\n  simpa [add_comm] using hr this\n"}
