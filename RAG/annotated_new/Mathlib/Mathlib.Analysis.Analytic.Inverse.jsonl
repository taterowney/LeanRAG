{"name":"FormalMultilinearSeries.leftInv_coeff_zero","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (p.leftInv i x 0) (ContinuousMultilinearMap.uncurry0 ğ•œ F x)","decl":"@[simp]\ntheorem leftInv_coeff_zero (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E) :\n    p.leftInv i x 0 = ContinuousMultilinearMap.uncurry0 ğ•œ _ x := by rw [leftInv]\n\n"}
{"name":"FormalMultilinearSeries.leftInv_coeff_one","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (p.leftInv i x 1) ((continuousMultilinearCurryFin1 ğ•œ F E).symm â†‘i.symm)","decl":"@[simp]\ntheorem leftInv_coeff_one (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E) :\n    p.leftInv i x 1 = (continuousMultilinearCurryFin1 ğ•œ F E).symm i.symm := by rw [leftInv]\n\n"}
{"name":"FormalMultilinearSeries.leftInv_removeZero","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (p.removeZero.leftInv i x) (p.leftInv i x)","decl":"/-- The left inverse does not depend on the zeroth coefficient of a formal multilinear\nseries. -/\ntheorem leftInv_removeZero (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E) :\n    p.removeZero.leftInv i x = p.leftInv i x := by\n  ext1 n\n  induction' n using Nat.strongRec' with n IH\n  match n with\n  | 0 => simp -- if one replaces `simp` with `refl`, the proof times out in the kernel.\n  | 1 => simp -- TODO: why?\n  | n + 2 =>\n    simp only [leftInv, neg_inj]\n    refine Finset.sum_congr rfl fun c cuniv => ?_\n    rcases c with âŸ¨c, hcâŸ©\n    ext v\n    dsimp\n    simp [IH _ hc]\n\n"}
{"name":"FormalMultilinearSeries.leftInv_comp","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nh : Eq (p 1) ((continuousMultilinearCurryFin1 ğ•œ E F).symm â†‘i)\nâŠ¢ Eq ((p.leftInv i x).comp p) (FormalMultilinearSeries.id ğ•œ E x)","decl":"/-- The left inverse to a formal multilinear series is indeed a left inverse, provided its linear\nterm is invertible. -/\ntheorem leftInv_comp (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E)\n    (h : p 1 = (continuousMultilinearCurryFin1 ğ•œ E F).symm i) :\n    (leftInv p i x).comp p = id ğ•œ E x := by\n  ext n v\n  classical\n  match n with\n  | 0 =>\n    simp only [comp_coeff_zero', leftInv_coeff_zero, ContinuousMultilinearMap.uncurry0_apply,\n      id_apply_zero]\n  | 1 =>\n    simp only [leftInv_coeff_one, comp_coeff_one, h, id_apply_one, ContinuousLinearEquiv.coe_apply,\n      ContinuousLinearEquiv.symm_apply_apply, continuousMultilinearCurryFin1_symm_apply]\n  | n + 2 =>\n    have A :\n      (Finset.univ : Finset (Composition (n + 2))) =\n        {c | Composition.length c < n + 2}.toFinset âˆª {Composition.ones (n + 2)} := by\n      refine Subset.antisymm (fun c _ => ?_) (subset_univ _)\n      by_cases h : c.length < n + 2\n      Â· simp [h, Set.mem_toFinset (s := {c | Composition.length c < n + 2})]\n      Â· simp [Composition.eq_ones_iff_le_length.2 (not_lt.1 h)]\n    have B :\n      Disjoint ({c | Composition.length c < n + 2} : Set (Composition (n + 2))).toFinset\n        {Composition.ones (n + 2)} := by\n      simp [Set.mem_toFinset (s := {c | Composition.length c < n + 2})]\n    have C :\n      ((p.leftInv i x (Composition.ones (n + 2)).length)\n          fun j : Fin (Composition.ones n.succ.succ).length =>\n          p 1 fun _ => v ((Fin.castLE (Composition.length_le _)) j)) =\n        p.leftInv i x (n + 2) fun j : Fin (n + 2) => p 1 fun _ => v j := by\n      apply FormalMultilinearSeries.congr _ (Composition.ones_length _) fun j hj1 hj2 => ?_\n      exact FormalMultilinearSeries.congr _ rfl fun k _ _ => by congr\n    have D :\n      (p.leftInv i x (n + 2) fun j : Fin (n + 2) => p 1 fun _ => v j) =\n        -âˆ‘ c âˆˆ {c : Composition (n + 2) | c.length < n + 2}.toFinset,\n            (p.leftInv i x c.length) (p.applyComposition c v) := by\n      simp only [leftInv, ContinuousMultilinearMap.neg_apply, neg_inj,\n        ContinuousMultilinearMap.sum_apply]\n      convert\n        (sum_toFinset_eq_subtype\n          (fun c : Composition (n + 2) => c.length < n + 2)\n          (fun c : Composition (n + 2) =>\n          (ContinuousMultilinearMap.compAlongComposition\n            (p.compContinuousLinearMap (i.symm : F â†’L[ğ•œ] E)) c (p.leftInv i x c.length))\n            fun j : Fin (n + 2) => p 1 fun _ : Fin 1 => v j)).symm.trans\n          _\n      simp only [compContinuousLinearMap_applyComposition,\n        ContinuousMultilinearMap.compAlongComposition_apply]\n      congr\n      ext c\n      congr\n      ext k\n      simp [h, Function.comp_def]\n    simp [FormalMultilinearSeries.comp, show n + 2 â‰  1 by omega, A, Finset.sum_union B,\n      applyComposition_ones, C, D, -Set.toFinset_setOf]\n\n"}
{"name":"FormalMultilinearSeries.rightInv_coeff_zero","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (p.rightInv i x 0) (ContinuousMultilinearMap.uncurry0 ğ•œ F x)","decl":"@[simp]\ntheorem rightInv_coeff_zero (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E) :\n    p.rightInv i x 0 = ContinuousMultilinearMap.uncurry0 ğ•œ _ x := by rw [rightInv]\n\n"}
{"name":"FormalMultilinearSeries.rightInv_coeff_one","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (p.rightInv i x 1) ((continuousMultilinearCurryFin1 ğ•œ F E).symm â†‘i.symm)","decl":"@[simp]\ntheorem rightInv_coeff_one (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E) :\n    p.rightInv i x 1 = (continuousMultilinearCurryFin1 ğ•œ F E).symm i.symm := by rw [rightInv]\n\n"}
{"name":"FormalMultilinearSeries.rightInv_removeZero","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nâŠ¢ Eq (p.removeZero.rightInv i x) (p.rightInv i x)","decl":"/-- The right inverse does not depend on the zeroth coefficient of a formal multilinear\nseries. -/\ntheorem rightInv_removeZero (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E) :\n    p.removeZero.rightInv i x = p.rightInv i x := by\n  ext1 n\n  induction' n using Nat.strongRec' with n IH\n  match n with\n  | 0 => simp only [rightInv_coeff_zero]\n  | 1 => simp only [rightInv_coeff_one]\n  | n + 2 =>\n    simp only [rightInv, neg_inj]\n    rw [removeZero_comp_of_pos _ _ (add_pos_of_nonneg_of_pos n.zero_le zero_lt_two)]\n    congr (config := { closePost := false }) 2 with k\n    by_cases hk : k < n + 2 <;> simp [hk, IH]\n\n"}
{"name":"FormalMultilinearSeries.comp_rightInv_aux1","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nhn : LT.lt 0 n\np : FormalMultilinearSeries ğ•œ E F\nq : FormalMultilinearSeries ğ•œ F E\nv : Fin n â†’ F\nâŠ¢ Eq ((p.comp q n) v) (HAdd.hAdd ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => (p c.length) (q.applyComposition c v)) ((p 1) fun x => (q n) v))","decl":"theorem comp_rightInv_aux1 {n : â„•} (hn : 0 < n) (p : FormalMultilinearSeries ğ•œ E F)\n    (q : FormalMultilinearSeries ğ•œ F E) (v : Fin n â†’ F) :\n    p.comp q n v =\n      âˆ‘ c âˆˆ {c : Composition n | 1 < c.length}.toFinset,\n          p c.length (q.applyComposition c v) + p 1 fun _ => q n v := by\n  classical\n  have A :\n    (Finset.univ : Finset (Composition n)) =\n      {c | 1 < Composition.length c}.toFinset âˆª {Composition.single n hn} := by\n    refine Subset.antisymm (fun c _ => ?_) (subset_univ _)\n    by_cases h : 1 < c.length\n    Â· simp [h, Set.mem_toFinset (s := {c | 1 < Composition.length c})]\n    Â· have : c.length = 1 := by\n        refine (eq_iff_le_not_lt.2 âŸ¨?_, hâŸ©).symm; exact c.length_pos_of_pos hn\n      rw [â† Composition.eq_single_iff_length hn] at this\n      simp [this]\n  have B :\n    Disjoint ({c | 1 < Composition.length c} : Set (Composition n)).toFinset\n      {Composition.single n hn} := by\n    simp [Set.mem_toFinset (s := {c | 1 < Composition.length c})]\n  have C :\n    p (Composition.single n hn).length (q.applyComposition (Composition.single n hn) v) =\n      p 1 fun _ : Fin 1 => q n v := by\n    apply p.congr (Composition.single_length hn) fun j hj1 _ => ?_\n    simp [applyComposition_single]\n  simp [FormalMultilinearSeries.comp, A, Finset.sum_union B, C, -Set.toFinset_setOf,\n    -add_right_inj, -Composition.single_length]\n\n"}
{"name":"FormalMultilinearSeries.comp_rightInv_aux2","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nn : Nat\nv : Fin (HAdd.hAdd n 2) â†’ F\nâŠ¢ Eq ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => (p c.length) (FormalMultilinearSeries.applyComposition (fun k => ite (LT.lt k (HAdd.hAdd n 2)) (p.rightInv i x k) 0) c v)) ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => (p c.length) ((p.rightInv i x).applyComposition c v))","decl":"theorem comp_rightInv_aux2 (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E) (n : â„•)\n    (v : Fin (n + 2) â†’ F) :\n    âˆ‘ c âˆˆ {c : Composition (n + 2) | 1 < c.length}.toFinset,\n        p c.length (applyComposition (fun k : â„• => ite (k < n + 2) (p.rightInv i x k) 0) c v) =\n      âˆ‘ c âˆˆ {c : Composition (n + 2) | 1 < c.length}.toFinset,\n        p c.length ((p.rightInv i x).applyComposition c v) := by\n  have N : 0 < n + 2 := by norm_num\n  refine sum_congr rfl fun c hc => p.congr rfl fun j hj1 hj2 => ?_\n  have : âˆ€ k, c.blocksFun k < n + 2 := by\n    simp only [Set.mem_toFinset (s := {c : Composition (n + 2) | 1 < c.length}),\n      Set.mem_setOf_eq] at hc\n    simp [â† Composition.ne_single_iff N, Composition.eq_single_iff_length, ne_of_gt hc]\n  simp [applyComposition, this]\n\n"}
{"name":"FormalMultilinearSeries.comp_rightInv","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nh : Eq (p 1) ((continuousMultilinearCurryFin1 ğ•œ E F).symm â†‘i)\nâŠ¢ Eq (p.comp (p.rightInv i x)) (FormalMultilinearSeries.id ğ•œ F ((p 0) 0))","decl":"/-- The right inverse to a formal multilinear series is indeed a right inverse, provided its linear\nterm is invertible and its constant term vanishes. -/\ntheorem comp_rightInv (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E)\n    (h : p 1 = (continuousMultilinearCurryFin1 ğ•œ E F).symm i) :\n    p.comp (rightInv p i x) = id ğ•œ F (p 0 0) := by\n  ext (n v)\n  match n with\n  | 0 =>\n    simp only [comp_coeff_zero', Matrix.zero_empty, id_apply_zero]\n    congr\n    ext i\n    exact i.elim0\n  | 1 =>\n    simp only [comp_coeff_one, h, rightInv_coeff_one, ContinuousLinearEquiv.apply_symm_apply,\n      id_apply_one, ContinuousLinearEquiv.coe_apply, continuousMultilinearCurryFin1_symm_apply]\n  | n + 2 =>\n    have N : 0 < n + 2 := by norm_num\n    simp [comp_rightInv_aux1 N, h, rightInv, lt_irrefl n, show n + 2 â‰  1 by omega,\n      â† sub_eq_add_neg, sub_eq_zero, comp_rightInv_aux2, -Set.toFinset_setOf]\n\n"}
{"name":"FormalMultilinearSeries.rightInv_coeff","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nn : Nat\nhn : LE.le 2 n\nâŠ¢ Eq (p.rightInv i x n) (Neg.neg ((â†‘i.symm).compContinuousMultilinearMap ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => p.compAlongComposition (p.rightInv i x) c)))","decl":"theorem rightInv_coeff (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E)\n    (n : â„•) (hn : 2 â‰¤ n) :\n    p.rightInv i x n =\n      -(i.symm : F â†’L[ğ•œ] E).compContinuousMultilinearMap\n          (âˆ‘ c âˆˆ ({c | 1 < Composition.length c}.toFinset : Finset (Composition n)),\n            p.compAlongComposition (p.rightInv i x) c) := by\n  match n with\n  | 0 => exact False.elim (zero_lt_two.not_le hn)\n  | 1 => exact False.elim (one_lt_two.not_le hn)\n  | n + 2 =>\n    simp only [rightInv, neg_inj]\n    congr (config := { closePost := false }) 1\n    ext v\n    have N : 0 < n + 2 := by norm_num\n    have : ((p 1) fun _ : Fin 1 => 0) = 0 := ContinuousMultilinearMap.map_zero _\n    simp [comp_rightInv_aux1 N, lt_irrefl n, this, comp_rightInv_aux2, -Set.toFinset_setOf]\n\n"}
{"name":"FormalMultilinearSeries.leftInv_eq_rightInv","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nh : Eq (p 1) ((continuousMultilinearCurryFin1 ğ•œ E F).symm â†‘i)\nâŠ¢ Eq (p.leftInv i x) (p.rightInv i x)","decl":"theorem leftInv_eq_rightInv (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) (x : E)\n    (h : p 1 = (continuousMultilinearCurryFin1 ğ•œ E F).symm i) :\n    leftInv p i x = rightInv p i x :=\n  calc\n    leftInv p i x = (leftInv p i x).comp (id ğ•œ F (p 0 0)) := by simp\n    _ = (leftInv p i x).comp (p.comp (rightInv p i x)) := by rw [comp_rightInv p i _ h]\n    _ = ((leftInv p i x).comp p).comp (rightInv p i x) := by rw [comp_assoc]\n    _ = (id ğ•œ E x).comp (rightInv p i x) := by rw [leftInv_comp p i _ h]\n    _ = rightInv p i x := by simp [id_comp' _ _ 0]\n\n"}
{"name":"FormalMultilinearSeries.radius_right_inv_pos_of_radius_pos_aux1","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"n : Nat\np : Nat â†’ Real\nhp : âˆ€ (k : Nat), LE.le 0 (p k)\nr a : Real\nhr : LE.le 0 r\nha : LE.le 0 a\nâŠ¢ LE.le ((Finset.Ico 2 (HAdd.hAdd n 1)).sum fun k => HMul.hMul (HPow.hPow a k) ((setOf fun c => LT.lt 1 c.length).toFinset.sum fun c => HMul.hMul (HPow.hPow r c.length) (Finset.univ.prod fun j => p (c.blocksFun j)))) ((Finset.Ico 2 (HAdd.hAdd n 1)).sum fun j => HMul.hMul (HPow.hPow r j) (HPow.hPow ((Finset.Ico 1 n).sum fun k => HMul.hMul (HPow.hPow a k) (p k)) j))","decl":"/-- First technical lemma to control the growth of coefficients of the inverse. Bound the explicit\nexpression for `âˆ‘_{k<n+1} aáµ Qâ‚–` in terms of a sum of powers of the same sum one step before,\nin a general abstract setup. -/\ntheorem radius_right_inv_pos_of_radius_pos_aux1 (n : â„•) (p : â„• â†’ â„) (hp : âˆ€ k, 0 â‰¤ p k) {r a : â„}\n    (hr : 0 â‰¤ r) (ha : 0 â‰¤ a) :\n    âˆ‘ k âˆˆ Ico 2 (n + 1),\n        a ^ k *\n          âˆ‘ c âˆˆ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n            r ^ c.length * âˆ j, p (c.blocksFun j) â‰¤\n      âˆ‘ j âˆˆ Ico 2 (n + 1), r ^ j * (âˆ‘ k âˆˆ Ico 1 n, a ^ k * p k) ^ j :=\n  calc\n    âˆ‘ k âˆˆ Ico 2 (n + 1),\n          a ^ k *\n            âˆ‘ c âˆˆ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n              r ^ c.length * âˆ j, p (c.blocksFun j) =\n        âˆ‘ k âˆˆ Ico 2 (n + 1),\n          âˆ‘ c âˆˆ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n            âˆ j, r * (a ^ c.blocksFun j * p (c.blocksFun j)) := by\n      simp_rw [mul_sum]\n      congr! with k _ c\n      rw [prod_mul_distrib, prod_mul_distrib, prod_pow_eq_pow_sum, Composition.sum_blocksFun,\n        prod_const, card_fin]\n      ring\n    _ â‰¤\n        âˆ‘ d âˆˆ compPartialSumTarget 2 (n + 1) n,\n          âˆ j : Fin d.2.length, r * (a ^ d.2.blocksFun j * p (d.2.blocksFun j)) := by\n      rw [sum_sigma']\n      refine\n        sum_le_sum_of_subset_of_nonneg ?_ fun x _ _ =>\n          prod_nonneg fun j _ => mul_nonneg hr (mul_nonneg (pow_nonneg ha _) (hp _))\n      rintro âŸ¨k, câŸ© hd\n      simp only [Set.mem_toFinset (s := {c | 1 < Composition.length c}), mem_Ico, mem_sigma,\n        Set.mem_setOf_eq] at hd\n      simp only [mem_compPartialSumTarget_iff]\n      refine âŸ¨hd.2, c.length_le.trans_lt hd.1.2, fun j => ?_âŸ©\n      have : c â‰  Composition.single k (zero_lt_two.trans_le hd.1.1) := by\n        simp [Composition.eq_single_iff_length, ne_of_gt hd.2]\n      rw [Composition.ne_single_iff] at this\n      exact (this j).trans_le (Nat.lt_succ_iff.mp hd.1.2)\n    _ = âˆ‘ e âˆˆ compPartialSumSource 2 (n + 1) n, âˆ j : Fin e.1, r * (a ^ e.2 j * p (e.2 j)) := by\n      symm\n      apply compChangeOfVariables_sum\n      rintro âŸ¨k, blocksFunâŸ© H\n      have K : (compChangeOfVariables 2 (n + 1) n âŸ¨k, blocksFunâŸ© H).snd.length = k := by simp\n      congr 2 <;> try rw [K]\n      rw [Fin.heq_fun_iff K.symm]\n      intro j\n      rw [compChangeOfVariables_blocksFun]\n    _ = âˆ‘ j âˆˆ Ico 2 (n + 1), r ^ j * (âˆ‘ k âˆˆ Ico 1 n, a ^ k * p k) ^ j := by\n      rw [compPartialSumSource,\n        â† sum_sigma' (Ico 2 (n + 1))\n          (fun k : â„• => (Fintype.piFinset fun _ : Fin k => Ico 1 n : Finset (Fin k â†’ â„•)))\n          (fun n e => âˆ j : Fin n, r * (a ^ e j * p (e j)))]\n      congr! with j\n      simp only [â† @MultilinearMap.mkPiAlgebra_apply â„ (Fin j) _ â„]\n      simp only [â†\n        MultilinearMap.map_sum_finset (MultilinearMap.mkPiAlgebra â„ (Fin j) â„) fun _ (m : â„•) =>\n          r * (a ^ m * p m)]\n      simp only [MultilinearMap.mkPiAlgebra_apply]\n      simp [prod_const, â† mul_sum, mul_pow]\n\n"}
{"name":"FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos_aux2","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : Nat\nhn : LE.le 2 (HAdd.hAdd n 1)\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nr a C : Real\nhr : LE.le 0 r\nha : LE.le 0 a\nhC : LE.le 0 C\nhp : âˆ€ (n : Nat), LE.le (Norm.norm (p n)) (HMul.hMul C (HPow.hPow r n))\nâŠ¢ LE.le ((Finset.Ico 1 (HAdd.hAdd n 1)).sum fun k => HMul.hMul (HPow.hPow a k) (Norm.norm (p.rightInv i x k))) (HAdd.hAdd (HMul.hMul (Norm.norm â†‘i.symm) a) (HMul.hMul (HMul.hMul (Norm.norm â†‘i.symm) C) ((Finset.Ico 2 (HAdd.hAdd n 1)).sum fun k => HPow.hPow (HMul.hMul r ((Finset.Ico 1 n).sum fun j => HMul.hMul (HPow.hPow a j) (Norm.norm (p.rightInv i x j)))) k)))","decl":"/-- Second technical lemma to control the growth of coefficients of the inverse. Bound the explicit\nexpression for `âˆ‘_{k<n+1} aáµ Qâ‚–` in terms of a sum of powers of the same sum one step before,\nin the specific setup we are interesting in, by reducing to the general bound in\n`radius_rightInv_pos_of_radius_pos_aux1`. -/\ntheorem radius_rightInv_pos_of_radius_pos_aux2 {x : E} {n : â„•} (hn : 2 â‰¤ n + 1)\n    (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F) {r a C : â„} (hr : 0 â‰¤ r) (ha : 0 â‰¤ a)\n    (hC : 0 â‰¤ C) (hp : âˆ€ n, â€–p nâ€– â‰¤ C * r ^ n) :\n    âˆ‘ k âˆˆ Ico 1 (n + 1), a ^ k * â€–p.rightInv i x kâ€– â‰¤\n      â€–(i.symm : F â†’L[ğ•œ] E)â€– * a +\n        â€–(i.symm : F â†’L[ğ•œ] E)â€– * C *\n          âˆ‘ k âˆˆ Ico 2 (n + 1), (r * âˆ‘ j âˆˆ Ico 1 n, a ^ j * â€–p.rightInv i x jâ€–) ^ k :=\n  let I := â€–(i.symm : F â†’L[ğ•œ] E)â€–\n  calc\n    âˆ‘ k âˆˆ Ico 1 (n + 1), a ^ k * â€–p.rightInv i x kâ€– =\n        a * I + âˆ‘ k âˆˆ Ico 2 (n + 1), a ^ k * â€–p.rightInv i x kâ€– := by\n      simp only [I, LinearIsometryEquiv.norm_map, pow_one, rightInv_coeff_one,\n        show Ico (1 : â„•) 2 = {1} from Nat.Ico_succ_singleton 1,\n        sum_singleton, â† sum_Ico_consecutive _ one_le_two hn]\n    _ =\n        a * I +\n          âˆ‘ k âˆˆ Ico 2 (n + 1),\n            a ^ k *\n              â€–(i.symm : F â†’L[ğ•œ] E).compContinuousMultilinearMap\n                  (âˆ‘ c âˆˆ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n                    p.compAlongComposition (p.rightInv i x) c)â€– := by\n      congr! 2 with j hj\n      rw [rightInv_coeff _ _ _ _ (mem_Ico.1 hj).1, norm_neg]\n    _ â‰¤\n        a * â€–(i.symm : F â†’L[ğ•œ] E)â€– +\n          âˆ‘ k âˆˆ Ico 2 (n + 1),\n            a ^ k *\n              (I *\n                âˆ‘ c âˆˆ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n                  C * r ^ c.length * âˆ j, â€–p.rightInv i x (c.blocksFun j)â€–) := by\n      gcongr with j\n      apply (ContinuousLinearMap.norm_compContinuousMultilinearMap_le _ _).trans\n      gcongr\n      apply (norm_sum_le _ _).trans\n      gcongr\n      apply (compAlongComposition_norm _ _ _).trans\n      gcongr\n      apply hp\n    _ = I * a + I * C * âˆ‘ k âˆˆ Ico 2 (n + 1), a ^ k *\n          âˆ‘ c âˆˆ ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n            r ^ c.length * âˆ j, â€–p.rightInv i x (c.blocksFun j)â€– := by\n      simp_rw [I, mul_assoc C, â† mul_sum, â† mul_assoc, mul_comm _ â€–(i.symm : F â†’L[ğ•œ] E)â€–,\n        mul_assoc, â† mul_sum, â† mul_assoc, mul_comm _ C, mul_assoc, â† mul_sum]\n      ring\n    _ â‰¤ I * a + I * C *\n        âˆ‘ k âˆˆ Ico 2 (n + 1), (r * âˆ‘ j âˆˆ Ico 1 n, a ^ j * â€–p.rightInv i x jâ€–) ^ k := by\n      gcongr _ + _ * _ * ?_\n      simp_rw [mul_pow]\n      apply\n        radius_right_inv_pos_of_radius_pos_aux1 n (fun k => â€–p.rightInv i x kâ€–)\n          (fun k => norm_nonneg _) hr ha\n\n"}
{"name":"FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nhp : LT.lt 0 p.radius\nâŠ¢ LT.lt 0 (p.rightInv i x).radius","decl":"/-- If a a formal multilinear series has a positive radius of convergence, then its right inverse\nalso has a positive radius of convergence. -/\ntheorem radius_rightInv_pos_of_radius_pos\n    {p : FormalMultilinearSeries ğ•œ E F} {i : E â‰ƒL[ğ•œ] F} {x : E}\n    (hp : 0 < p.radius) : 0 < (p.rightInv i x).radius := by\n  obtain âŸ¨C, r, Cpos, rpos, pleâŸ© :\n    âˆƒ (C r : _) (_ : 0 < C) (_ : 0 < r), âˆ€ n : â„•, â€–p nâ€– â‰¤ C * r ^ n :=\n    le_mul_pow_of_radius_pos p hp\n  let I := â€–(i.symm : F â†’L[ğ•œ] E)â€–\n  -- choose `a` small enough to make sure that `âˆ‘_{k â‰¤ n} aáµ Qâ‚–` will be controllable by\n  -- induction\n  obtain âŸ¨a, apos, ha1, ha2âŸ© :\n    âˆƒ (a : _) (apos : 0 < a),\n      2 * I * C * r ^ 2 * (I + 1) ^ 2 * a â‰¤ 1 âˆ§ r * (I + 1) * a â‰¤ 1 / 2 := by\n    have :\n      Tendsto (fun a => 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a) (ğ“ 0)\n        (ğ“ (2 * I * C * r ^ 2 * (I + 1) ^ 2 * 0)) :=\n      tendsto_const_nhds.mul tendsto_id\n    have A : âˆ€á¶  a in ğ“ 0, 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a < 1 := by\n      apply (tendsto_order.1 this).2; simp [zero_lt_one]\n    have : Tendsto (fun a => r * (I + 1) * a) (ğ“ 0) (ğ“ (r * (I + 1) * 0)) :=\n      tendsto_const_nhds.mul tendsto_id\n    have B : âˆ€á¶  a in ğ“ 0, r * (I + 1) * a < 1 / 2 := by\n      apply (tendsto_order.1 this).2; simp [zero_lt_one]\n    have C : âˆ€á¶  a in ğ“[>] (0 : â„), (0 : â„) < a := by\n      filter_upwards [self_mem_nhdsWithin] with _ ha using ha\n    rcases (C.and ((A.and B).filter_mono inf_le_left)).exists with âŸ¨a, haâŸ©\n    exact âŸ¨a, ha.1, ha.2.1.le, ha.2.2.leâŸ©\n  -- check by induction that the partial sums are suitably bounded, using the choice of `a` and the\n  -- inductive control from Lemma `radius_rightInv_pos_of_radius_pos_aux2`.\n  let S n := âˆ‘ k âˆˆ Ico 1 n, a ^ k * â€–p.rightInv i x kâ€–\n  have IRec : âˆ€ n, 1 â‰¤ n â†’ S n â‰¤ (I + 1) * a := by\n    apply Nat.le_induction\n    Â· simp only [S]\n      rw [Ico_eq_empty_of_le (le_refl 1), sum_empty]\n      exact mul_nonneg (add_nonneg (norm_nonneg _) zero_le_one) apos.le\n    Â· intro n one_le_n hn\n      have In : 2 â‰¤ n + 1 := by omega\n      have rSn : r * S n â‰¤ 1 / 2 :=\n        calc\n          r * S n â‰¤ r * ((I + 1) * a) := by gcongr\n          _ â‰¤ 1 / 2 := by rwa [â† mul_assoc]\n      calc\n        S (n + 1) â‰¤ I * a + I * C * âˆ‘ k âˆˆ Ico 2 (n + 1), (r * S n) ^ k :=\n          radius_rightInv_pos_of_radius_pos_aux2 In p i rpos.le apos.le Cpos.le ple\n        _ = I * a + I * C * (((r * S n) ^ 2 - (r * S n) ^ (n + 1)) / (1 - r * S n)) := by\n          rw [geom_sum_Ico' _ In]; exact ne_of_lt (rSn.trans_lt (by norm_num))\n        _ â‰¤ I * a + I * C * ((r * S n) ^ 2 / (1 / 2)) := by\n          gcongr\n          Â· simp only [sub_le_self_iff]\n            positivity\n          Â· linarith only [rSn]\n        _ = I * a + 2 * I * C * (r * S n) ^ 2 := by ring\n        _ â‰¤ I * a + 2 * I * C * (r * ((I + 1) * a)) ^ 2 := by gcongr\n        _ = (I + 2 * I * C * r ^ 2 * (I + 1) ^ 2 * a) * a := by ring\n        _ â‰¤ (I + 1) * a := by gcongr\n  -- conclude that all coefficients satisfy `aâ¿ Qâ‚™ â‰¤ (I + 1) a`.\n  let a' : NNReal := âŸ¨a, apos.leâŸ©\n  suffices H : (a' : ENNReal) â‰¤ (p.rightInv i x).radius by\n    apply lt_of_lt_of_le _ H\n    -- Prior to https://github.com/leanprover/lean4/pull/2734, this was `exact_mod_cast apos`.\n    simpa only [ENNReal.coe_pos]\n  apply le_radius_of_eventually_le _ ((I + 1) * a)\n  filter_upwards [Ici_mem_atTop 1] with n (hn : 1 â‰¤ n)\n  calc\n    â€–p.rightInv i x nâ€– * (a' : â„) ^ n = a ^ n * â€–p.rightInv i x nâ€– := mul_comm _ _\n    _ â‰¤ âˆ‘ k âˆˆ Ico 1 (n + 1), a ^ k * â€–p.rightInv i x kâ€– :=\n      (haveI : âˆ€ k âˆˆ Ico 1 (n + 1), 0 â‰¤ a ^ k * â€–p.rightInv i x kâ€– := fun k _ => by positivity\n      single_le_sum this (by simp [hn]))\n    _ â‰¤ (I + 1) * a := IRec (n + 1) (by norm_num)\n\n"}
{"name":"FormalMultilinearSeries.radius_leftInv_pos_of_radius_pos","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nx : E\nhp : LT.lt 0 p.radius\nh : Eq (p 1) ((continuousMultilinearCurryFin1 ğ•œ E F).symm â†‘i)\nâŠ¢ LT.lt 0 (p.leftInv i x).radius","decl":"/-- If a a formal multilinear series has a positive radius of convergence, then its left inverse\nalso has a positive radius of convergence. -/\ntheorem radius_leftInv_pos_of_radius_pos\n    {p : FormalMultilinearSeries ğ•œ E F} {i : E â‰ƒL[ğ•œ] F} {x : E}\n    (hp : 0 < p.radius) (h : p 1 = (continuousMultilinearCurryFin1 ğ•œ E F).symm i) :\n    0 < (p.leftInv i x).radius := by\n  rw [leftInv_eq_rightInv _ _ _ h]\n  exact radius_rightInv_pos_of_radius_pos hp\n\n"}
{"name":"HasFPowerSeriesAt.tendsto_partialSum_prod_of_comp","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f (q.comp p) x\nhq : LT.lt 0 q.radius\nhp : LT.lt 0 p.radius\nâŠ¢ Filter.Eventually (fun y => Filter.Tendsto (fun a => q.partialSum a.1 (HSub.hSub (p.partialSum a.2 y) ((p 0) fun x => 0))) Filter.atTop (nhds (f (HAdd.hAdd x y)))) (nhds 0)","decl":"lemma HasFPowerSeriesAt.tendsto_partialSum_prod_of_comp\n    {f : E â†’ G} {q : FormalMultilinearSeries ğ•œ F G}\n    {p : FormalMultilinearSeries ğ•œ E F} {x : E}\n    (hf : HasFPowerSeriesAt f (q.comp p) x) (hq : 0 < q.radius) (hp : 0 < p.radius) :\n    âˆ€á¶  y in ğ“ 0, Tendsto (fun (a : â„• Ã— â„•) â†¦ q.partialSum a.1 (p.partialSum a.2 y\n      - p 0 (fun _ â†¦ 0))) atTop (ğ“ (f (x + y))) := by\n  rcases hf with âŸ¨r0, h0âŸ©\n  rcases q.comp_summable_nnreal p hq hp with âŸ¨r1, r1_pos : 0 < r1, hr1âŸ©\n  let r : â„â‰¥0âˆ := min r0 r1\n  have : EMetric.ball (0 : E) r âˆˆ ğ“ 0 :=\n    EMetric.ball_mem_nhds 0 (lt_min h0.r_pos (by exact_mod_cast r1_pos))\n  filter_upwards [this] with y hy\n  have hy0 : y âˆˆ EMetric.ball 0 r0 := EMetric.ball_subset_ball (min_le_left _ _) hy\n  have A : HasSum (fun i : Î£ n, Composition n => q.compAlongComposition p i.2 fun _j => y)\n      (f (x + y)) := by\n    have cau : CauchySeq fun s : Finset (Î£ n, Composition n) =>\n        âˆ‘ i âˆˆ s, q.compAlongComposition p i.2 fun _j => y := by\n      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr1) _\n      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]\n      rintro âŸ¨n, câŸ©\n      calc\n        â€–(compAlongComposition q p c) fun _j : Fin n => yâ€– â‰¤\n            â€–compAlongComposition q p câ€– * âˆ _j : Fin n, â€–yâ€– := by\n          apply ContinuousMultilinearMap.le_opNorm\n        _ â‰¤ â€–compAlongComposition q p câ€– * (r1 : â„) ^ n := by\n          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n          rw [Finset.prod_const, Finset.card_fin]\n          gcongr\n          rw [EMetric.mem_ball, edist_zero_eq_enorm] at hy\n          have := le_trans (le_of_lt hy) (min_le_right _ _)\n          rwa [enorm_le_coe, â† NNReal.coe_le_coe, coe_nnnorm] at this\n    apply HasSum.of_sigma (fun b â†¦ hasSum_fintype _) ?_ cau\n    simpa [FormalMultilinearSeries.comp] using h0.hasSum hy0\n  have B : Tendsto (fun (n : â„• Ã— â„•) => âˆ‘ i âˆˆ compPartialSumTarget 0 n.1 n.2,\n      q.compAlongComposition p i.2 fun _j => y) atTop (ğ“ (f (x + y))) := by\n    apply Tendsto.comp A compPartialSumTarget_tendsto_prod_atTop\n  have C : Tendsto (fun (n : â„• Ã— â„•) => q.partialSum n.1 (âˆ‘ a âˆˆ Finset.Ico 1 n.2, p a fun _b â†¦ y))\n      atTop (ğ“ (f (x + y))) := by simpa [comp_partialSum] using B\n  apply C.congr'\n  filter_upwards [Ici_mem_atTop (0, 1)]\n  rintro âŸ¨-, nâŸ© âŸ¨-, (hn : 1 â‰¤ n)âŸ©\n  congr\n  rw [partialSum, eq_sub_iff_add_eq', Finset.range_eq_Ico,\n        Finset.sum_eq_sum_Ico_succ_bot hn]\n  congr with i\n  exact i.elim0\n\n"}
{"name":"HasFPowerSeriesAt.eventually_hasSum_of_comp","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ng : F â†’ G\nq : FormalMultilinearSeries ğ•œ F G\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhgf : HasFPowerSeriesAt (Function.comp g f) (q.comp p) x\nhf : HasFPowerSeriesAt f p x\nhq : LT.lt 0 q.radius\nâŠ¢ Filter.Eventually (fun y => HasSum (fun n => (q n) fun x_1 => HSub.hSub (f (HAdd.hAdd x y)) (f x)) (g (f (HAdd.hAdd x y)))) (nhds 0)","decl":"lemma HasFPowerSeriesAt.eventually_hasSum_of_comp  {f : E â†’ F} {g : F â†’ G}\n    {q : FormalMultilinearSeries ğ•œ F G} {p : FormalMultilinearSeries ğ•œ E F} {x : E}\n    (hgf : HasFPowerSeriesAt (g âˆ˜ f) (q.comp p) x) (hf : HasFPowerSeriesAt f p x)\n    (hq : 0 < q.radius) :\n    âˆ€á¶  y in ğ“ 0, HasSum (fun n : â„• => q n fun _ : Fin n => (f (x + y) - f x)) (g (f (x + y))) := by\n  have : âˆ€á¶  y in ğ“ (0 : E), f (x + y) - f x âˆˆ EMetric.ball 0 q.radius := by\n    have A : ContinuousAt (fun y â†¦ f (x + y) - f x) 0 := by\n      apply ContinuousAt.sub _ continuousAt_const\n      exact hf.continuousAt.comp_of_eq (continuous_add_left x).continuousAt (by simp)\n    have B : EMetric.ball 0 q.radius âˆˆ ğ“ (f (x + 0) - f x) := by\n      simpa using EMetric.ball_mem_nhds _ hq\n    exact A.preimage_mem_nhds B\n  filter_upwards [hgf.tendsto_partialSum_prod_of_comp hq (hf.radius_pos),\n    hf.tendsto_partialSum, this] with y hy h'y h''y\n  have L : Tendsto (fun n â†¦ q.partialSum n (f (x + y) - f x)) atTop (ğ“ (g (f (x + y)))) := by\n    apply (closed_nhds_basis (g (f (x + y)))).tendsto_right_iff.2\n    rintro u âŸ¨hu, u_closedâŸ©\n    simp only [id_eq, eventually_atTop, ge_iff_le]\n    rcases mem_nhds_iff.1 hu with âŸ¨v, vu, v_open, hvâŸ©\n    obtain âŸ¨aâ‚€, bâ‚€, habâŸ© : âˆƒ aâ‚€ bâ‚€, âˆ€ (a b : â„•), aâ‚€ â‰¤ a â†’ bâ‚€ â‰¤ b â†’\n        q.partialSum a (p.partialSum b y - (p 0) fun _ â†¦ 0) âˆˆ v := by\n      simpa using hy (v_open.mem_nhds hv)\n    refine âŸ¨aâ‚€, fun a ha â†¦ ?_âŸ©\n    have : Tendsto (fun b â†¦ q.partialSum a (p.partialSum b y - (p 0) fun _ â†¦ 0)) atTop\n        (ğ“ (q.partialSum a (f (x + y) - f x))) := by\n      have : ContinuousAt (q.partialSum a) (f (x + y) - f x) :=\n        (partialSum_continuous q a).continuousAt\n      apply this.tendsto.comp\n      apply Tendsto.sub h'y\n      convert tendsto_const_nhds\n      exact (HasFPowerSeriesAt.coeff_zero hf fun _ â†¦ 0).symm\n    apply u_closed.mem_of_tendsto this\n    filter_upwards [Ici_mem_atTop bâ‚€] with b hb using vu (hab _ _ ha hb)\n  have C : CauchySeq (fun (s : Finset â„•) â†¦ âˆ‘ n âˆˆ s, q n fun _ : Fin n => (f (x + y) - f x)) := by\n    have Z := q.summable_norm_apply (x := f (x + y) - f x) h''y\n    exact cauchySeq_finset_of_norm_bounded _ Z (fun i â†¦ le_rfl)\n  exact tendsto_nhds_of_cauchySeq_of_subseq C tendsto_finset_range L\n\n"}
{"name":"PartialHomeomorph.hasFPowerSeriesAt_symm","module":"Mathlib.Analysis.Analytic.Inverse","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\na : E\ni : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nh0 : Membership.mem f.source a\np : FormalMultilinearSeries ğ•œ E F\nh : HasFPowerSeriesAt (â†‘f) p a\nhp : Eq (p 1) ((continuousMultilinearCurryFin1 ğ•œ E F).symm â†‘i)\nâŠ¢ HasFPowerSeriesAt (â†‘f.symm) (p.leftInv i a) (â†‘f a)","decl":"/-- If a partial homeomorphism `f` is defined at `a` and has a power series expansion there with\ninvertible linear term, then `f.symm` has a power series expansion at `f a`, given by the inverse\nof the initial power series. -/\ntheorem PartialHomeomorph.hasFPowerSeriesAt_symm (f : PartialHomeomorph E F) {a : E}\n    {i : E â‰ƒL[ğ•œ] F} (h0 : a âˆˆ f.source) {p : FormalMultilinearSeries ğ•œ E F}\n    (h : HasFPowerSeriesAt f p a) (hp : p 1 = (continuousMultilinearCurryFin1 ğ•œ E F).symm i) :\n    HasFPowerSeriesAt f.symm (p.leftInv i a) (f a) := by\n  have A : HasFPowerSeriesAt (f.symm âˆ˜ f) ((p.leftInv i a).comp p) a := by\n    have : HasFPowerSeriesAt (ContinuousLinearMap.id ğ•œ E) ((p.leftInv i a).comp p) a := by\n      rw [leftInv_comp _ _ _ hp]\n      exact (ContinuousLinearMap.id ğ•œ E).hasFPowerSeriesAt a\n    apply this.congr\n    filter_upwards [f.open_source.mem_nhds h0] with x hx using by simp [hx]\n  have B : âˆ€á¶  (y : E) in ğ“ 0, HasSum (fun n â†¦ (p.leftInv i a n) fun _ â†¦ f (a + y) - f a)\n      (f.symm (f (a + y))) := by\n    simpa using A.eventually_hasSum_of_comp h (radius_leftInv_pos_of_radius_pos h.radius_pos hp)\n  have C : âˆ€á¶  (y : E) in ğ“ a, HasSum (fun n â†¦ (p.leftInv i a n) fun _ â†¦ f y - f a)\n      (f.symm (f y)) := by\n    rw [â† sub_eq_zero_of_eq (a := a) rfl] at B\n    have : ContinuousAt (fun x â†¦ x - a) a := by fun_prop\n    simpa using this.preimage_mem_nhds B\n  have D : âˆ€á¶  (y : E) in ğ“ (f.symm (f a)),\n      HasSum (fun n â†¦ (p.leftInv i a n) fun _ â†¦ f y - f a) y := by\n    simp only [h0, PartialHomeomorph.left_inv]\n    filter_upwards [C, f.open_source.mem_nhds h0] with x hx h'x\n    simpa [h'x] using hx\n  have E : âˆ€á¶  z in ğ“ (f a), HasSum (fun n â†¦ (p.leftInv i a n) fun _ â†¦ f (f.symm z) - f a)\n      (f.symm z) := by\n    have : ContinuousAt f.symm (f a) := f.continuousAt_symm (f.map_source h0)\n    exact this D\n  have F : âˆ€á¶  z in ğ“ (f a), HasSum (fun n â†¦ (p.leftInv i a n) fun _ â†¦ z - f a) (f.symm z) := by\n    filter_upwards [f.open_target.mem_nhds (f.map_source h0), E] with z hz h'z\n    simpa [hz] using h'z\n  rcases EMetric.mem_nhds_iff.1 F with âŸ¨r, r_pos, hrâŸ©\n  refine âŸ¨min r (p.leftInv i a).radius, min_le_right _ _,\n    lt_min r_pos (radius_leftInv_pos_of_radius_pos h.radius_pos hp), fun {y} hy â†¦ ?_âŸ©\n  have : y + f a âˆˆ EMetric.ball (f a) r := by\n    simp only [EMetric.mem_ball, edist_eq_enorm_sub, sub_zero, lt_min_iff,\n      add_sub_cancel_right] at hy âŠ¢\n    exact hy.1\n  simpa [add_comm] using hr this\n"}
