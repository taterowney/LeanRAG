{"name":"RatFunc.zero_def","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u_1\ninst✝ : CommRing K\n⊢ Eq RatFunc.zero { toFractionRing := 0 }","decl":"/-- The zero rational function. -/\nprotected irreducible_def zero : RatFunc K :=\n  ⟨0⟩\n\n"}
{"name":"RatFunc.ofFractionRing_zero","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : CommRing K\n⊢ Eq { toFractionRing := 0 } 0","decl":"theorem ofFractionRing_zero : (ofFractionRing 0 : RatFunc K) = 0 :=\n  zero_def.symm\n\n"}
{"name":"RatFunc.add_def","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u_1\ninst✝ : CommRing K\nx✝¹ x✝ : RatFunc K\n⊢ Eq (x✝¹.add x✝) (RatFunc.definition.match_1✝ (fun x x => RatFunc K) x✝¹ x✝ fun p q => { toFractionRing := HAdd.hAdd p q })","decl":"/-- Addition of rational functions. -/\nprotected irreducible_def add : RatFunc K → RatFunc K → RatFunc K\n  | ⟨p⟩, ⟨q⟩ => ⟨p + q⟩\n\n"}
{"name":"RatFunc.ofFractionRing_add","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : CommRing K\np q : FractionRing (Polynomial K)\n⊢ Eq { toFractionRing := HAdd.hAdd p q } (HAdd.hAdd { toFractionRing := p } { toFractionRing := q })","decl":"theorem ofFractionRing_add (p q : FractionRing K[X]) :\n    ofFractionRing (p + q) = ofFractionRing p + ofFractionRing q :=\n  (add_def _ _).symm\n\n"}
{"name":"RatFunc.sub_def","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u_1\ninst✝ : CommRing K\nx✝¹ x✝ : RatFunc K\n⊢ Eq (x✝¹.sub x✝) (RatFunc.definition.match_1✝ (fun x x => RatFunc K) x✝¹ x✝ fun p q => { toFractionRing := HSub.hSub p q })","decl":"/-- Subtraction of rational functions. -/\nprotected irreducible_def sub : RatFunc K → RatFunc K → RatFunc K\n  | ⟨p⟩, ⟨q⟩ => ⟨p - q⟩\n\n"}
{"name":"RatFunc.ofFractionRing_sub","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : CommRing K\np q : FractionRing (Polynomial K)\n⊢ Eq { toFractionRing := HSub.hSub p q } (HSub.hSub { toFractionRing := p } { toFractionRing := q })","decl":"theorem ofFractionRing_sub (p q : FractionRing K[X]) :\n    ofFractionRing (p - q) = ofFractionRing p - ofFractionRing q :=\n  (sub_def _ _).symm\n\n"}
{"name":"RatFunc.neg_def","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u_1\ninst✝ : CommRing K\nx✝ : RatFunc K\n⊢ Eq x✝.neg (RatFunc.definition.match_1✝ (fun x => RatFunc K) x✝ fun p => { toFractionRing := Neg.neg p })","decl":"/-- Additive inverse of a rational function. -/\nprotected irreducible_def neg : RatFunc K → RatFunc K\n  | ⟨p⟩ => ⟨-p⟩\n\n"}
{"name":"RatFunc.ofFractionRing_neg","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : CommRing K\np : FractionRing (Polynomial K)\n⊢ Eq { toFractionRing := Neg.neg p } (Neg.neg { toFractionRing := p })","decl":"theorem ofFractionRing_neg (p : FractionRing K[X]) :\n    ofFractionRing (-p) = -ofFractionRing p :=\n  (neg_def _).symm\n\n"}
{"name":"RatFunc.one_def","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u_1\ninst✝ : CommRing K\n⊢ Eq RatFunc.one { toFractionRing := 1 }","decl":"/-- The multiplicative unit of rational functions. -/\nprotected irreducible_def one : RatFunc K :=\n  ⟨1⟩\n\n"}
{"name":"RatFunc.ofFractionRing_one","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : CommRing K\n⊢ Eq { toFractionRing := 1 } 1","decl":"theorem ofFractionRing_one : (ofFractionRing 1 : RatFunc K) = 1 :=\n  one_def.symm\n\n"}
{"name":"RatFunc.mul_def","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u_1\ninst✝ : CommRing K\nx✝¹ x✝ : RatFunc K\n⊢ Eq (x✝¹.mul x✝) (RatFunc.definition.match_1✝ (fun x x => RatFunc K) x✝¹ x✝ fun p q => { toFractionRing := HMul.hMul p q })","decl":"/-- Multiplication of rational functions. -/\nprotected irreducible_def mul : RatFunc K → RatFunc K → RatFunc K\n  | ⟨p⟩, ⟨q⟩ => ⟨p * q⟩\n\n"}
{"name":"RatFunc.ofFractionRing_mul","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : CommRing K\np q : FractionRing (Polynomial K)\n⊢ Eq { toFractionRing := HMul.hMul p q } (HMul.hMul { toFractionRing := p } { toFractionRing := q })","decl":"theorem ofFractionRing_mul (p q : FractionRing K[X]) :\n    ofFractionRing (p * q) = ofFractionRing p * ofFractionRing q :=\n  (mul_def _ _).symm\n\n"}
{"name":"RatFunc.div_def","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u_1\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nx✝¹ x✝ : RatFunc K\n⊢ Eq (x✝¹.div x✝) (RatFunc.definition.match_1✝ (fun x x => RatFunc K) x✝¹ x✝ fun p q => { toFractionRing := HDiv.hDiv p q })","decl":"/-- Division of rational functions. -/\nprotected irreducible_def div : RatFunc K → RatFunc K → RatFunc K\n  | ⟨p⟩, ⟨q⟩ => ⟨p / q⟩\n\n"}
{"name":"RatFunc.ofFractionRing_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np q : FractionRing (Polynomial K)\n⊢ Eq { toFractionRing := HDiv.hDiv p q } (HDiv.hDiv { toFractionRing := p } { toFractionRing := q })","decl":"theorem ofFractionRing_div (p q : FractionRing K[X]) :\n    ofFractionRing (p / q) = ofFractionRing p / ofFractionRing q :=\n  (div_def _ _).symm\n\n"}
{"name":"RatFunc.inv_def","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u_1\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nx✝ : RatFunc K\n⊢ Eq x✝.inv (RatFunc.definition.match_1✝ (fun x => RatFunc K) x✝ fun p => { toFractionRing := Inv.inv p })","decl":"/-- Multiplicative inverse of a rational function. -/\nprotected irreducible_def inv : RatFunc K → RatFunc K\n  | ⟨p⟩ => ⟨p⁻¹⟩\n\n"}
{"name":"RatFunc.ofFractionRing_inv","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np : FractionRing (Polynomial K)\n⊢ Eq { toFractionRing := Inv.inv p } (Inv.inv { toFractionRing := p })","decl":"theorem ofFractionRing_inv (p : FractionRing K[X]) :\n    ofFractionRing p⁻¹ = (ofFractionRing p)⁻¹ :=\n  (inv_def _).symm\n\n-- Auxiliary lemma for the `Field` instance\n"}
{"name":"RatFunc.mul_inv_cancel","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np : RatFunc K\na✝ : Ne p 0\n⊢ Eq (HMul.hMul p (Inv.inv p)) 1","decl":"theorem mul_inv_cancel : ∀ {p : RatFunc K}, p ≠ 0 → p * p⁻¹ = 1\n  | ⟨p⟩, h => by\n    have : p ≠ 0 := fun hp => h <| by rw [hp, ofFractionRing_zero]\n    simpa only [← ofFractionRing_inv, ← ofFractionRing_mul, ← ofFractionRing_one,\n        ofFractionRing.injEq] using\n      mul_inv_cancel₀ this\n\n"}
{"name":"RatFunc.smul_def","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u_2\ninst✝¹ : CommRing K\nR : Type u_3\ninst✝ : SMul R (FractionRing (Polynomial K))\nx✝¹ : R\nx✝ : RatFunc K\n⊢ Eq (RatFunc.smul x✝¹ x✝) (RatFunc.definition.match_1✝ (fun x x => RatFunc K) x✝¹ x✝ fun r p => { toFractionRing := HSMul.hSMul r p })","decl":"/-- Scalar multiplication of rational functions. -/\nprotected irreducible_def smul [SMul R (FractionRing K[X])] : R → RatFunc K → RatFunc K\n  | r, ⟨p⟩ => ⟨r • p⟩\n\n"}
{"name":"RatFunc.ofFractionRing_smul","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\nR : Type u_1\ninst✝ : SMul R (FractionRing (Polynomial K))\nc : R\np : FractionRing (Polynomial K)\n⊢ Eq { toFractionRing := HSMul.hSMul c p } (HSMul.hSMul c { toFractionRing := p })","decl":"theorem ofFractionRing_smul [SMul R (FractionRing K[X])] (c : R) (p : FractionRing K[X]) :\n    ofFractionRing (c • p) = c • ofFractionRing p :=\n  (smul_def _ _).symm\n\n"}
{"name":"RatFunc.toFractionRing_smul","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\nR : Type u_1\ninst✝ : SMul R (FractionRing (Polynomial K))\nc : R\np : RatFunc K\n⊢ Eq (HSMul.hSMul c p).toFractionRing (HSMul.hSMul c p.toFractionRing)","decl":"theorem toFractionRing_smul [SMul R (FractionRing K[X])] (c : R) (p : RatFunc K) :\n    toFractionRing (c • p) = c • toFractionRing p := by\n  cases p\n  rw [← ofFractionRing_smul]\n\n"}
{"name":"RatFunc.smul_eq_C_smul","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : CommRing K\nx : RatFunc K\nr : K\n⊢ Eq (HSMul.hSMul r x) (HSMul.hSMul (Polynomial.C r) x)","decl":"theorem smul_eq_C_smul (x : RatFunc K) (r : K) : r • x = Polynomial.C r • x := by\n  cases' x with x\n  induction x using Localization.induction_on\n  rw [← ofFractionRing_smul, ← ofFractionRing_smul, Localization.smul_mk,\n    Localization.smul_mk, smul_eq_mul, Polynomial.smul_eq_C_mul]\n\n"}
{"name":"RatFunc.mk_smul","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁴ : CommRing K\nR : Type u_1\ninst✝³ : IsDomain K\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R (Polynomial K)\ninst✝ : IsScalarTower R (Polynomial K) (Polynomial K)\nc : R\np q : Polynomial K\n⊢ Eq (RatFunc.mk (HSMul.hSMul c p) q) (HSMul.hSMul c (RatFunc.mk p q))","decl":"theorem mk_smul (c : R) (p q : K[X]) : RatFunc.mk (c • p) q = c • RatFunc.mk p q := by\n  letI : SMulZeroClass R (FractionRing K[X]) := inferInstance\n  by_cases hq : q = 0\n  · rw [hq, mk_zero, mk_zero, ← ofFractionRing_smul, smul_zero]\n  · rw [mk_eq_localization_mk _ hq, mk_eq_localization_mk _ hq, ← Localization.smul_mk, ←\n      ofFractionRing_smul]\n\n"}
{"name":"RatFunc.instIsScalarTowerPolynomial","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁴ : CommRing K\nR : Type u_1\ninst✝³ : IsDomain K\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R (Polynomial K)\ninst✝ : IsScalarTower R (Polynomial K) (Polynomial K)\n⊢ IsScalarTower R (Polynomial K) (RatFunc K)","decl":"instance : IsScalarTower R K[X] (RatFunc K) :=\n  ⟨fun c p q => q.induction_on' fun q r _ => by rw [← mk_smul, smul_assoc, mk_smul, mk_smul]⟩\n\n"}
{"name":"RatFunc.instSubsingleton","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : Subsingleton K\n⊢ Subsingleton (RatFunc K)","decl":"instance [Subsingleton K] : Subsingleton (RatFunc K) :=\n  toFractionRing_injective.subsingleton\n\n"}
{"name":"RatFunc.instNontrivial","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : Nontrivial K\n⊢ Nontrivial (RatFunc K)","decl":"instance instNontrivial [Nontrivial K] : Nontrivial (RatFunc K) :=\n  ofFractionRing_injective.nontrivial\n\n"}
{"name":"RatFunc.toFractionRingRingEquiv_apply","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : CommRing K\nself : RatFunc K\n⊢ Eq ((RatFunc.toFractionRingRingEquiv K) self) self.toFractionRing","decl":"/-- `RatFunc K` is isomorphic to the field of fractions of `K[X]`, as rings.\n\nThis is an auxiliary definition; `simp`-normal form is `IsLocalization.algEquiv`.\n-/\n@[simps apply]\ndef toFractionRingRingEquiv : RatFunc K ≃+* FractionRing K[X] where\n  toFun := toFractionRing\n  invFun := ofFractionRing\n  left_inv := fun ⟨_⟩ => rfl\n  right_inv _ := rfl\n  map_add' := fun ⟨_⟩ ⟨_⟩ => by simp [← ofFractionRing_add]\n  map_mul' := fun ⟨_⟩ ⟨_⟩ => by simp [← ofFractionRing_mul]\n\n"}
{"name":"RatFunc.map_apply_ofFractionRing_mk","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nF : Type u_5\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : FunLike F (Polynomial R) (Polynomial S)\ninst✝ : MonoidHomClass F (Polynomial R) (Polynomial S)\nφ : F\nhφ : LE.le (nonZeroDivisors (Polynomial R)) (Submonoid.comap φ (nonZeroDivisors (Polynomial S)))\nn : Polynomial R\nd : Subtype fun x => Membership.mem (nonZeroDivisors (Polynomial R)) x\n⊢ Eq ((RatFunc.map φ hφ) { toFractionRing := Localization.mk n d }) { toFractionRing := Localization.mk (φ n) ⟨φ ↑d, ⋯⟩ }","decl":"theorem map_apply_ofFractionRing_mk [MonoidHomClass F R[X] S[X]] (φ : F)\n    (hφ : R[X]⁰ ≤ S[X]⁰.comap φ) (n : R[X]) (d : R[X]⁰) :\n    map φ hφ (ofFractionRing (Localization.mk n d)) =\n      ofFractionRing (Localization.mk (φ n) ⟨φ d, hφ d.prop⟩) := by\n  simp only [map, MonoidHom.coe_mk, OneHom.coe_mk, liftOn_ofFractionRing_mk,\n    Submonoid.mem_comap.mp (hφ d.2), ↓reduceDIte]\n\n"}
{"name":"RatFunc.map_injective","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nF : Type u_5\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : FunLike F (Polynomial R) (Polynomial S)\ninst✝ : MonoidHomClass F (Polynomial R) (Polynomial S)\nφ : F\nhφ : LE.le (nonZeroDivisors (Polynomial R)) (Submonoid.comap φ (nonZeroDivisors (Polynomial S)))\nhf : Function.Injective ⇑φ\n⊢ Function.Injective ⇑(RatFunc.map φ hφ)","decl":"theorem map_injective [MonoidHomClass F R[X] S[X]] (φ : F) (hφ : R[X]⁰ ≤ S[X]⁰.comap φ)\n    (hf : Function.Injective φ) : Function.Injective (map φ hφ) := by\n  rintro ⟨x⟩ ⟨y⟩ h\n  induction x using Localization.induction_on\n  induction y using Localization.induction_on\n  simpa only [map_apply_ofFractionRing_mk, ofFractionRing_injective.eq_iff,\n    Localization.mk_eq_mk_iff, Localization.r_iff_exists, mul_cancel_left_coe_nonZeroDivisors,\n    exists_const, ← map_mul, hf.eq_iff] using h\n\n"}
{"name":"RatFunc.coe_mapRingHom_eq_coe_map","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nF : Type u_5\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : FunLike F (Polynomial R) (Polynomial S)\ninst✝ : RingHomClass F (Polynomial R) (Polynomial S)\nφ : F\nhφ : LE.le (nonZeroDivisors (Polynomial R)) (Submonoid.comap φ (nonZeroDivisors (Polynomial S)))\n⊢ Eq ⇑(RatFunc.mapRingHom φ hφ) ⇑(RatFunc.map φ hφ)","decl":"theorem coe_mapRingHom_eq_coe_map [RingHomClass F R[X] S[X]] (φ : F) (hφ : R[X]⁰ ≤ S[X]⁰.comap φ) :\n    (mapRingHom φ hφ : RatFunc R → RatFunc S) = map φ hφ :=\n  rfl\n\n-- TODO: Generalize to `FunLike` classes,\n"}
{"name":"RatFunc.liftMonoidWithZeroHom_apply_ofFractionRing_mk","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"G₀ : Type u_1\nR : Type u_3\ninst✝¹ : CommGroupWithZero G₀\ninst✝ : CommRing R\nφ : MonoidWithZeroHom (Polynomial R) G₀\nhφ : LE.le (nonZeroDivisors (Polynomial R)) (Submonoid.comap φ (nonZeroDivisors G₀))\nn : Polynomial R\nd : Subtype fun x => Membership.mem (nonZeroDivisors (Polynomial R)) x\n⊢ Eq ((RatFunc.liftMonoidWithZeroHom φ hφ) { toFractionRing := Localization.mk n d }) (HDiv.hDiv (φ n) (φ ↑d))","decl":"theorem liftMonoidWithZeroHom_apply_ofFractionRing_mk (φ : R[X] →*₀ G₀) (hφ : R[X]⁰ ≤ G₀⁰.comap φ)\n    (n : R[X]) (d : R[X]⁰) :\n    liftMonoidWithZeroHom φ hφ (ofFractionRing (Localization.mk n d)) = φ n / φ d :=\n  liftOn_ofFractionRing_mk _ _ _ _\n\n"}
{"name":"RatFunc.liftMonoidWithZeroHom_injective","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"G₀ : Type u_1\nR : Type u_3\ninst✝² : CommGroupWithZero G₀\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\nφ : MonoidWithZeroHom (Polynomial R) G₀\nhφ : Function.Injective ⇑φ\nhφ' : optParam (LE.le (nonZeroDivisors (Polynomial R)) (Submonoid.comap φ (nonZeroDivisors G₀))) ⋯\n⊢ Function.Injective ⇑(RatFunc.liftMonoidWithZeroHom φ hφ')","decl":"theorem liftMonoidWithZeroHom_injective [Nontrivial R] (φ : R[X] →*₀ G₀) (hφ : Function.Injective φ)\n    (hφ' : R[X]⁰ ≤ G₀⁰.comap φ := nonZeroDivisors_le_comap_nonZeroDivisors_of_injective _ hφ) :\n    Function.Injective (liftMonoidWithZeroHom φ hφ') := by\n  rintro ⟨x⟩ ⟨y⟩\n  induction' x using Localization.induction_on with a\n  induction' y using Localization.induction_on with a'\n  simp_rw [liftMonoidWithZeroHom_apply_ofFractionRing_mk]\n  intro h\n  congr 1\n  refine Localization.mk_eq_mk_iff.mpr (Localization.r_of_eq (M := R[X]) ?_)\n  have := mul_eq_mul_of_div_eq_div _ _ ?_ ?_ h\n  · rwa [← map_mul, ← map_mul, hφ.eq_iff, mul_comm, mul_comm a'.fst] at this\n  all_goals exact map_ne_zero_of_mem_nonZeroDivisors _ hφ (SetLike.coe_mem _)\n\n"}
{"name":"RatFunc.liftRingHom_apply_ofFractionRing_mk","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"L : Type u_2\nR : Type u_3\ninst✝¹ : Field L\ninst✝ : CommRing R\nφ : RingHom (Polynomial R) L\nhφ : LE.le (nonZeroDivisors (Polynomial R)) (Submonoid.comap φ (nonZeroDivisors L))\nn : Polynomial R\nd : Subtype fun x => Membership.mem (nonZeroDivisors (Polynomial R)) x\n⊢ Eq ((RatFunc.liftRingHom φ hφ) { toFractionRing := Localization.mk n d }) (HDiv.hDiv (φ n) (φ ↑d))","decl":"theorem liftRingHom_apply_ofFractionRing_mk (φ : R[X] →+* L) (hφ : R[X]⁰ ≤ L⁰.comap φ) (n : R[X])\n    (d : R[X]⁰) : liftRingHom φ hφ (ofFractionRing (Localization.mk n d)) = φ n / φ d :=\n  liftMonoidWithZeroHom_apply_ofFractionRing_mk _ hφ _ _\n\n"}
{"name":"RatFunc.liftRingHom_injective","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"L : Type u_2\nR : Type u_3\ninst✝² : Field L\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\nφ : RingHom (Polynomial R) L\nhφ : Function.Injective ⇑φ\nhφ' : optParam (LE.le (nonZeroDivisors (Polynomial R)) (Submonoid.comap φ (nonZeroDivisors L))) ⋯\n⊢ Function.Injective ⇑(RatFunc.liftRingHom φ hφ')","decl":"theorem liftRingHom_injective [Nontrivial R] (φ : R[X] →+* L) (hφ : Function.Injective φ)\n    (hφ' : R[X]⁰ ≤ L⁰.comap φ := nonZeroDivisors_le_comap_nonZeroDivisors_of_injective _ hφ) :\n    Function.Injective (liftRingHom φ hφ') :=\n  liftMonoidWithZeroHom_injective _ hφ\n\n"}
{"name":"RatFunc.mk_one","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nx : Polynomial K\n⊢ Eq (RatFunc.mk x 1) ((algebraMap (Polynomial K) (RatFunc K)) x)","decl":"theorem mk_one (x : K[X]) : RatFunc.mk x 1 = algebraMap _ _ x :=\n  rfl\n\n"}
{"name":"RatFunc.ofFractionRing_algebraMap","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nx : Polynomial K\n⊢ Eq { toFractionRing := (algebraMap (Polynomial K) (FractionRing (Polynomial K))) x } ((algebraMap (Polynomial K) (RatFunc K)) x)","decl":"theorem ofFractionRing_algebraMap (x : K[X]) :\n    ofFractionRing (algebraMap _ (FractionRing K[X]) x) = algebraMap _ _ x := by\n  rw [← mk_one, mk_one']\n\n"}
{"name":"RatFunc.mk_eq_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\np q : Polynomial K\n⊢ Eq (RatFunc.mk p q) (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q))","decl":"@[simp]\ntheorem mk_eq_div (p q : K[X]) : RatFunc.mk p q = algebraMap _ _ p / algebraMap _ _ q := by\n  simp only [mk_eq_div', ofFractionRing_div, ofFractionRing_algebraMap]\n\n"}
{"name":"RatFunc.div_smul","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁴ : CommRing K\ninst✝³ : IsDomain K\nR : Type u_1\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R (Polynomial K)\ninst✝ : IsScalarTower R (Polynomial K) (Polynomial K)\nc : R\np q : Polynomial K\n⊢ Eq (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) (HSMul.hSMul c p)) ((algebraMap (Polynomial K) (RatFunc K)) q)) (HSMul.hSMul c (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)))","decl":"@[simp]\ntheorem div_smul {R} [Monoid R] [DistribMulAction R K[X]] [IsScalarTower R K[X] K[X]] (c : R)\n    (p q : K[X]) :\n    algebraMap _ (RatFunc K) (c • p) / algebraMap _ _ q =\n      c • (algebraMap _ _ p / algebraMap _ _ q) := by\n  rw [← mk_eq_div, mk_smul, mk_eq_div]\n\n"}
{"name":"RatFunc.algebraMap_apply","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝³ : CommRing K\ninst✝² : IsDomain K\nR : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Algebra R (Polynomial K)\nx : R\n⊢ Eq ((algebraMap R (RatFunc K)) x) (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) ((algebraMap R (Polynomial K)) x)) ((algebraMap (Polynomial K) (RatFunc K)) 1))","decl":"theorem algebraMap_apply {R : Type*} [CommSemiring R] [Algebra R K[X]] (x : R) :\n    algebraMap R (RatFunc K) x = algebraMap _ _ (algebraMap R K[X] x) / algebraMap K[X] _ 1 := by\n  rw [← mk_eq_div]\n  rfl\n\n"}
{"name":"RatFunc.map_apply_div_ne_zero","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁵ : CommRing K\ninst✝⁴ : IsDomain K\nR : Type u_1\nF : Type u_2\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : FunLike F (Polynomial K) (Polynomial R)\ninst✝ : MonoidHomClass F (Polynomial K) (Polynomial R)\nφ : F\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors (Polynomial R)))\np q : Polynomial K\nhq : Ne q 0\n⊢ Eq ((RatFunc.map φ hφ) (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q))) (HDiv.hDiv ((algebraMap (Polynomial R) (RatFunc R)) (φ p)) ((algebraMap (Polynomial R) (RatFunc R)) (φ q)))","decl":"theorem map_apply_div_ne_zero {R F : Type*} [CommRing R] [IsDomain R]\n    [FunLike F K[X] R[X]] [MonoidHomClass F K[X] R[X]]\n    (φ : F) (hφ : K[X]⁰ ≤ R[X]⁰.comap φ) (p q : K[X]) (hq : q ≠ 0) :\n    map φ hφ (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (φ p) / algebraMap _ _ (φ q) := by\n  have hq' : φ q ≠ 0 := nonZeroDivisors.ne_zero (hφ (mem_nonZeroDivisors_iff_ne_zero.mpr hq))\n  simp only [← mk_eq_div, mk_eq_localization_mk _ hq, map_apply_ofFractionRing_mk,\n    mk_eq_localization_mk _ hq']\n\n"}
{"name":"RatFunc.map_apply_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁵ : CommRing K\ninst✝⁴ : IsDomain K\nR : Type u_1\nF : Type u_2\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : FunLike F (Polynomial K) (Polynomial R)\ninst✝ : MonoidWithZeroHomClass F (Polynomial K) (Polynomial R)\nφ : F\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors (Polynomial R)))\np q : Polynomial K\n⊢ Eq ((RatFunc.map φ hφ) (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q))) (HDiv.hDiv ((algebraMap (Polynomial R) (RatFunc R)) (φ p)) ((algebraMap (Polynomial R) (RatFunc R)) (φ q)))","decl":"@[simp]\ntheorem map_apply_div {R F : Type*} [CommRing R] [IsDomain R]\n    [FunLike F K[X] R[X]] [MonoidWithZeroHomClass F K[X] R[X]]\n    (φ : F) (hφ : K[X]⁰ ≤ R[X]⁰.comap φ) (p q : K[X]) :\n    map φ hφ (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (φ p) / algebraMap _ _ (φ q) := by\n  rcases eq_or_ne q 0 with (rfl | hq)\n  · have : (0 : RatFunc K) = algebraMap K[X] _ 0 / algebraMap K[X] _ 1 := by simp\n    rw [map_zero, map_zero, map_zero, div_zero, div_zero, this, map_apply_div_ne_zero, map_one,\n      map_one, div_one, map_zero, map_zero]\n    exact one_ne_zero\n  exact map_apply_div_ne_zero _ _ _ _ hq\n\n"}
{"name":"RatFunc.liftMonoidWithZeroHom_apply_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝² : CommRing K\ninst✝¹ : IsDomain K\nL : Type u_1\ninst✝ : CommGroupWithZero L\nφ : MonoidWithZeroHom (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\np q : Polynomial K\n⊢ Eq ((RatFunc.liftMonoidWithZeroHom φ hφ) (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q))) (HDiv.hDiv (φ p) (φ q))","decl":"theorem liftMonoidWithZeroHom_apply_div {L : Type*} [CommGroupWithZero L]\n    (φ : MonoidWithZeroHom K[X] L) (hφ : K[X]⁰ ≤ L⁰.comap φ) (p q : K[X]) :\n    liftMonoidWithZeroHom φ hφ (algebraMap _ _ p / algebraMap _ _ q) = φ p / φ q := by\n  rcases eq_or_ne q 0 with (rfl | hq)\n  · simp only [div_zero, map_zero]\n  simp only [← mk_eq_div, mk_eq_localization_mk _ hq,\n    liftMonoidWithZeroHom_apply_ofFractionRing_mk]\n\n"}
{"name":"RatFunc.liftMonoidWithZeroHom_apply_div'","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝² : CommRing K\ninst✝¹ : IsDomain K\nL : Type u_1\ninst✝ : CommGroupWithZero L\nφ : MonoidWithZeroHom (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\np q : Polynomial K\n⊢ Eq (HDiv.hDiv ((RatFunc.liftMonoidWithZeroHom φ hφ) ((algebraMap (Polynomial K) (RatFunc K)) p)) ((RatFunc.liftMonoidWithZeroHom φ hφ) ((algebraMap (Polynomial K) (RatFunc K)) q))) (HDiv.hDiv (φ p) (φ q))","decl":"@[simp]\ntheorem liftMonoidWithZeroHom_apply_div' {L : Type*} [CommGroupWithZero L]\n    (φ : MonoidWithZeroHom K[X] L) (hφ : K[X]⁰ ≤ L⁰.comap φ) (p q : K[X]) :\n    liftMonoidWithZeroHom φ hφ (algebraMap _ _ p) / liftMonoidWithZeroHom φ hφ (algebraMap _ _ q) =\n      φ p / φ q := by\n  rw [← map_div₀, liftMonoidWithZeroHom_apply_div]\n\n"}
{"name":"RatFunc.liftRingHom_apply_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝² : CommRing K\ninst✝¹ : IsDomain K\nL : Type u_1\ninst✝ : Field L\nφ : RingHom (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\np q : Polynomial K\n⊢ Eq ((RatFunc.liftRingHom φ hφ) (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q))) (HDiv.hDiv (φ p) (φ q))","decl":"theorem liftRingHom_apply_div {L : Type*} [Field L] (φ : K[X] →+* L) (hφ : K[X]⁰ ≤ L⁰.comap φ)\n    (p q : K[X]) : liftRingHom φ hφ (algebraMap _ _ p / algebraMap _ _ q) = φ p / φ q :=\n  liftMonoidWithZeroHom_apply_div _ hφ _ _\n\n"}
{"name":"RatFunc.liftRingHom_apply_div'","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝² : CommRing K\ninst✝¹ : IsDomain K\nL : Type u_1\ninst✝ : Field L\nφ : RingHom (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\np q : Polynomial K\n⊢ Eq (HDiv.hDiv ((RatFunc.liftRingHom φ hφ) ((algebraMap (Polynomial K) (RatFunc K)) p)) ((RatFunc.liftRingHom φ hφ) ((algebraMap (Polynomial K) (RatFunc K)) q))) (HDiv.hDiv (φ p) (φ q))","decl":"@[simp]\ntheorem liftRingHom_apply_div' {L : Type*} [Field L] (φ : K[X] →+* L) (hφ : K[X]⁰ ≤ L⁰.comap φ)\n    (p q : K[X]) : liftRingHom φ hφ (algebraMap _ _ p) / liftRingHom φ hφ (algebraMap _ _ q) =\n      φ p / φ q :=\n  liftMonoidWithZeroHom_apply_div' _ hφ _ _\n\n"}
{"name":"RatFunc.ofFractionRing_comp_algebraMap","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\n⊢ Eq (Function.comp RatFunc.ofFractionRing ⇑(algebraMap (Polynomial K) (FractionRing (Polynomial K)))) ⇑(algebraMap (Polynomial K) (RatFunc K))","decl":"theorem ofFractionRing_comp_algebraMap :\n    ofFractionRing ∘ algebraMap K[X] (FractionRing K[X]) = algebraMap _ _ :=\n  funext ofFractionRing_algebraMap\n\n"}
{"name":"RatFunc.algebraMap_injective","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\n⊢ Function.Injective ⇑(algebraMap (Polynomial K) (RatFunc K))","decl":"theorem algebraMap_injective : Function.Injective (algebraMap K[X] (RatFunc K)) := by\n  rw [← ofFractionRing_comp_algebraMap]\n  exact ofFractionRing_injective.comp (IsFractionRing.injective _ _)\n\n"}
{"name":"RatFunc.coe_mapAlgHom_eq_coe_map","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁶ : CommRing K\ninst✝⁵ : IsDomain K\nR : Type u_2\nS : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S (Polynomial K)\ninst✝ : Algebra S (Polynomial R)\nφ : AlgHom S (Polynomial K) (Polynomial R)\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors (Polynomial R)))\n⊢ Eq ⇑(RatFunc.mapAlgHom φ hφ) ⇑(RatFunc.map φ hφ)","decl":"theorem coe_mapAlgHom_eq_coe_map (φ : K[X] →ₐ[S] R[X]) (hφ : K[X]⁰ ≤ R[X]⁰.comap φ) :\n    (mapAlgHom φ hφ : RatFunc K → RatFunc R) = map φ hφ :=\n  rfl\n\n"}
{"name":"RatFunc.liftAlgHom_apply_ofFractionRing_mk","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁵ : CommRing K\ninst✝⁴ : IsDomain K\nL : Type u_1\nS : Type u_3\ninst✝³ : Field L\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S (Polynomial K)\ninst✝ : Algebra S L\nφ : AlgHom S (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\nn : Polynomial K\nd : Subtype fun x => Membership.mem (nonZeroDivisors (Polynomial K)) x\n⊢ Eq ((RatFunc.liftAlgHom φ hφ) { toFractionRing := Localization.mk n d }) (HDiv.hDiv (φ n) (φ ↑d))","decl":"theorem liftAlgHom_apply_ofFractionRing_mk (n : K[X]) (d : K[X]⁰) :\n    liftAlgHom φ hφ (ofFractionRing (Localization.mk n d)) = φ n / φ d :=\n  liftMonoidWithZeroHom_apply_ofFractionRing_mk _ hφ _ _\n\n"}
{"name":"RatFunc.liftAlgHom_injective","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁵ : CommRing K\ninst✝⁴ : IsDomain K\nL : Type u_1\nS : Type u_3\ninst✝³ : Field L\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S (Polynomial K)\ninst✝ : Algebra S L\nφ : AlgHom S (Polynomial K) L\nhφ : Function.Injective ⇑φ\nhφ' : optParam (LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))) ⋯\n⊢ Function.Injective ⇑(RatFunc.liftAlgHom φ hφ')","decl":"theorem liftAlgHom_injective (φ : K[X] →ₐ[S] L) (hφ : Function.Injective φ)\n    (hφ' : K[X]⁰ ≤ L⁰.comap φ := nonZeroDivisors_le_comap_nonZeroDivisors_of_injective _ hφ) :\n    Function.Injective (liftAlgHom φ hφ') :=\n  liftMonoidWithZeroHom_injective _ hφ\n\n"}
{"name":"RatFunc.liftAlgHom_apply_div'","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁵ : CommRing K\ninst✝⁴ : IsDomain K\nL : Type u_1\nS : Type u_3\ninst✝³ : Field L\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S (Polynomial K)\ninst✝ : Algebra S L\nφ : AlgHom S (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\np q : Polynomial K\n⊢ Eq (HDiv.hDiv ((RatFunc.liftAlgHom φ hφ) ((algebraMap (Polynomial K) (RatFunc K)) p)) ((RatFunc.liftAlgHom φ hφ) ((algebraMap (Polynomial K) (RatFunc K)) q))) (HDiv.hDiv (φ p) (φ q))","decl":"@[simp]\ntheorem liftAlgHom_apply_div' (p q : K[X]) :\n    liftAlgHom φ hφ (algebraMap _ _ p) / liftAlgHom φ hφ (algebraMap _ _ q) = φ p / φ q :=\n  liftMonoidWithZeroHom_apply_div' _ hφ _ _\n\n"}
{"name":"RatFunc.liftAlgHom_apply_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁵ : CommRing K\ninst✝⁴ : IsDomain K\nL : Type u_1\nS : Type u_3\ninst✝³ : Field L\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S (Polynomial K)\ninst✝ : Algebra S L\nφ : AlgHom S (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\np q : Polynomial K\n⊢ Eq ((RatFunc.liftAlgHom φ hφ) (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q))) (HDiv.hDiv (φ p) (φ q))","decl":"theorem liftAlgHom_apply_div (p q : K[X]) :\n    liftAlgHom φ hφ (algebraMap _ _ p / algebraMap _ _ q) = φ p / φ q :=\n  liftMonoidWithZeroHom_apply_div _ hφ _ _\n\n"}
{"name":"RatFunc.instIsFractionRingPolynomial","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\n⊢ IsFractionRing (Polynomial K) (RatFunc K)","decl":"/-- `RatFunc K` is the field of fractions of the polynomials over `K`. -/\ninstance : IsFractionRing K[X] (RatFunc K) where\n  map_units' y := by\n    rw [← ofFractionRing_algebraMap]\n    exact (toFractionRingRingEquiv K).symm.toRingHom.isUnit_map (IsLocalization.map_units _ y)\n  exists_of_eq {x y} := by\n    rw [← ofFractionRing_algebraMap, ← ofFractionRing_algebraMap]\n    exact fun h ↦ IsLocalization.exists_of_eq ((toFractionRingRingEquiv K).symm.injective h)\n  surj' := by\n    rintro ⟨z⟩\n    convert IsLocalization.surj K[X]⁰ z\n    simp only [← ofFractionRing_algebraMap, Function.comp_apply, ← ofFractionRing_mul,\n      ofFractionRing.injEq]\n\n"}
{"name":"RatFunc.algebraMap_eq_zero_iff","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nx : Polynomial K\n⊢ Iff (Eq ((algebraMap (Polynomial K) (RatFunc K)) x) 0) (Eq x 0)","decl":"@[deprecated \"Use NoZeroSMulDivisors.algebraMap_eq_zero_iff instead.\" (since := \"2024-09-08\")]\ntheorem algebraMap_eq_zero_iff {x : K[X]} : algebraMap K[X] (RatFunc K) x = 0 ↔ x = 0 := by\n  simp\n\n"}
{"name":"RatFunc.algebraMap_ne_zero","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nx : Polynomial K\nhx : Ne x 0\n⊢ Ne ((algebraMap (Polynomial K) (RatFunc K)) x) 0","decl":"theorem algebraMap_ne_zero {x : K[X]} (hx : x ≠ 0) : algebraMap K[X] (RatFunc K) x ≠ 0 := by\n  simpa\n\n"}
{"name":"RatFunc.liftOn_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nP : Sort v\np q : Polynomial K\nf : Polynomial K → Polynomial K → P\nf0 : ∀ (p : Polynomial K), Eq (f p 0) (f 0 1)\nH' : ∀ {p q p' q' : Polynomial K}, Ne q 0 → Ne q' 0 → Eq (HMul.hMul q' p) (HMul.hMul q p') → Eq (f p q) (f p' q')\nH : optParam (∀ {p q p' q' : Polynomial K}, Membership.mem (nonZeroDivisors (Polynomial K)) q → Membership.mem (nonZeroDivisors (Polynomial K)) q' → Eq (HMul.hMul q' p) (HMul.hMul q p') → Eq (f p q) (f p' q')) ⋯\n⊢ Eq ((HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)).liftOn f H) (f p q)","decl":"@[simp]\ntheorem liftOn_div {P : Sort v} (p q : K[X]) (f : K[X] → K[X] → P) (f0 : ∀ p, f p 0 = f 0 1)\n    (H' : ∀ {p q p' q'} (_hq : q ≠ 0) (_hq' : q' ≠ 0), q' * p = q * p' → f p q = f p' q')\n    (H : ∀ {p q p' q'} (_hq : q ∈ K[X]⁰) (_hq' : q' ∈ K[X]⁰), q' * p = q * p' → f p q = f p' q' :=\n      fun {_ _ _ _} hq hq' h => H' (nonZeroDivisors.ne_zero hq) (nonZeroDivisors.ne_zero hq') h) :\n    (RatFunc.liftOn (algebraMap _ (RatFunc K) p / algebraMap _ _ q)) f @H = f p q := by\n  rw [← mk_eq_div, liftOn_mk _ _ f f0 @H']\n\n"}
{"name":"RatFunc.liftOn'_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nP : Sort v\np q : Polynomial K\nf : Polynomial K → Polynomial K → P\nf0 : ∀ (p : Polynomial K), Eq (f p 0) (f 0 1)\nH : ∀ {p q a : Polynomial K}, Ne q 0 → Ne a 0 → Eq (f (HMul.hMul a p) (HMul.hMul a q)) (f p q)\n⊢ Eq ((HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)).liftOn' f H) (f p q)","decl":"@[simp]\ntheorem liftOn'_div {P : Sort v} (p q : K[X]) (f : K[X] → K[X] → P) (f0 : ∀ p, f p 0 = f 0 1)\n    (H) :\n    (RatFunc.liftOn' (algebraMap _ (RatFunc K) p / algebraMap _ _ q)) f @H = f p q := by\n  rw [RatFunc.liftOn', liftOn_div _ _ _ f0]\n  apply liftOn_condition_of_liftOn'_condition H\n\n"}
{"name":"RatFunc.induction_on","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nP : RatFunc K → Prop\nx : RatFunc K\nf : ∀ (p q : Polynomial K), Ne q 0 → P (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q))\n⊢ P x","decl":"/-- Induction principle for `RatFunc K`: if `f p q : P (p / q)` for all `p q : K[X]`,\nthen `P` holds on all elements of `RatFunc K`.\n\nSee also `induction_on'`, which is a recursion principle defined in terms of `RatFunc.mk`.\n-/\nprotected theorem induction_on {P : RatFunc K → Prop} (x : RatFunc K)\n    (f : ∀ (p q : K[X]) (_ : q ≠ 0), P (algebraMap _ (RatFunc K) p / algebraMap _ _ q)) : P x :=\n  x.induction_on' fun p q hq => by simpa using f p q hq\n\n"}
{"name":"RatFunc.ofFractionRing_mk'","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nx : Polynomial K\ny : Subtype fun x => Membership.mem (nonZeroDivisors (Polynomial K)) x\n⊢ Eq { toFractionRing := IsLocalization.mk' (FractionRing (Polynomial K)) x y } (IsLocalization.mk' (RatFunc K) x y)","decl":"theorem ofFractionRing_mk' (x : K[X]) (y : K[X]⁰) :\n    ofFractionRing (IsLocalization.mk' _ x y) =\n      IsLocalization.mk' (RatFunc K) x y := by\n  rw [IsFractionRing.mk'_eq_div, IsFractionRing.mk'_eq_div, ← mk_eq_div', ← mk_eq_div]\n\n"}
{"name":"RatFunc.mk_eq_mk'","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\nf g : Polynomial K\nhg : Ne g 0\n⊢ Eq (RatFunc.mk f g) (IsLocalization.mk' (RatFunc K) f ⟨g, ⋯⟩)","decl":"theorem mk_eq_mk' (f : Polynomial K) {g : Polynomial K} (hg : g ≠ 0) :\n    RatFunc.mk f g = IsLocalization.mk' (RatFunc K) f ⟨g, mem_nonZeroDivisors_iff_ne_zero.2 hg⟩ :=\n  by simp only [mk_eq_div, IsFractionRing.mk'_eq_div]\n\n"}
{"name":"RatFunc.ofFractionRing_eq","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\n⊢ Eq RatFunc.ofFractionRing ⇑(IsLocalization.algEquiv (nonZeroDivisors (Polynomial K)) (FractionRing (Polynomial K)) (RatFunc K))","decl":"@[simp]\ntheorem ofFractionRing_eq :\n    (ofFractionRing : FractionRing K[X] → RatFunc K) = IsLocalization.algEquiv K[X]⁰ _ _ :=\n  funext fun x =>\n    Localization.induction_on x fun x => by\n      simp only [Localization.mk_eq_mk'_apply, ofFractionRing_mk', IsLocalization.algEquiv_apply,\n        IsLocalization.map_mk', RingHom.id_apply]\n\n"}
{"name":"RatFunc.toFractionRing_eq","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\n⊢ Eq RatFunc.toFractionRing ⇑(IsLocalization.algEquiv (nonZeroDivisors (Polynomial K)) (RatFunc K) (FractionRing (Polynomial K)))","decl":"@[simp]\ntheorem toFractionRing_eq :\n    (toFractionRing : RatFunc K → FractionRing K[X]) = IsLocalization.algEquiv K[X]⁰ _ _ :=\n  funext fun ⟨x⟩ =>\n    Localization.induction_on x fun x => by\n      simp only [Localization.mk_eq_mk'_apply, ofFractionRing_mk', IsLocalization.algEquiv_apply,\n        IsLocalization.map_mk', RingHom.id_apply]\n\n"}
{"name":"RatFunc.toFractionRingRingEquiv_symm_eq","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : CommRing K\ninst✝ : IsDomain K\n⊢ Eq (RatFunc.toFractionRingRingEquiv K).symm (IsLocalization.algEquiv (nonZeroDivisors (Polynomial K)) (FractionRing (Polynomial K)) (RatFunc K)).toRingEquiv","decl":"@[simp]\ntheorem toFractionRingRingEquiv_symm_eq :\n    (toFractionRingRingEquiv K).symm = (IsLocalization.algEquiv K[X]⁰ _ _).toRingEquiv := by\n  ext x\n  simp [toFractionRingRingEquiv, ofFractionRing_eq, AlgEquiv.coe_ringEquiv']\n\n"}
{"name":"RatFunc.numDenom_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\np q : Polynomial K\nhq : Ne q 0\n⊢ Eq (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)).numDenom { fst := HMul.hMul (Polynomial.C (Inv.inv (HDiv.hDiv q (GCDMonoid.gcd p q)).leadingCoeff)) (HDiv.hDiv p (GCDMonoid.gcd p q)), snd := HMul.hMul (Polynomial.C (Inv.inv (HDiv.hDiv q (GCDMonoid.gcd p q)).leadingCoeff)) (HDiv.hDiv q (GCDMonoid.gcd p q)) }","decl":"open scoped Classical in\n@[simp]\ntheorem numDenom_div (p : K[X]) {q : K[X]} (hq : q ≠ 0) :\n    numDenom (algebraMap _ _ p / algebraMap _ _ q) =\n      (Polynomial.C (q / gcd p q).leadingCoeff⁻¹ * (p / gcd p q),\n        Polynomial.C (q / gcd p q).leadingCoeff⁻¹ * (q / gcd p q)) := by\n  rw [numDenom, liftOn'_div, if_neg hq]\n  intro p\n  rw [if_pos rfl, if_neg (one_ne_zero' K[X])]\n  simp\n\n"}
{"name":"RatFunc.num_zero","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Eq (RatFunc.num 0) 0","decl":"@[simp]\ntheorem num_zero : num (0 : RatFunc K) = 0 := by convert num_div' (0 : K[X]) one_ne_zero <;> simp\n\n"}
{"name":"RatFunc.num_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\np q : Polynomial K\n⊢ Eq (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)).num (HMul.hMul (Polynomial.C (Inv.inv (HDiv.hDiv q (GCDMonoid.gcd p q)).leadingCoeff)) (HDiv.hDiv p (GCDMonoid.gcd p q)))","decl":"open scoped Classical in\n@[simp]\ntheorem num_div (p q : K[X]) :\n    num (algebraMap _ _ p / algebraMap _ _ q) =\n      Polynomial.C (q / gcd p q).leadingCoeff⁻¹ * (p / gcd p q) := by\n  by_cases hq : q = 0\n  · simp [hq]\n  · exact num_div' p hq\n\n"}
{"name":"RatFunc.num_one","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Eq (RatFunc.num 1) 1","decl":"@[simp]\ntheorem num_one : num (1 : RatFunc K) = 1 := by convert num_div (1 : K[X]) 1 <;> simp\n\n"}
{"name":"RatFunc.num_algebraMap","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\np : Polynomial K\n⊢ Eq ((algebraMap (Polynomial K) (RatFunc K)) p).num p","decl":"@[simp]\ntheorem num_algebraMap (p : K[X]) : num (algebraMap _ _ p) = p := by convert num_div p 1 <;> simp\n\n"}
{"name":"RatFunc.num_div_dvd","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\np q : Polynomial K\nhq : Ne q 0\n⊢ Dvd.dvd (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)).num p","decl":"theorem num_div_dvd (p : K[X]) {q : K[X]} (hq : q ≠ 0) :\n    num (algebraMap _ _ p / algebraMap _ _ q) ∣ p := by\n  classical\n  rw [num_div _ q, C_mul_dvd]\n  · exact EuclideanDomain.div_dvd_of_dvd (gcd_dvd_left p q)\n  · simpa only [Ne, inv_eq_zero, Polynomial.leadingCoeff_eq_zero] using right_div_gcd_ne_zero hq\n\n"}
{"name":"RatFunc.num_div_dvd'","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\np q : Polynomial K\nhq : Ne q 0\n⊢ Dvd.dvd (HMul.hMul (Polynomial.C (Inv.inv (HDiv.hDiv q (GCDMonoid.gcd p q)).leadingCoeff)) (HDiv.hDiv p (GCDMonoid.gcd p q))) p","decl":"open scoped Classical in\n/-- A version of `num_div_dvd` with the LHS in simp normal form -/\n@[simp]\ntheorem num_div_dvd' (p : K[X]) {q : K[X]} (hq : q ≠ 0) :\n    C (q / gcd p q).leadingCoeff⁻¹ * (p / gcd p q) ∣ p := by simpa using num_div_dvd p hq\n\n"}
{"name":"RatFunc.denom_div","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\np q : Polynomial K\nhq : Ne q 0\n⊢ Eq (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)).denom (HMul.hMul (Polynomial.C (Inv.inv (HDiv.hDiv q (GCDMonoid.gcd p q)).leadingCoeff)) (HDiv.hDiv q (GCDMonoid.gcd p q)))","decl":"open scoped Classical in\n@[simp]\ntheorem denom_div (p : K[X]) {q : K[X]} (hq : q ≠ 0) :\n    denom (algebraMap _ _ p / algebraMap _ _ q) =\n      Polynomial.C (q / gcd p q).leadingCoeff⁻¹ * (q / gcd p q) := by\n  rw [denom, numDenom_div _ hq]\n\n"}
{"name":"RatFunc.monic_denom","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\n⊢ x.denom.Monic","decl":"theorem monic_denom (x : RatFunc K) : (denom x).Monic := by\n  classical\n  induction x using RatFunc.induction_on with\n  | f p q hq =>\n    rw [denom_div p hq, mul_comm]\n    exact Polynomial.monic_mul_leadingCoeff_inv (right_div_gcd_ne_zero hq)\n\n"}
{"name":"RatFunc.denom_ne_zero","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\n⊢ Ne x.denom 0","decl":"theorem denom_ne_zero (x : RatFunc K) : denom x ≠ 0 :=\n  (monic_denom x).ne_zero\n\n"}
{"name":"RatFunc.denom_zero","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Eq (RatFunc.denom 0) 1","decl":"@[simp]\ntheorem denom_zero : denom (0 : RatFunc K) = 1 := by\n  convert denom_div (0 : K[X]) one_ne_zero <;> simp\n\n"}
{"name":"RatFunc.denom_one","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Eq (RatFunc.denom 1) 1","decl":"@[simp]\ntheorem denom_one : denom (1 : RatFunc K) = 1 := by\n  convert denom_div (1 : K[X]) one_ne_zero <;> simp\n\n"}
{"name":"RatFunc.denom_algebraMap","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\np : Polynomial K\n⊢ Eq ((algebraMap (Polynomial K) (RatFunc K)) p).denom 1","decl":"@[simp]\ntheorem denom_algebraMap (p : K[X]) : denom (algebraMap _ (RatFunc K) p) = 1 := by\n  convert denom_div p one_ne_zero <;> simp\n\n"}
{"name":"RatFunc.denom_div_dvd","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\np q : Polynomial K\n⊢ Dvd.dvd (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)).denom q","decl":"@[simp]\ntheorem denom_div_dvd (p q : K[X]) : denom (algebraMap _ _ p / algebraMap _ _ q) ∣ q := by\n  classical\n  by_cases hq : q = 0\n  · simp [hq]\n  rw [denom_div _ hq, C_mul_dvd]\n  · exact EuclideanDomain.div_dvd_of_dvd (gcd_dvd_right p q)\n  · simpa only [Ne, inv_eq_zero, Polynomial.leadingCoeff_eq_zero] using right_div_gcd_ne_zero hq\n\n"}
{"name":"RatFunc.num_div_denom","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\n⊢ Eq (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) x.num) ((algebraMap (Polynomial K) (RatFunc K)) x.denom)) x","decl":"@[simp]\ntheorem num_div_denom (x : RatFunc K) : algebraMap _ _ (num x) / algebraMap _ _ (denom x) = x := by\n  classical\n  induction' x using RatFunc.induction_on with p q hq\n  have q_div_ne_zero : q / gcd p q ≠ 0 := right_div_gcd_ne_zero hq\n  rw [num_div p q, denom_div p hq, RingHom.map_mul, RingHom.map_mul, mul_div_mul_left,\n    div_eq_div_iff, ← RingHom.map_mul, ← RingHom.map_mul, mul_comm _ q, ←\n    EuclideanDomain.mul_div_assoc, ← EuclideanDomain.mul_div_assoc, mul_comm]\n  · apply gcd_dvd_right\n  · apply gcd_dvd_left\n  · exact algebraMap_ne_zero q_div_ne_zero\n  · exact algebraMap_ne_zero hq\n  · refine algebraMap_ne_zero (mt Polynomial.C_eq_zero.mp ?_)\n    exact inv_ne_zero (Polynomial.leadingCoeff_ne_zero.mpr q_div_ne_zero)\n\n"}
{"name":"RatFunc.isCoprime_num_denom","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\n⊢ IsCoprime x.num x.denom","decl":"theorem isCoprime_num_denom (x : RatFunc K) : IsCoprime x.num x.denom := by\n  classical\n  induction' x using RatFunc.induction_on with p q hq\n  rw [num_div, denom_div _ hq]\n  exact (isCoprime_mul_unit_left\n    ((leadingCoeff_ne_zero.2 <| right_div_gcd_ne_zero hq).isUnit.inv.map C) _ _).2\n      (isCoprime_div_gcd_div_gcd hq)\n\n"}
{"name":"RatFunc.num_eq_zero_iff","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\n⊢ Iff (Eq x.num 0) (Eq x 0)","decl":"@[simp]\ntheorem num_eq_zero_iff {x : RatFunc K} : num x = 0 ↔ x = 0 :=\n  ⟨fun h => by rw [← num_div_denom x, h, RingHom.map_zero, zero_div], fun h => h.symm ▸ num_zero⟩\n\n"}
{"name":"RatFunc.num_ne_zero","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\nhx : Ne x 0\n⊢ Ne x.num 0","decl":"theorem num_ne_zero {x : RatFunc K} (hx : x ≠ 0) : num x ≠ 0 :=\n  mt num_eq_zero_iff.mp hx\n\n"}
{"name":"RatFunc.num_mul_eq_mul_denom_iff","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\np q : Polynomial K\nhq : Ne q 0\n⊢ Iff (Eq (HMul.hMul x.num q) (HMul.hMul p x.denom)) (Eq x (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)))","decl":"theorem num_mul_eq_mul_denom_iff {x : RatFunc K} {p q : K[X]} (hq : q ≠ 0) :\n    x.num * q = p * x.denom ↔ x = algebraMap _ _ p / algebraMap _ _ q := by\n  rw [← (algebraMap_injective K).eq_iff, eq_div_iff (algebraMap_ne_zero hq)]\n  conv_rhs => rw [← num_div_denom x]\n  rw [RingHom.map_mul, RingHom.map_mul, div_eq_mul_inv, mul_assoc, mul_comm (Inv.inv _), ←\n    mul_assoc, ← div_eq_mul_inv, div_eq_iff]\n  exact algebraMap_ne_zero (denom_ne_zero x)\n\n"}
{"name":"RatFunc.num_denom_add","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx y : RatFunc K\n⊢ Eq (HMul.hMul (HAdd.hAdd x y).num (HMul.hMul x.denom y.denom)) (HMul.hMul (HAdd.hAdd (HMul.hMul x.num y.denom) (HMul.hMul x.denom y.num)) (HAdd.hAdd x y).denom)","decl":"theorem num_denom_add (x y : RatFunc K) :\n    (x + y).num * (x.denom * y.denom) = (x.num * y.denom + x.denom * y.num) * (x + y).denom :=\n  (num_mul_eq_mul_denom_iff (mul_ne_zero (denom_ne_zero x) (denom_ne_zero y))).mpr <| by\n    conv_lhs => rw [← num_div_denom x, ← num_div_denom y]\n    rw [div_add_div, RingHom.map_mul, RingHom.map_add, RingHom.map_mul, RingHom.map_mul]\n    · exact algebraMap_ne_zero (denom_ne_zero x)\n    · exact algebraMap_ne_zero (denom_ne_zero y)\n\n"}
{"name":"RatFunc.num_denom_neg","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\n⊢ Eq (HMul.hMul (Neg.neg x).num x.denom) (HMul.hMul (Neg.neg x.num) (Neg.neg x).denom)","decl":"theorem num_denom_neg (x : RatFunc K) : (-x).num * x.denom = -x.num * (-x).denom := by\n  rw [num_mul_eq_mul_denom_iff (denom_ne_zero x), _root_.map_neg, neg_div, num_div_denom]\n\n"}
{"name":"RatFunc.num_denom_mul","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx y : RatFunc K\n⊢ Eq (HMul.hMul (HMul.hMul x y).num (HMul.hMul x.denom y.denom)) (HMul.hMul (HMul.hMul x.num y.num) (HMul.hMul x y).denom)","decl":"theorem num_denom_mul (x y : RatFunc K) :\n    (x * y).num * (x.denom * y.denom) = x.num * y.num * (x * y).denom :=\n  (num_mul_eq_mul_denom_iff (mul_ne_zero (denom_ne_zero x) (denom_ne_zero y))).mpr <| by\n    conv_lhs =>\n      rw [← num_div_denom x, ← num_div_denom y, div_mul_div_comm, ← RingHom.map_mul, ←\n        RingHom.map_mul]\n\n"}
{"name":"RatFunc.num_dvd","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\np : Polynomial K\nhp : Ne p 0\n⊢ Iff (Dvd.dvd x.num p) (Exists fun q => And (Ne q 0) (Eq x (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q))))","decl":"theorem num_dvd {x : RatFunc K} {p : K[X]} (hp : p ≠ 0) :\n    num x ∣ p ↔ ∃ q : K[X], q ≠ 0 ∧ x = algebraMap _ _ p / algebraMap _ _ q := by\n  constructor\n  · rintro ⟨q, rfl⟩\n    obtain ⟨_hx, hq⟩ := mul_ne_zero_iff.mp hp\n    use denom x * q\n    rw [RingHom.map_mul, RingHom.map_mul, ← div_mul_div_comm, div_self, mul_one, num_div_denom]\n    · exact ⟨mul_ne_zero (denom_ne_zero x) hq, rfl⟩\n    · exact algebraMap_ne_zero hq\n  · rintro ⟨q, hq, rfl⟩\n    exact num_div_dvd p hq\n\n"}
{"name":"RatFunc.denom_dvd","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx : RatFunc K\nq : Polynomial K\nhq : Ne q 0\n⊢ Iff (Dvd.dvd x.denom q) (Exists fun p => Eq x (HDiv.hDiv ((algebraMap (Polynomial K) (RatFunc K)) p) ((algebraMap (Polynomial K) (RatFunc K)) q)))","decl":"theorem denom_dvd {x : RatFunc K} {q : K[X]} (hq : q ≠ 0) :\n    denom x ∣ q ↔ ∃ p : K[X], x = algebraMap _ _ p / algebraMap _ _ q := by\n  constructor\n  · rintro ⟨p, rfl⟩\n    obtain ⟨_hx, hp⟩ := mul_ne_zero_iff.mp hq\n    use num x * p\n    rw [RingHom.map_mul, RingHom.map_mul, ← div_mul_div_comm, div_self, mul_one, num_div_denom]\n    exact algebraMap_ne_zero hp\n  · rintro ⟨p, rfl⟩\n    exact denom_div_dvd p q\n\n"}
{"name":"RatFunc.num_mul_dvd","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx y : RatFunc K\n⊢ Dvd.dvd (HMul.hMul x y).num (HMul.hMul x.num y.num)","decl":"theorem num_mul_dvd (x y : RatFunc K) : num (x * y) ∣ num x * num y := by\n  by_cases hx : x = 0\n  · simp [hx]\n  by_cases hy : y = 0\n  · simp [hy]\n  rw [num_dvd (mul_ne_zero (num_ne_zero hx) (num_ne_zero hy))]\n  refine ⟨x.denom * y.denom, mul_ne_zero (denom_ne_zero x) (denom_ne_zero y), ?_⟩\n  rw [RingHom.map_mul, RingHom.map_mul, ← div_mul_div_comm, num_div_denom, num_div_denom]\n\n"}
{"name":"RatFunc.denom_mul_dvd","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx y : RatFunc K\n⊢ Dvd.dvd (HMul.hMul x y).denom (HMul.hMul x.denom y.denom)","decl":"theorem denom_mul_dvd (x y : RatFunc K) : denom (x * y) ∣ denom x * denom y := by\n  rw [denom_dvd (mul_ne_zero (denom_ne_zero x) (denom_ne_zero y))]\n  refine ⟨x.num * y.num, ?_⟩\n  rw [RingHom.map_mul, RingHom.map_mul, ← div_mul_div_comm, num_div_denom, num_div_denom]\n\n"}
{"name":"RatFunc.denom_add_dvd","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx y : RatFunc K\n⊢ Dvd.dvd (HAdd.hAdd x y).denom (HMul.hMul x.denom y.denom)","decl":"theorem denom_add_dvd (x y : RatFunc K) : denom (x + y) ∣ denom x * denom y := by\n  rw [denom_dvd (mul_ne_zero (denom_ne_zero x) (denom_ne_zero y))]\n  refine ⟨x.num * y.denom + x.denom * y.num, ?_⟩\n  rw [RingHom.map_mul, RingHom.map_add, RingHom.map_mul, RingHom.map_mul, ← div_add_div,\n    num_div_denom, num_div_denom]\n  · exact algebraMap_ne_zero (denom_ne_zero x)\n  · exact algebraMap_ne_zero (denom_ne_zero y)\n\n"}
{"name":"RatFunc.map_denom_ne_zero","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝³ : Field K\nL : Type u_1\nF : Type u_2\ninst✝² : Zero L\ninst✝¹ : FunLike F (Polynomial K) L\ninst✝ : ZeroHomClass F (Polynomial K) L\nφ : F\nhφ : Function.Injective ⇑φ\nf : RatFunc K\n⊢ Ne (φ f.denom) 0","decl":"theorem map_denom_ne_zero {L F : Type*} [Zero L] [FunLike F K[X] L] [ZeroHomClass F K[X] L]\n    (φ : F) (hφ : Function.Injective φ) (f : RatFunc K) : φ f.denom ≠ 0 := fun H =>\n  (denom_ne_zero f) ((map_eq_zero_iff φ hφ).mp H)\n\n"}
{"name":"RatFunc.map_apply","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁴ : Field K\nR : Type u_1\nF : Type u_2\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : FunLike F (Polynomial K) (Polynomial R)\ninst✝ : MonoidHomClass F (Polynomial K) (Polynomial R)\nφ : F\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors (Polynomial R)))\nf : RatFunc K\n⊢ Eq ((RatFunc.map φ hφ) f) (HDiv.hDiv ((algebraMap (Polynomial R) (RatFunc R)) (φ f.num)) ((algebraMap (Polynomial R) (RatFunc R)) (φ f.denom)))","decl":"theorem map_apply {R F : Type*} [CommRing R] [IsDomain R]\n    [FunLike F K[X] R[X]] [MonoidHomClass F K[X] R[X]] (φ : F)\n    (hφ : K[X]⁰ ≤ R[X]⁰.comap φ) (f : RatFunc K) :\n    map φ hφ f = algebraMap _ _ (φ f.num) / algebraMap _ _ (φ f.denom) := by\n  rw [← num_div_denom f, map_apply_div_ne_zero, num_div_denom f]\n  exact denom_ne_zero _\n\n"}
{"name":"RatFunc.liftMonoidWithZeroHom_apply","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u_1\ninst✝ : CommGroupWithZero L\nφ : MonoidWithZeroHom (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\nf : RatFunc K\n⊢ Eq ((RatFunc.liftMonoidWithZeroHom φ hφ) f) (HDiv.hDiv (φ f.num) (φ f.denom))","decl":"theorem liftMonoidWithZeroHom_apply {L : Type*} [CommGroupWithZero L] (φ : K[X] →*₀ L)\n    (hφ : K[X]⁰ ≤ L⁰.comap φ) (f : RatFunc K) :\n    liftMonoidWithZeroHom φ hφ f = φ f.num / φ f.denom := by\n  rw [← num_div_denom f, liftMonoidWithZeroHom_apply_div, num_div_denom]\n\n"}
{"name":"RatFunc.liftRingHom_apply","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u_1\ninst✝ : Field L\nφ : RingHom (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\nf : RatFunc K\n⊢ Eq ((RatFunc.liftRingHom φ hφ) f) (HDiv.hDiv (φ f.num) (φ f.denom))","decl":"theorem liftRingHom_apply {L : Type*} [Field L] (φ : K[X] →+* L) (hφ : K[X]⁰ ≤ L⁰.comap φ)\n    (f : RatFunc K) : liftRingHom φ hφ f = φ f.num / φ f.denom :=\n  liftMonoidWithZeroHom_apply _ hφ _\n\n"}
{"name":"RatFunc.liftAlgHom_apply","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝⁴ : Field K\nL : Type u_1\nS : Type u_2\ninst✝³ : Field L\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S (Polynomial K)\ninst✝ : Algebra S L\nφ : AlgHom S (Polynomial K) L\nhφ : LE.le (nonZeroDivisors (Polynomial K)) (Submonoid.comap φ (nonZeroDivisors L))\nf : RatFunc K\n⊢ Eq ((RatFunc.liftAlgHom φ hφ) f) (HDiv.hDiv (φ f.num) (φ f.denom))","decl":"theorem liftAlgHom_apply {L S : Type*} [Field L] [CommSemiring S] [Algebra S K[X]] [Algebra S L]\n    (φ : K[X] →ₐ[S] L) (hφ : K[X]⁰ ≤ L⁰.comap φ) (f : RatFunc K) :\n    liftAlgHom φ hφ f = φ f.num / φ f.denom :=\n  liftMonoidWithZeroHom_apply _ hφ _\n\n"}
{"name":"RatFunc.num_mul_denom_add_denom_mul_num_ne_zero","module":"Mathlib.FieldTheory.RatFunc.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nx y : RatFunc K\nhxy : Ne (HAdd.hAdd x y) 0\n⊢ Ne (HAdd.hAdd (HMul.hMul x.num y.denom) (HMul.hMul x.denom y.num)) 0","decl":"theorem num_mul_denom_add_denom_mul_num_ne_zero {x y : RatFunc K} (hxy : x + y ≠ 0) :\n    x.num * y.denom + x.denom * y.num ≠ 0 := by\n  intro h_zero\n  have h := num_denom_add x y\n  rw [h_zero, zero_mul] at h\n  exact (mul_ne_zero (num_ne_zero hxy) (mul_ne_zero x.denom_ne_zero y.denom_ne_zero)) h\n\n"}
