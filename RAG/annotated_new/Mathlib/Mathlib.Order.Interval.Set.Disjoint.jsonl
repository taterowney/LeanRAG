{"name":"Set.Iic_disjoint_Ioi","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ Disjoint (Set.Iic a) (Set.Ioi b)","decl":"@[simp]\ntheorem Iic_disjoint_Ioi (h : a ≤ b) : Disjoint (Iic a) (Ioi b) :=\n  disjoint_left.mpr fun _ ha hb => (h.trans_lt hb).not_le ha\n\n"}
{"name":"Set.Iio_disjoint_Ici","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ Disjoint (Set.Iio a) (Set.Ici b)","decl":"@[simp]\ntheorem Iio_disjoint_Ici (h : a ≤ b) : Disjoint (Iio a) (Ici b) :=\n  disjoint_left.mpr fun _ ha hb => (h.trans_lt' ha).not_le hb\n\n"}
{"name":"Set.Iic_disjoint_Ioc","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na b c : α\nh : LE.le a b\n⊢ Disjoint (Set.Iic a) (Set.Ioc b c)","decl":"@[simp]\ntheorem Iic_disjoint_Ioc (h : a ≤ b) : Disjoint (Iic a) (Ioc b c) :=\n  (Iic_disjoint_Ioi h).mono le_rfl Ioc_subset_Ioi_self\n\n"}
{"name":"Set.Ioc_disjoint_Ioc_same","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na b c : α\n⊢ Disjoint (Set.Ioc a b) (Set.Ioc b c)","decl":"@[simp]\ntheorem Ioc_disjoint_Ioc_same : Disjoint (Ioc a b) (Ioc b c) :=\n  (Iic_disjoint_Ioc le_rfl).mono Ioc_subset_Iic_self le_rfl\n\n"}
{"name":"Set.Ico_disjoint_Ico_same","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na b c : α\n⊢ Disjoint (Set.Ico a b) (Set.Ico b c)","decl":"@[simp]\ntheorem Ico_disjoint_Ico_same : Disjoint (Ico a b) (Ico b c) :=\n  disjoint_left.mpr fun _ hab hbc => hab.2.not_le hbc.1\n\n"}
{"name":"Set.Ici_disjoint_Iic","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na b : α\n⊢ Iff (Disjoint (Set.Ici a) (Set.Iic b)) (Not (LE.le a b))","decl":"@[simp]\ntheorem Ici_disjoint_Iic : Disjoint (Ici a) (Iic b) ↔ ¬a ≤ b := by\n  rw [Set.disjoint_iff_inter_eq_empty, Ici_inter_Iic, Icc_eq_empty_iff]\n\n"}
{"name":"Set.Iic_disjoint_Ici","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na b : α\n⊢ Iff (Disjoint (Set.Iic a) (Set.Ici b)) (Not (LE.le b a))","decl":"@[simp]\ntheorem Iic_disjoint_Ici : Disjoint (Iic a) (Ici b) ↔ ¬b ≤ a :=\n  disjoint_comm.trans Ici_disjoint_Iic\n\n"}
{"name":"Set.Ioc_disjoint_Ioi","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na b c : α\nh : LE.le b c\n⊢ Disjoint (Set.Ioc a b) (Set.Ioi c)","decl":"@[simp]\ntheorem Ioc_disjoint_Ioi (h : b ≤ c) : Disjoint (Ioc a b) (Ioi c) :=\n  disjoint_left.mpr (fun _ hx hy ↦ (hx.2.trans h).not_lt hy)\n\n"}
{"name":"Set.Ioc_disjoint_Ioi_same","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na b : α\n⊢ Disjoint (Set.Ioc a b) (Set.Ioi b)","decl":"theorem Ioc_disjoint_Ioi_same : Disjoint (Ioc a b) (Ioi b) :=\n  Ioc_disjoint_Ioi le_rfl\n\n"}
{"name":"Set.iUnion_Iic","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\n⊢ Eq (Set.iUnion fun a => Set.Iic a) Set.univ","decl":"@[simp]\ntheorem iUnion_Iic : ⋃ a : α, Iic a = univ :=\n  iUnion_eq_univ_iff.2 fun x => ⟨x, right_mem_Iic⟩\n\n"}
{"name":"Set.iUnion_Ici","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\n⊢ Eq (Set.iUnion fun a => Set.Ici a) Set.univ","decl":"@[simp]\ntheorem iUnion_Ici : ⋃ a : α, Ici a = univ :=\n  iUnion_eq_univ_iff.2 fun x => ⟨x, left_mem_Ici⟩\n\n"}
{"name":"Set.iUnion_Icc_right","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na : α\n⊢ Eq (Set.iUnion fun b => Set.Icc a b) (Set.Ici a)","decl":"@[simp]\ntheorem iUnion_Icc_right (a : α) : ⋃ b, Icc a b = Ici a := by\n  simp only [← Ici_inter_Iic, ← inter_iUnion, iUnion_Iic, inter_univ]\n\n"}
{"name":"Set.iUnion_Ioc_right","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\na : α\n⊢ Eq (Set.iUnion fun b => Set.Ioc a b) (Set.Ioi a)","decl":"@[simp]\ntheorem iUnion_Ioc_right (a : α) : ⋃ b, Ioc a b = Ioi a := by\n  simp only [← Ioi_inter_Iic, ← inter_iUnion, iUnion_Iic, inter_univ]\n\n"}
{"name":"Set.iUnion_Icc_left","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\nb : α\n⊢ Eq (Set.iUnion fun a => Set.Icc a b) (Set.Iic b)","decl":"@[simp]\ntheorem iUnion_Icc_left (b : α) : ⋃ a, Icc a b = Iic b := by\n  simp only [← Ici_inter_Iic, ← iUnion_inter, iUnion_Ici, univ_inter]\n\n"}
{"name":"Set.iUnion_Ico_left","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : Preorder α\nb : α\n⊢ Eq (Set.iUnion fun a => Set.Ico a b) (Set.Iio b)","decl":"@[simp]\ntheorem iUnion_Ico_left (b : α) : ⋃ a, Ico a b = Iio b := by\n  simp only [← Ici_inter_Iio, ← iUnion_inter, iUnion_Ici, univ_inter]\n\n"}
{"name":"Set.iUnion_Iio","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\n⊢ Eq (Set.iUnion fun a => Set.Iio a) Set.univ","decl":"@[simp]\ntheorem iUnion_Iio [NoMaxOrder α] : ⋃ a : α, Iio a = univ :=\n  iUnion_eq_univ_iff.2 exists_gt\n\n"}
{"name":"Set.iUnion_Ioi","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\n⊢ Eq (Set.iUnion fun a => Set.Ioi a) Set.univ","decl":"@[simp]\ntheorem iUnion_Ioi [NoMinOrder α] : ⋃ a : α, Ioi a = univ :=\n  iUnion_eq_univ_iff.2 exists_lt\n\n"}
{"name":"Set.iUnion_Ico_right","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Eq (Set.iUnion fun b => Set.Ico a b) (Set.Ici a)","decl":"@[simp]\ntheorem iUnion_Ico_right [NoMaxOrder α] (a : α) : ⋃ b, Ico a b = Ici a := by\n  simp only [← Ici_inter_Iio, ← inter_iUnion, iUnion_Iio, inter_univ]\n\n"}
{"name":"Set.iUnion_Ioo_right","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Eq (Set.iUnion fun b => Set.Ioo a b) (Set.Ioi a)","decl":"@[simp]\ntheorem iUnion_Ioo_right [NoMaxOrder α] (a : α) : ⋃ b, Ioo a b = Ioi a := by\n  simp only [← Ioi_inter_Iio, ← inter_iUnion, iUnion_Iio, inter_univ]\n\n"}
{"name":"Set.iUnion_Ioc_left","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\nb : α\n⊢ Eq (Set.iUnion fun a => Set.Ioc a b) (Set.Iic b)","decl":"@[simp]\ntheorem iUnion_Ioc_left [NoMinOrder α] (b : α) : ⋃ a, Ioc a b = Iic b := by\n  simp only [← Ioi_inter_Iic, ← iUnion_inter, iUnion_Ioi, univ_inter]\n\n"}
{"name":"Set.iUnion_Ioo_left","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\nb : α\n⊢ Eq (Set.iUnion fun a => Set.Ioo a b) (Set.Iio b)","decl":"@[simp]\ntheorem iUnion_Ioo_left [NoMinOrder α] (b : α) : ⋃ a, Ioo a b = Iio b := by\n  simp only [← Ioi_inter_Iio, ← iUnion_inter, iUnion_Ioi, univ_inter]\n\n"}
{"name":"Set.Ico_disjoint_Ico","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\n⊢ Iff (Disjoint (Set.Ico a₁ a₂) (Set.Ico b₁ b₂)) (LE.le (Min.min a₂ b₂) (Max.max a₁ b₁))","decl":"@[simp]\ntheorem Ico_disjoint_Ico : Disjoint (Ico a₁ a₂) (Ico b₁ b₂) ↔ min a₂ b₂ ≤ max a₁ b₁ := by\n  simp_rw [Set.disjoint_iff_inter_eq_empty, Ico_inter_Ico, Ico_eq_empty_iff, not_lt]\n\n"}
{"name":"Set.Ioc_disjoint_Ioc","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\n⊢ Iff (Disjoint (Set.Ioc a₁ a₂) (Set.Ioc b₁ b₂)) (LE.le (Min.min a₂ b₂) (Max.max a₁ b₁))","decl":"@[simp]\ntheorem Ioc_disjoint_Ioc : Disjoint (Ioc a₁ a₂) (Ioc b₁ b₂) ↔ min a₂ b₂ ≤ max a₁ b₁ := by\n  have h : _ ↔ min (toDual a₁) (toDual b₁) ≤ max (toDual a₂) (toDual b₂) := Ico_disjoint_Ico\n  simpa only [dual_Ico] using h\n\n"}
{"name":"Set.Ioo_disjoint_Ioo","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝¹ : LinearOrder α\na₁ a₂ b₁ b₂ : α\ninst✝ : DenselyOrdered α\n⊢ Iff (Disjoint (Set.Ioo a₁ a₂) (Set.Ioo b₁ b₂)) (LE.le (Min.min a₂ b₂) (Max.max a₁ b₁))","decl":"@[simp]\ntheorem Ioo_disjoint_Ioo [DenselyOrdered α] :\n    Disjoint (Set.Ioo a₁ a₂) (Set.Ioo b₁ b₂) ↔ min a₂ b₂ ≤ max a₁ b₁ := by\n  simp_rw [Set.disjoint_iff_inter_eq_empty, Ioo_inter_Ioo, Ioo_eq_empty_iff, not_lt]\n\n"}
{"name":"Set.eq_of_Ico_disjoint","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : LinearOrder α\nx₁ x₂ y₁ y₂ : α\nh : Disjoint (Set.Ico x₁ x₂) (Set.Ico y₁ y₂)\nhx : LT.lt x₁ x₂\nh2 : Membership.mem (Set.Ico y₁ y₂) x₂\n⊢ Eq y₁ x₂","decl":"/-- If two half-open intervals are disjoint and the endpoint of one lies in the other,\n  then it must be equal to the endpoint of the other. -/\ntheorem eq_of_Ico_disjoint {x₁ x₂ y₁ y₂ : α} (h : Disjoint (Ico x₁ x₂) (Ico y₁ y₂)) (hx : x₁ < x₂)\n    (h2 : x₂ ∈ Ico y₁ y₂) : y₁ = x₂ := by\n  rw [Ico_disjoint_Ico, min_eq_left (le_of_lt h2.2), le_max_iff] at h\n  apply le_antisymm h2.1\n  exact h.elim (fun h => absurd hx (not_lt_of_le h)) id\n\n"}
{"name":"Set.iUnion_Ico_eq_Iio_self_iff","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\nf : ι → α\na : α\n⊢ Iff (Eq (Set.iUnion fun i => Set.Ico (f i) a) (Set.Iio a)) (∀ (x : α), LT.lt x a → Exists fun i => LE.le (f i) x)","decl":"@[simp]\ntheorem iUnion_Ico_eq_Iio_self_iff {f : ι → α} {a : α} :\n    ⋃ i, Ico (f i) a = Iio a ↔ ∀ x < a, ∃ i, f i ≤ x := by\n  simp [← Ici_inter_Iio, ← iUnion_inter, subset_def]\n\n"}
{"name":"Set.iUnion_Ioc_eq_Ioi_self_iff","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\nf : ι → α\na : α\n⊢ Iff (Eq (Set.iUnion fun i => Set.Ioc a (f i)) (Set.Ioi a)) (∀ (x : α), LT.lt a x → Exists fun i => LE.le x (f i))","decl":"@[simp]\ntheorem iUnion_Ioc_eq_Ioi_self_iff {f : ι → α} {a : α} :\n    ⋃ i, Ioc a (f i) = Ioi a ↔ ∀ x, a < x → ∃ i, x ≤ f i := by\n  simp [← Ioi_inter_Iic, ← inter_iUnion, subset_def]\n\n"}
{"name":"Set.biUnion_Ico_eq_Iio_self_iff","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\np : ι → Prop\nf : (i : ι) → p i → α\na : α\n⊢ Iff (Eq (Set.iUnion fun i => Set.iUnion fun hi => Set.Ico (f i hi) a) (Set.Iio a)) (∀ (x : α), LT.lt x a → Exists fun i => Exists fun hi => LE.le (f i hi) x)","decl":"@[simp]\ntheorem biUnion_Ico_eq_Iio_self_iff {p : ι → Prop} {f : ∀ i, p i → α} {a : α} :\n    ⋃ (i) (hi : p i), Ico (f i hi) a = Iio a ↔ ∀ x < a, ∃ i hi, f i hi ≤ x := by\n  simp [← Ici_inter_Iio, ← iUnion_inter, subset_def]\n\n"}
{"name":"Set.biUnion_Ioc_eq_Ioi_self_iff","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\np : ι → Prop\nf : (i : ι) → p i → α\na : α\n⊢ Iff (Eq (Set.iUnion fun i => Set.iUnion fun hi => Set.Ioc a (f i hi)) (Set.Ioi a)) (∀ (x : α), LT.lt a x → Exists fun i => Exists fun hi => LE.le x (f i hi))","decl":"@[simp]\ntheorem biUnion_Ioc_eq_Ioi_self_iff {p : ι → Prop} {f : ∀ i, p i → α} {a : α} :\n    ⋃ (i) (hi : p i), Ioc a (f i hi) = Ioi a ↔ ∀ x, a < x → ∃ i hi, x ≤ f i hi := by\n  simp [← Ioi_inter_Iic, ← inter_iUnion, subset_def]\n\n"}
{"name":"IsGLB.biUnion_Ioi_eq","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : LinearOrder α\ns : Set α\na : α\nh : IsGLB s a\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => Set.Ioi x) (Set.Ioi a)","decl":"theorem IsGLB.biUnion_Ioi_eq (h : IsGLB s a) : ⋃ x ∈ s, Ioi x = Ioi a := by\n  refine (iUnion₂_subset fun x hx => ?_).antisymm fun x hx => ?_\n  · exact Ioi_subset_Ioi (h.1 hx)\n  · rcases h.exists_between hx with ⟨y, hys, _, hyx⟩\n    exact mem_biUnion hys hyx\n\n"}
{"name":"IsGLB.iUnion_Ioi_eq","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\na : α\nf : ι → α\nh : IsGLB (Set.range f) a\n⊢ Eq (Set.iUnion fun x => Set.Ioi (f x)) (Set.Ioi a)","decl":"theorem IsGLB.iUnion_Ioi_eq (h : IsGLB (range f) a) : ⋃ x, Ioi (f x) = Ioi a :=\n  biUnion_range.symm.trans h.biUnion_Ioi_eq\n\n"}
{"name":"IsLUB.biUnion_Iio_eq","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : LinearOrder α\ns : Set α\na : α\nh : IsLUB s a\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => Set.Iio x) (Set.Iio a)","decl":"theorem IsLUB.biUnion_Iio_eq (h : IsLUB s a) : ⋃ x ∈ s, Iio x = Iio a :=\n  h.dual.biUnion_Ioi_eq\n\n"}
{"name":"IsLUB.iUnion_Iio_eq","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\na : α\nf : ι → α\nh : IsLUB (Set.range f) a\n⊢ Eq (Set.iUnion fun x => Set.Iio (f x)) (Set.Iio a)","decl":"theorem IsLUB.iUnion_Iio_eq (h : IsLUB (range f) a) : ⋃ x, Iio (f x) = Iio a :=\n  h.dual.iUnion_Ioi_eq\n\n"}
{"name":"IsGLB.biUnion_Ici_eq_Ioi","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : LinearOrder α\ns : Set α\na : α\na_glb : IsGLB s a\na_not_mem : Not (Membership.mem s a)\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => Set.Ici x) (Set.Ioi a)","decl":"theorem IsGLB.biUnion_Ici_eq_Ioi (a_glb : IsGLB s a) (a_not_mem : a ∉ s) :\n    ⋃ x ∈ s, Ici x = Ioi a := by\n  refine (iUnion₂_subset fun x hx => ?_).antisymm fun x hx => ?_\n  · exact Ici_subset_Ioi.mpr (lt_of_le_of_ne (a_glb.1 hx) fun h => (h ▸ a_not_mem) hx)\n  · rcases a_glb.exists_between hx with ⟨y, hys, _, hyx⟩\n    rw [mem_iUnion₂]\n    exact ⟨y, hys, hyx.le⟩\n\n"}
{"name":"IsGLB.biUnion_Ici_eq_Ici","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : LinearOrder α\ns : Set α\na : α\na_glb : IsGLB s a\na_mem : Membership.mem s a\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => Set.Ici x) (Set.Ici a)","decl":"theorem IsGLB.biUnion_Ici_eq_Ici (a_glb : IsGLB s a) (a_mem : a ∈ s) :\n    ⋃ x ∈ s, Ici x = Ici a := by\n  refine (iUnion₂_subset fun x hx => ?_).antisymm fun x hx => ?_\n  · exact Ici_subset_Ici.mpr (mem_lowerBounds.mp a_glb.1 x hx)\n  · exact mem_iUnion₂.mpr ⟨a, a_mem, hx⟩\n\n"}
{"name":"IsLUB.biUnion_Iic_eq_Iio","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : LinearOrder α\ns : Set α\na : α\na_lub : IsLUB s a\na_not_mem : Not (Membership.mem s a)\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => Set.Iic x) (Set.Iio a)","decl":"theorem IsLUB.biUnion_Iic_eq_Iio (a_lub : IsLUB s a) (a_not_mem : a ∉ s) :\n    ⋃ x ∈ s, Iic x = Iio a :=\n  a_lub.dual.biUnion_Ici_eq_Ioi a_not_mem\n\n"}
{"name":"IsLUB.biUnion_Iic_eq_Iic","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"α : Type v\ninst✝ : LinearOrder α\ns : Set α\na : α\na_lub : IsLUB s a\na_mem : Membership.mem s a\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => Set.Iic x) (Set.Iic a)","decl":"theorem IsLUB.biUnion_Iic_eq_Iic (a_lub : IsLUB s a) (a_mem : a ∈ s) : ⋃ x ∈ s, Iic x = Iic a :=\n  a_lub.dual.biUnion_Ici_eq_Ici a_mem\n\n"}
{"name":"iUnion_Ici_eq_Ioi_iInf","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nR : Type u_1\ninst✝ : CompleteLinearOrder R\nf : ι → R\nno_least_elem : Not (Membership.mem (Set.range f) (iInf fun i => f i))\n⊢ Eq (Set.iUnion fun i => Set.Ici (f i)) (Set.Ioi (iInf fun i => f i))","decl":"theorem iUnion_Ici_eq_Ioi_iInf {R : Type*} [CompleteLinearOrder R] {f : ι → R}\n    (no_least_elem : ⨅ i, f i ∉ range f) : ⋃ i : ι, Ici (f i) = Ioi (⨅ i, f i) := by\n  simp only [← IsGLB.biUnion_Ici_eq_Ioi (@isGLB_iInf _ _ _ f) no_least_elem, mem_range,\n    iUnion_exists, iUnion_iUnion_eq']\n\n"}
{"name":"iUnion_Iic_eq_Iio_iSup","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nR : Type u_1\ninst✝ : CompleteLinearOrder R\nf : ι → R\nno_greatest_elem : Not (Membership.mem (Set.range f) (iSup fun i => f i))\n⊢ Eq (Set.iUnion fun i => Set.Iic (f i)) (Set.Iio (iSup fun i => f i))","decl":"theorem iUnion_Iic_eq_Iio_iSup {R : Type*} [CompleteLinearOrder R] {f : ι → R}\n    (no_greatest_elem : (⨆ i, f i) ∉ range f) : ⋃ i : ι, Iic (f i) = Iio (⨆ i, f i) :=\n  @iUnion_Ici_eq_Ioi_iInf ι (OrderDual R) _ f no_greatest_elem\n\n"}
{"name":"iUnion_Ici_eq_Ici_iInf","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nR : Type u_1\ninst✝ : CompleteLinearOrder R\nf : ι → R\nhas_least_elem : Membership.mem (Set.range f) (iInf fun i => f i)\n⊢ Eq (Set.iUnion fun i => Set.Ici (f i)) (Set.Ici (iInf fun i => f i))","decl":"theorem iUnion_Ici_eq_Ici_iInf {R : Type*} [CompleteLinearOrder R] {f : ι → R}\n    (has_least_elem : (⨅ i, f i) ∈ range f) : ⋃ i : ι, Ici (f i) = Ici (⨅ i, f i) := by\n  simp only [← IsGLB.biUnion_Ici_eq_Ici (@isGLB_iInf _ _ _ f) has_least_elem, mem_range,\n    iUnion_exists, iUnion_iUnion_eq']\n\n"}
{"name":"iUnion_Iic_eq_Iic_iSup","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nR : Type u_1\ninst✝ : CompleteLinearOrder R\nf : ι → R\nhas_greatest_elem : Membership.mem (Set.range f) (iSup fun i => f i)\n⊢ Eq (Set.iUnion fun i => Set.Iic (f i)) (Set.Iic (iSup fun i => f i))","decl":"theorem iUnion_Iic_eq_Iic_iSup {R : Type*} [CompleteLinearOrder R] {f : ι → R}\n    (has_greatest_elem : (⨆ i, f i) ∈ range f) : ⋃ i : ι, Iic (f i) = Iic (⨆ i, f i) :=\n  @iUnion_Ici_eq_Ici_iInf ι (OrderDual R) _ f has_greatest_elem\n\n"}
{"name":"iUnion_Iio_eq_univ_iff","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\nf : ι → α\n⊢ Iff (Eq (Set.iUnion fun i => Set.Iio (f i)) Set.univ) (Not (BddAbove (Set.range f)))","decl":"theorem iUnion_Iio_eq_univ_iff : ⋃ i, Iio (f i) = univ ↔ (¬ BddAbove (range f)) := by\n  simp [not_bddAbove_iff, Set.eq_univ_iff_forall]\n\n"}
{"name":"iUnion_Iic_of_not_bddAbove_range","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\nf : ι → α\nhf : Not (BddAbove (Set.range f))\n⊢ Eq (Set.iUnion fun i => Set.Iic (f i)) Set.univ","decl":"theorem iUnion_Iic_of_not_bddAbove_range (hf : ¬ BddAbove (range f)) : ⋃ i, Iic (f i) = univ := by\n  refine  Set.eq_univ_of_subset ?_ (iUnion_Iio_eq_univ_iff.mpr hf)\n  gcongr\n  exact Iio_subset_Iic_self\n\n"}
{"name":"iInter_Iic_eq_empty_iff","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\nf : ι → α\n⊢ Iff (Eq (Set.iInter fun i => Set.Iic (f i)) EmptyCollection.emptyCollection) (Not (BddBelow (Set.range f)))","decl":"theorem iInter_Iic_eq_empty_iff : ⋂ i, Iic (f i) = ∅ ↔ ¬ BddBelow (range f) := by\n  simp [not_bddBelow_iff, Set.eq_empty_iff_forall_not_mem]\n\n"}
{"name":"iInter_Iio_of_not_bddBelow_range","module":"Mathlib.Order.Interval.Set.Disjoint","initialProofState":"ι : Sort u\nα : Type v\ninst✝ : LinearOrder α\nf : ι → α\nhf : Not (BddBelow (Set.range f))\n⊢ Eq (Set.iInter fun i => Set.Iio (f i)) EmptyCollection.emptyCollection","decl":"theorem iInter_Iio_of_not_bddBelow_range (hf : ¬ BddBelow (range f)) : ⋂ i, Iio (f i) = ∅ := by\n  refine eq_empty_of_subset_empty ?_\n  rw [← iInter_Iic_eq_empty_iff.mpr hf]\n  gcongr\n  exact Iio_subset_Iic_self\n\n"}
