{"name":"NumberField.classNumber_eq_one_iff","module":"Mathlib.NumberTheory.NumberField.ClassNumber","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Iff (Eq (NumberField.classNumber K) 1) (IsPrincipalIdealRing (NumberField.RingOfIntegers K))","decl":"/-- The class number of a number field is `1` iff the ring of integers is a PID. -/\ntheorem classNumber_eq_one_iff : classNumber K = 1 ↔ IsPrincipalIdealRing (𝓞 K) :=\n  card_classGroup_eq_one_iff\n\n"}
{"name":"NumberField.exists_ideal_in_class_of_norm_le","module":"Mathlib.NumberTheory.NumberField.ClassNumber","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nC : ClassGroup (NumberField.RingOfIntegers K)\n⊢ Exists fun I => And (Eq (ClassGroup.mk0 I) C) (LE.le (↑(Ideal.absNorm ↑I)) (HMul.hMul (HPow.hPow (HDiv.hDiv 4 Real.pi) (NumberField.InfinitePlace.nrComplexPlaces K)) (HMul.hMul (HDiv.hDiv (↑(Module.finrank Rat K).factorial) (HPow.hPow (↑(Module.finrank Rat K)) (Module.finrank Rat K))) (abs ↑(NumberField.discr K)).sqrt)))","decl":"theorem exists_ideal_in_class_of_norm_le (C : ClassGroup (𝓞 K)) :\n    ∃ I : (Ideal (𝓞 K))⁰, ClassGroup.mk0 I = C ∧\n      Ideal.absNorm (I : Ideal (𝓞 K)) ≤ (4 / π) ^ nrComplexPlaces K *\n        ((finrank ℚ K).factorial / (finrank ℚ K) ^ (finrank ℚ K) * Real.sqrt |discr K|) := by\n  obtain ⟨J, hJ⟩ := ClassGroup.mk0_surjective C⁻¹\n  obtain ⟨_, ⟨a, ha, rfl⟩, h_nz, h_nm⟩ :=\n    exists_ne_zero_mem_ideal_of_norm_le_mul_sqrt_discr K (FractionalIdeal.mk0 K J)\n  obtain ⟨I₀, hI⟩ := Ideal.dvd_iff_le.mpr ((Ideal.span_singleton_le_iff_mem J).mpr (by convert ha))\n  have : I₀ ≠ 0 := by\n    contrapose! h_nz\n    rw [h_nz, mul_zero, show 0 = (⊥ : Ideal (𝓞 K)) by rfl, Ideal.span_singleton_eq_bot] at hI\n    rw [Algebra.linearMap_apply, hI, map_zero]\n  let I := (⟨I₀, mem_nonZeroDivisors_iff_ne_zero.mpr this⟩ : (Ideal (𝓞 K))⁰)\n  refine ⟨I, ?_, ?_⟩\n  · suffices ClassGroup.mk0 I = (ClassGroup.mk0 J)⁻¹ by rw [this, hJ, inv_inv]\n    exact ClassGroup.mk0_eq_mk0_inv_iff.mpr ⟨a, Subtype.coe_ne_coe.1 h_nz, by rw [mul_comm, hI]⟩\n  · rw [← FractionalIdeal.absNorm_span_singleton (𝓞 K), Algebra.linearMap_apply,\n      ← FractionalIdeal.coeIdeal_span_singleton, FractionalIdeal.coeIdeal_absNorm, hI, map_mul,\n      Nat.cast_mul, Rat.cast_mul, show Ideal.absNorm I₀ = Ideal.absNorm (I : Ideal (𝓞 K)) by rfl,\n      Rat.cast_natCast, Rat.cast_natCast, FractionalIdeal.coe_mk0,\n      FractionalIdeal.coeIdeal_absNorm, Rat.cast_natCast, mul_div_assoc, mul_assoc, mul_assoc]\n      at h_nm\n    refine le_of_mul_le_mul_of_pos_left h_nm ?_\n    exact Nat.cast_pos.mpr <| Nat.pos_of_ne_zero <| Ideal.absNorm_ne_zero_of_nonZeroDivisors J\n\n"}
{"name":"RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt","module":"Mathlib.NumberTheory.NumberField.ClassNumber","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\nh : LT.lt (↑(abs (NumberField.discr K))) (HPow.hPow (HMul.hMul (HMul.hMul 2 (HPow.hPow (HDiv.hDiv Real.pi 4) (NumberField.InfinitePlace.nrComplexPlaces K))) (HDiv.hDiv (HPow.hPow (↑(Module.finrank Rat K)) (Module.finrank Rat K)) ↑(Module.finrank Rat K).factorial)) 2)\n⊢ IsPrincipalIdealRing (NumberField.RingOfIntegers K)","decl":"theorem _root_.RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt\n    (h : |discr K| < (2 * (π / 4) ^ nrComplexPlaces K *\n      ((finrank ℚ K) ^ (finrank ℚ K) / (finrank ℚ K).factorial)) ^ 2) :\n    IsPrincipalIdealRing (𝓞 K) := by\n  have : 0 < finrank ℚ K := finrank_pos -- Lean needs to know that for positivity to succeed\n  rw [← Real.sqrt_lt (by positivity) (by positivity), mul_assoc, ← inv_mul_lt_iff₀' (by positivity),\n    mul_inv, ← inv_pow, inv_div, inv_div, mul_assoc, Int.cast_abs] at h\n  rw [← classNumber_eq_one_iff, classNumber, Fintype.card_eq_one_iff]\n  refine ⟨1, fun C ↦ ?_⟩\n  obtain ⟨I, rfl, hI⟩ := exists_ideal_in_class_of_norm_le C\n  have : Ideal.absNorm I.1 = 1 := by\n    refine le_antisymm (Nat.lt_succ.mp ?_) (Nat.one_le_iff_ne_zero.mpr\n      (Ideal.absNorm_ne_zero_of_nonZeroDivisors I))\n    exact Nat.cast_lt.mp <| lt_of_le_of_lt hI h\n  rw [ClassGroup.mk0_eq_one_iff, Ideal.absNorm_eq_one_iff.mp this]\n  exact top_isPrincipal\n\n"}
{"name":"Rat.classNumber_eq","module":"Mathlib.NumberTheory.NumberField.ClassNumber","initialProofState":"⊢ Eq (NumberField.classNumber Rat) 1","decl":"theorem classNumber_eq : NumberField.classNumber ℚ = 1 :=\n  classNumber_eq_one_iff.mpr <| by\n    convert IsPrincipalIdealRing.of_surjective\n      (Rat.ringOfIntegersEquiv.symm : ℤ →+* 𝓞 ℚ) Rat.ringOfIntegersEquiv.symm.surjective\n\n"}
