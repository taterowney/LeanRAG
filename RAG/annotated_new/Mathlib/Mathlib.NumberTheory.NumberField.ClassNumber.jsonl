{"name":"NumberField.classNumber_eq_one_iff","module":"Mathlib.NumberTheory.NumberField.ClassNumber","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Iff (Eq (NumberField.classNumber K) 1) (IsPrincipalIdealRing (NumberField.RingOfIntegers K))","decl":"/-- The class number of a number field is `1` iff the ring of integers is a PID. -/\ntheorem classNumber_eq_one_iff : classNumber K = 1 â†” IsPrincipalIdealRing (ğ“ K) :=\n  card_classGroup_eq_one_iff\n\n"}
{"name":"NumberField.exists_ideal_in_class_of_norm_le","module":"Mathlib.NumberTheory.NumberField.ClassNumber","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nC : ClassGroup (NumberField.RingOfIntegers K)\nâŠ¢ Exists fun I => And (Eq (ClassGroup.mk0 I) C) (LE.le (â†‘(Ideal.absNorm â†‘I)) (HMul.hMul (HPow.hPow (HDiv.hDiv 4 Real.pi) (NumberField.InfinitePlace.nrComplexPlaces K)) (HMul.hMul (HDiv.hDiv (â†‘(Module.finrank Rat K).factorial) (HPow.hPow (â†‘(Module.finrank Rat K)) (Module.finrank Rat K))) (abs â†‘(NumberField.discr K)).sqrt)))","decl":"theorem exists_ideal_in_class_of_norm_le (C : ClassGroup (ğ“ K)) :\n    âˆƒ I : (Ideal (ğ“ K))â°, ClassGroup.mk0 I = C âˆ§\n      Ideal.absNorm (I : Ideal (ğ“ K)) â‰¤ (4 / Ï€) ^ nrComplexPlaces K *\n        ((finrank â„š K).factorial / (finrank â„š K) ^ (finrank â„š K) * Real.sqrt |discr K|) := by\n  obtain âŸ¨J, hJâŸ© := ClassGroup.mk0_surjective Câ»Â¹\n  obtain âŸ¨_, âŸ¨a, ha, rflâŸ©, h_nz, h_nmâŸ© :=\n    exists_ne_zero_mem_ideal_of_norm_le_mul_sqrt_discr K (FractionalIdeal.mk0 K J)\n  obtain âŸ¨Iâ‚€, hIâŸ© := Ideal.dvd_iff_le.mpr ((Ideal.span_singleton_le_iff_mem J).mpr (by convert ha))\n  have : Iâ‚€ â‰  0 := by\n    contrapose! h_nz\n    rw [h_nz, mul_zero, show 0 = (âŠ¥ : Ideal (ğ“ K)) by rfl, Ideal.span_singleton_eq_bot] at hI\n    rw [Algebra.linearMap_apply, hI, map_zero]\n  let I := (âŸ¨Iâ‚€, mem_nonZeroDivisors_iff_ne_zero.mpr thisâŸ© : (Ideal (ğ“ K))â°)\n  refine âŸ¨I, ?_, ?_âŸ©\n  Â· suffices ClassGroup.mk0 I = (ClassGroup.mk0 J)â»Â¹ by rw [this, hJ, inv_inv]\n    exact ClassGroup.mk0_eq_mk0_inv_iff.mpr âŸ¨a, Subtype.coe_ne_coe.1 h_nz, by rw [mul_comm, hI]âŸ©\n  Â· rw [â† FractionalIdeal.absNorm_span_singleton (ğ“ K), Algebra.linearMap_apply,\n      â† FractionalIdeal.coeIdeal_span_singleton, FractionalIdeal.coeIdeal_absNorm, hI, map_mul,\n      Nat.cast_mul, Rat.cast_mul, show Ideal.absNorm Iâ‚€ = Ideal.absNorm (I : Ideal (ğ“ K)) by rfl,\n      Rat.cast_natCast, Rat.cast_natCast, FractionalIdeal.coe_mk0,\n      FractionalIdeal.coeIdeal_absNorm, Rat.cast_natCast, mul_div_assoc, mul_assoc, mul_assoc]\n      at h_nm\n    refine le_of_mul_le_mul_of_pos_left h_nm ?_\n    exact Nat.cast_pos.mpr <| Nat.pos_of_ne_zero <| Ideal.absNorm_ne_zero_of_nonZeroDivisors J\n\n"}
{"name":"RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt","module":"Mathlib.NumberTheory.NumberField.ClassNumber","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nh : LT.lt (â†‘(abs (NumberField.discr K))) (HPow.hPow (HMul.hMul (HMul.hMul 2 (HPow.hPow (HDiv.hDiv Real.pi 4) (NumberField.InfinitePlace.nrComplexPlaces K))) (HDiv.hDiv (HPow.hPow (â†‘(Module.finrank Rat K)) (Module.finrank Rat K)) â†‘(Module.finrank Rat K).factorial)) 2)\nâŠ¢ IsPrincipalIdealRing (NumberField.RingOfIntegers K)","decl":"theorem _root_.RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt\n    (h : |discr K| < (2 * (Ï€ / 4) ^ nrComplexPlaces K *\n      ((finrank â„š K) ^ (finrank â„š K) / (finrank â„š K).factorial)) ^ 2) :\n    IsPrincipalIdealRing (ğ“ K) := by\n  have : 0 < finrank â„š K := finrank_pos -- Lean needs to know that for positivity to succeed\n  rw [â† Real.sqrt_lt (by positivity) (by positivity), mul_assoc, â† inv_mul_lt_iffâ‚€' (by positivity),\n    mul_inv, â† inv_pow, inv_div, inv_div, mul_assoc, Int.cast_abs] at h\n  rw [â† classNumber_eq_one_iff, classNumber, Fintype.card_eq_one_iff]\n  refine âŸ¨1, fun C â†¦ ?_âŸ©\n  obtain âŸ¨I, rfl, hIâŸ© := exists_ideal_in_class_of_norm_le C\n  have : Ideal.absNorm I.1 = 1 := by\n    refine le_antisymm (Nat.lt_succ.mp ?_) (Nat.one_le_iff_ne_zero.mpr\n      (Ideal.absNorm_ne_zero_of_nonZeroDivisors I))\n    exact Nat.cast_lt.mp <| lt_of_le_of_lt hI h\n  rw [ClassGroup.mk0_eq_one_iff, Ideal.absNorm_eq_one_iff.mp this]\n  exact top_isPrincipal\n\n"}
{"name":"Rat.classNumber_eq","module":"Mathlib.NumberTheory.NumberField.ClassNumber","initialProofState":"âŠ¢ Eq (NumberField.classNumber Rat) 1","decl":"theorem classNumber_eq : NumberField.classNumber â„š = 1 :=\n  classNumber_eq_one_iff.mpr <| by\n    convert IsPrincipalIdealRing.of_surjective\n      (Rat.ringOfIntegersEquiv.symm : â„¤ â†’+* ğ“ â„š) Rat.ringOfIntegersEquiv.symm.surjective\n\n"}
