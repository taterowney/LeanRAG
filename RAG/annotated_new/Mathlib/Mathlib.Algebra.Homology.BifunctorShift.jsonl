{"name":"CochainComplex.mapBifunctorHomologicalComplexShift₁Iso_inv_f_f","module":"Mathlib.Algebra.Homology.BifunctorShift","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} D\ninst✝⁴ : CategoryTheory.Preadditive C₁\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝² : CategoryTheory.Preadditive D\nK₁ : CochainComplex C₁ Int\nK₂ : CochainComplex C₂ Int\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝¹ : F.Additive\ninst✝ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nx i x✝ : Int\n⊢ Eq (((K₁.mapBifunctorHomologicalComplexShift₁Iso K₂ F x).inv.f i).f x✝) (CategoryTheory.CategoryStruct.id ((F.obj (K₁.X (HAdd.hAdd i x))).obj (K₂.X x✝)))","decl":"/-- Auxiliary definition for `mapBifunctorShift₁Iso`. -/\n@[simps! hom_f_f inv_f_f]\ndef mapBifunctorHomologicalComplexShift₁Iso :\n    ((F.mapBifunctorHomologicalComplex _ _).obj (K₁⟦x⟧)).obj K₂ ≅\n    (HomologicalComplex₂.shiftFunctor₁ D x).obj\n      (((F.mapBifunctorHomologicalComplex _ _).obj K₁).obj K₂) :=\n  HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _) (by\n    intros\n    ext\n    dsimp\n    simp only [Linear.comp_units_smul, id_comp, Functor.map_units_smul,\n      NatTrans.app_units_zsmul, comp_id])\n\n"}
{"name":"CochainComplex.mapBifunctorHomologicalComplexShift₁Iso_hom_f_f","module":"Mathlib.Algebra.Homology.BifunctorShift","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} D\ninst✝⁴ : CategoryTheory.Preadditive C₁\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝² : CategoryTheory.Preadditive D\nK₁ : CochainComplex C₁ Int\nK₂ : CochainComplex C₂ Int\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝¹ : F.Additive\ninst✝ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nx i x✝ : Int\n⊢ Eq (((K₁.mapBifunctorHomologicalComplexShift₁Iso K₂ F x).hom.f i).f x✝) (CategoryTheory.CategoryStruct.id ((F.obj (K₁.X (HAdd.hAdd i x))).obj (K₂.X x✝)))","decl":"/-- Auxiliary definition for `mapBifunctorShift₁Iso`. -/\n@[simps! hom_f_f inv_f_f]\ndef mapBifunctorHomologicalComplexShift₁Iso :\n    ((F.mapBifunctorHomologicalComplex _ _).obj (K₁⟦x⟧)).obj K₂ ≅\n    (HomologicalComplex₂.shiftFunctor₁ D x).obj\n      (((F.mapBifunctorHomologicalComplex _ _).obj K₁).obj K₂) :=\n  HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _) (by\n    intros\n    ext\n    dsimp\n    simp only [Linear.comp_units_smul, id_comp, Functor.map_units_smul,\n      NatTrans.app_units_zsmul, comp_id])\n\n"}
{"name":"CochainComplex.instHasMapBifunctorObjIntShiftFunctor","module":"Mathlib.Algebra.Homology.BifunctorShift","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C₁\ninst✝⁷ : CategoryTheory.Category.{u_5, u_2} C₂\ninst✝⁶ : CategoryTheory.Category.{u_6, u_3} D\ninst✝⁵ : CategoryTheory.Preadditive C₁\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C₂\ninst✝³ : CategoryTheory.Preadditive D\nK₁ : CochainComplex C₁ Int\nK₂ : CochainComplex C₂ Int\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝² : F.Additive\ninst✝¹ : ∀ (X₁ : C₁), (F.obj X₁).PreservesZeroMorphisms\nx : Int\ninst✝ : K₁.HasMapBifunctor K₂ F\n⊢ ((CategoryTheory.shiftFunctor (CochainComplex C₁ Int) x).obj K₁).HasMapBifunctor K₂ F","decl":"instance : HasMapBifunctor (K₁⟦x⟧) K₂ F :=\n  HomologicalComplex₂.hasTotal_of_iso (mapBifunctorHomologicalComplexShift₁Iso K₁ K₂ F x).symm _\n\n"}
{"name":"CochainComplex.mapBifunctorHomologicalComplexShift₂Iso_hom_f_f","module":"Mathlib.Algebra.Homology.BifunctorShift","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝³ : CategoryTheory.Preadditive C₂\ninst✝² : CategoryTheory.Preadditive D\nK₁ : CochainComplex C₁ Int\nK₂ : CochainComplex C₂ Int\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : ∀ (X₁ : C₁), (F.obj X₁).Additive\ny i✝ i : Int\n⊢ Eq (((K₁.mapBifunctorHomologicalComplexShift₂Iso K₂ F y).hom.f i✝).f i) (CategoryTheory.CategoryStruct.id ((F.obj (K₁.X i✝)).obj (K₂.X (HAdd.hAdd i y))))","decl":"/-- Auxiliary definition for `mapBifunctorShift₂Iso`. -/\n@[simps! hom_f_f inv_f_f]\ndef mapBifunctorHomologicalComplexShift₂Iso :\n    ((F.mapBifunctorHomologicalComplex _ _).obj K₁).obj (K₂⟦y⟧) ≅\n    (HomologicalComplex₂.shiftFunctor₂ D y).obj\n      (((F.mapBifunctorHomologicalComplex _ _).obj K₁).obj K₂) :=\n  HomologicalComplex.Hom.isoOfComponents\n    (fun i₁ => HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _)) (by\n      intros\n      ext\n      dsimp\n      simp only [id_comp, comp_id])\n\n"}
{"name":"CochainComplex.mapBifunctorHomologicalComplexShift₂Iso_inv_f_f","module":"Mathlib.Algebra.Homology.BifunctorShift","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝³ : CategoryTheory.Preadditive C₂\ninst✝² : CategoryTheory.Preadditive D\nK₁ : CochainComplex C₁ Int\nK₂ : CochainComplex C₂ Int\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : ∀ (X₁ : C₁), (F.obj X₁).Additive\ny i✝ i : Int\n⊢ Eq (((K₁.mapBifunctorHomologicalComplexShift₂Iso K₂ F y).inv.f i✝).f i) (CategoryTheory.CategoryStruct.id ((F.obj (K₁.X i✝)).obj (K₂.X (HAdd.hAdd i y))))","decl":"/-- Auxiliary definition for `mapBifunctorShift₂Iso`. -/\n@[simps! hom_f_f inv_f_f]\ndef mapBifunctorHomologicalComplexShift₂Iso :\n    ((F.mapBifunctorHomologicalComplex _ _).obj K₁).obj (K₂⟦y⟧) ≅\n    (HomologicalComplex₂.shiftFunctor₂ D y).obj\n      (((F.mapBifunctorHomologicalComplex _ _).obj K₁).obj K₂) :=\n  HomologicalComplex.Hom.isoOfComponents\n    (fun i₁ => HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _)) (by\n      intros\n      ext\n      dsimp\n      simp only [id_comp, comp_id])\n\n"}
{"name":"CochainComplex.instHasMapBifunctorObjIntShiftFunctor_1","module":"Mathlib.Algebra.Homology.BifunctorShift","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C₁\ninst✝⁷ : CategoryTheory.Category.{u_5, u_2} C₂\ninst✝⁶ : CategoryTheory.Category.{u_6, u_3} D\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C₁\ninst✝⁴ : CategoryTheory.Preadditive C₂\ninst✝³ : CategoryTheory.Preadditive D\nK₁ : CochainComplex C₁ Int\nK₂ : CochainComplex C₂ Int\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : ∀ (X₁ : C₁), (F.obj X₁).Additive\ny : Int\ninst✝ : K₁.HasMapBifunctor K₂ F\n⊢ K₁.HasMapBifunctor ((CategoryTheory.shiftFunctor (CochainComplex C₂ Int) y).obj K₂) F","decl":"instance : HasMapBifunctor K₁ (K₂⟦y⟧) F :=\n  HomologicalComplex₂.hasTotal_of_iso (mapBifunctorHomologicalComplexShift₂Iso K₁ K₂ F y).symm _\n\n"}
{"name":"CochainComplex.mapBifunctorShift₁Iso_trans_mapBifunctorShift₂Iso","module":"Mathlib.Algebra.Homology.BifunctorShift","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝⁷ : CategoryTheory.Category.{u_6, u_2} C₂\ninst✝⁶ : CategoryTheory.Category.{u_4, u_3} D\ninst✝⁵ : CategoryTheory.Preadditive C₁\ninst✝⁴ : CategoryTheory.Preadditive C₂\ninst✝³ : CategoryTheory.Preadditive D\nK₁ : CochainComplex C₁ Int\nK₂ : CochainComplex C₂ Int\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ D)\ninst✝² : F.Additive\ninst✝¹ : ∀ (X₁ : C₁), (F.obj X₁).Additive\nx y : Int\ninst✝ : K₁.HasMapBifunctor K₂ F\n⊢ Eq ((K₁.mapBifunctorShift₁Iso ((CategoryTheory.shiftFunctor (CochainComplex C₂ Int) y).obj K₂) F x).trans ((CategoryTheory.shiftFunctor (CochainComplex D Int) x).mapIso (K₁.mapBifunctorShift₂Iso K₂ F y))) (HSMul.hSMul (HMul.hMul x y).negOnePow ((((CategoryTheory.shiftFunctor (CochainComplex C₁ Int) x).obj K₁).mapBifunctorShift₂Iso K₂ F y).trans (((CategoryTheory.shiftFunctor (CochainComplex D Int) y).mapIso (K₁.mapBifunctorShift₁Iso K₂ F x)).trans ((CategoryTheory.shiftFunctorComm (CochainComplex D Int) x y).app (K₁.mapBifunctor K₂ F)))))","decl":"lemma mapBifunctorShift₁Iso_trans_mapBifunctorShift₂Iso :\n    mapBifunctorShift₁Iso K₁ (K₂⟦y⟧) F x ≪≫\n      (CategoryTheory.shiftFunctor _ x).mapIso (mapBifunctorShift₂Iso K₁ K₂ F y) =\n      (x * y).negOnePow • (mapBifunctorShift₂Iso (K₁⟦x⟧) K₂ F y ≪≫\n        (CategoryTheory.shiftFunctor _ y).mapIso (mapBifunctorShift₁Iso K₁ K₂ F x) ≪≫\n          (shiftFunctorComm (CochainComplex D ℤ) x y).app _) := by\n  ext1\n  dsimp [mapBifunctorShift₁Iso, mapBifunctorShift₂Iso]\n  rw [Functor.map_comp, Functor.map_comp, assoc, assoc, assoc,\n    ← HomologicalComplex₂.totalShift₁Iso_hom_naturality_assoc,\n    HomologicalComplex₂.totalShift₁Iso_hom_totalShift₂Iso_hom,\n    ← HomologicalComplex₂.totalShift₂Iso_hom_naturality_assoc,\n    Linear.comp_units_smul, Linear.comp_units_smul,\n    smul_left_cancel_iff,\n    ← HomologicalComplex₂.total.map_comp_assoc,\n    ← HomologicalComplex₂.total.map_comp_assoc,\n    ← HomologicalComplex₂.total.map_comp_assoc]\n  congr 2\n  ext a b\n  dsimp [HomologicalComplex₂.shiftFunctor₁₂CommIso]\n  simp only [id_comp]\n\n"}
