{"name":"hasSum_mellin","module":"Mathlib.NumberTheory.LSeries.MellinEqDirichlet","initialProofState":"ι : Type u_1\ninst✝ : Countable ι\na : ι → Complex\np : ι → Real\nF : Real → Complex\ns : Complex\nhp : ∀ (i : ι), Or (Eq (a i) 0) (LT.lt 0 (p i))\nhs : LT.lt 0 s.re\nhF : ∀ (t : Real), Membership.mem (Set.Ioi 0) t → HasSum (fun i => HMul.hMul (a i) ↑(Real.exp (HMul.hMul (Neg.neg (p i)) t))) (F t)\nh_sum : Summable fun i => HDiv.hDiv (Norm.norm (a i)) (HPow.hPow (p i) s.re)\n⊢ HasSum (fun i => HDiv.hDiv (HMul.hMul (Complex.Gamma s) (a i)) (HPow.hPow (↑(p i)) s)) (mellin F s)","decl":"/-- Most basic version of the \"Mellin transform = Dirichlet series\" argument. -/\nlemma hasSum_mellin {a : ι → ℂ} {p : ι → ℝ} {F : ℝ → ℂ} {s : ℂ}\n    (hp : ∀ i, a i = 0 ∨ 0 < p i) (hs : 0 < s.re)\n    (hF : ∀ t ∈ Ioi 0, HasSum (fun i ↦ a i * rexp (-p i * t)) (F t))\n    (h_sum : Summable fun i ↦ ‖a i‖ / (p i) ^ s.re) :\n    HasSum (fun i ↦ Gamma s * a i / p i ^ s) (mellin F s) := by\n  simp_rw [mellin, smul_eq_mul, ← setIntegral_congr_fun measurableSet_Ioi\n    (fun t ht ↦ congr_arg _ (hF t ht).tsum_eq), ← tsum_mul_left]\n  convert hasSum_integral_of_summable_integral_norm\n    (F := fun i t ↦ t ^ (s - 1) * (a i * rexp (-p i * t))) (fun i ↦ ?_) ?_ using 2 with i\n  · simp_rw [← mul_assoc, mul_comm _ (a _), mul_assoc (a _), mul_div_assoc, integral_mul_left]\n    rcases hp i with hai | hpi\n    · rw [hai, zero_mul, zero_mul]\n    have := integral_cpow_mul_exp_neg_mul_Ioi hs hpi\n    simp_rw [← ofReal_mul, ← ofReal_neg, ← ofReal_exp, ← neg_mul (p i)] at this\n    rw [this, one_div, inv_cpow _ _ (arg_ofReal_of_nonneg hpi.le ▸ pi_pos.ne), div_eq_inv_mul]\n  · -- integrability of terms\n    rcases hp i with hai | hpi\n    · simp [hai]\n    simp_rw [← mul_assoc, mul_comm _ (a i), mul_assoc]\n    have := Complex.GammaIntegral_convergent hs\n    rw [← mul_zero (p i), ← integrableOn_Ioi_comp_mul_left_iff _ _ hpi] at this\n    refine (IntegrableOn.congr_fun (this.const_mul (1 / p i ^ (s - 1)))\n      (fun t (ht : 0 < t) ↦ ?_) measurableSet_Ioi).const_mul _\n    simp_rw [mul_comm (↑(rexp _) : ℂ), ← mul_assoc, neg_mul, ofReal_mul]\n    rw [mul_cpow_ofReal_nonneg hpi.le ht.le, ← mul_assoc, one_div, inv_mul_cancel₀, one_mul]\n    rw [Ne, cpow_eq_zero_iff, not_and_or]\n    exact Or.inl (ofReal_ne_zero.mpr hpi.ne')\n  · -- summability of integrals of norms\n    apply Summable.of_norm\n    convert h_sum.mul_left (Real.Gamma s.re) using 2 with i\n    simp_rw [← mul_assoc, mul_comm _ (a i), mul_assoc, norm_mul (a i), integral_mul_left]\n    rw [← mul_div_assoc, mul_comm (Real.Gamma _), mul_div_assoc, norm_mul ‖a i‖, norm_norm]\n    rcases hp i with hai | hpi\n    · simp [hai]\n    congr 1\n    have := Real.integral_rpow_mul_exp_neg_mul_Ioi hs hpi\n    simp_rw [← neg_mul (p i), one_div, inv_rpow hpi.le, ← div_eq_inv_mul] at this\n    rw [norm_of_nonneg (integral_nonneg (fun _ ↦ norm_nonneg _)), ← this]\n    refine setIntegral_congr_fun measurableSet_Ioi (fun t ht ↦ ?_)\n    rw [norm_mul, norm_real, Real.norm_eq_abs, Real.abs_exp, Complex.norm_eq_abs,\n      abs_cpow_eq_rpow_re_of_pos ht, sub_re, one_re]\n\n"}
{"name":"hasSum_mellin_pi_mul","module":"Mathlib.NumberTheory.LSeries.MellinEqDirichlet","initialProofState":"ι : Type u_1\ninst✝ : Countable ι\na : ι → Complex\nq : ι → Real\nF : Real → Complex\ns : Complex\nhq : ∀ (i : ι), Or (Eq (a i) 0) (LT.lt 0 (q i))\nhs : LT.lt 0 s.re\nhF : ∀ (t : Real), Membership.mem (Set.Ioi 0) t → HasSum (fun i => HMul.hMul (a i) ↑(Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (q i)) t))) (F t)\nh_sum : Summable fun i => HDiv.hDiv (Norm.norm (a i)) (HPow.hPow (q i) s.re)\n⊢ HasSum (fun i => HDiv.hDiv (HMul.hMul (HMul.hMul (HPow.hPow (↑Real.pi) (Neg.neg s)) (Complex.Gamma s)) (a i)) (HPow.hPow (↑(q i)) s)) (mellin F s)","decl":"/-- Shortcut version for the commonly arising special case when `p i = π * q i` for some other\nsequence `q`. -/\nlemma hasSum_mellin_pi_mul {a : ι → ℂ} {q : ι → ℝ} {F : ℝ → ℂ} {s : ℂ}\n    (hq : ∀ i, a i = 0 ∨ 0 < q i) (hs : 0 < s.re)\n    (hF : ∀ t ∈ Ioi 0, HasSum (fun i ↦ a i * rexp (-π * q i * t)) (F t))\n    (h_sum : Summable fun i ↦ ‖a i‖ / (q i) ^ s.re) :\n    HasSum (fun i ↦ π ^ (-s) * Gamma s * a i / q i ^ s) (mellin F s) := by\n  have hp i : a i = 0 ∨ 0 < π * q i := by rcases hq i with h | h <;> simp [h, pi_pos]\n  convert hasSum_mellin hp hs (by simpa using hF) ?_ using 2 with i\n  · have : a i / ↑(π * q i) ^ s = π ^ (-s) * a i / q i ^ s := by\n      rcases hq i with h | h\n      · simp [h]\n      · rw [ofReal_mul, mul_cpow_ofReal_nonneg pi_pos.le h.le, ← div_div, cpow_neg,\n          ← div_eq_inv_mul]\n    simp_rw [mul_div_assoc, this]\n    ring_nf\n  · have (i) : ‖a i‖ / ↑(π * q i) ^ s.re = π ^ (-s.re) * ‖a i‖ / q i ^ s.re := by\n      rcases hq i with h | h\n      · simp [h]\n      · rw [mul_rpow pi_pos.le h.le, ← div_div, rpow_neg pi_pos.le, ← div_eq_inv_mul]\n    simpa only [this, mul_div_assoc] using h_sum.mul_left _\n\n"}
{"name":"hasSum_mellin_pi_mul₀","module":"Mathlib.NumberTheory.LSeries.MellinEqDirichlet","initialProofState":"ι : Type u_1\ninst✝ : Countable ι\na : ι → Complex\np : ι → Real\nF : Real → Complex\ns : Complex\nhp : ∀ (i : ι), LE.le 0 (p i)\nhs : LT.lt 0 s.re\nhF : ∀ (t : Real), Membership.mem (Set.Ioi 0) t → HasSum (fun i => ite (Eq (p i) 0) 0 (HMul.hMul (a i) ↑(Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (p i)) t)))) (F t)\nh_sum : Summable fun i => HDiv.hDiv (Norm.norm (a i)) (HPow.hPow (p i) s.re)\n⊢ HasSum (fun i => HDiv.hDiv (HMul.hMul (HMul.hMul (HPow.hPow (↑Real.pi) (Neg.neg s)) (Complex.Gamma s)) (a i)) (HPow.hPow (↑(p i)) s)) (mellin F s)","decl":"/-- Version allowing some constant terms (which are omitted from the sums). -/\nlemma hasSum_mellin_pi_mul₀ {a : ι → ℂ} {p : ι → ℝ} {F : ℝ → ℂ} {s : ℂ}\n    (hp : ∀ i, 0 ≤ p i) (hs : 0 < s.re)\n    (hF : ∀ t ∈ Ioi 0, HasSum (fun i ↦ if p i = 0 then 0 else a i * rexp (-π * p i * t)) (F t))\n    (h_sum : Summable fun i ↦ ‖a i‖ / (p i) ^ s.re) :\n    HasSum (fun i ↦ π ^ (-s) * Gamma s * a i / p i ^ s) (mellin F s) := by\n  have hs' : s ≠ 0 := fun h ↦ lt_irrefl _ (zero_re ▸ h ▸ hs)\n  let a' i := if p i = 0 then 0 else a i\n  have hp' i : a' i = 0 ∨ 0 < p i := by\n    simp only [a']\n    split_ifs with h <;> try tauto\n    exact Or.inr (lt_of_le_of_ne (hp i) (Ne.symm h))\n  have (i t) : (if p i = 0 then 0 else a i * rexp (-π * p i * t)) =\n      a' i * rexp (-π * p i * t) := by\n    simp [a']\n  simp_rw [this] at hF\n  convert hasSum_mellin_pi_mul hp' hs hF ?_ using 2 with i\n  · rcases eq_or_ne (p i) 0 with h | h <;>\n    simp [a', h, if_false, ofReal_zero, zero_cpow hs', div_zero]\n  · refine h_sum.of_norm_bounded _ (fun i ↦ ?_)\n    simp only [a']\n    split_ifs\n    · simp only [norm_zero, zero_div]\n      positivity\n    · have := hp i\n      rw [norm_of_nonneg (by positivity)]\n\n"}
{"name":"hasSum_mellin_pi_mul_sq","module":"Mathlib.NumberTheory.LSeries.MellinEqDirichlet","initialProofState":"ι : Type u_1\ninst✝ : Countable ι\na : ι → Complex\nr : ι → Real\nF : Real → Complex\ns : Complex\nhs : LT.lt 0 s.re\nhF : ∀ (t : Real), Membership.mem (Set.Ioi 0) t → HasSum (fun i => ite (Eq (r i) 0) 0 (HMul.hMul (a i) ↑(Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (r i) 2)) t)))) (F t)\nh_sum : Summable fun i => HDiv.hDiv (Norm.norm (a i)) (HPow.hPow (abs (r i)) s.re)\n⊢ HasSum (fun i => HDiv.hDiv (HMul.hMul s.Gammaℝ (a i)) (HPow.hPow (↑(abs (r i))) s)) (mellin F (HDiv.hDiv s 2))","decl":"/-- Tailored version for even Jacobi theta functions. -/\nlemma hasSum_mellin_pi_mul_sq {a : ι → ℂ} {r : ι → ℝ} {F : ℝ → ℂ} {s : ℂ} (hs : 0 < s.re)\n    (hF : ∀ t ∈ Ioi 0, HasSum (fun i ↦ if r i = 0 then 0 else a i * rexp (-π * r i ^ 2 * t)) (F t))\n    (h_sum : Summable fun i ↦ ‖a i‖ / |r i| ^ s.re) :\n    HasSum (fun i ↦ Gammaℝ s * a i / |r i| ^ s) (mellin F (s / 2)) := by\n  have hs' : 0 < (s / 2).re := by rw [div_ofNat_re]; positivity\n  simp_rw [← sq_eq_zero_iff (a := r _)] at hF\n  convert hasSum_mellin_pi_mul₀ (fun i ↦ sq_nonneg (r i)) hs' hF ?_ using 3 with i\n  · rw [← neg_div, Gammaℝ_def]\n  · rw [← _root_.sq_abs, ofReal_pow, ← cpow_nat_mul']\n    · ring_nf\n    all_goals rw [arg_ofReal_of_nonneg (abs_nonneg _)]; linarith [pi_pos]\n  · convert h_sum using 3 with i\n    rw [← _root_.sq_abs, ← rpow_natCast_mul (abs_nonneg _), div_ofNat_re, Nat.cast_ofNat,\n      mul_div_cancel₀ _ two_pos.ne']\n\n"}
{"name":"hasSum_mellin_pi_mul_sq'","module":"Mathlib.NumberTheory.LSeries.MellinEqDirichlet","initialProofState":"ι : Type u_1\ninst✝ : Countable ι\na : ι → Complex\nr : ι → Real\nF : Real → Complex\ns : Complex\nhs : LT.lt 0 s.re\nhF : ∀ (t : Real), Membership.mem (Set.Ioi 0) t → HasSum (fun i => HMul.hMul (HMul.hMul (a i) ↑(r i)) ↑(Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (r i) 2)) t))) (F t)\nh_sum : Summable fun i => HDiv.hDiv (Norm.norm (a i)) (HPow.hPow (abs (r i)) s.re)\n⊢ HasSum (fun i => HDiv.hDiv (HMul.hMul (HMul.hMul (HAdd.hAdd s 1).Gammaℝ (a i)) ↑(SignType.sign (r i))) (HPow.hPow (↑(abs (r i))) s)) (mellin F (HDiv.hDiv (HAdd.hAdd s 1) 2))","decl":"/-- Tailored version for odd Jacobi theta functions. -/\nlemma hasSum_mellin_pi_mul_sq' {a : ι → ℂ} {r : ι → ℝ} {F : ℝ → ℂ} {s : ℂ} (hs : 0 < s.re)\n    (hF : ∀ t ∈ Ioi 0, HasSum (fun i ↦ a i * r i * rexp (-π * r i ^ 2 * t)) (F t))\n    (h_sum : Summable fun i ↦ ‖a i‖ / |r i| ^ s.re) :\n    HasSum (fun i ↦ Gammaℝ (s + 1) * a i * SignType.sign (r i) / |r i| ^ s)\n    (mellin F ((s + 1) / 2)) := by\n  have hs₁ : s ≠ 0 := fun h ↦ lt_irrefl _ (zero_re ▸ h ▸ hs)\n  have hs₂ : 0 < (s + 1).re := by rw [add_re, one_re]; positivity\n  have hs₃ : s + 1 ≠ 0 := fun h ↦ lt_irrefl _ (zero_re ▸ h ▸ hs₂)\n  have (i t) : (a i * r i * rexp (-π * r i ^ 2 * t)) =\n      if r i = 0 then 0 else (a i * r i * rexp (-π * r i ^ 2 * t)) := by\n    split_ifs with h <;> simp [h]\n  conv at hF => enter [t, ht, 1, i]; rw [this]\n  convert hasSum_mellin_pi_mul_sq hs₂ hF ?_ using 2 with i\n  · rcases eq_or_ne (r i) 0 with h | h\n    · rw [h, abs_zero, ofReal_zero, zero_cpow hs₁, zero_cpow hs₃, div_zero, div_zero]\n    · rw [cpow_add _ _ (ofReal_ne_zero.mpr <| abs_ne_zero.mpr h), cpow_one]\n      conv_rhs => enter [1]; rw [← sign_mul_abs (r i), ofReal_mul, ← ofRealHom_eq_coe,\n        SignType.map_cast]\n      field_simp [h]\n      ring_nf\n  · convert h_sum using 2 with i\n    rcases eq_or_ne (r i) 0 with h | h\n    · rw [h, abs_zero, ofReal_zero, zero_rpow hs₂.ne', zero_rpow hs.ne', div_zero, div_zero]\n    · rw [add_re, one_re, rpow_add (abs_pos.mpr h), rpow_one, norm_mul, norm_real,\n        Real.norm_eq_abs, ← div_div, div_right_comm, mul_div_cancel_right₀ _ (abs_ne_zero.mpr h)]\n"}
