{"name":"Action.instMonoidalCategory_tensorObj_V","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX Y : Action V G\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).V (CategoryTheory.MonoidalCategoryStruct.tensorObj X.V Y.V)","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_associator_inv_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX Y Z : Action V G\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.hom (CategoryTheory.MonoidalCategoryStruct.associator X.V Y.V Z.V).inv","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_whiskerLeft_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX x‚úù¬π x‚úù : Action V G\nf : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.V f.hom)","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_tensorHom_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX‚ÇÅ‚úù Y‚ÇÅ‚úù X‚ÇÇ‚úù Y‚ÇÇ‚úù : Action V G\nf : Quiver.Hom X‚ÇÅ‚úù Y‚ÇÅ‚úù\ng : Quiver.Hom X‚ÇÇ‚úù Y‚ÇÇ‚úù\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom g.hom)","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_whiskerRight_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX‚ÇÅ‚úù X‚ÇÇ‚úù : Action V G\nf : Quiver.Hom X‚ÇÅ‚úù X‚ÇÇ‚úù\nX : Action V G\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom X.V)","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_rightUnitor_hom_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX : Action V G\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.V).hom","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_rightUnitor_inv_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX : Action V G\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.V).inv","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_associator_hom_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX Y Z : Action V G\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.hom (CategoryTheory.MonoidalCategoryStruct.associator X.V Y.V Z.V).hom","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_tensorUnit_V","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.V CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_leftUnitor_hom_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX : Action V G\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.V).hom","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.instMonoidalCategory_leftUnitor_inv_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX : Action V G\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.V).inv","decl":"@[simps! tensorUnit_V tensorObj_V tensorHom_hom whiskerLeft_hom whiskerRight_hom\n  associator_hom_hom associator_inv_hom leftUnitor_hom_hom leftUnitor_inv_hom\n  rightUnitor_hom_hom rightUnitor_inv_hom]\ninstance instMonoidalCategory : MonoidalCategory (Action V G) :=\n  Monoidal.transport (Action.functorCategoryEquivalence _ _).symm\n\n/- Adding this solves `simpNF` linter report at `tensorUnit_œÅ` -/\n"}
{"name":"Action.tensorUnit_œÅ'","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\ng : ‚ÜëG\n‚ä¢ Eq ((MonCat.Hom.hom CategoryTheory.MonoidalCategoryStruct.tensorUnit.œÅ) g) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp]\ntheorem tensorUnit_œÅ' {g : G} :\n    @DFunLike.coe (G ‚Üí* MonCat.of (End (ùüô_ V))) _ _ _ (ùüô_ (Action V G)).œÅ.hom g = ùüô (ùüô_ V) := by\n  rfl\n\n"}
{"name":"Action.tensorUnit_œÅ","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\ng : ‚ÜëG\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom CategoryTheory.MonoidalCategoryStruct.tensorUnit.œÅ) g) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp]\ntheorem tensorUnit_œÅ {g : G} :\n    -- Have to hint `F` here, otherwise `simp` doesn't reduce `‚Üë(MonCat.of (End _))` to `End _`.\n    DFunLike.coe (F := _ ‚Üí* End _)\n      -- Have to hint `Y` here for `simpNF` reasons.\n      (ConcreteCategory.hom (Y := MonCat.of (End (ùüô_ V))) (ùüô_ (Action V G)).œÅ) g = ùüô (ùüô_ V) :=\n  rfl\n\n/- Adding this solves `simpNF` linter report at `tensor_œÅ` -/\n"}
{"name":"Action.tensor_œÅ'","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX Y : Action V G\ng : ‚ÜëG\n‚ä¢ Eq ((MonCat.Hom.hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).œÅ) g) (CategoryTheory.MonoidalCategoryStruct.tensorHom ((CategoryTheory.ConcreteCategory.hom X.œÅ) g) ((CategoryTheory.ConcreteCategory.hom Y.œÅ) g))","decl":"@[simp]\ntheorem tensor_œÅ' {X Y : Action V G} {g : G} :\n    @DFunLike.coe (G ‚Üí* MonCat.of (End (X.V ‚äó Y.V))) _ _ _ (X ‚äó Y).œÅ.hom g = X.œÅ g ‚äó Y.œÅ g :=\n  rfl\n\n"}
{"name":"Action.tensor_œÅ","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX Y : Action V G\ng : ‚ÜëG\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).œÅ) g) (CategoryTheory.MonoidalCategoryStruct.tensorHom ((CategoryTheory.ConcreteCategory.hom X.œÅ) g) ((CategoryTheory.ConcreteCategory.hom Y.œÅ) g))","decl":"@[simp]\ntheorem tensor_œÅ {X Y : Action V G} {g : G} :\n    -- Have to hint `F` here, otherwise `simp` doesn't reduce `‚Üë(MonCat.of (End _))` to `End _`.\n    DFunLike.coe (F := _ ‚Üí* End _)\n      -- Have to hint `Y` here for `simpNF` reasons.\n      (ConcreteCategory.hom (Y := MonCat.of (End (tensorObj X.V Y.V))) (X ‚äó Y).œÅ) g =\n    X.œÅ g ‚äó Y.œÅ g :=\n  rfl\n\n"}
{"name":"Action.forget_Œµ","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ (Action.forget V G)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] lemma forget_Œµ : Œµ (Action.forget V G) = ùüô _ := rfl\n"}
{"name":"Action.forget_Œ∑","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ (Action.forget V G)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] lemma forget_Œ∑ : Œµ (Action.forget V G) = ùüô _ := rfl\n\n"}
{"name":"Action.forget_Œº","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX Y : Action V G\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œº (Action.forget V G) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((Action.forget V G).obj X) ((Action.forget V G).obj Y)))","decl":"@[simp] lemma forget_Œº (X Y : Action V G) : Œº (Action.forget V G) X Y = ùüô _ := rfl\n"}
{"name":"Action.forget_Œ¥","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nX Y : Action V G\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ¥ (Action.forget V G) X Y) (CategoryTheory.CategoryStruct.id ((Action.forget V G).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"@[simp] lemma forget_Œ¥ (X Y : Action V G) : Œ¥ (Action.forget V G) X Y = ùüô _ := rfl\n\n"}
{"name":"Action.instMonoidalPreadditive","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬≤ : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\ninst‚úù : CategoryTheory.Preadditive V\n‚ä¢ CategoryTheory.MonoidalPreadditive (Action V G)","decl":"instance : MonoidalPreadditive (Action V G) where\n\n"}
{"name":"Action.instMonoidalLinear","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù‚Å¥ : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory V\ninst‚úù¬≤ : CategoryTheory.Preadditive V\nR : Type u_1\ninst‚úù¬π : Semiring R\ninst‚úù : CategoryTheory.Linear R V\n‚ä¢ CategoryTheory.MonoidalLinear R (Action V G)","decl":"instance : MonoidalLinear R (Action V G) where\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_Œµ","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ Action.FunctorCategoryEquivalence.functor) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp]\nlemma FunctorCategoryEquivalence.functor_Œµ :\n    Œµ (FunctorCategoryEquivalence.functor (V := V) (G := G)) = ùüô _ := rfl\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_Œ∑","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ∑ Action.FunctorCategoryEquivalence.functor) (CategoryTheory.CategoryStruct.id (Action.FunctorCategoryEquivalence.functor.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp]\nlemma FunctorCategoryEquivalence.functor_Œ∑ :\n    Œ∑ (FunctorCategoryEquivalence.functor (V := V) (G := G)) = ùüô _ := rfl\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_Œº","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nA B : Action V G\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œº Action.FunctorCategoryEquivalence.functor A B) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (Action.FunctorCategoryEquivalence.functor.obj A) (Action.FunctorCategoryEquivalence.functor.obj B)))","decl":"@[simp]\nlemma FunctorCategoryEquivalence.functor_Œº (A B : Action V G) :\n    Œº FunctorCategoryEquivalence.functor A B = ùüô _ := rfl\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_Œ¥","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.MonoidalCategory V\nA B : Action V G\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ¥ Action.FunctorCategoryEquivalence.functor A B) (CategoryTheory.CategoryStruct.id (Action.FunctorCategoryEquivalence.functor.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj A B)))","decl":"@[simp]\nlemma FunctorCategoryEquivalence.functor_Œ¥ (A B : Action V G) :\n    Œ¥ FunctorCategoryEquivalence.functor A B = ùüô _ := rfl\n\n\n"}
{"name":"Action.rightDual_v","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬≤ : CategoryTheory.LargeCategory V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nH : Grp\nX : Action V ((CategoryTheory.forget‚ÇÇ Grp MonCat).obj H)\ninst‚úù : CategoryTheory.RightRigidCategory V\n‚ä¢ Eq (CategoryTheory.HasRightDual.rightDual X).V (CategoryTheory.HasRightDual.rightDual X.V)","decl":"@[simp]\ntheorem rightDual_v [RightRigidCategory V] : X·òÅ.V = X.V·òÅ :=\n  rfl\n\n"}
{"name":"Action.leftDual_v","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬≤ : CategoryTheory.LargeCategory V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nH : Grp\nX : Action V ((CategoryTheory.forget‚ÇÇ Grp MonCat).obj H)\ninst‚úù : CategoryTheory.LeftRigidCategory V\n‚ä¢ Eq (CategoryTheory.HasLeftDual.leftDual X).V (CategoryTheory.HasLeftDual.leftDual X.V)","decl":"@[simp]\ntheorem leftDual_v [LeftRigidCategory V] : (·òÅX).V = ·òÅX.V :=\n  rfl\n\n"}
{"name":"Action.rightDual_œÅ","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬≤ : CategoryTheory.LargeCategory V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nH : Grp\nX : Action V ((CategoryTheory.forget‚ÇÇ Grp MonCat).obj H)\ninst‚úù : CategoryTheory.RightRigidCategory V\nh : ‚ÜëH\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.HasRightDual.rightDual X).œÅ) h) (CategoryTheory.rightAdjointMate ((CategoryTheory.ConcreteCategory.hom X.œÅ) (Inv.inv h)))","decl":"theorem rightDual_œÅ [RightRigidCategory V] (h : H) : X·òÅ.œÅ h = (X.œÅ (h‚Åª¬π : H))·òÅ := by\n  rw [‚Üê SingleObj.inv_as_inv]; rfl\n\n"}
{"name":"Action.leftDual_œÅ","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù¬≤ : CategoryTheory.LargeCategory V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nH : Grp\nX : Action V ((CategoryTheory.forget‚ÇÇ Grp MonCat).obj H)\ninst‚úù : CategoryTheory.LeftRigidCategory V\nh : ‚ÜëH\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.HasLeftDual.leftDual X).œÅ) h) (CategoryTheory.leftAdjointMate ((CategoryTheory.ConcreteCategory.hom X.œÅ) (Inv.inv h)))","decl":"theorem leftDual_œÅ [LeftRigidCategory V] (h : H) : (·òÅX).œÅ h = ·òÅX.œÅ (h‚Åª¬π : H) := by\n  rw [‚Üê SingleObj.inv_as_inv]; rfl\n\n"}
{"name":"Action.leftRegularTensorIso_inv_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"G : Type u\ninst‚úù : Group G\nX : Action (Type u) (MonCat.of G)\ng : (CategoryTheory.MonoidalCategoryStruct.tensorObj (Action.leftRegular G) { V := X.V, œÅ := 1 }).V\n‚ä¢ Eq ((Action.leftRegularTensorIso G X).inv.hom g) { fst := g.1, snd := (CategoryTheory.ConcreteCategory.hom X.œÅ) g.1 g.2 }","decl":"/-- Given `X : Action (Type u) (MonCat.of G)` for `G` a group, then `G √ó X` (with `G` acting as left\nmultiplication on the first factor and by `X.œÅ` on the second) is isomorphic as a `G`-set to\n`G √ó X` (with `G` acting as left multiplication on the first factor and trivially on the second).\nThe isomorphism is given by `(g, x) ‚Ü¶ (g, g‚Åª¬π ‚Ä¢ x)`. -/\n@[simps]\nnoncomputable def leftRegularTensorIso (G : Type u) [Group G] (X : Action (Type u) (MonCat.of G)) :\n    leftRegular G ‚äó X ‚âÖ leftRegular G ‚äó Action.mk X.V 1 where\n  hom :=\n    { hom := fun g => ‚ü®g.1, (X.œÅ (g.1‚Åª¬π : G) g.2 : X.V)‚ü©\n      comm := fun (g : G) => by\n        funext ‚ü®(x‚ÇÅ : G), (x‚ÇÇ : X.V)‚ü©\n        refine Prod.ext rfl ?_\n        change (X.œÅ ((g * x‚ÇÅ)‚Åª¬π : G) * X.œÅ g) x‚ÇÇ = X.œÅ _ _\n        rw [mul_inv_rev, ‚Üê X.œÅ.hom.map_mul, inv_mul_cancel_right] }\n  inv :=\n    { hom := fun g => ‚ü®g.1, X.œÅ g.1 g.2‚ü©\n      comm := fun (g : G) => by\n        funext ‚ü®(x‚ÇÅ : G), (x‚ÇÇ : X.V)‚ü©\n        refine Prod.ext rfl ?_\n        dsimp [leftRegular] -- Unfold `leftRegular` so `rw` can see through `(leftRegular V).V = V`\n        rw [tensor_œÅ, tensor_œÅ]\n        dsimp\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n        erw [leftRegular_œÅ_hom_apply]\n        rw [map_mul]\n        rfl }\n  hom_inv_id := by\n    apply Hom.ext\n    funext x\n    refine Prod.ext rfl ?_\n    change (X.œÅ x.1 * X.œÅ (x.1‚Åª¬π : G)) x.2 = x.2\n    rw [‚Üê X.œÅ.hom.map_mul, mul_inv_cancel, X.œÅ.hom.map_one, MonCat.one_of, End.one_def,\n      types_id_apply]\n  inv_hom_id := by\n    apply Hom.ext\n    funext x\n    refine Prod.ext rfl ?_\n    change (X.œÅ (x.1‚Åª¬π : G) * X.œÅ x.1) x.2 = x.2\n    rw [‚Üê X.œÅ.hom.map_mul, inv_mul_cancel, X.œÅ.hom.map_one, MonCat.one_of, End.one_def,\n      types_id_apply]\n\n"}
{"name":"Action.leftRegularTensorIso_hom_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"G : Type u\ninst‚úù : Group G\nX : Action (Type u) (MonCat.of G)\ng : (CategoryTheory.MonoidalCategoryStruct.tensorObj (Action.leftRegular G) X).V\n‚ä¢ Eq ((Action.leftRegularTensorIso G X).hom.hom g) { fst := g.1, snd := (CategoryTheory.ConcreteCategory.hom X.œÅ) (Inv.inv g.1) g.2 }","decl":"/-- Given `X : Action (Type u) (MonCat.of G)` for `G` a group, then `G √ó X` (with `G` acting as left\nmultiplication on the first factor and by `X.œÅ` on the second) is isomorphic as a `G`-set to\n`G √ó X` (with `G` acting as left multiplication on the first factor and trivially on the second).\nThe isomorphism is given by `(g, x) ‚Ü¶ (g, g‚Åª¬π ‚Ä¢ x)`. -/\n@[simps]\nnoncomputable def leftRegularTensorIso (G : Type u) [Group G] (X : Action (Type u) (MonCat.of G)) :\n    leftRegular G ‚äó X ‚âÖ leftRegular G ‚äó Action.mk X.V 1 where\n  hom :=\n    { hom := fun g => ‚ü®g.1, (X.œÅ (g.1‚Åª¬π : G) g.2 : X.V)‚ü©\n      comm := fun (g : G) => by\n        funext ‚ü®(x‚ÇÅ : G), (x‚ÇÇ : X.V)‚ü©\n        refine Prod.ext rfl ?_\n        change (X.œÅ ((g * x‚ÇÅ)‚Åª¬π : G) * X.œÅ g) x‚ÇÇ = X.œÅ _ _\n        rw [mul_inv_rev, ‚Üê X.œÅ.hom.map_mul, inv_mul_cancel_right] }\n  inv :=\n    { hom := fun g => ‚ü®g.1, X.œÅ g.1 g.2‚ü©\n      comm := fun (g : G) => by\n        funext ‚ü®(x‚ÇÅ : G), (x‚ÇÇ : X.V)‚ü©\n        refine Prod.ext rfl ?_\n        dsimp [leftRegular] -- Unfold `leftRegular` so `rw` can see through `(leftRegular V).V = V`\n        rw [tensor_œÅ, tensor_œÅ]\n        dsimp\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n        erw [leftRegular_œÅ_hom_apply]\n        rw [map_mul]\n        rfl }\n  hom_inv_id := by\n    apply Hom.ext\n    funext x\n    refine Prod.ext rfl ?_\n    change (X.œÅ x.1 * X.œÅ (x.1‚Åª¬π : G)) x.2 = x.2\n    rw [‚Üê X.œÅ.hom.map_mul, mul_inv_cancel, X.œÅ.hom.map_one, MonCat.one_of, End.one_def,\n      types_id_apply]\n  inv_hom_id := by\n    apply Hom.ext\n    funext x\n    refine Prod.ext rfl ?_\n    change (X.œÅ (x.1‚Åª¬π : G) * X.œÅ x.1) x.2 = x.2\n    rw [‚Üê X.œÅ.hom.map_mul, inv_mul_cancel, X.œÅ.hom.map_one, MonCat.one_of, End.one_def,\n      types_id_apply]\n\n"}
{"name":"Action.diagonalSucc_inv_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"G : Type u\ninst‚úù : Monoid G\nn : Nat\na‚úù : (CategoryTheory.MonoidalCategoryStruct.tensorObj (Action.leftRegular G) (Action.diagonal G n)).V\n‚ä¢ Eq ((Action.diagonalSucc G n).inv.hom a‚úù) ((Fin.consEquiv fun a => G) a‚úù)","decl":"/-- The natural isomorphism of `G`-sets `G‚Åø‚Å∫¬π ‚âÖ G √ó G‚Åø`, where `G` acts by left multiplication on\neach factor. -/\n@[simps!]\nnoncomputable def diagonalSucc (G : Type u) [Monoid G] (n : ‚Ñï) :\n    diagonal G (n + 1) ‚âÖ leftRegular G ‚äó diagonal G n :=\n  mkIso (Fin.consEquiv _).symm.toIso fun _ => rfl\n\n"}
{"name":"Action.diagonalSucc_hom_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"G : Type u\ninst‚úù : Monoid G\nn : Nat\na‚úù : (Action.diagonal G (HAdd.hAdd n 1)).V\n‚ä¢ Eq ((Action.diagonalSucc G n).hom.hom a‚úù) ((Fin.consEquiv fun a => G).symm a‚úù)","decl":"/-- The natural isomorphism of `G`-sets `G‚Åø‚Å∫¬π ‚âÖ G √ó G‚Åø`, where `G` acts by left multiplication on\neach factor. -/\n@[simps!]\nnoncomputable def diagonalSucc (G : Type u) [Monoid G] (n : ‚Ñï) :\n    diagonal G (n + 1) ‚âÖ leftRegular G ‚äó diagonal G n :=\n  mkIso (Fin.consEquiv _).symm.toIso fun _ => rfl\n\n"}
{"name":"CategoryTheory.Functor.mapAction_Œµ_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù‚Å¥ : CategoryTheory.LargeCategory V\nG : MonCat\nW : Type (u + 1)\ninst‚úù¬≥ : CategoryTheory.LargeCategory W\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\nF : CategoryTheory.Functor V W\ninst‚úù : F.LaxMonoidal\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ (F.mapAction G)).hom (CategoryTheory.Functor.LaxMonoidal.Œµ F)","decl":"@[simp]\nlemma mapAction_Œµ_hom [F.LaxMonoidal] : (Œµ (F.mapAction G)).hom = Œµ F := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapAction_Œº_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù‚Å¥ : CategoryTheory.LargeCategory V\nG : MonCat\nW : Type (u + 1)\ninst‚úù¬≥ : CategoryTheory.LargeCategory W\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\nF : CategoryTheory.Functor V W\ninst‚úù : F.LaxMonoidal\nX Y : Action V G\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œº (F.mapAction G) X Y).hom (CategoryTheory.Functor.LaxMonoidal.Œº F X.V Y.V)","decl":"@[simp]\nlemma mapAction_Œº_hom [F.LaxMonoidal] (X Y : Action V G) :\n    (Œº (F.mapAction G) X Y).hom = Œº F X.V Y.V := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapAction_Œ∑_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù‚Å¥ : CategoryTheory.LargeCategory V\nG : MonCat\nW : Type (u + 1)\ninst‚úù¬≥ : CategoryTheory.LargeCategory W\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\nF : CategoryTheory.Functor V W\ninst‚úù : F.OplaxMonoidal\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ∑ (F.mapAction G)).hom (CategoryTheory.Functor.OplaxMonoidal.Œ∑ F)","decl":"@[simp]\nlemma mapAction_Œ∑_hom [F.OplaxMonoidal] : (Œ∑ (F.mapAction G)).hom = Œ∑ F := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapAction_Œ¥_hom","module":"Mathlib.CategoryTheory.Action.Monoidal","initialProofState":"V : Type (u + 1)\ninst‚úù‚Å¥ : CategoryTheory.LargeCategory V\nG : MonCat\nW : Type (u + 1)\ninst‚úù¬≥ : CategoryTheory.LargeCategory W\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\nF : CategoryTheory.Functor V W\ninst‚úù : F.OplaxMonoidal\nX Y : Action V G\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ¥ (F.mapAction G) X Y).hom (CategoryTheory.Functor.OplaxMonoidal.Œ¥ F X.V Y.V)","decl":"@[simp]\nlemma mapAction_Œ¥_hom [F.OplaxMonoidal] (X Y : Action V G) :\n    (Œ¥ (F.mapAction G) X Y).hom = Œ¥ F X.V Y.V := rfl\n\n"}
