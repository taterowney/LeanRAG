{"name":"Path.mk.sizeOf_spec","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nx y : X\ninst✝ : SizeOf X\ntoContinuousMap : ContinuousMap (↑unitInterval) X\nsource' : Eq (toContinuousMap.toFun 0) x\ntarget' : Eq (toContinuousMap.toFun 1) y\n⊢ Eq (SizeOf.sizeOf { toContinuousMap := toContinuousMap, source' := source', target' := target' }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toContinuousMap)) (SizeOf.sizeOf source')) (SizeOf.sizeOf target'))","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.target'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nself : Path x y\n⊢ Eq (self.toFun 1) y","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.source'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nself : Path x y\n⊢ Eq (self.toFun 0) x","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.mk.injEq","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ntoContinuousMap✝ : ContinuousMap (↑unitInterval) X\nsource'✝ : Eq (toContinuousMap✝.toFun 0) x\ntarget'✝ : Eq (toContinuousMap✝.toFun 1) y\ntoContinuousMap : ContinuousMap (↑unitInterval) X\nsource' : Eq (toContinuousMap.toFun 0) x\ntarget' : Eq (toContinuousMap.toFun 1) y\n⊢ Eq (Eq { toContinuousMap := toContinuousMap✝, source' := source'✝, target' := target'✝ } { toContinuousMap := toContinuousMap, source' := source', target' := target' }) (Eq toContinuousMap✝ toContinuousMap)","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.mk.inj","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\ntoContinuousMap✝ : ContinuousMap (↑unitInterval) X\nsource'✝ : Eq (toContinuousMap✝.toFun 0) x\ntarget'✝ : Eq (toContinuousMap✝.toFun 1) y\ntoContinuousMap : ContinuousMap (↑unitInterval) X\nsource' : Eq (toContinuousMap.toFun 0) x\ntarget' : Eq (toContinuousMap.toFun 1) y\nx✝ : Eq { toContinuousMap := toContinuousMap✝, source' := source'✝, target' := target'✝ } { toContinuousMap := toContinuousMap, source' := source', target' := target' }\n⊢ Eq toContinuousMap✝ toContinuousMap","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.continuousMapClass","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ ContinuousMapClass (Path x y) (↑unitInterval) X","decl":"instance Path.continuousMapClass : ContinuousMapClass (Path x y) I X where\n  map_continuous γ := show Continuous γ.toContinuousMap by fun_prop\n\n"}
{"name":"Path.ext_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ₁ γ₂ : Path x y\n⊢ Iff (Eq γ₁ γ₂) (Eq ⇑γ₁ ⇑γ₂)","decl":"@[ext]\nprotected theorem Path.ext : ∀ {γ₁ γ₂ : Path x y}, (γ₁ : I → X) = γ₂ → γ₁ = γ₂ := by\n  rintro ⟨⟨x, h11⟩, h12, h13⟩ ⟨⟨x, h21⟩, h22, h23⟩ rfl\n  rfl\n\n"}
{"name":"Path.ext","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ₁ γ₂ : Path x y\na✝ : Eq ⇑γ₁ ⇑γ₂\n⊢ Eq γ₁ γ₂","decl":"@[ext]\nprotected theorem Path.ext : ∀ {γ₁ γ₂ : Path x y}, (γ₁ : I → X) = γ₂ → γ₁ = γ₂ := by\n  rintro ⟨⟨x, h11⟩, h12, h13⟩ ⟨⟨x, h21⟩, h22, h23⟩ rfl\n  rfl\n\n"}
{"name":"Path.coe_mk_mk","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nf : ↑unitInterval → X\nh₁ : Continuous f\nh₂ : Eq (f 0) x\nh₃ : Eq (f 1) y\n⊢ Eq (⇑{ toFun := f, continuous_toFun := h₁, source' := h₂, target' := h₃ }) f","decl":"@[simp]\ntheorem coe_mk_mk (f : I → X) (h₁) (h₂ : f 0 = x) (h₃ : f 1 = y) :\n    ⇑(mk ⟨f, h₁⟩ h₂ h₃ : Path x y) = f :=\n  rfl\n-- Porting note: the name `Path.coe_mk` better refers to a new lemma below\n\n"}
{"name":"Path.continuous","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Continuous ⇑γ","decl":"@[continuity]\nprotected theorem continuous : Continuous γ :=\n  γ.continuous_toFun\n\n"}
{"name":"Path.source","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (γ 0) x","decl":"@[simp]\nprotected theorem source : γ 0 = x :=\n  γ.source'\n\n"}
{"name":"Path.target","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (γ 1) y","decl":"@[simp]\nprotected theorem target : γ 1 = y :=\n  γ.target'\n\n"}
{"name":"Path.coe_toContinuousMap","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq ⇑γ.toContinuousMap ⇑γ","decl":"@[simp]\ntheorem coe_toContinuousMap : ⇑γ.toContinuousMap = γ :=\n  rfl\n\n-- Porting note: this is needed because of the `Path.continuousMapClass` instance\n"}
{"name":"Path.coe_mk","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq ⇑↑γ ⇑γ","decl":"@[simp]\ntheorem coe_mk : ⇑(γ : C(I, X)) = γ :=\n  rfl\n\n"}
{"name":"Path.refl_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n_t : ↑unitInterval\n⊢ Eq ((Path.refl x) _t) x","decl":"/-- The constant path from a point to itself -/\n@[refl, simps]\ndef refl (x : X) : Path x x where\n  toFun _t := x\n  continuous_toFun := continuous_const\n  source' := rfl\n  target' := rfl\n\n"}
{"name":"Path.refl_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na : X\n⊢ Eq (Set.range ⇑(Path.refl a)) (Singleton.singleton a)","decl":"@[simp]\ntheorem refl_range {a : X} : range (Path.refl a) = {a} := by simp [Path.refl, CoeFun.coe]\n\n"}
{"name":"Path.symm_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\na✝ : ↑unitInterval\n⊢ Eq (γ.symm a✝) (Function.comp (⇑γ) unitInterval.symm a✝)","decl":"/-- The reverse of a path from `x` to `y`, as a path from `y` to `x` -/\n@[symm, simps]\ndef symm (γ : Path x y) : Path y x where\n  toFun := γ ∘ σ\n  continuous_toFun := by continuity\n  source' := by simpa [-Path.target] using γ.target\n  target' := by simpa [-Path.source] using γ.source\n\n"}
{"name":"Path.symm_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq γ.symm.symm γ","decl":"@[simp]\ntheorem symm_symm (γ : Path x y) : γ.symm.symm = γ := by\n  ext t\n  show γ (σ (σ t)) = γ t\n  rw [unitInterval.symm_symm]\n\n"}
{"name":"Path.symm_bijective","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Function.Bijective Path.symm","decl":"theorem symm_bijective : Function.Bijective (Path.symm : Path x y → Path y x) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"Path.refl_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na : X\n⊢ Eq (Path.refl a).symm (Path.refl a)","decl":"@[simp]\ntheorem refl_symm {a : X} : (Path.refl a).symm = Path.refl a := by\n  ext\n  rfl\n\n"}
{"name":"Path.symm_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\n⊢ Eq (Set.range ⇑γ.symm) (Set.range ⇑γ)","decl":"@[simp]\ntheorem symm_range {a b : X} (γ : Path a b) : range γ.symm = range γ := by\n  ext x\n  simp only [mem_range, Path.symm, DFunLike.coe, unitInterval.symm, SetCoe.exists, comp_apply,\n    Subtype.coe_mk]\n  constructor <;> rintro ⟨y, hy, hxy⟩ <;> refine ⟨1 - y, mem_iff_one_sub_mem.mp hy, ?_⟩ <;>\n    convert hxy\n  simp\n\n"}
{"name":"Path.instContinuousEvalElemRealUnitInterval","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ ContinuousEval (Path x y) (↑unitInterval) X","decl":"instance : ContinuousEval (Path x y) I X := .of_continuous_forget continuous_induced_dom\n\n"}
{"name":"Path.continuous_eval","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"F : Type u_1\nX : outParam (Type u_2)\nY : outParam (Type u_3)\ninst✝³ : FunLike F X Y\ninst✝² : TopologicalSpace F\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nself : ContinuousEval F X Y\n⊢ Continuous fun fx => fx.1 fx.2","decl":"@[deprecated (since := \"2024-10-04\")] protected alias continuous_eval := continuous_eval\n\n"}
{"name":"Continuous.path_eval","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nx y : X\nY : Type u_4\ninst✝ : TopologicalSpace Y\nf : Y → Path x y\ng : Y → ↑unitInterval\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun y_1 => (f y_1) (g y_1)","decl":"@[deprecated Continuous.eval (since := \"2024-10-04\")]\ntheorem _root_.Continuous.path_eval {Y} [TopologicalSpace Y] {f : Y → Path x y} {g : Y → I}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun y => f y (g y) := by\n  continuity\n\n"}
{"name":"Path.continuous_uncurry_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nx y : X\nY : Type u_4\ninst✝ : TopologicalSpace Y\ng : Y → Path x y\n⊢ Iff (Continuous (Function.HasUncurry.uncurry g)) (Continuous g)","decl":"theorem continuous_uncurry_iff {Y} [TopologicalSpace Y] {g : Y → Path x y} :\n    Continuous ↿g ↔ Continuous g :=\n  Iff.symm <| continuous_induced_rng.trans\n    ⟨fun h => continuous_uncurry_of_continuous ⟨_, h⟩,\n    continuous_of_continuous_uncurry (fun (y : Y) ↦ ContinuousMap.mk (g y))⟩\n\n"}
{"name":"Continuous.path_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nγ : Y → Path x y\nf : Y → Real\nhγ : Continuous (Function.HasUncurry.uncurry γ)\nhf : Continuous f\n⊢ Continuous fun t => (γ t).extend (f t)","decl":"/-- See Note [continuity lemma statement]. -/\ntheorem _root_.Continuous.path_extend {γ : Y → Path x y} {f : Y → ℝ} (hγ : Continuous ↿γ)\n    (hf : Continuous f) : Continuous fun t => (γ t).extend (f t) :=\n  Continuous.IccExtend hγ hf\n\n"}
{"name":"Path.continuous_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Continuous γ.extend","decl":"/-- A useful special case of `Continuous.path_extend`. -/\n@[continuity, fun_prop]\ntheorem continuous_extend : Continuous γ.extend :=\n  γ.continuous.Icc_extend'\n\n"}
{"name":"Filter.Tendsto.path_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nl r : Y → X\ny : Y\nl₁ : Filter Real\nl₂ : Filter X\nγ : (y : Y) → Path (l y) (r y)\nhγ : Filter.Tendsto (Function.HasUncurry.uncurry γ) (SProd.sprod (nhds y) (Filter.map (Set.projIcc 0 1 ⋯) l₁)) l₂\n⊢ Filter.Tendsto (Function.HasUncurry.uncurry fun x => (γ x).extend) (SProd.sprod (nhds y) l₁) l₂","decl":"theorem _root_.Filter.Tendsto.path_extend\n    {l r : Y → X} {y : Y} {l₁ : Filter ℝ} {l₂ : Filter X} {γ : ∀ y, Path (l y) (r y)}\n    (hγ : Tendsto (↿γ) (𝓝 y ×ˢ l₁.map (projIcc 0 1 zero_le_one)) l₂) :\n    Tendsto (↿fun x => (γ x).extend) (𝓝 y ×ˢ l₁) l₂ :=\n  Filter.Tendsto.IccExtend _ hγ\n\n"}
{"name":"ContinuousAt.path_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ng : Y → Real\nl r : Y → X\nγ : (y : Y) → Path (l y) (r y)\ny : Y\nhγ : ContinuousAt (Function.HasUncurry.uncurry γ) { fst := y, snd := Set.projIcc 0 1 ⋯ (g y) }\nhg : ContinuousAt g y\n⊢ ContinuousAt (fun i => (γ i).extend (g i)) y","decl":"theorem _root_.ContinuousAt.path_extend {g : Y → ℝ} {l r : Y → X} (γ : ∀ y, Path (l y) (r y))\n    {y : Y} (hγ : ContinuousAt (↿γ) (y, projIcc 0 1 zero_le_one (g y))) (hg : ContinuousAt g y) :\n    ContinuousAt (fun i => (γ i).extend (g i)) y :=\n  hγ.IccExtend (fun x => γ x) hg\n\n"}
{"name":"Path.extend_extends","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\nt : Real\nht : Membership.mem (Set.Icc 0 1) t\n⊢ Eq (γ.extend t) (γ ⟨t, ht⟩)","decl":"@[simp]\ntheorem extend_extends {a b : X} (γ : Path a b) {t : ℝ}\n    (ht : t ∈ (Icc 0 1 : Set ℝ)) : γ.extend t = γ ⟨t, ht⟩ :=\n  IccExtend_of_mem _ γ ht\n\n"}
{"name":"Path.extend_zero","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (γ.extend 0) x","decl":"theorem extend_zero : γ.extend 0 = x := by simp\n\n"}
{"name":"Path.extend_one","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (γ.extend 1) y","decl":"theorem extend_one : γ.extend 1 = y := by simp\n\n"}
{"name":"Path.extend_extends'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\nt : ↑(Set.Icc 0 1)\n⊢ Eq (γ.extend ↑t) (γ t)","decl":"theorem extend_extends' {a b : X} (γ : Path a b) (t : (Icc 0 1 : Set ℝ)) : γ.extend t = γ t :=\n  IccExtend_val _ γ t\n\n"}
{"name":"Path.extend_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\n⊢ Eq (Set.range γ.extend) (Set.range ⇑γ)","decl":"@[simp]\ntheorem extend_range {a b : X} (γ : Path a b) :\n    range γ.extend = range γ :=\n  IccExtend_range _ γ\n\n"}
{"name":"Path.extend_of_le_zero","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\nt : Real\nht : LE.le t 0\n⊢ Eq (γ.extend t) a","decl":"theorem extend_of_le_zero {a b : X} (γ : Path a b) {t : ℝ}\n    (ht : t ≤ 0) : γ.extend t = a :=\n  (IccExtend_of_le_left _ _ ht).trans γ.source\n\n"}
{"name":"Path.extend_of_one_le","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\nt : Real\nht : LE.le 1 t\n⊢ Eq (γ.extend t) b","decl":"theorem extend_of_one_le {a b : X} (γ : Path a b) {t : ℝ}\n    (ht : 1 ≤ t) : γ.extend t = b :=\n  (IccExtend_of_right_le _ _ ht).trans γ.target\n\n"}
{"name":"Path.refl_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na : X\n⊢ Eq (Path.refl a).extend fun x => a","decl":"@[simp]\ntheorem refl_extend {a : X} : (Path.refl a).extend = fun _ => a :=\n  rfl\n\n"}
{"name":"Path.ofLine_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nf : Real → X\nhf : ContinuousOn f unitInterval\nh₀ : Eq (f 0) x\nh₁ : Eq (f 1) y\nt : ↑unitInterval\n⊢ Membership.mem (Set.image f unitInterval) ((Path.ofLine hf h₀ h₁) t)","decl":"theorem ofLine_mem {f : ℝ → X} (hf : ContinuousOn f I) (h₀ : f 0 = x) (h₁ : f 1 = y) :\n    ∀ t, ofLine hf h₀ h₁ t ∈ f '' I := fun ⟨t, t_in⟩ => ⟨t, t_in, rfl⟩\n\n"}
{"name":"Path.trans_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y z : X\nγ : Path x y\nγ' : Path y z\nt : ↑unitInterval\n⊢ Eq ((γ.trans γ') t) (dite (LE.le (↑t) (1 / 2)) (fun h => γ ⟨HMul.hMul 2 ↑t, ⋯⟩) fun h => γ' ⟨HSub.hSub (HMul.hMul 2 ↑t) 1, ⋯⟩)","decl":"theorem trans_apply (γ : Path x y) (γ' : Path y z) (t : I) :\n    (γ.trans γ') t =\n      if h : (t : ℝ) ≤ 1 / 2 then γ ⟨2 * t, (mul_pos_mem_iff zero_lt_two).2 ⟨t.2.1, h⟩⟩\n      else γ' ⟨2 * t - 1, two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, t.2.2⟩⟩ :=\n  show ite _ _ _ = _ by split_ifs <;> rw [extend_extends]\n\n"}
{"name":"Path.trans_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y z : X\nγ : Path x y\nγ' : Path y z\n⊢ Eq (γ.trans γ').symm (γ'.symm.trans γ.symm)","decl":"@[simp]\ntheorem trans_symm (γ : Path x y) (γ' : Path y z) : (γ.trans γ').symm = γ'.symm.trans γ.symm := by\n  ext t\n  simp only [trans_apply, ← one_div, symm_apply, not_le, Function.comp_apply]\n  split_ifs with h h₁ h₂ <;> rw [coe_symm_eq] at h\n  · have ht : (t : ℝ) = 1 / 2 := by linarith\n    norm_num [ht]\n  · refine congr_arg _ (Subtype.ext ?_)\n    norm_num [sub_sub_eq_add_sub, mul_sub]\n  · refine congr_arg _ (Subtype.ext ?_)\n    norm_num [mul_sub, h]\n    ring -- TODO norm_num should really do this\n  · exfalso\n    linarith\n\n"}
{"name":"Path.refl_trans_refl","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na : X\n⊢ Eq ((Path.refl a).trans (Path.refl a)) (Path.refl a)","decl":"@[simp]\ntheorem refl_trans_refl {a : X} :\n    (Path.refl a).trans (Path.refl a) = Path.refl a := by\n  ext\n  simp only [Path.trans, ite_self, one_div, Path.refl_extend]\n  rfl\n\n"}
{"name":"Path.trans_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b c : X\nγ₁ : Path a b\nγ₂ : Path b c\n⊢ Eq (Set.range ⇑(γ₁.trans γ₂)) (Union.union (Set.range ⇑γ₁) (Set.range ⇑γ₂))","decl":"theorem trans_range {a b c : X} (γ₁ : Path a b) (γ₂ : Path b c) :\n    range (γ₁.trans γ₂) = range γ₁ ∪ range γ₂ := by\n  rw [Path.trans]\n  apply eq_of_subset_of_subset\n  · rintro x ⟨⟨t, ht0, ht1⟩, hxt⟩\n    by_cases h : t ≤ 1 / 2\n    · left\n      use ⟨2 * t, ⟨by linarith, by linarith⟩⟩\n      rw [← γ₁.extend_extends]\n      rwa [coe_mk_mk, Function.comp_apply, if_pos h] at hxt\n    · right\n      use ⟨2 * t - 1, ⟨by linarith, by linarith⟩⟩\n      rw [← γ₂.extend_extends]\n      rwa [coe_mk_mk, Function.comp_apply, if_neg h] at hxt\n  · rintro x (⟨⟨t, ht0, ht1⟩, hxt⟩ | ⟨⟨t, ht0, ht1⟩, hxt⟩)\n    · use ⟨t / 2, ⟨by linarith, by linarith⟩⟩\n      have : t / 2 ≤ 1 / 2 := (div_le_div_iff_of_pos_right (zero_lt_two : (0 : ℝ) < 2)).mpr ht1\n      rw [coe_mk_mk, Function.comp_apply, if_pos this, Subtype.coe_mk]\n      ring_nf\n      rwa [γ₁.extend_extends]\n    · by_cases h : t = 0\n      · use ⟨1 / 2, ⟨by linarith, by linarith⟩⟩\n        rw [coe_mk_mk, Function.comp_apply, if_pos le_rfl, Subtype.coe_mk,\n          mul_one_div_cancel (two_ne_zero' ℝ)]\n        rw [γ₁.extend_one]\n        rwa [← γ₂.extend_extends, h, γ₂.extend_zero] at hxt\n      · use ⟨(t + 1) / 2, ⟨by linarith, by linarith⟩⟩\n        replace h : t ≠ 0 := h\n        have ht0 := lt_of_le_of_ne ht0 h.symm\n        have : ¬(t + 1) / 2 ≤ 1 / 2 := by\n          rw [not_le]\n          linarith\n        rw [coe_mk_mk, Function.comp_apply, Subtype.coe_mk, if_neg this]\n        ring_nf\n        rwa [γ₂.extend_extends]\n\n"}
{"name":"Path.map_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nγ : Path x y\nf : X → Y\nh : Continuous f\n⊢ Eq (⇑(γ.map h)) (Function.comp f ⇑γ)","decl":"@[simp]\ntheorem map_coe (γ : Path x y) {f : X → Y} (h : Continuous f) :\n    (γ.map h : I → Y) = f ∘ γ := by\n  ext t\n  rfl\n\n"}
{"name":"Path.map_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nγ : Path x y\nf : X → Y\nh : Continuous f\n⊢ Eq (γ.map h).symm (γ.symm.map h)","decl":"@[simp]\ntheorem map_symm (γ : Path x y) {f : X → Y} (h : Continuous f) :\n    (γ.map h).symm = γ.symm.map h :=\n  rfl\n\n"}
{"name":"Path.map_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y z : X\nγ : Path x y\nγ' : Path y z\nf : X → Y\nh : Continuous f\n⊢ Eq ((γ.trans γ').map h) ((γ.map h).trans (γ'.map h))","decl":"@[simp]\ntheorem map_trans (γ : Path x y) (γ' : Path y z) {f : X → Y}\n    (h : Continuous f) : (γ.trans γ').map h = (γ.map h).trans (γ'.map h) := by\n  ext t\n  rw [trans_apply, map_coe, Function.comp_apply, trans_apply]\n  split_ifs <;> rfl\n\n"}
{"name":"Path.map_id","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (γ.map ⋯) γ","decl":"@[simp]\ntheorem map_id (γ : Path x y) : γ.map continuous_id = γ := by\n  ext\n  rfl\n\n"}
{"name":"Path.map_map","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nx y : X\nγ : Path x y\nZ : Type u_4\ninst✝ : TopologicalSpace Z\nf : X → Y\nhf : Continuous f\ng : Y → Z\nhg : Continuous g\n⊢ Eq ((γ.map hf).map hg) (γ.map ⋯)","decl":"@[simp]\ntheorem map_map (γ : Path x y) {Z : Type*} [TopologicalSpace Z]\n    {f : X → Y} (hf : Continuous f) {g : Y → Z} (hg : Continuous g) :\n    (γ.map hf).map hg = γ.map (hg.comp hf) := by\n  ext\n  rfl\n\n"}
{"name":"Path.symm_cast","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na₁ a₂ b₁ b₂ : X\nγ : Path a₂ b₂\nha : Eq a₁ a₂\nhb : Eq b₁ b₂\n⊢ Eq (γ.cast ha hb).symm (γ.symm.cast hb ha)","decl":"@[simp]\ntheorem symm_cast {a₁ a₂ b₁ b₂ : X} (γ : Path a₂ b₂) (ha : a₁ = a₂) (hb : b₁ = b₂) :\n    (γ.cast ha hb).symm = γ.symm.cast hb ha :=\n  rfl\n\n"}
{"name":"Path.trans_cast","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na₁ a₂ b₁ b₂ c₁ c₂ : X\nγ : Path a₂ b₂\nγ' : Path b₂ c₂\nha : Eq a₁ a₂\nhb : Eq b₁ b₂\nhc : Eq c₁ c₂\n⊢ Eq ((γ.cast ha hb).trans (γ'.cast hb hc)) ((γ.trans γ').cast ha hc)","decl":"@[simp]\ntheorem trans_cast {a₁ a₂ b₁ b₂ c₁ c₂ : X} (γ : Path a₂ b₂)\n    (γ' : Path b₂ c₂) (ha : a₁ = a₂) (hb : b₁ = b₂) (hc : c₁ = c₂) :\n    (γ.cast ha hb).trans (γ'.cast hb hc) = (γ.trans γ').cast ha hc :=\n  rfl\n\n"}
{"name":"Path.cast_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\nx' y' : X\nhx : Eq x' x\nhy : Eq y' y\n⊢ Eq ⇑(γ.cast hx hy) ⇑γ","decl":"@[simp]\ntheorem cast_coe (γ : Path x y) {x' y'} (hx : x' = x) (hy : y' = y) : (γ.cast hx hy : I → X) = γ :=\n  rfl\n\n"}
{"name":"Path.symm_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nι : Type u_4\ninst✝ : TopologicalSpace ι\na b : ι → X\nγ : (t : ι) → Path (a t) (b t)\nh : Continuous (Function.HasUncurry.uncurry γ)\n⊢ Continuous (Function.HasUncurry.uncurry fun t => (γ t).symm)","decl":"@[continuity, fun_prop]\ntheorem symm_continuous_family {ι : Type*} [TopologicalSpace ι]\n    {a b : ι → X} (γ : ∀ t : ι, Path (a t) (b t)) (h : Continuous ↿γ) :\n    Continuous ↿fun t => (γ t).symm :=\n  h.comp (continuous_id.prodMap continuous_symm)\n\n"}
{"name":"Path.continuous_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Continuous Path.symm","decl":"@[continuity]\ntheorem continuous_symm : Continuous (symm : Path x y → Path y x) :=\n  continuous_uncurry_iff.mp <| symm_continuous_family _ (continuous_fst.eval continuous_snd)\n\n"}
{"name":"Path.continuous_uncurry_extend_of_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nι : Type u_4\ninst✝ : TopologicalSpace ι\na b : ι → X\nγ : (t : ι) → Path (a t) (b t)\nh : Continuous (Function.HasUncurry.uncurry γ)\n⊢ Continuous (Function.HasUncurry.uncurry fun t => (γ t).extend)","decl":"@[continuity]\ntheorem continuous_uncurry_extend_of_continuous_family {ι : Type*} [TopologicalSpace ι]\n    {a b : ι → X} (γ : ∀ t : ι, Path (a t) (b t)) (h : Continuous ↿γ) :\n    Continuous ↿fun t => (γ t).extend := by\n  apply h.comp (continuous_id.prodMap continuous_projIcc)\n  exact zero_le_one\n\n"}
{"name":"Path.trans_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nι : Type u_4\ninst✝ : TopologicalSpace ι\na b c : ι → X\nγ₁ : (t : ι) → Path (a t) (b t)\nh₁ : Continuous (Function.HasUncurry.uncurry γ₁)\nγ₂ : (t : ι) → Path (b t) (c t)\nh₂ : Continuous (Function.HasUncurry.uncurry γ₂)\n⊢ Continuous (Function.HasUncurry.uncurry fun t => (γ₁ t).trans (γ₂ t))","decl":"@[continuity]\ntheorem trans_continuous_family {ι : Type*} [TopologicalSpace ι]\n    {a b c : ι → X} (γ₁ : ∀ t : ι, Path (a t) (b t)) (h₁ : Continuous ↿γ₁)\n    (γ₂ : ∀ t : ι, Path (b t) (c t)) (h₂ : Continuous ↿γ₂) :\n    Continuous ↿fun t => (γ₁ t).trans (γ₂ t) := by\n  have h₁' := Path.continuous_uncurry_extend_of_continuous_family γ₁ h₁\n  have h₂' := Path.continuous_uncurry_extend_of_continuous_family γ₂ h₂\n  simp only [HasUncurry.uncurry, CoeFun.coe, Path.trans, (· ∘ ·)]\n  refine Continuous.if_le ?_ ?_ (continuous_subtype_val.comp continuous_snd) continuous_const ?_\n  · change\n      Continuous ((fun p : ι × ℝ => (γ₁ p.1).extend p.2) ∘ Prod.map id (fun x => 2 * x : I → ℝ))\n    exact h₁'.comp (continuous_id.prodMap <| continuous_const.mul continuous_subtype_val)\n  · change\n      Continuous ((fun p : ι × ℝ => (γ₂ p.1).extend p.2) ∘ Prod.map id (fun x => 2 * x - 1 : I → ℝ))\n    exact\n      h₂'.comp\n        (continuous_id.prodMap <|\n          (continuous_const.mul continuous_subtype_val).sub continuous_const)\n  · rintro st hst\n    simp [hst, mul_inv_cancel₀ (two_ne_zero' ℝ)]\n\n"}
{"name":"Continuous.path_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y z : X\nf : Y → Path x y\ng : Y → Path y z\na✝¹ : Continuous f\na✝ : Continuous g\n⊢ Continuous fun t => (f t).trans (g t)","decl":"@[continuity]\ntheorem _root_.Continuous.path_trans {f : Y → Path x y} {g : Y → Path y z} :\n    Continuous f → Continuous g → Continuous fun t => (f t).trans (g t) := by\n  intro hf hg\n  apply continuous_uncurry_iff.mp\n  exact trans_continuous_family _ (continuous_uncurry_iff.mpr hf) _ (continuous_uncurry_iff.mpr hg)\n\n"}
{"name":"Path.continuous_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y z : X\n⊢ Continuous fun ρ => ρ.1.trans ρ.2","decl":"@[continuity]\ntheorem continuous_trans {x y z : X} : Continuous fun ρ : Path x y × Path y z => ρ.1.trans ρ.2 :=\n  continuous_fst.path_trans continuous_snd\n\n"}
{"name":"Path.prod_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\na₁ a₂ : X\nb₁ b₂ : Y\nγ₁ : Path a₁ a₂\nγ₂ : Path b₁ b₂\n⊢ Eq ⇑(γ₁.prod γ₂) fun t => { fst := γ₁ t, snd := γ₂ t }","decl":"@[simp]\ntheorem prod_coe (γ₁ : Path a₁ a₂) (γ₂ : Path b₁ b₂) :\n    ⇑(γ₁.prod γ₂) = fun t => (γ₁ t, γ₂ t) :=\n  rfl\n\n"}
{"name":"Path.trans_prod_eq_prod_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\na₁ a₂ a₃ : X\nb₁ b₂ b₃ : Y\nγ₁ : Path a₁ a₂\nδ₁ : Path a₂ a₃\nγ₂ : Path b₁ b₂\nδ₂ : Path b₂ b₃\n⊢ Eq ((γ₁.prod γ₂).trans (δ₁.prod δ₂)) ((γ₁.trans δ₁).prod (γ₂.trans δ₂))","decl":"/-- Path composition commutes with products -/\ntheorem trans_prod_eq_prod_trans (γ₁ : Path a₁ a₂) (δ₁ : Path a₂ a₃) (γ₂ : Path b₁ b₂)\n    (δ₂ : Path b₂ b₃) : (γ₁.prod γ₂).trans (δ₁.prod δ₂) = (γ₁.trans δ₁).prod (γ₂.trans δ₂) := by\n  ext t <;>\n  unfold Path.trans <;>\n  simp only [Path.coe_mk_mk, Path.prod_coe, Function.comp_apply] <;>\n  split_ifs <;>\n  rfl\n\n"}
{"name":"Path.pi_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"ι : Type u_3\nχ : ι → Type u_4\ninst✝ : (i : ι) → TopologicalSpace (χ i)\nas bs : (i : ι) → χ i\nγ : (i : ι) → Path (as i) (bs i)\n⊢ Eq ⇑(Path.pi γ) fun t i => (γ i) t","decl":"@[simp]\ntheorem pi_coe (γ : ∀ i, Path (as i) (bs i)) : ⇑(Path.pi γ) = fun t i => γ i t :=\n  rfl\n\n"}
{"name":"Path.trans_pi_eq_pi_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"ι : Type u_3\nχ : ι → Type u_4\ninst✝ : (i : ι) → TopologicalSpace (χ i)\nas bs cs : (i : ι) → χ i\nγ₀ : (i : ι) → Path (as i) (bs i)\nγ₁ : (i : ι) → Path (bs i) (cs i)\n⊢ Eq ((Path.pi γ₀).trans (Path.pi γ₁)) (Path.pi fun i => (γ₀ i).trans (γ₁ i))","decl":"/-- Path composition commutes with products -/\ntheorem trans_pi_eq_pi_trans (γ₀ : ∀ i, Path (as i) (bs i)) (γ₁ : ∀ i, Path (bs i) (cs i)) :\n    (Path.pi γ₀).trans (Path.pi γ₁) = Path.pi fun i => (γ₀ i).trans (γ₁ i) := by\n  ext t i\n  unfold Path.trans\n  simp only [Path.coe_mk_mk, Function.comp_apply, pi_coe]\n  split_ifs <;> rfl\n\n"}
{"name":"Path.add_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : Add X\ninst✝ : ContinuousAdd X\na₁ b₁ a₂ b₂ : X\nγ₁ : Path a₁ b₁\nγ₂ : Path a₂ b₂\nt : ↑unitInterval\n⊢ Eq ((γ₁.add γ₂) t) (HAdd.hAdd (γ₁ t) (γ₂ t))","decl":"@[to_additive]\nprotected theorem mul_apply [Mul X] [ContinuousMul X] {a₁ b₁ a₂ b₂ : X} (γ₁ : Path a₁ b₁)\n    (γ₂ : Path a₂ b₂) (t : unitInterval) : (γ₁.mul γ₂) t = γ₁ t * γ₂ t :=\n  rfl\n\n"}
{"name":"Path.mul_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : Mul X\ninst✝ : ContinuousMul X\na₁ b₁ a₂ b₂ : X\nγ₁ : Path a₁ b₁\nγ₂ : Path a₂ b₂\nt : ↑unitInterval\n⊢ Eq ((γ₁.mul γ₂) t) (HMul.hMul (γ₁ t) (γ₂ t))","decl":"@[to_additive]\nprotected theorem mul_apply [Mul X] [ContinuousMul X] {a₁ b₁ a₂ b₂ : X} (γ₁ : Path a₁ b₁)\n    (γ₂ : Path a₂ b₂) (t : unitInterval) : (γ₁.mul γ₂) t = γ₁ t * γ₂ t :=\n  rfl\n\n"}
{"name":"Path.truncate_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\nt₀ t₁ : Real\n⊢ HasSubset.Subset (Set.range ⇑(γ.truncate t₀ t₁)) (Set.range ⇑γ)","decl":"theorem truncate_range {a b : X} (γ : Path a b) {t₀ t₁ : ℝ} :\n    range (γ.truncate t₀ t₁) ⊆ range γ := by\n  rw [← γ.extend_range]\n  simp only [range_subset_iff, SetCoe.exists, SetCoe.forall]\n  intro x _hx\n  simp only [DFunLike.coe, Path.truncate, mem_range_self]\n\n"}
{"name":"Path.truncate_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\n⊢ Continuous fun x => (γ.truncate x.1 x.2.1) x.2.2","decl":"/-- For a path `γ`, `γ.truncate` gives a \"continuous family of paths\", by which we\n  mean the uncurried function which maps `(t₀, t₁, s)` to `γ.truncate t₀ t₁ s` is continuous. -/\n@[continuity]\ntheorem truncate_continuous_family {a b : X} (γ : Path a b) :\n    Continuous (fun x => γ.truncate x.1 x.2.1 x.2.2 : ℝ × ℝ × I → X) :=\n  γ.continuous_extend.comp\n    (((continuous_subtype_val.comp (continuous_snd.comp continuous_snd)).max continuous_fst).min\n      (continuous_fst.comp continuous_snd))\n\n"}
{"name":"Path.truncate_const_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\nt : Real\n⊢ Continuous (Function.HasUncurry.uncurry (γ.truncate t))","decl":"@[continuity]\ntheorem truncate_const_continuous_family {a b : X} (γ : Path a b)\n    (t : ℝ) : Continuous ↿(γ.truncate t) := by\n  have key : Continuous (fun x => (t, x) : ℝ × I → ℝ × ℝ × I) := by fun_prop\n  exact γ.truncate_continuous_family.comp key\n\n"}
{"name":"Path.truncate_self","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\nt : Real\n⊢ Eq (γ.truncate t t) ((Path.refl (γ.extend t)).cast ⋯ ⋯)","decl":"@[simp]\ntheorem truncate_self {a b : X} (γ : Path a b) (t : ℝ) :\n    γ.truncate t t = (Path.refl <| γ.extend t).cast (by rw [min_self]) rfl := by\n  ext x\n  rw [cast_coe]\n  simp only [truncate, DFunLike.coe, refl, min_def, max_def]\n  split_ifs with h₁ h₂ <;> congr\n\n"}
{"name":"Path.truncate_zero_zero","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\n⊢ Eq (γ.truncate 0 0) ((Path.refl a).cast ⋯ ⋯)","decl":"@[simp 1001] -- Porting note: increase `simp` priority so left-hand side doesn't simplify\ntheorem truncate_zero_zero {a b : X} (γ : Path a b) :\n    γ.truncate 0 0 = (Path.refl a).cast (by rw [min_self, γ.extend_zero]) γ.extend_zero := by\n  convert γ.truncate_self 0\n\n"}
{"name":"Path.truncate_one_one","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\n⊢ Eq (γ.truncate 1 1) ((Path.refl b).cast ⋯ ⋯)","decl":"@[simp 1001] -- Porting note: increase `simp` priority so left-hand side doesn't simplify\ntheorem truncate_one_one {a b : X} (γ : Path a b) :\n    γ.truncate 1 1 = (Path.refl b).cast (by rw [min_self, γ.extend_one]) γ.extend_one := by\n  convert γ.truncate_self 1\n\n"}
{"name":"Path.truncate_zero_one","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\na b : X\nγ : Path a b\n⊢ Eq (γ.truncate 0 1) (γ.cast ⋯ ⋯)","decl":"@[simp]\ntheorem truncate_zero_one {a b : X} (γ : Path a b) :\n    γ.truncate 0 1 = γ.cast (by simp [zero_le_one, extend_zero]) (by simp) := by\n  ext x\n  rw [cast_coe]\n  have : ↑x ∈ (Icc 0 1 : Set ℝ) := x.2\n  rw [truncate, coe_mk_mk, max_eq_left this.1, min_eq_left this.2, extend_extends']\n\n"}
{"name":"Path.coe_reparam","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\nf : ↑unitInterval → ↑unitInterval\nhfcont : Continuous f\nhf₀ : Eq (f 0) 0\nhf₁ : Eq (f 1) 1\n⊢ Eq (⇑(γ.reparam f hfcont hf₀ hf₁)) (Function.comp (⇑γ) f)","decl":"@[simp]\ntheorem coe_reparam (γ : Path x y) {f : I → I} (hfcont : Continuous f) (hf₀ : f 0 = 0)\n    (hf₁ : f 1 = 1) : ⇑(γ.reparam f hfcont hf₀ hf₁) = γ ∘ f :=\n  rfl\n-- Porting note: this seems like it was poorly named (was: `coe_to_fun`)\n\n"}
{"name":"Path.reparam_id","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (γ.reparam id ⋯ ⋯ ⋯) γ","decl":"@[simp]\ntheorem reparam_id (γ : Path x y) : γ.reparam id continuous_id rfl rfl = γ := by\n  ext\n  rfl\n\n"}
{"name":"Path.range_reparam","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\nf : ↑unitInterval → ↑unitInterval\nhfcont : Continuous f\nhf₀ : Eq (f 0) 0\nhf₁ : Eq (f 1) 1\n⊢ Eq (Set.range ⇑(γ.reparam f hfcont hf₀ hf₁)) (Set.range ⇑γ)","decl":"theorem range_reparam (γ : Path x y) {f : I → I} (hfcont : Continuous f) (hf₀ : f 0 = 0)\n    (hf₁ : f 1 = 1) : range (γ.reparam f hfcont hf₀ hf₁) = range γ := by\n  change range (γ ∘ f) = range γ\n  have : range f = univ := by\n    rw [range_eq_univ]\n    intro t\n    have h₁ : Continuous (Set.IccExtend (zero_le_one' ℝ) f) := by continuity\n    have := intermediate_value_Icc (zero_le_one' ℝ) h₁.continuousOn\n    · rw [IccExtend_left, IccExtend_right, Icc.mk_zero, Icc.mk_one, hf₀, hf₁] at this\n      rcases this t.2 with ⟨w, hw₁, hw₂⟩\n      rw [IccExtend_of_mem _ _ hw₁] at hw₂\n      exact ⟨_, hw₂⟩\n  rw [range_comp, this, image_univ]\n\n"}
{"name":"Path.refl_reparam","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nf : ↑unitInterval → ↑unitInterval\nhfcont : Continuous f\nhf₀ : Eq (f 0) 0\nhf₁ : Eq (f 1) 1\n⊢ Eq ((Path.refl x).reparam f hfcont hf₀ hf₁) (Path.refl x)","decl":"theorem refl_reparam {f : I → I} (hfcont : Continuous f) (hf₀ : f 0 = 0) (hf₁ : f 1 = 1) :\n    (refl x).reparam f hfcont hf₀ hf₁ = refl x := by\n  ext\n  simp\n\n"}
{"name":"Joined.refl","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Joined x x","decl":"@[refl]\ntheorem Joined.refl (x : X) : Joined x x :=\n  ⟨Path.refl x⟩\n\n"}
{"name":"Joined.symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nh : Joined x y\n⊢ Joined y x","decl":"@[symm]\ntheorem Joined.symm {x y : X} (h : Joined x y) : Joined y x :=\n  ⟨h.somePath.symm⟩\n\n"}
{"name":"Joined.trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y z : X\nhxy : Joined x y\nhyz : Joined y z\n⊢ Joined x z","decl":"@[trans]\ntheorem Joined.trans {x y z : X} (hxy : Joined x y) (hyz : Joined y z) : Joined x z :=\n  ⟨hxy.somePath.trans hyz.somePath⟩\n\n"}
{"name":"JoinedIn.mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n⊢ And (Membership.mem F x) (Membership.mem F y)","decl":"theorem JoinedIn.mem (h : JoinedIn F x y) : x ∈ F ∧ y ∈ F := by\n  rcases h with ⟨γ, γ_in⟩\n  have : γ 0 ∈ F ∧ γ 1 ∈ F := by constructor <;> apply γ_in\n  simpa using this\n\n"}
{"name":"JoinedIn.source_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n⊢ Membership.mem F x","decl":"theorem JoinedIn.source_mem (h : JoinedIn F x y) : x ∈ F :=\n  h.mem.1\n\n"}
{"name":"JoinedIn.target_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n⊢ Membership.mem F y","decl":"theorem JoinedIn.target_mem (h : JoinedIn F x y) : y ∈ F :=\n  h.mem.2\n\n"}
{"name":"JoinedIn.somePath_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\nt : ↑unitInterval\n⊢ Membership.mem F (h.somePath t)","decl":"theorem JoinedIn.somePath_mem (h : JoinedIn F x y) (t : I) : h.somePath t ∈ F :=\n  Classical.choose_spec h t\n\n"}
{"name":"JoinedIn.joined_subtype","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n⊢ Joined ⟨x, ⋯⟩ ⟨y, ⋯⟩","decl":"/-- If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`. -/\ntheorem JoinedIn.joined_subtype (h : JoinedIn F x y) :\n    Joined (⟨x, h.source_mem⟩ : F) (⟨y, h.target_mem⟩ : F) :=\n  ⟨{  toFun := fun t => ⟨h.somePath t, h.somePath_mem t⟩\n      continuous_toFun := by fun_prop\n      source' := by simp\n      target' := by simp }⟩\n\n"}
{"name":"JoinedIn.ofLine","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nf : Real → X\nhf : ContinuousOn f unitInterval\nh₀ : Eq (f 0) x\nh₁ : Eq (f 1) y\nhF : HasSubset.Subset (Set.image f unitInterval) F\n⊢ JoinedIn F x y","decl":"theorem JoinedIn.ofLine {f : ℝ → X} (hf : ContinuousOn f I) (h₀ : f 0 = x) (h₁ : f 1 = y)\n    (hF : f '' I ⊆ F) : JoinedIn F x y :=\n  ⟨Path.ofLine hf h₀ h₁, fun t => hF <| Path.ofLine_mem hf h₀ h₁ t⟩\n\n"}
{"name":"JoinedIn.joined","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n⊢ Joined x y","decl":"theorem JoinedIn.joined (h : JoinedIn F x y) : Joined x y :=\n  ⟨h.somePath⟩\n\n"}
{"name":"joinedIn_iff_joined","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nx_in : Membership.mem F x\ny_in : Membership.mem F y\n⊢ Iff (JoinedIn F x y) (Joined ⟨x, x_in⟩ ⟨y, y_in⟩)","decl":"theorem joinedIn_iff_joined (x_in : x ∈ F) (y_in : y ∈ F) :\n    JoinedIn F x y ↔ Joined (⟨x, x_in⟩ : F) (⟨y, y_in⟩ : F) :=\n  ⟨fun h => h.joined_subtype, fun h => ⟨h.somePath.map continuous_subtype_val, by simp⟩⟩\n\n"}
{"name":"joinedIn_univ","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (JoinedIn Set.univ x y) (Joined x y)","decl":"@[simp]\ntheorem joinedIn_univ : JoinedIn univ x y ↔ Joined x y := by\n  simp [JoinedIn, Joined, exists_true_iff_nonempty]\n\n"}
{"name":"JoinedIn.mono","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nU V : Set X\nh : JoinedIn U x y\nhUV : HasSubset.Subset U V\n⊢ JoinedIn V x y","decl":"theorem JoinedIn.mono {U V : Set X} (h : JoinedIn U x y) (hUV : U ⊆ V) : JoinedIn V x y :=\n  ⟨h.somePath, fun t => hUV (h.somePath_mem t)⟩\n\n"}
{"name":"JoinedIn.refl","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nF : Set X\nh : Membership.mem F x\n⊢ JoinedIn F x x","decl":"theorem JoinedIn.refl (h : x ∈ F) : JoinedIn F x x :=\n  ⟨Path.refl x, fun _t => h⟩\n\n"}
{"name":"JoinedIn.symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n⊢ JoinedIn F y x","decl":"@[symm]\ntheorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x := by\n  cases' h.mem with hx hy\n  simp_all only [joinedIn_iff_joined]\n  exact h.symm\n\n"}
{"name":"JoinedIn.trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y z : X\nF : Set X\nhxy : JoinedIn F x y\nhyz : JoinedIn F y z\n⊢ JoinedIn F x z","decl":"theorem JoinedIn.trans (hxy : JoinedIn F x y) (hyz : JoinedIn F y z) : JoinedIn F x z := by\n  cases' hxy.mem with hx hy\n  cases' hyz.mem with hx hy\n  simp_all only [joinedIn_iff_joined]\n  exact hxy.trans hyz\n\n"}
{"name":"Specializes.joinedIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : Specializes x y\nhx : Membership.mem F x\nhy : Membership.mem F y\n⊢ JoinedIn F x y","decl":"theorem Specializes.joinedIn (h : x ⤳ y) (hx : x ∈ F) (hy : y ∈ F) : JoinedIn F x y := by\n  refine ⟨⟨⟨Set.piecewise {1} (const I y) (const I x), ?_⟩, by simp, by simp⟩, fun t ↦ ?_⟩\n  · exact isClosed_singleton.continuous_piecewise_of_specializes continuous_const continuous_const\n      fun _ ↦ h\n  · simp only [Path.coe_mk_mk, piecewise]\n    split_ifs <;> assumption\n\n"}
{"name":"Inseparable.joinedIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : Inseparable x y\nhx : Membership.mem F x\nhy : Membership.mem F y\n⊢ JoinedIn F x y","decl":"theorem Inseparable.joinedIn (h : Inseparable x y) (hx : x ∈ F) (hy : y ∈ F) : JoinedIn F x y :=\n  h.specializes.joinedIn hx hy\n\n"}
{"name":"JoinedIn.map_continuousOn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nF : Set X\nh : JoinedIn F x y\nf : X → Y\nhf : ContinuousOn f F\n⊢ JoinedIn (Set.image f F) (f x) (f y)","decl":"theorem JoinedIn.map_continuousOn (h : JoinedIn F x y) {f : X → Y} (hf : ContinuousOn f F) :\n    JoinedIn (f '' F) (f x) (f y) :=\n  let ⟨γ, hγ⟩ := h\n  ⟨γ.map' <| hf.mono (range_subset_iff.mpr hγ), fun t ↦ mem_image_of_mem _ (hγ t)⟩\n\n"}
{"name":"JoinedIn.map","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nF : Set X\nh : JoinedIn F x y\nf : X → Y\nhf : Continuous f\n⊢ JoinedIn (Set.image f F) (f x) (f y)","decl":"theorem JoinedIn.map (h : JoinedIn F x y) {f : X → Y} (hf : Continuous f) :\n    JoinedIn (f '' F) (f x) (f y) :=\n  h.map_continuousOn hf.continuousOn\n\n"}
{"name":"Topology.IsInducing.joinedIn_image","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nF : Set X\nf : X → Y\nhf : Topology.IsInducing f\nhx : Membership.mem F x\nhy : Membership.mem F y\n⊢ Iff (JoinedIn (Set.image f F) (f x) (f y)) (JoinedIn F x y)","decl":"theorem Topology.IsInducing.joinedIn_image {f : X → Y} (hf : IsInducing f) (hx : x ∈ F)\n    (hy : y ∈ F) : JoinedIn (f '' F) (f x) (f y) ↔ JoinedIn F x y := by\n  refine ⟨?_, (.map · hf.continuous)⟩\n  rintro ⟨γ, hγ⟩\n  choose γ' hγ'F hγ' using hγ\n  have h₀ : x ⤳ γ' 0 := by rw [← hf.specializes_iff, hγ', γ.source]\n  have h₁ : γ' 1 ⤳ y := by rw [← hf.specializes_iff, hγ', γ.target]\n  have h : JoinedIn F (γ' 0) (γ' 1) := by\n    refine ⟨⟨⟨γ', ?_⟩, rfl, rfl⟩, hγ'F⟩\n    simpa only [hf.continuous_iff, comp_def, hγ'] using map_continuous γ\n  exact (h₀.joinedIn hx (hγ'F _)).trans <| h.trans <| h₁.joinedIn (hγ'F _) hy\n\n"}
{"name":"Inducing.joinedIn_image","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx y : X\nF : Set X\nf : X → Y\nhf : Topology.IsInducing f\nhx : Membership.mem F x\nhy : Membership.mem F y\n⊢ Iff (JoinedIn (Set.image f F) (f x) (f y)) (JoinedIn F x y)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.joinedIn_image := IsInducing.joinedIn_image\n\n"}
{"name":"mem_pathComponent_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Membership.mem (pathComponent y) x) (Joined y x)","decl":"theorem mem_pathComponent_iff : x ∈ pathComponent y ↔ Joined y x := .rfl\n\n"}
{"name":"mem_pathComponent_self","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Membership.mem (pathComponent x) x","decl":"@[simp]\ntheorem mem_pathComponent_self (x : X) : x ∈ pathComponent x :=\n  Joined.refl x\n\n"}
{"name":"pathComponent.nonempty","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ (pathComponent x).Nonempty","decl":"@[simp]\ntheorem pathComponent.nonempty (x : X) : (pathComponent x).Nonempty :=\n  ⟨x, mem_pathComponent_self x⟩\n\n"}
{"name":"mem_pathComponent_of_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nh : Membership.mem (pathComponent y) x\n⊢ Membership.mem (pathComponent x) y","decl":"theorem mem_pathComponent_of_mem (h : x ∈ pathComponent y) : y ∈ pathComponent x :=\n  Joined.symm h\n\n"}
{"name":"pathComponent_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Iff (Membership.mem (pathComponent y) x) (Membership.mem (pathComponent x) y)","decl":"theorem pathComponent_symm : x ∈ pathComponent y ↔ y ∈ pathComponent x :=\n  ⟨fun h => mem_pathComponent_of_mem h, fun h => mem_pathComponent_of_mem h⟩\n\n"}
{"name":"pathComponent_congr","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nh : Membership.mem (pathComponent y) x\n⊢ Eq (pathComponent x) (pathComponent y)","decl":"theorem pathComponent_congr (h : x ∈ pathComponent y) : pathComponent x = pathComponent y := by\n  ext z\n  constructor\n  · intro h'\n    rw [pathComponent_symm]\n    exact (h.trans h').symm\n  · intro h'\n    rw [pathComponent_symm] at h' ⊢\n    exact h'.trans h\n\n"}
{"name":"pathComponent_subset_component","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ HasSubset.Subset (pathComponent x) (connectedComponent x)","decl":"theorem pathComponent_subset_component (x : X) : pathComponent x ⊆ connectedComponent x :=\n  fun y h =>\n  (isConnected_range h.somePath.continuous).subset_connectedComponent ⟨0, by simp⟩ ⟨1, by simp⟩\n\n"}
{"name":"pathComponentIn_univ","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (pathComponentIn x Set.univ) (pathComponent x)","decl":"@[simp]\ntheorem pathComponentIn_univ (x : X) : pathComponentIn x univ = pathComponent x := by\n  simp [pathComponentIn, pathComponent, JoinedIn, Joined, exists_true_iff_nonempty]\n\n"}
{"name":"Joined.mem_pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y z : X\nhyz : Joined y z\nhxy : Membership.mem (pathComponent x) y\n⊢ Membership.mem (pathComponent x) z","decl":"theorem Joined.mem_pathComponent (hyz : Joined y z) (hxy : y ∈ pathComponent x) :\n    z ∈ pathComponent x :=\n  hxy.trans hyz\n\n"}
{"name":"mem_pathComponentIn_self","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nF : Set X\nh : Membership.mem F x\n⊢ Membership.mem (pathComponentIn x F) x","decl":"theorem mem_pathComponentIn_self (h : x ∈ F) : x ∈ pathComponentIn x F :=\n  JoinedIn.refl h\n\n"}
{"name":"pathComponentIn_subset","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nF : Set X\n⊢ HasSubset.Subset (pathComponentIn x F) F","decl":"theorem pathComponentIn_subset : pathComponentIn x F ⊆ F :=\n  fun _ hy ↦ hy.target_mem\n\n"}
{"name":"pathComponentIn_nonempty_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nF : Set X\n⊢ Iff (pathComponentIn x F).Nonempty (Membership.mem F x)","decl":"theorem pathComponentIn_nonempty_iff : (pathComponentIn x F).Nonempty ↔ x ∈ F :=\n  ⟨fun ⟨_, ⟨γ, hγ⟩⟩ ↦ γ.source ▸ hγ 0, fun hx ↦ ⟨x, mem_pathComponentIn_self hx⟩⟩\n\n"}
{"name":"pathComponentIn_congr","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : Membership.mem (pathComponentIn y F) x\n⊢ Eq (pathComponentIn x F) (pathComponentIn y F)","decl":"theorem pathComponentIn_congr (h : x ∈ pathComponentIn y F) :\n    pathComponentIn x F = pathComponentIn y F := by\n  ext; exact ⟨h.trans, h.symm.trans⟩\n\n"}
{"name":"pathComponentIn_mono","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nF G : Set X\nh : HasSubset.Subset F G\n⊢ HasSubset.Subset (pathComponentIn x F) (pathComponentIn x G)","decl":"@[gcongr]\ntheorem pathComponentIn_mono {G : Set X} (h : F ⊆ G) :\n    pathComponentIn x F ⊆ pathComponentIn x G :=\n  fun _ ⟨γ, hγ⟩ ↦ ⟨γ, fun t ↦ h (hγ t)⟩\n\n"}
{"name":"isPathConnected_iff_eq","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nF : Set X\n⊢ Iff (IsPathConnected F) (Exists fun x => And (Membership.mem F x) (Eq (pathComponentIn x F) F))","decl":"theorem isPathConnected_iff_eq : IsPathConnected F ↔ ∃ x ∈ F, pathComponentIn x F = F := by\n  constructor <;> rintro ⟨x, x_in, h⟩ <;> use x, x_in\n  · ext y\n    exact ⟨fun hy => hy.mem.2, h⟩\n  · intro y y_in\n    rwa [← h] at y_in\n\n"}
{"name":"IsPathConnected.joinedIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nF : Set X\nh : IsPathConnected F\nx : X\na✝¹ : Membership.mem F x\ny : X\na✝ : Membership.mem F y\n⊢ JoinedIn F x y","decl":"theorem IsPathConnected.joinedIn (h : IsPathConnected F) :\n    ∀ᵉ (x ∈ F) (y ∈ F), JoinedIn F x y := fun _x x_in _y y_in =>\n  let ⟨_b, _b_in, hb⟩ := h\n  (hb x_in).symm.trans (hb y_in)\n\n"}
{"name":"isPathConnected_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nF : Set X\n⊢ Iff (IsPathConnected F) (And F.Nonempty (∀ (x : X), Membership.mem F x → ∀ (y : X), Membership.mem F y → JoinedIn F x y))","decl":"theorem isPathConnected_iff :\n    IsPathConnected F ↔ F.Nonempty ∧ ∀ᵉ (x ∈ F) (y ∈ F), JoinedIn F x y :=\n  ⟨fun h =>\n    ⟨let ⟨b, b_in, _hb⟩ := h; ⟨b, b_in⟩, h.joinedIn⟩,\n    fun ⟨⟨b, b_in⟩, h⟩ => ⟨b, b_in, fun x_in => h _ b_in _ x_in⟩⟩\n\n"}
{"name":"IsPathConnected.image'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nF : Set X\nhF : IsPathConnected F\nf : X → Y\nhf : ContinuousOn f F\n⊢ IsPathConnected (Set.image f F)","decl":"/-- If `f` is continuous on `F` and `F` is path-connected, so is `f(F)`. -/\ntheorem IsPathConnected.image' (hF : IsPathConnected F)\n    {f : X → Y} (hf : ContinuousOn f F) : IsPathConnected (f '' F) := by\n  rcases hF with ⟨x, x_in, hx⟩\n  use f x, mem_image_of_mem f x_in\n  rintro _ ⟨y, y_in, rfl⟩\n  refine ⟨(hx y_in).somePath.map' ?_, fun t ↦ ⟨_, (hx y_in).somePath_mem t, rfl⟩⟩\n  exact hf.mono (range_subset_iff.2 (hx y_in).somePath_mem)\n\n"}
{"name":"IsPathConnected.image","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nF : Set X\nhF : IsPathConnected F\nf : X → Y\nhf : Continuous f\n⊢ IsPathConnected (Set.image f F)","decl":"/-- If `f` is continuous and `F` is path-connected, so is `f(F)`. -/\ntheorem IsPathConnected.image (hF : IsPathConnected F) {f : X → Y} (hf : Continuous f) :\n    IsPathConnected (f '' F) :=\n  hF.image' hf.continuousOn\n\n"}
{"name":"Topology.IsInducing.isPathConnected_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nF : Set X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (IsPathConnected F) (IsPathConnected (Set.image f F))","decl":"/-- If `f : X → Y` is an inducing map, `f(F)` is path-connected iff `F` is. -/\nnonrec theorem Topology.IsInducing.isPathConnected_iff {f : X → Y} (hf : IsInducing f) :\n    IsPathConnected F ↔ IsPathConnected (f '' F) := by\n  simp only [IsPathConnected, forall_mem_image, exists_mem_image]\n  refine exists_congr fun x ↦ and_congr_right fun hx ↦ forall₂_congr fun y hy ↦ ?_\n  rw [hf.joinedIn_image hx hy]\n\n"}
{"name":"Inducing.isPathConnected_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nF : Set X\nf : X → Y\nhf : Topology.IsInducing f\n⊢ Iff (IsPathConnected F) (IsPathConnected (Set.image f F))","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isPathConnected_iff := IsInducing.isPathConnected_iff\n\n"}
{"name":"Homeomorph.isPathConnected_image","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nh : Homeomorph X Y\n⊢ Iff (IsPathConnected (Set.image (⇑h) s)) (IsPathConnected s)","decl":"/-- If `h : X → Y` is a homeomorphism, `h(s)` is path-connected iff `s` is. -/\n@[simp]\ntheorem Homeomorph.isPathConnected_image {s : Set X} (h : X ≃ₜ Y) :\n    IsPathConnected (h '' s) ↔ IsPathConnected s :=\n  h.isInducing.isPathConnected_iff.symm\n\n"}
{"name":"Homeomorph.isPathConnected_preimage","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set Y\nh : Homeomorph X Y\n⊢ Iff (IsPathConnected (Set.preimage (⇑h) s)) (IsPathConnected s)","decl":"/-- If `h : X → Y` is a homeomorphism, `h⁻¹(s)` is path-connected iff `s` is. -/\n@[simp]\ntheorem Homeomorph.isPathConnected_preimage {s : Set Y} (h : X ≃ₜ Y) :\n    IsPathConnected (h ⁻¹' s) ↔ IsPathConnected s := by\n  rw [← Homeomorph.image_symm]; exact h.symm.isPathConnected_image\n\n"}
{"name":"IsPathConnected.mem_pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx y : X\nF : Set X\nh : IsPathConnected F\nx_in : Membership.mem F x\ny_in : Membership.mem F y\n⊢ Membership.mem (pathComponent x) y","decl":"theorem IsPathConnected.mem_pathComponent (h : IsPathConnected F) (x_in : x ∈ F) (y_in : y ∈ F) :\n    y ∈ pathComponent x :=\n  (h.joinedIn x x_in y y_in).joined\n\n"}
{"name":"IsPathConnected.subset_pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nF : Set X\nh : IsPathConnected F\nx_in : Membership.mem F x\n⊢ HasSubset.Subset F (pathComponent x)","decl":"theorem IsPathConnected.subset_pathComponent (h : IsPathConnected F) (x_in : x ∈ F) :\n    F ⊆ pathComponent x := fun _y y_in => h.mem_pathComponent x_in y_in\n\n"}
{"name":"IsPathConnected.subset_pathComponentIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nF s : Set X\nhs : IsPathConnected s\nhxs : Membership.mem s x\nhsF : HasSubset.Subset s F\n⊢ HasSubset.Subset s (pathComponentIn x F)","decl":"theorem IsPathConnected.subset_pathComponentIn {s : Set X} (hs : IsPathConnected s)\n    (hxs : x ∈ s) (hsF : s ⊆ F) : s ⊆ pathComponentIn x F :=\n  fun y hys ↦ (hs.joinedIn x hxs y hys).mono hsF\n\n"}
{"name":"isPathConnected_singleton","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ IsPathConnected (Singleton.singleton x)","decl":"theorem isPathConnected_singleton (x : X) : IsPathConnected ({x} : Set X) := by\n  refine ⟨x, rfl, ?_⟩\n  rintro y rfl\n  exact JoinedIn.refl rfl\n\n"}
{"name":"isPathConnected_pathComponentIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nF : Set X\nh : Membership.mem F x\n⊢ IsPathConnected (pathComponentIn x F)","decl":"theorem isPathConnected_pathComponentIn (h : x ∈ F) : IsPathConnected (pathComponentIn x F) :=\n  ⟨x, mem_pathComponentIn_self h, fun ⟨γ, hγ⟩ ↦ by\n    refine ⟨γ, fun t ↦\n      ⟨(γ.truncateOfLE t.2.1).cast (γ.extend_zero.symm) (γ.extend_extends' t).symm, fun t' ↦ ?_⟩⟩\n    dsimp [Path.truncateOfLE, Path.truncate]\n    exact γ.extend_extends' ⟨min (max t'.1 0) t.1, by simp [t.2.1, t.2.2]⟩ ▸ hγ _⟩\n\n"}
{"name":"isPathConnected_pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ IsPathConnected (pathComponent x)","decl":"theorem isPathConnected_pathComponent : IsPathConnected (pathComponent x) := by\n  rw [← pathComponentIn_univ]\n  exact isPathConnected_pathComponentIn (mem_univ x)\n\n"}
{"name":"IsPathConnected.union","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nU V : Set X\nhU : IsPathConnected U\nhV : IsPathConnected V\nhUV : (Inter.inter U V).Nonempty\n⊢ IsPathConnected (Union.union U V)","decl":"theorem IsPathConnected.union {U V : Set X} (hU : IsPathConnected U) (hV : IsPathConnected V)\n    (hUV : (U ∩ V).Nonempty) : IsPathConnected (U ∪ V) := by\n  rcases hUV with ⟨x, xU, xV⟩\n  use x, Or.inl xU\n  rintro y (yU | yV)\n  · exact (hU.joinedIn x xU y yU).mono subset_union_left\n  · exact (hV.joinedIn x xV y yV).mono subset_union_right\n\n"}
{"name":"IsPathConnected.preimage_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nU W : Set X\nhW : IsPathConnected W\nhWU : HasSubset.Subset W U\n⊢ IsPathConnected (Set.preimage Subtype.val W)","decl":"/-- If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\nambient type `U` (when `U` contains `W`). -/\ntheorem IsPathConnected.preimage_coe {U W : Set X} (hW : IsPathConnected W) (hWU : W ⊆ U) :\n    IsPathConnected (((↑) : U → X) ⁻¹' W) := by\n  rwa [IsInducing.subtypeVal.isPathConnected_iff, Subtype.image_preimage_val, inter_eq_right.2 hWU]\n\n"}
{"name":"IsPathConnected.exists_path_through_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nn : Nat\ns : Set X\nh : IsPathConnected s\np : Fin (HAdd.hAdd n 1) → X\nhp : ∀ (i : Fin (HAdd.hAdd n 1)), Membership.mem s (p i)\n⊢ Exists fun γ => And (HasSubset.Subset (Set.range ⇑γ) s) (∀ (i : Fin (HAdd.hAdd n 1)), Membership.mem (Set.range ⇑γ) (p i))","decl":"theorem IsPathConnected.exists_path_through_family {n : ℕ}\n    {s : Set X} (h : IsPathConnected s) (p : Fin (n + 1) → X) (hp : ∀ i, p i ∈ s) :\n    ∃ γ : Path (p 0) (p n), range γ ⊆ s ∧ ∀ i, p i ∈ range γ := by\n  let p' : ℕ → X := fun k => if h : k < n + 1 then p ⟨k, h⟩ else p ⟨0, n.zero_lt_succ⟩\n  obtain ⟨γ, hγ⟩ : ∃ γ : Path (p' 0) (p' n), (∀ i ≤ n, p' i ∈ range γ) ∧ range γ ⊆ s := by\n    have hp' : ∀ i ≤ n, p' i ∈ s := by\n      intro i hi\n      simp [p', Nat.lt_succ_of_le hi, hp]\n    clear_value p'\n    clear hp p\n    induction' n with n hn\n    · use Path.refl (p' 0)\n      constructor\n      · rintro i hi\n        rw [Nat.le_zero.mp hi]\n        exact ⟨0, rfl⟩\n      · rw [range_subset_iff]\n        rintro _x\n        exact hp' 0 le_rfl\n    · rcases hn fun i hi => hp' i <| Nat.le_succ_of_le hi with ⟨γ₀, hγ₀⟩\n      rcases h.joinedIn (p' n) (hp' n n.le_succ) (p' <| n + 1) (hp' (n + 1) <| le_rfl) with\n        ⟨γ₁, hγ₁⟩\n      let γ : Path (p' 0) (p' <| n + 1) := γ₀.trans γ₁\n      use γ\n      have range_eq : range γ = range γ₀ ∪ range γ₁ := γ₀.trans_range γ₁\n      constructor\n      · rintro i hi\n        by_cases hi' : i ≤ n\n        · rw [range_eq]\n          left\n          exact hγ₀.1 i hi'\n        · rw [not_le, ← Nat.succ_le_iff] at hi'\n          have : i = n.succ := le_antisymm hi hi'\n          rw [this]\n          use 1\n          exact γ.target\n      · rw [range_eq]\n        apply union_subset hγ₀.2\n        rw [range_subset_iff]\n        exact hγ₁\n  have hpp' : ∀ k < n + 1, p k = p' k := by\n    intro k hk\n    simp only [p', hk, dif_pos]\n    congr\n    ext\n    rw [Fin.val_cast_of_lt hk]\n  use γ.cast (hpp' 0 n.zero_lt_succ) (hpp' n n.lt_succ_self)\n  simp only [γ.cast_coe]\n  refine And.intro hγ.2 ?_\n  rintro ⟨i, hi⟩\n  suffices p ⟨i, hi⟩ = p' i by convert hγ.1 i (Nat.le_of_lt_succ hi)\n  rw [← hpp' i hi]\n  suffices i = i % n.succ by congr\n  rw [Nat.mod_eq_of_lt hi]\n\n"}
{"name":"IsPathConnected.exists_path_through_family'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nn : Nat\ns : Set X\nh : IsPathConnected s\np : Fin (HAdd.hAdd n 1) → X\nhp : ∀ (i : Fin (HAdd.hAdd n 1)), Membership.mem s (p i)\n⊢ Exists fun γ => Exists fun t => And (∀ (t : ↑unitInterval), Membership.mem s (γ t)) (∀ (i : Fin (HAdd.hAdd n 1)), Eq (γ (t i)) (p i))","decl":"theorem IsPathConnected.exists_path_through_family' {n : ℕ}\n    {s : Set X} (h : IsPathConnected s) (p : Fin (n + 1) → X) (hp : ∀ i, p i ∈ s) :\n    ∃ (γ : Path (p 0) (p n)) (t : Fin (n + 1) → I), (∀ t, γ t ∈ s) ∧ ∀ i, γ (t i) = p i := by\n  rcases h.exists_path_through_family p hp with ⟨γ, hγ⟩\n  rcases hγ with ⟨h₁, h₂⟩\n  simp only [range, mem_setOf_eq] at h₂\n  rw [range_subset_iff] at h₁\n  choose! t ht using h₂\n  exact ⟨γ, t, h₁, ht⟩\n\n"}
{"name":"pathConnectedSpace_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\n⊢ Iff (PathConnectedSpace X) (And (Nonempty X) (∀ (x y : X), Joined x y))","decl":"/-- A topological space is path-connected if it is non-empty and every two points can be\njoined by a continuous path. -/\n@[mk_iff]\nclass PathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- A path-connected space must be nonempty. -/\n  nonempty : Nonempty X\n  /-- Any two points in a path-connected space must be joined by a continuous path. -/\n  joined : ∀ x y : X, Joined x y\n\n"}
{"name":"PathConnectedSpace.nonempty","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\nself : PathConnectedSpace X\n⊢ Nonempty X","decl":"/-- A topological space is path-connected if it is non-empty and every two points can be\njoined by a continuous path. -/\n@[mk_iff]\nclass PathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- A path-connected space must be nonempty. -/\n  nonempty : Nonempty X\n  /-- Any two points in a path-connected space must be joined by a continuous path. -/\n  joined : ∀ x y : X, Joined x y\n\n"}
{"name":"PathConnectedSpace.joined","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\nself : PathConnectedSpace X\nx y : X\n⊢ Joined x y","decl":"/-- A topological space is path-connected if it is non-empty and every two points can be\njoined by a continuous path. -/\n@[mk_iff]\nclass PathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- A path-connected space must be nonempty. -/\n  nonempty : Nonempty X\n  /-- Any two points in a path-connected space must be joined by a continuous path. -/\n  joined : ∀ x y : X, Joined x y\n\n"}
{"name":"pathConnectedSpace_iff_zerothHomotopy","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (PathConnectedSpace X) (And (Nonempty (ZerothHomotopy X)) (Subsingleton (ZerothHomotopy X)))","decl":"theorem pathConnectedSpace_iff_zerothHomotopy :\n    PathConnectedSpace X ↔ Nonempty (ZerothHomotopy X) ∧ Subsingleton (ZerothHomotopy X) := by\n  letI := pathSetoid X\n  constructor\n  · intro h\n    refine ⟨(nonempty_quotient_iff _).mpr h.1, ⟨?_⟩⟩\n    rintro ⟨x⟩ ⟨y⟩\n    exact Quotient.sound (PathConnectedSpace.joined x y)\n  · unfold ZerothHomotopy\n    rintro ⟨h, h'⟩\n    exact ⟨(nonempty_quotient_iff _).mp h, fun x y => Quotient.exact <| Subsingleton.elim ⟦x⟧ ⟦y⟧⟩\n\n"}
{"name":"pathConnectedSpace_iff_univ","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (PathConnectedSpace X) (IsPathConnected Set.univ)","decl":"theorem pathConnectedSpace_iff_univ : PathConnectedSpace X ↔ IsPathConnected (univ : Set X) := by\n  simp [pathConnectedSpace_iff, isPathConnected_iff, nonempty_iff_univ_nonempty]\n\n"}
{"name":"isPathConnected_iff_pathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nF : Set X\n⊢ Iff (IsPathConnected F) (PathConnectedSpace ↑F)","decl":"theorem isPathConnected_iff_pathConnectedSpace : IsPathConnected F ↔ PathConnectedSpace F := by\n  rw [pathConnectedSpace_iff_univ, IsInducing.subtypeVal.isPathConnected_iff, image_univ,\n    Subtype.range_val_subtype, setOf_mem_eq]\n\n"}
{"name":"isPathConnected_univ","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : PathConnectedSpace X\n⊢ IsPathConnected Set.univ","decl":"theorem isPathConnected_univ [PathConnectedSpace X] : IsPathConnected (univ : Set X) :=\n  pathConnectedSpace_iff_univ.mp inferInstance\n\n"}
{"name":"isPathConnected_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : PathConnectedSpace X\nf : X → Y\nhf : Continuous f\n⊢ IsPathConnected (Set.range f)","decl":"theorem isPathConnected_range [PathConnectedSpace X] {f : X → Y} (hf : Continuous f) :\n    IsPathConnected (range f) := by\n  rw [← image_univ]\n  exact isPathConnected_univ.image hf\n\n"}
{"name":"Function.Surjective.pathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : PathConnectedSpace X\nf : X → Y\nhf : Function.Surjective f\nhf' : Continuous f\n⊢ PathConnectedSpace Y","decl":"theorem Function.Surjective.pathConnectedSpace [PathConnectedSpace X]\n    {f : X → Y} (hf : Surjective f) (hf' : Continuous f) : PathConnectedSpace Y := by\n  rw [pathConnectedSpace_iff_univ, ← hf.range_eq]\n  exact isPathConnected_range hf'\n\n"}
{"name":"Quotient.instPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ns : Setoid X\ninst✝ : PathConnectedSpace X\n⊢ PathConnectedSpace (Quotient s)","decl":"instance Quotient.instPathConnectedSpace {s : Setoid X} [PathConnectedSpace X] :\n    PathConnectedSpace (Quotient s) :=\n  Quotient.mk'_surjective.pathConnectedSpace continuous_coinduced_rng\n\n"}
{"name":"Real.instPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"⊢ PathConnectedSpace Real","decl":"/-- This is a special case of `NormedSpace.instPathConnectedSpace` (and\n`TopologicalAddGroup.pathConnectedSpace`). It exists only to simplify dependencies. -/\ninstance Real.instPathConnectedSpace : PathConnectedSpace ℝ where\n  joined x y := ⟨⟨⟨fun (t : I) ↦ (1 - t) * x + t * y, by fun_prop⟩, by simp, by simp⟩⟩\n  nonempty := inferInstance\n\n"}
{"name":"pathConnectedSpace_iff_eq","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Iff (PathConnectedSpace X) (Exists fun x => Eq (pathComponent x) Set.univ)","decl":"theorem pathConnectedSpace_iff_eq : PathConnectedSpace X ↔ ∃ x : X, pathComponent x = univ := by\n  simp [pathConnectedSpace_iff_univ, isPathConnected_iff_eq]\n\n-- see Note [lower instance priority]\n"}
{"name":"PathConnectedSpace.connectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : PathConnectedSpace X\n⊢ ConnectedSpace X","decl":"instance (priority := 100) PathConnectedSpace.connectedSpace [PathConnectedSpace X] :\n    ConnectedSpace X := by\n  rw [connectedSpace_iff_connectedComponent]\n  rcases isPathConnected_iff_eq.mp (pathConnectedSpace_iff_univ.mp ‹_›) with ⟨x, _x_in, hx⟩\n  use x\n  rw [← univ_subset_iff]\n  exact (by simpa using hx : pathComponent x = univ) ▸ pathComponent_subset_component x\n\n"}
{"name":"IsPathConnected.isConnected","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nF : Set X\nhF : IsPathConnected F\n⊢ IsConnected F","decl":"theorem IsPathConnected.isConnected (hF : IsPathConnected F) : IsConnected F := by\n  rw [isConnected_iff_connectedSpace]\n  rw [isPathConnected_iff_pathConnectedSpace] at hF\n  exact @PathConnectedSpace.connectedSpace _ _ hF\n\n"}
{"name":"PathConnectedSpace.exists_path_through_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : PathConnectedSpace X\nn : Nat\np : Fin (HAdd.hAdd n 1) → X\n⊢ Exists fun γ => ∀ (i : Fin (HAdd.hAdd n 1)), Membership.mem (Set.range ⇑γ) (p i)","decl":"theorem exists_path_through_family {n : ℕ} (p : Fin (n + 1) → X) :\n    ∃ γ : Path (p 0) (p n), ∀ i, p i ∈ range γ := by\n  have : IsPathConnected (univ : Set X) := pathConnectedSpace_iff_univ.mp (by infer_instance)\n  rcases this.exists_path_through_family p fun _i => True.intro with ⟨γ, -, h⟩\n  exact ⟨γ, h⟩\n\n"}
{"name":"PathConnectedSpace.exists_path_through_family'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : PathConnectedSpace X\nn : Nat\np : Fin (HAdd.hAdd n 1) → X\n⊢ Exists fun γ => Exists fun t => ∀ (i : Fin (HAdd.hAdd n 1)), Eq (γ (t i)) (p i)","decl":"theorem exists_path_through_family' {n : ℕ} (p : Fin (n + 1) → X) :\n    ∃ (γ : Path (p 0) (p n)) (t : Fin (n + 1) → I), ∀ i, γ (t i) = p i := by\n  have : IsPathConnected (univ : Set X) := pathConnectedSpace_iff_univ.mp (by infer_instance)\n  rcases this.exists_path_through_family' p fun _i => True.intro with ⟨γ, t, -, h⟩\n  exact ⟨γ, t, h⟩\n\n"}
{"name":"LocPathConnectedSpace.path_connected_basis","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\nself : LocPathConnectedSpace X\nx : X\n⊢ (nhds x).HasBasis (fun s => And (Membership.mem (nhds x) s) (IsPathConnected s)) id","decl":"/-- A topological space is locally path connected, at every point, path connected\nneighborhoods form a neighborhood basis. -/\nclass LocPathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- Each neighborhood filter has a basis of path-connected neighborhoods. -/\n  path_connected_basis : ∀ x : X, (𝓝 x).HasBasis (fun s : Set X => s ∈ 𝓝 x ∧ IsPathConnected s) id\n\n"}
{"name":"LocPathConnectedSpace.of_bases","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Type u_3\np : X → ι → Prop\ns : X → ι → Set X\nh : ∀ (x : X), (nhds x).HasBasis (p x) (s x)\nh' : ∀ (x : X) (i : ι), p x i → IsPathConnected (s x i)\n⊢ LocPathConnectedSpace X","decl":"theorem LocPathConnectedSpace.of_bases {p : X → ι → Prop} {s : X → ι → Set X}\n    (h : ∀ x, (𝓝 x).HasBasis (p x) (s x)) (h' : ∀ x i, p x i → IsPathConnected (s x i)) :\n    LocPathConnectedSpace X where\n  path_connected_basis x := by\n    rw [hasBasis_self]\n    intro t ht\n    rcases (h x).mem_iff.mp ht with ⟨i, hpi, hi⟩\n    exact ⟨s x i, (h x).mem_of_mem hpi, h' x i hpi, hi⟩\n\n"}
{"name":"locPathConnected_of_bases","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nι : Type u_3\np : X → ι → Prop\ns : X → ι → Set X\nh : ∀ (x : X), (nhds x).HasBasis (p x) (s x)\nh' : ∀ (x : X) (i : ι), p x i → IsPathConnected (s x i)\n⊢ LocPathConnectedSpace X","decl":"@[deprecated (since := \"2024-10-16\")]\nalias locPathConnected_of_bases := LocPathConnectedSpace.of_bases\n\n"}
{"name":"IsOpen.pathComponentIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nF : Set X\ninst✝ : LocPathConnectedSpace X\nx : X\nhF : IsOpen F\n⊢ IsOpen (pathComponentIn x F)","decl":"protected theorem IsOpen.pathComponentIn (x : X) (hF : IsOpen F) :\n    IsOpen (pathComponentIn x F) := by\n  rw [isOpen_iff_mem_nhds]\n  intro y hy\n  let ⟨s, hs⟩ := (path_connected_basis y).mem_iff.mp (hF.mem_nhds (pathComponentIn_subset hy))\n  exact mem_of_superset hs.1.1 <| pathComponentIn_congr hy ▸\n    hs.1.2.subset_pathComponentIn (mem_of_mem_nhds hs.1.1) hs.2\n\n"}
{"name":"IsOpen.pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nx : X\n⊢ IsOpen (pathComponent x)","decl":"/-- In a locally path connected space, each path component is an open set. -/\nprotected theorem IsOpen.pathComponent (x : X) : IsOpen (pathComponent x) := by\n  rw [← pathComponentIn_univ]\n  exact isOpen_univ.pathComponentIn _\n\n"}
{"name":"IsClosed.pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nx : X\n⊢ IsClosed (pathComponent x)","decl":"/-- In a locally path connected space, each path component is a closed set. -/\nprotected theorem IsClosed.pathComponent (x : X) : IsClosed (pathComponent x) := by\n  rw [← isOpen_compl_iff, isOpen_iff_mem_nhds]\n  intro y hxy\n  rcases (path_connected_basis y).ex_mem with ⟨V, hVy, hVc⟩\n  filter_upwards [hVy] with z hz hxz\n  exact hxy <|  hxz.trans (hVc.joinedIn _ hz _ (mem_of_mem_nhds hVy)).joined\n\n"}
{"name":"IsClopen.pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nx : X\n⊢ IsClopen (pathComponent x)","decl":"/-- In a locally path connected space, each path component is a clopen set. -/\nprotected theorem IsClopen.pathComponent (x : X) : IsClopen (pathComponent x) :=\n  ⟨.pathComponent x, .pathComponent x⟩\n\n"}
{"name":"pathComponentIn_mem_nhds","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nx : X\nF : Set X\ninst✝ : LocPathConnectedSpace X\nhF : Membership.mem (nhds x) F\n⊢ Membership.mem (nhds x) (pathComponentIn x F)","decl":"lemma pathComponentIn_mem_nhds (hF : F ∈ 𝓝 x) : pathComponentIn x F ∈ 𝓝 x := by\n  let ⟨u, huF, hu, hxu⟩ := mem_nhds_iff.mp hF\n  exact mem_nhds_iff.mpr ⟨pathComponentIn x u, pathComponentIn_mono huF,\n    hu.pathComponentIn x, mem_pathComponentIn_self hxu⟩\n\n"}
{"name":"pathConnectedSpace_iff_connectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\n⊢ Iff (PathConnectedSpace X) (ConnectedSpace X)","decl":"theorem pathConnectedSpace_iff_connectedSpace : PathConnectedSpace X ↔ ConnectedSpace X := by\n  refine ⟨fun _ ↦ inferInstance, fun h ↦ ⟨inferInstance, fun x y ↦ ?_⟩⟩\n  rw [← mem_pathComponent_iff, (IsClopen.pathComponent _).eq_univ] <;> simp\n\n"}
{"name":"pathComponent_eq_connectedComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nx : X\n⊢ Eq (pathComponent x) (connectedComponent x)","decl":"theorem pathComponent_eq_connectedComponent (x : X) : pathComponent x = connectedComponent x :=\n  (pathComponent_subset_component x).antisymm <|\n    (IsClopen.pathComponent x).connectedComponent_subset (mem_pathComponent_self _)\n\n"}
{"name":"pathConnected_subset_basis","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : LocPathConnectedSpace X\nU : Set X\nh : IsOpen U\nhx : Membership.mem U x\n⊢ (nhds x).HasBasis (fun s => And (Membership.mem (nhds x) s) (And (IsPathConnected s) (HasSubset.Subset s U))) id","decl":"theorem pathConnected_subset_basis {U : Set X} (h : IsOpen U) (hx : x ∈ U) :\n    (𝓝 x).HasBasis (fun s : Set X => s ∈ 𝓝 x ∧ IsPathConnected s ∧ s ⊆ U) id :=\n  (path_connected_basis x).hasBasis_self_subset (IsOpen.mem_nhds h hx)\n\n"}
{"name":"isOpen_isPathConnected_basis","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nx : X\n⊢ (nhds x).HasBasis (fun s => And (IsOpen s) (And (Membership.mem s x) (IsPathConnected s))) id","decl":"theorem isOpen_isPathConnected_basis (x : X) :\n    (𝓝 x).HasBasis (fun s : Set X ↦ IsOpen s ∧ x ∈ s ∧ IsPathConnected s) id := by\n  refine ⟨fun s ↦ ⟨fun hs ↦ ?_, fun ⟨u, hu⟩ ↦ mem_nhds_iff.mpr ⟨u, hu.2, hu.1.1, hu.1.2.1⟩⟩⟩\n  have ⟨u, hus, hu, hxu⟩ := mem_nhds_iff.mp hs\n  exact ⟨pathComponentIn x u, ⟨hu.pathComponentIn _, ⟨mem_pathComponentIn_self hxu,\n    isPathConnected_pathComponentIn hxu⟩⟩, pathComponentIn_subset.trans hus⟩\n\n"}
{"name":"Topology.IsOpenEmbedding.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : LocPathConnectedSpace X\ne : Y → X\nhe : Topology.IsOpenEmbedding e\n⊢ LocPathConnectedSpace Y","decl":"theorem Topology.IsOpenEmbedding.locPathConnectedSpace {e : Y → X} (he : IsOpenEmbedding e) :\n    LocPathConnectedSpace Y :=\n  have (y : Y) :\n      (𝓝 y).HasBasis (fun s ↦ s ∈ 𝓝 (e y) ∧ IsPathConnected s ∧ s ⊆ range e) (e ⁻¹' ·) :=\n    he.basis_nhds <| pathConnected_subset_basis he.isOpen_range (mem_range_self _)\n  .of_bases this fun x s ⟨_, hs, hse⟩ ↦ by\n    rwa [he.isPathConnected_iff, image_preimage_eq_of_subset hse]\n\n"}
{"name":"OpenEmbedding.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : LocPathConnectedSpace X\ne : Y → X\nhe : Topology.IsOpenEmbedding e\n⊢ LocPathConnectedSpace Y","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.locPathConnectedSpace := IsOpenEmbedding.locPathConnectedSpace\n\n"}
{"name":"IsOpen.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nU : Set X\nh : IsOpen U\n⊢ LocPathConnectedSpace ↑U","decl":"theorem IsOpen.locPathConnectedSpace {U : Set X} (h : IsOpen U) : LocPathConnectedSpace U :=\n  h.isOpenEmbedding_subtypeVal.locPathConnectedSpace\n\n"}
{"name":"locPathConnected_of_isOpen","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nU : Set X\nh : IsOpen U\n⊢ LocPathConnectedSpace ↑U","decl":"@[deprecated (since := \"2024-10-17\")]\nalias locPathConnected_of_isOpen := IsOpen.locPathConnectedSpace\n\n"}
{"name":"IsOpen.isConnected_iff_isPathConnected","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nU : Set X\nU_op : IsOpen U\n⊢ Iff (IsConnected U) (IsPathConnected U)","decl":"theorem IsOpen.isConnected_iff_isPathConnected {U : Set X} (U_op : IsOpen U) :\n    IsConnected U ↔ IsPathConnected U := by\n  rw [isConnected_iff_connectedSpace, isPathConnected_iff_pathConnectedSpace]\n  haveI := U_op.locPathConnectedSpace\n  exact pathConnectedSpace_iff_connectedSpace.symm\n\n"}
{"name":"instLocallyConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ LocallyConnectedSpace X","decl":"/-- Locally path-connected spaces are locally connected. -/\ninstance : LocallyConnectedSpace X := by\n  refine ⟨forall_imp (fun x h ↦ ⟨fun s ↦ ?_⟩) isOpen_isPathConnected_basis⟩\n  refine ⟨fun hs ↦ ?_, fun ⟨u, ⟨hu, hxu, _⟩, hus⟩ ↦ mem_nhds_iff.mpr ⟨u, hus, hu, hxu⟩⟩\n  let ⟨u, ⟨hu, hxu, hu'⟩, hus⟩ := (h.mem_iff' s).mp hs\n  exact ⟨u, ⟨hu, hxu, hu'.isConnected⟩, hus⟩\n\n"}
{"name":"locPathConnectedSpace_iff_isOpen_pathComponentIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\n⊢ Iff (LocPathConnectedSpace X) (∀ (x : X) (u : Set X), IsOpen u → IsOpen (pathComponentIn x u))","decl":"/-- A space is locally path-connected iff all path components of open subsets are open. -/\nlemma locPathConnectedSpace_iff_isOpen_pathComponentIn {X : Type*} [TopologicalSpace X] :\n    LocPathConnectedSpace X ↔ ∀ (x : X) (u : Set X), IsOpen u → IsOpen (pathComponentIn x u) :=\n  ⟨fun _ _ _ hu ↦ hu.pathComponentIn _, fun h ↦ ⟨fun x ↦ ⟨fun s ↦ by\n    refine ⟨fun hs ↦ ?_, fun ⟨_, ht⟩ ↦ Filter.mem_of_superset ht.1.1 ht.2⟩\n    let ⟨u, hu⟩ := mem_nhds_iff.mp hs\n    exact ⟨pathComponentIn x u, ⟨(h x u hu.2.1).mem_nhds (mem_pathComponentIn_self hu.2.2),\n      isPathConnected_pathComponentIn hu.2.2⟩, pathComponentIn_subset.trans hu.1⟩⟩⟩⟩\n\n"}
{"name":"locPathConnectedSpace_iff_pathComponentIn_mem_nhds","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\n⊢ Iff (LocPathConnectedSpace X) (∀ (x : X) (u : Set X), IsOpen u → Membership.mem u x → Membership.mem (nhds x) (pathComponentIn x u))","decl":"/-- A space is locally path-connected iff all path components of open subsets are neighbourhoods. -/\nlemma locPathConnectedSpace_iff_pathComponentIn_mem_nhds {X : Type*} [TopologicalSpace X] :\n    LocPathConnectedSpace X ↔\n    ∀ x : X, ∀ u : Set X, IsOpen u → x ∈ u → pathComponentIn x u ∈ nhds x := by\n  rw [locPathConnectedSpace_iff_isOpen_pathComponentIn]\n  simp_rw [forall_comm (β := Set X), ← imp_forall_iff]\n  refine forall_congr' fun u ↦ imp_congr_right fun _ ↦ ?_\n  exact ⟨fun h x hxu ↦ (h x).mem_nhds (mem_pathComponentIn_self hxu),\n    fun h x ↦ isOpen_iff_mem_nhds.mpr fun y hy ↦\n      pathComponentIn_congr hy ▸ h y <| pathComponentIn_subset hy⟩\n\n"}
{"name":"LocPathConnectedSpace.coinduced","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nY : Type u_4\nf : X → Y\n⊢ LocPathConnectedSpace Y","decl":"/-- Any topology coinduced by a locally path-connected topology is locally path-connected. -/\nlemma LocPathConnectedSpace.coinduced {Y : Type*} (f : X → Y) :\n    @LocPathConnectedSpace Y (.coinduced f ‹_›) := by\n  let _ := TopologicalSpace.coinduced f ‹_›; have hf : Continuous f := continuous_coinduced_rng\n  refine locPathConnectedSpace_iff_isOpen_pathComponentIn.mpr fun y u hu ↦\n    isOpen_coinduced.mpr <| isOpen_iff_mem_nhds.mpr fun x hx ↦ ?_\n  have hx' := preimage_mono pathComponentIn_subset hx\n  refine mem_nhds_iff.mpr ⟨pathComponentIn x (f ⁻¹' u), ?_,\n    (hu.preimage hf).pathComponentIn _, mem_pathComponentIn_self hx'⟩\n  rw [← image_subset_iff, ← pathComponentIn_congr hx]\n  exact ((isPathConnected_pathComponentIn hx').image hf).subset_pathComponentIn\n    ⟨x, mem_pathComponentIn_self hx', rfl⟩ <|\n    (image_mono pathComponentIn_subset).trans <| u.image_preimage_subset f\n\n"}
{"name":"Topology.IsQuotientMap.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : LocPathConnectedSpace X\nf : X → Y\nh : Topology.IsQuotientMap f\n⊢ LocPathConnectedSpace Y","decl":"/-- Quotients of locally path-connected spaces are locally path-connected. -/\nlemma Topology.IsQuotientMap.locPathConnectedSpace {f : X → Y} (h : IsQuotientMap f) :\n    LocPathConnectedSpace Y :=\n  h.2 ▸ LocPathConnectedSpace.coinduced f\n\n"}
{"name":"Quot.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\nr : X → X → Prop\n⊢ LocPathConnectedSpace (Quot r)","decl":"/-- Quotients of locally path-connected spaces are locally path-connected. -/\ninstance Quot.locPathConnectedSpace {r : X → X → Prop} : LocPathConnectedSpace (Quot r) :=\n  isQuotientMap_quot_mk.locPathConnectedSpace\n\n"}
{"name":"Quotient.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : LocPathConnectedSpace X\ns : Setoid X\n⊢ LocPathConnectedSpace (Quotient s)","decl":"/-- Quotients of locally path-connected spaces are locally path-connected. -/\ninstance Quotient.locPathConnectedSpace {s : Setoid X} : LocPathConnectedSpace (Quotient s) :=\n  isQuotientMap_quotient_mk'.locPathConnectedSpace\n\n\n"}
{"name":"Sum.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X Y : Type u\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : LocPathConnectedSpace X\ninst✝ : LocPathConnectedSpace Y\n⊢ LocPathConnectedSpace (Sum X Y)","decl":"/-- Disjoint unions of locally path-connected spaces are locally path-connected. -/\ninstance Sum.locPathConnectedSpace.{u} {X Y : Type u} [TopologicalSpace X] [TopologicalSpace Y]\n    [LocPathConnectedSpace X] [LocPathConnectedSpace Y] :\n    LocPathConnectedSpace (X ⊕ Y) := by\n  rw [locPathConnectedSpace_iff_pathComponentIn_mem_nhds]; intro x u hu hxu; rw [mem_nhds_iff]\n  obtain x | y := x\n  · refine ⟨Sum.inl '' (pathComponentIn x (Sum.inl ⁻¹' u)), ?_, ?_, ?_⟩\n    · apply IsPathConnected.subset_pathComponentIn\n      · exact (isPathConnected_pathComponentIn (by exact hxu)).image continuous_inl\n      · exact ⟨x, mem_pathComponentIn_self hxu, rfl⟩\n      · exact (image_mono pathComponentIn_subset).trans (u.image_preimage_subset _)\n    · exact isOpenMap_inl _ <| (hu.preimage continuous_inl).pathComponentIn _\n    · exact ⟨x, mem_pathComponentIn_self hxu, rfl⟩\n  · refine ⟨Sum.inr '' (pathComponentIn y (Sum.inr ⁻¹' u)), ?_, ?_, ?_⟩\n    · apply IsPathConnected.subset_pathComponentIn\n      · exact (isPathConnected_pathComponentIn (by exact hxu)).image continuous_inr\n      · exact ⟨y, mem_pathComponentIn_self hxu, rfl⟩\n      · exact (image_mono pathComponentIn_subset).trans (u.image_preimage_subset _)\n    · exact isOpenMap_inr _ <| (hu.preimage continuous_inr).pathComponentIn _\n    · exact ⟨y, mem_pathComponentIn_self hxu, rfl⟩\n\n\n"}
{"name":"Sigma.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"ι : Type u_3\nX : ι → Type u_4\ninst✝¹ : (i : ι) → TopologicalSpace (X i)\ninst✝ : ∀ (i : ι), LocPathConnectedSpace (X i)\n⊢ LocPathConnectedSpace (Sigma fun i => X i)","decl":"/-- Disjoint unions of locally path-connected spaces are locally path-connected. -/\ninstance Sigma.locPathConnectedSpace {X : ι → Type*}\n    [(i : ι) → TopologicalSpace (X i)] [(i : ι) → LocPathConnectedSpace (X i)] :\n    LocPathConnectedSpace ((i : ι) × X i) := by\n  rw [locPathConnectedSpace_iff_pathComponentIn_mem_nhds]; intro x u hu hxu; rw [mem_nhds_iff]\n  refine ⟨(Sigma.mk x.1) '' (pathComponentIn x.2 ((Sigma.mk x.1) ⁻¹' u)), ?_, ?_, ?_⟩\n  · apply IsPathConnected.subset_pathComponentIn\n    · exact (isPathConnected_pathComponentIn (by exact hxu)).image continuous_sigmaMk\n    · exact ⟨x.2, mem_pathComponentIn_self hxu, rfl⟩\n    · exact (image_mono pathComponentIn_subset).trans (u.image_preimage_subset _)\n  · exact isOpenMap_sigmaMk _ <| (hu.preimage continuous_sigmaMk).pathComponentIn _\n  · exact ⟨x.2, mem_pathComponentIn_self hxu, rfl⟩\n\n"}
