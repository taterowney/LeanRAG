{"name":"Path.mk.sizeOf_spec","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nx y : X\ninst‚úù : SizeOf X\ntoContinuousMap : ContinuousMap (‚ÜëunitInterval) X\nsource' : Eq (toContinuousMap.toFun 0) x\ntarget' : Eq (toContinuousMap.toFun 1) y\n‚ä¢ Eq (SizeOf.sizeOf { toContinuousMap := toContinuousMap, source' := source', target' := target' }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toContinuousMap)) (SizeOf.sizeOf source')) (SizeOf.sizeOf target'))","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.target'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nself : Path x y\n‚ä¢ Eq (self.toFun 1) y","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.source'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nself : Path x y\n‚ä¢ Eq (self.toFun 0) x","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.mk.injEq","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ntoContinuousMap‚úù : ContinuousMap (‚ÜëunitInterval) X\nsource'‚úù : Eq (toContinuousMap‚úù.toFun 0) x\ntarget'‚úù : Eq (toContinuousMap‚úù.toFun 1) y\ntoContinuousMap : ContinuousMap (‚ÜëunitInterval) X\nsource' : Eq (toContinuousMap.toFun 0) x\ntarget' : Eq (toContinuousMap.toFun 1) y\n‚ä¢ Eq (Eq { toContinuousMap := toContinuousMap‚úù, source' := source'‚úù, target' := target'‚úù } { toContinuousMap := toContinuousMap, source' := source', target' := target' }) (Eq toContinuousMap‚úù toContinuousMap)","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.mk.inj","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\ntoContinuousMap‚úù : ContinuousMap (‚ÜëunitInterval) X\nsource'‚úù : Eq (toContinuousMap‚úù.toFun 0) x\ntarget'‚úù : Eq (toContinuousMap‚úù.toFun 1) y\ntoContinuousMap : ContinuousMap (‚ÜëunitInterval) X\nsource' : Eq (toContinuousMap.toFun 0) x\ntarget' : Eq (toContinuousMap.toFun 1) y\nx‚úù : Eq { toContinuousMap := toContinuousMap‚úù, source' := source'‚úù, target' := target'‚úù } { toContinuousMap := toContinuousMap, source' := source', target' := target' }\n‚ä¢ Eq toContinuousMap‚úù toContinuousMap","decl":"/-- Continuous path connecting two points `x` and `y` in a topological space -/\nstructure Path (x y : X) extends C(I, X) where\n  /-- The start point of a `Path`. -/\n  source' : toFun 0 = x\n  /-- The end point of a `Path`. -/\n  target' : toFun 1 = y\n\n"}
{"name":"Path.continuousMapClass","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ ContinuousMapClass (Path x y) (‚ÜëunitInterval) X","decl":"instance Path.continuousMapClass : ContinuousMapClass (Path x y) I X where\n  map_continuous Œ≥ := show Continuous Œ≥.toContinuousMap by fun_prop\n\n"}
{"name":"Path.ext_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥‚ÇÅ Œ≥‚ÇÇ : Path x y\n‚ä¢ Iff (Eq Œ≥‚ÇÅ Œ≥‚ÇÇ) (Eq ‚áëŒ≥‚ÇÅ ‚áëŒ≥‚ÇÇ)","decl":"@[ext]\nprotected theorem Path.ext : ‚àÄ {Œ≥‚ÇÅ Œ≥‚ÇÇ : Path x y}, (Œ≥‚ÇÅ : I ‚Üí X) = Œ≥‚ÇÇ ‚Üí Œ≥‚ÇÅ = Œ≥‚ÇÇ := by\n  rintro ‚ü®‚ü®x, h11‚ü©, h12, h13‚ü© ‚ü®‚ü®x, h21‚ü©, h22, h23‚ü© rfl\n  rfl\n\n"}
{"name":"Path.ext","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥‚ÇÅ Œ≥‚ÇÇ : Path x y\na‚úù : Eq ‚áëŒ≥‚ÇÅ ‚áëŒ≥‚ÇÇ\n‚ä¢ Eq Œ≥‚ÇÅ Œ≥‚ÇÇ","decl":"@[ext]\nprotected theorem Path.ext : ‚àÄ {Œ≥‚ÇÅ Œ≥‚ÇÇ : Path x y}, (Œ≥‚ÇÅ : I ‚Üí X) = Œ≥‚ÇÇ ‚Üí Œ≥‚ÇÅ = Œ≥‚ÇÇ := by\n  rintro ‚ü®‚ü®x, h11‚ü©, h12, h13‚ü© ‚ü®‚ü®x, h21‚ü©, h22, h23‚ü© rfl\n  rfl\n\n"}
{"name":"Path.coe_mk_mk","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nf : ‚ÜëunitInterval ‚Üí X\nh‚ÇÅ : Continuous f\nh‚ÇÇ : Eq (f 0) x\nh‚ÇÉ : Eq (f 1) y\n‚ä¢ Eq (‚áë{ toFun := f, continuous_toFun := h‚ÇÅ, source' := h‚ÇÇ, target' := h‚ÇÉ }) f","decl":"@[simp]\ntheorem coe_mk_mk (f : I ‚Üí X) (h‚ÇÅ) (h‚ÇÇ : f 0 = x) (h‚ÇÉ : f 1 = y) :\n    ‚áë(mk ‚ü®f, h‚ÇÅ‚ü© h‚ÇÇ h‚ÇÉ : Path x y) = f :=\n  rfl\n-- Porting note: the name `Path.coe_mk` better refers to a new lemma below\n\n"}
{"name":"Path.continuous","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Continuous ‚áëŒ≥","decl":"@[continuity]\nprotected theorem continuous : Continuous Œ≥ :=\n  Œ≥.continuous_toFun\n\n"}
{"name":"Path.source","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Eq (Œ≥ 0) x","decl":"@[simp]\nprotected theorem source : Œ≥ 0 = x :=\n  Œ≥.source'\n\n"}
{"name":"Path.target","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Eq (Œ≥ 1) y","decl":"@[simp]\nprotected theorem target : Œ≥ 1 = y :=\n  Œ≥.target'\n\n"}
{"name":"Path.coe_toContinuousMap","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Eq ‚áëŒ≥.toContinuousMap ‚áëŒ≥","decl":"@[simp]\ntheorem coe_toContinuousMap : ‚áëŒ≥.toContinuousMap = Œ≥ :=\n  rfl\n\n-- Porting note: this is needed because of the `Path.continuousMapClass` instance\n"}
{"name":"Path.coe_mk","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Eq ‚áë‚ÜëŒ≥ ‚áëŒ≥","decl":"@[simp]\ntheorem coe_mk : ‚áë(Œ≥ : C(I, X)) = Œ≥ :=\n  rfl\n\n"}
{"name":"Path.refl_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n_t : ‚ÜëunitInterval\n‚ä¢ Eq ((Path.refl x) _t) x","decl":"/-- The constant path from a point to itself -/\n@[refl, simps]\ndef refl (x : X) : Path x x where\n  toFun _t := x\n  continuous_toFun := continuous_const\n  source' := rfl\n  target' := rfl\n\n"}
{"name":"Path.refl_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na : X\n‚ä¢ Eq (Set.range ‚áë(Path.refl a)) (Singleton.singleton a)","decl":"@[simp]\ntheorem refl_range {a : X} : range (Path.refl a) = {a} := by simp [Path.refl, CoeFun.coe]\n\n"}
{"name":"Path.symm_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\na‚úù : ‚ÜëunitInterval\n‚ä¢ Eq (Œ≥.symm a‚úù) (Function.comp (‚áëŒ≥) unitInterval.symm a‚úù)","decl":"/-- The reverse of a path from `x` to `y`, as a path from `y` to `x` -/\n@[symm, simps]\ndef symm (Œ≥ : Path x y) : Path y x where\n  toFun := Œ≥ ‚àò œÉ\n  continuous_toFun := by continuity\n  source' := by simpa [-Path.target] using Œ≥.target\n  target' := by simpa [-Path.source] using Œ≥.source\n\n"}
{"name":"Path.symm_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Eq Œ≥.symm.symm Œ≥","decl":"@[simp]\ntheorem symm_symm (Œ≥ : Path x y) : Œ≥.symm.symm = Œ≥ := by\n  ext t\n  show Œ≥ (œÉ (œÉ t)) = Œ≥ t\n  rw [unitInterval.symm_symm]\n\n"}
{"name":"Path.symm_bijective","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Function.Bijective Path.symm","decl":"theorem symm_bijective : Function.Bijective (Path.symm : Path x y ‚Üí Path y x) :=\n  Function.bijective_iff_has_inverse.mpr ‚ü®_, symm_symm, symm_symm‚ü©\n\n"}
{"name":"Path.refl_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na : X\n‚ä¢ Eq (Path.refl a).symm (Path.refl a)","decl":"@[simp]\ntheorem refl_symm {a : X} : (Path.refl a).symm = Path.refl a := by\n  ext\n  rfl\n\n"}
{"name":"Path.symm_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\n‚ä¢ Eq (Set.range ‚áëŒ≥.symm) (Set.range ‚áëŒ≥)","decl":"@[simp]\ntheorem symm_range {a b : X} (Œ≥ : Path a b) : range Œ≥.symm = range Œ≥ := by\n  ext x\n  simp only [mem_range, Path.symm, DFunLike.coe, unitInterval.symm, SetCoe.exists, comp_apply,\n    Subtype.coe_mk]\n  constructor <;> rintro ‚ü®y, hy, hxy‚ü© <;> refine ‚ü®1 - y, mem_iff_one_sub_mem.mp hy, ?_‚ü© <;>\n    convert hxy\n  simp\n\n"}
{"name":"Path.instContinuousEvalElemRealUnitInterval","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ ContinuousEval (Path x y) (‚ÜëunitInterval) X","decl":"instance : ContinuousEval (Path x y) I X := .of_continuous_forget continuous_induced_dom\n\n"}
{"name":"Path.continuous_eval","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"F : Type u_1\nX : outParam (Type u_2)\nY : outParam (Type u_3)\ninst‚úù¬≥ : FunLike F X Y\ninst‚úù¬≤ : TopologicalSpace F\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nself : ContinuousEval F X Y\n‚ä¢ Continuous fun fx => fx.1 fx.2","decl":"@[deprecated (since := \"2024-10-04\")] protected alias continuous_eval := continuous_eval\n\n"}
{"name":"Continuous.path_eval","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nx y : X\nY : Type u_4\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí Path x y\ng : Y ‚Üí ‚ÜëunitInterval\nhf : Continuous f\nhg : Continuous g\n‚ä¢ Continuous fun y_1 => (f y_1) (g y_1)","decl":"@[deprecated Continuous.eval (since := \"2024-10-04\")]\ntheorem _root_.Continuous.path_eval {Y} [TopologicalSpace Y] {f : Y ‚Üí Path x y} {g : Y ‚Üí I}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun y => f y (g y) := by\n  continuity\n\n"}
{"name":"Path.continuous_uncurry_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nx y : X\nY : Type u_4\ninst‚úù : TopologicalSpace Y\ng : Y ‚Üí Path x y\n‚ä¢ Iff (Continuous (Function.HasUncurry.uncurry g)) (Continuous g)","decl":"theorem continuous_uncurry_iff {Y} [TopologicalSpace Y] {g : Y ‚Üí Path x y} :\n    Continuous ‚Üøg ‚Üî Continuous g :=\n  Iff.symm <| continuous_induced_rng.trans\n    ‚ü®fun h => continuous_uncurry_of_continuous ‚ü®_, h‚ü©,\n    continuous_of_continuous_uncurry (fun (y : Y) ‚Ü¶ ContinuousMap.mk (g y))‚ü©\n\n"}
{"name":"Continuous.path_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nŒ≥ : Y ‚Üí Path x y\nf : Y ‚Üí Real\nhŒ≥ : Continuous (Function.HasUncurry.uncurry Œ≥)\nhf : Continuous f\n‚ä¢ Continuous fun t => (Œ≥ t).extend (f t)","decl":"/-- See Note [continuity lemma statement]. -/\ntheorem _root_.Continuous.path_extend {Œ≥ : Y ‚Üí Path x y} {f : Y ‚Üí ‚Ñù} (hŒ≥ : Continuous ‚ÜøŒ≥)\n    (hf : Continuous f) : Continuous fun t => (Œ≥ t).extend (f t) :=\n  Continuous.IccExtend hŒ≥ hf\n\n"}
{"name":"Path.continuous_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Continuous Œ≥.extend","decl":"/-- A useful special case of `Continuous.path_extend`. -/\n@[continuity, fun_prop]\ntheorem continuous_extend : Continuous Œ≥.extend :=\n  Œ≥.continuous.Icc_extend'\n\n"}
{"name":"Filter.Tendsto.path_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nl r : Y ‚Üí X\ny : Y\nl‚ÇÅ : Filter Real\nl‚ÇÇ : Filter X\nŒ≥ : (y : Y) ‚Üí Path (l y) (r y)\nhŒ≥ : Filter.Tendsto (Function.HasUncurry.uncurry Œ≥) (SProd.sprod (nhds y) (Filter.map (Set.projIcc 0 1 ‚ãØ) l‚ÇÅ)) l‚ÇÇ\n‚ä¢ Filter.Tendsto (Function.HasUncurry.uncurry fun x => (Œ≥ x).extend) (SProd.sprod (nhds y) l‚ÇÅ) l‚ÇÇ","decl":"theorem _root_.Filter.Tendsto.path_extend\n    {l r : Y ‚Üí X} {y : Y} {l‚ÇÅ : Filter ‚Ñù} {l‚ÇÇ : Filter X} {Œ≥ : ‚àÄ y, Path (l y) (r y)}\n    (hŒ≥ : Tendsto (‚ÜøŒ≥) (ùìù y √óÀ¢ l‚ÇÅ.map (projIcc 0 1 zero_le_one)) l‚ÇÇ) :\n    Tendsto (‚Üøfun x => (Œ≥ x).extend) (ùìù y √óÀ¢ l‚ÇÅ) l‚ÇÇ :=\n  Filter.Tendsto.IccExtend _ hŒ≥\n\n"}
{"name":"ContinuousAt.path_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ng : Y ‚Üí Real\nl r : Y ‚Üí X\nŒ≥ : (y : Y) ‚Üí Path (l y) (r y)\ny : Y\nhŒ≥ : ContinuousAt (Function.HasUncurry.uncurry Œ≥) { fst := y, snd := Set.projIcc 0 1 ‚ãØ (g y) }\nhg : ContinuousAt g y\n‚ä¢ ContinuousAt (fun i => (Œ≥ i).extend (g i)) y","decl":"theorem _root_.ContinuousAt.path_extend {g : Y ‚Üí ‚Ñù} {l r : Y ‚Üí X} (Œ≥ : ‚àÄ y, Path (l y) (r y))\n    {y : Y} (hŒ≥ : ContinuousAt (‚ÜøŒ≥) (y, projIcc 0 1 zero_le_one (g y))) (hg : ContinuousAt g y) :\n    ContinuousAt (fun i => (Œ≥ i).extend (g i)) y :=\n  hŒ≥.IccExtend (fun x => Œ≥ x) hg\n\n"}
{"name":"Path.extend_extends","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\nt : Real\nht : Membership.mem (Set.Icc 0 1) t\n‚ä¢ Eq (Œ≥.extend t) (Œ≥ ‚ü®t, ht‚ü©)","decl":"@[simp]\ntheorem extend_extends {a b : X} (Œ≥ : Path a b) {t : ‚Ñù}\n    (ht : t ‚àà (Icc 0 1 : Set ‚Ñù)) : Œ≥.extend t = Œ≥ ‚ü®t, ht‚ü© :=\n  IccExtend_of_mem _ Œ≥ ht\n\n"}
{"name":"Path.extend_zero","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Eq (Œ≥.extend 0) x","decl":"theorem extend_zero : Œ≥.extend 0 = x := by simp\n\n"}
{"name":"Path.extend_one","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Eq (Œ≥.extend 1) y","decl":"theorem extend_one : Œ≥.extend 1 = y := by simp\n\n"}
{"name":"Path.extend_extends'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\nt : ‚Üë(Set.Icc 0 1)\n‚ä¢ Eq (Œ≥.extend ‚Üët) (Œ≥ t)","decl":"theorem extend_extends' {a b : X} (Œ≥ : Path a b) (t : (Icc 0 1 : Set ‚Ñù)) : Œ≥.extend t = Œ≥ t :=\n  IccExtend_val _ Œ≥ t\n\n"}
{"name":"Path.extend_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\n‚ä¢ Eq (Set.range Œ≥.extend) (Set.range ‚áëŒ≥)","decl":"@[simp]\ntheorem extend_range {a b : X} (Œ≥ : Path a b) :\n    range Œ≥.extend = range Œ≥ :=\n  IccExtend_range _ Œ≥\n\n"}
{"name":"Path.extend_of_le_zero","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\nt : Real\nht : LE.le t 0\n‚ä¢ Eq (Œ≥.extend t) a","decl":"theorem extend_of_le_zero {a b : X} (Œ≥ : Path a b) {t : ‚Ñù}\n    (ht : t ‚â§ 0) : Œ≥.extend t = a :=\n  (IccExtend_of_le_left _ _ ht).trans Œ≥.source\n\n"}
{"name":"Path.extend_of_one_le","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\nt : Real\nht : LE.le 1 t\n‚ä¢ Eq (Œ≥.extend t) b","decl":"theorem extend_of_one_le {a b : X} (Œ≥ : Path a b) {t : ‚Ñù}\n    (ht : 1 ‚â§ t) : Œ≥.extend t = b :=\n  (IccExtend_of_right_le _ _ ht).trans Œ≥.target\n\n"}
{"name":"Path.refl_extend","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na : X\n‚ä¢ Eq (Path.refl a).extend fun x => a","decl":"@[simp]\ntheorem refl_extend {a : X} : (Path.refl a).extend = fun _ => a :=\n  rfl\n\n"}
{"name":"Path.ofLine_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nf : Real ‚Üí X\nhf : ContinuousOn f unitInterval\nh‚ÇÄ : Eq (f 0) x\nh‚ÇÅ : Eq (f 1) y\nt : ‚ÜëunitInterval\n‚ä¢ Membership.mem (Set.image f unitInterval) ((Path.ofLine hf h‚ÇÄ h‚ÇÅ) t)","decl":"theorem ofLine_mem {f : ‚Ñù ‚Üí X} (hf : ContinuousOn f I) (h‚ÇÄ : f 0 = x) (h‚ÇÅ : f 1 = y) :\n    ‚àÄ t, ofLine hf h‚ÇÄ h‚ÇÅ t ‚àà f '' I := fun ‚ü®t, t_in‚ü© => ‚ü®t, t_in, rfl‚ü©\n\n"}
{"name":"Path.trans_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y z : X\nŒ≥ : Path x y\nŒ≥' : Path y z\nt : ‚ÜëunitInterval\n‚ä¢ Eq ((Œ≥.trans Œ≥') t) (dite (LE.le (‚Üët) (1 / 2)) (fun h => Œ≥ ‚ü®HMul.hMul 2 ‚Üët, ‚ãØ‚ü©) fun h => Œ≥' ‚ü®HSub.hSub (HMul.hMul 2 ‚Üët) 1, ‚ãØ‚ü©)","decl":"theorem trans_apply (Œ≥ : Path x y) (Œ≥' : Path y z) (t : I) :\n    (Œ≥.trans Œ≥') t =\n      if h : (t : ‚Ñù) ‚â§ 1 / 2 then Œ≥ ‚ü®2 * t, (mul_pos_mem_iff zero_lt_two).2 ‚ü®t.2.1, h‚ü©‚ü©\n      else Œ≥' ‚ü®2 * t - 1, two_mul_sub_one_mem_iff.2 ‚ü®(not_le.1 h).le, t.2.2‚ü©‚ü© :=\n  show ite _ _ _ = _ by split_ifs <;> rw [extend_extends]\n\n"}
{"name":"Path.trans_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y z : X\nŒ≥ : Path x y\nŒ≥' : Path y z\n‚ä¢ Eq (Œ≥.trans Œ≥').symm (Œ≥'.symm.trans Œ≥.symm)","decl":"@[simp]\ntheorem trans_symm (Œ≥ : Path x y) (Œ≥' : Path y z) : (Œ≥.trans Œ≥').symm = Œ≥'.symm.trans Œ≥.symm := by\n  ext t\n  simp only [trans_apply, ‚Üê one_div, symm_apply, not_le, Function.comp_apply]\n  split_ifs with h h‚ÇÅ h‚ÇÇ <;> rw [coe_symm_eq] at h\n  ¬∑ have ht : (t : ‚Ñù) = 1 / 2 := by linarith\n    norm_num [ht]\n  ¬∑ refine congr_arg _ (Subtype.ext ?_)\n    norm_num [sub_sub_eq_add_sub, mul_sub]\n  ¬∑ refine congr_arg _ (Subtype.ext ?_)\n    norm_num [mul_sub, h]\n    ring -- TODO norm_num should really do this\n  ¬∑ exfalso\n    linarith\n\n"}
{"name":"Path.refl_trans_refl","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na : X\n‚ä¢ Eq ((Path.refl a).trans (Path.refl a)) (Path.refl a)","decl":"@[simp]\ntheorem refl_trans_refl {a : X} :\n    (Path.refl a).trans (Path.refl a) = Path.refl a := by\n  ext\n  simp only [Path.trans, ite_self, one_div, Path.refl_extend]\n  rfl\n\n"}
{"name":"Path.trans_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b c : X\nŒ≥‚ÇÅ : Path a b\nŒ≥‚ÇÇ : Path b c\n‚ä¢ Eq (Set.range ‚áë(Œ≥‚ÇÅ.trans Œ≥‚ÇÇ)) (Union.union (Set.range ‚áëŒ≥‚ÇÅ) (Set.range ‚áëŒ≥‚ÇÇ))","decl":"theorem trans_range {a b c : X} (Œ≥‚ÇÅ : Path a b) (Œ≥‚ÇÇ : Path b c) :\n    range (Œ≥‚ÇÅ.trans Œ≥‚ÇÇ) = range Œ≥‚ÇÅ ‚à™ range Œ≥‚ÇÇ := by\n  rw [Path.trans]\n  apply eq_of_subset_of_subset\n  ¬∑ rintro x ‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü©\n    by_cases h : t ‚â§ 1 / 2\n    ¬∑ left\n      use ‚ü®2 * t, ‚ü®by linarith, by linarith‚ü©‚ü©\n      rw [‚Üê Œ≥‚ÇÅ.extend_extends]\n      rwa [coe_mk_mk, Function.comp_apply, if_pos h] at hxt\n    ¬∑ right\n      use ‚ü®2 * t - 1, ‚ü®by linarith, by linarith‚ü©‚ü©\n      rw [‚Üê Œ≥‚ÇÇ.extend_extends]\n      rwa [coe_mk_mk, Function.comp_apply, if_neg h] at hxt\n  ¬∑ rintro x (‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü© | ‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü©)\n    ¬∑ use ‚ü®t / 2, ‚ü®by linarith, by linarith‚ü©‚ü©\n      have : t / 2 ‚â§ 1 / 2 := (div_le_div_iff_of_pos_right (zero_lt_two : (0 : ‚Ñù) < 2)).mpr ht1\n      rw [coe_mk_mk, Function.comp_apply, if_pos this, Subtype.coe_mk]\n      ring_nf\n      rwa [Œ≥‚ÇÅ.extend_extends]\n    ¬∑ by_cases h : t = 0\n      ¬∑ use ‚ü®1 / 2, ‚ü®by linarith, by linarith‚ü©‚ü©\n        rw [coe_mk_mk, Function.comp_apply, if_pos le_rfl, Subtype.coe_mk,\n          mul_one_div_cancel (two_ne_zero' ‚Ñù)]\n        rw [Œ≥‚ÇÅ.extend_one]\n        rwa [‚Üê Œ≥‚ÇÇ.extend_extends, h, Œ≥‚ÇÇ.extend_zero] at hxt\n      ¬∑ use ‚ü®(t + 1) / 2, ‚ü®by linarith, by linarith‚ü©‚ü©\n        replace h : t ‚â† 0 := h\n        have ht0 := lt_of_le_of_ne ht0 h.symm\n        have : ¬¨(t + 1) / 2 ‚â§ 1 / 2 := by\n          rw [not_le]\n          linarith\n        rw [coe_mk_mk, Function.comp_apply, Subtype.coe_mk, if_neg this]\n        ring_nf\n        rwa [Œ≥‚ÇÇ.extend_extends]\n\n"}
{"name":"Path.map_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nŒ≥ : Path x y\nf : X ‚Üí Y\nh : Continuous f\n‚ä¢ Eq (‚áë(Œ≥.map h)) (Function.comp f ‚áëŒ≥)","decl":"@[simp]\ntheorem map_coe (Œ≥ : Path x y) {f : X ‚Üí Y} (h : Continuous f) :\n    (Œ≥.map h : I ‚Üí Y) = f ‚àò Œ≥ := by\n  ext t\n  rfl\n\n"}
{"name":"Path.map_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nŒ≥ : Path x y\nf : X ‚Üí Y\nh : Continuous f\n‚ä¢ Eq (Œ≥.map h).symm (Œ≥.symm.map h)","decl":"@[simp]\ntheorem map_symm (Œ≥ : Path x y) {f : X ‚Üí Y} (h : Continuous f) :\n    (Œ≥.map h).symm = Œ≥.symm.map h :=\n  rfl\n\n"}
{"name":"Path.map_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y z : X\nŒ≥ : Path x y\nŒ≥' : Path y z\nf : X ‚Üí Y\nh : Continuous f\n‚ä¢ Eq ((Œ≥.trans Œ≥').map h) ((Œ≥.map h).trans (Œ≥'.map h))","decl":"@[simp]\ntheorem map_trans (Œ≥ : Path x y) (Œ≥' : Path y z) {f : X ‚Üí Y}\n    (h : Continuous f) : (Œ≥.trans Œ≥').map h = (Œ≥.map h).trans (Œ≥'.map h) := by\n  ext t\n  rw [trans_apply, map_coe, Function.comp_apply, trans_apply]\n  split_ifs <;> rfl\n\n"}
{"name":"Path.map_id","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Eq (Œ≥.map ‚ãØ) Œ≥","decl":"@[simp]\ntheorem map_id (Œ≥ : Path x y) : Œ≥.map continuous_id = Œ≥ := by\n  ext\n  rfl\n\n"}
{"name":"Path.map_map","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\nx y : X\nŒ≥ : Path x y\nZ : Type u_4\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y\nhf : Continuous f\ng : Y ‚Üí Z\nhg : Continuous g\n‚ä¢ Eq ((Œ≥.map hf).map hg) (Œ≥.map ‚ãØ)","decl":"@[simp]\ntheorem map_map (Œ≥ : Path x y) {Z : Type*} [TopologicalSpace Z]\n    {f : X ‚Üí Y} (hf : Continuous f) {g : Y ‚Üí Z} (hg : Continuous g) :\n    (Œ≥.map hf).map hg = Œ≥.map (hg.comp hf) := by\n  ext\n  rfl\n\n"}
{"name":"Path.symm_cast","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : X\nŒ≥ : Path a‚ÇÇ b‚ÇÇ\nha : Eq a‚ÇÅ a‚ÇÇ\nhb : Eq b‚ÇÅ b‚ÇÇ\n‚ä¢ Eq (Œ≥.cast ha hb).symm (Œ≥.symm.cast hb ha)","decl":"@[simp]\ntheorem symm_cast {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : X} (Œ≥ : Path a‚ÇÇ b‚ÇÇ) (ha : a‚ÇÅ = a‚ÇÇ) (hb : b‚ÇÅ = b‚ÇÇ) :\n    (Œ≥.cast ha hb).symm = Œ≥.symm.cast hb ha :=\n  rfl\n\n"}
{"name":"Path.trans_cast","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ c‚ÇÅ c‚ÇÇ : X\nŒ≥ : Path a‚ÇÇ b‚ÇÇ\nŒ≥' : Path b‚ÇÇ c‚ÇÇ\nha : Eq a‚ÇÅ a‚ÇÇ\nhb : Eq b‚ÇÅ b‚ÇÇ\nhc : Eq c‚ÇÅ c‚ÇÇ\n‚ä¢ Eq ((Œ≥.cast ha hb).trans (Œ≥'.cast hb hc)) ((Œ≥.trans Œ≥').cast ha hc)","decl":"@[simp]\ntheorem trans_cast {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ c‚ÇÅ c‚ÇÇ : X} (Œ≥ : Path a‚ÇÇ b‚ÇÇ)\n    (Œ≥' : Path b‚ÇÇ c‚ÇÇ) (ha : a‚ÇÅ = a‚ÇÇ) (hb : b‚ÇÅ = b‚ÇÇ) (hc : c‚ÇÅ = c‚ÇÇ) :\n    (Œ≥.cast ha hb).trans (Œ≥'.cast hb hc) = (Œ≥.trans Œ≥').cast ha hc :=\n  rfl\n\n"}
{"name":"Path.cast_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\nx' y' : X\nhx : Eq x' x\nhy : Eq y' y\n‚ä¢ Eq ‚áë(Œ≥.cast hx hy) ‚áëŒ≥","decl":"@[simp]\ntheorem cast_coe (Œ≥ : Path x y) {x' y'} (hx : x' = x) (hy : y' = y) : (Œ≥.cast hx hy : I ‚Üí X) = Œ≥ :=\n  rfl\n\n"}
{"name":"Path.symm_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nŒπ : Type u_4\ninst‚úù : TopologicalSpace Œπ\na b : Œπ ‚Üí X\nŒ≥ : (t : Œπ) ‚Üí Path (a t) (b t)\nh : Continuous (Function.HasUncurry.uncurry Œ≥)\n‚ä¢ Continuous (Function.HasUncurry.uncurry fun t => (Œ≥ t).symm)","decl":"@[continuity, fun_prop]\ntheorem symm_continuous_family {Œπ : Type*} [TopologicalSpace Œπ]\n    {a b : Œπ ‚Üí X} (Œ≥ : ‚àÄ t : Œπ, Path (a t) (b t)) (h : Continuous ‚ÜøŒ≥) :\n    Continuous ‚Üøfun t => (Œ≥ t).symm :=\n  h.comp (continuous_id.prodMap continuous_symm)\n\n"}
{"name":"Path.continuous_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Continuous Path.symm","decl":"@[continuity]\ntheorem continuous_symm : Continuous (symm : Path x y ‚Üí Path y x) :=\n  continuous_uncurry_iff.mp <| symm_continuous_family _ (continuous_fst.eval continuous_snd)\n\n"}
{"name":"Path.continuous_uncurry_extend_of_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nŒπ : Type u_4\ninst‚úù : TopologicalSpace Œπ\na b : Œπ ‚Üí X\nŒ≥ : (t : Œπ) ‚Üí Path (a t) (b t)\nh : Continuous (Function.HasUncurry.uncurry Œ≥)\n‚ä¢ Continuous (Function.HasUncurry.uncurry fun t => (Œ≥ t).extend)","decl":"@[continuity]\ntheorem continuous_uncurry_extend_of_continuous_family {Œπ : Type*} [TopologicalSpace Œπ]\n    {a b : Œπ ‚Üí X} (Œ≥ : ‚àÄ t : Œπ, Path (a t) (b t)) (h : Continuous ‚ÜøŒ≥) :\n    Continuous ‚Üøfun t => (Œ≥ t).extend := by\n  apply h.comp (continuous_id.prodMap continuous_projIcc)\n  exact zero_le_one\n\n"}
{"name":"Path.trans_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nŒπ : Type u_4\ninst‚úù : TopologicalSpace Œπ\na b c : Œπ ‚Üí X\nŒ≥‚ÇÅ : (t : Œπ) ‚Üí Path (a t) (b t)\nh‚ÇÅ : Continuous (Function.HasUncurry.uncurry Œ≥‚ÇÅ)\nŒ≥‚ÇÇ : (t : Œπ) ‚Üí Path (b t) (c t)\nh‚ÇÇ : Continuous (Function.HasUncurry.uncurry Œ≥‚ÇÇ)\n‚ä¢ Continuous (Function.HasUncurry.uncurry fun t => (Œ≥‚ÇÅ t).trans (Œ≥‚ÇÇ t))","decl":"@[continuity]\ntheorem trans_continuous_family {Œπ : Type*} [TopologicalSpace Œπ]\n    {a b c : Œπ ‚Üí X} (Œ≥‚ÇÅ : ‚àÄ t : Œπ, Path (a t) (b t)) (h‚ÇÅ : Continuous ‚ÜøŒ≥‚ÇÅ)\n    (Œ≥‚ÇÇ : ‚àÄ t : Œπ, Path (b t) (c t)) (h‚ÇÇ : Continuous ‚ÜøŒ≥‚ÇÇ) :\n    Continuous ‚Üøfun t => (Œ≥‚ÇÅ t).trans (Œ≥‚ÇÇ t) := by\n  have h‚ÇÅ' := Path.continuous_uncurry_extend_of_continuous_family Œ≥‚ÇÅ h‚ÇÅ\n  have h‚ÇÇ' := Path.continuous_uncurry_extend_of_continuous_family Œ≥‚ÇÇ h‚ÇÇ\n  simp only [HasUncurry.uncurry, CoeFun.coe, Path.trans, (¬∑ ‚àò ¬∑)]\n  refine Continuous.if_le ?_ ?_ (continuous_subtype_val.comp continuous_snd) continuous_const ?_\n  ¬∑ change\n      Continuous ((fun p : Œπ √ó ‚Ñù => (Œ≥‚ÇÅ p.1).extend p.2) ‚àò Prod.map id (fun x => 2 * x : I ‚Üí ‚Ñù))\n    exact h‚ÇÅ'.comp (continuous_id.prodMap <| continuous_const.mul continuous_subtype_val)\n  ¬∑ change\n      Continuous ((fun p : Œπ √ó ‚Ñù => (Œ≥‚ÇÇ p.1).extend p.2) ‚àò Prod.map id (fun x => 2 * x - 1 : I ‚Üí ‚Ñù))\n    exact\n      h‚ÇÇ'.comp\n        (continuous_id.prodMap <|\n          (continuous_const.mul continuous_subtype_val).sub continuous_const)\n  ¬∑ rintro st hst\n    simp [hst, mul_inv_cancel‚ÇÄ (two_ne_zero' ‚Ñù)]\n\n"}
{"name":"Continuous.path_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y z : X\nf : Y ‚Üí Path x y\ng : Y ‚Üí Path y z\na‚úù¬π : Continuous f\na‚úù : Continuous g\n‚ä¢ Continuous fun t => (f t).trans (g t)","decl":"@[continuity]\ntheorem _root_.Continuous.path_trans {f : Y ‚Üí Path x y} {g : Y ‚Üí Path y z} :\n    Continuous f ‚Üí Continuous g ‚Üí Continuous fun t => (f t).trans (g t) := by\n  intro hf hg\n  apply continuous_uncurry_iff.mp\n  exact trans_continuous_family _ (continuous_uncurry_iff.mpr hf) _ (continuous_uncurry_iff.mpr hg)\n\n"}
{"name":"Path.continuous_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y z : X\n‚ä¢ Continuous fun œÅ => œÅ.1.trans œÅ.2","decl":"@[continuity]\ntheorem continuous_trans {x y z : X} : Continuous fun œÅ : Path x y √ó Path y z => œÅ.1.trans œÅ.2 :=\n  continuous_fst.path_trans continuous_snd\n\n"}
{"name":"Path.prod_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\na‚ÇÅ a‚ÇÇ : X\nb‚ÇÅ b‚ÇÇ : Y\nŒ≥‚ÇÅ : Path a‚ÇÅ a‚ÇÇ\nŒ≥‚ÇÇ : Path b‚ÇÅ b‚ÇÇ\n‚ä¢ Eq ‚áë(Œ≥‚ÇÅ.prod Œ≥‚ÇÇ) fun t => { fst := Œ≥‚ÇÅ t, snd := Œ≥‚ÇÇ t }","decl":"@[simp]\ntheorem prod_coe (Œ≥‚ÇÅ : Path a‚ÇÅ a‚ÇÇ) (Œ≥‚ÇÇ : Path b‚ÇÅ b‚ÇÇ) :\n    ‚áë(Œ≥‚ÇÅ.prod Œ≥‚ÇÇ) = fun t => (Œ≥‚ÇÅ t, Œ≥‚ÇÇ t) :=\n  rfl\n\n"}
{"name":"Path.trans_prod_eq_prod_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\na‚ÇÅ a‚ÇÇ a‚ÇÉ : X\nb‚ÇÅ b‚ÇÇ b‚ÇÉ : Y\nŒ≥‚ÇÅ : Path a‚ÇÅ a‚ÇÇ\nŒ¥‚ÇÅ : Path a‚ÇÇ a‚ÇÉ\nŒ≥‚ÇÇ : Path b‚ÇÅ b‚ÇÇ\nŒ¥‚ÇÇ : Path b‚ÇÇ b‚ÇÉ\n‚ä¢ Eq ((Œ≥‚ÇÅ.prod Œ≥‚ÇÇ).trans (Œ¥‚ÇÅ.prod Œ¥‚ÇÇ)) ((Œ≥‚ÇÅ.trans Œ¥‚ÇÅ).prod (Œ≥‚ÇÇ.trans Œ¥‚ÇÇ))","decl":"/-- Path composition commutes with products -/\ntheorem trans_prod_eq_prod_trans (Œ≥‚ÇÅ : Path a‚ÇÅ a‚ÇÇ) (Œ¥‚ÇÅ : Path a‚ÇÇ a‚ÇÉ) (Œ≥‚ÇÇ : Path b‚ÇÅ b‚ÇÇ)\n    (Œ¥‚ÇÇ : Path b‚ÇÇ b‚ÇÉ) : (Œ≥‚ÇÅ.prod Œ≥‚ÇÇ).trans (Œ¥‚ÇÅ.prod Œ¥‚ÇÇ) = (Œ≥‚ÇÅ.trans Œ¥‚ÇÅ).prod (Œ≥‚ÇÇ.trans Œ¥‚ÇÇ) := by\n  ext t <;>\n  unfold Path.trans <;>\n  simp only [Path.coe_mk_mk, Path.prod_coe, Function.comp_apply] <;>\n  split_ifs <;>\n  rfl\n\n"}
{"name":"Path.pi_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"Œπ : Type u_3\nœá : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (œá i)\nas bs : (i : Œπ) ‚Üí œá i\nŒ≥ : (i : Œπ) ‚Üí Path (as i) (bs i)\n‚ä¢ Eq ‚áë(Path.pi Œ≥) fun t i => (Œ≥ i) t","decl":"@[simp]\ntheorem pi_coe (Œ≥ : ‚àÄ i, Path (as i) (bs i)) : ‚áë(Path.pi Œ≥) = fun t i => Œ≥ i t :=\n  rfl\n\n"}
{"name":"Path.trans_pi_eq_pi_trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"Œπ : Type u_3\nœá : Œπ ‚Üí Type u_4\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (œá i)\nas bs cs : (i : Œπ) ‚Üí œá i\nŒ≥‚ÇÄ : (i : Œπ) ‚Üí Path (as i) (bs i)\nŒ≥‚ÇÅ : (i : Œπ) ‚Üí Path (bs i) (cs i)\n‚ä¢ Eq ((Path.pi Œ≥‚ÇÄ).trans (Path.pi Œ≥‚ÇÅ)) (Path.pi fun i => (Œ≥‚ÇÄ i).trans (Œ≥‚ÇÅ i))","decl":"/-- Path composition commutes with products -/\ntheorem trans_pi_eq_pi_trans (Œ≥‚ÇÄ : ‚àÄ i, Path (as i) (bs i)) (Œ≥‚ÇÅ : ‚àÄ i, Path (bs i) (cs i)) :\n    (Path.pi Œ≥‚ÇÄ).trans (Path.pi Œ≥‚ÇÅ) = Path.pi fun i => (Œ≥‚ÇÄ i).trans (Œ≥‚ÇÅ i) := by\n  ext t i\n  unfold Path.trans\n  simp only [Path.coe_mk_mk, Function.comp_apply, pi_coe]\n  split_ifs <;> rfl\n\n"}
{"name":"Path.add_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Add X\ninst‚úù : ContinuousAdd X\na‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : X\nŒ≥‚ÇÅ : Path a‚ÇÅ b‚ÇÅ\nŒ≥‚ÇÇ : Path a‚ÇÇ b‚ÇÇ\nt : ‚ÜëunitInterval\n‚ä¢ Eq ((Œ≥‚ÇÅ.add Œ≥‚ÇÇ) t) (HAdd.hAdd (Œ≥‚ÇÅ t) (Œ≥‚ÇÇ t))","decl":"@[to_additive]\nprotected theorem mul_apply [Mul X] [ContinuousMul X] {a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : X} (Œ≥‚ÇÅ : Path a‚ÇÅ b‚ÇÅ)\n    (Œ≥‚ÇÇ : Path a‚ÇÇ b‚ÇÇ) (t : unitInterval) : (Œ≥‚ÇÅ.mul Œ≥‚ÇÇ) t = Œ≥‚ÇÅ t * Œ≥‚ÇÇ t :=\n  rfl\n\n"}
{"name":"Path.mul_apply","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : Mul X\ninst‚úù : ContinuousMul X\na‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : X\nŒ≥‚ÇÅ : Path a‚ÇÅ b‚ÇÅ\nŒ≥‚ÇÇ : Path a‚ÇÇ b‚ÇÇ\nt : ‚ÜëunitInterval\n‚ä¢ Eq ((Œ≥‚ÇÅ.mul Œ≥‚ÇÇ) t) (HMul.hMul (Œ≥‚ÇÅ t) (Œ≥‚ÇÇ t))","decl":"@[to_additive]\nprotected theorem mul_apply [Mul X] [ContinuousMul X] {a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : X} (Œ≥‚ÇÅ : Path a‚ÇÅ b‚ÇÅ)\n    (Œ≥‚ÇÇ : Path a‚ÇÇ b‚ÇÇ) (t : unitInterval) : (Œ≥‚ÇÅ.mul Œ≥‚ÇÇ) t = Œ≥‚ÇÅ t * Œ≥‚ÇÇ t :=\n  rfl\n\n"}
{"name":"Path.truncate_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\nt‚ÇÄ t‚ÇÅ : Real\n‚ä¢ HasSubset.Subset (Set.range ‚áë(Œ≥.truncate t‚ÇÄ t‚ÇÅ)) (Set.range ‚áëŒ≥)","decl":"theorem truncate_range {a b : X} (Œ≥ : Path a b) {t‚ÇÄ t‚ÇÅ : ‚Ñù} :\n    range (Œ≥.truncate t‚ÇÄ t‚ÇÅ) ‚äÜ range Œ≥ := by\n  rw [‚Üê Œ≥.extend_range]\n  simp only [range_subset_iff, SetCoe.exists, SetCoe.forall]\n  intro x _hx\n  simp only [DFunLike.coe, Path.truncate, mem_range_self]\n\n"}
{"name":"Path.truncate_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\n‚ä¢ Continuous fun x => (Œ≥.truncate x.1 x.2.1) x.2.2","decl":"/-- For a path `Œ≥`, `Œ≥.truncate` gives a \"continuous family of paths\", by which we\n  mean the uncurried function which maps `(t‚ÇÄ, t‚ÇÅ, s)` to `Œ≥.truncate t‚ÇÄ t‚ÇÅ s` is continuous. -/\n@[continuity]\ntheorem truncate_continuous_family {a b : X} (Œ≥ : Path a b) :\n    Continuous (fun x => Œ≥.truncate x.1 x.2.1 x.2.2 : ‚Ñù √ó ‚Ñù √ó I ‚Üí X) :=\n  Œ≥.continuous_extend.comp\n    (((continuous_subtype_val.comp (continuous_snd.comp continuous_snd)).max continuous_fst).min\n      (continuous_fst.comp continuous_snd))\n\n"}
{"name":"Path.truncate_const_continuous_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\nt : Real\n‚ä¢ Continuous (Function.HasUncurry.uncurry (Œ≥.truncate t))","decl":"@[continuity]\ntheorem truncate_const_continuous_family {a b : X} (Œ≥ : Path a b)\n    (t : ‚Ñù) : Continuous ‚Üø(Œ≥.truncate t) := by\n  have key : Continuous (fun x => (t, x) : ‚Ñù √ó I ‚Üí ‚Ñù √ó ‚Ñù √ó I) := by fun_prop\n  exact Œ≥.truncate_continuous_family.comp key\n\n"}
{"name":"Path.truncate_self","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\nt : Real\n‚ä¢ Eq (Œ≥.truncate t t) ((Path.refl (Œ≥.extend t)).cast ‚ãØ ‚ãØ)","decl":"@[simp]\ntheorem truncate_self {a b : X} (Œ≥ : Path a b) (t : ‚Ñù) :\n    Œ≥.truncate t t = (Path.refl <| Œ≥.extend t).cast (by rw [min_self]) rfl := by\n  ext x\n  rw [cast_coe]\n  simp only [truncate, DFunLike.coe, refl, min_def, max_def]\n  split_ifs with h‚ÇÅ h‚ÇÇ <;> congr\n\n"}
{"name":"Path.truncate_zero_zero","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\n‚ä¢ Eq (Œ≥.truncate 0 0) ((Path.refl a).cast ‚ãØ ‚ãØ)","decl":"@[simp 1001] -- Porting note: increase `simp` priority so left-hand side doesn't simplify\ntheorem truncate_zero_zero {a b : X} (Œ≥ : Path a b) :\n    Œ≥.truncate 0 0 = (Path.refl a).cast (by rw [min_self, Œ≥.extend_zero]) Œ≥.extend_zero := by\n  convert Œ≥.truncate_self 0\n\n"}
{"name":"Path.truncate_one_one","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\n‚ä¢ Eq (Œ≥.truncate 1 1) ((Path.refl b).cast ‚ãØ ‚ãØ)","decl":"@[simp 1001] -- Porting note: increase `simp` priority so left-hand side doesn't simplify\ntheorem truncate_one_one {a b : X} (Œ≥ : Path a b) :\n    Œ≥.truncate 1 1 = (Path.refl b).cast (by rw [min_self, Œ≥.extend_one]) Œ≥.extend_one := by\n  convert Œ≥.truncate_self 1\n\n"}
{"name":"Path.truncate_zero_one","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\na b : X\nŒ≥ : Path a b\n‚ä¢ Eq (Œ≥.truncate 0 1) (Œ≥.cast ‚ãØ ‚ãØ)","decl":"@[simp]\ntheorem truncate_zero_one {a b : X} (Œ≥ : Path a b) :\n    Œ≥.truncate 0 1 = Œ≥.cast (by simp [zero_le_one, extend_zero]) (by simp) := by\n  ext x\n  rw [cast_coe]\n  have : ‚Üëx ‚àà (Icc 0 1 : Set ‚Ñù) := x.2\n  rw [truncate, coe_mk_mk, max_eq_left this.1, min_eq_left this.2, extend_extends']\n\n"}
{"name":"Path.coe_reparam","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\nf : ‚ÜëunitInterval ‚Üí ‚ÜëunitInterval\nhfcont : Continuous f\nhf‚ÇÄ : Eq (f 0) 0\nhf‚ÇÅ : Eq (f 1) 1\n‚ä¢ Eq (‚áë(Œ≥.reparam f hfcont hf‚ÇÄ hf‚ÇÅ)) (Function.comp (‚áëŒ≥) f)","decl":"@[simp]\ntheorem coe_reparam (Œ≥ : Path x y) {f : I ‚Üí I} (hfcont : Continuous f) (hf‚ÇÄ : f 0 = 0)\n    (hf‚ÇÅ : f 1 = 1) : ‚áë(Œ≥.reparam f hfcont hf‚ÇÄ hf‚ÇÅ) = Œ≥ ‚àò f :=\n  rfl\n-- Porting note: this seems like it was poorly named (was: `coe_to_fun`)\n\n"}
{"name":"Path.reparam_id","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\n‚ä¢ Eq (Œ≥.reparam id ‚ãØ ‚ãØ ‚ãØ) Œ≥","decl":"@[simp]\ntheorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ := by\n  ext\n  rfl\n\n"}
{"name":"Path.range_reparam","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nŒ≥ : Path x y\nf : ‚ÜëunitInterval ‚Üí ‚ÜëunitInterval\nhfcont : Continuous f\nhf‚ÇÄ : Eq (f 0) 0\nhf‚ÇÅ : Eq (f 1) 1\n‚ä¢ Eq (Set.range ‚áë(Œ≥.reparam f hfcont hf‚ÇÄ hf‚ÇÅ)) (Set.range ‚áëŒ≥)","decl":"theorem range_reparam (Œ≥ : Path x y) {f : I ‚Üí I} (hfcont : Continuous f) (hf‚ÇÄ : f 0 = 0)\n    (hf‚ÇÅ : f 1 = 1) : range (Œ≥.reparam f hfcont hf‚ÇÄ hf‚ÇÅ) = range Œ≥ := by\n  change range (Œ≥ ‚àò f) = range Œ≥\n  have : range f = univ := by\n    rw [range_eq_univ]\n    intro t\n    have h‚ÇÅ : Continuous (Set.IccExtend (zero_le_one' ‚Ñù) f) := by continuity\n    have := intermediate_value_Icc (zero_le_one' ‚Ñù) h‚ÇÅ.continuousOn\n    ¬∑ rw [IccExtend_left, IccExtend_right, Icc.mk_zero, Icc.mk_one, hf‚ÇÄ, hf‚ÇÅ] at this\n      rcases this t.2 with ‚ü®w, hw‚ÇÅ, hw‚ÇÇ‚ü©\n      rw [IccExtend_of_mem _ _ hw‚ÇÅ] at hw‚ÇÇ\n      exact ‚ü®_, hw‚ÇÇ‚ü©\n  rw [range_comp, this, image_univ]\n\n"}
{"name":"Path.refl_reparam","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\nf : ‚ÜëunitInterval ‚Üí ‚ÜëunitInterval\nhfcont : Continuous f\nhf‚ÇÄ : Eq (f 0) 0\nhf‚ÇÅ : Eq (f 1) 1\n‚ä¢ Eq ((Path.refl x).reparam f hfcont hf‚ÇÄ hf‚ÇÅ) (Path.refl x)","decl":"theorem refl_reparam {f : I ‚Üí I} (hfcont : Continuous f) (hf‚ÇÄ : f 0 = 0) (hf‚ÇÅ : f 1 = 1) :\n    (refl x).reparam f hfcont hf‚ÇÄ hf‚ÇÅ = refl x := by\n  ext\n  simp\n\n"}
{"name":"Joined.refl","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Joined x x","decl":"@[refl]\ntheorem Joined.refl (x : X) : Joined x x :=\n  ‚ü®Path.refl x‚ü©\n\n"}
{"name":"Joined.symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nh : Joined x y\n‚ä¢ Joined y x","decl":"@[symm]\ntheorem Joined.symm {x y : X} (h : Joined x y) : Joined y x :=\n  ‚ü®h.somePath.symm‚ü©\n\n"}
{"name":"Joined.trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y z : X\nhxy : Joined x y\nhyz : Joined y z\n‚ä¢ Joined x z","decl":"@[trans]\ntheorem Joined.trans {x y z : X} (hxy : Joined x y) (hyz : Joined y z) : Joined x z :=\n  ‚ü®hxy.somePath.trans hyz.somePath‚ü©\n\n"}
{"name":"JoinedIn.mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n‚ä¢ And (Membership.mem F x) (Membership.mem F y)","decl":"theorem JoinedIn.mem (h : JoinedIn F x y) : x ‚àà F ‚àß y ‚àà F := by\n  rcases h with ‚ü®Œ≥, Œ≥_in‚ü©\n  have : Œ≥ 0 ‚àà F ‚àß Œ≥ 1 ‚àà F := by constructor <;> apply Œ≥_in\n  simpa using this\n\n"}
{"name":"JoinedIn.source_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n‚ä¢ Membership.mem F x","decl":"theorem JoinedIn.source_mem (h : JoinedIn F x y) : x ‚àà F :=\n  h.mem.1\n\n"}
{"name":"JoinedIn.target_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n‚ä¢ Membership.mem F y","decl":"theorem JoinedIn.target_mem (h : JoinedIn F x y) : y ‚àà F :=\n  h.mem.2\n\n"}
{"name":"JoinedIn.somePath_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\nt : ‚ÜëunitInterval\n‚ä¢ Membership.mem F (h.somePath t)","decl":"theorem JoinedIn.somePath_mem (h : JoinedIn F x y) (t : I) : h.somePath t ‚àà F :=\n  Classical.choose_spec h t\n\n"}
{"name":"JoinedIn.joined_subtype","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n‚ä¢ Joined ‚ü®x, ‚ãØ‚ü© ‚ü®y, ‚ãØ‚ü©","decl":"/-- If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`. -/\ntheorem JoinedIn.joined_subtype (h : JoinedIn F x y) :\n    Joined (‚ü®x, h.source_mem‚ü© : F) (‚ü®y, h.target_mem‚ü© : F) :=\n  ‚ü®{  toFun := fun t => ‚ü®h.somePath t, h.somePath_mem t‚ü©\n      continuous_toFun := by fun_prop\n      source' := by simp\n      target' := by simp }‚ü©\n\n"}
{"name":"JoinedIn.ofLine","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nf : Real ‚Üí X\nhf : ContinuousOn f unitInterval\nh‚ÇÄ : Eq (f 0) x\nh‚ÇÅ : Eq (f 1) y\nhF : HasSubset.Subset (Set.image f unitInterval) F\n‚ä¢ JoinedIn F x y","decl":"theorem JoinedIn.ofLine {f : ‚Ñù ‚Üí X} (hf : ContinuousOn f I) (h‚ÇÄ : f 0 = x) (h‚ÇÅ : f 1 = y)\n    (hF : f '' I ‚äÜ F) : JoinedIn F x y :=\n  ‚ü®Path.ofLine hf h‚ÇÄ h‚ÇÅ, fun t => hF <| Path.ofLine_mem hf h‚ÇÄ h‚ÇÅ t‚ü©\n\n"}
{"name":"JoinedIn.joined","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n‚ä¢ Joined x y","decl":"theorem JoinedIn.joined (h : JoinedIn F x y) : Joined x y :=\n  ‚ü®h.somePath‚ü©\n\n"}
{"name":"joinedIn_iff_joined","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nx_in : Membership.mem F x\ny_in : Membership.mem F y\n‚ä¢ Iff (JoinedIn F x y) (Joined ‚ü®x, x_in‚ü© ‚ü®y, y_in‚ü©)","decl":"theorem joinedIn_iff_joined (x_in : x ‚àà F) (y_in : y ‚àà F) :\n    JoinedIn F x y ‚Üî Joined (‚ü®x, x_in‚ü© : F) (‚ü®y, y_in‚ü© : F) :=\n  ‚ü®fun h => h.joined_subtype, fun h => ‚ü®h.somePath.map continuous_subtype_val, by simp‚ü©‚ü©\n\n"}
{"name":"joinedIn_univ","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (JoinedIn Set.univ x y) (Joined x y)","decl":"@[simp]\ntheorem joinedIn_univ : JoinedIn univ x y ‚Üî Joined x y := by\n  simp [JoinedIn, Joined, exists_true_iff_nonempty]\n\n"}
{"name":"JoinedIn.mono","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nU V : Set X\nh : JoinedIn U x y\nhUV : HasSubset.Subset U V\n‚ä¢ JoinedIn V x y","decl":"theorem JoinedIn.mono {U V : Set X} (h : JoinedIn U x y) (hUV : U ‚äÜ V) : JoinedIn V x y :=\n  ‚ü®h.somePath, fun t => hUV (h.somePath_mem t)‚ü©\n\n"}
{"name":"JoinedIn.refl","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\nF : Set X\nh : Membership.mem F x\n‚ä¢ JoinedIn F x x","decl":"theorem JoinedIn.refl (h : x ‚àà F) : JoinedIn F x x :=\n  ‚ü®Path.refl x, fun _t => h‚ü©\n\n"}
{"name":"JoinedIn.symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : JoinedIn F x y\n‚ä¢ JoinedIn F y x","decl":"@[symm]\ntheorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x := by\n  cases' h.mem with hx hy\n  simp_all only [joinedIn_iff_joined]\n  exact h.symm\n\n"}
{"name":"JoinedIn.trans","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y z : X\nF : Set X\nhxy : JoinedIn F x y\nhyz : JoinedIn F y z\n‚ä¢ JoinedIn F x z","decl":"theorem JoinedIn.trans (hxy : JoinedIn F x y) (hyz : JoinedIn F y z) : JoinedIn F x z := by\n  cases' hxy.mem with hx hy\n  cases' hyz.mem with hx hy\n  simp_all only [joinedIn_iff_joined]\n  exact hxy.trans hyz\n\n"}
{"name":"Specializes.joinedIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : Specializes x y\nhx : Membership.mem F x\nhy : Membership.mem F y\n‚ä¢ JoinedIn F x y","decl":"theorem Specializes.joinedIn (h : x ‚§≥ y) (hx : x ‚àà F) (hy : y ‚àà F) : JoinedIn F x y := by\n  refine ‚ü®‚ü®‚ü®Set.piecewise {1} (const I y) (const I x), ?_‚ü©, by simp, by simp‚ü©, fun t ‚Ü¶ ?_‚ü©\n  ¬∑ exact isClosed_singleton.continuous_piecewise_of_specializes continuous_const continuous_const\n      fun _ ‚Ü¶ h\n  ¬∑ simp only [Path.coe_mk_mk, piecewise]\n    split_ifs <;> assumption\n\n"}
{"name":"Inseparable.joinedIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : Inseparable x y\nhx : Membership.mem F x\nhy : Membership.mem F y\n‚ä¢ JoinedIn F x y","decl":"theorem Inseparable.joinedIn (h : Inseparable x y) (hx : x ‚àà F) (hy : y ‚àà F) : JoinedIn F x y :=\n  h.specializes.joinedIn hx hy\n\n"}
{"name":"JoinedIn.map_continuousOn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nF : Set X\nh : JoinedIn F x y\nf : X ‚Üí Y\nhf : ContinuousOn f F\n‚ä¢ JoinedIn (Set.image f F) (f x) (f y)","decl":"theorem JoinedIn.map_continuousOn (h : JoinedIn F x y) {f : X ‚Üí Y} (hf : ContinuousOn f F) :\n    JoinedIn (f '' F) (f x) (f y) :=\n  let ‚ü®Œ≥, hŒ≥‚ü© := h\n  ‚ü®Œ≥.map' <| hf.mono (range_subset_iff.mpr hŒ≥), fun t ‚Ü¶ mem_image_of_mem _ (hŒ≥ t)‚ü©\n\n"}
{"name":"JoinedIn.map","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nF : Set X\nh : JoinedIn F x y\nf : X ‚Üí Y\nhf : Continuous f\n‚ä¢ JoinedIn (Set.image f F) (f x) (f y)","decl":"theorem JoinedIn.map (h : JoinedIn F x y) {f : X ‚Üí Y} (hf : Continuous f) :\n    JoinedIn (f '' F) (f x) (f y) :=\n  h.map_continuousOn hf.continuousOn\n\n"}
{"name":"Topology.IsInducing.joinedIn_image","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nF : Set X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\nhx : Membership.mem F x\nhy : Membership.mem F y\n‚ä¢ Iff (JoinedIn (Set.image f F) (f x) (f y)) (JoinedIn F x y)","decl":"theorem Topology.IsInducing.joinedIn_image {f : X ‚Üí Y} (hf : IsInducing f) (hx : x ‚àà F)\n    (hy : y ‚àà F) : JoinedIn (f '' F) (f x) (f y) ‚Üî JoinedIn F x y := by\n  refine ‚ü®?_, (.map ¬∑ hf.continuous)‚ü©\n  rintro ‚ü®Œ≥, hŒ≥‚ü©\n  choose Œ≥' hŒ≥'F hŒ≥' using hŒ≥\n  have h‚ÇÄ : x ‚§≥ Œ≥' 0 := by rw [‚Üê hf.specializes_iff, hŒ≥', Œ≥.source]\n  have h‚ÇÅ : Œ≥' 1 ‚§≥ y := by rw [‚Üê hf.specializes_iff, hŒ≥', Œ≥.target]\n  have h : JoinedIn F (Œ≥' 0) (Œ≥' 1) := by\n    refine ‚ü®‚ü®‚ü®Œ≥', ?_‚ü©, rfl, rfl‚ü©, hŒ≥'F‚ü©\n    simpa only [hf.continuous_iff, comp_def, hŒ≥'] using map_continuous Œ≥\n  exact (h‚ÇÄ.joinedIn hx (hŒ≥'F _)).trans <| h.trans <| h‚ÇÅ.joinedIn (hŒ≥'F _) hy\n\n"}
{"name":"Inducing.joinedIn_image","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nx y : X\nF : Set X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\nhx : Membership.mem F x\nhy : Membership.mem F y\n‚ä¢ Iff (JoinedIn (Set.image f F) (f x) (f y)) (JoinedIn F x y)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.joinedIn_image := IsInducing.joinedIn_image\n\n"}
{"name":"mem_pathComponent_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Membership.mem (pathComponent y) x) (Joined y x)","decl":"theorem mem_pathComponent_iff : x ‚àà pathComponent y ‚Üî Joined y x := .rfl\n\n"}
{"name":"mem_pathComponent_self","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Membership.mem (pathComponent x) x","decl":"@[simp]\ntheorem mem_pathComponent_self (x : X) : x ‚àà pathComponent x :=\n  Joined.refl x\n\n"}
{"name":"pathComponent.nonempty","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ (pathComponent x).Nonempty","decl":"@[simp]\ntheorem pathComponent.nonempty (x : X) : (pathComponent x).Nonempty :=\n  ‚ü®x, mem_pathComponent_self x‚ü©\n\n"}
{"name":"mem_pathComponent_of_mem","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nh : Membership.mem (pathComponent y) x\n‚ä¢ Membership.mem (pathComponent x) y","decl":"theorem mem_pathComponent_of_mem (h : x ‚àà pathComponent y) : y ‚àà pathComponent x :=\n  Joined.symm h\n\n"}
{"name":"pathComponent_symm","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\n‚ä¢ Iff (Membership.mem (pathComponent y) x) (Membership.mem (pathComponent x) y)","decl":"theorem pathComponent_symm : x ‚àà pathComponent y ‚Üî y ‚àà pathComponent x :=\n  ‚ü®fun h => mem_pathComponent_of_mem h, fun h => mem_pathComponent_of_mem h‚ü©\n\n"}
{"name":"pathComponent_congr","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nh : Membership.mem (pathComponent y) x\n‚ä¢ Eq (pathComponent x) (pathComponent y)","decl":"theorem pathComponent_congr (h : x ‚àà pathComponent y) : pathComponent x = pathComponent y := by\n  ext z\n  constructor\n  ¬∑ intro h'\n    rw [pathComponent_symm]\n    exact (h.trans h').symm\n  ¬∑ intro h'\n    rw [pathComponent_symm] at h' ‚ä¢\n    exact h'.trans h\n\n"}
{"name":"pathComponent_subset_component","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ HasSubset.Subset (pathComponent x) (connectedComponent x)","decl":"theorem pathComponent_subset_component (x : X) : pathComponent x ‚äÜ connectedComponent x :=\n  fun y h =>\n  (isConnected_range h.somePath.continuous).subset_connectedComponent ‚ü®0, by simp‚ü© ‚ü®1, by simp‚ü©\n\n"}
{"name":"pathComponentIn_univ","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ Eq (pathComponentIn x Set.univ) (pathComponent x)","decl":"@[simp]\ntheorem pathComponentIn_univ (x : X) : pathComponentIn x univ = pathComponent x := by\n  simp [pathComponentIn, pathComponent, JoinedIn, Joined, exists_true_iff_nonempty]\n\n"}
{"name":"Joined.mem_pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y z : X\nhyz : Joined y z\nhxy : Membership.mem (pathComponent x) y\n‚ä¢ Membership.mem (pathComponent x) z","decl":"theorem Joined.mem_pathComponent (hyz : Joined y z) (hxy : y ‚àà pathComponent x) :\n    z ‚àà pathComponent x :=\n  hxy.trans hyz\n\n"}
{"name":"mem_pathComponentIn_self","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\nF : Set X\nh : Membership.mem F x\n‚ä¢ Membership.mem (pathComponentIn x F) x","decl":"theorem mem_pathComponentIn_self (h : x ‚àà F) : x ‚àà pathComponentIn x F :=\n  JoinedIn.refl h\n\n"}
{"name":"pathComponentIn_subset","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\nF : Set X\n‚ä¢ HasSubset.Subset (pathComponentIn x F) F","decl":"theorem pathComponentIn_subset : pathComponentIn x F ‚äÜ F :=\n  fun _ hy ‚Ü¶ hy.target_mem\n\n"}
{"name":"pathComponentIn_nonempty_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\nF : Set X\n‚ä¢ Iff (pathComponentIn x F).Nonempty (Membership.mem F x)","decl":"theorem pathComponentIn_nonempty_iff : (pathComponentIn x F).Nonempty ‚Üî x ‚àà F :=\n  ‚ü®fun ‚ü®_, ‚ü®Œ≥, hŒ≥‚ü©‚ü© ‚Ü¶ Œ≥.source ‚ñ∏ hŒ≥ 0, fun hx ‚Ü¶ ‚ü®x, mem_pathComponentIn_self hx‚ü©‚ü©\n\n"}
{"name":"pathComponentIn_congr","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : Membership.mem (pathComponentIn y F) x\n‚ä¢ Eq (pathComponentIn x F) (pathComponentIn y F)","decl":"theorem pathComponentIn_congr (h : x ‚àà pathComponentIn y F) :\n    pathComponentIn x F = pathComponentIn y F := by\n  ext; exact ‚ü®h.trans, h.symm.trans‚ü©\n\n"}
{"name":"pathComponentIn_mono","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\nF G : Set X\nh : HasSubset.Subset F G\n‚ä¢ HasSubset.Subset (pathComponentIn x F) (pathComponentIn x G)","decl":"@[gcongr]\ntheorem pathComponentIn_mono {G : Set X} (h : F ‚äÜ G) :\n    pathComponentIn x F ‚äÜ pathComponentIn x G :=\n  fun _ ‚ü®Œ≥, hŒ≥‚ü© ‚Ü¶ ‚ü®Œ≥, fun t ‚Ü¶ h (hŒ≥ t)‚ü©\n\n"}
{"name":"isPathConnected_iff_eq","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nF : Set X\n‚ä¢ Iff (IsPathConnected F) (Exists fun x => And (Membership.mem F x) (Eq (pathComponentIn x F) F))","decl":"theorem isPathConnected_iff_eq : IsPathConnected F ‚Üî ‚àÉ x ‚àà F, pathComponentIn x F = F := by\n  constructor <;> rintro ‚ü®x, x_in, h‚ü© <;> use x, x_in\n  ¬∑ ext y\n    exact ‚ü®fun hy => hy.mem.2, h‚ü©\n  ¬∑ intro y y_in\n    rwa [‚Üê h] at y_in\n\n"}
{"name":"IsPathConnected.joinedIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nF : Set X\nh : IsPathConnected F\nx : X\na‚úù¬π : Membership.mem F x\ny : X\na‚úù : Membership.mem F y\n‚ä¢ JoinedIn F x y","decl":"theorem IsPathConnected.joinedIn (h : IsPathConnected F) :\n    ‚àÄ·µâ (x ‚àà F) (y ‚àà F), JoinedIn F x y := fun _x x_in _y y_in =>\n  let ‚ü®_b, _b_in, hb‚ü© := h\n  (hb x_in).symm.trans (hb y_in)\n\n"}
{"name":"isPathConnected_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nF : Set X\n‚ä¢ Iff (IsPathConnected F) (And F.Nonempty (‚àÄ (x : X), Membership.mem F x ‚Üí ‚àÄ (y : X), Membership.mem F y ‚Üí JoinedIn F x y))","decl":"theorem isPathConnected_iff :\n    IsPathConnected F ‚Üî F.Nonempty ‚àß ‚àÄ·µâ (x ‚àà F) (y ‚àà F), JoinedIn F x y :=\n  ‚ü®fun h =>\n    ‚ü®let ‚ü®b, b_in, _hb‚ü© := h; ‚ü®b, b_in‚ü©, h.joinedIn‚ü©,\n    fun ‚ü®‚ü®b, b_in‚ü©, h‚ü© => ‚ü®b, b_in, fun x_in => h _ b_in _ x_in‚ü©‚ü©\n\n"}
{"name":"IsPathConnected.image'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nF : Set X\nhF : IsPathConnected F\nf : X ‚Üí Y\nhf : ContinuousOn f F\n‚ä¢ IsPathConnected (Set.image f F)","decl":"/-- If `f` is continuous on `F` and `F` is path-connected, so is `f(F)`. -/\ntheorem IsPathConnected.image' (hF : IsPathConnected F)\n    {f : X ‚Üí Y} (hf : ContinuousOn f F) : IsPathConnected (f '' F) := by\n  rcases hF with ‚ü®x, x_in, hx‚ü©\n  use f x, mem_image_of_mem f x_in\n  rintro _ ‚ü®y, y_in, rfl‚ü©\n  refine ‚ü®(hx y_in).somePath.map' ?_, fun t ‚Ü¶ ‚ü®_, (hx y_in).somePath_mem t, rfl‚ü©‚ü©\n  exact hf.mono (range_subset_iff.2 (hx y_in).somePath_mem)\n\n"}
{"name":"IsPathConnected.image","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nF : Set X\nhF : IsPathConnected F\nf : X ‚Üí Y\nhf : Continuous f\n‚ä¢ IsPathConnected (Set.image f F)","decl":"/-- If `f` is continuous and `F` is path-connected, so is `f(F)`. -/\ntheorem IsPathConnected.image (hF : IsPathConnected F) {f : X ‚Üí Y} (hf : Continuous f) :\n    IsPathConnected (f '' F) :=\n  hF.image' hf.continuousOn\n\n"}
{"name":"Topology.IsInducing.isPathConnected_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nF : Set X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Iff (IsPathConnected F) (IsPathConnected (Set.image f F))","decl":"/-- If `f : X ‚Üí Y` is an inducing map, `f(F)` is path-connected iff `F` is. -/\nnonrec theorem Topology.IsInducing.isPathConnected_iff {f : X ‚Üí Y} (hf : IsInducing f) :\n    IsPathConnected F ‚Üî IsPathConnected (f '' F) := by\n  simp only [IsPathConnected, forall_mem_image, exists_mem_image]\n  refine exists_congr fun x ‚Ü¶ and_congr_right fun hx ‚Ü¶ forall‚ÇÇ_congr fun y hy ‚Ü¶ ?_\n  rw [hf.joinedIn_image hx hy]\n\n"}
{"name":"Inducing.isPathConnected_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nF : Set X\nf : X ‚Üí Y\nhf : Topology.IsInducing f\n‚ä¢ Iff (IsPathConnected F) (IsPathConnected (Set.image f F))","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isPathConnected_iff := IsInducing.isPathConnected_iff\n\n"}
{"name":"Homeomorph.isPathConnected_image","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\nh : Homeomorph X Y\n‚ä¢ Iff (IsPathConnected (Set.image (‚áëh) s)) (IsPathConnected s)","decl":"/-- If `h : X ‚Üí Y` is a homeomorphism, `h(s)` is path-connected iff `s` is. -/\n@[simp]\ntheorem Homeomorph.isPathConnected_image {s : Set X} (h : X ‚âÉ‚Çú Y) :\n    IsPathConnected (h '' s) ‚Üî IsPathConnected s :=\n  h.isInducing.isPathConnected_iff.symm\n\n"}
{"name":"Homeomorph.isPathConnected_preimage","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set Y\nh : Homeomorph X Y\n‚ä¢ Iff (IsPathConnected (Set.preimage (‚áëh) s)) (IsPathConnected s)","decl":"/-- If `h : X ‚Üí Y` is a homeomorphism, `h‚Åª¬π(s)` is path-connected iff `s` is. -/\n@[simp]\ntheorem Homeomorph.isPathConnected_preimage {s : Set Y} (h : X ‚âÉ‚Çú Y) :\n    IsPathConnected (h ‚Åª¬π' s) ‚Üî IsPathConnected s := by\n  rw [‚Üê Homeomorph.image_symm]; exact h.symm.isPathConnected_image\n\n"}
{"name":"IsPathConnected.mem_pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx y : X\nF : Set X\nh : IsPathConnected F\nx_in : Membership.mem F x\ny_in : Membership.mem F y\n‚ä¢ Membership.mem (pathComponent x) y","decl":"theorem IsPathConnected.mem_pathComponent (h : IsPathConnected F) (x_in : x ‚àà F) (y_in : y ‚àà F) :\n    y ‚àà pathComponent x :=\n  (h.joinedIn x x_in y y_in).joined\n\n"}
{"name":"IsPathConnected.subset_pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\nF : Set X\nh : IsPathConnected F\nx_in : Membership.mem F x\n‚ä¢ HasSubset.Subset F (pathComponent x)","decl":"theorem IsPathConnected.subset_pathComponent (h : IsPathConnected F) (x_in : x ‚àà F) :\n    F ‚äÜ pathComponent x := fun _y y_in => h.mem_pathComponent x_in y_in\n\n"}
{"name":"IsPathConnected.subset_pathComponentIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\nF s : Set X\nhs : IsPathConnected s\nhxs : Membership.mem s x\nhsF : HasSubset.Subset s F\n‚ä¢ HasSubset.Subset s (pathComponentIn x F)","decl":"theorem IsPathConnected.subset_pathComponentIn {s : Set X} (hs : IsPathConnected s)\n    (hxs : x ‚àà s) (hsF : s ‚äÜ F) : s ‚äÜ pathComponentIn x F :=\n  fun y hys ‚Ü¶ (hs.joinedIn x hxs y hys).mono hsF\n\n"}
{"name":"isPathConnected_singleton","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ IsPathConnected (Singleton.singleton x)","decl":"theorem isPathConnected_singleton (x : X) : IsPathConnected ({x} : Set X) := by\n  refine ‚ü®x, rfl, ?_‚ü©\n  rintro y rfl\n  exact JoinedIn.refl rfl\n\n"}
{"name":"isPathConnected_pathComponentIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\nF : Set X\nh : Membership.mem F x\n‚ä¢ IsPathConnected (pathComponentIn x F)","decl":"theorem isPathConnected_pathComponentIn (h : x ‚àà F) : IsPathConnected (pathComponentIn x F) :=\n  ‚ü®x, mem_pathComponentIn_self h, fun ‚ü®Œ≥, hŒ≥‚ü© ‚Ü¶ by\n    refine ‚ü®Œ≥, fun t ‚Ü¶\n      ‚ü®(Œ≥.truncateOfLE t.2.1).cast (Œ≥.extend_zero.symm) (Œ≥.extend_extends' t).symm, fun t' ‚Ü¶ ?_‚ü©‚ü©\n    dsimp [Path.truncateOfLE, Path.truncate]\n    exact Œ≥.extend_extends' ‚ü®min (max t'.1 0) t.1, by simp [t.2.1, t.2.2]‚ü© ‚ñ∏ hŒ≥ _‚ü©\n\n"}
{"name":"isPathConnected_pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nx : X\n‚ä¢ IsPathConnected (pathComponent x)","decl":"theorem isPathConnected_pathComponent : IsPathConnected (pathComponent x) := by\n  rw [‚Üê pathComponentIn_univ]\n  exact isPathConnected_pathComponentIn (mem_univ x)\n\n"}
{"name":"IsPathConnected.union","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nU V : Set X\nhU : IsPathConnected U\nhV : IsPathConnected V\nhUV : (Inter.inter U V).Nonempty\n‚ä¢ IsPathConnected (Union.union U V)","decl":"theorem IsPathConnected.union {U V : Set X} (hU : IsPathConnected U) (hV : IsPathConnected V)\n    (hUV : (U ‚à© V).Nonempty) : IsPathConnected (U ‚à™ V) := by\n  rcases hUV with ‚ü®x, xU, xV‚ü©\n  use x, Or.inl xU\n  rintro y (yU | yV)\n  ¬∑ exact (hU.joinedIn x xU y yU).mono subset_union_left\n  ¬∑ exact (hV.joinedIn x xV y yV).mono subset_union_right\n\n"}
{"name":"IsPathConnected.preimage_coe","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nU W : Set X\nhW : IsPathConnected W\nhWU : HasSubset.Subset W U\n‚ä¢ IsPathConnected (Set.preimage Subtype.val W)","decl":"/-- If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\nambient type `U` (when `U` contains `W`). -/\ntheorem IsPathConnected.preimage_coe {U W : Set X} (hW : IsPathConnected W) (hWU : W ‚äÜ U) :\n    IsPathConnected (((‚Üë) : U ‚Üí X) ‚Åª¬π' W) := by\n  rwa [IsInducing.subtypeVal.isPathConnected_iff, Subtype.image_preimage_val, inter_eq_right.2 hWU]\n\n"}
{"name":"IsPathConnected.exists_path_through_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nn : Nat\ns : Set X\nh : IsPathConnected s\np : Fin (HAdd.hAdd n 1) ‚Üí X\nhp : ‚àÄ (i : Fin (HAdd.hAdd n 1)), Membership.mem s (p i)\n‚ä¢ Exists fun Œ≥ => And (HasSubset.Subset (Set.range ‚áëŒ≥) s) (‚àÄ (i : Fin (HAdd.hAdd n 1)), Membership.mem (Set.range ‚áëŒ≥) (p i))","decl":"theorem IsPathConnected.exists_path_through_family {n : ‚Ñï}\n    {s : Set X} (h : IsPathConnected s) (p : Fin (n + 1) ‚Üí X) (hp : ‚àÄ i, p i ‚àà s) :\n    ‚àÉ Œ≥ : Path (p 0) (p n), range Œ≥ ‚äÜ s ‚àß ‚àÄ i, p i ‚àà range Œ≥ := by\n  let p' : ‚Ñï ‚Üí X := fun k => if h : k < n + 1 then p ‚ü®k, h‚ü© else p ‚ü®0, n.zero_lt_succ‚ü©\n  obtain ‚ü®Œ≥, hŒ≥‚ü© : ‚àÉ Œ≥ : Path (p' 0) (p' n), (‚àÄ i ‚â§ n, p' i ‚àà range Œ≥) ‚àß range Œ≥ ‚äÜ s := by\n    have hp' : ‚àÄ i ‚â§ n, p' i ‚àà s := by\n      intro i hi\n      simp [p', Nat.lt_succ_of_le hi, hp]\n    clear_value p'\n    clear hp p\n    induction' n with n hn\n    ¬∑ use Path.refl (p' 0)\n      constructor\n      ¬∑ rintro i hi\n        rw [Nat.le_zero.mp hi]\n        exact ‚ü®0, rfl‚ü©\n      ¬∑ rw [range_subset_iff]\n        rintro _x\n        exact hp' 0 le_rfl\n    ¬∑ rcases hn fun i hi => hp' i <| Nat.le_succ_of_le hi with ‚ü®Œ≥‚ÇÄ, hŒ≥‚ÇÄ‚ü©\n      rcases h.joinedIn (p' n) (hp' n n.le_succ) (p' <| n + 1) (hp' (n + 1) <| le_rfl) with\n        ‚ü®Œ≥‚ÇÅ, hŒ≥‚ÇÅ‚ü©\n      let Œ≥ : Path (p' 0) (p' <| n + 1) := Œ≥‚ÇÄ.trans Œ≥‚ÇÅ\n      use Œ≥\n      have range_eq : range Œ≥ = range Œ≥‚ÇÄ ‚à™ range Œ≥‚ÇÅ := Œ≥‚ÇÄ.trans_range Œ≥‚ÇÅ\n      constructor\n      ¬∑ rintro i hi\n        by_cases hi' : i ‚â§ n\n        ¬∑ rw [range_eq]\n          left\n          exact hŒ≥‚ÇÄ.1 i hi'\n        ¬∑ rw [not_le, ‚Üê Nat.succ_le_iff] at hi'\n          have : i = n.succ := le_antisymm hi hi'\n          rw [this]\n          use 1\n          exact Œ≥.target\n      ¬∑ rw [range_eq]\n        apply union_subset hŒ≥‚ÇÄ.2\n        rw [range_subset_iff]\n        exact hŒ≥‚ÇÅ\n  have hpp' : ‚àÄ k < n + 1, p k = p' k := by\n    intro k hk\n    simp only [p', hk, dif_pos]\n    congr\n    ext\n    rw [Fin.val_cast_of_lt hk]\n  use Œ≥.cast (hpp' 0 n.zero_lt_succ) (hpp' n n.lt_succ_self)\n  simp only [Œ≥.cast_coe]\n  refine And.intro hŒ≥.2 ?_\n  rintro ‚ü®i, hi‚ü©\n  suffices p ‚ü®i, hi‚ü© = p' i by convert hŒ≥.1 i (Nat.le_of_lt_succ hi)\n  rw [‚Üê hpp' i hi]\n  suffices i = i % n.succ by congr\n  rw [Nat.mod_eq_of_lt hi]\n\n"}
{"name":"IsPathConnected.exists_path_through_family'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nn : Nat\ns : Set X\nh : IsPathConnected s\np : Fin (HAdd.hAdd n 1) ‚Üí X\nhp : ‚àÄ (i : Fin (HAdd.hAdd n 1)), Membership.mem s (p i)\n‚ä¢ Exists fun Œ≥ => Exists fun t => And (‚àÄ (t : ‚ÜëunitInterval), Membership.mem s (Œ≥ t)) (‚àÄ (i : Fin (HAdd.hAdd n 1)), Eq (Œ≥ (t i)) (p i))","decl":"theorem IsPathConnected.exists_path_through_family' {n : ‚Ñï}\n    {s : Set X} (h : IsPathConnected s) (p : Fin (n + 1) ‚Üí X) (hp : ‚àÄ i, p i ‚àà s) :\n    ‚àÉ (Œ≥ : Path (p 0) (p n)) (t : Fin (n + 1) ‚Üí I), (‚àÄ t, Œ≥ t ‚àà s) ‚àß ‚àÄ i, Œ≥ (t i) = p i := by\n  rcases h.exists_path_through_family p hp with ‚ü®Œ≥, hŒ≥‚ü©\n  rcases hŒ≥ with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©\n  simp only [range, mem_setOf_eq] at h‚ÇÇ\n  rw [range_subset_iff] at h‚ÇÅ\n  choose! t ht using h‚ÇÇ\n  exact ‚ü®Œ≥, t, h‚ÇÅ, ht‚ü©\n\n"}
{"name":"pathConnectedSpace_iff","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (PathConnectedSpace X) (And (Nonempty X) (‚àÄ (x y : X), Joined x y))","decl":"/-- A topological space is path-connected if it is non-empty and every two points can be\njoined by a continuous path. -/\n@[mk_iff]\nclass PathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- A path-connected space must be nonempty. -/\n  nonempty : Nonempty X\n  /-- Any two points in a path-connected space must be joined by a continuous path. -/\n  joined : ‚àÄ x y : X, Joined x y\n\n"}
{"name":"PathConnectedSpace.nonempty","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\nself : PathConnectedSpace X\n‚ä¢ Nonempty X","decl":"/-- A topological space is path-connected if it is non-empty and every two points can be\njoined by a continuous path. -/\n@[mk_iff]\nclass PathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- A path-connected space must be nonempty. -/\n  nonempty : Nonempty X\n  /-- Any two points in a path-connected space must be joined by a continuous path. -/\n  joined : ‚àÄ x y : X, Joined x y\n\n"}
{"name":"PathConnectedSpace.joined","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\nself : PathConnectedSpace X\nx y : X\n‚ä¢ Joined x y","decl":"/-- A topological space is path-connected if it is non-empty and every two points can be\njoined by a continuous path. -/\n@[mk_iff]\nclass PathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- A path-connected space must be nonempty. -/\n  nonempty : Nonempty X\n  /-- Any two points in a path-connected space must be joined by a continuous path. -/\n  joined : ‚àÄ x y : X, Joined x y\n\n"}
{"name":"pathConnectedSpace_iff_zerothHomotopy","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (PathConnectedSpace X) (And (Nonempty (ZerothHomotopy X)) (Subsingleton (ZerothHomotopy X)))","decl":"theorem pathConnectedSpace_iff_zerothHomotopy :\n    PathConnectedSpace X ‚Üî Nonempty (ZerothHomotopy X) ‚àß Subsingleton (ZerothHomotopy X) := by\n  letI := pathSetoid X\n  constructor\n  ¬∑ intro h\n    refine ‚ü®(nonempty_quotient_iff _).mpr h.1, ‚ü®?_‚ü©‚ü©\n    rintro ‚ü®x‚ü© ‚ü®y‚ü©\n    exact Quotient.sound (PathConnectedSpace.joined x y)\n  ¬∑ unfold ZerothHomotopy\n    rintro ‚ü®h, h'‚ü©\n    exact ‚ü®(nonempty_quotient_iff _).mp h, fun x y => Quotient.exact <| Subsingleton.elim ‚ü¶x‚üß ‚ü¶y‚üß‚ü©\n\n"}
{"name":"pathConnectedSpace_iff_univ","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (PathConnectedSpace X) (IsPathConnected Set.univ)","decl":"theorem pathConnectedSpace_iff_univ : PathConnectedSpace X ‚Üî IsPathConnected (univ : Set X) := by\n  simp [pathConnectedSpace_iff, isPathConnected_iff, nonempty_iff_univ_nonempty]\n\n"}
{"name":"isPathConnected_iff_pathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nF : Set X\n‚ä¢ Iff (IsPathConnected F) (PathConnectedSpace ‚ÜëF)","decl":"theorem isPathConnected_iff_pathConnectedSpace : IsPathConnected F ‚Üî PathConnectedSpace F := by\n  rw [pathConnectedSpace_iff_univ, IsInducing.subtypeVal.isPathConnected_iff, image_univ,\n    Subtype.range_val_subtype, setOf_mem_eq]\n\n"}
{"name":"isPathConnected_univ","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PathConnectedSpace X\n‚ä¢ IsPathConnected Set.univ","decl":"theorem isPathConnected_univ [PathConnectedSpace X] : IsPathConnected (univ : Set X) :=\n  pathConnectedSpace_iff_univ.mp inferInstance\n\n"}
{"name":"isPathConnected_range","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : PathConnectedSpace X\nf : X ‚Üí Y\nhf : Continuous f\n‚ä¢ IsPathConnected (Set.range f)","decl":"theorem isPathConnected_range [PathConnectedSpace X] {f : X ‚Üí Y} (hf : Continuous f) :\n    IsPathConnected (range f) := by\n  rw [‚Üê image_univ]\n  exact isPathConnected_univ.image hf\n\n"}
{"name":"Function.Surjective.pathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : PathConnectedSpace X\nf : X ‚Üí Y\nhf : Function.Surjective f\nhf' : Continuous f\n‚ä¢ PathConnectedSpace Y","decl":"theorem Function.Surjective.pathConnectedSpace [PathConnectedSpace X]\n    {f : X ‚Üí Y} (hf : Surjective f) (hf' : Continuous f) : PathConnectedSpace Y := by\n  rw [pathConnectedSpace_iff_univ, ‚Üê hf.range_eq]\n  exact isPathConnected_range hf'\n\n"}
{"name":"Quotient.instPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ns : Setoid X\ninst‚úù : PathConnectedSpace X\n‚ä¢ PathConnectedSpace (Quotient s)","decl":"instance Quotient.instPathConnectedSpace {s : Setoid X} [PathConnectedSpace X] :\n    PathConnectedSpace (Quotient s) :=\n  Quotient.mk'_surjective.pathConnectedSpace continuous_coinduced_rng\n\n"}
{"name":"Real.instPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"‚ä¢ PathConnectedSpace Real","decl":"/-- This is a special case of `NormedSpace.instPathConnectedSpace` (and\n`TopologicalAddGroup.pathConnectedSpace`). It exists only to simplify dependencies. -/\ninstance Real.instPathConnectedSpace : PathConnectedSpace ‚Ñù where\n  joined x y := ‚ü®‚ü®‚ü®fun (t : I) ‚Ü¶ (1 - t) * x + t * y, by fun_prop‚ü©, by simp, by simp‚ü©‚ü©\n  nonempty := inferInstance\n\n"}
{"name":"pathConnectedSpace_iff_eq","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (PathConnectedSpace X) (Exists fun x => Eq (pathComponent x) Set.univ)","decl":"theorem pathConnectedSpace_iff_eq : PathConnectedSpace X ‚Üî ‚àÉ x : X, pathComponent x = univ := by\n  simp [pathConnectedSpace_iff_univ, isPathConnected_iff_eq]\n\n-- see Note [lower instance priority]\n"}
{"name":"PathConnectedSpace.connectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PathConnectedSpace X\n‚ä¢ ConnectedSpace X","decl":"instance (priority := 100) PathConnectedSpace.connectedSpace [PathConnectedSpace X] :\n    ConnectedSpace X := by\n  rw [connectedSpace_iff_connectedComponent]\n  rcases isPathConnected_iff_eq.mp (pathConnectedSpace_iff_univ.mp ‚Äπ_‚Ä∫) with ‚ü®x, _x_in, hx‚ü©\n  use x\n  rw [‚Üê univ_subset_iff]\n  exact (by simpa using hx : pathComponent x = univ) ‚ñ∏ pathComponent_subset_component x\n\n"}
{"name":"IsPathConnected.isConnected","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nF : Set X\nhF : IsPathConnected F\n‚ä¢ IsConnected F","decl":"theorem IsPathConnected.isConnected (hF : IsPathConnected F) : IsConnected F := by\n  rw [isConnected_iff_connectedSpace]\n  rw [isPathConnected_iff_pathConnectedSpace] at hF\n  exact @PathConnectedSpace.connectedSpace _ _ hF\n\n"}
{"name":"PathConnectedSpace.exists_path_through_family","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PathConnectedSpace X\nn : Nat\np : Fin (HAdd.hAdd n 1) ‚Üí X\n‚ä¢ Exists fun Œ≥ => ‚àÄ (i : Fin (HAdd.hAdd n 1)), Membership.mem (Set.range ‚áëŒ≥) (p i)","decl":"theorem exists_path_through_family {n : ‚Ñï} (p : Fin (n + 1) ‚Üí X) :\n    ‚àÉ Œ≥ : Path (p 0) (p n), ‚àÄ i, p i ‚àà range Œ≥ := by\n  have : IsPathConnected (univ : Set X) := pathConnectedSpace_iff_univ.mp (by infer_instance)\n  rcases this.exists_path_through_family p fun _i => True.intro with ‚ü®Œ≥, -, h‚ü©\n  exact ‚ü®Œ≥, h‚ü©\n\n"}
{"name":"PathConnectedSpace.exists_path_through_family'","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PathConnectedSpace X\nn : Nat\np : Fin (HAdd.hAdd n 1) ‚Üí X\n‚ä¢ Exists fun Œ≥ => Exists fun t => ‚àÄ (i : Fin (HAdd.hAdd n 1)), Eq (Œ≥ (t i)) (p i)","decl":"theorem exists_path_through_family' {n : ‚Ñï} (p : Fin (n + 1) ‚Üí X) :\n    ‚àÉ (Œ≥ : Path (p 0) (p n)) (t : Fin (n + 1) ‚Üí I), ‚àÄ i, Œ≥ (t i) = p i := by\n  have : IsPathConnected (univ : Set X) := pathConnectedSpace_iff_univ.mp (by infer_instance)\n  rcases this.exists_path_through_family' p fun _i => True.intro with ‚ü®Œ≥, t, -, h‚ü©\n  exact ‚ü®Œ≥, t, h‚ü©\n\n"}
{"name":"LocPathConnectedSpace.path_connected_basis","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\nself : LocPathConnectedSpace X\nx : X\n‚ä¢ (nhds x).HasBasis (fun s => And (Membership.mem (nhds x) s) (IsPathConnected s)) id","decl":"/-- A topological space is locally path connected, at every point, path connected\nneighborhoods form a neighborhood basis. -/\nclass LocPathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- Each neighborhood filter has a basis of path-connected neighborhoods. -/\n  path_connected_basis : ‚àÄ x : X, (ùìù x).HasBasis (fun s : Set X => s ‚àà ùìù x ‚àß IsPathConnected s) id\n\n"}
{"name":"LocPathConnectedSpace.of_bases","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : Type u_3\np : X ‚Üí Œπ ‚Üí Prop\ns : X ‚Üí Œπ ‚Üí Set X\nh : ‚àÄ (x : X), (nhds x).HasBasis (p x) (s x)\nh' : ‚àÄ (x : X) (i : Œπ), p x i ‚Üí IsPathConnected (s x i)\n‚ä¢ LocPathConnectedSpace X","decl":"theorem LocPathConnectedSpace.of_bases {p : X ‚Üí Œπ ‚Üí Prop} {s : X ‚Üí Œπ ‚Üí Set X}\n    (h : ‚àÄ x, (ùìù x).HasBasis (p x) (s x)) (h' : ‚àÄ x i, p x i ‚Üí IsPathConnected (s x i)) :\n    LocPathConnectedSpace X where\n  path_connected_basis x := by\n    rw [hasBasis_self]\n    intro t ht\n    rcases (h x).mem_iff.mp ht with ‚ü®i, hpi, hi‚ü©\n    exact ‚ü®s x i, (h x).mem_of_mem hpi, h' x i hpi, hi‚ü©\n\n"}
{"name":"locPathConnected_of_bases","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : Type u_3\np : X ‚Üí Œπ ‚Üí Prop\ns : X ‚Üí Œπ ‚Üí Set X\nh : ‚àÄ (x : X), (nhds x).HasBasis (p x) (s x)\nh' : ‚àÄ (x : X) (i : Œπ), p x i ‚Üí IsPathConnected (s x i)\n‚ä¢ LocPathConnectedSpace X","decl":"@[deprecated (since := \"2024-10-16\")]\nalias locPathConnected_of_bases := LocPathConnectedSpace.of_bases\n\n"}
{"name":"IsOpen.pathComponentIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nF : Set X\ninst‚úù : LocPathConnectedSpace X\nx : X\nhF : IsOpen F\n‚ä¢ IsOpen (pathComponentIn x F)","decl":"protected theorem IsOpen.pathComponentIn (x : X) (hF : IsOpen F) :\n    IsOpen (pathComponentIn x F) := by\n  rw [isOpen_iff_mem_nhds]\n  intro y hy\n  let ‚ü®s, hs‚ü© := (path_connected_basis y).mem_iff.mp (hF.mem_nhds (pathComponentIn_subset hy))\n  exact mem_of_superset hs.1.1 <| pathComponentIn_congr hy ‚ñ∏\n    hs.1.2.subset_pathComponentIn (mem_of_mem_nhds hs.1.1) hs.2\n\n"}
{"name":"IsOpen.pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nx : X\n‚ä¢ IsOpen (pathComponent x)","decl":"/-- In a locally path connected space, each path component is an open set. -/\nprotected theorem IsOpen.pathComponent (x : X) : IsOpen (pathComponent x) := by\n  rw [‚Üê pathComponentIn_univ]\n  exact isOpen_univ.pathComponentIn _\n\n"}
{"name":"IsClosed.pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nx : X\n‚ä¢ IsClosed (pathComponent x)","decl":"/-- In a locally path connected space, each path component is a closed set. -/\nprotected theorem IsClosed.pathComponent (x : X) : IsClosed (pathComponent x) := by\n  rw [‚Üê isOpen_compl_iff, isOpen_iff_mem_nhds]\n  intro y hxy\n  rcases (path_connected_basis y).ex_mem with ‚ü®V, hVy, hVc‚ü©\n  filter_upwards [hVy] with z hz hxz\n  exact hxy <|  hxz.trans (hVc.joinedIn _ hz _ (mem_of_mem_nhds hVy)).joined\n\n"}
{"name":"IsClopen.pathComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nx : X\n‚ä¢ IsClopen (pathComponent x)","decl":"/-- In a locally path connected space, each path component is a clopen set. -/\nprotected theorem IsClopen.pathComponent (x : X) : IsClopen (pathComponent x) :=\n  ‚ü®.pathComponent x, .pathComponent x‚ü©\n\n"}
{"name":"pathComponentIn_mem_nhds","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nx : X\nF : Set X\ninst‚úù : LocPathConnectedSpace X\nhF : Membership.mem (nhds x) F\n‚ä¢ Membership.mem (nhds x) (pathComponentIn x F)","decl":"lemma pathComponentIn_mem_nhds (hF : F ‚àà ùìù x) : pathComponentIn x F ‚àà ùìù x := by\n  let ‚ü®u, huF, hu, hxu‚ü© := mem_nhds_iff.mp hF\n  exact mem_nhds_iff.mpr ‚ü®pathComponentIn x u, pathComponentIn_mono huF,\n    hu.pathComponentIn x, mem_pathComponentIn_self hxu‚ü©\n\n"}
{"name":"pathConnectedSpace_iff_connectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\n‚ä¢ Iff (PathConnectedSpace X) (ConnectedSpace X)","decl":"theorem pathConnectedSpace_iff_connectedSpace : PathConnectedSpace X ‚Üî ConnectedSpace X := by\n  refine ‚ü®fun _ ‚Ü¶ inferInstance, fun h ‚Ü¶ ‚ü®inferInstance, fun x y ‚Ü¶ ?_‚ü©‚ü©\n  rw [‚Üê mem_pathComponent_iff, (IsClopen.pathComponent _).eq_univ] <;> simp\n\n"}
{"name":"pathComponent_eq_connectedComponent","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nx : X\n‚ä¢ Eq (pathComponent x) (connectedComponent x)","decl":"theorem pathComponent_eq_connectedComponent (x : X) : pathComponent x = connectedComponent x :=\n  (pathComponent_subset_component x).antisymm <|\n    (IsClopen.pathComponent x).connectedComponent_subset (mem_pathComponent_self _)\n\n"}
{"name":"pathConnected_subset_basis","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\nx : X\ninst‚úù : LocPathConnectedSpace X\nU : Set X\nh : IsOpen U\nhx : Membership.mem U x\n‚ä¢ (nhds x).HasBasis (fun s => And (Membership.mem (nhds x) s) (And (IsPathConnected s) (HasSubset.Subset s U))) id","decl":"theorem pathConnected_subset_basis {U : Set X} (h : IsOpen U) (hx : x ‚àà U) :\n    (ùìù x).HasBasis (fun s : Set X => s ‚àà ùìù x ‚àß IsPathConnected s ‚àß s ‚äÜ U) id :=\n  (path_connected_basis x).hasBasis_self_subset (IsOpen.mem_nhds h hx)\n\n"}
{"name":"isOpen_isPathConnected_basis","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nx : X\n‚ä¢ (nhds x).HasBasis (fun s => And (IsOpen s) (And (Membership.mem s x) (IsPathConnected s))) id","decl":"theorem isOpen_isPathConnected_basis (x : X) :\n    (ùìù x).HasBasis (fun s : Set X ‚Ü¶ IsOpen s ‚àß x ‚àà s ‚àß IsPathConnected s) id := by\n  refine ‚ü®fun s ‚Ü¶ ‚ü®fun hs ‚Ü¶ ?_, fun ‚ü®u, hu‚ü© ‚Ü¶ mem_nhds_iff.mpr ‚ü®u, hu.2, hu.1.1, hu.1.2.1‚ü©‚ü©‚ü©\n  have ‚ü®u, hus, hu, hxu‚ü© := mem_nhds_iff.mp hs\n  exact ‚ü®pathComponentIn x u, ‚ü®hu.pathComponentIn _, ‚ü®mem_pathComponentIn_self hxu,\n    isPathConnected_pathComponentIn hxu‚ü©‚ü©, pathComponentIn_subset.trans hus‚ü©\n\n"}
{"name":"Topology.IsOpenEmbedding.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocPathConnectedSpace X\ne : Y ‚Üí X\nhe : Topology.IsOpenEmbedding e\n‚ä¢ LocPathConnectedSpace Y","decl":"theorem Topology.IsOpenEmbedding.locPathConnectedSpace {e : Y ‚Üí X} (he : IsOpenEmbedding e) :\n    LocPathConnectedSpace Y :=\n  have (y : Y) :\n      (ùìù y).HasBasis (fun s ‚Ü¶ s ‚àà ùìù (e y) ‚àß IsPathConnected s ‚àß s ‚äÜ range e) (e ‚Åª¬π' ¬∑) :=\n    he.basis_nhds <| pathConnected_subset_basis he.isOpen_range (mem_range_self _)\n  .of_bases this fun x s ‚ü®_, hs, hse‚ü© ‚Ü¶ by\n    rwa [he.isPathConnected_iff, image_preimage_eq_of_subset hse]\n\n"}
{"name":"OpenEmbedding.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocPathConnectedSpace X\ne : Y ‚Üí X\nhe : Topology.IsOpenEmbedding e\n‚ä¢ LocPathConnectedSpace Y","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.locPathConnectedSpace := IsOpenEmbedding.locPathConnectedSpace\n\n"}
{"name":"IsOpen.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nU : Set X\nh : IsOpen U\n‚ä¢ LocPathConnectedSpace ‚ÜëU","decl":"theorem IsOpen.locPathConnectedSpace {U : Set X} (h : IsOpen U) : LocPathConnectedSpace U :=\n  h.isOpenEmbedding_subtypeVal.locPathConnectedSpace\n\n"}
{"name":"locPathConnected_of_isOpen","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nU : Set X\nh : IsOpen U\n‚ä¢ LocPathConnectedSpace ‚ÜëU","decl":"@[deprecated (since := \"2024-10-17\")]\nalias locPathConnected_of_isOpen := IsOpen.locPathConnectedSpace\n\n"}
{"name":"IsOpen.isConnected_iff_isPathConnected","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nU : Set X\nU_op : IsOpen U\n‚ä¢ Iff (IsConnected U) (IsPathConnected U)","decl":"theorem IsOpen.isConnected_iff_isPathConnected {U : Set X} (U_op : IsOpen U) :\n    IsConnected U ‚Üî IsPathConnected U := by\n  rw [isConnected_iff_connectedSpace, isPathConnected_iff_pathConnectedSpace]\n  haveI := U_op.locPathConnectedSpace\n  exact pathConnectedSpace_iff_connectedSpace.symm\n\n"}
{"name":"instLocallyConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ LocallyConnectedSpace X","decl":"/-- Locally path-connected spaces are locally connected. -/\ninstance : LocallyConnectedSpace X := by\n  refine ‚ü®forall_imp (fun x h ‚Ü¶ ‚ü®fun s ‚Ü¶ ?_‚ü©) isOpen_isPathConnected_basis‚ü©\n  refine ‚ü®fun hs ‚Ü¶ ?_, fun ‚ü®u, ‚ü®hu, hxu, _‚ü©, hus‚ü© ‚Ü¶ mem_nhds_iff.mpr ‚ü®u, hus, hu, hxu‚ü©‚ü©\n  let ‚ü®u, ‚ü®hu, hxu, hu'‚ü©, hus‚ü© := (h.mem_iff' s).mp hs\n  exact ‚ü®u, ‚ü®hu, hxu, hu'.isConnected‚ü©, hus‚ü©\n\n"}
{"name":"locPathConnectedSpace_iff_isOpen_pathComponentIn","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (LocPathConnectedSpace X) (‚àÄ (x : X) (u : Set X), IsOpen u ‚Üí IsOpen (pathComponentIn x u))","decl":"/-- A space is locally path-connected iff all path components of open subsets are open. -/\nlemma locPathConnectedSpace_iff_isOpen_pathComponentIn {X : Type*} [TopologicalSpace X] :\n    LocPathConnectedSpace X ‚Üî ‚àÄ (x : X) (u : Set X), IsOpen u ‚Üí IsOpen (pathComponentIn x u) :=\n  ‚ü®fun _ _ _ hu ‚Ü¶ hu.pathComponentIn _, fun h ‚Ü¶ ‚ü®fun x ‚Ü¶ ‚ü®fun s ‚Ü¶ by\n    refine ‚ü®fun hs ‚Ü¶ ?_, fun ‚ü®_, ht‚ü© ‚Ü¶ Filter.mem_of_superset ht.1.1 ht.2‚ü©\n    let ‚ü®u, hu‚ü© := mem_nhds_iff.mp hs\n    exact ‚ü®pathComponentIn x u, ‚ü®(h x u hu.2.1).mem_nhds (mem_pathComponentIn_self hu.2.2),\n      isPathConnected_pathComponentIn hu.2.2‚ü©, pathComponentIn_subset.trans hu.1‚ü©‚ü©‚ü©‚ü©\n\n"}
{"name":"locPathConnectedSpace_iff_pathComponentIn_mem_nhds","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (LocPathConnectedSpace X) (‚àÄ (x : X) (u : Set X), IsOpen u ‚Üí Membership.mem u x ‚Üí Membership.mem (nhds x) (pathComponentIn x u))","decl":"/-- A space is locally path-connected iff all path components of open subsets are neighbourhoods. -/\nlemma locPathConnectedSpace_iff_pathComponentIn_mem_nhds {X : Type*} [TopologicalSpace X] :\n    LocPathConnectedSpace X ‚Üî\n    ‚àÄ x : X, ‚àÄ u : Set X, IsOpen u ‚Üí x ‚àà u ‚Üí pathComponentIn x u ‚àà nhds x := by\n  rw [locPathConnectedSpace_iff_isOpen_pathComponentIn]\n  simp_rw [forall_comm (Œ≤ := Set X), ‚Üê imp_forall_iff]\n  refine forall_congr' fun u ‚Ü¶ imp_congr_right fun _ ‚Ü¶ ?_\n  exact ‚ü®fun h x hxu ‚Ü¶ (h x).mem_nhds (mem_pathComponentIn_self hxu),\n    fun h x ‚Ü¶ isOpen_iff_mem_nhds.mpr fun y hy ‚Ü¶\n      pathComponentIn_congr hy ‚ñ∏ h y <| pathComponentIn_subset hy‚ü©\n\n"}
{"name":"LocPathConnectedSpace.coinduced","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nY : Type u_4\nf : X ‚Üí Y\n‚ä¢ LocPathConnectedSpace Y","decl":"/-- Any topology coinduced by a locally path-connected topology is locally path-connected. -/\nlemma LocPathConnectedSpace.coinduced {Y : Type*} (f : X ‚Üí Y) :\n    @LocPathConnectedSpace Y (.coinduced f ‚Äπ_‚Ä∫) := by\n  let _ := TopologicalSpace.coinduced f ‚Äπ_‚Ä∫; have hf : Continuous f := continuous_coinduced_rng\n  refine locPathConnectedSpace_iff_isOpen_pathComponentIn.mpr fun y u hu ‚Ü¶\n    isOpen_coinduced.mpr <| isOpen_iff_mem_nhds.mpr fun x hx ‚Ü¶ ?_\n  have hx' := preimage_mono pathComponentIn_subset hx\n  refine mem_nhds_iff.mpr ‚ü®pathComponentIn x (f ‚Åª¬π' u), ?_,\n    (hu.preimage hf).pathComponentIn _, mem_pathComponentIn_self hx'‚ü©\n  rw [‚Üê image_subset_iff, ‚Üê pathComponentIn_congr hx]\n  exact ((isPathConnected_pathComponentIn hx').image hf).subset_pathComponentIn\n    ‚ü®x, mem_pathComponentIn_self hx', rfl‚ü© <|\n    (image_mono pathComponentIn_subset).trans <| u.image_preimage_subset f\n\n"}
{"name":"Topology.IsQuotientMap.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : LocPathConnectedSpace X\nf : X ‚Üí Y\nh : Topology.IsQuotientMap f\n‚ä¢ LocPathConnectedSpace Y","decl":"/-- Quotients of locally path-connected spaces are locally path-connected. -/\nlemma Topology.IsQuotientMap.locPathConnectedSpace {f : X ‚Üí Y} (h : IsQuotientMap f) :\n    LocPathConnectedSpace Y :=\n  h.2 ‚ñ∏ LocPathConnectedSpace.coinduced f\n\n"}
{"name":"Quot.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\nr : X ‚Üí X ‚Üí Prop\n‚ä¢ LocPathConnectedSpace (Quot r)","decl":"/-- Quotients of locally path-connected spaces are locally path-connected. -/\ninstance Quot.locPathConnectedSpace {r : X ‚Üí X ‚Üí Prop} : LocPathConnectedSpace (Quot r) :=\n  isQuotientMap_quot_mk.locPathConnectedSpace\n\n"}
{"name":"Quotient.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : LocPathConnectedSpace X\ns : Setoid X\n‚ä¢ LocPathConnectedSpace (Quotient s)","decl":"/-- Quotients of locally path-connected spaces are locally path-connected. -/\ninstance Quotient.locPathConnectedSpace {s : Setoid X} : LocPathConnectedSpace (Quotient s) :=\n  isQuotientMap_quotient_mk'.locPathConnectedSpace\n\n\n"}
{"name":"Sum.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"X Y : Type u\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : LocPathConnectedSpace X\ninst‚úù : LocPathConnectedSpace Y\n‚ä¢ LocPathConnectedSpace (Sum X Y)","decl":"/-- Disjoint unions of locally path-connected spaces are locally path-connected. -/\ninstance Sum.locPathConnectedSpace.{u} {X Y : Type u} [TopologicalSpace X] [TopologicalSpace Y]\n    [LocPathConnectedSpace X] [LocPathConnectedSpace Y] :\n    LocPathConnectedSpace (X ‚äï Y) := by\n  rw [locPathConnectedSpace_iff_pathComponentIn_mem_nhds]; intro x u hu hxu; rw [mem_nhds_iff]\n  obtain x | y := x\n  ¬∑ refine ‚ü®Sum.inl '' (pathComponentIn x (Sum.inl ‚Åª¬π' u)), ?_, ?_, ?_‚ü©\n    ¬∑ apply IsPathConnected.subset_pathComponentIn\n      ¬∑ exact (isPathConnected_pathComponentIn (by exact hxu)).image continuous_inl\n      ¬∑ exact ‚ü®x, mem_pathComponentIn_self hxu, rfl‚ü©\n      ¬∑ exact (image_mono pathComponentIn_subset).trans (u.image_preimage_subset _)\n    ¬∑ exact isOpenMap_inl _ <| (hu.preimage continuous_inl).pathComponentIn _\n    ¬∑ exact ‚ü®x, mem_pathComponentIn_self hxu, rfl‚ü©\n  ¬∑ refine ‚ü®Sum.inr '' (pathComponentIn y (Sum.inr ‚Åª¬π' u)), ?_, ?_, ?_‚ü©\n    ¬∑ apply IsPathConnected.subset_pathComponentIn\n      ¬∑ exact (isPathConnected_pathComponentIn (by exact hxu)).image continuous_inr\n      ¬∑ exact ‚ü®y, mem_pathComponentIn_self hxu, rfl‚ü©\n      ¬∑ exact (image_mono pathComponentIn_subset).trans (u.image_preimage_subset _)\n    ¬∑ exact isOpenMap_inr _ <| (hu.preimage continuous_inr).pathComponentIn _\n    ¬∑ exact ‚ü®y, mem_pathComponentIn_self hxu, rfl‚ü©\n\n\n"}
{"name":"Sigma.locPathConnectedSpace","module":"Mathlib.Topology.Connected.PathConnected","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), LocPathConnectedSpace (X i)\n‚ä¢ LocPathConnectedSpace (Sigma fun i => X i)","decl":"/-- Disjoint unions of locally path-connected spaces are locally path-connected. -/\ninstance Sigma.locPathConnectedSpace {X : Œπ ‚Üí Type*}\n    [(i : Œπ) ‚Üí TopologicalSpace (X i)] [(i : Œπ) ‚Üí LocPathConnectedSpace (X i)] :\n    LocPathConnectedSpace ((i : Œπ) √ó X i) := by\n  rw [locPathConnectedSpace_iff_pathComponentIn_mem_nhds]; intro x u hu hxu; rw [mem_nhds_iff]\n  refine ‚ü®(Sigma.mk x.1) '' (pathComponentIn x.2 ((Sigma.mk x.1) ‚Åª¬π' u)), ?_, ?_, ?_‚ü©\n  ¬∑ apply IsPathConnected.subset_pathComponentIn\n    ¬∑ exact (isPathConnected_pathComponentIn (by exact hxu)).image continuous_sigmaMk\n    ¬∑ exact ‚ü®x.2, mem_pathComponentIn_self hxu, rfl‚ü©\n    ¬∑ exact (image_mono pathComponentIn_subset).trans (u.image_preimage_subset _)\n  ¬∑ exact isOpenMap_sigmaMk _ <| (hu.preimage continuous_sigmaMk).pathComponentIn _\n  ¬∑ exact ‚ü®x.2, mem_pathComponentIn_self hxu, rfl‚ü©\n\n"}
