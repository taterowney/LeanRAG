{"name":"MultilinearMap.domCoprod_apply","module":"Mathlib.LinearAlgebra.Multilinear.TensorProduct","initialProofState":"R : Type u_1\nι₁ : Type u_2\nι₂ : Type u_3\ninst✝⁶ : CommSemiring R\nN₁ : Type u_6\ninst✝⁵ : AddCommMonoid N₁\ninst✝⁴ : Module R N₁\nN₂ : Type u_7\ninst✝³ : AddCommMonoid N₂\ninst✝² : Module R N₂\nN : Type u_8\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\na : MultilinearMap R (fun x => N) N₁\nb : MultilinearMap R (fun x => N) N₂\nv : Sum ι₁ ι₂ → N\n⊢ Eq ((a.domCoprod b) v) (TensorProduct.tmul R (a fun i => v (Sum.inl i)) (b fun i => v (Sum.inr i)))","decl":"/-- Given two multilinear maps `(ι₁ → N) → N₁` and `(ι₂ → N) → N₂`, this produces the map\n`(ι₁ ⊕ ι₂ → N) → N₁ ⊗ N₂` by taking the coproduct of the domain and the tensor product\nof the codomain.\n\nThis can be thought of as combining `Equiv.sumArrowEquivProdArrow.symm` with\n`TensorProduct.map`, noting that the two operations can't be separated as the intermediate result\nis not a `MultilinearMap`.\n\nWhile this can be generalized to work for dependent `Π i : ι₁, N'₁ i` instead of `ι₁ → N`, doing so\nintroduces `Sum.elim N'₁ N'₂` types in the result which are difficult to work with and not defeq\nto the simple case defined here. See [this zulip thread](\nhttps://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Instances.20on.20.60sum.2Eelim.20A.20B.20i.60/near/218484619).\n-/\n@[simps apply]\ndef domCoprod (a : MultilinearMap R (fun _ : ι₁ => N) N₁)\n    (b : MultilinearMap R (fun _ : ι₂ => N) N₂) :\n    MultilinearMap R (fun _ : ι₁ ⊕ ι₂ => N) (N₁ ⊗[R] N₂) where\n  toFun v := (a fun i => v (Sum.inl i)) ⊗ₜ b fun i => v (Sum.inr i)\n  map_update_add' _ i p q := by\n    letI := (@Sum.inl_injective ι₁ ι₂).decidableEq\n    letI := (@Sum.inr_injective ι₁ ι₂).decidableEq\n    cases i <;> simp [TensorProduct.add_tmul, TensorProduct.tmul_add]\n  map_update_smul' _ i c p := by\n    letI := (@Sum.inl_injective ι₁ ι₂).decidableEq\n    letI := (@Sum.inr_injective ι₁ ι₂).decidableEq\n    cases i <;> simp [TensorProduct.smul_tmul', TensorProduct.tmul_smul]\n\n"}
{"name":"MultilinearMap.domCoprod'_apply","module":"Mathlib.LinearAlgebra.Multilinear.TensorProduct","initialProofState":"R : Type u_1\nι₁ : Type u_2\nι₂ : Type u_3\ninst✝⁶ : CommSemiring R\nN₁ : Type u_6\ninst✝⁵ : AddCommMonoid N₁\ninst✝⁴ : Module R N₁\nN₂ : Type u_7\ninst✝³ : AddCommMonoid N₂\ninst✝² : Module R N₂\nN : Type u_8\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\na : MultilinearMap R (fun x => N) N₁\nb : MultilinearMap R (fun x => N) N₂\n⊢ Eq (MultilinearMap.domCoprod' (TensorProduct.tmul R a b)) (a.domCoprod b)","decl":"@[simp]\ntheorem domCoprod'_apply (a : MultilinearMap R (fun _ : ι₁ => N) N₁)\n    (b : MultilinearMap R (fun _ : ι₂ => N) N₂) : domCoprod' (a ⊗ₜ[R] b) = domCoprod a b :=\n  rfl\n\n"}
{"name":"MultilinearMap.domCoprod_domDomCongr_sumCongr","module":"Mathlib.LinearAlgebra.Multilinear.TensorProduct","initialProofState":"R : Type u_1\nι₁ : Type u_2\nι₂ : Type u_3\nι₃ : Type u_4\nι₄ : Type u_5\ninst✝⁶ : CommSemiring R\nN₁ : Type u_6\ninst✝⁵ : AddCommMonoid N₁\ninst✝⁴ : Module R N₁\nN₂ : Type u_7\ninst✝³ : AddCommMonoid N₂\ninst✝² : Module R N₂\nN : Type u_8\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\na : MultilinearMap R (fun x => N) N₁\nb : MultilinearMap R (fun x => N) N₂\nσa : Equiv ι₁ ι₃\nσb : Equiv ι₂ ι₄\n⊢ Eq (MultilinearMap.domDomCongr (σa.sumCongr σb) (a.domCoprod b)) ((MultilinearMap.domDomCongr σa a).domCoprod (MultilinearMap.domDomCongr σb b))","decl":"/-- When passed an `Equiv.sumCongr`, `MultilinearMap.domDomCongr` distributes over\n`MultilinearMap.domCoprod`. -/\ntheorem domCoprod_domDomCongr_sumCongr (a : MultilinearMap R (fun _ : ι₁ => N) N₁)\n    (b : MultilinearMap R (fun _ : ι₂ => N) N₂) (σa : ι₁ ≃ ι₃) (σb : ι₂ ≃ ι₄) :\n    (a.domCoprod b).domDomCongr (σa.sumCongr σb) =\n      (a.domDomCongr σa).domCoprod (b.domDomCongr σb) :=\n  rfl\n\n"}
