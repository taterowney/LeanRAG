{"name":"Semiquot.mk'.sizeOf_spec","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\ns : Set α\nval : Trunc ↑s\n⊢ Eq (SizeOf.sizeOf { s := s, val := val }) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- A member of `Semiquot α` is classically a nonempty `Set α`,\n  and in the VM is represented by an element of `α`; the relation\n  between these is that the VM element is required to be a member\n  of the set `s`. The specific element of `s` that the VM computes\n  is hidden by a quotient construction, allowing for the representation\n  of nondeterministic functions. -/\n  -- Porting note: removed universe parameter\nstructure Semiquot (α : Type*) where mk' ::\n  /-- Set containing some element of `α`-/\n  s : Set α\n  /-- Assertion of non-emptiness via `Trunc`-/\n  val : Trunc s\n\n"}
{"name":"Semiquot.mk'.inj","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\ns✝ : Set α\nval✝ : Trunc ↑s✝\ns : Set α\nval : Trunc ↑s\nx✝ : Eq { s := s✝, val := val✝ } { s := s, val := val }\n⊢ And (Eq s✝ s) (HEq val✝ val)","decl":"/-- A member of `Semiquot α` is classically a nonempty `Set α`,\n  and in the VM is represented by an element of `α`; the relation\n  between these is that the VM element is required to be a member\n  of the set `s`. The specific element of `s` that the VM computes\n  is hidden by a quotient construction, allowing for the representation\n  of nondeterministic functions. -/\n  -- Porting note: removed universe parameter\nstructure Semiquot (α : Type*) where mk' ::\n  /-- Set containing some element of `α`-/\n  s : Set α\n  /-- Assertion of non-emptiness via `Trunc`-/\n  val : Trunc s\n\n"}
{"name":"Semiquot.mk'.injEq","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\ns✝ : Set α\nval✝ : Trunc ↑s✝\ns : Set α\nval : Trunc ↑s\n⊢ Eq (Eq { s := s✝, val := val✝ } { s := s, val := val }) (And (Eq s✝ s) (HEq val✝ val))","decl":"/-- A member of `Semiquot α` is classically a nonempty `Set α`,\n  and in the VM is represented by an element of `α`; the relation\n  between these is that the VM element is required to be a member\n  of the set `s`. The specific element of `s` that the VM computes\n  is hidden by a quotient construction, allowing for the representation\n  of nondeterministic functions. -/\n  -- Porting note: removed universe parameter\nstructure Semiquot (α : Type*) where mk' ::\n  /-- Set containing some element of `α`-/\n  s : Set α\n  /-- Assertion of non-emptiness via `Trunc`-/\n  val : Trunc s\n\n"}
{"name":"Semiquot.ext_s","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nq₁ q₂ : Semiquot α\n⊢ Iff (Eq q₁ q₂) (Eq q₁.s q₂.s)","decl":"theorem ext_s {q₁ q₂ : Semiquot α} : q₁ = q₂ ↔ q₁.s = q₂.s := by\n  refine ⟨congr_arg _, fun h => ?_⟩\n  cases' q₁ with _ v₁; cases' q₂ with _ v₂; congr\n  exact Subsingleton.helim (congrArg Trunc (congrArg Set.Elem h)) v₁ v₂\n\n"}
{"name":"Semiquot.ext","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nq₁ q₂ : Semiquot α\n⊢ Iff (Eq q₁ q₂) (∀ (a : α), Iff (Membership.mem q₁ a) (Membership.mem q₂ a))","decl":"theorem ext {q₁ q₂ : Semiquot α} : q₁ = q₂ ↔ ∀ a, a ∈ q₁ ↔ a ∈ q₂ :=\n  ext_s.trans Set.ext_iff\n\n"}
{"name":"Semiquot.exists_mem","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nq : Semiquot α\n⊢ Exists fun a => Membership.mem q a","decl":"theorem exists_mem (q : Semiquot α) : ∃ a, a ∈ q :=\n  let ⟨⟨a, h⟩, _⟩ := q.2.exists_rep\n  ⟨a, h⟩\n\n"}
{"name":"Semiquot.eq_mk_of_mem","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nq : Semiquot α\na : α\nh : Membership.mem q a\n⊢ Eq q (Semiquot.mk h)","decl":"theorem eq_mk_of_mem {q : Semiquot α} {a : α} (h : a ∈ q) : q = @mk _ a q.1 h :=\n  ext_s.2 rfl\n\n"}
{"name":"Semiquot.nonempty","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nq : Semiquot α\n⊢ q.s.Nonempty","decl":"theorem nonempty (q : Semiquot α) : q.s.Nonempty :=\n  q.exists_mem\n\n"}
{"name":"Semiquot.mem_pure'","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Membership.mem (Semiquot.pure b) a) (Eq a b)","decl":"@[simp]\ntheorem mem_pure' {a b : α} : a ∈ Semiquot.pure b ↔ a = b :=\n  Set.mem_singleton_iff\n\n"}
{"name":"Semiquot.blur_eq_blur'","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nq : Semiquot α\ns : Set α\nh : HasSubset.Subset q.s s\n⊢ Eq (Semiquot.blur s q) (q.blur' h)","decl":"theorem blur_eq_blur' (q : Semiquot α) (s : Set α) (h : q.s ⊆ s) : blur s q = blur' q h := by\n  unfold blur; congr; exact Set.union_eq_self_of_subset_right h\n\n"}
{"name":"Semiquot.mem_blur'","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nq : Semiquot α\ns : Set α\nh : HasSubset.Subset q.s s\na : α\n⊢ Iff (Membership.mem (q.blur' h) a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_blur' (q : Semiquot α) {s : Set α} (h : q.s ⊆ s) {a : α} : a ∈ blur' q h ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Semiquot.liftOn_ofMem","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nβ : Type u_2\nq : Semiquot α\nf : α → β\nh : ∀ (a : α), Membership.mem q a → ∀ (b : α), Membership.mem q b → Eq (f a) (f b)\na : α\naq : Membership.mem q a\n⊢ Eq (q.liftOn f h) (f a)","decl":"theorem liftOn_ofMem (q : Semiquot α) (f : α → β)\n    (h : ∀ a ∈ q, ∀ b ∈ q, f a = f b) (a : α) (aq : a ∈ q) : liftOn q f h = f a := by\n  revert h; rw [eq_mk_of_mem aq]; intro; rfl\n\n"}
{"name":"Semiquot.mem_map","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nq : Semiquot α\nb : β\n⊢ Iff (Membership.mem (Semiquot.map f q) b) (Exists fun a => And (Membership.mem q a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_map (f : α → β) (q : Semiquot α) (b : β) : b ∈ map f q ↔ ∃ a, a ∈ q ∧ f a = b :=\n  Set.mem_image _ _ _\n\n"}
{"name":"Semiquot.mem_bind","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nβ : Type u_2\nq : Semiquot α\nf : α → Semiquot β\nb : β\n⊢ Iff (Membership.mem (q.bind f) b) (Exists fun a => And (Membership.mem q a) (Membership.mem (f a) b))","decl":"@[simp]\ntheorem mem_bind (q : Semiquot α) (f : α → Semiquot β) (b : β) :\n    b ∈ bind q f ↔ ∃ a ∈ q, b ∈ f a := by simp_rw [← exists_prop]; exact Set.mem_iUnion₂\n\n"}
{"name":"Semiquot.map_def","module":"Mathlib.Data.Semiquot","initialProofState":"α β : Type u_1\n⊢ Eq (fun x1 x2 => Functor.map x1 x2) Semiquot.map","decl":"@[simp]\ntheorem map_def {β} : ((· <$> ·) : (α → β) → Semiquot α → Semiquot β) = map :=\n  rfl\n\n"}
{"name":"Semiquot.bind_def","module":"Mathlib.Data.Semiquot","initialProofState":"α β : Type u_1\n⊢ Eq (fun x1 x2 => Bind.bind x1 x2) Semiquot.bind","decl":"@[simp]\ntheorem bind_def {β} : ((· >>= ·) : Semiquot α → (α → Semiquot β) → Semiquot β) = bind :=\n  rfl\n\n"}
{"name":"Semiquot.mem_pure","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Membership.mem (Pure.pure b) a) (Eq a b)","decl":"@[simp]\ntheorem mem_pure {a b : α} : a ∈ (pure b : Semiquot α) ↔ a = b :=\n  Set.mem_singleton_iff\n\n"}
{"name":"Semiquot.mem_pure_self","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\na : α\n⊢ Membership.mem (Pure.pure a) a","decl":"theorem mem_pure_self (a : α) : a ∈ (pure a : Semiquot α) :=\n  Set.mem_singleton a\n\n"}
{"name":"Semiquot.pure_inj","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq (Pure.pure a) (Pure.pure b)) (Eq a b)","decl":"@[simp]\ntheorem pure_inj {a b : α} : (pure a : Semiquot α) = pure b ↔ a = b :=\n  ext_s.trans Set.singleton_eq_singleton_iff\n\n"}
{"name":"Semiquot.instLawfulMonad","module":"Mathlib.Data.Semiquot","initialProofState":"⊢ LawfulMonad Semiquot","decl":"instance : LawfulMonad Semiquot := LawfulMonad.mk'\n  (pure_bind := fun {α β} x f => ext.2 <| by simp)\n  (bind_assoc := fun {α β} γ s f g =>\n    ext.2 <| by\n    simp only [bind_def, mem_bind]\n    exact fun c => ⟨fun ⟨b, ⟨a, as, bf⟩, cg⟩ => ⟨a, as, b, bf, cg⟩,\n      fun ⟨a, as, b, bf, cg⟩ => ⟨b, ⟨a, as, bf⟩, cg⟩⟩)\n  (id_map := fun {α} q => ext.2 <| by simp)\n  (bind_pure_comp := fun {α β} f s => ext.2 <| by simp [eq_comm])\n\n"}
{"name":"Semiquot.pure_le","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\na : α\ns : Semiquot α\n⊢ Iff (LE.le (Pure.pure a) s) (Membership.mem s a)","decl":"@[simp]\ntheorem pure_le {a : α} {s : Semiquot α} : pure a ≤ s ↔ a ∈ s :=\n  Set.singleton_subset_iff\n\n"}
{"name":"Semiquot.get_mem","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nq : Semiquot α\np : q.IsPure\n⊢ Membership.mem q (q.get p)","decl":"theorem get_mem {q : Semiquot α} (p) : get q p ∈ q := by\n  let ⟨a, h⟩ := exists_mem q\n  unfold get; rw [liftOn_ofMem q _ _ a h]; exact h\n\n"}
{"name":"Semiquot.eq_pure","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nq : Semiquot α\np : q.IsPure\n⊢ Eq q (Pure.pure (q.get p))","decl":"theorem eq_pure {q : Semiquot α} (p) : q = pure (get q p) :=\n  ext.2 fun a => by simpa using ⟨fun h => p _ h _ (get_mem _), fun e => e.symm ▸ get_mem _⟩\n\n"}
{"name":"Semiquot.pure_isPure","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\na : α\n⊢ (Pure.pure a).IsPure","decl":"@[simp]\ntheorem pure_isPure (a : α) : IsPure (pure a)\n  | b, ab, c, ac => by\n    rw [mem_pure] at ab ac\n    rwa [← ac] at ab\n\n"}
{"name":"Semiquot.isPure_iff","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\ns : Semiquot α\n⊢ Iff s.IsPure (Exists fun a => Eq s (Pure.pure a))","decl":"theorem isPure_iff {s : Semiquot α} : IsPure s ↔ ∃ a, s = pure a :=\n  ⟨fun h => ⟨_, eq_pure h⟩, fun ⟨_, e⟩ => e.symm ▸ pure_isPure _⟩\n\n"}
{"name":"Semiquot.IsPure.mono","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\ns t : Semiquot α\nst : LE.le s t\nh : t.IsPure\n⊢ s.IsPure","decl":"theorem IsPure.mono {s t : Semiquot α} (st : s ≤ t) (h : IsPure t) : IsPure s\n  | _, as, _, bs => h _ (st as) _ (st bs)\n\n"}
{"name":"Semiquot.IsPure.min","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\ns t : Semiquot α\nh : t.IsPure\n⊢ Iff (LE.le s t) (Eq s t)","decl":"theorem IsPure.min {s t : Semiquot α} (h : IsPure t) : s ≤ t ↔ s = t :=\n  ⟨fun st =>\n    le_antisymm st <| by\n      rw [eq_pure h, eq_pure (h.mono st)]; simpa using h _ (get_mem _) _ (st <| get_mem _),\n    le_of_eq⟩\n\n"}
{"name":"Semiquot.isPure_of_subsingleton","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\nq : Semiquot α\n⊢ q.IsPure","decl":"theorem isPure_of_subsingleton [Subsingleton α] (q : Semiquot α) : IsPure q\n  | _, _, _, _ => Subsingleton.elim _ _\n\n"}
{"name":"Semiquot.mem_univ","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\na : α\n⊢ Membership.mem Semiquot.univ a","decl":"@[simp]\ntheorem mem_univ [Inhabited α] : ∀ a, a ∈ @univ α _ :=\n  @Set.mem_univ α\n\n"}
{"name":"Semiquot.univ_unique","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\nI J : Inhabited α\n⊢ Eq Semiquot.univ Semiquot.univ","decl":"@[congr]\ntheorem univ_unique (I J : Inhabited α) : @univ _ I = @univ _ J :=\n  ext.2 fun a => refl (a ∈ univ)\n\n"}
{"name":"Semiquot.isPure_univ","module":"Mathlib.Data.Semiquot","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\n⊢ Iff Semiquot.univ.IsPure (Subsingleton α)","decl":"@[simp]\ntheorem isPure_univ [Inhabited α] : @IsPure α univ ↔ Subsingleton α :=\n  ⟨fun h => ⟨fun a b => h a trivial b trivial⟩, fun ⟨h⟩ a _ b _ => h a b⟩\n\n"}
