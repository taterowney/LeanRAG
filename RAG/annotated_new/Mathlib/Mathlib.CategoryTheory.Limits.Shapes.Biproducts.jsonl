{"name":"CategoryTheory.Limits.Bicone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nptâœ : C\nÏ€âœ : (j : J) â†’ Quiver.Hom ptâœ (F j)\nÎ¹âœ : (j : J) â†’ Quiver.Hom (F j) ptâœ\nÎ¹_Ï€âœ : autoParam (âˆ€ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (Î¹âœ j) (Ï€âœ j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0)) _autoâœ\npt : C\nÏ€ : (j : J) â†’ Quiver.Hom pt (F j)\nÎ¹ : (j : J) â†’ Quiver.Hom (F j) pt\nÎ¹_Ï€ : autoParam (âˆ€ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (Î¹ j) (Ï€ j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0)) _autoâœ\nâŠ¢ Eq (Eq { pt := ptâœ, Ï€ := Ï€âœ, Î¹ := Î¹âœ, Î¹_Ï€ := Î¹_Ï€âœ } { pt := pt, Ï€ := Ï€, Î¹ := Î¹, Î¹_Ï€ := Î¹_Ï€ }) (And (Eq ptâœ pt) (And (HEq Ï€âœ Ï€) (HEq Î¹âœ Î¹)))","decl":"open scoped Classical in\n/-- A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `Ï€ j : pt âŸ¶ F j` and `Î¹ j : F j âŸ¶ pt` for each `j`,\n* such that `Î¹ j â‰« Ï€ j'` is the identity when `j = j'` and zero otherwise.\n-/\nstructure Bicone (F : J â†’ C) where\n  pt : C\n  Ï€ : âˆ€ j, pt âŸ¶ F j\n  Î¹ : âˆ€ j, F j âŸ¶ pt\n  Î¹_Ï€ : âˆ€ j j', Î¹ j â‰« Ï€ j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n\n"}
{"name":"CategoryTheory.Limits.Bicone.Î¹_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nself : CategoryTheory.Limits.Bicone F\nj j' : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.Î¹ j) (self.Ï€ j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0)","decl":"open scoped Classical in\n/-- A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `Ï€ j : pt âŸ¶ F j` and `Î¹ j : F j âŸ¶ pt` for each `j`,\n* such that `Î¹ j â‰« Ï€ j'` is the identity when `j = j'` and zero otherwise.\n-/\nstructure Bicone (F : J â†’ C) where\n  pt : C\n  Ï€ : âˆ€ j, pt âŸ¶ F j\n  Î¹ : âˆ€ j, F j âŸ¶ pt\n  Î¹_Ï€ : âˆ€ j j', Î¹ j â‰« Ï€ j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n\n"}
{"name":"CategoryTheory.Limits.Bicone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nptâœ : C\nÏ€âœ : (j : J) â†’ Quiver.Hom ptâœ (F j)\nÎ¹âœ : (j : J) â†’ Quiver.Hom (F j) ptâœ\nÎ¹_Ï€âœ : autoParam (âˆ€ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (Î¹âœ j) (Ï€âœ j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0)) _autoâœ\npt : C\nÏ€ : (j : J) â†’ Quiver.Hom pt (F j)\nÎ¹ : (j : J) â†’ Quiver.Hom (F j) pt\nÎ¹_Ï€ : autoParam (âˆ€ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (Î¹ j) (Ï€ j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0)) _autoâœ\nxâœ : Eq { pt := ptâœ, Ï€ := Ï€âœ, Î¹ := Î¹âœ, Î¹_Ï€ := Î¹_Ï€âœ } { pt := pt, Ï€ := Ï€, Î¹ := Î¹, Î¹_Ï€ := Î¹_Ï€ }\nâŠ¢ And (Eq ptâœ pt) (And (HEq Ï€âœ Ï€) (HEq Î¹âœ Î¹))","decl":"open scoped Classical in\n/-- A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `Ï€ j : pt âŸ¶ F j` and `Î¹ j : F j âŸ¶ pt` for each `j`,\n* such that `Î¹ j â‰« Ï€ j'` is the identity when `j = j'` and zero otherwise.\n-/\nstructure Bicone (F : J â†’ C) where\n  pt : C\n  Ï€ : âˆ€ j, pt âŸ¶ F j\n  Î¹ : âˆ€ j, F j âŸ¶ pt\n  Î¹_Ï€ : âˆ€ j j', Î¹ j â‰« Ï€ j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n\n"}
{"name":"CategoryTheory.Limits.Bicone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ³ : CategoryTheory.Category.{uC', uC} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\ninstâœÂ¹ : SizeOf J\ninstâœ : SizeOf C\npt : C\nÏ€ : (j : J) â†’ Quiver.Hom pt (F j)\nÎ¹ : (j : J) â†’ Quiver.Hom (F j) pt\nÎ¹_Ï€ : autoParam (âˆ€ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (Î¹ j) (Ï€ j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { pt := pt, Ï€ := Ï€, Î¹ := Î¹, Î¹_Ï€ := Î¹_Ï€ }) (HAdd.hAdd 1 (SizeOf.sizeOf pt))","decl":"open scoped Classical in\n/-- A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `Ï€ j : pt âŸ¶ F j` and `Î¹ j : F j âŸ¶ pt` for each `j`,\n* such that `Î¹ j â‰« Ï€ j'` is the identity when `j = j'` and zero otherwise.\n-/\nstructure Bicone (F : J â†’ C) where\n  pt : C\n  Ï€ : âˆ€ j, pt âŸ¶ F j\n  Î¹ : âˆ€ j, F j âŸ¶ pt\n  Î¹_Ï€ : âˆ€ j j', Î¹ j â‰« Ï€ j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n\n"}
{"name":"CategoryTheory.Limits.bicone_Î¹_Ï€_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (B.Î¹ j) (B.Ï€ j)) (CategoryTheory.CategoryStruct.id (F j))","decl":"@[reassoc (attr := simp)]\ntheorem bicone_Î¹_Ï€_self {F : J â†’ C} (B : Bicone F) (j : J) : B.Î¹ j â‰« B.Ï€ j = ğŸ™ (F j) := by\n  simpa using B.Î¹_Ï€ j j\n\n"}
{"name":"CategoryTheory.Limits.bicone_Î¹_Ï€_self_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj : J\nZ : C\nh : Quiver.Hom (F j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (B.Î¹ j) (CategoryTheory.CategoryStruct.comp (B.Ï€ j) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem bicone_Î¹_Ï€_self {F : J â†’ C} (B : Bicone F) (j : J) : B.Î¹ j â‰« B.Ï€ j = ğŸ™ (F j) := by\n  simpa using B.Î¹_Ï€ j j\n\n"}
{"name":"CategoryTheory.Limits.bicone_Î¹_Ï€_ne_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj j' : J\nhâœ : Ne j j'\nZ : C\nh : Quiver.Hom (F j') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (B.Î¹ j) (CategoryTheory.CategoryStruct.comp (B.Ï€ j') h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem bicone_Î¹_Ï€_ne {F : J â†’ C} (B : Bicone F) {j j' : J} (h : j â‰  j') : B.Î¹ j â‰« B.Ï€ j' = 0 := by\n  simpa [h] using B.Î¹_Ï€ j j'\n\n"}
{"name":"CategoryTheory.Limits.bicone_Î¹_Ï€_ne","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj j' : J\nh : Ne j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (B.Î¹ j) (B.Ï€ j')) 0","decl":"@[reassoc (attr := simp)]\ntheorem bicone_Î¹_Ï€_ne {F : J â†’ C} (B : Bicone F) {j j' : J} (h : j â‰  j') : B.Î¹ j â‰« B.Ï€ j' = 0 := by\n  simpa [h] using B.Î¹_Ï€ j j'\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.wÎ¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nA B : CategoryTheory.Limits.Bicone F\nself : CategoryTheory.Limits.BiconeMorphism A B\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (A.Î¹ j) self.hom) (B.Î¹ j)","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J â†’ C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÏ€ : âˆ€ j : J, hom â‰« B.Ï€ j = A.Ï€ j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÎ¹ : âˆ€ j : J, A.Î¹ j â‰« hom = B.Î¹ j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.wÏ€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nA B : CategoryTheory.Limits.Bicone F\nself : CategoryTheory.Limits.BiconeMorphism A B\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.hom (B.Ï€ j)) (A.Ï€ j)","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J â†’ C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÏ€ : âˆ€ j : J, hom â‰« B.Ï€ j = A.Ï€ j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÎ¹ : âˆ€ j : J, A.Î¹ j â‰« hom = B.Î¹ j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nA B : CategoryTheory.Limits.Bicone F\nhomâœ : Quiver.Hom A.pt B.pt\nwÏ€âœ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp homâœ (B.Ï€ j)) (A.Ï€ j)) _autoâœ\nwÎ¹âœ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Î¹ j) homâœ) (B.Î¹ j)) _autoâœ\nhom : Quiver.Hom A.pt B.pt\nwÏ€ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.Ï€ j)) (A.Ï€ j)) _autoâœ\nwÎ¹ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Î¹ j) hom) (B.Î¹ j)) _autoâœ\nxâœ : Eq { hom := homâœ, wÏ€ := wÏ€âœ, wÎ¹ := wÎ¹âœ } { hom := hom, wÏ€ := wÏ€, wÎ¹ := wÎ¹ }\nâŠ¢ Eq homâœ hom","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J â†’ C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÏ€ : âˆ€ j : J, hom â‰« B.Ï€ j = A.Ï€ j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÎ¹ : âˆ€ j : J, A.Î¹ j â‰« hom = B.Î¹ j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nA B : CategoryTheory.Limits.Bicone F\nhomâœ : Quiver.Hom A.pt B.pt\nwÏ€âœ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp homâœ (B.Ï€ j)) (A.Ï€ j)) _autoâœ\nwÎ¹âœ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Î¹ j) homâœ) (B.Î¹ j)) _autoâœ\nhom : Quiver.Hom A.pt B.pt\nwÏ€ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.Ï€ j)) (A.Ï€ j)) _autoâœ\nwÎ¹ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Î¹ j) hom) (B.Î¹ j)) _autoâœ\nâŠ¢ Eq (Eq { hom := homâœ, wÏ€ := wÏ€âœ, wÎ¹ := wÎ¹âœ } { hom := hom, wÏ€ := wÏ€, wÎ¹ := wÎ¹ }) (Eq homâœ hom)","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J â†’ C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÏ€ : âˆ€ j : J, hom â‰« B.Ï€ j = A.Ï€ j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÎ¹ : âˆ€ j : J, A.Î¹ j â‰« hom = B.Î¹ j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ³ : CategoryTheory.Category.{uC', uC} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nA B : CategoryTheory.Limits.Bicone F\ninstâœÂ¹ : SizeOf J\ninstâœ : SizeOf C\nhom : Quiver.Hom A.pt B.pt\nwÏ€ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.Ï€ j)) (A.Ï€ j)) _autoâœ\nwÎ¹ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.Î¹ j) hom) (B.Î¹ j)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { hom := hom, wÏ€ := wÏ€, wÎ¹ := wÎ¹ }) (HAdd.hAdd 1 (SizeOf.sizeOf hom))","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J â†’ C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÏ€ : âˆ€ j : J, hom â‰« B.Ï€ j = A.Ï€ j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wÎ¹ : âˆ€ j : J, A.Î¹ j â‰« hom = B.Î¹ j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.wÎ¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nA B : CategoryTheory.Limits.Bicone F\nself : CategoryTheory.Limits.BiconeMorphism A B\nj : J\nZ : C\nh : Quiver.Hom B.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (A.Î¹ j) (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (B.Î¹ j) h)","decl":"attribute [reassoc (attr := simp)] BiconeMorphism.wÎ¹\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.wÏ€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nA B : CategoryTheory.Limits.Bicone F\nself : CategoryTheory.Limits.BiconeMorphism A B\nj : J\nZ : C\nh : Quiver.Hom (F j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp (B.Ï€ j) h)) (CategoryTheory.CategoryStruct.comp (A.Ï€ j) h)","decl":"attribute [reassoc (attr := simp)] BiconeMorphism.wÏ€\n\n"}
{"name":"CategoryTheory.Limits.Bicone.category_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nXâœ Yâœ Zâœ : CategoryTheory.Limits.Bicone F\nf : Quiver.Hom Xâœ Yâœ\ng : Quiver.Hom Yâœ Zâœ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- The category of bicones on a given diagram. -/\n@[simps]\ninstance Bicone.category : Category (Bicone F) where\n  Hom A B := BiconeMorphism A B\n  comp f g := { hom := f.hom â‰« g.hom }\n  id B := { hom := ğŸ™ B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the `hom` field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.Bicone.category_id_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id B).hom (CategoryTheory.CategoryStruct.id B.pt)","decl":"/-- The category of bicones on a given diagram. -/\n@[simps]\ninstance Bicone.category : Category (Bicone F) where\n  Hom A B := BiconeMorphism A B\n  comp f g := { hom := f.hom â‰« g.hom }\n  id B := { hom := ğŸ™ B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the `hom` field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nc c' : CategoryTheory.Limits.Bicone F\nf g : Quiver.Hom c c'\nw : Eq f.hom g.hom\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem BiconeMorphism.ext {c c' : Bicone F} (f g : c âŸ¶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nc c' : CategoryTheory.Limits.Bicone F\nf g : Quiver.Hom c c'\nâŠ¢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\ntheorem BiconeMorphism.ext {c c' : Bicone F} (f g : c âŸ¶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.Bicones.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nc c' : CategoryTheory.Limits.Bicone F\nÏ† : CategoryTheory.Iso c.pt c'.pt\nwÎ¹ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (c.Î¹ j) Ï†.hom) (c'.Î¹ j)) _autoâœ\nwÏ€ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp Ï†.hom (c'.Ï€ j)) (c.Ï€ j)) _autoâœ\nâŠ¢ Eq (CategoryTheory.Limits.Bicones.ext Ï† wÎ¹ wÏ€).hom.hom Ï†.hom","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Bicone F} (Ï† : c.pt â‰… c'.pt)\n    (wÎ¹ : âˆ€ j, c.Î¹ j â‰« Ï†.hom = c'.Î¹ j := by aesop_cat)\n    (wÏ€ : âˆ€ j, Ï†.hom â‰« c'.Ï€ j = c.Ï€ j := by aesop_cat) : c â‰… c' where\n  hom := { hom := Ï†.hom }\n  inv :=\n    { hom := Ï†.inv\n      wÎ¹ := fun j => Ï†.comp_inv_eq.mpr (wÎ¹ j).symm\n      wÏ€ := fun j => Ï†.inv_comp_eq.mpr (wÏ€ j).symm  }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nc c' : CategoryTheory.Limits.Bicone F\nÏ† : CategoryTheory.Iso c.pt c'.pt\nwÎ¹ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (c.Î¹ j) Ï†.hom) (c'.Î¹ j)) _autoâœ\nwÏ€ : autoParam (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp Ï†.hom (c'.Ï€ j)) (c.Ï€ j)) _autoâœ\nâŠ¢ Eq (CategoryTheory.Limits.Bicones.ext Ï† wÎ¹ wÏ€).inv.hom Ï†.inv","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Bicone F} (Ï† : c.pt â‰… c'.pt)\n    (wÎ¹ : âˆ€ j, c.Î¹ j â‰« Ï†.hom = c'.Î¹ j := by aesop_cat)\n    (wÏ€ : âˆ€ j, Ï†.hom â‰« c'.Ï€ j = c.Ï€ j := by aesop_cat) : c â‰… c' where\n  hom := { hom := Ï†.hom }\n  inv :=\n    { hom := Ï†.inv\n      wÎ¹ := fun j => Ï†.comp_inv_eq.mpr (wÎ¹ j).symm\n      wÏ€ := fun j => Ï†.inv_comp_eq.mpr (wÏ€ j).symm  }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœâ´ : CategoryTheory.Category.{uC', uC} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ² : CategoryTheory.Category.{uD', uD} D\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J â†’ C\nG : CategoryTheory.Functor C D\ninstâœ : G.PreservesZeroMorphisms\nA : CategoryTheory.Limits.Bicone F\nâŠ¢ Eq ((CategoryTheory.Limits.Bicones.functoriality F G).obj A).pt (G.obj A.pt)","decl":"variable (F) in\n/-- A functor `G : C â¥¤ D` sends bicones over `F` to bicones over `G.obj âˆ˜ F` functorially. -/\n@[simps]\ndef functoriality (G : C â¥¤ D) [Functor.PreservesZeroMorphisms G] :\n    Bicone F â¥¤ Bicone (G.obj âˆ˜ F) where\n  obj A :=\n    { pt := G.obj A.pt\n      Ï€ := fun j => G.map (A.Ï€ j)\n      Î¹ := fun j => G.map (A.Î¹ j)\n      Î¹_Ï€ := fun i j => (Functor.map_comp _ _ _).symm.trans <| by\n        rw [A.Î¹_Ï€]\n        aesop_cat }\n  map f :=\n    { hom := G.map f.hom\n      wÏ€ := fun j => by simp [-BiconeMorphism.wÏ€, â† f.wÏ€ j]\n      wÎ¹ := fun j => by simp [-BiconeMorphism.wÎ¹, â† f.wÎ¹ j] }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_obj_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœâ´ : CategoryTheory.Category.{uC', uC} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ² : CategoryTheory.Category.{uD', uD} D\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J â†’ C\nG : CategoryTheory.Functor C D\ninstâœ : G.PreservesZeroMorphisms\nA : CategoryTheory.Limits.Bicone F\nj : J\nâŠ¢ Eq (((CategoryTheory.Limits.Bicones.functoriality F G).obj A).Ï€ j) (G.map (A.Ï€ j))","decl":"variable (F) in\n/-- A functor `G : C â¥¤ D` sends bicones over `F` to bicones over `G.obj âˆ˜ F` functorially. -/\n@[simps]\ndef functoriality (G : C â¥¤ D) [Functor.PreservesZeroMorphisms G] :\n    Bicone F â¥¤ Bicone (G.obj âˆ˜ F) where\n  obj A :=\n    { pt := G.obj A.pt\n      Ï€ := fun j => G.map (A.Ï€ j)\n      Î¹ := fun j => G.map (A.Î¹ j)\n      Î¹_Ï€ := fun i j => (Functor.map_comp _ _ _).symm.trans <| by\n        rw [A.Î¹_Ï€]\n        aesop_cat }\n  map f :=\n    { hom := G.map f.hom\n      wÏ€ := fun j => by simp [-BiconeMorphism.wÏ€, â† f.wÏ€ j]\n      wÎ¹ := fun j => by simp [-BiconeMorphism.wÎ¹, â† f.wÎ¹ j] }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœâ´ : CategoryTheory.Category.{uC', uC} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ² : CategoryTheory.Category.{uD', uD} D\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J â†’ C\nG : CategoryTheory.Functor C D\ninstâœ : G.PreservesZeroMorphisms\nXâœ Yâœ : CategoryTheory.Limits.Bicone F\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Limits.Bicones.functoriality F G).map f).hom (G.map f.hom)","decl":"variable (F) in\n/-- A functor `G : C â¥¤ D` sends bicones over `F` to bicones over `G.obj âˆ˜ F` functorially. -/\n@[simps]\ndef functoriality (G : C â¥¤ D) [Functor.PreservesZeroMorphisms G] :\n    Bicone F â¥¤ Bicone (G.obj âˆ˜ F) where\n  obj A :=\n    { pt := G.obj A.pt\n      Ï€ := fun j => G.map (A.Ï€ j)\n      Î¹ := fun j => G.map (A.Î¹ j)\n      Î¹_Ï€ := fun i j => (Functor.map_comp _ _ _).symm.trans <| by\n        rw [A.Î¹_Ï€]\n        aesop_cat }\n  map f :=\n    { hom := G.map f.hom\n      wÏ€ := fun j => by simp [-BiconeMorphism.wÏ€, â† f.wÏ€ j]\n      wÎ¹ := fun j => by simp [-BiconeMorphism.wÎ¹, â† f.wÎ¹ j] }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_obj_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœâ´ : CategoryTheory.Category.{uC', uC} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ² : CategoryTheory.Category.{uD', uD} D\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J â†’ C\nG : CategoryTheory.Functor C D\ninstâœ : G.PreservesZeroMorphisms\nA : CategoryTheory.Limits.Bicone F\nj : J\nâŠ¢ Eq (((CategoryTheory.Limits.Bicones.functoriality F G).obj A).Î¹ j) (G.map (A.Î¹ j))","decl":"variable (F) in\n/-- A functor `G : C â¥¤ D` sends bicones over `F` to bicones over `G.obj âˆ˜ F` functorially. -/\n@[simps]\ndef functoriality (G : C â¥¤ D) [Functor.PreservesZeroMorphisms G] :\n    Bicone F â¥¤ Bicone (G.obj âˆ˜ F) where\n  obj A :=\n    { pt := G.obj A.pt\n      Ï€ := fun j => G.map (A.Ï€ j)\n      Î¹ := fun j => G.map (A.Î¹ j)\n      Î¹_Ï€ := fun i j => (Functor.map_comp _ _ _).symm.trans <| by\n        rw [A.Î¹_Ï€]\n        aesop_cat }\n  map f :=\n    { hom := G.map f.hom\n      wÏ€ := fun j => by simp [-BiconeMorphism.wÏ€, â† f.wÏ€ j]\n      wÎ¹ := fun j => by simp [-BiconeMorphism.wÎ¹, â† f.wÎ¹ j] }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_full","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœâ¶ : CategoryTheory.Category.{uC', uC} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœâ´ : CategoryTheory.Category.{uD', uD} D\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J â†’ C\nG : CategoryTheory.Functor C D\ninstâœÂ² : G.PreservesZeroMorphisms\ninstâœÂ¹ : G.Full\ninstâœ : G.Faithful\nâŠ¢ (CategoryTheory.Limits.Bicones.functoriality F G).Full","decl":"instance functoriality_full [G.PreservesZeroMorphisms] [G.Full] [G.Faithful] :\n    (functoriality F G).Full where\n  map_surjective t :=\n   âŸ¨{ hom := G.preimage t.hom\n      wÎ¹ := fun j => G.map_injective (by simpa using t.wÎ¹ j)\n      wÏ€ := fun j => G.map_injective (by simpa using t.wÏ€ j) }, by aesop_catâŸ©\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_faithful","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœâµ : CategoryTheory.Category.{uC', uC} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ³ : CategoryTheory.Category.{uD', uD} D\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms D\nF : J â†’ C\nG : CategoryTheory.Functor C D\ninstâœÂ¹ : G.PreservesZeroMorphisms\ninstâœ : G.Faithful\nâŠ¢ (CategoryTheory.Limits.Bicones.functoriality F G).Faithful","decl":"instance functoriality_faithful [G.PreservesZeroMorphisms] [G.Faithful] :\n    (functoriality F G).Faithful where\n  map_injective {_X} {_Y} f g h :=\n    BiconeMorphism.ext f g <| G.map_injective <| congr_arg BiconeMorphism.hom h\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nâŠ¢ Eq B.toCone.pt B.pt","decl":"@[simp]\ntheorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCone_Ï€_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj : CategoryTheory.Discrete J\nâŠ¢ Eq (B.toCone.Ï€.app j) (B.Ï€ j.as)","decl":"@[simp]\ntheorem toCone_Ï€_app (B : Bicone F) (j : Discrete J) : B.toCone.Ï€.app j = B.Ï€ j.as := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCone_Ï€_app_mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj : J\nâŠ¢ Eq (B.toCone.Ï€.app { as := j }) (B.Ï€ j)","decl":"theorem toCone_Ï€_app_mk (B : Bicone F) (j : J) : B.toCone.Ï€.app âŸ¨jâŸ© = B.Ï€ j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCone_proj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj : J\nâŠ¢ Eq (CategoryTheory.Limits.Fan.proj B.toCone j) (B.Ï€ j)","decl":"@[simp]\ntheorem toCone_proj (B : Bicone F) (j : J) : Fan.proj B.toCone j = B.Ï€ j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nâŠ¢ Eq B.toCocone.pt B.pt","decl":"@[simp]\ntheorem toCocone_pt (B : Bicone F) : B.toCocone.pt = B.pt := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCocone_Î¹_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj : CategoryTheory.Discrete J\nâŠ¢ Eq (B.toCocone.Î¹.app j) (B.Î¹ j.as)","decl":"@[simp]\ntheorem toCocone_Î¹_app (B : Bicone F) (j : Discrete J) : B.toCocone.Î¹.app j = B.Î¹ j.as := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCocone_inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj : J\nâŠ¢ Eq (CategoryTheory.Limits.Cofan.inj B.toCocone j) (B.Î¹ j)","decl":"@[simp]\ntheorem toCocone_inj (B : Bicone F) (j : J) : Cofan.inj B.toCocone j = B.Î¹ j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCocone_Î¹_app_mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nj : J\nâŠ¢ Eq (B.toCocone.Î¹.app { as := j }) (B.Î¹ j)","decl":"theorem toCocone_Î¹_app_mk (B : Bicone F) (j : J) : B.toCocone.Î¹.app âŸ¨jâŸ© = B.Î¹ j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofLimitCone_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsLimit t\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.Bicone.ofLimitCone ht).Ï€ j) (t.Ï€.app { as := j })","decl":"open scoped Classical in\n/-- We can turn any limit cone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofLimitCone {f : J â†’ C} {t : Cone (Discrete.functor f)} (ht : IsLimit t) : Bicone f where\n  pt := t.pt\n  Ï€ j := t.Ï€.app âŸ¨jâŸ©\n  Î¹ j := ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0)\n  Î¹_Ï€ j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofLimitCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsLimit t\nâŠ¢ Eq (CategoryTheory.Limits.Bicone.ofLimitCone ht).pt t.pt","decl":"open scoped Classical in\n/-- We can turn any limit cone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofLimitCone {f : J â†’ C} {t : Cone (Discrete.functor f)} (ht : IsLimit t) : Bicone f where\n  pt := t.pt\n  Ï€ j := t.Ï€.app âŸ¨jâŸ©\n  Î¹ j := ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0)\n  Î¹_Ï€ j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofLimitCone_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsLimit t\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.Bicone.ofLimitCone ht).Î¹ j) (ht.lift (CategoryTheory.Limits.Fan.mk (f j) fun j' => dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0))","decl":"open scoped Classical in\n/-- We can turn any limit cone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofLimitCone {f : J â†’ C} {t : Cone (Discrete.functor f)} (ht : IsLimit t) : Bicone f where\n  pt := t.pt\n  Ï€ j := t.Ï€.app âŸ¨jâŸ©\n  Î¹ j := ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0)\n  Î¹_Ï€ j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.Î¹_of_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\nt : CategoryTheory.Limits.Bicone f\nht : CategoryTheory.Limits.IsLimit t.toCone\nj : J\nâŠ¢ Eq (t.Î¹ j) (ht.lift (CategoryTheory.Limits.Fan.mk (f j) fun j' => dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0))","decl":"open scoped Classical in\ntheorem Î¹_of_isLimit {f : J â†’ C} {t : Bicone f} (ht : IsLimit t.toCone) (j : J) :\n    t.Î¹ j = ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0) :=\n  ht.hom_ext fun j' => by\n    rw [ht.fac]\n    simp [t.Î¹_Ï€]\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofColimitCocone_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsColimit t\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.Bicone.ofColimitCocone ht).Ï€ j) (ht.desc (CategoryTheory.Limits.Cofan.mk (f j) fun j' => dite (Eq j' j) (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0))","decl":"open scoped Classical in\n/-- We can turn any colimit cocone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofColimitCocone {f : J â†’ C} {t : Cocone (Discrete.functor f)} (ht : IsColimit t) :\n    Bicone f where\n  pt := t.pt\n  Ï€ j := ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0)\n  Î¹ j := t.Î¹.app âŸ¨jâŸ©\n  Î¹_Ï€ j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofColimitCocone_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsColimit t\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.Bicone.ofColimitCocone ht).Î¹ j) (t.Î¹.app { as := j })","decl":"open scoped Classical in\n/-- We can turn any colimit cocone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofColimitCocone {f : J â†’ C} {t : Cocone (Discrete.functor f)} (ht : IsColimit t) :\n    Bicone f where\n  pt := t.pt\n  Ï€ j := ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0)\n  Î¹ j := t.Î¹.app âŸ¨jâŸ©\n  Î¹_Ï€ j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofColimitCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsColimit t\nâŠ¢ Eq (CategoryTheory.Limits.Bicone.ofColimitCocone ht).pt t.pt","decl":"open scoped Classical in\n/-- We can turn any colimit cocone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofColimitCocone {f : J â†’ C} {t : Cocone (Discrete.functor f)} (ht : IsColimit t) :\n    Bicone f where\n  pt := t.pt\n  Ï€ j := ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0)\n  Î¹ j := t.Î¹.app âŸ¨jâŸ©\n  Î¹_Ï€ j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.Ï€_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\nt : CategoryTheory.Limits.Bicone f\nht : CategoryTheory.Limits.IsColimit t.toCocone\nj : J\nâŠ¢ Eq (t.Ï€ j) (ht.desc (CategoryTheory.Limits.Cofan.mk (f j) fun j' => dite (Eq j' j) (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0))","decl":"open scoped Classical in\ntheorem Ï€_of_isColimit {f : J â†’ C} {t : Bicone f} (ht : IsColimit t.toCocone) (j : J) :\n    t.Ï€ j = ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0) :=\n  ht.hom_ext fun j' => by\n    rw [ht.fac]\n    simp [t.Î¹_Ï€]\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ³ : CategoryTheory.Category.{uC', uC} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\ninstâœÂ¹ : SizeOf J\ninstâœ : SizeOf C\nisLimit : CategoryTheory.Limits.IsLimit B.toCone\nisColimit : CategoryTheory.Limits.IsColimit B.toCocone\nâŠ¢ Eq (SizeOf.sizeOf { isLimit := isLimit, isColimit := isColimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf isLimit)) (SizeOf.sizeOf isColimit))","decl":"/-- Structure witnessing that a bicone is both a limit cone and a colimit cocone. -/\nstructure IsBilimit {F : J â†’ C} (B : Bicone F) where\n  isLimit : IsLimit B.toCone\n  isColimit : IsColimit B.toCocone\n\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nisLimitâœ : CategoryTheory.Limits.IsLimit B.toCone\nisColimitâœ : CategoryTheory.Limits.IsColimit B.toCocone\nisLimit : CategoryTheory.Limits.IsLimit B.toCone\nisColimit : CategoryTheory.Limits.IsColimit B.toCocone\nxâœ : Eq { isLimit := isLimitâœ, isColimit := isColimitâœ } { isLimit := isLimit, isColimit := isColimit }\nâŠ¢ And (Eq isLimitâœ isLimit) (Eq isColimitâœ isColimit)","decl":"/-- Structure witnessing that a bicone is both a limit cone and a colimit cocone. -/\nstructure IsBilimit {F : J â†’ C} (B : Bicone F) where\n  isLimit : IsLimit B.toCone\n  isColimit : IsColimit B.toCocone\n\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nisLimitâœ : CategoryTheory.Limits.IsLimit B.toCone\nisColimitâœ : CategoryTheory.Limits.IsColimit B.toCocone\nisLimit : CategoryTheory.Limits.IsLimit B.toCone\nisColimit : CategoryTheory.Limits.IsColimit B.toCocone\nâŠ¢ Eq (Eq { isLimit := isLimitâœ, isColimit := isColimitâœ } { isLimit := isLimit, isColimit := isColimit }) (And (Eq isLimitâœ isLimit) (Eq isColimitâœ isColimit))","decl":"/-- Structure witnessing that a bicone is both a limit cone and a colimit cocone. -/\nstructure IsBilimit {F : J â†’ C} (B : Bicone F) where\n  isLimit : IsLimit B.toCone\n  isColimit : IsColimit B.toCocone\n\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nx y : B.IsBilimit\nâŠ¢ Iff (Eq x y) (And (Eq x.isLimit y.isLimit) (Eq x.isColimit y.isColimit))","decl":"attribute [local ext] Bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nB : CategoryTheory.Limits.Bicone F\nx y : B.IsBilimit\nisLimit : Eq x.isLimit y.isLimit\nisColimit : Eq x.isColimit y.isColimit\nâŠ¢ Eq x y","decl":"attribute [local ext] Bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.Bicone.subsingleton_isBilimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\nc : CategoryTheory.Limits.Bicone f\nâŠ¢ Subsingleton c.IsBilimit","decl":"instance subsingleton_isBilimit {f : J â†’ C} {c : Bicone f} : Subsingleton c.IsBilimit :=\n  âŸ¨fun _ _ => Bicone.IsBilimit.ext (Subsingleton.elim _ _) (Subsingleton.elim _ _)âŸ©\n\n"}
{"name":"CategoryTheory.Limits.Bicone.whisker_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type w'\nf : J â†’ C\nc : CategoryTheory.Limits.Bicone f\ng : Equiv K J\nk : K\nâŠ¢ Eq ((c.whisker g).Î¹ k) (c.Î¹ (g k))","decl":"/-- Whisker a bicone with an equivalence between the indexing types. -/\n@[simps]\ndef whisker {f : J â†’ C} (c : Bicone f) (g : K â‰ƒ J) : Bicone (f âˆ˜ g) where\n  pt := c.pt\n  Ï€ k := c.Ï€ (g k)\n  Î¹ k := c.Î¹ (g k)\n  Î¹_Ï€ k k' := by\n    simp only [c.Î¹_Ï€]\n    split_ifs with h h' h' <;> simp [Equiv.apply_eq_iff_eq g] at h h' <;> tauto\n\n"}
{"name":"CategoryTheory.Limits.Bicone.whisker_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type w'\nf : J â†’ C\nc : CategoryTheory.Limits.Bicone f\ng : Equiv K J\nâŠ¢ Eq (c.whisker g).pt c.pt","decl":"/-- Whisker a bicone with an equivalence between the indexing types. -/\n@[simps]\ndef whisker {f : J â†’ C} (c : Bicone f) (g : K â‰ƒ J) : Bicone (f âˆ˜ g) where\n  pt := c.pt\n  Ï€ k := c.Ï€ (g k)\n  Î¹ k := c.Î¹ (g k)\n  Î¹_Ï€ k k' := by\n    simp only [c.Î¹_Ï€]\n    split_ifs with h h' h' <;> simp [Equiv.apply_eq_iff_eq g] at h h' <;> tauto\n\n"}
{"name":"CategoryTheory.Limits.Bicone.whisker_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type w'\nf : J â†’ C\nc : CategoryTheory.Limits.Bicone f\ng : Equiv K J\nk : K\nâŠ¢ Eq ((c.whisker g).Ï€ k) (c.Ï€ (g k))","decl":"/-- Whisker a bicone with an equivalence between the indexing types. -/\n@[simps]\ndef whisker {f : J â†’ C} (c : Bicone f) (g : K â‰ƒ J) : Bicone (f âˆ˜ g) where\n  pt := c.pt\n  Ï€ k := c.Ï€ (g k)\n  Î¹ k := c.Î¹ (g k)\n  Î¹_Ï€ k k' := by\n    simp only [c.Î¹_Ï€]\n    split_ifs with h h' h' <;> simp [Equiv.apply_eq_iff_eq g] at h h' <;> tauto\n\n"}
{"name":"CategoryTheory.Limits.LimitBicone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nbiconeâœ : CategoryTheory.Limits.Bicone F\nisBilimitâœ : biconeâœ.IsBilimit\nbicone : CategoryTheory.Limits.Bicone F\nisBilimit : bicone.IsBilimit\nâŠ¢ Eq (Eq { bicone := biconeâœ, isBilimit := isBilimitâœ } { bicone := bicone, isBilimit := isBilimit }) (And (Eq biconeâœ bicone) (HEq isBilimitâœ isBilimit))","decl":"/-- A bicone over `F : J â†’ C`, which is both a limit cone and a colimit cocone.\n-/\nstructure LimitBicone (F : J â†’ C) where\n  bicone : Bicone F\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.LimitBicone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ³ : CategoryTheory.Category.{uC', uC} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\ninstâœÂ¹ : SizeOf J\ninstâœ : SizeOf C\nbicone : CategoryTheory.Limits.Bicone F\nisBilimit : bicone.IsBilimit\nâŠ¢ Eq (SizeOf.sizeOf { bicone := bicone, isBilimit := isBilimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf bicone)) (SizeOf.sizeOf isBilimit))","decl":"/-- A bicone over `F : J â†’ C`, which is both a limit cone and a colimit cocone.\n-/\nstructure LimitBicone (F : J â†’ C) where\n  bicone : Bicone F\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.LimitBicone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nbiconeâœ : CategoryTheory.Limits.Bicone F\nisBilimitâœ : biconeâœ.IsBilimit\nbicone : CategoryTheory.Limits.Bicone F\nisBilimit : bicone.IsBilimit\nxâœ : Eq { bicone := biconeâœ, isBilimit := isBilimitâœ } { bicone := bicone, isBilimit := isBilimit }\nâŠ¢ And (Eq biconeâœ bicone) (HEq isBilimitâœ isBilimit)","decl":"/-- A bicone over `F : J â†’ C`, which is both a limit cone and a colimit cocone.\n-/\nstructure LimitBicone (F : J â†’ C) where\n  bicone : Bicone F\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.HasBiproduct.exists_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nself : CategoryTheory.Limits.HasBiproduct F\nâŠ¢ Nonempty (CategoryTheory.Limits.LimitBicone F)","decl":"/-- `HasBiproduct F` expresses the mere existence of a bicone which is\nsimultaneously a limit and a colimit of the diagram `F`.\n-/\nclass HasBiproduct (F : J â†’ C) : Prop where mk' ::\n  exists_biproduct : Nonempty (LimitBicone F)\n\n"}
{"name":"CategoryTheory.Limits.HasBiproduct.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\nd : CategoryTheory.Limits.LimitBicone F\nâŠ¢ CategoryTheory.Limits.HasBiproduct F","decl":"theorem HasBiproduct.mk {F : J â†’ C} (d : LimitBicone F) : HasBiproduct F :=\n  âŸ¨Nonempty.intro dâŸ©\n\n"}
{"name":"CategoryTheory.Limits.hasProduct_of_hasBiproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ² : CategoryTheory.Category.{uC', uC} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct F\nâŠ¢ CategoryTheory.Limits.HasProduct F","decl":"instance (priority := 100) hasProduct_of_hasBiproduct [HasBiproduct F] : HasProduct F :=\n  HasLimit.mk\n    { cone := (biproduct.bicone F).toCone\n      isLimit := biproduct.isLimit F }\n\n"}
{"name":"CategoryTheory.Limits.hasCoproduct_of_hasBiproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ² : CategoryTheory.Category.{uC', uC} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct F\nâŠ¢ CategoryTheory.Limits.HasCoproduct F","decl":"instance (priority := 100) hasCoproduct_of_hasBiproduct [HasBiproduct F] : HasCoproduct F :=\n  HasColimit.mk\n    { cocone := (biproduct.bicone F).toCocone\n      isColimit := biproduct.isColimit F }\n\n"}
{"name":"CategoryTheory.Limits.HasBiproductsOfShape.has_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasBiproductsOfShape J C\nF : J â†’ C\nâŠ¢ CategoryTheory.Limits.HasBiproduct F","decl":"/-- `C` has biproducts of shape `J` if we have\na limit and a colimit, with the same cone points,\nof every function `F : J â†’ C`.\n-/\nclass HasBiproductsOfShape : Prop where\n  has_biproduct : âˆ€ F : J â†’ C, HasBiproduct F\n\n"}
{"name":"CategoryTheory.Limits.HasFiniteBiproducts.out","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type uC\ninstâœÂ¹ : CategoryTheory.Category.{uC', uC} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasFiniteBiproducts C\nn : Nat\nâŠ¢ CategoryTheory.Limits.HasBiproductsOfShape (Fin n) C","decl":"/-- `HasFiniteBiproducts C` represents a choice of biproduct for every family of objects in `C`\nindexed by a finite type. -/\nclass HasFiniteBiproducts : Prop where\n  out : âˆ€ n, HasBiproductsOfShape (Fin n) C\n\n"}
{"name":"CategoryTheory.Limits.hasBiproductsOfShape_of_equiv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ² : CategoryTheory.Category.{uC', uC} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type w'\ninstâœ : CategoryTheory.Limits.HasBiproductsOfShape K C\ne : Equiv J K\nâŠ¢ CategoryTheory.Limits.HasBiproductsOfShape J C","decl":"theorem hasBiproductsOfShape_of_equiv {K : Type w'} [HasBiproductsOfShape K C] (e : J â‰ƒ K) :\n    HasBiproductsOfShape J C :=\n  âŸ¨fun F =>\n    let âŸ¨âŸ¨hâŸ©âŸ© := HasBiproductsOfShape.has_biproduct (F âˆ˜ e.symm)\n    let âŸ¨c, hcâŸ© := h\n    HasBiproduct.mk <| by\n      simpa only [Function.comp_def, e.symm_apply_apply] using\n        LimitBicone.mk (c.whisker e) ((c.whiskerIsBilimitIff _).2 hc)âŸ©\n\n"}
{"name":"CategoryTheory.Limits.hasBiproductsOfShape_finite","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ³ : CategoryTheory.Category.{uC', uC} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninstâœ : Finite J\nâŠ¢ CategoryTheory.Limits.HasBiproductsOfShape J C","decl":"instance (priority := 100) hasBiproductsOfShape_finite [HasFiniteBiproducts C] [Finite J] :\n    HasBiproductsOfShape J C := by\n  rcases Finite.exists_equiv_fin J with âŸ¨n, âŸ¨eâŸ©âŸ©\n  haveI : HasBiproductsOfShape (Fin n) C := HasFiniteBiproducts.out n\n  exact hasBiproductsOfShape_of_equiv C e\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteProducts_of_hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type uC\ninstâœÂ² : CategoryTheory.Category.{uC', uC} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nâŠ¢ CategoryTheory.Limits.HasFiniteProducts C","decl":"instance (priority := 100) hasFiniteProducts_of_hasFiniteBiproducts [HasFiniteBiproducts C] :\n    HasFiniteProducts C where\n  out _ := âŸ¨fun _ => hasLimitOfIso Discrete.natIsoFunctor.symmâŸ©\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteCoproducts_of_hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type uC\ninstâœÂ² : CategoryTheory.Category.{uC', uC} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nâŠ¢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"instance (priority := 100) hasFiniteCoproducts_of_hasFiniteBiproducts [HasFiniteBiproducts C] :\n    HasFiniteCoproducts C where\n  out _ := âŸ¨fun _ => hasColimitOfIso Discrete.natIsoFunctorâŸ©\n\n"}
{"name":"CategoryTheory.Limits.hasProductsOfShape_of_hasBiproductsOfShape","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ² : CategoryTheory.Category.{uC', uC} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBiproductsOfShape J C\nâŠ¢ CategoryTheory.Limits.HasProductsOfShape J C","decl":"instance (priority := 100) hasProductsOfShape_of_hasBiproductsOfShape [HasBiproductsOfShape J C] :\n    HasProductsOfShape J C where\n  has_limit _ := hasLimitOfIso Discrete.natIsoFunctor.symm\n\n"}
{"name":"CategoryTheory.Limits.hasCoproductsOfShape_of_hasBiproductsOfShape","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninstâœÂ² : CategoryTheory.Category.{uC', uC} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBiproductsOfShape J C\nâŠ¢ CategoryTheory.Limits.HasCoproductsOfShape J C","decl":"instance (priority := 100) hasCoproductsOfShape_of_hasBiproductsOfShape [HasBiproductsOfShape J C] :\n    HasCoproductsOfShape J C where\n  has_colimit _ := hasColimitOfIso Discrete.natIsoFunctor\n\n"}
{"name":"CategoryTheory.Limits.biproduct.bicone_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nb : J\nâŠ¢ Eq ((CategoryTheory.Limits.biproduct.bicone f).Ï€ b) (CategoryTheory.Limits.biproduct.Ï€ f b)","decl":"@[simp]\ntheorem biproduct.bicone_Ï€ (f : J â†’ C) [HasBiproduct f] (b : J) :\n    (biproduct.bicone f).Ï€ b = biproduct.Ï€ f b := rfl\n\n"}
{"name":"CategoryTheory.Limits.biproduct.bicone_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nb : J\nâŠ¢ Eq ((CategoryTheory.Limits.biproduct.bicone f).Î¹ b) (CategoryTheory.Limits.biproduct.Î¹ f b)","decl":"@[simp]\ntheorem biproduct.bicone_Î¹ (f : J â†’ C) [HasBiproduct f] (b : J) :\n    (biproduct.bicone f).Î¹ b = biproduct.Î¹ f b := rfl\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : DecidableEq J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nZ : C\nh : Quiver.Hom (f j') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j') h)) (CategoryTheory.CategoryStruct.comp (dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0) h)","decl":"/-- Note that as this lemma has an `if` in the statement, we include a `DecidableEq` argument.\nThis means you may not be able to `simp` using this lemma unless you `open scoped Classical`. -/\n@[reassoc]\ntheorem biproduct.Î¹_Ï€ [DecidableEq J] (f : J â†’ C) [HasBiproduct f] (j j' : J) :\n    biproduct.Î¹ f j â‰« biproduct.Ï€ f j' = if h : j = j' then eqToHom (congr_arg f h) else 0 := by\n  convert (biproduct.bicone f).Î¹_Ï€ j j'\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : DecidableEq J\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.Limits.biproduct.Ï€ f j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom â‹¯) fun h => 0)","decl":"/-- Note that as this lemma has an `if` in the statement, we include a `DecidableEq` argument.\nThis means you may not be able to `simp` using this lemma unless you `open scoped Classical`. -/\n@[reassoc]\ntheorem biproduct.Î¹_Ï€ [DecidableEq J] (f : J â†’ C) [HasBiproduct f] (j j' : J) :\n    biproduct.Î¹ f j â‰« biproduct.Ï€ f j' = if h : j = j' then eqToHom (congr_arg f h) else 0 := by\n  convert (biproduct.bicone f).Î¹_Ï€ j j'\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_Ï€_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.Limits.biproduct.Ï€ f j)) (CategoryTheory.CategoryStruct.id (f j))","decl":"@[reassoc] -- Porting note: both versions proven by simp\ntheorem biproduct.Î¹_Ï€_self (f : J â†’ C) [HasBiproduct f] (j : J) :\n    biproduct.Î¹ f j â‰« biproduct.Ï€ f j = ğŸ™ _ := by simp [biproduct.Î¹_Ï€]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_Ï€_self_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj : J\nZ : C\nh : Quiver.Hom (f j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) h)) h","decl":"@[reassoc] -- Porting note: both versions proven by simp\ntheorem biproduct.Î¹_Ï€_self (f : J â†’ C) [HasBiproduct f] (j : J) :\n    biproduct.Î¹ f j â‰« biproduct.Ï€ f j = ğŸ™ _ := by simp [biproduct.Î¹_Ï€]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_Ï€_ne_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nhâœ : Ne j j'\nZ : C\nh : Quiver.Hom (f j') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j') h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_Ï€_ne (f : J â†’ C) [HasBiproduct f] {j j' : J} (h : j â‰  j') :\n    biproduct.Î¹ f j â‰« biproduct.Ï€ f j' = 0 := by simp [biproduct.Î¹_Ï€, h]\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_Ï€_ne","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nh : Ne j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.Limits.biproduct.Ï€ f j')) 0","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_Ï€_ne (f : J â†’ C) [HasBiproduct f] {j j' : J} (h : j â‰  j') :\n    biproduct.Î¹ f j â‰« biproduct.Ï€ f j' = 0 := by simp [biproduct.Î¹_Ï€, h]\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.biproduct.eqToHom_comp_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nw : Eq j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.Limits.biproduct.Î¹ f j')) (CategoryTheory.Limits.biproduct.Î¹ f j)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.eqToHom_comp_Î¹ (f : J â†’ C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) â‰« biproduct.Î¹ f j' = biproduct.Î¹ f j := by\n  cases w\n  simp\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.biproduct.eqToHom_comp_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nw : Eq j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) h)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.eqToHom_comp_Î¹ (f : J â†’ C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) â‰« biproduct.Î¹ f j' = biproduct.Î¹ f j := by\n  cases w\n  simp\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.biproduct.Ï€_comp_eqToHom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nw : Eq j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) (CategoryTheory.eqToHom â‹¯)) (CategoryTheory.Limits.biproduct.Ï€ f j')","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.Ï€_comp_eqToHom (f : J â†’ C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    biproduct.Ï€ f j â‰« eqToHom (by simp [w]) = biproduct.Ï€ f j' := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Ï€_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nw : Eq j j'\nZ : C\nh : Quiver.Hom (f j') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j') h)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.Ï€_comp_eqToHom (f : J â†’ C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    biproduct.Ï€ f j â‰« eqToHom (by simp [w]) = biproduct.Ï€ f j' := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nP : C\np : (b : J) â†’ Quiver.Hom P (f b)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift p) (CategoryTheory.Limits.biproduct.Ï€ f j)) (p j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.lift_Ï€ {f : J â†’ C} [HasBiproduct f] {P : C} (p : âˆ€ b, P âŸ¶ f b) (j : J) :\n    biproduct.lift p â‰« biproduct.Ï€ f j = p j := (biproduct.isLimit f).fac _ âŸ¨jâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nP : C\np : (b : J) â†’ Quiver.Hom P (f b)\nj : J\nZ : C\nh : Quiver.Hom (f j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) h)) (CategoryTheory.CategoryStruct.comp (p j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.lift_Ï€ {f : J â†’ C} [HasBiproduct f] {P : C} (p : âˆ€ b, P âŸ¶ f b) (j : J) :\n    biproduct.lift p â‰« biproduct.Ï€ f j = p j := (biproduct.isLimit f).fac _ âŸ¨jâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nP : C\np : (b : J) â†’ Quiver.Hom (f b) P\nj : J\nZ : C\nh : Quiver.Hom P Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc p) h)) (CategoryTheory.CategoryStruct.comp (p j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_desc {f : J â†’ C} [HasBiproduct f] {P : C} (p : âˆ€ b, f b âŸ¶ P) (j : J) :\n    biproduct.Î¹ f j â‰« biproduct.desc p = p j := (biproduct.isColimit f).fac _ âŸ¨jâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nP : C\np : (b : J) â†’ Quiver.Hom (f b) P\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.Limits.biproduct.desc p)) (p j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_desc {f : J â†’ C} [HasBiproduct f] {P : C} (p : âˆ€ b, f b âŸ¶ P) (j : J) :\n    biproduct.Î¹ f j â‰« biproduct.desc p = p j := (biproduct.isColimit f).fac _ âŸ¨jâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biproduct.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nZ : C\ng h : Quiver.Hom Z (CategoryTheory.Limits.biproduct f)\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.Ï€ f j)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.Limits.biproduct.Ï€ f j))\nâŠ¢ Eq g h","decl":"@[ext 1001]\ntheorem biproduct.hom_ext {f : J â†’ C} [HasBiproduct f] {Z : C} (g h : Z âŸ¶ â¨ f)\n    (w : âˆ€ j, g â‰« biproduct.Ï€ f j = h â‰« biproduct.Ï€ f j) : g = h :=\n  (biproduct.isLimit f).hom_ext fun j => w j.as\n\n"}
{"name":"CategoryTheory.Limits.biproduct.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nZ : C\ng h : Quiver.Hom Z (CategoryTheory.Limits.biproduct f)\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.Ï€ f j)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.Limits.biproduct.Ï€ f j)))","decl":"@[ext 1001]\ntheorem biproduct.hom_ext {f : J â†’ C} [HasBiproduct f] {Z : C} (g h : Z âŸ¶ â¨ f)\n    (w : âˆ€ j, g â‰« biproduct.Ï€ f j = h â‰« biproduct.Ï€ f j) : g = h :=\n  (biproduct.isLimit f).hom_ext fun j => w j.as\n\n"}
{"name":"CategoryTheory.Limits.biproduct.hom_ext'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nZ : C\ng h : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) h)\nâŠ¢ Eq g h","decl":"@[ext]\ntheorem biproduct.hom_ext' {f : J â†’ C} [HasBiproduct f] {Z : C} (g h : â¨ f âŸ¶ Z)\n    (w : âˆ€ j, biproduct.Î¹ f j â‰« g = biproduct.Î¹ f j â‰« h) : g = h :=\n  (biproduct.isColimit f).hom_ext fun j => w j.as\n\n"}
{"name":"CategoryTheory.Limits.biproduct.hom_ext'_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nZ : C\ng h : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) h))","decl":"@[ext]\ntheorem biproduct.hom_ext' {f : J â†’ C} [HasBiproduct f] {Z : C} (g h : â¨ f âŸ¶ Z)\n    (w : âˆ€ j, biproduct.Î¹ f j â‰« g = biproduct.Î¹ f j â‰« h) : g = h :=\n  (biproduct.isColimit f).hom_ext fun j => w j.as\n\n"}
{"name":"CategoryTheory.Limits.biproduct.isoProduct_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.isoProduct f).hom (CategoryTheory.Limits.Pi.lift (CategoryTheory.Limits.biproduct.Ï€ f))","decl":"@[simp]\ntheorem biproduct.isoProduct_hom {f : J â†’ C} [HasBiproduct f] :\n    (biproduct.isoProduct f).hom = Pi.lift (biproduct.Ï€ f) :=\n  limit.hom_ext fun j => by simp [biproduct.isoProduct]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.isoProduct_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.isoProduct f).inv (CategoryTheory.Limits.biproduct.lift (CategoryTheory.Limits.Pi.Ï€ f))","decl":"@[simp]\ntheorem biproduct.isoProduct_inv {f : J â†’ C} [HasBiproduct f] :\n    (biproduct.isoProduct f).inv = biproduct.lift (Pi.Ï€ f) :=\n  biproduct.hom_ext _ _ fun j => by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.isoCoproduct_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.isoCoproduct f).inv (CategoryTheory.Limits.Sigma.desc (CategoryTheory.Limits.biproduct.Î¹ f))","decl":"@[simp]\ntheorem biproduct.isoCoproduct_inv {f : J â†’ C} [HasBiproduct f] :\n    (biproduct.isoCoproduct f).inv = Sigma.desc (biproduct.Î¹ f) :=\n  colimit.hom_ext fun j => by simp [biproduct.isoCoproduct]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.isoCoproduct_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.isoCoproduct f).hom (CategoryTheory.Limits.biproduct.desc (CategoryTheory.Limits.Sigma.Î¹ f))","decl":"@[simp]\ntheorem biproduct.isoCoproduct_hom {f : J â†’ C} [HasBiproduct f] :\n    (biproduct.isoCoproduct f).hom = biproduct.desc (Sigma.Î¹ f) :=\n  biproduct.hom_ext' _ _ fun j => by simp [â† Iso.eq_comp_inv]\n\n"}
{"name":"CategoryTheory.Limits.HasBiproductsOfShape.colimIsoLim_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBiproductsOfShape J C\nX : CategoryTheory.Functor (CategoryTheory.Discrete J) C\nâŠ¢ Eq (CategoryTheory.Limits.HasBiproductsOfShape.colimIsoLim.inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift (CategoryTheory.Limits.Pi.Ï€ fun j => X.obj { as := j })) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc (CategoryTheory.Limits.Sigma.Î¹ fun j => X.obj { as := j })) (CategoryTheory.Limits.Sigma.isoColimit X).hom)))","decl":"/-- If a category has biproducts of a shape `J`, its `colim` and `lim` functor on diagrams over `J`\nare isomorphic. -/\n@[simps!]\ndef HasBiproductsOfShape.colimIsoLim [HasBiproductsOfShape J C] :\n    colim (J := Discrete J) (C := C) â‰… lim :=\n  NatIso.ofComponents (fun F => (Sigma.isoColimit F).symm â‰ªâ‰«\n      (biproduct.isoCoproduct _).symm â‰ªâ‰« biproduct.isoProduct _ â‰ªâ‰« Pi.isoLimit F)\n    fun Î· => colimit.hom_ext fun âŸ¨iâŸ© => limit.hom_ext fun âŸ¨jâŸ© => by\n      classical\n      by_cases h : i = j <;>\n       simp_all [h, Sigma.isoColimit, Pi.isoLimit, biproduct.Î¹_Ï€, biproduct.Î¹_Ï€_assoc]\n\n"}
{"name":"CategoryTheory.Limits.HasBiproductsOfShape.colimIsoLim_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBiproductsOfShape J C\nX : CategoryTheory.Functor (CategoryTheory.Discrete J) C\nâŠ¢ Eq (CategoryTheory.Limits.HasBiproductsOfShape.colimIsoLim.hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.isoColimit X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.desc (CategoryTheory.Limits.biproduct.Î¹ fun j => X.obj { as := j })) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift (CategoryTheory.Limits.biproduct.Ï€ fun j => X.obj { as := j })) (CategoryTheory.Limits.Pi.isoLimit X).hom)))","decl":"/-- If a category has biproducts of a shape `J`, its `colim` and `lim` functor on diagrams over `J`\nare isomorphic. -/\n@[simps!]\ndef HasBiproductsOfShape.colimIsoLim [HasBiproductsOfShape J C] :\n    colim (J := Discrete J) (C := C) â‰… lim :=\n  NatIso.ofComponents (fun F => (Sigma.isoColimit F).symm â‰ªâ‰«\n      (biproduct.isoCoproduct _).symm â‰ªâ‰« biproduct.isoProduct _ â‰ªâ‰« Pi.isoLimit F)\n    fun Î· => colimit.hom_ext fun âŸ¨iâŸ© => limit.hom_ext fun âŸ¨jâŸ© => by\n      classical\n      by_cases h : i = j <;>\n       simp_all [h, Sigma.isoColimit, Pi.isoLimit, biproduct.Î¹_Ï€, biproduct.Î¹_Ï€_assoc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_eq_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\np : (b : J) â†’ Quiver.Hom (f b) (g b)\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.Limits.biproduct.map' p)","decl":"theorem biproduct.map_eq_map' {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ b, f b âŸ¶ g b) :\n    biproduct.map p = biproduct.map' p := by\n  classical\n  ext\n  dsimp\n  simp only [Discrete.natTrans_app, Limits.IsColimit.Î¹_map_assoc, Limits.IsLimit.map_Ï€,\n    Category.assoc, â† Bicone.toCone_Ï€_app_mk, â† biproduct.bicone_Ï€, â† Bicone.toCocone_Î¹_app_mk,\n    â† biproduct.bicone_Î¹]\n  dsimp\n  rw [biproduct.Î¹_Ï€_assoc, biproduct.Î¹_Ï€]\n  split_ifs with h\n  Â· subst h; simp\n  Â· simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\nj : J\nZ : C\nh : Quiver.Hom (g j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ g j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) (CategoryTheory.CategoryStruct.comp (p j) h))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.map_Ï€ {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    (j : J) : biproduct.map p â‰« biproduct.Ï€ g j = biproduct.Ï€ f j â‰« p j :=\n  Limits.IsLimit.map_Ï€ _ _ _ (Discrete.mk j)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.Limits.biproduct.Ï€ g j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) (p j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.map_Ï€ {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    (j : J) : biproduct.map p â‰« biproduct.Ï€ g j = biproduct.Ï€ f j â‰« p j :=\n  Limits.IsLimit.map_Ï€ _ _ _ (Discrete.mk j)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.Limits.biproduct.map p)) (CategoryTheory.CategoryStruct.comp (p j) (CategoryTheory.Limits.biproduct.Î¹ g j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_map {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    (j : J) : biproduct.Î¹ f j â‰« biproduct.map p = p j â‰« biproduct.Î¹ g j := by\n  rw [biproduct.map_eq_map']\n  apply\n    Limits.IsColimit.Î¹_map (biproduct.isColimit f) (biproduct.bicone g).toCocone\n    (Discrete.natTrans fun j => p j.as) (Discrete.mk j)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) h)) (CategoryTheory.CategoryStruct.comp (p j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ g j) h))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_map {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    (j : J) : biproduct.Î¹ f j â‰« biproduct.map p = p j â‰« biproduct.Î¹ g j := by\n  rw [biproduct.map_eq_map']\n  apply\n    Limits.IsColimit.Î¹_map (biproduct.isColimit f) (biproduct.bicone g).toCocone\n    (Discrete.natTrans fun j => p j.as) (Discrete.mk j)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\nP : C\nk : (j : J) â†’ Quiver.Hom (g j) P\nZ : C\nh : Quiver.Hom P Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc fun j => CategoryTheory.CategoryStruct.comp (p j) (k j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.map_desc {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    {P : C} (k : âˆ€ j, g j âŸ¶ P) :\n    biproduct.map p â‰« biproduct.desc k = biproduct.desc fun j => p j â‰« k j := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\nP : C\nk : (j : J) â†’ Quiver.Hom (g j) P\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.Limits.biproduct.desc k)) (CategoryTheory.Limits.biproduct.desc fun j => CategoryTheory.CategoryStruct.comp (p j) (k j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.map_desc {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    {P : C} (k : âˆ€ j, g j âŸ¶ P) :\n    biproduct.map p â‰« biproduct.desc k = biproduct.desc fun j => p j â‰« k j := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\nP : C\nk : (j : J) â†’ Quiver.Hom P (f j)\np : (j : J) â†’ Quiver.Hom (f j) (g j)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift k) (CategoryTheory.Limits.biproduct.map p)) (CategoryTheory.Limits.biproduct.lift fun j => CategoryTheory.CategoryStruct.comp (k j) (p j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.lift_map {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] {P : C}\n    (k : âˆ€ j, P âŸ¶ f j) (p : âˆ€ j, f j âŸ¶ g j) :\n    biproduct.lift k â‰« biproduct.map p = biproduct.lift fun j => k j â‰« p j := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\nP : C\nk : (j : J) â†’ Quiver.Hom P (f j)\np : (j : J) â†’ Quiver.Hom (f j) (g j)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift fun j => CategoryTheory.CategoryStruct.comp (k j) (p j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.lift_map {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] {P : C}\n    (k : âˆ€ j, P âŸ¶ f j) (p : âˆ€ j, f j âŸ¶ g j) :\n    biproduct.lift k â‰« biproduct.map p = biproduct.lift fun j => k j â‰« p j := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\np : (b : J) â†’ CategoryTheory.Iso (f b) (g b)\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.mapIso p).hom (CategoryTheory.Limits.biproduct.map fun b => (p b).hom)","decl":"/-- Given a collection of isomorphisms between corresponding summands of a pair of biproducts\nindexed by the same type, we obtain an isomorphism between the biproducts. -/\n@[simps]\ndef biproduct.mapIso {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ b, f b â‰… g b) :\n    â¨ f â‰… â¨ g where\n  hom := biproduct.map fun b => (p b).hom\n  inv := biproduct.map fun b => (p b).inv\n\n"}
{"name":"CategoryTheory.Limits.biproduct.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\np : (b : J) â†’ CategoryTheory.Iso (f b) (g b)\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.mapIso p).inv (CategoryTheory.Limits.biproduct.map fun b => (p b).inv)","decl":"/-- Given a collection of isomorphisms between corresponding summands of a pair of biproducts\nindexed by the same type, we obtain an isomorphism between the biproducts. -/\n@[simps]\ndef biproduct.mapIso {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ b, f b â‰… g b) :\n    â¨ f â‰… â¨ g where\n  hom := biproduct.map fun b => (p b).hom\n  inv := biproduct.map fun b => (p b).inv\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\ninstâœ : âˆ€ (j : J), CategoryTheory.Epi (p j)\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.biproduct.map p)","decl":"instance biproduct.map_epi {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    [âˆ€ j, Epi (p j)] : Epi (biproduct.map p) := by\n  classical\n  have : biproduct.map p =\n      (biproduct.isoCoproduct _).hom â‰« Sigma.map p â‰« (biproduct.isoCoproduct _).inv := by\n    ext\n    simp only [map_Ï€, isoCoproduct_hom, isoCoproduct_inv, Category.assoc, Î¹_desc_assoc,\n      Î¹_colimMap_assoc, Discrete.functor_obj_eq_as, Discrete.natTrans_app, colimit.Î¹_desc_assoc,\n      Cofan.mk_pt, Cofan.mk_Î¹_app, Î¹_Ï€, Î¹_Ï€_assoc]\n    split\n    all_goals simp_all\n  rw [this]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\ninstâœ : âˆ€ (j : J), CategoryTheory.Epi (p j)\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.Pi.map p)","decl":"instance Pi.map_epi {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    [âˆ€ j, Epi (p j)] : Epi (Pi.map p) := by\n  rw [show Pi.map p = (biproduct.isoProduct _).inv â‰« biproduct.map p â‰«\n    (biproduct.isoProduct _).hom by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\ninstâœ : âˆ€ (j : J), CategoryTheory.Mono (p j)\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.biproduct.map p)","decl":"instance biproduct.map_mono {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    [âˆ€ j, Mono (p j)] : Mono (biproduct.map p) := by\n  rw [show biproduct.map p = (biproduct.isoProduct _).hom â‰« Pi.map p â‰«\n    (biproduct.isoProduct _).inv by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) â†’ Quiver.Hom (f j) (g j)\ninstâœ : âˆ€ (j : J), CategoryTheory.Mono (p j)\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.Sigma.map p)","decl":"instance Sigma.map_mono {f g : J â†’ C} [HasBiproduct f] [HasBiproduct g] (p : âˆ€ j, f j âŸ¶ g j)\n    [âˆ€ j, Mono (p j)] : Mono (Sigma.map p) := by\n  rw [show Sigma.map p = (biproduct.isoCoproduct _).inv â‰« biproduct.map p â‰«\n    (biproduct.isoCoproduct _).hom by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.biproduct.whiskerEquiv_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nK : Type u_1\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ng : K â†’ C\ne : Equiv J K\nw : (j : J) â†’ CategoryTheory.Iso (g (e j)) (f j)\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.whiskerEquiv e w).inv (CategoryTheory.Limits.biproduct.desc fun k => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp (w (e.symm k)).hom (CategoryTheory.Limits.biproduct.Î¹ f (e.symm k))))","decl":"/-- Two biproducts which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n\nUnfortunately there are two natural ways to define each direction of this isomorphism\n(because it is true for both products and coproducts separately).\nWe give the alternative definitions as lemmas below.\n-/\n@[simps]\ndef biproduct.whiskerEquiv {f : J â†’ C} {g : K â†’ C} (e : J â‰ƒ K) (w : âˆ€ j, g (e j) â‰… f j)\n    [HasBiproduct f] [HasBiproduct g] : â¨ f â‰… â¨ g where\n  hom := biproduct.desc fun j => (w j).inv â‰« biproduct.Î¹ g (e j)\n  inv := biproduct.desc fun k => eqToHom (by simp) â‰« (w (e.symm k)).hom â‰« biproduct.Î¹ f _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.whiskerEquiv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nK : Type u_1\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ng : K â†’ C\ne : Equiv J K\nw : (j : J) â†’ CategoryTheory.Iso (g (e j)) (f j)\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.whiskerEquiv e w).hom (CategoryTheory.Limits.biproduct.desc fun j => CategoryTheory.CategoryStruct.comp (w j).inv (CategoryTheory.Limits.biproduct.Î¹ g (e j)))","decl":"/-- Two biproducts which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n\nUnfortunately there are two natural ways to define each direction of this isomorphism\n(because it is true for both products and coproducts separately).\nWe give the alternative definitions as lemmas below.\n-/\n@[simps]\ndef biproduct.whiskerEquiv {f : J â†’ C} {g : K â†’ C} (e : J â‰ƒ K) (w : âˆ€ j, g (e j) â‰… f j)\n    [HasBiproduct f] [HasBiproduct g] : â¨ f â‰… â¨ g where\n  hom := biproduct.desc fun j => (w j).inv â‰« biproduct.Î¹ g (e j)\n  inv := biproduct.desc fun k => eqToHom (by simp) â‰« (w (e.symm k)).hom â‰« biproduct.Î¹ f _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.whiskerEquiv_hom_eq_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nK : Type u_1\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ng : K â†’ C\ne : Equiv J K\nw : (j : J) â†’ CategoryTheory.Iso (g (e j)) (f j)\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.whiskerEquiv e w).hom (CategoryTheory.Limits.biproduct.lift fun k => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f (e.symm k)) (CategoryTheory.CategoryStruct.comp (w (e.symm k)).inv (CategoryTheory.eqToHom â‹¯)))","decl":"lemma biproduct.whiskerEquiv_hom_eq_lift {f : J â†’ C} {g : K â†’ C} (e : J â‰ƒ K)\n    (w : âˆ€ j, g (e j) â‰… f j) [HasBiproduct f] [HasBiproduct g] :\n    (biproduct.whiskerEquiv e w).hom =\n      biproduct.lift fun k => biproduct.Ï€ f (e.symm k) â‰« (w _).inv â‰« eqToHom (by simp) := by\n  simp only [whiskerEquiv_hom]\n  ext k j\n  by_cases h : k = e j\n  Â· subst h\n    simp\n  Â· simp only [Î¹_desc_assoc, Category.assoc, ne_eq, lift_Ï€]\n    rw [biproduct.Î¹_Ï€_ne, biproduct.Î¹_Ï€_ne_assoc]\n    Â· simp\n    Â· rintro rfl\n      simp at h\n    Â· exact Ne.symm h\n\n"}
{"name":"CategoryTheory.Limits.biproduct.whiskerEquiv_inv_eq_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nK : Type u_1\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ng : K â†’ C\ne : Equiv J K\nw : (j : J) â†’ CategoryTheory.Iso (g (e j)) (f j)\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct g\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.whiskerEquiv e w).inv (CategoryTheory.Limits.biproduct.lift fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ g (e j)) (w j).hom)","decl":"lemma biproduct.whiskerEquiv_inv_eq_lift {f : J â†’ C} {g : K â†’ C} (e : J â‰ƒ K)\n    (w : âˆ€ j, g (e j) â‰… f j) [HasBiproduct f] [HasBiproduct g] :\n    (biproduct.whiskerEquiv e w).inv =\n      biproduct.lift fun j => biproduct.Ï€ g (e j) â‰« (w j).hom := by\n  simp only [whiskerEquiv_inv]\n  ext j k\n  by_cases h : k = e j\n  Â· subst h\n    simp only [Î¹_desc_assoc, â† eqToHom_iso_hom_naturality_assoc w (e.symm_apply_apply j).symm,\n      Equiv.symm_apply_apply, eqToHom_comp_Î¹, Category.assoc, bicone_Î¹_Ï€_self, Category.comp_id,\n      lift_Ï€, bicone_Î¹_Ï€_self_assoc]\n  Â· simp only [Î¹_desc_assoc, Category.assoc, ne_eq, lift_Ï€]\n    rw [biproduct.Î¹_Ï€_ne, biproduct.Î¹_Ï€_ne_assoc]\n    Â· simp\n    Â· exact h\n    Â· rintro rfl\n      simp at h\n\n"}
{"name":"CategoryTheory.Limits.instHasBiproductSigmaFstSndOfBiproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nÎ¹ : Type u_3\nf : Î¹ â†’ Type u_2\ng : (i : Î¹) â†’ f i â†’ C\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBiproduct (g i)\ninstâœ : CategoryTheory.Limits.HasBiproduct fun i => CategoryTheory.Limits.biproduct (g i)\nâŠ¢ CategoryTheory.Limits.HasBiproduct fun p => g p.fst p.snd","decl":"attribute [local simp] Sigma.forall in\ninstance {Î¹} (f : Î¹ â†’ Type*) (g : (i : Î¹) â†’ (f i) â†’ C)\n    [âˆ€ i, HasBiproduct (g i)] [HasBiproduct fun i => â¨ g i] :\n    HasBiproduct fun p : Î£ i, f i => g p.1 p.2 where\n  exists_biproduct := Nonempty.intro\n    { bicone :=\n      { pt := â¨ fun i => â¨ g i\n        Î¹ := fun X => biproduct.Î¹ (g X.1) X.2 â‰« biproduct.Î¹ (fun i => â¨ g i) X.1\n        Ï€ := fun X => biproduct.Ï€ (fun i => â¨ g i) X.1 â‰« biproduct.Ï€ (g X.1) X.2\n        Î¹_Ï€ := fun âŸ¨j, xâŸ© âŸ¨j', yâŸ© => by\n          split_ifs with h\n          Â· obtain âŸ¨rfl, rflâŸ© := h\n            simp\n          Â· simp only [Sigma.mk.inj_iff, not_and] at h\n            by_cases w : j = j'\n            Â· cases w\n              simp only [heq_eq_eq, forall_true_left] at h\n              simp [biproduct.Î¹_Ï€_ne _ h]\n            Â· simp [biproduct.Î¹_Ï€_ne_assoc _ w] }\n      isBilimit :=\n      { isLimit := mkFanLimit _\n          (fun s => biproduct.lift fun b => biproduct.lift fun c => s.proj âŸ¨b, câŸ©)\n        isColimit := mkCofanColimit _\n          (fun s => biproduct.desc fun b => biproduct.desc fun c => s.inj âŸ¨b, câŸ©) } }\n\n"}
{"name":"CategoryTheory.Limits.biproductBiproductIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nÎ¹ : Type u_3\nf : Î¹ â†’ Type u_2\ng : (i : Î¹) â†’ f i â†’ C\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBiproduct (g i)\ninstâœ : CategoryTheory.Limits.HasBiproduct fun i => CategoryTheory.Limits.biproduct (g i)\nâŠ¢ Eq (CategoryTheory.Limits.biproductBiproductIso f g).hom (CategoryTheory.Limits.biproduct.lift fun x => CategoryTheory.Limits.biproductBiproductIso.match_1 f (fun x => Quiver.Hom (CategoryTheory.Limits.biproduct fun i => CategoryTheory.Limits.biproduct (g i)) (g x.fst x.snd)) x fun i x => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ (fun i => CategoryTheory.Limits.biproduct (g i)) i) (CategoryTheory.Limits.biproduct.Ï€ (g i) x))","decl":"/-- An iterated biproduct is a biproduct over a sigma type. -/\n@[simps]\ndef biproductBiproductIso {Î¹} (f : Î¹ â†’ Type*) (g : (i : Î¹) â†’ (f i) â†’ C)\n    [âˆ€ i, HasBiproduct (g i)] [HasBiproduct fun i => â¨ g i] :\n    (â¨ fun i => â¨ g i) â‰… (â¨ fun p : Î£ i, f i => g p.1 p.2) where\n  hom := biproduct.lift fun âŸ¨i, xâŸ© => biproduct.Ï€ _ i â‰« biproduct.Ï€ _ x\n  inv := biproduct.lift fun i => biproduct.lift fun x => biproduct.Ï€ _ (âŸ¨i, xâŸ© : Î£ i, f i)\n\n"}
{"name":"CategoryTheory.Limits.biproductBiproductIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nÎ¹ : Type u_3\nf : Î¹ â†’ Type u_2\ng : (i : Î¹) â†’ f i â†’ C\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasBiproduct (g i)\ninstâœ : CategoryTheory.Limits.HasBiproduct fun i => CategoryTheory.Limits.biproduct (g i)\nâŠ¢ Eq (CategoryTheory.Limits.biproductBiproductIso f g).inv (CategoryTheory.Limits.biproduct.lift fun i => CategoryTheory.Limits.biproduct.lift fun x => CategoryTheory.Limits.biproduct.Ï€ (fun p => g p.fst p.snd) âŸ¨i, xâŸ©)","decl":"/-- An iterated biproduct is a biproduct over a sigma type. -/\n@[simps]\ndef biproductBiproductIso {Î¹} (f : Î¹ â†’ Type*) (g : (i : Î¹) â†’ (f i) â†’ C)\n    [âˆ€ i, HasBiproduct (g i)] [HasBiproduct fun i => â¨ g i] :\n    (â¨ fun i => â¨ g i) â‰… (â¨ fun p : Î£ i, f i => g p.1 p.2) where\n  hom := biproduct.lift fun âŸ¨i, xâŸ© => biproduct.Ï€ _ i â‰« biproduct.Ï€ _ x\n  inv := biproduct.lift fun i => biproduct.lift fun x => biproduct.Ï€ _ (âŸ¨i, xâŸ© : Î£ i, f i)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninstâœ : DecidablePred p\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.Limits.biproduct.Ï€ f j)) (dite (p j) (fun h => CategoryTheory.Limits.biproduct.Ï€ (Subtype.restrict p f) âŸ¨j, hâŸ©) fun h => 0)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.fromSubtype_Ï€ [DecidablePred p] (j : J) :\n    biproduct.fromSubtype f p â‰« biproduct.Ï€ f j =\n      if h : p j then biproduct.Ï€ (Subtype.restrict p f) âŸ¨j, hâŸ© else 0 := by\n  classical\n  ext i; dsimp\n  rw [biproduct.fromSubtype, biproduct.Î¹_desc_assoc, biproduct.Î¹_Ï€]\n  by_cases h : p j\n  Â· rw [dif_pos h, biproduct.Î¹_Ï€]\n    split_ifs with hâ‚ hâ‚‚ hâ‚‚\n    exacts [rfl, False.elim (hâ‚‚ (Subtype.ext hâ‚)), False.elim (hâ‚ (congr_arg Subtype.val hâ‚‚)), rfl]\n  Â· rw [dif_neg h, dif_neg (show (i : J) â‰  j from fun hâ‚‚ => h (hâ‚‚ â–¸ i.2)), comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninstâœ : DecidablePred p\nj : J\nZ : C\nh : Quiver.Hom (f j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f j) h)) (CategoryTheory.CategoryStruct.comp (dite (p j) (fun h => CategoryTheory.Limits.biproduct.Ï€ (Subtype.restrict p f) âŸ¨j, hâŸ©) fun h => 0) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.fromSubtype_Ï€ [DecidablePred p] (j : J) :\n    biproduct.fromSubtype f p â‰« biproduct.Ï€ f j =\n      if h : p j then biproduct.Ï€ (Subtype.restrict p f) âŸ¨j, hâŸ© else 0 := by\n  classical\n  ext i; dsimp\n  rw [biproduct.fromSubtype, biproduct.Î¹_desc_assoc, biproduct.Î¹_Ï€]\n  by_cases h : p j\n  Â· rw [dif_pos h, biproduct.Î¹_Ï€]\n    split_ifs with hâ‚ hâ‚‚ hâ‚‚\n    exacts [rfl, False.elim (hâ‚‚ (Subtype.ext hâ‚)), False.elim (hâ‚ (congr_arg Subtype.val hâ‚‚)), rfl]\n  Â· rw [dif_neg h, dif_neg (show (i : J) â‰  j from fun hâ‚‚ => h (hâ‚‚ â–¸ i.2)), comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_eq_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninstâœ : DecidablePred p\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.Limits.biproduct.lift fun j => dite (p j) (fun h => CategoryTheory.Limits.biproduct.Ï€ (Subtype.restrict p f) âŸ¨j, hâŸ©) fun h => 0)","decl":"theorem biproduct.fromSubtype_eq_lift [DecidablePred p] :\n    biproduct.fromSubtype f p =\n      biproduct.lift fun j => if h : p j then biproduct.Ï€ (Subtype.restrict p f) âŸ¨j, hâŸ© else 0 :=\n  biproduct.hom_ext _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_Ï€_subtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.Limits.biproduct.Ï€ f â†‘j)) (CategoryTheory.Limits.biproduct.Ï€ (Subtype.restrict p f) j)","decl":"@[reassoc] -- Porting note: both version solved using simp\ntheorem biproduct.fromSubtype_Ï€_subtype (j : Subtype p) :\n    biproduct.fromSubtype f p â‰« biproduct.Ï€ f j = biproduct.Ï€ (Subtype.restrict p f) j := by\n  classical\n  ext\n  rw [biproduct.fromSubtype, biproduct.Î¹_desc_assoc, biproduct.Î¹_Ï€, biproduct.Î¹_Ï€]\n  split_ifs with hâ‚ hâ‚‚ hâ‚‚\n  exacts [rfl, False.elim (hâ‚‚ (Subtype.ext hâ‚)), False.elim (hâ‚ (congr_arg Subtype.val hâ‚‚)), rfl]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_Ï€_subtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nZ : C\nh : Quiver.Hom (f â†‘j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f â†‘j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ (Subtype.restrict p f) j) h)","decl":"@[reassoc] -- Porting note: both version solved using simp\ntheorem biproduct.fromSubtype_Ï€_subtype (j : Subtype p) :\n    biproduct.fromSubtype f p â‰« biproduct.Ï€ f j = biproduct.Ï€ (Subtype.restrict p f) j := by\n  classical\n  ext\n  rw [biproduct.fromSubtype, biproduct.Î¹_desc_assoc, biproduct.Î¹_Ï€, biproduct.Î¹_Ï€]\n  split_ifs with hâ‚ hâ‚‚ hâ‚‚\n  exacts [rfl, False.elim (hâ‚‚ (Subtype.ext hâ‚)), False.elim (hâ‚ (congr_arg Subtype.val hâ‚‚)), rfl]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nZ : C\nh : Quiver.Hom (Subtype.restrict p f j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ (Subtype.restrict p f) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ f â†‘j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.toSubtype_Ï€ (j : Subtype p) :\n    biproduct.toSubtype f p â‰« biproduct.Ï€ (Subtype.restrict p f) j = biproduct.Ï€ f j :=\n  biproduct.lift_Ï€ _ _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.Limits.biproduct.Ï€ (Subtype.restrict p f) j)) (CategoryTheory.Limits.biproduct.Ï€ f â†‘j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.toSubtype_Ï€ (j : Subtype p) :\n    biproduct.toSubtype f p â‰« biproduct.Ï€ (Subtype.restrict p f) j = biproduct.Ï€ f j :=\n  biproduct.lift_Ï€ _ _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_toSubtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninstâœ : DecidablePred p\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct (Subtype.restrict p f)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) h)) (CategoryTheory.CategoryStruct.comp (dite (p j) (fun h => CategoryTheory.Limits.biproduct.Î¹ (Subtype.restrict p f) âŸ¨j, hâŸ©) fun h => 0) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_toSubtype [DecidablePred p] (j : J) :\n    biproduct.Î¹ f j â‰« biproduct.toSubtype f p =\n      if h : p j then biproduct.Î¹ (Subtype.restrict p f) âŸ¨j, hâŸ© else 0 := by\n  classical\n  ext i\n  rw [biproduct.toSubtype, Category.assoc, biproduct.lift_Ï€, biproduct.Î¹_Ï€]\n  by_cases h : p j\n  Â· rw [dif_pos h, biproduct.Î¹_Ï€]\n    split_ifs with hâ‚ hâ‚‚ hâ‚‚\n    exacts [rfl, False.elim (hâ‚‚ (Subtype.ext hâ‚)), False.elim (hâ‚ (congr_arg Subtype.val hâ‚‚)), rfl]\n  Â· rw [dif_neg h, dif_neg (show j â‰  i from fun hâ‚‚ => h (hâ‚‚.symm â–¸ i.2)), zero_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_toSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninstâœ : DecidablePred p\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.Limits.biproduct.toSubtype f p)) (dite (p j) (fun h => CategoryTheory.Limits.biproduct.Î¹ (Subtype.restrict p f) âŸ¨j, hâŸ©) fun h => 0)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_toSubtype [DecidablePred p] (j : J) :\n    biproduct.Î¹ f j â‰« biproduct.toSubtype f p =\n      if h : p j then biproduct.Î¹ (Subtype.restrict p f) âŸ¨j, hâŸ© else 0 := by\n  classical\n  ext i\n  rw [biproduct.toSubtype, Category.assoc, biproduct.lift_Ï€, biproduct.Î¹_Ï€]\n  by_cases h : p j\n  Â· rw [dif_pos h, biproduct.Î¹_Ï€]\n    split_ifs with hâ‚ hâ‚‚ hâ‚‚\n    exacts [rfl, False.elim (hâ‚‚ (Subtype.ext hâ‚)), False.elim (hâ‚ (congr_arg Subtype.val hâ‚‚)), rfl]\n  Â· rw [dif_neg h, dif_neg (show j â‰  i from fun hâ‚‚ => h (hâ‚‚.symm â–¸ i.2)), zero_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_eq_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninstâœ : DecidablePred p\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.Limits.biproduct.desc fun j => dite (p j) (fun h => CategoryTheory.Limits.biproduct.Î¹ (Subtype.restrict p f) âŸ¨j, hâŸ©) fun h => 0)","decl":"theorem biproduct.toSubtype_eq_desc [DecidablePred p] :\n    biproduct.toSubtype f p =\n      biproduct.desc fun j => if h : p j then biproduct.Î¹ (Subtype.restrict p f) âŸ¨j, hâŸ© else 0 :=\n  biproduct.hom_ext' _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_toSubtype_subtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f â†‘j) (CategoryTheory.Limits.biproduct.toSubtype f p)) (CategoryTheory.Limits.biproduct.Î¹ (Subtype.restrict p f) j)","decl":"@[reassoc]\ntheorem biproduct.Î¹_toSubtype_subtype (j : Subtype p) :\n    biproduct.Î¹ f j â‰« biproduct.toSubtype f p = biproduct.Î¹ (Subtype.restrict p f) j := by\n  classical\n  ext\n  rw [biproduct.toSubtype, Category.assoc, biproduct.lift_Ï€, biproduct.Î¹_Ï€, biproduct.Î¹_Ï€]\n  split_ifs with hâ‚ hâ‚‚ hâ‚‚\n  exacts [rfl, False.elim (hâ‚‚ (Subtype.ext hâ‚)), False.elim (hâ‚ (congr_arg Subtype.val hâ‚‚)), rfl]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_toSubtype_subtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct (Subtype.restrict p f)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f â†‘j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (Subtype.restrict p f) j) h)","decl":"@[reassoc]\ntheorem biproduct.Î¹_toSubtype_subtype (j : Subtype p) :\n    biproduct.Î¹ f j â‰« biproduct.toSubtype f p = biproduct.Î¹ (Subtype.restrict p f) j := by\n  classical\n  ext\n  rw [biproduct.toSubtype, Category.assoc, biproduct.lift_Ï€, biproduct.Î¹_Ï€, biproduct.Î¹_Ï€]\n  split_ifs with hâ‚ hâ‚‚ hâ‚‚\n  exacts [rfl, False.elim (hâ‚‚ (Subtype.ext hâ‚)), False.elim (hâ‚ (congr_arg Subtype.val hâ‚‚)), rfl]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_fromSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (Subtype.restrict p f) j) (CategoryTheory.Limits.biproduct.fromSubtype f p)) (CategoryTheory.Limits.biproduct.Î¹ f â†‘j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_fromSubtype (j : Subtype p) :\n    biproduct.Î¹ (Subtype.restrict p f) j â‰« biproduct.fromSubtype f p = biproduct.Î¹ f j :=\n  biproduct.Î¹_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_fromSubtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (Subtype.restrict p f) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f â†‘j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_fromSubtype (j : Subtype p) :\n    biproduct.Î¹ (Subtype.restrict p f) j â‰« biproduct.fromSubtype f p = biproduct.Î¹ f j :=\n  biproduct.Î¹_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_toSubtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct (Subtype.restrict p f)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.fromSubtype_toSubtype :\n    biproduct.fromSubtype f p â‰« biproduct.toSubtype f p = ğŸ™ (â¨ Subtype.restrict p f) := by\n  refine biproduct.hom_ext _ _ fun j => ?_\n  rw [Category.assoc, biproduct.toSubtype_Ï€, biproduct.fromSubtype_Ï€_subtype, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_toSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.Limits.biproduct.toSubtype f p)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biproduct (Subtype.restrict p f)))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.fromSubtype_toSubtype :\n    biproduct.fromSubtype f p â‰« biproduct.toSubtype f p = ğŸ™ (â¨ Subtype.restrict p f) := by\n  refine biproduct.hom_ext _ _ fun j => ?_\n  rw [Category.assoc, biproduct.toSubtype_Ï€, biproduct.fromSubtype_Ï€_subtype, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_fromSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninstâœ : DecidablePred p\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.Limits.biproduct.fromSubtype f p)) (CategoryTheory.Limits.biproduct.map fun j => ite (p j) (CategoryTheory.CategoryStruct.id (f j)) 0)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.toSubtype_fromSubtype [DecidablePred p] :\n    biproduct.toSubtype f p â‰« biproduct.fromSubtype f p =\n      biproduct.map fun j => if p j then ğŸ™ (f j) else 0 := by\n  ext1 i\n  by_cases h : p i\n  Â· simp [h]\n  Â· simp [h]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_fromSubtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasBiproduct f\np : J â†’ Prop\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninstâœ : DecidablePred p\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map fun j => ite (p j) (CategoryTheory.CategoryStruct.id (f j)) 0) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.toSubtype_fromSubtype [DecidablePred p] :\n    biproduct.toSubtype f p â‰« biproduct.fromSubtype f p =\n      biproduct.map fun j => if p j then ğŸ™ (f j) else 0 := by\n  ext1 i\n  by_cases h : p i\n  Â· simp [h]\n  Â· simp [h]\n\n"}
{"name":"CategoryTheory.Limits.instHasKernelÏ€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ni : J\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\nâŠ¢ CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.biproduct.Ï€ f i)","decl":"instance : HasKernel (biproduct.Ï€ f i) :=\n  HasLimit.mk âŸ¨_, biproduct.isLimitFromSubtype f iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernelBiproductÏ€Iso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ni : J\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\nâŠ¢ Eq (CategoryTheory.Limits.kernelBiproductÏ€Iso f i).hom ((CategoryTheory.Limits.biproduct.isLimitFromSubtype f i).lift (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.Ï€ f i) 0)))","decl":"/-- The kernel of `biproduct.Ï€ f i` is `â¨ Subtype.restrict {i}á¶œ f`. -/\n@[simps!]\ndef kernelBiproductÏ€Iso : kernel (biproduct.Ï€ f i) â‰… â¨ Subtype.restrict (fun j => j â‰  i) f :=\n  limit.isoLimitCone âŸ¨_, biproduct.isLimitFromSubtype f iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernelBiproductÏ€Iso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ni : J\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\nâŠ¢ Eq (CategoryTheory.Limits.kernelBiproductÏ€Iso f i).inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.Ï€ f i) 0) (CategoryTheory.Limits.KernelFork.ofÎ¹ (CategoryTheory.Limits.biproduct.fromSubtype f fun j => Not (Eq j i)) â‹¯))","decl":"/-- The kernel of `biproduct.Ï€ f i` is `â¨ Subtype.restrict {i}á¶œ f`. -/\n@[simps!]\ndef kernelBiproductÏ€Iso : kernel (biproduct.Ï€ f i) â‰… â¨ Subtype.restrict (fun j => j â‰  i) f :=\n  limit.isoLimitCone âŸ¨_, biproduct.isLimitFromSubtype f iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.instHasCokernelÎ¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ni : J\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\nâŠ¢ CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.biproduct.Î¹ f i)","decl":"instance : HasCokernel (biproduct.Î¹ f i) :=\n  HasColimit.mk âŸ¨_, biproduct.isColimitToSubtype f iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiproductÎ¹Iso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ni : J\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\nâŠ¢ Eq (CategoryTheory.Limits.cokernelBiproductÎ¹Iso f i).hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.Î¹ f i) 0) (CategoryTheory.Limits.CokernelCofork.ofÏ€ (CategoryTheory.Limits.biproduct.toSubtype f fun j => Not (Eq j i)) â‹¯))","decl":"/-- The cokernel of `biproduct.Î¹ f i` is `â¨ Subtype.restrict {i}á¶œ f`. -/\n@[simps!]\ndef cokernelBiproductÎ¹Iso : cokernel (biproduct.Î¹ f i) â‰… â¨ Subtype.restrict (fun j => j â‰  i) f :=\n  colimit.isoColimitCocone âŸ¨_, biproduct.isColimitToSubtype f iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiproductÎ¹Iso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ni : J\ninstâœÂ¹ : CategoryTheory.Limits.HasBiproduct f\ninstâœ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\nâŠ¢ Eq (CategoryTheory.Limits.cokernelBiproductÎ¹Iso f i).inv ((CategoryTheory.Limits.biproduct.isColimitToSubtype f i).desc (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.Î¹ f i) 0)))","decl":"/-- The cokernel of `biproduct.Î¹ f i` is `â¨ Subtype.restrict {i}á¶œ f`. -/\n@[simps!]\ndef cokernelBiproductÎ¹Iso : cokernel (biproduct.Î¹ f i) â‰… â¨ Subtype.restrict (fun j => j â‰  i) f :=\n  colimit.isoColimitCocone âŸ¨_, biproduct.isColimitToSubtype f iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernelForkBiproductToSubtype_cone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ Eq (CategoryTheory.Limits.kernelForkBiproductToSubtype f p).cone (CategoryTheory.Limits.KernelFork.ofÎ¹ (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) â‹¯)","decl":"/-- The limit cone exhibiting `â¨ Subtype.restrict pá¶œ f` as the kernel of\n`biproduct.toSubtype f p` -/\n@[simps]\ndef kernelForkBiproductToSubtype (p : Set K) :\n    LimitCone (parallelPair (biproduct.toSubtype f p) 0) where\n  cone :=\n    KernelFork.ofÎ¹ (biproduct.fromSubtype f pá¶œ)\n      (by\n        classical\n        ext j k\n        simp only [Category.assoc, biproduct.Î¹_fromSubtype_assoc, biproduct.Î¹_toSubtype_assoc,\n          comp_zero, zero_comp]\n        rw [dif_neg k.2]\n        simp only [zero_comp])\n  isLimit :=\n    KernelFork.IsLimit.ofÎ¹ _ _ (fun {_} g _ => g â‰« biproduct.toSubtype f pá¶œ)\n      (by\n        classical\n        intro W' g' w\n        ext j\n        simp only [Category.assoc, biproduct.toSubtype_fromSubtype, Pi.compl_apply,\n          biproduct.map_Ï€]\n        split_ifs with h\n        Â· simp\n        Â· replace w := w =â‰« biproduct.Ï€ _ âŸ¨j, not_not.mp hâŸ©\n          simpa using w.symm)\n      (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.kernelForkBiproductToSubtype_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ Eq (CategoryTheory.Limits.kernelForkBiproductToSubtype f p).isLimit (CategoryTheory.Limits.KernelFork.IsLimit.ofÎ¹ (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) â‹¯ (fun {x} g x_1 => CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p))) â‹¯ â‹¯)","decl":"/-- The limit cone exhibiting `â¨ Subtype.restrict pá¶œ f` as the kernel of\n`biproduct.toSubtype f p` -/\n@[simps]\ndef kernelForkBiproductToSubtype (p : Set K) :\n    LimitCone (parallelPair (biproduct.toSubtype f p) 0) where\n  cone :=\n    KernelFork.ofÎ¹ (biproduct.fromSubtype f pá¶œ)\n      (by\n        classical\n        ext j k\n        simp only [Category.assoc, biproduct.Î¹_fromSubtype_assoc, biproduct.Î¹_toSubtype_assoc,\n          comp_zero, zero_comp]\n        rw [dif_neg k.2]\n        simp only [zero_comp])\n  isLimit :=\n    KernelFork.IsLimit.ofÎ¹ _ _ (fun {_} g _ => g â‰« biproduct.toSubtype f pá¶œ)\n      (by\n        classical\n        intro W' g' w\n        ext j\n        simp only [Category.assoc, biproduct.toSubtype_fromSubtype, Pi.compl_apply,\n          biproduct.map_Ï€]\n        split_ifs with h\n        Â· simp\n        Â· replace w := w =â‰« biproduct.Ï€ _ âŸ¨j, not_not.mp hâŸ©\n          simpa using w.symm)\n      (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.instHasKernelToSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.biproduct.toSubtype f p)","decl":"instance (p : Set K) : HasKernel (biproduct.toSubtype f p) :=\n  HasLimit.mk (kernelForkBiproductToSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.kernelBiproductToSubtypeIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ Eq (CategoryTheory.Limits.kernelBiproductToSubtypeIso f p).inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.toSubtype f p) 0) (CategoryTheory.Limits.KernelFork.ofÎ¹ (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) â‹¯))","decl":"/-- The kernel of `biproduct.toSubtype f p` is `â¨ Subtype.restrict pá¶œ f`. -/\n@[simps!]\ndef kernelBiproductToSubtypeIso (p : Set K) :\n    kernel (biproduct.toSubtype f p) â‰… â¨ Subtype.restrict pá¶œ f :=\n  limit.isoLimitCone (kernelForkBiproductToSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.kernelBiproductToSubtypeIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ Eq (CategoryTheory.Limits.kernelBiproductToSubtypeIso f p).hom ((CategoryTheory.Limits.KernelFork.IsLimit.ofÎ¹ (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) â‹¯ (fun {x} g x_1 => CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p))) â‹¯ â‹¯).lift (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.toSubtype f p) 0)))","decl":"/-- The kernel of `biproduct.toSubtype f p` is `â¨ Subtype.restrict pá¶œ f`. -/\n@[simps!]\ndef kernelBiproductToSubtypeIso (p : Set K) :\n    kernel (biproduct.toSubtype f p) â‰… â¨ Subtype.restrict pá¶œ f :=\n  limit.isoLimitCone (kernelForkBiproductToSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.cokernelCoforkBiproductFromSubtype_cocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ Eq (CategoryTheory.Limits.cokernelCoforkBiproductFromSubtype f p).cocone (CategoryTheory.Limits.CokernelCofork.ofÏ€ (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p)) â‹¯)","decl":"/-- The colimit cocone exhibiting `â¨ Subtype.restrict pá¶œ f` as the cokernel of\n`biproduct.fromSubtype f p` -/\n@[simps]\ndef cokernelCoforkBiproductFromSubtype (p : Set K) :\n    ColimitCocone (parallelPair (biproduct.fromSubtype f p) 0) where\n  cocone :=\n    CokernelCofork.ofÏ€ (biproduct.toSubtype f pá¶œ)\n      (by\n        classical\n        ext j k\n        simp only [Category.assoc, Pi.compl_apply, biproduct.Î¹_fromSubtype_assoc,\n          biproduct.Î¹_toSubtype_assoc, comp_zero, zero_comp]\n        rw [dif_neg]\n        Â· simp only [zero_comp]\n        Â· exact not_not.mpr k.2)\n  isColimit :=\n    CokernelCofork.IsColimit.ofÏ€ _ _ (fun {_} g _ => biproduct.fromSubtype f pá¶œ â‰« g)\n      (by\n        classical\n        intro W g' w\n        ext j\n        simp only [biproduct.toSubtype_fromSubtype_assoc, Pi.compl_apply, biproduct.Î¹_map_assoc]\n        split_ifs with h\n        Â· simp\n        Â· replace w := biproduct.Î¹ _ (âŸ¨j, not_not.mp hâŸ© : p) â‰«= w\n          simpa using w.symm)\n      (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.cokernelCoforkBiproductFromSubtype_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ Eq (CategoryTheory.Limits.cokernelCoforkBiproductFromSubtype f p).isColimit (CategoryTheory.Limits.CokernelCofork.IsColimit.ofÏ€ (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p)) â‹¯ (fun {x} g x_1 => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) g) â‹¯ â‹¯)","decl":"/-- The colimit cocone exhibiting `â¨ Subtype.restrict pá¶œ f` as the cokernel of\n`biproduct.fromSubtype f p` -/\n@[simps]\ndef cokernelCoforkBiproductFromSubtype (p : Set K) :\n    ColimitCocone (parallelPair (biproduct.fromSubtype f p) 0) where\n  cocone :=\n    CokernelCofork.ofÏ€ (biproduct.toSubtype f pá¶œ)\n      (by\n        classical\n        ext j k\n        simp only [Category.assoc, Pi.compl_apply, biproduct.Î¹_fromSubtype_assoc,\n          biproduct.Î¹_toSubtype_assoc, comp_zero, zero_comp]\n        rw [dif_neg]\n        Â· simp only [zero_comp]\n        Â· exact not_not.mpr k.2)\n  isColimit :=\n    CokernelCofork.IsColimit.ofÏ€ _ _ (fun {_} g _ => biproduct.fromSubtype f pá¶œ â‰« g)\n      (by\n        classical\n        intro W g' w\n        ext j\n        simp only [biproduct.toSubtype_fromSubtype_assoc, Pi.compl_apply, biproduct.Î¹_map_assoc]\n        split_ifs with h\n        Â· simp\n        Â· replace w := biproduct.Î¹ _ (âŸ¨j, not_not.mp hâŸ© : p) â‰«= w\n          simpa using w.symm)\n      (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.instHasCokernelFromSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.biproduct.fromSubtype f p)","decl":"instance (p : Set K) : HasCokernel (biproduct.fromSubtype f p) :=\n  HasColimit.mk (cokernelCoforkBiproductFromSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiproductFromSubtypeIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ Eq (CategoryTheory.Limits.cokernelBiproductFromSubtypeIso f p).hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.fromSubtype f p) 0) (CategoryTheory.Limits.CokernelCofork.ofÏ€ (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p)) â‹¯))","decl":"/-- The cokernel of `biproduct.fromSubtype f p` is `â¨ Subtype.restrict pá¶œ f`. -/\n@[simps!]\ndef cokernelBiproductFromSubtypeIso (p : Set K) :\n    cokernel (biproduct.fromSubtype f p) â‰… â¨ Subtype.restrict pá¶œ f :=\n  colimit.isoColimitCocone (cokernelCoforkBiproductFromSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiproductFromSubtypeIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninstâœÂ¹ : Finite K\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K â†’ C\np : Set K\nâŠ¢ Eq (CategoryTheory.Limits.cokernelBiproductFromSubtypeIso f p).inv ((CategoryTheory.Limits.CokernelCofork.IsColimit.ofÏ€ (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p)) â‹¯ (fun {x} g x_1 => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) g) â‹¯ â‹¯).desc (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.fromSubtype f p) 0)))","decl":"/-- The cokernel of `biproduct.fromSubtype f p` is `â¨ Subtype.restrict pá¶œ f`. -/\n@[simps!]\ndef cokernelBiproductFromSubtypeIso (p : Set K) :\n    cokernel (biproduct.fromSubtype f p) â‰… â¨ Subtype.restrict pá¶œ f :=\n  colimit.isoColimitCocone (cokernelCoforkBiproductFromSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninstâœâ´ : Finite J\nK : Type\ninstâœÂ³ : Finite K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.Limits.biproduct.Ï€ g k)) (CategoryTheory.Limits.biproduct.desc fun j => m j k)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.matrix_Ï€ (m : âˆ€ j k, f j âŸ¶ g k) (k : K) :\n    biproduct.matrix m â‰« biproduct.Ï€ g k = biproduct.desc fun j => m j k := by\n  ext\n  simp [biproduct.matrix]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninstâœâ´ : Finite J\nK : Type\ninstâœÂ³ : Finite K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nk : K\nZ : C\nh : Quiver.Hom (g k) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ g k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc fun j => m j k) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.matrix_Ï€ (m : âˆ€ j k, f j âŸ¶ g k) (k : K) :\n    biproduct.matrix m â‰« biproduct.Ï€ g k = biproduct.desc fun j => m j k := by\n  ext\n  simp [biproduct.matrix]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_matrix","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninstâœâ´ : Finite J\nK : Type\ninstâœÂ³ : Finite K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.Limits.biproduct.matrix m)) (CategoryTheory.Limits.biproduct.lift fun k => m j k)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_matrix (m : âˆ€ j k, f j âŸ¶ g k) (j : J) :\n    biproduct.Î¹ f j â‰« biproduct.matrix m = biproduct.lift fun k => m j k := by\n  ext\n  simp [biproduct.matrix]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_matrix_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninstâœâ´ : Finite J\nK : Type\ninstâœÂ³ : Finite K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift fun k => m j k) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.Î¹_matrix (m : âˆ€ j k, f j âŸ¶ g k) (j : J) :\n    biproduct.Î¹ f j â‰« biproduct.matrix m = biproduct.lift fun k => m j k := by\n  ext\n  simp [biproduct.matrix]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_components","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninstâœâ´ : Finite J\nK : Type\ninstâœÂ³ : Finite K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.components (CategoryTheory.Limits.biproduct.matrix m) j k) (m j k)","decl":"@[simp]\ntheorem biproduct.matrix_components (m : âˆ€ j k, f j âŸ¶ g k) (j : J) (k : K) :\n    biproduct.components (biproduct.matrix m) j k = m j k := by simp [biproduct.components]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.components_matrix","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninstâœâ´ : Finite J\nK : Type\ninstâœÂ³ : Finite K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nm : Quiver.Hom (CategoryTheory.Limits.biproduct f) (CategoryTheory.Limits.biproduct g)\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.Limits.biproduct.components m j k) m","decl":"@[simp]\ntheorem biproduct.components_matrix (m : â¨ f âŸ¶ â¨ g) :\n    (biproduct.matrix fun j k => biproduct.components m j k) = m := by\n  ext\n  simp [biproduct.components]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrixEquiv_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninstâœâ´ : Finite J\nK : Type\ninstâœÂ³ : Finite K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nm : Quiver.Hom (CategoryTheory.Limits.biproduct f) (CategoryTheory.Limits.biproduct g)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.matrixEquiv m j k) (CategoryTheory.Limits.biproduct.components m j k)","decl":"/-- Morphisms between direct sums are matrices. -/\n@[simps]\ndef biproduct.matrixEquiv : (â¨ f âŸ¶ â¨ g) â‰ƒ âˆ€ j k, f j âŸ¶ g k where\n  toFun := biproduct.components\n  invFun := biproduct.matrix\n  left_inv := biproduct.components_matrix\n  right_inv m := by\n    ext\n    apply biproduct.matrix_components\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrixEquiv_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninstâœâ´ : Finite J\nK : Type\ninstâœÂ³ : Finite K\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J â†’ C\ng : K â†’ C\nm : (j : J) â†’ (k : K) â†’ Quiver.Hom (f j) (g k)\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.matrixEquiv.symm m) (CategoryTheory.Limits.biproduct.matrix m)","decl":"/-- Morphisms between direct sums are matrices. -/\n@[simps]\ndef biproduct.matrixEquiv : (â¨ f âŸ¶ â¨ g) â‰ƒ âˆ€ j k, f j âŸ¶ g k where\n  toFun := biproduct.components\n  invFun := biproduct.matrix\n  left_inv := biproduct.components_matrix\n  right_inv m := by\n    ext\n    apply biproduct.matrix_components\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Î¹_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nb : J\nâŠ¢ CategoryTheory.IsSplitMono (CategoryTheory.Limits.biproduct.Î¹ f b)","decl":"instance biproduct.Î¹_mono (f : J â†’ C) [HasBiproduct f] (b : J) : IsSplitMono (biproduct.Î¹ f b) := by\n  classical exact IsSplitMono.mk' { retraction := biproduct.desc <| Pi.single b (ğŸ™ (f b)) }\n\n"}
{"name":"CategoryTheory.Limits.biproduct.Ï€_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nb : J\nâŠ¢ CategoryTheory.IsSplitEpi (CategoryTheory.Limits.biproduct.Ï€ f b)","decl":"instance biproduct.Ï€_epi (f : J â†’ C) [HasBiproduct f] (b : J) : IsSplitEpi (biproduct.Ï€ f b) := by\n  classical exact IsSplitEpi.mk' { section_ := biproduct.lift <| Pi.single b (ğŸ™ (f b)) }\n\n"}
{"name":"CategoryTheory.Limits.biproduct.conePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nb : CategoryTheory.Limits.Bicone f\nhb : b.IsBilimit\nâŠ¢ Eq (hb.isLimit.conePointUniqueUpToIso (CategoryTheory.Limits.biproduct.isLimit f)).hom (CategoryTheory.Limits.biproduct.lift b.Ï€)","decl":"/-- Auxiliary lemma for `biproduct.uniqueUpToIso`. -/\ntheorem biproduct.conePointUniqueUpToIso_hom (f : J â†’ C) [HasBiproduct f] {b : Bicone f}\n    (hb : b.IsBilimit) :\n    (hb.isLimit.conePointUniqueUpToIso (biproduct.isLimit _)).hom = biproduct.lift b.Ï€ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biproduct.conePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nb : CategoryTheory.Limits.Bicone f\nhb : b.IsBilimit\nâŠ¢ Eq (hb.isLimit.conePointUniqueUpToIso (CategoryTheory.Limits.biproduct.isLimit f)).inv (CategoryTheory.Limits.biproduct.desc b.Î¹)","decl":"/-- Auxiliary lemma for `biproduct.uniqueUpToIso`. -/\ntheorem biproduct.conePointUniqueUpToIso_inv (f : J â†’ C) [HasBiproduct f] {b : Bicone f}\n    (hb : b.IsBilimit) :\n    (hb.isLimit.conePointUniqueUpToIso (biproduct.isLimit _)).inv = biproduct.desc b.Î¹ := by\n  classical\n  refine biproduct.hom_ext' _ _ fun j => hb.isLimit.hom_ext fun j' => ?_\n  rw [Category.assoc, IsLimit.conePointUniqueUpToIso_inv_comp, Bicone.toCone_Ï€_app,\n    biproduct.bicone_Ï€, biproduct.Î¹_desc, biproduct.Î¹_Ï€, b.toCone_Ï€_app, b.Î¹_Ï€]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nb : CategoryTheory.Limits.Bicone f\nhb : b.IsBilimit\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.uniqueUpToIso f hb).hom (CategoryTheory.Limits.biproduct.lift b.Ï€)","decl":"/-- Biproducts are unique up to isomorphism. This already follows because bilimits are limits,\n    but in the case of biproducts we can give an isomorphism with particularly nice definitional\n    properties, namely that `biproduct.lift b.Ï€` and `biproduct.desc b.Î¹` are inverses of each\n    other. -/\n@[simps]\ndef biproduct.uniqueUpToIso (f : J â†’ C) [HasBiproduct f] {b : Bicone f} (hb : b.IsBilimit) :\n    b.pt â‰… â¨ f where\n  hom := biproduct.lift b.Ï€\n  inv := biproduct.desc b.Î¹\n  hom_inv_id := by\n    rw [â† biproduct.conePointUniqueUpToIso_hom f hb, â†\n      biproduct.conePointUniqueUpToIso_inv f hb, Iso.hom_inv_id]\n  inv_hom_id := by\n    rw [â† biproduct.conePointUniqueUpToIso_hom f hb, â†\n      biproduct.conePointUniqueUpToIso_inv f hb, Iso.inv_hom_id]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasBiproduct f\nb : CategoryTheory.Limits.Bicone f\nhb : b.IsBilimit\nâŠ¢ Eq (CategoryTheory.Limits.biproduct.uniqueUpToIso f hb).inv (CategoryTheory.Limits.biproduct.desc b.Î¹)","decl":"/-- Biproducts are unique up to isomorphism. This already follows because bilimits are limits,\n    but in the case of biproducts we can give an isomorphism with particularly nice definitional\n    properties, namely that `biproduct.lift b.Ï€` and `biproduct.desc b.Î¹` are inverses of each\n    other. -/\n@[simps]\ndef biproduct.uniqueUpToIso (f : J â†’ C) [HasBiproduct f] {b : Bicone f} (hb : b.IsBilimit) :\n    b.pt â‰… â¨ f where\n  hom := biproduct.lift b.Ï€\n  inv := biproduct.desc b.Î¹\n  hom_inv_id := by\n    rw [â† biproduct.conePointUniqueUpToIso_hom f hb, â†\n      biproduct.conePointUniqueUpToIso_inv f hb, Iso.hom_inv_id]\n  inv_hom_id := by\n    rw [â† biproduct.conePointUniqueUpToIso_hom f hb, â†\n      biproduct.conePointUniqueUpToIso_inv f hb, Iso.inv_hom_id]\n\n"}
{"name":"CategoryTheory.Limits.hasZeroObject_of_hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nâŠ¢ CategoryTheory.Limits.HasZeroObject C","decl":"/-- A category with finite biproducts has a zero object. -/\ninstance (priority := 100) hasZeroObject_of_hasFiniteBiproducts [HasFiniteBiproducts C] :\n    HasZeroObject C := by\n  refine âŸ¨âŸ¨biproduct Empty.elim, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, ?_âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, ?_âŸ©âŸ©âŸ©âŸ©\n  Â· intro a; apply biproduct.hom_ext'; simp\n  Â· intro a; apply biproduct.hom_ext; simp\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_bicone_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : Unique J\nf : J â†’ C\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.limitBiconeOfUnique f).bicone.Î¹ j) (CategoryTheory.eqToHom â‹¯)","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J â†’ C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      Ï€ := fun j => eqToHom (by congr; rw [â† Unique.uniq] )\n      Î¹ := fun j => eqToHom (by congr; rw [â† Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_isBilimit_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : Unique J\nf : J â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.limitBiconeOfUnique f).isBilimit.isLimit (CategoryTheory.Limits.limitConeOfUnique f).isLimit","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J â†’ C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      Ï€ := fun j => eqToHom (by congr; rw [â† Unique.uniq] )\n      Î¹ := fun j => eqToHom (by congr; rw [â† Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_bicone_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : Unique J\nf : J â†’ C\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.limitBiconeOfUnique f).bicone.Ï€ j) (CategoryTheory.eqToHom â‹¯)","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J â†’ C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      Ï€ := fun j => eqToHom (by congr; rw [â† Unique.uniq] )\n      Î¹ := fun j => eqToHom (by congr; rw [â† Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_isBilimit_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : Unique J\nf : J â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.limitBiconeOfUnique f).isBilimit.isColimit (CategoryTheory.Limits.colimitCoconeOfUnique f).isColimit","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J â†’ C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      Ï€ := fun j => eqToHom (by congr; rw [â† Unique.uniq] )\n      Î¹ := fun j => eqToHom (by congr; rw [â† Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_bicone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : Unique J\nf : J â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.limitBiconeOfUnique f).bicone.pt (f Inhabited.default)","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J â†’ C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      Ï€ := fun j => eqToHom (by congr; rw [â† Unique.uniq] )\n      Î¹ := fun j => eqToHom (by congr; rw [â† Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.hasBiproduct_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : Subsingleton J\ninstâœ : Nonempty J\nf : J â†’ C\nâŠ¢ CategoryTheory.Limits.HasBiproduct f","decl":"instance (priority := 100) hasBiproduct_unique [Subsingleton J] [Nonempty J] (f : J â†’ C) :\n    HasBiproduct f :=\n  let âŸ¨_âŸ© := nonempty_unique J; .mk (limitBiconeOfUnique f)\n\n"}
{"name":"CategoryTheory.Limits.biproductUniqueIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : Unique J\nf : J â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.biproductUniqueIso f).inv (CategoryTheory.Limits.biproduct.lift (CategoryTheory.Limits.limitBiconeOfUnique f).bicone.Ï€)","decl":"/-- A biproduct over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef biproductUniqueIso [Unique J] (f : J â†’ C) : â¨ f â‰… f default :=\n  (biproduct.uniqueUpToIso _ (limitBiconeOfUnique f).isBilimit).symm\n\n"}
{"name":"CategoryTheory.Limits.biproductUniqueIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : Unique J\nf : J â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.biproductUniqueIso f).hom (CategoryTheory.Limits.biproduct.desc (CategoryTheory.Limits.limitBiconeOfUnique f).bicone.Î¹)","decl":"/-- A biproduct over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef biproductUniqueIso [Unique J] (f : J â†’ C) : â¨ f â‰… f default :=\n  (biproduct.uniqueUpToIso _ (limitBiconeOfUnique f).isBilimit).symm\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inl_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.inl self.snd) 0","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl â‰« fst = ğŸ™ P`, `inl â‰« snd = 0`, `inr â‰« fst = 0`, and `inr â‰« snd = ğŸ™ Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt âŸ¶ P\n  snd : pt âŸ¶ Q\n  inl : P âŸ¶ pt\n  inr : Q âŸ¶ pt\n  inl_fst : inl â‰« fst = ğŸ™ P := by aesop\n  inl_snd : inl â‰« snd = 0 := by aesop\n  inr_fst : inr â‰« fst = 0 := by aesop\n  inr_snd : inr â‰« snd = ğŸ™ Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\ninstâœ : SizeOf C\npt : C\nfst : Quiver.Hom pt P\nsnd : Quiver.Hom pt Q\ninl : Quiver.Hom P pt\ninr : Quiver.Hom Q pt\ninl_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl fst) (CategoryTheory.CategoryStruct.id P)) _autoâœ\ninl_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl snd) 0) _autoâœ\ninr_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr fst) 0) _autoâœ\ninr_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr snd) (CategoryTheory.CategoryStruct.id Q)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { pt := pt, fst := fst, snd := snd, inl := inl, inr := inr, inl_fst := inl_fst, inl_snd := inl_snd, inr_fst := inr_fst, inr_snd := inr_snd }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf pt)) (SizeOf.sizeOf fst)) (SizeOf.sizeOf snd)) (SizeOf.sizeOf inl)) (SizeOf.sizeOf inr)) (SizeOf.sizeOf inl_fst)) (SizeOf.sizeOf inl_snd)) (SizeOf.sizeOf inr_fst)) (SizeOf.sizeOf inr_snd))","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl â‰« fst = ğŸ™ P`, `inl â‰« snd = 0`, `inr â‰« fst = 0`, and `inr â‰« snd = ğŸ™ Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt âŸ¶ P\n  snd : pt âŸ¶ Q\n  inl : P âŸ¶ pt\n  inr : Q âŸ¶ pt\n  inl_fst : inl â‰« fst = ğŸ™ P := by aesop\n  inl_snd : inl â‰« snd = 0 := by aesop\n  inr_fst : inr â‰« fst = 0 := by aesop\n  inr_snd : inr â‰« snd = ğŸ™ Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inr_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.inr self.fst) 0","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl â‰« fst = ğŸ™ P`, `inl â‰« snd = 0`, `inr â‰« fst = 0`, and `inr â‰« snd = ğŸ™ Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt âŸ¶ P\n  snd : pt âŸ¶ Q\n  inl : P âŸ¶ pt\n  inr : Q âŸ¶ pt\n  inl_fst : inl â‰« fst = ğŸ™ P := by aesop\n  inl_snd : inl â‰« snd = 0 := by aesop\n  inr_fst : inr â‰« fst = 0 := by aesop\n  inr_snd : inr â‰« snd = ğŸ™ Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q ptâœ : C\nfstâœ : Quiver.Hom ptâœ P\nsndâœ : Quiver.Hom ptâœ Q\ninlâœ : Quiver.Hom P ptâœ\ninrâœ : Quiver.Hom Q ptâœ\ninl_fstâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inlâœ fstâœ) (CategoryTheory.CategoryStruct.id P)) _autoâœ\ninl_sndâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inlâœ sndâœ) 0) _autoâœ\ninr_fstâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inrâœ fstâœ) 0) _autoâœ\ninr_sndâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inrâœ sndâœ) (CategoryTheory.CategoryStruct.id Q)) _autoâœ\npt : C\nfst : Quiver.Hom pt P\nsnd : Quiver.Hom pt Q\ninl : Quiver.Hom P pt\ninr : Quiver.Hom Q pt\ninl_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl fst) (CategoryTheory.CategoryStruct.id P)) _autoâœ\ninl_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl snd) 0) _autoâœ\ninr_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr fst) 0) _autoâœ\ninr_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr snd) (CategoryTheory.CategoryStruct.id Q)) _autoâœ\nxâœ : Eq { pt := ptâœ, fst := fstâœ, snd := sndâœ, inl := inlâœ, inr := inrâœ, inl_fst := inl_fstâœ, inl_snd := inl_sndâœ, inr_fst := inr_fstâœ, inr_snd := inr_sndâœ } { pt := pt, fst := fst, snd := snd, inl := inl, inr := inr, inl_fst := inl_fst, inl_snd := inl_snd, inr_fst := inr_fst, inr_snd := inr_snd }\nâŠ¢ And (Eq ptâœ pt) (And (HEq fstâœ fst) (And (HEq sndâœ snd) (And (HEq inlâœ inl) (HEq inrâœ inr))))","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl â‰« fst = ğŸ™ P`, `inl â‰« snd = 0`, `inr â‰« fst = 0`, and `inr â‰« snd = ğŸ™ Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt âŸ¶ P\n  snd : pt âŸ¶ Q\n  inl : P âŸ¶ pt\n  inr : Q âŸ¶ pt\n  inl_fst : inl â‰« fst = ğŸ™ P := by aesop\n  inl_snd : inl â‰« snd = 0 := by aesop\n  inr_fst : inr â‰« fst = 0 := by aesop\n  inr_snd : inr â‰« snd = ğŸ™ Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q ptâœ : C\nfstâœ : Quiver.Hom ptâœ P\nsndâœ : Quiver.Hom ptâœ Q\ninlâœ : Quiver.Hom P ptâœ\ninrâœ : Quiver.Hom Q ptâœ\ninl_fstâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inlâœ fstâœ) (CategoryTheory.CategoryStruct.id P)) _autoâœ\ninl_sndâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inlâœ sndâœ) 0) _autoâœ\ninr_fstâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inrâœ fstâœ) 0) _autoâœ\ninr_sndâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inrâœ sndâœ) (CategoryTheory.CategoryStruct.id Q)) _autoâœ\npt : C\nfst : Quiver.Hom pt P\nsnd : Quiver.Hom pt Q\ninl : Quiver.Hom P pt\ninr : Quiver.Hom Q pt\ninl_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl fst) (CategoryTheory.CategoryStruct.id P)) _autoâœ\ninl_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl snd) 0) _autoâœ\ninr_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr fst) 0) _autoâœ\ninr_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr snd) (CategoryTheory.CategoryStruct.id Q)) _autoâœ\nâŠ¢ Eq (Eq { pt := ptâœ, fst := fstâœ, snd := sndâœ, inl := inlâœ, inr := inrâœ, inl_fst := inl_fstâœ, inl_snd := inl_sndâœ, inr_fst := inr_fstâœ, inr_snd := inr_sndâœ } { pt := pt, fst := fst, snd := snd, inl := inl, inr := inr, inl_fst := inl_fst, inl_snd := inl_snd, inr_fst := inr_fst, inr_snd := inr_snd }) (And (Eq ptâœ pt) (And (HEq fstâœ fst) (And (HEq sndâœ snd) (And (HEq inlâœ inl) (HEq inrâœ inr)))))","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl â‰« fst = ğŸ™ P`, `inl â‰« snd = 0`, `inr â‰« fst = 0`, and `inr â‰« snd = ğŸ™ Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt âŸ¶ P\n  snd : pt âŸ¶ Q\n  inl : P âŸ¶ pt\n  inr : Q âŸ¶ pt\n  inl_fst : inl â‰« fst = ğŸ™ P := by aesop\n  inl_snd : inl â‰« snd = 0 := by aesop\n  inr_fst : inr â‰« fst = 0 := by aesop\n  inr_snd : inr â‰« snd = ğŸ™ Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inr_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.inr self.snd) (CategoryTheory.CategoryStruct.id Q)","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl â‰« fst = ğŸ™ P`, `inl â‰« snd = 0`, `inr â‰« fst = 0`, and `inr â‰« snd = ğŸ™ Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt âŸ¶ P\n  snd : pt âŸ¶ Q\n  inl : P âŸ¶ pt\n  inr : Q âŸ¶ pt\n  inl_fst : inl â‰« fst = ğŸ™ P := by aesop\n  inl_snd : inl â‰« snd = 0 := by aesop\n  inr_fst : inr â‰« fst = 0 := by aesop\n  inr_snd : inr â‰« snd = ğŸ™ Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inl_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.inl self.fst) (CategoryTheory.CategoryStruct.id P)","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl â‰« fst = ğŸ™ P`, `inl â‰« snd = 0`, `inr â‰« fst = 0`, and `inr â‰« snd = ğŸ™ Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt âŸ¶ P\n  snd : pt âŸ¶ Q\n  inl : P âŸ¶ pt\n  inr : Q âŸ¶ pt\n  inl_fst : inl â‰« fst = ğŸ™ P := by aesop\n  inl_snd : inl â‰« snd = 0 := by aesop\n  inr_fst : inr â‰« fst = 0 := by aesop\n  inr_snd : inr â‰« snd = ğŸ™ Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inr_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nZ : C\nh : Quiver.Hom P Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.inr (CategoryTheory.CategoryStruct.comp self.fst h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)]\n  BinaryBicone.inl_fst BinaryBicone.inl_snd BinaryBicone.inr_fst BinaryBicone.inr_snd\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inl_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nZ : C\nh : Quiver.Hom Q Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.inl (CategoryTheory.CategoryStruct.comp self.snd h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)]\n  BinaryBicone.inl_fst BinaryBicone.inl_snd BinaryBicone.inr_fst BinaryBicone.inr_snd\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inl_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nZ : C\nh : Quiver.Hom P Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.inl (CategoryTheory.CategoryStruct.comp self.fst h)) h","decl":"attribute [reassoc (attr := simp)]\n  BinaryBicone.inl_fst BinaryBicone.inl_snd BinaryBicone.inr_fst BinaryBicone.inr_snd\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inr_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nZ : C\nh : Quiver.Hom Q Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.inr (CategoryTheory.CategoryStruct.comp self.snd h)) h","decl":"attribute [reassoc (attr := simp)]\n  BinaryBicone.inl_fst BinaryBicone.inl_snd BinaryBicone.inr_fst BinaryBicone.inr_snd\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\ninstâœ : SizeOf C\nhom : Quiver.Hom A.pt B.pt\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.fst) A.fst) _autoâœ\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.snd) A.snd) _autoâœ\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl hom) B.inl) _autoâœ\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr hom) B.inr) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { hom := hom, wfst := wfst, wsnd := wsnd, winl := winl, winr := winr }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf wfst)) (SizeOf.sizeOf wsnd)) (SizeOf.sizeOf winl)) (SizeOf.sizeOf winr))","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom â‰« B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom â‰« B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl â‰« hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr â‰« hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nhomâœ : Quiver.Hom A.pt B.pt\nwfstâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp homâœ B.fst) A.fst) _autoâœ\nwsndâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp homâœ B.snd) A.snd) _autoâœ\nwinlâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl homâœ) B.inl) _autoâœ\nwinrâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr homâœ) B.inr) _autoâœ\nhom : Quiver.Hom A.pt B.pt\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.fst) A.fst) _autoâœ\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.snd) A.snd) _autoâœ\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl hom) B.inl) _autoâœ\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr hom) B.inr) _autoâœ\nxâœ : Eq { hom := homâœ, wfst := wfstâœ, wsnd := wsndâœ, winl := winlâœ, winr := winrâœ } { hom := hom, wfst := wfst, wsnd := wsnd, winl := winl, winr := winr }\nâŠ¢ Eq homâœ hom","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom â‰« B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom â‰« B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl â‰« hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr â‰« hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.wsnd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.hom B.snd) A.snd","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom â‰« B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom â‰« B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl â‰« hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr â‰« hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nhomâœ : Quiver.Hom A.pt B.pt\nwfstâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp homâœ B.fst) A.fst) _autoâœ\nwsndâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp homâœ B.snd) A.snd) _autoâœ\nwinlâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl homâœ) B.inl) _autoâœ\nwinrâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr homâœ) B.inr) _autoâœ\nhom : Quiver.Hom A.pt B.pt\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.fst) A.fst) _autoâœ\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.snd) A.snd) _autoâœ\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl hom) B.inl) _autoâœ\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr hom) B.inr) _autoâœ\nâŠ¢ Eq (Eq { hom := homâœ, wfst := wfstâœ, wsnd := wsndâœ, winl := winlâœ, winr := winrâœ } { hom := hom, wfst := wfst, wsnd := wsnd, winl := winl, winr := winr }) (Eq homâœ hom)","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom â‰« B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom â‰« B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl â‰« hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr â‰« hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.wfst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.hom B.fst) A.fst","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom â‰« B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom â‰« B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl â‰« hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr â‰« hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.winl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp A.inl self.hom) B.inl","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom â‰« B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom â‰« B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl â‰« hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr â‰« hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.winr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp A.inr self.hom) B.inr","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt âŸ¶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom â‰« B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom â‰« B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl â‰« hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr â‰« hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.wsnd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nZ : C\nh : Quiver.Hom Q Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp B.snd h)) (CategoryTheory.CategoryStruct.comp A.snd h)","decl":"attribute [reassoc (attr := simp)] BinaryBiconeMorphism.wfst BinaryBiconeMorphism.wsnd\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.wfst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nZ : C\nh : Quiver.Hom P Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp B.fst h)) (CategoryTheory.CategoryStruct.comp A.fst h)","decl":"attribute [reassoc (attr := simp)] BinaryBiconeMorphism.wfst BinaryBiconeMorphism.wsnd\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.winr_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nZ : C\nh : Quiver.Hom B.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp A.inr (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp B.inr h)","decl":"attribute [reassoc (attr := simp)] BinaryBiconeMorphism.winl BinaryBiconeMorphism.winr\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.winl_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nZ : C\nh : Quiver.Hom B.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp A.inl (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp B.inl h)","decl":"attribute [reassoc (attr := simp)] BinaryBiconeMorphism.winl BinaryBiconeMorphism.winr\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.category_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nXâœ Yâœ Zâœ : CategoryTheory.Limits.BinaryBicone P Q\nf : Quiver.Hom Xâœ Yâœ\ng : Quiver.Hom Yâœ Zâœ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- The category of binary bicones on a given diagram. -/\n@[simps]\ninstance BinaryBicone.category {P Q : C} : Category (BinaryBicone P Q) where\n  Hom A B := BinaryBiconeMorphism A B\n  comp f g := { hom := f.hom â‰« g.hom }\n  id B := { hom := ğŸ™ B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the `hom` field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.category_id_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nB : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id B).hom (CategoryTheory.CategoryStruct.id B.pt)","decl":"/-- The category of binary bicones on a given diagram. -/\n@[simps]\ninstance BinaryBicone.category {P Q : C} : Category (BinaryBicone P Q) where\n  Hom A B := BinaryBiconeMorphism A B\n  comp f g := { hom := f.hom â‰« g.hom }\n  id B := { hom := ğŸ™ B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the `hom` field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc c' : CategoryTheory.Limits.BinaryBicone P Q\nf g : Quiver.Hom c c'\nâŠ¢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\ntheorem BinaryBiconeMorphism.ext {P Q : C} {c c' : BinaryBicone P Q}\n    (f g : c âŸ¶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc c' : CategoryTheory.Limits.BinaryBicone P Q\nf g : Quiver.Hom c c'\nw : Eq f.hom g.hom\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem BinaryBiconeMorphism.ext {P Q : C} {c c' : BinaryBicone P Q}\n    (f g : c âŸ¶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc c' : CategoryTheory.Limits.BinaryBicone P Q\nÏ† : CategoryTheory.Iso c.pt c'.pt\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp c.inl Ï†.hom) c'.inl) _autoâœ\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp c.inr Ï†.hom) c'.inr) _autoâœ\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp Ï†.hom c'.fst) c.fst) _autoâœ\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp Ï†.hom c'.snd) c.snd) _autoâœ\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicones.ext Ï† winl winr wfst wsnd).inv.hom Ï†.inv","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {P Q : C} {c c' : BinaryBicone P Q} (Ï† : c.pt â‰… c'.pt)\n    (winl : c.inl â‰« Ï†.hom = c'.inl := by aesop_cat)\n    (winr : c.inr â‰« Ï†.hom = c'.inr := by aesop_cat)\n    (wfst : Ï†.hom â‰« c'.fst = c.fst := by aesop_cat)\n    (wsnd : Ï†.hom â‰« c'.snd = c.snd := by aesop_cat) : c â‰… c' where\n  hom := { hom := Ï†.hom }\n  inv :=\n    { hom := Ï†.inv\n      wfst := Ï†.inv_comp_eq.mpr wfst.symm\n      wsnd := Ï†.inv_comp_eq.mpr wsnd.symm\n      winl := Ï†.comp_inv_eq.mpr winl.symm\n      winr := Ï†.comp_inv_eq.mpr winr.symm }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc c' : CategoryTheory.Limits.BinaryBicone P Q\nÏ† : CategoryTheory.Iso c.pt c'.pt\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp c.inl Ï†.hom) c'.inl) _autoâœ\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp c.inr Ï†.hom) c'.inr) _autoâœ\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp Ï†.hom c'.fst) c.fst) _autoâœ\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp Ï†.hom c'.snd) c.snd) _autoâœ\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicones.ext Ï† winl winr wfst wsnd).hom.hom Ï†.hom","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {P Q : C} {c c' : BinaryBicone P Q} (Ï† : c.pt â‰… c'.pt)\n    (winl : c.inl â‰« Ï†.hom = c'.inl := by aesop_cat)\n    (winr : c.inr â‰« Ï†.hom = c'.inr := by aesop_cat)\n    (wfst : Ï†.hom â‰« c'.fst = c.fst := by aesop_cat)\n    (wsnd : Ï†.hom â‰« c'.snd = c.snd := by aesop_cat) : c â‰… c' where\n  hom := { hom := Ï†.hom }\n  inv :=\n    { hom := Ï†.inv\n      wfst := Ï†.inv_comp_eq.mpr wfst.symm\n      wsnd := Ï†.inv_comp_eq.mpr wsnd.symm\n      winl := Ï†.comp_inv_eq.mpr winl.symm\n      winr := Ï†.comp_inv_eq.mpr winr.symm }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ¹ : CategoryTheory.Category.{uD', uD} D\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).fst (F.map A.fst)","decl":"/-- A functor `F : C â¥¤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q â¥¤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [â† F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [â† F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [â† F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [â† F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, â† f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, â† f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, â† f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, â† f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ¹ : CategoryTheory.Category.{uD', uD} D\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).inr (F.map A.inr)","decl":"/-- A functor `F : C â¥¤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q â¥¤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [â† F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [â† F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [â† F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [â† F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, â† f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, â† f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, â† f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, â† f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ¹ : CategoryTheory.Category.{uD', uD} D\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).snd (F.map A.snd)","decl":"/-- A functor `F : C â¥¤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q â¥¤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [â† F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [â† F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [â† F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [â† F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, â† f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, â† f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, â† f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, â† f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ¹ : CategoryTheory.Category.{uD', uD} D\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nXâœ Yâœ : CategoryTheory.Limits.BinaryBicone P Q\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).map f).hom (F.map f.hom)","decl":"/-- A functor `F : C â¥¤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q â¥¤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [â† F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [â† F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [â† F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [â† F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, â† f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, â† f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, â† f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, â† f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ¹ : CategoryTheory.Category.{uD', uD} D\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).inl (F.map A.inl)","decl":"/-- A functor `F : C â¥¤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q â¥¤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [â† F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [â† F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [â† F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [â† F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, â† f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, â† f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, â† f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, â† f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ¹ : CategoryTheory.Category.{uD', uD} D\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).pt (F.obj A.pt)","decl":"/-- A functor `F : C â¥¤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q â¥¤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [â† F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [â† F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [â† F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [â† F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, â† f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, â† f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, â† f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, â† f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_full","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ³ : CategoryTheory.Category.{uD', uD} D\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : F.Full\ninstâœ : F.Faithful\nâŠ¢ (CategoryTheory.Limits.BinaryBicones.functoriality P Q F).Full","decl":"instance functoriality_full [F.Full] [F.Faithful] : (functoriality P Q F).Full where\n  map_surjective t :=\n   âŸ¨{ hom := F.preimage t.hom\n      winl := F.map_injective (by simpa using t.winl)\n      winr := F.map_injective (by simpa using t.winr)\n      wfst := F.map_injective (by simpa using t.wfst)\n      wsnd := F.map_injective (by simpa using t.wsnd) }, by aesop_catâŸ©\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_faithful","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninstâœÂ² : CategoryTheory.Category.{uD', uD} D\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\ninstâœ : F.Faithful\nâŠ¢ (CategoryTheory.Limits.BinaryBicones.functoriality P Q F).Faithful","decl":"instance functoriality_faithful [F.Faithful] : (functoriality P Q F).Faithful where\n  map_injective {_X} {_Y} f g h :=\n    BinaryBiconeMorphism.ext f g <| F.map_injective <| congr_arg BinaryBiconeMorphism.hom h\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq c.toCone.pt c.pt","decl":"@[simp]\ntheorem toCone_pt (c : BinaryBicone P Q) : c.toCone.pt = c.pt := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCone_Ï€_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (c.toCone.Ï€.app { as := CategoryTheory.Limits.WalkingPair.left }) c.fst","decl":"@[simp]\ntheorem toCone_Ï€_app_left (c : BinaryBicone P Q) : c.toCone.Ï€.app âŸ¨WalkingPair.leftâŸ© = c.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCone_Ï€_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (c.toCone.Ï€.app { as := CategoryTheory.Limits.WalkingPair.right }) c.snd","decl":"@[simp]\ntheorem toCone_Ï€_app_right (c : BinaryBicone P Q) : c.toCone.Ï€.app âŸ¨WalkingPair.rightâŸ© = c.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.binary_fan_fst_toCone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (CategoryTheory.Limits.BinaryFan.fst c.toCone) c.fst","decl":"@[simp]\ntheorem binary_fan_fst_toCone (c : BinaryBicone P Q) : BinaryFan.fst c.toCone = c.fst := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.binary_fan_snd_toCone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (CategoryTheory.Limits.BinaryFan.snd c.toCone) c.snd","decl":"@[simp]\ntheorem binary_fan_snd_toCone (c : BinaryBicone P Q) : BinaryFan.snd c.toCone = c.snd := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq c.toCocone.pt c.pt","decl":"@[simp]\ntheorem toCocone_pt (c : BinaryBicone P Q) : c.toCocone.pt = c.pt := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCocone_Î¹_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (c.toCocone.Î¹.app { as := CategoryTheory.Limits.WalkingPair.left }) c.inl","decl":"@[simp]\ntheorem toCocone_Î¹_app_left (c : BinaryBicone P Q) : c.toCocone.Î¹.app âŸ¨WalkingPair.leftâŸ© = c.inl :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCocone_Î¹_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (c.toCocone.Î¹.app { as := CategoryTheory.Limits.WalkingPair.right }) c.inr","decl":"@[simp]\ntheorem toCocone_Î¹_app_right (c : BinaryBicone P Q) :\n    c.toCocone.Î¹.app âŸ¨WalkingPair.rightâŸ© = c.inr := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.binary_cofan_inl_toCocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (CategoryTheory.Limits.BinaryCofan.inl c.toCocone) c.inl","decl":"@[simp]\ntheorem binary_cofan_inl_toCocone (c : BinaryBicone P Q) : BinaryCofan.inl c.toCocone = c.inl :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.binary_cofan_inr_toCocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ Eq (CategoryTheory.Limits.BinaryCofan.inr c.toCocone) c.inr","decl":"@[simp]\ntheorem binary_cofan_inr_toCocone (c : BinaryBicone P Q) : BinaryCofan.inr c.toCocone = c.inr :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.instIsSplitMonoInl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ CategoryTheory.IsSplitMono c.inl","decl":"instance (c : BinaryBicone P Q) : IsSplitMono c.inl :=\n  IsSplitMono.mk'\n    { retraction := c.fst\n      id := c.inl_fst }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.instIsSplitMonoInr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ CategoryTheory.IsSplitMono c.inr","decl":"instance (c : BinaryBicone P Q) : IsSplitMono c.inr :=\n  IsSplitMono.mk'\n    { retraction := c.snd\n      id := c.inr_snd }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.instIsSplitEpiFst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ CategoryTheory.IsSplitEpi c.fst","decl":"instance (c : BinaryBicone P Q) : IsSplitEpi c.fst :=\n  IsSplitEpi.mk'\n    { section_ := c.inl\n      id := c.inl_fst }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.instIsSplitEpiSnd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\nâŠ¢ CategoryTheory.IsSplitEpi c.snd","decl":"instance (c : BinaryBicone P Q) : IsSplitEpi c.snd :=\n  IsSplitEpi.mk'\n    { section_ := c.inr\n      id := c.inr_snd }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toBiconeFunctor_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.toBiconeFunctor.obj b).pt b.pt","decl":"/-- Convert a `BinaryBicone` into a `Bicone` over a pair. -/\n@[simps]\ndef toBiconeFunctor {X Y : C} : BinaryBicone X Y â¥¤ Bicone (pairFunction X Y) where\n  obj b :=\n    { pt := b.pt\n      Ï€ := fun j => WalkingPair.casesOn j b.fst b.snd\n      Î¹ := fun j => WalkingPair.casesOn j b.inl b.inr\n      Î¹_Ï€ := fun j j' => by\n        rcases j with âŸ¨âŸ© <;> rcases j' with âŸ¨âŸ© <;> simp }\n  map f := {\n    hom := f.hom\n    wÏ€ := fun i => WalkingPair.casesOn i f.wfst f.wsnd\n    wÎ¹ := fun i => WalkingPair.casesOn i f.winl f.winr }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toBiconeFunctor_obj_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\nj : CategoryTheory.Limits.WalkingPair\nâŠ¢ Eq ((CategoryTheory.Limits.BinaryBicone.toBiconeFunctor.obj b).Î¹ j) (CategoryTheory.Limits.WalkingPair.casesOn j b.inl b.inr)","decl":"/-- Convert a `BinaryBicone` into a `Bicone` over a pair. -/\n@[simps]\ndef toBiconeFunctor {X Y : C} : BinaryBicone X Y â¥¤ Bicone (pairFunction X Y) where\n  obj b :=\n    { pt := b.pt\n      Ï€ := fun j => WalkingPair.casesOn j b.fst b.snd\n      Î¹ := fun j => WalkingPair.casesOn j b.inl b.inr\n      Î¹_Ï€ := fun j j' => by\n        rcases j with âŸ¨âŸ© <;> rcases j' with âŸ¨âŸ© <;> simp }\n  map f := {\n    hom := f.hom\n    wÏ€ := fun i => WalkingPair.casesOn i f.wfst f.wsnd\n    wÎ¹ := fun i => WalkingPair.casesOn i f.winl f.winr }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toBiconeFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nXâœ Yâœ : CategoryTheory.Limits.BinaryBicone X Y\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBicone.toBiconeFunctor.map f).hom f.hom","decl":"/-- Convert a `BinaryBicone` into a `Bicone` over a pair. -/\n@[simps]\ndef toBiconeFunctor {X Y : C} : BinaryBicone X Y â¥¤ Bicone (pairFunction X Y) where\n  obj b :=\n    { pt := b.pt\n      Ï€ := fun j => WalkingPair.casesOn j b.fst b.snd\n      Î¹ := fun j => WalkingPair.casesOn j b.inl b.inr\n      Î¹_Ï€ := fun j j' => by\n        rcases j with âŸ¨âŸ© <;> rcases j' with âŸ¨âŸ© <;> simp }\n  map f := {\n    hom := f.hom\n    wÏ€ := fun i => WalkingPair.casesOn i f.wfst f.wsnd\n    wÎ¹ := fun i => WalkingPair.casesOn i f.winl f.winr }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toBiconeFunctor_obj_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\nj : CategoryTheory.Limits.WalkingPair\nâŠ¢ Eq ((CategoryTheory.Limits.BinaryBicone.toBiconeFunctor.obj b).Ï€ j) (CategoryTheory.Limits.WalkingPair.casesOn j b.fst b.snd)","decl":"/-- Convert a `BinaryBicone` into a `Bicone` over a pair. -/\n@[simps]\ndef toBiconeFunctor {X Y : C} : BinaryBicone X Y â¥¤ Bicone (pairFunction X Y) where\n  obj b :=\n    { pt := b.pt\n      Ï€ := fun j => WalkingPair.casesOn j b.fst b.snd\n      Î¹ := fun j => WalkingPair.casesOn j b.inl b.inr\n      Î¹_Ï€ := fun j j' => by\n        rcases j with âŸ¨âŸ© <;> rcases j' with âŸ¨âŸ© <;> simp }\n  map f := {\n    hom := f.hom\n    wÏ€ := fun i => WalkingPair.casesOn i f.wfst f.wsnd\n    wÎ¹ := fun i => WalkingPair.casesOn i f.winl f.winr }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\nâŠ¢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).inr (b.Î¹ CategoryTheory.Limits.WalkingPair.right)","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) â¥¤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.Ï€ WalkingPair.left\n      snd := b.Ï€ WalkingPair.right\n      inl := b.Î¹ WalkingPair.left\n      inr := b.Î¹ WalkingPair.right\n      inl_fst := by simp [Bicone.Î¹_Ï€]\n      inr_fst := by simp [Bicone.Î¹_Ï€]\n      inl_snd := by simp [Bicone.Î¹_Ï€]\n      inr_snd := by simp [Bicone.Î¹_Ï€] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\nâŠ¢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).inl (b.Î¹ CategoryTheory.Limits.WalkingPair.left)","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) â¥¤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.Ï€ WalkingPair.left\n      snd := b.Ï€ WalkingPair.right\n      inl := b.Î¹ WalkingPair.left\n      inr := b.Î¹ WalkingPair.right\n      inl_fst := by simp [Bicone.Î¹_Ï€]\n      inr_fst := by simp [Bicone.Î¹_Ï€]\n      inl_snd := by simp [Bicone.Î¹_Ï€]\n      inr_snd := by simp [Bicone.Î¹_Ï€] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\nâŠ¢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).snd (b.Ï€ CategoryTheory.Limits.WalkingPair.right)","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) â¥¤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.Ï€ WalkingPair.left\n      snd := b.Ï€ WalkingPair.right\n      inl := b.Î¹ WalkingPair.left\n      inr := b.Î¹ WalkingPair.right\n      inl_fst := by simp [Bicone.Î¹_Ï€]\n      inr_fst := by simp [Bicone.Î¹_Ï€]\n      inl_snd := by simp [Bicone.Î¹_Ï€]\n      inr_snd := by simp [Bicone.Î¹_Ï€] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nXâœ Yâœ : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.map f).hom f.hom","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) â¥¤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.Ï€ WalkingPair.left\n      snd := b.Ï€ WalkingPair.right\n      inl := b.Î¹ WalkingPair.left\n      inr := b.Î¹ WalkingPair.right\n      inl_fst := by simp [Bicone.Î¹_Ï€]\n      inr_fst := by simp [Bicone.Î¹_Ï€]\n      inl_snd := by simp [Bicone.Î¹_Ï€]\n      inr_snd := by simp [Bicone.Î¹_Ï€] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\nâŠ¢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).pt b.pt","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) â¥¤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.Ï€ WalkingPair.left\n      snd := b.Ï€ WalkingPair.right\n      inl := b.Î¹ WalkingPair.left\n      inr := b.Î¹ WalkingPair.right\n      inl_fst := by simp [Bicone.Î¹_Ï€]\n      inr_fst := by simp [Bicone.Î¹_Ï€]\n      inl_snd := by simp [Bicone.Î¹_Ï€]\n      inr_snd := by simp [Bicone.Î¹_Ï€] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\nâŠ¢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).fst (b.Ï€ CategoryTheory.Limits.WalkingPair.left)","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) â¥¤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.Ï€ WalkingPair.left\n      snd := b.Ï€ WalkingPair.right\n      inl := b.Î¹ WalkingPair.left\n      inr := b.Î¹ WalkingPair.right\n      inl_fst := by simp [Bicone.Î¹_Ï€]\n      inr_fst := by simp [Bicone.Î¹_Ï€]\n      inl_snd := by simp [Bicone.Î¹_Ï€]\n      inr_snd := by simp [Bicone.Î¹_Ï€] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.IsBilimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nb : CategoryTheory.Limits.BinaryBicone P Q\nisLimitâœ : CategoryTheory.Limits.IsLimit b.toCone\nisColimitâœ : CategoryTheory.Limits.IsColimit b.toCocone\nisLimit : CategoryTheory.Limits.IsLimit b.toCone\nisColimit : CategoryTheory.Limits.IsColimit b.toCocone\nxâœ : Eq { isLimit := isLimitâœ, isColimit := isColimitâœ } { isLimit := isLimit, isColimit := isColimit }\nâŠ¢ And (Eq isLimitâœ isLimit) (Eq isColimitâœ isColimit)","decl":"/-- Structure witnessing that a binary bicone is a limit cone and a limit cocone. -/\nstructure BinaryBicone.IsBilimit {P Q : C} (b : BinaryBicone P Q) where\n  isLimit : IsLimit b.toCone\n  isColimit : IsColimit b.toCocone\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.IsBilimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nb : CategoryTheory.Limits.BinaryBicone P Q\ninstâœ : SizeOf C\nisLimit : CategoryTheory.Limits.IsLimit b.toCone\nisColimit : CategoryTheory.Limits.IsColimit b.toCocone\nâŠ¢ Eq (SizeOf.sizeOf { isLimit := isLimit, isColimit := isColimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf isLimit)) (SizeOf.sizeOf isColimit))","decl":"/-- Structure witnessing that a binary bicone is a limit cone and a limit cocone. -/\nstructure BinaryBicone.IsBilimit {P Q : C} (b : BinaryBicone P Q) where\n  isLimit : IsLimit b.toCone\n  isColimit : IsColimit b.toCocone\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.IsBilimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nb : CategoryTheory.Limits.BinaryBicone P Q\nisLimitâœ : CategoryTheory.Limits.IsLimit b.toCone\nisColimitâœ : CategoryTheory.Limits.IsColimit b.toCocone\nisLimit : CategoryTheory.Limits.IsLimit b.toCone\nisColimit : CategoryTheory.Limits.IsColimit b.toCocone\nâŠ¢ Eq (Eq { isLimit := isLimitâœ, isColimit := isColimitâœ } { isLimit := isLimit, isColimit := isColimit }) (And (Eq isLimitâœ isLimit) (Eq isColimitâœ isColimit))","decl":"/-- Structure witnessing that a binary bicone is a limit cone and a limit cocone. -/\nstructure BinaryBicone.IsBilimit {P Q : C} (b : BinaryBicone P Q) where\n  isLimit : IsLimit b.toCone\n  isColimit : IsColimit b.toCocone\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproductData.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nbiconeâœ : CategoryTheory.Limits.BinaryBicone P Q\nisBilimitâœ : biconeâœ.IsBilimit\nbicone : CategoryTheory.Limits.BinaryBicone P Q\nisBilimit : bicone.IsBilimit\nâŠ¢ Eq (Eq { bicone := biconeâœ, isBilimit := isBilimitâœ } { bicone := bicone, isBilimit := isBilimit }) (And (Eq biconeâœ bicone) (HEq isBilimitâœ isBilimit))","decl":"/-- A bicone over `P Q : C`, which is both a limit cone and a colimit cocone.\n-/\nstructure BinaryBiproductData (P Q : C) where\n  bicone : BinaryBicone P Q\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproductData.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nbiconeâœ : CategoryTheory.Limits.BinaryBicone P Q\nisBilimitâœ : biconeâœ.IsBilimit\nbicone : CategoryTheory.Limits.BinaryBicone P Q\nisBilimit : bicone.IsBilimit\nxâœ : Eq { bicone := biconeâœ, isBilimit := isBilimitâœ } { bicone := bicone, isBilimit := isBilimit }\nâŠ¢ And (Eq biconeâœ bicone) (HEq isBilimitâœ isBilimit)","decl":"/-- A bicone over `P Q : C`, which is both a limit cone and a colimit cocone.\n-/\nstructure BinaryBiproductData (P Q : C) where\n  bicone : BinaryBicone P Q\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproductData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\ninstâœ : SizeOf C\nbicone : CategoryTheory.Limits.BinaryBicone P Q\nisBilimit : bicone.IsBilimit\nâŠ¢ Eq (SizeOf.sizeOf { bicone := bicone, isBilimit := isBilimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf bicone)) (SizeOf.sizeOf isBilimit))","decl":"/-- A bicone over `P Q : C`, which is both a limit cone and a colimit cocone.\n-/\nstructure BinaryBiproductData (P Q : C) where\n  bicone : BinaryBicone P Q\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.exists_binary_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.HasBinaryBiproduct P Q\nâŠ¢ Nonempty (CategoryTheory.Limits.BinaryBiproductData P Q)","decl":"/-- `HasBinaryBiproduct P Q` expresses the mere existence of a bicone which is\nsimultaneously a limit and a colimit of the diagram `pair P Q`.\n-/\nclass HasBinaryBiproduct (P Q : C) : Prop where mk' ::\n  exists_binary_biproduct : Nonempty (BinaryBiproductData P Q)\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nd : CategoryTheory.Limits.BinaryBiproductData P Q\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproduct P Q","decl":"theorem HasBinaryBiproduct.mk {P Q : C} (d : BinaryBiproductData P Q) : HasBinaryBiproduct P Q :=\n  âŸ¨Nonempty.intro dâŸ©\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproduct P Q","decl":"/-- `HasBinaryBiproducts C` represents the existence of a bicone which is\nsimultaneously a limit and a colimit of the diagram `pair P Q`, for every `P Q : C`.\n-/\nclass HasBinaryBiproducts : Prop where\n  has_binary_biproduct : âˆ€ P Q : C, HasBinaryBiproduct P Q\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryBiproducts_of_finite_biproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproducts C","decl":"/-- A category with finite biproducts has binary biproducts.\n\nThis is not an instance as typically in concrete categories there will be\nan alternative construction with nicer definitional properties.\n-/\ntheorem hasBinaryBiproducts_of_finite_biproducts [HasFiniteBiproducts C] : HasBinaryBiproducts C :=\n  { has_binary_biproduct := fun P Q =>\n      HasBinaryBiproduct.mk\n        { bicone := (biproduct.bicone (pairFunction P Q)).toBinaryBicone\n          isBilimit := (Bicone.toBinaryBiconeIsBilimit _).symm (biproduct.isBilimit _) } }\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.hasLimit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct P Q\nâŠ¢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair P Q)","decl":"instance HasBinaryBiproduct.hasLimit_pair [HasBinaryBiproduct P Q] : HasLimit (pair P Q) :=\n  HasLimit.mk âŸ¨_, BinaryBiproduct.isLimit P QâŸ©\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.hasColimit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct P Q\nâŠ¢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair P Q)","decl":"instance HasBinaryBiproduct.hasColimit_pair [HasBinaryBiproduct P Q] : HasColimit (pair P Q) :=\n  HasColimit.mk âŸ¨_, BinaryBiproduct.isColimit P QâŸ©\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryProducts_of_hasBinaryBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nâŠ¢ CategoryTheory.Limits.HasBinaryProducts C","decl":"instance (priority := 100) hasBinaryProducts_of_hasBinaryBiproducts [HasBinaryBiproducts C] :\n    HasBinaryProducts C where\n  has_limit F := hasLimitOfIso (diagramIsoPair F).symm\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryCoproducts_of_hasBinaryBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nâŠ¢ CategoryTheory.Limits.HasBinaryCoproducts C","decl":"instance (priority := 100) hasBinaryCoproducts_of_hasBinaryBiproducts [HasBinaryBiproducts C] :\n    HasBinaryCoproducts C where\n  has_colimit F := hasColimitOfIso (diagramIsoPair F)\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproduct.bicone_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).fst CategoryTheory.Limits.biprod.fst","decl":"@[simp]\ntheorem BinaryBiproduct.bicone_fst : (BinaryBiproduct.bicone X Y).fst = biprod.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproduct.bicone_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).snd CategoryTheory.Limits.biprod.snd","decl":"@[simp]\ntheorem BinaryBiproduct.bicone_snd : (BinaryBiproduct.bicone X Y).snd = biprod.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproduct.bicone_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inl CategoryTheory.Limits.biprod.inl","decl":"@[simp]\ntheorem BinaryBiproduct.bicone_inl : (BinaryBiproduct.bicone X Y).inl = biprod.inl :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproduct.bicone_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inr CategoryTheory.Limits.biprod.inr","decl":"@[simp]\ntheorem BinaryBiproduct.bicone_inr : (BinaryBiproduct.bicone X Y).inr = biprod.inr :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) h","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inl_fst {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inl : X âŸ¶ X âŠ Y) â‰« (biprod.fst : X âŠ Y âŸ¶ X) = ğŸ™ X :=\n  (BinaryBiproduct.bicone X Y).inl_fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inl_fst {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inl : X âŸ¶ X âŠ Y) â‰« (biprod.fst : X âŠ Y âŸ¶ X) = ğŸ™ X :=\n  (BinaryBiproduct.bicone X Y).inl_fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nZ : C\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inl_snd {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inl : X âŸ¶ X âŠ Y) â‰« (biprod.snd : X âŠ Y âŸ¶ Y) = 0 :=\n  (BinaryBiproduct.bicone X Y).inl_snd\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.snd) 0","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inl_snd {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inl : X âŸ¶ X âŠ Y) â‰« (biprod.snd : X âŠ Y âŸ¶ Y) = 0 :=\n  (BinaryBiproduct.bicone X Y).inl_snd\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inr_fst {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inr : Y âŸ¶ X âŠ Y) â‰« (biprod.fst : X âŠ Y âŸ¶ X) = 0 :=\n  (BinaryBiproduct.bicone X Y).inr_fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.fst) 0","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inr_fst {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inr : Y âŸ¶ X âŠ Y) â‰« (biprod.fst : X âŠ Y âŸ¶ X) = 0 :=\n  (BinaryBiproduct.bicone X Y).inr_fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.snd) (CategoryTheory.CategoryStruct.id Y)","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inr_snd {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inr : Y âŸ¶ X âŠ Y) â‰« (biprod.snd : X âŠ Y âŸ¶ Y) = ğŸ™ Y :=\n  (BinaryBiproduct.bicone X Y).inr_snd\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nZ : C\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) h","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inr_snd {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inr : Y âŸ¶ X âŠ Y) â‰« (biprod.snd : X âŠ Y âŸ¶ Y) = ğŸ™ Y :=\n  (BinaryBiproduct.bicone X Y).inr_snd\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) CategoryTheory.Limits.biprod.fst) f","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_fst {W X Y : C} [HasBinaryBiproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :\n    biprod.lift f g â‰« biprod.fst = f :=\n  (BinaryBiproduct.isLimit X Y).fac _ âŸ¨WalkingPair.leftâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_fst {W X Y : C} [HasBinaryBiproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :\n    biprod.lift f g â‰« biprod.fst = f :=\n  (BinaryBiproduct.isLimit X Y).fac _ âŸ¨WalkingPair.leftâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_snd {W X Y : C} [HasBinaryBiproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :\n    biprod.lift f g â‰« biprod.snd = g :=\n  (BinaryBiproduct.isLimit X Y).fac _ âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) CategoryTheory.Limits.biprod.snd) g","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_snd {W X Y : C} [HasBinaryBiproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y) :\n    biprod.lift f g â‰« biprod.snd = g :=\n  (BinaryBiproduct.isLimit X Y).fac _ âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.Limits.biprod.desc f g)) f","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inl_desc {W X Y : C} [HasBinaryBiproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) :\n    biprod.inl â‰« biprod.desc f g = f :=\n  (BinaryBiproduct.isColimit X Y).fac _ âŸ¨WalkingPair.leftâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nZ : C\nh : Quiver.Hom W Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inl_desc {W X Y : C} [HasBinaryBiproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) :\n    biprod.inl â‰« biprod.desc f g = f :=\n  (BinaryBiproduct.isColimit X Y).fac _ âŸ¨WalkingPair.leftâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nZ : C\nh : Quiver.Hom W Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inr_desc {W X Y : C} [HasBinaryBiproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) :\n    biprod.inr â‰« biprod.desc f g = g :=\n  (BinaryBiproduct.isColimit X Y).fac _ âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.Limits.biprod.desc f g)) g","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inr_desc {W X Y : C} [HasBinaryBiproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W) :\n    biprod.inr â‰« biprod.desc f g = g :=\n  (BinaryBiproduct.isColimit X Y).fac _ âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.mono_lift_of_mono_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninstâœ : CategoryTheory.Mono f\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.biprod.lift f g)","decl":"instance biprod.mono_lift_of_mono_left {W X Y : C} [HasBinaryBiproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y)\n    [Mono f] : Mono (biprod.lift f g) :=\n  mono_of_mono_fac <| biprod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.biprod.mono_lift_of_mono_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninstâœ : CategoryTheory.Mono g\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.biprod.lift f g)","decl":"instance biprod.mono_lift_of_mono_right {W X Y : C} [HasBinaryBiproduct X Y] (f : W âŸ¶ X) (g : W âŸ¶ Y)\n    [Mono g] : Mono (biprod.lift f g) :=\n  mono_of_mono_fac <| biprod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.biprod.epi_desc_of_epi_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ninstâœ : CategoryTheory.Epi f\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.biprod.desc f g)","decl":"instance biprod.epi_desc_of_epi_left {W X Y : C} [HasBinaryBiproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W)\n    [Epi f] : Epi (biprod.desc f g) :=\n  epi_of_epi_fac <| biprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.biprod.epi_desc_of_epi_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ninstâœ : CategoryTheory.Epi g\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.biprod.desc f g)","decl":"instance biprod.epi_desc_of_epi_right {W X Y : C} [HasBinaryBiproduct X Y] (f : X âŸ¶ W) (g : Y âŸ¶ W)\n    [Epi g] : Epi (biprod.desc f g) :=\n  epi_of_epi_fac <| biprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.biprod.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf g : Quiver.Hom Z (CategoryTheory.Limits.biprod X Y)\nhâ‚€ : Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.fst)\nhâ‚ : Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.snd)\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem biprod.hom_ext {X Y Z : C} [HasBinaryBiproduct X Y] (f g : Z âŸ¶ X âŠ Y)\n    (hâ‚€ : f â‰« biprod.fst = g â‰« biprod.fst) (hâ‚ : f â‰« biprod.snd = g â‰« biprod.snd) : f = g :=\n  BinaryFan.IsLimit.hom_ext (BinaryBiproduct.isLimit X Y) hâ‚€ hâ‚\n\n"}
{"name":"CategoryTheory.Limits.biprod.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf g : Quiver.Hom Z (CategoryTheory.Limits.biprod X Y)\nâŠ¢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.fst)) (Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.snd)))","decl":"@[ext]\ntheorem biprod.hom_ext {X Y Z : C} [HasBinaryBiproduct X Y] (f g : Z âŸ¶ X âŠ Y)\n    (hâ‚€ : f â‰« biprod.fst = g â‰« biprod.fst) (hâ‚ : f â‰« biprod.snd = g â‰« biprod.snd) : f = g :=\n  BinaryFan.IsLimit.hom_ext (BinaryBiproduct.isLimit X Y) hâ‚€ hâ‚\n\n"}
{"name":"CategoryTheory.Limits.biprod.hom_ext'_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf g : Quiver.Hom (CategoryTheory.Limits.biprod X Y) Z\nâŠ¢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl g)) (Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr g)))","decl":"@[ext]\ntheorem biprod.hom_ext' {X Y Z : C} [HasBinaryBiproduct X Y] (f g : X âŠ Y âŸ¶ Z)\n    (hâ‚€ : biprod.inl â‰« f = biprod.inl â‰« g) (hâ‚ : biprod.inr â‰« f = biprod.inr â‰« g) : f = g :=\n  BinaryCofan.IsColimit.hom_ext (BinaryBiproduct.isColimit X Y) hâ‚€ hâ‚\n\n"}
{"name":"CategoryTheory.Limits.biprod.hom_ext'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf g : Quiver.Hom (CategoryTheory.Limits.biprod X Y) Z\nhâ‚€ : Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl g)\nhâ‚ : Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr g)\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem biprod.hom_ext' {X Y Z : C} [HasBinaryBiproduct X Y] (f g : X âŠ Y âŸ¶ Z)\n    (hâ‚€ : biprod.inl â‰« f = biprod.inl â‰« g) (hâ‚ : biprod.inr â‰« f = biprod.inr â‰« g) : f = g :=\n  BinaryCofan.IsColimit.hom_ext (BinaryBiproduct.isColimit X Y) hâ‚€ hâ‚\n\n"}
{"name":"CategoryTheory.Limits.biprod.isoProd_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.biprod.isoProd X Y).hom (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.snd)","decl":"@[simp]\ntheorem biprod.isoProd_hom {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.isoProd X Y).hom = prod.lift biprod.fst biprod.snd := by\n      ext <;> simp [biprod.isoProd]\n\n"}
{"name":"CategoryTheory.Limits.biprod.isoProd_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.biprod.isoProd X Y).inv (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd)","decl":"@[simp]\ntheorem biprod.isoProd_inv {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.isoProd X Y).inv = biprod.lift prod.fst prod.snd := by\n  ext <;> simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.biprod.isoCoprod_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.biprod.isoCoprod X Y).inv (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.inr)","decl":"@[simp]\ntheorem biprod.isoCoprod_inv {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.isoCoprod X Y).inv = coprod.desc biprod.inl biprod.inr := by\n  ext <;> simp [biprod.isoCoprod]\n\n"}
{"name":"CategoryTheory.Limits.biprod_isoCoprod_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.biprod.isoCoprod X Y).hom (CategoryTheory.Limits.biprod.desc CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr)","decl":"@[simp]\ntheorem biprod_isoCoprod_hom {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.isoCoprod X Y).hom = biprod.desc coprod.inl coprod.inr := by\n  ext <;> simp [â† Iso.eq_comp_inv]\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_eq_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.Limits.biprod.map' f g)","decl":"theorem biprod.map_eq_map' {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z]\n    (f : W âŸ¶ Y) (g : X âŸ¶ Z) : biprod.map f g = biprod.map' f g := by\n  ext\n  Â· simp only [mapPair_left, IsColimit.Î¹_map, IsLimit.map_Ï€, biprod.inl_fst_assoc,\n      Category.assoc, â† BinaryBicone.toCone_Ï€_app_left, â† BinaryBiproduct.bicone_fst, â†\n      BinaryBicone.toCocone_Î¹_app_left, â† BinaryBiproduct.bicone_inl]\n    dsimp; simp\n  Â· simp only [mapPair_left, IsColimit.Î¹_map, IsLimit.map_Ï€, zero_comp, biprod.inl_snd_assoc,\n      Category.assoc, â† BinaryBicone.toCone_Ï€_app_right, â† BinaryBiproduct.bicone_snd, â†\n      BinaryBicone.toCocone_Î¹_app_left, â† BinaryBiproduct.bicone_inl]\n    simp\n  Â· simp only [mapPair_right, biprod.inr_fst_assoc, IsColimit.Î¹_map, IsLimit.map_Ï€, zero_comp,\n      Category.assoc, â† BinaryBicone.toCone_Ï€_app_left, â† BinaryBiproduct.bicone_fst, â†\n      BinaryBicone.toCocone_Î¹_app_right, â† BinaryBiproduct.bicone_inr]\n    simp\n  Â· simp only [mapPair_right, IsColimit.Î¹_map, IsLimit.map_Ï€, biprod.inr_snd_assoc,\n      Category.assoc, â† BinaryBicone.toCone_Ï€_app_right, â† BinaryBiproduct.bicone_snd, â†\n      BinaryBicone.toCocone_Î¹_app_right, â† BinaryBiproduct.bicone_inr]\n    simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ CategoryTheory.IsSplitMono CategoryTheory.Limits.biprod.inl","decl":"instance biprod.inl_mono {X Y : C} [HasBinaryBiproduct X Y] :\n    IsSplitMono (biprod.inl : X âŸ¶ X âŠ Y) :=\n  IsSplitMono.mk' { retraction := biprod.fst }\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ CategoryTheory.IsSplitMono CategoryTheory.Limits.biprod.inr","decl":"instance biprod.inr_mono {X Y : C} [HasBinaryBiproduct X Y] :\n    IsSplitMono (biprod.inr : Y âŸ¶ X âŠ Y) :=\n  IsSplitMono.mk' { retraction := biprod.snd }\n\n"}
{"name":"CategoryTheory.Limits.biprod.fst_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ CategoryTheory.IsSplitEpi CategoryTheory.Limits.biprod.fst","decl":"instance biprod.fst_epi {X Y : C} [HasBinaryBiproduct X Y] : IsSplitEpi (biprod.fst : X âŠ Y âŸ¶ X) :=\n  IsSplitEpi.mk' { section_ := biprod.inl }\n\n"}
{"name":"CategoryTheory.Limits.biprod.snd_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ CategoryTheory.IsSplitEpi CategoryTheory.Limits.biprod.snd","decl":"instance biprod.snd_epi {X Y : C} [HasBinaryBiproduct X Y] : IsSplitEpi (biprod.snd : X âŠ Y âŸ¶ Y) :=\n  IsSplitEpi.mk' { section_ := biprod.inr }\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst f)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.map_fst {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W âŸ¶ Y)\n    (g : X âŸ¶ Z) : biprod.map f g â‰« biprod.fst = biprod.fst â‰« f :=\n  IsLimit.map_Ï€ _ _ _ (âŸ¨WalkingPair.leftâŸ© : Discrete WalkingPair)\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Zâœ : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Zâœ\nf : Quiver.Hom W Y\ng : Quiver.Hom X Zâœ\nZ : C\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.map_fst {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W âŸ¶ Y)\n    (g : X âŸ¶ Z) : biprod.map f g â‰« biprod.fst = biprod.fst â‰« f :=\n  IsLimit.map_Ï€ _ _ _ (âŸ¨WalkingPair.leftâŸ© : Discrete WalkingPair)\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) CategoryTheory.Limits.biprod.snd) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd g)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.map_snd {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W âŸ¶ Y)\n    (g : X âŸ¶ Z) : biprod.map f g â‰« biprod.snd = biprod.snd â‰« g :=\n  IsLimit.map_Ï€ _ _ _ (âŸ¨WalkingPair.rightâŸ© : Discrete WalkingPair)\n\n-- Because `biprod.map` is defined in terms of `lim` rather than `colim`,\n-- we need to provide additional `simp` lemmas.\n"}
{"name":"CategoryTheory.Limits.biprod.map_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Zâœ : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Zâœ\nf : Quiver.Hom W Y\ng : Quiver.Hom X Zâœ\nZ : C\nh : Quiver.Hom Zâœ Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.map_snd {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W âŸ¶ Y)\n    (g : X âŸ¶ Z) : biprod.map f g â‰« biprod.snd = biprod.snd â‰« g :=\n  IsLimit.map_Ï€ _ _ _ (âŸ¨WalkingPair.rightâŸ© : Discrete WalkingPair)\n\n-- Because `biprod.map` is defined in terms of `lim` rather than `colim`,\n-- we need to provide additional `simp` lemmas.\n"}
{"name":"CategoryTheory.Limits.biprod.inl_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.Limits.biprod.map f g)) (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.inl)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inl_map {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W âŸ¶ Y)\n    (g : X âŸ¶ Z) : biprod.inl â‰« biprod.map f g = f â‰« biprod.inl := by\n  rw [biprod.map_eq_map']\n  exact IsColimit.Î¹_map (BinaryBiproduct.isColimit W X) _ _ âŸ¨WalkingPair.leftâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Zâœ : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Zâœ\nf : Quiver.Hom W Y\ng : Quiver.Hom X Zâœ\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod Y Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl h))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inl_map {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W âŸ¶ Y)\n    (g : X âŸ¶ Z) : biprod.inl â‰« biprod.map f g = f â‰« biprod.inl := by\n  rw [biprod.map_eq_map']\n  exact IsColimit.Î¹_map (BinaryBiproduct.isColimit W X) _ _ âŸ¨WalkingPair.leftâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Zâœ : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Zâœ\nf : Quiver.Hom W Y\ng : Quiver.Hom X Zâœ\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod Y Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr h))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inr_map {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W âŸ¶ Y)\n    (g : X âŸ¶ Z) : biprod.inr â‰« biprod.map f g = g â‰« biprod.inr := by\n  rw [biprod.map_eq_map']\n  exact IsColimit.Î¹_map (BinaryBiproduct.isColimit W X) _ _ âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.Limits.biprod.map f g)) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.inr)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inr_map {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W âŸ¶ Y)\n    (g : X âŸ¶ Z) : biprod.inr â‰« biprod.map f g = g â‰« biprod.inr := by\n  rw [biprod.map_eq_map']\n  exact IsColimit.Î¹_map (BinaryBiproduct.isColimit W X) _ _ âŸ¨WalkingPair.rightâŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\nâŠ¢ Eq (CategoryTheory.Limits.biprod.mapIso f g).hom (CategoryTheory.Limits.biprod.map f.hom g.hom)","decl":"/-- Given a pair of isomorphisms between the summands of a pair of binary biproducts,\nwe obtain an isomorphism between the binary biproducts. -/\n@[simps]\ndef biprod.mapIso {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W â‰… Y)\n    (g : X â‰… Z) : W âŠ X â‰… Y âŠ Z where\n  hom := biprod.map f.hom g.hom\n  inv := biprod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.biprod.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\nâŠ¢ Eq (CategoryTheory.Limits.biprod.mapIso f g).inv (CategoryTheory.Limits.biprod.map f.inv g.inv)","decl":"/-- Given a pair of isomorphisms between the summands of a pair of binary biproducts,\nwe obtain an isomorphism between the binary biproducts. -/\n@[simps]\ndef biprod.mapIso {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W â‰… Y)\n    (g : X â‰… Z) : W âŠ X â‰… Y âŠ Z where\n  hom := biprod.map f.hom g.hom\n  inv := biprod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.biprod.conePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nb : CategoryTheory.Limits.BinaryBicone X Y\nhb : b.IsBilimit\nâŠ¢ Eq (hb.isLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).hom (CategoryTheory.Limits.biprod.lift b.fst b.snd)","decl":"/-- Auxiliary lemma for `biprod.uniqueUpToIso`. -/\ntheorem biprod.conePointUniqueUpToIso_hom (X Y : C) [HasBinaryBiproduct X Y] {b : BinaryBicone X Y}\n    (hb : b.IsBilimit) :\n    (hb.isLimit.conePointUniqueUpToIso (BinaryBiproduct.isLimit _ _)).hom =\n      biprod.lift b.fst b.snd := rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nb : CategoryTheory.Limits.BinaryBicone X Y\nhb : b.IsBilimit\nâŠ¢ Eq (hb.isLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).inv (CategoryTheory.Limits.biprod.desc b.inl b.inr)","decl":"/-- Auxiliary lemma for `biprod.uniqueUpToIso`. -/\ntheorem biprod.conePointUniqueUpToIso_inv (X Y : C) [HasBinaryBiproduct X Y] {b : BinaryBicone X Y}\n    (hb : b.IsBilimit) :\n    (hb.isLimit.conePointUniqueUpToIso (BinaryBiproduct.isLimit _ _)).inv =\n      biprod.desc b.inl b.inr := by\n  refine biprod.hom_ext' _ _ (hb.isLimit.hom_ext fun j => ?_) (hb.isLimit.hom_ext fun j => ?_)\n  all_goals\n    simp only [Category.assoc, IsLimit.conePointUniqueUpToIso_inv_comp]\n    rcases j with âŸ¨âŸ¨âŸ©âŸ©\n  all_goals simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nb : CategoryTheory.Limits.BinaryBicone X Y\nhb : b.IsBilimit\nâŠ¢ Eq (CategoryTheory.Limits.biprod.uniqueUpToIso X Y hb).hom (CategoryTheory.Limits.biprod.lift b.fst b.snd)","decl":"/-- Binary biproducts are unique up to isomorphism. This already follows because bilimits are\n    limits, but in the case of biproducts we can give an isomorphism with particularly nice\n    definitional properties, namely that `biprod.lift b.fst b.snd` and `biprod.desc b.inl b.inr`\n    are inverses of each other. -/\n@[simps]\ndef biprod.uniqueUpToIso (X Y : C) [HasBinaryBiproduct X Y] {b : BinaryBicone X Y}\n    (hb : b.IsBilimit) : b.pt â‰… X âŠ Y where\n  hom := biprod.lift b.fst b.snd\n  inv := biprod.desc b.inl b.inr\n  hom_inv_id := by\n    rw [â† biprod.conePointUniqueUpToIso_hom X Y hb, â†\n      biprod.conePointUniqueUpToIso_inv X Y hb, Iso.hom_inv_id]\n  inv_hom_id := by\n    rw [â† biprod.conePointUniqueUpToIso_hom X Y hb, â†\n      biprod.conePointUniqueUpToIso_inv X Y hb, Iso.inv_hom_id]\n\n-- There are three further variations,\n-- about `IsIso biprod.inr`, `IsIso biprod.fst` and `IsIso biprod.snd`,\n-- but any one suffices to prove `indecomposable_of_simple`\n-- and they are likely not separately useful.\n"}
{"name":"CategoryTheory.Limits.biprod.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nb : CategoryTheory.Limits.BinaryBicone X Y\nhb : b.IsBilimit\nâŠ¢ Eq (CategoryTheory.Limits.biprod.uniqueUpToIso X Y hb).inv (CategoryTheory.Limits.biprod.desc b.inl b.inr)","decl":"/-- Binary biproducts are unique up to isomorphism. This already follows because bilimits are\n    limits, but in the case of biproducts we can give an isomorphism with particularly nice\n    definitional properties, namely that `biprod.lift b.fst b.snd` and `biprod.desc b.inl b.inr`\n    are inverses of each other. -/\n@[simps]\ndef biprod.uniqueUpToIso (X Y : C) [HasBinaryBiproduct X Y] {b : BinaryBicone X Y}\n    (hb : b.IsBilimit) : b.pt â‰… X âŠ Y where\n  hom := biprod.lift b.fst b.snd\n  inv := biprod.desc b.inl b.inr\n  hom_inv_id := by\n    rw [â† biprod.conePointUniqueUpToIso_hom X Y hb, â†\n      biprod.conePointUniqueUpToIso_inv X Y hb, Iso.hom_inv_id]\n  inv_hom_id := by\n    rw [â† biprod.conePointUniqueUpToIso_hom X Y hb, â†\n      biprod.conePointUniqueUpToIso_inv X Y hb, Iso.inv_hom_id]\n\n-- There are three further variations,\n-- about `IsIso biprod.inr`, `IsIso biprod.fst` and `IsIso biprod.snd`,\n-- but any one suffices to prove `indecomposable_of_simple`\n-- and they are likely not separately useful.\n"}
{"name":"CategoryTheory.Limits.biprod.isIso_inl_iff_id_eq_fst_comp_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Iff (CategoryTheory.IsIso CategoryTheory.Limits.biprod.inl) (Eq (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod X Y)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.inl))","decl":"theorem biprod.isIso_inl_iff_id_eq_fst_comp_inl (X Y : C) [HasBinaryBiproduct X Y] :\n    IsIso (biprod.inl : X âŸ¶ X âŠ Y) â†” ğŸ™ (X âŠ Y) = biprod.fst â‰« biprod.inl := by\n  constructor\n  Â· intro h\n    have := (cancel_epi (inv biprod.inl : X âŠ Y âŸ¶ X)).2 <| @biprod.inl_fst _ _ _ X Y _\n    rw [IsIso.inv_hom_id_assoc, Category.comp_id] at this\n    rw [this, IsIso.inv_hom_id]\n  Â· intro h\n    exact âŸ¨âŸ¨biprod.fst, biprod.inl_fst, h.symmâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninstâœÂ³ : CategoryTheory.Epi f\ninstâœÂ² : CategoryTheory.Epi g\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.biprod.map f g)","decl":"instance biprod.map_epi {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [Epi f]\n    [Epi g] [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] : Epi (biprod.map f g) := by\n  rw [show biprod.map f g =\n    (biprod.isoCoprod _ _).hom â‰« coprod.map f g â‰« (biprod.isoCoprod _ _).inv by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.prod.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninstâœÂ³ : CategoryTheory.Epi f\ninstâœÂ² : CategoryTheory.Epi g\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.prod.map f g)","decl":"instance prod.map_epi {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [Epi f]\n    [Epi g] [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] : Epi (prod.map f g) := by\n  rw [show prod.map f g = (biprod.isoProd _ _).inv â‰« biprod.map f g â‰«\n    (biprod.isoProd _ _).hom by simp]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninstâœÂ³ : CategoryTheory.Mono f\ninstâœÂ² : CategoryTheory.Mono g\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.biprod.map f g)","decl":"instance biprod.map_mono {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [Mono f]\n    [Mono g] [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] : Mono (biprod.map f g) := by\n  rw [show biprod.map f g = (biprod.isoProd _ _).hom â‰« prod.map f g â‰«\n    (biprod.isoProd _ _).inv by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninstâœÂ³ : CategoryTheory.Mono f\ninstâœÂ² : CategoryTheory.Mono g\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.coprod.map f g)","decl":"instance coprod.map_mono {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) [Mono f]\n    [Mono g] [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] : Mono (coprod.map f g) := by\n  rw [show coprod.map f g = (biprod.isoCoprod _ _).inv â‰« biprod.map f g â‰«\n    (biprod.isoCoprod _ _).hom by simp]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.fstKernelFork_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nc : CategoryTheory.Limits.BinaryBicone X Y\nâŠ¢ Eq (CategoryTheory.Limits.Fork.Î¹ c.fstKernelFork) c.inr","decl":"@[simp]\ntheorem BinaryBicone.fstKernelFork_Î¹ : (BinaryBicone.fstKernelFork c).Î¹ = c.inr := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.sndKernelFork_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nc : CategoryTheory.Limits.BinaryBicone X Y\nâŠ¢ Eq (CategoryTheory.Limits.Fork.Î¹ c.sndKernelFork) c.inl","decl":"@[simp]\ntheorem BinaryBicone.sndKernelFork_Î¹ : (BinaryBicone.sndKernelFork c).Î¹ = c.inl := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inlCokernelCofork_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nc : CategoryTheory.Limits.BinaryBicone X Y\nâŠ¢ Eq (CategoryTheory.Limits.Cofork.Ï€ c.inlCokernelCofork) c.snd","decl":"@[simp]\ntheorem BinaryBicone.inlCokernelCofork_Ï€ : (BinaryBicone.inlCokernelCofork c).Ï€ = c.snd := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inrCokernelCofork_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nc : CategoryTheory.Limits.BinaryBicone X Y\nâŠ¢ Eq (CategoryTheory.Limits.Cofork.Ï€ c.inrCokernelCofork) c.fst","decl":"@[simp]\ntheorem BinaryBicone.inrCokernelCofork_Ï€ : (BinaryBicone.inrCokernelCofork c).Ï€ = c.fst := rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.fstKernelFork_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.Fork.Î¹ (CategoryTheory.Limits.biprod.fstKernelFork X Y)) CategoryTheory.Limits.biprod.inr","decl":"@[simp]\ntheorem biprod.fstKernelFork_Î¹ : Fork.Î¹ (biprod.fstKernelFork X Y) = (biprod.inr : Y âŸ¶ X âŠ Y) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.sndKernelFork_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.Fork.Î¹ (CategoryTheory.Limits.biprod.sndKernelFork X Y)) CategoryTheory.Limits.biprod.inl","decl":"@[simp]\ntheorem biprod.sndKernelFork_Î¹ : Fork.Î¹ (biprod.sndKernelFork X Y) = (biprod.inl : X âŸ¶ X âŠ Y) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.inlCokernelCofork_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.Cofork.Ï€ (CategoryTheory.Limits.biprod.inlCokernelCofork X Y)) CategoryTheory.Limits.biprod.snd","decl":"@[simp]\ntheorem biprod.inlCokernelCofork_Ï€ : Cofork.Ï€ (biprod.inlCokernelCofork X Y) = biprod.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.inrCokernelCofork_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq (CategoryTheory.Limits.Cofork.Ï€ (CategoryTheory.Limits.biprod.inrCokernelCofork X Y)) CategoryTheory.Limits.biprod.fst","decl":"@[simp]\ntheorem biprod.inrCokernelCofork_Ï€ : Cofork.Ï€ (biprod.inrCokernelCofork X Y) = biprod.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.instHasKernelFst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ CategoryTheory.Limits.HasKernel CategoryTheory.Limits.biprod.fst","decl":"instance : HasKernel (biprod.fst : X âŠ Y âŸ¶ X) :=\n  HasLimit.mk âŸ¨_, biprod.isKernelFstKernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernelBiprodFstIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq CategoryTheory.Limits.kernelBiprodFstIso.hom ((CategoryTheory.Limits.biprod.isKernelFstKernelFork X Y).lift (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.fst 0)))","decl":"/-- The kernel of `biprod.fst : X âŠ Y âŸ¶ X` is `Y`. -/\n@[simps!]\ndef kernelBiprodFstIso : kernel (biprod.fst : X âŠ Y âŸ¶ X) â‰… Y :=\n  limit.isoLimitCone âŸ¨_, biprod.isKernelFstKernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernelBiprodFstIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq CategoryTheory.Limits.kernelBiprodFstIso.inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.fst 0) (CategoryTheory.Limits.biprod.fstKernelFork X Y))","decl":"/-- The kernel of `biprod.fst : X âŠ Y âŸ¶ X` is `Y`. -/\n@[simps!]\ndef kernelBiprodFstIso : kernel (biprod.fst : X âŠ Y âŸ¶ X) â‰… Y :=\n  limit.isoLimitCone âŸ¨_, biprod.isKernelFstKernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.instHasKernelSnd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ CategoryTheory.Limits.HasKernel CategoryTheory.Limits.biprod.snd","decl":"instance : HasKernel (biprod.snd : X âŠ Y âŸ¶ Y) :=\n  HasLimit.mk âŸ¨_, biprod.isKernelSndKernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernelBiprodSndIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq CategoryTheory.Limits.kernelBiprodSndIso.hom ((CategoryTheory.Limits.biprod.isKernelSndKernelFork X Y).lift (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.snd 0)))","decl":"/-- The kernel of `biprod.snd : X âŠ Y âŸ¶ Y` is `X`. -/\n@[simps!]\ndef kernelBiprodSndIso : kernel (biprod.snd : X âŠ Y âŸ¶ Y) â‰… X :=\n  limit.isoLimitCone âŸ¨_, biprod.isKernelSndKernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernelBiprodSndIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq CategoryTheory.Limits.kernelBiprodSndIso.inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.snd 0) (CategoryTheory.Limits.biprod.sndKernelFork X Y))","decl":"/-- The kernel of `biprod.snd : X âŠ Y âŸ¶ Y` is `X`. -/\n@[simps!]\ndef kernelBiprodSndIso : kernel (biprod.snd : X âŠ Y âŸ¶ Y) â‰… X :=\n  limit.isoLimitCone âŸ¨_, biprod.isKernelSndKernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.instHasCokernelInl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ CategoryTheory.Limits.HasCokernel CategoryTheory.Limits.biprod.inl","decl":"instance : HasCokernel (biprod.inl : X âŸ¶ X âŠ Y) :=\n  HasColimit.mk âŸ¨_, biprod.isCokernelInlCokernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiprodInlIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq CategoryTheory.Limits.cokernelBiprodInlIso.hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.inl 0) (CategoryTheory.Limits.biprod.inlCokernelCofork X Y))","decl":"/-- The cokernel of `biprod.inl : X âŸ¶ X âŠ Y` is `Y`. -/\n@[simps!]\ndef cokernelBiprodInlIso : cokernel (biprod.inl : X âŸ¶ X âŠ Y) â‰… Y :=\n  colimit.isoColimitCocone âŸ¨_, biprod.isCokernelInlCokernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiprodInlIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq CategoryTheory.Limits.cokernelBiprodInlIso.inv ((CategoryTheory.Limits.biprod.isCokernelInlCokernelFork X Y).desc (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.inl 0)))","decl":"/-- The cokernel of `biprod.inl : X âŸ¶ X âŠ Y` is `Y`. -/\n@[simps!]\ndef cokernelBiprodInlIso : cokernel (biprod.inl : X âŸ¶ X âŠ Y) â‰… Y :=\n  colimit.isoColimitCocone âŸ¨_, biprod.isCokernelInlCokernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.instHasCokernelInr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ CategoryTheory.Limits.HasCokernel CategoryTheory.Limits.biprod.inr","decl":"instance : HasCokernel (biprod.inr : Y âŸ¶ X âŠ Y) :=\n  HasColimit.mk âŸ¨_, biprod.isCokernelInrCokernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiprodInrIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq CategoryTheory.Limits.cokernelBiprodInrIso.hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.inr 0) (CategoryTheory.Limits.biprod.inrCokernelCofork X Y))","decl":"/-- The cokernel of `biprod.inr : Y âŸ¶ X âŠ Y` is `X`. -/\n@[simps!]\ndef cokernelBiprodInrIso : cokernel (biprod.inr : Y âŸ¶ X âŠ Y) â‰… X :=\n  colimit.isoColimitCocone âŸ¨_, biprod.isCokernelInrCokernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiprodInrIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nâŠ¢ Eq CategoryTheory.Limits.cokernelBiprodInrIso.inv ((CategoryTheory.Limits.biprod.isCokernelInrCokernelFork X Y).desc (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.inr 0)))","decl":"/-- The cokernel of `biprod.inr : Y âŸ¶ X âŠ Y` is `X`. -/\n@[simps!]\ndef cokernelBiprodInrIso : cokernel (biprod.inr : Y âŸ¶ X âŠ Y) â‰… X :=\n  colimit.isoColimitCocone âŸ¨_, biprod.isCokernelInrCokernelFork X YâŸ©\n\n"}
{"name":"CategoryTheory.Limits.isoBiprodZero_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nhY : CategoryTheory.Limits.IsZero Y\nâŠ¢ Eq (CategoryTheory.Limits.isoBiprodZero hY).hom CategoryTheory.Limits.biprod.inl","decl":"/-- If `Y` is a zero object, `X â‰… X âŠ Y` for any `X`. -/\n@[simps!]\ndef isoBiprodZero {X Y : C} [HasBinaryBiproduct X Y] (hY : IsZero Y) : X â‰… X âŠ Y where\n  hom := biprod.inl\n  inv := biprod.fst\n  inv_hom_id := by\n    apply CategoryTheory.Limits.biprod.hom_ext <;>\n      simp only [Category.assoc, biprod.inl_fst, Category.comp_id, Category.id_comp, biprod.inl_snd,\n        comp_zero]\n    apply hY.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.isoBiprodZero_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nhY : CategoryTheory.Limits.IsZero Y\nâŠ¢ Eq (CategoryTheory.Limits.isoBiprodZero hY).inv CategoryTheory.Limits.biprod.fst","decl":"/-- If `Y` is a zero object, `X â‰… X âŠ Y` for any `X`. -/\n@[simps!]\ndef isoBiprodZero {X Y : C} [HasBinaryBiproduct X Y] (hY : IsZero Y) : X â‰… X âŠ Y where\n  hom := biprod.inl\n  inv := biprod.fst\n  inv_hom_id := by\n    apply CategoryTheory.Limits.biprod.hom_ext <;>\n      simp only [Category.assoc, biprod.inl_fst, Category.comp_id, Category.id_comp, biprod.inl_snd,\n        comp_zero]\n    apply hY.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.isoZeroBiprod_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nhY : CategoryTheory.Limits.IsZero X\nâŠ¢ Eq (CategoryTheory.Limits.isoZeroBiprod hY).inv CategoryTheory.Limits.biprod.snd","decl":"/-- If `X` is a zero object, `Y â‰… X âŠ Y` for any `Y`. -/\n@[simps]\ndef isoZeroBiprod {X Y : C} [HasBinaryBiproduct X Y] (hY : IsZero X) : Y â‰… X âŠ Y where\n  hom := biprod.inr\n  inv := biprod.snd\n  inv_hom_id := by\n    apply CategoryTheory.Limits.biprod.hom_ext <;>\n      simp only [Category.assoc, biprod.inr_snd, Category.comp_id, Category.id_comp, biprod.inr_fst,\n        comp_zero]\n    apply hY.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.isoZeroBiprod_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nhY : CategoryTheory.Limits.IsZero X\nâŠ¢ Eq (CategoryTheory.Limits.isoZeroBiprod hY).hom CategoryTheory.Limits.biprod.inr","decl":"/-- If `X` is a zero object, `Y â‰… X âŠ Y` for any `Y`. -/\n@[simps]\ndef isoZeroBiprod {X Y : C} [HasBinaryBiproduct X Y] (hY : IsZero X) : Y â‰… X âŠ Y where\n  hom := biprod.inr\n  inv := biprod.snd\n  inv_hom_id := by\n    apply CategoryTheory.Limits.biprod.hom_ext <;>\n      simp only [Category.assoc, biprod.inr_snd, Category.comp_id, Category.id_comp, biprod.inr_fst,\n        comp_zero]\n    apply hY.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.biprod_isZero_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nA B : C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproduct A B\nâŠ¢ Iff (CategoryTheory.Limits.IsZero (CategoryTheory.Limits.biprod A B)) (And (CategoryTheory.Limits.IsZero A) (CategoryTheory.Limits.IsZero B))","decl":"@[simp]\nlemma biprod_isZero_iff (A B : C) [HasBinaryBiproduct A B] :\n    IsZero (biprod A B) â†” IsZero A âˆ§ IsZero B := by\n  constructor\n  Â· intro h\n    simp only [IsZero.iff_id_eq_zero] at h âŠ¢\n    simp only [show ğŸ™ A = biprod.inl â‰« ğŸ™ (A âŠ B) â‰« biprod.fst by simp,\n      show ğŸ™ B = biprod.inr â‰« ğŸ™ (A âŠ B) â‰« biprod.snd by simp, h, zero_comp, comp_zero,\n      and_self]\n  Â· rintro âŸ¨hA, hBâŸ©\n    rw [IsZero.iff_id_eq_zero]\n    apply biprod.hom_ext\n    Â· apply hA.eq_of_tgt\n    Â· apply hB.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\nâŠ¢ Eq (CategoryTheory.Limits.biprod.braiding P Q).inv (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst)","decl":"/-- The braiding isomorphism which swaps a binary biproduct. -/\n@[simps]\ndef biprod.braiding (P Q : C) : P âŠ Q â‰… Q âŠ P where\n  hom := biprod.lift biprod.snd biprod.fst\n  inv := biprod.lift biprod.snd biprod.fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\nâŠ¢ Eq (CategoryTheory.Limits.biprod.braiding P Q).hom (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst)","decl":"/-- The braiding isomorphism which swaps a binary biproduct. -/\n@[simps]\ndef biprod.braiding (P Q : C) : P âŠ Q â‰… Q âŠ P where\n  hom := biprod.lift biprod.snd biprod.fst\n  inv := biprod.lift biprod.snd biprod.fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding'_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\nâŠ¢ Eq (CategoryTheory.Limits.biprod.braiding' P Q).inv (CategoryTheory.Limits.biprod.desc CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.inl)","decl":"/-- An alternative formula for the braiding isomorphism which swaps a binary biproduct,\nusing the fact that the biproduct is a coproduct.\n-/\n@[simps]\ndef biprod.braiding' (P Q : C) : P âŠ Q â‰… Q âŠ P where\n  hom := biprod.desc biprod.inr biprod.inl\n  inv := biprod.desc biprod.inr biprod.inl\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding'_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\nâŠ¢ Eq (CategoryTheory.Limits.biprod.braiding' P Q).hom (CategoryTheory.Limits.biprod.desc CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.inl)","decl":"/-- An alternative formula for the braiding isomorphism which swaps a binary biproduct,\nusing the fact that the biproduct is a coproduct.\n-/\n@[simps]\ndef biprod.braiding' (P Q : C) : P âŠ Q â‰… Q âŠ P where\n  hom := biprod.desc biprod.inr biprod.inl\n  inv := biprod.desc biprod.inr biprod.inl\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding'_eq_braiding","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\nâŠ¢ Eq (CategoryTheory.Limits.biprod.braiding' P Q) (CategoryTheory.Limits.biprod.braiding P Q)","decl":"theorem biprod.braiding'_eq_braiding {P Q : C} : biprod.braiding' P Q = biprod.braiding P Q := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.braid_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Zâœ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Zâœ W\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod W Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding Y W).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding X Zâœ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map g f) h))","decl":"/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.braid_natural {W X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ W) :\n    biprod.map f g â‰« (biprod.braiding _ _).hom = (biprod.braiding _ _).hom â‰« biprod.map g f := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.braid_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.Limits.biprod.braiding Y W).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding X Z).hom (CategoryTheory.Limits.biprod.map g f))","decl":"/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.braid_natural {W X Y Z : C} (f : X âŸ¶ Y) (g : Z âŸ¶ W) :\n    biprod.map f g â‰« (biprod.braiding _ _).hom = (biprod.braiding _ _).hom â‰« biprod.map g f := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding_map_braiding_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Zâœ : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Zâœ\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod Zâœ Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding X W).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding Y Zâœ).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map g f) h)","decl":"@[reassoc]\ntheorem biprod.braiding_map_braiding {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) :\n    (biprod.braiding X W).hom â‰« biprod.map f g â‰« (biprod.braiding Y Z).hom = biprod.map g f := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding_map_braiding","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding X W).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.Limits.biprod.braiding Y Z).hom)) (CategoryTheory.Limits.biprod.map g f)","decl":"@[reassoc]\ntheorem biprod.braiding_map_braiding {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z) :\n    (biprod.braiding X W).hom â‰« biprod.map f g â‰« (biprod.braiding Y Z).hom = biprod.map g f := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.symmetry'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst) (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod P Q))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.symmetry' (P Q : C) :\n    biprod.lift biprod.snd biprod.fst â‰« biprod.lift biprod.snd biprod.fst = ğŸ™ (P âŠ Q) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.symmetry'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q Z : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod P Q) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem biprod.symmetry' (P Q : C) :\n    biprod.lift biprod.snd biprod.fst â‰« biprod.lift biprod.snd biprod.fst = ğŸ™ (P âŠ Q) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding P Q).hom (CategoryTheory.Limits.biprod.braiding Q P).hom) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod P Q))","decl":"/-- The braiding isomorphism is symmetric. -/\n@[reassoc]\ntheorem biprod.symmetry (P Q : C) :\n    (biprod.braiding P Q).hom â‰« (biprod.braiding Q P).hom = ğŸ™ _ := by simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.symmetry_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q Z : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod P Q) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding P Q).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding Q P).hom h)) h","decl":"/-- The braiding isomorphism is symmetric. -/\n@[reassoc]\ntheorem biprod.symmetry (P Q : C) :\n    (biprod.braiding P Q).hom â‰« (biprod.braiding Q P).hom = ğŸ™ _ := by simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q R : C\nâŠ¢ Eq (CategoryTheory.Limits.biprod.associator P Q R).hom (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.fst) (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.snd) CategoryTheory.Limits.biprod.snd))","decl":"/-- The associator isomorphism which associates a binary biproduct. -/\n@[simps]\ndef biprod.associator (P Q R : C) : (P âŠ Q) âŠ R â‰… P âŠ (Q âŠ R) where\n  hom := biprod.lift (biprod.fst â‰« biprod.fst) (biprod.lift (biprod.fst â‰« biprod.snd) biprod.snd)\n  inv := biprod.lift (biprod.lift biprod.fst (biprod.snd â‰« biprod.fst)) (biprod.snd â‰« biprod.snd)\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q R : C\nâŠ¢ Eq (CategoryTheory.Limits.biprod.associator P Q R).inv (CategoryTheory.Limits.biprod.lift (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.fst (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.snd))","decl":"/-- The associator isomorphism which associates a binary biproduct. -/\n@[simps]\ndef biprod.associator (P Q R : C) : (P âŠ Q) âŠ R â‰… P âŠ (Q âŠ R) where\n  hom := biprod.lift (biprod.fst â‰« biprod.fst) (biprod.lift (biprod.fst â‰« biprod.snd) biprod.snd)\n  inv := biprod.lift (biprod.lift biprod.fst (biprod.snd â‰« biprod.fst)) (biprod.snd â‰« biprod.snd)\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nU V W X Y Z : C\nf : Quiver.Hom U X\ng : Quiver.Hom V Y\nh : Quiver.Hom W Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map (CategoryTheory.Limits.biprod.map f g) h) (CategoryTheory.Limits.biprod.associator X Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator U V W).hom (CategoryTheory.Limits.biprod.map f (CategoryTheory.Limits.biprod.map g h)))","decl":"/-- The associator isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.associator_natural {U V W X Y Z : C} (f : U âŸ¶ X) (g : V âŸ¶ Y) (h : W âŸ¶ Z) :\n    biprod.map (biprod.map f g) h â‰« (biprod.associator _ _ _).hom\n      = (biprod.associator _ _ _).hom â‰« biprod.map f (biprod.map g h) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nU V W X Y Zâœ : C\nf : Quiver.Hom U X\ng : Quiver.Hom V Y\nhâœ : Quiver.Hom W Zâœ\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod X (CategoryTheory.Limits.biprod Y Zâœ)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map (CategoryTheory.Limits.biprod.map f g) hâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator X Y Zâœ).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator U V W).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f (CategoryTheory.Limits.biprod.map g hâœ)) h))","decl":"/-- The associator isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.associator_natural {U V W X Y Z : C} (f : U âŸ¶ X) (g : V âŸ¶ Y) (h : W âŸ¶ Z) :\n    biprod.map (biprod.map f g) h â‰« (biprod.associator _ _ _).hom\n      = (biprod.associator _ _ _).hom â‰« biprod.map f (biprod.map g h) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_inv_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nU V W X Y Zâœ : C\nf : Quiver.Hom U X\ng : Quiver.Hom V Y\nhâœ : Quiver.Hom W Zâœ\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod (CategoryTheory.Limits.biprod X Y) Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f (CategoryTheory.Limits.biprod.map g hâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator X Y Zâœ).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator U V W).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map (CategoryTheory.Limits.biprod.map f g) hâœ) h))","decl":"/-- The associator isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.associator_inv_natural {U V W X Y Z : C} (f : U âŸ¶ X) (g : V âŸ¶ Y) (h : W âŸ¶ Z) :\n    biprod.map f (biprod.map g h) â‰« (biprod.associator _ _ _).inv\n      = (biprod.associator _ _ _).inv â‰« biprod.map (biprod.map f g) h := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_inv_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasBinaryBiproducts C\nU V W X Y Z : C\nf : Quiver.Hom U X\ng : Quiver.Hom V Y\nh : Quiver.Hom W Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f (CategoryTheory.Limits.biprod.map g h)) (CategoryTheory.Limits.biprod.associator X Y Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator U V W).inv (CategoryTheory.Limits.biprod.map (CategoryTheory.Limits.biprod.map f g) h))","decl":"/-- The associator isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.associator_inv_natural {U V W X Y Z : C} (f : U âŸ¶ X) (g : V âŸ¶ Y) (h : W âŸ¶ Z) :\n    biprod.map f (biprod.map g h) â‰« (biprod.associator _ _ _).inv\n      = (biprod.associator _ _ _).inv â‰« biprod.map (biprod.map f g) h := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.isIso_left_of_isIso_biprod_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninstâœ : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)\nâŠ¢ CategoryTheory.IsIso f","decl":"/-- If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `f` is invertible.\n-/\ntheorem isIso_left_of_isIso_biprod_map {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z)\n    [IsIso (biprod.map f g)] : IsIso f :=\n  âŸ¨âŸ¨biprod.inl â‰« inv (biprod.map f g) â‰« biprod.fst,\n      âŸ¨by\n        have t := congrArg (fun p : W âŠ X âŸ¶ W âŠ X => biprod.inl â‰« p â‰« biprod.fst)\n          (IsIso.hom_inv_id (biprod.map f g))\n        simp only [Category.id_comp, Category.assoc, biprod.inl_map_assoc] at t\n        simp [t], by\n        have t := congrArg (fun p : Y âŠ Z âŸ¶ Y âŠ Z => biprod.inl â‰« p â‰« biprod.fst)\n          (IsIso.inv_hom_id (biprod.map f g))\n        simp only [Category.id_comp, Category.assoc, biprod.map_fst] at t\n        simp only [Category.assoc]\n        simp [t]âŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.isIso_right_of_isIso_biprod_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninstâœ : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)\nâŠ¢ CategoryTheory.IsIso g","decl":"/-- If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `g` is invertible.\n-/\ntheorem isIso_right_of_isIso_biprod_map {W X Y Z : C} (f : W âŸ¶ Y) (g : X âŸ¶ Z)\n    [IsIso (biprod.map f g)] : IsIso g :=\n  letI : IsIso (biprod.map g f) := by\n    rw [â† biprod.braiding_map_braiding]\n    infer_instance\n  isIso_left_of_isIso_biprod_map g f\n\n"}
