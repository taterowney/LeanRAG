{"name":"CategoryTheory.Limits.Bicone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\npt✝ : C\nπ✝ : (j : J) → Quiver.Hom pt✝ (F j)\nι✝ : (j : J) → Quiver.Hom (F j) pt✝\nι_π✝ : autoParam (∀ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (ι✝ j) (π✝ j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)) _auto✝\npt : C\nπ : (j : J) → Quiver.Hom pt (F j)\nι : (j : J) → Quiver.Hom (F j) pt\nι_π : autoParam (∀ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (ι j) (π j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)) _auto✝\n⊢ Eq (Eq { pt := pt✝, π := π✝, ι := ι✝, ι_π := ι_π✝ } { pt := pt, π := π, ι := ι, ι_π := ι_π }) (And (Eq pt✝ pt) (And (HEq π✝ π) (HEq ι✝ ι)))","decl":"open scoped Classical in\n/-- A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `π j : pt ⟶ F j` and `ι j : F j ⟶ pt` for each `j`,\n* such that `ι j ≫ π j'` is the identity when `j = j'` and zero otherwise.\n-/\nstructure Bicone (F : J → C) where\n  pt : C\n  π : ∀ j, pt ⟶ F j\n  ι : ∀ j, F j ⟶ pt\n  ι_π : ∀ j j', ι j ≫ π j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ι_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nself : CategoryTheory.Limits.Bicone F\nj j' : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.ι j) (self.π j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)","decl":"open scoped Classical in\n/-- A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `π j : pt ⟶ F j` and `ι j : F j ⟶ pt` for each `j`,\n* such that `ι j ≫ π j'` is the identity when `j = j'` and zero otherwise.\n-/\nstructure Bicone (F : J → C) where\n  pt : C\n  π : ∀ j, pt ⟶ F j\n  ι : ∀ j, F j ⟶ pt\n  ι_π : ∀ j j', ι j ≫ π j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n\n"}
{"name":"CategoryTheory.Limits.Bicone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\npt✝ : C\nπ✝ : (j : J) → Quiver.Hom pt✝ (F j)\nι✝ : (j : J) → Quiver.Hom (F j) pt✝\nι_π✝ : autoParam (∀ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (ι✝ j) (π✝ j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)) _auto✝\npt : C\nπ : (j : J) → Quiver.Hom pt (F j)\nι : (j : J) → Quiver.Hom (F j) pt\nι_π : autoParam (∀ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (ι j) (π j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)) _auto✝\nx✝ : Eq { pt := pt✝, π := π✝, ι := ι✝, ι_π := ι_π✝ } { pt := pt, π := π, ι := ι, ι_π := ι_π }\n⊢ And (Eq pt✝ pt) (And (HEq π✝ π) (HEq ι✝ ι))","decl":"open scoped Classical in\n/-- A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `π j : pt ⟶ F j` and `ι j : F j ⟶ pt` for each `j`,\n* such that `ι j ≫ π j'` is the identity when `j = j'` and zero otherwise.\n-/\nstructure Bicone (F : J → C) where\n  pt : C\n  π : ∀ j, pt ⟶ F j\n  ι : ∀ j, F j ⟶ pt\n  ι_π : ∀ j j', ι j ≫ π j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n\n"}
{"name":"CategoryTheory.Limits.Bicone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝³ : CategoryTheory.Category.{uC', uC} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\npt : C\nπ : (j : J) → Quiver.Hom pt (F j)\nι : (j : J) → Quiver.Hom (F j) pt\nι_π : autoParam (∀ (j j' : J), Eq (CategoryTheory.CategoryStruct.comp (ι j) (π j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)) _auto✝\n⊢ Eq (SizeOf.sizeOf { pt := pt, π := π, ι := ι, ι_π := ι_π }) (HAdd.hAdd 1 (SizeOf.sizeOf pt))","decl":"open scoped Classical in\n/-- A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `π j : pt ⟶ F j` and `ι j : F j ⟶ pt` for each `j`,\n* such that `ι j ≫ π j'` is the identity when `j = j'` and zero otherwise.\n-/\nstructure Bicone (F : J → C) where\n  pt : C\n  π : ∀ j, pt ⟶ F j\n  ι : ∀ j, F j ⟶ pt\n  ι_π : ∀ j j', ι j ≫ π j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n\n"}
{"name":"CategoryTheory.Limits.bicone_ι_π_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (B.ι j) (B.π j)) (CategoryTheory.CategoryStruct.id (F j))","decl":"@[reassoc (attr := simp)]\ntheorem bicone_ι_π_self {F : J → C} (B : Bicone F) (j : J) : B.ι j ≫ B.π j = 𝟙 (F j) := by\n  simpa using B.ι_π j j\n\n"}
{"name":"CategoryTheory.Limits.bicone_ι_π_self_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj : J\nZ : C\nh : Quiver.Hom (F j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (B.ι j) (CategoryTheory.CategoryStruct.comp (B.π j) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem bicone_ι_π_self {F : J → C} (B : Bicone F) (j : J) : B.ι j ≫ B.π j = 𝟙 (F j) := by\n  simpa using B.ι_π j j\n\n"}
{"name":"CategoryTheory.Limits.bicone_ι_π_ne_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj j' : J\nh✝ : Ne j j'\nZ : C\nh : Quiver.Hom (F j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (B.ι j) (CategoryTheory.CategoryStruct.comp (B.π j') h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem bicone_ι_π_ne {F : J → C} (B : Bicone F) {j j' : J} (h : j ≠ j') : B.ι j ≫ B.π j' = 0 := by\n  simpa [h] using B.ι_π j j'\n\n"}
{"name":"CategoryTheory.Limits.bicone_ι_π_ne","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj j' : J\nh : Ne j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (B.ι j) (B.π j')) 0","decl":"@[reassoc (attr := simp)]\ntheorem bicone_ι_π_ne {F : J → C} (B : Bicone F) {j j' : J} (h : j ≠ j') : B.ι j ≫ B.π j' = 0 := by\n  simpa [h] using B.ι_π j j'\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.wι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nA B : CategoryTheory.Limits.Bicone F\nself : CategoryTheory.Limits.BiconeMorphism A B\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (A.ι j) self.hom) (B.ι j)","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J → C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wπ : ∀ j : J, hom ≫ B.π j = A.π j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wι : ∀ j : J, A.ι j ≫ hom = B.ι j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.wπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nA B : CategoryTheory.Limits.Bicone F\nself : CategoryTheory.Limits.BiconeMorphism A B\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.hom (B.π j)) (A.π j)","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J → C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wπ : ∀ j : J, hom ≫ B.π j = A.π j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wι : ∀ j : J, A.ι j ≫ hom = B.ι j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nA B : CategoryTheory.Limits.Bicone F\nhom✝ : Quiver.Hom A.pt B.pt\nwπ✝ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom✝ (B.π j)) (A.π j)) _auto✝\nwι✝ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι j) hom✝) (B.ι j)) _auto✝\nhom : Quiver.Hom A.pt B.pt\nwπ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.π j)) (A.π j)) _auto✝\nwι : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι j) hom) (B.ι j)) _auto✝\nx✝ : Eq { hom := hom✝, wπ := wπ✝, wι := wι✝ } { hom := hom, wπ := wπ, wι := wι }\n⊢ Eq hom✝ hom","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J → C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wπ : ∀ j : J, hom ≫ B.π j = A.π j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wι : ∀ j : J, A.ι j ≫ hom = B.ι j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nA B : CategoryTheory.Limits.Bicone F\nhom✝ : Quiver.Hom A.pt B.pt\nwπ✝ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom✝ (B.π j)) (A.π j)) _auto✝\nwι✝ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι j) hom✝) (B.ι j)) _auto✝\nhom : Quiver.Hom A.pt B.pt\nwπ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.π j)) (A.π j)) _auto✝\nwι : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι j) hom) (B.ι j)) _auto✝\n⊢ Eq (Eq { hom := hom✝, wπ := wπ✝, wι := wι✝ } { hom := hom, wπ := wπ, wι := wι }) (Eq hom✝ hom)","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J → C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wπ : ∀ j : J, hom ≫ B.π j = A.π j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wι : ∀ j : J, A.ι j ≫ hom = B.ι j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝³ : CategoryTheory.Category.{uC', uC} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nA B : CategoryTheory.Limits.Bicone F\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\nhom : Quiver.Hom A.pt B.pt\nwπ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp hom (B.π j)) (A.π j)) _auto✝\nwι : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (A.ι j) hom) (B.ι j)) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, wπ := wπ, wι := wι }) (HAdd.hAdd 1 (SizeOf.sizeOf hom))","decl":"/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J → C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wπ : ∀ j : J, hom ≫ B.π j = A.π j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wι : ∀ j : J, A.ι j ≫ hom = B.ι j := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.wι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nA B : CategoryTheory.Limits.Bicone F\nself : CategoryTheory.Limits.BiconeMorphism A B\nj : J\nZ : C\nh : Quiver.Hom B.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (A.ι j) (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (B.ι j) h)","decl":"attribute [reassoc (attr := simp)] BiconeMorphism.wι\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.wπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nA B : CategoryTheory.Limits.Bicone F\nself : CategoryTheory.Limits.BiconeMorphism A B\nj : J\nZ : C\nh : Quiver.Hom (F j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp (B.π j) h)) (CategoryTheory.CategoryStruct.comp (A.π j) h)","decl":"attribute [reassoc (attr := simp)] BiconeMorphism.wπ\n\n"}
{"name":"CategoryTheory.Limits.Bicone.category_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nX✝ Y✝ Z✝ : CategoryTheory.Limits.Bicone F\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- The category of bicones on a given diagram. -/\n@[simps]\ninstance Bicone.category : Category (Bicone F) where\n  Hom A B := BiconeMorphism A B\n  comp f g := { hom := f.hom ≫ g.hom }\n  id B := { hom := 𝟙 B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the `hom` field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.Bicone.category_id_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\n⊢ Eq (CategoryTheory.CategoryStruct.id B).hom (CategoryTheory.CategoryStruct.id B.pt)","decl":"/-- The category of bicones on a given diagram. -/\n@[simps]\ninstance Bicone.category : Category (Bicone F) where\n  Hom A B := BiconeMorphism A B\n  comp f g := { hom := f.hom ≫ g.hom }\n  id B := { hom := 𝟙 B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the `hom` field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nc c' : CategoryTheory.Limits.Bicone F\nf g : Quiver.Hom c c'\nw : Eq f.hom g.hom\n⊢ Eq f g","decl":"@[ext]\ntheorem BiconeMorphism.ext {c c' : Bicone F} (f g : c ⟶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.BiconeMorphism.ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nc c' : CategoryTheory.Limits.Bicone F\nf g : Quiver.Hom c c'\n⊢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\ntheorem BiconeMorphism.ext {c c' : Bicone F} (f g : c ⟶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.Bicones.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nc c' : CategoryTheory.Limits.Bicone F\nφ : CategoryTheory.Iso c.pt c'.pt\nwι : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (c.ι j) φ.hom) (c'.ι j)) _auto✝\nwπ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp φ.hom (c'.π j)) (c.π j)) _auto✝\n⊢ Eq (CategoryTheory.Limits.Bicones.ext φ wι wπ).hom.hom φ.hom","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Bicone F} (φ : c.pt ≅ c'.pt)\n    (wι : ∀ j, c.ι j ≫ φ.hom = c'.ι j := by aesop_cat)\n    (wπ : ∀ j, φ.hom ≫ c'.π j = c.π j := by aesop_cat) : c ≅ c' where\n  hom := { hom := φ.hom }\n  inv :=\n    { hom := φ.inv\n      wι := fun j => φ.comp_inv_eq.mpr (wι j).symm\n      wπ := fun j => φ.inv_comp_eq.mpr (wπ j).symm  }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nc c' : CategoryTheory.Limits.Bicone F\nφ : CategoryTheory.Iso c.pt c'.pt\nwι : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (c.ι j) φ.hom) (c'.ι j)) _auto✝\nwπ : autoParam (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp φ.hom (c'.π j)) (c.π j)) _auto✝\n⊢ Eq (CategoryTheory.Limits.Bicones.ext φ wι wπ).inv.hom φ.inv","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Bicone F} (φ : c.pt ≅ c'.pt)\n    (wι : ∀ j, c.ι j ≫ φ.hom = c'.ι j := by aesop_cat)\n    (wπ : ∀ j, φ.hom ≫ c'.π j = c.π j := by aesop_cat) : c ≅ c' where\n  hom := { hom := φ.hom }\n  inv :=\n    { hom := φ.inv\n      wι := fun j => φ.comp_inv_eq.mpr (wι j).symm\n      wπ := fun j => φ.inv_comp_eq.mpr (wπ j).symm  }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝⁴ : CategoryTheory.Category.{uC', uC} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝² : CategoryTheory.Category.{uD', uD} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J → C\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\nA : CategoryTheory.Limits.Bicone F\n⊢ Eq ((CategoryTheory.Limits.Bicones.functoriality F G).obj A).pt (G.obj A.pt)","decl":"variable (F) in\n/-- A functor `G : C ⥤ D` sends bicones over `F` to bicones over `G.obj ∘ F` functorially. -/\n@[simps]\ndef functoriality (G : C ⥤ D) [Functor.PreservesZeroMorphisms G] :\n    Bicone F ⥤ Bicone (G.obj ∘ F) where\n  obj A :=\n    { pt := G.obj A.pt\n      π := fun j => G.map (A.π j)\n      ι := fun j => G.map (A.ι j)\n      ι_π := fun i j => (Functor.map_comp _ _ _).symm.trans <| by\n        rw [A.ι_π]\n        aesop_cat }\n  map f :=\n    { hom := G.map f.hom\n      wπ := fun j => by simp [-BiconeMorphism.wπ, ← f.wπ j]\n      wι := fun j => by simp [-BiconeMorphism.wι, ← f.wι j] }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_obj_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝⁴ : CategoryTheory.Category.{uC', uC} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝² : CategoryTheory.Category.{uD', uD} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J → C\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\nA : CategoryTheory.Limits.Bicone F\nj : J\n⊢ Eq (((CategoryTheory.Limits.Bicones.functoriality F G).obj A).π j) (G.map (A.π j))","decl":"variable (F) in\n/-- A functor `G : C ⥤ D` sends bicones over `F` to bicones over `G.obj ∘ F` functorially. -/\n@[simps]\ndef functoriality (G : C ⥤ D) [Functor.PreservesZeroMorphisms G] :\n    Bicone F ⥤ Bicone (G.obj ∘ F) where\n  obj A :=\n    { pt := G.obj A.pt\n      π := fun j => G.map (A.π j)\n      ι := fun j => G.map (A.ι j)\n      ι_π := fun i j => (Functor.map_comp _ _ _).symm.trans <| by\n        rw [A.ι_π]\n        aesop_cat }\n  map f :=\n    { hom := G.map f.hom\n      wπ := fun j => by simp [-BiconeMorphism.wπ, ← f.wπ j]\n      wι := fun j => by simp [-BiconeMorphism.wι, ← f.wι j] }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝⁴ : CategoryTheory.Category.{uC', uC} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝² : CategoryTheory.Category.{uD', uD} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J → C\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\nX✝ Y✝ : CategoryTheory.Limits.Bicone F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.Bicones.functoriality F G).map f).hom (G.map f.hom)","decl":"variable (F) in\n/-- A functor `G : C ⥤ D` sends bicones over `F` to bicones over `G.obj ∘ F` functorially. -/\n@[simps]\ndef functoriality (G : C ⥤ D) [Functor.PreservesZeroMorphisms G] :\n    Bicone F ⥤ Bicone (G.obj ∘ F) where\n  obj A :=\n    { pt := G.obj A.pt\n      π := fun j => G.map (A.π j)\n      ι := fun j => G.map (A.ι j)\n      ι_π := fun i j => (Functor.map_comp _ _ _).symm.trans <| by\n        rw [A.ι_π]\n        aesop_cat }\n  map f :=\n    { hom := G.map f.hom\n      wπ := fun j => by simp [-BiconeMorphism.wπ, ← f.wπ j]\n      wι := fun j => by simp [-BiconeMorphism.wι, ← f.wι j] }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_obj_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝⁴ : CategoryTheory.Category.{uC', uC} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝² : CategoryTheory.Category.{uD', uD} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J → C\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\nA : CategoryTheory.Limits.Bicone F\nj : J\n⊢ Eq (((CategoryTheory.Limits.Bicones.functoriality F G).obj A).ι j) (G.map (A.ι j))","decl":"variable (F) in\n/-- A functor `G : C ⥤ D` sends bicones over `F` to bicones over `G.obj ∘ F` functorially. -/\n@[simps]\ndef functoriality (G : C ⥤ D) [Functor.PreservesZeroMorphisms G] :\n    Bicone F ⥤ Bicone (G.obj ∘ F) where\n  obj A :=\n    { pt := G.obj A.pt\n      π := fun j => G.map (A.π j)\n      ι := fun j => G.map (A.ι j)\n      ι_π := fun i j => (Functor.map_comp _ _ _).symm.trans <| by\n        rw [A.ι_π]\n        aesop_cat }\n  map f :=\n    { hom := G.map f.hom\n      wπ := fun j => by simp [-BiconeMorphism.wπ, ← f.wπ j]\n      wι := fun j => by simp [-BiconeMorphism.wι, ← f.wι j] }\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_full","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝⁶ : CategoryTheory.Category.{uC', uC} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝⁴ : CategoryTheory.Category.{uD', uD} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : J → C\nG : CategoryTheory.Functor C D\ninst✝² : G.PreservesZeroMorphisms\ninst✝¹ : G.Full\ninst✝ : G.Faithful\n⊢ (CategoryTheory.Limits.Bicones.functoriality F G).Full","decl":"instance functoriality_full [G.PreservesZeroMorphisms] [G.Full] [G.Faithful] :\n    (functoriality F G).Full where\n  map_surjective t :=\n   ⟨{ hom := G.preimage t.hom\n      wι := fun j => G.map_injective (by simpa using t.wι j)\n      wπ := fun j => G.map_injective (by simpa using t.wπ j) }, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Limits.Bicones.functoriality_faithful","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝⁵ : CategoryTheory.Category.{uC', uC} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝³ : CategoryTheory.Category.{uD', uD} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : J → C\nG : CategoryTheory.Functor C D\ninst✝¹ : G.PreservesZeroMorphisms\ninst✝ : G.Faithful\n⊢ (CategoryTheory.Limits.Bicones.functoriality F G).Faithful","decl":"instance functoriality_faithful [G.PreservesZeroMorphisms] [G.Faithful] :\n    (functoriality F G).Faithful where\n  map_injective {_X} {_Y} f g h :=\n    BiconeMorphism.ext f g <| G.map_injective <| congr_arg BiconeMorphism.hom h\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\n⊢ Eq B.toCone.pt B.pt","decl":"@[simp]\ntheorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCone_π_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj : CategoryTheory.Discrete J\n⊢ Eq (B.toCone.π.app j) (B.π j.as)","decl":"@[simp]\ntheorem toCone_π_app (B : Bicone F) (j : Discrete J) : B.toCone.π.app j = B.π j.as := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCone_π_app_mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj : J\n⊢ Eq (B.toCone.π.app { as := j }) (B.π j)","decl":"theorem toCone_π_app_mk (B : Bicone F) (j : J) : B.toCone.π.app ⟨j⟩ = B.π j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCone_proj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj : J\n⊢ Eq (CategoryTheory.Limits.Fan.proj B.toCone j) (B.π j)","decl":"@[simp]\ntheorem toCone_proj (B : Bicone F) (j : J) : Fan.proj B.toCone j = B.π j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\n⊢ Eq B.toCocone.pt B.pt","decl":"@[simp]\ntheorem toCocone_pt (B : Bicone F) : B.toCocone.pt = B.pt := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj : CategoryTheory.Discrete J\n⊢ Eq (B.toCocone.ι.app j) (B.ι j.as)","decl":"@[simp]\ntheorem toCocone_ι_app (B : Bicone F) (j : Discrete J) : B.toCocone.ι.app j = B.ι j.as := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCocone_inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj : J\n⊢ Eq (CategoryTheory.Limits.Cofan.inj B.toCocone j) (B.ι j)","decl":"@[simp]\ntheorem toCocone_inj (B : Bicone F) (j : J) : Cofan.inj B.toCocone j = B.ι j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toCocone_ι_app_mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nj : J\n⊢ Eq (B.toCocone.ι.app { as := j }) (B.ι j)","decl":"theorem toCocone_ι_app_mk (B : Bicone F) (j : J) : B.toCocone.ι.app ⟨j⟩ = B.ι j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofLimitCone_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsLimit t\nj : J\n⊢ Eq ((CategoryTheory.Limits.Bicone.ofLimitCone ht).π j) (t.π.app { as := j })","decl":"open scoped Classical in\n/-- We can turn any limit cone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofLimitCone {f : J → C} {t : Cone (Discrete.functor f)} (ht : IsLimit t) : Bicone f where\n  pt := t.pt\n  π j := t.π.app ⟨j⟩\n  ι j := ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0)\n  ι_π j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofLimitCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsLimit t\n⊢ Eq (CategoryTheory.Limits.Bicone.ofLimitCone ht).pt t.pt","decl":"open scoped Classical in\n/-- We can turn any limit cone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofLimitCone {f : J → C} {t : Cone (Discrete.functor f)} (ht : IsLimit t) : Bicone f where\n  pt := t.pt\n  π j := t.π.app ⟨j⟩\n  ι j := ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0)\n  ι_π j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofLimitCone_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\nt : CategoryTheory.Limits.Cone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsLimit t\nj : J\n⊢ Eq ((CategoryTheory.Limits.Bicone.ofLimitCone ht).ι j) (ht.lift (CategoryTheory.Limits.Fan.mk (f j) fun j' => dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0))","decl":"open scoped Classical in\n/-- We can turn any limit cone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofLimitCone {f : J → C} {t : Cone (Discrete.functor f)} (ht : IsLimit t) : Bicone f where\n  pt := t.pt\n  π j := t.π.app ⟨j⟩\n  ι j := ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0)\n  ι_π j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ι_of_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\nt : CategoryTheory.Limits.Bicone f\nht : CategoryTheory.Limits.IsLimit t.toCone\nj : J\n⊢ Eq (t.ι j) (ht.lift (CategoryTheory.Limits.Fan.mk (f j) fun j' => dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0))","decl":"open scoped Classical in\ntheorem ι_of_isLimit {f : J → C} {t : Bicone f} (ht : IsLimit t.toCone) (j : J) :\n    t.ι j = ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0) :=\n  ht.hom_ext fun j' => by\n    rw [ht.fac]\n    simp [t.ι_π]\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofColimitCocone_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsColimit t\nj : J\n⊢ Eq ((CategoryTheory.Limits.Bicone.ofColimitCocone ht).π j) (ht.desc (CategoryTheory.Limits.Cofan.mk (f j) fun j' => dite (Eq j' j) (fun h => CategoryTheory.eqToHom ⋯) fun h => 0))","decl":"open scoped Classical in\n/-- We can turn any colimit cocone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofColimitCocone {f : J → C} {t : Cocone (Discrete.functor f)} (ht : IsColimit t) :\n    Bicone f where\n  pt := t.pt\n  π j := ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0)\n  ι j := t.ι.app ⟨j⟩\n  ι_π j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofColimitCocone_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsColimit t\nj : J\n⊢ Eq ((CategoryTheory.Limits.Bicone.ofColimitCocone ht).ι j) (t.ι.app { as := j })","decl":"open scoped Classical in\n/-- We can turn any colimit cocone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofColimitCocone {f : J → C} {t : Cocone (Discrete.functor f)} (ht : IsColimit t) :\n    Bicone f where\n  pt := t.pt\n  π j := ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0)\n  ι j := t.ι.app ⟨j⟩\n  ι_π j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.ofColimitCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\nt : CategoryTheory.Limits.Cocone (CategoryTheory.Discrete.functor f)\nht : CategoryTheory.Limits.IsColimit t\n⊢ Eq (CategoryTheory.Limits.Bicone.ofColimitCocone ht).pt t.pt","decl":"open scoped Classical in\n/-- We can turn any colimit cocone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofColimitCocone {f : J → C} {t : Cocone (Discrete.functor f)} (ht : IsColimit t) :\n    Bicone f where\n  pt := t.pt\n  π j := ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0)\n  ι j := t.ι.app ⟨j⟩\n  ι_π j j' := by simp\n\n"}
{"name":"CategoryTheory.Limits.Bicone.π_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\nt : CategoryTheory.Limits.Bicone f\nht : CategoryTheory.Limits.IsColimit t.toCocone\nj : J\n⊢ Eq (t.π j) (ht.desc (CategoryTheory.Limits.Cofan.mk (f j) fun j' => dite (Eq j' j) (fun h => CategoryTheory.eqToHom ⋯) fun h => 0))","decl":"open scoped Classical in\ntheorem π_of_isColimit {f : J → C} {t : Bicone f} (ht : IsColimit t.toCocone) (j : J) :\n    t.π j = ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0) :=\n  ht.hom_ext fun j' => by\n    rw [ht.fac]\n    simp [t.ι_π]\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝³ : CategoryTheory.Category.{uC', uC} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\nisLimit : CategoryTheory.Limits.IsLimit B.toCone\nisColimit : CategoryTheory.Limits.IsColimit B.toCocone\n⊢ Eq (SizeOf.sizeOf { isLimit := isLimit, isColimit := isColimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf isLimit)) (SizeOf.sizeOf isColimit))","decl":"/-- Structure witnessing that a bicone is both a limit cone and a colimit cocone. -/\nstructure IsBilimit {F : J → C} (B : Bicone F) where\n  isLimit : IsLimit B.toCone\n  isColimit : IsColimit B.toCocone\n\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nisLimit✝ : CategoryTheory.Limits.IsLimit B.toCone\nisColimit✝ : CategoryTheory.Limits.IsColimit B.toCocone\nisLimit : CategoryTheory.Limits.IsLimit B.toCone\nisColimit : CategoryTheory.Limits.IsColimit B.toCocone\nx✝ : Eq { isLimit := isLimit✝, isColimit := isColimit✝ } { isLimit := isLimit, isColimit := isColimit }\n⊢ And (Eq isLimit✝ isLimit) (Eq isColimit✝ isColimit)","decl":"/-- Structure witnessing that a bicone is both a limit cone and a colimit cocone. -/\nstructure IsBilimit {F : J → C} (B : Bicone F) where\n  isLimit : IsLimit B.toCone\n  isColimit : IsColimit B.toCocone\n\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nisLimit✝ : CategoryTheory.Limits.IsLimit B.toCone\nisColimit✝ : CategoryTheory.Limits.IsColimit B.toCocone\nisLimit : CategoryTheory.Limits.IsLimit B.toCone\nisColimit : CategoryTheory.Limits.IsColimit B.toCocone\n⊢ Eq (Eq { isLimit := isLimit✝, isColimit := isColimit✝ } { isLimit := isLimit, isColimit := isColimit }) (And (Eq isLimit✝ isLimit) (Eq isColimit✝ isColimit))","decl":"/-- Structure witnessing that a bicone is both a limit cone and a colimit cocone. -/\nstructure IsBilimit {F : J → C} (B : Bicone F) where\n  isLimit : IsLimit B.toCone\n  isColimit : IsColimit B.toCocone\n\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nx y : B.IsBilimit\n⊢ Iff (Eq x y) (And (Eq x.isLimit y.isLimit) (Eq x.isColimit y.isColimit))","decl":"attribute [local ext] Bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.Bicone.IsBilimit.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nB : CategoryTheory.Limits.Bicone F\nx y : B.IsBilimit\nisLimit : Eq x.isLimit y.isLimit\nisColimit : Eq x.isColimit y.isColimit\n⊢ Eq x y","decl":"attribute [local ext] Bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.Bicone.subsingleton_isBilimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\nc : CategoryTheory.Limits.Bicone f\n⊢ Subsingleton c.IsBilimit","decl":"instance subsingleton_isBilimit {f : J → C} {c : Bicone f} : Subsingleton c.IsBilimit :=\n  ⟨fun _ _ => Bicone.IsBilimit.ext (Subsingleton.elim _ _) (Subsingleton.elim _ _)⟩\n\n"}
{"name":"CategoryTheory.Limits.Bicone.whisker_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type w'\nf : J → C\nc : CategoryTheory.Limits.Bicone f\ng : Equiv K J\nk : K\n⊢ Eq ((c.whisker g).ι k) (c.ι (g k))","decl":"/-- Whisker a bicone with an equivalence between the indexing types. -/\n@[simps]\ndef whisker {f : J → C} (c : Bicone f) (g : K ≃ J) : Bicone (f ∘ g) where\n  pt := c.pt\n  π k := c.π (g k)\n  ι k := c.ι (g k)\n  ι_π k k' := by\n    simp only [c.ι_π]\n    split_ifs with h h' h' <;> simp [Equiv.apply_eq_iff_eq g] at h h' <;> tauto\n\n"}
{"name":"CategoryTheory.Limits.Bicone.whisker_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type w'\nf : J → C\nc : CategoryTheory.Limits.Bicone f\ng : Equiv K J\n⊢ Eq (c.whisker g).pt c.pt","decl":"/-- Whisker a bicone with an equivalence between the indexing types. -/\n@[simps]\ndef whisker {f : J → C} (c : Bicone f) (g : K ≃ J) : Bicone (f ∘ g) where\n  pt := c.pt\n  π k := c.π (g k)\n  ι k := c.ι (g k)\n  ι_π k k' := by\n    simp only [c.ι_π]\n    split_ifs with h h' h' <;> simp [Equiv.apply_eq_iff_eq g] at h h' <;> tauto\n\n"}
{"name":"CategoryTheory.Limits.Bicone.whisker_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type w'\nf : J → C\nc : CategoryTheory.Limits.Bicone f\ng : Equiv K J\nk : K\n⊢ Eq ((c.whisker g).π k) (c.π (g k))","decl":"/-- Whisker a bicone with an equivalence between the indexing types. -/\n@[simps]\ndef whisker {f : J → C} (c : Bicone f) (g : K ≃ J) : Bicone (f ∘ g) where\n  pt := c.pt\n  π k := c.π (g k)\n  ι k := c.ι (g k)\n  ι_π k k' := by\n    simp only [c.ι_π]\n    split_ifs with h h' h' <;> simp [Equiv.apply_eq_iff_eq g] at h h' <;> tauto\n\n"}
{"name":"CategoryTheory.Limits.LimitBicone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nbicone✝ : CategoryTheory.Limits.Bicone F\nisBilimit✝ : bicone✝.IsBilimit\nbicone : CategoryTheory.Limits.Bicone F\nisBilimit : bicone.IsBilimit\n⊢ Eq (Eq { bicone := bicone✝, isBilimit := isBilimit✝ } { bicone := bicone, isBilimit := isBilimit }) (And (Eq bicone✝ bicone) (HEq isBilimit✝ isBilimit))","decl":"/-- A bicone over `F : J → C`, which is both a limit cone and a colimit cocone.\n-/\nstructure LimitBicone (F : J → C) where\n  bicone : Bicone F\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.LimitBicone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝³ : CategoryTheory.Category.{uC', uC} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\nbicone : CategoryTheory.Limits.Bicone F\nisBilimit : bicone.IsBilimit\n⊢ Eq (SizeOf.sizeOf { bicone := bicone, isBilimit := isBilimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf bicone)) (SizeOf.sizeOf isBilimit))","decl":"/-- A bicone over `F : J → C`, which is both a limit cone and a colimit cocone.\n-/\nstructure LimitBicone (F : J → C) where\n  bicone : Bicone F\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.LimitBicone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nbicone✝ : CategoryTheory.Limits.Bicone F\nisBilimit✝ : bicone✝.IsBilimit\nbicone : CategoryTheory.Limits.Bicone F\nisBilimit : bicone.IsBilimit\nx✝ : Eq { bicone := bicone✝, isBilimit := isBilimit✝ } { bicone := bicone, isBilimit := isBilimit }\n⊢ And (Eq bicone✝ bicone) (HEq isBilimit✝ isBilimit)","decl":"/-- A bicone over `F : J → C`, which is both a limit cone and a colimit cocone.\n-/\nstructure LimitBicone (F : J → C) where\n  bicone : Bicone F\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.HasBiproduct.exists_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nself : CategoryTheory.Limits.HasBiproduct F\n⊢ Nonempty (CategoryTheory.Limits.LimitBicone F)","decl":"/-- `HasBiproduct F` expresses the mere existence of a bicone which is\nsimultaneously a limit and a colimit of the diagram `F`.\n-/\nclass HasBiproduct (F : J → C) : Prop where mk' ::\n  exists_biproduct : Nonempty (LimitBicone F)\n\n"}
{"name":"CategoryTheory.Limits.HasBiproduct.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\nd : CategoryTheory.Limits.LimitBicone F\n⊢ CategoryTheory.Limits.HasBiproduct F","decl":"theorem HasBiproduct.mk {F : J → C} (d : LimitBicone F) : HasBiproduct F :=\n  ⟨Nonempty.intro d⟩\n\n"}
{"name":"CategoryTheory.Limits.hasProduct_of_hasBiproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝² : CategoryTheory.Category.{uC', uC} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct F\n⊢ CategoryTheory.Limits.HasProduct F","decl":"instance (priority := 100) hasProduct_of_hasBiproduct [HasBiproduct F] : HasProduct F :=\n  HasLimit.mk\n    { cone := (biproduct.bicone F).toCone\n      isLimit := biproduct.isLimit F }\n\n"}
{"name":"CategoryTheory.Limits.hasCoproduct_of_hasBiproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝² : CategoryTheory.Category.{uC', uC} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nF : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct F\n⊢ CategoryTheory.Limits.HasCoproduct F","decl":"instance (priority := 100) hasCoproduct_of_hasBiproduct [HasBiproduct F] : HasCoproduct F :=\n  HasColimit.mk\n    { cocone := (biproduct.bicone F).toCocone\n      isColimit := biproduct.isColimit F }\n\n"}
{"name":"CategoryTheory.Limits.HasBiproductsOfShape.has_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasBiproductsOfShape J C\nF : J → C\n⊢ CategoryTheory.Limits.HasBiproduct F","decl":"/-- `C` has biproducts of shape `J` if we have\na limit and a colimit, with the same cone points,\nof every function `F : J → C`.\n-/\nclass HasBiproductsOfShape : Prop where\n  has_biproduct : ∀ F : J → C, HasBiproduct F\n\n"}
{"name":"CategoryTheory.Limits.HasFiniteBiproducts.out","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasFiniteBiproducts C\nn : Nat\n⊢ CategoryTheory.Limits.HasBiproductsOfShape (Fin n) C","decl":"/-- `HasFiniteBiproducts C` represents a choice of biproduct for every family of objects in `C`\nindexed by a finite type. -/\nclass HasFiniteBiproducts : Prop where\n  out : ∀ n, HasBiproductsOfShape (Fin n) C\n\n"}
{"name":"CategoryTheory.Limits.hasBiproductsOfShape_of_equiv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝² : CategoryTheory.Category.{uC', uC} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type w'\ninst✝ : CategoryTheory.Limits.HasBiproductsOfShape K C\ne : Equiv J K\n⊢ CategoryTheory.Limits.HasBiproductsOfShape J C","decl":"theorem hasBiproductsOfShape_of_equiv {K : Type w'} [HasBiproductsOfShape K C] (e : J ≃ K) :\n    HasBiproductsOfShape J C :=\n  ⟨fun F =>\n    let ⟨⟨h⟩⟩ := HasBiproductsOfShape.has_biproduct (F ∘ e.symm)\n    let ⟨c, hc⟩ := h\n    HasBiproduct.mk <| by\n      simpa only [Function.comp_def, e.symm_apply_apply] using\n        LimitBicone.mk (c.whisker e) ((c.whiskerIsBilimitIff _).2 hc)⟩\n\n"}
{"name":"CategoryTheory.Limits.hasBiproductsOfShape_finite","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝³ : CategoryTheory.Category.{uC', uC} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝ : Finite J\n⊢ CategoryTheory.Limits.HasBiproductsOfShape J C","decl":"instance (priority := 100) hasBiproductsOfShape_finite [HasFiniteBiproducts C] [Finite J] :\n    HasBiproductsOfShape J C := by\n  rcases Finite.exists_equiv_fin J with ⟨n, ⟨e⟩⟩\n  haveI : HasBiproductsOfShape (Fin n) C := HasFiniteBiproducts.out n\n  exact hasBiproductsOfShape_of_equiv C e\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteProducts_of_hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type uC\ninst✝² : CategoryTheory.Category.{uC', uC} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\n⊢ CategoryTheory.Limits.HasFiniteProducts C","decl":"instance (priority := 100) hasFiniteProducts_of_hasFiniteBiproducts [HasFiniteBiproducts C] :\n    HasFiniteProducts C where\n  out _ := ⟨fun _ => hasLimitOfIso Discrete.natIsoFunctor.symm⟩\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteCoproducts_of_hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type uC\ninst✝² : CategoryTheory.Category.{uC', uC} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\n⊢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"instance (priority := 100) hasFiniteCoproducts_of_hasFiniteBiproducts [HasFiniteBiproducts C] :\n    HasFiniteCoproducts C where\n  out _ := ⟨fun _ => hasColimitOfIso Discrete.natIsoFunctor⟩\n\n"}
{"name":"CategoryTheory.Limits.hasProductsOfShape_of_hasBiproductsOfShape","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝² : CategoryTheory.Category.{uC', uC} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBiproductsOfShape J C\n⊢ CategoryTheory.Limits.HasProductsOfShape J C","decl":"instance (priority := 100) hasProductsOfShape_of_hasBiproductsOfShape [HasBiproductsOfShape J C] :\n    HasProductsOfShape J C where\n  has_limit _ := hasLimitOfIso Discrete.natIsoFunctor.symm\n\n"}
{"name":"CategoryTheory.Limits.hasCoproductsOfShape_of_hasBiproductsOfShape","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type uC\ninst✝² : CategoryTheory.Category.{uC', uC} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBiproductsOfShape J C\n⊢ CategoryTheory.Limits.HasCoproductsOfShape J C","decl":"instance (priority := 100) hasCoproductsOfShape_of_hasBiproductsOfShape [HasBiproductsOfShape J C] :\n    HasCoproductsOfShape J C where\n  has_colimit _ := hasColimitOfIso Discrete.natIsoFunctor\n\n"}
{"name":"CategoryTheory.Limits.biproduct.bicone_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nb : J\n⊢ Eq ((CategoryTheory.Limits.biproduct.bicone f).π b) (CategoryTheory.Limits.biproduct.π f b)","decl":"@[simp]\ntheorem biproduct.bicone_π (f : J → C) [HasBiproduct f] (b : J) :\n    (biproduct.bicone f).π b = biproduct.π f b := rfl\n\n"}
{"name":"CategoryTheory.Limits.biproduct.bicone_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nb : J\n⊢ Eq ((CategoryTheory.Limits.biproduct.bicone f).ι b) (CategoryTheory.Limits.biproduct.ι f b)","decl":"@[simp]\ntheorem biproduct.bicone_ι (f : J → C) [HasBiproduct f] (b : J) :\n    (biproduct.bicone f).ι b = biproduct.ι f b := rfl\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : DecidableEq J\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nZ : C\nh : Quiver.Hom (f j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j') h)) (CategoryTheory.CategoryStruct.comp (dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0) h)","decl":"/-- Note that as this lemma has an `if` in the statement, we include a `DecidableEq` argument.\nThis means you may not be able to `simp` using this lemma unless you `open scoped Classical`. -/\n@[reassoc]\ntheorem biproduct.ι_π [DecidableEq J] (f : J → C) [HasBiproduct f] (j j' : J) :\n    biproduct.ι f j ≫ biproduct.π f j' = if h : j = j' then eqToHom (congr_arg f h) else 0 := by\n  convert (biproduct.bicone f).ι_π j j'\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : DecidableEq J\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.Limits.biproduct.π f j')) (dite (Eq j j') (fun h => CategoryTheory.eqToHom ⋯) fun h => 0)","decl":"/-- Note that as this lemma has an `if` in the statement, we include a `DecidableEq` argument.\nThis means you may not be able to `simp` using this lemma unless you `open scoped Classical`. -/\n@[reassoc]\ntheorem biproduct.ι_π [DecidableEq J] (f : J → C) [HasBiproduct f] (j j' : J) :\n    biproduct.ι f j ≫ biproduct.π f j' = if h : j = j' then eqToHom (congr_arg f h) else 0 := by\n  convert (biproduct.bicone f).ι_π j j'\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_π_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.Limits.biproduct.π f j)) (CategoryTheory.CategoryStruct.id (f j))","decl":"@[reassoc] -- Porting note: both versions proven by simp\ntheorem biproduct.ι_π_self (f : J → C) [HasBiproduct f] (j : J) :\n    biproduct.ι f j ≫ biproduct.π f j = 𝟙 _ := by simp [biproduct.ι_π]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_π_self_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj : J\nZ : C\nh : Quiver.Hom (f j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) h)) h","decl":"@[reassoc] -- Porting note: both versions proven by simp\ntheorem biproduct.ι_π_self (f : J → C) [HasBiproduct f] (j : J) :\n    biproduct.ι f j ≫ biproduct.π f j = 𝟙 _ := by simp [biproduct.ι_π]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_π_ne_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nh✝ : Ne j j'\nZ : C\nh : Quiver.Hom (f j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j') h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_π_ne (f : J → C) [HasBiproduct f] {j j' : J} (h : j ≠ j') :\n    biproduct.ι f j ≫ biproduct.π f j' = 0 := by simp [biproduct.ι_π, h]\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_π_ne","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nh : Ne j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.Limits.biproduct.π f j')) 0","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_π_ne (f : J → C) [HasBiproduct f] {j j' : J} (h : j ≠ j') :\n    biproduct.ι f j ≫ biproduct.π f j' = 0 := by simp [biproduct.ι_π, h]\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.biproduct.eqToHom_comp_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nw : Eq j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.Limits.biproduct.ι f j')) (CategoryTheory.Limits.biproduct.ι f j)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.eqToHom_comp_ι (f : J → C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) ≫ biproduct.ι f j' = biproduct.ι f j := by\n  cases w\n  simp\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.biproduct.eqToHom_comp_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nw : Eq j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) h)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.eqToHom_comp_ι (f : J → C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) ≫ biproduct.ι f j' = biproduct.ι f j := by\n  cases w\n  simp\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.biproduct.π_comp_eqToHom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nw : Eq j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) (CategoryTheory.eqToHom ⋯)) (CategoryTheory.Limits.biproduct.π f j')","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.π_comp_eqToHom (f : J → C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    biproduct.π f j ≫ eqToHom (by simp [w]) = biproduct.π f j' := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.π_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nj j' : J\nw : Eq j j'\nZ : C\nh : Quiver.Hom (f j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j') h)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.π_comp_eqToHom (f : J → C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    biproduct.π f j ≫ eqToHom (by simp [w]) = biproduct.π f j' := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nP : C\np : (b : J) → Quiver.Hom P (f b)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift p) (CategoryTheory.Limits.biproduct.π f j)) (p j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.lift_π {f : J → C} [HasBiproduct f] {P : C} (p : ∀ b, P ⟶ f b) (j : J) :\n    biproduct.lift p ≫ biproduct.π f j = p j := (biproduct.isLimit f).fac _ ⟨j⟩\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nP : C\np : (b : J) → Quiver.Hom P (f b)\nj : J\nZ : C\nh : Quiver.Hom (f j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) h)) (CategoryTheory.CategoryStruct.comp (p j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.lift_π {f : J → C} [HasBiproduct f] {P : C} (p : ∀ b, P ⟶ f b) (j : J) :\n    biproduct.lift p ≫ biproduct.π f j = p j := (biproduct.isLimit f).fac _ ⟨j⟩\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nP : C\np : (b : J) → Quiver.Hom (f b) P\nj : J\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc p) h)) (CategoryTheory.CategoryStruct.comp (p j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_desc {f : J → C} [HasBiproduct f] {P : C} (p : ∀ b, f b ⟶ P) (j : J) :\n    biproduct.ι f j ≫ biproduct.desc p = p j := (biproduct.isColimit f).fac _ ⟨j⟩\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nP : C\np : (b : J) → Quiver.Hom (f b) P\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.Limits.biproduct.desc p)) (p j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_desc {f : J → C} [HasBiproduct f] {P : C} (p : ∀ b, f b ⟶ P) (j : J) :\n    biproduct.ι f j ≫ biproduct.desc p = p j := (biproduct.isColimit f).fac _ ⟨j⟩\n\n"}
{"name":"CategoryTheory.Limits.biproduct.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nZ : C\ng h : Quiver.Hom Z (CategoryTheory.Limits.biproduct f)\nw : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.π f j)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.Limits.biproduct.π f j))\n⊢ Eq g h","decl":"@[ext 1001]\ntheorem biproduct.hom_ext {f : J → C} [HasBiproduct f] {Z : C} (g h : Z ⟶ ⨁ f)\n    (w : ∀ j, g ≫ biproduct.π f j = h ≫ biproduct.π f j) : g = h :=\n  (biproduct.isLimit f).hom_ext fun j => w j.as\n\n"}
{"name":"CategoryTheory.Limits.biproduct.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nZ : C\ng h : Quiver.Hom Z (CategoryTheory.Limits.biproduct f)\n⊢ Iff (Eq g h) (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.π f j)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.Limits.biproduct.π f j)))","decl":"@[ext 1001]\ntheorem biproduct.hom_ext {f : J → C} [HasBiproduct f] {Z : C} (g h : Z ⟶ ⨁ f)\n    (w : ∀ j, g ≫ biproduct.π f j = h ≫ biproduct.π f j) : g = h :=\n  (biproduct.isLimit f).hom_ext fun j => w j.as\n\n"}
{"name":"CategoryTheory.Limits.biproduct.hom_ext'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nZ : C\ng h : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\nw : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) h)\n⊢ Eq g h","decl":"@[ext]\ntheorem biproduct.hom_ext' {f : J → C} [HasBiproduct f] {Z : C} (g h : ⨁ f ⟶ Z)\n    (w : ∀ j, biproduct.ι f j ≫ g = biproduct.ι f j ≫ h) : g = h :=\n  (biproduct.isColimit f).hom_ext fun j => w j.as\n\n"}
{"name":"CategoryTheory.Limits.biproduct.hom_ext'_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nZ : C\ng h : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\n⊢ Iff (Eq g h) (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) h))","decl":"@[ext]\ntheorem biproduct.hom_ext' {f : J → C} [HasBiproduct f] {Z : C} (g h : ⨁ f ⟶ Z)\n    (w : ∀ j, biproduct.ι f j ≫ g = biproduct.ι f j ≫ h) : g = h :=\n  (biproduct.isColimit f).hom_ext fun j => w j.as\n\n"}
{"name":"CategoryTheory.Limits.biproduct.isoProduct_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\n⊢ Eq (CategoryTheory.Limits.biproduct.isoProduct f).hom (CategoryTheory.Limits.Pi.lift (CategoryTheory.Limits.biproduct.π f))","decl":"@[simp]\ntheorem biproduct.isoProduct_hom {f : J → C} [HasBiproduct f] :\n    (biproduct.isoProduct f).hom = Pi.lift (biproduct.π f) :=\n  limit.hom_ext fun j => by simp [biproduct.isoProduct]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.isoProduct_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\n⊢ Eq (CategoryTheory.Limits.biproduct.isoProduct f).inv (CategoryTheory.Limits.biproduct.lift (CategoryTheory.Limits.Pi.π f))","decl":"@[simp]\ntheorem biproduct.isoProduct_inv {f : J → C} [HasBiproduct f] :\n    (biproduct.isoProduct f).inv = biproduct.lift (Pi.π f) :=\n  biproduct.hom_ext _ _ fun j => by simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.isoCoproduct_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\n⊢ Eq (CategoryTheory.Limits.biproduct.isoCoproduct f).inv (CategoryTheory.Limits.Sigma.desc (CategoryTheory.Limits.biproduct.ι f))","decl":"@[simp]\ntheorem biproduct.isoCoproduct_inv {f : J → C} [HasBiproduct f] :\n    (biproduct.isoCoproduct f).inv = Sigma.desc (biproduct.ι f) :=\n  colimit.hom_ext fun j => by simp [biproduct.isoCoproduct]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.isoCoproduct_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\n⊢ Eq (CategoryTheory.Limits.biproduct.isoCoproduct f).hom (CategoryTheory.Limits.biproduct.desc (CategoryTheory.Limits.Sigma.ι f))","decl":"@[simp]\ntheorem biproduct.isoCoproduct_hom {f : J → C} [HasBiproduct f] :\n    (biproduct.isoCoproduct f).hom = biproduct.desc (Sigma.ι f) :=\n  biproduct.hom_ext' _ _ fun j => by simp [← Iso.eq_comp_inv]\n\n"}
{"name":"CategoryTheory.Limits.HasBiproductsOfShape.colimIsoLim_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBiproductsOfShape J C\nX : CategoryTheory.Functor (CategoryTheory.Discrete J) C\n⊢ Eq (CategoryTheory.Limits.HasBiproductsOfShape.colimIsoLim.inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift (CategoryTheory.Limits.Pi.π fun j => X.obj { as := j })) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc (CategoryTheory.Limits.Sigma.ι fun j => X.obj { as := j })) (CategoryTheory.Limits.Sigma.isoColimit X).hom)))","decl":"/-- If a category has biproducts of a shape `J`, its `colim` and `lim` functor on diagrams over `J`\nare isomorphic. -/\n@[simps!]\ndef HasBiproductsOfShape.colimIsoLim [HasBiproductsOfShape J C] :\n    colim (J := Discrete J) (C := C) ≅ lim :=\n  NatIso.ofComponents (fun F => (Sigma.isoColimit F).symm ≪≫\n      (biproduct.isoCoproduct _).symm ≪≫ biproduct.isoProduct _ ≪≫ Pi.isoLimit F)\n    fun η => colimit.hom_ext fun ⟨i⟩ => limit.hom_ext fun ⟨j⟩ => by\n      classical\n      by_cases h : i = j <;>\n       simp_all [h, Sigma.isoColimit, Pi.isoLimit, biproduct.ι_π, biproduct.ι_π_assoc]\n\n"}
{"name":"CategoryTheory.Limits.HasBiproductsOfShape.colimIsoLim_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBiproductsOfShape J C\nX : CategoryTheory.Functor (CategoryTheory.Discrete J) C\n⊢ Eq (CategoryTheory.Limits.HasBiproductsOfShape.colimIsoLim.hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.isoColimit X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.desc (CategoryTheory.Limits.biproduct.ι fun j => X.obj { as := j })) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift (CategoryTheory.Limits.biproduct.π fun j => X.obj { as := j })) (CategoryTheory.Limits.Pi.isoLimit X).hom)))","decl":"/-- If a category has biproducts of a shape `J`, its `colim` and `lim` functor on diagrams over `J`\nare isomorphic. -/\n@[simps!]\ndef HasBiproductsOfShape.colimIsoLim [HasBiproductsOfShape J C] :\n    colim (J := Discrete J) (C := C) ≅ lim :=\n  NatIso.ofComponents (fun F => (Sigma.isoColimit F).symm ≪≫\n      (biproduct.isoCoproduct _).symm ≪≫ biproduct.isoProduct _ ≪≫ Pi.isoLimit F)\n    fun η => colimit.hom_ext fun ⟨i⟩ => limit.hom_ext fun ⟨j⟩ => by\n      classical\n      by_cases h : i = j <;>\n       simp_all [h, Sigma.isoColimit, Pi.isoLimit, biproduct.ι_π, biproduct.ι_π_assoc]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_eq_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\np : (b : J) → Quiver.Hom (f b) (g b)\n⊢ Eq (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.Limits.biproduct.map' p)","decl":"theorem biproduct.map_eq_map' {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ b, f b ⟶ g b) :\n    biproduct.map p = biproduct.map' p := by\n  classical\n  ext\n  dsimp\n  simp only [Discrete.natTrans_app, Limits.IsColimit.ι_map_assoc, Limits.IsLimit.map_π,\n    Category.assoc, ← Bicone.toCone_π_app_mk, ← biproduct.bicone_π, ← Bicone.toCocone_ι_app_mk,\n    ← biproduct.bicone_ι]\n  dsimp\n  rw [biproduct.ι_π_assoc, biproduct.ι_π]\n  split_ifs with h\n  · subst h; simp\n  · simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\nj : J\nZ : C\nh : Quiver.Hom (g j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π g j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) (CategoryTheory.CategoryStruct.comp (p j) h))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.map_π {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    (j : J) : biproduct.map p ≫ biproduct.π g j = biproduct.π f j ≫ p j :=\n  Limits.IsLimit.map_π _ _ _ (Discrete.mk j)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.Limits.biproduct.π g j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) (p j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.map_π {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    (j : J) : biproduct.map p ≫ biproduct.π g j = biproduct.π f j ≫ p j :=\n  Limits.IsLimit.map_π _ _ _ (Discrete.mk j)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.Limits.biproduct.map p)) (CategoryTheory.CategoryStruct.comp (p j) (CategoryTheory.Limits.biproduct.ι g j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_map {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    (j : J) : biproduct.ι f j ≫ biproduct.map p = p j ≫ biproduct.ι g j := by\n  rw [biproduct.map_eq_map']\n  apply\n    Limits.IsColimit.ι_map (biproduct.isColimit f) (biproduct.bicone g).toCocone\n    (Discrete.natTrans fun j => p j.as) (Discrete.mk j)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) h)) (CategoryTheory.CategoryStruct.comp (p j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι g j) h))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_map {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    (j : J) : biproduct.ι f j ≫ biproduct.map p = p j ≫ biproduct.ι g j := by\n  rw [biproduct.map_eq_map']\n  apply\n    Limits.IsColimit.ι_map (biproduct.isColimit f) (biproduct.bicone g).toCocone\n    (Discrete.natTrans fun j => p j.as) (Discrete.mk j)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\nP : C\nk : (j : J) → Quiver.Hom (g j) P\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc fun j => CategoryTheory.CategoryStruct.comp (p j) (k j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.map_desc {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    {P : C} (k : ∀ j, g j ⟶ P) :\n    biproduct.map p ≫ biproduct.desc k = biproduct.desc fun j => p j ≫ k j := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\nP : C\nk : (j : J) → Quiver.Hom (g j) P\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) (CategoryTheory.Limits.biproduct.desc k)) (CategoryTheory.Limits.biproduct.desc fun j => CategoryTheory.CategoryStruct.comp (p j) (k j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.map_desc {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    {P : C} (k : ∀ j, g j ⟶ P) :\n    biproduct.map p ≫ biproduct.desc k = biproduct.desc fun j => p j ≫ k j := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\nP : C\nk : (j : J) → Quiver.Hom P (f j)\np : (j : J) → Quiver.Hom (f j) (g j)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift k) (CategoryTheory.Limits.biproduct.map p)) (CategoryTheory.Limits.biproduct.lift fun j => CategoryTheory.CategoryStruct.comp (k j) (p j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.lift_map {f g : J → C} [HasBiproduct f] [HasBiproduct g] {P : C}\n    (k : ∀ j, P ⟶ f j) (p : ∀ j, f j ⟶ g j) :\n    biproduct.lift k ≫ biproduct.map p = biproduct.lift fun j => k j ≫ p j := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.lift_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\nP : C\nk : (j : J) → Quiver.Hom P (f j)\np : (j : J) → Quiver.Hom (f j) (g j)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map p) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift fun j => CategoryTheory.CategoryStruct.comp (k j) (p j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.lift_map {f g : J → C} [HasBiproduct f] [HasBiproduct g] {P : C}\n    (k : ∀ j, P ⟶ f j) (p : ∀ j, f j ⟶ g j) :\n    biproduct.lift k ≫ biproduct.map p = biproduct.lift fun j => k j ≫ p j := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.biproduct.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\np : (b : J) → CategoryTheory.Iso (f b) (g b)\n⊢ Eq (CategoryTheory.Limits.biproduct.mapIso p).hom (CategoryTheory.Limits.biproduct.map fun b => (p b).hom)","decl":"/-- Given a collection of isomorphisms between corresponding summands of a pair of biproducts\nindexed by the same type, we obtain an isomorphism between the biproducts. -/\n@[simps]\ndef biproduct.mapIso {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ b, f b ≅ g b) :\n    ⨁ f ≅ ⨁ g where\n  hom := biproduct.map fun b => (p b).hom\n  inv := biproduct.map fun b => (p b).inv\n\n"}
{"name":"CategoryTheory.Limits.biproduct.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\np : (b : J) → CategoryTheory.Iso (f b) (g b)\n⊢ Eq (CategoryTheory.Limits.biproduct.mapIso p).inv (CategoryTheory.Limits.biproduct.map fun b => (p b).inv)","decl":"/-- Given a collection of isomorphisms between corresponding summands of a pair of biproducts\nindexed by the same type, we obtain an isomorphism between the biproducts. -/\n@[simps]\ndef biproduct.mapIso {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ b, f b ≅ g b) :\n    ⨁ f ≅ ⨁ g where\n  hom := biproduct.map fun b => (p b).hom\n  inv := biproduct.map fun b => (p b).inv\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\ninst✝ : ∀ (j : J), CategoryTheory.Epi (p j)\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.biproduct.map p)","decl":"instance biproduct.map_epi {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    [∀ j, Epi (p j)] : Epi (biproduct.map p) := by\n  classical\n  have : biproduct.map p =\n      (biproduct.isoCoproduct _).hom ≫ Sigma.map p ≫ (biproduct.isoCoproduct _).inv := by\n    ext\n    simp only [map_π, isoCoproduct_hom, isoCoproduct_inv, Category.assoc, ι_desc_assoc,\n      ι_colimMap_assoc, Discrete.functor_obj_eq_as, Discrete.natTrans_app, colimit.ι_desc_assoc,\n      Cofan.mk_pt, Cofan.mk_ι_app, ι_π, ι_π_assoc]\n    split\n    all_goals simp_all\n  rw [this]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\ninst✝ : ∀ (j : J), CategoryTheory.Epi (p j)\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.Pi.map p)","decl":"instance Pi.map_epi {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    [∀ j, Epi (p j)] : Epi (Pi.map p) := by\n  rw [show Pi.map p = (biproduct.isoProduct _).inv ≫ biproduct.map p ≫\n    (biproduct.isoProduct _).hom by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\ninst✝ : ∀ (j : J), CategoryTheory.Mono (p j)\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.biproduct.map p)","decl":"instance biproduct.map_mono {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    [∀ j, Mono (p j)] : Mono (biproduct.map p) := by\n  rw [show biproduct.map p = (biproduct.isoProduct _).hom ≫ Pi.map p ≫\n    (biproduct.isoProduct _).inv by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf g : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : CategoryTheory.Limits.HasBiproduct g\np : (j : J) → Quiver.Hom (f j) (g j)\ninst✝ : ∀ (j : J), CategoryTheory.Mono (p j)\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.Sigma.map p)","decl":"instance Sigma.map_mono {f g : J → C} [HasBiproduct f] [HasBiproduct g] (p : ∀ j, f j ⟶ g j)\n    [∀ j, Mono (p j)] : Mono (Sigma.map p) := by\n  rw [show Sigma.map p = (biproduct.isoCoproduct _).inv ≫ biproduct.map p ≫\n    (biproduct.isoCoproduct _).hom by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.biproduct.whiskerEquiv_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nK : Type u_1\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ng : K → C\ne : Equiv J K\nw : (j : J) → CategoryTheory.Iso (g (e j)) (f j)\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\n⊢ Eq (CategoryTheory.Limits.biproduct.whiskerEquiv e w).inv (CategoryTheory.Limits.biproduct.desc fun k => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (w (e.symm k)).hom (CategoryTheory.Limits.biproduct.ι f (e.symm k))))","decl":"/-- Two biproducts which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n\nUnfortunately there are two natural ways to define each direction of this isomorphism\n(because it is true for both products and coproducts separately).\nWe give the alternative definitions as lemmas below.\n-/\n@[simps]\ndef biproduct.whiskerEquiv {f : J → C} {g : K → C} (e : J ≃ K) (w : ∀ j, g (e j) ≅ f j)\n    [HasBiproduct f] [HasBiproduct g] : ⨁ f ≅ ⨁ g where\n  hom := biproduct.desc fun j => (w j).inv ≫ biproduct.ι g (e j)\n  inv := biproduct.desc fun k => eqToHom (by simp) ≫ (w (e.symm k)).hom ≫ biproduct.ι f _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.whiskerEquiv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nK : Type u_1\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ng : K → C\ne : Equiv J K\nw : (j : J) → CategoryTheory.Iso (g (e j)) (f j)\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\n⊢ Eq (CategoryTheory.Limits.biproduct.whiskerEquiv e w).hom (CategoryTheory.Limits.biproduct.desc fun j => CategoryTheory.CategoryStruct.comp (w j).inv (CategoryTheory.Limits.biproduct.ι g (e j)))","decl":"/-- Two biproducts which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n\nUnfortunately there are two natural ways to define each direction of this isomorphism\n(because it is true for both products and coproducts separately).\nWe give the alternative definitions as lemmas below.\n-/\n@[simps]\ndef biproduct.whiskerEquiv {f : J → C} {g : K → C} (e : J ≃ K) (w : ∀ j, g (e j) ≅ f j)\n    [HasBiproduct f] [HasBiproduct g] : ⨁ f ≅ ⨁ g where\n  hom := biproduct.desc fun j => (w j).inv ≫ biproduct.ι g (e j)\n  inv := biproduct.desc fun k => eqToHom (by simp) ≫ (w (e.symm k)).hom ≫ biproduct.ι f _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.whiskerEquiv_hom_eq_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nK : Type u_1\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ng : K → C\ne : Equiv J K\nw : (j : J) → CategoryTheory.Iso (g (e j)) (f j)\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\n⊢ Eq (CategoryTheory.Limits.biproduct.whiskerEquiv e w).hom (CategoryTheory.Limits.biproduct.lift fun k => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f (e.symm k)) (CategoryTheory.CategoryStruct.comp (w (e.symm k)).inv (CategoryTheory.eqToHom ⋯)))","decl":"lemma biproduct.whiskerEquiv_hom_eq_lift {f : J → C} {g : K → C} (e : J ≃ K)\n    (w : ∀ j, g (e j) ≅ f j) [HasBiproduct f] [HasBiproduct g] :\n    (biproduct.whiskerEquiv e w).hom =\n      biproduct.lift fun k => biproduct.π f (e.symm k) ≫ (w _).inv ≫ eqToHom (by simp) := by\n  simp only [whiskerEquiv_hom]\n  ext k j\n  by_cases h : k = e j\n  · subst h\n    simp\n  · simp only [ι_desc_assoc, Category.assoc, ne_eq, lift_π]\n    rw [biproduct.ι_π_ne, biproduct.ι_π_ne_assoc]\n    · simp\n    · rintro rfl\n      simp at h\n    · exact Ne.symm h\n\n"}
{"name":"CategoryTheory.Limits.biproduct.whiskerEquiv_inv_eq_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nK : Type u_1\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ng : K → C\ne : Equiv J K\nw : (j : J) → CategoryTheory.Iso (g (e j)) (f j)\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct g\n⊢ Eq (CategoryTheory.Limits.biproduct.whiskerEquiv e w).inv (CategoryTheory.Limits.biproduct.lift fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π g (e j)) (w j).hom)","decl":"lemma biproduct.whiskerEquiv_inv_eq_lift {f : J → C} {g : K → C} (e : J ≃ K)\n    (w : ∀ j, g (e j) ≅ f j) [HasBiproduct f] [HasBiproduct g] :\n    (biproduct.whiskerEquiv e w).inv =\n      biproduct.lift fun j => biproduct.π g (e j) ≫ (w j).hom := by\n  simp only [whiskerEquiv_inv]\n  ext j k\n  by_cases h : k = e j\n  · subst h\n    simp only [ι_desc_assoc, ← eqToHom_iso_hom_naturality_assoc w (e.symm_apply_apply j).symm,\n      Equiv.symm_apply_apply, eqToHom_comp_ι, Category.assoc, bicone_ι_π_self, Category.comp_id,\n      lift_π, bicone_ι_π_self_assoc]\n  · simp only [ι_desc_assoc, Category.assoc, ne_eq, lift_π]\n    rw [biproduct.ι_π_ne, biproduct.ι_π_ne_assoc]\n    · simp\n    · exact h\n    · rintro rfl\n      simp at h\n\n"}
{"name":"CategoryTheory.Limits.instHasBiproductSigmaFstSndOfBiproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nι : Type u_3\nf : ι → Type u_2\ng : (i : ι) → f i → C\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBiproduct (g i)\ninst✝ : CategoryTheory.Limits.HasBiproduct fun i => CategoryTheory.Limits.biproduct (g i)\n⊢ CategoryTheory.Limits.HasBiproduct fun p => g p.fst p.snd","decl":"attribute [local simp] Sigma.forall in\ninstance {ι} (f : ι → Type*) (g : (i : ι) → (f i) → C)\n    [∀ i, HasBiproduct (g i)] [HasBiproduct fun i => ⨁ g i] :\n    HasBiproduct fun p : Σ i, f i => g p.1 p.2 where\n  exists_biproduct := Nonempty.intro\n    { bicone :=\n      { pt := ⨁ fun i => ⨁ g i\n        ι := fun X => biproduct.ι (g X.1) X.2 ≫ biproduct.ι (fun i => ⨁ g i) X.1\n        π := fun X => biproduct.π (fun i => ⨁ g i) X.1 ≫ biproduct.π (g X.1) X.2\n        ι_π := fun ⟨j, x⟩ ⟨j', y⟩ => by\n          split_ifs with h\n          · obtain ⟨rfl, rfl⟩ := h\n            simp\n          · simp only [Sigma.mk.inj_iff, not_and] at h\n            by_cases w : j = j'\n            · cases w\n              simp only [heq_eq_eq, forall_true_left] at h\n              simp [biproduct.ι_π_ne _ h]\n            · simp [biproduct.ι_π_ne_assoc _ w] }\n      isBilimit :=\n      { isLimit := mkFanLimit _\n          (fun s => biproduct.lift fun b => biproduct.lift fun c => s.proj ⟨b, c⟩)\n        isColimit := mkCofanColimit _\n          (fun s => biproduct.desc fun b => biproduct.desc fun c => s.inj ⟨b, c⟩) } }\n\n"}
{"name":"CategoryTheory.Limits.biproductBiproductIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nι : Type u_3\nf : ι → Type u_2\ng : (i : ι) → f i → C\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBiproduct (g i)\ninst✝ : CategoryTheory.Limits.HasBiproduct fun i => CategoryTheory.Limits.biproduct (g i)\n⊢ Eq (CategoryTheory.Limits.biproductBiproductIso f g).hom (CategoryTheory.Limits.biproduct.lift fun x => CategoryTheory.Limits.biproductBiproductIso.match_1 f (fun x => Quiver.Hom (CategoryTheory.Limits.biproduct fun i => CategoryTheory.Limits.biproduct (g i)) (g x.fst x.snd)) x fun i x => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π (fun i => CategoryTheory.Limits.biproduct (g i)) i) (CategoryTheory.Limits.biproduct.π (g i) x))","decl":"/-- An iterated biproduct is a biproduct over a sigma type. -/\n@[simps]\ndef biproductBiproductIso {ι} (f : ι → Type*) (g : (i : ι) → (f i) → C)\n    [∀ i, HasBiproduct (g i)] [HasBiproduct fun i => ⨁ g i] :\n    (⨁ fun i => ⨁ g i) ≅ (⨁ fun p : Σ i, f i => g p.1 p.2) where\n  hom := biproduct.lift fun ⟨i, x⟩ => biproduct.π _ i ≫ biproduct.π _ x\n  inv := biproduct.lift fun i => biproduct.lift fun x => biproduct.π _ (⟨i, x⟩ : Σ i, f i)\n\n"}
{"name":"CategoryTheory.Limits.biproductBiproductIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nι : Type u_3\nf : ι → Type u_2\ng : (i : ι) → f i → C\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasBiproduct (g i)\ninst✝ : CategoryTheory.Limits.HasBiproduct fun i => CategoryTheory.Limits.biproduct (g i)\n⊢ Eq (CategoryTheory.Limits.biproductBiproductIso f g).inv (CategoryTheory.Limits.biproduct.lift fun i => CategoryTheory.Limits.biproduct.lift fun x => CategoryTheory.Limits.biproduct.π (fun p => g p.fst p.snd) ⟨i, x⟩)","decl":"/-- An iterated biproduct is a biproduct over a sigma type. -/\n@[simps]\ndef biproductBiproductIso {ι} (f : ι → Type*) (g : (i : ι) → (f i) → C)\n    [∀ i, HasBiproduct (g i)] [HasBiproduct fun i => ⨁ g i] :\n    (⨁ fun i => ⨁ g i) ≅ (⨁ fun p : Σ i, f i => g p.1 p.2) where\n  hom := biproduct.lift fun ⟨i, x⟩ => biproduct.π _ i ≫ biproduct.π _ x\n  inv := biproduct.lift fun i => biproduct.lift fun x => biproduct.π _ (⟨i, x⟩ : Σ i, f i)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninst✝ : DecidablePred p\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.Limits.biproduct.π f j)) (dite (p j) (fun h => CategoryTheory.Limits.biproduct.π (Subtype.restrict p f) ⟨j, h⟩) fun h => 0)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.fromSubtype_π [DecidablePred p] (j : J) :\n    biproduct.fromSubtype f p ≫ biproduct.π f j =\n      if h : p j then biproduct.π (Subtype.restrict p f) ⟨j, h⟩ else 0 := by\n  classical\n  ext i; dsimp\n  rw [biproduct.fromSubtype, biproduct.ι_desc_assoc, biproduct.ι_π]\n  by_cases h : p j\n  · rw [dif_pos h, biproduct.ι_π]\n    split_ifs with h₁ h₂ h₂\n    exacts [rfl, False.elim (h₂ (Subtype.ext h₁)), False.elim (h₁ (congr_arg Subtype.val h₂)), rfl]\n  · rw [dif_neg h, dif_neg (show (i : J) ≠ j from fun h₂ => h (h₂ ▸ i.2)), comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninst✝ : DecidablePred p\nj : J\nZ : C\nh : Quiver.Hom (f j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f j) h)) (CategoryTheory.CategoryStruct.comp (dite (p j) (fun h => CategoryTheory.Limits.biproduct.π (Subtype.restrict p f) ⟨j, h⟩) fun h => 0) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.fromSubtype_π [DecidablePred p] (j : J) :\n    biproduct.fromSubtype f p ≫ biproduct.π f j =\n      if h : p j then biproduct.π (Subtype.restrict p f) ⟨j, h⟩ else 0 := by\n  classical\n  ext i; dsimp\n  rw [biproduct.fromSubtype, biproduct.ι_desc_assoc, biproduct.ι_π]\n  by_cases h : p j\n  · rw [dif_pos h, biproduct.ι_π]\n    split_ifs with h₁ h₂ h₂\n    exacts [rfl, False.elim (h₂ (Subtype.ext h₁)), False.elim (h₁ (congr_arg Subtype.val h₂)), rfl]\n  · rw [dif_neg h, dif_neg (show (i : J) ≠ j from fun h₂ => h (h₂ ▸ i.2)), comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_eq_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninst✝ : DecidablePred p\n⊢ Eq (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.Limits.biproduct.lift fun j => dite (p j) (fun h => CategoryTheory.Limits.biproduct.π (Subtype.restrict p f) ⟨j, h⟩) fun h => 0)","decl":"theorem biproduct.fromSubtype_eq_lift [DecidablePred p] :\n    biproduct.fromSubtype f p =\n      biproduct.lift fun j => if h : p j then biproduct.π (Subtype.restrict p f) ⟨j, h⟩ else 0 :=\n  biproduct.hom_ext _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_π_subtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.Limits.biproduct.π f ↑j)) (CategoryTheory.Limits.biproduct.π (Subtype.restrict p f) j)","decl":"@[reassoc] -- Porting note: both version solved using simp\ntheorem biproduct.fromSubtype_π_subtype (j : Subtype p) :\n    biproduct.fromSubtype f p ≫ biproduct.π f j = biproduct.π (Subtype.restrict p f) j := by\n  classical\n  ext\n  rw [biproduct.fromSubtype, biproduct.ι_desc_assoc, biproduct.ι_π, biproduct.ι_π]\n  split_ifs with h₁ h₂ h₂\n  exacts [rfl, False.elim (h₂ (Subtype.ext h₁)), False.elim (h₁ (congr_arg Subtype.val h₂)), rfl]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_π_subtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nZ : C\nh : Quiver.Hom (f ↑j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f ↑j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π (Subtype.restrict p f) j) h)","decl":"@[reassoc] -- Porting note: both version solved using simp\ntheorem biproduct.fromSubtype_π_subtype (j : Subtype p) :\n    biproduct.fromSubtype f p ≫ biproduct.π f j = biproduct.π (Subtype.restrict p f) j := by\n  classical\n  ext\n  rw [biproduct.fromSubtype, biproduct.ι_desc_assoc, biproduct.ι_π, biproduct.ι_π]\n  split_ifs with h₁ h₂ h₂\n  exacts [rfl, False.elim (h₂ (Subtype.ext h₁)), False.elim (h₁ (congr_arg Subtype.val h₂)), rfl]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nZ : C\nh : Quiver.Hom (Subtype.restrict p f j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π (Subtype.restrict p f) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π f ↑j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.toSubtype_π (j : Subtype p) :\n    biproduct.toSubtype f p ≫ biproduct.π (Subtype.restrict p f) j = biproduct.π f j :=\n  biproduct.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.Limits.biproduct.π (Subtype.restrict p f) j)) (CategoryTheory.Limits.biproduct.π f ↑j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.toSubtype_π (j : Subtype p) :\n    biproduct.toSubtype f p ≫ biproduct.π (Subtype.restrict p f) j = biproduct.π f j :=\n  biproduct.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_toSubtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninst✝ : DecidablePred p\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct (Subtype.restrict p f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) h)) (CategoryTheory.CategoryStruct.comp (dite (p j) (fun h => CategoryTheory.Limits.biproduct.ι (Subtype.restrict p f) ⟨j, h⟩) fun h => 0) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_toSubtype [DecidablePred p] (j : J) :\n    biproduct.ι f j ≫ biproduct.toSubtype f p =\n      if h : p j then biproduct.ι (Subtype.restrict p f) ⟨j, h⟩ else 0 := by\n  classical\n  ext i\n  rw [biproduct.toSubtype, Category.assoc, biproduct.lift_π, biproduct.ι_π]\n  by_cases h : p j\n  · rw [dif_pos h, biproduct.ι_π]\n    split_ifs with h₁ h₂ h₂\n    exacts [rfl, False.elim (h₂ (Subtype.ext h₁)), False.elim (h₁ (congr_arg Subtype.val h₂)), rfl]\n  · rw [dif_neg h, dif_neg (show j ≠ i from fun h₂ => h (h₂.symm ▸ i.2)), zero_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_toSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninst✝ : DecidablePred p\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.Limits.biproduct.toSubtype f p)) (dite (p j) (fun h => CategoryTheory.Limits.biproduct.ι (Subtype.restrict p f) ⟨j, h⟩) fun h => 0)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_toSubtype [DecidablePred p] (j : J) :\n    biproduct.ι f j ≫ biproduct.toSubtype f p =\n      if h : p j then biproduct.ι (Subtype.restrict p f) ⟨j, h⟩ else 0 := by\n  classical\n  ext i\n  rw [biproduct.toSubtype, Category.assoc, biproduct.lift_π, biproduct.ι_π]\n  by_cases h : p j\n  · rw [dif_pos h, biproduct.ι_π]\n    split_ifs with h₁ h₂ h₂\n    exacts [rfl, False.elim (h₂ (Subtype.ext h₁)), False.elim (h₁ (congr_arg Subtype.val h₂)), rfl]\n  · rw [dif_neg h, dif_neg (show j ≠ i from fun h₂ => h (h₂.symm ▸ i.2)), zero_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_eq_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninst✝ : DecidablePred p\n⊢ Eq (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.Limits.biproduct.desc fun j => dite (p j) (fun h => CategoryTheory.Limits.biproduct.ι (Subtype.restrict p f) ⟨j, h⟩) fun h => 0)","decl":"theorem biproduct.toSubtype_eq_desc [DecidablePred p] :\n    biproduct.toSubtype f p =\n      biproduct.desc fun j => if h : p j then biproduct.ι (Subtype.restrict p f) ⟨j, h⟩ else 0 :=\n  biproduct.hom_ext' _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_toSubtype_subtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f ↑j) (CategoryTheory.Limits.biproduct.toSubtype f p)) (CategoryTheory.Limits.biproduct.ι (Subtype.restrict p f) j)","decl":"@[reassoc]\ntheorem biproduct.ι_toSubtype_subtype (j : Subtype p) :\n    biproduct.ι f j ≫ biproduct.toSubtype f p = biproduct.ι (Subtype.restrict p f) j := by\n  classical\n  ext\n  rw [biproduct.toSubtype, Category.assoc, biproduct.lift_π, biproduct.ι_π, biproduct.ι_π]\n  split_ifs with h₁ h₂ h₂\n  exacts [rfl, False.elim (h₂ (Subtype.ext h₁)), False.elim (h₁ (congr_arg Subtype.val h₂)), rfl]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_toSubtype_subtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct (Subtype.restrict p f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f ↑j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (Subtype.restrict p f) j) h)","decl":"@[reassoc]\ntheorem biproduct.ι_toSubtype_subtype (j : Subtype p) :\n    biproduct.ι f j ≫ biproduct.toSubtype f p = biproduct.ι (Subtype.restrict p f) j := by\n  classical\n  ext\n  rw [biproduct.toSubtype, Category.assoc, biproduct.lift_π, biproduct.ι_π, biproduct.ι_π]\n  split_ifs with h₁ h₂ h₂\n  exacts [rfl, False.elim (h₂ (Subtype.ext h₁)), False.elim (h₁ (congr_arg Subtype.val h₂)), rfl]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_fromSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (Subtype.restrict p f) j) (CategoryTheory.Limits.biproduct.fromSubtype f p)) (CategoryTheory.Limits.biproduct.ι f ↑j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_fromSubtype (j : Subtype p) :\n    biproduct.ι (Subtype.restrict p f) j ≫ biproduct.fromSubtype f p = biproduct.ι f j :=\n  biproduct.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_fromSubtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nj : Subtype p\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (Subtype.restrict p f) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f ↑j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_fromSubtype (j : Subtype p) :\n    biproduct.ι (Subtype.restrict p f) j ≫ biproduct.fromSubtype f p = biproduct.ι f j :=\n  biproduct.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_toSubtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct (Subtype.restrict p f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.fromSubtype_toSubtype :\n    biproduct.fromSubtype f p ≫ biproduct.toSubtype f p = 𝟙 (⨁ Subtype.restrict p f) := by\n  refine biproduct.hom_ext _ _ fun j => ?_\n  rw [Category.assoc, biproduct.toSubtype_π, biproduct.fromSubtype_π_subtype, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.fromSubtype_toSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) (CategoryTheory.Limits.biproduct.toSubtype f p)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biproduct (Subtype.restrict p f)))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.fromSubtype_toSubtype :\n    biproduct.fromSubtype f p ≫ biproduct.toSubtype f p = 𝟙 (⨁ Subtype.restrict p f) := by\n  refine biproduct.hom_ext _ _ fun j => ?_\n  rw [Category.assoc, biproduct.toSubtype_π, biproduct.fromSubtype_π_subtype, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_fromSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninst✝ : DecidablePred p\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.Limits.biproduct.fromSubtype f p)) (CategoryTheory.Limits.biproduct.map fun j => ite (p j) (CategoryTheory.CategoryStruct.id (f j)) 0)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.toSubtype_fromSubtype [DecidablePred p] :\n    biproduct.toSubtype f p ≫ biproduct.fromSubtype f p =\n      biproduct.map fun j => if p j then 𝟙 (f j) else 0 := by\n  ext1 i\n  by_cases h : p i\n  · simp [h]\n  · simp [h]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.toSubtype_fromSubtype_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\np : J → Prop\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict p f)\ninst✝ : DecidablePred p\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.toSubtype f p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f p) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map fun j => ite (p j) (CategoryTheory.CategoryStruct.id (f j)) 0) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.toSubtype_fromSubtype [DecidablePred p] :\n    biproduct.toSubtype f p ≫ biproduct.fromSubtype f p =\n      biproduct.map fun j => if p j then 𝟙 (f j) else 0 := by\n  ext1 i\n  by_cases h : p i\n  · simp [h]\n  · simp [h]\n\n"}
{"name":"CategoryTheory.Limits.instHasKernelπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ni : J\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\n⊢ CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.biproduct.π f i)","decl":"instance : HasKernel (biproduct.π f i) :=\n  HasLimit.mk ⟨_, biproduct.isLimitFromSubtype f i⟩\n\n"}
{"name":"CategoryTheory.Limits.kernelBiproductπIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ni : J\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\n⊢ Eq (CategoryTheory.Limits.kernelBiproductπIso f i).hom ((CategoryTheory.Limits.biproduct.isLimitFromSubtype f i).lift (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.π f i) 0)))","decl":"/-- The kernel of `biproduct.π f i` is `⨁ Subtype.restrict {i}ᶜ f`. -/\n@[simps!]\ndef kernelBiproductπIso : kernel (biproduct.π f i) ≅ ⨁ Subtype.restrict (fun j => j ≠ i) f :=\n  limit.isoLimitCone ⟨_, biproduct.isLimitFromSubtype f i⟩\n\n"}
{"name":"CategoryTheory.Limits.kernelBiproductπIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ni : J\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\n⊢ Eq (CategoryTheory.Limits.kernelBiproductπIso f i).inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.π f i) 0) (CategoryTheory.Limits.KernelFork.ofι (CategoryTheory.Limits.biproduct.fromSubtype f fun j => Not (Eq j i)) ⋯))","decl":"/-- The kernel of `biproduct.π f i` is `⨁ Subtype.restrict {i}ᶜ f`. -/\n@[simps!]\ndef kernelBiproductπIso : kernel (biproduct.π f i) ≅ ⨁ Subtype.restrict (fun j => j ≠ i) f :=\n  limit.isoLimitCone ⟨_, biproduct.isLimitFromSubtype f i⟩\n\n"}
{"name":"CategoryTheory.Limits.instHasCokernelι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ni : J\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\n⊢ CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.biproduct.ι f i)","decl":"instance : HasCokernel (biproduct.ι f i) :=\n  HasColimit.mk ⟨_, biproduct.isColimitToSubtype f i⟩\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiproductιIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ni : J\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\n⊢ Eq (CategoryTheory.Limits.cokernelBiproductιIso f i).hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.ι f i) 0) (CategoryTheory.Limits.CokernelCofork.ofπ (CategoryTheory.Limits.biproduct.toSubtype f fun j => Not (Eq j i)) ⋯))","decl":"/-- The cokernel of `biproduct.ι f i` is `⨁ Subtype.restrict {i}ᶜ f`. -/\n@[simps!]\ndef cokernelBiproductιIso : cokernel (biproduct.ι f i) ≅ ⨁ Subtype.restrict (fun j => j ≠ i) f :=\n  colimit.isoColimitCocone ⟨_, biproduct.isColimitToSubtype f i⟩\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiproductιIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ni : J\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Subtype.restrict (fun j => Ne j i) f)\n⊢ Eq (CategoryTheory.Limits.cokernelBiproductιIso f i).inv ((CategoryTheory.Limits.biproduct.isColimitToSubtype f i).desc (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.ι f i) 0)))","decl":"/-- The cokernel of `biproduct.ι f i` is `⨁ Subtype.restrict {i}ᶜ f`. -/\n@[simps!]\ndef cokernelBiproductιIso : cokernel (biproduct.ι f i) ≅ ⨁ Subtype.restrict (fun j => j ≠ i) f :=\n  colimit.isoColimitCocone ⟨_, biproduct.isColimitToSubtype f i⟩\n\n"}
{"name":"CategoryTheory.Limits.kernelForkBiproductToSubtype_cone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ Eq (CategoryTheory.Limits.kernelForkBiproductToSubtype f p).cone (CategoryTheory.Limits.KernelFork.ofι (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) ⋯)","decl":"/-- The limit cone exhibiting `⨁ Subtype.restrict pᶜ f` as the kernel of\n`biproduct.toSubtype f p` -/\n@[simps]\ndef kernelForkBiproductToSubtype (p : Set K) :\n    LimitCone (parallelPair (biproduct.toSubtype f p) 0) where\n  cone :=\n    KernelFork.ofι (biproduct.fromSubtype f pᶜ)\n      (by\n        classical\n        ext j k\n        simp only [Category.assoc, biproduct.ι_fromSubtype_assoc, biproduct.ι_toSubtype_assoc,\n          comp_zero, zero_comp]\n        rw [dif_neg k.2]\n        simp only [zero_comp])\n  isLimit :=\n    KernelFork.IsLimit.ofι _ _ (fun {_} g _ => g ≫ biproduct.toSubtype f pᶜ)\n      (by\n        classical\n        intro W' g' w\n        ext j\n        simp only [Category.assoc, biproduct.toSubtype_fromSubtype, Pi.compl_apply,\n          biproduct.map_π]\n        split_ifs with h\n        · simp\n        · replace w := w =≫ biproduct.π _ ⟨j, not_not.mp h⟩\n          simpa using w.symm)\n      (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.kernelForkBiproductToSubtype_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ Eq (CategoryTheory.Limits.kernelForkBiproductToSubtype f p).isLimit (CategoryTheory.Limits.KernelFork.IsLimit.ofι (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) ⋯ (fun {x} g x_1 => CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p))) ⋯ ⋯)","decl":"/-- The limit cone exhibiting `⨁ Subtype.restrict pᶜ f` as the kernel of\n`biproduct.toSubtype f p` -/\n@[simps]\ndef kernelForkBiproductToSubtype (p : Set K) :\n    LimitCone (parallelPair (biproduct.toSubtype f p) 0) where\n  cone :=\n    KernelFork.ofι (biproduct.fromSubtype f pᶜ)\n      (by\n        classical\n        ext j k\n        simp only [Category.assoc, biproduct.ι_fromSubtype_assoc, biproduct.ι_toSubtype_assoc,\n          comp_zero, zero_comp]\n        rw [dif_neg k.2]\n        simp only [zero_comp])\n  isLimit :=\n    KernelFork.IsLimit.ofι _ _ (fun {_} g _ => g ≫ biproduct.toSubtype f pᶜ)\n      (by\n        classical\n        intro W' g' w\n        ext j\n        simp only [Category.assoc, biproduct.toSubtype_fromSubtype, Pi.compl_apply,\n          biproduct.map_π]\n        split_ifs with h\n        · simp\n        · replace w := w =≫ biproduct.π _ ⟨j, not_not.mp h⟩\n          simpa using w.symm)\n      (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.instHasKernelToSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.biproduct.toSubtype f p)","decl":"instance (p : Set K) : HasKernel (biproduct.toSubtype f p) :=\n  HasLimit.mk (kernelForkBiproductToSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.kernelBiproductToSubtypeIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ Eq (CategoryTheory.Limits.kernelBiproductToSubtypeIso f p).inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.toSubtype f p) 0) (CategoryTheory.Limits.KernelFork.ofι (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) ⋯))","decl":"/-- The kernel of `biproduct.toSubtype f p` is `⨁ Subtype.restrict pᶜ f`. -/\n@[simps!]\ndef kernelBiproductToSubtypeIso (p : Set K) :\n    kernel (biproduct.toSubtype f p) ≅ ⨁ Subtype.restrict pᶜ f :=\n  limit.isoLimitCone (kernelForkBiproductToSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.kernelBiproductToSubtypeIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ Eq (CategoryTheory.Limits.kernelBiproductToSubtypeIso f p).hom ((CategoryTheory.Limits.KernelFork.IsLimit.ofι (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) ⋯ (fun {x} g x_1 => CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p))) ⋯ ⋯).lift (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.toSubtype f p) 0)))","decl":"/-- The kernel of `biproduct.toSubtype f p` is `⨁ Subtype.restrict pᶜ f`. -/\n@[simps!]\ndef kernelBiproductToSubtypeIso (p : Set K) :\n    kernel (biproduct.toSubtype f p) ≅ ⨁ Subtype.restrict pᶜ f :=\n  limit.isoLimitCone (kernelForkBiproductToSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.cokernelCoforkBiproductFromSubtype_cocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ Eq (CategoryTheory.Limits.cokernelCoforkBiproductFromSubtype f p).cocone (CategoryTheory.Limits.CokernelCofork.ofπ (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p)) ⋯)","decl":"/-- The colimit cocone exhibiting `⨁ Subtype.restrict pᶜ f` as the cokernel of\n`biproduct.fromSubtype f p` -/\n@[simps]\ndef cokernelCoforkBiproductFromSubtype (p : Set K) :\n    ColimitCocone (parallelPair (biproduct.fromSubtype f p) 0) where\n  cocone :=\n    CokernelCofork.ofπ (biproduct.toSubtype f pᶜ)\n      (by\n        classical\n        ext j k\n        simp only [Category.assoc, Pi.compl_apply, biproduct.ι_fromSubtype_assoc,\n          biproduct.ι_toSubtype_assoc, comp_zero, zero_comp]\n        rw [dif_neg]\n        · simp only [zero_comp]\n        · exact not_not.mpr k.2)\n  isColimit :=\n    CokernelCofork.IsColimit.ofπ _ _ (fun {_} g _ => biproduct.fromSubtype f pᶜ ≫ g)\n      (by\n        classical\n        intro W g' w\n        ext j\n        simp only [biproduct.toSubtype_fromSubtype_assoc, Pi.compl_apply, biproduct.ι_map_assoc]\n        split_ifs with h\n        · simp\n        · replace w := biproduct.ι _ (⟨j, not_not.mp h⟩ : p) ≫= w\n          simpa using w.symm)\n      (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.cokernelCoforkBiproductFromSubtype_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ Eq (CategoryTheory.Limits.cokernelCoforkBiproductFromSubtype f p).isColimit (CategoryTheory.Limits.CokernelCofork.IsColimit.ofπ (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p)) ⋯ (fun {x} g x_1 => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) g) ⋯ ⋯)","decl":"/-- The colimit cocone exhibiting `⨁ Subtype.restrict pᶜ f` as the cokernel of\n`biproduct.fromSubtype f p` -/\n@[simps]\ndef cokernelCoforkBiproductFromSubtype (p : Set K) :\n    ColimitCocone (parallelPair (biproduct.fromSubtype f p) 0) where\n  cocone :=\n    CokernelCofork.ofπ (biproduct.toSubtype f pᶜ)\n      (by\n        classical\n        ext j k\n        simp only [Category.assoc, Pi.compl_apply, biproduct.ι_fromSubtype_assoc,\n          biproduct.ι_toSubtype_assoc, comp_zero, zero_comp]\n        rw [dif_neg]\n        · simp only [zero_comp]\n        · exact not_not.mpr k.2)\n  isColimit :=\n    CokernelCofork.IsColimit.ofπ _ _ (fun {_} g _ => biproduct.fromSubtype f pᶜ ≫ g)\n      (by\n        classical\n        intro W g' w\n        ext j\n        simp only [biproduct.toSubtype_fromSubtype_assoc, Pi.compl_apply, biproduct.ι_map_assoc]\n        split_ifs with h\n        · simp\n        · replace w := biproduct.ι _ (⟨j, not_not.mp h⟩ : p) ≫= w\n          simpa using w.symm)\n      (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.instHasCokernelFromSubtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.biproduct.fromSubtype f p)","decl":"instance (p : Set K) : HasCokernel (biproduct.fromSubtype f p) :=\n  HasColimit.mk (cokernelCoforkBiproductFromSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiproductFromSubtypeIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ Eq (CategoryTheory.Limits.cokernelBiproductFromSubtypeIso f p).hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.fromSubtype f p) 0) (CategoryTheory.Limits.CokernelCofork.ofπ (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p)) ⋯))","decl":"/-- The cokernel of `biproduct.fromSubtype f p` is `⨁ Subtype.restrict pᶜ f`. -/\n@[simps!]\ndef cokernelBiproductFromSubtypeIso (p : Set K) :\n    cokernel (biproduct.fromSubtype f p) ≅ ⨁ Subtype.restrict pᶜ f :=\n  colimit.isoColimitCocone (cokernelCoforkBiproductFromSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiproductFromSubtypeIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nK : Type\ninst✝¹ : Finite K\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : K → C\np : Set K\n⊢ Eq (CategoryTheory.Limits.cokernelBiproductFromSubtypeIso f p).inv ((CategoryTheory.Limits.CokernelCofork.IsColimit.ofπ (CategoryTheory.Limits.biproduct.toSubtype f (HasCompl.compl p)) ⋯ (fun {x} g x_1 => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.fromSubtype f (HasCompl.compl p)) g) ⋯ ⋯).desc (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.biproduct.fromSubtype f p) 0)))","decl":"/-- The cokernel of `biproduct.fromSubtype f p` is `⨁ Subtype.restrict pᶜ f`. -/\n@[simps!]\ndef cokernelBiproductFromSubtypeIso (p : Set K) :\n    cokernel (biproduct.fromSubtype f p) ≅ ⨁ Subtype.restrict pᶜ f :=\n  colimit.isoColimitCocone (cokernelCoforkBiproductFromSubtype f p)\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninst✝⁴ : Finite J\nK : Type\ninst✝³ : Finite K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.Limits.biproduct.π g k)) (CategoryTheory.Limits.biproduct.desc fun j => m j k)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.matrix_π (m : ∀ j k, f j ⟶ g k) (k : K) :\n    biproduct.matrix m ≫ biproduct.π g k = biproduct.desc fun j => m j k := by\n  ext\n  simp [biproduct.matrix]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninst✝⁴ : Finite J\nK : Type\ninst✝³ : Finite K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nk : K\nZ : C\nh : Quiver.Hom (g k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π g k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.desc fun j => m j k) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.matrix_π (m : ∀ j k, f j ⟶ g k) (k : K) :\n    biproduct.matrix m ≫ biproduct.π g k = biproduct.desc fun j => m j k := by\n  ext\n  simp [biproduct.matrix]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_matrix","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninst✝⁴ : Finite J\nK : Type\ninst✝³ : Finite K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.Limits.biproduct.matrix m)) (CategoryTheory.Limits.biproduct.lift fun k => m j k)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_matrix (m : ∀ j k, f j ⟶ g k) (j : J) :\n    biproduct.ι f j ≫ biproduct.matrix m = biproduct.lift fun k => m j k := by\n  ext\n  simp [biproduct.matrix]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_matrix_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninst✝⁴ : Finite J\nK : Type\ninst✝³ : Finite K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.matrix m) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.lift fun k => m j k) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct.ι_matrix (m : ∀ j k, f j ⟶ g k) (j : J) :\n    biproduct.ι f j ≫ biproduct.matrix m = biproduct.lift fun k => m j k := by\n  ext\n  simp [biproduct.matrix]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrix_components","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninst✝⁴ : Finite J\nK : Type\ninst✝³ : Finite K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\nj : J\nk : K\n⊢ Eq (CategoryTheory.Limits.biproduct.components (CategoryTheory.Limits.biproduct.matrix m) j k) (m j k)","decl":"@[simp]\ntheorem biproduct.matrix_components (m : ∀ j k, f j ⟶ g k) (j : J) (k : K) :\n    biproduct.components (biproduct.matrix m) j k = m j k := by simp [biproduct.components]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.components_matrix","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninst✝⁴ : Finite J\nK : Type\ninst✝³ : Finite K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nm : Quiver.Hom (CategoryTheory.Limits.biproduct f) (CategoryTheory.Limits.biproduct g)\n⊢ Eq (CategoryTheory.Limits.biproduct.matrix fun j k => CategoryTheory.Limits.biproduct.components m j k) m","decl":"@[simp]\ntheorem biproduct.components_matrix (m : ⨁ f ⟶ ⨁ g) :\n    (biproduct.matrix fun j k => biproduct.components m j k) = m := by\n  ext\n  simp [biproduct.components]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrixEquiv_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninst✝⁴ : Finite J\nK : Type\ninst✝³ : Finite K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nm : Quiver.Hom (CategoryTheory.Limits.biproduct f) (CategoryTheory.Limits.biproduct g)\nj : J\nk : K\n⊢ Eq (CategoryTheory.Limits.biproduct.matrixEquiv m j k) (CategoryTheory.Limits.biproduct.components m j k)","decl":"/-- Morphisms between direct sums are matrices. -/\n@[simps]\ndef biproduct.matrixEquiv : (⨁ f ⟶ ⨁ g) ≃ ∀ j k, f j ⟶ g k where\n  toFun := biproduct.components\n  invFun := biproduct.matrix\n  left_inv := biproduct.components_matrix\n  right_inv m := by\n    ext\n    apply biproduct.matrix_components\n\n"}
{"name":"CategoryTheory.Limits.biproduct.matrixEquiv_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type\ninst✝⁴ : Finite J\nK : Type\ninst✝³ : Finite K\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\nf : J → C\ng : K → C\nm : (j : J) → (k : K) → Quiver.Hom (f j) (g k)\n⊢ Eq (CategoryTheory.Limits.biproduct.matrixEquiv.symm m) (CategoryTheory.Limits.biproduct.matrix m)","decl":"/-- Morphisms between direct sums are matrices. -/\n@[simps]\ndef biproduct.matrixEquiv : (⨁ f ⟶ ⨁ g) ≃ ∀ j k, f j ⟶ g k where\n  toFun := biproduct.components\n  invFun := biproduct.matrix\n  left_inv := biproduct.components_matrix\n  right_inv m := by\n    ext\n    apply biproduct.matrix_components\n\n"}
{"name":"CategoryTheory.Limits.biproduct.ι_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nb : J\n⊢ CategoryTheory.IsSplitMono (CategoryTheory.Limits.biproduct.ι f b)","decl":"instance biproduct.ι_mono (f : J → C) [HasBiproduct f] (b : J) : IsSplitMono (biproduct.ι f b) := by\n  classical exact IsSplitMono.mk' { retraction := biproduct.desc <| Pi.single b (𝟙 (f b)) }\n\n"}
{"name":"CategoryTheory.Limits.biproduct.π_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nb : J\n⊢ CategoryTheory.IsSplitEpi (CategoryTheory.Limits.biproduct.π f b)","decl":"instance biproduct.π_epi (f : J → C) [HasBiproduct f] (b : J) : IsSplitEpi (biproduct.π f b) := by\n  classical exact IsSplitEpi.mk' { section_ := biproduct.lift <| Pi.single b (𝟙 (f b)) }\n\n"}
{"name":"CategoryTheory.Limits.biproduct.conePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nb : CategoryTheory.Limits.Bicone f\nhb : b.IsBilimit\n⊢ Eq (hb.isLimit.conePointUniqueUpToIso (CategoryTheory.Limits.biproduct.isLimit f)).hom (CategoryTheory.Limits.biproduct.lift b.π)","decl":"/-- Auxiliary lemma for `biproduct.uniqueUpToIso`. -/\ntheorem biproduct.conePointUniqueUpToIso_hom (f : J → C) [HasBiproduct f] {b : Bicone f}\n    (hb : b.IsBilimit) :\n    (hb.isLimit.conePointUniqueUpToIso (biproduct.isLimit _)).hom = biproduct.lift b.π :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biproduct.conePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nb : CategoryTheory.Limits.Bicone f\nhb : b.IsBilimit\n⊢ Eq (hb.isLimit.conePointUniqueUpToIso (CategoryTheory.Limits.biproduct.isLimit f)).inv (CategoryTheory.Limits.biproduct.desc b.ι)","decl":"/-- Auxiliary lemma for `biproduct.uniqueUpToIso`. -/\ntheorem biproduct.conePointUniqueUpToIso_inv (f : J → C) [HasBiproduct f] {b : Bicone f}\n    (hb : b.IsBilimit) :\n    (hb.isLimit.conePointUniqueUpToIso (biproduct.isLimit _)).inv = biproduct.desc b.ι := by\n  classical\n  refine biproduct.hom_ext' _ _ fun j => hb.isLimit.hom_ext fun j' => ?_\n  rw [Category.assoc, IsLimit.conePointUniqueUpToIso_inv_comp, Bicone.toCone_π_app,\n    biproduct.bicone_π, biproduct.ι_desc, biproduct.ι_π, b.toCone_π_app, b.ι_π]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nb : CategoryTheory.Limits.Bicone f\nhb : b.IsBilimit\n⊢ Eq (CategoryTheory.Limits.biproduct.uniqueUpToIso f hb).hom (CategoryTheory.Limits.biproduct.lift b.π)","decl":"/-- Biproducts are unique up to isomorphism. This already follows because bilimits are limits,\n    but in the case of biproducts we can give an isomorphism with particularly nice definitional\n    properties, namely that `biproduct.lift b.π` and `biproduct.desc b.ι` are inverses of each\n    other. -/\n@[simps]\ndef biproduct.uniqueUpToIso (f : J → C) [HasBiproduct f] {b : Bicone f} (hb : b.IsBilimit) :\n    b.pt ≅ ⨁ f where\n  hom := biproduct.lift b.π\n  inv := biproduct.desc b.ι\n  hom_inv_id := by\n    rw [← biproduct.conePointUniqueUpToIso_hom f hb, ←\n      biproduct.conePointUniqueUpToIso_inv f hb, Iso.hom_inv_id]\n  inv_hom_id := by\n    rw [← biproduct.conePointUniqueUpToIso_hom f hb, ←\n      biproduct.conePointUniqueUpToIso_inv f hb, Iso.inv_hom_id]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nf : J → C\ninst✝ : CategoryTheory.Limits.HasBiproduct f\nb : CategoryTheory.Limits.Bicone f\nhb : b.IsBilimit\n⊢ Eq (CategoryTheory.Limits.biproduct.uniqueUpToIso f hb).inv (CategoryTheory.Limits.biproduct.desc b.ι)","decl":"/-- Biproducts are unique up to isomorphism. This already follows because bilimits are limits,\n    but in the case of biproducts we can give an isomorphism with particularly nice definitional\n    properties, namely that `biproduct.lift b.π` and `biproduct.desc b.ι` are inverses of each\n    other. -/\n@[simps]\ndef biproduct.uniqueUpToIso (f : J → C) [HasBiproduct f] {b : Bicone f} (hb : b.IsBilimit) :\n    b.pt ≅ ⨁ f where\n  hom := biproduct.lift b.π\n  inv := biproduct.desc b.ι\n  hom_inv_id := by\n    rw [← biproduct.conePointUniqueUpToIso_hom f hb, ←\n      biproduct.conePointUniqueUpToIso_inv f hb, Iso.hom_inv_id]\n  inv_hom_id := by\n    rw [← biproduct.conePointUniqueUpToIso_hom f hb, ←\n      biproduct.conePointUniqueUpToIso_inv f hb, Iso.inv_hom_id]\n\n"}
{"name":"CategoryTheory.Limits.hasZeroObject_of_hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\n⊢ CategoryTheory.Limits.HasZeroObject C","decl":"/-- A category with finite biproducts has a zero object. -/\ninstance (priority := 100) hasZeroObject_of_hasFiniteBiproducts [HasFiniteBiproducts C] :\n    HasZeroObject C := by\n  refine ⟨⟨biproduct Empty.elim, fun X => ⟨⟨⟨0⟩, ?_⟩⟩, fun X => ⟨⟨⟨0⟩, ?_⟩⟩⟩⟩\n  · intro a; apply biproduct.hom_ext'; simp\n  · intro a; apply biproduct.hom_ext; simp\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_bicone_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : Unique J\nf : J → C\nj : J\n⊢ Eq ((CategoryTheory.Limits.limitBiconeOfUnique f).bicone.ι j) (CategoryTheory.eqToHom ⋯)","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J → C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      π := fun j => eqToHom (by congr; rw [← Unique.uniq] )\n      ι := fun j => eqToHom (by congr; rw [← Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_isBilimit_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : Unique J\nf : J → C\n⊢ Eq (CategoryTheory.Limits.limitBiconeOfUnique f).isBilimit.isLimit (CategoryTheory.Limits.limitConeOfUnique f).isLimit","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J → C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      π := fun j => eqToHom (by congr; rw [← Unique.uniq] )\n      ι := fun j => eqToHom (by congr; rw [← Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_bicone_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : Unique J\nf : J → C\nj : J\n⊢ Eq ((CategoryTheory.Limits.limitBiconeOfUnique f).bicone.π j) (CategoryTheory.eqToHom ⋯)","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J → C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      π := fun j => eqToHom (by congr; rw [← Unique.uniq] )\n      ι := fun j => eqToHom (by congr; rw [← Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_isBilimit_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : Unique J\nf : J → C\n⊢ Eq (CategoryTheory.Limits.limitBiconeOfUnique f).isBilimit.isColimit (CategoryTheory.Limits.colimitCoconeOfUnique f).isColimit","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J → C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      π := fun j => eqToHom (by congr; rw [← Unique.uniq] )\n      ι := fun j => eqToHom (by congr; rw [← Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.limitBiconeOfUnique_bicone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : Unique J\nf : J → C\n⊢ Eq (CategoryTheory.Limits.limitBiconeOfUnique f).bicone.pt (f Inhabited.default)","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The limit bicone for the biproduct over an index type with exactly one term. -/\n@[simps]\ndef limitBiconeOfUnique [Unique J] (f : J → C) : LimitBicone f where\n  bicone :=\n    { pt := f default\n      π := fun j => eqToHom (by congr; rw [← Unique.uniq] )\n      ι := fun j => eqToHom (by congr; rw [← Unique.uniq] ) }\n  isBilimit :=\n    { isLimit := (limitConeOfUnique f).isLimit\n      isColimit := (colimitCoconeOfUnique f).isColimit }\n\n"}
{"name":"CategoryTheory.Limits.hasBiproduct_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : Subsingleton J\ninst✝ : Nonempty J\nf : J → C\n⊢ CategoryTheory.Limits.HasBiproduct f","decl":"instance (priority := 100) hasBiproduct_unique [Subsingleton J] [Nonempty J] (f : J → C) :\n    HasBiproduct f :=\n  let ⟨_⟩ := nonempty_unique J; .mk (limitBiconeOfUnique f)\n\n"}
{"name":"CategoryTheory.Limits.biproductUniqueIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : Unique J\nf : J → C\n⊢ Eq (CategoryTheory.Limits.biproductUniqueIso f).inv (CategoryTheory.Limits.biproduct.lift (CategoryTheory.Limits.limitBiconeOfUnique f).bicone.π)","decl":"/-- A biproduct over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef biproductUniqueIso [Unique J] (f : J → C) : ⨁ f ≅ f default :=\n  (biproduct.uniqueUpToIso _ (limitBiconeOfUnique f).isBilimit).symm\n\n"}
{"name":"CategoryTheory.Limits.biproductUniqueIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"J : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : Unique J\nf : J → C\n⊢ Eq (CategoryTheory.Limits.biproductUniqueIso f).hom (CategoryTheory.Limits.biproduct.desc (CategoryTheory.Limits.limitBiconeOfUnique f).bicone.ι)","decl":"/-- A biproduct over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef biproductUniqueIso [Unique J] (f : J → C) : ⨁ f ≅ f default :=\n  (biproduct.uniqueUpToIso _ (limitBiconeOfUnique f).isBilimit).symm\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inl_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.inl self.snd) 0","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ≫ fst = 𝟙 P`, `inl ≫ snd = 0`, `inr ≫ fst = 0`, and `inr ≫ snd = 𝟙 Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt ⟶ P\n  snd : pt ⟶ Q\n  inl : P ⟶ pt\n  inr : Q ⟶ pt\n  inl_fst : inl ≫ fst = 𝟙 P := by aesop\n  inl_snd : inl ≫ snd = 0 := by aesop\n  inr_fst : inr ≫ fst = 0 := by aesop\n  inr_snd : inr ≫ snd = 𝟙 Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\ninst✝ : SizeOf C\npt : C\nfst : Quiver.Hom pt P\nsnd : Quiver.Hom pt Q\ninl : Quiver.Hom P pt\ninr : Quiver.Hom Q pt\ninl_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl fst) (CategoryTheory.CategoryStruct.id P)) _auto✝\ninl_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl snd) 0) _auto✝\ninr_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr fst) 0) _auto✝\ninr_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr snd) (CategoryTheory.CategoryStruct.id Q)) _auto✝\n⊢ Eq (SizeOf.sizeOf { pt := pt, fst := fst, snd := snd, inl := inl, inr := inr, inl_fst := inl_fst, inl_snd := inl_snd, inr_fst := inr_fst, inr_snd := inr_snd }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf pt)) (SizeOf.sizeOf fst)) (SizeOf.sizeOf snd)) (SizeOf.sizeOf inl)) (SizeOf.sizeOf inr)) (SizeOf.sizeOf inl_fst)) (SizeOf.sizeOf inl_snd)) (SizeOf.sizeOf inr_fst)) (SizeOf.sizeOf inr_snd))","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ≫ fst = 𝟙 P`, `inl ≫ snd = 0`, `inr ≫ fst = 0`, and `inr ≫ snd = 𝟙 Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt ⟶ P\n  snd : pt ⟶ Q\n  inl : P ⟶ pt\n  inr : Q ⟶ pt\n  inl_fst : inl ≫ fst = 𝟙 P := by aesop\n  inl_snd : inl ≫ snd = 0 := by aesop\n  inr_fst : inr ≫ fst = 0 := by aesop\n  inr_snd : inr ≫ snd = 𝟙 Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inr_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.inr self.fst) 0","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ≫ fst = 𝟙 P`, `inl ≫ snd = 0`, `inr ≫ fst = 0`, and `inr ≫ snd = 𝟙 Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt ⟶ P\n  snd : pt ⟶ Q\n  inl : P ⟶ pt\n  inr : Q ⟶ pt\n  inl_fst : inl ≫ fst = 𝟙 P := by aesop\n  inl_snd : inl ≫ snd = 0 := by aesop\n  inr_fst : inr ≫ fst = 0 := by aesop\n  inr_snd : inr ≫ snd = 𝟙 Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q pt✝ : C\nfst✝ : Quiver.Hom pt✝ P\nsnd✝ : Quiver.Hom pt✝ Q\ninl✝ : Quiver.Hom P pt✝\ninr✝ : Quiver.Hom Q pt✝\ninl_fst✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl✝ fst✝) (CategoryTheory.CategoryStruct.id P)) _auto✝\ninl_snd✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl✝ snd✝) 0) _auto✝\ninr_fst✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr✝ fst✝) 0) _auto✝\ninr_snd✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr✝ snd✝) (CategoryTheory.CategoryStruct.id Q)) _auto✝\npt : C\nfst : Quiver.Hom pt P\nsnd : Quiver.Hom pt Q\ninl : Quiver.Hom P pt\ninr : Quiver.Hom Q pt\ninl_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl fst) (CategoryTheory.CategoryStruct.id P)) _auto✝\ninl_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl snd) 0) _auto✝\ninr_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr fst) 0) _auto✝\ninr_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr snd) (CategoryTheory.CategoryStruct.id Q)) _auto✝\nx✝ : Eq { pt := pt✝, fst := fst✝, snd := snd✝, inl := inl✝, inr := inr✝, inl_fst := inl_fst✝, inl_snd := inl_snd✝, inr_fst := inr_fst✝, inr_snd := inr_snd✝ } { pt := pt, fst := fst, snd := snd, inl := inl, inr := inr, inl_fst := inl_fst, inl_snd := inl_snd, inr_fst := inr_fst, inr_snd := inr_snd }\n⊢ And (Eq pt✝ pt) (And (HEq fst✝ fst) (And (HEq snd✝ snd) (And (HEq inl✝ inl) (HEq inr✝ inr))))","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ≫ fst = 𝟙 P`, `inl ≫ snd = 0`, `inr ≫ fst = 0`, and `inr ≫ snd = 𝟙 Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt ⟶ P\n  snd : pt ⟶ Q\n  inl : P ⟶ pt\n  inr : Q ⟶ pt\n  inl_fst : inl ≫ fst = 𝟙 P := by aesop\n  inl_snd : inl ≫ snd = 0 := by aesop\n  inr_fst : inr ≫ fst = 0 := by aesop\n  inr_snd : inr ≫ snd = 𝟙 Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q pt✝ : C\nfst✝ : Quiver.Hom pt✝ P\nsnd✝ : Quiver.Hom pt✝ Q\ninl✝ : Quiver.Hom P pt✝\ninr✝ : Quiver.Hom Q pt✝\ninl_fst✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl✝ fst✝) (CategoryTheory.CategoryStruct.id P)) _auto✝\ninl_snd✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl✝ snd✝) 0) _auto✝\ninr_fst✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr✝ fst✝) 0) _auto✝\ninr_snd✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr✝ snd✝) (CategoryTheory.CategoryStruct.id Q)) _auto✝\npt : C\nfst : Quiver.Hom pt P\nsnd : Quiver.Hom pt Q\ninl : Quiver.Hom P pt\ninr : Quiver.Hom Q pt\ninl_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl fst) (CategoryTheory.CategoryStruct.id P)) _auto✝\ninl_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inl snd) 0) _auto✝\ninr_fst : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr fst) 0) _auto✝\ninr_snd : autoParam (Eq (CategoryTheory.CategoryStruct.comp inr snd) (CategoryTheory.CategoryStruct.id Q)) _auto✝\n⊢ Eq (Eq { pt := pt✝, fst := fst✝, snd := snd✝, inl := inl✝, inr := inr✝, inl_fst := inl_fst✝, inl_snd := inl_snd✝, inr_fst := inr_fst✝, inr_snd := inr_snd✝ } { pt := pt, fst := fst, snd := snd, inl := inl, inr := inr, inl_fst := inl_fst, inl_snd := inl_snd, inr_fst := inr_fst, inr_snd := inr_snd }) (And (Eq pt✝ pt) (And (HEq fst✝ fst) (And (HEq snd✝ snd) (And (HEq inl✝ inl) (HEq inr✝ inr)))))","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ≫ fst = 𝟙 P`, `inl ≫ snd = 0`, `inr ≫ fst = 0`, and `inr ≫ snd = 𝟙 Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt ⟶ P\n  snd : pt ⟶ Q\n  inl : P ⟶ pt\n  inr : Q ⟶ pt\n  inl_fst : inl ≫ fst = 𝟙 P := by aesop\n  inl_snd : inl ≫ snd = 0 := by aesop\n  inr_fst : inr ≫ fst = 0 := by aesop\n  inr_snd : inr ≫ snd = 𝟙 Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inr_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.inr self.snd) (CategoryTheory.CategoryStruct.id Q)","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ≫ fst = 𝟙 P`, `inl ≫ snd = 0`, `inr ≫ fst = 0`, and `inr ≫ snd = 𝟙 Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt ⟶ P\n  snd : pt ⟶ Q\n  inl : P ⟶ pt\n  inr : Q ⟶ pt\n  inl_fst : inl ≫ fst = 𝟙 P := by aesop\n  inl_snd : inl ≫ snd = 0 := by aesop\n  inr_fst : inr ≫ fst = 0 := by aesop\n  inr_snd : inr ≫ snd = 𝟙 Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inl_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.inl self.fst) (CategoryTheory.CategoryStruct.id P)","decl":"/-- A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ≫ fst = 𝟙 P`, `inl ≫ snd = 0`, `inr ≫ fst = 0`, and `inr ≫ snd = 𝟙 Q`\n-/\nstructure BinaryBicone (P Q : C) where\n  pt : C\n  fst : pt ⟶ P\n  snd : pt ⟶ Q\n  inl : P ⟶ pt\n  inr : Q ⟶ pt\n  inl_fst : inl ≫ fst = 𝟙 P := by aesop\n  inl_snd : inl ≫ snd = 0 := by aesop\n  inr_fst : inr ≫ fst = 0 := by aesop\n  inr_snd : inr ≫ snd = 𝟙 Q := by aesop\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inr_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.inr (CategoryTheory.CategoryStruct.comp self.fst h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)]\n  BinaryBicone.inl_fst BinaryBicone.inl_snd BinaryBicone.inr_fst BinaryBicone.inr_snd\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inl_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nZ : C\nh : Quiver.Hom Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.inl (CategoryTheory.CategoryStruct.comp self.snd h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)]\n  BinaryBicone.inl_fst BinaryBicone.inl_snd BinaryBicone.inr_fst BinaryBicone.inr_snd\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inl_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.inl (CategoryTheory.CategoryStruct.comp self.fst h)) h","decl":"attribute [reassoc (attr := simp)]\n  BinaryBicone.inl_fst BinaryBicone.inl_snd BinaryBicone.inr_fst BinaryBicone.inr_snd\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inr_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.BinaryBicone P Q\nZ : C\nh : Quiver.Hom Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.inr (CategoryTheory.CategoryStruct.comp self.snd h)) h","decl":"attribute [reassoc (attr := simp)]\n  BinaryBicone.inl_fst BinaryBicone.inl_snd BinaryBicone.inr_fst BinaryBicone.inr_snd\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\ninst✝ : SizeOf C\nhom : Quiver.Hom A.pt B.pt\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.fst) A.fst) _auto✝\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.snd) A.snd) _auto✝\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl hom) B.inl) _auto✝\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr hom) B.inr) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, wfst := wfst, wsnd := wsnd, winl := winl, winr := winr }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf wfst)) (SizeOf.sizeOf wsnd)) (SizeOf.sizeOf winl)) (SizeOf.sizeOf winr))","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom ≫ B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom ≫ B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl ≫ hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr ≫ hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nhom✝ : Quiver.Hom A.pt B.pt\nwfst✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom✝ B.fst) A.fst) _auto✝\nwsnd✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom✝ B.snd) A.snd) _auto✝\nwinl✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl hom✝) B.inl) _auto✝\nwinr✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr hom✝) B.inr) _auto✝\nhom : Quiver.Hom A.pt B.pt\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.fst) A.fst) _auto✝\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.snd) A.snd) _auto✝\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl hom) B.inl) _auto✝\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr hom) B.inr) _auto✝\nx✝ : Eq { hom := hom✝, wfst := wfst✝, wsnd := wsnd✝, winl := winl✝, winr := winr✝ } { hom := hom, wfst := wfst, wsnd := wsnd, winl := winl, winr := winr }\n⊢ Eq hom✝ hom","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom ≫ B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom ≫ B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl ≫ hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr ≫ hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.wsnd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.hom B.snd) A.snd","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom ≫ B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom ≫ B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl ≫ hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr ≫ hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nhom✝ : Quiver.Hom A.pt B.pt\nwfst✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom✝ B.fst) A.fst) _auto✝\nwsnd✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom✝ B.snd) A.snd) _auto✝\nwinl✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl hom✝) B.inl) _auto✝\nwinr✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr hom✝) B.inr) _auto✝\nhom : Quiver.Hom A.pt B.pt\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.fst) A.fst) _auto✝\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom B.snd) A.snd) _auto✝\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inl hom) B.inl) _auto✝\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.inr hom) B.inr) _auto✝\n⊢ Eq (Eq { hom := hom✝, wfst := wfst✝, wsnd := wsnd✝, winl := winl✝, winr := winr✝ } { hom := hom, wfst := wfst, wsnd := wsnd, winl := winl, winr := winr }) (Eq hom✝ hom)","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom ≫ B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom ≫ B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl ≫ hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr ≫ hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.wfst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.hom B.fst) A.fst","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom ≫ B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom ≫ B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl ≫ hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr ≫ hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.winl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.inl self.hom) B.inl","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom ≫ B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom ≫ B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl ≫ hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr ≫ hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.winr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.inr self.hom) B.inr","decl":"/-- A binary bicone morphism between two binary bicones for the same diagram is a morphism of the\nbinary bicone points which commutes with the cone and cocone legs. -/\nstructure BinaryBiconeMorphism {P Q : C} (A B : BinaryBicone P Q) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt ⟶ B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wfst : hom ≫ B.fst = A.fst := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  wsnd : hom ≫ B.snd = A.snd := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winl : A.inl ≫ hom = B.inl := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  winr : A.inr ≫ hom = B.inr := by aesop_cat\n\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.wsnd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nZ : C\nh : Quiver.Hom Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp B.snd h)) (CategoryTheory.CategoryStruct.comp A.snd h)","decl":"attribute [reassoc (attr := simp)] BinaryBiconeMorphism.wfst BinaryBiconeMorphism.wsnd\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.wfst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nZ : C\nh : Quiver.Hom P Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp B.fst h)) (CategoryTheory.CategoryStruct.comp A.fst h)","decl":"attribute [reassoc (attr := simp)] BinaryBiconeMorphism.wfst BinaryBiconeMorphism.wsnd\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.winr_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nZ : C\nh : Quiver.Hom B.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.inr (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp B.inr h)","decl":"attribute [reassoc (attr := simp)] BinaryBiconeMorphism.winl BinaryBiconeMorphism.winr\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.winl_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nA B : CategoryTheory.Limits.BinaryBicone P Q\nself : CategoryTheory.Limits.BinaryBiconeMorphism A B\nZ : C\nh : Quiver.Hom B.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.inl (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp B.inl h)","decl":"attribute [reassoc (attr := simp)] BinaryBiconeMorphism.winl BinaryBiconeMorphism.winr\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.category_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nX✝ Y✝ Z✝ : CategoryTheory.Limits.BinaryBicone P Q\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- The category of binary bicones on a given diagram. -/\n@[simps]\ninstance BinaryBicone.category {P Q : C} : Category (BinaryBicone P Q) where\n  Hom A B := BinaryBiconeMorphism A B\n  comp f g := { hom := f.hom ≫ g.hom }\n  id B := { hom := 𝟙 B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the `hom` field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.category_id_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nB : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (CategoryTheory.CategoryStruct.id B).hom (CategoryTheory.CategoryStruct.id B.pt)","decl":"/-- The category of binary bicones on a given diagram. -/\n@[simps]\ninstance BinaryBicone.category {P Q : C} : Category (BinaryBicone P Q) where\n  Hom A B := BinaryBiconeMorphism A B\n  comp f g := { hom := f.hom ≫ g.hom }\n  id B := { hom := 𝟙 B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the `hom` field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc c' : CategoryTheory.Limits.BinaryBicone P Q\nf g : Quiver.Hom c c'\n⊢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\ntheorem BinaryBiconeMorphism.ext {P Q : C} {c c' : BinaryBicone P Q}\n    (f g : c ⟶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiconeMorphism.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc c' : CategoryTheory.Limits.BinaryBicone P Q\nf g : Quiver.Hom c c'\nw : Eq f.hom g.hom\n⊢ Eq f g","decl":"@[ext]\ntheorem BinaryBiconeMorphism.ext {P Q : C} {c c' : BinaryBicone P Q}\n    (f g : c ⟶ c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc c' : CategoryTheory.Limits.BinaryBicone P Q\nφ : CategoryTheory.Iso c.pt c'.pt\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp c.inl φ.hom) c'.inl) _auto✝\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp c.inr φ.hom) c'.inr) _auto✝\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp φ.hom c'.fst) c.fst) _auto✝\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp φ.hom c'.snd) c.snd) _auto✝\n⊢ Eq (CategoryTheory.Limits.BinaryBicones.ext φ winl winr wfst wsnd).inv.hom φ.inv","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {P Q : C} {c c' : BinaryBicone P Q} (φ : c.pt ≅ c'.pt)\n    (winl : c.inl ≫ φ.hom = c'.inl := by aesop_cat)\n    (winr : c.inr ≫ φ.hom = c'.inr := by aesop_cat)\n    (wfst : φ.hom ≫ c'.fst = c.fst := by aesop_cat)\n    (wsnd : φ.hom ≫ c'.snd = c.snd := by aesop_cat) : c ≅ c' where\n  hom := { hom := φ.hom }\n  inv :=\n    { hom := φ.inv\n      wfst := φ.inv_comp_eq.mpr wfst.symm\n      wsnd := φ.inv_comp_eq.mpr wsnd.symm\n      winl := φ.comp_inv_eq.mpr winl.symm\n      winr := φ.comp_inv_eq.mpr winr.symm }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc c' : CategoryTheory.Limits.BinaryBicone P Q\nφ : CategoryTheory.Iso c.pt c'.pt\nwinl : autoParam (Eq (CategoryTheory.CategoryStruct.comp c.inl φ.hom) c'.inl) _auto✝\nwinr : autoParam (Eq (CategoryTheory.CategoryStruct.comp c.inr φ.hom) c'.inr) _auto✝\nwfst : autoParam (Eq (CategoryTheory.CategoryStruct.comp φ.hom c'.fst) c.fst) _auto✝\nwsnd : autoParam (Eq (CategoryTheory.CategoryStruct.comp φ.hom c'.snd) c.snd) _auto✝\n⊢ Eq (CategoryTheory.Limits.BinaryBicones.ext φ winl winr wfst wsnd).hom.hom φ.hom","decl":"/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {P Q : C} {c c' : BinaryBicone P Q} (φ : c.pt ≅ c'.pt)\n    (winl : c.inl ≫ φ.hom = c'.inl := by aesop_cat)\n    (winr : c.inr ≫ φ.hom = c'.inr := by aesop_cat)\n    (wfst : φ.hom ≫ c'.fst = c.fst := by aesop_cat)\n    (wsnd : φ.hom ≫ c'.snd = c.snd := by aesop_cat) : c ≅ c' where\n  hom := { hom := φ.hom }\n  inv :=\n    { hom := φ.inv\n      wfst := φ.inv_comp_eq.mpr wfst.symm\n      wsnd := φ.inv_comp_eq.mpr wsnd.symm\n      winl := φ.comp_inv_eq.mpr winl.symm\n      winr := φ.comp_inv_eq.mpr winr.symm }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{uD', uD} D\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).fst (F.map A.fst)","decl":"/-- A functor `F : C ⥤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q ⥤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [← F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [← F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [← F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [← F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, ← f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, ← f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, ← f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, ← f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{uD', uD} D\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).inr (F.map A.inr)","decl":"/-- A functor `F : C ⥤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q ⥤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [← F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [← F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [← F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [← F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, ← f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, ← f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, ← f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, ← f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{uD', uD} D\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).snd (F.map A.snd)","decl":"/-- A functor `F : C ⥤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q ⥤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [← F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [← F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [← F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [← F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, ← f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, ← f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, ← f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, ← f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{uD', uD} D\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Limits.BinaryBicone P Q\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).map f).hom (F.map f.hom)","decl":"/-- A functor `F : C ⥤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q ⥤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [← F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [← F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [← F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [← F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, ← f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, ← f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, ← f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, ← f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{uD', uD} D\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).inl (F.map A.inl)","decl":"/-- A functor `F : C ⥤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q ⥤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [← F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [← F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [← F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [← F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, ← f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, ← f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, ← f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, ← f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝¹ : CategoryTheory.Category.{uD', uD} D\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\nA : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq ((CategoryTheory.Limits.BinaryBicones.functoriality P Q F).obj A).pt (F.obj A.pt)","decl":"/-- A functor `F : C ⥤ D` sends binary bicones for `P` and `Q`\nto binary bicones for `G.obj P` and `G.obj Q` functorially. -/\n@[simps]\ndef functoriality : BinaryBicone P Q ⥤ BinaryBicone (F.obj P) (F.obj Q) where\n  obj A :=\n    { pt := F.obj A.pt\n      fst := F.map A.fst\n      snd := F.map A.snd\n      inl := F.map A.inl\n      inr := F.map A.inr\n      inl_fst := by rw [← F.map_comp, A.inl_fst, F.map_id]\n      inl_snd := by rw [← F.map_comp, A.inl_snd, F.map_zero]\n      inr_fst := by rw [← F.map_comp, A.inr_fst, F.map_zero]\n      inr_snd := by rw [← F.map_comp, A.inr_snd, F.map_id] }\n  map f :=\n    { hom := F.map f.hom\n      wfst := by simp [-BinaryBiconeMorphism.wfst, ← f.wfst]\n      wsnd := by simp [-BinaryBiconeMorphism.wsnd, ← f.wsnd]\n      winl := by simp [-BinaryBiconeMorphism.winl, ← f.winl]\n      winr := by simp [-BinaryBiconeMorphism.winr, ← f.winr] }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_full","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝³ : CategoryTheory.Category.{uD', uD} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ (CategoryTheory.Limits.BinaryBicones.functoriality P Q F).Full","decl":"instance functoriality_full [F.Full] [F.Faithful] : (functoriality P Q F).Full where\n  map_surjective t :=\n   ⟨{ hom := F.preimage t.hom\n      winl := F.map_injective (by simpa using t.winl)\n      winr := F.map_injective (by simpa using t.winr)\n      wfst := F.map_injective (by simpa using t.wfst)\n      wsnd := F.map_injective (by simpa using t.wsnd) }, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicones.functoriality_faithful","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type uD\ninst✝² : CategoryTheory.Category.{uD', uD} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nP Q : C\nF : CategoryTheory.Functor C D\ninst✝ : F.Faithful\n⊢ (CategoryTheory.Limits.BinaryBicones.functoriality P Q F).Faithful","decl":"instance functoriality_faithful [F.Faithful] : (functoriality P Q F).Faithful where\n  map_injective {_X} {_Y} f g h :=\n    BinaryBiconeMorphism.ext f g <| F.map_injective <| congr_arg BinaryBiconeMorphism.hom h\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq c.toCone.pt c.pt","decl":"@[simp]\ntheorem toCone_pt (c : BinaryBicone P Q) : c.toCone.pt = c.pt := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCone_π_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (c.toCone.π.app { as := CategoryTheory.Limits.WalkingPair.left }) c.fst","decl":"@[simp]\ntheorem toCone_π_app_left (c : BinaryBicone P Q) : c.toCone.π.app ⟨WalkingPair.left⟩ = c.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCone_π_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (c.toCone.π.app { as := CategoryTheory.Limits.WalkingPair.right }) c.snd","decl":"@[simp]\ntheorem toCone_π_app_right (c : BinaryBicone P Q) : c.toCone.π.app ⟨WalkingPair.right⟩ = c.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.binary_fan_fst_toCone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (CategoryTheory.Limits.BinaryFan.fst c.toCone) c.fst","decl":"@[simp]\ntheorem binary_fan_fst_toCone (c : BinaryBicone P Q) : BinaryFan.fst c.toCone = c.fst := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.binary_fan_snd_toCone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (CategoryTheory.Limits.BinaryFan.snd c.toCone) c.snd","decl":"@[simp]\ntheorem binary_fan_snd_toCone (c : BinaryBicone P Q) : BinaryFan.snd c.toCone = c.snd := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq c.toCocone.pt c.pt","decl":"@[simp]\ntheorem toCocone_pt (c : BinaryBicone P Q) : c.toCocone.pt = c.pt := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCocone_ι_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (c.toCocone.ι.app { as := CategoryTheory.Limits.WalkingPair.left }) c.inl","decl":"@[simp]\ntheorem toCocone_ι_app_left (c : BinaryBicone P Q) : c.toCocone.ι.app ⟨WalkingPair.left⟩ = c.inl :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toCocone_ι_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (c.toCocone.ι.app { as := CategoryTheory.Limits.WalkingPair.right }) c.inr","decl":"@[simp]\ntheorem toCocone_ι_app_right (c : BinaryBicone P Q) :\n    c.toCocone.ι.app ⟨WalkingPair.right⟩ = c.inr := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.binary_cofan_inl_toCocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (CategoryTheory.Limits.BinaryCofan.inl c.toCocone) c.inl","decl":"@[simp]\ntheorem binary_cofan_inl_toCocone (c : BinaryBicone P Q) : BinaryCofan.inl c.toCocone = c.inl :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.binary_cofan_inr_toCocone","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ Eq (CategoryTheory.Limits.BinaryCofan.inr c.toCocone) c.inr","decl":"@[simp]\ntheorem binary_cofan_inr_toCocone (c : BinaryBicone P Q) : BinaryCofan.inr c.toCocone = c.inr :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.instIsSplitMonoInl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ CategoryTheory.IsSplitMono c.inl","decl":"instance (c : BinaryBicone P Q) : IsSplitMono c.inl :=\n  IsSplitMono.mk'\n    { retraction := c.fst\n      id := c.inl_fst }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.instIsSplitMonoInr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ CategoryTheory.IsSplitMono c.inr","decl":"instance (c : BinaryBicone P Q) : IsSplitMono c.inr :=\n  IsSplitMono.mk'\n    { retraction := c.snd\n      id := c.inr_snd }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.instIsSplitEpiFst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ CategoryTheory.IsSplitEpi c.fst","decl":"instance (c : BinaryBicone P Q) : IsSplitEpi c.fst :=\n  IsSplitEpi.mk'\n    { section_ := c.inl\n      id := c.inl_fst }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.instIsSplitEpiSnd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nc : CategoryTheory.Limits.BinaryBicone P Q\n⊢ CategoryTheory.IsSplitEpi c.snd","decl":"instance (c : BinaryBicone P Q) : IsSplitEpi c.snd :=\n  IsSplitEpi.mk'\n    { section_ := c.inr\n      id := c.inr_snd }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toBiconeFunctor_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.toBiconeFunctor.obj b).pt b.pt","decl":"/-- Convert a `BinaryBicone` into a `Bicone` over a pair. -/\n@[simps]\ndef toBiconeFunctor {X Y : C} : BinaryBicone X Y ⥤ Bicone (pairFunction X Y) where\n  obj b :=\n    { pt := b.pt\n      π := fun j => WalkingPair.casesOn j b.fst b.snd\n      ι := fun j => WalkingPair.casesOn j b.inl b.inr\n      ι_π := fun j j' => by\n        rcases j with ⟨⟩ <;> rcases j' with ⟨⟩ <;> simp }\n  map f := {\n    hom := f.hom\n    wπ := fun i => WalkingPair.casesOn i f.wfst f.wsnd\n    wι := fun i => WalkingPair.casesOn i f.winl f.winr }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toBiconeFunctor_obj_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\nj : CategoryTheory.Limits.WalkingPair\n⊢ Eq ((CategoryTheory.Limits.BinaryBicone.toBiconeFunctor.obj b).ι j) (CategoryTheory.Limits.WalkingPair.casesOn j b.inl b.inr)","decl":"/-- Convert a `BinaryBicone` into a `Bicone` over a pair. -/\n@[simps]\ndef toBiconeFunctor {X Y : C} : BinaryBicone X Y ⥤ Bicone (pairFunction X Y) where\n  obj b :=\n    { pt := b.pt\n      π := fun j => WalkingPair.casesOn j b.fst b.snd\n      ι := fun j => WalkingPair.casesOn j b.inl b.inr\n      ι_π := fun j j' => by\n        rcases j with ⟨⟩ <;> rcases j' with ⟨⟩ <;> simp }\n  map f := {\n    hom := f.hom\n    wπ := fun i => WalkingPair.casesOn i f.wfst f.wsnd\n    wι := fun i => WalkingPair.casesOn i f.winl f.winr }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toBiconeFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nX✝ Y✝ : CategoryTheory.Limits.BinaryBicone X Y\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Limits.BinaryBicone.toBiconeFunctor.map f).hom f.hom","decl":"/-- Convert a `BinaryBicone` into a `Bicone` over a pair. -/\n@[simps]\ndef toBiconeFunctor {X Y : C} : BinaryBicone X Y ⥤ Bicone (pairFunction X Y) where\n  obj b :=\n    { pt := b.pt\n      π := fun j => WalkingPair.casesOn j b.fst b.snd\n      ι := fun j => WalkingPair.casesOn j b.inl b.inr\n      ι_π := fun j j' => by\n        rcases j with ⟨⟩ <;> rcases j' with ⟨⟩ <;> simp }\n  map f := {\n    hom := f.hom\n    wπ := fun i => WalkingPair.casesOn i f.wfst f.wsnd\n    wι := fun i => WalkingPair.casesOn i f.winl f.winr }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.toBiconeFunctor_obj_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\nj : CategoryTheory.Limits.WalkingPair\n⊢ Eq ((CategoryTheory.Limits.BinaryBicone.toBiconeFunctor.obj b).π j) (CategoryTheory.Limits.WalkingPair.casesOn j b.fst b.snd)","decl":"/-- Convert a `BinaryBicone` into a `Bicone` over a pair. -/\n@[simps]\ndef toBiconeFunctor {X Y : C} : BinaryBicone X Y ⥤ Bicone (pairFunction X Y) where\n  obj b :=\n    { pt := b.pt\n      π := fun j => WalkingPair.casesOn j b.fst b.snd\n      ι := fun j => WalkingPair.casesOn j b.inl b.inr\n      ι_π := fun j j' => by\n        rcases j with ⟨⟩ <;> rcases j' with ⟨⟩ <;> simp }\n  map f := {\n    hom := f.hom\n    wπ := fun i => WalkingPair.casesOn i f.wfst f.wsnd\n    wι := fun i => WalkingPair.casesOn i f.winl f.winr }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\n⊢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).inr (b.ι CategoryTheory.Limits.WalkingPair.right)","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) ⥤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.π WalkingPair.left\n      snd := b.π WalkingPair.right\n      inl := b.ι WalkingPair.left\n      inr := b.ι WalkingPair.right\n      inl_fst := by simp [Bicone.ι_π]\n      inr_fst := by simp [Bicone.ι_π]\n      inl_snd := by simp [Bicone.ι_π]\n      inr_snd := by simp [Bicone.ι_π] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\n⊢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).inl (b.ι CategoryTheory.Limits.WalkingPair.left)","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) ⥤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.π WalkingPair.left\n      snd := b.π WalkingPair.right\n      inl := b.ι WalkingPair.left\n      inr := b.ι WalkingPair.right\n      inl_fst := by simp [Bicone.ι_π]\n      inr_fst := by simp [Bicone.ι_π]\n      inl_snd := by simp [Bicone.ι_π]\n      inr_snd := by simp [Bicone.ι_π] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\n⊢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).snd (b.π CategoryTheory.Limits.WalkingPair.right)","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) ⥤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.π WalkingPair.left\n      snd := b.π WalkingPair.right\n      inl := b.ι WalkingPair.left\n      inr := b.ι WalkingPair.right\n      inl_fst := by simp [Bicone.ι_π]\n      inr_fst := by simp [Bicone.ι_π]\n      inl_snd := by simp [Bicone.ι_π]\n      inr_snd := by simp [Bicone.ι_π] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_map_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nX✝ Y✝ : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.map f).hom f.hom","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) ⥤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.π WalkingPair.left\n      snd := b.π WalkingPair.right\n      inl := b.ι WalkingPair.left\n      inr := b.ι WalkingPair.right\n      inl_fst := by simp [Bicone.ι_π]\n      inr_fst := by simp [Bicone.ι_π]\n      inl_snd := by simp [Bicone.ι_π]\n      inr_snd := by simp [Bicone.ι_π] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\n⊢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).pt b.pt","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) ⥤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.π WalkingPair.left\n      snd := b.π WalkingPair.right\n      inl := b.ι WalkingPair.left\n      inr := b.ι WalkingPair.right\n      inl_fst := by simp [Bicone.ι_π]\n      inr_fst := by simp [Bicone.ι_π]\n      inl_snd := by simp [Bicone.ι_π]\n      inr_snd := by simp [Bicone.ι_π] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor_obj_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nb : CategoryTheory.Limits.Bicone (CategoryTheory.Limits.pairFunction X Y)\n⊢ Eq (CategoryTheory.Limits.Bicone.toBinaryBiconeFunctor.obj b).fst (b.π CategoryTheory.Limits.WalkingPair.left)","decl":"/-- Convert a `Bicone` over a function on `WalkingPair` to a BinaryBicone. -/\n@[simps]\ndef toBinaryBiconeFunctor {X Y : C} : Bicone (pairFunction X Y) ⥤ BinaryBicone X Y where\n  obj b :=\n    { pt := b.pt\n      fst := b.π WalkingPair.left\n      snd := b.π WalkingPair.right\n      inl := b.ι WalkingPair.left\n      inr := b.ι WalkingPair.right\n      inl_fst := by simp [Bicone.ι_π]\n      inr_fst := by simp [Bicone.ι_π]\n      inl_snd := by simp [Bicone.ι_π]\n      inr_snd := by simp [Bicone.ι_π] }\n  map f :=\n    { hom := f.hom }\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.IsBilimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nb : CategoryTheory.Limits.BinaryBicone P Q\nisLimit✝ : CategoryTheory.Limits.IsLimit b.toCone\nisColimit✝ : CategoryTheory.Limits.IsColimit b.toCocone\nisLimit : CategoryTheory.Limits.IsLimit b.toCone\nisColimit : CategoryTheory.Limits.IsColimit b.toCocone\nx✝ : Eq { isLimit := isLimit✝, isColimit := isColimit✝ } { isLimit := isLimit, isColimit := isColimit }\n⊢ And (Eq isLimit✝ isLimit) (Eq isColimit✝ isColimit)","decl":"/-- Structure witnessing that a binary bicone is a limit cone and a limit cocone. -/\nstructure BinaryBicone.IsBilimit {P Q : C} (b : BinaryBicone P Q) where\n  isLimit : IsLimit b.toCone\n  isColimit : IsColimit b.toCocone\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.IsBilimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nb : CategoryTheory.Limits.BinaryBicone P Q\ninst✝ : SizeOf C\nisLimit : CategoryTheory.Limits.IsLimit b.toCone\nisColimit : CategoryTheory.Limits.IsColimit b.toCocone\n⊢ Eq (SizeOf.sizeOf { isLimit := isLimit, isColimit := isColimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf isLimit)) (SizeOf.sizeOf isColimit))","decl":"/-- Structure witnessing that a binary bicone is a limit cone and a limit cocone. -/\nstructure BinaryBicone.IsBilimit {P Q : C} (b : BinaryBicone P Q) where\n  isLimit : IsLimit b.toCone\n  isColimit : IsColimit b.toCocone\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.IsBilimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nb : CategoryTheory.Limits.BinaryBicone P Q\nisLimit✝ : CategoryTheory.Limits.IsLimit b.toCone\nisColimit✝ : CategoryTheory.Limits.IsColimit b.toCocone\nisLimit : CategoryTheory.Limits.IsLimit b.toCone\nisColimit : CategoryTheory.Limits.IsColimit b.toCocone\n⊢ Eq (Eq { isLimit := isLimit✝, isColimit := isColimit✝ } { isLimit := isLimit, isColimit := isColimit }) (And (Eq isLimit✝ isLimit) (Eq isColimit✝ isColimit))","decl":"/-- Structure witnessing that a binary bicone is a limit cone and a limit cocone. -/\nstructure BinaryBicone.IsBilimit {P Q : C} (b : BinaryBicone P Q) where\n  isLimit : IsLimit b.toCone\n  isColimit : IsColimit b.toCocone\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproductData.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nbicone✝ : CategoryTheory.Limits.BinaryBicone P Q\nisBilimit✝ : bicone✝.IsBilimit\nbicone : CategoryTheory.Limits.BinaryBicone P Q\nisBilimit : bicone.IsBilimit\n⊢ Eq (Eq { bicone := bicone✝, isBilimit := isBilimit✝ } { bicone := bicone, isBilimit := isBilimit }) (And (Eq bicone✝ bicone) (HEq isBilimit✝ isBilimit))","decl":"/-- A bicone over `P Q : C`, which is both a limit cone and a colimit cocone.\n-/\nstructure BinaryBiproductData (P Q : C) where\n  bicone : BinaryBicone P Q\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproductData.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nbicone✝ : CategoryTheory.Limits.BinaryBicone P Q\nisBilimit✝ : bicone✝.IsBilimit\nbicone : CategoryTheory.Limits.BinaryBicone P Q\nisBilimit : bicone.IsBilimit\nx✝ : Eq { bicone := bicone✝, isBilimit := isBilimit✝ } { bicone := bicone, isBilimit := isBilimit }\n⊢ And (Eq bicone✝ bicone) (HEq isBilimit✝ isBilimit)","decl":"/-- A bicone over `P Q : C`, which is both a limit cone and a colimit cocone.\n-/\nstructure BinaryBiproductData (P Q : C) where\n  bicone : BinaryBicone P Q\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproductData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\ninst✝ : SizeOf C\nbicone : CategoryTheory.Limits.BinaryBicone P Q\nisBilimit : bicone.IsBilimit\n⊢ Eq (SizeOf.sizeOf { bicone := bicone, isBilimit := isBilimit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf bicone)) (SizeOf.sizeOf isBilimit))","decl":"/-- A bicone over `P Q : C`, which is both a limit cone and a colimit cocone.\n-/\nstructure BinaryBiproductData (P Q : C) where\n  bicone : BinaryBicone P Q\n  isBilimit : bicone.IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.exists_binary_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nself : CategoryTheory.Limits.HasBinaryBiproduct P Q\n⊢ Nonempty (CategoryTheory.Limits.BinaryBiproductData P Q)","decl":"/-- `HasBinaryBiproduct P Q` expresses the mere existence of a bicone which is\nsimultaneously a limit and a colimit of the diagram `pair P Q`.\n-/\nclass HasBinaryBiproduct (P Q : C) : Prop where mk' ::\n  exists_binary_biproduct : Nonempty (BinaryBiproductData P Q)\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.mk","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\nd : CategoryTheory.Limits.BinaryBiproductData P Q\n⊢ CategoryTheory.Limits.HasBinaryBiproduct P Q","decl":"theorem HasBinaryBiproduct.mk {P Q : C} (d : BinaryBiproductData P Q) : HasBinaryBiproduct P Q :=\n  ⟨Nonempty.intro d⟩\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproducts.has_binary_biproduct","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\n⊢ CategoryTheory.Limits.HasBinaryBiproduct P Q","decl":"/-- `HasBinaryBiproducts C` represents the existence of a bicone which is\nsimultaneously a limit and a colimit of the diagram `pair P Q`, for every `P Q : C`.\n-/\nclass HasBinaryBiproducts : Prop where\n  has_binary_biproduct : ∀ P Q : C, HasBinaryBiproduct P Q\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryBiproducts_of_finite_biproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\n⊢ CategoryTheory.Limits.HasBinaryBiproducts C","decl":"/-- A category with finite biproducts has binary biproducts.\n\nThis is not an instance as typically in concrete categories there will be\nan alternative construction with nicer definitional properties.\n-/\ntheorem hasBinaryBiproducts_of_finite_biproducts [HasFiniteBiproducts C] : HasBinaryBiproducts C :=\n  { has_binary_biproduct := fun P Q =>\n      HasBinaryBiproduct.mk\n        { bicone := (biproduct.bicone (pairFunction P Q)).toBinaryBicone\n          isBilimit := (Bicone.toBinaryBiconeIsBilimit _).symm (biproduct.isBilimit _) } }\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.hasLimit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct P Q\n⊢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair P Q)","decl":"instance HasBinaryBiproduct.hasLimit_pair [HasBinaryBiproduct P Q] : HasLimit (pair P Q) :=\n  HasLimit.mk ⟨_, BinaryBiproduct.isLimit P Q⟩\n\n"}
{"name":"CategoryTheory.Limits.HasBinaryBiproduct.hasColimit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nP Q : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct P Q\n⊢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair P Q)","decl":"instance HasBinaryBiproduct.hasColimit_pair [HasBinaryBiproduct P Q] : HasColimit (pair P Q) :=\n  HasColimit.mk ⟨_, BinaryBiproduct.isColimit P Q⟩\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryProducts_of_hasBinaryBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ CategoryTheory.Limits.HasBinaryProducts C","decl":"instance (priority := 100) hasBinaryProducts_of_hasBinaryBiproducts [HasBinaryBiproducts C] :\n    HasBinaryProducts C where\n  has_limit F := hasLimitOfIso (diagramIsoPair F).symm\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryCoproducts_of_hasBinaryBiproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ CategoryTheory.Limits.HasBinaryCoproducts C","decl":"instance (priority := 100) hasBinaryCoproducts_of_hasBinaryBiproducts [HasBinaryBiproducts C] :\n    HasBinaryCoproducts C where\n  has_colimit F := hasColimitOfIso (diagramIsoPair F)\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproduct.bicone_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).fst CategoryTheory.Limits.biprod.fst","decl":"@[simp]\ntheorem BinaryBiproduct.bicone_fst : (BinaryBiproduct.bicone X Y).fst = biprod.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproduct.bicone_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).snd CategoryTheory.Limits.biprod.snd","decl":"@[simp]\ntheorem BinaryBiproduct.bicone_snd : (BinaryBiproduct.bicone X Y).snd = biprod.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproduct.bicone_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inl CategoryTheory.Limits.biprod.inl","decl":"@[simp]\ntheorem BinaryBiproduct.bicone_inl : (BinaryBiproduct.bicone X Y).inl = biprod.inl :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBiproduct.bicone_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.BinaryBiproduct.bicone X Y).inr CategoryTheory.Limits.biprod.inr","decl":"@[simp]\ntheorem BinaryBiproduct.bicone_inr : (BinaryBiproduct.bicone X Y).inr = biprod.inr :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) h","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inl_fst {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inl : X ⟶ X ⊞ Y) ≫ (biprod.fst : X ⊞ Y ⟶ X) = 𝟙 X :=\n  (BinaryBiproduct.bicone X Y).inl_fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inl_fst {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inl : X ⟶ X ⊞ Y) ≫ (biprod.fst : X ⊞ Y ⟶ X) = 𝟙 X :=\n  (BinaryBiproduct.bicone X Y).inl_fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inl_snd {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inl : X ⟶ X ⊞ Y) ≫ (biprod.snd : X ⊞ Y ⟶ Y) = 0 :=\n  (BinaryBiproduct.bicone X Y).inl_snd\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.snd) 0","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inl_snd {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inl : X ⟶ X ⊞ Y) ≫ (biprod.snd : X ⊞ Y ⟶ Y) = 0 :=\n  (BinaryBiproduct.bicone X Y).inl_snd\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inr_fst {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inr : Y ⟶ X ⊞ Y) ≫ (biprod.fst : X ⊞ Y ⟶ X) = 0 :=\n  (BinaryBiproduct.bicone X Y).inr_fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.fst) 0","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inr_fst {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inr : Y ⟶ X ⊞ Y) ≫ (biprod.fst : X ⊞ Y ⟶ X) = 0 :=\n  (BinaryBiproduct.bicone X Y).inr_fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.snd) (CategoryTheory.CategoryStruct.id Y)","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inr_snd {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inr : Y ⟶ X ⊞ Y) ≫ (biprod.snd : X ⊞ Y ⟶ Y) = 𝟙 Y :=\n  (BinaryBiproduct.bicone X Y).inr_snd\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) h","decl":"@[reassoc] -- Porting note: simp can solve both versions\ntheorem biprod.inr_snd {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.inr : Y ⟶ X ⊞ Y) ≫ (biprod.snd : X ⊞ Y ⟶ Y) = 𝟙 Y :=\n  (BinaryBiproduct.bicone X Y).inr_snd\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) CategoryTheory.Limits.biprod.fst) f","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_fst {W X Y : C} [HasBinaryBiproduct X Y] (f : W ⟶ X) (g : W ⟶ Y) :\n    biprod.lift f g ≫ biprod.fst = f :=\n  (BinaryBiproduct.isLimit X Y).fac _ ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_fst {W X Y : C} [HasBinaryBiproduct X Y] (f : W ⟶ X) (g : W ⟶ Y) :\n    biprod.lift f g ≫ biprod.fst = f :=\n  (BinaryBiproduct.isLimit X Y).fac _ ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_snd {W X Y : C} [HasBinaryBiproduct X Y] (f : W ⟶ X) (g : W ⟶ Y) :\n    biprod.lift f g ≫ biprod.snd = g :=\n  (BinaryBiproduct.isLimit X Y).fac _ ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g) CategoryTheory.Limits.biprod.snd) g","decl":"@[reassoc (attr := simp)]\ntheorem biprod.lift_snd {W X Y : C} [HasBinaryBiproduct X Y] (f : W ⟶ X) (g : W ⟶ Y) :\n    biprod.lift f g ≫ biprod.snd = g :=\n  (BinaryBiproduct.isLimit X Y).fac _ ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.Limits.biprod.desc f g)) f","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inl_desc {W X Y : C} [HasBinaryBiproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) :\n    biprod.inl ≫ biprod.desc f g = f :=\n  (BinaryBiproduct.isColimit X Y).fac _ ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inl_desc {W X Y : C} [HasBinaryBiproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) :\n    biprod.inl ≫ biprod.desc f g = f :=\n  (BinaryBiproduct.isColimit X Y).fac _ ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inr_desc {W X Y : C} [HasBinaryBiproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) :\n    biprod.inr ≫ biprod.desc f g = g :=\n  (BinaryBiproduct.isColimit X Y).fac _ ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.Limits.biprod.desc f g)) g","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inr_desc {W X Y : C} [HasBinaryBiproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) :\n    biprod.inr ≫ biprod.desc f g = g :=\n  (BinaryBiproduct.isColimit X Y).fac _ ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.mono_lift_of_mono_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.biprod.lift f g)","decl":"instance biprod.mono_lift_of_mono_left {W X Y : C} [HasBinaryBiproduct X Y] (f : W ⟶ X) (g : W ⟶ Y)\n    [Mono f] : Mono (biprod.lift f g) :=\n  mono_of_mono_fac <| biprod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.biprod.mono_lift_of_mono_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝ : CategoryTheory.Mono g\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.biprod.lift f g)","decl":"instance biprod.mono_lift_of_mono_right {W X Y : C} [HasBinaryBiproduct X Y] (f : W ⟶ X) (g : W ⟶ Y)\n    [Mono g] : Mono (biprod.lift f g) :=\n  mono_of_mono_fac <| biprod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.biprod.epi_desc_of_epi_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.biprod.desc f g)","decl":"instance biprod.epi_desc_of_epi_left {W X Y : C} [HasBinaryBiproduct X Y] (f : X ⟶ W) (g : Y ⟶ W)\n    [Epi f] : Epi (biprod.desc f g) :=\n  epi_of_epi_fac <| biprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.biprod.epi_desc_of_epi_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ninst✝ : CategoryTheory.Epi g\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.biprod.desc f g)","decl":"instance biprod.epi_desc_of_epi_right {W X Y : C} [HasBinaryBiproduct X Y] (f : X ⟶ W) (g : Y ⟶ W)\n    [Epi g] : Epi (biprod.desc f g) :=\n  epi_of_epi_fac <| biprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.biprod.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf g : Quiver.Hom Z (CategoryTheory.Limits.biprod X Y)\nh₀ : Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.fst)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.snd)\n⊢ Eq f g","decl":"@[ext]\ntheorem biprod.hom_ext {X Y Z : C} [HasBinaryBiproduct X Y] (f g : Z ⟶ X ⊞ Y)\n    (h₀ : f ≫ biprod.fst = g ≫ biprod.fst) (h₁ : f ≫ biprod.snd = g ≫ biprod.snd) : f = g :=\n  BinaryFan.IsLimit.hom_ext (BinaryBiproduct.isLimit X Y) h₀ h₁\n\n"}
{"name":"CategoryTheory.Limits.biprod.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf g : Quiver.Hom Z (CategoryTheory.Limits.biprod X Y)\n⊢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.fst)) (Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.snd)))","decl":"@[ext]\ntheorem biprod.hom_ext {X Y Z : C} [HasBinaryBiproduct X Y] (f g : Z ⟶ X ⊞ Y)\n    (h₀ : f ≫ biprod.fst = g ≫ biprod.fst) (h₁ : f ≫ biprod.snd = g ≫ biprod.snd) : f = g :=\n  BinaryFan.IsLimit.hom_ext (BinaryBiproduct.isLimit X Y) h₀ h₁\n\n"}
{"name":"CategoryTheory.Limits.biprod.hom_ext'_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf g : Quiver.Hom (CategoryTheory.Limits.biprod X Y) Z\n⊢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl g)) (Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr g)))","decl":"@[ext]\ntheorem biprod.hom_ext' {X Y Z : C} [HasBinaryBiproduct X Y] (f g : X ⊞ Y ⟶ Z)\n    (h₀ : biprod.inl ≫ f = biprod.inl ≫ g) (h₁ : biprod.inr ≫ f = biprod.inr ≫ g) : f = g :=\n  BinaryCofan.IsColimit.hom_ext (BinaryBiproduct.isColimit X Y) h₀ h₁\n\n"}
{"name":"CategoryTheory.Limits.biprod.hom_ext'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nf g : Quiver.Hom (CategoryTheory.Limits.biprod X Y) Z\nh₀ : Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl g)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr g)\n⊢ Eq f g","decl":"@[ext]\ntheorem biprod.hom_ext' {X Y Z : C} [HasBinaryBiproduct X Y] (f g : X ⊞ Y ⟶ Z)\n    (h₀ : biprod.inl ≫ f = biprod.inl ≫ g) (h₁ : biprod.inr ≫ f = biprod.inr ≫ g) : f = g :=\n  BinaryCofan.IsColimit.hom_ext (BinaryBiproduct.isColimit X Y) h₀ h₁\n\n"}
{"name":"CategoryTheory.Limits.biprod.isoProd_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.biprod.isoProd X Y).hom (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.snd)","decl":"@[simp]\ntheorem biprod.isoProd_hom {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.isoProd X Y).hom = prod.lift biprod.fst biprod.snd := by\n      ext <;> simp [biprod.isoProd]\n\n"}
{"name":"CategoryTheory.Limits.biprod.isoProd_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.biprod.isoProd X Y).inv (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd)","decl":"@[simp]\ntheorem biprod.isoProd_inv {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.isoProd X Y).inv = biprod.lift prod.fst prod.snd := by\n  ext <;> simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.biprod.isoCoprod_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.biprod.isoCoprod X Y).inv (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.inr)","decl":"@[simp]\ntheorem biprod.isoCoprod_inv {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.isoCoprod X Y).inv = coprod.desc biprod.inl biprod.inr := by\n  ext <;> simp [biprod.isoCoprod]\n\n"}
{"name":"CategoryTheory.Limits.biprod_isoCoprod_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.biprod.isoCoprod X Y).hom (CategoryTheory.Limits.biprod.desc CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr)","decl":"@[simp]\ntheorem biprod_isoCoprod_hom {X Y : C} [HasBinaryBiproduct X Y] :\n    (biprod.isoCoprod X Y).hom = biprod.desc coprod.inl coprod.inr := by\n  ext <;> simp [← Iso.eq_comp_inv]\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_eq_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.Limits.biprod.map' f g)","decl":"theorem biprod.map_eq_map' {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z]\n    (f : W ⟶ Y) (g : X ⟶ Z) : biprod.map f g = biprod.map' f g := by\n  ext\n  · simp only [mapPair_left, IsColimit.ι_map, IsLimit.map_π, biprod.inl_fst_assoc,\n      Category.assoc, ← BinaryBicone.toCone_π_app_left, ← BinaryBiproduct.bicone_fst, ←\n      BinaryBicone.toCocone_ι_app_left, ← BinaryBiproduct.bicone_inl]\n    dsimp; simp\n  · simp only [mapPair_left, IsColimit.ι_map, IsLimit.map_π, zero_comp, biprod.inl_snd_assoc,\n      Category.assoc, ← BinaryBicone.toCone_π_app_right, ← BinaryBiproduct.bicone_snd, ←\n      BinaryBicone.toCocone_ι_app_left, ← BinaryBiproduct.bicone_inl]\n    simp\n  · simp only [mapPair_right, biprod.inr_fst_assoc, IsColimit.ι_map, IsLimit.map_π, zero_comp,\n      Category.assoc, ← BinaryBicone.toCone_π_app_left, ← BinaryBiproduct.bicone_fst, ←\n      BinaryBicone.toCocone_ι_app_right, ← BinaryBiproduct.bicone_inr]\n    simp\n  · simp only [mapPair_right, IsColimit.ι_map, IsLimit.map_π, biprod.inr_snd_assoc,\n      Category.assoc, ← BinaryBicone.toCone_π_app_right, ← BinaryBiproduct.bicone_snd, ←\n      BinaryBicone.toCocone_ι_app_right, ← BinaryBiproduct.bicone_inr]\n    simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsSplitMono CategoryTheory.Limits.biprod.inl","decl":"instance biprod.inl_mono {X Y : C} [HasBinaryBiproduct X Y] :\n    IsSplitMono (biprod.inl : X ⟶ X ⊞ Y) :=\n  IsSplitMono.mk' { retraction := biprod.fst }\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsSplitMono CategoryTheory.Limits.biprod.inr","decl":"instance biprod.inr_mono {X Y : C} [HasBinaryBiproduct X Y] :\n    IsSplitMono (biprod.inr : Y ⟶ X ⊞ Y) :=\n  IsSplitMono.mk' { retraction := biprod.snd }\n\n"}
{"name":"CategoryTheory.Limits.biprod.fst_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsSplitEpi CategoryTheory.Limits.biprod.fst","decl":"instance biprod.fst_epi {X Y : C} [HasBinaryBiproduct X Y] : IsSplitEpi (biprod.fst : X ⊞ Y ⟶ X) :=\n  IsSplitEpi.mk' { section_ := biprod.inl }\n\n"}
{"name":"CategoryTheory.Limits.biprod.snd_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.IsSplitEpi CategoryTheory.Limits.biprod.snd","decl":"instance biprod.snd_epi {X Y : C} [HasBinaryBiproduct X Y] : IsSplitEpi (biprod.snd : X ⊞ Y ⟶ Y) :=\n  IsSplitEpi.mk' { section_ := biprod.inr }\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst f)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.map_fst {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : biprod.map f g ≫ biprod.fst = biprod.fst ≫ f :=\n  IsLimit.map_π _ _ _ (⟨WalkingPair.left⟩ : Discrete WalkingPair)\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z✝ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z✝\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.map_fst {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : biprod.map f g ≫ biprod.fst = biprod.fst ≫ f :=\n  IsLimit.map_π _ _ _ (⟨WalkingPair.left⟩ : Discrete WalkingPair)\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) CategoryTheory.Limits.biprod.snd) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd g)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.map_snd {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : biprod.map f g ≫ biprod.snd = biprod.snd ≫ g :=\n  IsLimit.map_π _ _ _ (⟨WalkingPair.right⟩ : Discrete WalkingPair)\n\n-- Because `biprod.map` is defined in terms of `lim` rather than `colim`,\n-- we need to provide additional `simp` lemmas.\n"}
{"name":"CategoryTheory.Limits.biprod.map_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z✝ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z✝\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.map_snd {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : biprod.map f g ≫ biprod.snd = biprod.snd ≫ g :=\n  IsLimit.map_π _ _ _ (⟨WalkingPair.right⟩ : Discrete WalkingPair)\n\n-- Because `biprod.map` is defined in terms of `lim` rather than `colim`,\n-- we need to provide additional `simp` lemmas.\n"}
{"name":"CategoryTheory.Limits.biprod.inl_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.Limits.biprod.map f g)) (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.inl)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inl_map {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : biprod.inl ≫ biprod.map f g = f ≫ biprod.inl := by\n  rw [biprod.map_eq_map']\n  exact IsColimit.ι_map (BinaryBiproduct.isColimit W X) _ _ ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.inl_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z✝ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z✝\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod Y Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl h))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inl_map {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : biprod.inl ≫ biprod.map f g = f ≫ biprod.inl := by\n  rw [biprod.map_eq_map']\n  exact IsColimit.ι_map (BinaryBiproduct.isColimit W X) _ _ ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z✝ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z✝\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod Y Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr h))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inr_map {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : biprod.inr ≫ biprod.map f g = g ≫ biprod.inr := by\n  rw [biprod.map_eq_map']\n  exact IsColimit.ι_map (BinaryBiproduct.isColimit W X) _ _ ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.inr_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.Limits.biprod.map f g)) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.inr)","decl":"@[reassoc (attr := simp)]\ntheorem biprod.inr_map {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : biprod.inr ≫ biprod.map f g = g ≫ biprod.inr := by\n  rw [biprod.map_eq_map']\n  exact IsColimit.ι_map (BinaryBiproduct.isColimit W X) _ _ ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n⊢ Eq (CategoryTheory.Limits.biprod.mapIso f g).hom (CategoryTheory.Limits.biprod.map f.hom g.hom)","decl":"/-- Given a pair of isomorphisms between the summands of a pair of binary biproducts,\nwe obtain an isomorphism between the binary biproducts. -/\n@[simps]\ndef biprod.mapIso {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ≅ Y)\n    (g : X ≅ Z) : W ⊞ X ≅ Y ⊞ Z where\n  hom := biprod.map f.hom g.hom\n  inv := biprod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.biprod.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n⊢ Eq (CategoryTheory.Limits.biprod.mapIso f g).inv (CategoryTheory.Limits.biprod.map f.inv g.inv)","decl":"/-- Given a pair of isomorphisms between the summands of a pair of binary biproducts,\nwe obtain an isomorphism between the binary biproducts. -/\n@[simps]\ndef biprod.mapIso {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W ≅ Y)\n    (g : X ≅ Z) : W ⊞ X ≅ Y ⊞ Z where\n  hom := biprod.map f.hom g.hom\n  inv := biprod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.biprod.conePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nb : CategoryTheory.Limits.BinaryBicone X Y\nhb : b.IsBilimit\n⊢ Eq (hb.isLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).hom (CategoryTheory.Limits.biprod.lift b.fst b.snd)","decl":"/-- Auxiliary lemma for `biprod.uniqueUpToIso`. -/\ntheorem biprod.conePointUniqueUpToIso_hom (X Y : C) [HasBinaryBiproduct X Y] {b : BinaryBicone X Y}\n    (hb : b.IsBilimit) :\n    (hb.isLimit.conePointUniqueUpToIso (BinaryBiproduct.isLimit _ _)).hom =\n      biprod.lift b.fst b.snd := rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nb : CategoryTheory.Limits.BinaryBicone X Y\nhb : b.IsBilimit\n⊢ Eq (hb.isLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).inv (CategoryTheory.Limits.biprod.desc b.inl b.inr)","decl":"/-- Auxiliary lemma for `biprod.uniqueUpToIso`. -/\ntheorem biprod.conePointUniqueUpToIso_inv (X Y : C) [HasBinaryBiproduct X Y] {b : BinaryBicone X Y}\n    (hb : b.IsBilimit) :\n    (hb.isLimit.conePointUniqueUpToIso (BinaryBiproduct.isLimit _ _)).inv =\n      biprod.desc b.inl b.inr := by\n  refine biprod.hom_ext' _ _ (hb.isLimit.hom_ext fun j => ?_) (hb.isLimit.hom_ext fun j => ?_)\n  all_goals\n    simp only [Category.assoc, IsLimit.conePointUniqueUpToIso_inv_comp]\n    rcases j with ⟨⟨⟩⟩\n  all_goals simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nb : CategoryTheory.Limits.BinaryBicone X Y\nhb : b.IsBilimit\n⊢ Eq (CategoryTheory.Limits.biprod.uniqueUpToIso X Y hb).hom (CategoryTheory.Limits.biprod.lift b.fst b.snd)","decl":"/-- Binary biproducts are unique up to isomorphism. This already follows because bilimits are\n    limits, but in the case of biproducts we can give an isomorphism with particularly nice\n    definitional properties, namely that `biprod.lift b.fst b.snd` and `biprod.desc b.inl b.inr`\n    are inverses of each other. -/\n@[simps]\ndef biprod.uniqueUpToIso (X Y : C) [HasBinaryBiproduct X Y] {b : BinaryBicone X Y}\n    (hb : b.IsBilimit) : b.pt ≅ X ⊞ Y where\n  hom := biprod.lift b.fst b.snd\n  inv := biprod.desc b.inl b.inr\n  hom_inv_id := by\n    rw [← biprod.conePointUniqueUpToIso_hom X Y hb, ←\n      biprod.conePointUniqueUpToIso_inv X Y hb, Iso.hom_inv_id]\n  inv_hom_id := by\n    rw [← biprod.conePointUniqueUpToIso_hom X Y hb, ←\n      biprod.conePointUniqueUpToIso_inv X Y hb, Iso.inv_hom_id]\n\n-- There are three further variations,\n-- about `IsIso biprod.inr`, `IsIso biprod.fst` and `IsIso biprod.snd`,\n-- but any one suffices to prove `indecomposable_of_simple`\n-- and they are likely not separately useful.\n"}
{"name":"CategoryTheory.Limits.biprod.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nb : CategoryTheory.Limits.BinaryBicone X Y\nhb : b.IsBilimit\n⊢ Eq (CategoryTheory.Limits.biprod.uniqueUpToIso X Y hb).inv (CategoryTheory.Limits.biprod.desc b.inl b.inr)","decl":"/-- Binary biproducts are unique up to isomorphism. This already follows because bilimits are\n    limits, but in the case of biproducts we can give an isomorphism with particularly nice\n    definitional properties, namely that `biprod.lift b.fst b.snd` and `biprod.desc b.inl b.inr`\n    are inverses of each other. -/\n@[simps]\ndef biprod.uniqueUpToIso (X Y : C) [HasBinaryBiproduct X Y] {b : BinaryBicone X Y}\n    (hb : b.IsBilimit) : b.pt ≅ X ⊞ Y where\n  hom := biprod.lift b.fst b.snd\n  inv := biprod.desc b.inl b.inr\n  hom_inv_id := by\n    rw [← biprod.conePointUniqueUpToIso_hom X Y hb, ←\n      biprod.conePointUniqueUpToIso_inv X Y hb, Iso.hom_inv_id]\n  inv_hom_id := by\n    rw [← biprod.conePointUniqueUpToIso_hom X Y hb, ←\n      biprod.conePointUniqueUpToIso_inv X Y hb, Iso.inv_hom_id]\n\n-- There are three further variations,\n-- about `IsIso biprod.inr`, `IsIso biprod.fst` and `IsIso biprod.snd`,\n-- but any one suffices to prove `indecomposable_of_simple`\n-- and they are likely not separately useful.\n"}
{"name":"CategoryTheory.Limits.biprod.isIso_inl_iff_id_eq_fst_comp_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Iff (CategoryTheory.IsIso CategoryTheory.Limits.biprod.inl) (Eq (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod X Y)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.inl))","decl":"theorem biprod.isIso_inl_iff_id_eq_fst_comp_inl (X Y : C) [HasBinaryBiproduct X Y] :\n    IsIso (biprod.inl : X ⟶ X ⊞ Y) ↔ 𝟙 (X ⊞ Y) = biprod.fst ≫ biprod.inl := by\n  constructor\n  · intro h\n    have := (cancel_epi (inv biprod.inl : X ⊞ Y ⟶ X)).2 <| @biprod.inl_fst _ _ _ X Y _\n    rw [IsIso.inv_hom_id_assoc, Category.comp_id] at this\n    rw [this, IsIso.inv_hom_id]\n  · intro h\n    exact ⟨⟨biprod.fst, biprod.inl_fst, h.symm⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝³ : CategoryTheory.Epi f\ninst✝² : CategoryTheory.Epi g\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.biprod.map f g)","decl":"instance biprod.map_epi {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [Epi f]\n    [Epi g] [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] : Epi (biprod.map f g) := by\n  rw [show biprod.map f g =\n    (biprod.isoCoprod _ _).hom ≫ coprod.map f g ≫ (biprod.isoCoprod _ _).inv by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.prod.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝³ : CategoryTheory.Epi f\ninst✝² : CategoryTheory.Epi g\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.prod.map f g)","decl":"instance prod.map_epi {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [Epi f]\n    [Epi g] [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] : Epi (prod.map f g) := by\n  rw [show prod.map f g = (biprod.isoProd _ _).inv ≫ biprod.map f g ≫\n    (biprod.isoProd _ _).hom by simp]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝³ : CategoryTheory.Mono f\ninst✝² : CategoryTheory.Mono g\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.biprod.map f g)","decl":"instance biprod.map_mono {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [Mono f]\n    [Mono g] [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] : Mono (biprod.map f g) := by\n  rw [show biprod.map f g = (biprod.isoProd _ _).hom ≫ prod.map f g ≫\n    (biprod.isoProd _ _).inv by aesop]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝³ : CategoryTheory.Mono f\ninst✝² : CategoryTheory.Mono g\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct Y Z\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.coprod.map f g)","decl":"instance coprod.map_mono {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [Mono f]\n    [Mono g] [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] : Mono (coprod.map f g) := by\n  rw [show coprod.map f g = (biprod.isoCoprod _ _).inv ≫ biprod.map f g ≫\n    (biprod.isoCoprod _ _).hom by simp]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.fstKernelFork_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nc : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (CategoryTheory.Limits.Fork.ι c.fstKernelFork) c.inr","decl":"@[simp]\ntheorem BinaryBicone.fstKernelFork_ι : (BinaryBicone.fstKernelFork c).ι = c.inr := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.sndKernelFork_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nc : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (CategoryTheory.Limits.Fork.ι c.sndKernelFork) c.inl","decl":"@[simp]\ntheorem BinaryBicone.sndKernelFork_ι : (BinaryBicone.sndKernelFork c).ι = c.inl := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inlCokernelCofork_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nc : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (CategoryTheory.Limits.Cofork.π c.inlCokernelCofork) c.snd","decl":"@[simp]\ntheorem BinaryBicone.inlCokernelCofork_π : (BinaryBicone.inlCokernelCofork c).π = c.snd := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryBicone.inrCokernelCofork_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nc : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (CategoryTheory.Limits.Cofork.π c.inrCokernelCofork) c.fst","decl":"@[simp]\ntheorem BinaryBicone.inrCokernelCofork_π : (BinaryBicone.inrCokernelCofork c).π = c.fst := rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.fstKernelFork_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.Fork.ι (CategoryTheory.Limits.biprod.fstKernelFork X Y)) CategoryTheory.Limits.biprod.inr","decl":"@[simp]\ntheorem biprod.fstKernelFork_ι : Fork.ι (biprod.fstKernelFork X Y) = (biprod.inr : Y ⟶ X ⊞ Y) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.sndKernelFork_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.Fork.ι (CategoryTheory.Limits.biprod.sndKernelFork X Y)) CategoryTheory.Limits.biprod.inl","decl":"@[simp]\ntheorem biprod.sndKernelFork_ι : Fork.ι (biprod.sndKernelFork X Y) = (biprod.inl : X ⟶ X ⊞ Y) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.inlCokernelCofork_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.Cofork.π (CategoryTheory.Limits.biprod.inlCokernelCofork X Y)) CategoryTheory.Limits.biprod.snd","decl":"@[simp]\ntheorem biprod.inlCokernelCofork_π : Cofork.π (biprod.inlCokernelCofork X Y) = biprod.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biprod.inrCokernelCofork_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq (CategoryTheory.Limits.Cofork.π (CategoryTheory.Limits.biprod.inrCokernelCofork X Y)) CategoryTheory.Limits.biprod.fst","decl":"@[simp]\ntheorem biprod.inrCokernelCofork_π : Cofork.π (biprod.inrCokernelCofork X Y) = biprod.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.instHasKernelFst","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.Limits.HasKernel CategoryTheory.Limits.biprod.fst","decl":"instance : HasKernel (biprod.fst : X ⊞ Y ⟶ X) :=\n  HasLimit.mk ⟨_, biprod.isKernelFstKernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.kernelBiprodFstIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq CategoryTheory.Limits.kernelBiprodFstIso.hom ((CategoryTheory.Limits.biprod.isKernelFstKernelFork X Y).lift (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.fst 0)))","decl":"/-- The kernel of `biprod.fst : X ⊞ Y ⟶ X` is `Y`. -/\n@[simps!]\ndef kernelBiprodFstIso : kernel (biprod.fst : X ⊞ Y ⟶ X) ≅ Y :=\n  limit.isoLimitCone ⟨_, biprod.isKernelFstKernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.kernelBiprodFstIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq CategoryTheory.Limits.kernelBiprodFstIso.inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.fst 0) (CategoryTheory.Limits.biprod.fstKernelFork X Y))","decl":"/-- The kernel of `biprod.fst : X ⊞ Y ⟶ X` is `Y`. -/\n@[simps!]\ndef kernelBiprodFstIso : kernel (biprod.fst : X ⊞ Y ⟶ X) ≅ Y :=\n  limit.isoLimitCone ⟨_, biprod.isKernelFstKernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.instHasKernelSnd","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.Limits.HasKernel CategoryTheory.Limits.biprod.snd","decl":"instance : HasKernel (biprod.snd : X ⊞ Y ⟶ Y) :=\n  HasLimit.mk ⟨_, biprod.isKernelSndKernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.kernelBiprodSndIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq CategoryTheory.Limits.kernelBiprodSndIso.hom ((CategoryTheory.Limits.biprod.isKernelSndKernelFork X Y).lift (CategoryTheory.Limits.limit.cone (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.snd 0)))","decl":"/-- The kernel of `biprod.snd : X ⊞ Y ⟶ Y` is `X`. -/\n@[simps!]\ndef kernelBiprodSndIso : kernel (biprod.snd : X ⊞ Y ⟶ Y) ≅ X :=\n  limit.isoLimitCone ⟨_, biprod.isKernelSndKernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.kernelBiprodSndIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq CategoryTheory.Limits.kernelBiprodSndIso.inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.snd 0) (CategoryTheory.Limits.biprod.sndKernelFork X Y))","decl":"/-- The kernel of `biprod.snd : X ⊞ Y ⟶ Y` is `X`. -/\n@[simps!]\ndef kernelBiprodSndIso : kernel (biprod.snd : X ⊞ Y ⟶ Y) ≅ X :=\n  limit.isoLimitCone ⟨_, biprod.isKernelSndKernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.instHasCokernelInl","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.Limits.HasCokernel CategoryTheory.Limits.biprod.inl","decl":"instance : HasCokernel (biprod.inl : X ⟶ X ⊞ Y) :=\n  HasColimit.mk ⟨_, biprod.isCokernelInlCokernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiprodInlIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq CategoryTheory.Limits.cokernelBiprodInlIso.hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.inl 0) (CategoryTheory.Limits.biprod.inlCokernelCofork X Y))","decl":"/-- The cokernel of `biprod.inl : X ⟶ X ⊞ Y` is `Y`. -/\n@[simps!]\ndef cokernelBiprodInlIso : cokernel (biprod.inl : X ⟶ X ⊞ Y) ≅ Y :=\n  colimit.isoColimitCocone ⟨_, biprod.isCokernelInlCokernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiprodInlIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq CategoryTheory.Limits.cokernelBiprodInlIso.inv ((CategoryTheory.Limits.biprod.isCokernelInlCokernelFork X Y).desc (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.inl 0)))","decl":"/-- The cokernel of `biprod.inl : X ⟶ X ⊞ Y` is `Y`. -/\n@[simps!]\ndef cokernelBiprodInlIso : cokernel (biprod.inl : X ⟶ X ⊞ Y) ≅ Y :=\n  colimit.isoColimitCocone ⟨_, biprod.isCokernelInlCokernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.instHasCokernelInr","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ CategoryTheory.Limits.HasCokernel CategoryTheory.Limits.biprod.inr","decl":"instance : HasCokernel (biprod.inr : Y ⟶ X ⊞ Y) :=\n  HasColimit.mk ⟨_, biprod.isCokernelInrCokernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiprodInrIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq CategoryTheory.Limits.cokernelBiprodInrIso.hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.inr 0) (CategoryTheory.Limits.biprod.inrCokernelCofork X Y))","decl":"/-- The cokernel of `biprod.inr : Y ⟶ X ⊞ Y` is `X`. -/\n@[simps!]\ndef cokernelBiprodInrIso : cokernel (biprod.inr : Y ⟶ X ⊞ Y) ≅ X :=\n  colimit.isoColimitCocone ⟨_, biprod.isCokernelInrCokernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.cokernelBiprodInrIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\n⊢ Eq CategoryTheory.Limits.cokernelBiprodInrIso.inv ((CategoryTheory.Limits.biprod.isCokernelInrCokernelFork X Y).desc (CategoryTheory.Limits.colimit.cocone (CategoryTheory.Limits.parallelPair CategoryTheory.Limits.biprod.inr 0)))","decl":"/-- The cokernel of `biprod.inr : Y ⟶ X ⊞ Y` is `X`. -/\n@[simps!]\ndef cokernelBiprodInrIso : cokernel (biprod.inr : Y ⟶ X ⊞ Y) ≅ X :=\n  colimit.isoColimitCocone ⟨_, biprod.isCokernelInrCokernelFork X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.isoBiprodZero_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nhY : CategoryTheory.Limits.IsZero Y\n⊢ Eq (CategoryTheory.Limits.isoBiprodZero hY).hom CategoryTheory.Limits.biprod.inl","decl":"/-- If `Y` is a zero object, `X ≅ X ⊞ Y` for any `X`. -/\n@[simps!]\ndef isoBiprodZero {X Y : C} [HasBinaryBiproduct X Y] (hY : IsZero Y) : X ≅ X ⊞ Y where\n  hom := biprod.inl\n  inv := biprod.fst\n  inv_hom_id := by\n    apply CategoryTheory.Limits.biprod.hom_ext <;>\n      simp only [Category.assoc, biprod.inl_fst, Category.comp_id, Category.id_comp, biprod.inl_snd,\n        comp_zero]\n    apply hY.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.isoBiprodZero_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nhY : CategoryTheory.Limits.IsZero Y\n⊢ Eq (CategoryTheory.Limits.isoBiprodZero hY).inv CategoryTheory.Limits.biprod.fst","decl":"/-- If `Y` is a zero object, `X ≅ X ⊞ Y` for any `X`. -/\n@[simps!]\ndef isoBiprodZero {X Y : C} [HasBinaryBiproduct X Y] (hY : IsZero Y) : X ≅ X ⊞ Y where\n  hom := biprod.inl\n  inv := biprod.fst\n  inv_hom_id := by\n    apply CategoryTheory.Limits.biprod.hom_ext <;>\n      simp only [Category.assoc, biprod.inl_fst, Category.comp_id, Category.id_comp, biprod.inl_snd,\n        comp_zero]\n    apply hY.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.isoZeroBiprod_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nhY : CategoryTheory.Limits.IsZero X\n⊢ Eq (CategoryTheory.Limits.isoZeroBiprod hY).inv CategoryTheory.Limits.biprod.snd","decl":"/-- If `X` is a zero object, `Y ≅ X ⊞ Y` for any `Y`. -/\n@[simps]\ndef isoZeroBiprod {X Y : C} [HasBinaryBiproduct X Y] (hY : IsZero X) : Y ≅ X ⊞ Y where\n  hom := biprod.inr\n  inv := biprod.snd\n  inv_hom_id := by\n    apply CategoryTheory.Limits.biprod.hom_ext <;>\n      simp only [Category.assoc, biprod.inr_snd, Category.comp_id, Category.id_comp, biprod.inr_fst,\n        comp_zero]\n    apply hY.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.isoZeroBiprod_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct X Y\nhY : CategoryTheory.Limits.IsZero X\n⊢ Eq (CategoryTheory.Limits.isoZeroBiprod hY).hom CategoryTheory.Limits.biprod.inr","decl":"/-- If `X` is a zero object, `Y ≅ X ⊞ Y` for any `Y`. -/\n@[simps]\ndef isoZeroBiprod {X Y : C} [HasBinaryBiproduct X Y] (hY : IsZero X) : Y ≅ X ⊞ Y where\n  hom := biprod.inr\n  inv := biprod.snd\n  inv_hom_id := by\n    apply CategoryTheory.Limits.biprod.hom_ext <;>\n      simp only [Category.assoc, biprod.inr_snd, Category.comp_id, Category.id_comp, biprod.inr_fst,\n        comp_zero]\n    apply hY.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.biprod_isZero_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nA B : C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct A B\n⊢ Iff (CategoryTheory.Limits.IsZero (CategoryTheory.Limits.biprod A B)) (And (CategoryTheory.Limits.IsZero A) (CategoryTheory.Limits.IsZero B))","decl":"@[simp]\nlemma biprod_isZero_iff (A B : C) [HasBinaryBiproduct A B] :\n    IsZero (biprod A B) ↔ IsZero A ∧ IsZero B := by\n  constructor\n  · intro h\n    simp only [IsZero.iff_id_eq_zero] at h ⊢\n    simp only [show 𝟙 A = biprod.inl ≫ 𝟙 (A ⊞ B) ≫ biprod.fst by simp,\n      show 𝟙 B = biprod.inr ≫ 𝟙 (A ⊞ B) ≫ biprod.snd by simp, h, zero_comp, comp_zero,\n      and_self]\n  · rintro ⟨hA, hB⟩\n    rw [IsZero.iff_id_eq_zero]\n    apply biprod.hom_ext\n    · apply hA.eq_of_tgt\n    · apply hB.eq_of_tgt\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\n⊢ Eq (CategoryTheory.Limits.biprod.braiding P Q).inv (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst)","decl":"/-- The braiding isomorphism which swaps a binary biproduct. -/\n@[simps]\ndef biprod.braiding (P Q : C) : P ⊞ Q ≅ Q ⊞ P where\n  hom := biprod.lift biprod.snd biprod.fst\n  inv := biprod.lift biprod.snd biprod.fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\n⊢ Eq (CategoryTheory.Limits.biprod.braiding P Q).hom (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst)","decl":"/-- The braiding isomorphism which swaps a binary biproduct. -/\n@[simps]\ndef biprod.braiding (P Q : C) : P ⊞ Q ≅ Q ⊞ P where\n  hom := biprod.lift biprod.snd biprod.fst\n  inv := biprod.lift biprod.snd biprod.fst\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding'_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\n⊢ Eq (CategoryTheory.Limits.biprod.braiding' P Q).inv (CategoryTheory.Limits.biprod.desc CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.inl)","decl":"/-- An alternative formula for the braiding isomorphism which swaps a binary biproduct,\nusing the fact that the biproduct is a coproduct.\n-/\n@[simps]\ndef biprod.braiding' (P Q : C) : P ⊞ Q ≅ Q ⊞ P where\n  hom := biprod.desc biprod.inr biprod.inl\n  inv := biprod.desc biprod.inr biprod.inl\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding'_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\n⊢ Eq (CategoryTheory.Limits.biprod.braiding' P Q).hom (CategoryTheory.Limits.biprod.desc CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.inl)","decl":"/-- An alternative formula for the braiding isomorphism which swaps a binary biproduct,\nusing the fact that the biproduct is a coproduct.\n-/\n@[simps]\ndef biprod.braiding' (P Q : C) : P ⊞ Q ≅ Q ⊞ P where\n  hom := biprod.desc biprod.inr biprod.inl\n  inv := biprod.desc biprod.inr biprod.inl\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding'_eq_braiding","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\n⊢ Eq (CategoryTheory.Limits.biprod.braiding' P Q) (CategoryTheory.Limits.biprod.braiding P Q)","decl":"theorem biprod.braiding'_eq_braiding {P Q : C} : biprod.braiding' P Q = biprod.braiding P Q := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.braid_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z✝ W\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod W Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding Y W).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding X Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map g f) h))","decl":"/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.braid_natural {W X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ W) :\n    biprod.map f g ≫ (biprod.braiding _ _).hom = (biprod.braiding _ _).hom ≫ biprod.map g f := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.braid_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.Limits.biprod.braiding Y W).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding X Z).hom (CategoryTheory.Limits.biprod.map g f))","decl":"/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.braid_natural {W X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ W) :\n    biprod.map f g ≫ (biprod.braiding _ _).hom = (biprod.braiding _ _).hom ≫ biprod.map g f := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding_map_braiding_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z✝ : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod Z✝ Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding X W).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding Y Z✝).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map g f) h)","decl":"@[reassoc]\ntheorem biprod.braiding_map_braiding {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) :\n    (biprod.braiding X W).hom ≫ biprod.map f g ≫ (biprod.braiding Y Z).hom = biprod.map g f := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.braiding_map_braiding","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding X W).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f g) (CategoryTheory.Limits.biprod.braiding Y Z).hom)) (CategoryTheory.Limits.biprod.map g f)","decl":"@[reassoc]\ntheorem biprod.braiding_map_braiding {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) :\n    (biprod.braiding X W).hom ≫ biprod.map f g ≫ (biprod.braiding Y Z).hom = biprod.map g f := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.symmetry'","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst) (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod P Q))","decl":"@[reassoc (attr := simp)]\ntheorem biprod.symmetry' (P Q : C) :\n    biprod.lift biprod.snd biprod.fst ≫ biprod.lift biprod.snd biprod.fst = 𝟙 (P ⊞ Q) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.symmetry'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q Z : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod P Q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem biprod.symmetry' (P Q : C) :\n    biprod.lift biprod.snd biprod.fst ≫ biprod.lift biprod.snd biprod.fst = 𝟙 (P ⊞ Q) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding P Q).hom (CategoryTheory.Limits.biprod.braiding Q P).hom) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod P Q))","decl":"/-- The braiding isomorphism is symmetric. -/\n@[reassoc]\ntheorem biprod.symmetry (P Q : C) :\n    (biprod.braiding P Q).hom ≫ (biprod.braiding Q P).hom = 𝟙 _ := by simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.symmetry_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q Z : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod P Q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding P Q).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.braiding Q P).hom h)) h","decl":"/-- The braiding isomorphism is symmetric. -/\n@[reassoc]\ntheorem biprod.symmetry (P Q : C) :\n    (biprod.braiding P Q).hom ≫ (biprod.braiding Q P).hom = 𝟙 _ := by simp\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q R : C\n⊢ Eq (CategoryTheory.Limits.biprod.associator P Q R).hom (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.fst) (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.snd) CategoryTheory.Limits.biprod.snd))","decl":"/-- The associator isomorphism which associates a binary biproduct. -/\n@[simps]\ndef biprod.associator (P Q R : C) : (P ⊞ Q) ⊞ R ≅ P ⊞ (Q ⊞ R) where\n  hom := biprod.lift (biprod.fst ≫ biprod.fst) (biprod.lift (biprod.fst ≫ biprod.snd) biprod.snd)\n  inv := biprod.lift (biprod.lift biprod.fst (biprod.snd ≫ biprod.fst)) (biprod.snd ≫ biprod.snd)\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nP Q R : C\n⊢ Eq (CategoryTheory.Limits.biprod.associator P Q R).inv (CategoryTheory.Limits.biprod.lift (CategoryTheory.Limits.biprod.lift CategoryTheory.Limits.biprod.fst (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd CategoryTheory.Limits.biprod.snd))","decl":"/-- The associator isomorphism which associates a binary biproduct. -/\n@[simps]\ndef biprod.associator (P Q R : C) : (P ⊞ Q) ⊞ R ≅ P ⊞ (Q ⊞ R) where\n  hom := biprod.lift (biprod.fst ≫ biprod.fst) (biprod.lift (biprod.fst ≫ biprod.snd) biprod.snd)\n  inv := biprod.lift (biprod.lift biprod.fst (biprod.snd ≫ biprod.fst)) (biprod.snd ≫ biprod.snd)\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nU V W X Y Z : C\nf : Quiver.Hom U X\ng : Quiver.Hom V Y\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map (CategoryTheory.Limits.biprod.map f g) h) (CategoryTheory.Limits.biprod.associator X Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator U V W).hom (CategoryTheory.Limits.biprod.map f (CategoryTheory.Limits.biprod.map g h)))","decl":"/-- The associator isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.associator_natural {U V W X Y Z : C} (f : U ⟶ X) (g : V ⟶ Y) (h : W ⟶ Z) :\n    biprod.map (biprod.map f g) h ≫ (biprod.associator _ _ _).hom\n      = (biprod.associator _ _ _).hom ≫ biprod.map f (biprod.map g h) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nU V W X Y Z✝ : C\nf : Quiver.Hom U X\ng : Quiver.Hom V Y\nh✝ : Quiver.Hom W Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod X (CategoryTheory.Limits.biprod Y Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map (CategoryTheory.Limits.biprod.map f g) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator X Y Z✝).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator U V W).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f (CategoryTheory.Limits.biprod.map g h✝)) h))","decl":"/-- The associator isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.associator_natural {U V W X Y Z : C} (f : U ⟶ X) (g : V ⟶ Y) (h : W ⟶ Z) :\n    biprod.map (biprod.map f g) h ≫ (biprod.associator _ _ _).hom\n      = (biprod.associator _ _ _).hom ≫ biprod.map f (biprod.map g h) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_inv_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nU V W X Y Z✝ : C\nf : Quiver.Hom U X\ng : Quiver.Hom V Y\nh✝ : Quiver.Hom W Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biprod (CategoryTheory.Limits.biprod X Y) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f (CategoryTheory.Limits.biprod.map g h✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator X Y Z✝).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator U V W).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map (CategoryTheory.Limits.biprod.map f g) h✝) h))","decl":"/-- The associator isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.associator_inv_natural {U V W X Y Z : C} (f : U ⟶ X) (g : V ⟶ Y) (h : W ⟶ Z) :\n    biprod.map f (biprod.map g h) ≫ (biprod.associator _ _ _).inv\n      = (biprod.associator _ _ _).inv ≫ biprod.map (biprod.map f g) h := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.biprod.associator_inv_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nU V W X Y Z : C\nf : Quiver.Hom U X\ng : Quiver.Hom V Y\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.map f (CategoryTheory.Limits.biprod.map g h)) (CategoryTheory.Limits.biprod.associator X Y Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.associator U V W).inv (CategoryTheory.Limits.biprod.map (CategoryTheory.Limits.biprod.map f g) h))","decl":"/-- The associator isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem biprod.associator_inv_natural {U V W X Y Z : C} (f : U ⟶ X) (g : V ⟶ Y) (h : W ⟶ Z) :\n    biprod.map f (biprod.map g h) ≫ (biprod.associator _ _ _).inv\n      = (biprod.associator _ _ _).inv ≫ biprod.map (biprod.map f g) h := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.isIso_left_of_isIso_biprod_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)\n⊢ CategoryTheory.IsIso f","decl":"/-- If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `f` is invertible.\n-/\ntheorem isIso_left_of_isIso_biprod_map {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z)\n    [IsIso (biprod.map f g)] : IsIso f :=\n  ⟨⟨biprod.inl ≫ inv (biprod.map f g) ≫ biprod.fst,\n      ⟨by\n        have t := congrArg (fun p : W ⊞ X ⟶ W ⊞ X => biprod.inl ≫ p ≫ biprod.fst)\n          (IsIso.hom_inv_id (biprod.map f g))\n        simp only [Category.id_comp, Category.assoc, biprod.inl_map_assoc] at t\n        simp [t], by\n        have t := congrArg (fun p : Y ⊞ Z ⟶ Y ⊞ Z => biprod.inl ≫ p ≫ biprod.fst)\n          (IsIso.inv_hom_id (biprod.map f g))\n        simp only [Category.id_comp, Category.assoc, biprod.map_fst] at t\n        simp only [Category.assoc]\n        simp [t]⟩⟩⟩\n\n"}
{"name":"CategoryTheory.isIso_right_of_isIso_biprod_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Biproducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)\n⊢ CategoryTheory.IsIso g","decl":"/-- If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `g` is invertible.\n-/\ntheorem isIso_right_of_isIso_biprod_map {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z)\n    [IsIso (biprod.map f g)] : IsIso g :=\n  letI : IsIso (biprod.map g f) := by\n    rw [← biprod.braiding_map_braiding]\n    infer_instance\n  isIso_left_of_isIso_biprod_map g f\n\n"}
